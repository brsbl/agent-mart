{
  "author": {
    "id": "neill-k",
    "display_name": "Neill Killgore",
    "avatar_url": "https://avatars.githubusercontent.com/u/1945256?v=4"
  },
  "marketplaces": [
    {
      "name": "neills-skills",
      "version": null,
      "description": "Production-grade skills for Claude Code: ExecPlan for structured planning and REPL-Driven Development for Clojure 1.12",
      "repo_full_name": "neill-k/cc-skills",
      "repo_url": "https://github.com/neill-k/cc-skills",
      "repo_description": "Skills marketplace for Claude Code featuring ExecPlan and REPL-Driven Development for Clojure 1.12",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-09T20:37:12Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"neills-skills\",\n  \"owner\": {\n    \"name\": \"Neill Killgore\"\n  },\n  \"metadata\": {\n    \"description\": \"Production-grade skills for Claude Code: ExecPlan for structured planning and REPL-Driven Development for Clojure 1.12\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"neills-skills\",\n      \"description\": \"Core skills plugin with ExecPlan and REPL-Driven Development\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/development/exec-plan\",\n        \"./skills/development/repl-driven-clojure\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"neills-skills\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Production-grade skills for Claude Code: ExecPlan for structured planning and REPL-Driven Development for Clojure 1.12\",\n  \"author\": {\n    \"name\": \"Neill Killgore\"\n  },\n  \"homepage\": \"https://github.com/neill-k/cc-skills\",\n  \"repository\": \"https://github.com/neill-k/cc-skills.git\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"skills\", \"exec-plan\", \"clojure\", \"repl\", \"development\", \"planning\"]\n}\n",
        "README.md": "# CC Skills Marketplace\n\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Version](https://img.shields.io/badge/version-1.0.0-green.svg)](https://github.com/neill-k/cc-skills/releases)\n[![Skills](https://img.shields.io/badge/skills-2-orange.svg)](#available-skills)\n\n> A skills marketplace for Claude Code featuring production-grade development methodologies: ExecPlan for structured task planning and REPL-Driven Development for interactive Clojure programming\n\n## ‚ú® Features\n\n### ExecPlan\n- **üìã Structured Planning**: Living work plans for complex development tasks\n- **üìä Progress Tracking**: Checkbox-tracked steps with timestamps and velocity metrics\n- **üìù Decision Logging**: Capture important choices, rationale, and trade-offs\n- **üîç Discovery Documentation**: Log surprises, discoveries, and lessons learned\n- **‚úÖ Verification Steps**: Concrete validation for every change\n\n### REPL-Driven Development (Clojure)\n- **‚ö° Live Coding**: Immediate feedback with Clojure 1.12 REPL workflow\n- **üí¨ Rich Comment Blocks**: Living documentation and interactive exploration\n- **üîÑ State Management**: Mount, Integrant, Component patterns for long-running sessions\n- **üéØ Bottom-Up Design**: Build and compose small functions with continuous testing\n- **üîç Data Inspection**: Portal, tap>, and CIDER integration for visualization\n- **üß™ TDD Integration**: Combine REPL exploration with test-driven development\n\n### Marketplace\n- **üîç Smart Discovery**: Browse, search, and filter skills by category and tags\n- **üì¶ Easy Installation**: Simple commands to install and activate skills\n- **üöÄ Ready to Use**: Production-grade skills with comprehensive examples\n\n## üìã Table of Contents\n\n- [Installation](#installation)\n- [Quick Start](#quick-start)\n- [Available Commands](#available-commands)\n- [Available Skills](#available-skills)\n- [Usage Examples](#usage-examples)\n- [Creating Your Own Skills](#creating-your-own-skills)\n- [Contributing](#contributing)\n- [License](#license)\n\n## üöÄ Installation\n\n### Step 1: Add the Marketplace\n\nIn Claude Code, register this marketplace:\n\n```bash\n/plugin marketplace add neill-k/cc-skills\n```\n\nReplace `your-org` with your actual GitHub organization or username.\n\n### Step 2: Install the Plugin\n\n```bash\n/plugin install neills-skills@your-org\n```\n\n### Step 3: Verify Installation\n\nRun the skills command to see the marketplace:\n\n```bash\n/skills\n```\n\nYou should see a welcome message with available commands.\n\n## üèÉ Quick Start\n\n### Browse All Available Skills\n\n```bash\n/skills-browse\n```\n\nThis displays all skills organized by category with descriptions, difficulty levels, and installation commands.\n\n### Search for Specific Skills\n\n```bash\n/skills-search testing\n```\n\nFind skills related to testing, or search for any topic:\n\n```bash\n/skills-search code review\n/skills-search productivity\n/skills-search api\n```\n\n### Get Detailed Information\n\n```bash\n/skills-info task-breakdown\n```\n\nView comprehensive information about a specific skill including usage guidance and examples.\n\n### Install a Skill\n\n```bash\n/skills-install task-breakdown\n```\n\nOnce installed, simply mention the skill in your requests:\n- \"Use the Task Breakdown skill to plan this feature\"\n- \"Apply Code Review Checklist to this PR\"\n\n## üìö Available Commands\n\n| Command | Description |\n|---------|-------------|\n| `/skills` | Main hub - overview and quick start guide |\n| `/skills-browse` | Browse all skills by category |\n| `/skills-search <query>` | Search skills by name, tags, or description |\n| `/skills-info <skill-id>` | Get detailed information about a skill |\n| `/skills-install <skill-id>` | Install a skill to your environment |\n\n## üé® Available Skills\n\n### üíª Development (2 skills)\n\n#### ‚≠ê ExecPlan\nCreate structured, living work plans for complex coding tasks with progress tracking, decision logs, and verification steps.\n\n- **ID**: `exec-plan`\n- **Difficulty**: Intermediate\n- **Time**: 10-20 minutes to create plan, ongoing for updates\n- **Install**: `/skills-install exec-plan`\n\n**What is ExecPlan?**\n\nExecPlan is a planning methodology that transforms complex development work from chaotic improvisation into structured, trackable, and repeatable execution. It provides a comprehensive framework for:\n\n- **Task-Scoped Work Plans**: Break down features, refactorings, and bug fixes into concrete steps\n- **Living Documentation**: Plans that evolve with your work, not static documents\n- **Progress Visibility**: Checkbox tracking with timestamps and velocity metrics\n- **Decision Capture**: Log important choices, rationale, and trade-offs as you make them\n- **Discovery Documentation**: Record surprises, optimizations, and lessons learned\n- **Verification Steps**: Every change has a concrete way to validate it works\n\n**When to Use ExecPlan:**\n\n- Implementing new features (especially multi-file changes)\n- Planning significant refactorings\n- Debugging complex, systemic issues\n- Coordinating team development work\n- Maintaining long-running development sessions\n- Any task that will take more than a few hours\n\n**ExecPlan Structure:**\n\nEvery plan includes:\n1. **Metadata** - Ownership, dates, status tracking\n2. **Purpose & Success Criteria** - What you're building and why\n3. **Context & Orientation** - Current state, key files, terminology\n4. **Plan of Work** - Concrete steps with verification\n5. **Progress Tracking** - Real-time completion status\n6. **Surprises & Discoveries** - Unexpected findings\n7. **Decision Log** - Material choices with rationale\n8. **Outcomes & Retrospective** - Results and lessons learned\n\n---\n\n#### ‚≠ê REPL-Driven Development with Clojure\nMaster REPL-driven development workflow for Clojure 1.12 with live coding, rich comment blocks, state management, and iterative design.\n\n- **ID**: `repl-driven-clojure`\n- **Difficulty**: Intermediate\n- **Time**: 15-30 minutes to learn, ongoing practice\n- **Install**: `/skills-install repl-driven-clojure`\n\n**What is REPL-Driven Development?**\n\nREPL-Driven Development is an interactive programming approach that provides immediate feedback as you write code. This skill covers the complete Clojure 1.12 workflow with modern best practices:\n\n- **Live Coding**: Write functions and test them instantly in the REPL\n- **Rich Comment Blocks**: Document explorations with `(comment ...)` forms\n- **State Management**: Handle long-running sessions with Mount, Integrant, or Component\n- **Bottom-Up Design**: Build small, tested functions and compose into larger systems\n- **Data Inspection**: Visualize data with Portal, tap>, and CIDER inspector\n- **Clojure 1.12 Features**: Method values, qualified methods, param tags, array syntax\n\n**When to Use REPL-Driven Development:**\n\n- Writing any Clojure code (it's the standard workflow)\n- Exploring new libraries or APIs\n- Debugging complex data transformations\n- Building systems incrementally\n- Rapid prototyping and experimentation\n- Learning Clojure or onboarding new developers\n- Combining with TDD for robust development\n\n**Key Techniques Covered:**\n\n1. **REPL Workflow** - Read, Evaluate, Print, Loop cycle\n2. **Rich Comment Blocks** - Living documentation and examples\n3. **Design Journals** - Document decisions and rationale\n4. **State Management** - Mount, Integrant, Component patterns\n5. **Namespace Management** - Reloading and refresh strategies\n6. **Data Inspection** - Portal, tap>, CIDER inspector\n7. **Performance** - Criterium benchmarking\n8. **Debugging** - Scope capture and tap debugging\n9. **Editor Integration** - CIDER, Calva, Cursive workflows\n10. **Common Pitfalls** - Stale state, circular deps, side effects\n\n---\n\n## üí° Usage Examples\n\n### Example 1: Planning a New Feature\n\n```\nYou: I need to add API rate limiting to protect against abuse\n\nClaude: I'll create an ExecPlan to structure this implementation.\n\n[Claude generates comprehensive plan with:]\n- Current state analysis (no rate limiting, experiencing abuse)\n- Phases: Infrastructure Setup ‚Üí Middleware ‚Üí Integration ‚Üí Testing\n- Specific file changes (package.json, config/limits.ts, middleware/rateLimit.ts)\n- Verification steps for each change\n- Progress tracking with checkboxes\n- Decision log for algorithm choice (token bucket vs fixed window)\n```\n\n### Example 2: Complex Refactoring\n\n```\nYou: This authentication module is a mess with 800 lines in one file. Help me refactor it.\n\nClaude: Let me create an ExecPlan for this refactoring to ensure we maintain behavior.\n\n[Claude provides structured plan with:]\n- Context: Current pain points and why refactoring is needed\n- Incremental steps that preserve functionality\n- Test-first approach to validate behavior\n- Progress tracking for each extraction\n- Surprises section to document unexpected dependencies\n```\n\n### Example 3: Debugging Systemic Issues\n\n```\nYou: Users are reporting intermittent 500 errors. Help me debug this.\n\nClaude: I'll create an ExecPlan for systematic investigation and resolution.\n\n[Claude creates plan with:]\n- Hypothesis section for potential root causes\n- Investigation steps with verification at each stage\n- Fix implementation once root cause is identified\n- Monitoring and validation steps\n- Decision log for chosen solution approach\n```\n\n### Example 4: Coordinating Multi-File Changes\n\n```\nYou: We're migrating from REST to GraphQL across the entire API surface.\n\nClaude: This is complex. Let me create an ExecPlan to coordinate all the changes.\n\n[Claude develops comprehensive migration plan:]\n- Complete file inventory with dependencies\n- Migration phases with rollback points\n- Parallel work opportunities for team members\n- Integration testing strategy\n- Handoff notes for deployment and monitoring\n```\n\n### Example 5: Clojure REPL-Driven Feature Development\n\n```\nYou: I need to build a user authentication system in Clojure. Help me use REPL-driven development.\n\nClaude: I'll guide you through building this feature with REPL-driven development using Clojure 1.12.\n\n[Claude provides interactive workflow:]\n1. Start REPL and connect your editor\n2. Define data specs for validation\n3. Build hash-password function, test in REPL immediately\n4. Create register-user function with inline testing\n5. Build authenticate function, verify with mock data\n6. Use rich comment blocks to document experiments\n7. Codify successful experiments as formal tests\n8. Integrate with state management (Mount/Integrant)\n\n[Shows complete code with rich comment blocks demonstrating:]\n- Spec validation tested interactively\n- Password hashing verified in REPL\n- Mock database for rapid iteration\n- Authentication flow tested with various inputs\n- Final test suite based on REPL explorations\n```\n\n### Example 6: Exploring Clojure 1.12 Features\n\n```\nYou: Show me how to use the new Clojure 1.12 qualified method syntax.\n\nClaude: I'll demonstrate Clojure 1.12's unified method syntax with REPL examples.\n\n[Claude provides interactive examples:]\n- Qualified instance methods: (String/length \"hello\")\n- Method values as functions: (map String/length [\"foo\" \"bar\"])\n- Constructor syntax: (java.util.ArrayList/new)\n- Param tags for type hints\n- Array class syntax updates (String* vs String-*)\n- Complete REPL session showing real usage patterns\n```\n\n## üõ†Ô∏è Creating Your Own Skills\n\nWant to add custom skills to the marketplace? Here's how:\n\n### Skill Structure\n\nEach skill is a markdown file with YAML frontmatter:\n\n```markdown\n---\nname: my-skill\ndescription: Brief description of what the skill does and when to use it\n---\n\n# My Skill Name\n\nWhen the user [trigger conditions], use this skill to [what the skill does].\n\n## When to Use This Skill\n\nActivate this skill when the user:\n- [Condition 1]\n- [Condition 2]\n- [Condition 3]\n\n## Instructions\n\n[Detailed instructions for Claude to follow when this skill is activated]\n\n## Output Format\n\n[Expected output structure]\n\n## Best Practices\n\n### DO:\n- ‚úÖ [Best practice 1]\n- ‚úÖ [Best practice 2]\n\n### DON'T:\n- ‚ùå [Anti-pattern 1]\n- ‚ùå [Anti-pattern 2]\n\n## Examples\n\n[Concrete examples of the skill in action]\n```\n\n### Adding Your Skill\n\n1. **Create the skill file** in the appropriate category directory:\n   - `skills/productivity/my-skill.md`\n   - `skills/development/my-skill.md`\n   - `skills/testing/my-skill.md`\n   - `skills/documentation/my-skill.md`\n\n2. **Update the registry** in `registry/skills-catalog.json`:\n\n```json\n{\n  \"id\": \"my-skill\",\n  \"name\": \"My Skill Name\",\n  \"description\": \"Brief description\",\n  \"category\": \"productivity\",\n  \"author\": \"Your Name\",\n  \"version\": \"1.0.0\",\n  \"tags\": [\"tag1\", \"tag2\"],\n  \"path\": \"skills/productivity/my-skill.md\",\n  \"featured\": false,\n  \"difficulty\": \"beginner\",\n  \"estimatedTime\": \"5-10 minutes\"\n}\n```\n\n3. **Test your skill** by installing and using it\n\n4. **Submit a pull request** (see Contributing section)\n\n## ü§ù Contributing\n\nContributions are welcome! We're looking for:\n\n- **New skills** across all categories\n- **Improvements** to existing skills\n- **Bug fixes** in commands or registry\n- **Documentation** enhancements\n- **Examples** and use cases\n\n### How to Contribute\n\n1. **Fork the repository**\n\n2. **Create a feature branch**\n   ```bash\n   git checkout -b feature/new-skill-name\n   ```\n\n3. **Make your changes**\n   - Add new skills or improve existing ones\n   - Update the registry if adding/modifying skills\n   - Test your changes\n\n4. **Commit your changes**\n   ```bash\n   git commit -m 'Add new skill: [skill-name]'\n   ```\n\n5. **Push to your fork**\n   ```bash\n   git push origin feature/new-skill-name\n   ```\n\n6. **Open a Pull Request**\n   - Describe your changes\n   - Explain why the skill is useful\n   - Include examples of the skill in action\n\n### Skill Quality Guidelines\n\nSkills should be:\n- ‚úÖ **Clear**: Easy to understand and follow\n- ‚úÖ **Comprehensive**: Cover all important cases\n- ‚úÖ **Practical**: Solve real-world problems\n- ‚úÖ **Well-structured**: Follow the skill template\n- ‚úÖ **Production-ready**: Include best practices and examples\n- ‚úÖ **Tested**: Verified to work as intended\n\n## üìä Marketplace Stats\n\n- **Total Skills**: 2\n- **Categories**: 4 (Productivity, Development, Testing, Documentation)\n- **Featured Skills**: 2 (ExecPlan, REPL-Driven Development)\n- **Difficulty Levels**: Intermediate (2)\n- **Languages Covered**: Language-agnostic (ExecPlan), Clojure 1.12 (REPL-Driven)\n\n## üó∫Ô∏è Roadmap\n\n### v1.1 (Planned)\n- [ ] Add ExecPlan templates for common scenarios (API development, refactoring, bug fixes)\n- [ ] REPL-Driven Development templates for common Clojure patterns\n- [ ] Additional Clojure skills: spec-driven development, test.check property testing\n- [ ] Create ExecPlan CLI tool for easier plan management\n- [ ] Add plan archiving and retrieval system\n\n### v1.2 (Planned)\n- [ ] Add 5-10 additional skills across all categories\n- [ ] Productivity: Task breakdown, meeting notes, time tracking\n- [ ] Testing: Test generation, coverage analysis, TDD workflows\n- [ ] Documentation: README generation, API docs, code documentation\n- [ ] More language-specific REPL workflows (Python, JavaScript, Elixir)\n- [ ] Implement skill dependencies and skill collections\n\n### v2.0 (Future)\n- [ ] ExecPlan analytics (velocity tracking, completion patterns)\n- [ ] REPL session recording and replay\n- [ ] Team collaboration features (shared plans, handoffs)\n- [ ] Integration with project management tools\n- [ ] Plan diff and version history\n- [ ] Multi-language support for international teams\n- [ ] Interactive skill tutorials and guided walkthroughs\n\n## üìÑ License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## üÜò Support\n\n### Getting Help\n\n- **Documentation**: See individual skill files for detailed usage\n- **Issues**: [GitHub Issues](https://github.com/neill-k/cc-skills/issues)\n- **Discussions**: [GitHub Discussions](https://github.com/neill-k/cc-skills/discussions)\n\n### Frequently Asked Questions\n\n**Q: How do I activate a skill after installing it?**\nA: Simply mention the skill by name in your request to Claude. For example:\n- \"Create an ExecPlan for implementing user authentication\"\n- \"Use REPL-Driven Development to build this Clojure feature\"\n- \"Guide me through the REPL workflow for this problem\"\n\n**Q: Where should I store ExecPlans?**\nA: Recommended structure is `.agents/[feature-name]/PLAN.md` for feature-specific plans, with a template at `.agents/template/PLAN.md`. Quick iterations can go in `.agents/tmp/` (add to `.gitignore`).\n\n**Q: Do I need to complete every section of an ExecPlan?**\nA: Core sections (Metadata, Description, Purpose, Context, Plan, Progress) are essential. Risks/Open Questions and Handoff Notes are optional. Adapt based on your needs - solo projects need less than team projects.\n\n**Q: Do I need to know Clojure to use the REPL-Driven Development skill?**\nA: Basic Clojure knowledge helps, but this skill includes explanations of Clojure 1.12 features and can guide beginners through REPL workflows. It's useful for both learning and mastering advanced techniques.\n\n**Q: Which Clojure editors work with the REPL-Driven skill?**\nA: The skill covers CIDER (Emacs), Calva (VS Code), and Cursive (IntelliJ) with specific key bindings and workflows for each. Choose the editor you're comfortable with.\n\n**Q: Can I use these skills together?**\nA: Absolutely! Use ExecPlan to structure a complex Clojure project, then apply REPL-Driven Development techniques during implementation. They complement each other perfectly.\n\n**Q: How do I update a skill?**\nA: Currently, re-install with `/skills-install <skill-id>`. Automatic updates are planned for v1.2.\n\n**Q: Can I customize skills for my team?**\nA: Yes! Fork this repository and modify the skill files or create your own. Your team can install from your private marketplace.\n\n**Q: Should I use ExecPlan for small tasks?**\nA: ExecPlan is designed for complex tasks (multi-file changes, long-running work). For simple tasks under a few hours, it may be overkill. Use your judgment.\n\n**Q: How long should ExecPlan sessions last?**\nA: The methodology has enabled successful sessions of 30+ minutes up to 1 hour. Break very large projects into multiple ExecPlans (one per feature/phase).\n\n**Q: Are skills free?**\nA: Yes, all skills in this marketplace are open-source and free to use under the MIT license.\n\n## üôè Acknowledgments\n\n- Inspired by the [Anthropic Skills Repository](https://github.com/anthropics/skills)\n- Built for the [Claude Code](https://claude.ai/code) community\n- Thanks to all contributors who have added skills and improvements\n\n---\n\n**Made with ‚ù§Ô∏è for the Claude Code community**\n\nStart exploring: `/skills-browse` or `/skills-search <topic>`\n"
      },
      "plugins": [
        {
          "name": "neills-skills",
          "description": "Core skills plugin with ExecPlan and REPL-Driven Development",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/development/exec-plan",
            "./skills/development/repl-driven-clojure"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add neill-k/cc-skills",
            "/plugin install neills-skills@neills-skills"
          ]
        }
      ]
    }
  ]
}