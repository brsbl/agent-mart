{
  "author": {
    "id": "mconcat",
    "display_name": "mconcat",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/67312570?u=7cb5b88c223333a2e09679b21ccdb23a5c9ad740&v=4",
    "url": "https://github.com/mconcat",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 7,
      "total_skills": 3,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "mastermind",
      "version": null,
      "description": "Multi-project progress tracking via Claude Code session analysis",
      "owner_info": {
        "name": "mconcat"
      },
      "keywords": [],
      "repo_full_name": "mconcat/mastermind",
      "repo_url": "https://github.com/mconcat/mastermind",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-16T16:27:32Z",
        "created_at": "2026-01-16T16:26:22Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 574
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 264
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 4957
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/conversation-analyzer.md",
          "type": "blob",
          "size": 14465
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/add.md",
          "type": "blob",
          "size": 2675
        },
        {
          "path": "commands/daily.md",
          "type": "blob",
          "size": 3087
        },
        {
          "path": "commands/init.md",
          "type": "blob",
          "size": 2241
        },
        {
          "path": "commands/overview.md",
          "type": "blob",
          "size": 1831
        },
        {
          "path": "commands/plan.md",
          "type": "blob",
          "size": 2480
        },
        {
          "path": "commands/status.md",
          "type": "blob",
          "size": 2528
        },
        {
          "path": "commands/sync.md",
          "type": "blob",
          "size": 8208
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/mastermind",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/mastermind/SKILL.md",
          "type": "blob",
          "size": 4991
        },
        {
          "path": "skills/mastermind/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/mastermind/references/report-properties.md",
          "type": "blob",
          "size": 3414
        },
        {
          "path": "skills/mastermind/references/vault-structure.md",
          "type": "blob",
          "size": 3303
        },
        {
          "path": "skills/satellite",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/satellite/INSTALL.md",
          "type": "blob",
          "size": 1580
        },
        {
          "path": "skills/satellite/SKILL.md",
          "type": "blob",
          "size": 2220
        },
        {
          "path": "skills/spec-writer",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/spec-writer/SKILL.md",
          "type": "blob",
          "size": 4374
        },
        {
          "path": "skills/spec-writer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/spec-writer/references/spec-properties.md",
          "type": "blob",
          "size": 6093
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"mastermind\",\n  \"owner\": {\n    \"name\": \"mconcat\"\n  },\n  \"metadata\": {\n    \"description\": \"Multi-project progress tracking via Claude Code session analysis\",\n    \"version\": \"0.1.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"mm\",\n      \"source\": \"./\",\n      \"description\": \"Multi-project progress tracking and management via Claude Code session analysis\",\n      \"version\": \"0.1.0\",\n      \"author\": {\n        \"name\": \"mconcat\"\n      },\n      \"keywords\": [\"project-management\", \"session-tracking\", \"progress\", \"obsidian\"],\n      \"category\": \"productivity\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"mm\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Multi-project progress tracking and management via Claude Code session analysis\",\n  \"author\": {\n    \"name\": \"mconcat\"\n  },\n  \"keywords\": [\"project-management\", \"session-tracking\", \"progress\", \"obsidian\"]\n}\n",
        "README.md": "# Mastermind\n\nA Claude Code plugin for tracking progress across multiple projects via session analysis.\n\n## What It Does\n\nMastermind analyzes your Claude Code conversation history and generates structured reports. It helps you:\n\n- **Track what you've done** across multiple projects\n- **Remember decisions** and their rationale\n- **Surface patterns** in how you work\n- **Maintain context** when switching between projects\n\nAll data is stored as markdown files—works great with Obsidian or any text editor.\n\n## Prerequisites\n\n- [Claude Code](https://claude.ai/code) installed\n- `jq` for JSON processing: `brew install jq` (macOS) or `apt install jq` (Linux)\n\n## Installation\n\n### From GitHub\n\n```bash\n# Clone the repository\ngit clone https://github.com/mconcat/mastermind\ncd mastermind\n\n# Install the plugin\n/plugin install mm@mastermind\n```\n\n### For Development\n\n```bash\n# Load plugin for current session only\nclaude --plugin ./path/to/mastermind\n```\n\n## Quick Start\n\n```bash\n# 1. Initialize your vault (stores all mastermind data)\n/mm:init ~/Documents/vault\n\n# 2. Register projects to track\n/mm:add my-webapp ~/projects/my-webapp\n/mm:add rust-lib ~/projects/rust-lib\n\n# 3. Sync your Claude Code session history\n/mm:sync\n\n# 4. View project status\n/mm:overview\n```\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/mm:init <vault-path>` | Initialize a new vault |\n| `/mm:add <name> <path>` | Register a project to monitor |\n| `/mm:sync [project]` | Analyze new sessions, generate reports |\n| `/mm:overview` | Dashboard of all monitored projects |\n| `/mm:status <project>` | Deep dive on one project |\n| `/mm:plan [project]` | Create or update project spec |\n| `/mm:daily` | Generate cross-project daily digest |\n\n**All commands work from any directory.**\n\n## Vault Structure\n\nAfter running `/mm:init`, your vault contains:\n\n```\nvault/\n├── config.yaml                     # Project registry\n├── state/\n│   └── sync-state.yaml             # Sync tracking\n├── projects/\n│   └── my-webapp/\n│       ├── spec.md                 # Project specification\n│       ├── status.md               # Current state summary\n│       └── sessions/\n│           ├── 2026-01-15-implementing-auth.md\n│           └── 2026-01-16-fixing-token-refresh.md\n└── daily/\n    └── 2026-01-16.md               # Daily digest\n```\n\nSession reports use a `YYYY-MM-DD-title.md` naming convention for easy sorting and discovery.\n\n## Session Reports\n\nReports are generated automatically from your Claude Code conversations. Each report captures:\n\n- **Summary**: What the session accomplished\n- **Decisions**: Technical choices and rationale\n- **Issues & Fixes**: Problems encountered and solutions\n- **Learnings**: Insights for future work\n- **Unfinished Work**: What's left to do\n\nReports are written as readable narratives, not rigid templates.\n\n### Example Report\n\n```markdown\n# Implementing JWT Authentication\n\n**Project**: my-webapp\n**Date**: 2026-01-15\n**Session ID**: `a1b2c3d4-...`\n\nThis session focused on adding JWT-based authentication. The implementation\nwent smoothly until token refresh became an issue—users were getting logged\nout on page refresh.\n\n**The fix**: Store refresh tokens in httpOnly cookies instead of localStorage.\nThis prevents XSS attacks while maintaining session persistence.\n\n**Learnings**:\n- Auth state lives in AuthContext provider\n- Browser dev tools network tab is essential for debugging auth flows\n```\n\n## Workflow\n\n1. **Work normally** with Claude Code on your projects\n2. **Sync periodically**: Run `/mm:sync` at the end of work sessions\n3. **Review reports**: Check `projects/*/sessions/` for insights\n4. **Update specs**: Use `/mm:plan` when project direction changes\n5. **Daily digest**: Run `/mm:daily` for cross-project summary\n\n## Configuration\n\n### Vault Location\n\nStored in `~/.claude/mastermind.local.md`:\n\n```markdown\n# Mastermind Configuration\nvault: ~/Documents/vault\n```\n\n### Project Registry\n\nIn your vault's `config.yaml`:\n\n```yaml\nprojects:\n  my-webapp:\n    path: ~/projects/my-webapp\n    description: React web application\n  rust-lib:\n    path: ~/projects/rust-lib\n    description: Data processing library\n```\n\n## How It Works\n\n1. Claude Code stores your conversations in `~/.claude/projects/`\n2. `/mm:sync` discovers new sessions and filters them to essential content\n3. Analyzer agents read each session and generate narrative reports\n4. Reports are saved to your vault with timestamps and descriptive titles\n5. State tracking ensures only new content is processed on subsequent syncs\n\n## Tips\n\n- **Sync regularly**: Run `/mm:sync` at the end of each work session\n- **Keep specs updated**: Your spec is the source of truth for project direction\n- **Read your reports**: They often surface patterns you didn't notice while working\n- **Use with Obsidian**: The vault is just markdown—link between reports freely\n\n## License\n\nMIT\n",
        "agents/conversation-analyzer.md": "---\nmodel: sonnet\ncolor: blue\ntools: [\"Read\"]\nwhenToUse: |\n  This agent is called programmatically by the /mm:sync command to analyze Claude Code\n  session history. It is NOT triggered by user queries - it is spawned as a subagent\n  to process conversation JSONL files and generate structured reports.\n\n  <example>\n  Context: The /mm:sync command has identified a new conversation to analyze\n  user: [Internal call from sync command with JSONL path]\n  assistant: Spawns conversation-analyzer agent to process the file\n  </example>\n---\n\n# Conversation Analyzer Agent\n\nYou are a specialized subagent for analyzing Claude Code conversation history and generating insightful reports.\n\n## CRITICAL: Trust the Input Format\n\n**The file you receive is ALREADY pre-filtered by the main agent.** Do NOT:\n\n- Attempt to \"understand\" or \"check\" the JSONL structure\n- Parse raw Claude Code format (you won't receive it)\n- Wonder about missing fields (they were intentionally stripped)\n- Try alternative parsing approaches\n\n**The format is exactly as documented below. Trust it and read directly.**\n\nYour ONLY tool is `Read`. Use it to read the file in chunks. The JSON format is simple:\n```json\n{\"type\":\"user\",\"ts\":\"2026-01-08T05:27\",\"text\":\"...\"}\n{\"type\":\"assistant\",\"ts\":\"2026-01-08T05:28\",\"text\":\"...\"}\n{\"type\":\"summary\",\"text\":\"...\"}\n```\n\nIf you see different structure, the main agent made an error - but that's not your problem to solve. Analyze what you receive.\n\n## Input Format\n\nThe file you receive is pre-filtered JSONL with one JSON object per line. Each record has 2-3 fields:\n\n```json\n{\"type\":\"user\",\"ts\":\"2026-01-08T05:27\",\"text\":\"Fix the bug in authentication\"}\n{\"type\":\"assistant\",\"ts\":\"2026-01-08T05:28\",\"text\":\"I'll investigate the auth module...\"}\n{\"type\":\"summary\",\"text\":\"Fixed authentication bug and added tests\"}\n```\n\nFields:\n- `type`: \"user\", \"assistant\", or \"summary\"\n- `ts`: Timestamp (truncated to minute)\n- `text`: The message content\n\nRead the file directly with the Read tool. You understand JSON natively - just comprehend the structure as you read.\n\n## Role in the Sync Process\n\nYou are spawned by the main `/mm:sync` agent to analyze ONE conversation file. The main agent:\n1. Discovers which sessions need processing\n2. Spawns you (and other analyzer agents in parallel) with specific file paths\n3. Collects your returned report\n4. Writes reports to the vault (you do NOT write files)\n\n**Your job**: Read the ENTIRE JSONL file using only the Read tool, understand every message, and RETURN a comprehensive markdown report.\n\n**Why you exist**: Session files can be 50-100MB with 10,000+ messages. The main agent cannot read these without filling its context. You have dedicated context specifically to read ONE full conversation thoroughly.\n\n## Input\n\nYou will receive a prompt like:\n```\nAnalyze this Claude Code conversation and generate a report.\n\nFiltered JSONL file: /tmp/mm-a1b2c3d4.jsonl\nProject name: my-project\nSession ID: a1b2c3d4-...\n\nThis file contains only user messages and summary records (pre-filtered).\nRead it with the Read tool and generate a report.\n```\n\n**Important**: The file you receive is PRE-FILTERED to minimal JSON by the main agent. Each record has only the essential fields (`type`, `ts`, `text`). All metadata, tool calls, tool results, and thinking blocks have been stripped out (typically 95-98% smaller than the original).\n\nParameters:\n- `jsonl_path`: Absolute path to the filtered JSONL file (in /tmp/)\n- `project_name`: Name of the project this conversation belongs to\n- `session_id`: The session UUID\n\n## Task\n\n1. **Read the ENTIRE JSONL file using only the Read tool** - Iterate with offset until you've read every line. No bash, no scripts.\n2. **Understand the JSON directly** - Each line is JSON text. You can read and comprehend it natively.\n3. **Track key information** - Goals, decisions, problems, resolutions, sentiment, continuations.\n4. **Synthesize into a report** - After reading everything, write a comprehensive narrative report.\n5. **RETURN the report** - Output the markdown as your response. Do NOT write files.\n\nThe main agent will handle writing the report to the vault.\n\n## JSONL Format (Minimal)\n\nThe file contains simplified records with only essential fields:\n\n### User Messages\n```json\n{\"type\":\"user\",\"ts\":\"2026-01-15T14:30\",\"text\":\"What's the status of the auth module?\"}\n```\n\n### Assistant Messages\n```json\n{\"type\":\"assistant\",\"ts\":\"2026-01-15T14:31\",\"text\":\"Let me check the auth module for you...\"}\n```\n\n### Summary Records\nWhen Claude's context fills up, a summary is created:\n```json\n{\"type\":\"summary\",\"text\":\"Implemented user authentication with JWT tokens. Fixed token refresh bug.\"}\n```\n\n### Session Continuation Messages\n\nWhen a session is continued after context reset, look for user messages where `text` starts with:\n`\"This session is being continued from a previous conversation that ran out of context.\"`\n\nThese contain valuable summaries of prior work and indicate the session spans multiple context windows.\n\n### Low-Value Messages to Skim\n\nAs you read, you'll notice some messages have empty or minimal `text`:\n- Empty user messages (`\"text\":\"\"`) - just tool confirmations\n- Messages that say `[Request interrupted by user]`\n\nFocus on substantive messages where `text` has real content. But still READ everything.\n\n## Reading the Full Conversation\n\n**You MUST read the entire conversation file.** This is why you exist as a subagent - you have dedicated context to process one complete conversation thoroughly. Do NOT sample or skip content.\n\n### Reading Strategy\n\nRead in chunks of ~200 lines using offset:\n\n```\nRead(file_path=\"/path/to/session.jsonl\", limit=200)                    → lines 1-200\nRead(file_path=\"/path/to/session.jsonl\", offset=200, limit=200)        → lines 201-400\nRead(file_path=\"/path/to/session.jsonl\", offset=400, limit=200)        → lines 401-600\n... continue until Read returns fewer lines than your limit (end of file)\n```\n\nIf some sections are token-dense (long code blocks), reduce chunk size to 50-100 lines for that section.\n\n### What to Track While Reading\n\nAs you read through the file, build understanding of:\n\n- **Timeline**: First timestamp → last timestamp, any multi-day gaps\n- **Goals**: What was the user trying to accomplish? (look at early user messages)\n- **Key decisions**: Architectural choices, approach selections (look for \"let's\", \"decided\", \"going with\")\n- **Problems**: Errors, bugs, blockers (look for error messages, \"not working\", \"failed\")\n- **Resolutions**: How problems were solved\n- **User sentiment**: Frustrations (\"still\", \"again\", \"why\"), preferences\n- **Continuation points**: `type: \"summary\"` records and messages containing \"continued from a previous conversation\"\n- **Outcome**: What state was the work left in?\n\n### Which Records to Focus On\n\n| Record Type | Action |\n|------------|--------|\n| `\"type\": \"user\"` | **Read carefully** - shows what user asked for |\n| `\"type\": \"assistant\"` | **Read** - explanations, decisions, reasoning |\n| `\"type\": \"summary\"` | **Read carefully** - compressed history from context compaction |\n\nNote: Tool calls, tool results, thinking blocks, and all metadata have been stripped out. You're seeing only the essential text content.\n\n### After Reading Everything\n\nOnce you've read the complete file, synthesize your understanding into a coherent narrative report.\n\n## Properties to Extract\n\nYour report must capture these properties **when present**:\n\n### Goal\nWhat was the user trying to accomplish?\n- Look at early user messages for intent\n- Note if the goal evolved during the session\n\n### Outcome\nWhat was achieved?\n- Success: Goal fully met\n- Partial: Some progress\n- Blocked: Hit obstacle\n- Pivoted: Changed direction\n\n### Decisions\nTechnical/architectural choices made:\n- What was decided\n- Why (look for rationale in assistant responses)\n- What alternatives were considered\n\n### Issues & Fixes\nProblems encountered and resolutions:\n- Symptoms observed\n- Root causes discovered\n- How they were fixed\n- Quote specific code if the fix is non-obvious\n\n### User Frustrations\nPain points expressed:\n- Look for: \"still not working\", \"again\", \"why\", frustration markers\n- Repeated attempts at the same thing\n- Long debugging sequences\n\n### User Preferences\nStyle/approach preferences revealed:\n- Code style choices\n- Architectural preferences\n- Tool preferences\n\n### Significant Code\nCode worth quoting verbatim:\n- Bug fixes (before/after)\n- Architectural patterns established\n- Tricky configurations\n- Error messages that led to insights\n\n**Quote criteria**: Only quote code that would help someone understand what happened or how to handle similar situations. Don't quote routine code.\n\n### Unfinished Work\nTasks left incomplete:\n- What wasn't finished\n- Why (time, blocked, deprioritized)\n- What would be needed to complete\n\n### Learnings\nInsights for future sessions:\n- How this codebase works\n- Effective debugging approaches\n- Patterns discovered\n- Things to remember\n\n## Report Format\n\nWrite as a **readable narrative** like a technical blog post or lab notebook entry. NOT a rigid template with empty sections.\n\n**Required structure** - reports MUST start with YAML frontmatter:\n```markdown\n---\nfilename: 2026-01-15-implementing-jwt-authentication.md\ndate: 2026-01-15\ntitle: Implementing JWT Authentication\n---\n# Implementing JWT Authentication\n\n**Project**: [name]\n**Date**: [date range]\n**Session ID**: `[uuid]`\n\n[Opening paragraph: what this session was about and the outcome]\n\n[Body: flowing narrative covering the work done, organized naturally]\n\n[If significant code]: inline code blocks with context\n\n[Closing: learnings, unfinished work, what's next]\n```\n\n### Filename Convention\n\nThe `filename` field in frontmatter is **critical** - the main agent uses it to save the report.\n\n**Format**: `YYYY-MM-DD-descriptive-title.md`\n\n- **Date**: Use the session's START date (from first timestamp)\n- **Title**: Hyphen-connected summary of what the session accomplished\n- **Length**: Maximum 10 words (excluding date)\n- **Style**: Lowercase, no special characters except hyphens\n\n**Good filenames**:\n```\n2026-01-15-implementing-jwt-authentication.md\n2026-01-08-fixing-auth-token-refresh-bug.md\n2026-01-10-designing-two-tier-agent-architecture.md\n2026-01-12-debugging-session-discovery-issues.md\n```\n\n**Bad filenames**:\n```\n❌ deep-swinging-flamingo.md          (random slug, no date)\n❌ 2026-01-15-session.md              (not descriptive)\n❌ 2026-01-15-Implementing-JWT.md     (uppercase)\n❌ 2026-01-15-implemented-the-jwt-authentication-system-for-secure-user-login-with-refresh-tokens.md  (too long)\n```\n\nThe title should capture the PRIMARY accomplishment or focus. If a session covered multiple topics, pick the most significant one.\n\n**Adaptive structure**:\n- Short session → brief narrative\n- Debugging session → focus on issue diagnosis and fix\n- Feature implementation → focus on decisions and patterns\n- Exploratory session → focus on learnings and discoveries\n\n## Writing Guidelines\n\n**DO**:\n- Write in third person (\"The user wanted to...\", \"The session focused on...\")\n- Be specific about what happened\n- Include context for code quotes\n- Capture the user's voice when they express frustrations/preferences\n- Vary structure based on content\n\n**DON'T**:\n- Force empty sections\n- Include every routine detail\n- Quote large blocks of unremarkable code\n- Lose the narrative thread\n- Use vague summaries (\"worked on stuff\")\n\n## Example Report\n\n```markdown\n---\nfilename: 2026-01-15-implementing-jwt-authentication.md\ndate: 2026-01-15\ntitle: Implementing JWT Authentication\n---\n# Implementing JWT Authentication\n\n**Project**: my-webapp\n**Date**: 2026-01-15\n**Session ID**: `a1b2c3d4-5678-90ab-cdef-1234567890ab`\n\nThis session focused on implementing JWT-based authentication for the web application.\nThe user came in with a clear goal: add login functionality with secure token handling.\n\nThe implementation went smoothly until session persistence became an issue. Users were\ngetting logged out on page refresh despite valid tokens. After debugging, the root cause\nwas identified: the token was being stored in memory state rather than persisted storage.\n\n**The fix** involved moving token storage to httpOnly cookies:\n\n```typescript\n// Before: Token lost on refresh\nconst [token, setToken] = useState<string | null>(null);\n\n// After: Persisted in httpOnly cookie (set by server)\n// Client just checks cookie existence, server validates\n```\n\nA key decision was made during this session: **refresh tokens will use httpOnly cookies\nrather than localStorage**. The user explicitly chose security over convenience, noting\nthat \"XSS attacks are too common to risk storing tokens in JS-accessible storage.\"\n\nThe session ended with login working but logout not yet implemented. The user noted\nthis as the next priority.\n\n**Learnings**:\n- For this codebase, authentication state lives in the AuthContext provider\n- The existing middleware pattern makes adding auth checks straightforward\n- Browser dev tools network tab is essential for debugging auth flows\n```\n\n## Handling Edge Cases\n\n**Very short sessions** (< 5 exchanges):\nBrief paragraph covering what happened. Don't pad.\n\n**Sessions with many tool calls**:\nSummarize the exploration, don't list every file read.\n\n**Sessions that ended in frustration**:\nBe honest about what didn't work. Capture the blocking issue clearly.\n\n**Resumed sessions** (same sessionId, later timestamps):\nTreat as one logical session. Note if there was a gap.\n\n**Agent sub-conversations** (isSidechain: true):\nThese are sub-agents spawned during the session. Include their work in the overall narrative if significant.\n\n## Output\n\n**RETURN the report as your final response.** Do NOT write to any file.\n\nYour response should be the complete markdown report WITH YAML FRONTMATTER, ready for the main agent to save. The main agent will parse the `filename` field from frontmatter to determine where to save.\n\nThe main agent will:\n1. Receive your returned report\n2. Parse the YAML frontmatter to extract `filename`\n3. Save to `projects/[project]/sessions/[filename]`\n\n**Required response format:**\n```\n---\nfilename: YYYY-MM-DD-descriptive-title.md\ndate: YYYY-MM-DD\ntitle: Descriptive Title\n---\n# Descriptive Title\n\n**Project**: my-project\n**Date**: 2026-01-15\n**Session ID**: `a1b2c3d4-...`\n\n[Your analysis here...]\n```\n\n**The frontmatter is mandatory.** Without it, the main agent cannot determine the filename.\n",
        "commands/add.md": "---\nname: add\ndescription: Register a new project to monitor\nargument-hint: \"<name> <path>\"\nallowed-tools: [\"Read\", \"Write\", \"Bash\"]\n---\n\n# /mm:add - Add Project to Monitor\n\nRegister a new project directory for mastermind to track.\n\n**Works from any directory** - reads vault location from global config.\n\n## Prerequisites\n\nThis command requires mastermind to be initialized. If `~/.claude/mastermind.local.md` doesn't exist, prompt the user to run `/mm:init <vault-path>` first.\n\n## Behavior\n\n1. **Parse Arguments**\n   - `<name>`: Short identifier for the project (e.g., \"my-webapp\")\n   - `<path>`: Absolute path to the project directory\n\n2. **Validate**\n   - Check that path exists and is a directory\n   - Check that project name isn't already registered\n   - Warn if path doesn't appear to be a code project (no common project files)\n\n3. **Update Configuration**\n   - Read existing `config.yaml` (or create if doesn't exist)\n   - Add new project entry\n   - Write updated config\n\n4. **Create Project Directory Structure**\n   In the vault, create:\n   ```\n   projects/[name]/\n   ├── spec.md        # Empty template\n   ├── status.md      # Initial status\n   └── sessions/      # Empty directory\n   ```\n\n5. **Confirm and Suggest Next Steps**\n   - Confirm project added\n   - Suggest running `/mm:plan [name]` to create spec\n   - Suggest running `/mm:sync [name]` to pull existing session history\n\n## Arguments\n\n- `<name>`: Required. Short project identifier (kebab-case recommended)\n- `<path>`: Required. Absolute path to project directory\n\n## Examples\n\n```\n/mm:add my-webapp /home/user/projects/my-webapp\n/mm:add rust-lib /home/user/code/rust-library\n```\n\n## config.yaml Format\n\n```yaml\nprojects:\n  my-webapp:\n    path: /home/user/projects/my-webapp\n    description: React web application  # optional, can add later\n  rust-lib:\n    path: /home/user/code/rust-library\n```\n\n## Initial spec.md Template\n\n```markdown\n# [Project Name] Specification\n\n**Created**: [date]\n**Last Updated**: [date]\n\n## Purpose\n\n[To be defined - run /mm:plan to fill this in]\n\n## Scope\n\n### In Scope\n- [To be defined]\n\n### Out of Scope\n- [To be defined]\n\n## Success Criteria\n\n[To be defined]\n\n## Current Phase\n\n[To be defined]\n```\n\n## Initial status.md\n\n```markdown\n# [Project Name] Status\n\n**Last Updated**: [date]\n**Last Synced**: Never\n\n## Current State\n\nProject registered but not yet synced. Run `/mm:sync [name]` to pull session history.\n```\n\n## Error Handling\n\n- If path doesn't exist: Error with message\n- If name already exists: Error, suggest different name or update existing\n- If path already registered under different name: Warn but allow (same project, different alias)\n",
        "commands/daily.md": "---\nname: daily\ndescription: Generate cross-project daily digest\nallowed-tools: [\"Read\", \"Write\", \"Glob\"]\n---\n\n# /mm:daily - Daily Digest\n\nGenerate a cross-project summary of today's work across all monitored projects.\n\n**Works from any directory** - reads vault location from global config.\n\n## Prerequisites\n\nThis command requires mastermind to be initialized. If `~/.claude/mastermind.local.md` doesn't exist, prompt the user to run `/mm:init <vault-path>` first.\n\n## Behavior\n\n1. **Determine Date**\n   - Use today's date by default\n   - Could accept optional date argument for historical digests\n\n2. **Gather Today's Activity**\n   For each monitored project:\n   - Find session reports from today (`projects/[name]/sessions/`)\n   - Read recent status updates\n   - Extract key activities, decisions, blockers\n\n3. **Generate Digest**\n   Create a readable summary covering:\n   - High-level summary of the day\n   - Per-project summaries\n   - Key decisions made today (across all projects)\n   - Blockers encountered\n   - Suggested focus for tomorrow\n\n4. **Write Digest**\n   - Write to `daily/[YYYY-MM-DD].md`\n   - Update any cross-references if needed\n\n## Output Location\n\n`daily/2026-01-16.md` (for today's date)\n\n## Digest Format\n\nThe digest should read like a brief status report:\n\n```markdown\n# Daily Digest: 2026-01-16\n\n## Summary\n\nProductive day across 2 projects. Made significant progress on authentication\nin my-webapp and resolved the SSA closure bugs in rust-library. No major\nblockers remaining.\n\n## my-webapp\n\nWorked on user authentication flow. Key accomplishments:\n- Implemented JWT token handling\n- Added refresh token rotation\n- Fixed session persistence issue\n\nDecision: Chose to store refresh tokens in httpOnly cookies rather than\nlocalStorage for security.\n\n## rust-library\n\nContinued SSA IR implementation. Key accomplishments:\n- Fixed 3 closure capture edge cases\n- Added test coverage for nested functions\n- Identified one remaining issue with loop variables\n\nBlocker resolved: The \"borrowed as mutable\" error was due to capture timing,\nfixed by cloning before the loop.\n\n## Key Decisions\n\n1. **my-webapp**: HttpOnly cookies for refresh tokens (security over convenience)\n2. **rust-library**: Clone captured variables pre-loop (correctness over performance)\n\n## Tomorrow\n\nSuggested focus:\n- my-webapp: Add logout flow and token revocation\n- rust-library: Fix remaining loop variable capture issue, then optimization pass\n\n## Time Spent\n\n- my-webapp: ~3 hours (2 sessions)\n- rust-library: ~4 hours (3 sessions)\n```\n\n## If No Activity Today\n\nIf no sessions from today:\n- Report \"No activity recorded today\"\n- Show when last activity occurred for each project\n- Don't create an empty digest file\n\n## Aggregation Logic\n\n**Key Decisions**: Extract from session reports where decisions were documented.\n\n**Blockers**:\n- Current blockers: Still unresolved at end of day\n- Resolved blockers: Were blockers but got fixed today\n\n**Tomorrow Suggestions**: Based on:\n- Unfinished work from today's sessions\n- Current blockers that need attention\n- Next items from spec/roadmap\n",
        "commands/init.md": "---\nname: init\ndescription: Initialize a new mastermind vault\nargument-hint: \"<vault-path>\"\nallowed-tools: [\"Read\", \"Write\", \"Bash\", \"AskUserQuestion\"]\n---\n\n# /mm:init - Initialize Mastermind Vault\n\nSet up a new mastermind vault at the specified path. This is the first command new users should run.\n\n## Behavior\n\n1. **Parse Arguments**\n   - `<vault-path>`: Where to create the vault (e.g., `~/Documents/vault`)\n   - If not provided, ask the user where they want the vault\n\n2. **Create Vault Structure**\n   ```\n   [vault-path]/\n   ├── config.yaml         # Project registry\n   ├── .gitignore          # Standard ignores\n   ├── state/              # Sync state tracking\n   ├── projects/           # Project specs and session reports\n   └── daily/              # Daily digests\n   ```\n\n3. **Create Initial Files**\n\n   **config.yaml**:\n   ```yaml\n   # Mastermind Configuration\n   # Add projects with /mm:add <name> <path>\n\n   projects: {}\n   ```\n\n   **.gitignore**:\n   ```\n   # State files (machine-specific)\n   state/\n\n   # Local config\n   *.local.md\n\n   # OS files\n   .DS_Store\n   Thumbs.db\n   ```\n\n4. **Configure Global Settings**\n   Write `~/.claude/mastermind.local.md`:\n   ```markdown\n   # Mastermind Configuration\n   vault: [absolute-vault-path]\n   ```\n\n5. **Confirm Setup**\n   - Show what was created\n   - Explain next steps:\n     - `/mm:add <name> <path>` to register projects\n     - `/mm:sync` to pull session history\n     - `/mm:plan <project>` to create specs\n\n## Arguments\n\n- `<vault-path>`: Required. Path where vault will be created. Supports `~` expansion.\n\n## Examples\n\n```\n/mm:init ~/Documents/mastermind\n/mm:init ~/vault\n/mm:init /home/user/vault\n```\n\n## Path Handling\n\n- Expand `~` to home directory\n- Convert to absolute path for storage in config\n- Create parent directories if needed\n\n## If Vault Already Exists\n\nIf the path already contains vault files:\n- Ask user if they want to use existing vault\n- If yes, just update `~/.claude/mastermind.local.md` to point to it\n- If no, ask for different path\n\n## Error Handling\n\n- If path is not writable: Error with explanation\n- If `~/.claude/` doesn't exist: Create it\n- If `mastermind.local.md` already exists: Ask to overwrite or keep existing\n",
        "commands/overview.md": "---\nname: overview\ndescription: Dashboard of all monitored projects\nallowed-tools: [\"Read\", \"Glob\"]\n---\n\n# /mm:overview - Project Dashboard\n\nDisplay a dashboard overview of all monitored projects.\n\n**Works from any directory** - reads vault location from global config.\n\n## Prerequisites\n\nThis command requires mastermind to be initialized. If `~/.claude/mastermind.local.md` doesn't exist, prompt the user to run `/mm:init <vault-path>` first.\n\n## Behavior\n\n1. **Read Configuration**\n   - Load vault path from `~/.claude/mastermind.local.md`\n   - Read `config.yaml` to get project list\n\n2. **Gather Project Status**\n   For each project:\n   - Read `projects/[name]/status.md` for current state\n   - Read `projects/[name]/spec.md` for current phase\n   - Count recent session reports in `projects/[name]/sessions/`\n\n3. **Present Dashboard**\n   Display summary table with:\n   - Project name\n   - Current phase (from spec)\n   - Last activity date\n   - Recent session count\n   - Status summary (active work, blockers)\n\n## Output Format\n\nPresent as a readable summary:\n\n```\n## Mastermind Overview\n\n### my-webapp\n**Phase**: MVP Development\n**Last Activity**: 2026-01-15\n**Recent Sessions**: 3\n\nCurrent focus: Implementing user authentication\nBlockers: None\n\n---\n\n### rust-library\n**Phase**: Optimization\n**Last Activity**: 2026-01-14\n**Recent Sessions**: 5\n\nCurrent focus: SSA IR implementation\nBlockers: Closure capture edge cases\n\n---\n\n## Cross-Project Notes\n- 2 projects with recent activity\n- 1 project has blockers\n```\n\n## When Projects Are Missing\n\nIf a project in config.yaml has no vault data yet:\n- Show as \"Not yet synced\"\n- Suggest running `/mm:sync`\n\n## If No Projects Configured\n\nIf config.yaml doesn't exist or is empty:\n- Explain that no projects are monitored yet\n- Suggest running `/mm:add <name> <path>` to add projects\n",
        "commands/plan.md": "---\nname: plan\ndescription: Create or update a project specification\nargument-hint: \"[project]\"\nallowed-tools: [\"Read\", \"Write\", \"AskUserQuestion\", \"Glob\"]\n---\n\n# /mm:plan - Project Specification\n\nInteractively create or update a project specification using the spec-writer skill.\n\n**Works from any directory** - reads vault location from global config.\n\n## Prerequisites\n\nThis command requires mastermind to be initialized. If `~/.claude/mastermind.local.md` doesn't exist, prompt the user to run `/mm:init <vault-path>` first.\n\n## Behavior\n\n1. **Determine Project**\n   - If project argument provided, use that\n   - Otherwise, ask which project to plan\n\n2. **Load Existing Spec**\n   - Read `projects/[name]/spec.md` if it exists\n   - Identify which properties are already addressed\n   - Note gaps that need to be filled\n\n3. **Interactive Spec Writing**\n   Using the spec-writer skill, guide through:\n   - **Purpose**: Why does this exist?\n   - **Scope**: What's in and out?\n   - **Success Criteria**: How do we know it's working?\n   - **Current Phase**: Where are we now?\n   - Plus contextual properties as relevant\n\n4. **Validate Completeness**\n   Check that required properties are addressed:\n   - [ ] Purpose is clear and specific\n   - [ ] Scope has explicit in/out boundaries\n   - [ ] Success criteria are verifiable\n   - [ ] Current phase is defined\n\n5. **Write Spec**\n   - Write updated spec to `projects/[name]/spec.md`\n   - Preserve any existing content not being updated\n   - Add/update timestamp\n\n## Arguments\n\n- `[project]` (optional): The project to plan. If omitted, will ask.\n\n## Examples\n\n```\n/mm:plan              # Ask which project, then guide spec writing\n/mm:plan my-webapp    # Plan/update spec for my-webapp\n```\n\n## Probing Approach\n\nDon't just ask \"what's the purpose?\" - probe deeper:\n\n**Purpose**:\n- \"If this succeeds, what's different?\"\n- \"Who benefits and how?\"\n- \"What problem becomes solvable?\"\n\n**Scope**:\n- \"What will users expect that you WON'T do?\"\n- \"What's the most common misconception?\"\n- \"If you cut half the features, which half stays?\"\n\n**Success**:\n- \"How would you demo this working?\"\n- \"What would make you say 'done'?\"\n- \"What would disappoint you even if it 'works'?\"\n\n## New Project Setup\n\nIf the project directory doesn't exist in the vault:\n1. Create `projects/[name]/` directory\n2. Create initial `spec.md`\n3. Create empty `status.md`\n4. Create `sessions/` directory\n\nRemind user to run `/mm:add` if project isn't in config.yaml.\n",
        "commands/status.md": "---\nname: status\ndescription: Deep dive on one project's current state\nargument-hint: \"<project>\"\nallowed-tools: [\"Read\", \"Glob\"]\n---\n\n# /mm:status - Project Status Deep Dive\n\nShow detailed status for a specific project including spec, recent sessions, and current state.\n\n**Works from any directory** - reads vault location from global config.\n\n## Prerequisites\n\nThis command requires mastermind to be initialized. If `~/.claude/mastermind.local.md` doesn't exist, prompt the user to run `/mm:init <vault-path>` first.\n\n## Behavior\n\n1. **Determine Project**\n   - Use project argument (required)\n   - If not provided, list available projects and ask\n\n2. **Read Project Data**\n   - Load `projects/[name]/spec.md` - the specification\n   - Load `projects/[name]/status.md` - current state summary\n   - List `projects/[name]/sessions/` - recent session reports\n\n3. **Present Comprehensive View**\n\n   **Specification Summary**:\n   - Purpose (1-2 sentences)\n   - Current phase and its goals\n   - Key success criteria\n\n   **Current Status**:\n   - Active work items\n   - Known blockers\n   - Last sync date\n\n   **Recent Sessions**:\n   - List last 5 sessions with dates and brief summaries\n   - Offer to read any specific session in detail\n\n   **Patterns & Learnings**:\n   - Aggregate learnings from recent sessions\n   - Recurring issues/frustrations\n   - Effective approaches discovered\n\n## Arguments\n\n- `<project>`: Required. The project name to examine.\n\n## Examples\n\n```\n/mm:status my-webapp     # Show my-webapp status\n/mm:status rust-library  # Show rust-library status\n```\n\n## Output Format\n\n```\n# my-webapp Status\n\n## Specification\n**Purpose**: [1-2 sentence summary from spec]\n**Current Phase**: MVP Development\n**Success Criteria**: [key criteria for current phase]\n\n## Current State\n**Last Synced**: 2026-01-15\n**Active Work**: User authentication flow\n**Blockers**: None currently\n\n## Recent Sessions\n\n1. **cheerful-dancing-penguin** (2026-01-15)\n   Implemented login form, debugged session handling\n\n2. **bouncy-purple-flamingo** (2026-01-14)\n   Set up authentication backend, chose JWT approach\n\n3. **swift-coding-dolphin** (2026-01-12)\n   Initial project setup, dependency decisions\n\n## Patterns Observed\n- Recurring: Session state issues when cookies disabled\n- Effective: Using browser dev tools network tab for debugging auth\n```\n\n## If Project Not Found\n\nIf the project isn't in the vault:\n- Check if it's in config.yaml but not synced → suggest `/mm:sync`\n- If not in config.yaml → suggest `/mm:add <name> <path>`\n",
        "commands/sync.md": "---\nname: sync\ndescription: Analyze new Claude Code sessions and generate reports\nargument-hint: \"[project]\"\nallowed-tools: [\"Read\", \"Write\", \"Glob\", \"Bash\", \"Task\", \"TodoWrite\"]\n---\n\n# /mm:sync - Synchronize Session History\n\nAnalyze Claude Code session history for monitored projects and generate structured reports.\n\n**Works from any directory** - reads vault location from global config.\n\n## Exact Command Sequence\n\nExecute these steps in order. Do not add exploration or verification steps.\n\n### Step 1: Read Config (3 parallel reads)\n```\nRead ~/.claude/mastermind.local.md        → get vault path (e.g., ~/Documents/vault)\nRead {vault}/config.yaml                  → get project paths\nRead {vault}/state/sync-state.yaml        → get last sync state per session\n```\n\n### Step 2: List Sessions & Count Lines (2 bash commands)\n```bash\n# Command 1: List session files (UUID-named only, not agent-*)\nls ~/.claude/projects/{hash}/*.jsonl | grep -v '/agent-'\n\n# Command 2: Count lines in each session file\nwc -l ~/.claude/projects/{hash}/[0-9a-f]*-*-*-*-*.jsonl\n```\nWhere `{hash}` = project path with `/` → `-` (e.g., `/home/user/projects/my-app` → `-home-user-projects-my-app`)\n\n### Step 3: Identify Sessions to Process\nCompare `wc -l` output with `sync-state.yaml`:\n- Session NOT in sync-state → NEW, process it\n- Session line count > stored `message_count` → UPDATED, process it\n- Session line count == stored `message_count` → unchanged, skip it\n\n### Step 4: Pre-filter Each Session (1 bash command per session)\n```bash\njq -c '\n  if .type == \"summary\" then\n    { type: \"summary\", text: .summary }\n  elif .type == \"user\" then\n    {\n      type: \"user\",\n      ts: .timestamp[0:16],\n      text: (\n        if (.message.content | type) == \"string\" then .message.content\n        else (.message.content[] | select(.type == \"text\") | .text) // \"\"\n        end\n      )\n    }\n  elif .type == \"assistant\" then\n    (.message.content[] | select(.type == \"text\")) as $txt |\n    if $txt then\n      { type: \"assistant\", ts: .timestamp[0:16], text: $txt.text }\n    else empty\n    end\n  else empty\n  end\n' ~/.claude/projects/{hash}/{uuid}.jsonl > /tmp/mm-{uuid}.jsonl\n```\nRun this for EACH session identified in Step 3.\n\n### Step 5: Spawn Analyzer Agents (parallel Task calls)\nFor each filtered file, spawn a `mm:conversation-analyzer` agent:\n```\nTask(\n  subagent_type: \"mm:conversation-analyzer\",\n  prompt: \"Analyze /tmp/mm-{uuid}.jsonl for project {name}. Session ID: {uuid}\",\n  run_in_background: true\n)\n```\n**Launch ALL agents in a single message** (parallel execution).\n\n### Step 6: Collect Reports\n```\nTaskOutput(task_id: {agent1_id}, block: true)\nTaskOutput(task_id: {agent2_id}, block: true)\n...\n```\nEach agent returns markdown with YAML frontmatter containing the `filename`.\n\n### Step 7: Write Reports to Vault\nParse `filename` from each report's frontmatter, then:\n```\nWrite {vault}/projects/{name}/sessions/{filename}\n```\n\n### Step 8: Update Sync State\nUpdate `{vault}/state/sync-state.yaml` with new session entries:\n```yaml\n{project}:\n  last_synced: \"{now}\"\n  sessions:\n    {uuid}:\n      last_message: \"{timestamp}\"\n      message_count: {lines}\n      report: \"sessions/{filename}\"\n```\n\n### Step 9: Cleanup\n```bash\nrm /tmp/mm-*.jsonl\n```\n\n---\n\n## Prerequisites\n\nIf `~/.claude/mastermind.local.md` doesn't exist, prompt user to run `/mm:init <vault-path>` first.\n\n## Arguments\n\n- `[project]` (optional): Sync only the specified project. If omitted, sync all monitored projects.\n\n## Examples\n\n```\n/mm:sync              # Sync all monitored projects\n/mm:sync my-webapp    # Sync only my-webapp project\n```\n\n## Reference\n\n### Project Hash Mapping\n`/path/to/project` → `-path-to-project` (slashes become dashes)\n\nExample: `/home/user/projects/my-app` → `-home-user-projects-my-app`\n\n### Session File Pattern\n- Main sessions: `{uuid}.jsonl` (e.g., `5db1d5f9-9da6-474e-8e7c-38a3d0b005f9.jsonl`)\n- Sub-agents: `agent-{hash}.jsonl` (skip these)\n\n### Frontmatter Parsing\nThe analyzer returns markdown starting with:\n```yaml\n---\nfilename: 2026-01-15-descriptive-title.md\ndate: 2026-01-15\ntitle: Descriptive Title\n---\n```\nExtract `filename` field to determine output path.\n\n### JSONL Message Structure (Reference Only)\nThe jq filter in Step 4 handles all parsing. This is for understanding only:\n- `message.content` can be a string or array of content blocks\n- The jq filter extracts text from both formats automatically\n- Empty messages and tool results are filtered out\n\n### Session Continuation Detection\n\nClaude Code sessions can be continued after context limits. Look for messages containing:\n`\"This session is being continued from a previous conversation that ran out of context.\"`\n\nThese messages include summaries of prior work and indicate a logical continuation.\n\n### Session Statistics (Reference Only)\nTypical large session breakdown (no need to check this during sync):\n- ~70% assistant messages\n- ~30% user messages\n- A few summary/system/snapshot records\n\n### Incremental Sync\nOnly process sessions with file modification time > last_synced_timestamp.\n\n### Subagent Deployment Pattern\n\n**Why subagents are mandatory:**\n1. Session files can be 50-100MB with 10,000+ messages\n2. Reading a large JSONL into main context would fill it completely\n3. Main agent would lose ability to coordinate or write reports\n4. Each conversation deserves dedicated analysis context\n\n**How to spawn subagents:**\n```\n# In a SINGLE message, spawn ALL analyzer subagents in parallel:\n\n<Task tool call 1>\n  subagent_type: \"mm:conversation-analyzer\"\n  prompt: \"Analyze /tmp/mm-abc123.jsonl for project my-app...\"\n\n<Task tool call 2>\n  subagent_type: \"mm:conversation-analyzer\"\n  prompt: \"Analyze /tmp/mm-def456.jsonl for project my-app...\"\n\n<Task tool call 3>\n  subagent_type: \"mm:conversation-analyzer\"\n  prompt: \"Analyze /tmp/mm-ghi789.jsonl for project other-project...\"\n```\n\n**Subagent responsibilities:**\n- Read and parse the full JSONL file (they have dedicated context for this)\n- Extract key information per the conversation-analyzer agent spec\n- Return a markdown report (do NOT write files - main agent handles that)\n\n**Main agent responsibilities:**\n- Discover which sessions need processing (file listing, timestamps)\n- Spawn subagents with correct paths and parameters\n- Collect returned reports\n- Write/append reports to vault files\n- Update sync state\n\n### Handling Continued Sessions\n\nWhen a session exceeds context limits, Claude Code compacts it and continues. These show up as:\n- Same sessionId across multiple context windows\n- Messages containing \"This session is being continued from a previous conversation...\"\n- Summary records (`type: \"summary\"`) capturing compressed context\n\n**For continued sessions:**\n1. The subagent should note continuation points in its report\n2. Main agent checks if a report already exists for this sessionId\n3. If exists: Append new analysis under `## Continuation: [date]` header\n4. Track the latest message timestamp in sync state\n\n### Resume/Continuation Handling\n- Same `sessionId` = same logical conversation (even if resumed across days)\n- Track by session + timestamp to handle resumed conversations correctly\n- Agent files (`agent-*.jsonl`) are sub-agents spawned during the session\n- `isSidechain: true` identifies messages that are part of sub-agent execution chains\n\n## Error Handling\n\n- If `~/.claude/mastermind.local.md` not found: Guide user to run `/mm:init`\n- If vault path doesn't exist: Error, suggest re-running `/mm:init`\n- If no `config.yaml` in vault: Guide user to run `/mm:add` first\n- If project path doesn't exist: Warn and skip that project\n- If no new sessions found: Report \"No new activity\"\n- If analyzer agent fails: Log error and continue with other sessions\n\n## Troubleshooting\n\n### Report Filename Missing or Invalid\n\nIf the analyzer returns a report without valid YAML frontmatter, use a fallback filename:\n```\n{session_id[:8]}-{date}-untitled.md\n```\ne.g., `a1b2c3d4-2026-01-15-untitled.md`\n\n### jq Not Found\n\nInstall with `brew install jq` (macOS) or `apt install jq` (Linux).\n\n### Large Session Takes Too Long\n\nExpected for 100MB+ files. The jq filter is CPU-bound. Filtered output will be 95-98% smaller and fast to analyze.\n",
        "skills/mastermind/SKILL.md": "# Mastermind - Multi-Project Progress Management\n\nUse this skill when the user mentions \"mastermind\", \"track projects\", \"project overview\", \"sync sessions\", \"project progress\", or wants to manage multiple ongoing projects from a central location.\n\n---\n\n## Execution Principles\n\n**Trust the specifications. Do NOT verify documented structures.**\n\nAll mastermind commands include complete specifications for:\n- File formats (JSONL structure, YAML schema)\n- Directory layouts (vault structure, Claude session paths)\n- Data schemas (sync state, config format)\n\n**When executing a command:**\n1. Read the command specification completely\n2. Execute each step as documented\n3. Use the exact paths, formats, and commands specified\n4. Do NOT add \"exploratory\" or \"verification\" steps\n\n**Anti-patterns:**\n- Running `head`/`grep` to \"understand\" file formats already documented\n- Using `ls` to \"discover\" directory structures already specified\n- Parsing files to \"check\" schemas already defined\n- Adding preliminary investigation before following the workflow\n\n**The specifications are authoritative.** If something doesn't match, report the discrepancy - don't try to \"figure out\" the actual format through exploration.\n\n---\n\n## Overview\n\nMastermind is a markdown-based framework for tracking progress across multiple projects via Claude Code session analysis. It maintains a central \"vault\" with project specs, session reports, and daily digests.\n\n## Core Concepts\n\n**Vault**: The mastermind directory containing all tracking data. Location configured in `~/.claude/mastermind.local.md`.\n\n**Projects**: Registered directories that mastermind monitors for Claude Code session activity.\n\n**Session Reports**: Property-based narrative reports generated from Claude Code conversation history, capturing decisions, issues, learnings, and user preferences.\n\n**Specs**: Source-of-truth documents defining each project's purpose, scope, and direction.\n\n## Vault Structure\n\n```\n[vault]/\n├── config.yaml              # Project registry\n├── state/\n│   └── sync-state.yaml      # Sync tracking (last synced timestamps)\n├── projects/\n│   └── [project-name]/\n│       ├── spec.md          # Project specification\n│       ├── status.md        # Current state summary\n│       └── sessions/\n│           └── YYYY-MM-DD-descriptive-title.md    # Session reports\n└── daily/\n    └── [YYYY-MM-DD].md      # Cross-project daily digests\n```\n\n**Session filename format**: `YYYY-MM-DD-descriptive-title.md`\n- Date prefix enables chronological sorting\n- Descriptive title (max 10 words, hyphen-connected) summarizes the session\n- Example: `2026-01-15-implementing-jwt-authentication.md`\n\n## Available Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/mm:init <vault-path>` | Initialize a new vault (first-time setup) |\n| `/mm:add <name> <path>` | Register a new project to monitor |\n| `/mm:sync [project]` | Analyze new Claude Code sessions and generate reports |\n| `/mm:overview` | Dashboard of all monitored projects |\n| `/mm:status <project>` | Deep dive on one project |\n| `/mm:plan [project]` | Create or update a project spec |\n| `/mm:daily` | Generate today's cross-project digest |\n\n## Getting Started\n\n1. **Initialize vault**: `/mm:init ~/path/to/vault`\n2. **Add projects**: `/mm:add my-project /path/to/project`\n3. **Sync sessions**: `/mm:sync`\n4. **Create specs**: `/mm:plan my-project`\n\n## Configuration\n\nThe vault path is stored in `~/.claude/mastermind.local.md` (created by `/mm:init`):\n\n```markdown\n# Mastermind Configuration\nvault: /path/to/your/mastermind/vault\n```\n\n**All commands work from any directory** - they read the vault location from this config file.\n\n## Session Report Properties\n\nReports are narrative documents (like blog posts) that capture these properties when present:\n\n- **Goal**: What the user was trying to accomplish\n- **Outcome**: Success level, what was achieved\n- **Decisions**: Technical/architectural choices with rationale\n- **Issues & Fixes**: Problems encountered, root causes, solutions (with code quotes)\n- **Frustrations**: User pain points, repeated problems\n- **Preferences**: Style and approach preferences revealed\n- **Significant Code**: Verbatim quotes of important code (bugs, fixes, patterns)\n- **Unfinished Work**: Tasks left incomplete, deferred questions\n- **Learnings**: Patterns and insights for future sessions\n\n## Workflow\n\n1. **Setup**: Run `/mm:init ~/your/vault` to create vault\n2. **Add Projects**: Run `/mm:add <name> <path>` for each project to track\n3. **Work**: Do your normal development in project directories\n4. **Sync**: Periodically run `/mm:sync` (from any directory)\n5. **Review**: Read session reports, update specs with `/mm:plan`\n6. **Daily**: Generate cross-project digest with `/mm:daily`\n\nFor detailed specifications, see:\n- `references/vault-structure.md` - Complete vault format\n- `references/report-properties.md` - Session report property definitions\n",
        "skills/mastermind/references/report-properties.md": "# Session Report Properties\n\nSession reports capture the valuable information from Claude Code conversations. They are written as **readable narratives** (like technical blog posts), not rigid templates.\n\n## Core Properties\n\n### Goal\nWhat was the user trying to accomplish in this session?\n\n- Extract from initial user messages\n- May evolve during the session\n- Note if goal shifted or was refined\n\n### Outcome\nWhat was actually achieved?\n\n- Success: Goal fully accomplished\n- Partial: Some progress, work remains\n- Blocked: Hit an obstacle that prevented progress\n- Pivoted: Changed direction based on discoveries\n\n### Decisions\nTechnical and architectural choices made during the session.\n\n- What was decided\n- Why (rationale, tradeoffs considered)\n- Alternatives that were rejected\n- Impact on future work\n\n### Issues & Fixes\nProblems encountered and how they were resolved.\n\nFor each significant issue:\n- **Symptom**: What was observed\n- **Root cause**: What was actually wrong\n- **Fix**: How it was resolved\n- **Code quote**: If the fix is non-obvious, quote the relevant code\n\n### User Frustrations\nPain points and frustrations expressed by the user.\n\nIndicators:\n- \"still not working\", \"again\", \"why does this keep...\"\n- Repeated attempts at the same thing\n- Expressions of confusion or annoyance\n\nCapture:\n- What caused the frustration\n- Whether it was resolved\n- Patterns (recurring frustrations suggest systemic issues)\n\n### User Preferences\nStyle and approach preferences revealed during work.\n\n- Code style preferences\n- Architectural preferences (simple vs. flexible, explicit vs. implicit)\n- Tool preferences\n- Communication style preferences\n\n### Significant Code\nCode worth quoting verbatim in the report.\n\nQuote code when:\n- It's a bug fix (show before/after or just the fix)\n- It establishes an architectural pattern\n- It's a workaround for a known issue\n- It's a configuration that was tricky to get right\n- The error message was key to diagnosis\n\nDon't quote code when:\n- It's routine/obvious\n- It's just exploration\n- It would be too long without adding value\n\n### Unfinished Work\nTasks that were started but not completed.\n\n- What was left incomplete\n- Why (ran out of time, blocked, deprioritized)\n- What would be needed to complete it\n- Questions that remained unanswered\n\n### Learnings\nInsights and patterns discovered that apply beyond this session.\n\n- How this codebase works\n- Effective debugging approaches\n- Patterns in the domain\n- Things to remember for next time\n\n## Writing Style\n\n**DO:**\n- Write in third person or neutral voice\n- Use natural paragraph flow\n- Include context for code quotes\n- Be specific about what happened\n- Vary structure based on content\n\n**DON'T:**\n- Force empty sections\n- Use rigid markdown headers if content doesn't warrant\n- Include every detail (summarize routine work)\n- Lose the narrative thread\n\n## Adaptive Structure\n\nThe report structure should adapt to the conversation:\n\n**Short session (few exchanges)**:\nBrief narrative covering goal, what happened, outcome.\n\n**Debugging session**:\nFocus on issues, diagnosis process, fixes. Quote error messages and fix code.\n\n**Feature implementation**:\nFocus on decisions, architectural choices, code patterns established.\n\n**Exploratory session**:\nFocus on learnings, discoveries about the codebase.\n\n**Frustrated session**:\nFocus on what went wrong, user frustrations, what finally worked (or didn't).\n",
        "skills/mastermind/references/vault-structure.md": "# Mastermind Vault Structure Reference\n\n## config.yaml\n\nProject registry with monitored directories:\n\n```yaml\nprojects:\n  my-webapp:\n    path: /path/to/my-webapp\n    description: React web application with Node backend\n  rust-library:\n    path: /path/to/rust-library\n    description: Utility library for data processing\n  # ... more projects\n```\n\n## state/sync-state.yaml\n\nTracks sync progress per project and session:\n\n```yaml\nmy-webapp:\n  last_synced: \"2026-01-16T21:15:00.000Z\"\n  sessions:\n    abc12345-def6-7890-ghij-klmnopqrstuv:\n      last_message: \"2026-01-16T08:57:54.881Z\"\n      message_count: 142\n      report: \"sessions/2026-01-15-implementing-jwt-authentication.md\"\n\nrust-library:\n  last_synced: \"2026-01-16T20:00:00.000Z\"\n  sessions:\n    # ... sessions for this project\n\nlast_daily: \"2026-01-15\"\n```\n\n**Note**: The `report` field stores the analyzer-generated filename (not the slug). Filenames follow the format `YYYY-MM-DD-descriptive-title.md`.\n\n## Claude Code Session Storage\n\nSessions are stored at `~/.claude/projects/[project-hash]/`:\n\n- **Project hash**: Path with `/` replaced by `-`\n  - `/home/user/projects/my-app` → `-home-user-projects-my-app`\n\n- **Session files**: `[session-uuid].jsonl`\n  - Each line is a JSON record\n  - Types: `user`, `assistant`, `system`, `summary`\n\n- **Key fields in JSONL records**:\n  ```json\n  {\n    \"sessionId\": \"abc12345-...\",\n    \"uuid\": \"message-uuid\",\n    \"parentUuid\": \"previous-message-uuid\",\n    \"timestamp\": \"2026-01-08T05:27:01Z\",\n    \"type\": \"user\",\n    \"slug\": \"cheerful-dancing-penguin\",\n    \"message\": { \"role\": \"user\", \"content\": \"...\" }\n  }\n  ```\n\n## projects/[name]/spec.md\n\nProject specification (source of truth). Format varies by project, but should address:\n\n- Purpose and vision\n- Scope (in/out)\n- Success criteria\n- Current phase\n- Key architectural decisions\n- Constraints and dependencies\n\n## projects/[name]/status.md\n\nCurrent state summary, auto-updated by sync:\n\n```markdown\n# [Project Name] Status\n\n**Last Updated**: 2026-01-16\n**Current Phase**: [from spec]\n\n## Recent Activity\n- [Summary of recent session reports]\n\n## Active Work\n- [Current tasks in progress]\n\n## Blockers\n- [Known blockers or issues]\n```\n\n## projects/[name]/sessions/YYYY-MM-DD-title.md\n\nSession reports with timestamp-prefixed descriptive names.\n\n**Filename format**: `YYYY-MM-DD-descriptive-title.md`\n- **Date**: Session start date (enables chronological sorting)\n- **Title**: Hyphen-connected summary of the session (max 10 words)\n- **Example**: `2026-01-15-implementing-jwt-authentication.md`\n\n**Why not slugs?** Claude Code generates random slugs like \"cheerful-dancing-penguin\" which are meaningless. Descriptive titles make it easy to find sessions without opening files.\n\nReports are narrative documents capturing work done in a Claude Code session. They include YAML frontmatter with the filename. See `report-properties.md` for what properties to capture.\n\n## daily/[YYYY-MM-DD].md\n\nCross-project daily digest:\n\n```markdown\n# Daily Digest: 2026-01-16\n\n## Summary\n[High-level summary of today's work across all projects]\n\n## By Project\n\n### my-webapp\n[Summary of webapp work today]\n\n### rust-library\n[Summary of library work today]\n\n## Key Decisions\n[Important decisions made today across projects]\n\n## Tomorrow\n[Suggested focus areas]\n```\n",
        "skills/satellite/INSTALL.md": "# Installing the Mastermind Satellite Skill\n\nThe satellite skill allows you to read mastermind context from any project directory. Since Claude Code skills are loaded per-directory, you need to install this skill globally.\n\n## Installation Steps\n\n### 1. Create global skills directory (if not exists)\n\n```bash\nmkdir -p ~/.claude/skills\n```\n\n### 2. Copy the satellite skill\n\n```bash\ncp -r /path/to/mastermind-plugin/skills/satellite ~/.claude/skills/mastermind-satellite\n```\n\nOr create a symlink:\n```bash\nln -s /path/to/mastermind-plugin/skills/satellite ~/.claude/skills/mastermind-satellite\n```\n\n### 3. Configure vault path\n\nCreate `~/.claude/mastermind.local.md`:\n\n```markdown\n# Mastermind Configuration\nvault: /path/to/your/mastermind/vault\n```\n\n### 4. Verify installation\n\nStart a Claude Code session in any project and ask:\n- \"Read my mastermind spec\"\n- \"What's the plan for this project?\"\n\nThe skill should activate and read from your vault.\n\n## Updating\n\nIf you update the mastermind plugin, re-copy the satellite skill:\n\n```bash\ncp -r /path/to/mastermind-plugin/skills/satellite/* ~/.claude/skills/mastermind-satellite/\n```\n\n## Troubleshooting\n\n**Skill not activating**:\n- Check `~/.claude/skills/mastermind-satellite/SKILL.md` exists\n- Verify the SKILL.md file is valid markdown with proper structure\n\n**Can't find vault**:\n- Verify `~/.claude/mastermind.local.md` exists\n- Check the vault path is correct and accessible\n\n**Project not found**:\n- Ensure the project is registered in vault's `config.yaml`\n- The project name should match directory name or configured path\n",
        "skills/satellite/SKILL.md": "# Mastermind Satellite - Read Project Context\n\nUse this skill when the user mentions \"read plan\", \"get spec\", \"mastermind context\", \"project context\", \"what's the plan\", or wants to pull the latest specification and status from their mastermind vault while working in a different project directory.\n\n---\n\n## Purpose\n\nThis is a lightweight skill for reading project context from a mastermind vault while working in any repository. It enables the two-way flow:\n\n```\nmastermind vault ←──sync──── project repos (session history)\nmastermind vault ────read──→ project repos (specs, status)\n```\n\n## Configuration\n\nThis skill requires knowing where your mastermind vault is located. Configure in `~/.claude/mastermind.local.md`:\n\n```markdown\n# Mastermind Configuration\nvault: /path/to/your/mastermind/vault\n```\n\n## What You Can Read\n\nFrom the mastermind vault, you can access:\n\n### Project Spec\nThe source-of-truth specification for the current project:\n- Purpose and vision\n- Scope boundaries\n- Success criteria\n- Current phase\n- Key decisions\n\n**Location**: `[vault]/projects/[project-name]/spec.md`\n\n### Project Status\nCurrent state summary:\n- Recent activity\n- Active work\n- Blockers\n\n**Location**: `[vault]/projects/[project-name]/status.md`\n\n### Recent Session Reports\nPrevious work sessions on this project:\n- What was accomplished\n- Decisions made\n- Issues resolved\n- Learnings\n\n**Location**: `[vault]/projects/[project-name]/sessions/`\n\n## Usage\n\nWhen working in a project directory, ask:\n\n- \"What's the plan for this project?\"\n- \"Read my mastermind spec\"\n- \"What did I work on last time?\"\n- \"Get project context from mastermind\"\n\nThe skill will:\n1. Read vault path from config\n2. Determine current project name (from directory or ask)\n3. Read and present relevant files from the vault\n\n## Project Name Resolution\n\nThe skill matches the current directory to a project in the vault:\n\n1. Check if current directory basename matches a project name\n2. Check if current directory path matches a configured project path\n3. If no match, ask which project to read\n\n## Installation\n\nThis skill should be installed globally to work from any directory.\n\nSee `INSTALL.md` for installation instructions.\n",
        "skills/spec-writer/SKILL.md": "# Spec Writer - Rigorous Project Specification\n\nUse this skill when the user mentions \"write spec\", \"project spec\", \"define goals\", \"spec properties\", \"project definition\", or wants to create or update a comprehensive project specification.\n\n---\n\n## Purpose\n\nA spec is the **source of truth** for a project's direction. It answers: What are we building? Why? What's in scope? How do we know when we're done?\n\nThis skill guides the creation of rigorous specs through **property-based validation** - ensuring all necessary aspects are addressed without enforcing a rigid format.\n\n## Required Properties\n\nEvery good spec must address these properties. The format can vary, but the information must be present.\n\n### 1. Purpose (Required)\n**Question**: Why does this project exist? What problem does it solve?\n\n- Not just \"what it does\" but \"why it matters\"\n- Who benefits and how\n- What would be missing if this didn't exist\n\n### 2. Scope (Required)\n**Question**: What's explicitly IN and OUT?\n\n**In Scope**:\n- Concrete capabilities the project will have\n- Features that are committed\n\n**Out of Scope** (equally important):\n- What this project deliberately won't do\n- Adjacent problems it won't solve\n- Features explicitly deferred\n\n### 3. Success Criteria (Required)\n**Question**: How do we know when this is \"done\" or \"working\"?\n\n- Observable, verifiable conditions\n- Not vague (\"works well\") but specific (\"passes all integration tests\", \"handles 1000 concurrent users\")\n- Can be different for different phases\n\n### 4. Current Phase (Required)\n**Question**: Where are we now in the project lifecycle?\n\n- What phase/milestone is active\n- What \"done\" looks like for THIS phase\n- What triggers moving to next phase\n\n## Contextual Properties\n\nInclude these when relevant to the project:\n\n### Architecture Decisions\nKey technical choices and their rationale.\n\n- What was decided\n- Why (constraints, tradeoffs)\n- Alternatives considered\n- Consequences/implications\n\n### Constraints\nLimitations that shape the solution.\n\n- Technical (language, platform, dependencies)\n- Business (timeline, budget, resources)\n- External (APIs, regulations, compatibility)\n\n### Dependencies\nWhat this project relies on.\n\n- External services/APIs\n- Libraries/frameworks\n- Other internal projects\n- People/expertise\n\n### Risks\nWhat could derail the project.\n\n- Technical risks (complexity, unknowns)\n- External risks (dependencies, changes)\n- Mitigation strategies\n\n### Open Questions\nUnresolved decisions that need answers.\n\n- What's uncertain\n- What information would help decide\n- When decisions need to be made\n\n## Writing a Spec\n\n### Process\n\n1. **Start with Purpose**: Write 2-3 sentences on why this exists\n2. **Define Scope**: List what's in, what's out\n3. **Set Success Criteria**: How will we verify success?\n4. **Identify Current Phase**: Where are we now?\n5. **Add Context**: Architecture, constraints, risks as relevant\n6. **Review for Gaps**: Does someone reading this know what to build?\n\n### Validation Checklist\n\nA spec is complete when you can answer YES to all:\n\n- [ ] Could a new team member understand the project's purpose?\n- [ ] Is it clear what's NOT in scope?\n- [ ] Are success criteria specific and verifiable?\n- [ ] Is the current phase and its goals clear?\n- [ ] Are key technical decisions documented with rationale?\n- [ ] Are significant risks identified?\n\n### Style Guidelines\n\n- **Be specific**: \"Fast\" → \"Responds within 200ms\"\n- **Be honest**: Include unknowns and risks\n- **Be concise**: Dense information, not lengthy prose\n- **Update regularly**: A stale spec is worse than no spec\n\n## Probing Questions\n\nWhen helping write a spec, ask:\n\n**Purpose**:\n- \"If this project succeeds, what's different in the world?\"\n- \"Who is the primary user/beneficiary?\"\n- \"What's the one-sentence pitch?\"\n\n**Scope**:\n- \"What's the most common misconception about what this does?\"\n- \"What adjacent problem will you NOT solve?\"\n- \"If you had to cut half the features, which half stays?\"\n\n**Success**:\n- \"How would you demo this to prove it works?\"\n- \"What would make you say 'this phase is done'?\"\n- \"What metrics matter?\"\n\n**Decisions**:\n- \"What's the most controversial technical choice you've made?\"\n- \"What would you do differently if starting over?\"\n- \"What's the hardest constraint you're working with?\"\n\nSee `references/spec-properties.md` for detailed property definitions.\n",
        "skills/spec-writer/references/spec-properties.md": "# Spec Properties Reference\n\nDetailed definitions and examples for each spec property.\n\n## Core Properties\n\n### Purpose\n\n**Definition**: The fundamental reason the project exists.\n\n**Good Example**:\n> This project provides a lightweight JavaScript runtime for resource-constrained environments (blockchain VMs, embedded systems). It enables developers to write familiar JS code that compiles to efficient, deterministic bytecode, bridging the gap between JS developer experience and constrained execution environments.\n\n**Bad Example**:\n> A JavaScript interpreter.\n\n**Probe Questions**:\n- What pain does this solve?\n- What's impossible or painful without this?\n- Who specifically needs this?\n\n---\n\n### Scope\n\n**Definition**: Explicit boundaries of what the project will and won't do.\n\n**Good Example**:\n```\nIN SCOPE:\n- ES2020 syntax support (except dynamic import)\n- Synchronous execution model\n- Integration with CosmWasm, Solana, NEAR\n- Deterministic execution (same input → same output)\n\nOUT OF SCOPE:\n- Async/await (fundamentally incompatible with determinism)\n- DOM APIs (no browser environment)\n- Node.js compatibility (different use case)\n- JIT compilation (this is bytecode-interpreted only)\n```\n\n**Bad Example**:\n> We'll implement JavaScript features as needed.\n\n**Why Out-of-Scope Matters**:\n- Prevents scope creep\n- Sets expectations for users\n- Guides decisions (\"should we add X?\" → \"is X in scope?\")\n\n---\n\n### Success Criteria\n\n**Definition**: Observable conditions that indicate the project is working/done.\n\n**Good Example**:\n```\nPhase 1 Success Criteria:\n- Passes 100% of test262 tests for supported syntax\n- Executes reference benchmarks within 2x of V8 interpreter mode\n- Successfully deployed to testnet with 3 sample contracts\n- Documentation covers all public APIs\n\nOverall Success:\n- Adopted by at least 2 production dApps\n- Community contributions (PRs from non-core team)\n```\n\n**Bad Example**:\n> Works correctly and is fast enough.\n\n**Characteristics of Good Criteria**:\n- Verifiable (can be tested)\n- Specific (numbers, not adjectives)\n- Timebound (for a phase or milestone)\n\n---\n\n### Current Phase\n\n**Definition**: Where the project is now and what completing this phase means.\n\n**Good Example**:\n```\nCURRENT PHASE: SSA IR Implementation\n\nGoals for this phase:\n- Complete SSA IR generation from AST\n- Implement all bytecode operations\n- Pass interpreter test suite with SSA backend\n\nExit Criteria:\n- All existing tests pass with new backend\n- Performance within 20% of old interpreter\n- No correctness regressions\n\nNext Phase: Optimization passes\n```\n\n**Bad Example**:\n> We're working on the compiler.\n\n---\n\n## Contextual Properties\n\n### Architecture Decisions\n\n**Format**:\n```\nDecision: [What was decided]\nContext: [Why this decision was needed]\nOptions Considered:\n  - Option A: [pros/cons]\n  - Option B: [pros/cons]\nChosen: [Which option and why]\nConsequences: [What this means for the project]\n```\n\n**Example**:\n```\nDecision: Use arena allocation for AST nodes\n\nContext: AST traversal is frequent, and individual node\nallocations cause cache misses and fragmentation.\n\nOptions Considered:\n  - Box<Node>: Simple but slow, many small allocations\n  - Arena: Fast allocation, good locality, batch deallocation\n  - Index-based: Maximum control but complex API\n\nChosen: Arena (bumpalo crate)\n\nConsequences:\n  - All AST operations require arena reference\n  - Cannot easily remove individual nodes\n  - Significant performance improvement for parsing\n```\n\n---\n\n### Constraints\n\n**Categories**:\n\n**Technical**:\n- Language/platform requirements\n- Performance requirements\n- Compatibility requirements\n\n**Resource**:\n- Team size/expertise\n- Timeline\n- Budget\n\n**External**:\n- API limitations\n- Regulatory requirements\n- Dependency constraints\n\n**Example**:\n```\nConstraints:\n- Must compile to no_std Rust (blockchain VMs don't have std)\n- Maximum contract size: 500KB (Solana limit)\n- Deterministic: same input must produce same output always\n- Single-threaded only (no threading in blockchain VMs)\n- No floating point (non-deterministic across platforms)\n```\n\n---\n\n### Dependencies\n\n**Format**: List with status and risk assessment.\n\n**Example**:\n```\nDependencies:\n- bumpalo (arena allocation): Stable, low risk\n- logos (lexer): Stable, considering replacement for perf\n- CosmWasm SDK: Active development, breaking changes possible\n- [Internal] core-parser: We control this, tightly coupled\n```\n\n---\n\n### Risks\n\n**Format**: Risk + likelihood + impact + mitigation.\n\n**Example**:\n```\nRisks:\n\n1. Performance insufficient for production use\n   - Likelihood: Medium\n   - Impact: High (project viability)\n   - Mitigation: Early benchmarking, optimization phase planned\n   - Contingency: Can add JIT later if interpreter too slow\n\n2. Breaking changes in blockchain SDKs\n   - Likelihood: High (SDKs are immature)\n   - Impact: Medium (rework integration layer)\n   - Mitigation: Abstraction layer between core and integrations\n```\n\n---\n\n### Open Questions\n\n**Format**: Question + context + deadline (if any).\n\n**Example**:\n```\nOpen Questions:\n\n1. Should we support ES modules?\n   - Context: Would be nice for code organization, but adds complexity\n   - Blocker for: Phase 2 planning\n   - Decide by: End of Phase 1\n\n2. How to handle BigInt interop with blockchain native types?\n   - Context: Different chains have different integer sizes\n   - Currently: Punting, using JS BigInt everywhere\n   - Needs: Research on performance implications\n```\n\n---\n\n## Spec Anti-Patterns\n\n### Too Vague\n❌ \"Build a good system\"\n✅ \"Build a system that processes 1000 events/second with <100ms latency\"\n\n### No Boundaries\n❌ \"Support all JavaScript features\"\n✅ \"Support ES2020 except modules, async/await, and generators\"\n\n### Wishful Thinking\n❌ \"Will be the fastest implementation\"\n✅ \"Target: within 2x of V8 interpreter mode for our benchmarks\"\n\n### Missing Rationale\n❌ \"Use Rust\"\n✅ \"Use Rust because: no_std support, safety guarantees, good WASM story\"\n\n### Stale Information\n❌ Spec written 6 months ago, never updated\n✅ \"Last updated: [date], Current phase: X, Next review: Y\"\n"
      },
      "plugins": [
        {
          "name": "mm",
          "source": "./",
          "description": "Multi-project progress tracking and management via Claude Code session analysis",
          "version": "0.1.0",
          "author": {
            "name": "mconcat"
          },
          "keywords": [
            "project-management",
            "session-tracking",
            "progress",
            "obsidian"
          ],
          "category": "productivity",
          "categories": [
            "obsidian",
            "productivity",
            "progress",
            "project-management",
            "session-tracking"
          ],
          "install_commands": [
            "/plugin marketplace add mconcat/mastermind",
            "/plugin install mm@mastermind"
          ]
        }
      ]
    }
  ]
}