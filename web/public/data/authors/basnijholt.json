{
  "author": {
    "id": "basnijholt",
    "display_name": "Bas Nijholt",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/6897215?u=a7d69832481ceabbd1a99ab22413a7141d2b1183&v=4",
    "url": "https://github.com/basnijholt",
    "bio": "ðŸ”¬ Building quantum computers at IonQ by day, crafting various open-source tools at night.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 97,
      "total_forks": 9
    }
  },
  "marketplaces": [
    {
      "name": "agent-cli",
      "version": null,
      "description": "Parallel development environment manager using git worktrees",
      "owner_info": {
        "name": "Bas Nijholt",
        "github": "basnijholt"
      },
      "keywords": [],
      "repo_full_name": "basnijholt/agent-cli",
      "repo_url": "https://github.com/basnijholt/agent-cli",
      "repo_description": "A suite of local AI-powered command-line tools",
      "homepage": "https://agent-cli.nijho.lt/",
      "signals": {
        "stars": 97,
        "forks": 9,
        "pushed_at": "2026-01-29T22:30:47Z",
        "created_at": "2025-06-25T16:35:10Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/README.md",
          "type": "blob",
          "size": 1659
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 626
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 426
        },
        {
          "path": ".claude-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/agent-cli-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/agent-cli-dev/SKILL.md",
          "type": "blob",
          "size": 4713
        },
        {
          "path": ".claude-plugin/skills/agent-cli-dev/examples.md",
          "type": "blob",
          "size": 18702
        }
      ],
      "files": {
        ".claude-plugin/README.md": "# agent-cli-dev Plugin for Claude Code\n\nThis plugin teaches Claude Code how to spawn parallel AI coding agents in isolated git worktrees using `agent-cli dev`.\n\n## What It Does\n\nThe plugin provides a skill that enables Claude Code to:\n\n- Create isolated git worktrees for parallel development\n- Spawn AI coding agents (Claude, Codex, Gemini, Aider) in separate terminal tabs\n- Manage multiple features/tasks simultaneously without branch conflicts\n- Automatically set up project dependencies in new worktrees\n\n## Installation\n\n### Install agent-cli\n\n```bash\n# Using uv (recommended)\nuv tool install agent-cli -p 3.13\n\n# Or run directly without installing\nuvx --python 3.13 agent-cli dev new my-feature --agent --prompt \"...\"\n```\n\n### Install the Claude Code plugin\n\n```bash\n# From the marketplace\nclaude plugin marketplace add basnijholt/agent-cli\n\n# Then install\nclaude plugin install agent-cli@agent-cli-dev\n```\n\n## Usage\n\nOnce installed, Claude Code can automatically use this skill when you ask to:\n\n- \"Work on multiple features in parallel\"\n- \"Spawn agents for auth, payments, and notifications\"\n- \"Create a worktree for this bug fix\"\n- \"Delegate this task to a separate agent\"\n\n## Key Commands\n\n```bash\n# Create worktree with AI agent\nagent-cli dev new my-feature --agent --prompt \"Implement the login page\"\n\n# Use prompt file for longer tasks\nagent-cli dev new my-feature --agent --prompt-file task.md\n\n# Check status of all worktrees\nagent-cli dev status\n\n# Clean up merged worktrees\nagent-cli dev clean --merged\n```\n\n## Documentation\n\nFull documentation: [docs/commands/dev.md](https://github.com/basnijholt/agent-cli/blob/main/docs/commands/dev.md)\n",
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"agent-cli\",\n  \"owner\": {\n    \"name\": \"Bas Nijholt\",\n    \"github\": \"basnijholt\"\n  },\n  \"metadata\": {\n    \"description\": \"Parallel development environment manager using git worktrees\",\n    \"repository\": \"https://github.com/basnijholt/agent-cli\",\n    \"homepage\": \"https://github.com/basnijholt/agent-cli\",\n    \"documentation\": \"https://github.com/basnijholt/agent-cli/blob/main/docs/commands/dev.md\",\n    \"keywords\": [\"git\", \"worktree\", \"parallel\", \"agents\", \"development\", \"claude\", \"ai\"],\n    \"license\": \"MIT\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agent-cli-dev\",\n      \"source\": \"./.claude-plugin\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"agent-cli-dev\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Bas Nijholt\",\n    \"github\": \"basnijholt\"\n  },\n  \"description\": \"Spawn parallel AI coding agents in isolated git worktrees. Creates isolated development environments with automatic project setup, letting you work on multiple features simultaneously with different AI agents (Claude, Codex, Gemini, Aider).\",\n  \"skills\": [\"./skills/agent-cli-dev\"]\n}\n",
        ".claude-plugin/skills/agent-cli-dev/SKILL.md": "---\nname: agent-cli-dev\ndescription: Spawns AI coding agents in isolated git worktrees. Use when the user asks to spawn or launch an agent, delegate a task to a separate agent, work in a separate worktree, or parallelize development across features.\n---\n\n# Parallel Development with agent-cli dev\n\nThis skill teaches you how to spawn parallel AI coding agents in isolated git worktrees using the `agent-cli dev` command.\n\n## Installation\n\nIf `agent-cli` is not available, install it first:\n\n```bash\n# Install globally\nuv tool install agent-cli -p 3.13\n\n# Or run directly without installing\nuvx --python 3.13 agent-cli dev new <branch-name> --agent --prompt \"...\"\n```\n\n## When to spawn parallel agents\n\nSpawn separate agents when:\n- Multiple independent features/tasks can be worked on in parallel\n- Tasks benefit from isolation (separate branches, no conflicts)\n- Large refactoring that can be split by module/component\n- Test-driven development (one agent for tests, one for implementation)\n\nDo NOT spawn when:\n- Tasks are small and sequential\n- Tasks have tight dependencies requiring constant coordination\n- The overhead of context switching exceeds the benefit\n\n## Core command\n\nFor new features (starts from origin/main):\n```bash\nagent-cli dev new <branch-name> --agent --prompt \"Implement the new feature...\"\n```\n\nFor work on current branch (review, test, fix) - use `--from HEAD`:\n```bash\nagent-cli dev new <branch-name> --from HEAD --agent --prompt \"Review/test/fix...\"\n```\n\nFor longer prompts (recommended for multi-line or complex instructions):\n```bash\nagent-cli dev new <branch-name> --from HEAD --agent --prompt-file path/to/prompt.md\n```\n\nThis creates:\n1. A new git worktree with its own branch\n2. Runs project setup (installs dependencies)\n3. Saves your prompt to `.claude/TASK.md` in the worktree (for reference)\n4. Opens a new terminal tab with an AI coding agent\n5. Passes your prompt to the agent\n\n**Important**: Use `--prompt-file` for prompts longer than a single line. The `--prompt` option passes text through the shell, which can cause issues with special characters (exclamation marks, dollar signs, backticks, quotes) in ZSH and other shells. Using `--prompt-file` avoids all shell quoting issues.\n\n## Writing effective prompts for spawned agents\n\nSpawned agents work in isolation, so prompts must be **self-contained**. Include:\n\n1. **Clear task description**: What to implement/fix/refactor\n2. **Relevant context**: File locations, patterns to follow, constraints\n3. **Report request**: Ask the agent to write conclusions to `.claude/REPORT.md`\n\n### Using --prompt-file (recommended)\n\nFor any prompt longer than a single sentence:\n\n1. Write the prompt to a temporary file (e.g., `.claude/spawn-prompt.md`)\n2. Use `--prompt-file` to pass it to the agent\n3. The file can be deleted after spawning\n\nExample workflow:\n```bash\n# 1. Write prompt to file (Claude does this with the Write tool)\n# 2. Spawn agent with the file\nagent-cli dev new my-feature --agent --prompt-file .claude/spawn-prompt.md\n# 3. Optionally clean up\nrm .claude/spawn-prompt.md\n```\n\n### Prompt template\n\n```\n<Task description>\n\nContext:\n- <Key file locations>\n- <Patterns to follow>\n- <Constraints or requirements>\n\nWhen complete, write a summary to .claude/REPORT.md including:\n- What you implemented/changed\n- Key decisions you made\n- Any questions or concerns for review\n```\n\n## Checking spawned agent results\n\nAfter spawning, you can check progress:\n\n```bash\n# List all worktrees and their status\nagent-cli dev status\n\n# Read an agent's report\nagent-cli dev run <branch-name> cat .claude/REPORT.md\n\n# Open the worktree in your editor\nagent-cli dev editor <branch-name>\n```\n\n## Example: Multi-feature implementation\n\nIf asked to implement auth, payments, and notifications:\n\n```bash\n# Spawn three parallel agents\nagent-cli dev new auth-feature --agent --prompt \"Implement JWT authentication...\"\nagent-cli dev new payment-integration --agent --prompt \"Add Stripe payment processing...\"\nagent-cli dev new email-notifications --agent --prompt \"Implement email notification system...\"\n```\n\nEach agent works independently in its own branch. Results can be reviewed and merged separately.\n\n## Key options\n\n| Option | Description |\n|--------|-------------|\n| `--agent` / `-a` | Start AI coding agent after creation |\n| `--prompt` / `-p` | Initial prompt for the agent (short prompts only) |\n| `--prompt-file` / `-P` | Read prompt from file (recommended for longer prompts) |\n| `--from` / `-f` | Base ref (default: origin/main). **Use `--from HEAD` when reviewing/testing current branch!** |\n| `--with-agent` | Specific agent: claude, aider, codex, gemini |\n| `--agent-args` | Extra arguments for the agent |\n\n@examples.md\n",
        ".claude-plugin/skills/agent-cli-dev/examples.md": "# Examples: Parallel Agent Workflows\n\nReal-world scenarios for spawning parallel AI coding agents, optimized for Claude 4.5 models.\n\n> **Note on prompts**: The examples below show prompt content inline for readability. In practice, **always use `--prompt-file`** for these multi-line prompts to avoid shell quoting issues:\n>\n> ```bash\n> # Write prompt to file, then spawn\n> agent-cli dev new my-feature --agent --prompt-file .claude/spawn-prompt.md\n> ```\n\n## Prompt structure guidelines\n\nEach prompt for a spawned agent should follow this structure:\n\n1. **Explicit task description** - Be specific about what to implement\n2. **Workflow directive** - Read files in parallel, commit incrementally, verify before completing\n3. **Code exploration** - Read and understand existing code before writing\n4. **Context with motivation** - Explain why patterns matter\n5. **Focused scope** - Keep solutions minimal, implement only what's requested\n6. **Structured report** - Write conclusions to `.claude/REPORT.md`\n\n## Scenario 1: Code review of current branch\n\n**User request**: \"Review the code on this branch\" or \"Spawn an agent to review my changes\"\n\n**CRITICAL**: Use `--from HEAD` (or the branch name) so the review agent has access to the changes!\n\n```bash\n# Review the current branch - MUST use --from HEAD\nagent-cli dev new review-changes --from HEAD --agent --prompt \"Review the code changes on this branch.\n\n<workflow>\n- Run git diff origin/main...HEAD to identify all changes\n- Read changed files in parallel to understand context\n- Check CLAUDE.md for project-specific guidelines\n- Test changes with real services if applicable\n</workflow>\n\n<code_exploration>\n- Use git diff origin/main...HEAD to see the full diff\n- Read each changed file completely before judging\n- Look at surrounding code to understand patterns\n- Check existing tests to understand expected behavior\n</code_exploration>\n\n<context>\nCode review catches issues before merge. Focus on real problems - not style nitpicks. Apply these criteria:\n- Code cleanliness: Is the implementation clean and well-structured?\n- DRY principle: Does it avoid duplication?\n- Code reuse: Are there parts that should be reused from other places?\n- Organization: Is everything in the right place?\n- Consistency: Is it in the same style as other parts of the codebase?\n- Simplicity: Is it over-engineered? Remember KISS and YAGNI. No dead code paths, no defensive programming.\n- No pointless wrappers: Functions that just call another function should be inlined.\n- User experience: Does it provide a good user experience?\n- Tests: Are tests meaningful or just trivial coverage?\n- Live tests: Test changes with real services if applicable.\n- Rules: Does the code follow CLAUDE.md guidelines?\n</context>\n\n<scope>\nReview only - identify issues but do not fix them. Write findings to report.\n</scope>\n\n<report>\nWrite your review to .claude/REPORT.md:\n\n## Summary\n[Overall assessment of the changes]\n\n## Issues Found\n| Severity | File:Line | Issue | Suggestion |\n|----------|-----------|-------|------------|\n| Critical/High/Medium/Low | path:123 | description | fix |\n\n## Positive Observations\n[What's well done]\n</report>\"\n```\n\n**Common mistake**: Forgetting `--from HEAD` means the agent starts from `origin/main` and won't see any of the branch changes!\n\n## Scenario 2: Multi-feature implementation\n\n**User request**: \"Implement user auth, payment processing, and email notifications\"\n\n**Strategy**: Three independent features â†’ spawn three agents.\n\n```bash\nagent-cli dev new auth-feature --agent --prompt \"Implement JWT-based user authentication.\n\n<workflow>\n- Read multiple files in parallel when exploring the codebase\n- Make incremental git commits as you complete each component\n- Run tests and linting before writing your final report\n</workflow>\n\n<code_exploration>\nStart by reading these files (in parallel if independent):\n- src/api/routes/ to understand existing endpoint patterns\n- src/models/ to see how models are structured\n- Any existing auth-related code to avoid duplication\n\nThink carefully about the existing patterns before designing your implementation.\n</code_exploration>\n\n<context>\nBackend is FastAPI in src/api/. This authentication system protects all user-facing endpoints, so reliability and security are critical. Follow the exact patterns in existing endpoints to maintain codebase consistency.\n</context>\n\n<requirements>\nImplement these endpoints following existing route patterns:\n- POST /auth/register - create new user with password hashing\n- POST /auth/login - validate credentials and return JWT token\n- GET /auth/me - return current user (requires valid JWT)\n- Create an auth dependency for protecting other routes\n- Store JWT_SECRET in environment variable\n</requirements>\n\n<scope>\nKeep the implementation simple and focused. Implement only what is requested. A working, minimal implementation is better than an over-designed one. Reuse existing abstractions where possible.\n</scope>\n\n<report>\nAfter verifying tests pass and linting is clean, write to .claude/REPORT.md:\n\n## Summary\n[2-3 sentences on what was implemented]\n\n## Files Changed\n- path/to/file.py - description of change\n\n## Key Decisions\n- Decision 1: rationale\n\n## Testing\nHow to verify the implementation works\n\n## Questions/Concerns\nAny items needing review\n</report>\"\n\nagent-cli dev new payment-integration --agent --prompt \"Integrate Stripe payment processing.\n\n<workflow>\n- Read multiple files in parallel when exploring the codebase\n- Make incremental git commits as you complete each component\n- Run tests and linting before writing your final report\n</workflow>\n\n<code_exploration>\nRead these files to understand the codebase (parallelize independent reads):\n- src/api/routes/ for endpoint patterns and error handling\n- src/models/ for existing model patterns\n- Any existing payment or billing code\n\nOnly make claims about code you have actually read.\n</code_exploration>\n\n<context>\nThis payment integration handles real money transactions and must be implemented correctly. Stripe webhooks are essential for tracking payment status - the system cannot rely solely on client-side confirmation. Use the stripe Python package and store STRIPE_SECRET_KEY in environment.\n</context>\n\n<requirements>\n- POST /payments/create-intent - create Stripe PaymentIntent, return client_secret\n- POST /payments/webhook - handle Stripe webhook events (payment_intent.succeeded, payment_intent.failed)\n- Add Payment model to track transaction status\n- Include proper webhook signature verification for security\n</requirements>\n\n<scope>\nImplement only what is specified. Focus on a working, secure implementation. Skip subscription handling, multiple payment methods, or other features unless explicitly requested.\n</scope>\n\n<report>\nAfter verifying tests pass, write to .claude/REPORT.md:\n\n## Summary\n[What was implemented]\n\n## Files Changed\n[List with descriptions]\n\n## Security Considerations\n[How webhook verification works, secret handling]\n\n## Testing\n[How to test with Stripe test mode]\n\n## Questions/Concerns\n[Any items for review]\n</report>\"\n\nagent-cli dev new email-notifications --agent --prompt \"Implement email notification system.\n\n<workflow>\n- Read multiple files in parallel when exploring the codebase\n- Make incremental git commits as you complete each component\n- Run tests and linting before writing your final report\n</workflow>\n\n<code_exploration>\nStart by reading the codebase to understand patterns:\n- Examine src/api/ for how background tasks are handled\n- Check existing configuration patterns for external services\n- Look for template handling patterns\n\nUnderstand the existing architecture before implementing.\n</code_exploration>\n\n<context>\nEmail notifications are user-facing and must be reliable. Background processing prevents blocking API responses. Template-based emails allow content changes without code changes.\n</context>\n\n<requirements>\n- Use an appropriate email library for the stack (e.g., fastapi-mail or aiosmtplib)\n- Implement as background tasks to avoid blocking API responses\n- Create templates for: welcome, password_reset, order_confirmation\n- POST /notifications/send-test - endpoint for testing email delivery\n- Store SMTP settings (host, port, user, password) in environment\n</requirements>\n\n<scope>\nImplement the minimum required for reliable email delivery. Skip notification preferences, SMS, or push notifications unless requested.\n</scope>\n\n<report>\nAfter verifying tests pass, write to .claude/REPORT.md with summary, files changed, library choice rationale, testing instructions, and any concerns.\n</report>\"\n```\n\n## Scenario 3: Test-driven development\n\n**User request**: \"Add a caching layer with comprehensive tests\"\n\n**Strategy**: One agent writes tests first, another implements.\n\n```bash\nagent-cli dev new cache-tests --agent --prompt \"Write comprehensive tests for a caching layer.\n\n<task>\nCreate a complete test suite that drives the implementation of a caching system. The tests define the interface - write them as if the implementation already exists.\n</task>\n\n<workflow>\n- Read test files in parallel to understand existing patterns\n- Commit tests incrementally as you complete each test category\n- Verify tests are syntactically valid before finishing\n</workflow>\n\n<code_exploration>\nFirst, explore the codebase (parallelize these reads):\n- tests/ for existing test patterns and fixtures\n- conftest.py for shared fixtures\n- Project testing conventions\n\nFollow the exact testing patterns you find.\n</code_exploration>\n\n<interface_spec>\nThe cache system should support:\n- get(key: str) -> Any | None\n- set(key: str, value: Any, ttl_seconds: int | None = None) -> None\n- delete(key: str) -> bool\n- clear() -> None\n- Support for Redis backend and in-memory fallback\n</interface_spec>\n\n<test_requirements>\nWrite tests in tests/test_cache.py using pytest:\n- Basic get/set/delete operations\n- TTL expiration (use time mocking)\n- Cache miss returns None\n- Backend switching/fallback behavior\n- Concurrent access patterns\n- Edge cases: empty keys, None values, large values\n</test_requirements>\n\n<scope>\nWrite only tests, not the implementation. The tests should fail initially and pass once implementation is complete. Write tests that verify behavior, not implementation details.\n</scope>\n\n<report>\nWhen complete, write to .claude/REPORT.md:\n\n## Test Cases\n| Test Name | What It Verifies |\n|-----------|------------------|\n| test_xxx  | description      |\n\n## Interface Decisions\n- Why the interface is designed this way\n\n## Edge Cases Covered\n- List of edge cases and why they matter\n\n## Implementation Suggestions\n- Hints for the implementer\n</report>\"\n```\n\nAfter reviewing the tests:\n\n```bash\nagent-cli dev new cache-impl --from cache-tests --agent --prompt \"Implement the caching layer to pass existing tests.\n\n<workflow>\n- Read all test files first to understand the complete interface\n- Run tests frequently as you implement: pytest tests/test_cache.py -v\n- Make incremental git commits after each passing test group\n- Verify all tests pass before writing your report\n</workflow>\n\n<code_exploration>\nCRITICAL: Read the tests completely before writing any implementation.\n- Read tests/test_cache.py to understand expected behavior\n- Note the exact interface the tests expect\n- Identify edge cases the tests check for\n\nThe tests define the contract - implement to match them exactly.\n</code_exploration>\n\n<requirements>\nImplement in src/cache.py:\n- CacheBackend abstract base class\n- RedisBackend implementation (use redis-py)\n- MemoryBackend implementation (dict-based with TTL support)\n- Cache facade that selects backend based on configuration\n</requirements>\n\n<scope>\nImplement exactly what the tests require. Skip features the tests don't verify. Skip distributed caching, cache warming, or advanced features unless tests require them.\n</scope>\n\n<report>\nAfter ALL tests pass, write to .claude/REPORT.md:\n\n## Implementation Approach\n[How the cache system works]\n\n## Test Results\n[Output of pytest run showing all tests pass]\n\n## Deviations\n[Any places where tests seemed incorrect or ambiguous]\n\n## Performance Notes\n[Any performance considerations]\n</report>\"\n```\n\n## Scenario 4: Large refactoring by module\n\n**User request**: \"Refactor the API to use consistent error handling\"\n\n**Strategy**: Split by module, each agent handles one area.\n\n```bash\nagent-cli dev new refactor-users-errors --agent --prompt \"Refactor error handling in the users module.\n\n<workflow>\n- Read all relevant files in parallel before making any changes\n- Make incremental git commits as you refactor each endpoint\n- Run tests after each change to catch regressions early\n- Run linting before writing your final report\n</workflow>\n\n<code_exploration>\nThink carefully about the current state before making changes:\n- Read ALL files in src/api/routes/users.py and related user logic\n- Document the current error handling patterns you find\n- Check how errors are handled in other modules for comparison\n- Look for any error handling utilities that already exist\n\nOnly modify code you have read and understood.\n</code_exploration>\n\n<context>\nInconsistent error responses make API clients fragile and debugging difficult. A standard error format allows clients to handle errors programmatically and provides clear information for debugging. Logging errors with context is essential for production troubleshooting.\n</context>\n\n<target_pattern>\nUse HTTPException with structured detail:\n{\n  \\\"error\\\": \\\"ERROR_CODE\\\",\n  \\\"message\\\": \\\"Human readable description\\\",\n  \\\"details\\\": {}  // optional additional context\n}\n\nError codes for users: USER_NOT_FOUND, USER_ALREADY_EXISTS, INVALID_CREDENTIALS, EMAIL_NOT_VERIFIED, etc.\n\nBefore raising, log with context:\nlogger.warning(f\\\"User not found: {user_id}\\\", extra={\\\"user_id\\\": user_id})\n</target_pattern>\n\n<scope>\nONLY modify files in src/api/routes/users.py and directly related user logic. Other agents are handling other modules.\n</scope>\n\n<report>\nAfter tests pass and linting is clean, write to .claude/REPORT.md:\n\n## Changes Made\n| File | Change Description |\n|------|-------------------|\n| path | what changed      |\n\n## Error Codes Introduced\n| Code | When Used | HTTP Status |\n|------|-----------|-------------|\n\n## Breaking Changes\n[Any API response changes that could affect clients]\n\n## Testing\n[How to verify the changes work]\n</report>\"\n```\n\n## Scenario 5: Documentation and implementation in parallel\n\n**User request**: \"Add a plugin system with documentation\"\n\n**Strategy**: One agent implements, another writes docs simultaneously.\n\n```bash\nagent-cli dev new plugin-system --agent --prompt \"Implement a plugin system.\n\n<workflow>\n- Read existing codebase structure in parallel before designing\n- Make incremental git commits as you complete each component\n- Run tests and linting before writing your final report\n</workflow>\n\n<code_exploration>\nThink carefully about the architecture before implementing:\n- Read the existing codebase structure to understand where plugins fit\n- Check for any existing extension points or hooks\n- Look at how configuration is handled\n- Understand the application lifecycle\n\nDesign the plugin system to integrate naturally with existing patterns.\n</code_exploration>\n\n<requirements>\n- Plugin base class with lifecycle hooks: on_load(), on_unload(), on_event(event_name, data)\n- Plugin registry for discovery and management\n- Auto-load plugins from plugins/ directory\n- Create one example plugin demonstrating the interface\n- Plugins should be able to register event handlers\n</requirements>\n\n<scope>\nImplement the minimal system that allows extending functionality through plugins. Skip: plugin dependencies, versioning, hot-reloading, sandboxing, or a plugin marketplace.\n</scope>\n\n<implementation_notes>\n- Use importlib for dynamic loading\n- Simple dict-based event system is sufficient\n- Plugins should fail gracefully without crashing the app\n</implementation_notes>\n\n<report>\nAfter tests pass, write to .claude/REPORT.md:\n\n## Architecture\n[Diagram or description of how plugins integrate]\n\n## Plugin Interface\n\\`\\`\\`python\nclass Plugin:\n    # document the interface\n\\`\\`\\`\n\n## Example Plugin\n[Show the example plugin code]\n\n## Usage\n[How to create and register a plugin]\n</report>\"\n\nagent-cli dev new plugin-docs --agent --prompt \"Write documentation for the plugin system.\n\n<context>\nImplementation is happening in parallel in another branch. Write documentation based on a standard plugin system design. The implementation agent will adapt if needed, or you can update docs after reviewing their work.\n</context>\n\n<assumptions>\n- Plugin base class with on_load, on_unload, on_event hooks\n- Plugin registry pattern with auto-discovery\n- Plugins loaded from plugins/ directory\n- Event-based communication\n</assumptions>\n\n<deliverables>\nCreate these documentation files:\n- docs/plugins/overview.md - What plugins are, why use them, architecture diagram\n- docs/plugins/creating-plugins.md - Step-by-step tutorial with complete example\n- docs/plugins/api-reference.md - Complete API documentation for Plugin class and registry\n\nUse clear examples and explain the \\\"why\\\" not just the \\\"how\\\".\n</deliverables>\n\n<workflow>\n- Commit each documentation file as you complete it\n- Ensure markdown renders correctly\n</workflow>\n\n<report>\nWhen complete, write to .claude/REPORT.md:\n\n## Documentation Structure\n[Outline of what was created]\n\n## Assumptions Made\n[What you assumed about the implementation]\n\n## Suggestions for Implementation\n[Any insights from writing docs that could improve the design]\n\n## Open Questions\n[Things that need clarification from the implementation]\n</report>\"\n```\n\n## Reviewing results\n\nAfter agents complete their work:\n\n```bash\n# Check status of all worktrees\nagent-cli dev status\n\n# Read reports from each agent\nagent-cli dev run auth-feature cat .claude/REPORT.md\nagent-cli dev run payment-integration cat .claude/REPORT.md\nagent-cli dev run email-notifications cat .claude/REPORT.md\n\n# Open a worktree to review code\nagent-cli dev editor auth-feature\n\n# Run tests in a worktree\nagent-cli dev run cache-impl pytest tests/test_cache.py -v\n\n# Clean up after merging\nagent-cli dev clean --merged\n```\n\n## Report format reference\n\nAll spawned agents should write to `.claude/REPORT.md` with at minimum:\n\n```markdown\n## Summary\n[2-3 sentences describing what was done]\n\n## Files Changed\n- path/to/file.py - what changed and why\n\n## Key Decisions\n- Decision: rationale for the choice made\n\n## Testing\nHow to verify the implementation works correctly\n\n## Questions/Concerns\nAny items that need human review or clarification\n```\n\nThis consistent format makes it easy to review work from multiple agents.\n"
      },
      "plugins": [
        {
          "name": "agent-cli-dev",
          "source": "./.claude-plugin",
          "description": null,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add basnijholt/agent-cli",
            "/plugin install agent-cli-dev@agent-cli"
          ]
        }
      ]
    }
  ]
}