{
  "author": {
    "id": "bfreis",
    "display_name": "Bruno Franca dos Reis",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/261623?v=4",
    "url": "https://github.com/bfreis",
    "bio": "Cloud expert",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 3,
      "total_skills": 3,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "claude-mart",
      "version": null,
      "description": "Create and execute self-updating plan files for complex projects with phased breakdown and autonomous execution tracking. Generates feature-specific plans (e.g., PLAN-auth.md, PLAN-api.md) that enable autonomous work across sessions.",
      "owner_info": {
        "name": "Bruno Franca dos Reis",
        "email": "bfreis@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "bfreis/claude-mart",
      "repo_url": "https://github.com/bfreis/claude-mart",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-09T06:55:01Z",
        "created_at": "2025-11-12T23:11:22Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 785
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 258
        },
        {
          "path": "plugins/plan-exec/README.md",
          "type": "blob",
          "size": 11279
        },
        {
          "path": "plugins/plan-exec/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/agents/plan-worker.md",
          "type": "blob",
          "size": 5872
        },
        {
          "path": "plugins/plan-exec/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/commands/plan-status.md",
          "type": "blob",
          "size": 4851
        },
        {
          "path": "plugins/plan-exec/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/skills/plan-executor",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/skills/plan-executor/SKILL.md",
          "type": "blob",
          "size": 12659
        },
        {
          "path": "plugins/plan-exec/skills/plan-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plan-exec/skills/plan-generator/SKILL.md",
          "type": "blob",
          "size": 6670
        },
        {
          "path": "plugins/transcript-analyzer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 260
        },
        {
          "path": "plugins/transcript-analyzer/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/commands/transcript-bloat.md",
          "type": "blob",
          "size": 891
        },
        {
          "path": "plugins/transcript-analyzer/commands/transcript-summary.md",
          "type": "blob",
          "size": 671
        },
        {
          "path": "plugins/transcript-analyzer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/skills/transcript-analyzer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/transcript-analyzer/skills/transcript-analyzer/SKILL.md",
          "type": "blob",
          "size": 4417
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-mart\",\n  \"owner\": {\n    \"name\": \"Bruno Franca dos Reis\",\n    \"email\": \"bfreis@gmail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"plan-exec\",\n      \"source\": \"./plugins/plan-exec\",\n      \"description\": \"Create and execute self-updating plan files for complex projects with phased breakdown and autonomous execution tracking. Generates feature-specific plans (e.g., PLAN-auth.md, PLAN-api.md) that enable autonomous work across sessions.\"\n    },\n    {\n      \"name\": \"transcript-analyzer\",\n      \"source\": \"./plugins/transcript-analyzer\",\n      \"description\": \"Debug Claude Code plugins by analyzing session transcripts. Includes pre-built jq recipes, context bloat detection, tool usage tracing, and comprehensive documentation of transcript structure.\"\n    }\n  ]\n}\n",
        "plugins/plan-exec/.claude-plugin/plugin.json": "{\n  \"name\": \"plan-exec\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Autonomous project planning with self-updating PLAN.md files and worker mode for reduced context usage\",\n  \"author\": {\n    \"name\": \"Bruno Franca dos Reis\",\n    \"email\": \"bfreis@gmail.com\"\n  }\n}",
        "plugins/plan-exec/README.md": "# Plan Exec Plugin\n\nA Claude Code plugin that creates self-updating plan files for autonomous, phased project execution with comprehensive implementation tracking.\n\n## Overview\n\nThis plugin provides two complementary skills for project planning and execution:\n\n### plan-generator\n\nCreates feature-specific project plans (e.g., `PLAN-auth.md`, `PLAN-api.md`) broken down into phases and detailed steps. Use this skill when you need to plan a new feature or project.\n\n### plan-executor\n\nExecutes existing plan files autonomously. Use this skill when you have a PLAN file and want to start or continue working through it. The executor handles:\n\n- Working through phases and steps systematically\n- Tracking progress via JSON state block and `plan-update` commands\n- Documenting implementation decisions and findings\n- Resuming work seamlessly across sessions\n- Delegating work to sub-agents (worker mode) to reduce context usage\n\n## Installation\n\n### For Personal Use\n\n1. Copy this plugin to your Claude Code plugins directory:\n   ```bash\n   cp -r plugins/plan-exec ~/.claude/plugins/\n   ```\n\n2. The skills will be automatically available in all your Claude Code sessions\n\n### For Team/Project Use\n\n1. Add this plugin configuration to your project's `.claude/settings.json`:\n   ```json\n   {\n     \"plugins\": [\n       {\n         \"path\": \"./plugins/plan-exec\"\n       }\n     ]\n   }\n   ```\n\n2. Commit the plugin to your repository\n3. Team members will have the skills available when they trust the project folder\n\n## Usage\n\n### Creating a Plan\n\nUse the **plan-generator** skill to create a new plan. Simply describe your project to Claude Code:\n\n```\nCreate a plan for building a JWT authentication system with refresh tokens\n```\n\nClaude will suggest a filename like `PLAN-auth.md` or ask you to choose one. You can also explicitly request it:\n\n```\nUse the plan generator to create a plan for [your project description]\n```\n\n### Executing a Plan\n\nUse the **plan-executor** skill to work through an existing plan:\n\n```\nExecute PLAN-auth.md\n```\n\nOr simply reference the plan file and ask to continue:\n\n```\n@PLAN-auth.md - Continue working on this plan\n```\n\nThe executor will read the plan, identify the current phase and next steps, and begin autonomous execution.\n\n### Plan File Naming\n\nPlans can be named flexibly to support multiple features in one repository:\n- Feature-specific: `PLAN-auth.md`, `PLAN-api.md`, `PLAN-frontend.md`\n- Main project: `PLAN.md`\n- Custom: `PLAN-{your-feature}.md`\n\n### Resuming Work\n\nReference a plan file in any session to resume work:\n\n```\n@PLAN-auth.md\n```\n\nClaude Code will read the plan, understand the project context, implementation notes, and resume work from where it left off using the plan-executor skill.\n\n### Expected Behavior\n\n- Claude will work autonomously through entire phases\n- Progress is tracked in a JSON state block at the end of the plan file\n- Claude uses `plan-update` commands to mark steps as started, completed, or blocked\n- Implementation notes are added as sub-bullets under completed steps\n- Detailed findings are documented in the \"Notes & Decisions\" section\n- Claude only stops when a phase completes (unless auto-continue is enabled) or errors occur\n- With auto-continue enabled, Claude will proceed through all phases without stopping\n- You can resume work across multiple sessions by referencing the plan file\n- Use `/plan-status` to check current progress at any time\n\n## Plan File Structure\n\nGenerated plans include (in this order):\n\n1. **Instructions for Claude** (TOP - most critical): Complete autonomous execution guidelines\n2. **Current Phase**: Simple status indicator showing current phase or \"COMPLETE\"\n3. **Project Overview**: Goal, context, and requirements\n4. **Phase Breakdown**: Detailed phases with steps using `### Step N.X:` headings\n5. **Notes & Decisions**: Comprehensive implementation notes for each phase documenting:\n   - Implementation details and approach\n   - Decisions made and why\n   - Deviations from plan\n   - Technical findings\n   - Test results\n6. **Dependencies**: Required packages/tools\n7. **Completion Checklist**: Final project readiness criteria\n8. **JSON State Block**: Machine-readable progress tracking (at the end of the file)\n\nThe JSON state block is wrapped in HTML comment markers (`<!--PLAN-STATE ... PLAN-STATE-->`) so it doesn't render visually but is easily parsed by tools. It contains:\n- Execution settings (mode, auto-continue, commit options)\n- Current phase index\n- Per-phase step status (pending, in_progress, completed, blocked)\n- Summaries and blocker reasons\n\n## Progress Tracking\n\nPlans use a JSON state block to track progress. The `plan-update` command is available at runtime to manage plan state.\n\n### Status Values\n\n- **pending** - Step not yet started\n- **in_progress** - Currently being worked on (only one step at a time)\n- **completed** - Step finished successfully\n- **blocked** - Cannot proceed without resolution\n\n### plan-update Commands\n\n```bash\n# Mark a step as in-progress (resets any other in-progress step)\nplan-update start <file> <step-id>\n\n# Mark a step as completed (optionally with a summary)\nplan-update complete <file> <step-id> [--summary \"Implementation details...\"]\n\n# Mark a step as blocked (reason required)\nplan-update block <file> <step-id> --reason \"Waiting for API credentials\"\n\n# Clear blocked status, return to pending\nplan-update unblock <file> <step-id>\n\n# Advance to next phase (fails if steps incomplete unless --force)\nplan-update next-phase <file> [--force]\n\n# Initialize JSON state for an existing plan\nplan-update init <file> [--mode direct|worker] [--auto-continue] [--commit]\n```\n\n### Checking Status\n\nUse the `/plan-status` command to see current progress:\n\n```\n/plan-status PLAN-auth.md\n```\n\nThis displays:\n- Current phase and overall progress\n- Per-phase completion counts\n- Any in-progress or blocked steps\n- Execution settings (mode, auto-continue, commits)\n\n**Note:** During normal execution, Claude runs these commands automatically. You typically only need them for debugging or manual intervention.\n\n## Example Workflow\n\n### Single Feature Plan\n\n1. **Initial planning**:\n   ```\n   Create a plan for building a JWT authentication system\n   ```\n\n2. **Start execution**:\n   ```\n   @PLAN-auth.md - Let's begin Phase 0\n   ```\n\n3. **Check progress** at any time:\n   ```\n   /plan-status PLAN-auth.md\n   ```\n\n4. **Resume later** (even weeks later):\n   ```\n   @PLAN-auth.md - Continue where we left off\n   ```\n\n### Behind the Scenes\n\nWhen Claude executes steps, it automatically runs `plan-update` commands:\n\n```bash\n# Starting a step\nplan-update start PLAN-auth.md 1.2\n\n# Completing a step with notes\nplan-update complete PLAN-auth.md 1.2 --summary \"Created JWT middleware with RS256\"\n\n# If something blocks progress\nplan-update block PLAN-auth.md 1.3 --reason \"Redis not configured\"\n```\n\nYou typically don't need to run these manually - Claude handles it automatically.\n\n### Multiple Plans in One Repository\n\nYou can maintain multiple plans for different features:\n```\n@PLAN-auth.md - Work on authentication\n@PLAN-api.md - Work on API endpoints\n@PLAN-frontend.md - Work on UI components\n```\n\nEach plan operates independently with its own JSON state block and progress tracking.\n\n## Execution Modes\n\nPlans can run in two execution modes, chosen during plan creation:\n\n### Direct Mode (Default)\n\n- Steps are executed directly in the main Claude Code session\n- Best for: Small plans, simple tasks, exploratory work\n- Trade-off: Full continuity between steps, but higher context usage\n\n### Worker Mode\n\n- Steps are delegated to `plan-worker` sub-agents\n- Each worker runs in an isolated context window\n- Best for: Large plans, multi-phase projects, context-heavy work\n- Trade-off: Lower context usage in main session, enabling longer autonomous runs\n\n**How Worker Mode Works:**\n\n1. The main session acts as a **coordinator**\n2. Coordinator identifies the next batch of steps to execute\n3. Coordinator launches a worker sub-agent with:\n   - Project context and goal\n   - Specific steps to execute\n   - Relevant files to read/modify\n   - Success criteria\n4. Worker executes steps in isolated context\n5. Worker returns a structured summary\n6. Coordinator updates the plan with results and continues\n\n**Worker summaries appear as inline notes under the step heading:**\n```markdown\n### Step 2.1: Add JWT generation function\n\n- **Worker:** Created jwt.ts with sign/verify, uses RS256\n- Decision: RS256 for public key verification support\n```\n\n**When to use Worker Mode:**\n- Plans with 3+ phases\n- Steps involving extensive file reading/editing\n- Long-running autonomous work sessions\n- When you've experienced context exhaustion in the past\n\n## Auto-Continue Mode\n\nBy default, Claude stops at the end of each phase to ask if you want to continue. You can enable **auto-continue** during plan creation to have Claude automatically proceed to the next phase without stopping.\n\n**With auto-continue enabled:**\n- Claude executes all phases sequentially without asking for confirmation\n- Only stops when all phases are complete, a blocker occurs, or you explicitly request a pause\n- Ideal for fully autonomous, unattended execution\n\n**With auto-continue disabled (default):**\n- Claude stops at the end of each phase\n- Asks for confirmation before starting the next phase\n- Gives you natural checkpoints to review progress, make adjustments, or pause\n\n**When to enable auto-continue:**\n- You trust the plan is well-defined and complete\n- You want fully unattended execution\n- You're running overnight or during long periods away\n\n**When to keep auto-continue disabled:**\n- You want to review progress between phases\n- The project may require adjustments as you learn more\n- You prefer more control over execution flow\n\n## Benefits\n\n- **Autonomous execution**: Claude works through entire phases without constant supervision\n- **Session persistence**: Resume work seamlessly across multiple sessions, even weeks later\n- **Rich context**: Notes & Decisions section provides comprehensive implementation history\n- **Team sharing**: Share plans, progress, and implementation decisions with team members\n- **Quality improvement**: Structured approach leads to more complete, higher-quality results\n- **No lost steps**: JSON state tracking ensures nothing is forgotten\n- **Multiple features**: Support multiple independent plans in one repository\n- **Standalone plans**: Each plan file contains everything needed to understand and continue the work\n- **Reduced context usage**: Worker mode delegates to sub-agents, enabling longer autonomous runs\n\n## Customization\n\nYou can modify `skills/plan-generator/SKILL.md` to:\n\n- Adjust the number of phases/steps Claude generates\n- Change autonomous execution behavior\n- Add project-specific planning requirements\n- Customize the PLAN.md structure\n\n## Files\n\n- `.claude-plugin/plugin.json`: Plugin manifest\n- `skills/plan-generator/SKILL.md`: Plan creation skill\n- `skills/plan-executor/SKILL.md`: Plan execution skill\n- `agents/plan-worker.md`: Worker sub-agent definition (for worker mode)\n- `skills/plan-executor/scripts/plan-tool`: Bash script for managing plan state transitions\n- `commands/plan-status.md`: Slash command to display plan progress\n- `README.md`: This file\n\n## Author\n\nbfreis",
        "plugins/plan-exec/agents/plan-worker.md": "---\nname: plan-worker\ndescription: Execute specific steps from a PLAN file. Use when the coordinator delegates implementation work. Returns structured summaries of completed work including status, changes made, and any blockers.\nmodel: inherit\n---\n\n# Plan Worker Agent\n\nYou are a focused implementation worker executing specific steps from a project plan. You operate in an isolated context to prevent context accumulation in the main session.\n\n## Your Role\n\nYou receive from the coordinator:\n1. Project context and goal\n2. Specific steps to execute (with full descriptions)\n3. Relevant files to read/modify\n4. Success criteria for the work\n5. Any constraints or requirements\n\nYou return to the coordinator:\n1. Status of each step (COMPLETED / BLOCKED / PARTIAL)\n2. Summary of changes made\n3. Files modified or created\n4. Key decisions made during implementation\n5. Any blockers or issues encountered\n6. Suggestions for plan updates (if any)\n\n## Execution Guidelines\n\n1. **Focus narrowly** - Only work on the assigned steps. Do not expand scope.\n\n2. **Read before writing** - Always read relevant files before making changes.\n\n3. **Document as you go** - Note decisions, deviations, and findings.\n\n4. **Stop on blockers** - If you encounter an issue that prevents completion, report it clearly rather than working around it in ways that might cause problems.\n\n5. **Verify your work** - Run relevant tests, linters, or build commands to verify changes work before reporting completion.\n\n6. **Be concise** - Your summary will be incorporated into the plan file. Keep it brief but informative.\n\n7. **Preserve existing patterns** - Follow the codebase's existing conventions and patterns.\n\n## Output Format\n\nWhen you complete your work, provide a structured summary in this exact format:\n\n---\n\n### Step Results\n\nFor each assigned step, report:\n\n- **Step X.Y: [Step description]** — STATUS\n  - Summary: [Single-line summary suitable for `--summary` argument]\n  - Files changed: [comma-separated list of file paths]\n  - Key decisions: [brief note on any significant choices made]\n  - Issues: [any problems encountered, or \"None\"]\n\n**IMPORTANT:**\n- Step IDs must match EXACTLY what's in the PLAN file (e.g., \"1.2\", \"2.3\", NOT \"Step 1.2\")\n- Summaries must be concise single-line strings (they become `--summary` arguments)\n- For BLOCKED steps, the Issues field must be a clear single-line explanation (it becomes the `--reason` argument)\n\n### Overall Summary\n\n[2-3 sentence summary of what was accomplished across all steps]\n\n### Blockers\n\n[If any steps are BLOCKED or PARTIAL, list step IDs with single-line reasons. If none, write \"None\"]\n\n### Suggested Plan Updates\n\n[Any additions or modifications to suggest for the plan. If none, write \"None\"]\n\n---\n\n## Status Definitions\n\n- **COMPLETED**: Step fully done, verified working\n- **PARTIAL**: Some progress made but not finished (explain what's done vs remaining)\n- **BLOCKED**: Cannot proceed due to an issue (explain the blocker clearly)\n\n## Example Output\n\n---\n\n### Step Results\n\n- **Step 2.1: Add JWT generation function** — COMPLETED\n  - Summary: Created generateToken() function with RS256 signing and 15-minute expiry\n  - Files changed: src/auth/jwt.ts, package.json\n  - Key decisions: Used RS256 over HS256 for better security with public key verification\n  - Issues: None\n\n- **Step 2.2: Add token validation middleware** — COMPLETED\n  - Summary: Created Express middleware that validates JWT and attaches user to request\n  - Files changed: src/middleware/auth.ts, src/types/express.d.ts\n  - Key decisions: Added type augmentation for Express Request to include user property\n  - Issues: None\n\n- **Step 2.3: Add refresh token endpoint** — BLOCKED\n  - Summary: Started implementation but discovered Redis is not configured\n  - Files changed: src/routes/auth.ts (partial)\n  - Key decisions: N/A\n  - Issues: Redis not configured - refresh tokens need persistent storage\n\n### Overall Summary\n\nImplemented JWT generation and validation (steps 2.1-2.2). The refresh token endpoint (step 2.3) is blocked pending Redis configuration.\n\n### Blockers\n\n- 2.3: Redis not configured - refresh tokens need persistent storage\n\n### Suggested Plan Updates\n\nConsider adding a step in Phase 1 for Redis setup, or add a sub-step under 2.3 for configuring refresh token storage.\n\n---\n\n## Coordinator Integration\n\nAfter the worker returns its summary, the coordinator processes the results using `plan-update` commands:\n\n### For COMPLETED Steps\n\n```bash\nplan-update complete <plan-file> <step-id> --summary \"Summary from worker\"\n```\n\nExample from above output:\n```bash\nplan-update complete PLAN-auth.md 2.1 --summary \"Created generateToken() function with RS256 signing and 15-minute expiry\"\nplan-update complete PLAN-auth.md 2.2 --summary \"Created Express middleware that validates JWT and attaches user to request\"\n```\n\n### For BLOCKED Steps\n\n```bash\nplan-update block <plan-file> <step-id> --reason \"Issues field from worker\"\n```\n\nExample from above output:\n```bash\nplan-update block PLAN-auth.md 2.3 --reason \"Redis not configured - refresh tokens need persistent storage\"\n```\n\n### Adding Detailed Notes\n\nAfter updating the JSON state, the coordinator also adds detailed notes directly to the markdown step descriptions in the PLAN file:\n\n```markdown\n### Step 2.1: Add JWT generation function\nOriginal step description...\n- **Completed:** Created generateToken() function with RS256 signing and 15-minute expiry\n- **Decision:** Used RS256 over HS256 for better security with public key verification\n```\n\n### Handling Partial Completion\n\nWhen some steps are COMPLETED and others are BLOCKED or PARTIAL:\n1. Run `plan-update complete` for each finished step\n2. Run `plan-update block` for blocked steps (or leave as pending if PARTIAL)\n3. Add notes to markdown for all steps with progress\n4. Report blockers to user before continuing\n",
        "plugins/plan-exec/commands/plan-status.md": "# /plan-status - Display Plan Progress\n\nDisplay the current status and progress of a plan file by reading its JSON state block.\n\n## Usage\n\n```\n/plan-status [plan-file]\n```\n\nIf no file is specified, look for common plan file patterns in the current directory:\n- `PLAN.md`\n- `PLAN-*.md`\n\n## Instructions\n\n1. **Locate the plan file**:\n   - If a file argument is provided, use that file\n   - Otherwise, search for `PLAN.md` or `PLAN-*.md` in the current directory\n   - If multiple plan files exist and none specified, list them and ask user to specify\n\n2. **Extract the JSON state block**:\n   The JSON block is wrapped in HTML comment markers:\n   - Start marker: `<!--PLAN-STATE`\n   - End marker: `PLAN-STATE-->`\n\n   Extract the JSON between these markers using:\n   ```bash\n   sed -n '/<!--PLAN-STATE/,/PLAN-STATE-->/p' <file> | sed '1d;$d'\n   ```\n\n3. **Parse the JSON and calculate progress**:\n   Use `jq` to extract:\n   ```bash\n   # Get execution settings\n   jq -r '.execution.mode' <json>\n   jq -r '.execution.auto_continue' <json>\n   jq -r '.execution.commit_after_phase' <json>\n   jq -r '.execution.include_plan_in_commit' <json>\n\n   # Get current phase\n   jq -r '.current_phase' <json>\n\n   # Count steps by status across all phases\n   jq '[.phases[].steps[]] | group_by(.status) | map({(.[0].status): length}) | add' <json>\n\n   # Get per-phase breakdown\n   jq '.phases[] | {id, name, total: (.steps | length), completed: ([.steps[] | select(.status == \"completed\")] | length)}' <json>\n\n   # Find in-progress steps\n   jq '[.phases[].steps[] | select(.status == \"in_progress\")] | .[0].id' <json>\n\n   # Find blocked steps with reasons\n   jq '[.phases[].steps[] | select(.status == \"blocked\") | {id, reason: .blocker}]' <json>\n   ```\n\n4. **Display formatted output**:\n\n## Output Format\n\n```\nPlan Status: PLAN-auth.md\n\nCurrent Phase: Phase 1 - JWT Token Generation (in progress)\nMode: worker | Auto-continue: yes | Commits: yes (excluding PLAN)\n\nOverall Progress: [========--------] 8/20 (40%)\n\nPhase 0: Setup [completed] (4/4)\nPhase 1: JWT Token Generation (3/5)\n  - In progress: Step 1.3\nPhase 2: Refresh Tokens (0/4)\nPhase 3: Middleware (0/3)\nPhase 4: Testing (0/4)\n\nBlocked: None\n```\n\n### Format Details\n\n**Header**: Show the plan filename\n\n**Current Phase**:\n- If `current_phase >= 0`: Show \"Phase N - Name (in progress)\"\n- If `current_phase == -1`: Show \"COMPLETE - All phases finished\"\n\n**Execution Settings**:\n- Mode: \"direct\" or \"worker\"\n- Auto-continue: \"yes\" or \"no\"\n- Commits: \"no\" if `commit_after_phase` is false, otherwise:\n  - \"yes (including PLAN)\" if `include_plan_in_commit` is true\n  - \"yes (excluding PLAN)\" if `include_plan_in_commit` is false\n\n**Progress Bar**:\n- Calculate: completed_steps / total_steps\n- Use 20-character bar with `=` for filled, `-` for empty\n- Show count and percentage: \"8/20 (40%)\"\n\n**Per-Phase Breakdown**:\n- For each phase, show: \"Phase N: Name (completed/total)\"\n- Mark completed phases with `[completed]`\n- For in-progress phases, indent and show any active step: \"- In progress: Step N.X\"\n\n**Blocked Steps**:\n- If no blocked steps: \"Blocked: None\"\n- If blocked steps exist, list each with reason:\n  ```\n  Blocked:\n  - Step 2.3: Redis connection not configured\n  - Step 3.1: Waiting for API design approval\n  ```\n\n## Edge Cases\n\n1. **No JSON state block found**:\n   - Report: \"No JSON state block found in [file]. This plan may use the legacy checkbox format or needs initialization with `plan-update init`.\"\n\n2. **Invalid JSON**:\n   - Report: \"Invalid JSON in state block. The plan file may be corrupted.\"\n\n3. **All phases complete** (`current_phase == -1`):\n   - Show progress as 100% complete\n   - Current Phase shows \"COMPLETE\"\n\n4. **No plan files found**:\n   - Report: \"No plan files found. Create one with the plan-generator skill or specify a file path.\"\n\n5. **Empty phases array**:\n   - Report: \"Plan has no phases defined.\"\n\n## Example Complete Output\n\nFor a plan with 5 phases, currently in phase 2, with one blocked step:\n\n```\nPlan Status: PLAN-auth.md\n\nCurrent Phase: Phase 2 - Refresh Tokens (in progress)\nMode: worker | Auto-continue: yes | Commits: yes (excluding PLAN)\n\nOverall Progress: [==========------] 10/20 (50%)\n\nPhase 0: Setup [completed] (4/4)\nPhase 1: JWT Token Generation [completed] (5/5)\nPhase 2: Refresh Tokens (1/4)\n  - In progress: Step 2.2\nPhase 3: Middleware (0/4)\nPhase 4: Testing (0/3)\n\nBlocked:\n- Step 2.3: Redis not configured in project\n```\n\nFor a fully complete plan:\n\n```\nPlan Status: PLAN-auth.md\n\nCurrent Phase: COMPLETE - All phases finished\nMode: direct | Auto-continue: no | Commits: no\n\nOverall Progress: [====================] 20/20 (100%)\n\nPhase 0: Setup [completed] (4/4)\nPhase 1: JWT Token Generation [completed] (5/5)\nPhase 2: Refresh Tokens [completed] (4/4)\nPhase 3: Middleware [completed] (4/4)\nPhase 4: Testing [completed] (3/3)\n\nBlocked: None\n```\n",
        "plugins/plan-exec/skills/plan-executor/SKILL.md": "---\nname: plan-executor\ndescription: Execute and coordinate work on PLAN files with phased breakdown. Tracks progress via JSON state, coordinates worker sub-agents in worker mode, and manages commits. Use when user references a PLAN file or asks to continue/execute a plan.\n---\n\n# Plan Executor Skill\n\nThis skill executes and coordinates work on existing PLAN files. It handles progress tracking, worker coordination (in worker mode), commit management, and phase advancement.\n\n## When to Use This Skill\n\nUse this skill when:\n- User references an existing PLAN file (e.g., `@PLAN-auth.md`)\n- User asks to \"continue the plan\" or \"execute the plan\"\n- User asks to \"work on\" or \"resume\" a project with a PLAN file\n- User wants to see plan status or progress\n\nDo NOT use this skill when:\n- User wants to CREATE a new plan (use `plan-generator` skill instead)\n- User wants to modify the plan structure (add/remove phases)\n\n## CRITICAL RULES\n\n**These rules MUST be followed at all times:**\n\n### 1. ALWAYS Respect Execution Mode\n\nThe execution mode is defined in the JSON state block (`execution.mode`). **You MUST follow it:**\n\n- **If `mode` is `\"worker\"`**: You are a COORDINATOR. Do NOT execute steps directly. Launch `plan-worker` sub-agents to do the work. NEVER perform implementation work yourself in worker mode.\n- **If `mode` is `\"direct\"`**: Execute steps directly in the main session.\n\n**On resume**: Re-read the JSON state and respect the mode. Do not switch modes.\n\n### 2. ALWAYS Update State Immediately\n\nState updates MUST happen in real-time, not batched:\n\n- **BEFORE starting ANY step**: Run `scripts/plan-tool start <file> <step-id>`\n- **IMMEDIATELY after completing a step**: Run `scripts/plan-tool complete <file> <step-id> --summary \"...\"`\n- **Never skip state updates** - if the session is interrupted, state should reflect reality\n\nThis ensures that if execution is interrupted, the plan can resume from the correct point.\n\n---\n\n## Understanding Plan State\n\nPLAN files contain a JSON state block at the end wrapped in HTML comment markers:\n\n```\n<!--PLAN-STATE\n{\n  \"schema_version\": \"1.0\",\n  \"execution\": {\n    \"mode\": \"direct\",           // or \"worker\"\n    \"auto_continue\": false,     // auto-advance to next phase when current completes\n    \"commit_after_phase\": false,\n    \"include_plan_in_commit\": true\n  },\n  \"current_phase\": 0,           // -1 means all complete\n  \"phases\": [\n    {\n      \"id\": 0,\n      \"name\": \"Setup\",\n      \"steps\": [\n        { \"id\": \"0.1\", \"status\": \"pending\" },\n        { \"id\": \"0.2\", \"status\": \"completed\", \"summary\": \"...\" }\n      ]\n    }\n  ]\n}\nPLAN-STATE-->\n```\n\n### Step Status Values\n\n- `pending` - Not started\n- `in_progress` - Currently being worked on (only ONE at a time)\n- `completed` - Finished successfully\n- `blocked` - Cannot proceed (includes `blocker` field with reason)\n\n### Initializing Plan State\n\nWhen a PLAN file does not have a JSON state block, initialize it before starting execution:\n\n```bash\nscripts/plan-tool init <file> [--mode direct|worker] [--auto-continue] [--commit] [--no-plan-in-commit]\n```\n\nThe `init` command parses the markdown headings to discover phases and steps, then generates the JSON state block at the end of the file.\n\n**Options:**\n- `--mode direct|worker`: Execution mode (default: direct)\n- `--auto-continue`: Enable auto-advancement between phases\n- `--commit`: Enable commits after each phase\n- `--no-plan-in-commit`: Exclude PLAN file from commits\n\nExample:\n```bash\nscripts/plan-tool init PLAN-auth.md --mode worker --auto-continue --commit --no-plan-in-commit\n```\n\n### Reading Plan State\n\nWhen starting execution:\n1. Read the entire PLAN file\n2. Check if JSON state block exists (look for `<!--PLAN-STATE` marker)\n3. **If no JSON state block exists**: Initialize it using `scripts/plan-tool init` with options based on the execution preferences in the Instructions section\n4. Parse the JSON state block to understand:\n   - Which execution mode is active (`direct` or `worker`)\n   - Which phase is current (`current_phase`)\n   - Which steps are `pending`, `in_progress`, `completed`, or `blocked`\n5. Check for any `blocked` steps that need resolution\n6. Identify the next actionable step(s)\n\n## Progress Tracking Commands\n\nUse the `scripts/plan-tool` script (relative to this skill directory) to manage JSON state updates.\n\n### Starting a Step\n\nBefore beginning work on a step:\n\n```bash\nscripts/plan-tool start <file> <step-id>\n```\n\nExample:\n```bash\nscripts/plan-tool start PLAN-auth.md 1.2\n```\n\n**Note:** Only ONE step can be `in_progress` at a time. Starting a new step automatically resets any previously in-progress step to `pending`.\n\n### Completing a Step\n\nAfter successfully finishing a step:\n\n```bash\nscripts/plan-tool complete <file> <step-id> [--summary \"...\"]\n```\n\nExample:\n```bash\nscripts/plan-tool complete PLAN-auth.md 1.2 --summary \"Added JWT validation middleware with RS256 support\"\n```\n\n**Auto-advancement:** If all steps in the current phase are completed and `auto_continue` is enabled, the phase automatically advances.\n\n### Blocking a Step\n\nWhen a step cannot proceed due to an issue:\n\n```bash\nscripts/plan-tool block <file> <step-id> --reason \"...\"\n```\n\nExample:\n```bash\nscripts/plan-tool block PLAN-auth.md 1.3 --reason \"Redis not configured - refresh tokens need persistent storage\"\n```\n\n### Unblocking a Step\n\nTo clear a blocked status after resolving the issue:\n\n```bash\nscripts/plan-tool unblock <file> <step-id>\n```\n\n### Advancing Phase\n\nTo manually advance to the next phase:\n\n```bash\nscripts/plan-tool next-phase <file> [--force]\n```\n\nUse `--force` to advance even if some steps are incomplete or blocked (not recommended).\n\n## Direct Mode Execution\n\nIn direct mode, execute steps directly in the main Claude Code session.\n\n### Execution Flow\n\n1. **Identify next step**: Find the first `pending` step in the current phase\n2. **Mark as in-progress**: Run `scripts/plan-tool start`\n3. **Execute the step**: Perform all work described in the step\n4. **Document completion**: Add notes under the step heading in markdown:\n   ```markdown\n   ### Step 1.2: Implement user validation\n   Original step description...\n   - **Completed:** Added email regex validation and password strength check\n   - **Decision:** Used zxcvbn library for password scoring\n   ```\n5. **Update state**: Run `scripts/plan-tool complete` with a brief summary\n6. **Repeat**: Continue with next pending step\n\n### Stopping Conditions\n\nOnly stop when:\n- An entire phase is complete AND `auto_continue` is disabled (ask user if they want to continue)\n- An actual error or blocker occurs\n- User explicitly requests to pause\n- All phases are complete\n\n**If `auto_continue` is enabled:** Do NOT stop between phases. Immediately proceed to the next phase.\n\n### Adding Implementation Notes\n\nAfter completing steps, add detailed notes to the **Notes & Decisions** section:\n\n```markdown\n## Notes & Decisions\n\n### Phase 1: Core Implementation (Completed)\n- Implemented JWT generation using RS256 algorithm\n- Chose 15-minute expiry for access tokens based on security best practices\n- Added refresh token rotation to prevent token reuse\n```\n\n## Worker Mode Execution\n\nIn worker mode, delegate step execution to `plan-worker` sub-agents. The main session acts as a coordinator.\n\n### Coordinator Protocol\n\n#### 1. Identify Next Work Batch\n\nParse the JSON state block to find steps with `\"status\": \"pending\"` in the current phase. Determine batch size by considering:\n\n- **Step dependencies**: If step N+1 needs output from step N, batch them together\n- **Complexity**: Steps involving multiple files, tests, or debugging -> smaller batches (1-2 steps)\n- **Independence**: Simple, independent steps -> can batch more (3-5 steps)\n- **Default**: 2-4 related steps per worker, or an entire phase if steps are simple\n\n#### 2. Prepare Worker Context\n\nGather the information the worker needs:\n\n- **Project goal**: 1-2 sentences from Project Overview\n- **Specific steps**: Full descriptions from the plan\n- **Relevant files**: List of files the worker will need to read or modify\n- **Success criteria**: Derived from step descriptions\n- **Inline examples**: Any relevant examples from the plan\n\n#### 3. Mark Steps and Launch Worker\n\n**BEFORE launching the worker**, mark all assigned steps as in-progress:\n\n```bash\nscripts/plan-tool start <file> <step-id>\n```\n\nRun this for EACH step being assigned to the worker.\n\nThen launch the `plan-worker` sub-agent with this prompt structure:\n\n```\n**Project:** [Project name from plan]\n\n**Goal:** [Brief goal from Project Overview section]\n\n**Your Assignment:**\nExecute the following steps from Phase N:\n- Step N.X: [full description]\n- Step N.Y: [full description]\n- Step N.Z: [full description]\n\n**Context Files to Read:**\n- [path/to/file1] - [why it's relevant]\n- [path/to/file2] - [why it's relevant]\n\n**Success Criteria:**\n- [Specific criterion derived from steps]\n- [Another criterion]\n\n**Constraints:**\n- [Any project-specific constraints]\n- [Technology requirements]\n\nWhen done, provide your structured summary.\n```\n\n#### 4. Process Worker Results\n\nWhen the worker returns its summary:\n\n**For COMPLETED steps:**\n```bash\nscripts/plan-tool complete <file> <step-id> --summary \"Summary from worker\"\n```\n\nAdd inline notes under the step heading:\n```markdown\n### Step N.X: [description]\nOriginal step description...\n- **Completed:** [1-2 sentence summary of what was done]\n- **Decision:** [any notable decision, if applicable]\n```\n\n**For BLOCKED steps:**\n```bash\nscripts/plan-tool block <file> <step-id> --reason \"Blocker description from worker\"\n```\n\nAdd blocker details under the step heading:\n```markdown\n### Step N.X: [description]\nOriginal step description...\n- **Blocked:** [description of the blocker]\n```\n\nThen report to user and ask how to proceed.\n\n**Update Notes & Decisions section** with worker findings for the appropriate phase.\n\n#### 5. Continue or Pause\n\n- If more pending steps remain in the phase, launch another worker\n- If phase is complete:\n  - Create git commit if `commit_after_phase` is enabled\n  - **If `auto_continue` is enabled**: Immediately proceed to the next phase\n  - **If `auto_continue` is disabled**: Ask user if they want to continue\n- If all phases are complete, report completion to user\n- If blocker hit, wait for user guidance\n\n## Phase Completion Handling\n\n### Creating Commits\n\nIf `commit_after_phase` is enabled:\n\n1. Stage all modified files from the phase\n2. Check `include_plan_in_commit` setting:\n   - If `true`: Include the PLAN file in the commit\n   - If `false`: Keep PLAN file unstaged\n3. Create commit with message describing the phase work\n\nExample commit message:\n```\nfeat(auth): Phase 1 - Implement JWT token generation\n\n- Added generateToken() function with RS256 signing\n- Created token validation middleware\n- Implemented refresh token rotation\n```\n\n### Advancing to Next Phase\n\nAfter a phase completes:\n\n1. If `auto_continue` is enabled:\n   - Log phase completion\n   - Immediately begin work on next phase\n   - Continue until all phases complete or a blocker occurs\n\n2. If `auto_continue` is disabled:\n   - Report phase completion to user\n   - Ask: \"Phase N is complete. Would you like to continue to Phase N+1?\"\n   - Wait for user confirmation before proceeding\n\n### All Phases Complete\n\nWhen `current_phase` becomes `-1`:\n1. Report completion to user\n2. Review the Completion Checklist in the PLAN file\n3. Verify all items are satisfied\n4. Suggest any final cleanup or documentation tasks\n\n## Error Handling\n\n\n### Handling Blocked Steps\n\nWhen a step is blocked:\n\n1. Run `scripts/plan-tool block` to mark it in the JSON state\n2. Stop launching workers for steps that depend on the blocked step\n3. Report to user with:\n   - The step that is blocked\n   - The reason for the blocker\n   - Options to resolve:\n     - Add a prerequisite step to fix the blocker\n     - Skip the step (unblock then complete with note)\n     - Provide guidance for another attempt\n\n### Partial Completion\n\nWhen a worker completes some but not all assigned steps:\n\n1. Run `scripts/plan-tool complete` for each finished step\n2. For incomplete steps:\n   - Leave as `pending` if work can continue\n   - Mark as `blocked` if there's an issue\n3. Decide whether to:\n   - Launch a new worker for remaining steps\n   - Report to user if there's an issue\n\n### Invalid State Recovery\n\nIf the JSON state becomes corrupted:\n\n1. Attempt to parse and identify the issue\n2. If recoverable, fix the JSON and continue\n3. If not recoverable, report to user:\n   - \"The plan state appears corrupted. Would you like me to re-initialize it from the markdown headings?\"\n   - Use `scripts/plan-tool init` to rebuild state if user confirms\n\n",
        "plugins/plan-exec/skills/plan-generator/SKILL.md": "---\nname: plan-generator\ndescription: Create self-updating plan files for complex projects with phased breakdown and autonomous execution tracking. Generates feature-specific plans (e.g., PLAN-auth.md, PLAN-api.md) that enable autonomous work across sessions. Use when user wants comprehensive project planning with phases and detailed steps.\n---\n\n# Plan Generator Skill\n\nThis skill creates standalone plan files for complex projects that enable autonomous, phased execution with real-time progress tracking.\n\n## When to Use This Skill\n\nUse this skill when:\n- User asks to create a project plan or PLAN file\n- User wants to break down a complex project into phases and steps\n- User needs a self-contained planning document for large initiatives\n\nDo NOT use this skill when:\n- User wants to EXECUTE an existing plan (use `plan-executor` skill instead)\n- User references an existing PLAN file to continue work\n\n## Plan File Naming\n\nPlans are feature/project-specific and can be named flexibly:\n- Single feature: `PLAN-{feature}.md` (e.g., `PLAN-auth.md`, `PLAN-api.md`)\n- Main project plan: `PLAN.md`\n- Multiple plans can coexist in one repository for different features\n\n**Always ask the user what filename they want** or suggest based on the project/feature name.\n\n## Plan File Structure\n\nWhen creating a plan file, follow this exact structure:\n\n### 1. Instructions for Claude Code (TOP OF FILE)\n\nThis section MUST be first. Keep it concise (~15 lines):\n\n```markdown\n## Instructions for Claude Code\n\nWhen working on this plan:\n1. **Use the `plan-executor` skill** to execute this plan\n2. **Work autonomously** through phases without stopping for approval (unless blocked)\n3. **Document findings** in the Notes & Decisions section\n\n**Execution Mode:** [direct|worker]\n**Auto-continue:** [yes|no]\n**Commit after phase:** [yes|no] (include PLAN file: [yes|no])\n```\n\n### 2. Current Phase Indicator\n\nSimple status at the top:\n- `**Current Phase:** Phase 1: [Phase Name]`\n- `**Current Phase:** COMPLETE`\n\n### 3. Project Overview\n\n- Clear description of the end goal\n- Context about what the project achieves\n- Key requirements (bulleted list)\n- Any constraints or dependencies\n\n### 4. Phase Breakdown\n\nEach phase should include:\n\n```markdown\n## Phase N: [Phase Name]\n\nBrief description of what this phase accomplishes.\n\n### Step N.1: [Step title]\nDetailed, actionable step description with context and requirements.\n\n### Step N.2: [Another step title]\nDescription for this step...\n```\n\n**Step Format Notes:**\n- Steps are markdown headings (`### Step N.X: Title`), NOT checkbox list items\n- Each step ID follows the format `{phase}.{step}` (e.g., `0.1`, `1.2`, `2.3`)\n- Include inline examples within phases when helpful (e.g., config structures, code snippets)\n\n### 5. Notes & Decisions Section\n\nMajor section after all phases: `## Notes & Decisions`\n\nTemplate structure for each phase:\n```markdown\n### Phase N: [Phase Name] (Status)\n- Implementation details and approach taken\n- Why decisions were made\n- Deviations from original plan with explanations\n- Technical details for future reference\n```\n\n### 6. Completion Checklist\n\nFinal section with overall project readiness criteria:\n```markdown\n## Completion Checklist\n\nBefore marking this project complete:\n- [ ] All phases marked complete\n- [ ] All tests passing\n- [ ] Build successful\n- [ ] Documentation complete\n```\n\n## Generating the Plan File\n\nWhen this skill is invoked:\n\n1. **Determine filename**: Ask user for desired filename or suggest based on project (e.g., \"I'll create PLAN-auth.md for this authentication feature\")\n\n2. **Ask about preferences**:\n\n   a) **Execution mode**:\n      - **Direct mode**: Execute steps in the main session (simpler, good for small plans)\n      - **Worker mode**: Delegate to sub-agents (recommended for large/complex plans)\n\n   b) **Auto-continue preference**:\n      - **Yes**: Automatically start the next phase without asking\n      - **No**: Ask for confirmation before each new phase (default)\n\n   c) **Commit preferences**:\n      - **Yes, include PLAN file**: Commit code changes AND updated PLAN file together\n      - **Yes, exclude PLAN file**: Commit only code changes\n      - **No**: User will handle commits manually\n\n3. **Gather project details** from the user if not already provided\n\n4. **Break down the project**:\n   - Identify logical phases (typically 3-8 phases, including Phase 0 for setup if needed)\n   - For each phase, identify concrete steps (3-10 steps per phase)\n   - Consider including inline examples (configs, schemas) in relevant phases\n\n5. **Create the plan file** with:\n   - Instructions section at the TOP (referencing `plan-executor` skill)\n   - Current Phase indicator with execution preferences\n   - Complete project overview\n   - All phases with detailed, actionable steps\n   - Empty Notes & Decisions section\n   - Completion checklist\n   - (JSON state will be initialized automatically by plan-executor on first run)\n\n6. **Make it standalone**: The file should contain enough context that referencing it in a fresh session gives Claude complete understanding of the project\n\n## Key Principles\n\n- **Instructions first**: Always put Claude instructions at the top of the file\n- **Reference plan-executor**: The instructions section should tell Claude to use the `plan-executor` skill\n- **Detailed steps**: Each step should be actionable with clear requirements\n- **Include examples**: Inline examples (configs, schemas, code snippets) make steps clearer\n- **Self-referential**: Plan should reference \"this file\" not a hardcoded filename\n\n## Example Usage\n\n### Example 1: Single Feature Plan\n\nUser: \"Create a plan for building a JWT authentication system with refresh tokens\"\n\nClaude should:\n1. Suggest: \"I'll create `PLAN-auth.md` for this authentication feature\"\n2. Ask about execution mode, auto-continue, and commit preferences\n3. Break down into phases like:\n   - Phase 0: Dependencies and project structure\n   - Phase 1: JWT token generation and validation\n   - Phase 2: Refresh token implementation\n   - Phase 3: Middleware integration\n   - Phase 4: Testing\n4. Create detailed steps for each phase with inline examples (e.g., JWT payload structure)\n5. Generate PLAN-auth.md with all structure including the JSON state block\n6. Inform user: \"I've created PLAN-auth.md. Reference it with `@PLAN-auth.md` to begin execution\"\n\n### Example 2: Main Project Plan\n\nUser: \"Create a plan for building a CLI tool with subcommands and configuration support\"\n\nClaude should:\n1. Suggest: \"I'll create `PLAN.md` for this project\"\n2. Follow same process as Example 1\n3. User can later create additional feature-specific plans alongside (e.g., PLAN-config.md)\n",
        "plugins/transcript-analyzer/.claude-plugin/plugin.json": "{\n  \"name\": \"transcript-analyzer\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Analyze Claude Code session transcripts for debugging plugins and understanding context usage\",\n  \"author\": {\n    \"name\": \"Bruno Franca dos Reis\",\n    \"email\": \"bfreis@gmail.com\"\n  }\n}\n",
        "plugins/transcript-analyzer/commands/transcript-bloat.md": "# /transcript-bloat\n\nIdentifies the largest tool results in a transcript to find sources of context bloat.\n\n## Usage\n\n```\n/transcript-bloat <path-to-transcript.jsonl> [count]\n```\n\n- `count`: Number of results to show (default: 10)\n\n## Implementation\n\nWhen the user runs this command:\n\n1. Run the transcript-tool bloat command:\n```bash\n\"$(dirname \"$(dirname \"$0\")\")/skills/transcript-analyzer/scripts/transcript-tool\" bloat \"<FILE_PATH>\" <COUNT>\n```\n\n2. Present the results showing:\n   - Size in characters\n   - Tool use ID\n   - Tool name\n\n3. If specific tool results are very large, suggest investigating:\n   - Are large files being read unnecessarily?\n   - Are agent outputs too verbose?\n   - Could glob/grep be more targeted?\n\nIf no file path is provided, explain how to find transcript files:\n- Location: `~/.claude/projects/-PATH-TO-PROJECT/*.jsonl`\n- Path format: slashes become dashes\n",
        "plugins/transcript-analyzer/commands/transcript-summary.md": "# /transcript-summary\n\nDisplays a quick summary of a Claude Code session transcript.\n\n## Usage\n\n```\n/transcript-summary <path-to-transcript.jsonl>\n```\n\n## Implementation\n\nWhen the user runs this command with a transcript file path:\n\n1. Run the transcript-tool summary command:\n```bash\n\"$(dirname \"$(dirname \"$0\")\")/skills/transcript-analyzer/scripts/transcript-tool\" summary \"<FILE_PATH>\"\n```\n\n2. Present the output to the user in a readable format.\n\nIf no file path is provided, explain how to find transcript files:\n- Location: `~/.claude/projects/-PATH-TO-PROJECT/*.jsonl`\n- Path format: slashes become dashes (e.g., `/Users/foo/myproject` → `-Users-foo-myproject`)\n",
        "plugins/transcript-analyzer/skills/transcript-analyzer/SKILL.md": "---\nname: transcript-analyzer\ndescription: Analyze Claude Code session transcripts to debug plugins, understand context usage, and trace execution flow\n---\n\n# Transcript Analyzer Skill\n\nUse this skill when you need to analyze Claude Code session transcripts for:\n- Debugging plugin behavior\n- Understanding context/token usage patterns\n- Tracing tool execution flow\n- Finding sources of context bloat\n- Investigating errors or unexpected behavior\n\n## Transcript Location\n\nClaude Code stores session transcripts at:\n```\n~/.claude/projects/-PATH-TO-PROJECT/*.jsonl\n```\n\nThe path uses dashes instead of slashes. For example:\n- Project: `/Users/bfreis/dev/myproject`\n- Transcripts: `~/.claude/projects/-Users-bfreis-dev-myproject/*.jsonl`\n\n## Transcript Structure\n\nTranscripts use **JSONL format** (one JSON object per line).\n\n### Record Types\n\n| Type | Description |\n|------|-------------|\n| `summary` | Session metadata |\n| `file-history-snapshot` | File change tracking |\n| `user` | User messages (includes tool results) |\n| `assistant` | Assistant messages (includes tool calls) |\n\n### Message Structure\n\n```json\n{\n  \"type\": \"user\" | \"assistant\",\n  \"uuid\": \"message-uuid\",\n  \"parentUuid\": \"parent-message-uuid\",\n  \"sessionId\": \"session-uuid\",\n  \"isSidechain\": false,\n  \"timestamp\": \"2025-12-06T...\",\n  \"message\": {\n    \"role\": \"user\" | \"assistant\",\n    \"content\": [...],\n    \"usage\": { \"input_tokens\": N, \"output_tokens\": N }\n  }\n}\n```\n\n### Content Block Types\n\n**In assistant messages:**\n- `text` - Regular text response\n- `tool_use` - Tool invocation with `.id`, `.name`, `.input`\n- `thinking` - Extended thinking blocks\n\n**In user messages:**\n- `text` - User input\n- `tool_result` - Tool output with `.tool_use_id`, `.content`\n\n### Critical Gotchas\n\n1. **Content is ALWAYS an array** - Even single text blocks\n2. **Tool result `.content` can be string OR array** - Handle both:\n   ```jq\n   if .content | type == \"array\" then\n     (.content | map(.text // \"\") | add)\n   else\n     .content\n   end\n   ```\n3. **Use `[]?` not `[]`** - Handles missing fields gracefully\n4. **Sub-agents have `isSidechain: true`** - Filter these for main conversation only\n5. **`parentUuid` links threads** - Not line order\n\n## Using transcript-tool\n\nThe skill provides a CLI at `scripts/transcript-tool`:\n\n```bash\n# Quick overview\ntranscript-tool summary session.jsonl\n\n# Find context bloat sources\ntranscript-tool bloat session.jsonl 15\n\n# Tool usage breakdown\ntranscript-tool tools session.jsonl\n\n# Trace specific tool\ntranscript-tool trace-tool session.jsonl Read\n\n# Find errors\ntranscript-tool errors session.jsonl\n\n# Custom jq query\ntranscript-tool extract session.jsonl '.type'\n```\n\n## Common Analysis Workflows\n\n### 1. Debug Plugin Behavior\n\n```bash\n# Find skill invocations\ntranscript-tool trace-skill session.jsonl plan-generator\n\n# See what tools were used\ntranscript-tool tools session.jsonl\n\n# Check for errors\ntranscript-tool errors session.jsonl\n```\n\n### 2. Investigate Context Bloat\n\n```bash\n# Find largest tool results\ntranscript-tool bloat session.jsonl 20\n\n# Message size analysis\ntranscript-tool messages session.jsonl\n\n# Identify specific large results\ntranscript-tool extract session.jsonl '\n  select(.type == \"user\") |\n  .message.content[]? |\n  select(.type == \"tool_result\") |\n  select((.content | tostring | length) > 10000) |\n  .tool_use_id\n'\n```\n\n### 3. Trace Execution Flow\n\n```bash\n# All tool calls in order\ntranscript-tool extract session.jsonl '\n  select(.type == \"assistant\") |\n  .message.content[]? |\n  select(.type == \"tool_use\") |\n  \"\\(.name): \\(.input | keys | join(\", \"))\"\n'\n```\n\n## Raw jq Recipes\n\nFor complex analysis, use jq directly:\n\n**Count content block types:**\n```bash\njq -r '\n  select(.type == \"user\" or .type == \"assistant\") |\n  .message.content[]? |\n  .type\n' session.jsonl | sort | uniq -c\n```\n\n**Find tool call by ID:**\n```bash\njq -r --arg id \"toolu_xxx\" '\n  select(.type == \"assistant\") |\n  .message.content[]? |\n  select(.type == \"tool_use\" and .id == $id)\n' session.jsonl\n```\n\n**Get corresponding tool result:**\n```bash\njq -r --arg id \"toolu_xxx\" '\n  select(.type == \"user\") |\n  .message.content[]? |\n  select(.type == \"tool_result\" and .tool_use_id == $id) |\n  .content\n' session.jsonl\n```\n\n**Token usage per message:**\n```bash\njq -r '\n  select(.type == \"assistant\" and .message.usage) |\n  \"\\(.message.usage.input_tokens) in, \\(.message.usage.output_tokens) out\"\n' session.jsonl\n```\n"
      },
      "plugins": [
        {
          "name": "plan-exec",
          "source": "./plugins/plan-exec",
          "description": "Create and execute self-updating plan files for complex projects with phased breakdown and autonomous execution tracking. Generates feature-specific plans (e.g., PLAN-auth.md, PLAN-api.md) that enable autonomous work across sessions.",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add bfreis/claude-mart",
            "/plugin install plan-exec@claude-mart"
          ]
        },
        {
          "name": "transcript-analyzer",
          "source": "./plugins/transcript-analyzer",
          "description": "Debug Claude Code plugins by analyzing session transcripts. Includes pre-built jq recipes, context bloat detection, tool usage tracing, and comprehensive documentation of transcript structure.",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add bfreis/claude-mart",
            "/plugin install transcript-analyzer@claude-mart"
          ]
        }
      ]
    }
  ]
}