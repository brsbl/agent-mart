{
  "author": {
    "id": "membrowse",
    "display_name": "MemBrowse",
    "avatar_url": "https://avatars.githubusercontent.com/u/260731484?v=4"
  },
  "marketplaces": [
    {
      "name": "membrowse-marketplace",
      "version": null,
      "description": "MemBrowse memory tracking integration for embedded firmware projects",
      "repo_full_name": "membrowse/membrowse-action",
      "repo_url": "https://github.com/membrowse/membrowse-action",
      "repo_description": "Track and analyze memory footprint in embedded firmware",
      "signals": {
        "stars": 16,
        "forks": 1,
        "pushed_at": "2026-02-13T10:28:15Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"membrowse-marketplace\",\n  \"owner\": {\n    \"name\": \"MemBrowse\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"membrowse\",\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"membrowse/membrowse-action\"\n      },\n      \"description\": \"MemBrowse memory tracking integration for embedded firmware projects\",\n      \"version\": \"1.0.11\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"membrowse\",\n  \"description\": \"MemBrowse memory tracking integration for embedded firmware projects. Automatically sets up GitHub workflows for RAM/Flash analysis.\",\n  \"version\": \"1.0.11\",\n  \"author\": {\n    \"name\": \"MemBrowse\"\n  },\n  \"repository\": \"https://github.com/membrowse/membrowse-action\",\n  \"keywords\": [\"embedded\", \"memory\", \"firmware\", \"elf\", \"arm\", \"esp32\", \"stm32\", \"rp2040\"]\n}\n",
        "README.md": "# MemBrowse\n\n[![PyPI version](https://badge.fury.io/py/membrowse.svg)](https://badge.fury.io/py/membrowse)\n[![Python Versions](https://img.shields.io/pypi/pyversions/membrowse.svg)](https://pypi.org/project/membrowse/)\n[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)\n[![Downloads](https://pepy.tech/badge/membrowse)](https://pepy.tech/project/membrowse)\n\nA tool for analyzing memory footprint in embedded firmware. MemBrowse extracts detailed memory information from ELF files and linker scripts, providing symbol-level analysis with source file mapping for multiple architectures. Use it standalone for local analysis or integrate with [MemBrowse](https://membrowse.com) for historical analysis and CI integration.\n\n\n## Features\n\n- **Architecture Agnostic**: Works with architectures that produce ELFs with DWARF debug format\n- **Source File Mapping**: Symbols are mapped to their definition source files\n- **Memory Region Extraction**: Memory region capacity and layout are extracted from GNU LD linker scripts\n- **Cloud Integration**: Upload reports to [MemBrowse](https://membrowse.com) for historical tracking, diffs, monitoring and CI gating \n\n## CI/CD Integration\n\n### GitHub Actions\n\nMemBrowse provides GitHub Actions for CI integration.\n\n\n#### PR/Push Analysis\n\nCreate a Github action for PR analysis that will call `membrowse/membrowse-action`:\n\n```yaml\nname: Memory Analysis\non: [push, pull_request]\n\njobs:\n  analyze:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build firmware\n        run: make all # your build commands\n\n      - name: Analyze memory\n        id: analyze\n        uses: membrowse/membrowse-action@v1\n        with:\n          elf: build/firmware.elf # your elf\n          ld: \"src/linker.ld\" # your ld scripts\n          target_name: stm32f4 # the target name will be recognized by Membrowse\n          api_key: ${{ secrets.MEMBROWSE_API_KEY }}\n\n      - name: Post PR comment\n        if: github.event_name == 'pull_request'\n        uses: membrowse/membrowse-action/comment-action@v1\n        with:\n          json_files: ${{ steps.analyze.outputs.report_path }}\n          # Optional: use a custom Jinja2 template for the comment\n          # comment_template: .github/membrowse-comment.j2\n```\n\nThe comment action posts a memory report to the PR showing changes between the PR branch and the base branch. The report includes memory region utilization changes (e.g. FLASH, RAM), section-level deltas (e.g. `.text`, `.bss`, `.data`), and symbol-level changes — added, removed, modified, and moved symbols. If budget alerts are configured on [MemBrowse](https://membrowse.com), any exceeded budgets are highlighted in the comment.\n\nYou can customize the comment format by providing a Jinja2 template via the `comment_template` input. Your template receives a `targets` list (each with `regions`, `sections`, `symbols`, and `alerts`) and a top-level `has_alerts` boolean. See the [default template](membrowse/utils/templates/default_comment.j2) for reference.\n\n#### Historical Onboarding\n\nFor getting historical build data from day one upload the last N commits by\nCreating an Onboard Github action in your repo that will call `membrowse/membrowse-action/onboard-action`:\n\n```yaml\nname: Onboard to MemBrowse\non: workflow_dispatch\n\njobs:\n  onboard:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Historical analysis\n        uses: membrowse/membrowse-action/onboard-action@v1\n        with:\n          num_commits: 100\n          build_script: \"make clean && make\" # your build commands\n          elf: build/firmware.elf # your elf file\n          ld: \"components.ld memory.ld\" #your ld scripts \n          target_name: my-target # the target name will be recognized by Membrowse\n          api_key: ${{ secrets.MEMBROWSE_API_KEY }}\n```\n\n### Claude Code Integration\n\nIf you use [Claude Code](https://claude.ai/code), you can automatically set up MemBrowse integration using the membrowse-integrate skill.\n\nFirst, add the MemBrowse plugin to Claude Code:\n\n```\n/plugin marketplace add membrowse@membrowse-action\n```\n\nThen run the skill in your project:\n\n```\n/membrowse-integrate\n```\n\nThis will:\n- Analyze your project's build system and targets\n- Verify builds and linker scripts work locally\n- Create `membrowse-targets.json` configuration\n- Set up GitHub Actions workflows for PR analysis and onboarding\n- Add a MemBrowse badge to your README\n\n## Local Installation\n\n### From PyPI\n\n```bash\npip install membrowse\n```\n\n### For Development\n\n```bash\n# Clone and install in editable mode\ngit clone https://github.com/membrowse/membrowse-action.git\ncd membrowse-action\npip install -e .\n```\n\n## Quick Start\n\n### Analyze Your Firmware Locally\n\nThe simplest way to analyze your firmware (local mode - no upload):\n\n```bash\n# Generate a human-readable report (default)\nmembrowse report \\\n  build/firmware.elf \\\n  \"src/linker.ld src/memory.ld\"\n\n# Output JSON format instead\nmembrowse report \\\n  build/firmware.elf \\\n  \"src/linker.ld src/memory.ld\" \\\n  --json\n\n# Show all symbols (not just top 20)\nmembrowse report \\\n  build/firmware.elf \\\n  \"src/linker.ld src/memory.ld\" \\\n  --all-symbols\n\n# With verbose output to see progress messages\nmembrowse -v INFO report \\\n  build/firmware.elf \\\n  \"src/linker.ld src/memory.ld\"\n```\n\nBy default, this generates a **human-readable report** with memory regions, sections, and top symbols. Use `--json` to output structured JSON data instead. Use `-v INFO` or `-v DEBUG` before the subcommand to see progress messages (default is `WARNING` which only shows warnings and errors).\n\n**Example output:**\n\n```\nELF Metadata: build/firmware.elf  |  Arch: ELF32  |  Machine: EM_ARM  |  Entry: 0x0802015d  |  Type: ET_EXEC\n=======================================================================================================================================\n\nRegion               Address Range                                Size                Used                Free  Utilization\n--------------------------------------------------------------------------------------------------------------------------------------------\nFLASH                0x08000000-0x08100000             1,048,576 bytes       365,192 bytes       683,384 bytes  [██████░░░░░░░░░░░░░░] 34.8%\n  └─ FLASH_START     0x08000000-0x08004000                16,384 bytes        14,708 bytes         1,676 bytes  [█████████████████░░░] 89.8%\n     • .isr_vector              392 bytes\n     • .isr_extratext        14,316 bytes\n  └─ FLASH_FS        0x08004000-0x08020000               114,688 bytes             0 bytes       114,688 bytes  [░░░░░░░░░░░░░░░░░░░░] 0.0%\n  └─ FLASH_TEXT      0x08020000-0x08100000               917,504 bytes       350,484 bytes       567,020 bytes  [███████░░░░░░░░░░░░░] 38.2%\n     • .text                350,476 bytes\n     • .ARM                       8 bytes\nRAM                  0x20000000-0x20020000               131,072 bytes        26,960 bytes       104,112 bytes  [████░░░░░░░░░░░░░░░░] 20.6%\n  • .data                       52 bytes\n  • .bss                     8,476 bytes\n  • .heap                   16,384 bytes\n  • .stack                   2,048 bytes\n\nTop 20 Largest Symbols\n======================\n\nName                                     Address                    Size  Type       Section              Source\n--------------------------------------------------------------------------------------------------------------------------------------------\nusb_device                               0x20000a30          5,444 bytes  OBJECT     .bss                 usb.c\nmp_qstr_const_pool                       0x08062b70          4,692 bytes  OBJECT     .text                qstr.c\nmp_execute_bytecode                      0x080392f9          4,208 bytes  FUNC       .text                vm.c\nfresh_pybcdc_inf                         0x0806ffaa          2,598 bytes  OBJECT     .text                factoryreset.c\nemit_inline_thumb_op                     0x0802ac25          2,476 bytes  FUNC       .text                emitinlinethumb.c\nmp_qstr_const_hashes                     0x08061b36          2,334 bytes  OBJECT     .text                qstr.c\nstm_module_globals_table                 0x08073478          2,096 bytes  OBJECT     .text                modstm.c\nstm32_help_text                          0x08072366          2,067 bytes  OBJECT     .text                help.c\nmp_lexer_to_next                         0x080229ed          1,768 bytes  FUNC       .text                lexer.c\nf_mkfs                                   0x080020ed          1,564 bytes  FUNC       .isr_extratext       ff.c\n...\n```\n\n### Upload Reports to MemBrowse Platform\n\n```bash\n# Upload mode - uploads report to MemBrowse platform (https://membrowse.com)\nmembrowse report \\\n  build/firmware.elf \\\n  \"src/linker.ld\" \\\n  --upload \\\n  --target-name esp32 \\\n  --api-key your-membrowse-api-key\n\n# GitHub Actions mode - auto-detects Git metadata from CI environment\nmembrowse report \\\n  build/firmware.elf \\\n  \"src/linker.ld\" \\\n  --upload \\\n  --github \\\n  --target-name esp32 \\\n  --api-key your-membrowse-api-key\n```\n\nWhen uploading, MemBrowse will fail the build (exit code 1) if budget alerts are detected. Use `--dont-fail-on-alerts` to continue despite alerts.\n\n### Analyze Historical Commits (Onboarding)\n\nAnalyzes memory footprints across multiple commits and uploads them to [MemBrowse](https://membrowse.com):\n\n```bash\n# Analyze and upload the last 50 commits\nmembrowse onboard \\\n  50 \\\n  \"make clean && make all\" \\\n  build/firmware.elf \\\n  \"STM32F746ZGTx_FLASH.ld\" \\\n  stm32f4 \\\n  your-membrowse-api-key\n```\n\n\n## Platform Support\n\nMemBrowse is with toolchains that produce ELF files and uses GNU LD linker scripts.\nIf you found that you're not getting optimal results please contact us: support@membrowse.com \nWe are actively working on improving Membrowse.\n\n## License\n\nSee [LICENSE](LICENSE) file for details.\n\n## Support\n\n- **Issues**: https://github.com/membrowse/membrowse-action/issues\n- **Documentation**: This README and inline code documentation\n- **MemBrowse Support**: support@membrowse.com\n"
      },
      "plugins": [
        {
          "name": "membrowse",
          "source": {
            "source": "github",
            "repo": "membrowse/membrowse-action"
          },
          "description": "MemBrowse memory tracking integration for embedded firmware projects",
          "version": "1.0.11",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add membrowse/membrowse-action",
            "/plugin install membrowse@membrowse-marketplace"
          ]
        }
      ]
    }
  ]
}