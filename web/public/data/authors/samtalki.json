{
  "author": {
    "id": "samtalki",
    "display_name": "Samuel Talkington",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/10187005?u=290e31870d72dba2cb8f950e33ebf08b335407b6&v=4",
    "url": "https://github.com/samtalki",
    "bio": "Ph.D. candidate in the School of Electrical and Computer Engineering at Georgia Tech.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 1,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "julia-tools",
      "version": null,
      "description": "Julia development tools for Claude Code - persistent REPL, package management, modern workflows",
      "owner_info": {
        "name": "Samuel Talkington",
        "email": "talkington@pm.me"
      },
      "keywords": [],
      "repo_full_name": "samtalki/AgentREPL.jl",
      "repo_url": "https://github.com/samtalki/AgentREPL.jl",
      "repo_description": "STDIO-based MCP server for persistent Julia REPL sessions, eliminating TTFX overhead for AI coding assistants",
      "homepage": "",
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-19T21:47:27Z",
        "created_at": "2026-01-15T19:36:40Z",
        "license": "Apache-2.0"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 976
        },
        {
          "path": "claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 196
        },
        {
          "path": "claude-plugin/README.md",
          "type": "blob",
          "size": 4133
        },
        {
          "path": "claude-plugin/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/commands/julia-activate.md",
          "type": "blob",
          "size": 1166
        },
        {
          "path": "claude-plugin/commands/julia-info.md",
          "type": "blob",
          "size": 654
        },
        {
          "path": "claude-plugin/commands/julia-pkg.md",
          "type": "blob",
          "size": 1770
        },
        {
          "path": "claude-plugin/commands/julia-reset.md",
          "type": "blob",
          "size": 904
        },
        {
          "path": "claude-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/skills/julia",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/skills/julia/SKILL.md",
          "type": "blob",
          "size": 9265
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"julia-tools\",\n  \"owner\": {\n    \"name\": \"Samuel Talkington\",\n    \"email\": \"talkington@pm.me\"\n  },\n  \"metadata\": {\n    \"description\": \"Julia development tools for Claude Code - persistent REPL, package management, modern workflows\",\n    \"version\": \"0.3.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"julia\",\n      \"source\": \"./claude-plugin\",\n      \"description\": \"Persistent Julia REPL for Claude Code - eliminates TTFX startup penalty, supports modern Julia workflows\",\n      \"version\": \"0.3.0\",\n      \"author\": {\n        \"name\": \"Samuel Talkington\",\n        \"email\": \"talkington@pm.me\"\n      },\n      \"homepage\": \"https://github.com/samtalki/AgentREPL.jl\",\n      \"repository\": \"https://github.com/samtalki/AgentREPL.jl\",\n      \"license\": \"Apache-2.0\",\n      \"keywords\": [\"julia\", \"repl\", \"mcp\", \"ttfx\", \"scientific-computing\", \"data-science\"],\n      \"category\": \"development\",\n      \"tags\": [\"julia\", \"repl\", \"persistent-session\", \"package-management\"]\n    }\n  ]\n}\n",
        "claude-plugin/.claude-plugin/plugin.json": "{\n  \"name\": \"julia\",\n  \"version\": \"0.5.0\",\n  \"description\": \"Persistent Julia REPL for Claude Code - eliminates TTFX startup penalty\",\n  \"repository\": \"https://github.com/samtalki/AgentREPL.jl\"\n}\n",
        "claude-plugin/README.md": "# Julia Plugin for Claude Code\n\nThis plugin provides a persistent Julia REPL for Claude Code, eliminating the \"Time to First X\" (TTFX) startup penalty that normally occurs with each Julia invocation.\n\n## Prerequisites\n\n- Julia 1.10+ installed and available in PATH\n- AgentREPL.jl package (this repository)\n\n## Installation\n\nInstall directly from GitHub:\n\n```bash\nclaude /plugin add samtalki/AgentREPL.jl\n```\n\nOr add the plugin directory locally for development:\n\n```bash\nclaude --plugin-dir /path/to/AgentREPL.jl/claude-plugin\n```\n\n## What's Included\n\n### MCP Server\n\nThe plugin automatically configures the `julia-repl` MCP server which provides:\n\n- `eval` - Evaluate Julia code with persistent state\n- `reset` - **Hard reset**: kills worker, spawns fresh one\n- `info` - Get session information (including worker ID)\n- `pkg` - Manage packages (add, rm, status, update, instantiate, resolve, test, develop, free)\n- `activate` - Switch project/environment\n- `log_viewer` - Open a terminal showing Julia output in real-time\n- `mode` - Switch between distributed and tmux modes (tmux is deprecated)\n\n### Commands\n\n- `/julia-reset` - Kill and respawn the Julia worker (true reset)\n- `/julia-info` - Show session information\n- `/julia-pkg <action> [packages]` - Package management\n- `/julia-activate <path>` - Activate a project/environment\n- `/julia-mode <mode>` - Switch execution mode (distributed recommended, tmux deprecated)\n\n### Skill\n\nThe `julia-evaluation` skill provides best practices guidance for:\n- Showing code before evaluation (for readable permission prompts)\n- Understanding TTFX behavior\n- Working with session persistence\n- Environment management\n- Testing and development workflows\n- When to use hard reset vs continuing\n\n## Architecture\n\nAgentREPL uses a **worker subprocess model**:\n- The MCP server runs in the main Julia process\n- Code evaluation happens in a spawned worker (via Distributed.jl)\n- `reset` kills the worker and spawns a fresh one\n- This enables true reset including type redefinitions\n\n## Usage\n\nOnce installed, simply ask Claude to run Julia code:\n\n> \"Calculate the first 20 Fibonacci numbers in Julia\"\n\nOn first use, Claude will ask about your environment preference:\n1. Current directory (activate Project.toml if present)\n2. Specific project path\n3. Default/global environment\n\n## Session Behavior\n\n- Variables, functions, and packages persist across evaluations\n- `reset` provides a true hard reset (kills worker process)\n- Type definitions CAN be changed after reset (unlike soft resets)\n- Activated environment persists even across reset\n- First evaluation is slow (TTFX), subsequent ones are fast\n\n## Visual Output (Log Viewer)\n\nTo see Julia output in real-time, use the log viewer:\n\n```\n# Open a terminal showing output as it happens\nlog_viewer(mode=\"auto\")\n```\n\nThis opens a tmux session or terminal with `tail -f ~/.julia/logs/repl.log`.\n\n## Tmux Mode (Deprecated)\n\n**Note:** Tmux bidirectional REPL mode is deprecated due to unfixable marker pollution issues.\n\nUse distributed mode (default) with the log viewer for visual output instead:\n- Set `JULIA_REPL_VIEWER=auto` environment variable, OR\n- Use the `log_viewer` tool at runtime\n\nTo force-enable tmux mode (not recommended):\n- Set `JULIA_REPL_ENABLE_TMUX=true` environment variable\n\n## Package Management\n\nThe `pkg` tool supports these actions:\n\n| Action | Description | Packages Required |\n|--------|-------------|-------------------|\n| `add` | Install packages | Yes |\n| `rm` | Remove packages | Yes |\n| `status` | Show installed packages | No |\n| `update` | Update packages | No (optional) |\n| `instantiate` | Install from Project.toml | No |\n| `resolve` | Update Manifest.toml | No |\n| `test` | Run package tests | No (optional) |\n| `develop` | Use local package code | Yes (path or name) |\n| `free` | Exit development mode | Yes |\n\n## Development Workflow\n\nFor local package development:\n\n```\n# Put package in develop mode\n/julia-pkg develop ./MyLocalPackage\n\n# Make changes to the source code...\n\n# Test your changes\n/julia-pkg test MyLocalPackage\n\n# When done, return to registry version\n/julia-pkg free MyLocalPackage\n```\n",
        "claude-plugin/commands/julia-activate.md": "---\nname: julia-activate\ndescription: Activate a Julia project/environment for the session\nargument-hint: \"<path>\"\nallowed-tools:\n  - mcp__plugin_julia_julia-repl__activate\n  - mcp__plugin_julia_julia-repl__pkg\n---\n\n# Julia Activate Command\n\nActivate a Julia project or environment for the current session.\n\n## Arguments\n\n- `path` - Path to project directory, \".\" for current directory, or named environment like \"@v1.10\"\n\n## Instructions\n\n1. Parse the user's argument to determine the path:\n   - If no argument or \".\", activate the current working directory\n   - If a path is given, use that path\n   - If starts with \"@\", it's a named environment\n\n2. Call `activate` with the path\n\n3. After activation, offer to run `pkg(action=\"instantiate\")` to install dependencies if the project has a Project.toml\n\n## Examples\n\n```\n/julia-activate .\n/julia-activate /path/to/MyProject\n/julia-activate @v1.10\n```\n\n## Notes\n\n- Activating a project changes where packages are installed/loaded from\n- Use `pkg(action=\"instantiate\")` after activation to install dependencies\n- The activated environment persists across `reset` calls\n- Use `info` to see the currently active project\n",
        "claude-plugin/commands/julia-info.md": "---\nname: julia-info\ndescription: Show Julia session information (version, project, variables, loaded modules)\nallowed-tools:\n  - mcp__plugin_julia_julia-repl__info\n---\n\n# Julia Info Command\n\nDisplay information about the current Julia session.\n\n## Instructions\n\n1. Call the `info` MCP tool\n2. Present the information clearly to the user:\n   - Julia version\n   - Active project path\n   - User-defined variables\n   - Number of loaded modules\n   - Worker process ID\n\n## Use Cases\n\n- Check what variables exist from previous work\n- Verify which Julia version is running\n- See the active project environment\n- Confirm the worker is alive and which ID it has\n",
        "claude-plugin/commands/julia-pkg.md": "---\nname: julia-pkg\ndescription: Manage Julia packages (add, remove, status, update, test, develop)\nargument-hint: \"<action> [packages]\"\nallowed-tools:\n  - mcp__plugin_julia_julia-repl__pkg\n---\n\n# Julia Package Management Command\n\nManage Julia packages in the current environment.\n\n## Arguments\n\n- `action` - One of: add, rm, status, update, instantiate, resolve, test, develop, free\n- `packages` - Package names or paths (required for add/rm/develop/free, optional for update/test)\n\n## Instructions\n\nParse the user's arguments to determine the action and packages:\n\n| User Input | Action | Packages |\n|------------|--------|----------|\n| `add JSON` | add | JSON |\n| `add JSON DataFrames CSV` | add | JSON, DataFrames, CSV |\n| `rm OldPackage` | rm | OldPackage |\n| `status` | status | (none) |\n| `update` | update | (none - updates all) |\n| `update JSON` | update | JSON |\n| `instantiate` | instantiate | (none) |\n| `resolve` | resolve | (none) |\n| `test` | test | (none - tests current project) |\n| `test MyPackage` | test | MyPackage |\n| `develop ./MyLocalPkg` | develop | ./MyLocalPkg |\n| `free MyPackage` | free | MyPackage |\n\nCall `pkg` with the appropriate action and packages parameters.\n\n## Examples\n\n```\n/julia-pkg add Plots\n/julia-pkg status\n/julia-pkg update\n/julia-pkg instantiate\n/julia-pkg test\n/julia-pkg develop ./path/to/MyPackage\n/julia-pkg free MyPackage\n```\n\n## Notes\n\n- After adding packages, remind the user to load them with `using PackageName`\n- The `instantiate` action installs dependencies from Project.toml/Manifest.toml\n- The `test` action runs Pkg.test() - can be slow for large test suites\n- The `develop` action puts a package in development mode (uses local code)\n- The `free` action exits development mode (returns to registry version)\n",
        "claude-plugin/commands/julia-reset.md": "---\nname: julia-reset\ndescription: Kill and respawn the Julia worker (hard reset)\nallowed-tools:\n  - mcp__plugin_julia_julia-repl__reset\n---\n\n# Julia Reset Command\n\nKill the Julia worker process and spawn a fresh one (hard reset).\n\n## What This Does\n\nUnlike a \"soft reset\" that only clears variables, this is a **hard reset** that:\n- Kills the worker process entirely\n- Spawns a fresh Julia worker\n- Clears all variables, functions, and loaded packages\n- **Enables type/struct redefinitions** (impossible with soft reset)\n- Re-activates the previously activated project\n\n## Instructions\n\n1. Call the `reset` MCP tool\n2. Report the old and new worker IDs to the user\n3. Remind the user that packages need to be reloaded with `using`\n\n## When to Use\n\n- You need to redefine a struct or type\n- The session is in a bad/corrupted state\n- You want a completely clean slate\n- Something is behaving unexpectedly\n",
        "claude-plugin/skills/julia/SKILL.md": "---\nname: julia-evaluation\ndescription: This skill should be used when the user asks to \"run Julia code\", \"evaluate Julia\", \"use Julia\", mentions \"persistent Julia session\", \"TTFX\", or wants to work with Julia for data analysis, scientific computing, or package development. Provides best practices for using the Julia REPL MCP tools effectively.\nversion: 0.5.0\n---\n\n# Julia Development Best Practices\n\nThis skill provides guidance for using the persistent Julia REPL via MCP tools. AgentREPL maintains a worker subprocess for code evaluation, eliminating the \"Time to First X\" (TTFX) startup penalty that normally occurs with each Julia invocation.\n\n## Architecture\n\nAgentREPL uses a **distributed worker model** (recommended):\n\n### Distributed Mode (Default, Recommended)\n- The MCP server runs in the main process (STDIO transport)\n- Code evaluation happens in a spawned worker process (via Distributed.jl)\n- `reset` kills the worker and spawns a fresh one (true hard reset)\n- Use `log_viewer` tool to open a terminal showing output in real-time\n\n### Visual Output with Log Viewer\n\nTo see Julia output as it happens:\n```\nlog_viewer(mode=\"auto\")   # Opens a terminal with live output\n```\n\nOr set `JULIA_REPL_VIEWER=auto` environment variable before starting.\n\n### Note on Tmux Mode\n\nTmux mode is deprecated due to unfixable marker pollution issues. Use distributed mode (default) with `log_viewer` for visual output.\n\n## Available Tools\n\n| Tool | Purpose |\n|------|---------|\n| `eval` | Evaluate Julia code with persistent state |\n| `reset` | **Hard reset** - kills worker, spawns fresh one (enables type redefinition) |\n| `info` | Get session info (version, project, variables, worker ID) |\n| `pkg` | Manage packages (add, rm, status, update, instantiate, resolve, test, develop, free) |\n| `activate` | Switch active project/environment |\n| `log_viewer` | Open a terminal window showing Julia output in real-time |\n| `mode` | (Deprecated) Switch between distributed and tmux modes |\n\n## Critical: Beautiful Code and Output Display\n\n**The goal is to make Julia work feel like an interactive REPL session.**\n\n### Before Evaluation: Show the Code\n\nAlways display code in a readable format **before** calling `eval`. The MCP permission prompt shows code as an escaped string which is difficult to read.\n\n```\nRunning this Julia code:\n```julia\nA = [1 2 3; 4 5 6; 7 8 9]\ndet(A)\n```\n\n[then call eval]\n```\n\n### After Evaluation: Format Results Beautifully\n\nPresent results in REPL-style with proper formatting:\n\n```julia\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> det(A)\n0.0\n```\n\nThis workflow gives users the best of both worlds: they can verify code before it runs, and see results in a beautiful, readable format afterward.\n\n## Understanding TTFX (Time to First X)\n\nThe first call to `eval` in a session may take several seconds due to:\n- Julia's JIT compilation\n- Package loading and precompilation\n\nSubsequent calls are fast because the worker process stays alive with compiled code in memory. This is the core value proposition of AgentREPL.\n\n## Session Persistence\n\nVariables, functions, and loaded packages persist across `eval` calls:\n\n```julia\n# First call\nx = 42\nf(n) = n^2\n```\n\n```julia\n# Later call - x and f still exist\nf(x)  # Returns 1764\n```\n\n## Hard Reset with `reset`\n\nThe `reset` tool **kills the worker process and spawns a fresh one**. This means:\n\n- All variables are cleared\n- All loaded packages are unloaded\n- **Type definitions can be changed** (impossible with soft reset)\n- The worker starts completely fresh\n\nUse `reset` when:\n- You need to redefine a struct or type\n- Something is in a bad state\n- You want a completely clean slate\n\nAfter reset, packages need to be reloaded with `using`.\n\nThe activated environment persists across resets.\n\n## Environment Management\n\nJulia best practice is to use project-specific environments. Use `activate` to switch environments:\n\n```\nactivate(path=\".\")              # Current directory\nactivate(path=\"/path/to/proj\")  # Specific project\nactivate(path=\"@v1.10\")         # Named shared environment\n```\n\nAfter activation, install dependencies:\n```\npkg(action=\"instantiate\")\n```\n\nThe activated environment persists even across `reset` calls.\n\n## Package Management\n\nUse `pkg` for all package operations:\n\n**Adding packages:**\n```\npkg(action=\"add\", packages=\"JSON, DataFrames, CSV\")\n```\n\n**Checking installed packages:**\n```\npkg(action=\"status\")\n```\n\n**Installing from Project.toml:**\n```\npkg(action=\"instantiate\")\n```\n\n**Running tests:**\n```\npkg(action=\"test\")                    # Test current project\npkg(action=\"test\", packages=\"MyPkg\")  # Test specific package\n```\n\n**Development workflow (local packages):**\n```\npkg(action=\"develop\", packages=\"./path/to/MyLocalPackage\")  # Use local code\npkg(action=\"free\", packages=\"MyPackage\")                     # Return to registry\n```\n\nAfter adding a package, load it:\n```julia\nusing JSON\n```\n\n## Testing Workflow\n\nFor running tests, use `pkg(action=\"test\")`:\n- With no packages specified, tests the current project\n- With packages specified, tests those specific packages\n- Test output is captured and displayed\n\nThis is preferred over running tests via `eval` because it properly isolates the test environment.\n\n## Development Workflow (Pkg.develop)\n\nWhen developing a local package alongside your project:\n\n1. **Put the package in develop mode:**\n   ```\n   pkg(action=\"develop\", packages=\"./MyLocalPackage\")\n   ```\n\n2. **Make changes to the package source code**\n\n3. **Test your changes:**\n   ```\n   pkg(action=\"test\", packages=\"MyLocalPackage\")\n   ```\n\n4. **When done, return to registry version:**\n   ```\n   pkg(action=\"free\", packages=\"MyLocalPackage\")\n   ```\n\nThe `develop` action accepts:\n- Relative paths starting with `./` or `../`\n- Absolute paths starting with `/`\n- Home-relative paths starting with `~`\n- Package names (for developing registered packages from source)\n\n## Error Handling\n\nCommon issues and solutions:\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| `UndefVarError` | Variable not defined | Re-run earlier code or check spelling |\n| `MethodError` | Wrong argument types | Check function signatures |\n| `LoadError` | Package not installed | Use `pkg(action=\"add\", packages=\"...\")` |\n| `cannot redefine` | Type redefinition | Use `reset` for a fresh worker |\n| `StackOverflowError` | Infinite recursion | Fix recursion, may need `reset` |\n\n## First-Time Setup\n\n**When first using Julia in a session**, ask the user about their environment preference before running code:\n\n> \"Before we start, which Julia environment should I use?\n> 1. **Current directory** - activate Project.toml in this folder (if it exists)\n> 2. **Specific project** - provide a path to a Julia project\n> 3. **Default** - use the global environment\n>\n> This determines where packages are installed and what dependencies are available.\"\n\nBased on their answer:\n- Option 1: `activate(path=\".\")` then `pkg(action=\"instantiate\")`\n- Option 2: `activate(path=\"/their/path\")` then `pkg(action=\"instantiate\")`\n- Option 3: Proceed without activation (uses default environment)\n\n## Practical Workflow\n\nFor a typical Julia task:\n\n1. **First use**: Ask about environment (see above)\n2. **Activate and install**: `activate` + `pkg(action=\"instantiate\")`\n3. **Show code to user**, then call `eval`\n4. **Build incrementally** - variables persist across calls\n5. **Run tests**: `pkg(action=\"test\")` to verify changes\n6. **Use `reset`** if types need redefining or state is corrupted\n\n## Multi-line Code\n\nMulti-line code blocks work naturally:\n\n```julia\nfunction fibonacci(n)\n    if n <= 1\n        return n\n    end\n    return fibonacci(n-1) + fibonacci(n-2)\nend\n\n[fibonacci(i) for i in 1:10]\n```\n\n## Formatting Results Beautifully\n\n**CRITICAL: Always format Julia results in a readable REPL-style code block.**\n\nAfter calling `eval`, present the results to the user in a nicely formatted way that mimics the Julia REPL experience. This is especially important for:\n- Matrices and arrays (show the full formatted output)\n- DataFrames and tables\n- Custom types with pretty-printing\n- Multi-line output\n\n**Example - Good formatting:**\n\n```julia\njulia> A = [1 3 4; 4 5 6; 2 0 3]\n3×3 Matrix{Int64}:\n 1  3  4\n 4  5  6\n 2  0  3\n\njulia> inv(A)\n3×3 Matrix{Float64}:\n -0.6   0.36   0.08\n  0.0   0.2   -0.4\n  0.4  -0.24   0.28\n```\n\n**Example - Bad formatting (don't do this):**\n\n> The result is `[1 3 4; 4 5 6; 2 0 3]` and the inverse is `[-0.6 0.36 0.08; 0.0 0.2 -0.4; 0.4 -0.24 0.28]`\n\nThe REPL-style formatting:\n- Shows the `julia>` prompt with the command\n- Preserves matrix/array alignment and spacing\n- Makes numerical results easy to read and verify\n- Feels like an interactive Julia session\n\n## Output Capture\n\nBoth return values and printed output are captured from the `eval` tool. Format them beautifully as shown above.\n\n## When NOT to Use These Tools\n\nPrefer direct bash commands when:\n- Running a standalone Julia script: `julia script.jl`\n- Running with specific command-line flags\n- The task is one-shot and doesn't benefit from persistence\n\nUse the MCP tools when:\n- Interactive development and exploration\n- Iterative work where state should persist\n- Avoiding TTFX overhead matters\n- Package development workflow\n"
      },
      "plugins": [
        {
          "name": "julia",
          "source": "./claude-plugin",
          "description": "Persistent Julia REPL for Claude Code - eliminates TTFX startup penalty, supports modern Julia workflows",
          "version": "0.3.0",
          "author": {
            "name": "Samuel Talkington",
            "email": "talkington@pm.me"
          },
          "homepage": "https://github.com/samtalki/AgentREPL.jl",
          "repository": "https://github.com/samtalki/AgentREPL.jl",
          "license": "Apache-2.0",
          "keywords": [
            "julia",
            "repl",
            "mcp",
            "ttfx",
            "scientific-computing",
            "data-science"
          ],
          "category": "development",
          "tags": [
            "julia",
            "repl",
            "persistent-session",
            "package-management"
          ],
          "categories": [
            "data-science",
            "development",
            "julia",
            "mcp",
            "package-management",
            "persistent-session",
            "repl",
            "scientific-computing",
            "ttfx"
          ],
          "install_commands": [
            "/plugin marketplace add samtalki/AgentREPL.jl",
            "/plugin install julia@julia-tools"
          ]
        }
      ]
    }
  ]
}