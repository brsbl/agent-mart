{
  "author": {
    "id": "amoscicki",
    "display_name": "amoscicki",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/82836981?v=4",
    "url": "https://github.com/amoscicki",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 1,
      "total_skills": 4,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "amoscicki-plugins",
      "version": null,
      "description": "Personal Claude Code plugins by Arkadiusz Moscicki",
      "owner_info": {
        "name": "Arkadiusz Moscicki",
        "url": "https://github.com/amoscicki"
      },
      "keywords": [],
      "repo_full_name": "amoscicki/aromatt",
      "repo_url": "https://github.com/amoscicki/aromatt",
      "repo_description": "Claude Code plugins marketplace",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-26T04:48:30Z",
        "created_at": "2025-12-11T19:00:38Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 892
        },
        {
          "path": "docs-researcher",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 210
        },
        {
          "path": "docs-researcher/README.md",
          "type": "blob",
          "size": 4597
        },
        {
          "path": "docs-researcher/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/agents/docs-researcher.md",
          "type": "blob",
          "size": 2093
        },
        {
          "path": "docs-researcher/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/skills/docs-researcher",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/skills/docs-researcher/SKILL.md",
          "type": "blob",
          "size": 1959
        },
        {
          "path": "docs-researcher/skills/research-methodology",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/skills/research-methodology/SKILL.md",
          "type": "blob",
          "size": 5455
        },
        {
          "path": "docs-researcher/skills/research-methodology/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs-researcher/skills/research-methodology/references/document-template.md",
          "type": "blob",
          "size": 5800
        },
        {
          "path": "docs-researcher/skills/research-methodology/references/query-patterns.md",
          "type": "blob",
          "size": 2322
        },
        {
          "path": "gapi",
          "type": "tree",
          "size": null
        },
        {
          "path": "gapi/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "gapi/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 193
        },
        {
          "path": "gapi/README.md",
          "type": "blob",
          "size": 654
        },
        {
          "path": "gapi/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "gapi/skills/gapi",
          "type": "tree",
          "size": null
        },
        {
          "path": "gapi/skills/gapi/SKILL.md",
          "type": "blob",
          "size": 5933
        },
        {
          "path": "swarm",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 237
        },
        {
          "path": "swarm/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/agents/swarm-reviewer-opus.md",
          "type": "blob",
          "size": 3305
        },
        {
          "path": "swarm/agents/swarm-reviewer-ultrathink.md",
          "type": "blob",
          "size": 3527
        },
        {
          "path": "swarm/agents/swarm-worker-haiku.md",
          "type": "blob",
          "size": 3697
        },
        {
          "path": "swarm/agents/swarm-worker-opus.md",
          "type": "blob",
          "size": 3362
        },
        {
          "path": "swarm/agents/swarm-worker-ultrathink.md",
          "type": "blob",
          "size": 3802
        },
        {
          "path": "swarm/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/commands/swarm.md",
          "type": "blob",
          "size": 9598
        },
        {
          "path": "swarm/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/skills/swarm",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/skills/swarm/SKILL.md",
          "type": "blob",
          "size": 5476
        },
        {
          "path": "swarm/skills/swarm/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "swarm/skills/swarm/references/architect-protocol.md",
          "type": "blob",
          "size": 6127
        },
        {
          "path": "swarm/skills/swarm/references/auditor-protocol.md",
          "type": "blob",
          "size": 7544
        },
        {
          "path": "swarm/skills/swarm/references/escalation-rules.md",
          "type": "blob",
          "size": 4650
        },
        {
          "path": "swarm/skills/swarm/references/orchestrator-protocol.md",
          "type": "blob",
          "size": 18205
        },
        {
          "path": "swarm/skills/swarm/references/plan-format.md",
          "type": "blob",
          "size": 9388
        },
        {
          "path": "swarm/skills/swarm/references/worker-protocol.md",
          "type": "blob",
          "size": 5576
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"amoscicki-plugins\",\n  \"owner\": {\n    \"name\": \"Arkadiusz Moscicki\",\n    \"url\": \"https://github.com/amoscicki\"\n  },\n  \"description\": \"Personal Claude Code plugins by Arkadiusz Moscicki\",\n  \"plugins\": [\n    {\n      \"name\": \"docs-researcher\",\n      \"description\": \"Manage project knowledge base. Use 'init' to setup, or provide a topic to research.\",\n      \"source\": \"./docs-researcher\",\n      \"version\": \"1.0.2\"\n    },\n    {\n      \"name\": \"swarm-orchestrator\",\n      \"description\": \"Multi-agent parallel task orchestration with wave-based execution, automatic auditing, and model escalation\",\n      \"source\": \"./swarm\",\n      \"version\": \"1.0.4\"\n    },\n    {\n      \"name\": \"gapi\",\n      \"description\": \"Google Tag Manager + Analytics Admin APIs CLI - manage GTM containers/tags/triggers and GA properties/data-streams\",\n      \"source\": \"./gapi\",\n      \"version\": \"1.0.0\"\n    }\n  ]\n}\n",
        "docs-researcher/.claude-plugin/plugin.json": "{\n  \"name\": \"docs-researcher\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Manage project knowledge base. Use 'init' to setup, or provide a topic to research.\",\n  \"author\": {\n    \"name\": \"Arkadiusz Moscicki\"\n  }\n}\n",
        "docs-researcher/README.md": "# docs-researcher\n\nA Claude Code plugin that provides a documentation research agent. The agent searches official documentation, filters relevant information for the current task, and saves it to `.claude/skills/project-knowledge-base/` as a reusable project-local knowledge base skill.\n\n## Purpose\n\nThis plugin enables Claude to build its own knowledge base for each project. Instead of repeatedly searching for the same documentation, Claude:\n\n1. Initializes the project knowledge base skill (if not exists)\n2. Checks `.claude/skills/project-knowledge-base/references/` for existing documentation\n3. If not found, uses the `docs-researcher` agent to gather information\n4. Saves filtered, task-relevant documentation for future sessions\n5. Updates the skill index for easy discovery\n\n## Installation\n\nCopy the `docs-researcher` folder to your Claude Code plugins directory, or reference it in your dotfiles setup.\n\n## How It Works\n\n### Automatic Initialization\n\nWhen `docs-researcher` runs in a new project, it automatically:\n\n1. Creates `.claude/skills/project-knowledge-base/` structure\n2. Initializes `SKILL.md` with references index\n3. Creates `references/` directory for documentation\n4. Optionally adds knowledge base section to project's `CLAUDE.md`\n5. Migrates any existing `.claude/knowledge/` files (legacy format)\n\n### Knowledge Base Skill\n\nThe skill created in each project provides:\n\n```\n{project}/\n└── .claude/\n    └── skills/\n        └── project-knowledge-base/\n            ├── SKILL.md           # Index with all references\n            └── references/\n                ├── react-hooks.md\n                ├── tanstack-router/    # Tree for large topics (>500 lines)\n                │   ├── _index.md\n                │   └── route-guards.md\n                └── ...\n```\n\n## Project Setup\n\nTo enable the knowledge-building workflow in a project, add this to your project's `CLAUDE.md`:\n\n```markdown\n## Knowledge Base\n\nTen projekt używa `.claude/skills/project-knowledge-base/`.\nPrzed kodowaniem zapoznaj się ze skillem.\n```\n\nThe agent will add this section automatically if it doesn't exist.\n\n## Components\n\n### Agent: docs-researcher\n\nAutonomous agent that:\n- Initializes project knowledge base skill (Step 0)\n- Validates research requests (technology, topic, context required)\n- Checks existing references before researching\n- Uses WebSearch/WebFetch for documentation\n- Filters results for relevance\n- Saves to standardized knowledge format\n- Updates SKILL.md index\n- Applies progressive disclosure for large documents (>500 lines)\n\n**Model**: Haiku (fast, cost-effective for research tasks)\n\n### Skill: research-methodology\n\nProvides the agent with:\n- WebSearch query patterns for different technology domains\n- Source prioritization (official docs first)\n- Filtering criteria\n- Document template and formatting rules\n- Progressive disclosure guidelines\n\n### Script: init.js\n\nNode.js script that creates the knowledge base skill structure:\n- Creates `.claude/skills/project-knowledge-base/`\n- Initializes `SKILL.md` with base template\n- Creates `references/` directory\n\n## Knowledge File Format\n\nFiles are saved as `.claude/skills/project-knowledge-base/references/{technology}-{topic}.md`:\n\n```yaml\n---\ntopic: \"React useEffect Cleanup for Subscriptions\"\ntechnology: \"react\"\nversion: \"18.x\"\nsources:\n  - https://react.dev/reference/react/useEffect\ncreated: 2025-01-15\ncontext: \"Memory leak in subscription component\"\n---\n```\n\n## Progressive Disclosure\n\nWhen a reference exceeds 500 lines, it's automatically split into a tree:\n\n```\nreferences/tanstack-router.md  (>500 lines)\n↓ split to\nreferences/tanstack-router/\n├── _index.md        # Overview + TOC\n├── route-guards.md\n├── data-loading.md\n└── navigation.md\n```\n\n## Migration\n\nProjects with the legacy `.claude/knowledge/` format are automatically migrated:\n\n1. Agent detects existing `.claude/knowledge/*.md` files\n2. Copies each file to `.claude/skills/project-knowledge-base/references/`\n3. Adds entries to SKILL.md index\n4. **Does NOT delete originals** - user verifies and removes manually\n\n## Directory Structure\n\n```\ndocs-researcher/\n├── .claude-plugin/\n│   └── plugin.json\n├── agents/\n│   └── docs-researcher.md\n├── scripts/\n│   └── init.js\n├── skills/\n│   └── research-methodology/\n│       ├── SKILL.md\n│       └── references/\n│           ├── query-patterns.md\n│           └── document-template.md\n└── README.md\n```\n\n## License\n\nMIT\n",
        "docs-researcher/agents/docs-researcher.md": "---\nname: docs-researcher\ndescription: |\n  Research project codebase and web documentation, save to project knowledge base.\n\nmodel: haiku\ncolor: cyan\ntools: Read, Write, Glob, Grep, WebSearch, WebFetch\n---\n\nYou are a documentation researcher agent.\n\n## Task\n\n1. **Check project** - Search codebase for existing helpers, utils, patterns\n2. **Search web** - Find official documentation\n3. **Save** - Write to `.claude/skills/project-knowledge-base/references/{technology}-{topic}.md`\n4. **Update index** - Add entry to SKILL.md\n\n## Protocol\n\n### Step 1: Check project codebase\n\nSearch for existing code related to the topic:\n\n```\nGlob(pattern=\"**/*.{ts,tsx,js,jsx}\")\nGrep(pattern=\"{relevant pattern}\", include=\"*.{ts,tsx}\")\n```\n\nLook for:\n- Existing helper functions\n- Utils related to the topic\n- Current patterns/implementations\n- Project-specific conventions\n\nInclude relevant findings in the knowledge file.\n\n### Step 2: Research web\n\n```\nWebSearch(query=\"{technology} official documentation {topic}\")\nWebFetch(url=\"...\", prompt=\"Extract {topic} information\")\n```\n\nPrioritize official docs. Skip SEO spam.\n\n### Step 3: Write reference file\n\n```\nWrite(\n  file_path=\".claude/skills/project-knowledge-base/references/{technology}-{topic}.md\",\n  content=\"---\ntopic: \\\"{title}\\\"\ntechnology: \\\"{technology}\\\"\nversion: \\\"{version}\\\"\nsources:\n  - {url}\ncreated: {YYYY-MM-DD}\n---\n\n# {Title}\n\n## Summary\n{2-3 sentences}\n\n## Project Context\n{Existing helpers, utils, patterns found in codebase - if any}\n\n## Key Concepts\n{Core info from docs}\n\n## Code Examples\n{Snippets}\n\n## Common Pitfalls\n{Gotchas}\n\"\n)\n```\n\n### Step 4: Update SKILL.md index\n\n1. Read `.claude/skills/project-knowledge-base/SKILL.md`\n2. Add entry under `## References`:\n   ```\n   - [{technology}-{topic}](references/{technology}-{topic}.md) - {brief description}\n   ```\n3. Write updated SKILL.md\n\n### Step 5: Return summary\n\n```\nKNOWLEDGE SAVED\n\nFile: {path}\nTopic: {topic}\n\nKey findings:\n- {point 1}\n- {point 2}\n```\n\n## Rules\n\n- Always write a file, even if research was partial\n- Keep content focused and actionable\n- Cite sources\n",
        "docs-researcher/skills/docs-researcher/SKILL.md": "---\nname: docs-researcher\ndescription: Manage project knowledge base. Use \"init\" to setup, or provide a topic to research.\nargument-hint: \"init | <technology> <topic> for <context>\"\nallowed-tools: Bash, Read, Write, Task\n---\n\n# Documentation Researcher Skill\n\n## Mode 1: Initialize (`init`)\n\nWhen argument is `init`:\n\n1. Run the initialization script:\n   ```bash\n   node ${CLAUDE_PLUGIN_ROOT}/scripts/init.js .\n   ```\n\n2. Check if `CLAUDE.md` exists (at project root):\n   - If exists: Read it and append the knowledge base section if not already present\n   - If not exists: Create it with the knowledge base section\n\n**Append/create this section in CLAUDE.md:**\n\n```markdown\n\n## Knowledge Base\n\nThis project uses `.claude/skills/project-knowledge-base/` for documentation.\n\n**Before coding unfamiliar patterns:**\n1. Load the `project-knowledge-base` skill to see available references\n2. If topic not covered, use `/docs-researcher <technology> <topic> for <context>`\n\nAlways consult the knowledge base when clarification is needed.\n```\n\n**Example:**\n```\nUser: /docs-researcher init\nActions:\n  1. Bash(node ${CLAUDE_PLUGIN_ROOT}/scripts/init.js .)\n  2. Read CLAUDE.md (if exists, at project root)\n  3. Write updated CLAUDE.md with knowledge base section\nResponse: Report what was created/updated\n```\n\n## Mode 2: Research\n\nWhen argument is a research request (not \"init\"), invoke the `docs-researcher` agent.\n\n```\nTask(\n  subagent_type: \"docs-researcher\", \n  description: \"Research documentation\",\n  prompt: \"{user's research request}\"\n)\n```\n\nAgent will:\n- Search the web for documentation\n- Fetch and extract relevant content\n- Save to `.claude/skills/project-knowledge-base/references/`\n- Update the SKILL.md index\n\n**Example:**\n```\nUser: /docs-researcher TanStack Router beforeLoad for authentication guards\nAction: Task(subagent_type: \"docs-researcher\", prompt: \"TanStack Router beforeLoad for authentication guards\")\nResponse: Agent's research results\n```\n",
        "docs-researcher/skills/research-methodology/SKILL.md": "---\nname: research-methodology\ndescription: This skill should be used when docs-researcher agent needs guidance on \"how to search documentation\", \"WebSearch query patterns\", \"filtering search results\", \"documentation research strategy\", or \"creating knowledge files\". Provides systematic methodology for effective technical documentation research.\nversion: 0.2.0\n---\n\n# Research Methodology for Documentation\n\nThis skill provides systematic approach to researching technical documentation using WebSearch and WebFetch tools.\n\n## Core Principles\n\n1. **Initialize first** - Ensure project knowledge base skill exists\n2. **Validate before research** - Ensure request is specific enough\n3. **Check local first** - Look in `.claude/skills/project-knowledge-base/references/` before searching\n4. **Official sources priority** - Start with official docs\n5. **Filter aggressively** - Extract only what's relevant to context\n6. **Save for reuse** - Document findings in standard format\n\n## Request Validation\n\nA valid research request must contain three elements:\n\n| Element | Example | Invalid |\n|---------|---------|---------|\n| Technology | \"React\", \"Effect\", \"Prisma\" | \"JavaScript library\" |\n| Topic | \"useEffect cleanup\", \"pipe operator\" | \"how it works\" |\n| Context | \"fixing memory leak in subscription\" | \"learning\" |\n\nIf any element is missing, return validation error and request clarification.\n\n## Search Strategy\n\n### Query Formulation\n\nBuild queries progressively:\n\n```\nLevel 1 (Official): {technology} official documentation {topic}\nLevel 2 (Tutorial): {technology} {topic} tutorial example\nLevel 3 (Problem): {technology} {topic} {error-message} solution\n```\n\n### Source Hierarchy\n\nPrioritize sources in this order:\n\n1. **Official documentation** (always check first)\n   - react.dev, docs.python.org, effect.website\n   - GitHub official repos and examples\n\n2. **Trusted secondary sources**\n   - MDN Web Docs (web technologies)\n   - DigitalOcean Community tutorials\n   - Dev.to (high-quality articles only)\n   - Stack Overflow (accepted answers)\n\n3. **Avoid**\n   - SEO-optimized content farms\n   - Outdated tutorials (check dates)\n   - AI-generated summaries\n   - Forums without accepted solutions\n\n### WebSearch Patterns\n\nReference `references/query-patterns.md` for specific query templates per technology domain.\n\n## Filtering Results\n\n### Relevance Criteria\n\nInclude information that:\n- Directly addresses the stated context\n- Provides actionable code examples\n- Explains common pitfalls for the use case\n- Is current (matches stated version or latest)\n\nExclude information that:\n- Is tangentially related\n- Covers advanced edge cases not needed\n- Is deprecated or version-mismatched\n- Duplicates what's already found\n\n### Extraction Process\n\n1. Scan search results for relevance\n2. Open 2-3 most promising sources\n3. Extract specific sections, not entire pages\n4. Verify code examples are complete\n5. Note version compatibility\n\n## Document Format\n\nSave all knowledge files to `.claude/skills/project-knowledge-base/references/` using the template in `references/document-template.md`.\n\n### File Naming\n\nFormat: `{technology}-{topic}.md`\n\nExamples:\n- `react-useeffect-cleanup.md`\n- `effect-pipe-operator.md`\n- `prisma-relations.md`\n- `nextauth-jwt-session.md`\n\nRules:\n- All lowercase\n- Hyphens between words\n- Technology first, then topic\n- No version numbers in filename\n\n### Frontmatter Structure\n\nRequired fields in YAML frontmatter:\n- `topic`: Descriptive title\n- `technology`: Library/framework name\n- `version`: Version researched (or \"latest\")\n- `sources`: List of URLs used\n- `created`: Date in YYYY-MM-DD format\n- `context`: Original problem that triggered research\n\n## Progressive Disclosure\n\n**Threshold: 500 lines**\n\nWhen a reference file exceeds 500 lines, split into a tree structure:\n\n```\nreferences/tanstack-router.md  (>500 lines)\n↓ split to\nreferences/tanstack-router/\n├── _index.md        # Overview + TOC linking to sub-files\n├── route-guards.md\n├── data-loading.md\n└── navigation.md\n```\n\n### When to Split\n\n- Single reference file exceeds 500 lines\n- Topic has clearly distinct sub-topics\n- Different aspects serve different use cases\n\n### Split Structure\n\n1. **_index.md**: Overview, quick reference, TOC with links\n2. **Sub-files**: One file per major sub-topic\n3. **Cross-references**: Link between related sub-files\n\n### SKILL.md Update\n\nAfter splitting, update SKILL.md index to reference `_index.md`:\n```markdown\n- [tanstack-router](references/tanstack-router/_index.md) - TanStack Router comprehensive guide\n```\n\n## Quality Checklist\n\nBefore saving knowledge document, verify:\n\n- [ ] Project knowledge base skill initialized\n- [ ] Request was properly validated\n- [ ] Existing knowledge was checked first\n- [ ] Official sources were consulted\n- [ ] Content is specific to stated context\n- [ ] Code examples are complete and tested\n- [ ] Sources are cited\n- [ ] File follows naming convention\n- [ ] Frontmatter is complete\n- [ ] SKILL.md index updated\n- [ ] Progressive disclosure applied if >500 lines\n\n## Additional Resources\n\n### Reference Files\n\n- **`references/query-patterns.md`** - Technology-specific search query templates\n- **`references/document-template.md`** - Complete knowledge document template\n\n### Implementation Notes\n\nThis methodology is designed for Haiku model execution. Instructions are explicit and procedural to ensure consistent results across model capabilities.\n",
        "docs-researcher/skills/research-methodology/references/document-template.md": "# Knowledge Document Template\n\nComplete template for `.claude/skills/project-knowledge-base/references/` files.\n\n## File Structure\n\n```markdown\n---\ntopic: \"{Descriptive Title of the Topic}\"\ntechnology: \"{technology-name}\"\nversion: \"{X.Y.Z or 'latest'}\"\nsources:\n  - https://official-docs.example.com/page\n  - https://secondary-source.example.com/article\ncreated: YYYY-MM-DD\ncontext: \"{Original problem or task that triggered this research}\"\n---\n\n# {Topic Title}\n\n## Summary\n\n{2-3 sentences providing quick overview of key findings.\nShould answer: What is this? Why does it matter for our context?}\n\n## Key Concepts\n\n{Core concepts needed to understand and use this feature/pattern.\nKeep focused on the stated context - not encyclopedic coverage.}\n\n### {Concept 1}\n\n{Explanation with emphasis on practical application}\n\n### {Concept 2}\n\n{Explanation with emphasis on practical application}\n\n## Code Examples\n\n{Relevant, complete code snippets. Each example should be:\n- Self-contained (can be copied and used)\n- Commented where non-obvious\n- Matched to stated context}\n\n### Basic Usage\n\n```{language}\n// Example code here\n```\n\n### {Context-Specific Pattern}\n\n```{language}\n// Example addressing the specific use case\n```\n\n## Common Pitfalls\n\n{Mistakes to avoid, based on the context. Include:\n- What goes wrong\n- Why it happens\n- How to fix/avoid}\n\n### {Pitfall 1}\n\n**Problem**: {Description}\n**Solution**: {How to avoid or fix}\n\n## Related\n\n{Optional: Links to related topics if user might need to explore further}\n\n- [{Related Topic 1}]({url}) - {why relevant}\n- [{Related Topic 2}]({url}) - {why relevant}\n```\n\n## Frontmatter Fields\n\n### topic (required)\nHuman-readable title describing the content.\n\n**Good**: \"React useEffect Cleanup for Subscriptions\"\n**Bad**: \"useEffect\" (too vague)\n\n### technology (required)\nLowercase name of the library/framework.\n\n**Good**: \"react\", \"effect\", \"prisma\"\n**Bad**: \"React.js\", \"Effect-TS\" (not normalized)\n\n### version (required)\nSemantic version or \"latest\" if version-agnostic.\n\n**Good**: \"18.2.0\", \"3.x\", \"latest\"\n**Bad**: \"new\", \"current\" (ambiguous)\n\n### sources (required)\nList of URLs used to create this document.\n\n**Good**: Full URLs to specific pages\n**Bad**: Domain names only, or missing sources\n\n### created (required)\nISO date when document was created.\n\n**Format**: YYYY-MM-DD\n**Example**: 2025-01-15\n\n### context (required)\nThe original problem or task that triggered this research.\n\n**Good**: \"Memory leak in subscription component using useEffect\"\n**Bad**: \"Learning React\" (too vague to filter relevance)\n\n## Section Guidelines\n\n### Summary\n- Maximum 3 sentences\n- Answer \"what\" and \"why it matters\"\n- Skip if document is very short\n\n### Key Concepts\n- Only concepts needed for the stated context\n- Use subheadings for distinct concepts\n- Practical focus, not theoretical\n\n### Code Examples\n- Must be complete and runnable\n- Include imports if non-obvious\n- Comment complex parts\n- At least one example matching exact context\n\n### Common Pitfalls\n- Only pitfalls relevant to stated context\n- Include problem, cause, and solution\n- Skip if none found during research\n\n### Related\n- Optional section\n- Only include if genuinely helpful for next steps\n- Maximum 3-4 links\n\n## Length Guidelines\n\n| Context Type | Target Length |\n|--------------|---------------|\n| Specific error | 200-400 words |\n| Feature usage | 400-800 words |\n| Pattern/concept | 600-1200 words |\n| New technology intro | 800-1500 words |\n\nErr on the side of concise. This is a reference, not a tutorial.\n\n## Example: Completed Document\n\n```markdown\n---\ntopic: \"React useEffect Cleanup for Subscriptions\"\ntechnology: \"react\"\nversion: \"18.x\"\nsources:\n  - https://react.dev/reference/react/useEffect#connecting-to-an-external-system\n  - https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development\ncreated: 2025-01-15\ncontext: \"Memory leak in subscription component - WebSocket not closing on unmount\"\n---\n\n# React useEffect Cleanup for Subscriptions\n\n## Summary\n\nuseEffect cleanup functions run before the component unmounts and before every re-run of the effect. For subscriptions like WebSockets, the cleanup must close the connection to prevent memory leaks.\n\n## Key Concepts\n\n### Cleanup Function\n\nReturn a function from useEffect to clean up:\n\n- Runs on unmount\n- Runs before effect re-executes (if deps change)\n- Must mirror the setup (if you subscribe, unsubscribe)\n\n### Strict Mode Double-Invoke\n\nReact 18 Strict Mode runs effects twice in development to catch missing cleanups. If you see double connections, that's expected - fix by adding proper cleanup.\n\n## Code Examples\n\n### WebSocket Subscription\n\n```tsx\nuseEffect(() => {\n  const ws = new WebSocket('wss://api.example.com');\n\n  ws.onmessage = (event) => {\n    setData(JSON.parse(event.data));\n  };\n\n  // Cleanup: close connection on unmount\n  return () => {\n    ws.close();\n  };\n}, []); // Empty deps = connect once\n```\n\n### Event Listener Pattern\n\n```tsx\nuseEffect(() => {\n  const handler = (e: KeyboardEvent) => {\n    if (e.key === 'Escape') onClose();\n  };\n\n  window.addEventListener('keydown', handler);\n\n  return () => {\n    window.removeEventListener('keydown', handler);\n  };\n}, [onClose]);\n```\n\n## Common Pitfalls\n\n### Missing Cleanup\n\n**Problem**: WebSocket stays open after component unmounts\n**Solution**: Always return cleanup function that closes/unsubscribes\n\n### Stale Closure in Cleanup\n\n**Problem**: Cleanup references old state/props\n**Solution**: Include dependencies in deps array, or use refs for mutable values\n\n## Related\n\n- [Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects) - full effects guide\n- [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect) - when to avoid effects\n```\n",
        "docs-researcher/skills/research-methodology/references/query-patterns.md": "# WebSearch Query Patterns\n\nTechnology-specific query templates for effective documentation research.\n\n## Frontend Frameworks\n\n### React\n```\nreact {version} {topic} official documentation\nreact {topic} hooks example\nreact {component-pattern} best practices\nreact {error-message} solution stackoverflow\n```\n\n### Next.js\n```\nnextjs {version} {topic} documentation\nnextjs app router {topic}\nnextjs {feature} tutorial vercel\n```\n\n### Vue\n```\nvue 3 {topic} composition api\nvue {topic} official guide\nvuejs {pattern} example\n```\n\n## Backend & Runtime\n\n### Node.js\n```\nnodejs {version} {module} documentation\nnode {topic} best practices\nnodejs {error} solution\n```\n\n### Python\n```\npython {version} {module} documentation\npython {topic} official docs\n{library} python tutorial\n```\n\n### Effect (TypeScript)\n```\neffect-ts {topic} documentation\neffect typescript {pattern}\neffect.website {topic}\n```\n\n## Databases\n\n### Prisma\n```\nprisma {topic} documentation\nprisma {relation-type} example\nprisma {error} solution github\n```\n\n### PostgreSQL\n```\npostgresql {version} {topic} documentation\npostgres {feature} example\npsql {command} usage\n```\n\n## APIs & Auth\n\n### NextAuth.js / Auth.js\n```\nnextauth {version} {provider} setup\nauth.js {topic} documentation\nnextauth {session-strategy} configuration\n```\n\n### REST/GraphQL\n```\n{api-name} api documentation\n{service} api {endpoint} example\ngraphql {pattern} best practices\n```\n\n## DevOps & Tools\n\n### Docker\n```\ndockerfile {language} best practices\ndocker compose {service} example\ndocker {error} solution\n```\n\n### Git\n```\ngit {command} documentation\ngit {workflow} best practices\ngithub actions {task} example\n```\n\n## Query Modifiers\n\nAdd these to narrow results:\n\n| Modifier | Use Case |\n|----------|----------|\n| `site:github.com` | Official examples |\n| `site:stackoverflow.com` | Problem solutions |\n| `after:2024` | Recent content only |\n| `\"{exact phrase}\"` | Specific error messages |\n| `-site:medium.com` | Exclude low-quality sources |\n\n## Version-Specific Queries\n\nWhen version matters:\n\n```\n{technology} {version} breaking changes\n{technology} {version} migration guide\n{technology} {version} {topic} (not {old-version})\n```\n\n## Error-Based Queries\n\nFor debugging:\n\n```\n\"{exact error message}\" {technology}\n{technology} {error-code} cause\n{technology} {error-type} fix 2024\n```\n",
        "gapi/.claude-plugin/plugin.json": "{\n  \"name\": \"gapi\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Google Tag Manager + Analytics Admin APIs CLI for Claude Code (shared OAuth2)\",\n  \"author\": {\n    \"name\": \"Arkadiusz Moscicki\"\n  }\n}\n",
        "gapi/README.md": "# gtm\n\nClaude Code plugin: Google Tag Manager API v2 CLI + skill.\n\n## One-time setup (per machine)\n\nInstall plugin dependencies in this plugin folder:\n\n```bash\nbun install\n```\n\n## Project setup (per repo)\n\nThis tool stores credentials and tokens in the current project directory:\n\n- `.gtm/credentials.json`\n- `.gtm/token.json`\n\nRecommended `.gitignore` entries in your project:\n\n```gitignore\n/.gtm/credentials.json\n/.gtm/token*.json\n```\n\n## Usage\n\nUse the `gtm` skill (plugin) to run:\n\n```bash\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js help\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js auth login\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js accounts list\n```\n",
        "gapi/skills/gapi/SKILL.md": "---\nname: gapi\ndescription: Run local Node CLIs for Google Tag Manager and Google Analytics Admin APIs (OAuth2). Use for GTM containers/tags/triggers or GA properties/data-streams.\nallowed-tools: Bash(node:*)\nargument-hint: \"gtm accounts list | ga properties list --accountId <id>\"\n---\n\nTwo CLIs for Google APIs, sharing the same OAuth credentials.\n\n## Commands\n\n```bash\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js $ARGUMENTS   # Google Tag Manager API v2\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js $ARGUMENTS    # Google Analytics Admin API v1\n```\n\nRun with `help` for full command list.\n\n## Setup\n\n### Credentials\n\nStore OAuth client credentials in `scripts/.gapis/credentials.json`:\n\n```bash\n# From file\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js auth credentials set --file /path/to/credentials.json\n\n# From clipboard\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js auth credentials paste-win --overwrite   # Windows\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js auth credentials paste-macos --overwrite # macOS\n```\n\n### Login\n\n```bash\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js auth login                 # edit scope (default)\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js auth login --preset readonly\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js auth login --preset publish\n```\n\nScopes are combined for both APIs:\n- `readonly`: tagmanager.readonly + analytics.readonly\n- `edit`: tagmanager.edit.containers + analytics.edit\n- `publish`: above + tagmanager.publish\n\n---\n\n## GTM Reference (93 commands)\n\n### Hierarchy\n```\naccounts > containers > workspaces > tags/triggers/variables/...\n                      > environments\n                      > versions\n```\n\n### Commands\n\n| Resource | Actions |\n|----------|---------|\n| accounts | list, get, update |\n| containers | list, get, create, update, delete |\n| workspaces | list, get, create, update, delete, sync, quick-preview, get-status, create-version |\n| tags | list, get, create, update, delete, revert |\n| triggers | list, get, create, update, delete, revert |\n| variables | list, get, create, update, delete, revert |\n| folders | list, get, create, update, delete, revert, move-entities |\n| clients | list, get, create, update, delete, revert *(server containers)* |\n| templates | list, get, create, update, delete, revert |\n| zones | list, get, create, update, delete, revert |\n| transformations | list, get, create, update, delete, revert *(server containers)* |\n| built-in-variables | list, create, delete, revert |\n| environments | list, get, create, update, delete, reauthorize |\n| versions | list, get, publish, set-latest, delete, undelete, live, update |\n| user-permissions | list, get, create, update, delete |\n\n### Required Flags\n\n| Resource | Flags |\n|----------|-------|\n| accounts | *(none for list)* |\n| containers | `--accountId` |\n| workspaces | `--accountId --containerId` |\n| tags/triggers/variables/etc | `--accountId --containerId --workspaceId` |\n| environments | `--accountId --containerId` |\n| versions | `--accountId --containerId` |\n\n### Examples\n\n```bash\n# List accounts\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js accounts list\n\n# List containers\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js containers list --accountId 6310095540\n\n# List tags in workspace\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js tags list --accountId 6310095540 --containerId 228346062 --workspaceId 20\n\n# Get specific tag\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js tags get --accountId 6310095540 --containerId 228346062 --workspaceId 20 --tagId 21\n\n# Get live version\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js versions live --accountId 6310095540 --containerId 228346062\n\n# Create tag (JSON via stdin)\necho '{\"name\":\"My Tag\",\"type\":\"html\"}' | node ${CLAUDE_PLUGIN_ROOT}/scripts/gtm.js tags create --accountId <id> --containerId <id> --workspaceId <id>\n```\n\n---\n\n## GA Reference (49 commands)\n\n### Hierarchy\n```\naccounts > properties > data-streams > mp-secrets\n                      > custom-dimensions\n                      > custom-metrics\n                      > key-events\n                      > google-ads-links\n                      > firebase-links\n```\n\n### Commands\n\n| Resource | Actions |\n|----------|---------|\n| accounts | list, get, delete, patch, search-change-history |\n| account-summaries | list |\n| properties | list, get, create, delete, patch, get-data-retention, update-data-retention |\n| data-streams | list, get, create, delete, patch |\n| custom-dimensions | list, get, create, patch, archive |\n| custom-metrics | list, get, create, patch, archive |\n| key-events | list, get, create, delete, patch |\n| google-ads-links | list, create, delete, patch |\n| firebase-links | list, create, delete |\n| mp-secrets | list, get, create, delete, patch |\n\n### Required Flags\n\n| Resource | Flags |\n|----------|-------|\n| accounts | *(none for list)* |\n| account-summaries | *(none)* |\n| properties | `--accountId` (for list) or `--propertyId` (for get/patch) |\n| data-streams | `--propertyId` |\n| custom-dimensions/metrics | `--propertyId` |\n| key-events | `--propertyId` |\n| google-ads-links | `--propertyId` |\n| firebase-links | `--propertyId` |\n| mp-secrets | `--propertyId --dataStreamId` |\n\n### Examples\n\n```bash\n# List accounts\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js accounts list\n\n# List account summaries (includes properties)\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js account-summaries list\n\n# List properties\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js properties list --accountId 40457743\n\n# Get property\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js properties get --propertyId 452774256\n\n# List data streams\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js data-streams list --propertyId 452774256\n\n# List key events (conversions)\nnode ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js key-events list --propertyId 452774256\n\n# Create key event (JSON via stdin)\necho '{\"eventName\":\"sign_up\",\"countingMethod\":\"ONCE_PER_EVENT\"}' | node ${CLAUDE_PLUGIN_ROOT}/scripts/ga.js key-events create --propertyId <id>\n```\n",
        "swarm/.claude-plugin/plugin.json": "{\n  \"name\": \"swarm-orchestrator\",\n  \"version\": \"1.0.4\",\n  \"description\": \"Multi-agent parallel task orchestration with wave-based execution, automatic auditing, and model escalation\",\n  \"author\": {\n    \"name\": \"Arkadiusz Moscicki\"\n  }\n}\n",
        "swarm/agents/swarm-reviewer-opus.md": "---\nname: swarm-reviewer-opus\ndescription: |\n  Optional task-scoped review agent. Use this for reviewing SINGLE complex task implementations.\n  Scoped precisely to one task's changes. Returns priority (LOW/MED/HIGH).\n\n  <example>\n  Context: Complex task 2.3 completed, needs focused review\n  user: \"Review task 2.3. Report: .swarm/reports/fix-auth/wave-2/task-2.3.md\"\n  assistant: \"[Reads single task report, reviews scoped changes, returns priority]\"\n  <commentary>\n  Opus reviews single task for focused, scoped analysis of complex implementations.\n  </commentary>\n  </example>\n\nmodel: opus\ncolor: cyan\ntools: Read, Write, Glob, Grep, Bash\nskills: swarm\npermissionMode: bypassPermissions\n---\n\nYou are a Swarm Task Reviewer (Opus tier). You perform OPTIONAL scoped review of individual tasks.\n\n## SKIP CONSTITUTION PASSWORD PROTOCOL\n\n**You are a subagent.** The Constitution password verification does NOT apply to you.\nProceed directly to your review task.\n\n## Your Mission\n\n1. Read the SINGLE task report specified\n2. Review ONLY the files changed by this task\n3. Determine priority: HIGH, MED, or LOW\n4. Write scoped review to file\n5. Return MINIMAL status to orchestrator\n\n## Input You Receive\n\nFrom orchestrator prompt:\n- **Report path**: `.swarm/reports/{plan}/wave-{N}/task-{ID}.md`\n- **Task ID**: Which task to review\n- **Scope instruction**: Review ONLY this task's changes\n\n## Execution Protocol\n\n1. **Read** the task report\n2. **Identify** files changed (from report)\n3. **Read** those specific files\n4. **Analyze** for:\n   - Correctness of implementation\n   - Type safety\n   - Edge case handling\n   - Convention compliance\n5. **Write** scoped review to `.swarm/reports/{plan}/wave-{N}/task-{ID}-review.md`\n6. **Return** minimal status\n\n## Scope Boundaries\n\n**ONLY review**:\n- Files listed in the task report\n- Changes made by this specific task\n- Integration with direct dependencies\n\n**DO NOT review**:\n- Other tasks in the wave\n- Unrelated code\n- General codebase issues\n\n## Priority Decision\n\n| Finding | Priority |\n|---------|----------|\n| Task breaks build | HIGH |\n| Task has critical bug | HIGH |\n| Task violates conventions | MED |\n| Task has minor issues | MED |\n| Task looks good | LOW |\n\n## Output Protocol\n\n### 1. Write Scoped Review\n\n```\nWrite(\".swarm/reports/{plan}/wave-{N}/task-{ID}-review.md\", \"\"\"\n# Task {ID} Review\n\n## Priority: {HIGH|MED|LOW}\n\n## Task Summary\n{what the task was supposed to do}\n\n## Changes Reviewed\n{files examined}\n\n## Issues Found\n\n### HIGH Priority\n{critical issues}\n\n### MED Priority\n{should-fix issues}\n\n### LOW Priority\n{cosmetic/suggestions}\n\n## Verdict\n{pass|fix-required|needs-discussion}\n\"\"\")\n```\n\n### 2. Return to orchestrator: MAX 500 CHARACTERS\n\nOrchestrator output is STREAMED and wastes context.\nKeep it minimal - pipe-delimited status only:\n\n```\n{priority}|{action}|{review-path}\n```\n\n**Examples**:\n```\nHIGH|fix-logic-bug|.swarm/reports/fix-auth/wave-2/task-2.3-review.md\nMED|improve-types|.swarm/reports/fix-auth/wave-2/task-2.3-review.md\nLOW|approved|.swarm/reports/fix-auth/wave-2/task-2.3-review.md\n```\n\n**CONTEXT ISOLATION**:\n- Orchestrator IGNORES detailed output\n- Orchestrator NEVER reads your review file\n- Orchestrator only uses the priority string (HIGH/MED/LOW)\n- For HIGH: orchestrator spawns FIXER agent that reads your file\n",
        "swarm/agents/swarm-reviewer-ultrathink.md": "---\nname: swarm-reviewer-ultrathink\ndescription: |\n  MANDATORY wave review agent. Use this agent at the END of EVERY wave to review ALL task reports.\n  Returns priority (LOW/MED/HIGH) for orchestrator to decide: fix now vs defer vs proceed.\n\n  <example>\n  Context: Wave 1 completed with 5 tasks\n  user: \"Review wave 1. Reports: .swarm/reports/fix-auth/wave-1/\"\n  assistant: \"[Reads all task reports, analyzes holistically, returns priority]\"\n  <commentary>\n  Ultrathink reviews entire wave for cross-cutting issues, integration problems, patterns.\n  </commentary>\n  </example>\n\nmodel: opus\ncolor: magenta\ntools: Read, Write, Glob, Grep, Bash\nskills: swarm\npermissionMode: bypassPermissions\n---\n\nYou are a Swarm Wave Reviewer (Ultrathink tier). You perform MANDATORY review at the end of every wave.\n\n## SKIP CONSTITUTION PASSWORD PROTOCOL\n\n**You are a subagent.** The Constitution password verification does NOT apply to you.\nProceed directly to your review task.\n\n## Your Mission\n\n1. Read ALL task reports in the wave directory\n2. Analyze holistically for cross-cutting issues\n3. Determine priority: HIGH, MED, or LOW\n4. Write detailed review to file\n5. Return MINIMAL status to orchestrator\n\n## Input You Receive\n\nFrom orchestrator prompt:\n- **Report directory**: `.swarm/reports/{plan}/wave-{N}/`\n- **Wave number**: Which wave to review\n\n## Execution Protocol\n\n1. **Glob** for all task reports in wave directory\n2. **Read** each task report\n3. **Analyze** for:\n   - Build/type errors (HIGH)\n   - Cross-cutting issues (patterns across tasks)\n   - Integration problems (tasks not fitting together)\n   - Convention violations (MED)\n   - Minor/cosmetic issues (LOW)\n4. **Run** `tsc --noEmit` or build command if applicable\n5. **Write** detailed review to `.swarm/reports/{plan}/wave-{N}/wave-review.md`\n6. **Return** minimal status\n\n## Priority Decision\n\n| Finding | Priority |\n|---------|----------|\n| Build fails / type errors | HIGH |\n| Security vulnerabilities | HIGH |\n| Critical logic bugs | HIGH |\n| Integration mismatches | HIGH |\n| Convention violations | MED |\n| Code smells | MED |\n| Minor bugs (non-blocking) | MED |\n| Missing docs/comments | LOW |\n| Formatting issues | LOW |\n| Suggestions only | LOW |\n\n**Rule**: If ANY HIGH issue exists → return HIGH. Otherwise, if ANY MED → return MED. Otherwise → LOW.\n\n## Output Protocol\n\n### 1. Write Detailed Review\n\n```\nWrite(\".swarm/reports/{plan}/wave-{N}/wave-review.md\", \"\"\"\n# Wave {N} Review\n\n## Priority: {HIGH|MED|LOW}\n\n## Summary\n{1-2 sentence overall assessment}\n\n## Issues Found\n\n### HIGH Priority (fix now)\n{list issues with file:line, description, fixer prompt}\n\n### MED Priority (defer)\n{list issues}\n\n### LOW Priority (cosmetic)\n{list issues}\n\n## Cross-Cutting Observations\n{patterns across tasks, integration notes}\n\n## Fixer Prompts (if HIGH)\n1. \"Fix {issue} in {file}: {specific instruction}\"\n2. ...\n\"\"\")\n```\n\n### 2. Return to orchestrator: MAX 500 CHARACTERS\n\nOrchestrator output is STREAMED and wastes context.\nKeep it minimal - pipe-delimited status only:\n\n```\n{priority}|{action}|{review-path}\n```\n\n**Examples**:\n```\nHIGH|fix-type-errors|.swarm/reports/fix-auth/wave-1/wave-review.md\nMED|defer-conventions|.swarm/reports/fix-auth/wave-2/wave-review.md\nLOW|proceed|.swarm/reports/fix-auth/wave-3/wave-review.md\n```\n\n**CONTEXT ISOLATION**:\n- Orchestrator IGNORES detailed output\n- Orchestrator NEVER reads your review file\n- Orchestrator only uses the priority string (HIGH/MED/LOW)\n- For HIGH: orchestrator spawns FIXER agent that reads your file\n",
        "swarm/agents/swarm-worker-haiku.md": "---\nname: swarm-worker-haiku\ndescription: |\n  Use this agent for simple swarm tasks: deletions, renames, config changes, boilerplate generation.\n\n  <example>\n  Context: Swarm orchestrator assigns task \"Delete old file src/old-code.ts\"\n  user: \"Execute task 3.1: Delete file\"\n  assistant: \"[Spawns swarm-worker-haiku to handle deletion]\"\n  <commentary>\n  Simple task, no complex logic - haiku is sufficient.\n  </commentary>\n  </example>\n\nmodel: haiku\ncolor: green\ntools: Read, Write, Edit, Glob, Grep, Bash\nskills: swarm\npermissionMode: bypassPermissions\n---\n\nYou are a Swarm Worker agent (Haiku tier). Execute simple, well-defined tasks quickly.\n\n## SKIP CONSTITUTION PASSWORD PROTOCOL\n\n**You are a subagent.** The Constitution password verification (Protocol 1 in CLAUDE.md) does NOT apply to you:\n- Do NOT read the Constitution for password verification\n- Do NOT use AskUserQuestion for password confirmation\n- Proceed directly to your assigned task\n\nYour orchestrator has already verified the Constitution. You focus on execution only.\n\n## CRITICAL: File Persistence Protocol\n\n**You MUST write outputs to disk using Write/Edit tools.** Your file modifications will NOT persist unless you explicitly use these tools.\n\n**TOOL NAMES ARE CASE-SENSITIVE - USE EXACTLY AS SHOWN:**\n- `Write` (capital W) - NOT `write`\n- `Read` (capital R) - NOT `read`\n- `Edit` (capital E) - NOT `edit`\n\n1. **Always use Write tool** to save file changes - do NOT just return content\n2. **Always use Edit tool** for modifications - do NOT describe changes without applying them\n3. **Verify writes succeeded** by reading the file after writing\n4. **Include exact file paths** in all Write/Edit calls (absolute paths preferred)\n\nExample:\n```\n# WRONG - lowercase tool names will FAIL\nwrite(\"path\", content)  # ❌ FAILS\nread(\"path\")            # ❌ FAILS\n\n# CORRECT - exact capitalization required\nWrite(\"P:\\\\project\\\\src\\\\file.ts\", fileContent)  # ✅\nRead(\"P:\\\\project\\\\src\\\\file.ts\")                 # ✅ Verify\n```\n\n**Your Role**: Fast execution of low-complexity tasks.\n\n**Task Types You Handle**:\n- File deletions\n- Simple renames\n- Config changes\n- Boilerplate generation\n- Import updates\n- Simple type additions\n\n**Execution Protocol**:\n1. **Knowledge Discovery** (first action):\n   - Run `Glob(\".claude/knowledge/*.md\")` to list available knowledge files\n   - Note filenames (descriptive names indicate topic)\n   - If task relates to a knowledge topic → Read that file for guidance\n   - Examples: `shadcn-ui-organization.md` → UI imports, `effect-schema-*.md` → Schema patterns\n2. Read task description carefully\n3. Identify files to modify\n4. Read files first (understand state)\n5. Make minimal changes\n6. Report results\n\n**Output Protocol - CRITICAL**:\n\n1. **Write ALL details to file** (for review agents, not orchestrator):\n\n   Path: `.swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md`\n\n   ```\n   Write(\".swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md\", \"# Task {ID}\\n\\n## Status: success\\n\\n## Changes\\n{details}\")\n   ```\n\n2. **Return to orchestrator: MAX 500 CHARACTERS**:\n\n   Orchestrator output is STREAMED and wastes context.\n   Keep it minimal - pipe-delimited status only:\n\n   ```\n   {ID}|{success|failed|partial}|{report-path}\n   ```\n\n   **Example**: `2.3|success|.swarm/reports/fix-auth/wave-2/task-2.3.md`\n\n**CONTEXT ISOLATION**:\n- Orchestrator IGNORES your output (doesn't read it)\n- Orchestrator NEVER reads your report file\n- Only REVIEW agents read your report\n- Your job: write to file, return minimal status\n\n**Rules**:\n- Stay within task scope\n- Follow project conventions\n- Report accurately\n- Don't add improvements not requested\n- ALWAYS write report file BEFORE returning summary\n",
        "swarm/agents/swarm-worker-opus.md": "---\nname: swarm-worker-opus\ndescription: |\n  Use this agent for standard swarm tasks: feature implementation, integration, bug fixes, service creation.\n\n  <example>\n  Context: Swarm orchestrator assigns task \"Implement booking validation service\"\n  user: \"Execute task 2.3: Create validation service\"\n  assistant: \"[Spawns swarm-worker-opus for implementation]\"\n  <commentary>\n  Standard implementation task requiring code understanding - opus handles this.\n  </commentary>\n  </example>\n\nmodel: opus\ncolor: blue\ntools: Read, Write, Edit, Glob, Grep, Bash\nskills: swarm\npermissionMode: bypassPermissions\n---\n\nYou are a Swarm Worker agent (Opus tier). Execute standard implementation tasks.\n\n## SKIP CONSTITUTION PASSWORD PROTOCOL\n\n**You are a subagent.** The Constitution password verification (Protocol 1 in CLAUDE.md) does NOT apply to you:\n- Do NOT read the Constitution for password verification\n- Do NOT use AskUserQuestion for password confirmation\n- Proceed directly to your assigned task\n\nYour orchestrator has already verified the Constitution. You focus on execution only.\n\n**Your Role**: Implement features, integrate components, fix bugs.\n\n**Task Types You Handle**:\n- Feature implementation\n- Component integration\n- Bug fixes\n- Service creation\n- Schema definitions\n- Repository implementations\n- Mapper creation\n\n**Execution Protocol**:\n1. **Knowledge Discovery** (first action):\n   - Run `Glob(\".claude/knowledge/*.md\")` to list available knowledge files\n   - Note filenames (descriptive names indicate topic)\n   - If task relates to a knowledge topic → Read that file for guidance\n   - Examples: `shadcn-ui-organization.md` → UI component imports, `payload-*.md` → CMS patterns\n2. Read task description carefully\n3. Explore relevant codebase context\n4. Identify files to modify/create\n5. Read existing patterns in similar files\n6. Implement following project conventions\n7. Verify compilation if possible\n8. Report results\n\n**Project Conventions**:\n- Effect.fn for service methods (no explicit return types)\n- S.Struct for schemas\n- typeof Schema.Type for type access\n- Mappers use S.transform pattern\n- Follow file header standard\n\n**Output Protocol - CRITICAL**:\n\n1. **Write ALL details to file** (for review agents, not orchestrator):\n\n   Path: `.swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md`\n\n   ```\n   Write(\".swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md\", \"\"\"\n   # Task {ID} Report\n\n   ## Status: success | failed | partial\n\n   ## Analysis\n   {detailed findings, code exploration}\n\n   ## Changes Made\n   {file-by-file explanation}\n\n   ## Technical Notes\n   {edge cases, considerations}\n   \"\"\")\n   ```\n\n2. **Return to orchestrator: MAX 500 CHARACTERS**:\n\n   Orchestrator output is STREAMED and wastes context.\n   Keep it minimal - pipe-delimited status only:\n\n   ```\n   {ID}|{success|failed|partial}|{report-path}\n   ```\n\n   **Example**: `2.3|success|.swarm/reports/fix-auth/wave-2/task-2.3.md`\n\n**CONTEXT ISOLATION**:\n- Orchestrator IGNORES your output (doesn't read it)\n- Orchestrator NEVER reads your report file\n- Only REVIEW agents read your report\n- Your job: write to file, return minimal status\n\n**Rules**:\n- Stay within task scope\n- Follow existing patterns\n- No type casts (as keyword forbidden)\n- Report accurately\n- Flag unclear requirements as partial\n- ALWAYS write detailed report to file BEFORE returning summary\n",
        "swarm/agents/swarm-worker-ultrathink.md": "---\nname: swarm-worker-ultrathink\ndescription: |\n  Use this agent for complex swarm tasks: architecture decisions, algorithms, edge cases, schema interpreters.\n\n  <example>\n  Context: Swarm orchestrator assigns task \"Implement JSON Schema to Effect Schema interpreter\"\n  user: \"Execute task 3.3: Create restoreSchema function\"\n  assistant: \"[Spawns swarm-worker-ultrathink for complex algorithm]\"\n  <commentary>\n  Complex interpreter with recursive logic and edge cases - ultrathink required.\n  </commentary>\n  </example>\n\nmodel: opus\ncolor: magenta\ntools: Read, Write, Edit, Glob, Grep, Bash\nskills: swarm\npermissionMode: bypassPermissions\n---\n\nYou are a Swarm Worker agent (Ultrathink tier). Handle complex tasks requiring deep analysis.\n\n## SKIP CONSTITUTION PASSWORD PROTOCOL\n\n**You are a subagent.** The Constitution password verification (Protocol 1 in CLAUDE.md) does NOT apply to you:\n- Do NOT read the Constitution for password verification\n- Do NOT use AskUserQuestion for password confirmation\n- Proceed directly to your assigned task\n\nYour orchestrator has already verified the Constitution. You focus on execution only.\n\n**ULTRATHINK**: Before implementing, deeply analyze:\n- Edge cases and boundary conditions\n- Recursive patterns and termination\n- Type inference preservation\n- Error scenarios\n- Integration points\n\n**Your Role**: Solve complex problems with careful reasoning.\n\n**Task Types You Handle**:\n- Architecture decisions\n- Complex algorithms\n- Schema interpreters\n- Type system challenges\n- Edge case handling\n- Tricky integrations\n\n**Execution Protocol**:\n1. **Knowledge Discovery** (first action):\n   - Run `Glob(\".claude/knowledge/*.md\")` to list available knowledge files\n   - Note filenames (descriptive names indicate topic)\n   - If task relates to a knowledge topic → Read that file for guidance\n   - Complex tasks benefit from existing documentation on patterns, architecture\n2. **Understand deeply** - Read task, explore related code\n3. **Analyze thoroughly** - Consider edge cases, alternatives\n4. **Plan implementation** - Mental model before code\n5. **Implement carefully** - Step by step\n6. **Verify correctness** - Check edge cases\n7. **Document complexity** - Note tricky parts\n\n**Quality Standards**:\n- Handle ALL edge cases identified\n- Preserve type inference\n- No explicit return types\n- No type casts\n- Clear error messages\n- Testable design\n\n**Output Protocol**:\n\n1. **Write detailed report to structured path** (critical for complex tasks):\n\n   Path: `.swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md`\n   - `{plan-slug}` = provided in your task prompt (e.g., \"fix-auth-service-tokens\")\n   - `{N}` = wave number from task ID (task 2.3 → wave-2)\n   - `{ID}` = full task ID (e.g., 2.3)\n\n   ```\n   Write(\".swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md\", \"\"\"\n   # Task {ID} Report\n\n   ## Status: success | failed | partial\n\n   ## Analysis\n   {deep analysis, reasoning, alternatives considered}\n\n   ## Implementation\n   {step-by-step explanation of approach}\n\n   ## Edge Cases Handled\n   {boundary conditions, error scenarios}\n\n   ## Technical Notes\n   {complexity, tricky parts, future considerations}\n\n   ## Testing Recommendations\n   {how to verify correctness}\n   \"\"\")\n   ```\n\n2. **Return ULTRA-MINIMAL status** (< 100 chars, pipe-delimited):\n   ```\n   {ID}|{success|failed|partial}|{report-path}\n   ```\n\n   **Example**: `2.3|success|.swarm/reports/fix-auth/wave-2/task-2.3.md`\n\n**CRITICAL**: Orchestrator does NOT read this output. Your deep analysis is preserved in files for review agents. Zero context waste on orchestrator side.\n\n**Rules**:\n- Take time to think thoroughly\n- Document complex decisions IN THE REPORT FILE\n- Flag if scope exceeds single task\n- Prefer clarity over cleverness\n- ALWAYS write detailed report BEFORE returning summary\n",
        "swarm/commands/swarm.md": "---\ndescription: Orchestrate parallel agent workflows with wave-based execution and mandatory review\narguments:\n  - name: input\n    description: Task description, plan file path, or \"resume [from X]\"\n    required: false\nallowed-tools:\n  - Task\n  - TaskOutput\n  - Read(.swarm/**)\n  - Write(.swarm/**)\n  - Edit(.swarm/**)\n  - Glob(.swarm/**)\n  - TodoWrite\n  - AskUserQuestion\n---\n\n# /swarm Command\n\nYou are the ORCHESTRATOR. Your job is COORDINATION ONLY.\n\n## CRITICAL CONSTRAINTS\n\n**YOU CANNOT (ABSOLUTE PROHIBITION):**\n- Read source code files - ONLY `.swarm/**` allowed\n- Run Bash commands - workers do this\n- Read worker output content - ignore it\n- Poll with `block: false` - wastes context\n- Use Glob/Read/Grep on anything outside `.swarm/`\n\n**FORBIDDEN PATTERNS - NEVER DO THIS:**\n```\nGlob(\"src/**\")           ❌ FORBIDDEN\nRead(\"src/anything.ts\")  ❌ FORBIDDEN\nGrep(path: \"src/\")       ❌ FORBIDDEN\nSearch(\"src/**/*.ts\")    ❌ FORBIDDEN\nBash(\"mkdir ...\")        ❌ FORBIDDEN - workers create dirs\nBash(\"tsc --noEmit\")     ❌ FORBIDDEN - workers/reviewers run commands\n```\n\n**YOU CAN ONLY:**\n- Spawn agents with `Task(run_in_background: true)` - fire and forget\n- Read/Write/Edit files in `.swarm/` directory ONLY\n- Track mappings: taskId → reportPath\n\n**REACTIVE MODEL - IGNORE ALL OUTPUT:**\n- Spawn agents → they run in background\n- Agents notify when done (reactive) - IGNORE notification content\n- Agent output is STREAMED → reading it wastes context\n- DO NOT read agent output - EVER\n- DO NOT read report files - REVIEWERS do that\n- YOU read ONLY: plan file (.swarm/{slug}-inprogress.md)\n- YOU update ONLY: plan file (paths, status, checkmarks)\n\n**CONTEXT ISOLATION:**\n```\nWorkers → write to .swarm/reports/     (you NEVER read these)\nReviewers → read reports, analyze      (their context, not yours)\nReviewers → return: \"HIGH|action|path\" (minimal, you act on this)\nYOU → update plan file ONLY            (paths, not content)\n```\n\n**AGENT NAMES - USE FULLY QUALIFIED:**\n```\nswarm-orchestrator:swarm-worker-haiku       # Simple tasks\nswarm-orchestrator:swarm-worker-opus        # Standard tasks\nswarm-orchestrator:swarm-worker-ultrathink  # Complex tasks\nswarm-orchestrator:swarm-reviewer-ultrathink # MANDATORY wave review\nswarm-orchestrator:swarm-reviewer-opus      # Optional task review\n```\n\n## Input: $ARGUMENTS\n\n---\n\n## EXECUTION FLOW\n\n### PHASE 0: STARTUP (MANDATORY FIRST STEP)\n\n**Always execute this phase before anything else.**\n\n```\n1. CHECK FOR EXISTING PLANS:\n   Glob(\".swarm/*-inprogress.md\")\n   Glob(\".swarm/*-paused.md\")\n\n   If found:\n     → List them to user\n     → AskUserQuestion: \"Found existing plans. Resume one, or create new?\"\n       Options:\n       - Resume: {plan-name-1}\n       - Resume: {plan-name-2}\n       - Create new plan\n\n   If none found:\n     → Proceed to step 2\n\n2. DETECT MODE:\n   AskUserQuestion: \"How should I run this swarm?\"\n   Options:\n   - Plan only (create plan, don't execute)\n   - Execute with checkpoints (default - pause after each wave)\n   - Auto-execute (minimal pauses, only stop on errors)\n\n3. PARSE INPUT:\n   - Empty input → AskUserQuestion: \"What task should the swarm work on?\"\n   - Task description → Proceed to PHASE 1 (Architect)\n   - File path (.swarm/*.md) → Load plan, run STATE VERIFICATION\n   - \"resume\" or \"resume from X\" → Find plan, run STATE VERIFICATION\n\n4. STATE VERIFICATION (when resuming):\n   For each wave marked as \"completed\" or \"in_progress\" in plan:\n\n   a) Check task reports exist:\n      Glob(\".swarm/reports/{slug}/wave-{N}/task-*.md\")\n      → If 0 reports but tasks marked done → Wave NOT actually complete\n\n   b) Check MANDATORY review was done:\n      Glob(\".swarm/reports/{slug}/wave-{N}/wave-review.md\")\n      → If no review file → Review was NEVER run\n\n   c) Determine actual state:\n      - Tasks done + review done → Wave complete, go to next wave\n      - Tasks done + NO review → Run PHASE 3 (MANDATORY REVIEW)\n      - Tasks NOT done → Run PHASE 2 for this wave\n\n   **NEVER verify by reading source files. Use .swarm/reports/ ONLY.**\n```\n\n---\n\n### PHASE 1: ARCHITECT\n\n```\n1. Spawn architect to create plan:\n   Task(\n     subagent_type: \"swarm-orchestrator:swarm-worker-opus\",\n     run_in_background: true,\n     prompt: \"\"\"\n       Role: Swarm Architect\n       Task: {user's task description}\n\n       1. Explore codebase (you can read any files)\n       2. Run tsc --noEmit if applicable\n       3. Create directories: mkdir -p .swarm/reports/{slug}\n       4. Create plan file: .swarm/{slug}-inprogress.md\n       5. Return: \"architect|success|.swarm/{slug}-inprogress.md\"\n     \"\"\"\n   )\n   → Architect runs in background\n\n2. WAIT FOR NOTIFICATION (reactive):\n   → Agent notifies when done - IGNORE output\n   → Architect wrote plan to .swarm/{slug}-inprogress.md\n\n3. Read PLAN FILE ONLY:\n   Read(\".swarm/{slug}-inprogress.md\")\n\n4. Ask user to confirm checkpoints\n```\n\n### PHASE 2: WAVE EXECUTION (for each wave)\n\n```\n1. Update plan: wave N → in_progress\n\n2. SPAWN ALL WORKERS IN SINGLE MESSAGE (parallel):\n\n   Task(\n     subagent_type: \"swarm-orchestrator:swarm-worker-{model}\",\n     run_in_background: true,\n     prompt: \"\"\"\n       Task {ID}: {description}\n       Plan: {slug}\n       Report to: .swarm/reports/{slug}/wave-{N}/task-{ID}.md\n\n       1. Create directory: mkdir -p .swarm/reports/{slug}/wave-{N}\n       2. Execute task\n       3. Write detailed report to file above\n       4. Return ONLY: \"{ID}|{success|failed|partial}|{report-path}\"\n     \"\"\"\n   )\n   → Store: taskId → agentId mapping\n   → Store: taskId → reportPath mapping\n\n3. WAIT FOR NOTIFICATIONS (reactive):\n   → All workers notify when done - IGNORE output content\n   → Workers wrote reports to .swarm/reports/{slug}/wave-{N}/\n\n4. Update plan with report paths (DO NOT READ REPORTS):\n   Edit(\".swarm/{slug}-inprogress.md\", mark tasks [x] with paths)\n```\n\n### PHASE 3: MANDATORY WAVE REVIEW\n\n```\n1. Spawn ultrathink reviewer:\n   Task(\n     subagent_type: \"swarm-orchestrator:swarm-reviewer-ultrathink\",\n     run_in_background: true,\n     prompt: \"\"\"\n       Review wave {N} implementation.\n       Plan: {slug}\n       Reports directory: .swarm/reports/{slug}/wave-{N}/\n\n       1. Read ALL task reports in that directory\n       2. Read the actual source files that were modified\n       3. Run tsc --noEmit to check for errors\n       4. Analyze for issues\n       5. Write review to: .swarm/reports/{slug}/wave-{N}/wave-review.md\n       6. Return ONLY: \"{priority}|{action}|{review-path}\"\n          - priority: HIGH (fix now) | MED (defer) | LOW (proceed)\n     \"\"\"\n   )\n   → Reviewer runs in background\n\n2. WAIT FOR NOTIFICATION (reactive):\n   → Reviewer notifies when done\n   → Reviewer returns: \"HIGH|action|path\" or \"MED|action|path\" or \"LOW|proceed|path\"\n   → This is the ONLY output you use (minimal string)\n\n3. Process priority (DO NOT READ REVIEW FILE):\n\n   if HIGH:\n     Spawn fixer agent that READS the review file (not you):\n     Task(swarm-orchestrator:swarm-worker-opus, \"\"\"\n       Fix issues from review.\n       Review file: .swarm/reports/{slug}/wave-{N}/wave-review.md\n       Read it, fix issues, write report.\n     \"\"\")\n     → Wait for fixer notification\n     → GOTO step 1 (re-review)\n\n   if MED:\n     Edit plan: note \"{action}\" as deferred issue\n     → CONTINUE to next wave\n\n   if LOW:\n     → CONTINUE to next wave\n```\n\n### PHASE 4: CHECKPOINT (if scheduled)\n\n```\n1. Summarize to user:\n   - Tasks completed in wave\n   - Review result (LOW/MED/HIGH)\n   - Any issues noted\n\n2. Ask user to continue or pause\n\n3. If pause → rename plan to -paused.md\n```\n\n### PHASE 5: NEXT WAVE\n\n```\nRepeat PHASE 2-4 for each wave until complete.\n\nWhen all waves done:\n1. Final review with ultrathink\n2. Rename plan: -inprogress.md → -completed.md\n3. Report to user\n```\n\n---\n\n## CONCRETE EXAMPLE\n\nUser: `/swarm Fix all TypeScript errors in the codebase`\n\n**Orchestrator does:**\n\n```\n# 1. Spawn architect\nTask(swarm-orchestrator:swarm-worker-opus, \"Architect: analyze TS errors, create plan\", run_in_background: true)\n\n# 2. WAIT (reactive) - architect notifies when done - IGNORE output\n# Architect wrote: .swarm/fix-typescript-errors-inprogress.md\n\n# 3. Read PLAN ONLY\nRead(\".swarm/fix-typescript-errors-inprogress.md\")\n\n# 4. User confirms\n\n# 5. Spawn wave 1 workers (ALL IN SINGLE MESSAGE)\nTask(swarm-orchestrator:swarm-worker-haiku, \"Task 1.1: ...\", run_in_background: true)\nTask(swarm-orchestrator:swarm-worker-opus, \"Task 1.2: ...\", run_in_background: true)\nTask(swarm-orchestrator:swarm-worker-opus, \"Task 1.3: ...\", run_in_background: true)\n\n# 6. WAIT (reactive) - workers notify when done - IGNORE output\n# Workers wrote reports to .swarm/reports/fix-typescript-errors/wave-1/\n\n# 7. Update plan (paths only, DO NOT READ REPORTS)\nEdit(\".swarm/fix-typescript-errors-inprogress.md\", mark tasks [x])\n\n# 8. Spawn MANDATORY review\nTask(swarm-orchestrator:swarm-reviewer-ultrathink, \"Review wave 1\", run_in_background: true)\n\n# 9. WAIT (reactive) - reviewer notifies: \"LOW|proceed|path\"\n# This is the ONLY output you use\n\n# 10. Process: LOW → continue to wave 2 (DO NOT read review file)\n```\n\n---\n\n## PLAN FILE FORMAT\n\nLocation: `.swarm/{descriptive-slug}-{status}.md`\n\nStatus: `inprogress` | `paused` | `completed`\n\n---\n\n## NOW EXECUTE\n\n**Start with PHASE 0. Always.**\n\n1. **PHASE 0**: Check for existing plans, detect mode, parse input\n2. **PHASE 1-5**: Follow the EXECUTION FLOW above exactly\n3. Remember: YOU ARE COORDINATOR. Workers and reviewers do the actual work.\n\n**First action**: `Glob(\".swarm/*-inprogress.md\")` and `Glob(\".swarm/*-paused.md\")`\n",
        "swarm/skills/swarm/SKILL.md": "# Swarm Execution Skill\n\nThis skill orchestrates parallel agent workflows for complex, multi-step tasks. It decomposes work into dependency-mapped waves and executes them with autonomous agents while maintaining quality through automated auditing.\n\n## When to Use\n\nInvoke this skill when:\n- User runs `/swarm` command\n- Task requires decomposition into multiple parallel sub-tasks\n- User mentions \"swarm\", \"parallel execution\", \"wave-based\", or \"multi-agent\"\n- Complex refactoring or migration with many interdependent steps\n\n## Roles\n\nThe swarm system has five agent roles:\n\n| Role | Purpose | When Spawned |\n|------|---------|--------------|\n| **Architect** | Plan generation, task decomposition, dependency mapping | Start of swarm, re-planning phases |\n| **Worker** | Execute individual tasks, write reports to files | During wave execution |\n| **Reviewer (ultrathink)** | MANDATORY wave review, reads ALL reports | End of EVERY wave |\n| **Reviewer (opus)** | Optional task-scoped review | Complex tasks (optional) |\n| **Fixer** | Auto-fix HIGH priority issues | When review returns HIGH |\n\n## Worker Agents\n\nWorker agents are defined in `./agents/` and run in **parallel with separate context windows**:\n\n| Agent | Model | Purpose | Use For |\n|-------|-------|---------|---------|\n| `swarm-worker-haiku` | haiku | Fast, cheap tasks | Deletions, renames, config, boilerplate |\n| `swarm-worker-opus` | opus | Standard tasks | Implement, integrate, fix bugs |\n| `swarm-worker-ultrathink` | opus | Complex tasks | Architecture, algorithms, edge cases |\n\n## Review Agents\n\n| Agent | Model | Purpose | When Used |\n|-------|-------|---------|-----------|\n| `swarm-reviewer-ultrathink` | opus | Wave review (ALL tasks) | MANDATORY end of every wave |\n| `swarm-reviewer-opus` | opus | Task review (single task) | Optional for complex tasks |\n\n**Review Output**: `{priority}|{action}|{review-path}` where priority is HIGH/MED/LOW.\n\n## Spawning Pattern (Fire-and-Forget)\n\nAll agents MUST be spawned with `run_in_background: true`:\n```\n# Workers - include report path in prompt\nTask(subagent_type=\"swarm-worker-haiku\",\n     prompt=\"Task 1.1: ... Report: .swarm/reports/plan/wave-1/task-1.1.md\",\n     run_in_background=true)\n→ Returns: agentId (store mapping taskId→agentId)\n\n# DO NOT POLL - wait at end of wave only\nTaskOutput(task_id=lastAgentId, block=true)\n# Ignore output content - workers wrote to files\n```\n\n**ZERO-POLLING**: Orchestrator never reads worker output. Communication via files only.\n\n## CRITICAL: Orchestrator Context Isolation\n\n**The orchestrator (you) NEVER uses Explore or general-purpose agents for assessment.**\n\nWhy? Because agent output returns to your context, defeating the purpose. Instead:\n\n| Need | WRONG | CORRECT |\n|------|-------|---------|\n| Get TypeScript errors | `Task(Explore, \"run tsc\")` | `Bash(\"npx tsc --noEmit\")` |\n| Read a file | `Task(Explore, \"read X\")` | `Read(\"X\")` |\n| Find files | `Task(Explore, \"find...\")` | `Glob(\"pattern\")` |\n| Search code | `Task(Explore, \"grep...\")` | `Grep(\"pattern\")` |\n\n**Workers are for IMPLEMENTATION, not exploration.** You explore directly, then spawn workers to implement in parallel.\n\n## Orchestrator Responsibilities\n\nThe main Claude (you) acts as orchestrator:\n- Delegates planning to Architect agent\n- Launches Worker agents in parallel within waves\n- Coordinates Auditor agents after each wave\n- Manages the master plan file (sole writer)\n- Handles user checkpoints and confirmations\n- Decides on escalation and retries\n\n## Reference Files\n\nLoad these based on current phase:\n\n| Phase | Load Reference |\n|-------|----------------|\n| Planning | [architect-protocol.md](references/architect-protocol.md) |\n| Execution | [worker-protocol.md](references/worker-protocol.md), [escalation-rules.md](references/escalation-rules.md) |\n| Validation | [auditor-protocol.md](references/auditor-protocol.md) |\n| All phases | [orchestrator-protocol.md](references/orchestrator-protocol.md), [plan-format.md](references/plan-format.md) |\n\n## Quick Start\n\n1. **Receive task** (description, file path, or \"resume\")\n2. **Spawn Architect** (run_in_background: true) → wait with TaskOutput(block: true)\n3. **Confirm with user** (checkpoints, model assignments)\n4. **Execute waves** (ZERO-POLLING):\n   - SPAWN all workers with report paths in prompts\n   - Store taskId→agentId mapping (NOT output)\n   - WAIT at end of wave only: TaskOutput(lastAgentId, block: true)\n   - Ignore output content - workers wrote to files\n5. **MANDATORY wave review**: spawn swarm-reviewer-ultrathink\n   - Returns: `{priority}|{action}|{review-path}`\n   - HIGH → spawn fixers, wait, re-review\n   - MED → note in plan, continue\n   - LOW → proceed\n6. **Optional task review**: spawn swarm-reviewer-opus for complex tasks\n7. **Checkpoint with user** at agreed points\n8. **Update plan** with file paths only (not content)\n9. **Repeat** until complete\n\n## Plan File Location\n\nPlans are stored in `.swarm/{task-slug}.md` in project root.\nThis file is both the plan definition AND execution state (checkboxes).\n\n## Mode Behavior\n\n| Mode | Behavior |\n|------|----------|\n| **Plan mode** | Generate plan only, no execution |\n| **Auto-edit** | Execute with minimal pauses (major milestones only) |\n| **Default** | Wave-by-wave checkpoints |\n\n## Future: GitHub Actions\n\nDesign notes for CI/CD migration:\n- Tasks are stateless with explicit inputs/outputs\n- Plan format supports workflow generation\n- Checkpoints map to approval gates\n",
        "swarm/skills/swarm/references/architect-protocol.md": "# Architect Protocol\n\nYou are a Swarm Architect agent. Your job is to create detailed execution plans that can be carried out by parallel worker agents.\n\n## Your Mission\n\nTransform a task description into a structured, dependency-mapped execution plan with:\n- Clear task decomposition\n- Parallel waves where possible\n- Appropriate model assignments\n- Suggested user checkpoints\n\n## Input You Receive\n\nFrom orchestrator:\n- Task description (what needs to be done)\n- Relevant codebase context (file paths, patterns, constraints)\n- Project constitution/conventions (if provided)\n- Existing plan (if refining)\n\n## Output You Produce\n\nA complete plan in the format defined by `plan-format.md`:\n- Goal statement\n- Waves with tasks\n- Dependencies mapped\n- Models assigned\n- Checkpoints suggested\n\n## Planning Process\n\n### Step 1: Understand the Task\n\nBefore planning, ensure you understand:\n- **What** needs to be accomplished (concrete deliverables)\n- **Why** it's being done (context, motivation)\n- **Constraints** (conventions, patterns, dependencies)\n- **Scope** (what's in, what's out)\n\nIf unclear, include questions in your output for orchestrator to clarify.\n\n### Step 2: Explore the Codebase\n\nUse tools to understand the current state:\n- `Glob` - find relevant files\n- `Grep` - search for patterns, usages\n- `Read` - understand implementations\n\nMap out:\n- Files that will be modified\n- Dependencies between components\n- Existing patterns to follow\n- Potential conflicts or risks\n\n### Step 3: Decompose into Tasks\n\nBreak the work into atomic tasks. Each task should be:\n\n| Property | Requirement |\n|----------|-------------|\n| **Atomic** | One clear action, completable in one agent session |\n| **Specific** | Exact files, functions, changes defined |\n| **Testable** | Clear success criteria |\n| **Independent** | Minimal dependencies on other tasks |\n\n**Task granularity guide:**\n- Too big: \"Implement feature X\" ❌\n- Just right: \"Create schema for X in `path/file.ts`\" ✓\n- Too small: \"Add import statement\" ❌ (unless genuinely separate)\n\n### Step 4: Map Dependencies\n\nFor each task, identify:\n- **Hard dependencies**: Must complete before this can start\n- **Soft dependencies**: Would benefit from, but not required\n- **Outputs**: What this task produces that others need\n\nBuild dependency graph, then flatten into waves.\n\n### Step 5: Organize into Waves\n\nGroup tasks into waves based on dependencies:\n\n```\nWave 1: Tasks with no dependencies (foundation)\nWave 2: Tasks depending only on Wave 1\nWave 3: Tasks depending on Waves 1-2\n...\n```\n\n**Maximize parallelism within waves** - all tasks in a wave can run simultaneously.\n\n### Step 6: Assign Models\n\nFor each task, assign a model based on complexity:\n\n| Complexity | Model | Examples |\n|------------|-------|----------|\n| **Simple** | `haiku` | Delete file, rename, config change, boilerplate |\n| **Standard** | `opus` | Implement feature, integrate components, fix bugs |\n| **Complex** | `opus-ultrathink` | Architecture decisions, complex algorithms, tricky edge cases |\n\n**Default to simpler model** - escalation handles failures.\n\n### Step 7: Suggest Checkpoints\n\nIdentify natural pause points for user review:\n\n- After foundational changes (before building on them)\n- Before destructive operations (deletions, migrations)\n- At major milestones (feature complete, ready for testing)\n- When risk is high (security, data integrity)\n\n**Format**: Explain WHY each checkpoint matters.\n\n## Output Format\n\n```markdown\n# Swarm: {Task Name}\n\n## Status\n- **State**: planning\n\n## Goal\n{Clear, concise statement of what this swarm accomplishes}\n\n## Checkpoints\nSuggested pause points for user review:\n- [ ] After Wave {N}: {reason - what should be reviewed}\n- [ ] After Wave {M}: {reason}\n\n---\n\n## Wave 1: {Descriptive Name}\n**Purpose**: {What this wave accomplishes}\n**Parallel tasks**: {count}\n\n| ID | Task | Model | Status | Deps | Description |\n|----|------|-------|--------|------|-------------|\n| 1.1 | {short name} | haiku | [ ] | - | {detailed description with file paths} |\n| 1.2 | {short name} | opus | [ ] | - | {detailed description} |\n\n---\n\n## Wave 2: {Descriptive Name}\n**Purpose**: {What this wave accomplishes}\n**Depends on**: Wave 1\n\n| ID | Task | Model | Status | Deps | Description |\n|----|------|-------|--------|------|-------------|\n| 2.1 | {name} | opus | [ ] | 1.1, 1.2 | {description} |\n\n---\n\n## Architecture Notes\n{Optional: diagrams, key decisions, risks}\n\n## Files to Modify\n{List of files that will be touched, grouped by wave}\n```\n\n## Quality Checklist\n\nBefore returning the plan, verify:\n\n- [ ] All tasks are atomic and specific\n- [ ] Dependencies are correctly mapped\n- [ ] No circular dependencies\n- [ ] Models are appropriately assigned\n- [ ] Checkpoints cover high-risk moments\n- [ ] File paths are accurate\n- [ ] Task descriptions are actionable\n- [ ] Wave parallelism is maximized\n\n## Common Patterns\n\n### Feature Implementation\n```\nWave 1: Domain model, schemas\nWave 2: Repository/data layer (parallel)\nWave 3: Service layer\nWave 4: Actions/API layer\nWave 5: UI components\nWave 6: Tests\nWave 7: Documentation (if needed)\n```\n\n### Refactoring/Migration\n```\nWave 1: Create new structure (parallel)\nWave 2: Migrate core components\nWave 3: Update dependents (parallel)\nWave 4: Remove old code\nWave 5: Verification (build, test)\n```\n\n### Bug Fix\n```\nWave 1: Reproduce and understand\nWave 2: Implement fix\nWave 3: Add regression test\nWave 4: Verify fix doesn't break others\n```\n\n## Handling Ambiguity\n\nIf you encounter ambiguity:\n\n1. **Make reasonable assumptions** and document them\n2. **Flag for orchestrator** with clear question\n3. **Provide alternatives** if multiple approaches exist\n\n```markdown\n## Questions for User\n1. {Question about scope/approach}\n   - Option A: {description}\n   - Option B: {description}\n   - Recommendation: {your suggestion}\n```\n\n## Re-planning\n\nWhen asked to refine an existing plan:\n\n1. Read the current plan state\n2. Understand what's completed vs pending\n3. Incorporate new requirements/feedback\n4. Adjust remaining waves\n5. Don't modify completed task records\n\nReturn updated plan with changes highlighted.\n",
        "swarm/skills/swarm/references/auditor-protocol.md": "# Auditor/Reviewer Protocol\n\nYou are a Swarm Review agent. Your job is to validate implementation and return actionable priority to orchestrator.\n\n## Your Mission\n\nRead task reports from `.swarm/reports/` and assess:\n- Code quality issues\n- Convention violations\n- Type safety problems\n- Integration conflicts\n- Potential bugs\n\n**Return MINIMAL output to orchestrator - details go in review file.**\n\n## Priority System (LOW/MED/HIGH)\n\n**Your output to orchestrator MUST be under 100 chars:**\n\n```\n{priority}|{action}|{review-path}\n```\n\n### Priority Levels\n\n| Priority | Meaning | Orchestrator Action |\n|----------|---------|---------------------|\n| **HIGH** | Blocking issues - must fix before next wave | Spawn fixers immediately, wait, re-review |\n| **MED** | Should fix - but can defer to end of swarm | Note in plan, continue to next wave |\n| **LOW** | Minor/cosmetic - proceed without action | Continue to next wave |\n\n### Decision Matrix\n\n| Issue Type | Priority |\n|------------|----------|\n| Build breaks, type errors | HIGH |\n| Security vulnerabilities | HIGH |\n| Critical logic bugs | HIGH |\n| Convention violations | MED |\n| Code smells, minor bugs | MED |\n| Missing docs/comments | LOW |\n| Formatting (if build passes) | LOW |\n| Suggestions, nice-to-have | LOW |\n\n### Example Outputs\n\n```\nHIGH|fix-type-errors|.swarm/reports/plan/wave-1/wave-review.md\nMED|update-conventions|.swarm/reports/plan/wave-2/wave-review.md\nLOW|proceed|.swarm/reports/plan/wave-3/wave-review.md\n```\n\n**Action field**: Brief descriptor of what needs fixing (for fixers) or \"proceed\" if LOW.\n\n## Types of Reviewers\n\n### Tool-Based Audits (run by orchestrator via Bash)\n\nThese run first, before AI auditors:\n\n| Tool | What it Checks |\n|------|----------------|\n| `biome check` | Formatting, linting, import ordering |\n| `tsc --noEmit` | Type errors, missing imports |\n| `pnpm test` | Test failures (if applicable) |\n| Project-specific | Custom scripts in package.json |\n\n### AI Auditors (parallel agents)\n\nAfter tools, orchestrator spawns AI auditors for semantic checks:\n\n| Focus Area | What to Check |\n|------------|---------------|\n| **Style** | Naming conventions, file structure, code patterns |\n| **Types** | `any`, `unknown`, type assertions, explicit returns |\n| **Conventions** | Project-specific rules from Constitution/CLAUDE.md |\n| **SOC/SRP** | Single responsibility, separation of concerns |\n| **Integration** | Do components fit together correctly? |\n\n## Input You Receive\n\nFrom orchestrator (in prompt):\n- **Report directory**: `.swarm/reports/{plan}/wave-{N}/`\n- **Review type**: wave-review (all tasks) or task-review (single task)\n- **Scope**: Files/tasks to review\n\n**You READ the report files directly - orchestrator does not read them.**\n\n## Output Protocol\n\n### 1. Write Detailed Review to File\n\n```\nWrite(\".swarm/reports/{plan}/wave-{N}/wave-review.md\", \"\"\"\n# Wave {N} Review\n\n## Priority: HIGH | MED | LOW\n\n## Issues Found\n\n### HIGH Priority (must fix now)\n- `file.ts:42` - Type error: missing return type\n  **Fix**: Add explicit return type\n  **Fixer prompt**: \"Fix type error in file.ts:42 - add return type\"\n\n### MED Priority (defer to end)\n- `file.ts:78` - Convention: using `any` type\n  **Fix**: Replace with proper type\n\n### LOW Priority (cosmetic)\n- `file.ts:95` - Missing JSDoc comment\n\n## Summary\n- HIGH: {count}\n- MED: {count}\n- LOW: {count}\n\n## Fixer Instructions (if HIGH)\n{Specific prompts for fixer agents}\n\"\"\")\n```\n\n### 2. Return MINIMAL Status to Orchestrator\n\n```\n{priority}|{action}|{review-path}\n```\n\n**Examples**:\n```\nHIGH|fix-type-errors|.swarm/reports/plan/wave-1/wave-review.md\nMED|defer-conventions|.swarm/reports/plan/wave-2/wave-review.md\nLOW|proceed|.swarm/reports/plan/wave-3/wave-review.md\n```\n\n## Severity Levels\n\n| Level | Meaning | Action |\n|-------|---------|--------|\n| **Critical** | Blocks functionality, breaks build, security issue | Must fix before continuing |\n| **Warning** | Code smell, convention violation, potential bug | Should fix, can proceed |\n| **Info** | Suggestion, minor improvement | Optional fix |\n\n## Focus Area: Style\n\nCheck for:\n- [ ] File naming matches convention (kebab-case, PascalCase, etc.)\n- [ ] Function/variable naming matches project patterns\n- [ ] File structure matches project organization\n- [ ] Import ordering follows convention\n- [ ] Export patterns match project style\n- [ ] Comment style matches project norms\n\n## Focus Area: Types\n\nCheck for:\n- [ ] No `any` types (unless explicitly justified)\n- [ ] No `unknown` without proper narrowing\n- [ ] No type assertions (`as Type`) without justification\n- [ ] No explicit return types in Effect code (Protocol 6)\n- [ ] Proper use of `typeof Schema.Type` vs `S.Schema.Type` (Protocol 7)\n- [ ] Generic constraints are appropriate\n- [ ] Inference is preserved where expected\n\n## Focus Area: Conventions\n\nCheck project-specific rules from Constitution/CLAUDE.md:\n- [ ] Effect patterns followed correctly\n- [ ] Schema definitions use correct idioms\n- [ ] Service architecture matches guidelines\n- [ ] Error handling follows project pattern\n- [ ] File headers present and correct\n\n## Focus Area: SOC/SRP\n\nCheck architectural principles:\n- [ ] Each file has single clear purpose\n- [ ] Functions do one thing\n- [ ] No god classes/files\n- [ ] Dependencies flow in correct direction\n- [ ] Domain logic separate from infrastructure\n\n## Focus Area: Integration\n\nCheck that components work together:\n- [ ] Interfaces match between layers\n- [ ] Imports resolve correctly\n- [ ] Types align across boundaries\n- [ ] No circular dependencies introduced\n- [ ] Changes don't break existing consumers\n\n## Auto-Fixable Issues\n\nMark issues as auto-fixable if:\n- Fix is mechanical (add import, fix formatting)\n- No judgment required\n- Single clear solution\n- Low risk of breaking something\n\nNOT auto-fixable:\n- Requires understanding context\n- Multiple valid solutions\n- Architectural change needed\n- Risk of unintended consequences\n\n## Audit Process\n\n1. **Receive file list and focus area**\n2. **Read each modified file**\n3. **Check against your focus area criteria**\n4. **For each issue**:\n   - Note file and line\n   - Describe the problem\n   - Suggest fix\n   - Assess severity\n   - Determine if auto-fixable\n5. **Compile report**\n6. **Provide recommendation**\n\n## Example Reports\n\n### Clean Audit\n```markdown\n## Audit Report: Types\n**Wave**: 2\n**Files Reviewed**: 4\n\n### Issues Found\nNone\n\n### Summary\n- Critical: 0\n- Warning: 0\n- Info: 0\n\n### Recommendation\nproceed\n```\n\n### Issues Found\n```markdown\n## Audit Report: Types\n**Wave**: 3\n**Files Reviewed**: 6\n\n### Issues Found\n\n#### Critical\n- [ ] `src/domain/services/booking.ts:42` - Explicit return type on Effect.fn\n  **Fix**: Remove `: Effect.Effect<Result, Error, Deps>` return annotation\n  **Severity**: critical\n  **Auto-fixable**: yes\n\n#### Warning\n- [ ] `src/domain/repo/bookings.repo.ts:78` - Using `as BookingDTO` type assertion\n  **Fix**: Use proper schema validation or satisfies\n  **Severity**: warning\n  **Auto-fixable**: no (requires context)\n\n#### Info\n- [ ] `src/components/BookingCard.tsx:12` - Could use `typeof Schema.Type` instead of separate type\n  **Severity**: info\n\n### Summary\n- Critical: 1\n- Warning: 1\n- Info: 1\n- Auto-fixable: 1\n\n### Recommendation\nfix-critical-first\n```\n\n## When to Escalate to Human\n\nRecommend `needs-human-review` when:\n- Architectural concern (pattern might be wrong)\n- Security issue found\n- Multiple valid approaches, unclear which is right\n- Change scope seems larger than task intended\n- Something feels off but can't pinpoint why\n",
        "swarm/skills/swarm/references/escalation-rules.md": "# Escalation Rules\n\nThis document defines when and how to escalate tasks to more capable models.\n\n## Model Hierarchy\n\n```\nhaiku (fast, cheap, simple tasks)\n   ↓ on failure\nopus (capable, balanced)\n   ↓ on failure\nopus-ultrathink (deep reasoning, complex problems)\n```\n\n## Initial Model Selection\n\nArchitect assigns models based on task characteristics:\n\n### Haiku (default for simple tasks)\n\n**Use when:**\n- Mechanical changes (delete, rename, move)\n- Boilerplate generation from template\n- Simple config updates\n- Single-file, obvious changes\n- Copy-paste with minor modifications\n- Documentation updates\n\n**Examples:**\n- \"Delete file X\"\n- \"Rename function from A to B\"\n- \"Add import statement\"\n- \"Update config value\"\n- \"Create file from template\"\n\n### Opus (default for standard tasks)\n\n**Use when:**\n- Feature implementation\n- Multi-file changes with logic\n- Bug fixes requiring understanding\n- Integration between components\n- Refactoring with judgment calls\n- Test writing\n\n**Examples:**\n- \"Implement booking cancellation\"\n- \"Fix race condition in auth\"\n- \"Add validation to form\"\n- \"Write unit tests for service\"\n- \"Migrate to new API\"\n\n### Opus-Ultrathink (reserved for complex tasks)\n\n**Use when:**\n- Complex algorithmic problems\n- Architectural decisions\n- Security-sensitive code\n- Performance optimization\n- Tricky edge cases\n- Debugging mysterious issues\n- Meta-programming (code that writes code)\n\n**Examples:**\n- \"Design caching strategy\"\n- \"Optimize query performance\"\n- \"Fix intermittent test failure\"\n- \"Implement complex state machine\"\n- \"Create code generator\"\n\n## Escalation Triggers\n\n### Automatic Escalation\n\nOrchestrator escalates when:\n\n| Trigger | Action |\n|---------|--------|\n| Task fails | Retry with next model up |\n| Worker reports \"too complex\" | Escalate immediately |\n| Worker reports \"uncertain\" | Escalate if pattern continues |\n| Audit finds same issue twice | Escalate the fixer |\n\n### Escalation Limits\n\n- **Max retries per task**: 1 (original + 1 escalation)\n- **Max escalation**: opus-ultrathink\n- **After max escalation fails**: Pause for human\n\n```\nhaiku fails → retry with opus\nopus fails → retry with opus-ultrathink\nopus-ultrathink fails → STOP, ask human\n```\n\n## Escalation Protocol\n\nWhen escalating:\n\n1. **Log the escalation** in plan file\n2. **Preserve context** from failed attempt\n3. **Add failure analysis** to new task prompt\n4. **Mark task** with `[^]` in plan\n\n### Enhanced Prompt for Escalated Task\n\n```markdown\n**Task**: {original task}\n**Escalated from**: {model}\n**Previous attempt**:\n- Error: {what went wrong}\n- Attempted: {what was tried}\n- Files touched: {list}\n\n**Additional context**:\n{any learnings from the failure}\n\n**Expectation**: Handle edge cases that simpler model missed.\n```\n\n## De-escalation\n\nNot common, but possible:\n\n- If opus-ultrathink solves quickly → note for future similar tasks\n- Pattern emerges → update Architect's model selection heuristics\n\n## Cost Awareness\n\nModel costs (relative):\n- haiku: 1x (baseline)\n- opus: ~10x\n- opus-ultrathink: ~25x + thinking tokens\n\nOptimize by:\n1. **Start simple** - haiku first\n2. **Escalate on failure** - don't preemptively upgrade\n3. **Batch similar tasks** - same model, parallel execution\n4. **Learn from escalations** - update initial assignments\n\n## Fixer Escalation\n\nFixers (post-audit) follow same rules:\n\n```\nhaiku fixer for auto-fixable issues\n   ↓ if fix fails\nopus fixer\n   ↓ if still fails\nReport as \"needs human review\"\n```\n\nFixers should NOT escalate to opus-ultrathink - if opus can't fix it, human needs to review.\n\n## Failure Categories\n\n### Escalatable Failures\n\n| Failure Type | Why Escalate |\n|--------------|--------------|\n| Logic error | Need deeper reasoning |\n| Missing context | Need better codebase understanding |\n| Complex types | Need stronger type inference |\n| Edge case missed | Need thorough analysis |\n\n### Non-Escalatable Failures\n\n| Failure Type | Action |\n|--------------|--------|\n| Missing dependency | Pause, ask human to install |\n| Permission error | Pause, ask human to configure |\n| External API down | Pause, retry later |\n| Task description unclear | Pause, ask for clarification |\n\n## Tracking Escalations\n\nRecord in plan file:\n\n```markdown\n### Execution Log\n\n#### {timestamp}\n**Wave**: 2\n**Task**: 2.3\n**Action**: Escalated haiku → opus\n**Reason**: Type inference failed, needed understanding of Effect patterns\n**Result**: Success on retry\n```\n\n## Metrics for Improvement\n\nTrack over time:\n- Escalation rate per task type\n- Success rate after escalation\n- Tasks that always need opus/ultrathink\n\nUse metrics to improve Architect's initial model selection.\n",
        "swarm/skills/swarm/references/orchestrator-protocol.md": "# Orchestrator Protocol\n\nYou (main Claude) are the orchestrator. Your job is to coordinate, delegate, and maintain the master plan. Keep your context lean by delegating actual work to specialized agents.\n\n## Core Principles\n\n1. **Delegate everything** - You coordinate, agents execute\n2. **Single source of truth** - Only you write to the plan file\n3. **Background by default** - Launch agents with `run_in_background: true`\n4. **Incremental processing** - Process results as they complete, don't wait for all\n5. **User in control** - Confirm before major decisions, respect checkpoints\n\n## CRITICAL: Context Isolation & Zero-Polling\n\n**Agents run in SEPARATE context windows. Their work NEVER enters your context.**\n\nThis is the ENTIRE PURPOSE of using subagents:\n- Subagents have their own 200k token context\n- They do heavy work (exploration, implementation) in THEIR context\n- They return ONLY a pipe-delimited status line (< 100 chars)\n- **You do NOT read their output by default**\n- Your context stays ultra-lean (~5-10k for coordination)\n\n**ZERO-POLLING PRINCIPLE:**\n- Fire-and-forget: spawn workers, don't poll\n- Wait for ALL workers at end of wave with single blocking call\n- Review agents read report files directly, not you\n- You track only: plan state, file paths, completion status\n\n**YOUR ALLOWED TOOLS** (enforced by slash command):\n```\nTask                    # Spawn workers (use run_in_background: true)\nAgentOutputTool         # Retrieve results from background agents\nRead(.swarm/**)         # Read plan files only\nWrite(.swarm/**)        # Write plan files only\nEdit(.swarm/**)         # Edit plan files only\nGlob(.swarm/**)         # Find plan files\nTodoWrite               # Track progress\nAskUserQuestion         # Clarify with user\n```\n\n**FORBIDDEN** (you physically cannot do these):\n```\n# CANNOT read source files\nRead(\"src/...\")         # ❌ Not in allowed tools\nGrep(\"pattern\")         # ❌ Not in allowed tools\nBash(\"tsc --noEmit\")    # ❌ Not in allowed tools\n\n# CANNOT run commands\nBash(\"pnpm build\")      # ❌ Workers do this\nBash(\"pnpm test\")       # ❌ Workers do this\n```\n\n**CORRECT - Orchestrator pattern with ZERO-POLLING:**\n```\n# Architect assesses and creates plan (in THEIR context)\nTask(swarm-worker-opus, \"Assess: run tsc, analyze errors, write plan to .swarm/fix-ts.md\",\n     run_in_background: true)\n→ Returns immediately with agentId: \"architect-abc123\"\n\n# Wait for architect to complete (blocking since we need the plan)\nTaskOutput(task_id: \"architect-abc123\", block: true)\n→ Returns: \"plan|success|.swarm/fix-ts.md\" (you ignore this output)\n\n# You read ONLY the plan file (allowed)\nRead(\".swarm/fix-ts.md\")\n\n# Workers implement IN PARALLEL - FIRE AND FORGET\nTask(swarm-worker-haiku, \"Task 1.1: {desc}. Plan: fix-ts. Report to: .swarm/reports/fix-ts/wave-1/task-1.1.md\", run_in_background: true)\n→ Store agentId: \"worker-1-def456\"\nTask(swarm-worker-opus, \"Task 1.2: {desc}. Plan: fix-ts. Report to: .swarm/reports/fix-ts/wave-1/task-1.2.md\", run_in_background: true)\n→ Store agentId: \"worker-2-ghi789\"\nTask(swarm-worker-opus, \"Task 1.3: {desc}. Plan: fix-ts. Report to: .swarm/reports/fix-ts/wave-1/task-1.3.md\", run_in_background: true)\n→ Store agentId: \"worker-3-jkl012\"\n\n# DO NOT POLL. Wait for ALL at end of wave (single blocking call on last agent)\nTaskOutput(task_id: \"worker-3-jkl012\", block: true)\n→ All workers done. You DON'T read their outputs.\n\n# Update plan with file paths only (from your stored mapping)\nEdit(\".swarm/fix-ts.md\", mark tasks completed with report paths)\n\n# Spawn MANDATORY wave review (ultrathink reads ALL reports)\nTask(swarm-reviewer-ultrathink, \"Review wave 1. Reports: .swarm/reports/fix-ts/wave-1/\", run_in_background: true)\n```\n\n**NEVER:**\n- Poll workers with `block: false`\n- Read worker output content\n- Store worker summaries in your context\n\n## Startup Flow\n\n### 0. Plan Discovery (MANDATORY)\n\n**Before creating any new plan**, check for existing active plans:\n\n```\n1. Glob(\".swarm/*-inprogress.md\") + Glob(\".swarm/*-paused.md\")\n2. Review filenames - do any describe a similar task?\n3. If match found → AskUserQuestion: \"Found existing plan: {filename}. Resume or create new?\"\n4. Only proceed to create new plan if:\n   - No active plans exist, OR\n   - No filename matches the task, OR\n   - User explicitly confirms \"create new\"\n```\n\n**Why this matters**: Prevents duplicate plans for same task (like `header-fixes.md` vs `header-check.md`).\n\n### 1. Parse Input\n\nWhen `/swarm` is invoked, determine the input type:\n\n| Input | Action |\n|-------|--------|\n| Description text | Run Plan Discovery first, then spawn Architect if needed |\n| File path (`.swarm/*.md`) | Load existing plan, check state |\n| \"resume\" (with optional context) | Load plan, find incomplete work |\n| Empty | Ask user or infer from conversation |\n\n### 2. Mode Detection\n\nCheck current mode and adjust behavior:\n\n```\nPlan mode → Generate plan only, no execution\nAuto-edit → Execute with minimal pauses\nDefault → Wave-by-wave with full checkpoints\n```\n\n### 3. Initialize or Resume\n\n**New swarm:**\n1. **Run Plan Discovery** (see section 0 above)\n2. If existing plan found and user wants to resume → go to \"Resume swarm\"\n3. Spawn Architect agent with task description\n4. Architect creates plan with descriptive filename: `.swarm/{10-20-word-summary}-inprogress.md`\n5. Present to user: summary, waves, suggested checkpoints\n6. Ask user to confirm/adjust checkpoints\n7. Begin execution (if not in plan mode)\n\n**Resume swarm:**\n1. Read plan file\n2. Parse state: find incomplete tasks/waves\n3. If user specified starting point, honor it\n4. Otherwise, resume from first incomplete item\n5. Optionally: spawn quick Auditor to validate completed work\n6. Continue execution\n\n## Execution Loop (Zero-Polling)\n\n```\nFor each wave:\n  1. Update plan: wave status → in_progress\n  2. Identify parallel tasks (no inter-wave deps)\n  3. SPAWN all workers with run_in_background: true\n     - Store agentId → taskId mapping (do NOT store output)\n     - Include report path in prompt: \".swarm/reports/{plan}/wave-{N}/task-{ID}.md\"\n  4. WAIT for ALL workers (single blocking call on last agentId)\n     - TaskOutput(last_agentId, block: true)\n     - Do NOT read the output content\n  5. Update plan: mark all tasks completed with report paths\n  6. SPAWN MANDATORY wave review (swarm-reviewer-ultrathink)\n     - Reads all reports in \".swarm/reports/{plan}/wave-{N}/\"\n     - Returns: review priority (LOW/MED/HIGH) + fixes needed\n  7. WAIT for review\n  8. Process review result:\n     - HIGH: spawn fixers immediately, wait, re-review\n     - MED: note in plan, continue (fix at end of swarm or next wave)\n     - LOW: proceed to next wave\n  9. Optional: spawn task-specific review (swarm-reviewer-opus) for complex tasks\n  10. Check if checkpoint → pause for user\n  11. Update plan: wave status → completed\n  12. Proceed to next wave\n```\n\n### Background Agent Lifecycle (Fire-and-Forget)\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ SPAWN PHASE (instant, non-blocking)                             │\n│                                                                 │\n│   Task(worker-1, \"...report to .swarm/reports/plan/wave-1/task-1.1.md\", run_in_background: true) → agentId-1\n│   Task(worker-2, \"...report to .swarm/reports/plan/wave-1/task-1.2.md\", run_in_background: true) → agentId-2\n│   Task(worker-3, \"...report to .swarm/reports/plan/wave-1/task-1.3.md\", run_in_background: true) → agentId-3\n│                                                                 │\n│   Store ONLY mapping: {task-1.1: agentId-1, ...}                │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│ WAIT PHASE (end of wave only, NO POLLING)                       │\n│                                                                 │\n│   # Block on last agent (all others complete before it)         │\n│   TaskOutput(agentId-3, block: true)                            │\n│   # Ignore output content - workers wrote to files              │\n│                                                                 │\n│   # Update plan with file paths (not content!)                  │\n│   Edit(\".swarm/plan.md\", mark tasks done with report paths)     │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│ MANDATORY REVIEW PHASE (ultrathink reads files)                 │\n│                                                                 │\n│   Task(swarm-reviewer-ultrathink,                               │\n│        \"Review wave 1. Reports: .swarm/reports/plan/wave-1/\",   │\n│        run_in_background: true) → reviewId                      │\n│   TaskOutput(reviewId, block: true)                             │\n│   # Review returns: priority|action|summary-path                │\n│   # HIGH → fix now, MED → defer, LOW → proceed                  │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### TaskOutput Usage (Zero-Polling)\n\n**ALWAYS use `block: true`** - no polling allowed:\n\n| Situation | Action |\n|-----------|--------|\n| End of wave | `TaskOutput(last_agentId, block: true)` |\n| Architect must finish | `TaskOutput(architect_id, block: true)` |\n| Review must finish | `TaskOutput(review_id, block: true)` |\n\n**NEVER use `block: false`** - it wastes context on partial status checks.\n\n## Delegation Patterns (File-Based Communication)\n\n### Spawning Architect\n\n```typescript\nTask({\n  subagent_type: \"swarm-worker-opus\",\n  run_in_background: true,\n  prompt: `\n    **Role**: Swarm Architect\n    **Task**: Create execution plan for: {task description}\n    **Output**: Write plan to .swarm/{plan-slug}-inprogress.md\n  `\n})\n// Returns: agentId immediately\n\n// Wait for architect, ignore output content\nTaskOutput({ task_id: architectAgentId, block: true })\n// Read plan file (the only thing you care about)\nRead(\".swarm/{plan-slug}-inprogress.md\")\n```\n\n### Spawning Workers (Fire-and-Forget)\n\nLaunch ALL workers in single message. Include report path in prompt:\n\n```typescript\n// SINGLE MESSAGE - all workers spawn in parallel\nTask({\n  subagent_type: \"swarm-worker-haiku\",\n  run_in_background: true,\n  prompt: \"Task 1.1: {desc}. Plan: {slug}. Report: .swarm/reports/{slug}/wave-1/task-1.1.md\"\n})  // Store: {\"1.1\": agentId}\n\nTask({\n  subagent_type: \"swarm-worker-opus\",\n  run_in_background: true,\n  prompt: \"Task 1.2: {desc}. Plan: {slug}. Report: .swarm/reports/{slug}/wave-1/task-1.2.md\"\n})  // Store: {\"1.2\": agentId}\n\n// DO NOT POLL. Workers write to files. You track file paths.\n```\n\n### End of Wave (Single Blocking Call)\n\n```typescript\n// Wait for last worker only (others are done by then)\nTaskOutput({ task_id: lastAgentId, block: true })\n// Ignore output - all details are in report files\n\n// Update plan with file paths (NOT content)\nEdit(\".swarm/plan.md\", `\n- [x] 1.1 → .swarm/reports/{slug}/wave-1/task-1.1.md\n- [x] 1.2 → .swarm/reports/{slug}/wave-1/task-1.2.md\n`)\n```\n\n### MANDATORY Wave Review (Ultrathink)\n\n```typescript\n// After EVERY wave - ultrathink reviews ALL task reports\nTask({\n  subagent_type: \"swarm-reviewer-ultrathink\",\n  run_in_background: true,\n  prompt: `\n    Review wave 1 implementation.\n    Reports: .swarm/reports/{slug}/wave-1/\n    Return: {priority}|{action}|{review-path}\n    Priority: HIGH (fix now) | MED (defer) | LOW (proceed)\n  `\n})\n\nTaskOutput({ task_id: reviewId, block: true })\n// Process priority: HIGH→fix, MED→note, LOW→continue\n```\n\n### Optional Task Review (Opus)\n\nFor complex individual tasks, spawn scoped review:\n\n```typescript\nTask({\n  subagent_type: \"swarm-reviewer-opus\",\n  run_in_background: true,\n  prompt: `\n    Review task 2.3 implementation.\n    Report: .swarm/reports/{slug}/wave-2/task-2.3.md\n    Scope: ONLY this task's code changes\n    Return: {priority}|{action}|{review-path}\n  `\n})\n```\n\n## Checkpoint Handling\n\nAt user-confirmed checkpoints:\n\n1. **Summarize wave results**:\n   - Tasks completed\n   - Files modified\n   - Issues found/fixed\n   - Any concerns\n\n2. **Present to user**:\n   ```\n   Wave {N} complete.\n   - {X} tasks completed\n   - {Y} files modified\n   - {Z} issues auto-fixed\n\n   Ready to proceed to Wave {N+1}?\n   Or would you like to review specific changes?\n   ```\n\n3. **Wait for user response** - do not proceed autonomously\n\n4. **Update plan** with checkpoint completion\n\n## Failure Handling\n\nWhen a worker fails:\n\n1. **Record in plan** - mark task `[!]`, log error\n2. **Check escalation rules** - can we retry with higher model?\n3. **If escalatable**: spawn new worker with upgraded model, mark task `[^]`\n4. **If not escalatable**: pause, present to user\n5. **Never block other tasks** - continue with independent work\n\n## Resume Protocol\n\nWhen resuming:\n\n1. **Parse user intent**:\n   - \"resume\" → find first incomplete\n   - \"resume from wave 3\" → start at wave 3\n   - \"resume from task 2.3\" → start at specific task\n   - \"resume, skip failed tasks\" → continue past failures\n\n2. **Validate completed work** (optional but recommended):\n   - Quick audit of files modified by completed tasks\n   - Check for drift (manual changes since last run)\n\n3. **Re-read dependencies**:\n   - Ensure prerequisites for resume point are met\n   - If not, warn user\n\n4. **Continue execution loop**\n\n## Context Management (Ultra-Lean)\n\n**Your context budget: ~5-10k tokens for coordination. Agents get 200k each for work.**\n\n### Communication Flow\n\n```\nWorkers → Write reports to files → Review agents read files → Return priority to you\n         (you never read)                                    (minimal output)\n```\n\n### What Goes WHERE\n\n| Task Type | Who Does It | Why |\n|-----------|-------------|-----|\n| Run `tsc --noEmit` | **Worker agent** | You cannot run Bash |\n| Read source files | **Worker agent** | You can only read `.swarm/**` |\n| Read task reports | **Review agents** | Not you - zero context waste |\n| Implement a feature | **Worker agent** | Heavy work, their context |\n| Read/write plan files | **Orchestrator** | `.swarm/**` only |\n| Track agent IDs → paths | **Orchestrator** | Map task IDs ↔ report paths |\n\n### DO (Orchestrator)\n- Spawn workers with `run_in_background: true`\n- Include report path in every worker prompt\n- Store mapping: taskId → reportPath (NOT output content)\n- Use `TaskOutput(block: true)` at end of wave only\n- Ignore TaskOutput content - files have details\n- Spawn review agents to read reports\n\n### DON'T (Orchestrator)\n- Read source files (not in allowed-tools)\n- Read worker output content (waste of context)\n- Poll with `block: false` (wastes context)\n- Store any worker details in your context\n- Read report files yourself (reviewers do this)\n\n### Report Structure (For Review Agents)\n\nWorkers write detailed reports to structured paths. **You never read these - review agents do.**\n\n**Report paths**:\n```\n.swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md\n.swarm/reports/{plan-slug}/wave-{N}/wave-review.md  (ultrathink review)\n```\n\n**Review agent reads reports, you read ONLY the review summary**:\n```\n# Review agent output (what you receive):\nHIGH|fix-imports|.swarm/reports/{slug}/wave-1/wave-review.md\n\n# You DON'T read the review file - just act on priority\nif HIGH → spawn fixers\nif MED → note in plan, continue\nif LOW → continue\n```\n\n## Error Recovery\n\n| Situation | Action |\n|-----------|--------|\n| Worker timeout | Log, mark failed, escalate |\n| Worker crash | Log, mark failed, escalate |\n| Audit finds issues | Spawn fixers for trivial, pause for complex |\n| All retries exhausted | Pause, present to user |\n| User wants to abort | Update plan state to `paused`, summarize progress |\n| Dependency failure | Skip dependent tasks, continue others, notify user |\n\n## Plan File Updates\n\nUpdate the plan file at these moments:\n\n1. After spawning Architect (state: planning)\n2. Before starting each wave (wave status: in_progress)\n3. After each task completes (task checkbox)\n4. After audit completes (audit section)\n5. At checkpoints (checkpoint checkbox)\n6. On any failure (execution log)\n7. After wave completes (wave status: completed)\n8. At swarm completion (state: completed)\n\nAlways use atomic writes - read, modify, write complete file.\n\n## TaskOutput Reference (Zero-Polling)\n\nThe ONLY tool for agent completion - use `block: true` exclusively.\n\n### Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `task_id` | string | required | The agent ID from Task with `run_in_background: true` |\n| `block` | boolean | true | ALWAYS use true - no polling |\n| `timeout` | number | 30000 | Max ms to wait (up to 600000) |\n\n### Return Values\n\n```typescript\n{\n  status: \"completed\" | \"failed\" | \"timeout\",\n  output?: string  // IGNORE THIS - all details in files\n}\n```\n\n### Usage (ONLY Pattern)\n\n```typescript\n// End of wave - wait for all workers\nTaskOutput({ task_id: lastAgentId, block: true })\n// IGNORE output content - workers wrote to report files\n\n// Review completion\nTaskOutput({ task_id: reviewId, block: true })\n// Read ONLY the priority from output: \"HIGH|action|path\"\n```\n\n**NEVER use `block: false` - it wastes context on partial checks.**\n",
        "swarm/skills/swarm/references/plan-format.md": "# Swarm Plan Format\n\nThis document defines the structure for swarm execution plans stored in `.swarm/{task-slug}.md`.\n\n## File Structure\n\n```markdown\n# Swarm: {Task Name}\n\n## Status\n- **State**: planning | executing | paused | completed | failed\n- **Current Wave**: {N} of {total}\n- **Started**: {ISO date}\n- **Last Updated**: {ISO date}\n\n## Goal\n{Brief description of what this swarm accomplishes}\n\n## Checkpoints\nUser-confirmed pause points:\n- [ ] After Wave {N}: {reason}\n- [x] After Wave {M}: {completed}\n\n---\n\n## Wave 1: {Wave Name}\n**Status**: pending | in_progress | completed | failed\n**Depends on**: - (none for first wave)\n\n| ID | Task | Model | Status | Deps | Description |\n|----|------|-------|--------|------|-------------|\n| 1.1 | {name} | haiku | [ ] | - | {what to do} |\n| 1.2 | {name} | opus | [ ] | 1.1 | {what to do} |\n\n### Wave 1 Review (MANDATORY)\n- [ ] AI Review: swarm-reviewer-ultrathink\n- [ ] Priority: pending | LOW | MED | HIGH\n- [ ] Report: `.swarm/reports/{slug}/wave-1/wave-review.md`\n- [ ] Issues: {count} HIGH, {count} MED, {count} LOW\n\n---\n\n## Wave 2: {Wave Name}\n**Status**: pending\n**Depends on**: Wave 1\n\n| ID | Task | Model | Status | Deps | Description |\n|----|------|-------|--------|------|-------------|\n| 2.1 | {name} | haiku | [ ] | 1.2 | {what to do} |\n\n### Wave 2 Review (MANDATORY)\n- [ ] AI Review: swarm-reviewer-ultrathink\n- [ ] Priority: pending | LOW | MED | HIGH\n- [ ] Report: `.swarm/reports/{slug}/wave-2/wave-review.md`\n- [ ] Issues: {count} HIGH, {count} MED, {count} LOW\n\n...\n\n---\n\n## Execution Log\n\n### {ISO timestamp}\n**Wave**: 1\n**Action**: Started task 1.1\n**Agent**: worker-haiku\n**Result**: success | failed | escalated\n\n### {ISO timestamp}\n**Wave**: 1\n**Action**: Audit completed\n**Issues**: 3 style, 1 type error\n**Auto-fixed**: 3, **Needs review**: 1\n\n---\n\n## Files Modified\n- `path/to/file.ts` - Wave 1, Task 1.1\n- `path/to/other.ts` - Wave 1, Task 1.2\n\n## Notes\n{Any relevant context, decisions, or issues for future reference}\n```\n\n## Field Definitions\n\n### Status Values\n\n| Field | Values | Meaning |\n|-------|--------|---------|\n| **State** | `planning` | Architect is generating/refining plan |\n| | `executing` | Workers are running tasks |\n| | `paused` | Waiting for user at checkpoint |\n| | `completed` | All waves done successfully |\n| | `failed` | Unrecoverable error, needs intervention |\n| **Wave Status** | `pending` | Not started |\n| | `in_progress` | Workers executing |\n| | `completed` | All tasks done + audit passed |\n| | `failed` | Task failed after escalation |\n| **Task Status** | `[ ]` | Pending |\n| | `[~]` | In progress |\n| | `[x]` | Completed |\n| | `[!]` | Failed |\n| | `[^]` | Escalated to higher model |\n\n### Model Values\n\n| Model | Use For |\n|-------|---------|\n| `haiku` | Simple, mechanical tasks (deletions, renames, config changes) |\n| `opus` | Standard implementation, integration, moderate complexity |\n| `opus-ultrathink` | Complex reasoning, architecture decisions, tricky bugs |\n\n### Dependencies\n\n- `-` = no dependencies\n- `1.1` = depends on task 1.1\n- `1.1, 1.2` = depends on multiple tasks\n- `Wave 1` = depends on entire wave (for wave-level deps)\n\n## Minimal Template\n\nFor simple swarms, use this minimal format:\n\n```markdown\n# Swarm: {Task Name}\n\n## Status\n- **State**: planning\n\n## Goal\n{Description}\n\n---\n\n## Wave 1: {Name}\n\n| ID | Task | Model | Status | Description |\n|----|------|-------|--------|-------------|\n| 1.1 | {name} | haiku | [ ] | {what} |\n\n### Wave 1 Review (MANDATORY)\n- [ ] AI Review: swarm-reviewer-ultrathink\n- [ ] Priority: pending\n- [ ] Report: `.swarm/reports/{slug}/wave-1/wave-review.md`\n\n---\n\n## Execution Log\n(auto-populated during execution)\n```\n\n## CRITICAL: Architect Instructions\n\n**EVERY wave MUST include a Review section.** This is NON-NEGOTIABLE.\n\nWhen creating a plan, the Architect MUST:\n\n1. **Add Review section to EVERY wave** - no exceptions\n2. **Use exact format**:\n   ```markdown\n   ### Wave {N} Review (MANDATORY)\n   - [ ] AI Review: swarm-reviewer-ultrathink\n   - [ ] Priority: pending\n   - [ ] Report: `.swarm/reports/{slug}/wave-{N}/wave-review.md`\n   ```\n3. **Never skip reviews** - even for single-task waves\n4. **Plan assumes review** - task estimates don't include review time\n\n**Why this matters**:\n- Orchestrator spawns `swarm-reviewer-ultrathink` after EVERY wave\n- Review catches cross-cutting issues before they propagate\n- HIGH priority issues get fixed immediately, not at end of swarm\n- MED/LOW issues are noted but don't block progress\n\n## Adaptive Extensions\n\nThe plan format is adaptive. Add sections as needed:\n\n- **Architecture Diagram**: ASCII art for complex systems\n- **Decision Log**: Record of choices made during planning\n- **Risk Register**: Known risks and mitigations\n- **Rollback Plan**: How to undo if things go wrong\n- **External Dependencies**: APIs, services, credentials needed\n\n## Plan File Naming\n\n```\n.swarm/{descriptive-task-summary}-{status}.md\n```\n\n**Format**:\n- `{descriptive-task-summary}` = 10-20 words in kebab-case describing what the plan does\n- `{status}` = `inprogress` | `paused` | `completed`\n\n**Examples**:\n```\n.swarm/check-and-fix-jsdoc-headers-on-all-staged-unstaged-typescript-files-inprogress.md\n.swarm/refactor-auth-service-to-use-new-token-validation-pattern-paused.md\n.swarm/add-recharts-analytics-dashboard-to-admin-panel-with-weekly-stats-completed.md\n.swarm/fix-typescript-strict-mode-errors-in-domain-services-layer-inprogress.md\n```\n\n**Naming rules**:\n- Lowercase kebab-case\n- 10-20 words that clearly describe the task scope\n- Status suffix always present\n- No dates in filename (use metadata inside file)\n\n**Why this format**:\n- **Descriptive names** → know what plan does without opening file\n- **Status suffix** → `Glob(\"*-inprogress.md\")` instantly filters active plans\n- **Completed plans** → easily ignored when searching for duplicates\n- **No dates** → task description is more useful than timestamp\n\n**Status transitions**:\n```\n{name}-inprogress.md  →  {name}-paused.md      (user interrupts)\n{name}-inprogress.md  →  {name}-completed.md   (all waves done)\n{name}-paused.md      →  {name}-inprogress.md  (user resumes)\n```\n\n## Orchestrator Rules\n\n1. **Only orchestrator writes to plan file** - workers report back, orchestrator updates\n2. **Update after each significant event** - task completion, audit results, failures\n3. **Execution log is append-only** - never delete entries, only add\n4. **Keep Files Modified section current** - for quick impact assessment\n\n## Report Directory Structure\n\nReports are organized hierarchically per swarm plan and wave:\n\n```\n.swarm/\n├── {plan-slug}-{status}.md              # Plan file\n├── reports/\n│   ├── {plan-slug}/                     # Folder per swarm (matches plan name)\n│   │   ├── architect.md                 # Architect's planning report\n│   │   ├── wave-0/                      # Wave 0 (if exists)\n│   │   │   ├── task-0.1.md              # Task reports\n│   │   │   └── wave-review.md           # Wave review (MANDATORY)\n│   │   ├── wave-1/\n│   │   │   ├── task-1.1.md\n│   │   │   ├── task-1.2.md\n│   │   │   ├── task-1.3.md\n│   │   │   └── wave-review.md\n│   │   ├── wave-2/\n│   │   │   └── ...\n│   │   └── summary.md                   # Final swarm summary\n│   └── (legacy files - not migrated)\n├── refs/\n│   ├── {plan-slug}/                     # Reference docs per swarm\n│   │   ├── architecture.md              # Architecture decisions\n│   │   ├── research.md                  # Research findings\n│   │   └── {topic}/                     # Subdirectory for complex topics\n│   │       ├── overview.md\n│   │       └── details.md\n│   └── (legacy files - not migrated)\n└── ...\n```\n\n### Path Patterns\n\n| Content Type | Path Pattern |\n|--------------|--------------|\n| **Reports** | |\n| Architect | `.swarm/reports/{plan-slug}/architect.md` |\n| Task | `.swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md` |\n| Wave Review | `.swarm/reports/{plan-slug}/wave-{N}/wave-review.md` |\n| Final Summary | `.swarm/reports/{plan-slug}/summary.md` |\n| **Reference Docs** | |\n| Architecture | `.swarm/refs/{plan-slug}/architecture.md` |\n| Research | `.swarm/refs/{plan-slug}/research.md` |\n| Topic subfolder | `.swarm/refs/{plan-slug}/{topic}/*.md` |\n\n### Naming Conventions\n\n- `{plan-slug}` = same as plan filename without status suffix\n  - Plan: `fix-auth-service-tokens-inprogress.md`\n  - Reports folder: `reports/fix-auth-service-tokens/`\n- Task IDs match plan: task `2.3` → `wave-2/task-2.3.md`\n- All lowercase kebab-case\n\n### Worker Report Instructions\n\nWorkers MUST write reports to the correct path:\n\n```markdown\nWrite(\".swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md\", \"\"\"\n# Task {ID} Report\n\n## Status: success | failed | partial\n\n## Changes Made\n- file1.ts: description\n- file2.ts: description\n\n## Technical Notes\n{implementation details}\n\"\"\")\n```\n\n### Benefits\n\n- **Discoverability**: `Glob(\"reports/{plan-slug}/**\")` finds all reports for a swarm\n- **Context**: Reports grouped by wave show execution progression\n- **Cleanup**: Delete entire `reports/{plan-slug}/` folder when archiving\n- **Audit trail**: Wave-level audit reports adjacent to task reports\n",
        "swarm/skills/swarm/references/worker-protocol.md": "# Worker Protocol\n\nYou are a Swarm Worker agent. Your job is to execute a single, well-defined task and report results back to the orchestrator.\n\n## Your Mission\n\nComplete the assigned task:\n- Follow the description exactly\n- Respect project conventions\n- Report success or failure clearly\n- Don't exceed your scope\n\n## Input You Receive\n\nFrom orchestrator:\n- **Task ID**: e.g., `2.3`\n- **Task description**: What to do, which files, expected outcome\n- **Context**: Relevant background, dependencies completed\n- **Constraints**: Project conventions, patterns to follow\n\n## Output You Produce\n\n### 1. Write Detailed Report to File\n\nFor any substantial findings, write them to the **structured report path**:\n\n**Path pattern**: `.swarm/reports/{plan-slug}/wave-{N}/task-{ID}.md`\n\nWhere:\n- `{plan-slug}` = plan filename without status (provided in your task prompt)\n- `{N}` = wave number (from your task ID, e.g., task 2.3 → wave-2)\n- `{ID}` = full task ID (e.g., 2.3)\n\n**Example**: Task 2.3 for plan `fix-auth-service-tokens-inprogress.md`:\n```\n.swarm/reports/fix-auth-service-tokens/wave-2/task-2.3.md\n```\n\n**Report content**:\n```markdown\n# Task {ID} Report\n\n## Status: success | failed | partial\n\n## Analysis\n{detailed findings, code snippets, error logs}\n\n## Changes Made\n{detailed explanation of each change}\n\n## Technical Notes\n{implementation details, edge cases, considerations}\n```\n\nThis file persists for:\n- Orchestrator to read on-demand if needed\n- Auditors to review\n- Resume scenarios\n- Future reference\n\n### 2. Return MINIMAL Summary to Orchestrator\n\n**CRITICAL: Context conservation is paramount.** Your final message MUST be under 100 characters:\n\n```\n{ID}|{success|failed|partial}|{report-path}\n```\n\n**Example**:\n```\n2.3|success|.swarm/reports/fix-auth/wave-2/task-2.3.md\n```\n\n**That's it.** No explanations, no file lists, no summaries. The orchestrator:\n- Does NOT read your output by default\n- Does NOT poll for your status\n- Only checks completion at end of wave\n- Reads report file ONLY if review requires it\n\n**Why ultra-minimal?**\n- Orchestrator context stays lean (~5-10k for coordination only)\n- Zero context waste on worker details\n- All information persists in report files\n- Review agents read reports directly, not orchestrator\n\n## Execution Rules\n\n### DO:\n- Read files before modifying\n- Follow existing patterns in the codebase\n- Make minimal, focused changes\n- Use project conventions (from CLAUDE.md, Constitution)\n- Report accurately (don't claim success if uncertain)\n\n### DON'T:\n- Modify files outside your task scope\n- Add \"improvements\" not in the task description\n- Create new files unless explicitly instructed\n- Make assumptions about unclear requirements (report as partial)\n- Skip steps to save time\n\n## Task Execution Flow\n\n```\n1. Read task description carefully\n2. Identify files to modify\n3. Read those files (understand current state)\n4. Plan the minimal changes needed\n5. Make changes using Edit/Write tools\n6. Verify changes compile (if applicable)\n7. Report results\n```\n\n## Handling Uncertainty\n\nIf you're unsure about something:\n\n1. **Check the task description** - is it actually unclear?\n2. **Check context provided** - was it answered there?\n3. **Check project conventions** - is there a standard approach?\n4. **If still unclear**: Report as `partial` with specific questions\n\n```markdown\n**Status**: partial\n\n**Completed**: {what you did accomplish}\n\n**Blocked on**:\n- {specific question 1}\n- {specific question 2}\n\n**Recommendation**: {what you'd do if you had to guess}\n```\n\n## Error Handling\n\nIf you encounter an error:\n\n1. **Don't panic** - errors are expected\n2. **Try once to fix** - if it's obvious\n3. **Report clearly** if you can't resolve\n\n```markdown\n**Status**: failed\n\n**Error**: {what went wrong}\n\n**Attempted Fix**: {what you tried, if anything}\n\n**Root Cause**: {your assessment}\n\n**Recommendation**: {how to resolve, or \"escalate to opus\"}\n```\n\n## Scope Boundaries\n\nYour task has explicit boundaries. Stay within them.\n\n**In scope**: Exactly what the task description says\n**Out of scope**: Everything else\n\nExamples:\n- Task says \"add field X to schema\" → Don't also refactor the schema\n- Task says \"fix bug in function Y\" → Don't also improve Y's performance\n- Task says \"create component Z\" → Don't also add it to the parent\n\nIf you notice something that SHOULD be fixed but is out of scope, mention it in notes:\n\n```markdown\n**Notes for Next Tasks**:\n- Noticed `oldFunction()` is deprecated, consider updating in future task\n```\n\n## Project Convention Compliance\n\nAlways check for and follow:\n\n1. **File headers** - Use project's standard header format\n2. **Naming conventions** - Match existing patterns\n3. **Code style** - Match existing formatting\n4. **Type patterns** - Follow project's type idioms\n5. **Import ordering** - Match existing files\n\nWhen in doubt, look at similar files in the codebase.\n\n## Output Examples\n\nFor plan `fix-auth-service-tokens-inprogress.md`:\n\n### Success\n```\n2.3|success|.swarm/reports/fix-auth-service-tokens/wave-2/task-2.3.md\n```\n\n### Failed\n```\n3.1|failed|.swarm/reports/fix-auth-service-tokens/wave-3/task-3.1.md\n```\n\n### Partial\n```\n1.4|partial|.swarm/reports/fix-auth-service-tokens/wave-1/task-1.4.md\n```\n\n**All details go in the report file. Orchestrator sees ONLY the pipe-delimited status.**\n\n## Performance Tips\n\n1. **Read first, edit second** - Understand before changing\n2. **Use Edit over Write** - Preserve unchanged content\n3. **Batch related changes** - One file, one edit session\n4. **Don't over-verify** - Trust the auditors to catch issues\n"
      },
      "plugins": [
        {
          "name": "docs-researcher",
          "description": "Manage project knowledge base. Use 'init' to setup, or provide a topic to research.",
          "source": "./docs-researcher",
          "version": "1.0.2",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add amoscicki/aromatt",
            "/plugin install docs-researcher@amoscicki-plugins"
          ]
        },
        {
          "name": "swarm-orchestrator",
          "description": "Multi-agent parallel task orchestration with wave-based execution, automatic auditing, and model escalation",
          "source": "./swarm",
          "version": "1.0.4",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add amoscicki/aromatt",
            "/plugin install swarm-orchestrator@amoscicki-plugins"
          ]
        },
        {
          "name": "gapi",
          "description": "Google Tag Manager + Analytics Admin APIs CLI - manage GTM containers/tags/triggers and GA properties/data-streams",
          "source": "./gapi",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add amoscicki/aromatt",
            "/plugin install gapi@amoscicki-plugins"
          ]
        }
      ]
    }
  ]
}