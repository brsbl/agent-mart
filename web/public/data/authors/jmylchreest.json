{
  "author": {
    "id": "jmylchreest",
    "display_name": "John Mylchreest",
    "avatar_url": "https://avatars.githubusercontent.com/u/912349?v=4"
  },
  "marketplaces": [
    {
      "name": "aide",
      "version": null,
      "description": "AIDE - AI Development Environment for multi-agent orchestration",
      "repo_full_name": "jmylchreest/aide",
      "repo_url": "https://github.com/jmylchreest/aide",
      "repo_description": null,
      "signals": {
        "stars": 4,
        "forks": 0,
        "pushed_at": "2026-02-20T20:42:06Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"aide\",\n  \"description\": \"AIDE - AI Development Environment for multi-agent orchestration\",\n  \"owner\": {\n    \"name\": \"John Mylchreest\",\n    \"email\": \"john@mylchreest.net\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"aide\",\n      \"description\": \"AI Development Environment - Multi-agent orchestration for Claude Code\",\n      \"version\": \"0.0.34\",\n      \"source\": \"./\",\n      \"category\": \"productivity\",\n      \"tags\": [\"multi-agent\", \"orchestration\", \"automation\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"aide\",\n  \"version\": \"0.0.34\",\n  \"description\": \"AI Development Environment - Multi-agent orchestration for Claude Code\",\n  \"author\": {\n    \"name\": \"John Mylchreest\"\n  },\n  \"homepage\": \"https://github.com/jmylchreest/aide\",\n  \"license\": \"MIT\",\n  \"mcpServers\": {\n    \"aide\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/bin/aide-wrapper.sh\",\n      \"args\": [\"mcp\"],\n      \"env\": {\n        \"AIDE_CODE_WATCH\": \"1\",\n        \"AIDE_CODE_WATCH_DELAY\": \"30s\"\n      }\n    }\n  },\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/session-start.ts\\\"\",\n            \"timeout\": 60\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/skill-injector.ts\\\" 2>/dev/null\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/hud-updater.ts\\\" 2>/dev/null\",\n            \"timeout\": 3\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/comment-checker.ts\\\" 2>/dev/null\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ],\n    \"SubagentStart\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/subagent-tracker.ts\\\" 2>/dev/null\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ],\n    \"SubagentStop\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/subagent-tracker.ts\\\" 2>/dev/null\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/persistence.ts\\\" 2>/dev/null\",\n            \"timeout\": 5\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/session-summary.ts\\\" 2>/dev/null\",\n            \"timeout\": 10\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/agent-cleanup.ts\\\" 2>/dev/null\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/tool-tracker.ts\\\" 2>/dev/null\",\n            \"timeout\": 2\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/write-guard.ts\\\" 2>/dev/null\",\n            \"timeout\": 3\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/pre-tool-enforcer.ts\\\" 2>/dev/null\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/session-end.ts\\\" 2>/dev/null\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx tsx \\\"${CLAUDE_PLUGIN_ROOT}/src/hooks/pre-compact.ts\\\" 2>/dev/null\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "README.md": "# AIDE - AI Development Environment\n\nMulti-agent orchestration, persistent memory, and intelligent workflows for AI coding assistants.\n\nSupports **Claude Code** and **OpenCode** through a shared core with platform-specific adapters.\n\n## Why AIDE?\n\n| Without AIDE                    | With AIDE                          |\n| ------------------------------- | ---------------------------------- |\n| Context lost between sessions   | Memories persist and auto-inject   |\n| Manual task coordination        | Swarm mode with parallel agents    |\n| Repeated setup instructions     | Skills activate by keyword         |\n| No code search                  | Fast symbol search across codebase |\n| Decisions forgotten             | Decisions recorded and enforced    |\n| MCP servers configured per-tool | MCP configs sync across assistants |\n\n## Quick Start\n\n### Claude Code\n\n```bash\n# Add the marketplace\nclaude plugin marketplace add jmylchreest/aide\n\n# Install the plugin\nclaude plugin install aide@aide\n```\n\n### OpenCode\n\n```bash\n# Install the plugin + MCP server\nbunx @jmylchreest/aide-plugin install\n```\n\nThis registers the aide plugin and MCP server in your OpenCode config. Skills become available as `/aide:*` slash commands.\n\n## Installation\n\n### Claude Code - From Marketplace (Recommended)\n\n```bash\n# Step 1: Add the marketplace source\nclaude plugin marketplace add jmylchreest/aide\n\n# Step 2: Install the plugin\nclaude plugin install aide@aide\n```\n\nOr register the marketplace in `~/.claude/settings.json` (or `.claude/settings.json` for project-level) so team members are prompted to install:\n\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"aide\": {\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"jmylchreest/aide\"\n      }\n    }\n  }\n}\n```\n\n### OpenCode - From npm\n\n```bash\nbunx @jmylchreest/aide-plugin install\n```\n\nThis modifies your `opencode.json` (project-level or `~/.config/opencode/opencode.json`) to register:\n\n- The aide plugin (hooks, skill injection, memory)\n- The aide MCP server (code search, state, decisions, messages)\n\n**Check status:**\n\n```bash\nbunx @jmylchreest/aide-plugin status\n```\n\n**Uninstall:**\n\n```bash\nbunx @jmylchreest/aide-plugin uninstall\n```\n\n### From Source (Development)\n\n```bash\ngit clone https://github.com/jmylchreest/aide\ncd aide\n\n# Build the aide binary (requires Go 1.21+)\ncd aide && go build -o ../bin/aide ./cmd/aide && cd ..\n\n# Build TypeScript hooks\nnpm install && npm run build\n\n# Claude Code: use as plugin\nclaude --plugin-dir /path/to/aide\n\n# OpenCode: point plugin at local source\nbunx @jmylchreest/aide-plugin install --plugin-path /path/to/aide\n```\n\n**Binary included:** The `aide` Go binary is automatically downloaded when the plugin is installed (or upgraded). No separate binary installation needed.\n\n## Permissions\n\n### Claude Code\n\nAdd to `~/.claude/settings.json` for smooth operation:\n\n```json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(aide *)\",\n      \"Bash(**/aide *)\",\n      \"Bash(git worktree *)\",\n      \"mcp__plugin_aide_aide__*\"\n    ]\n  }\n}\n```\n\nThis pre-approves:\n\n- All `aide` CLI commands\n- Git worktree operations (for swarm mode)\n- All AIDE MCP tools (memory, code search, state, etc.)\n\n### OpenCode\n\nOpenCode uses its own permission model. Tool enforcement in swarm mode is handled by the aide plugin's `permission.ask` hook, which restricts read-only agents from write tools.\n\n## Quick Examples\n\n### Memory\n\n```\nYou: remember that I prefer vitest for testing\nClaude: Stored preference\n\n# Next session...\nYou: what testing framework should I use?\nClaude: Based on your preferences, you prefer vitest for testing.\n```\n\n### Code Search\n\n```\nYou: find all functions related to authentication\nClaude: [Uses code_search tool]\n\n# Code Search Results\n\n## `authenticateUser` [function]\n**File:** `src/auth/middleware.ts:24`\n**Signature:** `async function authenticateUser(req: Request): Promise<User>`\n\n## `validateToken` [function]\n**File:** `src/auth/jwt.ts:45`\n**Signature:** `function validateToken(token: string): TokenPayload`\n```\n\n### Modes\n\n```\nYou: swarm 3 implement the dashboard\n-> Spawns 3 parallel agents, each with SDLC pipeline (DESIGN->TEST->DEV->VERIFY->DOCS)\n\nYou: ralph fix all the failing tests\n-> Won't stop until all tests pass\n\nYou: design the auth system\n-> Technical spec with interfaces, decisions, and acceptance criteria\n```\n\n## Architecture\n\n### Shared Core with Platform Adapters\n\nAIDE uses a layered architecture where platform-agnostic logic lives in a shared core, and thin adapters map each AI assistant's lifecycle events to core functions.\n\n```\n+------------------------------------------------------------------+\n|  AI Assistant (Claude Code / OpenCode / ...)                     |\n+------------------------------------------------------------------+\n          |                              |\n  +----------------+            +----------------+\n  | Claude Code    |            | OpenCode       |\n  | Hooks          |            | Plugin         |\n  | (src/hooks/)   |            | (src/opencode/)|\n  +----------------+            +----------------+\n          |                              |\n  +--------------------------------------------------+\n  |  Shared Core (src/core/)                         |\n  |  session-init, skill-matcher, tool-tracking,     |\n  |  tool-enforcement, persistence-logic,            |\n  |  session-summary, mcp-sync, write-guard,         |\n  |  comment-checker, ...                            |\n  +--------------------------------------------------+\n          |\n  +--------------------------------------------------+\n  |  aide binary (Go)                                |\n  |  MCP server, BBolt storage, Bleve search,        |\n  |  tree-sitter code indexing, gRPC multiplexing    |\n  +--------------------------------------------------+\n```\n\n### MCP Reads, Hooks Write\n\nAIDE follows a clear separation of concerns:\n\n| Component     | Purpose                                     | Examples                                                    |\n| ------------- | ------------------------------------------- | ----------------------------------------------------------- |\n| **MCP Tools** | Read state, search, inter-agent messaging   | `memory_search`, `code_search`, `state_get`, `message_send` |\n| **Hooks**     | Write state, detect keywords, enforce rules | Session start, keyword detection, tool enforcement          |\n\nThis prevents conflicts - the LLM reads via MCP, hooks update state in response to lifecycle events.\n\n### Cross-Assistant MCP Sync\n\nMCP server configurations are automatically synchronized across assistants. When aide initializes on any platform, it reads MCP configs from Claude Code (`.mcp.json`), OpenCode (`opencode.json`), and the aide canonical format (`.aide/config/mcp.json`), merges them, and writes back. A journal tracks intentional deletions so removed servers aren't re-imported.\n\n### Hooks\n\n| Hook                 | Trigger                   | Purpose                                               |\n| -------------------- | ------------------------- | ----------------------------------------------------- |\n| `SessionStart`       | New conversation          | Initialize state, inject memories                     |\n| `SessionEnd`         | Session closes cleanly    | Cleanup session state, record metrics                 |\n| `UserPromptSubmit`   | User sends message        | Inject matching skills (fuzzy trigger matching)       |\n| `PreToolUse`         | Before tool execution     | Track tools, enforce agent roles, write guard         |\n| `PostToolUse`        | After any tool            | Update HUD, check for AI comment bloat                |\n| `SubagentStart/Stop` | Agent lifecycle           | Track active agents, inject memories                  |\n| `Stop`               | Conversation ends         | Persist state, capture session summary, agent cleanup |\n| `PreCompact`         | Before context compaction | Preserve state snapshot before summarization          |\n\n### MCP Tools\n\n| Tool               | Purpose                            |\n| ------------------ | ---------------------------------- |\n| `memory_search`    | Full-text search memories (Bleve)  |\n| `memory_list`      | List memories by category/tags     |\n| `code_search`      | Search code symbols                |\n| `code_symbols`     | List symbols in a file             |\n| `code_references`  | Find call sites for a symbol       |\n| `code_stats`       | Index statistics                   |\n| `state_get`        | Get session/agent state            |\n| `state_list`       | List all state values              |\n| `decision_get`     | Get latest decision for topic      |\n| `decision_list`    | List all decisions                 |\n| `decision_history` | Full history for a topic           |\n| `message_list`     | List inter-agent messages          |\n| `message_send`     | Send message to agent or broadcast |\n| `message_ack`      | Acknowledge a received message     |\n\n### Quality Guards\n\nAIDE includes automatic quality controls that run via hooks:\n\n- **Write Guard** - Prevents the `Write` tool from overwriting existing files, forcing `Edit` instead to reduce accidental file clobbers\n- **Comment Checker** - Detects excessive AI-generated comments in code output and flags them\n- **Tool Enforcement** - In swarm mode, restricts read-only agents (architect, explorer, researcher) from using write tools\n\n## Platform Comparison\n\n| Feature             | Claude Code             | OpenCode                            |\n| ------------------- | ----------------------- | ----------------------------------- |\n| Memory & decisions  | Full                    | Full                                |\n| Code indexing       | Full                    | Full                                |\n| Skill injection     | Via hooks               | Via system prompt transform         |\n| Swarm mode          | Native (subagent hooks) | Multi-instance workarounds          |\n| HUD / status line   | Native                  | Fallback to `.aide/state/hud.txt`   |\n| Persistence (ralph) | Stop-blocking           | Re-prompting via `session.prompt()` |\n| Subagent lifecycle  | Full hooks              | Session-based tracking              |\n| Write guard         | Full                    | Full                                |\n| MCP sync            | Full                    | Full                                |\n\nSee the [OpenCode adapter docs](adapters/opencode/README.md) for detailed integration notes and multi-instance orchestration patterns.\n\n## Memory System\n\nMemories are organized by **category** (`learning`, `decision`, `session`, `pattern`, `gotcha`, `discovery`, `blocker`, `issue`) and **tags**.\n\n### Tagging and Scoping\n\nTags control when and where memories are injected. The key scoping tags:\n\n| Tag              | Scope                      | Behavior                                                                |\n| ---------------- | -------------------------- | ----------------------------------------------------------------------- |\n| `scope:global`   | All projects, all sessions | Injected at every session start and subagent spawn, across all projects |\n| `project:<name>` | Single project             | Injected only when working in the named project                         |\n| `session:<id>`   | Single session             | Groups memories from the same session for recent-session summaries      |\n\nAt session start, aide fetches:\n\n1. All memories tagged `scope:global` (your cross-project preferences and patterns)\n2. All memories tagged `project:<current-project>` (project-specific context)\n3. Recent session groups (memories sharing a `session:*` tag within the current project)\n\nMemories without scope tags are still searchable via `memory_search` but won't be auto-injected.\n\n**Storing:** Use natural language (\"remember this...\") or `/aide:memorise`\n\n**Recalling:** Ask questions (\"what did we decide...\") or `/aide:recall`\n\n**Search:** Full-text with fuzzy matching, typo tolerance, and prefix search.\n\n### Automatic Injection\n\nMemories are automatically injected into context at specific lifecycle events:\n\n| Event              | What Gets Injected                                                             |\n| ------------------ | ------------------------------------------------------------------------------ |\n| Session Start      | Global memories, project memories, project decisions, recent session summaries |\n| Subagent Spawn     | Global memories, project memories, project decisions                           |\n| Context Compaction | State snapshot to preserve across summarization                                |\n\n### Automatic Capture\n\nSession summaries are automatically captured when a session ends with meaningful activity (files modified, tools used, or git commits made).\n\n### Storing Memories\n\nUse the `/aide:memorise` skill or the CLI directly:\n\n```bash\naide memory add --category=learning --tags=testing,vitest \"User prefers vitest over jest for testing\"\n```\n\n**Valid categories:** `learning`, `decision`, `session`, `pattern`, `gotcha`, `discovery`, `blocker`, `issue`\n\n### Decision System\n\nDecisions are a specialized memory type for architectural choices that need to be enforced.\n\n**Storage:**\n\n```bash\naide decision set \"auth-strategy\" \"JWT with refresh tokens\" --rationale=\"Stateless, mobile-friendly\"\n```\n\n**Retrieval:**\n\n```bash\naide decision get \"auth-strategy\"    # Latest decision\naide decision list                   # All decisions\naide decision history \"auth-strategy\" # Full history\n```\n\n**Superseding:** When a new decision is set for an existing topic, it supersedes the old one. The history is preserved, but only the latest decision is injected into context.\n\n**Injection:** All current project decisions are injected at session start and subagent spawn, ensuring all agents respect architectural choices.\n\n## Code Indexing\n\nFast symbol search using [tree-sitter](https://tree-sitter.github.io/). Supports TypeScript, JavaScript, Go, Python, Rust, and many more.\n\n```bash\naide code index              # Index codebase\naide code search \"getUser\"   # Search symbols\naide code symbols src/auth.ts  # List file symbols\n```\n\n**File watching:** Set `AIDE_CODE_WATCH=1` for auto-reindexing on file changes.\n\n## Swarm Mode\n\nParallel agents with SDLC pipeline per story, shared memory, and git worktree isolation.\n\n### Architecture\n\n```\n+--------------------------------------------------------------------------+\n|  ORCHESTRATOR                                                            |\n|  1. Decompose work into stories                                          |\n|  2. Create worktree per story                                            |\n|  3. Spawn story agent per worktree                                       |\n|  4. Monitor progress                                                     |\n+--------------------------------------------------------------------------+\n                              |\n       +----------------------+----------------------+\n       v                      v                      v\n+-----------------+   +-----------------+   +-----------------+\n| Story A Agent   |   | Story B Agent   |   | Story C Agent   |\n| (worktree-a)    |   | (worktree-b)    |   | (worktree-c)    |\n+-----------------+   +-----------------+   +-----------------+\n| SDLC Pipeline:  |   | SDLC Pipeline:  |   | SDLC Pipeline:  |\n| [DESIGN]        |   | [DESIGN]        |   | [DESIGN]        |\n| [TEST]          |   | [TEST]          |   | [TEST]          |\n| [DEV]           |   | [DEV]           |   | [DEV]           |\n| [VERIFY]        |   | [VERIFY]        |   | [VERIFY]        |\n| [DOCS]          |   | [DOCS]          |   | [DOCS]          |\n+-----------------+   +-----------------+   +-----------------+\n```\n\n### SDLC Stages\n\nEach story agent executes these stages in order:\n\n| Stage  | Skill             | Purpose                                         |\n| ------ | ----------------- | ----------------------------------------------- |\n| DESIGN | `/aide:design`    | Technical spec, interfaces, acceptance criteria |\n| TEST   | `/aide:test`      | Write failing tests (TDD)                       |\n| DEV    | `/aide:implement` | Make tests pass                                 |\n| VERIFY | `/aide:verify`    | Full QA validation                              |\n| DOCS   | `/aide:docs`      | Update documentation                            |\n\n### Activation\n\n```\nswarm 3                              # 3 story agents (SDLC mode)\nswarm stories \"Auth\" \"Payments\"      # Named stories\nswarm 2 --flat                       # Flat task mode (legacy)\n```\n\n### Workflow\n\n1. **Plan** (optional) - Use `/aide:plan-swarm` to decompose work into validated stories\n2. **Decompose** - Break work into independent stories\n3. **Create worktrees** - Each story gets isolated `feat/<story>` branch\n4. **Spawn agents** - Each agent manages its own SDLC pipeline\n5. **Track progress** - Monitor via tasks and messages\n6. **Merge** - Use `/aide:worktree-resolve` when all stories complete\n\n### Coordination\n\nAgents share state via:\n\n- **Decisions** - `aide decision set/get` for architectural choices\n- **Memory** - `aide memory add` for discoveries and learnings\n- **Messages** - `aide message send` for direct inter-agent communication\n\n### Git Worktree Management\n\n```bash\n# Worktrees created automatically as:\n.aide/worktrees/story-<name>/\n# On branch: feat/story-<name>\n```\n\n### Resolving Worktrees\n\nUse `/aide:worktree-resolve` to merge branches back to main, or manually:\n\n```bash\ngit worktree list                    # List worktrees\ngit merge feat/story-auth            # Merge each branch\ngit worktree remove .aide/worktrees/story-auth  # Cleanup\n```\n\n## Skills\n\nSkills are markdown files that inject context when triggered by keywords. Trigger matching uses fuzzy matching with Levenshtein distance for typo tolerance.\n\n### Built-in Skills\n\n| Skill                | Example Prompt                    | What Happens                                                    |\n| -------------------- | --------------------------------- | --------------------------------------------------------------- |\n| **swarm**            | `swarm 3 implement dashboard`     | Spawns N parallel agents with SDLC pipeline per story           |\n| **plan-swarm**       | `plan the dashboard work`         | Decomposes work into validated stories for swarm execution      |\n| **decide**           | `help me decide on auth strategy` | Formal decision-making interview, records architectural choices |\n| **design**           | `design the auth system`          | Technical spec with interfaces, decisions, acceptance criteria  |\n| **test**             | `write tests for auth`            | Creates test suite with coverage verification                   |\n| **implement**        | `implement the feature`           | TDD implementation - make failing tests pass                    |\n| **verify**           | `verify the implementation`       | Full QA: tests, lint, types, debug artifact check               |\n| **docs**             | `update the documentation`        | Updates docs to match implementation                            |\n| **ralph**            | `ralph fix all failing tests`     | Won't stop until verified complete                              |\n| **build-fix**        | `fix the build errors`            | Iteratively fixes build/lint/type errors until clean            |\n| **debug**            | `debug why login fails`           | Systematic debugging with hypothesis testing                    |\n| **perf**             | `optimize the API`                | Performance profiling and optimization workflow                 |\n| **review**           | `review this PR`                  | Security-focused code review                                    |\n| **code-search**      | `find all auth functions`         | Search code symbols and find call sites                         |\n| **memorise**         | `remember I prefer vitest`        | Stores info for future sessions                                 |\n| **recall**           | `what testing framework?`         | Searches memories and decisions                                 |\n| **git**              | `help with git rebase`            | Expert git operations                                           |\n| **worktree-resolve** | `merge the swarm branches`        | Intelligently merges worktrees with conflict resolution         |\n\n### Skill Discovery\n\nSkills are discovered from multiple locations with priority (highest first):\n\n1. Project-local `.aide/skills/` - Project-specific overrides\n2. Project-local `skills/` - Alternative project location\n3. Plugin-bundled `skills/` - Ships with aide\n4. Global `~/.aide/skills/` - User-wide custom skills\n\n### Custom Skills\n\nCreate `.aide/skills/my-skill.md`:\n\n```markdown\n---\nname: deploy\ntriggers:\n  - deploy\n  - ship it\n---\n\n# Deploy Workflow\n\n1. Run tests: `npm test`\n2. Build: `npm run build`\n3. Deploy: `./scripts/deploy.sh`\n```\n\nSkills are auto-discovered and hot-reloaded.\n\n## CLI Reference\n\nRun `aide --help` for full CLI documentation. Key commands:\n\n```bash\naide memory add/search/list/delete   # Memory management\naide decision set/get/list/history   # Architectural decisions\naide state set/get/list              # Session/agent state\naide message send/list/ack           # Inter-agent messaging\naide code index/search/symbols       # Code indexing\naide session init/cleanup            # Session lifecycle\naide upgrade                         # Self-upgrade binary\n```\n\n## Configuration\n\nKey environment variables:\n\n| Variable                    | Description                                   |\n| --------------------------- | --------------------------------------------- |\n| `AIDE_DEBUG=1`              | Enable debug logging (logs to `.aide/_logs/`) |\n| `AIDE_CODE_WATCH=1`         | Enable file watching for auto-reindex         |\n| `AIDE_CODE_WATCH_DELAY=30s` | Delay before re-indexing after file changes   |\n| `AIDE_MEMORY_INJECT=0`      | Disable memory injection                      |\n\n## Status Line (Claude Code)\n\nAIDE can display session info in Claude Code's status line, showing mode, duration, task counts, and token usage.\n\n**Setup:** Add to `~/.claude/settings.json`:\n\n```json\n{\n  \"statusLine\": {\n    \"type\": \"command\",\n    \"command\": \"bash ~/.claude/bin/aide-hud.sh\"\n  }\n}\n```\n\nThe wrapper script (`~/.claude/bin/aide-hud.sh`) is automatically installed on first session start after plugin installation.\n\n**Example output:**\n\n```\n[aide(0.0.32)] mode:idle | 12m | tasks:done(6) wip(0) todo(0) | 5h:115K ~<1m\n```\n\nShows: version, current mode, session duration, task status, 5-hour token usage, and estimated time to rate limit.\n\n## Storage\n\nAll data stored in `.aide/` (per-project). A `.aide/.gitignore` is automatically created on first session.\n\n**Explicitly gitignored** (machine-local runtime data):\n\n| Path                           | Purpose                                                     |\n| ------------------------------ | ----------------------------------------------------------- |\n| `memory/`                      | BBolt database + Bleve search index (binary, non-mergeable) |\n| `state/`                       | Runtime state (HUD output, session info, worktree tracking) |\n| `bin/`                         | Downloaded aide binary                                      |\n| `code/`                        | Tree-sitter code symbol index                               |\n| `worktrees/`                   | Git worktree directories for swarm mode                     |\n| `_logs/`                       | Debug logs (when `AIDE_DEBUG=1`)                            |\n| `config/mcp.json`              | Canonical MCP server config (machine-specific sync state)   |\n| `config/mcp-sync.journal.json` | Tracks intentional MCP server removals for sync             |\n\n**Explicitly un-ignored** (`!shared/` in `.gitignore`):\n\n| Path                | Purpose                                               |\n| ------------------- | ----------------------------------------------------- |\n| `shared/decisions/` | Exported decisions as markdown (one file per topic)   |\n| `shared/memories/`  | Exported memories as markdown (one file per category) |\n\nThe `shared/` directory is created when you run `aide share export`. Files use YAML frontmatter + markdown body, so they work as LLM context even without aide installed. This is the recommended way to share architectural decisions and project learnings via git.\n\n**Not gitignored** (tracked by default, committing is optional):\n\n| Path               | Purpose                                                     | Notes                                                                  |\n| ------------------ | ----------------------------------------------------------- | ---------------------------------------------------------------------- |\n| `config/aide.json` | Project-level aide config (e.g. auto-import settings)       | Only useful if you've customized settings                              |\n| `skills/`          | Project-specific custom skills (highest discovery priority) | Commit if you add custom skills; they are auto-discovered and injected |\n\nUse `aide share export` to populate `shared/` and `aide share import` to load it into the local store (or set `AIDE_SHARE_AUTO_IMPORT=1` for automatic import on session start).\n\n```bash\naide share export                    # Export decisions + memories to .aide/shared/\naide share export --decisions        # Decisions only\naide share import                    # Import from .aide/shared/\naide share import --dry-run          # Preview what would be imported\n```\n\nThe `aide` binary is bundled with the plugin and automatically downloaded on install/upgrade.\n\n## Troubleshooting\n\n```bash\n# Check if binary exists and works\naide version\n\n# Claude Code: reinstall plugin\nclaude plugin uninstall aide\nclaude plugin install aide@aide\n\n# OpenCode: reinstall\nbunx @jmylchreest/aide-plugin uninstall\nbunx @jmylchreest/aide-plugin install\n\n# Enable debug logging\nAIDE_DEBUG=1 claude    # or AIDE_DEBUG=1 opencode\n\n# Check memories\naide memory list\n\n# Check MCP sync status\ncat .aide/config/mcp.json\n```\n\n## Adding Support for New Assistants\n\nAIDE's adapter architecture makes it straightforward to add support for new AI coding tools. See the [adapters documentation](adapters/README.md) for the template:\n\n1. Create `adapters/<tool>/generate.ts`\n2. Map the tool's lifecycle events to aide core functions\n3. Generate config files for the tool's plugin format\n4. Skills and MCP tools work out of the box\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "aide",
          "description": "AI Development Environment - Multi-agent orchestration for Claude Code",
          "version": "0.0.34",
          "source": "./",
          "category": "productivity",
          "tags": [
            "multi-agent",
            "orchestration",
            "automation"
          ],
          "categories": [
            "automation",
            "multi-agent",
            "orchestration",
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jmylchreest/aide",
            "/plugin install aide@aide"
          ]
        }
      ]
    }
  ]
}