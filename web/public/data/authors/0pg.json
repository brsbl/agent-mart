{
  "author": {
    "id": "0pg",
    "display_name": "opg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/26541672?u=84f19b9bd4b471d8399aa9c65ddce716e8039d97&v=4"
  },
  "marketplaces": [
    {
      "name": "jhk-plugins",
      "version": null,
      "description": "Personal Claude Code plugins collection",
      "repo_full_name": "0pg/cc-marketplace",
      "repo_url": "https://github.com/0pg/cc-marketplace",
      "repo_description": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-18T16:59:49Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"jhk-plugins\",\n  \"description\": \"Personal Claude Code plugins collection\",\n  \"owner\": {\n    \"name\": \"jhk\",\n    \"email\": \"0pg@users.noreply.github.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"orchestrator-guide\",\n      \"description\": \"Multi-agent orchestration framework for complex tasks with 5-element delegation protocol. Use /orchestrator for task coordination, /planner for spec generation, /delegator for delegation prompts.\",\n      \"version\": \"1.6.2\",\n      \"author\": {\n        \"name\": \"jhk\"\n      },\n      \"source\": \"./plugins/orchestrator-guide\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"project-context-store\",\n      \"description\": \"코드 재현에 필요한 컨텍스트를 CLAUDE.md로 자동 문서화. /context-generate로 생성, /context-update로 업데이트, /context-validate로 검증.\",\n      \"version\": \"1.6.1\",\n      \"author\": {\n        \"name\": \"jhk\"\n      },\n      \"source\": \"./plugins/project-context-store\",\n      \"category\": \"documentation\"\n    },\n    {\n      \"name\": \"tdd-dev\",\n      \"description\": \"TDD/ATDD 원칙 가이드. Outside-In TDD로 테스트가 컴포넌트 인터페이스를 정의합니다. /test-design으로 테스트 설계, /tdd-impl로 구현.\",\n      \"version\": \"1.2.1\",\n      \"author\": {\n        \"name\": \"jhk\"\n      },\n      \"source\": \"./plugins/tdd-dev\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"tdd-workflow\",\n      \"description\": \"orchestrator-guide용 TDD 워크플로우 어댑터. Red-Green-Refactor 기반 테스트 주도 개발 워크플로우 제공.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"jhk\"\n      },\n      \"source\": \"./plugins/tdd-workflow\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"claude-md-plugin\",\n      \"description\": \"CLAUDE.md + IMPLEMENTS.md 듀얼 문서 시스템. /decompile로 소스코드에서 CLAUDE.md(WHAT) + IMPLEMENTS.md(HOW) 추출, /compile로 코드 생성, /validate로 문서-코드 일치 검증, /impl으로 요구사항에서 듀얼 문서 생성, /impl-review로 품질 리뷰, /debug로 런타임 버그 3계층 추적 진단, /project-setup으로 빌드/테스트 커맨드 + 코드 컨벤션 자동 감지, /convention-update으로 코드 컨벤션 관리.\",\n      \"version\": \"2.23.0\",\n      \"author\": {\n        \"name\": \"jhk\"\n      },\n      \"source\": \"./plugins/claude-md-plugin\",\n      \"category\": \"documentation\"\n    }\n  ]\n}\n",
        "plugins/orchestrator-guide/README.md": "# orchestrator-guide Plugin\n\nClaude Code Plugin for multi-agent coordination with 5-element delegation protocol.\n\n## Design Principles\n\nThis plugin defines **protocols** (what must happen) while leaving **implementation details** (how) to the model:\n\n| Area | Plugin (What) | Model (How) |\n|------|---------------|-------------|\n| Task Size | \"Must be evaluated\" | Specific criteria |\n| Split Strategy | \"Can be split\" | When/how to split |\n| Agent Selection | \"Role-based\" | Which agent |\n| Verification | \"Must be done\" | Which commands |\n\nThis separation allows the plugin to be **project-agnostic** while providing consistent coordination patterns.\n\n## Plugin Structure\n\n```\norchestrator-guide/\n├── .claude-plugin/\n│   └── plugin.json           # Plugin manifest (official spec)\n├── config/\n│   └── project-config.template.md  # Project-specific config template\n├── skills/                   # Skills (auto-detected by Claude Code)\n│   ├── orchestrator/         # Main orchestration workflow\n│   ├── planner/              # Planning and spec generation\n│   └── delegator/            # Delegation prompt generation\n├── hooks/                    # Hook definitions\n│   ├── hooks.json            # Hook configuration\n│   ├── session-start.sh      # SessionStart hook script\n│   ├── session-start.md      # SessionStart documentation\n│   └── task-continuation.md\n├── agents/                   # Agent pattern documentation\n│   ├── worker.md                 # Worker Agent (Phase delegation)\n│   └── verification-chain.md     # Verification workflow\n└── templates/                # Templates for delegation\n    ├── delegation-prompt.md  # Role-based delegation templates\n    └── arb-template.md       # Agent Result Block format\n```\n\n## Core Interfaces\n\n### 1. 5-Element Delegation Protocol\n\nAll agent delegations must include:\n- **GOAL**: What to achieve (task.md reference)\n- **CONTEXT**: Related files, patterns, background\n- **CONSTRAINTS**: What not to do\n- **SUCCESS**: Verification criteria (project-config reference)\n- **HANDOFF**: Next role or follow-up\n\n### 2. ARB (Agent Result Block)\n\nStandardized agent result reporting format:\n```yaml\n---agent-result---\nstatus: success | partial | blocked | failed\nagent: {agent_name}\ntask_ref: {task_id}\nfiles:\n  created: []\n  modified: []\nverification:\n  tests: pass | fail\n  lint: pass | fail\nissues: []\nfollowup: []\n---end-agent-result---\n```\n\n### 3. Role-Based Agent Selection\n\nAgents are selected by **role**, not by name:\n\n| Role | Purpose |\n|------|---------|\n| **Implementation** | Code writing |\n| **Exploration** | Code analysis |\n| **Review** | Code review |\n\nActual agent names are mapped from project-config or CLAUDE.md.\n\n### 4. Verification Chain\n\nLint → Tests → Code Review\n\nVerification commands are referenced from project-config.\n\n### 5. Task Size Protocol\n\nBefore delegation:\n1. Evaluate task size\n2. Split if necessary (vertical, horizontal, checkpoint)\n3. Handle context compaction recovery\n\n## Project Configuration\n\nTo customize for your project, copy and fill `config/project-config.template.md`:\n\n```yaml\nroles:\n  implementation:\n    backend: backend-impl\n    frontend: frontend-impl\n  review:\n    code: rust-code-reviewer\n\nverification:\n  lint:\n    command: cargo clippy -p {module}\n    flags: \"-- -D warnings\"\n  test:\n    command: cargo test -p {module}\n```\n\nOr define directly in CLAUDE.md.\n\n## Usage\n\nSkills are automatically triggered:\n- `/orchestrator` - Main orchestration workflow\n- `/planner` - Planning and spec generation\n- `/delegator` - Delegation prompt generation\n\nHooks execute automatically:\n- `SessionStart` - Loads context at conversation start, clear, resume, compaction\n\n## Compatibility\n\n### Module Path Detection\n\nThe hook script automatically detects common module patterns:\n- `crates/` (Rust workspaces)\n- `packages/` (Node.js monorepos)\n- `modules/` (Generic)\n- `libs/` (Library structures)\n\n### Task File Location\n\nSupported locations:\n- `spec/task.md` (project root)\n- `{module_pattern}/{module}/spec/task.md` (module-specific)\n",
        "plugins/project-context-store/README.md": "# Project Context Store\n\n프로젝트의 컨텍스트를 자동으로 문서화하여 도메인 이해와 확률적 재현가능성을 보장하는 Claude Code 플러그인입니다.\n\n## 핵심 개념\n\n**확률적 재현가능성**: 코드를 삭제해도 CLAUDE.md만으로 도메인을 파악하여 여러 번 시도 시 동일한 코드를 작성할 수 있는 것\n\n- 기존: 매번 똑같은 코드가 나와야 함 (결정론적)\n- 변경: 여러 번 시도하면 동일한 코드가 나올 수 있을 정도의 정보 (확률적)\n\n## 설치\n\n```bash\n# Claude Code에서 플러그인 설치\n/install-plugin path/to/project-context-store\n```\n\n## 사용법\n\n### 컨텍스트 생성\n\n```\n/context-generate\n```\n\n프로젝트의 소스 코드 디렉토리를 분석하여 각 디렉토리에 CLAUDE.md 파일을 생성합니다.\n\n**동작 방식:**\n1. 소스 코드 디렉토리 자동 탐지\n2. 디렉토리별 도메인 분석\n3. 불명확한 부분은 질문으로 확인\n4. CLAUDE.md 생성\n\n### 컨텍스트 업데이트\n\n```\n/context-update\n```\n\n코드 변경 사항을 감지하고 해당 CLAUDE.md를 업데이트합니다.\n\n### 컨텍스트 검증\n\n```\n/context-validate\n```\n\nCLAUDE.md와 실제 코드의 일치 여부 및 도메인 이해도를 검증합니다.\n\n## CLAUDE.md에 포함되는 정보\n\n| 항목 | 설명 |\n|------|------|\n| Domain Overview | 비즈니스 영역 설명 |\n| Key Concepts | 도메인 용어 정의 (Ubiquitous Language) |\n| Business Rules | 비즈니스 규칙과 근거 (법규, 정책 등) |\n| Domain Constants | 도메인 상수의 의미와 유래 |\n| Design Rationale | 기술 선택의 이유와 대안 검토 |\n| External Integrations | API 스펙, 프로토콜 정보 |\n| Implementation Notes | Tribal Knowledge, 주의사항 |\n\n## 자동 업데이트 알림\n\n코드 변경 시 자동으로 컨텍스트 업데이트 필요 여부를 알려줍니다.\n`/context-update`로 명시적으로 업데이트를 트리거할 수 있습니다.\n\n## 성공 기준\n\n**이 플러그인으로 생성된 CLAUDE.md로 도메인을 파악하여 여러 번 시도 시 동일한 코드를 재작성할 수 있어야 합니다.**\n\n코드에서 직접 읽을 수 없는 \"왜?\"에 대한 답변이 모두 문서화되어야 합니다.\n\n## 라이선스\n\nMIT\n",
        "plugins/tdd-dev/README.md": "# TDD-Dev Plugin\n\nTDD/ATDD 원칙을 가이드하는 Claude Code 플러그인입니다.\n\n## Features\n\n- **Outside-In TDD**: 테스트가 컴포넌트 인터페이스를 정의하는 Top-Down 접근법\n- **Red-Green-Refactor**: 검증된 TDD 사이클 프로토콜\n- **요구사항 검증**: TDD 시작 전 요구사항 충분성 확인\n\n## Installation\n\nClaude Code 설정에서 이 플러그인을 추가하세요.\n\n## Usage\n\n### /tdd-impl\n\nTDD 방식으로 코드를 구현합니다.\n\n```\n/tdd-impl\n```\n\n**자동 트리거:**\n- \"TDD로 구현해줘\"\n- \"테스트 주도 개발\"\n- \"테스트 먼저 작성\"\n\n**워크플로우:**\n1. 요구사항 검증 - 테스트 케이스 도출 가능 여부 확인\n2. 테스트 설계 - Top-Down으로 인터페이스 발견\n3. 코드 구현 - Red-Green-Refactor 사이클 실행\n4. 최종 검증 - 모든 테스트 통과 확인\n\n## Core Principles\n\n### 테스트가 인터페이스를 정의한다\n\n```\nUser Story / Requirement\n         ↓\n    Acceptance Test  ──→ 상위 인터페이스 발견\n         ↓\n    Integration Test ──→ 중간 인터페이스 발견\n         ↓\n    Unit Test        ──→ 하위 인터페이스 발견\n         ↓\n    Implementation\n```\n\n### Red-Green-Refactor\n\n```\n┌─────────┐     ┌─────────┐     ┌──────────┐\n│   RED   │ ──→ │  GREEN  │ ──→ │ REFACTOR │\n│ (실패)  │     │ (통과)  │     │  (개선)  │\n└─────────┘     └─────────┘     └────┬─────┘\n     ↑                               │\n     └───────────────────────────────┘\n```\n\n## Example\n\n```\nUser: 사용자 로그인 기능을 TDD로 구현해줘",
        "plugins/tdd-workflow/README.md": "# TDD Workflow\n\n> orchestrator-guide용 TDD workflow adapter 플러그인\n\n## 개요\n\n이 플러그인은 orchestrator-guide의 Pluggable Workflow로 TDD 워크플로우를 제공합니다.\n\n## 의존성\n\n- **orchestrator-guide**: Workflow Protocol 지원 버전 (1.3.0+)\n- **tdd-dev**: TDD 스킬 제공 (test-design, tdd-impl, test-reviewer)\n\n## 워크플로우\n\n### Phase 1: 테스트 설계\n```\nSkill(\"tdd-dev:test-design\")\n```\n- 요구사항 분석\n- 테스트 케이스 설계 (테스트 레벨별)\n- `.claude/tdd-spec.md` 생성\n\n### Phase 2: TDD 구현\n```\nSkill(\"tdd-dev:tdd-impl\")\n```\n- Red-Green-Refactor 사이클\n- 각 REQ에 대해 테스트 먼저 작성 -> 구현\n\n### 검증\n- 리뷰어: `tdd-dev:test-reviewer`\n- 매핑: REQ -> Test (직접)\n\n## 트리거\n\n다음 키워드로 이 워크플로우가 선택됩니다:\n- \"TDD로 구현해줘\"\n- \"테스트 주도 개발\"\n- \"Red-Green-Refactor로\"\n\n## 설치 및 설정\n\n```bash\n# 1. 플러그인 설치\nclaude plugins install tdd-workflow\n\n# 2. 프로젝트에 워크플로우 등록\n/tdd-workflow:setup\n```\n\n## 사용 예시\n\n### 워크플로우 선택 (2개 이상 등록 시)\n\n```\nUser: \"로그인 기능 구현해줘\"\n\nOrchestrator:\n1. project-config에서 workflows 확인: [default, tdd-workflow]\n2. 2개 이상 -> AskUserQuestion:\n   \"어떤 워크플로우를 사용하시겠습니까?\"\n   - Default (spec+task)\n   - TDD Workflow\n3. 사용자 선택에 따라 진행\n```\n\n### 명시적 워크플로우 요청\n\n```\nUser: \"TDD로 로그인 기능 구현해줘\"\n\nOrchestrator:\n1. \"TDD로\" 키워드 감지 -> tdd-workflow 직접 선택 (질문 없음)\n2. Phase 1: Skill(\"tdd-dev:test-design\") -> tdd-spec.md 생성\n3. Phase 2: Skill(\"tdd-dev:tdd-impl\") -> Red-Green-Refactor 실행\n4. Verification: tdd-dev:test-reviewer -> REQ-Test 매핑 검증\n```\n\n## Convention 플러그인 연동\n\n코드 작성 시 프로젝트에 설치된 Convention 플러그인을 참조합니다:\n\n| 조합 | 결과 |\n|------|------|\n| tdd-workflow + rust-convention | Rust TDD 개발 |\n| tdd-workflow + typescript-convention | TypeScript TDD 개발 |\n| tdd-workflow (단독) | 언어 표준 스타일 적용 |\n\n## 파일 구조\n\n```\ntdd-workflow/\n├── .claude-plugin/\n│   └── plugin.json               # 플러그인 매니페스트\n├── commands/\n│   └── setup.md                  # 워크플로우 등록 커맨드\n├── skills/\n│   └── tdd-orchestration/\n│       ├── SKILL.md              # 워크플로우 정의\n│       └── references/\n│           └── verification-chain.md  # TDD 검증 체인\n└── README.md                     # 이 파일\n```\n\n## Default Workflow와의 차이점\n\n| 구분 | Default Workflow | TDD Workflow |\n|------|------------------|--------------|\n| 명세 파일 | spec.md + task.md | tdd-spec.md |\n| 구현 순서 | 명세 -> 구현 -> 테스트 | 테스트 -> 구현 |\n| 매핑 | REQ -> VERIFY -> Test | REQ -> Test (직접) |\n| 리뷰어 | test-quality-reviewer | test-reviewer |\n",
        "plugins/claude-md-plugin/README.md": "# claude-md-plugin (v2.22.0)\n\n> CLAUDE.md + IMPLEMENTS.md 듀얼 문서 시스템 기반의 문서-코드 동기화 플러그인\n\n## 개요\n\n기존의 \"소스코드 → 문서\" 접근법을 역전시켜 **CLAUDE.md + IMPLEMENTS.md가 소스코드**이고, **소스코드가 바이너리**가 되는 Compile/Decompile 패러다임을 제공합니다.\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    전통적 소프트웨어                          │\n│                                                             │\n│   .h (헤더)  +  .c (소스)  ─── compile ──→  Binary (.exe)   │\n│   Binary (.exe)  ─── decompile ──→  .h + .c                 │\n└─────────────────────────────────────────────────────────────┘\n\n┌─────────────────────────────────────────────────────────────┐\n│                    claude-md-plugin (듀얼 문서 시스템)       │\n│                                                             │\n│   CLAUDE.md (WHAT) + IMPLEMENTS.md (HOW)                    │\n│         │                                                   │\n│         └──── /compile ──→  Source Code (구현)              │\n│                                                             │\n│   Source Code (구현)  ─── /decompile ──→                    │\n│         └──→ CLAUDE.md (WHAT) + IMPLEMENTS.md (HOW)         │\n└─────────────────────────────────────────────────────────────┘\n```\n\n| 전통적 개념 | claude-md-plugin | 역할 |\n|------------|------------------|------|\n| .h (헤더) | CLAUDE.md | **WHAT** - 인터페이스, 스펙 |\n| .c (소스) | IMPLEMENTS.md | **HOW** - 구현 명세 |\n| Binary | Source Code (.ts, .py, ...) | 실행물 |\n| **compile** | CLAUDE.md + IMPLEMENTS.md → Source Code | `/compile` |\n| **decompile** | Source Code → CLAUDE.md + IMPLEMENTS.md | `/decompile` |\n\n## Prerequisites\n\n### Rust Toolchain (필수)\n\n플러그인의 `core/` 디렉토리에 포함된 Rust CLI 바이너리 빌드가 필요합니다.\n\n- **rustc** + **cargo** (edition 2021, Rust 1.56+)\n- 주요 의존성: clap 4.4, serde, walkdir, regex\n\n```bash\n# 빌드\ncd plugins/claude-md-plugin/core && cargo build --release\n```\n\n빌드 결과물: `claude-md-core` CLI 바이너리\n\n## 설치\n\n프로젝트 플러그인으로 포함되어 있으므로 별도의 설치가 필요하지 않습니다.\n`developer-claude-code-plugin` 저장소를 클론하면 자동으로 사용할 수 있습니다.\n\n```bash\ngit clone <repo-url>\ncd developer-claude-code-plugin\n\n# Rust core 빌드\ncd plugins/claude-md-plugin/core && cargo build --release\n```\n\n## 사용법\n\n### Quick Start\n\n| 상황 | 커맨드 | 결과 |\n|------|--------|------|\n| 새 모듈 요구사항 정의 | `/impl \"요구사항\"` | CLAUDE.md + IMPLEMENTS.md |\n| 기존 코드 문서화 | `/decompile` | CLAUDE.md + IMPLEMENTS.md |\n| 명세 기반 코드 생성 | `/compile` | 소스코드 + 테스트 |\n| 문서-코드 일치 확인 | `/validate` | 통합 검증 보고서 |\n\n### 커맨드 상세\n\n#### `/impl` — 요구사항에서 명세 생성\n\n> Aliases: `define`, `requirements`\n\n**언제 사용하나요?**\n- 새 기능을 개발하기 전, 요구사항을 CLAUDE.md 명세로 정리하고 싶을 때\n- 기존 모듈에 새로운 기능을 추가하고 싶을 때\n\n**사용법:**\n```\n/impl \"JWT 토큰을 검증하는 인증 모듈이 필요합니다\"\n```\n\n**실행 결과 예시:**\n```\n=== /impl 완료 ===\n\n생성/업데이트된 파일:\n  ✓ src/auth/CLAUDE.md (WHAT - 스펙)\n  ✓ src/auth/IMPLEMENTS.md (HOW - Planning Section)\n\n스펙 요약:\n  - Purpose: JWT 토큰 검증 및 사용자 인증\n  - Exports: 2개\n  - Behaviors: 3개\n\n검증 결과: 스키마 검증 통과\n\n다음 단계:\n  - /compile로 코드 구현 가능\n  - /validate로 문서-코드 일치 검증 가능\n```\n\n**에러 시 대응:**\n\n| 상황 | 대응 |\n|------|------|\n| 요구사항 불명확 | AskUserQuestion으로 명확화 질문 |\n| 대상 경로 모호 | 후보 목록 제시 후 선택 요청 |\n| 기존 CLAUDE.md와 충돌 | 병합 전략 제안 |\n| 기존 IMPLEMENTS.md와 충돌 | Planning Section만 업데이트 (Implementation Section 유지) |\n\n**다음 단계:** `/compile` → 명세 기반 코드 생성\n\n---\n\n#### `/decompile` — 기존 코드에서 명세 추출\n\n> Aliases: `decom`\n\n**언제 사용하나요?**\n- 레거시 코드를 CLAUDE.md 체계로 편입시키고 싶을 때\n- 기존 프로젝트를 처음 도입할 때 전체 문서화가 필요할 때\n\n**사용법:**\n```\n/decompile\n```\n\n**실행 결과 예시:**\n```\n=== CLAUDE.md + IMPLEMENTS.md 추출 완료 ===\n\n생성된 파일:\n  ✓ src/CLAUDE.md + IMPLEMENTS.md\n  ✓ src/auth/CLAUDE.md + IMPLEMENTS.md\n  ✓ src/api/CLAUDE.md + IMPLEMENTS.md\n\n검증 결과:\n  - CLAUDE.md 스키마: 3/3 통과\n  - IMPLEMENTS.md 스키마: 3/3 통과\n\n다음 단계:\n  - /validate로 문서-코드 일치 검증 가능\n  - /compile로 코드 재생성 가능 (재현성 테스트)\n```\n\n**에러 시 대응:**\n\n| 상황 | 대응 |\n|------|------|\n| CLI 빌드 실패 | 에러 메시지 출력, 실패 반환 |\n| tree-parse 실패 | CLI 에러 메시지 전달 |\n| decompiler 실패 | 해당 디렉토리 스킵, 경고 표시 후 계속 진행 |\n\n**다음 단계:** `/validate` → 추출된 문서와 코드 일치 확인\n\n---\n\n#### `/compile` — 명세에서 소스코드 생성\n\n> Aliases: `gen`, `generate`, `build`\n\n**언제 사용하나요?**\n- `/impl`로 명세를 작성한 뒤, 코드를 자동 생성하고 싶을 때\n- CLAUDE.md를 직접 수정한 뒤, 변경 사항을 코드에 반영하고 싶을 때\n\n**사용법:**\n```bash\n# 기본 사용 (프로젝트 전체)\n/compile\n\n# 특정 경로만 처리\n/compile --path src/auth\n\n# 기존 파일 덮어쓰기\n/compile --conflict overwrite\n```\n\n**옵션:**\n\n| 옵션 | 기본값 | 설명 |\n|------|--------|------|\n| `--path` | `.` | 처리 대상 경로 |\n| `--conflict` | `skip` | 기존 파일과 충돌 시 처리 (`skip` \\| `overwrite`) |\n\n**실행 결과 예시:**\n```\n발견된 CLAUDE.md 파일:\n1. src/auth/CLAUDE.md + IMPLEMENTS.md\n2. src/utils/CLAUDE.md + IMPLEMENTS.md\n\n코드 생성을 시작합니다...\n\n[1/2] src/auth/CLAUDE.md\n✓ CLAUDE.md 파싱 완료 - 함수 2개, 타입 2개, 클래스 1개\n✓ IMPLEMENTS.md Planning Section 로드\n✓ 테스트 생성 (5 test cases)\n✓ 구현 생성\n✓ 테스트 실행: 5 passed\n✓ IMPLEMENTS.md Implementation Section 업데이트\n\n[2/2] src/utils/CLAUDE.md\n✓ CLAUDE.md 파싱 완료 - 함수 3개\n✓ 테스트 생성 (3 test cases)\n✓ 구현 생성\n✓ 테스트 실행: 3 passed\n\n=== 생성 완료 ===\n총 CLAUDE.md: 2개\n생성된 파일: 7개\n테스트: 8 passed, 0 failed\n```\n\n**에러 시 대응:**\n\n| 상황 | 대응 |\n|------|------|\n| IMPLEMENTS.md 없음 | 기본 템플릿으로 자동 생성 후 진행 |\n| 언어 감지 실패 | 사용자에게 언어 선택 질문 |\n| 테스트 실패 | 최대 3회 재시도, 이후 경고 표시 |\n| 파일 충돌 (skip 모드) | 기존 파일 유지, 새 파일만 생성 |\n\n**다음 단계:** `/validate` → 생성된 코드와 문서 일치 확인\n\n---\n\n#### `/validate` — 문서-코드 일치 검증\n\n> Aliases: `check`, `verify`, `lint`\n\n**언제 사용하나요?**\n- `/compile` 후 생성된 코드가 명세와 일치하는지 확인하고 싶을 때\n- `/decompile` 후 추출된 문서가 정확한지 검증하고 싶을 때\n\n**사용법:**\n```bash\n# 기본 사용 (프로젝트 전체)\n/validate\n\n# 특정 경로만 검증\n/validate src/\n```\n\n**검증 항목:**\n\n| 검증기 | 역할 |\n|--------|------|\n| **validator** | Structure, Exports, Dependencies, Behavior 일치 검증 + Export 커버리지 |\n\n**실행 결과 예시:**\n```\nCLAUDE.md 검증 보고서\n=====================\n\n요약\n----\n검증 대상: 3개 디렉토리\n- 양호: 1개\n- 개선 권장: 1개\n- 개선 필요: 1개\n\n상세 결과\n---------\nsrc/auth (양호)\n  Drift: 0개 이슈\n  Export 커버리지: 95% (18/19 예측 성공)\n\nsrc/utils (개선 권장)\n  Drift: 2개 이슈\n    - STALE: formatDate export가 코드에 없음\n    - MISSING: parseNumber export가 문서에 없음\n  Export 커버리지: 78% (14/18 예측 성공)\n```\n\n**상태 기준:**\n\n| 상태 | 조건 |\n|------|------|\n| **양호** | Drift 이슈 0개 AND Export 커버리지 90% 이상 |\n| **개선 권장** | Drift 1-2개 OR Export 커버리지 70-89% |\n| **개선 필요** | Drift 3개 이상 OR Export 커버리지 70% 미만 |\n\n**다음 단계:** 이슈가 발견되면 CLAUDE.md 또는 소스코드를 수정 후 다시 `/validate`\n\n---\n\n#### `/project-setup` — 프로젝트 Convention 초기 설정\n\n**언제 사용하나요?**\n- 새 프로젝트에 Convention 규칙을 설정하고 싶을 때\n- 기존 프로젝트의 코딩 스타일을 분석하여 Convention을 자동 추출하고 싶을 때\n\n**사용법:**\n```bash\n# 자동 탐지\n/project-setup\n\n# 프로젝트 루트 지정\n/project-setup /path/to/project\n```\n\n**실행 결과:**\n- `project_root/CLAUDE.md`에 `## Project Convention` 섹션 추가\n- 각 `module_root/CLAUDE.md`에 `## Code Convention` 섹션 추가\n- `validate-convention` CLI로 검증 수행\n\n---\n\n#### `/convention-update` — Convention 섹션 업데이트\n\n**언제 사용하나요?**\n- 기존 Convention 규칙을 수정하고 싶을 때\n\n**사용법:**\n```bash\n# 대화형\n/convention-update\n\n# 직접 지시\n/convention-update \"들여쓰기를 4 spaces로 변경\"\n```\n\n**실행 결과:** Convention 섹션 업데이트 후 `validate-convention` CLI로 검증 수행\n\n---\n\n### 워크플로우 예시\n\n#### A. 신규 모듈 개발 (처음부터)\n\n```\n/impl \"요구사항\" → /compile → /validate\n```\n\n1. `/impl \"JWT 인증 모듈이 필요합니다\"` — 요구사항을 CLAUDE.md + IMPLEMENTS.md로 변환\n2. `/compile` — 명세 기반 코드 + 테스트 자동 생성\n3. `/validate` — 생성된 코드와 문서 일치 확인\n\n#### B. 레거시 코드 문서화\n\n```\n/decompile → /validate → (드리프트 수정) → /validate\n```\n\n1. `/decompile` — 기존 코드에서 CLAUDE.md + IMPLEMENTS.md 추출\n2. `/validate` — 추출된 문서와 코드 일치 확인\n3. 이슈가 있으면 CLAUDE.md 또는 코드 수정\n4. `/validate` — 수정 후 재검증\n\n#### C. 명세 변경 후 재구현\n\n```\n/impl \"변경된 요구사항\" → /compile --conflict overwrite → /validate\n```\n\n1. `/impl \"기존 인증에 OAuth2 지원 추가\"` — 명세 업데이트\n2. `/compile --conflict overwrite` — 변경된 명세로 코드 재생성 (기존 파일 덮어쓰기)\n3. `/validate` — 변경 사항 검증\n\n## 핵심 개념\n\n### 듀얼 문서 시스템 (CLAUDE.md + IMPLEMENTS.md)\n\n각 디렉토리에 CLAUDE.md와 IMPLEMENTS.md가 1:1로 매핑됩니다.\n\n```\nauth/\n├── CLAUDE.md       ← WHAT (스펙)\n│   ├── Exports: validateToken(token: string): Claims\n│   └── Domain Context: 토큰 만료 7일 (PCI-DSS)\n│\n└── IMPLEMENTS.md   ← HOW (구현 명세)\n    ├── [Planning Section] - /impl이 업데이트\n    │   ├── Dependencies Direction\n    │   ├── Implementation Approach\n    │   └── Technology Choices\n    │\n    └── [Implementation Section] - /compile이 업데이트\n        ├── Algorithm\n        ├── Key Constants\n        ├── Error Handling\n        ├── State Management\n        └── Implementation Guide\n```\n\n**명령어별 업데이트 범위:**\n\n| 명령어 | CLAUDE.md | IMPLEMENTS.md |\n|--------|-----------|---------------|\n| `/impl` | 생성/업데이트 | Planning Section 업데이트 |\n| `/compile` | 읽기 전용 | Implementation Section 업데이트 |\n| `/decompile` | 생성 (전체) | 생성 (전체 - Planning + Implementation) |\n\n### Exports = Interface Catalog\n\nExports 섹션은 다른 모듈이 코드 탐색 없이 인터페이스를 파악할 수 있는 카탈로그입니다.\n\n```\n의존 모듈 참조 시 탐색 순서:\n1. 의존 모듈 CLAUDE.md Exports ← 여기서 인터페이스 확인\n2. 의존 모듈 CLAUDE.md Behavior ← 동작 이해 필요 시\n3. 실제 소스코드 ← 최후 수단 (Exports로 불충분할 때만)\n```\n\n### CLAUDE.md 배치 규칙\n\n다음 조건 중 하나라도 충족하는 디렉토리에 CLAUDE.md가 존재해야 합니다:\n- 1개 이상의 소스코드 파일이 존재\n- 2개 이상의 하위 디렉토리가 존재\n\n### 트리 구조 의존성\n\n```\nproject/CLAUDE.md\n    │\n    ├──► src/CLAUDE.md\n    │        │\n    │        └──► src/auth/CLAUDE.md\n    │\n    └──► tests/CLAUDE.md\n```\n\n- **부모 → 자식**: 참조 가능\n- **자식 → 부모**: 참조 불가\n- **형제 ↔ 형제**: 참조 불가\n\n### Convention 섹션\n\n프로젝트 수준 컨벤션을 CLAUDE.md 내 섹션으로 관리합니다:\n\n- **`## Project Convention`** (project_root CLAUDE.md): 아키텍처/모듈 구조 규칙\n  - 필수: Project Structure, Module Boundaries, Naming Conventions\n- **`## Code Convention`** (module_root CLAUDE.md): 소스코드 수준 규칙\n  - 필수: Language & Runtime, Code Style, Naming Rules\n\n멀티 모듈 프로젝트에서는 module_root가 project_root의 Convention을 override할 수 있습니다.\n\n**컨벤션 우선순위:**\n1. module_root `## Code Convention` → 코드 스타일\n2. module_root `## Project Convention` (optional override)\n3. project_root `## Code Convention` (fallback)\n4. project_root `## Project Convention`\n\n### CLAUDE.md 스키마\n\n```markdown\n# {디렉토리명}\n\n## Purpose\n이 디렉토리의 책임 (1-2문장)\n\n## Domain Context\n코드에서 읽을 수 없는 \"왜?\" - 비즈니스 맥락, 결정 이유\n\n## Structure\n- subdir/: 설명 (상세는 subdir/CLAUDE.md 참조)\n- file.ext: 역할\n\n## Exports\n### Functions\n- `FunctionName(params) ReturnType`\n\n### Types\n- `TypeName { fields }`\n\n## Dependencies\n- external: package v1.2.3\n\n## Behavior\n- 정상 케이스: input → expected output\n- 에러 케이스: invalid input → specific error\n\n## Constraints\n- 제약사항\n\n## Project Convention (project/module root만)\n### Project Structure\n### Module Boundaries\n### Naming Conventions\n\n## Code Convention (module root만)\n### Language & Runtime\n### Code Style\n### Naming Rules\n```\n\n## 아키텍처\n\n### Agents\n\n| Agent | 역할 |\n|-------|------|\n| `impl` | 요구사항 분석 및 CLAUDE.md + IMPLEMENTS.md 생성 |\n| `decompiler` | 소스코드에서 CLAUDE.md + IMPLEMENTS.md 추출 |\n| `compiler` | CLAUDE.md + IMPLEMENTS.md에서 소스코드 생성 (TDD) |\n| `validator` | CLAUDE.md-코드 일치 검증 (Structure, Exports, Dependencies, Behavior) + Export 커버리지 |\n\n### Skills\n\n**Entry Point (사용자 진입점):**\n\n| Skill | 역할 |\n|-------|------|\n| `/impl` | 요구사항 → CLAUDE.md + IMPLEMENTS.md |\n| `/decompile` | 소스코드 → CLAUDE.md + IMPLEMENTS.md |\n| `/compile` | CLAUDE.md + IMPLEMENTS.md → 소스코드 |\n| `/validate` | 문서-코드 일치 검증 |\n\n**Internal (Agent가 호출):**\n\n| Skill | 역할 |\n|-------|------|\n| `tree-parse` | 디렉토리 구조 분석 |\n| `boundary-resolve` | 바운더리 결정 |\n| `code-analyze` | 코드 분석 |\n| `claude-md-parse` | CLAUDE.md 파싱 |\n| `schema-validate` | 스키마 검증 |\n\n### 설계 원칙\n\n```\nUser → Entry Point Skill → Agent → Internal Skill(s)\n```\n\n| 컴포넌트 | 역할 | 오케스트레이션 |\n|----------|------|---------------|\n| **Entry Point Skill** | 사용자 진입점 | 간단 (파일 검색, 반복, Agent 호출) |\n| **Internal Skill** | 단일 기능 (SRP) | 없음, Stateless |\n| **Agent** | 비즈니스 로직 | 복잡 (N개 Skill, 재시도, 상태) |\n\n## CLI 도구\n\n플러그인에 포함된 Rust CLI 도구 (`core/`):\n\n```bash\n# 트리 파싱 - CLAUDE.md가 필요한 디렉토리 식별\nclaude-md-core parse-tree --root . --output tree.json\n\n# 바운더리 결정 - 디렉토리의 책임 범위 분석\nclaude-md-core resolve-boundary --path src/auth --output boundary.json\n\n# 스키마 검증 - CLAUDE.md 형식 검증\nclaude-md-core validate-schema --file CLAUDE.md --output validation.json\n\n# Convention 검증 - Convention 섹션 존재 및 필수 서브섹션 확인\nclaude-md-core validate-convention --project-root .\nclaude-md-core validate-convention --project-root . --module-roots packages/api,packages/web\n```\n\n## 언어 지원\n\n**프로젝트에서 사용하는 언어와 테스트 프레임워크를 자동 감지합니다.**\n\n- 언어 감지: 파일 확장자 기반\n- 테스트 프레임워크 감지: 프로젝트 설정 파일 분석\n\n## 라이선스\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "orchestrator-guide",
          "description": "Multi-agent orchestration framework for complex tasks with 5-element delegation protocol. Use /orchestrator for task coordination, /planner for spec generation, /delegator for delegation prompts.",
          "version": "1.6.2",
          "author": {
            "name": "jhk"
          },
          "source": "./plugins/orchestrator-guide",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add 0pg/cc-marketplace",
            "/plugin install orchestrator-guide@jhk-plugins"
          ]
        },
        {
          "name": "project-context-store",
          "description": "코드 재현에 필요한 컨텍스트를 CLAUDE.md로 자동 문서화. /context-generate로 생성, /context-update로 업데이트, /context-validate로 검증.",
          "version": "1.6.1",
          "author": {
            "name": "jhk"
          },
          "source": "./plugins/project-context-store",
          "category": "documentation",
          "categories": [
            "documentation"
          ],
          "install_commands": [
            "/plugin marketplace add 0pg/cc-marketplace",
            "/plugin install project-context-store@jhk-plugins"
          ]
        },
        {
          "name": "tdd-dev",
          "description": "TDD/ATDD 원칙 가이드. Outside-In TDD로 테스트가 컴포넌트 인터페이스를 정의합니다. /test-design으로 테스트 설계, /tdd-impl로 구현.",
          "version": "1.2.1",
          "author": {
            "name": "jhk"
          },
          "source": "./plugins/tdd-dev",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add 0pg/cc-marketplace",
            "/plugin install tdd-dev@jhk-plugins"
          ]
        },
        {
          "name": "tdd-workflow",
          "description": "orchestrator-guide용 TDD 워크플로우 어댑터. Red-Green-Refactor 기반 테스트 주도 개발 워크플로우 제공.",
          "version": "1.0.0",
          "author": {
            "name": "jhk"
          },
          "source": "./plugins/tdd-workflow",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add 0pg/cc-marketplace",
            "/plugin install tdd-workflow@jhk-plugins"
          ]
        },
        {
          "name": "claude-md-plugin",
          "description": "CLAUDE.md + IMPLEMENTS.md 듀얼 문서 시스템. /decompile로 소스코드에서 CLAUDE.md(WHAT) + IMPLEMENTS.md(HOW) 추출, /compile로 코드 생성, /validate로 문서-코드 일치 검증, /impl으로 요구사항에서 듀얼 문서 생성, /impl-review로 품질 리뷰, /debug로 런타임 버그 3계층 추적 진단, /project-setup으로 빌드/테스트 커맨드 + 코드 컨벤션 자동 감지, /convention-update으로 코드 컨벤션 관리.",
          "version": "2.23.0",
          "author": {
            "name": "jhk"
          },
          "source": "./plugins/claude-md-plugin",
          "category": "documentation",
          "categories": [
            "documentation"
          ],
          "install_commands": [
            "/plugin marketplace add 0pg/cc-marketplace",
            "/plugin install claude-md-plugin@jhk-plugins"
          ]
        }
      ]
    }
  ]
}