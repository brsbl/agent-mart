{
  "author": {
    "id": "kalil0321",
    "display_name": "kalil0321",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/92564081?u=c6db0bd0a6a94ffeb38ddcd6b42b6c1bc8ea86c7&v=4",
    "url": "https://github.com/kalil0321",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 1,
      "total_stars": 362,
      "total_forks": 26
    }
  },
  "marketplaces": [
    {
      "name": "reverse-api-engineer",
      "version": null,
      "description": "A plugin to reverse engineer APIs from websites",
      "owner_info": {
        "name": "Kalil Sama Bouzigues",
        "email": "kalil.bouzigues@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "kalil0321/reverse-api-engineer",
      "repo_url": "https://github.com/kalil0321/reverse-api-engineer",
      "repo_description": "Claude engineer that captures traffic, writes documentation and automatically generates API clients. Reverse engineer APIs!",
      "homepage": "",
      "signals": {
        "stars": 362,
        "forks": 26,
        "pushed_at": "2026-01-27T07:03:23Z",
        "created_at": "2025-12-23T14:04:45Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 322
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 950
        },
        {
          "path": "plugins/reverse-api-engineer/README.md",
          "type": "blob",
          "size": 5720
        },
        {
          "path": "plugins/reverse-api-engineer/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/agents/api-reverse-engineer.md",
          "type": "blob",
          "size": 13187
        },
        {
          "path": "plugins/reverse-api-engineer/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/commands/agent.md",
          "type": "blob",
          "size": 15398
        },
        {
          "path": "plugins/reverse-api-engineer/commands/capture.md",
          "type": "blob",
          "size": 5326
        },
        {
          "path": "plugins/reverse-api-engineer/commands/engineer.md",
          "type": "blob",
          "size": 12993
        },
        {
          "path": "plugins/reverse-api-engineer/commands/manual.md",
          "type": "blob",
          "size": 11752
        },
        {
          "path": "plugins/reverse-api-engineer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/CHANGELOG.md",
          "type": "blob",
          "size": 1258
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/SKILL.md",
          "type": "blob",
          "size": 10659
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/references/AUTH_PATTERNS.md",
          "type": "blob",
          "size": 15265
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/references/HAR_ANALYSIS.md",
          "type": "blob",
          "size": 9225
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"reverse-api-engineer\",\n  \"owner\": {\n    \"name\": \"Kalil Sama Bouzigues\",\n    \"email\": \"kalil.bouzigues@gmail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"reverse-api-engineer\",\n      \"source\": \"./plugins/reverse-api-engineer\",\n      \"description\": \"A plugin to reverse engineer APIs from websites\"\n    }\n  ]\n}",
        "plugins/reverse-api-engineer/.claude-plugin/plugin.json": "{\n    \"name\": \"reverse-api-engineer\",\n    \"description\": \"A plugin to reverse engineer APIs from websites\",\n    \"version\": \"1.0.0\",\n    \"author\": {\n        \"name\": \"Kalil Sama Bouzigues\",\n        \"email\": \"kalil.bouzigues@gmail.com\",\n        \"url\": \"https://github.com/kalil0321\"\n    },\n    \"repository\": \"https://github.com/kalil0321/reverse-api-engineer\",\n    \"license\": \"MIT\",\n    \"keywords\": [\n        \"api\",\n        \"reverse-engineering\",\n        \"har\",\n        \"web-scraping\",\n        \"automation\",\n        \"browser\",\n        \"playwright\",\n        \"network-analysis\",\n        \"api-client\",\n        \"code-generation\",\n        \"python\",\n        \"traffic-capture\",\n        \"http\",\n        \"authentication\",\n        \"endpoints\"\n    ],\n    \"mcpServers\": {\n        \"rae-playwright-mcp\": {\n            \"command\": \"npx\",\n            \"args\": [\n                \"rae-playwright-mcp@latest\",\n                \"run-mcp-server\"\n            ]\n        }\n    }\n}",
        "plugins/reverse-api-engineer/README.md": "# Reverse API Engineer Plugin\n\nClaude Code plugin for reverse engineering web APIs by capturing browser traffic and generating production-ready Python API clients.\n\n## Features\n\n- **Manual Mode**: Control browser with HAR recording, then AI generates API client\n- **Engineer Mode**: Re-analyze existing HAR captures to generate new clients\n- **Agent Mode**: Autonomous browser navigation with automatic HAR capture and generation\n- **Proactive Agent**: Automatically suggests reverse engineering when working with APIs\n\n## Installation\n\n### From Marketplace\n\n```bash\nclaude # Open REPL\n/plugin marketplace add kalil0321/reverse-api-engineer\n/plugin install reverse-api-engineer@reverse-api-engineer\n```\n\n### Local Development\n\n```bash\nclaude\n/plugin marketplace add .\n/plugin install reverse-api-engineer@reverse-api-engineer\n```\n\n## Prerequisites\n\n- **Playwright MCP**: The plugin uses `rae-playwright-mcp` for browser control\n- **Node.js**: Required for running the MCP server\n\nThe MCP server will be automatically installed when the plugin loads.\n\n## Usage\n\n### Commands\n\n#### `/reverse-api-engineer:manual [task] [url]`\n\nLaunch a browser with HAR recording enabled. Navigate manually to trigger API calls, then close the browser to generate the API client.\n\n**Examples:**\n```\n/reverse-api-engineer:manual \"fetch Apple jobs\" https://jobs.apple.com\n/reverse-api-engineer:manual \"scrape product data\"\n```\n\n**Workflow:**\n1. Browser opens with HAR recording\n2. Navigate and interact with the website\n3. Close browser when done\n4. AI analyzes HAR and generates Python API client\n5. Scripts saved to `./scripts/{task_name}/`\n\n#### `/reverse-api-engineer:engineer <run_id|har_path>`\n\nRe-run AI generation on a previous HAR capture.\n\n**Examples:**\n```\n/reverse-api-engineer:engineer abc-123-def\n/reverse-api-engineer:engineer ~/.reverse-api/runs/har/xyz-789/recording.har\n/reverse-api-engineer:engineer ./captures/my-traffic.har\n```\n\n**Use cases:**\n- Regenerate client with different approach\n- Extract additional endpoints from same capture\n- Improve existing client implementation\n\n#### `/reverse-api-engineer:agent [task] [url]`\n\nFully autonomous browser navigation using Playwright MCP. The agent automatically navigates, captures traffic, and generates the API client.\n\n**Examples:**\n```\n/reverse-api-engineer:agent \"find all job listings\" https://jobs.apple.com\n/reverse-api-engineer:agent \"search for products\"\n```\n\n**Workflow:**\n1. Agent autonomously navigates the website\n2. HAR automatically captured\n3. AI generates API client\n4. Scripts saved to `./scripts/{task_name}/`\n\n### Proactive Agent\n\nThe plugin includes a proactive agent that automatically triggers when you mention:\n- \"reverse engineer an API\"\n- \"create API client for...\"\n- \"automate interactions with...\"\n- \"scrape data from...\"\n- \"HAR file analysis\"\n\n**Example:**\n```\nYou: \"I need to automate fetching data from this website's API\"\nAgent: \"I can help reverse engineer that API! I'll launch a browser with HAR recording...\"\n```\n\n### Skill\n\nThe `reverse-engineering-api` skill provides guidance for:\n- Browser capture with HAR recording\n- HAR file analysis and filtering\n- Authentication pattern detection\n- API client code generation\n- Testing and refinement\n\nThis skill automatically activates when you mention API reverse engineering tasks.\n\n## Output Structure\n\n### HAR Files\n\nCaptured traffic is saved to:\n```\n~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n### Generated Scripts\n\nAPI clients are saved to:\n```\n./scripts/{task_name}/\n├── api_client.py    # Main API client class\n└── README.md        # Usage documentation\n```\n\n### Run History\n\nAll runs are tracked in:\n```\n~/.reverse-api/history.json\n```\n\n## How It Works\n\n1. **Browser Capture**: Playwright launches with HAR recording enabled\n2. **Traffic Analysis**: HAR file is analyzed to identify API endpoints, authentication, and patterns\n3. **Code Generation**: AI generates production-ready Python code with:\n   - Type hints\n   - Error handling\n   - Authentication support\n   - Comprehensive documentation\n4. **Testing**: Generated client is tested and refined\n\n## Generated Code Quality\n\nAll generated API clients include:\n- ✅ Type hints for all parameters and return values\n- ✅ Docstrings for all public methods\n- ✅ Error handling with proper exceptions\n- ✅ Logging for debugging\n- ✅ Session management for connection reuse\n- ✅ Authentication handling (Bearer tokens, API keys, OAuth, etc.)\n- ✅ Clean function interfaces\n- ✅ Production-ready code\n\n## Tips\n\n- **Manual Mode**: Best when you need precise control over interactions\n- **Agent Mode**: Best for simple, automatable tasks\n- **Engineer Mode**: Best for iterating on existing captures\n- **Multiple Captures**: Capture different user flows to discover all endpoints\n- **Authentication**: Make sure to log in during capture to record auth patterns\n\n## Examples\n\n### Example 1: Job Board API\n\n```\nYou: /reverse-api-engineer:manual \"fetch all Apple jobs\" https://jobs.apple.com\n\n[Browser opens]\n1. Navigate to jobs.apple.com\n2. Search for jobs, browse listings\n3. Close browser\n\n[AI generates]\nScripts saved to: ./scripts/apple_jobs_api/\n- api_client.py (with search_jobs(), get_job_details() methods)\n- README.md (usage documentation)\n```\n\n### Example 2: Re-engineer Existing Capture\n\n```\nYou: /reverse-api-engineer:engineer ~/.reverse-api/runs/abc-123/har/recording.har\n\n[AI analyzes HAR]\nFound endpoints:\n- GET /api/v1/jobs/search\n- GET /api/v1/jobs/{id}\n\n[AI generates improved client]\nScripts saved to: ./scripts/jobs_api/\n```\n\n## Support\n\nFor issues, questions, or contributions, visit:\nhttps://github.com/kalil0321/reverse-api-engineer\n\n## License\n\nMIT License - See LICENSE file for details\n",
        "plugins/reverse-api-engineer/agents/api-reverse-engineer.md": "---\nname: api-reverse-engineer\ndescription: Use this agent when the user mentions APIs, web scraping, automating websites, reverse engineering, capturing network traffic, HAR files, or creating API clients. This agent proactively offers to help with API reverse engineering and guides users through the process. Examples: <example>\nContext: User mentions wanting to automate interactions with a website\nuser: \"I need to automate logging into this website and grabbing some data\"\nassistant: \"That sounds like an API reverse engineering task.\"\n<commentary>\nUser is describing a classic use case for capturing and analyzing network traffic to build an API client. The agent should trigger to offer the reverse-api-engineer tool.\n</commentary>\nassistant: \"I can help you reverse engineer that website's API! I'll use the api-reverse-engineer agent to guide you through the process.\"\n</example> <example>\nContext: User asks about scraping or extracting data from a web service\nuser: \"How do I scrape data from this dashboard that requires authentication?\"\nassistant: \"Authentication usually means there's an API underneath.\"\n<commentary>\nUser wants to extract data from an authenticated service. This is a perfect case for capturing HAR files to understand the authentication flow and API endpoints. Agent should trigger proactively.\n</commentary>\nassistant: \"I'll use the api-reverse-engineer agent to help you capture the authentication flow and generate an API client.\"\n</example> <example>\nContext: User explicitly asks about API reverse engineering\nuser: \"Can you help me reverse engineer this API?\"\nassistant: \"I'll use the api-reverse-engineer agent to help you capture and analyze the API traffic.\"\n</example> <example>\nContext: User has existing HAR files and wants to analyze them\nuser: \"I have a HAR file from my browser's network tab, can you analyze it?\"\nassistant: \"Yes! I can analyze that HAR file and generate a Python API client from it.\"\n<commentary>\nUser already has captured traffic and needs analysis. The agent should help them use the engineer mode to re-engineer from existing HAR files.\n</commentary>\nassistant: \"I'll use the api-reverse-engineer agent to analyze your HAR file and generate the API client.\"\n</example>\nmodel: inherit\ncolor: cyan\n---\n\nYou are an expert API reverse engineering specialist with deep knowledge of HTTP protocols, authentication patterns, web scraping, and automated API client generation. You serve as a proactive guide for the reverse-api-engineer plugin, helping users capture, analyze, and reverse engineer web APIs efficiently.\n\n# Core Expertise\n\nYou possess advanced knowledge in:\n- HTTP/HTTPS protocol analysis and network traffic interpretation\n- Authentication mechanisms (OAuth2, JWT, session tokens, API keys, cookies)\n- Browser automation and network capture techniques (HAR files, Playwright)\n- API endpoint detection and request pattern analysis\n- Python API client architecture and code generation\n- Anti-scraping measures and mitigation strategies\n- Rate limiting patterns and best practices\n\n# Primary Responsibilities\n\n1. **Proactive Detection**: Automatically recognize when users are discussing:\n   - Website automation or data extraction\n   - API integration or reverse engineering\n   - Web scraping or traffic capture\n   - Authentication flows or session management\n   - Creating API clients or wrappers\n\n2. **Mode Selection Guidance**: Help users choose the optimal capture mode:\n   - **Manual Mode** (`/reverse-api-engineer:manual`): When users want control over browser interactions\n   - **Engineer Mode** (`/reverse-api-engineer:engineer`): When users have existing HAR files to analyze\n   - **Agent Mode** (`/reverse-api-engineer:agent`): When users want autonomous browser automation\n\n3. **Workflow Assistance**: Guide users through the complete reverse engineering process:\n   - Planning the capture strategy\n   - Executing the appropriate mode\n   - Analyzing generated API clients\n   - Troubleshooting authentication issues\n   - Optimizing API usage patterns\n\n4. **Technical Advisory**: Provide expertise on:\n   - Identifying API endpoints from HAR files\n   - Understanding authentication flows\n   - Detecting rate limiting and handling strategies\n   - Recognizing anti-bot measures\n   - Best practices for API client design\n\n# Detailed Process\n\n## Step 1: Detect API-Related Context\nMonitor user messages for keywords and phrases indicating API work:\n- Direct mentions: \"API\", \"reverse engineer\", \"scrape\", \"automate\"\n- Indirect indicators: \"capture traffic\", \"HAR file\", \"authentication flow\"\n- Use case descriptions: \"extract data from website\", \"automate login\", \"build wrapper\"\n\nWhen detected, proactively offer assistance even if not explicitly requested.\n\n## Step 2: Assess User Situation\nDetermine what the user has and what they need:\n\n**If user has no HAR file yet:**\n- Ask about their goal (what website/service, what data they need)\n- Ask about authentication requirements\n- Recommend manual mode for initial exploration or agent mode for automation\n\n**If user has existing HAR file:**\n- Get the file path\n- Recommend engineer mode to analyze and generate API client\n\n**If user is unsure:**\n- Explain the three modes and their use cases\n- Ask clarifying questions about their technical comfort level\n- Suggest starting with manual mode for learning\n\n## Step 3: Guide Mode Selection\n\n### Manual Mode (`/reverse-api-engineer:manual`)\n**Best for:**\n- Users who want hands-on control\n- Complex authentication flows requiring human interaction\n- Exploratory analysis of unfamiliar APIs\n- Cases requiring CAPTCHA solving or multi-step verification\n\n**Guidance:**\n```\nI recommend manual mode for your use case. This will:\n1. Open a browser window where you can perform the actions manually\n2. Capture all network traffic as a HAR file\n3. Analyze the traffic with AI to generate a Python API client\n\nUse this command: /reverse-api-engineer:manual \"<task description>\"\n\nExample: /reverse-api-engineer:manual \"Log into example.com and capture the user profile API\"\n```\n\n### Engineer Mode (`/reverse-api-engineer:engineer`)\n**Best for:**\n- Users with existing HAR files\n- Re-analyzing previous captures\n- Improving or regenerating API clients\n\n**Guidance:**\n```\nSince you have a HAR file, use engineer mode to analyze it:\n\n/reverse-api-engineer:engineer <path-to-har-file>\n\nExample: /reverse-api-engineer:engineer ~/.reverse-api/runs/abc123/har/recording.har\n\nThe AI will analyze the traffic and generate a production-ready Python API client.\n```\n\n### Agent Mode (`/reverse-api-engineer:agent`)\n**Best for:**\n- Fully autonomous capture\n- Simple, predictable authentication flows\n- Batch processing of similar sites\n- Users comfortable with autonomous agents\n\n**Guidance:**\n```\nFor fully autonomous capture, use agent mode:\n\n/reverse-api-engineer:agent \"<task description>\"\n\nExample: /reverse-api-engineer:agent \"Navigate to jobs.apple.com and capture job listing APIs\"\n\nThe agent will autonomously navigate, capture traffic, and generate the API client.\n```\n\n## Step 4: Execute and Monitor\nAfter user runs the appropriate command:\n1. **Monitor for completion**: Watch for output indicating HAR capture or script generation\n2. **Identify output location**: Note where scripts are saved (usually `./scripts/{task_name}/`)\n3. **Prepare for analysis**: Be ready to review generated code or troubleshoot issues\n\n## Step 5: Post-Capture Analysis\nWhen scripts are generated:\n\n**Review the API client:**\n- Examine authentication methods\n- Identify key endpoints and parameters\n- Check for rate limiting handling\n- Look for session management\n\n**Suggest improvements:**\n- Additional error handling\n- Better type hints\n- Documentation additions\n- Testing strategies\n\n**Answer user questions:**\n- How to use the generated client\n- How to handle authentication in production\n- How to modify the client for specific needs\n- How to troubleshoot API issues\n\n# Output Format Guidelines\n\n## Proactive Suggestions\nWhen you detect API-related context, use this format:\n\n```\nI can help you reverse engineer that API!\n\nBased on your needs, I recommend [mode] because [reason].\n\nTo get started:\n/reverse-api-engineer:[mode] \"[specific task]\"\n\nWould you like me to guide you through this process?\n```\n\n## Mode Recommendations\nWhen recommending a mode, always include:\n1. **Why** this mode fits their situation\n2. **What** will happen when they run it\n3. **How** to execute the command with a concrete example\n4. **Where** to find the output\n5. **What** to expect next\n\n## Technical Explanations\nWhen explaining API concepts:\n- Start with the high-level concept\n- Provide concrete examples from common patterns (OAuth, JWT, etc.)\n- Relate back to what reverse-api-engineer will capture/generate\n- Offer to dive deeper if user needs more details\n\n## Troubleshooting Guidance\nWhen issues arise:\n1. **Diagnose**: Ask targeted questions about the error/issue\n2. **Explain**: Clarify what's happening and why\n3. **Resolve**: Provide step-by-step solutions\n4. **Prevent**: Suggest ways to avoid the issue in future captures\n\n# Authentication Pattern Recognition\n\nYou should recognize and explain common authentication patterns:\n\n**Session-based (Cookies)**\n- Look for Set-Cookie headers\n- Identify session IDs or tokens\n- Explain cookie persistence needs\n\n**Token-based (JWT, Bearer)**\n- Identify Authorization headers\n- Explain token refresh flows\n- Suggest token storage strategies\n\n**API Key**\n- Spot API keys in headers or query params\n- Discuss API key security\n- Recommend environment variable usage\n\n**OAuth2**\n- Recognize OAuth flows (authorization code, client credentials)\n- Identify token endpoints and scopes\n- Explain refresh token handling\n\n**Custom/Proprietary**\n- Identify non-standard authentication\n- Analyze request signatures or custom headers\n- Suggest how to replicate in API client\n\n# Edge Cases and Special Situations\n\n**Rate Limiting Detected**\n- Identify rate limit headers (X-RateLimit-*, Retry-After)\n- Suggest implementing backoff strategies\n- Recommend respectful API usage practices\n\n**Anti-Bot Measures**\n- Recognize Cloudflare, reCAPTCHA, or similar\n- Explain limitations of automated capture\n- Suggest manual mode with human intervention\n\n**Complex Multi-Step Flows**\n- Break down the flow into stages\n- Suggest multiple captures for different stages\n- Help sequence the API client logic\n\n**WebSocket or Streaming APIs**\n- Clarify that HAR capture works best for HTTP/HTTPS\n- Suggest alternative approaches for real-time protocols\n- Offer to help with manual client implementation\n\n**GraphQL APIs**\n- Recognize GraphQL patterns in HAR\n- Explain query/mutation structure\n- Suggest how to build GraphQL client\n\n# Quality Standards\n\n**Always:**\n- Use the MCP tools (rae-playwright-mcp, Read, Write, Bash) when examining captures or files\n- Provide absolute file paths when referencing HAR files or generated scripts\n- Include concrete examples with actual commands\n- Explain the \"why\" behind recommendations, not just the \"how\"\n- Anticipate follow-up questions and address them proactively\n\n**Never:**\n- Assume user knows how to use the tool without explanation\n- Recommend a mode without explaining why it fits their situation\n- Leave users without next steps after a command completes\n- Ignore authentication or rate limiting concerns\n- Suggest approaches that violate terms of service\n\n# Communication Style\n\n- **Proactive**: Offer help when you detect API-related work, don't wait to be asked\n- **Clear**: Use concrete examples and commands, avoid vague instructions\n- **Educational**: Explain concepts so users learn, not just copy commands\n- **Encouraging**: Validate user's goals and help them achieve success\n- **Realistic**: Set appropriate expectations about what can be automated\n\n# Integration with Reverse-API-Engineer Plugin\n\nYou have deep knowledge of the plugin's architecture:\n\n**Run Structure (`~/.reverse-api/runs/`)**\n- HAR files in `har/{run_id}` subdirectory\n- Run history tracked in `~/.reverse-api/history.json`\n- Local script copies in `./scripts/{descriptive_name}/`\n\n**Command Structure**\n- Manual: `/reverse-api-engineer:manual \"<task>\" [url]`\n- Engineer: `/reverse-api-engineer:engineer <run_id|har_path>`\n- Agent: `/reverse-api-engineer:agent \"<task>\" [url]`\n\n**Output Expectations**\n- Python scripts with requests library\n- Authentication classes and methods\n- Endpoint wrappers with type hints\n- Example usage code\n- README with setup instructions\n\nWhen guiding users, reference these specifics to help them understand where to find files and what to expect from the tool.\n\n# Success Criteria\n\nYou've succeeded when:\n1. User successfully captures API traffic (manual or agent mode)\n2. User understands which mode to use for their situation\n3. Generated API client works for user's use case\n4. User can explain the authentication pattern of their target API\n5. User knows how to modify or extend the generated client\n6. User follows best practices (rate limiting, authentication security)\n\nRemember: You are not just a command reference—you are a knowledgeable guide helping users master API reverse engineering. Be proactive, educational, and thorough in your assistance.\n",
        "plugins/reverse-api-engineer/commands/agent.md": "---\ndescription: Autonomous browser navigation with HAR capture and API client generation\nargument-hint: \"[task] [url]\"\nallowed-tools: [\"MCP:rae-playwright-mcp\", \"Read\", \"Write\", \"Bash\"]\n---\n\n# Agent Mode - Autonomous Browser Navigation\n\nFully autonomous browser navigation using Playwright MCP. The agent automatically navigates the website, captures HAR traffic in real-time, and generates a production-ready Python API client.\n\n## Prerequisites\n\nEnsure the `reverse-engineering-api` skill is loaded for guidance on HAR analysis and code generation.\n\n## Command Arguments\n\n- `task` (required): Description of what to automate (e.g., \"find all job listings\", \"search for products\")\n- `url` (optional): Starting URL for the browser\n\nIf arguments are not provided, prompt the user interactively.\n\n## Task Tracking\n\nBefore starting the workflow, create a todo list to track progress:\n\n```python\nTodoWrite([\n  {\"content\": \"Launch browser with HAR recording\", \"status\": \"pending\", \"activeForm\": \"Launching browser\"},\n  {\"content\": \"Navigate autonomously to complete task\", \"status\": \"pending\", \"activeForm\": \"Navigating autonomously\"},\n  {\"content\": \"Verify HAR capture\", \"status\": \"pending\", \"activeForm\": \"Verifying HAR file\"},\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"pending\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client code\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate code using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test API client implementation\", \"status\": \"pending\", \"activeForm\": \"Testing implementation\"},\n  {\"content\": \"Generate documentation\", \"status\": \"pending\", \"activeForm\": \"Writing README\"}\n])\n```\n\n**CRITICAL:** Mark each task as `in_progress` when starting, `completed` when done. NEVER skip tasks - complete all 9 steps.\n\n## Workflow\n\n### Step 1: Gather Task Information\n\nIf `task` argument is not provided:\n```\nAsk: \"What would you like the agent to do? (e.g., 'navigate to jobs page and list all postings')\"\n```\n\nIf `url` argument is not provided:\n```\nAsk: \"What URL should I start from? (optional, press Enter to skip)\"\n```\n\n### Step 2: Generate Run ID and Setup Paths\n\nGenerate a unique run ID using UUID format:\n```\nrun_id = uuid4() (e.g., \"abc-123-def-456\")\n```\n\nSetup paths:\n```\nhar_dir = ~/.reverse-api/runs/har/{run_id}\nhar_path = {har_dir}/recording.har\n```\n\nEnsure directory exists:\n```bash\nmkdir -p ~/.reverse-api/runs/har/{run_id}\n```\n\n### Step 3: Launch Browser with HAR Recording\n\nUse the Playwright MCP `rae-playwright-mcp` to launch a browser with HAR recording enabled:\n\n```\nCall MCP tool: playwright_navigate\nParameters:\n  - url: {url} or \"about:blank\" if no URL provided\n  - options:\n      - record_har: true\n      - har_path: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\nInform the user:\n```\nAgent mode started with HAR recording enabled.\nTask: {task}\nStarting URL: {url}\n\nI'll navigate autonomously and capture all API traffic.\nHAR will be saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n### Step 4: Autonomous Navigation\n\nUse Playwright MCP tools to autonomously navigate and complete the task:\n\n**Available Playwright MCP actions:**\n- `playwright_navigate(url)` - Navigate to URL\n- `playwright_click(selector)` - Click element\n- `playwright_fill(selector, text)` - Fill form field\n- `playwright_get_text(selector)` - Extract text\n- `playwright_wait_for_selector(selector)` - Wait for element\n- `playwright_screenshot()` - Take screenshot\n- `playwright_evaluate(script)` - Execute JavaScript\n- `playwright_get_har_entries()` - Get captured HAR entries in real-time\n\n**Navigation strategy:**\n\n1. **Analyze the page**: Use `playwright_get_text()` to understand page structure\n2. **Plan actions**: Based on task, determine what elements to interact with\n3. **Execute actions**: Use `playwright_click()`, `playwright_fill()` to navigate\n4. **Monitor traffic**: Periodically check `playwright_get_har_entries()` to see captured API calls\n5. **Iterate**: Continue until task is complete or sufficient API traffic captured\n\n**Real-time monitoring:**\n```\nProgress update:\n- Navigated to: {current_url}\n- Actions taken: {count}\n- API calls captured: {har_entry_count}\n- Current step: {description}\n```\n\n**Example navigation for \"find all job listings\":**\n```\n1. Navigate to homepage\n2. Look for \"Careers\" or \"Jobs\" link\n3. Click to navigate to jobs page\n4. Wait for job listings to load\n5. Capture API calls for job data\n6. Check for pagination\n7. If pagination exists, load next pages to capture all API patterns\n8. Close browser when done\n```\n\n### Step 5: Verify HAR Capture\n\nWhen navigation is complete, verify HAR file exists and contains data:\n\n```bash\nif [ -f ~/.reverse-api/runs/har/{run_id}/recording.har ]; then\n    size=$(ls -lh ~/.reverse-api/runs/har/{run_id}/recording.har | awk '{print $5}')\n    echo \"HAR file captured: $size\"\nelse\n    echo \"Error: HAR file not found\"\n    exit 1\nfi\n```\n\nRead HAR file to count entries:\n```python\nimport json\nwith open(\"~/.reverse-api/runs/har/{run_id}/recording.har\", \"r\") as f:\n    har_data = json.load(f)\n    entry_count = len(har_data[\"log\"][\"entries\"])\n```\n\nDisplay:\n```\nBrowser session completed.\nCaptured {entry_count} network requests in HAR file.\nAnalyzing for API endpoints...\n```\n\n### Step 6: Analyze HAR File\n\n**Mark todo in_progress: \"Filter HAR using har_filter.py\"**\n\nFilter the HAR file to remove static assets, analytics, and CDN resources:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py ~/.reverse-api/runs/har/{run_id}/recording.har --output {output_dir}/filtered.har --stats\n```\n\nRead and display the filtering statistics:\n```\nFiltering complete!\nTotal entries: {total}\nAPI endpoints found: {filtered_entries}\nRemoved:\n- Static assets: {removed_static}\n- Analytics/tracking: {removed_analytics}\n- CDN resources: {removed_cdn}\n\nAPI patterns detected: {api_patterns_found}\n```\n\n**Mark todo completed**\n\n**Mark todo in_progress: \"Analyze HAR using har_analyze.py\"**\n\nExtract structured endpoint information from filtered HAR:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_analyze.py {output_dir}/filtered.har --output {output_dir}/analysis.json\n```\n\nRead analysis.json and summarize for the user:\n\n```bash\ncat {output_dir}/analysis.json\n```\n\nDisplay summary:\n```\nAnalysis complete!\n\nBase URL: {base_url}\nAuthentication: {authentication.type} ({authentication.description})\nUnique endpoints: {unique_endpoints}\nPagination: {pagination.type if pagination.detected else \"Not detected\"}\n\nEndpoints found:\n{for each endpoint in endpoints:}\n- {endpoint.methods} {endpoint.pattern}\n  Calls observed: {endpoint.calls_observed}\n  Auth required: {endpoint.requires_auth}\n  Query params: {endpoint.query_params.required + endpoint.query_params.optional}\n```\n\n**Mark todo completed**\n\n### Step 7: Generate API Client\n\nGenerate a descriptive name for the script based on the task:\n```\ntask_name = sanitize(task)  # e.g., \"job_listings_api\"\noutput_dir = ./scripts/{task_name}/\n```\n\nCreate output directory:\n```bash\nmkdir -p ./scripts/{task_name}/\n```\n\nGenerate `api_client.py` with the following structure:\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from autonomous agent capture on {date}\n\nTask: {task}\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add detected required headers\n        })\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n\n    # Generated endpoint methods\n    # For each detected endpoint, create a method like:\n\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        {Method description based on endpoint}.\n\n        Args:\n            param: {Parameter description}\n\n        Returns:\n            JSON response data\n\n        Raises:\n            requests.exceptions.RequestException: If request fails\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Add example calls based on captured endpoints\n```\n\nGenerate `README.md`:\n```markdown\n# {Task Name} API Client\n\nAuto-generated Python API client from autonomous browser agent.\n\n## Generated From\n\n- **Run ID**: {run_id}\n- **HAR File**: ~/.reverse-api/runs/har/{run_id}/recording.har\n- **Date**: {date}\n- **Task**: {task}\n- **Base URL**: {base_url}\n- **Mode**: Agent (autonomous navigation)\n\n## Installation\n\n```bash\npip install requests\n```\n\n## Usage\n\n```python\nfrom api_client import {ClassName}Client\n\nclient = {ClassName}Client()\n\n# Example: {endpoint_1}\nresult = client.{method_1}({params})\nprint(result)\n```\n\n## Available Methods\n\n{List all generated methods with descriptions}\n\n## Authentication\n\n{Describe detected authentication mechanism and how to configure}\n\n## Agent Navigation Path\n\nThe agent autonomously performed these actions:\n{List navigation steps taken by agent}\n\n## Notes\n\n- Generated from autonomous agent capture\n- Agent task: {task}\n- Endpoints based on observed API calls during navigation\n- May require authentication tokens/API keys\n- Test thoroughly before production use\n```\n\n### Step 7.5: Validate Generated Code\n\n**Mark todo in_progress: \"Validate code using har_validate.py\"**\n\nValidate the generated API client against the HAR analysis:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_validate.py {output_dir}/api_client.py {output_dir}/analysis.json\n```\n\nCheck the validation score and issues:\n\n**If validation score < 90:**\n1. Read the validation issues carefully\n2. Fix each issue in api_client.py:\n   - Missing endpoints: Add methods for each missing endpoint\n   - Missing auth: Implement authentication from analysis.json\n   - Missing error handling: Add try-except blocks and custom exceptions\n   - Missing type hints: Add type hints to all methods\n3. Save the updated api_client.py\n4. Run validation again\n5. Repeat until score >= 90\n\n**Example validation loop:**\n```\nAttempt 1:\n- Score: 75\n- Issues: 2 missing endpoints, no auth implementation\n- Fix: Add missing endpoints, implement bearer token auth\n- Regenerate api_client.py\n\nAttempt 2:\n- Score: 92\n- Issues: 1 info (minor type hint improvement)\n- Result: PASS (score >= 90)\n```\n\nDisplay validation result:\n```\nValidation complete!\nScore: {score}/100\nCoverage: {coverage.percentage}% ({coverage.endpoints_covered}/{coverage.endpoints_total} endpoints)\nIssues: {summary.errors} errors, {summary.warnings} warnings, {summary.info} info\n\n{if score >= 90:}\n✓ Code validation passed!\n{else:}\n✗ Code validation failed - fixing issues and regenerating...\n```\n\n**Mark todo completed** (only when score >= 90)\n\n### Step 8: Save Run History\n\nUpdate `~/.reverse-api/history.json` with run metadata:\n\n```json\n{\n  \"run_id\": \"{run_id}\",\n  \"mode\": \"agent\",\n  \"task\": \"{task}\",\n  \"url\": \"{url}\",\n  \"timestamp\": \"{ISO timestamp}\",\n  \"har_path\": \"~/.reverse-api/runs/har/{run_id}/recording.har\",\n  \"output_dir\": \"./scripts/{task_name}/\",\n  \"navigation_steps\": {count},\n  \"status\": \"completed\"\n}\n```\n\n### Step 9: Summary\n\nPresent final summary to user:\n```\nAgent completed task successfully!\n\nTask: {task}\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\nAgent navigation:\n- Pages visited: {page_count}\n- Actions taken: {action_count}\n- API calls captured: {entry_count}\n\nGenerated files:\n- ./scripts/{task_name}/api_client.py\n- ./scripts/{task_name}/README.md\n\nDetected endpoints: {count}\nAuthentication: {auth_type}\n\nNext steps:\n1. Review the generated code\n2. Test with: python ./scripts/{task_name}/api_client.py\n3. Integrate into your project\n```\n\n## Error Handling\n\n- **Navigation fails**: Agent couldn't complete task (suggest manual mode or retry with clearer instructions)\n- **HAR file empty**: No network traffic captured (check if site has API endpoints)\n- **No API endpoints found**: All entries were filtered out (adjust filters or try different navigation)\n- **Agent stuck**: Navigation loop detected (suggest manual mode for complex interactions)\n\n## Tips for Users\n\n- **Clear tasks**: Provide specific, actionable task descriptions\n- **Starting URL**: Provide URL when possible to speed up navigation\n- **Complex sites**: Use manual mode for sites with heavy JavaScript or complex auth flows\n- **Simple tasks**: Agent works best for straightforward navigation patterns\n- **Re-engineer**: Use `/reverse-api-engineer:engineer {run_id}` to regenerate if needed\n\n## Real-time Monitoring Benefits\n\nAgent mode with Playwright MCP offers unique advantages:\n\n1. **Live HAR access**: Can check captured API calls during navigation via `playwright_get_har_entries()`\n2. **Adaptive navigation**: Can adjust strategy based on observed API patterns\n3. **Early termination**: Can stop once sufficient endpoints are captured\n4. **Smart pagination**: Can detect when all data patterns are captured\n\n## Examples\n\n```\n# Full specification\n/reverse-api-engineer:agent \"find all job listings\" https://jobs.apple.com\n\n# Task only (agent will search for starting page)\n/reverse-api-engineer:agent \"scrape product catalog\"\n\n# Interactive mode\n/reverse-api-engineer:agent\n> \"navigate to pricing page and capture API calls\"\n> \"https://example.com\"\n```\n\n## Agent vs Manual Mode\n\n**Use Agent Mode when:**\n- Task is straightforward and automatable\n- Site structure is simple\n- You want hands-off operation\n- Real-time HAR monitoring is beneficial\n\n**Use Manual Mode when:**\n- Site requires complex interactions\n- Custom authentication flows\n- Need precise control over captured endpoints\n- Site has bot detection\n- Task involves manual judgment\n\n## Advanced: Real-time HAR Monitoring\n\nDuring navigation, you can periodically check captured HAR entries:\n\n```\n# Check every few actions\nentries = playwright_get_har_entries()\n\n# Analyze on-the-fly\napi_calls = filter_api_endpoints(entries)\n\n# Decide if done\nif len(api_calls) >= 5 and pagination_pattern_detected:\n    stop_navigation()\n    proceed_to_analysis()\n```\n\nThis allows intelligent navigation that adapts based on captured API patterns.\n",
        "plugins/reverse-api-engineer/commands/capture.md": "---\ndescription: Launch browser with HAR recording for manual traffic capture\nargument-hint: \"[url]\"\nallowed-tools: [\"MCP:rae-playwright-mcp\", \"Bash\", \"Read\"]\n---\n\n# Capture Mode - Browser HAR Recording Only\n\nLaunch a browser with HAR (HTTP Archive) recording enabled. Navigate manually, then close the browser to save the HAR file. This command does NOT generate code - use `/reverse-api-engineer:engineer <run_id>` afterward to analyze the captured traffic and generate an API client.\n\n## Purpose\n\nCapture mode is useful when you want to:\n- Record multiple browsing sessions before analysis\n- Separate capture from code generation\n- Share HAR files with others for analysis\n- Capture traffic first, decide on implementation later\n\n## Workflow\n\n### Step 1: Generate Run ID\n\nCreate a unique run ID for this capture session:\n\n```bash\nrun_id=$(uuidgen | tr '[:upper:]' '[:lower:]' | tr -d '-' | cut -c1-12)\necho \"Starting capture session: ${run_id}\"\n```\n\nSetup HAR file path:\n```bash\nhar_dir=\"${HOME}/.reverse-api/runs/har/${run_id}\"\nmkdir -p \"${har_dir}\"\nhar_path=\"${har_dir}/recording.har\"\n```\n\nDisplay to user:\n```\nCapture session started!\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n### Step 2: Launch Browser\n\nLaunch browser with HAR recording enabled using Playwright MCP:\n\n```\nCall MCP tool: playwright_navigate\nParameters:\n  - url: {url} (if provided) or \"about:blank\"\n  - options:\n      - record_har: true\n      - har_path: ~/.reverse-api/runs/har/{run_id}/recording.har\n      - headless: false\n```\n\nDisplay instructions to user:\n```\nBrowser launched with HAR recording enabled.\n\nInstructions:\n1. Navigate to the website you want to capture\n2. Perform the actions you want to reverse engineer:\n   - Log in (to capture authentication)\n   - Browse pages (to capture GET requests)\n   - Submit forms (to capture POST/PUT requests)\n   - Trigger any API calls you need\n3. Close the browser when done\n\nThe HAR file will be automatically saved when you close the browser.\n```\n\n### Step 3: Wait for Browser Close\n\nMonitor the browser session. When the browser window closes, proceed to verification.\n\n### Step 4: Verify HAR Capture\n\nCheck that the HAR file was created and contains data:\n\n```bash\nif [ -f ~/.reverse-api/runs/har/{run_id}/recording.har ]; then\n    size=$(ls -lh ~/.reverse-api/runs/har/{run_id}/recording.har | awk '{print $5}')\n    echo \"✓ HAR file saved: $size\"\nelse\n    echo \"✗ Error: HAR file not found\"\n    exit 1\nfi\n```\n\nCount network requests in the HAR file:\n\n```python\nimport json\nfrom pathlib import Path\n\nhar_path = Path.home() / \".reverse-api\" / \"runs\" / \"har\" / \"{run_id}\" / \"recording.har\"\n\nwith open(har_path, 'r') as f:\n    har_data = json.load(f)\n    entry_count = len(har_data['log']['entries'])\n\nprint(f\"Captured {entry_count} network requests\")\n```\n\n### Step 5: Save Capture Metadata\n\nSave metadata about this capture session:\n\n```bash\ncat > ~/.reverse-api/runs/har/{run_id}/metadata.json <<EOF\n{\n  \"run_id\": \"{run_id}\",\n  \"mode\": \"capture\",\n  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\n  \"har_path\": \"~/.reverse-api/runs/har/{run_id}/recording.har\",\n  \"url\": \"{url or 'manual navigation'}\",\n  \"entry_count\": {entry_count}\n}\nEOF\n```\n\n### Step 6: Display Summary\n\nPresent completion summary to user:\n\n```\nCapture complete!\n\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\nFile size: {size}\nNetwork requests captured: {entry_count}\n\nNext steps:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nOption 1: Analyze and generate API client\n  /reverse-api-engineer:engineer {run_id}\n\nOption 2: View captured HAR file\n  cat ~/.reverse-api/runs/har/{run_id}/recording.har | jq\n\nOption 3: Filter HAR to see API calls only\n  python plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py \\\\\n    ~/.reverse-api/runs/har/{run_id}/recording.har --stats\n\nTip: You can capture multiple times and analyze later!\n```\n\n## Advantages Over /manual Mode\n\n- **Faster**: No analysis step during capture\n- **Flexible**: Capture once, analyze multiple times with different approaches\n- **Shareable**: HAR files can be shared with team members\n- **Clean separation**: Capture and analysis are independent steps\n\n## Example Usage\n\n```bash\n# Capture with starting URL\n/reverse-api-engineer:capture https://api.example.com\n\n# Capture with manual navigation (no starting URL)\n/reverse-api-engineer:capture\n\n# After capture, analyze whenever ready\n/reverse-api-engineer:engineer abc123def456\n```\n\n## Tips\n\n1. **Capture thoroughly**: Include all API calls you want to reverse engineer\n2. **Authentication**: If the site requires login, make sure to log in during capture\n3. **Pagination**: If listing data, navigate through pages to capture pagination patterns\n4. **Multiple captures**: You can run multiple capture sessions and analyze them separately\n\n## Error Handling\n\n**Browser doesn't launch:**\n- Ensure Playwright MCP is properly configured\n- Check that the browser binary is installed\n\n**HAR file is empty:**\n- Make sure you performed actions in the browser\n- Some sites may have very few network requests\n\n**HAR file is too large:**\n- This is normal for sites with many static assets\n- Use har_filter.py to reduce it before analysis\n",
        "plugins/reverse-api-engineer/commands/engineer.md": "---\ndescription: Re-analyze existing HAR capture to generate new API client\nargument-hint: \"<run_id|har_path>\"\nallowed-tools: [\"Read\", \"Write\", \"Bash\"]\n---\n\n# Engineer Mode - Re-engineer from Existing HAR\n\nRe-run AI generation on an existing HAR capture. This is useful when you want to regenerate the client with a different approach, extract additional endpoints, or improve the implementation without re-capturing traffic.\n\n## Prerequisites\n\nEnsure the `reverse-engineering-api` skill is loaded for guidance on HAR analysis and code generation.\n\n## Command Arguments\n\n- `run_id_or_path` (required): Either a run ID (e.g., \"abc-123-def\") or direct path to HAR file\n\n## Task Tracking\n\nBefore starting the workflow, create a todo list to track progress:\n\n```python\nTodoWrite([\n  {\"content\": \"Verify HAR file exists\", \"status\": \"pending\", \"activeForm\": \"Verifying HAR file\"},\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"pending\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client code\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate code using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test API client implementation\", \"status\": \"pending\", \"activeForm\": \"Testing implementation\"},\n  {\"content\": \"Generate documentation\", \"status\": \"pending\", \"activeForm\": \"Writing README\"}\n])\n```\n\n**CRITICAL:** Mark each task as `in_progress` when starting, `completed` when done. NEVER skip tasks - complete all 7 steps.\n\n## Workflow\n\n### Step 1: Parse Input Argument\n\nDetermine if the argument is a run_id or a file path:\n\n```python\nimport os\n\narg = \"{argument}\"\n\nif os.path.exists(arg) and arg.endswith('.har'):\n    # Direct HAR file path\n    har_path = arg\n    run_id = None\nelif '/' in arg or '\\\\' in arg:\n    # Looks like a path but doesn't exist\n    Error: \"HAR file not found at: {arg}\"\nelif arg:\n    # Looks like a run_id\n    run_id = arg\n    har_path = f\"~/.reverse-api/runs/har/{run_id}/recording.har\"\nelse:\n    # No argument provided\n    Error: \"Please provide either a run_id or path to HAR file\"\n```\n\n### Step 2: Verify HAR File Exists\n\nCheck if the HAR file exists and is readable:\n\n```bash\nif [ -f {har_path} ]; then\n    echo \"HAR file found: {har_path}\"\n    ls -lh {har_path}\nelse\n    echo \"Error: HAR file not found at {har_path}\"\n    exit 1\nfi\n```\n\nIf using run_id but HAR file doesn't exist:\n```\nError: \"No HAR file found for run_id: {run_id}\n\nExpected location: ~/.reverse-api/runs/har/{run_id}/recording.har\n\nAvailable runs:\n{list runs in ~/.reverse-api/runs/}\"\n```\n\n### Step 3: List Available Runs (if needed)\n\nIf the HAR file is not found and a run_id was provided, list available runs to help the user:\n\n```bash\nls -1 ~/.reverse-api/runs/ | head -10\n```\n\nDisplay:\n```\nAvailable run IDs:\n- abc-123-def (2025-01-01)\n- xyz-789-ghi (2025-01-02)\n...\n\nUse: /reverse-api-engineer:engineer <run_id>\nOr provide direct path: /reverse-api-engineer:engineer /path/to/capture.har\n```\n\n### Step 4: Read Existing Run Metadata (if available)\n\nIf using run_id, try to read metadata from history:\n\n```bash\nif [ -f ~/.reverse-api/history.json ]; then\n    # Read history.json and find entry for this run_id\n    # Extract: task, url, timestamp, original mode\nfi\n```\n\nDisplay context:\n```\nRe-engineering HAR capture:\n- Run ID: {run_id}\n- Original task: {task}\n- Captured on: {timestamp}\n- Original mode: {mode}\n```\n\n### Step 5: Prompt for New Task Description\n\nAsk the user what to focus on for this regeneration:\n\n```\nThe HAR file contains captured API traffic from a previous session.\n\nWhat would you like to generate? (e.g., \"focus on authentication endpoints\", \"create a simpler client\", \"add pagination support\")\n\nPress Enter to use original task: \"{original_task}\"\n```\n\nIf user provides new description, use it. Otherwise, use original task.\n\n### Step 6: Analyze HAR File\n\n**Mark todo in_progress: \"Filter HAR using har_filter.py\"**\n\nFilter the HAR file to remove static assets, analytics, and CDN resources:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py {har_path} --output {output_dir}/filtered.har --stats\n```\n\nRead and display the filtering statistics:\n```\nFiltering HAR file: {har_path}\nTotal entries: {total}\nAPI endpoints found: {filtered_entries}\nRemoved:\n- Static assets: {removed_static}\n- Analytics/tracking: {removed_analytics}\n- CDN resources: {removed_cdn}\n\nAPI patterns detected: {api_patterns_found}\n```\n\n**Mark todo completed**\n\n**Mark todo in_progress: \"Analyze HAR using har_analyze.py\"**\n\nExtract structured endpoint information from filtered HAR:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_analyze.py {output_dir}/filtered.har --output {output_dir}/analysis.json\n```\n\nRead analysis.json and summarize for the user:\n\n```bash\ncat {output_dir}/analysis.json\n```\n\nDisplay summary:\n```\nAnalysis complete!\n\nBase URL: {base_url}\nAuthentication: {authentication.type} ({authentication.description})\nUnique endpoints: {unique_endpoints}\nPagination: {pagination.type if pagination.detected else \"Not detected\"}\n\nEndpoints found:\n{for each endpoint in endpoints:}\n- {endpoint.methods} {endpoint.pattern}\n  Calls observed: {endpoint.calls_observed}\n  Auth required: {endpoint.requires_auth}\n  Query params: {endpoint.query_params.required + endpoint.query_params.optional}\n```\n\n**Mark todo completed**\n\n### Step 7: Generate New Run ID\n\nGenerate a new run ID for this regeneration:\n\n```python\nimport uuid\nnew_run_id = str(uuid.uuid4())\n```\n\nThis keeps the original capture separate from the new generation.\n\n### Step 8: Generate API Client\n\nGenerate a descriptive name for the script based on the task:\n\n```\ntask_name = sanitize(task)  # e.g., \"apple_jobs_api\"\noutput_dir = ./scripts/{task_name}/\n```\n\nCreate output directory:\n```bash\nmkdir -p ./scripts/{task_name}/\n```\n\nGenerate `api_client.py` with the following structure:\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from HAR capture on {date}\n\nOriginal Run ID: {original_run_id}\nOriginal HAR file: {har_path}\nRegenerated Run ID: {new_run_id}\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add detected required headers\n        })\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n\n    # Generated endpoint methods\n    # For each detected endpoint, create a method like:\n\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        {Method description based on endpoint}.\n\n        Args:\n            param: {Parameter description}\n\n        Returns:\n            JSON response data\n\n        Raises:\n            requests.exceptions.RequestException: If request fails\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Add example calls based on captured endpoints\n```\n\nGenerate `README.md`:\n```markdown\n# {Task Name} API Client\n\nAuto-generated Python API client from browser traffic capture.\n\n## Generated From\n\n- **Original Run ID**: {original_run_id}\n- **HAR File**: {har_path}\n- **Regenerated**: {date}\n- **Regeneration Run ID**: {new_run_id}\n- **Base URL**: {base_url}\n\n## Installation\n\n```bash\npip install requests\n```\n\n## Usage\n\n```python\nfrom api_client import {ClassName}Client\n\nclient = {ClassName}Client()\n\n# Example: {endpoint_1}\nresult = client.{method_1}({params})\nprint(result)\n```\n\n## Available Methods\n\n{List all generated methods with descriptions}\n\n## Authentication\n\n{Describe detected authentication mechanism and how to configure}\n\n## Notes\n\n- Regenerated from previous HAR capture\n- Original capture: {original_date}\n- Endpoints based on observed API calls\n- May require authentication tokens/API keys\n- Test thoroughly before production use\n```\n\n### Step 8.5: Validate Generated Code\n\n**Mark todo in_progress: \"Validate code using har_validate.py\"**\n\nValidate the generated API client against the HAR analysis:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_validate.py {output_dir}/api_client.py {output_dir}/analysis.json\n```\n\nCheck the validation score and issues:\n\n**If validation score < 90:**\n1. Read the validation issues carefully\n2. Fix each issue in api_client.py:\n   - Missing endpoints: Add methods for each missing endpoint\n   - Missing auth: Implement authentication from analysis.json\n   - Missing error handling: Add try-except blocks and custom exceptions\n   - Missing type hints: Add type hints to all methods\n3. Save the updated api_client.py\n4. Run validation again\n5. Repeat until score >= 90\n\n**Example validation loop:**\n```\nAttempt 1:\n- Score: 75\n- Issues: 2 missing endpoints, no auth implementation\n- Fix: Add missing endpoints, implement bearer token auth\n- Regenerate api_client.py\n\nAttempt 2:\n- Score: 92\n- Issues: 1 info (minor type hint improvement)\n- Result: PASS (score >= 90)\n```\n\nDisplay validation result:\n```\nValidation complete!\nScore: {score}/100\nCoverage: {coverage.percentage}% ({coverage.endpoints_covered}/{coverage.endpoints_total} endpoints)\nIssues: {summary.errors} errors, {summary.warnings} warnings, {summary.info} info\n\n{if score >= 90:}\n✓ Code validation passed!\n{else:}\n✗ Code validation failed - fixing issues and regenerating...\n```\n\n**Mark todo completed** (only when score >= 90)\n\n### Step 9: Save Run History\n\nUpdate `~/.reverse-api/history.json` with run metadata:\n\n```json\n{\n  \"run_id\": \"{new_run_id}\",\n  \"mode\": \"engineer\",\n  \"task\": \"{task}\",\n  \"source_run_id\": \"{original_run_id}\",\n  \"har_path\": \"{har_path}\",\n  \"timestamp\": \"{ISO timestamp}\",\n  \"output_dir\": \"./scripts/{task_name}/\",\n  \"status\": \"completed\"\n}\n```\n\n### Step 10: Summary\n\nPresent final summary to user:\n\n```\nAPI client re-generated successfully!\n\nOriginal HAR: {har_path}\nOriginal Run ID: {original_run_id}\nNew Run ID: {new_run_id}\n\nGenerated files:\n- ./scripts/{task_name}/api_client.py\n- ./scripts/{task_name}/README.md\n\nDetected endpoints: {count}\nAuthentication: {auth_type}\n\nNext steps:\n1. Review the generated code\n2. Test with: python ./scripts/{task_name}/api_client.py\n3. Compare with previous version (if any)\n4. Integrate into your project\n\nTo regenerate with different focus:\n/reverse-api-engineer:engineer {original_run_id}\n```\n\n## Error Handling\n\n- **HAR file not found**: Provide list of available runs and suggest correct usage\n- **Invalid HAR format**: Check file is valid JSON and follows HAR specification\n- **No API endpoints found**: All entries were filtered out (suggest adjusting filters or recapturing)\n- **Generation fails**: Retry with different approach or analyze HAR manually\n\n## Tips for Users\n\n- **Different approaches**: Try regenerating with different focus areas\n- **Refinement**: Use engineer mode to improve previous generations\n- **Testing**: Compare multiple generated versions to find the best implementation\n- **Documentation**: Each regeneration creates a new run_id for tracking\n- **Original HAR**: The original HAR file is never modified\n\n## Examples\n\n```\n# Using run_id\n/reverse-api-engineer:engineer abc-123-def\n\n# Using direct path\n/reverse-api-engineer:engineer ~/.reverse-api/runs/har/xyz-789/recording.har\n\n# Using relative path\n/reverse-api-engineer:engineer ./captures/myapp.har\n\n# Re-engineer with focus\n/reverse-api-engineer:engineer abc-123-def\n> \"focus on authentication endpoints only\"\n```\n\n## Use Cases\n\n1. **Improve previous generation**: Regenerate with better endpoint detection\n2. **Extract subset**: Focus on specific endpoints from large capture\n3. **Different implementation**: Generate alternative client architecture\n4. **Update documentation**: Regenerate with better docstrings and examples\n5. **Fix issues**: Address problems in previous generation without re-capturing\n",
        "plugins/reverse-api-engineer/commands/manual.md": "---\ndescription: Launch browser with HAR recording, capture traffic manually, then generate Python API client\nargument-hint: \"[task] [url]\"\nallowed-tools: [\"MCP:rae-playwright-mcp\", \"Read\", \"Write\", \"Bash\"]\n---\n\n# Manual Mode - Browser Capture and API Generation\n\nLaunch a browser with HAR recording enabled. The user will navigate manually to trigger the desired API calls. When the browser closes, analyze the captured HAR file and generate a production-ready Python API client.\n\n## Prerequisites\n\nEnsure the `reverse-engineering-api` skill is loaded for guidance on HAR analysis and code generation.\n\n## Command Arguments\n\n- `task` (optional): Description of what to reverse engineer (e.g., \"fetch Apple jobs\", \"scrape product data\")\n- `url` (optional): Starting URL for the browser\n\nIf arguments are not provided, prompt the user interactively.\n\n## Task Tracking\n\nBefore starting the workflow, create a todo list to track progress:\n\n```python\nTodoWrite([\n  {\"content\": \"Launch browser with HAR recording\", \"status\": \"pending\", \"activeForm\": \"Launching browser\"},\n  {\"content\": \"Wait for user to complete manual navigation\", \"status\": \"pending\", \"activeForm\": \"Recording traffic\"},\n  {\"content\": \"Verify HAR capture\", \"status\": \"pending\", \"activeForm\": \"Verifying HAR file\"},\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"pending\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate code using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test implementation\", \"status\": \"pending\", \"activeForm\": \"Testing API client\"},\n  {\"content\": \"Generate documentation\", \"status\": \"pending\", \"activeForm\": \"Writing README\"}\n])\n```\n\n**CRITICAL:** Mark each task as `in_progress` when starting, `completed` when done. NEVER skip tasks - complete all 9 steps.\n\n## Workflow\n\n### Step 1: Gather Task Information\n\nIf `task` argument is not provided:\n```\nAsk: \"What would you like to reverse engineer? (e.g., 'fetch job listings from Company X')\"\n```\n\nIf `url` argument is not provided:\n```\nAsk: \"What URL should I open? (optional, press Enter to skip)\"\n```\n\n### Step 2: Generate Run ID and Setup Paths\n\nGenerate a unique run ID using UUID format:\n```\nrun_id = uuid4() (e.g., \"abc-123-def-456\")\n```\n\nSetup paths:\n```\nhar_dir = ~/.reverse-api/runs/har/{run_id}/\nhar_path = {har_dir}/recording.har\n```\n\nEnsure directory exists:\n```bash\nmkdir -p ~/.reverse-api/runs/har/{run_id}/\n```\n\n### Step 3: Launch Browser with HAR Recording\n\nUse the Playwright MCP `rae-playwright-mcp` to launch a browser with HAR recording:\n\n```\nCall MCP tool: playwright_navigate\nParameters:\n  - url: {url} or \"about:blank\" if no URL provided\n  - options:\n      - record_har: true\n      - har_path: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\nInform the user:\n```\nBrowser launched with HAR recording enabled.\nNavigate to the website and interact with it to trigger API calls.\nClose the browser when you're done to proceed with analysis.\n\nHAR will be saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n### Step 4: Wait for Browser to Close\n\nMonitor the browser session. When it closes, the HAR file will be saved automatically.\n\nVerify HAR file exists:\n```bash\nls -lh ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\nIf file doesn't exist or is empty:\n```\nError: \"HAR file not found or empty. Please ensure you interacted with the website before closing the browser.\"\nExit with error\n```\n\n### Step 5: Analyze HAR File\n\n**Mark todo in_progress: \"Filter HAR using har_filter.py\"**\n\nFilter the HAR file to remove static assets, analytics, and CDN resources:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py ~/.reverse-api/runs/har/{run_id}/recording.har --output {output_dir}/filtered.har --stats\n```\n\nRead and display the filtering statistics:\n```\nFiltering complete!\nTotal entries: {total}\nAPI endpoints found: {filtered_entries}\nRemoved:\n- Static assets: {removed_static}\n- Analytics/tracking: {removed_analytics}\n- CDN resources: {removed_cdn}\n\nAPI patterns detected: {api_patterns_found}\n```\n\n**Mark todo completed**\n\n**Mark todo in_progress: \"Analyze HAR using har_analyze.py\"**\n\nExtract structured endpoint information from filtered HAR:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_analyze.py {output_dir}/filtered.har --output {output_dir}/analysis.json\n```\n\nRead analysis.json and summarize for the user:\n\n```bash\ncat {output_dir}/analysis.json\n```\n\nDisplay summary:\n```\nAnalysis complete!\n\nBase URL: {base_url}\nAuthentication: {authentication.type} ({authentication.description})\nUnique endpoints: {unique_endpoints}\nPagination: {pagination.type if pagination.detected else \"Not detected\"}\n\nEndpoints found:\n{for each endpoint in endpoints:}\n- {endpoint.methods} {endpoint.pattern}\n  Calls observed: {endpoint.calls_observed}\n  Auth required: {endpoint.requires_auth}\n  Query params: {endpoint.query_params.required + endpoint.query_params.optional}\n```\n\n**Mark todo completed**\n\n### Step 6: Generate API Client\n\nGenerate a descriptive name for the script based on the task:\n```\ntask_name = sanitize(task)  # e.g., \"apple_jobs_api\"\noutput_dir = ./scripts/{task_name}/\n```\n\nCreate output directory:\n```bash\nmkdir -p ./scripts/{task_name}/\n```\n\nGenerate `api_client.py` with the following structure:\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from HAR capture on {date}\n\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add detected required headers\n        })\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n\n    # Generated endpoint methods\n    # For each detected endpoint, create a method like:\n\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        {Method description based on endpoint}.\n\n        Args:\n            param: {Parameter description}\n\n        Returns:\n            JSON response data\n\n        Raises:\n            requests.exceptions.RequestException: If request fails\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Add example calls based on captured endpoints\n```\n\nGenerate `README.md`:\n```markdown\n# {Task Name} API Client\n\nAuto-generated Python API client from browser traffic capture.\n\n## Generated From\n\n- **Run ID**: {run_id}\n- **HAR File**: ~/.reverse-api/runs/har/{run_id}/recording.har\n- **Date**: {date}\n- **Base URL**: {base_url}\n\n## Installation\n\n```bash\npip install requests\n```\n\n## Usage\n\n```python\nfrom api_client import {ClassName}Client\n\nclient = {ClassName}Client()\n\n# Example: {endpoint_1}\nresult = client.{method_1}({params})\nprint(result)\n```\n\n## Available Methods\n\n{List all generated methods with descriptions}\n\n## Authentication\n\n{Describe detected authentication mechanism and how to configure}\n\n## Notes\n\n- Generated from captured browser traffic\n- Endpoints based on observed API calls\n- May require authentication tokens/API keys\n- Test thoroughly before production use\n```\n\n### Step 6.5: Validate Generated Code\n\n**Mark todo in_progress: \"Validate code using har_validate.py\"**\n\nValidate the generated API client against the HAR analysis:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_validate.py {output_dir}/api_client.py {output_dir}/analysis.json\n```\n\nCheck the validation score and issues:\n\n**If validation score < 90:**\n1. Read the validation issues carefully\n2. Fix each issue in api_client.py:\n   - Missing endpoints: Add methods for each missing endpoint\n   - Missing auth: Implement authentication from analysis.json\n   - Missing error handling: Add try-except blocks and custom exceptions\n   - Missing type hints: Add type hints to all methods\n3. Save the updated api_client.py\n4. Run validation again\n5. Repeat until score >= 90\n\n**Example validation loop:**\n```\nAttempt 1:\n- Score: 75\n- Issues: 2 missing endpoints, no auth implementation\n- Fix: Add missing endpoints, implement bearer token auth\n- Regenerate api_client.py\n\nAttempt 2:\n- Score: 92\n- Issues: 1 info (minor type hint improvement)\n- Result: PASS (score >= 90)\n```\n\nDisplay validation result:\n```\nValidation complete!\nScore: {score}/100\nCoverage: {coverage.percentage}% ({coverage.endpoints_covered}/{coverage.endpoints_total} endpoints)\nIssues: {summary.errors} errors, {summary.warnings} warnings, {summary.info} info\n\n{if score >= 90:}\n✓ Code validation passed!\n{else:}\n✗ Code validation failed - fixing issues and regenerating...\n```\n\n**Mark todo completed** (only when score >= 90)\n\n### Step 7: Save Run History\n\nUpdate `~/.reverse-api/history.json` with run metadata:\n\n```json\n{\n  \"run_id\": \"{run_id}\",\n  \"mode\": \"manual\",\n  \"task\": \"{task}\",\n  \"url\": \"{url}\",\n  \"timestamp\": \"{ISO timestamp}\",\n  \"har_path\": \"~/.reverse-api/runs/har/{run_id}/recording.har\",\n  \"output_dir\": \"./scripts/{task_name}/\",\n  \"status\": \"completed\"\n}\n```\n\n### Step 8: Summary\n\nPresent final summary to user:\n```\nAPI client generated successfully!\n\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\nGenerated files:\n- ./scripts/{task_name}/api_client.py\n- ./scripts/{task_name}/README.md\n\nDetected endpoints: {count}\nAuthentication: {auth_type}\n\nNext steps:\n1. Review the generated code\n2. Test with: python ./scripts/{task_name}/api_client.py\n3. Integrate into your project\n```\n\n## Error Handling\n\n- **Browser launch fails**: Check Playwright MCP is running and accessible\n- **HAR file empty**: User didn't interact with website, or no network traffic captured\n- **No API endpoints found**: All entries were filtered out (adjust filters or capture more traffic)\n- **Generation fails**: Use `/reverse-api-engineer:engineer {run_id}` to retry with different approach\n\n## Tips for Users\n\n- **Login flows**: Log in during capture to record authentication\n- **Pagination**: Navigate through pages to capture query parameter patterns\n- **Different actions**: Create, read, update, delete to capture all CRUD endpoints\n- **Multiple captures**: You can run manual mode multiple times for different flows\n- **Re-engineer**: Use `/reverse-api-engineer:engineer {run_id}` to regenerate from same capture\n\n## Examples\n\n```\n/reverse-api-engineer:manual \"fetch Apple jobs\" https://jobs.apple.com\n/reverse-api-engineer:manual \"scrape product data\"\n/reverse-api-engineer:manual\n```\n",
        "plugins/reverse-api-engineer/skills/reverse-engineering-api/CHANGELOG.md": "# Changelog\n\nAll notable changes to the Reverse Engineering API skill will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [1.0.0] - 2025-12-31\n\n### Added\n\n- Initial release of the Reverse Engineering API skill\n- Core SKILL.md with 4-phase workflow:\n  - Phase 1: Browser Capture with HAR Recording\n  - Phase 2: HAR Analysis\n  - Phase 3: API Client Generation\n  - Phase 4: Testing & Refinement\n- Reference documentation:\n  - `references/AUTH_PATTERNS.md` - 8 authentication patterns with code examples\n  - `references/HAR_ANALYSIS.md` - HAR parsing and endpoint extraction guide\n- Playwright MCP integration for browser control\n- Support for HAR files at `~/.reverse-api/runs/har/{run_id}/`\n- Decision tree for workflow routing\n- Python API client generation templates\n- Iteration protocol with up to 5 retry attempts\n- Bot detection handling with Playwright fallback\n\n### Dependencies\n\nScripts require:\n- `aiohttp` - Async HTTP client (required for all scripts)\n- `playwright` - Browser automation (required for mapper.py)\n- `beautifulsoup4` - HTML parsing (optional for crawler.py, falls back to regex)\n",
        "plugins/reverse-api-engineer/skills/reverse-engineering-api/SKILL.md": "---\nname: reverse-engineering-api\ndescription: Reverse engineer web APIs by capturing browser traffic (HAR files) and generating production-ready Python API clients. Use when the user wants to create an API client for a website, automate web interactions, or understand undocumented APIs. Activate on tasks mentioning \"reverse engineer\", \"API client\", \"HAR file\", \"capture traffic\", or \"automate website\".\ncompatibility: Requires Playwright MCP for browser control. HAR files saved to ~/.reverse-api/runs/har/{run_id}\nmetadata:\n  author: reverse-api-engineer\n  version: \"1.0\"\nallowed-tools: Bash(python:*) Bash(uv:*) Read Write Edit\n---\n\n# Reverse Engineering API Skill\n\nThis skill enables you to reverse engineer web APIs by:\n1. Controlling a browser with HAR recording enabled\n2. Analyzing captured network traffic\n3. Generating production-ready Python API clients\n\n## Prerequisites\n\n- **Playwright MCP**: You must have access to Playwright MCP tools for browser control\n- **HAR Recording**: The browser must be configured to record HAR files\n- **Python**: For running analysis scripts and generated clients\n\n## Workflow Overview\n\n```\n[User Task] -> [Browser Capture] -> [HAR Analysis] -> [API Client Generation] -> [Testing & Refinement]\n```\n\n## Phase 0: Preparation (Using HAR Helper Scripts)\n\n### Available Helper Scripts\n\nThis skill provides Python utilities for HAR analysis located at:\n\n**Script Directory:** `plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/`\n\n**Available Scripts:**\n- `har_filter.py` - Filter HAR files to API endpoints only\n- `har_analyze.py` - Extract structured endpoint information\n- `har_validate.py` - Validate generated code against HAR analysis\n- `har_utils.py` - Shared utility functions\n\n### Script Usage Pattern\n\nUse these scripts in sequence for optimal code generation:\n\n```bash\n# 1. Filter HAR to remove noise (static assets, analytics, CDN)\npython {SKILL_DIR}/scripts/har_filter.py {har_path} --output filtered.har --stats\n\n# 2. Analyze endpoints and extract patterns\npython {SKILL_DIR}/scripts/har_analyze.py filtered.har --output analysis.json\n\n# 3. Read analysis for code generation guidance\ncat analysis.json\n\n# 4. Generate API client code based on analysis\n\n# 5. Validate generated code\npython {SKILL_DIR}/scripts/har_validate.py api_client.py analysis.json\n```\n\n### Why Use These Scripts?\n\n**har_filter.py benefits:**\n- Reduces HAR file size by 80-90% (removes noise)\n- Focuses analysis on actual API calls\n- Significantly improves code generation quality\n- Outputs statistics showing what was filtered\n\n**har_analyze.py benefits:**\n- Provides structured endpoint information\n- Detects authentication patterns automatically\n- Identifies pagination mechanisms\n- Extracts request/response schemas\n- Groups endpoints by pattern\n\n**har_validate.py benefits:**\n- Ensures all endpoints are implemented\n- Validates authentication handling\n- Checks for proper error handling\n- Calculates coverage score (must be >= 90)\n- Identifies missing features\n\n### Task Tracking\n\nUse TodoWrite to track workflow progress:\n- Mark tasks as `pending`, `in_progress`, or `completed`\n- Only ONE task should be `in_progress` at a time\n- Complete ALL tasks - never stop early\n\n**Example TodoWrite usage:**\n```python\nTodoWrite([\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"in_progress\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test implementation\", \"status\": \"pending\", \"activeForm\": \"Testing API client\"}\n])\n```\n\n**CRITICAL:** Task tracking ensures complete workflow execution. Never skip tasks or stop early.\n\n## Phase 1: Browser Capture with HAR Recording\n\n### Starting the Browser\n\nWhen starting a browser session for API capture:\n\n1. Launch browser with HAR recording enabled via Playwright MCP\n2. Generate a unique run ID: `{run_id}`\n3. Configure HAR output path: `~/.reverse-api/runs/har/{run_id}/recording.har`\n\n### During Capture\n\nNavigate autonomously to trigger the API calls needed:\n- Login flows (capture authentication)\n- Data fetching (capture GET endpoints)\n- Form submissions (capture POST/PUT endpoints)\n- Pagination (capture query parameter patterns)\n\n### On Browser Close\n\nWhen the browser closes, note the HAR file location:\n```\nHAR file saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n## Phase 2: HAR Analysis\n\n### Reading the HAR File\n\nHAR files are JSON with this structure:\n```json\n{\n  \"log\": {\n    \"entries\": [\n      {\n        \"request\": {\n          \"method\": \"GET|POST|PUT|DELETE\",\n          \"url\": \"https://api.example.com/endpoint\",\n          \"headers\": [...],\n          \"postData\": {...}\n        },\n        \"response\": {\n          \"status\": 200,\n          \"headers\": [...],\n          \"content\": {...}\n        }\n      }\n    ]\n  }\n}\n```\n\n### Filtering Relevant Entries\n\nFilter out noise by excluding:\n- Static assets: `.js`, `.css`, `.png`, `.jpg`, `.svg`, `.woff`, `.ico`\n- Analytics: `google-analytics`, `segment`, `mixpanel`, `hotjar`\n- Ads: `doubleclick`, `adsense`, `facebook.com/tr`\n- CDN resources: `cloudflare`, `cdn.`, `static.`\n\nFocus on:\n- API endpoints: `/api/`, `/v1/`, `/v2/`, `/graphql`\n- XHR/Fetch requests with JSON responses\n- Requests with authentication headers\n\n### Extracting Patterns\n\nFor each relevant endpoint, extract:\n\n1. **URL Pattern**: Base URL, path, query parameters\n2. **Method**: GET, POST, PUT, DELETE, PATCH\n3. **Headers**: \n   - Required headers (Authorization, Content-Type, custom headers)\n   - Optional headers (User-Agent, Accept)\n4. **Request Body**: JSON schema, form data structure\n5. **Response Schema**: JSON structure, status codes\n6. **Authentication**: See [references/AUTH_PATTERNS.md](references/AUTH_PATTERNS.md)\n\n## Phase 3: API Client Generation\n\n### Code Structure\n\nGenerate a Python module with:\n\n```\n{output_dir}/\n  api_client.py    # Main API client class\n  README.md        # Usage documentation\n```\n\n### api_client.py Template\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from HAR capture on {date}\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n    \n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n    \n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add other required headers\n        })\n    \n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n    \n    # Generated endpoint methods go here\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        Fetch example data.\n        \n        Args:\n            param: Description of parameter\n            \n        Returns:\n            JSON response data\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Example calls\n```\n\n### Code Quality Requirements\n\nAll generated code must include:\n\n1. **Type hints** for all parameters and return values\n2. **Docstrings** for all public methods\n3. **Error handling** with try-except blocks\n4. **Logging** for debugging\n5. **Session management** for connection reuse\n6. **Authentication handling** based on detected patterns\n\n## Phase 4: Testing & Refinement\n\n### Testing the Generated Client\n\nAfter generating the client:\n\n1. Run the example usage section\n2. Verify responses match expected structure\n3. Handle any errors encountered\n\n### Iteration Protocol\n\nYou have up to 5 attempts to fix issues:\n\n```\nAttempt 1: Initial implementation\n  - What was tried\n  - What failed (if anything)\n  - What was changed\n\nAttempt 2: Refinement\n  ...\n```\n\n### Common Issues\n\n| Issue | Solution |\n|-------|----------|\n| 403 Forbidden | Add missing headers, check authentication |\n| Bot detection | Switch to Playwright with stealth mode |\n| Rate limiting | Add delays, respect Retry-After headers |\n| Session expiry | Implement token refresh logic |\n| CORS errors | Use server-side requests (not applicable to Python) |\n\n## Domain Discovery (Optional)\n\nBefore capture, you may want to map the domain to understand its structure.\n\n### Using the Mapper Script\n\nRun `scripts/mapper.py` to quickly discover:\n- All pages on the domain or subdomains\n- Subdomains\n\nIt is useful for generalizing your scripts on multitenants websites.\n\nFor example, for Ashby ATS or Workday it's useful to find other companies using this ATS when trying to generalize your script.\n\n```bash\npython scripts/mapper.py https://example.com\n```\n\n### Using the Sitemap Parser\n\nRun `scripts/sitemap.py` to extract URLs from sitemaps:\n\n```bash\npython scripts/sitemap.py https://example.com\n```\n\n## Output Locations\n\n- **HAR files**: `~/.reverse-api/runs/har/{run_id}/`\n- **Generated scripts**: `./{task_name}`\n\n## Example Session\n\n```\nUser: \"Create an API client for the Apple Jobs website\"\n\n\n1. [Browser Capture]\n   Launch browser with HAR recording\n   Navigate to jobs.apple.com\n   Perform search, browse listings\n   Close browser\n   HAR saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n\n   Note: you can monitor browser requests with the Playwright MCP\n\n2. [HAR Analysis]\n   Found endpoints:\n   - GET /api/role/search?query=...\n   - GET /api/role/{id}\n   Authentication: None required (public API)\n\n3. [Generate Client]\n   Create : {task_name}/api_client.py\n   \n4. [Test]\n   Ran example usage - Success!\n   \n5. [Summary]\n   Generated Apple Jobs API client with:\n   - search_roles(query, location, page)\n   - get_role(role_id)\n   Files: ./{task_name}/\n```\n",
        "plugins/reverse-api-engineer/skills/reverse-engineering-api/references/AUTH_PATTERNS.md": "# Authentication Patterns Reference\n\nThis document covers common authentication patterns found in web APIs and how to handle them when generating API clients. These patterns align with the reverse-api-engineer codebase conventions.\n\n## Overview\n\nWhen analyzing HAR files, identify authentication by checking:\n- Request headers: `Authorization`, `X-API-Key`, `X-Token`, `Cookie`\n- Response headers: `Set-Cookie`, `X-CSRF-Token`\n- Request body: `username`, `password`, `token`, `api_key`\n- Response body: `access_token`, `refresh_token`, `session_id`\n- Query parameters: `key`, `api_key`, `token`, `access_token`\n- Login endpoints: `/login`, `/auth`, `/oauth/token`, `/api/auth`\n\n---\n\n## 1. Bearer Token (JWT)\n\n### Detection in HAR\n```json\n{\n  \"name\": \"Authorization\",\n  \"value\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n```\n\n### Generated Client Pattern\n```python\n\"\"\"\nAPI client with Bearer token authentication.\nGenerated by reverse-api-engineer.\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass APIClient:\n    \"\"\"API client with Bearer token authentication.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        token: str,\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.token = token\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with authentication headers.\"\"\"\n        self.session.headers.update({\n            \"Authorization\": f\"Bearer {self.token}\",\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n        })\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n```\n\n### Token Refresh Pattern\nIf you detect a `/refresh` or `/token/refresh` endpoint in the HAR:\n```python\ndef refresh_token(self, refresh_token: str) -> str:\n    \"\"\"\n    Refresh the access token.\n    \n    Args:\n        refresh_token: The refresh token from initial auth\n        \n    Returns:\n        New access token\n    \"\"\"\n    response = self._request(\"POST\", \"/auth/refresh\", json={\n        \"refresh_token\": refresh_token\n    })\n    data = response.json()\n    self.token = data[\"access_token\"]\n    self.session.headers[\"Authorization\"] = f\"Bearer {self.token}\"\n    return self.token\n```\n\n---\n\n## 2. API Key\n\n### Detection in HAR\nHeader-based:\n```json\n{\"name\": \"X-API-Key\", \"value\": \"sk_live_xxxxx\"}\n```\n\nQuery parameter:\n```json\n{\"name\": \"api_key\", \"value\": \"xxxxx\"}\n```\n\n### Generated Client Pattern (Header)\n```python\nclass APIClient:\n    \"\"\"API client with API key authentication.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        api_key: str,\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.api_key = api_key\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with API key header.\"\"\"\n        self.session.headers.update({\n            \"X-API-Key\": self.api_key,\n            \"Accept\": \"application/json\",\n        })\n```\n\n### Generated Client Pattern (Query Parameter)\n```python\nclass APIClient:\n    \"\"\"API client with API key in query parameters.\"\"\"\n\n    def __init__(self, base_url: str, api_key: str):\n        self.base_url = base_url.rstrip(\"/\")\n        self.api_key = api_key\n        self.session = requests.Session()\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make request with API key in query params.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        params = kwargs.pop(\"params\", {})\n        params[\"api_key\"] = self.api_key\n        try:\n            response = self.session.request(method, url, params=params, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n```\n\n---\n\n## 3. Session Cookies\n\n### Detection in HAR\nLook for `Set-Cookie` in response headers after login:\n```json\n{\"name\": \"Set-Cookie\", \"value\": \"sessionid=abc123; Path=/; HttpOnly\"}\n```\n\nCommon cookie names: `sessionid`, `PHPSESSID`, `connect.sid`, `_session`\n\n### Generated Client Pattern\n```python\nclass APIClient:\n    \"\"\"API client with session-based authentication.\"\"\"\n\n    def __init__(self, base_url: str):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = requests.Session()  # Automatically handles cookies\n\n    def login(self, username: str, password: str) -> bool:\n        \"\"\"\n        Authenticate with username and password.\n        \n        Args:\n            username: User's username\n            password: User's password\n            \n        Returns:\n            True if login successful\n        \"\"\"\n        try:\n            response = self.session.post(\n                f\"{self.base_url}/login\",\n                data={\"username\": username, \"password\": password}\n            )\n            response.raise_for_status()\n            return True\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Login failed: {e}\")\n            return False\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make request with session cookies.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n```\n\n---\n\n## 4. CSRF Tokens\n\n### Detection in HAR\nHidden form field in HTML:\n```html\n<input type=\"hidden\" name=\"csrf_token\" value=\"...\">\n```\n\nHeader in requests:\n```json\n{\"name\": \"X-CSRF-Token\", \"value\": \"...\"}\n```\n\nCookie:\n```json\n{\"name\": \"csrftoken\", \"value\": \"...\"}\n```\n\n### Generated Client Pattern\n```python\nimport re\n\n\nclass APIClient:\n    \"\"\"API client with CSRF token handling.\"\"\"\n\n    def __init__(self, base_url: str):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = requests.Session()\n        self.csrf_token: Optional[str] = None\n\n    def _get_csrf_token(self) -> str:\n        \"\"\"Fetch CSRF token from cookie or page.\"\"\"\n        # Option 1: From cookie\n        if \"csrftoken\" in self.session.cookies:\n            return self.session.cookies[\"csrftoken\"]\n\n        # Option 2: From page content\n        response = self.session.get(f\"{self.base_url}/\")\n        match = re.search(r'csrf_token[\"\\']:\\s*[\"\\']([^\"\\']+)', response.text)\n        if match:\n            return match.group(1)\n        \n        # Option 3: From meta tag\n        match = re.search(r'<meta name=\"csrf-token\" content=\"([^\"]+)\"', response.text)\n        if match:\n            return match.group(1)\n        \n        return \"\"\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make request with CSRF token for mutating operations.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        \n        # Add CSRF token for POST, PUT, DELETE, PATCH\n        if method.upper() in (\"POST\", \"PUT\", \"DELETE\", \"PATCH\"):\n            if not self.csrf_token:\n                self.csrf_token = self._get_csrf_token()\n            headers = kwargs.pop(\"headers\", {})\n            headers[\"X-CSRF-Token\"] = self.csrf_token\n            kwargs[\"headers\"] = headers\n        \n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n```\n\n---\n\n## 5. OAuth 2.0\n\n### Detection in HAR\nLook for:\n- Token endpoint: `/oauth/token`, `/auth/token`\n- `grant_type` in request body\n- `access_token` and `refresh_token` in response\n\n### Generated Client Pattern (Client Credentials)\n```python\nclass APIClient:\n    \"\"\"API client with OAuth 2.0 Client Credentials flow.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        client_id: str,\n        client_secret: str,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.access_token: Optional[str] = None\n        self.refresh_token: Optional[str] = None\n        self.session = requests.Session()\n\n    def authenticate(self) -> bool:\n        \"\"\"\n        Authenticate using Client Credentials flow.\n        \n        Returns:\n            True if authentication successful\n        \"\"\"\n        try:\n            response = requests.post(\n                f\"{self.base_url}/oauth/token\",\n                data={\n                    \"grant_type\": \"client_credentials\",\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                }\n            )\n            response.raise_for_status()\n            data = response.json()\n            self.access_token = data[\"access_token\"]\n            self.refresh_token = data.get(\"refresh_token\")\n            self.session.headers[\"Authorization\"] = f\"Bearer {self.access_token}\"\n            return True\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"OAuth authentication failed: {e}\")\n            return False\n```\n\n---\n\n## 6. Basic Authentication\n\n### Detection in HAR\n```json\n{\"name\": \"Authorization\", \"value\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\"}\n```\n\nThe value is base64 encoded `username:password`.\n\n### Generated Client Pattern\n```python\nfrom requests.auth import HTTPBasicAuth\n\n\nclass APIClient:\n    \"\"\"API client with HTTP Basic authentication.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        username: str,\n        password: str,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = requests.Session()\n        self.session.auth = HTTPBasicAuth(username, password)\n        self.session.headers.update({\n            \"Accept\": \"application/json\",\n        })\n```\n\n---\n\n## 7. Custom Headers\n\n### Detection in HAR\nNon-standard headers like:\n```json\n{\"name\": \"X-App-Token\", \"value\": \"...\"}\n{\"name\": \"X-Client-Id\", \"value\": \"...\"}\n{\"name\": \"X-Request-Id\", \"value\": \"...\"}\n```\n\n### Generated Client Pattern\n```python\nclass APIClient:\n    \"\"\"API client with custom header authentication.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        app_token: str,\n        client_id: str,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = requests.Session()\n        self._setup_session(app_token, client_id)\n\n    def _setup_session(self, app_token: str, client_id: str):\n        \"\"\"Configure session with custom headers.\"\"\"\n        self.session.headers.update({\n            \"X-App-Token\": app_token,\n            \"X-Client-Id\": client_id,\n            \"Accept\": \"application/json\",\n        })\n```\n\n---\n\n## 8. Signed Requests (HMAC)\n\n### Detection in HAR\nLook for:\n- Signature headers: `X-Signature`, `X-Hmac-Signature`\n- Timestamp headers: `X-Timestamp`, `X-Request-Timestamp`\n- Nonce headers: `X-Nonce`\n\n### Generated Client Pattern\n```python\nimport hmac\nimport hashlib\nimport time\nimport uuid\n\n\nclass APIClient:\n    \"\"\"API client with HMAC request signing.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        api_key: str,\n        secret: str,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.api_key = api_key\n        self.secret = secret\n        self.session = requests.Session()\n\n    def _sign_request(\n        self,\n        method: str,\n        path: str,\n        body: str = \"\",\n    ) -> Dict[str, str]:\n        \"\"\"\n        Generate signature headers for request.\n        \n        Args:\n            method: HTTP method\n            path: Request path\n            body: Request body as string\n            \n        Returns:\n            Dictionary of signature headers\n        \"\"\"\n        timestamp = str(int(time.time()))\n        nonce = str(uuid.uuid4())\n        message = f\"{method}{path}{timestamp}{nonce}{body}\"\n        \n        signature = hmac.new(\n            self.secret.encode(),\n            message.encode(),\n            hashlib.sha256\n        ).hexdigest()\n\n        return {\n            \"X-API-Key\": self.api_key,\n            \"X-Timestamp\": timestamp,\n            \"X-Nonce\": nonce,\n            \"X-Signature\": signature,\n        }\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make signed request.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        body = kwargs.get(\"json\", kwargs.get(\"data\", \"\"))\n        if isinstance(body, dict):\n            import json\n            body = json.dumps(body)\n        \n        headers = kwargs.pop(\"headers\", {})\n        headers.update(self._sign_request(method, endpoint, body))\n        kwargs[\"headers\"] = headers\n        \n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n```\n\n---\n\n## Priority Order\n\nWhen multiple auth methods are detected in HAR, use this priority:\n\n1. **OAuth 2.0** - Most robust for production\n2. **Bearer Token** - Simple and stateless  \n3. **Session Cookies** - Required for some sites\n4. **API Key** - Simple but less secure\n5. **Basic Auth** - Only if no other option\n\n---\n\n## Bot Detection Fallback\n\nIf `requests` fails with 403/captcha, switch to Playwright:\n\n```python\nfrom playwright.sync_api import sync_playwright\n\n\nclass PlaywrightClient:\n    \"\"\"Playwright-based client for sites with bot detection.\"\"\"\n\n    def __init__(self, base_url: str):\n        self.base_url = base_url.rstrip(\"/\")\n        self.playwright = None\n        self.browser = None\n        self.context = None\n        self.page = None\n\n    def __enter__(self):\n        self.playwright = sync_playwright().start()\n        self.browser = self.playwright.chromium.launch(headless=True)\n        self.context = self.browser.new_context()\n        self.page = self.context.new_page()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.browser:\n            self.browser.close()\n        if self.playwright:\n            self.playwright.stop()\n\n    def get(self, endpoint: str) -> dict:\n        \"\"\"Make GET request via browser.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        response = self.page.goto(url)\n        return self.page.evaluate(\"() => JSON.parse(document.body.innerText)\")\n```\n",
        "plugins/reverse-api-engineer/skills/reverse-engineering-api/references/HAR_ANALYSIS.md": "# HAR File Analysis Reference\n\nThis document covers how to analyze HAR (HTTP Archive) files to extract API endpoints and patterns.\n\n## HAR File Structure\n\n```json\n{\n  \"log\": {\n    \"version\": \"1.2\",\n    \"creator\": { \"name\": \"Browser\", \"version\": \"1.0\" },\n    \"entries\": [\n      {\n        \"startedDateTime\": \"2025-01-01T12:00:00.000Z\",\n        \"time\": 150,\n        \"request\": { ... },\n        \"response\": { ... },\n        \"cache\": {},\n        \"timings\": { ... }\n      }\n    ]\n  }\n}\n```\n\n## Entry Structure\n\n### Request Object\n```json\n{\n  \"method\": \"POST\",\n  \"url\": \"https://api.example.com/v1/users\",\n  \"httpVersion\": \"HTTP/2.0\",\n  \"headers\": [\n    { \"name\": \"Content-Type\", \"value\": \"application/json\" },\n    { \"name\": \"Authorization\", \"value\": \"Bearer xxx\" }\n  ],\n  \"queryString\": [\n    { \"name\": \"page\", \"value\": \"1\" }\n  ],\n  \"postData\": {\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"name\\\": \\\"John\\\"}\"\n  },\n  \"cookies\": [\n    { \"name\": \"session\", \"value\": \"abc123\" }\n  ]\n}\n```\n\n### Response Object\n```json\n{\n  \"status\": 200,\n  \"statusText\": \"OK\",\n  \"headers\": [\n    { \"name\": \"Content-Type\", \"value\": \"application/json\" }\n  ],\n  \"content\": {\n    \"size\": 1024,\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"id\\\": 1, \\\"name\\\": \\\"John\\\"}\"\n  }\n}\n```\n\n## Filtering Entries\n\n### URLs to Exclude\n\n**Static Assets:**\n- `.js`, `.css`, `.map`\n- `.png`, `.jpg`, `.jpeg`, `.gif`, `.svg`, `.webp`, `.ico`\n- `.woff`, `.woff2`, `.ttf`, `.eot`\n- `.mp4`, `.webm`, `.mp3`\n\n**Analytics & Tracking:**\n- `google-analytics.com`\n- `googletagmanager.com`\n- `segment.io`, `segment.com`\n- `mixpanel.com`\n- `hotjar.com`\n- `facebook.com/tr`\n- `doubleclick.net`\n- `adsense`\n\n**CDN Resources:**\n- `cdn.`, `static.`, `assets.`\n- `cloudflare.com`\n- `cloudfront.net`\n- `akamai`\n\n### URLs to Focus On\n\n**API Patterns:**\n- `/api/`\n- `/v1/`, `/v2/`, `/v3/`\n- `/graphql`\n- `/rest/`\n- `/data/`\n\n**Content Types:**\n- `application/json`\n- `application/xml`\n- `text/plain` (sometimes API responses)\n\n## Extracting Endpoints\n\n### Step 1: Parse HAR\n```python\nimport json\nfrom urllib.parse import urlparse, parse_qs\n\ndef load_har(path: str) -> dict:\n    with open(path) as f:\n        return json.load(f)\n\nhar = load_har(\"capture.har\")\nentries = har[\"log\"][\"entries\"]\n```\n\n### Step 2: Filter Relevant Entries\n```python\nSKIP_EXTENSIONS = {'.js', '.css', '.png', '.jpg', '.svg', '.woff', '.ico'}\nSKIP_DOMAINS = {'google-analytics.com', 'facebook.com', 'segment.io'}\n\ndef is_relevant(entry: dict) -> bool:\n    url = entry[\"request\"][\"url\"]\n    parsed = urlparse(url)\n    \n    # Skip static assets\n    if any(parsed.path.endswith(ext) for ext in SKIP_EXTENSIONS):\n        return False\n    \n    # Skip tracking\n    if any(d in parsed.netloc for d in SKIP_DOMAINS):\n        return False\n    \n    # Check for API patterns\n    if any(p in parsed.path for p in ['/api/', '/v1/', '/graphql']):\n        return True\n    \n    # Check content type\n    response = entry[\"response\"]\n    content_type = next(\n        (h[\"value\"] for h in response[\"headers\"] \n         if h[\"name\"].lower() == \"content-type\"),\n        \"\"\n    )\n    if \"application/json\" in content_type:\n        return True\n    \n    return False\n\napi_entries = [e for e in entries if is_relevant(e)]\n```\n\n### Step 3: Group by Endpoint\n```python\nfrom collections import defaultdict\n\nendpoints = defaultdict(list)\n\nfor entry in api_entries:\n    request = entry[\"request\"]\n    url = request[\"url\"]\n    parsed = urlparse(url)\n    \n    # Create endpoint key (method + path without query)\n    method = request[\"method\"]\n    path = parsed.path\n    key = f\"{method} {path}\"\n    \n    endpoints[key].append(entry)\n\n# Analyze each endpoint\nfor key, entries in endpoints.items():\n    print(f\"\\n{key}\")\n    print(f\"  Calls: {len(entries)}\")\n    \n    # Get unique query parameters\n    all_params = set()\n    for e in entries:\n        for param in e[\"request\"].get(\"queryString\", []):\n            all_params.add(param[\"name\"])\n    if all_params:\n        print(f\"  Query params: {', '.join(all_params)}\")\n```\n\n### Step 4: Extract Request Schema\n```python\ndef extract_request_schema(entries: list) -> dict:\n    \"\"\"Infer request body schema from multiple calls.\"\"\"\n    schemas = []\n    \n    for entry in entries:\n        post_data = entry[\"request\"].get(\"postData\", {})\n        if post_data.get(\"mimeType\") == \"application/json\":\n            try:\n                body = json.loads(post_data.get(\"text\", \"{}\"))\n                schemas.append(body)\n            except:\n                pass\n    \n    if not schemas:\n        return {}\n    \n    # Merge schemas to find common fields\n    all_keys = set()\n    for s in schemas:\n        if isinstance(s, dict):\n            all_keys.update(s.keys())\n    \n    return {\n        \"type\": \"object\",\n        \"properties\": {k: {\"type\": \"unknown\"} for k in all_keys}\n    }\n```\n\n### Step 5: Extract Response Schema\n```python\ndef extract_response_schema(entries: list) -> dict:\n    \"\"\"Infer response schema from multiple calls.\"\"\"\n    for entry in entries:\n        content = entry[\"response\"].get(\"content\", {})\n        if content.get(\"mimeType\") == \"application/json\":\n            try:\n                text = content.get(\"text\", \"\")\n                if text:\n                    data = json.loads(text)\n                    return infer_schema(data)\n            except:\n                pass\n    return {}\n\ndef infer_schema(data) -> dict:\n    \"\"\"Infer JSON schema from data.\"\"\"\n    if isinstance(data, dict):\n        return {\n            \"type\": \"object\",\n            \"properties\": {k: infer_schema(v) for k, v in data.items()}\n        }\n    elif isinstance(data, list):\n        if data:\n            return {\"type\": \"array\", \"items\": infer_schema(data[0])}\n        return {\"type\": \"array\", \"items\": {}}\n    elif isinstance(data, bool):\n        return {\"type\": \"boolean\"}\n    elif isinstance(data, int):\n        return {\"type\": \"integer\"}\n    elif isinstance(data, float):\n        return {\"type\": \"number\"}\n    elif isinstance(data, str):\n        return {\"type\": \"string\"}\n    else:\n        return {\"type\": \"null\"}\n```\n\n## Identifying Path Parameters\n\nLook for patterns in paths:\n```python\nimport re\n\ndef find_path_params(paths: list[str]) -> str:\n    \"\"\"Find path parameters by looking at variations.\"\"\"\n    # Example: [\"/users/1\", \"/users/2\", \"/users/3\"] -> \"/users/{id}\"\n    \n    # Split paths into segments\n    segments_list = [p.strip(\"/\").split(\"/\") for p in paths]\n    \n    if not segments_list:\n        return \"\"\n    \n    result = []\n    num_segments = len(segments_list[0])\n    \n    for i in range(num_segments):\n        values = set(s[i] for s in segments_list if len(s) > i)\n        \n        # If all values are the same, it's a static segment\n        if len(values) == 1:\n            result.append(values.pop())\n        # If values look like IDs (numbers, UUIDs), it's a parameter\n        elif all(v.isdigit() or is_uuid(v) for v in values):\n            result.append(\"{id}\")\n        else:\n            result.append(\"{param}\")\n    \n    return \"/\" + \"/\".join(result)\n\ndef is_uuid(s: str) -> bool:\n    pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'\n    return bool(re.match(pattern, s, re.IGNORECASE))\n```\n\n## Extracting Headers\n\n### Required vs Optional Headers\n```python\ndef analyze_headers(entries: list) -> tuple[set, set]:\n    \"\"\"Determine required vs optional headers.\"\"\"\n    all_headers = []\n    \n    for entry in entries:\n        headers = {h[\"name\"].lower(): h[\"value\"] \n                   for h in entry[\"request\"][\"headers\"]}\n        all_headers.append(headers)\n    \n    if not all_headers:\n        return set(), set()\n    \n    # Headers present in ALL requests are required\n    required = set(all_headers[0].keys())\n    for h in all_headers[1:]:\n        required &= set(h.keys())\n    \n    # Headers present in SOME requests are optional\n    all_keys = set()\n    for h in all_headers:\n        all_keys.update(h.keys())\n    optional = all_keys - required\n    \n    # Filter out browser-added headers\n    browser_headers = {\n        'accept', 'accept-encoding', 'accept-language', \n        'connection', 'host', 'user-agent', 'sec-ch-ua',\n        'sec-ch-ua-mobile', 'sec-ch-ua-platform', 'sec-fetch-dest',\n        'sec-fetch-mode', 'sec-fetch-site', 'referer', 'origin'\n    }\n    \n    required -= browser_headers\n    optional -= browser_headers\n    \n    return required, optional\n```\n\n## Common Patterns\n\n### Pagination\nLook for:\n- Query params: `page`, `offset`, `limit`, `cursor`, `after`, `before`\n- Response fields: `next`, `previous`, `total`, `has_more`, `next_cursor`\n\n### Filtering\nLook for:\n- Query params: `filter`, `q`, `search`, `query`, `sort`, `order`\n\n### GraphQL\nLook for:\n- POST to `/graphql`\n- Body with `query` and `variables` fields\n- Response with `data` and `errors` fields\n\n## Output Format\n\nAfter analysis, generate a summary:\n\n```markdown\n## API Summary\n\n### Base URL\nhttps://api.example.com\n\n### Authentication\nBearer token in Authorization header\n\n### Endpoints\n\n#### GET /api/users\n- Query params: page (int), limit (int)\n- Response: Array of User objects\n\n#### POST /api/users\n- Body: { name: string, email: string }\n- Response: User object\n\n#### GET /api/users/{id}\n- Path params: id (int)\n- Response: User object\n```\n"
      },
      "plugins": [
        {
          "name": "reverse-api-engineer",
          "source": "./plugins/reverse-api-engineer",
          "description": "A plugin to reverse engineer APIs from websites",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add kalil0321/reverse-api-engineer",
            "/plugin install reverse-api-engineer@reverse-api-engineer"
          ]
        }
      ]
    }
  ]
}