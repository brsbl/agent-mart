{
  "author": {
    "id": "LeomaiaJr",
    "display_name": "Leonardo Maia Jr",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/59290783?u=d1ccc03aded93c7fbdc713b4abe07daa871edce4&v=4",
    "url": "https://github.com/LeomaiaJr",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "leo-skills",
      "version": null,
      "description": "Leo's custom Claude Code skills",
      "owner_info": {
        "name": "Leo Maia Jr",
        "email": "leomaiajr@hotmail.com"
      },
      "keywords": [],
      "repo_full_name": "LeomaiaJr/leo-skills",
      "repo_url": "https://github.com/LeomaiaJr/leo-skills",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-29T16:42:13Z",
        "created_at": "2026-01-16T18:15:13Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 538
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 806
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/leo-wiggum",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/leo-wiggum/SKILL.md",
          "type": "blob",
          "size": 7170
        },
        {
          "path": "skills/leo-wiggum/prompt.md",
          "type": "blob",
          "size": 5847
        },
        {
          "path": "skills/leo-wiggum/prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/leo-wiggum/prompts/iteration-agent.md",
          "type": "blob",
          "size": 5847
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"leo-skills\",\n  \"owner\": {\n    \"name\": \"Leo Maia Jr\",\n    \"email\": \"leomaiajr@hotmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Leo's custom Claude Code skills\",\n    \"version\": \"2.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"leo-skills\",\n      \"description\": \"Collection of custom skills including leo-wiggum for autonomous AI coding loops with phased execution, browser validation, and quality ratcheting\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/leo-wiggum\"\n      ]\n    }\n  ]\n}\n",
        "README.md": "# leo-skills\n\nCustom Claude Code skills.\n\n## Installation\n\n```bash\n/plugin marketplace add LeomaiaJr/leo-skills\n/plugin install leo-skills@leo-skills\n```\n\n## Skills\n\n### leo-wiggum\n\nAutonomous coding loop that spawns fresh Claude Code sessions to implement features iteratively.\n\n**Usage:** Just mention it naturally:\n- \"Use leo-wiggum to add a notifications feature\"\n- \"Start leo loop for refactoring the auth module\"\n\n**How it works:**\n1. Generates `prd.json` with user stories from your description\n2. Runs external loop spawning fresh Claude sessions\n3. Each session picks next incomplete story, implements, tests, commits\n4. Memory persists via git, `prd.json`, and `progress.txt`\n\n**Manual run:**\n```bash\n~/.claude/plugins/cache/leo-skills/leo-skills/*/skills/leo-wiggum/scripts/leo-wiggum.sh 10\n```\n",
        "skills/leo-wiggum/SKILL.md": "---\nname: leo-wiggum\ndescription: >\n  Autonomous AI coding loop v2 with phased execution, dependency graphs,\n  browser validation, structured memory, and quality ratcheting.\n  Use when user says \"leo-wiggum\", \"/leo-wiggum\", \"start leo loop\",\n  \"autonomous coding\", \"run leo\", or wants to implement features or build\n  entire projects using iterative AI sessions. Works on any codebase or\n  greenfield projects.\nallowed-tools: Bash(agent-browser:*)\n---\n\n# Leo Wiggum v2 - Autonomous AI Coding Loop\n\nPhased, skill-aware autonomous coding loop with browser validation, structured memory, and quality ratcheting. Works on any project or from scratch.\n\n## How It Works\n\n1. **Phase 0 — Discovery/Scaffold**: Analyze codebase or scaffold a new project\n2. **Phase 1 — Foundation**: Core infrastructure stories (schema, auth, config)\n3. **Phase 2 — Features**: Story-based implementation with dependency ordering\n4. **Phase 3 — Polish & Validation**: Integration validation, browser smoke tests, cleanup\n5. Each iteration agent receives skill assignments and structured memory from previous iterations\n6. Memory persists via `.leo/` directory (prd.json, memory.json, quality-metrics.json, screenshots)\n\n## Usage\n\nParse from user input:\n- **prompt** (required): Feature or project description\n- **--max-iterations N**: Max iterations (default: 15)\n- **--branch name**: Git branch (default: `leo/<feature-slug>`)\n- **--greenfield**: Force greenfield scaffolding mode\n- **--headed**: Run browser validation in headed mode (visible)\n\n## Step 1: Discovery / Scaffold\n\n### Existing Project\n1. Read `CLAUDE.md` if exists\n2. Detect tech stack by checking: `package.json`, `Cargo.toml`, `pyproject.toml`, `go.mod`, `requirements.txt`, `Makefile`, etc.\n3. Explore code structure with Glob/Grep to understand patterns\n4. Identify and populate `techStack` in PRD:\n   - `language`, `framework`\n   - `buildCmd`, `testCmd`, `lintCmd`, `typecheckCmd`\n   - `devServerCmd`, `devServerUrl`\n5. Run baseline quality check (typecheck, tests, lint) and record in `quality-metrics.json`\n\n### Greenfield (--greenfield flag or no recognizable project files)\n1. Infer desired stack from the user's prompt (or ask if unclear)\n2. Generate scaffold story as first Phase 1 story (`US-000: Initialize project scaffold`)\n3. ALL other stories `dependsOn: [\"US-000\"]`\n4. Set `techStack` with expected commands for the chosen framework\n5. Quality baseline is captured AFTER the scaffold story passes\n\n## Step 2: Generate Phased User Stories\n\nBreak the feature/project into stories organized by phase. Each story must be completable in ONE iteration.\n\n### Skill Assignment\n\nAssign 1-3 skills per story based on its content:\n\n| Skill | When to Assign |\n|-------|---------------|\n| `code` | Always — general implementation |\n| `database` | Schema changes, migrations, seed data |\n| `api` | API endpoint creation or modification |\n| `ui` | Frontend component work |\n| `browser` | Story has visual output to validate |\n| `test` | Test-focused or test-heavy stories |\n\n### Right-Sized Stories\n- Add database model + migration\n- Add single UI component or page\n- Create one API endpoint\n- Add form with validation\n- Write tests for one module\n\n### Too Big (must split)\n- \"Build entire dashboard\" -> split into individual pages/components\n- \"Add authentication\" -> split into model, API, UI, tests\n- \"Refactor API\" -> split by domain/router\n\n### Dependency Graph\n- Stories declare `dependsOn: [\"US-XXX\"]` for explicit ordering\n- The iteration loop only picks stories whose dependencies are all `passed`\n- Avoid circular dependencies\n\n### Browser Validation\nFor UI stories, add `validation.type: \"browser\"` with steps:\n```json\n{\n  \"validation\": {\n    \"type\": \"browser\",\n    \"browserSteps\": [\n      { \"action\": \"open\", \"target\": \"http://localhost:3000/page\" },\n      { \"action\": \"wait\", \"target\": \"--text 'Expected Text'\" },\n      { \"action\": \"snapshot\", \"expect\": \"description of what should be visible\" },\n      { \"action\": \"screenshot\", \"path\": \".leo/screenshots/US-XXX.png\" }\n    ]\n  }\n}\n```\n\n## Step 3: Create .leo/ Directory\n\nInitialize the following files in `.leo/`:\n\n### .leo/prd.json\n```json\n{\n  \"version\": 2,\n  \"project\": \"<project name>\",\n  \"branchName\": \"leo/<feature-slug>\",\n  \"description\": \"<feature/project description>\",\n  \"techStack\": {\n    \"language\": \"<detected>\",\n    \"framework\": \"<detected>\",\n    \"buildCmd\": \"<detected or null>\",\n    \"testCmd\": \"<detected or null>\",\n    \"lintCmd\": \"<detected or null>\",\n    \"typecheckCmd\": \"<detected or null>\",\n    \"devServerCmd\": \"<detected or null>\",\n    \"devServerUrl\": \"<detected or null>\"\n  },\n  \"phases\": [\n    { \"id\": \"phase-0\", \"name\": \"Discovery\", \"type\": \"discovery\", \"status\": \"complete\" },\n    { \"id\": \"phase-1\", \"name\": \"Foundation\", \"status\": \"pending\" },\n    { \"id\": \"phase-2\", \"name\": \"Features\", \"status\": \"pending\" },\n    { \"id\": \"phase-3\", \"name\": \"Polish\", \"status\": \"pending\" }\n  ],\n  \"stories\": [\n    {\n      \"id\": \"US-001\",\n      \"title\": \"<title>\",\n      \"description\": \"As a <user>, I want <goal>, so that <benefit>\",\n      \"phase\": \"phase-1\",\n      \"priority\": 1,\n      \"skills\": [\"code\", \"database\"],\n      \"dependsOn\": [],\n      \"status\": \"pending\",\n      \"failureCount\": 0,\n      \"maxRetries\": 3,\n      \"acceptanceCriteria\": [\n        \"<criterion 1>\",\n        \"<criterion 2>\"\n      ],\n      \"validation\": {\n        \"type\": \"none\",\n        \"browserSteps\": []\n      },\n      \"notes\": \"\",\n      \"lastFailure\": null\n    }\n  ]\n}\n```\n\n### .leo/memory.json\n```json\n{\n  \"patterns\": [],\n  \"decisions\": [],\n  \"failures\": [],\n  \"environment\": {}\n}\n```\n\n### .leo/quality-metrics.json\nRun the project's quality commands and capture baseline:\n```json\n{\n  \"baseline\": {\n    \"typescriptErrors\": 0,\n    \"testCount\": 0,\n    \"testPassRate\": 1.0,\n    \"lintErrors\": 0,\n    \"buildSuccess\": true\n  },\n  \"snapshots\": [],\n  \"ratchetRules\": {\n    \"typescriptErrors\": \"no-increase\",\n    \"testCount\": \"no-decrease\",\n    \"testPassRate\": \"no-decrease\",\n    \"lintErrors\": \"no-increase\",\n    \"buildSuccess\": \"must-be-true\"\n  }\n}\n```\n\nFor greenfield projects, set all baseline values to 0/true (baseline captured after scaffold story).\n\nAlso create `.leo/screenshots/` directory.\n\n## Step 4: Show Summary & Confirm\n\nDisplay to the user:\n- Phase breakdown with story counts per phase\n- Dependency graph (which stories block which)\n- Skill distribution across stories\n- Quality baseline (if existing project)\n- Branch name\n- Max iterations\n- Command that will run\n\n## Step 5: Start Loop\n\nAsk user to confirm, then run:\n\n```bash\n${CLAUDE_PLUGIN_ROOT}/scripts/leo-wiggum.sh <max_iterations>\n```\n\nPass `--headed` if user requested visible browser.\n\n**CRITICAL:** After starting the script, END your response immediately. The script spawns NEW Claude Code sessions — your job is done.\n\n## Monitoring\n\n- **Terminal**: phase/iteration progress, quality gate results\n- **`.leo/prd.json`**: story statuses and failure info\n- **`.leo/memory.json`**: structured learnings, patterns, decisions, failures\n- **`.leo/quality-metrics.json`**: metric trends across iterations\n- **`.leo/screenshots/`**: visual proof from browser validation\n- **`git log`**: commits per story\n",
        "skills/leo-wiggum/prompt.md": "# Leo Wiggum v2 - Iteration Agent\n\nYou are an autonomous coding agent in a phased, skill-aware coding loop.\n\n## Startup Sequence\n\n1. Read `.leo/prd.json` — understand the full plan, tech stack, phases, stories\n2. Read `.leo/memory.json` — review patterns, decisions, past failures\n3. Read `.leo/quality-metrics.json` — know current quality baseline\n4. Read `CLAUDE.md` if it exists — project conventions\n5. Verify you are on the correct git branch (from PRD `branchName`). If not, create it from main.\n\n## Pick Next Story\n\nSelect the next story using these rules IN ORDER:\n\n1. Must have `status: \"pending\"` OR `status: \"failed\"` with `failureCount < maxRetries`\n2. ALL stories in `dependsOn` must have `status: \"passed\"`\n3. Must be in the earliest incomplete phase (phase with stories not all passed/skipped)\n4. Among eligible stories, pick lowest `priority` number (1 = highest)\n\nIf NO story is eligible (all passed, all blocked, or all skipped):\n- If ALL stories are `passed`: output `<promise>COMPLETE</promise>`\n- Otherwise: output `<promise>BLOCKED</promise>`\n\nBefore starting implementation, update the story `status` to `\"in-progress\"` in `.leo/prd.json`.\n\n## Implement the Story\n\nRead the story's `skills` array and follow the corresponding approach:\n\n### Skill: code (always present)\n- Follow patterns from memory.json\n- Keep changes minimal and focused on the story scope\n- Follow existing codebase conventions\n\n### Skill: database\n- Read existing schema files FIRST\n- Make schema/migration changes\n- Run migration command from `techStack`\n- Validate migration succeeds before continuing\n\n### Skill: api\n- Read existing API/router patterns from memory.json\n- Implement endpoint following project conventions\n- Add input validation matching existing patterns\n\n### Skill: ui\n- Read existing component patterns\n- Use the project's design system/component library\n- Prepare for browser validation if the story has it\n\n### Skill: browser\n- This story requires browser validation (handled in validation phase below)\n\n### Skill: test\n- Write tests following existing test patterns and runner\n- Ensure tests cover the story's acceptance criteria\n\n## Quality Gate\n\nAfter implementation, run quality checks using commands from `techStack`:\n\n1. **Typecheck**: Run `techStack.typecheckCmd` if defined\n2. **Tests**: Run `techStack.testCmd` if defined\n3. **Lint**: Run `techStack.lintCmd` if defined\n\nCompare results against `.leo/quality-metrics.json` latest snapshot (or baseline):\n- TypeScript/type errors must NOT increase\n- Test count must NOT decrease\n- Test pass rate must NOT decrease\n- Lint errors must NOT increase\n- Build must succeed\n\nIf quality gate **FAILS**:\n1. Attempt to fix the issues (up to 2 fix attempts)\n2. Re-run quality checks after each fix\n3. If still failing after 2 fix attempts, mark the story as `failed` (see On Failure below)\n\n## Browser Validation\n\nIf the story has `validation.type: \"browser\"`:\n\n1. Check if dev server is reachable:\n   ```bash\n   curl -s -o /dev/null -w \"%{http_code}\" <techStack.devServerUrl>\n   ```\n\n2. If NOT reachable (non-200 response or timeout):\n   - Update `.leo/memory.json` environment: `\"devServerHealthy\": false`\n   - SKIP browser validation — do NOT fail the story for this\n   - Proceed to commit\n\n3. If reachable, execute each step in `validation.browserSteps`:\n   ```bash\n   agent-browser open \"<target>\"\n   agent-browser wait <condition>\n   agent-browser snapshot -i\n   # Read snapshot output and verify it matches the \"expect\" description\n   agent-browser screenshot <path>\n   agent-browser close\n   ```\n\n4. If validation fails, treat it as a quality gate failure (retry flow)\n\n## On Success\n\n1. **Commit implementation**: `feat(<phase-name>): [Story ID] - [Story Title]`\n2. **Update `.leo/prd.json`**: Set story `status: \"passed\"`, clear `lastFailure`\n3. **Update phase status**: If all stories in the phase are passed/skipped, set phase `status: \"complete\"`\n4. **Append quality snapshot** to `.leo/quality-metrics.json` snapshots array\n5. **Update `.leo/memory.json`**:\n   - Add any new patterns discovered (with category and discoveredAt)\n   - Add any architectural decisions made (with reason)\n   - Update environment info if relevant\n6. **Commit state files**: `chore: update leo state after [Story ID]`\n\n## On Failure\n\n1. **DO NOT commit broken code** — revert uncommitted changes:\n   ```bash\n   git checkout -- . && git checkout -- ':!.leo'\n   ```\n   (Reverts everything EXCEPT .leo/ directory)\n\n2. **Update `.leo/prd.json`**:\n   - Increment `failureCount`\n   - Set `lastFailure` with error summary and what was attempted\n   - If `failureCount >= maxRetries`, set `status: \"skipped\"`\n   - Otherwise keep `status: \"failed\"`\n\n3. **Update `.leo/memory.json`**: Add failure record:\n   ```json\n   {\n     \"storyId\": \"US-XXX\",\n     \"error\": \"The actual error message\",\n     \"rootCause\": \"Your analysis of why it failed\",\n     \"resolution\": \"What you tried or what might work next time\",\n     \"attempt\": <current failureCount>\n   }\n   ```\n\n4. **Commit state files**: `chore: update leo state after [Story ID] failure`\n\n## Completion Check\n\nAfter handling the story (pass or fail):\n- If ALL stories have `status: \"passed\"`: output `<promise>COMPLETE</promise>`\n- If ALL remaining stories are `skipped` or have unresolvable blocked deps: output `<promise>BLOCKED</promise>`\n- Otherwise: end normally (next iteration will continue)\n\n## Rules\n\n- Work on **ONE** story per iteration\n- **NEVER** commit code that fails quality checks\n- Read `memory.json` patterns BEFORE implementing — learn from past iterations\n- If a story previously failed, read its failure record to try a DIFFERENT approach\n- Keep changes focused to the current story's scope\n- Do not modify files unrelated to the current story\n- Follow existing code patterns and conventions over introducing new ones\n",
        "skills/leo-wiggum/prompts/iteration-agent.md": "# Leo Wiggum v2 - Iteration Agent\n\nYou are an autonomous coding agent in a phased, skill-aware coding loop.\n\n## Startup Sequence\n\n1. Read `.leo/prd.json` — understand the full plan, tech stack, phases, stories\n2. Read `.leo/memory.json` — review patterns, decisions, past failures\n3. Read `.leo/quality-metrics.json` — know current quality baseline\n4. Read `CLAUDE.md` if it exists — project conventions\n5. Verify you are on the correct git branch (from PRD `branchName`). If not, create it from main.\n\n## Pick Next Story\n\nSelect the next story using these rules IN ORDER:\n\n1. Must have `status: \"pending\"` OR `status: \"failed\"` with `failureCount < maxRetries`\n2. ALL stories in `dependsOn` must have `status: \"passed\"`\n3. Must be in the earliest incomplete phase (phase with stories not all passed/skipped)\n4. Among eligible stories, pick lowest `priority` number (1 = highest)\n\nIf NO story is eligible (all passed, all blocked, or all skipped):\n- If ALL stories are `passed`: output `<promise>COMPLETE</promise>`\n- Otherwise: output `<promise>BLOCKED</promise>`\n\nBefore starting implementation, update the story `status` to `\"in-progress\"` in `.leo/prd.json`.\n\n## Implement the Story\n\nRead the story's `skills` array and follow the corresponding approach:\n\n### Skill: code (always present)\n- Follow patterns from memory.json\n- Keep changes minimal and focused on the story scope\n- Follow existing codebase conventions\n\n### Skill: database\n- Read existing schema files FIRST\n- Make schema/migration changes\n- Run migration command from `techStack`\n- Validate migration succeeds before continuing\n\n### Skill: api\n- Read existing API/router patterns from memory.json\n- Implement endpoint following project conventions\n- Add input validation matching existing patterns\n\n### Skill: ui\n- Read existing component patterns\n- Use the project's design system/component library\n- Prepare for browser validation if the story has it\n\n### Skill: browser\n- This story requires browser validation (handled in validation phase below)\n\n### Skill: test\n- Write tests following existing test patterns and runner\n- Ensure tests cover the story's acceptance criteria\n\n## Quality Gate\n\nAfter implementation, run quality checks using commands from `techStack`:\n\n1. **Typecheck**: Run `techStack.typecheckCmd` if defined\n2. **Tests**: Run `techStack.testCmd` if defined\n3. **Lint**: Run `techStack.lintCmd` if defined\n\nCompare results against `.leo/quality-metrics.json` latest snapshot (or baseline):\n- TypeScript/type errors must NOT increase\n- Test count must NOT decrease\n- Test pass rate must NOT decrease\n- Lint errors must NOT increase\n- Build must succeed\n\nIf quality gate **FAILS**:\n1. Attempt to fix the issues (up to 2 fix attempts)\n2. Re-run quality checks after each fix\n3. If still failing after 2 fix attempts, mark the story as `failed` (see On Failure below)\n\n## Browser Validation\n\nIf the story has `validation.type: \"browser\"`:\n\n1. Check if dev server is reachable:\n   ```bash\n   curl -s -o /dev/null -w \"%{http_code}\" <techStack.devServerUrl>\n   ```\n\n2. If NOT reachable (non-200 response or timeout):\n   - Update `.leo/memory.json` environment: `\"devServerHealthy\": false`\n   - SKIP browser validation — do NOT fail the story for this\n   - Proceed to commit\n\n3. If reachable, execute each step in `validation.browserSteps`:\n   ```bash\n   agent-browser open \"<target>\"\n   agent-browser wait <condition>\n   agent-browser snapshot -i\n   # Read snapshot output and verify it matches the \"expect\" description\n   agent-browser screenshot <path>\n   agent-browser close\n   ```\n\n4. If validation fails, treat it as a quality gate failure (retry flow)\n\n## On Success\n\n1. **Commit implementation**: `feat(<phase-name>): [Story ID] - [Story Title]`\n2. **Update `.leo/prd.json`**: Set story `status: \"passed\"`, clear `lastFailure`\n3. **Update phase status**: If all stories in the phase are passed/skipped, set phase `status: \"complete\"`\n4. **Append quality snapshot** to `.leo/quality-metrics.json` snapshots array\n5. **Update `.leo/memory.json`**:\n   - Add any new patterns discovered (with category and discoveredAt)\n   - Add any architectural decisions made (with reason)\n   - Update environment info if relevant\n6. **Commit state files**: `chore: update leo state after [Story ID]`\n\n## On Failure\n\n1. **DO NOT commit broken code** — revert uncommitted changes:\n   ```bash\n   git checkout -- . && git checkout -- ':!.leo'\n   ```\n   (Reverts everything EXCEPT .leo/ directory)\n\n2. **Update `.leo/prd.json`**:\n   - Increment `failureCount`\n   - Set `lastFailure` with error summary and what was attempted\n   - If `failureCount >= maxRetries`, set `status: \"skipped\"`\n   - Otherwise keep `status: \"failed\"`\n\n3. **Update `.leo/memory.json`**: Add failure record:\n   ```json\n   {\n     \"storyId\": \"US-XXX\",\n     \"error\": \"The actual error message\",\n     \"rootCause\": \"Your analysis of why it failed\",\n     \"resolution\": \"What you tried or what might work next time\",\n     \"attempt\": <current failureCount>\n   }\n   ```\n\n4. **Commit state files**: `chore: update leo state after [Story ID] failure`\n\n## Completion Check\n\nAfter handling the story (pass or fail):\n- If ALL stories have `status: \"passed\"`: output `<promise>COMPLETE</promise>`\n- If ALL remaining stories are `skipped` or have unresolvable blocked deps: output `<promise>BLOCKED</promise>`\n- Otherwise: end normally (next iteration will continue)\n\n## Rules\n\n- Work on **ONE** story per iteration\n- **NEVER** commit code that fails quality checks\n- Read `memory.json` patterns BEFORE implementing — learn from past iterations\n- If a story previously failed, read its failure record to try a DIFFERENT approach\n- Keep changes focused to the current story's scope\n- Do not modify files unrelated to the current story\n- Follow existing code patterns and conventions over introducing new ones\n"
      },
      "plugins": [
        {
          "name": "leo-skills",
          "description": "Collection of custom skills including leo-wiggum for autonomous AI coding loops with phased execution, browser validation, and quality ratcheting",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/leo-wiggum"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add LeomaiaJr/leo-skills",
            "/plugin install leo-skills@leo-skills"
          ]
        }
      ]
    }
  ]
}