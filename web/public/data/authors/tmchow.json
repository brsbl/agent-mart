{
  "author": {
    "id": "tmchow",
    "display_name": "Trevin Chow",
    "avatar_url": "https://avatars.githubusercontent.com/u/517103?u=8840cb220efe823a3547734dea97ebdcff28e836&v=4"
  },
  "marketplaces": [
    {
      "name": "tmc-marketplace",
      "version": null,
      "description": "Claude Code plugins by Trevin Chow",
      "repo_full_name": "tmchow/tmc-marketplace",
      "repo_url": "https://github.com/tmchow/tmc-marketplace",
      "repo_description": "Claude Code and Codex plugins by Trevin Chow",
      "signals": {
        "stars": 18,
        "forks": 2,
        "pushed_at": "2026-02-20T08:15:49Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"tmc-marketplace\",\n  \"owner\": {\n    \"name\": \"Trevin Chow\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugins by Trevin Chow\",\n    \"version\": \"0.1.0\",\n    \"pluginRoot\": \"./plugins\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"iterative-engineering\",\n      \"source\": \"./plugins/iterative-engineering\",\n      \"description\": \"Iterative development workflow - brainstorming, planning, multi-agent reviews, TDD execution, and PR feedback resolution\",\n      \"version\": \"1.10.0\"\n    }\n  ]\n}\n",
        "README.md": "# tmc-marketplace\n\nPlugins for Claude Code and Codex by Trevin Chow.\n\n[trev.in](https://trev.in) ¬∑ [LinkedIn](https://linkedin.com/in/trevin)\n\n## Quick Install\n\n```bash\ncurl -fsSL \"https://raw.githubusercontent.com/tmchow/tmc-marketplace/main/scripts/install.sh?$(date +%s)\" | bash\n```\n\nInstalls the Claude Code plugin and Codex skills. Safe to re-run (idempotent). Skips anything not detected (e.g., no Codex installed).\n\nTo uninstall:\n\n```bash\ncurl -fsSL \"https://raw.githubusercontent.com/tmchow/tmc-marketplace/main/scripts/install.sh?$(date +%s)\" | bash -s -- --uninstall\n```\n\n## Manual Install\n\n### Claude Code\n\n```\n/plugin marketplace add tmchow/tmc-marketplace\n/plugin install iterative-engineering@tmc-marketplace\n```\n\nVerify with `/plugin list`.\n\n### Codex\n\nDownload the skills into your Codex skills directory:\n\n```bash\ncurl -sL https://github.com/tmchow/tmc-marketplace/archive/refs/heads/main.tar.gz \\\n  | tar xz --strip-components=4 -C ~/.codex/skills/ \\\n    tmc-marketplace-main/plugins/iterative-engineering/skills/\n```\n\nThis extracts all skills (with their reference files) to `~/.codex/skills/`.\n\n## Plugins\n\n| Plugin | Description |\n|--------|-------------|\n| [iterative-engineering](./plugins/iterative-engineering) | Iterative development workflow ‚Äî brainstorming ‚Üí tech planning ‚Üí implementing with multi-agent reviews, dependency-aware execution, and severity-based acceptance |\n\n## Changelog\n\nSee [CHANGELOG.md](./CHANGELOG.md) for a detailed history of all changes, new features, and fixes across releases.\n\n## License\n\nMIT\n",
        "plugins/iterative-engineering/README.md": "# Iterative Engineering Plugin\n\nA plugin for Claude Code and Codex ‚Äî iterative development workflows with brainstorming, tech planning, multi-agent reviews, TDD implementation, and PR management.\n\n## Philosophy\n\n- **Planning pays off** ‚Äî Rushing to code is often slower than planning first.\n- **Iteration improves quality** ‚Äî A review after a review can still find improvements.\n- **User drives decisions** ‚Äî Stage transitions, review rounds, and what to fix all surface options to go deeper or move forward.\n- **Opinionated defaults, user choice** ‚Äî Recommend reviews, suggest worktrees, default to full coverage. The user can skip, customize, or exit at any point.\n- **Skills are independently valuable** ‚Äî Each skill works standalone. Run `/code-review` without the full pipeline, or `/iterative:brainstorming` to revisit requirements mid-implementation.\n\n## Installation\n\n### Quick Install\n\n```bash\ncurl -fsSL \"https://raw.githubusercontent.com/tmchow/tmc-marketplace/main/scripts/install.sh?$(date +%s)\" | bash\n```\n\nInstalls the Claude Code plugin and Codex skills. Safe to re-run (idempotent). Skips anything not detected (e.g., no Codex installed).\n\nTo uninstall:\n\n```bash\ncurl -fsSL \"https://raw.githubusercontent.com/tmchow/tmc-marketplace/main/scripts/install.sh?$(date +%s)\" | bash -s -- --uninstall\n```\n\n### Manual Install\n\n#### Claude Code\n\nClaude Code uses a [plugin marketplace](https://docs.anthropic.com/en/docs/claude-code/plugins) ‚Äî the marketplace must be added before installing the plugin:\n\n```\n/plugin marketplace add tmchow/tmc-marketplace\n/plugin install iterative-engineering@tmc-marketplace\n```\n\nVerify with `/plugin list`.\n\n#### Codex\n\nDownload the skills into your Codex skills directory:\n\n```bash\ncurl -sL https://github.com/tmchow/tmc-marketplace/archive/refs/heads/main.tar.gz \\\n  | tar xz --strip-components=4 -C ~/.codex/skills/ \\\n    tmc-marketplace-main/plugins/iterative-engineering/skills/\n```\n\nThis extracts all skills (with their reference files) to `~/.codex/skills/`.\n\n## The Workflow\n\n```\nbrainstorming\n     ‚îÇ PRD\n     ‚Üï plan-review (1+ rounds)\n     ‚Üï research (optional)\n     ‚Üï design-exploration (optional)\n     ‚îÇ\ntech-planning\n     ‚îÇ Tech Plan\n     ‚Üï plan-review (1+ rounds)\n     ‚îÇ\nimplementing\n     ‚îú‚îÄ execute batch ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n     ‚îÇ   incremental code-review? ‚îò (many subtasks)\n     ‚îÇ\n     ‚îú‚îÄ code-review (per plan section)\n     ‚îÇ   fix selected severities\n     ‚îÇ\n     ‚îú‚îÄ code-simplifier (cleanup pass)\n     ‚îÇ\n     ‚îú‚îÄ final code-review (all changes)\n     ‚îÇ   fix selected severities\n     ‚îÇ\n     ‚îî‚îÄ wrapup: verify tests ‚Üí PR\n```\n\nEach stage produces an artifact, offers iterative review, and hands off when the user is ready. Re-entry is supported ‚Äî run any skill again at any point.\n\n### Brainstorming\n\nBrainstorming shapes requirements through dialogue. It asks 2-3 questions to map the problem space, then assesses scope ‚Äî **Quick** (bug fix, config change), **Standard** (small feature, bounded refactor), or **Full** (large feature, new subsystem). The scope determines how much ceremony follows: Quick gets focused Q&A and an inline sanity check before implementing directly; Standard produces a lightweight brief with full review; Full produces a complete PRD with full review and structured tech planning. The user confirms or overrides the scope assessment.\n\nFor Standard and Full scope, it presents broad directions to narrow things down, validates the user's choice against core requirements before going deep, and pushes back on assumptions. The Full scope output is a **PRD** with requirements grouped by priority: Core (the whole point), Must-Have (required for v1), Nice-to-Have (include if straightforward), Out (considered and explicitly excluded). Scope splits into In Scope and deliberate Boundaries. Open questions are tagged with what they affect so downstream stages know what depends on resolving them. Sections earn their place based on criteria, not a rigid template. High-level technical direction belongs here; implementation specifics do not.\n\nAfter the PRD is written, it goes through review. 4 specialized reviewers (clarity, completeness, specificity, complexity/debt) analyze the document via agent team with cross-validation ‚Äî the complexity reviewer can push back when completeness wants more detail. The user reviews findings, fixes issues, and can run as many rounds as needed. If the PRD has open questions, they can be resolved before planning. The agent classifies each question by resolution method: questions where the answer exists somewhere (prior art, constraints, competitive landscape) get parallel research via `iterative:research`. Questions about visual design or UX feel get explored via `iterative:design-exploration`. Technical questions defer to tech planning; questions needing user decisions get flagged. Findings are proposed as PRD updates, applied only with user approval. The PRD stays live ‚Äî tech planning, design exploration, and implementation update it as reality reveals new constraints.\n\nDesign exploration generates 5-10 radically different design variations in an interactive HTML gallery. Each variation has per-variation tuning controls, and the gallery includes a rating/feedback system with structured export. The user rates variations, adds notes, and exports feedback that feeds directly back into the next round of exploration. Multiple rounds refine the options until the user converges on a direction. The output is a design direction document capturing chosen directions and discarded approaches ‚Äî the PRD references it rather than duplicating the content.\n\n### Tech Planning\n\nTech planning turns the PRD into an implementation plan. It starts by exploring the codebase ‚Äî existing patterns, conventions, affected modules ‚Äî and asking implementation-focused questions before writing anything. Open questions from the PRD get resolved during exploration, and the PRD is updated accordingly.\n\nThe output is a **Tech Plan** that captures what to build and where ‚Äî architecture decisions, query strategies, file paths, concrete test scenarios with specific inputs and expected outputs. It does not pre-write implementation code; that's brittle and gets followed blindly. The implementer writes the actual code. Subtasks are scoped to atomic commits (typically 2-3 files) with explicit dependencies. New constraints found during planning go back into the PRD with rationale.\n\nSame review process ‚Äî all 4 plan reviewers analyze via agent team regardless of document size. Shorter documents naturally produce fewer findings. The user fixes issues, multiple rounds until it's ready.\n\n### Implementing\n\nImplementing executes the tech plan with dependency-aware batching. Subtasks are grouped by their dependency graph ‚Äî each batch runs concurrently via worker subagents, but batches execute sequentially to respect ordering. Each worker reads its subtask from the plan, loads referenced patterns, implements with TDD, and commits.\n\nCode review happens throughout. Large plan sections (6+ subtasks) get automatic incremental reviews between batches to catch issues before later batches build on flawed code. Every section gets a code review when complete, using 5 built-in reviewers (correctness, security, performance, simplicity, testing) via agent team with cross-validation. In full mode, external model CLIs (Gemini, Codex, Claude) can optionally provide independent perspectives ‚Äî the orchestrator self-identifies and skips the matching model family's CLI. Severity-based fix acceptance keeps the user in control ‚Äî they pick which levels to address, not all-or-nothing.\n\nAfter all sections finish, a code-simplifier agent makes a single bounded pass of behavior-preserving cleanup on changed files, followed by a final code review of all branch changes. Wrapup verifies tests pass and creates the PR.\n\n### Stage Boundaries\n\nEach stage has a clear scope ‚Äî what it produces and what it deliberately leaves to the next stage:\n\n| Stage | Produces | Does | Does NOT |\n|-------|----------|------|----------|\n| **Brainstorming** | PRD | Explore problem space, make directional choices, capture prioritized requirements and scope boundaries | Specify libraries, schemas, API endpoints, or implementation details |\n| **Tech Planning** | Tech Plan | Structure subtasks with dependencies, file paths, test scenarios, and architecture decisions | Pre-write implementation code ‚Äî describe what and where, implementer writes the code |\n| **Implementing** | Code ‚Üí PR | Execute plan with dependency-aware batching, TDD, code reviews, test verification, PR creation | Deploy or release ‚Äî the workflow ends at PR creation |\n\n### Reviews\n\nReviews are user-driven:\n\n- **Offered, never forced** ‚Äî Every review is presented as a choice. The user can skip.\n- **Severity-based acceptance** ‚Äî Findings grouped by severity (Critical / High / Medium / Low). User selects which levels to fix ‚Äî not all-or-nothing.\n- **User-controlled loop** ‚Äî After fixes, user chooses to re-review or continue. No automatic re-review.\n- **Agent teams with fallback** ‚Äî Reviewers run as an agent team so they can cross-validate findings (the complexity/debt reviewer can push back on completeness suggestions). When agent teams aren't available, reviews automatically fall back to parallel subagents.\n- **Scaled to scope** ‚Äî Full review for substantial work, quick review for moderate changes, skip for trivial config edits.\n\n## Design Decisions\n\n| Decision | Rationale |\n|----------|-----------|\n| PRD captures direction, not implementation | High-level technical direction (\"real-time via WebSockets\") belongs in the PRD. Specific libraries and database schemas don't ‚Äî that's tech planning's job. |\n| Requirements are prioritized, not flat | Requirements grouped as Core / Must-Have / Nice-to-Have / Out. Priority drives implementation scope and prevents everything from being treated as equally important. |\n| PRD is a living document | Tech planning and implementation update the PRD when they hit new constraints. Changes are noted with rationale. |\n| Tech plan describes what, not how | Plans capture architecture, query strategies, and test scenarios. They don't pre-write method bodies ‚Äî that's brittle and gets followed blindly. The implementer writes the actual code. |\n| Dependency-aware batch execution | Subtasks are grouped by their dependency graph. Each batch runs concurrently, but batches execute sequentially. Not one-at-a-time (too slow), not all-at-once (ignores ordering). |\n| Incremental reviews for large sections | Plan sections with 6+ subtasks get code review offers between batches. Catches issues before later batches build on flawed code. |\n| Severity-based fix acceptance | Not all review findings warrant fixing. User picks which severity levels to address. Keeps the user in control of review scope. |\n| Docs committed at every checkpoint | PRDs, plans, and design direction docs are committed incrementally ‚Äî not left as uncommitted changes across workflow stages. A branch safety gate before the first commit prevents accidental commits to the default branch. |\n\n## Skills\n\nThe core workflow skills use an `iterative:` prefix in their name (e.g., `/iterative:brainstorming`). The slash command menu shows skill names from all installed plugins ‚Äî if another plugin also has a \"brainstorming\" skill, you'd see duplicate `/brainstorming` entries. The prefix makes ours immediately identifiable. Substring search still works ‚Äî typing `/brain` finds `/iterative:brainstorming`.\n\n### Core Workflow\n\n| Skill | Output | Description |\n|-------|--------|-------------|\n| `iterative:brainstorming` | PRD | Collaborative exploration of problem space, broad directions, deep Q&A |\n| `iterative:research` | Updated PRD | Research open questions from PRD or user ‚Äî parallel investigation, findings synthesis |\n| `iterative:design-exploration` | Design Direction Doc | Explore 5-10 radically different design approaches with interactive gallery, ratings, and iterative refinement |\n| `iterative:tech-planning` | Tech Plan | Structure PRD into dependency-ordered subtasks with file paths, test scenarios, architecture decisions |\n| `plan-review` | Review Report | 4 specialized reviewers analyze PRDs and tech plans via agent team with cross-validation |\n| `iterative:implementing` | Code ‚Üí PR | Dependency-aware batch execution with TDD, incremental and final code reviews, then wrapup |\n| `code-review` | Review Report | 5 built-in + external model-diverse reviewers, severity ratings, full or quick mode, diff-anchored scoping |\n\n### Internal\n\n| Skill | Description |\n|-------|-------------|\n| `implementation-wrapup` | Test verification, final review, PR creation ‚Äî invoked by implementing or standalone (\"create a PR\") |\n| `git-worktree` | Workspace isolation ‚Äî invoked by implementing during setup |\n\n### Supporting\n\n| Skill | Description |\n|-------|-------------|\n| `fix-code-review-feedback` | Resolve PR review comments systematically ‚Äî evaluates validity before fixing, supports local agent feedback and GitHub PR threads |\n| `agent-browser` | Browser automation using Vercel's agent-browser CLI |\n\n## Agents\n\n### Review Agents (Plan Review)\n\n4 specialized reviewers analyze documents via [agent team](https://code.claude.com/docs/en/agent-teams):\n\n| Agent | Focus |\n|-------|-------|\n| `clarity-reviewer` | Vague language, ambiguity, structure |\n| `completeness-reviewer` | Missing sections, gaps, dependencies |\n| `specificity-reviewer` | Actionability, concrete details |\n| `yagni-reviewer` | Unjustified complexity, maintenance burden, dead flexibility |\n\n### Review Agents (Code Review)\n\n5 built-in reviewers analyze code via agent team:\n\n| Agent | Focus |\n|-------|-------|\n| `correctness-reviewer` | Logic errors, edge cases, bugs, silent failures, plan compliance |\n| `security-reviewer` | Vulnerabilities, auth, input validation, project conventions |\n| `performance-reviewer` | Algorithmic complexity, queries, memory, caching |\n| `simplicity-reviewer` | Unjustified complexity, over-engineering, unnecessary abstraction |\n| `testing-reviewer` | Coverage, test quality, edge cases, plan test scenarios |\n\nBuilt-in reviewers use diff-anchored scoping ‚Äî primary focus on changed lines, with pre-existing issues tagged separately for independent triage. They run as teammates who can cross-validate findings. When agent teams are unavailable, reviews fall back to parallel subagent execution.\n\n### External Reviewers (Code Review, Experimental)\n\nIn Full mode, the orchestrator can run external model CLIs directly (opt-in) for independent, model-diverse perspectives. This feature is experimental; CLI availability and behavior may vary. Codex reviews can take 5+ minutes.\n\n| CLI | Invocation | Safety mode |\n|-----|------------|-------------|\n| Google Gemini | `gemini -s -p \"...\"` | Sandboxed (diff inlined, no tool access needed) |\n| OpenAI Codex | `codex review` | Review-dedicated subcommand (inherently read-only) |\n| Anthropic Claude | `claude -p \"...\" --max-turns 3` | Bounded turns, no session persistence |\n\nThe orchestrator self-identifies its model family and skips the matching CLI (e.g., `claude` is skipped in Claude Code, `codex` is skipped in Codex). CLIs that aren't installed are skipped gracefully. Full mode only ‚Äî never run in quick mode. See [Code Review Strategy](./docs/CODE_REVIEW_STRATEGY.md) for design details.\n\n### Workflow Agents\n\n| Agent | Purpose |\n|-------|---------|\n| `task-worker` | Executes subtasks ‚Äî reads plan context, loads patterns, implements with TDD, commits |\n| `code-simplifier` | Behavior-preserving simplification pass on changed files before final review |\n| `branch-setup-worker` | Creates git worktrees or branches for isolation |\n| `pr-creator-worker` | Creates pull requests following repo conventions |\n\nWorkflow agents run as isolated subagents. Each `task-worker` gets its own context window with just its subtask from the plan.\n\n## HZL Integration (Optional)\n\nThis plugin supports [HZL](https://github.com/tmchow/hzl) for persistent task tracking across sessions and agents. Implementing detects HZL automatically and offers the choice between built-in and HZL task tracking. Without HZL, the workflow uses built-in task management.\n\nSee the [HZL repository](https://github.com/tmchow/hzl) for installation.\n\n## Changelog\n\nSee [CHANGELOG.md](../../CHANGELOG.md) for a detailed history of all changes, new features, and fixes across releases.\n\n## Credits\n\nThis plugin draws inspiration from:\n\n- [superpowers](https://github.com/obra/superpowers) by Jesse Vincent\n- [compound-engineering](https://github.com/EveryInc/compound-engineering-plugin) by [Kieran Klaassen](https://x.com/kieranklaassen) / [Every](https://every.to)\n- [pr-review-toolkit](https://github.com/anthropics/claude-code-pr-review) by Anthropic\n- [code-simplifier](https://github.com/anthropics/claude-code-code-simplifier) by Anthropic\n- [Shape Up](https://basecamp.com/shapeup) by Ryan Singer\n- [Shaping Skills](https://github.com/rjs/shaping-skills) by Ryan Singer\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "iterative-engineering",
          "source": "./plugins/iterative-engineering",
          "description": "Iterative development workflow - brainstorming, planning, multi-agent reviews, TDD execution, and PR feedback resolution",
          "version": "1.10.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add tmchow/tmc-marketplace",
            "/plugin install iterative-engineering@tmc-marketplace"
          ]
        }
      ]
    },
    {
      "name": "hzl",
      "version": null,
      "description": "HZL task tracking for coding agents",
      "repo_full_name": "tmchow/hzl",
      "repo_url": "https://github.com/tmchow/hzl",
      "repo_description": "External task ledger for coding agents and OpenClaw",
      "signals": {
        "stars": 13,
        "forks": 1,
        "pushed_at": "2026-02-20T10:17:59Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"hzl\",\n  \"description\": \"HZL task tracking for coding agents\",\n  \"owner\": {\n    \"name\": \"Trevin Chow\",\n    \"url\": \"https://github.com/tmchow\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"hzl\",\n      \"description\": \"HZL task management skill for multi-session, multi-agent workflows\",\n      \"version\": \"1.32.0\",\n      \"source\": \"./\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"hzl\",\n  \"version\": \"1.32.0\",\n  \"description\": \"HZL task management skill for multi-session, multi-agent workflows\",\n  \"author\": {\n    \"name\": \"Trevin Chow\",\n    \"url\": \"https://github.com/tmchow\"\n  },\n  \"repository\": \"https://github.com/tmchow/hzl\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"hzl\",\n    \"tasks\",\n    \"agents\",\n    \"tracking\"\n  ],\n  \"skills\": \"./skills/\"\n}\n",
        "README.md": "# HZL (Hazel)\n\n**External task ledger for coding agents.**\n\nüìö **[Full Documentation](https://www.hzl-tasks.com)** ‚Äî Concepts, workflows, and CLI reference\n\n---\n\n## Why HZL?\n\nMost task trackers are built for humans. HZL is built for agents:\n\n- **Backend-first** ‚Äî Task database with a CLI, not another Trello\n- **Model-agnostic** ‚Äî Tasks live outside any vendor's memory\n- **Multi-agent safe** ‚Äî Atomic claiming prevents duplicate work\n- **Resumable** ‚Äî Checkpoints let work survive session boundaries\n\nIf you already have a favorite human todo app, keep it. HZL is for shared task state that multiple agents can read and write.\n\n## When to Use HZL\n\nHZL is for when work outlives a single session:\n\n- **Cross-agent workflows** ‚Äî Claude Code, Codex, Gemini sharing one task board\n- **Session persistence** ‚Äî Pick up where you left off tomorrow\n- **Orchestration** ‚Äî One agent delegates to another with clean handoffs\n- **Backup** ‚Äî Cloud sync keeps task state safe\n\nIf you only use one agent and never need persistence, the built-in tracker is fine. Once you need durability or coordination, reach for HZL.\n\n---\n\n## Quickstart\n\n### 1. Install\n\nRequires Node.js 22.14+.\n\n```bash\ncurl -fsSL \"https://raw.githubusercontent.com/tmchow/hzl/main/scripts/install.sh?$(date +%s)\" | bash\n```\n\n<details>\n<summary>Alternative install methods</summary>\n\n**Homebrew (macOS/Linux):**\n```bash\nbrew tap tmchow/hzl && brew install hzl && hzl init\n```\n\n**NPM:**\n```bash\nnpm install -g hzl-cli && hzl init\n```\n</details>\n\n### 2. Add to Your Project\n\nAppend the agent policy to your repo so agents know when to use HZL:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/tmchow/hzl/main/snippets/AGENT-POLICY.md >> AGENTS.md\n```\n\n### 3. Create Tasks and Work\n\n```bash\n# Create a project and tasks\nhzl project create my-feature\nhzl task add \"Design the API\" -P my-feature\nhzl task add \"Implement endpoints\" -P my-feature --depends-on 1\n\n# Claim and work\nhzl task claim 1 --assignee claude-code\nhzl task checkpoint 1 \"API design complete\"\nhzl task complete 1\n\n# View progress\nhzl serve  # Opens web dashboard at localhost:3456\n```\n\n### Enable Cloud Sync (Optional)\n\n```bash\nhzl init --sync-url libsql://<db>.turso.io --auth-token <token>\n```\n\n---\n\n## Documentation\n\n| Section | What's There |\n|---------|-------------|\n| [Getting Started](https://www.hzl-tasks.com/getting-started/) | Installation, quickstart, agent setup |\n| [Concepts](https://www.hzl-tasks.com/concepts/) | Projects, tasks, dependencies, checkpoints, leases |\n| [Workflows](https://www.hzl-tasks.com/workflows/) | Single-agent, multi-agent, handoffs, breakdown patterns |\n| [CLI Reference](https://www.hzl-tasks.com/reference/cli) | Complete command documentation |\n| [Web Dashboard](https://www.hzl-tasks.com/dashboard) | Kanban board setup and usage |\n| [Troubleshooting](https://www.hzl-tasks.com/troubleshooting) | Common issues and fixes |\n\n---\n\n## Agent Setup\n\n### Claude Code\n\n```bash\n/plugin marketplace add tmchow/hzl\n/plugin install hzl@hzl\n```\n\n### OpenAI Codex\n\n```bash\nmkdir -p ~/.codex/skills/hzl\ncurl -fsSL https://raw.githubusercontent.com/tmchow/hzl/main/skills/hzl/SKILL.md -o ~/.codex/skills/hzl/SKILL.md\n```\n\n### OpenClaw\n\nCopy/paste into an OpenClaw chat:\n\n```\nInstall HZL from https://github.com/tmchow/hzl and run hzl init. Install the HZL skill from https://www.clawhub.ai/tmchow/hzl. Then append the HZL policy from https://raw.githubusercontent.com/tmchow/hzl/main/openclaw/OPENCLAW-TOOLS-PROMPT.md to my TOOLS.md.\n```\n\nSee [Coding Agents Setup](https://www.hzl-tasks.com/getting-started/coding-agents) for full details.\n\n---\n\n## Packages\n\n| Package | Description | Install |\n|---------|-------------|---------|\n| [`hzl-cli`](https://www.npmjs.com/package/hzl-cli) | CLI for task management | `npm install -g hzl-cli` |\n| [`hzl-core`](https://www.npmjs.com/package/hzl-core) | Core library for programmatic use | `npm install hzl-core` |\n| [`hzl-web`](https://www.npmjs.com/package/hzl-web) | Web server and Kanban dashboard | `npm install hzl-web` |\n\n---\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "hzl",
          "description": "HZL task management skill for multi-session, multi-agent workflows",
          "version": "1.32.0",
          "source": "./",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add tmchow/hzl",
            "/plugin install hzl@hzl"
          ]
        }
      ]
    }
  ]
}