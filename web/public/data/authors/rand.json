{
  "author": {
    "id": "rand",
    "display_name": "Rand Arete",
    "avatar_url": "https://avatars.githubusercontent.com/u/2835?u=682e1f30172b40f29d6fbd85ba75be9355299fb7&v=4"
  },
  "marketplaces": [
    {
      "name": "rlm-claude-code",
      "version": null,
      "description": "Marketplace for RLM-Claude-Code: Recursive Language Model with intelligent multi-provider routing",
      "repo_full_name": "rand/rlm-claude-code",
      "repo_url": "https://github.com/rand/rlm-claude-code",
      "repo_description": "Recursive Language Model integration for Claude Code - intelligent multi-provider routing and unbounded context handling",
      "signals": {
        "stars": 45,
        "forks": 5,
        "pushed_at": "2026-01-22T19:09:35Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"rlm-claude-code\",\n  \"description\": \"Marketplace for RLM-Claude-Code: Recursive Language Model with intelligent multi-provider routing\",\n  \"owner\": {\n    \"name\": \"rand\",\n    \"url\": \"https://github.com/rand\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"rlm-claude-code\",\n      \"source\": \"./\",\n      \"description\": \"Recursive Language Model integration for Claude Code - intelligent multi-provider routing and unbounded context handling\",\n      \"version\": \"0.5.0\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"rlm-claude-code\",\n  \"description\": \"Recursive Language Model integration for Claude Code - intelligent multi-provider routing and unbounded context handling\",\n  \"version\": \"0.5.0\",\n  \"author\": {\n    \"name\": \"Rand\",\n    \"url\": \"https://github.com/rand\"\n  },\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/rand/rlm-claude-code\",\n  \"repository\": \"https://github.com/rand/rlm-claude-code\",\n  \"keywords\": [\n    \"rlm\",\n    \"recursive-language-model\",\n    \"context-management\",\n    \"smart-routing\",\n    \"multi-provider\"\n  ]\n}\n",
        "README.md": "# RLM-Claude-Code\n\nTransform Claude Code into a Recursive Language Model (RLM) agent with intelligent orchestration, unbounded context handling, persistent memory, and REPL-based decomposition.\n\n**rlm-core integration**: This project optionally uses [rlm-core](https://github.com/rand/loop) as the unified RLM orchestration library, providing shared implementations with [recurse](https://github.com/rand/recurse). When rlm-core is installed and `RLM_USE_CORE=true`, Rust-based pattern classification offers 10-50x faster performance. Falls back to Python when unavailable.\n\n## What is RLM?\n\nRLM (Recursive Language Model) enables Claude to handle arbitrarily large contexts by decomposing complex tasks into smaller sub-queries. Instead of processing 500K tokens at once, RLM lets Claude:\n\n- **Peek** at context structure before deep analysis\n- **Search** using patterns to narrow focus\n- **Partition** large contexts and process in parallel via map-reduce\n- **Recurse** with sub-queries for verification\n- **Remember** facts and experiences across sessions\n\nThis results in better accuracy on complex tasks while optimizing cost through intelligent model selection.\n\n---\n\n## Quick Start\n\n### Prerequisites\n\n- **Python 3.12+**: `brew install python@3.12` or [python.org](https://python.org)\n- **uv** (Python package manager): `curl -LsSf https://astral.sh/uv/install.sh | sh`\n- **Rust 1.75+** (optional): `rustup update stable` (only if building rlm-core)\n\n### Installation\n\n```bash\n# Clone the repository\ngit clone https://github.com/rand/rlm-claude-code.git\ncd rlm-claude-code\n\n# Install dependencies\nuv sync --all-extras\n\n# Run tests to verify setup\nuv run pytest tests/ -v\n```\n\n### Optional: Building rlm-core for Performance\n\nFor 10-50x faster pattern classification, build the [rlm-core](https://github.com/rand/loop) Rust library with Python bindings:\n\n```bash\n# Clone rlm-core (if not already present)\ngit clone https://github.com/rand/loop.git ~/src/loop\n\n# Install maturin (Rust-Python build tool)\nuv tool install maturin\n\n# Build the Python bindings\ncd ~/src/loop/rlm-core\nPYO3_USE_ABI3_FORWARD_COMPATIBILITY=1 uv run maturin develop --release\n\n# Verify the build succeeded\nls -la ~/src/loop/rlm-core/python/rlm_core*.so\n```\n\nTo use rlm-core with the standalone package (not plugin):\n\n```bash\ncd /path/to/rlm-claude-code\n\n# Link rlm_core to your venv\necho \"$HOME/src/loop/rlm-core/python\" > .venv/lib/python3.12/site-packages/rlm_core.pth\n\n# Verify import works\nuv run python -c \"import rlm_core; print('OK:', rlm_core.PatternClassifier)\"\n\n# Enable via config (persistent) or environment (temporary)\n# Config method - add to ~/.claude/rlm-config.json:\n#   \"use_rlm_core\": true\n# Environment method:\nexport RLM_USE_CORE=true\n```\n\n**Without rlm-core**: All functionality works using Python fallback implementations. You'll see warnings but everything operates correctly.\n\n### As a Claude Code Plugin\n\n#### Step 1: Install the Plugin\n\n```bash\n# Add the marketplace (one-time setup)\nclaude plugin marketplace add github:rand/rlm-claude-code\n\n# Install the plugin\nclaude plugin install rlm-claude-code@rlm-claude-code\n```\n\n#### Step 2: Set Up the Plugin Environment\n\nThe plugin requires a Python virtual environment with dependencies. After installation:\n\n```bash\n# Navigate to the plugin directory (adjust version number as needed)\ncd ~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/$(ls ~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/ | sort -V | tail -1)\n\n# Create venv and install dependencies\nuv venv && uv sync\n```\n\n#### Step 3 (Optional): Enable rlm-core for Performance\n\nFor 10-50x faster pattern classification:\n\n```bash\n# First, build rlm-core if you haven't already (see \"Building rlm-core\" section above)\n\n# Get the plugin version directory\nPLUGIN_DIR=~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/$(ls ~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/ | sort -V | tail -1)\n\n# Link rlm_core to the plugin's venv\necho \"$HOME/src/loop/rlm-core/python\" > \"$PLUGIN_DIR/.venv/lib/python3.12/site-packages/rlm_core.pth\"\n\n# Verify it works\n\"$PLUGIN_DIR/.venv/bin/python\" -c \"import rlm_core; print('rlm_core OK:', rlm_core.PatternClassifier)\"\n\n# Enable rlm-core by default (add to your config)\ncat > ~/.claude/rlm-config.json << 'EOF'\n{\n  \"use_rlm_core\": true,\n  \"activation\": {\n    \"mode\": \"complexity\",\n    \"fallback_token_threshold\": 80000\n  },\n  \"depth\": {\n    \"default\": 2,\n    \"max\": 3\n  },\n  \"trajectory\": {\n    \"verbosity\": \"normal\",\n    \"streaming\": true\n  }\n}\nEOF\n```\n\n#### Step 4: Verify Installation\n\nRestart Claude Code. You should see \"RLM initialized\" on startup.\n\nTest the hooks manually:\n```bash\nPLUGIN_DIR=~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/$(ls ~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/ | sort -V | tail -1)\n\"$PLUGIN_DIR/.venv/bin/python\" \"$PLUGIN_DIR/scripts/init_rlm.py\"\n# Should print: RLM initialized\n```\n\n#### Updating the Plugin\n\nWhen updating, you'll need to re-create the venv:\n\n```bash\nclaude plugin update rlm-claude-code@rlm-claude-code\n\n# Re-setup the new version\nPLUGIN_DIR=~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/$(ls ~/.claude/plugins/cache/rlm-claude-code/rlm-claude-code/ | sort -V | tail -1)\ncd \"$PLUGIN_DIR\" && uv venv && uv sync\n\n# Re-link rlm_core if using it\necho \"$HOME/src/loop/rlm-core/python\" > \"$PLUGIN_DIR/.venv/lib/python3.12/site-packages/rlm_core.pth\"\n```\n\n---\n\n## Architecture\n\n```\nUser Query\n    │\n    ▼\n┌─────────────────────────────────────────────────────────┐\n│              INTELLIGENT ORCHESTRATOR                   │\n│  ┌───────────────────┐   ┌───────────────────────────┐  │\n│  │ Complexity        │   │ Orchestration Decision    │  │\n│  │ Classifier        │   │ • Activate RLM?           │  │\n│  │ • Token count     │──►│ • Which model tier?       │  │\n│  │ • Cross-file refs │   │ • Depth budget (0-3)?     │  │\n│  │ • Query patterns  │   │ • Tool access level?      │  │\n│  └───────────────────┘   └───────────────────────────┘  │\n└─────────────────────────────────────────────────────────┘\n    │\n    ▼ (if RLM activated)\n┌─────────────────────────────────────────────────────────┐\n│                 RLM EXECUTION ENGINE                    │\n│                                                         │\n│  ┌──────────────────┐    ┌──────────────────────────┐   │\n│  │  Context Manager │    │     REPL Sandbox         │   │\n│  │  • Externalize   │───►│  • peek(), search()      │   │\n│  │    conversation  │    │  • llm(), llm_batch()    │   │\n│  │  • files, tools  │    │  • map_reduce()          │   │\n│  └──────────────────┘    │  • find_relevant()       │   │\n│                          │  • memory_*() functions  │   │\n│                          └──────────────────────────┘   │\n│                                     │                   │\n│                                     ▼                   │\n│  ┌──────────────────┐    ┌──────────────────────────┐   │\n│  │ Recursive Handler│    │    Tool Bridge           │   │\n│  │ • Depth ≤ 3      │    │  • bash, read, grep      │   │\n│  │ • Model cascade  │    │  • Permission control    │   │\n│  │ • Sub-query spawn│    │  • Blocked commands      │   │\n│  └──────────────────┘    └──────────────────────────┘   │\n└─────────────────────────────────────────────────────────┘\n    │\n    ▼\n┌─────────────────────────────────────────────────────────┐\n│                  PERSISTENCE LAYER                      │\n│                                                         │\n│  ┌──────────────────┐    ┌──────────────────────────┐   │\n│  │  Memory Store    │    │   Reasoning Traces       │   │\n│  │  • Facts, exps   │    │  • Goals, decisions      │   │\n│  │  • Hyperedges    │    │  • Options, outcomes     │   │\n│  │  • SQLite + WAL  │    │  • Decision trees        │   │\n│  └──────────────────┘    └──────────────────────────┘   │\n│           │                         │                   │\n│           ▼                         ▼                   │\n│  ┌──────────────────┐    ┌──────────────────────────┐   │\n│  │ Memory Evolution │    │   Strategy Cache         │   │\n│  │ task → session   │    │  • Learn from success    │   │\n│  │ session → long   │    │  • Similarity matching   │   │\n│  │ decay → archive  │    │  • Suggest strategies    │   │\n│  └──────────────────┘    └──────────────────────────┘   │\n└─────────────────────────────────────────────────────────┘\n    │\n    ▼\n┌─────────────────────────────────────────────────────────┐\n│                  BUDGET & TRAJECTORY                    │\n│  • Token tracking per component                         │\n│  • Cost limits with alerts                              │\n│  • Streaming trajectory output                          │\n│  • JSON export for analysis                             │\n└─────────────────────────────────────────────────────────┘\n    │\n    ▼\nFinal Answer\n```\n\n---\n\n## rlm-core Integration (Optional)\n\nRLM-Claude-Code optionally integrates with the [rlm-core](https://github.com/rand/loop) Rust library for improved performance.\n\n### Enabling rlm-core\n\nThere are two ways to enable rlm-core (in priority order):\n\n**1. Environment variable** (highest priority, good for testing):\n```bash\nexport RLM_USE_CORE=true\n```\n\n**2. Config file** (persistent, recommended for regular use):\n\nAdd `\"use_rlm_core\": true` to `~/.claude/rlm-config.json`:\n```json\n{\n  \"use_rlm_core\": true,\n  \"activation\": { ... }\n}\n```\n\n| Setting | Behavior |\n|---------|----------|\n| `use_rlm_core: true` | Use rlm-core Rust bindings (requires installation) |\n| `use_rlm_core: false` or unset | Use Python fallback (default, always works) |\n\nWhen rlm-core is enabled but not installed, a warning is logged and Python fallback is used automatically.\n\n### Performance Comparison\n\n| Component | Python Fallback | With rlm-core |\n|-----------|-----------------|---------------|\n| Pattern Classifier | Python regex | Rust via PyO3 (10-50x faster) |\n| Trajectory Events | Python classes | Rust types via PyO3 |\n| Memory Store | Python + SQLite | Python + SQLite (rlm-core memory disabled*) |\n\n*rlm-core memory store integration is disabled pending feature parity (metadata, FTS5 search).\n\n### Benefits of rlm-core\n\n- **Consistency**: Same classification logic as recurse TUI\n- **Performance**: Rust pattern matching is significantly faster\n- **Shared Codebase**: Bug fixes benefit both projects\n\n### Python Bindings Usage\n\n```python\nimport os\nos.environ[\"RLM_USE_CORE\"] = \"true\"\n\nfrom src.complexity_classifier import should_activate_rlm, extract_complexity_signals\nfrom src.types import SessionContext, Message, MessageRole\n\n# The bridge code auto-converts types and delegates to rlm_core when available\nctx = SessionContext(messages=[Message(role=MessageRole.USER, content=\"test\")])\nsignals = extract_complexity_signals(\"Find security vulnerabilities\", ctx)\nactivate, reason = should_activate_rlm(\"Find security vulnerabilities\", ctx)\n# Returns: (True, \"complexity_score:2:cross_context+pattern_search\")\n```\n\n---\n\n## Core Components\n\n### REPL Environment\n\nThe REPL provides a sandboxed Python environment for context manipulation:\n\n**Context Variables:**\n- `conversation` - List of message dicts with role and content\n- `files` - Dict mapping filenames to content\n- `tool_outputs` - List of tool execution results\n- `working_memory` - Scratchpad for intermediate results\n\n**Helper Functions:**\n\n| Function | Description |\n|----------|-------------|\n| `peek(var, start, end)` | View a slice of any context variable |\n| `search(var, pattern, regex=False)` | Find patterns in context |\n| `summarize(var, max_tokens)` | LLM-powered summarization |\n| `llm(query, context, spawn_repl)` | Spawn recursive sub-query |\n| `llm_batch([(q1,c1), (q2,c2), ...])` | Parallel LLM calls |\n| `map_reduce(content, map_prompt, reduce_prompt, n_chunks)` | Partition and aggregate |\n| `find_relevant(content, query, top_k)` | Find most relevant sections |\n| `extract_functions(content)` | Parse function definitions |\n| `run_tool(tool, *args)` | Safe subprocess (uv, ty, ruff) |\n\n**Memory Functions** (when enabled):\n\n| Function | Description |\n|----------|-------------|\n| `memory_query(query, limit)` | Search stored knowledge |\n| `memory_add_fact(content, confidence)` | Store a fact |\n| `memory_add_experience(content, outcome, success)` | Store an experience |\n| `memory_get_context(limit)` | Retrieve relevant context |\n| `memory_relate(node1, node2, relation)` | Create relationships |\n\n**Available Libraries:**\n\n| Library | Alias | Description |\n|---------|-------|-------------|\n| `re` | - | Regular expressions |\n| `json` | - | JSON encoding/decoding |\n| `pydantic` | `BaseModel`, `Field` | Data validation |\n| `hypothesis` | `given`, `st` | Property-based testing |\n| `cpmpy` | `cp` | Constraint programming |\n| `numpy` | `np` | Numerical computing |\n| `pandas` | `pd` | DataFrames and analysis |\n| `polars` | `pl` | Fast DataFrames |\n| `seaborn` | `sns` | Statistical visualization |\n\n### Memory System\n\nPersistent storage for cross-session learning:\n\n- **Node Types**: facts, experiences, procedures, goals\n- **Memory Tiers**: task → session → longterm → archive\n- **Session Isolation**: task/session tiers are isolated per terminal; longterm/archive shared (see [docs/session-isolation.md](docs/session-isolation.md))\n- **Hyperedges**: N-ary relationships with typed roles\n- **Storage**: SQLite with WAL mode for concurrent access\n\n```python\nfrom src import MemoryStore, MemoryEvolution\n\n# Create and use memory\nstore = MemoryStore(db_path=\"~/.claude/rlm-memory.db\")\nfact_id = store.create_node(\n    node_type=\"fact\",\n    content=\"This project uses FastAPI\",\n    confidence=0.9,\n)\n\n# Evolve memory through tiers\nevolution = MemoryEvolution(store)\nevolution.consolidate(task_id=\"current-task\")  # task → session\nevolution.promote(session_id=\"current-session\")  # session → longterm\nevolution.decay(days_threshold=30)  # longterm → archive\n```\n\n### Reasoning Traces\n\nTrack decision-making for transparency and debugging:\n\n```python\nfrom src import ReasoningTraces\n\ntraces = ReasoningTraces(store)\n\n# Create goal and decision tree\ngoal_id = traces.create_goal(\"Implement user authentication\")\ndecision_id = traces.create_decision(goal_id, \"Choose auth strategy\")\n\n# Track options considered\njwt_option = traces.add_option(decision_id, \"Use JWT tokens\")\nsession_option = traces.add_option(decision_id, \"Use session cookies\")\n\n# Record choice and reasoning\ntraces.choose_option(decision_id, jwt_option)\ntraces.reject_option(decision_id, session_option, \"JWT better for API\")\n\n# Get full decision tree\ntree = traces.get_decision_tree(goal_id)\n```\n\n### Budget Tracking\n\nGranular cost control with configurable limits:\n\n```python\nfrom src import EnhancedBudgetTracker, BudgetLimits\n\ntracker = EnhancedBudgetTracker()\ntracker.set_limits(BudgetLimits(\n    max_cost_per_task=5.0,\n    max_recursive_calls=10,\n    max_depth=3,\n))\n\n# Check before expensive operations\nallowed, reason = tracker.can_make_llm_call()\nif not allowed:\n    print(f\"Budget exceeded: {reason}\")\n\n# Get detailed metrics\nmetrics = tracker.get_metrics()\nprint(f\"Cost: ${metrics.total_cost_usd:.2f}\")\nprint(f\"Depth: {metrics.max_depth_reached}\")\nprint(f\"Calls: {metrics.sub_call_count}\")\n```\n\n---\n\n## Using RLM\n\n### Slash Commands\n\n| Command | Description |\n|---------|-------------|\n| `/rlm` | Show current status |\n| `/rlm on` | Enable RLM for this session |\n| `/rlm off` | Disable RLM mode |\n| `/rlm status` | Full configuration display |\n| `/rlm mode <fast\\|balanced\\|thorough>` | Set execution mode |\n| `/rlm depth <0-3>` | Set max recursion depth |\n| `/rlm budget $X` | Set session cost limit |\n| `/rlm model <opus\\|sonnet\\|haiku\\|auto>` | Force model selection |\n| `/rlm tools <none\\|repl\\|read\\|full>` | Set sub-LLM tool access |\n| `/rlm verbosity <minimal\\|normal\\|verbose\\|debug>` | Set output detail |\n| `/rlm reset` | Reset to defaults |\n| `/rlm save` | Save preferences to disk |\n| `/simple` | Bypass RLM for current query |\n| `/trajectory <file>` | Analyze a trajectory file |\n| `/test` | Run test suite |\n| `/bench` | Run benchmarks |\n| `/code-review` | Review code changes |\n\n### Execution Modes\n\n| Mode | Depth | Model | Tools | Best For |\n|------|-------|-------|-------|----------|\n| `fast` | 1 | Haiku | REPL only | Quick questions, iteration |\n| `balanced` | 2 | Sonnet | Read-only | Most tasks (default) |\n| `thorough` | 3 | Opus | Full access | Complex debugging, architecture |\n\n### Auto-Activation\n\nRLM automatically activates when it detects:\n- **Large context**: >80K tokens in conversation\n- **Cross-file reasoning**: Questions spanning multiple files\n- **Complex debugging**: Stack traces, error analysis\n- **Architecture questions**: System design, refactoring patterns\n\nForce activation with `/rlm on` or bypass with `/simple`.\n\n---\n\n## Configuration\n\n### Config File\n\nRLM stores configuration at `~/.claude/rlm-config.json`:\n\n```json\n{\n  \"use_rlm_core\": true,\n  \"activation\": {\n    \"mode\": \"complexity\",\n    \"fallback_token_threshold\": 80000\n  },\n  \"depth\": {\n    \"default\": 2,\n    \"max\": 3\n  },\n  \"trajectory\": {\n    \"verbosity\": \"normal\",\n    \"streaming\": true\n  }\n}\n```\n\n| Key | Type | Description |\n|-----|------|-------------|\n| `use_rlm_core` | bool | Enable rlm-core Rust bindings (default: `false`) |\n| `activation.mode` | string | `\"micro\"`, `\"complexity\"`, `\"always\"`, `\"manual\"` |\n| `depth.default` | int | Default recursion depth (1-3) |\n| `trajectory.verbosity` | string | `\"minimal\"`, `\"normal\"`, `\"verbose\"`, `\"debug\"` |\n\n### Environment Variables\n\n| Variable | Purpose |\n|----------|---------|\n| `ANTHROPIC_API_KEY` | Anthropic API access (uses Claude Code's key) |\n| `OPENAI_API_KEY` | OpenAI API access (optional, for GPT models) |\n| `RLM_USE_CORE` | Enable rlm-core Rust bindings (`true`/`false`) |\n| `RLM_CONFIG_PATH` | Custom config file location |\n| `RLM_DEBUG` | Enable debug logging |\n\n---\n\n## Hooks\n\nRLM integrates with Claude Code via hooks:\n\n| Hook | Script | Purpose |\n|------|--------|---------|\n| `SessionStart` | `init_rlm.py` | Initialize RLM environment |\n| `UserPromptSubmit` | `check_complexity.py` | Decide if RLM should activate |\n| `PreToolUse` | `sync_context.py` | Sync tool context with RLM state |\n| `PostToolUse` | `capture_output.py` | Capture tool output for context |\n| `PreCompact` | `externalize_context.py` | Externalize before compaction |\n| `Stop` | `save_trajectory.py` | Save trajectory on session end |\n\n### Hook Setup (Important!)\n\nClaude Code plugins register hooks in `hooks/hooks.json`, but these need to be merged into your global `~/.claude/settings.json` to take effect.\n\n**After installing or updating this plugin, run:**\n\n```bash\npython3 ~/.claude/scripts/merge-plugin-hooks.py\n```\n\nIf you don't have the merge script, create it:\n\n```bash\nmkdir -p ~/.claude/scripts\ncurl -o ~/.claude/scripts/merge-plugin-hooks.py \\\n  https://raw.githubusercontent.com/rand/rlm-claude-code/main/scripts/merge-plugin-hooks.py\n```\n\n### Hook Path Design\n\nThis plugin uses `${CLAUDE_PLUGIN_ROOT}` variable and `.venv/bin/python` (not `uv run`) to ensure hooks work correctly:\n\n- **`${CLAUDE_PLUGIN_ROOT}`** - Expands to the plugin's install path, ensuring hooks work after updates\n- **`.venv/bin/python`** - Direct venv Python, avoiding `uv run` sandbox issues on macOS\n\n### Verifying Hooks\n\nCheck hooks are correctly registered:\n\n```bash\n# See which hooks are active\ncat ~/.claude/settings.json | jq '.hooks.SessionStart'\n\n# Verify paths point to current version\ncat ~/.claude/plugins/installed_plugins.json | jq '.plugins[\"rlm-claude-code@rlm-claude-code\"][0].version'\n```\n\nIf hook paths don't match the installed version, re-run the merge script.\n\n### Troubleshooting Hooks\n\n**\"RLM not initializing\"**\n1. Run `python3 ~/.claude/scripts/merge-plugin-hooks.py`\n2. Restart Claude Code\n3. Check: `cat ~/.claude/settings.json | jq '.hooks.SessionStart'`\n\n**Hooks pointing to old version**\n- This happens after plugin updates\n- Run `python3 ~/.claude/scripts/merge-plugin-hooks.py` after each update\n\n**macOS sandbox errors with uv**\n- This plugin already uses `.venv/bin/python` to avoid this issue\n- If you see `SCDynamicStore` errors, verify hooks don't use `uv run`\n\n---\n\n## Development\n\n### Setup\n\n```bash\ngit clone https://github.com/rand/rlm-claude-code.git\ncd rlm-claude-code\n\n# Install all dependencies\nuv sync --all-extras\n\n# Run tests (3000+ tests)\nuv run pytest tests/ -v\n\n# Type check\nuv run ty check src/\n\n# Lint and format\nuv run ruff check src/ --fix\nuv run ruff format src/\n```\n\n### Project Structure\n\n```\nrlm-claude-code/\n├── src/\n│   ├── orchestrator.py           # Main RLM loop\n│   ├── intelligent_orchestrator.py  # Claude-powered decisions\n│   ├── auto_activation.py        # Complexity-based activation\n│   ├── context_manager.py        # Context externalization\n│   ├── repl_environment.py       # Sandboxed Python REPL\n│   ├── recursive_handler.py      # Sub-query management\n│   ├── memory_store.py           # Persistent memory (SQLite)\n│   ├── memory_evolution.py       # Memory tier management\n│   ├── reasoning_traces.py       # Decision tree tracking\n│   ├── enhanced_budget.py        # Cost tracking and limits\n│   ├── trajectory.py             # Event logging\n│   ├── trajectory_analysis.py    # Strategy extraction\n│   ├── strategy_cache.py         # Learn from success\n│   ├── tool_bridge.py            # Controlled tool access\n│   └── ...\n├── tests/\n│   ├── unit/                     # Unit tests\n│   ├── integration/              # Integration tests\n│   ├── property/                 # Hypothesis property tests\n│   └── security/                 # Security tests\n├── scripts/                      # Hook scripts\n├── hooks/                        # hooks.json\n├── commands/                     # Slash command definitions\n└── docs/                         # Documentation\n```\n\n### Running Tests\n\nThe test suite has 3,200+ tests including property-based tests (Hypothesis) and benchmarks.\n\n**Quick iteration** (~30 seconds):\n```bash\n# Fast mode - 10 examples per property test\nHYPOTHESIS_PROFILE=fast uv run pytest tests/unit/ -v\n```\n\n**Standard development** (default, ~2-3 minutes):\n```bash\n# Dev mode - 50 examples per property test\nuv run pytest tests/ -v\n```\n\n**Full CI run** (~5+ minutes):\n```bash\n# CI mode - 100 examples, all phases\nHYPOTHESIS_PROFILE=ci uv run pytest tests/ -v\n```\n\n**Benchmarks** (run separately, ~1-2 minutes):\n```bash\n# Performance benchmarks\nuv run pytest tests/benchmarks/ --benchmark-only\n```\n\n### Hypothesis Profiles\n\n| Profile | Examples | Use Case |\n|---------|----------|----------|\n| `fast` | 10 | Quick iteration, TDD |\n| `dev` | 50 | Local development (default) |\n| `ci` | 100 | CI/CD, thorough testing |\n\nSet via environment: `HYPOTHESIS_PROFILE=fast pytest ...`\n\n### Test Categories\n\n```bash\n# Unit tests only (fastest)\nuv run pytest tests/unit/ -v\n\n# Integration tests\nuv run pytest tests/integration/ -v\n\n# Property-based tests\nuv run pytest tests/property/ -v\n\n# Security tests\nuv run pytest tests/security/ -v\n\n# Include benchmarks (excluded by default)\nuv run pytest tests/ tests/benchmarks/ --benchmark-only\n```\n\n---\n\n## Troubleshooting\n\n### RLM Not Initializing\n\n1. Check plugin installation: `claude plugin list`\n2. Check hooks: `ls hooks/hooks.json`\n3. Test init script: `uv run python scripts/init_rlm.py`\n\n### Module Import Errors\n\nInstall dependencies:\n```bash\nuv sync --all-extras\n```\n\n### Reset Everything\n\n```bash\nrm ~/.claude/rlm-config.json\nrm ~/.claude/rlm-memory.db\n```\n\n---\n\n## Documentation\n\n| Document | Description |\n|----------|-------------|\n| [Getting Started](./docs/getting-started.md) | Installation and first steps |\n| [User Guide](./docs/user-guide.md) | Complete usage documentation |\n| [Specification](./rlm-claude-code-spec.md) | Technical specification |\n| [Architecture](./docs/process/architecture.md) | ADRs and design decisions |\n| [SPEC Overview](./docs/spec/00-overview.md) | Capability specifications |\n\n---\n\n## References\n\n- [RLM Paper](https://arxiv.org/abs/2512.24601v1) - Zhang, Kraska, Khattab\n- [Alex Zhang's RLM Blog](https://alexzhang13.github.io/blog/2025/rlm/)\n- [Claude Code Plugins](https://docs.anthropic.com/en/docs/claude-code)\n\n---\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "rlm-claude-code",
          "source": "./",
          "description": "Recursive Language Model integration for Claude Code - intelligent multi-provider routing and unbounded context handling",
          "version": "0.5.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add rand/rlm-claude-code",
            "/plugin install rlm-claude-code@rlm-claude-code"
          ]
        }
      ]
    }
  ]
}