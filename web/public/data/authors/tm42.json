{
  "author": {
    "id": "tm42",
    "display_name": "tm42",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/15903435?v=4",
    "url": "https://github.com/tm42",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 0,
      "total_stars": 3,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "mnemograph-plugins",
      "version": null,
      "description": "Mnemograph Claude Code plugin with memory subagents and hooks",
      "owner_info": {
        "name": "tm42",
        "email": "tm42@users.noreply.github.com"
      },
      "keywords": [],
      "repo_full_name": "tm42/mnemograph",
      "repo_url": "https://github.com/tm42/mnemograph",
      "repo_description": "graph-based persistent, yet lightweight memory MCP for CC",
      "homepage": "",
      "signals": {
        "stars": 3,
        "forks": 0,
        "pushed_at": "2026-01-16T20:32:09Z",
        "created_at": "2026-01-10T21:11:00Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 685
        },
        {
          "path": "mnemograph-claude-code",
          "type": "tree",
          "size": null
        },
        {
          "path": "mnemograph-claude-code/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "mnemograph-claude-code/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 525
        },
        {
          "path": "mnemograph-claude-code/README.md",
          "type": "blob",
          "size": 3967
        },
        {
          "path": "mnemograph-claude-code/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "mnemograph-claude-code/agents/memory-init.md",
          "type": "blob",
          "size": 2286
        },
        {
          "path": "mnemograph-claude-code/agents/memory-store.md",
          "type": "blob",
          "size": 6600
        },
        {
          "path": "mnemograph-claude-code/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "mnemograph-claude-code/commands/recall.md",
          "type": "blob",
          "size": 1322
        },
        {
          "path": "mnemograph-claude-code/commands/remember.md",
          "type": "blob",
          "size": 1989
        },
        {
          "path": "mnemograph-claude-code/commands/visualize-memory-graph.md",
          "type": "blob",
          "size": 2567
        },
        {
          "path": "mnemograph-claude-code/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "mnemograph-claude-code/hooks/hooks.json",
          "type": "blob",
          "size": 736
        },
        {
          "path": "mnemograph-claude-code/hooks/session_start.py",
          "type": "blob",
          "size": 2183
        },
        {
          "path": "mnemograph-claude-code/hooks/stop_hook.py",
          "type": "blob",
          "size": 2463
        },
        {
          "path": "mnemograph-claude-code/hooks/user_prompt.py",
          "type": "blob",
          "size": 5037
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"mnemograph-plugins\",\n  \"owner\": {\n    \"name\": \"tm42\",\n    \"email\": \"tm42@users.noreply.github.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Mnemograph Claude Code plugin with memory subagents and hooks\",\n    \"version\": \"0.4.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"mnemograph\",\n      \"description\": \"Persistent memory for Claude Code sessions via mnemograph knowledge graph\",\n      \"version\": \"0.4.0\",\n      \"author\": {\n        \"name\": \"tm42\"\n      },\n      \"source\": \"./mnemograph-claude-code\",\n      \"category\": \"memory\",\n      \"tags\": [\"memory\", \"knowledge-graph\", \"persistence\"]\n    }\n  ]\n}\n",
        "mnemograph-claude-code/.claude-plugin/plugin.json": "{\n  \"name\": \"mnemograph\",\n  \"version\": \"0.4.1\",\n  \"description\": \"Persistent memory for Claude Code sessions via mnemograph knowledge graph\",\n  \"author\": {\n    \"name\": \"tm42\",\n    \"email\": \"tm42@users.noreply.github.com\"\n  },\n  \"homepage\": \"https://github.com/tm42/mnemograph\",\n  \"repository\": \"https://github.com/tm42/mnemograph\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"memory\", \"knowledge-graph\", \"persistent-context\", \"mcp\"],\n  \"commands\": \"./commands/\",\n  \"agents\": [\"./agents/memory-init.md\", \"./agents/memory-store.md\"]\n}\n",
        "mnemograph-claude-code/README.md": "# Mnemograph Claude Code Plugin\n\nA Claude Code hook plugin that provides persistent memory across sessions using the [mnemograph](https://github.com/tm42/mnemograph) knowledge graph.\n\n## Features\n\n- **SessionStart hook**: Automatically injects relevant memory context at the start of each session\n- **Stop hook**: Reminds you to save learnings at session end\n- **Auto-commit** (optional): Automatically commits memory changes when session ends\n- **memory-store agent**: Quality-enforced knowledge storage with deduplication\n- **memory-init agent**: Fast session briefings using Haiku\n\n## Installation\n\n### Prerequisites\n\n1. [mnemograph](https://github.com/tm42/mnemograph) must be installed and configured\n2. A memory directory must exist (either project-local `.claude/memory/` or global `~/.claude/memory/`)\n\n### Install the plugin\n\n```bash\n# Clone or copy this directory\ngit clone https://github.com/tm42/mnemograph.git\ncd mnemograph/mnemograph-claude-code\n\n# Add to Claude Code plugins\nclaude plugins add /path/to/mnemograph-claude-code\n```\n\nOr symlink to your plugins directory:\n\n```bash\nln -s /path/to/mnemograph/mnemograph-claude-code ~/.claude/plugins/mnemograph\n```\n\n## Configuration\n\nCreate `.claude/mnemograph-hook.yaml` in your project to configure behavior:\n\n```yaml\n# Auto-commit memory changes at session end (default: false)\nauto_commit: false\n```\n\n## How It Works\n\n### SessionStart Hook\n\nWhen a Claude Code session starts, this hook:\n\n1. Detects the project from the working directory\n2. Checks for mnemograph memory (project-local first, then global)\n3. Retrieves a shallow memory context via `recall()`\n4. Injects the context into the session\n\nThe context appears as:\n\n```xml\n<mnemograph-context project=\"my-project\">\n[Memory summary, recent entities, gotchas...]\n</mnemograph-context>\n```\n\n### Stop Hook\n\nWhen a session ends normally, this hook:\n\n1. Outputs a reminder to save any learnings\n2. Optionally auto-commits memory changes (if configured)\n\n## Agents\n\n### memory-store\n\nA dedicated subagent (Haiku) that handles all knowledge storage with quality enforcement:\n\n- **Deduplication**: Checks `find_similar()` before every create\n- **Canonical naming**: Enforces \"Decision: X\", proper casing, no articles\n- **Auto-relations**: Calls `suggest_relations()` and creates obvious connections\n- **Importance levels**: Supports `low|normal|high` for relation weighting\n\n**Usage via command:**\n```\n/remember we decided to use JWT for auth\n```\n\n**Direct invocation for batch stores:**\n```xml\n<store-request>\n  <item content=\"chose SQLite for simplicity\" type_hint=\"decision\"/>\n  <item content=\"gotcha: WAL doesn't work on network drives\" type_hint=\"learning\" related_to=\"Decision: Use SQLite\"/>\n</store-request>\n```\n\n**Background storage (non-blocking):**\n```python\nTask(\n  subagent_type=\"memory-store\",\n  run_in_background=True,\n  prompt=\"<store-request><item content=\\\"...\\\"/></store-request>\"\n)\n```\n\n### memory-init\n\nFast session briefing agent that summarizes the knowledge graph at session start. Outputs a compact XML briefing with entity counts and key highlights.\n\n## Memory Detection\n\nThe plugin looks for memory in this order:\n\n1. **Project-local**: `./.claude/memory/` (relative to cwd)\n2. **MEMORY_PATH**: Environment variable if set\n3. **Global**: `~/.claude/memory/`\n\n## Troubleshooting\n\n**No context injected at session start?**\n- Check that mnemograph is installed: `pip show mnemograph`\n- Check that a memory directory exists with `events.jsonl`\n- The hook fails silently if mnemograph is unavailable\n\n**Timeouts?**\n- SessionStart has a 10-second timeout\n- Stop hook has a 5-second timeout\n- If your memory graph is large, context retrieval may time out\n\n## Development\n\n```bash\n# Install dev dependencies\npip install -e \".[dev]\"\n\n# Test the hooks manually\necho '{\"cwd\": \"/path/to/project\"}' | python hooks/session_start.py\necho '{\"cwd\": \"/path/to/project\", \"stopReason\": \"end_turn\"}' | python hooks/stop_hook.py\n```\n\n## License\n\nMIT\n",
        "mnemograph-claude-code/agents/memory-init.md": "---\nname: memory-init\ndescription: Initializes memory context at session start by analyzing the knowledge graph. Use at session start to get a compact briefing of relevant memories.\ntools: mcp__mnemograph__session_start, mcp__mnemograph__recall\nmodel: haiku\ncolor: blue\n---\n\nYou are a memory initialization agent. Your ONLY job is to quickly analyze the knowledge graph and output a compact briefing for the main Claude agent.\n\n## Your Task\n\n1. Call `session_start` with the project name from the prompt\n2. Parse the response: entity count, relation count, context, first_run flag\n3. Extract key highlights from the context (gotchas, decisions, open questions)\n4. Output a single XML briefing block\n\n## Output Format\n\n```xml\n<memory-briefing project=\"PROJECT_NAME\" entities=\"N\" relations=\"N\" status=\"STATUS\">\n  <highlights>\n    - Highlight 1 (gotcha, decision, or key fact)\n    - Highlight 2\n    - Highlight 3\n  </highlights>\n</memory-briefing>\n```\n\nWhere STATUS is one of:\n- `empty` — no entities in graph\n- `first_run` — graph was just bootstrapped with usage guide\n- `small` — fewer than 10 entities\n- `active` — 10+ entities, healthy graph\n\n## Rules\n\n1. **ONE tool call maximum** — use `session_start(project_hint=\"...\")`. Only use `recall` if session_start fails.\n2. **Output ONLY the XML block** — no explanations, no commentary, no markdown formatting around it.\n3. **Be fast** — complete in under 2 seconds.\n4. **Extract highlights intelligently**:\n   - Look for observations starting with \"Gotcha:\", \"Warning:\", \"Decision:\"\n   - Include recent decisions or learnings\n   - Note any open questions\n   - Max 5 highlights\n5. **If memory is empty**, output: `<memory-briefing status=\"empty\"/>`\n\n## Example\n\nGiven session_start returns:\n```json\n{\n  \"memory_summary\": {\"entity_count\": 23, \"relation_count\": 45},\n  \"context\": \"mnemograph: Event-sourced knowledge graph...\\nGotcha: MCP uses stdout for protocol...\",\n  \"project\": \"mnemograph\"\n}\n```\n\nOutput:\n```xml\n<memory-briefing project=\"mnemograph\" entities=\"23\" relations=\"45\" status=\"active\">\n  <highlights>\n    - Gotcha: MCP uses stdout for protocol, stderr for logs\n    - Event-sourced knowledge graph with SQLite storage\n    - Uses sentence-transformers for local embeddings\n  </highlights>\n</memory-briefing>\n```\n",
        "mnemograph-claude-code/agents/memory-store.md": "---\nname: memory-store\ndescription: Stores knowledge in the mnemograph graph with quality enforcement. Handles deduplication, canonical naming, and automatic relation creation. Use for all remember/store operations.\ntools: mcp__mnemograph__find_similar, mcp__mnemograph__recall, mcp__mnemograph__remember, mcp__mnemograph__add_observations, mcp__mnemograph__create_relations, mcp__mnemograph__suggest_relations, mcp__mnemograph__set_relation_importance\nmodel: haiku\ncolor: green\n---\n\nYou are a memory storage agent. Your ONLY job is to persist knowledge to the graph with HIGH QUALITY and output a structured confirmation.\n\n## Input Format\n\nYou receive a `<store-request>` containing one or more items:\n\n```xml\n<store-request>\n  <item content=\"what to remember\" type_hint=\"decision|pattern|learning|concept|question|project\" related_to=\"existing entity\" importance=\"low|normal|high\"/>\n</store-request>\n```\n\n- `content` (required): Natural language description of what to store\n- `type_hint` (optional): Suggested entity type\n- `related_to` (optional): Known related entity names\n- `importance` (optional): Priority level affecting relation weights\n  - `low`: Transient knowledge, may be pruned later\n  - `normal`: Standard knowledge (default)\n  - `high`: Critical decisions, gotchas — set higher relation weights\n\n## Processing Pipeline\n\nFor EACH item:\n\n### Step 1: Parse\n\nExtract from the content:\n- **Entity name**: Canonical form (see naming rules below)\n- **Entity type**: Use type_hint if provided, otherwise infer\n- **Observations**: Atomic facts (one idea each)\n\n### Step 2: Check Duplicates (TWO-PHASE)\n\n**Phase 2a: Lexical check**\nCall `find_similar(name, threshold=0.5)` — lower threshold to catch more candidates.\n\n**Phase 2b: Semantic check**\nCall `recall(query=content, depth=\"shallow\")` to find semantically related entities.\n\nExamine results from BOTH phases. Look for entities that:\n- Have the same core concept (e.g., \"event sourcing\" in different phrasings)\n- Are the same type (both decisions, both patterns, etc.)\n- Would be redundant if both existed\n\n**Duplicate decision matrix:**\n| Finding | Action |\n|---------|--------|\n| Exact or near-exact match found | Merge: use `add_observations` to existing entity |\n| Same concept, different name | Merge into existing, note in output |\n| Related but distinct | Create new, add relation to existing |\n| No match | Create new entity |\n\n**Examples of duplicates to catch:**\n- \"Decision: Event Sourcing\" ↔ \"Decision: Use event sourcing for memory system\" → SAME\n- \"Decision: Use JWT\" ↔ \"Decision: JWT for authentication\" → SAME\n- \"Pattern: Repository\" ↔ \"Decision: Use repository pattern\" → RELATED (different types)\n\n### Step 3: Store\n\n- **New entity**: Use `remember(name, entity_type, observations, relations)`\n- **Existing entity**: Use `add_observations(entityName, contents)`\n\n### Step 4: Connect\n\nFor NEW entities only:\n1. Call `suggest_relations(entity)`\n2. Auto-create relations with confidence ≥0.8\n3. Create explicit relations from `related_to` input\n\n### Step 5: Weight (if importance specified)\n\nFor `importance=\"high\"` items:\n- Use `set_relation_importance(relation_id, 0.9)` on created relations\n- Add observation prefix: \"Important: ...\"\n\nFor `importance=\"low\"` items:\n- Use `set_relation_importance(relation_id, 0.3)` on created relations\n- These may be pruned by `get_weak_relations()` later\n\n## Naming Rules\n\nApply these transformations to get canonical names:\n\n| Pattern | Canonical Form | Example |\n|---------|---------------|---------|\n| Decisions | Prefix with \"Decision: \" | \"Decision: Use JWT\" |\n| Patterns | Prefix with \"Pattern: \" | \"Pattern: Repository\" |\n| Learnings | Prefix with \"Learning: \" | \"Learning: WAL needs shared memory\" |\n| Questions | Prefix with \"Question: \" | \"Question: Add real-time sync?\" |\n| Acronyms | Use acronym, not expansion | \"JWT\" not \"JSON Web Tokens\" |\n| Tools/libs | Proper casing | \"SQLite\" not \"sqlite\" |\n| No articles | Drop a/an/the | \"API\" not \"the API\" |\n\n## Observation Rules\n\nSplit compound statements into atomic facts:\n- BAD: \"SQLite is fast and uses WAL mode for concurrency\"\n- GOOD: [\"SQLite optimized for read performance\", \"Uses WAL mode for concurrent access\"]\n\nUse prefixes for special observations:\n- `Gotcha: ...` — surprising behavior\n- `Warning: ...` — things to avoid\n- `Status: ...` — current state\n\n## Output Format\n\nOutput ONLY this XML block — no explanations, no markdown around it:\n\n```xml\n<memory-stored items=\"N\" duplicates_merged=\"N\">\n  <stored>\n    <entity name=\"NAME\" type=\"TYPE\" action=\"created|updated|merged\">\n      <observations added=\"N\"/>\n      <relations created=\"N\" auto=\"N\"/>\n    </entity>\n  </stored>\n  <ambiguous>\n    <item name=\"NAME\" similar_to=\"EXISTING\" similarity=\"0.XX\"/>\n  </ambiguous>\n</memory-stored>\n```\n\n- `items`: Total items processed\n- `duplicates_merged`: Items merged into existing entities\n- `action`: \"created\" (new), \"updated\" (added to existing), \"merged\" (consolidated)\n- `auto`: Relations auto-created from suggest_relations\n- `<ambiguous>`: Items in 0.70-0.84 similarity range (for main Claude's awareness)\n\n## Example\n\n**Input:**\n```xml\n<store-request>\n  <item content=\"we decided to use SQLite because it's simple and file-based\" type_hint=\"decision\"/>\n  <item content=\"gotcha: SQLite WAL mode doesn't work on network drives\" related_to=\"Decision: Use SQLite\"/>\n</store-request>\n```\n\n**Processing:**\n1. Item 1: find_similar(\"Decision: Use SQLite\") → no match → create new\n2. Item 2: find_similar(\"Learning: WAL network drives\") → no match → create new, link to Decision\n\n**Output:**\n```xml\n<memory-stored items=\"2\" duplicates_merged=\"0\">\n  <stored>\n    <entity name=\"Decision: Use SQLite\" type=\"decision\" action=\"created\">\n      <observations added=\"2\"/>\n      <relations created=\"0\" auto=\"0\"/>\n    </entity>\n    <entity name=\"Learning: WAL network drives\" type=\"learning\" action=\"created\">\n      <observations added=\"1\"/>\n      <relations created=\"1\" auto=\"0\"/>\n    </entity>\n  </stored>\n  <ambiguous/>\n</memory-stored>\n```\n\n## Rules\n\n1. **ALWAYS do two-phase duplicate check** — find_similar AND recall before creating\n2. **ALWAYS use canonical names** — apply naming rules before any operation\n3. **ALWAYS split compound observations** — one fact per string\n4. **ALWAYS connect new entities** — orphans are bad\n5. **NEVER output anything except the XML block** — no commentary\n6. **Be thorough on duplicates** — merging is better than creating duplicates\n7. **Use judgment on semantic matches** — \"Event Sourcing\" and \"Use event sourcing\" are THE SAME concept\n",
        "mnemograph-claude-code/commands/recall.md": "---\ndescription: Query the mnemograph knowledge graph for relevant context\nargument-hint: [query or topic]\n---\n\n# Recall from Knowledge Graph\n\nUse the mnemograph MCP server to retrieve relevant context from the knowledge graph.\n\n## Your Task\n\nThe user wants to recall information. Their query: **$ARGUMENTS**\n\n## Instructions\n\n1. **Determine recall depth** based on the query:\n   - If the query is a quick orientation question (e.g., \"what's in memory?\", \"overview\") → use `depth: shallow`\n   - If the query is task-specific (e.g., \"auth decisions\", \"API patterns\") → use `depth: medium`\n   - If the query needs deep exploration (e.g., \"everything about X\", \"full context\") → use `depth: deep`\n\n2. **Call the mnemograph recall tool** with:\n   - `query`: The user's query (use $ARGUMENTS)\n   - `depth`: As determined above\n   - `format`: \"prose\" for human-readable output\n\n3. **Present the results** clearly:\n   - Summarize the key entities and their relationships\n   - Highlight any decisions or learnings that are relevant\n   - If the query found nothing useful, suggest what topics might exist\n\n## Example Queries\n\n- `/recall auth` → medium depth search for authentication-related knowledge\n- `/recall` → shallow overview of what's in the graph\n- `/recall everything about the API design` → deep exploration\n",
        "mnemograph-claude-code/commands/remember.md": "---\ndescription: Store knowledge in the mnemograph knowledge graph\nargument-hint: [what to remember]\n---\n\n# Remember to Knowledge Graph\n\nStore knowledge using the memory-store agent, which handles deduplication, canonical naming, and automatic relation creation.\n\n## Your Task\n\nThe user wants to remember: **$ARGUMENTS**\n\n## Instructions\n\n1. **Parse the user's input** to identify:\n   - What they want to remember (the content)\n   - Any type hints (decision, pattern, learning, gotcha, question)\n   - Any mentioned relations to existing concepts\n\n2. **Spawn the memory-store agent** with a structured request:\n\n```xml\n<store-request>\n  <item content=\"...\" type_hint=\"...\" related_to=\"...\"/>\n</store-request>\n```\n\n3. **Report the result** to the user:\n   - What was stored (entity names, types)\n   - Any duplicates that were merged\n   - Any ambiguous matches the agent flagged\n\n## Type Detection Hints\n\n| User says... | type_hint |\n|--------------|-----------|\n| \"we decided\", \"chose\", \"decision\" | decision |\n| \"pattern\", \"approach\", \"we use\" | pattern |\n| \"gotcha\", \"learned\", \"turns out\", \"TIL\" | learning |\n| \"question\", \"should we\", \"wondering\" | question |\n| \"project\", \"codebase\", \"repo\" | project |\n| Generic fact | concept |\n\n## Examples\n\n**User:** `/remember we decided to use JWT for auth`\n**Action:** Spawn memory-store with:\n```xml\n<store-request>\n  <item content=\"we decided to use JWT for auth\" type_hint=\"decision\"/>\n</store-request>\n```\n\n**User:** `/remember gotcha: pytest needs python -m prefix`\n**Action:** Spawn memory-store with:\n```xml\n<store-request>\n  <item content=\"pytest needs python -m prefix\" type_hint=\"learning\"/>\n</store-request>\n```\n\n**User:** `/remember the API uses rate limiting, and we chose Redis for the cache`\n**Action:** Spawn memory-store with multiple items:\n```xml\n<store-request>\n  <item content=\"API uses rate limiting\" type_hint=\"pattern\"/>\n  <item content=\"chose Redis for cache\" type_hint=\"decision\" related_to=\"API\"/>\n</store-request>\n```\n",
        "mnemograph-claude-code/commands/visualize-memory-graph.md": "---\ndescription: Visualize the mnemograph knowledge graph in an interactive browser view\n---\n\n# Visualize Memory Graph\n\nOpen an interactive D3.js visualization of the knowledge graph in the browser.\n\n## Your Task\n\nBefore running the visualization, ask the user which memory scope and mode they want using the AskUserQuestion tool.\n\n## Instructions\n\n1. **Ask the user for their preferences** using AskUserQuestion with these questions:\n\n   **Question 1 - Memory Scope:**\n   - Header: \"Scope\"\n   - Question: \"Which memory graph do you want to visualize?\"\n   - Options:\n     - Label: \"Global memory\", Description: \"Your personal knowledge graph stored in ~/.claude/memory (shared across all projects)\"\n     - Label: \"Project memory\", Description: \"Project-specific knowledge graph stored in .claude/memory (local to this codebase)\"\n\n   **Question 2 - Mode:**\n   - Header: \"Mode\"\n   - Question: \"How do you want to view the graph?\"\n   - Options:\n     - Label: \"Live view (Recommended)\", Description: \"Opens in browser with a Refresh button for live updates as you work\"\n     - Label: \"Export only\", Description: \"Save the graph as an HTML file without opening the browser\"\n\n2. **Run the visualization** based on their choices:\n\n   Use the Bash tool to run the `mnemograph graph` command. The mnemograph project is located at `${CLAUDE_PLUGIN_ROOT}/..` (the parent of this plugin directory).\n\n   **Commands by choice combination:**\n\n   | Scope | Mode | Command |\n   |-------|------|---------|\n   | Global | Live | `cd ${CLAUDE_PLUGIN_ROOT}/.. && uv run mnemograph --global graph --watch` |\n   | Global | Export | `cd ${CLAUDE_PLUGIN_ROOT}/.. && uv run mnemograph --global graph --export ~/mnemograph-export.html` |\n   | Project | Live | `cd ${CLAUDE_PLUGIN_ROOT}/.. && uv run mnemograph graph --watch` |\n   | Project | Export | `cd ${CLAUDE_PLUGIN_ROOT}/.. && uv run mnemograph graph --export ./mnemograph-export.html` |\n\n   **Run in background** for live view mode so the user can continue working while the server runs.\n\n3. **Inform the user** about what's happening:\n   - For live view: Tell them the server is running and they can click Refresh in the browser\n   - For export: Tell them where the file was saved\n\n## Notes\n\n- The live view runs a local HTTP server — tell the user to press Ctrl+C or click \"Stop Server\" in the browser when done\n- The visualization shows entities as nodes and relations as edges\n- Node colors represent entity types (concept, decision, pattern, etc.)\n- Edge thickness represents relation weight (stronger connections = thicker lines)\n",
        "mnemograph-claude-code/hooks/hooks.json": "{\n  \"description\": \"Memory hooks for session lifecycle and automatic recall\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/session_start.py\"\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/user_prompt.py\",\n            \"timeout\": 5000\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop_hook.py\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "mnemograph-claude-code/hooks/session_start.py": "#!/usr/bin/env python3\n\"\"\"SessionStart hook for mnemograph.\n\nInjects memory context at the start of a Claude Code session.\nFails silently if mnemograph is unavailable.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sys\nfrom pathlib import Path\n\n# Add lib to path for imports\nsys.path.insert(0, str(Path(__file__).parent.parent / \"lib\"))\n\nfrom mnemograph_client import MnemographClient, detect_project_name\nfrom settings import load_settings\n\n\ndef main():\n    \"\"\"Main hook entry point.\"\"\"\n    # Parse hook input from stdin\n    try:\n        hook_input = json.loads(sys.stdin.read())\n    except json.JSONDecodeError:\n        # No input or invalid JSON - still try to provide context\n        hook_input = {}\n\n    # Get working directory from hook context\n    cwd = hook_input.get(\"cwd\", str(Path.cwd()))\n\n    # Load settings\n    settings = load_settings(cwd)\n\n    # Check if auto context is enabled\n    if not settings.get(\"auto_context_on_start\", True):\n        output_result(None)\n        return\n\n    project_name = detect_project_name(cwd)\n\n    # Initialize client with cwd for proper memory detection\n    client = MnemographClient(session_id=f\"session-{project_name}\", cwd=cwd)\n\n    if not client.available:\n        # Mnemograph not available - exit silently\n        output_result(None)\n        return\n\n    # Get memory context at configured depth\n    depth = settings.get(\"context_depth\", \"shallow\")\n    result = client.recall(\n        depth=depth,\n        query=project_name,\n        format=\"prose\",\n        timeout_seconds=10,\n    )\n\n    if result and result.get(\"content\"):\n        context = format_context(project_name, result[\"content\"])\n        output_result(context)\n    else:\n        output_result(None)\n\n\ndef format_context(project_name: str, content: str) -> str:\n    \"\"\"Format memory context for injection.\"\"\"\n    return f\"\"\"<mnemograph-context project=\"{project_name}\">\n{content}\n</mnemograph-context>\"\"\"\n\n\ndef output_result(context: str | None):\n    \"\"\"Output hook result as JSON.\"\"\"\n    result: dict = {\"continue\": True}\n\n    if context:\n        result[\"additionalContext\"] = context\n\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "mnemograph-claude-code/hooks/stop_hook.py": "#!/usr/bin/env python3\n\"\"\"Stop hook for mnemograph.\n\nOutputs a reminder to save learnings at session end.\nOptionally auto-commits memory changes if configured.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sys\nfrom pathlib import Path\n\n# Add lib to path for imports\nsys.path.insert(0, str(Path(__file__).parent.parent / \"lib\"))\n\nfrom mnemograph_client import MnemographClient, detect_project_name\nfrom settings import load_settings\n\n\ndef main():\n    \"\"\"Main hook entry point.\"\"\"\n    # Parse hook input from stdin\n    try:\n        hook_input = json.loads(sys.stdin.read())\n    except json.JSONDecodeError:\n        hook_input = {}\n\n    # Get context\n    cwd = hook_input.get(\"cwd\", str(Path.cwd()))\n    project_name = detect_project_name(cwd)\n    stop_reason = hook_input.get(\"stopReason\", \"unknown\")\n\n    # Load settings\n    settings = load_settings(cwd)\n\n    # Initialize client with cwd for proper memory detection\n    client = MnemographClient(session_id=f\"session-{project_name}\", cwd=cwd)\n\n    output_parts = []\n\n    # Only show reminder for normal session ends (not errors/interrupts)\n    # and if prompt_to_save is enabled\n    if (stop_reason in (\"end_turn\", \"stop_sequence\", \"unknown\")\n            and client.available\n            and settings.get(\"prompt_to_save\", True)):\n        output_parts.append(format_learning_reminder(project_name))\n\n    # Auto-commit if enabled\n    if settings.get(\"auto_commit\", False) and client.available:\n        committed = client.commit(\n            message=f\"Auto-commit: session end ({project_name})\",\n            timeout_seconds=5,\n        )\n        if committed:\n            output_parts.append(\"\\n[mnemograph: changes auto-committed]\")\n\n    output_result(\"\\n\".join(output_parts) if output_parts else None)\n\n\ndef format_learning_reminder(project_name: str) -> str:\n    \"\"\"Format the learning reminder message.\"\"\"\n    return f\"\"\"---\n**Session ending** - Any learnings worth remembering for {project_name}?\n\nIf you discovered patterns, made decisions, or hit gotchas, use the memory-store agent:\n\n```xml\n<store-request>\n  <item content=\"what you learned\" type_hint=\"learning|decision|pattern\"/>\n</store-request>\n```\n\nOr simply: `/remember <what you learned>`\n---\"\"\"\n\n\ndef output_result(message: str | None):\n    \"\"\"Output hook result as JSON.\"\"\"\n    result: dict = {\"continue\": True}\n\n    if message:\n        result[\"output\"] = message\n\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "mnemograph-claude-code/hooks/user_prompt.py": "#!/usr/bin/env python3\n\"\"\"UserPromptSubmit hook: Detect recall patterns and inject memory.\n\nWhen a user's message suggests they want to recall something from memory,\nthis hook automatically searches mnemograph and injects relevant context.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport re\nimport sys\nfrom pathlib import Path\n\n# Add lib to path for imports\nsys.path.insert(0, str(Path(__file__).parent.parent / \"lib\"))\n\nfrom mnemograph_client import MnemographClient, detect_project_name\nfrom settings import load_settings\n\n# Patterns that suggest user wants to recall something\nRECALL_PATTERNS = [\n    # Explicit memory requests\n    (r\"what did we (decide|discuss|conclude|agree)\", \"decision\"),\n    (r\"(last time|previously|before|earlier) we\", \"temporal\"),\n    (r\"do you remember\", \"memory\"),\n    (r\"remind me (about|of|what)\", \"reminder\"),\n\n    # Implicit recall (assumes shared context)\n    (r\"what do (you|we) know about\", \"knowledge\"),\n    (r\"what('s| is) (the|our) (approach|decision|plan) (for|on|about)\", \"decision\"),\n    (r\"why did we (choose|decide|go with)\", \"rationale\"),\n\n    # Continuity signals\n    (r\"continue (with|on|from|where) we\", \"continuation\"),\n    (r\"back to (the|that|our)\", \"return\"),\n    (r\"as we discussed\", \"reference\"),\n]\n\n# Patterns to EXCLUDE (common false positives)\nEXCLUDE_PATTERNS = [\n    r\"what did we eat\",\n    r\"what did we have for\",\n    r\"do you remember (me|my name|who i am)\",\n    r\"remind me (to|later|tomorrow)\",  # Task reminders, not memory recall\n]\n\n\ndef detect_recall_intent(prompt: str) -> tuple[bool, str, str]:\n    \"\"\"\n    Detect if prompt suggests recall intent.\n\n    Returns: (should_search, query_type, extracted_topic)\n    \"\"\"\n    prompt_lower = prompt.lower().strip()\n\n    # Check exclusions first\n    for pattern in EXCLUDE_PATTERNS:\n        if re.search(pattern, prompt_lower):\n            return False, \"\", \"\"\n\n    # Check recall patterns\n    for pattern, query_type in RECALL_PATTERNS:\n        match = re.search(pattern, prompt_lower)\n        if match:\n            topic = extract_topic(prompt_lower, match.end())\n            if topic:  # Only trigger if we found a meaningful topic\n                return True, query_type, topic\n\n    return False, \"\", \"\"\n\n\ndef extract_topic(prompt: str, start_pos: int) -> str:\n    \"\"\"Extract topic from text after the pattern match.\"\"\"\n    remainder = prompt[start_pos:].strip()\n\n    # Remove common filler words and punctuation\n    stopwords = {\"the\", \"a\", \"an\", \"about\", \"for\", \"on\", \"with\", \"that\", \"this\", \"?\", \"\"}\n    words = [w.strip(\"?.,!\") for w in remainder.split()]\n    words = [w for w in words if w not in stopwords and len(w) > 2]\n\n    # Take first 5 meaningful words as topic\n    return \" \".join(words[:5])\n\n\ndef search_memory(client: MnemographClient, topic: str, query_type: str) -> str | None:\n    \"\"\"Search mnemograph and return formatted context.\"\"\"\n    # Adjust query based on type\n    if query_type == \"decision\":\n        query = f\"decision {topic}\"\n    elif query_type == \"rationale\":\n        query = f\"rationale why {topic}\"\n    else:\n        query = topic\n\n    result = client.recall(\n        depth=\"medium\",\n        query=query,\n        format=\"prose\",\n        timeout_seconds=3,  # Fast timeout for interactive use\n    )\n\n    if not result or not result.get(\"content\"):\n        return None\n\n    content = result[\"content\"].strip()\n    if not content or content == \"No relevant context found.\":\n        return None\n\n    return content\n\n\ndef format_context(topic: str, content: str) -> str:\n    \"\"\"Format memory context for injection.\"\"\"\n    return f\"\"\"<mnemograph-recall query=\"{topic}\">\n{content}\n</mnemograph-recall>\"\"\"\n\n\ndef output_result(context: str | None):\n    \"\"\"Output hook result as JSON.\"\"\"\n    result: dict = {\"continue\": True}\n    if context:\n        result[\"additionalContext\"] = context\n    print(json.dumps(result))\n\n\ndef main():\n    \"\"\"Main hook entry point.\"\"\"\n    try:\n        hook_input = json.loads(sys.stdin.read())\n    except json.JSONDecodeError:\n        hook_input = {}\n\n    prompt = hook_input.get(\"prompt\", \"\")\n    cwd = hook_input.get(\"cwd\", str(Path.cwd()))\n\n    if not prompt:\n        output_result(None)\n        return\n\n    # Load settings and check if recall detection is enabled\n    settings = load_settings(cwd)\n    if not settings.get(\"detect_recall_patterns\", True):\n        output_result(None)\n        return\n\n    # Detect recall intent\n    should_search, query_type, topic = detect_recall_intent(prompt)\n\n    if not should_search:\n        output_result(None)\n        return\n\n    # Initialize client\n    project_name = detect_project_name(cwd)\n    client = MnemographClient(session_id=f\"recall-{project_name}\", cwd=cwd)\n\n    if not client.available:\n        output_result(None)\n        return\n\n    # Search memory and inject context\n    content = search_memory(client, topic, query_type)\n\n    if content:\n        context = format_context(topic, content)\n        output_result(context)\n    else:\n        output_result(None)\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      "plugins": [
        {
          "name": "mnemograph",
          "description": "Persistent memory for Claude Code sessions via mnemograph knowledge graph",
          "version": "0.4.0",
          "author": {
            "name": "tm42"
          },
          "source": "./mnemograph-claude-code",
          "category": "memory",
          "tags": [
            "memory",
            "knowledge-graph",
            "persistence"
          ],
          "categories": [
            "knowledge-graph",
            "memory",
            "persistence"
          ],
          "install_commands": [
            "/plugin marketplace add tm42/mnemograph",
            "/plugin install mnemograph@mnemograph-plugins"
          ]
        }
      ]
    }
  ]
}