{
  "author": {
    "id": "GantisStorm",
    "display_name": "GantisStorm",
    "avatar_url": "https://avatars.githubusercontent.com/u/246917469?u=12d956231e04a0d20a33d7cc07333e13628a5e91&v=4"
  },
  "marketplaces": [
    {
      "name": "essentials-claude-code",
      "version": "3.42.0",
      "description": "Loops and swarms powered by Claude Code's built-in Task System. Both are interchangeable—swarm is just faster when tasks can run in parallel. Plans define exit criteria. Executors run until tests pass. Done means actually done.",
      "repo_full_name": "GantisStorm/essentials-claude-code",
      "repo_url": "https://github.com/GantisStorm/essentials-claude-code",
      "repo_description": "Loops and swarms on Claude Code's Task System. Both enforce exit criteria—swarm is faster with parallel queue execution.   Plans define what \"done\" means. Optional: Beads for persistent memory, Ralph TUI for dashboard.",
      "signals": {
        "stars": 61,
        "forks": 6,
        "pushed_at": "2026-01-28T09:23:07Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"essentials-claude-code\",\n  \"version\": \"3.42.0\",\n  \"description\": \"Loops and swarms powered by Claude Code's built-in Task System. Both are interchangeable—swarm is just faster when tasks can run in parallel. Plans define exit criteria. Executors run until tests pass. Done means actually done.\",\n  \"author\": \"GantisStorm\",\n  \"owner\": {\n    \"name\": \"GantisStorm\"\n  },\n  \"homepage\": \"https://github.com/GantisStorm/essentials-claude-code\",\n  \"plugins\": [\n    {\n      \"name\": \"essentials\",\n      \"version\": \"3.42.0\",\n      \"description\": \"22 commands, 9 agents. Loops and swarms powered by Claude Code's built-in Task System. Native task dependencies, ctrl+t progress, automatic persistence.\",\n      \"source\": \"./essentials\"\n    }\n  ]\n}\n",
        "README.md": "<div align=\"center\">\n\n<img src=\"logo.png\" alt=\"Essentials for Claude Code\" width=\"450\"/>\n\n# Essentials for Claude Code\n\n[![Unlicense](https://img.shields.io/badge/license-Unlicense-blue.svg)](https://unlicense.org/)\n[![Claude Code](https://img.shields.io/badge/Built%20for-Claude%20Code-blueviolet)](https://claude.ai/code)\n[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](http://makeapullrequest.com)\n\n**Loops and swarms powered by Claude Code's built-in Task System.**\n\nLoop and swarm are interchangeable — swarm is just faster when tasks can run in parallel. Both enforce exit criteria, use Claude's native task dependencies, `ctrl+t` progress, and automatic persistence.\n\nPlans define exit criteria. Loops run until tests pass. Done means actually done.\n\n</div>\n\n---\n\n## The Problem\n\n```\nYou: \"Add authentication\"\nAI:  *writes code* \"Done!\"\nYou: *runs tests* — 3 failing\nYou: \"Fix these\"\nAI:  \"Fixed!\"\nYou: *runs tests* — still failing\n     [repeat until you give up]\n```\n\n## The Solution\n\n```\n# Option A: Discuss in chat, then execute from context\nYou: \"I need to fix this auth bug...\" [back and forth discussion]\nYou: /implement-loop fix the auth bug we discussed\nAI:  *implements, tests fail, fixes, tests fail, fixes...*\nAI:  \"Exit criteria passed\" ✓\n\n# Option B: Create plan first, then execute\nYou: /plan-creator Add authentication\nYou: /plan-loop .claude/plans/auth-plan.md\nAI:  \"Exit criteria passed\" ✓\n```\n\n---\n\n## Quick Start\n\n```bash\n# Install\n/plugin marketplace add GantisStorm/essentials-claude-code\n/plugin install essentials@essentials-claude-code\nmkdir -p .claude/plans .claude/maps .claude/prompts .claude/prd\n\n# Generate a codemap first (recommended — gives plan creators grounded codebase knowledge)\n/codemap-creator src/\n\n# Option A: From conversation (after discussing a bug/feature)\n/implement-loop fix the auth bug we discussed    # Sequential\n/implement-swarm refactor the API handlers       # Parallel\n\n# Option B: With plan file (auto-uses codemap if present)\n/plan-creator Add user authentication with JWT\n/plan-loop .claude/plans/user-auth-3k7f2-plan.md   # Sequential\n/plan-swarm .claude/plans/user-auth-3k7f2-plan.md  # Parallel\n\n# Visual progress\nctrl+t   # Toggle task tree view\n```\n\n**Zero external dependencies.** Both loop and swarm enforce exit criteria. Swarm defaults to 3 concurrent workers.\n\n---\n\n## Powered by Claude Code's Task System\n\nOur loop and swarm commands use Claude Code's **built-in Task Management System** (v2.1.19+).\n\n> **Ralph TUI and Beads integrate seamlessly.** Use [Ralph TUI](https://github.com/subsy/ralph-tui) for dashboard visualization. Use [Beads](https://github.com/steveyegge/beads) for persistent task tracking across sessions.\n\n### What We Used Before\n\nThe community built Ralph Wiggum loops with workarounds:\n\n- **Stop hooks**: Shell scripts (`.sh` files) that ran after each Claude response, grepping output for keywords like \"complete\" or \"done\" to decide whether to continue the loop\n- **External plan files**: Markdown files tracking task state since Claude had no built-in persistence\n- **TodoWrite**: Flat task lists with no dependency ordering — tasks could run out of order\n- **Fresh sessions**: Starting new conversations to fight context rot, manually re-establishing state each time\n\n### What We Use Now\n\nClaude Code v2.1.19+ provides native tools that replace all of this:\n\n| Old Workaround | Native Replacement | Why It's Better |\n|----------------|-------------------|-----------------|\n| Stop hooks (shell scripts) | `TaskUpdate({ status: \"completed\" })` | No external scripts, status is structured data |\n| External plan.md for state | `~/.claude/tasks/` storage | Survives context compaction automatically |\n| TodoWrite flat lists | `TaskUpdate({ addBlockedBy: [...] })` | Dependencies enforced — tasks can't run out of order |\n| Manual session coordination | `CLAUDE_CODE_TASK_LIST_ID` env var | Same task list across sessions |\n| Single agent | `TaskList` + parallel workers | Multiple agents coordinate via shared state |\n\n**The core loop is unchanged:** Plan → Implement → Verify → Loop if fail → Done when pass.\n\n### What Tasks Do Well\n\n- **Dependency management**: Task #3 blocked by #1 and #2 literally cannot start until both complete\n- **Visual progress**: Press `ctrl+t` to see live task tree with status\n- **Parallel coordination**: Multiple workers share one task list, no conflicts\n- **Persistence**: Survives context compaction, stored in `~/.claude/tasks/`\n\n### What Tasks Don't Do\n\n`TaskList` shows ID, subject, status, and blockedBy — **but NOT description**. To see implementation details, you must call `TaskGet` for each task individually.\n\n**This is why we still use plan files.** Tasks track status. Plans hold implementation details.\n\n```\nPlan file (.claude/plans/)     →  Full implementation code (50-200+ lines per task)\nTask System (~/.claude/tasks/) →  Status tracking, dependencies, parallel coordination\n```\n\n### The Four Core Tools\n\n| Tool | Purpose |\n|------|---------|\n| `TaskCreate` | Create task with subject, description, activeForm |\n| `TaskUpdate` | Change status, set owner, add `blockedBy` dependencies |\n| `TaskGet` | Get full details of ONE task (including description) |\n| `TaskList` | See ALL tasks (but only subject, status, blockedBy) |\n\n### How Dependencies Work\n\nDependencies flow through the entire pipeline:\n\n```\nPlan Creator                    Converter                      Executor\n┌──────────────┐    ┌─────────────────────────┐    ┌──────────────────────┐\n│ Dependency   │ →  │ dependsOn (prd.json)    │ →  │ addBlockedBy (task   │\n│ Graph        │    │ depends_on (beads)      │    │ primitive)           │\n│              │    │                         │    │                      │\n│ Phase 1: A,B │    │ US-003: [\"US-001\",\"002\"]│    │ taskId \"3\":          │\n│ Phase 2: C   │    │                         │    │  blockedBy: [\"1\",\"2\"]│\n└──────────────┘    └─────────────────────────┘    └──────────────────────┘\n```\n\nPlan creators write a `## Dependency Graph` table. Converters read it to build `dependsOn` (prd.json) or `depends_on` (beads). Loop/swarm commands translate those to `addBlockedBy` using an ID map.\n\n**Task lifecycle**: `pending` → (blocked until deps complete) → `in_progress` → `completed`\n\nA task with non-empty `blockedBy` shows as **blocked** in `ctrl+t`. When a blocking task is marked `completed`, it's automatically removed from the blocked list. A task becomes **ready** (executable) when its `blockedBy` list is empty.\n\n```\nTaskCreate({ subject: \"Set up database\" })           // → task \"1\"\nTaskCreate({ subject: \"Create auth middleware\" })     // → task \"2\"\nTaskUpdate({ taskId: \"2\", addBlockedBy: [\"1\"] })      // #2 waits for #1\n```\n\nTask #2 **cannot start** until #1 completes. The system enforces this.\n\n### Visual Progress (`ctrl+t`)\n\n```\nTasks (2 done, 1 in progress, 3 open)\n✓ #1 Set up database schema\n■ #2 Create auth middleware (Worker-1)\n□ #3 Add login routes > blocked by #2\n□ #4 Write tests > blocked by #3\n```\n\n### Queue-Based Swarm Coordination\n\nMain agent controls a queue of background agents:\n\n```\nMain:    Mark #1-3 in_progress → Spawn Agent-1, Agent-2, Agent-3\n         ↓\nMain:    Stop and wait — background agents notify on completion\n         ↓\nAgent-1: Completes Task #1 → notifies main → exits\n         ↓\nMain:    Woken → Mark #1 completed → TaskList → #4 unblocked → Mark #4 in_progress → Spawn Agent-4\n         ↓\nMain:    Stop and wait — next notification\n         ... repeat until all tasks complete ...\n```\n\nEach agent does ONE task then exits. No racing. No stuck loops.\nMain agent marks tasks in_progress on spawn, completed on return, and refills queue as slots open.\n\n### Multi-Session Persistence\n\nTasks persist across sessions with `CLAUDE_CODE_TASK_LIST_ID`:\n\n```bash\n# Per terminal session\nCLAUDE_CODE_TASK_LIST_ID=\"my-project\" claude\n\n# Or in .claude/settings.json\n{ \"env\": { \"CLAUDE_CODE_TASK_LIST_ID\": \"my-project\" } }\n```\n\nStart a new session tomorrow — your task list is still there.\n\n---\n\n## Workflows\n\n| Workflow | Best For | Converter | Loop | Swarm |\n|----------|----------|-----------|------|-------|\n| **Simple** | 80% of tasks | — | `/implement-loop`, `/plan-loop` | `/implement-swarm`, `/plan-swarm` |\n| **Tasks** | prd.json format | `/tasks-converter` | `/tasks-loop` | `/tasks-swarm` |\n| **Beads** | Persistent memory | `/beads-converter` | `/beads-loop` | `/beads-swarm` |\n\n**Converters** transform plans into executable formats. `/tasks-converter` creates prd.json files with `dependsOn` arrays. `/beads-converter` creates beads with epic→task hierarchy and `depends_on` via `bd dep add`. Both read the plan's `## Dependency Graph` table to build dependencies that maximize parallel execution.\n\n**All use Claude Code's built-in Task System** for dependencies, `ctrl+t` progress, and persistence.\n\n**Alternative executor:** [Ralph TUI](https://github.com/subsy/ralph-tui) runs Tasks/Beads with the classic Ralph Wiggum loop style (community approach before Claude Code had native tasks).\n\n### Loop vs Swarm\n\n| Aspect | Loop | Swarm |\n|--------|------|-------|\n| **Executor** | Main agent (foreground) | Background agents |\n| **Concurrency** | 1 task at a time | Up to N tasks (`--workers`) |\n| **Context** | Full conversation history | Each agent gets task description only |\n| **Visibility** | See work live | Check with `ctrl+t` or TaskList |\n| **Task system** | Same | Same |\n| **Dependencies** | Same | Same |\n\n**Both use the same task graph with dependencies.** Only difference is who executes and how many at once. Swarm is faster when tasks can run in parallel. Dependencies determine parallelism — tasks in the same dependency phase run simultaneously, later phases wait.\n\n### Simple (Start Here)\n\n```bash\n# From conversation context (after discussing)\n/implement-loop fix the auth bug       # Sequential\n/implement-swarm refactor API handlers  # Parallel\n\n# Or with plan file\n/plan-creator Add JWT authentication\n/plan-loop .claude/plans/jwt-auth-plan.md    # Sequential\n/plan-swarm .claude/plans/jwt-auth-plan.md   # Parallel\n```\n\n### Tasks (prd.json Format)\n\n```bash\n/plan-creator Add JWT authentication\n/tasks-converter .claude/plans/jwt-auth-plan.md\n\n# Execute with Claude Code's Task System (recommended)\n/tasks-loop .claude/prd/jwt-auth.json             # Sequential\n/tasks-swarm .claude/prd/jwt-auth.json            # Parallel\n\n# Or execute with Ralph TUI (classic Ralph loop)\nralph-tui run --prd .claude/prd/jwt-auth.json\n```\n\n### Beads (Persistent Memory)\n\n```bash\nbd init\n/plan-creator Add JWT authentication\n/beads-converter .claude/plans/jwt-auth-plan.md\n\n# Execute with Claude Code's Task System (recommended)\n/beads-loop                                        # Sequential\n/beads-swarm                                       # Parallel\n\n# Or execute with Ralph TUI (classic Ralph loop)\nralph-tui run --tracker beads --epic <epic-id>\n```\n\n---\n\n## How Loops Work\n\n```\n                    ┌─────────────────┐\n                    │  Read Source    │\n                    │ (plan/context)  │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │  Create Tasks   │\n                    │  + Dependencies │\n                    │ (from Dep Graph)│\n                    └────────┬────────┘\n                             │\n        ┌────────────────────┴────────────────────┐\n        │              MAIN AGENT                 │\n        │                                         │\n        │   ┌─────────────────┐                   │\n        │   │    TaskList     │◄──────┐           │\n        │   │ (find unblocked)│       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Mark task      │       │           │\n        │   │  in_progress    │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │   Implement     │       │           │\n        │   │   (read, edit)  │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Mark task      │       │           │\n        │   │   completed     │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │      ┌─────┴─────┐          │           │\n        │      │           │          │           │\n        │  More tasks   All done      │           │\n        │      │           │          │           │\n        │      └───────────┼──────────┘           │\n        │                  │                      │\n        └──────────────────┼──────────────────────┘\n                           │\n                           ▼\n                    ┌─────────────────┐\n                    │  Run Exit       │\n                    │  Criteria       │\n                    └────────┬────────┘\n                             │\n                       ┌─────┴─────┐\n                       │           │\n                     FAIL        PASS\n                       │           │\n                       │           ▼\n                       │    ┌─────────────────┐\n                       │    │ Loop complete ✓ │\n                       │    └─────────────────┘\n                       │\n                       ▼\n                ┌─────────────────┐\n                │   Fix issues    │\n                │   (loop back)   │\n                └─────────────────┘\n```\n\n**Sequential execution.** Main agent works through tasks one at a time in dependency order. Blocked tasks wait until their dependencies complete. Exit criteria verified at end. Loops until all tests pass.\n\n---\n\n## How Swarms Work\n\n```\n                    ┌─────────────────┐\n                    │  Read Source    │\n                    │ (plan/context)  │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │  Create Tasks   │\n                    │  + Dependencies │\n                    │ (from Dep Graph)│\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │  Spawn up to N  │\n                    │ background agents│\n                    │ (ready tasks)   │\n                    └────────┬────────┘\n                             │\n         ┌───────────────────┼───────────────────┐\n         │                   │                   │\n         ▼                   ▼                   ▼\n  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n  │  Agent 1    │     │  Agent 2    │     │  Agent N    │\n  │─────────────│     │─────────────│     │─────────────│\n  │ implement   │     │ implement   │     │ implement   │\n  │ EXIT        │     │ EXIT        │     │ EXIT        │\n  └──────┬──────┘     └──────┬──────┘     └──────┬──────┘\n         │                   │                   │\n         └───────────────────┼───────────────────┘\n                             │\n        ┌────────────────────┴────────────────────┐\n        │              MAIN AGENT                 │\n        │                                         │\n        │   ┌─────────────────┐                   │\n        │   │  Stop & wait    │◄──────┐           │\n        │   │  (notification) │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Agent done     │       │           │\n        │   │  Mark completed │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Find ready     │       │           │\n        │   │ (pending+empty  │       │           │\n        │   │  blockedBy)     │       │           │\n        │   │  Mark in_progress│      │           │\n        │   │  Spawn workers  │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │      ┌─────┴─────┐          │           │\n        │      │           │          │           │\n        │  More tasks   All done      │           │\n        │      │           │          │           │\n        │      └───────────┼──────────┘           │\n        │                  │                      │\n        └──────────────────┼──────────────────────┘\n                           │\n                           ▼\n                    ┌─────────────────┐\n                    │ Swarm complete ✓│\n                    └─────────────────┘\n```\n\n**Queue-based parallel execution (default: 3 workers).** Main agent marks tasks in_progress and spawns up to N background agents. Each agent does ONE task then exits. On completion notification, main agent marks the task completed, checks TaskList for newly unblocked tasks (status=`pending`, empty `blockedBy`), marks them in_progress, and spawns workers. Dependencies enforced — blocked tasks wait until all their blockers complete.\n\n---\n\n## Commands\n\n### Plan Creators\n\n| Command | Use For |\n|---------|---------|\n| `/plan-creator <feature>` | New features (brownfield development) |\n| `/bug-plan-creator <error> <desc>` | Bug fixes, root cause analysis |\n| `/code-quality-plan-creator <files>` | Refactoring, dead code, security |\n\nAll three produce plans with the same structure: per-file implementation details, `## Dependency Graph` table, and exit criteria. Any plan can be fed to any converter or executed directly via `/plan-loop` or `/plan-swarm`.\n\n### Execute Loops (Sequential)\n\n| Command | Source |\n|---------|--------|\n| `/implement-loop <task>` | Conversation context |\n| `/plan-loop <plan>` | Plan file (required) |\n| `/tasks-loop [prd.json]` | prd.json |\n| `/beads-loop [--label]` | Beads DB |\n\nCancel any loop: `/cancel-loop`\n\n### Execute Swarms (Parallel)\n\n| Command | Source |\n|---------|--------|\n| `/implement-swarm <task>` | Conversation context |\n| `/plan-swarm <plan>` | Plan file (required) |\n| `/tasks-swarm [prd.json]` | prd.json |\n| `/beads-swarm [--epic]` | Beads DB |\n\nCancel any swarm: `/cancel-swarm`\n\n### Convert Formats\n\n| Command | Output | Dependency Source |\n|---------|--------|-------------------|\n| `/tasks-converter <plan>` | prd.json with `dependsOn` arrays | Plan's `## Dependency Graph` table |\n| `/beads-converter <plan>` | Beads issues with `bd dep add` | Plan's `## Dependency Graph` table |\n\nConverters read the plan's `## Dependency Graph` to build file→task/bead ID maps and translate file dependencies to task dependencies. Falls back to per-file `Dependencies`/`Provides` for older plans without a Dependency Graph.\n\n### Schema References\n\n| Command | Purpose |\n|---------|---------|\n| `/plan-schema [validate <path>]` | Plan file format — sections, per-file format, dependency graph rules |\n| `/prd-schema [validate <path>]` | prd.json schema — required fields, rejected fields, examples |\n| `/beads-schema [validate]` | Beads CLI — issue types, statuses, priorities, commands |\n\nInvoke without arguments for a quick reference. Invoke with `validate` to check an existing file against the schema.\n\n### Utilities\n\n| Command | Purpose |\n|---------|---------|\n| `/codemap-creator <dir>` | Create JSON code map via LSP |\n| `/codemap-creator --update <map> [--diff\\|--mr\\|--pr]` | Update existing codemap with changed files |\n| `/document-creator <dir>` | DEVGUIDE.md generation |\n| `/prompt-creator <desc>` | Create prompts, feature requests, bug reports |\n| `/mr-description-creator` | PR/MR descriptions via gh/glab |\n| `/show-status <json\\|beads> [path\\|epic-id]` | Task/bead status dashboard |\n| `/reset-prd <path>` | Reset prd.json to initial state |\n| `/reset-beads <epic-id>` | Reopen all tasks in a beads epic |\n| `/ralph-config <json\\|beads>` | Write RalphTUI config for workflow |\n\n---\n\n## What's In A Plan?\n\nPlans are markdown files in `.claude/plans/` with structured sections:\n\n```markdown\n## Implementation Plan\n\n### src/types/auth.ts [create]\n[Complete code — not pseudocode]\nDependencies: —\nProvides: AuthToken type, validateToken() function\n\n### src/services/auth.ts [create]\n[Complete code]\nDependencies: src/types/auth.ts\nProvides: AuthService class\n\n## Dependency Graph\n\n| Phase | File                    | Action | Depends On              |\n|-------|-------------------------|--------|-------------------------|\n| 1     | `src/types/auth.ts`     | create | —                       |\n| 2     | `src/services/auth.ts`  | create | `src/types/auth.ts`     |\n\n## Exit Criteria\nnpm test -- auth && npm run typecheck\n```\n\n**Self-Contained Rule:** Each task must be implementable with ONLY its description. No \"see design.md\" allowed.\n\n**Dependency Graph Rule:** The `## Dependency Graph` table is the source of truth for execution order. Converters read it to build `dependsOn`/`depends_on`. Files in the same phase can execute in parallel. Only real code dependencies should create phase boundaries.\n\n---\n\n## Code Maps (Recommended)\n\n**Generate a codemap before creating plans.** Code maps give plan creators and sub-agents grounded knowledge of your codebase — file→symbol mappings, function signatures, dependencies, and export status extracted via LSP. Plans built with a codemap are more accurate and produce fewer hallucinations because the agent starts with real symbols and real dependency relationships instead of exploring from scratch.\n\n```bash\n# Create a codemap (do this once, then update incrementally)\n/codemap-creator src/\n\n# Update after changes (instead of recreating from scratch)\n/codemap-creator --update .claude/maps/code-map-src-a3f9e.json --diff      # git diff\n/codemap-creator --update .claude/maps/code-map-src-a3f9e.json --mr 123   # GitLab MR\n/codemap-creator --update .claude/maps/code-map-src-a3f9e.json --pr 456   # GitHub PR\n\n# Then create a plan — it automatically uses the codemap\n/plan-creator Add user authentication with JWT\n```\n\n**All plan creators check for codemaps automatically.** When `.claude/maps/code-map-*.json` exists, plan-creator, bug-plan-creator, and code-quality-plan-creator use it for faster codebase orientation. This means sub-agents spawned by swarm commands also benefit — the plan they receive was built with accurate codebase knowledge, so they write code that fits existing patterns and imports.\n\n**Best practice:** Create a codemap once per project, then use `--update` with `--diff`, `--mr`, or `--pr` to keep it current as code changes. The upfront cost pays for itself across every plan and every sub-agent that executes from those plans.\n\n---\n\n## Project Structure\n\n```\nyour-project/\n├── .claude/\n│   ├── plans/          # Source of truth (plan files with Dependency Graphs)\n│   ├── prd/            # prd.json files (from /tasks-converter)\n│   ├── maps/           # Code maps (consumed by plan creators)\n│   └── prompts/        # Generated prompts\n├── .ralph-tui/         # RalphTUI config (if using)\n│   └── config.toml     # Tracker, agent settings\n└── .beads/             # Beads DB (if using)\n```\n\n**RalphTUI setup:** Run `ralph-tui setup` per project. See [Managing .ralph-tui/](WORKFLOW-TASKS.md#managing-ralph-tui-folder) for config details and switching trackers.\n\n---\n\n## Requirements\n\n| Tool | Required? | Purpose |\n|------|-----------|---------|\n| None | — | Simple workflow works out of the box |\n| [Beads CLI](https://github.com/steveyegge/beads) | For Beads workflow | Persistent memory across sessions |\n| [Ralph TUI](https://github.com/subsy/ralph-tui) | Optional | Classic Ralph loop executor with TUI dashboard |\n\n**Simple workflow has zero dependencies.** Add Beads for persistent memory. Add Ralph TUI if you prefer the classic Ralph Wiggum loop style over Claude Code's native Task System.\n\n---\n\n## Model Configuration\n\nEdit YAML frontmatter in `essentials/commands/*.md` or `essentials/agents/*.md`:\n\n```yaml\n---\nmodel: opus    # opus | sonnet | haiku\n---\n```\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Loop won't stop | Exit criteria must return exit code 0 |\n| Wrong exit criteria | Edit plan directly, re-run loop |\n| Context filling up | Plans persist outside conversation |\n| prd.json not found | Use `userStories` and `passes` fields |\n| Beads CLI missing | `brew tap steveyegge/beads && brew install bd` |\n| Swarm runs sequentially | Check plan's Dependency Graph — every task chained to previous degrades swarm to sequential. Only declare real code dependencies. |\n\n---\n\n## Documentation\n\n- [WORKFLOW-SIMPLE.md](WORKFLOW-SIMPLE.md) — Default workflow, zero dependencies\n- [WORKFLOW-TASKS.md](WORKFLOW-TASKS.md) — Dashboard visualization with Ralph TUI\n- [WORKFLOW-BEADS.md](WORKFLOW-BEADS.md) — Persistent task tracking with Beads\n- [COMPARISON.md](COMPARISON.md) — Why verification-driven loops matter\n\n---\n\n## Contributing\n\n1. Fork it\n2. Create your branch (`git checkout -b feature/thing`)\n3. Commit changes\n4. Push and open a PR\n\n---\n\n## Credits\n\n- [Ralph Wiggum pattern](https://ghuntley.com/ralph/) by Geoffrey Huntley\n- [Beads](https://github.com/steveyegge/beads) by Steve Yegge — Persistent memory\n- [Ralph TUI](https://github.com/subsy/ralph-tui) by subsy — Classic Ralph loop executor\n- Built for [Claude Code](https://claude.ai/code)\n\n---\n\n<div align=\"center\">\n\n*Plans define exit criteria. Loops run until tests pass. Done means actually done.*\n\n</div>\n"
      },
      "plugins": [
        {
          "name": "essentials",
          "version": "3.42.0",
          "description": "22 commands, 9 agents. Loops and swarms powered by Claude Code's built-in Task System. Native task dependencies, ctrl+t progress, automatic persistence.",
          "source": "./essentials",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/essentials-claude-code",
            "/plugin install essentials@essentials-claude-code"
          ]
        }
      ]
    }
  ]
}