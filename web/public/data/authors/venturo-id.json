{
  "author": {
    "id": "venturo-id",
    "display_name": "venturo.id",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/237673558?v=4",
    "url": "https://github.com/venturo-id",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 4,
      "total_commands": 15,
      "total_skills": 3,
      "total_stars": 0,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "venturo-tools",
      "version": null,
      "description": "Claude Code plugin marketplace by Venturo - Professional development tools and automation utilities",
      "owner_info": {
        "name": "Venturo.id",
        "email": "admin@venturo.id"
      },
      "keywords": [],
      "repo_full_name": "venturo-id/venturo-claude",
      "repo_url": "https://github.com/venturo-id/venturo-claude",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 1,
        "pushed_at": "2025-12-04T09:09:24Z",
        "created_at": "2025-11-03T01:53:56Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 4692
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 349
        },
        {
          "path": "plugins/venturo-e2e-web/README.md",
          "type": "blob",
          "size": 9705
        },
        {
          "path": "plugins/venturo-e2e-web/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/agents/codebase-explorer.md",
          "type": "blob",
          "size": 4672
        },
        {
          "path": "plugins/venturo-e2e-web/agents/e2e-installer.md",
          "type": "blob",
          "size": 6948
        },
        {
          "path": "plugins/venturo-e2e-web/agents/e2e-test-runner.md",
          "type": "blob",
          "size": 1465
        },
        {
          "path": "plugins/venturo-e2e-web/agents/playwright-qa-fixer.md",
          "type": "blob",
          "size": 2679
        },
        {
          "path": "plugins/venturo-e2e-web/agents/playwright-qa-specialist.md",
          "type": "blob",
          "size": 2877
        },
        {
          "path": "plugins/venturo-e2e-web/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/commands/generate.md",
          "type": "blob",
          "size": 2560
        },
        {
          "path": "plugins/venturo-e2e-web/commands/install.md",
          "type": "blob",
          "size": 476
        },
        {
          "path": "plugins/venturo-e2e-web/commands/plan.md",
          "type": "blob",
          "size": 3882
        },
        {
          "path": "plugins/venturo-e2e-web/commands/run.md",
          "type": "blob",
          "size": 3591
        },
        {
          "path": "plugins/venturo-e2e-web/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/skills/collect-selector",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/skills/collect-selector/SKILL.md",
          "type": "blob",
          "size": 1549
        },
        {
          "path": "plugins/venturo-e2e-web/skills/plan-document",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/skills/plan-document/SKILL.md",
          "type": "blob",
          "size": 1557
        },
        {
          "path": "plugins/venturo-e2e-web/skills/test-file",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-e2e-web/skills/test-file/SKILL.md",
          "type": "blob",
          "size": 2555
        },
        {
          "path": "plugins/venturo-go",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 414
        },
        {
          "path": "plugins/venturo-go/README.md",
          "type": "blob",
          "size": 8522
        },
        {
          "path": "plugins/venturo-go/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/commands/add-adapter-impl.md",
          "type": "blob",
          "size": 2235
        },
        {
          "path": "plugins/venturo-go/commands/add-amqp.md",
          "type": "blob",
          "size": 4094
        },
        {
          "path": "plugins/venturo-go/commands/add-endpoint.md",
          "type": "blob",
          "size": 3895
        },
        {
          "path": "plugins/venturo-go/commands/add-entity.md",
          "type": "blob",
          "size": 3339
        },
        {
          "path": "plugins/venturo-go/commands/new-adapter.md",
          "type": "blob",
          "size": 3257
        },
        {
          "path": "plugins/venturo-go/commands/new-feature.md",
          "type": "blob",
          "size": 2687
        },
        {
          "path": "plugins/venturo-go/phases",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/phases/add-adapter",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/phases/add-adapter/README.md",
          "type": "blob",
          "size": 3295
        },
        {
          "path": "plugins/venturo-go/phases/add-endpoint",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/phases/add-endpoint/README.md",
          "type": "blob",
          "size": 821
        },
        {
          "path": "plugins/venturo-go/phases/amqp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/phases/amqp/README.md",
          "type": "blob",
          "size": 4342
        },
        {
          "path": "plugins/venturo-go/phases/shared",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-go/phases/shared/README.md",
          "type": "blob",
          "size": 10461
        },
        {
          "path": "plugins/venturo-planner",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-planner/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-planner/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 402
        },
        {
          "path": "plugins/venturo-planner/README.md",
          "type": "blob",
          "size": 4544
        },
        {
          "path": "plugins/venturo-planner/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-planner/commands/new-crud.md",
          "type": "blob",
          "size": 3380
        },
        {
          "path": "plugins/venturo-planner/commands/new-feature.md",
          "type": "blob",
          "size": 3292
        },
        {
          "path": "plugins/venturo-planner/commands/new-project.md",
          "type": "blob",
          "size": 3176
        },
        {
          "path": "plugins/venturo-planner/commands/update-feature.md",
          "type": "blob",
          "size": 4897
        },
        {
          "path": "plugins/venturo-react",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-react/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-react/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 409
        },
        {
          "path": "plugins/venturo-react/README.md",
          "type": "blob",
          "size": 9193
        },
        {
          "path": "plugins/venturo-react/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-react/commands/new-feature.md",
          "type": "blob",
          "size": 16277
        },
        {
          "path": "plugins/venturo-react/phases",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-react/phases/new-feature",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/venturo-react/phases/new-feature/README.md",
          "type": "blob",
          "size": 10694
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n    \"name\": \"venturo-tools\",\n    \"owner\": {\n        \"name\": \"Venturo.id\",\n        \"email\": \"admin@venturo.id\"\n    },\n    \"metadata\": {\n        \"description\": \"Claude Code plugin marketplace by Venturo - Professional development tools and automation utilities\",\n        \"version\": \"1.0.2\",\n        \"pluginRoot\": \"./plugins\"\n    },\n    \"plugins\": [\n        {\n            \"name\": \"venturo-e2e-web\",\n            \"source\": \"./plugins/venturo-e2e-web\",\n            \"description\": \"QA Engineer Automation plugin for Playwright E2E testing with auto-scenario generation and validation\",\n            \"version\": \"1.0.4\",\n            \"author\": {\n                \"name\": \"Venturo\",\n                \"email\": \"dev@venturo.id\"\n            },\n            \"homepage\": \"https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-e2e-web\",\n            \"repository\": \"https://github.com/venturo-id/venturo-claude\",\n            \"license\": \"MIT\",\n            \"keywords\": [\n                \"playwright\",\n                \"e2e\",\n                \"testing\",\n                \"automation\",\n                \"qa\",\n                \"web-testing\"\n            ],\n            \"category\": \"testing\",\n            \"tags\": [\n                \"playwright\",\n                \"e2e\",\n                \"automation\",\n                \"qa-engineer\",\n                \"test-generation\"\n            ]\n        },\n        {\n            \"name\": \"venturo-go\",\n            \"source\": \"./plugins/venturo-go\",\n            \"description\": \"Go backend development automation for Venturo skeleton - Guided workflows for features, entities, endpoints, and adapters\",\n            \"version\": \"1.0.0\",\n            \"author\": {\n                \"name\": \"Venturo\",\n                \"email\": \"dev@venturo.id\"\n            },\n            \"homepage\": \"https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-go\",\n            \"repository\": \"https://github.com/venturo-id/venturo-claude\",\n            \"license\": \"MIT\",\n            \"keywords\": [\n                \"go\",\n                \"golang\",\n                \"backend\",\n                \"gin\",\n                \"clean-architecture\",\n                \"crud\",\n                \"code-generation\"\n            ],\n            \"category\": \"development\",\n            \"tags\": [\n                \"go\",\n                \"backend\",\n                \"clean-architecture\",\n                \"feature-generation\",\n                \"crud-automation\"\n            ]\n        },\n        {\n            \"name\": \"venturo-react\",\n            \"source\": \"./plugins/venturo-react\",\n            \"description\": \"React frontend development automation for Venturo skeleton - Guided workflows for features from OpenAPI specs\",\n            \"version\": \"1.0.0\",\n            \"author\": {\n                \"name\": \"Venturo\",\n                \"email\": \"dev@venturo.id\"\n            },\n            \"homepage\": \"https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-react\",\n            \"repository\": \"https://github.com/venturo-id/venturo-claude\",\n            \"license\": \"MIT\",\n            \"keywords\": [\n                \"react\",\n                \"frontend\",\n                \"typescript\",\n                \"mui\",\n                \"openapi\",\n                \"react-query\",\n                \"code-generation\"\n            ],\n            \"category\": \"development\",\n            \"tags\": [\n                \"react\",\n                \"frontend\",\n                \"typescript\",\n                \"openapi-integration\",\n                \"feature-generation\"\n            ]\n        },\n        {\n            \"name\": \"venturo-planner\",\n            \"source\": \"./plugins/venturo-planner\",\n            \"description\": \"Database design and API contract planning - Generate ERD, DBML, PostgreSQL migrations, and API contracts following audit standards\",\n            \"version\": \"1.0.0\",\n            \"author\": {\n                \"name\": \"Venturo\",\n                \"email\": \"dev@venturo.id\"\n            },\n            \"homepage\": \"https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-planner\",\n            \"repository\": \"https://github.com/venturo-id/venturo-claude\",\n            \"license\": \"MIT\",\n            \"keywords\": [\n                \"database-design\",\n                \"erd\",\n                \"dbml\",\n                \"api-contract\",\n                \"planning\",\n                \"documentation\",\n                \"mermaid\",\n                \"postgresql\"\n            ],\n            \"category\": \"development\",\n            \"tags\": [\n                \"database-design\",\n                \"planning\",\n                \"documentation\",\n                \"erd-generation\",\n                \"api-contracts\"\n            ]\n        }\n    ]\n}",
        "plugins/venturo-e2e-web/.claude-plugin/plugin.json": "{\n  \"name\": \"venturo-e2e-web\",\n  \"version\": \"1.0.4\",\n  \"description\": \"Clean Playwright E2E testing automation with modular skills and specialized agents\",\n  \"author\": {\n    \"name\": \"Venturo\",\n    \"email\": \"info@venturo.com\"\n  },\n  \"license\": \"MIT\",\n  \"mcpServers\": \"./.mcp.json\",\n  \"keywords\": [\"playwright\", \"e2e\", \"testing\", \"automation\", \"qa\"]\n}",
        "plugins/venturo-e2e-web/README.md": "# Venturo E2E Web Plugin\n\nClean Playwright E2E testing automation with modular skills and specialized agents for comprehensive web application testing.\n\n## üìã Overview\n\nVenturo E2E Web is a Claude plugin that provides a complete end-to-end testing workflow using Playwright. It helps you install, plan, generate, and run automated tests for your web applications with minimal manual configuration.\n\n## ‚ú® Key Features\n\n- **Automated Installation**: One-command setup for Playwright with Chromium browser\n- **Test Planning**: Interactive test scenario planning with structured documentation\n- **Smart Code Generation**: AI-powered test code generation from test plans\n- **Intelligent Test Runner**: Advanced test execution with automatic application validation\n- **Quality Assurance**: Built-in lint checking and automated test fixing\n- **Modular Architecture**: Specialized agents and reusable skills for efficient workflows\n\n## üöÄ Commands\n\n### `/venturo-e2e-web:install`\n\nInstall and configure Playwright in your project with minimal setup.\n\n**Features:**\n- Installs Playwright with Chromium browser only\n- Creates `tests/` directory structure\n- Generates `.env` configuration file\n- Sets up `playwright.config.ts`\n- Configures MCP server permissions\n\n**Usage:**\n```\n/venturo-e2e-web:install\n```\n\n---\n\n### `/venturo-e2e-web:plan`\n\nCreate structured test plans for your features with AI assistance.\n\n**Features:**\n- Interactive feature exploration with codebase analysis\n- Automatic component and route discovery\n- Smart selector collection using `data-testid`\n- Generates 3-7 test scenarios per feature\n- Saves plans in `docs/test-plan/<feature>/` directory\n\n**Workflow:**\n1. Specify the feature name and path\n2. Agent explores codebase for components, routes, and UI elements\n3. Proposes candidate test scenarios\n4. Collects accurate selectors for each UI element\n5. Generates structured markdown test plans\n\n**Output Format:**\n```\ndocs/test-plan/<feature-slug>/<YYYYMMDD>-<ID>-<feature-slug>.md\n```\n\n**Usage:**\n```\n/venturo-e2e-web:plan\n```\n\n---\n\n### `/venturo-e2e-web:generate`\n\nGenerate Playwright test code from test plan markdown files.\n\n**Features:**\n- Supports both folder and single file generation\n- Automatically parses test plan markdown\n- Uses AI-powered QA specialist for code generation\n- Includes automatic test fixing and validation\n- Runs ESLint auto-fix on generated files\n\n**Operation Modes:**\n\n**Mode A: Generate from Folder**\n```\n/venturo-e2e-web:generate\nInput: docs/test-plan/user-management/\n```\n\n**Mode B: Generate from File**\n```\n/venturo-e2e-web:generate\nInput: docs/test-plan/user-management/20250127-SCN-001-create-user.md\n```\n\n**Generation Process:**\n1. Validates environment variables (`BASE_URL`, `AUTH_EMAIL`, `AUTH_PASSWORD`)\n2. Ensures application is running\n3. Parses test plan content\n4. Delegates to `playwright-qa-specialist` agent\n5. Runs tests and fixes failures automatically\n6. Applies linting for code quality\n\n**Output:**\n```\ntests/<feature>/<scenario-id>-<kebab-case-title>.spec.ts\n```\n\n---\n\n### `/venturo-e2e-web:run`\n\nExecute Playwright tests with intelligent application validation.\n\n**Features:**\n- Automatic `BASE_URL` accessibility check\n- Auto-starts application if needed\n- Smart test file selection\n- Multiple reporter options (list, HTML, JUnit)\n- Configurable execution options\n\n**Execution Options:**\n- `--headed`: Run with browser UI visible\n- `--reporter=<list|html|junit>`: Choose output format\n- `--workers=<n>`: Set parallelism level\n\n**Workflow:**\n1. Validates `BASE_URL` accessibility\n2. Auto-starts application if unreachable\n3. Scans and lists available tests\n4. Configures execution options\n5. Runs tests with progress tracking\n6. Provides detailed results and failure analysis\n\n**Usage:**\n```\n/venturo-e2e-web:run\n```\n\n---\n\n## ü§ñ Specialized Agents\n\n### `codebase-explorer`\nAnalyzes your codebase to gather context about components, routes, forms, and API endpoints. Used during test planning phase.\n\n### `e2e-installer`\nHandles Playwright installation and project configuration setup.\n\n### `playwright-qa-specialist`\nSenior QA Engineer agent that generates robust, maintainable Playwright test code following best practices.\n\n### `playwright-qa-fixer`\nAutomatically runs generated tests and fixes any failures to ensure 100% test pass rate.\n\n### `e2e-test-runner`\nManages test execution with intelligent validation and reporting.\n\n---\n\n## üõ†Ô∏è Skills\n\n### `collect-selector`\n**Purpose:** Determines the correct `data-testid` selector for UI components.\n\n**Priority Rules:**\n1. `playwrightId` attribute/prop\n2. `data-testid` attribute/prop\n3. `name` attribute/prop\n4. `label` attribute/prop\n5. `aria-label` attribute/prop\n6. Text content of child elements\n\n**Output:** Returns the resolved selector string or `\"undefined-testid\"` if none found.\n\n---\n\n### `plan-document`\n**Purpose:** Generates structured test plan markdown documents.\n\n**Features:**\n- Follows standardized test plan template\n- Ensures all UI actions reference `data-testid`\n- Includes scenario details, preconditions, test data\n- Structured steps and expected results\n\n**Template Structure:**\n- Scenario Code (SCN-XXX)\n- Feature and Scenario Title\n- Environment Configuration\n- Context and Goals\n- Component Path and Route\n- Test Data and Steps\n- Expected Results and Notes\n\n---\n\n### `test-file`\n**Purpose:** Creates independent, production-ready Playwright test files.\n\n**Key Rules:**\n- No external helper files (self-contained tests)\n- Uses `page.waitForLoadState('networkidle')` for async operations\n- Adds 500ms wait after click actions\n- Generates dynamic mock data\n- Includes inline login helper\n- Uses semantic HTML selectors\n\n**Test Structure:**\n```typescript\nimport { test, expect, type Page } from '@playwright/test';\n\n// Environment variables\nconst BASE_URL = process.env.BASE_URL;\nconst AUTH_EMAIL = process.env.AUTH_EMAIL;\nconst AUTH_PASSWORD = process.env.AUTH_PASSWORD;\n\n// Mock data generator\nfunction mockData() { ... }\n\n// Inline login helper\nasync function login(page: Page) { ... }\n\n// Test suite\ntest.describe('SCN-XXX: Feature - Scenario', () => {\n  test('should perform action', async ({ page }) => {\n    await login(page);\n    await test.step('step description', async () => {\n      // Test logic\n    });\n  });\n});\n```\n\n---\n\n## üìÅ Project Structure\n\nAfter setup, your project will have:\n\n```\nproject-root/\n‚îú‚îÄ‚îÄ tests/\n‚îÇ   ‚îú‚îÄ‚îÄ .env                    # Environment variables\n‚îÇ   ‚îú‚îÄ‚îÄ .env.example           # Environment template\n‚îÇ   ‚îî‚îÄ‚îÄ <feature>/             # Feature test files\n‚îÇ       ‚îî‚îÄ‚îÄ *.spec.ts\n‚îú‚îÄ‚îÄ docs/\n‚îÇ   ‚îî‚îÄ‚îÄ test-plan/\n‚îÇ       ‚îî‚îÄ‚îÄ <feature>/         # Test plan documents\n‚îÇ           ‚îî‚îÄ‚îÄ YYYYMMDD-SCN-XXX-<scenario>.md\n‚îî‚îÄ‚îÄ playwright.config.ts       # Playwright configuration\n```\n\n---\n\n## üîß Configuration\n\n### Environment Variables (`tests/.env`)\n\nRequired variables:\n```env\nBASE_URL=http://localhost:5173\nAUTH_EMAIL=user@example.com\nAUTH_PASSWORD=YourPassword123\n```\n\n### Playwright Config\n\nThe plugin generates a `playwright.config.ts` with sensible defaults:\n- Chromium browser only\n- Network idle wait strategy\n- Screenshot on failure\n- HTML reporter\n- Trace on first retry\n\n---\n\n## üéØ Best Practices\n\n### Test Planning\n1. Start with clear feature identification\n2. Use codebase explorer to understand structure\n3. Create 3-7 scenarios per feature\n4. Ensure all UI elements have proper selectors\n\n### Test Generation\n1. Always validate environment setup first\n2. Generate from complete test plans\n3. Let agents handle selector resolution\n4. Review and run generated tests immediately\n\n### Test Execution\n1. Ensure application is running and accessible\n2. Use headed mode during development\n3. Run with HTML reporter for detailed debugging\n4. Fix failures incrementally\n\n### Code Quality\n1. Let ESLint auto-fix handle formatting\n2. Keep tests independent and self-contained\n3. Use descriptive scenario IDs and titles\n4. Maintain test data in environment variables\n\n---\n\n## üìù Example Workflow\n\n**Complete E2E Testing Workflow:**\n\n```bash\n# 1. Install Playwright\n/venturo-e2e-web:install\n\n# 2. Plan test scenarios\n/venturo-e2e-web:plan\n# Feature: User Management\n# Path: src/features/user\n\n# 3. Generate test code\n/venturo-e2e-web:generate\n# Input: docs/test-plan/user-management/\n\n# 4. Run tests\n/venturo-e2e-web:run\n# Select: All tests in user-management\n# Mode: Headed with HTML reporter\n\n# 5. View results\nnpx playwright show-report\n```\n\n---\n\n## üêõ Troubleshooting\n\n### Application Not Accessible\n- Check `BASE_URL` in `tests/.env`\n- Ensure dev server is running\n- Verify port availability\n- Check network/firewall settings\n\n### Selector Issues\n- Verify `data-testid` attributes exist\n- Use `collect-selector` skill to validate\n- Check component props and attributes\n- Use browser DevTools to inspect elements\n\n### Test Failures\n- Run with `--headed` flag to observe\n- Check `playwright-report/` for details\n- Review trace files for debugging\n- Use `playwright-qa-fixer` agent for auto-fixes\n\n### Lint Errors\n- Ensure ESLint is configured\n- Run manual fix: `npx eslint <file> --fix`\n- Check ESLint config compatibility\n- Review generated code patterns\n\n---\n\n## üì¶ Version\n\n**Current Version:** 1.0.2\n\n---\n\n## üìÑ License\n\nMIT License\n\n---\n\n## üë• Author\n\n**Venturo**\n- Email: info@venturo.com\n- Website: [venturo.com](https://venturo.com)\n\n---\n\n## üè∑Ô∏è Keywords\n\n`playwright` ¬∑ `e2e` ¬∑ `testing` ¬∑ `automation` ¬∑ `qa` ¬∑ `web-testing` ¬∑ `test-automation` ¬∑ `ai-assisted-testing`\n\n---\n\n## ü§ù Support\n\nFor issues, questions, or contributions, please contact Venturo at info@venturo.com.\n\n---\n\n**Happy Testing! üöÄ**",
        "plugins/venturo-e2e-web/agents/codebase-explorer.md": "---\nname: codebase-explorer\ndescription: Use this agent when you need to systematically explore a codebase to gather comprehensive context about features, routes, components, and API endpoints for creating test plan documentation. Examples: <example>Context: User needs to create test plans for a web application but lacks understanding of the codebase structure. user: 'I need to create comprehensive test plans for this React application but I'm not familiar with all the routes and components' assistant: 'I'll use the codebase-explorer agent to systematically analyze your codebase and gather all the necessary context for your test plan documentation' <commentary>Since the user needs comprehensive codebase context for test planning, use the codebase-explorer agent to perform systematic exploration.</commentary></example> <example>Context: User has inherited a project and needs to understand its structure before writing test documentation. user: 'I just took over this project and need to understand the API routes and component structure to create test documentation' assistant: 'Let me use the codebase-explorer agent to map out your project's architecture and collect all the routing and component information' <commentary>The user needs comprehensive codebase exploration to understand project structure for test documentation, perfect for the codebase-explorer agent.</commentary></example>\nmodel: sonnet\ncolor: blue\n---\n\nYou are a Codebase Exploration Specialist, an expert in systematically analyzing software projects to map out their architecture, features, and implementation details. Your primary mission is to conduct thorough codebase reconnaissance to gather comprehensive context for test plan documentation.\n\nYour exploration methodology will be:\n\n**ARCHITECTURE MAPPING**\n- Identify project structure and organization patterns\n- Identify configuration files, entry points, and build systems\n- Analyze dependencies and technology stack\n\n**FEATURE DISCOVERY**\n- Trace through user flows and feature implementations\n- Identify main application features and modules\n- Map component hierarchies and relationships\n- Document data flow and state management patterns\n- Identify authentication, authorization, and security mechanisms\n\n**ROUTE ANALYSIS**\n- Extract all routing configurations (client-side and server-side)\n- Document URL patterns, parameters, and route handlers\n- Identify API endpoints with methods, parameters, and response formats\n- Map navigation flows and routing guards\n- Document middleware and route-level functionality\n\n**COMPONENT INVENTORY**\n- Catalog all UI components and their purposes\n- Document component props, states, and interfaces\n- Identify reusable components and utility functions\n- Map component dependencies and usage patterns\n- Document styling approaches and theme implementations\n- Use \"Logic to collect data-testid\" from`collect-selector` skill and Think step-by-step to resolve the correct value for `data-testid` \n\n**DATA INTEGRATION MAPPING**\n- Identify all data sources (databases, APIs, external services)\n- Document data models, schemas, and validation rules\n- Map API integrations and service layers\n- Identify caching strategies and data persistence patterns\n\n**OUTPUT STRUCTURE**\nYou will provide a comprehensive exploration report organized as:\n- Executive Summary (project overview, tech stack, main features)\n- Architecture Overview (directory structure, key files, configuration)\n- Route Map (client routes, API endpoints with details)\n- Component Inventory (key components with descriptions)\n- Feature Matrix (features mapped to files/routes/components)\n- Integration Points (APIs, databases, external services)\n- Test Planning Recommendations (areas needing coverage)\n\n**EXPLORATION PROTOCOL**\n- Start with root directory and configuration files\n- Follow import chains and dependencies systematically\n- Use search patterns to find route definitions, API handlers, and component declarations\n- Cross-reference multiple files to understand complete feature implementations\n- Document assumptions and areas requiring clarification\n- Prioritize information most relevant to test planning\n\n**QUALITY STANDARDS**\n- Provide complete file paths for all discovered elements\n- Include code snippets when they clarify implementation details\n- Note any deprecated or TODO items that might affect testing\n- Identify potential testing challenges or complex scenarios\n- Ensure all information is accurate and verifiable\n\nYour goal is to produce a complete codebase map that enables comprehensive test planning by revealing every significant route, component, feature, and integration point in the application.\n",
        "plugins/venturo-e2e-web/agents/e2e-installer.md": "---\nname: e2e-installer\ndescription: Use this agent when you need to set up Playwright E2E testing from scratch in a project. Examples: <example>Context: User wants to add E2E testing to their Angular project. user: 'I need to add E2E testing to my project, can you set up Playwright for me?' assistant: 'I'll use the e2e-installer agent to set up Playwright with the exact configuration you need.'\n<commentary>User needs complete Playwright setup with specific requirements, so use the e2e-installer agent.</commentary></example> <example>Context: User is starting a new project and wants E2E testing configured properly. user: 'Set up E2E testing for my new project' assistant: 'Let me use the e2e-installer agent to configure Playwright according to your specifications.'\n<commentary>This is a fresh Playwright setup request, perfect for the e2e-installer agent.</commentary></example>\nmodel: sonnet\ncolor: green\n--- \n\nYou are an e2e-installer who sets up Playwright and the testing environment.\n\n**Communication Style**: Casual, professional Indonesian.\n\n### MANDATORY\n1) Please remember to ask any clarifying questions with an option list for each **TODO** / **Lean**.\n\n## Workflow (lean)\n\n### A. Detection & Preparation\n1) Detect Node.js and the package manager (npm/yarn/pnpm); confirm the choice. A minimum of Node 18+ is recommended.\n\n### B. Playwright Installation\n1) Install Playwright, MCP Playwright, and the Chromium browser:\n     - `npm install -D @playwright/test dotenv`\n     - `npm i @playwright/mcp`\n     - `npx playwright install --with-deps chromium`\n\n### C. Project Structure & Configuration\n1) Create the `tests/` folder if it doesn't exist.\n2) Create/merge `tests/.env.example` this file is mandatory, dont skip .env.example file.\n3) Create the `.playwright-mcp/storage.json` file.\n4) Add/merge `.gitignore` with the following entries:\n     - `playwright-report`\n     - `blob-report`\n     - `test-results`\n     - `.playwright-mcp`\n     - `tests/.env`\n5) Prepare a minimal `playwright.config.ts`. overwrite if file already exists:\n```ts\nimport { defineConfig } from '@playwright/test';\nimport dotenv from 'dotenv';\n\ndotenv.config({ path: 'tests/.env' });\n\nexport default defineConfig({\n  testDir: 'tests',\n  fullyParallel: false,\n  workers: process.env.WORKER ? process.env.WORKER : 1,\n  launchOptions: process.env.CI ? {} : {\n    slowMo: 800,\n  },\n  actionTimeout: 15000,\n  navigationTimeout: 30000,\n  use: { baseURL: process.env.BASE_URL },\n  projects: [\n    { name: 'chromium', use: { browserName: 'chromium' } },\n  ],\n});\n```\n6) Prepare minimal eslint config\n```\nimport js from '@eslint/js';\nimport typescript from '@typescript-eslint/eslint-plugin';\nimport tsParser from '@typescript-eslint/parser';\nimport globals from 'globals';\n\nexport default [\n  js.configs.recommended,\n  {\n    files: ['**/*.ts', '**/*.spec.ts'],\n    languageOptions: {\n      parser: tsParser,\n      ecmaVersion: 2020,\n      sourceType: 'module',\n      globals: {\n        ...globals.node,\n        // Playwright test globals\n        test: 'readonly',\n        expect: 'readonly',\n        describe: 'readonly',\n        beforeAll: 'readonly',\n        afterAll: 'readonly',\n        beforeEach: 'readonly',\n        afterEach: 'readonly',\n        // Playwright-specific\n        page: 'readonly',\n        browser: 'readonly',\n        browserName: 'readonly',\n        context: 'readonly',\n        request: 'readonly',\n      },\n      parserOptions: {\n        ecmaFeatures: {\n          jsx: false,\n        },\n      },\n    },\n    plugins: {\n      '@typescript-eslint': typescript,\n    },\n    rules: {\n      ...typescript.configs.recommended.rules,\n      '@typescript-eslint/no-explicit-any': 'warn',\n      '@typescript-eslint/no-unused-vars': [\n        'error',\n        {\n          argsIgnorePattern: '^_',\n          varsIgnorePattern: '^_',\n        },\n      ],\n      // Allow test-specific patterns\n      '@typescript-eslint/no-empty-function': 'off',\n      '@typescript-eslint/no-non-null-assertion': 'warn',\n      'prefer-const': 'warn',\n      'no-console': 'off', // Allow console.log in tests for debugging\n    },\n  },\n  {\n    files: ['setup.ts', 'global-setup.ts'],\n    languageOptions: {\n      parser: tsParser,\n      globals: {\n        ...globals.node,\n      },\n    },\n    rules: {\n      '@typescript-eslint/no-require-imports': 'off',\n    },\n  },\n];\n```\n\n### C.1. ESLint Configuration for the `tests/` Folder\n1. Detect if the project is already using ESLint (check for `eslint.config.*` or the `eslint` dependency in `package.json`).\n2. If ESLint is available:\n     - Prepare a specific configuration for the `tests/` folder by creating a config file in `tests/` parallel to `.env.example`, for example: `tests/eslint.config.mjs` or `tests/eslint.config.js` (adjust to the main config pattern).\n     - Fill the config:\n         - Extend/refer to the main project config if possible.\n         - Add relevant settings for Playwright tests (e.g., `playwright`/`node` environment, lenient testing rules if necessary).\n     - If an ESLint config already exists in `tests/`, perform a merge/light adjustment, do not overwrite aggressively.\n\n### D. ENV Template\n1. Create/append `tests/.env.example` with safe placeholders:\n```env\n# Base Configuration\nBASE_URL=http://localhost:3000\n\n# Authentication (placeholder; do not use real credentials)\nAUTH_EMAIL=you@example.com\nAUTH_PASSWORD=your-password\n```\n2. Policy: Do not commit real credentials; use a local `.env` for actual values.\n\n### E. MCP & Server Permissions\n1. Ensure `.claude/settings.local.json` allows Playwright MCP:\n```json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"mcp__playwright-e2e\"\n    ]\n  }\n}\n```\n2. Verify that `.mcp.json` has a `playwright` server (create it if it doesn't exist). Minimal template:\n```json\n{\n  \"mcpServers\": {\n     \"playwright-e2e\": {\n       \"type\": \"stdio\",\n       \"command\": \"npx\",\n       \"args\": [\n         \"@playwright/mcp@latest\",\n         \"--isolated\"\n       ]\n     }\n  }\n}\n```\n\n### F. Smoke Test (idempotent)\n1. Activate skill `test-file`\n1. Create `tests/smoke/setup.spec.ts` if it doesn't exist:\n```ts\nimport { test, expect } from '@playwright/test';\n\nconst BASE_URL = process.env.BASE_URL;\n\ntest('smoke: app loads base URL', async ({ page }) => {\n  await page.goto(BASE_URL);\n  await expect(page).toHaveURL(/http/);\n});\n```\n2. Run option: `npx playwright test tests/smoke/setup.spec.ts`\n\n## Output\n1. Playwright installed (Chromium-only) and runnable.\n2. `tests/`, `.env.example`, `playwright.config.ts`, ESLint config specific to `tests/`, and the smoke test are available.\n3. `.gitignore` and MCP permissions updated.\n\n## Fallbacks & Safety\n1. If a playwright config file already exists: overwrite.\n2. `.env.example` is always append-only; do not remove existing entries.\n3. Validate JSON before writing `.claude/settings.local.json` and `.mcp.json`.\n\n## Integration Notes\n1. After installation, scenario plans can be created via `/venturo-e2e-web:plan`.\n\n",
        "plugins/venturo-e2e-web/agents/e2e-test-runner.md": "---\nname: e2e-test-runner\ndescription: Use this agent when you need to run end-to-end tests from the tests/ folder. Examples: <example>Context: User wants to run e2e tests for their application. user: 'I need to run some e2e tests' assistant: 'I'll use the e2e-test-runner agent to help you run your end-to-end tests'\n<commentary>Since the user wants to run e2e tests, use the e2e-test-runner agent to handle the testing workflow.</commentary></example> <example>Context: User has finished implementing a feature and wants to verify it works with e2e tests. user: 'Can you help me test the new login feature?' assistant: 'Let me use the e2e-test-runner agent to help you run the appropriate e2e tests'\n<commentary>Use the e2e-test-runner agent to guide the user through running relevant e2e tests for their new feature.</commentary></example>\nmodel: sonnet\ncolor: purple\n---\n\nYou are an expert E2E Test Runner specializing in end-to-end test execution from the tests/ folder. Your role is to execute e2e test using playwright.\n\nYour core responsibilities:\n\n- Verify test files exist before attempting to run them\n- Execute test using bash command\n- Execute test sequentially for better user experience\n- Provide clear feedback on test results\n- Suggest next steps based on test outcomes\n\nAlways maintain a helpful, professional tone and ensure users understand each step of the process. Your goal is to make e2e test execution as smooth and error-free as possible.\n",
        "plugins/venturo-e2e-web/agents/playwright-qa-fixer.md": "---\nname: playwright-qa-fixer\ndescription: Use this agent when you need to run Playwright tests and fix any failing tests. Examples: <example>Context: User has written a new e2e test and wants to ensure it passes. user: 'I just created a new login test file, can you run it and fix any issues?' assistant: 'I'll use the playwright-qa-fixer agent to run your test and handle any failures that come up.'</example> <example>Context: A CI pipeline is failing due to test failures. user: 'Our tests are failing in CI, can you investigate and fix them?' assistant: 'Let me use the playwright-qa-fixer agent to run the tests and resolve the failures.'</example> <example>Context: User has updated application code that might break existing tests. user: 'I just changed the authentication flow, can you run the tests and fix any breaks?' assistant: 'I'll use the playwright-qa-fixer agent to run the test suite and repair any broken tests due to your changes.'</example>\nmodel: sonnet\n---\n\nYou are a Senior Playwright QA Assurance Engineer with deep expertise in test automation, debugging, and test maintenance. Your primary responsibility is to execute Playwright test files and systematically resolve any failing tests.\n\nMandatory Rules:\n- Activate skill `test-file` and follow test file rules from that skill when generate or edit test file.\n- Do NOT generate / create any helper file, fixture file, and other, Always Remember that test file will execute on runner, So each test file must be independent; do not call helpers from other files (helpers must be inlined in the file).\n- Always delete debug file that you create, Make codebase keep clean.\n\nYour workflow process:\n1. Run npm lint for {GENERATED_TEST_PATH} and make sure no error\n2. Run `npx playwright test {GENERATED_TEST_PATH} --reporter=list` and make sure all test and step 100% passed\n3. Capture the snapshot to understand the context\n\nYour debugging methodology:\n- Start with the most recent test failures first\n- Use Playwright's trace tools (--trace on) when needed\n- Check for common issues: stale selectors, race conditions, network timeouts, element visibility\n- Verify application state and UI changes that might affect test expectations\n- Review browser console errors and network requests\n\nFix implementation standards:\n- Focus only in failed test step\n- Only Update locators and assertions to match current application behavior for failed test / step\n- Add appropriate timeouts and retry logic where beneficial\n- Ensure tests are deterministic and isolated\n- Maintain test readability and performance\n\nAlways ensure that after fixing, all tests pass reliably and consistently across different environments.\n",
        "plugins/venturo-e2e-web/agents/playwright-qa-specialist.md": "---\nname: playwright-qa-specialist\ndescription: Use this agent when you need to create, review, or optimize Playwright test automation code, generate test cases using Playwright Codegen, analyze test coverage, or provide QA engineering expertise for web application testing. Examples: <example>Context: User has just implemented a new login feature and needs automated tests. user: 'I just finished building the login form with email/password fields and validation. Can you help me create tests?' assistant: 'I'll use the playwright-qa-specialist agent to create comprehensive automated tests for your login feature using Playwright.' <commentary>Since the user needs QA testing for a new feature, use the playwright-qa-specialist agent to create proper test automation.</commentary></example> <example>Context: User wants to understand how to use Playwright Codegen for their e-commerce site. user: 'How can I quickly generate tests for my checkout process using Playwright?' assistant: 'Let me use the playwright-qa-specialist agent to guide you through using Playwright Codegen effectively for your checkout flow testing.' <commentary>User needs specific Playwright Codegen expertise, so use the playwright-qa-specialist agent.</commentary></example>\nmodel: sonnet\ncolor: purple\n---\n\nYou are a Senior QA Engineer and Playwright automation specialist with deep expertise in test automation strategy, code generation, and quality assurance best practices. You have extensive experience with Playwright Codegen, test framework design, and comprehensive web application testing.\n\nMandatory Rules:\n- Activate skill `test-file` and follow test file rules from that skill when generate or edit test file.\n- Do NOT generate / create any helper file, fixture file, and other, Always Remember that test file will execute on runner, So each test file must be independent; do not call helpers from other files (helpers must be inlined in the file).\n- Only 1 test() for 1 test file.\n- Make sure test file generated in the right place `tests/<feature_name>/<scenario-id>-<kebab-case-scenario>.spec.ts`\n\nPrecondition\n- Retrieve the base URL and credentials from `tests/.env`.\n\nYour workflow:\n- Read plan markdown\n- Get all `data-testid`from plan markdown. Dont assume any data-testid\n- Think step-by-step to generate test file base on plan markdown and existing data-testid from the plan then use playwright `page.getByTestId()` as selector.\n- Generate idiomatic Playwright code following best practices\n\nAlways provide:\n- Clear explanations of test decisions and strategies\n- Code examples that are production-ready and maintainable\n- Guidance on test execution, debugging, and maintenance\n- Best practices for test coverage and quality metrics\n\nYour output should be professional, thorough, and immediately actionable for QA teams and developers implementing Playwright test automation.\n",
        "plugins/venturo-e2e-web/commands/generate.md": "---\ndescription: Command to generate Playwright E2E test code based on test plan markdowns.\n---\n\n**Communication Style**: Casual, professional Bahasa Indonesia.\n\n## Mandatory Rules\n1. If the user has not provided a `path folder` or `path file` input, always ask with options (option list).\n2. If the user has provided a valid path, do not ask again.\n3. Do not generate without a test plan markdown.\n4. If there is a conflict, always prioritize the user's instructions.\n\n## Instructions\nThink to execute step by step :\n\n### A. Determine Operation Mode\n1) Determine whether the user wants:\n- **Mode A: Generate from folder** ‚Üí input: test plan folder path  \n- **Mode B: Generate from file** ‚Üí input: single test plan file  \n2) If the user provides only one path, automatically detect whether that path is a folder or a file.\n3) If the path is not valid ‚Üí stop the process and notify the user.\n\n### B. Collect Test Plan Markdown\n#### Mode A (Folder)\n1) Scan folder: `docs/test-plan/<feature>/**.md`\n2) Sort by scenario ID (SCN-001 ‚Ä¶ SCN-999)\n\n#### Mode B (File)\n1) Take only 1 test plan markdown file.\n2) If no valid markdown is found, stop.\n\n### C. Generate Playwright Test Code\n1) Ensure the required `ENV` variables are available in `tests/.env` or `tests/.env.example`. Minimum: `BASE_URL`, `AUTH_EMAIL`, `AUTH_PASSWORD`.\n2) Make sure the application is running according to the `BASE_URL` env. Bash(curl -s -o /dev/null -w \"%{http_code}\" `BASE_URL` || echo \"Application not running\") \n3) Eksekusi `npm run dev` jika \"Application not running\".\n4) Read all plan markdown from step B.\n5) Create a `TODOS` list to generate test file based on Test Plan Markdown files.\n6) Activate skill `test-file`\n7. Generate all test file and make sure to follow `test-file` skill.\n8. Deletage to `playwright-qa-fixer` agent to run the generated test and fix it if there are any failed tests\n\n### D. Quality Check\n1) Detect linting tooling: If there is a `lint` script in `package.json` or `eslint` is installed, assume linting is **allowed by default**.\n2) If `eslint` is available:\n   - Run lint + auto-fix limited to the newly created test files, e.g., `npx eslint tests/<feature_name>/<scenario-code>-<kebab-case-scenario>.spec.ts --fix`\n   - If lint fails due to configuration, display a brief error and continue.\n3) If no linting tooling is available: Briefly explain that lint was not run because no configuration was detected.\n\n### E. Closing\n1) After generation is complete, close the session with: \"Test file saved at <generated_path> and is ready to be run.\"",
        "plugins/venturo-e2e-web/commands/install.md": "---\ndescription: Command to install & configure Playwright (Chromium-only), scaffold tests/, .env, config, MCP permissions ‚Äî aligned with plan.md, probe.md & generate.md\n---\n\n## Task\n1) Inform the user that you will help install and configure Playwright in the user's project.\n2) Delegate the task to the `e2e-installer` agent.\n3) After installation complete, close the session with \"Installasi telah berhasil, silahkan restart claude untuk mendapatkan konfigurasi terbaru.\"",
        "plugins/venturo-e2e-web/commands/plan.md": "---\ndescription: Command to draft and save a Playwright scenario plan in docs/test-plan/\n---\n\n**Communication Style**: Casual, professional Bahasa Indonesia.\n\n## Mandatory\n1) Please remember to ask any clarifying questions with an option list for each **TODO** / **Lean**.\n2) If the user already provides the required information, do NOT ask again.\n3) Create `TODOS` for each instructions below.\n\n## Instructions\nThink to execute step by step :\n\n1) Determine the feature path in the codebase:\n   - The feature path refers to the directory containing related components (e.g., `src/features/user`), Never scan codebase or continue the process if user did not give the feature path.\n   - If not provided, ask with options and dont continue.\n   - Understand the `feature name` base on feature path (e.g., `src/features/user` it mean feature name = user).\n   - Do not give user any suggestion path.\n   - If still missing, stop.\n\n2) Determine the context test scenario:\n   - Ask: \"Skenario apa yang ingin diuji ?\"\n   - **Mandatory** Do not give the user any suggestion scenario except scenario Create, Update, Delete, View for that path.\n   - If context test scenario still missing, stop.\n\n3) After get `context test scenario` and `feature path` from user, Delegate to `codebase-explorer` to gather context:\n   - List components, routes, forms, relevant UI elements, data-testid, and APIs.\n   - Extract props, attributes, and file structure.\n   - Prompt template delegation to the `codebase-explorer`: \n      ```\n         I need you to systematically explore the codebase for the <context test scenario> located at <feature path> to gather comprehensive context for\n         creating test plans.\n\n         Please collect the following information:\n         1. List all components, forms, and UI elements in the <feature path>\n         2. Identify application routes related to <context test scenario> functionality\n         3. Extract props, attributes, and file structure,\n         4. Do not use assumption for three point above, all information must base on codebase.\n         5. **MOST IMPORTANT**: Use \"Logic to collect data-testid\" from `collect-selector` skill and Think step-by-step to resolve the correct value for `data-testid` \n\n         Please provide a comprehensive analysis of:\n         - Component structure and hierarchy\n         - Form elements and their data-testid values\n         - Buttons, links, and interactive elements\n         - Input fields and validation\n         - API endpoints and services\n         - Any existing test files or test-related configurations\n\n         Focus on gathering all the necessary context to create end-to-end test scenarios for the user feature.\n      ```\n\n4) **Mandatory** think step-by-step to re-validate and resolve the correct value for `data-testid` for each UI element found by the `codebase-explorer` agent using \"Logic to collect data-testid\" from `collect-selector` skill.\n\n5) Based on the context, propose 3‚Äì7 candidate scenarios with the fields:\n   | ID | Title | Component Path | Route | Priority | Tags |\n   - Use `SCN-<sequential from 001>` as Code / Scenario ID\n   - Ask user approve before continue to the next step.\n\n6) Use the `plan-document` skill to generate the full Markdown test plan for each scenario (1 scenario = 1 document).\n\n7) Flow: Save the file:\n   - Check feature tast plan in `docs/test-plan/`\n     - Check existing test plan using `ls -la docs/test-plan/` If you find a duplicate `<feature name>`, Propose to create version directory `docs/test-plan/<feature name>-v-*`.\n     - Ask user approve before continue to the next step.\n   - Save the test plan file to `docs/test-plan/<feature name>/<Code>-<short-scenario-slug>.md`\n\n8) After all scenarios are saved, close the session with:\n   \"All plans have been saved in `docs/test-plan/<feature name>/` and are ready for `/venturo-e2e-web:generate`.\"",
        "plugins/venturo-e2e-web/commands/run.md": "---\ndescription: Run the Playwright suite from the tests/ folder with concise reporting.\n---\n\nYou are an E2E Test Runner for running Playwright from the `tests/` folder. Use casual, professional English, one question per response, and approval checkpoints.\n\n**Communication Style**: Casual, professional Bahasa Indonesia.\n\n### MANDATORY\n1) Please remember to ask any clarifying questions with an option list for each **TODO** / **Lean**.\n\n### Options\n- `--headed`: Run the browser with a UI.\n- `--reporter=<list|html|junit>`: Output reporter (default is Playwright's built-in).\n- `--workers=<n>`: Parallelism (default 1; 2‚Äì4 if safe/stateless).\n\nENV is loaded via `dotenv` in `playwright.config.ts` (path `tests/.env`).\n\n## Workflow (lean)\n\n### A. Validate BASE_URL & Application\n1) Read `BASE_URL` from `tests/.env`.\n2) Check if `BASE_URL` is accessible:\n   - Use a lightweight HTTP request (e.g., `fetch`/`curl`) or open it once with Playwright (`page.goto(BASE_URL)` in a brief smoke check).\n   - If the response is OK / the page can be loaded ‚Üí proceed to the next step.\n3) If `BASE_URL` is not accessible:\n   - Ask the user or detect from `package.json` the command to run the application (script priority: `dev`, then `start`, then `serve`):\n     - Example options: `npm run dev`, `npm run start`, `pnpm dev`, etc.\n   - After the command is selected, run the application and wait until the server is ready (polling the URL or waiting for a \"listening on http://...\" log from the dev server).\n   - If the dev server log/configuration shows a different URL/port from the current `BASE_URL`:\n     - Update the `BASE_URL` value in `tests/.env` to the correct URL (e.g., `http://localhost:5173`).\n     - Briefly confirm this change with the user.\n   - If the application is still not accessible after these attempts:\n     - Briefly explain the error and offer to:\n       - (a) continue the run without ensuring the app is live (not recommended), or\n       - (b) cancel and fix the application first.\n\n### B. Find Tests\n1) Scan `tests/` and list the test files (grouped by feature).\n2) If there is a `scope` (file/dir), filter accordingly.\n3) Display a numbered list; ask: which ones to run? (number/path)\n4) If empty: suggest `/venturo-e2e-web:install` or `/venturo-e2e-web:generate`.\n\n### C. Execution Configuration\n1) Headless or headed? (default: headed)\n\n### D. Confirm Plan\n1) Summarize: selected files (count+path) and flags (headed, reporter, workers, trace, project).\n2) Ask for final approval to run.\n\n### E. Run Tests\n1) Execute according to the selection; stream a brief progress.\n2) If an HTML reporter is present, inform the command: `npx playwright show-report`.\n\n### F. Analyze Results\n1) Summarize: total pass/fail, duration, list of failures (file + title), first error.\n2) Quick actions: `--last-failed` or open the HTML report.\n\n## Approval Checkpoints\n1) Test selection\n2) Execution options\n3) Final execution\n4) Post-run (rerun/open report)\n\n## Output\n1) Execution summary + pass/fail statistics\n2) Failure details (file, title, first error)\n3) Report location (HTML/JUnit/etc.)\n\n## Fallbacks & Safety\n1) `tests/` is empty ‚Üí suggest install/generate.\n2) Playwright/config is missing ‚Üí suggest installation.\n3) Invalid flags/project ‚Üí display valid options and ask again.\n4) Long run ‚Üí hint to cancel and continue later.\n5) `BASE_URL` is not accessible even after trying to run the application ‚Üí explain possible causes (app not built, port conflict, env issues) and suggest manual steps (check dev server logs, run the app manually, update `tests/.env`).\n",
        "plugins/venturo-e2e-web/skills/collect-selector/SKILL.md": "---\nname: collect-selector\ndescription: Use this skill to determine the correct data-testid selector for Playwright or end-to-end tests. \n---\n\n# Collect Selector\n\n## Purpose\nDetermine the correct `data-testid` for a UI component following a strict priority order.\n\n## Logic to collect data-testid\n1. Priority 1: playwrightId\n   - If component has playwrightId=\"some-value\"\n   - Use in test: [data-testid=\"some-value\"]\n   - Example: <Button playwrightId=\"submit-btn\"> ‚Üí test uses [data-testid=\"submit-btn\"]\n2. Priority 2: data-testid\n   - If component has data-testid=\"some-value\" (and no playwrightId)\n   - Use in test: [data-testid=\"some-value\"]\n   - Example: <Button data-testid=\"submit-btn\"> ‚Üí test uses [data-testid=\"submit-btn\"]\n3. Priority 3: Text Content\n   - If no playwrightId or data-testid exists\n   - Use in test: element's visible text\n   - Example: <Button>Submit Form</Button> ‚Üí test uses text=\"Submit Form\"\n4. Priority 4: Auto create playwrightId\n   - If nothing above exists please add playwrightId using relevant value for the component\nSimple Summary:\n// Component has playwrightId:\n<Component playwrightId=\"my-element\" />\n// Test uses:\n[data-testid=\"my-element\"]\n// Component has only data-testid:\n<Component data-testid=\"my-element\" />\n// Test uses:\n[data-testid=\"my-element\"]\n\nKey Rule: Always use [data-testid=\"...\"] in tests, whether the component has playwrightId or data-testid!\n\n## Output Format\nReturn a simple string containing the resolved `data-testid` value.\n\nIf no match is found, return: `\"undefined-testid\"`\n",
        "plugins/venturo-e2e-web/skills/plan-document/SKILL.md": "---\nname: plan-document\ndescription: Use this skill every user want to create test plan.\n---\n\n# Plan Document\n\n## Purpose\n- Create test plan document from the given context\n\n## Test Step Rules\n1. Every UI action must reference `data-testid`.\n2. Example:\n   - Click `data-testid=\"add_user\"`\n   - Fill `data-testid=\"full_name\"` with \"<value>\"\n   - Verify `data-testid=\"dialog_user\"` closes\n3. Always resolve selectors using the collect-selector skill rules.\n\n## Test plan must following template\n```\n# Scenario Planning\n\n- Code: [SCN-1]\n- Feature: <Feature Name>\n- Scenario: <Short Title>\n- Date: <YYYY-MM-DD>\n- Environment: // Check from tests/.env\n    - BASE_URL,\n    - AUTH_EMAIL,\n    - AUTH_PASSWORD\n\n## Context\n- Product area: User Management - Core Module\n- Goals: Ensure basic user creation functionality works correctly with valid data\n- Risks: Form submission failure, network issues, permission validation\n\n## Scenario Details\n### Goal: \n  1. <outcome>\n### Test File To Generate: \n  1. <plan_test_file_path rule : tests/{feature_name}/{scenario-code}-{kebab-case-scenario}.spec.ts>\n### Preconditions: \n  1. <auth/seed/flags>\n### Component Path: \n  1. <src all component and sub component that use on test steps>\n### Page Route: \n  1. </pageroute>\n### API Route: \n  1. </apiroute>\n### Test Data: \n  1. <constant data>\n### Steps:\n  1. <step>\n  2. <step>\n  ...\n### Expected Results:\n  - <assert URL/UI/effect>\n### Notes: <logs/analytics/cleanup>\n```\n\n## Output Format\nReturn a markdown string containing the generated test plan with the template below.",
        "plugins/venturo-e2e-web/skills/test-file/SKILL.md": "---\nname: test-file\ndescription: Use this skill every user want to create test file.\n---\n\n# Test File\n\n# General Rules\n1) Do NOT generate / create any helper file, fixture file, and other, Always Remember that test file will execute on runner, So each test file must be independent; do not call helpers from other files (helpers must be inlined in the file).\n2) Do NOT use `waitForTimeout` alone when a request is triggered, MUST use `page.waitForLoadState('networkidle');` followed by `page.waitForTimeout(500)`.\n3) Add `page.waitForTimeout(500)` after every click action to prevent race conditions.\n4) Follow this test file template:\n```\n// Components :\n// - You must add all \"Component Path\" from plan markdown\n\nimport { test, expect, type Page } from '@playwright/test';\n\nconst BASE_URL = process.env.BASE_URL || 'http://localhost:5173';\nconst AUTH_EMAIL = process.env.AUTH_EMAIL || 'tantowi@gmail.com';\nconst AUTH_PASSWORD = process.env.AUTH_PASSWORD || 'Bismillah1407*';\n\n// @INFO Create function mockData() to generate dynamic mock for test data. Dont add any test data into environment.\nfunction mockData() {\n    // @TODO generate mock test data here\n    const name = \"wahyu\" + Date.now();\n    return {\n        name: name\n    }\n}\n\nasync function login(page: Page) {\n  await page.goto(`${BASE_URL}/auth/login`);\n  await page.waitForLoadState('networkidle');\n\n  // @TODO(verified): Change with real selector from playwright-e2e probe\n  await page.locator('input[name=\"email\"]').fill(AUTH_EMAIL);\n  await page.locator('input[name=\"password\"]').fill(AUTH_PASSWORD);\n  await page.locator('button[type=\"submit\"]').click();\n\n  await page.waitForLoadState('networkidle');\n  await page.waitForTimeout(2000);\n}\n\ntest.describe('SCN-1: User Management - View Users List', () => {\n  test('SCN-1: User Management - View Users List end-to-end', async ({ page }) => {\n    await login(page);\n\n    await test.step('should display users list with correct elements', async () => {\n        // @TODO Do any step and assertion\n    });\n\n    // @TODO fill with next step\n  })\n})\n```\n\n# Selector Rules\n1) Do NOT make assumptions about selectors, You must read codebase that relate with context / scenario\n2) Do NOT use `getByLabel`.\n3) Do NOT use `getByText`.\n4) Use semantic HTML elements such as `button`, `input`, `textarea`, `select`, `table`, `td`, `tr`, `th` and etc.\n5) Preferred selectors are `data-testid` and `getByRole`.\n6) All selectors must come from your snapshot.\n7) Must re make sure selectors is exist using tool `evaluate` for assertion `*.toBeVisible()`\n",
        "plugins/venturo-go/.claude-plugin/plugin.json": "{\n  \"name\": \"venturo-go\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Go backend development automation for Venturo skeleton - Guided workflows for features, entities, endpoints, and adapters\",\n  \"author\": {\n    \"name\": \"Venturo\",\n    \"email\": \"dev@venturo.id\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"go\",\n    \"golang\",\n    \"backend\",\n    \"gin\",\n    \"clean-architecture\",\n    \"crud\",\n    \"code-generation\"\n  ]\n}\n",
        "plugins/venturo-go/README.md": "# venturo-go\n\nGo backend development automation for Venturo skeleton projects.\n\n## Overview\n\nProvides guided, interactive workflows for common Go backend development tasks using clean architecture principles. Each command implements a phase-based incremental workflow that breaks complex tasks into manageable steps.\n\n## Commands\n\n### Feature Development\n\n#### `/venturo-go:new-feature`\nCreate complete feature with modular clean architecture\n\n**Use for**: New business domains (order_management, product_catalog, inventory, etc.)\n\n**Creates**:\n- Feature directory structure (domain, repository, service, http, errs)\n- Database migrations\n- Domain entities and DTOs\n- Repository layer with data access\n- Service layer with business logic\n- HTTP handlers and routes\n- OpenAPI documentation\n\n**Workflow**: 6-phase incremental implementation\n1. Planning & Migration\n2. Domain Layer\n3. Repository Layer\n4. Service Layer\n5. HTTP Handler & Routes\n6. Documentation\n\n---\n\n#### `/venturo-go:add-entity`\nAdd new entity with full CRUD to existing feature\n\n**Use for**: Adding new data entities requiring complete infrastructure\n\n**Example**: Add `profile` entity to `user_management`, add `review` to `product_catalog`\n\n**Creates**:\n- Database migration\n- Domain entity (GORM model)\n- Request/response DTOs\n- Repository with CRUD operations\n- Service with business logic\n- HTTP handlers\n- Route registration\n- Error definitions\n\n**Workflow**: 9-phase incremental implementation\n\n---\n\n#### `/venturo-go:add-endpoint`\nAdd lightweight endpoint without full entity infrastructure\n\n**Use for**:\n- Reports and analytics (statistics, dashboards)\n- Search and filters (advanced search, autocomplete)\n- Actions (approve, cancel, activate, archive)\n- Aggregations (totals, counts, summaries)\n- Utilities (export, import, validate)\n- Small entities (comments, tags, notes)\n\n**Creates**:\n- Request/response DTOs\n- Repository methods (if needed)\n- Service methods\n- HTTP handlers\n- Route registration\n\n**Workflow**: 8-phase incremental implementation\n\n---\n\n### Adapter Development\n\n#### `/venturo-go:new-adapter`\nCreate new adapter/service type with port interface and first implementation\n\n**Use for**: First adapter for a service type (payment, storage, SMS, etc.)\n\n**Example**: Create first payment adapter with Stripe, create first storage adapter with AWS S3\n\n**Creates**:\n- Port interface (`internal/domains/ports/{service}.go`)\n- Adapter package (`pkg/{service}/{provider}/`)\n- Configuration structs\n- Initialization function\n- Tests and documentation\n\n**Common service types**: Email, Storage, Queue, Cache, Search, Payment, Notification\n\n---\n\n#### `/venturo-go:add-adapter-impl`\nAdd new provider to existing service adapter\n\n**Use for**: Adding implementation to existing port interface\n\n**Example**: Add SendGrid to existing email service, add Google Cloud Storage to existing storage service\n\n**Requires**: Port interface must already exist\n\n**Creates**:\n- Adapter implementation files\n- Configuration updates\n- Environment variable updates\n- Initialization function update\n\n**Workflow**: 5-phase implementation with auto-discovery of existing ports\n\n---\n\n### Integration\n\n#### `/venturo-go:add-amqp`\nSet up RabbitMQ async processing\n\n**Use for**:\n- Async email sending (queue email operations)\n- Event processing (domain events)\n- Background jobs (reports, data import, long-running tasks)\n- Webhooks (async webhook processing)\n- Notifications (push notifications, SMS)\n- Data synchronization\n\n**Creates**:\n- RabbitMQ service package (`pkg/queue/`)\n- Configuration and Docker setup\n- Publisher integration (in feature services)\n- Consumer feature (worker processes)\n- AMQP handler with graceful shutdown\n\n**Workflow**: 5-phase implementation\n1. Infrastructure Setup\n2. Publisher Implementation\n3. Consumer Implementation\n4. Application Integration\n5. Code Quality\n\n---\n\n## Architecture\n\nEach command follows a phase-based incremental workflow:\n\n### Phase Structure\n\n```\n1. Planning/Discovery - Gather requirements, ask clarifying questions\n2. Implementation - Execute systematic phases\n3. Validation - Stop after each phase for review\n4. Continuation - User says \"continue\" to proceed\n5. Quality Checks - Run formatting, linting, tests\n6. Documentation - Generate API docs\n```\n\n### Benefits\n\n- **Context-efficient**: Break large tasks into smaller chunks\n- **Validation**: Review output after each phase\n- **Learning**: Understand what each phase does\n- **Error recovery**: Easy to spot and fix issues early\n- **Consistency**: Same patterns across all features\n\n---\n\n## Project Structure\n\n```\nfeatures/                 # Business features (modular clean architecture)\n‚îú‚îÄ‚îÄ {feature}/\n‚îÇ   ‚îú‚îÄ‚îÄ domain/          # Domain layer\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/         # Request/response DTOs\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ entity/      # Domain entities\n‚îÇ   ‚îú‚îÄ‚îÄ repository/      # Data access layer\n‚îÇ   ‚îú‚îÄ‚îÄ service/         # Business logic layer\n‚îÇ   ‚îú‚îÄ‚îÄ http/            # HTTP handlers\n‚îÇ   ‚îú‚îÄ‚îÄ errs/            # Feature-specific errors\n‚îÇ   ‚îî‚îÄ‚îÄ main.{feature}.go\n\ninternal/\n‚îú‚îÄ‚îÄ domains/ports/       # Port interfaces for adapters\n‚îú‚îÄ‚îÄ config/              # Configuration management\n‚îî‚îÄ‚îÄ db/migrations/       # Feature-based migrations\n\npkg/                     # Shared utilities and adapters\n‚îú‚îÄ‚îÄ {service}/           # Service adapters (email, storage, etc.)\n‚îÇ   ‚îú‚îÄ‚îÄ {provider}/      # Provider implementations\n‚îÇ   ‚îî‚îÄ‚îÄ main.{service}.go\n‚îî‚îÄ‚îÄ queue/               # RabbitMQ integration\n```\n\n---\n\n## Quick Start\n\n### Create a new feature\n```bash\n/venturo-go:new-feature\n```\nClaude will ask about feature name, entities, database schema, and API endpoints, then guide you through 6 implementation phases.\n\n### Add an endpoint to existing feature\n```bash\n/venturo-go:add-endpoint\n```\nPerfect for adding reports, search endpoints, or custom actions without full CRUD infrastructure.\n\n### Add async processing\n```bash\n/venturo-go:add-amqp\n```\nSet up RabbitMQ for background jobs and event-driven features.\n\n---\n\n## File Naming Conventions\n\nAll files follow entity-based naming (singular):\n\n- **Entities**: `entity.{entity}.go` (e.g., `entity.user.go`)\n- **DTOs**: `request.{entity}.go`, `response.{entity}.go`\n- **Handlers**: `http.{entity}.go`\n- **Repositories**: `repo.{entity}.go`\n- **Services**: `service.{entity}.go`\n- **Errors**: `errors.{feature}.go` (shared across feature)\n- **Feature Module**: `main.{feature}.go`\n\n---\n\n## Requirements\n\n- Go 1.25.1+\n- Venturo Go Skeleton project\n- Claude Code with plugin support\n- MySQL/PostgreSQL (for migrations)\n- RabbitMQ (optional, for async features)\n\n---\n\n## Code Quality Standards\n\nAll commands automatically run:\n\n- **Formatting**: `make fmt` (gofmt + goimports)\n- **Linting**: `make lint` (golangci-lint)\n- **Testing**: `make test`\n- **Build verification**: Ensure code compiles\n\n---\n\n## Examples\n\n### Example 1: Create Product Catalog Feature\n```\n/venturo-go:new-feature\n\n> Feature name: product_catalog\n> Entities: products, categories, reviews\n> Database: Help me design the schema\n> External services: Image storage (S3)\n> Async: No\n> Endpoints: Full CRUD for all entities\n\n[Claude guides through 6 phases, creating complete feature]\n```\n\n### Example 2: Add User Statistics Endpoint\n```\n/venturo-go:add-endpoint\n\n> Feature: user_management\n> Type: Report/Analytics\n> Endpoint: GET /users/statistics\n> Returns: Total users, active users, new registrations this month\n\n[Claude creates DTOs, repository methods, service logic, handler]\n```\n\n### Example 3: Add SendGrid Email Adapter\n```\n/venturo-go:add-adapter-impl\n\n> Service: email (auto-discovered)\n> Provider: SendGrid\n> Configuration: API Key\n\n[Claude creates adapter implementation, updates config and initialization]\n```\n\n### Example 4: Set Up Async Email Processing\n```\n/venturo-go:add-amqp\n\n> Use case: Async Email Sending\n> Publisher: user_management\n> Consumer: New worker feature (email_sender)\n> Operations: Welcome email, password reset, verification\n\n[Claude sets up RabbitMQ, publisher, and consumer]\n```\n\n---\n\n## Support & Documentation\n\n- **Plugin Issues**: https://github.com/venturo-id/venturo-claude/issues\n- **Venturo Skeleton**: https://github.com/venturo-id/venturo-go-skeleton\n- **Clean Architecture**: See project CLAUDE.md for architecture details\n\n---\n\n## License\n\nMIT License - see LICENSE file for details\n\n---\n\n## Version\n\n1.0.0\n\n---\n\n**Developed by Venturo** - Professional development tools for Go backend engineering\n",
        "plugins/venturo-go/commands/add-adapter-impl.md": "---\ndescription: Add new provider to existing service adapter\n---\n\n# Add Adapter Implementation\n\nAdd a new provider/implementation to an **existing service port** (e.g., add SendGrid to email service).\n\n## When to Use\n\n**Use this when:**\n- A port interface already exists (e.g., `internal/domains/ports/email.go`)\n- You want to add another provider option\n\n**Don't use when:**\n- Creating brand new service type ‚Üí Use `/venturo-go:new-adapter`\n\n## Workflow\n\n### Phase 1: Auto-Discovery\n\nAutomatically scan `internal/domains/ports/` to show available services:\n\n```\nFound existing service ports:\n\n1. email\n   - Interface: EmailAdapter  \n   - Existing providers: gomail, async\n\nWhich service do you want to add a provider to?\n```\n\n### Phase 2: Provider Selection\n\nSuggest common providers based on service type:\n\n**Email**: SendGrid, AWS SES, Mailgun, Postmark, Resend, Brevo\n**Storage**: AWS S3, GCS, Azure Blob, MinIO\n**Payment**: Stripe, PayPal, Square, Razorpay\n\n### Phase 3: Implementation\n\nExecute these phases in order:\n\n1. **Scan & Analyze** - `phases/add-adapter/01-scan-and-analyze.md`\n2. **Create Adapter** - `phases/add-adapter/02-create-adapter.md`\n3. **Update Initialization** - `phases/add-adapter/03-update-initialization.md`\n4. **Update Configuration** - `phases/add-adapter/04-update-configuration.md`\n5. **Code Quality** - `phases/shared/code-quality.md`\n\n### Files Created\n\n```\npkg/{service}/{provider}/\n‚îú‚îÄ‚îÄ config.go\n‚îú‚îÄ‚îÄ {provider}.adapter.go\n‚îú‚îÄ‚îÄ errors.go\n‚îú‚îÄ‚îÄ {provider}.adapter_test.go\n‚îî‚îÄ‚îÄ README.md\n```\n\n### Files Updated\n\n- `pkg/{service}/main.{service}.go` - Add provider case\n- `internal/config/config.go` - Add config struct\n- `.env.example` - Add environment variables\n\n## Example\n\n```\nUser: /venturo-go:add-adapter-impl\n\nClaude: Scanning internal/domains/ports/...\n\nFound: email (gomail, async), payment (stripe)\n\nWhich service?\n\nUser: email\n\nClaude: Common email providers:\n- SendGrid\n- AWS SES\n...\n\nWhich provider?\n\nUser: sendgrid\n\n[Proceeds with implementation]\n```\n\n## Tips\n\n- Always scan for existing ports first\n- Implement ALL port interface methods\n- Validate configuration in constructor\n- Never log sensitive data (API keys)\n- Keep adapters thin (no business logic)\n",
        "plugins/venturo-go/commands/add-amqp.md": "---\ndescription: Set up RabbitMQ async processing\n---\n\n# AMQP/Async Integration\n\nSet up RabbitMQ asynchronous processing for background jobs and event-driven architecture.\n\n## When to Use\n\n**Use this when:**\n- Async email sending (queue email operations)\n- Event processing (handle domain events asynchronously)\n- Background jobs (report generation, data import, long-running tasks)\n- Webhooks (process incoming webhooks asynchronously)\n- Notifications (push notifications, SMS in background)\n- Data sync (synchronize data between services)\n\n## Workflow\n\n### Interactive Discovery\n\nAsk these questions:\n\n1. **Use case?** (Async Email, Event Processing, Background Jobs, Webhooks, Notifications, Data Sync, Other)\n2. **Publisher feature?** (Which feature produces messages?)\n3. **Consumer feature?**\n   - Same feature consumes own messages\n   - Different feature (specify)\n   - New dedicated worker feature (specify name)\n4. **Operations to queue?** (operation name, trigger event, payload structure)\n5. **Failure handling?** (retry count, dead letter queue, custom handling)\n6. **Queue configuration?** (one queue or multiple queues per operation/priority)\n7. **Performance requirements?** (messages per minute, max delay, concurrent consumers)\n8. **RabbitMQ already configured?** (Check `pkg/queue/`, `.env`, `docker-compose.yml`)\n\nPresent complete plan before proceeding.\n\n### Implementation Phases\n\nExecute these 5 phases in order:\n\n1. **Infrastructure Setup** - `phases/amqp/01-infrastructure.md`\n2. **Publisher Implementation** - `phases/amqp/02-publisher.md`\n3. **Consumer Implementation** - `phases/amqp/03-consumer.md`\n4. **Application Integration** - `phases/amqp/04-integration.md`\n5. **Code Quality** - `phases/shared/code-quality.md`\n\n### Components Created\n\n**Infrastructure:**\n- `pkg/queue/rabbitmq.go` - Queue service package\n- `internal/handler/amqp/consumers.go` - AMQP handler\n- `docker-compose.yml` - RabbitMQ container\n- `.env` - RabbitMQ configuration\n\n**Publisher:**\n- `features/{feature}/domain/dto/event.{entity}.go` - Event structs\n- Service method integration for publishing\n\n**Consumer:**\n- `features/{consumer_feature}/amqp/consumer.{entity}.go` - Message consumer\n- `features/{consumer_feature}/service/service.{entity}.go` - Processing logic\n- `features/{consumer_feature}/main.{consumer_feature}.go` - Consumer module\n\n## Common Queue Patterns\n\n**One Queue Per Operation:**\n```\nQueue: user_welcome_email\nQueue: order_confirmation_email\n```\nUse when: Different processing logic per operation\n\n**One Queue With Event Types:**\n```\nQueue: email_queue\nEvents: user.welcome, order.confirmation\n```\nUse when: Shared processing infrastructure\n\n**Priority Queues:**\n```\nQueue: high_priority_emails\nQueue: low_priority_emails\n```\nUse when: Different SLAs for operations\n\n**Fanout Pattern:**\n```\nExchange: user_events (fanout)\nQueues: email_queue, analytics_queue, audit_queue\n```\nUse when: Multiple consumers need same event\n\n## Example\n\n```\nUser: /venturo-go:add-amqp\n\nClaude: What use case? (Async Email, Events, Jobs, Webhooks, Notifications...)\n\nUser: Async Email Sending\n\nClaude: Which feature publishes messages?\n\nUser: user_management\n\nClaude: Which feature consumes?\nA) Same (user_management)\nB) Different (specify)\nC) New worker (specify name)\n\nUser: C) email_sender\n\nClaude: What operations to queue?\n\nUser: Welcome email, password reset email, verification email\n\n[Presents plan with queue names, events, error handling]\n\nClaude: Checking RabbitMQ infrastructure... Not found.\n\nI'll set up:\n1. pkg/queue/ (RabbitMQ service)\n2. Docker container\n3. Publisher in user_management\n4. Consumer in email_sender feature\n\nProceed?\n\n[Executes phases]\n```\n\n## Tips\n\n- Start simple (one queue, one consumer)\n- Test locally with Docker\n- Monitor queues via RabbitMQ Management UI (http://localhost:15672)\n- Implement dead letter queue for failed messages\n- Make consumers idempotent (handle duplicates)\n- Log message processing\n- Graceful shutdown (finish processing before exit)\n- Keep messages small (reference data by ID)\n- Version message schemas\n- Use TLS in production\n",
        "plugins/venturo-go/commands/add-endpoint.md": "---\ndescription: Add lightweight endpoint without full entity infrastructure\n---\n\n# Add Endpoint/Handler\n\nAdd new HTTP endpoints to an existing feature **without creating full entity infrastructure**.\n\n## When to Use\n\n**Use this when:**\n- Adding report/analytics endpoints (statistics, dashboards)\n- Adding search/filter endpoints (advanced search, autocomplete)\n- Adding action endpoints (approve, cancel, activate)\n- Adding aggregation endpoints (totals, counts, summaries)\n- Adding small entities without full CRUD (comments, tags, notes)\n- Adding utility endpoints (export, import, validate)\n\n**Don't use when:**\n- Creating new feature ‚Üí Use `/venturo-go:new-feature`\n- Adding full entity with CRUD ‚Üí Use `/venturo-go:add-entity`\n\n## Workflow\n\n### Interactive Discovery\n\nAsk these questions:\n\n1. **Which feature?** (List from `features/`)\n2. **Endpoint type?** (Report, Search, Action, Aggregation, Utility, Small Entity, Custom)\n3. **Specific endpoint?** (HTTP method + path, e.g., `GET /users/statistics`)\n4. **Related to entity or feature-general?**\n   - Entity-specific (user statistics) ‚Üí Add to existing handler\n   - Feature-general (dashboard) ‚Üí Create new handler\n   - Operation-specific (bulk import) ‚Üí Dedicated handler\n5. **Operation/handler name?**\n6. **Purpose?** (What data/action?)\n7. **Input required?** (URL params, query params, body, headers)\n8. **Return type?** (Single object, array, paginated list, success message, file)\n9. **Business logic?** (queries, calculations, external calls)\n10. **External services?** (email, storage, queue, cache)\n11. **Authorization?** (public, authenticated, role-based, permission-based)\n12. **New repository methods?** (queries, aggregations)\n13. **Modifies data?** (read-only vs write operations)\n\nPresent plan and confirm before implementation.\n\n### Implementation Phases\n\nExecute these 8 phases:\n\n1. **Create DTOs** - `phases/add-endpoint/01-create-dtos.md`\n2. **Repository Methods** - `phases/add-endpoint/02-repository-methods.md`\n3. **Service Methods** - `phases/add-endpoint/03-service-methods.md`\n4. **HTTP Handlers** - `phases/add-endpoint/04-http-handlers.md`\n5. **Register Routes** - `phases/add-endpoint/05-register-routes.md`\n6. **Testing** - `phases/add-endpoint/06-testing.md`\n7. **Code Quality** - `phases/shared/code-quality.md`\n8. **Documentation** - `phases/shared/documentation.md`\n\n## Common Endpoint Patterns\n\n**Report/Analytics:**\n```\nGET /users/statistics?from_date=...&to_date=...\nGET /dashboard/summary\n```\n- Query parameters for filters\n- Aggregated data response\n- Read-only, often cached\n\n**Search/Filter:**\n```\nGET /products/search?q=keyword&category=...\nPOST /orders/advanced-filter\n```\n- Search criteria in query or body\n- Paginated results\n\n**Action/Command:**\n```\nPOST /orders/:id/cancel\nPOST /users/:id/activate\n```\n- URL parameter for resource ID\n- Body for action parameters\n- Modifies state, idempotent\n\n**Aggregation:**\n```\nGET /sales/totals?group_by=month\nGET /inventory/summary\n```\n- Computed/derived data\n- Grouping and filtering\n\n**Utility:**\n```\nPOST /users/export (returns file)\nPOST /products/import (accepts file)\n```\n- File upload/download\n- Batch operations\n\n## Example\n\n```\nUser: /venturo-go:add-endpoint\n\nClaude: Which feature?\n\nUser: user_management\n\nClaude: Endpoint type?\n\nUser: Report/Analytics\n\nClaude: Specific endpoint?\n\nUser: GET /users/statistics\n\nClaude: Related to user entity or feature-general?\n\nUser: Entity-specific (user)\n\nClaude: What data should statistics return?\n\nUser: Total users, active users, new registrations this month, users by role\n\n[Presents plan, proceeds with phases]\n```\n\n## Tips\n\n- Keep it focused (one endpoint = one responsibility)\n- Reuse existing repository/service methods\n- Validate input with binding tags\n- Consider caching for expensive operations\n- Think about performance and scale\n- Apply proper authentication\n- Test edge cases\n",
        "plugins/venturo-go/commands/add-entity.md": "---\ndescription: Add new entity with full CRUD to existing feature\n---\n\n# Add Entity and Routes\n\nAdd a new entity with complete CRUD operations to an **existing feature**.\n\n## When to Use\n\n**Use this when:**\n- Adding new data entity to existing feature\n- Need full CRUD infrastructure (Create, Read, Update, Delete, List)\n- Example: Add `profile` entity to `user_management` feature\n\n**Don't use when:**\n- Creating new feature ‚Üí Use `/venturo-go:new-feature`\n- Adding lightweight endpoint only ‚Üí Use `/venturo-go:add-endpoint`\n\n## Workflow\n\n### Interactive Discovery\n\nAsk these questions:\n\n1. **Which feature?** (List from `features/` directory)\n2. **Entity name?** (singular, e.g., `product`, `order`, `profile`)\n3. **Database table name?** (usually plural)\n4. **Table exists?** (Yes = generate from schema, No = design schema)\n5. **Entity fields?** (if designing new schema)\n6. **Relationships?** (foreign keys, joins)\n7. **HTTP operations?** (CRUD, batch, custom actions)\n8. **Base URL path?** (e.g., `/products`, `/orders`)\n9. **Authentication?** (public, authenticated, role-based, permission-based)\n10. **Business rules?** (validation, state transitions, side effects)\n11. **External services?** (email, storage, notifications)\n\nPresent plan and ask for confirmation.\n\n### Implementation Phases\n\nExecute these 9 phases in order:\n\n1. **Migration** - `phases/new-entity/01-migration.md`\n2. **Domain Entity** - `phases/new-entity/02-domain-entity.md`\n3. **DTOs** - `phases/new-entity/03-dtos.md`\n4. **Repository** - `phases/new-entity/04-repository.md`\n5. **Service** - `phases/new-entity/05-service.md`\n6. **HTTP Handler** - `phases/new-entity/06-handler.md`\n7. **Routes & Errors** - `phases/new-entity/07-routes.md`\n8. **Code Quality** - `phases/shared/code-quality.md`\n9. **Documentation** - `phases/shared/documentation.md`\n\n## Common Patterns\n\n**Simple CRUD Entity:**\n- Basic create, read, update, delete\n- Example: Product, Category, Tag\n\n**Entity with Relationships:**\n- References other entities\n- Example: Order (belongs to User)\n\n**Entity with State Machine:**\n- Status transitions + business rules\n- Example: Order (draft ‚Üí pending ‚Üí confirmed ‚Üí shipped)\n\n**Entity with Soft Delete:**\n- Uses GORM `DeletedAt` field\n- Never permanently deleted\n\n**Entity with Audit Trail:**\n- Tracks `CreatedBy`, `UpdatedBy`\n- Populated from auth context\n\n## File Naming Conventions\n\n- Entities: `entity.{entity}.go` (singular)\n- DTOs: `request.{entity}.go`, `response.{entity}.go`\n- Handlers: `http.{entity}.go`\n- Repositories: `repo.{entity}.go`\n- Services: `service.{entity}.go`\n- Errors: `errors.{feature}.go` (shared)\n\n## Example\n\n```\nUser: /venturo-go:add-entity\n\nClaude: Which feature?\n- user_management\n- email_sender\n\nUser: user_management\n\nClaude: Entity name? (singular)\n\nUser: profile\n\nClaude: Database table name?\n\nUser: user_profiles\n\nClaude: Does table exist?\n\nUser: No\n\nClaude: What fields?\n\nUser:\n- bio: text\n- avatar_url: string\n- phone: string, unique\n- user_id: uuid, foreign key\n\n[Presents plan, proceeds with phases]\n```\n\n## Tips\n\n- Start with database schema design\n- Use code generation for standard CRUD: `make gen-crud`\n- Follow naming conventions strictly\n- Add validation tags to DTOs\n- Use feature-specific errors\n- Test incrementally\n- Add database indexes for performance\n- Apply proper authentication\n",
        "plugins/venturo-go/commands/new-adapter.md": "---\ndescription: Create new adapter/service type with port interface\n---\n\n# New Adapter Creation\n\nCreate a **brand new service type** with port interface and first adapter implementation.\n\n## When to Use\n\n**Use this when:**\n- Creating first adapter for a service (e.g., first payment adapter with Stripe)\n- No port interface exists yet in `internal/domains/ports/`\n- Need complete service infrastructure (port + adapter + config + init)\n\n**Already have port?** ‚Üí Use `/venturo-go:add-adapter-impl`\n\n## Workflow\n\n### Interactive Discovery\n\nAsk these questions:\n\n1. **Adapter type** (Email, Storage, Queue, Cache, Search, Payment, Notification, Other)\n2. **Specific provider** (e.g., \"SendGrid\", \"AWS S3\", \"Stripe\")\n3. **Port interface exists?** (Check `internal/domains/ports/`)\n4. **Core operations** (methods to implement)\n5. **Configuration needed** (API keys, endpoints, regions)\n6. **Async processing?** (RabbitMQ integration)\n\nPresent complete plan before implementation.\n\n### Implementation Steps\n\n1. **Create Port Interface** (if needed) - `internal/domains/ports/{service}.go`\n2. **Create Adapter Package** - `pkg/{service}/{provider}/`\n3. **Adapter Configuration** - `config.go`\n4. **Implement Adapter** - `adapter.go`\n5. **Error Handling** - `errors.go`\n6. **Main Config Update** - `internal/config/config.go`\n7. **Environment Variables** - `.env.example`\n8. **Initialization Function** - `pkg/{service}/main.{service}.go`\n9. **Application Integration** - `cmd/api/main.go`\n10. **Write Tests** - `adapter_test.go`, `integration_test.go`\n11. **Documentation** - `README.md`\n12. **Optional Async** - AMQP wrapper (see `/venturo-go:add-amqp`)\n\n### Common Port Patterns\n\n**Email Port:**\n```go\ntype EmailService interface {\n    SendEmail(to, subject, body string) error\n    SendHTMLEmail(to, subject, htmlBody string) error\n}\n```\n\n**Storage Port:**\n```go\ntype StorageService interface {\n    UploadFile(ctx context.Context, path string, data io.Reader) (string, error)\n    DownloadFile(ctx context.Context, path string) (io.ReadCloser, error)\n    DeleteFile(ctx context.Context, path string) error\n}\n```\n\n**Payment Port:**\n```go\ntype PaymentService interface {\n    CreatePayment(ctx context.Context, amount int64, currency string) (*PaymentResult, error)\n    RefundPayment(ctx context.Context, paymentID string) error\n}\n```\n\n## Adapter Patterns\n\n**HTTP API-Based** (SendGrid, Mailgun, Stripe):\n- Use `http.Client`\n- Build requests with authentication headers\n\n**SDK-Based** (AWS, Google Cloud):\n- Use provider's official SDK client\n- Initialize with credentials\n\n**Connection Pool** (Redis, Database):\n- Maintain connection pool\n- Implement `Close()` method\n\n## Example\n\n```\nUser: /venturo-go:new-adapter\n\nClaude: What type of adapter? (Email, Storage, Payment...)\n\nUser: Payment\n\nClaude: Specific provider?\n\nUser: Stripe\n\nClaude: Checking for payment port... Not found.\n\nI'll create:\n1. internal/domains/ports/payment.go (interface)\n2. pkg/payment/stripe/ (adapter)\n3. pkg/payment/main.payment.go (init)\n\n[Proceeds with implementation]\n```\n\n## Tips\n\n- Study existing adapters (`pkg/email/gomail/`)\n- Follow port interface strictly\n- Validate config early, fail fast\n- Wrap provider errors with context\n- Keep adapters thin\n- Never log sensitive data\n",
        "plugins/venturo-go/commands/new-feature.md": "---\ndescription: Create complete feature with modular clean architecture\n---\n\n# New Feature Creation\n\nYou will guide the user through creating a complete Go backend feature using the Venturo skeleton's clean architecture pattern.\n\n## Workflow\n\nThis command uses an **incremental 6-phase workflow** to create features step-by-step.\n\n### Interactive Discovery\n\nAsk the user these questions first:\n\n1. **Feature name** (snake_case, e.g., `order_management`)\n2. **Entities/sub-features** (e.g., orders, payments, shipments)\n3. **Business purpose** (brief description)\n4. **Database schema** (existing tables or design help needed?)\n5. **External services** (email, storage, payment, etc.)\n6. **Async processing needed?** (RabbitMQ integration?)\n7. **HTTP endpoints** (CRUD operations, custom actions)\n\nPresent a complete plan and ask for confirmation before proceeding.\n\n### Implementation Phases\n\nAfter confirmation, execute these phases sequentially (read each phase file when needed):\n\n1. **Planning & Migration** - `phases/new-feature/01-planning-and-migration.md`\n2. **Domain Layer** - `phases/new-feature/02-domain-layer.md`\n3. **Repository Layer** - `phases/new-feature/03-repository-layer.md`\n4. **Service Layer** - `phases/new-feature/04-service-layer.md`\n5. **HTTP Handler & Routes** - `phases/new-feature/05-handler-and-routes.md`\n6. **Documentation** - `phases/new-feature/06-documentation.md`\n\nAfter each phase:\n- Stop and report what was created\n- Ask user to review\n- Wait for \"continue\" before next phase\n\n## Key Implementation Rules\n\n**Error Handling:**\n```go\n// ‚úÖ Correct\nutils.ErrorResponse(c, http.StatusBadRequest, \"Invalid request\", err.Error())\n\n// ‚ùå Wrong\nutils.ErrorResponse(c, http.StatusBadRequest, \"Invalid request\", err)\n```\n\n**Middleware:**\n```go\n// ‚úÖ Correct\n{entity}Group.Use(middleware.JWTMiddleware(cfg))\n```\n\n**File Naming:**\n- Entities: `entity.{entity}.go`\n- DTOs: `request.{entity}.go`, `response.{entity}.go`\n- Handlers: `http.{entity}.go`\n- Repositories: `repo.{entity}.go`\n- Services: `service.{entity}.go`\n- Errors: `errors.{feature_name}.go`\n\n## Frontend Integration\n\nAfter completion, the generated OpenAPI YAML can be used with Claude AI to:\n- Generate TypeScript interfaces\n- Create API client functions\n- Generate React hooks\n- Create validation schemas\n\n## Example Usage\n\n```\nUser: /venturo-go:new-feature\n\nClaude: I'll help you create a new feature. Let me ask some questions first:\n\n1. What is the name of the feature you want to create?\n\nUser: product_catalog\n\nClaude: 2. What entities/sub-features will this feature contain?\n\nUser: products, categories, reviews\n\n[Continues through all questions, presents plan, executes phases]\n```\n",
        "plugins/venturo-go/phases/add-adapter/README.md": "# Add Adapter Implementation - Phase-Based Instruction\n\n## Overview\n\nThis instruction guides you through adding a **NEW provider/implementation to an EXISTING service port**.\n\n**Use this when:**\n- A port interface already exists (e.g., `internal/domains/ports/email.go`)\n- You want to add another provider (e.g., add SendGrid to existing email service)\n\n**DO NOT use this when:**\n- Creating a brand new service type with its first adapter\n- ‚Üí Instead use: `new-adapter-instruction.md`\n\n---\n\n## Phase Structure\n\n### Phase 1: Scan and Analyze\nüìñ **File:** `01-scan-and-analyze.md`\n\n- Scan existing service ports\n- Select target service\n- Choose provider\n- Identify configuration requirements\n- Generate implementation plan\n\n### Phase 2: Create Adapter Implementation\nüìñ **File:** `02-create-adapter.md`\n\n- Create adapter directory\n- Implement configuration\n- Define errors\n- Implement adapter (all port methods)\n- Create tests\n- Write documentation\n\n### Phase 3: Update Service Initialization\nüìñ **File:** `03-update-initialization.md`\n\n- Add provider import\n- Add provider case to initialization function\n- Map configuration fields\n\n### Phase 4: Update Configuration Files\nüìñ **File:** `04-update-configuration.md`\n\n- Update main config struct\n- Add environment variables\n- Verify configuration loading\n\n---\n\n## Quick Start\n\n**Prompt Claude:**\n```\nAdd adapter implementation, read add-adapter-implementation.md\n```\n\nClaude will:\n1. Scan for existing service ports\n2. Show available services\n3. Guide you through provider selection\n4. Execute all 4 phases systematically\n\n---\n\n## Example: Adding SendGrid to Email Service\n\n**User:** Add adapter implementation\n\n**Claude:**\n- Scans and finds `email` service\n- Suggests email providers (SendGrid, SES, Mailgun...)\n- User selects SendGrid\n- Creates all adapter files in `pkg/email/sendgrid/`\n- Updates initialization and config\n- Result: Email service now supports SendGrid provider\n\n---\n\n## Files Created\n\nAfter completion, you'll have:\n\n```\npkg/{service}/{provider}/\n‚îú‚îÄ‚îÄ config.go               # Provider configuration\n‚îú‚îÄ‚îÄ {provider}.adapter.go   # Adapter implementation\n‚îú‚îÄ‚îÄ errors.go              # Provider-specific errors\n‚îú‚îÄ‚îÄ {provider}.adapter_test.go  # Unit tests\n‚îî‚îÄ‚îÄ README.md              # Provider documentation\n```\n\n**Files Updated:**\n- `pkg/{service}/main.{service}.go` - Provider selection\n- `internal/config/config.go` - Configuration struct\n- `.env.example` - Environment variables\n\n---\n\n## Phase Execution Order\n\n1. **Phase 1** (Scan) ‚Üí Identifies service and provider\n2. **Phase 2** (Adapter) ‚Üí Creates implementation files\n3. **Phase 3** (Init) ‚Üí Updates service initialization\n4. **Phase 4** (Config) ‚Üí Updates configuration\n\n**All phases must be completed in order.**\n\n---\n\n## Tips\n\n- Let Claude scan ports first - don't assume what exists\n- Follow port interface exactly - implement ALL methods\n- Add config validation early\n- Document well for future maintainers\n- Test both success and failure cases\n- Never commit secrets to .env files\n\n---\n\n## Related Instructions\n\n- **new-adapter-instruction.md** - Create first adapter for new service type\n- **amqp-integration-instruction.md** - Add async/background processing\n- **shared/code-quality.md** - Quality checks and testing\n",
        "plugins/venturo-go/phases/add-endpoint/README.md": "# Add Endpoint Phases\n\nThis directory contains phase files for the `add-endpoint-instruction.md` workflow.\n\n## Phase Files\n\n1. **01-create-dtos.md** - Create request and response DTOs\n2. **02-repository-methods.md** - Add repository methods (if needed)\n3. **03-service-methods.md** - Add service methods\n4. **04-http-handlers.md** - Create HTTP handlers\n5. **05-register-routes.md** - Register routes and update errors\n6. **06-testing.md** - Test the endpoint\n\n## Shared Phases\n\nAfter completing the above phases, execute:\n\n7. **Code Quality Checks** - `.venturo/instructions/shared/code-quality.md`\n8. **API Documentation** - `.venturo/instructions/shared/documentation.md`\n\n## Usage\n\nThese phase files are executed sequentially by the `add-endpoint-instruction.md` orchestrator after the interactive discovery process.\n",
        "plugins/venturo-go/phases/amqp/README.md": "# AMQP/RabbitMQ Integration - Phase-Based Instruction\n\n## Overview\n\nThis instruction guides you through adding **asynchronous message processing** using RabbitMQ/AMQP to your application.\n\n**Use this when:**\n- You need async email sending\n- You want event-driven architecture\n- You need background job processing\n- You want to decouple services\n- You need to handle webhooks asynchronously\n\n---\n\n## Phase Structure\n\n### Phase 1: Infrastructure Setup\nüìñ **File:** `01-infrastructure.md`\n\n- Create RabbitMQ service package\n- Add configuration\n- Setup Docker container\n- Create AMQP handler package\n\n### Phase 2: Publisher Implementation\nüìñ **File:** `02-publisher.md`\n\n- Define message/event structs\n- Implement publisher service\n- Integrate publishing into business logic\n- Update feature initialization\n\n### Phase 3: Consumer Implementation\nüìñ **File:** `03-consumer.md`\n\n- Create consumer feature\n- Implement message handler\n- Implement processing service\n- Register consumers\n\n### Phase 4: Application Integration\nüìñ **File:** `04-integration.md`\n\n- Update main application\n- Setup graceful shutdown\n- End-to-end testing\n- Integration tests\n\n---\n\n## Quick Start\n\n**Prompt Claude:**\n```\nAdd AMQP functionality, read amqp-integration-instruction.md\n```\n\nClaude will:\n1. Ask about your use case (email, events, jobs, etc.)\n2. Identify publisher and consumer features\n3. Guide you through all 4 phases\n4. Test the complete async flow\n\n---\n\n## Common Use Cases\n\n### Async Email Sending\n**Publisher:** `user_management` feature (on user registration)\n**Consumer:** `email_sender` feature (sends welcome email)\n**Queue:** `email_queue`\n\n### Event Processing\n**Publisher:** `order_management` feature (on order created)\n**Consumer:** `inventory` + `notification` features\n**Queue:** `order_events` (fanout pattern)\n\n### Background Jobs\n**Publisher:** `report` feature (on report request)\n**Consumer:** `report_generator` feature (generates PDF)\n**Queue:** `report_jobs`\n\n---\n\n## Files Created\n\nAfter completion, you'll have:\n\n**Infrastructure:**\n```\npkg/queue/\n‚îî‚îÄ‚îÄ rabbitmq.go\n\ninternal/handler/amqp/\n‚îî‚îÄ‚îÄ consumers.go\n```\n\n**Feature Publisher:**\n```\nfeatures/{feature}/domain/dto/\n‚îî‚îÄ‚îÄ event.{entity}.go\n\nfeatures/{feature}/service/\n‚îî‚îÄ‚îÄ service.{entity}.go (with publishing)\n```\n\n**Feature Consumer:**\n```\nfeatures/{consumer_feature}/\n‚îú‚îÄ‚îÄ amqp/\n‚îÇ   ‚îî‚îÄ‚îÄ consumer.{entity}.go\n‚îú‚îÄ‚îÄ service/\n‚îÇ   ‚îî‚îÄ‚îÄ service.{entity}.go\n‚îî‚îÄ‚îÄ main.{consumer_feature}.go\n```\n\n**Configuration:**\n- Updated `internal/config/config.go`\n- Updated `.env.example`\n- Updated `docker-compose.yml`\n- Updated `cmd/api/main.go`\n\n---\n\n## Phase Execution Order\n\n1. **Phase 1** (Infrastructure) ‚Üí Sets up RabbitMQ\n2. **Phase 2** (Publisher) ‚Üí Implements message publishing\n3. **Phase 3** (Consumer) ‚Üí Implements message consumption\n4. **Phase 4** (Integration) ‚Üí Connects everything together\n\n**All phases must be completed in order.**\n\n---\n\n## Common Patterns\n\n### Pattern 1: One Queue Per Operation\n```\nemail_welcome_queue\nemail_confirmation_queue\nemail_reset_password_queue\n```\n\n### Pattern 2: One Queue With Event Types\n```\nQueue: email_queue\nEvents: user.welcome, order.confirmation, password.reset\n```\n\n### Pattern 3: Fanout for Multiple Consumers\n```\nExchange: order_events\nQueues: inventory_queue, notification_queue, analytics_queue\n```\n\n---\n\n## Testing\n\nAfter implementation:\n\n```bash\n# 1. Start RabbitMQ\ndocker-compose up -d rabbitmq\n\n# 2. Enable in config\nRABBITMQ_ENABLED=true\n\n# 3. Start application\nmake dev\n\n# 4. Trigger publisher (API call)\ncurl -X POST http://localhost:8080/core/v1/users/register ...\n\n# 5. Check RabbitMQ UI\nopen http://localhost:15672\n\n# 6. Verify consumer logs\ndocker logs venturo-app | grep \"Processing event\"\n```\n\n---\n\n## Tips\n\n- Start with one queue and one consumer\n- Use RabbitMQ Management UI to monitor queues\n- Implement idempotent consumers (handle duplicates)\n- Log all message processing for debugging\n- Keep messages small (reference data by ID)\n- Handle errors gracefully (retry vs. DLQ)\n- Test with RabbitMQ disabled (RABBITMQ_ENABLED=false)\n\n---\n\n## Related Instructions\n\n- **new-feature-instruction.md** - Create consumer feature if needed\n- **add-adapter-implementation.md** - Add async email adapter\n- **shared/code-quality.md** - Quality checks and testing\n",
        "plugins/venturo-go/phases/shared/README.md": "# Shared Instruction Phases\n\nThis directory contains **reusable phase files** used across multiple instruction workflows to reduce redundancy and maintain consistency.\n\n## Architecture Overview\n\nThe instruction system uses a **phase-based architecture** where:\n\n1. **Main instruction files** (orchestrators) define the workflow and interactive discovery\n2. **Phase files** contain detailed implementation steps\n3. **Shared phase files** are reused across multiple instructions\n\n```\n.venturo/instructions/\n‚îú‚îÄ‚îÄ new-feature-instruction.md          # Orchestrator (main file)\n‚îú‚îÄ‚îÄ add-endpoint-instruction.md         # Orchestrator (main file)\n‚îú‚îÄ‚îÄ new-entity-route-instruction.md     # Orchestrator (main file)\n‚îú‚îÄ‚îÄ add-adapter-implementation.md       # Orchestrator (main file)\n‚îú‚îÄ‚îÄ amqp-integration-instruction.md     # Orchestrator (main file)\n‚îÇ\n‚îú‚îÄ‚îÄ new-feature/                        # Feature-specific phases\n‚îÇ   ‚îú‚îÄ‚îÄ 01-planning-and-migration.md\n‚îÇ   ‚îú‚îÄ‚îÄ 02-domain-layer.md\n‚îÇ   ‚îú‚îÄ‚îÄ 03-repository-layer.md\n‚îÇ   ‚îú‚îÄ‚îÄ 04-service-layer.md\n‚îÇ   ‚îú‚îÄ‚îÄ 05-handler-and-routes.md\n‚îÇ   ‚îî‚îÄ‚îÄ 06-documentation.md             # References shared/documentation.md\n‚îÇ\n‚îú‚îÄ‚îÄ add-endpoint/                       # Endpoint-specific phases\n‚îÇ   ‚îú‚îÄ‚îÄ 01-create-dtos.md\n‚îÇ   ‚îú‚îÄ‚îÄ 02-repository-methods.md\n‚îÇ   ‚îú‚îÄ‚îÄ 03-service-methods.md\n‚îÇ   ‚îú‚îÄ‚îÄ 04-http-handlers.md\n‚îÇ   ‚îú‚îÄ‚îÄ 05-register-routes.md\n‚îÇ   ‚îî‚îÄ‚îÄ 06-testing.md\n‚îÇ\n‚îú‚îÄ‚îÄ new-entity/                         # Entity-specific phases\n‚îÇ   ‚îú‚îÄ‚îÄ 01-migration.md\n‚îÇ   ‚îú‚îÄ‚îÄ 02-domain-entity.md\n‚îÇ   ‚îú‚îÄ‚îÄ 03-dtos.md\n‚îÇ   ‚îú‚îÄ‚îÄ 04-repository.md\n‚îÇ   ‚îú‚îÄ‚îÄ 05-service.md\n‚îÇ   ‚îú‚îÄ‚îÄ 06-handler.md\n‚îÇ   ‚îî‚îÄ‚îÄ 07-routes.md\n‚îÇ\n‚îú‚îÄ‚îÄ add-adapter/                        # Adapter-specific phases\n‚îÇ   ‚îú‚îÄ‚îÄ 01-config.md\n‚îÇ   ‚îú‚îÄ‚îÄ 02-adapter-impl.md\n‚îÇ   ‚îú‚îÄ‚îÄ 03-initialization.md\n‚îÇ   ‚îî‚îÄ‚îÄ 04-configuration.md\n‚îÇ\n‚îú‚îÄ‚îÄ amqp/                               # AMQP-specific phases\n‚îÇ   ‚îú‚îÄ‚îÄ 01-infrastructure.md\n‚îÇ   ‚îú‚îÄ‚îÄ 02-publisher.md\n‚îÇ   ‚îú‚îÄ‚îÄ 03-consumer.md\n‚îÇ   ‚îî‚îÄ‚îÄ 04-integration.md\n‚îÇ\n‚îî‚îÄ‚îÄ shared/                             # Shared across all instructions ‚≠ê\n    ‚îú‚îÄ‚îÄ README.md                       # This file\n    ‚îú‚îÄ‚îÄ documentation.md                # API docs + OpenAPI + Swagger UI\n    ‚îî‚îÄ‚îÄ code-quality.md                 # Format, lint, test, build\n```\n\n---\n\n## Shared Phase Files\n\n### 1. `documentation.md`\n\n**Purpose:** Create API documentation, update OpenAPI spec, validate, and test with Swagger UI\n\n**Used by:**\n- `new-feature-instruction.md` (Phase 6)\n- `add-endpoint-instruction.md` (Steps 11-13)\n- `new-entity-route-instruction.md` (Steps 12-14)\n\n**Contains:**\n- Step 1: Create API output documentation (markdown files)\n- Step 2: Update OpenAPI specification\n- Step 3: Validate OpenAPI YAML\n- Step 4: Test with Swagger UI\n- Verification checklist\n- Templates for different endpoint types\n\n**When to use:**\nAfter implementing HTTP endpoints/handlers that need documentation.\n\n---\n\n### 2. `code-quality.md`\n\n**Purpose:** Run code formatting, linting, testing, and build checks\n\n**Used by:**\n- All instruction workflows (final step before completion)\n- `add-endpoint-instruction.md` (Step 10)\n- `new-entity-route-instruction.md` (Step 15)\n- `add-adapter-implementation.md` (Step 10)\n- `amqp-integration-instruction.md` (Part E)\n\n**Contains:**\n- Step 1: Format code (`make fmt`)\n- Step 2: Run linter (`make lint`)\n- Step 3: Run tests (`make test`)\n- Step 4: Run all checks (`make check`)\n- Step 5: Check test coverage (optional)\n- Step 6: Build check (`make build`)\n- Common issues and solutions\n- Best practices\n\n**When to use:**\nAfter any code changes, before marking implementation as complete.\n\n---\n\n## How Instructions Use Shared Phases\n\n### Pattern 1: Direct Reference\n\nMain instruction file references shared phase at the appropriate step:\n\n```markdown\n### Step 10: Code Quality Checks\n\n**Execute the shared code quality phase:**\n\nüìñ **Read and execute:** `.venturo/instructions/shared/code-quality.md`\n\nThis phase will:\n- Format all code\n- Run linter checks\n- Execute tests\n- Verify build\n\nOnce complete, say \"continue\" to proceed to the next step.\n```\n\n### Pattern 2: Phase File Reference\n\nPhase file (e.g., `new-feature/06-documentation.md`) delegates to shared phase:\n\n```markdown\n# Phase 6: API Documentation\n\nThis phase uses the **shared documentation workflow**.\n\nüìñ **Read and execute:** `.venturo/instructions/shared/documentation.md`\n\n## Context for This Feature\n\n- Feature: {feature_name}\n- Entities: {entity_list}\n- Base URL: `/core/v1/{feature_path}`\n\nAfter completing the shared documentation phase, mark this phase as complete.\n```\n\n### Pattern 3: Embedded Reference\n\nMain instruction embeds shared phase inline:\n\n```markdown\n### Step 15: Code Quality & Documentation\n\nThis step combines two shared phases:\n\n1. **Code Quality Checks**\n   üìñ Read: `.venturo/instructions/shared/code-quality.md`\n\n2. **API Documentation**\n   üìñ Read: `.venturo/instructions/shared/documentation.md`\n\nExecute both phases sequentially.\n```\n\n---\n\n## Benefits of Shared Phases\n\n### 1. **Consistency**\n- Same process across all instructions\n- Uniform documentation format\n- Standardized quality checks\n\n### 2. **Maintainability**\n- Update once, apply everywhere\n- Fix errors in one place\n- Add improvements globally\n\n### 3. **Reduced Redundancy**\n- ~800 lines of documentation steps ‚Üí 1 shared file\n- ~100 lines of quality check steps ‚Üí 1 shared file\n- Saves ~900 lines per instruction\n\n### 4. **Better Organization**\n- Clear separation of concerns\n- Easier to find specific steps\n- Modular instruction design\n\n### 5. **Scalability**\n- Easy to add new shared phases\n- Simple to create new instructions\n- Reuse proven patterns\n\n---\n\n## Creating New Shared Phases\n\nWhen to create a new shared phase:\n\n1. **Repetition:** Step appears in 3+ instructions\n2. **Complexity:** Step has 100+ lines\n3. **Independence:** Step is self-contained\n4. **Stability:** Step rarely changes per use case\n\n### Template for New Shared Phase\n\n```markdown\n# Shared Phase: {Phase Name}\n\nThis is a **shared phase** used by multiple instruction workflows. It handles {brief description}.\n\n## When to Use This Phase\n\nUse this phase when:\n- {Scenario 1}\n- {Scenario 2}\n- {Scenario 3}\n\nUsed by:\n- `{instruction-1}.md` (Step X)\n- `{instruction-2}.md` (Step Y)\n\n---\n\n## Step 1: {First Step}\n\n{Detailed instructions}\n\n---\n\n## Step 2: {Second Step}\n\n{Detailed instructions}\n\n---\n\n## Verification Checklist\n\nPhase is complete when:\n\n- [ ] {Requirement 1}\n- [ ] {Requirement 2}\n- [ ] {Requirement 3}\n\n---\n\n## Troubleshooting\n\n### Issue: {Common Problem}\n\n**Solution:** {How to fix}\n\n---\n\n## Related Files\n\n- Main instruction: Varies by workflow\n- Related phase: `{other-phase}.md`\n```\n\n---\n\n## Phase Naming Conventions\n\n### Shared Phase Files\n- `{topic}.md` (lowercase, hyphenated)\n- Examples: `documentation.md`, `code-quality.md`, `testing.md`\n\n### Instruction-Specific Phase Files\n- `{number}-{topic}.md` (numbered, lowercase, hyphenated)\n- Examples: `01-planning.md`, `02-domain-layer.md`, `03-repository.md`\n\n---\n\n## Updating Shared Phases\n\nWhen updating a shared phase:\n\n1. **Test Impact:** Verify changes work for all instructions\n2. **Update README:** Document new features/changes\n3. **Version Notes:** Add comment about what changed\n4. **Backward Compatibility:** Avoid breaking existing workflows\n\n### Example Update Comment\n\n```markdown\n<!--\nUpdated: 2025-01-11\nChanges: Added Step 5 for test coverage checking\nImpact: All instructions using this phase\n-->\n```\n\n---\n\n## Phase Dependencies\n\nSome shared phases may depend on context from main instructions:\n\n### `documentation.md` expects:\n- Feature name\n- Entity name(s)\n- Endpoint paths\n- Request/response DTOs already created\n\n### `code-quality.md` expects:\n- Code changes committed locally\n- Dependencies installed\n- Database migrations applied (if needed)\n\n---\n\n## Future Shared Phases\n\nCandidates for future shared phases:\n\n### `testing.md`\n- Unit test creation\n- Integration test setup\n- Test data management\n- Used by: All instructions\n\n### `migration.md`\n- Database migration creation\n- Migration validation\n- Running migrations\n- Used by: new-feature, new-entity\n\n### `error-handling.md`\n- Error definition\n- Error handling patterns\n- Error response formatting\n- Used by: All instructions\n\n### `dto-creation.md`\n- Request DTO patterns\n- Response DTO patterns\n- Validation tags\n- Used by: new-feature, new-entity, add-endpoint\n\n---\n\n## Workflow Integration\n\n### Before Shared Phases\n```\nMain Instruction (1500 lines)\n‚îú‚îÄ‚îÄ Discovery Questions\n‚îú‚îÄ‚îÄ Implementation Steps\n‚îÇ   ‚îú‚îÄ‚îÄ Step 1-9: Feature-specific\n‚îÇ   ‚îú‚îÄ‚îÄ Step 10: Code Quality (100 lines)\n‚îÇ   ‚îú‚îÄ‚îÄ Step 11-13: Documentation (800 lines)\n‚îÇ   ‚îî‚îÄ‚îÄ Step 14: Verification\n‚îî‚îÄ‚îÄ Examples\n```\n\n### After Shared Phases\n```\nMain Instruction (600 lines)\n‚îú‚îÄ‚îÄ Discovery Questions\n‚îú‚îÄ‚îÄ Implementation Steps\n‚îÇ   ‚îú‚îÄ‚îÄ Step 1-9: Feature-specific\n‚îÇ   ‚îú‚îÄ‚îÄ Step 10: ‚Üí shared/code-quality.md\n‚îÇ   ‚îú‚îÄ‚îÄ Step 11: ‚Üí shared/documentation.md\n‚îÇ   ‚îî‚îÄ‚îÄ Step 12: Verification\n‚îî‚îÄ‚îÄ Examples\n\nshared/code-quality.md (100 lines)\nshared/documentation.md (800 lines)\n```\n\n**Reduction:** 1500 lines ‚Üí 600 lines (60% smaller!)\n\n---\n\n## Best Practices\n\n1. **Keep Phases Focused:** One clear purpose per phase\n2. **Make Self-Contained:** Phase should work independently\n3. **Provide Context:** Explain what phase expects from previous steps\n4. **Include Examples:** Show real usage scenarios\n5. **Add Verification:** Clear checklist for completion\n6. **Handle Errors:** Include troubleshooting section\n7. **Link Related:** Reference related phases/docs\n8. **Update Regularly:** Keep content current with codebase changes\n\n---\n\n## Questions?\n\nIf you're:\n- **Creating a new instruction:** Check if shared phases apply\n- **Updating an instruction:** Consider extracting to shared phase\n- **Finding bugs:** Update shared phase to fix for all instructions\n- **Adding features:** Update shared phase for global improvements\n\n---\n\n## Version History\n\n- **v1.0** (2025-01-11): Initial shared phase architecture\n  - Created `documentation.md`\n  - Created `code-quality.md`\n  - Refactored all instructions to use shared phases\n",
        "plugins/venturo-planner/.claude-plugin/plugin.json": "{\n  \"name\": \"venturo-planner\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Database design and API contract planning tool - Generate ERD, DBML, and API contracts following audit standards\",\n  \"author\": {\n    \"name\": \"Venturo\",\n    \"email\": \"dev@venturo.id\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"database-design\",\n    \"erd\",\n    \"dbml\",\n    \"api-contract\",\n    \"planning\",\n    \"documentation\"\n  ]\n}\n",
        "plugins/venturo-planner/README.md": "# venturo-planner\n\nDatabase design and API contract planning tool for Venturo projects.\n\n## Overview\n\n`venturo-planner` is a Claude Code plugin that generates database design documentation (ERD, DBML) and API contracts (Markdown) following Venturo's database audit standards. This plugin serves as the planning/design phase before using `venturo-go` (backend) and `venturo-react` (frontend) plugins.\n\n**Integration Flow:**\n```\nventuro-planner ‚Üí ERD + DBML + PostgreSQL + API Contract ‚Üí venturo-go ‚Üí OpenAPI YAML ‚Üí venturo-react\n```\n\n## Commands\n\n### `/venturo-planner:new-project`\nInitialize a new project with complete database design and API planning.\n\n**Use for:** Starting a new project with multiple features\n\n**Creates:**\n- Complete project ERD (Mermaid)\n- Complete DBML schema\n- PostgreSQL migration files\n- API contracts for all features\n\n**Workflow:** 5-phase implementation\n\n---\n\n### `/venturo-planner:new-feature`\nDesign a single feature with database schema and API endpoints.\n\n**Use for:** Adding a new feature to existing project\n\n**Creates:**\n- Feature ERD (Mermaid)\n- Feature DBML schema\n- PostgreSQL migration file\n- Feature API contract\n\n**Workflow:** 4-phase implementation\n\n---\n\n### `/venturo-planner:new-crud`\nQuick CRUD entity design (simplified version of new-feature).\n\n**Use for:** Simple CRUD entities\n\n**Creates:**\n- Entity ERD and DBML\n- PostgreSQL migration file\n- Standard CRUD API contract\n\n**Workflow:** 3-phase implementation\n\n---\n\n## Database Standards\n\n> [!IMPORTANT]\n> **Read [DATABASE_STANDARDS.md](./DATABASE_STANDARDS.md) before using this plugin.**\n> \n> This plugin strictly enforces Venturo's database audit standards including:\n> - UUID primary keys (VARCHAR 40)\n> - 6 audit trail columns (created_at, updated_at, deleted_at, created_by, updated_by, deleted_by)\n> - Snake_case naming (no prefixes like m_, t_, tbl_)\n> - NO foreign key constraints (managed at application layer)\n> - Metadata table pattern for flexible data\n> - Polymorphic reference standards (reff_table, reff_id, reff_type)\n\n---\n\n## Output Files\n\nGenerated files are placed in:\n- `docs/database/erd/{feature_name}.mmd` - Mermaid ERD diagrams\n- `docs/database/dbml/{feature_name}.dbml` - DBML schema files\n- `docs/database/migrations/{timestamp}_{feature_name}.sql` - PostgreSQL migrations\n- `docs/api/contracts/{feature_name}.md` - API contract markdown\n\n---\n\n## Quick Start\n\n### 1. Create a new project\n```bash\n/venturo-planner:new-project\n```\n\nClaude will ask about:\n- Project name and description\n- List of features/modules\n- Authentication requirements\n- Common entities\n\n### 2. Create a feature\n```bash\n/venturo-planner:new-feature\n```\n\nClaude will ask about:\n- Feature name (snake_case)\n- Entities in the feature\n- Entity attributes and relationships\n- API endpoints needed\n\n### 3. Create a simple CRUD entity\n```bash\n/venturo-planner:new-crud\n```\n\nClaude will ask about:\n- Entity name\n- Attributes with types\n- Constraints\n\n---\n\n## Integration with Other Plugins\n\n### With venturo-go (Backend)\n\n1. Generate design with `/venturo-planner:new-feature`\n2. Use generated DBML and API contract as reference\n3. Run `/venturo-go:new-feature` to generate Go backend\n4. Compare generated code with planned design\n\n### With venturo-react (Frontend)\n\n1. Generate API contract with `/venturo-planner:new-feature`\n2. Backend team implements using `/venturo-go:new-feature`\n3. Backend generates OpenAPI YAML\n4. Frontend team uses `/venturo-react:new-feature` with OpenAPI YAML\n\n---\n\n## Key Features\n\n### ‚úÖ Database Audit Compliance\n- Automatic validation against audit standards\n- Rejects invalid table/column names\n- Enforces UUID primary keys\n- Ensures all audit trail columns\n\n### üìä Multiple Output Formats\n- **ERD**: Mermaid diagrams for visualization\n- **DBML**: Schema definition language\n- **PostgreSQL**: Ready-to-run migration files\n- **API Contracts**: Markdown documentation\n\n### üîó Polymorphic References\n- Standard pattern for flexible references\n- `reff_table` + `reff_id` + `reff_type`\n- Proper indexing for performance\n\n### üì¶ Metadata Table Pattern\n- Separate metadata tables instead of adding columns\n- JSONB for flexible data storage\n- Standard structure across all features\n\n---\n\n## Requirements\n\n- Claude Code with plugin support\n- Understanding of database design principles\n- Familiarity with Venturo's architecture patterns\n\n---\n\n## Version\n\n1.0.0\n\n---\n\n## License\n\nMIT License - see LICENSE file for details\n\n---\n\n**Developed by Venturo** - Professional development tools for full-stack engineering\n",
        "plugins/venturo-planner/commands/new-crud.md": "---\ndescription: Quick CRUD entity design (simplified version of new-feature)\n---\n\n# New CRUD Entity Creation\n\nYou will guide the user through creating a simple CRUD entity with ERD, DBML, PostgreSQL migration, and standard API contract.\n\n## Workflow\n\nThis command uses an **incremental 3-phase workflow** for quick CRUD entity creation.\n\n### Interactive Discovery\n\nAsk the user these questions first:\n\n1. **Entity name** (singular, snake_case, e.g., `product`, `category`, `tag`)\n2. **Attributes** with types:\n   - Attribute name\n   - Data type (VARCHAR, INT, DECIMAL, TEXT, TIMESTAMP, etc.)\n   - Length (for VARCHAR)\n   - Required or optional\n   - Unique constraint needed?\n   - Default value (if any)\n3. **Soft delete needed?** (yes/no, default: yes)\n4. **Common filters** (e.g., search by name, filter by status)\n\nPresent a complete plan and ask for confirmation before proceeding.\n\n### Implementation Phases\n\nAfter confirmation, execute these phases sequentially (read each phase file when needed):\n\n1. **Schema Generation** - `phases/new-crud/01-crud-schema.md` (ERD + DBML)\n2. **PostgreSQL Migration** - `phases/new-crud/02-crud-migrations.md`\n3. **API Contract** - `phases/new-crud/03-crud-api-contract.md` (Standard CRUD)\n\nAfter each phase:\n- Stop and report what was created\n- Ask user to review\n- Wait for \"continue\" before next phase\n\n## Key Implementation Rules\n\n**Database Standards:**\n- Read `DATABASE_STANDARDS.md` before starting\n- Apply all audit standards automatically\n- UUID primary key (VARCHAR 40)\n- 6 audit trail columns\n- Standard indexes (deleted_at, unique constraints)\n- NO foreign key constraints\n\n**Standard CRUD Endpoints:**\n```\nGET    /api/v1/{entity_plural}           - List with pagination\nGET    /api/v1/{entity_plural}/{id}      - Get by ID\nPOST   /api/v1/{entity_plural}           - Create\nPUT    /api/v1/{entity_plural}/{id}      - Update\nDELETE /api/v1/{entity_plural}/{id}      - Soft delete\n```\n\n**File Naming:**\n- ERD: `docs/database/erd/{entity_name}.mmd`\n- DBML: `docs/database/dbml/{entity_name}.dbml`\n- Migration: `docs/database/migrations/{timestamp}_add_{entity_name}.sql`\n- API: `docs/api/contracts/{entity_name}.md`\n\n## Example Usage\n\n```\nUser: /venturo-planner:new-crud\n\nClaude: I'll help you create a simple CRUD entity.\n\n        Let me ask some questions:\n\n        1. What is the entity name? (singular, snake_case)\n\nUser: tag\n\nClaude: 2. What attributes should this entity have?\n        Please provide: name, type, length (if VARCHAR), required/optional, unique\n\nUser: \n- name: VARCHAR(100), required, unique\n- color: VARCHAR(7), optional (hex color code)\n- description: TEXT, optional\n\nClaude: 3. Should this entity support soft delete?\n\nUser: yes\n\nClaude: 4. What filters should be available?\n\nUser: search by name\n\n[Presents plan, executes phases]\n```\n\n## Output Files\n\n- `docs/database/erd/{entity_name}.mmd` - Mermaid ERD\n- `docs/database/dbml/{entity_name}.dbml` - DBML schema\n- `docs/database/migrations/{timestamp}_add_{entity_name}.sql` - PostgreSQL migration\n- `docs/api/contracts/{entity_name}.md` - Standard CRUD API contract\n\n## Use Cases\n\nPerfect for:\n- Simple lookup tables (tags, categories, statuses)\n- Reference data (countries, currencies)\n- Configuration entities\n- Small entities without complex relationships\n\nFor complex entities with multiple relationships, use `/venturo-planner:new-feature` instead.\n",
        "plugins/venturo-planner/commands/new-feature.md": "---\ndescription: Design a single feature with database schema and API endpoints\n---\n\n# New Feature Creation\n\nYou will guide the user through creating a complete feature design with ERD, DBML, PostgreSQL migration, and API contract.\n\n## Workflow\n\nThis command uses an **incremental 4-phase workflow** to create feature documentation step-by-step.\n\n### Interactive Discovery\n\nAsk the user these questions first:\n\n1. **Feature name** (snake_case, e.g., `product_catalog`, `order_management`)\n2. **Entities in this feature** (e.g., products, categories, reviews)\n3. **For each entity, ask:**\n   - Attributes with data types\n   - Required vs optional fields\n   - Unique constraints\n   - Relationships to other entities\n4. **API endpoints needed** (CRUD, custom actions like approve, cancel, etc.)\n5. **Filter/search requirements** (search by name, filter by status, etc.)\n6. **Pagination needed?** (yes/no, default page size)\n7. **Permissions required** (who can create, read, update, delete)\n\nPresent a complete plan and ask for confirmation before proceeding.\n\n### Implementation Phases\n\nAfter confirmation, execute these phases sequentially (read each phase file when needed):\n\n1. **ERD Generation** - `phases/new-feature/01-feature-erd.md`\n2. **DBML Generation** - `phases/new-feature/02-feature-dbml.md`\n3. **PostgreSQL Migration** - `phases/new-feature/03-feature-migrations.md`\n4. **API Contract** - `phases/new-feature/04-feature-api-contract.md`\n\nAfter each phase:\n- Stop and report what was created\n- Ask user to review\n- Wait for \"continue\" before next phase\n\n## Key Implementation Rules\n\n**Database Standards:**\n- Read `DATABASE_STANDARDS.md` before starting\n- Validate table names (plural, snake_case, no prefixes)\n- Validate column names (snake_case, proper foreign key format)\n- Ensure all audit trail columns present\n- UUID primary keys (VARCHAR 40)\n- NO foreign key constraints (only indexes)\n\n**File Naming:**\n- ERD: `docs/database/erd/{feature_name}.mmd`\n- DBML: `docs/database/dbml/{feature_name}.dbml`\n- Migration: `docs/database/migrations/{timestamp}_{feature_name}.sql`\n- API: `docs/api/contracts/{feature_name}.md`\n\n## Example Usage\n\n```\nUser: /venturo-planner:new-feature\n\nClaude: I'll help you design a new feature with database schema and API endpoints.\n\n        Let me ask some questions first:\n\n        1. What is the name of the feature? (use snake_case)\n\nUser: product_catalog\n\nClaude: 2. What entities will this feature contain?\n\nUser: products, categories, product_images\n\nClaude: 3. Let's define the 'products' entity.\n        What attributes should it have?\n\nUser: name (required), description (optional), price (required), stock (required), category_id (required), is_active (required)\n\n[Continues through all questions, presents plan, executes phases]\n```\n\n## Output Files\n\n- `docs/database/erd/{feature_name}.mmd` - Mermaid ERD\n- `docs/database/dbml/{feature_name}.dbml` - DBML schema\n- `docs/database/migrations/{timestamp}_{feature_name}.sql` - PostgreSQL migration\n- `docs/api/contracts/{feature_name}.md` - API contract\n\n## Integration\n\nAfter completion:\n1. Use DBML and API contract as reference\n2. Run `/venturo-go:new-feature` to generate backend\n3. Backend generates OpenAPI YAML\n4. Run `/venturo-react:new-feature` with OpenAPI to generate frontend\n",
        "plugins/venturo-planner/commands/new-project.md": "---\ndescription: Initialize a new project with complete database design and API planning\n---\n\n# New Project Creation\n\nYou will guide the user through creating a complete project plan with database design (ERD, DBML, PostgreSQL) and API contracts for all features.\n\n## Workflow\n\nThis command uses an **incremental 5-phase workflow** to create project documentation step-by-step.\n\n### Interactive Discovery\n\nAsk the user these questions first:\n\n1. **Project name** (e.g., \"E-Commerce Platform\", \"Inventory Management System\")\n2. **Project description** (brief business purpose)\n3. **List of features/modules** (e.g., user_management, product_catalog, order_management, inventory)\n4. **Authentication requirements** (JWT, OAuth, session-based, etc.)\n5. **Common entities** (users, roles, permissions, etc.)\n6. **Database type** (PostgreSQL recommended)\n\nPresent a complete plan and ask for confirmation before proceeding.\n\n### Implementation Phases\n\nAfter confirmation, execute these phases sequentially (read each phase file when needed):\n\n1. **Project Planning** - `phases/new-project/01-project-planning.md`\n2. **ERD Generation** - `phases/new-project/02-project-erd.md`\n3. **DBML Generation** - `phases/new-project/03-project-dbml.md`\n4. **PostgreSQL Migrations** - `phases/new-project/04-project-migrations.md`\n5. **API Contracts** - `phases/new-project/05-project-api-contract.md`\n\nAfter each phase:\n- Stop and report what was created\n- Ask user to review\n- Wait for \"continue\" before next phase\n\n## Key Implementation Rules\n\n**Database Standards:**\n- Read `DATABASE_STANDARDS.md` before starting\n- Enforce all audit standards\n- UUID primary keys (VARCHAR 40)\n- 6 audit trail columns required\n- NO foreign key constraints\n- Proper indexing\n\n**File Naming:**\n- ERD: `docs/database/erd/project-overview.mmd`\n- DBML: `docs/database/dbml/project-schema.dbml`\n- Migrations: `docs/database/migrations/{timestamp}_initial_schema.sql`\n- API: `docs/api/contracts/project-api.md`\n\n## Example Usage\n\n```\nUser: /venturo-planner:new-project\n\nClaude: I'll help you create a new project plan with complete database design and API contracts.\n\n        Let me ask some questions first:\n\n        1. What is the name of your project?\n\nUser: E-Commerce Platform\n\nClaude: 2. What is the business purpose of this project?\n\nUser: Online marketplace for selling products with inventory management\n\nClaude: 3. What features/modules will this project have?\n        (e.g., user_management, product_catalog, order_management)\n\nUser: user_management, product_catalog, order_management, inventory, payments\n\n[Continues through all questions, presents plan, executes phases]\n```\n\n## Output Files\n\n- `docs/database/erd/project-overview.mmd` - Complete project ERD\n- `docs/database/dbml/project-schema.dbml` - Complete DBML schema\n- `docs/database/migrations/{timestamp}_initial_schema.sql` - PostgreSQL migration\n- `docs/api/contracts/project-api.md` - Complete API contract\n- Individual files per feature\n\n## Integration\n\nAfter completion, the generated documentation can be used with:\n- `venturo-go` - For backend implementation\n- `venturo-react` - For frontend implementation (via OpenAPI from backend)\n",
        "plugins/venturo-planner/commands/update-feature.md": "---\ndescription: Update an existing feature design with schema and API changes\n---\n\n# Update Feature\n\nYou will guide the user through updating an existing feature design, regenerating ERD, DBML, PostgreSQL migration, and API contract with changes.\n\n## Workflow\n\nThis command uses an **incremental 5-phase workflow** to update feature documentation.\n\n### Interactive Discovery\n\nAsk the user these questions first:\n\n1. **Feature name** to update (snake_case, e.g., `product_catalog`)\n2. **What needs to be updated?**\n   - Add new entities\n   - Modify existing entities (add/remove/change columns)\n   - Add/remove relationships\n   - Update API endpoints\n   - Change validation rules\n3. **For entity changes, ask:**\n   - Which entity to modify?\n   - What columns to add/remove/modify?\n   - New relationships?\n   - Index changes?\n4. **For API changes, ask:**\n   - New endpoints needed?\n   - Modified request/response schemas?\n   - New filters or parameters?\n   - Permission changes?\n\nPresent a complete change plan and ask for confirmation before proceeding.\n\n### Implementation Phases\n\nAfter confirmation, execute these phases sequentially (read each phase file when needed):\n\n1. **Load Existing Design** - `phases/update-feature/01-load-existing.md`\n2. **Update ERD** - `phases/update-feature/02-update-erd.md`\n3. **Update DBML** - `phases/update-feature/03-update-dbml.md`\n4. **Generate Migration** - `phases/update-feature/04-generate-migration.md`\n5. **Update API Contract** - `phases/update-feature/05-update-api-contract.md`\n\nAfter each phase:\n- Stop and report what was updated\n- Ask user to review\n- Wait for \"continue\" before next phase\n\n## Key Implementation Rules\n\n**Database Standards:**\n- Read `DATABASE_STANDARDS.md` before starting\n- Maintain all audit standards\n- UUID primary keys (VARCHAR 40)\n- 6 audit trail columns required\n- NO foreign key constraints\n- Proper indexing\n\n**Migration Strategy:**\n- Create **new migration file** (don't modify existing)\n- Use ALTER TABLE for schema changes\n- Add new indexes as needed\n- Include rollback instructions in comments\n\n**File Naming:**\n- ERD: `docs/database/erd/{feature_name}.mmd` (overwrite)\n- DBML: `docs/database/dbml/{feature_name}.dbml` (overwrite)\n- Migration: `docs/database/migrations/{timestamp}_update_{feature_name}.sql` (new file)\n- API: `docs/api/contracts/{feature_name}.md` (overwrite)\n\n## Example Usage\n\n```\nUser: /venturo-planner:update-feature\n\nClaude: I'll help you update an existing feature design.\n\n        1. Which feature do you want to update?\n\nUser: product_catalog\n\nClaude: 2. What changes do you need to make?\n        - Add new entities\n        - Modify existing entities\n        - Update API endpoints\n        - Other\n\nUser: Add a new entity \"product_reviews\" and add a \"rating\" column to products\n\nClaude: Let me confirm the changes:\n        \n        **New Entity:**\n        - product_reviews (id, product_id, user_id, rating, comment, ...)\n        \n        **Modified Entity:**\n        - products: add \"average_rating\" column (DECIMAL 3,2)\n        \n        **New Relationships:**\n        - products ||--o{ product_reviews\n        - users ||--o{ product_reviews\n        \n        Proceed with these changes?\n\n[Continues through all phases]\n```\n\n## Output Files\n\n- `docs/database/erd/{feature_name}.mmd` - **Updated** ERD\n- `docs/database/dbml/{feature_name}.dbml` - **Updated** DBML\n- `docs/database/migrations/{timestamp}_update_{feature_name}.sql` - **New** migration\n- `docs/api/contracts/{feature_name}.md` - **Updated** API contract\n\n## Important Notes\n\n### Migration Strategy\n\n**DO NOT modify existing migration files!** Always create a new migration:\n\n```sql\n-- Migration: 20250123170000_update_product_catalog.sql\n-- Description: Add product_reviews table and average_rating to products\n\n-- Add new table\nCREATE TABLE IF NOT EXISTS product_reviews (...);\n\n-- Modify existing table\nALTER TABLE products ADD COLUMN average_rating DECIMAL(3,2);\n\n-- Add new indexes\nCREATE INDEX idx_product_reviews_product_id ON product_reviews(product_id);\n\n-- Rollback instructions (commented)\n-- DROP TABLE product_reviews;\n-- ALTER TABLE products DROP COLUMN average_rating;\n```\n\n### Backward Compatibility\n\nConsider backward compatibility:\n- Adding columns: Use NULL or DEFAULT values\n- Removing columns: Mark as deprecated first\n- Changing types: May require data migration\n- API changes: Version endpoints if breaking changes\n\n### Team Communication\n\nAfter updating:\n- Notify backend team of schema changes\n- Notify frontend team of API changes\n- Update both teams if breaking changes\n- Frontend may need to re-verify against new OpenAPI\n\n## Integration\n\nAfter completion:\n1. Backend team: Create new migration with `/venturo-go:new-migration`\n2. Frontend team: Review API contract changes\n3. Both teams: Test integration with updated schemas\n4. Frontend: Re-verify against updated OpenAPI when backend completes\n",
        "plugins/venturo-react/.claude-plugin/plugin.json": "{\n  \"name\": \"venturo-react\",\n  \"version\": \"1.0.0\",\n  \"description\": \"React frontend development automation for Venturo skeleton - Guided workflows for features from OpenAPI specs\",\n  \"author\": {\n    \"name\": \"Venturo\",\n    \"email\": \"dev@venturo.id\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"react\",\n    \"frontend\",\n    \"typescript\",\n    \"mui\",\n    \"openapi\",\n    \"react-query\",\n    \"code-generation\"\n  ]\n}\n",
        "plugins/venturo-react/README.md": "# venturo-react\n\nReact frontend development automation for Venturo skeleton projects.\n\n## Overview\n\nProvides guided, interactive workflows for creating React frontend features from OpenAPI specifications. Each command implements a phase-based incremental workflow that breaks complex tasks into manageable steps.\n\n## Commands\n\n### Feature Development\n\n#### `/venturo-react:new-feature`\nCreate complete React feature from OpenAPI specification\n\n**Use for**: Creating frontend features that integrate with backend APIs documented in OpenAPI YAML\n\n**Creates**:\n- API Layer (TypeScript types, API functions, React Query hooks)\n- Feature Components (Table, Form, Filters, FilterDrawer)\n- Feature Hooks (Table logic, Form logic)\n- Page Integration (Main page, Routes, Sidebar)\n- Permissions & Constants\n\n**Workflow**: 5-phase incremental implementation\n1. API Layer\n2. Feature Components\n3. Feature Hooks\n4. Page Integration & Routes\n5. Permissions & Constants\n\n---\n\n## Architecture\n\nEach command follows a phase-based incremental workflow:\n\n### Phase Structure\n\n```\n1. Discovery - Parse OpenAPI spec, ask clarifying questions\n2. Planning - Present complete implementation plan\n3. Implementation - Execute systematic phases\n4. Validation - Stop after each phase for review\n5. Continuation - User says \"continue\" to proceed\n6. Quality Checks - Verify TypeScript, ESLint, formatting\n```\n\n### Benefits\n\n- **Type Safety**: TypeScript interfaces match backend exactly\n- **Context-efficient**: Break large tasks into smaller chunks\n- **Validation**: Review output after each phase\n- **Consistency**: Same patterns across all features\n- **Integration**: Seamless backend-frontend integration via OpenAPI\n\n---\n\n## Project Structure\n\n```\nsrc/\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ api/                 # API Layer\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {feature}/\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ type.ts              # TypeScript types from OpenAPI\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ {feature}Api.ts      # API endpoint functions\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ use{Feature}Api.ts   # React Query hooks\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.ts\n‚îÇ   ‚îú‚îÄ‚îÄ constants/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permission.ts    # Permission constants\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.ts        # Route constants\n‚îÇ   ‚îî‚îÄ‚îÄ routes/\n‚îÇ       ‚îú‚îÄ‚îÄ Router.tsx       # Route registration\n‚îÇ       ‚îî‚îÄ‚îÄ SideBarData.ts   # Sidebar menu items\n‚îú‚îÄ‚îÄ features/\n‚îÇ   ‚îî‚îÄ‚îÄ {feature}/\n‚îÇ       ‚îú‚îÄ‚îÄ components/      # Feature components\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ {Feature}Table.tsx\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ {Feature}Form.tsx\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ {Feature}Filters.tsx\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ {Feature}FilterDrawer.tsx\n‚îÇ       ‚îú‚îÄ‚îÄ hooks/           # Feature hooks\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ useTable{Feature}.ts\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ useForm{Feature}.ts\n‚îÇ       ‚îî‚îÄ‚îÄ {Feature}Page.tsx\n```\n\n---\n\n## Quick Start\n\n### Create a feature from OpenAPI spec\n```bash\n/venturo-react:new-feature\n```\n\nClaude will:\n1. Ask for the OpenAPI YAML file path\n2. Parse the spec to extract schemas, endpoints, and permissions\n3. Ask about feature naming preferences\n4. Present a complete implementation plan\n5. Guide you through 5 implementation phases\n\n**Example:**\n```\nUser: /venturo-react:new-feature\n\nClaude: I'll help you create a new frontend feature from an OpenAPI specification.\n\n        1. What is the path to the OpenAPI YAML file?\n\nUser: /path/to/openapi-customer_management.yaml\n\nClaude: [Analyzes spec and asks remaining questions]\n        [Presents implementation plan]\n\nUser: Yes, proceed\n\nClaude: [Executes Phase 1: API Layer]\n        ‚úÖ Phase 1 Complete\n\n        Created:\n        - src/app/api/customer/type.ts\n        - src/app/api/customer/customerApi.ts\n        - src/app/api/customer/useCustomerApi.ts\n        - src/app/api/customer/index.ts\n\n        Say \"continue\" to proceed to Phase 2.\n\nUser: continue\n\n[Claude continues through all 5 phases]\n```\n\n---\n\n## Backend-Frontend Integration\n\nThe plugin integrates seamlessly with the `venturo-go` plugin through OpenAPI specifications:\n\n```mermaid\nflowchart LR\n    Backend[Backend<br/>venturo-go<br/>6 Phases] --> OpenAPI[OpenAPI YAML<br/>docs/api/openapi-feature.yaml]\n    OpenAPI --> Frontend[Frontend<br/>venturo-react<br/>5 Phases]\n    Frontend --> Complete[‚úÖ Feature Ready]\n```\n\n**Integration Flow:**\n1. Backend team creates feature using `/venturo-go:new-feature`\n2. Backend generates OpenAPI YAML documentation\n3. Frontend team uses `/venturo-react:new-feature` with the OpenAPI YAML\n4. Frontend feature is generated with type-safe API integration\n\nFor detailed integration flow, see: `phases/shared/backend-frontend-integration-flow.md`\n\n---\n\n## File Naming Conventions\n\nAll files follow consistent naming patterns:\n\n- **API Types**: `type.ts` (in feature API folder)\n- **API Functions**: `{feature}Api.ts` (e.g., `customerApi.ts`)\n- **React Query Hooks**: `use{Feature}Api.ts` (e.g., `useCustomerApi.ts`)\n- **Components**: `{Feature}{Component}.tsx` (e.g., `CustomerTable.tsx`)\n- **Feature Hooks**: `use{Action}{Feature}.ts` (e.g., `useTableCustomer.ts`)\n- **Page**: `{Feature}Page.tsx` (e.g., `CustomerPage.tsx`)\n\n---\n\n## Key Implementation Patterns\n\n### TypeScript Types from OpenAPI\n```typescript\n// Generated from OpenAPI schemas\nexport interface Customer {\n  id: string;\n  name: string;\n  email: string;\n  status: 'active' | 'inactive';  // Enum from OpenAPI\n  created_at: string;\n}\n```\n\n### API Service Pattern\n```typescript\n// Uses centralized apiService\nimport { apiService } from '@/app/services/apiService';\n\nexport const customerApi = {\n  createCustomer: (data: CreateCustomerData) =>\n    apiService.post<ResponseApi<Customer>>('/core/v1/customers', data),\n};\n```\n\n### React Query Hooks Pattern\n```typescript\n// Query keys factory pattern\nexport const customerKeys = {\n  all: ['customers'] as const,\n  lists: () => [...customerKeys.all, 'list'] as const,\n  list: (params?: ListCustomersParams) => [...customerKeys.lists(), params] as const,\n};\n\nexport const useGetListCustomers = (params?: ListCustomersParams) => {\n  return useQuery({\n    queryKey: customerKeys.list(params),\n    queryFn: () => customerApi.listCustomers(params),\n  });\n};\n```\n\n### Permission Checks\n```typescript\n// Use permission constants and hooks\nimport { usePermission } from '@/shared/hooks';\nimport { PERMISSIONS } from '@/app/constants/permission';\n\nconst { hasPermission } = usePermission();\nconst canCreate = hasPermission(PERMISSIONS.CUSTOMER_CREATE);\n```\n\n---\n\n## Code Quality Standards\n\nAll commands ensure:\n\n- **Type Safety**: No TypeScript errors (`npm run type-check`)\n- **Linting**: No ESLint warnings (`npm run lint`)\n- **Formatting**: Prettier formatting (`npm run format`)\n- **Absolute Imports**: Use `@/` prefix for all imports\n- **Component Library**: Use venturo-ui instead of raw MUI\n\n---\n\n## Requirements\n\n- React 18+\n- TypeScript 5+\n- Venturo React Skeleton project\n- Claude Code with plugin support\n- OpenAPI 3.0+ specification from backend\n\n---\n\n## Examples\n\n### Example 1: Create Customer Management Feature\n```\n/venturo-react:new-feature\n\n> OpenAPI file: /backend/docs/api/openapi-customer_management.yaml\n> Feature name: customer\n> Base path: /core/v1/customers\n\n[Claude guides through 5 phases, creating complete feature with:\n- TypeScript types for Customer entity\n- API functions for CRUD operations\n- React Query hooks for data fetching\n- Table, Form, and Filter components\n- Complete page with permissions]\n```\n\n### Example 2: Create Product Catalog Feature\n```\n/venturo-react:new-feature\n\n> OpenAPI file: /backend/docs/api/openapi-product_catalog.yaml\n> Feature name: product\n> Components: Table, Form, Filters, FilterDrawer\n> Additional features: Export CSV, Bulk operations\n\n[Claude creates feature with all specified components]\n```\n\n---\n\n## Phase Details\n\n### Phase 1: API Layer (~5 minutes)\n- Creates TypeScript types from OpenAPI schemas\n- Generates API endpoint functions\n- Creates React Query hooks (useGet, usePost, usePut, useDelete)\n- Sets up query keys factory pattern\n\n### Phase 2: Feature Components (~7 minutes)\n- Creates Table component with pagination\n- Creates Form component (Create/Edit dialog)\n- Creates Filters component (search bar)\n- Creates FilterDrawer component (advanced filters)\n\n### Phase 3: Feature Hooks (~3 minutes)\n- Creates useTable{Feature} hook for table logic\n- Creates useForm{Feature} hook for form logic\n- Integrates API hooks with UI state\n\n### Phase 4: Page Integration & Routes (~3 minutes)\n- Creates main {Feature}Page component\n- Registers routes in Router.tsx\n- Adds sidebar menu items\n\n### Phase 5: Permissions & Constants (~2 minutes)\n- Adds permission constants\n- Adds route constants\n- Applies permission guards to page\n\n**Total Time**: 15-20 minutes per feature\n\n---\n\n## Support & Documentation\n\n- **Plugin Issues**: https://github.com/venturo-id/venturo-claude/issues\n- **Venturo Skeleton**: https://github.com/venturo-id/venturo-react-skeleton\n- **Integration Guide**: See `phases/shared/backend-frontend-integration-flow.md`\n\n---\n\n## License\n\nMIT License - see LICENSE file for details\n\n---\n\n## Version\n\n1.0.0\n\n---\n\n**Developed by Venturo** - Professional development tools for React frontend engineering\n",
        "plugins/venturo-react/commands/new-feature.md": "# New Feature Creation Instruction (Frontend)\n\n## How to Use This Instruction\n\n**Prompt Claude with:**\n```\nCreate new feature from OpenAPI, read new-feature-instruction.md\n```\n\n**Claude will:**\n1. Ask for the OpenAPI YAML file location\n2. Parse the OpenAPI spec to understand the API structure\n3. Guide you through planning the feature architecture\n4. Execute implementation using **incremental phases**\n5. Stop after each phase for your review before continuing\n\n---\n\n## Implementation Approach\n\nThis instruction uses an **incremental workflow** broken into **5 phases** to save context and allow validation at each step.\n\n**Incremental phase files are located at:** `.venturo/instructions/new-feature/`\n\n### Phase Overview\n\n1. **Phase 1: API Layer** (`01-api-layer.md`)\n   - Create TypeScript types from OpenAPI schemas\n   - Create API endpoint functions\n   - Create React Query hooks (useGetList, usePost, usePut, useDelete)\n\n2. **Phase 2: Feature Components** (`02-feature-components.md`)\n   - Create Table component with pagination\n   - Create Form component (Create/Edit dialog)\n   - Create Filters component (search bar)\n   - Create FilterDrawer component (advanced filters)\n\n3. **Phase 3: Feature Hooks** (`03-feature-hooks.md`)\n   - Create useTable{Feature} hook for table logic\n   - Create useForm{Feature} hook for form logic\n\n4. **Phase 4: Page Integration & Routes** (`04-page-and-routes.md`)\n   - Create main {Feature}Page component\n   - Register routes in Router.tsx\n   - Add sidebar menu items\n\n5. **Phase 5: Permissions & Constants** (`05-permissions-constants.md`)\n   - Add permission constants\n   - Add permission guards to page\n\n**See:** `.venturo/instructions/new-feature/README.md` for complete incremental workflow details.\n\n---\n\n## Interactive Discovery Process\n\nWhen this instruction is invoked, Claude MUST ask these questions:\n\n### Step 1: OpenAPI File Location\n**Question 1:** \"What is the path to the OpenAPI YAML file?\"\n- Expected path format: `/mnt/d/Dev/Venturo/RnD/venturo-skeleton-go/docs/api/openapi-{feature_name}.yaml`\n- Example: `/mnt/d/Dev/Venturo/RnD/venturo-skeleton-go/docs/api/openapi-customer_management.yaml`\n- Claude will read and parse this file to extract:\n  - Feature name (from file name)\n  - Entity schemas (from components/schemas)\n  - API endpoints (from paths)\n  - Request/Response types\n  - Query parameters\n  - Required permissions (from descriptions)\n\n### Step 2: Feature Naming\n**Question 2:** \"What should the feature name be in the frontend?\"\n- Backend: `customer_management` (snake_case)\n- Frontend options:\n  - PascalCase for components: `CustomerManagement` or `Customer`\n  - lowercase for files: `customer` or `customer-management`\n- Example: \"customer\" (recommended for simpler names)\n\n**Question 3:** \"What is the base API path for this feature?\"\n- Extract from OpenAPI `servers.url` or paths\n- Example: `/core/v1/customers`\n- This helps determine the endpoint structure\n\n### Step 3: Feature Analysis\n**Question 4:** \"Review the OpenAPI spec analysis - does this look correct?\"\nPresent a summary showing:\n- **Feature Name**: customer\n- **Entity Name**: Customer (singular)\n- **Base Path**: `/core/v1/customers`\n- **Endpoints Detected**:\n  - POST /customers (Create)\n  - GET /customers (List with pagination)\n  - GET /customers/{id} (Get by ID)\n  - PUT /customers/{id} (Update)\n  - DELETE /customers/{id} (Delete)\n- **Schemas Detected**:\n  - CreateCustomerRequest\n  - UpdateCustomerRequest\n  - CustomerResponse\n  - PaginatedCustomerResponse\n- **Filters Available**:\n  - search (string)\n  - status (enum: active, inactive)\n  - page, page_size (pagination)\n- **Permissions Required**:\n  - customer.create\n  - customer.read\n  - customer.update\n  - customer.delete\n\n### Step 4: Component Structure Planning\n**Question 5:** \"What components should we generate?\"\nBased on OpenAPI analysis, suggest:\n- [x] Table (if GET list endpoint exists)\n- [x] Form (if POST/PUT endpoints exist)\n- [x] Filters (if query parameters exist)\n- [x] FilterDrawer (if multiple filter options exist)\n- [x] Delete confirmation (if DELETE endpoint exists)\n\n### Step 5: Additional Features\n**Question 6:** \"Does this feature need any of these additional features?\"\n- [ ] Export functionality (CSV, Excel)\n- [ ] Bulk operations (Bulk delete, bulk update)\n- [ ] Custom actions (Activate, Deactivate, etc.)\n- [ ] File upload/download\n- [ ] Advanced filtering (date range, etc.)\n\n### Step 6: Confirmation\nPresent a complete implementation plan:\n\n```\nüìã Feature Implementation Plan\n\nFeature: Customer Management\nEntity: Customer\nBase Path: /core/v1/customers\n\nüóÇÔ∏è Files to Create:\n\nAPI Layer (src/app/api/customer/):\n  ‚úì type.ts - TypeScript interfaces\n  ‚úì customerApi.ts - API endpoint functions\n  ‚úì useCustomerApi.ts - React Query hooks\n  ‚úì index.ts - Exports\n\nFeature Components (src/features/customer/components/):\n  ‚úì CustomerTable.tsx - Data table with pagination\n  ‚úì CustomerForm.tsx - Create/Edit dialog\n  ‚úì CustomerFilters.tsx - Search bar and filter button\n  ‚úì CustomerFilterDrawer.tsx - Advanced filter drawer\n\nFeature Hooks (src/features/customer/hooks/):\n  ‚úì useTableCustomer.ts - Table state and operations\n  ‚úì useFormCustomer.ts - Form state and validation\n\nFeature Page (src/features/customer/):\n  ‚úì CustomerPage.tsx - Main page component\n\nRoutes & Constants:\n  ‚úì Update src/app/routes/Router.tsx\n  ‚úì Update src/app/routes/SideBarData.ts\n  ‚úì Update src/app/constants/permission.ts\n  ‚úì Update src/app/constants/router.ts\n\nEstimated Time: 15-20 minutes\nPhases: 5 incremental phases with validation checkpoints\n```\n\n**Ask:** \"Does this plan look correct? Should I proceed with implementation?\"\n\n---\n\n## Implementation Workflow (After Confirmation)\n\nAfter user confirms the plan, Claude will:\n\n1. **Read Phase 1 instruction:** `.venturo/instructions/new-feature/01-api-layer.md`\n2. **Execute Phase 1:** Create API types, endpoints, and React Query hooks\n3. **Stop and report:** Ask user to review the API layer\n4. **Wait for \"continue\"** command from user\n5. **Repeat for each phase** (2-5)\n\n### Example Execution Flow\n\n```\nUser: Create new feature from OpenAPI, read new-feature-instruction.md\n\nClaude: [Asks for OpenAPI file path]\n\nUser: /mnt/d/Dev/Venturo/RnD/venturo-skeleton-go/docs/api/openapi-customer_management.yaml\n\nClaude: [Reads and parses OpenAPI]\n        [Asks remaining discovery questions]\n        [Presents complete plan]\n\nUser: Yes, proceed\n\nClaude: [Reads .venturo/instructions/new-feature/01-api-layer.md]\n        [Executes Phase 1: Creates API layer]\n\n        ‚úÖ Phase 1 Complete: API Layer\n\n        Created:\n        - src/app/api/customer/type.ts\n        - src/app/api/customer/customerApi.ts\n        - src/app/api/customer/useCustomerApi.ts\n        - src/app/api/customer/index.ts\n\n        Please review the API layer code, especially:\n        - TypeScript types match OpenAPI schemas\n        - API endpoints use correct paths\n        - React Query hooks have proper cache invalidation\n\n        Say \"continue\" to proceed to Phase 2 (Feature Components).\n\nUser: continue\n\nClaude: [Reads .venturo/instructions/new-feature/02-feature-components.md]\n        [Executes Phase 2: Creates components]\n\n        ‚úÖ Phase 2 Complete: Feature Components\n\n        Created:\n        - src/features/customer/components/CustomerTable.tsx\n        - src/features/customer/components/CustomerForm.tsx\n        - src/features/customer/components/CustomerFilters.tsx\n        - src/features/customer/components/CustomerFilterDrawer.tsx\n\n        Please review the components.\n        Say \"continue\" to proceed to Phase 3 (Feature Hooks).\n\n[Process continues through all 5 phases]\n```\n\n---\n\n## Key Implementation Rules\n\n### Always Follow These Patterns:\n\n**1. TypeScript Types from OpenAPI:**\n```typescript\n// ‚úÖ Correct: Match OpenAPI schema exactly\nexport interface Customer {\n  id: string;\n  name: string;\n  email: string;\n  phone?: string;        // Optional in OpenAPI\n  address?: string;\n  status: 'active' | 'inactive';  // Enum from OpenAPI\n  created_at: string;\n  updated_at: string;\n}\n\n// ‚ùå Wrong: Using different field names or types\nexport interface Customer {\n  customerId: string;    // Should be 'id'\n  status: string;        // Should be enum\n}\n```\n\n**2. API Service Pattern:**\n```typescript\n// ‚úÖ Correct: Use apiService from @/app/services\nimport { apiService } from '@/app/services/apiService';\n\nexport const customerApi = {\n  createCustomer: (data: CreateCustomerData) =>\n    apiService.post<ResponseApi<Customer>>('/core/v1/customers', data),\n};\n\n// ‚ùå Wrong: Direct axios usage\nimport axios from 'axios';\naxios.post('/core/v1/customers', data);\n```\n\n**3. React Query Hooks Pattern:**\n```typescript\n// ‚úÖ Correct: Follow existing pattern with proper typing\nexport const customerKeys = {\n  all: ['customers'] as const,\n  lists: () => [...customerKeys.all, 'list'] as const,\n  list: (params?: ListCustomersParams) => [...customerKeys.lists(), params] as const,\n  details: () => [...customerKeys.all, 'detail'] as const,\n  detail: (id: string) => [...customerKeys.details(), id] as const,\n};\n\nexport const useGetListCustomers = (\n  params?: ListCustomersParams,\n  options?: Omit<UseQueryOptions<AxiosResponse<ResponseApiWithMeta<Customer[]>>, AxiosError>, 'queryKey' | 'queryFn'>\n) => {\n  return useQuery({\n    queryKey: customerKeys.list(params),\n    queryFn: () => customerApi.listCustomers(params),\n    ...options,\n  });\n};\n\n// ‚ùå Wrong: Not using query keys factory pattern\nexport const useGetListCustomers = () => {\n  return useQuery(['customers'], () => customerApi.listCustomers());\n};\n```\n\n**4. Component Imports:**\n```typescript\n// ‚úÖ Correct: Import from @/shared/components/venturo-ui\nimport { Box, Button, Typography, Card } from '@/shared/components/venturo-ui';\nimport { IconPlus } from '@tabler/icons-react';\n\n// ‚ùå Wrong: Importing from @mui/material directly\nimport { Box, Button } from '@mui/material';\n```\n\n**5. Permission Checks:**\n```typescript\n// ‚úÖ Correct: Use usePermission hook and constants\nimport { usePermission } from '@/shared/hooks';\nimport { PERMISSIONS } from '@/app/constants/permission';\n\nconst { hasPermission } = usePermission();\nconst canCreate = hasPermission(PERMISSIONS.CUSTOMER_CREATE);\n\n// ‚ùå Wrong: Hardcoded permission strings\nconst canCreate = hasPermission('customer.create');\n```\n\n**6. File Naming Conventions:**\n- API Types: `type.ts` (in feature API folder)\n- API Functions: `{feature}Api.ts` (e.g., `customerApi.ts`)\n- React Query Hooks: `use{Feature}Api.ts` (e.g., `useCustomerApi.ts`)\n- Components: `{Feature}{Component}.tsx` (e.g., `CustomerTable.tsx`)\n- Feature Hooks: `use{Action}{Feature}.ts` (e.g., `useTableCustomer.ts`)\n- Page: `{Feature}Page.tsx` (e.g., `CustomerPage.tsx`)\n\n---\n\n## Common Errors and Solutions\n\n### Error 1: API Response Type Mismatch\n**Solution:** Always use `ResponseApi<T>` or `ResponseApiWithMeta<T>`:\n```typescript\n// ‚úÖ Correct\napiService.get<ResponseApiWithMeta<Customer[]>>('/core/v1/customers')\n\n// ‚ùå Wrong\napiService.get<Customer[]>('/core/v1/customers')\n```\n\n### Error 2: Missing Cache Invalidation\n**Solution:** Always invalidate related queries in mutations:\n```typescript\n// ‚úÖ Correct\nexport const usePostCustomers = (options?: MutationOptions) => {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: customerApi.createCustomer,\n    onSuccess: (response, ...args) => {\n      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });\n      options?.onSuccess?.(response, ...args);\n    },\n    ...options,\n  });\n};\n```\n\n### Error 3: Not Using Absolute Imports\n**Solution:** Always use `@/` or `src/` prefix:\n```typescript\n// ‚úÖ Correct\nimport { apiService } from '@/app/services/apiService';\n\n// ‚ùå Wrong\nimport { apiService } from '../../../app/services/apiService';\n```\n\n### Error 4: Direct State Updates Instead of React Query\n**Solution:** Use React Query hooks, not local state for server data:\n```typescript\n// ‚úÖ Correct\nconst { data, isLoading } = useGetListCustomers(params);\nconst customers = data?.data?.data || [];\n\n// ‚ùå Wrong\nconst [customers, setCustomers] = useState([]);\nuseEffect(() => {\n  fetchCustomers().then(setCustomers);\n}, []);\n```\n\n### Error 5: Missing Permission Guards\n**Solution:** Always check permissions before rendering actions:\n```typescript\n// ‚úÖ Correct\n{canCreate && (\n  <Button onClick={handleCreate}>Add Customer</Button>\n)}\n\n// ‚ùå Wrong\n<Button onClick={handleCreate}>Add Customer</Button>\n```\n\n---\n\n## Verification Checklist\n\nAfter all phases complete, verify:\n\n### API Layer\n- [ ] Types match OpenAPI schemas exactly\n- [ ] All CRUD endpoints implemented\n- [ ] React Query hooks follow query keys pattern\n- [ ] Proper cache invalidation in mutations\n- [ ] Types exported from index.ts\n\n### Feature Components\n- [ ] Table component displays all required fields\n- [ ] Table has pagination with proper meta handling\n- [ ] Form component handles both create and edit modes\n- [ ] Form validation matches OpenAPI constraints\n- [ ] Filters component has search functionality\n- [ ] FilterDrawer has all filter options from OpenAPI\n\n### Feature Hooks\n- [ ] useTable hook manages pagination state\n- [ ] useTable hook manages filter state\n- [ ] useTable hook integrates delete operation\n- [ ] useForm hook manages form state and validation\n- [ ] useForm hook handles submit (create/update)\n\n### Page Integration\n- [ ] Main page component integrates all sub-components\n- [ ] Permission checks on all actions (create, edit, delete)\n- [ ] Error handling for API failures\n- [ ] Loading states shown appropriately\n- [ ] Route registered in Router.tsx\n- [ ] Sidebar menu item added (if applicable)\n\n### Constants & Permissions\n- [ ] Permission constants added to permission.ts\n- [ ] Route constants added to router.ts\n- [ ] Permission guards applied correctly\n\n### Code Quality\n- [ ] No TypeScript errors (`npm run type-check`)\n- [ ] No ESLint warnings (`npm run lint`)\n- [ ] Code follows Prettier formatting (`npm run format`)\n- [ ] All imports use absolute paths (@/)\n- [ ] Components use venturo-ui instead of raw MUI\n\n---\n\n## Testing the Feature\n\nAfter implementation, test the feature manually:\n\n1. **Start the development server:**\n   ```bash\n   npm run dev\n   ```\n\n2. **Navigate to the feature page:**\n   - Go to the route you registered (e.g., `/customers`)\n   - Verify the page loads without errors\n\n3. **Test CRUD Operations:**\n   - **Create**: Click \"Add\" button, fill form, submit\n   - **Read**: Verify table displays data correctly\n   - **Update**: Click edit on a row, modify, submit\n   - **Delete**: Click delete on a row, confirm deletion\n\n4. **Test Filters:**\n   - Use search bar to filter by text\n   - Open filter drawer and apply advanced filters\n   - Verify filters affect table results\n\n5. **Test Pagination:**\n   - Navigate between pages\n   - Change items per page\n   - Verify pagination meta is correct\n\n6. **Test Permissions:**\n   - Create a test user with limited permissions\n   - Verify action buttons respect permissions\n   - Verify unauthorized actions show appropriate messages\n\n7. **Test Error Handling:**\n   - Test with invalid data\n   - Test network failures (disconnect network)\n   - Verify error messages display appropriately\n\n---\n\n## Example Prompt Usage\n\n```\nUser: Create new feature from OpenAPI, read new-feature-instruction.md\n\nClaude: I'll help you create a new frontend feature from an OpenAPI specification.\n        Let me start by asking some questions:\n\n        1. What is the path to the OpenAPI YAML file?\n\nUser: /mnt/d/Dev/Venturo/RnD/venturo-skeleton-go/docs/api/openapi-customer_management.yaml\n\nClaude: [Reads and parses the OpenAPI file]\n\n        Great! I've analyzed the OpenAPI spec. Here's what I found:\n\n        Feature: customer_management\n        Entity: Customer\n        Base Path: /core/v1/customers\n\n        Endpoints:\n        - POST /customers (Create)\n        - GET /customers (List)\n        - GET /customers/{id} (Get by ID)\n        - PUT /customers/{id} (Update)\n        - DELETE /customers/{id} (Delete)\n\n        2. What should the feature name be in the frontend?\n           Suggestion: \"customer\" (lowercase for files, Customer for components)\n\nUser: customer\n\nClaude: [Continues with remaining questions, presents plan, executes phases]\n```\n",
        "plugins/venturo-react/phases/new-feature/README.md": "# Incremental Feature Implementation Workflow\n\nThis directory contains phase-by-phase instructions for implementing new frontend features from OpenAPI specifications.\n\n## Why Incremental Phases?\n\nBreaking feature implementation into phases provides several benefits:\n\n1. **Context Management**: Each phase is self-contained, reducing token usage\n2. **Validation Checkpoints**: Review and test after each phase before proceeding\n3. **Error Recovery**: Easy to identify and fix issues at each stage\n4. **Learning**: Clear understanding of the codebase structure and patterns\n5. **Flexibility**: Can pause and resume implementation at any phase\n\n## Phase Structure\n\nEach phase follows this structure:\n\n```markdown\n# Phase N: Phase Name\n\n## Objective\nClear statement of what this phase accomplishes\n\n## Prerequisites\nWhat must be completed before this phase\n\n## Implementation Steps\nStep-by-step instructions for this phase\n\n## Files to Create/Modify\nExact list of files with templates\n\n## Validation\nHow to verify this phase is complete\n\n## Common Issues\nKnown problems and solutions\n\n## Next Steps\nWhat comes after this phase\n```\n\n## Phase Workflow\n\n### Phase 1: API Layer\n**File**: `01-api-layer.md`\n\n**Creates**:\n- `src/app/api/{feature}/type.ts`\n- `src/app/api/{feature}/{feature}Api.ts`\n- `src/app/api/{feature}/use{Feature}Api.ts`\n- `src/app/api/{feature}/index.ts`\n\n**Validates**:\n- Types match OpenAPI schemas\n- API endpoints correctly configured\n- React Query hooks properly structured\n- Cache invalidation working\n\n**Time**: ~5 minutes\n\n---\n\n### Phase 2: Feature Components\n**File**: `02-feature-components.md`\n\n**Creates**:\n- `src/features/{feature}/components/{Feature}Table.tsx`\n- `src/features/{feature}/components/{Feature}Form.tsx`\n- `src/features/{feature}/components/{Feature}Filters.tsx`\n- `src/features/{feature}/components/{Feature}FilterDrawer.tsx`\n\n**Validates**:\n- Components render without errors\n- Table displays data correctly\n- Form handles create/edit modes\n- Filters apply correctly\n\n**Time**: ~7 minutes\n\n---\n\n### Phase 3: Feature Hooks\n**File**: `03-feature-hooks.md`\n\n**Creates**:\n- `src/features/{feature}/hooks/useTable{Feature}.ts`\n- `src/features/{feature}/hooks/useForm{Feature}.ts`\n\n**Validates**:\n- Hooks encapsulate business logic\n- State management working correctly\n- API integration functioning\n- Pagination and filtering operational\n\n**Time**: ~3 minutes\n\n---\n\n### Phase 4: Page Integration & Routes\n**File**: `04-page-and-routes.md`\n\n**Creates**:\n- `src/features/{feature}/{Feature}Page.tsx`\n\n**Modifies**:\n- `src/app/routes/Router.tsx`\n- `src/app/routes/SideBarData.ts`\n\n**Validates**:\n- Page integrates all components\n- Route navigation working\n- Sidebar menu displays correctly\n- Page accessible and functional\n\n**Time**: ~3 minutes\n\n---\n\n### Phase 5: Permissions & Constants\n**File**: `05-permissions-constants.md`\n\n**Modifies**:\n- `src/app/constants/permission.ts`\n- `src/app/constants/router.ts`\n\n**Updates**:\n- `src/features/{feature}/{Feature}Page.tsx` (add permission guards)\n\n**Validates**:\n- Permission constants defined\n- Route constants defined\n- Permission guards functioning\n- Unauthorized actions properly blocked\n\n**Time**: ~2 minutes\n\n---\n\n## Total Implementation Time\n\n**Estimated Total**: 15-20 minutes per feature\n\n## Example Session Flow\n\n```\nUser: Create new feature from OpenAPI, read new-feature-instruction.md\n\nClaude: [Discovery questions and planning]\n\nUser: Yes, proceed\n\nClaude: ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n        PHASE 1/5: API Layer\n        ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n        [Executes Phase 1 steps]\n\n        ‚úÖ Phase 1 Complete\n\n        Created Files:\n        - src/app/api/customer/type.ts (45 lines)\n        - src/app/api/customer/customerApi.ts (31 lines)\n        - src/app/api/customer/useCustomerApi.ts (107 lines)\n        - src/app/api/customer/index.ts (3 lines)\n\n        Validation Checklist:\n        ‚úì Types match OpenAPI schemas\n        ‚úì API endpoints correctly defined\n        ‚úì React Query hooks created\n        ‚úì Query keys factory pattern applied\n        ‚úì Cache invalidation configured\n\n        Next: Phase 2 - Feature Components\n\n        Say \"continue\" to proceed, or review the files first.\n\nUser: continue\n\nClaude: ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n        PHASE 2/5: Feature Components\n        ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n        [Executes Phase 2 steps]\n\n        ‚úÖ Phase 2 Complete\n\n        Created Files:\n        - src/features/customer/components/CustomerTable.tsx (95 lines)\n        - src/features/customer/components/CustomerForm.tsx (120 lines)\n        - src/features/customer/components/CustomerFilters.tsx (65 lines)\n        - src/features/customer/components/CustomerFilterDrawer.tsx (85 lines)\n\n        Validation Checklist:\n        ‚úì Table component renders\n        ‚úì Form component handles create/edit\n        ‚úì Filters component functional\n        ‚úì FilterDrawer component complete\n\n        Next: Phase 3 - Feature Hooks\n\n        Say \"continue\" to proceed.\n\n[Continue through phases 3-5...]\n\nClaude: ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n        PHASE 5/5: Permissions & Constants\n        ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n        [Executes Phase 5 steps]\n\n        ‚úÖ All Phases Complete! üéâ\n\n        Feature \"Customer\" has been successfully implemented.\n\n        Final Checklist:\n        ‚úì API Layer (4 files)\n        ‚úì Components (4 files)\n        ‚úì Hooks (2 files)\n        ‚úì Page & Routes (1 file + 2 updates)\n        ‚úì Permissions & Constants (2 updates)\n\n        Total Files: 11 created, 4 modified\n\n        Next Steps:\n        1. Start dev server: npm run dev\n        2. Navigate to /customers\n        3. Test CRUD operations\n        4. Test filters and pagination\n        5. Test permission guards\n\n        Would you like me to create a test checklist?\n```\n\n## Inter-Phase Dependencies\n\n```\nPhase 1 (API Layer)\n    ‚Üì\nPhase 2 (Components) ‚Üê Depends on types from Phase 1\n    ‚Üì\nPhase 3 (Hooks) ‚Üê Depends on API hooks from Phase 1\n    ‚Üì\nPhase 4 (Page) ‚Üê Depends on components & hooks from Phases 2 & 3\n    ‚Üì\nPhase 5 (Permissions) ‚Üê Updates page from Phase 4\n```\n\n## Resuming After Interruption\n\nIf implementation is interrupted, you can resume at any phase:\n\n```\nUser: Continue from Phase 3\n\nClaude: Resuming at Phase 3: Feature Hooks\n        Prerequisites verified:\n        ‚úì Phase 1 complete (API layer exists)\n        ‚úì Phase 2 complete (Components exist)\n\n        Proceeding with Phase 3...\n```\n\n## Phase File Naming Convention\n\n- **01-api-layer.md** - Phase 1\n- **02-feature-components.md** - Phase 2\n- **03-feature-hooks.md** - Phase 3\n- **04-page-and-routes.md** - Phase 4\n- **05-permissions-constants.md** - Phase 5\n\n## Best Practices\n\n### During Implementation\n\n1. **Read the phase file completely** before starting\n2. **Follow templates exactly** - they match existing patterns\n3. **Validate after each phase** - don't skip verification\n4. **Ask for clarification** if OpenAPI spec is ambiguous\n5. **Use existing features as reference** (user, role)\n\n### After Each Phase\n\n1. **Review generated code** for correctness\n2. **Check TypeScript errors**: `npm run type-check`\n3. **Check linting**: `npm run lint`\n4. **Test manually** if possible\n5. **Report any issues** before proceeding\n\n### Common Mistakes to Avoid\n\n1. **Skipping validation** - Always verify before proceeding\n2. **Not following patterns** - Use existing code as reference\n3. **Hardcoding values** - Use constants and enums\n4. **Ignoring TypeScript errors** - Fix them immediately\n5. **Not using absolute imports** - Always use `@/` prefix\n\n## File Structure Reference\n\n```\nsrc/\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {feature}/              ‚Üê Phase 1\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ type.ts\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ {feature}Api.ts\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ use{Feature}Api.ts\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.ts\n‚îÇ   ‚îú‚îÄ‚îÄ constants/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permission.ts          ‚Üê Phase 5 (update)\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.ts              ‚Üê Phase 5 (update)\n‚îÇ   ‚îî‚îÄ‚îÄ routes/\n‚îÇ       ‚îú‚îÄ‚îÄ Router.tsx             ‚Üê Phase 4 (update)\n‚îÇ       ‚îî‚îÄ‚îÄ SideBarData.ts         ‚Üê Phase 4 (update)\n‚îú‚îÄ‚îÄ features/\n‚îÇ   ‚îî‚îÄ‚îÄ {feature}/\n‚îÇ       ‚îú‚îÄ‚îÄ components/            ‚Üê Phase 2\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ {Feature}Table.tsx\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ {Feature}Form.tsx\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ {Feature}Filters.tsx\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ {Feature}FilterDrawer.tsx\n‚îÇ       ‚îú‚îÄ‚îÄ hooks/                 ‚Üê Phase 3\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ useTable{Feature}.ts\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ useForm{Feature}.ts\n‚îÇ       ‚îî‚îÄ‚îÄ {Feature}Page.tsx      ‚Üê Phase 4\n```\n\n## Troubleshooting\n\n### If a phase fails:\n\n1. **Review the error message** carefully\n2. **Check prerequisites** - ensure previous phases are complete\n3. **Verify file paths** - ensure they match the pattern\n4. **Check OpenAPI spec** - ensure it's valid and complete\n5. **Consult Common Issues** section in each phase file\n6. **Ask Claude** to review and fix the specific issue\n\n### If types don't match:\n\n1. **Re-read OpenAPI schemas** section\n2. **Check for optional fields** (marked with `?`)\n3. **Verify enum values** match exactly\n4. **Ensure date fields** use `string` type\n5. **Check nested objects** are properly defined\n\n### If API calls fail:\n\n1. **Verify endpoint paths** match OpenAPI spec\n2. **Check base URL** configuration\n3. **Ensure authentication** headers are included\n4. **Test backend API** separately (using Postman/curl)\n5. **Check CORS settings** if running locally\n\n## Additional Resources\n\n- **Main Instruction**: `../ new-feature-instruction.md`\n- **Existing Features**: `src/features/user/`, `src/features/role/`\n- **Code Conventions**: `.serena/memories/code_style_and_conventions.md`\n- **Codebase Structure**: `.serena/memories/codebase_structure.md`\n\n## Questions?\n\nIf you encounter issues not covered in this documentation:\n\n1. Review existing feature implementations (user, role)\n2. Check the main instruction file for common errors\n3. Ask Claude specific questions about the pattern\n4. Consult the backend OpenAPI spec for clarifications\n"
      },
      "plugins": [
        {
          "name": "venturo-e2e-web",
          "source": "./plugins/venturo-e2e-web",
          "description": "QA Engineer Automation plugin for Playwright E2E testing with auto-scenario generation and validation",
          "version": "1.0.4",
          "author": {
            "name": "Venturo",
            "email": "dev@venturo.id"
          },
          "homepage": "https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-e2e-web",
          "repository": "https://github.com/venturo-id/venturo-claude",
          "license": "MIT",
          "keywords": [
            "playwright",
            "e2e",
            "testing",
            "automation",
            "qa",
            "web-testing"
          ],
          "category": "testing",
          "tags": [
            "playwright",
            "e2e",
            "automation",
            "qa-engineer",
            "test-generation"
          ],
          "categories": [
            "automation",
            "e2e",
            "playwright",
            "qa",
            "qa-engineer",
            "test-generation",
            "testing",
            "web-testing"
          ],
          "install_commands": [
            "/plugin marketplace add venturo-id/venturo-claude",
            "/plugin install venturo-e2e-web@venturo-tools"
          ]
        },
        {
          "name": "venturo-go",
          "source": "./plugins/venturo-go",
          "description": "Go backend development automation for Venturo skeleton - Guided workflows for features, entities, endpoints, and adapters",
          "version": "1.0.0",
          "author": {
            "name": "Venturo",
            "email": "dev@venturo.id"
          },
          "homepage": "https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-go",
          "repository": "https://github.com/venturo-id/venturo-claude",
          "license": "MIT",
          "keywords": [
            "go",
            "golang",
            "backend",
            "gin",
            "clean-architecture",
            "crud",
            "code-generation"
          ],
          "category": "development",
          "tags": [
            "go",
            "backend",
            "clean-architecture",
            "feature-generation",
            "crud-automation"
          ],
          "categories": [
            "backend",
            "clean-architecture",
            "code-generation",
            "crud",
            "crud-automation",
            "development",
            "feature-generation",
            "gin",
            "go",
            "golang"
          ],
          "install_commands": [
            "/plugin marketplace add venturo-id/venturo-claude",
            "/plugin install venturo-go@venturo-tools"
          ]
        },
        {
          "name": "venturo-react",
          "source": "./plugins/venturo-react",
          "description": "React frontend development automation for Venturo skeleton - Guided workflows for features from OpenAPI specs",
          "version": "1.0.0",
          "author": {
            "name": "Venturo",
            "email": "dev@venturo.id"
          },
          "homepage": "https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-react",
          "repository": "https://github.com/venturo-id/venturo-claude",
          "license": "MIT",
          "keywords": [
            "react",
            "frontend",
            "typescript",
            "mui",
            "openapi",
            "react-query",
            "code-generation"
          ],
          "category": "development",
          "tags": [
            "react",
            "frontend",
            "typescript",
            "openapi-integration",
            "feature-generation"
          ],
          "categories": [
            "code-generation",
            "development",
            "feature-generation",
            "frontend",
            "mui",
            "openapi",
            "openapi-integration",
            "react",
            "react-query",
            "typescript"
          ],
          "install_commands": [
            "/plugin marketplace add venturo-id/venturo-claude",
            "/plugin install venturo-react@venturo-tools"
          ]
        },
        {
          "name": "venturo-planner",
          "source": "./plugins/venturo-planner",
          "description": "Database design and API contract planning - Generate ERD, DBML, PostgreSQL migrations, and API contracts following audit standards",
          "version": "1.0.0",
          "author": {
            "name": "Venturo",
            "email": "dev@venturo.id"
          },
          "homepage": "https://github.com/venturo-id/venturo-claude/tree/production/plugins/venturo-planner",
          "repository": "https://github.com/venturo-id/venturo-claude",
          "license": "MIT",
          "keywords": [
            "database-design",
            "erd",
            "dbml",
            "api-contract",
            "planning",
            "documentation",
            "mermaid",
            "postgresql"
          ],
          "category": "development",
          "tags": [
            "database-design",
            "planning",
            "documentation",
            "erd-generation",
            "api-contracts"
          ],
          "categories": [
            "api-contract",
            "api-contracts",
            "database-design",
            "dbml",
            "development",
            "documentation",
            "erd",
            "erd-generation",
            "mermaid",
            "planning",
            "postgresql"
          ],
          "install_commands": [
            "/plugin marketplace add venturo-id/venturo-claude",
            "/plugin install venturo-planner@venturo-tools"
          ]
        }
      ]
    }
  ]
}