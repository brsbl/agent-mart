{
  "author": {
    "id": "martinffx",
    "display_name": "Martinffx",
    "avatar_url": "https://avatars.githubusercontent.com/u/632594?v=4"
  },
  "marketplaces": [
    {
      "name": "atelier",
      "version": null,
      "description": "Personal development toolkit - spec-driven development, code quality, deep thinking, and TypeScript patterns",
      "repo_full_name": "martinffx/claude-code-atelier",
      "repo_url": "https://github.com/martinffx/claude-code-atelier",
      "repo_description": "A software development atelier for Claude Code - spec-driven development, code quality, deep thinking, and language specific patterns.",
      "signals": {
        "stars": 4,
        "forks": 0,
        "pushed_at": "2026-01-30T11:13:57Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"atelier\",\n  \"description\": \"Personal development toolkit - spec-driven development, code quality, deep thinking, and TypeScript patterns\",\n  \"owner\": {\n    \"name\": \"Martin Richards\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"spec\",\n      \"description\": \"Spec-Driven Development workflows with unified requirements and technical design\",\n      \"source\": \"./plugins/atelier-spec\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"code\",\n      \"description\": \"Code quality workflows including senior engineer reviews and conventional commits\",\n      \"source\": \"./plugins/atelier-code\",\n      \"category\": \"productivity\"\n    },\n    {\n      \"name\": \"oracle\",\n      \"description\": \"Deep thinking and sequential reasoning for complex debugging and problem-solving\",\n      \"source\": \"./plugins/atelier-oracle\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"typescript\",\n      \"description\": \"TypeScript ecosystem patterns for DynamoDB, Drizzle, Fastify, and API design\",\n      \"source\": \"./plugins/atelier-typescript\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"python\",\n      \"description\": \"Modern Python ecosystem patterns - architecture, monorepos, tooling, APIs, databases, and testing\",\n      \"source\": \"./plugins/atelier-python\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "README.md": "# Claude Code Atelier\n\n![Atelier - A collaborative workshop for software development](atelier.jpg)\n\n> An atelier is the private workshop or studio where a principal master and a number of assistants, students, and apprentices can work together producing fine art or visual art released under the master's name or supervision. \n> \n> [Wikipedia](https://en.wikipedia.org/wiki/Atelier)\n\nA software development atelier for Claude Code - spec-driven development, code quality, deep thinking, and TypeScript patterns.\n\n## Plugins\n\n### [spec](plugins/atelier-spec/README.md) - Spec-Driven Development\n\n- **Lightweight documentation over heavyweight planning** - Replace PRDs with minimal business context + detailed implementation specs\n- **Dependency-driven over sprint-driven** - Order tasks by technical requirements (Entity → Repository → Service → Router)\n- **AI-assisted implementation** - Structured specs enable AI agents to make informed technical decisions without constant prompting\n- **Prevention over debugging** - Spot issues in design, not production\n- **Enforced patterns** - Layered architecture with domain-driven design and layer boundary testing\n\n**What you get:** 9 commands + 5 skills + 3 specialized agents (architect, oracle, clerk)\n\n```bash\n# Greenfield workflow\n/spec:create <feature>   # Gather requirements\n/spec:design <feature>   # Generate technical design\n/spec:plan <feature>     # Create implementation plan with Beads epic\n/spec:work [feature]     # AI-driven implementation with stub→test→fix workflow\n\n# Brownfield workflow\n/spec:propose <feature> <change>  # Propose changes to existing feature\n/spec:design <feature> <change>   # Design changes\n/spec:plan <feature> <change>     # Plan implementation\n/spec:work [feature]              # Implement changes\n\n# Progress tracking\n/spec:status [feature]   # Track progress via Beads\n```\n\n[→ Full spec plugin documentation](plugins/atelier-spec/README.md)\n\n---\n\n### [code](plugins/atelier-code/README.md) - Code Quality\n\n**Code reviews and conventional commits** that follow your project standards.\n\n**What it does:**\n- Reviews code changes against architectural patterns and standards\n- Identifies security vulnerabilities, performance issues, maintainability concerns\n- Generates conventional commits with proper scope and detailed context\n- Enforces consistency across your codebase\n\n```bash\n/code:review             # Get structured, relevant perspective on changes\n/code:commit [message]   # Create well-crafted conventional commit\n```\n\n[→ Full code plugin documentation](plugins/atelier-code/README.md)\n\n---\n\n### [oracle](plugins/atelier-oracle/README.md) - Deep Thinking\n\n**Spicier, structured thinking and reasoning** for complex problems that need deeper analysis.\n\n**When to use:**\n- Complex bugs that require investigation across multiple layers\n- Architecture decisions with multiple trade-offs\n- Performance bottlenecks that need systematic profiling\n- Problems where the root cause isn't immediately obvious\n\n```bash\n/oracle:debug <error>    # Systematic debugging with bisect methodology\n```\n\nPlus 2 auto-invoked skills: `atelier-challenge` (critical thinking), `atelier-thinkdeep` (extended reasoning)\n\n[→ Full oracle plugin documentation](plugins/atelier-oracle/README.md)\n\n---\n\n### [typescript](plugins/atelier-typescript/README.md) - TypeScript Patterns\n\n**Production-ready patterns** for the TypeScript ecosystem - **automatically loaded** when relevant.\n\n**Coverage:**\n- **REST API design** - Resource naming, HTTP methods, error responses, pagination, versioning\n- **DynamoDB Toolbox v2** - Single-table design, entity definitions, GSI patterns, queries\n- **Drizzle ORM** - Type-safe SQL for PostgreSQL/MySQL/SQLite/Cloudflare D1/Durable Objects\n- **Fastify + TypeBox** - Route handlers, validation, type-safe APIs\n- **Build Tools** - Bun, tsgo, Vitest, Biome, Turborepo configurations\n\nNo commands needed - patterns are auto-invoked when working with these technologies.\n\n[→ Full typescript plugin documentation](plugins/atelier-typescript/README.md)\n\n---\n\n### [python](plugins/atelier-python/README.md) - Python Patterns\n\n**Modern Python ecosystem patterns** - architecture, monorepos, tooling, APIs, databases, and testing - **automatically loaded** when relevant.\n\n**Coverage:**\n- **Architecture** - Functional core/imperative shell, DDD patterns, layered architecture\n- **Monorepo** - uv workspaces, mise task orchestration, apps/packages pattern\n- **FastAPI** - REST APIs, Pydantic validation, dependency injection, OpenAPI\n- **Testing** - Stub-Driven TDD, layer boundary testing, pytest patterns\n- **SQLAlchemy** - ORM patterns, queries, async, upserts\n- **Temporal** - Workflow orchestration, activities, error handling\n- **Modern Python** - Type hints, generics, async/await, pattern matching\n- **Build Tools** - uv, mise, ruff, basedpyright, pytest configurations\n\nNo commands needed - patterns are auto-invoked when working with these technologies.\n\n[→ Full python plugin documentation](plugins/atelier-python/README.md)\n\n## Installation\n\n```bash\n# Add the marketplace\n/plugin marketplace add martinffx/claude-code-atelier\n\n# Install plugins\n/plugin install spec@atelier\n/plugin install code@atelier\n/plugin install oracle@atelier\n/plugin install typescript@atelier\n/plugin install python@atelier\n```\n\n## Development\n\nFor local development, use `--plugin-dir` to load plugins directly:\n\n```bash\n# Load entire marketplace\nclaude --plugin-dir ./claude-code-atelier\n\n# Load individual plugins\nclaude --plugin-dir ./claude-code-atelier/plugins/atelier-spec\nclaude --plugin-dir ./claude-code-atelier/plugins/atelier-code\nclaude --plugin-dir ./claude-code-atelier/plugins/atelier-oracle\nclaude --plugin-dir ./claude-code-atelier/plugins/atelier-typescript\nclaude --plugin-dir ./claude-code-atelier/plugins/atelier-python\n```\n\nRestart Claude Code after making changes to reload plugins.\n\n## License\n\nMIT Copyright (c) 2026 Martin Richards\n",
        "plugins/atelier-spec/README.md": "# Spec\n\nSpec-Driven Development combining [OpenSpec](https://openspec.dev/) living specifications, [AgentOS](https://buildermethods.com/agent-os/workflow) orchestrated delegation, and [Beads](https://github.com/steveyegge/beads) dependency-aware task tracking.\n\n## Three Innovations, One Workflow\n\n| Innovation | From | Contribution |\n|------------|------|--------------|\n| **Living Specs** | [OpenSpec](https://openspec.dev/) | Specs persist as docs, delta-based changes for brownfield |\n| **Orchestrated Delegation** | [AgentOS](https://buildermethods.com/agent-os/workflow) | Subagents (architect, oracle, clerk) with controlled context |\n| **Dependency Tracking** | [Beads](https://github.com/steveyegge/beads) | `bd ready` surfaces unblocked tasks, git-backed persistence |\n\n## Workflow\n\n### Greenfield\n\n```\n/spec:init → /spec:create → /spec:design → /spec:plan → /spec:work → /spec:complete\n```\n\n**Flow:**\n1. `/spec:init` - Initialize project structure\n2. `/spec:create <feature>` - Gather requirements (user story, acceptance criteria)\n3. `/spec:design <feature>` - Generate technical design (architecture, domain model, APIs)\n4. `/spec:plan <feature>` - Create implementation plan + Beads epic with tasks\n5. `/spec:work [feature]` - Implement next ready task (Stub → Test → Fix)\n6. `/spec:complete <feature> initial` - Mark feature complete\n\n### Brownfield\n\n```\n/spec:propose → /spec:design → /spec:plan → /spec:work → /spec:complete\n```\n\n**Flow:**\n1. `/spec:propose <feature> <change>` - Propose changes (motivation, affected components)\n2. `/spec:design <feature> <change>` - Generate technical design for changes\n3. `/spec:plan <feature> <change>` - Create implementation plan + Beads epic\n4. `/spec:work [feature]` - Implement next ready task\n5. `/spec:complete <feature> <change>` - Merge delta into main spec\n\n## Agents\n\nSpecialized subagents invoked via `@agent-name` during command execution.\n\n| Agent | Model | Responsibilities |\n|-------|-------|------------------|\n| **architect** | opus | Technical design, data modeling, API contracts, Beads task breakdown |\n| **oracle** | opus | Requirements interviews, strategic analysis, progress recommendations |\n| **clerk** | haiku | Fast context retrieval, file scaffolding, template application |\n\n## Skills vs Agents\n\nTwo complementary systems work together:\n\n| Concept | Invocation | Purpose | Examples |\n|---------|------------|---------|----------|\n| **Agents** | Explicit via `@agent-name` | Execute tasks during commands | @clerk, @oracle, @architect |\n| **Skills** | Auto-invoked by context | Provide domain knowledge | product, architect, testing |\n\n**Agents** are personas that perform actions during command execution (e.g., @oracle conducts interviews, @architect designs systems).\n\n**Skills** are contextual knowledge auto-loaded when relevant (e.g., architect skill provides DDD patterns when designing, testing skill provides TDD guidance when writing tests).\n\nSkills flow through the specification process:\n\n```\nProduct → Architect → Testing\n  │           │           │\n  ▼           ▼           ▼\nScope &    Data Model   Test\nStories    & APIs       Strategy\n```\n\n## Architecture Patterns\n\n### Functional Core / Effectful Edge\n\n```\nBounded Context\n┌────────────────────────────────────────────────────────────────┐\n│   Effectful Edge (IO)              Functional Core (Pure)      │\n│   ┌──────────────────┐             ┌──────────────────┐        │\n│   │ Router           │────────────▶│ Service          │        │\n│   │ Repository       │◀────────────│ Entity/Aggregate │        │\n│   │ Consumer/Producer│◀── Events ──│                  │        │\n│   └──────────────────┘             └──────────────────┘        │\n└────────────────────────────────────────────────────────────────┘\n```\n\n**Key Principle:** Business logic lives in the functional core (Service + Entity). IO operations live in the effectful edge. Core defines interfaces; edge implements them (dependency inversion).\n\n### DDD Patterns\n\n- **Bounded Context** - Module boundary containing all layers for a domain\n- **Aggregates** - Entity clusters with a root that enforces invariants\n- **Value Objects** - Immutable objects defined by attributes, not identity\n- **Domain Events** - Cross context boundaries via Producer/Consumer\n\n### Stub-Driven TDD\n\n```\nStub → Test → Implement → Refactor\n```\n\nTest at layer boundaries: Core (unit tests with stubs) vs Edge (integration tests).\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| /spec:init | Initialize repository for Spec-Driven Development |\n| /spec:create | Gather requirements for new feature |\n| /spec:design | Generate technical design |\n| /spec:plan | Create implementation plan + Beads epic |\n| /spec:propose | Propose changes to existing feature |\n| /spec:work | Implement next ready task |\n| /spec:complete | Merge changes into main spec |\n| /spec:status | Track progress via Beads |\n| /spec:sync | Update spec from code changes |\n\n## Skills\n\n| Skill | Description |\n|-------|-------------|\n| project-structure | Directory layout implementing 3-layer context model |\n| methodology | AgentOS context layers, orchestrated delegation, living specs |\n| product | Requirements discovery, scope definition, user story extraction |\n| architect | DDD and hexagonal architecture with functional core pattern |\n| testing | Stub-Driven TDD and layer boundary testing strategy |\n\n## Usage\n\n```bash\n# Initialize project for SDD (one-time setup)\n/spec:init\n\n# Greenfield: New feature workflow\n/spec:create <feature>           # Gather requirements\n/spec:design <feature>            # Generate technical design\n/spec:plan <feature>              # Create implementation plan\n/spec:work [feature]              # Implement tasks\n/spec:complete <feature> initial  # Mark complete\n\n# Brownfield: Change existing feature workflow\n/spec:propose <feature> <change>    # Propose changes\n/spec:design <feature> <change>     # Design changes\n/spec:plan <feature> <change>       # Plan implementation\n/spec:work [feature]                # Implement tasks\n/spec:complete <feature> <change>   # Merge delta\n\n# Track progress and identify blockers\n/spec:status [feature]\n\n# Update spec from code changes\n/spec:sync <feature>\n```\n\n## Prerequisites\n\n- Initialize project structure: Run `/spec:init` (sets up `docs/product/`, `docs/spec/`, `docs/standards/`)\n- Beads CLI for task tracking (optional): `npm install -g @beads/bd`\n\n## Installation\n\n```bash\n/plugin marketplace add martinffx/claude-code-atelier\n/plugin install spec@atelier\n```\n\n## License\n\nMIT\n",
        "plugins/atelier-code/README.md": "# Code\n\n**Get a senior engineer's perspective on every commit.**\n\nStop shipping slop to colleagues. Catch vulnerabilities, data exposure risks, and breaking changes before they reach production.\n\n## Why This Matters\n\nCode reviews are where quality happens. But most teams lack the bandwidth for thorough reviews, and solo developers miss the feedback loop entirely. This plugin fills that gap with:\n\n- **Architectural awareness** - Reviews against layered architecture patterns (Router, Service, Repository, Entity)\n- **Security-first thinking** - Catches vulnerabilities, data exposure risks, and breaking changes\n- **Standards enforcement** - Validates against your project's coding and architecture standards\n- **Actionable feedback** - Specific line references with concrete improvement suggestions\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| /code:review | Review code changes as senior engineer |\n| /code:commit | Create well-crafted conventional commits |\n\n## Workflow Examples\n\n### Code Review\n\n```bash\n# Make your changes, then request a review\n/code:review\n```\n\nThe review examines all staged and unstaged changes, producing a structured report:\n\n```\nSummary: Adding user authentication endpoints\n\nIssues by Severity:\n\n  CRITICAL:\n  - src/auth/handler.ts:45 - Password stored in plain text\n    Fix: Use bcrypt.hash() before storing\n\n  IMPORTANT:\n  - src/auth/service.ts:23 - Missing input validation\n    Fix: Add zod schema validation for email/password\n\n  MINOR:\n  - src/auth/types.ts:12 - Consider renaming 'data' to 'credentials'\n\nPositive Aspects:\n- Clean separation between handler and service layers\n- Good use of dependency injection\n\nOverall Assessment: REQUEST CHANGES\n```\n\n### Smart Commits\n\n```bash\n# Auto-generate message from changes\n/code:commit\n\n# Or provide your own message\n/code:commit \"add user authentication\"\n```\n\nThe commit command analyzes your changes and generates a conventional commit message:\n\n```\nSuggested: feat(auth): add user authentication endpoints\n\nCommitted! Ready for git push\n```\n\n## The Senior Engineer Perspective\n\nReviews focus on what matters most:\n\n**Critical Issues** - Security vulnerabilities, data loss risks, breaking changes. These block merging.\n\n**Important Issues** - Bugs, performance problems, pattern violations. These need attention.\n\n**Minor Issues** - Style, naming, edge cases. Suggestions for improvement.\n\n**Architecture Compliance** - Every review validates against the layered architecture pattern:\n\n```\nRouter -> Service -> Repository -> Entity -> Database\n```\n\nIf your project has standards files (`docs/standards/coding.md`, `docs/standards/architecture.md`), reviews validate against them automatically.\n\n## Quick Reference\n\n### Conventional Commit Types\n\n| Type | Use |\n|------|-----|\n| feat | New feature |\n| fix | Bug fix |\n| refactor | Code restructuring |\n| test | Test changes |\n| docs | Documentation |\n| chore | Build/config |\n\n### Review Severity Levels\n\n- **Critical**: Security, data loss, breaking changes\n- **Important**: Bugs, performance, patterns\n- **Minor**: Naming, style, edge cases\n\n## Shared Agents\n\nFor enhanced workflows, install the **spec** plugin which provides shared agents:\n\n| Agent | Purpose |\n|-------|---------|\n| atelier-architect | Technical design decisions |\n| atelier-oracle | Requirements and strategic thinking |\n| atelier-clerk | Fast utility tasks |\n\n## Installation\n\n```bash\n/plugin marketplace add martinffx/claude-code-atelier\n/plugin install code@atelier\n/plugin install spec@atelier  # Recommended: provides shared agents\n```\n\n## License\n\nMIT\n",
        "plugins/atelier-oracle/README.md": "# Oracle\n\n**Deep, sequential reasoning for problems that deserve more than quick answers.**\n\nSome problems need deeper analysis - complex bugs with hidden root causes, architectural decisions with cascading trade-offs, or situations where your initial intuition might be wrong. Oracle provides structured thinking workflows that help Claude reason through problems step by step, challenge assumptions, and explore alternatives systematically.\n\n## When to Use Oracle vs Regular Claude\n\n| Situation | Regular Claude | Oracle |\n|-----------|----------------|--------|\n| Simple bug with clear stack trace | Works well | Overkill |\n| Bug that spans multiple systems | Misses connections | Traces dependencies systematically |\n| Quick code review | Sufficient | Unnecessary |\n| Architecture decision with trade-offs | Surface-level analysis | Evaluates alternatives deeply |\n| \"Something feels wrong\" instinct | Tends to agree with you | Challenges assumptions explicitly |\n| Performance issue with unclear cause | Guesses at solutions | Investigates systematically |\n\n**Use Oracle when:**\n- The root cause is not obvious\n- You need to challenge your own assumptions\n- Multiple approaches exist with non-trivial trade-offs\n- The problem spans multiple layers or systems\n- Previous debugging attempts have failed\n\n## How It Works\n\nOracle uses the **MCP sequential-thinking server** to structure reasoning into explicit, numbered steps. This prevents jumping to conclusions and ensures thorough analysis.\n\n```\nThought 1: Understand the problem and context\n    |\nThought 2: Identify assumptions and question them\n    |\nThought 3: Gather evidence (what supports/contradicts?)\n    |\nThought 4: Generate alternatives\n    |\nThought 5: Evaluate trade-offs\n    |\nThought 6: Synthesize recommendation\n    |\n   ...\n(continues until satisfied)\n```\n\nThe sequential thinking process supports:\n- **Revision** - Go back and refine earlier thoughts\n- **Branching** - Explore alternative reasoning paths\n- **Extension** - Add more thoughts when needed\n- **Confidence tracking** - Assess certainty at each step\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/oracle:debug` | Systematic debugging with bisect methodology |\n\n## Skills (auto-invoked)\n\n| Skill | When It Activates | Purpose |\n|-------|-------------------|---------|\n| `atelier-challenge` | Questioning assumptions, validating decisions | Critical evaluation that resists automatic agreement |\n| `atelier-thinkdeep` | Complex decisions, architectural analysis | Extended exploration with alternative discovery |\n\n### Challenge vs ThinkDeep\n\n**Challenge** is for critical evaluation - \"Should we really do this?\"\n- Questions underlying assumptions\n- Tests validity of current approach\n- Identifies risks and blind spots\n- Prevents automatic agreement with flawed premises\n\n**ThinkDeep** is for comprehensive exploration - \"What are all our options?\"\n- Deep problem decomposition\n- Alternative approach discovery\n- Trade-off analysis across multiple dimensions\n- Synthesis into actionable recommendations\n\n## Usage\n\n### Debugging Complex Issues\n\n```bash\n# Systematic debugging with sequential reasoning\n/oracle:debug \"TypeError occurs intermittently in production but not locally\"\n\n# Use git bisect to find regression\n/oracle:debug \"Find when authentication started failing using git bisect\"\n\n# Investigate performance degradation\n/oracle:debug \"API response times increased 3x after last deploy\"\n```\n\n### Debug Strategies\n\nOracle selects the appropriate strategy based on the problem:\n\n| Strategy | When Used | Process |\n|----------|-----------|---------|\n| **Git Bisect** | \"When did this break?\" | Binary search through commit history |\n| **Code Bisect** | \"Which section causes this?\" | Comment out halves recursively |\n| **Data Bisect** | \"What input triggers this?\" | Test with data subsets |\n| **Systematic** | Complex multi-factor issues | Sequential hypothesis elimination |\n\n### Auto-Invoked Analysis\n\nThe skills activate automatically when Claude detects relevant situations:\n\n```\nUser: \"I'm not sure if microservices is the right choice here\"\n      -> atelier-challenge activates\n      -> Questions assumptions about scale, team size, complexity\n      -> Evaluates monolith vs microservices trade-offs\n\nUser: \"Help me think through our caching strategy\"\n      -> atelier-thinkdeep activates\n      -> Explores cache invalidation approaches\n      -> Analyzes consistency vs performance trade-offs\n      -> Recommends approach with rationale\n```\n\n## Example: Sequential Debugging in Action\n\n```\n/oracle:debug \"Users randomly logged out after deploy\"\n\nThought 1: Problem Classification\n- Symptom: Intermittent logout\n- Timing: Post-deploy\n- Pattern: Random users, not all\n- Hypothesis: Session handling or token validation change\n\nThought 2: Evidence Gathering\n- Review deploy diff for auth-related changes\n- Check session storage configuration\n- Examine token expiration logic\n- Look for race conditions in middleware\n\nThought 3: Bisect Strategy Selection\n- Clear \"before/after\" boundary (deploy)\n- Testable with specific user sessions\n- Selecting: Git bisect + systematic investigation\n\nThought 4: Root Cause Isolation\n- Found: JWT secret rotation without grace period\n- Old tokens invalid immediately\n- Race condition during rolling deploy\n\nThought 5: Solution Synthesis\n- Immediate: Add grace period for old secret\n- Prevention: Token rotation with overlap window\n- Monitoring: Alert on auth failure spike\n```\n\n## Shared Agents\n\nFor enhanced workflows, install the **spec** plugin which provides agents Oracle can leverage:\n\n| Agent | Purpose |\n|-------|---------|\n| `atelier-architect` | Technical design decisions |\n| `atelier-oracle` | Requirements and strategic thinking |\n| `atelier-clerk` | Fast utility tasks |\n\n## Installation\n\n```bash\n/plugin marketplace add martinffx/claude-code-atelier\n/plugin install oracle@atelier\n/plugin install spec@atelier  # Recommended: provides shared agents\n```\n\n## License\n\nMIT\n",
        "plugins/atelier-typescript/README.md": "# TypeScript Ecosystem Plugin\n\nJust-in-time expertise for TypeScript development. This plugin provides contextual knowledge that loads automatically when you work with specific technologies - no commands to remember, no manual activation required.\n\n## How It Works\n\nUnlike command-based plugins, atelier-typescript provides **skills** - contextual knowledge that Claude loads automatically based on what you're working on. When you discuss Drizzle schemas, the drizzle-orm patterns appear. When you design a REST endpoint, API conventions surface. The right expertise arrives at the right moment.\n\nThis is **ambient intelligence** for TypeScript development:\n\n- Working with DynamoDB entities? Single-table design patterns load automatically\n- Building Fastify routes? TypeBox validation patterns become available\n- Setting up a monorepo? Turborepo and Biome configurations are ready\n- Defining database schemas? Drizzle ORM best practices guide your work\n\n## Skills Reference\n\n| Skill | Auto-Invoked When You... | What You Get |\n|-------|--------------------------|--------------|\n| **dynamodb-toolbox** | Create DynamoDB entities, design key patterns, write queries, implement pagination, or work with single-table design | Entity definitions with linked keys, GSI strategies, query patterns, pagination tokens, transaction handling, type-safe repository patterns |\n| **drizzle-orm** | Define database schemas, write SQL queries, set up relations, run migrations, or work with PostgreSQL/MySQL/SQLite/D1/Durable Objects | Schema definitions, type inference patterns, relational queries, entity/repository patterns, database-specific guides for PostgreSQL, SQLite, and Cloudflare |\n| **fastify** | Create routes, handle HTTP requests, implement TypeBox validation, structure applications, or work with plugins | TypeBox schema patterns, RFC 7807 error responses, modular route registration, auth/permissions decorators, OpenAPI-ready route definitions |\n| **api-design** | Design endpoints, structure error responses, implement pagination, plan versioning, or architect REST APIs | Resource naming conventions, cursor-based pagination, HTTP status code guidance, idempotency patterns, filtering/sorting conventions |\n| **build-tools** | Set up package.json scripts, configure builds, run typechecking, set up tests, or orchestrate monorepo development | Bun package manager patterns, tsgo typechecking, Vitest configuration, Biome linting/formatting, Turborepo task orchestration, CI pipeline templates |\n\n## Example Triggers\n\n**Drizzle ORM** loads when you:\n- \"Define a users table with posts relation\"\n- \"Write a query to find users by email\"\n- \"Set up Drizzle migrations for PostgreSQL\"\n- \"Create a repository pattern for my entities\"\n\n**DynamoDB Toolbox** loads when you:\n- \"Design a single-table schema for a todo app\"\n- \"Create an entity with GSI for querying by status\"\n- \"Implement cursor-based pagination for DynamoDB\"\n- \"Handle conditional writes with optimistic locking\"\n\n**Fastify** loads when you:\n- \"Create a POST /users endpoint with validation\"\n- \"Set up TypeBox schemas for request/response\"\n- \"Implement role-based permissions on routes\"\n- \"Structure a Fastify application with plugins\"\n\n**API Design** loads when you:\n- \"What status code should I return for duplicate email?\"\n- \"How should I structure error responses?\"\n- \"Design pagination for a large dataset\"\n- \"Plan API versioning strategy\"\n\n**Build Tools** loads when you:\n- \"Set up Vitest for a new project\"\n- \"Configure Biome for linting and formatting\"\n- \"Create a Turborepo monorepo structure\"\n- \"Write CI pipeline for TypeScript project\"\n\n## What This Plugin Does NOT Do\n\nThis plugin provides **contextual knowledge**, not commands:\n\n- No `/slash:commands` to invoke\n- No code generation workflows\n- No project scaffolding\n\nIt enhances Claude's understanding when you work with these technologies. The patterns and conventions become part of how Claude reasons about your code.\n\n## Coverage by Technology\n\n### DynamoDB Toolbox\n- Single-table design methodology\n- Entity definitions with computed keys\n- GSI design and access patterns\n- Type-safe queries with pagination\n- Transaction patterns\n- Repository and entity layer patterns\n\n### Drizzle ORM\n- Schema definitions (PostgreSQL, MySQL, SQLite)\n- Type inference from schemas\n- Relational queries and joins\n- Entity and repository patterns\n- Cloudflare D1 and Durable Objects\n- Migration strategies\n\n### Fastify + TypeBox\n- Route definitions with full schemas\n- Request/response validation\n- RFC 7807 error handling\n- Plugin architecture\n- Auth and permissions\n- OpenAPI generation\n\n### REST API Design\n- Resource naming (plural nouns, hyphens)\n- HTTP methods and status codes\n- Cursor-based pagination\n- Filtering and sorting conventions\n- Versioning strategies\n- Idempotency patterns\n\n### Build Tools\n- Bun (package manager, task runner, bundler)\n- tsgo (fast typechecking)\n- Vitest (testing with coverage)\n- Biome (linting and formatting)\n- Turborepo (monorepo orchestration)\n- CI/CD pipeline patterns\n\n## Installation\n\n```bash\n# Add the Atelier marketplace\n/plugin marketplace add martinffx/claude-code-atelier\n\n# Install the TypeScript plugin\n/plugin install typescript@atelier\n```\n\nOr load directly during development:\n\n```bash\nclaude --plugin-dir ./claude-code-atelier/plugins/atelier-typescript\n```\n\n## License\n\nMIT\n",
        "plugins/atelier-python/README.md": "# atelier-python\n\nModern Python ecosystem patterns plugin for Claude Code Atelier - architecture, monorepos, tooling, APIs, databases, and testing.\n\n## Skills\n\n### 1. architecture\n**Auto-invoked for:** Python application architecture, functional core/imperative shell, DDD, data modeling\n\n**Covers:**\n- Functional core / imperative shell pattern\n- Domain-Driven Design (entities, value objects, aggregates, repositories)\n- dataclasses and Pydantic for domain models\n- Layered architecture (Router → Service → Repository → Entity → Database)\n\n**References:**\n- `functional-core.md` - Pure functions and effect isolation\n- `ddd.md` - Domain-Driven Design patterns in Python\n- `data-modeling.md` - dataclasses, Pydantic, attrs patterns\n\n### 2. monorepo\n**Auto-invoked for:** Python monorepos, uv workspaces, mise, apps/packages pattern\n\n**Covers:**\n- uv workspace configuration and commands\n- mise.toml for Python version + task orchestration\n- apps/ vs packages/ directory pattern\n- Namespace packages (PEP 420)\n- Docker builds for workspace packages\n\n**References:**\n- `docker.md` - Multi-stage Docker builds for workspaces\n- `namespace-packages.md` - PEP 420 namespace patterns\n\n### 3. build-tools\n**Auto-invoked for:** Python tooling, uv, mise, ruff, basedpyright, pytest\n\n**Covers:**\n- uv package management and commands\n- mise.toml configuration and tasks\n- ruff linting and formatting\n- basedpyright strict type checking\n- pyproject.toml configuration\n\n**References:**\n- `uv.md` - Advanced uv patterns (scripts, workspaces, pip interface)\n- `ruff.md` - Ruff rules and configuration\n- `basedpyright.md` - Strict typing configuration\n\n### 4. fastapi\n**Auto-invoked for:** FastAPI, REST APIs, Pydantic validation, OpenAPI\n\n**Covers:**\n- FastAPI app setup and routers\n- Pydantic models for request/response\n- Dependency injection patterns\n- Error responses (RFC 7807 Problem Details)\n- Pagination, filtering, sorting\n\n**References:**\n- `dependencies.md` - Dependency injection patterns\n- `middleware.md` - Middleware and lifecycle hooks\n- `validation.md` - Pydantic validation in FastAPI\n- `api-design.md` - REST patterns and OpenAPI\n\n### 5. testing\n**Auto-invoked for:** pytest, TDD, testing strategies\n\n**Covers:**\n- Stub-Driven TDD workflow (Stub → Test → Implement → Refactor)\n- Layer boundary testing patterns\n- What to test at each layer (Entity, Service, Repository, Router)\n- pytest fixtures and parametrized tests\n- Mocking with pytest-mock\n\n**References:**\n- `pytest.md` - pytest configuration, fixtures, markers\n- `boundaries.md` - Layer boundary testing patterns\n- `mocking.md` - Stubbing strategies with pytest-mock\n\n### 6. sqlalchemy\n**Auto-invoked for:** SQLAlchemy ORM, database access\n\n**Covers:**\n- SQLAlchemy 2.0 declarative models\n- Session management and transactions\n- Query patterns (select, join, aggregate)\n- Upsert patterns (on_conflict_do_update)\n- Async SQLAlchemy with asyncio\n\n**References:**\n- `models.md` - Declarative model patterns\n- `queries.md` - Query building and optimization\n- `async.md` - Async SQLAlchemy patterns\n\n### 7. temporal\n**Auto-invoked for:** Temporal workflow orchestration\n\n**Covers:**\n- Worker setup and configuration\n- Workflow definition patterns\n- Activity implementation\n- Error handling and retries\n- Signals and queries\n\n**References:**\n- `testing.md` - Temporal testing patterns\n- `patterns.md` - Common workflow patterns (saga, fan-out, etc.)\n\n### 8. modern-python\n**Auto-invoked for:** Modern Python features, typing, async/await\n\n**Covers:**\n- Type hints (PEP 484, 585, 604)\n- Generics with TypeVar and ParamSpec\n- Protocol for structural typing\n- Pattern matching (match/case)\n- Async/await patterns\n\n**References:**\n- `typing.md` - Type hints and generics deep dive\n- `async.md` - Async/await patterns and best practices\n- `pattern-matching.md` - Structural pattern matching\n\n## Installation\n\n### From Marketplace\n\n```bash\n# Add marketplace\n/plugin marketplace add martinffx/claude-code-atelier\n\n# Install plugin\n/plugin install python@atelier\n```\n\n### Local Development\n\n```bash\n# Load plugin\nclaude --plugin-dir ./claude-code-atelier/plugins/atelier-python\n```\n\n## Usage\n\nSkills are automatically loaded when relevant. Ask Claude questions about:\n\n- \"How do I structure a Python monorepo with uv?\"\n- \"Show me FastAPI dependency injection patterns\"\n- \"What's the best way to test a service layer?\"\n- \"How do I implement DDD patterns in Python?\"\n- \"Set up strict type checking with basedpyright\"\n- \"Create async SQLAlchemy queries\"\n- \"Build a Temporal workflow with saga pattern\"\n\nThe relevant skill will be auto-invoked with comprehensive patterns and best practices.\n\n## Philosophy\n\nThis plugin follows modern Python development principles:\n\n1. **Functional Core / Imperative Shell** - Separate pure business logic from side effects\n2. **Layered Architecture** - Router → Service → Repository → Entity → Database\n3. **Domain-Driven Design** - Rich domain models with business logic\n4. **Type Safety** - Strict type checking with basedpyright\n5. **Test at Boundaries** - Test component interfaces, not internals\n6. **Modern Tooling** - uv, mise, ruff, basedpyright for fast development\n\n## Related Plugins\n\n- **atelier-spec** - Spec-Driven Development workflows\n- **atelier-code** - Code quality and review workflows\n- **atelier-oracle** - Deep thinking for complex problems\n- **atelier-typescript** - TypeScript ecosystem patterns\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "spec",
          "description": "Spec-Driven Development workflows with unified requirements and technical design",
          "source": "./plugins/atelier-spec",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add martinffx/claude-code-atelier",
            "/plugin install spec@atelier"
          ]
        },
        {
          "name": "code",
          "description": "Code quality workflows including senior engineer reviews and conventional commits",
          "source": "./plugins/atelier-code",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add martinffx/claude-code-atelier",
            "/plugin install code@atelier"
          ]
        },
        {
          "name": "oracle",
          "description": "Deep thinking and sequential reasoning for complex debugging and problem-solving",
          "source": "./plugins/atelier-oracle",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add martinffx/claude-code-atelier",
            "/plugin install oracle@atelier"
          ]
        },
        {
          "name": "typescript",
          "description": "TypeScript ecosystem patterns for DynamoDB, Drizzle, Fastify, and API design",
          "source": "./plugins/atelier-typescript",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add martinffx/claude-code-atelier",
            "/plugin install typescript@atelier"
          ]
        },
        {
          "name": "python",
          "description": "Modern Python ecosystem patterns - architecture, monorepos, tooling, APIs, databases, and testing",
          "source": "./plugins/atelier-python",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add martinffx/claude-code-atelier",
            "/plugin install python@atelier"
          ]
        }
      ]
    }
  ]
}