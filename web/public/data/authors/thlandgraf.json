{
  "author": {
    "id": "thlandgraf",
    "display_name": "Thomas Landgraf",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/45935153?u=292fa6d98afb533d3f5654cb665e7d7ddf7ea15b&v=4",
    "url": "https://github.com/thlandgraf",
    "bio": "Hello, I'm Thomas Landgraf, an entrepreneur, IT manager, and passionate programming enthusiast. With a programming journey that began back in 1983 on a VIC20.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 12,
      "total_skills": 6,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "digital-dividend-marketplace",
      "version": null,
      "description": "Claude Code plugins by Digital Dividend",
      "owner_info": {
        "name": "Thomas Landgraf",
        "email": "tl@digital-dividend.de",
        "url": "https://github.com/digital-dividend"
      },
      "keywords": [],
      "repo_full_name": "thlandgraf/cc-marketplace",
      "repo_url": "https://github.com/thlandgraf/cc-marketplace",
      "repo_description": "Claude Code Plugins",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-25T14:11:04Z",
        "created_at": "2026-01-11T17:00:49Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1751
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/constitution",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/constitution/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/constitution/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 424
        },
        {
          "path": "plugins/constitution/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/constitution/commands/add.md",
          "type": "blob",
          "size": 3677
        },
        {
          "path": "plugins/constitution/commands/check.md",
          "type": "blob",
          "size": 3666
        },
        {
          "path": "plugins/constitution/commands/clarify.md",
          "type": "blob",
          "size": 3765
        },
        {
          "path": "plugins/constitution/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/constitution/skills/constitution-format",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/constitution/skills/constitution-format/SKILL.md",
          "type": "blob",
          "size": 3989
        },
        {
          "path": "plugins/speclan",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 671
        },
        {
          "path": "plugins/speclan/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/agents/feature-verifier.md",
          "type": "blob",
          "size": 10180
        },
        {
          "path": "plugins/speclan/agents/implementation-order.md",
          "type": "blob",
          "size": 8214
        },
        {
          "path": "plugins/speclan/agents/requirement-verifier.md",
          "type": "blob",
          "size": 4248
        },
        {
          "path": "plugins/speclan/agents/spec-converter.md",
          "type": "blob",
          "size": 2583
        },
        {
          "path": "plugins/speclan/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/commands/from-speckit.md",
          "type": "blob",
          "size": 4159
        },
        {
          "path": "plugins/speclan/commands/implement.md",
          "type": "blob",
          "size": 11797
        },
        {
          "path": "plugins/speclan/commands/status.md",
          "type": "blob",
          "size": 2823
        },
        {
          "path": "plugins/speclan/commands/sync-from-session.md",
          "type": "blob",
          "size": 13518
        },
        {
          "path": "plugins/speclan/commands/to-speckit.md",
          "type": "blob",
          "size": 3826
        },
        {
          "path": "plugins/speclan/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/hooks/hooks.json",
          "type": "blob",
          "size": 636
        },
        {
          "path": "plugins/speclan/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/hooks/scripts/detect-context.sh",
          "type": "blob",
          "size": 5400
        },
        {
          "path": "plugins/speclan/hooks/scripts/inject-skill.sh",
          "type": "blob",
          "size": 840
        },
        {
          "path": "plugins/speclan/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/skills/speclan-format",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/skills/speclan-format/SKILL.md",
          "type": "blob",
          "size": 19840
        },
        {
          "path": "plugins/speclan/skills/speclan-format/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/skills/speclan-format/references/entity-fields.md",
          "type": "blob",
          "size": 9338
        },
        {
          "path": "plugins/speclan/skills/speclan-format/references/writing-guide.md",
          "type": "blob",
          "size": 8864
        },
        {
          "path": "plugins/speclan/skills/speclan-id-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/skills/speclan-id-generator/SKILL.md",
          "type": "blob",
          "size": 6945
        },
        {
          "path": "plugins/speclan/skills/speclan-query",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/skills/speclan-query/SKILL.md",
          "type": "blob",
          "size": 6798
        },
        {
          "path": "plugins/speclan/skills/sync-from-session",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/speclan/skills/sync-from-session/SKILL.md",
          "type": "blob",
          "size": 14004
        },
        {
          "path": "plugins/todo",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/todo/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/todo/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 423
        },
        {
          "path": "plugins/todo/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/todo/commands/add.md",
          "type": "blob",
          "size": 4077
        },
        {
          "path": "plugins/todo/commands/done.md",
          "type": "blob",
          "size": 2336
        },
        {
          "path": "plugins/todo/commands/start.md",
          "type": "blob",
          "size": 2615
        },
        {
          "path": "plugins/todo/commands/update.md",
          "type": "blob",
          "size": 2958
        },
        {
          "path": "plugins/todo/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/todo/hooks/hooks.json",
          "type": "blob",
          "size": 633
        },
        {
          "path": "plugins/todo/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/todo/hooks/scripts/detect-context.sh",
          "type": "blob",
          "size": 1996
        },
        {
          "path": "plugins/todo/hooks/scripts/inject-skill.sh",
          "type": "blob",
          "size": 736
        },
        {
          "path": "plugins/todo/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/todo/skills/todo-format",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/todo/skills/todo-format/SKILL.md",
          "type": "blob",
          "size": 3120
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"digital-dividend-marketplace\",\n  \"owner\": {\n    \"name\": \"Thomas Landgraf\",\n    \"email\": \"tl@digital-dividend.de\",\n    \"url\": \"https://github.com/digital-dividend\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugins by Digital Dividend\",\n    \"version\": \"1.2.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"speclan\",\n      \"description\": \"Claude Code helper for SPECLAN - manage project specifications as interlinked markdown files\",\n      \"version\": \"0.3.0\",\n      \"source\": \"./plugins/speclan\",\n      \"author\": {\n        \"name\": \"Thomas Landgraf\",\n        \"email\": \"tl@digital-dividend.de\"\n      },\n      \"keywords\": [\n        \"speclan\",\n        \"specifications\",\n        \"requirements\",\n        \"documentation\"\n      ],\n      \"license\": \"MIT\"\n    },\n    {\n      \"name\": \"constitution\",\n      \"description\": \"Manage project constitution files - rules, best practices, patterns, and guardrails for LLM/coding agents\",\n      \"version\": \"0.1.0\",\n      \"source\": \"./plugins/constitution\",\n      \"author\": {\n        \"name\": \"Thomas Landgraf\",\n        \"email\": \"tl@digital-dividend.de\"\n      },\n      \"keywords\": [\n        \"constitution\",\n        \"rules\",\n        \"best-practices\",\n        \"guardrails\",\n        \"patterns\"\n      ],\n      \"license\": \"MIT\"\n    },\n    {\n      \"name\": \"todo\",\n      \"description\": \"Filesystem-based task management with git integration - track tasks through open/wip/done lifecycle\",\n      \"version\": \"0.1.0\",\n      \"source\": \"./plugins/todo\",\n      \"author\": {\n        \"name\": \"Thomas Landgraf\",\n        \"email\": \"tl@digital-dividend.de\"\n      },\n      \"keywords\": [\n        \"todo\",\n        \"tasks\",\n        \"project-management\",\n        \"git\",\n        \"workflow\"\n      ],\n      \"license\": \"MIT\"\n    }\n  ]\n}\n",
        "plugins/constitution/.claude-plugin/plugin.json": "{\n  \"name\": \"constitution\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Manage project constitution files - rules, best practices, patterns, and guardrails for LLM/coding agents\",\n  \"author\": {\n    \"name\": \"Thomas Landgraf\",\n    \"email\": \"tl@digital-dividend.de\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\"constitution\", \"rules\", \"best-practices\", \"guardrails\", \"patterns\"],\n  \"commands\": \"./commands/\",\n  \"skills\": \"./skills/\"\n}\n",
        "plugins/constitution/commands/add.md": "---\nname: constitution:add\ndescription: Add rules, best practices, or guidelines to the project constitution\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - WebSearch\n  - AskUserQuestion\n  - TodoWrite\nargument-hint: \"<topic or rule to add>\"\n---\n\n# Constitution Add Command\n\nAdd a new rule, best practice, or guideline to the project's constitution file based on the provided argument.\n\n## Workflow\n\n### 1. Locate Constitution File\n\nSearch for existing constitution file:\n```\nconstitution.md\ndoc/constitution.md\n```\n\nIf no constitution exists, you will create one at `constitution.md`.\n\n### 2. Analyze the Argument\n\nParse the ARGUMENT to determine:\n- Is it a **technology/framework** (Angular, React, NestJS, etc.)?\n- Is it a **practice/pattern** (use Prettier, prefer composition, etc.)?\n- Is it a **constraint/rule** (no any types, max file size, etc.)?\n\n### 3. Clarify Ambiguous Topics\n\nFor technologies and frameworks, use AskUserQuestion to clarify specifics:\n\n**Examples of clarifying questions:**\n\n| Topic | Clarifications Needed |\n|-------|----------------------|\n| Angular | Version (17+/16/legacy)? Template syntax (control flow/structural directives)? State (signals/rxjs/both)? |\n| React | Version (18+/17)? Hooks vs class? State management (zustand/redux/context)? |\n| Node.js | Runtime (node/bun/deno)? Module system (ESM/CJS)? |\n| TypeScript | Strictness level? Target version? |\n| CSS | Framework (Tailwind/CSS modules/styled-components)? |\n| Testing | Framework (Jest/Vitest/Playwright)? Coverage requirements? |\n| Database | ORM preference? Query style? |\n\n### 4. Research Best Practices\n\nFor technologies or exotic topics, use WebSearch to find current best practices:\n- Search for `\"<topic> best practices 2024\"` or `\"<topic> coding standards\"`\n- Focus on official documentation recommendations\n- Look for common anti-patterns to avoid\n\n### 5. Compose Constitution Entry\n\nWrite a token-efficient entry following these principles:\n\n**DO:**\n- Use imperative voice: \"Use X\" not \"You should use X\"\n- Be specific: \"Use `const` over `let`\" not \"Prefer immutability\"\n- Include rationale briefly: \"Use X (prevents Y)\"\n- Group related rules under headings\n\n**DON'T:**\n- Write prose or explanations\n- Include examples unless critical\n- Duplicate information\n- Use filler words\n\n**Entry format:**\n```markdown\n## <Category>\n\n- <Rule 1>\n- <Rule 2> (rationale)\n- Prefer X over Y\n- Avoid Z (causes issues with W)\n```\n\n### 6. Add to Constitution\n\nIf constitution exists:\n- Read current content\n- Identify appropriate section (or create new one)\n- Use Edit tool to add the new entry\n\nIf constitution doesn't exist:\n- Create new file with header and first entry:\n\n```markdown\n# Project Constitution\n\nGuidelines and rules for LLM/coding agents working in this project.\n\n## <Category>\n\n- <Your new rule(s)>\n```\n\n### 7. Report Result\n\nOutput what was added:\n```\nAdded to constitution.md:\n\n## <Section>\n- <Rule added>\n- <Rule added>\n\nConstitution size: ~X tokens (limit: 25,000)\n```\n\n## Token Efficiency Guidelines\n\nThe constitution must stay under 25,000 tokens. When adding entries:\n\n- Count approximate tokens (rough: 1 token ≈ 4 chars)\n- If approaching limit, suggest consolidating existing rules\n- Prioritize actionable rules over explanatory content\n\n## Examples\n\n**Input:** `Angular`\n**Action:** Ask about version, template flavor, state management, then research Angular best practices, add structured rules.\n\n**Input:** `\"always use async/await over .then()\"`\n**Action:** Add directly to Patterns section without clarification (rule is clear).\n\n**Input:** `htmx`\n**Action:** Research htmx best practices (exotic tech), ask about integration context, add rules.\n",
        "plugins/constitution/commands/check.md": "---\nname: constitution:check\ndescription: Check code or recent session work for constitution violations\nallowed-tools:\n  - Read\n  - Glob\n  - Grep\n  - Bash\n  - TodoWrite\nargument-hint: \"[file, path, or description - leave empty for session review]\"\n---\n\n# Constitution Check Command\n\nCheck for violations against the project's constitution rules.\n\n## Workflow\n\n### 1. Locate Constitution File\n\nSearch for constitution file:\n```\nconstitution.md\ndoc/constitution.md\n```\n\nIf no constitution exists, report:\n```\nNo constitution found. Use /constitution:add to create one.\n```\n\n### 2. Load Constitution Rules\n\nRead the constitution file and parse rules by section. Build a mental checklist of what to verify.\n\n### 3. Determine Check Target\n\n**If ARGUMENT provided:**\n- File path → Check that specific file\n- Directory path → Check all files in directory\n- Description → Interpret and find relevant files\n\n**If NO ARGUMENT (default):**\nCheck the work done in the current session:\n- Review files that were created or modified in this conversation\n- Look at recent edits made by Claude\n- Check any code that was written or changed\n\nUse this bash command to see recent git changes as a starting point:\n```bash\ngit diff HEAD~5 --name-only 2>/dev/null || git status --porcelain\n```\n\n### 4. Analyze Against Constitution\n\nFor each file/change being checked:\n\n1. Read the file content\n2. Compare against each relevant constitution rule\n3. Note any violations\n\n**Check categories:**\n- **Patterns:** Is the code following required patterns?\n- **Anti-patterns:** Is the code using forbidden approaches?\n- **Conventions:** Does naming/structure follow conventions?\n- **Technology rules:** Are framework-specific rules followed?\n- **Constraints:** Are limits/constraints respected?\n\n### 5. Report Violations\n\nOutput a structured violation report:\n\n```\n## Constitution Check Results\n\n**Target:** <what was checked>\n**Constitution:** <path to constitution file>\n\n### Violations Found\n\n| # | Rule | Location | Issue |\n|---|------|----------|-------|\n| 1 | <rule violated> | `file:line` | <what's wrong> |\n| 2 | <rule violated> | `file:line` | <what's wrong> |\n\n### Suggested Fixes\n\n1. **`file:line`** - <how to fix>\n2. **`file:line`** - <how to fix>\n\n### Summary\n\n- Files checked: X\n- Violations: Y\n- Severity: <low/medium/high>\n```\n\nIf no violations:\n```\n## Constitution Check Results\n\n**Target:** <what was checked>\n\nNo violations found. Code complies with constitution.\n```\n\n## Session Work Detection\n\nWhen checking current session work without an argument:\n\n1. **Recall conversation context** - What files were discussed, created, or edited?\n2. **Check modified files** - Use git or file timestamps to find recent changes\n3. **Focus on code changes** - Prioritize checking actual code over documentation\n\nCommon session work patterns:\n- New files created with Write tool\n- Existing files modified with Edit tool\n- Code generated in response to user requests\n\n## Violation Severity\n\nClassify violations by impact:\n\n| Severity | Description |\n|----------|-------------|\n| **High** | Security risks, breaking constraints, critical anti-patterns |\n| **Medium** | Pattern violations, convention breaks, suboptimal practices |\n| **Low** | Style issues, minor convention deviations |\n\n## Examples\n\n**Input:** (no argument)\n**Action:** Review files edited in current conversation, check against constitution rules, report any violations.\n\n**Input:** `src/components/`\n**Action:** Scan all files in src/components/, check each against constitution, report violations.\n\n**Input:** `the new auth module`\n**Action:** Find auth-related files, check implementation against constitution rules.\n",
        "plugins/constitution/commands/clarify.md": "---\nname: constitution:clarify\ndescription: Clarify or refine existing constitution rules based on user input\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - TodoWrite\nargument-hint: \"<clarification or refinement>\"\n---\n\n# Constitution Clarify Command\n\nInterpret user clarification to improve, refine, or correct existing constitution rules.\n\n## Workflow\n\n### 1. Locate Constitution File\n\nSearch for constitution file:\n```\nconstitution.md\ndoc/constitution.md\n```\n\nIf no constitution exists, report:\n```\nNo constitution found. Use /constitution:add to create one first.\n```\n\n### 2. Read Current Constitution\n\nLoad the entire constitution content to understand:\n- Current sections and structure\n- Existing rules that might relate to the clarification\n- Overall context and patterns\n\n### 3. Interpret the Clarification\n\nParse the ARGUMENT to understand the user's intent:\n\n| Intent Type | Example | Action |\n|-------------|---------|--------|\n| **Refinement** | \"prefer functional components over class components\" | Add specificity to existing React rules |\n| **Correction** | \"actually we use Vitest not Jest\" | Replace incorrect rule with correct one |\n| **Exception** | \"except in the legacy module\" | Add exception clause to existing rule |\n| **Emphasis** | \"this is critical for security\" | Elevate rule priority or add warning |\n| **Removal** | \"we no longer use Redux\" | Remove outdated rules |\n| **Merge** | \"combine the testing rules\" | Consolidate related rules |\n\n### 4. Find Related Rules\n\nSearch the constitution for rules that relate to the clarification:\n- Look for keyword matches\n- Check for thematic connections\n- Identify potential conflicts\n\n### 5. Apply the Clarification\n\nUse Edit tool to update the constitution:\n\n**For refinements/additions:**\n```markdown\n# Before\n- Use React hooks\n\n# After\n- Use React hooks\n- Prefer functional components over class components\n```\n\n**For corrections:**\n```markdown\n# Before\n- Use Jest for testing\n\n# After\n- Use Vitest for testing\n```\n\n**For exceptions:**\n```markdown\n# Before\n- Use TypeScript strict mode\n\n# After\n- Use TypeScript strict mode (except legacy/ directory)\n```\n\n**For removals:**\nSimply delete the outdated rule(s).\n\n### 6. Show Changes\n\nOutput what changed:\n\n```\n## Constitution Updated\n\n**Clarification applied:** <user's clarification>\n\n### Changes Made\n\n**Section:** <section name>\n\n```diff\n- <old rule>\n+ <new rule>\n```\n\nOr for additions:\n```diff\n+ <new rule added>\n```\n\n**Reason:** <brief explanation of why this change was made>\n\n---\n\nConstitution size: ~X tokens (limit: 25,000)\n```\n\n## Handling Ambiguous Clarifications\n\nIf the clarification is unclear or could apply multiple ways:\n\n1. Show the possible interpretations\n2. Ask which interpretation is correct\n3. Apply once confirmed\n\nExample:\n```\nThe clarification \"prefer composition\" could mean:\n\n1. Add to React section: \"Prefer composition over inheritance for components\"\n2. Add to General section: \"Prefer composition over inheritance in all code\"\n3. Add to Testing section: \"Prefer composition for test utilities\"\n\nWhich interpretation is correct?\n```\n\n## Token Budget Awareness\n\nWhen clarifying:\n- Check if changes increase token count significantly\n- If approaching 25,000 tokens, suggest consolidation\n- Prefer making rules more concise when possible\n\n## Examples\n\n**Input:** `\"we use tabs not spaces\"`\n**Action:** Find indentation rule, update to specify tabs.\n\n**Input:** `\"ignore the API layer for now\"`\n**Action:** Add exception to relevant rules excluding api/ directory.\n\n**Input:** `\"TypeScript 5.3 specifically\"`\n**Action:** Update TypeScript rules to specify version 5.3.\n\n**Input:** `\"merge all the naming conventions into one section\"`\n**Action:** Consolidate scattered naming rules into unified section.\n",
        "plugins/constitution/skills/constitution-format/SKILL.md": "---\nname: Constitution Format\ndescription: >-\n  Knowledge about writing effective project constitution files for LLM/coding agents.\n  Use this skill when creating, editing, or reviewing constitution.md files.\nversion: 0.1.0\n---\n\n# Constitution Format Knowledge\n\n## Purpose\n\nA constitution file defines rules, best practices, patterns, and guardrails for LLM and coding agents working in a project. Unlike human documentation, constitutions are optimized for token efficiency and machine parsing.\n\n## File Location\n\nStandard locations (checked in order):\n1. `constitution.md` (project root)\n2. `doc/constitution.md`\n\n## Token Budget\n\n**Hard limit: 25,000 tokens**\n\nApproximate conversion: 1 token ≈ 4 characters\n\nMonitor size when adding rules. A well-written constitution for a medium project typically uses 5,000-15,000 tokens.\n\n## Structure\n\n```markdown\n# Project Constitution\n\nBrief one-line project description.\n\n## <Category 1>\n\n- Rule 1\n- Rule 2 (rationale)\n\n## <Category 2>\n\n- Rule 3\n- Prefer X over Y\n- Avoid Z\n```\n\n## Common Categories\n\n| Category | Contents |\n|----------|----------|\n| **Stack** | Languages, frameworks, versions |\n| **Patterns** | Required architectural patterns |\n| **Anti-patterns** | What to avoid |\n| **Conventions** | Naming, structure, organization |\n| **Testing** | Testing requirements and approaches |\n| **Security** | Security requirements |\n| **Performance** | Performance constraints |\n| **Dependencies** | Dependency rules |\n\n## Writing Effective Rules\n\n### DO\n\n- **Imperative voice:** \"Use X\" not \"You should use X\"\n- **Be specific:** \"Use `const` by default\" not \"Prefer immutability\"\n- **Include brief rationale:** \"Avoid any (breaks type safety)\"\n- **Quantify when possible:** \"Max 300 lines per file\"\n- **State the positive:** \"Use async/await\" not \"Don't use callbacks\"\n\n### DON'T\n\n- Write explanatory prose\n- Include code examples (unless critical)\n- Duplicate information\n- Use filler words (very, really, always try to)\n- Over-qualify (usually, in most cases, generally)\n\n## Rule Formats\n\n**Simple rule:**\n```markdown\n- Use TypeScript strict mode\n```\n\n**Rule with rationale:**\n```markdown\n- Use TypeScript strict mode (catches null errors early)\n```\n\n**Preference:**\n```markdown\n- Prefer composition over inheritance\n```\n\n**Prohibition:**\n```markdown\n- Avoid `any` type\n```\n\n**Conditional:**\n```markdown\n- Use server components by default; client components only for interactivity\n```\n\n**Exception:**\n```markdown\n- Use strict mode (except legacy/ directory)\n```\n\n**Quantified:**\n```markdown\n- Max 300 lines per file\n- Min 80% test coverage for business logic\n```\n\n## Example Constitution\n\n```markdown\n# Project Constitution\n\nTypeScript monorepo for e-commerce platform.\n\n## Stack\n\n- TypeScript 5.3+ strict mode\n- React 18 with Server Components\n- Next.js 14 App Router\n- PostgreSQL with Drizzle ORM\n- Vitest for testing\n\n## Patterns\n\n- Feature-based directory structure\n- Repository pattern for data access\n- Use server components by default\n- Client components only for interactivity\n- Collocate tests with source files\n\n## Anti-patterns\n\n- Avoid `any` type (use `unknown` if needed)\n- No barrel exports in feature modules\n- No circular dependencies\n- Avoid prop drilling beyond 2 levels\n\n## Conventions\n\n- camelCase for functions/variables\n- PascalCase for components/types\n- kebab-case for files and directories\n- Prefix interfaces with I (IUser, IProduct)\n- Suffix types with Type only if needed for clarity\n\n## Testing\n\n- Unit tests for business logic (min 80% coverage)\n- Integration tests for API routes\n- E2E tests for critical user flows\n- Use Testing Library, avoid implementation details\n\n## Security\n\n- Validate all user input at API boundary\n- Use parameterized queries only\n- No secrets in code or logs\n- HTTPS only, secure cookies\n```\n\n## Maintenance\n\n- Review constitution when adding major features\n- Remove rules for deprecated technologies\n- Consolidate overlapping rules periodically\n- Keep total under 25,000 tokens\n",
        "plugins/speclan/.claude-plugin/plugin.json": "{\n  \"name\": \"speclan\",\n  \"version\": \"0.8.1\",\n  \"description\": \"Claude Code helper for SPECLAN - manage project specifications as interlinked markdown files\",\n  \"author\": {\n    \"name\": \"Thomas Landgraf\",\n    \"email\": \"tl@digital-dividend.de\"\n  },\n  \"repository\": \"https://github.com/digital-dividend/speclan-plugin\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"speclan\",\n    \"specifications\",\n    \"requirements\",\n    \"documentation\",\n    \"vscode\"\n  ],\n  \"commands\": \"./commands/\",\n  \"agents\": [\n    \"./agents/feature-verifier.md\",\n    \"./agents/implementation-order.md\",\n    \"./agents/requirement-verifier.md\",\n    \"./agents/spec-converter.md\"\n  ],\n  \"skills\": \"./skills/\"\n}\n",
        "plugins/speclan/agents/feature-verifier.md": "---\nname: feature-verifier\ncolor: green\ndescription: |\n  Use this agent when:\n  <example>User wants to verify features are implemented correctly</example>\n  <example>User asks to check implementation against feature specs</example>\n  <example>Verifying features with status \"under-test\" or \"in-development\"</example>\n  <example>User wants a verification report for a set of features</example>\n  <example>Deep verification of feature implementation against SPECLAN specs</example>\ntools:\n  - Read\n  - Glob\n  - Grep\n  - Bash\n  - TodoWrite\n---\n\n# Feature Verifier Agent\n\nDeeply verify that SPECLAN features are correctly implemented in the codebase.\n\n## Purpose\n\nGiven features (by ID or selection criteria), perform comprehensive verification against the implementation and generate detailed reports.\n\n**IMPORTANT: Do NOT discover features yourself unless given selection criteria. Verify only what is requested.**\n\n## Input Format\n\nYou will receive input in one of these formats:\n\n**Specific features:**\n```\nVerify features:\n- F-1049-{slug}\n- F-200-{slug}\n\nSPECLAN directory: speclan/\n```\n\n**Selection criteria:**\n```\nVerify features matching:\n  status: under-test\n\nSPECLAN directory: speclan/\n```\n\n## Verification Process - ULTRATHINK for thorough analysis\n\n### Phase 1: Build Verification Todo List\n\n**MUST use TodoWrite tool to track progress.**\n\n1. **If specific features provided:** Add each to todo list\n2. **If selection criteria provided:** Query SPECLAN directory:\n   ```bash\n   grep -r \"^status: under-test\" speclan/features/ -l\n   ```\n\nCreate todo items:\n```\n- Verify F-1049: Pet Management (pending)\n- Verify F-200: Pet Health (pending)\n```\n\n### Phase 2: Deep Feature Understanding (per feature)\n\n**Mark todo as in_progress before starting each feature.**\n\n#### 2.1 Build Feature Context Tree\n\nRead the feature hierarchy from root to leaf:\n\n```\nGoal (G-XXX)\n  └── Parent Feature (if any)\n        └── THIS FEATURE (F-XXXX)\n              ├── Requirements (R-XXXX)\n              │     ├── Scenarios (S-XXXX)\n              │     └── Acceptance Criteria (AC-XXXX)\n              └── Sub-features (if any)\n```\n\n**Steps:**\n\n1. **Read the feature spec:**\n   ```bash\n   cat speclan/features/F-XXXX-*/F-XXXX-*.md\n   ```\n\n2. **Traverse UP to root:**\n   - Check for `parent:` in YAML → read parent feature\n   - Check for `goals:` in YAML → read goal specs\n   - Continue until no more parents\n\n3. **Traverse DOWN to sub-artifacts:**\n   - Find requirements in feature's requirements directory:\n     ```bash\n     find speclan/features/F-XXXX-*/requirements -type d -name 'R-*' 2>/dev/null\n     ```\n   - For each requirement directory, read the requirement file and find scenarios\n   - Check for sub-features in directory structure\n\n4. **Follow markdown links (selective):**\n   - Related features mentioned in \"## Related\" sections\n   - Cross-referenced business rules\n   - Linked external documentation\n\n#### 2.2 Extract Verification Targets\n\nFrom the feature context, identify what must be verified:\n\n| Source | Verification Target |\n|--------|---------------------|\n| Feature Overview | Core functionality exists |\n| User Story | User workflow is possible |\n| Scope items | Each scope item implemented |\n| Requirements | Enforcement rules in code |\n| Scenarios | Test coverage or code paths |\n| Acceptance Criteria | Specific conditions met |\n| Business Rules | Rules enforced in logic |\n\nCreate verification checklist:\n```\nFeature F-1049: Pet Management\n├── [ ] Core pet entity exists\n├── [ ] CRUD operations implemented\n├── [ ] Status lifecycle enforced\n├── Requirements:\n│   ├── R-0001: Quarantine sales block\n│   │   ├── [ ] Validation in CartService\n│   │   ├── [ ] Validation in POSService\n│   │   └── [ ] Error message displayed\n│   └── R-0002: Status transitions\n│       └── [ ] State machine implemented\n└── Scenarios:\n    ├── [ ] S-0001: Add pet to inventory\n    └── [ ] S-0002: Update pet status\n```\n\n### Phase 3: Implementation Verification\n\n#### 3.1 Verification Strategy\n\n**Layer 1: Entity/Model Verification**\n```bash\n# Find entity definitions\ngrep -r \"class Pet\\|interface Pet\\|type Pet\" src/ --include=\"*.ts\"\ngrep -r \"Pet.*=.*{\" src/ --include=\"*.ts\"\n\n# Verify required fields exist\ngrep -A20 \"class Pet\" <file> | grep -E \"status|name|id\"\n```\n\n**Layer 2: Service/Business Logic Verification**\n```bash\n# Find services implementing feature\ngrep -r \"PetService\\|PetManager\" src/ --include=\"*.ts\" -l\n\n# Check for business rule enforcement\ngrep -r \"QUARANTINE\\|canSell\\|validateStatus\" src/ --include=\"*.ts\"\n```\n\n**Layer 3: API/Controller Verification**\n```bash\n# Find endpoints\ngrep -r \"@Get\\|@Post\\|@Put\\|@Delete\" src/ --include=\"*.ts\" -B2 -A5 | grep -i \"pet\"\n\n# Or REST patterns\ngrep -r \"router\\.\\(get\\|post\\|put\\|delete\\).*pet\" src/ --include=\"*.ts\"\n```\n\n**Layer 4: UI/Frontend Verification**\n```bash\n# Find components\nfind src -name \"*[Pp]et*.tsx\" -o -name \"*[Pp]et*.vue\" -o -name \"*[Pp]et*.svelte\"\n\n# Check for user workflow elements\ngrep -r \"addToCart\\|checkout\\|petStatus\" src/ --include=\"*.tsx\"\n```\n\n**Layer 5: Test Coverage Verification**\n```bash\n# Find test files\nfind . -name \"*.spec.ts\" -o -name \"*.test.ts\" | xargs grep -l \"pet\\|Pet\"\n\n# Check scenario coverage\ngrep -r \"describe.*Pet\\|it.*should.*pet\" --include=\"*.spec.ts\"\n```\n\n#### 3.2 Evidence Collection\n\nFor each verification target, collect:\n\n| Evidence Type | Example |\n|---------------|---------|\n| File location | `src/services/PetService.ts:45` |\n| Code snippet | `if (pet.status === 'QUARANTINE') throw...` |\n| Test reference | `pet.spec.ts:120 - \"should block quarantine sales\"` |\n| API endpoint | `POST /api/pets - createPet()` |\n\n#### 3.3 Gap Detection\n\nIdentify missing implementations:\n\n```\n## Gaps Found\n\n### Critical (blocks feature)\n- [ ] No quarantine validation in POSService\n- [ ] Missing status transition validation\n\n### Major (incomplete feature)\n- [ ] No test for scenario S-0002\n- [ ] Error messages not user-friendly\n\n### Minor (polish)\n- [ ] Missing API documentation\n- [ ] No logging for status changes\n```\n\n### Phase 4: Generate Verification Report\n\n**Mark todo as completed after generating report for each feature.**\n\n#### Report Structure\n\n```markdown\n# Verification Report: F-XXXX - [Title]\n\n## Summary\n| Metric | Value |\n|--------|-------|\n| Status | ✅ VERIFIED / ⚠️ PARTIAL / ❌ NOT VERIFIED |\n| Coverage | 85% (17/20 items verified) |\n| Critical Gaps | 0 |\n| Major Gaps | 2 |\n| Minor Gaps | 3 |\n\n## Feature Context\n- **Goal:** G-XXX - [Goal Title]\n- **Parent:** F-YYY - [Parent Title] (if any)\n- **Requirements:** 3 (R-0001, R-0002, R-0003)\n- **Sub-features:** 2 (F-201, F-202)\n\n## Verification Results\n\n### Core Feature\n| Item | Status | Evidence |\n|------|--------|----------|\n| Pet entity | ✅ | `src/models/Pet.ts:1` |\n| CRUD operations | ✅ | `PetService.ts:create/read/update/delete` |\n| Status lifecycle | ⚠️ | Partial - missing DECEASED state |\n\n### Requirements\n\n#### R-0001: Pets in quarantine cannot be sold\n| Check | Status | Evidence |\n|-------|--------|----------|\n| Cart validation | ✅ | `CartService.ts:45` |\n| POS validation | ❌ | Not found |\n| Error message | ✅ | `CartError.QUARANTINE_BLOCKED` |\n\n**Gaps:**\n- POS sale flow bypasses quarantine check\n\n#### R-0002: Status transitions\n| Check | Status | Evidence |\n|-------|--------|----------|\n| State machine | ✅ | `PetStateMachine.ts` |\n| Transition validation | ✅ | `validateTransition()` |\n\n### Scenarios\n\n| Scenario | Status | Evidence |\n|----------|--------|----------|\n| S-0001: Add pet | ✅ | `pet.spec.ts:50` |\n| S-0002: Update status | ⚠️ | Code exists, no test |\n\n### Test Coverage\n- Unit tests: 12 passing\n- Integration tests: 3 passing\n- E2E tests: Not found\n\n## Gaps Summary\n\n### Critical\nNone\n\n### Major\n1. **POS quarantine bypass** - R-0001 not enforced in POS flow\n   - Fix: Add validation in `POSService.processSale()`\n\n2. **Missing S-0002 test** - Status update scenario untested\n   - Fix: Add test in `pet.spec.ts`\n\n### Minor\n1. Missing DECEASED status in lifecycle\n2. No API documentation for pet endpoints\n3. Console.log instead of proper logging\n\n## Recommendations\n\n1. **Immediate:** Fix POS quarantine validation (Critical path)\n2. **Before release:** Add missing tests\n3. **Technical debt:** Improve logging and docs\n\n## Verification Metadata\n- Verified by: feature-verifier agent\n- Date: [timestamp]\n- SPECLAN version: [from speclan/]\n- Codebase commit: [if available]\n```\n\n### Phase 5: Final Summary (after all features)\n\nAfter verifying all features, generate summary:\n\n```markdown\n# Verification Summary\n\n## Overview\n| Feature | Status | Coverage | Critical | Major | Minor |\n|---------|--------|----------|----------|-------|-------|\n| F-1049 | ✅ | 95% | 0 | 1 | 2 |\n| F-200 | ⚠️ | 70% | 1 | 2 | 1 |\n| F-301 | ❌ | 30% | 3 | 2 | 0 |\n\n## Overall Statistics\n- Features verified: 3\n- Fully verified: 1 (33%)\n- Partially verified: 1 (33%)\n- Not verified: 1 (33%)\n\n## Critical Issues (Must Fix)\n1. F-200: Missing health record validation\n2. F-301: Report generation not implemented\n3. F-301: Data aggregation incomplete\n\n## Recommended Priority\n1. F-301 - Most gaps, needs attention\n2. F-200 - One critical issue\n3. F-1049 - Minor polish only\n```\n\n## Confidence Levels\n\n**HIGH (✅):**\n- Exact code match found\n- Test explicitly covers scenario\n- Clear 1:1 mapping to requirement\n\n**MEDIUM (⚠️):**\n- Logic appears to implement requirement\n- Partial coverage found\n- Implicit implementation\n\n**LOW (❓):**\n- Cannot determine if implemented\n- Related code exists but unclear\n- Needs manual review\n\nAlways report confidence level with findings.\n\n## Edge Cases\n\n### Feature with no requirements\n```\nFeature F-XXXX has no linked requirements.\nVerifying based on:\n- Feature overview/scope\n- User story workflow\n- Sub-features (if any)\n```\n\n### Cannot access codebase\n```\n⚠️ Cannot verify implementation - codebase not accessible.\nReturning spec analysis only.\n```\n\n### Already verified recently\n```\nFeature F-XXXX was verified [date].\nRe-running verification...\n[or skip if --skip-recent flag]\n```\n",
        "plugins/speclan/agents/implementation-order.md": "---\nname: implementation-order\ncolor: blue\ndescription: |\n  Use this agent when:\n  <example>User needs to determine optimal feature implementation order</example>\n  <example>Analyzing feature dependencies for implementation planning</example>\n  <example>Creating a dependency graph for SPECLAN features</example>\n  <example>Sorting features by dependencies before implementation</example>\ntools:\n  - Read\n  - Glob\n  - Grep\n  - Bash\n---\n\n# Implementation Order Agent\n\nAnalyze feature dependencies and determine optimal implementation order using DAG-based topological sorting.\n\n## Purpose\n\nGiven a list of features to implement (passed as input), analyze dependencies and return optimal implementation order.\n\n**IMPORTANT: Do NOT discover features yourself. Only analyze the features explicitly passed to you.**\n\n## Input Format\n\nYou will receive input in this format:\n```\nFeatures to order:\n- F-1049-{slug}\n- F-1200-{slug}\n- F-1301-{slug}\n\nSPECLAN directory: speclan/\n```\n\n**Only process the features listed above. Do not search for other features.**\n\n## Dependency Analysis Process - ULTRATHINK to get it optimal\n\n### 1. Detect Parent-Child Relationships (FIRST)\n\n**Before any other analysis, identify hierarchical relationships:**\n\nCheck if features are nested in the directory structure:\n```bash\n# F-1200 is child of F-1049 if located at:\nspeclan/features/F-1049-*/F-1200-*/F-1200-*.md\n```\n\nOr check `parent:` field in YAML frontmatter:\n```yaml\nparent: F-1049\n```\n\n**If parent and child are BOTH in input list → parent MUST come first.**\n\n### 2. Parse Feature Specifications\n\n**For each feature in the INPUT LIST (not discovered):**\n\n```bash\n# Read feature spec\ncat speclan/features/F-XXXX-*/F-XXXX-*.md\n```\n\nExtract dependency indicators from:\n\n**YAML Frontmatter:**\n```yaml\n# Explicit dependencies\ndepends-on:\n  - F-1049\n  - F-100\n\n# Parent feature (implicit dependency)\nparent: F-1049\n\n# Required goals (shared dependencies)\ngoals:\n  - G-292\n```\n\n**Markdown Content:**\n- \"Depends on F-XXXX\" mentions\n- \"Requires F-XXXX\" references\n- \"After F-XXXX is implemented\" notes\n- Cross-references in Related sections\n\n### 3. Analyze Requirement Dependencies\n\nFor each feature's requirements:\n\n```bash\n# Find requirements for feature (directory-based storage)\nfind speclan/features/F-XXXX-*/requirements -type d -name 'R-*' 2>/dev/null\n```\n\nCheck requirement dependencies:\n```yaml\n# Requirement may depend on other requirements\ndepends-on:\n  - R-0001\n  - R-0002\n```\n\nMap requirement dependencies back to feature dependencies.\n\n### 4. Explore Codebase Dependencies\n\nAnalyze existing implementation for implicit dependencies:\n\n**Import/Module Dependencies:**\n```bash\n# Find files related to feature\ngrep -r \"F-XXXX\\|feature-name\" src/ --include=\"*.ts\" -l\n\n# Check imports in those files\ngrep -E \"^import.*from\" <files>\n```\n\n**Type Dependencies:**\n- Shared types/interfaces between features\n- Entity relationships (FK references)\n- Service dependencies\n\n**API Dependencies:**\n- Endpoint dependencies\n- Data flow requirements\n\n### 5. Build Dependency Graph (DAG)\n\nCreate adjacency list representation:\n\n```\nGraph Structure:\n{\n  \"F-1049\": [],                    # No dependencies (root)\n  \"F-1200\": [\"F-1049\"],             # Depends on F-1049 (child of F-1049)\n  \"F-1301\": [\"F-1049\", \"F-1200\"],    # Depends on both\n  \"F-1150\": [\"F-1049\"]              # Depends on F-1049\n}\n```\n\n**RULE: Parent features ALWAYS before subfeatures**\n\nWhen a feature and its subfeatures are both in the input list:\n- The parent feature MUST be implemented first\n- Subfeatures inherit an implicit dependency on their parent\n- This is non-negotiable regardless of other dependency analysis\n\nExample: If input contains F-1049 and F-1200 (child of F-1049):\n```\nF-1049 → F-1200  (parent-child relationship = mandatory ordering)\n```\n\n**Dependency Types (weighted):**\n1. **Hierarchical** (weight: 4) - Parent-child relationship (HIGHEST PRIORITY)\n2. **Explicit** (weight: 3) - Declared in `depends-on` YAML\n3. **Implicit** (weight: 1) - Code/requirement analysis\n\n### 6. Detect Cycles\n\nBefore sorting, check for circular dependencies:\n\n```\nAlgorithm: DFS-based cycle detection\n- Track visited nodes\n- Track recursion stack\n- If node in recursion stack → cycle found\n```\n\nIf cycle detected:\n```\n## ⚠️ Circular Dependency Detected\n\nCycle: F-1049 → F-1200 → F-1301 → F-1049\n\nResolution options:\n1. Break cycle by implementing F-XXXX first (minimal shared state)\n2. Merge features F-XXXX and F-YYYY\n3. Extract shared functionality to new feature\n\nProceeding with best-effort ordering...\n```\n\n### 7. Topological Sort (Kahn's Algorithm)\n\n```\nAlgorithm:\n1. Calculate in-degree for each node\n2. Add nodes with in-degree 0 to queue\n3. While queue not empty:\n   - Remove node from queue (use ID-based ordering for ties)\n   - Add to result list\n   - For each neighbor:\n     - Decrement in-degree\n     - If in-degree becomes 0, add to queue\n4. If result size ≠ node count → cycle exists\n```\n\n**Tiebreaker: ID-Based Ordering**\n\nWhen multiple features have the same dependency level (same in-degree), use numeric ID ordering:\n- **Lower IDs = Higher priority** (implemented first)\n- **Higher IDs = Lower priority** (implemented later)\n\nExample: If F-1049 and F-2500 both have no dependencies, F-1049 is implemented first.\n\n## Output Format\n\nReturn structured implementation order:\n\n```\n## Feature Implementation Order\n\n### Dependency Graph\n\n```mermaid\ngraph TD\n    F-1049[F-1049: Pet Management] --> F-1200[F-1200: Pet Health]\n    F-1049 --> F-1150[F-1150: Pet Sales]\n    F-1200 --> F-1301[F-1301: Health Reports]\n```\n\n### Implementation Sequence\n\n| Order | Feature | Title | Dependencies | Reason |\n|-------|---------|-------|--------------|--------|\n| 1 | F-1049 | Pet Management | None | Root feature, no dependencies |\n| 2 | F-1150 | Pet Sales | F-1049 | Requires pet entities from F-1049 |\n| 3 | F-1200 | Pet Health | F-1049 | Requires pet entities from F-1049 |\n| 4 | F-1301 | Health Reports | F-1200 | Requires health records from F-1200 |\n\n### Dependency Details\n\n**F-1049: Pet Management**\n- Dependencies: None\n- Dependents: F-1150, F-1200\n- Analysis: Core pet entity definitions, must be first\n\n**F-1200: Pet Health**\n- Dependencies: F-1049 (explicit in YAML)\n- Dependents: F-1301\n- Analysis: Extends Pet entity with health tracking\n\n**F-1301: Health Reports**\n- Dependencies: F-1200 (implicit from requirements)\n- Dependents: None\n- Analysis: Consumes health data, implement last\n\n### Parallel Implementation Opportunities\n\nFeatures at same depth level can be implemented in parallel:\n- Level 1: F-1049\n- Level 2: F-1150, F-1200 (parallel possible)\n- Level 3: F-1301\n```\n\n## Edge Cases\n\n### No Dependencies Found\n\nIf no explicit dependencies detected:\n```\nNo explicit dependencies found between features.\nRecommended order based on:\n1. Feature hierarchy (parents before children)\n2. Requirement count (simpler features first)\n3. Alphabetical by ID\n```\n\n### Partial Overlap with Existing Implementation\n\nWhen some features already implemented:\n```\n## Existing Implementation Analysis\n\nAlready implemented (excluded from ordering):\n- F-1049: Pet Management ✓\n\nRemaining features to implement:\n| Order | Feature | Dependencies |\n|-------|---------|--------------|\n| 1 | F-1200 | F-1049 (✓ satisfied) |\n| 2 | F-1301 | F-1200 |\n```\n\n### Single Feature\n\nIf only one feature provided:\n```\nSingle feature F-XXXX - no ordering needed.\nDependencies check: All satisfied ✓\n```\n\n## Search Patterns\n\n**Find feature specs:**\n```bash\nfind speclan/features -name \"F-*.md\" -type f\n```\n\n**Extract depends-on:**\n```bash\ngrep -A5 \"^depends-on:\" speclan/features/F-XXXX-*/F-XXXX-*.md\n```\n\n**Find parent features:**\n```bash\ngrep \"^parent:\" speclan/features/*/F-*.md\n```\n\n**Cross-reference mentions:**\n```bash\ngrep -r \"F-[0-9]\\{3\\}\" speclan/features/ --include=\"*.md\"\n```\n\n## Confidence Levels\n\n**High Confidence:**\n- Explicit `depends-on` in YAML\n- Parent-child hierarchy\n- Direct requirement linkage\n\n**Medium Confidence:**\n- Cross-reference mentions in markdown\n- Shared goal dependencies\n- Import analysis\n\n**Low Confidence:**\n- Naming similarity\n- Assumed logical order\n- No explicit indicators\n\nReport confidence level with dependency analysis.\n",
        "plugins/speclan/agents/requirement-verifier.md": "---\nname: requirement-verifier\ncolor: yellow\ndescription: |\n  Use this agent when:\n  <example>User wants to verify a requirement is implemented</example>\n  <example>User asks to check if requirement R-XXXX is satisfied</example>\n  <example>Checking implementation against requirement specification</example>\ntools:\n  - Read\n  - Glob\n  - Grep\n  - Edit\n  - Bash\n---\n\n# Requirement Verifier Agent\n\nVerify that a SPECLAN requirement is correctly implemented in the codebase.\n\n## Purpose\n\nAnalyze the codebase to determine if a specific requirement's enforcement rules, scenarios, and business rules are properly implemented.\n\n## Input\n\nReceives:\n- Requirement specification (ID, title, content)\n- Feature context (what was implemented)\n- Codebase location\n\n## Verification Process\n\n### 1. Parse Requirement Content\n\nExtract verification targets from the requirement:\n\n**Enforcement Rules** - From \"The system must:\" or \"Enforcement\" sections:\n```\nThe system must:\n1. Validate pet status before adding to cart\n2. Block sales of quarantined pets\n3. Display error message when blocked\n```\n\n**Scenarios** - From YAML `scenarios:` array:\n```yaml\nscenarios:\n  - Attempt to add quarantined pet to cart\n  - Validate order containing pet with restricted status\n```\n\n**Business Rules** - From \"Business Rule Reference\":\n```\n- PS-001: Pets in QUARANTINE cannot be sold\n- INV-003: 48-hour quarantine minimum\n```\n\n### 2. Search for Implementation\n\nFor each enforcement rule:\n- Search for code patterns that implement the rule\n- Look for validation logic, guards, checks\n- Check service/controller layers\n\nFor each scenario:\n- Look for test files covering the scenario\n- Search for code paths handling the scenario\n\nFor each business rule:\n- Find constants/enums with rule IDs\n- Verify rule is enforced in business logic\n\n### 3. Assess Verification\n\n**VERIFIED** - All conditions met:\n- All enforcement rules have corresponding code\n- Scenarios have test coverage or clear code paths\n- Business rules are implemented\n\n**NOT VERIFIED** - Any gap found:\n- Missing enforcement implementation\n- Uncovered scenarios\n- Business rule not enforced\n\n### 4. Report Results\n\nReturn structured verification result:\n\n```\n## Verification: R-XXXX [Title]\n\n### Status: VERIFIED | NOT_VERIFIED\n\n### Enforcement Rules\n| Rule | Status | Evidence |\n|------|--------|----------|\n| Validate pet status | ✓ | CartService.ts:45 |\n| Block quarantined pets | ✓ | PetValidator.ts:23 |\n| Display error message | ✗ | Not found |\n\n### Scenarios\n| Scenario | Status | Evidence |\n|----------|--------|----------|\n| Add quarantined pet to cart | ✓ | cart.spec.ts:120 |\n| POS sale blocked | ✗ | No test found |\n\n### Business Rules\n| Rule | Status | Evidence |\n|------|--------|----------|\n| PS-001 | ✓ | Constants.ts, CartService.ts |\n\n### Gaps (if NOT_VERIFIED)\n1. Missing error message display when pet is blocked\n2. No POS sale flow validation\n3. Missing test for POS scenario\n\n### Fix Instructions\nTo resolve gaps:\n1. Add error message in CartComponent when validation fails\n2. Add quarantine check in POSService.processSale()\n3. Add test case in pos.spec.ts for quarantined pets\n```\n\n## Status Update\n\nIf requirement is VERIFIED:\n- Keep status at `in-development` (already set by parent command)\n\nIf requirement is NOT_VERIFIED:\n- Revert status to previous value\n- Return gaps for fix cycle\n\n## Search Patterns\n\nCommon code patterns to search:\n\n**Validation logic:**\n```\ngrep -r \"status.*quarantine\" --include=\"*.ts\"\ngrep -r \"validate.*pet\" --include=\"*.ts\"\ngrep -r \"can.*sell\\|allow.*sale\" --include=\"*.ts\"\n```\n\n**Test coverage:**\n```\ngrep -r \"quarantine.*cart\" --include=\"*.spec.ts\"\ngrep -r \"describe.*pet.*sale\" --include=\"*.test.ts\"\n```\n\n**Business rule enforcement:**\n```\ngrep -r \"PS-001\\|INV-003\" --include=\"*.ts\"\ngrep -r \"QUARANTINE\\|MEDICAL_HOLD\" --include=\"*.ts\"\n```\n\n## Confidence Levels\n\n**High Confidence** - Clear match:\n- Explicit rule ID in code comments\n- Function name matches rule\n- Test describes exact scenario\n\n**Medium Confidence** - Implicit match:\n- Logic appears to implement rule\n- No explicit reference but behavior matches\n\n**Low Confidence** - Uncertain:\n- Partial implementation\n- Related but not exact match\n\nReport confidence level with each finding.\n",
        "plugins/speclan/agents/spec-converter.md": "---\nname: spec-converter\ncolor: green\ndescription: |\n  Use this agent when:\n  <example>User wants to convert speckit specs to SPECLAN format</example>\n  <example>User asks to prepare SPECLAN specs for speckit processing</example>\n  <example>User needs to transform specifications between formats</example>\ntools:\n  - Read\n  - Write\n  - Glob\n  - Grep\n  - Bash\nmodel: opus\n---\n\n# Spec Converter Agent\n\nConvert specifications between speckit and SPECLAN formats.\n\n## Purpose\n\nHandle bidirectional conversion between:\n- **Speckit format**: Phase-based specs in `specs/###-name/spec.md`\n- **SPECLAN format**: Hierarchical specs in `speclan/` directory\n\n## Speckit Format Understanding\n\nSpeckit specifications use:\n\n**Structure:**\n```\nspecs/\n├── 001-phase1-core/\n│   ├── spec.md\n│   └── tasks.md\n├── 002-phase2-persistence/\n│   └── spec.md\n```\n\n**Content sections:**\n- User Scenarios (P1-P4 priorities)\n- Functional Requirements (FR-###)\n- Success Criteria (SC-###)\n- Given/When/Then acceptance scenarios\n\n## SPECLAN Format Understanding\n\nSPECLAN specifications use:\n\n**Structure:**\n```\nspeclan/\n├── goals/G-###-name.md\n├── features/\n│   └── F-####-name/\n│       ├── F-####-name.md\n│       └── requirements/\n│           └── R-####-name/\n│               └── R-####-name.md\n```\n\nNote: Features and Requirements use directory-based storage where directory name matches the contained markdown filename.\n\n**YAML frontmatter:**\n```yaml\n---\nid: F-1001\ntype: feature\ntitle: Core Extension\nstatus: draft\nowner: Team\ncreated: \"2025-12-19\"\nupdated: \"2025-12-29\"\ngoals: [G-001]\n---\n```\n\n## Conversion: Speckit → SPECLAN\n\n### Mapping Rules\n\n| Speckit Element | SPECLAN Entity |\n|-----------------|----------------|\n| Feature Branch | Feature (F-####) |\n| FR-### | Requirement (R-####) |\n| Acceptance Scenario | Scenario (S-####) |\n| SC-### | AcceptanceCriterion (AC-####) |\n\n### Conversion Process\n\n1. Parse speckit `spec.md` file\n2. Extract metadata from bold markdown\n3. Extract user stories with priorities\n4. Extract functional requirements\n5. Generate SPECLAN YAML frontmatter\n6. Create file with proper naming\n7. Establish entity links\n\n## Conversion: SPECLAN → Speckit\n\n### Aggregation Rules\n\n1. Collect approved Features\n2. Gather linked Requirements\n3. Include Scenarios and ACs\n4. Format as speckit structure\n\n## Conversion Validation\n\nAfter conversion, verify:\n- All required YAML fields present\n- IDs follow SPECLAN conventions\n- File naming correct\n- Entity links valid\n- No data loss from source\n",
        "plugins/speclan/commands/from-speckit.md": "---\nname: from-speckit\ndescription: Convert speckit specifications to SPECLAN format\nallowed-tools:\n  - Read\n  - Write\n  - Bash\n  - Glob\n  - Grep\n  - Task\nargument-hint: \"[speckit-directory]\"\n---\n\n# SPECLAN From-Speckit Command\n\nConvert speckit phase-based specifications to SPECLAN hierarchical format.\n\n## Prerequisites\n\nThis command requires understanding of both formats:\n\n**Speckit Format** (source):\n- Located in `specs/` directory\n- Numbered directories: `###-phase-name/`\n- `spec.md` with bold markdown metadata\n- User stories with priorities (P1-P4)\n- Functional requirements (FR-###)\n- Success criteria (SC-###)\n\n**SPECLAN Format** (target):\n- Located in `speclan/` directory\n- Entity hierarchy: Goal → Feature → Requirement → Scenario → AC → Test\n- YAML frontmatter with proper IDs (G-###, F-####, R-####, etc.)\n\n## Instructions\n\n### 1. Check Plugin Dependency\n\nVerify speckit plugin is installed. If not:\n```\nError: speckit plugin is not installed.\n\nThe /speclan:from-speckit command requires speckit for full functionality.\nInstall speckit plugin to enable this command.\n\nProceeding with manual conversion...\n```\n\n### 2. Locate Speckit Specs\n\nFind speckit specifications:\n- Default: `specs/` in project root\n- Or use provided directory argument\n- Look for numbered directories with `spec.md` files\n\n### 3. Parse Speckit Format\n\nFor each `spec.md` file, extract:\n\n**Metadata:**\n- Feature Branch name\n- Created date\n- Status\n- Input source\n\n**Content:**\n- User stories (with priorities)\n- Functional requirements (FR-###)\n- Success criteria (SC-###)\n- Acceptance scenarios (Given/When/Then)\n- Assumptions and constraints\n\n### 4. Map to SPECLAN Entities\n\nConvert speckit elements to SPECLAN:\n\n| Speckit Element | SPECLAN Entity |\n|-----------------|----------------|\n| Feature Branch | Feature (F-####) |\n| User Story | Feature description / User Story section |\n| Functional Requirement (FR-###) | Requirement (R-####) |\n| Acceptance Scenario | Scenario (S-####) |\n| Success Criterion (SC-###) | AcceptanceCriterion (AC-####) |\n| Priority (P1-P4) | Tags or status |\n\n### 5. Generate SPECLAN Files\n\nFor each speckit spec:\n\n1. Create Feature file:\n   ```yaml\n   ---\n   id: F-XXX\n   type: feature\n   title: [from Feature Branch name]\n   status: draft\n   owner: [from metadata or default]\n   created: [from speckit created date]\n   updated: [current date]\n   goals: []  # To be linked later\n   ---\n   ```\n\n2. Create Requirement files for each FR:\n   ```yaml\n   ---\n   id: R-XXXX\n   type: requirement\n   title: [from FR description]\n   status: draft\n   owner: [inherited]\n   created: [current]\n   updated: [current]\n   feature: F-XXX\n   scenarios: []\n   ---\n   ```\n\n3. Create Scenario files for acceptance scenarios\n\n### 6. Handle Phase Dependencies\n\nSpeckit phases build on each other (001 → 002 → 003...).\n\n- Later phases may update earlier specs\n- Create ChangeRequest entities for modifications\n- Or update existing specs with new requirements\n\n### 7. Preserve Traceability\n\nMaintain links to source speckit files:\n```markdown\n## Source\n\nConverted from speckit specification:\n- **Source:** specs/001-phase1-core-extension/spec.md\n- **Converted:** [date]\n```\n\n### 8. Output Summary\n\n```\n## Conversion Complete\n\nConverted [X] speckit specifications to SPECLAN format.\n\n### Created Entities\n| Type | Count |\n|------|-------|\n| Features | X |\n| Requirements | X |\n| Scenarios | X |\n\n### Files Created\n- speclan/features/F-001-phase1-core-extension/F-001-phase1-core-extension.md\n- speclan/features/F-001-.../requirements/R-0001-slug/R-0001-slug.md\n- ...\n\n### Next Steps\n1. Review converted specifications\n2. Link features to goals\n3. Add missing acceptance criteria\n4. Complete scenario coverage\n```\n\n## Incremental Conversion\n\nIf some specs already converted:\n- Detect existing SPECLAN entities\n- Skip already-converted speckit specs\n- Only convert new or modified specs\n- Update existing specs if speckit changed\n\n## Error Handling\n\nIf speckit directory not found:\n```\nError: No speckit specifications found.\n\nExpected location: specs/\nExpected format: ###-phase-name/spec.md\n\nVerify speckit specs exist before running this command.\n```\n",
        "plugins/speclan/commands/implement.md": "---\nname: speclan:implement\ndescription: Implement approved SPECLAN Features using feature-dev plugin\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - Task\n  - Skill\n  - TodoWrite\n  - /feature-dev:feature-dev\nargument-hint: \"[feature-ids...]\"\n---\n\n# SPECLAN Implement Command\n\nImplement approved SPECLAN Features using the feature-dev command, then verify all requirements.\n\n## CRITICAL BEHAVIOR RULES\n\n1. **MUST USE /feature-dev:feature-dev** - For EACH feature, invoke the Command /feature-dev:feature-dev IMPORTANT: Do NOT implement features directly without invoking this command.\n\n2. **MUST VERIFY REQUIREMENTS** - After feature-dev completes, verify ALL linked requirements in PARALLEL using Task tool with requirement-verifier agents.\n\n3. **MUST VERIFY FEATURE** - After requirements pass, verify overall feature implementation using feature-verifier agent (5-layer deep verification).\n\n4. **FIX UNTIL ALL PASS** - If any verification fails (requirement OR feature), invoke feature-dev again with fix instructions. Repeat verify-fix cycle until ALL pass. NO LIMIT on retries.\n\n5. **DO NOT STOP between features** - Implement ALL approved features in sequence without pausing. Only stop when ALL features are complete or user intervenes.\n\n6. **Status updates are DEFERRED** - Features go to \"under-test\" only after ALL features complete. Requirements go to \"in-development\" during verification.\n\n## Prerequisites\n\nThis command requires:\n- **feature-dev command** - Must be installed\n\nCheck if feature-dev is available. If not installed, show error and stop.\n\n## Instructions\n\n### 1. Find Approved Features\n\nQuery SPECLAN directory for features with `status: approved`:\n\n```bash\ngrep -r \"^status: approved\" speclan/features/ -l\n```\n\nIf no approved features found, report and exit.\n\n### 2. Determine Implementation Order (USE AGENT)\n\n**MUST use the implementation-order agent** to analyze dependencies and determine optimal order.\n\n**Pass the exact list of approved features found in Step 1:**\n\n```\nTask tool:\n  subagent_type: \"general-purpose\"\n  prompt: \"You are the implementation-order agent.\n\n  Features to order:\n  - F-049-{slug}\n  - F-200-{slug}\n  - F-301-{slug}\n  [list ALL approved feature IDs from Step 1]\n\n  SPECLAN directory: speclan/\n\n  IMPORTANT: Only analyze the features listed above. Do not discover other features.\n\n  For each feature in the list:\n  1. Read its spec file and extract depends-on, parent, goals from YAML\n  2. Check requirement dependencies between features\n  3. Analyze codebase for implicit dependencies\n  4. Build Feature Dependency Graph (DAG)\n  5. Detect circular dependencies\n  6. Perform topological sort (Kahn's algorithm)\n\n  Return ordered list with:\n  - Implementation sequence (first to implement at top)\n  - Dependency graph visualization\n  - Reasoning for each position\n  - Parallel implementation opportunities\"\n```\n\nWait for agent to return the sorted feature list.\n\nDisplay the plan:\n```\n## Implementation Plan\n\n### Dependency Graph\n[from agent output]\n\n| Order | Feature | Title | Dependencies | Requirements |\n|-------|---------|-------|--------------|--------------|\n| 1 | F-XXX | Feature Title | None (root) | R-0001, R-0002 |\n| 2 | F-YYY | Another Feature | F-XXX | R-0003 |\n\nWill invoke /feature-dev:feature-dev for EACH feature in this order, then verify requirements.\n```\n\n### 3. Execute Implementation Loop\n\nInitialize tracking:\n- `completed_features = []`\n- `failed_features = []`\n\n**FOR EACH feature in order:**\n\n#### Step A: Update feature status to in-development\n```yaml\nstatus: in-development\n```\n\n#### Step B: Gather feature context\nRead and collect:\n- The feature specification file\n- All linked requirements\n- Acceptance scenarios\n- Business rules\n\n#### Step C: INVOKE FEATURE-DEV (MANDATORY)\n\n**YOU MUST use the command /feature-dev:feature-dev**\n\n```\nUse Command:\n  command: /feature-dev:feature-dev\n  args: \"Implement feature [F-XXX] [Title]\n\n## Feature Specification\n[paste full feature content]\n\n## Requirements\n[paste all linked requirements]\n\n## Acceptance Criteria\n[paste scenarios and acceptance criteria]\n\"\n```\n\nWait for feature-dev to complete.\n\n#### Step D: VERIFY REQUIREMENTS (PARALLEL)\n\n**After feature-dev completes, verify ALL linked requirements:**\n\n1. **Find all requirements for this feature:**\n   - Check feature's `requirements:` YAML field\n   - OR grep: `grep -r \"^feature: F-XXX\" speclan/`\n\n2. **Set ALL requirements to in-development:**\n   Edit each requirement's YAML:\n   ```yaml\n   status: in-development\n   ```\n\n3. **Launch verification agents IN PARALLEL:**\n   For EACH requirement, use Task tool:\n   ```\n   Task tool:\n     subagent_type: \"general-purpose\"\n     prompt: \"Verify requirement [R-XXXX] is implemented.\n\n     ## Requirement Specification\n     [paste requirement content]\n\n     ## What to verify:\n     1. Check enforcement rules are implemented in code\n     2. Check scenarios have test coverage\n     3. Check business rules are enforced\n\n     Return: VERIFIED or NOT_VERIFIED with gaps list\"\n   ```\n\n4. **Collect results:**\n   - VERIFIED: Keep requirement at `in-development`\n   - NOT_VERIFIED: Note gaps, revert status to previous\n\n#### Step E: FIX LOOP (if any requirement verification failed)\n\n**If ANY requirement NOT_VERIFIED:**\n\n1. Collect all gaps from failed verifications\n2. Invoke /feature-dev:feature-dev AGAIN with fix instructions:\n   ```\n   Command:\n     command: /feature-dev:feature-dev\n     args: \"Fix implementation gaps for [F-XXX]\n\n     ## Verification Failures\n     [list all gaps from failed requirements]\n\n     ## Requirements to fix\n     [paste failed requirement specs]\n\n     Fix these specific issues.\"\n   ```\n\n3. Re-verify ONLY the failed requirements (parallel)\n4. **REPEAT until ALL requirements pass**\n5. No limit on iterations - continue until all pass or user stops. FOR EACH LOOP: Always restart the /feature-dev:feature-dev command from scratch!\n\n#### Step F: VERIFY FEATURE (USE AGENT)\n\n**After ALL requirements pass, verify the overall feature implementation:**\n\nLaunch the feature-verifier agent:\n```\nTask tool:\n  subagent_type: \"general-purpose\"\n  prompt: \"You are the feature-verifier agent.\n\n  Verify feature:\n  - F-XXX-{slug}\n\n  SPECLAN directory: speclan/\n\n  Perform deep verification:\n  1. Build context tree (read parents up to root, feature, sub-artifacts)\n  2. Extract all verification targets from spec\n  3. Verify implementation using 5-layer strategy:\n     - Entity/Model layer\n     - Service/Business Logic layer\n     - API/Controller layer\n     - UI/Frontend layer (if applicable)\n     - Test coverage layer\n  4. Generate verification report with:\n     - Status: VERIFIED / PARTIAL / NOT_VERIFIED\n     - Coverage percentage\n     - Gaps (Critical/Major/Minor)\n     - Evidence with file:line references\n\n  Return: Verification report\"\n```\n\n#### Step F.2: FIX LOOP (if feature verification found issues)\n\n**If feature NOT_VERIFIED or PARTIAL with Critical/Major gaps:**\n\n1. Collect ALL gaps from verification report (Critical and Major)\n2. Invoke /feature-dev:feature-dev AGAIN with fix instructions:\n   ```\n   Command:\n     command: /feature-dev:feature-dev\n     args: \"Fix feature verification gaps for [F-XXX]\n\n     ## Verification Report Summary\n     Status: [PARTIAL/NOT_VERIFIED]\n     Coverage: [X]%\n\n     ## Gaps to Fix\n\n     ### Critical\n     [list critical gaps with file:line evidence]\n\n     ### Major\n     [list major gaps with file:line evidence]\n\n     ## Feature Specification\n     [paste feature spec for context]\n\n     Fix these specific issues to pass verification.\"\n   ```\n\n3. Re-run feature verification (launch feature-verifier agent again)\n4. **REPEAT until feature is VERIFIED or PARTIAL with only Minor gaps**\n5. No limit on iterations - continue until verified or user stops\n\n#### Step G: Record completion\n- Feature verified: Add feature to `completed_features`\n- Cannot complete: Add to `failed_features`\n\n#### Step H: Continue to next feature\n**IMMEDIATELY proceed to next feature without stopping.**\n\n### 4. Batch Status Update (AFTER ALL COMPLETE)\n\n**Only after ALL features processed:**\n\nFor each feature in `completed_features`:\n- Edit YAML: `status: under-test`\n- Update timestamp\n\nNote: Requirements already at `in-development` from verification step.\n\n### 5. Final Summary\n\n```\n## Implementation Complete\n\n### Features (status → under-test)\n| Feature | Requirements Verified |\n|---------|----------------------|\n| F-XXX | 3/3 ✓ |\n| F-YYY | 2/2 ✓ |\n\n### Requirements (status → in-development)\n| Requirement | Feature | Status |\n|-------------|---------|--------|\n| R-0001 | F-XXX | ✓ verified |\n| R-0002 | F-XXX | ✓ verified |\n\n### Failed (if any)\n| Feature | Issue |\n|---------|-------|\n| F-ZZZ | Could not verify R-0005 |\n\n### Next Steps\n1. Run tests\n2. Review changes\n3. Update to 'released' when verified\n```\n\n## Example Execution\n\n```\n> /implement\n\n## Finding Approved Features\nFound 2 approved features with 4 total requirements.\n\n## Analyzing Dependencies\n[Launching implementation-order agent...]\n\n### Dependency Graph\n```mermaid\ngraph TD\n    F-049[F-049: Pet Management] --> F-200[F-200: Pet Health]\n```\n\nF-200 depends on F-049 (explicit: depends-on in YAML)\n\n## Implementation Plan\n| Order | Feature | Dependencies | Requirements |\n|-------|---------|--------------|--------------|\n| 1 | F-049 | None (root) | R-0001, R-0002 |\n| 2 | F-200 | F-049 | R-0003, R-0004 |\n\n---\n\n### Implementing F-049: Pet Management\n\nSetting status: approved → in-development\n\n**Invoking Command /feature-dev:feature-dev **\n[feature-dev implements feature]\n\n**Verifying requirements (parallel)...**\n- R-0001: Setting to in-development...\n- R-0002: Setting to in-development...\n\n[Launching 2 verification agents in parallel]\n\nVerification results:\n- R-0001: ✓ VERIFIED\n- R-0002: ✗ NOT_VERIFIED - missing POS validation\n\n**Fixing gaps...**\n[Invoking feature-dev with fix instructions]\n\n**Re-verifying R-0002...**\n- R-0002: ✓ VERIFIED\n\n**Verifying feature (deep)...**\n[Launching feature-verifier agent]\n\nFeature verification report:\n- Status: ⚠️ PARTIAL\n- Coverage: 75%\n- Gaps: 0 Critical, 1 Major (missing status transition validation)\n\n**Fixing feature gaps...**\n[Invoking feature-dev with gap details]\n\n**Re-verifying feature...**\n[Launching feature-verifier agent]\n\nFeature verification report:\n- Status: ✅ VERIFIED\n- Coverage: 95%\n- Gaps: 0 Critical, 0 Major, 1 Minor (missing API docs)\n\n✓ F-049 complete (requirements + feature verified)\n\n---\n\n### Implementing F-200: Pet Health Management\n\nSetting status: approved → in-development\n\n**Invoking /feature-dev:feature-dev...**\n[feature-dev implements feature]\n\n**Verifying requirements (parallel)...**\n[Launching 2 verification agents]\n\nVerification results:\n- R-0003: ✓ VERIFIED\n- R-0004: ✓ VERIFIED\n\n**Verifying feature (deep)...**\n[Launching feature-verifier agent]\n\nFeature verification report:\n- Status: ✅ VERIFIED\n- Coverage: 100%\n- Gaps: None\n\n✓ F-200 complete (requirements + feature verified)\n\n---\n\n## All Features Processed\n\nUpdating feature statuses to under-test...\n- F-049: ✓ under-test\n- F-200: ✓ under-test\n\n## Summary\n2/2 features implemented.\n4/4 requirements verified and at in-development.\n```\n\n## Key Reminders\n\n1. **Implementation-order agent first** - Use agent to analyze dependencies and determine optimal order (DAG + topological sort)\n2. **Feature-dev for implementation** - Always use Command /feature-dev:feature-dev\n3. **Requirement verification (parallel)** - Launch ALL requirement verifications simultaneously\n4. **Feature verification (deep)** - After requirements pass, verify overall feature with feature-verifier agent\n5. **Fix loop** - Keep fixing and re-verifying until all pass (requirements AND feature)\n6. **No stopping** - Process all features without pause\n",
        "plugins/speclan/commands/status.md": "---\nname: speclan:status\ndescription: Check SPECLAN project setup, installed plugins, and specification statistics\nallowed-tools:\n  - Read\n  - Bash\n  - Glob\n  - Grep\nargument-hint: \"[path]\"\n---\n\n# SPECLAN Status Command\n\nDisplay comprehensive status information about the SPECLAN project.\n\n## Instructions\n\nWhen invoked, perform these checks and display results in table format:\n\n### 1. Detect SPECLAN Directory\n\nSearch for speclan directory starting from provided path or current working directory:\n- Check common locations: `speclan/`, `specs/speclan/`, `.speclan/`\n- Verify characteristic subdirectories: `goals/`, `features/`, `requirements/`\n\nIf not found, display error with setup instructions.\n\n### 2. Check Plugin Dependencies\n\nCheck if optional plugins are installed:\n- **speckit** - Required for `/speclan:from-speckit` and `/speclan:to-speckit`\n- **feature-dev** - Required for `/speclan:implement`\n\nDisplay installation status for each.\n\n### 3. Count Specifications by Type\n\nCount spec files in each category:\n\n| Entity | Directory | Pattern |\n|--------|-----------|---------|\n| Goals | `goals/` | `G-*.md` |\n| Features | `features/` | `F-*.md` (recursive) |\n| Requirements | `requirements/` or within features | `R-*.md` |\n| Scenarios | within requirements | `S-*.md` |\n| Acceptance Criteria | within scenarios | `AC-*.md` |\n| Tests | within criteria | `T-*.md` |\n| Templates | `templates/` | `*.md` |\n\n### 4. Analyze Status Distribution\n\nParse YAML frontmatter to count specs by status:\n- draft\n- review\n- approved\n- in-development\n- under-test\n- released\n- deprecated\n\n### 5. Check Coverage\n\nCalculate coverage metrics:\n- Features with at least one requirement\n- Requirements with at least one scenario\n- Approved features ready for implementation\n\n### 6. Display Results\n\nPresent as formatted tables:\n\n```\n## SPECLAN Project Status\n\n**Directory:** /path/to/speclan\n\n### Specification Counts\n| Entity | Count |\n|--------|-------|\n| Goals | X |\n| Features | X |\n| ... | ... |\n\n### Status Distribution\n| Status | Count |\n|--------|-------|\n| approved | X |\n| draft | X |\n| ... | ... |\n\n### Plugin Dependencies\n| Plugin | Status | Required For |\n|--------|--------|--------------|\n| speckit | Installed/Missing | from-speckit, to-speckit |\n| feature-dev | Installed/Missing | implement |\n\n### Coverage\n| Metric | Value |\n|--------|-------|\n| Features with requirements | X% |\n| Requirements with scenarios | X% |\n| Approved features | X |\n```\n\n## Error Handling\n\nIf SPECLAN directory not found:\n```\nError: No SPECLAN directory found in this project.\n\nTo set up SPECLAN, create:\n  speclan/\n  ├── goals/\n  ├── features/\n  └── requirements/\n```\n\nIf plugin missing and user tries dependent command, show:\n```\nError: [plugin] plugin is not installed.\n\nInstall with: [installation instructions]\n```\n",
        "plugins/speclan/commands/sync-from-session.md": "---\nname: speclan:sync\ndescription: Sync SPECLAN specs from session work - identifies implemented features and updates specs\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - AskUserQuestion\n  - TodoWrite\nargument-hint: \"[--dry-run] [hints...]\"\n---\n\n# SPECLAN Sync from Session\n\nAnalyze the current session to identify implemented features and sync them to SPECLAN specifications.\n\n## Core Philosophy: Implementation Reveals Specification Gaps\n\n**Specifications written before implementation are incomplete by nature.** Real implementation work exposes:\n\n- **Missing requirements** - Edge cases, error handling, validation rules discovered during coding\n- **Implicit assumptions** - Behaviors that were obvious to implement but never documented\n- **Integration points** - Dependencies and interactions only visible when building\n- **User experience details** - UI flows, feedback mechanisms, accessibility considerations\n\n**This command treats implementation as the source of truth.** When code does something useful that isn't in the spec, the spec is incomplete - not the code.\n\n### When to Add Requirements\n\nAdd new requirements when implementation reveals:\n\n| Implementation Pattern | Likely Missing Requirement |\n|------------------------|---------------------------|\n| Error handling/validation | Input validation rules, error messages |\n| Retry logic, timeouts | Reliability/resilience requirements |\n| Caching, optimization | Performance requirements |\n| Logging, metrics | Observability requirements |\n| Permission checks | Authorization requirements |\n| Edge case handling | Boundary condition requirements |\n| Default values | Configuration/defaults requirements |\n| User feedback (toasts, spinners) | UX feedback requirements |\n\n## Instructions\n\n### 1. Parse Arguments\n\n**Flags:**\n- `--dry-run` - Show what would be created/updated without making changes\n\n**User Hints (optional free-form text):**\nAfter flags, the user may provide guidance to help focus the analysis:\n\n```\n/speclan:sync focus on the auth changes, don't miss the token refresh logic\n/speclan:sync --dry-run look at src/api/ folder, we added new endpoints\n/speclan:sync important: the rate limiting feature, also check the middleware\n```\n\n**Hint Categories:**\n| Hint Type | Keywords | Purpose |\n|-----------|----------|---------|\n| Focus areas | \"focus on\", \"look at\", \"check\" | Direct attention to specific code/features |\n| Must-include | \"don't miss\", \"important\", \"make sure\" | Ensure specific items are captured |\n| Exclusions | \"ignore\", \"skip\", \"not relevant\" | Avoid false positives |\n| Context | \"we added\", \"new feature\", \"bugfix for\" | Clarify intent of changes |\n\n### 2. Process User Hints\n\nIf hints provided, extract and categorize:\n\n```yaml\nuser_guidance:\n  focus_areas:\n    - \"auth changes\"\n    - \"src/api/ folder\"\n  must_include:\n    - \"token refresh logic\"\n    - \"rate limiting feature\"\n  exclusions: []\n  context:\n    - \"new endpoints added\"\n    - \"middleware changes\"\n```\n\nUse this guidance to:\n1. **Prioritize** - Analyze focus areas first and more thoroughly\n2. **Validate** - Cross-check must-include items are captured in results\n3. **Filter** - Skip excluded areas during analysis\n4. **Interpret** - Use context to better understand change intent\n\n### 3. Load Skill Knowledge\n\nApply the `Sync Specs from Session` skill for detailed workflow guidance.\n\n### 3. Analyze Session Context\n\nReview the conversation history to identify implementation work:\n\n#### 3.1 Scan for Code Changes\n\nLook for evidence of implementation:\n- **File writes/edits**: Write and Edit tool usage\n- **New functions/classes**: Code patterns added\n- **API endpoints**: Routes, handlers, controllers\n- **Data models**: Schema changes, type definitions\n- **Tests added**: Test files created or modified\n\n#### 3.2 Extract Feature Candidates\n\nFor each identified change, determine:\n- **Title**: Descriptive name for the feature\n- **Description**: What it does and why\n- **Code paths**: Files involved\n- **Type**: new feature, enhancement, or bugfix\n\n#### 3.3 Infer Requirements from Implementation\n\n**Critical step:** Analyze implemented code to discover undocumented requirements:\n\n```\nFor each code change, ask:\n1. What user-visible behavior does this enable?\n2. What edge cases does this handle?\n3. What validation/error handling was added?\n4. What performance/reliability concerns does this address?\n5. What dependencies or integrations does this require?\n```\n\n**Example inference:**\n```\nCode: if (retries > 3) throw new Error('Max retries exceeded')\nInferred requirement: \"System shall retry failed operations up to 3 times before failing\"\n\nCode: toast.success('Changes saved')\nInferred requirement: \"System shall provide visual feedback when changes are saved\"\n\nCode: if (!user.hasPermission('admin')) return 403\nInferred requirement: \"Only administrators can access this functionality\"\n```\n\n#### 3.4 Group Related Changes\n\nConsolidate related changes:\n- Multiple files for one feature = single feature entry\n- Independent changes = separate feature entries\n\n### 4. Detect Speclan Directory\n\n```bash\n# Find speclan directory\nif [ -d \"speclan/features\" ]; then\n  echo \"Found: speclan/\"\nelif [ -d \"specs/speclan/features\" ]; then\n  echo \"Found: specs/speclan/\"\nelse\n  echo \"No speclan directory found\"\nfi\n```\n\nIf no speclan directory exists, ask user if they want to initialize one.\n\n### 5. Index Existing Specs\n\nIf speclan exists, use the SPECLAN Query skill to build an index:\n\n```bash\n# List all features with full metadata (JSON output)\n\"${PLUGIN_ROOT}/skills/speclan-query/scripts/query.sh\" --type feature --full speclan\n\n# List requirements for a specific feature\n\"${PLUGIN_ROOT}/skills/speclan-query/scripts/query.sh\" --type requirement --parent F-1234 --full speclan\n\n# Filter by status (e.g., find editable features)\n\"${PLUGIN_ROOT}/skills/speclan-query/scripts/query.sh\" --type feature --filter-status draft --full speclan\n```\n\n**Output format (JSON):**\n```json\n[\n  {\"id\":\"F-1234\",\"slug\":\"my-feature\",\"type\":\"feature\",\"path\":\"speclan/features/F-1234-my-feature/F-1234-my-feature.md\",\"title\":\"My Feature\",\"status\":\"draft\"}\n]\n```\n\nUse this to:\n1. Find features that match session work\n2. Determine if features are editable or locked\n3. Identify where to add new requirements\n\n### 6. Compare and Classify Changes\n\nFor each feature candidate from session analysis:\n\n| Match Result | Classification | Action |\n|--------------|----------------|--------|\n| No match in speclan | CREATE | New feature spec |\n| Matches existing, status editable | UPDATE | Modify existing spec |\n| Matches existing, status locked | CHANGE_REQUEST | Create CR |\n| Implementation detail of existing feature | ADD_REQUIREMENT | New requirement |\n\n**Editable statuses:** draft, review, approved\n**Locked statuses:** in-development, under-test, released, deprecated\n\n#### 6.1 Prioritize Requirement Discovery\n\n**Most syncs should produce new requirements, not just feature updates.**\n\nWhen analyzing implementation against existing specs:\n\n1. **Read the existing feature spec thoroughly**\n2. **Compare each implemented behavior against documented scope**\n3. **For each undocumented behavior, create a requirement**\n\n```\nExisting spec says: \"Users can save their preferences\"\nImplementation adds: retry logic, validation, success toast, error handling\n\n→ Add requirements:\n  - R-####: \"Preference saves shall retry up to 3 times on failure\"\n  - R-####: \"Invalid preference values shall show validation error\"\n  - R-####: \"Successful save shall display confirmation message\"\n  - R-####: \"Failed save shall display actionable error message\"\n```\n\n**Rule of thumb:** If you wrote more than 20 lines of code for a feature, there's probably at least one missing requirement.\n\n### 7. Present Changes to User\n\nShow identified changes and ask for confirmation:\n\n```markdown\n## Session Analysis Results\n\nBased on this session, I identified:\n\n### New Features (CREATE)\n1. **[Title]** - [Description]\n\n### Updates to Existing Features (UPDATE)\n1. **[F-####] [Title]** - [What changed]\n   - Status: [status] (editable)\n\n### Change Requests Needed (LOCKED)\n1. **[F-####] [Title]** - Cannot edit directly\n   - Status: [status] (locked)\n   - Proposed change: [description]\n\n### New Requirements\n1. For **[F-####]**: [Requirement title]\n```\n\nUse AskUserQuestion:\n\n```yaml\nquestions:\n  - question: \"Which changes should I apply to SPECLAN specs?\"\n    header: \"Apply\"\n    multiSelect: true\n    options:\n      - label: \"Create: [Feature Title]\"\n        description: \"New feature spec\"\n      - label: \"Update: F-#### [Title]\"\n        description: \"Add [change] to existing feature\"\n      # ... additional options\n```\n\n### 8. Handle Dry Run\n\nIf `--dry-run` flag provided:\n- Show all changes that would be made\n- Do NOT write any files\n- Report: \"Dry run complete. No changes made.\"\n\n### 9. Apply Selected Changes\n\nFor each user-selected change:\n\n#### ID Generation (MUST USE)\n\n**DO NOT create your own ID generator.** Use this collision-safe algorithm:\n\n```bash\n# Generate unique Feature ID (4-digit, F-1000 to F-9999)\ngenerate_feature_id() {\n  local speclan_dir=\"${1:-speclan}\"\n  for attempt in $(seq 1 100); do\n    local num=$((RANDOM % 9000 + 1000))\n    local id=\"F-${num}\"\n    if [ ! -d \"$speclan_dir\" ] || \\\n       (! find \"$speclan_dir\" -name \"${id}-*\" 2>/dev/null | grep -q . && \\\n        ! grep -r \"^id: ${id}$\" \"$speclan_dir\" 2>/dev/null | grep -q .); then\n      echo \"$id\"\n      return 0\n    fi\n  done\n  echo \"ERROR: Could not generate unique ID\" >&2\n  return 1\n}\n\n# Generate unique Requirement ID (4-digit, R-1000 to R-9999)\ngenerate_requirement_id() {\n  local speclan_dir=\"${1:-speclan}\"\n  for attempt in $(seq 1 100); do\n    local num=$((RANDOM % 9000 + 1000))\n    local id=\"R-${num}\"\n    if [ ! -d \"$speclan_dir\" ] || \\\n       (! find \"$speclan_dir\" -name \"${id}-*\" 2>/dev/null | grep -q . && \\\n        ! grep -r \"^id: ${id}$\" \"$speclan_dir\" 2>/dev/null | grep -q .); then\n      echo \"$id\"\n      return 0\n    fi\n  done\n  echo \"ERROR: Could not generate unique ID\" >&2\n  return 1\n}\n\n# Generate unique Change Request ID (4-digit, CR-1000 to CR-9999)\ngenerate_cr_id() {\n  local speclan_dir=\"${1:-speclan}\"\n  for attempt in $(seq 1 100); do\n    local num=$((RANDOM % 9000 + 1000))\n    local id=\"CR-${num}\"\n    if [ ! -d \"$speclan_dir\" ] || \\\n       (! find \"$speclan_dir\" -name \"${id}-*\" 2>/dev/null | grep -q . && \\\n        ! grep -r \"^id: ${id}$\" \"$speclan_dir\" 2>/dev/null | grep -q .); then\n      echo \"$id\"\n      return 0\n    fi\n  done\n  echo \"ERROR: Could not generate unique ID\" >&2\n  return 1\n}\n```\n\n#### 9.1 Create New Features\n\n1. Generate feature ID and get owner:\n   ```bash\n   FEATURE_ID=$(generate_feature_id speclan)\n   OWNER=$(git config --get user.email)\n   ```\n\n2. Create directory and file:\n   ```bash\n   SLUG=$(echo \"[title]\" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd 'a-z0-9-')\n   mkdir -p \"speclan/features/${FEATURE_ID}-${SLUG}/requirements\"\n   ```\n\n3. Write feature spec with frontmatter:\n   ```yaml\n   ---\n   id: [FEATURE_ID]\n   type: feature\n   title: [Title]\n   status: under-test\n   owner: [OWNER from git config --get user.email]\n   created: \"[ISO-8601]\"\n   updated: \"[ISO-8601]\"\n   goals: []\n   ---\n\n   # [Title]\n\n   ## Overview\n   [Description - focus on WHAT and WHY, not HOW]\n\n   ## Scope\n   - [User-facing functionality points]\n   ```\n\n**IMPORTANT:** Specs must be implementation-agnostic. Do NOT include:\n- Code paths, file names, or technical locations\n- Implementation details or internal architecture\n- Code fragments or snippets\n\nFocus on WHAT the feature does for users, not HOW it's built.\n\n#### 9.2 Update Existing Features\n\n1. Read current feature file\n2. Update relevant sections (scope, implementation notes)\n3. Update `updated` timestamp\n4. Write file back\n\n#### 9.3 Create Change Requests\n\nFor locked features or requirements:\n\n1. Generate CR ID:\n   ```bash\n   CR_ID=$(generate_cr_id speclan)\n   ```\n\n2. Create CR in entity's change-requests directory:\n   ```bash\n   # For features:\n   mkdir -p \"speclan/features/[feature-dir]/change-requests\"\n\n   # For requirements:\n   mkdir -p \"speclan/features/.../requirements/[requirement-dir]/change-requests\"\n   ```\n\n3. Write CR file with proper frontmatter (parentType: feature or requirement)\n\n#### 9.4 Create New Requirements\n\n1. Generate requirement ID:\n   ```bash\n   REQ_ID=$(generate_requirement_id speclan)\n   SLUG=$(echo \"[title]\" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd 'a-z0-9-')\n   ```\n2. Create requirement directory:\n   ```bash\n   mkdir -p \"speclan/features/[feature-dir]/requirements/${REQ_ID}-${SLUG}\"\n   ```\n3. Write requirement file to directory:\n   ```\n   speclan/features/[feature-dir]/requirements/${REQ_ID}-${SLUG}/${REQ_ID}-${SLUG}.md\n   ```\n4. Update parent feature's `updated` timestamp\n\n### 10. Report Results\n\n```markdown\n## Sync Complete\n\n### Created\n- F-#### [Title] → speclan/features/F-####-slug/\n- R-#### [Title] → speclan/features/F-####/requirements/R-####-slug/\n\n### Updated\n- F-#### [Title] - added [changes]\n\n### Change Requests\n- CR-#### for F-#### → speclan/features/F-####/change-requests/\n- CR-#### for R-#### → speclan/.../requirements/R-####/change-requests/\n\n### Skipped\n- [Any items user didn't select]\n\n### Next Steps\n- Review created specs for accuracy\n- Assign goals to new features\n- Process pending change requests\n- Run /speclan:status to verify structure\n```\n\n## Examples\n\n```bash\n# Sync session work to specs\n/speclan:sync\n\n# Preview without making changes\n/speclan:sync --dry-run\n```\n",
        "plugins/speclan/commands/to-speckit.md": "---\nname: speclan:to-speckit\ndescription: Inject approved SPECLAN Features into speckit for specification processing\nallowed-tools:\n  - Read\n  - Write\n  - Bash\n  - Glob\n  - Grep\n  - Skill\nargument-hint: \"[feature-ids...]\"\n---\n\n# SPECLAN To-Speckit Command\n\nInject approved SPECLAN Features into speckit commands for specification processing.\n\n## Prerequisites\n\nThis command requires:\n- **speckit plugin** - Must be installed for `/speckit.specify` command\n\n## Instructions\n\n### 1. Check Plugin Dependency\n\nVerify speckit plugin is installed:\n\n```bash\n# Check if speckit commands are available\n```\n\nIf not installed:\n```\nError: speckit plugin is not installed.\n\nThe /speclan:to-speckit command requires speckit to be installed.\n\nInstall speckit plugin:\n  [installation instructions]\n\nThis command injects SPECLAN specifications into speckit's /speckit.specify command.\n```\n\n### 2. Find Approved Features\n\nQuery SPECLAN directory for features with `status: approved`:\n\n```bash\n# Search for approved features in YAML frontmatter\ngrep -r \"^status: approved\" speclan/features/ -l\n```\n\nIf no approved features found:\n```\nNo approved features found.\n\nTo approve a feature for specification:\n1. Edit the feature file\n2. Change status from 'draft' to 'approved'\n3. Run /speclan:to-speckit again\n\nCurrent feature statuses:\n| Feature | Status |\n|---------|--------|\n| F-001 | draft |\n| F-002 | review |\n| ... | ... |\n```\n\n### 3. Collect Feature Content\n\nFor each approved feature, gather:\n- Feature description and user stories\n- All linked requirements\n- Scenarios and acceptance criteria\n- Business rules\n\n### 4. Generate Concatenated Specification\n\nCreate a combined specification document:\n\n```markdown\n# Specification Package for Speckit\n\nGenerated: [timestamp]\nSource: SPECLAN specifications\n\n---\n\n## Feature: [F-XXX] [Title]\n\n[Full feature content]\n\n### Requirements\n\n#### [R-XXXX] [Title]\n\n[Requirement content with scenarios]\n\n---\n\n## Feature: [F-YYY] [Title]\n\n[Next feature...]\n```\n\n### 5. Invoke Speckit\n\n**Note:** This integration is TBD pending speckit API clarification.\n\nCurrent approach:\n1. Write concatenated spec to temporary file\n2. Invoke `/speckit.specify` with the file\n3. Or display spec for manual processing\n\n```\nPrepared specification package with [X] approved features.\n\n## Included Features\n- F-001: [Title]\n- F-002: [Title]\n\n## Specification Package\n[Path to generated file]\n\nTo process with speckit:\n  /speckit.specify [path-to-spec-package]\n```\n\n### 6. Handle Partial Selection\n\nIf user provides specific feature IDs:\n- Only include specified features\n- Verify each is approved (warn if not)\n- Allow override with confirmation\n\n```\n/speclan:to-speckit F-001 F-003\n\nIncluding specified features:\n- F-001: approved ✓\n- F-003: draft ⚠ (not approved)\n\nProceed with F-003 despite draft status? [y/N]\n```\n\n## Output Format\n\n### Success\n```\n## Speckit Injection Ready\n\n### Approved Features Included\n| ID | Title | Requirements |\n|----|-------|--------------|\n| F-001 | Core Extension | 5 |\n| F-002 | Live Updates | 3 |\n\n### Generated Package\nLocation: /tmp/speclan-to-speckit-[timestamp].md\nSize: [X] KB\nTotal Requirements: [Y]\nTotal Scenarios: [Z]\n\n### Next Step\nRun: /speckit.specify /tmp/speclan-to-speckit-[timestamp].md\n```\n\n### No Features Ready\n```\nNo features ready for speckit processing.\n\nFeature Status Summary:\n| Status | Count |\n|--------|-------|\n| draft | 5 |\n| review | 2 |\n| approved | 0 |\n\nApprove features by updating their status to 'approved' in YAML frontmatter.\n```\n\n## Integration Notes\n\n**TBD:** The exact integration with speckit is pending clarification:\n- How `/speckit.specify` accepts input\n- Required format for specification injection\n- Expected output from speckit processing\n\nFor now, this command prepares specifications in a format suitable for manual speckit processing.\n",
        "plugins/speclan/hooks/hooks.json": "{\n  \"description\": \"SPECLAN plugin hooks for context detection and skill injection\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash $CLAUDE_PLUGIN_ROOT/hooks/scripts/detect-context.sh\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Read|Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash $CLAUDE_PLUGIN_ROOT/hooks/scripts/inject-skill.sh\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "plugins/speclan/hooks/scripts/detect-context.sh": "#!/bin/bash\n# SPECLAN Context Detection Hook\n# Runs at session start to detect speclan directory and installed plugins\n#\n# Outputs context information for Claude and persists environment variables\n\n# Minimal error handling - hooks must not fail on \"not found\" conditions\n\n# Colors for output\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nRED='\\033[0;31m'\nNC='\\033[0m' # No Color\n\nPROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-.}\"\n\n# --- Detection Functions ---\n\ndetect_speclan_dir() {\n    local dir=\"$1\"\n    local speclan_dirs=(\"speclan\" \"specs/speclan\" \".speclan\")\n    local markers=(\"goals\" \"features\" \"requirements\")\n\n    for speclan_name in \"${speclan_dirs[@]}\"; do\n        local candidate=\"$dir/$speclan_name\"\n        if [[ -d \"$candidate\" ]]; then\n            local marker_count=0\n            for marker in \"${markers[@]}\"; do\n                if [[ -d \"$candidate/$marker\" ]]; then\n                    ((marker_count++))\n                fi\n            done\n            if [[ $marker_count -ge 2 ]]; then\n                echo \"$candidate\"\n                return 0\n            fi\n        fi\n    done\n    return 1\n}\n\ncheck_plugin_installed() {\n    local plugin_name=\"$1\"\n    # Check if plugin commands are available by looking for skill triggers\n    # This is a heuristic - plugins register their skills\n    if command -v claude &> /dev/null; then\n        # Try to detect via claude's internal plugin registry\n        # For now, use a simple file-based check\n        local plugin_dirs=(\n            \"$HOME/.claude/plugins\"\n            \"$HOME/.claude-plugins\"\n            \".claude-plugins\"\n        )\n        for pdir in \"${plugin_dirs[@]}\"; do\n            if [[ -d \"$pdir/$plugin_name\" ]]; then\n                return 0\n            fi\n        done\n    fi\n    return 1\n}\n\ncount_specs() {\n    local speclan_dir=\"$1\"\n    local type=\"$2\"\n    local pattern=\"$3\"\n\n    if [[ -d \"$speclan_dir/$type\" ]]; then\n        find \"$speclan_dir/$type\" -name \"$pattern\" -type f 2>/dev/null | wc -l | tr -d ' '\n    else\n        echo \"0\"\n    fi\n}\n\ncount_by_status() {\n    local speclan_dir=\"$1\"\n    local status=\"$2\"\n\n    # Count specs with specific status in YAML frontmatter\n    # Use || true to handle no matches gracefully\n    grep -r \"^status: $status\" \"$speclan_dir\" 2>/dev/null | wc -l | tr -d ' ' || echo \"0\"\n}\n\n# --- Main Detection ---\n\noutput=\"\"\nenv_output=\"\"\n\n# Detect SPECLAN directory\nspeclan_dir=\"\"\ncurrent=\"$PROJECT_DIR\"\nwhile [[ \"$current\" != \"/\" ]]; do\n    if result=$(detect_speclan_dir \"$current\" 2>/dev/null); then\n        speclan_dir=\"$result\"\n        break\n    fi\n    current=$(dirname \"$current\")\ndone\n\nif [[ -n \"$speclan_dir\" ]]; then\n    output+=\"## SPECLAN Project Detected\\n\\n\"\n    output+=\"**Speclan Directory:** \\`$speclan_dir\\`\\n\\n\"\n\n    # Persist to environment\n    env_output+=\"export SPECLAN_DIR=\\\"$speclan_dir\\\"\\n\"\n\n    # Count specifications\n    goals=$(count_specs \"$speclan_dir\" \"goals\" \"G-*.md\")\n    features=$(count_specs \"$speclan_dir\" \"features\" \"F-*.md\")\n    requirements=$(count_specs \"$speclan_dir\" \"requirements\" \"R-*.md\")\n\n    # Count by status\n    approved=$(count_by_status \"$speclan_dir\" \"approved\")\n    draft=$(count_by_status \"$speclan_dir\" \"draft\")\n    in_dev=$(count_by_status \"$speclan_dir\" \"in-development\")\n\n    output+=\"### Specification Summary\\n\\n\"\n    output+=\"| Entity | Count |\\n\"\n    output+=\"|--------|-------|\\n\"\n    output+=\"| Goals | $goals |\\n\"\n    output+=\"| Features | $features |\\n\"\n    output+=\"| Requirements | $requirements |\\n\"\n    output+=\"\\n\"\n\n    output+=\"### Status Distribution\\n\\n\"\n    output+=\"| Status | Count |\\n\"\n    output+=\"|--------|-------|\\n\"\n    output+=\"| Approved | $approved |\\n\"\n    output+=\"| Draft | $draft |\\n\"\n    output+=\"| In Development | $in_dev |\\n\"\n    output+=\"\\n\"\n\n    env_output+=\"export SPECLAN_GOALS_COUNT=\\\"$goals\\\"\\n\"\n    env_output+=\"export SPECLAN_FEATURES_COUNT=\\\"$features\\\"\\n\"\n    env_output+=\"export SPECLAN_REQUIREMENTS_COUNT=\\\"$requirements\\\"\\n\"\n    env_output+=\"export SPECLAN_APPROVED_COUNT=\\\"$approved\\\"\\n\"\nelse\n    output+=\"## No SPECLAN Directory Found\\n\\n\"\n    output+=\"This project does not appear to have a SPECLAN specification directory.\\n\"\n    output+=\"To use SPECLAN, create a \\`speclan/\\` directory with \\`goals/\\`, \\`features/\\`, and \\`requirements/\\` subdirectories.\\n\\n\"\nfi\n\n# Check for optional plugin dependencies\noutput+=\"### Plugin Dependencies\\n\\n\"\noutput+=\"| Plugin | Status |\\n\"\noutput+=\"|--------|--------|\\n\"\n\n# Check speckit\nif check_plugin_installed \"speckit\"; then\n    output+=\"| speckit | Installed |\\n\"\n    env_output+=\"export SPECLAN_HAS_SPECKIT=\\\"true\\\"\\n\"\nelse\n    output+=\"| speckit | Not installed |\\n\"\n    env_output+=\"export SPECLAN_HAS_SPECKIT=\\\"false\\\"\\n\"\nfi\n\n# Check feature-dev\nif check_plugin_installed \"feature-dev\"; then\n    output+=\"| feature-dev | Installed |\\n\"\n    env_output+=\"export SPECLAN_HAS_FEATURE_DEV=\\\"true\\\"\\n\"\nelse\n    output+=\"| feature-dev | Not installed |\\n\"\n    env_output+=\"export SPECLAN_HAS_FEATURE_DEV=\\\"false\\\"\\n\"\nfi\n\noutput+=\"\\n\"\n\n# Persist environment variables if CLAUDE_ENV_FILE is available\nif [[ -n \"${CLAUDE_ENV_FILE:-}\" ]]; then\n    echo -e \"$env_output\" >> \"$CLAUDE_ENV_FILE\"\nfi\n\n# Output context for Claude\necho -e \"$output\"\n\n# Return JSON for systemMessage\ncat << EOF\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"SPECLAN context loaded. Speclan dir: ${speclan_dir:-none}. Use /speclan:status for details.\"\n}\nEOF\n",
        "plugins/speclan/hooks/scripts/inject-skill.sh": "#!/bin/bash\n# SPECLAN Skill Injection Hook\n# Injects speclan-format skill reference when accessing speclan files\n\n# Get file path from tool input\nFILE_PATH=$(echo \"$CLAUDE_TOOL_INPUT\" | jq -r '.file_path // .path // \"\"' 2>/dev/null)\n\n# Check if this is a speclan file\nif [[ \"$FILE_PATH\" == *\"/speclan/\"* ]] || [[ \"$FILE_PATH\" == *\"/specs/speclan/\"* ]] || [[ \"$FILE_PATH\" == *\"/.speclan/\"* ]]; then\n  cat << 'EOF'\n{\n  \"continue\": true,\n  \"systemMessage\": \"Working with SPECLAN file. Apply 'SPECLAN Format' skill: use proper YAML frontmatter (id, type, title, status, owner, created, updated), maintain entity relationships (Goals→Features→Requirements), use correct ID prefixes (G-, F-, R-, CR-), and follow status workflow (draft→review→approved→in-development→under-test→released).\"\n}\nEOF\nelse\n  echo '{\"continue\": true}'\nfi\n",
        "plugins/speclan/skills/speclan-format/SKILL.md": "---\nname: SPECLAN Format\ndescription: >-\n  **ALWAYS INJECT** this skill when working with files in PROJECTROOT/speclan/ directory.\n\n  This is foundational knowledge for ALL speclan operations - reading, creating, updating, or deleting spec files. Without this context, Claude will create incorrect file structures, invalid IDs, or broken relationships.\n\n  Triggers: ANY operation on speclan/ files, \"read feature\", \"list requirements\", \"create feature\", \"new requirement\", \"update spec\", \"delete change-request\", \"speclan directory\", \"spec hierarchy\", \"ID format\", or any mention of SPECLAN entity types (Goal, Feature, Requirement, Scenario, ChangeRequest).\nversion: 0.2.0\n---\n\n# SPECLAN Format Knowledge\n\n**THIS IS FOUNDATIONAL CONTEXT.** Apply these rules to ALL speclan file operations.\n\nSPECLAN (Specification as a Living Language) manages project specifications as interlinked markdown files with YAML frontmatter in a hierarchical directory structure.\n\n## Quick Reference (CRITICAL)\n\n### Filename IS the Source of Truth\n\nThe **directory/filename pattern** `{PREFIX}-{ID}-{slug}` is authoritative:\n\n```\nF-1049-pet-management/F-1049-pet-management.md\n│  │    │              └─ File MUST match directory name\n│  │    └─ Kebab-case slug from title\n│  └─ 4-digit numeric ID (randomly generated)\n└─ Entity prefix (F=Feature, R=Requirement, etc.)\n```\n\n**Extract ID from filename, NOT frontmatter** for indexing and collision checks.\n\n### Entity Prefixes\n\n| Entity | Prefix | Digits | Example | Storage |\n|--------|--------|--------|---------|---------|\n| Goal | G- | 3 | G-292 | `goals/G-292-slug.md` (flat) |\n| Feature | F- | 4 | F-1049 | `features/F-1049-slug/F-1049-slug.md` (dir) |\n| Requirement | R- | 4 | R-2046 | `features/.../requirements/R-2046-slug/R-2046-slug.md` (dir) |\n| Change Request | CR- | 4 | CR-0731 | `{parent}/change-requests/CR-0731-slug.md` (flat) |\n| Scenario | S- | 4 | S-0001 | `requirements/.../scenarios/S-0001-slug/` (dir) |\n\n### Status Determines Editability\n\n| Editable (direct edit OK) | Locked (needs Change Request) |\n|---------------------------|------------------------------|\n| draft, review, approved | in-development, under-test, released, deprecated |\n\n## Directory Structure\n\nSPECLAN specifications live in `${PROJECT}/speclan/`:\n\n```\nspeclan/\n├── goals/                    # G-### Business goals (flat)\n├── features/                 # F-#### Feature hierarchy\n│   └── F-1049-pet-management/\n│       ├── F-1049-pet-management.md      # Feature file matches directory\n│       ├── requirements/                  # Requirements as directories\n│       │   ├── R-2046-health-check/\n│       │   │   ├── R-2046-health-check.md\n│       │   │   ├── change-requests/       # CRs for this requirement\n│       │   │   └── scenarios/             # Scenarios for this requirement\n│       │   └── R-3272-status-tracking/\n│       │       └── R-3272-status-tracking.md\n│       ├── change-requests/               # CRs for this feature\n│       │   └── CR-0731-add-feature.md\n│       └── F-1200-pet-health/             # Child feature (nested)\n│           └── F-1200-pet-health.md\n├── templates/                # Templates (UUID in frontmatter, slug filename)\n│   ├── features/\n│   ├── requirements/\n│   ├── scenarios/\n│   ├── acceptance-criteria/\n│   └── tests/\n└── change-requests/          # Root-level change requests\n```\n\n**Key structural rules:**\n- **Features and Requirements use directory-based storage** - directory name must match contained markdown filename\n- Requirements are nested inside their parent feature's `requirements/` directory as subdirectories\n- Child features are subdirectories of parent features\n- Change requests live in `change-requests/` adjacent to the entity they modify (features OR requirements)\n\n## Entity Hierarchy\n\n```\nGoal (G-###)\n  └── Feature (F-####)  [forms hierarchical tree via directories]\n        └── Requirement (R-####)\n              └── Scenario (S-####)\n                    └── AcceptanceCriterion (AC-####)\n                          └── Test (T-####)\n```\n\nAdditional entities:\n- **Template** (UUID v4) - Reusable spec templates\n- **ChangeRequest** (CR-####) - Modifications to released entities\n\n## ID Format Conventions\n\n| Entity | Format | Example | Storage Location |\n|--------|--------|---------|------------------|\n| Goal | `G-###` | G-292 | `goals/` (flat files) |\n| Feature | `F-####` | F-1049 | `features/` (hierarchical directories) |\n| Requirement | `R-####` | R-2046 | `features/{feature}/requirements/` (directories) |\n| Scenario | `S-####` | S-0001 | `requirements/{requirement}/scenarios/` (directories) |\n| AcceptanceCriterion | `AC-####` | AC-0001 | *Not yet implemented* |\n| Test | `T-####` | T-0001 | *Not yet implemented* |\n| ChangeRequest | `CR-####` | CR-0731 | `{entity}/change-requests/` (flat files) |\n| Template | UUID v4 | bf5cb38b-... | `templates/{type}/` (flat files) |\n\n**ID Generation:** All numeric IDs are **randomly generated** with collision detection (not sequential). Always check existing IDs before creating new ones.\n\n**ID-Based Ordering:** IDs determine artifact priority/order numerically:\n- **Lower IDs = Higher priority** (processed/displayed first)\n- **Higher IDs = Lower priority** (processed/displayed later)\n- Example: F-1049 has higher priority than F-2847\n- This ordering applies within the same entity type (features sorted among features, requirements among requirements, etc.)\n\n## File Naming Convention\n\nFiles follow pattern: `<ID>-kebab-case-title.md`\n\nExamples:\n- `G-292-comprehensive-pet-retail-operations.md` (flat file in goals/)\n- `F-1049-pet-management/F-1049-pet-management.md` (directory-based)\n- `R-2046-health-check/R-2046-health-check.md` (directory-based)\n\n**Directory-based entities** (Features, Requirements, Scenarios):\n- Directory name **must match** the contained markdown filename\n- Example: `F-1049-pet-management/F-1049-pet-management.md`\n- Example: `R-2046-health-check/R-2046-health-check.md`\n\nTemplate filenames use **kebab-case slugs** (UUID stored in frontmatter only):\n- `basic-feature.md`\n- `functional-requirement.md`\n\n## Markdown File Format\n\nEvery spec file has YAML frontmatter followed by markdown content:\n\n```markdown\n---\nid: F-1049\ntype: feature\ntitle: Pet Management\nstatus: draft\nowner: Store Manager\ncreated: \"2025-12-29T09:53:49.355Z\"\nupdated: \"2025-12-29T10:31:04.445Z\"\ngoals:\n  - G-292\n  - G-087\n---\n\n# Pet Management\n\n## Overview\nBrief description of what this feature does and why it exists.\n\n## User Story\nAs a **Store Manager**, I want **comprehensive tools** so that **I can track pets**.\n\n## Scope\n- Pet Tracking\n- Status Management\n- Health Records\n```\n\n## Common YAML Frontmatter Fields\n\n**All entities share:**\n```yaml\nid: <entity-id>           # Required\ntype: <entity-type>       # Required: goal|feature|requirement|scenario|acceptanceCriterion|test|template|changeRequest\ntitle: <string>           # Required\nstatus: <status>          # Required: draft|review|approved|in-development|under-test|released|deprecated\nowner: <string>           # Required\ncreated: <ISO-8601>       # Required\nupdated: <ISO-8601>       # Required\ntags: [<string>, ...]     # Optional\n```\n\n**Entity-specific fields** - See `references/entity-fields.md` for complete reference.\n\n## Status Lifecycle\n\nEntities follow a 7-stage lifecycle:\n\n```\ndraft → review → approved → in-development → under-test → released → deprecated\n```\n\n| Status | Editable | Description |\n|--------|----------|-------------|\n| `draft` | Yes | Initial creation, work in progress |\n| `review` | Yes | Ready for review |\n| `approved` | Yes | Approved, ready for development |\n| `in-development` | **No** | Currently being implemented |\n| `under-test` | **No** | Implementation complete, testing |\n| `released` | **No** | Deployed to production |\n| `deprecated` | **No** | No longer active (terminal state) |\n\n**Read-only statuses:** Entities in `in-development`, `under-test`, `released`, or `deprecated` are locked. Direct edits are not allowed - changes require a **Change Request** (`CR-####`).\n\n## Validation Rules\n\nWhen creating or updating SPECLAN entities, enforce these validation rules to ensure structure compliance.\n\n### Required YAML Frontmatter Fields\n\nAll entities MUST have these fields present and non-empty:\n\n| Field | Validation |\n|-------|------------|\n| `id` | Must match entity-specific ID format (see below) |\n| `type` | Must be one of: `goal`, `feature`, `requirement`, `scenario`, `acceptanceCriterion`, `test`, `template`, `changeRequest` |\n| `title` | Non-empty string |\n| `status` | Must be valid status value for entity type |\n| `owner` | Non-empty string (role, person, or team) |\n| `created` | Valid ISO-8601 timestamp |\n| `updated` | Valid ISO-8601 timestamp, must be >= `created` |\n\n### ID Format Validation\n\nEach entity type has a strict ID format:\n\n| Entity | Regex Pattern | Valid Examples | Invalid Examples |\n|--------|---------------|----------------|------------------|\n| Goal | `^G-\\d{3}$` | G-142, G-999 | G-42, G-1234, G-ABC |\n| Feature | `^F-\\d{4}$` | F-1049, F-9999 | F-049, F-12345, f-1234 |\n| Requirement | `^R-\\d{4}$` | R-2046, R-1000 | R-046, R-99999 |\n| Scenario | `^S-\\d{4}$` | S-0001, S-5432 | S-1, S-12345 |\n| AcceptanceCriterion | `^AC-\\d{4}$` | AC-0001, AC-9999 | AC-1, ac-0001 |\n| Test | `^T-\\d{4}$` | T-0001, T-1234 | T-1, T-12345 |\n| ChangeRequest | `^CR-\\d{4}$` | CR-0731, CR-9999 | CR-01, CR-12345 |\n| Template | UUID v4 | `bf5cb38b-7417-...` | Any non-UUID |\n\n**Validation regex (JavaScript):**\n```javascript\nconst ID_PATTERNS = {\n  goal: /^G-\\d{3}$/,\n  feature: /^F-\\d{4}$/,\n  requirement: /^R-\\d{4}$/,\n  scenario: /^S-\\d{4}$/,\n  acceptanceCriterion: /^AC-\\d{4}$/,\n  test: /^T-\\d{4}$/,\n  changeRequest: /^CR-\\d{4}$/,\n  template: /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n};\n```\n\n### Directory and File Naming Enforcement\n\n**Directory-based entities** (Feature, Requirement, Scenario):\n\n1. Directory name MUST match the markdown filename inside\n2. Format: `<ID>-<kebab-case-title>/`\n3. Contained file: `<ID>-<kebab-case-title>.md`\n\n**Validation rules:**\n```\n# Valid\nF-1049-pet-management/F-1049-pet-management.md    ✓\nR-2046-health-check/R-2046-health-check.md        ✓\n\n# Invalid\nF-1049-pet-management/F-1049.md                   ✗ (filename mismatch)\nF-1049/F-1049-pet-management.md                   ✗ (directory name incomplete)\nf-1049-pet-management/F-1049-pet-management.md    ✗ (case mismatch)\n```\n\n**Flat-file entities** (Goal, ChangeRequest):\n\n1. File format: `<ID>-<kebab-case-title>.md`\n2. Placed directly in parent directory (no subdirectory)\n\n### Parent-Child Relationship Validation\n\nEntities must correctly reference their parents:\n\n| Entity | Required Parent Field | Parent Type | Validation |\n|--------|----------------------|-------------|------------|\n| Feature | `goals` (array) | Goal | Each ID must exist as `G-###` in `speclan/goals/` |\n| Requirement | `feature` (string) | Feature | Must be valid `F-####` that exists |\n| Scenario | `requirement` (string) | Requirement | Must be valid `R-####` that exists |\n| AcceptanceCriterion | `scenario` (string) | Scenario | Must be valid `S-####` that exists |\n| Test | `criterion` (string) | AcceptanceCriterion | Must be valid `AC-####` that exists |\n| ChangeRequest | `parentId` + `parentType` | Feature/Requirement | Parent must exist and parentType must match |\n\n**Directory placement validation:**\n- Requirements MUST be in `features/<parent-feature>/requirements/`\n- Scenarios MUST be in `requirements/<parent-requirement>/scenarios/`\n- Child features MUST be in `features/<parent-feature>/`\n- ChangeRequests MUST be in `<parent-entity>/change-requests/`\n\n### Status Lifecycle Rules\n\n#### Valid Status Values\n\n**Standard entities** (Goal, Feature, Requirement, Scenario, AC, Test):\n```\ndraft | review | approved | in-development | under-test | released | deprecated\n```\n\n**ChangeRequest entities:**\n```\npending | draft | review | approved | in-development | under-test | merged | closed\n```\n\n#### Editability Rules\n\n| Status | Direct Edit Allowed | Change Request Required |\n|--------|--------------------|-----------------------|\n| `draft` | Yes | No |\n| `review` | Yes | No |\n| `approved` | Yes | No |\n| `in-development` | **No** | **Yes** |\n| `under-test` | **No** | **Yes** |\n| `released` | **No** | **Yes** |\n| `deprecated` | **No** | **Yes** |\n\n**CRITICAL:** Before modifying any entity, check its status:\n\n```bash\n# Extract status from frontmatter\nstatus=$(grep \"^status:\" \"$file\" | head -1 | cut -d: -f2 | tr -d ' ')\n\n# Check if read-only\ncase \"$status\" in\n  in-development|under-test|released|deprecated)\n    echo \"Entity is read-only. Change Request required.\"\n    ;;\n  *)\n    echo \"Entity is editable.\"\n    ;;\nesac\n```\n\n#### When Change Requests Are Required\n\nA ChangeRequest (`CR-####`) MUST be created when:\n\n1. **Entity is in read-only status** (`in-development`, `under-test`, `released`, `deprecated`)\n2. **Proposing breaking changes** to any entity regardless of status\n3. **Deprecating an entity** (status change to `deprecated`)\n4. **Requesting feature removal** or significant scope reduction\n\n**ChangeRequest workflow:**\n```\n1. Create CR in <entity>/change-requests/\n2. CR status: pending → draft → review → approved → in-development → merged\n3. When merged, apply changes to parent entity\n4. Update parent entity's `updated` timestamp\n```\n\n### Status Transition Rules\n\nValid status transitions (forward progression):\n\n```\ndraft → review → approved → in-development → under-test → released → deprecated\n```\n\n**Special transitions:**\n- `review → draft` (rejection/revision)\n- `approved → draft` (re-planning)\n- Any status → `deprecated` (via Change Request if read-only)\n\n**Invalid transitions:**\n- `released → in-development` (regression - use Change Request instead)\n- `deprecated → any` (terminal state)\n\n### Entity-Specific Field Validation\n\n#### Goal (`G-###`)\n\n| Field | Required | Validation |\n|-------|----------|------------|\n| `contributors` | No | Array of valid `F-####` IDs |\n| `metrics` | No | Array of `{name, target, unit}` objects |\n\n#### Feature (`F-####`)\n\n| Field | Required | Validation |\n|-------|----------|------------|\n| `goals` | Yes | Non-empty array of valid `G-###` IDs |\n| `requirements` | No | Array of valid `R-####` IDs |\n| `bundlePath` | No | Valid relative path string |\n\n#### Requirement (`R-####`)\n\n| Field | Required | Validation |\n|-------|----------|------------|\n| `feature` | Yes | Valid `F-####` ID that exists |\n| `scenarios` | Yes | Non-empty array of valid `S-####` IDs |\n\n#### ChangeRequest (`CR-####`)\n\n| Field | Required | Validation |\n|-------|----------|------------|\n| `parentId` | Yes | Valid entity ID (F-####, R-####, etc.) |\n| `parentType` | Yes | `feature`, `requirement`, `scenario`, etc. |\n| `changeType` | Yes | `enhancement`, `bugfix`, `breaking`, `deprecation`, `documentation` |\n| `description` | Yes | Non-empty string |\n| `changes` | Yes | Non-empty string (detailed narrative) |\n\n### Validation Checklist\n\nBefore creating/updating any SPECLAN entity, verify:\n\n- [ ] ID format matches entity type regex\n- [ ] All required fields present and non-empty\n- [ ] `type` field matches expected entity type\n- [ ] `status` is valid for entity type\n- [ ] Parent references (if any) point to existing entities\n- [ ] File/directory naming matches convention\n- [ ] File placed in correct directory location\n- [ ] If entity is read-only, Change Request exists\n- [ ] `updated` timestamp is current ISO-8601\n- [ ] Bidirectional links maintained (e.g., feature lists requirement, requirement references feature)\n\n## Linking Between Specs\n\n### YAML Frontmatter References\n\n```yaml\n# Goal references features\ncontributors:\n  - F-1049\n  - F-2247\n\n# Feature references goals\ngoals:\n  - G-292\n  - G-087\n\n# Requirement references parent feature\nfeature: F-1009\n\n# Requirement references scenarios\nscenarios:\n  - S-0001\n  - S-0002\n```\n\n### Markdown Cross-References\n\nUse relative paths in markdown content:\n\n```markdown\n## Related\n### Goals\n- [Animal Welfare Compliance](../goals/G-087-animal-welfare-compliance.md)\n\n### Features\n- [Pet Status Lifecycle](../F-1807-pet-status-lifecycle/F-1807-pet-status-lifecycle.md)\n```\n\n## Working with SPECLAN Files\n\n### Detecting SPECLAN Directory\n\nTo find the speclan directory in a project:\n\n1. Check common locations: `speclan/`, `specs/speclan/`\n2. Look for characteristic subdirectories: `goals/`, `features/`, `requirements/`\n3. Verify markdown files with SPECLAN YAML frontmatter\n\n### Reading Specifications\n\nWhen reading a spec file:\n1. Parse YAML frontmatter for metadata\n2. Extract entity relationships from frontmatter fields\n3. Parse markdown content for documentation\n\n### Creating New Specifications\n\nTo create a new spec:\n\n1. **Check for user templates FIRST:**\n   ```\n   speclan/templates/<entity-type>/\n   ```\n   - `speclan/templates/features/` for feature templates\n   - `speclan/templates/requirements/` for requirement templates\n   - `speclan/templates/scenarios/` for scenario templates\n\n   Read available templates and choose the best fit. Templates contain the user's preferred structure.\n\n2. **Generate a unique ID:**\n   - IDs are **randomly generated** (not sequential)\n   - Goals: 3-digit (e.g., G-249)\n   - Features/Requirements/Scenarios/etc.: 4-digit (e.g., F-1049, R-2046)\n   - **Always check for collisions** before using:\n     ```bash\n     # Check existing Feature IDs\n     find speclan/features -type d -name 'F-*' | grep -oE 'F-[0-9]+' | sort -u\n     # Check existing Requirement IDs\n     find speclan/features -type d -name 'R-*' | grep -oE 'R-[0-9]+' | sort -u\n     ```\n\n3. **Create file in correct location:**\n\n   **For Goals:** `speclan/goals/G-###-slug.md` (flat file)\n\n   **For Features:** Create directory AND file with matching name:\n   ```\n   speclan/features/F-####-slug/F-####-slug.md\n   ```\n\n   **For Requirements:** Create directory inside parent feature's `requirements/`:\n   ```\n   speclan/features/F-####-parent/requirements/R-####-slug/R-####-slug.md\n   ```\n\n   **For Child Features:** Nest inside parent feature directory:\n   ```\n   speclan/features/F-####-parent/F-####-child/F-####-child.md\n   ```\n\n   **For Scenarios:** Nest inside parent requirement directory:\n   ```\n   speclan/features/.../requirements/R-####-parent/scenarios/S-####-slug/S-####-slug.md\n   ```\n\n4. **Write frontmatter and content:**\n   - Use template if found, otherwise use default structure\n   - Set all required fields (id, type, title, status, owner, created, updated)\n   - For requirements, set `feature: F-####` to link to parent\n\n5. **Update related entities** to establish bidirectional links\n\n### Updating Specifications\n\nWhen modifying a spec:\n1. Update the `updated` timestamp\n2. Maintain bidirectional links (if adding feature to goal, add goal to feature)\n3. Follow status transition rules\n\n## Writing Guidelines\n\nFor guidance on writing effective specifications, consult `references/writing-guide.md`.\n\nKey principles:\n- Write user-focused, implementation-agnostic specifications\n- Include clear acceptance criteria\n- Maintain traceability between entities\n- Use consistent terminology\n\n## Additional Resources\n\n### Reference Files\n\n- **`references/entity-fields.md`** - Complete YAML field reference for all entity types\n- **`references/writing-guide.md`** - Best practices for writing specifications\n\n### Related Skills\n\n- **`speclan-id-generator`** - Generate collision-free unique IDs for SPECLAN entities\n\n### Utility Scripts\n\n- **`scripts/detect-speclan.sh`** - Detect speclan directory in a project\n",
        "plugins/speclan/skills/speclan-format/references/entity-fields.md": "# SPECLAN Entity Field Reference\n\nComplete YAML frontmatter field reference for all SPECLAN entity types.\n\n## Common Fields (All Entities)\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `id` | string | Yes | Entity ID in type-specific format |\n| `type` | string | Yes | Entity type identifier |\n| `title` | string | Yes | Human-readable title |\n| `status` | string | Yes | Current lifecycle status |\n| `owner` | string | Yes | Responsible team/person |\n| `created` | ISO-8601 | Yes | Creation timestamp |\n| `updated` | ISO-8601 | Yes | Last modification timestamp |\n| `tags` | string[] | No | Classification tags |\n\n### Status Values\n\n```\ndraft | review | approved | in-development | under-test | released | deprecated\n```\n\n### Type Values\n\n```\ngoal | feature | requirement | scenario | acceptanceCriterion | test | template | changeRequest\n```\n\n---\n\n## Goal (G-###)\n\nStrategic objectives that features contribute to achieving.\n\n### Goal-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `contributors` | FeatureId[] | No | Features contributing to this goal |\n| `metrics` | Metric[] | No | Success measurement criteria |\n\n### Metric Object\n\n```yaml\nmetrics:\n  - name: \"Inventory Management Efficiency\"\n    target: \"60% reduction in manual tasks\"\n    unit: \"percent\"\n```\n\n### Example Goal\n\n```yaml\n---\nid: G-292\ntype: goal\ntitle: Comprehensive Pet Retail Operations\nstatus: draft\nowner: Store Owner\ncreated: '2025-12-29T09:51:56.458Z'\nupdated: '2025-12-29'\ncontributors:\n  - F-1049\n  - F-2247\n  - F-3344\nmetrics:\n  - name: Inventory Management Efficiency\n    target: 60% reduction in manual tasks\n    unit: percent\n  - name: Sales Performance\n    target: 15% increase in transaction value\n    unit: percent\n---\n```\n\n---\n\n## Feature (F-####)\n\nCapabilities that deliver value to users. Features form a hierarchical tree.\n\n### Feature-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `goals` | GoalId[] | Yes | Goals this feature contributes to |\n| `requirements` | RequirementId[] | No | Child requirements (typically for leaf features) |\n| `bundlePath` | string | No | Relative path to bundle directory |\n\n### Feature Hierarchy\n\nFeatures nest via directory structure:\n\n```\nfeatures/\n└── F-1049-pet-management/          # Parent feature\n    ├── F-1049-pet-management.md\n    └── F-1200-pet-health/          # Child feature\n        └── F-1200-pet-health.md\n```\n\n### Example Feature\n\n```yaml\n---\nid: F-1049\ntype: feature\ntitle: Pet Management\nstatus: draft\nowner: Store Manager\ncreated: \"2025-12-29T09:53:49.355Z\"\nupdated: \"2025-12-29T10:31:04.445Z\"\ngoals:\n  - G-292\n  - G-087\n---\n```\n\n---\n\n## Requirement (R-####)\n\nSpecific conditions that must be satisfied by a feature.\n\n### Requirement Storage\n\nRequirements use **directory-based storage** (like features):\n\n```\nfeatures/F-####-parent/requirements/\n└── R-2046-health-check/\n    ├── R-2046-health-check.md    # Requirement file\n    ├── change-requests/           # CRs for this requirement\n    └── scenarios/                 # Child scenarios\n```\n\n### Requirement-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `feature` | FeatureId | Yes | Parent feature ID |\n| `scenarios` | ScenarioId[] | Yes | Validation scenarios (at least one) |\n\n### Example Requirement\n\n```yaml\n---\nid: R-2046\ntype: requirement\ntitle: Pets in quarantine or medical hold cannot be sold\nstatus: draft\nowner: Product Team\ncreated: \"2025-12-29T08:09:34.064Z\"\nupdated: \"2025-12-29T10:49:13.890Z\"\nfeature: F-1009\nscenarios:\n  - S-0001\n  - S-0002\n---\n```\n\n---\n\n## Scenario (S-####)\n\nSpecific situations that validate a requirement.\n\n### Scenario-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `requirement` | RequirementId | Yes | Parent requirement ID |\n| `acceptanceCriteria` | ACId[] | Yes | Acceptance criteria (at least one) |\n\n### Example Scenario\n\n```yaml\n---\nid: S-0001\ntype: scenario\ntitle: Attempt to add quarantined pet to cart\nstatus: draft\nowner: QA Team\ncreated: \"2025-12-29T08:10:00.000Z\"\nupdated: \"2025-12-29T08:10:00.000Z\"\nrequirement: R-0001\nacceptanceCriteria:\n  - AC-0001\n  - AC-0002\n---\n```\n\n---\n\n## AcceptanceCriterion (AC-####)\n\nSpecific conditions that must be met for a scenario to pass.\n\n### AcceptanceCriterion-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `scenario` | ScenarioId | Yes | Parent scenario ID |\n| `tests` | TestId[] | Yes | Linked tests (at least one) |\n\n### Example AcceptanceCriterion\n\n```yaml\n---\nid: AC-0001\ntype: acceptanceCriterion\ntitle: System displays error message for quarantined pet\nstatus: draft\nowner: QA Team\ncreated: \"2025-12-29T08:11:00.000Z\"\nupdated: \"2025-12-29T08:11:00.000Z\"\nscenario: S-0001\ntests:\n  - T-0001\n---\n```\n\n---\n\n## Test (T-####)\n\nVerification procedures for acceptance criteria.\n\n### Test-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `criterion` | ACId | Yes | Parent acceptance criterion ID |\n| `kind` | string | Yes | `automated` or `manual` |\n| `framework` | string | No | Test framework (Jest, Mocha, etc.) |\n| `ref` | TestRef | No | Code reference |\n\n### TestRef Object\n\n```yaml\nref:\n  repo: \"https://github.com/org/repo\"  # Optional\n  path: \"tests/pet-sales.spec.ts\"       # Required if ref exists\n  selector: \"describe('Pet Sales')\"     # Optional\n```\n\n### Example Test\n\n```yaml\n---\nid: T-0001\ntype: test\ntitle: Verify quarantine check on cart add\nstatus: draft\nowner: QA Team\ncreated: \"2025-12-29T08:12:00.000Z\"\nupdated: \"2025-12-29T08:12:00.000Z\"\ncriterion: AC-0001\nkind: automated\nframework: Jest\nref:\n  path: \"tests/pet-sales.spec.ts\"\n  selector: \"it('blocks quarantined pets')\"\n---\n```\n\n---\n\n## Template (UUID v4)\n\nReusable specification templates.\n\n### Template-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `templateFor` | string | Yes | Entity type this templates: feature, requirement, scenario, acceptanceCriterion, test |\n| `description` | string | No | Template description |\n| `sections` | string[] | No | Template sections/headings |\n| `isSystemTemplate` | boolean | No | Built-in vs custom template |\n\n### Example Template\n\n```yaml\n---\nid: \"bf5cb38b-7417-4063-b82b-ab5ab185f512\"\ntype: template\ntitle: Basic Feature\nstatus: released\nowner: system\ncreated: \"2025-12-27\"\nupdated: \"2025-12-27\"\ndescription: Simple feature template with overview and scope sections\nisSystemTemplate: true\ntemplateFor: feature\n---\n```\n\n---\n\n## ChangeRequest (CR-####)\n\nProposed modifications to released or locked entities.\n\n### ChangeRequest-Specific Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `parentId` | string | Yes | ID of entity being modified |\n| `parentType` | string | Yes | Type of entity being modified |\n| `changeType` | string | Yes | enhancement, bugfix, breaking, deprecation, documentation |\n| `description` | string | Yes | Change description |\n| `changes` | string | Yes | Detailed change narrative |\n| `closedReason` | string | No | Why CR was closed |\n| `supersededBy` | CRId | No | Superseding CR ID |\n| `mergedAt` | ISO-8601 | No | Merge timestamp |\n| `mergedBy` | string | No | Person who merged |\n\n### ChangeRequest Status Values\n\n```\npending | draft | review | approved | in-development | under-test | merged | closed\n```\n\n### Example ChangeRequest\n\n```yaml\n---\nid: CR-0001\ntype: changeRequest\ntitle: Add microchipping validation to pet sales\nstatus: pending\nowner: Product Team\ncreated: \"2025-12-29T12:00:00.000Z\"\nupdated: \"2025-12-29T12:00:00.000Z\"\nparentId: R-0001\nparentType: requirement\nchangeType: enhancement\ndescription: Extend pet sale validation to check microchipping status\nchanges: |\n  Add validation step to verify pets requiring microchipping\n  (dogs and cats) have been properly chipped before sale.\n---\n```\n\n---\n\n## Field Validation Rules\n\n### ID Formats\n\n| Entity | Pattern | Regex |\n|--------|---------|-------|\n| Goal | G-### | `^G-\\d{3}$` |\n| Feature | F-#### | `^F-\\d{4}$` |\n| Requirement | R-#### | `^R-\\d{4}$` |\n| Scenario | S-#### | `^S-\\d{4}$` |\n| AcceptanceCriterion | AC-#### | `^AC-\\d{4}$` |\n| Test | T-#### | `^T-\\d{4}$` |\n| ChangeRequest | CR-#### | `^CR-\\d{4}$` |\n| Template | UUID v4 | `^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$` |\n\n### ID-Based Ordering\n\nIDs determine artifact priority/order numerically within each entity type:\n\n| ID | Priority |\n|----|----------|\n| Lower numeric value | Higher priority (first) |\n| Higher numeric value | Lower priority (last) |\n\n**Examples:**\n- G-100 > G-500 > G-899 (goals sorted by ID)\n- F-1049 > F-2500 > F-9999 (features sorted by ID)\n- R-1000 > R-5000 > R-9500 (requirements sorted by ID)\n\nUse this ordering for:\n- Display order in tree views\n- Processing order in reports\n- Implementation priority suggestions\n\n### Date Formats\n\n- Full timestamp: `\"2025-12-29T09:53:49.355Z\"`\n- Date only: `\"2025-12-29\"` or `'2025-12-29'`\n\n### Owner Values\n\n- Role: `\"Store Manager\"`, `\"Pet Care Specialist\"`\n- Person: `\"John Doe\"`\n- Team: `\"Frontend Team\"`, `\"QA\"`\n- System: `\"system\"` (for templates)\n",
        "plugins/speclan/skills/speclan-format/references/writing-guide.md": "# SPECLAN Writing Guide\n\nBest practices for writing effective, maintainable specifications.\n\n## Core Principles\n\n### 1. User-Focused\n\nWrite specifications from the user's perspective, not the developer's.\n\n**Good:**\n```markdown\nUsers can filter pets by health status to quickly find animals\nready for sale.\n```\n\n**Avoid:**\n```markdown\nThe filterPets() function accepts a status parameter and queries\nthe database with a WHERE clause.\n```\n\n### 2. Implementation-Agnostic\n\nDescribe WHAT the system should do, not HOW it should be implemented.\n\n**Good:**\n```markdown\nThe system prevents sale of pets in quarantine or medical hold status.\n```\n\n**Avoid:**\n```markdown\nAdd a check in the CartService.addItem() method that throws\nValidationException if pet.status is QUARANTINE or MEDICAL_HOLD.\n```\n\n### 3. Testable\n\nEvery requirement should have clear, measurable acceptance criteria.\n\n**Good:**\n```markdown\nGiven a pet with status QUARANTINE\nWhen a user attempts to add it to cart\nThen the system displays error \"Pet not available for sale\"\nAnd the cart remains unchanged\n```\n\n**Avoid:**\n```markdown\nThe system should handle quarantined pets appropriately.\n```\n\n### 4. Traceable\n\nMaintain clear links between entities in the hierarchy.\n\n```\nGoal G-087 (Animal Welfare)\n  └── Feature F-049 (Pet Management)\n        └── Requirement R-0001 (No quarantine sales)\n              └── Scenario S-0001 (Cart add attempt)\n                    └── AC-0001 (Error displayed)\n                          └── Test T-0001 (Automated check)\n```\n\n---\n\n## Writing Goals\n\nGoals define strategic business objectives.\n\n### Structure\n\n```markdown\n---\n[YAML frontmatter]\n---\n\n## Overview\n[1-2 paragraphs explaining the goal's purpose and business value]\n\n## Strategic Context\n[Why this goal matters, market/business drivers]\n\n## Success Criteria\n[Measurable outcomes that indicate goal achievement]\n\n## Contributing Features\n[List of features that help achieve this goal]\n```\n\n### Tips\n\n- Focus on business outcomes, not technical solutions\n- Include quantifiable metrics where possible\n- Link to all contributing features\n- Keep goals broad enough to encompass multiple features\n\n### Example\n\n```markdown\n## Overview\nEnable pet stores to maintain healthy, well-cared-for animals while\nensuring compliance with local animal welfare regulations.\n\n## Success Criteria\n- **Compliance Rate**: 100% compliance with health check schedules\n- **Incident Reduction**: 50% reduction in animal health incidents\n- **Customer Satisfaction**: 90%+ positive feedback on pet health\n```\n\n---\n\n## Writing Features\n\nFeatures describe capabilities that deliver user value.\n\n### Structure\n\n```markdown\n---\n[YAML frontmatter]\n---\n\n# [Feature Title]\n\n## Overview\n[Brief description of what this feature does and why]\n\n## User Story\nAs a **[user role]**, I want **[capability]** so that **[benefit]**.\n\n## Scope\n\n### In Scope\n- [Key capability 1]\n- [Key capability 2]\n\n### Out of Scope\n- [Explicitly excluded items]\n\n## Key Business Rules\n| Rule ID | Description |\n|---------|-------------|\n| [ID] | [Rule description] |\n\n## Related Entities\n- **[Entity]**: [How it relates to this feature]\n```\n\n### Tips\n\n- One clear user story per feature\n- Explicitly state what's out of scope\n- Reference business rules by ID\n- For parent features, describe how children relate\n\n### Leaf vs Parent Features\n\n**Parent features** (have child features):\n- Describe the organizing container\n- List child features in scope\n- May have fewer requirements directly attached\n\n**Leaf features** (no children):\n- More detailed specifications\n- Direct requirements attached\n- Specific acceptance criteria\n\n---\n\n## Writing Requirements\n\nRequirements specify conditions that must be satisfied.\n\n### Structure\n\n```markdown\n---\n[YAML frontmatter]\n---\n\n[One-line requirement statement]\n\n## Rationale\n[Why this requirement exists, what problem it solves]\n\n## Business Rule Reference\n- **[Rule ID]**: [Rule description]\n\n## Acceptance Criteria\n\n### Scenario 1: [Scenario name]\n**Given** [initial state]\n**When** [action]\n**Then** [expected outcome]\n\n### Scenario 2: [Scenario name]\n**Given** [initial state]\n**When** [action]\n**Then** [expected outcome]\n\n## Edge Cases\n- [Edge case 1 and expected behavior]\n- [Edge case 2 and expected behavior]\n\n## Related\n### Goals\n- [Link to related goals]\n\n### Features\n- [Link to related features]\n```\n\n### Tips\n\n- Start with a clear, one-line requirement statement\n- Use Given/When/Then format for scenarios\n- Document edge cases explicitly\n- Include rationale to explain the \"why\"\n\n### Good Requirement Statements\n\n```markdown\nPets in quarantine or medical hold status cannot be sold.\n\nUsers receive email notification within 5 minutes of order placement.\n\nThe system retains transaction history for a minimum of 7 years.\n```\n\n### Avoid\n\n```markdown\nThe system should handle pet status appropriately.  # Too vague\n\nImplement validation in the checkout flow.  # Implementation detail\n\nMake sure pets can't be sold when they shouldn't be.  # Ambiguous\n```\n\n---\n\n## Writing Scenarios\n\nScenarios describe specific situations for validation.\n\n### Structure\n\n```markdown\n---\n[YAML frontmatter]\n---\n\n## Context\n[Background context for this scenario]\n\n## Steps\n\n**Given** [precondition 1]\n**And** [precondition 2]\n\n**When** [action taken]\n**And** [additional action if needed]\n\n**Then** [expected outcome 1]\n**And** [expected outcome 2]\n\n## Test Data\n| Field | Value |\n|-------|-------|\n| [field] | [value] |\n\n## Notes\n[Additional context or edge case considerations]\n```\n\n### Tips\n\n- One scenario per specific situation\n- Use concrete test data\n- Keep steps atomic and testable\n- Reference any required preconditions\n\n---\n\n## Writing Acceptance Criteria\n\nAcceptance criteria define specific conditions for scenario success.\n\n### Structure\n\n```markdown\n---\n[YAML frontmatter]\n---\n\n## Criterion\n[Clear, testable statement of what must be true]\n\n## Verification Method\n[How this criterion will be verified]\n\n## Expected Behavior\n| Condition | Expected Result |\n|-----------|-----------------|\n| [condition] | [result] |\n```\n\n### Tips\n\n- One clear condition per criterion\n- Must be objectively verifiable\n- Include expected behavior table for complex criteria\n\n---\n\n## Writing Tests\n\nTests document verification procedures.\n\n### Structure\n\n```markdown\n---\n[YAML frontmatter]\n---\n\n## Test Description\n[What this test verifies]\n\n## Prerequisites\n- [Prerequisite 1]\n- [Prerequisite 2]\n\n## Test Steps\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n\n## Expected Results\n- [Expected result 1]\n- [Expected result 2]\n\n## Code Reference\n[Link to automated test if applicable]\n```\n\n### Automated vs Manual\n\n**Automated tests:**\n- Include `kind: automated` in frontmatter\n- Reference test file and selector\n- Document test framework\n\n**Manual tests:**\n- Include `kind: manual` in frontmatter\n- Detailed step-by-step instructions\n- Clear pass/fail criteria\n\n---\n\n## Common Mistakes\n\n### 1. Mixing Requirements and Implementation\n\n**Wrong:**\n```markdown\nAdd a validatePetStatus() method that checks the database\nand throws an error if status is invalid.\n```\n\n**Right:**\n```markdown\nThe system validates pet status before allowing sale transactions.\n```\n\n### 2. Vague Acceptance Criteria\n\n**Wrong:**\n```markdown\nThe system should respond quickly.\n```\n\n**Right:**\n```markdown\nThe system responds to search queries within 500ms for 95th percentile.\n```\n\n### 3. Missing Traceability\n\n**Wrong:**\n```markdown\n# Requirement without linking to feature or scenarios\n```\n\n**Right:**\n```yaml\nfeature: F-049\nscenarios:\n  - S-0001\n  - S-0002\n```\n\n### 4. Incomplete Edge Cases\n\n**Wrong:**\n```markdown\nUsers can add pets to cart.\n```\n\n**Right:**\n```markdown\nUsers can add available pets to cart.\n\n## Edge Cases\n- Quarantined pets: Display error, block addition\n- Reserved pets: Display warning, allow waitlist\n- Out of stock: Display availability date\n```\n\n---\n\n## Terminology Consistency\n\nMaintain consistent terminology across specifications:\n\n| Term | Use For | Avoid |\n|------|---------|-------|\n| User | End user of the system | Customer, Client (unless specific) |\n| System | The software being specified | Application, App, Platform |\n| Display | Show on screen | Render, Output, Print |\n| Store | Persist data | Save, Write, Commit |\n| Retrieve | Fetch data | Get, Load, Read, Query |\n\nCreate a project glossary for domain-specific terms.\n\n---\n\n## Review Checklist\n\nBefore finalizing a specification:\n\n- [ ] Uses user-focused, non-technical language\n- [ ] Implementation-agnostic (describes WHAT, not HOW)\n- [ ] All required YAML fields present\n- [ ] Linked to parent/child entities\n- [ ] Acceptance criteria are testable\n- [ ] Edge cases documented\n- [ ] Consistent terminology\n- [ ] No ambiguous words (should, might, could, appropriate)\n- [ ] Dates and timestamps in ISO-8601 format\n- [ ] File naming follows convention\n",
        "plugins/speclan/skills/speclan-id-generator/SKILL.md": "---\nname: SPECLAN ID Generator\ndescription: This skill should be used when generating IDs for SPECLAN entities, creating new specs, or needing collision-free unique identifiers. Use when user asks to \"create a spec\", \"generate ID\", \"new feature ID\", \"unique requirement ID\", or when commands need to assign IDs to new entities.\nversion: 0.1.0\ncontext: fork\n---\n\n# SPECLAN ID Generator\n\nGenerate unique, collision-free random IDs for SPECLAN entities with automatic retry and comprehensive collision detection.\n\n## Why Use This Skill\n\n- **Collision-free:** Automatically checks existing IDs and retries if collision detected\n- **Entity-aware:** Correct format for each entity type (goals: 3-digit, others: 4-digit)\n- **Comprehensive detection:** Checks both filenames AND frontmatter\n- **Reusable:** Single script usable by all commands and agents\n\n## Entity ID Formats\n\n| Entity Type | Prefix | Digits | Range | Example |\n|-------------|--------|--------|-------|---------|\n| goal | G- | 3 | 100-999 | G-142 |\n| feature | F- | 4 | 1000-9999 | F-1847 |\n| requirement | R- | 4 | 1000-9999 | R-3928 |\n| change-request | CR- | 4 | 1000-9999 | CR-7291 |\n| scenario | S- | 4 | 1000-9999 | S-4521 |\n| acceptance-criterion | AC- | 4 | 1000-9999 | AC-2847 |\n| test | T- | 4 | 1000-9999 | T-1029 |\n\n**ID-Based Ordering:** IDs determine artifact priority numerically. Lower IDs = higher priority. When generating IDs for artifacts that should have specific priority relative to existing ones, consider the ID range carefully.\n\n## Usage\n\n### Script Location\n\n```\n${PLUGIN_ROOT}/skills/speclan-id-generator/scripts/generate-id.sh\n```\n\n### Command Line\n\n```bash\n./generate-id.sh <entity-type> [count] [speclan-dir]\n```\n\n**Arguments:**\n- `entity-type` - Required. One of: `goal`, `feature`, `requirement`, `change-request`, `scenario`, `acceptance-criterion`, `test`\n- `count` - Optional. Number of IDs to generate (default: 1)\n- `speclan-dir` - Optional. Path to speclan directory (defaults to `./speclan`)\n\n**Output:**\n- Success: Prints unique ID(s) to stdout, one per line\n- Failure: Prints error to stderr, exits with code 1\n\n### Examples\n\n```bash\n# Generate a single feature ID\n./generate-id.sh feature\n# Output: F-1847\n\n# Generate 5 requirement IDs at once\n./generate-id.sh requirement 5\n# Output:\n# R-3928\n# R-4521\n# R-7832\n# R-1293\n# R-5647\n\n# Generate 3 feature IDs with custom speclan path\n./generate-id.sh feature 3 /path/to/project/speclan\n# Output:\n# F-1142\n# F-2893\n# F-5467\n\n# Generate a change request ID\n./generate-id.sh change-request\n# Output: CR-7291\n```\n\n### In Commands/Agents\n\n```bash\n# Capture single ID\nFEATURE_ID=$(./skills/speclan-id-generator/scripts/generate-id.sh feature speclan)\necho \"Created feature: $FEATURE_ID\"\n\n# Generate multiple IDs at once (more efficient than multiple calls)\nREQ_IDS=$(./generate-id.sh requirement 5 speclan)\necho \"Created requirements:\"\necho \"$REQ_IDS\"\n\n# Parse multiple IDs into array\nmapfile -t REQ_ARRAY <<< \"$(./generate-id.sh requirement 3 speclan)\"\necho \"First: ${REQ_ARRAY[0]}, Second: ${REQ_ARRAY[1]}, Third: ${REQ_ARRAY[2]}\"\n\n# Or use read for bash 3.x compatibility\nIFS=$'\\n' read -d '' -r -a REQ_ARRAY <<< \"$(./generate-id.sh requirement 3 speclan)\" || true\n```\n\n### Session-Aware Collision Detection\n\nWhen generating multiple IDs in a single call, the script tracks generated IDs within the session to ensure no duplicates, even before they're written to disk. This is more efficient than making multiple separate calls.\n\n## Algorithm\n\nThe script implements a robust ID generation algorithm:\n\n```\n1. Parse entity type to get prefix, digit count, and range\n2. For up to 100 attempts:\n   a. Generate random number in range\n   b. Format as ID (e.g., F-2934)\n   c. Check for collisions:\n      - Search filenames: find speclan -name \"F-2934-*\"\n      - Search frontmatter: grep \"^id: F-2934$\"\n   d. If no collision, return ID\n3. If all attempts fail, exit with error\n```\n\n## Collision Detection\n\nThe script checks two locations for collisions:\n\n### 1. Filename/Directory Collision\n\nSearches for files or directories matching the ID pattern:\n```bash\nfind \"$speclan_dir\" -name \"${id}-*\" -o -name \"${id}.md\"\n```\n\nThis catches both directory-based and flat file entities:\n- `F-2934-my-feature/` (feature directory)\n- `R-4521-requirement/` (requirement directory)\n- `G-142-goal.md` (flat goal file)\n- `CR-1234-change.md` (flat change request file)\n\n### 2. Frontmatter Collision\n\nSearches for ID in YAML frontmatter:\n```bash\ngrep -r \"^id: ${id}$\" \"$speclan_dir\"\n```\n\nThis catches:\n- Files that were renamed but kept the original ID\n- IDs referenced but not yet written to files\n\n## Inline Algorithm (For Commands)\n\nIf the script is not available, commands can use this inline algorithm:\n\n```bash\n# Generate unique Feature ID (4-digit)\ngenerate_feature_id() {\n  local speclan_dir=\"${1:-speclan}\"\n  local max_attempts=100\n\n  for attempt in $(seq 1 $max_attempts); do\n    # Generate random 4-digit number (1000-9999)\n    local num=$((RANDOM % 9000 + 1000))\n    local id=\"F-${num}\"\n\n    # Check for collisions\n    if [ ! -d \"$speclan_dir\" ]; then\n      echo \"$id\"\n      return 0\n    fi\n\n    # Check filenames and frontmatter\n    if ! find \"$speclan_dir\" -name \"${id}-*\" 2>/dev/null | grep -q . && \\\n       ! grep -r \"^id: ${id}$\" \"$speclan_dir\" 2>/dev/null | grep -q .; then\n      echo \"$id\"\n      return 0\n    fi\n  done\n\n  echo \"ERROR: Could not generate unique ID\" >&2\n  return 1\n}\n\n# Generate unique Requirement ID (4-digit)\ngenerate_requirement_id() {\n  local speclan_dir=\"${1:-speclan}\"\n  local max_attempts=100\n\n  for attempt in $(seq 1 $max_attempts); do\n    # Generate random 4-digit number (1000-9999)\n    local num=$((RANDOM % 9000 + 1000))\n    local id=\"R-${num}\"\n\n    if [ ! -d \"$speclan_dir\" ]; then\n      echo \"$id\"\n      return 0\n    fi\n\n    if ! find \"$speclan_dir\" -name \"${id}-*\" 2>/dev/null | grep -q . && \\\n       ! grep -r \"^id: ${id}$\" \"$speclan_dir\" 2>/dev/null | grep -q .; then\n      echo \"$id\"\n      return 0\n    fi\n  done\n\n  echo \"ERROR: Could not generate unique ID\" >&2\n  return 1\n}\n\n# Usage\nFEATURE_ID=$(generate_feature_id speclan)\nREQ_ID=$(generate_requirement_id speclan)\n```\n\n## Error Handling\n\n| Exit Code | Meaning |\n|-----------|---------|\n| 0 | Success - ID printed to stdout |\n| 1 | Error - message printed to stderr |\n\n**Common errors:**\n- Invalid entity type\n- Could not generate unique ID after 100 attempts (ID space exhausted)\n- Missing required arguments\n\n## Integration\n\n### With `infer-from-codebase` Command\n\nThe command should use this skill for all ID generation:\n\n```markdown\n##### 3.4.4 Generate IDs\n\nUse the `speclan-id-generator` skill:\n\n\\`\\`\\`bash\nFEATURE_ID=$(./skills/speclan-id-generator/scripts/generate-id.sh feature speclan)\nREQ_ID=$(./skills/speclan-id-generator/scripts/generate-id.sh requirement speclan)\n\\`\\`\\`\n```\n\n### With Agents\n\nAgents should reference the inline algorithm from this skill when they need to suggest ID generation code.\n",
        "plugins/speclan/skills/speclan-query/SKILL.md": "---\nname: SPECLAN Query\ndescription: This skill should be used when querying SPECLAN specifications by type, status, or parent relationship. Use when user asks to \"list features\", \"find requirements\", \"show approved specs\", \"get children of feature\", \"index specs\", or needs to search/filter SPECLAN entities programmatically.\nversion: 0.1.0\ncontext: fork\n---\n\n# SPECLAN Query\n\nFast, flexible querying of SPECLAN entities with JSON output. Query by type, filter by status or parent, with optional full metadata extraction.\n\n## Why Use This Skill\n\n- **Fast**: Filename-based parsing without reading files (unless filters require it)\n- **Reliable**: Uses `{PREFIX}-{ID}-{slug}` naming pattern as source of truth\n- **Flexible**: Query any entity type, filter by status/parent\n- **Structured**: Clean JSON output for programmatic consumption\n- **zsh-safe**: Avoids reserved word conflicts (uses `entity_status` not `status`)\n\n## Entity Types\n\n| Type | Prefix | Pattern | Location |\n|------|--------|---------|----------|\n| goal | G- | G-###-*.md | goals/ |\n| feature | F- | F-####-*.md | features/ (recursive) |\n| requirement | R- | R-####-*.md | features/.../requirements/ |\n| scenario | S- | S-####-*.md | features/.../scenarios/ |\n| acceptance-criterion | AC- | AC-####-*.md | features/.../acceptance-criteria/ |\n| test | T- | T-####-*.md | features/.../tests/ |\n| change-request | CR- | CR-####-*.md | Anywhere in change-requests/ |\n\n## Usage\n\n### Script Location\n\n```\n${PLUGIN_ROOT}/skills/speclan-query/scripts/query.sh\n```\n\n### Command Line\n\n```bash\n./query.sh [OPTIONS] [speclan-dir]\n```\n\n**Options:**\n- `-t, --type TYPE` - Entity type to query (required)\n- `-s, --filter-status STATUS` - Filter by status (draft|review|approved|in-development|under-test|released|deprecated)\n- `-p, --parent ID` - Filter by parent ID (e.g., F-1234)\n- `-f, --full` - Include title and status in output (reads frontmatter)\n- `-h, --help` - Show usage\n\n**Arguments:**\n- `speclan-dir` - Path to speclan directory (default: ./speclan)\n\n**Output:**\n- JSON array to stdout\n- Errors to stderr\n- Exit code: 0 = success, 1 = error\n\n## Examples\n\n### List all features (fast - filename only)\n\n```bash\n./query.sh --type feature speclan\n```\n\nOutput:\n```json\n[\n  {\"id\":\"F-1049\",\"slug\":\"pet-management\",\"type\":\"feature\",\"path\":\"speclan/features/F-1049-pet-management/F-1049-pet-management.md\"},\n  {\"id\":\"F-2847\",\"slug\":\"user-auth\",\"type\":\"feature\",\"path\":\"speclan/features/F-2847-user-auth/F-2847-user-auth.md\"}\n]\n```\n\n### List features with full details\n\n```bash\n./query.sh --type feature --full speclan\n```\n\nOutput:\n```json\n[\n  {\"id\":\"F-1049\",\"slug\":\"pet-management\",\"type\":\"feature\",\"path\":\"...\",\"title\":\"Pet Management\",\"status\":\"draft\"},\n  {\"id\":\"F-2847\",\"slug\":\"user-auth\",\"type\":\"feature\",\"path\":\"...\",\"title\":\"User Authentication\",\"status\":\"approved\"}\n]\n```\n\n### Filter by status\n\n```bash\n./query.sh --type feature --filter-status approved speclan\n```\n\n### Find requirements for a feature\n\n```bash\n./query.sh --type requirement --parent F-1049 speclan\n```\n\n### Find change-requests for a requirement\n\n```bash\n./query.sh --type change-request --parent R-2046 speclan\n```\n\n### Combine filters\n\n```bash\n./query.sh --type requirement --parent F-1049 --filter-status approved --full speclan\n```\n\n### Query all entity types\n\n```bash\n./query.sh --type all speclan\n```\n\n## Query Modes\n\n### Fast Mode (Default)\n\nOnly parses filenames, no file content read:\n- Extracts ID and slug from filename pattern\n- Infers type from ID prefix\n- Fastest for simple listing\n\n**Activated when:** No `--full`, `--filter-status`, or `--parent` flags\n\n### Full Mode (Frontmatter Read)\n\nReads YAML frontmatter when needed:\n- Extract title, status from frontmatter\n- Required for filtering or full output\n\n**Activated when:** `--full`, `--filter-status`, or `--parent` specified\n\n## JSON Output Schema\n\n### Minimal (fast mode)\n\n```json\n{\n  \"id\": \"F-1049\",\n  \"slug\": \"pet-management\",\n  \"type\": \"feature\",\n  \"path\": \"speclan/features/F-1049-pet-management/F-1049-pet-management.md\"\n}\n```\n\n### Full (with --full flag)\n\n```json\n{\n  \"id\": \"F-1049\",\n  \"slug\": \"pet-management\",\n  \"type\": \"feature\",\n  \"path\": \"speclan/...\",\n  \"title\": \"Pet Management\",\n  \"status\": \"draft\"\n}\n```\n\n## Parent Filtering\n\nThe `--parent` flag checks multiple locations:\n\n1. **Structural parent** - ID appears in file path (e.g., `F-1049-slug/requirements/R-2046-slug/`)\n2. **Frontmatter fields** - `feature:`, `requirement:`, `parentId:`\n3. **Array fields** - Goals array (`- G-123`)\n\n## Integration Examples\n\n### In sync-from-session Command\n\n```bash\n# Index existing features\nFEATURES_JSON=$(\"${PLUGIN_ROOT}/skills/speclan-query/scripts/query.sh\" --type feature --full speclan)\n\n# Check if feature exists\nif echo \"$FEATURES_JSON\" | grep -q '\"id\":\"F-1049\"'; then\n  echo \"Feature exists\"\nfi\n\n# Get editable features (not locked)\nEDITABLE=$(\"${PLUGIN_ROOT}/skills/speclan-query/scripts/query.sh\" --type feature --filter-status draft speclan)\n```\n\n### Extract specific fields with grep\n\n```bash\n# Get all feature IDs\n./query.sh --type feature speclan | grep -oE '\"id\":\"[^\"]+\"' | cut -d'\"' -f4\n\n# Get all paths\n./query.sh --type feature speclan | grep -oE '\"path\":\"[^\"]+\"' | cut -d'\"' -f4\n\n# Count entities\n./query.sh --type requirement speclan | grep -c '\"id\"'\n```\n\n### Process each entity\n\n```bash\n./query.sh --type feature --full speclan | grep -oE '\"id\":\"[^\"]+\"' | cut -d'\"' -f4 | while read -r fid; do\n  echo \"Processing feature: $fid\"\n  req_count=$(./query.sh --type requirement --parent \"$fid\" speclan | grep -c '\"id\"' || echo 0)\n  echo \"  Requirements: $req_count\"\ndone\n```\n\n## Status Lifecycle Reference\n\n**Editable statuses** (can be modified directly):\n- `draft`\n- `review`\n- `approved`\n\n**Locked statuses** (require change-request):\n- `in-development`\n- `under-test`\n- `released`\n- `deprecated`\n\nUse this for classification:\n\n```bash\n# Get editable features\n./query.sh --type feature --filter-status draft speclan\n./query.sh --type feature --filter-status review speclan\n./query.sh --type feature --filter-status approved speclan\n\n# Or check in code\ncase \"$entity_status\" in\n  draft|review|approved) editable=true ;;\n  *) editable=false ;;\nesac\n```\n\n## Error Handling\n\n| Scenario | Behavior |\n|----------|----------|\n| Missing speclan dir | Error message, exit 1 |\n| Invalid entity type | Error message, exit 1 |\n| No matches found | Empty JSON array `[]`, exit 0 |\n| Malformed filename | Skipped silently |\n| Template files | Skipped automatically |\n| Archived files | Skipped automatically |\n\n## Performance Notes\n\n- **Fast mode**: ~50ms for 100 features (filename parsing only)\n- **Full mode**: ~500ms for 100 features (frontmatter reads)\n- No caching between queries\n- No depth limits on recursive search\n- Files in `/templates/` and `/_archived/` are excluded\n",
        "plugins/speclan/skills/sync-from-session/SKILL.md": "---\nname: Sync Specs from Session\ndescription: This skill should be used when the user asks to \"sync specs\", \"update specs from work\", \"record what we did\", \"add to speclan\", \"document implemented features\", or wants to capture session work as SPECLAN specifications. Analyzes conversation context to identify implemented features and syncs with speclan directory.\nversion: 0.1.0\n---\n\n# Sync Specs from Session\n\nAnalyze the current session context to identify implemented features, compare with existing SPECLAN specifications, and create or update specs based on user confirmation.\n\n## Core Principle: Implementation-Agnostic Specs\n\n**SPECS MUST NEVER CONTAIN IMPLEMENTATION OR ARCHITECTURE DETAILS.** This skill analyzes code changes internally to understand WHAT was built, but specs describe only user-facing capabilities and business value. Never include file paths, code references, library names, technical approaches, architectural decisions, design patterns, or any implementation-specific information in generated specs.\n\n## When to Use\n\n- After completing implementation work and wanting to document it\n- When user asks to sync or update specs based on recent work\n- To capture newly implemented functionality in SPECLAN format\n\n## Workflow Overview\n\n```\n1. Analyze Session → 2. Scan Speclan → 3. Compare & Diff → 4. Ask User → 5. Apply Changes\n```\n\n## Step 1: Analyze Session Context\n\nReview the conversation history to identify:\n\n### 1.1 Code Changes Made (Internal Analysis)\n\nLook for patterns indicating implementation (for internal matching only - these details are NOT included in specs):\n- Files created or modified (Write/Edit tool usage)\n- Functions, classes, or components added\n- API endpoints implemented\n- Database schema changes\n- Configuration updates\n\n**Purpose:** Use these implementation signals to identify WHAT was built, then translate into user-facing capability descriptions for specs.\n\n### 1.2 Extract Feature Information\n\nFor each identified change, extract:\n\n```yaml\nfeature_candidate:\n  title: \"<descriptive name>\"\n  description: \"<what it does for users and why it matters>\"\n  _code_paths: [\"<files involved>\"]  # INTERNAL USE ONLY - for matching, never included in specs\n  type: \"new\" | \"enhancement\" | \"bugfix\"\n  scope: \"feature\" | \"requirement\" | \"both\"\n```\n\n**Note:** `_code_paths` is used internally to match session work to existing specs. It is NEVER written to spec files.\n\n### 1.3 Categorize Changes\n\nGroup related changes into logical features:\n- Multiple file changes for one feature = single feature\n- Independent changes = separate features\n- Small fixes to existing features = requirement updates\n\n## Step 2: Scan Speclan Directory\n\n### 2.1 Detect Speclan Location\n\n```bash\n# Check common locations\nif [ -d \"speclan\" ]; then\n  SPECLAN_DIR=\"speclan\"\nelif [ -d \"specs/speclan\" ]; then\n  SPECLAN_DIR=\"specs/speclan\"\nelse\n  # No speclan directory - all features are new\n  SPECLAN_DIR=\"\"\nfi\n```\n\n### 2.2 Index Existing Specs\n\nIf speclan directory exists, build an index:\n\n```bash\n# List all features\nfind \"$SPECLAN_DIR/features\" -name \"F-*.md\" -type f 2>/dev/null\n\n# Extract titles and paths\nfor f in $(find \"$SPECLAN_DIR/features\" -name \"F-*.md\" -type f); do\n  id=$(grep \"^id:\" \"$f\" | head -1 | cut -d: -f2 | tr -d ' ')\n  title=$(grep \"^title:\" \"$f\" | head -1 | cut -d: -f2-)\n  echo \"$id|$title|$f\"\ndone\n```\n\n### 2.3 Build Existing Spec Map\n\nCreate a mapping of:\n- Feature ID → Title → File path (spec file location, not code)\n- Feature ID → Status (for edit rules)\n- Feature ID → Key capabilities (for semantic matching)\n\n**Note:** Use titles and capability descriptions for matching, not code paths. Well-formed specs should not contain implementation or architecture references.\n\n## Step 3: Compare and Generate Diff\n\n### 3.1 Match Session Work to Existing Specs\n\nFor each feature candidate from session:\n\n1. **Title similarity check**: Compare with existing feature titles\n2. **Capability overlap**: Check if the described functionality matches existing features\n3. **Description similarity**: Semantic comparison of purpose and user-facing behavior\n\n**Note:** Matching is based on functional capabilities and user outcomes, not on code paths, implementation details, or architectural decisions.\n\n### 3.2 Classify Each Change\n\n| Session Feature | Existing Spec | Classification |\n|-----------------|---------------|----------------|\n| New capability | No match | **CREATE** new feature |\n| Related capability | Match found, status editable | **UPDATE** existing feature |\n| Related capability | Match found, status locked | **CHANGE_REQUEST** needed |\n| Enhancement | Partial match | **ADD_REQUIREMENT** to feature |\n\n### 3.3 Prepare Change Summary\n\nBuild a structured summary:\n\n```yaml\n# NOTE: _code_paths are INTERNAL ONLY for matching - never written to specs\nchanges:\n  create:\n    - title: \"User Authentication\"\n      description: \"Secure login with automatic session refresh\"\n      _code_paths: [\"src/auth/\", \"src/middleware/auth.ts\"]  # internal matching only\n\n  update:\n    - id: \"F-1142\"\n      title: \"Pet Management\"\n      changes: \"Added bulk import capability for pet records\"\n      _code_paths: [\"src/pets/import.ts\"]  # internal matching only\n\n  change_requests:\n    - parent_id: \"F-1089\"\n      title: \"Add Export Feature\"\n      reason: \"Feature is in-development status\"\n\n  requirements:\n    - feature_id: \"F-1142\"\n      title: \"Validate CSV format on import\"\n      _code_paths: [\"src/pets/validators/csv.ts\"]  # internal matching only\n```\n\n## Step 4: Ask User for Confirmation\n\nPresent the identified changes to the user using AskUserQuestion or direct prompting.\n\n### 4.1 Summary Format\n\n```markdown\n## Identified Changes from Session\n\nBased on our session, I identified the following potential spec updates:\n\n### New Features to Create\n1. **User Authentication** - Secure login with automatic session refresh\n\n### Existing Features to Update\n1. **F-1142 Pet Management** - Add bulk import capability for pet records\n   - Current status: draft (editable)\n\n### Change Requests Needed\n1. **F-1089 Data Export** - Feature is locked (in-development)\n   - Proposed: Add export option for user data\n\n### New Requirements\n1. For **F-1142**: Validate file format on import\n```\n\n**IMPORTANT:** Descriptions shown to users must be implementation and architecture agnostic. Focus on WHAT the feature does for users, not HOW it's implemented or structured (no mention of JWT, CSV, file paths, libraries, design patterns, architectural decisions, etc.).\n\n### 4.2 Ask for User Selection\n\nUse AskUserQuestion to let user choose:\n\n```yaml\nquestions:\n  - question: \"Which changes would you like to apply to specs?\"\n    header: \"Apply\"\n    multiSelect: true\n    options:\n      - label: \"Create: User Authentication\"\n        description: \"New feature for secure login with session refresh\"\n      - label: \"Update: F-1142 Pet Management\"\n        description: \"Add bulk import capability to existing feature\"\n      - label: \"CR for F-1089: Data Export\"\n        description: \"Create change request for locked feature\"\n      - label: \"Requirement for F-1142\"\n        description: \"Add file format validation requirement\"\n```\n\n### 4.3 Handle User Response\n\n- **Selected items**: Proceed to create/update\n- **\"Other\" response**: User may provide custom instructions\n- **No selection**: Skip spec updates\n\n## Step 5: Apply Changes\n\n### 5.1 Generate IDs\n\nFor new entities, generate collision-free IDs:\n\n```bash\n# Use the ID generator skill/script\nFEATURE_ID=$(./skills/speclan-id-generator/scripts/generate-id.sh feature \"$SPECLAN_DIR\")\nREQ_ID=$(./skills/speclan-id-generator/scripts/generate-id.sh requirement \"$SPECLAN_DIR\")\n```\n\n### 5.2 Create New Features\n\nFor each new feature:\n\n1. **Create directory structure:**\n   ```bash\n   mkdir -p \"$SPECLAN_DIR/features/F-####-slug\"\n   mkdir -p \"$SPECLAN_DIR/features/F-####-slug/requirements\"\n   ```\n\n2. **Write feature file** with YAML frontmatter:\n   ```yaml\n   ---\n   id: F-####\n   type: feature\n   title: <Title>\n   status: under-test\n   owner: <from session or \"Developer\">\n   created: \"<ISO-8601>\"\n   updated: \"<ISO-8601>\"\n   goals: []\n   ---\n\n   # <Title>\n\n   ## Overview\n   <Description from session analysis - focus on WHAT and WHY, not HOW>\n\n   ## Scope\n   <Bullet points of functionality - user-facing capabilities, not code details>\n   ```\n\n**CRITICAL: Specs must be 100% implementation and architecture agnostic.**\n\nDO NOT include any of the following in specs:\n\n**Implementation Details:**\n- File paths, directory names, or code locations\n- Class names, function names, or variable names\n- Library names, framework references, or technology choices (e.g., \"JWT\", \"Redis\", \"PostgreSQL\")\n- API endpoint paths or route definitions\n- Database table/column names or schema details\n- Code fragments, snippets, or pseudocode\n- Configuration file references\n- Technical implementation approaches\n\n**Architecture Details:**\n- Design patterns used (e.g., \"MVC\", \"event-driven\", \"microservices\", \"singleton\")\n- System architecture decisions (e.g., \"monolith vs microservices\", \"serverless\")\n- Component relationships or dependencies (e.g., \"service A calls service B\")\n- Data flow or sequence diagrams\n- Infrastructure choices (e.g., \"deployed on AWS Lambda\", \"uses message queue\")\n- Caching strategies, scaling approaches, or performance optimizations\n- Internal module boundaries or layering decisions\n- Protocol choices (e.g., \"REST\", \"GraphQL\", \"WebSocket\")\n\nDO include:\n- User-facing capabilities and behaviors\n- Business value and purpose\n- Functional requirements (what the system does)\n- User stories and acceptance criteria\n- Expected outcomes from user perspective\n\n**Example - WRONG:** \"JWT-based authentication with refresh tokens stored in Redis\"\n**Example - RIGHT:** \"Secure login that keeps users signed in across sessions\"\n\n**Example - WRONG:** \"Validates CSV format using the FileValidator class in src/validators/\"\n**Example - RIGHT:** \"Validates uploaded files meet the required format before processing\"\n\n**Example - WRONG:** \"Uses event-driven architecture with message queues for async processing\"\n**Example - RIGHT:** \"Processes large imports without blocking the user interface\"\n\n**Example - WRONG:** \"Implements repository pattern with PostgreSQL for data persistence\"\n**Example - RIGHT:** \"Stores and retrieves user data reliably\"\n\n### 5.3 Update Existing Features\n\nFor features with editable status (draft, review, approved):\n\n1. **Read current file**\n2. **Update relevant sections:**\n   - Add new scope items (user-facing capabilities only)\n   - Update description if needed (keep implementation-agnostic)\n   - Add acceptance criteria if applicable\n3. **Update `updated` timestamp**\n4. **Write file back**\n\n**Remember:** Never add implementation details, architecture decisions, code references, or technical approaches to existing specs.\n\n### 5.4 Create Change Requests\n\nFor locked entities (features or requirements in-development, under-test, released):\n\n1. **Generate CR ID:**\n   ```bash\n   CR_ID=$(./skills/speclan-id-generator/scripts/generate-id.sh change-request \"$SPECLAN_DIR\")\n   ```\n\n2. **Create CR file:**\n   ```yaml\n   ---\n   id: CR-####\n   type: changeRequest\n   title: <Change title>\n   status: pending\n   owner: Developer\n   created: \"<ISO-8601>\"\n   updated: \"<ISO-8601>\"\n   parentId: <F-#### or R-####>\n   parentType: <feature or requirement>\n   changeType: enhancement\n   description: <Brief description - user-facing, no implementation details>\n   changes: |\n     <Detailed change narrative - describe WHAT changes for users, not HOW it's implemented>\n   ---\n   ```\n\n   **Note:** Change request descriptions must also be implementation and architecture agnostic. Describe the user-facing change, not the technical approach or architectural decisions.\n\n3. **Place in correct location (adjacent to target entity):**\n   ```\n   # For features:\n   speclan/features/F-####-slug/change-requests/CR-####-slug.md\n\n   # For requirements:\n   speclan/features/.../requirements/R-####-slug/change-requests/CR-####-slug.md\n   ```\n\n### 5.5 Create New Requirements\n\nFor requirements under existing features:\n\n1. **Generate requirement ID**\n2. **Create requirement directory structure:**\n   ```bash\n   mkdir -p \"speclan/features/F-####-parent/requirements/R-####-slug\"\n   ```\n3. **Write requirement file:**\n   ```\n   speclan/features/F-####-parent/requirements/R-####-slug/R-####-slug.md\n   ```\n4. **Update parent feature's `updated` timestamp**\n\n## Step 6: Report Results\n\nAfter applying changes, report:\n\n```markdown\n## Spec Sync Complete\n\n### Created\n- F-#### User Authentication (speclan/features/F-####-user-authentication/)\n- R-#### CSV Validation (speclan/features/F-1142-pet-management/requirements/R-####-csv-validation/)\n\n### Updated\n- F-1142 Pet Management - added bulk import scope\n\n### Change Requests Created\n- CR-#### for F-1089 Data Export (speclan/features/F-1089-.../change-requests/)\n- CR-#### for R-#### (speclan/.../requirements/R-####-.../change-requests/)\n\n### Next Steps\n- Review created specs for accuracy\n- Assign goals to new features\n- Process pending change requests\n```\n\n## Edge Cases\n\n### No Speclan Directory\n\nIf speclan/ doesn't exist:\n1. Ask user if they want to initialize it\n2. If yes, create basic structure:\n   ```bash\n   mkdir -p speclan/goals speclan/features speclan/templates\n   ```\n3. Proceed with creating new features\n\n### No Identifiable Features\n\nIf session has no clear feature work:\n- Report: \"No significant feature implementations detected in this session\"\n- Offer to manually describe what to document\n\n### Ambiguous Matches\n\nWhen a session feature could match multiple existing specs:\n- Present options to user\n- Let them choose the correct match or create new\n\n## Integration with Other Skills\n\n### SPECLAN Format\nReference for proper file structure and frontmatter fields.\n\n### SPECLAN ID Generator\nUse for collision-free ID generation.\n\n### Spec Converter\nIf user also has speckit, consider syncing there too.\n",
        "plugins/todo/.claude-plugin/plugin.json": "{\n  \"name\": \"todo\",\n  \"version\": \"0.1.1\",\n  \"description\": \"Filesystem-based task management with git integration - track tasks through open/wip/done lifecycle\",\n  \"author\": {\n    \"name\": \"Thomas Landgraf\",\n    \"email\": \"tl@digital-dividend.de\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"todo\",\n    \"tasks\",\n    \"project-management\",\n    \"git\",\n    \"workflow\"\n  ],\n  \"commands\": \"./commands/\",\n  \"skills\": \"./skills/\"\n}\n",
        "plugins/todo/commands/add.md": "---\nname: todo:add\ndescription: Create a new task in the todo system\nallowed-tools:\n  - Read\n  - Write\n  - Glob\n  - Grep\n  - Bash\n  - AskUserQuestion\n  - TodoWrite\nargument-hint: \"<task description>\"\n---\n\n# Todo Add Command\n\nCreate a new task in `todo/open/` with auto-incremented ID.\n\n## Workflow\n\n### 1. Ensure Todo Directory Exists\n\nCheck for `todo/` directory in project root. If not found, create structure:\n```\ntodo/\n├── open/\n├── wip/\n└── done/\n```\n\n### 2. Determine Next ID\n\nFind the highest existing task ID across all directories:\n```bash\nfind todo -name \"[0-9]*.md\" 2>/dev/null | grep -oE '[0-9]+' | sort -n | tail -1\n```\n\nNext ID = highest + 1, zero-padded to 3 digits (001, 002, etc.)\n\n### 3. Parse Description\n\nFrom the ARGUMENT, extract:\n- **Title**: First sentence or line (used for filename slug)\n- **Description**: Full argument text\n\nGenerate slug from title: lowercase, spaces to hyphens, remove special chars.\nExample: \"Fix login bug in auth module\" → `fix-login-bug-in-auth-module`\n\n### 4. Search for Related Tasks (BEFORE asking questions)\n\n**Only suggest dependencies if there's actual similarity.**\n\n1. Extract keywords from new task title (ignore stop words like \"the\", \"a\", \"fix\", \"add\", \"update\")\n2. Search existing open/wip tasks for keyword matches:\n   ```bash\n   # Get keywords from title\n   keywords=$(echo \"<title>\" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9' ' ')\n\n   # Search each keyword in existing tasks\n   for kw in $keywords; do\n     grep -ril \"$kw\" todo/open/ todo/wip/ 2>/dev/null\n   done | sort | uniq -c | sort -rn\n   ```\n\n3. **Only consider tasks as related if they match 2+ keywords OR share the same component/module**\n\n4. Build related_tasks list with:\n   - Task ID\n   - Title (from first heading)\n   - Match reason (which keywords matched)\n\n### 5. Ask Clarifying Questions\n\nUse AskUserQuestion with **multiSelect: true** for dependencies:\n\n```yaml\nquestions:\n  - question: \"What priority should this task have?\"\n    header: \"Priority\"\n    multiSelect: false\n    options:\n      - label: \"High\"\n        description: \"Urgent, blocks other work\"\n      - label: \"Medium (Recommended)\"\n        description: \"Normal priority\"\n      - label: \"Low\"\n        description: \"Nice to have, not urgent\"\n\n  # ONLY show this question if related_tasks is NOT empty\n  - question: \"Any dependencies on other tasks?\"\n    header: \"Dependencies\"\n    multiSelect: true  # Allow selecting multiple dependencies\n    options:\n      - label: \"None\"\n        description: \"No dependencies, can start immediately\"\n      # Add ONLY tasks from related_tasks list:\n      - label: \"Task <ID>\"\n        description: \"<title> (matched: <keywords>)\"\n      # ... more related tasks\n```\n\n**IMPORTANT:**\n- Do NOT show dependency question if no related tasks found\n- Do NOT suggest ALL existing tasks - only those with keyword/topic similarity\n- Always include \"None\" as first option\n- Show max 4 related tasks (most relevant first)\n\n### 6. Search for Related Code Context\n\nUse Grep to find related code (for populating the Tasks section):\n- Search codebase for keywords from the title\n- Identify files/modules that might need changes\n\n### 7. Create Task File\n\nCreate file at `todo/open/<ID>-<slug>.md`:\n\n```markdown\n# <ID>: <Title>\n\n**Status:** open | **Priority:** <priority> | **Assignee:** unassigned\n**Created:** <date> | **Branch:** <id>-<slug>\n\n## Description\n<full description from argument>\n\n## Tasks\n- [ ] <inferred task 1>\n- [ ] <inferred task 2>\n\n## Dependencies\n- Depends on: <ids or \"none\">\n- Blocks: <ids or \"none\">\n\n## PRD\n<!-- Inferred from implementation decisions -->\n\n## Implementation Log\n<!-- Auto-populated by /todo:update -->\n```\n\n### 8. Report Result\n\nOutput confirmation:\n```\nCreated task: todo/open/<ID>-<slug>.md\n\n# <ID>: <Title>\nPriority: <priority>\nDependencies: <deps>\n\nUse /todo:start <ID> to begin working.\n```\n\n## Notes\n\n- **Never auto-commit**: User controls git workflow\n- **ID format**: Always 3 digits, zero-padded (001, 042, 123)\n- **Slug**: Max 50 chars, kebab-case\n- Get current date with: `date +%Y-%m-%d`\n",
        "plugins/todo/commands/done.md": "---\nname: todo:done\ndescription: Mark a task as complete - move to done, finalize log\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - Bash\n  - AskUserQuestion\n  - TodoWrite\nargument-hint: \"[task-id]\"\n---\n\n# Todo Done Command\n\nMark a task as complete. Move from `todo/wip/` to `todo/done/` and finalize the implementation log.\n\n## Workflow\n\n### 1. Select Task\n\n**If ARGUMENT provided:**\n- Find task file matching the ID in `todo/wip/`\n\n**If NO ARGUMENT:**\n- Try to infer from current git branch\n- If not on task branch, list tasks in `todo/wip/` and let user pick\n\n### 2. Validate Completion\n\nRead the task file and check:\n- Are all tasks in the Tasks section complete? `[x]`\n\nIf incomplete tasks remain:\n```\nWarning: Some tasks are not marked complete:\n- [ ] Add tests\n- [ ] Update documentation\n\nComplete anyway?\n```\n\nOptions:\n- \"Yes, close it\" - proceed\n- \"No, keep working\" - cancel\n\n### 3. Final Log Entry\n\nAdd final entry to Implementation Log:\n\n```markdown\n### <date> <time>\n**Completed** by <user>\n**Summary:** <brief summary of what was accomplished>\n```\n\n### 4. Update Task Header\n\n```markdown\n**Status:** done | **Priority:** <unchanged> | **Assignee:** <user>\n**Created:** <created> | **Started:** <started> | **Completed:** <now>\n```\n\n### 5. Move Task File\n\n```bash\nmv todo/wip/<id>-<slug>.md todo/done/\n```\n\n### 6. Report Result\n\n```\nCompleted: <ID> - <Title>\n\nDuration: <started> → <completed>\nFile: todo/done/<id>-<slug>.md\n\nImplementation log preserved for future reference.\n```\n\n## Optional: Branch Cleanup Hint\n\nAfter marking done, suggest:\n```\nTask complete. You may want to:\n1. Merge branch <id>-<slug> to main\n2. Delete the branch: git branch -d <id>-<slug>\n\n(These are not done automatically)\n```\n\n## Error Handling\n\n| Condition | Response |\n|-----------|----------|\n| No tasks in wip/ | \"No tasks in progress. Use /todo:start first.\" |\n| Task not found | \"Task <ID> not found in todo/wip/\" |\n| Task in open/ | \"Task <ID> hasn't been started yet. Use /todo:start first.\" |\n| Task already done | \"Task <ID> is already complete\" |\n\n## Notes\n\n- **Never auto-commit**: Moving the file and updating it does not trigger git commit\n- **Never auto-merge**: User handles git merge workflow\n- Get current timestamp with: `date +\"%Y-%m-%d %H:%M\"`\n- The completed task file serves as documentation for what was done\n",
        "plugins/todo/commands/start.md": "---\nname: todo:start\ndescription: Start working on a task - move to wip, create branch, assign to me\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - Bash\n  - AskUserQuestion\n  - TodoWrite\nargument-hint: \"[task-id]\"\n---\n\n# Todo Start Command\n\nMove a task from `todo/open/` to `todo/wip/`, create a git branch, and assign to current user.\n\n## Workflow\n\n### 1. Check Git State\n\n**CRITICAL**: Require clean git working directory before creating branch.\n\n```bash\ngit status --porcelain\n```\n\nIf output is non-empty, show error:\n```\nError: Uncommitted changes detected. Please commit or stash changes before starting a new task.\n\nModified files:\n<list of files>\n```\n\n### 2. Select Task\n\n**If ARGUMENT provided:**\n- Find task file matching the ID in `todo/open/`\n- Pattern: `todo/open/<ID>-*.md`\n\n**If NO ARGUMENT:**\n- List all tasks in `todo/open/`\n- Use AskUserQuestion to let user pick one:\n\n```\nWhich task do you want to start?\n\n1. 001-fix-login-bug - Fix login bug in auth module\n2. 002-add-dark-mode - Add dark mode support\n3. 003-refactor-api - Refactor API endpoints\n```\n\n### 3. Validate Task\n\n- Confirm task exists in `todo/open/`\n- If task is in `wip/` or `done/`, show appropriate error\n\n### 4. Get User Info\n\n```bash\ngit config user.name || whoami\n```\n\n### 5. Create Git Branch\n\nExtract slug from filename and create branch:\n```bash\ngit checkout -b <id>-<slug>\n```\n\nExample: Task `042-fix-login-bug.md` → branch `042-fix-login-bug`\n\n### 6. Move Task File\n\nMove from `todo/open/` to `todo/wip/`:\n```bash\nmv todo/open/<id>-<slug>.md todo/wip/\n```\n\n### 7. Update Task File\n\nEdit the task file to update:\n\n```markdown\n**Status:** wip | **Priority:** <unchanged> | **Assignee:** <user>\n**Created:** <unchanged> | **Started:** <now> | **Branch:** <id>-<slug>\n```\n\nAdd to Implementation Log:\n```markdown\n## Implementation Log\n\n### <date> <time>\n**Started** by <user>\n```\n\n### 8. Report Result\n\n```\nStarted task: <ID> - <Title>\n\nBranch: <id>-<slug>\nAssignee: <user>\nFile: todo/wip/<id>-<slug>.md\n\nReady to work. Use /todo:update to log progress.\n```\n\n## Error Handling\n\n| Condition | Response |\n|-----------|----------|\n| No tasks in open/ | \"No open tasks. Use /todo:add to create one.\" |\n| Task not found | \"Task <ID> not found in todo/open/\" |\n| Task already in wip | \"Task <ID> is already in progress\" |\n| Uncommitted changes | \"Please commit or stash changes first\" |\n| Branch exists | \"Branch <name> already exists. Delete it or use different task.\" |\n\n## Notes\n\n- **Never auto-commit**: Moving the file and updating it does not trigger git commit\n- Get current timestamp with: `date +\"%Y-%m-%d %H:%M\"`\n",
        "plugins/todo/commands/update.md": "---\nname: todo:update\ndescription: Log implementation progress - auto-detect work from git diff and session\nallowed-tools:\n  - Read\n  - Edit\n  - Glob\n  - Grep\n  - Bash\n  - AskUserQuestion\n  - TodoWrite\nargument-hint: \"\"\n---\n\n# Todo Update Command\n\nUpdate the current task with implementation progress. Auto-detects work done via git diff and Claude session context.\n\n## Workflow\n\n### 1. Identify Current Task\n\n**Primary**: Infer from current git branch name\n```bash\ngit branch --show-current\n```\n\nIf branch matches pattern `<id>-<slug>`, find corresponding task in `todo/wip/`.\n\n**Fallback**: If not on a task branch or no matching task:\n- Check `todo/wip/` for tasks\n- If exactly one task, use it\n- If multiple, ask user to pick\n- If none, offer to create new task (see step 1b)\n\n### 1b. No Active Task - Offer to Create\n\nIf no task is active but work was detected:\n```\nNo active task found, but you have uncommitted changes.\n\nWould you like to:\n1. Create a new task from this work\n2. Cancel\n```\n\nIf user chooses to create, invoke `/todo:add` workflow with inferred description.\n\n### 2. Detect Work Done\n\n**From Git:**\n```bash\ngit diff --name-only HEAD\ngit diff --name-only --cached\n```\n\nCombine to get list of modified files.\n\n**From Session Context:**\nConsider files that were edited during this Claude session (you have awareness of what files you modified).\n\n### 3. Summarize Changes\n\nFor each modified file, briefly describe the change:\n- New file: \"Created <file> - <brief purpose>\"\n- Modified: \"Updated <file> - <what changed>\"\n- Deleted: \"Removed <file>\"\n\n### 4. Ask for Additional Context\n\nUse AskUserQuestion:\n```\nDetected changes in:\n- src/auth/login.js\n- tests/auth.test.js\n\nAnything to add to the log? (optional)\n```\n\nOptions:\n- \"Looks good\" - proceed with auto-detected summary\n- \"Add details\" - let user type additional notes\n- \"Skip this update\" - cancel\n\n### 5. Update Implementation Log\n\nAppend to the task file's Implementation Log section:\n\n```markdown\n### <date> <time>\n**Files modified:**\n- `src/auth/login.js` - Fixed token validation\n- `tests/auth.test.js` - Added 3 test cases\n**Notes:** <user's additional context if provided>\n**Result:** In progress\n```\n\n### 6. Update Task Checkboxes\n\nReview the Tasks section and ask:\n```\nCurrent tasks:\n- [ ] Investigate root cause\n- [ ] Implement fix\n- [ ] Add tests\n\nAny tasks completed? (select all that apply)\n```\n\nUpdate checkboxes:\n- `[ ]` → `[x]` for completed tasks\n- Keep `[ ]` for incomplete\n\n### 7. Update PRD Section\n\nIf implementation decisions were made that clarify requirements:\n- Ask user if PRD should be updated\n- Add inferred requirements based on what was built\n\n### 8. Report Result\n\n```\nUpdated: <ID> - <Title>\n\nChanges logged:\n- <file1>\n- <file2>\n\nTasks: 2/4 complete\n```\n\n## Notes\n\n- **Never auto-commit**: Updates to task file are not committed\n- Get current timestamp with: `date +\"%Y-%m-%d %H:%M\"`\n- Log format should be concise but informative for later catch-up\n",
        "plugins/todo/hooks/hooks.json": "{\n  \"description\": \"Todo plugin hooks for context detection and skill injection\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash $CLAUDE_PLUGIN_ROOT/hooks/scripts/detect-context.sh\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Read|Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash $CLAUDE_PLUGIN_ROOT/hooks/scripts/inject-skill.sh\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "plugins/todo/hooks/scripts/detect-context.sh": "#!/bin/bash\n# Todo Context Detection Hook\n# Runs at session start to detect todo directory and show status summary\n\nPROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-.}\"\n\n# Check if todo directory exists\nTODO_DIR=\"$PROJECT_DIR/todo\"\n\nif [[ ! -d \"$TODO_DIR\" ]]; then\n    # No todo directory - silent exit\n    echo '{\"continue\": true}'\n    exit 0\nfi\n\n# Count tasks in each state\ncount_tasks() {\n    local dir=\"$1\"\n    if [[ -d \"$dir\" ]]; then\n        find \"$dir\" -maxdepth 1 -name \"[0-9]*.md\" -type f 2>/dev/null | wc -l | tr -d ' '\n    else\n        echo \"0\"\n    fi\n}\n\nopen_count=$(count_tasks \"$TODO_DIR/open\")\nwip_count=$(count_tasks \"$TODO_DIR/wip\")\ndone_count=$(count_tasks \"$TODO_DIR/done\")\n\n# Build output\noutput=\"\"\noutput+=\"## Todo Status\\n\\n\"\noutput+=\"| State | Count |\\n\"\noutput+=\"|-------|-------|\\n\"\noutput+=\"| Open | $open_count |\\n\"\noutput+=\"| In Progress | $wip_count |\\n\"\noutput+=\"| Done | $done_count |\\n\"\noutput+=\"\\n\"\n\n# List WIP tasks if any\nif [[ \"$wip_count\" -gt 0 ]]; then\n    output+=\"### Active Tasks\\n\"\n    for f in \"$TODO_DIR/wip\"/[0-9]*.md; do\n        if [[ -f \"$f\" ]]; then\n            # Extract ID and title from filename\n            filename=$(basename \"$f\" .md)\n            id=$(echo \"$filename\" | grep -oE '^[0-9]+')\n            slug=$(echo \"$filename\" | sed 's/^[0-9]*-//')\n            output+=\"- **$id**: $slug\\n\"\n        fi\n    done\n    output+=\"\\n\"\nfi\n\n# Persist environment if available\nif [[ -n \"${CLAUDE_ENV_FILE:-}\" ]]; then\n    echo \"export TODO_DIR=\\\"$TODO_DIR\\\"\" >> \"$CLAUDE_ENV_FILE\"\n    echo \"export TODO_OPEN_COUNT=\\\"$open_count\\\"\" >> \"$CLAUDE_ENV_FILE\"\n    echo \"export TODO_WIP_COUNT=\\\"$wip_count\\\"\" >> \"$CLAUDE_ENV_FILE\"\n    echo \"export TODO_DONE_COUNT=\\\"$done_count\\\"\" >> \"$CLAUDE_ENV_FILE\"\nfi\n\n# Output for Claude\necho -e \"$output\"\n\n# Return JSON\ncat << EOF\n{\n  \"continue\": true,\n  \"suppressOutput\": false,\n  \"systemMessage\": \"Todo context: $open_count open, $wip_count in progress, $done_count done. Use /todo:add, /todo:start, /todo:update, /todo:done.\"\n}\nEOF\n",
        "plugins/todo/hooks/scripts/inject-skill.sh": "#!/bin/bash\n# Todo Skill Injection Hook\n# Injects todo-format skill reference when accessing todo files\n\n# Get file path from tool input\nFILE_PATH=$(echo \"$CLAUDE_TOOL_INPUT\" | jq -r '.file_path // .path // \"\"' 2>/dev/null)\n\n# Check if this is a todo file\nif [[ \"$FILE_PATH\" == */todo/open/* ]] || [[ \"$FILE_PATH\" == */todo/wip/* ]] || [[ \"$FILE_PATH\" == */todo/done/* ]]; then\n  cat << 'EOF'\n{\n  \"continue\": true,\n  \"systemMessage\": \"Working with todo task file. Apply 'Todo Format' skill: use header format (Status/Priority/Assignee/Created/Branch), maintain Tasks checklist with [ ]/[x], log work in Implementation Log with timestamps (YYYY-MM-DD HH:MM), reference dependencies by ID only.\"\n}\nEOF\nelse\n  echo '{\"continue\": true}'\nfi\n",
        "plugins/todo/skills/todo-format/SKILL.md": "---\nname: Todo Format\ndescription: >-\n  Knowledge about the todo task file format and workflow.\n  Use this skill when working with files in todo/open/, todo/wip/, or todo/done/ directories.\nversion: 0.1.0\n---\n\n# Todo Format Knowledge\n\n## Directory Structure\n\n```\ntodo/\n├── open/     # New tasks, not yet started\n├── wip/      # Work in progress\n└── done/     # Completed tasks\n```\n\n## File Naming\n\n**Pattern:** `<ID>-<slug>.md`\n\n- **ID**: 3-digit zero-padded number (001, 042, 123)\n- **Slug**: Kebab-case title, max 50 chars\n\n**Examples:**\n- `001-fix-login-bug.md`\n- `042-add-dark-mode-support.md`\n- `123-refactor-api-endpoints.md`\n\n## Task File Structure\n\n```markdown\n# <ID>: <Title>\n\n**Status:** open | **Priority:** medium | **Assignee:** unassigned\n**Created:** 2026-01-21 | **Branch:** <id>-<slug>\n\n## Description\nBrief description of the task.\n\n## Tasks\n- [ ] Task 1\n- [ ] Task 2\n- [x] Completed task\n\n## Dependencies\n- Depends on: 039, 041\n- Blocks: 044\n\n## PRD\n<!-- Inferred from implementation decisions -->\n\n## Implementation Log\n<!-- Timestamped entries of work done -->\n```\n\n## Status Values\n\n| Status | Directory | Meaning |\n|--------|-----------|---------|\n| `open` | `todo/open/` | Not started |\n| `wip` | `todo/wip/` | Work in progress |\n| `done` | `todo/done/` | Completed |\n\nStatus in file header must match the directory location.\n\n## Header Fields\n\n| Field | Format | Example |\n|-------|--------|---------|\n| Status | open/wip/done | `wip` |\n| Priority | high/medium/low | `high` |\n| Assignee | name or \"unassigned\" | `Thomas Landgraf` |\n| Created | YYYY-MM-DD | `2026-01-21` |\n| Started | YYYY-MM-DD HH:MM | `2026-01-21 14:30` |\n| Completed | YYYY-MM-DD HH:MM | `2026-01-21 18:45` |\n| Branch | id-slug | `042-fix-login-bug` |\n\n## Task Checkboxes\n\n```markdown\n- [ ] Not started\n- [x] Completed\n```\n\n## Dependencies\n\nReference other tasks by ID only (no paths):\n```markdown\n- Depends on: 039, 041\n- Blocks: 044, 045\n```\n\n- **Depends on**: This task needs those tasks completed first\n- **Blocks**: Those tasks are waiting on this task\n\n## Implementation Log Format\n\n```markdown\n### 2026-01-21 14:30\n**Files modified:**\n- `src/auth/login.js` - Fixed token validation\n- `tests/auth.test.js` - Added 3 test cases\n**Notes:** Optional additional context\n**Result:** In progress / Success / Failed\n\n### 2026-01-21 18:45\n**Completed** by Thomas Landgraf\n**Summary:** Brief summary of accomplishment\n```\n\n## PRD Section\n\nThe PRD (Product Requirement Definition) is inferred from implementation:\n- Document decisions made during development\n- Capture requirements that emerged from building\n- Keep concise - bullet points preferred\n\n## Git Integration\n\n- **Branch naming**: `<id>-<slug>` (e.g., `042-fix-login-bug`)\n- **Manual commits**: Plugin never auto-commits\n- **Clean state**: Starting a task requires clean git working directory\n\n## Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/todo:add <desc>` | Create new task in open/ |\n| `/todo:start [id]` | Move to wip/, create branch |\n| `/todo:update` | Log progress, update tasks |\n| `/todo:done [id]` | Move to done/, finalize |\n"
      },
      "plugins": [
        {
          "name": "speclan",
          "description": "Claude Code helper for SPECLAN - manage project specifications as interlinked markdown files",
          "version": "0.3.0",
          "source": "./plugins/speclan",
          "author": {
            "name": "Thomas Landgraf",
            "email": "tl@digital-dividend.de"
          },
          "keywords": [
            "speclan",
            "specifications",
            "requirements",
            "documentation"
          ],
          "license": "MIT",
          "categories": [
            "documentation",
            "requirements",
            "specifications",
            "speclan"
          ],
          "install_commands": [
            "/plugin marketplace add thlandgraf/cc-marketplace",
            "/plugin install speclan@digital-dividend-marketplace"
          ]
        },
        {
          "name": "constitution",
          "description": "Manage project constitution files - rules, best practices, patterns, and guardrails for LLM/coding agents",
          "version": "0.1.0",
          "source": "./plugins/constitution",
          "author": {
            "name": "Thomas Landgraf",
            "email": "tl@digital-dividend.de"
          },
          "keywords": [
            "constitution",
            "rules",
            "best-practices",
            "guardrails",
            "patterns"
          ],
          "license": "MIT",
          "categories": [
            "best-practices",
            "constitution",
            "guardrails",
            "patterns",
            "rules"
          ],
          "install_commands": [
            "/plugin marketplace add thlandgraf/cc-marketplace",
            "/plugin install constitution@digital-dividend-marketplace"
          ]
        },
        {
          "name": "todo",
          "description": "Filesystem-based task management with git integration - track tasks through open/wip/done lifecycle",
          "version": "0.1.0",
          "source": "./plugins/todo",
          "author": {
            "name": "Thomas Landgraf",
            "email": "tl@digital-dividend.de"
          },
          "keywords": [
            "todo",
            "tasks",
            "project-management",
            "git",
            "workflow"
          ],
          "license": "MIT",
          "categories": [
            "git",
            "project-management",
            "tasks",
            "todo",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add thlandgraf/cc-marketplace",
            "/plugin install todo@digital-dividend-marketplace"
          ]
        }
      ]
    }
  ]
}