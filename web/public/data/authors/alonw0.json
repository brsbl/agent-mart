{
  "author": {
    "id": "alonw0",
    "display_name": "Alon Wolenitz",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/67408092?u=2700ca1701568fa19633302a46d89c63e8c32adf&v=4",
    "url": "https://github.com/alonw0",
    "bio": "Release early, release often.",
    "stats": {
      "total_marketplaces": 2,
      "total_plugins": 2,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 173,
      "total_forks": 12
    }
  },
  "marketplaces": [
    {
      "name": "web-asset-generator-marketplace",
      "version": null,
      "description": "Official marketplace for Web Asset Generator - A Claude Code plugin for generating favicons, app icons, and social media images",
      "owner_info": {
        "name": "Alon Wolenitz",
        "url": "https://github.com/alonw0/web-asset-generator"
      },
      "keywords": [],
      "repo_full_name": "alonw0/web-asset-generator",
      "repo_url": "https://github.com/alonw0/web-asset-generator",
      "repo_description": "Claude skill to generate favicons, app icons, and social media images from logos, text, or emojis. Supports emoji suggestions, validation, and framework auto-integration.",
      "homepage": null,
      "signals": {
        "stars": 171,
        "forks": 12,
        "pushed_at": "2026-01-28T09:11:01Z",
        "created_at": "2025-10-21T07:38:30Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1367
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 775
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"web-asset-generator-marketplace\",\n  \"description\": \"Official marketplace for Web Asset Generator - A Claude Code plugin for generating favicons, app icons, and social media images\",\n  \"owner\": {\n    \"name\": \"Alon Wolenitz\",\n    \"url\": \"https://github.com/alonw0/web-asset-generator\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"web-asset-generator\",\n      \"description\": \"Generate favicons, app icons, and social media images from logos, text, or emojis. Features emoji suggestions, WCAG validation, and automatic framework integration for Next.js, Astro, SvelteKit, and more.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Alon Wolenitz\",\n        \"url\": \"https://github.com/alonw0/web-asset-generator\"\n      },\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"alonw0/web-asset-generator\"\n      },\n      \"category\": \"productivity\",\n      \"tags\": [\n        \"favicon\",\n        \"icons\",\n        \"open-graph\",\n        \"social-media\",\n        \"images\",\n        \"web-assets\",\n        \"pwa\",\n        \"emoji\",\n        \"validation\",\n        \"accessibility\",\n        \"wcag\",\n        \"next-js\",\n        \"astro\",\n        \"sveltekit\"\n      ],\n      \"license\": \"MIT\",\n      \"homepage\": \"https://github.com/alonw0/web-asset-generator\",\n      \"repository\": \"https://github.com/alonw0/web-asset-generator.git\",\n      \"strict\": false\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"web-asset-generator\",\n  \"description\": \"Generate favicons, app icons, and social media images from logos, text, or emojis. Supports emoji suggestions, validation, and framework auto-integration.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Web Asset Generator Contributors\",\n    \"url\": \"https://github.com/alonw0/web-asset-generator\"\n  },\n  \"skills\": [\n    \"./skills/web-asset-generator\"\n  ],\n  \"repository\": \"https://github.com/alonw0/web-asset-generator.git\",\n  \"homepage\": \"https://github.com/alonw0/web-asset-generator\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"favicon generator\",\n    \"app icons\",\n    \"social media images\",\n    \"Open Graph\",\n    \"Twitter cards\",\n    \"PWA icons\",\n    \"emoji icons\",\n    \"web development\",\n    \"WCAG validation\"\n  ]\n}\n"
      },
      "plugins": [
        {
          "name": "web-asset-generator",
          "description": "Generate favicons, app icons, and social media images from logos, text, or emojis. Features emoji suggestions, WCAG validation, and automatic framework integration for Next.js, Astro, SvelteKit, and more.",
          "version": "1.0.0",
          "author": {
            "name": "Alon Wolenitz",
            "url": "https://github.com/alonw0/web-asset-generator"
          },
          "source": {
            "source": "github",
            "repo": "alonw0/web-asset-generator"
          },
          "category": "productivity",
          "tags": [
            "favicon",
            "icons",
            "open-graph",
            "social-media",
            "images",
            "web-assets",
            "pwa",
            "emoji",
            "validation",
            "accessibility",
            "wcag",
            "next-js",
            "astro",
            "sveltekit"
          ],
          "license": "MIT",
          "homepage": "https://github.com/alonw0/web-asset-generator",
          "repository": "https://github.com/alonw0/web-asset-generator.git",
          "strict": false,
          "categories": [
            "accessibility",
            "astro",
            "emoji",
            "favicon",
            "icons",
            "images",
            "next-js",
            "open-graph",
            "productivity",
            "pwa",
            "social-media",
            "sveltekit",
            "validation",
            "wcag",
            "web-assets"
          ],
          "install_commands": [
            "/plugin marketplace add alonw0/web-asset-generator",
            "/plugin install web-asset-generator@web-asset-generator-marketplace"
          ]
        }
      ]
    },
    {
      "name": "python-debugger-marketplace",
      "version": null,
      "description": "PyCharm-like Python debugging with breakpoints, stepping, variable inspection, and stack navigation",
      "owner_info": {
        "name": "Alon Wolenitz"
      },
      "keywords": [],
      "repo_full_name": "alonw0/python-debugger-skill",
      "repo_url": "https://github.com/alonw0/python-debugger-skill",
      "repo_description": "A skill for Python debugging methods and best practices",
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-01-19T14:16:29Z",
        "created_at": "2026-01-19T08:45:16Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 323
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/python-debugger",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/python-debugger/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/python-debugger/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 554
        },
        {
          "path": "plugins/python-debugger/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/python-debugger/skills/python-debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/python-debugger/skills/python-debugging/SKILL.md",
          "type": "blob",
          "size": 6427
        },
        {
          "path": "plugins/python-debugger/skills/python-debugging/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/python-debugger/skills/python-debugging/references/commands.md",
          "type": "blob",
          "size": 5732
        },
        {
          "path": "plugins/python-debugger/skills/python-debugging/references/examples.md",
          "type": "blob",
          "size": 6088
        },
        {
          "path": "plugins/python-debugger/skills/python-debugging/references/methodology.md",
          "type": "blob",
          "size": 12578
        },
        {
          "path": "plugins/python-debugger/skills/python-debugging/references/troubleshooting.md",
          "type": "blob",
          "size": 3726
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"python-debugger-marketplace\",\n  \"owner\": {\n    \"name\": \"Alon Wolenitz\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"python-debugger\",\n      \"source\": \"./plugins/python-debugger\",\n      \"description\": \"PyCharm-like Python debugging with breakpoints, stepping, variable inspection, and stack navigation\"\n    }\n  ]\n}\n",
        "plugins/python-debugger/.claude-plugin/plugin.json": "{\n  \"name\": \"python-debugger\",\n  \"version\": \"1.0.0\",\n  \"description\": \"PyCharm-like Python debugging with breakpoints, stepping, variable inspection, and stack navigation\",\n  \"author\": {\n    \"name\": \"Alon Wolenitz\",\n    \"url\": \"https://github.com/alonw0\"\n  },\n  \"homepage\": \"https://github.com/alonw0/python-debugger-skill\",\n  \"repository\": \"https://github.com/alonw0/python-debugger-skill\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"python\",\n    \"debugging\",\n    \"breakpoints\",\n    \"developer-tools\",\n    \"code-inspection\"\n  ],\n  \"skills\": \"./skills/\"\n}\n",
        "plugins/python-debugger/skills/python-debugging/SKILL.md": "---\nname: python-debugging\ndescription: |\n  Debug Python scripts with PyCharm-like capabilities: breakpoints, stepping, variable inspection, and stack navigation. Use this skill when:\n  - User wants to debug a Python script (\"debug this script\", \"help me debug\")\n  - User wants to set breakpoints (\"set a breakpoint at line X\", \"break on exception\")\n  - User wants to step through code (\"step through the code\", \"trace execution\")\n  - User wants to inspect variables (\"what's the value of X\", \"inspect this variable\", \"show locals\")\n  - User wants to understand a crash (\"why is this crashing\", \"find this bug\")\n  - User wants to see the call stack (\"show the call stack\", \"how did we get here\")\n  - User is troubleshooting Python code behavior\n---\n\n# Python Debugging\n\nDebug Python scripts with breakpoints, stepping, variable inspection, and stack navigation.\n\n## Quick Reference\n\n```bash\n# Start debugging\npython scripts/debugger.py start script.py [args...]\n\n# Breakpoints\npython scripts/debugger.py break -f script.py -l 45           # Line breakpoint\npython scripts/debugger.py break -f script.py -l 45 -c \"x>10\" # Conditional\npython scripts/debugger.py break -e ValueError               # Exception breakpoint\npython scripts/debugger.py breakpoints                        # List all\n\n# Execution\npython scripts/debugger.py continue   # Run until next breakpoint\npython scripts/debugger.py step       # Step into\npython scripts/debugger.py next       # Step over\npython scripts/debugger.py finish     # Run until return\n\n# Inspection\npython scripts/debugger.py locals     # Local variables\npython scripts/debugger.py globals    # Global variables\npython scripts/debugger.py eval \"expression\"\npython scripts/debugger.py inspect variable_name\n\n# Stack\npython scripts/debugger.py stack      # View call stack\npython scripts/debugger.py up         # Move up stack\npython scripts/debugger.py down       # Move down stack\n\n# Session\npython scripts/debugger.py status     # Check status\npython scripts/debugger.py quit       # End session\n```\n\n## Debugging Methodology\n\nDebug systematically, not randomly. Follow these principles:\n\n1. **Form a hypothesis first** - Before setting breakpoints, have a theory about what's wrong\n2. **Reproduce consistently** - Ensure you can trigger the bug reliably\n3. **Read error messages carefully** - They often point directly to the problem\n4. **Binary search for bugs** - Narrow down by halving the search space\n5. **Verify assumptions** - Use `eval` to check values are what you expect\n6. **Change one thing at a time** - Isolate variables to identify root cause\n\n## Decision Framework\n\n| Situation | Approach |\n|-----------|----------|\n| Script crashes with exception | `break -e ExceptionType` → `continue` → inspect `locals` and `stack` |\n| Wrong output, unknown cause | Binary search: breakpoint at midpoint, check state, narrow down |\n| Loop produces wrong result | `break -l <line> -c \"i == <problem_iteration>\"` |\n| Function returns wrong value | Breakpoint at return, inspect all locals before return |\n| Variable has unexpected value | Trace backwards: where was it last assigned? |\n| Intermittent bug | `break -e \"*\"` to catch any exception |\n\n## Python Bug Patterns\n\n| Bug Pattern | Symptoms | How to Debug |\n|-------------|----------|--------------|\n| `None` propagation | `AttributeError: 'NoneType'` | `eval \"var\"` at each step to find where it became None |\n| Mutable default args | Function \"remembers\" values | `eval \"func.__defaults__\"` |\n| Off-by-one errors | Missing first/last item | `break -c \"i == 0 or i == len(items)-1\"` |\n| Scope issues | `UnboundLocalError` | Compare `locals` vs `globals` |\n| Type coercion | Unexpected concatenation | `eval \"type(var)\"` |\n| Dict key errors | `KeyError` | `eval \"key in dict\"` before access |\n| Mutating while iterating | Missing items | `eval \"len(collection)\"` each iteration |\n\n## The Debugging Process\n\n```\n1. REPRODUCE   →  Trigger the bug reliably\n2. HYPOTHESIZE →  \"I think X is wrong because Y\"\n3. INSTRUMENT  →  Set strategic breakpoint(s)\n4. OBSERVE     →  Run to breakpoint, inspect state\n5. ANALYZE     →  Does evidence support hypothesis?\n   YES → Fix it    NO → New hypothesis, goto 2\n6. VERIFY      →  Run again to confirm fix\n```\n\n## Common Workflows\n\n### Debugging Exceptions\n\n```bash\npython scripts/debugger.py start script.py\npython scripts/debugger.py break -e ValueError  # Or -e \"*\" for any\npython scripts/debugger.py continue\n# When exception occurs:\npython scripts/debugger.py locals               # What values caused this?\npython scripts/debugger.py stack                # How did we get here?\npython scripts/debugger.py up                   # Check caller's context\n```\n\n### Debugging Wrong Output\n\n```bash\npython scripts/debugger.py start script.py\npython scripts/debugger.py break -f script.py -l <output_line>\npython scripts/debugger.py continue\npython scripts/debugger.py eval \"output_var\"    # Already wrong?\n# Binary search: set breakpoint at midpoint, repeat\n```\n\n### Debugging Loops\n\n```bash\npython scripts/debugger.py break -f script.py -l <loop_line> -c \"i == 5\"\npython scripts/debugger.py continue\npython scripts/debugger.py locals               # Check loop state\npython scripts/debugger.py next                 # Step through iteration\n```\n\n## Anti-Patterns (Avoid These)\n\n- **Random breakpoint placement** - Think first, then place strategically\n- **Not reading error messages** - Python errors are descriptive\n- **Changing code without understanding** - Understand before fixing\n- **Assuming instead of verifying** - Use `eval` to check\n- **Skipping reproduction** - Can't verify fix without consistent repro\n\n## JSON Output Format\n\nAll commands return JSON:\n\n```json\n{\n  \"status\": \"paused\",\n  \"stop_reason\": \"line\",\n  \"location\": {\n    \"file\": \"/path/to/script.py\",\n    \"line\": 45,\n    \"function\": \"process_data\",\n    \"code\": \"    result = calculate(item)\"\n  },\n  \"variables\": {\n    \"locals\": {\n      \"item\": {\"type\": \"dict\", \"value\": \"{'id': 1}\"},\n      \"result\": {\"type\": \"NoneType\", \"value\": \"None\"}\n    }\n  }\n}\n```\n\n## Additional Resources\n\n- [Methodology & Best Practices](references/methodology.md) - Detailed debugging methodology\n- [Command Reference](references/commands.md) - Complete command documentation\n- [Troubleshooting](references/troubleshooting.md) - Common issues and solutions\n- [Examples](references/examples.md) - Example debugging sessions\n",
        "plugins/python-debugger/skills/python-debugging/references/commands.md": "# Command Reference\n\nComplete reference for all Python Debugger commands.\n\n## Session Commands\n\n### start\n\nStart a new debugging session.\n\n```bash\npython scripts/debugger.py start <script> [args...]\n```\n\n**Arguments:**\n- `script` - Python script to debug (required)\n- `args` - Arguments to pass to the script (optional)\n\n**Example:**\n```bash\npython scripts/debugger.py start my_script.py --config prod.yaml\n```\n\n**Output:**\n```json\n{\n  \"status\": \"paused\",\n  \"stop_reason\": \"line\",\n  \"location\": {\"file\": \"my_script.py\", \"line\": 1, \"function\": \"<module>\"}\n}\n```\n\n### status\n\nCheck the status of active debugging sessions.\n\n```bash\npython scripts/debugger.py status [-s SCRIPT]\n```\n\n**Options:**\n- `-s, --script` - Check status for a specific script\n\n**Example:**\n```bash\npython scripts/debugger.py status\n```\n\n### quit\n\nTerminate the debugging session.\n\n```bash\npython scripts/debugger.py quit\n```\n\n## Breakpoint Commands\n\n### break\n\nSet a breakpoint.\n\n```bash\npython scripts/debugger.py break -f FILE -l LINE [-c CONDITION]\npython scripts/debugger.py break -e EXCEPTION\n```\n\n**Options:**\n- `-f, --file` - File path for line breakpoint\n- `-l, --line` - Line number\n- `-c, --condition` - Conditional expression (breakpoint only triggers when true)\n- `-e, --exception` - Exception type to break on (use `*` for all exceptions)\n\n**Examples:**\n```bash\n# Line breakpoint\npython scripts/debugger.py break -f script.py -l 45\n\n# Conditional breakpoint\npython scripts/debugger.py break -f script.py -l 45 -c \"i > 100\"\n\n# Exception breakpoint\npython scripts/debugger.py break -e KeyError\npython scripts/debugger.py break -e \"*\"  # All exceptions\n```\n\n### delete\n\nDelete a breakpoint.\n\n```bash\npython scripts/debugger.py delete -f FILE -l LINE\npython scripts/debugger.py delete -n NUMBER\npython scripts/debugger.py delete -e EXCEPTION\n```\n\n**Options:**\n- `-f, --file` - File path\n- `-l, --line` - Line number\n- `-n, --number` - Breakpoint number\n- `-e, --exception` - Exception type (use `*` to clear all exception breakpoints)\n\n### breakpoints\n\nList all active breakpoints.\n\n```bash\npython scripts/debugger.py breakpoints\n```\n\n**Output:**\n```json\n{\n  \"status\": \"ok\",\n  \"breakpoints\": [\n    {\"number\": 1, \"file\": \"script.py\", \"line\": 45, \"enabled\": true, \"condition\": null}\n  ],\n  \"exception_breakpoints\": [\"ValueError\"]\n}\n```\n\n## Execution Commands\n\n### continue\n\nContinue execution until the next breakpoint or end of script.\n\n```bash\npython scripts/debugger.py continue\n```\n\n### step\n\nStep into the next line of code, entering function calls.\n\n```bash\npython scripts/debugger.py step\n```\n\n### next\n\nStep over to the next line, executing function calls without entering them.\n\n```bash\npython scripts/debugger.py next\n```\n\n### finish\n\nRun until the current function returns.\n\n```bash\npython scripts/debugger.py finish\n```\n\n## Inspection Commands\n\n### locals\n\nGet local variables in the current frame.\n\n```bash\npython scripts/debugger.py locals [-d DEPTH]\n```\n\n**Options:**\n- `-d, --depth` - Inspection depth for nested objects (default: 2)\n\n**Output:**\n```json\n{\n  \"status\": \"ok\",\n  \"locals\": {\n    \"x\": {\"type\": \"int\", \"value\": \"42\"},\n    \"items\": {\"type\": \"list\", \"value\": \"<list with 5 items>\"}\n  }\n}\n```\n\n### globals\n\nGet global variables in the current frame.\n\n```bash\npython scripts/debugger.py globals [-d DEPTH]\n```\n\n**Options:**\n- `-d, --depth` - Inspection depth for nested objects (default: 2)\n\n### eval\n\nEvaluate an expression in the current frame's context.\n\n```bash\npython scripts/debugger.py eval \"EXPRESSION\"\n```\n\n**Examples:**\n```bash\npython scripts/debugger.py eval \"len(items)\"\npython scripts/debugger.py eval \"data['key']\"\npython scripts/debugger.py eval \"[x*2 for x in range(5)]\"\n```\n\n**Notes:**\n- Has a 5-second timeout to prevent hangs\n- Can execute statements (not just expressions)\n- Works in the context of the currently selected stack frame\n\n### inspect\n\nDeep inspect a variable or expression.\n\n```bash\npython scripts/debugger.py inspect EXPRESSION [-d DEPTH]\n```\n\n**Options:**\n- `-d, --depth` - Inspection depth (default: 4)\n\n**Example:**\n```bash\npython scripts/debugger.py inspect my_dataframe\n```\n\n**Output includes:**\n- Type information\n- For DataFrames: shape, columns, dtypes, sample values\n- For arrays: shape, dtype, statistics\n- For objects: attributes and methods\n- For collections: contents (truncated if large)\n\n## Stack Navigation Commands\n\n### stack\n\nDisplay the current call stack.\n\n```bash\npython scripts/debugger.py stack\n```\n\n**Output:**\n```json\n{\n  \"status\": \"ok\",\n  \"stack\": [\n    {\"index\": 0, \"file\": \"script.py\", \"line\": 45, \"function\": \"inner\", \"current\": true},\n    {\"index\": 1, \"file\": \"script.py\", \"line\": 30, \"function\": \"outer\", \"current\": false},\n    {\"index\": 2, \"file\": \"script.py\", \"line\": 10, \"function\": \"<module>\", \"current\": false}\n  ],\n  \"current_index\": 0\n}\n```\n\n### up\n\nMove up the call stack (toward the caller).\n\n```bash\npython scripts/debugger.py up\n```\n\nAfter moving up, `locals`, `globals`, and `eval` operate in that frame's context.\n\n### down\n\nMove down the call stack (toward where execution stopped).\n\n```bash\npython scripts/debugger.py down\n```\n\n## Output Format\n\nAll commands return JSON with a consistent structure:\n\n**Success:**\n```json\n{\n  \"status\": \"ok\",\n  ...\n}\n```\n\n**Paused at breakpoint:**\n```json\n{\n  \"status\": \"paused\",\n  \"stop_reason\": \"line|return|exception\",\n  \"location\": {...},\n  \"variables\": {...}\n}\n```\n\n**Error:**\n```json\n{\n  \"error\": \"Error message\",\n  \"traceback\": \"...\"\n}\n```\n\n## Value Truncation\n\nTo prevent overwhelming output:\n- String values: truncated to 1000 characters\n- Collections: limited to 50 items\n- Stack depth: limited to 50 frames\n- Nested objects: configurable depth (default 2-4)\n\nTruncated values are indicated in the output.\n",
        "plugins/python-debugger/skills/python-debugging/references/examples.md": "# Example Debugging Sessions\n\nReal-world examples of using the Python Debugger.\n\n## Example 1: Finding a Logic Bug\n\n**Script:** `calculate.py`\n```python\ndef calculate_average(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total / len(numbers)  # Bug: doesn't handle empty list\n\nresult = calculate_average([])\nprint(f\"Average: {result}\")\n```\n\n**Debugging Session:**\n```bash\n# Start debugging\n$ python scripts/debugger.py start calculate.py\n\n# Output shows we're at line 1\n{\"status\": \"paused\", \"location\": {\"line\": 1, ...}}\n\n# Set breakpoint at the division\n$ python scripts/debugger.py break -f calculate.py -l 5\n\n# Continue to breakpoint\n$ python scripts/debugger.py continue\n\n# Check the variables\n$ python scripts/debugger.py locals\n{\"locals\": {\"total\": {\"type\": \"int\", \"value\": \"0\"}, \"numbers\": {\"type\": \"list\", \"value\": \"<list with 0 items>\"}}}\n\n# Aha! numbers is empty, len(numbers) is 0 - division by zero!\n\n# Quit\n$ python scripts/debugger.py quit\n```\n\n## Example 2: Debugging an Exception\n\n**Script:** `process_data.py`\n```python\ndef process_user(data):\n    name = data['name']\n    age = data['age']\n    return f\"{name} is {age} years old\"\n\nusers = [\n    {'name': 'Alice', 'age': 30},\n    {'name': 'Bob'},  # Missing 'age' key\n    {'name': 'Carol', 'age': 25}\n]\n\nfor user in users:\n    print(process_user(user))\n```\n\n**Debugging Session:**\n```bash\n# Start with exception breakpoint\n$ python scripts/debugger.py start process_data.py\n$ python scripts/debugger.py break -e KeyError\n$ python scripts/debugger.py continue\n\n# Stops when KeyError is raised\n{\"status\": \"paused\", \"stop_reason\": \"exception\",\n \"exception\": {\"type\": \"KeyError\", \"message\": \"'age'\"}, ...}\n\n# Check what user we're processing\n$ python scripts/debugger.py eval \"data\"\n{\"result\": {\"type\": \"dict\", \"value\": \"{'name': 'Bob'}\"}}\n\n# Found it - Bob is missing the 'age' key!\n\n$ python scripts/debugger.py quit\n```\n\n## Example 3: Stepping Through Code\n\n**Script:** `fibonacci.py`\n```python\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\nresult = fib(5)\nprint(result)\n```\n\n**Debugging Session:**\n```bash\n$ python scripts/debugger.py start fibonacci.py\n$ python scripts/debugger.py break -f fibonacci.py -l 6\n$ python scripts/debugger.py continue\n\n# At the call to fib(5)\n$ python scripts/debugger.py step  # Step into fib()\n\n{\"location\": {\"line\": 2, \"function\": \"fib\"}}\n\n$ python scripts/debugger.py locals\n{\"locals\": {\"n\": {\"type\": \"int\", \"value\": \"5\"}}}\n\n$ python scripts/debugger.py next  # Step over the if check\n$ python scripts/debugger.py next  # Now at return statement\n\n# Step into the recursive call\n$ python scripts/debugger.py step\n\n$ python scripts/debugger.py locals\n{\"locals\": {\"n\": {\"type\": \"int\", \"value\": \"4\"}}}\n\n# Use finish to run until this call returns\n$ python scripts/debugger.py finish\n\n$ python scripts/debugger.py quit\n```\n\n## Example 4: Inspecting Complex Objects\n\n**Script:** `data_analysis.py`\n```python\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Carol'],\n    'score': [85, 92, 78],\n    'grade': ['B', 'A', 'C']\n})\n\nfiltered = df[df['score'] > 80]\nprint(filtered)\n```\n\n**Debugging Session:**\n```bash\n$ python scripts/debugger.py start data_analysis.py\n$ python scripts/debugger.py break -f data_analysis.py -l 9\n$ python scripts/debugger.py continue\n\n# Inspect the DataFrame\n$ python scripts/debugger.py inspect df\n{\n  \"type\": \"DataFrame\",\n  \"shape\": [3, 3],\n  \"column_info\": [\n    {\"name\": \"name\", \"dtype\": \"object\", \"samples\": [\"Alice\"]},\n    {\"name\": \"score\", \"dtype\": \"int64\", \"samples\": [\"85\"]},\n    {\"name\": \"grade\", \"dtype\": \"object\", \"samples\": [\"B\"]}\n  ],\n  \"preview\": [\n    {\"name\": \"Alice\", \"score\": 85, \"grade\": \"B\"},\n    {\"name\": \"Bob\", \"score\": 92, \"grade\": \"A\"},\n    {\"name\": \"Carol\", \"score\": 78, \"grade\": \"C\"}\n  ]\n}\n\n# Evaluate a filter expression\n$ python scripts/debugger.py eval \"df[df['score'] > 90].to_dict()\"\n\n$ python scripts/debugger.py quit\n```\n\n## Example 5: Navigating the Call Stack\n\n**Script:** `nested_calls.py`\n```python\ndef level3(value):\n    result = value * 2\n    return result  # Breakpoint here\n\ndef level2(value):\n    return level3(value + 10)\n\ndef level1(value):\n    return level2(value + 5)\n\noutput = level1(100)\nprint(output)\n```\n\n**Debugging Session:**\n```bash\n$ python scripts/debugger.py start nested_calls.py\n$ python scripts/debugger.py break -f nested_calls.py -l 3\n$ python scripts/debugger.py continue\n\n# Stopped in level3\n$ python scripts/debugger.py locals\n{\"locals\": {\"value\": {\"type\": \"int\", \"value\": \"115\"}}}\n\n# View the call stack\n$ python scripts/debugger.py stack\n{\"stack\": [\n  {\"index\": 0, \"function\": \"level3\", \"current\": true},\n  {\"index\": 1, \"function\": \"level2\"},\n  {\"index\": 2, \"function\": \"level1\"},\n  {\"index\": 3, \"function\": \"<module>\"}\n]}\n\n# Move up to see level2's context\n$ python scripts/debugger.py up\n{\"location\": {\"function\": \"level2\", \"line\": 6}}\n\n$ python scripts/debugger.py locals\n{\"locals\": {\"value\": {\"type\": \"int\", \"value\": \"105\"}}}\n\n# Move up again to level1\n$ python scripts/debugger.py up\n$ python scripts/debugger.py locals\n{\"locals\": {\"value\": {\"type\": \"int\", \"value\": \"100\"}}}\n\n# Move back down\n$ python scripts/debugger.py down\n$ python scripts/debugger.py down\n\n# Now back in level3\n$ python scripts/debugger.py quit\n```\n\n## Example 6: Conditional Breakpoints\n\n**Script:** `loop_bug.py`\n```python\ndef process_items(items):\n    results = []\n    for i, item in enumerate(items):\n        processed = item.upper()  # Bug: fails on None\n        results.append(processed)\n    return results\n\ndata = ['apple', 'banana', None, 'cherry']\nprocess_items(data)\n```\n\n**Debugging Session:**\n```bash\n$ python scripts/debugger.py start loop_bug.py\n# Only stop when item is None\n$ python scripts/debugger.py break -f loop_bug.py -l 4 -c \"item is None\"\n$ python scripts/debugger.py continue\n\n# Stops only when the condition is true\n{\"location\": {\"line\": 4}, ...}\n\n$ python scripts/debugger.py locals\n{\"locals\": {\"i\": {\"value\": \"2\"}, \"item\": {\"value\": \"None\"}}}\n\n# Found where it will fail!\n$ python scripts/debugger.py quit\n```\n",
        "plugins/python-debugger/skills/python-debugging/references/methodology.md": "# Debugging Methodology & Best Practices\n\nA comprehensive guide to debugging Python code effectively. This document covers the mindset, process, and techniques that experienced developers use to find and fix bugs efficiently.\n\n## The Debugging Mindset\n\n### Think Like a Detective\n\nDebugging is investigation. You're gathering evidence, forming theories, and testing them systematically. The bug exists for a reason—your job is to find that reason.\n\n**Key mindset shifts:**\n\n1. **Bugs are deterministic** - The same inputs produce the same outputs. If a bug seems random, you don't yet understand all the inputs (including state, timing, external data).\n\n2. **The computer is not wrong** - It's doing exactly what the code tells it. The gap between what you intended and what you wrote is where the bug lives.\n\n3. **Assume nothing** - The most dangerous bugs hide behind assumptions. Verify everything with the debugger.\n\n### Scientific Method for Debugging\n\nApply the same rigor scientists use:\n\n```\nOBSERVE    →  What exactly is happening? What's the error? What's the wrong output?\nHYPOTHESIZE  →  What could cause this? Where might the bug be?\nPREDICT    →  \"If my hypothesis is correct, then variable X should be Y at line Z\"\nTEST       →  Set a breakpoint, run to it, check your prediction\nCONCLUDE   →  Was your prediction correct? If yes, you're closer. If no, new hypothesis.\n```\n\n**Example thought process:**\n```\nObservation: \"Function returns 0 instead of the sum\"\nHypothesis: \"The accumulator variable isn't being updated\"\nPrediction: \"If true, 'total' should remain 0 inside the loop\"\nTest: Set breakpoint inside loop, check 'total' after each iteration\nConclusion: \"total IS being updated... so the bug is elsewhere\"\nNew hypothesis: \"Maybe I'm returning the wrong variable\"\n```\n\n## The Debugging Process\n\n### Step 1: Reproduce the Bug\n\nBefore debugging, ensure you can trigger the bug consistently.\n\n**Why this matters:**\n- If you can't reproduce it, you can't verify you've fixed it\n- Inconsistent reproduction suggests hidden state or timing issues\n- The reproduction steps themselves are clues\n\n**What to document:**\n- Exact inputs that trigger the bug\n- Environment details (Python version, dependencies)\n- Any setup steps required\n\n### Step 2: Understand Expected vs Actual Behavior\n\nBe precise about what's wrong:\n\n| Vague | Precise |\n|-------|---------|\n| \"It doesn't work\" | \"It returns `None` instead of a list of users\" |\n| \"It crashes\" | \"It raises `KeyError: 'email'` on line 45\" |\n| \"It's slow\" | \"The `process_data()` function takes 30s for 1000 items\" |\n\n### Step 3: Form a Hypothesis\n\nBased on the symptoms, theorize about the cause:\n\n**Good hypotheses are:**\n- Specific: \"The `user_id` variable is None when passed to `fetch_user()`\"\n- Testable: Can be verified or refuted with the debugger\n- Based on evidence: Connected to the observed symptoms\n\n**Ask yourself:**\n- What code path leads to this output/error?\n- What values would cause this behavior?\n- When was this working? What changed?\n\n### Step 4: Set Strategic Breakpoints\n\nDon't scatter breakpoints randomly. Place them to test your hypothesis:\n\n```bash\n# Hypothesis: \"user_id is None\"\n# Strategic breakpoint: where user_id is used\npython scripts/debugger.py break -f api.py -l 45 -c \"user_id is None\"\n```\n\n**Breakpoint strategies:**\n\n| Strategy | When to Use |\n|----------|-------------|\n| At the error line | When you have a stack trace |\n| At function entry | To verify inputs are correct |\n| At function exit | To verify output before return |\n| Conditional | When bug only occurs under specific conditions |\n| Exception | When you don't know where the error originates |\n| Binary search | When bug location is unknown—start in the middle |\n\n### Step 5: Gather Evidence\n\nAt each breakpoint:\n\n1. **Check local variables:** `locals`\n2. **Verify specific values:** `eval \"variable_name\"`\n3. **Check types:** `eval \"type(variable)\"`\n4. **Examine complex objects:** `inspect object_name`\n5. **Understand context:** `stack` to see how you got here\n\n### Step 6: Iterate Until Root Cause Found\n\nEach observation either:\n- **Confirms your hypothesis** → You're on the right track, dig deeper\n- **Refutes your hypothesis** → Form a new one based on what you learned\n\nThe root cause is where the actual behavior diverges from intended behavior.\n\n### Step 7: Verify the Fix\n\nAfter fixing:\n1. Run the original reproduction steps\n2. Verify the bug no longer occurs\n3. Check that you haven't broken anything else\n\n## Python Bug Pattern Recognition\n\n### None Propagation\n\n**Symptoms:** `AttributeError: 'NoneType' has no attribute 'X'`\n\n**Common causes:**\n- Function doesn't explicitly return (implicit `return None`)\n- Dictionary `.get()` returning default `None`\n- Failed API calls returning `None`\n- Conditional logic that doesn't cover all cases\n\n**Debugging approach:**\n```bash\n# Find where the None originated\n# Set breakpoints at each assignment and check the value\npython scripts/debugger.py break -f script.py -l <assignment_line>\npython scripts/debugger.py eval \"variable\"  # Check if None\n# Work backwards until you find where it became None\n```\n\n### Mutable Default Arguments\n\n**Symptoms:** Function \"remembers\" values between calls\n\n**The bug:**\n```python\ndef add_item(item, items=[]):  # BUG: default list is shared!\n    items.append(item)\n    return items\n```\n\n**Debugging approach:**\n```bash\npython scripts/debugger.py eval \"add_item.__defaults__\"\n# Shows: ([...items from previous calls...],)\n```\n\n**The fix:** Use `None` as default, create new list inside function.\n\n### Off-by-One Errors\n\n**Symptoms:** Missing first or last item, `IndexError`\n\n**Common causes:**\n- `range(len(items))` vs `range(len(items) - 1)`\n- `<=` vs `<` in loop conditions\n- Forgetting that indices start at 0\n\n**Debugging approach:**\n```bash\n# Check boundary conditions\npython scripts/debugger.py break -f script.py -l <loop_line> -c \"i == 0\"\npython scripts/debugger.py break -f script.py -l <loop_line> -c \"i == len(items) - 1\"\n```\n\n### Scope and Closure Issues\n\n**Symptoms:** `UnboundLocalError`, variable has unexpected value\n\n**The bug:**\n```python\ncount = 0\ndef increment():\n    count += 1  # BUG: Python thinks count is local because of assignment\n```\n\n**Debugging approach:**\n```bash\npython scripts/debugger.py locals   # Check what's in local scope\npython scripts/debugger.py globals  # Check what's in global scope\n# Compare to see if variable is in expected scope\n```\n\n### Type Coercion Surprises\n\n**Symptoms:** Unexpected string concatenation, wrong arithmetic\n\n**Common causes:**\n- Input from files/APIs is always strings\n- `\"1\" + \"2\"` = `\"12\"`, not `3`\n- Integer division in Python 2 vs 3\n\n**Debugging approach:**\n```bash\npython scripts/debugger.py eval \"type(variable)\"\npython scripts/debugger.py eval \"repr(variable)\"  # Shows quotes for strings\n```\n\n### Mutating While Iterating\n\n**Symptoms:** Missing items, infinite loop, unexpected behavior\n\n**The bug:**\n```python\nfor item in items:\n    if should_remove(item):\n        items.remove(item)  # BUG: modifying list while iterating\n```\n\n**Debugging approach:**\n```bash\n# Watch the collection size change\npython scripts/debugger.py break -f script.py -l <loop_line>\npython scripts/debugger.py eval \"len(items)\"  # Check each iteration\n```\n\n### Shallow vs Deep Copy\n\n**Symptoms:** Changes to \"copy\" affect original\n\n**Debugging approach:**\n```bash\npython scripts/debugger.py eval \"id(original)\"\npython scripts/debugger.py eval \"id(copy)\"\n# If same ID, they're the same object\n\npython scripts/debugger.py eval \"id(original[0])\"\npython scripts/debugger.py eval \"id(copy[0])\"\n# Check nested objects too\n```\n\n### Exception Handling Hiding Bugs\n\n**Symptoms:** Silent failures, unexpected behavior\n\n**The bug:**\n```python\ntry:\n    result = risky_operation()\nexcept:  # BUG: catches everything, including bugs\n    result = default_value\n```\n\n**Debugging approach:**\n```bash\n# Break on all exceptions to see what's being swallowed\npython scripts/debugger.py break -e \"*\"\n```\n\n## Decision Framework\n\n### When to Use Exception Breakpoints\n\nUse `break -e <ExceptionType>`:\n- You have an error message but don't know where it originates\n- Debugging intermittent failures\n- Understanding error propagation\n- Finding swallowed exceptions\n\n### When to Use Conditional Breakpoints\n\nUse `break -f file -l line -c \"condition\"`:\n- Bug only occurs on specific iterations\n- Bug only occurs with specific values\n- You'd hit the breakpoint too many times otherwise\n- Debugging loops or frequently-called functions\n\n### When to Step vs Continue\n\n**Use `step` when:**\n- You want to see inside a function call\n- You're narrowing down which function has the bug\n- You need to trace data flow through functions\n\n**Use `next` when:**\n- You trust the function being called\n- You want to stay at the current level of abstraction\n- The function is a library/built-in you don't need to debug\n\n**Use `continue` when:**\n- You want to run to the next breakpoint\n- You've seen enough at this location\n- You're using breakpoints to check specific points\n\n### When to Inspect the Stack\n\nUse `stack`, `up`, `down` when:\n- You need to understand how execution reached this point\n- The bug might be in a calling function\n- You need to check values in the caller's context\n- Debugging recursive functions\n\n## Debugging Anti-Patterns\n\n### The Shotgun Debugger\n\n**Problem:** Setting breakpoints everywhere hoping to stumble on the bug.\n\n**Why it fails:** Too much information, no direction, wastes time.\n\n**Better approach:** Form a hypothesis first, set targeted breakpoints.\n\n### The Code Changer\n\n**Problem:** Changing code to \"see what happens\" without understanding the bug.\n\n**Why it fails:** Might introduce new bugs, doesn't build understanding.\n\n**Better approach:** Understand the bug first, then make one deliberate change.\n\n### The Assumption Maker\n\n**Problem:** Assuming variables have certain values without checking.\n\n**Why it fails:** The bug often lives in violated assumptions.\n\n**Better approach:** Verify everything with `eval`. Trust nothing.\n\n### The Print Debugger (in complex scenarios)\n\n**Problem:** Using print statements when a debugger would be more effective.\n\n**Why it fails:** Can't inspect state dynamically, clutters code, misses the moment.\n\n**Better approach:** Use the debugger for interactive investigation.\n\n### The Error Message Ignorer\n\n**Problem:** Skimming or ignoring error messages and stack traces.\n\n**Why it fails:** Error messages contain crucial information.\n\n**Better approach:** Read the full error message and stack trace carefully.\n\n## Advanced Techniques\n\n### Binary Search Debugging\n\nWhen you have no idea where the bug is:\n\n1. Set a breakpoint at the midpoint of the code path\n2. Check if the bug has already occurred (values already wrong)\n3. If yes: bug is in the first half\n4. If no: bug is in the second half\n5. Repeat until you've narrowed down to a few lines\n\n### Using Eval to Test Fixes\n\nBefore modifying code, test your fix hypothesis:\n\n```bash\n# Hypothesis: \"I should add 1 to the index\"\npython scripts/debugger.py eval \"items[index]\"      # Current (wrong) value\npython scripts/debugger.py eval \"items[index + 1]\"  # What the fix would give\n```\n\n### Debugging Recursive Functions\n\n1. Set a breakpoint at function entry\n2. Use `stack` to see recursion depth\n3. Use conditional breakpoint for specific depth: `break -c \"depth == 5\"`\n4. Track how parameters change at each level\n\n### Tracing Data Flow\n\nTo understand how data transforms through your code:\n\n1. Start at the source of the data\n2. Set breakpoints at each transformation\n3. At each stop, `eval` the data to see its current form\n4. Follow until you find where it goes wrong\n\n### Debugging Async Code\n\nFor async/await code:\n1. Set breakpoints inside async functions\n2. Be aware that execution order may not be linear\n3. Use `stack` to understand the current execution context\n4. Consider setting breakpoints on await points\n\n## Checklist: Before You Start Debugging\n\n- [ ] Can I reproduce the bug consistently?\n- [ ] Have I read the full error message/stack trace?\n- [ ] Do I understand what the code SHOULD do?\n- [ ] Do I have a hypothesis about the cause?\n- [ ] Have I identified strategic breakpoint locations?\n\n## Checklist: When You're Stuck\n\n- [ ] Am I making assumptions I haven't verified?\n- [ ] Have I checked the inputs to the problematic code?\n- [ ] Have I looked at the full stack trace?\n- [ ] Is the bug actually where I think it is?\n- [ ] Would it help to start fresh with a new hypothesis?\n- [ ] Can I simplify the reproduction case?\n",
        "plugins/python-debugger/skills/python-debugging/references/troubleshooting.md": "# Troubleshooting\n\nCommon issues and solutions for the Python Debugger.\n\n## Connection Issues\n\n### \"Could not connect to debugger. Is it running?\"\n\n**Cause:** The debugger subprocess is not running or the socket connection failed.\n\n**Solutions:**\n1. Check if a session is active: `python scripts/debugger.py status`\n2. If stale session, quit and restart:\n   ```bash\n   python scripts/debugger.py quit\n   python scripts/debugger.py start script.py\n   ```\n3. Manually clean up session files:\n   ```bash\n   rm -rf ~/.claude_debugger/\n   ```\n\n### \"Debugger already running for this script\"\n\n**Cause:** A previous session wasn't properly terminated.\n\n**Solutions:**\n1. Quit the existing session: `python scripts/debugger.py quit`\n2. If that fails, kill the process:\n   ```bash\n   python scripts/debugger.py status  # Get PID\n   kill <pid>\n   rm -rf ~/.claude_debugger/\n   ```\n\n## Execution Issues\n\n### Script doesn't stop at breakpoints\n\n**Possible causes:**\n1. Breakpoint set on wrong file path (relative vs absolute)\n2. Line number doesn't contain executable code\n3. Condition never evaluates to true\n\n**Solutions:**\n1. Use absolute paths: `break -f /full/path/to/script.py -l 45`\n2. Verify line has executable code (not comment or blank)\n3. Test condition separately: `eval \"your_condition\"`\n4. List breakpoints to verify: `breakpoints`\n\n### \"Expression evaluation timed out\"\n\n**Cause:** The expression took longer than 5 seconds to evaluate.\n\n**Solutions:**\n1. Simplify the expression\n2. Avoid expressions that iterate over large collections\n3. Check for infinite loops in the expression\n\n### Script exits immediately\n\n**Cause:** The script may have completed before reaching breakpoints.\n\n**Solutions:**\n1. Set breakpoint at the start of the script\n2. Use exception breakpoint if script is crashing: `break -e \"*\"`\n3. Check script's entry point\n\n## Inspection Issues\n\n### Variables show \"<circular reference>\"\n\n**Cause:** Object contains a reference to itself.\n\n**Solution:** This is expected behavior to prevent infinite recursion. The object exists but can't be fully displayed.\n\n### Large objects are truncated\n\n**Cause:** By design, output is limited to prevent overwhelming responses.\n\n**Workarounds:**\n1. Use `inspect` with higher depth: `inspect var -d 6`\n2. Use `eval` to access specific parts: `eval \"large_dict['specific_key']\"`\n3. For DataFrames: `eval \"df.head(20).to_dict()\"`\n\n### \"No frame available\"\n\n**Cause:** Trying to inspect when not paused at a breakpoint.\n\n**Solution:** Make sure the debugger is paused:\n```bash\npython scripts/debugger.py status\n```\n\n## Platform Issues\n\n### Unix socket errors\n\n**Cause:** Socket file permissions or filesystem issues.\n\n**Solutions:**\n1. Check `~/.claude_debugger/` directory permissions\n2. Ensure the filesystem supports Unix sockets\n3. Clean up and retry:\n   ```bash\n   rm -rf ~/.claude_debugger/\n   python scripts/debugger.py start script.py\n   ```\n\n### Signal handling conflicts\n\n**Cause:** Script being debugged also uses SIGALRM or SIGTERM.\n\n**Workaround:** The debugger uses these signals internally. If your script depends on them, be aware of potential conflicts.\n\n## Best Practices\n\n1. **Always quit sessions when done:** `python scripts/debugger.py quit`\n2. **Use absolute paths** for breakpoint file arguments\n3. **Start simple:** Test with a basic script before debugging complex ones\n4. **Check status frequently:** `python scripts/debugger.py status`\n5. **Use exception breakpoints** to find crashes: `break -e \"*\"`\n\n## Getting Help\n\nIf issues persist:\n1. Check the session state: `ls -la ~/.claude_debugger/`\n2. Review the session file contents for error messages\n3. Ensure you're using Python 3.7+\n4. Try with a minimal test script to isolate the issue\n"
      },
      "plugins": [
        {
          "name": "python-debugger",
          "source": "./plugins/python-debugger",
          "description": "PyCharm-like Python debugging with breakpoints, stepping, variable inspection, and stack navigation",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add alonw0/python-debugger-skill",
            "/plugin install python-debugger@python-debugger-marketplace"
          ]
        }
      ]
    }
  ]
}