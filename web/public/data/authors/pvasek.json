{
  "author": {
    "id": "pvasek",
    "display_name": "pvasek",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/946316?u=3ca06e685549ee562a5c1cc9a7560e41f92acedb&v=4",
    "url": "https://github.com/pvasek",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "pvasek-skills-marketplace",
      "version": null,
      "description": "Collection of Claude Code skills by Pavel Vasek",
      "owner_info": {
        "name": "Pavel Vasek"
      },
      "keywords": [],
      "repo_full_name": "pvasek/claude-skills",
      "repo_url": "https://github.com/pvasek/claude-skills",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-23T21:53:12Z",
        "created_at": "2025-12-23T12:22:13Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 516
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 439
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1678
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/csharp-project-expert",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/csharp-project-expert/SKILL.md",
          "type": "blob",
          "size": 4117
        },
        {
          "path": "skills/csharp-project-expert/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/csharp-project-expert/references/ARCHITECTURE.md",
          "type": "blob",
          "size": 13180
        },
        {
          "path": "skills/csharp-project-expert/references/COMMANDS.md",
          "type": "blob",
          "size": 20127
        },
        {
          "path": "skills/csharp-project-expert/references/EXAMPLES.md",
          "type": "blob",
          "size": 15979
        },
        {
          "path": "skills/csharp-project-expert/references/WORKFLOWS.md",
          "type": "blob",
          "size": 14713
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"pvasek-skills-marketplace\",\n  \"metadata\": {\n    \"description\": \"Collection of Claude Code skills by Pavel Vasek\"\n  },\n  \"owner\": {\n    \"name\": \"Pavel Vasek\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"pvasek-skills\",\n      \"source\": \"./\",\n      \"description\": \"Collection of Claude Code skills including C# code analysis, and more.\",\n      \"version\": \"0.0.0\",\n      \"author\": {\n        \"name\": \"Pavel Vasek\"\n      },\n      \"keywords\": [\"claude-code\", \"skills\"],\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"pvasek-skills\",\n  \"version\": \"0.0.0\",\n  \"description\": \"Collection of Claude Code skills by Pavel Vasek\",\n  \"author\": {\n    \"name\": \"Pavel Vasek\",\n    \"url\": \"https://github.com/pvasek\"\n  },\n  \"homepage\": \"https://github.com/pvasek/claude-skills\",\n  \"repository\": \"https://github.com/pvasek/claude-skills\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"claude-code\",\n    \"skills\",\n    \"productivity\"\n  ],\n  \"skills\": \"./skills/\"\n}\n",
        "README.md": "# Claude Skills Distribution\n\nPre-built skills for Claude Code.\n\n## Installation\n\n1. Add the marketplace:\n```bash\n/plugin marketplace add pvasek/claude-skills\n```\n\n2. Install a plugin:\n```bash\n/plugin install csharp-expert@pvasek/claude-skills\n```\n\n## Available Skills\n\n| Skill | Description |\n|-------|-------------|\n| [csharp-expert](#csharp-expert) | C# code analysis and refactoring using Roslyn APIs |\n\n---\n\n### csharp-expert\n\nRoslyn-powered CLI for C# code analysis. 18 commands for symbol lookup, references, refactoring, diagnostics, and more.\n\n**Source**: [pvasek/csharp-project-expert-skill](https://github.com/pvasek/csharp-project-expert-skill)\n\n**Commands**:\n\n| Category | Commands |\n|----------|----------|\n| Symbol | `find-definition`, `find-references`, `signature`, `list-members`, `rename` |\n| Compilation | `diagnostics`, `check-symbol-exists` |\n| Type Hierarchy | `find-implementations`, `inheritance-tree` |\n| Call Analysis | `find-callers`, `find-callees` |\n| Dependencies | `dependencies`, `unused-code` |\n| Code Generation | `generate-interface`, `implement-interface` |\n| Organization | `list-types`, `namespace-tree`, `analyze-file` |\n\n**Example prompts**:\n- \"Find all implementations of IUserRepository\"\n- \"Rename the UserService class to UserManager\"\n- \"Show me the inheritance tree for BaseController\"\n\n---\n\n## Adding New Skills\n\nEach skill lives in `skills/<skill-name>/` with:\n- `SKILL.md` - Skill definition with frontmatter\n- `references/` - Optional reference docs\n- `scripts/` - Built binaries (per platform)\n\nSkills are published here via CI from their source repos.\n\n## License\n\nThis project is licensed under the [MIT License](LICENSE.md).\n",
        "skills/csharp-project-expert/SKILL.md": "---\nname: csharp-project-expert\ndescription: 'ALWAYS use for ANY C# operation: renaming (files/classes/methods/properties/namespaces), finding references/usages (\"where is X used\"), finding definitions (\"where is X defined\"), understanding code structure (hierarchies/dependencies/relationships). Roslyn-powered semantic analysis ensures all references are updated correctly across the entire solution.'\n---\n\n# C# Project Expert\n\nCompiler-accurate semantic analysis for C# using Roslyn APIs. **Not text search** - understands C# semantics.\n\n## When to Use\n\n**Use this skill for:**\n- Finding symbol definitions (classes, methods, interfaces, properties)\n- Finding all references before refactoring\n- Safe renaming across entire solution (always preview first!)\n- Understanding method signatures and type hierarchies\n- Checking compilation errors/warnings\n- Finding interface implementations\n- Analyzing method call chains (callers/callees)\n- Finding unused code\n\n**Don't use for:** Non-C# files, simple text/comment searches, projects without .sln/.csproj\n\n## CLI Path (Cross-Platform)\n\n| Platform | Path |\n|----------|------|\n| Linux x64 | `./scripts/linux-x64/csharp-skill` |\n| macOS x64 | `./scripts/osx-x64/csharp-skill` |\n| macOS ARM | `./scripts/osx-arm64/csharp-skill` |\n| Windows x64 | `./scripts/win-x64/csharp-skill.exe` |\n\n## Command Syntax\n\n```\n<cli-path> [-s <solution.sln> | -p <project.csproj>] [-o json|text|markdown] <command> [options]\n```\n\n**Auto-Discovery:** If `-s` or `-p` is not specified, the tool automatically searches the current directory for a `.sln` file (preferred) or `.csproj` file.\n\n## All Commands (18)\n\n| Command | Purpose | Key Options |\n|---------|---------|-------------|\n| `find-definition <name>` | Where is symbol defined | `--type class|method|property|interface` |\n| `find-references <name>` | All usages of symbol | `--type`, `--in-namespace` |\n| `rename <old> <new>` | Rename across solution | `--preview` (use first!), `--type`, `--rename-file` |\n| `signature <name>` | Method/type signature | `--include-overloads`, `--include-docs` |\n| `list-members <type>` | Members of a type | `--kind method|property|field`, `--accessibility` |\n| `diagnostics` | Compilation errors/warnings | `--severity error|warning`, `--file`, `--code` |\n| `check-symbol-exists <name>` | Verify symbol exists | `--type` |\n| `find-implementations <name>` | Interface implementations | - |\n| `inheritance-tree <type>` | Type hierarchy | `--direction ancestors|descendants|both` |\n| `find-callers <method>` | Who calls this method | - |\n| `find-callees <method>` | What does method call | - |\n| `dependencies <target>` | Type/file dependencies | - |\n| `unused-code` | Find dead code | - |\n| `generate-interface <class>` | Extract interface | - |\n| `implement-interface <iface>` | Generate stubs | - |\n| `list-types` | Types in namespace/file | `--namespace` |\n| `namespace-tree` | Namespace hierarchy | - |\n| `analyze-file <path>` | Quick file analysis | - |\n\n## Critical Workflows\n\n### Safe Rename (Always Follow)\n1. Check usage: `find-references OldName --type method`\n2. Preview changes (REQUIRED): `rename OldName NewName --type method --preview`\n3. Apply: `rename OldName NewName --type method`\n4. **When renaming classes/types**: Add `--rename-file` to also rename the file\n5. Verify: `diagnostics --severity error`\n\n### Understand Unknown Code\n1. What is it? `find-definition ClassName --type class`\n2. What can it do? `list-members ClassName`\n3. How does it fit? `inheritance-tree ClassName`\n4. What does it need? `dependencies ClassName`\n\n## Output Formats\n\n- `json` (default) - Machine-readable\n- `text` - Human-readable terminal\n- `markdown` - Documentation format\n\n## Requirements\n\n- [.NET 10.0 runtime](https://dotnet.microsoft.com/download/dotnet/10.0)\n- Valid .sln or .csproj file\n- Solution must compile\n\n## Exit Codes\n\n- `0` Success | `1` Error | `2` Not found\n\n## Detailed References\n\n- [COMMANDS.md](references/COMMANDS.md) - Full command reference\n- [WORKFLOWS.md](references/WORKFLOWS.md) - Step-by-step workflows\n- [EXAMPLES.md](references/EXAMPLES.md) - Real-world scenarios\n",
        "skills/csharp-project-expert/references/ARCHITECTURE.md": "# Technical Architecture\n\nThis document describes the technical architecture, implementation details, and performance considerations of the C# Project Expert skill.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Roslyn API Integration](#roslyn-api-integration)\n- [Architecture Components](#architecture-components)\n- [Performance Considerations](#performance-considerations)\n- [Output Format Specifications](#output-format-specifications)\n- [Dependencies](#dependencies)\n- [Error Handling](#error-handling)\n\n---\n\n## Overview\n\nThe C# Project Expert skill is built on top of the .NET Compiler Platform (Roslyn), which provides programmatic access to the same semantic analysis that powers Visual Studio, Rider, and other C# IDEs.\n\n### Key Architectural Principles\n\n1. **Compiler-Accurate Analysis** - Uses the same Roslyn APIs as Visual Studio\n2. **Solution-Wide Context** - Understands entire solutions, not just individual files\n3. **Symbol-Based Operations** - Works with C# symbols, not text patterns\n4. **Multiple Output Formats** - JSON for automation, text/markdown for humans\n5. **Fast and Efficient** - Caches compilation for performance\n\n---\n\n## Roslyn API Integration\n\n### What is Roslyn?\n\nRoslyn is the .NET Compiler Platform that provides:\n- **Syntax Analysis** - Parse C# code into syntax trees\n- **Semantic Analysis** - Understand meaning, types, and symbols\n- **Symbol Resolution** - Find definitions, references, and relationships\n- **Code Generation** - Generate and modify code programmatically\n\n### Core Roslyn Components Used\n\n#### 1. MSBuild Workspace\n\n```csharp\nusing Microsoft.CodeAnalysis.MSBuild;\n\n// Load solution\nvar workspace = MSBuildWorkspace.Create();\nvar solution = await workspace.OpenSolutionAsync(solutionPath);\n```\n\n**Purpose:** Loads .sln files with full project references and configurations.\n\n**Benefits:**\n- Understands multi-project solutions\n- Resolves project-to-project references\n- Respects build configurations (Debug/Release)\n- Handles NuGet package references\n\n#### 2. Compilation\n\n```csharp\n// Get compilation for a project\nvar project = solution.Projects.First();\nvar compilation = await project.GetCompilationAsync();\n```\n\n**Purpose:** Creates a compiled representation of the code.\n\n**Benefits:**\n- Access to all declared symbols\n- Type checking and diagnostics\n- Full semantic model\n\n#### 3. Semantic Model\n\n```csharp\nvar document = project.Documents.First();\nvar semanticModel = await document.GetSemanticModelAsync();\nvar symbol = semanticModel.GetSymbolInfo(node).Symbol;\n```\n\n**Purpose:** Provides semantic understanding of code.\n\n**Benefits:**\n- Resolve symbols from syntax nodes\n- Get type information\n- Find references and definitions\n\n#### 4. Symbol Finder\n\n```csharp\nusing Microsoft.CodeAnalysis.FindSymbols;\n\n// Find all references to a symbol\nvar references = await SymbolFinder.FindReferencesAsync(symbol, solution);\n```\n\n**Purpose:** Fast, accurate symbol search across solution.\n\n**Benefits:**\n- Find definitions and references\n- Find derived/base types\n- Find implementations of interfaces\n\n---\n\n## Architecture Components\n\n### 1. CLI Layer (`Program.cs`)\n\nHandles command-line interface using `System.CommandLine`:\n\n```\nUser Input → Command Parser → Command Handler → Roslyn API → Output Formatter → JSON/Text/Markdown\n```\n\n**Responsibilities:**\n- Parse command-line arguments\n- Validate input\n- Route to appropriate command handler\n- Format and output results\n\n### 2. API Client (`RoslynApiClient.cs`)\n\nCore wrapper around Roslyn APIs:\n\n**Key Methods:**\n- `LoadSolutionAsync()` - Initialize workspace\n- `FindSymbolAsync()` - Locate symbols by name\n- `GetReferencesAsync()` - Find all references\n- `RenameSymbolAsync()` - Safe symbol renaming\n- `GetDiagnosticsAsync()` - Compilation errors/warnings\n\n### 3. Command Handlers\n\nEach command has a dedicated handler implementing `ICommandHandler`:\n\n**Structure:**\n```\nCommands/\n├── Symbol/\n│   ├── FindDefinitionCommand.cs\n│   ├── FindReferencesCommand.cs\n│   ├── RenameCommand.cs\n│   ├── SignatureCommand.cs\n│   └── ListMembersCommand.cs\n├── Compilation/\n│   ├── DiagnosticsCommand.cs\n│   └── CheckSymbolExistsCommand.cs\n├── TypeHierarchy/\n│   ├── FindImplementationsCommand.cs\n│   └── InheritanceTreeCommand.cs\n├── CallAnalysis/\n│   ├── FindCallersCommand.cs\n│   └── FindCalleesCommand.cs\n├── Dependency/\n│   ├── DependenciesCommand.cs\n│   └── UnusedCodeCommand.cs\n├── CodeGeneration/\n│   ├── GenerateInterfaceCommand.cs\n│   └── ImplementInterfaceCommand.cs\n└── Organization/\n    ├── ListTypesCommand.cs\n    ├── NamespaceTreeCommand.cs\n    └── AnalyzeFileCommand.cs\n```\n\n**Each Handler:**\n1. Validates input parameters\n2. Calls RoslynApiClient methods\n3. Processes results\n4. Returns structured data models\n\n### 4. Data Models\n\nStrongly-typed models for command results:\n\n```\nModels/\n├── SymbolLocation.cs        - File location information\n├── SymbolReference.cs        - Reference details\n├── SymbolSignature.cs        - Method/type signatures\n├── TypeMember.cs             - Class member information\n├── DiagnosticInfo.cs         - Compilation diagnostics\n├── InheritanceTree.cs        - Type hierarchy data\n├── CallAnalysis.cs           - Method call information\n├── DependencyAnalysis.cs     - Dependency information\n├── CodeGeneration.cs         - Generated code\n├── Organization.cs           - Namespace/type organization\n└── RenameResult.cs           - Rename preview/result\n```\n\n### 5. Output Formatters\n\nConverts models to different output formats:\n\n**Supported Formats:**\n- **JSON** - Structured, machine-readable (default)\n- **Text** - Human-readable terminal output\n- **Markdown** - Formatted for documentation\n\n**Example:**\n```csharp\npublic interface IOutputFormatter\n{\n    string Format<T>(T data);\n}\n\n// JsonOutputFormatter, TextOutputFormatter, MarkdownOutputFormatter\n```\n\n---\n\n## Performance Considerations\n\n### Compilation Caching\n\n**Problem:** Loading and compiling a solution is expensive (2-10 seconds for large solutions).\n\n**Solution:** The workspace and compilations are cached after first load.\n\n```csharp\nprivate static MSBuildWorkspace? _workspace;\nprivate static Solution? _solution;\n\npublic async Task<Solution> LoadSolutionAsync(string path)\n{\n    if (_solution != null && _solution.FilePath == path)\n        return _solution; // Return cached solution\n\n    _workspace = MSBuildWorkspace.Create();\n    _solution = await _workspace.OpenSolutionAsync(path);\n    return _solution;\n}\n```\n\n**Impact:**\n- First command: 2-10 seconds\n- Subsequent commands: < 100ms\n\n### Symbol Resolution\n\n**Fast Path:** When searching for symbols, narrow the search space:\n\n```csharp\n// Slow - search all projects\nvar allSymbols = solution.Projects\n    .SelectMany(p => p.Documents)\n    .SelectMany(d => GetAllSymbols(d));\n\n// Fast - filter by name first\nvar candidates = await SymbolFinder.FindDeclarationsAsync(\n    solution,\n    name: symbolName,\n    ignoreCase: false\n);\n```\n\n### Parallel Processing\n\nMultiple files can be analyzed in parallel:\n\n```csharp\nvar diagnostics = await Task.WhenAll(\n    project.Documents.Select(async doc => {\n        var semantic = await doc.GetSemanticModelAsync();\n        return semantic.GetDiagnostics();\n    })\n);\n```\n\n### Memory Management\n\n**Large Solutions:**\n- Roslyn keeps syntax trees in memory\n- Large solutions (100+ projects) can use 500MB-1GB RAM\n- Workspace is disposed after operation completes\n\n**Optimization:**\n```csharp\n// Only load necessary documents\nvar relevantDocs = project.Documents\n    .Where(d => d.FilePath.Contains(\"Services\"));\n\nforeach (var doc in relevantDocs)\n{\n    // Process\n}\n// Unload when done\nworkspace.Dispose();\n```\n\n---\n\n## Output Format Specifications\n\n### JSON Schema\n\nAll commands output JSON following this structure:\n\n```json\n{\n  \"command\": \"find-definition\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"success\": true,\n  \"data\": {\n    // Command-specific payload\n  },\n  \"errors\": []\n}\n```\n\n**Success Response:**\n```json\n{\n  \"success\": true,\n  \"data\": { /* command results */ }\n}\n```\n\n**Error Response:**\n```json\n{\n  \"success\": false,\n  \"errors\": [\n    {\n      \"code\": \"SYMBOL_NOT_FOUND\",\n      \"message\": \"Symbol 'UserService' not found in solution\",\n      \"details\": \"...\"\n    }\n  ]\n}\n```\n\n### Text Format\n\nHuman-readable output:\n\n```\nSymbol: UserService\nKind: class\nLocation:\n  File: src/Services/UserService.cs\n  Line: 15\n  Column: 18\nNamespace: MyApp.Services\nAccessibility: public\n```\n\n**Format Rules:**\n- Key-value pairs with proper indentation\n- Nested data indented by 2 spaces\n- Clear visual separation between sections\n\n### Markdown Format\n\nDocumentation-friendly output:\n\n```markdown\n## Symbol: UserService\n\n**Kind:** class\n**Location:** `src/Services/UserService.cs:15:18`\n**Namespace:** `MyApp.Services`\n**Accessibility:** public\n```\n\n**Format Rules:**\n- Headers for major sections\n- Bold for labels\n- Code formatting for paths and code\n- Lists for collections\n\n---\n\n## Dependencies\n\n### Core Dependencies\n\n**Microsoft.CodeAnalysis.CSharp.Workspaces** (v5.0.0)\n- Provides Roslyn APIs for C# analysis\n- Includes syntax/semantic analysis\n- Symbol resolution and renaming\n\n**Microsoft.CodeAnalysis.Workspaces.MSBuild** (v5.0.0)\n- Loads .sln and .csproj files\n- Handles MSBuild-based projects\n- Resolves project references\n\n**Microsoft.Build.Locator** (v1.8.1)\n- Locates MSBuild on the system\n- Required for MSBuildWorkspace\n- Ensures correct .NET SDK version\n\n**System.CommandLine** (v2.0.0-beta4.22272.1)\n- Modern CLI framework\n- Argument parsing and validation\n- Help generation\n\n### Runtime Requirements\n\n**.NET 10.0 Runtime**\n- Required to run the tool\n- Supports C# 1.0-12.0 analysis\n- Cross-platform (Windows/macOS/Linux)\n\n**MSBuild**\n- Included with .NET SDK\n- Required for solution loading\n- Version matches .NET SDK version\n\n---\n\n## Error Handling\n\n### Error Categories\n\n#### 1. Solution Loading Errors\n\n```\n- Solution file not found\n- Invalid solution format\n- Project load failures\n- Missing dependencies\n```\n\n**Handling:** Return clear error with path and resolution steps.\n\n#### 2. Symbol Not Found\n\n```\n- Symbol name doesn't exist\n- Symbol exists but wrong type\n- Ambiguous symbol name\n```\n\n**Handling:** Return exit code 2, suggest alternatives if available.\n\n#### 3. Compilation Errors\n\n```\n- C# syntax errors\n- Type resolution failures\n- Missing references\n```\n\n**Handling:** Report via diagnostics command, don't fail other commands.\n\n#### 4. Invalid Arguments\n\n```\n- Missing required options\n- Invalid type values\n- Malformed paths\n```\n\n**Handling:** Show usage help, suggest correct format.\n\n### Exit Codes\n\n- `0` - Success\n- `1` - General error (exception, invalid arguments)\n- `2` - Not found (symbol not found, file not found)\n\n### Error Messages\n\n**Good Error Message:**\n```\nError: Symbol 'UserService' not found in solution.\n\nSuggestions:\n  - Check spelling: did you mean 'UserServices'?\n  - Verify symbol type: try --type class\n  - Check namespace: try --in-namespace MyApp.Services\n\nUse --verbose for more details.\n```\n\n**Poor Error Message:**\n```\nError: Symbol not found.\n```\n\n---\n\n## Supported C# Versions\n\nThe tool supports C# language versions 1.0 through 12.0 via Roslyn 5.0:\n\n- **C# 1.0-7.3** - Full support\n- **C# 8.0** - Nullable reference types, pattern matching\n- **C# 9.0** - Records, init properties\n- **C# 10.0** - Global usings, file-scoped namespaces\n- **C# 11.0** - Raw string literals, list patterns\n- **C# 12.0** - Primary constructors, collection expressions\n\n**Note:** The tool analyzes code based on the project's target framework and language version specified in .csproj files.\n\n---\n\n## Extension Points\n\n### Adding New Commands\n\n1. Create command handler class\n2. Implement `ICommandHandler` interface\n3. Register in `Program.cs`\n4. Add data model if needed\n5. Update documentation\n\n### Custom Output Formatters\n\nImplement `IOutputFormatter` interface:\n\n```csharp\npublic class CustomFormatter : IOutputFormatter\n{\n    public string Format<T>(T data)\n    {\n        // Custom formatting logic\n    }\n}\n```\n\n---\n\n## Troubleshooting\n\n### Workspace Load Failures\n\n**Symptom:** \"Could not load solution\"\n\n**Causes:**\n- MSBuild not found\n- .NET SDK version mismatch\n- Corrupted project files\n\n**Solution:**\n```bash\n# Verify MSBuild\ndotnet --info\n\n# Try restoring packages\ncd path/to/solution\ndotnet restore\n\n# Check for project errors\ndotnet build\n```\n\n### Symbol Resolution Issues\n\n**Symptom:** \"Symbol not found\" but it exists\n\n**Causes:**\n- Symbol in different namespace\n- Private/internal accessibility\n- #if conditional compilation\n\n**Solution:**\n- Use `--in-namespace` to narrow search\n- Check accessibility with `list-members`\n- Ensure conditional symbols are defined\n\n### Performance Issues\n\n**Symptom:** Commands taking > 30 seconds\n\n**Causes:**\n- Very large solution (200+ projects)\n- Network drive\n- Insufficient memory\n\n**Solution:**\n- Use `--project` instead of `--solution`\n- Run on local drive\n- Increase available RAM\n- Close other applications\n",
        "skills/csharp-project-expert/references/COMMANDS.md": "# Complete Command Reference\n\nThis document provides detailed reference for all 18 commands in the C# Project Expert skill.\n\n## Command Categories\n\n- [Symbol Commands](#symbol-commands) - find-definition, find-references, rename, signature, list-members\n- [Compilation Commands](#compilation-commands) - diagnostics, check-symbol-exists\n- [Type Hierarchy Commands](#type-hierarchy-commands) - find-implementations, inheritance-tree\n- [Call Analysis Commands](#call-analysis-commands) - find-callers, find-callees\n- [Dependency Commands](#dependency-commands) - dependencies, unused-code\n- [Code Generation Commands](#code-generation-commands) - generate-interface, implement-interface\n- [Organization Commands](#organization-commands) - list-types, namespace-tree, analyze-file\n\n## Global Options\n\nAll commands support these global options:\n\n- `--solution, -s <path>` - Path to .sln file (optional - auto-discovers if not specified)\n- `--project, -p <path>` - Path to .csproj file (alternative to solution, also auto-discovers)\n- `--output, -o <format>` - Output format: `json`, `text`, or `markdown` (default: json)\n- `--verbose, -v` - Enable verbose logging\n\n### Auto-Discovery\n\nIf neither `--solution` nor `--project` is specified, the tool automatically searches the **current directory** for:\n1. **First priority**: `.sln` files (if exactly one is found, it's used)\n2. **Second priority**: `.csproj` files (if no .sln found and exactly one .csproj exists)\n\n**Error cases**:\n- Multiple `.sln` files found → Error (you must specify which one with `-s`)\n- Multiple `.csproj` files found (and no .sln) → Error (you must specify which one with `-p`)\n- No `.sln` or `.csproj` files found → Error\n\n---\n\n## Symbol Commands\n\n### find-definition\n\nFind where a symbol (class, method, property, etc.) is defined.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> find-definition <symbol-name> [options]\n```\n\n**Options:**\n- `--type, -t <type>` - Filter by symbol type: `class`, `method`, `property`, `field`, `interface`, `enum`\n- `--in-file, -f <path>` - Search only in specific file\n- `--in-namespace, -n <namespace>` - Search only in specific namespace\n\n**Examples:**\n```bash\n# Find a class (auto-discovers solution in current directory)\n./scripts/CSharpExpertCli find-definition UserService --type class\n\n# Find a method in a specific namespace (explicit solution path)\n./scripts/CSharpExpertCli -s MySolution.sln find-definition GetById \\\n  --type method \\\n  --in-namespace MyApp.Services\n\n# Find a property in a specific file\n./scripts/CSharpExpertCli find-definition UserId \\\n  --type property \\\n  --in-file src/Models/User.cs\n```\n\n**JSON Output:**\n```json\n{\n  \"symbol\": \"UserService\",\n  \"kind\": \"class\",\n  \"location\": {\n    \"file\": \"src/Services/UserService.cs\",\n    \"line\": 15,\n    \"column\": 18\n  },\n  \"namespace\": \"MyApp.Services\",\n  \"accessibility\": \"public\"\n}\n```\n\n---\n\n### find-references\n\nFind all references/usages of a symbol throughout the solution.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> find-references <symbol-name> [options]\n```\n\n**Options:**\n- `--type, -t <type>` - Symbol type to search for\n- `--in-namespace, -n <namespace>` - Symbol namespace\n\n**Examples:**\n```bash\n# Find all references to a method\n./scripts/CSharpExpertCli -s MySolution.sln find-references GetById --type method\n\n# Find all references to an interface\n./scripts/CSharpExpertCli -s MySolution.sln find-references IUserRepository \\\n  --type interface\n\n# Find references to a class\n./scripts/CSharpExpertCli -s MySolution.sln find-references UserDto --type class\n```\n\n**JSON Output:**\n```json\n{\n  \"symbol\": \"UserService.GetById\",\n  \"totalReferences\": 23,\n  \"references\": [\n    {\n      \"file\": \"src/Controllers/UserController.cs\",\n      \"line\": 45,\n      \"column\": 28,\n      \"context\": \"var user = _userService.GetById(id);\",\n      \"kind\": \"invocation\"\n    },\n    {\n      \"file\": \"src/Services/AdminService.cs\",\n      \"line\": 102,\n      \"column\": 15,\n      \"context\": \"return userService.GetById(adminId);\",\n      \"kind\": \"invocation\"\n    }\n  ]\n}\n```\n\n---\n\n### rename\n\nSafely rename a symbol across the entire solution with preview mode.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> rename <old-name> <new-name> [options]\n```\n\n**Options:**\n- `--type, -t <type>` - Type of symbol being renamed\n- `--in-namespace, -n <namespace>` - Limit scope to namespace\n- `--preview` - Show changes without applying them (RECOMMENDED)\n- `--rename-file` - Also rename the file if renaming a type (REQUIRED for classes/interfaces/types)\n\n**IMPORTANT:** When renaming classes, interfaces, or other types, ALWAYS use `--rename-file` to ensure the source file is renamed to match C# naming conventions (file name = type name).\n\n**Examples:**\n```bash\n# Preview rename (safe - shows changes without applying)\n./scripts/CSharpExpertCli -s MySolution.sln rename UserService UserManager \\\n  --type class \\\n  --preview\n\n# Apply rename and update file name\n./scripts/CSharpExpertCli -s MySolution.sln rename UserService UserManager \\\n  --type class \\\n  --rename-file\n\n# Rename a method\n./scripts/CSharpExpertCli -s MySolution.sln rename GetById FindById \\\n  --type method\n\n# Rename within specific namespace\n./scripts/CSharpExpertCli -s MySolution.sln rename Helper Utility \\\n  --type class \\\n  --in-namespace MyApp.Common\n```\n\n**JSON Output (Preview Mode):**\n```json\n{\n  \"symbol\": \"UserService\",\n  \"newName\": \"UserManager\",\n  \"changes\": [\n    {\n      \"file\": \"src/Services/UserService.cs\",\n      \"fileName\": \"UserManager.cs\",\n      \"edits\": [\n        {\"line\": 15, \"old\": \"class UserService\", \"new\": \"class UserManager\"},\n        {\"line\": 20, \"old\": \"public UserService(\", \"new\": \"public UserManager(\"}\n      ]\n    },\n    {\n      \"file\": \"src/Controllers/UserController.cs\",\n      \"edits\": [\n        {\"line\": 12, \"old\": \"private readonly UserService\", \"new\": \"private readonly UserManager\"}\n      ]\n    }\n  ],\n  \"totalChanges\": 47,\n  \"affectedFiles\": 12\n}\n```\n\n**Important:** Always use `--preview` first to verify changes before applying!\n\n---\n\n### signature\n\nGet the signature and documentation of a symbol.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> signature <symbol-name> [options]\n```\n\n**Options:**\n- `--type, -t <type>` - Type of symbol\n- `--include-overloads` - Show all overloads for methods\n- `--include-docs` - Include XML documentation comments (default: true)\n\n**Examples:**\n```bash\n# Get method signature with overloads\n./scripts/CSharpExpertCli -s MySolution.sln signature GetById \\\n  --type method \\\n  --include-overloads\n\n# Get class signature\n./scripts/CSharpExpertCli -s MySolution.sln signature UserService --type class\n\n# Get property signature\n./scripts/CSharpExpertCli -s MySolution.sln signature UserId --type property\n```\n\n**JSON Output:**\n```json\n{\n  \"symbol\": \"UserService.GetById\",\n  \"kind\": \"method\",\n  \"signatures\": [\n    {\n      \"declaration\": \"public User GetById(int id)\",\n      \"returnType\": \"User\",\n      \"parameters\": [\n        {\"name\": \"id\", \"type\": \"int\", \"isOptional\": false}\n      ],\n      \"accessibility\": \"public\",\n      \"isStatic\": false,\n      \"isAsync\": false,\n      \"documentation\": \"Retrieves a user by their unique identifier.\"\n    }\n  ]\n}\n```\n\n---\n\n### list-members\n\nList all members (methods, properties, fields) of a type.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> list-members <type-name> [options]\n```\n\n**Options:**\n- `--kind, -k <kind>` - Filter by member kind: `method`, `property`, `field`, `event`\n- `--accessibility, -a <level>` - Filter by: `public`, `private`, `protected`, `internal`\n- `--include-inherited` - Include inherited members\n\n**Examples:**\n```bash\n# List all members\n./scripts/CSharpExpertCli -s MySolution.sln list-members UserService\n\n# List only public methods\n./scripts/CSharpExpertCli -s MySolution.sln list-members User \\\n  --kind method \\\n  --accessibility public\n\n# List properties including inherited\n./scripts/CSharpExpertCli -s MySolution.sln list-members UserDto \\\n  --kind property \\\n  --include-inherited\n```\n\n**JSON Output:**\n```json\n{\n  \"type\": \"UserService\",\n  \"namespace\": \"MyApp.Services\",\n  \"members\": [\n    {\n      \"name\": \"GetById\",\n      \"kind\": \"method\",\n      \"accessibility\": \"public\",\n      \"returnType\": \"User\",\n      \"signature\": \"public User GetById(int id)\"\n    },\n    {\n      \"name\": \"GetAll\",\n      \"kind\": \"method\",\n      \"accessibility\": \"public\",\n      \"returnType\": \"List<User>\",\n      \"signature\": \"public List<User> GetAll()\"\n    }\n  ]\n}\n```\n\n---\n\n## Compilation Commands\n\n### diagnostics\n\nGet all compilation errors, warnings, and info messages.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> diagnostics [options]\n```\n\n**Options:**\n- `--severity, -s <level>` - Filter by severity: `error`, `warning`, `info`\n- `--file, -f <path>` - Get diagnostics only for specific file\n- `--code, -c <code>` - Filter by diagnostic code (e.g., CS0246)\n\n**Examples:**\n```bash\n# Get all errors\n./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error\n\n# Get diagnostics for specific file\n./scripts/CSharpExpertCli -s MySolution.sln diagnostics \\\n  --file src/UserService.cs \\\n  --severity warning\n\n# Filter by diagnostic code\n./scripts/CSharpExpertCli -s MySolution.sln diagnostics --code CS0246\n```\n\n**JSON Output:**\n```json\n{\n  \"totalDiagnostics\": 5,\n  \"errors\": 2,\n  \"warnings\": 3,\n  \"diagnostics\": [\n    {\n      \"severity\": \"error\",\n      \"code\": \"CS0246\",\n      \"message\": \"The type or namespace name 'UserDto' could not be found\",\n      \"file\": \"src/Services/UserService.cs\",\n      \"line\": 25,\n      \"column\": 20\n    }\n  ]\n}\n```\n\n---\n\n### check-symbol-exists\n\nQuickly verify if a symbol exists and is accessible.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> check-symbol-exists <symbol-name> [options]\n```\n\n**Options:**\n- `--type, -t <type>` - Expected symbol type\n- `--in-namespace, -n <namespace>` - Expected namespace\n\n**Examples:**\n```bash\n# Check if a class exists\n./scripts/CSharpExpertCli -s MySolution.sln check-symbol-exists UserDto --type class\n\n# Check if a method exists in a namespace\n./scripts/CSharpExpertCli -s MySolution.sln check-symbol-exists GetById \\\n  --type method \\\n  --in-namespace MyApp.Services\n```\n\n**JSON Output:**\n```json\n{\n  \"symbol\": \"UserDto\",\n  \"exists\": true,\n  \"kind\": \"class\",\n  \"namespace\": \"MyApp.Models\",\n  \"accessibility\": \"public\"\n}\n```\n\n---\n\n## Type Hierarchy Commands\n\n### find-implementations\n\nFind all implementations of an interface or abstract class.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> find-implementations <interface-name>\n```\n\n**Examples:**\n```bash\n# Find implementations of an interface\n./scripts/CSharpExpertCli -s MySolution.sln find-implementations IUserRepository\n\n# Find implementations of IDisposable\n./scripts/CSharpExpertCli -s MySolution.sln find-implementations IDisposable\n\n# Find implementations of abstract class\n./scripts/CSharpExpertCli -s MySolution.sln find-implementations BaseService\n```\n\n**JSON Output:**\n```json\n{\n  \"interface\": \"IUserRepository\",\n  \"implementations\": [\n    {\n      \"name\": \"UserRepository\",\n      \"namespace\": \"MyApp.Repositories\",\n      \"file\": \"src/Repositories/UserRepository.cs\",\n      \"line\": 10,\n      \"isAbstract\": false\n    },\n    {\n      \"name\": \"CachedUserRepository\",\n      \"namespace\": \"MyApp.Repositories\",\n      \"file\": \"src/Repositories/CachedUserRepository.cs\",\n      \"line\": 8,\n      \"isAbstract\": false\n    }\n  ]\n}\n```\n\n---\n\n### inheritance-tree\n\nShow inheritance hierarchy (ancestors and descendants).\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> inheritance-tree <type-name> [options]\n```\n\n**Options:**\n- `--direction, -d <dir>` - Show `ancestors`, `descendants`, or `both` (default: both)\n\n**Examples:**\n```bash\n# Show full inheritance tree\n./scripts/CSharpExpertCli -s MySolution.sln inheritance-tree UserService\n\n# Show only descendants\n./scripts/CSharpExpertCli -s MySolution.sln inheritance-tree BaseService --direction descendants\n\n# Show only ancestors\n./scripts/CSharpExpertCli -s MySolution.sln inheritance-tree AdminUserService --direction ancestors\n```\n\n**JSON Output:**\n```json\n{\n  \"type\": \"UserService\",\n  \"ancestors\": [\n    \"BaseService\",\n    \"Object\"\n  ],\n  \"descendants\": [\n    \"AdminUserService\",\n    \"GuestUserService\"\n  ],\n  \"interfaces\": [\n    \"IUserService\",\n    \"IDisposable\"\n  ]\n}\n```\n\n---\n\n## Call Analysis Commands\n\n### find-callers\n\nFind all methods that call a specific method.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> find-callers <method-name>\n```\n\n**Examples:**\n```bash\n# Find what calls GetById\n./scripts/CSharpExpertCli -s MySolution.sln find-callers GetById\n\n# Find what calls ProcessOrder\n./scripts/CSharpExpertCli -s MySolution.sln find-callers ProcessOrder\n```\n\n**JSON Output:**\n```json\n{\n  \"method\": \"UserService.GetById\",\n  \"callers\": [\n    {\n      \"caller\": \"UserController.GetUserById\",\n      \"file\": \"src/Controllers/UserController.cs\",\n      \"line\": 45,\n      \"context\": \"var user = _userService.GetById(id);\"\n    },\n    {\n      \"caller\": \"AdminService.GetAdminUser\",\n      \"file\": \"src/Services/AdminService.cs\",\n      \"line\": 102,\n      \"context\": \"return userService.GetById(adminId);\"\n    }\n  ]\n}\n```\n\n---\n\n### find-callees\n\nFind all methods called by a specific method.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> find-callees <method-name>\n```\n\n**Examples:**\n```bash\n# Find what GetUser calls\n./scripts/CSharpExpertCli -s MySolution.sln find-callees GetUser\n\n# Find what ProcessOrder calls\n./scripts/CSharpExpertCli -s MySolution.sln find-callees ProcessOrder\n```\n\n**JSON Output:**\n```json\n{\n  \"method\": \"UserService.GetUser\",\n  \"callees\": [\n    {\n      \"callee\": \"UserRepository.FindById\",\n      \"file\": \"src/Services/UserService.cs\",\n      \"line\": 35\n    },\n    {\n      \"callee\": \"UserMapper.MapToDto\",\n      \"file\": \"src/Services/UserService.cs\",\n      \"line\": 36\n    }\n  ]\n}\n```\n\n---\n\n## Dependency Commands\n\n### dependencies\n\nAnalyze what types/namespaces a file or type depends on.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> dependencies <file-or-type>\n```\n\n**Examples:**\n```bash\n# Analyze dependencies of a file\n./scripts/CSharpExpertCli -s MySolution.sln dependencies src/Controllers/UserController.cs\n\n# Analyze dependencies of a type\n./scripts/CSharpExpertCli -s MySolution.sln dependencies UserService\n```\n\n**JSON Output:**\n```json\n{\n  \"file\": \"src/Controllers/UserController.cs\",\n  \"dependencies\": {\n    \"namespaces\": [\n      \"MyApp.Services\",\n      \"MyApp.Models\",\n      \"Microsoft.AspNetCore.Mvc\"\n    ],\n    \"types\": [\n      \"UserService\",\n      \"UserDto\",\n      \"IMapper\"\n    ]\n  }\n}\n```\n\n---\n\n### unused-code\n\nFind potentially unused code (methods, classes, properties).\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> unused-code\n```\n\n**Examples:**\n```bash\n# Find all unused code\n./scripts/CSharpExpertCli -s MySolution.sln unused-code\n```\n\n**JSON Output:**\n```json\n{\n  \"unusedSymbols\": [\n    {\n      \"symbol\": \"OldHelper.ProcessData\",\n      \"kind\": \"method\",\n      \"file\": \"src/Helpers/OldHelper.cs\",\n      \"line\": 45,\n      \"accessibility\": \"private\"\n    },\n    {\n      \"symbol\": \"TempClass\",\n      \"kind\": \"class\",\n      \"file\": \"src/Temp/TempClass.cs\",\n      \"line\": 10,\n      \"accessibility\": \"internal\"\n    }\n  ]\n}\n```\n\n---\n\n## Code Generation Commands\n\n### generate-interface\n\nExtract an interface from a class.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> generate-interface <class-name>\n```\n\n**Examples:**\n```bash\n# Generate interface from a class\n./scripts/CSharpExpertCli -s MySolution.sln generate-interface UserService\n\n# Generate interface in text format\n./scripts/CSharpExpertCli -s MySolution.sln -o text generate-interface UserService\n```\n\n**JSON Output:**\n```json\n{\n  \"interfaceName\": \"IUserService\",\n  \"code\": \"public interface IUserService\\n{\\n    User GetById(int id);\\n    List<User> GetAll();\\n}\"\n}\n```\n\n---\n\n### implement-interface\n\nGenerate implementation stubs for an interface.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> implement-interface <interface-name>\n```\n\n**Examples:**\n```bash\n# Generate implementation stubs\n./scripts/CSharpExpertCli -s MySolution.sln implement-interface IUserRepository\n\n# Generate stubs for IDisposable\n./scripts/CSharpExpertCli -s MySolution.sln implement-interface IDisposable\n```\n\n**JSON Output:**\n```json\n{\n  \"interface\": \"IUserRepository\",\n  \"stubs\": \"public class UserRepositoryImpl : IUserRepository\\n{\\n    public User FindById(int id)\\n    {\\n        throw new NotImplementedException();\\n    }\\n}\"\n}\n```\n\n---\n\n## Organization Commands\n\n### list-types\n\nList all types in a namespace or file.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> list-types [options]\n```\n\n**Options:**\n- `--namespace <namespace>` - Filter by namespace\n\n**Examples:**\n```bash\n# List all types in solution\n./scripts/CSharpExpertCli -s MySolution.sln list-types\n\n# List types in specific namespace\n./scripts/CSharpExpertCli -s MySolution.sln list-types --namespace MyApp.Services\n```\n\n**JSON Output:**\n```json\n{\n  \"types\": [\n    {\"name\": \"UserService\", \"kind\": \"class\", \"namespace\": \"MyApp.Services\"},\n    {\"name\": \"OrderService\", \"kind\": \"class\", \"namespace\": \"MyApp.Services\"},\n    {\"name\": \"IUserService\", \"kind\": \"interface\", \"namespace\": \"MyApp.Services\"}\n  ]\n}\n```\n\n---\n\n### namespace-tree\n\nShow the namespace hierarchy of the solution.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> namespace-tree\n```\n\n**Examples:**\n```bash\n# Show namespace tree\n./scripts/CSharpExpertCli -s MySolution.sln namespace-tree\n\n# Show namespace tree in markdown format\n./scripts/CSharpExpertCli -s MySolution.sln -o markdown namespace-tree\n```\n\n**JSON Output:**\n```json\n{\n  \"root\": \"MyApp\",\n  \"namespaces\": {\n    \"MyApp\": {\n      \"Services\": [\"UserService\", \"OrderService\"],\n      \"Models\": [\"User\", \"Order\"],\n      \"Controllers\": [\"UserController\", \"OrderController\"]\n    }\n  }\n}\n```\n\n---\n\n### analyze-file\n\nQuick comprehensive analysis of a single file.\n\n**Syntax:**\n```bash\n./scripts/CSharpExpertCli -s <solution> analyze-file <file-path>\n```\n\n**Examples:**\n```bash\n# Analyze a file\n./scripts/CSharpExpertCli -s MySolution.sln analyze-file src/Services/UserService.cs\n\n# Analyze in markdown format\n./scripts/CSharpExpertCli -s MySolution.sln -o markdown analyze-file src/Program.cs\n```\n\n**JSON Output:**\n```json\n{\n  \"file\": \"src/Services/UserService.cs\",\n  \"types\": [\n    {\"name\": \"UserService\", \"kind\": \"class\", \"members\": 8}\n  ],\n  \"dependencies\": [\"IUserRepository\", \"IMapper\"],\n  \"diagnostics\": [],\n  \"linesOfCode\": 145\n}\n```\n\n---\n\n## Exit Codes\n\n- `0` - Success\n- `1` - General error (exception, invalid arguments)\n- `2` - Not found (symbol not found, file not found)\n\n---\n\n## Output Formats\n\nAll commands support three output formats via `--output` or `-o`:\n\n### JSON (Default)\nMachine-readable, ideal for automation and parsing.\n\n### Text\nHuman-readable, good for terminal output and quick inspection.\n\n### Markdown\nFormatted for documentation and reports.\n\n---\n\n## Common Patterns\n\n### Piping Output\n\nSince all commands output to stdout, you can pipe results:\n\n```bash\n# Parse JSON with jq\n./scripts/CSharpExpertCli -s MySolution.sln find-definition UserService --type class | jq '.location.file'\n\n# Count references\n./scripts/CSharpExpertCli -s MySolution.sln find-references GetById --type method | jq '.totalReferences'\n```\n\n### Combining Commands\n\nUse multiple commands in sequence for complex analysis:\n\n```bash\n# Find a class, then list its members\n./scripts/CSharpExpertCli -s MySolution.sln find-definition UserService --type class\n./scripts/CSharpExpertCli -s MySolution.sln list-members UserService\n\n# Find a method, check its callers, then get its signature\n./scripts/CSharpExpertCli -s MySolution.sln find-callers ProcessOrder\n./scripts/CSharpExpertCli -s MySolution.sln signature ProcessOrder --type method\n```\n\n### Error Handling\n\nCheck exit codes for success:\n\n```bash\nif ./scripts/CSharpExpertCli -s MySolution.sln find-definition UserService --type class; then\n    echo \"Found UserService\"\nelse\n    echo \"UserService not found\"\nfi\n```\n",
        "skills/csharp-project-expert/references/EXAMPLES.md": "# Real-World Examples\n\nThis document provides real-world usage examples and integration patterns for the C# Project Expert skill.\n\n## Table of Contents\n\n- [Refactoring a Legacy Codebase](#refactoring-a-legacy-codebase)\n- [Understanding a New Project](#understanding-a-new-project)\n- [Pre-Merge Code Review](#pre-merge-code-review)\n- [Automated Code Quality Checks](#automated-code-quality-checks)\n- [Integration with CI/CD](#integration-with-cicd)\n- [JSON Parsing for Claude](#json-parsing-for-claude)\n- [Complex Multi-Step Scenarios](#complex-multi-step-scenarios)\n\n---\n\n## Refactoring a Legacy Codebase\n\n**Scenario:** You inherit a legacy C# project and need to modernize the data access layer. The old `UserRepository` class needs to be split into `UserReadRepository` and `UserWriteRepository`.\n\n### Step 1: Understand Current Usage\n\n```bash\n# Find all references to UserRepository\n./scripts/CSharpExpertCli -s LegacyApp.sln find-references UserRepository \\\n  --type class \\\n  -o json | jq '{total: .totalReferences, files: [.references[].file] | unique | length}'\n```\n\n**Output:**\n```json\n{\n  \"total\": 47,\n  \"files\": 12\n}\n```\n\n**Analysis:** 47 usages across 12 files. This is a significant change.\n\n### Step 2: Categorize Methods\n\n```bash\n# List all methods to categorize as read vs write\n./scripts/CSharpExpertCli -s LegacyApp.sln list-members UserRepository \\\n  --kind method \\\n  --accessibility public \\\n  -o json | jq '.members[] | {name, signature}'\n```\n\n**Output:**\n```json\n[\n  {\"name\": \"GetById\", \"signature\": \"public User GetById(int id)\"},\n  {\"name\": \"GetAll\", \"signature\": \"public List<User> GetAll()\"},\n  {\"name\": \"Create\", \"signature\": \"public void Create(User user)\"},\n  {\"name\": \"Update\", \"signature\": \"public void Update(User user)\"},\n  {\"name\": \"Delete\", \"signature\": \"public void Delete(int id)\"}\n]\n```\n\n**Categorization:**\n- **Read**: `GetById`, `GetAll`\n- **Write**: `Create`, `Update`, `Delete`\n\n### Step 3: Check Dependencies\n\n```bash\n# See what UserRepository depends on\n./scripts/CSharpExpertCli -s LegacyApp.sln dependencies UserRepository \\\n  -o json | jq '.dependencies'\n```\n\n### Step 4: Generate New Interfaces\n\n```bash\n# Generate interface to understand structure\n./scripts/CSharpExpertCli -s LegacyApp.sln generate-interface UserRepository -o text\n```\n\n**Result:** Use this as a template to create `IUserReadRepository` and `IUserWriteRepository`.\n\n### Step 5: Find Impact of Each Method\n\nFor each method you're moving:\n\n```bash\n#!/bin/bash\nfor method in \"GetById\" \"GetAll\" \"Create\" \"Update\" \"Delete\"; do\n    echo \"=== $method Usage ===\"\n    ./scripts/CSharpExpertCli -s LegacyApp.sln find-callers \"$method\" | \\\n      jq '{method: \"'$method'\", callers: .callers | length}'\ndone\n```\n\n**Output:**\n```json\n{\"method\": \"GetById\", \"callers\": 15}\n{\"method\": \"GetAll\", \"callers\": 8}\n{\"method\": \"Create\", \"callers\": 12}\n{\"method\": \"Update\", \"callers\": 7}\n{\"method\": \"Delete\", \"callers\": 5}\n```\n\n---\n\n## Understanding a New Project\n\n**Scenario:** First day on a new team. Need to understand the project structure quickly.\n\n### Quick Project Overview\n\n```bash\n#!/bin/bash\nSOLUTION=\"NewProject.sln\"\n\necho \"===New Project Analysis ===\"\necho\n\n# 1. Namespace structure\necho \"1. Namespace Structure:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" namespace-tree -o text | head -20\n\n# 2. Count types by namespace\necho -e \"\\n2. Type Counts by Namespace:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" list-types -o json | \\\n  jq -r '.types | group_by(.namespace) | .[] | \"\\(.[0].namespace): \\(length) types\"'\n\n# 3. Find entry point\necho -e \"\\n3. Entry Points:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" find-definition Main --type method -o text\n\n# 4. Find key interfaces\necho -e \"\\n4. Key Interfaces:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" list-types -o json | \\\n  jq -r '.types[] | select(.kind == \"interface\") | .name' | head -10\n\n# 5. Check for compilation issues\necho -e \"\\n5. Health Check:\"\nERROR_COUNT=$(./scripts/CSharpExpertCli -s \"$SOLUTION\" diagnostics --severity error -o json | jq '.errors')\nWARNING_COUNT=$(./scripts/CSharpExpertCli -s \"$SOLUTION\" diagnostics --severity warning -o json | jq '.warnings')\necho \"Errors: $ERROR_COUNT, Warnings: $WARNING_COUNT\"\n```\n\n### Exploring a Specific Feature\n\n```bash\n#!/bin/bash\n# Understand the \"User Management\" feature\n\nSOLUTION=\"NewProject.sln\"\nNAMESPACE=\"NewProject.UserManagement\"\n\necho \"=== User Management Feature Analysis ===\"\n\n# 1. List all types in this namespace\necho -e \"\\n1. Types in $NAMESPACE:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" list-types --namespace \"$NAMESPACE\" -o text\n\n# 2. For each service, show what it does\nfor service in $(./scripts/CSharpExpertCli -s \"$SOLUTION\" list-types --namespace \"$NAMESPACE\" -o json | \\\n  jq -r '.types[] | select(.name | endswith(\"Service\")) | .name'); do\n\n    echo -e \"\\n=== $service ===\"\n\n    # Show public methods\n    echo \"Public Methods:\"\n    ./scripts/CSharpExpertCli -s \"$SOLUTION\" list-members \"$service\" \\\n      --kind method \\\n      --accessibility public \\\n      -o text | grep \"Name:\" | sed 's/Name: /  - /'\n\n    # Show dependencies\n    echo \"Dependencies:\"\n    ./scripts/CSharpExpertCli -s \"$SOLUTION\" dependencies \"$service\" -o json | \\\n      jq -r '.dependencies.types[]' | sed 's/^/  - /'\ndone\n```\n\n---\n\n## Pre-Merge Code Review\n\n**Scenario:** Reviewing a pull request that refactors the authentication system.\n\n### Automated PR Review Script\n\n```bash\n#!/bin/bash\nSOLUTION=\"MyApp.sln\"\nBASE_BRANCH=\"main\"\nPR_BRANCH=\"feature/auth-refactor\"\n\necho \"=== PR Review: $PR_BRANCH ===\"\n\n# 1. Get list of changed C# files\ngit diff \"$BASE_BRANCH\"...\"$PR_BRANCH\" --name-only | grep '\\.cs$' > changed_files.txt\n\necho \"Changed Files: $(wc -l < changed_files.txt)\"\n\n# 2. Check each file for issues\nwhile IFS= read -r file; do\n    echo -e \"\\n=== Analyzing $file ===\"\n\n    # Check for new errors\n    ./scripts/CSharpExpertCli -s \"$SOLUTION\" diagnostics --file \"$file\" --severity error -o json > /tmp/diagnostics.json\n\n    ERROR_COUNT=$(jq '.errors' < /tmp/diagnostics.json)\n    if [ \"$ERROR_COUNT\" -gt 0 ]; then\n        echo \"❌ $ERROR_COUNT errors found:\"\n        jq -r '.diagnostics[] | \"  Line \\(.line): \\(.message)\"' < /tmp/diagnostics.json\n    fi\n\n    # Check for new warnings\n    WARNING_COUNT=$(./scripts/CSharpExpertCli -s \"$SOLUTION\" diagnostics --file \"$file\" --severity warning -o json | jq '.warnings')\n    if [ \"$WARNING_COUNT\" -gt 0 ]; then\n        echo \"⚠️  $WARNING_COUNT warnings found\"\n    fi\n\ndone < changed_files.txt\n\n# 3. Check if any public APIs were changed\necho -e \"\\n=== Public API Changes ===\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" list-types --namespace \"MyApp.Auth\" -o json | \\\n  jq -r '.types[] | select(.kind == \"interface\" or .kind == \"class\") | .name' | \\\n  while read -r type; do\n      echo \"Checking $type for breaking changes...\"\n      # Compare members before/after (requires checking out both branches)\n  done\n\n# 4. Summary\necho -e \"\\n=== Summary ===\"\nTOTAL_ERRORS=$(find /tmp -name \"diagnostics.json\" -exec jq -s 'map(.errors) | add' {} \\;)\necho \"Total Errors: ${TOTAL_ERRORS:-0}\"\necho \"Review complete.\"\n```\n\n---\n\n## Automated Code Quality Checks\n\n**Scenario:** Run automated quality checks before every commit.\n\n### Git Pre-Commit Hook\n\nCreate `.git/hooks/pre-commit`:\n\n```bash\n#!/bin/bash\nset -e\n\nSOLUTION=\"MyApp.sln\"\nSKILL_PATH=\"./skills/csharp-project-expert/scripts/CSharpExpertCli\"\n\necho \"Running code quality checks...\"\n\n# Get staged .cs files\nSTAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\\.cs$' || true)\n\nif [ -z \"$STAGED_FILES\" ]; then\n    echo \"No C# files changed.\"\n    exit 0\nfi\n\n# 1. Check for compilation errors\necho \"Checking for compilation errors...\"\nERROR_COUNT=$(\"$SKILL_PATH\" -s \"$SOLUTION\" diagnostics --severity error -o json | jq '.errors')\n\nif [ \"$ERROR_COUNT\" -gt 0 ]; then\n    echo \"❌ Found $ERROR_COUNT compilation errors. Fix before committing.\"\n    \"$SKILL_PATH\" -s \"$SOLUTION\" diagnostics --severity error -o text\n    exit 1\nfi\n\n# 2. Check each staged file for warnings\necho \"Checking staged files for warnings...\"\nfor file in $STAGED_FILES; do\n    WARNING_COUNT=$(\"$SKILL_PATH\" -s \"$SOLUTION\" diagnostics --file \"$file\" --severity warning -o json | jq '.warnings')\n\n    if [ \"$WARNING_COUNT\" -gt 3 ]; then\n        echo \"⚠️  $file has $WARNING_COUNT warnings (threshold: 3)\"\n        \"$SKILL_PATH\" -s \"$SOLUTION\" diagnostics --file \"$file\" --severity warning -o text\n        read -p \"Continue anyway? (y/n) \" -n 1 -r\n        echo\n        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n            exit 1\n        fi\n    fi\ndone\n\n# 3. Check for unused code in staged files\necho \"Checking for unused code...\"\nUNUSED=$(\"$SKILL_PATH\" -s \"$SOLUTION\" unused-code -o json)\nUNUSED_COUNT=$(echo \"$UNUSED\" | jq '.unusedSymbols | length')\n\nif [ \"$UNUSED_COUNT\" -gt 0 ]; then\n    echo \"ℹ️  Found $UNUSED_COUNT potentially unused symbols\"\n    # Don't block commit, just inform\nfi\n\necho \"✅ Code quality checks passed!\"\nexit 0\n```\n\nMake it executable:\n```bash\nchmod +x .git/hooks/pre-commit\n```\n\n---\n\n## Integration with CI/CD\n\n### GitHub Actions Workflow\n\n`.github/workflows/code-quality.yml`:\n\n```yaml\nname: Code Quality\n\non: [pull_request]\n\njobs:\n  analyze:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v3\n        with:\n          dotnet-version: '10.0.x'\n\n      - name: Restore dependencies\n        run: dotnet restore\n\n      - name: Download C# Project Expert Skill\n        run: |\n          wget https://github.com/your-org/csharp-project-expert/releases/latest/download/csharp-project-expert-v1.0.0.zip\n          unzip csharp-project-expert-v1.0.0.zip\n          chmod +x csharp-project-expert/scripts/CSharpExpertCli\n\n      - name: Check for compilation errors\n        run: |\n          ERROR_COUNT=$(./csharp-project-expert/scripts/CSharpExpertCli -s MyApp.sln diagnostics --severity error -o json | jq '.errors')\n          if [ \"$ERROR_COUNT\" -gt 0 ]; then\n            echo \"Found $ERROR_COUNT errors\"\n            ./csharp-project-expert/scripts/CSharpExpertCli -s MyApp.sln diagnostics --severity error -o text\n            exit 1\n          fi\n\n      - name: Check for unused code\n        run: |\n          ./csharp-project-expert/scripts/CSharpExpertCli -s MyApp.sln unused-code -o json > unused.json\n          UNUSED_COUNT=$(jq '.unusedSymbols | length' unused.json)\n          echo \"Found $UNUSED_COUNT unused symbols\"\n\n      - name: Upload unused code report\n        uses: actions/upload-artifact@v3\n        with:\n          name: unused-code-report\n          path: unused.json\n```\n\n---\n\n## JSON Parsing for Claude\n\n**Scenario:** Claude needs to parse and understand the output for further processing.\n\n### Example: Finding All Controllers and Their Actions\n\n```bash\n# Get all controller classes\n./scripts/CSharpExpertCli -s WebApp.sln list-types --namespace \"WebApp.Controllers\" -o json > controllers.json\n\n# For each controller, get actions (public methods)\njq -r '.types[] | select(.name | endswith(\"Controller\")) | .name' controllers.json | \\\n  while read -r controller; do\n    echo \"=== $controller Actions ===\"\n    ./scripts/CSharpExpertCli -s WebApp.sln list-members \"$controller\" \\\n      --kind method \\\n      --accessibility public \\\n      -o json | \\\n      jq -r '.members[] | \"  - \\(.name): \\(.returnType)\"'\n  done\n```\n\n**Output for Claude to Process:**\n```\n=== UserController Actions ===\n  - GetUsers: List<User>\n  - GetUser: User\n  - CreateUser: ActionResult\n  - UpdateUser: ActionResult\n  - DeleteUser: ActionResult\n\n=== OrderController Actions ===\n  - GetOrders: List<Order>\n  - GetOrder: Order\n  - CreateOrder: ActionResult\n```\n\n### Example: Build Dependency Graph\n\n```bash\n#!/bin/bash\n# Generate a dependency graph for Claude to visualize\n\nSOLUTION=\"MyApp.sln\"\nNAMESPACE=\"MyApp.Services\"\n\necho \"{\"\necho '  \"namespace\": \"'$NAMESPACE'\",'\necho '  \"dependencies\": ['\n\nFIRST=true\n./scripts/CSharpExpertCli -s \"$SOLUTION\" list-types --namespace \"$NAMESPACE\" -o json | \\\n  jq -r '.types[].name' | \\\n  while read -r type; do\n    if [ \"$FIRST\" = true ]; then\n        FIRST=false\n    else\n        echo \"    ,\"\n    fi\n\n    DEPS=$(./scripts/CSharpExpertCli -s \"$SOLUTION\" dependencies \"$type\" -o json 2>/dev/null | \\\n      jq -c '{type: \"'$type'\", dependsOn: .dependencies.types}')\n    echo -n \"    $DEPS\"\n  done\n\necho\necho \"  ]\"\necho \"}\"\n```\n\n**Claude can then visualize:**\n```\nUserService depends on:\n  → IUserRepository\n  → IMapper\n  → ILogger\n\nOrderService depends on:\n  → IOrderRepository\n  → IUserRepository\n  → IPaymentService\n```\n\n---\n\n## Complex Multi-Step Scenarios\n\n### Scenario: Extract and Implement CQRS Pattern\n\n**Goal:** Refactor a service layer to use CQRS (Command Query Responsibility Segregation).\n\n```bash\n#!/bin/bash\nSERVICE=\"UserService\"\nSOLUTION=\"MyApp.sln\"\n\necho \"=== CQRS Refactoring for $SERVICE ===\"\n\n# Step 1: List all methods\necho \"1. Analyzing methods...\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" list-members \"$SERVICE\" \\\n  --kind method \\\n  --accessibility public \\\n  -o json > /tmp/methods.json\n\n# Step 2: Categorize as Query (read) or Command (write)\necho \"2. Categorizing methods...\"\nQUERIES=$(jq -r '.members[] | select(.name | startswith(\"Get\") or startswith(\"Find\") or startswith(\"List\")) | .name' < /tmp/methods.json)\nCOMMANDS=$(jq -r '.members[] | select(.name | startswith(\"Create\") or startswith(\"Update\") or startswith(\"Delete\") or startswith(\"Save\")) | .name' < /tmp/methods.json)\n\necho \"Queries: $(echo \"$QUERIES\" | wc -l)\"\necho \"$QUERIES\" | sed 's/^/  - /'\n\necho \"Commands: $(echo \"$COMMANDS\" | wc -l)\"\necho \"$COMMANDS\" | sed 's/^/  - /'\n\n# Step 3: For each query, generate interface\necho -e \"\\n3. Generating Query Interfaces...\"\nfor query in $QUERIES; do\n    ./scripts/CSharpExpertCli -s \"$SOLUTION\" signature \"$query\" \\\n      --type method \\\n      -o json | \\\n      jq -r '.signatures[0] | \"public interface I\\(input.query)Query { \\(.returnType) Execute(\\(.parameters | map(\"\\(.type) \\(.name)\") | join(\", \"))); }\"' \\\n        --arg query \"$query\"\ndone\n\n# Step 4: Check impact of splitting the service\necho -e \"\\n4. Impact Analysis...\"\nfor method in $QUERIES $COMMANDS; do\n    CALLER_COUNT=$(./scripts/CSharpExpertCli -s \"$SOLUTION\" find-callers \"$method\" -o json | jq '.callers | length')\n    echo \"$method is called from $CALLER_COUNT places\"\ndone\n\n# Step 5: Suggest new structure\necho -e \"\\n5. Suggested Structure:\"\necho \"  - IUserQueryService (with $(echo \"$QUERIES\" | wc -l) methods)\"\necho \"  - IUserCommandService (with $(echo \"$COMMANDS\" | wc -l) methods)\"\necho \"  - Refactor $(./scripts/CSharpExpertCli -s \"$SOLUTION\" find-references \"$SERVICE\" -o json | jq '.totalReferences') references\"\n```\n\n---\n\n## Performance Benchmarking\n\n```bash\n#!/bin/bash\n# Compare tool performance vs manual searching\n\nSOLUTION=\"LargeSolution.sln\"\n\necho \"=== Performance Comparison ===\"\n\n# Benchmark: Find all references to a common symbol\necho \"1. Finding references to 'Logger'...\"\n\n# Using C# Project Expert\nSTART=$(date +%s%N)\n./scripts/CSharpExpertCli -s \"$SOLUTION\" find-references Logger --type class -o json > /dev/null\nEND=$(date +%s%N)\nTOOL_TIME=$(echo \"scale=3; ($END - $START) / 1000000000\" | bc)\n\n# Using grep (for comparison)\nSTART=$(date +%s%N)\ngrep -r \"Logger\" --include=\"*.cs\" . > /dev/null 2>&1\nEND=$(date +%s%N)\nGREP_TIME=$(echo \"scale=3; ($END - $START) / 1000000000\" | bc)\n\necho \"C# Project Expert: ${TOOL_TIME}s (accurate, semantic)\"\necho \"grep: ${GREP_TIME}s (fast but imprecise)\"\n\n# Count accuracy\nTOOL_COUNT=$(./scripts/CSharpExpertCli -s \"$SOLUTION\" find-references Logger --type class -o json | jq '.totalReferences')\nGREP_COUNT=$(grep -r \"Logger\" --include=\"*.cs\" . 2>/dev/null | wc -l)\n\necho \"Tool found: $TOOL_COUNT references (actual usage)\"\necho \"grep found: $GREP_COUNT matches (includes comments, strings)\"\n```\n\n---\n\nThese examples demonstrate real-world usage patterns and show how the C# Project Expert skill can be integrated into development workflows, automation scripts, and CI/CD pipelines.\n",
        "skills/csharp-project-expert/references/WORKFLOWS.md": "# Workflows and Best Practices\n\nThis document provides detailed workflows and best practices for using the C# Project Expert skill effectively.\n\n## Table of Contents\n\n- [Safe Refactoring Workflow](#safe-refactoring-workflow)\n- [Understanding Unfamiliar Code](#understanding-unfamiliar-code)\n- [Code Quality Analysis](#code-quality-analysis)\n- [Interface Implementation Workflow](#interface-implementation-workflow)\n- [Dependency Auditing](#dependency-auditing)\n- [Large-Scale Renaming](#large-scale-renaming)\n- [Best Practices](#best-practices)\n- [Anti-Patterns to Avoid](#anti-patterns-to-avoid)\n\n---\n\n## Safe Refactoring Workflow\n\nWhen making changes to existing code, follow these steps to ensure safety and prevent breaking changes.\n\n### Step 1: Understand Current Usage\n\nBefore changing any symbol, understand how it's currently used:\n\n```bash\n# Find all references to the method you want to change\n./scripts/CSharpExpertCli -s MySolution.sln find-references GetById --type method -o text\n\n# Count total references (using JSON)\n./scripts/CSharpExpertCli -s MySolution.sln find-references GetById --type method | jq '.totalReferences'\n```\n\n**Why:** Knowing who uses your code helps you assess impact and plan the refactoring.\n\n### Step 2: Check Method Signature\n\nUnderstand the current contract:\n\n```bash\n# Get full signature with documentation\n./scripts/CSharpExpertCli -s MySolution.sln signature GetById \\\n  --type method \\\n  --include-overloads \\\n  --include-docs \\\n  -o text\n```\n\n### Step 3: Preview Changes\n\nAlways preview before applying changes:\n\n```bash\n# Preview rename to see exact changes\n./scripts/CSharpExpertCli -s MySolution.sln rename GetById FindById \\\n  --type method \\\n  --preview \\\n  -o text\n```\n\nReview the output carefully. Look for:\n- Total number of changes\n- Affected files\n- Specific line-by-line edits\n\n### Step 4: Apply Changes\n\nOnce you're confident:\n\n```bash\n# Apply the rename\n./scripts/CSharpExpertCli -s MySolution.sln rename GetById FindById --type method\n```\n\n### Step 5: Verify Success\n\nCheck that no new errors were introduced:\n\n```bash\n# Check for compilation errors\n./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error\n\n# Verify the new symbol exists\n./scripts/CSharpExpertCli -s MySolution.sln check-symbol-exists FindById --type method\n```\n\n**Complete Example:**\n\n```bash\n# 1. Check current usage\necho \"=== Current Usage ===\"\n./scripts/CSharpExpertCli -s MySolution.sln find-references GetById --type method -o text\n\n# 2. Get signature\necho -e \"\\n=== Method Signature ===\"\n./scripts/CSharpExpertCli -s MySolution.sln signature GetById --type method -o text\n\n# 3. Preview rename\necho -e \"\\n=== Preview Changes ===\"\n./scripts/CSharpExpertCli -s MySolution.sln rename GetById FindById \\\n  --type method \\\n  --preview \\\n  -o text\n\n# 4. Ask for confirmation\nread -p \"Apply changes? (y/n) \" -n 1 -r\necho\nif [[ $REPLY =~ ^[Yy]$ ]]; then\n    # 5. Apply rename\n    ./scripts/CSharpExpertCli -s MySolution.sln rename GetById FindById --type method\n\n    # 6. Verify\n    echo -e \"\\n=== Checking for Errors ===\"\n    ./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error\nfi\n```\n\n---\n\n## Understanding Unfamiliar Code\n\nWhen exploring a codebase you're not familiar with, use this systematic approach.\n\n### Step 1: Find the Type\n\nLocate the class or interface:\n\n```bash\n# Find where UserService is defined\n./scripts/CSharpExpertCli -s MySolution.sln find-definition UserService --type class -o text\n```\n\n### Step 2: Explore Members\n\nSee what the type can do:\n\n```bash\n# List all public members\n./scripts/CSharpExpertCli -s MySolution.sln list-members UserService \\\n  --accessibility public \\\n  -o text\n```\n\n### Step 3: Check Inheritance\n\nUnderstand the type hierarchy:\n\n```bash\n# See what it inherits and implements\n./scripts/CSharpExpertCli -s MySolution.sln inheritance-tree UserService -o text\n```\n\n### Step 4: Analyze Dependencies\n\nSee what this type depends on:\n\n```bash\n# Find dependencies\n./scripts/CSharpExpertCli -s MySolution.sln dependencies UserService -o text\n```\n\n### Step 5: Examine Key Methods\n\nFor each important method, get details:\n\n```bash\n# Get method signature with documentation\n./scripts/CSharpExpertCli -s MySolution.sln signature GetUser \\\n  --type method \\\n  --include-docs \\\n  -o text\n\n# See what calls this method\n./scripts/CSharpExpertCli -s MySolution.sln find-callers GetUser -o text\n\n# See what this method calls\n./scripts/CSharpExpertCli -s MySolution.sln find-callees GetUser -o text\n```\n\n**Complete Exploration Script:**\n\n```bash\n#!/bin/bash\nTYPE_NAME=$1\nSOLUTION=$2\n\necho \"=== Exploring $TYPE_NAME in $SOLUTION ===\"\n\necho -e \"\\n1. Location:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" find-definition \"$TYPE_NAME\" --type class -o text\n\necho -e \"\\n2. Public Members:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" list-members \"$TYPE_NAME\" --accessibility public -o text\n\necho -e \"\\n3. Inheritance:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" inheritance-tree \"$TYPE_NAME\" -o text\n\necho -e \"\\n4. Dependencies:\"\n./scripts/CSharpExpertCli -s \"$SOLUTION\" dependencies \"$TYPE_NAME\" -o text\n```\n\nUsage: `./explore-type.sh UserService MySolution.sln`\n\n---\n\n## Code Quality Analysis\n\nPerform comprehensive code quality checks before committing or deploying.\n\n### Pre-Commit Checklist\n\n```bash\n# 1. Check for compilation errors\necho \"=== Checking for Errors ===\"\nERROR_COUNT=$(./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error | jq '.errors')\n\nif [ \"$ERROR_COUNT\" -gt 0 ]; then\n    echo \"❌ Found $ERROR_COUNT errors\"\n    ./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error -o text\n    exit 1\nfi\n\n# 2. Check for warnings in changed files\necho -e \"\\n=== Checking Warnings in Changed Files ===\"\nfor file in $(git diff --name-only --cached | grep '\\.cs$'); do\n    echo \"Checking $file...\"\n    ./scripts/CSharpExpertCli -s MySolution.sln diagnostics --file \"$file\" --severity warning -o text\ndone\n\n# 3. Look for unused code\necho -e \"\\n=== Checking for Unused Code ===\"\n./scripts/CSharpExpertCli -s MySolution.sln unused-code -o text\n\necho -e \"\\n✅ Code quality checks passed\"\n```\n\n### Analyzing Technical Debt\n\nIdentify areas needing attention:\n\n```bash\n# Find unused code\n./scripts/CSharpExpertCli -s MySolution.sln unused-code | \\\n  jq -r '.unusedSymbols[] | \"\\(.file):\\(.line) - \\(.symbol) (\\(.kind))\"'\n\n# Find classes with many dependencies (potential code smell)\nfor class in $(./scripts/CSharpExpertCli -s MySolution.sln list-types | jq -r '.types[].name'); do\n    dep_count=$(./scripts/CSharpExpertCli -s MySolution.sln dependencies \"$class\" | \\\n      jq '.dependencies.types | length')\n    if [ \"$dep_count\" -gt 10 ]; then\n        echo \"$class has $dep_count dependencies\"\n    fi\ndone\n```\n\n---\n\n## Interface Implementation Workflow\n\nWhen implementing a new class that uses an interface.\n\n### Step 1: Find Interface Definition\n\n```bash\n# Locate the interface\n./scripts/CSharpExpertCli -s MySolution.sln find-definition IUserRepository --type interface -o text\n```\n\n### Step 2: See Existing Implementations\n\nLearn from existing code:\n\n```bash\n# Find who already implements this\n./scripts/CSharpExpertCli -s MySolution.sln find-implementations IUserRepository -o text\n```\n\n### Step 3: Generate Implementation Stubs\n\nGet a starting point:\n\n```bash\n# Generate implementation code\n./scripts/CSharpExpertCli -s MySolution.sln implement-interface IUserRepository -o text\n```\n\n### Step 4: Understand Interface Members\n\nKnow what you need to implement:\n\n```bash\n# List all interface members\n./scripts/CSharpExpertCli -s MySolution.sln list-members IUserRepository -o text\n\n# Get detailed signatures\n./scripts/CSharpExpertCli -s MySolution.sln signature IUserRepository \\\n  --type interface \\\n  --include-docs \\\n  -o text\n```\n\n---\n\n## Dependency Auditing\n\nAnalyze and manage dependencies in your solution.\n\n### Finding Circular Dependencies\n\n```bash\n#!/bin/bash\n# Check for potential circular dependencies\n\necho \"Analyzing dependencies for circular references...\"\n\nfor type in $(./scripts/CSharpExpertCli -s MySolution.sln list-types | jq -r '.types[].name'); do\n    deps=$(./scripts/CSharpExpertCli -s MySolution.sln dependencies \"$type\" 2>/dev/null | \\\n      jq -r '.dependencies.types[]?' 2>/dev/null)\n\n    for dep in $deps; do\n        # Check if dependency also depends on original type\n        reverse_deps=$(./scripts/CSharpExpertCli -s MySolution.sln dependencies \"$dep\" 2>/dev/null | \\\n          jq -r '.dependencies.types[]?' 2>/dev/null)\n\n        if echo \"$reverse_deps\" | grep -q \"^$type$\"; then\n            echo \"⚠️  Circular dependency: $type <-> $dep\"\n        fi\n    done\ndone\n```\n\n### Dependency Graph\n\nCreate a dependency map for a namespace:\n\n```bash\n# Analyze all types in a namespace\nNAMESPACE=\"MyApp.Services\"\n\necho \"Dependency graph for $NAMESPACE:\"\nfor type in $(./scripts/CSharpExpertCli -s MySolution.sln list-types --namespace \"$NAMESPACE\" | \\\n  jq -r '.types[].name'); do\n    echo -e \"\\n$type depends on:\"\n    ./scripts/CSharpExpertCli -s MySolution.sln dependencies \"$type\" | \\\n      jq -r '.dependencies.types[]' | sed 's/^/  - /'\ndone\n```\n\n---\n\n## Large-Scale Renaming\n\nWhen renaming affects many files across the solution.\n\n### Planning Phase\n\n```bash\n# 1. Assess impact\necho \"=== Impact Assessment ===\"\n./scripts/CSharpExpertCli -s MySolution.sln find-references OldClassName --type class | \\\n  jq '{totalReferences, affectedFiles: [.references[].file] | unique | length}'\n\n# 2. Preview all changes (including file rename)\necho -e \"\\n=== Preview Changes ===\"\n./scripts/CSharpExpertCli -s MySolution.sln rename OldClassName NewClassName \\\n  --type class \\\n  --preview \\\n  --rename-file \\\n  -o text > rename-preview.txt\n\n# Review the preview file\nless rename-preview.txt\n```\n\n### Execution Phase\n\n```bash\n# 1. Create a backup (git)\ngit add -A\ngit commit -m \"Backup before renaming OldClassName to NewClassName\"\n\n# 2. Apply rename (IMPORTANT: use --rename-file for classes to rename the source file too)\necho \"Applying rename...\"\n./scripts/CSharpExpertCli -s MySolution.sln rename OldClassName NewClassName \\\n  --type class \\\n  --rename-file\n\n# 3. Verify compilation\necho -e \"\\n=== Checking for Errors ===\"\nif ./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error | jq -e '.errors == 0' > /dev/null; then\n    echo \"✅ No compilation errors\"\n    git add -A\n    git commit -m \"Rename OldClassName to NewClassName\"\nelse\n    echo \"❌ Compilation errors found - review and fix\"\n    ./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error -o text\n    echo \"Consider: git reset --hard HEAD~1 to rollback\"\nfi\n```\n\n**IMPORTANT:** When renaming classes, interfaces, or other types, always use `--rename-file` to ensure the source file is renamed to match the type name. This follows C# naming conventions where the file name matches the primary type name.\n\n---\n\n## Best Practices\n\n### 1. Always Preview Before Refactoring\n\n```bash\n# GOOD\n./scripts/CSharpExpertCli -s MySolution.sln rename OldName NewName --preview\n# Review output, then apply if satisfied\n\n# BAD\n./scripts/CSharpExpertCli -s MySolution.sln rename OldName NewName\n# Direct application without preview\n```\n\n### 2. Use Specific Type Filters\n\n```bash\n# GOOD - Specific type\n./scripts/CSharpExpertCli -s MySolution.sln find-definition GetUser --type method\n\n# BAD - No type filter (may find wrong symbol)\n./scripts/CSharpExpertCli -s MySolution.sln find-definition GetUser\n```\n\n### 3. Check for Errors After Changes\n\n```bash\n# After any refactoring\n./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error\n```\n\n### 4. Use JSON for Automation\n\n```bash\n# GOOD - Parse JSON in scripts\nERROR_COUNT=$(./scripts/CSharpExpertCli -s MySolution.sln diagnostics --severity error | jq '.errors')\n\n# Less ideal - Parse text output\nERROR_COUNT=$(./scripts/CSharpExpertCli -s MySolution.sln -o text diagnostics --severity error | grep -c \"Error\")\n```\n\n### 5. Combine Commands for Complete Analysis\n\n```bash\n# Comprehensive method analysis\nMETHOD=\"ProcessOrder\"\n\necho \"=== Signature ===\"\n./scripts/CSharpExpertCli -s MySolution.sln signature \"$METHOD\" --type method -o text\n\necho -e \"\\n=== Who Calls This ===\"\n./scripts/CSharpExpertCli -s MySolution.sln find-callers \"$METHOD\" -o text\n\necho -e \"\\n=== What This Calls ===\"\n./scripts/CSharpExpertCli -s MySolution.sln find-callees \"$METHOD\" -o text\n```\n\n---\n\n## Anti-Patterns to Avoid\n\n### ❌ Don't Skip the Preview Step\n\n```bash\n# This is risky\n./scripts/CSharpExpertCli -s MySolution.sln rename ImportantClass NewName --rename-file\n```\n\n**Why:** You might not realize the full scope of changes. Always preview first.\n\n### ❌ Don't Ignore Compilation Errors\n\n```bash\n# Don't do this\n./scripts/CSharpExpertCli -s MySolution.sln rename Foo Bar\n# ... then continue without checking diagnostics\n```\n\n**Why:** Errors compound. Fix them immediately after refactoring.\n\n### ❌ Don't Use Text Parsing When JSON Is Available\n\n```bash\n# Don't do this\nCOUNT=$(./scripts/CSharpExpertCli -s MySolution.sln -o text find-references GetUser | grep -c \"Reference\")\n\n# Do this instead\nCOUNT=$(./scripts/CSharpExpertCli -s MySolution.sln find-references GetUser | jq '.totalReferences')\n```\n\n**Why:** Text output format may change. JSON is stable and precise.\n\n### ❌ Don't Rename Without Checking References\n\n```bash\n# Don't do this\n./scripts/CSharpExpertCli -s MySolution.sln rename GetUser FindUser --type method --preview\n\n# Do this instead\n./scripts/CSharpExpertCli -s MySolution.sln find-references GetUser --type method  # Check first\n./scripts/CSharpExpertCli -s MySolution.sln rename GetUser FindUser --type method --preview\n```\n\n**Why:** You need context on how many places will be affected.\n\n### ❌ Don't Make Assumptions About Symbol Types\n\n```bash\n# Don't do this (might find class instead of method)\n./scripts/CSharpExpertCli -s MySolution.sln find-definition GetUser\n\n# Do this instead\n./scripts/CSharpExpertCli -s MySolution.sln find-definition GetUser --type method\n```\n\n**Why:** Ambiguous symbols might exist as both class names and method names.\n\n---\n\n## Quick Reference Cheatsheet\n\n### Before Changing Code\n1. `find-references` - See who uses it\n2. `signature` - Understand the contract\n3. `find-callers` / `find-callees` - Analyze call graph\n\n### During Refactoring\n1. `rename --preview` - See what will change\n2. `rename` - Apply changes\n3. `diagnostics --severity error` - Check for errors\n\n### Exploring Code\n1. `find-definition` - Where is it?\n2. `list-members` - What can it do?\n3. `inheritance-tree` - How does it fit in?\n4. `dependencies` - What does it need?\n\n### Code Quality\n1. `diagnostics` - Find errors/warnings\n2. `unused-code` - Find dead code\n3. `check-symbol-exists` - Verify symbols exist\n"
      },
      "plugins": [
        {
          "name": "pvasek-skills",
          "source": "./",
          "description": "Collection of Claude Code skills including C# code analysis, and more.",
          "version": "0.0.0",
          "author": {
            "name": "Pavel Vasek"
          },
          "keywords": [
            "claude-code",
            "skills"
          ],
          "category": "development",
          "categories": [
            "claude-code",
            "development",
            "skills"
          ],
          "install_commands": [
            "/plugin marketplace add pvasek/claude-skills",
            "/plugin install pvasek-skills@pvasek-skills-marketplace"
          ]
        }
      ]
    }
  ]
}