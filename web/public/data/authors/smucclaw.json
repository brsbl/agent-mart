{
  "author": {
    "id": "smucclaw",
    "display_name": "SMU Centre for Computational Law",
    "avatar_url": "https://avatars.githubusercontent.com/u/66001179?v=4"
  },
  "marketplaces": [
    {
      "name": "legalese",
      "version": null,
      "description": "Official Legalese plugin marketplace for computational law tools",
      "repo_full_name": "smucclaw/l4-ide",
      "repo_url": "https://github.com/smucclaw/l4-ide",
      "repo_description": "L4 - rules-as-code - is an open-source functional specification language for business rules, legal contracts, and legislation/regulation, with a CNL syntax for isomorphism.",
      "signals": {
        "stars": 23,
        "forks": 6,
        "pushed_at": "2026-02-03T13:13:04Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"legalese\",\n  \"owner\": {\n    \"name\": \"Legalese\",\n    \"email\": \"hello@legalese.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Official Legalese plugin marketplace for computational law tools\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"l4-computational-law\",\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"legalese/l4-ide\",\n        \"path\": \"skill\"\n      },\n      \"description\": \"L4 programming language for computational law - encode contracts, regulations, and policies as executable, testable, verifiable programs\",\n      \"version\": \"0.1.0\",\n      \"author\": {\n        \"name\": \"Legalese\",\n        \"email\": \"hello@legalese.com\"\n      },\n      \"homepage\": \"https://github.com/legalese/l4-ide\",\n      \"repository\": \"https://github.com/legalese/l4-ide\",\n      \"license\": \"Apache 2.0\",\n      \"keywords\": [\n        \"legal\",\n        \"law\",\n        \"computational-law\",\n        \"contracts\",\n        \"regulations\",\n        \"formal-methods\",\n        \"verification\",\n        \"functional-programming\"\n      ],\n      \"category\": \"legal-tech\",\n      \"tags\": [\"legal\", \"computational-law\", \"formal-verification\", \"contracts\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"l4-computational-law\",\n  \"version\": \"0.1.0\",\n  \"description\": \"L4 programming language for computational law - encode contracts, regulations, and policies as executable, testable, verifiable programs\",\n  \"author\": {\n    \"name\": \"Legalese\",\n    \"email\": \"hello@legalese.com\",\n    \"url\": \"https://github.com/legalese\"\n  },\n  \"homepage\": \"https://github.com/legalese/l4-ide\",\n  \"repository\": \"https://github.com/legalese/l4-ide\",\n  \"license\": \"Apache 2.0\",\n  \"keywords\": [\n    \"legal\",\n    \"law\",\n    \"computational-law\",\n    \"contracts\",\n    \"regulations\",\n    \"formal-methods\",\n    \"verification\",\n    \"functional-programming\"\n  ],\n  \"skills\": \"./skill/\",\n  \"lspServers\": \"./.lsp.json\"\n}\n",
        "README.md": "# L4 with IDE\n\n**L4** is a domain-specific programming language for law, designed to bring software engineering rigor to legal drafting and contract analysis. Just as programmers have powerful IDEs, compilers, debuggers, and test suites, L4 provides legal professionals with a comprehensive toolchain for creating precise, unambiguous, and verifiable legal specifications.\n\n## What is L4?\n\nL4 treats legal rules and contracts as **executable specifications** rather than documents. Drawing from logic programming, functional programming, temporal logic, and formal verification, L4 allows you to:\n\n- **Formalize** legal rules with mathematical precision\n- **Test** contracts against scenarios before deployment\n- **Find** logical contradictions and loopholes automatically\n- **Generate** user-facing web applications from legal specifications\n- **Explain** decisions with audit-grade evaluation traces\n- **Integrate** with enterprise systems via REST APIs\n\nThis repository includes the L4 compiler toolchain, IDE extensions for Visual Studio Code, an interactive REPL, a web-based editor, visualization tools, and a decision service for runtime evaluation.\n\n## What Can You Do With L4?\n\n**\"After I convert my rules to L4, what can I usefully do with them?\"**\n\nFrom a single L4 source file, you automatically get:\n\n- ðŸŒ **REST APIs** - Expose functions as HTTP endpoints with `@export` annotation\n- ðŸ§™ **Web Applications** - Auto-generated questionnaires with smart question ordering\n- ðŸ’¬ **Chatbot Interfaces** - Natural language interface for non-technical users\n- ðŸ“Š **Interactive Visualizations** - Ladder diagrams and evaluation traces\n- ðŸ§ª **Test Suites** - Automated testing with golden files and assertions\n- ðŸ“š **Documentation** - JSON schemas, Swagger specs, and type definitions\n- ðŸ”— **Enterprise Integration** - JSON/REST/SQL bridges to existing systems\n\nSee [**doc/MARKETECTURE.md**](doc/MARKETECTURE.md) for the complete \"whole product\" picture of what L4 enables.\n\n## Real-World Impact\n\nL4 has been piloted with organizations in both public and private sectors:\n\n- **Government Regulatory Compliance**: Encoded secondary legislation to auto-generate web wizards that explain legal obligations to citizens. Formal verification discovered a race conditionâ€”a double bind where contradictory clauses could require and prohibit the same action simultaneously.\n\n- **Insurance Policy Analysis**: Formalized insurance contracts from major global providers, discovering ambiguities in payout formulas that potentially caused millions of dollars in claims leakage.\n\n- **Legislative Drafting**: Working with government legal drafting offices on rules-as-code initiatives, enabling legislation to be written in machine-verifiable form from the start.\n\n- **Commercial Agreements**: Transformed complex fee schedules and payment terms into L4, serving them via SQL-like APIs for enterprise system integration.\n\n## Documentation\n\n### For Developers\n\n- **[doc/dev/setup.md](./doc/dev/setup.md)** - Complete developer setup guide for Haskell and TypeScript development\n- **[doc/dev/local-config.md](./doc/dev/local-config.md)** - Local development guide (running with `cabal`)\n- **[dev-start.sh](./dev-start.sh)** - Helper script for starting services locally\n\n### For DevOps\n\n- **[doc/dev/deployment/provisioning.md](./doc/dev/deployment/provisioning.md)** - Setting up new servers from scratch (nixos-anywhere)\n- **[doc/dev/deployment/deployment.md](./doc/dev/deployment/deployment.md)** - Deploying to existing dev/prod servers\n- **[nix/README.md](./nix/README.md)** - NixOS configuration reference\n\n## Documentation\n\n### For Developers\n\n- **[dev-config.md](./dev-config.md)** - Local development guide (running with `cabal`)\n- **[dev-start.sh](./dev-start.sh)** - Helper script for starting services locally\n\n### For DevOps\n\n- **[PROVISIONING.md](./PROVISIONING.md)** - Setting up new servers from scratch (nixos-anywhere)\n- **[DEPLOYMENT.md](./DEPLOYMENT.md)** - Deploying to existing dev/prod servers\n- **[nix/README.md](./nix/README.md)** - NixOS configuration reference\n\n## Gallery\n\nSyntax Highlighting for Boolean-oriented decision logic\n\n![Syntax Highlighting Example](./doc/images/bna-code.png)\n\nDecision Logic Visualization as a ladder diagram circuit\n\n![Syntax Highlighting Example](./doc/images/bna-viz.png)\n\n## Trace Visualization\n\nCurious how an L4 decision actually unfolded? Every tool in this repo can show you the evaluation trace as a GraphViz diagram:\n\n- **CLI:** `jl4-cli --graphviz myfile.l4 > trace.dot`, then render with `dot -Tsvg trace.dot > trace.svg`.\n- **REPL:** Load a file, run `:trace your expression`, or turn on `:tracefile traces/session` to capture numbered `.dot` files with timestamps, imports, and the final result right in the header.\n- **Decision Service:** Call `POST /functions/<name>/evaluation?trace=full&graphviz=true` to get a `graphviz` object containing the DOT plus relative PNG/SVG URLs, or hit `evaluation/trace.png` / `trace.svg` directly for ready-to-share images. Batch requests set `graphviz=true` to attach an `@graphviz` blob (same `{dot,png,svg}` shape) per case.\n\nThese traces act like explainability receipts for deterministic logic: you can follow each node from the top-level question down to the exact condition or branch that determined the answer. Install GraphViz (`brew install graphviz` or `apt-get install graphviz`) to unlock the PNG/SVG outputs.\n\n## Trace Logging\n\nL4 provides audit-grade explainability and observability. Textual decision traces can be generated in plain text or JSON for archival purposes.\n\n## Status (December 2025)\n\n### Core Language Features âœ…\n\n- âœ… Functional core with layout-sensitive parsing\n- âœ… LET...IN expressions with Haskell-style recursive bindings\n- âœ… Mixfix and postfix operators for domain-specific syntax\n- âœ… Pattern matching for function definitions (in development)\n- âœ… Type coercion builtins (TOSTRING, TONUMBER, TODATE, TRUNC)\n- âœ… String manipulation primitives (SPLIT, CHARAT, CONCAT)\n- âœ… Math library with trigonometric functions (SQRT, EXPONENT, etc.)\n- âœ… Dictionary/map data structures in prelude\n- âœ… HTTP operations (POST, FETCH) for external API integration\n- âœ… JSON operations (JSONENCODE, JSONDECODE) with bidirectional type checking\n- âœ… Excel date compatibility for business applications\n- âœ… Temporal logic with multi-temporal evaluation contexts\n- âœ… Application libraries (jurisdiction, currency, legal persons, holdings)\n\n### IDE & Developer Tools âœ…\n\n- âœ… VS Code extension with syntax highlighting, type checking, and inline evaluation\n- âœ… LSP server with hover support for @desc annotations\n- âœ… Interactive REPL (jl4-repl) for live code exploration\n- âœ… Web-based editor at https://jl4.legalese.com/\n- âœ… CLI tool (jl4-cli) with unified GraphViz output control\n\n### Trace Visualization & Explainability âœ…\n\n- âœ… GraphViz evaluation trace visualization (Phase 1 complete)\n- âœ… Function body display with @desc semantic annotations\n- âœ… Conditional trace collection (controlled via CLI flags and API parameters)\n- âœ… Multiple output formats: DOT, PNG, SVG\n- âœ… Decision logic visualizer as ladder diagram circuits\n- ðŸš§ Binding deduplication for shared WHERE/LET clauses (WIP)\n\n### Decision Service & APIs âœ…\n\n- âœ… REST API for decision evaluation with OpenAPI/Swagger\n- âœ… @export syntax for declaring API-exposed functions (no separate YAML needed)\n- âœ… Batch evaluation with parallel processing\n- âœ… Module precompilation for 10-100x performance improvement\n- âœ… JSON Schema generation (jl4-schema CLI)\n- âœ… Websessions integration with auto-push to decision service\n\n### In Development ðŸš§\n\n- ðŸš§ Boolean minimization for default logic reasoning\n- ðŸš§ TYPICALLY keyword for rebuttable presumptions\n- ðŸš§ Runtime input state model for partial information handling\n- ðŸš§ State transition logic visualizer (automaton view)\n- ðŸš§ Web App Auto-Generation for Decision Logic\n- ðŸš§ Natural language generation to Word/PDF\n- ðŸš§ Formal verification tooling for finding logical contradictions and loopholes\n\n## The REPL\n\nAn interactive Read-Eval-Print Loop for exploring L4 code in real-time.\n\n```bash\ncabal run jl4-repl -- path/to/file.l4\n```\n\nThe REPL provides:\n\n- Live evaluation of L4 expressions\n- Module loading and reloading (`:load`, `:reload`)\n- Interactive exploration of language features\n- Query planning helpers (`:decides`, `:queryplan` / `:qp`)\n- Trace output (GraphViz DOT via `:trace`, ASCII via `:traceascii`, file output via `:tracefile`)\n\nPerfect for prototyping logic, testing functions, and learning L4 interactively.\n\nSee `jl4-repl/README.md:1` for the current command list and examples.\n\n## The Web Editor\n\nAn experimental prototype offers a lightweight web-based alternative to VS Code.\n\nhttps://jl4.legalese.com/\n\n## VS Code Extension: Download, Install and Build\n\n[Dev Build](Dev.md): for Haskell and JS developers to improve the toolchain and IDE developer experience. Requires Haskell and Typscript.\n\n[Quickstart for a local build](doc/foundation-course-ai/quickstart.md): for legal engineers to experiment with writing L4 code locally. Download the VS Code extension and get started.\n\n## Application Libraries\n\nL4 includes foundational libraries for building legal and commercial applications:\n\nISO 3166 country codes, US states, Canadian provinces, and supranational regions (EU). Use directly in code as string literals (\"US\", \"GB\", \"SG\").\n[Jurisdiction](jl4-core/libraries/jurisdiction.l4)\n\nISO 4217 currency codes (USD, EUR, GBP, JPY, etc.) with integer minor unit storage to avoid floating-point errors.\n[Currency](jl4-core/libraries/currency.l4)\n\nModel individuals, corporations, partnerships, LLCs, and trusts with appropriate legal attributes.\n[Legal Persons](jl4-core/libraries/legal-persons.l4)\n\nOwnership structures and percentage holdings for modeling corporate relationships and beneficial ownership.\n[Holdings](jl4-core/libraries/holdings.l4)\n\nThese libraries follow a principle of simplicity and extensibilityâ€”they provide common patterns while allowing applications to extend them for specific needs.\n\n## Learning L4\n\n### [Foundation Course](doc/foundation-course-ai/)\n\nA complete introduction to L4 for legal professionals and developers. Learn to write legal rules as executable code through hands-on modules:\n\n- **Module 0**: Orientation & File Anatomy\n- **Module 1**: Enums & Records (DECLARE)\n- **Module 2**: Functions (GIVEN/GIVETH/MEANS)\n- **Module 3**: Control Flow (CONSIDER, WHEN, BRANCH)\n- **Module 4**: Lists, MAYBE, and Higher-Order Functions\n- **Module 5**: WPA Eligibility Pipeline (complete example)\n- **Module 6**: Test Data & Evaluation\n\n**Who it's for**: Anyone new to L4, legal professionals learning to code, developers entering legal tech.\n\n### [Advanced Course](doc/advanced-course-ai/)\n\nProduction-grade L4 development for enterprise systems. Covers professional workflows, system architecture, and integration:\n\n- **Module A1**: VSCode Development Workflow\n- **Module A2**: AI-Assisted Rule Ingestion\n- **Module A3**: Temporal Logic [WIP]\n- **Module A4**: Decision Service APIs\n- **Module A5**: Rebuttable Presumptions [ROADMAP]\n- **Module A6**: JSON Integration & External Systems\n- **Module A7**: Regression Testing & Change Control\n- **Module A8**: Multi-File Architecture\n- **Module A9**: OPM/OIA Migration\n- **Module A10**: LLM-Powered Semantic Parser / Chatbot [PLANNED]\n- **Module A11**: Regulative Rules & Contract Logic\n\n**Who it's for**: Developers building production systems, enterprise architects, teams migrating from legacy systems, developers building AI-powered legal interfaces, and developers building contract management or compliance systems.\n\n### Other Tutorials\n\n- [Default Logic](./doc/default-logic.md) and `Optional` types with the `Maybe` monad\n- [Automatically Building User-Facing Apps](doc/apps.md)\n\n## Language Reference & Theory\n\nFor an in-depth exploration of L4's theoretical foundations, design philosophy, and language features, see the [**L4 Language Reference**](doc/README.md).\n\nThis comprehensive guide covers:\n\n- **Boolean logic** and data types for legal reasoning\n- **Default logic** and ternary reasoning (unknown values)\n- **Constitutive rules** as first-order predicate logic (decision functions)\n- **Regulative rules** as labeled state transition systems (contracts, obligations)\n- **Multi-temporal logic** for reasoning about time-dependent rules\n- **Deontics** as property assertions (must, may, shall)\n- **Design principles** and the theory behind L4's syntax\n- Comparison with related languages (Catala, Blawx, Logical English, etc.)\n\nThe reference also links to detailed documents on specific topics including mixfix operators, scope and modifiers, and the semantic foundations of legal computation.\n"
      },
      "plugins": [
        {
          "name": "l4-computational-law",
          "source": {
            "source": "github",
            "repo": "legalese/l4-ide",
            "path": "skill"
          },
          "description": "L4 programming language for computational law - encode contracts, regulations, and policies as executable, testable, verifiable programs",
          "version": "0.1.0",
          "author": {
            "name": "Legalese",
            "email": "hello@legalese.com"
          },
          "homepage": "https://github.com/legalese/l4-ide",
          "repository": "https://github.com/legalese/l4-ide",
          "license": "Apache 2.0",
          "keywords": [
            "legal",
            "law",
            "computational-law",
            "contracts",
            "regulations",
            "formal-methods",
            "verification",
            "functional-programming"
          ],
          "category": "legal-tech",
          "tags": [
            "legal",
            "computational-law",
            "formal-verification",
            "contracts"
          ],
          "categories": [
            "computational-law",
            "contracts",
            "formal-methods",
            "formal-verification",
            "functional-programming",
            "law",
            "legal",
            "legal-tech",
            "regulations",
            "verification"
          ],
          "install_commands": [
            "/plugin marketplace add smucclaw/l4-ide",
            "/plugin install l4-computational-law@legalese"
          ]
        }
      ]
    }
  ]
}