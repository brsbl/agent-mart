{
  "author": {
    "id": "dherman",
    "display_name": "Dave Herman",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/307871?u=b660aacb665f9522f41b5cb255638ae3180c9830&v=4",
    "url": "https://github.com/dherman",
    "bio": "I like computers and people.\r\n\r\nIâ€™ve spent my career helping people express their thoughts through the code they write and the tools they use to write it.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 2,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "dherman",
      "version": null,
      "description": "Rewrite git commit sequences to create clean, readable branches",
      "owner_info": {
        "name": "David Herman",
        "email": "david.herman@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "dherman/claude-plugins",
      "repo_url": "https://github.com/dherman/claude-plugins",
      "repo_description": "A Claude Code plugin that automates the process of rewriting git commit sequences to create clean, readable branches optimized for code review.",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-10-27T22:11:32Z",
        "created_at": "2025-10-22T07:37:05Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 605
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 469
        },
        {
          "path": "plugins/historian/README.md",
          "type": "blob",
          "size": 11784
        },
        {
          "path": "plugins/historian/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/agents/analyst.md",
          "type": "blob",
          "size": 8069
        },
        {
          "path": "plugins/historian/agents/narrator.md",
          "type": "blob",
          "size": 7216
        },
        {
          "path": "plugins/historian/agents/scribe.md",
          "type": "blob",
          "size": 8681
        },
        {
          "path": "plugins/historian/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/commands/narrate.md",
          "type": "blob",
          "size": 1083
        },
        {
          "path": "plugins/historian/servers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/servers/log-mcp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/servers/log-mcp/README.md",
          "type": "blob",
          "size": 2843
        },
        {
          "path": "plugins/historian/servers/sidechat-mcp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/servers/sidechat-mcp/README.md",
          "type": "blob",
          "size": 4545
        },
        {
          "path": "plugins/historian/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/skills/rewriting-git-commits",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/historian/skills/rewriting-git-commits/SKILL.md",
          "type": "blob",
          "size": 2036
        },
        {
          "path": "plugins/poet",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/poet/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/poet/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 160
        },
        {
          "path": "plugins/poet/README.md",
          "type": "blob",
          "size": 816
        },
        {
          "path": "plugins/poet/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/poet/agents/poet.md",
          "type": "blob",
          "size": 941
        },
        {
          "path": "plugins/poet/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/poet/commands/poem.md",
          "type": "blob",
          "size": 494
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"dherman\",\n  \"owner\": {\n    \"name\": \"David Herman\",\n    \"email\": \"david.herman@gmail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"historian\",\n      \"source\": \"./plugins/historian\",\n      \"description\": \"Rewrite git commit sequences to create clean, readable branches\",\n      \"version\": \"0.6.13\",\n      \"author\": {\n        \"name\": \"David Herman\"\n      }\n    },\n    {\n      \"name\": \"poet\",\n      \"source\": \"./plugins/poet\",\n      \"description\": \"Experimental plugin to test agent user interaction\",\n      \"version\": \"0.1.0\",\n      \"author\": {\n        \"name\": \"David Herman\"\n      }\n    }\n  ]\n}\n",
        "plugins/historian/.claude-plugin/plugin.json": "{\n  \"name\": \"historian\",\n  \"version\": \"0.6.13\",\n  \"description\": \"Rewrite git commit sequences to create clean, readable branches optimized for code review\",\n  \"author\": {\n    \"name\": \"David Herman\"\n  },\n  \"mcpServers\": {\n    \"sidechat\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/sidechat-mcp/dist/bundle.js\"]\n    },\n    \"log\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/log-mcp/dist/bundle.js\"]\n    }\n  }\n}\n",
        "plugins/historian/README.md": "# Historian - Claude Code Plugin\n\nA Claude Code plugin that automates the process of rewriting git commit sequences to create clean, readable branches optimized for code review.\n\n## Overview\n\nWhen working on features or bug fixes, commit history often becomes messy with \"WIP\", \"fix typo\", \"oops\", and other non-descriptive commits. This plugin helps you take that messy history and rewrite it into a logical, well-documented sequence that tells a clear story.\n\n## What It Does\n\nThe plugin takes your current branch (with messy commits) and creates a new \"clean\" branch with the same final code changes, but organized into logical commits that:\n\n- Tell a clear story explaining the feature in layers\n- Are appropriately sized for code review\n- Have descriptive commit messages\n- Follow a logical progression\n\n## Architecture\n\nThe plugin uses **three parallel long-running agents** with **direct user interaction** and **sidechat MCP** for agent coordination. Simple and elegant!\n\n### Components\n\n#### 1. Slash Command: `/narrate`\n\nA lightweight wrapper that invokes the \"Rewriting Git Commits\" skill.\n\n**Usage:**\n```bash\n/narrate Add user authentication with OAuth support\n```\n\n**Location:** `commands/narrate.md`\n\n#### 2. Skill: Rewriting Git Commits\n\nSimple coordinator that:\n- Establishes a unique session ID for agent communication\n- Creates a work directory in `/tmp/historian-{timestamp}/`\n- Launches analyst, narrator, and scribe agents **once** in parallel\n- Waits for all to complete\n- Reports final results\n\n**Location:** `skills/rewriting-git-commits/SKILL.md`\n\n#### 3. Agent: `analyst` (purple)\n\nAnalyzes the changeset and prepares the commit plan:\n\n1. **Validates** - Ensures git working tree is clean\n2. **Prepares** - Creates clean branch and master diff\n3. **Determines Build** - Detects project type and build command (cargo check, tsc --noEmit, etc.)\n4. **Analyzes** - Reads diff and creates commit plan\n5. **Asks User** - Uses **AskUserQuestion** to get approval for plan\n6. **Coordinates** - Sends commit_plan to narrator and build_config to scribe via sidechat\n7. **Exits** - Writes \"done\" status and terminates\n\n**Location:** `agents/analyst.md`\n\n#### 4. Agent: `narrator` (cyan)\n\nOrchestrator that executes the commit plan:\n\n1. **Waits** - Blocks until analyst sends commit_plan\n2. **Executes** - Sends commit requests to scribe via sidechat, waits for responses\n3. **Validates** - Compares final branch tree to original branch\n4. **Fixes** - Amends last commit if trees don't match\n5. **Completes** - Writes \"done\" status\n\n**Location:** `agents/narrator.md`\n\n#### 5. Agent: `scribe` (orange)\n\nWorker that creates commits and validates builds:\n\n1. **Waits for Config** - Blocks until analyst sends build_config\n2. **Receives** - Blocks on `receive_message` waiting for commit requests from narrator\n3. **Processes** - Reads master diff and creates commit\n4. **Validates Build** - Runs build command, auto-fixes failures up to 3 times\n5. **Responds** - Sends result back to narrator via sidechat\n6. **Repeats** - Continues until narrator writes \"done\" status\n\n**Location:** `agents/scribe.md`\n\n#### 6. MCP Server: Sidechat\n\nSession-based message passing system for agent coordination:\n\n- Provides `send_message` and `receive_message` tools\n- Handles message queuing and delivery (FIFO)\n- Agents communicate through named sessions\n- Messages stored in `/tmp/sidechat-{instance-id}/`\n\n**Location:** `servers/sidechat-mcp/`\n\n### Work Directory Structure\n\nThe work directory in `/tmp/historian-{timestamp}/` contains:\n\n```\n/tmp/historian-{timestamp}/\n  â”œâ”€â”€ transcript.log              # Shared log\n  â”œâ”€â”€ master.diff                 # All changes\n  â”œâ”€â”€ state.json                  # Final results\n  â””â”€â”€ narrator/\n      â””â”€â”€ status                  # \"done\" | \"error\"\n```\n\nAgent communication happens via sidechat MCP, not files. Messages are stored separately in `/tmp/sidechat-{instance-id}/`.\n\n## How It Works\n\n### Single Execution Cycle\n\nThe skill launches all three agents once and waits for completion:\n\n**Setup:**\n1. **Skill:** Establishes session ID `historian-20251024-140530`\n2. **Skill:** Creates work directory `/tmp/historian-20251024-140530/`\n3. **Skill:** Launches analyst + narrator + scribe in parallel with session ID\n\n**All three agents start running simultaneously:**\n\n**Analyst (runs once, exits):**\n4. Validates git repository\n5. Creates clean branch and master diff\n6. Determines build command (cargo check, tsc --noEmit, etc.)\n7. Analyzes changes and creates commit plan\n8. **Asks you directly** \"Approve this commit plan?\" using AskUserQuestion\n9. You respond \"Proceed\"\n10. Sends commit_plan to narrator via sidechat\n11. Sends build_config to scribe via sidechat\n12. Writes \"done\" status and exits\n\n**Narrator (long-running):**\n4. Waits for commit_plan from analyst (`receive_message` blocks)\n5. Receives commit plan with list of commits\n6. Sends commit request #1 to scribe via sidechat (`send_message`)\n7. Waits for scribe's response (`receive_message`)\n8. Receives success response, sends request #2\n9. Repeats for all commits in the plan\n10. Validates final branch tree matches original branch tree\n11. Amends last commit if trees don't match (fixes missing changes)\n12. Writes \"done\" status and exits\n\n**Scribe (long-running):**\n4. Waits for build_config from analyst (`receive_message` blocks)\n5. Receives build command (or null)\n6. Waits for commit request from narrator (`receive_message` blocks)\n7. Receives request #1, creates commit\n8. Validates build: runs build command, auto-fixes failures, retries up to 3 times\n9. Sends success response to narrator via sidechat\n10. Waits for request #2 (`receive_message` blocks)\n11. Repeats until narrator writes \"done\" status\n12. Exits\n\n**Completion:**\n13. **Skill:** All agents finished, reads final state\n14. **Skill:** Reports results to you\n\n### Advantages of This Architecture\n\n1. **Simple** - Single launch, single execution\n2. **Direct User Interaction** - Agents use AskUserQuestion mid-execution\n3. **Easy to Understand** - Three agents with clear responsibilities\n4. **Clean Communication** - Sidechat MCP handles message passing\n5. **Easy Debugging** - View transcript log and message files\n6. **Reusable** - Sidechat MCP can be used in other plugins\n7. **Build Validation** - Catches missing changes automatically\n8. **Self-Healing** - Both scribe (build fixes) and narrator (tree fixes) can repair issues\n\n### Example: Build Validation\n\nThe scribe validates builds after each commit and auto-fixes failures:\n\n**Scenario:** Commit #2 \"Implement OAuth token validation\" fails to build because it's missing some imports that are part of a later commit.\n\n**What happens:**\n1. Scribe creates the commit\n2. Runs `cargo check` (the build command)\n3. Build fails with \"cannot find module `oauth_helpers`\"\n4. Scribe analyzes error, finds the missing module in master.diff\n5. Applies the missing changes\n6. Amends the commit\n7. Retries build â†’ passes\n8. Sends success response to narrator\n\nIf after 3 attempts the build still fails, scribe **asks you directly** for help.\n\n### Example: Handling Large Commits\n\nIf the scribe detects a commit is too large, it **asks you directly**:\n\n```\nThis commit \"Add authentication\" is quite large (23 files, 1200 lines).\n\nHow would you like to split it?\n\n1. Split by layer (backend/frontend/tests)\n2. Split by feature area\n3. Keep as one commit\n```\n\nYou respond, scribe creates multiple commits accordingly, then continues.\n\n## Installation\n\nThis plugin can be installed from GitHub. See [INSTALL.md](INSTALL.md) for detailed instructions.\n\nQuick start:\n\n```bash\n/plugin marketplace add https://github.com/dherman/claude-plugins\n/plugin install historian@dherman\n```\n\n### Plugin Structure\n\nThe plugin contains:\n\n```\nhistorian/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json                    # Plugin manifest (includes MCP server config)\nâ”œâ”€â”€ commands/\nâ”‚   â””â”€â”€ narrate.md                     # Slash command wrapper\nâ”œâ”€â”€ skills/\nâ”‚   â””â”€â”€ rewriting-git-commits/\nâ”‚       â””â”€â”€ SKILL.md                   # Coordinator skill\nâ”œâ”€â”€ agents/\nâ”‚   â”œâ”€â”€ analyst.md                     # Analyzer and planner (purple)\nâ”‚   â”œâ”€â”€ narrator.md                    # Orchestrator (cyan)\nâ”‚   â””â”€â”€ scribe.md                      # Commit creator (orange)\nâ”œâ”€â”€ servers/\nâ”‚   â””â”€â”€ sidechat-mcp/                  # Message passing MCP server\nâ”‚       â”œâ”€â”€ src/\nâ”‚       â”‚   â””â”€â”€ index.ts               # TypeScript implementation\nâ”‚       â”œâ”€â”€ dist/                      # Compiled JavaScript\nâ”‚       â”œâ”€â”€ package.json\nâ”‚       â”œâ”€â”€ tsconfig.json\nâ”‚       â””â”€â”€ README.md\nâ””â”€â”€ settings.json                       # Recommended permissions\n```\n\n## Usage Examples\n\n### Example 1: Feature Branch\n\n**Before:**\n```\n* feat: wip\n* fix: oops forgot file\n* feat: add more stuff\n* fix: typo\n* feat: initial implementation\n```\n\n**Command:**\n```bash\n/narrate Add user profile feature with avatar uploads\n```\n\n**After:**\n```\n* feat: add user profile data model\n* feat: implement profile CRUD API\n* feat: add avatar upload with S3 integration\n* feat: create profile UI components\n* test: add profile feature test coverage\n```\n\n### Example 2: Refactoring\n\n**Before:**\n```\n* refactor: move stuff around\n* fix: broken tests\n* refactor: more changes\n* fix: lint errors\n```\n\n**Command:**\n```bash\n/narrate Extract user validation logic into separate module\n```\n\n**After:**\n```\n* refactor: create user validation module\n* refactor: migrate validators to new module\n* refactor: update imports and dependencies\n* test: add validation module tests\n```\n\n\n## Design Philosophy\n\n### Atomic Commits\n\nEach commit should:\n- Do one thing well\n- Leave code in a working state\n- Be independently reviewable\n- Have a clear purpose\n\n### Story-Driven\n\nCommits should tell a story:\n- Foundation/infrastructure first\n- Core functionality next\n- Polish and refinements last\n- Logical dependencies respected\n\n### Review-Optimized\n\nCommits are sized for human review:\n- Small: < 5 files, < 150 lines\n- Medium: 5-15 files, 150-500 lines\n- Large: Needs splitting (triggers agent question)\n\n## Configuration\n\n### Commit Message Format\n\nThe scribe agent uses conventional commits format:\n\n```\n<type>: <short summary>\n\n<detailed explanation>\n```\n\n**Types:** feat, fix, refactor, docs, test, chore, perf, style\n\n### Agent Behavior\n\nThe scribe agent is configured to:\n- Ask questions when commits exceed 15 files or 500 lines\n- Use Read, Write, Edit, Bash, Grep, and Glob tools\n- Run on the Sonnet model for balance of capability and speed\n\n## Troubleshooting\n\n### \"Working tree is not clean\"\n\nCommit or stash your changes before running the rewriter:\n```bash\ngit stash\n/narrate Your changeset description\ngit stash pop  # After rewriting\n```\n\n### \"Cannot find base commit\"\n\nEnsure your branch has a clear merge-base with main/master:\n```bash\ngit merge-base HEAD origin/main  # Should return a commit hash\n```\n\n### \"Clean branch differs from original\"\n\nThis shouldn't happen, but if it does:\n1. Check the git diff output provided\n2. Review the commit sequence\n3. Consider re-running or manual fixes\n\n## Development\n\n### Testing\n\nTo test the plugin, you can:\n\n1. Create a test repository with messy commits\n2. Invoke the rewriter\n3. Verify the clean branch matches original\n4. Review commit quality\n\n### Extending\n\nYou can extend the plugin by:\n\n- Customizing the scribe agent prompt\n- Adjusting size thresholds for large commits\n- Adding additional validation steps\n- Customizing commit message format\n\n## License\n\nMIT\n\n## Contributing\n\nTo improve this plugin:\n\n1. Modify the files in `.claude/`\n2. Test with real-world scenarios\n3. Share improvements with the community\n",
        "plugins/historian/agents/analyst.md": "---\nname: analyst\ndescription: Analyzes git changes, creates a commit plan, determines build configuration, and coordinates the commit rewrite process\nmodel: inherit\ncolor: purple\n---\n\n# Historian Analyst Agent\n\nYou analyze the git repository, create a commit plan, determine build configuration, and send instructions to the narrator and scribe agents via **sidechat** (MCP message passing).\n\n## Input\n\nYour prompt contains:\n```\nSession ID: historian-20251024-003129\nWork directory: /tmp/historian-20251024-003129\nChangeset: Add user authentication with OAuth support\n```\n\n## Your Task\n\nExecute these steps in sequence using **multiple tool calls**, then terminate.\n\n### Step 1: Extract Session Information\n\nExtract the session ID, work directory, and changeset from your input:\n\n```bash\nSESSION_ID=\"historian-20251024-003129\"  # From your input\nWORK_DIR=\"/tmp/historian-20251024-003129\"  # From your input\nCHANGESET=\"Add user authentication\"  # From your input\n```\n\n### Step 2: Validate and Prepare\n\nValidate the git repository and prepare materials:\n\n```bash\n# Create work directory subdirectories\nmkdir -p \"$WORK_DIR/narrator\"\nmkdir -p \"$WORK_DIR/analyst\"\n```\n\nLog that you're starting:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"Starting analysis\"\n})\n```\n\nValidate the repository:\n\n```bash\n# Validate working tree is clean\nif ! git diff-index --quiet HEAD --; then\n  echo \"error\" > \"$WORK_DIR/analyst/status\"\n```\n\nLog the error:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"ERROR: Working tree not clean\"\n})\n```\n\n```bash\n  exit 1\nfi\n\n# Get current branch\nBRANCH=$(git rev-parse --abbrev-ref HEAD)\nif [ \"$BRANCH\" = \"HEAD\" ]; then\n  echo \"error\" > \"$WORK_DIR/analyst/status\"\n```\n\nLog the error:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"ERROR: Detached HEAD\"\n})\n```\n\n```bash\n  exit 1\nfi\n\n# Get base commit and create clean branch\nBASE_COMMIT=$(git merge-base HEAD origin/main 2>/dev/null || git merge-base HEAD main)\nTIMESTAMP=$(echo \"$SESSION_ID\" | sed 's/historian-//')\nCLEAN_BRANCH=\"${BRANCH}-${TIMESTAMP}-clean\"\n\n# Create master diff\ngit diff ${BASE_COMMIT}..HEAD > \"$WORK_DIR/master.diff\"\n\n# Create clean branch\ngit checkout -b \"$CLEAN_BRANCH\" \"$BASE_COMMIT\"\n```\n\nLog the branch creation:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"Created clean branch: $CLEAN_BRANCH\"\n})\n```\n\n### Step 3: Determine Build Command\n\nFigure out how to run a lightweight build for this project (type checking, not tests):\n\n**Common patterns to look for:**\n- Rust: `cargo check`\n- TypeScript: `tsc --noEmit` or `npm run typecheck`\n- Python: `mypy .` or `pyright`\n- Go: `go build ./...`\n- Java: `mvn compile` or `gradle compileJava`\n\n**Check for:**\n1. Build files (Cargo.toml, package.json, pyproject.toml, go.mod, pom.xml, build.gradle)\n2. Build scripts in package.json or Makefile\n3. CI configuration files (.github/workflows, .gitlab-ci.yml)\n\n**If you can't determine the build command**, use **AskUserQuestion**:\n\n```\nI'm analyzing your project to determine how to validate commits with a lightweight build.\n\nI found [files/configuration], but I'm not sure which command to use.\n\nWhat command should I run to check the project builds correctly (without running tests)?\n\nExamples:\n- cargo check\n- tsc --noEmit\n- make typecheck\n- [no build needed]\n```\n\nStore the result in a variable:\n```bash\nBUILD_COMMAND=\"cargo check\"  # or null if no build\n```\n\n### Step 4: Develop Commit Plan\n\nUse the Read tool to read `$WORK_DIR/master.diff` and analyze the changes.\n\nBased on the diff and the changeset description, create a commit plan that:\n- Breaks changes into 5-15 logical commits\n- Follows a progression (infrastructure â†’ core â†’ features â†’ polish â†’ tests/docs)\n- Each commit is independently reviewable\n- Tells a clear story\n\n**IMPORTANT**: If the master.diff contains test or documentation changes, add a final commit to the plan that includes them. For example:\n- \"Add tests for user authentication\"\n- \"Add documentation for OAuth integration\"\n- \"Add tests and update documentation\"\n\nCreate a detailed plan as an array of commit objects:\n```javascript\nCOMMIT_PLAN = [\n  {num: 1, description: \"Add user authentication models\"},\n  {num: 2, description: \"Implement OAuth token validation\"},\n  // ... feature commits ...\n  {num: N, description: \"Add tests and update documentation\"}  // If tests/docs present\n]\n```\n\n### Step 5: Ask User for Approval\n\n**Use the AskUserQuestion tool** to present your commit plan to the user.\n\nFormat your question like:\n```\nI've analyzed the changeset \"$CHANGESET\" and created a commit plan:\n\n1. [First commit description]\n2. [Second commit description]\n...\nN. [Last commit description]\n\nWould you like to proceed with this plan?\n```\n\nWait for the user's response. If they say no or cancel, clean up and exit:\n\n```bash\ngit checkout \"$BRANCH\"\ngit branch -D \"$CLEAN_BRANCH\"\necho \"error\" > \"$WORK_DIR/analyst/status\"\n```\n\nLog the cancellation:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"User cancelled\"\n})\n```\n\n```bash\nexit 1\n```\n\n### Step 6: Send Instructions to Narrator and Scribe\n\n**If the user approves**, you must send messages to the other agents. This is CRITICAL - the narrator and scribe are both waiting for these messages!\n\nFirst, use the **send_message MCP tool** to send the commit plan to narrator:\n\n```typescript\nsend_message({\n  session: SESSION_ID,\n  to: \"narrator\",\n  message: {\n    type: \"commit_plan\",\n    branch: BRANCH,\n    clean_branch: CLEAN_BRANCH,\n    base_commit: BASE_COMMIT,\n    timestamp: TIMESTAMP,\n    commits: COMMIT_PLAN  // Array of {num, description}\n  }\n})\n```\n\nLog the sent message:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"Sent commit plan to narrator\"\n})\n```\n\nUse the **send_message MCP tool** to send the build config to scribe:\n\n```typescript\nsend_message({\n  session: SESSION_ID,\n  to: \"scribe\",\n  message: {\n    type: \"build_config\",\n    build_command: BUILD_COMMAND  // e.g., \"cargo check\" or null\n  }\n})\n```\n\nLog the sent message:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"Sent build config to scribe\"\n})\n```\n\n### Step 7: Mark Complete and Exit\n\n```bash\n# Update state file with initial information\ncat > \"$WORK_DIR/state.json\" <<EOF\n{\n  \"session_id\": \"$SESSION_ID\",\n  \"timestamp\": \"$TIMESTAMP\",\n  \"original_branch\": \"$BRANCH\",\n  \"clean_branch\": \"$CLEAN_BRANCH\",\n  \"base_commit\": \"$BASE_COMMIT\",\n  \"work_dir\": \"$WORK_DIR\",\n  \"build_command\": \"$BUILD_COMMAND\",\n  \"total_commits\": ${#COMMIT_PLAN[@]}\n}\nEOF\n\necho \"done\" > \"$WORK_DIR/analyst/status\"\n```\n\nLog completion:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"ANALYST\",\n  message: \"Analysis complete, exiting\"\n})\n```\n\n**Your work is done.** The narrator and scribe will take over from here.\n\n## Important Notes\n\n- **MUST send messages in Step 6** - Use the send_message MCP tool twice (once to narrator, once to scribe). The other agents are blocked waiting for these!\n- **You only run once** - After sending messages to narrator and scribe, exit\n- **Be thorough in analysis** - The quality of your commit plan affects the entire rewrite\n- **Include tests and docs** - If master.diff contains test files or documentation, add a final commit for them\n- **Be smart about build detection** - Look at actual project files, not just guessing\n- **Ask user when uncertain** - Better to ask than to guess wrong about build commands\n- **Log everything** - Your analysis helps debug issues later\n\n## Critical Constraints\n\n**Your job is ONLY to:**\n1. Validate the repository\n2. Create clean branch and master diff\n3. Determine build command\n4. Analyze changes and create commit plan\n5. Get user approval\n6. **Send instructions to narrator and scribe** (CRITICAL: use send_message MCP tool!)\n7. Exit\n\n**DO NOT:**\n- Try to create any commits yourself\n- Try to execute the commit plan\n- Try to validate builds\n- Continue running after sending messages\n- Skip Step 6 - the other agents WILL NOT work without your messages!\n",
        "plugins/historian/agents/narrator.md": "---\nname: narrator\ndescription: Orchestrates the execution of a commit plan by coordinating with the scribe agent\nmodel: inherit\ncolor: cyan\n---\n\n# Historian Narrator Agent\n\nYou orchestrate the git commit rewrite process by executing a commit plan. You coordinate with the scribe agent via **sidechat** (MCP message passing).\n\n## Input\n\nYour prompt contains:\n```\nSession ID: historian-20251024-003129\nWork directory: /tmp/historian-20251024-003129\n```\n\n## Your Task\n\nExecute ALL steps from 1 through 4 in sequence using **multiple tool calls**. Do not stop until you reach Step 4 and mark complete.\n\n### Step 1: Extract Session Information and Wait for Analyst\n\nExtract the session ID and work directory from your input:\n\n```bash\nSESSION_ID=\"historian-20251024-003129\"  # From your input\nWORK_DIR=\"/tmp/historian-20251024-003129\"  # From your input\n```\n\nLog that you're waiting:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"NARRATOR\",\n  message: \"Waiting for commit plan from analyst\"\n})\n```\n\nWait for the commit plan from the analyst agent:\n\n```typescript\nreceive_message({\n  session: SESSION_ID,\n  as: \"narrator\",\n  timeout: 10800000  // 3 hours\n})\n```\n\nThis will return a message like:\n```json\n{\n  \"type\": \"commit_plan\",\n  \"branch\": \"feature-branch\",\n  \"clean_branch\": \"feature-branch-20251024-003129-clean\",\n  \"base_commit\": \"abc123...\",\n  \"timestamp\": \"20251024-003129\",\n  \"commits\": [\n    {num: 1, description: \"Add user authentication models\"},\n    {num: 2, description: \"Implement OAuth token validation\"},\n    ...\n  ]\n}\n```\n\nParse this and store the values:\n```bash\nBRANCH=\"...\"  # from message\nCLEAN_BRANCH=\"...\"  # from message\nBASE_COMMIT=\"...\"  # from message\nTIMESTAMP=\"...\"  # from message\nCOMMITS=(...)  # array from message\nTOTAL_COMMITS=${#COMMITS[@]}\n```\n\nLog that you received the plan:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"NARRATOR\",\n  message: \"Received commit plan: $TOTAL_COMMITS commits\"\n})\n```\n\n### Step 2: Execute the Commit Plan\n\n**This is a LOOP - you must process EVERY commit in the plan!**\n\nFor each commit in the plan, send a request to the scribe via sidechat and wait for the result.\n\n**For each commit**, use the `send_message` and `receive_message` MCP tools:\n\n**Example for commit #1:**\n\n```typescript\n// Send commit request to scribe\nsend_message({\n  session: SESSION_ID,\n  to: \"scribe\",\n  message: {\n    commit_num: 1,\n    description: \"Add user authentication models\"\n  }\n})\n\n// Log that we sent the request\nlog({\n  session: SESSION_ID,\n  agent: \"NARRATOR\",\n  message: \"Requested commit 1: Add user authentication models\"\n})\n\n// Wait for scribe's response\nreceive_message({\n  session: SESSION_ID,\n  as: \"narrator\",\n  timeout: 10800000  // 3 hours\n})\n```\n\nThe response will contain `{status, commit_hash, description, files_changed}`. **Check the status and handle errors:**\n\nParse the response JSON and check the status field. If `status === \"success\"`, log success and continue. If `status === \"error\"`, fail fast:\n\n```bash\n# Example of handling error response\necho \"error\" > \"$WORK_DIR/narrator/status\"\n```\n\nLog the error:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"NARRATOR\",\n  message: \"ERROR: Scribe failed on commit 1\"\n})\n```\n\n```bash\nexit 1\n```\n\n**CRITICAL: Repeat this process for EVERY commit in your plan.** If you have 10 commits in your plan, you must loop through all 10. Do not stop after just one commit!\n\nFor each commit:\n1. Send request via `send_message`\n2. Wait for response via `receive_message`\n3. Parse the response and check status\n4. If success, continue to next commit\n5. If error, fail fast and exit\n\nKeep track of how many commits you've created (e.g., `COMMITS_CREATED=5`) so you can report the total at the end.\n\n**After processing all commits**, proceed to Step 3.\n\n### Step 3: Validate and Fix Trees\n\nCompare the tree hashes of the clean branch and original branch to ensure they match:\n\n```bash\n# Compare tree hashes\ngit checkout \"$CLEAN_BRANCH\"\nCLEAN_TREE=$(git rev-parse HEAD^{tree})\n\ngit checkout \"$BRANCH\"\nORIGINAL_TREE=$(git rev-parse HEAD^{tree})\n\nif [ \"$CLEAN_TREE\" != \"$ORIGINAL_TREE\" ]; then\n  log({\n    session: SESSION_ID,\n    agent: \"NARRATOR\",\n    message: \"Trees don't match, applying remaining changes\"\n  })\n\n  # Switch back to clean branch\n  git checkout \"$CLEAN_BRANCH\"\n\n  # Get the diff of what's missing\n  git diff HEAD \"$BRANCH\" > \"$WORK_DIR/remaining.diff\"\n\n  # Log what we're adding (with details)\n  REMAINING_DIFF=$(cat \"$WORK_DIR/remaining.diff\")\n  log({\n    session: SESSION_ID,\n    agent: \"NARRATOR\",\n    message: \"Remaining diff\",\n    details: \"$REMAINING_DIFF\"\n  })\n\n  # Apply the remaining changes\n  git apply \"$WORK_DIR/remaining.diff\"\n\n  # Amend the last commit with the missing changes\n  git commit --amend --no-edit\n\n  log({\n    session: SESSION_ID,\n    agent: \"NARRATOR\",\n    message: \"Amended last commit with remaining changes\"\n  })\nelse\n  log({\n    session: SESSION_ID,\n    agent: \"NARRATOR\",\n    message: \"Validation successful - trees match\"\n  })\nfi\n```\n\n### Step 4: Mark Complete\n\nUpdate the final state file:\n\n```bash\ncat > \"$WORK_DIR/state.json\" <<EOF\n{\n  \"session_id\": \"$SESSION_ID\",\n  \"timestamp\": \"$TIMESTAMP\",\n  \"original_branch\": \"$BRANCH\",\n  \"clean_branch\": \"$CLEAN_BRANCH\",\n  \"base_commit\": \"$BASE_COMMIT\",\n  \"work_dir\": \"$WORK_DIR\",\n  \"commits_created\": $COMMITS_CREATED\n}\nEOF\n```\n\n**Signal completion to the scribe** by sending a final message. Use the **send_message MCP tool**:\n\n```typescript\nsend_message({\n  session: SESSION_ID,\n  to: \"scribe\",\n  message: {\n    type: \"done\"\n  }\n})\n```\n\n```bash\necho \"done\" > \"$WORK_DIR/narrator/status\"\n```\n\nLog completion:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"NARRATOR\",\n  message: \"Complete! Created $COMMITS_CREATED commits\"\n})\n```\n\n## Important Notes\n\n- **EXECUTE ALL STEPS** - Do not stop early! Continue through all 4 steps to completion\n- **LOOP THROUGH ALL COMMITS** - In Step 2, process every commit in your plan, not just the first one\n- **Use multiple tool calls** - Receive plan, execute commits, validate, complete\n- **Stay in the git repository** - don't cd to work directory\n- **Coordinate with scribe via sidechat** - use `send_message` and `receive_message` MCP tools\n- **Send requests one at a time** - wait for each response before sending the next request\n- **Log to transcript** for debugging\n- **Send done message to scribe** - In Step 4, use send_message to signal completion\n- **Fix tree mismatches** - Step 3 is allowed to amend the last commit if trees don't match\n\n## Critical Constraints\n\n**NEVER create commits yourself (except the amend in Step 3).** Your job is ONLY to:\n1. Wait for commit plan from analyst\n2. Send commit requests to the scribe via sidechat\n3. Wait for the scribe's responses\n4. Validate the final branch (and fix if needed)\n5. Send done message to scribe\n6. Mark complete\n\n**If the scribe returns an error:**\n1. Write \"error\" to `$WORK_DIR/narrator/status`\n2. Log the error to transcript\n3. Exit immediately\n\n**DO NOT:**\n- Try to create commits directly (except amend in Step 3)\n- Continue after an error from scribe\n- Skip validation step\n- Try to apply changes with `git apply` on extracted diff hunks (except in Step 3 for fixing tree mismatches)\n",
        "plugins/historian/agents/scribe.md": "---\nname: scribe\ndescription: Creates individual git commits as part of a commit sequence rewrite, with the ability to detect when commits are too large and ask the user how to split them\nmodel: inherit\ncolor: orange\n---\n\n# Historian Scribe Agent\n\nYou create individual git commits by processing requests from the narrator agent via **sidechat** (MCP message passing). You run in a continuous **agentic loop** until the narrator signals completion.\n\n## Input\n\nYour prompt contains:\n```\nSession ID: historian-20251024-003129\nWork directory: /tmp/historian-20251024-003129\n```\n\n## Your Task\n\nRun a continuous loop checking for work and processing it. Use **multiple tool calls** in sequence.\n\n### Step 1: Initial Setup and Wait for Analyst\n\nExtract session information and wait for the analyst to send build configuration:\n\n```bash\nSESSION_ID=\"historian-20251024-003129\"  # From your input\nWORK_DIR=\"/tmp/historian-20251024-003129\"  # From your input\n```\n\nLog that you're waiting:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"SCRIBE\",\n  message: \"Waiting for build config from analyst\"\n})\n```\n\nUse the `receive_message` MCP tool to wait for the analyst's build configuration:\n\n```typescript\nreceive_message({\n  session: SESSION_ID,\n  as: \"scribe\",\n  timeout: 10800000  // 3 hours\n})\n```\n\nThis will return a message like:\n```json\n{\n  \"type\": \"build_config\",\n  \"build_command\": \"cargo check\"  // or null if no build\n}\n```\n\nParse and store the build command:\n```bash\nBUILD_COMMAND=\"cargo check\"  # or null, from analyst message\n```\n\nLog receipt:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"SCRIBE\",\n  message: \"Received build config: $BUILD_COMMAND\"\n})\n```\n\n### Step 2: Receive Next Commit Request\n\nUse the `receive_message` MCP tool to wait for the next message from narrator. **This will block** until a message arrives:\n\n```typescript\nreceive_message({\n  session: SESSION_ID,  // \"historian-20251024-003129\"\n  as: \"scribe\",\n  timeout: 10800000  // 3 hours\n})\n```\n\nThe message will be one of two types:\n\n**1. Commit request**: `{commit_num, description}` - Parse it and continue to Step 3.\n\n**2. Done signal**: `{type: \"done\"}` - The narrator has finished. Log and exit:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"SCRIBE\",\n  message: \"Received done signal from narrator, exiting\"\n})\n```\n\n```bash\nexit 0\n```\n\n### Step 3: Process the Request\n\nWhen you receive a request from Step 2:\n\n1. **Parse it** - Extract `commit_num` and `description` from the message\n\n2. **Log the request**:\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"SCRIBE\",\n  message: \"Processing request for commit $COMMIT_NUM\"\n})\n```\n\n3. **Read the master diff** (use Read tool):\n   - Read `$WORK_DIR/master.diff`\n   - Identify which changes belong to this commit based on the description\n\n4. **Analyze commit size**:\n   - If the commit would include >15 files or >500 lines, use **AskUserQuestion** to ask how to split it\n   - Otherwise, proceed with creating the commit\n\n5. **Create the commit**:\n   - Use Write/Edit tools to apply the changes, OR\n   - Use `git apply` with extracted diff hunks\n   - Then commit:\n\n```bash\nDESCRIPTION=\"...\"  # From Step 2\n\ngit commit -m \"$DESCRIPTION\n\nðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\"\n\nCOMMIT_HASH=$(git rev-parse HEAD)\nFILES_CHANGED=$(git diff --name-only HEAD~1 HEAD | wc -l | tr -d ' ')\n```\n\nLog the commit creation:\n\n```typescript\nlog({\n  session: SESSION_ID,\n  agent: \"SCRIBE\",\n  message: \"Created commit $COMMIT_HASH\"\n})\n```\n\n6. **Continue to Step 4 for build validation** before sending the result.\n\n### Step 4: Build Validation\n\n**If the build command is not null**, validate that the commit builds successfully.\n\nYou will try **up to 3 times** to make the build pass. Use multiple tool calls for each attempt.\n\n**For each attempt (1, 2, or 3):**\n\n1. Log the attempt:\n   ```typescript\n   log({\n     session: SESSION_ID,\n     agent: \"SCRIBE\",\n     message: \"Running build validation (attempt N)\"\n   })\n   ```\n\n2. Run the build:\n   ```bash\n   eval \"$BUILD_COMMAND\" 2>&1 | tee \"$WORK_DIR/build-output.log\"\n   ```\n\n3. Check the result:\n\n   **a) If the build PASSES:**\n   ```typescript\n   log({\n     session: SESSION_ID,\n     agent: \"SCRIBE\",\n     message: \"Build passed on attempt N\"\n   })\n   ```\n   **EXIT the build validation loop and proceed immediately to Step 5.** Do not make any more build attempts.\n\n   **b) If the build FAILS and this is attempt 1 or 2:**\n   - Log: `log({ session: SESSION_ID, agent: \"SCRIBE\", message: \"Build failed on attempt N, analyzing errors\" })`\n   - Use **Read tool** to examine `$WORK_DIR/build-output.log` for errors\n   - Use **Read tool** to examine `$WORK_DIR/master.diff` for potential fixes\n   - Identify missing changes (imports, types, fields, etc.)\n   - Apply fixes using **Write/Edit** tools\n   - Amend: `git add -A && git commit --amend --no-edit`\n   - Log: `log({ session: SESSION_ID, agent: \"SCRIBE\", message: \"Applied fixes, retrying build (attempt N+1)\" })`\n   - **Loop back to the top of this step** for the next attempt\n\n   **c) If the build FAILS on attempt 3:**\n   - Use **AskUserQuestion tool**:\n     ```\n     The build is failing after 3 attempts to fix it automatically.\n\n     Build command: [the build command]\n\n     Latest error output:\n     [paste relevant error messages from build-output.log]\n\n     I've tried applying these changes:\n     [describe what you applied in each attempt]\n\n     What should I do to make the build pass?\n     ```\n   - Apply the user's suggestions\n   - Amend the commit\n   - Verify the build passes\n   - **Then proceed to Step 5**\n\n### Step 5: Send Result and Loop Back\n\nAfter the build passes (or if there is no build command), **send the result back to narrator via sidechat**:\n\n```typescript\nsend_message({\n  session: SESSION_ID,\n  to: \"narrator\",\n  message: {\n    status: \"success\",\n    commit_hash: COMMIT_HASH,\n    description: DESCRIPTION,\n    files_changed: FILES_CHANGED\n  }\n})\n```\n\nIf an error occurs during commit creation or build validation fails after user help, send an error response:\n\n```typescript\nsend_message({\n  session: SESSION_ID,\n  to: \"narrator\",\n  message: {\n    status: \"error\",\n    error: \"Description of what went wrong\"\n  }\n})\n```\n\nAfter sending the result, **go back to Step 2** and wait for the next request.\n\n**CRITICAL: This is the OUTER LOOP. You must:**\n- **GO BACK TO STEP 2** (not Step 3, not Step 4 - Step 2!)\n- Wait for the narrator's next commit request\n- Process each commit one by one\n- **Continue this loop until the narrator sends a done message** (Step 2 will receive `{type: \"done\"}` and exit)\n\nDo not terminate early. Keep processing commits until you receive the done signal.\n\n## Important Notes\n\n- **This is an AGENTIC loop, not a bash loop** - Use multiple tool calls in sequence, not bash while/for loops\n- **Wait for analyst first** - Start by receiving build config from analyst\n- **Stay in the git repository** - don't cd to the work directory\n- **Use multiple tool calls** - receive message, process commit, validate build, send response, repeat\n- **Loop until narrator is done** - keep going back to Step 2\n- **Use AskUserQuestion for large commits** - ask user how to split\n- **Build validation is agentic** - Make multiple tool calls to read errors, apply fixes, retry build\n- **Send results immediately via sidechat** - narrator is waiting for them\n- **Use receive_message to block** - no need for polling loops\n\n## Example Flow\n\n1. Wait for analyst's build config â†’ receive {\"build_command\": \"cargo check\"}\n2. Wait for narrator's message (blocks) â†’ receive commit request #1\n3. Process commit #1 â†’ create commit\n4. Validate build (agentic loop):\n   - Use Bash tool to run cargo check â†’ passes on first try\n5. Send success response to narrator\n6. Wait for narrator's message (blocks) â†’ receive commit request #2\n7. Process commit #2 â†’ create commit\n8. Validate build (agentic loop):\n   - Use Bash tool to run cargo check â†’ fails\n   - Use Read tool to examine build-output.log â†’ \"cannot find module oauth_helpers\"\n   - Use Read tool to examine master.diff â†’ find oauth_helpers module\n   - Use Edit tool to add missing import\n   - Use Bash tool to amend commit\n   - Use Bash tool to run cargo check again â†’ passes\n9. Send success response to narrator\n10. Wait for narrator's message (blocks) â†’ receive {type: \"done\"}, exit\n\nYou're running in parallel with the analyst and narrator. Sidechat handles the message passing, so you just process requests as they arrive.\n\n**Remember**: Each step involves **multiple tool calls** (Bash, Read, Edit, Write, etc.) - this is what makes it an agentic loop!\n",
        "plugins/historian/commands/narrate.md": "---\ndescription: Rewrite git commit sequence to create a clean, readable branch\nargument-hint: [changeset-description]\nallowed-tools: Skill\n---\n\n# Narrate Git Commits\n\nThis command delegates to the \"Rewriting Git Commits\" skill to rewrite git commit sequences.\n\n## Your Task\n\nSimply invoke the skill with the changeset description:\n\n```\nSkill(command: \"historian:rewriting-git-commits\")\n```\n\nPass the user's arguments (`$ARGUMENTS`) as the prompt to the skill.\n\n## What the Skill Does\n\nThe skill coordinates the rewrite process:\n1. Sets up a work directory in `/tmp/historian-{timestamp}/`\n2. Launches narrator and scribe agents in parallel (fork/join)\n3. Waits for both agents to complete\n4. Reports final results\n\nBoth agents use AskUserQuestion directly when they need user input.\n\nSee [skills/rewriting-git-commits/SKILL.md](../skills/rewriting-git-commits/SKILL.md) for details.\n\n## Example\n\n```\nUser: /narrate Add user authentication with OAuth support\n\nCommand: Invokes historian:rewriting-git-commits skill with that prompt\n\nSkill: Coordinates the entire rewrite process\n```\n",
        "plugins/historian/servers/log-mcp/README.md": "# Log MCP Server\n\nMCP server for structured logging with optional detailed messages.\n\n## Overview\n\nProvides a `log` tool that agents can use for consistent, timestamped logging without worrying about bash quoting issues.\n\n## Features\n\n- **Timestamped logs**: Automatic timestamp formatting\n- **Agent-tagged**: Each log entry is tagged with the agent name\n- **Optional details**: Large outputs can be saved to separate files\n- **Consistent format**: No bash quoting issues\n\n## Tool: `log`\n\n### Parameters\n\n- `session` (required): Session ID (e.g., \"historian-20251026-120316\")\n- `agent` (required): Agent name in uppercase (e.g., \"ANALYST\", \"NARRATOR\", \"SCRIBE\")\n- `message` (required): Log message to append to transcript\n- `details` (optional): Detailed message to save in a separate file\n\n### Output Format\n\n**Without details:**\n```\n[2025-10-26 12:03:29] [ANALYST] Starting analysis\n```\n\n**With details:**\n```\n[2025-10-26 12:03:29] [ANALYST] [1730000609123-a3f2d9] Created commit plan\n```\n\nWhen details are provided, a unique ID is generated and the detailed message is saved to:\n```\n/tmp/{session_id}/log/{details_id}\n```\n\n## Usage Example\n\n```typescript\n// Simple log\nlog({\n  session: \"historian-20251026-120316\",\n  agent: \"SCRIBE\",\n  message: \"Processing request for commit 1\"\n})\n\n// Log with details\nlog({\n  session: \"historian-20251026-120316\",\n  agent: \"NARRATOR\",\n  message: \"Received commit plan\",\n  details: JSON.stringify(commitPlan, null, 2)\n})\n```\n\n## File Structure\n\n```\n/tmp/{session_id}/\nâ”œâ”€â”€ transcript.log          # Main log file\nâ””â”€â”€ log/                    # Details directory\n    â”œâ”€â”€ 1730000609123-a3f2d9\n    â”œâ”€â”€ 1730000610456-b8c1e2\n    â””â”€â”€ ...\n```\n\n## Building\n\n```bash\nnpm install\nnpm run build\n```\n\nThis creates:\n- `dist/index.js` - Compiled TypeScript\n- `dist/bundle.js` - Bundled standalone executable\n\n## Testing\n\n### Quick Test\n```bash\ncd servers/log-mcp\nchmod +x test-simple.sh\n./test-simple.sh\n```\n\nThis verifies:\n- Bundle exists and has correct shebang\n- No duplicate shebang (common build issue)\n- Server can start without errors\n\n### Integration Test\n\nThe MCP server will be automatically loaded by Claude Code when the historian plugin is installed. To verify it's working:\n\n1. Reinstall the historian plugin\n2. Check Claude Code's MCP server logs\n3. Use the `/historian:narrate` command and check `/tmp/historian-*/transcript.log` for properly formatted timestamps\n\n### Manual Test\n\nTo test the `log` tool manually:\n```bash\nnode dist/bundle.js\n```\n\nThen send a JSON-RPC request via stdin:\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"log\",\n    \"arguments\": {\n      \"session\": \"test-session\",\n      \"agent\": \"TEST\",\n      \"message\": \"Hello world\"\n    }\n  }\n}\n```\n\nCheck `/tmp/test-session/transcript.log` for the logged message.\n",
        "plugins/historian/servers/sidechat-mcp/README.md": "# Sidechat MCP Server\n\nA session-based communication system for coordinating agents via MCP (Model Context Protocol).\n\n## Overview\n\nSidechat provides simple, reliable communication between agents using a session-based model. Agents can \"sidechat\" with each other by sending and receiving JSON messages through named inboxes, creating a communication channel alongside their main work.\n\n## Concepts\n\n### Sessions\n\nA **session** is a unique identifier that groups related agents together. All agents participating in the same coordination must agree on a session ID. How you establish this session ID is up to you:\n\n- Use a timestamp-based identifier\n- Use a work directory name\n- Use any unique string your agents can share\n\nSessions are completely isolated - agents in different sessions cannot see each other's messages.\n\n### Agent IDs\n\nWithin a session, each agent has a unique **agent ID** (a simple string like `\"narrator\"` or `\"scribe\"`). Messages are addressed to agent IDs.\n\n### Messages\n\nMessages are free-form JSON objects. The structure and content are entirely up to the agents using the server. Common patterns include:\n\n```json\n{ \"type\": \"request\", \"data\": {...} }\n{ \"type\": \"response\", \"status\": \"success\", \"result\": {...} }\n```\n\n## Tools\n\n### `send_message`\n\nSend a message to an agent's inbox.\n\n**Parameters:**\n- `session` (string, required): Session ID\n- `to` (string, required): Target agent ID\n- `message` (object, required): Message payload (any JSON object)\n\n**Returns:**\n```json\n{ \"message_id\": \"msg-1234567890-abc123\" }\n```\n\n**Example:**\n```typescript\nsend_message({\n  session: \"historian-20251024-140530\",\n  to: \"scribe\",\n  message: {\n    type: \"commit_request\",\n    commit_num: 1,\n    description: \"Add user authentication\"\n  }\n})\n```\n\n### `receive_message`\n\nReceive the next message from an agent's inbox. **Blocks** until a message arrives or timeout is reached.\n\n**Parameters:**\n- `session` (string, required): Session ID\n- `as` (string, required): Agent ID receiving the message\n- `timeout` (number, optional): Timeout in milliseconds. If omitted, blocks indefinitely.\n\n**Returns:**\n```json\n{\n  \"message_id\": \"msg-1234567890-abc123\",\n  \"message\": { ... }\n}\n```\n\nReturns `null` if timeout is reached with no message.\n\n**Example:**\n```typescript\n// Wait indefinitely\nreceive_message({\n  session: \"historian-20251024-140530\",\n  as: \"narrator\"\n})\n\n// With timeout (30 seconds)\nreceive_message({\n  session: \"historian-20251024-140530\",\n  as: \"narrator\",\n  timeout: 30000\n})\n```\n\n## Message Delivery\n\n- Messages are delivered in **FIFO order** (first in, first out)\n- Messages persist until received\n- Once received, messages are automatically deleted\n- Messages are stored in `/tmp/sidechat-{instance-id}/{session}/{agent}/inbox/`\n\n## Usage in Claude Code Plugins\n\n### 1. Add to plugin.json\n\n```json\n{\n  \"mcpServers\": {\n    \"sidechat\": {\n      \"command\": \"node\",\n      \"args\": [\"${CLAUDE_PLUGIN_ROOT}/servers/sidechat-mcp/dist/index.js\"]\n    }\n  }\n}\n```\n\n### 2. Use in Agent Prompts\n\nAgents automatically get access to `send_message` and `receive_message` tools:\n\n```bash\n# In narrator agent:\nSESSION_ID=\"my-unique-session\"\n\n# Send a message\nsend_message \\\n  --session \"$SESSION_ID\" \\\n  --to \"scribe\" \\\n  --message '{\"type\":\"request\",\"data\":\"...\"}'\n\n# Receive a message\nreceive_message \\\n  --session \"$SESSION_ID\" \\\n  --as \"narrator\"\n```\n\n## Development\n\n### Build\n\nThe build process compiles TypeScript and creates a bundled standalone file:\n\n```bash\nnpm install\nnpm run build  # Runs tsc && npm run bundle\n```\n\nThis creates:\n- `dist/index.js` - Compiled TypeScript\n- `dist/bundle.js` - Standalone bundled file (includes all dependencies)\n\nThe bundled file is what gets used by the plugin, ensuring it works without requiring `node_modules`.\n\n### Watch Mode\n\n```bash\nnpm run watch  # TypeScript watch mode\n```\n\n### Manual Bundle\n\n```bash\nnpm run bundle  # Create standalone bundle\n```\n\n## Design Philosophy\n\nThis MCP server is intentionally **generic and plugin-agnostic**:\n\n- No assumptions about message structure\n- No knowledge of specific use cases\n- Simple session-based isolation\n- Minimal API surface\n\nThis makes it easy to extract into a standalone package or reuse across different plugins.\n\n## Future Enhancements\n\nPotential additions (not yet implemented):\n\n- `has_messages(session, agent)` - Check inbox without blocking\n- `clear_messages(session, agent)` - Delete all pending messages\n- Message priorities or filtering\n- Broadcast messages to multiple agents\n- Session lifecycle management\n\n## License\n\nMIT\n",
        "plugins/historian/skills/rewriting-git-commits/SKILL.md": "---\nname: Rewriting Git Commits\ndescription: Rewrites a git commit sequence for a changeset to create a clean branch with commits optimized for readability and review\nallowed-tools: Task, Bash, Read\n---\n\n# Rewriting Git Commits Skill\n\nYou coordinate three parallel agents (analyst, narrator, and scribe) to rewrite git commit sequences into clean, logical commits.\n\n## Input\n\nThe changeset description: **$PROMPT**\n\n## Your Task\n\n### Step 1: Establish Session ID\n\nCreate a unique session ID for the agents to communicate via sidechat:\n\n```bash\n# Generate timestamp-based session ID\nTIMESTAMP=$(date +%Y%m%d-%H%M%S)\nSESSION_ID=\"historian-$TIMESTAMP\"\n\n# Create work directory for storing state and logs\nWORK_DIR=\"/tmp/$SESSION_ID\"\nmkdir -p \"$WORK_DIR\"\n\n# Initialize state file\nCURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\ncat > \"$WORK_DIR/state.json\" <<EOF\n{\n  \"session_id\": \"$SESSION_ID\",\n  \"timestamp\": \"$TIMESTAMP\",\n  \"original_branch\": \"$CURRENT_BRANCH\",\n  \"work_dir\": \"$WORK_DIR\"\n}\nEOF\n\necho \"Created session: $SESSION_ID\"\necho \"Work directory: $WORK_DIR\"\n```\n\nSave both `$SESSION_ID` and `$WORK_DIR` for later use.\n\n### Step 2: Launch All Three Agents in Parallel\n\n**CRITICAL: Make THREE Task calls in a SINGLE message** to launch all agents in parallel:\n\n```\nTask(\n  subagent_type: \"historian:analyst\",\n  description: \"Analyze changeset and create commit plan\",\n  prompt: \"Session ID: $SESSION_ID\nWork directory: $WORK_DIR\nChangeset: $PROMPT\"\n)\n\nTask(\n  subagent_type: \"historian:narrator\",\n  description: \"Execute commit plan\",\n  prompt: \"Session ID: $SESSION_ID\nWork directory: $WORK_DIR\"\n)\n\nTask(\n  subagent_type: \"historian:scribe\",\n  description: \"Create commits with build validation\",\n  prompt: \"Session ID: $SESSION_ID\nWork directory: $WORK_DIR\"\n)\n```\n\nThe agents coordinate via sidechat MCP. You will **block here** until all complete.\n\n### Step 3: Report Results\n\nRead `$WORK_DIR/state.json` to extract `original_branch`, `clean_branch`, and `commits_created`. Report success with the branch names and commit count.\n",
        "plugins/poet/.claude-plugin/plugin.json": "{\n  \"name\": \"poet\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Experimental plugin to test agent user interaction\",\n  \"author\": {\n    \"name\": \"David Herman\"\n  }\n}\n",
        "plugins/poet/README.md": "# Poet - Experimental Plugin\n\nA simple experimental plugin to test whether Claude Code agents can directly use the AskUserQuestion tool.\n\n## Purpose\n\nThis plugin tests if:\n- An agent launched via Task can use AskUserQuestion\n- User responses are properly passed back to the agent\n- The agent can continue execution after receiving the response\n\n## Usage\n\n```\n/poem\n```\n\nThe agent will:\n1. Ask for your name\n2. Write a personalized poem\n3. Show you the result\n\n## What We're Testing\n\nIf this works directly without any trampoline/coordinator:\n- Agents CAN ask users questions directly\n- The fork/join model supports user interaction\n- We may not need the complex trampoline pattern in historian\n\nIf this doesn't work:\n- We'll see how the agent behaves\n- We'll learn what limitations exist\n- We can design around them\n",
        "plugins/poet/agents/poet.md": "---\nname: poet\ndescription: Asks for the user's name and writes a personalized poem\ntools: AskUserQuestion\nmodel: inherit\ncolor: purple\n---\n\n# Poet Agent\n\nYou are a poet who writes personalized poems for users.\n\n## Your Task\n\n1. **Ask the user for their name** using the AskUserQuestion tool\n2. **Write a short, creative poem** (4-8 lines) that incorporates their name\n3. **Present the poem** to the user\n\n## Instructions\n\n**Step 1: Ask for the name**\n\nUse AskUserQuestion to ask the user:\n- \"What is your name?\"\n\n**Step 2: Write the poem**\n\nCreate a short, whimsical poem that:\n- Mentions or plays with their name\n- Is positive and fun\n- Is 4-8 lines long\n\n**Step 3: Present it**\n\nShare the poem with the user in your response.\n\n## Example\n\nIf user says their name is \"Alice\":\n\n```\nAlice, adventurer bold,\nWith stories yet untold,\nThrough wonderlands you roam,\nMaking everywhere your home!\n```\n\nNow go ahead and create a poem for the user!\n",
        "plugins/poet/commands/poem.md": "---\ndescription: Write a personalized poem for you\nallowed-tools: Task\n---\n\n# Poem Command\n\nThis command invokes the poet agent to write you a personalized poem.\n\n## Your Task\n\nSimply launch the poet agent:\n\n```\nTask(\n  subagent_type: \"poet:poet\",\n  description: \"Write personalized poem\",\n  prompt: \"Please write a personalized poem for the user. Ask them for their name first.\"\n)\n```\n\nThe poet agent will:\n1. Ask the user for their name\n2. Write a personalized poem\n3. Present it to the user\n"
      },
      "plugins": [
        {
          "name": "historian",
          "source": "./plugins/historian",
          "description": "Rewrite git commit sequences to create clean, readable branches",
          "version": "0.6.13",
          "author": {
            "name": "David Herman"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add dherman/claude-plugins",
            "/plugin install historian@dherman"
          ]
        },
        {
          "name": "poet",
          "source": "./plugins/poet",
          "description": "Experimental plugin to test agent user interaction",
          "version": "0.1.0",
          "author": {
            "name": "David Herman"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add dherman/claude-plugins",
            "/plugin install poet@dherman"
          ]
        }
      ]
    }
  ]
}