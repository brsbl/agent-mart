{
  "author": {
    "id": "mateon01",
    "display_name": "West Kim",
    "avatar_url": "https://avatars.githubusercontent.com/u/18133668?u=12aff33ee8ea23b115e5b1bcebac58c4280ee91d&v=4"
  },
  "marketplaces": [
    {
      "name": "aidlc-for-claude",
      "version": null,
      "description": "AI-DLC (AI-Driven Development Life Cycle) - A structured three-phase workflow (INCEPTION, CONSTRUCTION, OPERATIONS) that guides AI assistants through disciplined software development with adaptive depth, human-in-the-loop approval gates, and comprehensive audit trails.",
      "repo_full_name": "mateon01/aidlc-for-claude",
      "repo_url": "https://github.com/mateon01/aidlc-for-claude",
      "repo_description": "AI-DLC (AI-Driven Development Life Cycle) plugin for Claude Code",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-12T08:56:17Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"aidlc-for-claude\",\n  \"owner\": {\n    \"name\": \"AI-DLC\",\n    \"email\": \"mateon01@gmail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"aidlc-for-claude\",\n      \"source\": \"./\",\n      \"description\": \"AI-DLC (AI-Driven Development Life Cycle) - A structured three-phase workflow (INCEPTION, CONSTRUCTION, OPERATIONS) that guides AI assistants through disciplined software development with adaptive depth, human-in-the-loop approval gates, and comprehensive audit trails.\",\n      \"category\": \"productivity\",\n      \"tags\": [\n        \"ai-dlc\",\n        \"sdlc\",\n        \"software-development\",\n        \"workflow\",\n        \"methodology\",\n        \"inception\",\n        \"construction\",\n        \"requirements\",\n        \"design\",\n        \"code-generation\"\n      ],\n      \"homepage\": \"https://github.com/mateon01/aidlc-for-claude\",\n      \"version\": \"1.6.1\",\n      \"author\": {\n        \"name\": \"AI-DLC\",\n        \"email\": \"mateon01@gmail.com\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"aidlc-for-claude\",\n  \"version\": \"1.6.1\",\n  \"description\": \"AI-DLC (AI-Driven Development Life Cycle) - A structured, adaptive software development workflow for Claude Code\",\n  \"skills\": \"./commands/\"\n}\n",
        "README.md": "# AI-DLC for Claude Code\n\nA Claude Code plugin that implements the **AI-DLC (AI-Driven Development Life Cycle)** methodology -- a structured, adaptive software development workflow that guides AI assistants through disciplined three-phase development.\n\nAI-DLC intelligently adapts to your project: simple changes execute only essential stages, while complex projects receive comprehensive treatment with full safeguards.\n\n**[Documentation](https://mateon01.github.io/aidlc-for-claude)** | **[Apache-2.0 License](LICENSE)**\n\n## Installation\n\nIn the Claude Code chat, run these two commands:\n\n```\n/plugin marketplace add mateon01/aidlc-for-claude\n/plugin install aidlc-for-claude\n```\n\n## Quick Start\n\n```\n/aidlc\n```\n\nThat's it. The orchestrator detects your workspace (greenfield or brownfield), gathers requirements through interactive Q&A, and walks through each phase with you. Every stage requires your approval before proceeding.\n\nTo run a specific stage independently:\n\n```\n/aidlc-requirements-analysis\n/aidlc-code-generation\n```\n\n## How It Works\n\nAI-DLC has three phases. Each phase contains stages that may execute conditionally based on your project's needs.\n\n```\n+-----------------------------------------------------------------------+\n|                     INCEPTION (WHAT and WHY)                          |\n|                                                                       |\n|  Workspace Detection --> [Scope Assessment (brownfield)]              |\n|  --> Reverse Engineering --> Requirements Analysis                    |\n|  --> User Stories --> Workflow Planning --> Application Design         |\n|  --> Units Generation                                                 |\n+-----------------------------------+-----------------------------------+\n                                    |\n                                    v\n+-----------------------------------------------------------------------+\n|                     CONSTRUCTION (HOW)                                |\n|                                                                       |\n|  System NFR Assessment -->                                            |\n|  FOR each unit (sequential or parallel):                              |\n|    Functional Design --> NFR Requirements --> NFR Design               |\n|    --> Infrastructure Design --> Code Generation                      |\n|                                                                       |\n|  Build and Test (after all units) + security scan + coverage          |\n|  Operations (CI/CD, PR Review, Dockerfile, .env, README, deploy)     |\n+-----------------------------------+-----------------------------------+\n                                    |\n                                    v\n+-----------------------------------------------------------------------+\n|                     OPERATIONS                                        |\n+-----------------------------------------------------------------------+\n```\n\n### Stage Execution\n\nNot every stage runs every time. After Workflow Planning, an execution plan determines which stages are needed:\n\n| Condition | Stages Executed |\n|-----------|----------------|\n| Simple bug fix | Workspace Detection, Requirements, Workflow Planning, Code Generation, Build and Test |\n| Simple brownfield (fast path) | Workspace Detection, Reverse Engineering, Workflow Planning (minimal), Code Generation, Build and Test |\n| New feature (greenfield) | All INCEPTION + all CONSTRUCTION stages |\n| Brownfield modification | Adds Reverse Engineering, adapts scope based on existing codebase |\n| Infrastructure-only change | Skips User Stories, Functional Design; includes Infrastructure Design |\n\nYou can override any recommendation at the Workflow Planning approval gate.\n\n## Commands\n\n| Command | Phase | Description |\n|---------|-------|-------------|\n| `/aidlc` | - | Main orchestrator (start here) |\n| `/aidlc-workspace-detection` | INCEPTION 1 | Scan workspace, detect greenfield/brownfield |\n| `/aidlc-reverse-engineering` | INCEPTION 2 | Analyze existing codebase (brownfield) |\n| `/aidlc-requirements-analysis` | INCEPTION 3 | Gather and analyze requirements |\n| `/aidlc-user-stories` | INCEPTION 4 | Create user stories with INVEST criteria |\n| `/aidlc-workflow-planning` | INCEPTION 5 | Determine execution plan |\n| `/aidlc-application-design` | INCEPTION 6 | Component and service layer design |\n| `/aidlc-units-generation` | INCEPTION 7 | Decompose system into units |\n| `/aidlc-system-nfr` | CONSTRUCTION 0 | System-level NFR decisions (multi-unit projects) |\n| `/aidlc-functional-design` | CONSTRUCTION 1 | Business logic design (per-unit) |\n| `/aidlc-nfr-requirements` | CONSTRUCTION 2 | Non-functional requirements (per-unit) |\n| `/aidlc-nfr-design` | CONSTRUCTION 3 | NFR pattern design (per-unit) |\n| `/aidlc-infrastructure-design` | CONSTRUCTION 4 | Infrastructure mapping (per-unit) |\n| `/aidlc-code-generation` | CONSTRUCTION 5 | Code generation (per-unit) |\n| `/aidlc-build-and-test` | CONSTRUCTION 6 | Build, test (coverage), security scan, integration/E2E tests |\n| `/aidlc-operations` | OPERATIONS | CI/CD, Dockerfile, .env.example, README, deployment checklist |\n| `/aidlc-review-pr` | UTILITY | Analyze PR diffs for code quality, security, and consistency |\n| `/aidlc-ci-setup` | UTILITY | Generate CI/CD pipelines, PR review workflows, and issue/PR templates |\n| `/aidlc-graph` | UTILITY | Build, update, and visualize code dependency graphs |\n\n## Agents\n\nEach command delegates to a specialized agent via the Task tool. Agents use the fully qualified `aidlc-for-claude:` prefix and are tiered by model for cost-efficiency:\n\n### Opus (Strategic Reasoning)\n\n| Agent | Purpose |\n|-------|---------|\n| `aidlc-for-claude:aidlc-reverse-engineer` | Deep codebase analysis for brownfield projects |\n| `aidlc-for-claude:aidlc-requirements-analyst` | Requirements gathering with adaptive depth |\n| `aidlc-for-claude:aidlc-story-writer` | User story creation with INVEST criteria |\n| `aidlc-for-claude:aidlc-workflow-planner` | Execution planning and stage determination |\n| `aidlc-for-claude:aidlc-application-designer` | Component and service layer design |\n| `aidlc-for-claude:aidlc-units-planner` | System decomposition into units |\n| `aidlc-for-claude:aidlc-code-planner` | Code generation plan with mandatory test plans per module |\n\n### Sonnet (Volume Work)\n\n| Agent | Purpose |\n|-------|---------|\n| `aidlc-for-claude:aidlc-functional-designer` | Business logic and domain model design |\n| `aidlc-for-claude:aidlc-nfr-analyst` | Non-functional requirements assessment |\n| `aidlc-for-claude:aidlc-system-nfr-analyst` | System-level NFR decisions for multi-unit projects |\n| `aidlc-for-claude:aidlc-nfr-designer` | NFR pattern and component design |\n| `aidlc-for-claude:aidlc-infra-designer` | Infrastructure service mapping |\n| `aidlc-for-claude:aidlc-code-generator` | Code + test generation with multi-layer quality gate |\n| `aidlc-for-claude:aidlc-build-test-engineer` | Build, test (coverage), security scan, integration/E2E scaffolding |\n| `aidlc-for-claude:aidlc-ops-generator` | CI/CD, Dockerfile, Docker Compose, .env.example, README, deployment checklist |\n| `aidlc-for-claude:aidlc-pr-reviewer` | PR diff analysis for code quality, security, performance, and consistency |\n| `aidlc-for-claude:aidlc-ci-setup-engineer` | CI/CD pipeline, PR review workflow, and issue/PR template generation |\n| `aidlc-for-claude:aidlc-graph-analyzer` | Code dependency graph with multi-backend support (File/Neo4j/Neptune), impact analysis, and visualization |\n\n### Haiku (Fast Detection)\n\n| Agent | Purpose |\n|-------|---------|\n| `aidlc-for-claude:aidlc-workspace-analyst` | Workspace scanning and project type detection |\n\n**Model strategy:** Opus handles stages requiring deep reasoning (requirements analysis, architectural decisions, planning). Sonnet handles volume work (design documents, code generation, testing, operations). Haiku handles fast detection (workspace scanning, project classification).\n\nTotal: **19 specialized agents** across 3 model tiers.\n\n## Key Conventions\n\n**Deep questioning** -- INCEPTION stages ask 15-30 practical questions across mandatory analysis categories (12 for requirements, 10 for application design, 12 for stories, 9 for units) with multi-round md file Q&A. Each category requires at least 1 question, and agents have mandatory minimums to prevent shallow analysis.\n\n**Interactive Q&A** -- Simple preference questions use Claude Code's interactive question UI (AskUserQuestion) with clickable options. Complex questions with many items use document-based questionnaires. All decisions are documented in the audit trail.\n\n**Brownfield fast path** -- For existing codebases, a scope assessment after workspace detection lets you choose between four options: simple change (fast path to code generation), complex change (streamlined path), new component within existing repo, or full structured workflow.\n\n**Prerequisite validation** -- Construction agents verify required input files exist before proceeding, failing fast with clear errors if a prior stage was skipped.\n\n**System-level NFR** -- For multi-unit projects, cross-cutting NFR decisions (authentication, observability, error handling) are established once before the per-unit loop, preventing contradictory choices.\n\n**Approval gates** are required at each stage. You review the generated artifacts and choose to approve, request changes, or add/remove stages.\n\n**Audit trail** (`aidlc-docs/audit.md`) captures every user input with ISO 8601 timestamps. It is append-only and never overwritten.\n\n**Session continuity** is handled via `aidlc-docs/aidlc-state.md`. Re-running `/aidlc` detects existing state and offers to resume.\n\n**Error recovery** -- Failed stages can be retried, skipped, or aborted. State is preserved for session continuity. Build failures are retried up to 3 times with automated fix attempts.\n\n**Stage banners (MOTD)** -- Every agent displays a formatted banner on start showing phase, stage number, agent name, model, and key capabilities. The orchestrator also shows a stage banner before each delegation, so you always know which stage is running and what to expect.\n\n**Parallel unit execution** -- CONSTRUCTION supports concurrent unit processing for projects with 3 or more units. Units with no inter-dependencies execute simultaneously in parallel groups, reducing total build time. File ownership ensures no conflicts between parallel units. Shared files are modified only in the final Build & Test phase.\n\n**Batch approval** -- Optionally auto-approve construction design stages (Functional Design through Infrastructure Design) to reduce review overhead on large projects. Code Generation and Build & Test still require explicit review.\n\n**Git safety** -- Brownfield code generation creates a `aidlc/{unit-name}` git branch before modifying existing files, providing a safe rollback point.\n\n**Code quality gate** -- Before presenting generated code, the agent runs a multi-layer quality check: type/syntax check (tsc, py_compile, cargo check, go vet), lint check (ESLint, Ruff, Clippy if configured), and unit test execution. Auto-fixes issues up to 3 times.\n\n**Test-first code generation** -- Code generation plans include mandatory test plans per module with test file paths, test cases, and coverage targets. Test files are generated alongside application code as first-class artifacts.\n\n**Dependency security scanning** -- Build and Test stage runs `npm audit` / `pip audit` / `cargo audit` to catch known vulnerabilities in dependencies. Results are informational (not gating).\n\n**Test coverage tracking** -- Test execution includes coverage flags (--coverage, --cov) when available. Coverage percentage is reported in the execution report.\n\n**Integration test scaffolding** -- For multi-unit projects, executable integration test files are generated to verify cross-unit interfaces, API contracts, and shared data models.\n\n**E2E test scaffolding** -- For web applications, optional Playwright or Cypress test scaffolds with basic smoke tests are generated based on data-testid attributes in UI components.\n\n**Operations artifacts** -- The Operations phase generates executable artifacts beyond documentation: CI/CD pipeline, Dockerfile, Docker Compose, .env.example, root README.md, and monitoring configuration.\n\n**Design conformance check** -- Optional verification that generated code matches functional design artifacts (domain entities, API endpoints, business rules).\n\n**Cross-unit consistency** -- When building multi-unit systems, each unit receives summaries of all previously completed units to maintain consistent domain models, tech stack choices, and conventions.\n\n**PR review** -- The `/aidlc-review-pr` standalone utility analyzes PR diffs or local changes across 6 categories (correctness, security, performance, consistency, testing, documentation). It can review GitHub PRs, local changes, or branch diffs independently of the three-phase workflow.\n\n**CI setup** -- The `/aidlc-ci-setup` standalone utility generates CI/CD infrastructure for any project. It detects the tech stack automatically and generates CI/CD pipelines, AI-powered PR review workflows, issue templates, and PR templates -- no prior AI-DLC stages required.\n\n**Dependency graph** -- Optional graph-based code dependency analysis with multi-backend support. During Workflow Planning, choose from three backends: **Neo4j Local** (Docker-based with Cypher queries and browser visualization), **AWS Neptune** (managed graph DB with IaC provisioning via CDK/Terraform/CloudFormation), or **File-based** (simple JSON, no dependencies). Deployment verification (9 checks: connection, schema, node/edge counts, orphan/duplicate edge detection, hub analysis, circular dependency detection, impact analysis) ensures graph DB health after setup. The standalone `/aidlc-graph` utility can build, update, visualize, verify, or tear down the graph at any time. When using the full workflow, the graph is automatically maintained: Reverse Engineering builds the initial graph (brownfield), Code Generation updates it incrementally per unit with integrity verification, and Build & Test uses impact analysis for prioritized test execution (direct dependencies first, then 1-hop, then full suite). The orchestrator manages graph DB lifecycle (initialization, health checks, parallel coordination, teardown). Graph operations are non-blocking -- failures log warnings and continue the workflow. E2E verified with Neo4j backend on a 15-module TypeScript project (15 nodes, 41 edges, all checks passed).\n\n**Adaptive depth** means all defined artifacts for a stage are created, but the detail level adapts to problem complexity. A simple bug fix gets concise artifacts; a complex system gets comprehensive treatment.\n\n**ASCII diagrams** use only `+`, `-`, `|`, `^`, `v`, `<`, `>` characters. No Unicode box-drawing characters.\n\n## Artifacts\n\nAll documentation is generated in the `aidlc-docs/` directory. Application code is always placed in the workspace root.\n\n```\naidlc-docs/\n  aidlc-state.md                    # Workflow state tracking\n  audit.md                          # Append-only audit trail\n  graph/\n    dependency-graph.json           # Code dependency graph (when enabled)\n    dependency-graph.md             # Mermaid visualization (when enabled)\n    graph-summary.md                # Graph statistics summary (all backends)\n    verification-report.md          # DB verification report (neo4j/neptune)\n    infra/                          # IaC files for Neptune (neptune only)\n  inception/\n    plans/                          # Execution plans\n    reverse-engineering/            # 8 RE artifacts (brownfield)\n    requirements/                   # Requirements + question files\n    user-stories/                   # Stories + personas\n    application-design/             # Components, services, dependencies\n  construction/\n    system-nfr-decisions.md         # System-level NFR (multi-unit projects)\n    plans/                          # Per-unit code plans\n    {unit-name}/\n      functional-design/            # Business logic, rules, entities\n      nfr-requirements/             # Quality attributes, tech stack\n      nfr-design/                   # Patterns, logical components\n      infrastructure-design/        # Service mapping\n      code/                         # Code summaries (code itself at workspace root)\n    build-and-test/                 # Build and test instructions + execution report\n  operations/\n    deployment-checklist.md         # Deployment steps and validation\n    developer-readme.md             # Developer onboarding and setup\n\n# Workspace root (application + operational artifacts)\n.env.example                        # Environment configuration template\n.github/workflows/ci.yml            # CI/CD pipeline (or .gitlab-ci.yml)\n.github/workflows/pr-review.yml     # AI-powered PR review (conditional)\n.github/ISSUE_TEMPLATE/             # Issue form templates (feature, bug)\n.github/PULL_REQUEST_TEMPLATE.md    # PR template\nDockerfile                          # Container image (conditional)\ndocker-compose.yml                  # Multi-service setup (conditional, multi-unit)\nREADME.md                           # Project README (generated or updated)\ntests/                              # Generated test files alongside application code\n  integration/                      # Integration tests (multi-unit)\n  e2e/                              # E2E test scaffolds (web apps, optional)\n```\n\n## Plugin Structure\n\n```\naidlc-for-claude/\n  .claude-plugin/\n    plugin.json                     # Plugin metadata\n    marketplace.json                # Marketplace listing\n  commands/                         # 19 slash commands\n    aidlc.md                        # Entry point orchestrator\n    aidlc-workspace-detection.md\n    aidlc-reverse-engineering.md\n    aidlc-requirements-analysis.md\n    aidlc-user-stories.md\n    aidlc-workflow-planning.md\n    aidlc-application-design.md\n    aidlc-units-generation.md\n    aidlc-system-nfr.md\n    aidlc-functional-design.md\n    aidlc-nfr-requirements.md\n    aidlc-nfr-design.md\n    aidlc-infrastructure-design.md\n    aidlc-code-generation.md\n    aidlc-build-and-test.md\n    aidlc-operations.md\n    aidlc-review-pr.md\n    aidlc-ci-setup.md\n    aidlc-graph.md\n  agents/                           # 19 specialized agents\n    aidlc-workspace-analyst.md\n    aidlc-reverse-engineer.md\n    aidlc-requirements-analyst.md\n    aidlc-story-writer.md\n    aidlc-workflow-planner.md\n    aidlc-application-designer.md\n    aidlc-units-planner.md\n    aidlc-system-nfr-analyst.md\n    aidlc-functional-designer.md\n    aidlc-nfr-analyst.md\n    aidlc-nfr-designer.md\n    aidlc-infra-designer.md\n    aidlc-code-planner.md\n    aidlc-code-generator.md\n    aidlc-build-test-engineer.md\n    aidlc-ops-generator.md\n    aidlc-pr-reviewer.md\n    aidlc-ci-setup-engineer.md\n    aidlc-graph-analyzer.md\n  docs/                             # GitHub Pages (Material for MkDocs)\n  .github/\n    workflows/\n      deploy-docs.yml               # GitHub Pages deployment\n      pr-review.yml                 # AI-powered PR review\n    ISSUE_TEMPLATE/\n      feature-request.yml           # Feature request form\n      bug-report.yml                # Bug report form\n      config.yml                    # Template config\n    PULL_REQUEST_TEMPLATE.md        # PR template\n  .gitignore\n  package.json\n  LICENSE\n  CONTRIBUTING.md\n  README.md\n```\n\n## Origin\n\nAI-DLC was originally developed as an AI-driven software development methodology by AWS. This plugin adapts the methodology for Claude Code's native command/agent system:\n\n- Kiro's rule-loading mechanism becomes self-contained agent markdown files\n- Kiro's file-based approvals become interactive approval gates\n- Single-AI execution becomes multi-agent delegation with model tiering (Opus/Sonnet/Haiku)\n\n### References\n\n- [AI-DLC Methodology Blog (AWS Tech Blog)](https://aws.amazon.com/ko/blogs/tech/ai-driven-development-life-cycle/) - Original methodology introduction\n- [AI-DLC Interactive Demo](https://prod.d13rzhkk8cj2z0.amplifyapp.com/) - Live demo of the AI-DLC workflow\n- [AI-DLC Workflows for Kiro (GitHub)](https://github.com/awslabs/aidlc-workflows) - Original Kiro steering files\n\n## License\n\nApache-2.0\n"
      },
      "plugins": [
        {
          "name": "aidlc-for-claude",
          "source": "./",
          "description": "AI-DLC (AI-Driven Development Life Cycle) - A structured three-phase workflow (INCEPTION, CONSTRUCTION, OPERATIONS) that guides AI assistants through disciplined software development with adaptive depth, human-in-the-loop approval gates, and comprehensive audit trails.",
          "category": "productivity",
          "tags": [
            "ai-dlc",
            "sdlc",
            "software-development",
            "workflow",
            "methodology",
            "inception",
            "construction",
            "requirements",
            "design",
            "code-generation"
          ],
          "homepage": "https://github.com/mateon01/aidlc-for-claude",
          "version": "1.6.1",
          "author": {
            "name": "AI-DLC",
            "email": "mateon01@gmail.com"
          },
          "categories": [
            "ai-dlc",
            "code-generation",
            "construction",
            "design",
            "inception",
            "methodology",
            "productivity",
            "requirements",
            "sdlc",
            "software-development",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add mateon01/aidlc-for-claude",
            "/plugin install aidlc-for-claude@aidlc-for-claude"
          ]
        }
      ]
    }
  ]
}