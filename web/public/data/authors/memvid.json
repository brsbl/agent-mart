{
  "author": {
    "id": "memvid",
    "display_name": "Memvid",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/241489775?v=4",
    "url": "https://github.com/memvid",
    "bio": "The Memory Layer for AI Agents.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 2,
      "total_stars": 175,
      "total_forks": 13
    }
  },
  "marketplaces": [
    {
      "name": "memvid",
      "version": null,
      "description": "Official Memvid plugins for Claude Code",
      "owner_info": {
        "name": "Memvid",
        "url": "https://memvid.com"
      },
      "keywords": [],
      "repo_full_name": "memvid/claude-brain",
      "repo_url": "https://github.com/memvid/claude-brain",
      "repo_description": "Give Claude Code photographic memory in ONE portable file. No database, no SQLite, no ChromaDB - just a single .mv2 file you can git commit, scp, or share. Native Rust core with sub-ms operations.",
      "homepage": "https://memvid.com",
      "signals": {
        "stars": 175,
        "forks": 13,
        "pushed_at": "2026-01-19T18:38:28Z",
        "created_at": "2025-12-18T20:11:22Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 349
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 369
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3587
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/ask.md",
          "type": "blob",
          "size": 797
        },
        {
          "path": "commands/recent.md",
          "type": "blob",
          "size": 730
        },
        {
          "path": "commands/search.md",
          "type": "blob",
          "size": 767
        },
        {
          "path": "commands/stats.md",
          "type": "blob",
          "size": 559
        },
        {
          "path": "dist",
          "type": "tree",
          "size": null
        },
        {
          "path": "dist/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "dist/hooks/hooks.json",
          "type": "blob",
          "size": 980
        },
        {
          "path": "dist/hooks/post-tool-use.js",
          "type": "blob",
          "size": 27044
        },
        {
          "path": "dist/hooks/post-tool-use.js.map",
          "type": "blob",
          "size": 74403
        },
        {
          "path": "dist/hooks/session-start.js",
          "type": "blob",
          "size": 2953
        },
        {
          "path": "dist/hooks/session-start.js.map",
          "type": "blob",
          "size": 11432
        },
        {
          "path": "dist/hooks/smart-install.js",
          "type": "blob",
          "size": 3030
        },
        {
          "path": "dist/hooks/smart-install.js.map",
          "type": "blob",
          "size": 11819
        },
        {
          "path": "dist/hooks/stop.js",
          "type": "blob",
          "size": 18095
        },
        {
          "path": "dist/hooks/stop.js.map",
          "type": "blob",
          "size": 52213
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 980
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/memory/SKILL.md",
          "type": "blob",
          "size": 2243
        },
        {
          "path": "skills/mind",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/mind/SKILL.md",
          "type": "blob",
          "size": 2241
        },
        {
          "path": "src",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/hooks/hooks.json",
          "type": "blob",
          "size": 980
        },
        {
          "path": "src/hooks/post-tool-use.ts",
          "type": "blob",
          "size": 8530
        },
        {
          "path": "src/hooks/session-start.ts",
          "type": "blob",
          "size": 3054
        },
        {
          "path": "src/hooks/smart-install.ts",
          "type": "blob",
          "size": 3276
        },
        {
          "path": "src/hooks/stop.ts",
          "type": "blob",
          "size": 9843
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"memvid\",\n  \"description\": \"Official Memvid plugins for Claude Code\",\n  \"owner\": {\n    \"name\": \"Memvid\",\n    \"url\": \"https://memvid.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"mind\",\n      \"description\": \"Claude Brain - Give Claude photographic memory in ONE portable file\",\n      \"version\": \"1.0.11\",\n      \"source\": \"./\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"mind\",\n  \"description\": \"Claude Mind - Give Claude photographic memory in ONE portable file. Share, version, and transfer your Claude's brain.\",\n  \"version\": \"1.0.11\",\n  \"author\": {\n    \"name\": \"Memvid\",\n    \"url\": \"https://memvid.com\"\n  },\n  \"repository\": \"https://github.com/memvid/claude-brain\",\n  \"homepage\": \"https://memvid.com\",\n  \"license\": \"MIT\"\n}\n",
        "README.md": "<div align=\"center\">\n\n<img src=\"logo.png\" alt=\"Claude Brain\" width=\"320\" />\n\n### Give Claude Code photographic memory.\n\n[![GitHub stars](https://img.shields.io/github/stars/memvid/claude-brain?style=social)](https://github.com/memvid/claude-brain)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n<br />\n\nhttps://github.com/user-attachments/assets/b57cb3db-576b-4c1f-af92-95796ba3fb5b\n\n<br />\n\n**[Install in 30 seconds](#installation)** · [How it Works](#how-it-works) · [Commands](#commands) · [Full Demo](https://youtu.be/uRT0CMdK0yg)\n\n</div>\n\n<br />\n\n## The Problem\n\n```\nYou: \"Remember that auth bug we fixed?\"\nClaude: \"I don't have memory of previous conversations.\"\nYou: \"We spent 3 hours on it yesterday\"\nClaude: \"I'd be happy to help debug from scratch!\"\n```\n\n**200K context window. Zero memory between sessions.**\n\nYou're paying for a goldfish with a PhD.\n\n<br />\n\n## The Fix\n\n```\nYou: \"What did we decide about auth?\"\nClaude: \"We chose JWT over sessions for your microservices.\n        The refresh token issue - here's exactly what we fixed...\"\n```\n\nOne file. Claude remembers everything.\n\n<br />\n\n## Installation\n\n```bash\n# One-time setup (if you haven't used GitHub plugins before)\ngit config --global url.\"https://github.com/\".insteadOf \"git@github.com:\"\n```\n\n```bash\n# In Claude Code\n/plugin add marketplace memvid/claude-brain\n```\n\nThen: `/plugins` → Installed → **mind** Enable Plugin → Restart.\n\nDone.\n\n<br />\n\n## How it Works\n\nAfter install, Claude's memory lives in one file:\n\n```\nyour-project/\n└── .claude/\n    └── mind.mv2   # Claude's brain. That's it.\n```\n\nNo database. No cloud. No API keys.\n\n**What gets captured:**\n- Session context, decisions, bugs, solutions\n- Auto-injected at session start\n- Searchable anytime\n\n**Why one file?**\n- `git commit` → version control Claude's brain\n- `scp` → transfer anywhere\n- Send to teammate → instant onboarding\n\n<br />\n\n## Commands\n\n**In Claude Code:**\n```bash\n/mind stats                       # memory statistics\n/mind search \"authentication\"     # find past context\n/mind ask \"why did we choose X?\"  # ask your memory\n/mind recent                      # what happened lately\n```\n\nOr just ask naturally: *\"mind stats\"*, *\"search my memory for auth bugs\"*, etc.\n\n<br />\n\n## CLI (Optional)\n\nFor power users who want direct access to their memory file:\n\n```bash\nnpm install -g memvid-cli\n```\n\n```bash\nmemvid stats .claude/mind.mv2           # view memory stats\nmemvid find .claude/mind.mv2 \"auth\"     # search memories\nmemvid ask .claude/mind.mv2 \"why JWT?\"  # ask questions\nmemvid timeline .claude/mind.mv2        # view timeline\n```\n\n[Full CLI reference →](https://docs.memvid.com/cli/cheat-sheet)\n\n<br />\n\n## FAQ\n\n<details>\n<summary><b>How big is the file?</b></summary>\n\nEmpty: ~70KB. Grows ~1KB per memory. A year of use stays under 5MB.\n\n</details>\n\n<details>\n<summary><b>Is it private?</b></summary>\n\n100% local. Nothing leaves your machine. Ever.\n\n</details>\n\n<details>\n<summary><b>How fast?</b></summary>\n\nSub-millisecond. Native Rust core. Searches 10K+ memories in <1ms.\n\n</details>\n\n<details>\n<summary><b>Reset memory?</b></summary>\n\n`rm .claude/mind.mv2`\n\n</details>\n\n<br />\n\n---\n\n<div align=\"center\">\n\nBuilt on **[memvid](https://github.com/memvid/memvid)** - the single-file memory engine\n\n<br />\n\n**If this saved you time, [star the repo](https://github.com/memvid/claude-brain)**\n\n<br />\n\n*Send me your `.mv2` file and I'll tell you what's wrong with your code. No context needed - I already know everything.*\n\n</div>\n",
        "commands/ask.md": "---\ndescription: Ask questions about memories and get context-aware answers\nargument-hint: <question>\nallowed-tools: Bash\n---\n\n# Memory Question\n\nAsk Claude's memory system questions about past work, decisions, and context.\n\n**Usage**: `/mind:ask <question>`\n\nExecute the ask script with user's question:\n\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/ask.js\" \"$ARGUMENTS\"\n```\n\n## Examples\n- `/mind:ask Why did we choose React?` - Get context about technology decisions\n- `/mind:ask What was the CORS solution?` - Recall specific solutions\n- `/mind:ask How did we fix the authentication bug?` - Get details about past fixes\n\n## Response Format\n- Provide context-aware answers based on stored memories\n- Reference specific memories when applicable\n- Include timestamps for referenced information",
        "commands/recent.md": "---\ndescription: Show recent memories and activity timeline\nargument-hint: [count]\nallowed-tools: Bash\n---\n\n# Recent Memories\n\nDisplay the most recent memories and activity from Claude's persistent storage.\n\n**Usage**: `/mind:recent [count]`\n\nExecute the timeline script to show recent activity:\n\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/timeline.js\" ${ARGUMENTS:-20}\n```\n\n## Examples\n- `/mind:recent` - Show 20 most recent memories (default)\n- `/mind:recent 10` - Show 10 most recent memories\n- `/mind:recent 50` - Show 50 most recent memories\n\n## Response Format\n- Display memories in reverse chronological order (newest first)\n- Convert timestamps to human-readable format\n- Group by session or time period when helpful",
        "commands/search.md": "---\ndescription: Search memories for specific content or patterns\nargument-hint: <query> [limit]\nallowed-tools: Bash\n---\n\n# Memory Search\n\nSearch through Claude's persistent memories for specific content, patterns, or keywords.\n\n**Usage**: `/mind:search <query> [limit]`\n\nExecute the search script with user's query:\n\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/find.js\" \"$ARGUMENTS\" 10\n```\n\n## Examples\n- `/mind:search authentication` - Find memories related to authentication\n- `/mind:search \"database schema\"` - Search for exact phrase\n- `/mind:search API errors` - Find memories about API errors\n\n## Response Format\n- Show matching memories with relevance scores\n- Include timestamps (convert to human-readable format)\n- Highlight matched keywords in context",
        "commands/stats.md": "---\ndescription: Show memory statistics and storage information\nallowed-tools: Bash\n---\n\n# Memory Statistics\n\nShow statistics about Claude's persistent memory file including total memories, storage size, and recent activity.\n\n**Usage**: `/mind:stats`\n\nExecute the stats script:\n\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/stats.js\"\n```\n\n## Response Format\n- Convert Unix timestamps to human-readable (Xm ago, Xh ago, Xd ago)\n- Summarize key findings in a table when appropriate\n- If file was just created, tell the user memories will appear as they work",
        "dist/hooks/hooks.json": "{\n  \"description\": \"Memvid Mind - Persistent memory for Claude Code\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/smart-install.js\\\"\",\n            \"timeout\": 30\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/session-start.js\\\"\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/post-tool-use.js\\\"\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/stop.js\\\"\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "dist/hooks/post-tool-use.js": "#!/usr/bin/env node\nimport { readdirSync, unlinkSync, existsSync } from 'fs';\nimport { resolve, dirname } from 'path';\nimport { mkdir, open } from 'fs/promises';\nimport { randomBytes } from 'crypto';\nimport lockfile from 'proper-lockfile';\n\n// src/types.ts\nvar DEFAULT_CONFIG = {\n  memoryPath: \".claude/mind.mv2\",\n  maxContextObservations: 20,\n  maxContextTokens: 2e3,\n  autoCompress: true,\n  minConfidence: 0.6,\n  debug: false\n};\nfunction generateId() {\n  return randomBytes(8).toString(\"hex\");\n}\nfunction estimateTokens(text) {\n  return Math.ceil(text.length / 4);\n}\nasync function readStdin() {\n  const chunks = [];\n  return new Promise((resolve2, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve2(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\nfunction writeOutput(output) {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\nfunction debug(message) {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\nfunction classifyObservationType(toolName, output) {\n  const lowerOutput = output.toLowerCase();\n  if (lowerOutput.includes(\"error\") || lowerOutput.includes(\"failed\") || lowerOutput.includes(\"exception\")) {\n    return \"problem\";\n  }\n  if (lowerOutput.includes(\"success\") || lowerOutput.includes(\"passed\") || lowerOutput.includes(\"completed\")) {\n    return \"success\";\n  }\n  if (lowerOutput.includes(\"warning\") || lowerOutput.includes(\"deprecated\")) {\n    return \"warning\";\n  }\n  switch (toolName) {\n    case \"Read\":\n    case \"Glob\":\n    case \"Grep\":\n      return \"discovery\";\n    case \"Edit\":\n      if (lowerOutput.includes(\"fix\") || lowerOutput.includes(\"bug\")) {\n        return \"bugfix\";\n      }\n      return \"refactor\";\n    case \"Write\":\n      return \"feature\";\n    default:\n      return \"discovery\";\n  }\n}\nvar LOCK_OPTIONS = {\n  stale: 3e4,\n  retries: {\n    retries: 1e3,\n    minTimeout: 5,\n    maxTimeout: 50\n  }\n};\nasync function withMemvidLock(lockPath, fn) {\n  await mkdir(dirname(lockPath), { recursive: true });\n  const handle = await open(lockPath, \"a\");\n  await handle.close();\n  const release = await lockfile.lock(lockPath, LOCK_OPTIONS);\n  try {\n    return await fn();\n  } finally {\n    await release();\n  }\n}\n\n// src/core/mind.ts\nfunction pruneBackups(memoryPath, keepCount) {\n  try {\n    const dir = dirname(memoryPath);\n    const baseName = memoryPath.split(\"/\").pop() || \"mind.mv2\";\n    const backupPattern = new RegExp(`^${baseName.replace(\".\", \"\\\\.\")}\\\\.backup-\\\\d+$`);\n    const files = readdirSync(dir);\n    const backups = files.filter((f) => backupPattern.test(f)).map((f) => ({\n      name: f,\n      path: resolve(dir, f),\n      time: parseInt(f.split(\"-\").pop() || \"0\", 10)\n    })).sort((a, b) => b.time - a.time);\n    for (let i = keepCount; i < backups.length; i++) {\n      try {\n        unlinkSync(backups[i].path);\n        console.error(`[memvid-mind] Pruned old backup: ${backups[i].name}`);\n      } catch {\n      }\n    }\n  } catch {\n  }\n}\nvar sdkLoaded = false;\nvar use;\nvar create;\nasync function loadSDK() {\n  if (sdkLoaded) return;\n  const sdk = await import('@memvid/sdk');\n  use = sdk.use;\n  create = sdk.create;\n  sdkLoaded = true;\n}\nvar Mind = class _Mind {\n  memvid;\n  config;\n  sessionId;\n  initialized = false;\n  constructor(memvid, config) {\n    this.memvid = memvid;\n    this.config = config;\n    this.sessionId = generateId();\n  }\n  /**\n   * Open or create a Mind instance\n   */\n  static async open(configOverrides = {}) {\n    await loadSDK();\n    const config = { ...DEFAULT_CONFIG, ...configOverrides };\n    const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\n    const memoryPath = resolve(projectDir, config.memoryPath);\n    const memoryDir = dirname(memoryPath);\n    await mkdir(memoryDir, { recursive: true });\n    let memvid;\n    const MAX_FILE_SIZE_MB = 100;\n    const lockPath = `${memoryPath}.lock`;\n    await withMemvidLock(lockPath, async () => {\n      if (!existsSync(memoryPath)) {\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n      const { statSync, renameSync, unlinkSync: unlinkSync2 } = await import('fs');\n      const fileSize = statSync(memoryPath).size;\n      const fileSizeMB = fileSize / (1024 * 1024);\n      if (fileSizeMB > MAX_FILE_SIZE_MB) {\n        console.error(`[memvid-mind] Memory file too large (${fileSizeMB.toFixed(1)}MB), likely corrupted. Creating fresh memory...`);\n        const backupPath = `${memoryPath}.backup-${Date.now()}`;\n        try {\n          renameSync(memoryPath, backupPath);\n        } catch {\n        }\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n      try {\n        memvid = await use(\"basic\", memoryPath);\n      } catch (openError) {\n        const errorMessage = openError instanceof Error ? openError.message : String(openError);\n        if (errorMessage.includes(\"Deserialization\") || errorMessage.includes(\"UnexpectedVariant\") || errorMessage.includes(\"Invalid\") || errorMessage.includes(\"corrupt\") || errorMessage.includes(\"validation failed\") || errorMessage.includes(\"unable to recover\") || errorMessage.includes(\"table of contents\")) {\n          console.error(\"[memvid-mind] Memory file corrupted, creating fresh memory...\");\n          const backupPath = `${memoryPath}.backup-${Date.now()}`;\n          try {\n            renameSync(memoryPath, backupPath);\n          } catch {\n            try {\n              unlinkSync2(memoryPath);\n            } catch {\n            }\n          }\n          memvid = await create(memoryPath, \"basic\");\n          return;\n        }\n        throw openError;\n      }\n    });\n    const mind = new _Mind(memvid, config);\n    mind.initialized = true;\n    pruneBackups(memoryPath, 3);\n    if (config.debug) {\n      console.error(`[memvid-mind] Opened: ${memoryPath}`);\n    }\n    return mind;\n  }\n  async withLock(fn) {\n    const memoryPath = this.getMemoryPath();\n    const lockPath = `${memoryPath}.lock`;\n    return withMemvidLock(lockPath, fn);\n  }\n  /**\n   * Remember an observation\n   */\n  async remember(input) {\n    const observation = {\n      id: generateId(),\n      timestamp: Date.now(),\n      type: input.type,\n      tool: input.tool,\n      summary: input.summary,\n      content: input.content,\n      metadata: {\n        ...input.metadata,\n        sessionId: this.sessionId\n      }\n    };\n    const frameId = await this.withLock(async () => {\n      return this.memvid.put({\n        title: `[${observation.type}] ${observation.summary}`,\n        label: observation.type,\n        text: observation.content,\n        metadata: {\n          observationId: observation.id,\n          timestamp: observation.timestamp,\n          tool: observation.tool,\n          sessionId: this.sessionId,\n          ...observation.metadata\n        },\n        tags: [observation.type, observation.tool].filter(Boolean)\n      });\n    });\n    if (this.config.debug) {\n      console.error(`[memvid-mind] Remembered: ${observation.summary}`);\n    }\n    return frameId;\n  }\n  /**\n   * Search memories by query (uses fast lexical search)\n   */\n  async search(query, limit = 10) {\n    return this.withLock(async () => {\n      return this.searchUnlocked(query, limit);\n    });\n  }\n  async searchUnlocked(query, limit) {\n    const results = await this.memvid.find(query, { k: limit, mode: \"lex\" });\n    return (results.frames || []).map((frame) => ({\n      observation: {\n        id: frame.metadata?.observationId || frame.frame_id,\n        timestamp: frame.metadata?.timestamp || 0,\n        type: frame.label,\n        tool: frame.metadata?.tool,\n        summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || \"\",\n        content: frame.text || \"\",\n        metadata: frame.metadata\n      },\n      score: frame.score || 0,\n      snippet: frame.snippet || frame.text?.slice(0, 200) || \"\"\n    }));\n  }\n  /**\n   * Ask the memory a question (uses fast lexical search)\n   */\n  async ask(question) {\n    return this.withLock(async () => {\n      const result = await this.memvid.ask(question, { k: 5, mode: \"lex\" });\n      return result.answer || \"No relevant memories found.\";\n    });\n  }\n  /**\n   * Get context for session start\n   */\n  async getContext(query) {\n    return this.withLock(async () => {\n      const timeline = await this.memvid.timeline({\n        limit: this.config.maxContextObservations,\n        reverse: true\n      });\n      const frames = Array.isArray(timeline) ? timeline : timeline.frames || [];\n      const recentObservations2 = frames.map(\n        (frame) => {\n          let ts = frame.metadata?.timestamp || frame.timestamp || 0;\n          if (ts > 0 && ts < 4102444800) {\n            ts = ts * 1e3;\n          }\n          return {\n            id: frame.metadata?.observationId || frame.frame_id,\n            timestamp: ts,\n            type: frame.label || frame.metadata?.type || \"observation\",\n            tool: frame.metadata?.tool,\n            summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || frame.preview?.slice(0, 100) || \"\",\n            content: frame.text || frame.preview || \"\",\n            metadata: frame.metadata\n          };\n        }\n      );\n      let relevantMemories = [];\n      if (query) {\n        const searchResults = await this.searchUnlocked(query, 10);\n        relevantMemories = searchResults.map((r) => r.observation);\n      }\n      let tokenCount = 0;\n      for (const obs of recentObservations2) {\n        const text = `[${obs.type}] ${obs.summary}`;\n        const tokens = estimateTokens(text);\n        if (tokenCount + tokens > this.config.maxContextTokens) break;\n        tokenCount += tokens;\n      }\n      return {\n        recentObservations: recentObservations2,\n        relevantMemories,\n        sessionSummaries: [],\n        // TODO: Implement session summaries\n        tokenCount\n      };\n    });\n  }\n  /**\n   * Save a session summary\n   */\n  async saveSessionSummary(summary) {\n    const sessionSummary = {\n      id: this.sessionId,\n      startTime: Date.now() - 36e5,\n      // Approximate\n      endTime: Date.now(),\n      observationCount: 0,\n      // TODO: Track this\n      keyDecisions: summary.keyDecisions,\n      filesModified: summary.filesModified,\n      summary: summary.summary\n    };\n    return this.withLock(async () => {\n      return this.memvid.put({\n        title: `Session Summary: ${(/* @__PURE__ */ new Date()).toISOString().split(\"T\")[0]}`,\n        label: \"session\",\n        text: JSON.stringify(sessionSummary, null, 2),\n        metadata: sessionSummary,\n        tags: [\"session\", \"summary\"]\n      });\n    });\n  }\n  /**\n   * Get memory statistics\n   */\n  async stats() {\n    return this.withLock(async () => {\n      const stats = await this.memvid.stats();\n      const timeline = await this.memvid.timeline({ limit: 1, reverse: false });\n      const recentTimeline = await this.memvid.timeline({ limit: 1, reverse: true });\n      const oldestFrames = Array.isArray(timeline) ? timeline : timeline.frames || [];\n      const newestFrames = Array.isArray(recentTimeline) ? recentTimeline : recentTimeline.frames || [];\n      return {\n        totalObservations: stats.frame_count || 0,\n        totalSessions: 0,\n        // TODO: Count unique sessions\n        oldestMemory: oldestFrames[0]?.metadata?.timestamp || oldestFrames[0]?.timestamp || 0,\n        newestMemory: newestFrames[0]?.metadata?.timestamp || newestFrames[0]?.timestamp || 0,\n        fileSize: stats.size_bytes || 0,\n        topTypes: {}\n        // TODO: Aggregate\n      };\n    });\n  }\n  /**\n   * Get the session ID\n   */\n  getSessionId() {\n    return this.sessionId;\n  }\n  /**\n   * Get the memory file path\n   */\n  getMemoryPath() {\n    return resolve(process.cwd(), this.config.memoryPath);\n  }\n  /**\n   * Check if initialized\n   */\n  isInitialized() {\n    return this.initialized;\n  }\n};\nvar mindInstance = null;\nasync function getMind(config) {\n  if (!mindInstance) {\n    mindInstance = await Mind.open(config);\n  }\n  return mindInstance;\n}\n\n// src/utils/compression.ts\nvar TARGET_COMPRESSED_SIZE = 2e3;\nvar COMPRESSION_THRESHOLD = 3e3;\nfunction compressToolOutput(toolName, toolInput, output) {\n  const originalSize = output.length;\n  if (originalSize <= COMPRESSION_THRESHOLD) {\n    return { compressed: output, wasCompressed: false, originalSize };\n  }\n  let compressed;\n  switch (toolName) {\n    case \"Read\":\n      compressed = compressFileRead(toolInput, output);\n      break;\n    case \"Bash\":\n      compressed = compressBashOutput(toolInput, output);\n      break;\n    case \"Grep\":\n      compressed = compressGrepOutput(toolInput, output);\n      break;\n    case \"Glob\":\n      compressed = compressGlobOutput(toolInput, output);\n      break;\n    case \"Edit\":\n    case \"Write\":\n      compressed = compressEditOutput(toolInput, output);\n      break;\n    default:\n      compressed = compressGeneric(output);\n  }\n  return {\n    compressed: truncateToTarget(compressed),\n    wasCompressed: true,\n    originalSize\n  };\n}\nfunction compressFileRead(toolInput, output) {\n  const filePath = toolInput?.file_path || \"unknown\";\n  const fileName = filePath.split(\"/\").pop() || \"file\";\n  const lines = output.split(\"\\n\");\n  const totalLines = lines.length;\n  const imports = extractImports(output);\n  const exports$1 = extractExports(output);\n  const functions = extractFunctionSignatures(output);\n  const classes = extractClassNames(output);\n  const errors = extractErrorPatterns(output);\n  const parts = [\n    `\\u{1F4C4} File: ${fileName} (${totalLines} lines)`\n  ];\n  if (imports.length > 0) {\n    parts.push(`\n\\u{1F4E6} Imports: ${imports.slice(0, 10).join(\", \")}${imports.length > 10 ? ` (+${imports.length - 10} more)` : \"\"}`);\n  }\n  if (exports$1.length > 0) {\n    parts.push(`\n\\u{1F4E4} Exports: ${exports$1.slice(0, 10).join(\", \")}${exports$1.length > 10 ? ` (+${exports$1.length - 10} more)` : \"\"}`);\n  }\n  if (functions.length > 0) {\n    parts.push(`\n\\u26A1 Functions: ${functions.slice(0, 10).join(\", \")}${functions.length > 10 ? ` (+${functions.length - 10} more)` : \"\"}`);\n  }\n  if (classes.length > 0) {\n    parts.push(`\n\\u{1F3D7}\\uFE0F Classes: ${classes.join(\", \")}`);\n  }\n  if (errors.length > 0) {\n    parts.push(`\n\\u26A0\\uFE0F Errors/TODOs: ${errors.slice(0, 5).join(\"; \")}`);\n  }\n  const contextLines = [\n    \"\\n--- First 10 lines ---\",\n    ...lines.slice(0, 10),\n    \"\\n--- Last 5 lines ---\",\n    ...lines.slice(-5)\n  ];\n  parts.push(contextLines.join(\"\\n\"));\n  return parts.join(\"\");\n}\nfunction compressBashOutput(toolInput, output) {\n  const command = toolInput?.command || \"command\";\n  const shortCmd = command.split(\"\\n\")[0].slice(0, 100);\n  const lines = output.split(\"\\n\");\n  const errorLines = lines.filter(\n    (l) => l.toLowerCase().includes(\"error\") || l.toLowerCase().includes(\"failed\") || l.toLowerCase().includes(\"exception\") || l.toLowerCase().includes(\"warning\")\n  );\n  const successLines = lines.filter(\n    (l) => l.toLowerCase().includes(\"success\") || l.toLowerCase().includes(\"passed\") || l.toLowerCase().includes(\"completed\") || l.toLowerCase().includes(\"done\")\n  );\n  const parts = [`\\u{1F5A5}\\uFE0F Command: ${shortCmd}`];\n  if (errorLines.length > 0) {\n    parts.push(`\n\\u274C Errors (${errorLines.length}):`);\n    parts.push(errorLines.slice(0, 10).join(\"\\n\"));\n  }\n  if (successLines.length > 0) {\n    parts.push(`\n\\u2705 Success indicators:`);\n    parts.push(successLines.slice(0, 5).join(\"\\n\"));\n  }\n  parts.push(`\n\\u{1F4CA} Output: ${lines.length} lines total`);\n  if (lines.length > 20) {\n    parts.push(\"\\n--- First 10 lines ---\");\n    parts.push(lines.slice(0, 10).join(\"\\n\"));\n    parts.push(\"\\n--- Last 5 lines ---\");\n    parts.push(lines.slice(-5).join(\"\\n\"));\n  } else {\n    parts.push(\"\\n--- Full output ---\");\n    parts.push(lines.join(\"\\n\"));\n  }\n  return parts.join(\"\");\n}\nfunction compressGrepOutput(toolInput, output) {\n  const pattern = toolInput?.pattern || \"pattern\";\n  const lines = output.split(\"\\n\").filter(Boolean);\n  const files = /* @__PURE__ */ new Set();\n  lines.forEach((line) => {\n    const match = line.match(/^([^:]+):/);\n    if (match) files.add(match[1]);\n  });\n  const parts = [\n    `\\u{1F50D} Grep: \"${pattern.slice(0, 50)}\"`,\n    `\\u{1F4C1} Found in ${files.size} files, ${lines.length} matches`\n  ];\n  if (files.size > 0) {\n    parts.push(`\n\\u{1F4C2} Files: ${Array.from(files).slice(0, 15).join(\", \")}${files.size > 15 ? ` (+${files.size - 15} more)` : \"\"}`);\n  }\n  parts.push(\"\\n--- Top matches ---\");\n  parts.push(lines.slice(0, 10).join(\"\\n\"));\n  if (lines.length > 10) {\n    parts.push(`\n... and ${lines.length - 10} more matches`);\n  }\n  return parts.join(\"\");\n}\nfunction compressGlobOutput(toolInput, output) {\n  const pattern = toolInput?.pattern || \"pattern\";\n  let files = [];\n  try {\n    const parsed = JSON.parse(output);\n    files = parsed.filenames || [];\n  } catch {\n    files = output.split(\"\\n\").filter(Boolean);\n  }\n  const byDir = {};\n  files.forEach((f) => {\n    const dir = f.split(\"/\").slice(0, -1).join(\"/\") || \"/\";\n    const file = f.split(\"/\").pop() || f;\n    if (!byDir[dir]) byDir[dir] = [];\n    byDir[dir].push(file);\n  });\n  const parts = [\n    `\\u{1F4C2} Glob: \"${pattern.slice(0, 50)}\"`,\n    `\\u{1F4C1} Found ${files.length} files in ${Object.keys(byDir).length} directories`\n  ];\n  const topDirs = Object.entries(byDir).sort((a, b) => b[1].length - a[1].length).slice(0, 5);\n  parts.push(\"\\n--- Top directories ---\");\n  topDirs.forEach(([dir, dirFiles]) => {\n    const shortDir = dir.split(\"/\").slice(-3).join(\"/\");\n    parts.push(`${shortDir}/ (${dirFiles.length} files)`);\n  });\n  parts.push(\"\\n--- Sample files ---\");\n  parts.push(files.slice(0, 15).map((f) => f.split(\"/\").pop()).join(\", \"));\n  return parts.join(\"\");\n}\nfunction compressEditOutput(toolInput, output) {\n  const filePath = toolInput?.file_path || \"unknown\";\n  const fileName = filePath.split(\"/\").pop() || \"file\";\n  return [\n    `\\u270F\\uFE0F Edited: ${fileName}`,\n    `\\u{1F4DD} Changes applied successfully`,\n    output.slice(0, 500)\n  ].join(\"\\n\");\n}\nfunction compressGeneric(output) {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 30) {\n    return output;\n  }\n  return [\n    `\\u{1F4CA} Output: ${lines.length} lines`,\n    \"--- First 15 lines ---\",\n    ...lines.slice(0, 15),\n    \"--- Last 10 lines ---\",\n    ...lines.slice(-10)\n  ].join(\"\\n\");\n}\nfunction extractImports(code) {\n  const imports = [];\n  const patterns = [\n    /import\\s+(?:{\\s*([^}]+)\\s*}|(\\w+))\\s+from\\s+['\"]([^'\"]+)['\"]/g,\n    /from\\s+['\"]([^'\"]+)['\"]\\s+import/g,\n    /require\\s*\\(['\"]([^'\"]+)['\"]\\)/g,\n    /use\\s+(\\w+(?:::\\w+)*)/g\n  ];\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      imports.push(match[3] || match[1] || match[2] || match[0]);\n    }\n  });\n  return [...new Set(imports)];\n}\nfunction extractExports(code) {\n  const exports$1 = [];\n  const patterns = [\n    /export\\s+(?:default\\s+)?(?:function|class|const|let|var)\\s+(\\w+)/g,\n    /export\\s*{\\s*([^}]+)\\s*}/g,\n    /pub\\s+(?:fn|struct|enum|trait|mod)\\s+(\\w+)/g\n  ];\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      const names = (match[1] || \"\").split(\",\").map((s) => s.trim());\n      exports$1.push(...names.filter(Boolean));\n    }\n  });\n  return [...new Set(exports$1)];\n}\nfunction extractFunctionSignatures(code) {\n  const functions = [];\n  const patterns = [\n    /(?:async\\s+)?function\\s+(\\w+)/g,\n    /(\\w+)\\s*:\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>/g,\n    /(?:const|let)\\s+(\\w+)\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>/g,\n    /fn\\s+(\\w+)/g,\n    /def\\s+(\\w+)/g\n  ];\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      functions.push(match[1]);\n    }\n  });\n  return [...new Set(functions)];\n}\nfunction extractClassNames(code) {\n  const classes = [];\n  const patterns = [\n    /class\\s+(\\w+)/g,\n    /struct\\s+(\\w+)/g,\n    /interface\\s+(\\w+)/g,\n    /type\\s+(\\w+)\\s*=/g\n  ];\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      classes.push(match[1]);\n    }\n  });\n  return [...new Set(classes)];\n}\nfunction extractErrorPatterns(code) {\n  const errors = [];\n  const lines = code.split(\"\\n\");\n  lines.forEach((line) => {\n    if (line.includes(\"TODO\") || line.includes(\"FIXME\") || line.includes(\"HACK\") || line.includes(\"XXX\") || line.includes(\"BUG\")) {\n      errors.push(line.trim().slice(0, 100));\n    }\n  });\n  return errors.slice(0, 10);\n}\nfunction truncateToTarget(text) {\n  if (text.length <= TARGET_COMPRESSED_SIZE) {\n    return text;\n  }\n  return text.slice(0, TARGET_COMPRESSED_SIZE - 20) + \"\\n... (compressed)\";\n}\nfunction getCompressionStats(originalSize, compressedSize) {\n  const saved = originalSize - compressedSize;\n  const ratio = originalSize / compressedSize;\n  const savedPercent = (saved / originalSize * 100).toFixed(1);\n  return { ratio, saved, savedPercent };\n}\n\n// src/hooks/post-tool-use.ts\nvar OBSERVED_TOOLS = /* @__PURE__ */ new Set([\n  \"Read\",\n  \"Edit\",\n  \"Write\",\n  \"Update\",\n  // Claude Code may use Update for edits\n  \"Bash\",\n  \"Grep\",\n  \"Glob\",\n  \"WebFetch\",\n  \"WebSearch\",\n  \"Task\",\n  \"NotebookEdit\"\n]);\nvar MIN_OUTPUT_LENGTH = 50;\nvar recentObservations = /* @__PURE__ */ new Map();\nvar DEDUP_WINDOW_MS = 6e4;\nfunction getObservationKey(toolName, toolInput) {\n  const inputStr = toolInput ? JSON.stringify(toolInput).slice(0, 200) : \"\";\n  return `${toolName}:${inputStr}`;\n}\nfunction isDuplicate(key) {\n  const lastSeen = recentObservations.get(key);\n  if (!lastSeen) return false;\n  return Date.now() - lastSeen < DEDUP_WINDOW_MS;\n}\nfunction markObserved(key) {\n  recentObservations.set(key, Date.now());\n  if (recentObservations.size > 100) {\n    const now = Date.now();\n    for (const [k, v] of recentObservations.entries()) {\n      if (now - v > DEDUP_WINDOW_MS * 2) {\n        recentObservations.delete(k);\n      }\n    }\n  }\n}\nvar ALWAYS_CAPTURE_TOOLS = /* @__PURE__ */ new Set([\"Edit\", \"Write\", \"Update\", \"NotebookEdit\"]);\nvar MAX_OUTPUT_LENGTH = 2500;\nasync function main() {\n  try {\n    const input = await readStdin();\n    const hookInput = JSON.parse(input);\n    const { tool_name, tool_input, tool_response } = hookInput;\n    debug(`Tool received: ${tool_name}`);\n    if (!tool_name || !OBSERVED_TOOLS.has(tool_name)) {\n      debug(`Skipping tool: ${tool_name} (not in OBSERVED_TOOLS)`);\n      writeOutput({ continue: true });\n      return;\n    }\n    const dedupKey = getObservationKey(tool_name, tool_input);\n    if (isDuplicate(dedupKey)) {\n      debug(`Skipping duplicate observation: ${tool_name}`);\n      writeOutput({ continue: true });\n      return;\n    }\n    const tool_output = typeof tool_response === \"string\" ? tool_response : JSON.stringify(tool_response, null, 2);\n    const alwaysCapture = ALWAYS_CAPTURE_TOOLS.has(tool_name);\n    if (!alwaysCapture && (!tool_output || tool_output.length < MIN_OUTPUT_LENGTH)) {\n      writeOutput({ continue: true });\n      return;\n    }\n    let effectiveOutput = tool_output || \"\";\n    if (alwaysCapture && effectiveOutput.length < MIN_OUTPUT_LENGTH) {\n      const filePath = tool_input?.file_path || \"unknown file\";\n      const fileName = filePath.split(\"/\").pop() || \"file\";\n      effectiveOutput = `File modified: ${fileName}\nPath: ${filePath}\nTool: ${tool_name}`;\n    }\n    if (effectiveOutput.includes(\"<system-reminder>\") || effectiveOutput.includes(\"<memvid-mind-context>\")) {\n      writeOutput({ continue: true });\n      return;\n    }\n    const { compressed, wasCompressed, originalSize } = compressToolOutput(\n      tool_name,\n      tool_input,\n      effectiveOutput\n    );\n    if (wasCompressed) {\n      const stats = getCompressionStats(originalSize, compressed.length);\n      debug(`\\u{1F5DC}\\uFE0F Endless Mode: ${stats.savedPercent}% compression (${originalSize} \\u2192 ${compressed.length} chars)`);\n    }\n    debug(`Capturing observation from ${tool_name}`);\n    const mind = await getMind();\n    const observationType = classifyObservationType(tool_name, compressed);\n    const summary = generateSummary(tool_name, tool_input, effectiveOutput);\n    const content = compressed.length > MAX_OUTPUT_LENGTH ? compressed.slice(0, MAX_OUTPUT_LENGTH) + \"\\n... (compressed)\" : compressed;\n    const metadata = extractMetadata(tool_name, tool_input);\n    if (wasCompressed) {\n      metadata.compressed = true;\n      metadata.originalSize = originalSize;\n      metadata.compressedSize = compressed.length;\n    }\n    await mind.remember({\n      type: observationType,\n      summary,\n      content,\n      tool: tool_name,\n      metadata\n    });\n    markObserved(dedupKey);\n    debug(`Stored: [${observationType}] ${summary}${wasCompressed ? \" (compressed)\" : \"\"}`);\n    writeOutput({ continue: true });\n  } catch (error) {\n    debug(`Error: ${error}`);\n    writeOutput({ continue: true });\n  }\n}\nfunction generateSummary(toolName, toolInput, toolOutput) {\n  switch (toolName) {\n    case \"Read\": {\n      const path = toolInput?.file_path;\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      const lines = toolOutput.split(\"\\n\").length;\n      return `Read ${fileName} (${lines} lines)`;\n    }\n    case \"Edit\": {\n      const path = toolInput?.file_path;\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      return `Edited ${fileName}`;\n    }\n    case \"Write\": {\n      const path = toolInput?.file_path;\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      return `Created ${fileName}`;\n    }\n    case \"Bash\": {\n      const cmd = toolInput?.command;\n      const shortCmd = cmd?.split(\"\\n\")[0].slice(0, 50) || \"command\";\n      const hasError = toolOutput.toLowerCase().includes(\"error\") || toolOutput.toLowerCase().includes(\"failed\");\n      return hasError ? `Command failed: ${shortCmd}` : `Ran: ${shortCmd}`;\n    }\n    case \"Grep\": {\n      const pattern = toolInput?.pattern;\n      const matches = toolOutput.split(\"\\n\").filter(Boolean).length;\n      return `Found ${matches} matches for \"${pattern?.slice(0, 30)}\"`;\n    }\n    case \"Glob\": {\n      const pattern = toolInput?.pattern;\n      const matches = toolOutput.split(\"\\n\").filter(Boolean).length;\n      return `Found ${matches} files matching \"${pattern?.slice(0, 30)}\"`;\n    }\n    case \"WebFetch\":\n    case \"WebSearch\": {\n      const url = toolInput?.url || toolInput?.query;\n      return `Fetched: ${url?.slice(0, 50)}`;\n    }\n    default:\n      return `${toolName} completed`;\n  }\n}\nfunction extractMetadata(toolName, toolInput) {\n  const metadata = {};\n  if (!toolInput) return metadata;\n  switch (toolName) {\n    case \"Read\":\n    case \"Edit\":\n    case \"Write\":\n      if (toolInput.file_path) {\n        metadata.files = [toolInput.file_path];\n      }\n      break;\n    case \"Bash\":\n      if (toolInput.command) {\n        metadata.command = toolInput.command.slice(0, 200);\n      }\n      break;\n    case \"Grep\":\n    case \"Glob\":\n      if (toolInput.pattern) {\n        metadata.pattern = toolInput.pattern;\n      }\n      if (toolInput.path) {\n        metadata.searchPath = toolInput.path;\n      }\n      break;\n  }\n  return metadata;\n}\nmain();\n//# sourceMappingURL=post-tool-use.js.map\n//# sourceMappingURL=post-tool-use.js.map",
        "dist/hooks/post-tool-use.js.map": "{\"version\":3,\"sources\":[\"../../src/types.ts\",\"../../src/utils/helpers.ts\",\"../../src/utils/memvid-lock.ts\",\"../../src/core/mind.ts\",\"../../src/utils/compression.ts\",\"../../src/hooks/post-tool-use.ts\"],\"names\":[\"resolve\",\"dirname\",\"mkdir\",\"unlinkSync\",\"recentObservations\",\"exports\"],\"mappings\":\"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\",\"file\":\"post-tool-use.js\",\"sourcesContent\":[\"/**\\n * Memvid Mind - Type Definitions\\n *\\n * Core types for Claude Code memory persistence.\\n */\\n\\n/** Observation captured from tool use */\\nexport interface Observation {\\n  id: string;\\n  timestamp: number;\\n  type: ObservationType;\\n  tool?: string;\\n  summary: string;\\n  content: string;\\n  metadata?: ObservationMetadata;\\n}\\n\\n/** Types of observations */\\nexport type ObservationType =\\n  | \\\"discovery\\\"      // New information discovered\\n  | \\\"decision\\\"       // Decision made\\n  | \\\"problem\\\"        // Problem identified\\n  | \\\"solution\\\"       // Solution implemented\\n  | \\\"pattern\\\"        // Pattern recognized\\n  | \\\"warning\\\"        // Warning or concern\\n  | \\\"success\\\"        // Successful outcome\\n  | \\\"refactor\\\"       // Code refactored\\n  | \\\"bugfix\\\"         // Bug fixed\\n  | \\\"feature\\\";       // Feature added\\n\\n/** Metadata attached to observations */\\nexport interface ObservationMetadata {\\n  files?: string[];\\n  functions?: string[];\\n  error?: string;\\n  confidence?: number;\\n  tags?: string[];\\n  sessionId?: string;\\n  [key: string]: unknown;  // Allow additional properties\\n}\\n\\n/** Session summary stored at end of session */\\nexport interface SessionSummary {\\n  id: string;\\n  startTime: number;\\n  endTime: number;\\n  observationCount: number;\\n  keyDecisions: string[];\\n  filesModified: string[];\\n  summary: string;\\n}\\n\\n/** Context injected at session start */\\nexport interface InjectedContext {\\n  recentObservations: Observation[];\\n  relevantMemories: Observation[];\\n  sessionSummaries: SessionSummary[];\\n  tokenCount: number;\\n}\\n\\n/** Configuration for Memvid Mind */\\nexport interface MindConfig {\\n  /** Path to the .memvid file (default: .mind.mv2 in project root) */\\n  memoryPath: string;\\n  /** Maximum observations to inject at session start */\\n  maxContextObservations: number;\\n  /** Maximum tokens for context injection */\\n  maxContextTokens: number;\\n  /** Whether to auto-compress observations */\\n  autoCompress: boolean;\\n  /** Minimum confidence for storing observations */\\n  minConfidence: number;\\n  /** Enable debug logging */\\n  debug: boolean;\\n}\\n\\n/** Default configuration */\\nexport const DEFAULT_CONFIG: MindConfig = {\\n  memoryPath: \\\".claude/mind.mv2\\\",\\n  maxContextObservations: 20,\\n  maxContextTokens: 2000,\\n  autoCompress: true,\\n  minConfidence: 0.6,\\n  debug: false,\\n};\\n\\n/** Hook input from Claude Code */\\nexport interface HookInput {\\n  session_id: string;\\n  transcript_path?: string;\\n  cwd?: string;\\n  hook_event_name?: string;\\n  permission_mode?: string;\\n  tool_name?: string;\\n  tool_input?: Record<string, unknown>;\\n  tool_response?: unknown; // Can be object or string depending on tool\\n  tool_use_id?: string;\\n}\\n\\n/** Hook output to Claude Code */\\nexport interface HookOutput {\\n  continue?: boolean;\\n  result?: string;\\n  decision?: \\\"block\\\" | \\\"approve\\\" | \\\"modify\\\";\\n  reason?: string;\\n  modified_input?: Record<string, unknown>;\\n}\\n\\n/** Search result from memory */\\nexport interface MemorySearchResult {\\n  observation: Observation;\\n  score: number;\\n  snippet: string;\\n}\\n\\n/** Statistics about the mind file */\\nexport interface MindStats {\\n  totalObservations: number;\\n  totalSessions: number;\\n  oldestMemory: number;\\n  newestMemory: number;\\n  fileSize: number;\\n  topTypes: Record<ObservationType, number>;\\n}\\n\",\"/**\\n * Memvid Mind - Utility Helpers\\n */\\n\\nimport { randomBytes } from \\\"node:crypto\\\";\\n\\n/**\\n * Generate a unique ID\\n */\\nexport function generateId(): string {\\n  return randomBytes(8).toString(\\\"hex\\\");\\n}\\n\\n/**\\n * Estimate token count for text (rough approximation)\\n * ~4 characters per token for English text\\n */\\nexport function estimateTokens(text: string): number {\\n  return Math.ceil(text.length / 4);\\n}\\n\\n/**\\n * Truncate text to fit within token limit\\n */\\nexport function truncateToTokens(text: string, maxTokens: number): string {\\n  const maxChars = maxTokens * 4;\\n  if (text.length <= maxChars) return text;\\n  return text.slice(0, maxChars - 3) + \\\"...\\\";\\n}\\n\\n/**\\n * Format timestamp to human-readable string\\n */\\nexport function formatTimestamp(ts: number): string {\\n  const date = new Date(ts);\\n  const now = new Date();\\n  const diffMs = now.getTime() - date.getTime();\\n  const diffMins = Math.floor(diffMs / 60000);\\n  const diffHours = Math.floor(diffMs / 3600000);\\n  const diffDays = Math.floor(diffMs / 86400000);\\n\\n  if (diffMins < 1) return \\\"just now\\\";\\n  if (diffMins < 60) return `${diffMins}m ago`;\\n  if (diffHours < 24) return `${diffHours}h ago`;\\n  if (diffDays < 7) return `${diffDays}d ago`;\\n\\n  return date.toLocaleDateString();\\n}\\n\\n/**\\n * Parse JSON safely\\n */\\nexport function safeJsonParse<T>(text: string, fallback: T): T {\\n  try {\\n    return JSON.parse(text) as T;\\n  } catch {\\n    return fallback;\\n  }\\n}\\n\\n/**\\n * Read all stdin as string\\n */\\nexport async function readStdin(): Promise<string> {\\n  const chunks: Buffer[] = [];\\n\\n  return new Promise((resolve, reject) => {\\n    process.stdin.on(\\\"data\\\", (chunk) => chunks.push(chunk));\\n    process.stdin.on(\\\"end\\\", () => resolve(Buffer.concat(chunks).toString(\\\"utf8\\\")));\\n    process.stdin.on(\\\"error\\\", reject);\\n  });\\n}\\n\\n/**\\n * Write JSON to stdout and exit immediately\\n * (Prevents SDK background tasks from blocking process exit)\\n */\\nexport function writeOutput(output: unknown): never {\\n  console.log(JSON.stringify(output));\\n  process.exit(0);\\n}\\n\\n/**\\n * Log debug message to stderr\\n */\\nexport function debug(message: string): void {\\n  if (process.env.MEMVID_MIND_DEBUG === \\\"1\\\") {\\n    console.error(`[memvid-mind] ${message}`);\\n  }\\n}\\n\\n/**\\n * Extract key information from tool output\\n */\\nexport function extractKeyInfo(toolName: string, output: string): string {\\n  // Truncate very long outputs\\n  const maxLength = 2000;\\n  const truncated = output.length > maxLength\\n    ? output.slice(0, maxLength) + \\\"\\\\n... (truncated)\\\"\\n    : output;\\n\\n  // Tool-specific extraction\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n      // Extract file summary from read output\\n      return extractFileReadSummary(truncated);\\n    case \\\"Bash\\\":\\n      // Extract command summary\\n      return extractBashSummary(truncated);\\n    case \\\"Edit\\\":\\n      // Extract edit summary\\n      return extractEditSummary(truncated);\\n    case \\\"Grep\\\":\\n    case \\\"Glob\\\":\\n      // Extract search summary\\n      return extractSearchSummary(truncated);\\n    default:\\n      return truncated;\\n  }\\n}\\n\\nfunction extractFileReadSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 20) return output;\\n  return `${lines.slice(0, 10).join(\\\"\\\\n\\\")}\\\\n... (${lines.length} lines total)`;\\n}\\n\\nfunction extractBashSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 30) return output;\\n  return [\\n    ...lines.slice(0, 10),\\n    `... (${lines.length - 20} lines omitted)`,\\n    ...lines.slice(-10),\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\nfunction extractEditSummary(output: string): string {\\n  // Edits are usually compact, return as-is\\n  return output;\\n}\\n\\nfunction extractSearchSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\").filter(Boolean);\\n  if (lines.length <= 20) return output;\\n  return [\\n    ...lines.slice(0, 15),\\n    `... and ${lines.length - 15} more results`,\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\n/**\\n * Classify observation type from tool and output\\n */\\nexport function classifyObservationType(\\n  toolName: string,\\n  output: string\\n): \\\"discovery\\\" | \\\"decision\\\" | \\\"problem\\\" | \\\"solution\\\" | \\\"pattern\\\" | \\\"warning\\\" | \\\"success\\\" | \\\"refactor\\\" | \\\"bugfix\\\" | \\\"feature\\\" {\\n  const lowerOutput = output.toLowerCase();\\n\\n  // Error detection\\n  if (\\n    lowerOutput.includes(\\\"error\\\") ||\\n    lowerOutput.includes(\\\"failed\\\") ||\\n    lowerOutput.includes(\\\"exception\\\")\\n  ) {\\n    return \\\"problem\\\";\\n  }\\n\\n  // Success detection\\n  if (\\n    lowerOutput.includes(\\\"success\\\") ||\\n    lowerOutput.includes(\\\"passed\\\") ||\\n    lowerOutput.includes(\\\"completed\\\")\\n  ) {\\n    return \\\"success\\\";\\n  }\\n\\n  // Warning detection\\n  if (lowerOutput.includes(\\\"warning\\\") || lowerOutput.includes(\\\"deprecated\\\")) {\\n    return \\\"warning\\\";\\n  }\\n\\n  // Tool-based classification\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n    case \\\"Glob\\\":\\n    case \\\"Grep\\\":\\n      return \\\"discovery\\\";\\n    case \\\"Edit\\\":\\n      if (lowerOutput.includes(\\\"fix\\\") || lowerOutput.includes(\\\"bug\\\")) {\\n        return \\\"bugfix\\\";\\n      }\\n      return \\\"refactor\\\";\\n    case \\\"Write\\\":\\n      return \\\"feature\\\";\\n    default:\\n      return \\\"discovery\\\";\\n  }\\n}\\n\",\"import lockfile from \\\"proper-lockfile\\\";\\nimport { mkdir, open } from \\\"node:fs/promises\\\";\\nimport { dirname } from \\\"node:path\\\";\\n\\nconst LOCK_OPTIONS = {\\n  stale: 30000,\\n  retries: {\\n    retries: 1000,\\n    minTimeout: 5,\\n    maxTimeout: 50,\\n  },\\n} as const;\\n\\nexport async function withMemvidLock<T>(\\n  lockPath: string,\\n  fn: () => Promise<T>\\n): Promise<T> {\\n  await mkdir(dirname(lockPath), { recursive: true });\\n  const handle = await open(lockPath, \\\"a\\\");\\n  await handle.close();\\n\\n  const release = await lockfile.lock(lockPath, LOCK_OPTIONS);\\n  try {\\n    return await fn();\\n  } finally {\\n    await release();\\n  }\\n}\\n\",\"/**\\n * Memvid Mind - Core Engine\\n *\\n * The brain behind Claude's persistent memory.\\n * Stores everything in ONE portable .memvid file.\\n */\\n\\n// Use dynamic import to allow smart-install to run first\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\ntype Memvid = any;\\n\\nimport { existsSync, readdirSync, unlinkSync } from \\\"node:fs\\\";\\nimport { resolve, dirname } from \\\"node:path\\\";\\nimport { mkdir } from \\\"node:fs/promises\\\";\\nimport {\\n  type Observation,\\n  type ObservationType,\\n  type SessionSummary,\\n  type InjectedContext,\\n  type MindConfig,\\n  type MindStats,\\n  type MemorySearchResult,\\n  DEFAULT_CONFIG,\\n} from \\\"../types.js\\\";\\nimport { generateId, estimateTokens } from \\\"../utils/helpers.js\\\";\\nimport { withMemvidLock } from \\\"../utils/memvid-lock.js\\\";\\n\\n/**\\n * Prune old backup files, keeping only the most recent N\\n */\\nfunction pruneBackups(memoryPath: string, keepCount: number): void {\\n  try {\\n    const dir = dirname(memoryPath);\\n    const baseName = memoryPath.split(\\\"/\\\").pop() || \\\"mind.mv2\\\";\\n    const backupPattern = new RegExp(`^${baseName.replace(\\\".\\\", \\\"\\\\\\\\.\\\")}\\\\\\\\.backup-\\\\\\\\d+$`);\\n\\n    const files = readdirSync(dir);\\n    const backups = files\\n      .filter(f => backupPattern.test(f))\\n      .map(f => ({\\n        name: f,\\n        path: resolve(dir, f),\\n        time: parseInt(f.split(\\\"-\\\").pop() || \\\"0\\\", 10),\\n      }))\\n      .sort((a, b) => b.time - a.time); // newest first\\n\\n    // Delete old backups beyond keepCount\\n    for (let i = keepCount; i < backups.length; i++) {\\n      try {\\n        unlinkSync(backups[i].path);\\n        console.error(`[memvid-mind] Pruned old backup: ${backups[i].name}`);\\n      } catch {\\n        // Ignore errors deleting backups\\n      }\\n    }\\n  } catch {\\n    // Ignore errors during pruning\\n  }\\n}\\n\\n// Lazy-loaded SDK functions\\nlet sdkLoaded = false;\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\nlet use: any;\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\nlet create: any;\\n\\nasync function loadSDK(): Promise<void> {\\n  if (sdkLoaded) return;\\n  const sdk = await import(\\\"@memvid/sdk\\\");\\n  use = sdk.use;\\n  create = sdk.create;\\n  sdkLoaded = true;\\n}\\n\\n/**\\n * Mind - Claude's portable memory engine\\n *\\n * @example\\n * ```typescript\\n * const mind = await Mind.open();\\n * await mind.remember({\\n *   type: \\\"decision\\\",\\n *   summary: \\\"Chose React over Vue for frontend\\\",\\n *   content: \\\"Decision rationale: team familiarity, ecosystem...\\\"\\n * });\\n *\\n * const context = await mind.getContext(\\\"authentication\\\");\\n * ```\\n */\\nexport class Mind {\\n  private memvid: Memvid;\\n  private config: MindConfig;\\n  private sessionId: string;\\n  private initialized = false;\\n\\n  private constructor(memvid: Memvid, config: MindConfig) {\\n    this.memvid = memvid;\\n    this.config = config;\\n    this.sessionId = generateId();\\n  }\\n\\n  /**\\n   * Open or create a Mind instance\\n   */\\n  static async open(configOverrides: Partial<MindConfig> = {}): Promise<Mind> {\\n    // Load SDK dynamically (allows smart-install to run first)\\n    await loadSDK();\\n\\n    const config = { ...DEFAULT_CONFIG, ...configOverrides };\\n\\n    // Resolve path relative to project dir (use CLAUDE_PROJECT_DIR if available)\\n    const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\\n    const memoryPath = resolve(projectDir, config.memoryPath);\\n    const memoryDir = dirname(memoryPath);\\n\\n    // Ensure directory exists\\n    await mkdir(memoryDir, { recursive: true });\\n\\n    // Open or create the memvid file\\n    let memvid: Memvid;\\n    const MAX_FILE_SIZE_MB = 100; // Files over 100MB are likely corrupted\\n    const lockPath = `${memoryPath}.lock`;\\n\\n    await withMemvidLock(lockPath, async () => {\\n      if (!existsSync(memoryPath)) {\\n        memvid = await create(memoryPath, \\\"basic\\\");\\n        return;\\n      }\\n\\n      // Check file size - very large files are likely corrupted and will hang\\n      const { statSync, renameSync, unlinkSync } = await import(\\\"node:fs\\\");\\n      const fileSize = statSync(memoryPath).size;\\n      const fileSizeMB = fileSize / (1024 * 1024);\\n\\n      if (fileSizeMB > MAX_FILE_SIZE_MB) {\\n        console.error(`[memvid-mind] Memory file too large (${fileSizeMB.toFixed(1)}MB), likely corrupted. Creating fresh memory...`);\\n        const backupPath = `${memoryPath}.backup-${Date.now()}`;\\n        try { renameSync(memoryPath, backupPath); } catch { /* ignore */ }\\n        memvid = await create(memoryPath, \\\"basic\\\");\\n        return;\\n      }\\n\\n      try {\\n        memvid = await use(\\\"basic\\\", memoryPath);\\n      } catch (openError: unknown) {\\n        const errorMessage = openError instanceof Error ? openError.message : String(openError);\\n        // Handle corrupted or incompatible memory files\\n        if (errorMessage.includes(\\\"Deserialization\\\") ||\\n            errorMessage.includes(\\\"UnexpectedVariant\\\") ||\\n            errorMessage.includes(\\\"Invalid\\\") ||\\n            errorMessage.includes(\\\"corrupt\\\") ||\\n            errorMessage.includes(\\\"validation failed\\\") ||\\n            errorMessage.includes(\\\"unable to recover\\\") ||\\n            errorMessage.includes(\\\"table of contents\\\")) {\\n          console.error(\\\"[memvid-mind] Memory file corrupted, creating fresh memory...\\\");\\n          const backupPath = `${memoryPath}.backup-${Date.now()}`;\\n          try {\\n            renameSync(memoryPath, backupPath);\\n          } catch {\\n            try { unlinkSync(memoryPath); } catch { /* ignore */ }\\n          }\\n          memvid = await create(memoryPath, \\\"basic\\\");\\n          return;\\n        }\\n        throw openError;\\n      }\\n    });\\n\\n    const mind = new Mind(memvid, config);\\n    mind.initialized = true;\\n\\n    // Prune old backups (keep only most recent 3)\\n    pruneBackups(memoryPath, 3);\\n\\n    if (config.debug) {\\n      console.error(`[memvid-mind] Opened: ${memoryPath}`);\\n    }\\n\\n    return mind;\\n  }\\n\\n  private async withLock<T>(fn: () => Promise<T>): Promise<T> {\\n    const memoryPath = this.getMemoryPath();\\n    const lockPath = `${memoryPath}.lock`;\\n    return withMemvidLock(lockPath, fn);\\n  }\\n\\n  /**\\n   * Remember an observation\\n   */\\n  async remember(input: {\\n    type: ObservationType;\\n    summary: string;\\n    content: string;\\n    tool?: string;\\n    metadata?: Record<string, unknown>;\\n  }): Promise<string> {\\n    const observation: Observation = {\\n      id: generateId(),\\n      timestamp: Date.now(),\\n      type: input.type,\\n      tool: input.tool,\\n      summary: input.summary,\\n      content: input.content,\\n      metadata: {\\n        ...input.metadata,\\n        sessionId: this.sessionId,\\n      },\\n    };\\n\\n    const frameId = await this.withLock(async () => {\\n      return this.memvid.put({\\n        title: `[${observation.type}] ${observation.summary}`,\\n        label: observation.type,\\n        text: observation.content,\\n        metadata: {\\n          observationId: observation.id,\\n          timestamp: observation.timestamp,\\n          tool: observation.tool,\\n          sessionId: this.sessionId,\\n          ...observation.metadata,\\n        },\\n        tags: [observation.type, observation.tool].filter(Boolean) as string[],\\n      });\\n    });\\n\\n    if (this.config.debug) {\\n      console.error(`[memvid-mind] Remembered: ${observation.summary}`);\\n    }\\n\\n    return frameId;\\n  }\\n\\n  /**\\n   * Search memories by query (uses fast lexical search)\\n   */\\n  async search(query: string, limit = 10): Promise<MemorySearchResult[]> {\\n    return this.withLock(async () => {\\n      return this.searchUnlocked(query, limit);\\n    });\\n  }\\n\\n  private async searchUnlocked(query: string, limit: number): Promise<MemorySearchResult[]> {\\n    const results = await this.memvid.find(query, { k: limit, mode: \\\"lex\\\" });\\n\\n    return (results.frames || []).map((frame: any) => ({\\n      observation: {\\n        id: frame.metadata?.observationId || frame.frame_id,\\n        timestamp: frame.metadata?.timestamp || 0,\\n        type: frame.label as ObservationType,\\n        tool: frame.metadata?.tool,\\n        summary: frame.title?.replace(/^\\\\[.*?\\\\]\\\\s*/, \\\"\\\") || \\\"\\\",\\n        content: frame.text || \\\"\\\",\\n        metadata: frame.metadata,\\n      },\\n      score: frame.score || 0,\\n      snippet: frame.snippet || frame.text?.slice(0, 200) || \\\"\\\",\\n    }));\\n  }\\n\\n  /**\\n   * Ask the memory a question (uses fast lexical search)\\n   */\\n  async ask(question: string): Promise<string> {\\n    return this.withLock(async () => {\\n      const result = await this.memvid.ask(question, { k: 5, mode: \\\"lex\\\" });\\n      return result.answer || \\\"No relevant memories found.\\\";\\n    });\\n  }\\n\\n  /**\\n   * Get context for session start\\n   */\\n  async getContext(query?: string): Promise<InjectedContext> {\\n    return this.withLock(async () => {\\n      // Get recent observations via timeline\\n      const timeline = await this.memvid.timeline({\\n        limit: this.config.maxContextObservations,\\n        reverse: true,\\n      });\\n\\n      // SDK returns array directly or { frames: [...] }\\n      const frames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\\n\\n      const recentObservations: Observation[] = frames.map(\\n        (frame: any) => {\\n          // Get timestamp - SDK returns seconds, convert to milliseconds if needed\\n          let ts = frame.metadata?.timestamp || frame.timestamp || 0;\\n          // If timestamp looks like seconds (before year 2100 in seconds), convert to ms\\n          if (ts > 0 && ts < 4102444800) {\\n            ts = ts * 1000;\\n          }\\n          return {\\n            id: frame.metadata?.observationId || frame.frame_id,\\n            timestamp: ts,\\n            type: (frame.label || frame.metadata?.type || \\\"observation\\\") as ObservationType,\\n            tool: frame.metadata?.tool,\\n            summary: frame.title?.replace(/^\\\\[.*?\\\\]\\\\s*/, \\\"\\\") || frame.preview?.slice(0, 100) || \\\"\\\",\\n            content: frame.text || frame.preview || \\\"\\\",\\n            metadata: frame.metadata,\\n          };\\n        }\\n      );\\n\\n      // Get relevant memories if query provided\\n      let relevantMemories: Observation[] = [];\\n      if (query) {\\n        const searchResults = await this.searchUnlocked(query, 10);\\n        relevantMemories = searchResults.map((r) => r.observation);\\n      }\\n\\n      // Build context with token limit\\n      const contextParts: string[] = [];\\n      let tokenCount = 0;\\n\\n      // Add recent observations\\n      for (const obs of recentObservations) {\\n        const text = `[${obs.type}] ${obs.summary}`;\\n        const tokens = estimateTokens(text);\\n        if (tokenCount + tokens > this.config.maxContextTokens) break;\\n        contextParts.push(text);\\n        tokenCount += tokens;\\n      }\\n\\n      return {\\n        recentObservations,\\n        relevantMemories,\\n        sessionSummaries: [], // TODO: Implement session summaries\\n        tokenCount,\\n      };\\n    });\\n  }\\n\\n  /**\\n   * Save a session summary\\n   */\\n  async saveSessionSummary(summary: {\\n    keyDecisions: string[];\\n    filesModified: string[];\\n    summary: string;\\n  }): Promise<string> {\\n    const sessionSummary: SessionSummary = {\\n      id: this.sessionId,\\n      startTime: Date.now() - 3600000, // Approximate\\n      endTime: Date.now(),\\n      observationCount: 0, // TODO: Track this\\n      keyDecisions: summary.keyDecisions,\\n      filesModified: summary.filesModified,\\n      summary: summary.summary,\\n    };\\n\\n    return this.withLock(async () => {\\n      return this.memvid.put({\\n        title: `Session Summary: ${new Date().toISOString().split(\\\"T\\\")[0]}`,\\n        label: \\\"session\\\",\\n        text: JSON.stringify(sessionSummary, null, 2),\\n        metadata: sessionSummary as unknown as Record<string, unknown>,\\n        tags: [\\\"session\\\", \\\"summary\\\"],\\n      });\\n    });\\n  }\\n\\n  /**\\n   * Get memory statistics\\n   */\\n  async stats(): Promise<MindStats> {\\n    return this.withLock(async () => {\\n      const stats = await this.memvid.stats();\\n      const timeline = await this.memvid.timeline({ limit: 1, reverse: false });\\n      const recentTimeline = await this.memvid.timeline({ limit: 1, reverse: true });\\n\\n      // SDK returns array directly or { frames: [...] }\\n      const oldestFrames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\\n      const newestFrames = Array.isArray(recentTimeline) ? recentTimeline : (recentTimeline.frames || []);\\n\\n      return {\\n        totalObservations: (stats.frame_count as number) || 0,\\n        totalSessions: 0, // TODO: Count unique sessions\\n        oldestMemory: (oldestFrames[0] as any)?.metadata?.timestamp || (oldestFrames[0] as any)?.timestamp || 0,\\n        newestMemory: (newestFrames[0] as any)?.metadata?.timestamp || (newestFrames[0] as any)?.timestamp || 0,\\n        fileSize: (stats.size_bytes as number) || 0,\\n        topTypes: {} as Record<ObservationType, number>, // TODO: Aggregate\\n      };\\n    });\\n  }\\n\\n  /**\\n   * Get the session ID\\n   */\\n  getSessionId(): string {\\n    return this.sessionId;\\n  }\\n\\n  /**\\n   * Get the memory file path\\n   */\\n  getMemoryPath(): string {\\n    return resolve(process.cwd(), this.config.memoryPath);\\n  }\\n\\n  /**\\n   * Check if initialized\\n   */\\n  isInitialized(): boolean {\\n    return this.initialized;\\n  }\\n}\\n\\n// Singleton instance for hooks\\nlet mindInstance: Mind | null = null;\\n\\n/**\\n * Get or create the Mind singleton\\n */\\nexport async function getMind(config?: Partial<MindConfig>): Promise<Mind> {\\n  if (!mindInstance) {\\n    mindInstance = await Mind.open(config);\\n  }\\n  return mindInstance;\\n}\\n\\n/**\\n * Reset the Mind singleton (for testing)\\n */\\nexport function resetMind(): void {\\n  mindInstance = null;\\n}\\n\",\"/**\\n * Memvid Mind - Endless Mode Compression\\n *\\n * Compresses large tool outputs to ~500 tokens while preserving key information.\\n * This enables 20x more tool uses before hitting context limits.\\n */\\n\\n// Target compressed size in characters (~500 tokens ≈ 2000 chars)\\nconst TARGET_COMPRESSED_SIZE = 2000;\\n\\n// Threshold for when to apply compression\\nconst COMPRESSION_THRESHOLD = 3000;\\n\\n/**\\n * Compress tool output while preserving key information\\n */\\nexport function compressToolOutput(\\n  toolName: string,\\n  toolInput: Record<string, unknown> | undefined,\\n  output: string\\n): { compressed: string; wasCompressed: boolean; originalSize: number } {\\n  const originalSize = output.length;\\n\\n  // Don't compress small outputs\\n  if (originalSize <= COMPRESSION_THRESHOLD) {\\n    return { compressed: output, wasCompressed: false, originalSize };\\n  }\\n\\n  let compressed: string;\\n\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n      compressed = compressFileRead(toolInput, output);\\n      break;\\n    case \\\"Bash\\\":\\n      compressed = compressBashOutput(toolInput, output);\\n      break;\\n    case \\\"Grep\\\":\\n      compressed = compressGrepOutput(toolInput, output);\\n      break;\\n    case \\\"Glob\\\":\\n      compressed = compressGlobOutput(toolInput, output);\\n      break;\\n    case \\\"Edit\\\":\\n    case \\\"Write\\\":\\n      compressed = compressEditOutput(toolInput, output);\\n      break;\\n    default:\\n      compressed = compressGeneric(output);\\n  }\\n\\n  return {\\n    compressed: truncateToTarget(compressed),\\n    wasCompressed: true,\\n    originalSize,\\n  };\\n}\\n\\n/**\\n * Compress file read output - extract structure and key patterns\\n */\\nfunction compressFileRead(\\n  toolInput: Record<string, unknown> | undefined,\\n  output: string\\n): string {\\n  const filePath = (toolInput?.file_path as string) || \\\"unknown\\\";\\n  const fileName = filePath.split(\\\"/\\\").pop() || \\\"file\\\";\\n  const lines = output.split(\\\"\\\\n\\\");\\n  const totalLines = lines.length;\\n\\n  // Extract key information\\n  const imports = extractImports(output);\\n  const exports = extractExports(output);\\n  const functions = extractFunctionSignatures(output);\\n  const classes = extractClassNames(output);\\n  const errors = extractErrorPatterns(output);\\n\\n  const parts: string[] = [\\n    `📄 File: ${fileName} (${totalLines} lines)`,\\n  ];\\n\\n  if (imports.length > 0) {\\n    parts.push(`\\\\n📦 Imports: ${imports.slice(0, 10).join(\\\", \\\")}${imports.length > 10 ? ` (+${imports.length - 10} more)` : \\\"\\\"}`);\\n  }\\n\\n  if (exports.length > 0) {\\n    parts.push(`\\\\n📤 Exports: ${exports.slice(0, 10).join(\\\", \\\")}${exports.length > 10 ? ` (+${exports.length - 10} more)` : \\\"\\\"}`);\\n  }\\n\\n  if (functions.length > 0) {\\n    parts.push(`\\\\n⚡ Functions: ${functions.slice(0, 10).join(\\\", \\\")}${functions.length > 10 ? ` (+${functions.length - 10} more)` : \\\"\\\"}`);\\n  }\\n\\n  if (classes.length > 0) {\\n    parts.push(`\\\\n🏗️ Classes: ${classes.join(\\\", \\\")}`);\\n  }\\n\\n  if (errors.length > 0) {\\n    parts.push(`\\\\n⚠️ Errors/TODOs: ${errors.slice(0, 5).join(\\\"; \\\")}`);\\n  }\\n\\n  // Add first and last few lines for context\\n  const contextLines = [\\n    \\\"\\\\n--- First 10 lines ---\\\",\\n    ...lines.slice(0, 10),\\n    \\\"\\\\n--- Last 5 lines ---\\\",\\n    ...lines.slice(-5),\\n  ];\\n\\n  parts.push(contextLines.join(\\\"\\\\n\\\"));\\n\\n  return parts.join(\\\"\\\");\\n}\\n\\n/**\\n * Compress bash output - focus on errors and key results\\n */\\nfunction compressBashOutput(\\n  toolInput: Record<string, unknown> | undefined,\\n  output: string\\n): string {\\n  const command = (toolInput?.command as string) || \\\"command\\\";\\n  const shortCmd = command.split(\\\"\\\\n\\\")[0].slice(0, 100);\\n  const lines = output.split(\\\"\\\\n\\\");\\n\\n  // Check for errors\\n  const errorLines = lines.filter(\\n    (l) =>\\n      l.toLowerCase().includes(\\\"error\\\") ||\\n      l.toLowerCase().includes(\\\"failed\\\") ||\\n      l.toLowerCase().includes(\\\"exception\\\") ||\\n      l.toLowerCase().includes(\\\"warning\\\")\\n  );\\n\\n  // Check for success indicators\\n  const successLines = lines.filter(\\n    (l) =>\\n      l.toLowerCase().includes(\\\"success\\\") ||\\n      l.toLowerCase().includes(\\\"passed\\\") ||\\n      l.toLowerCase().includes(\\\"completed\\\") ||\\n      l.toLowerCase().includes(\\\"done\\\")\\n  );\\n\\n  const parts: string[] = [`🖥️ Command: ${shortCmd}`];\\n\\n  if (errorLines.length > 0) {\\n    parts.push(`\\\\n❌ Errors (${errorLines.length}):`);\\n    parts.push(errorLines.slice(0, 10).join(\\\"\\\\n\\\"));\\n  }\\n\\n  if (successLines.length > 0) {\\n    parts.push(`\\\\n✅ Success indicators:`);\\n    parts.push(successLines.slice(0, 5).join(\\\"\\\\n\\\"));\\n  }\\n\\n  // Add summary stats\\n  parts.push(`\\\\n📊 Output: ${lines.length} lines total`);\\n\\n  // Add first and last lines\\n  if (lines.length > 20) {\\n    parts.push(\\\"\\\\n--- First 10 lines ---\\\");\\n    parts.push(lines.slice(0, 10).join(\\\"\\\\n\\\"));\\n    parts.push(\\\"\\\\n--- Last 5 lines ---\\\");\\n    parts.push(lines.slice(-5).join(\\\"\\\\n\\\"));\\n  } else {\\n    parts.push(\\\"\\\\n--- Full output ---\\\");\\n    parts.push(lines.join(\\\"\\\\n\\\"));\\n  }\\n\\n  return parts.join(\\\"\\\");\\n}\\n\\n/**\\n * Compress grep output - summarize matches\\n */\\nfunction compressGrepOutput(\\n  toolInput: Record<string, unknown> | undefined,\\n  output: string\\n): string {\\n  const pattern = (toolInput?.pattern as string) || \\\"pattern\\\";\\n  const lines = output.split(\\\"\\\\n\\\").filter(Boolean);\\n\\n  // Extract unique files\\n  const files = new Set<string>();\\n  lines.forEach((line) => {\\n    const match = line.match(/^([^:]+):/);\\n    if (match) files.add(match[1]);\\n  });\\n\\n  const parts: string[] = [\\n    `🔍 Grep: \\\"${pattern.slice(0, 50)}\\\"`,\\n    `📁 Found in ${files.size} files, ${lines.length} matches`,\\n  ];\\n\\n  if (files.size > 0) {\\n    parts.push(`\\\\n📂 Files: ${Array.from(files).slice(0, 15).join(\\\", \\\")}${files.size > 15 ? ` (+${files.size - 15} more)` : \\\"\\\"}`);\\n  }\\n\\n  // Show first 10 matches\\n  parts.push(\\\"\\\\n--- Top matches ---\\\");\\n  parts.push(lines.slice(0, 10).join(\\\"\\\\n\\\"));\\n\\n  if (lines.length > 10) {\\n    parts.push(`\\\\n... and ${lines.length - 10} more matches`);\\n  }\\n\\n  return parts.join(\\\"\\\");\\n}\\n\\n/**\\n * Compress glob output - summarize file list\\n */\\nfunction compressGlobOutput(\\n  toolInput: Record<string, unknown> | undefined,\\n  output: string\\n): string {\\n  const pattern = (toolInput?.pattern as string) || \\\"pattern\\\";\\n\\n  // Try to parse as JSON (Glob returns JSON)\\n  let files: string[] = [];\\n  try {\\n    const parsed = JSON.parse(output);\\n    files = parsed.filenames || [];\\n  } catch {\\n    files = output.split(\\\"\\\\n\\\").filter(Boolean);\\n  }\\n\\n  // Group by directory\\n  const byDir: Record<string, string[]> = {};\\n  files.forEach((f) => {\\n    const dir = f.split(\\\"/\\\").slice(0, -1).join(\\\"/\\\") || \\\"/\\\";\\n    const file = f.split(\\\"/\\\").pop() || f;\\n    if (!byDir[dir]) byDir[dir] = [];\\n    byDir[dir].push(file);\\n  });\\n\\n  const parts: string[] = [\\n    `📂 Glob: \\\"${pattern.slice(0, 50)}\\\"`,\\n    `📁 Found ${files.length} files in ${Object.keys(byDir).length} directories`,\\n  ];\\n\\n  // Show top directories\\n  const topDirs = Object.entries(byDir)\\n    .sort((a, b) => b[1].length - a[1].length)\\n    .slice(0, 5);\\n\\n  parts.push(\\\"\\\\n--- Top directories ---\\\");\\n  topDirs.forEach(([dir, dirFiles]) => {\\n    const shortDir = dir.split(\\\"/\\\").slice(-3).join(\\\"/\\\");\\n    parts.push(`${shortDir}/ (${dirFiles.length} files)`);\\n  });\\n\\n  // Show some file names\\n  parts.push(\\\"\\\\n--- Sample files ---\\\");\\n  parts.push(files.slice(0, 15).map((f) => f.split(\\\"/\\\").pop()).join(\\\", \\\"));\\n\\n  return parts.join(\\\"\\\");\\n}\\n\\n/**\\n * Compress edit output\\n */\\nfunction compressEditOutput(\\n  toolInput: Record<string, unknown> | undefined,\\n  output: string\\n): string {\\n  const filePath = (toolInput?.file_path as string) || \\\"unknown\\\";\\n  const fileName = filePath.split(\\\"/\\\").pop() || \\\"file\\\";\\n\\n  return [\\n    `✏️ Edited: ${fileName}`,\\n    `📝 Changes applied successfully`,\\n    output.slice(0, 500),\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\n/**\\n * Generic compression for unknown tool types\\n */\\nfunction compressGeneric(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n\\n  if (lines.length <= 30) {\\n    return output;\\n  }\\n\\n  return [\\n    `📊 Output: ${lines.length} lines`,\\n    \\\"--- First 15 lines ---\\\",\\n    ...lines.slice(0, 15),\\n    \\\"--- Last 10 lines ---\\\",\\n    ...lines.slice(-10),\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\n/**\\n * Extract import statements\\n */\\nfunction extractImports(code: string): string[] {\\n  const imports: string[] = [];\\n  const patterns = [\\n    /import\\\\s+(?:{\\\\s*([^}]+)\\\\s*}|(\\\\w+))\\\\s+from\\\\s+['\\\"]([^'\\\"]+)['\\\"]/g,\\n    /from\\\\s+['\\\"]([^'\\\"]+)['\\\"]\\\\s+import/g,\\n    /require\\\\s*\\\\(['\\\"]([^'\\\"]+)['\\\"]\\\\)/g,\\n    /use\\\\s+(\\\\w+(?:::\\\\w+)*)/g,\\n  ];\\n\\n  patterns.forEach((pattern) => {\\n    let match;\\n    while ((match = pattern.exec(code)) !== null) {\\n      imports.push(match[3] || match[1] || match[2] || match[0]);\\n    }\\n  });\\n\\n  return [...new Set(imports)];\\n}\\n\\n/**\\n * Extract export statements\\n */\\nfunction extractExports(code: string): string[] {\\n  const exports: string[] = [];\\n  const patterns = [\\n    /export\\\\s+(?:default\\\\s+)?(?:function|class|const|let|var)\\\\s+(\\\\w+)/g,\\n    /export\\\\s*{\\\\s*([^}]+)\\\\s*}/g,\\n    /pub\\\\s+(?:fn|struct|enum|trait|mod)\\\\s+(\\\\w+)/g,\\n  ];\\n\\n  patterns.forEach((pattern) => {\\n    let match;\\n    while ((match = pattern.exec(code)) !== null) {\\n      const names = (match[1] || \\\"\\\").split(\\\",\\\").map((s) => s.trim());\\n      exports.push(...names.filter(Boolean));\\n    }\\n  });\\n\\n  return [...new Set(exports)];\\n}\\n\\n/**\\n * Extract function signatures\\n */\\nfunction extractFunctionSignatures(code: string): string[] {\\n  const functions: string[] = [];\\n  const patterns = [\\n    /(?:async\\\\s+)?function\\\\s+(\\\\w+)/g,\\n    /(\\\\w+)\\\\s*:\\\\s*(?:async\\\\s+)?\\\\([^)]*\\\\)\\\\s*=>/g,\\n    /(?:const|let)\\\\s+(\\\\w+)\\\\s*=\\\\s*(?:async\\\\s+)?\\\\([^)]*\\\\)\\\\s*=>/g,\\n    /fn\\\\s+(\\\\w+)/g,\\n    /def\\\\s+(\\\\w+)/g,\\n  ];\\n\\n  patterns.forEach((pattern) => {\\n    let match;\\n    while ((match = pattern.exec(code)) !== null) {\\n      functions.push(match[1]);\\n    }\\n  });\\n\\n  return [...new Set(functions)];\\n}\\n\\n/**\\n * Extract class names\\n */\\nfunction extractClassNames(code: string): string[] {\\n  const classes: string[] = [];\\n  const patterns = [\\n    /class\\\\s+(\\\\w+)/g,\\n    /struct\\\\s+(\\\\w+)/g,\\n    /interface\\\\s+(\\\\w+)/g,\\n    /type\\\\s+(\\\\w+)\\\\s*=/g,\\n  ];\\n\\n  patterns.forEach((pattern) => {\\n    let match;\\n    while ((match = pattern.exec(code)) !== null) {\\n      classes.push(match[1]);\\n    }\\n  });\\n\\n  return [...new Set(classes)];\\n}\\n\\n/**\\n * Extract error patterns\\n */\\nfunction extractErrorPatterns(code: string): string[] {\\n  const errors: string[] = [];\\n  const lines = code.split(\\\"\\\\n\\\");\\n\\n  lines.forEach((line) => {\\n    if (\\n      line.includes(\\\"TODO\\\") ||\\n      line.includes(\\\"FIXME\\\") ||\\n      line.includes(\\\"HACK\\\") ||\\n      line.includes(\\\"XXX\\\") ||\\n      line.includes(\\\"BUG\\\")\\n    ) {\\n      errors.push(line.trim().slice(0, 100));\\n    }\\n  });\\n\\n  return errors.slice(0, 10);\\n}\\n\\n/**\\n * Truncate to target size\\n */\\nfunction truncateToTarget(text: string): string {\\n  if (text.length <= TARGET_COMPRESSED_SIZE) {\\n    return text;\\n  }\\n\\n  return text.slice(0, TARGET_COMPRESSED_SIZE - 20) + \\\"\\\\n... (compressed)\\\";\\n}\\n\\n/**\\n * Calculate compression ratio\\n */\\nexport function getCompressionStats(\\n  originalSize: number,\\n  compressedSize: number\\n): { ratio: number; saved: number; savedPercent: string } {\\n  const saved = originalSize - compressedSize;\\n  const ratio = originalSize / compressedSize;\\n  const savedPercent = ((saved / originalSize) * 100).toFixed(1);\\n\\n  return { ratio, saved, savedPercent };\\n}\\n\",\"#!/usr/bin/env node\\n/**\\n * Memvid Mind - Post Tool Use Hook\\n *\\n * Captures observations after each tool execution.\\n * Uses ENDLESS MODE compression to store 20x more context.\\n * Intelligently extracts key learnings and stores them for future sessions.\\n */\\n\\nimport { getMind } from \\\"../core/mind.js\\\";\\nimport {\\n  readStdin,\\n  writeOutput,\\n  debug,\\n  classifyObservationType,\\n} from \\\"../utils/helpers.js\\\";\\nimport {\\n  compressToolOutput,\\n  getCompressionStats,\\n} from \\\"../utils/compression.js\\\";\\nimport type { HookInput } from \\\"../types.js\\\";\\n\\n// Tools worth capturing observations from\\nconst OBSERVED_TOOLS = new Set([\\n  \\\"Read\\\",\\n  \\\"Edit\\\",\\n  \\\"Write\\\",\\n  \\\"Update\\\",  // Claude Code may use Update for edits\\n  \\\"Bash\\\",\\n  \\\"Grep\\\",\\n  \\\"Glob\\\",\\n  \\\"WebFetch\\\",\\n  \\\"WebSearch\\\",\\n  \\\"Task\\\",\\n  \\\"NotebookEdit\\\",\\n]);\\n\\n// Minimum output length to consider capturing\\nconst MIN_OUTPUT_LENGTH = 50;\\n\\n// Simple in-memory dedup cache to avoid storing duplicate observations\\n// Key: hash of tool+input, Value: timestamp of last capture\\nconst recentObservations = new Map<string, number>();\\nconst DEDUP_WINDOW_MS = 60000; // 1 minute - don't re-capture same thing within this window\\n\\nfunction getObservationKey(toolName: string, toolInput: Record<string, unknown> | undefined): string {\\n  const inputStr = toolInput ? JSON.stringify(toolInput).slice(0, 200) : \\\"\\\";\\n  return `${toolName}:${inputStr}`;\\n}\\n\\nfunction isDuplicate(key: string): boolean {\\n  const lastSeen = recentObservations.get(key);\\n  if (!lastSeen) return false;\\n  return Date.now() - lastSeen < DEDUP_WINDOW_MS;\\n}\\n\\nfunction markObserved(key: string): void {\\n  recentObservations.set(key, Date.now());\\n  // Clean old entries\\n  if (recentObservations.size > 100) {\\n    const now = Date.now();\\n    for (const [k, v] of recentObservations.entries()) {\\n      if (now - v > DEDUP_WINDOW_MS * 2) {\\n        recentObservations.delete(k);\\n      }\\n    }\\n  }\\n}\\n\\n// Tools that should ALWAYS be captured regardless of output length\\nconst ALWAYS_CAPTURE_TOOLS = new Set([\\\"Edit\\\", \\\"Write\\\", \\\"Update\\\", \\\"NotebookEdit\\\"]);\\n\\n// Maximum output length after compression\\nconst MAX_OUTPUT_LENGTH = 2500;\\n\\nasync function main() {\\n  try {\\n    // Read hook input from stdin\\n    const input = await readStdin();\\n    const hookInput: HookInput = JSON.parse(input);\\n\\n    const { tool_name, tool_input, tool_response } = hookInput;\\n\\n    // Debug: Log all tool names to understand what we're receiving\\n    debug(`Tool received: ${tool_name}`);\\n\\n    // Skip if not a tool we observe\\n    if (!tool_name || !OBSERVED_TOOLS.has(tool_name)) {\\n      debug(`Skipping tool: ${tool_name} (not in OBSERVED_TOOLS)`);\\n      writeOutput({ continue: true });\\n      return;\\n    }\\n\\n    // Deduplication check - avoid storing the same observation within a short window\\n    const dedupKey = getObservationKey(tool_name, tool_input);\\n    if (isDuplicate(dedupKey)) {\\n      debug(`Skipping duplicate observation: ${tool_name}`);\\n      writeOutput({ continue: true });\\n      return;\\n    }\\n\\n    // Convert tool_response to string (it can be object or string)\\n    const tool_output = typeof tool_response === 'string'\\n      ? tool_response\\n      : JSON.stringify(tool_response, null, 2);\\n\\n    // Skip if output is too short or missing (but ALWAYS capture file modifications)\\n    const alwaysCapture = ALWAYS_CAPTURE_TOOLS.has(tool_name);\\n    if (!alwaysCapture && (!tool_output || tool_output.length < MIN_OUTPUT_LENGTH)) {\\n      writeOutput({ continue: true });\\n      return;\\n    }\\n\\n    // For file modifications with minimal output, create a descriptive content\\n    let effectiveOutput = tool_output || \\\"\\\";\\n    if (alwaysCapture && effectiveOutput.length < MIN_OUTPUT_LENGTH) {\\n      const filePath = tool_input?.file_path as string || \\\"unknown file\\\";\\n      const fileName = filePath.split(\\\"/\\\").pop() || \\\"file\\\";\\n      effectiveOutput = `File modified: ${fileName}\\\\nPath: ${filePath}\\\\nTool: ${tool_name}`;\\n    }\\n\\n    // Skip system reminders and internal content\\n    if (\\n      effectiveOutput.includes(\\\"<system-reminder>\\\") ||\\n      effectiveOutput.includes(\\\"<memvid-mind-context>\\\")\\n    ) {\\n      writeOutput({ continue: true });\\n      return;\\n    }\\n\\n    // ENDLESS MODE: Compress large outputs to ~500 tokens\\n    const { compressed, wasCompressed, originalSize } = compressToolOutput(\\n      tool_name,\\n      tool_input,\\n      effectiveOutput\\n    );\\n\\n    if (wasCompressed) {\\n      const stats = getCompressionStats(originalSize, compressed.length);\\n      debug(`🗜️ Endless Mode: ${stats.savedPercent}% compression (${originalSize} → ${compressed.length} chars)`);\\n    }\\n\\n    debug(`Capturing observation from ${tool_name}`);\\n\\n    // Initialize mind\\n    const mind = await getMind();\\n\\n    // Extract and classify the observation\\n    const observationType = classifyObservationType(tool_name, compressed);\\n\\n    // Generate a summary based on tool type\\n    const summary = generateSummary(tool_name, tool_input, effectiveOutput);\\n\\n    // Use compressed content (already within limits)\\n    const content = compressed.length > MAX_OUTPUT_LENGTH\\n      ? compressed.slice(0, MAX_OUTPUT_LENGTH) + \\\"\\\\n... (compressed)\\\"\\n      : compressed;\\n\\n    // Extract metadata with compression flag\\n    const metadata = extractMetadata(tool_name, tool_input);\\n    if (wasCompressed) {\\n      metadata.compressed = true;\\n      metadata.originalSize = originalSize;\\n      metadata.compressedSize = compressed.length;\\n    }\\n\\n    // Store the observation\\n    await mind.remember({\\n      type: observationType,\\n      summary,\\n      content,\\n      tool: tool_name,\\n      metadata,\\n    });\\n\\n    // Mark as observed for deduplication\\n    markObserved(dedupKey);\\n\\n    debug(`Stored: [${observationType}] ${summary}${wasCompressed ? \\\" (compressed)\\\" : \\\"\\\"}`);\\n\\n    // Continue without blocking\\n    writeOutput({ continue: true });\\n  } catch (error) {\\n    debug(`Error: ${error}`);\\n    // Don't block on errors\\n    writeOutput({ continue: true });\\n  }\\n}\\n\\n/**\\n * Generate a summary based on tool type and input\\n */\\nfunction generateSummary(\\n  toolName: string,\\n  toolInput: Record<string, unknown> | undefined,\\n  toolOutput: string\\n): string {\\n  switch (toolName) {\\n    case \\\"Read\\\": {\\n      const path = toolInput?.file_path as string;\\n      const fileName = path?.split(\\\"/\\\").pop() || \\\"file\\\";\\n      const lines = toolOutput.split(\\\"\\\\n\\\").length;\\n      return `Read ${fileName} (${lines} lines)`;\\n    }\\n\\n    case \\\"Edit\\\": {\\n      const path = toolInput?.file_path as string;\\n      const fileName = path?.split(\\\"/\\\").pop() || \\\"file\\\";\\n      return `Edited ${fileName}`;\\n    }\\n\\n    case \\\"Write\\\": {\\n      const path = toolInput?.file_path as string;\\n      const fileName = path?.split(\\\"/\\\").pop() || \\\"file\\\";\\n      return `Created ${fileName}`;\\n    }\\n\\n    case \\\"Bash\\\": {\\n      const cmd = toolInput?.command as string;\\n      const shortCmd = cmd?.split(\\\"\\\\n\\\")[0].slice(0, 50) || \\\"command\\\";\\n      const hasError =\\n        toolOutput.toLowerCase().includes(\\\"error\\\") ||\\n        toolOutput.toLowerCase().includes(\\\"failed\\\");\\n      return hasError ? `Command failed: ${shortCmd}` : `Ran: ${shortCmd}`;\\n    }\\n\\n    case \\\"Grep\\\": {\\n      const pattern = toolInput?.pattern as string;\\n      const matches = toolOutput.split(\\\"\\\\n\\\").filter(Boolean).length;\\n      return `Found ${matches} matches for \\\"${pattern?.slice(0, 30)}\\\"`;\\n    }\\n\\n    case \\\"Glob\\\": {\\n      const pattern = toolInput?.pattern as string;\\n      const matches = toolOutput.split(\\\"\\\\n\\\").filter(Boolean).length;\\n      return `Found ${matches} files matching \\\"${pattern?.slice(0, 30)}\\\"`;\\n    }\\n\\n    case \\\"WebFetch\\\":\\n    case \\\"WebSearch\\\": {\\n      const url = (toolInput?.url as string) || (toolInput?.query as string);\\n      return `Fetched: ${url?.slice(0, 50)}`;\\n    }\\n\\n    default:\\n      return `${toolName} completed`;\\n  }\\n}\\n\\n/**\\n * Extract metadata from tool input\\n */\\nfunction extractMetadata(\\n  toolName: string,\\n  toolInput: Record<string, unknown> | undefined\\n): Record<string, unknown> {\\n  const metadata: Record<string, unknown> = {};\\n\\n  if (!toolInput) return metadata;\\n\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n    case \\\"Edit\\\":\\n    case \\\"Write\\\":\\n      if (toolInput.file_path) {\\n        metadata.files = [toolInput.file_path];\\n      }\\n      break;\\n\\n    case \\\"Bash\\\":\\n      if (toolInput.command) {\\n        metadata.command = (toolInput.command as string).slice(0, 200);\\n      }\\n      break;\\n\\n    case \\\"Grep\\\":\\n    case \\\"Glob\\\":\\n      if (toolInput.pattern) {\\n        metadata.pattern = toolInput.pattern;\\n      }\\n      if (toolInput.path) {\\n        metadata.searchPath = toolInput.path;\\n      }\\n      break;\\n  }\\n\\n  return metadata;\\n}\\n\\nmain();\\n\"]}",
        "dist/hooks/session-start.js": "#!/usr/bin/env node\nimport 'crypto';\nimport { existsSync, statSync } from 'fs';\nimport { basename, resolve } from 'path';\n\nasync function readStdin() {\n  const chunks = [];\n  return new Promise((resolve2, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve2(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\nfunction writeOutput(output) {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\nfunction debug(message) {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\nasync function main() {\n  try {\n    const input = await readStdin();\n    const hookInput = JSON.parse(input);\n    debug(`Session starting: ${hookInput.session_id}`);\n    const projectDir = hookInput.cwd || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n    const projectName = basename(projectDir);\n    const memoryPath = resolve(projectDir, \".claude/mind.mv2\");\n    const memoryExists = existsSync(memoryPath);\n    const contextLines = [];\n    if (memoryExists) {\n      try {\n        const stats = statSync(memoryPath);\n        const fileSizeKB = Math.round(stats.size / 1024);\n        contextLines.push(\"<memvid-mind-context>\");\n        contextLines.push(\"# \\u{1F9E0} Claude Mind Active\");\n        contextLines.push(\"\");\n        contextLines.push(`\\u{1F4C1} Project: **${projectName}**`);\n        contextLines.push(`\\u{1F4BE} Memory: \\`.claude/mind.mv2\\` (${fileSizeKB} KB)`);\n        contextLines.push(\"\");\n        contextLines.push(\"**Commands:**\");\n        contextLines.push(\"- `/mind:search <query>` - Search memories\");\n        contextLines.push(\"- `/mind:ask <question>` - Ask your memory\");\n        contextLines.push(\"- `/mind:recent` - View timeline\");\n        contextLines.push(\"- `/mind:stats` - View statistics\");\n        contextLines.push(\"\");\n        contextLines.push(\"_Memories are captured automatically from your tool use._\");\n        contextLines.push(\"</memvid-mind-context>\");\n      } catch {\n      }\n    } else {\n      contextLines.push(\"<memvid-mind-context>\");\n      contextLines.push(\"# \\u{1F9E0} Claude Mind Ready\");\n      contextLines.push(\"\");\n      contextLines.push(`\\u{1F4C1} Project: **${projectName}**`);\n      contextLines.push(\"\\u{1F4BE} Memory will be created at: `.claude/mind.mv2`\");\n      contextLines.push(\"\");\n      contextLines.push(\"_Your observations will be automatically captured._\");\n      contextLines.push(\"</memvid-mind-context>\");\n    }\n    const output = {\n      continue: true\n    };\n    if (contextLines.length > 0) {\n      output.hookSpecificOutput = {\n        hookEventName: \"SessionStart\",\n        additionalContext: contextLines.join(\"\\n\")\n      };\n    }\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    writeOutput({ continue: true });\n  }\n}\nmain();\n//# sourceMappingURL=session-start.js.map\n//# sourceMappingURL=session-start.js.map",
        "dist/hooks/session-start.js.map": "{\"version\":3,\"sources\":[\"../../src/utils/helpers.ts\",\"../../src/hooks/session-start.ts\"],\"names\":[\"resolve\"],\"mappings\":\"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\",\"file\":\"session-start.js\",\"sourcesContent\":[\"/**\\n * Memvid Mind - Utility Helpers\\n */\\n\\nimport { randomBytes } from \\\"node:crypto\\\";\\n\\n/**\\n * Generate a unique ID\\n */\\nexport function generateId(): string {\\n  return randomBytes(8).toString(\\\"hex\\\");\\n}\\n\\n/**\\n * Estimate token count for text (rough approximation)\\n * ~4 characters per token for English text\\n */\\nexport function estimateTokens(text: string): number {\\n  return Math.ceil(text.length / 4);\\n}\\n\\n/**\\n * Truncate text to fit within token limit\\n */\\nexport function truncateToTokens(text: string, maxTokens: number): string {\\n  const maxChars = maxTokens * 4;\\n  if (text.length <= maxChars) return text;\\n  return text.slice(0, maxChars - 3) + \\\"...\\\";\\n}\\n\\n/**\\n * Format timestamp to human-readable string\\n */\\nexport function formatTimestamp(ts: number): string {\\n  const date = new Date(ts);\\n  const now = new Date();\\n  const diffMs = now.getTime() - date.getTime();\\n  const diffMins = Math.floor(diffMs / 60000);\\n  const diffHours = Math.floor(diffMs / 3600000);\\n  const diffDays = Math.floor(diffMs / 86400000);\\n\\n  if (diffMins < 1) return \\\"just now\\\";\\n  if (diffMins < 60) return `${diffMins}m ago`;\\n  if (diffHours < 24) return `${diffHours}h ago`;\\n  if (diffDays < 7) return `${diffDays}d ago`;\\n\\n  return date.toLocaleDateString();\\n}\\n\\n/**\\n * Parse JSON safely\\n */\\nexport function safeJsonParse<T>(text: string, fallback: T): T {\\n  try {\\n    return JSON.parse(text) as T;\\n  } catch {\\n    return fallback;\\n  }\\n}\\n\\n/**\\n * Read all stdin as string\\n */\\nexport async function readStdin(): Promise<string> {\\n  const chunks: Buffer[] = [];\\n\\n  return new Promise((resolve, reject) => {\\n    process.stdin.on(\\\"data\\\", (chunk) => chunks.push(chunk));\\n    process.stdin.on(\\\"end\\\", () => resolve(Buffer.concat(chunks).toString(\\\"utf8\\\")));\\n    process.stdin.on(\\\"error\\\", reject);\\n  });\\n}\\n\\n/**\\n * Write JSON to stdout and exit immediately\\n * (Prevents SDK background tasks from blocking process exit)\\n */\\nexport function writeOutput(output: unknown): never {\\n  console.log(JSON.stringify(output));\\n  process.exit(0);\\n}\\n\\n/**\\n * Log debug message to stderr\\n */\\nexport function debug(message: string): void {\\n  if (process.env.MEMVID_MIND_DEBUG === \\\"1\\\") {\\n    console.error(`[memvid-mind] ${message}`);\\n  }\\n}\\n\\n/**\\n * Extract key information from tool output\\n */\\nexport function extractKeyInfo(toolName: string, output: string): string {\\n  // Truncate very long outputs\\n  const maxLength = 2000;\\n  const truncated = output.length > maxLength\\n    ? output.slice(0, maxLength) + \\\"\\\\n... (truncated)\\\"\\n    : output;\\n\\n  // Tool-specific extraction\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n      // Extract file summary from read output\\n      return extractFileReadSummary(truncated);\\n    case \\\"Bash\\\":\\n      // Extract command summary\\n      return extractBashSummary(truncated);\\n    case \\\"Edit\\\":\\n      // Extract edit summary\\n      return extractEditSummary(truncated);\\n    case \\\"Grep\\\":\\n    case \\\"Glob\\\":\\n      // Extract search summary\\n      return extractSearchSummary(truncated);\\n    default:\\n      return truncated;\\n  }\\n}\\n\\nfunction extractFileReadSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 20) return output;\\n  return `${lines.slice(0, 10).join(\\\"\\\\n\\\")}\\\\n... (${lines.length} lines total)`;\\n}\\n\\nfunction extractBashSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 30) return output;\\n  return [\\n    ...lines.slice(0, 10),\\n    `... (${lines.length - 20} lines omitted)`,\\n    ...lines.slice(-10),\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\nfunction extractEditSummary(output: string): string {\\n  // Edits are usually compact, return as-is\\n  return output;\\n}\\n\\nfunction extractSearchSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\").filter(Boolean);\\n  if (lines.length <= 20) return output;\\n  return [\\n    ...lines.slice(0, 15),\\n    `... and ${lines.length - 15} more results`,\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\n/**\\n * Classify observation type from tool and output\\n */\\nexport function classifyObservationType(\\n  toolName: string,\\n  output: string\\n): \\\"discovery\\\" | \\\"decision\\\" | \\\"problem\\\" | \\\"solution\\\" | \\\"pattern\\\" | \\\"warning\\\" | \\\"success\\\" | \\\"refactor\\\" | \\\"bugfix\\\" | \\\"feature\\\" {\\n  const lowerOutput = output.toLowerCase();\\n\\n  // Error detection\\n  if (\\n    lowerOutput.includes(\\\"error\\\") ||\\n    lowerOutput.includes(\\\"failed\\\") ||\\n    lowerOutput.includes(\\\"exception\\\")\\n  ) {\\n    return \\\"problem\\\";\\n  }\\n\\n  // Success detection\\n  if (\\n    lowerOutput.includes(\\\"success\\\") ||\\n    lowerOutput.includes(\\\"passed\\\") ||\\n    lowerOutput.includes(\\\"completed\\\")\\n  ) {\\n    return \\\"success\\\";\\n  }\\n\\n  // Warning detection\\n  if (lowerOutput.includes(\\\"warning\\\") || lowerOutput.includes(\\\"deprecated\\\")) {\\n    return \\\"warning\\\";\\n  }\\n\\n  // Tool-based classification\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n    case \\\"Glob\\\":\\n    case \\\"Grep\\\":\\n      return \\\"discovery\\\";\\n    case \\\"Edit\\\":\\n      if (lowerOutput.includes(\\\"fix\\\") || lowerOutput.includes(\\\"bug\\\")) {\\n        return \\\"bugfix\\\";\\n      }\\n      return \\\"refactor\\\";\\n    case \\\"Write\\\":\\n      return \\\"feature\\\";\\n    default:\\n      return \\\"discovery\\\";\\n  }\\n}\\n\",\"#!/usr/bin/env node\\n/**\\n * Memvid Mind - Session Start Hook\\n *\\n * LIGHTWEIGHT startup - does NOT load the SDK.\\n * SDK is loaded lazily on first tool use instead.\\n * This keeps Claude startup fast (< 1 second).\\n */\\n\\nimport { readStdin, writeOutput, debug } from \\\"../utils/helpers.js\\\";\\nimport type { HookInput } from \\\"../types.js\\\";\\nimport { existsSync, statSync } from \\\"node:fs\\\";\\nimport { resolve, basename } from \\\"node:path\\\";\\n\\nasync function main() {\\n  try {\\n    // Read hook input from stdin\\n    const input = await readStdin();\\n    const hookInput: HookInput = JSON.parse(input);\\n\\n    debug(`Session starting: ${hookInput.session_id}`);\\n\\n    // Get project info without loading SDK\\n    const projectDir = hookInput.cwd || process.env.CLAUDE_PROJECT_DIR || process.cwd();\\n    const projectName = basename(projectDir);\\n    const memoryPath = resolve(projectDir, \\\".claude/mind.mv2\\\");\\n\\n    // Quick check if memory file exists (no SDK needed)\\n    const memoryExists = existsSync(memoryPath);\\n\\n    // Build minimal context without loading SDK\\n    const contextLines: string[] = [];\\n\\n    if (memoryExists) {\\n      try {\\n        const stats = statSync(memoryPath);\\n        const fileSizeKB = Math.round(stats.size / 1024);\\n\\n        contextLines.push(\\\"<memvid-mind-context>\\\");\\n        contextLines.push(\\\"# 🧠 Claude Mind Active\\\");\\n        contextLines.push(\\\"\\\");\\n        contextLines.push(`📁 Project: **${projectName}**`);\\n        contextLines.push(`💾 Memory: \\\\`.claude/mind.mv2\\\\` (${fileSizeKB} KB)`);\\n        contextLines.push(\\\"\\\");\\n        contextLines.push(\\\"**Commands:**\\\");\\n        contextLines.push(\\\"- `/mind:search <query>` - Search memories\\\");\\n        contextLines.push(\\\"- `/mind:ask <question>` - Ask your memory\\\");\\n        contextLines.push(\\\"- `/mind:recent` - View timeline\\\");\\n        contextLines.push(\\\"- `/mind:stats` - View statistics\\\");\\n        contextLines.push(\\\"\\\");\\n        contextLines.push(\\\"_Memories are captured automatically from your tool use._\\\");\\n        contextLines.push(\\\"</memvid-mind-context>\\\");\\n      } catch {\\n        // Ignore stat errors\\n      }\\n    } else {\\n      // First time - memory will be created on first observation\\n      contextLines.push(\\\"<memvid-mind-context>\\\");\\n      contextLines.push(\\\"# 🧠 Claude Mind Ready\\\");\\n      contextLines.push(\\\"\\\");\\n      contextLines.push(`📁 Project: **${projectName}**`);\\n      contextLines.push(\\\"💾 Memory will be created at: \\\\`.claude/mind.mv2\\\\`\\\");\\n      contextLines.push(\\\"\\\");\\n      contextLines.push(\\\"_Your observations will be automatically captured._\\\");\\n      contextLines.push(\\\"</memvid-mind-context>\\\");\\n    }\\n\\n    // SessionStart hooks use hookSpecificOutput.additionalContext\\n    const output: any = {\\n      continue: true,\\n    };\\n\\n    if (contextLines.length > 0) {\\n      output.hookSpecificOutput = {\\n        hookEventName: \\\"SessionStart\\\",\\n        additionalContext: contextLines.join(\\\"\\\\n\\\"),\\n      };\\n    }\\n\\n    writeOutput(output);\\n  } catch (error) {\\n    debug(`Error: ${error}`);\\n    // Don't block on errors\\n    writeOutput({ continue: true });\\n  }\\n}\\n\\nmain();\\n\"]}",
        "dist/hooks/smart-install.js": "#!/usr/bin/env node\nimport { existsSync, readFileSync, writeFileSync } from 'fs';\nimport { dirname, resolve } from 'path';\nimport { execSync } from 'child_process';\nimport 'crypto';\n\nfunction writeOutput(output) {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\nfunction debug(message) {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\n\n// src/hooks/smart-install.ts\nvar pluginRoot = process.env.CLAUDE_PLUGIN_ROOT || dirname(dirname(__dirname));\nvar nodeModulesPath = resolve(pluginRoot, \"node_modules\");\nvar sdkPath = resolve(nodeModulesPath, \"@memvid/sdk\");\nvar packageJsonPath = resolve(pluginRoot, \"package.json\");\nvar installMarkerPath = resolve(pluginRoot, \".install-version\");\nfunction getPackageVersion() {\n  try {\n    const pkg = JSON.parse(readFileSync(packageJsonPath, \"utf-8\"));\n    return pkg.version || \"unknown\";\n  } catch {\n    return \"unknown\";\n  }\n}\nfunction getInstallMarker() {\n  try {\n    if (existsSync(installMarkerPath)) {\n      return JSON.parse(readFileSync(installMarkerPath, \"utf-8\"));\n    }\n  } catch {\n  }\n  return null;\n}\nfunction saveInstallMarker(version) {\n  const marker = {\n    version,\n    installedAt: (/* @__PURE__ */ new Date()).toISOString()\n  };\n  writeFileSync(installMarkerPath, JSON.stringify(marker, null, 2));\n}\nfunction needsInstall() {\n  if (!existsSync(sdkPath)) {\n    debug(\"SDK not found, needs install\");\n    return true;\n  }\n  const marker = getInstallMarker();\n  const currentVersion = getPackageVersion();\n  if (!marker || marker.version !== currentVersion) {\n    debug(`Version mismatch: ${marker?.version} -> ${currentVersion}`);\n    return true;\n  }\n  return false;\n}\nfunction installDeps() {\n  debug(\"Installing dependencies...\");\n  try {\n    execSync(\"npm install --production --no-fund --no-audit\", {\n      cwd: pluginRoot,\n      stdio: \"pipe\",\n      timeout: 12e4\n      // 2 minute timeout\n    });\n    debug(\"Dependencies installed successfully\");\n    return true;\n  } catch (error) {\n    debug(`npm install failed: ${error}`);\n    try {\n      execSync(\"npm install --production --no-fund --no-audit --force\", {\n        cwd: pluginRoot,\n        stdio: \"pipe\",\n        timeout: 12e4\n      });\n      debug(\"Dependencies installed with --force\");\n      return true;\n    } catch (forceError) {\n      debug(`npm install --force failed: ${forceError}`);\n      return false;\n    }\n  }\n}\nasync function main() {\n  try {\n    if (needsInstall()) {\n      const success = installDeps();\n      if (success) {\n        const version = getPackageVersion();\n        saveInstallMarker(version);\n        debug(`Installed memvid-mind v${version}`);\n      } else {\n        debug(\"Failed to install dependencies\");\n      }\n    } else {\n      debug(\"Dependencies already installed\");\n    }\n    writeOutput({ continue: true });\n  } catch (error) {\n    debug(`Smart install error: ${error}`);\n    writeOutput({ continue: true });\n  }\n}\nmain();\n//# sourceMappingURL=smart-install.js.map\n//# sourceMappingURL=smart-install.js.map",
        "dist/hooks/smart-install.js.map": "{\"version\":3,\"sources\":[\"../../src/utils/helpers.ts\",\"../../src/hooks/smart-install.ts\"],\"names\":[],\"mappings\":\"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\",\"file\":\"smart-install.js\",\"sourcesContent\":[\"/**\\n * Memvid Mind - Utility Helpers\\n */\\n\\nimport { randomBytes } from \\\"node:crypto\\\";\\n\\n/**\\n * Generate a unique ID\\n */\\nexport function generateId(): string {\\n  return randomBytes(8).toString(\\\"hex\\\");\\n}\\n\\n/**\\n * Estimate token count for text (rough approximation)\\n * ~4 characters per token for English text\\n */\\nexport function estimateTokens(text: string): number {\\n  return Math.ceil(text.length / 4);\\n}\\n\\n/**\\n * Truncate text to fit within token limit\\n */\\nexport function truncateToTokens(text: string, maxTokens: number): string {\\n  const maxChars = maxTokens * 4;\\n  if (text.length <= maxChars) return text;\\n  return text.slice(0, maxChars - 3) + \\\"...\\\";\\n}\\n\\n/**\\n * Format timestamp to human-readable string\\n */\\nexport function formatTimestamp(ts: number): string {\\n  const date = new Date(ts);\\n  const now = new Date();\\n  const diffMs = now.getTime() - date.getTime();\\n  const diffMins = Math.floor(diffMs / 60000);\\n  const diffHours = Math.floor(diffMs / 3600000);\\n  const diffDays = Math.floor(diffMs / 86400000);\\n\\n  if (diffMins < 1) return \\\"just now\\\";\\n  if (diffMins < 60) return `${diffMins}m ago`;\\n  if (diffHours < 24) return `${diffHours}h ago`;\\n  if (diffDays < 7) return `${diffDays}d ago`;\\n\\n  return date.toLocaleDateString();\\n}\\n\\n/**\\n * Parse JSON safely\\n */\\nexport function safeJsonParse<T>(text: string, fallback: T): T {\\n  try {\\n    return JSON.parse(text) as T;\\n  } catch {\\n    return fallback;\\n  }\\n}\\n\\n/**\\n * Read all stdin as string\\n */\\nexport async function readStdin(): Promise<string> {\\n  const chunks: Buffer[] = [];\\n\\n  return new Promise((resolve, reject) => {\\n    process.stdin.on(\\\"data\\\", (chunk) => chunks.push(chunk));\\n    process.stdin.on(\\\"end\\\", () => resolve(Buffer.concat(chunks).toString(\\\"utf8\\\")));\\n    process.stdin.on(\\\"error\\\", reject);\\n  });\\n}\\n\\n/**\\n * Write JSON to stdout and exit immediately\\n * (Prevents SDK background tasks from blocking process exit)\\n */\\nexport function writeOutput(output: unknown): never {\\n  console.log(JSON.stringify(output));\\n  process.exit(0);\\n}\\n\\n/**\\n * Log debug message to stderr\\n */\\nexport function debug(message: string): void {\\n  if (process.env.MEMVID_MIND_DEBUG === \\\"1\\\") {\\n    console.error(`[memvid-mind] ${message}`);\\n  }\\n}\\n\\n/**\\n * Extract key information from tool output\\n */\\nexport function extractKeyInfo(toolName: string, output: string): string {\\n  // Truncate very long outputs\\n  const maxLength = 2000;\\n  const truncated = output.length > maxLength\\n    ? output.slice(0, maxLength) + \\\"\\\\n... (truncated)\\\"\\n    : output;\\n\\n  // Tool-specific extraction\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n      // Extract file summary from read output\\n      return extractFileReadSummary(truncated);\\n    case \\\"Bash\\\":\\n      // Extract command summary\\n      return extractBashSummary(truncated);\\n    case \\\"Edit\\\":\\n      // Extract edit summary\\n      return extractEditSummary(truncated);\\n    case \\\"Grep\\\":\\n    case \\\"Glob\\\":\\n      // Extract search summary\\n      return extractSearchSummary(truncated);\\n    default:\\n      return truncated;\\n  }\\n}\\n\\nfunction extractFileReadSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 20) return output;\\n  return `${lines.slice(0, 10).join(\\\"\\\\n\\\")}\\\\n... (${lines.length} lines total)`;\\n}\\n\\nfunction extractBashSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 30) return output;\\n  return [\\n    ...lines.slice(0, 10),\\n    `... (${lines.length - 20} lines omitted)`,\\n    ...lines.slice(-10),\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\nfunction extractEditSummary(output: string): string {\\n  // Edits are usually compact, return as-is\\n  return output;\\n}\\n\\nfunction extractSearchSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\").filter(Boolean);\\n  if (lines.length <= 20) return output;\\n  return [\\n    ...lines.slice(0, 15),\\n    `... and ${lines.length - 15} more results`,\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\n/**\\n * Classify observation type from tool and output\\n */\\nexport function classifyObservationType(\\n  toolName: string,\\n  output: string\\n): \\\"discovery\\\" | \\\"decision\\\" | \\\"problem\\\" | \\\"solution\\\" | \\\"pattern\\\" | \\\"warning\\\" | \\\"success\\\" | \\\"refactor\\\" | \\\"bugfix\\\" | \\\"feature\\\" {\\n  const lowerOutput = output.toLowerCase();\\n\\n  // Error detection\\n  if (\\n    lowerOutput.includes(\\\"error\\\") ||\\n    lowerOutput.includes(\\\"failed\\\") ||\\n    lowerOutput.includes(\\\"exception\\\")\\n  ) {\\n    return \\\"problem\\\";\\n  }\\n\\n  // Success detection\\n  if (\\n    lowerOutput.includes(\\\"success\\\") ||\\n    lowerOutput.includes(\\\"passed\\\") ||\\n    lowerOutput.includes(\\\"completed\\\")\\n  ) {\\n    return \\\"success\\\";\\n  }\\n\\n  // Warning detection\\n  if (lowerOutput.includes(\\\"warning\\\") || lowerOutput.includes(\\\"deprecated\\\")) {\\n    return \\\"warning\\\";\\n  }\\n\\n  // Tool-based classification\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n    case \\\"Glob\\\":\\n    case \\\"Grep\\\":\\n      return \\\"discovery\\\";\\n    case \\\"Edit\\\":\\n      if (lowerOutput.includes(\\\"fix\\\") || lowerOutput.includes(\\\"bug\\\")) {\\n        return \\\"bugfix\\\";\\n      }\\n      return \\\"refactor\\\";\\n    case \\\"Write\\\":\\n      return \\\"feature\\\";\\n    default:\\n      return \\\"discovery\\\";\\n  }\\n}\\n\",\"#!/usr/bin/env node\\n/**\\n * Memvid Mind - Smart Install Hook\\n *\\n * Automatically installs dependencies on first run.\\n * Runs on SessionStart before other hooks.\\n */\\n\\nimport { existsSync, readFileSync, writeFileSync } from \\\"node:fs\\\";\\nimport { resolve, dirname } from \\\"node:path\\\";\\nimport { execSync } from \\\"node:child_process\\\";\\nimport { writeOutput, debug } from \\\"../utils/helpers.js\\\";\\n\\n// Get the plugin root directory\\nconst pluginRoot = process.env.CLAUDE_PLUGIN_ROOT || dirname(dirname(__dirname));\\nconst nodeModulesPath = resolve(pluginRoot, \\\"node_modules\\\");\\nconst sdkPath = resolve(nodeModulesPath, \\\"@memvid/sdk\\\");\\nconst packageJsonPath = resolve(pluginRoot, \\\"package.json\\\");\\nconst installMarkerPath = resolve(pluginRoot, \\\".install-version\\\");\\n\\ninterface InstallMarker {\\n  version: string;\\n  installedAt: string;\\n}\\n\\nfunction getPackageVersion(): string {\\n  try {\\n    const pkg = JSON.parse(readFileSync(packageJsonPath, \\\"utf-8\\\"));\\n    return pkg.version || \\\"unknown\\\";\\n  } catch {\\n    return \\\"unknown\\\";\\n  }\\n}\\n\\nfunction getInstallMarker(): InstallMarker | null {\\n  try {\\n    if (existsSync(installMarkerPath)) {\\n      return JSON.parse(readFileSync(installMarkerPath, \\\"utf-8\\\"));\\n    }\\n  } catch {\\n    // Ignore errors\\n  }\\n  return null;\\n}\\n\\nfunction saveInstallMarker(version: string): void {\\n  const marker: InstallMarker = {\\n    version,\\n    installedAt: new Date().toISOString(),\\n  };\\n  writeFileSync(installMarkerPath, JSON.stringify(marker, null, 2));\\n}\\n\\nfunction needsInstall(): boolean {\\n  // Check if SDK exists\\n  if (!existsSync(sdkPath)) {\\n    debug(\\\"SDK not found, needs install\\\");\\n    return true;\\n  }\\n\\n  // Check if version changed\\n  const marker = getInstallMarker();\\n  const currentVersion = getPackageVersion();\\n\\n  if (!marker || marker.version !== currentVersion) {\\n    debug(`Version mismatch: ${marker?.version} -> ${currentVersion}`);\\n    return true;\\n  }\\n\\n  return false;\\n}\\n\\nfunction installDeps(): boolean {\\n  debug(\\\"Installing dependencies...\\\");\\n\\n  try {\\n    // Try npm install first\\n    execSync(\\\"npm install --production --no-fund --no-audit\\\", {\\n      cwd: pluginRoot,\\n      stdio: \\\"pipe\\\",\\n      timeout: 120000, // 2 minute timeout\\n    });\\n\\n    debug(\\\"Dependencies installed successfully\\\");\\n    return true;\\n  } catch (error) {\\n    debug(`npm install failed: ${error}`);\\n\\n    // Try with force flag\\n    try {\\n      execSync(\\\"npm install --production --no-fund --no-audit --force\\\", {\\n        cwd: pluginRoot,\\n        stdio: \\\"pipe\\\",\\n        timeout: 120000,\\n      });\\n      debug(\\\"Dependencies installed with --force\\\");\\n      return true;\\n    } catch (forceError) {\\n      debug(`npm install --force failed: ${forceError}`);\\n      return false;\\n    }\\n  }\\n}\\n\\nasync function main() {\\n  try {\\n    if (needsInstall()) {\\n      const success = installDeps();\\n\\n      if (success) {\\n        const version = getPackageVersion();\\n        saveInstallMarker(version);\\n        debug(`Installed memvid-mind v${version}`);\\n      } else {\\n        debug(\\\"Failed to install dependencies\\\");\\n      }\\n    } else {\\n      debug(\\\"Dependencies already installed\\\");\\n    }\\n\\n    // Always continue - don't block on install errors\\n    writeOutput({ continue: true });\\n  } catch (error) {\\n    debug(`Smart install error: ${error}`);\\n    writeOutput({ continue: true });\\n  }\\n}\\n\\nmain();\\n\"]}",
        "dist/hooks/stop.js": "#!/usr/bin/env node\nimport { constants, readdirSync, unlinkSync, existsSync } from 'fs';\nimport { resolve, dirname } from 'path';\nimport { access, readFile, mkdir, open } from 'fs/promises';\nimport { randomBytes } from 'crypto';\nimport lockfile from 'proper-lockfile';\nimport { execSync } from 'child_process';\n\n// src/types.ts\nvar DEFAULT_CONFIG = {\n  memoryPath: \".claude/mind.mv2\",\n  maxContextObservations: 20,\n  maxContextTokens: 2e3,\n  autoCompress: true,\n  minConfidence: 0.6,\n  debug: false\n};\nfunction generateId() {\n  return randomBytes(8).toString(\"hex\");\n}\nfunction estimateTokens(text) {\n  return Math.ceil(text.length / 4);\n}\nasync function readStdin() {\n  const chunks = [];\n  return new Promise((resolve2, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve2(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\nfunction writeOutput(output) {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\nfunction debug(message) {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\nvar LOCK_OPTIONS = {\n  stale: 3e4,\n  retries: {\n    retries: 1e3,\n    minTimeout: 5,\n    maxTimeout: 50\n  }\n};\nasync function withMemvidLock(lockPath, fn) {\n  await mkdir(dirname(lockPath), { recursive: true });\n  const handle = await open(lockPath, \"a\");\n  await handle.close();\n  const release = await lockfile.lock(lockPath, LOCK_OPTIONS);\n  try {\n    return await fn();\n  } finally {\n    await release();\n  }\n}\n\n// src/core/mind.ts\nfunction pruneBackups(memoryPath, keepCount) {\n  try {\n    const dir = dirname(memoryPath);\n    const baseName = memoryPath.split(\"/\").pop() || \"mind.mv2\";\n    const backupPattern = new RegExp(`^${baseName.replace(\".\", \"\\\\.\")}\\\\.backup-\\\\d+$`);\n    const files = readdirSync(dir);\n    const backups = files.filter((f) => backupPattern.test(f)).map((f) => ({\n      name: f,\n      path: resolve(dir, f),\n      time: parseInt(f.split(\"-\").pop() || \"0\", 10)\n    })).sort((a, b) => b.time - a.time);\n    for (let i = keepCount; i < backups.length; i++) {\n      try {\n        unlinkSync(backups[i].path);\n        console.error(`[memvid-mind] Pruned old backup: ${backups[i].name}`);\n      } catch {\n      }\n    }\n  } catch {\n  }\n}\nvar sdkLoaded = false;\nvar use;\nvar create;\nasync function loadSDK() {\n  if (sdkLoaded) return;\n  const sdk = await import('@memvid/sdk');\n  use = sdk.use;\n  create = sdk.create;\n  sdkLoaded = true;\n}\nvar Mind = class _Mind {\n  memvid;\n  config;\n  sessionId;\n  initialized = false;\n  constructor(memvid, config) {\n    this.memvid = memvid;\n    this.config = config;\n    this.sessionId = generateId();\n  }\n  /**\n   * Open or create a Mind instance\n   */\n  static async open(configOverrides = {}) {\n    await loadSDK();\n    const config = { ...DEFAULT_CONFIG, ...configOverrides };\n    const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\n    const memoryPath = resolve(projectDir, config.memoryPath);\n    const memoryDir = dirname(memoryPath);\n    await mkdir(memoryDir, { recursive: true });\n    let memvid;\n    const MAX_FILE_SIZE_MB = 100;\n    const lockPath = `${memoryPath}.lock`;\n    await withMemvidLock(lockPath, async () => {\n      if (!existsSync(memoryPath)) {\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n      const { statSync, renameSync, unlinkSync: unlinkSync2 } = await import('fs');\n      const fileSize = statSync(memoryPath).size;\n      const fileSizeMB = fileSize / (1024 * 1024);\n      if (fileSizeMB > MAX_FILE_SIZE_MB) {\n        console.error(`[memvid-mind] Memory file too large (${fileSizeMB.toFixed(1)}MB), likely corrupted. Creating fresh memory...`);\n        const backupPath = `${memoryPath}.backup-${Date.now()}`;\n        try {\n          renameSync(memoryPath, backupPath);\n        } catch {\n        }\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n      try {\n        memvid = await use(\"basic\", memoryPath);\n      } catch (openError) {\n        const errorMessage = openError instanceof Error ? openError.message : String(openError);\n        if (errorMessage.includes(\"Deserialization\") || errorMessage.includes(\"UnexpectedVariant\") || errorMessage.includes(\"Invalid\") || errorMessage.includes(\"corrupt\") || errorMessage.includes(\"validation failed\") || errorMessage.includes(\"unable to recover\") || errorMessage.includes(\"table of contents\")) {\n          console.error(\"[memvid-mind] Memory file corrupted, creating fresh memory...\");\n          const backupPath = `${memoryPath}.backup-${Date.now()}`;\n          try {\n            renameSync(memoryPath, backupPath);\n          } catch {\n            try {\n              unlinkSync2(memoryPath);\n            } catch {\n            }\n          }\n          memvid = await create(memoryPath, \"basic\");\n          return;\n        }\n        throw openError;\n      }\n    });\n    const mind = new _Mind(memvid, config);\n    mind.initialized = true;\n    pruneBackups(memoryPath, 3);\n    if (config.debug) {\n      console.error(`[memvid-mind] Opened: ${memoryPath}`);\n    }\n    return mind;\n  }\n  async withLock(fn) {\n    const memoryPath = this.getMemoryPath();\n    const lockPath = `${memoryPath}.lock`;\n    return withMemvidLock(lockPath, fn);\n  }\n  /**\n   * Remember an observation\n   */\n  async remember(input) {\n    const observation = {\n      id: generateId(),\n      timestamp: Date.now(),\n      type: input.type,\n      tool: input.tool,\n      summary: input.summary,\n      content: input.content,\n      metadata: {\n        ...input.metadata,\n        sessionId: this.sessionId\n      }\n    };\n    const frameId = await this.withLock(async () => {\n      return this.memvid.put({\n        title: `[${observation.type}] ${observation.summary}`,\n        label: observation.type,\n        text: observation.content,\n        metadata: {\n          observationId: observation.id,\n          timestamp: observation.timestamp,\n          tool: observation.tool,\n          sessionId: this.sessionId,\n          ...observation.metadata\n        },\n        tags: [observation.type, observation.tool].filter(Boolean)\n      });\n    });\n    if (this.config.debug) {\n      console.error(`[memvid-mind] Remembered: ${observation.summary}`);\n    }\n    return frameId;\n  }\n  /**\n   * Search memories by query (uses fast lexical search)\n   */\n  async search(query, limit = 10) {\n    return this.withLock(async () => {\n      return this.searchUnlocked(query, limit);\n    });\n  }\n  async searchUnlocked(query, limit) {\n    const results = await this.memvid.find(query, { k: limit, mode: \"lex\" });\n    return (results.frames || []).map((frame) => ({\n      observation: {\n        id: frame.metadata?.observationId || frame.frame_id,\n        timestamp: frame.metadata?.timestamp || 0,\n        type: frame.label,\n        tool: frame.metadata?.tool,\n        summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || \"\",\n        content: frame.text || \"\",\n        metadata: frame.metadata\n      },\n      score: frame.score || 0,\n      snippet: frame.snippet || frame.text?.slice(0, 200) || \"\"\n    }));\n  }\n  /**\n   * Ask the memory a question (uses fast lexical search)\n   */\n  async ask(question) {\n    return this.withLock(async () => {\n      const result = await this.memvid.ask(question, { k: 5, mode: \"lex\" });\n      return result.answer || \"No relevant memories found.\";\n    });\n  }\n  /**\n   * Get context for session start\n   */\n  async getContext(query) {\n    return this.withLock(async () => {\n      const timeline = await this.memvid.timeline({\n        limit: this.config.maxContextObservations,\n        reverse: true\n      });\n      const frames = Array.isArray(timeline) ? timeline : timeline.frames || [];\n      const recentObservations = frames.map(\n        (frame) => {\n          let ts = frame.metadata?.timestamp || frame.timestamp || 0;\n          if (ts > 0 && ts < 4102444800) {\n            ts = ts * 1e3;\n          }\n          return {\n            id: frame.metadata?.observationId || frame.frame_id,\n            timestamp: ts,\n            type: frame.label || frame.metadata?.type || \"observation\",\n            tool: frame.metadata?.tool,\n            summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || frame.preview?.slice(0, 100) || \"\",\n            content: frame.text || frame.preview || \"\",\n            metadata: frame.metadata\n          };\n        }\n      );\n      let relevantMemories = [];\n      if (query) {\n        const searchResults = await this.searchUnlocked(query, 10);\n        relevantMemories = searchResults.map((r) => r.observation);\n      }\n      let tokenCount = 0;\n      for (const obs of recentObservations) {\n        const text = `[${obs.type}] ${obs.summary}`;\n        const tokens = estimateTokens(text);\n        if (tokenCount + tokens > this.config.maxContextTokens) break;\n        tokenCount += tokens;\n      }\n      return {\n        recentObservations,\n        relevantMemories,\n        sessionSummaries: [],\n        // TODO: Implement session summaries\n        tokenCount\n      };\n    });\n  }\n  /**\n   * Save a session summary\n   */\n  async saveSessionSummary(summary) {\n    const sessionSummary = {\n      id: this.sessionId,\n      startTime: Date.now() - 36e5,\n      // Approximate\n      endTime: Date.now(),\n      observationCount: 0,\n      // TODO: Track this\n      keyDecisions: summary.keyDecisions,\n      filesModified: summary.filesModified,\n      summary: summary.summary\n    };\n    return this.withLock(async () => {\n      return this.memvid.put({\n        title: `Session Summary: ${(/* @__PURE__ */ new Date()).toISOString().split(\"T\")[0]}`,\n        label: \"session\",\n        text: JSON.stringify(sessionSummary, null, 2),\n        metadata: sessionSummary,\n        tags: [\"session\", \"summary\"]\n      });\n    });\n  }\n  /**\n   * Get memory statistics\n   */\n  async stats() {\n    return this.withLock(async () => {\n      const stats = await this.memvid.stats();\n      const timeline = await this.memvid.timeline({ limit: 1, reverse: false });\n      const recentTimeline = await this.memvid.timeline({ limit: 1, reverse: true });\n      const oldestFrames = Array.isArray(timeline) ? timeline : timeline.frames || [];\n      const newestFrames = Array.isArray(recentTimeline) ? recentTimeline : recentTimeline.frames || [];\n      return {\n        totalObservations: stats.frame_count || 0,\n        totalSessions: 0,\n        // TODO: Count unique sessions\n        oldestMemory: oldestFrames[0]?.metadata?.timestamp || oldestFrames[0]?.timestamp || 0,\n        newestMemory: newestFrames[0]?.metadata?.timestamp || newestFrames[0]?.timestamp || 0,\n        fileSize: stats.size_bytes || 0,\n        topTypes: {}\n        // TODO: Aggregate\n      };\n    });\n  }\n  /**\n   * Get the session ID\n   */\n  getSessionId() {\n    return this.sessionId;\n  }\n  /**\n   * Get the memory file path\n   */\n  getMemoryPath() {\n    return resolve(process.cwd(), this.config.memoryPath);\n  }\n  /**\n   * Check if initialized\n   */\n  isInitialized() {\n    return this.initialized;\n  }\n};\nvar mindInstance = null;\nasync function getMind(config) {\n  if (!mindInstance) {\n    mindInstance = await Mind.open(config);\n  }\n  return mindInstance;\n}\nvar MIN_OBSERVATIONS_FOR_SUMMARY = 3;\nasync function captureFileChanges(mind) {\n  try {\n    const memoryPath = mind.getMemoryPath();\n    const workDir = memoryPath.replace(/\\/\\.claude\\/.*$/, \"\");\n    const allChangedFiles = [];\n    let gitDiffContent = \"\";\n    try {\n      const diffNames = execSync(\"git diff --name-only HEAD 2>/dev/null || git diff --name-only 2>/dev/null || echo ''\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 3e3,\n        stdio: [\"pipe\", \"pipe\", \"pipe\"]\n      }).trim();\n      const stagedNames = execSync(\"git diff --cached --name-only 2>/dev/null || echo ''\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 3e3,\n        stdio: [\"pipe\", \"pipe\", \"pipe\"]\n      }).trim();\n      const gitFiles = [.../* @__PURE__ */ new Set([\n        ...diffNames.split(\"\\n\").filter(Boolean),\n        ...stagedNames.split(\"\\n\").filter(Boolean)\n      ])];\n      allChangedFiles.push(...gitFiles);\n      if (gitFiles.length > 0) {\n        try {\n          gitDiffContent = execSync(\"git diff HEAD --stat 2>/dev/null | head -30\", {\n            cwd: workDir,\n            encoding: \"utf-8\",\n            timeout: 3e3,\n            stdio: [\"pipe\", \"pipe\", \"pipe\"]\n          }).trim();\n        } catch {\n        }\n      }\n    } catch {\n    }\n    try {\n      const recentFiles = execSync(\n        `find . -maxdepth 4 -type f \\\\( -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.jsx\" -o -name \"*.md\" -o -name \"*.json\" -o -name \"*.py\" -o -name \"*.rs\" \\\\) -mmin -30 ! -path \"*/node_modules/*\" ! -path \"*/.git/*\" ! -path \"*/dist/*\" ! -path \"*/build/*\" ! -path \"*/.next/*\" ! -path \"*/target/*\" 2>/dev/null | head -30`,\n        {\n          cwd: workDir,\n          encoding: \"utf-8\",\n          timeout: 5e3,\n          stdio: [\"pipe\", \"pipe\", \"pipe\"]\n        }\n      ).trim();\n      const recentFilesList = recentFiles.split(\"\\n\").filter(Boolean).map((f) => f.replace(/^\\.\\//, \"\"));\n      for (const file of recentFilesList) {\n        if (!allChangedFiles.includes(file)) {\n          allChangedFiles.push(file);\n        }\n      }\n    } catch {\n    }\n    if (allChangedFiles.length === 0) {\n      debug(\"No file changes detected\");\n      return;\n    }\n    debug(`Capturing ${allChangedFiles.length} changed files`);\n    const contentParts = [`## Files Modified This Session\n\n${allChangedFiles.map((f) => `- ${f}`).join(\"\\n\")}`];\n    if (gitDiffContent) {\n      contentParts.push(`\n## Git Changes Summary\n\\`\\`\\`\n${gitDiffContent}\n\\`\\`\\``);\n    }\n    await mind.remember({\n      type: \"refactor\",\n      summary: `Session edits: ${allChangedFiles.length} file(s) modified`,\n      content: contentParts.join(\"\\n\"),\n      tool: \"FileChanges\",\n      metadata: {\n        files: allChangedFiles,\n        fileCount: allChangedFiles.length,\n        captureMethod: \"git-diff-plus-recent\"\n      }\n    });\n    for (const file of allChangedFiles) {\n      const fileName = file.split(\"/\").pop() || file;\n      const isImportant = /^(README|CHANGELOG|package\\.json|Cargo\\.toml|\\.env)/i.test(fileName);\n      if (isImportant) {\n        await mind.remember({\n          type: \"refactor\",\n          summary: `Modified ${fileName}`,\n          content: `File edited: ${file}\nThis file was modified during the session.`,\n          tool: \"FileEdit\",\n          metadata: {\n            files: [file],\n            fileName\n          }\n        });\n        debug(`Stored individual edit: ${fileName}`);\n      }\n    }\n    debug(`Stored file changes: ${allChangedFiles.length} files`);\n  } catch (error) {\n    debug(`Failed to capture file changes: ${error}`);\n  }\n}\nasync function main() {\n  try {\n    const input = await readStdin();\n    const hookInput = JSON.parse(input);\n    debug(`Session stopping: ${hookInput.session_id}`);\n    const mind = await getMind();\n    const stats = await mind.stats();\n    await captureFileChanges(mind);\n    let transcriptContent = \"\";\n    if (hookInput.transcript_path) {\n      try {\n        await access(hookInput.transcript_path, constants.R_OK);\n        transcriptContent = await readFile(hookInput.transcript_path, \"utf-8\");\n      } catch {\n      }\n    }\n    const context = await mind.getContext();\n    const sessionObservations = context.recentObservations.filter(\n      (obs) => obs.metadata?.sessionId === mind.getSessionId()\n    );\n    if (sessionObservations.length >= MIN_OBSERVATIONS_FOR_SUMMARY) {\n      const summary = generateSessionSummary(\n        sessionObservations,\n        transcriptContent\n      );\n      await mind.saveSessionSummary(summary);\n      debug(\n        `Session summary saved: ${summary.keyDecisions.length} decisions, ${summary.filesModified.length} files`\n      );\n    }\n    debug(\n      `Session complete. Total memories: ${stats.totalObservations}, File: ${mind.getMemoryPath()}`\n    );\n    const output = {\n      continue: true\n    };\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    writeOutput({ continue: true });\n  }\n}\nfunction generateSessionSummary(observations, transcript) {\n  const keyDecisions = [];\n  const filesModified = /* @__PURE__ */ new Set();\n  for (const obs of observations) {\n    if (obs.type === \"decision\" || obs.summary.toLowerCase().includes(\"chose\") || obs.summary.toLowerCase().includes(\"decided\")) {\n      keyDecisions.push(obs.summary);\n    }\n    const files = obs.metadata?.files;\n    if (files) {\n      files.forEach((f) => filesModified.add(f));\n    }\n  }\n  if (transcript) {\n    const filePatterns = [\n      /(?:Read|Edit|Write)[^\"]*\"([^\"]+)\"/g,\n      /file_path[\"\\s:]+([^\\s\"]+)/g\n    ];\n    for (const pattern of filePatterns) {\n      let match;\n      while ((match = pattern.exec(transcript)) !== null) {\n        const path = match[1];\n        if (path && !path.includes(\"node_modules\") && !path.startsWith(\".\")) {\n          filesModified.add(path);\n        }\n      }\n    }\n  }\n  const typeCounts = {};\n  for (const obs of observations) {\n    typeCounts[obs.type] = (typeCounts[obs.type] || 0) + 1;\n  }\n  const summaryParts = [];\n  if (typeCounts.feature) {\n    summaryParts.push(`Added ${typeCounts.feature} feature(s)`);\n  }\n  if (typeCounts.bugfix) {\n    summaryParts.push(`Fixed ${typeCounts.bugfix} bug(s)`);\n  }\n  if (typeCounts.refactor) {\n    summaryParts.push(`Refactored ${typeCounts.refactor} item(s)`);\n  }\n  if (typeCounts.discovery) {\n    summaryParts.push(`Made ${typeCounts.discovery} discovery(ies)`);\n  }\n  if (typeCounts.problem) {\n    summaryParts.push(`Encountered ${typeCounts.problem} problem(s)`);\n  }\n  if (typeCounts.solution) {\n    summaryParts.push(`Found ${typeCounts.solution} solution(s)`);\n  }\n  const summary = summaryParts.length > 0 ? summaryParts.join(\". \") + \".\" : `Session with ${observations.length} observations.`;\n  return {\n    keyDecisions: keyDecisions.slice(0, 10),\n    filesModified: Array.from(filesModified).slice(0, 20),\n    summary\n  };\n}\nmain();\n//# sourceMappingURL=stop.js.map\n//# sourceMappingURL=stop.js.map",
        "dist/hooks/stop.js.map": "{\"version\":3,\"sources\":[\"../../src/types.ts\",\"../../src/utils/helpers.ts\",\"../../src/utils/memvid-lock.ts\",\"../../src/core/mind.ts\",\"../../src/hooks/stop.ts\"],\"names\":[\"resolve\",\"dirname\",\"mkdir\",\"unlinkSync\"],\"mappings\":\"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\",\"file\":\"stop.js\",\"sourcesContent\":[\"/**\\n * Memvid Mind - Type Definitions\\n *\\n * Core types for Claude Code memory persistence.\\n */\\n\\n/** Observation captured from tool use */\\nexport interface Observation {\\n  id: string;\\n  timestamp: number;\\n  type: ObservationType;\\n  tool?: string;\\n  summary: string;\\n  content: string;\\n  metadata?: ObservationMetadata;\\n}\\n\\n/** Types of observations */\\nexport type ObservationType =\\n  | \\\"discovery\\\"      // New information discovered\\n  | \\\"decision\\\"       // Decision made\\n  | \\\"problem\\\"        // Problem identified\\n  | \\\"solution\\\"       // Solution implemented\\n  | \\\"pattern\\\"        // Pattern recognized\\n  | \\\"warning\\\"        // Warning or concern\\n  | \\\"success\\\"        // Successful outcome\\n  | \\\"refactor\\\"       // Code refactored\\n  | \\\"bugfix\\\"         // Bug fixed\\n  | \\\"feature\\\";       // Feature added\\n\\n/** Metadata attached to observations */\\nexport interface ObservationMetadata {\\n  files?: string[];\\n  functions?: string[];\\n  error?: string;\\n  confidence?: number;\\n  tags?: string[];\\n  sessionId?: string;\\n  [key: string]: unknown;  // Allow additional properties\\n}\\n\\n/** Session summary stored at end of session */\\nexport interface SessionSummary {\\n  id: string;\\n  startTime: number;\\n  endTime: number;\\n  observationCount: number;\\n  keyDecisions: string[];\\n  filesModified: string[];\\n  summary: string;\\n}\\n\\n/** Context injected at session start */\\nexport interface InjectedContext {\\n  recentObservations: Observation[];\\n  relevantMemories: Observation[];\\n  sessionSummaries: SessionSummary[];\\n  tokenCount: number;\\n}\\n\\n/** Configuration for Memvid Mind */\\nexport interface MindConfig {\\n  /** Path to the .memvid file (default: .mind.mv2 in project root) */\\n  memoryPath: string;\\n  /** Maximum observations to inject at session start */\\n  maxContextObservations: number;\\n  /** Maximum tokens for context injection */\\n  maxContextTokens: number;\\n  /** Whether to auto-compress observations */\\n  autoCompress: boolean;\\n  /** Minimum confidence for storing observations */\\n  minConfidence: number;\\n  /** Enable debug logging */\\n  debug: boolean;\\n}\\n\\n/** Default configuration */\\nexport const DEFAULT_CONFIG: MindConfig = {\\n  memoryPath: \\\".claude/mind.mv2\\\",\\n  maxContextObservations: 20,\\n  maxContextTokens: 2000,\\n  autoCompress: true,\\n  minConfidence: 0.6,\\n  debug: false,\\n};\\n\\n/** Hook input from Claude Code */\\nexport interface HookInput {\\n  session_id: string;\\n  transcript_path?: string;\\n  cwd?: string;\\n  hook_event_name?: string;\\n  permission_mode?: string;\\n  tool_name?: string;\\n  tool_input?: Record<string, unknown>;\\n  tool_response?: unknown; // Can be object or string depending on tool\\n  tool_use_id?: string;\\n}\\n\\n/** Hook output to Claude Code */\\nexport interface HookOutput {\\n  continue?: boolean;\\n  result?: string;\\n  decision?: \\\"block\\\" | \\\"approve\\\" | \\\"modify\\\";\\n  reason?: string;\\n  modified_input?: Record<string, unknown>;\\n}\\n\\n/** Search result from memory */\\nexport interface MemorySearchResult {\\n  observation: Observation;\\n  score: number;\\n  snippet: string;\\n}\\n\\n/** Statistics about the mind file */\\nexport interface MindStats {\\n  totalObservations: number;\\n  totalSessions: number;\\n  oldestMemory: number;\\n  newestMemory: number;\\n  fileSize: number;\\n  topTypes: Record<ObservationType, number>;\\n}\\n\",\"/**\\n * Memvid Mind - Utility Helpers\\n */\\n\\nimport { randomBytes } from \\\"node:crypto\\\";\\n\\n/**\\n * Generate a unique ID\\n */\\nexport function generateId(): string {\\n  return randomBytes(8).toString(\\\"hex\\\");\\n}\\n\\n/**\\n * Estimate token count for text (rough approximation)\\n * ~4 characters per token for English text\\n */\\nexport function estimateTokens(text: string): number {\\n  return Math.ceil(text.length / 4);\\n}\\n\\n/**\\n * Truncate text to fit within token limit\\n */\\nexport function truncateToTokens(text: string, maxTokens: number): string {\\n  const maxChars = maxTokens * 4;\\n  if (text.length <= maxChars) return text;\\n  return text.slice(0, maxChars - 3) + \\\"...\\\";\\n}\\n\\n/**\\n * Format timestamp to human-readable string\\n */\\nexport function formatTimestamp(ts: number): string {\\n  const date = new Date(ts);\\n  const now = new Date();\\n  const diffMs = now.getTime() - date.getTime();\\n  const diffMins = Math.floor(diffMs / 60000);\\n  const diffHours = Math.floor(diffMs / 3600000);\\n  const diffDays = Math.floor(diffMs / 86400000);\\n\\n  if (diffMins < 1) return \\\"just now\\\";\\n  if (diffMins < 60) return `${diffMins}m ago`;\\n  if (diffHours < 24) return `${diffHours}h ago`;\\n  if (diffDays < 7) return `${diffDays}d ago`;\\n\\n  return date.toLocaleDateString();\\n}\\n\\n/**\\n * Parse JSON safely\\n */\\nexport function safeJsonParse<T>(text: string, fallback: T): T {\\n  try {\\n    return JSON.parse(text) as T;\\n  } catch {\\n    return fallback;\\n  }\\n}\\n\\n/**\\n * Read all stdin as string\\n */\\nexport async function readStdin(): Promise<string> {\\n  const chunks: Buffer[] = [];\\n\\n  return new Promise((resolve, reject) => {\\n    process.stdin.on(\\\"data\\\", (chunk) => chunks.push(chunk));\\n    process.stdin.on(\\\"end\\\", () => resolve(Buffer.concat(chunks).toString(\\\"utf8\\\")));\\n    process.stdin.on(\\\"error\\\", reject);\\n  });\\n}\\n\\n/**\\n * Write JSON to stdout and exit immediately\\n * (Prevents SDK background tasks from blocking process exit)\\n */\\nexport function writeOutput(output: unknown): never {\\n  console.log(JSON.stringify(output));\\n  process.exit(0);\\n}\\n\\n/**\\n * Log debug message to stderr\\n */\\nexport function debug(message: string): void {\\n  if (process.env.MEMVID_MIND_DEBUG === \\\"1\\\") {\\n    console.error(`[memvid-mind] ${message}`);\\n  }\\n}\\n\\n/**\\n * Extract key information from tool output\\n */\\nexport function extractKeyInfo(toolName: string, output: string): string {\\n  // Truncate very long outputs\\n  const maxLength = 2000;\\n  const truncated = output.length > maxLength\\n    ? output.slice(0, maxLength) + \\\"\\\\n... (truncated)\\\"\\n    : output;\\n\\n  // Tool-specific extraction\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n      // Extract file summary from read output\\n      return extractFileReadSummary(truncated);\\n    case \\\"Bash\\\":\\n      // Extract command summary\\n      return extractBashSummary(truncated);\\n    case \\\"Edit\\\":\\n      // Extract edit summary\\n      return extractEditSummary(truncated);\\n    case \\\"Grep\\\":\\n    case \\\"Glob\\\":\\n      // Extract search summary\\n      return extractSearchSummary(truncated);\\n    default:\\n      return truncated;\\n  }\\n}\\n\\nfunction extractFileReadSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 20) return output;\\n  return `${lines.slice(0, 10).join(\\\"\\\\n\\\")}\\\\n... (${lines.length} lines total)`;\\n}\\n\\nfunction extractBashSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\");\\n  if (lines.length <= 30) return output;\\n  return [\\n    ...lines.slice(0, 10),\\n    `... (${lines.length - 20} lines omitted)`,\\n    ...lines.slice(-10),\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\nfunction extractEditSummary(output: string): string {\\n  // Edits are usually compact, return as-is\\n  return output;\\n}\\n\\nfunction extractSearchSummary(output: string): string {\\n  const lines = output.split(\\\"\\\\n\\\").filter(Boolean);\\n  if (lines.length <= 20) return output;\\n  return [\\n    ...lines.slice(0, 15),\\n    `... and ${lines.length - 15} more results`,\\n  ].join(\\\"\\\\n\\\");\\n}\\n\\n/**\\n * Classify observation type from tool and output\\n */\\nexport function classifyObservationType(\\n  toolName: string,\\n  output: string\\n): \\\"discovery\\\" | \\\"decision\\\" | \\\"problem\\\" | \\\"solution\\\" | \\\"pattern\\\" | \\\"warning\\\" | \\\"success\\\" | \\\"refactor\\\" | \\\"bugfix\\\" | \\\"feature\\\" {\\n  const lowerOutput = output.toLowerCase();\\n\\n  // Error detection\\n  if (\\n    lowerOutput.includes(\\\"error\\\") ||\\n    lowerOutput.includes(\\\"failed\\\") ||\\n    lowerOutput.includes(\\\"exception\\\")\\n  ) {\\n    return \\\"problem\\\";\\n  }\\n\\n  // Success detection\\n  if (\\n    lowerOutput.includes(\\\"success\\\") ||\\n    lowerOutput.includes(\\\"passed\\\") ||\\n    lowerOutput.includes(\\\"completed\\\")\\n  ) {\\n    return \\\"success\\\";\\n  }\\n\\n  // Warning detection\\n  if (lowerOutput.includes(\\\"warning\\\") || lowerOutput.includes(\\\"deprecated\\\")) {\\n    return \\\"warning\\\";\\n  }\\n\\n  // Tool-based classification\\n  switch (toolName) {\\n    case \\\"Read\\\":\\n    case \\\"Glob\\\":\\n    case \\\"Grep\\\":\\n      return \\\"discovery\\\";\\n    case \\\"Edit\\\":\\n      if (lowerOutput.includes(\\\"fix\\\") || lowerOutput.includes(\\\"bug\\\")) {\\n        return \\\"bugfix\\\";\\n      }\\n      return \\\"refactor\\\";\\n    case \\\"Write\\\":\\n      return \\\"feature\\\";\\n    default:\\n      return \\\"discovery\\\";\\n  }\\n}\\n\",\"import lockfile from \\\"proper-lockfile\\\";\\nimport { mkdir, open } from \\\"node:fs/promises\\\";\\nimport { dirname } from \\\"node:path\\\";\\n\\nconst LOCK_OPTIONS = {\\n  stale: 30000,\\n  retries: {\\n    retries: 1000,\\n    minTimeout: 5,\\n    maxTimeout: 50,\\n  },\\n} as const;\\n\\nexport async function withMemvidLock<T>(\\n  lockPath: string,\\n  fn: () => Promise<T>\\n): Promise<T> {\\n  await mkdir(dirname(lockPath), { recursive: true });\\n  const handle = await open(lockPath, \\\"a\\\");\\n  await handle.close();\\n\\n  const release = await lockfile.lock(lockPath, LOCK_OPTIONS);\\n  try {\\n    return await fn();\\n  } finally {\\n    await release();\\n  }\\n}\\n\",\"/**\\n * Memvid Mind - Core Engine\\n *\\n * The brain behind Claude's persistent memory.\\n * Stores everything in ONE portable .memvid file.\\n */\\n\\n// Use dynamic import to allow smart-install to run first\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\ntype Memvid = any;\\n\\nimport { existsSync, readdirSync, unlinkSync } from \\\"node:fs\\\";\\nimport { resolve, dirname } from \\\"node:path\\\";\\nimport { mkdir } from \\\"node:fs/promises\\\";\\nimport {\\n  type Observation,\\n  type ObservationType,\\n  type SessionSummary,\\n  type InjectedContext,\\n  type MindConfig,\\n  type MindStats,\\n  type MemorySearchResult,\\n  DEFAULT_CONFIG,\\n} from \\\"../types.js\\\";\\nimport { generateId, estimateTokens } from \\\"../utils/helpers.js\\\";\\nimport { withMemvidLock } from \\\"../utils/memvid-lock.js\\\";\\n\\n/**\\n * Prune old backup files, keeping only the most recent N\\n */\\nfunction pruneBackups(memoryPath: string, keepCount: number): void {\\n  try {\\n    const dir = dirname(memoryPath);\\n    const baseName = memoryPath.split(\\\"/\\\").pop() || \\\"mind.mv2\\\";\\n    const backupPattern = new RegExp(`^${baseName.replace(\\\".\\\", \\\"\\\\\\\\.\\\")}\\\\\\\\.backup-\\\\\\\\d+$`);\\n\\n    const files = readdirSync(dir);\\n    const backups = files\\n      .filter(f => backupPattern.test(f))\\n      .map(f => ({\\n        name: f,\\n        path: resolve(dir, f),\\n        time: parseInt(f.split(\\\"-\\\").pop() || \\\"0\\\", 10),\\n      }))\\n      .sort((a, b) => b.time - a.time); // newest first\\n\\n    // Delete old backups beyond keepCount\\n    for (let i = keepCount; i < backups.length; i++) {\\n      try {\\n        unlinkSync(backups[i].path);\\n        console.error(`[memvid-mind] Pruned old backup: ${backups[i].name}`);\\n      } catch {\\n        // Ignore errors deleting backups\\n      }\\n    }\\n  } catch {\\n    // Ignore errors during pruning\\n  }\\n}\\n\\n// Lazy-loaded SDK functions\\nlet sdkLoaded = false;\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\nlet use: any;\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\nlet create: any;\\n\\nasync function loadSDK(): Promise<void> {\\n  if (sdkLoaded) return;\\n  const sdk = await import(\\\"@memvid/sdk\\\");\\n  use = sdk.use;\\n  create = sdk.create;\\n  sdkLoaded = true;\\n}\\n\\n/**\\n * Mind - Claude's portable memory engine\\n *\\n * @example\\n * ```typescript\\n * const mind = await Mind.open();\\n * await mind.remember({\\n *   type: \\\"decision\\\",\\n *   summary: \\\"Chose React over Vue for frontend\\\",\\n *   content: \\\"Decision rationale: team familiarity, ecosystem...\\\"\\n * });\\n *\\n * const context = await mind.getContext(\\\"authentication\\\");\\n * ```\\n */\\nexport class Mind {\\n  private memvid: Memvid;\\n  private config: MindConfig;\\n  private sessionId: string;\\n  private initialized = false;\\n\\n  private constructor(memvid: Memvid, config: MindConfig) {\\n    this.memvid = memvid;\\n    this.config = config;\\n    this.sessionId = generateId();\\n  }\\n\\n  /**\\n   * Open or create a Mind instance\\n   */\\n  static async open(configOverrides: Partial<MindConfig> = {}): Promise<Mind> {\\n    // Load SDK dynamically (allows smart-install to run first)\\n    await loadSDK();\\n\\n    const config = { ...DEFAULT_CONFIG, ...configOverrides };\\n\\n    // Resolve path relative to project dir (use CLAUDE_PROJECT_DIR if available)\\n    const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\\n    const memoryPath = resolve(projectDir, config.memoryPath);\\n    const memoryDir = dirname(memoryPath);\\n\\n    // Ensure directory exists\\n    await mkdir(memoryDir, { recursive: true });\\n\\n    // Open or create the memvid file\\n    let memvid: Memvid;\\n    const MAX_FILE_SIZE_MB = 100; // Files over 100MB are likely corrupted\\n    const lockPath = `${memoryPath}.lock`;\\n\\n    await withMemvidLock(lockPath, async () => {\\n      if (!existsSync(memoryPath)) {\\n        memvid = await create(memoryPath, \\\"basic\\\");\\n        return;\\n      }\\n\\n      // Check file size - very large files are likely corrupted and will hang\\n      const { statSync, renameSync, unlinkSync } = await import(\\\"node:fs\\\");\\n      const fileSize = statSync(memoryPath).size;\\n      const fileSizeMB = fileSize / (1024 * 1024);\\n\\n      if (fileSizeMB > MAX_FILE_SIZE_MB) {\\n        console.error(`[memvid-mind] Memory file too large (${fileSizeMB.toFixed(1)}MB), likely corrupted. Creating fresh memory...`);\\n        const backupPath = `${memoryPath}.backup-${Date.now()}`;\\n        try { renameSync(memoryPath, backupPath); } catch { /* ignore */ }\\n        memvid = await create(memoryPath, \\\"basic\\\");\\n        return;\\n      }\\n\\n      try {\\n        memvid = await use(\\\"basic\\\", memoryPath);\\n      } catch (openError: unknown) {\\n        const errorMessage = openError instanceof Error ? openError.message : String(openError);\\n        // Handle corrupted or incompatible memory files\\n        if (errorMessage.includes(\\\"Deserialization\\\") ||\\n            errorMessage.includes(\\\"UnexpectedVariant\\\") ||\\n            errorMessage.includes(\\\"Invalid\\\") ||\\n            errorMessage.includes(\\\"corrupt\\\") ||\\n            errorMessage.includes(\\\"validation failed\\\") ||\\n            errorMessage.includes(\\\"unable to recover\\\") ||\\n            errorMessage.includes(\\\"table of contents\\\")) {\\n          console.error(\\\"[memvid-mind] Memory file corrupted, creating fresh memory...\\\");\\n          const backupPath = `${memoryPath}.backup-${Date.now()}`;\\n          try {\\n            renameSync(memoryPath, backupPath);\\n          } catch {\\n            try { unlinkSync(memoryPath); } catch { /* ignore */ }\\n          }\\n          memvid = await create(memoryPath, \\\"basic\\\");\\n          return;\\n        }\\n        throw openError;\\n      }\\n    });\\n\\n    const mind = new Mind(memvid, config);\\n    mind.initialized = true;\\n\\n    // Prune old backups (keep only most recent 3)\\n    pruneBackups(memoryPath, 3);\\n\\n    if (config.debug) {\\n      console.error(`[memvid-mind] Opened: ${memoryPath}`);\\n    }\\n\\n    return mind;\\n  }\\n\\n  private async withLock<T>(fn: () => Promise<T>): Promise<T> {\\n    const memoryPath = this.getMemoryPath();\\n    const lockPath = `${memoryPath}.lock`;\\n    return withMemvidLock(lockPath, fn);\\n  }\\n\\n  /**\\n   * Remember an observation\\n   */\\n  async remember(input: {\\n    type: ObservationType;\\n    summary: string;\\n    content: string;\\n    tool?: string;\\n    metadata?: Record<string, unknown>;\\n  }): Promise<string> {\\n    const observation: Observation = {\\n      id: generateId(),\\n      timestamp: Date.now(),\\n      type: input.type,\\n      tool: input.tool,\\n      summary: input.summary,\\n      content: input.content,\\n      metadata: {\\n        ...input.metadata,\\n        sessionId: this.sessionId,\\n      },\\n    };\\n\\n    const frameId = await this.withLock(async () => {\\n      return this.memvid.put({\\n        title: `[${observation.type}] ${observation.summary}`,\\n        label: observation.type,\\n        text: observation.content,\\n        metadata: {\\n          observationId: observation.id,\\n          timestamp: observation.timestamp,\\n          tool: observation.tool,\\n          sessionId: this.sessionId,\\n          ...observation.metadata,\\n        },\\n        tags: [observation.type, observation.tool].filter(Boolean) as string[],\\n      });\\n    });\\n\\n    if (this.config.debug) {\\n      console.error(`[memvid-mind] Remembered: ${observation.summary}`);\\n    }\\n\\n    return frameId;\\n  }\\n\\n  /**\\n   * Search memories by query (uses fast lexical search)\\n   */\\n  async search(query: string, limit = 10): Promise<MemorySearchResult[]> {\\n    return this.withLock(async () => {\\n      return this.searchUnlocked(query, limit);\\n    });\\n  }\\n\\n  private async searchUnlocked(query: string, limit: number): Promise<MemorySearchResult[]> {\\n    const results = await this.memvid.find(query, { k: limit, mode: \\\"lex\\\" });\\n\\n    return (results.frames || []).map((frame: any) => ({\\n      observation: {\\n        id: frame.metadata?.observationId || frame.frame_id,\\n        timestamp: frame.metadata?.timestamp || 0,\\n        type: frame.label as ObservationType,\\n        tool: frame.metadata?.tool,\\n        summary: frame.title?.replace(/^\\\\[.*?\\\\]\\\\s*/, \\\"\\\") || \\\"\\\",\\n        content: frame.text || \\\"\\\",\\n        metadata: frame.metadata,\\n      },\\n      score: frame.score || 0,\\n      snippet: frame.snippet || frame.text?.slice(0, 200) || \\\"\\\",\\n    }));\\n  }\\n\\n  /**\\n   * Ask the memory a question (uses fast lexical search)\\n   */\\n  async ask(question: string): Promise<string> {\\n    return this.withLock(async () => {\\n      const result = await this.memvid.ask(question, { k: 5, mode: \\\"lex\\\" });\\n      return result.answer || \\\"No relevant memories found.\\\";\\n    });\\n  }\\n\\n  /**\\n   * Get context for session start\\n   */\\n  async getContext(query?: string): Promise<InjectedContext> {\\n    return this.withLock(async () => {\\n      // Get recent observations via timeline\\n      const timeline = await this.memvid.timeline({\\n        limit: this.config.maxContextObservations,\\n        reverse: true,\\n      });\\n\\n      // SDK returns array directly or { frames: [...] }\\n      const frames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\\n\\n      const recentObservations: Observation[] = frames.map(\\n        (frame: any) => {\\n          // Get timestamp - SDK returns seconds, convert to milliseconds if needed\\n          let ts = frame.metadata?.timestamp || frame.timestamp || 0;\\n          // If timestamp looks like seconds (before year 2100 in seconds), convert to ms\\n          if (ts > 0 && ts < 4102444800) {\\n            ts = ts * 1000;\\n          }\\n          return {\\n            id: frame.metadata?.observationId || frame.frame_id,\\n            timestamp: ts,\\n            type: (frame.label || frame.metadata?.type || \\\"observation\\\") as ObservationType,\\n            tool: frame.metadata?.tool,\\n            summary: frame.title?.replace(/^\\\\[.*?\\\\]\\\\s*/, \\\"\\\") || frame.preview?.slice(0, 100) || \\\"\\\",\\n            content: frame.text || frame.preview || \\\"\\\",\\n            metadata: frame.metadata,\\n          };\\n        }\\n      );\\n\\n      // Get relevant memories if query provided\\n      let relevantMemories: Observation[] = [];\\n      if (query) {\\n        const searchResults = await this.searchUnlocked(query, 10);\\n        relevantMemories = searchResults.map((r) => r.observation);\\n      }\\n\\n      // Build context with token limit\\n      const contextParts: string[] = [];\\n      let tokenCount = 0;\\n\\n      // Add recent observations\\n      for (const obs of recentObservations) {\\n        const text = `[${obs.type}] ${obs.summary}`;\\n        const tokens = estimateTokens(text);\\n        if (tokenCount + tokens > this.config.maxContextTokens) break;\\n        contextParts.push(text);\\n        tokenCount += tokens;\\n      }\\n\\n      return {\\n        recentObservations,\\n        relevantMemories,\\n        sessionSummaries: [], // TODO: Implement session summaries\\n        tokenCount,\\n      };\\n    });\\n  }\\n\\n  /**\\n   * Save a session summary\\n   */\\n  async saveSessionSummary(summary: {\\n    keyDecisions: string[];\\n    filesModified: string[];\\n    summary: string;\\n  }): Promise<string> {\\n    const sessionSummary: SessionSummary = {\\n      id: this.sessionId,\\n      startTime: Date.now() - 3600000, // Approximate\\n      endTime: Date.now(),\\n      observationCount: 0, // TODO: Track this\\n      keyDecisions: summary.keyDecisions,\\n      filesModified: summary.filesModified,\\n      summary: summary.summary,\\n    };\\n\\n    return this.withLock(async () => {\\n      return this.memvid.put({\\n        title: `Session Summary: ${new Date().toISOString().split(\\\"T\\\")[0]}`,\\n        label: \\\"session\\\",\\n        text: JSON.stringify(sessionSummary, null, 2),\\n        metadata: sessionSummary as unknown as Record<string, unknown>,\\n        tags: [\\\"session\\\", \\\"summary\\\"],\\n      });\\n    });\\n  }\\n\\n  /**\\n   * Get memory statistics\\n   */\\n  async stats(): Promise<MindStats> {\\n    return this.withLock(async () => {\\n      const stats = await this.memvid.stats();\\n      const timeline = await this.memvid.timeline({ limit: 1, reverse: false });\\n      const recentTimeline = await this.memvid.timeline({ limit: 1, reverse: true });\\n\\n      // SDK returns array directly or { frames: [...] }\\n      const oldestFrames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\\n      const newestFrames = Array.isArray(recentTimeline) ? recentTimeline : (recentTimeline.frames || []);\\n\\n      return {\\n        totalObservations: (stats.frame_count as number) || 0,\\n        totalSessions: 0, // TODO: Count unique sessions\\n        oldestMemory: (oldestFrames[0] as any)?.metadata?.timestamp || (oldestFrames[0] as any)?.timestamp || 0,\\n        newestMemory: (newestFrames[0] as any)?.metadata?.timestamp || (newestFrames[0] as any)?.timestamp || 0,\\n        fileSize: (stats.size_bytes as number) || 0,\\n        topTypes: {} as Record<ObservationType, number>, // TODO: Aggregate\\n      };\\n    });\\n  }\\n\\n  /**\\n   * Get the session ID\\n   */\\n  getSessionId(): string {\\n    return this.sessionId;\\n  }\\n\\n  /**\\n   * Get the memory file path\\n   */\\n  getMemoryPath(): string {\\n    return resolve(process.cwd(), this.config.memoryPath);\\n  }\\n\\n  /**\\n   * Check if initialized\\n   */\\n  isInitialized(): boolean {\\n    return this.initialized;\\n  }\\n}\\n\\n// Singleton instance for hooks\\nlet mindInstance: Mind | null = null;\\n\\n/**\\n * Get or create the Mind singleton\\n */\\nexport async function getMind(config?: Partial<MindConfig>): Promise<Mind> {\\n  if (!mindInstance) {\\n    mindInstance = await Mind.open(config);\\n  }\\n  return mindInstance;\\n}\\n\\n/**\\n * Reset the Mind singleton (for testing)\\n */\\nexport function resetMind(): void {\\n  mindInstance = null;\\n}\\n\",\"#!/usr/bin/env node\\n/**\\n * Memvid Mind - Stop Hook\\n *\\n * AUTO SESSION SUMMARY\\n * Runs when Claude session ends.\\n * Generates an intelligent session summary for future reference.\\n *\\n * WORKAROUND: Since PostToolUse doesn't fire for Edit operations (Claude Code bug),\\n * we capture git diff at session end to record all file modifications.\\n */\\n\\nimport { getMind } from \\\"../core/mind.js\\\";\\nimport { readStdin, writeOutput, debug } from \\\"../utils/helpers.js\\\";\\nimport type { HookInput, HookOutput } from \\\"../types.js\\\";\\nimport { readFile, access } from \\\"node:fs/promises\\\";\\nimport { constants } from \\\"node:fs\\\";\\nimport { execSync } from \\\"node:child_process\\\";\\n\\n// Minimum observations to generate a session summary\\nconst MIN_OBSERVATIONS_FOR_SUMMARY = 3;\\n\\n/**\\n * Capture file modifications at session end\\n * WORKAROUND for Claude Code bug: PostToolUse hooks don't fire for Edit operations\\n *\\n * Captures both:\\n * 1. Git tracked files that changed (git diff)\\n * 2. Recently modified files in untracked directories (find -mmin)\\n */\\nasync function captureFileChanges(mind: Awaited<ReturnType<typeof getMind>>) {\\n  try {\\n    // Get the working directory from the mind's memory path\\n    const memoryPath = mind.getMemoryPath();\\n    const workDir = memoryPath.replace(/\\\\/\\\\.claude\\\\/.*$/, \\\"\\\");\\n\\n    const allChangedFiles: string[] = [];\\n    let gitDiffContent = \\\"\\\";\\n\\n    // 1. Get git tracked changes (staged and unstaged)\\n    // Use shorter timeouts to avoid blocking session end\\n    try {\\n      const diffNames = execSync(\\\"git diff --name-only HEAD 2>/dev/null || git diff --name-only 2>/dev/null || echo ''\\\", {\\n        cwd: workDir,\\n        encoding: \\\"utf-8\\\",\\n        timeout: 3000,\\n        stdio: ['pipe', 'pipe', 'pipe'],\\n      }).trim();\\n\\n      const stagedNames = execSync(\\\"git diff --cached --name-only 2>/dev/null || echo ''\\\", {\\n        cwd: workDir,\\n        encoding: \\\"utf-8\\\",\\n        timeout: 3000,\\n        stdio: ['pipe', 'pipe', 'pipe'],\\n      }).trim();\\n\\n      const gitFiles = [...new Set([\\n        ...diffNames.split(\\\"\\\\n\\\").filter(Boolean),\\n        ...stagedNames.split(\\\"\\\\n\\\").filter(Boolean),\\n      ])];\\n\\n      allChangedFiles.push(...gitFiles);\\n\\n      // Get git diff stat for tracked files\\n      if (gitFiles.length > 0) {\\n        try {\\n          gitDiffContent = execSync(\\\"git diff HEAD --stat 2>/dev/null | head -30\\\", {\\n            cwd: workDir,\\n            encoding: \\\"utf-8\\\",\\n            timeout: 3000,\\n            stdio: ['pipe', 'pipe', 'pipe'],\\n          }).trim();\\n        } catch {\\n          // Ignore\\n        }\\n      }\\n    } catch {\\n      // Not a git repo or git not available - continue to find recent files\\n    }\\n\\n    // 2. Find recently modified files (last 30 minutes) in common code directories\\n    // This catches changes in untracked directories\\n    // Use -maxdepth to limit search and exclude common large dirs for speed\\n    // Reduced timeout and scope to avoid hanging\\n    try {\\n      const recentFiles = execSync(\\n        `find . -maxdepth 4 -type f \\\\\\\\( -name \\\"*.ts\\\" -o -name \\\"*.tsx\\\" -o -name \\\"*.js\\\" -o -name \\\"*.jsx\\\" -o -name \\\"*.md\\\" -o -name \\\"*.json\\\" -o -name \\\"*.py\\\" -o -name \\\"*.rs\\\" \\\\\\\\) -mmin -30 ! -path \\\"*/node_modules/*\\\" ! -path \\\"*/.git/*\\\" ! -path \\\"*/dist/*\\\" ! -path \\\"*/build/*\\\" ! -path \\\"*/.next/*\\\" ! -path \\\"*/target/*\\\" 2>/dev/null | head -30`,\\n        {\\n          cwd: workDir,\\n          encoding: \\\"utf-8\\\",\\n          timeout: 5000,\\n          stdio: ['pipe', 'pipe', 'pipe'],\\n        }\\n      ).trim();\\n\\n      const recentFilesList = recentFiles.split(\\\"\\\\n\\\").filter(Boolean).map(f => f.replace(/^\\\\.\\\\//, \\\"\\\"));\\n\\n      // Add files not already in the list\\n      for (const file of recentFilesList) {\\n        if (!allChangedFiles.includes(file)) {\\n          allChangedFiles.push(file);\\n        }\\n      }\\n    } catch {\\n      // find command failed, continue with what we have\\n    }\\n\\n    if (allChangedFiles.length === 0) {\\n      debug(\\\"No file changes detected\\\");\\n      return;\\n    }\\n\\n    debug(`Capturing ${allChangedFiles.length} changed files`);\\n\\n    // Build content summary\\n    const contentParts = [`## Files Modified This Session\\\\n\\\\n${allChangedFiles.map(f => `- ${f}`).join(\\\"\\\\n\\\")}`];\\n\\n    if (gitDiffContent) {\\n      contentParts.push(`\\\\n## Git Changes Summary\\\\n\\\\`\\\\`\\\\`\\\\n${gitDiffContent}\\\\n\\\\`\\\\`\\\\``);\\n    }\\n\\n    // Store the changes as a memory\\n    await mind.remember({\\n      type: \\\"refactor\\\",\\n      summary: `Session edits: ${allChangedFiles.length} file(s) modified`,\\n      content: contentParts.join(\\\"\\\\n\\\"),\\n      tool: \\\"FileChanges\\\",\\n      metadata: {\\n        files: allChangedFiles,\\n        fileCount: allChangedFiles.length,\\n        captureMethod: \\\"git-diff-plus-recent\\\",\\n      },\\n    });\\n\\n    // Also store individual entries for important file types (README, config, etc.)\\n    // so they're searchable by name\\n    for (const file of allChangedFiles) {\\n      const fileName = file.split(\\\"/\\\").pop() || file;\\n      const isImportant = /^(README|CHANGELOG|package\\\\.json|Cargo\\\\.toml|\\\\.env)/i.test(fileName);\\n\\n      if (isImportant) {\\n        await mind.remember({\\n          type: \\\"refactor\\\",\\n          summary: `Modified ${fileName}`,\\n          content: `File edited: ${file}\\\\nThis file was modified during the session.`,\\n          tool: \\\"FileEdit\\\",\\n          metadata: {\\n            files: [file],\\n            fileName,\\n          },\\n        });\\n        debug(`Stored individual edit: ${fileName}`);\\n      }\\n    }\\n\\n    debug(`Stored file changes: ${allChangedFiles.length} files`);\\n  } catch (error) {\\n    debug(`Failed to capture file changes: ${error}`);\\n  }\\n}\\n\\nasync function main() {\\n  try {\\n    // Read hook input from stdin\\n    const input = await readStdin();\\n    const hookInput: HookInput = JSON.parse(input);\\n\\n    debug(`Session stopping: ${hookInput.session_id}`);\\n\\n    // Initialize mind\\n    const mind = await getMind();\\n    const stats = await mind.stats();\\n\\n    // WORKAROUND: Capture file changes since PostToolUse doesn't fire for Edit\\n    await captureFileChanges(mind);\\n\\n    // Try to read the transcript for richer summary\\n    let transcriptContent = \\\"\\\";\\n    if (hookInput.transcript_path) {\\n      try {\\n        await access(hookInput.transcript_path, constants.R_OK);\\n        transcriptContent = await readFile(hookInput.transcript_path, \\\"utf-8\\\");\\n      } catch {\\n        // Transcript not available, that's ok\\n      }\\n    }\\n\\n    // Get recent observations from this session\\n    const context = await mind.getContext();\\n    const sessionObservations = context.recentObservations.filter(\\n      (obs) => obs.metadata?.sessionId === mind.getSessionId()\\n    );\\n\\n    // Generate session summary if we have enough observations\\n    if (sessionObservations.length >= MIN_OBSERVATIONS_FOR_SUMMARY) {\\n      const summary = generateSessionSummary(\\n        sessionObservations,\\n        transcriptContent\\n      );\\n\\n      // Save the session summary\\n      await mind.saveSessionSummary(summary);\\n\\n      debug(\\n        `Session summary saved: ${summary.keyDecisions.length} decisions, ${summary.filesModified.length} files`\\n      );\\n    }\\n\\n    debug(\\n      `Session complete. Total memories: ${stats.totalObservations}, File: ${mind.getMemoryPath()}`\\n    );\\n\\n    // Continue without blocking\\n    const output: HookOutput = {\\n      continue: true,\\n    };\\n\\n    writeOutput(output);\\n  } catch (error) {\\n    debug(`Error: ${error}`);\\n    // Don't block on errors\\n    writeOutput({ continue: true });\\n  }\\n}\\n\\n/**\\n * Generate a session summary from observations\\n */\\nfunction generateSessionSummary(\\n  observations: Array<{\\n    type: string;\\n    summary: string;\\n    content: string;\\n    metadata?: { files?: string[]; sessionId?: string; [key: string]: unknown };\\n  }>,\\n  transcript: string\\n): {\\n  keyDecisions: string[];\\n  filesModified: string[];\\n  summary: string;\\n} {\\n  // Extract key decisions\\n  const keyDecisions: string[] = [];\\n  const filesModified = new Set<string>();\\n\\n  for (const obs of observations) {\\n    // Track decisions\\n    if (\\n      obs.type === \\\"decision\\\" ||\\n      obs.summary.toLowerCase().includes(\\\"chose\\\") ||\\n      obs.summary.toLowerCase().includes(\\\"decided\\\")\\n    ) {\\n      keyDecisions.push(obs.summary);\\n    }\\n\\n    // Track files from metadata\\n    const files = obs.metadata?.files as string[] | undefined;\\n    if (files) {\\n      files.forEach((f) => filesModified.add(f));\\n    }\\n  }\\n\\n  // Extract file paths from transcript if available\\n  if (transcript) {\\n    const filePatterns = [\\n      /(?:Read|Edit|Write)[^\\\"]*\\\"([^\\\"]+)\\\"/g,\\n      /file_path[\\\"\\\\s:]+([^\\\\s\\\"]+)/g,\\n    ];\\n\\n    for (const pattern of filePatterns) {\\n      let match;\\n      while ((match = pattern.exec(transcript)) !== null) {\\n        const path = match[1];\\n        if (path && !path.includes(\\\"node_modules\\\") && !path.startsWith(\\\".\\\")) {\\n          filesModified.add(path);\\n        }\\n      }\\n    }\\n  }\\n\\n  // Generate summary based on observation types\\n  const typeCounts: Record<string, number> = {};\\n  for (const obs of observations) {\\n    typeCounts[obs.type] = (typeCounts[obs.type] || 0) + 1;\\n  }\\n\\n  const summaryParts: string[] = [];\\n\\n  if (typeCounts.feature) {\\n    summaryParts.push(`Added ${typeCounts.feature} feature(s)`);\\n  }\\n  if (typeCounts.bugfix) {\\n    summaryParts.push(`Fixed ${typeCounts.bugfix} bug(s)`);\\n  }\\n  if (typeCounts.refactor) {\\n    summaryParts.push(`Refactored ${typeCounts.refactor} item(s)`);\\n  }\\n  if (typeCounts.discovery) {\\n    summaryParts.push(`Made ${typeCounts.discovery} discovery(ies)`);\\n  }\\n  if (typeCounts.problem) {\\n    summaryParts.push(`Encountered ${typeCounts.problem} problem(s)`);\\n  }\\n  if (typeCounts.solution) {\\n    summaryParts.push(`Found ${typeCounts.solution} solution(s)`);\\n  }\\n\\n  const summary =\\n    summaryParts.length > 0\\n      ? summaryParts.join(\\\". \\\") + \\\".\\\"\\n      : `Session with ${observations.length} observations.`;\\n\\n  return {\\n    keyDecisions: keyDecisions.slice(0, 10),\\n    filesModified: Array.from(filesModified).slice(0, 20),\\n    summary,\\n  };\\n}\\n\\nmain();\\n\"]}",
        "hooks/hooks.json": "{\n  \"description\": \"Memvid Mind - Persistent memory for Claude Code\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/smart-install.js\\\"\",\n            \"timeout\": 30\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/session-start.js\\\"\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/post-tool-use.js\\\"\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/stop.js\\\"\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "skills/memory/SKILL.md": "---\nname: memory\ndescription: Claude Mind - Search and manage Claude's persistent memory stored in a single portable .mv2 file\n---\n\n# Claude Mind\n\nYou have access to a persistent memory system powered by Claude Mind. All your observations, discoveries, and learnings are stored in a single `.claude/mind.mv2` file.\n\n## How to Execute Memory Commands\n\nUse the bundled SDK scripts via Node.js (NOT the CLI). The scripts are at `${CLAUDE_PLUGIN_ROOT}/dist/scripts/`.\n\n### Search Memories\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/find.js\" \"<query>\" [limit]\n```\n\nExamples:\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/find.js\" \"authentication\" 5`\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/find.js\" \"database schema\" 10`\n\n### Ask Questions\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/ask.js\" \"<question>\"\n```\n\nExamples:\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/ask.js\" \"Why did we choose React?\"`\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/ask.js\" \"What was the CORS solution?\"`\n\n### View Statistics\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/stats.js\"\n```\n\n### View Recent Memories\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/timeline.js\" [count]\n```\n\n## Memory Types\n\nMemories are automatically classified into these types:\n- **discovery** - New information discovered\n- **decision** - Important decisions made\n- **problem** - Problems or errors encountered\n- **solution** - Solutions implemented\n- **pattern** - Patterns recognized in code/data\n- **warning** - Warnings or concerns noted\n- **success** - Successful outcomes\n- **refactor** - Code refactoring done\n- **bugfix** - Bugs fixed\n- **feature** - Features added\n\n## File Location\n\nYour memory is stored at: `.claude/mind.mv2`\n\nThis file is:\n- **Portable** - Copy it anywhere, share with teammates\n- **Git-friendly** - Commit to version control\n- **Self-contained** - Everything in ONE file\n- **Searchable** - Instant semantic search\n\n## Usage Tips\n\n1. **Start of session**: Recent memories are automatically injected as context\n2. **During coding**: Observations are captured automatically from tool use\n3. **Searching**: Use natural language queries to find relevant past context\n4. **Sharing**: Send the `.mind.mv2` file to teammates for instant onboarding\n",
        "skills/mind/SKILL.md": "---\nname: mind\ndescription: Claude Mind - Search and manage Claude's persistent memory stored in a single portable .mv2 file\n---\n\n# Claude Mind\n\nYou have access to a persistent memory system powered by Claude Mind. All your observations, discoveries, and learnings are stored in a single `.claude/mind.mv2` file.\n\n## How to Execute Memory Commands\n\nUse the bundled SDK scripts via Node.js (NOT the CLI). The scripts are at `${CLAUDE_PLUGIN_ROOT}/dist/scripts/`.\n\n### Search Memories\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/find.js\" \"<query>\" [limit]\n```\n\nExamples:\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/find.js\" \"authentication\" 5`\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/find.js\" \"database schema\" 10`\n\n### Ask Questions\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/ask.js\" \"<question>\"\n```\n\nExamples:\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/ask.js\" \"Why did we choose React?\"`\n- `node \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/ask.js\" \"What was the CORS solution?\"`\n\n### View Statistics\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/stats.js\"\n```\n\n### View Recent Memories\n```bash\nnode \"${CLAUDE_PLUGIN_ROOT}/dist/scripts/timeline.js\" [count]\n```\n\n## Memory Types\n\nMemories are automatically classified into these types:\n- **discovery** - New information discovered\n- **decision** - Important decisions made\n- **problem** - Problems or errors encountered\n- **solution** - Solutions implemented\n- **pattern** - Patterns recognized in code/data\n- **warning** - Warnings or concerns noted\n- **success** - Successful outcomes\n- **refactor** - Code refactoring done\n- **bugfix** - Bugs fixed\n- **feature** - Features added\n\n## File Location\n\nYour memory is stored at: `.claude/mind.mv2`\n\nThis file is:\n- **Portable** - Copy it anywhere, share with teammates\n- **Git-friendly** - Commit to version control\n- **Self-contained** - Everything in ONE file\n- **Searchable** - Instant semantic search\n\n## Usage Tips\n\n1. **Start of session**: Recent memories are automatically injected as context\n2. **During coding**: Observations are captured automatically from tool use\n3. **Searching**: Use natural language queries to find relevant past context\n4. **Sharing**: Send the `.mind.mv2` file to teammates for instant onboarding\n",
        "src/hooks/hooks.json": "{\n  \"description\": \"Memvid Mind - Persistent memory for Claude Code\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/smart-install.js\\\"\",\n            \"timeout\": 30\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/session-start.js\\\"\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/post-tool-use.js\\\"\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/dist/hooks/stop.js\\\"\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "src/hooks/post-tool-use.ts": "#!/usr/bin/env node\n/**\n * Memvid Mind - Post Tool Use Hook\n *\n * Captures observations after each tool execution.\n * Uses ENDLESS MODE compression to store 20x more context.\n * Intelligently extracts key learnings and stores them for future sessions.\n */\n\nimport { getMind } from \"../core/mind.js\";\nimport {\n  readStdin,\n  writeOutput,\n  debug,\n  classifyObservationType,\n} from \"../utils/helpers.js\";\nimport {\n  compressToolOutput,\n  getCompressionStats,\n} from \"../utils/compression.js\";\nimport type { HookInput } from \"../types.js\";\n\n// Tools worth capturing observations from\nconst OBSERVED_TOOLS = new Set([\n  \"Read\",\n  \"Edit\",\n  \"Write\",\n  \"Update\",  // Claude Code may use Update for edits\n  \"Bash\",\n  \"Grep\",\n  \"Glob\",\n  \"WebFetch\",\n  \"WebSearch\",\n  \"Task\",\n  \"NotebookEdit\",\n]);\n\n// Minimum output length to consider capturing\nconst MIN_OUTPUT_LENGTH = 50;\n\n// Simple in-memory dedup cache to avoid storing duplicate observations\n// Key: hash of tool+input, Value: timestamp of last capture\nconst recentObservations = new Map<string, number>();\nconst DEDUP_WINDOW_MS = 60000; // 1 minute - don't re-capture same thing within this window\n\nfunction getObservationKey(toolName: string, toolInput: Record<string, unknown> | undefined): string {\n  const inputStr = toolInput ? JSON.stringify(toolInput).slice(0, 200) : \"\";\n  return `${toolName}:${inputStr}`;\n}\n\nfunction isDuplicate(key: string): boolean {\n  const lastSeen = recentObservations.get(key);\n  if (!lastSeen) return false;\n  return Date.now() - lastSeen < DEDUP_WINDOW_MS;\n}\n\nfunction markObserved(key: string): void {\n  recentObservations.set(key, Date.now());\n  // Clean old entries\n  if (recentObservations.size > 100) {\n    const now = Date.now();\n    for (const [k, v] of recentObservations.entries()) {\n      if (now - v > DEDUP_WINDOW_MS * 2) {\n        recentObservations.delete(k);\n      }\n    }\n  }\n}\n\n// Tools that should ALWAYS be captured regardless of output length\nconst ALWAYS_CAPTURE_TOOLS = new Set([\"Edit\", \"Write\", \"Update\", \"NotebookEdit\"]);\n\n// Maximum output length after compression\nconst MAX_OUTPUT_LENGTH = 2500;\n\nasync function main() {\n  try {\n    // Read hook input from stdin\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    const { tool_name, tool_input, tool_response } = hookInput;\n\n    // Debug: Log all tool names to understand what we're receiving\n    debug(`Tool received: ${tool_name}`);\n\n    // Skip if not a tool we observe\n    if (!tool_name || !OBSERVED_TOOLS.has(tool_name)) {\n      debug(`Skipping tool: ${tool_name} (not in OBSERVED_TOOLS)`);\n      writeOutput({ continue: true });\n      return;\n    }\n\n    // Deduplication check - avoid storing the same observation within a short window\n    const dedupKey = getObservationKey(tool_name, tool_input);\n    if (isDuplicate(dedupKey)) {\n      debug(`Skipping duplicate observation: ${tool_name}`);\n      writeOutput({ continue: true });\n      return;\n    }\n\n    // Convert tool_response to string (it can be object or string)\n    const tool_output = typeof tool_response === 'string'\n      ? tool_response\n      : JSON.stringify(tool_response, null, 2);\n\n    // Skip if output is too short or missing (but ALWAYS capture file modifications)\n    const alwaysCapture = ALWAYS_CAPTURE_TOOLS.has(tool_name);\n    if (!alwaysCapture && (!tool_output || tool_output.length < MIN_OUTPUT_LENGTH)) {\n      writeOutput({ continue: true });\n      return;\n    }\n\n    // For file modifications with minimal output, create a descriptive content\n    let effectiveOutput = tool_output || \"\";\n    if (alwaysCapture && effectiveOutput.length < MIN_OUTPUT_LENGTH) {\n      const filePath = tool_input?.file_path as string || \"unknown file\";\n      const fileName = filePath.split(\"/\").pop() || \"file\";\n      effectiveOutput = `File modified: ${fileName}\\nPath: ${filePath}\\nTool: ${tool_name}`;\n    }\n\n    // Skip system reminders and internal content\n    if (\n      effectiveOutput.includes(\"<system-reminder>\") ||\n      effectiveOutput.includes(\"<memvid-mind-context>\")\n    ) {\n      writeOutput({ continue: true });\n      return;\n    }\n\n    // ENDLESS MODE: Compress large outputs to ~500 tokens\n    const { compressed, wasCompressed, originalSize } = compressToolOutput(\n      tool_name,\n      tool_input,\n      effectiveOutput\n    );\n\n    if (wasCompressed) {\n      const stats = getCompressionStats(originalSize, compressed.length);\n      debug(`🗜️ Endless Mode: ${stats.savedPercent}% compression (${originalSize} → ${compressed.length} chars)`);\n    }\n\n    debug(`Capturing observation from ${tool_name}`);\n\n    // Initialize mind\n    const mind = await getMind();\n\n    // Extract and classify the observation\n    const observationType = classifyObservationType(tool_name, compressed);\n\n    // Generate a summary based on tool type\n    const summary = generateSummary(tool_name, tool_input, effectiveOutput);\n\n    // Use compressed content (already within limits)\n    const content = compressed.length > MAX_OUTPUT_LENGTH\n      ? compressed.slice(0, MAX_OUTPUT_LENGTH) + \"\\n... (compressed)\"\n      : compressed;\n\n    // Extract metadata with compression flag\n    const metadata = extractMetadata(tool_name, tool_input);\n    if (wasCompressed) {\n      metadata.compressed = true;\n      metadata.originalSize = originalSize;\n      metadata.compressedSize = compressed.length;\n    }\n\n    // Store the observation\n    await mind.remember({\n      type: observationType,\n      summary,\n      content,\n      tool: tool_name,\n      metadata,\n    });\n\n    // Mark as observed for deduplication\n    markObserved(dedupKey);\n\n    debug(`Stored: [${observationType}] ${summary}${wasCompressed ? \" (compressed)\" : \"\"}`);\n\n    // Continue without blocking\n    writeOutput({ continue: true });\n  } catch (error) {\n    debug(`Error: ${error}`);\n    // Don't block on errors\n    writeOutput({ continue: true });\n  }\n}\n\n/**\n * Generate a summary based on tool type and input\n */\nfunction generateSummary(\n  toolName: string,\n  toolInput: Record<string, unknown> | undefined,\n  toolOutput: string\n): string {\n  switch (toolName) {\n    case \"Read\": {\n      const path = toolInput?.file_path as string;\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      const lines = toolOutput.split(\"\\n\").length;\n      return `Read ${fileName} (${lines} lines)`;\n    }\n\n    case \"Edit\": {\n      const path = toolInput?.file_path as string;\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      return `Edited ${fileName}`;\n    }\n\n    case \"Write\": {\n      const path = toolInput?.file_path as string;\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      return `Created ${fileName}`;\n    }\n\n    case \"Bash\": {\n      const cmd = toolInput?.command as string;\n      const shortCmd = cmd?.split(\"\\n\")[0].slice(0, 50) || \"command\";\n      const hasError =\n        toolOutput.toLowerCase().includes(\"error\") ||\n        toolOutput.toLowerCase().includes(\"failed\");\n      return hasError ? `Command failed: ${shortCmd}` : `Ran: ${shortCmd}`;\n    }\n\n    case \"Grep\": {\n      const pattern = toolInput?.pattern as string;\n      const matches = toolOutput.split(\"\\n\").filter(Boolean).length;\n      return `Found ${matches} matches for \"${pattern?.slice(0, 30)}\"`;\n    }\n\n    case \"Glob\": {\n      const pattern = toolInput?.pattern as string;\n      const matches = toolOutput.split(\"\\n\").filter(Boolean).length;\n      return `Found ${matches} files matching \"${pattern?.slice(0, 30)}\"`;\n    }\n\n    case \"WebFetch\":\n    case \"WebSearch\": {\n      const url = (toolInput?.url as string) || (toolInput?.query as string);\n      return `Fetched: ${url?.slice(0, 50)}`;\n    }\n\n    default:\n      return `${toolName} completed`;\n  }\n}\n\n/**\n * Extract metadata from tool input\n */\nfunction extractMetadata(\n  toolName: string,\n  toolInput: Record<string, unknown> | undefined\n): Record<string, unknown> {\n  const metadata: Record<string, unknown> = {};\n\n  if (!toolInput) return metadata;\n\n  switch (toolName) {\n    case \"Read\":\n    case \"Edit\":\n    case \"Write\":\n      if (toolInput.file_path) {\n        metadata.files = [toolInput.file_path];\n      }\n      break;\n\n    case \"Bash\":\n      if (toolInput.command) {\n        metadata.command = (toolInput.command as string).slice(0, 200);\n      }\n      break;\n\n    case \"Grep\":\n    case \"Glob\":\n      if (toolInput.pattern) {\n        metadata.pattern = toolInput.pattern;\n      }\n      if (toolInput.path) {\n        metadata.searchPath = toolInput.path;\n      }\n      break;\n  }\n\n  return metadata;\n}\n\nmain();\n",
        "src/hooks/session-start.ts": "#!/usr/bin/env node\n/**\n * Memvid Mind - Session Start Hook\n *\n * LIGHTWEIGHT startup - does NOT load the SDK.\n * SDK is loaded lazily on first tool use instead.\n * This keeps Claude startup fast (< 1 second).\n */\n\nimport { readStdin, writeOutput, debug } from \"../utils/helpers.js\";\nimport type { HookInput } from \"../types.js\";\nimport { existsSync, statSync } from \"node:fs\";\nimport { resolve, basename } from \"node:path\";\n\nasync function main() {\n  try {\n    // Read hook input from stdin\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    debug(`Session starting: ${hookInput.session_id}`);\n\n    // Get project info without loading SDK\n    const projectDir = hookInput.cwd || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n    const projectName = basename(projectDir);\n    const memoryPath = resolve(projectDir, \".claude/mind.mv2\");\n\n    // Quick check if memory file exists (no SDK needed)\n    const memoryExists = existsSync(memoryPath);\n\n    // Build minimal context without loading SDK\n    const contextLines: string[] = [];\n\n    if (memoryExists) {\n      try {\n        const stats = statSync(memoryPath);\n        const fileSizeKB = Math.round(stats.size / 1024);\n\n        contextLines.push(\"<memvid-mind-context>\");\n        contextLines.push(\"# 🧠 Claude Mind Active\");\n        contextLines.push(\"\");\n        contextLines.push(`📁 Project: **${projectName}**`);\n        contextLines.push(`💾 Memory: \\`.claude/mind.mv2\\` (${fileSizeKB} KB)`);\n        contextLines.push(\"\");\n        contextLines.push(\"**Commands:**\");\n        contextLines.push(\"- `/mind:search <query>` - Search memories\");\n        contextLines.push(\"- `/mind:ask <question>` - Ask your memory\");\n        contextLines.push(\"- `/mind:recent` - View timeline\");\n        contextLines.push(\"- `/mind:stats` - View statistics\");\n        contextLines.push(\"\");\n        contextLines.push(\"_Memories are captured automatically from your tool use._\");\n        contextLines.push(\"</memvid-mind-context>\");\n      } catch {\n        // Ignore stat errors\n      }\n    } else {\n      // First time - memory will be created on first observation\n      contextLines.push(\"<memvid-mind-context>\");\n      contextLines.push(\"# 🧠 Claude Mind Ready\");\n      contextLines.push(\"\");\n      contextLines.push(`📁 Project: **${projectName}**`);\n      contextLines.push(\"💾 Memory will be created at: \\`.claude/mind.mv2\\`\");\n      contextLines.push(\"\");\n      contextLines.push(\"_Your observations will be automatically captured._\");\n      contextLines.push(\"</memvid-mind-context>\");\n    }\n\n    // SessionStart hooks use hookSpecificOutput.additionalContext\n    const output: any = {\n      continue: true,\n    };\n\n    if (contextLines.length > 0) {\n      output.hookSpecificOutput = {\n        hookEventName: \"SessionStart\",\n        additionalContext: contextLines.join(\"\\n\"),\n      };\n    }\n\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    // Don't block on errors\n    writeOutput({ continue: true });\n  }\n}\n\nmain();\n",
        "src/hooks/smart-install.ts": "#!/usr/bin/env node\n/**\n * Memvid Mind - Smart Install Hook\n *\n * Automatically installs dependencies on first run.\n * Runs on SessionStart before other hooks.\n */\n\nimport { existsSync, readFileSync, writeFileSync } from \"node:fs\";\nimport { resolve, dirname } from \"node:path\";\nimport { execSync } from \"node:child_process\";\nimport { writeOutput, debug } from \"../utils/helpers.js\";\n\n// Get the plugin root directory\nconst pluginRoot = process.env.CLAUDE_PLUGIN_ROOT || dirname(dirname(__dirname));\nconst nodeModulesPath = resolve(pluginRoot, \"node_modules\");\nconst sdkPath = resolve(nodeModulesPath, \"@memvid/sdk\");\nconst packageJsonPath = resolve(pluginRoot, \"package.json\");\nconst installMarkerPath = resolve(pluginRoot, \".install-version\");\n\ninterface InstallMarker {\n  version: string;\n  installedAt: string;\n}\n\nfunction getPackageVersion(): string {\n  try {\n    const pkg = JSON.parse(readFileSync(packageJsonPath, \"utf-8\"));\n    return pkg.version || \"unknown\";\n  } catch {\n    return \"unknown\";\n  }\n}\n\nfunction getInstallMarker(): InstallMarker | null {\n  try {\n    if (existsSync(installMarkerPath)) {\n      return JSON.parse(readFileSync(installMarkerPath, \"utf-8\"));\n    }\n  } catch {\n    // Ignore errors\n  }\n  return null;\n}\n\nfunction saveInstallMarker(version: string): void {\n  const marker: InstallMarker = {\n    version,\n    installedAt: new Date().toISOString(),\n  };\n  writeFileSync(installMarkerPath, JSON.stringify(marker, null, 2));\n}\n\nfunction needsInstall(): boolean {\n  // Check if SDK exists\n  if (!existsSync(sdkPath)) {\n    debug(\"SDK not found, needs install\");\n    return true;\n  }\n\n  // Check if version changed\n  const marker = getInstallMarker();\n  const currentVersion = getPackageVersion();\n\n  if (!marker || marker.version !== currentVersion) {\n    debug(`Version mismatch: ${marker?.version} -> ${currentVersion}`);\n    return true;\n  }\n\n  return false;\n}\n\nfunction installDeps(): boolean {\n  debug(\"Installing dependencies...\");\n\n  try {\n    // Try npm install first\n    execSync(\"npm install --production --no-fund --no-audit\", {\n      cwd: pluginRoot,\n      stdio: \"pipe\",\n      timeout: 120000, // 2 minute timeout\n    });\n\n    debug(\"Dependencies installed successfully\");\n    return true;\n  } catch (error) {\n    debug(`npm install failed: ${error}`);\n\n    // Try with force flag\n    try {\n      execSync(\"npm install --production --no-fund --no-audit --force\", {\n        cwd: pluginRoot,\n        stdio: \"pipe\",\n        timeout: 120000,\n      });\n      debug(\"Dependencies installed with --force\");\n      return true;\n    } catch (forceError) {\n      debug(`npm install --force failed: ${forceError}`);\n      return false;\n    }\n  }\n}\n\nasync function main() {\n  try {\n    if (needsInstall()) {\n      const success = installDeps();\n\n      if (success) {\n        const version = getPackageVersion();\n        saveInstallMarker(version);\n        debug(`Installed memvid-mind v${version}`);\n      } else {\n        debug(\"Failed to install dependencies\");\n      }\n    } else {\n      debug(\"Dependencies already installed\");\n    }\n\n    // Always continue - don't block on install errors\n    writeOutput({ continue: true });\n  } catch (error) {\n    debug(`Smart install error: ${error}`);\n    writeOutput({ continue: true });\n  }\n}\n\nmain();\n",
        "src/hooks/stop.ts": "#!/usr/bin/env node\n/**\n * Memvid Mind - Stop Hook\n *\n * AUTO SESSION SUMMARY\n * Runs when Claude session ends.\n * Generates an intelligent session summary for future reference.\n *\n * WORKAROUND: Since PostToolUse doesn't fire for Edit operations (Claude Code bug),\n * we capture git diff at session end to record all file modifications.\n */\n\nimport { getMind } from \"../core/mind.js\";\nimport { readStdin, writeOutput, debug } from \"../utils/helpers.js\";\nimport type { HookInput, HookOutput } from \"../types.js\";\nimport { readFile, access } from \"node:fs/promises\";\nimport { constants } from \"node:fs\";\nimport { execSync } from \"node:child_process\";\n\n// Minimum observations to generate a session summary\nconst MIN_OBSERVATIONS_FOR_SUMMARY = 3;\n\n/**\n * Capture file modifications at session end\n * WORKAROUND for Claude Code bug: PostToolUse hooks don't fire for Edit operations\n *\n * Captures both:\n * 1. Git tracked files that changed (git diff)\n * 2. Recently modified files in untracked directories (find -mmin)\n */\nasync function captureFileChanges(mind: Awaited<ReturnType<typeof getMind>>) {\n  try {\n    // Get the working directory from the mind's memory path\n    const memoryPath = mind.getMemoryPath();\n    const workDir = memoryPath.replace(/\\/\\.claude\\/.*$/, \"\");\n\n    const allChangedFiles: string[] = [];\n    let gitDiffContent = \"\";\n\n    // 1. Get git tracked changes (staged and unstaged)\n    // Use shorter timeouts to avoid blocking session end\n    try {\n      const diffNames = execSync(\"git diff --name-only HEAD 2>/dev/null || git diff --name-only 2>/dev/null || echo ''\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 3000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      }).trim();\n\n      const stagedNames = execSync(\"git diff --cached --name-only 2>/dev/null || echo ''\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 3000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      }).trim();\n\n      const gitFiles = [...new Set([\n        ...diffNames.split(\"\\n\").filter(Boolean),\n        ...stagedNames.split(\"\\n\").filter(Boolean),\n      ])];\n\n      allChangedFiles.push(...gitFiles);\n\n      // Get git diff stat for tracked files\n      if (gitFiles.length > 0) {\n        try {\n          gitDiffContent = execSync(\"git diff HEAD --stat 2>/dev/null | head -30\", {\n            cwd: workDir,\n            encoding: \"utf-8\",\n            timeout: 3000,\n            stdio: ['pipe', 'pipe', 'pipe'],\n          }).trim();\n        } catch {\n          // Ignore\n        }\n      }\n    } catch {\n      // Not a git repo or git not available - continue to find recent files\n    }\n\n    // 2. Find recently modified files (last 30 minutes) in common code directories\n    // This catches changes in untracked directories\n    // Use -maxdepth to limit search and exclude common large dirs for speed\n    // Reduced timeout and scope to avoid hanging\n    try {\n      const recentFiles = execSync(\n        `find . -maxdepth 4 -type f \\\\( -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.jsx\" -o -name \"*.md\" -o -name \"*.json\" -o -name \"*.py\" -o -name \"*.rs\" \\\\) -mmin -30 ! -path \"*/node_modules/*\" ! -path \"*/.git/*\" ! -path \"*/dist/*\" ! -path \"*/build/*\" ! -path \"*/.next/*\" ! -path \"*/target/*\" 2>/dev/null | head -30`,\n        {\n          cwd: workDir,\n          encoding: \"utf-8\",\n          timeout: 5000,\n          stdio: ['pipe', 'pipe', 'pipe'],\n        }\n      ).trim();\n\n      const recentFilesList = recentFiles.split(\"\\n\").filter(Boolean).map(f => f.replace(/^\\.\\//, \"\"));\n\n      // Add files not already in the list\n      for (const file of recentFilesList) {\n        if (!allChangedFiles.includes(file)) {\n          allChangedFiles.push(file);\n        }\n      }\n    } catch {\n      // find command failed, continue with what we have\n    }\n\n    if (allChangedFiles.length === 0) {\n      debug(\"No file changes detected\");\n      return;\n    }\n\n    debug(`Capturing ${allChangedFiles.length} changed files`);\n\n    // Build content summary\n    const contentParts = [`## Files Modified This Session\\n\\n${allChangedFiles.map(f => `- ${f}`).join(\"\\n\")}`];\n\n    if (gitDiffContent) {\n      contentParts.push(`\\n## Git Changes Summary\\n\\`\\`\\`\\n${gitDiffContent}\\n\\`\\`\\``);\n    }\n\n    // Store the changes as a memory\n    await mind.remember({\n      type: \"refactor\",\n      summary: `Session edits: ${allChangedFiles.length} file(s) modified`,\n      content: contentParts.join(\"\\n\"),\n      tool: \"FileChanges\",\n      metadata: {\n        files: allChangedFiles,\n        fileCount: allChangedFiles.length,\n        captureMethod: \"git-diff-plus-recent\",\n      },\n    });\n\n    // Also store individual entries for important file types (README, config, etc.)\n    // so they're searchable by name\n    for (const file of allChangedFiles) {\n      const fileName = file.split(\"/\").pop() || file;\n      const isImportant = /^(README|CHANGELOG|package\\.json|Cargo\\.toml|\\.env)/i.test(fileName);\n\n      if (isImportant) {\n        await mind.remember({\n          type: \"refactor\",\n          summary: `Modified ${fileName}`,\n          content: `File edited: ${file}\\nThis file was modified during the session.`,\n          tool: \"FileEdit\",\n          metadata: {\n            files: [file],\n            fileName,\n          },\n        });\n        debug(`Stored individual edit: ${fileName}`);\n      }\n    }\n\n    debug(`Stored file changes: ${allChangedFiles.length} files`);\n  } catch (error) {\n    debug(`Failed to capture file changes: ${error}`);\n  }\n}\n\nasync function main() {\n  try {\n    // Read hook input from stdin\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    debug(`Session stopping: ${hookInput.session_id}`);\n\n    // Initialize mind\n    const mind = await getMind();\n    const stats = await mind.stats();\n\n    // WORKAROUND: Capture file changes since PostToolUse doesn't fire for Edit\n    await captureFileChanges(mind);\n\n    // Try to read the transcript for richer summary\n    let transcriptContent = \"\";\n    if (hookInput.transcript_path) {\n      try {\n        await access(hookInput.transcript_path, constants.R_OK);\n        transcriptContent = await readFile(hookInput.transcript_path, \"utf-8\");\n      } catch {\n        // Transcript not available, that's ok\n      }\n    }\n\n    // Get recent observations from this session\n    const context = await mind.getContext();\n    const sessionObservations = context.recentObservations.filter(\n      (obs) => obs.metadata?.sessionId === mind.getSessionId()\n    );\n\n    // Generate session summary if we have enough observations\n    if (sessionObservations.length >= MIN_OBSERVATIONS_FOR_SUMMARY) {\n      const summary = generateSessionSummary(\n        sessionObservations,\n        transcriptContent\n      );\n\n      // Save the session summary\n      await mind.saveSessionSummary(summary);\n\n      debug(\n        `Session summary saved: ${summary.keyDecisions.length} decisions, ${summary.filesModified.length} files`\n      );\n    }\n\n    debug(\n      `Session complete. Total memories: ${stats.totalObservations}, File: ${mind.getMemoryPath()}`\n    );\n\n    // Continue without blocking\n    const output: HookOutput = {\n      continue: true,\n    };\n\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    // Don't block on errors\n    writeOutput({ continue: true });\n  }\n}\n\n/**\n * Generate a session summary from observations\n */\nfunction generateSessionSummary(\n  observations: Array<{\n    type: string;\n    summary: string;\n    content: string;\n    metadata?: { files?: string[]; sessionId?: string; [key: string]: unknown };\n  }>,\n  transcript: string\n): {\n  keyDecisions: string[];\n  filesModified: string[];\n  summary: string;\n} {\n  // Extract key decisions\n  const keyDecisions: string[] = [];\n  const filesModified = new Set<string>();\n\n  for (const obs of observations) {\n    // Track decisions\n    if (\n      obs.type === \"decision\" ||\n      obs.summary.toLowerCase().includes(\"chose\") ||\n      obs.summary.toLowerCase().includes(\"decided\")\n    ) {\n      keyDecisions.push(obs.summary);\n    }\n\n    // Track files from metadata\n    const files = obs.metadata?.files as string[] | undefined;\n    if (files) {\n      files.forEach((f) => filesModified.add(f));\n    }\n  }\n\n  // Extract file paths from transcript if available\n  if (transcript) {\n    const filePatterns = [\n      /(?:Read|Edit|Write)[^\"]*\"([^\"]+)\"/g,\n      /file_path[\"\\s:]+([^\\s\"]+)/g,\n    ];\n\n    for (const pattern of filePatterns) {\n      let match;\n      while ((match = pattern.exec(transcript)) !== null) {\n        const path = match[1];\n        if (path && !path.includes(\"node_modules\") && !path.startsWith(\".\")) {\n          filesModified.add(path);\n        }\n      }\n    }\n  }\n\n  // Generate summary based on observation types\n  const typeCounts: Record<string, number> = {};\n  for (const obs of observations) {\n    typeCounts[obs.type] = (typeCounts[obs.type] || 0) + 1;\n  }\n\n  const summaryParts: string[] = [];\n\n  if (typeCounts.feature) {\n    summaryParts.push(`Added ${typeCounts.feature} feature(s)`);\n  }\n  if (typeCounts.bugfix) {\n    summaryParts.push(`Fixed ${typeCounts.bugfix} bug(s)`);\n  }\n  if (typeCounts.refactor) {\n    summaryParts.push(`Refactored ${typeCounts.refactor} item(s)`);\n  }\n  if (typeCounts.discovery) {\n    summaryParts.push(`Made ${typeCounts.discovery} discovery(ies)`);\n  }\n  if (typeCounts.problem) {\n    summaryParts.push(`Encountered ${typeCounts.problem} problem(s)`);\n  }\n  if (typeCounts.solution) {\n    summaryParts.push(`Found ${typeCounts.solution} solution(s)`);\n  }\n\n  const summary =\n    summaryParts.length > 0\n      ? summaryParts.join(\". \") + \".\"\n      : `Session with ${observations.length} observations.`;\n\n  return {\n    keyDecisions: keyDecisions.slice(0, 10),\n    filesModified: Array.from(filesModified).slice(0, 20),\n    summary,\n  };\n}\n\nmain();\n"
      },
      "plugins": [
        {
          "name": "mind",
          "description": "Claude Brain - Give Claude photographic memory in ONE portable file",
          "version": "1.0.11",
          "source": "./",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add memvid/claude-brain",
            "/plugin install mind@memvid"
          ]
        }
      ]
    }
  ]
}