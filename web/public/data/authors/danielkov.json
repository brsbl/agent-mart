{
  "author": {
    "id": "danielkov",
    "display_name": "Daniel Emod Kovacs",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/18039004?u=0a8fa944935129cd8240bc2adbd4af246e8501df&v=4",
    "url": "https://github.com/danielkov",
    "bio": "Software Engineer ðŸ’»  Co-founder of @tandem-dating ",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 1,
      "total_skills": 5,
      "total_stars": 5,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "granary",
      "version": "0.5.0",
      "description": "Context hub for agentic workflows - manage projects, tasks, sessions, and multi-agent coordination",
      "owner_info": {
        "name": "Daniel Kovacs",
        "email": "kovacsemod@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "danielkov/granary",
      "repo_url": "https://github.com/danielkov/granary",
      "repo_description": "A CLI context hub for agentic work",
      "homepage": null,
      "signals": {
        "stars": 5,
        "forks": 1,
        "pushed_at": "2026-01-29T20:07:35Z",
        "created_at": "2026-01-12T00:09:18Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/commands/status.md",
          "type": "blob",
          "size": 980
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 683
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 395
        },
        {
          "path": ".claude-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/execute-task",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/execute-task/SKILL.md",
          "type": "blob",
          "size": 4584
        },
        {
          "path": ".claude-plugin/skills/initiative-planner",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/initiative-planner/SKILL.md",
          "type": "blob",
          "size": 13174
        },
        {
          "path": ".claude-plugin/skills/orchestrate",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/orchestrate/SKILL.md",
          "type": "blob",
          "size": 9163
        },
        {
          "path": ".claude-plugin/skills/plan-work",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/plan-work/SKILL.md",
          "type": "blob",
          "size": 17948
        },
        {
          "path": ".claude-plugin/skills/setup",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/skills/setup/SKILL.md",
          "type": "blob",
          "size": 1151
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/bump-plugin-version.md",
          "type": "blob",
          "size": 558
        },
        {
          "path": ".claude/skills/finalize.md",
          "type": "blob",
          "size": 761
        },
        {
          "path": ".claude/skills/update-e2e-tests.md",
          "type": "blob",
          "size": 620
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6742
        }
      ],
      "files": {
        ".claude-plugin/commands/status.md": "---\ndescription: Show current granary session status, tasks, and next actions\nuser-invocable: true\nallowed-tools: Bash(granary:*)\n---\n\n# Granary Status Command\n\nWhen the user runs /granary:status, provide a summary of the current granary state.\n\n## Steps\n\n1. **Current Session:**\n   Run: `granary session current --json`\n   Display: Session name, mode, owner\n\n2. **Task Summary:**\n   Run: `granary tasks --json`\n   Display: Count by status (todo, in_progress, done, blocked)\n\n3. **Next Action:**\n   Run: `granary next --json`\n   Display: The next recommended task\n\n4. **Blockers:**\n   Run: `granary tasks --status blocked --json`\n   Display: Any blocked tasks and their reasons\n\n## Output Format\n\nFormat as clean markdown:\n\n## Granary Status\n\n**Session:** [name] ([mode] mode)\n**Owner:** [owner]\n\n### Tasks\n\n- Todo: [count]\n- In Progress: [count]\n- Done: [count]\n- Blocked: [count]\n\n### Next Action\n\n[Task title and ID]\n\n### Blockers\n\n[List blocked tasks with reasons, or \"None\"]\n",
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"granary\",\n  \"version\": \"0.5.0\",\n  \"description\": \"Context hub for agentic workflows - manage projects, tasks, sessions, and multi-agent coordination\",\n  \"owner\": {\n    \"name\": \"Daniel Kovacs\",\n    \"email\": \"kovacsemod@gmail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"granary\",\n      \"description\": \"Context hub for agentic workflows - manage projects, tasks, sessions, and multi-agent coordination\",\n      \"version\": \"0.5.1\",\n      \"author\": {\n        \"name\": \"Daniel Kovacs\",\n        \"email\": \"kovacsemod@gmail.com\"\n      },\n      \"source\": \"./\",\n      \"category\": \"productivity\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"granary\",\n  \"description\": \"Context hub for agentic workflows - manage projects, tasks, sessions, and multi-agent coordination\",\n  \"version\": \"0.5.1\",\n  \"author\": {\n    \"name\": \"Daniel Kovacs <kovacsemod@gmail.com>\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/danielkov/granary\",\n  \"skills\": \"./.claude-plugin/skills/\",\n  \"commands\": \"./.claude-plugin/commands/\"\n}\n",
        ".claude-plugin/skills/execute-task/SKILL.md": "---\nname: granary-execute-task\ndescription: Execute an assigned granary task as a sub-agent. Use when you receive a task ID to complete.\n---\n\n# Executing a Granary Task\n\nYou are a **sub-agent** spawned by an orchestrator to complete a specific task. Your responsibility is to:\n\n1. Build context from the task\n2. Implement the task as described\n3. Report your progress\n4. Signal completion or blockers back to the orchestrator\n\n**You do NOT coordinate other agents. You do the actual work.**\n\n## Step 1: Build Context from the Task\n\nFirst, use `granary handoff` to retrieve full context for your task:\n\n```bash\ngranary handoff --tasks <task-id>\n```\n\nThis returns:\n- **Task description** with goals, requirements, and acceptance criteria\n- **Files to modify** with exact paths and line numbers\n- **Implementation details** including code patterns to follow\n- **Steering files** attached to the task or its parent project\n- **Global steering** with project-wide conventions\n\n**Read this context carefully.** The planner has done thorough research and provided everything you need. The handoff context is your primary source of truth.\n\n### Understanding the Handoff Output\n\nThe handoff includes:\n\n| Section | Contains |\n|---------|----------|\n| Task Details | Goal, context, requirements, acceptance criteria |\n| Files to Modify | Exact file paths with line numbers |\n| Implementation Details | Code examples, patterns, function signatures |\n| Steering Files | Project conventions, existing patterns, research notes |\n\nIf the handoff mentions specific files like `src/services/user.rs:45-67`, read those files to understand the existing patterns before making changes.\n\n### Verify Task Metadata (Optional)\n\nIf you need the raw task data:\n\n```bash\ngranary show <task-id>\n# or\ngranary task <task-id>\n```\n\nUse this to double-check task metadata (priority, dependencies, status).\n\n## Step 2: Start the Task\n\nMark the task as in-progress:\n\n```bash\ngranary task <task-id> start\n```\n\nIf working in a multi-agent environment, claim with a lease to prevent conflicts:\n\n```bash\ngranary task <task-id> start --lease 30\n```\n\nThe lease (in minutes) ensures no other agent claims this task while you work.\n\n## Step 3: Do the Work\n\n**This is your main responsibility.** Implement whatever the task description specifies:\n\n- Write code\n- Create files\n- Run tests\n- Fix bugs\n- Whatever the task requires\n\n### Record Progress\n\nAdd comments as you work to maintain visibility for the orchestrator:\n\n```bash\ngranary task <task-id> comments create \"Started implementing the login form\"\ngranary task <task-id> comments create \"Completed form validation, now adding API integration\" --kind progress\n```\n\nComment kinds: `note`, `progress`, `decision`, `blocker`\n\n## Step 4: Report Completion\n\nWhen you have successfully completed the task:\n\n```bash\ngranary task <task-id> done --comment \"Implemented login form with validation and API integration\"\n```\n\n**Important**: Only mark done when the task is truly complete according to its acceptance criteria.\n\n## Handling Problems\n\n### If You Get Blocked\n\nIf you cannot continue due to external factors:\n\n```bash\ngranary task <task-id> block --reason \"Waiting for API credentials from ops team\"\n```\n\nThis signals to the orchestrator that this task needs attention.\n\n### If You Cannot Complete\n\nIf you cannot complete the task for any reason, release it so others can pick it up:\n\n```bash\ngranary task <task-id> release\n```\n\nThen report back to the orchestrator with what went wrong.\n\n## Multi-Agent Safety\n\nIf working in parallel with other agents:\n\n```bash\n# Extend lease for long-running tasks\ngranary task <task-id> heartbeat --lease 30\n\n# Check if task is still yours\ngranary task <task-id>\n```\n\nExit codes to watch for:\n\n- `4` = Conflict (task claimed by another agent)\n- `5` = Blocked (dependencies not met)\n\n## Summary\n\nAs a sub-agent, your workflow is:\n\n1. **Build context** â†’ `granary handoff --tasks <id>` to get full task details with steering\n2. **Read referenced files** â†’ Examine files mentioned in handoff (e.g., `src/foo.rs:45-67`)\n3. **Start task** â†’ `granary task <id> start`\n4. **Do the work** â†’ Implement following the patterns and details provided\n5. **Record progress** â†’ `granary task <id> comments create \"...\"`\n6. **Complete or block** â†’ `granary task <id> done` or `granary task <id> block`\n\n**Remember:** The planner has done thorough research. Your handoff context contains file paths, implementation details, and code patterns. Trust this contextâ€”it's specifically prepared for you to execute without additional exploration.\n",
        ".claude-plugin/skills/initiative-planner/SKILL.md": "---\nname: granary-initiative-planner\ndescription: Plan and organize multi-project initiatives or significant, substantial projects. Use when work spans multiple services, repositories, or has natural project boundaries.\n---\n\n# Planning Multi-Project Initiatives\n\nUse this skill when work naturally spans multiple projects or services. **Do NOT use for single-feature work**â€”use `/granary:plan-work` instead.\n\n**Your role:** High-level architecture, separation of concerns, dependency analysis, and spawning sub-agents for project planning. You do NOT plan individual project tasks yourselfâ€”you coordinate and synthesize.\n\n## Your Focus as Initiative Planner\n\nYou are a **high-level coordinator**. Your job is to:\n\n1. **Collect broad context** before any planning begins\n2. **Design the project structure** with clear boundaries\n3. **Spawn sub-agents** to handle detailed project planning\n4. **Synthesize cross-project dependencies** from sub-agent reports\n\n**You do NOT:**\n\n- Plan detailed tasks within projects (sub-agents do this)\n- Implement anything directly\n- Make low-level technical decisions\n\n## When to Use Initiatives\n\n**Use initiatives when:**\n\n- Work spans multiple services (API + frontend + workers)\n- Implementation has clear phases with dependencies (schema -> API -> UI)\n- Multiple teams or agents will work in parallel on different components\n- You need to track cross-project dependencies\n\n**Do NOT use initiatives when:**\n\n- Work fits in a single project\n- There are no cross-project dependencies\n- It's a single feature in one service\n\n## Step 1: Comprehensive Context Collection\n\n**This is your most important step.** Before creating an initiative, gather broad context to inform the entire planning process. You are building the foundation that sub-agents will rely on.\n\n### 1.1 Search for Prior Art\n\n```bash\n# Search granary for related existing work\ngranary search \"feature keywords\"\ngranary initiatives  # Check existing initiatives\ngranary projects     # See all projects\n```\n\n### 1.2 Understand Current Implementation\n\nResearch the codebase at a high level:\n\n- What services/modules exist that will be affected?\n- What boundaries already exist in the architecture?\n- What shared dependencies or interfaces might be needed?\n- What are the current **limitations** of the system?\n\n```bash\n# Example: understand existing architecture\nls -la src/\ngrep -r \"mod \" src/lib.rs\ncat README.md\n```\n\n### 1.3 Gather External Context\n\n**Use web search and documentation lookup** to understand:\n\n- Industry best practices for similar features\n- Framework/library documentation for relevant technologies\n- Potential pitfalls or known issues others have encountered\n\nThis external research provides valuable context that sub-agents will benefit from when planning their projects.\n\n### 1.4 Document Limitations and Constraints\n\nBefore proceeding, document:\n\n- Technical limitations of the current system\n- Resource or time constraints\n- Dependencies on external systems or teams\n- Known risks or uncertainties\n\n### 1.5 Decision Tree\n\n| Situation                                         | Action                              |\n| ------------------------------------------------- | ----------------------------------- |\n| Work fits in one project                          | Use `/granary:plan-work` instead    |\n| Related initiative exists                         | Add projects to existing initiative |\n| Work spans 2+ distinct projects with dependencies | Create new initiative               |\n\n## Step 2: Create the Initiative\n\n```bash\ngranary initiatives create \"Initiative Name\" \\\n  --description \"High-level goal spanning multiple projects\"\n```\n\nExample:\n\n```bash\ngranary initiatives create \"User Authentication System\" \\\n  --description \"Implement auth across API, web app, and mobile app with shared token service\"\n```\n\n## Step 3: Design Separation of Concerns\n\nBreak the initiative into logical projects. Each project should:\n\n- Be independently implementable (given its dependencies)\n- Have a clear boundary (service, module, or phase)\n- Be completable by a single agent\n\nThink carefully about:\n\n- **What depends on what?** Which components need to exist before others can start?\n- **What can run in parallel?** Which projects have no dependencies on each other?\n- **Where are the interfaces?** What contracts need to be defined between projects?\n\nExample breakdown:\n\n```\nInitiative: User Authentication System\nâ”œâ”€â”€ Project: Auth Token Service (shared backend) â€” no deps, can start first\nâ”œâ”€â”€ Project: API Auth Integration â€” depends on token service\nâ”œâ”€â”€ Project: Web App Login â€” depends on API auth\nâ””â”€â”€ Project: Mobile App Login â€” depends on API auth (parallel with Web App)\n```\n\n## Step 4: Create Projects and Add to Initiative\n\n```bash\n# Create each project with clear descriptions for sub-agents\ngranary projects create \"Auth Token Service\" \\\n  --description \"JWT token generation and validation service\"\n# Output: auth-token-service-abc1\n\ngranary projects create \"API Auth Integration\" \\\n  --description \"Add authentication middleware to API endpoints\"\n# Output: api-auth-integration-def2\n\n# Add projects to initiative\ngranary initiative <initiative-id> add-project auth-token-service-abc1\ngranary initiative <initiative-id> add-project api-auth-integration-def2\n```\n\n## Step 5: Analyze and Set Up Project Dependencies\n\n**This is critical.** Review each project pair and ask:\n\n- Does project A need anything from project B to start?\n- Does project B produce interfaces/APIs that project A consumes?\n- Are there shared schemas or contracts that must exist first?\n\n```bash\n# API Auth depends on Token Service being complete\ngranary project api-auth-integration-def2 deps add auth-token-service-abc1\n\n# Web App depends on API Auth\ngranary project web-app-login-ghi3 deps add api-auth-integration-def2\n```\n\n**Key principle:** A project is blocked until ALL its dependency projects have ALL tasks done.\n\n## Step 6: Verify the Dependency Structure\n\nBefore spawning sub-agents, verify the structure makes sense:\n\n```bash\n# View the initiative dependency graph\ngranary initiative <initiative-id> graph\n\n# View as mermaid diagram (paste into GitHub/VSCode)\ngranary initiative <initiative-id> graph --format mermaid\n\n# Check overall status\ngranary initiative <initiative-id> summary\n```\n\nReview the graph for:\n\n- Circular dependencies (error)\n- Missing dependencies (projects that should depend on each other but don't)\n- Overly sequential structure (could more projects run in parallel?)\n\n## Step 7: Spawn Sub-Agents for Project Planning\n\n**Do NOT plan project tasks yourself.** Spawn sub-agents to handle detailed project planning. Each sub-agent focuses deeply on one project while you maintain the high-level view.\n\n### 7.1 Get Projects Ready for Planning\n\n```bash\n# Get all projects in the initiative\ngranary initiative <initiative-id> projects\n\n# Identify which projects are unblocked (no project dependencies)\ngranary initiative <initiative-id> graph\n```\n\n### 7.2 Spawn Sub-Agents with Large Context Models\n\n**Critical:** Use the **largest context model available** (e.g., `claude-opus-4-5-20250101` or `opus`) for sub-agents. These planning tasks benefit from deep reasoning and extensive context windows.\n\nFor each unblocked project, spawn a sub-agent using the Task tool:\n\n```\nUse Task tool with:\n  prompt: [see template below]\n  subagent_type: \"general-purpose\"\n  model: \"claude-opus-4-5-20250101\"  # Use largest available context model\n  run_in_background: true  # Spawn in parallel when multiple projects are unblocked\n```\n\n### 7.3 Sub-Agent Prompt Template\n\nProvide each sub-agent with:\n\n1. **Project context** from your high-level research\n2. **Clear directive** to use `/granary:plan-work`\n3. **Instruction to report back** with cross-project dependencies\n\n**Example prompt:**\n\n```\nUse /granary:plan-work to plan the project `auth-token-service-abc1`.\n\n## Context\nThis project is part of the \"User Authentication System\" initiative.\nGoal: Implement JWT token generation and validation service.\n\n## High-Level Context from Initiative Planning\n- The API will consume tokens via middleware (future project: api-auth-integration)\n- Token format should be JWT with RS256 signing\n- Existing auth patterns found in src/middleware/ use Bearer tokens\n- Reference: https://jwt.io/introduction for JWT best practices\n\n## Your Task\n1. Research the project scope thoroughly\n2. Create detailed tasks with file paths, implementation details, and acceptance criteria\n3. Set up task dependencies within the project\n\n## Required Report Back\nWhen planning is complete, summarize:\n1. **Tasks created** - List of tasks with brief descriptions\n2. **Cross-project interfaces** - What APIs, types, or contracts does this project expose that other projects will depend on?\n3. **Cross-project dependencies identified** - Did you discover dependencies on other initiative projects not yet captured?\n4. **Risks or blockers** - Any concerns that affect the broader initiative\n```\n\n### 7.4 Spawn in Parallel\n\nSpawn sub-agents for **all unblocked projects simultaneously**:\n\n```\n# If projects A, B, C have no project dependencies, spawn all three at once:\n\nUse Task tool (all in ONE message):\n  1. prompt: [Project A planning prompt]\n     model: \"claude-opus-4-5-20250101\"\n     run_in_background: true\n\n  2. prompt: [Project B planning prompt]\n     model: \"claude-opus-4-5-20250101\"\n     run_in_background: true\n\n  3. prompt: [Project C planning prompt]\n     model: \"claude-opus-4-5-20250101\"\n     run_in_background: true\n```\n\n### 7.5 Collect and Synthesize Reports\n\nAfter sub-agents complete, review their reports for:\n\n- **Cross-project dependencies** they identified (update initiative dependency graph if needed)\n- **Shared interfaces** that need coordination between projects\n- **Risks** that affect multiple projects\n\n```bash\n# Update dependencies if sub-agents identified new ones\ngranary project <project-B> deps add <project-A>\n\n# Verify updated structure\ngranary initiative <initiative-id> graph --format mermaid\n```\n\n## Step 8: Hand Off to Orchestration\n\nOnce all projects have been planned by sub-agents, the initiative is ready for `/granary:orchestrate`:\n\n```bash\n# Verify all projects have tasks\ngranary initiative <initiative-id> summary\n\n# Get the next actionable task across the entire initiative\ngranary initiative <initiative-id> next\n\n# Get ALL unblocked tasks (for parallel execution)\ngranary initiative <initiative-id> next --all\n```\n\n## Example: Full Initiative Planning Flow\n\n```bash\n# 1. Research the codebase (understand existing architecture)\n\n# 2. Create initiative\ngranary initiatives create \"Payment Processing\" \\\n  --description \"Add payment support: Stripe integration, checkout flow, order management\"\n\n# 3. Design separation of concerns and create projects\ngranary projects create \"Stripe Service\" --description \"Stripe API integration wrapper\"\ngranary projects create \"Checkout API\" --description \"Checkout endpoints and cart management\"\ngranary projects create \"Checkout UI\" --description \"Frontend checkout flow\"\ngranary projects create \"Order Service\" --description \"Order persistence and status tracking\"\n\n# 4. Add to initiative\ngranary initiative payment-processing-xyz1 add-project stripe-service-abc1\ngranary initiative payment-processing-xyz1 add-project checkout-api-def2\ngranary initiative payment-processing-xyz1 add-project checkout-ui-ghi3\ngranary initiative payment-processing-xyz1 add-project order-service-jkl4\n\n# 5. Analyze dependencies and set them up\ngranary project checkout-api-def2 deps add stripe-service-abc1\ngranary project checkout-ui-ghi3 deps add checkout-api-def2\ngranary project order-service-jkl4 deps add checkout-api-def2\n\n# 6. Verify structure\ngranary initiative payment-processing-xyz1 graph --format mermaid\n\n# 7. Spawn sub-agents to plan unblocked projects\n# stripe-service-abc1 is unblocked -> spawn agent with /granary:plan-work\n\n# 8. Once planned, check readiness\ngranary initiative payment-processing-xyz1 summary\n```\n\n## Summary\n\n1. **Collect context broadly** -> Prior art, current implementation, limitations, external docs, web search\n2. **Assess** -> Is this truly multi-project work?\n3. **Create initiative** -> High-level container with context documentation\n4. **Design separation** -> Clear boundaries, identify interfaces\n5. **Create projects** -> Add to initiative with good descriptions\n6. **Analyze dependencies** -> Review all project pairs, set project-level dependencies\n7. **Verify structure** -> Check graph for issues\n8. **Spawn sub-agents** -> Use **largest context model** (opus), provide context, request cross-project dependency reports\n9. **Synthesize reports** -> Update dependencies based on sub-agent findings\n10. **Hand off** -> Orchestrator uses initiative-level commands\n\n**Your output:** A well-structured initiative with projects and dependencies. Sub-agents handle detailed task planning within each project and report back cross-project dependencies they discover.\n\n**Key principle:** You are a high-level coordinator. Gather broad context, design the structure, delegate deep planning to sub-agents, then synthesize their findings.\n",
        ".claude-plugin/skills/orchestrate/SKILL.md": "---\nname: granary-orchestrate\ndescription: Orchestrate sub-agents and coordinate multi-agent workflows with granary. Use when delegating tasks, spawning workers, or managing parallel execution.\n---\n\n# Orchestrating Implementation with Granary\n\nThis skill is for **implementation-time orchestration**. Your job is to coordinate sub-agents to implement planned work. You do NOT plan or designâ€”you delegate and track.\n\n## Critical: Trust the Scheduler\n\n**NEVER** determine task parallelism by:\n\n- Checking if `blocked_by` is null/empty on individual tasks\n- Assuming tasks are independent because they don't have explicit blockers\n- Launching more tasks than `granary next --all` returns\n- Inspecting task metadata to make your own parallelism decisions\n\n`granary next --all` is the **ONLY** source of truth for what can run in parallel. It considers:\n\n- Explicit task dependencies (task_dependencies table)\n- Project dependencies (project_dependencies table)\n- Task status (draft tasks are never returned)\n- Claims and leases\n- Implicit ordering requirements\n\n**If `granary next --all` returns 2 tasks, spawn exactly 2 agents. Not 6. Not 4. Exactly 2.**\n\n## Output Format\n\n**Always use `--format=prompt` instead of `--json`** for granary commands. The `--format=prompt` output is specifically designed for LLM consumptionâ€”it's token-efficient and easy to parse without wasting context on JSON syntax.\n\nOnly use `--json` when you need to extract specific fields via `jq`, and always filter the output:\n\n```bash\n# Only if you need specific fields\ngranary task <id> --json | jq '.id, .status'\n```\n\n## Primary Use-Case\n\nYou are prompted to implement a project. Follow these steps:\n\n## Step 1: Get Granary Overview\n\n```bash\ngranary summary\n```\n\nThis shows all projects, their status, and task counts. Understand what exists before proceeding.\n\n## Step 2: Find Your Target Project\n\nIf given a project name, find it:\n\n```bash\ngranary projects\ngranary project <project-id>\n```\n\n### Finding Projects and Tasks\n\nSearch for projects and tasks by title:\n\n```bash\ngranary search \"query\"                # Find matching projects and tasks\ngranary search \"api\" --format=prompt  # LLM-friendly output\n```\n\nThis is useful when you know part of the project or task name but not the exact ID.\n\n## Step 3: Assess Project Readiness\n\nExamine the project structure:\n\n```bash\ngranary project <project-id> tasks\n```\n\n**Decision tree:**\n\n| Situation                                    | Action                                       |\n| -------------------------------------------- | -------------------------------------------- |\n| Project has no tasks                         | Use `/granary:plan-work` skill to plan first |\n| Project has tasks but they lack detail       | Use `/granary:plan-work` skill to refine     |\n| Single simple project with clear description | Implement directly as one task               |\n| Project has tasks with dependencies          | **Happy path** - proceed to Step 4           |\n\n## Step 4: Start Orchestration Session\n\n```bash\ngranary session start \"implementing-<project-name>\" --mode execute\ngranary session add <project-id>\n```\n\n## Step 5: The Orchestration Loop\n\nYour sole focus: **hand off tasks to sub-agents**. You do NOT implement tasks yourself.\n\n**Key principle: Maximize parallelism.** Always look for opportunities to run multiple tasks concurrently. Tasks without dependencies on each other can and should run in parallel.\n\n### Get ONLY the Tasks Granary Says Are Ready\n\n```bash\n# Get ONLY tasks the scheduler has determined are ready\ngranary next --all --format=prompt\n```\n\nThis returns **only** the tasks that are ready to execute. The scheduler has already evaluated dependencies, project ordering, claims, and status. **Spawn agents for exactly the tasks returnedâ€”no more, no fewer.**\n\nIf no tasks are returned, either all tasks are complete or remaining tasks are blocked.\n\n**DO NOT** bypass this by:\n\n- Listing all project tasks and filtering by `blocked_by == null`\n- Assuming tasks without explicit blockers can run in parallel\n- Making your own judgment calls about task independence\n\nThe scheduler knows things you don't. Trust it.\n\n### Spawning Agents in Parallel\n\nWhen multiple tasks are unblocked, spawn them all at once using parallel Task tool calls:\n\n```\n# If granary next --all returns task-1, task-2, task-3:\n\nUse Task tool (call all three in a SINGLE message):\n  1. prompt: \"Execute granary task task-1. Use /granary:execute-task skill.\"\n     subagent_type: \"general-purpose\"\n     run_in_background: true\n\n  2. prompt: \"Execute granary task task-2. Use /granary:execute-task skill.\"\n     subagent_type: \"general-purpose\"\n     run_in_background: true\n\n  3. prompt: \"Execute granary task task-3. Use /granary:execute-task skill.\"\n     subagent_type: \"general-purpose\"\n     run_in_background: true\n```\n\n**Important:** Use `run_in_background: true` for parallel execution. This allows multiple agents to work simultaneously.\n\n### The Loop\n\n1. **Ask the scheduler what's ready** â†’ `granary next --all --format=prompt`\n2. **Spawn agents for exactly those tasks** â†’ One Task tool call per task, all in the same message\n3. **Monitor progress** â†’ Check on background agents, wait for completions\n4. **Repeat** â†’ When agents complete, ask the scheduler again for newly unblocked tasks\n\n**Critical:** Never spawn more agents than tasks returned by `granary next --all`. If it returns 2 tasks, spawn 2 agents. Period.\n\n### Single Task Fallback\n\nIf only one task is available or tasks must be sequential:\n\n```bash\ngranary next --format=prompt\n```\n\nThen spawn a single agent and wait for completion before checking for the next task.\n\n### What Sub-Agents Do\n\nEach sub-agent is responsible for:\n\n- Building context (`granary handoff --tasks <id>`)\n- Starting the task (`granary task <id> start`)\n- Doing the actual implementation\n- Marking the task done (`granary task <id> done`) or blocked\n\n**Note:** You do NOT need to run `granary handoff` yourself. Sub-agents handle their own context building. Your job is to identify unblocked tasks and spawn agents.\n\n## Step 6: Handle Completion\n\nWhen all tasks are done:\n\n```bash\ngranary session close --summary \"Completed implementation of <project-name>\"\n```\n\n## Handling Edge Cases\n\n### Sub-Agent Gets Blocked\n\nIf a sub-agent cannot complete:\n\n```bash\n# Sub-agent should have blocked the task:\ngranary task <task-id> block --reason \"...\"\n\n# You see it when checking next task\ngranary next --format=prompt  # Will skip blocked tasks\n```\n\n### Conflict Prevention\n\nSub-agents should claim tasks with leases:\n\n```bash\ngranary task <task-id> claim --owner \"Worker-1\" --lease 30\n# Exit code 4 = conflict (task claimed by another)\n```\n\n## Checkpointing\n\nBefore risky operations:\n\n```bash\ngranary checkpoint create \"before-major-change\"\n\n# If things go wrong\ngranary checkpoint restore before-major-change\n```\n\n## Common Mistakes\n\n### Inspecting tasks to determine parallelism\n\n```bash\n# WRONG - Don't do this\ngranary project <id> tasks --json | jq '.[] | select(.blocked_by == null)'\n```\n\nThis bypasses the scheduler and leads to race conditions. Just because a task has no explicit `blocked_by` value doesn't mean it's ready to run. The scheduler considers implicit dependencies, project ordering, and other factors you can't see in task metadata.\n\n### Assuming task independence\n\n```bash\n# WRONG - Don't assume tasks can run together\ngranary show task-1  # blocked_by: null\ngranary show task-2  # blocked_by: null\ngranary show task-3  # blocked_by: null\n# \"All three have no blockers, I'll run them all!\"\n```\n\nTasks may have implicit logical dependencies. Task-3 might implement a service that uses schemas from task-1. Running them in parallel causes compiler errors.\n\n### Overriding scheduler decisions\n\n```bash\n# WRONG - Don't second-guess the scheduler\ngranary next --all  # Returns 2 tasks\n# \"But I checked and 6 tasks have no blockers, I'll launch 6 agents\"\n```\n\nIf `granary next --all` returns 2 tasks, there's a reason. Trust it.\n\n### The right approach\n\n```bash\n# RIGHT - Trust the scheduler completely\ngranary next --all --format=prompt\n# Returns task-1, task-2\n# Spawn exactly 2 agents, one for each task\n```\n\nOnly spawn agents for tasks returned by `granary next --all`. When they complete, run the command again to discover what's newly unblocked.\n\n## Summary\n\n1. **Get overview** â†’ `granary summary`\n2. **Find project** â†’ `granary projects`\n3. **Assess readiness** â†’ Are tasks planned? If not, use plan-work skill\n4. **Start session** â†’ `granary session start`\n5. **Loop: delegate tasks** â†’ Use `granary next --all`, spawn agents for **exactly** the tasks returned\n6. **Close session** â†’ `granary session close`\n\n**Your job is coordination, not implementation.** Sub-agents use `granary handoff` to build their own context and do the actual workâ€”you just spawn agents for the tasks that `granary next --all` returns.\n\n**Remember:** `granary next --all` is the scheduler. Trust it completely. If it returns 2 tasks, spawn 2 agents. Don't inspect task metadata to make your own parallelism decisionsâ€”that path leads to race conditions and compiler errors.\n",
        ".claude-plugin/skills/plan-work/SKILL.md": "---\nname: granary-plan-work\ndescription: Plan and organize work into granary projects and tasks. Use when breaking down a feature, creating tasks, or setting up dependencies.\n---\n\n# Planning Work in Granary\n\nUse this skill when you need to break down work into projects and tasks, or when an orchestrator determines a project needs planning before implementation.\n\n## Before You Plan: Do Thorough Research\n\n**Critical**: Before creating any tasks, conduct comprehensive research of the codebase. Each task description is the ONLY context a sub-agent receivesâ€”they cannot ask follow-up questions or explore further. Your research directly determines whether tasks succeed or fail.\n\n### Check for Existing Work First\n\nBefore creating a new project or task, search for similar existing work:\n\n```bash\n# Search for similar projects and tasks\ngranary search \"user profile\"\ngranary search \"authentication\"\ngranary search \"api endpoint\"\n```\n\n**Decision tree based on search results:**\n\n| Search Result | Action |\n|---------------|--------|\n| Exact match found (same feature) | Don't duplicateâ€”add tasks to existing project or update existing tasks |\n| Similar project exists | Review itâ€”maybe extend it instead of creating a new project |\n| Related tasks exist in other projects | Consider dependencies or consolidation |\n| No matches | Safe to create new project |\n\n**Example: Avoiding duplication**\n\n```bash\n$ granary search \"profile\"\nProjects:\n  user-profile-abc1: \"User Profile\" (3 tasks, 1 completed)\n\nTasks:\n  settings-xyz9-task-2: \"Add profile settings page\"\n```\n\nIn this case, don't create a new \"User Profile\" projectâ€”add your tasks to `user-profile-abc1` or coordinate with the existing work.\n\n### Research Checklist\n\n- [ ] **Search granary** - Check for existing similar projects and tasks\n- [ ] **Locate all relevant files** - Find existing implementations, tests, configs\n- [ ] **Understand existing patterns** - How does the codebase handle similar features?\n- [ ] **Identify dependencies** - What modules/services will be affected?\n- [ ] **Note file paths and line numbers** - Sub-agents need exact locations\n- [ ] **Document function signatures** - What interfaces exist?\n- [ ] **Find test patterns** - How are similar features tested?\n\n### Research Tools\n\n```bash\n# Check for existing planned work\ngranary search \"feature keywords\"\ngranary projects                    # List all projects\ngranary project <id> tasks          # See tasks in a specific project\n\n# Find relevant files in codebase\nglob \"**/*.rs\" | grep -i auth\ngrep -r \"UserService\" src/\n\n# Understand existing patterns\ncat src/services/user.rs | head -100\n```\n\nDocument your findings in steering files (see Section 5) before creating tasks.\n\n## 1. Create a Project\n\nGroup related tasks into a project:\n\n```bash\ngranary projects create \"Feature Name\" --description \"Clear description of what this project achieves\"\n```\n\nOutput gives you a project ID like `feature-name-abc1`.\n\n## 2. Break Down into Tasks\n\nCreate focused, actionable tasks:\n\n```bash\ngranary project <project-id> tasks create \"Task title\" \\\n  --description \"**Goal:** What this task accomplishes\n\n**Context:** Why this task exists\n\n**Requirements:**\n- Specific deliverable 1\n- Specific deliverable 2\n\n**Acceptance Criteria:**\n- [ ] Criterion 1\n- [ ] Criterion 2\" \\\n  --priority P1\n```\n\n### Priority Levels\n\n| Priority | When to Use                   |\n| -------- | ----------------------------- |\n| P0       | Critical, blocking other work |\n| P1       | Important, should do soon     |\n| P2       | Normal priority (default)     |\n| P3       | Nice to have                  |\n\n### Writing Good Task Descriptions\n\n**The task description is the ONLY context a sub-agent receives.** Sub-agents cannot explore the codebase or ask questionsâ€”they rely entirely on what you provide.\n\nInclude:\n\n- **Goal**: One sentence on what this achieves\n- **Context**: Why this matters, background info\n- **Requirements**: Specific deliverables\n- **Files to Modify**: Exact paths with line numbers where relevant\n- **Implementation Details**: Suggested approach, function signatures, patterns to follow\n- **Acceptance Criteria**: How to verify completion\n\n### Bad vs Good Task Descriptions\n\n**Bad**: \"Fix the auth bug\"\n\n**Good**:\n\n````\n**Goal:** Fix null pointer in UserService.getById when user not found.\n\n**Context:** Currently throws NullPointerException when querying non-existent user IDs. Should gracefully handle missing users.\n\n**Files to Modify:**\n- `src/services/user_service.rs:142-156` - The `get_by_id` function\n- `src/errors/mod.rs:23` - Add UserNotFoundException if not present\n- `tests/services/user_service_test.rs` - Add test case\n\n**Implementation Details:**\nThe existing pattern in `src/services/post_service.rs:89` handles this well:\n```rust\npub fn get_by_id(id: Uuid) -> Result<Option<Post>, ServiceError> {\n    // Returns Ok(None) for missing records\n}\n````\n\nFollow this patternâ€”return `Result<Option<User>, ServiceError>` instead of `Result<User, ServiceError>`.\n\n**Acceptance Criteria:**\n\n- [ ] `get_by_id` returns `Ok(None)` for missing users\n- [ ] Existing callers updated to handle `Option`\n- [ ] Test added for missing user case\n\n```\n\n### Linking Files in Descriptions\n\nAlways provide exact file paths and line numbers:\n\n| Instead of...                | Write...                                          |\n| ---------------------------- | ------------------------------------------------- |\n| \"the user service\"           | `src/services/user_service.rs`                    |\n| \"the auth middleware\"        | `src/middleware/auth.rs:45-67`                    |\n| \"follow the existing pattern\"| \"follow pattern in `src/handlers/posts.rs:23-45`\" |\n| \"add tests\"                  | \"add tests in `tests/unit/user_test.rs`\"          |\n\n### Implementation Detail Examples\n\n**For new endpoints:**\n```\n\n**Implementation Details:**\nAdd handler in `src/handlers/profile.rs`. Follow the pattern from `src/handlers/user.rs:34-56`:\n\n1. Create `GetProfileHandler` struct implementing `Handler` trait\n2. Use `ProfileService::get_by_user_id()` (already exists at `src/services/profile.rs:12`)\n3. Return `ApiResponse<ProfileDto>` matching existing response format\n4. Register route in `src/routes/mod.rs:45` following existing pattern\n\n```\n\n**For refactoring:**\n```\n\n**Implementation Details:**\nExtract validation logic from `src/handlers/user.rs:78-112` into `src/validators/user_validator.rs`.\n\nExisting validator pattern at `src/validators/post_validator.rs`:\n\n- Implement `Validator<T>` trait\n- Return `ValidationResult` with field-level errors\n- Use `#[derive(Validate)]` macro for struct validation\n\nThe three validation functions to extract:\n\n- `validate_email()` (lines 82-89)\n- `validate_password()` (lines 91-98)\n- `validate_username()` (lines 100-110)\n\n```\n\n**For bug fixes:**\n```\n\n**Implementation Details:**\nRoot cause: `calculate_total()` at `src/cart/pricing.rs:45` doesn't account for null discounts.\n\nFix approach:\n\n1. Add null check before discount application (line 52)\n2. Use `discount.unwrap_or(Decimal::ZERO)` pattern (see `src/cart/tax.rs:23`)\n3. Add debug logging using existing `tracing::debug!` macro\n\n````\n\n## 3. Add Dependencies\n\nIf tasks must be done in order:\n\n```bash\n# task-2 depends on task-1 (task-2 cannot start until task-1 is done)\ngranary task <project-id>-task-2 deps add <project-id>-task-1\n\n# View dependencies\ngranary task <project-id>-task-2 deps graph\n````\n\nYou can also specify dependencies at task creation time:\n\n```bash\ngranary project <project-id> tasks create \"Dependent task\" \\\n  --dependencies <project-id>-task-1\n```\n\nOnly add dependencies when truly required - over-constraining reduces parallelism.\n\n## 4. Start a Planning Session (Optional)\n\nFor complex planning:\n\n```bash\ngranary session start \"planning-feature-x\" --mode plan\ngranary session add <project-id>\n```\n\n## 5. Steering Files\n\nSteering files provide standards, conventions, and context that sub-agents should follow during implementation. Set these up during planning so orchestrators and sub-agents have the guidance they need.\n\n### Steering Scopes\n\n| Scope            | When Included                         | Use Case                  |\n| ---------------- | ------------------------------------- | ------------------------- |\n| Global (default) | Always in context/handoffs            | Project-wide standards    |\n| `--project <id>` | When project is in session scope      | Project-specific patterns |\n| `--task <id>`    | When handing off that specific task   | Task-specific research    |\n| `--for-session`  | During session, auto-deleted on close | Temporary research notes  |\n\n### Adding Steering Files (optional)\n\nSteering files are useful for:\n\n- Transient files, produced during deep research, e.g.:\n  - Summary of a technical article\n  - Explanation of how a system works\n- Task or project specific guidelines\n\n```bash\n# Global steering (always included)\ngranary steering add docs/coding-standards.md\n\n# Project-attached (only when this project is in context)\ngranary steering add docs/auth-patterns.md --project auth-proj-abc1\n\n# Task-attached (only in handoffs for this specific task)\ngranary steering add .granary/task-research.md --task auth-proj-abc1-task-3\n\n# Session-attached (temporary, auto-deleted on session close)\ngranary steering add .granary/temp-notes.md --for-session\n\n# List current steering files\ngranary steering list\n\n# Remove steering (specify scope to match)\ngranary steering rm docs/auth-patterns.md --project auth-proj-abc1\n```\n\n### When to Use Each Scope\n\n- **Global**: Project-wide coding standards, architecture decisions\n- **Project-attached**: Module-specific patterns (e.g., auth module conventions)\n- **Task-attached**: Research specific to one task (avoid polluting other handoffs)\n- **Session-attached**: Temporary research during planning that shouldn't persist\n\n### Example: Adding Steering During Planning\n\n```bash\n# During planning, document patterns you discover\ncat > docs/auth-patterns.md << 'EOF'\n# Authentication Patterns\n\n## Existing Conventions\n- Auth middleware in src/middleware/auth.rs uses JWT tokens\n- User model in src/models/user.rs with bcrypt password hashing\n- Session storage uses Redis (see src/services/session.rs)\n\n## Key Conventions\n- All API endpoints return JSON with {data, error, meta} structure\n- Use `ApiError` type for error handling\n- Tests go in tests/ directory, not inline\nEOF\n\n# Attach to the project so sub-agents get this context\ngranary steering add docs/auth-patterns.md --project auth-proj-abc1\n```\n\n## Example: Planning a User Profile Feature\n\n### Step 1: Check for Existing Work\n\nFirst, search granary for similar projects or tasks:\n\n```bash\n$ granary search \"profile\"\nNo matching projects or tasks found.\n\n$ granary search \"user\"\nProjects:\n  user-auth-def2: \"User Authentication\" (4 tasks, 4 completed)\n\nTasks:\n  user-auth-def2-task-3: \"Implement user login endpoint\"\n```\n\n**Analysis:** No existing profile work, but there's a completed auth project. We can reference patterns from `user-auth-def2` when building our profile feature. Safe to create a new project.\n\n### Step 2: Research the Codebase\n\nNow thoroughly research the codebase:\n\n```bash\n# Find existing user-related code\nglob \"**/*user*\"\ngrep -r \"struct User\" src/\n\n# Understand the API patterns\ncat src/handlers/mod.rs\ncat src/routes/mod.rs | head -50\n\n# Check existing types\ncat src/types/user.rs\n\n# Find test patterns\nls tests/\ncat tests/handlers/user_test.rs | head -30\n```\n\n**Research findings to document:**\n\n- User model at `src/models/user.rs:12-45` has `id`, `email`, `name`, `created_at`\n- Missing: `bio`, `avatar_url` fields needed for profile\n- Handler pattern at `src/handlers/user.rs:23-67` - uses `axum::Json<T>`\n- Routes registered in `src/routes/api.rs:34`\n- Tests use `mockall` for service mocking (see `tests/handlers/user_test.rs:5`)\n\n### Step 3: Create Project and Tasks\n\n```bash\n# Create project\ngranary projects create \"User Profile\" --description \"Add user profile page with edit capability. Extends existing User model with profile fields.\"\n# Output: user-profile-abc1\n\n# Task 1: Extend the data model\ngranary project user-profile-abc1 tasks create \"Extend User model with profile fields\" \\\n  --description \"**Goal:** Add profile fields to the User model and create database migration.\n\n**Context:** User model exists but lacks profile-specific fields.\n\n**Files to Modify:**\n- \\`src/models/user.rs:12-45\\` - Add new fields to User struct\n- \\`src/schema.rs\\` - Update diesel schema (auto-generated after migration)\n- \\`migrations/\\` - Create new migration file\n\n**Implementation Details:**\nAdd these fields to the User struct at \\`src/models/user.rs:12\\`:\n\\`\\`\\`rust\npub struct User {\n    // existing fields...\n    pub bio: Option<String>,        // max 500 chars\n    pub avatar_url: Option<String>, // validated URL\n}\n\\`\\`\\`\n\nCreate migration following pattern in \\`migrations/2024_01_15_create_users/up.sql\\`:\n\\`\\`\\`sql\nALTER TABLE users ADD COLUMN bio TEXT;\nALTER TABLE users ADD COLUMN avatar_url VARCHAR(2048);\n\\`\\`\\`\n\n**Acceptance Criteria:**\n- [ ] Migration runs successfully (\\`diesel migration run\\`)\n- [ ] User struct compiles with new fields\n- [ ] Existing user queries still work\" \\\n  --priority P0\n# Output: user-profile-abc1-task-1\n\n# Task 2: Create Profile DTOs and validation\ngranary project user-profile-abc1 tasks create \"Create Profile DTOs with validation\" \\\n  --description \"**Goal:** Create request/response DTOs for profile endpoints.\n\n**Files to Modify:**\n- \\`src/types/mod.rs:1\\` - Add mod declaration\n- \\`src/types/profile.rs\\` - New file for DTOs\n\n**Implementation Details:**\nFollow existing DTO pattern at \\`src/types/user.rs:8-25\\`:\n\\`\\`\\`rust\n#[derive(Serialize, Deserialize)]\npub struct ProfileResponse {\n    pub id: Uuid,\n    pub name: String,\n    pub email: String,\n    pub bio: Option<String>,\n    pub avatar_url: Option<String>,\n}\n\n#[derive(Deserialize, Validate)]\npub struct UpdateProfileRequest {\n    #[validate(length(max = 100))]\n    pub name: Option<String>,\n    #[validate(length(max = 500))]\n    pub bio: Option<String>,\n    #[validate(url)]\n    pub avatar_url: Option<String>,\n}\n\\`\\`\\`\n\nUse \\`validator\\` crate (already in Cargo.toml) for validation.\n\n**Acceptance Criteria:**\n- [ ] DTOs serialize/deserialize correctly\n- [ ] Validation rejects invalid inputs\n- [ ] Unit tests in \\`tests/types/profile_test.rs\\`\" \\\n  --priority P0 \\\n  --dependencies user-profile-abc1-task-1\n# Output: user-profile-abc1-task-2\n\n# Task 3: Implement API handlers\ngranary project user-profile-abc1 tasks create \"Implement profile API handlers\" \\\n  --description \"**Goal:** Create GET and PUT handlers for profile endpoints.\n\n**Context:** DTOs defined in task-2. User model extended in task-1.\n\n**Files to Modify:**\n- \\`src/handlers/mod.rs:5\\` - Add mod declaration\n- \\`src/handlers/profile.rs\\` - New handler file\n- \\`src/routes/api.rs:34\\` - Register new routes\n- \\`tests/handlers/profile_test.rs\\` - New test file\n\n**Implementation Details:**\nFollow handler pattern at \\`src/handlers/user.rs:23-67\\`:\n\n\\`\\`\\`rust\n// GET /api/profile/:id\npub async fn get_profile(\n    State(pool): State<DbPool>,\n    Path(user_id): Path<Uuid>,\n) -> Result<Json<ProfileResponse>, ApiError> {\n    let user = UserService::get_by_id(&pool, user_id)\n        .await?\n        .ok_or(ApiError::NotFound)?;\n    Ok(Json(ProfileResponse::from(user)))\n}\n\n// PUT /api/profile/:id (requires auth)\npub async fn update_profile(\n    State(pool): State<DbPool>,\n    Extension(current_user): Extension<AuthUser>,\n    Path(user_id): Path<Uuid>,\n    Json(req): Json<UpdateProfileRequest>,\n) -> Result<Json<ProfileResponse>, ApiError> {\n    // Verify user can only update own profile\n    if current_user.id != user_id {\n        return Err(ApiError::Forbidden);\n    }\n    req.validate()?;\n    // ... update logic\n}\n\\`\\`\\`\n\nRegister routes in \\`src/routes/api.rs:34\\` following existing pattern:\n\\`\\`\\`rust\n.route(\\\"/profile/:id\\\", get(get_profile))\n.route(\\\"/profile/:id\\\", put(update_profile).layer(auth_middleware()))\n\\`\\`\\`\n\n**Acceptance Criteria:**\n- [ ] GET returns profile data\n- [ ] PUT requires authentication\n- [ ] PUT validates ownership (users can only edit own profile)\n- [ ] Integration tests pass\" \\\n  --priority P1 \\\n  --dependencies user-profile-abc1-task-2\n# Output: user-profile-abc1-task-3\n\n# Add steering file with research findings\ncat > docs/profile-patterns.md << 'EOF'\n# Profile Feature Patterns\n\n## Existing Codebase Patterns\n- Handlers use `axum` extractors: `State`, `Path`, `Json`, `Extension`\n- Auth middleware at `src/middleware/auth.rs:12` adds `AuthUser` to extensions\n- Error handling uses `ApiError` enum at `src/errors/api_error.rs`\n- All responses wrapped in `Json<T>`\n\n## Database Access\n- Use `UserService` at `src/services/user.rs` for queries\n- Connection pool passed via `State<DbPool>`\n- Async queries with `sqlx`\n\n## Testing\n- Integration tests in `tests/handlers/`\n- Use `TestApp::new()` helper at `tests/common/mod.rs:8`\n- Mock services with `mockall` when needed\nEOF\n\ngranary steering add docs/profile-patterns.md --project user-profile-abc1\n```\n\n## Summary\n\n1. **Search for existing work** - Use `granary search` to find similar projects/tasks before creating duplicates\n2. **Research thoroughly** - Explore the codebase, find patterns, note file paths and line numbers\n3. **Create project** with clear description (or add to existing project if found)\n4. **Break into tasks** with detailed descriptions including:\n   - Exact file paths with line numbers\n   - Implementation details with code examples\n   - References to existing patterns to follow\n5. **Add dependencies** only where truly required\n6. **Set up steering** to document research findings and conventions\n7. Hand off to `/granary:orchestrate` for implementation\n\n**Remember:** Sub-agents only see task descriptions. Every detail they need must be in the task or steering filesâ€”they cannot explore or ask questions.\n",
        ".claude-plugin/skills/setup/SKILL.md": "---\nname: granary-setup\ndescription: Set up granary in a new project. Use when asked to initialize granary, install it, or get started with task management.\n---\n\n# Setting Up Granary\n\nUse this skill when the user asks you to set up granary in their project.\n\n## 1. Check Installation\n\nFirst, verify granary is installed:\n\n```bash\nwhich granary\n```\n\nIf not installed, direct the user to install it:\n\n```bash\n# macOS/Linux\ncurl -fsSL https://raw.githubusercontent.com/danielkov/granary/main/scripts/install.sh | sh\n\n# Windows PowerShell\nirm https://raw.githubusercontent.com/danielkov/granary/main/scripts/install.ps1 | iex\n```\n\n## 2. Initialize Workspace\n\nInitialize granary in the project directory:\n\n```bash\ngranary init\n```\n\nThis creates a `.granary/` directory with the SQLite database.\n\n## 3. Verify Setup\n\nCheck that granary is working:\n\n```bash\ngranary doctor\n```\n\n## Done\n\nGranary is now ready. The user can:\n\n- Create projects with `granary projects create \"Project Name\" --description \"...\"`\n- Create tasks with `granary project <id> tasks create \"Task title\" --description \"...\"`\n- Start sessions with `granary session start \"session-name\"`\n",
        ".claude/skills/bump-plugin-version.md": "---\nname: bump-plugin-version\ndescription: Update plugin and marketplace versions after changes to .claude-plugin/. Use when skills, commands, or plugin config have been modified.\n---\n\n# Bump Plugin Version\n\nAfter modifying `.claude-plugin/` files:\n\n1. Read current version from `.claude-plugin/plugin.json`\n2. Bump version (patch for fixes, minor for new skills/commands)\n3. Update `version` in both:\n   - `.claude-plugin/plugin.json`\n   - `.claude-plugin/marketplace.json` (root `version` AND `plugins[0].version`)\n4. Verify all three version fields match\n",
        ".claude/skills/finalize.md": "---\nname: finalize\ndescription: IMPORTANT! you must use this skill when a granary project is complete\n---\n\n# Finalize Project\n\nAfter a project is complete (no outstanding tasks):\n\n1. **Verify branch**: Ensure you're on a feature branch (not main/master)\n2. **Format code**: Run `cargo fmt`\n3. **Run tests**: Run `cargo test`\n4. **Handle failures**: If tests fail, create new tasks to fix the failing tests and stop\n5. **If all tests pass**:\n   - Assess the changes made during the project\n   - Increment the version in `Cargo.toml` according to semver:\n     - **patch**: bug fixes, minor improvements\n     - **minor**: new features, backwards-compatible changes\n     - **major**: breaking changes\n   - Create a PR using `gh pr create` with a summary of changes\n",
        ".claude/skills/update-e2e-tests.md": "---\nname: update-e2e-tests\ndescription: Update end-to-end tests after CLI API changes. Use when public commands, flags, or output formats have been modified.\n---\n\n# Update E2E Tests\n\nAfter modifying the CLI's public API:\n\n1. Add tests to `./test-e2e.sh` following existing patterns\n2. Use assertions to verify output:\n   ```bash\n   OUTPUT=$(granary <command> --json)\n   [[ -n \"$OUTPUT\" ]] || { echo \"FAIL: Expected output\"; exit 1; }\n   echo \"$OUTPUT\" | grep -q \"expected\" || { echo \"FAIL: Missing expected\"; exit 1; }\n   ```\n3. All operations MUST use `$TEST_DIR` - never the repo root\n4. Run `./test-e2e.sh` to verify\n",
        "README.md": "# Granary\n\nA CLI context hub for agentic work. Granary supercharges your agentic workflows. It seamlessly integrates into your existing AI tools and teaches them how to share and manage context more efficiently.\n\n## Features\n\n- **Session-centric**: Explicit \"what's in context\" for each agent run\n- **LLM-first I/O**: Every command has `--json` and `--format prompt` for machine consumption\n- **Local-first**: All state stored locally (SQLite), no network dependency\n- **Concurrency-tolerant**: Task claiming with leases for multi-agent safety\n- **Context packs**: Generate summaries and handoffs optimized for LLM context windows\n\n## Getting started for Claude Code\n\n1. Add the granary marketplace\n\n```sh\nclaude plugin marketplace add danielkov/granary\n```\n\n2. Install the granary plugin from the marketplace\n\n```sh\nclaude plugin install granary@granary\n```\n\n3. Launch Claude and verify skills are available with `/skills` - you should see something like:\n\n```sh\n  granary-orchestrate Â· ~43 tokens\n  granary-initiative-planner Â· ~40 tokens\n  granary-plan-work Â· ~38 tokens\n  granary-setup Â· ~33 tokens\n  granary-execute-task Â· ~28 tokens\n```\n\n4. Prompt Claude to `set up granary for this project`\n\nClaude will install and initialize `granary` in your project.\n\n## How to get the most out of Granary\n\nGranary works best when used with the Claude Code skills. The skills teach Claude how to use Granary effectively.\n\n### Example workflows\n\nUse similar prompts to see Granary in action.\n\n- `use granary to plan a new audit service`\n- Once the plan is complete, you can review it with `granary summary`\n- Start implementation by telling Claude: `use granary to implement audit service`\n\n## Installation\n\n### macOS / Linux\n\n```sh\ncurl -sSfL https://raw.githubusercontent.com/danielkov/granary/main/scripts/install.sh | sh\n```\n\n### Windows (PowerShell)\n\n```powershell\nirm https://raw.githubusercontent.com/danielkov/granary/main/scripts/install.ps1 | iex\n```\n\n### Installing a specific version\n\nYou can install a specific version (including pre-releases) by setting the `GRANARY_VERSION` environment variable:\n\n**macOS / Linux:**\n\n```sh\nGRANARY_VERSION=0.6.2 curl -sSfL https://raw.githubusercontent.com/danielkov/granary/main/scripts/install.sh | sh\n```\n\n**Windows (PowerShell):**\n\n```powershell\n$env:GRANARY_VERSION='0.6.2'; irm https://raw.githubusercontent.com/danielkov/granary/main/scripts/install.ps1 | iex\n```\n\n### Updating\n\nTo update to the latest stable version:\n\n```sh\ngranary update\n```\n\nTo install a specific version (including pre-releases):\n\n```sh\ngranary update --to=0.6.3-pre.1\n```\n\n### From source\n\nRequires [Rust](https://rustup.rs/):\n\n```sh\ncargo install --git https://github.com/danielkov/granary.git\n```\n\n## Quick Start\n\n```sh\n# Initialize a workspace\ngranary init\n\n# Create a project\ngranary projects create \"My Project\" --description \"Building something great\"\n\n# Start a session\ngranary session start \"feature-work\" --owner \"Claude Code\"\n\n# Add tasks\ngranary project my-project-xxxx tasks create \"Implement login\" --priority P0\ngranary project my-project-xxxx tasks create \"Add tests\" --priority P1\n\n# Get the next actionable task\ngranary next\n\n# Start working on a task\ngranary start my-project-xxxx-task-1\n\n# Mark it done\ngranary task my-project-xxxx-task-1 done\n\n# Get a summary for your LLM\ngranary summary --format prompt\n```\n\n## Why Granary?\n\nGranary is designed for the agentic loop pattern:\n\n1. **Plan**: Create projects and tasks, set dependencies\n2. **Execute**: Agents claim tasks, work on them, report progress\n3. **Coordinate**: Multiple agents can work safely in parallel with leases\n4. **Handoff**: Generate context packs for sub-agents or human review\n\n### Key Concepts\n\n- **Workspace**: A directory (typically a repo) containing `.granary/`\n- **Project**: Long-lived initiative with tasks and steering references\n- **Task**: Unit of work with status, priority, dependencies, and claiming\n- **Session**: Container for \"what's in context\" for a run\n- **Checkpoint**: Snapshot of state for pause/resume or rollback\n\n## Commands\n\n```\ngranary init          # Initialize workspace\ngranary projects      # List/create projects\ngranary tasks         # List tasks in session scope\ngranary next          # Get next actionable task\ngranary start <id>    # Start working on a task\ngranary summary       # Generate work summary\ngranary context       # Export context pack for LLM\ngranary handoff       # Generate handoff for sub-agent\ngranary checkpoint    # Create/restore checkpoints\ngranary search        # Search projects and tasks by title\ngranary workers       # List all workers\ngranary worker start  # Start a new event-driven worker\ngranary runs          # List all runner executions\n```\n\nUse `granary --help` or `granary <command> --help` for detailed usage.\n\n## Output Formats\n\nEvery command supports multiple output formats:\n\n```sh\ngranary tasks                    # Human-readable table\ngranary tasks --json             # JSON for parsing\ngranary tasks --format yaml      # YAML\ngranary tasks --format md        # Markdown\ngranary tasks --format prompt    # Optimized for LLM context\n\ngranary search \"api\"             # Search in human-readable table\ngranary search \"api\" --json      # JSON for parsing\n```\n\n## Watch Mode\n\nMonitor changes in real-time with `--watch`. The output refreshes automatically at a configurable interval:\n\n```sh\n# Watch tasks with default 2-second refresh\ngranary tasks --watch\n\n# Watch workers with 5-second refresh\ngranary workers --watch --interval 5\n\n# Watch runs filtered by status\ngranary runs --watch --status running\n\n# Watch search results\ngranary search \"api\" --watch\n```\n\nSupported commands: `tasks`, `projects`, `workers`, `runs`, `sessions`, `initiatives`, `search`, `summary`\n\nPress `Ctrl+C` to exit watch mode.\n\n## Integration with Claude Code\n\nGranary works seamlessly with Claude Code and other LLM coding assistants:\n\n```sh\n# Set session for sub-agents\neval $(granary session env)\n\n# Generate context for prompts\ngranary context --format prompt --token-budget 2000\n\n# Handoff to a review agent\ngranary handoff --to \"Code Review Agent\" --tasks task-1,task-2\n```\n\n## Workers (Event-driven Automation)\n\nWorkers are long-running processes that subscribe to granary events and automatically spawn commands. For example, automatically run Claude Code when tasks become unblocked:\n\n```sh\n# Configure a runner\ngranary config runners add claude \\\n  --command \"claude\" \\\n  --arg \"--print\" \\\n  --arg \"--message\" \\\n  --arg \"Execute task {task.id}\"\n\n# Start a worker\ngranary worker start --runner claude --on task.unblocked\n```\n\nSee [docs/workers.md](docs/workers.md) for complete documentation on workers, runners, filters, and template substitution.\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "granary",
          "description": "Context hub for agentic workflows - manage projects, tasks, sessions, and multi-agent coordination",
          "version": "0.5.1",
          "author": {
            "name": "Daniel Kovacs",
            "email": "kovacsemod@gmail.com"
          },
          "source": "./",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add danielkov/granary",
            "/plugin install granary@granary"
          ]
        }
      ]
    }
  ]
}