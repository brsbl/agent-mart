{
  "author": {
    "id": "lfnovo",
    "display_name": "Luis Novo",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/579178?u=6c2949fe733f6e3ac1b436861a07555d031b866a&v=4",
    "url": "https://github.com/lfnovo",
    "bio": "Someone that is addicted to learning new stuff, committed to helping as many people as possible to achieve their full potential. Open Source lover!",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 10,
      "total_skills": 0,
      "total_stars": 3,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "por-marketplace",
      "version": null,
      "description": "A development plugin for the Product on Rails methodology",
      "owner_info": {
        "name": "Luis Novo"
      },
      "keywords": [],
      "repo_full_name": "lfnovo/por-marketplace",
      "repo_url": "https://github.com/lfnovo/por-marketplace",
      "repo_description": "Claude Code marketplace for the Product on Rails methodology",
      "homepage": null,
      "signals": {
        "stars": 3,
        "forks": 0,
        "pushed_at": "2026-01-29T11:57:27Z",
        "created_at": "2025-12-15T22:33:26Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 207
        },
        {
          "path": "por-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 180
        },
        {
          "path": "por-dev/README.md",
          "type": "blob",
          "size": 7454
        },
        {
          "path": "por-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/commands/design.md",
          "type": "blob",
          "size": 11565
        },
        {
          "path": "por-dev/commands/discover.md",
          "type": "blob",
          "size": 6397
        },
        {
          "path": "por-dev/commands/fast",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/commands/fast/bug.md",
          "type": "blob",
          "size": 3144
        },
        {
          "path": "por-dev/commands/fast/chore.md",
          "type": "blob",
          "size": 2459
        },
        {
          "path": "por-dev/commands/fast/feature.md",
          "type": "blob",
          "size": 4056
        },
        {
          "path": "por-dev/commands/implement.md",
          "type": "blob",
          "size": 1208
        },
        {
          "path": "por-dev/commands/plan.md",
          "type": "blob",
          "size": 14594
        },
        {
          "path": "por-dev/commands/prime.md",
          "type": "blob",
          "size": 289
        },
        {
          "path": "por-dev/commands/util",
          "type": "tree",
          "size": null
        },
        {
          "path": "por-dev/commands/util/all-tools.md",
          "type": "blob",
          "size": 194
        },
        {
          "path": "por-dev/commands/util/generate-all-claude-mds.md",
          "type": "blob",
          "size": 4965
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n\"name\": \"por-marketplace\",\n\"owner\": {\n\"name\": \"Luis Novo\"\n},\n\"plugins\": [\n{\n  \"name\": \"por-dev\",\n  \"source\": \"./por-dev\",\n  \"description\": \"A development plugin for the Product on Rails methodology\"\n}\n]\n}\n",
        "por-dev/.claude-plugin/plugin.json": "{\n    \"name\": \"por-dev\",\n    \"description\": \"A development plugin for the Product on Rails methodology\",\n    \"version\": \"1.1.0\",\n    \"author\": {\n        \"name\": \"Luis Novo\"\n    }\n}",
        "por-dev/README.md": "# POR Dev Plugin\n\nA Claude Code plugin that provides structured workflows for feature development, bug fixes, and chores following the **Product on Rails** methodology.\n\n## Overview\n\nThis plugin helps you build features methodically by enforcing a structured approach to planning and implementation. It ensures thorough analysis before coding begins, reducing rework and improving code quality.\n\n**Key Benefits:**\n- Consistent planning process across all development tasks\n- Clear separation between discovery, design, planning, and implementation\n- Documented specs that serve as future reference\n- Flexible workflows for different task complexities\n\n## Installation\n\n```bash\n# Add the marketplace (if not already added)\nclaude plugin marketplace add https://github.com/lfnovo/por-marketplace\n\n# Install the plugin\nclaude plugin install por-dev@por-marketplace\n```\n\n## Workflows\n\nThe plugin provides two main workflows depending on task complexity:\n\n### Fast Track (Quick Tasks)\n\nFor smaller, well-understood tasks where extensive planning isn't needed.\n\n```\n/prime ‚Üí /fast:[bug|chore|feature] ‚Üí /implement\n```\n\n| Command | Purpose |\n|---------|---------|\n| `/fast:bug <description>` | Plan a surgical bug fix with root cause analysis |\n| `/fast:chore <description>` | Plan a simple maintenance task |\n| `/fast:feature <description>` | Plan a new feature with phased implementation |\n\n**Output:** Creates a single plan file at `specs/<task-name>.md`\n\n### Complete Workflow (Complex Features)\n\nFor larger features requiring thorough analysis and architecture design.\n\n```\n/prime ‚Üí /discover ‚Üí /design ‚Üí /plan ‚Üí /implement\n```\n\n| Command | Purpose |\n|---------|---------|\n| `/discover <input>` | Create feature specification from requirements |\n| `/design` | Design technical architecture |\n| `/plan` | Generate detailed implementation tasks |\n\n**Output:** Creates structured documentation in `specs/<feature-slug>/`:\n- `spec.md` - Feature requirements and user stories\n- `architecture.md` - Technical design and decisions\n- `contracts.md` - API/data contracts (if applicable)\n- `plan.md` - Step-by-step implementation tasks\n\n## Command Reference\n\n### `/prime`\n\n**Always run first.** Primes the agent with codebase context by reading project structure, README, and available documentation.\n\n```bash\n/prime\n```\n\n### `/discover <input>`\n\nCreates a feature specification from requirements. Input can be:\n- Natural language description\n- Path to a requirements file\n- Project management card (via MCP tools)\n\n```bash\n/discover \"Add user authentication with OAuth support\"\n/discover ./requirements/auth-feature.md\n/discover LINEAR-123\n```\n\n**What it does:**\n1. Creates a feature branch and `specs/<feature-slug>/` folder\n2. Analyzes requirements to extract: actors, actions, data, constraints\n3. Generates `spec.md` with user stories, functional requirements, and success criteria\n4. Identifies clarification questions and presents them for review\n\n### `/design`\n\nTransforms requirements into technical architecture. Requires completed `spec.md`.\n\n```bash\n/design\n```\n\n**What it does:**\n1. Researches unfamiliar libraries/APIs\n2. Analyzes existing codebase patterns\n3. Designs component structure and data flow\n4. Generates `architecture.md` with technical decisions and rationale\n5. Optionally generates `contracts.md` for API/data contracts\n\n### `/plan`\n\nBreaks architecture into actionable implementation tasks. Requires completed `architecture.md`.\n\n```bash\n/plan\n```\n\n**What it does:**\n1. Organizes tasks by phase (Setup ‚Üí Foundational ‚Üí User Stories ‚Üí Polish)\n2. Identifies parallel execution opportunities\n3. Estimates time per phase\n4. Generates `plan.md` with trackable task list\n\n### `/implement [--ff|--phases]`\n\nExecutes the implementation plan.\n\n```bash\n/implement              # Default: phased approach with review stops\n/implement --ff         # Fast-forward: complete build without stops\n/implement --phases     # Explicit phased approach\n```\n\n**Modes:**\n- `--phases` (default): Stops after each phase for user review\n- `--ff`: Builds completely, only stops for questions or blockers\n\n**What it does:**\n1. Reads and executes the plan step-by-step\n2. Updates `plan.md` marking completed tasks\n3. Reports summary and `git diff --stat` when done\n\n### `/fast:bug <description>`\n\nQuick planning for bug fixes.\n\n```bash\n/fast:bug \"Login fails when email contains + character\"\n```\n\n**Creates plan with:**\n- Bug description and steps to reproduce\n- Root cause analysis\n- Surgical fix approach (minimal changes)\n- Validation commands\n\n### `/fast:chore <description>`\n\nQuick planning for maintenance tasks.\n\n```bash\n/fast:chore \"Upgrade dependencies to latest versions\"\n```\n\n**Creates plan with:**\n- Chore description\n- Step-by-step tasks\n- Validation commands\n\n### `/fast:feature <description>`\n\nQuick planning for smaller features.\n\n```bash\n/fast:feature \"Add export to CSV button on reports page\"\n```\n\n**Creates plan with:**\n- Feature description and user story\n- Phased implementation plan\n- Testing strategy\n- Acceptance criteria\n\n## Utility Commands\n\n### `/all-tools`\n\nLists all available Claude Code tools in the current session.\n\n```bash\n/all-tools\n```\n\n### `/generate-all-claude-mds`\n\nGenerates CLAUDE.md documentation files throughout the codebase to help AI assistants understand the project structure.\n\n```bash\n/generate-all-claude-mds\n```\n\n**What it creates:**\n- Contextual maps for AI navigating the codebase\n- Integration guides showing how modules connect\n- Pattern documentation for consistent code generation\n- Gotcha lists preventing common AI mistakes\n\n**Hierarchy approach:**\n- Builds from deepest directories (leaves) up to root\n- Parent files reference children instead of duplicating content\n- Root serves as a navigation hub\n\n## Workflow Decision Guide\n\n| Scenario | Recommended Workflow |\n|----------|---------------------|\n| Simple bug fix | `/prime` ‚Üí `/fast:bug` ‚Üí `/implement` |\n| Dependency update | `/prime` ‚Üí `/fast:chore` ‚Üí `/implement` |\n| Small UI feature | `/prime` ‚Üí `/fast:feature` ‚Üí `/implement` |\n| New API endpoint | `/prime` ‚Üí `/discover` ‚Üí `/design` ‚Üí `/plan` ‚Üí `/implement` |\n| Complex feature | `/prime` ‚Üí `/discover` ‚Üí `/design` ‚Üí `/plan` ‚Üí `/implement` |\n| Refactoring | `/prime` ‚Üí `/fast:chore` or complete workflow |\n| Document codebase for AI | `/generate-all-claude-mds` |\n\n## Project Structure\n\nAfter using the plugin, your project will have:\n\n```\nyour-project/\n‚îú‚îÄ‚îÄ specs/\n‚îÇ   ‚îú‚îÄ‚îÄ fix-login-bug.md           # Fast track plans\n‚îÇ   ‚îú‚îÄ‚îÄ upgrade-deps.md\n‚îÇ   ‚îî‚îÄ‚îÄ user-authentication/       # Complete workflow\n‚îÇ       ‚îú‚îÄ‚îÄ spec.md\n‚îÇ       ‚îú‚îÄ‚îÄ architecture.md\n‚îÇ       ‚îú‚îÄ‚îÄ contracts.md\n‚îÇ       ‚îî‚îÄ‚îÄ plan.md\n‚îî‚îÄ‚îÄ ...\n```\n\n## Best Practices\n\n1. **Always start with `/prime`** - Ensures the agent understands your codebase\n2. **Use complete workflow for uncertainty** - When requirements are unclear or the feature is complex\n3. **Answer clarification questions** - The discover phase identifies ambiguities early\n4. **Review architecture before planning** - Catch design issues before implementation\n5. **Use `--phases` for learning** - See how the agent approaches each phase\n6. **Use `--ff` for confidence** - When you trust the plan and want faster execution\n\n## Contributing\n\nContributions are welcome! Please ensure any changes maintain the structured workflow philosophy.\n\n## License\n\nMIT\n",
        "por-dev/commands/design.md": "---\ndescription: Execute technical planning and architecture design for the feature\nargument-hint: [optional-context]\nmodel: opus\n---\n\n# Design Command\n\nThis command takes the requirements from `specs/<feature_slug>/spec.md` and transforms them into a concrete technical architecture by solving all its open questions and implementation ambiguities.\n\n## User Input\n\nArguments:\n```text\n$ARGUMENTS\n```\n\nYou **MUST** consider the user input before proceeding (if not empty).\n\n## Prerequisites\n\nBefore running this command:\n- ‚úÖ Feature specs must exist at `./specs/<feature_slug>/specs.md`\n- ‚úÖ You should be on the correct feature branch\n- ‚ùå Do NOT run this if specs are incomplete or have unresolved clarifications\n\n## Execution Flow\n\n### Step 0: Load Context\n\n1. Identify the current feature by checking:\n   - Current git branch name (if using git)\n   - Ask user to specify feature if unclear\n\n2. Load the specs file at `./specs/<feature_slug>/specs.md`\n\n3. Verify specs are complete:\n   - No `[NEEDS CLARIFICATION]` markers remaining\n   - All user stories defined with priorities\n   - Success criteria are clear\n   - If incomplete, STOP and tell user to run `/discover` first\n\n### Step 1: Technical Research\n\nBased on the requirements in specs.md, identify what you need to research:\n\n**Research Triggers:**\n- New libraries/frameworks mentioned that you're not familiar with\n- Integration with external services/APIs\n- Unfamiliar patterns or architectural approaches\n- Performance requirements that need specific solutions\n- Security/compliance requirements needing validation\n\n**Research Tools Available:**\n- **WebSearch**: For general technical information, library documentation, best practices\n- **Context7**: For library-specific documentation and examples\n- **Perplexity**: For recent technical decisions, comparisons, and up-to-date practices\n\n**Research Process:**\n1. List what needs research (be specific: \"How to implement rate limiting in xxxx framework\" not \"research rate limiting\")\n2. For each item, use the appropriate tool and synthesize findings\n3. Document key decisions as you research (don't wait until the end)\n\n**Important:** Don't research things you already know well. Focus on gaps in your knowledge that would affect implementation quality.\n\n### Step 2: Codebase Analysis\n\nUnderstand the existing codebase structure and patterns:\n\n**Discovery Questions:**\n- What is the existing tech stack? (language, frameworks, key libraries)\n- What are the established patterns? (file structure, naming conventions, architectural patterns)\n- Where do similar features live in the codebase?\n- What existing components can be reused?\n- What are the testing patterns?\n\n**Analysis Tools:**\n- Use available MCP tools to search and read code\n- Look for similar features to understand patterns\n- Identify the main directories and their purposes\n- Note any conventions (naming, structure, imports)\n\n**Tips:**\n- Search for keywords from your specs to find related code\n- Look at recent commits/PRs for active patterns\n- Check for README files explaining structure\n- Identify configuration files and their purposes\n\n### Step 3: Architecture Design\n\nNow design the architecture for this feature:\n\n**What to Define:**\n\n1. **Component Structure:**\n   - What new files/modules need to be created?\n   - What existing files need modification?\n   - How do components relate to each other?\n   - Where does each user story map to in the code?\n\n2. **Technical Decisions:**\n   - Which libraries/frameworks to use (with rationale)\n   - Which patterns to follow (with justification)\n   - How to handle edge cases\n   - Performance considerations\n   - Security considerations\n\n3. **Integration Points:**\n   - How does this feature integrate with existing code?\n   - What APIs/interfaces need to be defined?\n   - What side effects or dependencies exist?\n\n4. **Data Flow:**\n   - How does data move through the system?\n   - What transformations occur?\n   - Where is state managed?\n\n**Architecture Principles:**\n- Follow existing codebase patterns (don't reinvent)\n- Prefer simplicity over cleverness\n- Consider testability\n- Think about maintenance and debugging\n- Address non-functional requirements (performance, security, etc.)\n\n### Step 4: Generate architecture.md\n\nCreate `./specs/<feature_slug>/architecture.md` with this structure:\n\n```markdown\n# Architecture: [FEATURE NAME]\n\n**Feature**: [Feature name]\n**Date**: [Current date]\n**Branch**: [feature branch name]\n**Specs**: [Link to specs.md]\n\n## Summary\n\n[2-3 sentence overview: what we're building and the core technical approach]\n\n## Technical Context\n\n**Language/Stack**: [e.g., Python 3.11 + FastAPI, TypeScript + React, etc.]\n**Key Dependencies**: [Libraries/frameworks being used or added]\n**Storage**: [Database, files, cache - if applicable]\n**Testing**: [Testing approach and tools]\n**Platform**: [Where this runs - server, browser, mobile, etc.]\n\n## Technical Decisions\n\n### Decision 1: [Decision Title]\n\n**What**: [What was decided]\n**Why**: [Rationale for this decision]\n**Alternatives Considered**: [What else was considered and why rejected]\n**Trade-offs**: [What we gain vs what we lose]\n\n[Repeat for each major technical decision]\n\n## Architecture Overview\n\n[High-level description of how the system works before and after this change]\n\n### Component Structure\n\n**New Files/Modules:**\n```\npath/to/new/file.ext - Purpose and responsibility\npath/to/another/file.ext - Purpose and responsibility\n```\n\n**Modified Files:**\n```\npath/to/existing/file.ext - What changes and why\n```\n\n### Component Relationships\n\n[Describe how components interact - can use bullet points or simple diagrams]\n\n### Data Flow\n\n[Describe how data moves through the system for key user stories]\n\n## Implementation Approach\n\n### User Story Mapping\n\n**US1 (P1): [Story Title]**\n- Files involved: [list]\n- Key components: [list]\n- Dependencies: [if any]\n- Testing approach: [how to verify]\n\n**US2 (P2): [Story Title]**\n[Same structure]\n\n### File Structure\n\n```\n[Show the relevant part of the directory structure with new/modified files marked]\n\nproject/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ [existing]/\n‚îÇ   ‚îú‚îÄ‚îÄ [new-module]/          # NEW\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py       # NEW\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ core.py           # NEW\n‚îÇ   ‚îî‚îÄ‚îÄ [existing-file.py]    # MODIFIED\n‚îî‚îÄ‚îÄ tests/\n    ‚îî‚îÄ‚îÄ test_new_feature.py   # NEW\n```\n\n## Integration Points\n\n[Describe how this feature integrates with existing code]\n\n- **Integration with [Component A]**: [How and why]\n- **New APIs/Interfaces**: [What's exposed]\n- **Dependencies**: [What this feature depends on]\n\n## Technical Constraints\n\n- [Constraint 1: e.g., Must maintain backward compatibility with v1 API]\n- [Constraint 2: e.g., Response time must be <200ms]\n- [Constraint 3: e.g., Must work offline]\n\n## Risks & Mitigations\n\n| Risk | Impact | Mitigation |\n|------|--------|------------|\n| [Risk description] | [High/Med/Low] | [How we'll handle it] |\n\n## Open Questions\n\n[If any technical questions remain that need resolution before implementation]\n\n- [ ] Question 1\n- [ ] Question 2\n\n## Next Steps\n\n1. Review this architecture with stakeholders\n2. Resolve any open questions\n3. Run `/tasks` to break down into implementation tasks\n```\n\n### Step 5: Generate contracts.md (Optional)\n\n**Only create this file if the feature involves:**\n- External APIs or services\n- Data models with validation rules\n- Integration contracts with other systems\n- Complex request/response formats\n\nIf needed, create `./specs/<feature_slug>/contracts.md`:\n\n```markdown\n# Contracts: [FEATURE NAME]\n\n**Feature**: [Feature name]\n**Date**: [Current date]\n\n## Data Models\n\n### [Entity Name]\n\n**Purpose**: [What this represents]\n\n**Attributes:**\n- `field_name` (type): Description, validation rules\n- `another_field` (type): Description\n\n**Example:**\n```json\n{\n  \"field_name\": \"value\",\n  \"another_field\": 123\n}\n```\n\n[Repeat for each entity]\n\n## API Contracts\n\n### [Endpoint Name]\n\n**Endpoint**: `POST /api/path`\n**Purpose**: [What this does]\n\n**Request:**\n```json\n{\n  \"param1\": \"value\",\n  \"param2\": 123\n}\n```\n\n**Response (Success - 200):**\n```json\n{\n  \"result\": \"success\",\n  \"data\": {}\n}\n```\n\n**Response (Error - 400):**\n```json\n{\n  \"error\": \"Error message\"\n}\n```\n\n**Validation Rules:**\n- param1: Required, must be non-empty string\n- param2: Required, must be positive integer\n\n[Repeat for each endpoint/contract]\n\n## Integration Contracts\n\n[If integrating with external services, document the contract/expectations]\n\n### [Service Name]\n\n**What we expect:**\n- Input format: [describe]\n- Output format: [describe]\n- Error handling: [describe]\n\n## State Transitions\n\n[If there are complex state machines or workflows, document them]\n\n[Current State] --[Action]--> [New State]\n```\n\n### Step 6 Final Review & Report\n\nPresent to the user:\n\n1. **Summary of architecture:**\n   - Core technical approach\n   - Major decisions made\n   - Key components involved\n\n2. **Files generated:**\n   - Link to `architecture.md`\n   - Link to `contracts.md` (if created)\n   - Agent file updated (CLAUDE.md or AGENTS.md)\n\n3. **Key decisions to review:**\n   - List the most important architectural decisions\n   - Ask if user wants to discuss or adjust anything\n\n4. **Next steps:**\n   - Suggest reviewing the architecture.md\n   - Ask if they want to proceed to `/tasks` or iterate on architecture\n   - Mention any open questions that need resolution\n\n## Guidelines\n\n### Research Guidelines\n\n**When to use each tool:**\n- **WebSearch**: General information, official docs, Stack Overflow patterns\n- **Context7**: Library-specific docs, API references, code examples\n- **Perplexity**: Recent best practices, \"what's the latest way to...\", comparisons\n\n**How to research efficiently:**\n- Be specific in search queries\n- Look for official documentation first\n- Cross-reference multiple sources for important decisions\n- Document your findings as you go (don't wait until end)\n\n### Architecture Guidelines\n\n**Keep it pragmatic:**\n- Don't over-engineer\n- Follow existing patterns in the codebase\n- Consider the team's skill level and familiarity\n- Choose boring, proven technologies over shiny new ones\n\n**Think about the future:**\n- How easy is this to test?\n- How easy is this to debug?\n- How easy is this to extend?\n- How easy is this to maintain?\n\n**Address non-functionals:**\n- Performance requirements from specs\n- Security considerations\n- Accessibility needs (if applicable)\n- Error handling and resilience\n\n### Documentation Guidelines\n\n**Write for humans:**\n- Use clear, simple language\n- Explain WHY, not just WHAT\n- Include examples where helpful\n- Use diagrams/ASCII art if it helps clarity\n\n**Be concise but complete:**\n- Every section should add value\n- Remove boilerplate that doesn't apply\n- Focus on decisions and trade-offs\n- Link to external docs rather than copying them\n\n**Make it actionable:**\n- Anyone should be able to implement from this\n- Include enough detail for task breakdown\n- Highlight dependencies and prerequisites\n- Call out risks and gotchas\n\n## Error Handling\n\n**If specs.md is missing:**\n```\nERROR: No specs found at ./specs/<feature_slug>/specs.md\n\nPlease run `/discover` first to create the feature specification.\n```\n\n**If specs have unresolved clarifications:**\n```\nERROR: Specs contain [NEEDS CLARIFICATION] markers:\n- [List the markers]\n\nPlease resolve these before proceeding to architecture.\nYou can:\n1. Run `/discover` again to address clarifications\n2. Manually edit specs.md to resolve them\n```\n\nOnce you are done and the architecture is complete, run the /plan command. \n",
        "por-dev/commands/discover.md": "---\ndescription: Create or update the feature specification from a requirements file, card, or natural language feature description.\nargument-hint: [text-card-or-path]\nmodel: opus\n---\n\n# Feature Discovery\n\nYou're writing a plan to implement a net new feature that will add value to the application.\n\nThe text in the arguments is the requirements source. Your first step here is to analyze what is the source for the feature arguments, which could be: \n\n- A string (requirements typed in natural language)\n- A file in the local filesystem\n- A card in a project management software that you can access through MCP Tools\n\nBased on the identified source, acquire the necessary context by reviewing what was types, reading the file or pulling the card from the tool. \n\nGiven that feature description, do this:\n\n<arguments>\n#$ARGUMENTS\n</arguments>\n\nYou **MUST** consider the user input before proceeding (if not empty).\nIf the input is empty, error now and ask for a proper input.\n\n## Setup\n\n1. Create a slug for this feature (<feature_slug>), should be a git branch friendly name that is not in the ./specs folder (not repeated)\n2. Create the folder at ./specs/<feature_slug>\n3. Make sure we are in a branch with the same name. If not, create it.\n4. Parse user description from Input\n    If empty: ERROR \"No feature description provided\"\n5. Extract key concepts from description\n    Identify: actors, actions, data, constraints\n\n## Analysis\n\nGo through the cards, parents and children if required, and build an initial understanding of what needs to be build. Think carefully about what is requested, ensure you understand exactly: \n    - Why this is being built (context)\n    - What is the expected outcome for this issue? (goal)\n    - How should it be built, just directionally, not in details (approach)\n    - If it requires using new APIs/tools, do you understand them?\n    - How should this be tested?\n    - What are the dependencies?\n    - What are the constraints?\nAnything that isn't clear MUST be recorded as a question / clarification needed.\n\nOnce you have a good understanding of what is being built, save it in the specs/<feature_slug>/spec.md file and ask the human to review it.\n\nYour goal at this point is to extract the feature requirements from the functionality perspective, not to define its architecure. \n\n## General Guidelines\n\n## Quick Guidelines\n\n- Focus on **WHAT** users need and **WHY**.\n- Avoid HOW to implement (no tech stack, APIs, code structure) for now.\n- DO NOT create any checklists that are embedded in the spec. That will be a separate command.\n\n## Spec Format\n\n```md\n# Feature Specification: [FEATURE NAME]\n\n**Feature Branch**: `[###-feature-name]`  \n**Input**: User description: \"$ARGUMENTS\"\n\n## Context and Understanding \n\n[ Explain what you understand from the user requirements. What is the user trying to build and what is the motivation for it? What is wrong / missing today and needs to change?]\n\n## Feature Description\n<describe the feature in detail, including its purpose and value to users>\n\n## Requirements *(mandatory)*\n\n<!--\n  ACTION REQUIRED: The content in this section represents placeholders.\n  Fill them out with the right functional requirements.\n-->\n\n### Proposed solution\n\n<!--\n  ACTION REQUIRED: How will this feature really work? Think about user journeys, APIs, reports. Do we need tests? Do we need configuration changes? Are we handling deployment? Create as many stories as its required to deliver this.\n-->\nExamples:\n\n- **US-001**: User Story for an important feature\n- **US-002**: User Story for the backend service\n- **US-003**: User Story for the frontend implementation\n- **US-004**: User Story for configuration\n- **US-005**: User Story for unit testings\n\n\n### Functional Requirements\n\n- **FR-001**: System MUST [specific capability, e.g., \"allow users to create accounts\"]\n- **FR-002**: System MUST [specific capability, e.g., \"validate email addresses\"]  \n- **FR-003**: Users MUST be able to [key interaction, e.g., \"reset their password\"]\n- **FR-004**: System MUST [data requirement, e.g., \"persist user preferences\"]\n- **FR-005**: System MUST [behavior, e.g., \"log all security events\"]\n\n*Example of marking unclear requirements:*\n\n- **FR-006**: System MUST authenticate users via [NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]\n- **FR-007**: System MUST retain user data for [NEEDS CLARIFICATION: retention period not specified]\n\n## Success Criteria *(mandatory)*\n\n<!--\n  ACTION REQUIRED: Define measurable success criteria.\n  These must be technology-agnostic and measurable.\n-->\n\n### Measurable Outcomes\n\n- **SC-001**: [Measurable metric, e.g., \"Users can complete account creation in under 2 minutes\"]\n- **SC-002**: [Measurable metric, e.g., \"System handles 1000 concurrent users without degradation\"]\n- **SC-003**: [User satisfaction metric, e.g., \"90% of users successfully complete primary task on first attempt\"]\n- **SC-004**: [Business metric, e.g., \"Reduce support tickets related to [X] by 50%\"]\n\n## Clarification Needed\n<optionally list any questions and clarifications required to properly design the feature. A developer will answer them in time. If the user answers your clarification questions, you should update the documentation.>\n\n## Notes\n<optionally list any additional notes, future considerations, or context that are relevant to the feature that will be helpful to the developer>\n```\n\nAfter creating the spec file, present your questions to the human.\n\nAsk the questions in `Clarification Needed` section in one single message. Provide alternatives and suggest your preferred appraoch. \n\nExample:\n```\nI have finished my initial review. In the analysis process, I identified some issues that would benefit from clarification. I am providing each of them below. You can reply only for the items you want to change. Any item you don't reply to, I'll consider you accepted my suggestion. You can reply to all of them in the same message. \n\n1. Insert your question here provididing details on context and why it's important\nA) Option 1 \nB) Option 2\nC) Option 3\nD) Tell me what to do. \n\n(repeat this process for each question)\n```\n\nOnce the human provides you with the answers, MUST update the spec.md file and provide the human answer to your clarification questions so you can refer to them later. \n\nOnce you are done and the discovery is complete, run the /design command. ",
        "por-dev/commands/fast/bug.md": "# Bug Planning\n\nCreate a new plan in specs/*.md to resolve the `Bug` using the exact specified markdown `Plan Format`. Follow the `Instructions` to create the plan use the `Relevant Files` to focus on the right files.\n\n## Instructions\n\n- You're writing a plan to resolve a bug, it should be thorough and precise so we fix the root cause and prevent regressions.\n- Create the plan in the `specs/*.md` file. Name it appropriately based on the `Bug`.\n- Use the plan format below to create the plan. \n- Research the codebase to understand the bug, reproduce it, and put together a plan to fix it.\n- IMPORTANT: Replace every <placeholder> in the `Plan Format` with the requested value. Add as much detail as needed to fix the bug.\n- Use your reasoning model: THINK HARD about the bug, its root cause, and the steps to fix it properly.\n- IMPORTANT: Be surgical with your bug fix, solve the bug at hand and don't fall off track.\n- IMPORTANT: We want the minimal number of changes that will fix and address the bug.\n- Don't use decorators. Keep it simple.\n- If you need a new library, use `uv add` and be sure to report it in the `Notes` section of the `Plan Format`.\n- Respect requested files in the `Relevant Files` section.\n- Start your research by reading the `README.md` file.\n\n\n## Plan Format\n\n```md\n# Bug: <bug name>\n\n## Bug Description\n<describe the bug in detail, including symptoms and expected vs actual behavior>\n\n## Problem Statement\n<clearly define the specific problem that needs to be solved>\n\n## Solution Statement\n<describe the proposed solution approach to fix the bug>\n\n## Steps to Reproduce\n<list exact steps to reproduce the bug>\n\n## Root Cause Analysis\n<analyze and explain the root cause of the bug>\n\n## Relevant Files\nUse these files to fix the bug:\n\n<find and list the files that are relevant to the bug describe why they are relevant in bullet points. If there are new files that need to be created to fix the bug, list them in an h3 'New Files' section.>\n\n## Step by Step Tasks\nIMPORTANT: Execute every step in order, top to bottom.\n\n<list step by step tasks as h3 headers plus bullet points. use as many h3 headers as needed to fix the bug. Order matters, start with the foundational shared changes required to fix the bug then move on to the specific changes required to fix the bug. Include tests that will validate the bug is fixed with zero regressions. Your last step should be running the `Validation Commands` to validate the bug is fixed with zero regressions.>\n\n## Validation Commands\nExecute every command to validate the bug is fixed with zero regressions.\n\n<list commands you'll use to validate with 100% confidence the bug is fixed with zero regressions. every command must execute without errors so be specific about what you want to run to validate the bug is fixed with zero regressions. Include commands to reproduce the bug before and after the fix.>\n- `cd app/server && uv run pytest` - Run server tests to validate the bug is fixed with zero regressions\n\n## Notes\n<optionally list any additional notes or context that are relevant to the bug that will be helpful to the developer>\n```\n\n## Bug\n$ARGUMENTS",
        "por-dev/commands/fast/chore.md": "# Chore Planning\n\nCreate a new plan in specs/*.md to resolve the `Chore` using the exact specified markdown `Plan Format`. Follow the `Instructions` to create the plan use the `Relevant Files` to focus on the right files.\n\n## Instructions\n\n- You're writing a plan to resolve a chore, it should be simple but we need to be thorough and precise so we don't miss anything or waste time with any second round of changes.\n- Create the plan in the `specs/*.md` file. Name it appropriately based on the `Chore`.\n- Use the plan format below to create the plan. \n- Research the codebase and put together a plan to accomplish the chore.\n- IMPORTANT: Replace every <placeholder> in the `Plan Format` with the requested value. Add as much detail as needed to accomplish the chore.\n- Use your reasoning model: THINK HARD about the plan and the steps to accomplish the chore.\n- Respect requested files in the `Relevant Files` section.\n- Start your research by reading the `README.md` file.\n\n## Plan Format\n\n```md\n# Chore: <chore name>\n\n## Chore Description\n<describe the chore in detail>\n\n## Relevant Files\nUse these files to resolve the chore:\n\n<find and list the files that are relevant to the chore describe why they are relevant in bullet points. If there are new files that need to be created to accomplish the chore, list them in an h3 'New Files' section.>\n\n## Step by Step Tasks\nIMPORTANT: Execute every step in order, top to bottom.\n\n<list step by step tasks as h3 headers plus bullet points. use as many h3 headers as needed to accomplish the chore. Order matters, start with the foundational shared changes required to fix the chore then move on to the specific changes required to fix the chore. Your last step should be running the `Validation Commands` to validate the chore is complete with zero regressions.>\n\n## Validation Commands\nExecute every command to validate the chore is complete with zero regressions.\n\n<list commands you'll use to validate with 100% confidence the chore is complete with zero regressions. every command must execute without errors so be specific about what you want to run to validate the chore is complete with zero regressions. Don't validate with curl commands.>\n- `cd app/server && uv run pytest` - Run server tests to validate the chore is complete with zero regressions\n\n## Notes\n<optionally list any additional notes or context that are relevant to the chore that will be helpful to the developer>\n```\n\n## Chore\n$ARGUMENTS",
        "por-dev/commands/fast/feature.md": "# Feature Planning\n\nCreate a new plan in specs/*.md to implement the `Feature` using the exact specified markdown `Plan Format`. Follow the `Instructions` to create the plan use the `Relevant Files` to focus on the right files.\n\n## Instructions\n\n- You're writing a plan to implement a net new feature that will add value to the application.\n- Create the plan in the `specs/*.md` file. Name it appropriately based on the `Feature`.\n- Use the `Plan Format` below to create the plan. \n- Research the codebase to understand existing patterns, architecture, and conventions before planning the feature.\n- IMPORTANT: Replace every <placeholder> in the `Plan Format` with the requested value. Add as much detail as needed to implement the feature successfully.\n- Use your reasoning model: THINK HARD about the feature requirements, design, and implementation approach.\n- Follow existing patterns and conventions in the codebase. Don't reinvent the wheel.\n- Design for extensibility and maintainability.\n- If you need a new library, use `uv add` and be sure to report it in the `Notes` section of the `Plan Format`.\n- Start your research by reading the `README.md` file and docs/ folder.\n\n## Plan Format\n\n```md\n# Feature: <feature name>\n\n## Feature Description\n<describe the feature in detail, including its purpose and value to users>\n\n## User Story\nAs a <type of user>\nI want to <action/goal>\nSo that <benefit/value>\n\n## Problem Statement\n<clearly define the specific problem or opportunity this feature addresses>\n\n## Solution Statement\n<describe the proposed solution approach and how it solves the problem>\n\n## Relevant Files\nUse these files to implement the feature:\n\n<find and list the files that are relevant to the feature describe why they are relevant in bullet points. If there are new files that need to be created to implement the feature, list them in an h3 'New Files' section.>\n\n## Implementation Plan\n### Phase 1: Foundation\n<describe the foundational work needed before implementing the main feature>\n\n### Phase 2: Core Implementation\n<describe the main implementation work for the feature>\n\n### Phase 3: Integration\n<describe how the feature will integrate with existing functionality>\n\n## Step by Step Tasks\nIMPORTANT: Execute every step in order, top to bottom.\n\n<list step by step tasks as h3 headers plus bullet points. use as many h3 headers as needed to implement the feature. Order matters, start with the foundational shared changes required then move on to the specific implementation. Include creating tests throughout the implementation process. Your last step should be running the `Validation Commands` to validate the feature works correctly with zero regressions.>\n\n## Testing Strategy\n### Unit Tests\n<describe unit tests needed for the feature>\n\n### Integration Tests\n<describe integration tests needed for the feature>\n\n### Edge Cases\n<list edge cases that need to be tested>\n\n## Acceptance Criteria\n<list specific, measurable criteria that must be met for the feature to be considered complete>\n\n## Validation Commands\nExecute every command to validate the feature works correctly with zero regressions.\n\n<list commands you'll use to validate with 100% confidence the feature is implemented correctly with zero regressions. every command must execute without errors so be specific about what you want to run to validate the feature works as expected. Include commands to test the feature end-to-end.>\n- `cd app/server && uv run pytest` - Run server tests to validate the feature works with zero regressions\n\n\n## Clarification Needed\n<optionally list any questions and clarifications required to properly design the feature. A developer will answer them in time. Also include your default decision (the one you'll follow if your questions are not answered). If the user answers your clarification questions, you should update the documentation.>\n\n## Notes\n<optionally list any additional notes, future considerations, or context that are relevant to the feature that will be helpful to the developer>\n```\n\n## Feature\n$ARGUMENTS",
        "por-dev/commands/implement.md": "# Implement the following plan\nFollow the `Instructions` to implement the `Plan` then `Report` the completed work.\n\n## Instructions\n- Read the plan, think hard about the plan and implement the plan.\n\n## Parameters\n\nIf this command is called with the --ff parameter, it means you should build the feature completely. In this case, you should reach out to the user only a) if you are done, b) if you have question or c) if you find any blocks.\n\nIf the command is not called with any parameter or you find the --phases parameter in the arguments, then you should proceed with a phased approach to the development, which means you should stop after each phase and ask the user for review before continuing to the next stage. \n\n## Plan\n$ARGUMENTS\n\n## Report\n\nIn any mode (ff or phases), at the end of each phase:\n\n- Update the plan.md file (if there is one), marking completed tasks as done `[X]`\n- Add comments to the completed phase with a summary of what was accomplished, specially if you changed the plan for some reason.\n\n\nIn any mode (ff or phases), when you are done: \n\n- Summarize the work you've just done in a concise bullet point list.\n- Report the files and total lines changed with `git diff --stat`",
        "por-dev/commands/plan.md": "---\ndescription: Generate detailed implementation tasks organized by user story\nargument-hint: [optional-context]\n---\n\n# Tasks Command\n\nThis command breaks down the architecture into concrete, actionable implementation tasks organized by user story and phase.\n\n## User Input\n\nArguments:\n```text\n$ARGUMENTS\n```\n\nYou **MUST** consider the user input before proceeding (if not empty).\n\n## Prerequisites\n\nBefore running this command:\n- ‚úÖ Feature specs must exist at `./specs/<feature_slug>/specs.md`\n- ‚úÖ Architecture must exist at `./specs/<feature_slug>/architecture.md`\n- ‚úÖ You should be on the correct feature branch\n- ‚ùå Do NOT run this if architecture has unresolved open questions\n\n## Execution Flow\n\n### Step 0: Load Context\n\n1. Identify the current feature by checking:\n   - Current git branch name (if using git)\n   - Ask user to specify feature if unclear\n\n2. Load required files from `./specs/<feature_slug>/`:\n   - **Required**: `specs.md` (for user stories with priorities)\n   - **Required**: `architecture.md` (for tech decisions and components)\n   - **Optional**: `contracts.md` (for API endpoints and data models)\n\n3. Verify architecture is complete:\n   - No unresolved \"Open Questions\" section items\n   - All user stories have component mappings\n   - File structure is defined\n   - If incomplete, STOP and tell user to resolve architecture first\n\n### Step 1: Extract Information\n\nFrom the loaded documents, extract:\n\n**From specs.md:**\n- All user stories with priorities (P1, P2, P3, etc.)\n- For each user story: title, goal, acceptance criteria\n- Edge cases and special requirements\n\n**From architecture.md:**\n- Tech stack and dependencies\n- Component structure (new files, modified files)\n- User story mapping (which files belong to which story)\n- Integration points and dependencies\n- File structure and naming conventions\n\n**From contracts.md (if exists):**\n- Data models/entities\n- API endpoints\n- Validation rules\n- Request/response formats\n\n### Step 2: Organize Tasks by Phase\n\nBreak down the implementation into phases following this structure:\n\n**Phase 1: Setup** (~1-2h)\n- Project initialization\n- Dependency installation\n- Configuration setup\n- Development environment prep\n\n**Phase 2: Foundational** (~2-4h)\n- Core infrastructure that BLOCKS all user stories\n- Examples: Database setup, auth framework, base classes, routing infrastructure\n- CRITICAL: Nothing user-story-specific here - only blocking prerequisites\n\n**Phase 3+: User Stories** (one phase per story, in priority order)\n- Each user story gets its own phase\n- Organized by priority (P1 first, then P2, then P3, etc.)\n- Each phase should be ~2-4 hours of work\n- Include: models, services, endpoints, UI, tests (if requested)\n\n**Final Phase: Polish**\n- Documentation\n- Code cleanup\n- Performance optimization\n- Cross-cutting concerns\n\n### Step 3: Generate Tasks\n\nFor each phase, generate specific tasks following these rules:\n\n**Task Format:**\n```\n- [ ] T001 [P] [US1] Specific task description with file path\n```\n\n**Components:**\n- `[ ]` or `[x]`: Checkbox for completion tracking\n- `T001`: Unique sequential ID\n- `[P]`: OPTIONAL marker for tasks that can run in parallel (different files, no dependencies)\n- `[US1]`: User story reference (omit for Setup/Foundational/Polish phases)\n- Description: Concrete action with specific file path when relevant\n\n**Task Granularity:**\n- Each task should be completable in 15-30 minutes\n- Include enough detail that an LLM can execute it\n- Specify file paths when creating/modifying files\n- Be specific but not excessively verbose\n\n**Parallelization Rules:**\n- Mark [P] only if tasks touch different files\n- Same file = sequential (no [P] marker)\n- Different files with no logical dependency = [P]\n- Tests can often be [P] with each other\n\n**Test Tasks (OPTIONAL):**\n- Only include if explicitly requested in specs or user asks\n- Tests should come BEFORE implementation (TDD approach)\n- Each test task should verify it FAILS before implementation\n\n### Step 4: Estimate Time\n\nFor each phase, provide a realistic time estimate:\n- Setup: Usually 1-2h\n- Foundational: 2-4h (can be longer for complex setups)\n- User Stories: 2-4h each (adjust based on complexity)\n- Polish: 1-2h\n\nTime estimates help with:\n- Session planning (knowing when to take breaks)\n- Progress tracking\n- Resource allocation\n\n### Step 5: Map Dependencies\n\nDocument explicit dependencies between phases:\n- Which phases must complete before others can start\n- Which user stories are independent vs dependent\n- Parallel opportunities (which stories can be worked simultaneously)\n\n### Step 6: Generate plan.md\n\nCreate `./specs/<feature_slug>/plan.md` with this structure (the content itself is just for your reference, keep the structure):\n\n```markdown\n# Tasks: [FEATURE NAME]\n\n**Branch**: [branch-name]\n**Specs**: [link to specs.md]\n**Architecture**: [link to architecture.md]\n**Status**: Not Started ‚è≥\n\n---\n\n## Phase 1: Setup ‚è≥ (~2h)\n\n**Purpose**: Initialize project structure and dependencies\n\n- [ ] T001 [P] Create project structure per architecture.md\n- [ ] T002 [P] Install dependencies: [list key dependencies]\n- [ ] T003 Configure [linting/formatting tools]\n- [ ] T004 Setup development environment variables\n\n**Notes:**\n- [Space for learnings and comments during implementation]\n\n---\n\n## Phase 2: Foundational ‚è≥ (~3h)\n\n**Purpose**: Core infrastructure that BLOCKS all user stories\n\n‚ö†Ô∏è **CRITICAL**: No user story work can begin until this phase completes\n\n- [ ] T005 Setup database schema and migrations in [path]\n- [ ] T006 [P] Implement authentication middleware in [path]\n- [ ] T007 [P] Create base error handling in [path]\n- [ ] T008 Setup logging infrastructure in [path]\n\n**Checkpoint**: ‚úã Foundation ready - user stories can now proceed\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n## Phase 3: User Story 1 - [Title] (P1) ‚è≥ üéØ MVP (~4h)\n\n**Goal**: [Brief description from specs.md]\n\n**Independent Test**: [How to verify this story works standalone]\n\n### Tasks\n\n- [ ] T009 [P] [US1] Create [Entity] model in src/models/[entity].py\n- [ ] T010 [P] [US1] Create [Entity2] model in src/models/[entity2].py\n- [ ] T011 [US1] Implement [Service] in src/services/[service].py\n- [ ] T012 [US1] Create [endpoint/feature] in src/[path]/[file].py\n- [ ] T013 [US1] Add validation for [entity] fields\n- [ ] T014 [US1] Add error handling for [scenario]\n- [ ] T015 [US1] Add logging for [operations]\n\n**Checkpoint**: ‚úã User Story 1 complete and independently testable\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n## Phase 4: User Story 2 - [Title] (P2) ‚è≥ (~3h)\n\n**Goal**: [Brief description from specs.md]\n\n**Independent Test**: [How to verify this story works standalone]\n\n### Tasks\n\n- [ ] T016 [P] [US2] Create [Entity] model in src/models/[entity].py\n- [ ] T017 [US2] Implement [Service] in src/services/[service].py\n- [ ] T018 [US2] Create [endpoint/feature] in src/[path]/[file].py\n- [ ] T019 [US2] Integrate with User Story 1 (if needed)\n\n**Checkpoint**: ‚úã User Stories 1 AND 2 both work independently\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n[Repeat for each user story: Phase 5 for US3, Phase 6 for US4, etc.]\n\n---\n\n## Phase N: Polish & Documentation ‚è≥ (~2h)\n\n**Purpose**: Final touches and cross-cutting improvements\n\n- [ ] TXXX [P] Update README.md with new feature documentation\n- [ ] TXXX [P] Add inline code comments for complex logic\n- [ ] TXXX Code cleanup and refactoring\n- [ ] TXXX Performance optimization review\n- [ ] TXXX Security review checklist\n\n**Notes:**\n- [Space for learnings and comments]\n\n---\n\n## Dependencies & Execution Order\n\n### Phase Dependencies\n\n```\nSetup (Phase 1)\n    ‚Üì\nFoundational (Phase 2) ‚Üê BLOCKS everything below\n    ‚Üì\n    ‚îú‚îÄ‚Üí User Story 1 (Phase 3) - Can start\n    ‚îú‚îÄ‚Üí User Story 2 (Phase 4) - Can start in parallel OR after US1\n    ‚îî‚îÄ‚Üí User Story 3 (Phase 5) - Can start in parallel OR after US1/US2\n    ‚Üì\nPolish (Final Phase) - After all desired stories complete\n```\n\n### User Story Independence\n\n- **US1 (P1)**: No dependencies on other stories ‚úÖ MVP\n- **US2 (P2)**: [Independent OR depends on US1 - specify]\n- **US3 (P3)**: [Independent OR depends on US1/US2 - specify]\n\n### Parallel Opportunities\n\n**Within a phase:**\n- Tasks marked [P] can run simultaneously\n- Example: Multiple model files can be created in parallel\n\n**Across phases:**\n- After Foundational completes, ALL user stories CAN run in parallel\n- Recommended: Complete US1 first (MVP), then parallelize US2+US3\n\n---\n\n## Implementation Strategy\n\n### üéØ MVP First (Recommended)\n\n1. Complete Phase 1: Setup ‚úÖ\n2. Complete Phase 2: Foundational ‚úÖ\n3. Complete Phase 3: User Story 1 ‚úÖ\n4. **STOP and VALIDATE** - Test US1 independently\n5. Deploy/demo if ready\n6. Then proceed to US2, US3, etc.\n\n### üìà Incremental Delivery\n\nEach user story adds value independently:\n- After US1: Deploy MVP ‚úÖ\n- After US2: Deploy US1+US2 ‚úÖ\n- After US3: Deploy US1+US2+US3 ‚úÖ\n\n### üë• Parallel Team Strategy\n\nWith multiple developers after Foundational:\n- Developer A: User Story 1\n- Developer B: User Story 2  \n- Developer C: User Story 3\n- Stories integrate seamlessly when complete\n\n---\n\n## Progress Tracking\n\n**Emoji Legend:**\n- ‚è≥ Not Started\n- ‚è∞ In Progress\n- ‚úÖ Completed\n\n**Update this file as you work:**\n1. Change phase status emoji (‚è≥ ‚Üí ‚è∞ ‚Üí ‚úÖ)\n2. Check off tasks as completed: `- [x]`\n3. Add notes/learnings in the Notes sections\n4. Update time estimates if needed\n\n---\n\n## Task Execution Tips\n\n**Before starting a task:**\n- Read the task description carefully\n- Check if any [P] sibling tasks can run in parallel\n- Verify prerequisites are complete\n\n**While executing:**\n- Follow file paths exactly as specified\n- Match existing code patterns and conventions\n- Test incrementally (don't wait until phase end)\n\n**After completing a task:**\n- Mark it complete: `- [x]`\n- Commit if it's a logical unit\n- Add any learnings to Notes section\n\n**At checkpoints:**\n- Validate the entire phase works as expected\n- Test user story independently\n- Get user approval before continuing\n\n---\n\n## Notes\n\n**Key Conventions:**\n- [P] = Can run in parallel (different files)\n- [US1] = Belongs to User Story 1\n- File paths should be exact and absolute when possible\n- Commit after each task or logical grouping\n- Stop at checkpoints to validate\n\n**Remember:**\n- Each user story should be independently completable\n- Foundational phase blocks everything - don't skip it\n- MVP = Just User Story 1 (P1)\n- Add learnings to Notes sections as you discover them\n```\n\n### Step 7: Final Report\n\nPresent to the user:\n\n1. **Task Summary:**\n   - Total number of tasks: [X]\n   - Number of phases: [Y]\n   - Tasks per user story breakdown\n   - Estimated total time: [Z hours]\n\n2. **Files generated:**\n   - Link to `plan.md`\n\n3. **MVP Definition:**\n   - Clearly state what constitutes the MVP (usually just P1 user story)\n   - Estimated time to MVP: [X hours]\n\n4. **Parallel Opportunities:**\n   - Highlight which phases can be parallelized\n   - Note tasks marked [P] within phases\n\n5. **Next Steps:**\n   - Suggest reviewing plan.md\n   - Recommend starting with Phase 1 (Setup)\n   - Mention checkpoints for validation\n   - Ask if they want to proceed to `/work` or adjust tasks\n\n## Guidelines\n\n### Task Generation Guidelines\n\n**Be Specific:**\n- ‚ùå \"Implement user authentication\"\n- ‚úÖ \"Implement JWT authentication middleware in src/auth/jwt.py\"\n\n**Be Actionable:**\n- Each task should have a clear deliverable\n- Include file paths when creating/modifying code\n- Specify what needs to be tested\n\n**Be Realistic:**\n- Each task: 15-30 minutes\n- Each phase: 2-4 hours\n- Don't create micro-tasks (too granular)\n- Don't create mega-tasks (too broad)\n\n**Be Independent:**\n- User stories should be independently completable\n- Mark dependencies explicitly when they exist\n- Prefer independence over tight coupling\n\n### Time Estimation Guidelines\n\n**Consider:**\n- Complexity of the task\n- Need for research/learning\n- Testing and debugging time\n- Integration complexity\n\n**Default Estimates:**\n- Simple CRUD: 2-3h per user story\n- API endpoints: 3-4h per user story\n- Complex business logic: 4-6h per user story\n- UI components: 2-4h per user story\n\n**Adjust based on:**\n- Team experience with tech stack\n- Code familiarity\n- Availability of examples/patterns\n\n### Documentation Guidelines\n\n**Notes Sections:**\n- Use for learnings during implementation\n- Document unexpected issues\n- Record decisions made on-the-fly\n- Capture \"gotchas\" for future reference\n\n**Status Tracking:**\n- Update emojis as phases progress\n- Check off tasks as completed\n- Keep the file current (living document)\n\n## Error Handling\n\n**If specs.md is missing:**\n```\nERROR: No specs found at ./specs/<feature_slug>/specs.md\n\nPlease run `/specify` first to create the feature specification.\n```\n\n**If architecture.md is missing:**\n```\nERROR: No architecture found at ./specs/<feature_slug>/architecture.md\n\nPlease run `/plan` first to create the technical architecture.\n```\n\n**If architecture has open questions:**\n```\nWARNING: Architecture has unresolved open questions:\n- [List them]\n\nResolve these before generating tasks, or tasks may be incomplete.\nProceed anyway? (yes/no)\n```\n\n**If no user stories found:**\n```\nERROR: No user stories found in specs.md\n\nUser stories are required to organize tasks by priority.\nPlease update specs.md with user stories before running /tasks.\n```\n\n## Example Flow\n\n```\nUser: /tasks\n\nClaude:\nI'll break down the architecture into actionable tasks.\n\n[Loads specs.md and architecture.md from ./specs/001-api-endpoints/]\n\nFound:\n- 3 user stories (P1, P2, P3)\n- Tech stack: Python 3.11 + FastAPI\n- 5 new files to create, 2 files to modify\n\nGenerating tasks organized by user story...\n\n‚úÖ Tasks created!\n\nüìÑ File: ./specs/001-api-endpoints/plan.md\n\nüìä Summary:\n- Total tasks: 24\n- Phases: 6 (Setup, Foundational, 3 User Stories, Polish)\n- Estimated time: ~16 hours\n- MVP (US1 only): ~7 hours\n\nüéØ MVP Definition:\nUser Story 1 (P1): \"API Authentication\" - Allows users to authenticate via JWT\n\nüîÄ Parallel Opportunities:\n- Within Phase 2: Tasks T005-T007 can run in parallel\n- After Phase 2: All user stories can proceed in parallel\n- Within each user story: Model creation tasks marked [P]\n\nüí° Recommended Approach:\n1. Start with Phase 1 (Setup) - ~2h\n2. Complete Phase 2 (Foundational) - ~3h ‚ö†Ô∏è This blocks everything\n3. Focus on Phase 3 (US1 - MVP) - ~4h\n4. Validate US1 works independently ‚úã\n5. Then proceed to US2 and US3 in any order\n\nReady to start implementation? Run `/implement` when you're ready!\n```",
        "por-dev/commands/prime.md": "# Prime\n> Execute the following sections to understand the codebase then summarize your understanding.\n\n## Run\ngit ls-files\n\n## Read\nREADME.md\n\n## List\nRun `tree docs` to know which docs are available. \nRead as needed during the session if you have any questions on how this project works.",
        "por-dev/commands/util/all-tools.md": "# List All Tools\n\nList all availagle tools detailed in your system prompt. Display them in bullet points. Display them in typescript function signature format and suffix the purpose of the tool.",
        "por-dev/commands/util/generate-all-claude-mds.md": "# Generate CLAUDE.md Documentation\n\nGenerate CLAUDE.md files to provide AI coding assistants with codebase context.\n\n## Purpose\n\nCLAUDE.md files exist solely to help AI developers understand the codebase when working on files in each directory. They are NOT:\n- Human documentation (README, docs/)\n- Tutorials or guides\n- API references\n- Installation instructions\n\nThey ARE:\n- Contextual maps for AI navigating the codebase\n- Integration guides showing how modules connect\n- Pattern documentation for consistent code generation\n- Gotcha lists preventing common AI mistakes\n\n## What to Include\n\n### Essential Content\n- **Module purpose**: One sentence explaining what this code does\n- **File catalog**: What each file contains and its role\n- **Key patterns**: How things are done here (naming, structure, error handling)\n- **Integration points**: How this module connects to others\n- **Gotchas**: Traps that would cause AI to generate incorrect code\n- **Anti-patterns**: What NOT to do in this codebase\n\n### Exclude\n- Version numbers, dates, \"last updated\"\n- Installation/setup instructions\n- CLI usage examples (unless explaining internal implementation)\n- Human-readable tutorials\n- Badges, links to external docs\n- Anything a human needs but code context doesn't require\n\n## File Template\n\n```markdown\n# [Module Name]\n\n[One sentence: what this module does]\n\n## Files\n\n- **`file.py`**: [What it contains, key classes/functions]\n- **`other.py`**: [What it contains]\n\n## Patterns\n\n- **[Pattern name]**: [How it's implemented here, when to use it]\n\n## Integration\n\n- Imports from: `module.x`, `module.y`\n- Used by: `other_module.z`\n- Data flow: [Brief description of how data moves through]\n\n## Gotchas\n\n- [Specific trap that would cause incorrect code generation]\n- [Another gotcha]\n\n## When Adding Code\n\n- [Constraint or convention to follow]\n- [Another convention]\n```\n\n## Hierarchy Rules\n\n### Execution Order: Leaves ‚Üí Trunk\n\nBuild from deepest directories up to root:\n\n1. **Leaf files** (deepest): Document every file, all patterns, all gotchas\n2. **Parent directories**: Focus on how children integrate, reference children for details\n3. **Root** (last): High-level map only, everything else in children\n\n### Content Distribution\n\n| Level | Contains | Avoids |\n|-------|----------|--------|\n| Leaf | All file details, all patterns, all gotchas | - |\n| Mid | Integration between children, cross-cutting patterns | Repeating child content |\n| Root | Directory map, project-wide patterns only | Implementation details |\n\n### Reference Pattern\n\nParent files should say:\n```markdown\n## Submodules\n\n- **[child/](child/CLAUDE.md)**: [What it handles]\n\nSee child CLAUDE.md for implementation details.\n```\n\nNOT duplicate the child's content.\n\n## Anti-Patterns\n\n**DON'T include:**\n- `## Quick Start` or `## Getting Started`\n- `## Installation`\n- `## Usage Examples` (unless showing internal patterns)\n- `## Version` or version numbers\n- `## Contributing` or `## License`\n- `Current: v1.2.0` or any version strings\n- `Last Updated: January 2025`\n- Links to external documentation\n- Badges or status indicators\n\n**DON'T duplicate:**\n- Same file description in parent and child\n- Same gotcha at multiple levels\n- Same pattern explanation repeated\n\n**DO include:**\n- What would cause AI to write incorrect code\n- How modules actually connect (not how users use them)\n- Naming conventions that must be followed\n- Edge cases in the implementation\n\n## Placement Strategy\n\nCreate CLAUDE.md in:\n- Project root (always)\n- Directories with substantial implementation code (3+ non-trivial files)\n- Directories with complex internal logic worth documenting\n\nSkip CLAUDE.md for:\n- **Pass-through directories**: Folders that just contain `__init__.py` + subfolders (e.g., `src/package/` when all code is in `src/package/core/`, `src/package/utils/`)\n- **Simple re-export levels**: If a directory only has `__init__.py` that re-exports from children, skip it - document in root instead\n- Single-file directories\n- Generated code\n- Pure configuration directories\n- `node_modules`, `__pycache__`, `.git`, etc.\n\n### Pass-Through Directory Rule\n\nIf a directory structure looks like:\n```\nsrc/mypackage/\n‚îú‚îÄ‚îÄ __init__.py        # Just re-exports\n‚îú‚îÄ‚îÄ one_simple_file.py # Could be mentioned in root\n‚îú‚îÄ‚îÄ core/              # Has real implementation\n‚îú‚îÄ‚îÄ utils/             # Has real implementation\n‚îî‚îÄ‚îÄ api/               # Has real implementation\n```\n\nThen skip `src/mypackage/CLAUDE.md`. Instead:\n- Root CLAUDE.md references `core/`, `utils/`, `api/` directly\n- Mention `__init__.py` and `one_simple_file.py` briefly in root\n\nThis avoids CLAUDE.md files that are just \"see children for details\".\n\n## Execution\n\n1. Map directory structure, identify documentation points\n2. Start with deepest directories (leaves)\n3. Work up, referencing children instead of repeating\n4. Finish with root as navigation hub\n5. Review: remove any human-oriented content that crept in\n"
      },
      "plugins": [
        {
          "name": "por-dev",
          "source": "./por-dev",
          "description": "A development plugin for the Product on Rails methodology",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add lfnovo/por-marketplace",
            "/plugin install por-dev@por-marketplace"
          ]
        }
      ]
    }
  ]
}