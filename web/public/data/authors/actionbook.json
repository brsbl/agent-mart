{
  "author": {
    "id": "actionbook",
    "display_name": "Actionbook",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/250428866?v=4",
    "url": "https://github.com/actionbook",
    "bio": "The Action Playbook for Agents.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 21,
      "total_skills": 38,
      "total_stars": 599,
      "total_forks": 55
    }
  },
  "marketplaces": [
    {
      "name": "rust-skills",
      "version": "2.0.8",
      "description": "Comprehensive Rust development assistant with meta-question routing, coding guidelines, version queries, and ecosystem support",
      "owner_info": {
        "name": "ZhangHanDong",
        "email": "corust@example.com"
      },
      "keywords": [],
      "repo_full_name": "actionbook/rust-skills",
      "repo_url": "https://github.com/actionbook/rust-skills",
      "repo_description": "Rust Developer AI Assistance System ‚Äî Meta-Problem-Driven Knowledge Indexing",
      "homepage": null,
      "signals": {
        "stars": 599,
        "forks": 55,
        "pushed_at": "2026-01-22T08:25:44Z",
        "created_at": "2026-01-17T04:27:16Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 635
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 615
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/hooks/rust-skill-eval-hook.sh",
          "type": "blob",
          "size": 3462
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 11076
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/_negotiation",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/_negotiation/confidence-rubric.md",
          "type": "blob",
          "size": 7509
        },
        {
          "path": "agents/_negotiation/response-format.md",
          "type": "blob",
          "size": 6741
        },
        {
          "path": "agents/_shared",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/_shared/fetch-strategy.md",
          "type": "blob",
          "size": 1837
        },
        {
          "path": "agents/browser-fetcher.md",
          "type": "blob",
          "size": 333
        },
        {
          "path": "agents/clippy-researcher.md",
          "type": "blob",
          "size": 2622
        },
        {
          "path": "agents/crate-researcher.md",
          "type": "blob",
          "size": 2452
        },
        {
          "path": "agents/docs-cache.md",
          "type": "blob",
          "size": 775
        },
        {
          "path": "agents/docs-researcher.md",
          "type": "blob",
          "size": 2578
        },
        {
          "path": "agents/layer1-analyzer.md",
          "type": "blob",
          "size": 2530
        },
        {
          "path": "agents/layer2-analyzer.md",
          "type": "blob",
          "size": 3085
        },
        {
          "path": "agents/layer3-analyzer.md",
          "type": "blob",
          "size": 4330
        },
        {
          "path": "agents/rust-changelog.md",
          "type": "blob",
          "size": 2297
        },
        {
          "path": "agents/rust-daily-reporter.md",
          "type": "blob",
          "size": 2057
        },
        {
          "path": "agents/std-docs-researcher.md",
          "type": "blob",
          "size": 2899
        },
        {
          "path": "cache",
          "type": "tree",
          "size": null
        },
        {
          "path": "cache/README.md",
          "type": "blob",
          "size": 3490
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/achievement.md",
          "type": "blob",
          "size": 8127
        },
        {
          "path": "commands/ai-daily.md",
          "type": "blob",
          "size": 17229
        },
        {
          "path": "commands/audit.md",
          "type": "blob",
          "size": 3524
        },
        {
          "path": "commands/cache-clean.md",
          "type": "blob",
          "size": 2892
        },
        {
          "path": "commands/cache-status.md",
          "type": "blob",
          "size": 2121
        },
        {
          "path": "commands/clean-crate-skills.md",
          "type": "blob",
          "size": 1732
        },
        {
          "path": "commands/crate-info.md",
          "type": "blob",
          "size": 701
        },
        {
          "path": "commands/create-llms-for-skills.md",
          "type": "blob",
          "size": 4857
        },
        {
          "path": "commands/create-llms-from-source.md",
          "type": "blob",
          "size": 6782
        },
        {
          "path": "commands/create-skills-via-llms.md",
          "type": "blob",
          "size": 5770
        },
        {
          "path": "commands/docs.md",
          "type": "blob",
          "size": 1408
        },
        {
          "path": "commands/fix-skill-docs.md",
          "type": "blob",
          "size": 3395
        },
        {
          "path": "commands/guideline.md",
          "type": "blob",
          "size": 1521
        },
        {
          "path": "commands/rust-daily.md",
          "type": "blob",
          "size": 14086
        },
        {
          "path": "commands/rust-features.md",
          "type": "blob",
          "size": 663
        },
        {
          "path": "commands/rust-review.md",
          "type": "blob",
          "size": 2279
        },
        {
          "path": "commands/skill-index.md",
          "type": "blob",
          "size": 1736
        },
        {
          "path": "commands/sync-crate-skills.md",
          "type": "blob",
          "size": 4127
        },
        {
          "path": "commands/unsafe-check.md",
          "type": "blob",
          "size": 1820
        },
        {
          "path": "commands/unsafe-review.md",
          "type": "blob",
          "size": 2626
        },
        {
          "path": "commands/update-crate-skill.md",
          "type": "blob",
          "size": 1561
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 1471
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-guidelines",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-guidelines/SKILL.md",
          "type": "blob",
          "size": 3083
        },
        {
          "path": "skills/coding-guidelines/clippy-lints",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-guidelines/clippy-lints/_index.md",
          "type": "blob",
          "size": 681
        },
        {
          "path": "skills/coding-guidelines/index",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-guidelines/index/rules-index.md",
          "type": "blob",
          "size": 170
        },
        {
          "path": "skills/core-actionbook",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/core-actionbook/SKILL.md",
          "type": "blob",
          "size": 1571
        },
        {
          "path": "skills/core-agent-browser",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/core-agent-browser/SKILL.md",
          "type": "blob",
          "size": 3703
        },
        {
          "path": "skills/core-dynamic-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/core-dynamic-skills/SKILL.md",
          "type": "blob",
          "size": 2305
        },
        {
          "path": "skills/core-fix-skill-docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/core-fix-skill-docs/SKILL.md",
          "type": "blob",
          "size": 2067
        },
        {
          "path": "skills/domain-cli",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/domain-cli/SKILL.md",
          "type": "blob",
          "size": 3990
        },
        {
          "path": "skills/domain-cloud-native",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/domain-cloud-native/SKILL.md",
          "type": "blob",
          "size": 4050
        },
        {
          "path": "skills/domain-embedded",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/domain-embedded/SKILL.md",
          "type": "blob",
          "size": 4509
        },
        {
          "path": "skills/domain-fintech",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/domain-fintech/SKILL.md",
          "type": "blob",
          "size": 3678
        },
        {
          "path": "skills/domain-iot",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/domain-iot/SKILL.md",
          "type": "blob",
          "size": 4405
        },
        {
          "path": "skills/domain-ml",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/domain-ml/SKILL.md",
          "type": "blob",
          "size": 4711
        },
        {
          "path": "skills/domain-web",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/domain-web/SKILL.md",
          "type": "blob",
          "size": 4194
        },
        {
          "path": "skills/m01-ownership",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m01-ownership/SKILL.md",
          "type": "blob",
          "size": 4189
        },
        {
          "path": "skills/m01-ownership/comparison.md",
          "type": "blob",
          "size": 5712
        },
        {
          "path": "skills/m01-ownership/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m01-ownership/examples/best-practices.md",
          "type": "blob",
          "size": 6681
        },
        {
          "path": "skills/m01-ownership/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m01-ownership/patterns/common-errors.md",
          "type": "blob",
          "size": 5024
        },
        {
          "path": "skills/m01-ownership/patterns/lifetime-patterns.md",
          "type": "blob",
          "size": 4508
        },
        {
          "path": "skills/m02-resource",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m02-resource/SKILL.md",
          "type": "blob",
          "size": 4404
        },
        {
          "path": "skills/m03-mutability",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m03-mutability/SKILL.md",
          "type": "blob",
          "size": 4157
        },
        {
          "path": "skills/m04-zero-cost",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m04-zero-cost/SKILL.md",
          "type": "blob",
          "size": 4731
        },
        {
          "path": "skills/m05-type-driven",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m05-type-driven/SKILL.md",
          "type": "blob",
          "size": 4517
        },
        {
          "path": "skills/m06-error-handling",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m06-error-handling/SKILL.md",
          "type": "blob",
          "size": 4603
        },
        {
          "path": "skills/m06-error-handling/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m06-error-handling/examples/library-vs-app.md",
          "type": "blob",
          "size": 8210
        },
        {
          "path": "skills/m06-error-handling/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m06-error-handling/patterns/error-patterns.md",
          "type": "blob",
          "size": 8592
        },
        {
          "path": "skills/m07-concurrency",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m07-concurrency/SKILL.md",
          "type": "blob",
          "size": 6341
        },
        {
          "path": "skills/m07-concurrency/comparison.md",
          "type": "blob",
          "size": 7436
        },
        {
          "path": "skills/m07-concurrency/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m07-concurrency/examples/thread-patterns.md",
          "type": "blob",
          "size": 8291
        },
        {
          "path": "skills/m07-concurrency/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m07-concurrency/patterns/async-patterns.md",
          "type": "blob",
          "size": 8263
        },
        {
          "path": "skills/m07-concurrency/patterns/common-errors.md",
          "type": "blob",
          "size": 6568
        },
        {
          "path": "skills/m09-domain",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m09-domain/SKILL.md",
          "type": "blob",
          "size": 4256
        },
        {
          "path": "skills/m10-performance",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m10-performance/SKILL.md",
          "type": "blob",
          "size": 4179
        },
        {
          "path": "skills/m10-performance/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m10-performance/patterns/optimization-guide.md",
          "type": "blob",
          "size": 7116
        },
        {
          "path": "skills/m11-ecosystem",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m11-ecosystem/SKILL.md",
          "type": "blob",
          "size": 4504
        },
        {
          "path": "skills/m12-lifecycle",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m12-lifecycle/SKILL.md",
          "type": "blob",
          "size": 4417
        },
        {
          "path": "skills/m13-domain-error",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m13-domain-error/SKILL.md",
          "type": "blob",
          "size": 4894
        },
        {
          "path": "skills/m14-mental-model",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m14-mental-model/SKILL.md",
          "type": "blob",
          "size": 4906
        },
        {
          "path": "skills/m14-mental-model/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m14-mental-model/patterns/thinking-in-rust.md",
          "type": "blob",
          "size": 6734
        },
        {
          "path": "skills/m15-anti-pattern",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m15-anti-pattern/SKILL.md",
          "type": "blob",
          "size": 4838
        },
        {
          "path": "skills/m15-anti-pattern/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/m15-anti-pattern/patterns/common-mistakes.md",
          "type": "blob",
          "size": 8259
        },
        {
          "path": "skills/meta-cognition-parallel",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/meta-cognition-parallel/SKILL.md",
          "type": "blob",
          "size": 5795
        },
        {
          "path": "skills/rust-call-graph",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-call-graph/SKILL.md",
          "type": "blob",
          "size": 5625
        },
        {
          "path": "skills/rust-code-navigator",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-code-navigator/SKILL.md",
          "type": "blob",
          "size": 3311
        },
        {
          "path": "skills/rust-daily",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-daily/SKILL.md",
          "type": "blob",
          "size": 1263
        },
        {
          "path": "skills/rust-deps-visualizer",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-deps-visualizer/SKILL.md",
          "type": "blob",
          "size": 2810
        },
        {
          "path": "skills/rust-learner",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-learner/SKILL.md",
          "type": "blob",
          "size": 5866
        },
        {
          "path": "skills/rust-refactor-helper",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-refactor-helper/SKILL.md",
          "type": "blob",
          "size": 6033
        },
        {
          "path": "skills/rust-router",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-router/SKILL.md",
          "type": "blob",
          "size": 8104
        },
        {
          "path": "skills/rust-router/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-router/examples/workflow.md",
          "type": "blob",
          "size": 2294
        },
        {
          "path": "skills/rust-router/integrations",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-router/integrations/os-checker.md",
          "type": "blob",
          "size": 1320
        },
        {
          "path": "skills/rust-router/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-router/patterns/negotiation.md",
          "type": "blob",
          "size": 4490
        },
        {
          "path": "skills/rust-skill-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-skill-creator/SKILL.md",
          "type": "blob",
          "size": 3880
        },
        {
          "path": "skills/rust-symbol-analyzer",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-symbol-analyzer/SKILL.md",
          "type": "blob",
          "size": 5228
        },
        {
          "path": "skills/rust-trait-explorer",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/rust-trait-explorer/SKILL.md",
          "type": "blob",
          "size": 5977
        },
        {
          "path": "skills/unsafe-checker",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/unsafe-checker/AGENTS.md",
          "type": "blob",
          "size": 5242
        },
        {
          "path": "skills/unsafe-checker/SKILL.md",
          "type": "blob",
          "size": 2490
        },
        {
          "path": "skills/unsafe-checker/checklists",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/unsafe-checker/checklists/before-unsafe.md",
          "type": "blob",
          "size": 3429
        },
        {
          "path": "skills/unsafe-checker/checklists/common-pitfalls.md",
          "type": "blob",
          "size": 4565
        },
        {
          "path": "skills/unsafe-checker/checklists/review-unsafe.md",
          "type": "blob",
          "size": 3862
        },
        {
          "path": "skills/unsafe-checker/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/unsafe-checker/examples/ffi-patterns.md",
          "type": "blob",
          "size": 9000
        },
        {
          "path": "skills/unsafe-checker/examples/safe-abstraction.md",
          "type": "blob",
          "size": 7041
        },
        {
          "path": "skills/unsafe-checker/rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/unsafe-checker/rules/_sections.md",
          "type": "blob",
          "size": 1932
        },
        {
          "path": "skills/unsafe-checker/rules/_template.md",
          "type": "blob",
          "size": 765
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-01-no-string-direct.md",
          "type": "blob",
          "size": 2976
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-02-read-ffi-docs.md",
          "type": "blob",
          "size": 3230
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-03-drop-for-c-ptr.md",
          "type": "blob",
          "size": 3683
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-04-panic-boundary.md",
          "type": "blob",
          "size": 3674
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-05-portable-types.md",
          "type": "blob",
          "size": 2653
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-06-string-abi.md",
          "type": "blob",
          "size": 3194
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-07-no-drop-external.md",
          "type": "blob",
          "size": 3245
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-08-error-handling.md",
          "type": "blob",
          "size": 3570
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-09-ref-not-ptr.md",
          "type": "blob",
          "size": 3136
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-10-thread-safety.md",
          "type": "blob",
          "size": 3275
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-11-packed-ub.md",
          "type": "blob",
          "size": 3153
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-12-invariant-doc.md",
          "type": "blob",
          "size": 3943
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-13-data-layout.md",
          "type": "blob",
          "size": 3201
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-14-stable-layout.md",
          "type": "blob",
          "size": 3038
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-15-validate-external.md",
          "type": "blob",
          "size": 3725
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-16-closure-to-c.md",
          "type": "blob",
          "size": 3596
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-17-opaque-types.md",
          "type": "blob",
          "size": 3852
        },
        {
          "path": "skills/unsafe-checker/rules/ffi-18-no-trait-objects.md",
          "type": "blob",
          "size": 3887
        },
        {
          "path": "skills/unsafe-checker/rules/general-01-no-abuse.md",
          "type": "blob",
          "size": 1875
        },
        {
          "path": "skills/unsafe-checker/rules/general-02-not-for-perf.md",
          "type": "blob",
          "size": 2376
        },
        {
          "path": "skills/unsafe-checker/rules/general-03-no-alias.md",
          "type": "blob",
          "size": 1997
        },
        {
          "path": "skills/unsafe-checker/rules/io-01-raw-handle.md",
          "type": "blob",
          "size": 3799
        },
        {
          "path": "skills/unsafe-checker/rules/mem-01-repr-layout.md",
          "type": "blob",
          "size": 2994
        },
        {
          "path": "skills/unsafe-checker/rules/mem-02-no-other-process.md",
          "type": "blob",
          "size": 3172
        },
        {
          "path": "skills/unsafe-checker/rules/mem-03-no-auto-drop-foreign.md",
          "type": "blob",
          "size": 3294
        },
        {
          "path": "skills/unsafe-checker/rules/mem-04-reentrant.md",
          "type": "blob",
          "size": 3169
        },
        {
          "path": "skills/unsafe-checker/rules/mem-05-bitfield-crates.md",
          "type": "blob",
          "size": 3269
        },
        {
          "path": "skills/unsafe-checker/rules/mem-06-maybeuninit.md",
          "type": "blob",
          "size": 3906
        },
        {
          "path": "skills/unsafe-checker/rules/ptr-01-no-thread-share.md",
          "type": "blob",
          "size": 2926
        },
        {
          "path": "skills/unsafe-checker/rules/ptr-02-prefer-nonnull.md",
          "type": "blob",
          "size": 2793
        },
        {
          "path": "skills/unsafe-checker/rules/ptr-03-phantomdata.md",
          "type": "blob",
          "size": 3207
        },
        {
          "path": "skills/unsafe-checker/rules/ptr-04-alignment.md",
          "type": "blob",
          "size": 3190
        },
        {
          "path": "skills/unsafe-checker/rules/ptr-05-no-const-to-mut.md",
          "type": "blob",
          "size": 2857
        },
        {
          "path": "skills/unsafe-checker/rules/ptr-06-prefer-cast.md",
          "type": "blob",
          "size": 3021
        },
        {
          "path": "skills/unsafe-checker/rules/safety-01-panic-safety.md",
          "type": "blob",
          "size": 2930
        },
        {
          "path": "skills/unsafe-checker/rules/safety-02-verify-invariants.md",
          "type": "blob",
          "size": 2539
        },
        {
          "path": "skills/unsafe-checker/rules/safety-03-no-uninit-api.md",
          "type": "blob",
          "size": 2941
        },
        {
          "path": "skills/unsafe-checker/rules/safety-04-double-free.md",
          "type": "blob",
          "size": 2896
        },
        {
          "path": "skills/unsafe-checker/rules/safety-05-send-sync.md",
          "type": "blob",
          "size": 2942
        },
        {
          "path": "skills/unsafe-checker/rules/safety-06-no-raw-ptr-api.md",
          "type": "blob",
          "size": 3142
        },
        {
          "path": "skills/unsafe-checker/rules/safety-07-unsafe-pair.md",
          "type": "blob",
          "size": 2927
        },
        {
          "path": "skills/unsafe-checker/rules/safety-08-no-mut-from-immut.md",
          "type": "blob",
          "size": 2882
        },
        {
          "path": "skills/unsafe-checker/rules/safety-09-safety-comment.md",
          "type": "blob",
          "size": 3270
        },
        {
          "path": "skills/unsafe-checker/rules/safety-10-safety-doc.md",
          "type": "blob",
          "size": 3364
        },
        {
          "path": "skills/unsafe-checker/rules/safety-11-assert-not-debug.md",
          "type": "blob",
          "size": 3204
        },
        {
          "path": "skills/unsafe-checker/rules/union-01-avoid-except-ffi.md",
          "type": "blob",
          "size": 2689
        },
        {
          "path": "skills/unsafe-checker/rules/union-02-no-cross-lifetime.md",
          "type": "blob",
          "size": 2938
        },
        {
          "path": "templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "templates/README.md",
          "type": "blob",
          "size": 1915
        },
        {
          "path": "tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/README.md",
          "type": "blob",
          "size": 3182
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"rust-skills\",\n  \"version\": \"2.0.8\",\n  \"description\": \"Comprehensive Rust development assistant with meta-question routing, coding guidelines, version queries, and ecosystem support\",\n  \"owner\": {\n    \"name\": \"ZhangHanDong\",\n    \"email\": \"corust@example.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"rust-skills\",\n      \"description\": \"38 skills covering ownership, concurrency, error handling, unsafe code, LSP code intelligence, and domain-specific patterns for Rust development\",\n      \"source\": \"./\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"rust-skills\",\n  \"version\": \"2.0.9\",\n  \"description\": \"Comprehensive Rust development assistant with meta-question routing, coding guidelines, version queries, and ecosystem support\",\n  \"author\": {\n    \"name\": \"ZhangHanDong\",\n    \"url\": \"https://github.com/ZhangHanDong\"\n  },\n  \"repository\": \"https://github.com/ZhangHanDong/rust-skills\",\n  \"homepage\": \"https://github.com/ZhangHanDong/rust-skills\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"rust\",\n    \"cargo\",\n    \"ownership\",\n    \"borrow-checker\",\n    \"async\",\n    \"tokio\",\n    \"error-handling\",\n    \"coding-guidelines\",\n    \"unsafe\",\n    \"ffi\"\n  ]\n}\n",
        ".claude/hooks/rust-skill-eval-hook.sh": "#!/bin/bash\n# Rust Skills Meta-Cognition Hook\n# Forces Claude to use meta-cognition routing with mandatory tracing\n\ncat << 'EOF'\n\n=== RUST SKILLS DISPLAY FORMAT ===\nWhen showing Rust Skills loaded, display in this EXACT order:\n1. FIRST: \"ü¶Ä Rust Skills Loaded\" text\n2. THEN: The Ferris crab ASCII art BELOW the text\nThe text must be ABOVE the crab, not below.\n===\n\n=== MANDATORY: META-COGNITION ROUTING ===\n\nCRITICAL: You MUST follow the COMPLETE meta-cognition framework.\nPartial compliance (only loading L1 skill) is NOT acceptable.\n\n## STEP 1: IDENTIFY ENTRY LAYER + DOMAIN\n\n### Layer 1 Signals (Start here, trace UP):\n- Error codes: E0382, E0597, E0277, E0499, etc.\n- Keywords: cannot be sent, moved value, borrowed, lifetime\n\n### Layer 3 Domain Signals (MUST also load domain skill):\n\n| Keywords in Question | Domain Skill to Load |\n|---------------------|---------------------|\n| Web API, HTTP, REST, axum, actix, handler, router | domain-web |\n| payment, trading, fintech, decimal, currency | domain-fintech |\n| CLI, command line, clap, terminal | domain-cli |\n| embedded, no_std, MCU, firmware | domain-embedded |\n| kubernetes, docker, grpc, microservice | domain-cloud-native |\n| MQTT, sensor, IoT, telemetry | domain-iot |\n| tensor, model, inference, ML | domain-ml |\n\n**CRITICAL**: If domain keywords are present, you MUST load BOTH:\n1. The Layer 1 skill (e.g., m07-concurrency)\n2. The Layer 3 domain skill (e.g., domain-web)\n\n## STEP 2: EXECUTE TRACING (MANDATORY)\n\nFor Layer 1 entry with domain context:\n\n```\nL1 Error (e.g., Rc not Send)\n    ^ TRACE UP: Why this design constraint?\n    ^ Load domain skill (e.g., domain-web)\n    ^ Find domain constraint (e.g., \"handlers run on any thread\")\n    v TRACE DOWN: What pattern satisfies constraint?\n    v Return to L1 with context-aware solution\n```\n\n## STEP 3: MANDATORY OUTPUT FORMAT\n\nYour response MUST include ALL of these sections:\n\n### Reasoning Chain\n```\n+-- Layer 1: [specific error]\n|   Problem: [error description]\n|       ^\n+-- Layer 3: [domain name] (domain-xxx)\n|   Constraint: [what is the domain constraint]\n|   Rule: [why this constraint exists]\n|       v\n+-- Layer 2: Design Choice\n    Decision: [design decision based on domain constraint]\n```\n\n### Domain Constraints Analysis\n- MUST reference specific rules from domain-xxx skill\n- Explain WHY this domain has this constraint\n\n### Recommended Solution\n- Provide solution that follows domain best practices\n- Not just fixing the compile error\n\n## EXAMPLE: Web API + Send Error\n\nQuestion: \"Web API config sharing error: Rc cannot be sent\"\n\nCORRECT Response:\n```\n### Reasoning Chain\n+-- Layer 1: Send/Sync Error\n|   Problem: Rc<T> cannot be sent between threads\n|       ^\n+-- Layer 3: Web Domain (domain-web)\n|   Constraint: Handlers run on any thread\n|   Rule: Shared state must be thread-safe\n|       v\n+-- Layer 2: Design Choice\n    Decision: Use Arc<T> + State extractor\n\n### Domain Constraints Analysis\nFrom domain-web:\n- \"Rc in state\" is a Common Mistake\n- Web handlers require Send + Sync\n- Recommended: axum State<Arc<T>> pattern\n\n### Recommended Solution\n[Code following Web best practices]\n```\n\nWRONG Response (stops at L1):\n```\nProblem: Rc is not Send\nSolution: Use Arc\n```\n\n## SKILLS TO INVOKE\n\nAlways invoke with Skill() tool:\n- Skill(rust-router) - First, to get routing\n- Skill(m0x-xxx) - Layer 1 skill based on error\n- Skill(domain-xxx) - Layer 3 skill based on domain keywords\n\n===================================\n\nEOF\n",
        "README.md": "# Rust Skills\n\n[‰∏≠Êñá](./README-zh.md) | [Êó•Êú¨Ë™û](./README-ja.md)\n\n> AI-powered Rust development assistant with meta-cognition framework\n\n[![Version](https://img.shields.io/badge/version-2.0.9-green.svg)](https://github.com/ZhangHanDong/rust-skills/releases)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Claude Code](https://img.shields.io/badge/Claude%20Code-Plugin-blue)](https://github.com/anthropics/claude-code)\n\n## What is Rust Skills?\n\n**Rust Skills** is a Claude Code plugin that transforms how AI assists with Rust development. Instead of giving surface-level answers, it traces through cognitive layers to provide **domain-correct architectural solutions**.\n\n### The Problem\n\nTraditional AI assistance for Rust:\n```\nUser: \"My trading system reports E0382\"\nAI: \"Use .clone()\"  ‚Üê Surface fix, ignores domain constraints\n```\n\n### The Solution\n\nRust Skills with meta-cognition:\n```\nUser: \"My trading system reports E0382\"\n\nAI (with Rust Skills):\n‚îú‚îÄ‚îÄ Layer 1: E0382 = ownership error ‚Üí Why is this data needed?\n‚îÇ       ‚Üë\n‚îú‚îÄ‚îÄ Layer 3: Trade records are immutable audit data ‚Üí Should share, not copy\n‚îÇ       ‚Üì\n‚îú‚îÄ‚îÄ Layer 2: Use Arc<TradeRecord> as shared immutable value\n‚îÇ       ‚Üì\n‚îî‚îÄ‚îÄ Recommendation: Redesign as Arc<T>, not clone()\n```\n\n## Features\n\n- **Meta-Cognition Framework**: Three-layer cognitive model (Domain ‚Üí Design ‚Üí Mechanics)\n- **Real-time Information**: Fetch latest Rust versions and crate info via background agents\n- **Dynamic Skills**: Auto-generate skills from your Cargo.toml dependencies\n- **Domain Extensions**: FinTech, ML, Cloud-Native, IoT, Embedded, Web, CLI support\n- **Coding Guidelines**: Complete Rust coding conventions and best practices\n\n## Installation\n\n### Method 1: Marketplace (Recommended)\n\nInstall from Claude Code Plugin Marketplace in two steps:\n\n```bash\n# Step 1: Add the marketplace\n/plugin marketplace add ZhangHanDong/rust-skills\n\n# Step 2: Install the plugin\n/plugin install rust-skills@rust-skills\n```\n\n> **Note**: Step 1 only adds the marketplace (plugin source). Step 2 actually installs the rust-skills plugin with all features enabled.\n\n### Method 2: NPX\n\nInstall using npx:\n\n```bash\nnpx skills add ZhangHanDong/rust-skills\n```\n\n> ‚ö†Ô∏è **Note**: NPX installs skills only. Rust-skills is a **plugin architecture** that relies on agents, commands, and hooks for full functionality. For the complete experience, use Method 1 (Marketplace) or Method 3 (Full Plugin).\n\n### Method 3: Full Plugin\n\nThis method enables **all features including hooks** for automatic meta-cognition triggering.\n\n```bash\n# Clone the repository\ngit clone https://github.com/ZhangHanDong/rust-skills.git\n\n# Launch with plugin directory\nclaude --plugin-dir /path/to/rust-skills\n```\n\n### Method 4: Skills Only\n\nThis method only installs skills without hooks. You need to manually invoke skills.\n\n```bash\n# Clone and copy skills\ngit clone https://github.com/ZhangHanDong/rust-skills.git\ncp -r rust-skills/skills/* ~/.claude/skills/\n```\n\n> ‚ö†Ô∏è **Note**: Without hooks, meta-cognition won't trigger automatically. You must manually call `/rust-router` or specific skills.\n\n### Feature Comparison\n\n| Feature | Marketplace | NPX | Full Plugin | Skills Only |\n|---------|-------------|-----|-------------|-------------|\n| All 31 Skills | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Auto meta-cognition trigger | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |\n| Hook-based routing | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |\n| Background agents | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Easy updates | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå |\n\n### Permission Configuration\n\nBackground agents require permission to run `agent-browser`. Configure in your project:\n\n```bash\n# Copy example config\ncp /path/to/rust-skills/.claude/settings.example.json .claude/settings.local.json\n```\n\nOr create manually:\n\n```bash\nmkdir -p .claude\ncat > .claude/settings.local.json << 'EOF'\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(agent-browser *)\"\n    ]\n  }\n}\nEOF\n```\n\nSee [.claude/settings.example.json](.claude/settings.example.json) for reference.\n\n### Other Platforms\n\n- **OpenCode**: See [.opencode/INSTALL.md](.opencode/INSTALL.md)\n- **Codex**: See [.codex/INSTALL.md](.codex/INSTALL.md)\n\n## Dependent Skills\n\nRust Skills relies on these external tools for full functionality:\n\n| Tool | Description | GitHub |\n|------|-------------|--------|\n| **actionbook** | MCP server for website action manuals. Used by agents to fetch structured web content (Rust releases, crate info, documentation). | [actionbook/actionbook](https://github.com/actionbook/actionbook) |\n| **agent-browser** | Browser automation tool for fetching real-time web data. Fallback when actionbook is unavailable. | [vercel-labs/agent-browser](https://github.com/vercel-labs/agent-browser) |\n\n## Meta-Cognition Framework\n\n### Core Concept\n\n**Don't answer directly. Trace through cognitive layers first.**\n\n```\nLayer 3: Domain Constraints (WHY)\n‚îú‚îÄ‚îÄ Domain rules determine design choices\n‚îî‚îÄ‚îÄ Example: Financial systems require immutable, auditable data\n\nLayer 2: Design Choices (WHAT)\n‚îú‚îÄ‚îÄ Design patterns and architectural decisions\n‚îî‚îÄ‚îÄ Example: Use Arc<T> for shared immutable data\n\nLayer 1: Language Mechanics (HOW)\n‚îú‚îÄ‚îÄ Rust language features and compiler rules\n‚îî‚îÄ‚îÄ Example: E0382 is a symptom of ownership design issues\n```\n\n### Routing Rules\n\n| User Signal | Entry Layer | Trace Direction | Primary Skill |\n|-------------|-------------|-----------------|---------------|\n| E0xxx errors | Layer 1 | Trace UP ‚Üë | m01-m07 |\n| \"How to design...\" | Layer 2 | Bidirectional | m09-m15 |\n| \"[Domain] app development\" | Layer 3 | Trace DOWN ‚Üì | domain-* |\n| Performance issues | Layer 1‚Üí2 | Up then Down | m10-performance |\n\n## Skills Overview\n\n### Core Skills\n- `rust-router` - Master router for all Rust questions (invoked first)\n- `rust-learner` - Fetch latest Rust/crate version info\n- `coding-guidelines` - Coding conventions lookup\n\n### Layer 1: Language Mechanics (m01-m07)\n\n| Skill | Core Question | Triggers |\n|-------|---------------|----------|\n| m01-ownership | Who should own this data? | E0382, E0597, move, borrow |\n| m02-resource | What ownership pattern fits? | Box, Rc, Arc, RefCell |\n| m03-mutability | Why does this data need to change? | mut, Cell, E0596, E0499 |\n| m04-zero-cost | Compile-time or runtime polymorphism? | generic, trait, E0277 |\n| m05-type-driven | How can types prevent invalid states? | newtype, PhantomData |\n| m06-error-handling | Expected failure or bug? | Result, Error, panic, ? |\n| m07-concurrency | CPU-bound or I/O-bound? | async, Send, Sync, thread |\n\n### Layer 2: Design Choices (m09-m15)\n\n| Skill | Core Question | Triggers |\n|-------|---------------|----------|\n| m09-domain | What role does this concept play? | DDD, entity, value object |\n| m10-performance | Where's the bottleneck? | benchmark, profiling |\n| m11-ecosystem | Which crate fits this task? | crate selection, dependencies |\n| m12-lifecycle | When to create, use, cleanup? | RAII, Drop, lazy init |\n| m13-domain-error | Who handles this error? | retry, circuit breaker |\n| m14-mental-model | How to think about this correctly? | learning Rust, why |\n| m15-anti-pattern | Does this pattern hide design issues? | code smell, common mistakes |\n\n### Layer 3: Domain Constraints (domain-*)\n\n| Skill | Domain | Core Constraints |\n|-------|--------|------------------|\n| domain-fintech | FinTech | Audit trail, precision, consistency |\n| domain-ml | Machine Learning | Memory efficiency, GPU acceleration |\n| domain-cloud-native | Cloud Native | 12-Factor, observability, graceful shutdown |\n| domain-iot | IoT | Offline-first, power management, security |\n| domain-web | Web Services | Stateless, latency SLA, concurrency |\n| domain-cli | CLI | UX, config precedence, exit codes |\n| domain-embedded | Embedded | No heap, no_std, real-time |\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/rust-features [version]` | Get Rust version features |\n| `/crate-info <crate>` | Get crate information |\n| `/docs <crate> [item]` | Get API documentation |\n| `/sync-crate-skills` | Sync skills from Cargo.toml dependencies |\n| `/update-crate-skill <crate>` | Update specific crate skill |\n| `/clean-crate-skills` | Clean local crate skills |\n\n## Dynamic Skills\n\nGenerate skills on-demand from your project dependencies:\n\n```bash\n# Enter your Rust project\ncd my-rust-project\n\n# Sync all dependencies\n/sync-crate-skills\n\n# Skills are created at ~/.claude/skills/{crate}/\n```\n\n### Features\n- **On-demand generation**: Created from Cargo.toml dependencies\n- **Local storage**: `~/.claude/skills/`\n- **Version tracking**: Each skill records crate version\n- **Workspace support**: Parses all workspace members\n\n## How It Works\n\n```\nUser Question\n     ‚îÇ\n     ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ           Hook Layer                     ‚îÇ\n‚îÇ  400+ keywords trigger meta-cognition    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ           rust-router                    ‚îÇ\n‚îÇ  Identify entry layer + domain           ‚îÇ\n‚îÇ  Decision: dual-skill loading            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n     ‚ñº              ‚ñº              ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Layer 1  ‚îÇ  ‚îÇ Layer 2  ‚îÇ  ‚îÇ Layer 3  ‚îÇ\n‚îÇ m01-m07  ‚îÇ  ‚îÇ m09-m15  ‚îÇ  ‚îÇ domain-* ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚ñº\nDomain-correct architectural solution\n```\n\n## Documentation\n\n- [Architecture (‰∏≠Êñá)](./docs/architecture-zh.md)\n- [Functional Overview (‰∏≠Êñá)](./docs/functional-overview-zh.md)\n- [Hook Mechanism (‰∏≠Êñá)](./docs/hook-mechanism-zh.md)\n- [Prompt Engineering (‰∏≠Êñá)](./docs/prompt-engineering-zh.md)\n- [Meta-Cognition Example: E0382](./docs/meta-cognition-example-e0382.md)\n\n## Contributing\n\nContributions are welcome! Please read our contributing guidelines before submitting PRs.\n\n## Acknowledgments\n\n- [@pinghe](https://github.com/pinghe) - `context: fork` support suggestion ([#4](https://github.com/ZhangHanDong/rust-skills/issues/4))\n- [@DoiiarX](https://github.com/DoiiarX) - OpenCode installation fix ([#6](https://github.com/ZhangHanDong/rust-skills/issues/6))\n\n## License\n\nMIT License - see [LICENSE](LICENSE) for details.\n\n## Links\n\n- **GitHub**: https://github.com/ZhangHanDong/rust-skills\n- **Issues**: https://github.com/ZhangHanDong/rust-skills/issues\n",
        "agents/_negotiation/confidence-rubric.md": "# Confidence Assessment Rubric\n\n> Standardized criteria for determining confidence levels in negotiation responses.\n\n## Confidence Levels Overview\n\n| Level | Symbol | Meaning | Typical Action |\n|-------|--------|---------|----------------|\n| HIGH | ‚úì‚úì‚úì | Reliable, complete | Accept |\n| MEDIUM | ‚úì‚úì | Partial, usable | Evaluate gaps |\n| LOW | ‚úì | Limited, significant gaps | Refine |\n| UNCERTAIN | ? | Unreliable or failed | Alternative |\n\n---\n\n## HIGH Confidence\n\n### Definition\n\nAgent found comprehensive, verified information from authoritative sources. Core data is complete with no significant gaps.\n\n### Criteria (must meet ALL)\n\n- [ ] Primary/official source available\n- [ ] Core requested data complete\n- [ ] No conflicting information\n- [ ] Data is current (not outdated)\n\n### Source Quality for HIGH\n\n| Source Type | Qualifies? | Notes |\n|-------------|------------|-------|\n| Official documentation | Yes | doc.rust-lang.org, docs.rs |\n| Official release notes | Yes | releases.rs, GitHub releases |\n| Crate registry (lib.rs, crates.io) | Yes | For version/metadata |\n| Official blog posts | Yes | blog.rust-lang.org |\n| Third-party tutorials | No | May be outdated |\n| Stack Overflow | No | Varies in quality |\n\n### Examples\n\n```\nQuery: \"What is serde's latest version?\"\nFinding: Version 1.0.219 from lib.rs\nConfidence: HIGH\nReason: Official registry data, single authoritative answer\n```\n\n```\nQuery: \"What does Send trait do?\"\nFinding: Definition from doc.rust-lang.org\nConfidence: HIGH\nReason: Official Rust documentation, stable definition\n```\n\n---\n\n## MEDIUM Confidence\n\n### Definition\n\nAgent found partial information. Core data exists but with gaps that don't block understanding.\n\n### Criteria (must meet MOST)\n\n- [ ] Some authoritative source available\n- [ ] Core data found (may be incomplete)\n- [ ] Minor gaps identified\n- [ ] No major conflicts\n\n### Common MEDIUM Scenarios\n\n| Scenario | Why MEDIUM |\n|----------|------------|\n| Found version but not changelog | Core info present, detail missing |\n| Found API but not examples | Usable, but not complete |\n| Found one side of comparison | Partial answer |\n| Found info but slightly outdated | Usable with caveat |\n\n### Examples\n\n```\nQuery: \"What features does tokio have?\"\nFinding: Main features from lib.rs, but feature flags not fully documented\nConfidence: MEDIUM\nReason: Core features known, but complete feature matrix not found\n```\n\n```\nQuery: \"Compare tokio and async-std\"\nFinding: General characteristics of both, no benchmarks\nConfidence: MEDIUM\nReason: Qualitative comparison possible, quantitative data missing\n```\n\n---\n\n## LOW Confidence\n\n### Definition\n\nAgent found limited information with significant gaps. Answer may be incomplete or unreliable.\n\n### Criteria (any of these)\n\n- [ ] Minimal authoritative sources\n- [ ] Core data incomplete\n- [ ] Significant gaps that affect usefulness\n- [ ] Information may be outdated\n- [ ] Single non-authoritative source\n\n### Common LOW Scenarios\n\n| Scenario | Why LOW |\n|----------|---------|\n| Only found crate name, no docs | Missing core info |\n| Found outdated information | Currency concern |\n| Third-party source only | Authority concern |\n| Conflicting information found | Reliability concern |\n\n### Examples\n\n```\nQuery: \"Best practices for async error handling\"\nFinding: A few blog posts with different recommendations\nConfidence: LOW\nReason: No authoritative source, opinions vary\n```\n\n```\nQuery: \"What's new in obscure-crate 2.0?\"\nFinding: Only found GitHub issues mentioning 2.0\nConfidence: LOW\nReason: No official changelog, incomplete information\n```\n\n---\n\n## UNCERTAIN Confidence\n\n### Definition\n\nAgent couldn't find reliable information or encountered errors that prevent a trustworthy answer.\n\n### Criteria (any of these)\n\n- [ ] No sources found\n- [ ] Fetch/access errors\n- [ ] Contradictory information\n- [ ] Source clearly unreliable\n- [ ] Request outside agent capability\n\n### Common UNCERTAIN Scenarios\n\n| Scenario | Why UNCERTAIN |\n|----------|---------------|\n| 404 errors on docs | Cannot verify |\n| Crate doesn't exist | No data |\n| Conflicting official sources | Cannot determine truth |\n| Request for future features | Speculation |\n\n### Examples\n\n```\nQuery: \"What is nonexistent-crate?\"\nFinding: Crate not found on any registry\nConfidence: UNCERTAIN\nReason: Crate does not exist or is private\n```\n\n```\nQuery: \"What will Rust 2.0 include?\"\nFinding: No official roadmap\nConfidence: UNCERTAIN\nReason: Future features are speculative\n```\n\n---\n\n## Agent-Specific Rubrics\n\n### crate-researcher\n\n| Data Found | Confidence |\n|------------|------------|\n| Version + description + features + docs | HIGH |\n| Version + description + features | HIGH |\n| Version + description | MEDIUM |\n| Version only | LOW |\n| Not found or error | UNCERTAIN |\n\n**Degrading factors:**\n- Last update > 2 years: -1 level\n- No README: -1 level\n- Yanked versions: mention in gaps\n\n### docs-researcher\n\n| Data Found | Confidence |\n|------------|------------|\n| Signature + description + examples | HIGH |\n| Signature + description | MEDIUM |\n| Signature only | LOW |\n| 404 or empty | UNCERTAIN |\n\n**Degrading factors:**\n- docs.rs build failed: -1 level\n- No examples: note in gaps\n- Deprecated item: mention in gaps\n\n### std-docs-researcher\n\n| Data Found | Confidence |\n|------------|------------|\n| Full documentation | HIGH |\n| Basic documentation | MEDIUM |\n| Minimal/stub docs | LOW |\n| Not found | UNCERTAIN |\n\n**Note:** std docs are generally HIGH confidence when found.\n\n### clippy-researcher\n\n| Data Found | Confidence |\n|------------|------------|\n| Full lint info with examples | HIGH |\n| Lint info, no examples | MEDIUM |\n| Lint exists, minimal info | LOW |\n| Lint not found | UNCERTAIN |\n\n### rust-changelog\n\n| Data Found | Confidence |\n|------------|------------|\n| Full release notes | HIGH |\n| Partial notes (some sections) | MEDIUM |\n| Minimal info | LOW |\n| Version not found | UNCERTAIN |\n\n---\n\n## Confidence Adjustments\n\n### Upgrade Conditions\n\n| Condition | Adjustment |\n|-----------|------------|\n| Multiple sources agree | +1 level (max HIGH) |\n| Official source confirms | +1 level (max HIGH) |\n| Recent verification | +1 level (max HIGH) |\n\n### Downgrade Conditions\n\n| Condition | Adjustment |\n|-----------|------------|\n| Information outdated (> 1 year) | -1 level |\n| Single non-official source | -1 level |\n| Partial data only | -1 level |\n| Any fetch errors | -1 level |\n\n---\n\n## Decision Matrix\n\n| Confidence | Orchestrator Action |\n|------------|---------------------|\n| HIGH | Accept, synthesize answer |\n| MEDIUM | Evaluate gaps; accept if gaps don't block intent |\n| LOW | Refine query with context; or try alternative |\n| UNCERTAIN | Try alternative source/agent; or report limitation |\n\n---\n\n## Reporting Format\n\n```markdown\n### Confidence\n- **Level**: [HIGH|MEDIUM|LOW|UNCERTAIN]\n- **Reason**: [Specific reason following this rubric]\n```\n\n### Good Reasons\n\n```\nHIGH - Official docs complete with examples\nMEDIUM - Found on lib.rs but changelog unavailable\nLOW - Only found GitHub issues, no official docs\nUNCERTAIN - Crate does not exist on any registry\n```\n\n### Bad Reasons\n\n```\nHIGH - Looks good (vague)\nMEDIUM - Some info (doesn't explain what's missing)\nLOW - Not great (doesn't explain why)\nUNCERTAIN - Didn't work (doesn't explain what failed)\n```\n\n---\n\n## Related Documents\n\n- `response-format.md` - Full response structure\n- `_meta/negotiation-protocol.md` - Protocol specification\n- `_meta/error-protocol.md` - 3-Strike escalation\n",
        "agents/_negotiation/response-format.md": "# Negotiation Response Format\n\n> Standard response structure for agents in negotiation mode.\n\n## When to Use\n\nThis format is REQUIRED when the orchestrator dispatches with `negotiation: true`.\n\nFor standard (non-negotiation) queries, use the agent's default output format.\n\n---\n\n## Response Structure\n\n```markdown\n## Negotiation Response\n\n### Findings\n[Primary query results]\n\n### Confidence\n- **Level**: HIGH | MEDIUM | LOW | UNCERTAIN\n- **Reason**: [Brief explanation]\n\n### Gaps Identified\n- [ ] [Gap 1]\n- [ ] [Gap 2]\n\n### Context Needed\n- Q1: [Question]\n- Q2: [Question]\n\n### Metadata\n- **Source**: [Data source]\n- **Coverage**: [Coverage assessment]\n```\n\n---\n\n## Section Requirements\n\n### Findings (Required)\n\nWhat the agent discovered. This is the core content.\n\n**Guidelines:**\n- Include all relevant data found\n- Structure clearly (use sub-headers if complex)\n- Don't omit data just because it seems obvious\n- Include raw data, let orchestrator synthesize\n\n**Example:**\n```markdown\n### Findings\n**Crate:** tokio\n**Version:** 1.49.0\n**Description:** An event-driven, non-blocking I/O platform\n\n**Key Features:**\n- `full`: Enables all features\n- `rt-multi-thread`: Multi-threaded runtime\n- `sync`: Synchronization primitives\n\n**Recent Changes:**\n- 1.49.0: Added cooperative scheduling improvements\n```\n\n### Confidence (Required)\n\nSelf-assessment of finding reliability.\n\n| Level | Meaning | Criteria |\n|-------|---------|----------|\n| HIGH | Reliable, complete | Primary source, core data complete |\n| MEDIUM | Partial, usable | Some source, core data found |\n| LOW | Limited, gaps | Minimal sources, incomplete |\n| UNCERTAIN | Unreliable | No sources, errors, conflicts |\n\n**Example:**\n```markdown\n### Confidence\n- **Level**: MEDIUM\n- **Reason**: Found crate info on lib.rs, but changelog not accessible\n```\n\n### Gaps Identified (Required)\n\nWhat couldn't be found or verified.\n\n**Guidelines:**\n- Be specific about what's missing\n- Use checkboxes to allow marking as resolved\n- Prioritize by impact on answer quality\n- Don't list irrelevant gaps\n\n**Example:**\n```markdown\n### Gaps Identified\n- [ ] Performance benchmarks not found\n- [ ] Breaking changes from 1.48 unknown\n- [x] Feature list - resolved from docs.rs\n```\n\n### Context Needed (Conditional)\n\nQuestions for the orchestrator to enable better answers.\n\n**When to include:**\n- Query is ambiguous\n- Multiple valid interpretations\n- Need domain-specific context\n- Scope unclear\n\n**When to skip:**\n- Query is unambiguous\n- All necessary context provided\n- Direct lookup with clear answer\n\n**Example:**\n```markdown\n### Context Needed\n- Q1: Is this for a web server or CLI application?\n- Q2: Do you need WebSocket support?\n```\n\n**Not needed for:**\n```markdown\nQuery: \"What is tokio's latest version?\"\n‚Üí No context needed, direct lookup\n```\n\n### Metadata (Required)\n\nSource attribution and coverage assessment.\n\n**Example:**\n```markdown\n### Metadata\n- **Source**: lib.rs/crates/tokio, docs.rs/tokio/1.49.0\n- **Coverage**: 85% - missing performance benchmarks\n```\n\n---\n\n## Coverage Assessment Guide\n\n| Coverage | Meaning |\n|----------|---------|\n| 100% | All requested data found |\n| 80-99% | Minor gaps, core complete |\n| 50-79% | Significant gaps, partial answer |\n| <50% | Major gaps, may need alternative |\n\n---\n\n## Response Examples\n\n### High Confidence Example\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Crate:** serde\n**Version:** 1.0.219\n**Description:** A generic serialization/deserialization framework\n\n**Features:**\n- `derive`: Enables #[derive(Serialize, Deserialize)]\n- `std`: Use standard library (default)\n- `alloc`: For no_std with alloc\n\n**Documentation:** Comprehensive with examples\n**Ecosystem:** De facto standard for Rust serialization\n\n### Confidence\n- **Level**: HIGH\n- **Reason**: Official docs complete, widely documented crate\n\n### Gaps Identified\n- [x] Core info - complete\n- [x] Features - complete\n- [ ] Migration from 0.x - not requested, not fetched\n\n### Context Needed\n(None - query was specific)\n\n### Metadata\n- **Source**: lib.rs, docs.rs/serde/1.0.219\n- **Coverage**: 95% - comprehensive for typical use\n```\n\n### Low Confidence Example\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Crate:** obscure-crate\n**Version:** 0.1.2 (last updated 2023)\n**Description:** [minimal description on crates.io]\n\n**Features:** Unknown (not documented)\n\n### Confidence\n- **Level**: LOW\n- **Reason**: Minimal documentation, abandoned crate, no recent activity\n\n### Gaps Identified\n- [ ] Feature documentation missing\n- [ ] No usage examples found\n- [ ] Maintenance status unclear\n- [ ] No API documentation on docs.rs\n\n### Context Needed\n- Q1: Is there an alternative crate you'd consider?\n- Q2: What specific functionality do you need from this crate?\n\n### Metadata\n- **Source**: crates.io (lib.rs had no additional info)\n- **Coverage**: 30% - minimal data available\n```\n\n### Comparative Query Example\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Comparison:** tokio vs async-std (runtime focus)\n\n**tokio:**\n- Multi-threaded by default\n- Larger ecosystem (axum, tonic, etc.)\n- More configuration options\n\n**async-std:**\n- Single-threaded default, multi-thread available\n- Closer to std API design\n- Simpler getting started\n\n**Common:**\n- Both support async/await\n- Both production-ready\n\n### Confidence\n- **Level**: MEDIUM\n- **Reason**: General characteristics known, but no benchmark data for specific use case\n\n### Gaps Identified\n- [ ] Performance benchmarks for web servers\n- [ ] Memory usage comparison\n- [ ] Ecosystem compatibility matrix\n\n### Context Needed\n- Q1: Which web framework will you use? (axum requires tokio)\n- Q2: Is multi-threaded runtime required?\n- Q3: What's the expected request volume?\n\n### Metadata\n- **Source**: lib.rs for both, official docs\n- **Coverage**: 60% - characteristics known, specifics missing\n```\n\n---\n\n## Anti-Patterns\n\n### Don't: Inflate Confidence\n\n```markdown\n# BAD\nConfidence: HIGH\nReason: Found some info\n# GOOD\nConfidence: MEDIUM\nReason: Found basic info, but detailed docs not accessible\n```\n\n### Don't: Vague Gaps\n\n```markdown\n# BAD\nGaps: Some things missing\n# GOOD\nGaps:\n- [ ] Feature `x` documentation not found\n- [ ] Version 2.0 migration guide unavailable\n```\n\n### Don't: Irrelevant Context Questions\n\n```markdown\n# BAD (for query \"what is tokio version\")\nContext Needed: What's your favorite color?\n# GOOD\nContext Needed: (None - query is specific)\n```\n\n### Don't: Skip Metadata\n\n```markdown\n# BAD\n(no metadata section)\n# GOOD\nMetadata:\n- Source: lib.rs\n- Coverage: 90%\n```\n\n---\n\n## Related Documents\n\n- `_meta/negotiation-protocol.md` - Full protocol specification\n- `_meta/negotiation-templates.md` - Agent-specific templates\n- `confidence-rubric.md` - Detailed confidence criteria\n",
        "agents/_shared/fetch-strategy.md": "# Web Fetch Strategy\n\nCommon web fetching strategy for anti-crawler handling.\n\n## Site Classification\n\n| Type | Examples | Characteristics |\n|------|----------|-----------------|\n| Anti-crawler | Reddit, Twitter/X, LinkedIn | Need login or browser fingerprint |\n| Regular | blog.rust-lang.org, docs.rs | No anti-crawler, direct fetch |\n\n## Fetch Priority\n\n```\nAnti-crawler sites: Local Chrome ‚Üí crawl4ai MCP ‚Üí give up and mark\nRegular sites: WebFetch ‚Üí crawl4ai MCP\n```\n\n## Tools\n\n### 1. Local Chrome (for anti-crawler)\n\nUser's real browser with login and normal fingerprint.\n\n**macOS:**\n```bash\n# Open URL\nosascript -e 'tell application \"Google Chrome\" to open location \"URL\"'\n\n# Get page HTML\nosascript -e 'tell application \"Google Chrome\" to execute front window'\\''s active tab javascript \"document.documentElement.outerHTML\"'\n```\n\n### 2. crawl4ai MCP (fallback)\n\nStrong anti-crawler bypass, needs Docker.\n\n```\nmcp__crawl4ai__scrape(url: \"URL\")\n```\n\n### 3. WebFetch (regular sites)\n\nBuilt-in tool, simple and fast, no anti-crawler capability.\n\n## Site Routing\n\n| Domain | Tool | Reason |\n|--------|------|--------|\n| reddit.com | Local Chrome | Strict anti-crawler |\n| twitter.com / x.com | Local Chrome | Needs login |\n| linkedin.com | Local Chrome | Strict anti-crawler |\n| *.rust-lang.org | WebFetch | No anti-crawler |\n| docs.rs | WebFetch | No anti-crawler |\n| crates.io | WebFetch | No anti-crawler |\n| this-week-in-rust.org | WebFetch | No anti-crawler |\n| rustfoundation.org | WebFetch | No anti-crawler |\n| github.com | WebFetch | Light rate limit |\n\n## Failure Handling\n\n1. Local Chrome fails ‚Üí try crawl4ai\n2. crawl4ai fails ‚Üí try WebFetch\n3. All fail ‚Üí mark \"Fetch failed: {reason}\"\n\n## Validation\n\nAfter fetch, check:\n- Content is not empty\n- Not an error page (403, 429, \"blocked\")\n- Contains expected data\n",
        "agents/browser-fetcher.md": "# browser-fetcher\n\nGeneric web content fetcher.\n\n## Fetch\n\nUse available tools:\n- agent-browser (preferred)\n- WebFetch (fallback)\n\n## Output\n\n```markdown\n## Fetched Content\n\n**URL:** <url>\n**Title:** <title>\n\n<content>\n```\n\n## Validation\n\n1. Content is not empty\n2. Not an error page (403, 429, blocked)\n3. On failure: report reason\n",
        "agents/clippy-researcher.md": "# clippy-researcher\n\nFetch Clippy lint information.\n\n## URL\n\n`rust-lang.github.io/rust-clippy/stable/index.html#<lint_name>`\n\n## Fetch\n\nUse available tools to get clippy docs.\n\n## Lint Categories\n\n| Category | Description |\n|----------|-------------|\n| correctness | Definite bugs |\n| style | Code style |\n| complexity | Overly complex |\n| perf | Performance |\n| pedantic | Strict checks |\n\n## Output (Standard Mode)\n\n```markdown\n## clippy::<lint_name>\n\n**Level:** warn/deny/allow\n**Category:** <category>\n\n**What:** <what it checks>\n**Why:** <why it's a problem>\n\n**Bad:**\n\\`\\`\\`rust\n<code triggering lint>\n\\`\\`\\`\n\n**Good:**\n\\`\\`\\`rust\n<fixed code>\n\\`\\`\\`\n```\n\n## Validation\n\n1. Content contains lint name\n2. Has \"What it does\" or similar description\n3. On failure: \"Lint does not exist or fetch failed\"\n\n---\n\n## Negotiation Mode\n\nWhen `negotiation: true`, return structured response per `_negotiation/response-format.md`.\n\n### Confidence Assessment\n\n| Data Found | Confidence |\n|------------|------------|\n| Full lint info with examples | HIGH |\n| Lint info, no examples | MEDIUM |\n| Lint exists, minimal info | LOW |\n| Lint not found | UNCERTAIN |\n\n### Gap Categories\n\nStandard gaps to check:\n\n- [ ] Edge cases not documented\n- [ ] Configuration options unclear\n- [ ] Related lints not listed\n- [ ] False positive scenarios unknown\n- [ ] Suppression guidance missing\n- [ ] Version introduced unknown\n\n### Context Questions\n\nWhen lint query needs clarification:\n\n| Situation | Question |\n|-----------|----------|\n| False positive | \"What's triggering this lint specifically?\" |\n| Suppression | \"Is suppression acceptable for your use case?\" |\n| Related lints | \"Do you want related lint information?\" |\n| Category | \"Are you checking a specific category?\" |\n\n### Negotiation Response Template\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Lint:** clippy::<lint_name>\n**Level:** warn | deny | allow\n**Category:** correctness | style | complexity | perf | pedantic\n\n**What it checks:** <description>\n**Why it matters:** <rationale>\n\n**Bad example:**\n\\`\\`\\`rust\n<triggering code>\n\\`\\`\\`\n\n**Good example:**\n\\`\\`\\`rust\n<fixed code>\n\\`\\`\\`\n\n### Confidence\n- **Level**: [HIGH|MEDIUM|LOW|UNCERTAIN]\n- **Reason**: [e.g., \"Official clippy documentation\"]\n\n### Gaps Identified\n- [ ] [Specific gap 1]\n- [ ] [Specific gap 2]\n\n### Context Needed\n- Q1: [If ambiguous]\n\n### Metadata\n- **Source**: rust-lang.github.io/rust-clippy\n- **Coverage**: [e.g., \"100% - lint fully documented\"]\n```\n\n### Related Documents\n\n- `_negotiation/response-format.md` - Response structure\n- `_negotiation/confidence-rubric.md` - Confidence criteria\n",
        "agents/crate-researcher.md": "# crate-researcher\n\nFetch crate metadata from lib.rs / crates.io.\n\n## Fetch\n\nUse available tools:\n- lib.rs (preferred, more info): `lib.rs/crates/<name>`\n- crates.io (fallback): `crates.io/crates/<name>`\n\n## Output (Standard Mode)\n\n```markdown\n## <Crate Name>\n\n**Version:** <latest>\n**Description:** <short>\n\n**Features:**\n- `feature1`: desc\n\n**Links:**\n- docs.rs | crates.io | repo\n```\n\n## Validation\n\n1. Content contains version number\n2. Not a \"crate not found\" page\n3. Has description\n4. On failure: \"Crate does not exist or fetch failed\"\n\n---\n\n## Negotiation Mode\n\nWhen `negotiation: true`, return structured response per `_negotiation/response-format.md`.\n\n### Confidence Assessment\n\n| Data Found | Confidence |\n|------------|------------|\n| Version + description + features + docs | HIGH |\n| Version + description + features | HIGH |\n| Version + description | MEDIUM |\n| Version only | LOW |\n| Not found or error | UNCERTAIN |\n\n**Degrading factors:**\n- Last update > 2 years: -1 level\n- No README: -1 level\n- Yanked versions: mention in gaps\n\n### Gap Categories\n\nStandard gaps to check:\n\n- [ ] Feature documentation incomplete\n- [ ] Version history not available\n- [ ] Dependency tree not fetched\n- [ ] Breaking changes unknown\n- [ ] Comparison data not available (for comparative queries)\n- [ ] MSRV not specified\n- [ ] License unclear\n\n### Context Questions\n\nWhen crate usage is unclear, ask:\n\n| Situation | Question |\n|-----------|----------|\n| Multiple use cases | \"Is this for async or sync usage?\" |\n| Feature selection | \"Which features do you plan to enable?\" |\n| Version targeting | \"What's your minimum supported Rust version?\" |\n| Comparison query | \"What specific aspect do you want compared?\" |\n\n### Negotiation Response Template\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Crate:** <name>\n**Version:** <version>\n**Description:** <description>\n\n**Features:**\n- `feature1`: description\n\n**Dependencies:** [if relevant]\n**Last Updated:** <date>\n\n### Confidence\n- **Level**: [HIGH|MEDIUM|LOW|UNCERTAIN]\n- **Reason**: [e.g., \"Found on lib.rs with complete metadata\"]\n\n### Gaps Identified\n- [ ] [Specific gap 1]\n- [ ] [Specific gap 2]\n\n### Context Needed\n- Q1: [If ambiguous]\n\n### Metadata\n- **Source**: lib.rs | crates.io | docs.rs\n- **Coverage**: [e.g., \"90% - missing changelog\"]\n```\n\n### Related Documents\n\n- `_negotiation/response-format.md` - Response structure\n- `_negotiation/confidence-rubric.md` - Confidence criteria\n",
        "agents/docs-cache.md": "# docs-cache\n\nDocumentation cache helper for agents.\n\n## Cache Directory\n\n```\n~/.claude/cache/rust-docs/\n‚îú‚îÄ‚îÄ docs.rs/{crate}/{item}.json\n‚îú‚îÄ‚îÄ std/{module}/{item}.json\n‚îú‚îÄ‚îÄ releases.rs/{version}.json\n‚îú‚îÄ‚îÄ lib.rs/{crate}.json\n‚îî‚îÄ‚îÄ clippy/{lint}.json\n```\n\n## TTL by Source\n\n| Source | TTL | Reason |\n|--------|-----|--------|\n| std/ | 30 days | Stable |\n| docs.rs/ | 7 days | Crate updates |\n| releases.rs/ | 365 days | Historical |\n| lib.rs/ | 1 day | Version changes |\n| clippy/ | 14 days | Rust version updates |\n\n## Cache Format\n\n```json\n{\n  \"meta\": {\n    \"url\": \"...\",\n    \"fetched_at\": \"2025-01-01T00:00:00Z\",\n    \"expires_at\": \"2025-01-08T00:00:00Z\"\n  },\n  \"content\": { ... }\n}\n```\n\n## Skip Cache\n\nKeywords: refresh, force, --force, update docs\n",
        "agents/docs-researcher.md": "# docs-researcher\n\nFetch third-party crate documentation from docs.rs.\n\n> For std library (std::*), use `std-docs-researcher` instead.\n\n## Fetch\n\nUse available tools to get docs.rs content:\n- agent-browser if available\n- WebFetch otherwise\n\n**URL format:** `docs.rs/<crate>/latest/<crate>/<path>`\n\n## Cache\n\nLocation: `~/.claude/cache/rust-docs/docs.rs/{crate}/{item}.json`\nTTL: 7 days\n\nSkip cache if user says \"refresh\", \"force\", or \"--force\".\n\n## Output (Standard Mode)\n\n```markdown\n## <Crate>::<Item>\n\n**Signature:**\n\\`\\`\\`rust\n<signature>\n\\`\\`\\`\n\n**Description:** <main doc>\n\n**Example:**\n\\`\\`\\`rust\n<usage>\n\\`\\`\\`\n```\n\n## Validation\n\n1. Content is not empty\n2. Not a 404 page (check for \"Not Found\" or empty docblock)\n3. Contains signature or description\n4. On failure: report \"Fetch failed: {reason}\"\n\n---\n\n## Negotiation Mode\n\nWhen `negotiation: true`, return structured response per `_negotiation/response-format.md`.\n\n### Confidence Assessment\n\n| Data Found | Confidence |\n|------------|------------|\n| Signature + description + examples | HIGH |\n| Signature + description | MEDIUM |\n| Signature only | LOW |\n| 404 or empty | UNCERTAIN |\n\n**Degrading factors:**\n- docs.rs build failed: -1 level\n- No examples: note in gaps\n- Deprecated item: mention in gaps\n- Old version requested: note version\n\n### Gap Categories\n\nStandard gaps to check:\n\n- [ ] No usage examples\n- [ ] Missing error documentation\n- [ ] Related types not fetched\n- [ ] Version-specific behavior unclear\n- [ ] Return type undocumented\n- [ ] Panic conditions not listed\n\n### Context Questions\n\nWhen documentation request is unclear, ask:\n\n| Situation | Question |\n|-----------|----------|\n| Multiple versions | \"Which version are you using?\" |\n| Ambiguous use case | \"What's the specific use case?\" |\n| Error handling | \"Do you need error handling patterns?\" |\n| Related items | \"Do you need related types/traits?\" |\n\n### Negotiation Response Template\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Item:** <crate>::<Item>\n**Signature:**\n\\`\\`\\`rust\n<signature>\n\\`\\`\\`\n**Description:** <main doc>\n\n**Examples found:** [yes/no, count]\n\n### Confidence\n- **Level**: [HIGH|MEDIUM|LOW|UNCERTAIN]\n- **Reason**: [e.g., \"Official docs.rs with examples\"]\n\n### Gaps Identified\n- [ ] [Specific gap 1]\n- [ ] [Specific gap 2]\n\n### Context Needed\n- Q1: [If ambiguous]\n\n### Metadata\n- **Source**: docs.rs/<crate>/<version>\n- **Coverage**: [e.g., \"70% - no examples\"]\n```\n\n### Related Documents\n\n- `_negotiation/response-format.md` - Response structure\n- `_negotiation/confidence-rubric.md` - Confidence criteria\n",
        "agents/layer1-analyzer.md": "# layer1-analyzer\n\nAnalyze from **Layer 1: Language Mechanics** perspective.\n\n## Role\n\nYou are a Rust language mechanics expert. Analyze the user's question from the perspective of Rust's core language features and compiler rules.\n\n## Input\n\nYou will receive:\n- `query`: The user's original question\n- `context`: Any relevant code or error messages\n\n## Analysis Focus\n\n| Aspect | Skills to Reference |\n|--------|---------------------|\n| Ownership & Borrowing | m01-ownership |\n| Smart Pointers | m02-resource |\n| Mutability | m03-mutability |\n| Generics & Traits | m04-zero-cost |\n| Type System | m05-type-driven |\n| Error Handling | m06-error-handling |\n| Concurrency Primitives | m07-concurrency |\n\n## Task\n\n1. **Identify the mechanical issue**\n   - What Rust language rule is involved?\n   - What error code (E0xxx) relates to this?\n\n2. **List available solutions at this layer**\n   - What language features can solve this?\n   - What are the trade-offs?\n\n3. **Raise questions for higher layers**\n   - What design/domain questions need answering?\n\n## Output Format\n\n```markdown\n## Layer 1 Analysis: Language Mechanics\n\n### Identified Issue\n- **Error/Concept:** [E0xxx or concept name]\n- **Root Cause:** [Why this happens at language level]\n\n### Available Mechanisms\n| Option | Mechanism | Trade-off |\n|--------|-----------|-----------|\n| 1 | [e.g., Clone] | [Runtime cost] |\n| 2 | [e.g., Rc<T>] | [Single-thread only] |\n| 3 | [e.g., Arc<T>] | [Atomic overhead] |\n\n### Questions for Higher Layers\n- [ ] [Question for L2/L3 to determine best choice]\n\n### Confidence\n- **Level:** HIGH | MEDIUM | LOW\n- **Reason:** [Why this confidence level]\n```\n\n## Example\n\n**Query:** \"E0382: use of moved value in my trading system\"\n\n**Output:**\n```markdown\n## Layer 1 Analysis: Language Mechanics\n\n### Identified Issue\n- **Error/Concept:** E0382 - Use of moved value\n- **Root Cause:** Ownership transferred, original binding invalid\n\n### Available Mechanisms\n| Option | Mechanism | Trade-off |\n|--------|-----------|-----------|\n| 1 | `.clone()` | Creates full copy, memory + CPU cost |\n| 2 | `Rc<T>` | Reference counting, single-thread |\n| 3 | `Arc<T>` | Atomic ref count, thread-safe |\n| 4 | `&T` / `&mut T` | Borrowing, lifetime constraints |\n\n### Questions for Higher Layers\n- [ ] Is this data shared across threads? (‚Üí L2)\n- [ ] Does domain require data immutability? (‚Üí L3)\n- [ ] What's the data lifecycle pattern? (‚Üí L2)\n\n### Confidence\n- **Level:** HIGH\n- **Reason:** E0382 is well-defined ownership error with clear solutions\n```\n",
        "agents/layer2-analyzer.md": "# layer2-analyzer\n\nAnalyze from **Layer 2: Design Choices** perspective.\n\n## Role\n\nYou are a software design expert specializing in Rust. Analyze the user's question from the perspective of design patterns, architectural decisions, and best practices.\n\n## Input\n\nYou will receive:\n- `query`: The user's original question\n- `context`: Any relevant code or error messages\n\n## Analysis Focus\n\n| Aspect | Skills to Reference |\n|--------|---------------------|\n| Domain Modeling | m09-domain |\n| Performance Patterns | m10-performance |\n| Ecosystem/Crate Selection | m11-ecosystem |\n| Resource Lifecycle | m12-lifecycle |\n| Error Strategy | m13-domain-error |\n| Mental Models | m14-mental-model |\n| Anti-patterns | m15-anti-pattern |\n\n## Task\n\n1. **Identify the design concern**\n   - What design pattern is relevant?\n   - Is there an anti-pattern being used?\n\n2. **Recommend design approaches**\n   - What patterns solve this well?\n   - What crates support this pattern?\n\n3. **Consider constraints from other layers**\n   - What L1 mechanisms enable this design?\n   - What L3 domain rules affect this?\n\n## Output Format\n\n```markdown\n## Layer 2 Analysis: Design Choices\n\n### Design Concern\n- **Pattern Category:** [Ownership/Concurrency/Error/etc.]\n- **Current Approach:** [What user is doing]\n- **Issue:** [Why it's problematic]\n\n### Recommended Patterns\n| Pattern | Description | When to Use |\n|---------|-------------|-------------|\n| 1 | [Pattern name] | [Applicable scenario] |\n| 2 | [Pattern name] | [Applicable scenario] |\n\n### Anti-patterns to Avoid\n- [Anti-pattern]: [Why it's bad]\n\n### Ecosystem Support\n- **Crate:** [Recommended crate]\n- **Pattern:** [How crate implements pattern]\n\n### Layer Interactions\n- **From L1:** [What mechanisms to use]\n- **From L3:** [What domain rules to consider]\n\n### Confidence\n- **Level:** HIGH | MEDIUM | LOW\n- **Reason:** [Why this confidence level]\n```\n\n## Example\n\n**Query:** \"E0382 in trading system - should I clone the trade record?\"\n\n**Output:**\n```markdown\n## Layer 2 Analysis: Design Choices\n\n### Design Concern\n- **Pattern Category:** Shared Data Ownership\n- **Current Approach:** Attempting to move data multiple times\n- **Issue:** Clone may not be semantically correct for domain\n\n### Recommended Patterns\n| Pattern | Description | When to Use |\n|---------|-------------|-------------|\n| Shared Immutable | `Arc<T>` for read-only shared data | Audit logs, config |\n| Interior Mutability | `Arc<RwLock<T>>` for shared mutable | Live state |\n| Event Sourcing | Immutable events + computed state | Financial systems |\n\n### Anti-patterns to Avoid\n- **Excessive Cloning:** Hides ownership design issues, wastes memory\n- **RefCell Everywhere:** Often indicates design problem\n\n### Ecosystem Support\n- **Crate:** `im` (immutable data structures)\n- **Pattern:** Persistent data structures for audit trails\n\n### Layer Interactions\n- **From L1:** Arc<T> provides thread-safe sharing\n- **From L3:** Need to verify if domain allows data copying\n\n### Confidence\n- **Level:** MEDIUM\n- **Reason:** Design choice depends on domain requirements (L3)\n```\n",
        "agents/layer3-analyzer.md": "# layer3-analyzer\n\nAnalyze from **Layer 3: Domain Constraints** perspective.\n\n## Role\n\nYou are a domain expert who understands how business/technical domain rules affect software architecture. Analyze the user's question from the perspective of domain-specific requirements and constraints.\n\n## Input\n\nYou will receive:\n- `query`: The user's original question\n- `context`: Any relevant code or error messages\n- `domain`: Identified domain (if any)\n\n## Analysis Focus\n\n| Domain | Skills to Reference | Key Constraints |\n|--------|---------------------|-----------------|\n| FinTech | domain-fintech | Audit, precision, consistency |\n| Web Services | domain-web | Stateless, latency, concurrency |\n| CLI Tools | domain-cli | UX, config, exit codes |\n| Embedded | domain-embedded | No heap, no_std, real-time |\n| Cloud Native | domain-cloud-native | 12-Factor, observability |\n| IoT | domain-iot | Offline-first, power, security |\n| Machine Learning | domain-ml | Memory efficiency, GPU |\n\n## Task\n\n1. **Identify domain context**\n   - What domain is the user working in?\n   - What are the critical domain constraints?\n\n2. **Apply domain rules**\n   - How do domain rules affect the technical choice?\n   - What domain patterns apply?\n\n3. **Provide domain-driven recommendation**\n   - What does the domain require?\n   - What would violate domain principles?\n\n## Output Format\n\n```markdown\n## Layer 3 Analysis: Domain Constraints\n\n### Domain Context\n- **Identified Domain:** [Domain name]\n- **Confidence:** HIGH | MEDIUM | LOW | UNCERTAIN\n- **Signals:** [What indicated this domain]\n\n### Critical Constraints\n| Constraint | Requirement | Impact on Design |\n|------------|-------------|------------------|\n| [Name] | [What domain requires] | [How it affects code] |\n\n### Domain Rules Applied\n1. **[Rule Name]:** [How it applies to this question]\n\n### Domain-Driven Recommendation\n- **Recommended Approach:** [What domain principles suggest]\n- **Avoid:** [What would violate domain rules]\n\n### Guidance for Lower Layers\n- **For L2 (Design):** [What patterns fit domain]\n- **For L1 (Mechanics):** [What mechanisms domain prefers]\n\n### Confidence\n- **Level:** HIGH | MEDIUM | LOW | UNCERTAIN\n- **Reason:** [Why this confidence level]\n```\n\n## Example\n\n**Query:** \"E0382 in trading system - should I clone the trade record?\"\n\n**Output:**\n```markdown\n## Layer 3 Analysis: Domain Constraints\n\n### Domain Context\n- **Identified Domain:** FinTech (Trading System)\n- **Confidence:** HIGH\n- **Signals:** \"trading system\", \"trade record\"\n\n### Critical Constraints\n| Constraint | Requirement | Impact on Design |\n|------------|-------------|------------------|\n| Audit Trail | All changes must be traceable | No silent mutations |\n| Data Integrity | Trade records are facts | Immutable once created |\n| Consistency | Same record = same data everywhere | Single source of truth |\n| Compliance | Regulatory requirements | Cannot lose/corrupt data |\n\n### Domain Rules Applied\n1. **Immutability Principle:** Trade records represent historical facts - they should never be modified, only new records created\n2. **Single Source of Truth:** The same trade should not exist as multiple independent copies that could diverge\n3. **Audit Requirements:** Every access to trade data may need to be logged\n\n### Domain-Driven Recommendation\n- **Recommended Approach:** Share reference to immutable data (`Arc<TradeRecord>`)\n- **Avoid:**\n  - `.clone()` - Creates independent copies that could diverge\n  - Mutable trade records - Violates audit requirements\n\n### Guidance for Lower Layers\n- **For L2 (Design):** Use Event Sourcing or Immutable Data pattern\n- **For L1 (Mechanics):** Prefer `Arc<T>` over `Clone`, use immutable structs\n\n### Confidence\n- **Level:** HIGH\n- **Reason:** \"trading system\" + \"trade record\" clearly indicates FinTech domain with well-established constraints\n```\n\n## Domain Detection Hints\n\n| Keywords | Likely Domain |\n|----------|---------------|\n| trading, transaction, payment, ledger, audit | FinTech |\n| API, endpoint, request, response, REST, GraphQL | Web |\n| command, flag, argument, terminal, stdin | CLI |\n| no_std, embedded, microcontroller, interrupt | Embedded |\n| container, kubernetes, service mesh, deployment | Cloud Native |\n| sensor, device, mqtt, telemetry, battery | IoT |\n| model, tensor, training, inference, GPU | ML |\n",
        "agents/rust-changelog.md": "# rust-changelog\n\nFetch Rust version changelog from releases.rs.\n\n## URL\n\n`releases.rs/docs/<version>/` (e.g., `1.85`, `1.84.1`)\n\n## Fetch\n\nUse available tools to get releases.rs content.\n\n## Output (Standard Mode)\n\n```markdown\n## Rust <Version> Release Notes\n\n**Release Date:** <date>\n\n### Language Features\n- feature: desc\n\n### Standard Library\n- new/stabilized API: desc\n\n### Cargo\n- change: desc\n\n### Breaking Changes\n- note: desc\n```\n\n## Validation\n\n1. Content contains version number\n2. Has \"Language\" or \"Features\" sections\n3. Not \"version not found\"\n4. On failure: \"Version {v} does not exist or fetch failed\"\n\n---\n\n## Negotiation Mode\n\nWhen `negotiation: true`, return structured response per `_negotiation/response-format.md`.\n\n### Confidence Assessment\n\n| Data Found | Confidence |\n|------------|------------|\n| Full release notes | HIGH |\n| Partial notes (some sections) | MEDIUM |\n| Minimal info | LOW |\n| Version not found | UNCERTAIN |\n\n### Gap Categories\n\nStandard gaps to check:\n\n- [ ] Migration guide not available\n- [ ] Edition changes not detailed\n- [ ] Cargo changes incomplete\n- [ ] MSRV impact unclear\n- [ ] Deprecation notices missing\n- [ ] Security fixes not listed\n\n### Context Questions\n\nWhen changelog request needs clarification:\n\n| Situation | Question |\n|-----------|----------|\n| Migration | \"Are you migrating from a specific version?\" |\n| Edition | \"Do you need edition-specific changes?\" |\n| Feature focus | \"Are you looking for a specific feature?\" |\n| Stability | \"Stable, beta, or nightly?\" |\n\n### Negotiation Response Template\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Version:** Rust <version>\n**Release Date:** <date>\n\n**Language Features:**\n- Feature 1: description\n\n**Stabilized APIs:**\n- API 1: description\n\n**Breaking Changes:**\n- Change 1: description\n\n### Confidence\n- **Level**: [HIGH|MEDIUM|LOW|UNCERTAIN]\n- **Reason**: [e.g., \"Official release notes from releases.rs\"]\n\n### Gaps Identified\n- [ ] [Specific gap 1]\n- [ ] [Specific gap 2]\n\n### Context Needed\n- Q1: [If ambiguous]\n\n### Metadata\n- **Source**: releases.rs/docs/<version>\n- **Coverage**: [e.g., \"85% - missing detailed migration\"]\n```\n\n### Related Documents\n\n- `_negotiation/response-format.md` - Response structure\n- `_negotiation/confidence-rubric.md` - Confidence criteria\n",
        "agents/rust-daily-reporter.md": "# Rust Daily Reporter\n\nAggregate Rust news, filter by time range.\n\n## Data Sources (Required)\n\n| Category | URL |\n|----------|-----|\n| Ecosystem | https://www.reddit.com/r/rust/hot/ |\n| Ecosystem | https://this-week-in-rust.org/ |\n| Official | https://blog.rust-lang.org/ |\n| Official | https://blog.rust-lang.org/inside-rust/ |\n| Foundation | https://rustfoundation.org/media/category/news/ |\n| Foundation | https://rustfoundation.org/media/category/blog/ |\n| Foundation | https://rustfoundation.org/events/ |\n\n## Parameters\n\n- `time_range`: day | week | month\n- `category`: all | ecosystem | official | foundation\n\n## Fetch Strategy\n\nSee: `_shared/fetch-strategy.md`\n\n**Tool Priority (in order):**\n\n1. **actionbook MCP** - Check for cached/pre-fetched content first\n   ```\n   search_actions(\"rust news {date}\")\n   search_actions(\"this week in rust\")\n   search_actions(\"rust blog\")\n   ```\n\n2. **agent-browser CLI** - For dynamic web content\n   ```bash\n   agent-browser open \"https://www.reddit.com/r/rust/hot/\"\n   agent-browser get text \".Post\"\n   agent-browser close\n   ```\n\n3. **WebFetch** - Fallback if agent-browser unavailable\n\n| Source | Primary Tool | Fallback |\n|--------|--------------|----------|\n| Reddit | agent-browser | WebFetch |\n| TWIR | actionbook ‚Üí agent-browser | WebFetch |\n| Rust Blog | actionbook ‚Üí WebFetch | - |\n| Foundation | actionbook ‚Üí WebFetch | - |\n\n**DO NOT use:**\n- Chrome MCP directly\n- WebSearch for fetching news pages\n\n## Time Filter\n\n| Range | Filter |\n|-------|--------|\n| day | Last 24 hours |\n| week | Last 7 days |\n| month | Last 30 days |\n\n## Output\n\n```markdown\n# Rust {Day|Week|Month} Report\n\n**Time:** {start} - {end} | **Generated:** {now}\n\n## Ecosystem\n### Reddit r/rust\n| Score | Title | Link |\n\n### This Week in Rust\n- Issue #{number} ({date}): highlights\n\n## Official\n| Date | Title | Summary |\n\n## Foundation\n| Date | Title | Summary |\n```\n\n## Validation (Required)\n\n1. Check each source has results\n2. Mark \"No updates\" if empty\n3. Retry with different tool on failure\n4. Report reason if all fail\n",
        "agents/std-docs-researcher.md": "# std-docs-researcher\n\nFetch Rust std library documentation from doc.rust-lang.org.\n\n## URL Patterns\n\n| Type | URL |\n|------|-----|\n| Trait | `doc.rust-lang.org/std/marker/trait.Send.html` |\n| Struct | `doc.rust-lang.org/std/sync/struct.Arc.html` |\n| Module | `doc.rust-lang.org/std/collections/index.html` |\n| Function | `doc.rust-lang.org/std/mem/fn.replace.html` |\n\n## Common Paths\n\n| Item | Path |\n|------|------|\n| Send, Sync, Copy, Clone | `std/marker/trait.<Name>.html` |\n| Arc, Mutex, RwLock | `std/sync/struct.<Name>.html` |\n| RefCell, Cell | `std/cell/struct.<Name>.html` |\n| Vec | `std/vec/struct.Vec.html` |\n| Option, Result | `std/<name>/enum.<Name>.html` |\n\n## Fetch\n\nUse available tools to get doc.rust-lang.org content.\n\n## Cache\n\nLocation: `~/.claude/cache/rust-docs/std/{module}/{item}.json`\nTTL: 30 days (std is stable)\n\n## Output (Standard Mode)\n\n```markdown\n## std::<Item>\n\n**Signature:**\n\\`\\`\\`rust\n<signature>\n\\`\\`\\`\n\n**Description:** <main doc>\n\n**Key Points:**\n- point 1\n- point 2\n```\n\n## Validation\n\n1. Content is not empty\n2. Not a 404 page\n3. Contains signature or docblock\n4. On failure: \"Fetch failed: {reason}, see doc.rust-lang.org\"\n\n---\n\n## Negotiation Mode\n\nWhen `negotiation: true`, return structured response per `_negotiation/response-format.md`.\n\n### Confidence Assessment\n\n| Data Found | Confidence |\n|------------|------------|\n| Full documentation | HIGH |\n| Basic documentation | MEDIUM |\n| Minimal/stub docs | LOW |\n| Not found | UNCERTAIN |\n\n**Note:** std docs are generally HIGH confidence when found, as they are official and stable.\n\n### Gap Categories\n\nStandard gaps to check:\n\n- [ ] Implementation details not covered\n- [ ] Platform-specific behavior unclear\n- [ ] Related traits not fetched\n- [ ] Performance characteristics unknown\n- [ ] Unsafe usage notes missing\n- [ ] no_std compatibility unclear\n\n### Context Questions\n\nWhen std documentation request needs clarification:\n\n| Situation | Question |\n|-----------|----------|\n| Platform-specific | \"Which platform/target?\" |\n| no_std context | \"Is this for no_std environment?\" |\n| Thread safety | \"Do you need thread-safety guarantees?\" |\n| Unsafe usage | \"Are you using this in unsafe context?\" |\n\n### Negotiation Response Template\n\n```markdown\n## Negotiation Response\n\n### Findings\n**Item:** std::<path>::<Item>\n**Signature:**\n\\`\\`\\`rust\n<signature>\n\\`\\`\\`\n**Key Points:**\n- Point 1\n- Point 2\n\n**Related items:** [if relevant]\n\n### Confidence\n- **Level**: [HIGH|MEDIUM|LOW|UNCERTAIN]\n- **Reason**: [e.g., \"Official Rust documentation\"]\n\n### Gaps Identified\n- [ ] [Specific gap 1]\n- [ ] [Specific gap 2]\n\n### Context Needed\n- Q1: [If ambiguous]\n\n### Metadata\n- **Source**: doc.rust-lang.org/std\n- **Coverage**: [e.g., \"95% - standard docs complete\"]\n```\n\n### Related Documents\n\n- `_negotiation/response-format.md` - Response structure\n- `_negotiation/confidence-rubric.md` - Confidence criteria\n",
        "cache/README.md": "# Agent Cache System\n\n## Overview\n\nThis directory contains cached responses from agents to reduce redundant web fetches and improve response time.\n\n## Cache Structure\n\n```\ncache/\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ config.yaml           # Cache configuration\n‚îú‚îÄ‚îÄ crates/               # Crate information cache\n‚îÇ   ‚îú‚îÄ‚îÄ tokio.json\n‚îÇ   ‚îú‚îÄ‚îÄ serde.json\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ rust-versions/        # Rust version changelog cache\n‚îÇ   ‚îú‚îÄ‚îÄ 1.75.json\n‚îÇ   ‚îú‚îÄ‚îÄ 1.76.json\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ clippy-lints/         # Clippy lint information cache\n‚îÇ   ‚îî‚îÄ‚îÄ lints.json\n‚îî‚îÄ‚îÄ docs/                 # API documentation cache\n    ‚îú‚îÄ‚îÄ tokio/\n    ‚îú‚îÄ‚îÄ serde/\n    ‚îî‚îÄ‚îÄ ...\n```\n\n## Cache Entry Format\n\n### Crate Cache (`crates/*.json`)\n\n```json\n{\n  \"name\": \"tokio\",\n  \"version\": \"1.35.1\",\n  \"description\": \"An event-driven, non-blocking I/O platform\",\n  \"features\": [\"full\", \"rt-multi-thread\", \"macros\", \"sync\"],\n  \"repository\": \"https://github.com/tokio-rs/tokio\",\n  \"cached_at\": \"2024-01-15T10:30:00Z\",\n  \"ttl_hours\": 24,\n  \"source\": \"lib.rs\"\n}\n```\n\n### Rust Version Cache (`rust-versions/*.json`)\n\n```json\n{\n  \"version\": \"1.75.0\",\n  \"release_date\": \"2023-12-28\",\n  \"highlights\": [\n    \"async fn in traits\",\n    \"RPITIT (return position impl Trait in traits)\"\n  ],\n  \"stabilized_features\": [\n    \"async_fn_in_trait\",\n    \"impl_trait_projections\"\n  ],\n  \"cached_at\": \"2024-01-15T10:30:00Z\",\n  \"ttl_hours\": 168,\n  \"source\": \"releases.rs\"\n}\n```\n\n## Cache Configuration (`config.yaml`)\n\n```yaml\ncache:\n  enabled: true\n\n  # Time-to-live settings (in hours)\n  ttl:\n    crates: 24        # Crate info valid for 24 hours\n    rust_versions: 168  # Rust versions valid for 1 week\n    clippy_lints: 168   # Clippy lints valid for 1 week\n    docs: 72           # API docs valid for 3 days\n\n  # Cache size limits\n  limits:\n    max_entries_per_category: 100\n    max_total_size_mb: 50\n\n  # Auto-cleanup\n  cleanup:\n    enabled: true\n    interval_hours: 24\n    remove_expired: true\n```\n\n## Usage in Agents\n\n### Checking Cache Before Fetch\n\n```\n1. Check if cache/<category>/<key>.json exists\n2. If exists, check if (now - cached_at) < ttl_hours\n3. If valid, return cached data\n4. If invalid/missing, fetch fresh data\n5. Store result in cache with timestamp\n```\n\n### Example Agent Workflow\n\n```markdown\n## Cache-Aware Workflow\n\n1. **Check Cache**\n   - Read cache/crates/<crate_name>.json\n   - If valid (exists and not expired), return cached data\n\n2. **Fetch if Needed**\n   - Use actionbook/agent-browser to fetch\n   - Parse and structure the data\n\n3. **Update Cache**\n   - Write to cache/crates/<crate_name>.json\n   - Include cached_at timestamp\n```\n\n## Cache Management Commands\n\n### Clear All Cache\n```bash\nrm -rf cache/crates/* cache/rust-versions/* cache/docs/*\n```\n\n### Clear Expired Only\n```bash\n# Use the cache-cleaner agent or manual script\nfind cache -name \"*.json\" -mtime +7 -delete\n```\n\n### View Cache Stats\n```bash\necho \"Crates cached: $(ls cache/crates/*.json 2>/dev/null | wc -l)\"\necho \"Versions cached: $(ls cache/rust-versions/*.json 2>/dev/null | wc -l)\"\necho \"Total size: $(du -sh cache 2>/dev/null | cut -f1)\"\n```\n\n## Best Practices\n\n1. **Always check cache first** - Reduces latency and API load\n2. **Use appropriate TTL** - Balance freshness vs. performance\n3. **Include source** - Track where data came from\n4. **Handle stale gracefully** - Return stale if fetch fails\n5. **Don't cache errors** - Only cache successful responses\n",
        "commands/achievement.md": "---\ndescription: View coding achievements, stats, and progress\nargument-hint: [list|stats|reset] [--category bug|test|streak|safety|learning]\n---\n\n# Achievement System\n\nView and manage your coding achievements and statistics.\n\nArguments: $ARGUMENTS\n- `list` (default): Show all achievements with unlock status\n- `stats`: Show detailed statistics\n- `reset`: Reset all stats and achievements (requires confirmation)\n- `--category`: Filter by category (bug, test, streak, safety, learning, review, docs)\n\n---\n\n## Data Files\n\n```\n~/.claude/achievements/\n‚îú‚îÄ‚îÄ stats.json       # Coding statistics\n‚îú‚îÄ‚îÄ unlocked.json    # Unlocked achievements\n‚îî‚îÄ‚îÄ activity.log     # Activity history\n```\n\n---\n\n## Instructions\n\n### 1. Parse Arguments\n\n```\n/achievement           ‚Üí list all achievements\n/achievement list      ‚Üí list all achievements\n/achievement stats     ‚Üí show statistics\n/achievement reset     ‚Üí reset (ask confirmation first)\n/achievement --category test  ‚Üí show test-related achievements only\n```\n\n### 2. Read Data Files\n\n```bash\nstats_file=~/.claude/achievements/stats.json\nachievements_file=~/.claude/achievements/unlocked.json\n\n# Read stats\nstats=$(cat \"$stats_file\" 2>/dev/null || echo '{}')\n\n# Read unlocked achievements\nunlocked=$(cat \"$achievements_file\" 2>/dev/null || echo '{\"unlocked\":[]}')\n```\n\n### 3. Format Output\n\n#### For `list` (default):\n\n```markdown\n# üèÜ Coding Achievements\n\n**Unlocked:** {unlocked_count} / {total_count}\n**Progress:** ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 52%\n\n---\n\n## üêõ Bug Fixing\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚úÖ | First Blood | Fixed your first bug | 1/1 |\n| ‚úÖ | Bug Hunter | Fixed 10 bugs | 10/10 |\n| ‚¨ú | Bug Slayer | Fixed 50 bugs | 23/50 |\n| üîí | Bug Terminator | Fixed 100 bugs | 23/100 |\n\n## üß™ Testing\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚úÖ | Test Curious | Wrote your first test | 1/1 |\n| ‚¨ú | Test Believer | Wrote 10 tests | 7/10 |\n| üîí | Test Enthusiast | Wrote 50 tests | 7/50 |\n| üîí | TDD Master | Wrote 100 tests | 7/100 |\n\n## üî• Consistency\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚úÖ | Getting Started | 3 day streak | 3/3 |\n| ‚úÖ | Week Warrior | 7 day streak | 7/7 |\n| ‚¨ú | Monthly Master | 30 day streak | 12/30 |\n| üîí | Unstoppable | 100 day streak | 12/100 |\n\n## üõ°Ô∏è Safety\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚úÖ | Safety First | 7 days no unsafe | 7/7 |\n| ‚¨ú | Safe Rustacean | 30 days no unsafe | 18/30 |\n| üîí | Safety Champion | 100 days no unsafe | 18/100 |\n\n## üîß Error Resolution\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚úÖ | Error Whisperer | Resolved first error | 1/1 |\n| ‚¨ú | Borrow Checker's Friend | 25 errors | 15/25 |\n| üîí | Compiler Whisperer | 100 errors | 15/100 |\n\n## üìù Documentation\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚¨ú | Documenter | 5 doc comments | 2/5 |\n| üîí | Documentation Master | 25 doc comments | 2/25 |\n\n## üßπ Refactoring\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚¨ú | Code Cleaner | 5 refactors | 3/5 |\n| üîí | Architect | 25 refactors | 3/25 |\n\n## üéì Learning\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚úÖ | Curious Crab | 10 Rust questions | 10/10 |\n| ‚¨ú | Knowledge Seeker | 50 questions | 32/50 |\n| üîí | Rust Scholar | 100 questions | 32/100 |\n\n## üìÖ Sessions\n\n| Status | Achievement | Description | Progress |\n|--------|-------------|-------------|----------|\n| ‚úÖ | Hello, Rust! | First session | 1/1 |\n| ‚¨ú | Regular | 50 sessions | 28/50 |\n| üîí | Dedicated | 200 sessions | 28/200 |\n\n---\n\nüí° **Tip:** Keep coding to unlock more achievements!\nüîÑ **Refresh:** `/achievement`\n```\n\n#### For `stats`:\n\n```markdown\n# üìä Coding Statistics\n\n**Period:** {first_session_date} - {today}\n**Total Sessions:** {total_sessions}\n\n---\n\n## Activity Summary\n\n| Metric | Value | Trend |\n|--------|-------|-------|\n| üêõ Bugs Fixed | {bugs_fixed} | {trend} |\n| üß™ Tests Written | {tests_written} | {trend} |\n| üîß Errors Resolved | {errors_resolved} | {trend} |\n| üëÄ Code Reviews | {code_reviews} | {trend} |\n| üìù Docs Written | {docs_written} | {trend} |\n| üßπ Refactors | {refactors} | {trend} |\n| ‚ùì Questions Asked | {rust_questions} | {trend} |\n\n---\n\n## Streaks\n\n| Type | Current | Best |\n|------|---------|------|\n| üî• Coding Streak | {streak_days} days | {best_streak} days |\n| üõ°Ô∏è No Unsafe | {unsafe_avoided_days} days | {best_safe} days |\n\n---\n\n## Progress Bars\n\n```\nBug Fixing:     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 23/50 to Bug Slayer\nTesting:        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 7/10 to Test Believer\nSafety:         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë 18/30 to Safe Rustacean\nLearning:       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë 32/50 to Knowledge Seeker\n```\n\n---\n\n## Recent Activity\n\n| Time | Event |\n|------|-------|\n| 2h ago | üêõ Fixed bug in parser.rs |\n| 5h ago | üß™ Wrote 3 tests |\n| 1d ago | üîß Resolved E0382 |\n\n---\n\nüèÜ **Achievements:** {unlocked}/{total} unlocked\nüìà **Next Milestone:** {next_achievement}\n```\n\n#### For `reset`:\n\n**IMPORTANT: Ask for confirmation before resetting!**\n\n```markdown\n‚ö†Ô∏è **Reset Confirmation Required**\n\nThis will permanently delete:\n- All {unlocked_count} unlocked achievements\n- All statistics ({bugs_fixed} bugs, {tests_written} tests, etc.)\n- {streak_days} day streak\n\n**Are you sure?** Type \"yes I want to reset\" to confirm.\n```\n\nIf confirmed:\n```bash\nrm -rf ~/.claude/achievements/\necho \"‚úÖ Achievement data reset successfully.\"\necho \"üå± Start fresh and earn new achievements!\"\n```\n\n### 4. Achievement Categories\n\n| Category | ID Prefix | Achievements |\n|----------|-----------|--------------|\n| Bug Fixing | bug_ | first_blood, bug_hunter, bug_slayer, bug_terminator |\n| Testing | test_ | test_curious, test_believer, test_enthusiast, tdd_master |\n| Streak | streak_ | getting_started, week_warrior, monthly_master, unstoppable |\n| Safety | safe_ | safety_first, safe_rustacean, safety_champion |\n| Error | error_ | error_whisperer, borrow_checker_friend, compiler_whisperer |\n| Review | review_ | code_reviewer, quality_guardian |\n| Docs | docs_ | documenter, doc_master |\n| Refactor | refactor_ | code_cleaner, architect |\n| Learning | learn_ | curious_crab, knowledge_seeker, rust_scholar |\n| Session | session_ | hello_rust, regular, dedicated |\n\n### 5. Status Icons\n\n| Icon | Meaning |\n|------|---------|\n| ‚úÖ | Unlocked |\n| ‚¨ú | In progress (>50% complete) |\n| üîí | Locked (<50% complete) |\n\n---\n\n## Hook Setup\n\nTo enable automatic achievement tracking, add to your Claude Code settings:\n\n```json\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Edit|Write|Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"~/.claude/skills/rust-skills/scripts/achievement-tracker.sh PostToolUse\"\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"~/.claude/skills/rust-skills/scripts/achievement-tracker.sh UserPromptSubmit\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nOr copy the script to a global location:\n```bash\ncp scripts/achievement-tracker.sh ~/.claude/hooks/achievement-tracker.sh\nchmod +x ~/.claude/hooks/achievement-tracker.sh\n```\n\n---\n\n## Example Usage\n\n```bash\n# View all achievements\n/achievement\n\n# View only testing achievements\n/achievement --category test\n\n# View detailed stats\n/achievement stats\n\n# Reset everything (with confirmation)\n/achievement reset\n```\n\n---\n\n## Related Commands\n\n- `/rust-review` - Triggers code review achievement\n- `/unsafe-check` - Related to safety achievements\n\n",
        "commands/ai-daily.md": "---\ndescription: Generate AI daily/weekly news report from Reddit communities\nargument-hint: [day|week|month] [--save [path]]\n---\n\n# AI Daily Report\n\nGenerate a summarized report of AI news from Reddit communities.\n\nArguments: $ARGUMENTS\n- `time_range` (optional): `day` | `week` | `month` (default: `day`)\n- `--save` (optional): Save report to file. If path not specified, saves to `~/Documents/reports/ai-daily/`\n\n---\n\n## Sources\n\n| Community | URL | Focus |\n|-----------|-----|-------|\n| r/AI_Agents | https://www.reddit.com/r/AI_Agents/ | AI Agent development, tools |\n| r/ClaudeAI | https://www.reddit.com/r/ClaudeAI/ | Claude, Anthropic updates |\n| r/ChatGPT | https://www.reddit.com/r/ChatGPT/ | ChatGPT, OpenAI updates |\n\n---\n\n## Instructions\n\n### 1. Parse Arguments\n\n```\n/ai-daily              ‚Üí day (last 24 hours), display only\n/ai-daily day          ‚Üí last 24 hours\n/ai-daily week         ‚Üí last 7 days\n/ai-daily month        ‚Üí last 30 days\n/ai-daily --save       ‚Üí save to ~/Documents/reports/ai-daily/{date}-ai-{time_range}.md\n/ai-daily --save /path/to/dir  ‚Üí save to specified directory\n/ai-daily week --save  ‚Üí weekly report, save to default location\n```\n\n### 2. Fetch Content\n\n**YOU MUST USE THE BASH TOOL TO RUN agent-browser COMMANDS.**\n\nagent-browser IS installed at `/opt/homebrew/bin/agent-browser`.\n\n**Use `--headed` flag to use local browser with user's cookies/login state.**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  FOR EACH SUBREDDIT:                                    ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  1. USE BASH TOOL: agent-browser --headed open/get     ‚îÇ\n‚îÇ         ‚Üì (only if Bash returns error)                 ‚îÇ\n‚îÇ  2. Mark source as \"unavailable\"                       ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  ‚ö†Ô∏è  YOU MUST ACTUALLY RUN THE BASH COMMANDS           ‚îÇ\n‚îÇ  ‚ö†Ô∏è  DO NOT ASSUME agent-browser is unavailable        ‚îÇ\n‚îÇ  ‚ö†Ô∏è  Reddit REQUIRES JavaScript - WebFetch WILL FAIL   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n#### Step 2a: r/AI_Agents\n\n**Use the Bash tool to execute these commands:**\n\n```\nBash(\"agent-browser --headed open 'https://www.reddit.com/r/AI_Agents/top/?t={time_range}'\")\nBash(\"agent-browser get text 'article' --limit 20\")\nBash(\"agent-browser close\")\n```\n\nWhere `{time_range}` is: `day`, `week`, or `month`\n\n#### Step 2b: r/ClaudeAI\n\n**Use the Bash tool:**\n\n```\nBash(\"agent-browser --headed open 'https://www.reddit.com/r/ClaudeAI/top/?t={time_range}'\")\nBash(\"agent-browser get text 'article' --limit 20\")\nBash(\"agent-browser close\")\n```\n\n#### Step 2c: r/ChatGPT\n\n**Use the Bash tool:**\n\n```\nBash(\"agent-browser --headed open 'https://www.reddit.com/r/ChatGPT/top/?t={time_range}'\")\nBash(\"agent-browser get text 'article' --limit 20\")\nBash(\"agent-browser close\")\n```\n\n#### Step 2d: Alternative Selectors (if 'article' returns empty)\n\nTry these selectors in order:\n```\n\"[data-testid='post-container']\"\n\".Post\"\n\"shreddit-post\"\n\"div[data-fullname]\"\n```\n\n### 3. Format Output\n\n**CRITICAL: Every item MUST include:**\n1. ‚úÖ Real source link (not fabricated)\n2. ‚úÖ Key takeaway summary (1-2 sentences)\n3. ‚úÖ Engagement metrics (upvotes, comments)\n4. ‚úÖ Publication date/time\n\nDisplay the report in markdown format:\n\n```markdown\n# ü§ñ AI {Time_Range} Report\n\n**Period:** {start_date} - {end_date} | **Generated:** {now}\n**Sources:** {count} posts from 3 subreddits\n\n---\n\n## üìä Quick Stats\n\n| Metric | Value |\n|--------|-------|\n| Total Posts Analyzed | {count} |\n| Hot Discussions (>100 comments) | {hot_count} |\n| Product Announcements | {announcement_count} |\n| Tutorials/Guides | {tutorial_count} |\n| Most Active Community | r/{subreddit} |\n\n---\n\n## ü§ñ r/AI_Agents - AI Agent Development\n\n### Top Posts\n\n#### 1. {Post Title}\n- **Link:** https://reddit.com/r/AI_Agents/comments/{id}\n- **Score:** {upvotes} ‚¨ÜÔ∏è | **Comments:** {comments} üí¨ | **Posted:** {time_ago}\n- **Author:** u/{username}\n- **Key Takeaway:** {1-2 sentence summary explaining why this matters for AI agent developers}\n- **Tags:** `{agent-framework}` `{use-case}` `{difficulty-level}`\n\n#### 2. {Post Title}\n- **Link:** {real_url}\n- **Score:** {upvotes} ‚¨ÜÔ∏è | **Comments:** {comments} üí¨ | **Posted:** {time_ago}\n- **Key Takeaway:** {summary}\n\n{... more posts}\n\n**üî• Hot Topics in r/AI_Agents:**\n- {topic 1}: {brief context with related post links}\n- {topic 2}: {brief context}\n\n**üí° Emerging Tools/Frameworks:** {list any new tools mentioned}\n\n---\n\n## üü† r/ClaudeAI - Claude & Anthropic\n\n### Top Posts\n\n#### 1. {Post Title}\n- **Link:** https://reddit.com/r/ClaudeAI/comments/{id}\n- **Score:** {upvotes} ‚¨ÜÔ∏è | **Comments:** {comments} üí¨ | **Posted:** {time_ago}\n- **Author:** u/{username}\n- **Key Takeaway:** {what Claude users should know}\n- **Tags:** `{feature}` `{use-case}`\n\n{... more posts}\n\n**üî• Hot Topics in r/ClaudeAI:**\n- {topic 1}: {context}\n- {topic 2}: {context}\n\n**üì¢ Official/Notable Updates:** {any Anthropic announcements or significant feature discoveries}\n\n---\n\n## üü¢ r/ChatGPT - ChatGPT & OpenAI\n\n### Top Posts\n\n#### 1. {Post Title}\n- **Link:** https://reddit.com/r/ChatGPT/comments/{id}\n- **Score:** {upvotes} ‚¨ÜÔ∏è | **Comments:** {comments} üí¨ | **Posted:** {time_ago}\n- **Author:** u/{username}\n- **Key Takeaway:** {what ChatGPT users should know}\n- **Tags:** `{feature}` `{use-case}`\n\n{... more posts}\n\n**üî• Hot Topics in r/ChatGPT:**\n- {topic 1}: {context}\n- {topic 2}: {context}\n\n**üì¢ Official/Notable Updates:** {any OpenAI announcements}\n\n---\n\n## üî• Cross-Community Trends\n\nTopics generating discussion across multiple subreddits:\n\n### 1. {Trending Topic}\n- **Why it matters:** {explanation}\n- **Discussed in:** [r/AI_Agents]({url}), [r/ClaudeAI]({url}), [r/ChatGPT]({url})\n- **Key perspectives:**\n  - AI_Agents: {viewpoint}\n  - ClaudeAI: {viewpoint}\n  - ChatGPT: {viewpoint}\n\n### 2. {Trending Topic}\n- **Why it matters:** {explanation}\n- **Related posts:** [{title}]({url}), [{title}]({url})\n\n---\n\n## üí° AI Analysis & Insights\n\n**Key Themes This {Period}:**\n1. **{Theme}** - {detailed explanation with evidence from posts}\n2. **{Theme}** - {explanation}\n\n**Emerging Patterns:**\n- {pattern observed across communities}\n\n**What to Watch:**\n- {upcoming developments or trends to monitor}\n\n**Community Sentiment:**\n| Community | Sentiment | Top Concern |\n|-----------|-----------|-------------|\n| r/AI_Agents | {positive/neutral/negative} | {main topic} |\n| r/ClaudeAI | {sentiment} | {topic} |\n| r/ChatGPT | {sentiment} | {topic} |\n\n---\n\n## üõ†Ô∏è Tools & Resources Mentioned\n\n| Tool/Resource | Mentioned In | What It Does | Link |\n|---------------|--------------|--------------|------|\n| {name} | r/{subreddit} | {brief description} | [{url}]({url}) |\n\n---\n\n## üìù Notable Tutorials & Guides\n\n| Title | Community | Difficulty | Key Learning |\n|-------|-----------|------------|--------------|\n| [{title}]({url}) | r/{sub} | {beginner/intermediate/advanced} | {what you'll learn} |\n\n---\n\n## ‚ö° Action Items\n\nBased on today's discussions, consider:\n- [ ] {actionable insight 1}\n- [ ] {actionable insight 2}\n- [ ] {resource to check out}\n\n---\n\nüìä **Stats:** {total_posts} posts | {total_comments} comments | 3 communities\nüîÑ **Refresh:** `/ai-daily` | üíæ **Save:** `/ai-daily --save`\nüìÖ **Weekly:** `/ai-daily week` | üìÜ **Monthly:** `/ai-daily month`\n```\n\n### 4. Summarize Trends\n\nAfter collecting posts from all subreddits:\n- Identify common themes across communities\n- Note any major announcements or releases\n- Highlight highly-engaged discussions (high comment counts)\n\n### 5. Save Report (if --save specified)\n\nIf `--save` flag is present:\n\n```bash\n# Determine save path\nif [ -n \"$save_path\" ]; then\n    # User specified path\n    save_dir=\"$save_path\"\nelse\n    # Default path\n    save_dir=\"$HOME/Documents/reports/ai-daily\"\nfi\n\n# Create directory\nmkdir -p \"$save_dir\"\n\n# Generate filename: {date}-ai-{time_range}.md\nfilename=\"${save_dir}/$(date +%Y%m%d)-ai-${time_range}.md\"\n```\n\n**Use the Write tool to save the report:**\n\n```\nWrite(\"{save_dir}/{date}-ai-{time_range}.md\", \"{full_report_markdown}\")\n```\n\nAfter saving, inform user:\n```\n‚úÖ Report saved to: {filename}\n```\n\n---\n\n## Tool Priority\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  1. agent-browser --headed  ‚Üê‚îÄ‚îÄ REQUIRED (Reddit=JS)  ‚îÇ\n‚îÇ  2. ‚ùå WebFetch             ‚Üê‚îÄ‚îÄ WILL FAIL for Reddit  ‚îÇ\n‚îÇ  3. ‚ùå WebSearch            ‚Üê‚îÄ‚îÄ FORBIDDEN             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Why --headed?**\n- Uses local browser instance\n- Preserves user's cookies and login state\n- Can bypass some anti-bot measures\n- User can see what's happening\n\n**DO NOT:**\n- Skip agent-browser and assume it's unavailable\n- Use WebFetch for Reddit (will fail - requires JS)\n- Use WebSearch for fetching posts\n\n---\n\n## Example Usage\n\n```bash\n# Get today's AI news (default)\n/ai-daily\n\n# Get AI news from last 24 hours\n/ai-daily day\n\n# Get weekly AI news\n/ai-daily week\n\n# Get monthly AI news\n/ai-daily month\n\n# Save report to default location (~/Documents/reports/ai-daily/)\n/ai-daily --save\n\n# Save weekly report to default location\n/ai-daily week --save\n\n# Save report to custom directory\n/ai-daily --save ~/my-reports/ai\n\n# Combine: monthly report, save to custom path\n/ai-daily month --save ~/notes/ai-monthly\n```\n\n---\n\n## Output Example\n\n```markdown\n# ü§ñ AI Daily Report\n\n**Period:** 2026-01-19 - 2026-01-20 | **Generated:** 2026-01-20 15:30\n**Sources:** 45 posts from 3 subreddits\n\n---\n\n## üìä Quick Stats\n\n| Metric | Value |\n|--------|-------|\n| Total Posts Analyzed | 45 |\n| Hot Discussions (>100 comments) | 6 |\n| Product Announcements | 3 |\n| Tutorials/Guides | 8 |\n| Most Active Community | r/ChatGPT |\n\n---\n\n## ü§ñ r/AI_Agents - AI Agent Development\n\n### Top Posts\n\n#### 1. Claude Code Now Supports MCP Servers Natively\n- **Link:** https://reddit.com/r/AI_Agents/comments/xyz789\n- **Score:** 234 ‚¨ÜÔ∏è | **Comments:** 45 üí¨ | **Posted:** 4 hours ago\n- **Author:** u/mcp_developer\n- **Key Takeaway:** MCP (Model Context Protocol) integration allows Claude Code to connect to external tools and data sources. This is a major step toward truly autonomous agents that can interact with real-world systems.\n- **Tags:** `claude-code` `mcp` `tooling` `intermediate`\n\n#### 2. Building a Multi-Agent System with LangGraph - Complete Tutorial\n- **Link:** https://reddit.com/r/AI_Agents/comments/abc456\n- **Score:** 189 ‚¨ÜÔ∏è | **Comments:** 32 üí¨ | **Posted:** 8 hours ago\n- **Author:** u/langgraph_fan\n- **Key Takeaway:** Step-by-step guide for orchestrating multiple specialized agents. Shows patterns for agent communication, state management, and error handling in production.\n- **Tags:** `langgraph` `multi-agent` `tutorial` `advanced`\n\n**üî• Hot Topics in r/AI_Agents:**\n- MCP Protocol: [Native support](https://reddit.com/...), [Custom servers](https://reddit.com/...)\n- Agent monetization: Multiple posts on making agents profitable\n\n**üí° Emerging Tools/Frameworks:** LangGraph, CrewAI, AutoGen\n\n---\n\n## üü† r/ClaudeAI - Claude & Anthropic\n\n### Top Posts\n\n#### 1. Claude 4.5 Opus Announced - First Impressions Thread\n- **Link:** https://reddit.com/r/ClaudeAI/comments/def123\n- **Score:** 567 ‚¨ÜÔ∏è | **Comments:** 234 üí¨ | **Posted:** 2 hours ago\n- **Author:** u/anthropic_watcher\n- **Key Takeaway:** New flagship model with improved reasoning, larger context window (300K), and better code generation. Early testers report significant improvements in complex multi-step tasks.\n- **Tags:** `opus` `new-release` `benchmark`\n\n#### 2. Claude's New System Prompts Explained - What Changed\n- **Link:** https://reddit.com/r/ClaudeAI/comments/ghi789\n- **Score:** 423 ‚¨ÜÔ∏è | **Comments:** 89 üí¨ | **Posted:** 6 hours ago\n- **Author:** u/prompt_engineer\n- **Key Takeaway:** Anthropic updated Claude's system prompts to be more helpful while maintaining safety. Key changes include better handling of edge cases and more nuanced refusals.\n- **Tags:** `system-prompt` `safety` `behavior`\n\n**üî• Hot Topics in r/ClaudeAI:**\n- Opus 4.5 capabilities and pricing\n- Claude Code vs Cursor comparison threads\n\n**üì¢ Official/Notable Updates:** Claude 4.5 Opus release, API pricing changes\n\n---\n\n## üü¢ r/ChatGPT - ChatGPT & OpenAI\n\n### Top Posts\n\n#### 1. GPT-5 Rumors: What We Know So Far\n- **Link:** https://reddit.com/r/ChatGPT/comments/jkl012\n- **Score:** 892 ‚¨ÜÔ∏è | **Comments:** 445 üí¨ | **Posted:** 5 hours ago\n- **Author:** u/openai_insider\n- **Key Takeaway:** Compilation of leaked information and official hints about GPT-5. Expected features include native multimodal input, improved reasoning, and potential agent capabilities.\n- **Tags:** `gpt-5` `rumors` `speculation`\n\n#### 2. OpenAI's New Voice Mode is Incredible - Demo Inside\n- **Link:** https://reddit.com/r/ChatGPT/comments/mno345\n- **Score:** 654 ‚¨ÜÔ∏è | **Comments:** 234 üí¨ | **Posted:** 10 hours ago\n- **Author:** u/voice_tester\n- **Key Takeaway:** Advanced Voice mode now available to Plus users. Features real-time conversation, emotional tone detection, and multilingual support. Latency reduced to near-instant.\n- **Tags:** `voice-mode` `feature` `demo`\n\n**üî• Hot Topics in r/ChatGPT:**\n- GPT-5 speculation dominating discussion\n- Voice mode demos and use cases\n- Custom GPTs marketplace strategies\n\n**üì¢ Official/Notable Updates:** Voice mode general availability, GPT Store improvements\n\n---\n\n## üî• Cross-Community Trends\n\n### 1. Agent Capabilities Race\n- **Why it matters:** All major AI providers are pushing toward autonomous agents\n- **Discussed in:** [r/AI_Agents](https://reddit.com/...), [r/ClaudeAI](https://reddit.com/...), [r/ChatGPT](https://reddit.com/...)\n- **Key perspectives:**\n  - AI_Agents: Focus on practical implementation and tooling\n  - ClaudeAI: Excitement about MCP and Claude Code\n  - ChatGPT: Anticipation for GPT-5 agent features\n\n### 2. Voice/Multimodal as Default\n- **Why it matters:** Shift from text-only to multimodal interaction becoming standard\n- **Related posts:** [Voice mode demo](https://reddit.com/...), [Claude vision](https://reddit.com/...)\n\n---\n\n## üí° AI Analysis & Insights\n\n**Key Themes This Period:**\n1. **Agent Infrastructure Maturing** - MCP, LangGraph, and similar tools enabling production-grade agents\n2. **Model Competition Intensifying** - Opus 4.5 vs GPT-5 speculation driving engagement\n\n**Emerging Patterns:**\n- Increased focus on agent monetization and business applications\n- Voice/audio becoming differentiating feature\n\n**What to Watch:**\n- GPT-5 announcement timing (rumored Q1 2026)\n- MCP adoption across AI tools\n\n**Community Sentiment:**\n| Community | Sentiment | Top Concern |\n|-----------|-----------|-------------|\n| r/AI_Agents | Positive | Production readiness |\n| r/ClaudeAI | Excited | Opus pricing |\n| r/ChatGPT | Anticipatory | GPT-5 timeline |\n\n---\n\n## üõ†Ô∏è Tools & Resources Mentioned\n\n| Tool/Resource | Mentioned In | What It Does | Link |\n|---------------|--------------|--------------|------|\n| LangGraph | r/AI_Agents | Multi-agent orchestration | [langchain.com](https://langchain.com) |\n| MCP Protocol | r/ClaudeAI | Tool/data integration for Claude | [anthropic.com](https://anthropic.com) |\n| GPT Store | r/ChatGPT | Marketplace for custom GPTs | [chat.openai.com](https://chat.openai.com) |\n\n---\n\n## üìù Notable Tutorials & Guides\n\n| Title | Community | Difficulty | Key Learning |\n|-------|-----------|------------|--------------|\n| [Multi-Agent LangGraph](https://reddit.com/...) | r/AI_Agents | Advanced | Agent orchestration patterns |\n| [MCP Server Setup](https://reddit.com/...) | r/ClaudeAI | Intermediate | Connecting Claude to tools |\n| [Voice Mode Tips](https://reddit.com/...) | r/ChatGPT | Beginner | Getting best results from voice |\n\n---\n\n## ‚ö° Action Items\n\nBased on today's discussions, consider:\n- [ ] Try Claude 4.5 Opus for complex reasoning tasks\n- [ ] Explore MCP protocol for agent development\n- [ ] Test OpenAI's new voice mode if you have Plus\n- [ ] Bookmark LangGraph tutorial for multi-agent projects\n\n---\n\nüìä **Stats:** 45 posts | 1,234 comments | 3 communities\nüîÑ **Refresh:** `/ai-daily` | üíæ **Save:** `/ai-daily --save`\nüìÖ **Weekly:** `/ai-daily week` | üìÜ **Monthly:** `/ai-daily month`\n```\n\n---\n\n## Troubleshooting\n\nIf agent-browser commands fail:\n\n1. **Check installation:**\n   ```bash\n   which agent-browser\n   agent-browser install\n   ```\n\n2. **Try without --headed:**\n   ```bash\n   agent-browser open 'https://www.reddit.com/r/ClaudeAI/'\n   ```\n\n3. **Check browser is installed:**\n   ```bash\n   agent-browser install --with-deps\n   ```\n\n---\n\n## Related Commands\n\n- `/rust-daily` - Rust programming news\n",
        "commands/audit.md": "# /audit\n\nHeavy-weight security and safety audit using os-checker tools.\n\n## Usage\n\n```\n/audit [mode]\n```\n\n## Parameters\n\n- `mode` (optional): Audit mode\n  - `security` - ÂÆâÂÖ®ÊºèÊ¥ûÂÆ°ËÆ° (default)\n  - `safety` - unsafe ‰ª£Á†ÅÂÆâÂÖ®ÊÄßÂÆ°ËÆ°\n  - `concurrency` - Âπ∂ÂèëÈóÆÈ¢òÂÆ°ËÆ°\n  - `full` - ÂÆåÊï¥ÂÆ°ËÆ°ÔºàÊâÄÊúâÊ£ÄÊü•Âô®Ôºâ\n\n## When to Use\n\n| Âú∫ÊôØ | Êé®Ëçê |\n|------|------|\n| Êó•Â∏∏ÂºÄÂèë | Áî® `/rust-review` (clippy) |\n| PR ÂÆ°Êü• | Áî® `/rust-review` |\n| **ÂèëÂ∏ÉÂâç** | `/audit security` |\n| **unsafe ‰ª£Á†ÅÂÆ°Êü•** | `/audit safety` |\n| **Âπ∂Âèë‰ª£Á†ÅÂÆ°Êü•** | `/audit concurrency` |\n| **ÂÆâÂÖ®ÂÖ≥ÈîÆÈ°πÁõÆ** | `/audit full` |\n\n## Audit Modes\n\n### Security (Default)\n\nÊ£ÄÊü•Â∑≤Áü•ÂÆâÂÖ®ÊºèÊ¥ûÔºö\n\n| Â∑•ÂÖ∑ | Ê£ÄÊü•ÂÜÖÂÆπ |\n|------|----------|\n| `cargo audit` | ‰æùËµñ‰∏≠ÁöÑ CVE |\n| `geiger` | unsafe ‰ª£Á†ÅÊö¥Èú≤ÁªüËÆ° |\n\n```bash\ncargo audit\ncargo geiger\n```\n\n### Safety\n\nÊ£ÄÊü• unsafe ‰ª£Á†ÅÁöÑÊ≠£Á°ÆÊÄßÔºö\n\n| Â∑•ÂÖ∑ | Ê£ÄÊü•ÂÜÖÂÆπ |\n|------|----------|\n| `miri` | Undefined Behavior |\n| `rudra` | ÂÜÖÂ≠òÂÆâÂÖ®ÈóÆÈ¢ò |\n| `geiger` | unsafe ÁªüËÆ° |\n\n```bash\ncargo +nightly miri test\n# rudra ÈúÄË¶Å‰∏ìÈó®ÂÆâË£Ö\n```\n\n**Ê≥®ÊÑè**: ÈúÄË¶Å nightly toolchain\n\n### Concurrency\n\nÊ£ÄÊü•Âπ∂ÂèëÈóÆÈ¢òÔºö\n\n| Â∑•ÂÖ∑ | Ê£ÄÊü•ÂÜÖÂÆπ |\n|------|----------|\n| `lockbud` | Ê≠ªÈîÅÊ£ÄÊµã |\n| `atomvchecker` | ÂéüÂ≠êÊÄßËøùËßÑ |\n\n### Full\n\nËøêË°åÊâÄÊúâÂèØÁî®Ê£ÄÊü•Âô®ÔºàÊúÄÊÖ¢Ôºâ„ÄÇ\n\n## Integration with os-checker Skills\n\nÂÆ°ËÆ°Êó∂‰ºöÂèÇËÄÉ‰ª•‰∏ã skillsÔºö\n\n| Skill | Áî®ÈÄî |\n|-------|------|\n| `os-checker-checkers` | ‰∫ÜËß£ÊØè‰∏™Â∑•ÂÖ∑ÁöÑÂäüËÉΩ |\n| `os-checker-cli` | os-checker ÂëΩ‰ª§Áî®Ê≥ï |\n| `os-checker-diagnostics` | Ëß£ËØªÂÆ°ËÆ°ÁªìÊûú |\n| `os-checker-setup` | ÂÆâË£ÖÊ£ÄÊü•Â∑•ÂÖ∑ |\n\n## Issue Prioritization\n\n| ‰ºòÂÖàÁ∫ß | ËØäÊñ≠Á±ªÂûã | Â§ÑÁêÜ |\n|--------|----------|------|\n| Critical | `Miri`, `Rudra`, `Audit`, `Cargo` | Á´ãÂç≥‰øÆÂ§ç |\n| High | `Lockbud(Probably)`, `Semver Violation` | Â∫îËØ•‰øÆÂ§ç |\n| Medium | `Lockbud(Possibly)`, `Atomvchecker` | ÈúÄÂÆ°Êü• |\n| Low | `Geiger`, `Outdated` | ÂèÇËÄÉ‰ø°ÊÅØ |\n\n## Example Output\n\n```\nSecurity Audit Report\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n[1/2] cargo audit\n  ‚úó 2 vulnerabilities found\n\n  CRITICAL:\n    RUSTSEC-2024-0001: Memory corruption in foo v1.2.3\n    ‚Üí Upgrade to foo v1.2.4\n\n  HIGH:\n    RUSTSEC-2024-0002: DoS vulnerability in bar v2.0.0\n    ‚Üí Upgrade to bar v2.0.1\n\n[2/2] cargo geiger\n  Unsafe usage in dependencies:\n    ‚îú‚îÄ‚îÄ libc: 127 unsafe blocks\n    ‚îú‚îÄ‚îÄ tokio: 45 unsafe blocks\n    ‚îî‚îÄ‚îÄ your-crate: 3 unsafe blocks\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nRecommended Actions:\n1. Update foo to v1.2.4 (CRITICAL)\n2. Update bar to v2.0.1 (HIGH)\n3. Review unsafe usage with /unsafe-check\n```\n\n## Tool Installation\n\n```bash\n# Security\ncargo install cargo-audit\n\n# Safety (needs nightly)\nrustup +nightly component add miri\n\n# Geiger\ncargo install cargo-geiger\n\n# Full os-checker suite\ncargo install os-checker\n```\n\n## Batch Audit (Multiple Repos)\n\n‰ΩøÁî® os-checker ËøõË°åÊâπÈáèÂÆ°ËÆ°Ôºö\n\n```bash\n# ÂàõÂª∫ÈÖçÁΩÆ\ncat > audit-config.json << 'EOF'\n{\n  \"org/repo1\": {},\n  \"org/repo2\": {},\n  \"org/repo3\": {}\n}\nEOF\n\n# ÊâπÈáèËøêË°å\nos-checker run --config audit-config.json --emit results.json\n```\n\n## Related Commands\n\n- `/rust-review` - ËΩªÈáèÁ∫ßÊó•Â∏∏Ê£ÄÊü• (clippy)\n- `/unsafe-check` - unsafe ‰ª£Á†ÅÈùôÊÄÅÊ£ÄÊü•\n- `/unsafe-review` - ‰∫§‰∫íÂºè unsafe ÂÆ°Êü•\n",
        "commands/cache-clean.md": "---\ndescription: Clean Rust docs cache\nargument-hint: [--all | --expired | crate_name]\n---\n\n# Cache Clean\n\nClean cached Rust documentation.\n\nArguments: $ARGUMENTS\n- `--all`: Remove all cached docs\n- `--expired`: Remove only expired docs (default)\n- `crate_name`: Remove cache for specific crate/item\n\n---\n\n## Instructions\n\n### 1. Parse Arguments\n\n```bash\nCACHE_DIR=\"$HOME/.claude/cache/rust-docs\"\nMODE=\"expired\"  # default\nTARGET=\"\"\n\nfor arg in $ARGUMENTS; do\n    case $arg in\n        --all) MODE=\"all\" ;;\n        --expired) MODE=\"expired\" ;;\n        *) TARGET=\"$arg\" ;;\n    esac\ndone\n```\n\n### 2. Clean Based on Mode\n\n#### Mode: --all\n\n```bash\nif [ \"$MODE\" = \"all\" ]; then\n    echo \"Removing all cached docs...\"\n    rm -rf \"$CACHE_DIR\"/*\n    echo \"Cache cleared.\"\n    exit 0\nfi\n```\n\n#### Mode: --expired (default)\n\n```bash\nif [ \"$MODE\" = \"expired\" ]; then\n    echo \"Removing expired cache entries...\"\n    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n    count=0\n\n    for f in $(find \"$CACHE_DIR\" -name \"*.json\" -type f); do\n        exp=$(jq -r '.meta.expires_at' \"$f\" 2>/dev/null)\n        if [[ \"$exp\" < \"$now\" ]]; then\n            rm \"$f\"\n            ((count++))\n            echo \"Removed: ${f#$CACHE_DIR/}\"\n        fi\n    done\n\n    # Clean empty directories\n    find \"$CACHE_DIR\" -type d -empty -delete 2>/dev/null\n\n    echo \"\"\n    echo \"Removed $count expired entries.\"\n    exit 0\nfi\n```\n\n#### Mode: specific target\n\n```bash\nif [ -n \"$TARGET\" ]; then\n    echo \"Removing cache for: $TARGET\"\n\n    # Search in all categories\n    found=0\n    for category in std docs.rs lib.rs clippy; do\n        target_dir=\"$CACHE_DIR/$category/$TARGET\"\n        if [ -d \"$target_dir\" ]; then\n            rm -rf \"$target_dir\"\n            echo \"Removed: $category/$TARGET/\"\n            ((found++))\n        fi\n\n        # Also check for files matching the target\n        for f in $(find \"$CACHE_DIR/$category\" -name \"*$TARGET*\" -type f 2>/dev/null); do\n            rm \"$f\"\n            echo \"Removed: ${f#$CACHE_DIR/}\"\n            ((found++))\n        done\n    done\n\n    if [ $found -eq 0 ]; then\n        echo \"No cache found for: $TARGET\"\n    else\n        echo \"\"\n        echo \"Removed $found items.\"\n    fi\n    exit 0\nfi\n```\n\n---\n\n## Output Format\n\n### --expired (default)\n\n```\nRemoving expired cache entries...\nRemoved: docs.rs/tokio/task-fn.spawn.json\nRemoved: std/marker/trait.Send.json\nRemoved: lib.rs/serde.json\n\nRemoved 3 expired entries.\n```\n\n### --all\n\n```\nRemoving all cached docs...\nCache cleared.\n```\n\n### specific target\n\n```\nRemoving cache for: tokio\nRemoved: docs.rs/tokio/\nRemoved: lib.rs/tokio.json\n\nRemoved 2 items.\n```\n\n---\n\n## Example Usage\n\n```bash\n# Clean only expired entries (default)\n/rust-skills:cache-clean\n\n# Clean all cache\n/rust-skills:cache-clean --all\n\n# Clean specific crate cache\n/rust-skills:cache-clean tokio\n\n# Clean std library cache for specific item\n/rust-skills:cache-clean Send\n```\n",
        "commands/cache-status.md": "---\ndescription: Show Rust docs cache status\nargument-hint: [--verbose]\n---\n\n# Cache Status\n\nShow the status of cached Rust documentation.\n\nArguments: $ARGUMENTS\n- `--verbose`: Show detailed file list\n\n---\n\n## Instructions\n\n### 1. Check Cache Directory\n\n```bash\nCACHE_DIR=\"$HOME/.claude/cache/rust-docs\"\n\nif [ ! -d \"$CACHE_DIR\" ]; then\n    echo \"No cache directory found at: $CACHE_DIR\"\n    exit 0\nfi\n```\n\n### 2. Collect Statistics\n\n```bash\n# Count files and size by category\necho \"=== Rust Docs Cache Status ===\"\necho \"\"\necho \"Location: $CACHE_DIR\"\necho \"\"\n\nfor category in std docs.rs releases.rs lib.rs clippy; do\n    if [ -d \"$CACHE_DIR/$category\" ]; then\n        count=$(find \"$CACHE_DIR/$category\" -name \"*.json\" | wc -l | tr -d ' ')\n        size=$(du -sh \"$CACHE_DIR/$category\" 2>/dev/null | cut -f1)\n\n        # Count expired\n        expired=0\n        now=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n        for f in $(find \"$CACHE_DIR/$category\" -name \"*.json\"); do\n            exp=$(jq -r '.meta.expires_at' \"$f\" 2>/dev/null)\n            if [[ \"$exp\" < \"$now\" ]]; then\n                ((expired++))\n            fi\n        done\n\n        echo \"$category: $count items, $size (expired: $expired)\"\n    fi\ndone\n\necho \"\"\ntotal=$(find \"$CACHE_DIR\" -name \"*.json\" | wc -l | tr -d ' ')\ntotal_size=$(du -sh \"$CACHE_DIR\" 2>/dev/null | cut -f1)\necho \"Total: $total items, $total_size\"\n```\n\n### 3. Verbose Mode\n\nIf `--verbose` flag is set:\n\n```bash\necho \"\"\necho \"=== Cached Items ===\"\nfor f in $(find \"$CACHE_DIR\" -name \"*.json\" -type f | sort); do\n    rel_path=${f#$CACHE_DIR/}\n    exp=$(jq -r '.meta.expires_at' \"$f\" 2>/dev/null)\n    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n    if [[ \"$exp\" < \"$now\" ]]; then\n        status=\"[EXPIRED]\"\n    else\n        status=\"[valid]\"\n    fi\n    echo \"$status $rel_path (expires: $exp)\"\ndone\n```\n\n---\n\n## Output Format\n\n```\n=== Rust Docs Cache Status ===\n\nLocation: ~/.claude/cache/rust-docs\n\nstd: 45 items, 1.2M (expired: 3)\ndocs.rs: 128 items, 4.5M (expired: 12)\nreleases.rs: 15 items, 320K (expired: 0)\nlib.rs: 23 items, 156K (expired: 8)\nclippy: 42 items, 890K (expired: 5)\n\nTotal: 253 items, 7.1M\n```\n",
        "commands/clean-crate-skills.md": "---\ndescription: Remove local dynamic crate skills\nargument-hint: [crate_names...] [--all]\n---\n\n# Clean Crate Skills\n\nRemove dynamically generated crate skills from the local skills directory.\n\nArguments: $ARGUMENTS\n- `crate_names`: Specific crates to remove (space-separated)\n- `--all`: Remove all local crate skills\n\n---\n\n## Instructions\n\n### 1. List Current Skills\n\n```bash\nls -la ~/.claude/skills/\n```\n\nDisplay current skills:\n```\nLocal crate skills:\n- tokio (1.40.0) - 2025-01-15\n- serde (1.0.215) - 2025-01-14\n- axum (0.7.9) - 2025-01-13\n```\n\n### 2. Handle Arguments\n\n**If specific crates provided:**\n```bash\n# Remove specified crate skill directories\nrm -rf ~/.claude/skills/{crate_name}\nrm -rf ~/.claude/skills/{crate_name}-*  # Remove sub-skills (e.g., tokio-task, tokio-sync)\n```\n\n**If `--all` flag:**\n```bash\n# Remove all crate skills (be careful not to remove non-crate skills)\nrm -rf ~/.claude/skills/{crate_name}*\n```\n\n**If no arguments:**\nUse AskUserQuestion to ask which crates to remove:\n```\nWhich crate skills do you want to remove?\n- tokio\n- serde\n- axum\n- All of the above\n```\n\n### 3. Confirm Deletion\n\nBefore removing, confirm with user:\n```\nThis will remove skills for: tokio, serde\nContinue? (yes/no)\n```\n\n### 4. Report Results\n\n```\nCleaned skills:\n- tokio - removed\n- serde - removed\n\nRemaining skills: axum\n```\n\n---\n\n## Example Usage\n\n```bash\n# List and interactively select skills to remove\n/clean-crate-skills\n\n# Remove specific crate skills\n/clean-crate-skills tokio serde\n\n# Remove all crate skills\n/clean-crate-skills --all\n```\n\n---\n\n## Safety Notes\n\n- This only removes skills from `~/.claude/skills/`\n- Does not affect the rust-skills repository\n- Skills can be regenerated with `/sync-crate-skills`\n",
        "commands/crate-info.md": "# /crate-info\n\nGet information about a Rust crate including latest version, features, and changelog.\n\n## Usage\n\n```\n/crate-info <crate> [version]\n```\n\n## Parameters\n\n- `crate` (required): Crate name (e.g., `tokio`, `serde`, `axum`)\n- `version` (optional): Specific version to look up\n\n## Examples\n\n```\n/crate-info tokio           # Latest tokio info\n/crate-info axum 0.7        # axum 0.7 features\n/crate-info serde           # serde latest features\n```\n\n## Workflow\n\n1. Use `search_actions(\"lib.rs crate\")` to get action ID\n2. Use `get_action_by_id()` to get page selectors\n3. Use `agent-browser` to open https://lib.rs/crates/{crate}\n4. Extract crate information and changelog\n5. Summarize for user\n",
        "commands/create-llms-for-skills.md": "---\ndescription: Generate comprehensive llms.txt from URLs using agent-browser\nargument-hint: <urls> [requirements]\n---\n\n# Create llms.txt from URLs\n\nUse agent-browser CLI to access target URLs, extract content, and generate comprehensive llms.txt files.\n\nArguments: $ARGUMENTS\n- First argument(s): urls (required) - one or more URLs, space-separated\n- Last argument: requirements (optional) - additional requirements or instructions (if the last argument is not a URL)\n\n---\n\n## Tool Priority\n\n1. **agent-browser CLI** (preferred) - Full browser automation\n2. **WebFetch** (fallback) - If agent-browser unavailable\n\n**DO NOT use:**\n- Claude in Chrome MCP\n- Direct Fetch without user confirmation\n\n---\n\n## Instructions\n\n### 1. Parse Arguments\n\nFrom `$ARGUMENTS`, parse:\n- Identify all URLs (starting with http:// or https://)\n- Remaining content serves as additional requirements\n\n### 2. Use agent-browser CLI\n\nagent-browser is a **command-line tool** with specific subcommands:\n\n```bash\n# Step 1: Open the page\nagent-browser open \"https://docs.rs/{crate}/latest/{crate}/\"\n\n# Step 2: Extract content using CSS selectors\nagent-browser get text \".docblock\"              # Main documentation\nagent-browser get text \".module-item\"           # Module list\nagent-browser get text \".item-decl\"             # Type declarations\nagent-browser get text \"pre.rust\"               # Code examples\n\n# Step 3: Close browser\nagent-browser close\n```\n\n**Common selectors for docs.rs:**\n\n| Selector | Content |\n|----------|---------|\n| `.docblock` | Main documentation text |\n| `.module-item` | Module/item list |\n| `.item-decl` | Function/struct declarations |\n| `pre.rust` | Code examples |\n| `.feature-flag` | Feature flags |\n| `#reexports` | Re-exports section |\n\n**For multiple pages**, repeat open/get/close for each submodule.\n\n### 3. Content Extraction Strategy\n\nFor Rust crate documentation (docs.rs):\n\n```\n1. Main crate page ‚Üí Overview, re-exports, modules list\n2. Each major module ‚Üí Public items, examples\n3. Important types ‚Üí Methods, trait implementations\n4. Examples section ‚Üí Complete runnable code\n```\n\n**Extraction focus**:\n- Core concepts and principles\n- API function signatures and parameter descriptions\n- Code examples (complete and runnable)\n- Configuration options and best practices\n- Common patterns and use cases\n- Feature flags and cargo features\n\n### 4. Generate llms.txt\n\nConsolidate all content and generate in the following format:\n\n````markdown\n# {Crate Name}\n\n> {One-line description from crate docs}\n\n**Version:** {version} | **docs.rs:** {url}\n\n---\n\n## Overview\n\n{Detailed explanation of core concepts from crate-level docs}\n\n## Modules\n\n### {module_name}\n\n{Module description}\n\n#### Key Types\n\n| Type | Description |\n|------|-------------|\n| `TypeName` | Brief description |\n\n#### Key Functions\n\n```rust\n// Function signature with doc comment\npub fn function_name(param: Type) -> ReturnType\n```\n\n### Code Examples\n\n```rust\n// Complete code example from docs\nuse crate_name::...;\n\nfn main() {\n    // Example code\n}\n```\n\n---\n\n## Feature Flags\n\n| Feature | Description | Default |\n|---------|-------------|---------|\n| `feature_name` | What it enables | yes/no |\n\n---\n\n## Common Patterns\n\n### Pattern 1: {Name}\n```rust\n// Pattern code\n```\n\n### Pattern 2: {Name}\n```rust\n// Pattern code\n```\n````\n\n### 5. Save Output\n\n```bash\n# Generate timestamp\ntimestamp=$(date +%Y%m%d%H%M)\n\n# Determine crate name from URL\n# e.g., https://docs.rs/tokio/latest/tokio/ ‚Üí tokio\n\n# Save location\n~/tmp/${timestamp}-{crate_name}-llms.txt\n```\n\nInform the user of the file path after output is complete.\n\n---\n\n## Fallback: WebFetch\n\nIf agent-browser is not available:\n\n```\n1. Use WebFetch to get main page content\n2. Parse the response for key sections\n3. May need multiple WebFetch calls for subpages\n4. Inform user that content may be incomplete\n```\n\n---\n\n## Quality Requirements\n\n- [ ] Comprehensive content: Include actual API descriptions and code examples\n- [ ] Clear sources: Mark source URL for each section\n- [ ] Complete structure: Maintain the hierarchy of the original documentation\n- [ ] Usable code: Example code should be complete and runnable\n- [ ] Consistent format: Use consistent Markdown formatting\n- [ ] Feature flags: Document all cargo features\n\n---\n\n## Workflow Integration\n\nThis command is the first step in the Skills creation workflow:\n\n1. **create-llms-for-skills** (this command) ‚Üí Generate llms.txt\n2. **create-skills-via-llms** ‚Üí Create skills based on llms.txt\n\n---\n\n## Example Usage\n\n```bash\n# Generate llms.txt for tokio\n/create-llms-for-skills https://docs.rs/tokio/latest/tokio/\n\n# Generate for multiple URLs\n/create-llms-for-skills https://docs.rs/serde/latest/serde/ https://serde.rs/\n\n# With additional requirements\n/create-llms-for-skills https://docs.rs/axum/latest/axum/ \"Focus on routing and extractors\"\n```\n",
        "commands/create-llms-from-source.md": "---\ndescription: Generate llms.txt from local Rust source code\nargument-hint: [source_path] [output_path]\n---\n\n# Create llms.txt from Rust Source Code\n\nGenerate comprehensive llms.txt documentation from local Rust project source code.\n\nArguments: $ARGUMENTS\n- First argument: source_path (optional) - Rust project path, defaults to current directory\n- Second argument: output_path (optional) - output path, defaults to ~/tmp/{timestamp}-{crate}-llms.txt\n\n---\n\n## Tool Priority\n\n1. **rustdoc JSON** (preferred) - Most complete API extraction\n2. **Source code parsing** (fallback) - If rustdoc unavailable\n\n---\n\n## Instructions\n\n### 1. Validate Project\n\n```bash\n# Check if Cargo.toml exists\nif [ ! -f \"${source_path}/Cargo.toml\" ]; then\n    echo \"Error: No Cargo.toml found at ${source_path}\"\n    exit 1\nfi\n```\n\n### 2. Read Project Metadata\n\nExtract from `Cargo.toml`:\n- `name` - crate name\n- `version` - crate version\n- `description` - crate description\n- `[features]` - feature flags\n- `[dependencies]` - dependencies list\n\n```bash\n# Parse Cargo.toml\ngrep -E \"^name|^version|^description\" Cargo.toml\n```\n\n### 3. Check for Workspace\n\n```bash\n# Detect workspace\nif grep -q \"\\[workspace\\]\" Cargo.toml; then\n    # Parse members\n    grep -A 20 \"^\\[workspace\\]\" Cargo.toml | grep -E \"members\\s*=\"\n    # Process each member separately\nfi\n```\n\n**Workspace handling:**\n- If `[workspace]` section exists, identify all members\n- Generate llms.txt for each member crate\n- Or combine into single llms.txt with sections per crate\n\n### 4. Extract API Documentation\n\n#### Method A: rustdoc JSON (Preferred)\n\n```bash\n# Generate JSON documentation\ncargo +nightly rustdoc -- -Z unstable-options --output-format json 2>/dev/null\n\n# Output location\nls target/doc/*.json\n```\n\n**rustdoc JSON contains:**\n- Complete module hierarchy\n- All pub items with documentation\n- Type signatures and generics\n- Code examples from doc comments\n- Feature flag requirements\n\n**Parse JSON for:**\n```\n.index[*] | select(.visibility == \"public\") | {\n  name: .name,\n  kind: .kind,\n  docs: .docs,\n  sig: .inner.decl\n}\n```\n\n#### Method B: Source Code Parsing (Fallback)\n\nIf rustdoc fails (no nightly, compilation errors):\n\n```bash\n# Extract crate-level documentation\ngrep \"^//!\" src/lib.rs | sed 's/^\\/\\/! //'\n\n# Extract module documentation\nfind src -name \"*.rs\" -exec grep -l \"^//!\" {} \\;\n\n# Extract pub items with doc comments\ngrep -B 10 \"^pub \" src/**/*.rs | grep -E \"///|^pub \"\n\n# Extract pub item signatures\ngrep -E \"^pub (fn|struct|enum|trait|type|mod|const|static)\" src/**/*.rs\n```\n\n**Extraction targets:**\n| Pattern | Captures |\n|---------|----------|\n| `//!` | Module-level docs |\n| `///` | Item-level docs |\n| `pub fn` | Public functions |\n| `pub struct` | Public structs |\n| `pub enum` | Public enums |\n| `pub trait` | Public traits |\n| `pub type` | Type aliases |\n| `pub mod` | Public modules |\n\n### 5. Read README.md\n\n```bash\nif [ -f \"${source_path}/README.md\" ]; then\n    # Extract overview section (first 100 lines or until ## section)\n    head -100 README.md\nfi\n```\n\n### 6. Extract Feature Flags\n\n```bash\n# From Cargo.toml [features] section\ngrep -A 50 \"^\\[features\\]\" Cargo.toml | grep -B 50 \"^\\[\" | head -50\n```\n\n### 7. Generate llms.txt\n\nConsolidate all extracted content into this format:\n\n````markdown\n# {CrateName}\n\n> {Description from Cargo.toml}\n\n**Version:** {version} | **Source:** local\n\n---\n\n## Overview\n\n{Content from README.md or crate-level //! docs}\n\n## Modules\n\n### {module_name}\n\n{Module documentation from //!}\n\n#### Key Types\n\n| Type | Description |\n|------|-------------|\n| `StructName` | From /// docs |\n| `EnumName` | From /// docs |\n\n#### Key Functions\n\n```rust\n/// Function documentation\npub fn function_name(param: Type) -> ReturnType\n```\n\n## Code Examples\n\n```rust\n// Examples extracted from /// docs or README\n```\n\n---\n\n## Feature Flags\n\n| Feature | Dependencies | Description |\n|---------|--------------|-------------|\n| `feature_name` | dep1, dep2 | From Cargo.toml comments |\n\n---\n\n## Dependencies\n\n| Crate | Version | Features |\n|-------|---------|----------|\n| `dep_name` | 1.0 | feature1, feature2 |\n\n---\n\n## Source Structure\n\n```\nsrc/\n‚îú‚îÄ‚îÄ lib.rs          - Main library entry\n‚îú‚îÄ‚îÄ module1/\n‚îÇ   ‚îú‚îÄ‚îÄ mod.rs      - Module docs\n‚îÇ   ‚îî‚îÄ‚îÄ types.rs    - Type definitions\n‚îî‚îÄ‚îÄ module2.rs      - Single-file module\n```\n````\n\n### 8. Save Output\n\n```bash\n# Generate timestamp\ntimestamp=$(date +%Y%m%d%H%M)\n\n# Get crate name\ncrate_name=$(grep \"^name\" Cargo.toml | head -1 | cut -d'\"' -f2)\n\n# Output path\noutput=\"${output_path:-$HOME/tmp/${timestamp}-${crate_name}-llms.txt}\"\n\n# Ensure directory exists\nmkdir -p \"$(dirname \"$output\")\"\n\n# Write file\necho \"Output saved to: $output\"\n```\n\n---\n\n## Fallback Strategy\n\n```\n1. Try rustdoc JSON\n   ‚Üì (if failed)\n2. Use source code parsing\n   ‚Üì (always)\n3. Supplement with Cargo.toml + README.md\n```\n\n**Automatic fallback triggers:**\n- No nightly toolchain installed\n- Project has compilation errors\n- Missing dependencies\n- Build script failures\n\nWhen falling back, inform user:\n```\nrustdoc JSON generation failed, using source code parsing.\nSome type information may be incomplete.\n```\n\n---\n\n## Quality Requirements\n\n- [ ] All pub items documented\n- [ ] Module hierarchy preserved\n- [ ] Code examples included\n- [ ] Feature flags documented\n- [ ] Dependencies listed\n- [ ] Source structure shown\n- [ ] Consistent markdown formatting\n- [ ] Version information accurate\n\n---\n\n## Workspace Handling\n\nFor workspaces with multiple crates:\n\n**Option 1: Combined llms.txt**\n```\n~/tmp/{timestamp}-{workspace}-llms.txt\n```\nContains sections for each member crate.\n\n**Option 2: Separate files**\n```\n~/tmp/{timestamp}-{crate1}-llms.txt\n~/tmp/{timestamp}-{crate2}-llms.txt\n```\n\nAsk user which approach they prefer for workspaces.\n\n---\n\n## Workflow Integration\n\nThis command integrates with the Skills creation workflow:\n\n```\nLocal Rust Source\n        ‚Üì\n/create-llms-from-source {path}\n        ‚Üì\n~/tmp/{timestamp}-{crate}-llms.txt\n        ‚Üì\n/create-skills-via-llms {crate} {llms_path}\n        ‚Üì\n~/.claude/skills/{crate}-*/\n```\n\n**Or via sync-crate-skills:**\n```\n/sync-crate-skills --from-source {path}\n```\n\n---\n\n## Example Usage\n\n```bash\n# Generate llms.txt for current directory\n/create-llms-from-source\n\n# Generate for specific project\n/create-llms-from-source /path/to/my-rust-project\n\n# Specify output path\n/create-llms-from-source /path/to/project ~/docs/my-crate-llms.txt\n\n# For workspace project\n/create-llms-from-source /path/to/workspace\n```\n\n---\n\n## Limitations\n\n- Private items (`pub(crate)`, `pub(super)`) are excluded\n- Macro-generated code may not be fully captured in source parsing mode\n- Generic constraints shown as-is without resolution\n- Inline documentation preferred over external doc files\n",
        "commands/create-skills-via-llms.md": "---\ndescription: Create high-quality Rust crate skills from llms.txt\nargument-hint: <crate_name> <llms_path> [version] [description]\n---\n\nCreate high-quality skills for a Rust crate based on llms.txt documentation.\n\nArguments: $ARGUMENTS\n- First argument: crate_name (required) - the Rust crate name (e.g., tokio, serde)\n- Second argument: llms_path (required) - local path to the llms.txt file\n- Third argument: version (optional) - the crate version (e.g., \"1.40.0\", \"2.0.0\")\n- Fourth argument: description (optional) - additional requirements or information\n\n---\n\n## Task: Create {crate_name} Skills\n\n**llms.txt file location**: {llms_path}\n\n---\n\n## Skill Quality Standards\n\nEach skill must include the following structure:\n\n### SKILL.md Structure\n\n````markdown\n---\nname: {crate_name}-{feature}\ndescription: |\n  CRITICAL: Use for {crate_name} {feature} questions. Triggers on:\n  {keyword1}, {keyword2}, {keyword3}, \"{common question}\",\n  {‰∏≠ÊñáÂÖ≥ÈîÆËØç1}, {‰∏≠ÊñáÂÖ≥ÈîÆËØç2}, {‰∏≠ÊñáÈóÆÈ¢ò}\n---\n\n# {CrateName} {Feature} Skill\n\n> **Version:** {crate_name} {version} | **Last Updated:** {YYYY-MM-DD}\n>\n> Check for updates: https://crates.io/crates/{crate_name}\n\nYou are an expert at the Rust `{crate_name}` crate. Help users by:\n- **Writing code**: Generate Rust code following the patterns below\n- **Answering questions**: Explain concepts, troubleshoot issues, reference documentation\n\n## Documentation\n\nRefer to the local files for detailed documentation:\n- `./references/{file1}.md` - {description}\n- `./references/{file2}.md` - {description}\n\n## IMPORTANT: Documentation Completeness Check\n\n**Before answering questions, Claude MUST:**\n\n1. Read the relevant reference file(s) listed above\n2. If file read fails or file is empty:\n   - Inform user: \"Êú¨Âú∞ÊñáÊ°£‰∏çÂÆåÊï¥ÔºåÂª∫ËÆÆËøêË°å `/sync-crate-skills {crate_name} --force` Êõ¥Êñ∞ÊñáÊ°£\"\n   - Still answer based on SKILL.md patterns + built-in knowledge\n3. If reference file exists, incorporate its content into the answer\n\n## Key Patterns\n\n{Core code patterns, 3-5 most commonly used patterns}\n\n## API Reference Table\n\n| Function/Type | Description | Example |\n|---------------|-------------|---------|\n| ... | ... | ... |\n\n## Deprecated Patterns (Don't Use)\n\n| Deprecated | Correct | Notes |\n|------------|---------|-------|\n| ... | ... | ... |\n\n## When Writing Code\n\n1. {Best practice 1}\n2. {Best practice 2}\n3. ...\n\n## When Answering Questions\n\n1. {Key point 1}\n2. {Key point 2}\n3. ...\n````\n\n### References Directory\n\nEach skill's `references/` directory contains detailed documentation:\n- API reference documentation\n- Configuration options details\n- Advanced usage examples\n- Feature-specific configurations\n\n---\n\n## Instructions\n\n### 1. Read llms.txt and Analyze\n\n1. **Read the entire llms.txt** content\n2. **Identify content domains**: Find functional modules that can be separate skills\n3. **Analyze each domain**:\n   - What are the core concepts?\n   - What APIs/configuration options exist?\n   - What are common usage patterns?\n   - What content needs detailed documentation?\n\n### 1.5 Confirm Version Number\n\nIf the user did not provide a version number (third argument):\n1. Use the AskUserQuestion tool to ask the user for the current version\n2. Version format examples: \"1.40.0\", \"2.0.0\", \"latest\"\n3. Use the version number for all SKILL.md Version fields\n\n### 2. Output Detailed Plan\n\nOutput to `~/tmp/{YYYYMMDDHHmm}-{crate_name}-skills-plan.md`:\n\n````markdown\n# {CrateName} Skills Plan\n\n## Analysis Summary\n- Crate: {crate_name}\n- Version: {version}\n- Main functional domains: ...\n\n## Skill List\n\n### 1. {crate_name}-{feature1}\n**Trigger conditions**: \"...\", \"...\", \"...\"\n**Core content**: ...\n**Reference files**:\n- {file1}.md - {description}\n- {file2}.md - {description}\n\n### 2. {crate_name}-{feature2}\n...\n````\n\n### 3. Create Skills\n\nFor each skill:\n\n1. **Create directory structure**:\n   ```\n   ~/.claude/skills/{crate_name}-{feature}/\n   ‚îú‚îÄ‚îÄ SKILL.md\n   ‚îî‚îÄ‚îÄ references/\n       ‚îú‚îÄ‚îÄ {api-reference}.md\n       ‚îî‚îÄ‚îÄ {detailed-guide}.md\n   ```\n\n2. **Write SKILL.md**:\n   - Follow the quality standards above\n   - Keep SKILL.md concise (<200 lines)\n   - Put complex content in references/\n\n3. **Write reference files**:\n   - Complete API reference\n   - Configuration options tables\n   - Detailed code examples\n   - Feature-specific content\n\n### 4. Content Allocation Principles\n\n| Content Type | Location |\n|--------------|----------|\n| Core patterns (3-5) | SKILL.md |\n| Complete API reference | references/ |\n| Configuration options details | references/ |\n| Feature-specific config | references/ |\n| Advanced usage/edge cases | references/ |\n| Deprecated patterns table | SKILL.md |\n| Best practices | SKILL.md |\n\n---\n\n## Quality Checklist\n\n- [ ] Each SKILL.md has CSO-optimized description with \"CRITICAL:\" prefix\n- [ ] Each SKILL.md description includes Chinese trigger keywords\n- [ ] Each SKILL.md has version info and update date\n- [ ] Each SKILL.md has \"You are an expert...\" role definition\n- [ ] Each SKILL.md has Documentation navigation list\n- [ ] Each SKILL.md has \"Documentation Completeness Check\" section\n- [ ] Each SKILL.md has Key Patterns code examples\n- [ ] Each SKILL.md has Deprecated Patterns table (if applicable)\n- [ ] Each SKILL.md has \"When Writing Code\" best practices\n- [ ] Each SKILL.md has \"When Answering Questions\" guidelines\n- [ ] Complex content has been split into references/ directory\n- [ ] Code examples use latest Rust idioms\n- [ ] No redundant documentation files (README.md, etc.)\n- [ ] Skills created directly in `~/.claude/skills/` for auto-discovery\n\n---\n\n## Output Location\n\nAll skills are created in: `~/.claude/skills/{crate_name}-*/`\n\nThis is the local dynamic skills directory, not committed to the rust-skills repository.\n",
        "commands/docs.md": "---\nname: docs\ndescription: Fetch Rust API documentation from docs.rs\narguments:\n  - name: crate_name\n    description: Name of the crate to look up\n    required: true\n  - name: item\n    description: Specific item (function, struct, trait) to look up\n    required: false\n---\n\n# /docs Command\n\nFetch API documentation for Rust crates from docs.rs.\n\n## Usage\n\n```\n/docs <crate_name> [item]\n```\n\n## Examples\n\n```\n/docs snafu              # Get snafu crate overview\n/docs tokio spawn        # Get tokio::spawn documentation\n/docs serde Serialize    # Get serde::Serialize trait docs\n```\n\n## Workflow\n\n1. Use actionbook MCP to get docs.rs selectors\n2. Launch `docs-researcher` agent with target URL\n3. Wait for agent to complete\n4. Return formatted API documentation\n\n## Target URLs\n\n- Overview: `https://docs.rs/<crate>/latest/<crate>/`\n- Function: `https://docs.rs/<crate>/latest/<crate>/fn.<name>.html`\n- Struct: `https://docs.rs/<crate>/latest/<crate>/struct.<Name>.html`\n- Trait: `https://docs.rs/<crate>/latest/<crate>/trait.<Name>.html`\n- Macro: `https://docs.rs/<crate>/latest/<crate>/macro.<name>.html`\n- Module: `https://docs.rs/<crate>/latest/<crate>/<module>/`\n\n## Output Format\n\n```\n# <crate_name> API Documentation\n\n## Overview\n<crate description>\n\n## Key Types\n- `TypeName`: <description>\n\n## Key Functions\n- `fn_name`: <description>\n\n## Key Traits\n- `TraitName`: <description>\n\nSource: docs.rs\n```\n",
        "commands/fix-skill-docs.md": "---\ndescription: Check and fix missing reference files in dynamic skills\nargument-hint: [crate_name] [--check-only] [--remove-invalid]\n---\n\n# Fix Skill Documentation\n\nCheck dynamic skills for missing reference files and fix them.\n\nArguments: $ARGUMENTS\n- `crate_name`: Specific crate to check (optional, defaults to all crates in ~/.claude/skills/)\n- `--check-only`: Only report issues, don't fix\n- `--remove-invalid`: Remove references to non-existent files instead of creating them\n\n---\n\n## Instructions\n\n### 1. Scan Skills Directory\n\n```bash\n# If crate_name provided\nskill_dir=~/.claude/skills/{crate_name}\n\n# Otherwise scan all\nfor dir in ~/.claude/skills/*/; do\n    # Process each skill\ndone\n```\n\n### 2. Parse SKILL.md for References\n\nFor each skill, extract referenced files from:\n\n```markdown\n## Documentation\n\nRefer to the local files for detailed documentation:\n- `./references/file1.md` - Description\n- `./references/file2.md` - Description\n```\n\nAlso check \"Expected reference files\" section if present.\n\n### 3. Check File Existence\n\nFor each referenced file:\n```bash\nif [ ! -f \"{skill_dir}/references/{filename}\" ]; then\n    echo \"MISSING: {filename}\"\nfi\n```\n\n### 4. Report Status\n\nOutput format:\n```\n=== {crate_name} ===\nSKILL.md: ‚úÖ\nreferences/:\n  - sync.md: ‚úÖ\n  - time.md: ‚úÖ\n  - runtime.md: ‚ùå MISSING\n  - io.md: ‚ùå MISSING\n\nAction needed: 2 files missing\n```\n\n### 5. Fix Missing Files\n\n**If --check-only**: Stop here, only report.\n\n**If --remove-invalid**: Update SKILL.md to remove invalid references.\n\n**Otherwise (default)**: Generate missing reference files using agent-browser:\n\n```bash\n# For each missing file\nagent-browser \"Navigate to docs.rs/{crate_name}/latest/{crate_name}/{module}/\nExtract documentation for {topic} including:\n- API reference\n- Code examples\n- Common patterns\nSave as markdown.\"\n\n# Save to references/{filename}\n```\n\n### 6. Update SKILL.md\n\nAfter fixing, ensure SKILL.md Documentation section matches actual files:\n\n```markdown\n## Documentation\n\nRefer to the local files for detailed documentation:\n- `./references/sync.md` - Synchronization primitives\n- `./references/time.md` - Time utilities\n```\n\n---\n\n## Tool Priority\n\n1. **agent-browser CLI** - Generate missing documentation\n2. **WebFetch** - Fallback if agent-browser unavailable\n3. **Edit SKILL.md** - Remove invalid references (--remove-invalid mode)\n\n---\n\n## Example Usage\n\n```bash\n# Check all skills\n/fix-skill-docs --check-only\n\n# Fix specific crate\n/fix-skill-docs tokio\n\n# Check specific crate only\n/fix-skill-docs tokio --check-only\n\n# Remove invalid references instead of creating files\n/fix-skill-docs tokio --remove-invalid\n\n# Fix all skills\n/fix-skill-docs\n```\n\n---\n\n## Output Example\n\n```\n=== Skill Documentation Check ===\n\ntokio:\n  SKILL.md: ‚úÖ\n  references/:\n    ‚úÖ sync.md (2.5KB)\n    ‚úÖ time.md (2.7KB)\n    ‚ùå runtime.md - MISSING\n    ‚ùå io.md - MISSING\n  Status: 2 files missing\n\ntokio-basics:\n  SKILL.md: ‚úÖ\n  references/:\n    ‚úÖ runtime-config.md (2.0KB)\n    ‚úÖ feature-flags.md (1.5KB)\n  Status: Complete ‚úÖ\n\nSummary:\n- 7 skills checked\n- 6 complete\n- 1 with missing files\n\nRun `/fix-skill-docs tokio` to fix missing files.\n```\n\n---\n\n## Integration\n\nThis command complements the skill creation workflow:\n\n1. `/sync-crate-skills` - Create initial skills\n2. `/fix-skill-docs` - Verify and fix completeness\n3. `/clean-crate-skills` - Remove skills when needed\n",
        "commands/guideline.md": "# /guideline\n\nQuery Rust coding guidelines and best practices.\n\n## Usage\n\n```\n/guideline <query>\n/guideline --clippy <lint>\n```\n\n## Parameters\n\n- `query` (required): Rule ID (e.g., `P.NAM.01`) or keyword (e.g., `naming`)\n- `--clippy <lint>`: Look up a Clippy lint and map it to guideline rules\n\n## Examples\n\n```\n/guideline P.NAM.01          # Get specific rule\n/guideline naming            # Search naming conventions\n/guideline clippy            # Search clippy-related rules\n/guideline --clippy needless_clone  # Map clippy lint to rule\n```\n\n## Workflow\n\n### Standard Query\n1. Parse query type (rule ID or keyword)\n2. Check if unsafe-related ‚Üí route to `unsafe-checker` skill\n3. Search in rules files or rules-index.md\n4. Return matching rules with:\n   - Rule ID and level (P/G)\n   - Title and description\n   - Code examples\n   - Link to full documentation\n\n### Clippy Lint Query (`--clippy`)\n1. Use `clippy-researcher` agent\n2. Look up lint in `clippy-lints/_index.md`\n3. Return:\n   - Lint description\n   - Mapped rule ID and skill\n   - Fix suggestions\n\n## Rule Levels\n\n- **P (Prescribed)**: Must follow - Required rules\n- **G (Guidance)**: Should follow - Recommended rules\n\n## Routing\n\n| Query Type | Routed To |\n|------------|-----------|\n| P.UNS.*, G.UNS.*, FFI, unsafe | `unsafe-checker` skill |\n| P.*, G.* (other) | `coding-guidelines` skill |\n| --clippy <lint> | `clippy-researcher` agent |\n\n## Related Commands\n\n- `/unsafe-check` - Check file for unsafe issues\n- `/unsafe-review` - Interactive unsafe review\n",
        "commands/rust-daily.md": "---\ndescription: Generate Rust daily/weekly/monthly news report\nargument-hint: [day|week|month] [--category ecosystem|official|foundation] [--save [path]]\n---\n\n# Rust Daily Report\n\nGenerate a summarized report of Rust news from multiple sources.\n\nArguments: $ARGUMENTS\n- `time_range` (optional): `day` | `week` | `month` (default: `week`)\n- `--category` (optional): `ecosystem` | `official` | `foundation` | `all` (default: `all`)\n- `--save` (optional): Save report to file. If path not specified, saves to `~/Documents/reports/rust-daily/`\n\n---\n\n## Sources\n\n| Category | Sources |\n|----------|---------|\n| **Ecosystem** | Reddit r/rust, This Week in Rust |\n| **Official** | Rust Blog, Inside Rust Blog |\n| **Foundation** | Rust Foundation News, Blog, Events |\n\n---\n\n## Instructions\n\n### 1. Parse Arguments\n\n```\n/rust-daily              ‚Üí week, all categories, display only\n/rust-daily day          ‚Üí last 24 hours, all\n/rust-daily week         ‚Üí last 7 days, all\n/rust-daily month        ‚Üí last 30 days, all\n/rust-daily --category ecosystem  ‚Üí week, ecosystem only\n/rust-daily day --category official ‚Üí day, official only\n/rust-daily --save       ‚Üí save to ~/Documents/reports/rust-daily/{date}-rust-{time_range}.md\n/rust-daily --save /path/to/dir  ‚Üí save to specified directory\n/rust-daily day --save   ‚Üí day report, save to default location\n```\n\n### 2. Check Cache\n\nCheck if recent cache exists:\n\n```bash\ncache_dir=~/.claude/cache/rust-daily/\ncache_file=${cache_dir}/report-{date}-{time_range}-{category}.json\n\n# If cache exists and < 4 hours old, use cached data\n```\n\n### 3. Fetch Content\n\n**YOU MUST USE THE BASH TOOL TO RUN agent-browser COMMANDS.**\n\nDo NOT assume agent-browser is unavailable. It IS installed at `/opt/homebrew/bin/agent-browser`.\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  FOR EACH SOURCE:                                       ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  1. USE BASH TOOL to run: agent-browser open/get/close ‚îÇ\n‚îÇ         ‚Üì (only if Bash returns error)                 ‚îÇ\n‚îÇ  2. USE WebFetch tool as fallback                      ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  ‚ö†Ô∏è  YOU MUST ACTUALLY RUN THE BASH COMMANDS           ‚îÇ\n‚îÇ  ‚ö†Ô∏è  DO NOT ASSUME agent-browser is unavailable        ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n#### Step 3a: Reddit (Bash + agent-browser REQUIRED)\n\n**Use the Bash tool to execute these commands:**\n\n```\nBash(\"agent-browser open 'https://www.reddit.com/r/rust/top/?t=day'\")\nBash(\"agent-browser get text '[data-testid=\\\"post-container\\\"]' --limit 15\")\nBash(\"agent-browser close\")\n```\n\nReddit requires JavaScript. WebFetch will fail. Only mark unavailable if Bash command fails.\n\n#### Step 3b: This Week in Rust (Bash first)\n\n**Use the Bash tool:**\n\n```\nBash(\"agent-browser open 'https://this-week-in-rust.org/'\")\nBash(\"agent-browser get text '.post-content'\")\nBash(\"agent-browser close\")\n```\n\nIf Bash fails ‚Üí Use WebFetch tool\n\n#### Step 3c: Rust Blog (Bash first)\n\n**Use the Bash tool:**\n\n```\nBash(\"agent-browser open 'https://blog.rust-lang.org/'\")\nBash(\"agent-browser get text '.post-list'\")\nBash(\"agent-browser close\")\n```\n\nIf Bash fails ‚Üí Use WebFetch tool\n\n#### Step 3d: Foundation News (Bash first)\n\n**Use the Bash tool:**\n\n```\nBash(\"agent-browser open 'https://foundation.rust-lang.org/news/'\")\nBash(\"agent-browser get text '.news-list'\")\nBash(\"agent-browser close\")\n```\n\nIf Bash fails ‚Üí Use WebFetch tool\n\n#### Step 3e: FORBIDDEN\n\n- ‚ùå **Assuming agent-browser unavailable without trying** - YOU MUST RUN BASH COMMANDS\n- ‚ùå **WebSearch** - Never use for fetching news\n- ‚ùå **WebFetch for Reddit** - Will always fail\n\n### 4. Format Output\n\n**CRITICAL: Every item MUST include:**\n1. ‚úÖ Real source link (not fabricated)\n2. ‚úÖ Key takeaway summary (1-2 sentences)\n3. ‚úÖ Engagement metrics (upvotes, comments)\n4. ‚úÖ Publication date/time\n\nDisplay the report in markdown format:\n\n```markdown\n# ü¶Ä Rust {Time_Range} Report\n\n**Period:** {start_date} - {end_date} | **Generated:** {now}\n**Sources:** {count} items from {source_count} sources\n\n---\n\n## üìä Quick Stats\n\n| Metric | Value |\n|--------|-------|\n| Total Posts | {count} |\n| Hot Discussions (>50 comments) | {hot_count} |\n| Official Announcements | {official_count} |\n| Top Topic | {top_topic} |\n\n---\n\n## üåê Ecosystem Highlights\n\n### Reddit r/rust\n\n#### 1. {Post Title}\n- **Link:** https://reddit.com/r/rust/comments/{id}\n- **Score:** {upvotes} ‚¨ÜÔ∏è | **Comments:** {comments} üí¨ | **Posted:** {time_ago}\n- **Author:** u/{username}\n- **Key Takeaway:** {1-2 sentence summary of why this matters}\n- **Tags:** `{tag1}` `{tag2}`\n\n#### 2. {Post Title}\n- **Link:** {real_url}\n- **Score:** {upvotes} ‚¨ÜÔ∏è | **Comments:** {comments} üí¨ | **Posted:** {time_ago}\n- **Key Takeaway:** {summary}\n\n{... more posts}\n\n### This Week in Rust #{issue_number}\n- **Link:** https://this-week-in-rust.org/blog/{date}/this-week-in-rust-{number}/\n- **Published:** {date}\n\n**Crate of the Week:** [{crate_name}]({crates.io_link})\n> {why it was selected}\n\n**Notable Updates:**\n| Item | Summary | Link |\n|------|---------|------|\n| {title} | {key_takeaway} | [‚Üí]({url}) |\n\n---\n\n## üì¢ Official Announcements\n\n### Rust Blog\n\n#### {Post Title}\n- **Link:** https://blog.rust-lang.org/{path}\n- **Published:** {date}\n- **Key Takeaway:** {what this means for Rust developers}\n- **Action Required:** {yes/no - what users should do}\n\n### Inside Rust Blog\n\n#### {Post Title}\n- **Link:** https://blog.rust-lang.org/inside-rust/{path}\n- **Published:** {date}\n- **Key Takeaway:** {summary}\n- **Relevant Teams:** {compiler, lang, libs, etc.}\n\n---\n\n## üèõÔ∏è Rust Foundation\n\n### News & Announcements\n\n#### {Title}\n- **Link:** https://foundation.rust-lang.org/news/{path}\n- **Published:** {date}\n- **Key Takeaway:** {impact on Rust ecosystem}\n\n### Upcoming Events\n\n| Date | Event | Location | Link | Why Attend |\n|------|-------|----------|------|------------|\n| {date} | {name} | {location} | [Register]({url}) | {brief reason} |\n\n---\n\n## üî• Trending Topics\n\nBased on engagement and discussion volume:\n\n1. **{Topic 1}** - {brief explanation}\n   - Related: [{post1}]({url}), [{post2}]({url})\n\n2. **{Topic 2}** - {brief explanation}\n   - Related: [{post1}]({url})\n\n---\n\n## üí° AI Analysis\n\n**Key Themes This {Period}:**\n- {theme 1 with context}\n- {theme 2 with context}\n\n**What to Watch:**\n- {upcoming event or trend to monitor}\n\n**Community Sentiment:** {positive/neutral/mixed} - {brief explanation}\n\n---\n\n## üìö Further Reading\n\n| Topic | Resource | Type |\n|-------|----------|------|\n| {topic} | [{title}]({url}) | Blog/Video/Doc |\n\n---\n\nüìä **Stats:** {total_posts} posts | {total_comments} comments | {sources_count} sources\nüîÑ **Refresh:** `/rust-daily` | üíæ **Save:** `/rust-daily --save`\n```\n\n### 5. Save Report (if --save specified)\n\nIf `--save` flag is present:\n\n```bash\n# Determine save path\nif [ -n \"$save_path\" ]; then\n    # User specified path\n    save_dir=\"$save_path\"\nelse\n    # Default path\n    save_dir=\"$HOME/Documents/reports/rust-daily\"\nfi\n\n# Create directory\nmkdir -p \"$save_dir\"\n\n# Generate filename: {date}-rust-{time_range}.md\nfilename=\"${save_dir}/$(date +%Y%m%d)-rust-${time_range}.md\"\n\n# Save report using Write tool\nWrite(\"$filename\", \"{report_content}\")\n```\n\n**Use the Write tool to save the report:**\n\n```\nWrite(\"{save_dir}/{date}-rust-{time_range}.md\", \"{full_report_markdown}\")\n```\n\nAfter saving, inform user:\n```\n‚úÖ Report saved to: {filename}\n```\n\n### 6. Save Cache\n\nSave results for faster subsequent queries:\n\n```bash\nmkdir -p ~/.claude/cache/rust-daily/\n# Save JSON with metadata\n```\n\n---\n\n## Example Usage\n\n```bash\n# Get weekly Rust news (default)\n/rust-daily\n\n# Get today's Rust news\n/rust-daily day\n\n# Get monthly summary\n/rust-daily month\n\n# Get only ecosystem updates (Reddit, TWIR)\n/rust-daily --category ecosystem\n\n# Get official Rust project updates only\n/rust-daily --category official\n\n# Get Rust Foundation updates only\n/rust-daily --category foundation\n\n# Combine: today's official updates\n/rust-daily day --category official\n\n# Save report to default location (~/Documents/reports/rust-daily/)\n/rust-daily --save\n\n# Save daily report to default location\n/rust-daily day --save\n\n# Save report to custom directory\n/rust-daily --save ~/my-reports/rust\n\n# Combine: weekly ecosystem report, save to custom path\n/rust-daily week --category ecosystem --save ~/notes/rust-weekly\n```\n\n---\n\n## Output Example\n\n```markdown\n# ü¶Ä Rust Daily Report\n\n**Period:** 2026-01-19 - 2026-01-20 | **Generated:** 2026-01-20 15:30\n**Sources:** 18 items from 5 sources\n\n---\n\n## üìä Quick Stats\n\n| Metric | Value |\n|--------|-------|\n| Total Posts | 18 |\n| Hot Discussions (>50 comments) | 4 |\n| Official Announcements | 2 |\n| Top Topic | Async improvements |\n\n---\n\n## üåê Ecosystem Highlights\n\n### Reddit r/rust\n\n#### 1. Tokio 2.0 Released with Major Performance Improvements\n- **Link:** https://reddit.com/r/rust/comments/abc123\n- **Score:** 542 ‚¨ÜÔ∏è | **Comments:** 89 üí¨ | **Posted:** 6 hours ago\n- **Author:** u/tokio_maintainer\n- **Key Takeaway:** Tokio 2.0 brings 40% better throughput and simplified APIs. If you're using async Rust, this is a must-upgrade with mostly backward-compatible changes.\n- **Tags:** `async` `tokio` `release`\n\n#### 2. Why I Switched My Company from Go to Rust\n- **Link:** https://reddit.com/r/rust/comments/def456\n- **Score:** 423 ‚¨ÜÔ∏è | **Comments:** 156 üí¨ | **Posted:** 12 hours ago\n- **Author:** u/startup_cto\n- **Key Takeaway:** Real-world experience report showing 60% reduction in production bugs after migrating. Key challenges were learning curve and compile times, but reliability gains outweighed costs.\n- **Tags:** `experience-report` `go-comparison` `production`\n\n### This Week in Rust #634\n- **Link:** https://this-week-in-rust.org/blog/2026/01/14/this-week-in-rust-634/\n- **Published:** 2026-01-14\n\n**Crate of the Week:** [axum](https://crates.io/crates/axum)\n> Selected for its elegant API design and strong ecosystem integration with tower middleware.\n\n**Notable Updates:**\n| Item | Summary | Link |\n|------|---------|------|\n| Rust 1.85 beta | New async closures stabilized | [‚Üí](https://blog.rust-lang.org) |\n| cargo-semver | Now detects more breaking changes | [‚Üí](https://github.com/...) |\n\n---\n\n## üì¢ Official Announcements\n\n### Rust Blog\n\n#### Announcing Rust 1.85.0\n- **Link:** https://blog.rust-lang.org/2026/01/15/Rust-1.85.0.html\n- **Published:** 2026-01-15\n- **Key Takeaway:** Async closures are now stable! This enables more ergonomic async code patterns. Also includes improved compile times for large projects.\n- **Action Required:** Yes - update with `rustup update stable`\n\n### Inside Rust Blog\n\n#### Lang Team Design Meeting: Edition 2027 Planning\n- **Link:** https://blog.rust-lang.org/inside-rust/2026/01/14/lang-meeting.html\n- **Published:** 2026-01-14\n- **Key Takeaway:** Early discussions on potential Edition 2027 features including keyword generics and effect systems.\n- **Relevant Teams:** lang, compiler\n\n---\n\n## üèõÔ∏è Rust Foundation\n\n### News & Announcements\n\n#### Google Joins as Platinum Member\n- **Link:** https://foundation.rust-lang.org/news/2026-01-13-google-platinum/\n- **Published:** 2026-01-13\n- **Key Takeaway:** $2M annual commitment will fund security audits and compiler infrastructure. Shows continued enterprise investment in Rust.\n\n### Upcoming Events\n\n| Date | Event | Location | Link | Why Attend |\n|------|-------|----------|------|------------|\n| Feb 1-3 | RustConf 2026 | Seattle, WA | [Register](https://rustconf.com) | Keynote on Rust in Linux kernel |\n| Feb 15 | Rust Meetup | Virtual | [Join](https://meetup.com/...) | Free, beginner-friendly |\n\n---\n\n## üî• Trending Topics\n\n1. **Async Ecosystem Maturation** - Multiple posts discussing Tokio 2.0 and async closures\n   - Related: [Tokio 2.0](https://reddit.com/...), [Async Patterns](https://reddit.com/...)\n\n2. **Rust in Production** - Growing number of experience reports from companies\n   - Related: [Go to Rust Migration](https://reddit.com/...)\n\n---\n\n## üí° AI Analysis\n\n**Key Themes This Period:**\n- Async Rust reaching new maturity level with Tokio 2.0 and language improvements\n- Increasing enterprise adoption evidenced by Foundation membership and experience reports\n\n**What to Watch:**\n- Edition 2027 discussions starting - may influence long-term project planning\n\n**Community Sentiment:** Positive - excitement about async improvements and ecosystem growth\n\n---\n\nüìä **Stats:** 18 posts | 523 comments | 5 sources\nüîÑ **Refresh:** `/rust-daily` | üíæ **Save:** `/rust-daily --save`\n```\n\n---\n\n## Tool Priority\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  1. agent-browser CLI  ‚Üê‚îÄ‚îÄ PRIMARY (always first) ‚îÇ\n‚îÇ  2. WebFetch           ‚Üê‚îÄ‚îÄ FALLBACK (static only) ‚îÇ\n‚îÇ  3. ‚ùå WebSearch       ‚Üê‚îÄ‚îÄ FORBIDDEN              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n| Site | agent-browser | WebFetch | WebSearch |\n|------|---------------|----------|-----------|\n| Reddit | ‚úÖ Required | ‚ùå Fails | ‚ùå Never |\n| TWIR | ‚úÖ First | ‚úÖ Fallback | ‚ùå Never |\n| Rust Blog | ‚úÖ First | ‚úÖ Fallback | ‚ùå Never |\n| Foundation | ‚úÖ First | ‚úÖ Fallback | ‚ùå Never |\n\n**DO NOT:**\n- Skip agent-browser and go directly to WebFetch\n- Use WebFetch for Reddit (will fail)\n- Use WebSearch for any news fetching\n\n---\n\n## Related Commands\n\n- `/rust-features [version]` - Rust version changelog\n- `/crate-info <crate>` - Crate information\n- `/sync-crate-skills` - Sync project dependencies\n",
        "commands/rust-features.md": "# /rust-features\n\nGet Rust version changelog and new features.\n\n## Usage\n\n```\n/rust-features [version]\n```\n\n## Parameters\n\n- `version` (optional): Rust version number (e.g., `1.83`, `1.82`). If omitted, fetches the latest stable version.\n\n## Examples\n\n```\n/rust-features           # Latest Rust features\n/rust-features 1.83      # Rust 1.83 features\n/rust-features 1.80      # Rust 1.80 features\n```\n\n## Workflow\n\n1. Use `search_actions(\"releases.rs\")` to get action ID\n2. Use `get_action_by_id()` to get page selectors\n3. Use `agent-browser` to open https://releases.rs and navigate to the version\n4. Extract changelog content\n5. Summarize key features for user\n",
        "commands/rust-review.md": "# /rust-review\n\nLightweight Rust code review using clippy.\n\n## Usage\n\n```\n/rust-review [path]\n```\n\n## Parameters\n\n- `path` (optional): Path to file or directory to review. Defaults to current directory.\n\n## What It Does\n\nËøêË°å `cargo clippy` ËøõË°å‰ª£Á†ÅÂÆ°Êü•Ôºö\n\n| Ê£ÄÊü•Á±ªÂûã | ËØ¥Êòé |\n|----------|------|\n| `clippy::correctness` | ÊòéÁ°ÆÈîôËØØÁöÑ‰ª£Á†Å |\n| `clippy::suspicious` | ÂèØÁñë‰ª£Á†Å |\n| `clippy::complexity` | Ëøá‰∫éÂ§çÊùÇÁöÑ‰ª£Á†Å |\n| `clippy::perf` | ÊÄßËÉΩÈóÆÈ¢ò |\n| `clippy::style` | È£éÊ†ºÈóÆÈ¢ò |\n\n## Workflow\n\n1. **ËØªÂèñ‰ª£Á†Å** - ÂàÜÊûêÁõÆÊ†áÊñá‰ª∂/ÁõÆÂΩï\n2. **ËøêË°å clippy** - `cargo clippy --message-format=json`\n3. **ÂàÜÊûêÁªìÊûú** - Êåâ‰∏•ÈáçÁ®ãÂ∫¶ÂàÜÁ±ª\n4. **Êèê‰æõ‰øÆÂ§çÂª∫ËÆÆ** - ‰ª£Á†ÅÁ§∫‰æã\n\n## Example Output\n\n```\nRust Code Review: src/lib.rs\n\nRunning clippy...\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nResults: 3 issues found\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nERROR (1):\n  src/lib.rs:42 [clippy::unwrap_used]\n    ‚Üí unwrap() called on Result\n    ‚Üí Fix: Use ? operator or handle error explicitly\n\nWARNING (2):\n  src/lib.rs:15 [clippy::needless_clone]\n    ‚Üí Clone is not needed here\n    ‚Üí Fix: Remove .clone()\n\n  src/lib.rs:28 [clippy::manual_map]\n    ‚Üí Use Option::map instead of match\n    ‚Üí Fix: x.map(|v| v + 1)\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n```\n\n## Clippy Configuration\n\nÈ°πÁõÆÂèØÈÄöËøá `clippy.toml` Êàñ `Cargo.toml` ÈÖçÁΩÆ clippyÔºö\n\n```toml\n# Cargo.toml\n[lints.clippy]\nunwrap_used = \"deny\"\nexpect_used = \"warn\"\n```\n\n## NOT Included\n\n‰ª•‰∏ãÊ£ÄÊü•**‰∏çÂú®** `/rust-review` ËåÉÂõ¥ÂÜÖÔºö\n\n| Ê£ÄÊü• | ÂéüÂõ† | Êõø‰ª£ÂëΩ‰ª§ |\n|------|------|----------|\n| `cargo fmt` | ÈÉ®ÂàÜÈ°πÁõÆ‰∏çÊîØÊåÅ | ÊâãÂä®ËøêË°å |\n| `miri` | Â§™ÈáçÔºåÈúÄË¶Å nightly | `/audit safety` |\n| `cargo audit` | ÂÆâÂÖ®ÂÆ°ËÆ°Âú∫ÊôØ | `/audit security` |\n| `lockbud` | ‰∏ìÁî®Âπ∂ÂèëÂÆ°ËÆ° | `/audit concurrency` |\n\n## Related Commands\n\n- `/audit` - ÈáçÈáèÁ∫ßÂÆâÂÖ®ÂÆ°ËÆ°Ôºà‰ΩøÁî® os-checkerÔºâ\n- `/unsafe-check` - ‰∏ìÊ≥® unsafe ‰ª£Á†ÅÊ£ÄÊü•\n- `/guideline` - Êü•ËØ¢ÁºñÁ†ÅËßÑËåÉ\n",
        "commands/skill-index.md": "# /skill-index\n\nQuery Rust skills by meta-question category or technical subcategory.\n\n## Usage\n\n```\n/skill-index <query>\n```\n\n## Parameters\n\n- `query` (required): Meta-question code (e.g., `m01`), tech category (e.g., `200`), or keyword\n\n## Examples\n\n```\n/skill-index m01             # Memory ownership skills\n/skill-index m07             # Concurrency skills\n/skill-index 200             # Web development (Axum)\n/skill-index 250             # Tokio runtime\n/skill-index ownership       # Search by keyword\n/skill-index tokio           # Search by crate name\n```\n\n## Query Format\n\n### By Meta-Question (XX)\n- `m01` - Memory Ownership & Lifetimes\n- `m02` - Resource Management Balance\n- `m03` - Mutability Boundaries\n- `m04` - Zero-Cost Abstractions\n- `m05` - Type-Driven Design\n- `m06` - Error Handling Philosophy\n- `m07` - Concurrency Correctness\n- ~~`m08`~~ - Merged into `unsafe-checker`\n- `m09` - Domain Constraint Mapping\n- `m10` - Performance Optimization Model\n- `m11` - Ecosystem Integration\n- `m12` - Domain Lifecycle\n- `m13` - Domain Error Patterns\n- `m14` - Mental Model Construction\n- `m15` - Error Pattern Recognition\n\n### By Tech Category (YYY)\n- `001-099` - Language Core\n- `100-199` - Standard Library\n- `200-299` - Web Development\n- `250-299` - Async/Concurrency\n- `400-499` - Data Processing\n- `500-599` - Systems Programming\n- `700-799` - Embedded Development\n- `800-899` - Cross-Language Integration\n- `850-899` - Toolchain & Build\n\n### By Domain Extension\n- `F*` - FinTech\n- `M*` - Machine Learning\n- `CN*` - Cloud Native\n- `IoT*` - Internet of Things\n\n## Output\n\nReturns matching skills with:\n- Category code and name\n- Related technical subcategories\n- Key concepts and keywords\n- Cognitive level range (L0-L4)\n",
        "commands/sync-crate-skills.md": "---\ndescription: Sync dynamic skills for Cargo.toml dependencies or local source\nargument-hint: [--force] [--from-source <path>] [crate_names...]\n---\n\n# Sync Crate Skills\n\nScan Cargo.toml and generate skills for dependencies that don't have local skills yet.\nSupports both remote crates (docs.rs) and local Rust source code.\n\nArguments: $ARGUMENTS\n- `--force`: Regenerate all skills even if they exist\n- `--from-source <path>`: Generate skills from local Rust source code\n- `crate_names`: Optional specific crates to sync (space-separated)\n\n---\n\n## Instructions\n\n### 0. Check for --from-source Flag\n\nIf `--from-source` flag is present:\n\n```\n/create-llms-from-source {path}\n    ‚Üì\n~/tmp/{timestamp}-{crate}-llms.txt\n    ‚Üì\n/create-skills-via-llms {crate} {llms_path}\n```\n\n**Workflow for local source:**\n1. Parse path from `--from-source <path>` argument\n2. Call `/create-llms-from-source {path}` to generate llms.txt\n3. Call `/create-skills-via-llms {crate_name} {llms_path} {version}` to create skills\n4. Skip remaining steps (no need to check dependencies)\n\n**Input type detection:**\n| Input | Action |\n|-------|--------|\n| `--from-source /path/to/project` | Use `/create-llms-from-source` |\n| `https://docs.rs/...` URL | Use `/create-llms-for-skills` |\n| Crate name (e.g., `tokio`) | Use actionbook or `/create-llms-for-skills` |\n\n---\n\n### 1. Find Cargo.toml Files\n\n```bash\n# Check for Cargo.toml in current directory\nif [ -f \"Cargo.toml\" ]; then\n    # Check if it's a workspace\n    grep -q \"\\[workspace\\]\" Cargo.toml\nfi\n```\n\n**Workspace handling:**\n- If `[workspace]` section exists, find `members = [...]`\n- Parse each member path\n- Collect Cargo.toml from each member directory\n\n### 2. Parse Dependencies\n\nFor each Cargo.toml, extract:\n- `[dependencies]` section\n- `[dev-dependencies]` section\n\nParse crate names and versions:\n```toml\ntokio = { version = \"1.40\", features = [\"full\"] }\nserde = \"1.0\"\n```\n\n### 3. Check Existing Skills\n\nFor each crate, check if skill exists:\n```bash\nls ~/.claude/skills/{crate_name}/SKILL.md\n```\n\nIf `--force` flag is set, skip this check.\n\n### 4. Generate Missing Skills\n\nFor each missing crate skill:\n\n#### 4a. Check actionbook for llms.txt\n\n```\nsearch_actions(\"{crate_name} llms.txt\")\n```\n\nIf found:\n```\nget_action_by_id(action_id)\n# Save content to ~/tmp/{crate_name}-llms.txt\n```\n\n#### 4b. Generate llms.txt if not in actionbook\n\nIf not found in actionbook:\n```\n/create-llms-for-skills https://docs.rs/{crate_name}/latest/{crate_name}/\n```\n\n#### 4c. Create skills from llms.txt\n\n```\n/create-skills-via-llms {crate_name} {llms_path} {version}\n```\n\n### 5. Report Results\n\nOutput summary:\n```\nSynced skills for:\n- tokio (1.40.0) - created\n- serde (1.0.215) - created\n- axum (0.7.9) - already exists, skipped\n\nSkills location: ~/.claude/skills/\n```\n\n---\n\n## Tool Priority\n\n1. **--from-source flag** - If present, use `/create-llms-from-source` for local source\n2. **actionbook MCP** - Check for pre-generated llms.txt first\n3. **/create-llms-for-skills** - Generate from docs.rs if not in actionbook\n   - Uses **agent-browser CLI** (preferred)\n   - Falls back to **WebFetch** if agent-browser unavailable\n4. **/create-llms-from-source** - Generate from local Rust source\n   - Uses **rustdoc JSON** (preferred)\n   - Falls back to **source code parsing** if rustdoc unavailable\n5. **/create-skills-via-llms** - Create skills from llms.txt\n\n**DO NOT use:**\n- Chrome MCP for documentation fetching\n- Direct Fetch without agent-browser attempt first\n\n---\n\n## Example Usage\n\n```bash\n# Sync all dependencies from current project\n/sync-crate-skills\n\n# Force regenerate all skills\n/sync-crate-skills --force\n\n# Sync specific crates only\n/sync-crate-skills tokio serde\n\n# Force regenerate specific crate\n/sync-crate-skills --force tokio\n\n# Generate skills from local Rust source code\n/sync-crate-skills --from-source /path/to/my-rust-project\n\n# Force regenerate skills from local source\n/sync-crate-skills --force --from-source /path/to/project\n```\n\n---\n\n## Output Location\n\nAll skills are created in: `~/.claude/skills/`\n\nThis is the local dynamic skills directory, not committed to repositories.\n",
        "commands/unsafe-check.md": "# /unsafe-check\n\nCheck a file for unsafe code issues and potential safety violations.\n\n## Usage\n\n```\n/unsafe-check [file]\n```\n\n## Parameters\n\n- `file` (optional): Path to the Rust file to check. If not provided, checks the current file or prompts for input.\n\n## Workflow\n\n1. **Read the file** to identify all `unsafe` blocks and `unsafe fn`\n2. **Load unsafe-checker skill** rules\n3. **Check each unsafe block** against relevant rules:\n   - SAFETY comment present? (safety-09)\n   - Pointer validity verified? (ptr-*)\n   - Panic safety considered? (safety-01)\n   - FFI rules followed? (ffi-*)\n4. **Report findings** with rule references and fix suggestions\n\n## Checks Performed\n\n### Safety Comments\n- Every `unsafe` block should have `// SAFETY:` comment\n- Comment should explain invariants, not just say \"this is safe\"\n\n### Pointer Operations\n- Null checks before dereference\n- Alignment verification\n- Bounds checking\n- No aliasing violations\n\n### FFI\n- Types have `#[repr(C)]`\n- Panics caught at boundary\n- String handling correct\n- Memory ownership clear\n\n### Send/Sync\n- Manual implementations are sound\n- No data races possible\n\n## Example Output\n\n```\nChecking: src/lib.rs\n\nFound 3 unsafe blocks:\n\n1. Line 42: unsafe { ptr.read() }\n   - [WARN] Missing SAFETY comment (safety-09)\n   - [WARN] No null check for ptr (ptr-01)\n   Suggestion: Add SAFETY comment and verify ptr is non-null\n\n2. Line 87: unsafe impl Send for MyType {}\n   - [WARN] Missing Safety docs (safety-10)\n   - [OK] Type analysis shows no !Send fields\n   Suggestion: Add /// # Safety documentation\n\n3. Line 123: extern \"C\" fn callback() { ... }\n   - [WARN] No catch_unwind (ffi-04)\n   Suggestion: Wrap body in std::panic::catch_unwind\n```\n\n## Related Commands\n\n- `/unsafe-review` - Interactive unsafe code review\n- `/guideline` - Query specific rules\n",
        "commands/unsafe-review.md": "# /unsafe-review\n\nInteractive review session for unsafe Rust code.\n\n## Usage\n\n```\n/unsafe-review\n```\n\n## Description\n\nStarts an interactive review session that guides you through reviewing unsafe code using the `unsafe-checker` skill checklists.\n\n## Workflow\n\n1. **Identify unsafe code** in the current file/selection\n2. **Load review checklist** from `unsafe-checker/checklists/review-unsafe.md`\n3. **Step through each check**:\n   - Ask clarifying questions\n   - Verify invariants\n   - Suggest improvements\n4. **Generate report** with findings and recommendations\n\n## Interactive Prompts\n\nThe review will ask questions like:\n\n```\nReviewing: unsafe { *ptr }\n\n1. Is this pointer guaranteed non-null?\n   - How is null prevented?\n   - Show me the null check\n\n2. Is the pointer properly aligned?\n   - What type is it pointing to?\n   - Where does the pointer come from?\n\n3. Is the pointed-to memory valid?\n   - Who allocated it?\n   - Is it initialized?\n   - How long is it valid?\n\n4. Could this panic?\n   - What happens if it panics here?\n   - Is cleanup needed?\n```\n\n## Checklist Categories\n\n### Surface-Level\n- SAFETY comments present and meaningful?\n- Safety documentation for unsafe fn?\n- Unsafe blocks minimized?\n\n### Memory Safety\n- Pointer validity (non-null, aligned, valid)\n- No aliasing violations\n- No use-after-free\n- No double-free\n- Bounds checking\n\n### Type Safety\n- Correct transmutes\n- Valid enum discriminants\n- Proper repr attributes\n\n### Concurrency\n- Send/Sync correctness\n- No data races\n- Proper synchronization\n\n### FFI\n- Type compatibility\n- Panic handling\n- Error handling\n- Memory ownership\n\n## Example Session\n\n```\n/unsafe-review\n\nScanning for unsafe code...\nFound 2 unsafe blocks and 1 unsafe fn.\n\n--- Review 1/3 ---\nLocation: src/buffer.rs:42\nCode: unsafe { slice::from_raw_parts(self.ptr, self.len) }\n\n[Checklist]\n[ ] SAFETY comment present?\n    > Yes: \"// SAFETY: ptr and len are validated in new()\"\n\n[ ] Pointer non-null?\n    > Checking... new() uses NonNull, so guaranteed\n\n[ ] Pointer aligned?\n    > Type is u8, alignment is 1, always aligned\n\n[ ] Length valid?\n    > len is set in new() and never changed\n\n[Result] PASS - All checks satisfied\n\n--- Review 2/3 ---\n...\n```\n\n## Output\n\nAfter review completes:\n\n```\n=== Unsafe Review Summary ===\n\nTotal unsafe items: 3\n- Passed: 2\n- Warnings: 1\n- Errors: 0\n\nWarnings:\n1. src/ffi.rs:87 - Missing catch_unwind in extern \"C\" fn\n\nRecommendations:\n- Add panic handling to FFI functions\n- Consider using NonNull instead of raw pointers\n```\n\n## Related Commands\n\n- `/unsafe-check [file]` - Quick automated check\n- `/guideline P.UNS.*` - Query unsafe rules\n",
        "commands/update-crate-skill.md": "---\ndescription: Update a specific crate skill to latest version\nargument-hint: <crate_name> [version]\n---\n\n# Update Crate Skill\n\nForce regenerate a crate skill with the latest documentation.\n\nArguments: $ARGUMENTS\n- `crate_name` (required): The crate to update\n- `version` (optional): Specific version to target\n\n---\n\n## Instructions\n\n### 1. Check Current Skill\n\n```bash\n# Check if skill exists\ncat ~/.claude/skills/{crate_name}*/SKILL.md | head -20\n```\n\nDisplay current version info if exists:\n```\nCurrent skill:\n- Crate: tokio\n- Version: 1.38.0\n- Last Updated: 2025-01-01\n```\n\n### 2. Get Latest Version\n\nIf version not provided, fetch latest from crates.io:\n```bash\ncargo search {crate_name} --limit 1\n```\n\nOr use crate-researcher agent to get latest version.\n\n### 3. Remove Old Skill\n\n```bash\nrm -rf ~/.claude/skills/{crate_name}*\n```\n\n### 4. Generate Fresh llms.txt\n\n```\n/create-llms-for-skills https://docs.rs/{crate_name}/{version}/{crate_name}/\n```\n\n### 5. Create Updated Skill\n\n```\n/create-skills-via-llms {crate_name} {llms_path} {version}\n```\n\n### 6. Report Results\n\n```\nUpdated skill:\n- Crate: tokio\n- Old Version: 1.38.0\n- New Version: 1.40.0\n- Location: ~/.claude/skills/tokio/\n```\n\n---\n\n## Example Usage\n\n```bash\n# Update tokio to latest version\n/update-crate-skill tokio\n\n# Update to specific version\n/update-crate-skill tokio 1.40.0\n\n# Update serde\n/update-crate-skill serde\n```\n\n---\n\n## When to Update\n\n- Crate has new major/minor release\n- API has changed significantly\n- Existing skill has incorrect information\n- Documentation has improved\n",
        "hooks/hooks.json": "{\n  \"hooks\": {\n    \"UserPromptSubmit\": [\n      {\n        \"matcher\": \"(?i)(rust|cargo|rustc|crate|Cargo\\\\.toml|\\\\.rs\\\\b|ownership|borrow|lifetime|async|await|trait|generic|unsafe|ffi|error|result|option|tokio|serde|axum|E0\\\\d{3,4}|value moved|cannot borrow|does not live long enough|mismatched types|not satisfied|Send|Sync|concurrency|ÊâÄÊúâÊùÉ|ÂÄüÁî®|ÁîüÂëΩÂë®Êúü|ÂºÇÊ≠•|Âπ∂Âèë|ÈîôËØØÂ§ÑÁêÜ|Á±ªÂûã|ÁºñËØë|ÁâàÊú¨|ÊÑèÂõæÂàÜÊûê|ÈóÆÈ¢òÂàÜÊûê|ËØ≠‰πâÂàÜÊûê|ÈóÆÈ¢ò|ÊÄé‰πàÁî®|ÊÄé‰πà|Â¶Ç‰Ωï|‰∏∫‰ªÄ‰πà|‰ªÄ‰πàÊòØ|Â∏ÆÊàëÂÜô|Â∏ÆÊàë|ÂÆûÁé∞|Ëß£Èáä|Âå∫Âà´|ÊúÄ‰Ω≥ÂÆûË∑µ|best practice|implement|explain|difference|how to|why|what is|ÂàõÂª∫.*È°πÁõÆ|ÂàõÂª∫.*skill|create.*skill|Âä®ÊÄÅ.*skill|fintech|trading|decimal|currency|ÈáëËûç|‰∫§Êòì|Ë¥ßÂ∏Å|ÊîØ‰ªò|kubernetes|k8s|docker|grpc|microservice|‰∫ëÂéüÁîü|ÂæÆÊúçÂä°|ÂÆπÂô®|web server|HTTP|REST|axum|actix|warp|API|‰∏≠Èó¥‰ª∂|Ë∑ØÁî±|CLI|command line|clap|terminal|ÂëΩ‰ª§Ë°å|ÁªàÁ´Ø|embedded|no_std|MCU|ARM|RISC-V|firmware|ÂµåÂÖ•Âºè|ÂçïÁâáÊú∫|Âõ∫‰ª∂|IoT|sensor|MQTT|Áâ©ËÅîÁΩë|‰º†ÊÑüÂô®|machine learning|ML|tensor|model|inference|Êú∫Âô®Â≠¶‰π†|Ê®°Âûã|DDD|domain model|È¢ÜÂüüÊ®°Âûã|performance|benchmark|ÊÄßËÉΩ‰ºòÂåñ|Âü∫ÂáÜÊµãËØï|RAII|Drop|ËµÑÊ∫ê|lifecycle|anti-pattern|ÂèçÊ®°Âºè|Â∏∏ËßÅÈîôËØØ|mental model|ÂøÉÊô∫Ê®°Âûã|Â≠¶‰π†|compare|vs|versus|ÂØπÊØî|ÊØîËæÉ)\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/.claude/hooks/rust-skill-eval-hook.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "skills/coding-guidelines/SKILL.md": "---\nname: coding-guidelines\ndescription: \"Use when asking about Rust code style or best practices. Keywords: naming, formatting, comment, clippy, rustfmt, lint, code style, best practice, P.NAM, G.FMT, code review, naming convention, variable naming, function naming, type naming, ÂëΩÂêçËßÑËåÉ, ‰ª£Á†ÅÈ£éÊ†º, Ê†ºÂºèÂåñ, ÊúÄ‰Ω≥ÂÆûË∑µ, ‰ª£Á†ÅÂÆ°Êü•, ÊÄé‰πàÂëΩÂêç\"\nsource: https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/\nuser-invocable: false\n---\n\n# Rust Coding Guidelines (50 Core Rules)\n\n## Naming (Rust-Specific)\n\n| Rule | Guideline |\n|------|-----------|\n| No `get_` prefix | `fn name()` not `fn get_name()` |\n| Iterator convention | `iter()` / `iter_mut()` / `into_iter()` |\n| Conversion naming | `as_` (cheap &), `to_` (expensive), `into_` (ownership) |\n| Static var prefix | `G_CONFIG` for `static`, no prefix for `const` |\n\n## Data Types\n\n| Rule | Guideline |\n|------|-----------|\n| Use newtypes | `struct Email(String)` for domain semantics |\n| Prefer slice patterns | `if let [first, .., last] = slice` |\n| Pre-allocate | `Vec::with_capacity()`, `String::with_capacity()` |\n| Avoid Vec abuse | Use arrays for fixed sizes |\n\n## Strings\n\n| Rule | Guideline |\n|------|-----------|\n| Prefer bytes | `s.bytes()` over `s.chars()` when ASCII |\n| Use `Cow<str>` | When might modify borrowed data |\n| Use `format!` | Over string concatenation with `+` |\n| Avoid nested iteration | `contains()` on string is O(n*m) |\n\n## Error Handling\n\n| Rule | Guideline |\n|------|-----------|\n| Use `?` propagation | Not `try!()` macro |\n| `expect()` over `unwrap()` | When value guaranteed |\n| Assertions for invariants | `assert!` at function entry |\n\n## Memory\n\n| Rule | Guideline |\n|------|-----------|\n| Meaningful lifetimes | `'src`, `'ctx` not just `'a` |\n| `try_borrow()` for RefCell | Avoid panic |\n| Shadowing for transformation | `let x = x.parse()?` |\n\n## Concurrency\n\n| Rule | Guideline |\n|------|-----------|\n| Identify lock ordering | Prevent deadlocks |\n| Atomics for primitives | Not Mutex for bool/usize |\n| Choose memory order carefully | Relaxed/Acquire/Release/SeqCst |\n\n## Async\n\n| Rule | Guideline |\n|------|-----------|\n| Sync for CPU-bound | Async is for I/O |\n| Don't hold locks across await | Use scoped guards |\n\n## Macros\n\n| Rule | Guideline |\n|------|-----------|\n| Avoid unless necessary | Prefer functions/generics |\n| Follow Rust syntax | Macro input should look like Rust |\n\n## Deprecated ‚Üí Better\n\n| Deprecated | Better | Since |\n|------------|--------|-------|\n| `lazy_static!` | `std::sync::OnceLock` | 1.70 |\n| `once_cell::Lazy` | `std::sync::LazyLock` | 1.80 |\n| `std::sync::mpsc` | `crossbeam::channel` | - |\n| `std::sync::Mutex` | `parking_lot::Mutex` | - |\n| `failure`/`error-chain` | `thiserror`/`anyhow` | - |\n| `try!()` | `?` operator | 2018 |\n\n## Quick Reference\n\n```\nNaming: snake_case (fn/var), CamelCase (type), SCREAMING_CASE (const)\nFormat: rustfmt (just use it)\nDocs: /// for public items, //! for module docs\nLint: #![warn(clippy::all)]\n```\n\nClaude knows Rust conventions well. These are the non-obvious Rust-specific rules.\n",
        "skills/coding-guidelines/clippy-lints/_index.md": "# Clippy Lint ‚Üí Rule Mapping\n\n| Clippy Lint | Category | Fix |\n|-------------|----------|-----|\n| `unwrap_used` | Error | Use `?` or `expect()` |\n| `needless_clone` | Perf | Use reference |\n| `await_holding_lock` | Async | Scope guard before await |\n| `linkedlist` | Perf | Use Vec/VecDeque |\n| `wildcard_imports` | Style | Explicit imports |\n| `missing_safety_doc` | Safety | Add `# Safety` doc |\n| `undocumented_unsafe_blocks` | Safety | Add `// SAFETY:` |\n| `transmute_ptr_to_ptr` | Safety | Use `pointer::cast()` |\n| `large_stack_arrays` | Mem | Use Vec or Box |\n| `too_many_arguments` | Design | Use struct params |\n\nFor unsafe-related lints ‚Üí see `unsafe-checker` skill.\n",
        "skills/coding-guidelines/index/rules-index.md": "# Complete Rules Reference\n\nFor the full 500+ rules, see:\n- Source: https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/\n\nCore rules are in `../SKILL.md`.\n",
        "skills/core-actionbook/SKILL.md": "---\nname: core-actionbook\n# Internal tool - no description to prevent auto-triggering\n# Used by: rust-learner agents for pre-computed selectors\n---\n\n# Actionbook\n\nPre-computed action manuals for browser automation. Agents receive structured page information instead of parsing entire HTML.\n\n## Workflow\n\n1. **search_actions** - Search by keyword, returns URL-based action IDs with content previews\n2. **get_action_by_id** - Get full action manual with page details, DOM structure, and element selectors\n3. **Execute** - Use returned selectors with your browser automation tool\n\n## MCP Tools\n\n- `search_actions` - Search by keyword. Returns: URL-based action IDs, content previews, relevance scores\n- `get_action_by_id` - Get full action details. Returns: action content, page element selectors (CSS/XPath), element types, allowed methods (click, type, extract), document metadata\n\n### Parameters\n\n**search_actions**:\n- `query` (required): Search keyword (e.g., \"airbnb search\", \"google login\")\n- `type`: `vector` | `fulltext` | `hybrid` (default)\n- `limit`: Max results (default: 5)\n- `sourceIds`: Filter by source IDs (comma-separated)\n- `minScore`: Minimum relevance score (0-1)\n\n**get_action_by_id**:\n- `id` (required): URL-based action ID (e.g., `example.com/page`)\n\n## Example Response\n\n```json\n{\n  \"title\": \"Airbnb Search\",\n  \"url\": \"www.airbnb.com/search\",\n  \"elements\": [\n    {\n      \"name\": \"location_input\",\n      \"selector\": \"input[data-testid='structured-search-input-field-query']\",\n      \"type\": \"textbox\",\n      \"methods\": [\"type\", \"fill\"]\n    }\n  ]\n}\n```\n",
        "skills/core-agent-browser/SKILL.md": "---\nname: core-agent-browser\n# Internal tool - no description to prevent auto-triggering\n# Used by: rust-learner, docs-researcher, crate-researcher agents\n---\n\n# Browser Automation with agent-browser\n\n## Priority Note\n\nFor fetching Rust/crate information, use this priority order:\n1. **rust-learner skill** - Orchestrates actionbook + browser-fetcher\n2. **actionbook MCP** - Pre-computed selectors for known sites\n3. **agent-browser CLI** - Direct browser automation (last resort)\n\nUse agent-browser directly only when:\n- actionbook has no pre-computed selectors for the target site\n- You need interactive browser testing/automation\n- You need screenshots or form filling\n\n## Quick start\n\n```bash\nagent-browser open <url>        # Navigate to page\nagent-browser snapshot -i       # Get interactive elements with refs\nagent-browser click @e1         # Click element by ref\nagent-browser fill @e2 \"text\"   # Fill input by ref\nagent-browser close             # Close browser\n```\n\n## Core workflow\n\n1. Navigate: `agent-browser open <url>`\n2. Snapshot: `agent-browser snapshot -i` (returns elements with refs like `@e1`, `@e2`)\n3. Interact using refs from the snapshot\n4. Re-snapshot after navigation or significant DOM changes\n\n## Commands\n\n### Navigation\n```bash\nagent-browser open <url>      # Navigate to URL\nagent-browser back            # Go back\nagent-browser forward         # Go forward\nagent-browser reload          # Reload page\nagent-browser close           # Close browser\n```\n\n### Snapshot (page analysis)\n```bash\nagent-browser snapshot        # Full accessibility tree\nagent-browser snapshot -i     # Interactive elements only (recommended)\nagent-browser snapshot -c     # Compact output\nagent-browser snapshot -d 3   # Limit depth to 3\n```\n\n### Interactions (use @refs from snapshot)\n```bash\nagent-browser click @e1           # Click\nagent-browser dblclick @e1        # Double-click\nagent-browser fill @e2 \"text\"     # Clear and type\nagent-browser type @e2 \"text\"     # Type without clearing\nagent-browser press Enter         # Press key\nagent-browser press Control+a     # Key combination\nagent-browser hover @e1           # Hover\nagent-browser check @e1           # Check checkbox\nagent-browser uncheck @e1         # Uncheck checkbox\nagent-browser select @e1 \"value\"  # Select dropdown\nagent-browser scroll down 500     # Scroll page\nagent-browser scrollintoview @e1  # Scroll element into view\n```\n\n### Get information\n```bash\nagent-browser get text @e1        # Get element text\nagent-browser get value @e1       # Get input value\nagent-browser get title           # Get page title\nagent-browser get url             # Get current URL\n```\n\n### Screenshots\n```bash\nagent-browser screenshot          # Screenshot to stdout\nagent-browser screenshot path.png # Save to file\nagent-browser screenshot --full   # Full page\n```\n\n### Wait\n```bash\nagent-browser wait @e1                     # Wait for element\nagent-browser wait 2000                    # Wait milliseconds\nagent-browser wait --text \"Success\"        # Wait for text\nagent-browser wait --load networkidle      # Wait for network idle\n```\n\n### Semantic locators (alternative to refs)\n```bash\nagent-browser find role button click --name \"Submit\"\nagent-browser find text \"Sign In\" click\nagent-browser find label \"Email\" fill \"user@test.com\"\n```\n\n## Example: Form submission\n\n```bash\nagent-browser open https://example.com/form\nagent-browser snapshot -i\n# Output shows: textbox \"Email\" [ref=e1], textbox \"Password\" [ref=e2], button \"Submit\" [ref=e3]\n\nagent-browser fill @e1 \"user@example.com\"\nagent-browser fill @e2 \"password123\"\nagent-browser click @e3\nagent-browser wait --load networkidle\nagent-browser snapshot -i  # Check result\n```\n",
        "skills/core-dynamic-skills/SKILL.md": "---\nname: core-dynamic-skills\n# Command-based tool - no description to prevent auto-triggering\n# Triggered by: /sync-crate-skills, /clean-crate-skills, /update-crate-skill\nargument-hint: \"[--force] | <crate_name>\"\ncontext: fork\nagent: general-purpose\n---\n\n# Dynamic Skills Manager\n\nOrchestrates on-demand generation of crate-specific skills based on project dependencies.\n\n## Concept\n\nDynamic skills are:\n- Generated locally at `~/.claude/skills/`\n- Based on Cargo.toml dependencies\n- Created using llms.txt from docs.rs\n- Versioned and updatable\n- Not committed to the rust-skills repository\n\n## Trigger Scenarios\n\n### Prompt-on-Open\n\nWhen entering a directory with Cargo.toml:\n1. Detect Cargo.toml (single or workspace)\n2. Parse dependencies list\n3. Check which crates are missing skills\n4. If missing: \"Found X dependencies without skills. Sync now?\"\n5. If confirmed: run `/sync-crate-skills`\n\n### Manual Commands\n\n- `/sync-crate-skills` - Sync all dependencies\n- `/clean-crate-skills [crate]` - Remove skills\n- `/update-crate-skill <crate>` - Update specific skill\n\n## Architecture\n\n```\nCargo.toml\n    ‚Üì\nParse dependencies\n    ‚Üì\nFor each crate:\n  ‚îú‚îÄ Check ~/.claude/skills/{crate}/\n  ‚îú‚îÄ If missing: Check actionbook for llms.txt\n  ‚îÇ     ‚îú‚îÄ Found: /create-skills-via-llms\n  ‚îÇ     ‚îî‚îÄ Not found: /create-llms-for-skills first\n  ‚îî‚îÄ Load skill\n```\n\n## Local Skills Directory\n\n```\n~/.claude/skills/\n‚îú‚îÄ‚îÄ tokio/\n‚îÇ   ‚îú‚îÄ‚îÄ SKILL.md\n‚îÇ   ‚îî‚îÄ‚îÄ references/\n‚îú‚îÄ‚îÄ serde/\n‚îÇ   ‚îú‚îÄ‚îÄ SKILL.md\n‚îÇ   ‚îî‚îÄ‚îÄ references/\n‚îî‚îÄ‚îÄ axum/\n    ‚îú‚îÄ‚îÄ SKILL.md\n    ‚îî‚îÄ‚îÄ references/\n```\n\n## Workflow Priority\n\n1. **actionbook MCP** - Check for pre-generated llms.txt\n2. **/create-llms-for-skills** - Generate llms.txt from docs.rs\n3. **/create-skills-via-llms** - Create skills from llms.txt\n\n## Workspace Support\n\nFor Cargo workspace projects:\n1. Parse root Cargo.toml for `[workspace] members`\n2. Collect all member Cargo.toml paths\n3. Aggregate all dependencies\n4. Deduplicate before skill generation\n\n## Related Commands\n\n- `/sync-crate-skills` - Main sync command\n- `/clean-crate-skills` - Cleanup command\n- `/update-crate-skill` - Update command\n- `/create-llms-for-skills` - Generate llms.txt\n- `/create-skills-via-llms` - Create skills from llms.txt\n",
        "skills/core-fix-skill-docs/SKILL.md": "---\nname: core-fix-skill-docs\n# Internal maintenance tool - no description to prevent auto-triggering\n# Triggered by: /fix-skill-docs command\nargument-hint: \"[crate_name] [--check-only]\"\ncontext: fork\nagent: general-purpose\n---\n\n# Fix Skill Documentation\n\nCheck and fix missing reference files in dynamic skills.\n\n## Usage\n\n```\n/fix-skill-docs [crate_name] [--check-only] [--remove-invalid]\n```\n\n**Arguments:**\n- `crate_name`: Specific crate to check (optional, defaults to all)\n- `--check-only`: Only report issues, don't fix\n- `--remove-invalid`: Remove invalid references instead of creating files\n\n## Instructions\n\n### 1. Scan Skills Directory\n\n```bash\n# If crate_name provided\nskill_dir=~/.claude/skills/{crate_name}\n\n# Otherwise scan all\nfor dir in ~/.claude/skills/*/; do\n    # Process each skill\ndone\n```\n\n### 2. Parse SKILL.md for References\n\nExtract referenced files from Documentation section:\n\n```markdown\n## Documentation\n- `./references/file1.md` - Description\n```\n\n### 3. Check File Existence\n\n```bash\nif [ ! -f \"{skill_dir}/references/{filename}\" ]; then\n    echo \"MISSING: {filename}\"\nfi\n```\n\n### 4. Report Status\n\n```\n=== {crate_name} ===\nSKILL.md: ‚úÖ\nreferences/:\n  - sync.md: ‚úÖ\n  - runtime.md: ‚ùå MISSING\n\nAction needed: 1 file missing\n```\n\n### 5. Fix Missing Files\n\n**--check-only**: Only report, don't fix.\n\n**--remove-invalid**: Update SKILL.md to remove invalid references.\n\n**Default**: Generate missing files using agent-browser:\n\n```bash\nagent-browser \"Navigate to docs.rs/{crate_name}/latest/{crate_name}/{module}/\nExtract documentation for {topic}. Save as markdown.\"\n```\n\n### 6. Update SKILL.md\n\nEnsure Documentation section matches actual files.\n\n## Tool Priority\n\n1. **agent-browser CLI** - Generate missing documentation\n2. **WebFetch** - Fallback if agent-browser unavailable\n3. **Edit SKILL.md** - Remove invalid references (--remove-invalid)\n\n## Example\n\n```bash\n# Check all skills\n/fix-skill-docs --check-only\n\n# Fix specific crate\n/fix-skill-docs tokio\n\n# Remove invalid references\n/fix-skill-docs tokio --remove-invalid\n```\n",
        "skills/domain-cli/SKILL.md": "---\nname: domain-cli\ndescription: \"Use when building CLI tools. Keywords: CLI, command line, terminal, clap, structopt, argument parsing, subcommand, interactive, TUI, ratatui, crossterm, indicatif, progress bar, colored output, shell completion, config file, environment variable, ÂëΩ‰ª§Ë°å, ÁªàÁ´ØÂ∫îÁî®, ÂèÇÊï∞Ëß£Êûê\"\nglobs: [\"**/Cargo.toml\"]\nuser-invocable: false\n---\n\n# CLI Domain\n\n> **Layer 3: Domain Constraints**\n\n## Domain Constraints ‚Üí Design Implications\n\n| Domain Rule | Design Constraint | Rust Implication |\n|-------------|-------------------|------------------|\n| User ergonomics | Clear help, errors | clap derive macros |\n| Config precedence | CLI > env > file | Layered config loading |\n| Exit codes | Non-zero on error | Proper Result handling |\n| Stdout/stderr | Data vs errors | eprintln! for errors |\n| Interruptible | Handle Ctrl+C | Signal handling |\n\n---\n\n## Critical Constraints\n\n### User Communication\n\n```\nRULE: Errors to stderr, data to stdout\nWHY: Pipeable output, scriptability\nRUST: eprintln! for errors, println! for data\n```\n\n### Configuration Priority\n\n```\nRULE: CLI args > env vars > config file > defaults\nWHY: User expectation, override capability\nRUST: Layered config with clap + figment/config\n```\n\n### Exit Codes\n\n```\nRULE: Return non-zero on any error\nWHY: Script integration, automation\nRUST: main() -> Result<(), Error> or explicit exit()\n```\n\n---\n\n## Trace Down ‚Üì\n\nFrom constraints to design (Layer 2):\n\n```\n\"Need argument parsing\"\n    ‚Üì m05-type-driven: Derive structs for args\n    ‚Üì clap: #[derive(Parser)]\n\n\"Need config layering\"\n    ‚Üì m09-domain: Config as domain object\n    ‚Üì figment/config: Layer sources\n\n\"Need progress display\"\n    ‚Üì m12-lifecycle: Progress bar as RAII\n    ‚Üì indicatif: ProgressBar\n```\n\n---\n\n## Key Crates\n\n| Purpose | Crate |\n|---------|-------|\n| Argument parsing | clap |\n| Interactive prompts | dialoguer |\n| Progress bars | indicatif |\n| Colored output | colored |\n| Terminal UI | ratatui |\n| Terminal control | crossterm |\n| Console utilities | console |\n\n## Design Patterns\n\n| Pattern | Purpose | Implementation |\n|---------|---------|----------------|\n| Args struct | Type-safe args | `#[derive(Parser)]` |\n| Subcommands | Command hierarchy | `#[derive(Subcommand)]` |\n| Config layers | Override precedence | CLI > env > file |\n| Progress | User feedback | `ProgressBar::new(len)` |\n\n## Code Pattern: CLI Structure\n\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(name = \"myapp\", about = \"My CLI tool\")]\nstruct Cli {\n    /// Enable verbose output\n    #[arg(short, long)]\n    verbose: bool,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Initialize a new project\n    Init { name: String },\n    /// Run the application\n    Run {\n        #[arg(short, long)]\n        port: Option<u16>,\n    },\n}\n\nfn main() -> anyhow::Result<()> {\n    let cli = Cli::parse();\n    match cli.command {\n        Commands::Init { name } => init_project(&name)?,\n        Commands::Run { port } => run_server(port.unwrap_or(8080))?,\n    }\n    Ok(())\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Domain Violation | Fix |\n|---------|-----------------|-----|\n| Errors to stdout | Breaks piping | eprintln! |\n| No help text | Poor UX | #[arg(help = \"...\")] |\n| Panic on error | Bad exit code | Result + proper handling |\n| No progress for long ops | User uncertainty | indicatif |\n\n---\n\n## Trace to Layer 1\n\n| Constraint | Layer 2 Pattern | Layer 1 Implementation |\n|------------|-----------------|------------------------|\n| Type-safe args | Derive macros | clap Parser |\n| Error handling | Result propagation | anyhow + exit codes |\n| User feedback | Progress RAII | indicatif ProgressBar |\n| Config precedence | Builder pattern | Layered sources |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Error handling | m06-error-handling |\n| Type-driven args | m05-type-driven |\n| Progress lifecycle | m12-lifecycle |\n| Async CLI | m07-concurrency |\n",
        "skills/domain-cloud-native/SKILL.md": "---\nname: domain-cloud-native\ndescription: \"Use when building cloud-native apps. Keywords: kubernetes, k8s, docker, container, grpc, tonic, microservice, service mesh, observability, tracing, metrics, health check, cloud, deployment, ‰∫ëÂéüÁîü, ÂæÆÊúçÂä°, ÂÆπÂô®\"\nuser-invocable: false\n---\n\n# Cloud-Native Domain\n\n> **Layer 3: Domain Constraints**\n\n## Domain Constraints ‚Üí Design Implications\n\n| Domain Rule | Design Constraint | Rust Implication |\n|-------------|-------------------|------------------|\n| 12-Factor | Config from env | Environment-based config |\n| Observability | Metrics + traces | tracing + opentelemetry |\n| Health checks | Liveness/readiness | Dedicated endpoints |\n| Graceful shutdown | Clean termination | Signal handling |\n| Horizontal scale | Stateless design | No local state |\n| Container-friendly | Small binaries | Release optimization |\n\n---\n\n## Critical Constraints\n\n### Stateless Design\n\n```\nRULE: No local persistent state\nWHY: Pods can be killed/rescheduled anytime\nRUST: External state (Redis, DB), no static mut\n```\n\n### Graceful Shutdown\n\n```\nRULE: Handle SIGTERM, drain connections\nWHY: Zero-downtime deployments\nRUST: tokio::signal + graceful shutdown\n```\n\n### Observability\n\n```\nRULE: Every request must be traceable\nWHY: Debugging distributed systems\nRUST: tracing spans, opentelemetry export\n```\n\n---\n\n## Trace Down ‚Üì\n\nFrom constraints to design (Layer 2):\n\n```\n\"Need distributed tracing\"\n    ‚Üì m12-lifecycle: Span lifecycle\n    ‚Üì tracing + opentelemetry\n\n\"Need graceful shutdown\"\n    ‚Üì m07-concurrency: Signal handling\n    ‚Üì m12-lifecycle: Connection draining\n\n\"Need health checks\"\n    ‚Üì domain-web: HTTP endpoints\n    ‚Üì m06-error-handling: Health status\n```\n\n---\n\n## Key Crates\n\n| Purpose | Crate |\n|---------|-------|\n| gRPC | tonic |\n| Kubernetes | kube, kube-runtime |\n| Docker | bollard |\n| Tracing | tracing, opentelemetry |\n| Metrics | prometheus, metrics |\n| Config | config, figment |\n| Health | HTTP endpoints |\n\n## Design Patterns\n\n| Pattern | Purpose | Implementation |\n|---------|---------|----------------|\n| gRPC services | Service mesh | tonic + tower |\n| K8s operators | Custom resources | kube-runtime Controller |\n| Observability | Debugging | tracing + OTEL |\n| Health checks | Orchestration | `/health`, `/ready` |\n| Config | 12-factor | Env vars + secrets |\n\n## Code Pattern: Graceful Shutdown\n\n```rust\nuse tokio::signal;\n\nasync fn run_server() -> anyhow::Result<()> {\n    let app = Router::new()\n        .route(\"/health\", get(health))\n        .route(\"/ready\", get(ready));\n\n    let addr = SocketAddr::from(([0, 0, 0, 0], 8080));\n\n    axum::Server::bind(&addr)\n        .serve(app.into_make_service())\n        .with_graceful_shutdown(shutdown_signal())\n        .await?;\n\n    Ok(())\n}\n\nasync fn shutdown_signal() {\n    signal::ctrl_c().await.expect(\"failed to listen for ctrl+c\");\n    tracing::info!(\"shutdown signal received\");\n}\n```\n\n## Health Check Pattern\n\n```rust\nasync fn health() -> StatusCode {\n    StatusCode::OK\n}\n\nasync fn ready(State(db): State<Arc<DbPool>>) -> StatusCode {\n    match db.ping().await {\n        Ok(_) => StatusCode::OK,\n        Err(_) => StatusCode::SERVICE_UNAVAILABLE,\n    }\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Domain Violation | Fix |\n|---------|-----------------|-----|\n| Local file state | Not stateless | External storage |\n| No SIGTERM handling | Hard kills | Graceful shutdown |\n| No tracing | Can't debug | tracing spans |\n| Static config | Not 12-factor | Env vars |\n\n---\n\n## Trace to Layer 1\n\n| Constraint | Layer 2 Pattern | Layer 1 Implementation |\n|------------|-----------------|------------------------|\n| Stateless | External state | Arc<Client> for external |\n| Graceful shutdown | Signal handling | tokio::signal |\n| Tracing | Span lifecycle | tracing + OTEL |\n| Health checks | HTTP endpoints | Dedicated routes |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Async patterns | m07-concurrency |\n| HTTP endpoints | domain-web |\n| Error handling | m13-domain-error |\n| Resource lifecycle | m12-lifecycle |\n",
        "skills/domain-embedded/SKILL.md": "---\nname: domain-embedded\ndescription: \"Use when developing embedded/no_std Rust. Keywords: embedded, no_std, microcontroller, MCU, ARM, RISC-V, bare metal, firmware, HAL, PAC, RTIC, embassy, interrupt, DMA, peripheral, GPIO, SPI, I2C, UART, embedded-hal, cortex-m, esp32, stm32, nrf, ÂµåÂÖ•Âºè, ÂçïÁâáÊú∫, Âõ∫‰ª∂, Ë£∏Êú∫\"\nglobs: [\"**/Cargo.toml\", \"**/.cargo/config.toml\"]\nuser-invocable: false\n---\n\n## Project Context (Auto-Injected)\n\n**Target configuration:**\n!`cat .cargo/config.toml 2>/dev/null || echo \"No .cargo/config.toml found\"`\n\n---\n\n# Embedded Domain\n\n> **Layer 3: Domain Constraints**\n\n## Domain Constraints ‚Üí Design Implications\n\n| Domain Rule | Design Constraint | Rust Implication |\n|-------------|-------------------|------------------|\n| No heap | Stack allocation | heapless, no Box/Vec |\n| No std | Core only | #![no_std] |\n| Real-time | Predictable timing | No dynamic alloc |\n| Resource limited | Minimal memory | Static buffers |\n| Hardware safety | Safe peripheral access | HAL + ownership |\n| Interrupt safe | No blocking in ISR | Atomic, critical sections |\n\n---\n\n## Critical Constraints\n\n### No Dynamic Allocation\n\n```\nRULE: Cannot use heap (no allocator)\nWHY: Deterministic memory, no OOM\nRUST: heapless::Vec<T, N>, arrays\n```\n\n### Interrupt Safety\n\n```\nRULE: Shared state must be interrupt-safe\nWHY: ISR can preempt at any time\nRUST: Mutex<RefCell<T>> + critical section\n```\n\n### Hardware Ownership\n\n```\nRULE: Peripherals must have clear ownership\nWHY: Prevent conflicting access\nRUST: HAL takes ownership, singletons\n```\n\n---\n\n## Trace Down ‚Üì\n\nFrom constraints to design (Layer 2):\n\n```\n\"Need no_std compatible data structures\"\n    ‚Üì m02-resource: heapless collections\n    ‚Üì Static sizing: heapless::Vec<T, N>\n\n\"Need interrupt-safe state\"\n    ‚Üì m03-mutability: Mutex<RefCell<Option<T>>>\n    ‚Üì m07-concurrency: Critical sections\n\n\"Need peripheral ownership\"\n    ‚Üì m01-ownership: Singleton pattern\n    ‚Üì m12-lifecycle: RAII for hardware\n```\n\n---\n\n## Layer Stack\n\n| Layer | Examples | Purpose |\n|-------|----------|---------|\n| PAC | stm32f4, esp32c3 | Register access |\n| HAL | stm32f4xx-hal | Hardware abstraction |\n| Framework | RTIC, Embassy | Concurrency |\n| Traits | embedded-hal | Portable drivers |\n\n## Framework Comparison\n\n| Framework | Style | Best For |\n|-----------|-------|----------|\n| RTIC | Priority-based | Interrupt-driven apps |\n| Embassy | Async | Complex state machines |\n| Bare metal | Manual | Simple apps |\n\n## Key Crates\n\n| Purpose | Crate |\n|---------|-------|\n| Runtime (ARM) | cortex-m-rt |\n| Panic handler | panic-halt, panic-probe |\n| Collections | heapless |\n| HAL traits | embedded-hal |\n| Logging | defmt |\n| Flash/debug | probe-run |\n\n## Design Patterns\n\n| Pattern | Purpose | Implementation |\n|---------|---------|----------------|\n| no_std setup | Bare metal | `#![no_std]` + `#![no_main]` |\n| Entry point | Startup | `#[entry]` or embassy |\n| Static state | ISR access | `Mutex<RefCell<Option<T>>>` |\n| Fixed buffers | No heap | `heapless::Vec<T, N>` |\n\n## Code Pattern: Static Peripheral\n\n```rust\n#![no_std]\n#![no_main]\n\nuse cortex_m::interrupt::{self, Mutex};\nuse core::cell::RefCell;\n\nstatic LED: Mutex<RefCell<Option<Led>>> = Mutex::new(RefCell::new(None));\n\n#[entry]\nfn main() -> ! {\n    let dp = pac::Peripherals::take().unwrap();\n    let led = Led::new(dp.GPIOA);\n\n    interrupt::free(|cs| {\n        LED.borrow(cs).replace(Some(led));\n    });\n\n    loop {\n        interrupt::free(|cs| {\n            if let Some(led) = LED.borrow(cs).borrow_mut().as_mut() {\n                led.toggle();\n            }\n        });\n    }\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Domain Violation | Fix |\n|---------|-----------------|-----|\n| Using Vec | Heap allocation | heapless::Vec |\n| No critical section | Race with ISR | Mutex + interrupt::free |\n| Blocking in ISR | Missed interrupts | Defer to main loop |\n| Unsafe peripheral | Hardware conflict | HAL ownership |\n\n---\n\n## Trace to Layer 1\n\n| Constraint | Layer 2 Pattern | Layer 1 Implementation |\n|------------|-----------------|------------------------|\n| No heap | Static collections | heapless::Vec<T, N> |\n| ISR safety | Critical sections | Mutex<RefCell<T>> |\n| Hardware ownership | Singleton | take().unwrap() |\n| no_std | Core-only | #![no_std], #![no_main] |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Static memory | m02-resource |\n| Interior mutability | m03-mutability |\n| Interrupt patterns | m07-concurrency |\n| Unsafe for hardware | unsafe-checker |\n",
        "skills/domain-fintech/SKILL.md": "---\nname: domain-fintech\ndescription: \"Use when building fintech apps. Keywords: fintech, trading, decimal, currency, financial, money, transaction, ledger, payment, exchange rate, precision, rounding, accounting, ÈáëËûç, ‰∫§ÊòìÁ≥ªÁªü, Ë¥ßÂ∏Å, ÊîØ‰ªò\"\nuser-invocable: false\n---\n\n# FinTech Domain\n\n> **Layer 3: Domain Constraints**\n\n## Domain Constraints ‚Üí Design Implications\n\n| Domain Rule | Design Constraint | Rust Implication |\n|-------------|-------------------|------------------|\n| Audit trail | Immutable records | Arc<T>, no mutation |\n| Precision | No floating point | rust_decimal |\n| Consistency | Transaction boundaries | Clear ownership |\n| Compliance | Complete logging | Structured tracing |\n| Reproducibility | Deterministic execution | No race conditions |\n\n---\n\n## Critical Constraints\n\n### Financial Precision\n\n```\nRULE: Never use f64 for money\nWHY: Floating point loses precision\nRUST: Use rust_decimal::Decimal\n```\n\n### Audit Requirements\n\n```\nRULE: All transactions must be immutable and traceable\nWHY: Regulatory compliance, dispute resolution\nRUST: Arc<T> for sharing, event sourcing pattern\n```\n\n### Consistency\n\n```\nRULE: Money can't disappear or appear\nWHY: Double-entry accounting principles\nRUST: Transaction types with validated totals\n```\n\n---\n\n## Trace Down ‚Üì\n\nFrom constraints to design (Layer 2):\n\n```\n\"Need immutable transaction records\"\n    ‚Üì m09-domain: Model as Value Objects\n    ‚Üì m01-ownership: Use Arc for shared immutable data\n\n\"Need precise decimal math\"\n    ‚Üì m05-type-driven: Newtype for Currency/Amount\n    ‚Üì rust_decimal: Use Decimal type\n\n\"Need transaction boundaries\"\n    ‚Üì m12-lifecycle: RAII for transaction scope\n    ‚Üì m09-domain: Aggregate boundaries\n```\n\n---\n\n## Key Crates\n\n| Purpose | Crate |\n|---------|-------|\n| Decimal math | rust_decimal |\n| Date/time | chrono, time |\n| UUID | uuid |\n| Serialization | serde |\n| Validation | validator |\n\n## Design Patterns\n\n| Pattern | Purpose | Implementation |\n|---------|---------|----------------|\n| Currency newtype | Type safety | `struct Amount(Decimal);` |\n| Transaction | Atomic operations | Event sourcing |\n| Audit log | Traceability | Structured logging with trace IDs |\n| Ledger | Double-entry | Debit/credit balance |\n\n## Code Pattern: Currency Type\n\n```rust\nuse rust_decimal::Decimal;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct Amount {\n    value: Decimal,\n    currency: Currency,\n}\n\nimpl Amount {\n    pub fn new(value: Decimal, currency: Currency) -> Self {\n        Self { value, currency }\n    }\n\n    pub fn add(&self, other: &Amount) -> Result<Amount, CurrencyMismatch> {\n        if self.currency != other.currency {\n            return Err(CurrencyMismatch);\n        }\n        Ok(Amount::new(self.value + other.value, self.currency))\n    }\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Domain Violation | Fix |\n|---------|-----------------|-----|\n| Using f64 | Precision loss | rust_decimal |\n| Mutable transaction | Audit trail broken | Immutable + events |\n| String for amount | No validation | Validated newtype |\n| Silent overflow | Money disappears | Checked arithmetic |\n\n---\n\n## Trace to Layer 1\n\n| Constraint | Layer 2 Pattern | Layer 1 Implementation |\n|------------|-----------------|------------------------|\n| Immutable records | Event sourcing | Arc<T>, Clone |\n| Transaction scope | Aggregate | Owned children |\n| Precision | Value Object | rust_decimal newtype |\n| Thread-safe sharing | Shared immutable | Arc (not Rc) |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Value Object design | m09-domain |\n| Ownership for immutable | m01-ownership |\n| Arc for sharing | m02-resource |\n| Error handling | m13-domain-error |\n",
        "skills/domain-iot/SKILL.md": "---\nname: domain-iot\ndescription: \"Use when building IoT apps. Keywords: IoT, Internet of Things, sensor, MQTT, device, edge computing, telemetry, actuator, smart home, gateway, protocol, Áâ©ËÅîÁΩë, ‰º†ÊÑüÂô®, ËæπÁºòËÆ°ÁÆó, Êô∫ËÉΩÂÆ∂Â±Ö\"\nuser-invocable: false\n---\n\n# IoT Domain\n\n> **Layer 3: Domain Constraints**\n\n## Domain Constraints ‚Üí Design Implications\n\n| Domain Rule | Design Constraint | Rust Implication |\n|-------------|-------------------|------------------|\n| Unreliable network | Offline-first | Local buffering |\n| Power constraints | Efficient code | Sleep modes, minimal alloc |\n| Resource limits | Small footprint | no_std where needed |\n| Security | Encrypted comms | TLS, signed firmware |\n| Reliability | Self-recovery | Watchdog, error handling |\n| OTA updates | Safe upgrades | Rollback capability |\n\n---\n\n## Critical Constraints\n\n### Network Unreliability\n\n```\nRULE: Network can fail at any time\nWHY: Wireless, remote locations\nRUST: Local queue, retry with backoff\n```\n\n### Power Management\n\n```\nRULE: Minimize power consumption\nWHY: Battery life, energy costs\nRUST: Sleep modes, efficient algorithms\n```\n\n### Device Security\n\n```\nRULE: All communication encrypted\nWHY: Physical access possible\nRUST: TLS, signed messages\n```\n\n---\n\n## Trace Down ‚Üì\n\nFrom constraints to design (Layer 2):\n\n```\n\"Need offline-first design\"\n    ‚Üì m12-lifecycle: Local buffer with persistence\n    ‚Üì m13-domain-error: Retry with backoff\n\n\"Need power efficiency\"\n    ‚Üì domain-embedded: no_std patterns\n    ‚Üì m10-performance: Minimal allocations\n\n\"Need reliable messaging\"\n    ‚Üì m07-concurrency: Async with timeout\n    ‚Üì MQTT: QoS levels\n```\n\n---\n\n## Environment Comparison\n\n| Environment | Stack | Crates |\n|-------------|-------|--------|\n| Linux gateway | tokio + std | rumqttc, reqwest |\n| MCU device | embassy + no_std | embedded-hal |\n| Hybrid | Split workloads | Both |\n\n## Key Crates\n\n| Purpose | Crate |\n|---------|-------|\n| MQTT (std) | rumqttc, paho-mqtt |\n| Embedded | embedded-hal, embassy |\n| Async (std) | tokio |\n| Async (no_std) | embassy |\n| Logging (no_std) | defmt |\n| Logging (std) | tracing |\n\n## Design Patterns\n\n| Pattern | Purpose | Implementation |\n|---------|---------|----------------|\n| Pub/Sub | Device comms | MQTT topics |\n| Edge compute | Local processing | Filter before upload |\n| OTA updates | Firmware upgrade | Signed + rollback |\n| Power mgmt | Battery life | Sleep + wake events |\n| Store & forward | Network reliability | Local queue |\n\n## Code Pattern: MQTT Client\n\n```rust\nuse rumqttc::{AsyncClient, MqttOptions, QoS};\n\nasync fn run_mqtt() -> anyhow::Result<()> {\n    let mut options = MqttOptions::new(\"device-1\", \"broker.example.com\", 1883);\n    options.set_keep_alive(Duration::from_secs(30));\n\n    let (client, mut eventloop) = AsyncClient::new(options, 10);\n\n    // Subscribe to commands\n    client.subscribe(\"devices/device-1/commands\", QoS::AtLeastOnce).await?;\n\n    // Publish telemetry\n    tokio::spawn(async move {\n        loop {\n            let data = read_sensor().await;\n            client.publish(\"devices/device-1/telemetry\", QoS::AtLeastOnce, false, data).await.ok();\n            tokio::time::sleep(Duration::from_secs(60)).await;\n        }\n    });\n\n    // Process events\n    loop {\n        match eventloop.poll().await {\n            Ok(event) => handle_event(event).await,\n            Err(e) => {\n                tracing::error!(\"MQTT error: {}\", e);\n                tokio::time::sleep(Duration::from_secs(5)).await;\n            }\n        }\n    }\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Domain Violation | Fix |\n|---------|-----------------|-----|\n| No retry logic | Lost data | Exponential backoff |\n| Always-on radio | Battery drain | Sleep between sends |\n| Unencrypted MQTT | Security risk | TLS |\n| No local buffer | Network outage = data loss | Persist locally |\n\n---\n\n## Trace to Layer 1\n\n| Constraint | Layer 2 Pattern | Layer 1 Implementation |\n|------------|-----------------|------------------------|\n| Offline-first | Store & forward | Local queue + flush |\n| Power efficiency | Sleep patterns | Timer-based wake |\n| Network reliability | Retry | tokio-retry, backoff |\n| Security | TLS | rustls, native-tls |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Embedded patterns | domain-embedded |\n| Async patterns | m07-concurrency |\n| Error recovery | m13-domain-error |\n| Performance | m10-performance |\n",
        "skills/domain-ml/SKILL.md": "---\nname: domain-ml\ndescription: \"Use when building ML/AI apps in Rust. Keywords: machine learning, ML, AI, tensor, model, inference, neural network, deep learning, training, prediction, ndarray, tch-rs, burn, candle, Êú∫Âô®Â≠¶‰π†, ‰∫∫Â∑•Êô∫ËÉΩ, Ê®°ÂûãÊé®ÁêÜ\"\nuser-invocable: false\n---\n\n# Machine Learning Domain\n\n> **Layer 3: Domain Constraints**\n\n## Domain Constraints ‚Üí Design Implications\n\n| Domain Rule | Design Constraint | Rust Implication |\n|-------------|-------------------|------------------|\n| Large data | Efficient memory | Zero-copy, streaming |\n| GPU acceleration | CUDA/Metal support | candle, tch-rs |\n| Model portability | Standard formats | ONNX |\n| Batch processing | Throughput over latency | Batched inference |\n| Numerical precision | Float handling | ndarray, careful f32/f64 |\n| Reproducibility | Deterministic | Seeded random, versioning |\n\n---\n\n## Critical Constraints\n\n### Memory Efficiency\n\n```\nRULE: Avoid copying large tensors\nWHY: Memory bandwidth is bottleneck\nRUST: References, views, in-place ops\n```\n\n### GPU Utilization\n\n```\nRULE: Batch operations for GPU efficiency\nWHY: GPU overhead per kernel launch\nRUST: Batch sizes, async data loading\n```\n\n### Model Portability\n\n```\nRULE: Use standard model formats\nWHY: Train in Python, deploy in Rust\nRUST: ONNX via tract or candle\n```\n\n---\n\n## Trace Down ‚Üì\n\nFrom constraints to design (Layer 2):\n\n```\n\"Need efficient data pipelines\"\n    ‚Üì m10-performance: Streaming, batching\n    ‚Üì polars: Lazy evaluation\n\n\"Need GPU inference\"\n    ‚Üì m07-concurrency: Async data loading\n    ‚Üì candle/tch-rs: CUDA backend\n\n\"Need model loading\"\n    ‚Üì m12-lifecycle: Lazy init, caching\n    ‚Üì tract: ONNX runtime\n```\n\n---\n\n## Use Case ‚Üí Framework\n\n| Use Case | Recommended | Why |\n|----------|-------------|-----|\n| Inference only | tract (ONNX) | Lightweight, portable |\n| Training + inference | candle, burn | Pure Rust, GPU |\n| PyTorch models | tch-rs | Direct bindings |\n| Data pipelines | polars | Fast, lazy eval |\n\n## Key Crates\n\n| Purpose | Crate |\n|---------|-------|\n| Tensors | ndarray |\n| ONNX inference | tract |\n| ML framework | candle, burn |\n| PyTorch bindings | tch-rs |\n| Data processing | polars |\n| Embeddings | fastembed |\n\n## Design Patterns\n\n| Pattern | Purpose | Implementation |\n|---------|---------|----------------|\n| Model loading | Once, reuse | `OnceLock<Model>` |\n| Batching | Throughput | Collect then process |\n| Streaming | Large data | Iterator-based |\n| GPU async | Parallelism | Data loading parallel to compute |\n\n## Code Pattern: Inference Server\n\n```rust\nuse std::sync::OnceLock;\nuse tract_onnx::prelude::*;\n\nstatic MODEL: OnceLock<SimplePlan<TypedFact, Box<dyn TypedOp>, Graph<TypedFact, Box<dyn TypedOp>>>> = OnceLock::new();\n\nfn get_model() -> &'static SimplePlan<...> {\n    MODEL.get_or_init(|| {\n        tract_onnx::onnx()\n            .model_for_path(\"model.onnx\")\n            .unwrap()\n            .into_optimized()\n            .unwrap()\n            .into_runnable()\n            .unwrap()\n    })\n}\n\nasync fn predict(input: Vec<f32>) -> anyhow::Result<Vec<f32>> {\n    let model = get_model();\n    let input = tract_ndarray::arr1(&input).into_shape((1, input.len()))?;\n    let result = model.run(tvec!(input.into()))?;\n    Ok(result[0].to_array_view::<f32>()?.iter().copied().collect())\n}\n```\n\n## Code Pattern: Batched Inference\n\n```rust\nasync fn batch_predict(inputs: Vec<Vec<f32>>, batch_size: usize) -> Vec<Vec<f32>> {\n    let mut results = Vec::with_capacity(inputs.len());\n\n    for batch in inputs.chunks(batch_size) {\n        // Stack inputs into batch tensor\n        let batch_tensor = stack_inputs(batch);\n\n        // Run inference on batch\n        let batch_output = model.run(batch_tensor).await;\n\n        // Unstack results\n        results.extend(unstack_outputs(batch_output));\n    }\n\n    results\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Domain Violation | Fix |\n|---------|-----------------|-----|\n| Clone tensors | Memory waste | Use views |\n| Single inference | GPU underutilized | Batch processing |\n| Load model per request | Slow | Singleton pattern |\n| Sync data loading | GPU idle | Async pipeline |\n\n---\n\n## Trace to Layer 1\n\n| Constraint | Layer 2 Pattern | Layer 1 Implementation |\n|------------|-----------------|------------------------|\n| Memory efficiency | Zero-copy | ndarray views |\n| Model singleton | Lazy init | OnceLock<Model> |\n| Batch processing | Chunked iteration | chunks() + parallel |\n| GPU async | Concurrent loading | tokio::spawn + GPU |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Performance | m10-performance |\n| Lazy initialization | m12-lifecycle |\n| Async patterns | m07-concurrency |\n| Memory efficiency | m01-ownership |\n",
        "skills/domain-web/SKILL.md": "---\nname: domain-web\ndescription: \"Use when building web services. Keywords: web server, HTTP, REST API, GraphQL, WebSocket, axum, actix, warp, rocket, tower, hyper, reqwest, middleware, router, handler, extractor, state management, authentication, authorization, JWT, session, cookie, CORS, rate limiting, web ÂºÄÂèë, HTTP ÊúçÂä°, API ËÆæËÆ°, ‰∏≠Èó¥‰ª∂, Ë∑ØÁî±\"\nglobs: [\"**/Cargo.toml\"]\nuser-invocable: false\n---\n\n# Web Domain\n\n> **Layer 3: Domain Constraints**\n\n## Domain Constraints ‚Üí Design Implications\n\n| Domain Rule | Design Constraint | Rust Implication |\n|-------------|-------------------|------------------|\n| Stateless HTTP | No request-local globals | State in extractors |\n| Concurrency | Handle many connections | Async, Send + Sync |\n| Latency SLA | Fast response | Efficient ownership |\n| Security | Input validation | Type-safe extractors |\n| Observability | Request tracing | tracing + tower layers |\n\n---\n\n## Critical Constraints\n\n### Async by Default\n\n```\nRULE: Web handlers must not block\nWHY: Block one task = block many requests\nRUST: async/await, spawn_blocking for CPU work\n```\n\n### State Management\n\n```\nRULE: Shared state must be thread-safe\nWHY: Handlers run on any thread\nRUST: Arc<T>, Arc<RwLock<T>> for mutable\n```\n\n### Request Lifecycle\n\n```\nRULE: Resources live only for request duration\nWHY: Memory management, no leaks\nRUST: Extractors, proper ownership\n```\n\n---\n\n## Trace Down ‚Üì\n\nFrom constraints to design (Layer 2):\n\n```\n\"Need shared application state\"\n    ‚Üì m07-concurrency: Use Arc for thread-safe sharing\n    ‚Üì m02-resource: Arc<RwLock<T>> for mutable state\n\n\"Need request validation\"\n    ‚Üì m05-type-driven: Validated extractors\n    ‚Üì m06-error-handling: IntoResponse for errors\n\n\"Need middleware stack\"\n    ‚Üì m12-lifecycle: Tower layers\n    ‚Üì m04-zero-cost: Trait-based composition\n```\n\n---\n\n## Framework Comparison\n\n| Framework | Style | Best For |\n|-----------|-------|----------|\n| axum | Functional, tower | Modern APIs |\n| actix-web | Actor-based | High performance |\n| warp | Filter composition | Composable APIs |\n| rocket | Macro-driven | Rapid development |\n\n## Key Crates\n\n| Purpose | Crate |\n|---------|-------|\n| HTTP server | axum, actix-web |\n| HTTP client | reqwest |\n| JSON | serde_json |\n| Auth/JWT | jsonwebtoken |\n| Session | tower-sessions |\n| Database | sqlx, diesel |\n| Middleware | tower |\n\n## Design Patterns\n\n| Pattern | Purpose | Implementation |\n|---------|---------|----------------|\n| Extractors | Request parsing | `State(db)`, `Json(payload)` |\n| Error response | Unified errors | `impl IntoResponse` |\n| Middleware | Cross-cutting | Tower layers |\n| Shared state | App config | `Arc<AppState>` |\n\n## Code Pattern: Axum Handler\n\n```rust\nasync fn handler(\n    State(db): State<Arc<DbPool>>,\n    Json(payload): Json<CreateUser>,\n) -> Result<Json<User>, AppError> {\n    let user = db.create_user(&payload).await?;\n    Ok(Json(user))\n}\n\n// Error handling\nimpl IntoResponse for AppError {\n    fn into_response(self) -> Response {\n        let (status, message) = match self {\n            Self::NotFound => (StatusCode::NOT_FOUND, \"Not found\"),\n            Self::Internal(_) => (StatusCode::INTERNAL_SERVER_ERROR, \"Internal error\"),\n        };\n        (status, Json(json!({\"error\": message}))).into_response()\n    }\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Domain Violation | Fix |\n|---------|-----------------|-----|\n| Blocking in handler | Latency spike | spawn_blocking |\n| Rc in state | Not Send + Sync | Use Arc |\n| No validation | Security risk | Type-safe extractors |\n| No error response | Bad UX | IntoResponse impl |\n\n---\n\n## Trace to Layer 1\n\n| Constraint | Layer 2 Pattern | Layer 1 Implementation |\n|------------|-----------------|------------------------|\n| Async handlers | Async/await | tokio runtime |\n| Thread-safe state | Shared state | Arc<T>, Arc<RwLock<T>> |\n| Request lifecycle | Extractors | Ownership via From<Request> |\n| Middleware | Tower layers | Trait-based composition |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Async patterns | m07-concurrency |\n| State management | m02-resource |\n| Error handling | m06-error-handling |\n| Middleware design | m12-lifecycle |\n",
        "skills/m01-ownership/SKILL.md": "---\nname: m01-ownership\ndescription: \"CRITICAL: Use for ownership/borrow/lifetime issues. Triggers: E0382, E0597, E0506, E0507, E0515, E0716, E0106, value moved, borrowed value does not live long enough, cannot move out of, use of moved value, ownership, borrow, lifetime, 'a, 'static, move, clone, Copy, ÊâÄÊúâÊùÉ, ÂÄüÁî®, ÁîüÂëΩÂë®Êúü\"\nuser-invocable: false\n---\n\n# Ownership & Lifetimes\n\n> **Layer 1: Language Mechanics**\n\n## Core Question\n\n**Who should own this data, and for how long?**\n\nBefore fixing ownership errors, understand the data's role:\n- Is it shared or exclusive?\n- Is it short-lived or long-lived?\n- Is it transformed or just read?\n\n---\n\n## Error ‚Üí Design Question\n\n| Error | Don't Just Say | Ask Instead |\n|-------|----------------|-------------|\n| E0382 | \"Clone it\" | Who should own this data? |\n| E0597 | \"Extend lifetime\" | Is the scope boundary correct? |\n| E0506 | \"End borrow first\" | Should mutation happen elsewhere? |\n| E0507 | \"Clone before move\" | Why are we moving from a reference? |\n| E0515 | \"Return owned\" | Should caller own the data? |\n| E0716 | \"Bind to variable\" | Why is this temporary? |\n| E0106 | \"Add 'a\" | What is the actual lifetime relationship? |\n\n---\n\n## Thinking Prompt\n\nBefore fixing an ownership error, ask:\n\n1. **What is this data's domain role?**\n   - Entity (unique identity) ‚Üí owned\n   - Value Object (interchangeable) ‚Üí clone/copy OK\n   - Temporary (computation result) ‚Üí maybe restructure\n\n2. **Is the ownership design intentional?**\n   - By design ‚Üí work within constraints\n   - Accidental ‚Üí consider redesign\n\n3. **Fix symptom or redesign?**\n   - If Strike 3 (3rd attempt) ‚Üí escalate to Layer 2\n\n---\n\n## Trace Up ‚Üë\n\nWhen errors persist, trace to design layer:\n\n```\nE0382 (moved value)\n    ‚Üë Ask: What design choice led to this ownership pattern?\n    ‚Üë Check: m09-domain (is this Entity or Value Object?)\n    ‚Üë Check: domain-* (what constraints apply?)\n```\n\n| Persistent Error | Trace To | Question |\n|-----------------|----------|----------|\n| E0382 repeated | m02-resource | Should use Arc/Rc for sharing? |\n| E0597 repeated | m09-domain | Is scope boundary at right place? |\n| E0506/E0507 | m03-mutability | Should use interior mutability? |\n\n---\n\n## Trace Down ‚Üì\n\nFrom design decisions to implementation:\n\n```\n\"Data needs to be shared immutably\"\n    ‚Üì Use: Arc<T> (multi-thread) or Rc<T> (single-thread)\n\n\"Data needs exclusive ownership\"\n    ‚Üì Use: move semantics, take ownership\n\n\"Data is read-only view\"\n    ‚Üì Use: &T (immutable borrow)\n```\n\n---\n\n## Quick Reference\n\n| Pattern | Ownership | Cost | Use When |\n|---------|-----------|------|----------|\n| Move | Transfer | Zero | Caller doesn't need data |\n| `&T` | Borrow | Zero | Read-only access |\n| `&mut T` | Exclusive borrow | Zero | Need to modify |\n| `clone()` | Duplicate | Alloc + copy | Actually need a copy |\n| `Rc<T>` | Shared (single) | Ref count | Single-thread sharing |\n| `Arc<T>` | Shared (multi) | Atomic ref count | Multi-thread sharing |\n| `Cow<T>` | Clone-on-write | Alloc if mutated | Might modify |\n\n## Error Code Reference\n\n| Error | Cause | Quick Fix |\n|-------|-------|-----------|\n| E0382 | Value moved | Clone, reference, or redesign ownership |\n| E0597 | Reference outlives owner | Extend owner scope or restructure |\n| E0506 | Assign while borrowed | End borrow before mutation |\n| E0507 | Move out of borrowed | Clone or use reference |\n| E0515 | Return local reference | Return owned value |\n| E0716 | Temporary dropped | Bind to variable |\n| E0106 | Missing lifetime | Add `'a` annotation |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| `.clone()` everywhere | Hides design issues | Design ownership properly |\n| Fight borrow checker | Increases complexity | Work with the compiler |\n| `'static` for everything | Restricts flexibility | Use appropriate lifetimes |\n| Leak with `Box::leak` | Memory leak | Proper lifetime design |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Need smart pointers | m02-resource |\n| Need interior mutability | m03-mutability |\n| Data is domain entity | m09-domain |\n| Learning ownership concepts | m14-mental-model |\n",
        "skills/m01-ownership/comparison.md": "# Ownership: Comparison with Other Languages\n\n## Rust vs C++\n\n### Memory Management\n\n| Aspect | Rust | C++ |\n|--------|------|-----|\n| Default | Move semantics | Copy semantics (pre-C++11) |\n| Move | `let b = a;` (a invalidated) | `auto b = std::move(a);` (a valid but unspecified) |\n| Copy | `let b = a.clone();` | `auto b = a;` |\n| Safety | Compile-time enforcement | Runtime responsibility |\n\n### Rust Move vs C++ Move\n\n```rust\n// Rust: after move, 'a' is INVALID\nlet a = String::from(\"hello\");\nlet b = a;  // a moved\n// println!(\"{}\", a);  // COMPILE ERROR\n\n// Equivalent in C++:\n// std::string a = \"hello\";\n// std::string b = std::move(a);\n// std::cout << a;  // UNDEFINED (compiles but buggy)\n```\n\n### Smart Pointers\n\n| Rust | C++ | Purpose |\n|------|-----|---------|\n| `Box<T>` | `std::unique_ptr<T>` | Unique ownership |\n| `Rc<T>` | `std::shared_ptr<T>` | Shared ownership |\n| `Arc<T>` | `std::shared_ptr<T>` + atomic | Thread-safe shared |\n| `RefCell<T>` | (manual runtime checks) | Interior mutability |\n\n---\n\n## Rust vs Go\n\n### Memory Model\n\n| Aspect | Rust | Go |\n|--------|------|-----|\n| Memory | Stack + heap, explicit | GC manages all |\n| Ownership | Enforced at compile-time | None (GC handles) |\n| Null | `Option<T>` | `nil` for pointers |\n| Concurrency | `Send`/`Sync` traits | Channels (less strict) |\n\n### Sharing Data\n\n```rust\n// Rust: explicit about sharing\nuse std::sync::Arc;\nlet data = Arc::new(vec![1, 2, 3]);\nlet data_clone = Arc::clone(&data);\nstd::thread::spawn(move || {\n    println!(\"{:?}\", data_clone);\n});\n\n// Go: implicit sharing\n// data := []int{1, 2, 3}\n// go func() {\n//     fmt.Println(data)  // potential race condition\n// }()\n```\n\n### Why No GC in Rust\n\n1. **Deterministic destruction**: Resources freed exactly when scope ends\n2. **Zero-cost**: No GC pauses or overhead\n3. **Embeddable**: Works in OS kernels, embedded systems\n4. **Predictable latency**: Critical for real-time systems\n\n---\n\n## Rust vs Java/C#\n\n### Reference Semantics\n\n| Aspect | Rust | Java/C# |\n|--------|------|---------|\n| Objects | Owned by default | Reference by default |\n| Null | `Option<T>` | `null` (nullable) |\n| Immutability | Default | Must use `final`/`readonly` |\n| Copy | Explicit `.clone()` | Reference copy (shallow) |\n\n### Comparison\n\n```rust\n// Rust: clear ownership\nfn process(data: Vec<i32>) {  // takes ownership\n    // data is ours, will be freed at end\n}\n\nlet numbers = vec![1, 2, 3];\nprocess(numbers);\n// numbers is invalid here\n\n// Java: ambiguous ownership\n// void process(List<Integer> data) {\n//     // Who owns data? Caller? Callee? Both?\n//     // Can caller still use it?\n// }\n```\n\n---\n\n## Rust vs Python\n\n### Memory Model\n\n| Aspect | Rust | Python |\n|--------|------|--------|\n| Typing | Static, compile-time | Dynamic, runtime |\n| Memory | Ownership-based | Reference counting + GC |\n| Mutability | Default immutable | Default mutable |\n| Performance | Native, zero-cost | Interpreted, higher overhead |\n\n### Common Pattern Translation\n\n```rust\n// Rust: borrowing iteration\nlet items = vec![\"a\", \"b\", \"c\"];\nfor item in &items {\n    println!(\"{}\", item);\n}\n// items still usable\n\n// Python: iteration doesn't consume\n// items = [\"a\", \"b\", \"c\"]\n// for item in items:\n//     print(item)\n// items still usable (different reason - ref counting)\n```\n\n---\n\n## Unique Rust Concepts\n\n### Concepts Other Languages Lack\n\n1. **Borrow Checker**: No other mainstream language has compile-time borrow checking\n2. **Lifetimes**: Explicit annotation of reference validity\n3. **Move by Default**: Values move, not copy\n4. **No Null**: `Option<T>` instead of null pointers\n5. **Affine Types**: Values can be used at most once\n\n### Learning Curve Areas\n\n| Concept | Coming From | Key Insight |\n|---------|-------------|-------------|\n| Ownership | GC languages | Think about who \"owns\" data |\n| Borrowing | C/C++ | Like references but checked |\n| Lifetimes | Any | Explicit scope of validity |\n| Move | C++ | Move is default, not copy |\n\n---\n\n## Mental Model Shifts\n\n### From GC Languages (Java, Go, Python)\n\n```\nBefore: \"Memory just works, GC handles it\"\nAfter:  \"I explicitly decide who owns data and when it's freed\"\n```\n\nKey shifts:\n- Think about ownership at design time\n- Returning references requires lifetime thinking\n- No more `null` - use `Option<T>`\n\n### From C/C++\n\n```\nBefore: \"I manually manage memory and hope I get it right\"\nAfter:  \"Compiler enforces correctness, I fight the borrow checker\"\n```\n\nKey shifts:\n- Trust the compiler's errors\n- Move is the default (unlike C++ copy)\n- Smart pointers are idiomatic, not overhead\n\n### From Functional Languages (Haskell, ML)\n\n```\nBefore: \"Everything is immutable, copying is fine\"\nAfter:  \"Mutability is explicit, ownership prevents aliasing\"\n```\n\nKey shifts:\n- Mutability is safe because of ownership rules\n- No persistent data structures needed (usually)\n- Performance characteristics are explicit\n\n---\n\n## Performance Trade-offs\n\n| Language | Memory Overhead | Latency | Throughput |\n|----------|-----------------|---------|------------|\n| Rust | Minimal (no GC) | Predictable | Excellent |\n| C++ | Minimal | Predictable | Excellent |\n| Go | GC overhead | GC pauses | Good |\n| Java | GC overhead | GC pauses | Good |\n| Python | High (ref counting + GC) | Variable | Lower |\n\n### When Rust Ownership Wins\n\n1. **Real-time systems**: No GC pauses\n2. **Embedded**: No runtime overhead\n3. **High-performance**: Zero-cost abstractions\n4. **Concurrent**: Data races prevented at compile time\n\n### When GC Might Be Preferable\n\n1. **Rapid prototyping**: Less mental overhead\n2. **Complex object graphs**: Cycles are tricky in Rust\n3. **GUI applications**: Object lifetimes are dynamic\n4. **Small programs**: Overhead doesn't matter\n",
        "skills/m01-ownership/examples/best-practices.md": "# Ownership Best Practices\n\n## API Design Patterns\n\n### 1. Prefer Borrowing Over Ownership\n\n```rust\n// BAD: takes ownership unnecessarily\nfn print_name(name: String) {\n    println!(\"Name: {}\", name);\n}\n\n// GOOD: borrows instead\nfn print_name(name: &str) {\n    println!(\"Name: {}\", name);\n}\n\n// Caller benefits:\nlet name = String::from(\"Alice\");\nprint_name(&name);  // can reuse name\nprint_name(&name);  // still valid\n```\n\n### 2. Return Owned Values from Constructors\n\n```rust\n// GOOD: return owned value\nimpl User {\n    fn new(name: &str) -> Self {\n        User {\n            name: name.to_string(),\n        }\n    }\n}\n\n// GOOD: accept Into<String> for flexibility\nimpl User {\n    fn new(name: impl Into<String>) -> Self {\n        User {\n            name: name.into(),\n        }\n    }\n}\n\n// Usage:\nlet u1 = User::new(\"Alice\");        // &str\nlet u2 = User::new(String::from(\"Bob\"));  // String\n```\n\n### 3. Use AsRef for Generic Borrowing\n\n```rust\n// GOOD: accepts both &str and String\nfn process<S: AsRef<str>>(input: S) {\n    let s = input.as_ref();\n    println!(\"{}\", s);\n}\n\nprocess(\"literal\");           // &str\nprocess(String::from(\"owned\")); // String\nprocess(&String::from(\"ref\")); // &String\n```\n\n### 4. Cow for Clone-on-Write\n\n```rust\nuse std::borrow::Cow;\n\n// Return borrowed when possible, owned when needed\nfn maybe_modify(s: &str, uppercase: bool) -> Cow<'_, str> {\n    if uppercase {\n        Cow::Owned(s.to_uppercase())  // allocates\n    } else {\n        Cow::Borrowed(s)  // zero-cost\n    }\n}\n\nlet input = \"hello\";\nlet result = maybe_modify(input, false);\n// result is borrowed, no allocation\n```\n\n---\n\n## Struct Design Patterns\n\n### 1. Owned Fields vs References\n\n```rust\n// Use owned fields for most cases\nstruct User {\n    name: String,\n    email: String,\n}\n\n// Use references only when lifetime is clear\nstruct UserView<'a> {\n    name: &'a str,\n    email: &'a str,\n}\n\n// Pattern: owned data + view for efficiency\nimpl User {\n    fn view(&self) -> UserView<'_> {\n        UserView {\n            name: &self.name,\n            email: &self.email,\n        }\n    }\n}\n```\n\n### 2. Builder Pattern with Ownership\n\n```rust\n#[derive(Default)]\nstruct RequestBuilder {\n    url: Option<String>,\n    method: Option<String>,\n    body: Option<Vec<u8>>,\n}\n\nimpl RequestBuilder {\n    fn new() -> Self {\n        Self::default()\n    }\n\n    // Take self by value for chaining\n    fn url(mut self, url: impl Into<String>) -> Self {\n        self.url = Some(url.into());\n        self\n    }\n\n    fn method(mut self, method: impl Into<String>) -> Self {\n        self.method = Some(method.into());\n        self\n    }\n\n    fn build(self) -> Result<Request, Error> {\n        Ok(Request {\n            url: self.url.ok_or(Error::MissingUrl)?,\n            method: self.method.unwrap_or_else(|| \"GET\".to_string()),\n            body: self.body.unwrap_or_default(),\n        })\n    }\n}\n\n// Usage:\nlet req = RequestBuilder::new()\n    .url(\"https://example.com\")\n    .method(\"POST\")\n    .build()?;\n```\n\n### 3. Interior Mutability When Needed\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n// Shared mutable state in single-threaded context\nstruct Counter {\n    value: Rc<RefCell<u32>>,\n}\n\nimpl Counter {\n    fn new() -> Self {\n        Counter {\n            value: Rc::new(RefCell::new(0)),\n        }\n    }\n\n    fn increment(&self) {\n        *self.value.borrow_mut() += 1;\n    }\n\n    fn get(&self) -> u32 {\n        *self.value.borrow()\n    }\n\n    fn clone_handle(&self) -> Self {\n        Counter {\n            value: Rc::clone(&self.value),\n        }\n    }\n}\n```\n\n---\n\n## Collection Patterns\n\n### 1. Efficient Iteration\n\n```rust\nlet items = vec![1, 2, 3, 4, 5];\n\n// Iterate by reference (no move)\nfor item in &items {\n    println!(\"{}\", item);\n}\n\n// Iterate by mutable reference\nfor item in &mut items.clone() {\n    *item *= 2;\n}\n\n// Consume with into_iter when done\nlet sum: i32 = items.into_iter().sum();\n```\n\n### 2. Collecting Results\n\n```rust\n// Collect into owned collection\nlet strings: Vec<String> = (0..5)\n    .map(|i| format!(\"item_{}\", i))\n    .collect();\n\n// Collect references\nlet refs: Vec<&str> = strings.iter().map(|s| s.as_str()).collect();\n\n// Collect with transformation\nlet result: Result<Vec<i32>, _> = [\"1\", \"2\", \"3\"]\n    .iter()\n    .map(|s| s.parse::<i32>())\n    .collect();\n```\n\n### 3. Entry API for Maps\n\n```rust\nuse std::collections::HashMap;\n\nlet mut map: HashMap<String, Vec<i32>> = HashMap::new();\n\n// Efficient: don't search twice\nmap.entry(\"key\".to_string())\n   .or_insert_with(Vec::new)\n   .push(42);\n\n// With entry modification\nmap.entry(\"key\".to_string())\n   .and_modify(|v| v.push(43))\n   .or_insert_with(|| vec![43]);\n```\n\n---\n\n## Error Handling with Ownership\n\n### 1. Preserve Context in Errors\n\n```rust\nuse std::error::Error;\nuse std::fmt;\n\n#[derive(Debug)]\nstruct ParseError {\n    input: String,  // owns the problematic input\n    message: String,\n}\n\nimpl fmt::Display for ParseError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Failed to parse '{}': {}\", self.input, self.message)\n    }\n}\n\nfn parse(input: &str) -> Result<i32, ParseError> {\n    input.parse().map_err(|_| ParseError {\n        input: input.to_string(),  // clone for error context\n        message: \"not a valid integer\".to_string(),\n    })\n}\n```\n\n### 2. Ownership in Result Chains\n\n```rust\nfn process_data(path: &str) -> Result<ProcessedData, Error> {\n    let content = std::fs::read_to_string(path)?;  // owned String\n    let parsed = parse_content(&content)?;          // borrow\n    let processed = transform(parsed)?;             // ownership moves\n    Ok(processed)                                   // return owned\n}\n```\n\n---\n\n## Performance Considerations\n\n### 1. Avoid Unnecessary Clones\n\n```rust\n// BAD: cloning just to compare\nfn contains_item(items: &[String], target: &str) -> bool {\n    items.iter().any(|s| s.clone() == target)  // unnecessary clone\n}\n\n// GOOD: compare references\nfn contains_item(items: &[String], target: &str) -> bool {\n    items.iter().any(|s| s == target)  // String implements PartialEq<str>\n}\n```\n\n### 2. Use Slices for Flexibility\n\n```rust\n// BAD: requires Vec\nfn sum(numbers: &Vec<i32>) -> i32 {\n    numbers.iter().sum()\n}\n\n// GOOD: accepts any slice\nfn sum(numbers: &[i32]) -> i32 {\n    numbers.iter().sum()\n}\n\n// Now works with:\nsum(&vec![1, 2, 3]);     // Vec\nsum(&[1, 2, 3]);         // array\nsum(&array[1..3]);       // slice\n```\n\n### 3. In-Place Mutation\n\n```rust\n// BAD: allocates new String\nfn make_uppercase(s: &str) -> String {\n    s.to_uppercase()\n}\n\n// GOOD when you own the data: mutate in place\nfn make_uppercase(mut s: String) -> String {\n    s.make_ascii_uppercase();  // in-place for ASCII\n    s\n}\n```\n",
        "skills/m01-ownership/patterns/common-errors.md": "# Common Ownership Errors & Fixes\n\n## E0382: Use of Moved Value\n\n### Error Pattern\n```rust\nlet s = String::from(\"hello\");\nlet s2 = s;          // s moved here\nprintln!(\"{}\", s);   // ERROR: value borrowed after move\n```\n\n### Fix Options\n\n**Option 1: Clone (if ownership not needed)**\n```rust\nlet s = String::from(\"hello\");\nlet s2 = s.clone();  // s is cloned\nprintln!(\"{}\", s);   // OK: s still valid\n```\n\n**Option 2: Borrow (if modification not needed)**\n```rust\nlet s = String::from(\"hello\");\nlet s2 = &s;         // borrow, not move\nprintln!(\"{}\", s);   // OK\nprintln!(\"{}\", s2);  // OK\n```\n\n**Option 3: Use Rc/Arc (for shared ownership)**\n```rust\nuse std::rc::Rc;\nlet s = Rc::new(String::from(\"hello\"));\nlet s2 = Rc::clone(&s);  // shared ownership\nprintln!(\"{}\", s);       // OK\nprintln!(\"{}\", s2);      // OK\n```\n\n---\n\n## E0597: Borrowed Value Does Not Live Long Enough\n\n### Error Pattern\n```rust\nfn get_str() -> &str {\n    let s = String::from(\"hello\");\n    &s  // ERROR: s dropped here, but reference returned\n}\n```\n\n### Fix Options\n\n**Option 1: Return owned value**\n```rust\nfn get_str() -> String {\n    String::from(\"hello\")  // return owned value\n}\n```\n\n**Option 2: Use 'static lifetime**\n```rust\nfn get_str() -> &'static str {\n    \"hello\"  // string literal has 'static lifetime\n}\n```\n\n**Option 3: Accept reference parameter**\n```rust\nfn get_str<'a>(s: &'a str) -> &'a str {\n    s  // return reference with same lifetime as input\n}\n```\n\n---\n\n## E0499: Cannot Borrow as Mutable More Than Once\n\n### Error Pattern\n```rust\nlet mut s = String::from(\"hello\");\nlet r1 = &mut s;\nlet r2 = &mut s;  // ERROR: second mutable borrow\nprintln!(\"{}, {}\", r1, r2);\n```\n\n### Fix Options\n\n**Option 1: Sequential borrows**\n```rust\nlet mut s = String::from(\"hello\");\n{\n    let r1 = &mut s;\n    r1.push_str(\" world\");\n}  // r1 goes out of scope\nlet r2 = &mut s;  // OK: r1 no longer exists\n```\n\n**Option 2: Use RefCell for interior mutability**\n```rust\nuse std::cell::RefCell;\nlet s = RefCell::new(String::from(\"hello\"));\nlet mut r1 = s.borrow_mut();\n// drop r1 before borrowing again\ndrop(r1);\nlet mut r2 = s.borrow_mut();\n```\n\n---\n\n## E0502: Cannot Borrow as Mutable While Immutable Borrow Exists\n\n### Error Pattern\n```rust\nlet mut v = vec![1, 2, 3];\nlet first = &v[0];      // immutable borrow\nv.push(4);              // ERROR: mutable borrow while immutable exists\nprintln!(\"{}\", first);\n```\n\n### Fix Options\n\n**Option 1: Finish using immutable borrow first**\n```rust\nlet mut v = vec![1, 2, 3];\nlet first = v[0];       // copy value, not borrow\nv.push(4);              // OK\nprintln!(\"{}\", first);  // OK: using copied value\n```\n\n**Option 2: Clone before mutating**\n```rust\nlet mut v = vec![1, 2, 3];\nlet first = v[0].clone();  // if T: Clone\nv.push(4);\nprintln!(\"{}\", first);\n```\n\n---\n\n## E0507: Cannot Move Out of Borrowed Content\n\n### Error Pattern\n```rust\nfn take_string(s: &String) {\n    let moved = *s;  // ERROR: cannot move out of borrowed content\n}\n```\n\n### Fix Options\n\n**Option 1: Clone**\n```rust\nfn take_string(s: &String) {\n    let cloned = s.clone();\n}\n```\n\n**Option 2: Take ownership in function signature**\n```rust\nfn take_string(s: String) {  // take ownership\n    let moved = s;\n}\n```\n\n**Option 3: Use mem::take for Option/Default types**\n```rust\nfn take_from_option(opt: &mut Option<String>) -> Option<String> {\n    std::mem::take(opt)  // replaces with None, returns owned value\n}\n```\n\n---\n\n## E0515: Return Local Reference\n\n### Error Pattern\n```rust\nfn create_string() -> &String {\n    let s = String::from(\"hello\");\n    &s  // ERROR: cannot return reference to local variable\n}\n```\n\n### Fix Options\n\n**Option 1: Return owned value**\n```rust\nfn create_string() -> String {\n    String::from(\"hello\")\n}\n```\n\n**Option 2: Use static/const**\n```rust\nfn get_static_str() -> &'static str {\n    \"hello\"\n}\n```\n\n---\n\n## E0716: Temporary Value Dropped While Borrowed\n\n### Error Pattern\n```rust\nlet r: &str = &String::from(\"hello\");  // ERROR: temporary dropped\nprintln!(\"{}\", r);\n```\n\n### Fix Options\n\n**Option 1: Bind to variable first**\n```rust\nlet s = String::from(\"hello\");\nlet r: &str = &s;\nprintln!(\"{}\", r);\n```\n\n**Option 2: Use let binding with reference**\n```rust\nlet r: &str = {\n    let s = String::from(\"hello\");\n    // s.as_str()  // ERROR: still temporary\n    Box::leak(s.into_boxed_str())  // extreme: leak for 'static\n};\n```\n\n---\n\n## Pattern: Loop Ownership Issues\n\n### Error Pattern\n```rust\nlet strings = vec![String::from(\"a\"), String::from(\"b\")];\nfor s in strings {\n    println!(\"{}\", s);\n}\n// ERROR: strings moved into loop\nprintln!(\"{:?}\", strings);\n```\n\n### Fix Options\n\n**Option 1: Iterate by reference**\n```rust\nlet strings = vec![String::from(\"a\"), String::from(\"b\")];\nfor s in &strings {\n    println!(\"{}\", s);\n}\nprintln!(\"{:?}\", strings);  // OK\n```\n\n**Option 2: Use iter()**\n```rust\nfor s in strings.iter() {\n    println!(\"{}\", s);\n}\n```\n\n**Option 3: Clone if needed**\n```rust\nfor s in strings.clone() {\n    // consumes cloned vec\n}\nprintln!(\"{:?}\", strings);  // original still available\n```\n",
        "skills/m01-ownership/patterns/lifetime-patterns.md": "# Lifetime Patterns\n\n## Basic Lifetime Annotation\n\n### When Required\n```rust\n// ERROR: missing lifetime specifier\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() { x } else { y }\n}\n\n// FIX: explicit lifetime\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n### Lifetime Elision Rules\n1. Each input reference gets its own lifetime\n2. If one input lifetime, output uses same\n3. If `&self` or `&mut self`, output uses self's lifetime\n\n```rust\n// These are equivalent (elision applies):\nfn first_word(s: &str) -> &str { ... }\nfn first_word<'a>(s: &'a str) -> &'a str { ... }\n\n// Method with self (elision applies):\nimpl MyStruct {\n    fn get_ref(&self) -> &str { ... }\n    // Equivalent to:\n    fn get_ref<'a>(&'a self) -> &'a str { ... }\n}\n```\n\n---\n\n## Struct Lifetimes\n\n### Struct Holding References\n```rust\n// Struct must declare lifetime for references\nstruct Excerpt<'a> {\n    part: &'a str,\n}\n\nimpl<'a> Excerpt<'a> {\n    fn level(&self) -> i32 { 3 }\n\n    // Return reference tied to self's lifetime\n    fn get_part(&self) -> &str {\n        self.part\n    }\n}\n```\n\n### Multiple Lifetimes in Struct\n```rust\nstruct Multi<'a, 'b> {\n    x: &'a str,\n    y: &'b str,\n}\n\n// Use when references may have different lifetimes\nfn make_multi<'a, 'b>(x: &'a str, y: &'b str) -> Multi<'a, 'b> {\n    Multi { x, y }\n}\n```\n\n---\n\n## 'static Lifetime\n\n### When to Use\n```rust\n// String literals are 'static\nlet s: &'static str = \"hello\";\n\n// Owned data can be leaked to 'static\nlet leaked: &'static str = Box::leak(String::from(\"hello\").into_boxed_str());\n\n// Thread spawn requires 'static or move\nstd::thread::spawn(move || {\n    // closure owns data, satisfies 'static\n});\n```\n\n### Avoid Overusing 'static\n```rust\n// BAD: requires 'static unnecessarily\nfn process(s: &'static str) { ... }\n\n// GOOD: use generic lifetime\nfn process<'a>(s: &'a str) { ... }\n// or\nfn process(s: &str) { ... }  // lifetime elision\n```\n\n---\n\n## Higher-Ranked Trait Bounds (HRTB)\n\n### for<'a> Syntax\n```rust\n// Function that works with any lifetime\nfn apply_to_ref<F>(f: F)\nwhere\n    F: for<'a> Fn(&'a str) -> &'a str,\n{\n    let s = String::from(\"hello\");\n    let result = f(&s);\n    println!(\"{}\", result);\n}\n```\n\n### Common Use: Closure Bounds\n```rust\n// Closure that borrows any lifetime\nfn filter_refs<F>(items: &[&str], pred: F) -> Vec<&str>\nwhere\n    F: for<'a> Fn(&'a str) -> bool,\n{\n    items.iter().copied().filter(|s| pred(s)).collect()\n}\n```\n\n---\n\n## Lifetime Bounds\n\n### 'a: 'b (Outlives)\n```rust\n// 'a must live at least as long as 'b\nfn coerce<'a, 'b>(x: &'a str) -> &'b str\nwhere\n    'a: 'b,\n{\n    x\n}\n```\n\n### T: 'a (Type Outlives Lifetime)\n```rust\n// T must live at least as long as 'a\nstruct Wrapper<'a, T: 'a> {\n    value: &'a T,\n}\n\n// Common pattern with trait objects\nfn use_trait<'a, T: MyTrait + 'a>(t: &'a T) { ... }\n```\n\n---\n\n## Common Lifetime Mistakes\n\n### Mistake 1: Returning Reference to Local\n```rust\n// WRONG\nfn dangle() -> &String {\n    let s = String::from(\"hello\");\n    &s  // s dropped, reference invalid\n}\n\n// RIGHT\nfn no_dangle() -> String {\n    String::from(\"hello\")\n}\n```\n\n### Mistake 2: Conflicting Lifetimes\n```rust\n// WRONG: might return reference to y which has shorter lifetime\nfn wrong<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {\n    y  // ERROR: 'b might not live as long as 'a\n}\n\n// RIGHT: use same lifetime or add bound\nfn right<'a>(x: &'a str, y: &'a str) -> &'a str {\n    y  // OK: both have lifetime 'a\n}\n```\n\n### Mistake 3: Struct Outlives Reference\n```rust\n// WRONG: s might outlive the string it references\nlet r;\n{\n    let s = String::from(\"hello\");\n    r = Excerpt { part: &s };  // ERROR\n}\nprintln!(\"{}\", r.part);  // s already dropped\n\n// RIGHT: ensure source outlives struct\nlet s = String::from(\"hello\");\nlet r = Excerpt { part: &s };\nprintln!(\"{}\", r.part);  // OK: s still in scope\n```\n\n---\n\n## Subtyping and Variance\n\n### Covariance\n```rust\n// &'a T is covariant in 'a\n// Can use &'long where &'short expected\nfn example<'short, 'long: 'short>(long_ref: &'long str) {\n    let short_ref: &'short str = long_ref;  // OK: covariance\n}\n```\n\n### Invariance\n```rust\n// &'a mut T is invariant in 'a\nfn example<'a, 'b>(x: &'a mut &'b str, y: &'b str) {\n    *x = y;  // ERROR if 'a and 'b are different\n}\n```\n\n### Practical Impact\n```rust\n// This works due to covariance\nfn accept_any<'a>(s: &'a str) { ... }\n\nlet s = String::from(\"hello\");\nlet long_lived: &str = &s;\naccept_any(long_lived);  // 'long coerces to 'short\n```\n",
        "skills/m02-resource/SKILL.md": "---\nname: m02-resource\ndescription: \"CRITICAL: Use for smart pointers and resource management. Triggers: Box, Rc, Arc, Weak, RefCell, Cell, smart pointer, heap allocation, reference counting, RAII, Drop, should I use Box or Rc, when to use Arc vs Rc, Êô∫ËÉΩÊåáÈíà, ÂºïÁî®ËÆ°Êï∞, Â†ÜÂàÜÈÖç\"\nuser-invocable: false\n---\n\n# Resource Management\n\n> **Layer 1: Language Mechanics**\n\n## Core Question\n\n**What ownership pattern does this resource need?**\n\nBefore choosing a smart pointer, understand:\n- Is ownership single or shared?\n- Is access single-threaded or multi-threaded?\n- Are there potential cycles?\n\n---\n\n## Error ‚Üí Design Question\n\n| Error | Don't Just Say | Ask Instead |\n|-------|----------------|-------------|\n| \"Need heap allocation\" | \"Use Box\" | Why can't this be on stack? |\n| Rc memory leak | \"Use Weak\" | Is the cycle necessary in design? |\n| RefCell panic | \"Use try_borrow\" | Is runtime check the right approach? |\n| Arc overhead complaint | \"Accept it\" | Is multi-thread access actually needed? |\n\n---\n\n## Thinking Prompt\n\nBefore choosing a smart pointer:\n\n1. **What's the ownership model?**\n   - Single owner ‚Üí Box or owned value\n   - Shared ownership ‚Üí Rc/Arc\n   - Weak reference ‚Üí Weak\n\n2. **What's the thread context?**\n   - Single-thread ‚Üí Rc, Cell, RefCell\n   - Multi-thread ‚Üí Arc, Mutex, RwLock\n\n3. **Are there cycles?**\n   - Yes ‚Üí One direction must be Weak\n   - No ‚Üí Regular Rc/Arc is fine\n\n---\n\n## Trace Up ‚Üë\n\nWhen pointer choice is unclear, trace to design:\n\n```\n\"Should I use Arc or Rc?\"\n    ‚Üë Ask: Is this data shared across threads?\n    ‚Üë Check: m07-concurrency (thread model)\n    ‚Üë Check: domain-* (performance constraints)\n```\n\n| Situation | Trace To | Question |\n|-----------|----------|----------|\n| Rc vs Arc confusion | m07-concurrency | What's the concurrency model? |\n| RefCell panics | m03-mutability | Is interior mutability right here? |\n| Memory leaks | m12-lifecycle | Where should cleanup happen? |\n\n---\n\n## Trace Down ‚Üì\n\nFrom design to implementation:\n\n```\n\"Need single-owner heap data\"\n    ‚Üì Use: Box<T>\n\n\"Need shared immutable data (single-thread)\"\n    ‚Üì Use: Rc<T>\n\n\"Need shared immutable data (multi-thread)\"\n    ‚Üì Use: Arc<T>\n\n\"Need to break reference cycle\"\n    ‚Üì Use: Weak<T>\n\n\"Need shared mutable data\"\n    ‚Üì Single-thread: Rc<RefCell<T>>\n    ‚Üì Multi-thread: Arc<Mutex<T>> or Arc<RwLock<T>>\n```\n\n---\n\n## Quick Reference\n\n| Type | Ownership | Thread-Safe | Use When |\n|------|-----------|-------------|----------|\n| `Box<T>` | Single | Yes | Heap allocation, recursive types |\n| `Rc<T>` | Shared | No | Single-thread shared ownership |\n| `Arc<T>` | Shared | Yes | Multi-thread shared ownership |\n| `Weak<T>` | Weak ref | Same as Rc/Arc | Break reference cycles |\n| `Cell<T>` | Single | No | Interior mutability (Copy types) |\n| `RefCell<T>` | Single | No | Interior mutability (runtime check) |\n\n## Decision Flowchart\n\n```\nNeed heap allocation?\n‚îú‚îÄ Yes ‚Üí Single owner?\n‚îÇ        ‚îú‚îÄ Yes ‚Üí Box<T>\n‚îÇ        ‚îî‚îÄ No ‚Üí Multi-thread?\n‚îÇ                ‚îú‚îÄ Yes ‚Üí Arc<T>\n‚îÇ                ‚îî‚îÄ No ‚Üí Rc<T>\n‚îî‚îÄ No ‚Üí Stack allocation (default)\n\nHave reference cycles?\n‚îú‚îÄ Yes ‚Üí Use Weak for one direction\n‚îî‚îÄ No ‚Üí Regular Rc/Arc\n\nNeed interior mutability?\n‚îú‚îÄ Yes ‚Üí Thread-safe needed?\n‚îÇ        ‚îú‚îÄ Yes ‚Üí Mutex<T> or RwLock<T>\n‚îÇ        ‚îî‚îÄ No ‚Üí T: Copy? ‚Üí Cell<T> : RefCell<T>\n‚îî‚îÄ No ‚Üí Use &mut T\n```\n\n---\n\n## Common Errors\n\n| Problem | Cause | Fix |\n|---------|-------|-----|\n| Rc cycle leak | Mutual strong refs | Use Weak for one direction |\n| RefCell panic | Borrow conflict at runtime | Use try_borrow or restructure |\n| Arc overhead | Atomic ops in hot path | Consider Rc if single-threaded |\n| Box unnecessary | Data fits on stack | Remove Box |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| Arc everywhere | Unnecessary atomic overhead | Use Rc for single-thread |\n| RefCell everywhere | Runtime panics | Design clear ownership |\n| Box for small types | Unnecessary allocation | Stack allocation |\n| Ignore Weak for cycles | Memory leaks | Design parent-child with Weak |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Ownership errors | m01-ownership |\n| Interior mutability details | m03-mutability |\n| Multi-thread context | m07-concurrency |\n| Resource lifecycle | m12-lifecycle |\n",
        "skills/m03-mutability/SKILL.md": "---\nname: m03-mutability\ndescription: \"CRITICAL: Use for mutability issues. Triggers: E0596, E0499, E0502, cannot borrow as mutable, already borrowed as immutable, mut, &mut, interior mutability, Cell, RefCell, Mutex, RwLock, ÂèØÂèòÊÄß, ÂÜÖÈÉ®ÂèØÂèòÊÄß, ÂÄüÁî®ÂÜ≤Á™Å\"\nuser-invocable: false\n---\n\n# Mutability\n\n> **Layer 1: Language Mechanics**\n\n## Core Question\n\n**Why does this data need to change, and who can change it?**\n\nBefore adding interior mutability, understand:\n- Is mutation essential or accidental complexity?\n- Who should control mutation?\n- Is the mutation pattern safe?\n\n---\n\n## Error ‚Üí Design Question\n\n| Error | Don't Just Say | Ask Instead |\n|-------|----------------|-------------|\n| E0596 | \"Add mut\" | Should this really be mutable? |\n| E0499 | \"Split borrows\" | Is the data structure right? |\n| E0502 | \"Separate scopes\" | Why do we need both borrows? |\n| RefCell panic | \"Use try_borrow\" | Is runtime check appropriate? |\n\n---\n\n## Thinking Prompt\n\nBefore adding mutability:\n\n1. **Is mutation necessary?**\n   - Maybe transform ‚Üí return new value\n   - Maybe builder ‚Üí construct immutably\n\n2. **Who controls mutation?**\n   - External caller ‚Üí `&mut T`\n   - Internal logic ‚Üí interior mutability\n   - Concurrent access ‚Üí synchronized mutability\n\n3. **What's the thread context?**\n   - Single-thread ‚Üí Cell/RefCell\n   - Multi-thread ‚Üí Mutex/RwLock/Atomic\n\n---\n\n## Trace Up ‚Üë\n\nWhen mutability conflicts persist:\n\n```\nE0499/E0502 (borrow conflicts)\n    ‚Üë Ask: Is the data structure designed correctly?\n    ‚Üë Check: m09-domain (should data be split?)\n    ‚Üë Check: m07-concurrency (is async involved?)\n```\n\n| Persistent Error | Trace To | Question |\n|-----------------|----------|----------|\n| Repeated borrow conflicts | m09-domain | Should data be restructured? |\n| RefCell in async | m07-concurrency | Is Send/Sync needed? |\n| Mutex deadlocks | m07-concurrency | Is the lock design right? |\n\n---\n\n## Trace Down ‚Üì\n\nFrom design to implementation:\n\n```\n\"Need mutable access from &self\"\n    ‚Üì T: Copy ‚Üí Cell<T>\n    ‚Üì T: !Copy ‚Üí RefCell<T>\n\n\"Need thread-safe mutation\"\n    ‚Üì Simple counters ‚Üí AtomicXxx\n    ‚Üì Complex data ‚Üí Mutex<T> or RwLock<T>\n\n\"Need shared mutable state\"\n    ‚Üì Single-thread: Rc<RefCell<T>>\n    ‚Üì Multi-thread: Arc<Mutex<T>>\n```\n\n---\n\n## Borrow Rules\n\n```\nAt any time, you can have EITHER:\n‚îú‚îÄ Multiple &T (immutable borrows)\n‚îî‚îÄ OR one &mut T (mutable borrow)\n\nNever both simultaneously.\n```\n\n## Quick Reference\n\n| Pattern | Thread-Safe | Runtime Cost | Use When |\n|---------|-------------|--------------|----------|\n| `&mut T` | N/A | Zero | Exclusive mutable access |\n| `Cell<T>` | No | Zero | Copy types, no refs needed |\n| `RefCell<T>` | No | Runtime check | Non-Copy, need runtime borrow |\n| `Mutex<T>` | Yes | Lock contention | Thread-safe mutation |\n| `RwLock<T>` | Yes | Lock contention | Many readers, few writers |\n| `Atomic*` | Yes | Minimal | Simple types (bool, usize) |\n\n## Error Code Reference\n\n| Error | Cause | Quick Fix |\n|-------|-------|-----------|\n| E0596 | Borrowing immutable as mutable | Add `mut` or redesign |\n| E0499 | Multiple mutable borrows | Restructure code flow |\n| E0502 | &mut while & exists | Separate borrow scopes |\n\n---\n\n## Interior Mutability Decision\n\n| Scenario | Choose |\n|----------|--------|\n| T: Copy, single-thread | `Cell<T>` |\n| T: !Copy, single-thread | `RefCell<T>` |\n| T: Copy, multi-thread | `AtomicXxx` |\n| T: !Copy, multi-thread | `Mutex<T>` or `RwLock<T>` |\n| Read-heavy, multi-thread | `RwLock<T>` |\n| Simple flags/counters | `AtomicBool`, `AtomicUsize` |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| RefCell everywhere | Runtime panics | Clear ownership design |\n| Mutex for single-thread | Unnecessary overhead | RefCell |\n| Ignore RefCell panic | Hard to debug | Handle or restructure |\n| Lock inside hot loop | Performance killer | Batch operations |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Smart pointer choice | m02-resource |\n| Thread safety | m07-concurrency |\n| Data structure design | m09-domain |\n| Anti-patterns | m15-anti-pattern |\n",
        "skills/m04-zero-cost/SKILL.md": "---\nname: m04-zero-cost\ndescription: \"CRITICAL: Use for generics, traits, zero-cost abstraction. Triggers: E0277, E0308, E0599, generic, trait, impl, dyn, where, monomorphization, static dispatch, dynamic dispatch, impl Trait, trait bound not satisfied, Ê≥õÂûã, ÁâπÂæÅ, Èõ∂ÊàêÊú¨ÊäΩË±°, ÂçïÊÄÅÂåñ\"\nuser-invocable: false\n---\n\n# Zero-Cost Abstraction\n\n> **Layer 1: Language Mechanics**\n\n## Core Question\n\n**Do we need compile-time or runtime polymorphism?**\n\nBefore choosing between generics and trait objects:\n- Is the type known at compile time?\n- Is a heterogeneous collection needed?\n- What's the performance priority?\n\n---\n\n## Error ‚Üí Design Question\n\n| Error | Don't Just Say | Ask Instead |\n|-------|----------------|-------------|\n| E0277 | \"Add trait bound\" | Is this abstraction at the right level? |\n| E0308 | \"Fix the type\" | Should types be unified or distinct? |\n| E0599 | \"Import the trait\" | Is the trait the right abstraction? |\n| E0038 | \"Make object-safe\" | Do we really need dynamic dispatch? |\n\n---\n\n## Thinking Prompt\n\nBefore adding trait bounds:\n\n1. **What abstraction is needed?**\n   - Same behavior, different types ‚Üí trait\n   - Different behavior, same type ‚Üí enum\n   - No abstraction needed ‚Üí concrete type\n\n2. **When is type known?**\n   - Compile time ‚Üí generics (static dispatch)\n   - Runtime ‚Üí trait objects (dynamic dispatch)\n\n3. **What's the trade-off priority?**\n   - Performance ‚Üí generics\n   - Compile time ‚Üí trait objects\n   - Flexibility ‚Üí depends\n\n---\n\n## Trace Up ‚Üë\n\nWhen type system fights back:\n\n```\nE0277 (trait bound not satisfied)\n    ‚Üë Ask: Is the abstraction level correct?\n    ‚Üë Check: m09-domain (what behavior is being abstracted?)\n    ‚Üë Check: m05-type-driven (should use newtype?)\n```\n\n| Persistent Error | Trace To | Question |\n|-----------------|----------|----------|\n| Complex trait bounds | m09-domain | Is the abstraction right? |\n| Object safety issues | m05-type-driven | Can typestate help? |\n| Type explosion | m10-performance | Accept dyn overhead? |\n\n---\n\n## Trace Down ‚Üì\n\nFrom design to implementation:\n\n```\n\"Need to abstract over types with same behavior\"\n    ‚Üì Types known at compile time ‚Üí impl Trait or generics\n    ‚Üì Types determined at runtime ‚Üí dyn Trait\n\n\"Need collection of different types\"\n    ‚Üì Closed set ‚Üí enum\n    ‚Üì Open set ‚Üí Vec<Box<dyn Trait>>\n\n\"Need to return different types\"\n    ‚Üì Same type ‚Üí impl Trait\n    ‚Üì Different types ‚Üí Box<dyn Trait>\n```\n\n---\n\n## Quick Reference\n\n| Pattern | Dispatch | Code Size | Runtime Cost |\n|---------|----------|-----------|--------------|\n| `fn foo<T: Trait>()` | Static | +bloat | Zero |\n| `fn foo(x: &dyn Trait)` | Dynamic | Minimal | vtable lookup |\n| `impl Trait` return | Static | +bloat | Zero |\n| `Box<dyn Trait>` | Dynamic | Minimal | Allocation + vtable |\n\n## Syntax Comparison\n\n```rust\n// Static dispatch - type known at compile time\nfn process(x: impl Display) { }      // argument position\nfn process<T: Display>(x: T) { }     // explicit generic\nfn get() -> impl Display { }         // return position\n\n// Dynamic dispatch - type determined at runtime\nfn process(x: &dyn Display) { }      // reference\nfn process(x: Box<dyn Display>) { }  // owned\n```\n\n## Error Code Reference\n\n| Error | Cause | Quick Fix |\n|-------|-------|-----------|\n| E0277 | Type doesn't impl trait | Add impl or change bound |\n| E0308 | Type mismatch | Check generic params |\n| E0599 | No method found | Import trait with `use` |\n| E0038 | Trait not object-safe | Use generics or redesign |\n\n---\n\n## Decision Guide\n\n| Scenario | Choose | Why |\n|----------|--------|-----|\n| Performance critical | Generics | Zero runtime cost |\n| Heterogeneous collection | `dyn Trait` | Different types at runtime |\n| Plugin architecture | `dyn Trait` | Unknown types at compile |\n| Reduce compile time | `dyn Trait` | Less monomorphization |\n| Small, known type set | `enum` | No indirection |\n\n---\n\n## Object Safety\n\nA trait is object-safe if it:\n- Doesn't have `Self: Sized` bound\n- Doesn't return `Self`\n- Doesn't have generic methods\n- Uses `where Self: Sized` for non-object-safe methods\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| Over-generic everything | Compile time, complexity | Concrete types when possible |\n| `dyn` for known types | Unnecessary indirection | Generics |\n| Complex trait hierarchies | Hard to understand | Simpler design |\n| Ignore object safety | Limits flexibility | Plan for dyn if needed |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Type-driven design | m05-type-driven |\n| Domain abstraction | m09-domain |\n| Performance concerns | m10-performance |\n| Send/Sync bounds | m07-concurrency |\n",
        "skills/m05-type-driven/SKILL.md": "---\nname: m05-type-driven\ndescription: \"CRITICAL: Use for type-driven design. Triggers: type state, PhantomData, newtype, marker trait, builder pattern, make invalid states unrepresentable, compile-time validation, sealed trait, ZST, Á±ªÂûãÁä∂ÊÄÅ, Êñ∞Á±ªÂûãÊ®°Âºè, Á±ªÂûãÈ©±Âä®ËÆæËÆ°\"\nuser-invocable: false\n---\n\n# Type-Driven Design\n\n> **Layer 1: Language Mechanics**\n\n## Core Question\n\n**How can the type system prevent invalid states?**\n\nBefore reaching for runtime checks:\n- Can the compiler catch this error?\n- Can invalid states be unrepresentable?\n- Can the type encode the invariant?\n\n---\n\n## Error ‚Üí Design Question\n\n| Pattern | Don't Just Say | Ask Instead |\n|---------|----------------|-------------|\n| Primitive obsession | \"It's just a string\" | What does this value represent? |\n| Boolean flags | \"Add an is_valid flag\" | Can states be types? |\n| Optional everywhere | \"Check for None\" | Is absence really possible? |\n| Validation at runtime | \"Return Err if invalid\" | Can we validate at construction? |\n\n---\n\n## Thinking Prompt\n\nBefore adding runtime validation:\n\n1. **Can the type encode the constraint?**\n   - Numeric range ‚Üí bounded types or newtypes\n   - Valid states ‚Üí type state pattern\n   - Semantic meaning ‚Üí newtype\n\n2. **When is validation possible?**\n   - At construction ‚Üí validated newtype\n   - At state transition ‚Üí type state\n   - Only at runtime ‚Üí Result with clear error\n\n3. **Who needs to know the invariant?**\n   - Compiler ‚Üí type-level encoding\n   - API users ‚Üí clear type signatures\n   - Runtime only ‚Üí documentation\n\n---\n\n## Trace Up ‚Üë\n\nWhen type design is unclear:\n\n```\n\"Need to validate email format\"\n    ‚Üë Ask: Is this a domain value object?\n    ‚Üë Check: m09-domain (Email as Value Object)\n    ‚Üë Check: domain-* (validation requirements)\n```\n\n| Situation | Trace To | Question |\n|-----------|----------|----------|\n| What types to create | m09-domain | What's the domain model? |\n| State machine design | m09-domain | What are valid transitions? |\n| Marker trait usage | m04-zero-cost | Static or dynamic dispatch? |\n\n---\n\n## Trace Down ‚Üì\n\nFrom design to implementation:\n\n```\n\"Need type-safe wrapper for primitives\"\n    ‚Üì Newtype: struct UserId(u64);\n\n\"Need compile-time state validation\"\n    ‚Üì Type State: Connection<Connected>\n\n\"Need to track phantom type parameters\"\n    ‚Üì PhantomData: PhantomData<T>\n\n\"Need capability markers\"\n    ‚Üì Marker Trait: trait Validated {}\n\n\"Need gradual construction\"\n    ‚Üì Builder: Builder::new().field(x).build()\n```\n\n---\n\n## Quick Reference\n\n| Pattern | Purpose | Example |\n|---------|---------|---------|\n| Newtype | Type safety | `struct UserId(u64);` |\n| Type State | State machine | `Connection<Connected>` |\n| PhantomData | Variance/lifetime | `PhantomData<&'a T>` |\n| Marker Trait | Capability flag | `trait Validated {}` |\n| Builder | Gradual construction | `Builder::new().name(\"x\").build()` |\n| Sealed Trait | Prevent external impl | `mod private { pub trait Sealed {} }` |\n\n## Pattern Examples\n\n### Newtype\n\n```rust\nstruct Email(String);  // Not just any string\n\nimpl Email {\n    pub fn new(s: &str) -> Result<Self, ValidationError> {\n        // Validate once, trust forever\n        validate_email(s)?;\n        Ok(Self(s.to_string()))\n    }\n}\n```\n\n### Type State\n\n```rust\nstruct Connection<State>(TcpStream, PhantomData<State>);\n\nstruct Disconnected;\nstruct Connected;\nstruct Authenticated;\n\nimpl Connection<Disconnected> {\n    fn connect(self) -> Connection<Connected> { ... }\n}\n\nimpl Connection<Connected> {\n    fn authenticate(self) -> Connection<Authenticated> { ... }\n}\n```\n\n---\n\n## Decision Guide\n\n| Need | Pattern |\n|------|---------|\n| Type safety for primitives | Newtype |\n| Compile-time state validation | Type State |\n| Lifetime/variance markers | PhantomData |\n| Capability flags | Marker Trait |\n| Gradual construction | Builder |\n| Closed set of impls | Sealed Trait |\n| Zero-sized type marker | ZST struct |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| Boolean flags for states | Runtime errors | Type state |\n| String for semantic types | No type safety | Newtype |\n| Option for uninitialized | Unclear invariant | Builder |\n| Public fields with invariants | Invariant violation | Private + validated new() |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Domain modeling | m09-domain |\n| Trait design | m04-zero-cost |\n| Error handling in constructors | m06-error-handling |\n| Anti-patterns | m15-anti-pattern |\n",
        "skills/m06-error-handling/SKILL.md": "---\nname: m06-error-handling\ndescription: \"CRITICAL: Use for error handling. Triggers: Result, Option, Error, ?, unwrap, expect, panic, anyhow, thiserror, when to panic vs return Result, custom error, error propagation, ÈîôËØØÂ§ÑÁêÜ, Result Áî®Ê≥ï, ‰ªÄ‰πàÊó∂ÂÄôÁî® panic\"\nuser-invocable: false\n---\n\n# Error Handling\n\n> **Layer 1: Language Mechanics**\n\n## Core Question\n\n**Is this failure expected or a bug?**\n\nBefore choosing error handling strategy:\n- Can this fail in normal operation?\n- Who should handle this failure?\n- What context does the caller need?\n\n---\n\n## Error ‚Üí Design Question\n\n| Pattern | Don't Just Say | Ask Instead |\n|---------|----------------|-------------|\n| unwrap panics | \"Use ?\" | Is None/Err actually possible here? |\n| Type mismatch on ? | \"Use anyhow\" | Are error types designed correctly? |\n| Lost error context | \"Add .context()\" | What does the caller need to know? |\n| Too many error variants | \"Use Box<dyn Error>\" | Is error granularity right? |\n\n---\n\n## Thinking Prompt\n\nBefore handling an error:\n\n1. **What kind of failure is this?**\n   - Expected ‚Üí Result<T, E>\n   - Absence normal ‚Üí Option<T>\n   - Bug/invariant ‚Üí panic!\n   - Unrecoverable ‚Üí panic!\n\n2. **Who handles this?**\n   - Caller ‚Üí propagate with ?\n   - Current function ‚Üí match/if-let\n   - User ‚Üí friendly error message\n   - Programmer ‚Üí panic with message\n\n3. **What context is needed?**\n   - Type of error ‚Üí thiserror variants\n   - Call chain ‚Üí anyhow::Context\n   - Debug info ‚Üí anyhow or tracing\n\n---\n\n## Trace Up ‚Üë\n\nWhen error strategy is unclear:\n\n```\n\"Should I return Result or Option?\"\n    ‚Üë Ask: Is absence/failure normal or exceptional?\n    ‚Üë Check: m09-domain (what does domain say?)\n    ‚Üë Check: domain-* (error handling requirements)\n```\n\n| Situation | Trace To | Question |\n|-----------|----------|----------|\n| Too many unwraps | m09-domain | Is the data model right? |\n| Error context design | m13-domain-error | What recovery is needed? |\n| Library vs app errors | m11-ecosystem | Who are the consumers? |\n\n---\n\n## Trace Down ‚Üì\n\nFrom design to implementation:\n\n```\n\"Expected failure, library code\"\n    ‚Üì Use: thiserror for typed errors\n\n\"Expected failure, application code\"\n    ‚Üì Use: anyhow for ergonomic errors\n\n\"Absence is normal (find, get, lookup)\"\n    ‚Üì Use: Option<T>\n\n\"Bug or invariant violation\"\n    ‚Üì Use: panic!, assert!, unreachable!\n\n\"Need to propagate with context\"\n    ‚Üì Use: .context(\"what was happening\")\n```\n\n---\n\n## Quick Reference\n\n| Pattern | When | Example |\n|---------|------|---------|\n| `Result<T, E>` | Recoverable error | `fn read() -> Result<String, io::Error>` |\n| `Option<T>` | Absence is normal | `fn find() -> Option<&Item>` |\n| `?` | Propagate error | `let data = file.read()?;` |\n| `unwrap()` | Dev/test only | `config.get(\"key\").unwrap()` |\n| `expect()` | Invariant holds | `env.get(\"HOME\").expect(\"HOME set\")` |\n| `panic!` | Unrecoverable | `panic!(\"critical failure\")` |\n\n## Library vs Application\n\n| Context | Error Crate | Why |\n|---------|-------------|-----|\n| Library | `thiserror` | Typed errors for consumers |\n| Application | `anyhow` | Ergonomic error handling |\n| Mixed | Both | thiserror at boundaries, anyhow internally |\n\n## Decision Flowchart\n\n```\nIs failure expected?\n‚îú‚îÄ Yes ‚Üí Is absence the only \"failure\"?\n‚îÇ        ‚îú‚îÄ Yes ‚Üí Option<T>\n‚îÇ        ‚îî‚îÄ No ‚Üí Result<T, E>\n‚îÇ                 ‚îú‚îÄ Library ‚Üí thiserror\n‚îÇ                 ‚îî‚îÄ Application ‚Üí anyhow\n‚îî‚îÄ No ‚Üí Is it a bug?\n        ‚îú‚îÄ Yes ‚Üí panic!, assert!\n        ‚îî‚îÄ No ‚Üí Consider if really unrecoverable\n\nUse ? ‚Üí Need context?\n‚îú‚îÄ Yes ‚Üí .context(\"message\")\n‚îî‚îÄ No ‚Üí Plain ?\n```\n\n---\n\n## Common Errors\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| `unwrap()` panic | Unhandled None/Err | Use `?` or match |\n| Type mismatch | Different error types | Use `anyhow` or `From` |\n| Lost context | `?` without context | Add `.context()` |\n| `cannot use ?` | Missing Result return | Return `Result<(), E>` |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| `.unwrap()` everywhere | Panics in production | `.expect(\"reason\")` or `?` |\n| Ignore errors silently | Bugs hidden | Handle or propagate |\n| `panic!` for expected errors | Bad UX, no recovery | Result |\n| Box<dyn Error> everywhere | Lost type info | thiserror |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Domain error strategy | m13-domain-error |\n| Crate boundaries | m11-ecosystem |\n| Type-safe errors | m05-type-driven |\n| Mental models | m14-mental-model |\n",
        "skills/m06-error-handling/examples/library-vs-app.md": "# Error Handling: Library vs Application\n\n## Library Error Design\n\n### Principles\n1. **Define specific error types** - Don't use `anyhow` in libraries\n2. **Implement std::error::Error** - For compatibility\n3. **Provide error variants** - Let users match on errors\n4. **Include source errors** - Enable error chains\n5. **Be `Send + Sync`** - For async compatibility\n\n### Example: Library Error Type\n```rust\n// lib.rs\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum DatabaseError {\n    #[error(\"connection failed: {host}:{port}\")]\n    ConnectionFailed {\n        host: String,\n        port: u16,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"query failed: {query}\")]\n    QueryFailed {\n        query: String,\n        #[source]\n        source: SqlError,\n    },\n\n    #[error(\"record not found: {table}.{id}\")]\n    NotFound { table: String, id: String },\n\n    #[error(\"constraint violation: {0}\")]\n    ConstraintViolation(String),\n}\n\n// Public Result alias\npub type Result<T> = std::result::Result<T, DatabaseError>;\n\n// Library functions\npub fn connect(host: &str, port: u16) -> Result<Connection> {\n    // ...\n}\n\npub fn query(conn: &Connection, sql: &str) -> Result<Rows> {\n    // ...\n}\n```\n\n### Library Usage of Errors\n```rust\nimpl Database {\n    pub fn get_user(&self, id: &str) -> Result<User> {\n        let rows = self.query(&format!(\"SELECT * FROM users WHERE id = '{}'\", id))?;\n\n        rows.first()\n            .cloned()\n            .ok_or_else(|| DatabaseError::NotFound {\n                table: \"users\".to_string(),\n                id: id.to_string(),\n            })\n    }\n}\n```\n\n---\n\n## Application Error Design\n\n### Principles\n1. **Use anyhow for convenience** - Or custom unified error\n2. **Add context liberally** - Help debugging\n3. **Log at boundaries** - Don't log in libraries\n4. **Convert to user-friendly messages** - For display\n\n### Example: Application Error Handling\n```rust\n// main.rs\nuse anyhow::{Context, Result};\nuse tracing::{error, info};\n\nasync fn run_server() -> Result<()> {\n    let config = load_config()\n        .context(\"failed to load configuration\")?;\n\n    let db = Database::connect(&config.db_url)\n        .await\n        .context(\"failed to connect to database\")?;\n\n    let server = Server::new(config.port)\n        .context(\"failed to create server\")?;\n\n    info!(\"Server starting on port {}\", config.port);\n\n    server.run(db).await\n        .context(\"server error\")?;\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::init();\n\n    if let Err(e) = run_server().await {\n        error!(\"Application error: {:#}\", e);\n        std::process::exit(1);\n    }\n}\n```\n\n### Converting Library Errors\n```rust\nuse mylib::DatabaseError;\n\nasync fn get_user_handler(id: &str) -> Result<Response> {\n    match db.get_user(id).await {\n        Ok(user) => Ok(Response::json(user)),\n\n        Err(DatabaseError::NotFound { .. }) => {\n            Ok(Response::not_found(\"User not found\"))\n        }\n\n        Err(DatabaseError::ConnectionFailed { .. }) => {\n            error!(\"Database connection failed\");\n            Ok(Response::internal_error(\"Service unavailable\"))\n        }\n\n        Err(e) => {\n            error!(\"Database error: {}\", e);\n            Err(e.into())  // Convert to anyhow::Error\n        }\n    }\n}\n```\n\n---\n\n## Error Handling Layers\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ           Application Layer          ‚îÇ\n‚îÇ  - Use anyhow or unified error       ‚îÇ\n‚îÇ  - Add context at boundaries         ‚îÇ\n‚îÇ  - Log errors                        ‚îÇ\n‚îÇ  - Convert to user messages          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                 ‚îÇ\n                 ‚îÇ calls\n                 ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ           Service Layer              ‚îÇ\n‚îÇ  - Map between error types           ‚îÇ\n‚îÇ  - Add business context              ‚îÇ\n‚îÇ  - Handle recoverable errors         ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                 ‚îÇ\n                 ‚îÇ calls\n                 ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ           Library Layer              ‚îÇ\n‚îÇ  - Define specific error types       ‚îÇ\n‚îÇ  - Use thiserror                     ‚îÇ\n‚îÇ  - Include source errors             ‚îÇ\n‚îÇ  - No logging                        ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## Practical Examples\n\n### HTTP API Error Response\n```rust\nuse axum::{response::IntoResponse, http::StatusCode};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ErrorResponse {\n    error: String,\n    code: String,\n}\n\nenum AppError {\n    NotFound(String),\n    BadRequest(String),\n    Internal(anyhow::Error),\n}\n\nimpl IntoResponse for AppError {\n    fn into_response(self) -> axum::response::Response {\n        let (status, error, code) = match self {\n            AppError::NotFound(msg) => {\n                (StatusCode::NOT_FOUND, msg, \"NOT_FOUND\")\n            }\n            AppError::BadRequest(msg) => {\n                (StatusCode::BAD_REQUEST, msg, \"BAD_REQUEST\")\n            }\n            AppError::Internal(e) => {\n                tracing::error!(\"Internal error: {:#}\", e);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    \"Internal server error\".to_string(),\n                    \"INTERNAL_ERROR\",\n                )\n            }\n        };\n\n        let body = ErrorResponse {\n            error,\n            code: code.to_string(),\n        };\n\n        (status, axum::Json(body)).into_response()\n    }\n}\n```\n\n### CLI Error Handling\n```rust\nuse anyhow::{Context, Result};\nuse clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long)]\n    config: String,\n}\n\nfn main() {\n    if let Err(e) = run() {\n        eprintln!(\"Error: {:#}\", e);\n        std::process::exit(1);\n    }\n}\n\nfn run() -> Result<()> {\n    let args = Args::parse();\n\n    let config = std::fs::read_to_string(&args.config)\n        .context(format!(\"Failed to read config file: {}\", args.config))?;\n\n    let parsed: Config = toml::from_str(&config)\n        .context(\"Failed to parse config file\")?;\n\n    process(parsed)?;\n\n    println!(\"Done!\");\n    Ok(())\n}\n```\n\n---\n\n## Testing Error Handling\n\n### Testing Error Cases\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_not_found_error() {\n        let result = db.get_user(\"nonexistent\");\n\n        assert!(matches!(\n            result,\n            Err(DatabaseError::NotFound { table, id })\n            if table == \"users\" && id == \"nonexistent\"\n        ));\n    }\n\n    #[test]\n    fn test_error_message() {\n        let err = DatabaseError::NotFound {\n            table: \"users\".to_string(),\n            id: \"123\".to_string(),\n        };\n\n        assert_eq!(err.to_string(), \"record not found: users.123\");\n    }\n\n    #[test]\n    fn test_error_chain() {\n        let io_err = std::io::Error::new(\n            std::io::ErrorKind::ConnectionRefused,\n            \"connection refused\"\n        );\n\n        let err = DatabaseError::ConnectionFailed {\n            host: \"localhost\".to_string(),\n            port: 5432,\n            source: io_err,\n        };\n\n        // Check source is preserved\n        assert!(err.source().is_some());\n    }\n}\n```\n\n### Testing with anyhow\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_with_context() -> anyhow::Result<()> {\n        let result = process(\"valid input\")?;\n        assert_eq!(result, expected);\n        Ok(())\n    }\n\n    #[test]\n    fn test_error_context() {\n        let err = process(\"invalid\")\n            .context(\"processing failed\")\n            .unwrap_err();\n\n        // Check error chain contains expected text\n        let chain = format!(\"{:#}\", err);\n        assert!(chain.contains(\"processing failed\"));\n    }\n}\n```\n",
        "skills/m06-error-handling/patterns/error-patterns.md": "# Error Handling Patterns\n\n## The ? Operator\n\n### Basic Usage\n```rust\nfn read_config() -> Result<Config, io::Error> {\n    let content = std::fs::read_to_string(\"config.toml\")?;\n    let config: Config = toml::from_str(&content)?;  // needs From impl\n    Ok(config)\n}\n```\n\n### With Different Error Types\n```rust\nuse std::error::Error;\n\n// Box<dyn Error> for quick prototyping\nfn process() -> Result<(), Box<dyn Error>> {\n    let file = std::fs::read_to_string(\"data.txt\")?;\n    let num: i32 = file.trim().parse()?;  // different error type\n    Ok(())\n}\n```\n\n### Custom Conversion with From\n```rust\n#[derive(Debug)]\nenum MyError {\n    Io(std::io::Error),\n    Parse(std::num::ParseIntError),\n}\n\nimpl From<std::io::Error> for MyError {\n    fn from(err: std::io::Error) -> Self {\n        MyError::Io(err)\n    }\n}\n\nimpl From<std::num::ParseIntError> for MyError {\n    fn from(err: std::num::ParseIntError) -> Self {\n        MyError::Parse(err)\n    }\n}\n\nfn process() -> Result<i32, MyError> {\n    let content = std::fs::read_to_string(\"num.txt\")?;  // auto-converts\n    let num: i32 = content.trim().parse()?;  // auto-converts\n    Ok(num)\n}\n```\n\n---\n\n## Error Type Design\n\n### Simple Enum Error\n```rust\n#[derive(Debug, Clone, PartialEq)]\npub enum ConfigError {\n    NotFound,\n    InvalidFormat,\n    MissingField(String),\n}\n\nimpl std::fmt::Display for ConfigError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            ConfigError::NotFound => write!(f, \"configuration file not found\"),\n            ConfigError::InvalidFormat => write!(f, \"invalid configuration format\"),\n            ConfigError::MissingField(field) => write!(f, \"missing field: {}\", field),\n        }\n    }\n}\n\nimpl std::error::Error for ConfigError {}\n```\n\n### Error with Source (Wrapping)\n```rust\n#[derive(Debug)]\npub struct AppError {\n    kind: AppErrorKind,\n    source: Option<Box<dyn std::error::Error + Send + Sync>>,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum AppErrorKind {\n    Config,\n    Database,\n    Network,\n}\n\nimpl std::fmt::Display for AppError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self.kind {\n            AppErrorKind::Config => write!(f, \"configuration error\"),\n            AppErrorKind::Database => write!(f, \"database error\"),\n            AppErrorKind::Network => write!(f, \"network error\"),\n        }\n    }\n}\n\nimpl std::error::Error for AppError {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        self.source.as_ref().map(|e| e.as_ref() as _)\n    }\n}\n```\n\n---\n\n## Using thiserror\n\n### Basic Usage\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum DataError {\n    #[error(\"file not found: {path}\")]\n    NotFound { path: String },\n\n    #[error(\"invalid data format\")]\n    InvalidFormat,\n\n    #[error(\"IO error\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"parse error: {0}\")]\n    Parse(#[from] std::num::ParseIntError),\n}\n\n// Usage\nfn load_data(path: &str) -> Result<Data, DataError> {\n    let content = std::fs::read_to_string(path)\n        .map_err(|_| DataError::NotFound { path: path.to_string() })?;\n    let num: i32 = content.trim().parse()?;  // auto-converts with #[from]\n    Ok(Data { value: num })\n}\n```\n\n### Transparent Wrapper\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\n#[error(transparent)]\npub struct MyError(#[from] InnerError);\n\n// Useful for newtype error wrappers\n```\n\n---\n\n## Using anyhow\n\n### For Applications\n```rust\nuse anyhow::{Context, Result, bail, ensure};\n\nfn process_file(path: &str) -> Result<Data> {\n    let content = std::fs::read_to_string(path)\n        .context(\"failed to read config file\")?;\n\n    ensure!(!content.is_empty(), \"config file is empty\");\n\n    let data: Data = serde_json::from_str(&content)\n        .context(\"failed to parse JSON\")?;\n\n    if data.version < 1 {\n        bail!(\"unsupported config version: {}\", data.version);\n    }\n\n    Ok(data)\n}\n\nfn main() -> Result<()> {\n    let data = process_file(\"config.json\")\n        .context(\"failed to load configuration\")?;\n    Ok(())\n}\n```\n\n### Error Chain\n```rust\nuse anyhow::{Context, Result};\n\nfn deep_function() -> Result<()> {\n    std::fs::read_to_string(\"missing.txt\")\n        .context(\"failed to read file\")?;\n    Ok(())\n}\n\nfn middle_function() -> Result<()> {\n    deep_function()\n        .context(\"failed in deep function\")?;\n    Ok(())\n}\n\nfn top_function() -> Result<()> {\n    middle_function()\n        .context(\"failed in middle function\")?;\n    Ok(())\n}\n\n// Error output shows full chain:\n// Error: failed in middle function\n// Caused by:\n//     0: failed in deep function\n//     1: failed to read file\n//     2: No such file or directory (os error 2)\n```\n\n---\n\n## Option Handling\n\n### Converting Option to Result\n```rust\nfn find_user(id: u32) -> Option<User> { ... }\n\n// Using ok_or for static error\nfn get_user(id: u32) -> Result<User, &'static str> {\n    find_user(id).ok_or(\"user not found\")\n}\n\n// Using ok_or_else for dynamic error\nfn get_user(id: u32) -> Result<User, String> {\n    find_user(id).ok_or_else(|| format!(\"user {} not found\", id))\n}\n```\n\n### Chaining Options\n```rust\nfn get_nested_value(data: &Data) -> Option<&str> {\n    data.config\n        .as_ref()?\n        .nested\n        .as_ref()?\n        .value\n        .as_deref()\n}\n\n// Equivalent with and_then\nfn get_nested_value(data: &Data) -> Option<&str> {\n    data.config\n        .as_ref()\n        .and_then(|c| c.nested.as_ref())\n        .and_then(|n| n.value.as_deref())\n}\n```\n\n---\n\n## Pattern: Result Combinators\n\n### map and map_err\n```rust\nfn parse_port(s: &str) -> Result<u16, ParseError> {\n    s.parse::<u16>()\n        .map_err(|e| ParseError::InvalidPort(e))\n}\n\nfn get_url(config: &Config) -> Result<String, Error> {\n    config.url()\n        .map(|u| format!(\"https://{}\", u))\n}\n```\n\n### and_then (flatMap)\n```rust\nfn validate_and_save(input: &str) -> Result<(), Error> {\n    validate(input)\n        .and_then(|valid| save(valid))\n        .and_then(|saved| notify(saved))\n}\n```\n\n### unwrap_or and unwrap_or_else\n```rust\n// Default value\nlet port = config.port().unwrap_or(8080);\n\n// Computed default\nlet port = config.port().unwrap_or_else(|| find_free_port());\n\n// Default for Result\nlet data = load_data().unwrap_or_default();\n```\n\n---\n\n## Pattern: Early Return vs Combinators\n\n### Early Return Style\n```rust\nfn process(input: &str) -> Result<Output, Error> {\n    let step1 = validate(input)?;\n    if !step1.is_valid {\n        return Err(Error::Invalid);\n    }\n\n    let step2 = transform(step1)?;\n    let step3 = save(step2)?;\n\n    Ok(step3)\n}\n```\n\n### Combinator Style\n```rust\nfn process(input: &str) -> Result<Output, Error> {\n    validate(input)\n        .and_then(|s| {\n            if s.is_valid {\n                Ok(s)\n            } else {\n                Err(Error::Invalid)\n            }\n        })\n        .and_then(transform)\n        .and_then(save)\n}\n```\n\n### When to Use Which\n\n| Style | Best For |\n|-------|----------|\n| Early return (`?`) | Most cases, clearer flow |\n| Combinators | Functional pipelines, one-liners |\n| Match | Complex branching on errors |\n\n---\n\n## Panic vs Result\n\n### When to Panic\n```rust\n// 1. Unrecoverable programmer error\nfn get_config() -> &'static Config {\n    CONFIG.get().expect(\"config must be initialized\")\n}\n\n// 2. In tests\n#[test]\nfn test_parsing() {\n    let result = parse(\"valid\").unwrap();  // OK in tests\n    assert_eq!(result, expected);\n}\n\n// 3. Prototype/examples\nfn main() {\n    let data = load().unwrap();  // OK for quick examples\n}\n```\n\n### When to Return Result\n```rust\n// 1. Any I/O operation\nfn read_file(path: &str) -> Result<String, io::Error>\n\n// 2. User input validation\nfn parse_port(s: &str) -> Result<u16, ParseError>\n\n// 3. Network operations\nasync fn fetch(url: &str) -> Result<Response, Error>\n\n// 4. Anything that can fail at runtime\nfn connect(addr: &str) -> Result<Connection, Error>\n```\n\n---\n\n## Error Context Best Practices\n\n### Add Context at Boundaries\n```rust\nfn load_user_config(user_id: u64) -> Result<Config, Error> {\n    let path = format!(\"/home/{}/config.toml\", user_id);\n\n    std::fs::read_to_string(&path)\n        .context(format!(\"failed to read config for user {}\", user_id))?\n        // NOT: .context(\"failed to read file\")  // too generic\n\n    // ...\n}\n```\n\n### Include Relevant Data\n```rust\n// Good: includes the problematic value\nfn parse_age(s: &str) -> Result<u8, Error> {\n    s.parse()\n        .context(format!(\"invalid age value: '{}'\", s))\n}\n\n// Bad: no context about what failed\nfn parse_age(s: &str) -> Result<u8, Error> {\n    s.parse()\n        .context(\"parse error\")\n}\n```\n",
        "skills/m07-concurrency/SKILL.md": "---\nname: m07-concurrency\ndescription: \"CRITICAL: Use for concurrency/async. Triggers: E0277 Send Sync, cannot be sent between threads, thread, spawn, channel, mpsc, Mutex, RwLock, Atomic, async, await, Future, tokio, deadlock, race condition, Âπ∂Âèë, Á∫øÁ®ã, ÂºÇÊ≠•, Ê≠ªÈîÅ\"\nuser-invocable: false\n---\n\n# Concurrency\n\n> **Layer 1: Language Mechanics**\n\n## Core Question\n\n**Is this CPU-bound or I/O-bound, and what's the sharing model?**\n\nBefore choosing concurrency primitives:\n- What's the workload type?\n- What data needs to be shared?\n- What's the thread safety requirement?\n\n---\n\n## Error ‚Üí Design Question\n\n| Error | Don't Just Say | Ask Instead |\n|-------|----------------|-------------|\n| E0277 Send | \"Add Send bound\" | Should this type cross threads? |\n| E0277 Sync | \"Wrap in Mutex\" | Is shared access really needed? |\n| Future not Send | \"Use spawn_local\" | Is async the right choice? |\n| Deadlock | \"Reorder locks\" | Is the locking design correct? |\n\n---\n\n## Thinking Prompt\n\nBefore adding concurrency:\n\n1. **What's the workload?**\n   - CPU-bound ‚Üí threads (std::thread, rayon)\n   - I/O-bound ‚Üí async (tokio, async-std)\n   - Mixed ‚Üí hybrid approach\n\n2. **What's the sharing model?**\n   - No sharing ‚Üí message passing (channels)\n   - Immutable sharing ‚Üí Arc<T>\n   - Mutable sharing ‚Üí Arc<Mutex<T>> or Arc<RwLock<T>>\n\n3. **What are the Send/Sync requirements?**\n   - Cross-thread ownership ‚Üí Send\n   - Cross-thread references ‚Üí Sync\n   - Single-thread async ‚Üí spawn_local\n\n---\n\n## Trace Up ‚Üë (MANDATORY)\n\n**CRITICAL**: Don't just fix the error. Trace UP to find domain constraints.\n\n### Domain Detection Table\n\n| Context Keywords | Load Domain Skill | Key Constraint |\n|-----------------|-------------------|----------------|\n| Web API, HTTP, axum, actix, handler | **domain-web** | Handlers run on any thread |\n| ‰∫§Êòì, ÊîØ‰ªò, trading, payment | **domain-fintech** | Audit + thread safety |\n| gRPC, kubernetes, microservice | **domain-cloud-native** | Distributed tracing |\n| CLI, terminal, clap | **domain-cli** | Usually single-thread OK |\n\n### Example: Web API + Rc Error\n\n```\n\"Rc cannot be sent between threads\" in Web API context\n    ‚Üë DETECT: \"Web API\" ‚Üí Load domain-web\n    ‚Üë FIND: domain-web says \"Shared state must be thread-safe\"\n    ‚Üë FIND: domain-web says \"Rc in state\" is Common Mistake\n    ‚Üì DESIGN: Use Arc<T> with State extractor\n    ‚Üì IMPL: axum::extract::State<Arc<AppConfig>>\n```\n\n### Generic Trace\n\n```\n\"Send not satisfied for my type\"\n    ‚Üë Ask: What domain is this? Load domain-* skill\n    ‚Üë Ask: Does this type need to cross thread boundaries?\n    ‚Üë Check: m09-domain (is the data model correct?)\n```\n\n| Situation | Trace To | Question |\n|-----------|----------|----------|\n| Send/Sync in Web | **domain-web** | What's the state management pattern? |\n| Send/Sync in CLI | **domain-cli** | Is multi-thread really needed? |\n| Mutex vs channels | m09-domain | Shared state or message passing? |\n| Async vs threads | m10-performance | What's the workload profile? |\n\n---\n\n## Trace Down ‚Üì\n\nFrom design to implementation:\n\n```\n\"Need parallelism for CPU work\"\n    ‚Üì Use: std::thread or rayon\n\n\"Need concurrency for I/O\"\n    ‚Üì Use: async/await with tokio\n\n\"Need to share immutable data across threads\"\n    ‚Üì Use: Arc<T>\n\n\"Need to share mutable data across threads\"\n    ‚Üì Use: Arc<Mutex<T>> or Arc<RwLock<T>>\n    ‚Üì Or: channels for message passing\n\n\"Need simple atomic operations\"\n    ‚Üì Use: AtomicBool, AtomicUsize, etc.\n```\n\n---\n\n## Send/Sync Markers\n\n| Marker | Meaning | Example |\n|--------|---------|---------|\n| `Send` | Can transfer ownership between threads | Most types |\n| `Sync` | Can share references between threads | `Arc<T>` |\n| `!Send` | Must stay on one thread | `Rc<T>` |\n| `!Sync` | No shared refs across threads | `RefCell<T>` |\n\n## Quick Reference\n\n| Pattern | Thread-Safe | Blocking | Use When |\n|---------|-------------|----------|----------|\n| `std::thread` | Yes | Yes | CPU-bound parallelism |\n| `async/await` | Yes | No | I/O-bound concurrency |\n| `Mutex<T>` | Yes | Yes | Shared mutable state |\n| `RwLock<T>` | Yes | Yes | Read-heavy shared state |\n| `mpsc::channel` | Yes | Optional | Message passing |\n| `Arc<Mutex<T>>` | Yes | Yes | Shared mutable across threads |\n\n## Decision Flowchart\n\n```\nWhat type of work?\n‚îú‚îÄ CPU-bound ‚Üí std::thread or rayon\n‚îú‚îÄ I/O-bound ‚Üí async/await\n‚îî‚îÄ Mixed ‚Üí hybrid (spawn_blocking)\n\nNeed to share data?\n‚îú‚îÄ No ‚Üí message passing (channels)\n‚îú‚îÄ Immutable ‚Üí Arc<T>\n‚îî‚îÄ Mutable ‚Üí\n   ‚îú‚îÄ Read-heavy ‚Üí Arc<RwLock<T>>\n   ‚îî‚îÄ Write-heavy ‚Üí Arc<Mutex<T>>\n   ‚îî‚îÄ Simple counter ‚Üí AtomicUsize\n\nAsync context?\n‚îú‚îÄ Type is Send ‚Üí tokio::spawn\n‚îú‚îÄ Type is !Send ‚Üí spawn_local\n‚îî‚îÄ Blocking code ‚Üí spawn_blocking\n```\n\n---\n\n## Common Errors\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| E0277 `Send` not satisfied | Non-Send in async | Use Arc or spawn_local |\n| E0277 `Sync` not satisfied | Non-Sync shared | Wrap with Mutex |\n| Deadlock | Lock ordering | Consistent lock order |\n| `future is not Send` | Non-Send across await | Drop before await |\n| `MutexGuard` across await | Guard held during suspend | Scope guard properly |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| Arc<Mutex<T>> everywhere | Contention, complexity | Message passing |\n| thread::sleep in async | Blocks executor | tokio::time::sleep |\n| Holding locks across await | Blocks other tasks | Scope locks tightly |\n| Ignoring deadlock risk | Hard to debug | Lock ordering, try_lock |\n\n---\n\n## Async-Specific Patterns\n\n### Avoid MutexGuard Across Await\n\n```rust\n// Bad: guard held across await\nlet guard = mutex.lock().await;\ndo_async().await;  // guard still held!\n\n// Good: scope the lock\n{\n    let guard = mutex.lock().await;\n    // use guard\n}  // guard dropped\ndo_async().await;\n```\n\n### Non-Send Types in Async\n\n```rust\n// Rc is !Send, can't cross await in spawned task\n// Option 1: use Arc instead\n// Option 2: use spawn_local (single-thread runtime)\n// Option 3: ensure Rc is dropped before .await\n```\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Smart pointer choice | m02-resource |\n| Interior mutability | m03-mutability |\n| Performance tuning | m10-performance |\n| Domain concurrency needs | domain-* |\n",
        "skills/m07-concurrency/comparison.md": "# Concurrency: Comparison with Other Languages\n\n## Rust vs Go\n\n### Concurrency Model\n\n| Aspect | Rust | Go |\n|--------|------|-----|\n| Model | Ownership + Send/Sync | CSP (Communicating Sequential Processes) |\n| Primitives | Arc, Mutex, channels | goroutines, channels |\n| Safety | Compile-time | Runtime (race detector) |\n| Async | async/await + runtime | Built-in scheduler |\n\n### Goroutines vs Rust Tasks\n\n```rust\n// Rust: explicit about thread safety\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\nlet data = Arc::new(Mutex::new(vec![]));\nlet data_clone = Arc::clone(&data);\n\ntokio::spawn(async move {\n    let mut guard = data_clone.lock().await;\n    guard.push(1);  // Safe: Mutex protects access\n});\n\n// Go: implicit sharing (potential race)\n// data := []int{}\n// go func() {\n//     data = append(data, 1)  // RACE CONDITION!\n// }()\n```\n\n### Channel Comparison\n\n```rust\n// Rust: typed channels with ownership\nuse tokio::sync::mpsc;\n\nlet (tx, mut rx) = mpsc::channel::<String>(100);\n\ntokio::spawn(async move {\n    tx.send(\"hello\".to_string()).await.unwrap();\n    // tx is moved, can't be used elsewhere\n});\n\n// Go: channels are more flexible but less safe\n// ch := make(chan string, 100)\n// go func() {\n//     ch <- \"hello\"\n//     // ch can still be used anywhere\n// }()\n```\n\n---\n\n## Rust vs Java\n\n### Thread Safety Model\n\n| Aspect | Rust | Java |\n|--------|------|------|\n| Safety | Compile-time (Send/Sync) | Runtime (synchronized, volatile) |\n| Null | No null (Option) | NullPointerException risk |\n| Locks | RAII (drop releases) | try-finally or try-with-resources |\n| Memory | No GC | GC with stop-the-world |\n\n### Synchronization Comparison\n\n```rust\n// Rust: lock is tied to data\nuse std::sync::Mutex;\n\nlet data = Mutex::new(vec![1, 2, 3]);\n{\n    let mut guard = data.lock().unwrap();\n    guard.push(4);\n}  // lock released automatically\n\n// Java: lock and data are separate\n// List<Integer> data = new ArrayList<>();\n// synchronized(data) {\n//     data.add(4);\n// }  // easy to forget synchronization elsewhere\n```\n\n### Thread Pool Comparison\n\n```rust\n// Rust: rayon for data parallelism\nuse rayon::prelude::*;\n\nlet sum: i32 = (0..1000)\n    .into_par_iter()\n    .map(|x| x * x)\n    .sum();\n\n// Java: Stream API\n// int sum = IntStream.range(0, 1000)\n//     .parallel()\n//     .map(x -> x * x)\n//     .sum();\n```\n\n---\n\n## Rust vs C++\n\n### Safety Guarantees\n\n| Aspect | Rust | C++ |\n|--------|------|-----|\n| Data races | Prevented at compile-time | Undefined behavior |\n| Deadlocks | Not prevented (same as C++) | Not prevented |\n| Thread safety | Send/Sync traits | Convention only |\n| Memory ordering | Explicit Ordering enum | memory_order enum |\n\n### Atomic Comparison\n\n```rust\n// Rust: clear memory ordering\nuse std::sync::atomic::{AtomicI32, Ordering};\n\nlet counter = AtomicI32::new(0);\ncounter.fetch_add(1, Ordering::SeqCst);\nlet value = counter.load(Ordering::Acquire);\n\n// C++: similar but without safety\n// std::atomic<int> counter{0};\n// counter.fetch_add(1, std::memory_order_seq_cst);\n// int value = counter.load(std::memory_order_acquire);\n```\n\n### Mutex Comparison\n\n```rust\n// Rust: data protected by Mutex\nuse std::sync::Mutex;\n\nstruct SafeCounter {\n    count: Mutex<i32>,  // Mutex contains the data\n}\n\nimpl SafeCounter {\n    fn increment(&self) {\n        *self.count.lock().unwrap() += 1;\n    }\n}\n\n// C++: mutex separate from data (error-prone)\n// class Counter {\n//     std::mutex mtx;\n//     int count;  // NOT protected by type system\n// public:\n//     void increment() {\n//         std::lock_guard<std::mutex> lock(mtx);\n//         count++;\n//     }\n//     void unsafe_increment() {\n//         count++;  // Compiles! But wrong.\n//     }\n// };\n```\n\n---\n\n## Async Models Comparison\n\n| Language | Model | Runtime |\n|----------|-------|---------|\n| Rust | async/await, zero-cost | tokio, async-std (bring your own) |\n| Go | goroutines | Built-in scheduler |\n| JavaScript | async/await, Promises | Event loop (single-threaded) |\n| Python | async/await | asyncio (single-threaded) |\n| Java | CompletableFuture, Virtual Threads | ForkJoinPool, Loom |\n\n### Rust vs JavaScript Async\n\n```rust\n// Rust: async requires explicit runtime, can use multiple threads\n#[tokio::main]\nasync fn main() {\n    let results = tokio::join!(\n        fetch(\"url1\"),  // runs concurrently\n        fetch(\"url2\"),\n    );\n}\n\n// JavaScript: single-threaded event loop\n// async function main() {\n//     const results = await Promise.all([\n//         fetch(\"url1\"),\n//         fetch(\"url2\"),\n//     ]);\n// }\n```\n\n### Rust vs Python Async\n\n```rust\n// Rust: true parallelism possible\n#[tokio::main(flavor = \"multi_thread\")]\nasync fn main() {\n    let handles: Vec<_> = urls\n        .into_iter()\n        .map(|url| tokio::spawn(fetch(url)))  // spawns on thread pool\n        .collect();\n\n    for handle in handles {\n        let _ = handle.await;\n    }\n}\n\n// Python: asyncio is single-threaded (use ProcessPoolExecutor for CPU)\n# async def main():\n#     tasks = [asyncio.create_task(fetch(url)) for url in urls]\n#     await asyncio.gather(*tasks)  # all on same thread\n```\n\n---\n\n## Send and Sync: Rust's Unique Feature\n\nNo other mainstream language has compile-time thread safety markers:\n\n| Trait | Meaning | Auto-impl |\n|-------|---------|-----------|\n| `Send` | Safe to transfer between threads | Most types |\n| `Sync` | Safe to share `&T` between threads | Types with thread-safe `&` |\n| `!Send` | Must stay on one thread | Rc, raw pointers |\n| `!Sync` | References can't be shared | RefCell, Cell |\n\n### Why This Matters\n\n```rust\n// Rust PREVENTS this at compile time:\nuse std::rc::Rc;\n\nlet rc = Rc::new(42);\nstd::thread::spawn(move || {\n    println!(\"{}\", rc);  // ERROR: Rc is not Send\n});\n\n// In other languages, this would be a runtime bug:\n// - Go: race detector might catch it\n// - Java: undefined behavior\n// - Python: GIL usually saves you\n// - C++: undefined behavior\n```\n\n---\n\n## Performance Characteristics\n\n| Aspect | Rust | Go | Java | C++ |\n|--------|------|-----|------|-----|\n| Thread overhead | System threads or M:N | M:N (goroutines) | System or virtual | System threads |\n| Context switch | OS-level or cooperative | Cheap (goroutines) | OS-level | OS-level |\n| Memory | Predictable (no GC) | GC pauses | GC pauses | Predictable |\n| Async overhead | Zero-cost futures | Runtime overhead | Boxing overhead | Depends |\n\n### When to Use What\n\n| Scenario | Best Choice |\n|----------|-------------|\n| CPU-bound parallelism | Rust (rayon), C++ |\n| I/O-bound concurrency | Rust (tokio), Go, Node.js |\n| Low latency required | Rust, C++ |\n| Rapid development | Go, Python |\n| Complex concurrent state | Rust (compile-time safety) |\n\n---\n\n## Mental Model Shifts\n\n### From Go\n\n```\nBefore: \"Just use goroutines and channels\"\nAfter:  \"Explicitly declare what can be shared and how\"\n```\n\nKey shifts:\n- `Arc<Mutex<T>>` instead of implicit sharing\n- Compiler enforces thread safety\n- Async needs explicit runtime\n\n### From Java\n\n```\nBefore: \"synchronized everywhere, hope for the best\"\nAfter:  \"Types encode thread safety, compiler enforces\"\n```\n\nKey shifts:\n- No need for synchronized keyword\n- Mutex contains data, not separate\n- No GC pauses in critical sections\n\n### From C++\n\n```\nBefore: \"Be careful, read the docs, use sanitizers\"\nAfter:  \"Compiler catches data races, trust the type system\"\n```\n\nKey shifts:\n- Send/Sync replace convention\n- RAII locks are mandatory, not optional\n- Much harder to write incorrect concurrent code\n",
        "skills/m07-concurrency/examples/thread-patterns.md": "# Thread-Based Concurrency Patterns\n\n## Thread Spawning Best Practices\n\n### Basic Thread Spawn\n```rust\nuse std::thread;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        println!(\"Hello from thread!\");\n        42  // return value\n    });\n\n    let result = handle.join().unwrap();\n    println!(\"Thread returned: {}\", result);\n}\n```\n\n### Named Threads for Debugging\n```rust\nuse std::thread;\n\nlet builder = thread::Builder::new()\n    .name(\"worker-1\".to_string())\n    .stack_size(32 * 1024);  // 32KB stack\n\nlet handle = builder.spawn(|| {\n    println!(\"Thread name: {:?}\", thread::current().name());\n}).unwrap();\n```\n\n### Scoped Threads (No 'static Required)\n```rust\nuse std::thread;\n\nfn process_data(data: &[u32]) -> Vec<u32> {\n    thread::scope(|s| {\n        let handles: Vec<_> = data\n            .chunks(2)\n            .map(|chunk| {\n                s.spawn(|| {\n                    chunk.iter().map(|x| x * 2).collect::<Vec<_>>()\n                })\n            })\n            .collect();\n\n        handles\n            .into_iter()\n            .flat_map(|h| h.join().unwrap())\n            .collect()\n    })\n}\n\nfn main() {\n    let data = vec![1, 2, 3, 4, 5, 6];\n    let result = process_data(&data);  // No 'static needed!\n    println!(\"{:?}\", result);\n}\n```\n\n---\n\n## Shared State Patterns\n\n### Arc + Mutex (Read-Write)\n```rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn shared_counter() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n### Arc + RwLock (Read-Heavy)\n```rust\nuse std::sync::{Arc, RwLock};\nuse std::thread;\n\nfn read_heavy_cache() {\n    let cache = Arc::new(RwLock::new(vec![1, 2, 3]));\n\n    // Many readers\n    for i in 0..5 {\n        let cache = Arc::clone(&cache);\n        thread::spawn(move || {\n            let data = cache.read().unwrap();\n            println!(\"Reader {}: {:?}\", i, *data);\n        });\n    }\n\n    // Occasional writer\n    {\n        let cache = Arc::clone(&cache);\n        thread::spawn(move || {\n            let mut data = cache.write().unwrap();\n            data.push(4);\n            println!(\"Writer: added element\");\n        });\n    }\n}\n```\n\n### Atomic for Simple Types\n```rust\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\nuse std::thread;\n\nfn atomic_counter() {\n    let counter = Arc::new(AtomicUsize::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        handles.push(thread::spawn(move || {\n            for _ in 0..1000 {\n                counter.fetch_add(1, Ordering::SeqCst);\n            }\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", counter.load(Ordering::SeqCst));\n}\n```\n\n---\n\n## Channel Patterns\n\n### MPSC Channel\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn producer_consumer() {\n    let (tx, rx) = mpsc::channel();\n\n    // Multiple producers\n    for i in 0..3 {\n        let tx = tx.clone();\n        thread::spawn(move || {\n            for j in 0..5 {\n                tx.send(format!(\"msg {}-{}\", i, j)).unwrap();\n            }\n        });\n    }\n    drop(tx);  // Drop original sender\n\n    // Single consumer\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n```\n\n### Sync Channel (Bounded)\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn bounded_channel() {\n    let (tx, rx) = mpsc::sync_channel(2);  // buffer size 2\n\n    thread::spawn(move || {\n        for i in 0..5 {\n            println!(\"Sending {}\", i);\n            tx.send(i).unwrap();  // blocks if buffer full\n            println!(\"Sent {}\", i);\n        }\n    });\n\n    thread::sleep(std::time::Duration::from_millis(500));\n    for received in rx {\n        println!(\"Received: {}\", received);\n        thread::sleep(std::time::Duration::from_millis(100));\n    }\n}\n```\n\n---\n\n## Thread Pool Patterns\n\n### Using rayon for Parallel Iteration\n```rust\nuse rayon::prelude::*;\n\nfn parallel_map() {\n    let numbers: Vec<i32> = (0..1000).collect();\n\n    let squares: Vec<i32> = numbers\n        .par_iter()  // parallel iterator\n        .map(|x| x * x)\n        .collect();\n\n    println!(\"Processed {} items\", squares.len());\n}\n\nfn parallel_filter_map() {\n    let data: Vec<String> = get_data();\n\n    let results: Vec<_> = data\n        .par_iter()\n        .filter(|s| !s.is_empty())\n        .map(|s| expensive_process(s))\n        .collect();\n}\n```\n\n### Custom Thread Pool with crossbeam\n```rust\nuse crossbeam::channel;\nuse std::thread;\n\nfn custom_pool(num_workers: usize) {\n    let (tx, rx) = channel::bounded::<Box<dyn FnOnce() + Send>>(100);\n\n    // Spawn workers\n    let workers: Vec<_> = (0..num_workers)\n        .map(|_| {\n            let rx = rx.clone();\n            thread::spawn(move || {\n                while let Ok(task) = rx.recv() {\n                    task();\n                }\n            })\n        })\n        .collect();\n\n    // Submit tasks\n    for i in 0..100 {\n        tx.send(Box::new(move || {\n            println!(\"Processing task {}\", i);\n        })).unwrap();\n    }\n\n    drop(tx);  // Close channel\n\n    for worker in workers {\n        worker.join().unwrap();\n    }\n}\n```\n\n---\n\n## Synchronization Primitives\n\n### Barrier (Wait for All)\n```rust\nuse std::sync::{Arc, Barrier};\nuse std::thread;\n\nfn barrier_example() {\n    let barrier = Arc::new(Barrier::new(3));\n    let mut handles = vec![];\n\n    for i in 0..3 {\n        let barrier = Arc::clone(&barrier);\n        handles.push(thread::spawn(move || {\n            println!(\"Thread {} starting\", i);\n            thread::sleep(std::time::Duration::from_millis(i as u64 * 100));\n\n            barrier.wait();  // All threads wait here\n\n            println!(\"Thread {} after barrier\", i);\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n```\n\n### Condvar (Condition Variable)\n```rust\nuse std::sync::{Arc, Condvar, Mutex};\nuse std::thread;\n\nfn condvar_example() {\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair_clone = Arc::clone(&pair);\n\n    // Waiter thread\n    let waiter = thread::spawn(move || {\n        let (lock, cvar) = &*pair_clone;\n        let mut started = lock.lock().unwrap();\n        while !*started {\n            started = cvar.wait(started).unwrap();\n        }\n        println!(\"Waiter: condition met!\");\n    });\n\n    // Notifier\n    thread::sleep(std::time::Duration::from_millis(100));\n    let (lock, cvar) = &*pair;\n    {\n        let mut started = lock.lock().unwrap();\n        *started = true;\n    }\n    cvar.notify_one();\n\n    waiter.join().unwrap();\n}\n```\n\n### Once (One-Time Initialization)\n```rust\nuse std::sync::Once;\n\nstatic INIT: Once = Once::new();\nstatic mut CONFIG: Option<Config> = None;\n\nfn get_config() -> &'static Config {\n    INIT.call_once(|| {\n        unsafe {\n            CONFIG = Some(load_config());\n        }\n    });\n    unsafe { CONFIG.as_ref().unwrap() }\n}\n\n// Better: use once_cell or lazy_static\nuse once_cell::sync::Lazy;\n\nstatic CONFIG: Lazy<Config> = Lazy::new(|| {\n    load_config()\n});\n```\n\n---\n\n## Error Handling in Threads\n\n### Handling Panics\n```rust\nuse std::thread;\n\nfn handle_panic() {\n    let handle = thread::spawn(|| {\n        panic!(\"Thread panicked!\");\n    });\n\n    match handle.join() {\n        Ok(_) => println!(\"Thread completed successfully\"),\n        Err(e) => {\n            if let Some(s) = e.downcast_ref::<&str>() {\n                println!(\"Thread panicked with: {}\", s);\n            } else if let Some(s) = e.downcast_ref::<String>() {\n                println!(\"Thread panicked with: {}\", s);\n            } else {\n                println!(\"Thread panicked with unknown error\");\n            }\n        }\n    }\n}\n```\n\n### Catching Panics\n```rust\nuse std::panic;\n\nfn catch_panic() {\n    let result = panic::catch_unwind(|| {\n        risky_operation()\n    });\n\n    match result {\n        Ok(value) => println!(\"Success: {:?}\", value),\n        Err(_) => println!(\"Operation panicked, continuing...\"),\n    }\n}\n```\n",
        "skills/m07-concurrency/patterns/async-patterns.md": "# Async Patterns in Rust\n\n## Task Spawning\n\n### Basic Spawn\n```rust\nuse tokio::task;\n\n#[tokio::main]\nasync fn main() {\n    // Spawn a task that runs concurrently\n    let handle = task::spawn(async {\n        expensive_computation().await\n    });\n\n    // Do other work while task runs\n    other_work().await;\n\n    // Wait for result\n    let result = handle.await.unwrap();\n}\n```\n\n### Spawn with Shared State\n```rust\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\nasync fn process_with_state() {\n    let state = Arc::new(Mutex::new(vec![]));\n\n    let handles: Vec<_> = (0..10)\n        .map(|i| {\n            let state = Arc::clone(&state);\n            tokio::spawn(async move {\n                let mut guard = state.lock().await;\n                guard.push(i);\n            })\n        })\n        .collect();\n\n    // Wait for all tasks\n    for handle in handles {\n        handle.await.unwrap();\n    }\n}\n```\n\n---\n\n## Select Pattern\n\n### Racing Multiple Futures\n```rust\nuse tokio::select;\nuse tokio::time::{sleep, Duration};\n\nasync fn first_response() {\n    select! {\n        result = fetch_from_server_a() => {\n            println!(\"A responded first: {:?}\", result);\n        }\n        result = fetch_from_server_b() => {\n            println!(\"B responded first: {:?}\", result);\n        }\n    }\n}\n```\n\n### Select with Timeout\n```rust\nuse tokio::time::timeout;\n\nasync fn with_timeout() -> Result<Data, Error> {\n    select! {\n        result = fetch_data() => result,\n        _ = sleep(Duration::from_secs(5)) => {\n            Err(Error::Timeout)\n        }\n    }\n}\n\n// Or use timeout directly\nasync fn with_timeout2() -> Result<Data, Error> {\n    timeout(Duration::from_secs(5), fetch_data())\n        .await\n        .map_err(|_| Error::Timeout)?\n}\n```\n\n### Select with Channel\n```rust\nuse tokio::sync::mpsc;\n\nasync fn process_messages(mut rx: mpsc::Receiver<Message>) {\n    loop {\n        select! {\n            Some(msg) = rx.recv() => {\n                handle_message(msg).await;\n            }\n            _ = tokio::signal::ctrl_c() => {\n                println!(\"Shutting down...\");\n                break;\n            }\n        }\n    }\n}\n```\n\n---\n\n## Channel Patterns\n\n### MPSC (Multi-Producer, Single-Consumer)\n```rust\nuse tokio::sync::mpsc;\n\nasync fn producer_consumer() {\n    let (tx, mut rx) = mpsc::channel(100);\n\n    // Spawn producers\n    for i in 0..3 {\n        let tx = tx.clone();\n        tokio::spawn(async move {\n            tx.send(format!(\"Message from {}\", i)).await.unwrap();\n        });\n    }\n\n    // Drop original sender so channel closes\n    drop(tx);\n\n    // Consume\n    while let Some(msg) = rx.recv().await {\n        println!(\"Received: {}\", msg);\n    }\n}\n```\n\n### Oneshot (Single-Shot Response)\n```rust\nuse tokio::sync::oneshot;\n\nasync fn request_response() {\n    let (tx, rx) = oneshot::channel();\n\n    tokio::spawn(async move {\n        let result = compute_something().await;\n        tx.send(result).unwrap();\n    });\n\n    // Wait for response\n    let response = rx.await.unwrap();\n}\n```\n\n### Broadcast (Multi-Consumer)\n```rust\nuse tokio::sync::broadcast;\n\nasync fn pub_sub() {\n    let (tx, _) = broadcast::channel(16);\n\n    // Subscribe multiple consumers\n    let mut rx1 = tx.subscribe();\n    let mut rx2 = tx.subscribe();\n\n    tokio::spawn(async move {\n        while let Ok(msg) = rx1.recv().await {\n            println!(\"Consumer 1: {}\", msg);\n        }\n    });\n\n    tokio::spawn(async move {\n        while let Ok(msg) = rx2.recv().await {\n            println!(\"Consumer 2: {}\", msg);\n        }\n    });\n\n    // Publish\n    tx.send(\"Hello\").unwrap();\n}\n```\n\n### Watch (Single Latest Value)\n```rust\nuse tokio::sync::watch;\n\nasync fn config_updates() {\n    let (tx, mut rx) = watch::channel(Config::default());\n\n    // Consumer watches for changes\n    tokio::spawn(async move {\n        while rx.changed().await.is_ok() {\n            let config = rx.borrow();\n            apply_config(&config);\n        }\n    });\n\n    // Update config\n    tx.send(Config::new()).unwrap();\n}\n```\n\n---\n\n## Structured Concurrency\n\n### JoinSet for Task Groups\n```rust\nuse tokio::task::JoinSet;\n\nasync fn parallel_fetch(urls: Vec<String>) -> Vec<Result<Response, Error>> {\n    let mut set = JoinSet::new();\n\n    for url in urls {\n        set.spawn(async move {\n            fetch(&url).await\n        });\n    }\n\n    let mut results = vec![];\n    while let Some(res) = set.join_next().await {\n        results.push(res.unwrap());\n    }\n    results\n}\n```\n\n### Scoped Tasks (no 'static)\n```rust\n// Using tokio-scoped or async-scoped crate\nuse async_scoped::TokioScope;\n\nasync fn scoped_example(data: &[u32]) {\n    let results = TokioScope::scope_and_block(|scope| {\n        for item in data {\n            scope.spawn(async move {\n                process(item).await\n            });\n        }\n    });\n}\n```\n\n---\n\n## Cancellation Patterns\n\n### Using CancellationToken\n```rust\nuse tokio_util::sync::CancellationToken;\n\nasync fn cancellable_task(token: CancellationToken) {\n    loop {\n        select! {\n            _ = token.cancelled() => {\n                println!(\"Task cancelled\");\n                break;\n            }\n            _ = do_work() => {\n                // Continue working\n            }\n        }\n    }\n}\n\nasync fn main_with_cancellation() {\n    let token = CancellationToken::new();\n    let task_token = token.clone();\n\n    let handle = tokio::spawn(cancellable_task(task_token));\n\n    // Cancel after some condition\n    tokio::time::sleep(Duration::from_secs(5)).await;\n    token.cancel();\n\n    handle.await.unwrap();\n}\n```\n\n### Graceful Shutdown\n```rust\nasync fn serve_with_shutdown(shutdown: impl Future) {\n    let server = TcpListener::bind(\"0.0.0.0:8080\").await.unwrap();\n\n    loop {\n        select! {\n            Ok((socket, _)) = server.accept() => {\n                tokio::spawn(handle_connection(socket));\n            }\n            _ = &mut shutdown => {\n                println!(\"Shutting down...\");\n                break;\n            }\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let ctrl_c = async {\n        tokio::signal::ctrl_c().await.unwrap();\n    };\n\n    serve_with_shutdown(ctrl_c).await;\n}\n```\n\n---\n\n## Backpressure Patterns\n\n### Bounded Channels\n```rust\nuse tokio::sync::mpsc;\n\nasync fn with_backpressure() {\n    // Buffer of 10 - producers will wait if full\n    let (tx, mut rx) = mpsc::channel(10);\n\n    let producer = tokio::spawn(async move {\n        for i in 0..1000 {\n            // This will wait if channel is full\n            tx.send(i).await.unwrap();\n        }\n    });\n\n    let consumer = tokio::spawn(async move {\n        while let Some(item) = rx.recv().await {\n            // Slow consumer\n            tokio::time::sleep(Duration::from_millis(10)).await;\n            process(item);\n        }\n    });\n\n    let _ = tokio::join!(producer, consumer);\n}\n```\n\n### Semaphore for Rate Limiting\n```rust\nuse tokio::sync::Semaphore;\nuse std::sync::Arc;\n\nasync fn rate_limited_requests(urls: Vec<String>) {\n    let semaphore = Arc::new(Semaphore::new(10));  // max 10 concurrent\n\n    let handles: Vec<_> = urls\n        .into_iter()\n        .map(|url| {\n            let sem = Arc::clone(&semaphore);\n            tokio::spawn(async move {\n                let _permit = sem.acquire().await.unwrap();\n                fetch(&url).await\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.await.unwrap();\n    }\n}\n```\n\n---\n\n## Error Handling in Async\n\n### Propagating Errors\n```rust\nasync fn fetch_and_parse(url: &str) -> Result<Data, Error> {\n    let response = fetch(url).await?;\n    let data = parse(response).await?;\n    Ok(data)\n}\n```\n\n### Handling Task Panics\n```rust\nasync fn robust_spawn() {\n    let handle = tokio::spawn(async {\n        risky_operation().await\n    });\n\n    match handle.await {\n        Ok(result) => println!(\"Success: {:?}\", result),\n        Err(e) if e.is_panic() => {\n            println!(\"Task panicked: {:?}\", e);\n        }\n        Err(e) => {\n            println!(\"Task cancelled: {:?}\", e);\n        }\n    }\n}\n```\n\n### Try-Join for Multiple Results\n```rust\nuse tokio::try_join;\n\nasync fn fetch_all() -> Result<(A, B, C), Error> {\n    // All must succeed, or first error returned\n    try_join!(\n        fetch_a(),\n        fetch_b(),\n        fetch_c(),\n    )\n}\n```\n",
        "skills/m07-concurrency/patterns/common-errors.md": "# Common Concurrency Errors & Fixes\n\n## E0277: Cannot Send Between Threads\n\n### Error Pattern\n```rust\nuse std::rc::Rc;\n\nlet data = Rc::new(42);\nstd::thread::spawn(move || {\n    println!(\"{}\", data);  // ERROR: Rc<i32> cannot be sent between threads\n});\n```\n\n### Fix Options\n\n**Option 1: Use Arc instead**\n```rust\nuse std::sync::Arc;\n\nlet data = Arc::new(42);\nlet data_clone = Arc::clone(&data);\nstd::thread::spawn(move || {\n    println!(\"{}\", data_clone);  // OK: Arc is Send\n});\n```\n\n**Option 2: Move owned data**\n```rust\nlet data = 42;  // i32 is Copy and Send\nstd::thread::spawn(move || {\n    println!(\"{}\", data);  // OK\n});\n```\n\n---\n\n## E0277: Cannot Share Between Threads (Not Sync)\n\n### Error Pattern\n```rust\nuse std::cell::RefCell;\nuse std::sync::Arc;\n\nlet data = Arc::new(RefCell::new(42));\n// ERROR: RefCell is not Sync\n```\n\n### Fix Options\n\n**Option 1: Use Mutex for thread-safe interior mutability**\n```rust\nuse std::sync::{Arc, Mutex};\n\nlet data = Arc::new(Mutex::new(42));\nlet data_clone = Arc::clone(&data);\nstd::thread::spawn(move || {\n    let mut guard = data_clone.lock().unwrap();\n    *guard += 1;\n});\n```\n\n**Option 2: Use RwLock for read-heavy workloads**\n```rust\nuse std::sync::{Arc, RwLock};\n\nlet data = Arc::new(RwLock::new(42));\nlet data_clone = Arc::clone(&data);\nstd::thread::spawn(move || {\n    let guard = data_clone.read().unwrap();\n    println!(\"{}\", *guard);\n});\n```\n\n---\n\n## Deadlock Patterns\n\n### Pattern 1: Lock Ordering Deadlock\n```rust\n// DANGER: potential deadlock\nuse std::sync::{Arc, Mutex};\n\nlet a = Arc::new(Mutex::new(1));\nlet b = Arc::new(Mutex::new(2));\n\n// Thread 1: locks a then b\nlet a1 = Arc::clone(&a);\nlet b1 = Arc::clone(&b);\nstd::thread::spawn(move || {\n    let _a = a1.lock().unwrap();\n    let _b = b1.lock().unwrap();  // waits for b\n});\n\n// Thread 2: locks b then a (opposite order!)\nlet a2 = Arc::clone(&a);\nlet b2 = Arc::clone(&b);\nstd::thread::spawn(move || {\n    let _b = b2.lock().unwrap();\n    let _a = a2.lock().unwrap();  // waits for a - DEADLOCK\n});\n```\n\n### Fix: Consistent Lock Ordering\n```rust\n// SAFE: always lock in same order (a before b)\nstd::thread::spawn(move || {\n    let _a = a1.lock().unwrap();\n    let _b = b1.lock().unwrap();\n});\n\nstd::thread::spawn(move || {\n    let _a = a2.lock().unwrap();  // same order\n    let _b = b2.lock().unwrap();\n});\n```\n\n### Pattern 2: Self-Deadlock\n```rust\n// DANGER: locking same mutex twice\nlet m = Mutex::new(42);\nlet _g1 = m.lock().unwrap();\nlet _g2 = m.lock().unwrap();  // DEADLOCK on std::Mutex\n\n// FIX: use parking_lot::ReentrantMutex if needed\n// or restructure code to avoid double locking\n```\n\n---\n\n## Mutex Guard Across Await\n\n### Error Pattern\n```rust\nuse std::sync::Mutex;\nuse tokio::time::sleep;\n\nasync fn bad_async() {\n    let m = Mutex::new(42);\n    let guard = m.lock().unwrap();\n    sleep(Duration::from_secs(1)).await;  // WARNING: guard held across await\n    println!(\"{}\", *guard);\n}\n```\n\n### Fix Options\n\n**Option 1: Scope the lock**\n```rust\nasync fn good_async() {\n    let m = Mutex::new(42);\n    let value = {\n        let guard = m.lock().unwrap();\n        *guard  // copy value\n    };  // guard dropped here\n    sleep(Duration::from_secs(1)).await;\n    println!(\"{}\", value);\n}\n```\n\n**Option 2: Use tokio::sync::Mutex**\n```rust\nuse tokio::sync::Mutex;\n\nasync fn good_async() {\n    let m = Mutex::new(42);\n    let guard = m.lock().await;  // async lock\n    sleep(Duration::from_secs(1)).await;  // OK with tokio::Mutex\n    println!(\"{}\", *guard);\n}\n```\n\n---\n\n## Data Race Prevention\n\n### Pattern: Missing Synchronization\n```rust\n// This WON'T compile - Rust prevents data races\nuse std::sync::Arc;\n\nlet data = Arc::new(0);\nlet d1 = Arc::clone(&data);\nlet d2 = Arc::clone(&data);\n\nstd::thread::spawn(move || {\n    // *d1 += 1;  // ERROR: cannot mutate through Arc\n});\n\nstd::thread::spawn(move || {\n    // *d2 += 1;  // ERROR: cannot mutate through Arc\n});\n```\n\n### Fix: Add Synchronization\n```rust\nuse std::sync::{Arc, Mutex};\nuse std::sync::atomic::{AtomicI32, Ordering};\n\n// Option 1: Mutex\nlet data = Arc::new(Mutex::new(0));\nlet d1 = Arc::clone(&data);\nstd::thread::spawn(move || {\n    *d1.lock().unwrap() += 1;\n});\n\n// Option 2: Atomic (for simple types)\nlet data = Arc::new(AtomicI32::new(0));\nlet d1 = Arc::clone(&data);\nstd::thread::spawn(move || {\n    d1.fetch_add(1, Ordering::SeqCst);\n});\n```\n\n---\n\n## Channel Errors\n\n### Disconnected Channel\n```rust\nuse std::sync::mpsc;\n\nlet (tx, rx) = mpsc::channel();\ndrop(tx);  // sender dropped\nmatch rx.recv() {\n    Ok(v) => println!(\"{}\", v),\n    Err(_) => println!(\"channel disconnected\"),  // this happens\n}\n```\n\n### Fix: Handle Disconnection\n```rust\n// Use try_recv for non-blocking\nloop {\n    match rx.try_recv() {\n        Ok(msg) => handle(msg),\n        Err(TryRecvError::Empty) => continue,\n        Err(TryRecvError::Disconnected) => break,\n    }\n}\n\n// Or iterate (stops on disconnect)\nfor msg in rx {\n    handle(msg);\n}\n```\n\n---\n\n## Async Common Errors\n\n### Forgetting to Spawn\n```rust\n// WRONG: future not polled\nasync fn fetch_data() -> Result<Data, Error> { ... }\n\nfn process() {\n    fetch_data();  // does nothing! returns Future that's dropped\n}\n\n// RIGHT: await or spawn\nasync fn process() {\n    let data = fetch_data().await;  // awaited\n}\n\nfn process_sync() {\n    tokio::spawn(fetch_data());  // spawned\n}\n```\n\n### Blocking in Async Context\n```rust\n// WRONG: blocks the executor\nasync fn bad() {\n    std::thread::sleep(Duration::from_secs(1));  // blocks!\n    std::fs::read_to_string(\"file.txt\").unwrap();  // blocks!\n}\n\n// RIGHT: use async versions\nasync fn good() {\n    tokio::time::sleep(Duration::from_secs(1)).await;\n    tokio::fs::read_to_string(\"file.txt\").await.unwrap();\n}\n\n// Or spawn_blocking for CPU-bound work\nasync fn compute() {\n    let result = tokio::task::spawn_blocking(|| {\n        heavy_computation()  // OK to block here\n    }).await.unwrap();\n}\n```\n\n---\n\n## Thread Panic Handling\n\n### Unhandled Panic\n```rust\nlet handle = std::thread::spawn(|| {\n    panic!(\"oops\");\n});\n\n// Main thread continues, might miss the error\nhandle.join().unwrap();  // panics here\n```\n\n### Proper Error Handling\n```rust\nlet handle = std::thread::spawn(|| {\n    panic!(\"oops\");\n});\n\nmatch handle.join() {\n    Ok(result) => println!(\"Success: {:?}\", result),\n    Err(e) => println!(\"Thread panicked: {:?}\", e),\n}\n\n// For async: use catch_unwind\nuse std::panic;\n\nasync fn safe_task() {\n    let result = panic::catch_unwind(|| {\n        risky_operation()\n    });\n\n    match result {\n        Ok(v) => use_value(v),\n        Err(_) => log_error(\"task panicked\"),\n    }\n}\n```\n",
        "skills/m09-domain/SKILL.md": "---\nname: m09-domain\ndescription: \"CRITICAL: Use for domain modeling. Triggers: domain model, DDD, domain-driven design, entity, value object, aggregate, repository pattern, business rules, validation, invariant, È¢ÜÂüüÊ®°Âûã, È¢ÜÂüüÈ©±Âä®ËÆæËÆ°, ‰∏öÂä°ËßÑÂàô\"\nuser-invocable: false\n---\n\n# Domain Modeling\n\n> **Layer 2: Design Choices**\n\n## Core Question\n\n**What is this concept's role in the domain?**\n\nBefore modeling in code, understand:\n- Is it an Entity (identity matters) or Value Object (interchangeable)?\n- What invariants must be maintained?\n- Where are the aggregate boundaries?\n\n---\n\n## Domain Concept ‚Üí Rust Pattern\n\n| Domain Concept | Rust Pattern | Ownership Implication |\n|----------------|--------------|----------------------|\n| Entity | struct + Id | Owned, unique identity |\n| Value Object | struct + Clone/Copy | Shareable, immutable |\n| Aggregate Root | struct owns children | Clear ownership tree |\n| Repository | trait | Abstracts persistence |\n| Domain Event | enum | Captures state changes |\n| Service | impl block / free fn | Stateless operations |\n\n---\n\n## Thinking Prompt\n\nBefore creating a domain type:\n\n1. **What's the concept's identity?**\n   - Needs unique identity ‚Üí Entity (Id field)\n   - Interchangeable by value ‚Üí Value Object (Clone/Copy)\n\n2. **What invariants must hold?**\n   - Always valid ‚Üí private fields + validated constructor\n   - Transition rules ‚Üí type state pattern\n\n3. **Who owns this data?**\n   - Single owner (parent) ‚Üí owned field\n   - Shared reference ‚Üí Arc/Rc\n   - Weak reference ‚Üí Weak\n\n---\n\n## Trace Up ‚Üë\n\nTo domain constraints (Layer 3):\n\n```\n\"How should I model a Transaction?\"\n    ‚Üë Ask: What domain rules govern transactions?\n    ‚Üë Check: domain-fintech (audit, precision requirements)\n    ‚Üë Check: Business stakeholders (what invariants?)\n```\n\n| Design Question | Trace To | Ask |\n|-----------------|----------|-----|\n| Entity vs Value Object | domain-* | What makes two instances \"the same\"? |\n| Aggregate boundaries | domain-* | What must be consistent together? |\n| Validation rules | domain-* | What business rules apply? |\n\n---\n\n## Trace Down ‚Üì\n\nTo implementation (Layer 1):\n\n```\n\"Model as Entity\"\n    ‚Üì m01-ownership: Owned, unique\n    ‚Üì m05-type-driven: Newtype for Id\n\n\"Model as Value Object\"\n    ‚Üì m01-ownership: Clone/Copy OK\n    ‚Üì m05-type-driven: Validate at construction\n\n\"Model as Aggregate\"\n    ‚Üì m01-ownership: Parent owns children\n    ‚Üì m02-resource: Consider Rc for shared within aggregate\n```\n\n---\n\n## Quick Reference\n\n| DDD Concept | Rust Pattern | Example |\n|-------------|--------------|---------|\n| Value Object | Newtype | `struct Email(String);` |\n| Entity | Struct + ID | `struct User { id: UserId, ... }` |\n| Aggregate | Module boundary | `mod order { ... }` |\n| Repository | Trait | `trait UserRepo { fn find(...) }` |\n| Domain Event | Enum | `enum OrderEvent { Created, ... }` |\n\n## Pattern Templates\n\n### Value Object\n\n```rust\nstruct Email(String);\n\nimpl Email {\n    pub fn new(s: &str) -> Result<Self, ValidationError> {\n        validate_email(s)?;\n        Ok(Self(s.to_string()))\n    }\n}\n```\n\n### Entity\n\n```rust\nstruct UserId(Uuid);\n\nstruct User {\n    id: UserId,\n    email: Email,\n    // ... other fields\n}\n\nimpl PartialEq for User {\n    fn eq(&self, other: &Self) -> bool {\n        self.id == other.id  // Identity equality\n    }\n}\n```\n\n### Aggregate\n\n```rust\nmod order {\n    pub struct Order {\n        id: OrderId,\n        items: Vec<OrderItem>,  // Owned children\n        // ...\n    }\n\n    impl Order {\n        pub fn add_item(&mut self, item: OrderItem) {\n            // Enforce aggregate invariants\n        }\n    }\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Why Wrong | Better |\n|---------|-----------|--------|\n| Primitive obsession | No type safety | Newtype wrappers |\n| Public fields with invariants | Invariants violated | Private + accessor |\n| Leaked aggregate internals | Broken encapsulation | Methods on root |\n| String for semantic types | No validation | Validated newtype |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Type-driven implementation | m05-type-driven |\n| Ownership for aggregates | m01-ownership |\n| Domain error handling | m13-domain-error |\n| Specific domain rules | domain-* |\n",
        "skills/m10-performance/SKILL.md": "---\nname: m10-performance\ndescription: \"CRITICAL: Use for performance optimization. Triggers: performance, optimization, benchmark, profiling, flamegraph, criterion, slow, fast, allocation, cache, SIMD, make it faster, ÊÄßËÉΩ‰ºòÂåñ, Âü∫ÂáÜÊµãËØï\"\nuser-invocable: false\n---\n\n# Performance Optimization\n\n> **Layer 2: Design Choices**\n\n## Core Question\n\n**What's the bottleneck, and is optimization worth it?**\n\nBefore optimizing:\n- Have you measured? (Don't guess)\n- What's the acceptable performance?\n- Will optimization add complexity?\n\n---\n\n## Performance Decision ‚Üí Implementation\n\n| Goal | Design Choice | Implementation |\n|------|---------------|----------------|\n| Reduce allocations | Pre-allocate, reuse | `with_capacity`, object pools |\n| Improve cache | Contiguous data | `Vec`, `SmallVec` |\n| Parallelize | Data parallelism | `rayon`, threads |\n| Avoid copies | Zero-copy | References, `Cow<T>` |\n| Reduce indirection | Inline data | `smallvec`, arrays |\n\n---\n\n## Thinking Prompt\n\nBefore optimizing:\n\n1. **Have you measured?**\n   - Profile first ‚Üí flamegraph, perf\n   - Benchmark ‚Üí criterion, cargo bench\n   - Identify actual hotspots\n\n2. **What's the priority?**\n   - Algorithm (10x-1000x improvement)\n   - Data structure (2x-10x)\n   - Allocation (2x-5x)\n   - Cache (1.5x-3x)\n\n3. **What's the trade-off?**\n   - Complexity vs speed\n   - Memory vs CPU\n   - Latency vs throughput\n\n---\n\n## Trace Up ‚Üë\n\nTo domain constraints (Layer 3):\n\n```\n\"How fast does this need to be?\"\n    ‚Üë Ask: What's the performance SLA?\n    ‚Üë Check: domain-* (latency requirements)\n    ‚Üë Check: Business requirements (acceptable response time)\n```\n\n| Question | Trace To | Ask |\n|----------|----------|-----|\n| Latency requirements | domain-* | What's acceptable response time? |\n| Throughput needs | domain-* | How many requests per second? |\n| Memory constraints | domain-* | What's the memory budget? |\n\n---\n\n## Trace Down ‚Üì\n\nTo implementation (Layer 1):\n\n```\n\"Need to reduce allocations\"\n    ‚Üì m01-ownership: Use references, avoid clone\n    ‚Üì m02-resource: Pre-allocate with_capacity\n\n\"Need to parallelize\"\n    ‚Üì m07-concurrency: Choose rayon or threads\n    ‚Üì m07-concurrency: Consider async for I/O-bound\n\n\"Need cache efficiency\"\n    ‚Üì Data layout: Prefer Vec over HashMap when possible\n    ‚Üì Access patterns: Sequential over random access\n```\n\n---\n\n## Quick Reference\n\n| Tool | Purpose |\n|------|---------|\n| `cargo bench` | Micro-benchmarks |\n| `criterion` | Statistical benchmarks |\n| `perf` / `flamegraph` | CPU profiling |\n| `heaptrack` | Allocation tracking |\n| `valgrind` / `cachegrind` | Cache analysis |\n\n## Optimization Priority\n\n```\n1. Algorithm choice     (10x - 1000x)\n2. Data structure       (2x - 10x)\n3. Allocation reduction (2x - 5x)\n4. Cache optimization   (1.5x - 3x)\n5. SIMD/Parallelism     (2x - 8x)\n```\n\n## Common Techniques\n\n| Technique | When | How |\n|-----------|------|-----|\n| Pre-allocation | Known size | `Vec::with_capacity(n)` |\n| Avoid cloning | Hot paths | Use references or `Cow<T>` |\n| Batch operations | Many small ops | Collect then process |\n| SmallVec | Usually small | `smallvec::SmallVec<[T; N]>` |\n| Inline buffers | Fixed-size data | Arrays over Vec |\n\n---\n\n## Common Mistakes\n\n| Mistake | Why Wrong | Better |\n|---------|-----------|--------|\n| Optimize without profiling | Wrong target | Profile first |\n| Benchmark in debug mode | Meaningless | Always `--release` |\n| Use LinkedList | Cache unfriendly | `Vec` or `VecDeque` |\n| Hidden `.clone()` | Unnecessary allocs | Use references |\n| Premature optimization | Wasted effort | Make it work first |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| Clone to avoid lifetimes | Performance cost | Proper ownership |\n| Box everything | Indirection cost | Stack when possible |\n| HashMap for small sets | Overhead | Vec with linear search |\n| String concat in loop | O(n^2) | `String::with_capacity` or `format!` |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Reducing clones | m01-ownership |\n| Concurrency options | m07-concurrency |\n| Smart pointer choice | m02-resource |\n| Domain requirements | domain-* |\n",
        "skills/m10-performance/patterns/optimization-guide.md": "# Rust Performance Optimization Guide\n\n## Profiling First\n\n### Tools\n```bash\n# CPU profiling\ncargo install flamegraph\ncargo flamegraph --bin myapp\n\n# Memory profiling\ncargo install cargo-instruments  # macOS\nheaptrack ./target/release/myapp  # Linux\n\n# Benchmarking\ncargo bench  # with criterion\n\n# Cache analysis\nvalgrind --tool=cachegrind ./target/release/myapp\n```\n\n### Criterion Benchmarks\n```rust\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nfn benchmark_parse(c: &mut Criterion) {\n    let input = \"test data\".repeat(1000);\n\n    c.bench_function(\"parse_v1\", |b| {\n        b.iter(|| parse_v1(&input))\n    });\n\n    c.bench_function(\"parse_v2\", |b| {\n        b.iter(|| parse_v2(&input))\n    });\n}\n\ncriterion_group!(benches, benchmark_parse);\ncriterion_main!(benches);\n```\n\n---\n\n## Common Optimizations\n\n### 1. Avoid Unnecessary Allocations\n\n```rust\n// BAD: allocates on every call\nfn to_uppercase(s: &str) -> String {\n    s.to_uppercase()\n}\n\n// GOOD: return Cow, allocate only if needed\nuse std::borrow::Cow;\n\nfn to_uppercase(s: &str) -> Cow<'_, str> {\n    if s.chars().all(|c| c.is_uppercase()) {\n        Cow::Borrowed(s)\n    } else {\n        Cow::Owned(s.to_uppercase())\n    }\n}\n```\n\n### 2. Reuse Allocations\n\n```rust\n// BAD: creates new Vec each iteration\nfor item in items {\n    let mut buffer = Vec::new();\n    process(&mut buffer, item);\n}\n\n// GOOD: reuse buffer\nlet mut buffer = Vec::new();\nfor item in items {\n    buffer.clear();\n    process(&mut buffer, item);\n}\n```\n\n### 3. Use Appropriate Collections\n\n| Need | Collection | Notes |\n|------|------------|-------|\n| Sequential access | `Vec<T>` | Best cache locality |\n| Random access by key | `HashMap<K, V>` | O(1) lookup |\n| Ordered keys | `BTreeMap<K, V>` | O(log n) lookup |\n| Small sets (<20) | `Vec<T>` + linear search | Lower overhead |\n| FIFO queue | `VecDeque<T>` | O(1) push/pop both ends |\n\n### 4. Pre-allocate Capacity\n\n```rust\n// BAD: many reallocations\nlet mut v = Vec::new();\nfor i in 0..10000 {\n    v.push(i);\n}\n\n// GOOD: single allocation\nlet mut v = Vec::with_capacity(10000);\nfor i in 0..10000 {\n    v.push(i);\n}\n```\n\n---\n\n## String Optimization\n\n### Avoid String Concatenation in Loops\n\n```rust\n// BAD: O(n¬≤) allocations\nlet mut result = String::new();\nfor s in strings {\n    result = result + &s;\n}\n\n// GOOD: O(n) with push_str\nlet mut result = String::new();\nfor s in strings {\n    result.push_str(&s);\n}\n\n// BETTER: pre-calculate capacity\nlet total_len: usize = strings.iter().map(|s| s.len()).sum();\nlet mut result = String::with_capacity(total_len);\nfor s in strings {\n    result.push_str(&s);\n}\n\n// BEST: use join for simple cases\nlet result = strings.join(\"\");\n```\n\n### Use &str When Possible\n\n```rust\n// BAD: requires allocation\nfn greet(name: String) {\n    println!(\"Hello, {}\", name);\n}\n\n// GOOD: borrows, no allocation\nfn greet(name: &str) {\n    println!(\"Hello, {}\", name);\n}\n\n// Works with both:\ngreet(\"world\");                    // &str\ngreet(&String::from(\"world\"));     // &String coerces to &str\n```\n\n---\n\n## Iterator Optimization\n\n### Use Iterators Over Indexing\n\n```rust\n// BAD: bounds checking on each access\nlet mut sum = 0;\nfor i in 0..vec.len() {\n    sum += vec[i];\n}\n\n// GOOD: no bounds checking\nlet sum: i32 = vec.iter().sum();\n\n// GOOD: when index needed\nfor (i, item) in vec.iter().enumerate() {\n    // ...\n}\n```\n\n### Lazy Evaluation\n\n```rust\n// Iterators are lazy - computation happens at collect\nlet result: Vec<_> = data\n    .iter()\n    .filter(|x| x.is_valid())\n    .map(|x| x.process())\n    .take(10)  // stop after 10 items\n    .collect();\n```\n\n### Avoid Collecting When Not Needed\n\n```rust\n// BAD: unnecessary intermediate allocation\nlet filtered: Vec<_> = items.iter().filter(|x| x.valid).collect();\nlet count = filtered.len();\n\n// GOOD: no allocation\nlet count = items.iter().filter(|x| x.valid).count();\n```\n\n---\n\n## Parallelism with Rayon\n\n```rust\nuse rayon::prelude::*;\n\n// Sequential\nlet sum: i32 = (0..1_000_000).map(|x| x * x).sum();\n\n// Parallel (automatic work stealing)\nlet sum: i32 = (0..1_000_000).into_par_iter().map(|x| x * x).sum();\n\n// Parallel with custom chunk size\nlet results: Vec<_> = data\n    .par_chunks(1000)\n    .map(|chunk| process_chunk(chunk))\n    .collect();\n```\n\n---\n\n## Memory Layout\n\n### Use Appropriate Integer Sizes\n\n```rust\n// If values are small, use smaller types\nstruct Item {\n    count: u8,      // 0-255, not u64\n    flags: u8,      // small enum\n    id: u32,        // if 4 billion is enough\n}\n```\n\n### Pack Structs Efficiently\n\n```rust\n// BAD: 24 bytes due to padding\nstruct Bad {\n    a: u8,   // 1 byte + 7 padding\n    b: u64,  // 8 bytes\n    c: u8,   // 1 byte + 7 padding\n}\n\n// GOOD: 16 bytes (or use #[repr(packed)])\nstruct Good {\n    b: u64,  // 8 bytes\n    a: u8,   // 1 byte\n    c: u8,   // 1 byte + 6 padding\n}\n```\n\n### Box Large Values\n\n```rust\n// Large enum variants waste space\nenum Message {\n    Quit,\n    Data([u8; 10000]),  // all variants are 10000+ bytes\n}\n\n// Better: box the large variant\nenum Message {\n    Quit,\n    Data(Box<[u8; 10000]>),  // variants are pointer-sized\n}\n```\n\n---\n\n## Async Performance\n\n### Avoid Blocking in Async\n\n```rust\n// BAD: blocks the executor\nasync fn bad() {\n    std::thread::sleep(Duration::from_secs(1));  // blocking!\n    std::fs::read_to_string(\"file.txt\").unwrap();  // blocking!\n}\n\n// GOOD: use async versions\nasync fn good() {\n    tokio::time::sleep(Duration::from_secs(1)).await;\n    tokio::fs::read_to_string(\"file.txt\").await.unwrap();\n}\n\n// For CPU work: spawn_blocking\nasync fn compute() -> i32 {\n    tokio::task::spawn_blocking(|| {\n        heavy_computation()\n    }).await.unwrap()\n}\n```\n\n### Buffer Async I/O\n\n```rust\nuse tokio::io::{AsyncBufReadExt, BufReader};\n\n// BAD: many small reads\nasync fn bad(file: File) {\n    let mut byte = [0u8];\n    while file.read(&mut byte).await.unwrap() > 0 {\n        process(byte[0]);\n    }\n}\n\n// GOOD: buffered reading\nasync fn good(file: File) {\n    let reader = BufReader::new(file);\n    let mut lines = reader.lines();\n    while let Some(line) = lines.next_line().await.unwrap() {\n        process(&line);\n    }\n}\n```\n\n---\n\n## Release Build Optimization\n\n### Cargo.toml Settings\n\n```toml\n[profile.release]\nlto = true           # Link-time optimization\ncodegen-units = 1    # Single codegen unit (slower compile, faster code)\npanic = \"abort\"      # Smaller binary, no unwinding\nstrip = true         # Strip symbols\n\n[profile.release-fast]\ninherits = \"release\"\nopt-level = 3        # Maximum optimization\n\n[profile.release-small]\ninherits = \"release\"\nopt-level = \"s\"      # Optimize for size\n```\n\n### Compile-Time Assertions\n\n```rust\n// Zero runtime cost\nconst _: () = assert!(std::mem::size_of::<MyStruct>() <= 64);\n```\n\n---\n\n## Checklist\n\nBefore optimizing:\n- [ ] Profile to find actual bottlenecks\n- [ ] Have benchmarks to measure improvement\n- [ ] Consider if optimization is worth complexity\n\nCommon wins:\n- [ ] Reduce allocations (Cow, reuse buffers)\n- [ ] Use appropriate collections\n- [ ] Pre-allocate with_capacity\n- [ ] Use iterators instead of indexing\n- [ ] Enable LTO for release builds\n- [ ] Use rayon for parallel workloads\n",
        "skills/m11-ecosystem/SKILL.md": "---\nname: m11-ecosystem\ndescription: \"Use when integrating crates or ecosystem questions. Keywords: E0425, E0433, E0603, crate, cargo, dependency, feature flag, workspace, which crate to use, using external C libraries, creating Python extensions, PyO3, wasm, WebAssembly, bindgen, cbindgen, napi-rs, cannot find, private, crate recommendation, best crate for, Cargo.toml, features, crate Êé®Ëçê, ‰æùËµñÁÆ°ÁêÜ, ÁâπÊÄßÊ†áÂøó, Â∑•‰ΩúÁ©∫Èó¥, Python ÁªëÂÆö\"\nuser-invocable: false\n---\n\n## Current Dependencies (Auto-Injected)\n\n!`grep -A 100 '^\\[dependencies\\]' Cargo.toml 2>/dev/null | head -30 || echo \"No Cargo.toml found\"`\n\n---\n\n# Ecosystem Integration\n\n> **Layer 2: Design Choices**\n\n## Core Question\n\n**What's the right crate for this job, and how should it integrate?**\n\nBefore adding dependencies:\n- Is there a standard solution?\n- What's the maintenance status?\n- What's the API stability?\n\n---\n\n## Integration Decision ‚Üí Implementation\n\n| Need | Choice | Crates |\n|------|--------|--------|\n| Serialization | Derive-based | serde, serde_json |\n| Async runtime | tokio or async-std | tokio (most popular) |\n| HTTP client | Ergonomic | reqwest |\n| HTTP server | Modern | axum, actix-web |\n| Database | SQL or ORM | sqlx, diesel |\n| CLI parsing | Derive-based | clap |\n| Error handling | App vs lib | anyhow, thiserror |\n| Logging | Facade | tracing, log |\n\n---\n\n## Thinking Prompt\n\nBefore adding a dependency:\n\n1. **Is it well-maintained?**\n   - Recent commits?\n   - Active issue response?\n   - Breaking changes frequency?\n\n2. **What's the scope?**\n   - Do you need the full crate or just a feature?\n   - Can feature flags reduce bloat?\n\n3. **How does it integrate?**\n   - Trait-based or concrete types?\n   - Sync or async?\n   - What bounds does it require?\n\n---\n\n## Trace Up ‚Üë\n\nTo domain constraints (Layer 3):\n\n```\n\"Which HTTP framework should I use?\"\n    ‚Üë Ask: What are the performance requirements?\n    ‚Üë Check: domain-web (latency, throughput needs)\n    ‚Üë Check: Team expertise (familiarity with framework)\n```\n\n| Question | Trace To | Ask |\n|----------|----------|-----|\n| Framework choice | domain-* | What constraints matter? |\n| Library vs build | domain-* | What's the deployment model? |\n| API design | domain-* | Who are the consumers? |\n\n---\n\n## Trace Down ‚Üì\n\nTo implementation (Layer 1):\n\n```\n\"Integrate external crate\"\n    ‚Üì m04-zero-cost: Trait bounds and generics\n    ‚Üì m06-error-handling: Error type compatibility\n\n\"FFI integration\"\n    ‚Üì unsafe-checker: Safety requirements\n    ‚Üì m12-lifecycle: Resource cleanup\n```\n\n---\n\n## Quick Reference\n\n### Language Interop\n\n| Integration | Crate/Tool | Use Case |\n|-------------|------------|----------|\n| C/C++ ‚Üí Rust | `bindgen` | Auto-generate bindings |\n| Rust ‚Üí C | `cbindgen` | Export C headers |\n| Python ‚Üî Rust | `pyo3` | Python extensions |\n| Node.js ‚Üî Rust | `napi-rs` | Node addons |\n| WebAssembly | `wasm-bindgen` | Browser/WASI |\n\n### Cargo Features\n\n| Feature | Purpose |\n|---------|---------|\n| `[features]` | Optional functionality |\n| `default = [...]` | Default features |\n| `feature = \"serde\"` | Conditional deps |\n| `[workspace]` | Multi-crate projects |\n\n## Error Code Reference\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| E0433 | Can't find crate | Add to Cargo.toml |\n| E0603 | Private item | Check crate docs |\n| Feature not enabled | Optional feature | Enable in `features` |\n| Version conflict | Incompatible deps | `cargo update` or pin |\n| Duplicate types | Different crate versions | Unify in workspace |\n\n---\n\n## Crate Selection Criteria\n\n| Criterion | Good Sign | Warning Sign |\n|-----------|-----------|--------------|\n| Maintenance | Recent commits | Years inactive |\n| Community | Active issues/PRs | No response |\n| Documentation | Examples, API docs | Minimal docs |\n| Stability | Semantic versioning | Frequent breaking |\n| Dependencies | Minimal, well-known | Heavy, obscure |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| `extern crate` | Outdated (2018+) | Just `use` |\n| `#[macro_use]` | Global pollution | Explicit import |\n| Wildcard deps `*` | Unpredictable | Specific versions |\n| Too many deps | Supply chain risk | Evaluate necessity |\n| Vendoring everything | Maintenance burden | Trust crates.io |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Error type design | m06-error-handling |\n| Trait integration | m04-zero-cost |\n| FFI safety | unsafe-checker |\n| Resource management | m12-lifecycle |\n",
        "skills/m12-lifecycle/SKILL.md": "---\nname: m12-lifecycle\ndescription: \"Use when designing resource lifecycles. Keywords: RAII, Drop, resource lifecycle, connection pool, lazy initialization, connection pool design, resource cleanup patterns, cleanup, scope, OnceCell, Lazy, once_cell, OnceLock, transaction, session management, when is Drop called, cleanup on error, guard pattern, scope guard, ËµÑÊ∫êÁîüÂëΩÂë®Êúü, ËøûÊé•Ê±†, ÊÉ∞ÊÄßÂàùÂßãÂåñ, ËµÑÊ∫êÊ∏ÖÁêÜ, RAII Ê®°Âºè\"\nuser-invocable: false\n---\n\n# Resource Lifecycle\n\n> **Layer 2: Design Choices**\n\n## Core Question\n\n**When should this resource be created, used, and cleaned up?**\n\nBefore implementing lifecycle:\n- What's the resource's scope?\n- Who owns the cleanup responsibility?\n- What happens on error?\n\n---\n\n## Lifecycle Pattern ‚Üí Implementation\n\n| Pattern | When | Implementation |\n|---------|------|----------------|\n| RAII | Auto cleanup | `Drop` trait |\n| Lazy init | Deferred creation | `OnceLock`, `LazyLock` |\n| Pool | Reuse expensive resources | `r2d2`, `deadpool` |\n| Guard | Scoped access | `MutexGuard` pattern |\n| Scope | Transaction boundary | Custom struct + Drop |\n\n---\n\n## Thinking Prompt\n\nBefore designing lifecycle:\n\n1. **What's the resource cost?**\n   - Cheap ‚Üí create per use\n   - Expensive ‚Üí pool or cache\n   - Global ‚Üí lazy singleton\n\n2. **What's the scope?**\n   - Function-local ‚Üí stack allocation\n   - Request-scoped ‚Üí passed or extracted\n   - Application-wide ‚Üí static or Arc\n\n3. **What about errors?**\n   - Cleanup must happen ‚Üí Drop\n   - Cleanup is optional ‚Üí explicit close\n   - Cleanup can fail ‚Üí Result from close\n\n---\n\n## Trace Up ‚Üë\n\nTo domain constraints (Layer 3):\n\n```\n\"How should I manage database connections?\"\n    ‚Üë Ask: What's the connection cost?\n    ‚Üë Check: domain-* (latency requirements)\n    ‚Üë Check: Infrastructure (connection limits)\n```\n\n| Question | Trace To | Ask |\n|----------|----------|-----|\n| Connection pooling | domain-* | What's acceptable latency? |\n| Resource limits | domain-* | What are infra constraints? |\n| Transaction scope | domain-* | What must be atomic? |\n\n---\n\n## Trace Down ‚Üì\n\nTo implementation (Layer 1):\n\n```\n\"Need automatic cleanup\"\n    ‚Üì m02-resource: Implement Drop\n    ‚Üì m01-ownership: Clear owner for cleanup\n\n\"Need lazy initialization\"\n    ‚Üì m03-mutability: OnceLock for thread-safe\n    ‚Üì m07-concurrency: LazyLock for sync\n\n\"Need connection pool\"\n    ‚Üì m07-concurrency: Thread-safe pool\n    ‚Üì m02-resource: Arc for sharing\n```\n\n---\n\n## Quick Reference\n\n| Pattern | Type | Use Case |\n|---------|------|----------|\n| RAII | `Drop` trait | Auto cleanup on scope exit |\n| Lazy Init | `OnceLock`, `LazyLock` | Deferred initialization |\n| Pool | `r2d2`, `deadpool` | Connection reuse |\n| Guard | `MutexGuard` | Scoped lock release |\n| Scope | Custom struct | Transaction boundaries |\n\n## Lifecycle Events\n\n| Event | Rust Mechanism |\n|-------|----------------|\n| Creation | `new()`, `Default` |\n| Lazy Init | `OnceLock::get_or_init` |\n| Usage | `&self`, `&mut self` |\n| Cleanup | `Drop::drop()` |\n\n## Pattern Templates\n\n### RAII Guard\n\n```rust\nstruct FileGuard {\n    path: PathBuf,\n    _handle: File,\n}\n\nimpl Drop for FileGuard {\n    fn drop(&mut self) {\n        // Cleanup: remove temp file\n        let _ = std::fs::remove_file(&self.path);\n    }\n}\n```\n\n### Lazy Singleton\n\n```rust\nuse std::sync::OnceLock;\n\nstatic CONFIG: OnceLock<Config> = OnceLock::new();\n\nfn get_config() -> &'static Config {\n    CONFIG.get_or_init(|| {\n        Config::load().expect(\"config required\")\n    })\n}\n```\n\n---\n\n## Common Errors\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| Resource leak | Forgot Drop | Implement Drop or RAII wrapper |\n| Double free | Manual memory | Let Rust handle |\n| Use after drop | Dangling reference | Check lifetimes |\n| E0509 move out of Drop | Moving owned field | `Option::take()` |\n| Pool exhaustion | Not returned | Ensure Drop returns |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| Manual cleanup | Easy to forget | RAII/Drop |\n| `lazy_static!` | External dep | `std::sync::OnceLock` |\n| Global mutable state | Thread unsafety | `OnceLock` or proper sync |\n| Forget to close | Resource leak | Drop impl |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Smart pointers | m02-resource |\n| Thread-safe init | m07-concurrency |\n| Domain scopes | m09-domain |\n| Error in cleanup | m06-error-handling |\n",
        "skills/m13-domain-error/SKILL.md": "---\nname: m13-domain-error\ndescription: \"Use when designing domain error handling. Keywords: domain error, error categorization, recovery strategy, retry, fallback, domain error hierarchy, user-facing vs internal errors, error code design, circuit breaker, graceful degradation, resilience, error context, backoff, retry with backoff, error recovery, transient vs permanent error, È¢ÜÂüüÈîôËØØ, ÈîôËØØÂàÜÁ±ª, ÊÅ¢Â§çÁ≠ñÁï•, ÈáçËØï, ÁÜîÊñ≠Âô®, ‰ºòÈõÖÈôçÁ∫ß\"\nuser-invocable: false\n---\n\n# Domain Error Strategy\n\n> **Layer 2: Design Choices**\n\n## Core Question\n\n**Who needs to handle this error, and how should they recover?**\n\nBefore designing error types:\n- Is this user-facing or internal?\n- Is recovery possible?\n- What context is needed for debugging?\n\n---\n\n## Error Categorization\n\n| Error Type | Audience | Recovery | Example |\n|------------|----------|----------|---------|\n| User-facing | End users | Guide action | `InvalidEmail`, `NotFound` |\n| Internal | Developers | Debug info | `DatabaseError`, `ParseError` |\n| System | Ops/SRE | Monitor/alert | `ConnectionTimeout`, `RateLimited` |\n| Transient | Automation | Retry | `NetworkError`, `ServiceUnavailable` |\n| Permanent | Human | Investigate | `ConfigInvalid`, `DataCorrupted` |\n\n---\n\n## Thinking Prompt\n\nBefore designing error types:\n\n1. **Who sees this error?**\n   - End user ‚Üí friendly message, actionable\n   - Developer ‚Üí detailed, debuggable\n   - Ops ‚Üí structured, alertable\n\n2. **Can we recover?**\n   - Transient ‚Üí retry with backoff\n   - Degradable ‚Üí fallback value\n   - Permanent ‚Üí fail fast, alert\n\n3. **What context is needed?**\n   - Call chain ‚Üí anyhow::Context\n   - Request ID ‚Üí structured logging\n   - Input data ‚Üí error payload\n\n---\n\n## Trace Up ‚Üë\n\nTo domain constraints (Layer 3):\n\n```\n\"How should I handle payment failures?\"\n    ‚Üë Ask: What are the business rules for retries?\n    ‚Üë Check: domain-fintech (transaction requirements)\n    ‚Üë Check: SLA (availability requirements)\n```\n\n| Question | Trace To | Ask |\n|----------|----------|-----|\n| Retry policy | domain-* | What's acceptable latency for retry? |\n| User experience | domain-* | What message should users see? |\n| Compliance | domain-* | What must be logged for audit? |\n\n---\n\n## Trace Down ‚Üì\n\nTo implementation (Layer 1):\n\n```\n\"Need typed errors\"\n    ‚Üì m06-error-handling: thiserror for library\n    ‚Üì m04-zero-cost: Error enum design\n\n\"Need error context\"\n    ‚Üì m06-error-handling: anyhow::Context\n    ‚Üì Logging: tracing with fields\n\n\"Need retry logic\"\n    ‚Üì m07-concurrency: async retry patterns\n    ‚Üì Crates: tokio-retry, backoff\n```\n\n---\n\n## Quick Reference\n\n| Recovery Pattern | When | Implementation |\n|------------------|------|----------------|\n| Retry | Transient failures | exponential backoff |\n| Fallback | Degraded mode | cached/default value |\n| Circuit Breaker | Cascading failures | failsafe-rs |\n| Timeout | Slow operations | `tokio::time::timeout` |\n| Bulkhead | Isolation | separate thread pools |\n\n## Error Hierarchy\n\n```rust\n#[derive(thiserror::Error, Debug)]\npub enum AppError {\n    // User-facing\n    #[error(\"Invalid input: {0}\")]\n    Validation(String),\n\n    // Transient (retryable)\n    #[error(\"Service temporarily unavailable\")]\n    ServiceUnavailable(#[source] reqwest::Error),\n\n    // Internal (log details, show generic)\n    #[error(\"Internal error\")]\n    Internal(#[source] anyhow::Error),\n}\n\nimpl AppError {\n    pub fn is_retryable(&self) -> bool {\n        matches!(self, Self::ServiceUnavailable(_))\n    }\n}\n```\n\n## Retry Pattern\n\n```rust\nuse tokio_retry::{Retry, strategy::ExponentialBackoff};\n\nasync fn with_retry<F, T, E>(f: F) -> Result<T, E>\nwhere\n    F: Fn() -> impl Future<Output = Result<T, E>>,\n    E: std::fmt::Debug,\n{\n    let strategy = ExponentialBackoff::from_millis(100)\n        .max_delay(Duration::from_secs(10))\n        .take(5);\n\n    Retry::spawn(strategy, || f()).await\n}\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Why Wrong | Better |\n|---------|-----------|--------|\n| Same error for all | No actionability | Categorize by audience |\n| Retry everything | Wasted resources | Only transient errors |\n| Infinite retry | DoS self | Max attempts + backoff |\n| Expose internal errors | Security risk | User-friendly messages |\n| No context | Hard to debug | .context() everywhere |\n\n---\n\n## Anti-Patterns\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| String errors | No structure | thiserror types |\n| panic! for recoverable | Bad UX | Result with context |\n| Ignore errors | Silent failures | Log or propagate |\n| Box<dyn Error> everywhere | Lost type info | thiserror |\n| Error in happy path | Performance | Early validation |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Error handling basics | m06-error-handling |\n| Retry implementation | m07-concurrency |\n| Domain modeling | m09-domain |\n| User-facing APIs | domain-* |\n",
        "skills/m14-mental-model/SKILL.md": "---\nname: m14-mental-model\ndescription: \"Use when learning Rust concepts. Keywords: mental model, how to think about ownership, understanding borrow checker, visualizing memory layout, analogy, misconception, explaining ownership, why does Rust, help me understand, confused about, learning Rust, explain like I'm, ELI5, intuition for, coming from Java, coming from Python, ÂøÉÊô∫Ê®°Âûã, Â¶Ç‰ΩïÁêÜËß£ÊâÄÊúâÊùÉ, Â≠¶‰π† Rust, Rust ÂÖ•Èó®, ‰∏∫‰ªÄ‰πà Rust\"\nuser-invocable: false\n---\n\n# Mental Models\n\n> **Layer 2: Design Choices**\n\n## Core Question\n\n**What's the right way to think about this Rust concept?**\n\nWhen learning or explaining Rust:\n- What's the correct mental model?\n- What misconceptions should be avoided?\n- What analogies help understanding?\n\n---\n\n## Key Mental Models\n\n| Concept | Mental Model | Analogy |\n|---------|--------------|---------|\n| Ownership | Unique key | Only one person has the house key |\n| Move | Key handover | Giving away your key |\n| `&T` | Lending for reading | Lending a book |\n| `&mut T` | Exclusive editing | Only you can edit the doc |\n| Lifetime `'a` | Valid scope | \"Ticket valid until...\" |\n| `Box<T>` | Heap pointer | Remote control to TV |\n| `Rc<T>` | Shared ownership | Multiple remotes, last turns off |\n| `Arc<T>` | Thread-safe Rc | Remotes from any room |\n\n---\n\n## Coming From Other Languages\n\n| From | Key Shift |\n|------|-----------|\n| Java/C# | Values are owned, not references by default |\n| C/C++ | Compiler enforces safety rules |\n| Python/Go | No GC, deterministic destruction |\n| Functional | Mutability is safe via ownership |\n| JavaScript | No null, use Option instead |\n\n---\n\n## Thinking Prompt\n\nWhen confused about Rust:\n\n1. **What's the ownership model?**\n   - Who owns this data?\n   - How long does it live?\n   - Who can access it?\n\n2. **What guarantee is Rust providing?**\n   - No data races\n   - No dangling pointers\n   - No use-after-free\n\n3. **What's the compiler telling me?**\n   - Error = violation of safety rule\n   - Solution = work with the rules\n\n---\n\n## Trace Up ‚Üë\n\nTo design understanding (Layer 2):\n\n```\n\"Why can't I do X in Rust?\"\n    ‚Üë Ask: What safety guarantee would be violated?\n    ‚Üë Check: m01-m07 for the rule being enforced\n    ‚Üë Ask: What's the intended design pattern?\n```\n\n---\n\n## Trace Down ‚Üì\n\nTo implementation (Layer 1):\n\n```\n\"I understand the concept, now how do I implement?\"\n    ‚Üì m01-ownership: Ownership patterns\n    ‚Üì m02-resource: Smart pointer choice\n    ‚Üì m07-concurrency: Thread safety\n```\n\n---\n\n## Common Misconceptions\n\n| Error | Wrong Model | Correct Model |\n|-------|-------------|---------------|\n| E0382 use after move | GC cleans up | Ownership = unique key transfer |\n| E0502 borrow conflict | Multiple writers OK | Only one writer at a time |\n| E0499 multiple mut borrows | Aliased mutation | Exclusive access for mutation |\n| E0106 missing lifetime | Ignoring scope | References have validity scope |\n| E0507 cannot move from `&T` | Implicit clone | References don't own data |\n\n## Deprecated Thinking\n\n| Deprecated | Better |\n|------------|--------|\n| \"Rust is like C++\" | Different ownership model |\n| \"Lifetimes are GC\" | Compile-time validity scope |\n| \"Clone solves everything\" | Restructure ownership |\n| \"Fight the borrow checker\" | Work with the compiler |\n| \"`unsafe` to avoid rules\" | Understand safe patterns first |\n\n---\n\n## Ownership Visualization\n\n```\nStack                          Heap\n+----------------+            +----------------+\n| main()         |            |                |\n|   s1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> ‚îÇ \"hello\"        |\n|                |            |                |\n| fn takes(s) {  |            |                |\n|   s2 (moved) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> ‚îÇ \"hello\"        |\n| }              |            | (s1 invalid)   |\n+----------------+            +----------------+\n\nAfter move: s1 is no longer valid\n```\n\n## Reference Visualization\n\n```\n+----------------+\n| data: String   |‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> \"hello\"\n+----------------+\n       ‚Üë\n       ‚îÇ &data (immutable borrow)\n       ‚îÇ\n+------+------+\n| reader1    reader2    (multiple OK)\n+------+------+\n\n+----------------+\n| data: String   |‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> \"hello\"\n+----------------+\n       ‚Üë\n       ‚îÇ &mut data (mutable borrow)\n       ‚îÇ\n+------+\n| writer (only one)\n+------+\n```\n\n---\n\n## Learning Path\n\n| Stage | Focus | Skills |\n|-------|-------|--------|\n| Beginner | Ownership basics | m01-ownership, m14-mental-model |\n| Intermediate | Smart pointers, error handling | m02, m06 |\n| Advanced | Concurrency, unsafe | m07, unsafe-checker |\n| Expert | Design patterns | m09-m15, domain-* |\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Ownership errors | m01-ownership |\n| Smart pointers | m02-resource |\n| Concurrency | m07-concurrency |\n| Anti-patterns | m15-anti-pattern |\n",
        "skills/m14-mental-model/patterns/thinking-in-rust.md": "# Thinking in Rust: Mental Models\n\n## Core Mental Models\n\n### 1. Ownership as Resource Management\n\n```\nTraditional: \"Who has a pointer to this data?\"\nRust:        \"Who OWNS this data and is responsible for freeing it?\"\n```\n\nKey insight: Every value has exactly one owner. When the owner goes out of scope, the value is dropped.\n\n```rust\n{\n    let s = String::from(\"hello\");  // s owns the String\n    // use s...\n}  // s goes out of scope, String is dropped (memory freed)\n```\n\n### 2. Borrowing as Temporary Access\n\n```\nTraditional: \"I'll just read from this pointer\"\nRust:        \"I'm borrowing this value, owner still responsible for it\"\n```\n\nKey insight: Borrows are like library books - you can read them, but must return them.\n\n```rust\nfn print_length(s: &String) {  // borrows s\n    println!(\"{}\", s.len());\n}  // borrow ends, caller still owns s\n\nlet my_string = String::from(\"hello\");\nprint_length(&my_string);  // lend to function\nprintln!(\"{}\", my_string);  // still have it\n```\n\n### 3. Lifetimes as Validity Scopes\n\n```\nTraditional: \"Hope this pointer is still valid\"\nRust:        \"Compiler tracks exactly how long references are valid\"\n```\n\nKey insight: A reference can't outlive the data it points to.\n\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    // 'a means: the returned reference is valid as long as BOTH inputs are valid\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n---\n\n## Shifting Perspectives\n\n### From \"Everything is a Reference\" (Java/C#)\n\nJava mental model:\n```java\n// Everything is implicitly a reference\nUser user = new User(\"Alice\");  // user is a reference\nList<User> users = new ArrayList<>();\nusers.add(user);  // shares the reference\nuser.setName(\"Bob\");  // affects the list too!\n```\n\nRust mental model:\n```rust\n// Values are owned, sharing is explicit\nlet user = User::new(\"Alice\");  // user is owned\nlet mut users = vec![];\nusers.push(user);  // user moved into vec, can't use user anymore\n// user.set_name(\"Bob\");  // ERROR: user was moved\n\n// If you need sharing:\nuse std::rc::Rc;\nlet user = Rc::new(User::new(\"Alice\"));\nlet user2 = Rc::clone(&user);  // explicit shared ownership\n```\n\n### From \"Manual Memory Management\" (C/C++)\n\nC mental model:\n```c\nchar* s = malloc(100);\n// ... must remember to free(s) ...\n// ... what if we return early? ...\n// ... what if an exception occurs? ...\nfree(s);\n```\n\nRust mental model:\n```rust\nlet s = String::with_capacity(100);\n// ... use s ...\n// No need to free - Rust drops s automatically when scope ends\n// Even with early returns, panics, or any control flow\n```\n\n### From \"Garbage Collection\" (Go/Python)\n\nGC mental model:\n```python\n# Create objects, GC will figure it out\nusers = []\nfor name in names:\n    users.append(User(name))\n# GC runs sometime later, when it feels like it\n```\n\nRust mental model:\n```rust\nlet users: Vec<User> = names\n    .iter()\n    .map(|name| User::new(name))\n    .collect();\n// Memory is freed EXACTLY when users goes out of scope\n// Deterministic, no GC pauses, no unpredictable memory usage\n```\n\n---\n\n## Key Questions to Ask\n\n### When Designing Functions\n\n1. **Does this function need to own the data, or just read it?**\n   - Need to keep it: take ownership (`fn process(data: Vec<T>)`)\n   - Just reading: borrow (`fn process(data: &[T])`)\n   - Need to modify: mutable borrow (`fn process(data: &mut Vec<T>)`)\n\n2. **Does the return value contain references to inputs?**\n   - Yes: need lifetime annotations\n   - No: lifetime elision usually works\n\n### When Designing Structs\n\n1. **Should this struct own its data or reference it?**\n   - Long-lived, independent: own (`name: String`)\n   - Short-lived view: reference (`name: &'a str`)\n\n2. **Do multiple parts need to access the same data?**\n   - Single-threaded: `Rc<T>` or `Rc<RefCell<T>>`\n   - Multi-threaded: `Arc<T>` or `Arc<Mutex<T>>`\n\n### When Hitting Borrow Checker Errors\n\n1. **Am I trying to use a value after moving it?**\n   - Clone it, borrow it, or restructure the code\n\n2. **Am I trying to have multiple mutable references?**\n   - Scope the mutations, use interior mutability, or redesign\n\n3. **Does a reference outlive its source?**\n   - Return owned data instead, or use `'static`\n\n---\n\n## Common Patterns\n\n### The Clone Escape Hatch\n\nWhen fighting the borrow checker, `.clone()` often works:\n\n```rust\n// Can't do this - double borrow\nlet mut map = HashMap::new();\nfor key in map.keys() {\n    map.insert(key.clone(), process(key));  // ERROR: map borrowed twice\n}\n\n// Clone to escape\nlet keys: Vec<_> = map.keys().cloned().collect();\nfor key in keys {\n    map.insert(key.clone(), process(&key));  // OK\n}\n```\n\nBut ask: \"Is there a better design?\" Often, restructuring is better than cloning.\n\n### The \"Make It Own\" Pattern\n\nWhen lifetimes get complex, make the struct own its data:\n\n```rust\n// Complex: struct with references\nstruct Parser<'a> {\n    input: &'a str,\n    current: &'a str,\n}\n\n// Simpler: struct owns data\nstruct Parser {\n    input: String,\n    position: usize,\n}\n```\n\n### The \"Split the Borrow\" Pattern\n\n```rust\nstruct Data {\n    field_a: Vec<i32>,\n    field_b: Vec<i32>,\n}\n\n// Can't borrow self mutably twice\nfn process(&mut self) {\n    // for a in &self.field_a {\n    //     self.field_b.push(*a);  // ERROR\n    // }\n\n    // Split the borrow\n    let Data { field_a, field_b } = self;\n    for a in field_a.iter() {\n        field_b.push(*a);  // OK: separate borrows\n    }\n}\n```\n\n---\n\n## The Rust Way\n\n### Embrace the Type System\n\n```rust\n// Don't: stringly-typed\nfn connect(host: &str, port: &str) { ... }\nconnect(\"8080\", \"localhost\");  // oops, wrong order\n\n// Do: strongly-typed\nstruct Host(String);\nstruct Port(u16);\nfn connect(host: Host, port: Port) { ... }\n// connect(Port(8080), Host(\"localhost\".into()));  // compile error!\n```\n\n### Make Invalid States Unrepresentable\n\n```rust\n// Don't: runtime checks\nstruct Connection {\n    socket: Option<Socket>,\n    connected: bool,\n}\n\n// Do: types enforce states\nenum Connection {\n    Disconnected,\n    Connected { socket: Socket },\n}\n```\n\n### Let the Compiler Guide You\n\n```rust\n// Start with what you want\nfn process(data: ???) -> ???\n\n// Let compiler errors tell you:\n// - What types are needed\n// - What lifetimes are needed\n// - What bounds are needed\n\n// The error messages are documentation!\n```\n\n---\n\n## Summary: The Rust Mental Model\n\n1. **Values have owners** - exactly one at a time\n2. **Borrowing is lending** - temporary access, owner retains responsibility\n3. **Lifetimes are scopes** - compiler tracks validity\n4. **Types encode constraints** - use them to prevent bugs\n5. **The compiler is your friend** - work with it, not against it\n\nWhen stuck:\n- Clone to make progress\n- Restructure to own instead of borrow\n- Ask: \"What is the compiler trying to tell me?\"\n",
        "skills/m15-anti-pattern/SKILL.md": "---\nname: m15-anti-pattern\ndescription: \"Use when reviewing code for anti-patterns. Keywords: anti-pattern, common mistake, pitfall, code smell, bad practice, code review, is this an anti-pattern, better way to do this, common mistake to avoid, why is this bad, idiomatic way, beginner mistake, fighting borrow checker, clone everywhere, unwrap in production, should I refactor, ÂèçÊ®°Âºè, Â∏∏ËßÅÈîôËØØ, ‰ª£Á†ÅÂºÇÂë≥, ÊúÄ‰Ω≥ÂÆûË∑µ, Âú∞ÈÅìÂÜôÊ≥ï\"\nuser-invocable: false\n---\n\n# Anti-Patterns\n\n> **Layer 2: Design Choices**\n\n## Core Question\n\n**Is this pattern hiding a design problem?**\n\nWhen reviewing code:\n- Is this solving the symptom or the cause?\n- Is there a more idiomatic approach?\n- Does this fight or flow with Rust?\n\n---\n\n## Anti-Pattern ‚Üí Better Pattern\n\n| Anti-Pattern | Why Bad | Better |\n|--------------|---------|--------|\n| `.clone()` everywhere | Hides ownership issues | Proper references or ownership |\n| `.unwrap()` in production | Runtime panics | `?`, `expect`, or handling |\n| `Rc` when single owner | Unnecessary overhead | Simple ownership |\n| `unsafe` for convenience | UB risk | Find safe pattern |\n| OOP via `Deref` | Misleading API | Composition, traits |\n| Giant match arms | Unmaintainable | Extract to methods |\n| `String` everywhere | Allocation waste | `&str`, `Cow<str>` |\n| Ignoring `#[must_use]` | Lost errors | Handle or `let _ =` |\n\n---\n\n## Thinking Prompt\n\nWhen seeing suspicious code:\n\n1. **Is this symptom or cause?**\n   - Clone to avoid borrow? ‚Üí Ownership design issue\n   - Unwrap \"because it won't fail\"? ‚Üí Unhandled case\n\n2. **What would idiomatic code look like?**\n   - References instead of clones\n   - Iterators instead of index loops\n   - Pattern matching instead of flags\n\n3. **Does this fight Rust?**\n   - Fighting borrow checker ‚Üí restructure\n   - Excessive unsafe ‚Üí find safe pattern\n\n---\n\n## Trace Up ‚Üë\n\nTo design understanding:\n\n```\n\"Why does my code have so many clones?\"\n    ‚Üë Ask: Is the ownership model correct?\n    ‚Üë Check: m09-domain (data flow design)\n    ‚Üë Check: m01-ownership (reference patterns)\n```\n\n| Anti-Pattern | Trace To | Question |\n|--------------|----------|----------|\n| Clone everywhere | m01-ownership | Who should own this data? |\n| Unwrap everywhere | m06-error-handling | What's the error strategy? |\n| Rc everywhere | m09-domain | Is ownership clear? |\n| Fighting lifetimes | m09-domain | Should data structure change? |\n\n---\n\n## Trace Down ‚Üì\n\nTo implementation (Layer 1):\n\n```\n\"Replace clone with proper ownership\"\n    ‚Üì m01-ownership: Reference patterns\n    ‚Üì m02-resource: Smart pointer if needed\n\n\"Replace unwrap with proper handling\"\n    ‚Üì m06-error-handling: ? operator\n    ‚Üì m06-error-handling: expect with message\n```\n\n---\n\n## Top 5 Beginner Mistakes\n\n| Rank | Mistake | Fix |\n|------|---------|-----|\n| 1 | Clone to escape borrow checker | Use references |\n| 2 | Unwrap in production | Propagate with `?` |\n| 3 | String for everything | Use `&str` |\n| 4 | Index loops | Use iterators |\n| 5 | Fighting lifetimes | Restructure to own data |\n\n## Code Smell ‚Üí Refactoring\n\n| Smell | Indicates | Refactoring |\n|-------|-----------|-------------|\n| Many `.clone()` | Ownership unclear | Clarify data flow |\n| Many `.unwrap()` | Error handling missing | Add proper handling |\n| Many `pub` fields | Encapsulation broken | Private + accessors |\n| Deep nesting | Complex logic | Extract methods |\n| Long functions | Multiple responsibilities | Split |\n| Giant enums | Missing abstraction | Trait + types |\n\n---\n\n## Common Error Patterns\n\n| Error | Anti-Pattern Cause | Fix |\n|-------|-------------------|-----|\n| E0382 use after move | Cloning vs ownership | Proper references |\n| Panic in production | Unwrap everywhere | ?, matching |\n| Slow performance | String for all text | &str, Cow |\n| Borrow checker fights | Wrong structure | Restructure |\n| Memory bloat | Rc/Arc everywhere | Simple ownership |\n\n---\n\n## Deprecated ‚Üí Better\n\n| Deprecated | Better |\n|------------|--------|\n| Index-based loops | `.iter()`, `.enumerate()` |\n| `collect::<Vec<_>>()` then iterate | Chain iterators |\n| Manual unsafe cell | `Cell`, `RefCell` |\n| `mem::transmute` for casts | `as` or `TryFrom` |\n| Custom linked list | `Vec`, `VecDeque` |\n| `lazy_static!` | `std::sync::OnceLock` |\n\n---\n\n## Quick Review Checklist\n\n- [ ] No `.clone()` without justification\n- [ ] No `.unwrap()` in library code\n- [ ] No `pub` fields with invariants\n- [ ] No index loops when iterator works\n- [ ] No `String` where `&str` suffices\n- [ ] No ignored `#[must_use]` warnings\n- [ ] No `unsafe` without SAFETY comment\n- [ ] No giant functions (>50 lines)\n\n---\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Ownership patterns | m01-ownership |\n| Error handling | m06-error-handling |\n| Mental models | m14-mental-model |\n| Performance | m10-performance |\n",
        "skills/m15-anti-pattern/patterns/common-mistakes.md": "# Common Rust Anti-Patterns & Mistakes\n\n## Ownership Anti-Patterns\n\n### 1. Clone Everything\n\n```rust\n// ANTI-PATTERN: clone to avoid borrow checker\nfn process(data: Vec<String>) {\n    for item in data.clone() {  // unnecessary clone\n        println!(\"{}\", item);\n    }\n    use_data(data);\n}\n\n// BETTER: borrow when you don't need ownership\nfn process(data: Vec<String>) {\n    for item in &data {  // borrow instead\n        println!(\"{}\", item);\n    }\n    use_data(data);\n}\n```\n\n### 2. Unnecessary Box\n\n```rust\n// ANTI-PATTERN: boxing everything\nfn get_value() -> Box<String> {\n    Box::new(String::from(\"hello\"))\n}\n\n// BETTER: return value directly\nfn get_value() -> String {\n    String::from(\"hello\")\n}\n```\n\n### 3. Holding References Too Long\n\n```rust\n// ANTI-PATTERN: borrow prevents mutation\nlet mut data = vec![1, 2, 3];\nlet first = &data[0];\ndata.push(4);  // ERROR: data is borrowed\nprintln!(\"{}\", first);\n\n// BETTER: scope the borrow\nlet mut data = vec![1, 2, 3];\nlet first = data[0];  // copy the value\ndata.push(4);  // OK\nprintln!(\"{}\", first);\n```\n\n---\n\n## Error Handling Anti-Patterns\n\n### 4. Unwrap Everywhere\n\n```rust\n// ANTI-PATTERN: crashes on error\nfn process_file(path: &str) {\n    let content = std::fs::read_to_string(path).unwrap();\n    let config: Config = toml::from_str(&content).unwrap();\n}\n\n// BETTER: propagate errors\nfn process_file(path: &str) -> Result<Config, Error> {\n    let content = std::fs::read_to_string(path)?;\n    let config: Config = toml::from_str(&content)?;\n    Ok(config)\n}\n```\n\n### 5. Ignoring Errors\n\n```rust\n// ANTI-PATTERN: silent failure\nlet _ = file.write_all(data);\n\n// BETTER: handle or propagate\nfile.write_all(data)?;\n// or at minimum, log the error\nif let Err(e) = file.write_all(data) {\n    eprintln!(\"Warning: failed to write: {}\", e);\n}\n```\n\n### 6. Panic in Library Code\n\n```rust\n// ANTI-PATTERN: library panics\npub fn parse(input: &str) -> Data {\n    if input.is_empty() {\n        panic!(\"input cannot be empty\");\n    }\n    // ...\n}\n\n// BETTER: return Result\npub fn parse(input: &str) -> Result<Data, ParseError> {\n    if input.is_empty() {\n        return Err(ParseError::EmptyInput);\n    }\n    // ...\n}\n```\n\n---\n\n## String Anti-Patterns\n\n### 7. String Instead of &str\n\n```rust\n// ANTI-PATTERN: forces allocation\nfn greet(name: String) {\n    println!(\"Hello, {}\", name);\n}\n\ngreet(\"world\".to_string());  // allocation\n\n// BETTER: accept &str\nfn greet(name: &str) {\n    println!(\"Hello, {}\", name);\n}\n\ngreet(\"world\");  // no allocation\n```\n\n### 8. Format for Simple Concatenation\n\n```rust\n// ANTI-PATTERN: format overhead\nlet greeting = format!(\"{}{}\", \"Hello, \", name);\n\n// BETTER for simple cases: push_str\nlet mut greeting = String::from(\"Hello, \");\ngreeting.push_str(name);\n\n// Or use + for String + &str\nlet greeting = String::from(\"Hello, \") + name;\n```\n\n### 9. Repeated String Operations\n\n```rust\n// ANTI-PATTERN: O(n¬≤) allocations\nlet mut result = String::new();\nfor word in words {\n    result = result + word + \" \";\n}\n\n// BETTER: join\nlet result = words.join(\" \");\n\n// Or with_capacity + push_str\nlet mut result = String::with_capacity(total_len);\nfor word in words {\n    result.push_str(word);\n    result.push(' ');\n}\n```\n\n---\n\n## Collection Anti-Patterns\n\n### 10. Index Instead of Iterator\n\n```rust\n// ANTI-PATTERN: bounds checking overhead\nfor i in 0..vec.len() {\n    process(vec[i]);\n}\n\n// BETTER: iterator\nfor item in &vec {\n    process(item);\n}\n```\n\n### 11. Collect Then Iterate\n\n```rust\n// ANTI-PATTERN: unnecessary allocation\nlet filtered: Vec<_> = items.iter().filter(|x| x.valid).collect();\nfor item in filtered {\n    process(item);\n}\n\n// BETTER: chain iterators\nfor item in items.iter().filter(|x| x.valid) {\n    process(item);\n}\n```\n\n### 12. Wrong Collection Type\n\n```rust\n// ANTI-PATTERN: Vec for frequent membership checks\nlet allowed: Vec<&str> = vec![\"a\", \"b\", \"c\"];\nif allowed.contains(&input) { ... }  // O(n)\n\n// BETTER: HashSet for membership\nuse std::collections::HashSet;\nlet allowed: HashSet<&str> = [\"a\", \"b\", \"c\"].into();\nif allowed.contains(input) { ... }  // O(1)\n```\n\n---\n\n## Concurrency Anti-Patterns\n\n### 13. Mutex for Read-Heavy Data\n\n```rust\n// ANTI-PATTERN: Mutex when mostly reading\nlet data = Arc::new(Mutex::new(config));\n// All readers block each other\n\n// BETTER: RwLock for read-heavy workloads\nlet data = Arc::new(RwLock::new(config));\n// Multiple readers can proceed in parallel\n```\n\n### 14. Holding Lock Across Await\n\n```rust\n// ANTI-PATTERN: lock held across await\nasync fn bad() {\n    let guard = mutex.lock().unwrap();\n    some_async_op().await;  // lock held!\n    use(guard);\n}\n\n// BETTER: scope the lock\nasync fn good() {\n    let value = {\n        let guard = mutex.lock().unwrap();\n        guard.clone()\n    };  // lock released\n    some_async_op().await;\n    use(value);\n}\n```\n\n### 15. Blocking in Async\n\n```rust\n// ANTI-PATTERN: blocking call in async\nasync fn bad() {\n    std::thread::sleep(Duration::from_secs(1));  // blocks executor!\n}\n\n// BETTER: async sleep\nasync fn good() {\n    tokio::time::sleep(Duration::from_secs(1)).await;\n}\n\n// For CPU work: spawn_blocking\nasync fn compute() {\n    tokio::task::spawn_blocking(|| heavy_work()).await\n}\n```\n\n---\n\n## Type System Anti-Patterns\n\n### 16. Stringly Typed\n\n```rust\n// ANTI-PATTERN: strings for everything\nfn connect(host: &str, port: &str, timeout: &str) { ... }\nconnect(\"8080\", \"localhost\", \"30\");  // wrong order!\n\n// BETTER: strong types\nstruct Host(String);\nstruct Port(u16);\nstruct Timeout(Duration);\n\nfn connect(host: Host, port: Port, timeout: Timeout) { ... }\n```\n\n### 17. Boolean Parameters\n\n```rust\n// ANTI-PATTERN: what does true mean?\nfn fetch(url: &str, use_cache: bool, validate_ssl: bool) { ... }\nfetch(\"https://...\", true, false);  // unclear\n\n// BETTER: builder or named parameters\nstruct FetchOptions {\n    use_cache: bool,\n    validate_ssl: bool,\n}\n\nfn fetch(url: &str, options: FetchOptions) { ... }\nfetch(\"https://...\", FetchOptions {\n    use_cache: true,\n    validate_ssl: false,\n});\n```\n\n### 18. Option<Option<T>>\n\n```rust\n// ANTI-PATTERN: nested Option\nfn find(id: u32) -> Option<Option<User>> { ... }\n// What does None vs Some(None) mean?\n\n// BETTER: use Result or custom enum\nenum FindResult {\n    Found(User),\n    NotFound,\n    Error(String),\n}\n```\n\n---\n\n## API Design Anti-Patterns\n\n### 19. Taking Ownership Unnecessarily\n\n```rust\n// ANTI-PATTERN: takes ownership but doesn't need it\nfn validate(config: Config) -> bool {\n    config.timeout > 0 && config.retries >= 0\n}\n\n// BETTER: borrow\nfn validate(config: &Config) -> bool {\n    config.timeout > 0 && config.retries >= 0\n}\n```\n\n### 20. Returning References to Temporaries\n\n```rust\n// ANTI-PATTERN: impossible lifetime\nfn get_default() -> &str {\n    let s = String::from(\"default\");\n    &s  // ERROR: s is dropped\n}\n\n// BETTER: return owned\nfn get_default() -> String {\n    String::from(\"default\")\n}\n\n// Or return static\nfn get_default() -> &'static str {\n    \"default\"\n}\n```\n\n### 21. Overly Generic Functions\n\n```rust\n// ANTI-PATTERN: complex generics for simple function\nfn process<T, U, V>(input: T) -> V\nwhere\n    T: Into<U>,\n    U: AsRef<str> + Clone,\n    V: From<String>,\n{ ... }\n\n// BETTER: concrete types if generics not needed\nfn process(input: &str) -> String { ... }\n```\n\n---\n\n## Macro Anti-Patterns\n\n### 22. Macro When Function Works\n\n```rust\n// ANTI-PATTERN: macro for simple operation\nmacro_rules! add {\n    ($a:expr, $b:expr) => { $a + $b };\n}\n\n// BETTER: just use a function\nfn add(a: i32, b: i32) -> i32 { a + b }\n```\n\n### 23. Complex Macro Without Tests\n\n```rust\n// ANTI-PATTERN: complex macro with no tests\nmacro_rules! define_api {\n    // ... 100 lines of macro code ...\n}\n\n// BETTER: test macro outputs\n#[test]\nfn test_macro_expansion() {\n    // Use cargo-expand or trybuild\n}\n```\n\n---\n\n## Quick Reference\n\n| Anti-Pattern | Better Alternative |\n|--------------|-------------------|\n| Clone everywhere | Borrow when possible |\n| Unwrap everywhere | Propagate with `?` |\n| `String` parameters | `&str` parameters |\n| Index loops | Iterator loops |\n| Collect then process | Chain iterators |\n| Mutex for reads | RwLock for read-heavy |\n| Lock across await | Scope the lock |\n| Blocking in async | spawn_blocking |\n| Stringly typed | Strong types |\n| Boolean params | Builders or enums |\n",
        "skills/meta-cognition-parallel/SKILL.md": "---\nname: meta-cognition-parallel\ndescription: \"EXPERIMENTAL: Three-layer parallel meta-cognition analysis. Triggers on: /meta-parallel, ‰∏âÂ±ÇÂàÜÊûê, parallel analysis, Âπ∂Ë°åÂÖÉËÆ§Áü•\"\nargument-hint: \"<rust_question>\"\n---\n\n# Meta-Cognition Parallel Analysis (Experimental)\n\n> **Status:** Experimental | **Version:** 0.1.0\n>\n> This skill tests parallel three-layer cognitive analysis using `context: fork`.\n\n## Concept\n\nInstead of sequential analysis, this skill launches three parallel subagents - one for each cognitive layer - then synthesizes their results.\n\n```\nUser Question\n     ‚îÇ\n     ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ            meta-cognition-parallel                   ‚îÇ\n‚îÇ                  (Coordinator)                       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚îú‚îÄ‚îÄ‚îÄ Task(fork) ‚îÄ‚îÄ‚ñ∫ layer1-analyzer ‚îÄ‚îÄ‚ñ∫ L1 Result\n     ‚îÇ                   (Language Mechanics)\n     ‚îÇ\n     ‚îú‚îÄ‚îÄ‚îÄ Task(fork) ‚îÄ‚îÄ‚ñ∫ layer2-analyzer ‚îÄ‚îÄ‚ñ∫ L2 Result\n     ‚îÇ                   (Design Choices)         ‚îú‚îÄ‚îÄ Parallel\n     ‚îÇ                                            ‚îÇ\n     ‚îî‚îÄ‚îÄ‚îÄ Task(fork) ‚îÄ‚îÄ‚ñ∫ layer3-analyzer ‚îÄ‚îÄ‚ñ∫ L3 Result\n                         (Domain Constraints)\n     ‚îÇ\n     ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              Cross-Layer Synthesis                   ‚îÇ\n‚îÇ         (In main context with all results)          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚ñº\nDomain-Correct Architectural Solution\n```\n\n## Usage\n\n```\n/meta-parallel <your Rust question>\n```\n\n**Example:**\n```\n/meta-parallel ÊàëÁöÑ‰∫§ÊòìÁ≥ªÁªüÊä• E0382 ÈîôËØØÔºåÂ∫îËØ•Áî® clone ÂêóÔºü\n```\n\n## Execution Instructions\n\n### Step 1: Parse User Query\n\nExtract from `$ARGUMENTS`:\n- The original question\n- Any code snippets\n- Domain hints (trading, web, embedded, etc.)\n\n### Step 2: Launch Three Parallel Agents\n\n**CRITICAL: Launch all three Tasks in a SINGLE message to enable parallel execution.**\n\n```\nRead agent files, then launch in parallel:\n\nTask(\n  subagent_type: \"general-purpose\",\n  run_in_background: true,\n  prompt: <content of agents/layer1-analyzer.md>\n          + \"\\n\\n## User Query\\n\" + $ARGUMENTS\n)\n\nTask(\n  subagent_type: \"general-purpose\",\n  run_in_background: true,\n  prompt: <content of agents/layer2-analyzer.md>\n          + \"\\n\\n## User Query\\n\" + $ARGUMENTS\n)\n\nTask(\n  subagent_type: \"general-purpose\",\n  run_in_background: true,\n  prompt: <content of agents/layer3-analyzer.md>\n          + \"\\n\\n## User Query\\n\" + $ARGUMENTS\n)\n```\n\n### Step 3: Collect Results\n\nWait for all three agents to complete. Each returns structured analysis.\n\n### Step 4: Cross-Layer Synthesis\n\nWith all three results, perform synthesis:\n\n```markdown\n## Cross-Layer Synthesis\n\n### Layer Results Summary\n\n| Layer | Key Finding | Confidence |\n|-------|-------------|------------|\n| L1 (Mechanics) | [Summary] | [Level] |\n| L2 (Design) | [Summary] | [Level] |\n| L3 (Domain) | [Summary] | [Level] |\n\n### Cross-Layer Reasoning\n\n1. **L3 ‚Üí L2:** [How domain constraints affect design choice]\n2. **L2 ‚Üí L1:** [How design choice determines mechanism]\n3. **L1 ‚Üê L3:** [Direct domain impact on language features]\n\n### Synthesized Recommendation\n\n**Problem:** [Restated with full context]\n\n**Solution:** [Domain-correct architectural solution]\n\n**Rationale:**\n- Domain requires: [L3 constraint]\n- Design pattern: [L2 pattern]\n- Mechanism: [L1 implementation]\n\n### Confidence Assessment\n\n- **Overall:** HIGH | MEDIUM | LOW\n- **Limiting Factor:** [Which layer had lowest confidence]\n```\n\n## Output Template\n\n```markdown\n# Three-Layer Meta-Cognition Analysis\n\n> Query: [User's question]\n\n---\n\n## Layer 1: Language Mechanics\n[L1 agent result]\n\n---\n\n## Layer 2: Design Choices\n[L2 agent result]\n\n---\n\n## Layer 3: Domain Constraints\n[L3 agent result]\n\n---\n\n## Cross-Layer Synthesis\n\n### Reasoning Chain\n```\nL3 Domain: [Constraint]\n    ‚Üì implies\nL2 Design: [Pattern]\n    ‚Üì implemented via\nL1 Mechanism: [Feature]\n```\n\n### Final Recommendation\n\n**Do:** [Recommended approach]\n\n**Don't:** [What to avoid]\n\n**Code Pattern:**\n```rust\n// Recommended implementation\n```\n\n---\n\n*Analysis performed by meta-cognition-parallel v0.1.0 (experimental)*\n```\n\n## Test Scenarios\n\n### Test 1: Trading System E0382\n```\n/meta-parallel ‰∫§ÊòìÁ≥ªÁªüÊä• E0382Ôºåtrade record Ë¢´ move ‰∫Ü\n```\n\nExpected: L3 identifies FinTech constraints ‚Üí L2 suggests shared immutable ‚Üí L1 recommends Arc<T>\n\n### Test 2: Web API Concurrency\n```\n/meta-parallel Web API ‰∏≠Â§ö‰∏™ handler ÈúÄË¶ÅÂÖ±‰∫´Êï∞ÊçÆÂ∫ìËøûÊé•Ê±†\n```\n\nExpected: L3 identifies Web constraints ‚Üí L2 suggests connection pooling ‚Üí L1 recommends Arc<Pool>\n\n### Test 3: CLI Tool Config\n```\n/meta-parallel CLI Â∑•ÂÖ∑Â¶Ç‰ΩïÂ§ÑÁêÜÈÖçÁΩÆÊñá‰ª∂ÂíåÂëΩ‰ª§Ë°åÂèÇÊï∞ÁöÑ‰ºòÂÖàÁ∫ß\n```\n\nExpected: L3 identifies CLI constraints ‚Üí L2 suggests config precedence pattern ‚Üí L1 recommends builder pattern\n\n## Limitations (Experimental)\n\n- Subagent results are summarized, may lose detail\n- Parallel execution depends on Claude Code version\n- Cross-layer synthesis quality depends on result structure\n- May have higher latency than sequential approach\n\n## Feedback\n\nThis is experimental. Please report issues and suggestions to improve the three-layer parallel analysis approach.\n",
        "skills/rust-call-graph/SKILL.md": "---\nname: rust-call-graph\ndescription: \"Visualize Rust function call graphs using LSP. Triggers on: /call-graph, call hierarchy, who calls, what calls, Ë∞ÉÁî®Âõæ, Ë∞ÉÁî®ÂÖ≥Á≥ª, Ë∞ÅË∞ÉÁî®‰∫Ü, Ë∞ÉÁî®‰∫ÜË∞Å\"\nargument-hint: \"<function_name> [--depth N] [--direction in|out|both]\"\nallowed-tools: [\"LSP\", \"Read\", \"Glob\"]\n---\n\n# Rust Call Graph\n\nVisualize function call relationships using LSP call hierarchy.\n\n## Usage\n\n```\n/rust-call-graph <function_name> [--depth N] [--direction in|out|both]\n```\n\n**Options:**\n- `--depth N`: How many levels to traverse (default: 3)\n- `--direction`: `in` (callers), `out` (callees), `both`\n\n**Examples:**\n- `/rust-call-graph process_request` - Show both callers and callees\n- `/rust-call-graph handle_error --direction in` - Show only callers\n- `/rust-call-graph main --direction out --depth 5` - Deep callee analysis\n\n## LSP Operations\n\n### 1. Prepare Call Hierarchy\n\nGet the call hierarchy item for a function.\n\n```\nLSP(\n  operation: \"prepareCallHierarchy\",\n  filePath: \"src/handler.rs\",\n  line: 45,\n  character: 8\n)\n```\n\n### 2. Incoming Calls (Who calls this?)\n\n```\nLSP(\n  operation: \"incomingCalls\",\n  filePath: \"src/handler.rs\",\n  line: 45,\n  character: 8\n)\n```\n\n### 3. Outgoing Calls (What does this call?)\n\n```\nLSP(\n  operation: \"outgoingCalls\",\n  filePath: \"src/handler.rs\",\n  line: 45,\n  character: 8\n)\n```\n\n## Workflow\n\n```\nUser: \"Show call graph for process_request\"\n    ‚îÇ\n    ‚ñº\n[1] Find function location\n    LSP(workspaceSymbol) or Grep\n    ‚îÇ\n    ‚ñº\n[2] Prepare call hierarchy\n    LSP(prepareCallHierarchy)\n    ‚îÇ\n    ‚ñº\n[3] Get incoming calls (callers)\n    LSP(incomingCalls)\n    ‚îÇ\n    ‚ñº\n[4] Get outgoing calls (callees)\n    LSP(outgoingCalls)\n    ‚îÇ\n    ‚ñº\n[5] Recursively expand to depth N\n    ‚îÇ\n    ‚ñº\n[6] Generate ASCII visualization\n```\n\n## Output Format\n\n### Incoming Calls (Who calls this?)\n\n```\n## Callers of `process_request`\n\nmain\n‚îî‚îÄ‚îÄ run_server\n    ‚îî‚îÄ‚îÄ handle_connection\n        ‚îî‚îÄ‚îÄ process_request  ‚óÑ‚îÄ‚îÄ YOU ARE HERE\n```\n\n### Outgoing Calls (What does this call?)\n\n```\n## Callees of `process_request`\n\nprocess_request  ‚óÑ‚îÄ‚îÄ YOU ARE HERE\n‚îú‚îÄ‚îÄ parse_headers\n‚îÇ   ‚îî‚îÄ‚îÄ validate_header\n‚îú‚îÄ‚îÄ authenticate\n‚îÇ   ‚îú‚îÄ‚îÄ check_token\n‚îÇ   ‚îî‚îÄ‚îÄ load_user\n‚îú‚îÄ‚îÄ execute_handler\n‚îÇ   ‚îî‚îÄ‚îÄ [dynamic dispatch]\n‚îî‚îÄ‚îÄ send_response\n    ‚îî‚îÄ‚îÄ serialize_body\n```\n\n### Bidirectional (Both)\n\n```\n## Call Graph for `process_request`\n\n                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                    ‚îÇ      main       ‚îÇ\n                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                             ‚îÇ\n                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                    ‚îÇ   run_server    ‚îÇ\n                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                             ‚îÇ\n                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                    ‚îÇhandle_connection‚îÇ\n                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                             ‚îÇ\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        ‚îÇ                    ‚îÇ                    ‚îÇ\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ parse_headers ‚îÇ   ‚îÇ authenticate  ‚îÇ   ‚îÇsend_response  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                            ‚îÇ\n                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                    ‚îÇ               ‚îÇ\n             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n             ‚îÇ check_token ‚îÇ ‚îÇ  load_user  ‚îÇ\n             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Analysis Insights\n\nAfter generating the call graph, provide insights:\n\n```\n## Analysis\n\n**Entry Points:** main, test_process_request\n**Leaf Functions:** validate_header, serialize_body\n**Hot Path:** main ‚Üí run_server ‚Üí handle_connection ‚Üí process_request\n**Complexity:** 12 functions, 3 levels deep\n\n**Potential Issues:**\n- `authenticate` has high fan-out (4 callees)\n- `process_request` is called from 3 places (consider if this is intentional)\n```\n\n## Common Patterns\n\n| User Says | Direction | Use Case |\n|-----------|-----------|----------|\n| \"Who calls X?\" | incoming | Impact analysis |\n| \"What does X call?\" | outgoing | Understanding implementation |\n| \"Show call graph\" | both | Full picture |\n| \"Trace from main to X\" | outgoing | Execution path |\n\n## Visualization Options\n\n| Style | Best For |\n|-------|----------|\n| Tree (default) | Simple hierarchies |\n| Box diagram | Complex relationships |\n| Flat list | Many connections |\n| Mermaid | Export to docs |\n\n### Mermaid Export\n\n```mermaid\ngraph TD\n    main --> run_server\n    run_server --> handle_connection\n    handle_connection --> process_request\n    process_request --> parse_headers\n    process_request --> authenticate\n    process_request --> send_response\n```\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Find definition | rust-code-navigator |\n| Project structure | rust-symbol-analyzer |\n| Trait implementations | rust-trait-explorer |\n| Safe refactoring | rust-refactor-helper |\n",
        "skills/rust-code-navigator/SKILL.md": "---\nname: rust-code-navigator\ndescription: \"Navigate Rust code using LSP. Triggers on: /navigate, go to definition, find references, where is defined, Ë∑≥ËΩ¨ÂÆö‰πâ, Êü•ÊâæÂºïÁî®, ÂÆö‰πâÂú®Âì™, Ë∞ÅÁî®‰∫ÜËøô‰∏™\"\nargument-hint: \"<symbol> [in file.rs:line]\"\nallowed-tools: [\"LSP\", \"Read\", \"Glob\"]\n---\n\n# Rust Code Navigator\n\nNavigate large Rust codebases efficiently using Language Server Protocol.\n\n## Usage\n\n```\n/rust-code-navigator <symbol> [in file.rs:line]\n```\n\n**Examples:**\n- `/rust-code-navigator parse_config` - Find definition of parse_config\n- `/rust-code-navigator MyStruct in src/lib.rs:42` - Navigate from specific location\n\n## LSP Operations\n\n### 1. Go to Definition\n\nFind where a symbol is defined.\n\n```\nLSP(\n  operation: \"goToDefinition\",\n  filePath: \"src/main.rs\",\n  line: 25,\n  character: 10\n)\n```\n\n**Use when:**\n- User asks \"where is X defined?\"\n- User wants to understand a type/function\n- Ctrl+click equivalent\n\n### 2. Find References\n\nFind all usages of a symbol.\n\n```\nLSP(\n  operation: \"findReferences\",\n  filePath: \"src/lib.rs\",\n  line: 15,\n  character: 8\n)\n```\n\n**Use when:**\n- User asks \"who uses X?\"\n- Before refactoring/renaming\n- Understanding impact of changes\n\n### 3. Hover Information\n\nGet type and documentation for a symbol.\n\n```\nLSP(\n  operation: \"hover\",\n  filePath: \"src/main.rs\",\n  line: 30,\n  character: 15\n)\n```\n\n**Use when:**\n- User asks \"what type is X?\"\n- User wants documentation\n- Quick type checking\n\n## Workflow\n\n```\nUser: \"Where is the Config struct defined?\"\n    ‚îÇ\n    ‚ñº\n[1] Search for \"Config\" in workspace\n    LSP(operation: \"workspaceSymbol\", ...)\n    ‚îÇ\n    ‚ñº\n[2] If multiple results, ask user to clarify\n    ‚îÇ\n    ‚ñº\n[3] Go to definition\n    LSP(operation: \"goToDefinition\", ...)\n    ‚îÇ\n    ‚ñº\n[4] Show file path and context\n    Read surrounding code for context\n```\n\n## Output Format\n\n### Definition Found\n\n```\n## Config (struct)\n\n**Defined in:** `src/config.rs:15`\n\n‚Äã```rust\n#[derive(Debug, Clone)]\npub struct Config {\n    pub name: String,\n    pub port: u16,\n    pub debug: bool,\n}\n‚Äã```\n\n**Documentation:** Configuration for the application server.\n```\n\n### References Found\n\n```\n## References to `Config` (5 found)\n\n| Location | Context |\n|----------|---------|\n| src/main.rs:10 | `let config = Config::load()?;` |\n| src/server.rs:25 | `fn new(config: Config) -> Self` |\n| src/server.rs:42 | `self.config.port` |\n| src/tests.rs:15 | `Config::default()` |\n| src/cli.rs:8 | `config: Option<Config>` |\n```\n\n## Common Patterns\n\n| User Says | LSP Operation |\n|-----------|---------------|\n| \"Where is X defined?\" | goToDefinition |\n| \"Who uses X?\" | findReferences |\n| \"What type is X?\" | hover |\n| \"Find all structs\" | workspaceSymbol |\n| \"What's in this file?\" | documentSymbol |\n\n## Error Handling\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| \"No LSP server\" | rust-analyzer not running | Suggest: `rustup component add rust-analyzer` |\n| \"Symbol not found\" | Typo or not in scope | Search with workspaceSymbol first |\n| \"Multiple definitions\" | Generics or macros | Show all and let user choose |\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Call relationships | rust-call-graph |\n| Project structure | rust-symbol-analyzer |\n| Trait implementations | rust-trait-explorer |\n| Safe refactoring | rust-refactor-helper |\n",
        "skills/rust-daily/SKILL.md": "---\nname: rust-daily\ndescription: |\n  CRITICAL: Use for Rust news and daily/weekly/monthly reports. Triggers on:\n  rust news, rust daily, rust weekly, TWIR, rust blog,\n  Rust Êó•Êä•, Rust Âë®Êä•, Rust Êñ∞Èóª, Rust Âä®ÊÄÅ\nargument-hint: \"[today|week|month]\"\ncontext: fork\nagent: Explore\n---\n\n# Rust Daily Report\n\nFetch Rust community updates, filtered by time range.\n\n## Data Sources\n\n| Category | Sources |\n|----------|---------|\n| Ecosystem | Reddit r/rust, This Week in Rust |\n| Official | blog.rust-lang.org, Inside Rust |\n| Foundation | rustfoundation.org (news, blog, events) |\n\n## Parameters\n\n- `time_range`: day | week | month (default: week)\n- `category`: all | ecosystem | official | foundation\n\n## Execution\n\nRead agent file then launch Task:\n\n```\n1. Read: ../../agents/rust-daily-reporter.md\n2. Task(subagent_type: \"general-purpose\", run_in_background: false, prompt: <agent content>)\n```\n\n## Output Format\n\n```markdown\n# Rust {Weekly|Daily|Monthly} Report\n\n**Time Range:** {start} - {end}\n\n## Ecosystem\n| Score | Title | Link |\n\n## Official\n| Date | Title | Summary |\n\n## Foundation\n| Date | Title | Summary |\n```\n\n## Validation\n\n- Each source should have at least 1 result, otherwise mark \"No updates\"\n- On fetch failure, retry with alternative tool\n",
        "skills/rust-deps-visualizer/SKILL.md": "---\nname: rust-deps-visualizer\ndescription: \"Visualize Rust project dependencies as ASCII art. Triggers on: /deps-viz, dependency graph, show dependencies, visualize deps, ‰æùËµñÂõæ, ‰æùËµñÂèØËßÜÂåñ, ÊòæÁ§∫‰æùËµñ\"\nargument-hint: \"[--depth N] [--features]\"\nallowed-tools: [\"Bash\", \"Read\", \"Glob\"]\n---\n\n# Rust Dependencies Visualizer\n\nGenerate ASCII art visualizations of your Rust project's dependency tree.\n\n## Usage\n\n```\n/rust-deps-visualizer [--depth N] [--features]\n```\n\n**Options:**\n- `--depth N`: Limit tree depth (default: 3)\n- `--features`: Show feature flags\n\n## Output Format\n\n### Simple Tree (Default)\n\n```\nmy-project v0.1.0\n‚îú‚îÄ‚îÄ tokio v1.49.0\n‚îÇ   ‚îú‚îÄ‚îÄ pin-project-lite v0.2.x\n‚îÇ   ‚îî‚îÄ‚îÄ bytes v1.x\n‚îú‚îÄ‚îÄ serde v1.0.x\n‚îÇ   ‚îî‚îÄ‚îÄ serde_derive v1.0.x\n‚îî‚îÄ‚îÄ anyhow v1.x\n```\n\n### Feature-Aware Tree\n\n```\nmy-project v0.1.0\n‚îú‚îÄ‚îÄ tokio v1.49.0 [rt, rt-multi-thread, macros, fs, io-util]\n‚îÇ   ‚îú‚îÄ‚îÄ pin-project-lite v0.2.x\n‚îÇ   ‚îî‚îÄ‚îÄ bytes v1.x\n‚îú‚îÄ‚îÄ serde v1.0.x [derive]\n‚îÇ   ‚îî‚îÄ‚îÄ serde_derive v1.0.x (proc-macro)\n‚îî‚îÄ‚îÄ anyhow v1.x [std]\n```\n\n## Implementation\n\n**Step 1:** Parse Cargo.toml for direct dependencies\n\n```bash\ncargo metadata --format-version=1 --no-deps 2>/dev/null\n```\n\n**Step 2:** Get full dependency tree\n\n```bash\ncargo tree --depth=${DEPTH:-3} ${FEATURES:+--features} 2>/dev/null\n```\n\n**Step 3:** Format as ASCII art tree\n\nUse these box-drawing characters:\n- `‚îú‚îÄ‚îÄ` for middle items\n- `‚îî‚îÄ‚îÄ` for last items\n- `‚îÇ   ` for continuation lines\n\n## Visual Enhancements\n\n### Dependency Categories\n\n```\nmy-project v0.1.0\n‚îÇ\n‚îú‚îÄ[Runtime]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îÇ ‚îú‚îÄ‚îÄ tokio v1.49.0\n‚îÇ ‚îî‚îÄ‚îÄ async-trait v0.1.x\n‚îÇ\n‚îú‚îÄ[Serialization]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îÇ ‚îú‚îÄ‚îÄ serde v1.0.x\n‚îÇ ‚îî‚îÄ‚îÄ serde_json v1.x\n‚îÇ\n‚îî‚îÄ[Development]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  ‚îú‚îÄ‚îÄ criterion v0.5.x\n  ‚îî‚îÄ‚îÄ proptest v1.x\n```\n\n### Size Visualization (Optional)\n\n```\nmy-project v0.1.0\n‚îú‚îÄ‚îÄ tokio v1.49.0        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 2.1 MB\n‚îú‚îÄ‚îÄ serde v1.0.x         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 1.2 MB\n‚îú‚îÄ‚îÄ regex v1.x           ‚ñà‚ñà‚ñà‚ñà‚ñà 890 KB\n‚îî‚îÄ‚îÄ anyhow v1.x          ‚ñà‚ñà 120 KB\n                         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                         Total: 4.3 MB\n```\n\n## Workflow\n\n1. Check for Cargo.toml in current directory\n2. Run `cargo tree` with specified options\n3. Parse output and generate ASCII visualization\n4. Optionally categorize by purpose (runtime, dev, build)\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Crate selection advice | m11-ecosystem |\n| Workspace management | m11-ecosystem |\n| Feature flag decisions | m11-ecosystem |\n",
        "skills/rust-learner/SKILL.md": "---\nname: rust-learner\ndescription: \"Use when asking about Rust versions or crate info. Keywords: latest version, what's new, changelog, Rust 1.x, Rust release, stable, nightly, crate info, crates.io, lib.rs, docs.rs, API documentation, crate features, dependencies, which crate, what version, Rust edition, edition 2021, edition 2024, cargo add, cargo update, ÊúÄÊñ∞ÁâàÊú¨, ÁâàÊú¨Âè∑, Á®≥ÂÆöÁâà, ÊúÄÊñ∞, Âì™‰∏™ÁâàÊú¨, crate ‰ø°ÊÅØ, ÊñáÊ°£, ‰æùËµñ, Rust ÁâàÊú¨, Êñ∞ÁâπÊÄß, Êúâ‰ªÄ‰πàÁâπÊÄß\"\nallowed-tools: [\"Task\", \"Read\", \"Glob\"]\n---\n\n# Rust Learner\n\n> **Version:** 2.0.0 | **Last Updated:** 2025-01-22\n\nYou are an expert at fetching Rust and crate information. Help users by:\n- **Version queries**: Get latest Rust/crate versions via background agents\n- **API documentation**: Fetch docs from docs.rs\n- **Changelog**: Get Rust version features from releases.rs\n\n**Primary skill for fetching Rust/crate information. All agents run in background.**\n\n## CRITICAL: How to Launch Agents\n\n**All agents MUST be launched via Task tool with these parameters:**\n\n```\nTask(\n  subagent_type: \"general-purpose\",\n  run_in_background: true,\n  prompt: <read from ../../agents/*.md file>\n)\n```\n\n**Workflow:**\n1. Read the agent prompt file: `../../agents/<agent-name>.md` (relative to this skill)\n2. Launch Task with `run_in_background: true`\n3. Continue with other work or wait for completion\n4. Read results when agent completes\n\n## Agent Routing Table\n\n| Query Type | Agent File | Source |\n|------------|------------|--------|\n| Rust version features | `../../agents/rust-changelog.md` | releases.rs |\n| Crate info/version | `../../agents/crate-researcher.md` | lib.rs, crates.io |\n| **Std library docs** (Send, Sync, Arc, etc.) | `../../agents/std-docs-researcher.md` | doc.rust-lang.org |\n| Third-party crate docs (tokio, serde, etc.) | `../../agents/docs-researcher.md` | docs.rs |\n| Clippy lints | `../../agents/clippy-researcher.md` | rust-clippy docs |\n| **Rust news/daily report** | `../../agents/rust-daily-reporter.md` | Reddit, TWIR, blogs |\n\n### Choosing docs-researcher vs std-docs-researcher\n\n| Query Pattern | Use Agent |\n|---------------|-----------|\n| `std::*`, `Send`, `Sync`, `Arc`, `Rc`, `Box`, `Vec`, `String` | `std-docs-researcher` |\n| `tokio::*`, `serde::*`, any third-party crate | `docs-researcher` |\n\n## Tool Chain\n\nAll agents use this tool chain (in order):\n\n1. **actionbook MCP** (first - get pre-computed selectors)\n   - `mcp__actionbook__search_actions(\"site_name\")` ‚Üí get action ID\n   - `mcp__actionbook__get_action_by_id(id)` ‚Üí get URL + selectors\n\n2. **agent-browser CLI** (PRIMARY execution tool)\n   ```bash\n   agent-browser open <url>\n   agent-browser get text <selector_from_actionbook>\n   agent-browser close\n   ```\n\n3. **WebFetch** (LAST RESORT only if agent-browser unavailable)\n\n### Fallback Principle (CRITICAL)\n\n```\nactionbook ‚Üí agent-browser ‚Üí WebFetch (only if agent-browser unavailable)\n```\n\n**DO NOT:**\n- Skip agent-browser because it's slower\n- Use WebFetch as primary when agent-browser is available\n- Block on WebFetch without trying agent-browser first\n\n## Example: Crate Version Query\n\n```\nUser: \"tokio latest version\"\n\nClaude:\n1. Read ../../agents/crate-researcher.md\n2. Task(\n     subagent_type: \"general-purpose\",\n     run_in_background: true,\n     prompt: \"Fetch crate info for 'tokio'. Use actionbook MCP to get lib.rs selectors, then agent-browser to fetch. Return: name, version, description, features.\"\n   )\n3. Wait for agent or continue with other work\n4. Summarize results to user\n```\n\n## Example: Third-Party Crate Documentation\n\n```\nUser: \"tokio::spawn documentation\"\n\nClaude:\n1. Read ../../agents/docs-researcher.md\n2. Task(\n     subagent_type: \"general-purpose\",\n     run_in_background: true,\n     prompt: \"Fetch API docs for tokio::spawn from docs.rs. Use agent-browser first. Return: signature, description, examples.\"\n   )\n3. Wait for agent\n4. Summarize API to user\n```\n\n## Example: Std Library Documentation\n\n```\nUser: \"Send trait documentation\"\n\nClaude:\n1. Read ../../agents/std-docs-researcher.md  (NOT docs-researcher!)\n2. Task(\n     subagent_type: \"general-purpose\",\n     run_in_background: true,\n     prompt: \"Fetch std::marker::Send trait docs from doc.rust-lang.org. Use agent-browser first. Return: description, implementors, examples.\"\n   )\n3. Wait for agent\n4. Summarize trait to user\n```\n\n## Example: Rust Changelog Query\n\n```\nUser: \"What's new in Rust 1.85?\"\n\nClaude:\n1. Read ../../agents/rust-changelog.md\n2. Task(\n     subagent_type: \"general-purpose\",\n     run_in_background: true,\n     prompt: \"Fetch Rust 1.85 changelog from releases.rs. Use actionbook MCP for selectors, agent-browser to fetch. Return: language features, library changes, stabilized APIs.\"\n   )\n3. Wait for agent\n4. Summarize features to user\n```\n\n## Deprecated Patterns\n\n| Deprecated | Use Instead | Reason |\n|------------|-------------|--------|\n| WebSearch for crate info | Task + crate-researcher | Structured data |\n| Direct WebFetch | Task + actionbook | Pre-computed selectors |\n| Foreground agent execution | `run_in_background: true` | Non-blocking |\n| Guessing version numbers | Always use agents | Prevents misinformation |\n\n## Error Handling\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| actionbook unavailable | MCP not configured | Fall back to WebFetch |\n| agent-browser not found | CLI not installed | Fall back to WebFetch |\n| Agent timeout | Site slow/down | Retry or inform user |\n| Empty results | Selector mismatch | Report and use WebFetch fallback |\n\n## Proactive Triggering\n\nThis skill triggers AUTOMATICALLY when:\n- Any Rust crate name mentioned (tokio, serde, axum, sqlx, etc.)\n- Questions about \"latest\", \"new\", \"version\", \"changelog\"\n- API documentation requests\n- Dependency/feature questions\n\n**DO NOT use WebSearch for Rust crate info. Launch background agents instead.**\n",
        "skills/rust-refactor-helper/SKILL.md": "---\nname: rust-refactor-helper\ndescription: \"Safe Rust refactoring with LSP analysis. Triggers on: /refactor, rename symbol, move function, extract, ÈáçÊûÑ, ÈáçÂëΩÂêç, ÊèêÂèñÂáΩÊï∞, ÂÆâÂÖ®ÈáçÊûÑ\"\nargument-hint: \"<action> <target> [--dry-run]\"\nallowed-tools: [\"LSP\", \"Read\", \"Glob\", \"Grep\", \"Edit\"]\n---\n\n# Rust Refactor Helper\n\nPerform safe refactoring with comprehensive impact analysis.\n\n## Usage\n\n```\n/rust-refactor-helper <action> <target> [--dry-run]\n```\n\n**Actions:**\n- `rename <old> <new>` - Rename symbol\n- `extract-fn <selection>` - Extract to function\n- `inline <fn>` - Inline function\n- `move <symbol> <dest>` - Move to module\n\n**Examples:**\n- `/rust-refactor-helper rename parse_config load_config`\n- `/rust-refactor-helper extract-fn src/main.rs:20-35`\n- `/rust-refactor-helper move UserService src/services/`\n\n## LSP Operations Used\n\n### Pre-Refactor Analysis\n\n```\n# Find all references before renaming\nLSP(\n  operation: \"findReferences\",\n  filePath: \"src/lib.rs\",\n  line: 25,\n  character: 8\n)\n\n# Get symbol info\nLSP(\n  operation: \"hover\",\n  filePath: \"src/lib.rs\",\n  line: 25,\n  character: 8\n)\n\n# Check call hierarchy for move operations\nLSP(\n  operation: \"incomingCalls\",\n  filePath: \"src/lib.rs\",\n  line: 25,\n  character: 8\n)\n```\n\n## Refactoring Workflows\n\n### 1. Rename Symbol\n\n```\nUser: \"Rename parse_config to load_config\"\n    ‚îÇ\n    ‚ñº\n[1] Find symbol definition\n    LSP(goToDefinition)\n    ‚îÇ\n    ‚ñº\n[2] Find ALL references\n    LSP(findReferences)\n    ‚îÇ\n    ‚ñº\n[3] Categorize by file\n    ‚îÇ\n    ‚ñº\n[4] Check for conflicts\n    - Is 'load_config' already used?\n    - Are there macro-generated uses?\n    ‚îÇ\n    ‚ñº\n[5] Show impact analysis (--dry-run)\n    ‚îÇ\n    ‚ñº\n[6] Apply changes with Edit tool\n```\n\n**Output:**\n\n```\n## Rename: parse_config ‚Üí load_config\n\n### Impact Analysis\n\n**Definition:** src/config.rs:25\n**References found:** 8\n\n| File | Line | Context | Change |\n|------|------|---------|--------|\n| src/config.rs | 25 | `pub fn parse_config(` | Definition |\n| src/config.rs | 45 | `parse_config(path)?` | Call |\n| src/main.rs | 12 | `config::parse_config` | Import |\n| src/main.rs | 30 | `let cfg = parse_config(` | Call |\n| src/lib.rs | 8 | `pub use config::parse_config` | Re-export |\n| tests/config_test.rs | 15 | `parse_config(\"test.toml\")` | Test |\n| tests/config_test.rs | 25 | `parse_config(\"\")` | Test |\n| docs/api.md | 42 | `parse_config` | Documentation |\n\n### Potential Issues\n\n‚ö†Ô∏è **Documentation reference:** docs/api.md:42 may need manual update\n‚ö†Ô∏è **Re-export:** src/lib.rs:8 - public API change\n\n### Proceed?\n- [x] --dry-run (preview only)\n- [ ] Apply changes\n```\n\n### 2. Extract Function\n\n```\nUser: \"Extract lines 20-35 in main.rs to a function\"\n    ‚îÇ\n    ‚ñº\n[1] Read the selected code block\n    ‚îÇ\n    ‚ñº\n[2] Analyze variables\n    - Which are inputs? (used but not defined in block)\n    - Which are outputs? (defined and used after block)\n    - Which are local? (defined and used only in block)\n    ‚îÇ\n    ‚ñº\n[3] Determine function signature\n    ‚îÇ\n    ‚ñº\n[4] Check for early returns, loops, etc.\n    ‚îÇ\n    ‚ñº\n[5] Generate extracted function\n    ‚îÇ\n    ‚ñº\n[6] Replace original code with call\n```\n\n**Output:**\n\n```\n## Extract Function: src/main.rs:20-35\n\n### Selected Code\n‚Äã```rust\nlet file = File::open(&path)?;\nlet mut contents = String::new();\nfile.read_to_string(&mut contents)?;\nlet config: Config = toml::from_str(&contents)?;\nvalidate_config(&config)?;\n‚Äã```\n\n### Analysis\n\n**Inputs:** path: &Path\n**Outputs:** config: Config\n**Side Effects:** File I/O, may return error\n\n### Extracted Function\n\n‚Äã```rust\nfn load_and_validate_config(path: &Path) -> Result<Config> {\n    let file = File::open(path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    let config: Config = toml::from_str(&contents)?;\n    validate_config(&config)?;\n    Ok(config)\n}\n‚Äã```\n\n### Replacement\n\n‚Äã```rust\nlet config = load_and_validate_config(&path)?;\n‚Äã```\n```\n\n### 3. Move Symbol\n\n```\nUser: \"Move UserService to src/services/\"\n    ‚îÇ\n    ‚ñº\n[1] Find symbol and all its dependencies\n    ‚îÇ\n    ‚ñº\n[2] Find all references (callers)\n    LSP(findReferences)\n    ‚îÇ\n    ‚ñº\n[3] Analyze import changes needed\n    ‚îÇ\n    ‚ñº\n[4] Check for circular dependencies\n    ‚îÇ\n    ‚ñº\n[5] Generate move plan\n```\n\n**Output:**\n\n```\n## Move: UserService ‚Üí src/services/user.rs\n\n### Current Location\nsrc/handlers/auth.rs:50-120\n\n### Dependencies (will be moved together)\n- struct UserService (50-80)\n- impl UserService (82-120)\n- const DEFAULT_TIMEOUT (48)\n\n### Import Changes Required\n\n| File | Current | New |\n|------|---------|-----|\n| src/main.rs | `use handlers::auth::UserService` | `use services::user::UserService` |\n| src/handlers/api.rs | `use super::auth::UserService` | `use crate::services::user::UserService` |\n| tests/auth_test.rs | `use crate::handlers::auth::UserService` | `use crate::services::user::UserService` |\n\n### New File Structure\n\n‚Äã```\nsrc/\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ mod.rs (NEW - add `pub mod user;`)\n‚îÇ   ‚îî‚îÄ‚îÄ user.rs (NEW - UserService moved here)\n‚îú‚îÄ‚îÄ handlers/\n‚îÇ   ‚îî‚îÄ‚îÄ auth.rs (UserService removed)\n‚Äã```\n\n### Circular Dependency Check\n‚úÖ No circular dependencies detected\n```\n\n## Safety Checks\n\n| Check | Purpose |\n|-------|---------|\n| Reference completeness | Ensure all uses are found |\n| Name conflicts | Detect existing symbols with same name |\n| Visibility changes | Warn if pub/private scope changes |\n| Macro-generated code | Warn about code in macros |\n| Documentation | Flag doc comments mentioning symbol |\n| Test coverage | Show affected tests |\n\n## Dry Run Mode\n\nAlways use `--dry-run` first to preview changes:\n\n```\n/rust-refactor-helper rename old_name new_name --dry-run\n```\n\nThis shows all changes without applying them.\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Navigate to symbol | rust-code-navigator |\n| Understand call flow | rust-call-graph |\n| Project structure | rust-symbol-analyzer |\n| Trait implementations | rust-trait-explorer |\n",
        "skills/rust-router/SKILL.md": "---\nname: rust-router\ndescription: \"CRITICAL: Use for ALL Rust questions including errors, design, and coding.\nHIGHEST PRIORITY for: ÊØîËæÉ, ÂØπÊØî, compare, vs, versus, Âå∫Âà´, difference, ÊúÄ‰Ω≥ÂÆûË∑µ, best practice,\ntokio vs, async-std vs, ÊØîËæÉ tokio, ÊØîËæÉ async,\nTriggers on: Rust, cargo, rustc, crate, Cargo.toml,\nÊÑèÂõæÂàÜÊûê, ÈóÆÈ¢òÂàÜÊûê, ËØ≠‰πâÂàÜÊûê, analyze intent, question analysis,\ncompile error, borrow error, lifetime error, ownership error, type error, trait error,\nvalue moved, cannot borrow, does not live long enough, mismatched types, not satisfied,\nE0382, E0597, E0277, E0308, E0499, E0502, E0596,\nasync, await, Send, Sync, tokio, concurrency, error handling,\nÁºñËØëÈîôËØØ, compile error, ÊâÄÊúâÊùÉ, ownership, ÂÄüÁî®, borrow, ÁîüÂëΩÂë®Êúü, lifetime, Á±ªÂûãÈîôËØØ, type error,\nÂºÇÊ≠•, async, Âπ∂Âèë, concurrency, ÈîôËØØÂ§ÑÁêÜ, error handling,\nÈóÆÈ¢ò, problem, question, ÊÄé‰πàÁî®, how to use, Â¶Ç‰Ωï, how to, ‰∏∫‰ªÄ‰πà, why,\n‰ªÄ‰πàÊòØ, what is, Â∏ÆÊàëÂÜô, help me write, ÂÆûÁé∞, implement, Ëß£Èáä, explain\"\nglobs: [\"**/Cargo.toml\", \"**/*.rs\"]\n---\n\n---\n\n# Rust Question Router\n\n> **Version:** 2.0.0 | **Last Updated:** 2025-01-22\n>\n> **v2.0:** Context optimized - detailed examples moved to sub-files\n\n## Meta-Cognition Framework\n\n### Core Principle\n\n**Don't answer directly. Trace through the cognitive layers first.**\n\n```\nLayer 3: Domain Constraints (WHY)\n‚îú‚îÄ‚îÄ Business rules, regulatory requirements\n‚îú‚îÄ‚îÄ domain-fintech, domain-web, domain-cli, etc.\n‚îî‚îÄ‚îÄ \"Why is it designed this way?\"\n\nLayer 2: Design Choices (WHAT)\n‚îú‚îÄ‚îÄ Architecture patterns, DDD concepts\n‚îú‚îÄ‚îÄ m09-m15 skills\n‚îî‚îÄ‚îÄ \"What pattern should I use?\"\n\nLayer 1: Language Mechanics (HOW)\n‚îú‚îÄ‚îÄ Ownership, borrowing, lifetimes, traits\n‚îú‚îÄ‚îÄ m01-m07 skills\n‚îî‚îÄ‚îÄ \"How do I implement this in Rust?\"\n```\n\n### Routing by Entry Point\n\n| User Signal | Entry Layer | Direction | First Skill |\n|-------------|-------------|-----------|-------------|\n| E0xxx error | Layer 1 | Trace UP ‚Üë | m01-m07 |\n| Compile error | Layer 1 | Trace UP ‚Üë | Error table below |\n| \"How to design...\" | Layer 2 | Check L3, then DOWN ‚Üì | m09-domain |\n| \"Building [domain] app\" | Layer 3 | Trace DOWN ‚Üì | domain-* |\n| \"Best practice...\" | Layer 2 | Both directions | m09-m15 |\n| Performance issue | Layer 1 ‚Üí 2 | UP then DOWN | m10-performance |\n\n### CRITICAL: Dual-Skill Loading\n\n**When domain keywords are present, you MUST load BOTH skills:**\n\n| Domain Keywords | L1 Skill | L3 Skill |\n|-----------------|----------|----------|\n| Web API, HTTP, axum, handler | m07-concurrency | **domain-web** |\n| ‰∫§Êòì, ÊîØ‰ªò, trading, payment | m01-ownership | **domain-fintech** |\n| CLI, terminal, clap | m07-concurrency | **domain-cli** |\n| kubernetes, grpc, microservice | m07-concurrency | **domain-cloud-native** |\n| embedded, no_std, MCU | m02-resource | **domain-embedded** |\n\n---\n\n## INSTRUCTIONS FOR CLAUDE\n\n### CRITICAL: Negotiation Protocol Trigger\n\n**BEFORE answering, check if negotiation is required:**\n\n| Query Contains | Action |\n|----------------|--------|\n| \"ÊØîËæÉ\", \"ÂØπÊØî\", \"compare\", \"vs\", \"versus\" | **MUST use negotiation** |\n| \"ÊúÄ‰Ω≥ÂÆûË∑µ\", \"best practice\" | **MUST use negotiation** |\n| Domain + error (e.g., \"‰∫§ÊòìÁ≥ªÁªü E0382\") | **MUST use negotiation** |\n| Ambiguous scope (e.g., \"tokio ÊÄßËÉΩ\") | **SHOULD use negotiation** |\n\n**When negotiation is required, include:**\n\n```markdown\n## Negotiation Analysis\n\n**Query Type:** [Comparative | Cross-domain | Synthesis | Ambiguous]\n**Negotiation:** Enabled\n\n### Source: [Agent/Skill Name]\n**Confidence:** HIGH | MEDIUM | LOW | UNCERTAIN\n**Gaps:** [What's missing]\n\n## Synthesized Answer\n[Answer]\n\n**Overall Confidence:** [Level]\n**Disclosed Gaps:** [Gaps user should know]\n```\n\n> **ËØ¶ÁªÜÂçèËÆÆËßÅ:** `patterns/negotiation.md`\n\n---\n\n### Default Project Settings\n\nWhen creating new Rust projects or Cargo.toml files, ALWAYS use:\n\n```toml\n[package]\nedition = \"2024\"  # ALWAYS use latest stable edition\nrust-version = \"1.85\"\n\n[lints.rust]\nunsafe_code = \"warn\"\n\n[lints.clippy]\nall = \"warn\"\npedantic = \"warn\"\n```\n\n---\n\n## Layer 1 Skills (Language Mechanics)\n\n| Pattern | Route To |\n|---------|----------|\n| move, borrow, lifetime, E0382, E0597 | m01-ownership |\n| Box, Rc, Arc, RefCell, Cell | m02-resource |\n| mut, interior mutability, E0499, E0502, E0596 | m03-mutability |\n| generic, trait, inline, monomorphization | m04-zero-cost |\n| type state, phantom, newtype | m05-type-driven |\n| Result, Error, panic, ?, anyhow, thiserror | m06-error-handling |\n| Send, Sync, thread, async, channel | m07-concurrency |\n| unsafe, FFI, extern, raw pointer, transmute | **unsafe-checker** |\n\n## Layer 2 Skills (Design Choices)\n\n| Pattern | Route To |\n|---------|----------|\n| domain model, business logic | m09-domain |\n| performance, optimization, benchmark | m10-performance |\n| integration, interop, bindings | m11-ecosystem |\n| resource lifecycle, RAII, Drop | m12-lifecycle |\n| domain error, recovery strategy | m13-domain-error |\n| mental model, how to think | m14-mental-model |\n| anti-pattern, common mistake, pitfall | m15-anti-pattern |\n\n## Layer 3 Skills (Domain Constraints)\n\n| Domain Keywords | Route To |\n|-----------------|----------|\n| fintech, trading, decimal, currency | domain-fintech |\n| ml, tensor, model, inference | domain-ml |\n| kubernetes, docker, grpc, microservice | domain-cloud-native |\n| embedded, sensor, mqtt, iot | domain-iot |\n| web server, HTTP, REST, axum, actix | domain-web |\n| CLI, command line, clap, terminal | domain-cli |\n| no_std, microcontroller, firmware | domain-embedded |\n\n---\n\n## Error Code Routing\n\n| Error Code | Route To | Common Cause |\n|------------|----------|--------------|\n| E0382 | m01-ownership | Use of moved value |\n| E0597 | m01-ownership | Lifetime too short |\n| E0506 | m01-ownership | Cannot assign to borrowed |\n| E0507 | m01-ownership | Cannot move out of borrowed |\n| E0515 | m01-ownership | Return local reference |\n| E0716 | m01-ownership | Temporary value dropped |\n| E0106 | m01-ownership | Missing lifetime specifier |\n| E0596 | m03-mutability | Cannot borrow as mutable |\n| E0499 | m03-mutability | Multiple mutable borrows |\n| E0502 | m03-mutability | Borrow conflict |\n| E0277 | m04/m07 | Trait bound not satisfied |\n| E0308 | m04-zero-cost | Type mismatch |\n| E0599 | m04-zero-cost | No method found |\n| E0038 | m04-zero-cost | Trait not object-safe |\n| E0433 | m11-ecosystem | Cannot find crate/module |\n\n---\n\n## Functional Routing Table\n\n| Pattern | Route To | Action |\n|---------|----------|--------|\n| latest version, what's new | **rust-learner** | Use agents |\n| API, docs, documentation | **docs-researcher** | Use agent |\n| code style, naming, clippy | **coding-guidelines** | Read skill |\n| unsafe code, FFI | **unsafe-checker** | Read skill |\n| code review | **os-checker** | See `integrations/os-checker.md` |\n\n---\n\n## Priority Order\n\n1. **Identify cognitive layer** (L1/L2/L3)\n2. **Load entry skill** (m0x/m1x/domain)\n3. **Trace through layers** (UP or DOWN)\n4. **Cross-reference skills** as indicated in \"Trace\" sections\n5. **Answer with reasoning chain**\n\n### Keyword Conflict Resolution\n\n| Keyword | Resolution |\n|---------|------------|\n| `unsafe` | **unsafe-checker** (more specific than m11) |\n| `error` | **m06** for general, **m13** for domain-specific |\n| `RAII` | **m12** for design, **m01** for implementation |\n| `crate` | **rust-learner** for version, **m11** for integration |\n| `tokio` | **tokio-*** for API, **m07** for concepts |\n\n**Priority Hierarchy:**\n\n```\n1. Error codes (E0xxx) ‚Üí Direct lookup, highest priority\n2. Negotiation triggers (compare, vs, best practice) ‚Üí Enable negotiation\n3. Domain keywords + error ‚Üí Load BOTH domain + error skills\n4. Specific crate keywords ‚Üí Route to crate-specific skill if exists\n5. General concept keywords ‚Üí Route to meta-question skill\n```\n\n---\n\n## Sub-Files Reference\n\n| File | Content |\n|------|---------|\n| `patterns/negotiation.md` | Negotiation protocol details |\n| `examples/workflow.md` | Workflow examples |\n| `integrations/os-checker.md` | OS-Checker integration |\n",
        "skills/rust-router/examples/workflow.md": "# Workflow Examples\n\n> rust-router ÁöÑÂ∑•‰ΩúÊµÅÁ®ãÁ§∫‰æã\n\n## Example 1: Error Code with Domain Context\n\n```\nUser: \"Why am I getting E0382 in my trading system?\"\n\nAnalysis:\n1. Entry: Layer 1 (E0382 = ownership/move error)\n2. Load: m01-ownership skill\n3. Context: \"trading system\" ‚Üí domain-fintech\n\nTrace UP ‚Üë:\n- E0382 in trading context\n- Check domain-fintech: \"immutable audit records\"\n- Finding: Trading data should be shared, not moved\n\nResponse:\n\"E0382 indicates a value was moved when still needed.\nIn a trading system (domain-fintech), transaction records\nshould be immutable and shareable for audit purposes.\n\nInstead of cloning, consider:\n- Arc<TradeRecord> for shared immutable access\n- This aligns with financial audit requirements\n\nSee: m01-ownership (Trace Up section),\n     domain-fintech (Audit Requirements)\"\n```\n\n## Example 2: Design Question\n\n```\nUser: \"How should I handle user authentication?\"\n\n1. Entry: Layer 2 (design question)\n2. Trace UP to Layer 3: domain-web constraints\n3. Load: domain-web skill (security, stateless HTTP)\n4. Trace DOWN: m06-error-handling, m07-concurrency\n5. Answer: JWT with proper error types, async handlers\n```\n\n## Example 3: Comparative Query\n\n```\nUser: \"Compare tokio and async-std\"\n\n1. Detect: \"compare\" ‚Üí Enable negotiation\n2. Load both runtime knowledge sources\n3. Assess confidence for each\n4. Synthesize with disclosed gaps\n5. Answer: Structured comparison table\n```\n\n## Example 4: Multi-Layer Trace\n\n```\nUser: \"My web API reports Rc cannot be sent between threads\"\n\n1. Entry: Layer 1 (Send/Sync error)\n2. Load: m07-concurrency\n3. Detect: \"web API\" ‚Üí domain-web\n4. Dual-skill loading:\n   - m07: Explain Send/Sync bounds\n   - domain-web: Web state management patterns\n5. Answer: Use Arc instead of Rc, or move to thread-local\n```\n\n## Example 5: Intent Analysis Request\n\n```\nUser: \"Analyze this question: How do I share state in actix-web?\"\n\nAnalysis Steps:\n1. Extract Keywords: share, state, actix-web\n2. Identify Entry Layer: Layer 1 (sharing = concurrency) + Layer 3 (actix-web = web)\n3. Map to Skills: m07-concurrency, domain-web\n4. Report:\n   - Layer 1: Concurrency (state sharing mechanisms)\n   - Layer 3: Web domain (HTTP handler patterns)\n   - Suggested trace: L1 ‚Üí L3\n5. Invoke: m07-concurrency first, then domain-web\n```\n",
        "skills/rust-router/integrations/os-checker.md": "# OS-Checker Integration\n\n> ‰ª£Á†ÅÂÆ°Êü•ÂíåÂÆâÂÖ®ÂÆ°ËÆ°Â∑•ÂÖ∑ÈõÜÊàê\n\n## Available Commands\n\n| Use Case | Command | Tools |\n|----------|---------|-------|\n| Daily check | `/rust-review` | clippy |\n| Security audit | `/audit security` | cargo audit, geiger |\n| Unsafe audit | `/audit safety` | miri, rudra |\n| Concurrency audit | `/audit concurrency` | lockbud |\n| Full audit | `/audit full` | all os-checker tools |\n\n## When to Suggest OS-Checker\n\n| User Intent | Suggest |\n|-------------|---------|\n| Code review request | `/rust-review` |\n| Security concerns | `/audit security` |\n| Unsafe code review | `/audit safety` |\n| Deadlock/race concerns | `/audit concurrency` |\n| Pre-release check | `/audit full` |\n\n## Tool Descriptions\n\n### clippy\nStandard Rust linter for code style and common mistakes.\n\n### cargo audit\nSecurity vulnerability scanner for dependencies.\n\n### geiger\nCounts unsafe code usage in dependencies.\n\n### miri\nInterprets MIR to detect undefined behavior.\n\n### rudra\nMemory safety bug detector.\n\n### lockbud\nDeadlock and concurrency bug detector.\n\n## Integration Flow\n\n```\nUser: \"Review my unsafe code\"\n     ‚îÇ\n     ‚ñº\nRouter detects: unsafe + review\n     ‚îÇ\n     ‚îú‚îÄ‚îÄ Load: unsafe-checker skill (for manual review)\n     ‚îÇ\n     ‚îî‚îÄ‚îÄ Suggest: `/audit safety` (for automated check)\n```\n",
        "skills/rust-router/patterns/negotiation.md": "# Negotiation Protocol\n\n> ÊØîËæÉÊü•ËØ¢ÂíåË∑®È¢ÜÂüüÈóÆÈ¢òÁöÑÂ§ÑÁêÜÂçèËÆÆ\n\n## When to Enable Negotiation\n\nFor complex queries requiring structured agent responses, enable negotiation mode.\n\n| Query Pattern | Enable Negotiation | Reason |\n|---------------|-------------------|--------|\n| Single error code lookup | No | Direct answer |\n| Single crate version | No | Direct lookup |\n| \"Compare X and Y\" | **Yes** | Multi-faceted |\n| Domain + error | **Yes** | Cross-layer context |\n| \"Best practices for...\" | **Yes** | Requires synthesis |\n| Ambiguous scope | **Yes** | Needs clarification |\n| Multi-crate question | **Yes** | Multiple sources |\n\n## Negotiation Decision Flow\n\n```\nQuery Received\n     ‚îÇ\n     ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Is query single-lookup?     ‚îÇ\n‚îÇ (version, error code, def)  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚îú‚îÄ‚îÄ Yes ‚Üí Direct dispatch (no negotiation)\n     ‚îÇ\n     ‚ñº No\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Does query require:         ‚îÇ\n‚îÇ - Comparison?               ‚îÇ\n‚îÇ - Cross-domain context?     ‚îÇ\n‚îÇ - Synthesis/aggregation?    ‚îÇ\n‚îÇ - Multiple sources?         ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚îú‚îÄ‚îÄ Yes ‚Üí Dispatch with negotiation: true\n     ‚îÇ\n     ‚ñº No\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Is scope ambiguous?         ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n     ‚îÇ\n     ‚îú‚îÄ‚îÄ Yes ‚Üí Dispatch with negotiation: true\n     ‚îÇ\n     ‚ñº No\n     ‚îî‚îÄ‚îÄ Direct dispatch (no negotiation)\n```\n\n## Negotiation Dispatch\n\nWhen dispatching with negotiation:\n\n```\n1. Set `negotiation: true`\n2. Include original query context\n3. Expect structured response:\n   - Findings\n   - Confidence (HIGH/MEDIUM/LOW/UNCERTAIN)\n   - Gaps identified\n   - Context questions (if any)\n4. Evaluate response against original intent\n```\n\n## Orchestrator Evaluation\n\nAfter receiving negotiation response:\n\n| Confidence | Intent Coverage | Action |\n|------------|-----------------|--------|\n| HIGH | Complete | Synthesize answer |\n| HIGH | Partial | May need supplementary query |\n| MEDIUM | Complete | Accept with disclosed gaps |\n| MEDIUM | Partial | Refine with context |\n| LOW | Any | Refine or try alternative |\n| UNCERTAIN | Any | Try alternative or escalate |\n\n## Refinement Loop\n\nIf response insufficient:\n\n```\nRound 1: Initial query\n  ‚îÇ\n  ‚ñº (LOW confidence or gaps block intent)\nRound 2: Refined query with:\n  - Answers to agent's context questions\n  - Narrowed scope\n  ‚îÇ\n  ‚ñº (still insufficient)\nRound 3: Final attempt with:\n  - Alternative agent/source\n  - Maximum context provided\n  ‚îÇ\n  ‚ñº (still insufficient)\nSynthesize best-effort answer with disclosed gaps\n```\n\n## Integration with 3-Strike Rule\n\nNegotiation follows the 3-Strike escalation:\n\n```\nStrike 1: Initial query returns LOW confidence\n  ‚Üí Refine with more context\n\nStrike 2: Refined query still LOW\n  ‚Üí Try alternative agent/source\n\nStrike 3: Still insufficient\n  ‚Üí Synthesize best-effort answer\n  ‚Üí Report gaps to user explicitly\n```\n\nSee `_meta/error-protocol.md` for full escalation rules.\n\n## Negotiation Routing Examples\n\n**Example 1: No Negotiation Needed**\n```\nQuery: \"What is tokio's latest version?\"\nAnalysis: Single lookup\nAction: Direct dispatch to crate-researcher\n```\n\n**Example 2: Negotiation Required**\n```\nQuery: \"Compare tokio and async-std for a web server\"\nAnalysis: Comparative + domain context\nAction: Dispatch with negotiation: true\nExpected: Structured responses from both runtime lookups\nEvaluation: Check if web-server specific data found\n```\n\n**Example 3: Cross-Domain Negotiation**\n```\nQuery: \"E0382 in my trading system\"\nAnalysis: Error code + domain context\nAction:\n  - Dispatch m01-ownership (standard - error is defined)\n  - Dispatch domain-fintech (negotiation: true - domain context)\nSynthesis: Combine error explanation with domain-appropriate fix\n```\n\n## Related Documents\n\n- `_meta/negotiation-protocol.md` - Full protocol specification\n- `_meta/negotiation-templates.md` - Response templates\n- `_meta/error-protocol.md` - 3-Strike escalation\n- `agents/_negotiation/response-format.md` - Agent response format\n",
        "skills/rust-skill-creator/SKILL.md": "---\nname: rust-skill-creator\ndescription: \"Use when creating skills for Rust crates or std library documentation. Keywords: create rust skill, create crate skill, create std skill, ÂàõÂª∫ rust skill, ÂàõÂª∫ crate skill, ÂàõÂª∫ std skill, Âä®ÊÄÅ rust skill, Âä®ÊÄÅ crate skill, skill for tokio, skill for serde, skill for axum, generate rust skill, rust ÊäÄËÉΩ, crate ÊäÄËÉΩ, ‰ªéÊñáÊ°£ÂàõÂª∫skill, from docs create skill\"\nargument-hint: \"<crate_name|std::module>\"\ncontext: fork\nagent: general-purpose\n---\n\n# Rust Skill Creator\n\n> Create dynamic skills for Rust crates and std library documentation.\n\n## When to Use\n\nThis skill handles requests to create skills for:\n- Third-party crates (tokio, serde, axum, etc.)\n- Rust standard library (std::sync, std::marker, etc.)\n- Any Rust documentation URL\n\n## Workflow\n\n### 1. Identify the Target\n\n| User Request | Target Type | URL Pattern |\n|--------------|-------------|-------------|\n| \"create tokio skill\" | Third-party crate | `docs.rs/tokio/latest/tokio/` |\n| \"create Send trait skill\" | Std library | `doc.rust-lang.org/std/marker/trait.Send.html` |\n| \"create skill from URL\" + URL | Custom URL | User-provided URL |\n\n### 2. Execute the Command\n\nUse the `/create-llms-for-skills` command:\n\n```\n/create-llms-for-skills <url> [requirements]\n```\n\n**Examples:**\n\n```bash\n# For third-party crate\n/create-llms-for-skills https://docs.rs/tokio/latest/tokio/\n\n# For std library\n/create-llms-for-skills https://doc.rust-lang.org/std/marker/trait.Send.html\n\n# With specific requirements\n/create-llms-for-skills https://docs.rs/axum/latest/axum/ \"Focus on routing and extractors\"\n```\n\n### 3. Follow-up with Skill Creation\n\nAfter llms.txt is generated, use:\n\n```\n/create-skills-via-llms <crate_name> <llms_path> [version]\n```\n\n## URL Construction Helper\n\n| Target | URL Template |\n|--------|--------------|\n| Crate overview | `https://docs.rs/{crate}/latest/{crate}/` |\n| Crate module | `https://docs.rs/{crate}/latest/{crate}/{module}/` |\n| Std trait | `https://doc.rust-lang.org/std/{module}/trait.{Name}.html` |\n| Std struct | `https://doc.rust-lang.org/std/{module}/struct.{Name}.html` |\n| Std module | `https://doc.rust-lang.org/std/{module}/index.html` |\n\n## Common Std Library Paths\n\n| Item | Path |\n|------|------|\n| Send, Sync, Copy, Clone | `std/marker/trait.{Name}.html` |\n| Arc, Mutex, RwLock | `std/sync/struct.{Name}.html` |\n| Rc, Weak | `std/rc/struct.{Name}.html` |\n| RefCell, Cell | `std/cell/struct.{Name}.html` |\n| Box | `std/boxed/struct.Box.html` |\n| Vec | `std/vec/struct.Vec.html` |\n| String | `std/string/struct.String.html` |\n| Option | `std/option/enum.Option.html` |\n| Result | `std/result/enum.Result.html` |\n\n## Example Interactions\n\n### Example 1: Create Crate Skill\n\n```\nUser: \"Create a dynamic skill for tokio\"\n\nClaude:\n1. Identify: Third-party crate \"tokio\"\n2. Execute: /create-llms-for-skills https://docs.rs/tokio/latest/tokio/\n3. Wait for llms.txt generation\n4. Execute: /create-skills-via-llms tokio ~/tmp/{timestamp}-tokio-llms.txt\n```\n\n### Example 2: Create Std Library Skill\n\n```\nUser: \"Create a skill for Send and Sync traits\"\n\nClaude:\n1. Identify: Std library traits\n2. Execute: /create-llms-for-skills https://doc.rust-lang.org/std/marker/trait.Send.html https://doc.rust-lang.org/std/marker/trait.Sync.html\n3. Wait for llms.txt generation\n4. Execute: /create-skills-via-llms std-marker ~/tmp/{timestamp}-std-marker-llms.txt\n```\n\n### Example 3: Custom URL\n\n```\nUser: \"Create skill from https://docs.rs/sqlx/latest/sqlx/\"\n\nClaude:\n1. Identify: User-provided URL\n2. Execute: /create-llms-for-skills https://docs.rs/sqlx/latest/sqlx/\n3. Follow standard workflow\n```\n\n## DO NOT\n\n- Use `best-skill-creator` for Rust-related skill creation\n- Skip the `/create-llms-for-skills` step\n- Guess documentation URLs without verification\n\n## Output Location\n\nAll generated skills are saved to: `~/.claude/skills/`\n",
        "skills/rust-symbol-analyzer/SKILL.md": "---\nname: rust-symbol-analyzer\ndescription: \"Analyze Rust project structure using LSP symbols. Triggers on: /symbols, project structure, list structs, list traits, list functions, Á¨¶Âè∑ÂàÜÊûê, È°πÁõÆÁªìÊûÑ, ÂàóÂá∫ÊâÄÊúâ, ÊúâÂì™‰∫õstruct\"\nargument-hint: \"[file.rs] [--type struct|trait|fn|mod]\"\nallowed-tools: [\"LSP\", \"Read\", \"Glob\"]\n---\n\n# Rust Symbol Analyzer\n\nAnalyze project structure by examining symbols across your Rust codebase.\n\n## Usage\n\n```\n/rust-symbol-analyzer [file.rs] [--type struct|trait|fn|mod]\n```\n\n**Examples:**\n- `/rust-symbol-analyzer` - Analyze entire project\n- `/rust-symbol-analyzer src/lib.rs` - Analyze single file\n- `/rust-symbol-analyzer --type trait` - List all traits in project\n\n## LSP Operations\n\n### 1. Document Symbols (Single File)\n\nGet all symbols in a file with their hierarchy.\n\n```\nLSP(\n  operation: \"documentSymbol\",\n  filePath: \"src/lib.rs\",\n  line: 1,\n  character: 1\n)\n```\n\n**Returns:** Nested structure of modules, structs, functions, etc.\n\n### 2. Workspace Symbols (Entire Project)\n\nSearch for symbols across the workspace.\n\n```\nLSP(\n  operation: \"workspaceSymbol\",\n  filePath: \"src/lib.rs\",\n  line: 1,\n  character: 1\n)\n```\n\n**Note:** Query is implicit in the operation context.\n\n## Workflow\n\n```\nUser: \"What's the structure of this project?\"\n    ‚îÇ\n    ‚ñº\n[1] Find all Rust files\n    Glob(\"**/*.rs\")\n    ‚îÇ\n    ‚ñº\n[2] Get symbols from each key file\n    LSP(documentSymbol) for lib.rs, main.rs\n    ‚îÇ\n    ‚ñº\n[3] Categorize by type\n    ‚îÇ\n    ‚ñº\n[4] Generate structure visualization\n```\n\n## Output Format\n\n### Project Overview\n\n```\n## Project Structure: my-project\n\n### Modules\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs (root)\n‚îÇ   ‚îú‚îÄ‚îÄ config/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ parser.rs\n‚îÇ   ‚îú‚îÄ‚îÄ handlers/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.rs\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.rs\n‚îÇ   ‚îî‚îÄ‚îÄ models/\n‚îÇ       ‚îú‚îÄ‚îÄ mod.rs\n‚îÇ       ‚îú‚îÄ‚îÄ user.rs\n‚îÇ       ‚îî‚îÄ‚îÄ order.rs\n‚îî‚îÄ‚îÄ tests/\n    ‚îî‚îÄ‚îÄ integration.rs\n```\n\n### By Symbol Type\n\n```\n## Symbols by Type\n\n### Structs (12)\n| Name | Location | Fields | Derives |\n|------|----------|--------|---------|\n| Config | src/config.rs:10 | 5 | Debug, Clone |\n| User | src/models/user.rs:8 | 4 | Debug, Serialize |\n| Order | src/models/order.rs:15 | 6 | Debug, Serialize |\n| ... | | | |\n\n### Traits (4)\n| Name | Location | Methods | Implementors |\n|------|----------|---------|--------------|\n| Handler | src/handlers/mod.rs:5 | 3 | AuthHandler, ApiHandler |\n| Repository | src/db/mod.rs:12 | 5 | UserRepo, OrderRepo |\n| ... | | | |\n\n### Functions (25)\n| Name | Location | Visibility | Async |\n|------|----------|------------|-------|\n| main | src/main.rs:10 | pub | yes |\n| parse_config | src/config.rs:45 | pub | no |\n| ... | | | |\n\n### Enums (6)\n| Name | Location | Variants |\n|------|----------|----------|\n| Error | src/error.rs:5 | 8 |\n| Status | src/models/order.rs:5 | 4 |\n| ... | | |\n```\n\n### Single File Analysis\n\n```\n## src/handlers/auth.rs\n\n### Symbols Hierarchy\n\nmod auth\n‚îú‚îÄ‚îÄ struct AuthHandler\n‚îÇ   ‚îú‚îÄ‚îÄ field: config: Config\n‚îÇ   ‚îú‚îÄ‚îÄ field: db: Pool\n‚îÇ   ‚îî‚îÄ‚îÄ impl AuthHandler\n‚îÇ       ‚îú‚îÄ‚îÄ fn new(config, db) -> Self\n‚îÇ       ‚îú‚îÄ‚îÄ fn authenticate(&self, token) -> Result<User>\n‚îÇ       ‚îî‚îÄ‚îÄ fn refresh_token(&self, user) -> Result<Token>\n‚îú‚îÄ‚îÄ struct Token\n‚îÇ   ‚îú‚îÄ‚îÄ field: value: String\n‚îÇ   ‚îî‚îÄ‚îÄ field: expires: DateTime\n‚îú‚îÄ‚îÄ enum AuthError\n‚îÇ   ‚îú‚îÄ‚îÄ InvalidToken\n‚îÇ   ‚îú‚îÄ‚îÄ Expired\n‚îÇ   ‚îî‚îÄ‚îÄ Unauthorized\n‚îî‚îÄ‚îÄ impl Handler for AuthHandler\n    ‚îú‚îÄ‚îÄ fn handle(&self, req) -> Response\n    ‚îî‚îÄ‚îÄ fn name(&self) -> &str\n```\n\n## Analysis Features\n\n### Complexity Metrics\n\n```\n## Complexity Analysis\n\n| File | Structs | Functions | Lines | Complexity |\n|------|---------|-----------|-------|------------|\n| src/handlers/auth.rs | 2 | 8 | 150 | Medium |\n| src/models/user.rs | 3 | 12 | 200 | High |\n| src/config.rs | 1 | 3 | 50 | Low |\n\n**Hotspots:** Files with high complexity that may need refactoring\n- src/handlers/api.rs (15 functions, 300 lines)\n```\n\n### Dependency Analysis\n\n```\n## Internal Dependencies\n\nauth.rs\n‚îú‚îÄ‚îÄ imports from: config.rs, models/user.rs, db/mod.rs\n‚îî‚îÄ‚îÄ imported by: main.rs, handlers/mod.rs\n\nuser.rs\n‚îú‚îÄ‚îÄ imports from: (none - leaf module)\n‚îî‚îÄ‚îÄ imported by: auth.rs, api.rs, tests/\n```\n\n## Symbol Types\n\n| Type | Icon | LSP Kind |\n|------|------|----------|\n| Module | üì¶ | Module |\n| Struct | üèóÔ∏è | Struct |\n| Enum | üî¢ | Enum |\n| Trait | üìú | Interface |\n| Function | ‚ö° | Function |\n| Method | üîß | Method |\n| Constant | üîí | Constant |\n| Field | üìé | Field |\n\n## Common Queries\n\n| User Says | Analysis |\n|-----------|----------|\n| \"What structs are in this project?\" | workspaceSymbol + filter |\n| \"Show me src/lib.rs structure\" | documentSymbol |\n| \"Find all async functions\" | workspaceSymbol + async filter |\n| \"List public API\" | documentSymbol + pub filter |\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Navigate to symbol | rust-code-navigator |\n| Call relationships | rust-call-graph |\n| Trait implementations | rust-trait-explorer |\n| Safe refactoring | rust-refactor-helper |\n",
        "skills/rust-trait-explorer/SKILL.md": "---\nname: rust-trait-explorer\ndescription: \"Explore Rust trait implementations using LSP. Triggers on: /trait-impl, find implementations, who implements, trait ÂÆûÁé∞, Ë∞ÅÂÆûÁé∞‰∫Ü, ÂÆûÁé∞‰∫ÜÂì™‰∫õtrait\"\nargument-hint: \"<TraitName|StructName>\"\nallowed-tools: [\"LSP\", \"Read\", \"Glob\", \"Grep\"]\n---\n\n# Rust Trait Explorer\n\nDiscover trait implementations and understand polymorphic designs.\n\n## Usage\n\n```\n/rust-trait-explorer <TraitName|StructName>\n```\n\n**Examples:**\n- `/rust-trait-explorer Handler` - Find all implementors of Handler trait\n- `/rust-trait-explorer MyStruct` - Find all traits implemented by MyStruct\n\n## LSP Operations\n\n### Go to Implementation\n\nFind all implementations of a trait.\n\n```\nLSP(\n  operation: \"goToImplementation\",\n  filePath: \"src/traits.rs\",\n  line: 10,\n  character: 11\n)\n```\n\n**Use when:**\n- Trait name is known\n- Want to find all implementors\n- Understanding polymorphic code\n\n## Workflow\n\n### Find Trait Implementors\n\n```\nUser: \"Who implements the Handler trait?\"\n    ‚îÇ\n    ‚ñº\n[1] Find trait definition\n    LSP(goToDefinition) or workspaceSymbol\n    ‚îÇ\n    ‚ñº\n[2] Get implementations\n    LSP(goToImplementation)\n    ‚îÇ\n    ‚ñº\n[3] For each impl, get details\n    LSP(documentSymbol) for methods\n    ‚îÇ\n    ‚ñº\n[4] Generate implementation map\n```\n\n### Find Traits for a Type\n\n```\nUser: \"What traits does MyStruct implement?\"\n    ‚îÇ\n    ‚ñº\n[1] Find struct definition\n    ‚îÇ\n    ‚ñº\n[2] Search for \"impl * for MyStruct\"\n    Grep pattern matching\n    ‚îÇ\n    ‚ñº\n[3] Get trait details for each\n    ‚îÇ\n    ‚ñº\n[4] Generate trait list\n```\n\n## Output Format\n\n### Trait Implementors\n\n```\n## Implementations of `Handler`\n\n**Trait defined at:** src/traits.rs:15\n\n‚Äã```rust\npub trait Handler {\n    fn handle(&self, request: Request) -> Response;\n    fn name(&self) -> &str;\n}\n‚Äã```\n\n### Implementors (4)\n\n| Type | Location | Notes |\n|------|----------|-------|\n| AuthHandler | src/handlers/auth.rs:20 | Handles authentication |\n| ApiHandler | src/handlers/api.rs:15 | REST API endpoints |\n| WebSocketHandler | src/handlers/ws.rs:10 | WebSocket connections |\n| MockHandler | tests/mocks.rs:5 | Test mock |\n\n### Implementation Details\n\n#### AuthHandler\n‚Äã```rust\nimpl Handler for AuthHandler {\n    fn handle(&self, request: Request) -> Response {\n        // Authentication logic\n    }\n\n    fn name(&self) -> &str {\n        \"auth\"\n    }\n}\n‚Äã```\n\n#### ApiHandler\n‚Äã```rust\nimpl Handler for ApiHandler {\n    fn handle(&self, request: Request) -> Response {\n        // API routing logic\n    }\n\n    fn name(&self) -> &str {\n        \"api\"\n    }\n}\n‚Äã```\n```\n\n### Traits for a Type\n\n```\n## Traits implemented by `User`\n\n**Struct defined at:** src/models/user.rs:10\n\n### Standard Library Traits\n| Trait | Derived/Manual | Notes |\n|-------|----------------|-------|\n| Debug | #[derive] | Auto-generated |\n| Clone | #[derive] | Auto-generated |\n| Default | manual | Custom defaults |\n| Display | manual | User-friendly output |\n\n### Serde Traits\n| Trait | Location |\n|-------|----------|\n| Serialize | #[derive] |\n| Deserialize | #[derive] |\n\n### Project Traits\n| Trait | Location | Methods |\n|-------|----------|---------|\n| Entity | src/db/entity.rs:30 | id(), created_at() |\n| Validatable | src/validation.rs:15 | validate() |\n\n### Implementation Hierarchy\n\n‚Äã```\nUser\n‚îú‚îÄ‚îÄ derive\n‚îÇ   ‚îú‚îÄ‚îÄ Debug\n‚îÇ   ‚îú‚îÄ‚îÄ Clone\n‚îÇ   ‚îú‚îÄ‚îÄ Serialize\n‚îÇ   ‚îî‚îÄ‚îÄ Deserialize\n‚îî‚îÄ‚îÄ impl\n    ‚îú‚îÄ‚îÄ Default (src/models/user.rs:50)\n    ‚îú‚îÄ‚îÄ Display (src/models/user.rs:60)\n    ‚îú‚îÄ‚îÄ Entity (src/models/user.rs:70)\n    ‚îî‚îÄ‚îÄ Validatable (src/models/user.rs:85)\n‚Äã```\n```\n\n## Trait Hierarchy Visualization\n\n```\n## Trait Hierarchy\n\n                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                    ‚îÇ    Error    ‚îÇ (std)\n                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                           ‚îÇ\n              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n              ‚îÇ            ‚îÇ            ‚îÇ\n      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n      ‚îÇ  AppError     ‚îÇ ‚îÇ ... ‚îÇ ‚îÇ  DbError      ‚îÇ\n      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚îÇ                         ‚îÇ\n      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n      ‚îÇ AuthError     ‚îÇ         ‚îÇ QueryError    ‚îÇ\n      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Analysis Features\n\n### Coverage Check\n\n```\n## Trait Implementation Coverage\n\nTrait: Handler (3 required methods)\n\n| Implementor | handle() | name() | priority() | Complete |\n|-------------|----------|--------|------------|----------|\n| AuthHandler | ‚úÖ | ‚úÖ | ‚úÖ | Yes |\n| ApiHandler | ‚úÖ | ‚úÖ | ‚ùå default | Yes |\n| MockHandler | ‚úÖ | ‚úÖ | ‚úÖ | Yes |\n```\n\n### Blanket Implementations\n\n```\n## Blanket Implementations\n\nThe following blanket impls may apply to your types:\n\n| Trait | Blanket Impl | Applies To |\n|-------|--------------|------------|\n| From<T> | `impl<T> From<T> for T` | All types |\n| Into<U> | `impl<T, U> Into<U> for T where U: From<T>` | Types with From |\n| ToString | `impl<T: Display> ToString for T` | Types with Display |\n```\n\n## Common Patterns\n\n| User Says | Action |\n|-----------|--------|\n| \"Who implements X?\" | goToImplementation on trait |\n| \"What traits does Y impl?\" | Grep for `impl * for Y` |\n| \"Show trait hierarchy\" | Find super-traits recursively |\n| \"Is X: Send + Sync?\" | Check std trait impls |\n\n## Related Skills\n\n| When | See |\n|------|-----|\n| Navigate to impl | rust-code-navigator |\n| Call relationships | rust-call-graph |\n| Project structure | rust-symbol-analyzer |\n| Safe refactoring | rust-refactor-helper |\n",
        "skills/unsafe-checker/AGENTS.md": "# Unsafe Checker - Quick Reference\n\n**Auto-generated from rules/**\n\n## Rule Summary by Section\n\n### General Principles (3 rules)\n| ID | Level | Title |\n|----|-------|-------|\n| general-01 | P | Do Not Abuse Unsafe to Escape Compiler Safety Checks |\n| general-02 | P | Do Not Blindly Use Unsafe for Performance |\n| general-03 | G | Do Not Create Aliases for Types/Methods Named \"Unsafe\" |\n\n### Safety Abstraction (11 rules)\n| ID | Level | Title |\n|----|-------|-------|\n| safety-01 | P | Be Aware of Memory Safety Issues from Panics |\n| safety-02 | P | Unsafe Code Authors Must Verify Safety Invariants |\n| safety-03 | P | Do Not Expose Uninitialized Memory in Public APIs |\n| safety-04 | P | Avoid Double-Free from Panic Safety Issues |\n| safety-05 | P | Consider Safety When Manually Implementing Auto Traits |\n| safety-06 | P | Do Not Expose Raw Pointers in Public APIs |\n| safety-07 | P | Provide Unsafe Counterparts for Performance Alongside Safe Methods |\n| safety-08 | P | Mutable Return from Immutable Parameter is Wrong |\n| safety-09 | P | Add SAFETY Comment Before Any Unsafe Block |\n| safety-10 | G | Add Safety Section in Docs for Public Unsafe Functions |\n| safety-11 | G | Use assert! Instead of debug_assert! in Unsafe Functions |\n\n### Raw Pointers (6 rules)\n| ID | Level | Title |\n|----|-------|-------|\n| ptr-01 | P | Do Not Share Raw Pointers Across Threads |\n| ptr-02 | P | Prefer NonNull<T> Over *mut T |\n| ptr-03 | P | Use PhantomData<T> for Variance and Ownership |\n| ptr-04 | G | Do Not Dereference Pointers Cast to Misaligned Types |\n| ptr-05 | G | Do Not Manually Convert Immutable Pointer to Mutable |\n| ptr-06 | G | Prefer pointer::cast Over `as` for Pointer Casting |\n\n### Union (2 rules)\n| ID | Level | Title |\n|----|-------|-------|\n| union-01 | P | Avoid Union Except for C Interop |\n| union-02 | P | Do Not Use Union Variants Across Different Lifetimes |\n\n### Memory Layout (6 rules)\n| ID | Level | Title |\n|----|-------|-------|\n| mem-01 | P | Choose Appropriate Data Layout for Struct/Tuple/Enum |\n| mem-02 | P | Do Not Modify Memory Variables of Other Processes |\n| mem-03 | P | Do Not Let String/Vec Auto-Drop Other Process's Memory |\n| mem-04 | P | Prefer Reentrant Versions of C-API or Syscalls |\n| mem-05 | P | Use Third-Party Crates for Bitfields |\n| mem-06 | G | Use MaybeUninit<T> for Uninitialized Memory |\n\n### FFI (18 rules)\n| ID | Level | Title |\n|----|-------|-------|\n| ffi-01 | P | Avoid Passing Strings Directly to C |\n| ffi-02 | P | Read Documentation Carefully for std::ffi Types |\n| ffi-03 | P | Implement Drop for Wrapped C Pointers |\n| ffi-04 | P | Handle Panics When Crossing FFI Boundaries |\n| ffi-05 | P | Use Portable Type Aliases from std or libc |\n| ffi-06 | P | Ensure C-ABI String Compatibility |\n| ffi-07 | P | Do Not Implement Drop for Types Passed to External Code |\n| ffi-08 | P | Handle Errors Properly in FFI |\n| ffi-09 | P | Use References Instead of Raw Pointers in Safe Wrappers |\n| ffi-10 | P | Exported Functions Must Be Thread-Safe |\n| ffi-11 | P | Be Careful with repr(packed) Field References |\n| ffi-12 | P | Document Invariant Assumptions for C Parameters |\n| ffi-13 | P | Ensure Consistent Data Layout for Custom Types |\n| ffi-14 | P | Types in FFI Should Have Stable Layout |\n| ffi-15 | P | Validate Non-Robust External Values |\n| ffi-16 | P | Separate Data and Code for Closures to C |\n| ffi-17 | P | Use Opaque Types Instead of c_void |\n| ffi-18 | P | Avoid Passing Trait Objects to C |\n\n### I/O Safety (1 rule)\n| ID | Level | Title |\n|----|-------|-------|\n| io-01 | P | Ensure I/O Safety When Using Raw Handles |\n\n## Clippy Lint Mapping\n\n| Clippy Lint | Rule | Category |\n|-------------|------|----------|\n| `undocumented_unsafe_blocks` | safety-09 | SAFETY comments |\n| `missing_safety_doc` | safety-10 | Safety docs |\n| `panic_in_result_fn` | safety-01, ffi-04 | Panic safety |\n| `non_send_fields_in_send_ty` | safety-05 | Send/Sync |\n| `uninit_assumed_init` | safety-03 | Initialization |\n| `uninit_vec` | mem-06 | Initialization |\n| `mut_from_ref` | safety-08 | Aliasing |\n| `cast_ptr_alignment` | ptr-04 | Alignment |\n| `cast_ref_to_mut` | ptr-05 | Aliasing |\n| `ptr_as_ptr` | ptr-06 | Pointer casting |\n| `unaligned_references` | ffi-11 | Packed structs |\n| `debug_assert_with_mut_call` | safety-11 | Assertions |\n\n## Quick Decision Tree\n\n```\nWriting unsafe code?\n    ‚îÇ\n    ‚îú‚îÄ FFI with C?\n    ‚îÇ   ‚îî‚îÄ See ffi-* rules\n    ‚îÇ\n    ‚îú‚îÄ Raw pointers?\n    ‚îÇ   ‚îî‚îÄ See ptr-* rules\n    ‚îÇ\n    ‚îú‚îÄ Manual Send/Sync?\n    ‚îÇ   ‚îî‚îÄ See safety-05\n    ‚îÇ\n    ‚îú‚îÄ MaybeUninit/uninitialized?\n    ‚îÇ   ‚îî‚îÄ See safety-03, mem-06\n    ‚îÇ\n    ‚îî‚îÄ Performance optimization?\n        ‚îî‚îÄ See general-02, safety-07\n```\n\n## Essential Checklist\n\nBefore every unsafe block:\n- [ ] SAFETY comment present\n- [ ] Invariants documented\n- [ ] Pointer validity checked\n- [ ] Aliasing rules followed\n- [ ] Panic safety considered\n- [ ] Tested with Miri\n\n## Resources\n\n- `checklists/before-unsafe.md` - Pre-writing checklist\n- `checklists/review-unsafe.md` - Code review checklist\n- `checklists/common-pitfalls.md` - Common bugs and fixes\n- `examples/safe-abstraction.md` - Safe wrapper patterns\n- `examples/ffi-patterns.md` - FFI best practices\n",
        "skills/unsafe-checker/SKILL.md": "---\nname: unsafe-checker\ndescription: \"CRITICAL: Use for unsafe Rust code review and FFI. Triggers on: unsafe, raw pointer, FFI, extern, transmute, *mut, *const, union, #[repr(C)], libc, std::ffi, MaybeUninit, NonNull, SAFETY comment, soundness, undefined behavior, UB, safe wrapper, memory layout, bindgen, cbindgen, CString, CStr, ÂÆâÂÖ®ÊäΩË±°, Ë£∏ÊåáÈíà, Â§ñÈÉ®ÂáΩÊï∞Êé•Âè£, ÂÜÖÂ≠òÂ∏ÉÂ±Ä, ‰∏çÂÆâÂÖ®‰ª£Á†Å, FFI ÁªëÂÆö, Êú™ÂÆö‰πâË°å‰∏∫\"\nglobs: [\"**/*.rs\"]\nallowed-tools: [\"Read\", \"Grep\", \"Glob\"]\n---\n\nDisplay the following ASCII art exactly as shown. Do not modify spaces or line breaks:\n```text\n‚ö†Ô∏è **Unsafe Rust Checker Loaded**\n\n     *  ^  *\n    /‚óâ\\_~^~_/‚óâ\\\n ‚ö°/     o     \\‚ö°\n   '_        _'\n   / '-----' \\\n```\n\n---\n\n# Unsafe Rust Checker\n\n## When Unsafe is Valid\n\n| Use Case | Example |\n|----------|---------|\n| FFI | Calling C functions |\n| Low-level abstractions | Implementing `Vec`, `Arc` |\n| Performance | Measured bottleneck with safe alternative too slow |\n\n**NOT valid:** Escaping borrow checker without understanding why.\n\n## Required Documentation\n\n```rust\n// SAFETY: <why this is safe>\nunsafe { ... }\n\n/// # Safety\n/// <caller requirements>\npub unsafe fn dangerous() { ... }\n```\n\n## Quick Reference\n\n| Operation | Safety Requirements |\n|-----------|---------------------|\n| `*ptr` deref | Valid, aligned, initialized |\n| `&*ptr` | + No aliasing violations |\n| `transmute` | Same size, valid bit pattern |\n| `extern \"C\"` | Correct signature, ABI |\n| `static mut` | Synchronization guaranteed |\n| `impl Send/Sync` | Actually thread-safe |\n\n## Common Errors\n\n| Error | Fix |\n|-------|-----|\n| Null pointer deref | Check for null before deref |\n| Use after free | Ensure lifetime validity |\n| Data race | Add proper synchronization |\n| Alignment violation | Use `#[repr(C)]`, check alignment |\n| Invalid bit pattern | Use `MaybeUninit` |\n| Missing SAFETY comment | Add `// SAFETY:` |\n\n## Deprecated ‚Üí Better\n\n| Deprecated | Use Instead |\n|------------|-------------|\n| `mem::uninitialized()` | `MaybeUninit<T>` |\n| `mem::zeroed()` for refs | `MaybeUninit<T>` |\n| Raw pointer arithmetic | `NonNull<T>`, `ptr::add` |\n| `CString::new().unwrap().as_ptr()` | Store `CString` first |\n| `static mut` | `AtomicT` or `Mutex` |\n| Manual extern | `bindgen` |\n\n## FFI Crates\n\n| Direction | Crate |\n|-----------|-------|\n| C ‚Üí Rust | bindgen |\n| Rust ‚Üí C | cbindgen |\n| Python | PyO3 |\n| Node.js | napi-rs |\n\nClaude knows unsafe Rust. Focus on SAFETY comments and soundness.\n",
        "skills/unsafe-checker/checklists/before-unsafe.md": "# Checklist: Before Writing Unsafe Code\n\nUse this checklist before writing any `unsafe` block or `unsafe fn`.\n\n## 1. Do You Really Need Unsafe?\n\n- [ ] Have you tried all safe alternatives?\n- [ ] Can you restructure the code to satisfy the borrow checker?\n- [ ] Would interior mutability (`Cell`, `RefCell`, `Mutex`) solve the problem?\n- [ ] Is there a safe crate that already does this?\n- [ ] Is the performance gain (if any) worth the safety risk?\n\n**If you answered \"no\" to all, proceed with unsafe.**\n\n## 2. What Unsafe Operation Do You Need?\n\nIdentify which specific unsafe operation you're performing:\n\n- [ ] Dereferencing a raw pointer (`*const T`, `*mut T`)\n- [ ] Calling an `unsafe` function\n- [ ] Accessing a mutable static variable\n- [ ] Implementing an unsafe trait (`Send`, `Sync`, etc.)\n- [ ] Accessing fields of a `union`\n- [ ] Using `extern \"C\"` functions (FFI)\n\n## 3. Safety Invariants\n\nFor each unsafe operation, document the invariants:\n\n### For Pointer Dereference:\n- [ ] Is the pointer non-null?\n- [ ] Is the pointer properly aligned for the type?\n- [ ] Does the pointer point to valid, initialized memory?\n- [ ] Is the memory not being mutated by other code?\n- [ ] Will the memory remain valid for the entire duration of use?\n\n### For Mutable Aliasing:\n- [ ] Are you creating multiple mutable references to the same memory?\n- [ ] Is there any possibility of aliasing `&mut` and `&`?\n- [ ] Have you verified no other code can access this memory?\n\n### For FFI:\n- [ ] Is the function signature correct (types, ABI)?\n- [ ] Are you handling potential null pointers?\n- [ ] Are you handling potential panics (catch_unwind)?\n- [ ] Is memory ownership clear (who allocates, who frees)?\n\n### For Send/Sync:\n- [ ] Is concurrent access properly synchronized?\n- [ ] Are there any data races possible?\n- [ ] Does the type truly satisfy the trait requirements?\n\n## 4. Panic Safety\n\n- [ ] What happens if this code panics at any line?\n- [ ] Are data structures left in a valid state on panic?\n- [ ] Do you need a panic guard for cleanup?\n- [ ] Could a destructor see invalid state?\n\n## 5. Documentation\n\n- [ ] Have you written a `// SAFETY:` comment explaining:\n  - What invariants must hold?\n  - Why those invariants are upheld here?\n\n- [ ] For `unsafe fn`, have you written `# Safety` docs explaining:\n  - What the caller must guarantee?\n  - What happens if requirements are violated?\n\n## 6. Testing and Verification\n\n- [ ] Can you add debug assertions to verify invariants?\n- [ ] Have you tested with Miri (`cargo miri test`)?\n- [ ] Have you tested with address sanitizer (`RUSTFLAGS=\"-Zsanitizer=address\"`)?\n- [ ] Have you considered fuzzing the unsafe code?\n\n## Quick Reference: Common SAFETY Comments\n\n```rust\n// SAFETY: We checked that index < len above, so this is in bounds.\n\n// SAFETY: The pointer was created from a valid reference and hasn't been invalidated.\n\n// SAFETY: We hold the lock, guaranteeing exclusive access.\n\n// SAFETY: The type is #[repr(C)] and all fields are initialized.\n\n// SAFETY: Caller guarantees the pointer is non-null and properly aligned.\n```\n\n## Decision Flowchart\n\n```\nNeed unsafe?\n     |\n     v\nCan you use safe Rust? --Yes--> Don't use unsafe\n     |\n     No\n     v\nCan you use existing safe abstraction? --Yes--> Use it (std, crates)\n     |\n     No\n     v\nDocument all invariants\n     |\n     v\nAdd SAFETY comments\n     |\n     v\nWrite the unsafe code\n     |\n     v\nTest with Miri\n```\n",
        "skills/unsafe-checker/checklists/common-pitfalls.md": "# Common Unsafe Pitfalls and Fixes\n\nA reference of frequently encountered unsafe bugs and how to fix them.\n\n## Pitfall 1: Dangling Pointer from Local\n\n**Bug:**\n```rust\nfn bad() -> *const i32 {\n    let x = 42;\n    &x as *const i32  // Dangling after return!\n}\n```\n\n**Fix:**\n```rust\nfn good() -> Box<i32> {\n    Box::new(42)  // Heap allocation lives beyond function\n}\n\n// Or return the value itself\nfn better() -> i32 {\n    42\n}\n```\n\n## Pitfall 2: CString Lifetime\n\n**Bug:**\n```rust\nfn bad() -> *const c_char {\n    let s = CString::new(\"hello\").unwrap();\n    s.as_ptr()  // Dangling! CString dropped\n}\n```\n\n**Fix:**\n```rust\nfn good(s: &CString) -> *const c_char {\n    s.as_ptr()  // Caller keeps CString alive\n}\n\n// Or take ownership\nfn also_good(s: CString) -> *const c_char {\n    s.into_raw()  // Caller must free with CString::from_raw\n}\n```\n\n## Pitfall 3: Vec set_len with Uninitialized Data\n\n**Bug:**\n```rust\nfn bad() -> Vec<String> {\n    let mut v = Vec::with_capacity(10);\n    unsafe { v.set_len(10); }  // Strings are uninitialized!\n    v\n}\n```\n\n**Fix:**\n```rust\nfn good() -> Vec<String> {\n    let mut v = Vec::with_capacity(10);\n    for _ in 0..10 {\n        v.push(String::new());\n    }\n    v\n}\n\n// Or use resize\nfn also_good() -> Vec<String> {\n    let mut v = Vec::new();\n    v.resize(10, String::new());\n    v\n}\n```\n\n## Pitfall 4: Reference to Packed Field\n\n**Bug:**\n```rust\n#[repr(packed)]\nstruct Packed { a: u8, b: u32 }\n\nfn bad(p: &Packed) -> &u32 {\n    &p.b  // UB: misaligned reference!\n}\n```\n\n**Fix:**\n```rust\nfn good(p: &Packed) -> u32 {\n    unsafe { std::ptr::addr_of!(p.b).read_unaligned() }\n}\n```\n\n## Pitfall 5: Mutable Aliasing Through Raw Pointers\n\n**Bug:**\n```rust\nfn bad() {\n    let mut x = 42;\n    let ptr1 = &mut x as *mut i32;\n    let ptr2 = &mut x as *mut i32;  // Already have ptr1!\n    unsafe {\n        *ptr1 = 1;\n        *ptr2 = 2;  // Aliasing mutable pointers!\n    }\n}\n```\n\n**Fix:**\n```rust\nfn good() {\n    let mut x = 42;\n    let ptr = &mut x as *mut i32;\n    unsafe {\n        *ptr = 1;\n        *ptr = 2;  // Same pointer, sequential access\n    }\n}\n```\n\n## Pitfall 6: Transmute to Wrong Size\n\n**Bug:**\n```rust\nfn bad() {\n    let x: u32 = 42;\n    let y: u64 = unsafe { std::mem::transmute(x) };  // UB: size mismatch!\n}\n```\n\n**Fix:**\n```rust\nfn good() {\n    let x: u32 = 42;\n    let y: u64 = x as u64;  // Use conversion\n}\n```\n\n## Pitfall 7: Invalid Enum Discriminant\n\n**Bug:**\n```rust\n#[repr(u8)]\nenum Status { A = 0, B = 1, C = 2 }\n\nfn bad(raw: u8) -> Status {\n    unsafe { std::mem::transmute(raw) }  // UB if raw > 2!\n}\n```\n\n**Fix:**\n```rust\nfn good(raw: u8) -> Option<Status> {\n    match raw {\n        0 => Some(Status::A),\n        1 => Some(Status::B),\n        2 => Some(Status::C),\n        _ => None,\n    }\n}\n```\n\n## Pitfall 8: FFI Panic Unwinding\n\n**Bug:**\n```rust\n#[no_mangle]\nextern \"C\" fn callback(x: i32) -> i32 {\n    if x < 0 {\n        panic!(\"negative!\");  // UB: unwinding across FFI!\n    }\n    x * 2\n}\n```\n\n**Fix:**\n```rust\n#[no_mangle]\nextern \"C\" fn callback(x: i32) -> i32 {\n    std::panic::catch_unwind(|| {\n        if x < 0 {\n            panic!(\"negative!\");\n        }\n        x * 2\n    }).unwrap_or(-1)  // Return error code on panic\n}\n```\n\n## Pitfall 9: Double Free from Clone + into_raw\n\n**Bug:**\n```rust\nstruct Handle(*mut c_void);\n\nimpl Clone for Handle {\n    fn clone(&self) -> Self {\n        Handle(self.0)  // Both now \"own\" same pointer!\n    }\n}\n\nimpl Drop for Handle {\n    fn drop(&mut self) {\n        unsafe { free(self.0); }  // Double free when both drop!\n    }\n}\n```\n\n**Fix:**\n```rust\nstruct Handle(*mut c_void);\n\n// Don't implement Clone, or implement proper reference counting\nimpl Handle {\n    fn clone_ptr(&self) -> *mut c_void {\n        self.0  // Return raw pointer, no ownership\n    }\n}\n```\n\n## Pitfall 10: Forget Doesn't Run Destructors\n\n**Bug:**\n```rust\nfn bad() {\n    let guard = lock.lock();\n    std::mem::forget(guard);  // Lock never released!\n}\n```\n\n**Fix:**\n```rust\nfn good() {\n    let guard = lock.lock();\n    // Let guard drop naturally\n    // or explicitly: drop(guard);\n}\n```\n\n## Quick Reference Table\n\n| Pitfall | Detection | Fix |\n|---------|-----------|-----|\n| Dangling pointer | Miri | Extend lifetime or heap allocate |\n| Uninitialized read | Miri | Use MaybeUninit properly |\n| Misaligned access | Miri, UBsan | read_unaligned, copy by value |\n| Data race | TSan | Use atomics or mutex |\n| Double free | ASan | Track ownership carefully |\n| Invalid enum | Manual review | Use TryFrom |\n| FFI panic | Testing | catch_unwind |\n| Type confusion | Miri | Match types exactly |\n",
        "skills/unsafe-checker/checklists/review-unsafe.md": "# Checklist: Reviewing Unsafe Code\n\nUse this checklist when reviewing code containing `unsafe`.\n\n## 1. Surface-Level Checks\n\n- [ ] Does every `unsafe` block have a `// SAFETY:` comment?\n- [ ] Does every `unsafe fn` have `# Safety` documentation?\n- [ ] Are the safety comments specific and verifiable, not vague?\n- [ ] Is the unsafe code minimized (smallest possible unsafe block)?\n\n## 2. Pointer Validity\n\nFor each pointer dereference:\n\n- [ ] **Non-null**: Is null checked before dereference?\n- [ ] **Aligned**: Is alignment verified or guaranteed by construction?\n- [ ] **Valid**: Does the pointer point to allocated memory?\n- [ ] **Initialized**: Is the memory initialized before reading?\n- [ ] **Lifetime**: Is the memory valid for the entire use duration?\n- [ ] **Unique**: For `&mut`, is there only one mutable reference?\n\n## 3. Memory Safety\n\n- [ ] **No aliasing**: Are `&` and `&mut` never created to the same memory simultaneously?\n- [ ] **No use-after-free**: Is memory not accessed after deallocation?\n- [ ] **No double-free**: Is memory freed exactly once?\n- [ ] **No data races**: Is concurrent access properly synchronized?\n- [ ] **Bounds checked**: Are array/slice accesses in bounds?\n\n## 4. Type Safety\n\n- [ ] **Transmute**: Are transmuted types actually compatible?\n- [ ] **Repr**: Do FFI types have `#[repr(C)]`?\n- [ ] **Enum values**: Are enum discriminants validated from external sources?\n- [ ] **Unions**: Is the correct union field accessed?\n\n## 5. Panic Safety\n\n- [ ] What state is the program in if this code panics?\n- [ ] Are partially constructed objects properly cleaned up?\n- [ ] Do Drop implementations see valid state?\n- [ ] Is there a panic guard if needed?\n\n## 6. FFI-Specific Checks\n\n- [ ] **Types**: Do Rust types match C types exactly?\n- [ ] **Strings**: Are strings properly null-terminated?\n- [ ] **Ownership**: Is it clear who owns/frees memory?\n- [ ] **Thread safety**: Are callbacks thread-safe?\n- [ ] **Panic boundary**: Are panics caught before crossing FFI?\n- [ ] **Error handling**: Are C-style errors properly handled?\n\n## 7. Concurrency Checks\n\n- [ ] **Send/Sync**: Are manual implementations actually sound?\n- [ ] **Atomics**: Are memory orderings correct?\n- [ ] **Locks**: Is there potential for deadlock?\n- [ ] **Data races**: Is all shared mutable state synchronized?\n\n## 8. Red Flags (Require Extra Scrutiny)\n\n| Pattern | Concern |\n|---------|---------|\n| `transmute` | Type compatibility, provenance |\n| `as` on pointers | Alignment, type punning |\n| `static mut` | Data races |\n| `*const T as *mut T` | Aliasing violation |\n| Manual `Send`/`Sync` | Thread safety |\n| `assume_init` | Initialization |\n| `set_len` on Vec | Uninitialized memory |\n| `from_raw_parts` | Lifetime, validity |\n| `offset`/`add`/`sub` | Out of bounds |\n| FFI callbacks | Panic safety |\n\n## 9. Verification Questions\n\nAsk the author:\n- \"What would happen if [X invariant] was violated?\"\n- \"How do you know [pointer/reference] is valid here?\"\n- \"What if this panics at [specific line]?\"\n- \"Who is responsible for freeing this memory?\"\n\n## 10. Testing Requirements\n\n- [ ] Has this been tested with Miri?\n- [ ] Are there unit tests covering edge cases?\n- [ ] Are there tests for error conditions?\n- [ ] Has concurrent code been tested under stress?\n\n## Review Severity Guide\n\n| Severity | Requires |\n|----------|----------|\n| `transmute` | Two reviewers, Miri test |\n| Manual `Send`/`Sync` | Thread safety expert review |\n| FFI | Documentation of C interface |\n| `static mut` | Justification for not using atomic/mutex |\n| Pointer arithmetic | Bounds proof |\n\n## Sample Review Comments\n\n```\n// Good SAFETY comment ‚úì\n// SAFETY: index was checked to be < len on line 42\n\n// Needs improvement ‚úó\n// SAFETY: This is safe because we know it works\n\n// Missing information ‚úó\n// SAFETY: ptr is valid\n// (Why is it valid? How do we know?)\n```\n",
        "skills/unsafe-checker/examples/ffi-patterns.md": "# FFI Best Practices and Patterns\n\nExamples of safe and idiomatic Rust-C interoperability.\n\n## Pattern 1: Basic FFI Wrapper\n\n```rust\nuse std::ffi::{CStr, CString};\nuse std::os::raw::{c_char, c_int, c_void};\nuse std::ptr::NonNull;\n\n// Raw C API\nmod ffi {\n    use super::*;\n\n    extern \"C\" {\n        pub fn lib_create(name: *const c_char) -> *mut c_void;\n        pub fn lib_destroy(handle: *mut c_void);\n        pub fn lib_process(handle: *mut c_void, data: *const u8, len: usize) -> c_int;\n        pub fn lib_get_error() -> *const c_char;\n    }\n}\n\n// Safe Rust wrapper\npub struct Library {\n    handle: NonNull<c_void>,\n}\n\n#[derive(Debug)]\npub struct LibraryError(String);\n\nimpl Library {\n    pub fn new(name: &str) -> Result<Self, LibraryError> {\n        let c_name = CString::new(name).map_err(|_| LibraryError(\"invalid name\".into()))?;\n\n        let handle = unsafe { ffi::lib_create(c_name.as_ptr()) };\n\n        NonNull::new(handle)\n            .map(|handle| Self { handle })\n            .ok_or_else(|| Self::last_error())\n    }\n\n    pub fn process(&self, data: &[u8]) -> Result<(), LibraryError> {\n        let result = unsafe {\n            ffi::lib_process(self.handle.as_ptr(), data.as_ptr(), data.len())\n        };\n\n        if result == 0 {\n            Ok(())\n        } else {\n            Err(Self::last_error())\n        }\n    }\n\n    fn last_error() -> LibraryError {\n        let ptr = unsafe { ffi::lib_get_error() };\n        if ptr.is_null() {\n            LibraryError(\"unknown error\".into())\n        } else {\n            let msg = unsafe { CStr::from_ptr(ptr) }\n                .to_string_lossy()\n                .into_owned();\n            LibraryError(msg)\n        }\n    }\n}\n\nimpl Drop for Library {\n    fn drop(&mut self) {\n        unsafe { ffi::lib_destroy(self.handle.as_ptr()); }\n    }\n}\n\n// Prevent accidental copies\nimpl !Clone for Library {}\n```\n\n## Pattern 2: Callback Registration\n\n```rust\nuse std::os::raw::{c_int, c_void};\nuse std::panic::{catch_unwind, AssertUnwindSafe};\n\ntype CCallback = extern \"C\" fn(value: c_int, user_data: *mut c_void) -> c_int;\n\nextern \"C\" {\n    fn register_callback(cb: CCallback, user_data: *mut c_void);\n    fn unregister_callback();\n}\n\n/// Safely register a Rust closure as a C callback.\npub struct CallbackGuard<F> {\n    _closure: Box<F>,\n}\n\nimpl<F: FnMut(i32) -> i32 + 'static> CallbackGuard<F> {\n    pub fn register(closure: F) -> Self {\n        let boxed = Box::new(closure);\n        let user_data = Box::into_raw(boxed) as *mut c_void;\n\n        extern \"C\" fn trampoline<F: FnMut(i32) -> i32>(\n            value: c_int,\n            user_data: *mut c_void,\n        ) -> c_int {\n            let result = catch_unwind(AssertUnwindSafe(|| {\n                let closure = unsafe { &mut *(user_data as *mut F) };\n                closure(value as i32) as c_int\n            }));\n            result.unwrap_or(-1)\n        }\n\n        unsafe {\n            register_callback(trampoline::<F>, user_data);\n        }\n\n        Self {\n            // SAFETY: We just created this box and need to keep it alive\n            _closure: unsafe { Box::from_raw(user_data as *mut F) },\n        }\n    }\n}\n\nimpl<F> Drop for CallbackGuard<F> {\n    fn drop(&mut self) {\n        unsafe { unregister_callback(); }\n        // Box in _closure is dropped automatically\n    }\n}\n\n// Usage\nfn example() {\n    let multiplier = 2;\n    let _guard = CallbackGuard::register(move |x| x * multiplier);\n    // Callback is active until _guard is dropped\n}\n```\n\n## Pattern 3: Opaque Handle Types\n\n```rust\nuse std::marker::PhantomData;\n\n// Opaque type markers - prevents mixing up handles\n#[repr(C)]\npub struct DatabaseHandle {\n    _data: [u8; 0],\n    _marker: PhantomData<(*mut u8, std::marker::PhantomPinned)>,\n}\n\n#[repr(C)]\npub struct ConnectionHandle {\n    _data: [u8; 0],\n    _marker: PhantomData<(*mut u8, std::marker::PhantomPinned)>,\n}\n\nmod ffi {\n    use super::*;\n\n    extern \"C\" {\n        pub fn db_open(path: *const c_char) -> *mut DatabaseHandle;\n        pub fn db_close(db: *mut DatabaseHandle);\n        pub fn db_connect(db: *mut DatabaseHandle) -> *mut ConnectionHandle;\n        pub fn conn_close(conn: *mut ConnectionHandle);\n        pub fn conn_query(conn: *mut ConnectionHandle, sql: *const c_char) -> c_int;\n    }\n}\n\n// Type-safe wrappers\npub struct Database {\n    handle: NonNull<DatabaseHandle>,\n}\n\npub struct Connection<'db> {\n    handle: NonNull<ConnectionHandle>,\n    _db: PhantomData<&'db Database>,\n}\n\nimpl Database {\n    pub fn open(path: &str) -> Result<Self, ()> {\n        let c_path = CString::new(path).map_err(|_| ())?;\n        let handle = unsafe { ffi::db_open(c_path.as_ptr()) };\n        NonNull::new(handle).map(|h| Self { handle: h }).ok_or(())\n    }\n\n    pub fn connect(&self) -> Result<Connection<'_>, ()> {\n        let handle = unsafe { ffi::db_connect(self.handle.as_ptr()) };\n        NonNull::new(handle)\n            .map(|h| Connection { handle: h, _db: PhantomData })\n            .ok_or(())\n    }\n}\n\nimpl Drop for Database {\n    fn drop(&mut self) {\n        // All Connections must be dropped first (enforced by lifetime)\n        unsafe { ffi::db_close(self.handle.as_ptr()); }\n    }\n}\n\nimpl Connection<'_> {\n    pub fn query(&self, sql: &str) -> Result<(), ()> {\n        let c_sql = CString::new(sql).map_err(|_| ())?;\n        let result = unsafe { ffi::conn_query(self.handle.as_ptr(), c_sql.as_ptr()) };\n        if result == 0 { Ok(()) } else { Err(()) }\n    }\n}\n\nimpl Drop for Connection<'_> {\n    fn drop(&mut self) {\n        unsafe { ffi::conn_close(self.handle.as_ptr()); }\n    }\n}\n```\n\n## Pattern 4: Error Handling Across FFI\n\n```rust\nuse std::os::raw::c_int;\n\n// Error codes for C\npub const SUCCESS: c_int = 0;\npub const ERR_NULL_PTR: c_int = 1;\npub const ERR_INVALID_UTF8: c_int = 2;\npub const ERR_IO: c_int = 3;\npub const ERR_PANIC: c_int = -1;\n\n// Thread-local error storage\nthread_local! {\n    static LAST_ERROR: std::cell::RefCell<Option<Box<dyn std::error::Error>>> =\n        std::cell::RefCell::new(None);\n}\n\nfn set_last_error<E: std::error::Error + 'static>(err: E) {\n    LAST_ERROR.with(|e| {\n        *e.borrow_mut() = Some(Box::new(err));\n    });\n}\n\n/// Get the last error message. Caller must free with `free_string`.\n#[no_mangle]\npub extern \"C\" fn get_last_error() -> *mut c_char {\n    LAST_ERROR.with(|e| {\n        e.borrow()\n            .as_ref()\n            .map(|err| {\n                CString::new(err.to_string())\n                    .unwrap_or_else(|_| CString::new(\"error\").unwrap())\n                    .into_raw()\n            })\n            .unwrap_or(std::ptr::null_mut())\n    })\n}\n\n/// Free a string returned by this library.\n#[no_mangle]\npub extern \"C\" fn free_string(s: *mut c_char) {\n    if !s.is_null() {\n        // SAFETY: String was created by CString::into_raw\n        unsafe { drop(CString::from_raw(s)); }\n    }\n}\n\n/// Example function with proper error handling.\n#[no_mangle]\npub extern \"C\" fn do_operation(data: *const u8, len: usize) -> c_int {\n    let result = catch_unwind(AssertUnwindSafe(|| -> Result<(), c_int> {\n        if data.is_null() {\n            return Err(ERR_NULL_PTR);\n        }\n\n        let slice = unsafe { std::slice::from_raw_parts(data, len) };\n\n        std::str::from_utf8(slice)\n            .map_err(|e| {\n                set_last_error(e);\n                ERR_INVALID_UTF8\n            })?;\n\n        // Do actual work...\n\n        Ok(())\n    }));\n\n    match result {\n        Ok(Ok(())) => SUCCESS,\n        Ok(Err(code)) => code,\n        Err(_) => ERR_PANIC,\n    }\n}\n```\n\n## Pattern 5: Struct with C Layout\n\n```rust\nuse std::os::raw::{c_char, c_int};\n\n/// A C-compatible configuration struct.\n#[repr(C)]\npub struct Config {\n    pub version: c_int,\n    pub flags: u32,\n    pub name: [c_char; 64],\n    pub name_len: usize,\n}\n\nimpl Config {\n    pub fn new(version: i32, flags: u32, name: &str) -> Option<Self> {\n        if name.len() >= 64 {\n            return None;\n        }\n\n        let mut config = Self {\n            version: version as c_int,\n            flags,\n            name: [0; 64],\n            name_len: name.len(),\n        };\n\n        // Copy name bytes\n        for (i, byte) in name.bytes().enumerate() {\n            config.name[i] = byte as c_char;\n        }\n\n        Some(config)\n    }\n\n    pub fn name(&self) -> &str {\n        let bytes = unsafe {\n            std::slice::from_raw_parts(\n                self.name.as_ptr() as *const u8,\n                self.name_len,\n            )\n        };\n        // SAFETY: We only store valid UTF-8 in new()\n        unsafe { std::str::from_utf8_unchecked(bytes) }\n    }\n}\n\n// Verify layout at compile time\nconst _: () = {\n    assert!(std::mem::size_of::<Config>() == 80);  // 4 + 4 + 64 + 8\n    assert!(std::mem::align_of::<Config>() == 8);\n};\n```\n\n## Key FFI Guidelines\n\n1. **Always use `#[repr(C)]`** for types crossing FFI\n2. **Handle null pointers** at the boundary\n3. **Catch panics** before returning to C\n4. **Document ownership** clearly\n5. **Use opaque types** for type safety\n6. **Keep unsafe minimal** and well-documented\n",
        "skills/unsafe-checker/examples/safe-abstraction.md": "# Safe Abstraction Examples\n\nExamples of building safe APIs on top of unsafe code.\n\n## Example 1: Simple Wrapper with Bounds Check\n\n```rust\n/// A slice wrapper that provides unchecked access internally\n/// but safe access externally.\npub struct SafeSlice<'a, T> {\n    ptr: *const T,\n    len: usize,\n    _marker: std::marker::PhantomData<&'a T>,\n}\n\nimpl<'a, T> SafeSlice<'a, T> {\n    /// Creates a SafeSlice from a regular slice.\n    pub fn new(slice: &'a [T]) -> Self {\n        Self {\n            ptr: slice.as_ptr(),\n            len: slice.len(),\n            _marker: std::marker::PhantomData,\n        }\n    }\n\n    /// Safe get - returns Option.\n    pub fn get(&self, index: usize) -> Option<&T> {\n        if index < self.len {\n            // SAFETY: We just verified index < len\n            Some(unsafe { &*self.ptr.add(index) })\n        } else {\n            None\n        }\n    }\n\n    /// Unsafe get - caller must ensure bounds.\n    ///\n    /// # Safety\n    /// `index` must be less than `self.len()`.\n    pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n        debug_assert!(index < self.len);\n        &*self.ptr.add(index)\n    }\n\n    pub fn len(&self) -> usize {\n        self.len\n    }\n}\n```\n\n## Example 2: Resource Wrapper with Drop\n\n```rust\nuse std::ptr::NonNull;\n\n/// Safe wrapper around a C-allocated buffer.\npub struct CBuffer {\n    ptr: NonNull<u8>,\n    len: usize,\n}\n\nextern \"C\" {\n    fn c_alloc(size: usize) -> *mut u8;\n    fn c_free(ptr: *mut u8);\n}\n\nimpl CBuffer {\n    /// Creates a new buffer. Returns None if allocation fails.\n    pub fn new(size: usize) -> Option<Self> {\n        let ptr = unsafe { c_alloc(size) };\n        NonNull::new(ptr).map(|ptr| Self { ptr, len: size })\n    }\n\n    /// Returns a slice view of the buffer.\n    pub fn as_slice(&self) -> &[u8] {\n        // SAFETY: ptr is valid for len bytes (from c_alloc contract)\n        unsafe { std::slice::from_raw_parts(self.ptr.as_ptr(), self.len) }\n    }\n\n    /// Returns a mutable slice view.\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        // SAFETY: We have &mut self, so exclusive access\n        unsafe { std::slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len) }\n    }\n}\n\nimpl Drop for CBuffer {\n    fn drop(&mut self) {\n        // SAFETY: ptr was allocated by c_alloc and not yet freed\n        unsafe { c_free(self.ptr.as_ptr()); }\n    }\n}\n\n// Prevent double-free\nimpl !Clone for CBuffer {}\n\n// Safe to send between threads (assuming c_alloc is thread-safe)\nunsafe impl Send for CBuffer {}\n```\n\n## Example 3: Interior Mutability with UnsafeCell\n\n```rust\nuse std::cell::UnsafeCell;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\n/// A simple spinlock demonstrating safe abstraction over UnsafeCell.\npub struct SpinLock<T> {\n    locked: AtomicBool,\n    data: UnsafeCell<T>,\n}\n\npub struct SpinLockGuard<'a, T> {\n    lock: &'a SpinLock<T>,\n}\n\nimpl<T> SpinLock<T> {\n    pub const fn new(data: T) -> Self {\n        Self {\n            locked: AtomicBool::new(false),\n            data: UnsafeCell::new(data),\n        }\n    }\n\n    pub fn lock(&self) -> SpinLockGuard<'_, T> {\n        // Spin until we acquire the lock\n        while self.locked.compare_exchange_weak(\n            false,\n            true,\n            Ordering::Acquire,\n            Ordering::Relaxed,\n        ).is_err() {\n            std::hint::spin_loop();\n        }\n        SpinLockGuard { lock: self }\n    }\n}\n\nimpl<T> std::ops::Deref for SpinLockGuard<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        // SAFETY: We hold the lock, so we have exclusive access\n        unsafe { &*self.lock.data.get() }\n    }\n}\n\nimpl<T> std::ops::DerefMut for SpinLockGuard<'_, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        // SAFETY: We hold the lock, so we have exclusive access\n        unsafe { &mut *self.lock.data.get() }\n    }\n}\n\nimpl<T> Drop for SpinLockGuard<'_, T> {\n    fn drop(&mut self) {\n        self.lock.locked.store(false, Ordering::Release);\n    }\n}\n\n// SAFETY: The lock ensures only one thread accesses data at a time\nunsafe impl<T: Send> Sync for SpinLock<T> {}\nunsafe impl<T: Send> Send for SpinLock<T> {}\n```\n\n## Example 4: Iterator with Lifetime Tracking\n\n```rust\nuse std::marker::PhantomData;\n\n/// An iterator over raw pointer range with proper lifetime tracking.\npub struct PtrIter<'a, T> {\n    current: *const T,\n    end: *const T,\n    _marker: PhantomData<&'a T>,\n}\n\nimpl<'a, T> PtrIter<'a, T> {\n    /// Creates an iterator from a slice.\n    pub fn new(slice: &'a [T]) -> Self {\n        let ptr = slice.as_ptr();\n        Self {\n            current: ptr,\n            // SAFETY: Adding len to slice pointer is always valid\n            end: unsafe { ptr.add(slice.len()) },\n            _marker: PhantomData,\n        }\n    }\n}\n\nimpl<'a, T> Iterator for PtrIter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.current == self.end {\n            None\n        } else {\n            // SAFETY:\n            // - current < end (checked above)\n            // - PhantomData<&'a T> ensures the data lives for 'a\n            let item = unsafe { &*self.current };\n            self.current = unsafe { self.current.add(1) };\n            Some(item)\n        }\n    }\n}\n```\n\n## Example 5: Builder Pattern with Delayed Initialization\n\n```rust\nuse std::mem::MaybeUninit;\n\n/// A builder that collects exactly N items, then produces an array.\npub struct ArrayBuilder<T, const N: usize> {\n    data: [MaybeUninit<T>; N],\n    count: usize,\n}\n\nimpl<T, const N: usize> ArrayBuilder<T, N> {\n    pub fn new() -> Self {\n        Self {\n            // SAFETY: MaybeUninit doesn't require initialization\n            data: unsafe { MaybeUninit::uninit().assume_init() },\n            count: 0,\n        }\n    }\n\n    pub fn push(&mut self, value: T) -> Result<(), T> {\n        if self.count >= N {\n            return Err(value);\n        }\n        self.data[self.count].write(value);\n        self.count += 1;\n        Ok(())\n    }\n\n    pub fn build(self) -> Option<[T; N]> {\n        if self.count != N {\n            return None;\n        }\n\n        // SAFETY: All N elements have been initialized\n        let result = unsafe {\n            // Prevent drop of self.data (we're moving out)\n            let data = std::ptr::read(&self.data);\n            std::mem::forget(self);\n            // Transmute MaybeUninit array to initialized array\n            std::mem::transmute_copy::<[MaybeUninit<T>; N], [T; N]>(&data)\n        };\n        Some(result)\n    }\n}\n\nimpl<T, const N: usize> Drop for ArrayBuilder<T, N> {\n    fn drop(&mut self) {\n        // Drop only initialized elements\n        for i in 0..self.count {\n            // SAFETY: Elements 0..count are initialized\n            unsafe { self.data[i].assume_init_drop(); }\n        }\n    }\n}\n```\n\n## Key Patterns\n\n1. **Encapsulation**: Hide unsafe behind safe public API\n2. **Invariant maintenance**: Use private fields to maintain invariants\n3. **PhantomData**: Track lifetimes and ownership for pointers\n4. **RAII**: Use Drop for cleanup\n5. **Type state**: Use types to encode valid states\n",
        "skills/unsafe-checker/rules/_sections.md": "# Unsafe Checker - Section Definitions\n\n## Section Overview\n\n| # | Section | Prefix | Level | Count | Impact |\n|---|---------|--------|-------|-------|--------|\n| 1 | General Principles | `general-` | CRITICAL | 3 | Foundational unsafe usage guidance |\n| 2 | Safety Abstraction | `safety-` | CRITICAL | 11 | Building sound safe APIs |\n| 3 | Raw Pointers | `ptr-` | HIGH | 6 | Pointer manipulation safety |\n| 4 | Union | `union-` | HIGH | 2 | Union type safety |\n| 5 | Memory Layout | `mem-` | HIGH | 6 | Data representation correctness |\n| 6 | FFI | `ffi-` | CRITICAL | 18 | C interoperability safety |\n| 7 | I/O Safety | `io-` | MEDIUM | 1 | Handle/resource safety |\n\n## Section Details\n\n### 1. General Principles (`general-`)\n\n**Focus**: When and why to use unsafe\n\n- P.UNS.01: Don't abuse unsafe to escape borrow checker\n- P.UNS.02: Don't use unsafe blindly for performance\n- G.UNS.01: Don't create aliases for \"unsafe\" named items\n\n### 2. Safety Abstraction (`safety-`)\n\n**Focus**: Building sound safe abstractions over unsafe code\n\nKey invariants:\n- Panic safety\n- Memory initialization\n- Send/Sync correctness\n- API soundness\n\n### 3. Raw Pointers (`ptr-`)\n\n**Focus**: Safe pointer manipulation patterns\n\n- Aliasing rules\n- Alignment requirements\n- Null/dangling prevention\n- Type casting\n\n### 4. Union (`union-`)\n\n**Focus**: Safe union usage (primarily for C interop)\n\n- Initialization rules\n- Lifetime considerations\n- Type punning dangers\n\n### 5. Memory Layout (`mem-`)\n\n**Focus**: Correct data representation\n\n- `#[repr(C)]` usage\n- Alignment and padding\n- Uninitialized memory\n- Cross-process memory\n\n### 6. FFI (`ffi-`)\n\n**Focus**: Safe C interoperability\n\nSubcategories:\n- String handling (CString, CStr)\n- Type compatibility\n- Error handling across FFI\n- Thread safety\n- Resource management\n\n### 7. I/O Safety (`io-`)\n\n**Focus**: Handle and resource ownership\n\n- Raw file descriptor safety\n- Handle validity guarantees\n",
        "skills/unsafe-checker/rules/_template.md": "# Rule Template\n\nUse this template for all unsafe-checker rules.\n\n---\n\n```markdown\n---\nid: {prefix}-{number}\noriginal_id: P.UNS.XXX.YY or G.UNS.XXX.YY\nlevel: P|G\nimpact: CRITICAL|HIGH|MEDIUM\nclippy: <clippy_lint_name> (if applicable)\n---\n\n# {Rule Title}\n\n## Summary\n\nOne-sentence description of what this rule requires.\n\n## Rationale\n\nWhy this rule matters for safety/soundness.\n\n## Bad Example\n\n```rust\n// DON'T: Description of the anti-pattern\n<code that violates the rule>\n```\n\n## Good Example\n\n```rust\n// DO: Description of the correct pattern\n<code that follows the rule>\n```\n\n## Common Violations\n\n1. Violation pattern 1\n2. Violation pattern 2\n\n## Checklist\n\n- [ ] Check item 1\n- [ ] Check item 2\n\n## Related Rules\n\n- `{other-rule-id}`: Brief description\n```\n",
        "skills/unsafe-checker/rules/ffi-01-no-string-direct.md": "---\nid: ffi-01\noriginal_id: P.UNS.FFI.01\nlevel: P\nimpact: HIGH\n---\n\n# Avoid Passing Strings Directly to C from Public Rust API\n\n## Summary\n\nUse `CString` and `CStr` for string handling at FFI boundaries. Never pass Rust `String` or `&str` directly to C.\n\n## Rationale\n\n- Rust strings are UTF-8, not null-terminated\n- C strings require null terminator\n- Rust strings may contain interior null bytes\n- Memory layout differs between Rust String and C char*\n\n## Bad Example\n\n```rust\nextern \"C\" {\n    fn c_print(s: *const u8);\n    fn c_strlen(s: *const u8) -> usize;\n}\n\n// DON'T: Pass Rust string directly\nfn bad_print(s: &str) {\n    unsafe {\n        c_print(s.as_ptr());  // Not null-terminated!\n    }\n}\n\n// DON'T: Assume length matches\nfn bad_strlen(s: &str) -> usize {\n    unsafe {\n        c_strlen(s.as_ptr())  // May read past buffer\n    }\n}\n\n// DON'T: Use String in FFI signatures\nextern \"C\" fn bad_callback(s: String) {  // Wrong!\n    println!(\"{}\", s);\n}\n```\n\n## Good Example\n\n```rust\nuse std::ffi::{CString, CStr};\nuse std::os::raw::c_char;\n\nextern \"C\" {\n    fn c_print(s: *const c_char);\n    fn c_strlen(s: *const c_char) -> usize;\n    fn c_get_string() -> *const c_char;\n}\n\n// DO: Convert to CString for passing to C\nfn good_print(s: &str) -> Result<(), std::ffi::NulError> {\n    let c_string = CString::new(s)?;  // Adds null terminator, checks for interior nulls\n    unsafe {\n        c_print(c_string.as_ptr());\n    }\n    Ok(())\n}\n\n// DO: Use CStr for receiving C strings\nfn good_receive() -> String {\n    unsafe {\n        let ptr = c_get_string();\n        let c_str = CStr::from_ptr(ptr);\n        c_str.to_string_lossy().into_owned()\n    }\n}\n\n// DO: Handle interior null bytes\nfn handle_nulls(s: &str) {\n    match CString::new(s) {\n        Ok(c_string) => unsafe { c_print(c_string.as_ptr()) },\n        Err(e) => {\n            // String contains interior null at position e.nul_position()\n            eprintln!(\"String contains null byte at {}\", e.nul_position());\n        }\n    }\n}\n\n// DO: Use proper types in callbacks\nextern \"C\" fn good_callback(s: *const c_char) {\n    if !s.is_null() {\n        let c_str = unsafe { CStr::from_ptr(s) };\n        if let Ok(rust_str) = c_str.to_str() {\n            println!(\"{}\", rust_str);\n        }\n    }\n}\n```\n\n## String Type Comparison\n\n| Type | Null-terminated | Encoding | Use |\n|------|-----------------|----------|-----|\n| `String` | No | UTF-8 | Rust owned |\n| `&str` | No | UTF-8 | Rust borrowed |\n| `CString` | Yes | Byte | Rust-to-C owned |\n| `&CStr` | Yes | Byte | Rust-to-C borrowed |\n| `*const c_char` | Yes | Byte | FFI pointer |\n| `OsString` | Platform | Platform | Paths, env |\n\n## Checklist\n\n- [ ] Am I passing Rust strings to C? ‚Üí Use CString\n- [ ] Am I receiving C strings? ‚Üí Use CStr\n- [ ] Does my string contain null bytes? ‚Üí Handle NulError\n- [ ] Am I checking for null pointers from C?\n\n## Related Rules\n\n- `ffi-02`: Read documentation for std::ffi types\n- `ffi-06`: Ensure C-ABI string compatibility\n",
        "skills/unsafe-checker/rules/ffi-02-read-ffi-docs.md": "---\nid: ffi-02\noriginal_id: P.UNS.FFI.02\nlevel: P\nimpact: MEDIUM\n---\n\n# Read Documentation Carefully When Using std::ffi Types\n\n## Summary\n\nThe `std::ffi` module has many types with subtle differences. Read their documentation carefully to avoid misuse.\n\n## Key Types in std::ffi\n\n### CString vs CStr\n\n```rust\nuse std::ffi::{CString, CStr};\nuse std::os::raw::c_char;\n\n// CString: Owned, heap-allocated, null-terminated\n// - Use when creating strings to pass to C\n// - Owns the memory\nlet owned = CString::new(\"hello\").unwrap();\nlet ptr: *const c_char = owned.as_ptr();\n// ptr valid until `owned` is dropped\n\n// CStr: Borrowed, null-terminated\n// - Use when receiving strings from C\n// - Does not own memory\nlet borrowed: &CStr = unsafe { CStr::from_ptr(ptr) };\n// borrowed valid as long as ptr is valid\n```\n\n### OsString vs OsStr\n\n```rust\nuse std::ffi::{OsString, OsStr};\nuse std::path::Path;\n\n// OsString/OsStr: Platform-native strings\n// - Windows: potentially ill-formed UTF-16\n// - Unix: arbitrary bytes\n// - Use for paths and environment variables\n\nlet path = Path::new(\"/some/path\");\nlet os_str: &OsStr = path.as_os_str();\n\n// Convert to Rust string (may fail)\nif let Some(s) = os_str.to_str() {\n    println!(\"Valid UTF-8: {}\", s);\n}\n```\n\n### c_void and Opaque Types\n\n```rust\nuse std::ffi::c_void;\n\nextern \"C\" {\n    fn get_handle() -> *mut c_void;\n    fn use_handle(h: *mut c_void);\n}\n\n// c_void is for truly opaque pointers\n// Better: use dedicated opaque types (see ffi-17)\n```\n\n## Common Pitfalls\n\n```rust\nuse std::ffi::CString;\n\n// PITFALL 1: CString::as_ptr() lifetime\nfn bad_ptr() -> *const i8 {\n    let s = CString::new(\"hello\").unwrap();\n    s.as_ptr()  // Dangling! s dropped at end of function\n}\n\nfn good_ptr(s: &CString) -> *const i8 {\n    s.as_ptr()  // OK: s outlives the pointer\n}\n\n// PITFALL 2: CString::new with interior nulls\nlet result = CString::new(\"hello\\0world\");\nassert!(result.is_err());  // Interior null!\n\n// PITFALL 3: CStr::from_ptr safety\nunsafe {\n    let ptr: *const i8 = std::ptr::null();\n    // let cstr = CStr::from_ptr(ptr);  // UB: null pointer!\n\n    // Always check for null first\n    if !ptr.is_null() {\n        let cstr = CStr::from_ptr(ptr);\n    }\n}\n\n// PITFALL 4: CStr assumes valid null-terminated string\nunsafe {\n    let bytes = [104, 101, 108, 108, 111];  // \"hello\" without null\n    let ptr = bytes.as_ptr() as *const i8;\n    // let cstr = CStr::from_ptr(ptr);  // UB: no null terminator!\n\n    // Use from_bytes_with_nul instead\n    let bytes_with_nul = b\"hello\\0\";\n    let cstr = CStr::from_bytes_with_nul(bytes_with_nul).unwrap();\n}\n```\n\n## Type Selection Guide\n\n| Scenario | Type |\n|----------|------|\n| Create string for C | `CString` |\n| Borrow string from C | `&CStr` |\n| File paths | `OsString`, `Path` |\n| Environment variables | `OsString` |\n| Opaque C pointers | Newtype over `*mut c_void` |\n| C integers | `c_int`, `c_long`, etc. |\n\n## Checklist\n\n- [ ] Have I read the docs for the std::ffi type I'm using?\n- [ ] Am I aware of the lifetime constraints?\n- [ ] Am I handling potential errors (NulError, UTF-8 errors)?\n- [ ] Is there a better type for my use case?\n\n## Related Rules\n\n- `ffi-01`: Use CString/CStr for strings\n- `ffi-17`: Use opaque types instead of c_void\n",
        "skills/unsafe-checker/rules/ffi-03-drop-for-c-ptr.md": "---\nid: ffi-03\noriginal_id: P.UNS.FFI.03\nlevel: P\nimpact: CRITICAL\n---\n\n# Implement Drop for Rust Types Wrapping Memory-Managing C Pointers\n\n## Summary\n\nWhen wrapping a C pointer that owns memory, implement `Drop` to call the appropriate C deallocation function.\n\n## Rationale\n\n- C allocated memory must be freed with the matching C function\n- Rust's default drop won't clean up foreign memory\n- Resource leaks and double-frees are common FFI bugs\n\n## Bad Example\n\n```rust\nextern \"C\" {\n    fn create_resource() -> *mut Resource;\n    fn free_resource(r: *mut Resource);\n}\n\n// DON'T: Wrapper without Drop\nstruct ResourceHandle {\n    ptr: *mut Resource,\n}\n\nimpl ResourceHandle {\n    fn new() -> Self {\n        Self {\n            ptr: unsafe { create_resource() }\n        }\n    }\n    // Memory leak! ptr is never freed\n}\n\n// DON'T: Forget to handle null\nimpl Drop for BadHandle {\n    fn drop(&mut self) {\n        unsafe {\n            free_resource(self.ptr);  // Crash if ptr is null!\n        }\n    }\n}\n```\n\n## Good Example\n\n```rust\nuse std::ptr::NonNull;\n\nextern \"C\" {\n    fn create_resource() -> *mut Resource;\n    fn free_resource(r: *mut Resource);\n}\n\n// DO: Proper wrapper with Drop\nstruct ResourceHandle {\n    ptr: NonNull<Resource>,\n}\n\nimpl ResourceHandle {\n    fn new() -> Option<Self> {\n        let ptr = unsafe { create_resource() };\n        NonNull::new(ptr).map(|ptr| Self { ptr })\n    }\n\n    fn as_ptr(&self) -> *mut Resource {\n        self.ptr.as_ptr()\n    }\n}\n\nimpl Drop for ResourceHandle {\n    fn drop(&mut self) {\n        // SAFETY: ptr was allocated by create_resource\n        // and hasn't been freed yet\n        unsafe {\n            free_resource(self.ptr.as_ptr());\n        }\n    }\n}\n\n// Prevent accidental copies that would cause double-free\nimpl !Clone for ResourceHandle {}\n\n// DO: Document ownership transfer\nimpl ResourceHandle {\n    /// Consumes the handle and returns the raw pointer.\n    ///\n    /// The caller is responsible for freeing the resource.\n    fn into_raw(self) -> *mut Resource {\n        let ptr = self.ptr.as_ptr();\n        std::mem::forget(self);  // Don't run Drop\n        ptr\n    }\n\n    /// Creates a handle from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// ptr must have been allocated by create_resource()\n    /// and not yet freed.\n    unsafe fn from_raw(ptr: *mut Resource) -> Option<Self> {\n        NonNull::new(ptr).map(|ptr| Self { ptr })\n    }\n}\n```\n\n## Complete Pattern with Multiple Resources\n\n```rust\nstruct Connection {\n    handle: NonNull<c_void>,\n}\n\nstruct Statement<'conn> {\n    handle: NonNull<c_void>,\n    _conn: std::marker::PhantomData<&'conn Connection>,\n}\n\nimpl Connection {\n    fn prepare(&self, sql: &str) -> Option<Statement<'_>> {\n        let handle = unsafe { db_prepare(self.handle.as_ptr(), sql.as_ptr()) };\n        NonNull::new(handle).map(|handle| Statement {\n            handle,\n            _conn: std::marker::PhantomData,\n        })\n    }\n}\n\nimpl Drop for Connection {\n    fn drop(&mut self) {\n        // Statements must be dropped before Connection\n        // PhantomData ensures this at compile time\n        unsafe { db_close(self.handle.as_ptr()); }\n    }\n}\n\nimpl Drop for Statement<'_> {\n    fn drop(&mut self) {\n        unsafe { db_finalize(self.handle.as_ptr()); }\n    }\n}\n```\n\n## Checklist\n\n- [ ] Does my wrapper own the C resource?\n- [ ] Did I implement Drop with the correct C free function?\n- [ ] Did I handle null pointers?\n- [ ] Did I prevent Clone/Copy to avoid double-free?\n- [ ] Did I consider ownership transfer methods (into_raw/from_raw)?\n\n## Related Rules\n\n- `mem-03`: Don't let String/Vec drop foreign memory\n- `ffi-07`: Don't implement Drop for types passed to external code\n",
        "skills/unsafe-checker/rules/ffi-04-panic-boundary.md": "---\nid: ffi-04\noriginal_id: P.UNS.FFI.04\nlevel: P\nimpact: CRITICAL\nclippy: panic_in_result_fn\n---\n\n# Handle Panics When Crossing FFI Boundaries\n\n## Summary\n\nPanics must not unwind across FFI boundaries. Use `catch_unwind` or mark functions as `extern \"C-unwind\"`.\n\n## Rationale\n\n- Unwinding across C code is undefined behavior\n- C has no concept of Rust panics\n- Can corrupt C stack frames and cause crashes\n- Even with `panic=abort`, still UB to attempt unwinding in `extern \"C\"`\n\n## Bad Example\n\n```rust\n// DON'T: Allow panics to escape to C\n#[no_mangle]\npub extern \"C\" fn callback(data: *const u8, len: usize) -> i32 {\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n\n    // If this panics, UB occurs!\n    let sum: i32 = slice.iter().map(|&x| x as i32).sum();\n\n    // If this panics due to overflow in debug, UB!\n    process(sum)\n}\n\n// DON'T: Unwrap in extern functions\n#[no_mangle]\npub extern \"C\" fn parse_config(path: *const c_char) -> i32 {\n    let path = unsafe { CStr::from_ptr(path) };\n    let config = std::fs::read_to_string(path.to_str().unwrap()).unwrap();  // Can panic!\n    0\n}\n```\n\n## Good Example\n\n```rust\nuse std::panic::{catch_unwind, AssertUnwindSafe};\nuse std::ffi::CStr;\nuse std::os::raw::{c_char, c_int};\n\n// DO: Catch panics at FFI boundary\n#[no_mangle]\npub extern \"C\" fn safe_callback(data: *const u8, len: usize) -> c_int {\n    let result = catch_unwind(AssertUnwindSafe(|| {\n        if data.is_null() || len == 0 {\n            return -1;\n        }\n\n        let slice = unsafe { std::slice::from_raw_parts(data, len) };\n        let sum: i32 = slice.iter().map(|&x| x as i32).sum();\n        sum\n    }));\n\n    match result {\n        Ok(value) => value,\n        Err(_) => {\n            // Log error, return error code\n            eprintln!(\"Panic caught at FFI boundary\");\n            -1\n        }\n    }\n}\n\n// DO: Use Result-based API internally\n#[no_mangle]\npub extern \"C\" fn parse_config(path: *const c_char) -> c_int {\n    let result = catch_unwind(AssertUnwindSafe(|| -> Result<(), Box<dyn std::error::Error>> {\n        let path = unsafe { CStr::from_ptr(path) }.to_str()?;\n        let _config = std::fs::read_to_string(path)?;\n        Ok(())\n    }));\n\n    match result {\n        Ok(Ok(())) => 0,\n        Ok(Err(e)) => {\n            eprintln!(\"Error: {}\", e);\n            -1\n        }\n        Err(_) => {\n            eprintln!(\"Panic in parse_config\");\n            -2\n        }\n    }\n}\n\n// DO: For Rust-calling-Rust across C, use \"C-unwind\"\n#[no_mangle]\npub extern \"C-unwind\" fn rust_callback_can_unwind() {\n    // This is OK to panic if called from Rust through C\n    // The \"C-unwind\" ABI allows unwinding\n    panic!(\"This is allowed\");\n}\n```\n\n## FFI Error Handling Pattern\n\n```rust\n// Define error codes\nconst SUCCESS: c_int = 0;\nconst ERR_NULL_PTR: c_int = -1;\nconst ERR_INVALID_UTF8: c_int = -2;\nconst ERR_IO: c_int = -3;\nconst ERR_PANIC: c_int = -99;\n\n// Thread-local for detailed error\nthread_local! {\n    static LAST_ERROR: std::cell::RefCell<Option<String>> = std::cell::RefCell::new(None);\n}\n\nfn set_error(msg: String) {\n    LAST_ERROR.with(|e| *e.borrow_mut() = Some(msg));\n}\n\n#[no_mangle]\npub extern \"C\" fn get_last_error() -> *const c_char {\n    LAST_ERROR.with(|e| {\n        e.borrow().as_ref().map(|s| s.as_ptr() as *const c_char)\n            .unwrap_or(std::ptr::null())\n    })\n}\n```\n\n## Checklist\n\n- [ ] Does my extern \"C\" function use catch_unwind?\n- [ ] Am I avoiding unwrap/expect in FFI functions?\n- [ ] Do I return error codes for error conditions?\n- [ ] Have I considered using \"C-unwind\" for Rust-to-Rust through C?\n\n## Related Rules\n\n- `ffi-08`: Handle errors properly in FFI\n- `safety-01`: Panic safety\n",
        "skills/unsafe-checker/rules/ffi-05-portable-types.md": "---\nid: ffi-05\noriginal_id: P.UNS.FFI.05\nlevel: P\nimpact: HIGH\n---\n\n# Use Portable Type Aliases from std or libc\n\n## Summary\n\nUse type aliases from `std::os::raw` or the `libc` crate for C-compatible types. Don't assume sizes of C types.\n\n## Rationale\n\n- C types have platform-dependent sizes (`int` is not always 32 bits)\n- `long` is 32 bits on Windows, 64 bits on Unix\n- Using Rust primitives directly causes portability bugs\n\n## Bad Example\n\n```rust\n// DON'T: Use Rust types directly for C interop\nextern \"C\" {\n    fn c_function(x: i32, y: i64) -> i32;  // Might not match C types!\n}\n\n// DON'T: Assume sizes\n#[repr(C)]\nstruct BadStruct {\n    count: i32,   // C 'int' might not be 32 bits\n    size: i64,    // C 'long' varies by platform!\n    ptr: usize,   // size_t? intptr_t? Different!\n}\n```\n\n## Good Example\n\n```rust\nuse std::os::raw::{c_int, c_long, c_char, c_void};\n\n// DO: Use std::os::raw types\nextern \"C\" {\n    fn c_function(x: c_int, y: c_long) -> c_int;\n}\n\n// DO: Use libc for more types\nuse libc::{size_t, ssize_t, off_t, pid_t, time_t};\n\nextern \"C\" {\n    fn read(fd: c_int, buf: *mut c_void, count: size_t) -> ssize_t;\n    fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;\n    fn getpid() -> pid_t;\n}\n\n// DO: Match C struct layout\n#[repr(C)]\nstruct GoodStruct {\n    count: c_int,\n    size: c_long,\n    data: *mut c_void,\n}\n\n// DO: Use isize/usize for pointer-sized integers\n#[repr(C)]\nstruct PointerSized {\n    offset: isize,     // intptr_t equivalent\n    size: usize,       // size_t in pointer arithmetic\n}\n```\n\n## Type Mapping Reference\n\n| C Type | Rust Type | Notes |\n|--------|-----------|-------|\n| `char` | `c_char` | May be signed or unsigned! |\n| `signed char` | `i8` | |\n| `unsigned char` | `u8` | |\n| `short` | `c_short` | Usually i16 |\n| `int` | `c_int` | Usually i32 |\n| `long` | `c_long` | 32 or 64 bits! |\n| `long long` | `c_longlong` | Usually i64 |\n| `size_t` | `usize` or `libc::size_t` | |\n| `ssize_t` | `isize` or `libc::ssize_t` | |\n| `float` | `c_float` / `f32` | |\n| `double` | `c_double` / `f64` | |\n| `void*` | `*mut c_void` | |\n| `const void*` | `*const c_void` | |\n\n## Platform Differences\n\n```rust\n#[cfg(target_pointer_width = \"64\")]\ntype PtrDiff = i64;\n\n#[cfg(target_pointer_width = \"32\")]\ntype PtrDiff = i32;\n\n// Better: use isize\nlet diff: isize = ptr1 as isize - ptr2 as isize;\n```\n\n## Checklist\n\n- [ ] Am I using std::os::raw or libc types for FFI?\n- [ ] Have I avoided assuming c_long is 64 bits?\n- [ ] Am I using size_t/usize for sizes?\n- [ ] Have I tested on multiple platforms?\n\n## Related Rules\n\n- `ffi-13`: Ensure consistent data layout\n- `ffi-14`: Types in FFI should have stable layout\n",
        "skills/unsafe-checker/rules/ffi-06-string-abi.md": "---\nid: ffi-06\noriginal_id: P.UNS.FFI.06\nlevel: P\nimpact: HIGH\n---\n\n# Ensure C-ABI Compatibility for Strings Between Rust and C\n\n## Summary\n\nWhen passing strings across FFI, ensure both sides agree on encoding, null-termination, and memory ownership.\n\n## Rationale\n\n- Rust strings are UTF-8, C strings are byte arrays\n- C expects null termination, Rust strings don't have it\n- Memory ownership must be explicit to avoid leaks/double-frees\n\n## String Passing Patterns\n\n### Rust to C (Caller Allocates)\n\n```rust\nuse std::ffi::CString;\nuse std::os::raw::c_char;\n\nextern \"C\" {\n    fn c_process_string(s: *const c_char);\n}\n\nfn rust_to_c(s: &str) -> Result<(), std::ffi::NulError> {\n    let c_string = CString::new(s)?;\n    // c_string lives until end of scope\n    unsafe {\n        c_process_string(c_string.as_ptr());\n    }\n    // c_string dropped here, memory freed\n    Ok(())\n}\n```\n\n### C to Rust (C Allocates, Rust Borrows)\n\n```rust\nuse std::ffi::CStr;\nuse std::os::raw::c_char;\n\nextern \"C\" {\n    fn c_get_string() -> *const c_char;\n}\n\nfn c_to_rust() -> Option<String> {\n    let ptr = unsafe { c_get_string() };\n    if ptr.is_null() {\n        return None;\n    }\n    // Borrow from C, don't take ownership\n    let c_str = unsafe { CStr::from_ptr(ptr) };\n    Some(c_str.to_string_lossy().into_owned())\n}\n```\n\n### C to Rust (Ownership Transfer)\n\n```rust\nextern \"C\" {\n    fn c_create_string() -> *mut c_char;\n    fn c_free_string(s: *mut c_char);\n}\n\nstruct CAllocatedString {\n    ptr: *mut c_char,\n}\n\nimpl CAllocatedString {\n    fn new() -> Option<Self> {\n        let ptr = unsafe { c_create_string() };\n        if ptr.is_null() {\n            None\n        } else {\n            Some(Self { ptr })\n        }\n    }\n\n    fn as_str(&self) -> &str {\n        let c_str = unsafe { CStr::from_ptr(self.ptr) };\n        c_str.to_str().unwrap_or(\"\")\n    }\n}\n\nimpl Drop for CAllocatedString {\n    fn drop(&mut self) {\n        unsafe { c_free_string(self.ptr); }\n    }\n}\n```\n\n### Rust to C (Ownership Transfer)\n\n```rust\nextern \"C\" {\n    fn c_take_ownership(s: *mut c_char);  // C will free\n}\n\nfn give_to_c(s: &str) -> Result<(), std::ffi::NulError> {\n    let c_string = CString::new(s)?;\n    let ptr = c_string.into_raw();  // Don't drop CString\n\n    unsafe {\n        c_take_ownership(ptr);\n        // C now owns this memory\n        // To free it back in Rust: let _ = CString::from_raw(ptr);\n    }\n    Ok(())\n}\n```\n\n## Encoding Considerations\n\n```rust\n// UTF-8 to platform encoding\nuse std::ffi::OsString;\nuse std::os::unix::ffi::OsStrExt;\n\nfn to_platform_string(s: &str) -> CString {\n    // On Unix, UTF-8 usually works\n    CString::new(s).unwrap()\n}\n\n#[cfg(windows)]\nfn to_wide_string(s: &str) -> Vec<u16> {\n    use std::os::windows::ffi::OsStrExt;\n    std::ffi::OsStr::new(s)\n        .encode_wide()\n        .chain(std::iter::once(0))\n        .collect()\n}\n```\n\n## Checklist\n\n- [ ] Is the string null-terminated when passed to C?\n- [ ] Who allocates the memory? Who frees it?\n- [ ] Is the encoding (UTF-8, ASCII, platform) documented?\n- [ ] Am I handling conversion errors (interior nulls, invalid UTF-8)?\n\n## Related Rules\n\n- `ffi-01`: Use CString/CStr at FFI boundaries\n- `ffi-02`: Read std::ffi documentation\n",
        "skills/unsafe-checker/rules/ffi-07-no-drop-external.md": "---\nid: ffi-07\noriginal_id: P.UNS.FFI.07\nlevel: P\nimpact: HIGH\n---\n\n# Do Not Implement Drop for Types Passed to External Code\n\n## Summary\n\nIf a type will be passed to external code that manages its lifetime, don't implement `Drop`. Otherwise, both Rust and the external code will try to free it.\n\n## Rationale\n\n- External code (C library) may take ownership of the data\n- If Rust also tries to drop it, you get double-free\n- Need clear ownership boundaries\n\n## Bad Example\n\n```rust\n// DON'T: Drop on type that external code will free\n#[repr(C)]\nstruct EventHandler {\n    callback: extern \"C\" fn(i32),\n    user_data: *mut c_void,\n}\n\nimpl Drop for EventHandler {\n    fn drop(&mut self) {\n        // BAD: What if the C library already freed user_data?\n        unsafe { libc::free(self.user_data); }\n    }\n}\n\nextern \"C\" {\n    // C takes ownership and frees EventHandler when done\n    fn register_handler(h: *mut EventHandler);\n}\n\nfn bad_register() {\n    let handler = EventHandler { /* ... */ };\n    let ptr = Box::into_raw(Box::new(handler));\n    unsafe {\n        register_handler(ptr);\n        // If C code frees this, and Rust's Drop runs too = double-free\n    }\n}\n```\n\n## Good Example\n\n```rust\n// DO: No Drop for types whose lifetime is managed externally\n#[repr(C)]\nstruct EventHandler {\n    callback: extern \"C\" fn(i32),\n    user_data: *mut c_void,\n}\n// No Drop impl - C library manages lifetime\n\nextern \"C\" {\n    fn register_handler(h: *mut EventHandler);\n    fn unregister_handler(h: *mut EventHandler);\n}\n\n// DO: Wrap in a Rust type that knows when it's safe to drop\nstruct RegisteredHandler {\n    ptr: *mut EventHandler,\n    registered: bool,\n}\n\nimpl RegisteredHandler {\n    fn register(handler: EventHandler) -> Self {\n        let ptr = Box::into_raw(Box::new(handler));\n        unsafe { register_handler(ptr); }\n        Self { ptr, registered: true }\n    }\n\n    fn unregister(&mut self) {\n        if self.registered {\n            unsafe { unregister_handler(self.ptr); }\n            self.registered = false;\n        }\n    }\n}\n\nimpl Drop for RegisteredHandler {\n    fn drop(&mut self) {\n        self.unregister();\n        // Only free if we still own it\n        if !self.registered {\n            unsafe { drop(Box::from_raw(self.ptr)); }\n        }\n    }\n}\n\n// DO: Use ManuallyDrop for explicit control\nuse std::mem::ManuallyDrop;\n\nfn explicit_ownership() {\n    let handler = ManuallyDrop::new(EventHandler { /* ... */ });\n    let ptr = &*handler as *const EventHandler as *mut EventHandler;\n    unsafe {\n        register_handler(ptr);\n        // C now owns handler, don't drop it in Rust\n    }\n}\n```\n\n## Ownership Patterns\n\n| Pattern | Who Owns | Rust Drop? |\n|---------|----------|------------|\n| Rust creates, Rust frees | Rust | Yes |\n| Rust creates, C frees | C | No |\n| C creates, C frees | C | No (use wrapper) |\n| C creates, Rust frees | Rust | Yes (in wrapper) |\n\n## Checklist\n\n- [ ] Who will free this type's memory?\n- [ ] If external code frees it, am I avoiding Drop?\n- [ ] If ownership is conditional, do I track it?\n- [ ] Am I using ManuallyDrop or forget() when transferring ownership?\n\n## Related Rules\n\n- `ffi-03`: Implement Drop for wrapped C pointers (opposite case)\n- `mem-03`: Don't let String/Vec drop foreign memory\n",
        "skills/unsafe-checker/rules/ffi-08-error-handling.md": "---\nid: ffi-08\noriginal_id: P.UNS.FFI.08\nlevel: P\nimpact: HIGH\n---\n\n# Handle Errors Properly in FFI\n\n## Summary\n\nFFI functions must use C-compatible error handling (return codes, errno, out parameters). Rust's Result/Option don't cross FFI boundaries.\n\n## Rationale\n\n- C doesn't have Result or Option\n- Exceptions don't exist in C\n- Must use patterns C code understands\n\n## Bad Example\n\n```rust\n// DON'T: Return Result across FFI\n#[no_mangle]\npub extern \"C\" fn bad_open(path: *const c_char) -> Result<Handle, Error> {\n    // Result is not C-compatible!\n    unimplemented!()\n}\n\n// DON'T: Return Option across FFI\n#[no_mangle]\npub extern \"C\" fn bad_find(id: i32) -> Option<*mut Data> {\n    // Option<*mut T> might work but is confusing\n    unimplemented!()\n}\n```\n\n## Good Example\n\n```rust\nuse std::os::raw::{c_char, c_int};\n\n// Error codes\nconst SUCCESS: c_int = 0;\nconst ERR_NULL_PTR: c_int = 1;\nconst ERR_INVALID_PATH: c_int = 2;\nconst ERR_FILE_NOT_FOUND: c_int = 3;\nconst ERR_PERMISSION: c_int = 4;\nconst ERR_UNKNOWN: c_int = -1;\n\n// DO: Return error code, output via pointer\n#[no_mangle]\npub extern \"C\" fn open_file(\n    path: *const c_char,\n    out_handle: *mut *mut Handle\n) -> c_int {\n    if path.is_null() || out_handle.is_null() {\n        return ERR_NULL_PTR;\n    }\n\n    let path_str = match unsafe { CStr::from_ptr(path) }.to_str() {\n        Ok(s) => s,\n        Err(_) => return ERR_INVALID_PATH,\n    };\n\n    match File::open(path_str) {\n        Ok(file) => {\n            let handle = Box::into_raw(Box::new(Handle { file }));\n            unsafe { *out_handle = handle; }\n            SUCCESS\n        }\n        Err(e) => {\n            match e.kind() {\n                std::io::ErrorKind::NotFound => ERR_FILE_NOT_FOUND,\n                std::io::ErrorKind::PermissionDenied => ERR_PERMISSION,\n                _ => ERR_UNKNOWN,\n            }\n        }\n    }\n}\n\n// DO: Use errno for POSIX-style APIs\n#[cfg(unix)]\n#[no_mangle]\npub extern \"C\" fn posix_style_read(\n    fd: c_int,\n    buf: *mut u8,\n    count: usize\n) -> isize {\n    if buf.is_null() {\n        unsafe { *libc::__errno_location() = libc::EINVAL; }\n        return -1;\n    }\n\n    // ... do read ...\n    // On error:\n    // unsafe { *libc::__errno_location() = error_code; }\n    // return -1;\n\n    count as isize\n}\n\n// DO: Provide error message function\nthread_local! {\n    static LAST_ERROR: std::cell::RefCell<Option<String>> = std::cell::RefCell::new(None);\n}\n\n#[no_mangle]\npub extern \"C\" fn get_error_message(buf: *mut c_char, len: usize) -> c_int {\n    LAST_ERROR.with(|e| {\n        if let Some(msg) = e.borrow().as_ref() {\n            let bytes = msg.as_bytes();\n            let copy_len = std::cmp::min(bytes.len(), len.saturating_sub(1));\n            unsafe {\n                std::ptr::copy_nonoverlapping(bytes.as_ptr(), buf as *mut u8, copy_len);\n                *buf.add(copy_len) = 0;\n            }\n            SUCCESS\n        } else {\n            ERR_UNKNOWN\n        }\n    })\n}\n```\n\n## Error Handling Patterns\n\n| Pattern | Usage |\n|---------|-------|\n| Return code | Simple success/failure |\n| Return code + out param | Return value on success |\n| errno | POSIX-style APIs |\n| Error message function | Detailed error info |\n| Last-error thread-local | Windows-style APIs |\n\n## Checklist\n\n- [ ] Am I returning C-compatible error indicators?\n- [ ] Are output parameters used for return values?\n- [ ] Is there a way to get detailed error info?\n- [ ] Am I documenting all possible error codes?\n\n## Related Rules\n\n- `ffi-04`: Handle panics at FFI boundary\n- `safety-10`: Document safety requirements\n",
        "skills/unsafe-checker/rules/ffi-09-ref-not-ptr.md": "---\nid: ffi-09\noriginal_id: P.UNS.FFI.09\nlevel: P\nimpact: MEDIUM\n---\n\n# Use References Instead of Raw Pointers When Calling Safe C Functions\n\n## Summary\n\nWhen wrapping C functions that don't need null pointers, use Rust references in the safe wrapper to enforce non-null at compile time.\n\n## Rationale\n\n- References guarantee non-null\n- References have lifetime tracking\n- Raw pointers should stay in the unsafe FFI layer\n- Safe Rust API should use safe types\n\n## Bad Example\n\n```rust\nextern \"C\" {\n    fn c_process(data: *const u8, len: usize);\n}\n\n// DON'T: Expose raw pointers in safe API\npub fn process(data: *const u8, len: usize) {\n    // Caller might pass null!\n    unsafe { c_process(data, len); }\n}\n\n// DON'T: Unsafe function when it could be safe\npub unsafe fn process_unsafe(data: *const u8, len: usize) {\n    // Why force caller to use unsafe?\n    c_process(data, len);\n}\n```\n\n## Good Example\n\n```rust\nextern \"C\" {\n    fn c_process(data: *const u8, len: usize);\n    fn c_modify(data: *mut Data);\n    fn c_optional(data: *const Data);  // Can be null\n}\n\n// DO: Use slice reference for safe API\npub fn process(data: &[u8]) {\n    // Reference guarantees non-null\n    // Slice guarantees valid length\n    unsafe { c_process(data.as_ptr(), data.len()); }\n}\n\n// DO: Use &mut for exclusive access\npub fn modify(data: &mut Data) {\n    // Mutable reference guarantees:\n    // - Non-null\n    // - Exclusive access\n    // - Valid for duration\n    unsafe { c_modify(data as *mut Data); }\n}\n\n// DO: Use Option<&T> for nullable parameters\npub fn optional(data: Option<&Data>) {\n    let ptr = data.map(|d| d as *const Data).unwrap_or(std::ptr::null());\n    unsafe { c_optional(ptr); }\n}\n\n// DO: Wrap FFI types in safe Rust types\npub struct SafeHandle(*mut c_void);\n\nimpl SafeHandle {\n    pub fn new() -> Option<Self> {\n        let ptr = unsafe { create_handle() };\n        if ptr.is_null() {\n            None\n        } else {\n            Some(Self(ptr))\n        }\n    }\n\n    // Methods take &self or &mut self, not raw pointers\n    pub fn do_something(&self) {\n        unsafe { handle_operation(self.0); }\n    }\n}\n```\n\n## Converting Between References and Pointers\n\n```rust\n// Reference to pointer\nfn ref_to_ptr(r: &Data) -> *const Data {\n    r as *const Data\n}\n\nfn mut_ref_to_ptr(r: &mut Data) -> *mut Data {\n    r as *mut Data\n}\n\n// Slice to pointer\nfn slice_to_ptr(s: &[u8]) -> (*const u8, usize) {\n    (s.as_ptr(), s.len())\n}\n\n// Pointer to reference (unsafe)\nunsafe fn ptr_to_ref<'a>(p: *const Data) -> &'a Data {\n    &*p\n}\n\nunsafe fn ptr_to_mut<'a>(p: *mut Data) -> &'a mut Data {\n    &mut *p\n}\n```\n\n## When to Use Raw Pointers\n\n- FFI declarations (`extern \"C\"`)\n- Implementing the unsafe boundary layer\n- When null is a valid value\n- When the pointee might not be valid Rust (e.g., uninitialized)\n\n## Checklist\n\n- [ ] Can this parameter be a reference instead of a pointer?\n- [ ] Am I checking for null in the unsafe layer?\n- [ ] Is the safe API free of raw pointers?\n- [ ] Do I use Option<&T> for nullable references?\n\n## Related Rules\n\n- `safety-06`: Don't expose raw pointers in public APIs\n- `ffi-02`: Read std::ffi documentation\n",
        "skills/unsafe-checker/rules/ffi-10-thread-safety.md": "---\nid: ffi-10\noriginal_id: P.UNS.FFI.10\nlevel: P\nimpact: CRITICAL\n---\n\n# Exported Rust Functions Must Be Designed for Thread-Safety\n\n## Summary\n\nFunctions exported to C with `#[no_mangle] extern \"C\"` may be called from multiple threads. Ensure they are thread-safe.\n\n## Rationale\n\n- C code doesn't know about Rust's thread safety guarantees\n- C may call your function from any thread\n- Global state must be synchronized\n- Race conditions are undefined behavior\n\n## Bad Example\n\n```rust\n// DON'T: Unsynchronized global state\nstatic mut COUNTER: i32 = 0;\n\n#[no_mangle]\npub extern \"C\" fn increment() -> i32 {\n    unsafe {\n        COUNTER += 1;  // Data race if called from multiple threads!\n        COUNTER\n    }\n}\n\n// DON'T: Thread-local assuming single thread\nthread_local! {\n    static CONFIG: RefCell<Config> = RefCell::new(Config::default());\n}\n\n#[no_mangle]\npub extern \"C\" fn set_config(value: i32) {\n    // Different threads get different configs!\n    // Is that what the C caller expects?\n    CONFIG.with(|c| c.borrow_mut().value = value);\n}\n\n// DON'T: Non-Send types in globals\nstatic mut HANDLE: Option<Rc<Data>> = None;  // Rc is not Send!\n```\n\n## Good Example\n\n```rust\nuse std::sync::atomic::{AtomicI32, Ordering};\nuse std::sync::{Mutex, OnceLock};\n\n// DO: Use atomics for simple counters\nstatic COUNTER: AtomicI32 = AtomicI32::new(0);\n\n#[no_mangle]\npub extern \"C\" fn increment() -> i32 {\n    COUNTER.fetch_add(1, Ordering::SeqCst) + 1\n}\n\n// DO: Use Mutex for complex state\nstatic CONFIG: OnceLock<Mutex<Config>> = OnceLock::new();\n\nfn get_config() -> &'static Mutex<Config> {\n    CONFIG.get_or_init(|| Mutex::new(Config::default()))\n}\n\n#[no_mangle]\npub extern \"C\" fn set_config_value(value: i32) -> i32 {\n    match get_config().lock() {\n        Ok(mut config) => {\n            config.value = value;\n            0  // Success\n        }\n        Err(_) => -1  // Lock poisoned\n    }\n}\n\n// DO: Document thread safety requirements\n/// Initializes the library. NOT thread-safe.\n/// Must be called once from main thread before any other function.\n#[no_mangle]\npub extern \"C\" fn init() -> i32 {\n    // One-time initialization\n    0\n}\n\n/// Processes data. Thread-safe.\n/// May be called from multiple threads concurrently.\n#[no_mangle]\npub extern \"C\" fn process(data: *const u8, len: usize) -> i32 {\n    // Uses only local state or synchronized globals\n    0\n}\n\n// DO: Make non-thread-safe APIs explicit\n/// Handle for single-threaded use only.\n///\n/// # Thread Safety\n///\n/// This handle must only be used from the thread that created it.\nstruct SingleThreadHandle {\n    data: *mut Data,\n    _not_send: std::marker::PhantomData<*const ()>,  // !Send\n}\n```\n\n## Synchronization Patterns\n\n| Pattern | Use Case |\n|---------|----------|\n| `AtomicT` | Simple counters, flags |\n| `Mutex<T>` | Complex shared state |\n| `RwLock<T>` | Read-heavy shared state |\n| `OnceLock<T>` | Lazy one-time init |\n| `thread_local!` | Per-thread state (document!) |\n\n## Checklist\n\n- [ ] Does my exported function access global state?\n- [ ] Is that state properly synchronized?\n- [ ] Have I documented thread-safety guarantees?\n- [ ] Are any types !Send/!Sync exposed across FFI?\n\n## Related Rules\n\n- `ptr-01`: Don't share raw pointers across threads\n- `safety-05`: Send/Sync implementation safety\n",
        "skills/unsafe-checker/rules/ffi-11-packed-ub.md": "---\nid: ffi-11\noriginal_id: P.UNS.FFI.11\nlevel: P\nimpact: HIGH\nclippy: unaligned_references\n---\n\n# Be Careful with UB When Referencing #[repr(packed)] Struct Fields\n\n## Summary\n\nCreating references to fields in `#[repr(packed)]` structs is undefined behavior if the field is misaligned. Use raw pointers and `read_unaligned`/`write_unaligned` instead.\n\n## Rationale\n\n- Packed structs have no padding, so fields may be misaligned\n- References must be aligned; misaligned references are UB\n- Even implicit references (method calls, match) can cause UB\n\n## Bad Example\n\n```rust\n#[repr(C, packed)]\nstruct Packet {\n    header: u8,\n    value: u32,   // Misaligned! At offset 1, not 4\n    data: u64,    // Misaligned! At offset 5, not 8\n}\n\nfn bad_reference(p: &Packet) -> &u32 {\n    &p.value  // UB: Creates misaligned reference!\n}\n\nfn bad_match(p: &Packet) {\n    match p.value {  // UB: Match creates a reference\n        0 => {},\n        _ => {},\n    }\n}\n\nfn bad_method(p: &Packet) {\n    p.value.to_string();  // UB: Method call creates reference\n}\n\nfn bad_borrow(p: &mut Packet) {\n    let v = &mut p.value;  // UB: Misaligned mutable reference\n    *v = 42;\n}\n```\n\n## Good Example\n\n```rust\n#[repr(C, packed)]\nstruct Packet {\n    header: u8,\n    value: u32,\n    data: u64,\n}\n\n// DO: Copy out the value\nfn good_read(p: &Packet) -> u32 {\n    p.value  // Copies the value, no reference created\n}\n\n// DO: Use addr_of! for raw pointer (Rust 2021+)\nfn good_ptr_read(p: &Packet) -> u32 {\n    // SAFETY: read_unaligned handles misalignment\n    unsafe {\n        std::ptr::addr_of!(p.value).read_unaligned()\n    }\n}\n\n// DO: Use addr_of_mut! for writing\nfn good_ptr_write(p: &mut Packet, value: u32) {\n    // SAFETY: write_unaligned handles misalignment\n    unsafe {\n        std::ptr::addr_of_mut!(p.value).write_unaligned(value);\n    }\n}\n\n// DO: Create accessor methods\nimpl Packet {\n    fn value(&self) -> u32 {\n        unsafe { std::ptr::addr_of!(self.value).read_unaligned() }\n    }\n\n    fn set_value(&mut self, value: u32) {\n        unsafe { std::ptr::addr_of_mut!(self.value).write_unaligned(value); }\n    }\n\n    fn data(&self) -> u64 {\n        unsafe { std::ptr::addr_of!(self.data).read_unaligned() }\n    }\n}\n\n// DO: Consider using byte arrays + from_ne_bytes\n#[repr(C, packed)]\nstruct PacketBytes {\n    header: u8,\n    value: [u8; 4],  // Store as bytes\n    data: [u8; 8],\n}\n\nimpl PacketBytes {\n    fn value(&self) -> u32 {\n        u32::from_ne_bytes(self.value)  // Safe, no alignment issue\n    }\n}\n```\n\n## Safe Alternatives\n\n```rust\n// Alternative 1: Don't use packed\n#[repr(C)]\nstruct AlignedPacket {\n    header: u8,\n    _pad: [u8; 3],\n    value: u32,\n    data: u64,\n}\n\n// Alternative 2: Use zerocopy crate\n// use zerocopy::{AsBytes, FromBytes};\n\n// Alternative 3: Use bytemuck\n// use bytemuck::{Pod, Zeroable};\n```\n\n## Checklist\n\n- [ ] Am I creating references to packed struct fields?\n- [ ] Am I using addr_of! / addr_of_mut! for field access?\n- [ ] Am I using read_unaligned / write_unaligned?\n- [ ] Would a byte array representation be safer?\n\n## Related Rules\n\n- `ptr-04`: Don't dereference misaligned pointers\n- `mem-01`: Choose appropriate data layout\n",
        "skills/unsafe-checker/rules/ffi-12-invariant-doc.md": "---\nid: ffi-12\noriginal_id: P.UNS.FFI.12\nlevel: P\nimpact: MEDIUM\n---\n\n# Document Invariant Assumptions for C-Provided Parameters\n\n## Summary\n\nWhen receiving parameters from C, document what invariants you assume (non-null, alignment, validity, lifetime) and verify them when possible.\n\n## Rationale\n\n- C doesn't enforce invariants at compile time\n- Rust code needs to validate or document assumptions\n- Debugging FFI bugs is hard without clear documentation\n\n## Bad Example\n\n```rust\n// DON'T: Undocumented assumptions\nextern \"C\" {\n    fn get_data() -> *mut Data;\n}\n\nfn bad_use() -> &'static Data {\n    let ptr = unsafe { get_data() };\n    // Assumes:\n    // - ptr is non-null (not documented)\n    // - ptr is aligned (not checked)\n    // - Data is valid (not verified)\n    // - Lifetime is 'static (just guessing)\n    unsafe { &*ptr }\n}\n\n// DON'T: Silent assumptions in function signature\n#[no_mangle]\npub extern \"C\" fn process(data: *const Data, len: usize) {\n    // What if data is null?\n    // What if len is wrong?\n    // What if data contains invalid Data?\n    let slice = unsafe {\n        std::slice::from_raw_parts(data, len)\n    };\n}\n```\n\n## Good Example\n\n```rust\n/// Retrieves data from the C library.\n///\n/// # Invariants Assumed from C\n///\n/// - Returns a non-null pointer on success, null on failure\n/// - Returned pointer is valid for the lifetime of the library\n/// - Returned pointer is aligned for `Data`\n/// - The `Data` struct is fully initialized\nextern \"C\" {\n    fn get_data() -> *mut Data;\n}\n\nfn documented_use() -> Option<&'static Data> {\n    let ptr = unsafe { get_data() };\n\n    // Verify what we can\n    if ptr.is_null() {\n        return None;\n    }\n\n    // Document what we can't verify\n    // SAFETY:\n    // - Non-null: checked above\n    // - Aligned: documented in C library docs\n    // - Valid: C library guarantees initialized Data\n    // - Lifetime: C library guarantees static lifetime\n    Some(unsafe { &*ptr })\n}\n\n/// Processes data provided by C caller.\n///\n/// # Parameters\n///\n/// - `data`: Must be non-null, aligned for `Data`, and point to `len` valid `Data` items\n/// - `len`: Number of items. Must not exceed `isize::MAX / size_of::<Data>()`\n///\n/// # Returns\n///\n/// - `0` on success\n/// - `-1` if `data` is null\n/// - `-2` if `len` is invalid\n///\n/// # Thread Safety\n///\n/// This function is thread-safe. The `data` array must not be mutated during the call.\n#[no_mangle]\npub extern \"C\" fn process_documented(data: *const Data, len: usize) -> i32 {\n    // Verify invariants we can check\n    if data.is_null() {\n        return -1;\n    }\n\n    if len > isize::MAX as usize / std::mem::size_of::<Data>() {\n        return -2;\n    }\n\n    // SAFETY:\n    // - Non-null: checked above\n    // - Aligned: documented requirement for caller\n    // - Valid for len items: documented requirement for caller\n    // - Not mutated: documented thread safety requirement\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n\n    for item in slice {\n        // process...\n    }\n\n    0\n}\n```\n\n## Documentation Template\n\n```rust\n/// Brief description.\n///\n/// # Parameters\n///\n/// - `param`: Description, constraints (non-null, aligned, etc.)\n///\n/// # Invariants Assumed\n///\n/// The following invariants are assumed and NOT verified:\n/// - Invariant 1: explanation\n/// - Invariant 2: explanation\n///\n/// The following invariants ARE verified at runtime:\n/// - Verified 1: how it's checked\n///\n/// # Safety (for unsafe fn)\n///\n/// Caller must ensure:\n/// - Requirement 1\n/// - Requirement 2\n///\n/// # Errors\n///\n/// Returns error code when:\n/// - Condition 1: error code\n```\n\n## Checklist\n\n- [ ] Have I documented all assumptions about C parameters?\n- [ ] Which invariants can I verify at runtime?\n- [ ] Which must I trust the C caller to uphold?\n- [ ] Have I documented error conditions and return values?\n\n## Related Rules\n\n- `safety-02`: Verify safety invariants\n- `safety-10`: Document safety requirements\n",
        "skills/unsafe-checker/rules/ffi-13-data-layout.md": "---\nid: ffi-13\noriginal_id: P.UNS.FFI.13\nlevel: P\nimpact: HIGH\n---\n\n# Ensure Consistent Data Layout for Custom Types\n\n## Summary\n\nTypes shared between Rust and C must have `#[repr(C)]` to ensure the memory layout matches what C expects.\n\n## Rationale\n\n- Rust's default layout is unspecified and may change\n- C has specific, standardized layout rules\n- Mismatched layouts cause memory corruption\n\n## Bad Example\n\n```rust\n// DON'T: Rust layout for FFI types\nstruct BadStruct {\n    a: u8,\n    b: u32,\n    c: u8,\n}\n// Rust may reorder to: b, a, c (for better packing)\n// C expects: a, padding, b, c, padding\n\nextern \"C\" {\n    fn use_struct(s: *const BadStruct);  // Layout mismatch!\n}\n\n// DON'T: Assume Rust enum layout matches C\nenum BadEnum {\n    A,\n    B(i32),\n    C { x: u8, y: u8 },\n}\n// Rust enum layout is complex and not C-compatible\n```\n\n## Good Example\n\n```rust\n// DO: Use repr(C) for FFI structs\n#[repr(C)]\nstruct GoodStruct {\n    a: u8,      // offset 0\n    // 3 bytes padding\n    b: u32,     // offset 4\n    c: u8,      // offset 8\n    // 3 bytes padding\n}\n// Total size: 12, align: 4\n\n// DO: Use repr(C) for enums with explicit discriminant\n#[repr(C)]\nenum GoodEnum {\n    A = 0,\n    B = 1,\n    C = 2,\n}\n// Equivalent to C: enum { A = 0, B = 1, C = 2 };\n\n// DO: For complex enums, use tagged unions\n#[repr(C)]\nstruct TaggedUnion {\n    tag: GoodEnum,\n    data: GoodUnionData,\n}\n\n#[repr(C)]\nunion GoodUnionData {\n    a: (),         // For GoodEnum::A\n    b: i32,        // For GoodEnum::B\n    c: [u8; 2],    // For GoodEnum::C\n}\n\n// DO: Verify layout at compile time\nconst _: () = {\n    assert!(std::mem::size_of::<GoodStruct>() == 12);\n    assert!(std::mem::align_of::<GoodStruct>() == 4);\n};\n```\n\n## Layout Verification\n\n```rust\nuse std::mem::{size_of, align_of, offset_of};\n\n#[repr(C)]\nstruct Verified {\n    a: u8,\n    b: u32,\n    c: u8,\n}\n\n// Compile-time layout verification\nconst _: () = {\n    assert!(size_of::<Verified>() == 12);\n    assert!(align_of::<Verified>() == 4);\n    // offset_of! requires nightly or crate\n    // assert!(offset_of!(Verified, a) == 0);\n    // assert!(offset_of!(Verified, b) == 4);\n    // assert!(offset_of!(Verified, c) == 8);\n};\n\n// Runtime verification\n#[test]\nfn verify_layout() {\n    assert_eq!(size_of::<Verified>(), 12);\n    assert_eq!(align_of::<Verified>(), 4);\n\n    let v = Verified { a: 0, b: 0, c: 0 };\n    let base = &v as *const _ as usize;\n\n    assert_eq!(&v.a as *const _ as usize - base, 0);\n    assert_eq!(&v.b as *const _ as usize - base, 4);\n    assert_eq!(&v.c as *const _ as usize - base, 8);\n}\n```\n\n## repr Options\n\n| Attribute | Effect |\n|-----------|--------|\n| `#[repr(C)]` | C-compatible layout |\n| `#[repr(C, packed)]` | C layout, no padding |\n| `#[repr(C, align(N))]` | C layout, minimum align N |\n| `#[repr(transparent)]` | Same layout as single field |\n| `#[repr(u8)]` etc. | Enum discriminant type |\n\n## Checklist\n\n- [ ] Is every FFI struct marked `#[repr(C)]`?\n- [ ] Is every FFI enum using explicit discriminants?\n- [ ] Have I verified the layout matches the C header?\n- [ ] Have I added compile-time assertions?\n\n## Related Rules\n\n- `mem-01`: Choose appropriate data layout\n- `ffi-14`: Types in FFI should have stable layout\n",
        "skills/unsafe-checker/rules/ffi-14-stable-layout.md": "---\nid: ffi-14\noriginal_id: P.UNS.FFI.14\nlevel: P\nimpact: HIGH\n---\n\n# Types Used in FFI Should Have Stable Layout\n\n## Summary\n\nFFI types should not change layout between versions. Use `#[repr(C)]` and avoid types with unstable layout like generic `std` types.\n\n## Rationale\n\n- ABI compatibility requires stable layout\n- Dynamic libraries may be loaded with different compiler versions\n- Layout changes break binary compatibility\n\n## Bad Example\n\n```rust\n// DON'T: Use Rust std types with unstable layout in FFI\nextern \"C\" {\n    // Vec layout is not stable!\n    fn bad_vec(v: Vec<i32>);\n\n    // String layout is not stable!\n    fn bad_string(s: String);\n\n    // HashMap layout varies between versions\n    fn bad_map(m: std::collections::HashMap<i32, i32>);\n}\n\n// DON'T: Use Rust-specific types in C structs\n#[repr(C)]\nstruct BadMixed {\n    id: i32,\n    data: Vec<u8>,  // Vec is not C-compatible!\n}\n\n// DON'T: Use Option with non-null optimization assumptions\n#[repr(C)]\nstruct BadOption {\n    value: Option<std::num::NonZeroU32>,  // Layout may change!\n}\n```\n\n## Good Example\n\n```rust\nuse std::os::raw::{c_int, c_char, c_void};\n\n// DO: Use C-compatible types\n#[repr(C)]\nstruct GoodStruct {\n    id: c_int,\n    name: *const c_char,  // C-style string\n    data: *const c_void,  // Generic pointer\n    data_len: usize,\n}\n\n// DO: Use explicit struct for what Vec would provide\n#[repr(C)]\nstruct GoodBuffer {\n    ptr: *mut u8,\n    len: usize,\n    cap: usize,\n}\n\nimpl GoodBuffer {\n    fn from_vec(mut v: Vec<u8>) -> Self {\n        let buf = Self {\n            ptr: v.as_mut_ptr(),\n            len: v.len(),\n            cap: v.capacity(),\n        };\n        std::mem::forget(v);\n        buf\n    }\n\n    /// # Safety\n    /// Must have been created by from_vec()\n    unsafe fn into_vec(self) -> Vec<u8> {\n        Vec::from_raw_parts(self.ptr, self.len, self.cap)\n    }\n}\n\n// DO: Use fixed-size arrays for bounded data\n#[repr(C)]\nstruct FixedName {\n    name: [c_char; 64],\n    name_len: usize,\n}\n\n// DO: Define your own stable option type\n#[repr(C)]\nstruct OptionalU32 {\n    has_value: bool,\n    value: u32,\n}\n\nimpl From<Option<u32>> for OptionalU32 {\n    fn from(opt: Option<u32>) -> Self {\n        match opt {\n            Some(v) => Self { has_value: true, value: v },\n            None => Self { has_value: false, value: 0 },\n        }\n    }\n}\n```\n\n## Stable Types for FFI\n\n| Use Instead Of | Stable Type |\n|----------------|-------------|\n| `Vec<T>` | `*mut T` + `len` + `cap` |\n| `String` | `*const c_char` or `*mut c_char` + `len` |\n| `&[T]` | `*const T` + `len` |\n| `Option<T>` | Custom tagged struct |\n| `Result<T, E>` | Error code + out parameter |\n| `Box<T>` | `*mut T` |\n| `bool` | `c_int` or explicit `u8` |\n\n## Checklist\n\n- [ ] Am I using only C-compatible primitive types?\n- [ ] Am I avoiding std collection types in FFI signatures?\n- [ ] Have I created stable wrappers for Rust types?\n- [ ] Is the layout documented for other languages?\n\n## Related Rules\n\n- `ffi-13`: Ensure consistent data layout\n- `ffi-05`: Use portable type aliases\n",
        "skills/unsafe-checker/rules/ffi-15-validate-external.md": "---\nid: ffi-15\noriginal_id: P.UNS.FFI.15\nlevel: P\nimpact: HIGH\n---\n\n# Validate Non-Robust External Values\n\n## Summary\n\nData received from external sources (FFI, files, network) may be invalid. Validate before using it as Rust types with stricter invariants.\n\n## Rationale\n\n- External data can be malicious or corrupted\n- Rust types have invariants (e.g., valid UTF-8 for str)\n- Invalid data causes undefined behavior\n\n## Bad Example\n\n```rust\n// DON'T: Trust external data\nextern \"C\" {\n    fn get_status() -> u8;\n}\n\n#[derive(Debug)]\nenum Status { Active = 0, Inactive = 1, Pending = 2 }\n\nfn bad_convert() -> Status {\n    let raw = unsafe { get_status() };\n    // BAD: Assumes C returns valid enum value\n    unsafe { std::mem::transmute(raw) }  // UB if raw > 2\n}\n\n// DON'T: Trust strings from C\nfn bad_string(ptr: *const c_char) -> &str {\n    let cstr = unsafe { CStr::from_ptr(ptr) };\n    // BAD: Assumes valid UTF-8\n    cstr.to_str().unwrap()\n}\n\n// DON'T: Trust size values\nfn bad_size(ptr: *const u8, len: usize) -> Vec<u8> {\n    // BAD: len could be huge, causing OOM\n    // BAD: len could exceed actual data\n    unsafe { std::slice::from_raw_parts(ptr, len) }.to_vec()\n}\n```\n\n## Good Example\n\n```rust\n// DO: Validate enum values\n#[derive(Debug, Clone, Copy)]\n#[repr(u8)]\nenum Status {\n    Active = 0,\n    Inactive = 1,\n    Pending = 2,\n}\n\nimpl TryFrom<u8> for Status {\n    type Error = InvalidStatusError;\n\n    fn try_from(value: u8) -> Result<Self, Self::Error> {\n        match value {\n            0 => Ok(Status::Active),\n            1 => Ok(Status::Inactive),\n            2 => Ok(Status::Pending),\n            _ => Err(InvalidStatusError(value)),\n        }\n    }\n}\n\nfn good_convert() -> Result<Status, InvalidStatusError> {\n    let raw = unsafe { get_status() };\n    Status::try_from(raw)  // Returns error for invalid values\n}\n\n// DO: Handle invalid UTF-8\nfn good_string(ptr: *const c_char) -> Result<String, std::str::Utf8Error> {\n    if ptr.is_null() {\n        return Ok(String::new());\n    }\n    let cstr = unsafe { CStr::from_ptr(ptr) };\n    cstr.to_str().map(|s| s.to_owned())\n}\n\nfn good_string_lossy(ptr: *const c_char) -> String {\n    if ptr.is_null() {\n        return String::new();\n    }\n    let cstr = unsafe { CStr::from_ptr(ptr) };\n    cstr.to_string_lossy().into_owned()  // Replaces invalid UTF-8\n}\n\n// DO: Validate sizes\nconst MAX_REASONABLE_SIZE: usize = 100 * 1024 * 1024;  // 100 MB\n\nfn good_size(ptr: *const u8, len: usize) -> Result<Vec<u8>, ValidationError> {\n    if ptr.is_null() {\n        return Err(ValidationError::NullPointer);\n    }\n    if len > MAX_REASONABLE_SIZE {\n        return Err(ValidationError::SizeTooLarge);\n    }\n\n    // Still need to trust that ptr points to len valid bytes\n    // Document this as a caller requirement\n    let slice = unsafe { std::slice::from_raw_parts(ptr, len) };\n    Ok(slice.to_vec())\n}\n\n// DO: Use num_enum for safe enum conversion\n// use num_enum::TryFromPrimitive;\n//\n// #[derive(TryFromPrimitive)]\n// #[repr(u8)]\n// enum Status { Active = 0, Inactive = 1, Pending = 2 }\n```\n\n## Validation Patterns\n\n| External Data | Validation |\n|---------------|------------|\n| Enum discriminant | Match against valid values |\n| String | Check UTF-8 or use lossy conversion |\n| Size/length | Check against maximum |\n| Pointer | Check for null |\n| Boolean | Explicit 0/1 check or treat any non-zero as true |\n| Float | Check for NaN, infinity if problematic |\n\n## Checklist\n\n- [ ] Am I validating external enum values?\n- [ ] Am I handling potential invalid UTF-8?\n- [ ] Am I checking sizes against reasonable limits?\n- [ ] Am I using TryFrom instead of transmute?\n\n## Related Rules\n\n- `ffi-12`: Document invariant assumptions\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/ffi-16-closure-to-c.md": "---\nid: ffi-16\noriginal_id: P.UNS.FFI.16\nlevel: P\nimpact: HIGH\n---\n\n# Separate Data and Code When Passing Rust Closures to C\n\n## Summary\n\nC callbacks are function pointers without captured state. To pass Rust closures to C, separate the function pointer from the closure data using a \"trampoline\" pattern.\n\n## Rationale\n\n- Rust closures can capture state (like lambdas)\n- C function pointers are just addresses, no state\n- Must pass state separately via `void*` user_data\n\n## Bad Example\n\n```rust\n// DON'T: Try to pass closure directly\nextern \"C\" {\n    fn set_callback(cb: fn(i32) -> i32);  // Only works for non-capturing!\n}\n\nfn bad_closure() {\n    let multiplier = 2;\n    let closure = |x| x * multiplier;  // Captures multiplier\n\n    // This won't compile - closure is not fn pointer\n    // set_callback(closure);\n}\n\n// DON'T: Transmute closure to function pointer\nfn bad_transmute() {\n    let closure = |x: i32| x * 2;\n    let fp: fn(i32) -> i32 = unsafe { std::mem::transmute(closure) };\n    // UB: Closure may have non-zero size\n}\n```\n\n## Good Example\n\n```rust\nuse std::os::raw::c_void;\nuse std::ffi::c_int;\n\n// C callback signature with user_data\ntype CCallback = extern \"C\" fn(value: c_int, user_data: *mut c_void) -> c_int;\n\nextern \"C\" {\n    fn set_callback(cb: CCallback, user_data: *mut c_void);\n    fn remove_callback();\n}\n\n// DO: Use trampoline pattern\nfn good_closure<F: FnMut(i32) -> i32>(mut closure: F) {\n    // Trampoline function that forwards to the closure\n    extern \"C\" fn trampoline<F: FnMut(i32) -> i32>(\n        value: c_int,\n        user_data: *mut c_void,\n    ) -> c_int {\n        let closure = unsafe { &mut *(user_data as *mut F) };\n        closure(value as i32) as c_int\n    }\n\n    let user_data = &mut closure as *mut F as *mut c_void;\n\n    unsafe {\n        set_callback(trampoline::<F>, user_data);\n        // Important: closure must live until callback is removed!\n    }\n}\n\n// DO: Box the closure for 'static lifetime\nstruct CallbackHandle {\n    closure: Box<dyn FnMut(i32) -> i32>,\n}\n\nimpl CallbackHandle {\n    fn new<F: FnMut(i32) -> i32 + 'static>(closure: F) -> Self {\n        Self { closure: Box::new(closure) }\n    }\n\n    fn register(&mut self) {\n        extern \"C\" fn trampoline(value: c_int, user_data: *mut c_void) -> c_int {\n            let closure = unsafe { &mut *(user_data as *mut Box<dyn FnMut(i32) -> i32>) };\n            closure(value as i32) as c_int\n        }\n\n        let user_data = &mut self.closure as *mut _ as *mut c_void;\n        unsafe { set_callback(trampoline, user_data); }\n    }\n}\n\nimpl Drop for CallbackHandle {\n    fn drop(&mut self) {\n        unsafe { remove_callback(); }\n        // Now safe to drop closure\n    }\n}\n\n// Usage\nfn example() {\n    let multiplier = 2;\n    let mut handle = CallbackHandle::new(move |x| x * multiplier);\n    handle.register();\n    // handle must live until callback is no longer needed\n}\n```\n\n## Trampoline Pattern\n\n```\nRust Closure: |x| x * captured_value\n     |\n     v\n+-----------------+     +-----------------+\n| trampoline fn   | --> | closure data    |\n| (no captures)   |     | (captured_value)|\n+-----------------+     +-----------------+\n     |                         ^\n     |    user_data ptr        |\n     +-------------------------+\n\nC sees: function pointer + void* user_data\n```\n\n## Checklist\n\n- [ ] Does my closure capture any state?\n- [ ] Am I using the trampoline pattern?\n- [ ] Does the closure data live long enough?\n- [ ] Am I unregistering before dropping the closure?\n\n## Related Rules\n\n- `ffi-03`: Implement Drop for resource wrappers\n- `ffi-10`: Thread safety for callbacks\n",
        "skills/unsafe-checker/rules/ffi-17-opaque-types.md": "---\nid: ffi-17\noriginal_id: P.UNS.FFI.17\nlevel: P\nimpact: MEDIUM\n---\n\n# Use Dedicated Opaque Type Pointers Instead of c_void for C Opaque Types\n\n## Summary\n\nInstead of using `*mut c_void` for opaque C handles, create dedicated marker types that provide type safety.\n\n## Rationale\n\n- `*mut c_void` accepts any pointer, easy to mix up handles\n- Dedicated types catch mistakes at compile time\n- Self-documenting code\n- Prevents accidental use of wrong free function\n\n## Bad Example\n\n```rust\nuse std::ffi::c_void;\n\nextern \"C\" {\n    fn create_database() -> *mut c_void;\n    fn create_connection() -> *mut c_void;\n    fn execute(conn: *mut c_void, query: *const i8);\n    fn close_database(db: *mut c_void);\n    fn close_connection(conn: *mut c_void);\n}\n\nfn bad_usage() {\n    let db = unsafe { create_database() };\n    let conn = unsafe { create_connection() };\n\n    // BUG: Passed db where conn was expected - compiles fine!\n    unsafe { execute(db, b\"SELECT 1\\0\".as_ptr() as *const i8) };\n\n    // BUG: Wrong close function - compiles fine!\n    unsafe { close_connection(db) };\n    unsafe { close_database(conn) };\n}\n```\n\n## Good Example\n\n```rust\nuse std::marker::PhantomData;\n\n// DO: Define opaque marker types\n#[repr(C)]\npub struct Database {\n    _private: [u8; 0],\n    _marker: PhantomData<(*mut u8, std::marker::PhantomPinned)>,\n}\n\n#[repr(C)]\npub struct Connection {\n    _private: [u8; 0],\n    _marker: PhantomData<(*mut u8, std::marker::PhantomPinned)>,\n}\n\nextern \"C\" {\n    fn create_database() -> *mut Database;\n    fn create_connection(db: *mut Database) -> *mut Connection;\n    fn execute(conn: *mut Connection, query: *const i8) -> i32;\n    fn close_database(db: *mut Database);\n    fn close_connection(conn: *mut Connection);\n}\n\nfn good_usage() {\n    let db = unsafe { create_database() };\n    let conn = unsafe { create_connection(db) };\n\n    // Compile error: expected *mut Connection, found *mut Database\n    // unsafe { execute(db, b\"SELECT 1\\0\".as_ptr() as *const i8) };\n\n    // Correct usage\n    unsafe { execute(conn, b\"SELECT 1\\0\".as_ptr() as *const i8) };\n\n    unsafe { close_connection(conn) };\n    unsafe { close_database(db) };\n}\n\n// DO: Wrap in safe Rust types\npub struct SafeDatabase {\n    ptr: *mut Database,\n}\n\nimpl SafeDatabase {\n    pub fn new() -> Option<Self> {\n        let ptr = unsafe { create_database() };\n        if ptr.is_null() { None } else { Some(Self { ptr }) }\n    }\n\n    pub fn connect(&self) -> Option<SafeConnection<'_>> {\n        let ptr = unsafe { create_connection(self.ptr) };\n        if ptr.is_null() { None } else { Some(SafeConnection { ptr, _db: PhantomData }) }\n    }\n}\n\nimpl Drop for SafeDatabase {\n    fn drop(&mut self) {\n        unsafe { close_database(self.ptr); }\n    }\n}\n\npub struct SafeConnection<'db> {\n    ptr: *mut Connection,\n    _db: PhantomData<&'db SafeDatabase>,\n}\n\nimpl SafeConnection<'_> {\n    pub fn execute(&self, query: &str) -> Result<(), ()> {\n        let query = std::ffi::CString::new(query).map_err(|_| ())?;\n        let result = unsafe { execute(self.ptr, query.as_ptr()) };\n        if result == 0 { Ok(()) } else { Err(()) }\n    }\n}\n\nimpl Drop for SafeConnection<'_> {\n    fn drop(&mut self) {\n        unsafe { close_connection(self.ptr); }\n    }\n}\n```\n\n## Opaque Type Pattern\n\n```rust\n// The zero-sized array makes it impossible to construct\n// PhantomData ensures proper variance and !Send/!Sync if needed\n#[repr(C)]\npub struct OpaqueHandle {\n    _private: [u8; 0],\n    _marker: PhantomData<(*mut u8, std::marker::PhantomPinned)>,\n}\n```\n\n## Checklist\n\n- [ ] Am I using `*mut c_void` for distinct handle types?\n- [ ] Would dedicated types prevent bugs?\n- [ ] Have I wrapped opaque pointers in safe Rust types?\n- [ ] Do my types enforce correct handle/function pairing?\n\n## Related Rules\n\n- `ffi-02`: Read std::ffi documentation\n- `ffi-03`: Implement Drop for wrapped pointers\n",
        "skills/unsafe-checker/rules/ffi-18-no-trait-objects.md": "---\nid: ffi-18\noriginal_id: P.UNS.FFI.18\nlevel: P\nimpact: HIGH\n---\n\n# Avoid Passing Trait Objects to C Interfaces\n\n## Summary\n\nTrait objects (`dyn Trait`) have Rust-specific layout (fat pointers with vtable) that is not compatible with C.\n\n## Rationale\n\n- Trait objects are \"fat pointers\": data ptr + vtable ptr\n- C expects thin pointers (single pointer)\n- Vtable layout is not stable across Rust versions\n- C cannot call Rust vtable methods\n\n## Bad Example\n\n```rust\n// DON'T: Pass trait objects to C\ntrait Handler {\n    fn handle(&self, data: i32);\n}\n\nextern \"C\" {\n    // This won't work - dyn Handler is a fat pointer!\n    fn set_handler(h: *const dyn Handler);\n}\n\n// DON'T: Store trait objects in FFI structs\n#[repr(C)]\nstruct BadCallback {\n    handler: *const dyn Handler,  // Not C-compatible!\n}\n```\n\n## Good Example\n\n```rust\nuse std::os::raw::{c_int, c_void};\n\n// DO: Use function pointers with user_data (trampoline pattern)\ntype HandlerFn = extern \"C\" fn(data: c_int, user_data: *mut c_void);\n\nextern \"C\" {\n    fn set_handler(handler: HandlerFn, user_data: *mut c_void);\n}\n\ntrait Handler {\n    fn handle(&self, data: i32);\n}\n\nfn register_handler<H: Handler + 'static>(handler: H) {\n    // Box the handler\n    let boxed: Box<H> = Box::new(handler);\n    let user_data = Box::into_raw(boxed) as *mut c_void;\n\n    extern \"C\" fn trampoline<H: Handler>(data: c_int, user_data: *mut c_void) {\n        let handler = unsafe { &*(user_data as *const H) };\n        handler.handle(data as i32);\n    }\n\n    unsafe {\n        set_handler(trampoline::<H>, user_data);\n    }\n}\n\n// DO: Use concrete types when possible\nstruct ConcreteHandler {\n    multiplier: i32,\n}\n\nimpl Handler for ConcreteHandler {\n    fn handle(&self, data: i32) {\n        println!(\"{}\", data * self.multiplier);\n    }\n}\n\n// DO: Create C-compatible vtable manually if needed\n#[repr(C)]\nstruct HandlerVtable {\n    handle: extern \"C\" fn(this: *const c_void, data: c_int),\n    drop: extern \"C\" fn(this: *mut c_void),\n}\n\n#[repr(C)]\nstruct CCompatibleHandler {\n    data: *mut c_void,\n    vtable: *const HandlerVtable,\n}\n\nimpl CCompatibleHandler {\n    fn new<H: Handler + 'static>(handler: H) -> Self {\n        extern \"C\" fn handle_impl<H: Handler>(this: *const c_void, data: c_int) {\n            let handler = unsafe { &*(this as *const H) };\n            handler.handle(data as i32);\n        }\n\n        extern \"C\" fn drop_impl<H: Handler>(this: *mut c_void) {\n            unsafe { drop(Box::from_raw(this as *mut H)); }\n        }\n\n        static VTABLE: HandlerVtable = HandlerVtable {\n            handle: handle_impl::<ConcreteHandler>,  // Need concrete type\n            drop: drop_impl::<ConcreteHandler>,\n        };\n\n        Self {\n            data: Box::into_raw(Box::new(handler)) as *mut c_void,\n            vtable: &VTABLE,\n        }\n    }\n\n    fn handle(&self, data: i32) {\n        unsafe {\n            ((*self.vtable).handle)(self.data, data as c_int);\n        }\n    }\n}\n\nimpl Drop for CCompatibleHandler {\n    fn drop(&mut self) {\n        unsafe {\n            ((*self.vtable).drop)(self.data);\n        }\n    }\n}\n```\n\n## Why Trait Objects Don't Work\n\n```\nRust trait object (*const dyn Handler):\n[data pointer][vtable pointer]  <- 16 bytes on 64-bit\n\nC pointer (void*):\n[pointer]  <- 8 bytes on 64-bit\n\nThe sizes don't match!\n```\n\n## Alternatives to Trait Objects\n\n| Instead of | Use |\n|------------|-----|\n| `dyn Trait` | Function pointer + user_data |\n| `Box<dyn Trait>` | Boxed concrete type + trampoline |\n| `&dyn Trait` | C-compatible vtable struct |\n| `Arc<dyn Trait>` | Reference counting wrapper |\n\n## Checklist\n\n- [ ] Am I passing trait objects across FFI?\n- [ ] Can I use concrete types instead?\n- [ ] Have I used the trampoline pattern for callbacks?\n- [ ] If vtable is needed, is it C-compatible?\n\n## Related Rules\n\n- `ffi-16`: Closure to C with trampoline pattern\n- `ffi-14`: Types should have stable layout\n",
        "skills/unsafe-checker/rules/general-01-no-abuse.md": "---\nid: general-01\noriginal_id: P.UNS.01\nlevel: P\nimpact: CRITICAL\n---\n\n# Do Not Abuse Unsafe to Escape Compiler Safety Checks\n\n## Summary\n\nUnsafe Rust should not be used as an escape hatch from the borrow checker or other compiler safety mechanisms.\n\n## Rationale\n\nThe borrow checker exists to prevent memory safety bugs. Using `unsafe` to bypass it defeats Rust's safety guarantees and introduces potential undefined behavior.\n\n## Bad Example\n\n```rust\n// DON'T: Using unsafe to bypass borrow checker\nfn bad_alias() {\n    let mut data = vec![1, 2, 3];\n    let ptr = data.as_mut_ptr();\n\n    // Unsafe used to create aliasing mutable references\n    unsafe {\n        let ref1 = &mut *ptr;\n        let ref2 = &mut *ptr;  // UB: Two mutable references!\n        *ref1 = 10;\n        *ref2 = 20;\n    }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Work with the borrow checker, not against it\nfn good_sequential() {\n    let mut data = vec![1, 2, 3];\n    data[0] = 10;\n    data[0] = 20;  // Sequential mutations are fine\n}\n\n// DO: Use interior mutability when needed\nuse std::cell::RefCell;\n\nfn good_interior_mut() {\n    let data = RefCell::new(vec![1, 2, 3]);\n    data.borrow_mut()[0] = 10;\n}\n```\n\n## Legitimate Uses of Unsafe\n\n1. **FFI**: Calling C functions or implementing C-compatible interfaces\n2. **Low-level abstractions**: Implementing collections, synchronization primitives\n3. **Performance**: Only after profiling shows measurable improvement, and with careful safety analysis\n\n## Checklist\n\n- [ ] Have I tried all safe alternatives first?\n- [ ] Is the borrow checker preventing a genuine design need?\n- [ ] Can I restructure the code to satisfy the borrow checker?\n- [ ] If unsafe is necessary, have I documented the safety invariants?\n\n## Related Rules\n\n- `general-02`: Don't blindly use unsafe for performance\n- `safety-02`: Unsafe code authors must verify safety invariants\n",
        "skills/unsafe-checker/rules/general-02-not-for-perf.md": "---\nid: general-02\noriginal_id: P.UNS.02\nlevel: P\nimpact: CRITICAL\n---\n\n# Do Not Blindly Use Unsafe for Performance\n\n## Summary\n\nDo not assume that using `unsafe` will automatically improve performance. Always measure first and verify the safety invariants.\n\n## Rationale\n\n1. Modern Rust optimizers often eliminate bounds checks when they can prove safety\n2. Unsafe code may prevent optimizations by breaking aliasing assumptions\n3. Unmeasured \"optimizations\" often provide no real benefit while introducing risk\n\n## Bad Example\n\n```rust\n// DON'T: Blind unsafe for \"performance\"\nfn sum_bad(slice: &[i32]) -> i32 {\n    let mut sum = 0;\n    // Unnecessary unsafe - LLVM can optimize the safe version\n    for i in 0..slice.len() {\n        unsafe {\n            sum += *slice.get_unchecked(i);\n        }\n    }\n    sum\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use safe iteration - compiler optimizes bounds checks away\nfn sum_good(slice: &[i32]) -> i32 {\n    slice.iter().sum()\n}\n\n// DO: If unsafe is justified, document why\nfn sum_justified(slice: &[i32]) -> i32 {\n    let mut sum = 0;\n    // This is actually slower than iter().sum() in most cases\n    // Only use get_unchecked when:\n    // 1. Profiler shows bounds checks as bottleneck\n    // 2. Iterator patterns can't be used\n    // 3. Safety is proven by other means\n    for i in 0..slice.len() {\n        // SAFETY: i is always < slice.len() due to loop condition\n        unsafe {\n            sum += *slice.get_unchecked(i);\n        }\n    }\n    sum\n}\n```\n\n## When Unsafe Might Be Justified for Performance\n\n1. **Hot inner loops** where profiling shows bounds checks are a bottleneck\n2. **SIMD operations** that require specific memory alignment\n3. **Lock-free data structures** with carefully verified memory orderings\n\n## Measurement Workflow\n\n```bash\n# 1. Benchmark the safe version first\ncargo bench --bench my_bench\n\n# 2. Profile to identify actual bottlenecks\ncargo flamegraph --bench my_bench\n\n# 3. Only then consider unsafe, with measurements\n```\n\n## Checklist\n\n- [ ] Have I benchmarked the safe version?\n- [ ] Does profiling show this specific code as a bottleneck?\n- [ ] Have I measured the actual improvement from unsafe?\n- [ ] Is the performance gain worth the safety risk?\n\n## Related Rules\n\n- `general-01`: Don't abuse unsafe to escape safety checks\n- `safety-02`: Unsafe code authors must verify safety invariants\n",
        "skills/unsafe-checker/rules/general-03-no-alias.md": "---\nid: general-03\noriginal_id: G.UNS.01\nlevel: G\nimpact: MEDIUM\n---\n\n# Do Not Create Aliases for Types/Methods Named \"Unsafe\"\n\n## Summary\n\nDo not create type aliases, re-exports, or wrapper methods that hide the \"unsafe\" nature of operations.\n\n## Rationale\n\nThe word \"unsafe\" in Rust is a signal to developers that extra scrutiny is required. Hiding this signal makes code review harder and can lead to accidental misuse.\n\n## Bad Example\n\n```rust\n// DON'T: Hide unsafe behind an alias\ntype SafePointer = *mut u8;  // Still unsafe to dereference!\n\n// DON'T: Wrap unsafe in a \"safe-looking\" name\npub fn get_value(ptr: *const i32) -> i32 {\n    unsafe { *ptr }  // Caller doesn't know this is unsafe!\n}\n\n// DON'T: Re-export unsafe functions with different names\npub use std::mem::transmute as convert;\n```\n\n## Good Example\n\n```rust\n// DO: Keep \"unsafe\" visible in the API\npub unsafe fn get_value_unchecked(ptr: *const i32) -> i32 {\n    *ptr\n}\n\n// DO: If providing a safe wrapper, make the safety contract clear\n/// Returns the value at the pointer.\n///\n/// # Safety\n/// This is safe because the pointer is validated internally.\npub fn get_value_checked(ptr: *const i32) -> Option<i32> {\n    if ptr.is_null() {\n        None\n    } else {\n        // SAFETY: We checked for null above\n        Some(unsafe { *ptr })\n    }\n}\n\n// DO: Use clear naming for raw pointer types\ntype RawHandle = *mut c_void;  // \"Raw\" signals potential unsafety\n```\n\n## Common Violations\n\n1. Creating type aliases that hide pointer types\n2. Wrapping unsafe functions in safe-looking functions without proper safety analysis\n3. Re-exporting unsafe functions with \"friendlier\" names\n\n## Checklist\n\n- [ ] Does my API preserve visibility of unsafe operations?\n- [ ] If wrapping unsafe code in safe API, is the safety invariant enforced?\n- [ ] Are type aliases clearly named to indicate their nature?\n\n## Related Rules\n\n- `safety-06`: Don't expose raw pointers in public APIs\n- `safety-09`: Add SAFETY comment before any unsafe block\n",
        "skills/unsafe-checker/rules/io-01-raw-handle.md": "---\nid: io-01\noriginal_id: P.UNS.FIO.01\nlevel: P\nimpact: HIGH\n---\n\n# Ensure I/O Safety When Using Raw Handles\n\n## Summary\n\nWhen working with raw file descriptors or handles, ensure they are valid for the duration of use and properly ownership-tracked.\n\n## Rationale\n\n- Raw handles can be closed by other code\n- Using a closed handle is undefined behavior\n- Handle reuse can cause data corruption\n- Rust 1.63+ provides I/O safety traits\n\n## Bad Example\n\n```rust\n#[cfg(unix)]\nmod bad_example {\n    use std::os::unix::io::RawFd;\n\n    // DON'T: Accept raw handle without ownership\n    fn bad_read(fd: RawFd) -> std::io::Result<Vec<u8>> {\n        // What if fd was closed? What if it's reused?\n        let mut buf = vec![0u8; 1024];\n        let n = unsafe {\n            libc::read(fd, buf.as_mut_ptr() as *mut libc::c_void, buf.len())\n        };\n        if n < 0 {\n            Err(std::io::Error::last_os_error())\n        } else {\n            buf.truncate(n as usize);\n            Ok(buf)\n        }\n    }\n\n    // DON'T: Store raw handle without tracking ownership\n    struct BadFileRef {\n        fd: RawFd,  // Who owns this? Who closes it?\n    }\n}\n```\n\n## Good Example\n\n```rust\n#[cfg(unix)]\nmod good_example {\n    use std::os::unix::io::{AsFd, BorrowedFd, OwnedFd, FromRawFd, AsRawFd};\n    use std::fs::File;\n\n    // DO: Use BorrowedFd for borrowed access (Rust 1.63+)\n    fn good_read(fd: BorrowedFd<'_>) -> std::io::Result<Vec<u8>> {\n        let mut buf = vec![0u8; 1024];\n        // BorrowedFd guarantees the fd is valid for this call\n        let n = unsafe {\n            libc::read(\n                fd.as_raw_fd(),\n                buf.as_mut_ptr() as *mut libc::c_void,\n                buf.len()\n            )\n        };\n        if n < 0 {\n            Err(std::io::Error::last_os_error())\n        } else {\n            buf.truncate(n as usize);\n            Ok(buf)\n        }\n    }\n\n    // DO: Use OwnedFd for owned handles\n    struct GoodFileOwner {\n        fd: OwnedFd,  // Clearly owns the handle\n    }\n\n    impl Drop for GoodFileOwner {\n        fn drop(&mut self) {\n            // OwnedFd closes automatically\n        }\n    }\n\n    // DO: Use generic AsFd bound for flexibility\n    fn generic_read<F: AsFd>(f: &F) -> std::io::Result<Vec<u8>> {\n        good_read(f.as_fd())\n    }\n\n    // Usage\n    fn example() -> std::io::Result<()> {\n        let file = File::open(\"test.txt\")?;\n\n        // Pass as BorrowedFd\n        let data = good_read(file.as_fd())?;\n\n        // Or use generic function\n        let data = generic_read(&file)?;\n\n        Ok(())\n    }\n\n    // DO: Take ownership from raw fd\n    fn from_raw(fd: i32) -> Option<GoodFileOwner> {\n        if fd < 0 {\n            return None;\n        }\n        // SAFETY: Caller guarantees fd is valid and ownership is transferred\n        let owned = unsafe { OwnedFd::from_raw_fd(fd) };\n        Some(GoodFileOwner { fd: owned })\n    }\n}\n```\n\n## I/O Safety Types (Rust 1.63+)\n\n| Type | Meaning |\n|------|---------|\n| `OwnedFd` | Owns a file descriptor, closes on drop |\n| `BorrowedFd<'a>` | Borrows a fd for lifetime 'a |\n| `RawFd` | Raw integer, no safety guarantees |\n| `AsFd` | Trait for types that have a fd |\n| `From<OwnedFd>` | Create from owned fd |\n| `Into<OwnedFd>` | Convert to owned fd |\n\n## Windows Equivalents\n\n```rust\n#[cfg(windows)]\nuse std::os::windows::io::{\n    OwnedHandle, BorrowedHandle, RawHandle,\n    AsHandle, FromRawHandle,\n    OwnedSocket, BorrowedSocket, RawSocket,\n    AsSocket, FromRawSocket,\n};\n```\n\n## Checklist\n\n- [ ] Am I using BorrowedFd/OwnedFd instead of RawFd?\n- [ ] Is ownership of handles clear?\n- [ ] Am I using the AsFd trait for generic code?\n- [ ] Is the fd guaranteed valid for the duration of use?\n\n## Related Rules\n\n- `ffi-03`: Implement Drop for resource wrappers\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/mem-01-repr-layout.md": "---\nid: mem-01\noriginal_id: P.UNS.MEM.01\nlevel: P\nimpact: HIGH\n---\n\n# Choose Appropriate Data Layout for Struct/Tuple/Enum\n\n## Summary\n\nUse `#[repr(...)]` attributes to control data layout when interfacing with C, doing memory mapping, or needing specific guarantees.\n\n## Rationale\n\nRust's default layout is unspecified and may change between compiler versions. For FFI, persistence, or low-level memory operations, you need predictable layout.\n\n## Repr Attributes\n\n| Attribute | Use Case |\n|-----------|----------|\n| `#[repr(C)]` | C-compatible layout, stable field order |\n| `#[repr(transparent)]` | Single-field struct with same layout as field |\n| `#[repr(packed)]` | No padding (alignment = 1), careful with references! |\n| `#[repr(align(N))]` | Minimum alignment of N bytes |\n| `#[repr(u8)]`, `#[repr(i32)]`, etc. | Enum discriminant type |\n\n## Bad Example\n\n```rust\n// DON'T: Assume Rust struct layout matches C\nstruct BadFFI {\n    a: u8,\n    b: u32,\n    c: u8,\n}\n// Rust may reorder fields or add different padding than C\n\n// DON'T: Use packed without understanding the risks\n#[repr(packed)]\nstruct Dangerous {\n    a: u8,\n    b: u32,\n}\n\nfn bad_ref(d: &Dangerous) -> &u32 {\n    &d.b  // UB: Creates unaligned reference!\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use repr(C) for FFI\n#[repr(C)]\nstruct GoodFFI {\n    a: u8,\n    b: u32,\n    c: u8,\n}\n// Guaranteed: a at 0, padding 1-3, b at 4, c at 8, padding 9-11\n\n// DO: Use repr(transparent) for newtypes\n#[repr(transparent)]\nstruct Wrapper(u32);\n// Guaranteed same layout as u32, can be transmuted\n\n// DO: Use repr(packed) carefully, access via copy\n#[repr(C, packed)]\nstruct PackedData {\n    header: u8,\n    value: u32,\n}\n\nimpl PackedData {\n    fn value(&self) -> u32 {\n        // Copy out the value to avoid unaligned reference\n        let ptr = std::ptr::addr_of!(self.value);\n        // SAFETY: Reading unaligned is OK with read_unaligned\n        unsafe { ptr.read_unaligned() }\n    }\n}\n\n// DO: Use align for SIMD or cache line alignment\n#[repr(C, align(64))]\nstruct CacheAligned {\n    data: [u8; 64],\n}\n\n// DO: Specify enum discriminant for FFI\n#[repr(u8)]\nenum Status {\n    Ok = 0,\n    Error = 1,\n    Unknown = 255,\n}\n```\n\n## Layout Guarantees\n\n```rust\nuse std::mem::{size_of, align_of};\n\n#[repr(C)]\nstruct Example {\n    a: u8,   // offset 0, size 1\n    // padding: 3 bytes\n    b: u32,  // offset 4, size 4\n    c: u8,   // offset 8, size 1\n    // padding: 3 bytes\n}\n\nassert_eq!(size_of::<Example>(), 12);\nassert_eq!(align_of::<Example>(), 4);\n\n// repr(Rust) might reorder to: b, a, c -> size 8\n```\n\n## Checklist\n\n- [ ] Is this type used in FFI? ‚Üí Use `#[repr(C)]`\n- [ ] Is this a newtype wrapper? ‚Üí Consider `#[repr(transparent)]`\n- [ ] Do I need specific alignment? ‚Üí Use `#[repr(align(N))]`\n- [ ] Am I using packed? ‚Üí Never create references to packed fields\n\n## Related Rules\n\n- `ffi-13`: Ensure consistent data layout for custom types\n- `ffi-14`: Types in FFI should have stable layout\n- `ptr-04`: Alignment considerations\n",
        "skills/unsafe-checker/rules/mem-02-no-other-process.md": "---\nid: mem-02\noriginal_id: P.UNS.MEM.02\nlevel: P\nimpact: CRITICAL\n---\n\n# Do Not Modify Memory Variables of Other Processes or Dynamic Libraries\n\n## Summary\n\nDo not directly manipulate memory belonging to other processes or dynamically loaded libraries. Use proper IPC or FFI mechanisms.\n\n## Rationale\n\n- Other processes have separate address spaces; direct access is impossible on modern OSes\n- Shared memory requires explicit setup and synchronization\n- Dynamic library memory has ownership rules that must be respected\n- Violating these causes undefined behavior or security vulnerabilities\n\n## Bad Example\n\n```rust\n// DON'T: Try to access another process's memory directly\nfn bad_cross_process(ptr: *mut i32) {\n    // This pointer from another process is meaningless in our address space\n    unsafe { *ptr = 42; }  // Undefined behavior or crash\n}\n\n// DON'T: Modify library internals\nextern \"C\" {\n    static mut LIBRARY_INTERNAL: i32;\n}\n\nfn bad_library_access() {\n    // Modifying library internals breaks encapsulation\n    unsafe { LIBRARY_INTERNAL = 100; }  // May corrupt library state\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use proper IPC for cross-process communication\nuse std::io::{Read, Write};\nuse std::os::unix::net::UnixStream;\n\nfn ipc_communication() -> std::io::Result<()> {\n    let mut stream = UnixStream::connect(\"/tmp/socket\")?;\n    stream.write_all(b\"message\")?;\n    Ok(())\n}\n\n// DO: Use shared memory with proper synchronization\n#[cfg(unix)]\nfn shared_memory_example() {\n    use std::sync::atomic::{AtomicI32, Ordering};\n\n    // Properly set up shared memory region\n    // let shm = mmap shared memory...\n\n    // Use atomic operations for synchronization\n    let shared: &AtomicI32 = /* ... */;\n    shared.store(42, Ordering::Release);\n}\n\n// DO: Use proper FFI for library interaction\nmod ffi {\n    extern \"C\" {\n        pub fn library_set_value(value: i32);\n        pub fn library_get_value() -> i32;\n    }\n}\n\nfn proper_library_access() {\n    unsafe {\n        ffi::library_set_value(42);\n        let value = ffi::library_get_value();\n    }\n}\n\n// DO: Use Rust's libloading for dynamic libraries\nfn dynamic_library() -> Result<(), Box<dyn std::error::Error>> {\n    let lib = unsafe { libloading::Library::new(\"mylib.so\")? };\n    let func: libloading::Symbol<extern \"C\" fn(i32) -> i32> =\n        unsafe { lib.get(b\"my_function\")? };\n    let result = func(42);\n    Ok(())\n}\n```\n\n## Memory Ownership Rules\n\n| Memory Type | Owner | Safe Access |\n|-------------|-------|-------------|\n| Stack variables | Current function | Direct |\n| Heap (Box, Vec) | Rust allocator | Through smart pointers |\n| Static | Program | With proper synchronization |\n| Shared memory | Multiple processes | Atomic ops, mutexes |\n| Library memory | Library | Through library API |\n| FFI-allocated | C allocator | Through C free functions |\n\n## Checklist\n\n- [ ] Who allocated this memory?\n- [ ] Who is responsible for freeing it?\n- [ ] Is proper synchronization in place for shared access?\n- [ ] Am I using the correct API for cross-boundary access?\n\n## Related Rules\n\n- `mem-03`: Don't let String/Vec drop other process's memory\n- `ffi-03`: Implement Drop for wrapped C pointers\n",
        "skills/unsafe-checker/rules/mem-03-no-auto-drop-foreign.md": "---\nid: mem-03\noriginal_id: P.UNS.MEM.03\nlevel: P\nimpact: CRITICAL\n---\n\n# Do Not Let String/Vec Auto-Drop Other Process's Memory\n\n## Summary\n\nNever create `String`, `Vec`, or `Box` from memory allocated outside Rust's allocator. They will try to free the memory with the wrong deallocator.\n\n## Rationale\n\n`String`, `Vec`, and `Box` assume memory was allocated by Rust's global allocator. When dropped, they call `dealloc`. If the memory came from C's `malloc`, a different allocator, or shared memory, this causes undefined behavior.\n\n## Bad Example\n\n```rust\n// DON'T: Create String from C-allocated memory\nextern \"C\" {\n    fn c_get_string() -> *mut std::os::raw::c_char;\n}\n\nfn bad_string() -> String {\n    unsafe {\n        let ptr = c_get_string();\n        // BAD: String will try to free with Rust allocator\n        String::from_raw_parts(ptr as *mut u8, len, cap)\n    }\n}\n\n// DON'T: Create Vec from foreign memory\nfn bad_vec(ptr: *mut u8, len: usize) -> Vec<u8> {\n    // BAD: Vec will free this memory incorrectly\n    unsafe { Vec::from_raw_parts(ptr, len, len) }\n}\n\n// DON'T: Wrap shared memory in Box\nfn bad_box(shared_ptr: *mut Data) -> Box<Data> {\n    // BAD: Box will try to deallocate shared memory!\n    unsafe { Box::from_raw(shared_ptr) }\n}\n```\n\n## Good Example\n\n```rust\nuse std::ffi::CStr;\n\nextern \"C\" {\n    fn c_get_string() -> *mut std::os::raw::c_char;\n    fn c_free_string(s: *mut std::os::raw::c_char);\n}\n\n// DO: Copy data into Rust-owned allocation\nfn good_string() -> String {\n    unsafe {\n        let ptr = c_get_string();\n        let cstr = CStr::from_ptr(ptr);\n        let result = cstr.to_string_lossy().into_owned();\n        c_free_string(ptr);  // Free with correct deallocator\n        result\n    }\n}\n\n// DO: Use wrapper that calls correct deallocator\nstruct CString {\n    ptr: *mut std::os::raw::c_char,\n}\n\nimpl Drop for CString {\n    fn drop(&mut self) {\n        unsafe { c_free_string(self.ptr); }\n    }\n}\n\n// DO: Use slice for borrowed view, don't take ownership\nfn good_slice(ptr: *const u8, len: usize) -> &'static [u8] {\n    // Only borrow, don't own\n    unsafe { std::slice::from_raw_parts(ptr, len) }\n}\n\n// DO: For shared memory, use raw pointers or custom wrapper\nstruct SharedBuffer {\n    ptr: *mut u8,\n    len: usize,\n}\n\nimpl SharedBuffer {\n    fn as_slice(&self) -> &[u8] {\n        unsafe { std::slice::from_raw_parts(self.ptr, self.len) }\n    }\n}\n\nimpl Drop for SharedBuffer {\n    fn drop(&mut self) {\n        // Unmap shared memory, don't deallocate\n        // munmap(self.ptr, self.len);\n    }\n}\n```\n\n## Memory Allocation Compatibility\n\n| Allocator | Can use Rust Vec/String/Box? |\n|-----------|------------------------------|\n| Rust global allocator | Yes |\n| C malloc | No - use wrapper with C free |\n| C++ new | No - use wrapper with C++ delete |\n| Custom allocator | No - use allocator_api |\n| mmap/shared memory | No - use munmap |\n| Stack/static | No - never \"free\" |\n\n## Checklist\n\n- [ ] Who allocated this memory?\n- [ ] Is it from Rust's global allocator?\n- [ ] If not, do I have a custom Drop that frees correctly?\n- [ ] Am I copying data or taking ownership?\n\n## Related Rules\n\n- `mem-02`: Don't modify other process's memory\n- `ffi-03`: Implement Drop for wrapped C pointers\n- `ffi-07`: Don't implement Drop for types passed to external code\n",
        "skills/unsafe-checker/rules/mem-04-reentrant.md": "---\nid: mem-04\noriginal_id: P.UNS.MEM.04\nlevel: P\nimpact: HIGH\n---\n\n# Prefer Reentrant Versions of C-API or Syscalls\n\n## Summary\n\nWhen calling C functions or system calls, use reentrant (`_r`) versions to avoid data races from global state.\n\n## Rationale\n\nMany C library functions use static buffers or global state, making them unsafe in multithreaded programs. Reentrant versions use caller-provided buffers instead.\n\n## Bad Example\n\n```rust\nuse std::ffi::CStr;\n\nextern \"C\" {\n    fn strtok(s: *mut i8, delim: *const i8) -> *mut i8;\n    fn localtime(time: *const i64) -> *mut Tm;\n    fn rand() -> i32;\n}\n\n// DON'T: Use non-reentrant functions\nfn bad_tokenize(s: &mut [i8]) {\n    unsafe {\n        let delim = b\" \\0\".as_ptr() as *const i8;\n        // strtok uses static buffer - not thread-safe!\n        let token = strtok(s.as_mut_ptr(), delim);\n    }\n}\n\nfn bad_time() {\n    unsafe {\n        let now: i64 = 0;\n        // localtime returns pointer to static buffer\n        let tm = localtime(&now);  // Data race if called from multiple threads!\n    }\n}\n\nfn bad_random() -> i32 {\n    // rand() uses global state - not thread-safe\n    unsafe { rand() }\n}\n```\n\n## Good Example\n\n```rust\nextern \"C\" {\n    fn strtok_r(s: *mut i8, delim: *const i8, saveptr: *mut *mut i8) -> *mut i8;\n    fn localtime_r(time: *const i64, result: *mut Tm) -> *mut Tm;\n    fn rand_r(seed: *mut u32) -> i32;\n}\n\n// DO: Use reentrant versions\nfn good_tokenize(s: &mut [i8]) {\n    unsafe {\n        let delim = b\" \\0\".as_ptr() as *const i8;\n        let mut saveptr: *mut i8 = std::ptr::null_mut();\n        // strtok_r uses caller-provided saveptr\n        let token = strtok_r(s.as_mut_ptr(), delim, &mut saveptr);\n    }\n}\n\nfn good_time() {\n    unsafe {\n        let now: i64 = 0;\n        let mut result: Tm = std::mem::zeroed();\n        // localtime_r writes to caller-provided buffer\n        localtime_r(&now, &mut result);\n    }\n}\n\nfn good_random(seed: &mut u32) -> i32 {\n    // rand_r uses caller-provided seed\n    unsafe { rand_r(seed) }\n}\n\n// BETTER: Use Rust standard library\nfn best_time() {\n    use std::time::SystemTime;\n    let now = SystemTime::now();  // Thread-safe!\n}\n\nfn best_random() -> u32 {\n    use rand::Rng;\n    rand::thread_rng().gen()  // Thread-safe!\n}\n```\n\n## Common Non-Reentrant Functions\n\n| Non-Reentrant | Reentrant | Rust Alternative |\n|---------------|-----------|------------------|\n| `strtok` | `strtok_r` | `str::split` |\n| `localtime` | `localtime_r` | `chrono` crate |\n| `gmtime` | `gmtime_r` | `chrono` crate |\n| `ctime` | `ctime_r` | `chrono` crate |\n| `rand` | `rand_r` | `rand` crate |\n| `strerror` | `strerror_r` | `std::io::Error` |\n| `getenv` | None (inherent race) | `std::env::var` (not atomic) |\n| `readdir` | `readdir_r` | `std::fs::read_dir` |\n| `gethostbyname` | `getaddrinfo` | `std::net::ToSocketAddrs` |\n\n## Checklist\n\n- [ ] Am I calling a C function that might use global state?\n- [ ] Is there a `_r` reentrant version available?\n- [ ] Is there a Rust standard library alternative?\n- [ ] If neither, do I need synchronization?\n\n## Related Rules\n\n- `ffi-10`: Exported functions must be thread-safe\n- `ptr-01`: Don't share raw pointers across threads\n",
        "skills/unsafe-checker/rules/mem-05-bitfield-crates.md": "---\nid: mem-05\noriginal_id: P.UNS.MEM.05\nlevel: P\nimpact: MEDIUM\n---\n\n# Use Third-Party Crates for Bitfields\n\n## Summary\n\nUse crates like `bitflags`, `bitvec`, or `modular-bitfield` instead of manual bit manipulation for complex bitfield operations.\n\n## Rationale\n\n- Manual bit manipulation is error-prone\n- Easy to get offsets, masks, or endianness wrong\n- Crates provide type-safe, tested abstractions\n- Proc-macro crates generate efficient code\n\n## Bad Example\n\n```rust\n// DON'T: Manual bitfield manipulation\nstruct Flags(u32);\n\nimpl Flags {\n    const READ: u32 = 1 << 0;\n    const WRITE: u32 = 1 << 1;\n    const EXECUTE: u32 = 1 << 2;\n\n    fn has_read(&self) -> bool {\n        (self.0 & Self::READ) != 0\n    }\n\n    fn set_read(&mut self) {\n        self.0 |= Self::READ;\n    }\n\n    fn clear_read(&mut self) {\n        self.0 &= !Self::READ;  // Easy to forget the !\n    }\n}\n\n// DON'T: Manual packed bitfields for FFI\n#[repr(C)]\nstruct PackedHeader {\n    data: u32,\n}\n\nimpl PackedHeader {\n    // Error-prone: wrong shift or mask values\n    fn version(&self) -> u8 {\n        ((self.data >> 24) & 0xFF) as u8\n    }\n\n    fn flags(&self) -> u16 {\n        ((self.data >> 8) & 0xFFFF) as u16\n    }\n\n    fn tag(&self) -> u8 {\n        (self.data & 0xFF) as u8\n    }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use bitflags for flag sets\nuse bitflags::bitflags;\n\nbitflags! {\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    struct Flags: u32 {\n        const READ = 1 << 0;\n        const WRITE = 1 << 1;\n        const EXECUTE = 1 << 2;\n        const RW = Self::READ.bits() | Self::WRITE.bits();\n    }\n}\n\nfn use_flags() {\n    let mut flags = Flags::READ | Flags::WRITE;\n    flags.insert(Flags::EXECUTE);\n    flags.remove(Flags::WRITE);\n\n    if flags.contains(Flags::READ) {\n        println!(\"Readable\");\n    }\n}\n\n// DO: Use modular-bitfield for packed structures\nuse modular_bitfield::prelude::*;\n\n#[bitfield]\n#[repr(C)]\nstruct PackedHeader {\n    tag: B8,      // 8 bits\n    flags: B16,   // 16 bits\n    version: B8,  // 8 bits\n}\n\nfn use_packed() {\n    let header = PackedHeader::new()\n        .with_version(1)\n        .with_flags(0x1234)\n        .with_tag(0xAB);\n\n    assert_eq!(header.version(), 1);\n    assert_eq!(header.flags(), 0x1234);\n}\n\n// DO: Use bitvec for arbitrary bit manipulation\nuse bitvec::prelude::*;\n\nfn use_bitvec() {\n    let mut bits = bitvec![u8, Msb0; 0; 16];\n    bits.set(0, true);\n    bits.set(7, true);\n\n    let byte: u8 = bits[0..8].load_be();\n    assert_eq!(byte, 0b1000_0001);\n}\n```\n\n## Recommended Crates\n\n| Crate | Use Case | Features |\n|-------|----------|----------|\n| `bitflags` | Flag sets (like C enums) | Type-safe, const, derives |\n| `modular-bitfield` | Packed struct fields | Proc macro, repr(C) |\n| `bitvec` | Arbitrary bit arrays | Slicing, iteration |\n| `packed_struct` | Binary protocol structs | Endianness, derive |\n| `deku` | Binary parsing | Derive, read/write |\n\n## Checklist\n\n- [ ] Am I manipulating multiple bit flags? ‚Üí Use `bitflags`\n- [ ] Am I packing fields into bytes? ‚Üí Use `modular-bitfield` or `packed_struct`\n- [ ] Am I doing binary protocol work? ‚Üí Consider `deku`\n- [ ] Is the manual approach really simpler?\n\n## Related Rules\n\n- `mem-01`: Choose appropriate data layout\n- `ffi-13`: Ensure consistent data layout\n",
        "skills/unsafe-checker/rules/mem-06-maybeuninit.md": "---\nid: mem-06\noriginal_id: G.UNS.MEM.01\nlevel: G\nimpact: HIGH\nclippy: uninit_assumed_init, uninit_vec\n---\n\n# Use MaybeUninit<T> for Uninitialized Memory\n\n## Summary\n\nUse `MaybeUninit<T>` instead of `mem::uninitialized()` or `mem::zeroed()` when working with uninitialized memory.\n\n## Rationale\n\n- `mem::uninitialized()` is deprecated and unsound\n- `mem::zeroed()` is UB for types where zero is invalid (references, NonZero, bool)\n- `MaybeUninit<T>` clearly marks memory as potentially uninitialized\n- Compiler can optimize based on initialization state\n\n## Bad Example\n\n```rust\n// DON'T: Use deprecated uninitialized\nfn bad_uninit<T>() -> T {\n    unsafe { std::mem::uninitialized() }  // Deprecated, UB\n}\n\n// DON'T: Use zeroed for types where zero is invalid\nfn bad_zeroed() -> &'static str {\n    unsafe { std::mem::zeroed() }  // UB: null reference\n}\n\nfn bad_zeroed_bool() -> bool {\n    unsafe { std::mem::zeroed() }  // UB: 0 might not be valid bool\n}\n\n// DON'T: Transmute to \"initialize\"\nfn bad_transmute() -> [String; 10] {\n    unsafe { std::mem::transmute([0u8; std::mem::size_of::<[String; 10]>()]) }\n}\n\n// DON'T: Set Vec length without initializing\nfn bad_vec() -> Vec<String> {\n    let mut v = Vec::with_capacity(10);\n    unsafe { v.set_len(10); }  // Elements are uninitialized!\n    v\n}\n```\n\n## Good Example\n\n```rust\nuse std::mem::MaybeUninit;\n\n// DO: Use MaybeUninit for delayed initialization\nfn good_array() -> [String; 10] {\n    let mut arr: [MaybeUninit<String>; 10] =\n        unsafe { MaybeUninit::uninit().assume_init() };\n\n    for (i, elem) in arr.iter_mut().enumerate() {\n        elem.write(format!(\"item {}\", i));\n    }\n\n    // SAFETY: All elements initialized above\n    unsafe { std::mem::transmute::<_, [String; 10]>(arr) }\n}\n\n// DO: Use MaybeUninit with arrays (cleaner with array_assume_init)\nfn good_array_nightly() -> [String; 10] {\n    let mut arr: [MaybeUninit<String>; 10] =\n        [const { MaybeUninit::uninit() }; 10];\n\n    for (i, elem) in arr.iter_mut().enumerate() {\n        elem.write(format!(\"item {}\", i));\n    }\n\n    // On nightly: arr.map(|e| unsafe { e.assume_init() })\n    unsafe { MaybeUninit::array_assume_init(arr) }\n}\n\n// DO: Use zeroed only for types where it's valid\nfn good_zeroed() -> [u8; 1024] {\n    // SAFETY: All-zero bytes is valid for u8\n    unsafe { std::mem::zeroed() }\n}\n\n// DO: Initialize buffer properly\nfn good_vec() -> Vec<u8> {\n    let mut v = Vec::with_capacity(1024);\n\n    // Option 1: Resize with default value\n    v.resize(1024, 0);\n\n    // Option 2: Use spare_capacity_mut\n    let spare = v.spare_capacity_mut();\n    for elem in spare.iter_mut().take(1024) {\n        elem.write(0);\n    }\n    unsafe { v.set_len(1024); }\n\n    v\n}\n\n// DO: Use MaybeUninit::uninit_array (nightly) or const array\nfn good_uninit_array<const N: usize>() -> [MaybeUninit<u8>; N] {\n    // Stable: create array of uninit\n    [const { MaybeUninit::uninit() }; N]\n}\n```\n\n## MaybeUninit API\n\n```rust\nuse std::mem::MaybeUninit;\n\n// Creation\nlet uninit: MaybeUninit<T> = MaybeUninit::uninit();\nlet zeroed: MaybeUninit<T> = MaybeUninit::zeroed();\nlet init: MaybeUninit<T> = MaybeUninit::new(value);\n\n// Writing\nuninit.write(value);  // Returns &mut T\n\n// Reading (unsafe)\nlet value: T = unsafe { uninit.assume_init() };\nlet ref_: &T = unsafe { uninit.assume_init_ref() };\nlet mut_: &mut T = unsafe { uninit.assume_init_mut() };\n\n// Pointer access\nlet ptr: *const T = uninit.as_ptr();\nlet mut_ptr: *mut T = uninit.as_mut_ptr();\n```\n\n## Checklist\n\n- [ ] Am I using `mem::uninitialized()`? ‚Üí Replace with `MaybeUninit`\n- [ ] Am I using `mem::zeroed()` for non-POD types? ‚Üí Use `MaybeUninit`\n- [ ] Am I setting Vec length without initialization? ‚Üí Use proper initialization\n- [ ] Have I initialized all MaybeUninit before assume_init?\n\n## Related Rules\n\n- `safety-03`: Don't expose uninitialized memory in APIs\n- `safety-01`: Panic safety with partial initialization\n",
        "skills/unsafe-checker/rules/ptr-01-no-thread-share.md": "---\nid: ptr-01\noriginal_id: P.UNS.PTR.01\nlevel: P\nimpact: CRITICAL\n---\n\n# Do Not Share Raw Pointers Across Threads\n\n## Summary\n\nRaw pointers (`*const T`, `*mut T`) are not `Send` or `Sync` by default. Do not share them across threads without ensuring proper synchronization.\n\n## Rationale\n\nRaw pointers have no synchronization guarantees. Sharing them across threads can lead to data races, which are undefined behavior.\n\n## Bad Example\n\n```rust\nuse std::thread;\n\n// DON'T: Share raw pointers across threads\nfn bad_sharing() {\n    let mut data = 42i32;\n    let ptr = &mut data as *mut i32;\n\n    let handle = thread::spawn(move || {\n        // This is undefined behavior!\n        unsafe { *ptr = 100; }\n    });\n\n    // Main thread also accesses - data race!\n    unsafe { *ptr = 200; }\n\n    handle.join().unwrap();\n}\n\n// DON'T: Wrap in struct and impl Send unsafely\nstruct UnsafePtr(*mut i32);\nunsafe impl Send for UnsafePtr {}  // Unsound without synchronization!\n```\n\n## Good Example\n\n```rust\nuse std::sync::{Arc, Mutex, atomic::{AtomicPtr, Ordering}};\nuse std::thread;\n\n// DO: Use Arc<Mutex<T>> for shared mutable access\nfn good_mutex() {\n    let data = Arc::new(Mutex::new(42i32));\n    let data_clone = Arc::clone(&data);\n\n    let handle = thread::spawn(move || {\n        *data_clone.lock().unwrap() = 100;\n    });\n\n    *data.lock().unwrap() = 200;\n    handle.join().unwrap();\n}\n\n// DO: Use AtomicPtr for lock-free pointer sharing\nfn good_atomic() {\n    let data = Box::into_raw(Box::new(42i32));\n    let atomic_ptr = Arc::new(AtomicPtr::new(data));\n    let atomic_clone = Arc::clone(&atomic_ptr);\n\n    let handle = thread::spawn(move || {\n        let ptr = atomic_clone.load(Ordering::Acquire);\n        // SAFETY: We have exclusive access through atomic operations\n        unsafe { println!(\"Value: {}\", *ptr); }\n    });\n\n    handle.join().unwrap();\n\n    // SAFETY: All threads done, we own the memory\n    unsafe { drop(Box::from_raw(atomic_ptr.load(Ordering::Relaxed))); }\n}\n\n// DO: If you must use raw pointers, ensure exclusive access\nfn good_exclusive() {\n    let mut data = vec![1, 2, 3];\n\n    // Send data ownership to thread, not pointer\n    let handle = thread::spawn(move || {\n        data.push(4);\n        data\n    });\n\n    let data = handle.join().unwrap();\n    println!(\"{:?}\", data);\n}\n```\n\n## When Raw Pointers Across Threads Are Valid\n\nOnly with proper synchronization:\n- Through `AtomicPtr` with appropriate memory orderings\n- Protected by a `Mutex` (don't share the pointer, share the Mutex)\n- Using lock-free algorithms with careful memory ordering\n\n## Checklist\n\n- [ ] Does my pointer cross thread boundaries?\n- [ ] Is there synchronization preventing concurrent access?\n- [ ] Can I use a higher-level abstraction (Arc, Mutex)?\n- [ ] If implementing Send/Sync, is thread safety proven?\n\n## Related Rules\n\n- `safety-05`: Consider safety when implementing Send/Sync\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/ptr-02-prefer-nonnull.md": "---\nid: ptr-02\noriginal_id: P.UNS.PTR.02\nlevel: P\nimpact: MEDIUM\n---\n\n# Prefer NonNull<T> Over *mut T\n\n## Summary\n\nUse `NonNull<T>` instead of `*mut T` when the pointer should never be null. This enables null pointer optimization and makes the intent clear.\n\n## Rationale\n\n- `NonNull<T>` guarantees non-null at the type level\n- Enables niche optimization: `Option<NonNull<T>>` is the same size as `*mut T`\n- Makes invariants explicit in the type system\n- Covariant over `T` (like `&T`), which is usually what you want\n\n## Bad Example\n\n```rust\n// DON'T: Use *mut when pointer is always non-null\nstruct MyBox<T> {\n    ptr: *mut T,  // Invariant: never null, but not enforced\n}\n\nimpl<T> MyBox<T> {\n    pub fn new(value: T) -> Self {\n        let ptr = Box::into_raw(Box::new(value));\n        // ptr is guaranteed non-null, but type doesn't show it\n        Self { ptr }\n    }\n\n    pub fn get(&self) -> &T {\n        // Must add null check or document the invariant\n        unsafe { &*self.ptr }\n    }\n}\n```\n\n## Good Example\n\n```rust\nuse std::ptr::NonNull;\n\n// DO: Use NonNull when pointer is never null\nstruct MyBox<T> {\n    ptr: NonNull<T>,  // Type guarantees non-null\n}\n\nimpl<T> MyBox<T> {\n    pub fn new(value: T) -> Self {\n        let ptr = Box::into_raw(Box::new(value));\n        // SAFETY: Box::into_raw never returns null\n        let ptr = unsafe { NonNull::new_unchecked(ptr) };\n        Self { ptr }\n    }\n\n    pub fn get(&self) -> &T {\n        // SAFETY: NonNull guarantees ptr is valid\n        unsafe { self.ptr.as_ref() }\n    }\n}\n\nimpl<T> Drop for MyBox<T> {\n    fn drop(&mut self) {\n        // SAFETY: ptr was created from Box::into_raw\n        unsafe { drop(Box::from_raw(self.ptr.as_ptr())); }\n    }\n}\n\n// DO: Niche optimization with Option\nstruct OptionalBox<T> {\n    ptr: Option<NonNull<T>>,  // Same size as *mut T!\n}\n```\n\n## NonNull API\n\n```rust\nuse std::ptr::NonNull;\n\n// Creating NonNull\nlet ptr: NonNull<i32> = NonNull::new(raw_ptr).expect(\"null pointer\");\nlet ptr: NonNull<i32> = unsafe { NonNull::new_unchecked(raw_ptr) };\nlet ptr: NonNull<i32> = NonNull::dangling();  // For ZSTs or uninitialized\n\n// Using NonNull\nlet raw: *mut i32 = ptr.as_ptr();\nlet reference: &i32 = unsafe { ptr.as_ref() };\nlet mut_ref: &mut i32 = unsafe { ptr.as_mut() };\n\n// Casting\nlet ptr: NonNull<u8> = ptr.cast::<u8>();\n```\n\n## When to Use *mut T Instead\n\n- When null is a valid/expected value\n- FFI with C code that may return null\n- When variance matters (NonNull is covariant, sometimes you need invariance)\n\n## Checklist\n\n- [ ] Is my pointer ever null? If no, use NonNull\n- [ ] Do I need null pointer optimization?\n- [ ] Is the variance correct for my use case?\n\n## Related Rules\n\n- `ptr-03`: Use PhantomData for variance and ownership\n- `safety-06`: Don't expose raw pointers in public APIs\n",
        "skills/unsafe-checker/rules/ptr-03-phantomdata.md": "---\nid: ptr-03\noriginal_id: P.UNS.PTR.03\nlevel: P\nimpact: HIGH\n---\n\n# Use PhantomData<T> for Variance and Ownership with Pointer Generics\n\n## Summary\n\nWhen a struct contains raw pointers but logically owns or borrows the pointed-to data, use `PhantomData<T>` to tell the compiler about the relationship.\n\n## Rationale\n\nRaw pointers don't carry ownership or lifetime information. `PhantomData` lets you:\n- Indicate ownership (for `Drop` check)\n- Control variance (covariant, contravariant, invariant)\n- Participate in lifetime elision\n\n## Bad Example\n\n```rust\n// DON'T: Raw pointer without PhantomData\nstruct MyVec<T> {\n    ptr: *mut T,\n    len: usize,\n    cap: usize,\n}\n\n// Problems:\n// 1. Compiler doesn't know we \"own\" the T values\n// 2. T might be incorrectly determined as unused\n// 3. Drop check may allow dangling references\n```\n\n## Good Example\n\n```rust\nuse std::marker::PhantomData;\nuse std::ptr::NonNull;\n\n// DO: Use PhantomData to express ownership\nstruct MyVec<T> {\n    ptr: NonNull<T>,\n    len: usize,\n    cap: usize,\n    _marker: PhantomData<T>,  // We own T values\n}\n\n// For owned data: PhantomData<T>\n// For borrowed data: PhantomData<&'a T>\n// For mutably borrowed: PhantomData<&'a mut T>\n// For function pointers: PhantomData<fn(T)> (contravariant)\n\n// DO: Express lifetime relationships\nstruct Iter<'a, T> {\n    ptr: *const T,\n    end: *const T,\n    _marker: PhantomData<&'a T>,  // Borrows T for 'a\n}\n\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.ptr == self.end {\n            None\n        } else {\n            // SAFETY: ptr < end, so ptr is valid\n            // Lifetime is tied to 'a through PhantomData\n            let current = unsafe { &*self.ptr };\n            self.ptr = unsafe { self.ptr.add(1) };\n            Some(current)\n        }\n    }\n}\n```\n\n## PhantomData Patterns\n\n| Phantom Type | Meaning | Variance |\n|--------------|---------|----------|\n| `PhantomData<T>` | Owns T | Covariant |\n| `PhantomData<&'a T>` | Borrows T for 'a | Covariant in T, covariant in 'a |\n| `PhantomData<&'a mut T>` | Mutably borrows T | Invariant in T, covariant in 'a |\n| `PhantomData<*const T>` | Just has pointer | Covariant |\n| `PhantomData<*mut T>` | Just has pointer | Invariant |\n| `PhantomData<fn(T)>` | Consumes T | Contravariant |\n| `PhantomData<fn() -> T>` | Produces T | Covariant |\n\n## Drop Check\n\n```rust\nuse std::marker::PhantomData;\n\n// This tells the compiler that dropping MyVec may drop T values\nstruct MyVec<T> {\n    ptr: NonNull<T>,\n    _marker: PhantomData<T>,\n}\n\nimpl<T> Drop for MyVec<T> {\n    fn drop(&mut self) {\n        // Drop all T values...\n    }\n}\n\n// Without PhantomData<T>, this might compile incorrectly:\n// let x = MyVec::new(&local);\n// drop(local);  // Would be UB if allowed\n// drop(x);      // Tries to access dropped local\n```\n\n## Checklist\n\n- [ ] Does my pointer type logically own the pointed-to data?\n- [ ] Do I need to express a lifetime relationship?\n- [ ] What variance do I need for my generic parameter?\n- [ ] Will the type be dropped, and does it need drop check?\n\n## Related Rules\n\n- `ptr-02`: Prefer NonNull over *mut T\n- `safety-05`: Send/Sync implementation safety\n",
        "skills/unsafe-checker/rules/ptr-04-alignment.md": "---\nid: ptr-04\noriginal_id: G.UNS.PTR.01\nlevel: G\nimpact: HIGH\nclippy: cast_ptr_alignment\n---\n\n# Do Not Dereference Pointers Cast to Misaligned Types\n\n## Summary\n\nWhen casting a pointer to a different type, ensure the resulting pointer is properly aligned for the target type.\n\n## Rationale\n\nMisaligned pointer dereferences are undefined behavior on most architectures. Even on architectures that support unaligned access, it may cause performance penalties or subtle bugs.\n\n## Bad Example\n\n```rust\n// DON'T: Cast without checking alignment\nfn bad_cast(bytes: &[u8]) -> u32 {\n    // BAD: bytes might not be aligned for u32\n    let ptr = bytes.as_ptr() as *const u32;\n    unsafe { *ptr }  // UB if misaligned!\n}\n\n// DON'T: Assume struct layout\n#[repr(C)]\nstruct Header {\n    flags: u8,\n    value: u32,  // Aligned at offset 4 in the struct\n}\n\nfn bad_field_access(bytes: &[u8]) -> u32 {\n    let header = bytes.as_ptr() as *const Header;\n    // Even if bytes is 4-byte aligned, this might fail\n    // if Header has different alignment than expected\n    unsafe { (*header).value }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use read_unaligned for potentially misaligned data\nfn good_cast(bytes: &[u8]) -> u32 {\n    assert!(bytes.len() >= 4);\n    let ptr = bytes.as_ptr() as *const u32;\n    // SAFETY: We're reading 4 bytes, alignment doesn't matter for read_unaligned\n    unsafe { ptr.read_unaligned() }\n}\n\n// DO: Check alignment before cast\nfn good_aligned_cast(bytes: &[u8]) -> Option<&u32> {\n    if bytes.len() >= 4 && bytes.as_ptr() as usize % std::mem::align_of::<u32>() == 0 {\n        // SAFETY: Checked length and alignment\n        Some(unsafe { &*(bytes.as_ptr() as *const u32) })\n    } else {\n        None\n    }\n}\n\n// DO: Use from_ne_bytes for portable byte conversion\nfn good_from_bytes(bytes: &[u8]) -> u32 {\n    u32::from_ne_bytes(bytes[..4].try_into().unwrap())\n}\n\n// DO: Use bytemuck for safe transmutation\n// use bytemuck::{Pod, Zeroable};\n// let value: u32 = bytemuck::pod_read_unaligned(bytes);\n\n// DO: Use align_to for splitting at alignment boundaries\nfn process_aligned(bytes: &[u8]) {\n    let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u32>() };\n    // prefix and suffix are unaligned portions\n    // aligned is a &[u32] that's properly aligned\n}\n```\n\n## Alignment Check Helpers\n\n```rust\nfn is_aligned<T>(ptr: *const u8) -> bool {\n    ptr as usize % std::mem::align_of::<T>() == 0\n}\n\n/// Align a pointer up to the next aligned address\nfn align_up<T>(ptr: *const u8) -> *const u8 {\n    let align = std::mem::align_of::<T>();\n    let addr = ptr as usize;\n    let aligned = (addr + align - 1) & !(align - 1);\n    aligned as *const u8\n}\n```\n\n## Architecture Notes\n\n| Arch | Misaligned Access |\n|------|-------------------|\n| x86/x64 | Works but slower |\n| ARM | UB, may trap or give wrong results |\n| RISC-V | UB, may trap |\n| WASM | UB |\n\n## Checklist\n\n- [ ] Is my pointer cast changing alignment requirements?\n- [ ] Is the source pointer guaranteed to be aligned?\n- [ ] Should I use read_unaligned instead?\n- [ ] Can I use safe conversion methods (from_ne_bytes)?\n\n## Related Rules\n\n- `mem-01`: Choose appropriate data layout\n- `ffi-13`: Ensure consistent data layout\n",
        "skills/unsafe-checker/rules/ptr-05-no-const-to-mut.md": "---\nid: ptr-05\noriginal_id: G.UNS.PTR.02\nlevel: G\nimpact: CRITICAL\nclippy: cast_ref_to_mut\n---\n\n# Do Not Manually Convert Immutable Pointer to Mutable\n\n## Summary\n\nNever cast `*const T` to `*mut T` and dereference it to write. This violates aliasing rules and is undefined behavior.\n\n## Rationale\n\nCreating `*const T` from `&T` implies immutability. Other references might exist. Writing through a `*mut T` created from `*const T` creates mutable aliasing, which is UB.\n\n## Bad Example\n\n```rust\n// DON'T: Cast *const to *mut\nfn bad_mutate(value: &i32) {\n    let ptr = value as *const i32 as *mut i32;\n    unsafe { *ptr = 42; }  // UB: Mutating through &\n}\n\n// DON'T: Use transmute to convert\nfn bad_transmute(value: &i32) -> &mut i32 {\n    unsafe { std::mem::transmute(value) }  // UB!\n}\n\n// DON'T: \"I know this is the only reference\"\nfn bad_claim(value: &i32) {\n    // Even if you \"know\" there's only one reference,\n    // the compiler assumes & means no mutation\n    let ptr = value as *const i32 as *mut i32;\n    unsafe { *ptr += 1; }  // Still UB - compiler may optimize incorrectly\n}\n```\n\n## Good Example\n\n```rust\n// DO: Take &mut if you need to mutate\nfn good_mutate(value: &mut i32) {\n    *value = 42;\n}\n\n// DO: Use interior mutability\nuse std::cell::{Cell, RefCell, UnsafeCell};\n\nstruct Mutable {\n    value: Cell<i32>,  // Interior mutability\n}\n\nimpl Mutable {\n    fn modify(&self) {\n        self.value.set(42);  // OK: Cell provides interior mutability\n    }\n}\n\n// DO: Use UnsafeCell if you need raw unsafe interior mutability\nstruct RawMutable {\n    value: UnsafeCell<i32>,\n}\n\nimpl RawMutable {\n    fn modify(&self) {\n        // SAFETY: We ensure exclusive access through external means\n        unsafe { *self.value.get() = 42; }\n    }\n}\n```\n\n## The UnsafeCell Exception\n\n`UnsafeCell<T>` is the ONLY valid way to get `*mut T` from `&self`:\n\n```rust\nuse std::cell::UnsafeCell;\n\npub struct MyMutex<T> {\n    data: UnsafeCell<T>,\n    // ... lock state\n}\n\nimpl<T> MyMutex<T> {\n    pub fn lock(&self) -> Guard<'_, T> {\n        // acquire lock...\n\n        // SAFETY: UnsafeCell allows this, lock ensures exclusivity\n        Guard { data: unsafe { &mut *self.data.get() } }\n    }\n}\n```\n\n## Why This Is Always UB\n\nThe compiler assumes:\n1. `&T` means no mutation will occur\n2. Multiple `&T` can exist simultaneously\n3. Optimizations can be made based on these assumptions\n\nWhen you mutate through cast pointer:\n1. Other `&T` references see inconsistent values\n2. Compiler may cache/eliminate reads\n3. Results are unpredictable\n\n## Checklist\n\n- [ ] Am I trying to mutate through `&`?\n- [ ] Should I use `&mut` instead?\n- [ ] Should I use `Cell`, `RefCell`, or `UnsafeCell`?\n- [ ] Is the original type designed for interior mutability?\n\n## Related Rules\n\n- `safety-08`: Mutable return from immutable parameter is wrong\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/ptr-06-prefer-cast.md": "---\nid: ptr-06\noriginal_id: G.UNS.PTR.03\nlevel: G\nimpact: LOW\nclippy: ptr_as_ptr\n---\n\n# Prefer pointer::cast Over `as` for Pointer Casting\n\n## Summary\n\nUse the `cast()` method instead of `as` for pointer type conversions. It's clearer and prevents accidental provenance loss.\n\n## Rationale\n\n- `cast()` only changes the pointed-to type, not pointer properties\n- `as` can accidentally convert to integer and back, losing provenance\n- `cast()` is more explicit about intent\n- Better tooling support (clippy, miri)\n\n## Bad Example\n\n```rust\n// DON'T: Use `as` for pointer casts\nfn bad_cast(ptr: *const u8) -> *const i32 {\n    ptr as *const i32  // Works, but less clear\n}\n\n// DON'T: Accidental provenance loss\nfn bad_roundtrip(ptr: *const u8) -> *const u8 {\n    let addr = ptr as usize;   // Converts to integer\n    addr as *const u8          // Loses provenance information!\n}\n\n// DON'T: Multiple `as` casts in chain\nfn bad_chain(ptr: *const u8) -> *mut i32 {\n    ptr as *mut u8 as *mut i32  // Hard to follow\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use cast() for pointer type changes\nfn good_cast(ptr: *const u8) -> *const i32 {\n    ptr.cast::<i32>()\n}\n\n// DO: Use cast_mut() for const-to-mut (when valid)\nfn good_cast_mut(ptr: *const u8) -> *mut u8 {\n    ptr.cast_mut()  // Only use when mutation is valid!\n}\n\n// DO: Use cast_const() for mut-to-const\nfn good_cast_const(ptr: *mut u8) -> *const u8 {\n    ptr.cast_const()\n}\n\n// DO: Chain casts clearly\nfn good_chain(ptr: *const u8) -> *mut i32 {\n    ptr.cast_mut().cast::<i32>()\n}\n\n// DO: Use with_addr() for address manipulation (nightly)\n#[cfg(feature = \"strict_provenance\")]\nfn good_provenance(ptr: *const u8, new_addr: usize) -> *const u8 {\n    ptr.with_addr(new_addr)  // Preserves provenance\n}\n```\n\n## Pointer Method Reference\n\n| Method | From | To | Notes |\n|--------|------|-----|-------|\n| `.cast::<U>()` | `*T` | `*U` | Changes pointee type |\n| `.cast_mut()` | `*const T` | `*mut T` | Removes const |\n| `.cast_const()` | `*mut T` | `*const T` | Adds const |\n| `.addr()` | `*T` | `usize` | Gets address (nightly) |\n| `.with_addr(usize)` | `*T` | `*T` | Changes address, keeps provenance |\n| `.map_addr(fn)` | `*T` | `*T` | Transforms address |\n\n## Provenance Considerations\n\n```rust\n// Provenance = permission to access memory\n\n// BAD: Loses provenance\nlet ptr: *const u8 = &data as *const u8;\nlet addr = ptr as usize;\nlet ptr2 = addr as *const u8;  // ptr2 has no provenance!\n\n// GOOD: Preserves provenance (nightly strict_provenance)\nlet ptr2 = ptr.with_addr(addr);  // Still has permission\n\n// GOOD: Use expose/from_exposed when provenance must cross integer\nlet addr = ptr.expose_addr();  // \"Expose\" the provenance\nlet ptr2 = std::ptr::from_exposed_addr(addr);  // Recover it\n```\n\n## Checklist\n\n- [ ] Am I using `as` where `cast()` would be clearer?\n- [ ] Am I accidentally converting through `usize`?\n- [ ] Do I need to preserve provenance?\n\n## Related Rules\n\n- `ptr-04`: Alignment considerations when casting\n- `ptr-05`: Don't convert const to mut improperly\n",
        "skills/unsafe-checker/rules/safety-01-panic-safety.md": "---\nid: safety-01\noriginal_id: P.UNS.SAS.01\nlevel: P\nimpact: CRITICAL\nclippy: panic_in_result_fn\n---\n\n# Be Aware of Memory Safety Issues from Panics\n\n## Summary\n\nPanics in unsafe code can leave data structures in an inconsistent state, leading to undefined behavior when the panic is caught.\n\n## Rationale\n\nWhen a panic occurs, Rust unwinds the stack and runs destructors. If unsafe code has partially modified data, the destructors may observe invalid state.\n\n## Bad Example\n\n```rust\n// DON'T: Panic can leave Vec in invalid state\nimpl<T> MyVec<T> {\n    pub fn push(&mut self, value: T) {\n        if self.len == self.cap {\n            self.grow();  // Might panic during allocation\n        }\n\n        unsafe {\n            // If Clone::clone() panics after incrementing len,\n            // drop will try to drop uninitialized memory\n            self.len += 1;\n            ptr::write(self.ptr.add(self.len - 1), value.clone());\n        }\n    }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Ensure panic safety by ordering operations correctly\nimpl<T> MyVec<T> {\n    pub fn push(&mut self, value: T) {\n        if self.len == self.cap {\n            self.grow();\n        }\n\n        unsafe {\n            // Write first, then increment len\n            // If write somehow panics, len is still valid\n            ptr::write(self.ptr.add(self.len), value);\n            self.len += 1;  // Only increment after successful write\n        }\n    }\n}\n\n// DO: Use guards for complex operations\nimpl<T: Clone> MyVec<T> {\n    pub fn extend_from_slice(&mut self, slice: &[T]) {\n        self.reserve(slice.len());\n\n        let mut guard = PanicGuard {\n            vec: self,\n            initialized: 0,\n        };\n\n        for item in slice {\n            unsafe {\n                ptr::write(guard.vec.ptr.add(guard.vec.len + guard.initialized), item.clone());\n                guard.initialized += 1;\n            }\n        }\n\n        // Success - update len and forget guard\n        self.len += guard.initialized;\n        std::mem::forget(guard);\n    }\n}\n\nstruct PanicGuard<'a, T> {\n    vec: &'a mut MyVec<T>,\n    initialized: usize,\n}\n\nimpl<T> Drop for PanicGuard<'_, T> {\n    fn drop(&mut self) {\n        // Clean up partially initialized elements on panic\n        unsafe {\n            for i in 0..self.initialized {\n                ptr::drop_in_place(self.vec.ptr.add(self.vec.len + i));\n            }\n        }\n    }\n}\n```\n\n## Key Patterns\n\n1. **Update bookkeeping after operations**: Increment length only after writing\n2. **Use panic guards**: RAII types that clean up on panic\n3. **Order operations carefully**: Ensure invariants hold if panic occurs at any point\n\n## Checklist\n\n- [ ] What happens if this code panics at each line?\n- [ ] Are all invariants maintained if we unwind from here?\n- [ ] Do I need a panic guard for cleanup?\n\n## Related Rules\n\n- `safety-04`: Avoid double-free from panic safety issues\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/safety-02-verify-invariants.md": "---\nid: safety-02\noriginal_id: P.UNS.SAS.02\nlevel: P\nimpact: CRITICAL\n---\n\n# Unsafe Code Authors Must Verify Safety Invariants\n\n## Summary\n\nWhen writing unsafe code, you are taking responsibility for upholding all safety invariants that the compiler normally enforces.\n\n## Rationale\n\nUnsafe blocks don't disable safety requirements - they transfer responsibility from the compiler to the programmer. You must manually verify what the compiler normally checks.\n\n## Safety Invariants to Verify\n\n1. **Pointer validity**: Non-null, aligned, points to valid memory\n2. **Aliasing**: No mutable aliasing (two &mut to same memory)\n3. **Initialization**: Memory is initialized before read\n4. **Lifetime**: References don't outlive their referents\n5. **Type validity**: Data matches the expected type's invariants\n6. **Thread safety**: Proper synchronization for concurrent access\n\n## Bad Example\n\n```rust\n// DON'T: Blindly trust inputs\nunsafe fn process(ptr: *const Data, len: usize) {\n    for i in 0..len {\n        // No verification that ptr is valid or len is correct!\n        let item = &*ptr.add(i);\n        process_item(item);\n    }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Document and verify invariants\n/// Processes a slice of Data items.\n///\n/// # Safety\n///\n/// - `ptr` must be non-null and aligned for `Data`\n/// - `ptr` must point to `len` consecutive initialized `Data` items\n/// - The memory must not be mutated during this call\n/// - `len * size_of::<Data>()` must not overflow `isize::MAX`\nunsafe fn process(ptr: *const Data, len: usize) {\n    debug_assert!(!ptr.is_null(), \"ptr must not be null\");\n    debug_assert!(ptr.is_aligned(), \"ptr must be aligned\");\n\n    for i in 0..len {\n        // SAFETY: Caller guarantees ptr points to len valid items\n        let item = &*ptr.add(i);\n        process_item(item);\n    }\n}\n\n// DO: Provide safe wrapper when possible\nfn process_slice(data: &[Data]) {\n    // SAFETY: slice guarantees all invariants\n    unsafe { process(data.as_ptr(), data.len()) }\n}\n```\n\n## Invariant Documentation Template\n\n```rust\n/// # Safety\n///\n/// The caller must ensure that:\n/// - [List each invariant]\n/// - [Explain why each matters]\n```\n\n## Checklist\n\n- [ ] Have I listed all safety invariants?\n- [ ] Can I prove each invariant holds at the call site?\n- [ ] Have I added debug assertions where possible?\n- [ ] Have I documented invariants in /// # Safety section?\n\n## Related Rules\n\n- `safety-09`: Add SAFETY comment before any unsafe block\n- `safety-10`: Add Safety section in docs for public unsafe functions\n",
        "skills/unsafe-checker/rules/safety-03-no-uninit-api.md": "---\nid: safety-03\noriginal_id: P.UNS.SAS.03\nlevel: P\nimpact: CRITICAL\nclippy: uninit_assumed_init\n---\n\n# Do Not Expose Uninitialized Memory in Public APIs\n\n## Summary\n\nPublic APIs must never return or expose uninitialized memory to callers.\n\n## Rationale\n\nReading uninitialized memory is undefined behavior in Rust. Safe code should never be able to access uninitialized memory through your API.\n\n## Bad Example\n\n```rust\n// DON'T: Expose uninitialized memory\npub struct Buffer {\n    data: [u8; 1024],\n    len: usize,\n}\n\nimpl Buffer {\n    pub fn new() -> Self {\n        // BAD: data is uninitialized\n        unsafe {\n            Self {\n                data: std::mem::MaybeUninit::uninit().assume_init(),\n                len: 0,\n            }\n        }\n    }\n\n    // BAD: Returns reference to potentially uninitialized data\n    pub fn as_slice(&self) -> &[u8] {\n        &self.data[..self.len]  // What if len > initialized portion?\n    }\n}\n```\n\n## Good Example\n\n```rust\nuse std::mem::MaybeUninit;\n\n// DO: Use MaybeUninit properly and only expose initialized data\npub struct Buffer {\n    data: Box<[MaybeUninit<u8>; 1024]>,\n    len: usize,  // Invariant: data[0..len] is initialized\n}\n\nimpl Buffer {\n    pub fn new() -> Self {\n        Self {\n            // MaybeUninit doesn't require initialization\n            data: Box::new([MaybeUninit::uninit(); 1024]),\n            len: 0,\n        }\n    }\n\n    pub fn push(&mut self, byte: u8) {\n        if self.len < 1024 {\n            self.data[self.len].write(byte);\n            self.len += 1;\n        }\n    }\n\n    // Only returns initialized portion\n    pub fn as_slice(&self) -> &[u8] {\n        // SAFETY: self.len bytes are initialized (invariant)\n        unsafe {\n            std::slice::from_raw_parts(\n                self.data.as_ptr() as *const u8,\n                self.len\n            )\n        }\n    }\n}\n\nimpl Drop for Buffer {\n    fn drop(&mut self) {\n        // Only drop initialized elements\n        // For u8 this is a no-op, but important for Drop types\n    }\n}\n```\n\n## Patterns for Uninitialized Memory\n\n```rust\n// Pattern 1: MaybeUninit for delayed initialization\nlet mut value: MaybeUninit<ExpensiveType> = MaybeUninit::uninit();\ninitialize_expensive(&mut value);\nlet value = unsafe { value.assume_init() };\n\n// Pattern 2: Vec::with_capacity for growable buffers\nlet mut vec = Vec::with_capacity(100);\n// vec.len() is 0, capacity is 100\n// No uninitialized memory is accessible\n\n// Pattern 3: Box::new_uninit (nightly)\nlet mut boxed = Box::<[u8; 1024]>::new_uninit();\nboxed.write([0u8; 1024]);\nlet boxed = unsafe { boxed.assume_init() };\n```\n\n## Checklist\n\n- [ ] Does my API ever return references to uninitialized memory?\n- [ ] Are length/capacity invariants properly maintained?\n- [ ] Is MaybeUninit used instead of transmute for uninitialized data?\n\n## Related Rules\n\n- `mem-06`: Use MaybeUninit<T> for uninitialized memory\n- `safety-01`: Panic safety with partial initialization\n",
        "skills/unsafe-checker/rules/safety-04-double-free.md": "---\nid: safety-04\noriginal_id: P.UNS.SAS.04\nlevel: P\nimpact: CRITICAL\n---\n\n# Avoid Double-Free from Panic Safety Issues\n\n## Summary\n\nEnsure that resources are not freed twice, especially when panics can occur during operations.\n\n## Rationale\n\nDouble-free is undefined behavior. Panics during unsafe operations can cause destructors to run on already-freed or partially-constructed data.\n\n## Bad Example\n\n```rust\n// DON'T: Potential double-free on panic\nimpl<T> MyVec<T> {\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            self.len -= 1;\n            unsafe {\n                // If something panics after this read but before return,\n                // Drop will try to drop this element again\n                Some(ptr::read(self.ptr.add(self.len)))\n            }\n        }\n    }\n}\n\n// DON'T: Double-free with ManuallyDrop misuse\nfn bad_swap<T>(a: &mut T, b: &mut T) {\n    unsafe {\n        let tmp = ptr::read(a);\n        ptr::write(a, ptr::read(b));  // If this panics, tmp leaks\n        ptr::write(b, tmp);\n    }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use std::mem::take or swap\nfn good_swap<T: Default>(a: &mut T, b: &mut T) {\n    std::mem::swap(a, b);  // Safe and correct\n}\n\n// DO: Use ManuallyDrop for panic safety\nuse std::mem::ManuallyDrop;\n\nimpl<T> MyVec<T> {\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            self.len -= 1;  // Decrement first\n            unsafe {\n                // SAFETY: len was decremented, so this slot won't be\n                // dropped again by Vec's Drop impl\n                Some(ptr::read(self.ptr.add(self.len)))\n            }\n        }\n    }\n}\n\n// DO: Use scopeguard or manual cleanup\nfn safe_operation<T: Clone>(data: &mut [T], source: &[T]) {\n    // Track what we've written for cleanup on panic\n    let mut written = 0;\n\n    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n        for (i, item) in source.iter().enumerate() {\n            data[i] = item.clone();\n            written = i + 1;\n        }\n    }));\n\n    if result.is_err() {\n        // Clean up on panic (if T needs special handling)\n        // In this case, safe code handles it automatically\n    }\n}\n```\n\n## Patterns to Avoid Double-Free\n\n1. **Decrement length before reading**: Vec's Drop won't touch the read element\n2. **Use ManuallyDrop**: Explicitly control when Drop runs\n3. **Use std::mem::replace/swap**: Safe alternatives for move semantics\n4. **Panic guards**: RAII cleanup on unwind\n\n## Checklist\n\n- [ ] After reading memory, is it marked as \"moved\"?\n- [ ] Will Drop run on this memory? Should it?\n- [ ] What happens if this code panics at each point?\n- [ ] Are length/count bookkeeping updates ordered correctly?\n\n## Related Rules\n\n- `safety-01`: Panic safety in unsafe code\n- `ptr-01`: Don't share raw pointers across threads\n",
        "skills/unsafe-checker/rules/safety-05-send-sync.md": "---\nid: safety-05\noriginal_id: P.UNS.SAS.05\nlevel: P\nimpact: CRITICAL\nclippy: non_send_fields_in_send_ty\n---\n\n# Consider Safety When Manually Implementing Auto Traits\n\n## Summary\n\nWhen manually implementing `Send` or `Sync`, you must ensure thread safety invariants are upheld.\n\n## Rationale\n\n`Send` and `Sync` are unsafe traits because incorrect implementations cause data races, which are undefined behavior. The compiler auto-implements them conservatively, but manual implementations require careful analysis.\n\n## Trait Meanings\n\n- **`Send`**: Safe to transfer ownership to another thread\n- **`Sync`**: Safe to share references (`&T`) between threads (i.e., `&T: Send`)\n\n## Bad Example\n\n```rust\n// DON'T: Unsafe Send/Sync without thread safety\nstruct NotThreadSafe {\n    ptr: *mut i32,  // Raw pointers are not Send/Sync\n}\n\n// BAD: This is unsound!\nunsafe impl Send for NotThreadSafe {}\nunsafe impl Sync for NotThreadSafe {}\n\n// DON'T: Rc-like type with unsafe Sync\nstruct MyRc<T> {\n    ptr: *mut RcInner<T>,\n}\n\nstruct RcInner<T> {\n    count: usize,  // Not atomic!\n    data: T,\n}\n\n// BAD: count is not atomic, concurrent access is UB\nunsafe impl<T: Send> Sync for MyRc<T> {}\n```\n\n## Good Example\n\n```rust\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::ptr::NonNull;\n\n// DO: Use atomic operations for thread-safe reference counting\nstruct MyArc<T> {\n    ptr: NonNull<ArcInner<T>>,\n}\n\nstruct ArcInner<T> {\n    count: AtomicUsize,  // Atomic for thread safety\n    data: T,\n}\n\n// SAFETY: The data is behind atomic reference counting,\n// and T: Send + Sync ensures the data itself is thread-safe\nunsafe impl<T: Send + Sync> Send for MyArc<T> {}\nunsafe impl<T: Send + Sync> Sync for MyArc<T> {}\n\n// DO: Document why it's safe\n/// A thread-safe wrapper around a raw file descriptor.\n///\n/// # Safety\n///\n/// The file descriptor is valid for the lifetime of this struct,\n/// and file descriptors are safe to use from any thread.\nstruct ThreadSafeFd {\n    fd: std::os::unix::io::RawFd,\n}\n\n// SAFETY: File descriptors are just integers and can be used\n// from any thread. The actual I/O operations are thread-safe\n// at the OS level.\nunsafe impl Send for ThreadSafeFd {}\nunsafe impl Sync for ThreadSafeFd {}\n```\n\n## Decision Tree\n\n```\nDoes your type contain:\n  - Raw pointers? ‚Üí Probably not auto Send/Sync\n  - Rc/RefCell? ‚Üí Not Sync (Rc not Send either)\n  - Cell/UnsafeCell? ‚Üí Not Sync\n  - Interior mutability? ‚Üí Needs synchronization for Sync\n\nTo manually implement:\n  - Send: Can another thread safely drop this?\n  - Sync: Can multiple threads safely call &self methods?\n```\n\n## Checklist\n\n- [ ] Does my type contain any non-Send/Sync fields?\n- [ ] Is interior mutability properly synchronized (Mutex, atomic)?\n- [ ] Would concurrent access cause data races?\n- [ ] Have I documented why the implementation is safe?\n\n## Related Rules\n\n- `ptr-01`: Don't share raw pointers across threads\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/safety-06-no-raw-ptr-api.md": "---\nid: safety-06\noriginal_id: P.UNS.SAS.06\nlevel: P\nimpact: HIGH\n---\n\n# Do Not Expose Raw Pointers in Public APIs\n\n## Summary\n\nPublic APIs should use safe abstractions (references, slices, smart pointers) instead of exposing raw pointers.\n\n## Rationale\n\nRaw pointers bypass Rust's safety guarantees. Exposing them in public APIs forces users into unsafe code and makes it easy to create undefined behavior.\n\n## Bad Example\n\n```rust\n// DON'T: Expose raw pointers in public API\npub struct Buffer {\n    data: *mut u8,\n    len: usize,\n}\n\nimpl Buffer {\n    // BAD: Returns raw pointer\n    pub fn as_ptr(&self) -> *const u8 {\n        self.data\n    }\n\n    // BAD: Takes raw pointer as input\n    pub fn from_ptr(ptr: *mut u8, len: usize) -> Self {\n        Self { data: ptr, len }\n    }\n\n    // BAD: Exposes internal pointer mutably\n    pub fn as_mut_ptr(&mut self) -> *mut u8 {\n        self.data\n    }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use safe abstractions\npub struct Buffer {\n    data: Vec<u8>,\n}\n\nimpl Buffer {\n    // Returns a safe reference\n    pub fn as_slice(&self) -> &[u8] {\n        &self.data\n    }\n\n    // Takes safe input\n    pub fn from_slice(data: &[u8]) -> Self {\n        Self { data: data.to_vec() }\n    }\n\n    // Mutable access through safe reference\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        &mut self.data\n    }\n}\n\n// DO: If raw pointers are needed, provide unsafe API with documentation\nimpl Buffer {\n    /// Returns a pointer to the buffer's data.\n    ///\n    /// # Safety\n    ///\n    /// The pointer is valid for `self.len()` bytes and must not be\n    /// used after the Buffer is dropped or reallocated.\n    pub fn as_ptr(&self) -> *const u8 {\n        self.data.as_ptr()\n    }\n\n    /// Creates a Buffer from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// - `ptr` must point to `len` valid bytes\n    /// - The memory must be allocated with the global allocator\n    /// - Caller transfers ownership of the memory to Buffer\n    pub unsafe fn from_raw_parts(ptr: *mut u8, len: usize, cap: usize) -> Self {\n        Self {\n            data: Vec::from_raw_parts(ptr, len, cap)\n        }\n    }\n}\n```\n\n## Patterns for Safe Pointer APIs\n\n```rust\n// Pattern 1: Use NonNull for internal pointers\nuse std::ptr::NonNull;\n\npub struct MyBox<T> {\n    ptr: NonNull<T>,  // Internal use only\n}\n\nimpl<T> MyBox<T> {\n    // Safe public API\n    pub fn get(&self) -> &T {\n        // SAFETY: ptr is always valid while MyBox exists\n        unsafe { self.ptr.as_ref() }\n    }\n}\n\n// Pattern 2: Callback-based access\nimpl Buffer {\n    // User can work with pointer in controlled context\n    pub fn with_ptr<F, R>(&self, f: F) -> R\n    where\n        F: FnOnce(*const u8, usize) -> R,\n    {\n        f(self.data.as_ptr(), self.data.len())\n    }\n}\n```\n\n## Checklist\n\n- [ ] Can this API use references instead of pointers?\n- [ ] Can this API use slices instead of pointer + length?\n- [ ] If pointers are necessary, is the API marked `unsafe`?\n- [ ] Are safety requirements documented?\n\n## Related Rules\n\n- `general-03`: Don't create aliases for unsafe items\n- `safety-10`: Document safety requirements for public unsafe functions\n",
        "skills/unsafe-checker/rules/safety-07-unsafe-pair.md": "---\nid: safety-07\noriginal_id: P.UNS.SAS.07\nlevel: P\nimpact: MEDIUM\n---\n\n# Provide Unsafe Counterparts for Performance Alongside Safe Methods\n\n## Summary\n\nWhen providing performance-critical operations that skip safety checks, offer both a safe checked version and an unsafe unchecked version.\n\n## Rationale\n\nUsers who need maximum performance can opt into unsafe, while others get safety by default. This follows the \"safe by default, unsafe opt-in\" principle.\n\n## Bad Example\n\n```rust\n// DON'T: Only provide unsafe version\nimpl<T> MySlice<T> {\n    /// Gets an element by index.\n    ///\n    /// # Safety\n    /// Index must be in bounds.\n    pub unsafe fn get(&self, index: usize) -> &T {\n        &*self.ptr.add(index)\n    }\n}\n\n// DON'T: Only provide checked version when performance matters\nimpl<T> MySlice<T> {\n    pub fn get(&self, index: usize) -> Option<&T> {\n        if index < self.len {\n            Some(unsafe { &*self.ptr.add(index) })\n        } else {\n            None\n        }\n    }\n    // Missing: get_unchecked for performance-critical code\n}\n```\n\n## Good Example\n\n```rust\n// DO: Provide both versions\nimpl<T> MySlice<T> {\n    /// Gets an element by index, returning `None` if out of bounds.\n    #[inline]\n    pub fn get(&self, index: usize) -> Option<&T> {\n        if index < self.len {\n            // SAFETY: We just verified index < len\n            Some(unsafe { self.get_unchecked(index) })\n        } else {\n            None\n        }\n    }\n\n    /// Gets an element by index without bounds checking.\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with an out-of-bounds index is undefined behavior.\n    #[inline]\n    pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n        debug_assert!(index < self.len, \"index out of bounds\");\n        &*self.ptr.add(index)\n    }\n\n    /// Gets an element, panicking if out of bounds.\n    #[inline]\n    pub fn get_or_panic(&self, index: usize) -> &T {\n        assert!(index < self.len, \"index {} out of bounds for len {}\", index, self.len);\n        // SAFETY: We just asserted index < len\n        unsafe { self.get_unchecked(index) }\n    }\n}\n```\n\n## Standard Library Patterns\n\n| Safe Method | Unsafe Counterpart |\n|-------------|-------------------|\n| `slice.get(i)` | `slice.get_unchecked(i)` |\n| `str.chars().nth(i)` | `str.get_unchecked(range)` |\n| `vec.pop()` | `vec.set_len()` + `ptr::read` |\n| `String::from_utf8()` | `String::from_utf8_unchecked()` |\n\n## Naming Conventions\n\n- Safe: `method_name()`\n- Unsafe: `method_name_unchecked()`\n- Or: `get()` vs `get_unchecked()`\n\n## Checklist\n\n- [ ] Does my safe method have an unsafe counterpart for hot paths?\n- [ ] Does my unsafe method have a safe alternative for normal use?\n- [ ] Are both methods documented with their trade-offs?\n- [ ] Does the unsafe version include debug assertions?\n\n## Related Rules\n\n- `general-02`: Don't blindly use unsafe for performance\n- `safety-09`: Add SAFETY comments\n",
        "skills/unsafe-checker/rules/safety-08-no-mut-from-immut.md": "---\nid: safety-08\noriginal_id: P.UNS.SAS.08\nlevel: P\nimpact: CRITICAL\nclippy: mut_from_ref\n---\n\n# Mutable Return from Immutable Parameter is Wrong\n\n## Summary\n\nA function taking `&self` or `&T` must not return `&mut T` to the same data without interior mutability.\n\n## Rationale\n\nReturning `&mut` from `&` violates Rust's aliasing rules. The caller has an immutable borrow, so they can create additional `&` references. Returning `&mut` creates mutable aliasing, which is undefined behavior.\n\n## Bad Example\n\n```rust\n// DON'T: Return &mut from &self\nstruct Container {\n    data: i32,\n}\n\nimpl Container {\n    // WRONG: This is undefined behavior!\n    pub fn get_mut(&self) -> &mut i32 {\n        unsafe {\n            // Creating &mut from & is ALWAYS wrong\n            &mut *(&self.data as *const i32 as *mut i32)\n        }\n    }\n}\n\n// DON'T: Transmute & to &mut\nfn bad_transmute<T>(reference: &T) -> &mut T {\n    unsafe { std::mem::transmute(reference) }  // UB!\n}\n```\n\n## Good Example\n\n```rust\nuse std::cell::{Cell, RefCell, UnsafeCell};\n\n// DO: Use interior mutability types\nstruct Container {\n    data: Cell<i32>,          // For Copy types\n    complex: RefCell<String>, // For non-Copy with runtime checks\n}\n\nimpl Container {\n    pub fn get(&self) -> i32 {\n        self.data.get()\n    }\n\n    pub fn set(&self, value: i32) {\n        self.data.set(value);\n    }\n\n    pub fn modify_complex(&self, f: impl FnOnce(&mut String)) {\n        f(&mut self.complex.borrow_mut());\n    }\n}\n\n// DO: Use UnsafeCell for custom interior mutability\nstruct MyMutex<T> {\n    locked: std::sync::atomic::AtomicBool,\n    data: UnsafeCell<T>,\n}\n\nimpl<T> MyMutex<T> {\n    pub fn lock(&self) -> MutexGuard<'_, T> {\n        // Acquire lock...\n        MutexGuard { mutex: self }\n    }\n}\n\nstruct MutexGuard<'a, T> {\n    mutex: &'a MyMutex<T>,\n}\n\nimpl<T> std::ops::DerefMut for MutexGuard<'_, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        // SAFETY: We hold the lock, so exclusive access is guaranteed\n        unsafe { &mut *self.mutex.data.get() }\n    }\n}\n```\n\n## The Only Valid Pattern\n\nThe ONLY way to get `&mut` from `&` is through `UnsafeCell`:\n\n```rust\nuse std::cell::UnsafeCell;\n\nstruct ValidInteriorMut {\n    data: UnsafeCell<i32>,\n}\n\nimpl ValidInteriorMut {\n    // This is sound ONLY because UnsafeCell opts out of aliasing rules\n    // AND we guarantee exclusive access (e.g., through a lock)\n    pub fn get_mut(&self) -> &mut i32 {\n        // Must ensure no other references exist!\n        unsafe { &mut *self.data.get() }\n    }\n}\n```\n\n## Checklist\n\n- [ ] Am I trying to return &mut from a & method?\n- [ ] If yes, am I using UnsafeCell or a type built on it?\n- [ ] Am I guaranteeing exclusive access before creating &mut?\n- [ ] Would Cell, RefCell, or Mutex solve my problem safely?\n\n## Related Rules\n\n- `ptr-05`: Don't manually convert *const to *mut\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/safety-09-safety-comment.md": "---\nid: safety-09\noriginal_id: P.UNS.SAS.09\nlevel: P\nimpact: CRITICAL\nclippy: undocumented_unsafe_blocks\n---\n\n# Add SAFETY Comment Before Any Unsafe Block\n\n## Summary\n\nEvery `unsafe` block or `unsafe impl` must have a `// SAFETY:` comment explaining why the operation is safe.\n\n## Rationale\n\nSAFETY comments force the author to think about invariants and help reviewers verify correctness. They serve as documentation for future maintainers.\n\n## Bad Example\n\n```rust\n// DON'T: Unsafe without explanation\nfn get_unchecked(slice: &[i32], index: usize) -> i32 {\n    unsafe { *slice.get_unchecked(index) }\n}\n\n// DON'T: Vague or unhelpful comments\nfn bad_comments(ptr: *const i32) -> i32 {\n    // This is unsafe\n    unsafe { *ptr }\n\n    // Trust me\n    unsafe { *ptr }\n\n    // Safe because I know what I'm doing\n    unsafe { *ptr }\n}\n```\n\n## Good Example\n\n```rust\n// DO: Explain the safety invariant\nfn get_unchecked(slice: &[i32], index: usize) -> i32 {\n    // SAFETY: Caller guarantees index < slice.len()\n    unsafe { *slice.get_unchecked(index) }\n}\n\n// DO: Be specific about what makes it safe\nfn read_header(buffer: &[u8]) -> Header {\n    assert!(buffer.len() >= std::mem::size_of::<Header>());\n\n    // SAFETY:\n    // - buffer.len() >= size_of::<Header>() (asserted above)\n    // - buffer is aligned for u8, which is compatible with any alignment\n    // - Header is #[repr(C)] and has no padding requirements\n    unsafe {\n        std::ptr::read_unaligned(buffer.as_ptr() as *const Header)\n    }\n}\n\n// DO: Document unsafe impl\nstruct MySendType(*mut i32);\n\n// SAFETY: The pointer is to thread-local storage that is only accessed\n// from the owning thread. MySendType is only sent when the TLS slot\n// is being transferred between threads with proper synchronization.\nunsafe impl Send for MySendType {}\n\n// DO: Multi-line for complex invariants\nfn complex_operation(data: &mut [u8], ranges: &[(usize, usize)]) {\n    for &(start, end) in ranges {\n        // SAFETY:\n        // 1. All ranges were validated to be within data.len()\n        //    in the calling function `validate_ranges()`\n        // 2. Ranges are non-overlapping (invariant of RangeSet)\n        // 3. We have &mut access to data, so no aliasing\n        unsafe {\n            let ptr = data.as_mut_ptr().add(start);\n            std::ptr::write_bytes(ptr, 0, end - start);\n        }\n    }\n}\n```\n\n## SAFETY Comment Format\n\n```rust\n// SAFETY: <brief explanation>\n\n// Or for complex cases:\n// SAFETY:\n// - Invariant 1: explanation\n// - Invariant 2: explanation\n// - Why this is upheld: explanation\n```\n\n## What to Include\n\n1. **What invariants must hold** for this to be safe\n2. **Why those invariants hold** at this specific call site\n3. **What could go wrong** if the invariants were violated (optional but helpful)\n\n## Clippy Configuration\n\n```toml\n# clippy.toml\naccept-comment-above-statement = true\naccept-comment-above-attributes = true\n```\n\n## Checklist\n\n- [ ] Does every unsafe block have a SAFETY comment?\n- [ ] Does the comment explain WHY it's safe, not just WHAT it does?\n- [ ] Are all relevant invariants mentioned?\n- [ ] Would a reviewer understand the safety argument?\n\n## Related Rules\n\n- `safety-02`: Verify safety invariants\n- `safety-10`: Add Safety section in docs for public unsafe functions\n",
        "skills/unsafe-checker/rules/safety-10-safety-doc.md": "---\nid: safety-10\noriginal_id: G.UNS.SAS.01\nlevel: G\nimpact: HIGH\nclippy: missing_safety_doc\n---\n\n# Add Safety Section in Docs for Public Unsafe Functions\n\n## Summary\n\nPublic `unsafe` functions must have a `# Safety` section in their documentation explaining the caller's obligations.\n\n## Rationale\n\nUnlike SAFETY comments (which explain why an unsafe block is sound), `# Safety` docs tell callers what they must guarantee. Without this, users cannot safely call the function.\n\n## Bad Example\n\n```rust\n// DON'T: Unsafe function without safety docs\npub unsafe fn process_buffer(ptr: *const u8, len: usize) {\n    // ...\n}\n\n// DON'T: Safety docs that don't explain requirements\n/// Processes a buffer.\n///\n/// This function is unsafe.  // Not helpful!\npub unsafe fn process_buffer(ptr: *const u8, len: usize) {\n    // ...\n}\n```\n\n## Good Example\n\n```rust\n/// Processes a buffer of bytes.\n///\n/// # Safety\n///\n/// The caller must ensure that:\n///\n/// - `ptr` is non-null and properly aligned for `u8`\n/// - `ptr` points to at least `len` consecutive, initialized bytes\n/// - The memory referenced by `ptr` is not mutated during this call\n/// - `len` does not exceed `isize::MAX`\n///\n/// # Examples\n///\n/// ```\n/// let data = [1u8, 2, 3, 4];\n/// // SAFETY: data is a valid slice, we pass its pointer and length\n/// unsafe { process_buffer(data.as_ptr(), data.len()) };\n/// ```\npub unsafe fn process_buffer(ptr: *const u8, len: usize) {\n    // ...\n}\n\n/// Creates a `Vec<T>` from raw parts.\n///\n/// # Safety\n///\n/// This is highly unsafe due to the number of invariants that must\n/// be upheld by the caller:\n///\n/// * `ptr` must have been allocated via the global allocator\n/// * `T` must have the same alignment as the original allocation\n/// * `capacity` must be the capacity the pointer was allocated with\n/// * `length` must be less than or equal to `capacity`\n/// * The first `length` values must be properly initialized\n/// * The allocated memory must not be used elsewhere\n///\n/// Violating these may cause undefined behavior including\n/// use-after-free, double-free, and memory corruption.\npub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n    // ...\n}\n```\n\n## Safety Documentation Template\n\n```rust\n/// Brief description of what the function does.\n///\n/// # Safety\n///\n/// The caller must ensure that:\n///\n/// - Requirement 1: detailed explanation\n/// - Requirement 2: detailed explanation\n///\n/// # Panics (if applicable)\n///\n/// Panics if...\n///\n/// # Examples\n///\n/// ```\n/// // SAFETY: explanation of why this call is safe\n/// unsafe { function_name(...) };\n/// ```\n```\n\n## What to Document\n\n| Category | Example |\n|----------|---------|\n| Pointer validity | \"ptr must be non-null and aligned\" |\n| Memory state | \"must point to initialized memory\" |\n| Aliasing | \"no other references to this memory may exist\" |\n| Lifetime | \"pointer must be valid for the duration of the call\" |\n| Thread safety | \"must not be called concurrently with...\" |\n| Invariants | \"len must not exceed isize::MAX\" |\n\n## Checklist\n\n- [ ] Does the function have a `# Safety` section?\n- [ ] Are ALL caller obligations listed?\n- [ ] Is each requirement specific and verifiable?\n- [ ] Does the example show correct usage with SAFETY comment?\n\n## Related Rules\n\n- `safety-09`: SAFETY comments for unsafe blocks\n- `safety-02`: Verify safety invariants\n",
        "skills/unsafe-checker/rules/safety-11-assert-not-debug.md": "---\nid: safety-11\noriginal_id: G.UNS.SAS.02\nlevel: G\nimpact: MEDIUM\nclippy: debug_assert_with_mut_call\n---\n\n# Use assert! Instead of debug_assert! in Unsafe Functions\n\n## Summary\n\nIn `unsafe` functions or functions containing unsafe blocks, prefer `assert!` over `debug_assert!` for checking safety invariants.\n\n## Rationale\n\n`debug_assert!` is compiled out in release builds. If an invariant is important enough to check for safety, it should be checked in all builds to catch violations.\n\n## Bad Example\n\n```rust\n// DON'T: Use debug_assert for safety-critical checks\npub unsafe fn get_unchecked(slice: &[i32], index: usize) -> &i32 {\n    debug_assert!(index < slice.len());  // Gone in release!\n    &*slice.as_ptr().add(index)\n}\n\n// DON'T: Rely on debug_assert for FFI safety\npub unsafe fn call_c_function(ptr: *const Data) {\n    debug_assert!(!ptr.is_null());  // Won't catch bugs in release\n    ffi::process_data(ptr);\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use assert! for safety checks (when performance allows)\npub unsafe fn get_unchecked(slice: &[i32], index: usize) -> &i32 {\n    assert!(index < slice.len(), \"index {} out of bounds for len {}\", index, slice.len());\n    &*slice.as_ptr().add(index)\n}\n\n// DO: Use debug_assert when CALLER is responsible\n/// # Safety\n/// index must be less than slice.len()\npub unsafe fn get_unchecked_fast(slice: &[i32], index: usize) -> &i32 {\n    // Caller is responsible; debug_assert just helps catch bugs during development\n    debug_assert!(index < slice.len());\n    &*slice.as_ptr().add(index)\n}\n\n// DO: Use assert for internal safety, debug_assert for caller obligations\npub fn get_checked(slice: &[i32], index: usize) -> Option<&i32> {\n    if index < slice.len() {\n        // SAFETY: We just checked index < len\n        // debug_assert is fine here because the if-check is the real guard\n        Some(unsafe {\n            debug_assert!(index < slice.len()); // Redundant, just for documentation\n            &*slice.as_ptr().add(index)\n        })\n    } else {\n        None\n    }\n}\n```\n\n## When to Use Each\n\n| Assertion | Use When |\n|-----------|----------|\n| `assert!` | Invariant is not already checked; function is called with untrusted input |\n| `debug_assert!` | Invariant is the caller's responsibility (documented in `# Safety`); performance-critical |\n| No assert | Invariant is enforced by types or prior checks in the same function |\n\n## Hybrid Approach\n\n```rust\n// Use cfg to have both safety and performance\npub unsafe fn process(slice: &[u8], index: usize) {\n    // Always check in tests and debug\n    #[cfg(any(test, debug_assertions))]\n    assert!(index < slice.len());\n\n    // Optional: paranoid mode for production\n    #[cfg(feature = \"paranoid\")]\n    assert!(index < slice.len());\n\n    // SAFETY: Caller guarantees index < len (checked in debug)\n    let ptr = slice.as_ptr().add(index);\n    // ...\n}\n```\n\n## Checklist\n\n- [ ] Is this a safety-critical invariant?\n- [ ] Who is responsible for upholding it (caller or this function)?\n- [ ] Can the assertion be optimized away when provably true?\n- [ ] What's the performance impact of the assertion?\n\n## Related Rules\n\n- `safety-02`: Verify safety invariants\n- `safety-09`: SAFETY comments\n",
        "skills/unsafe-checker/rules/union-01-avoid-except-ffi.md": "---\nid: union-01\noriginal_id: P.UNS.UNI.01\nlevel: P\nimpact: HIGH\n---\n\n# Avoid Union Except for C Interop\n\n## Summary\n\nOnly use `union` for FFI with C code. For Rust-only code, use `enum` with explicit tags.\n\n## Rationale\n\n- Unions require unsafe to read (any field access is unsafe)\n- Easy to read wrong field, causing undefined behavior\n- Enums are type-safe and the compiler tracks the active variant\n- Unions don't run destructors properly\n\n## Bad Example\n\n```rust\n// DON'T: Use union for space optimization in Rust-only code\nunion IntOrFloat {\n    i: i32,\n    f: f32,\n}\n\nfn bad_usage() {\n    let mut u = IntOrFloat { i: 42 };\n\n    // BAD: Reading wrong field is UB\n    let f = unsafe { u.f };  // UB if i was the last written field\n}\n\n// DON'T: Use union for variant types\nunion Variant {\n    string: std::mem::ManuallyDrop<String>,\n    number: i64,\n}\n\n// Problems:\n// 1. Must manually track which variant is active\n// 2. Must manually call drop on String variant\n// 3. Easy to have memory leaks or double-free\n```\n\n## Good Example\n\n```rust\n// DO: Use enum for variant types in Rust\nenum Variant {\n    String(String),\n    Number(i64),\n}\n\n// Compiler tracks active variant, runs correct destructor\n\n// DO: Use union only for C FFI\n#[repr(C)]\nunion CUnion {\n    i: i32,\n    f: f32,\n}\n\n// When interfacing with C code that uses this union\nextern \"C\" {\n    fn c_function_returns_union() -> CUnion;\n    fn c_function_takes_union(u: CUnion);\n}\n\n// DO: Wrap in safe API with explicit variant tracking\n#[repr(C)]\npub struct SafeUnion {\n    tag: u8,\n    data: CUnion,\n}\n\nimpl SafeUnion {\n    pub fn as_int(&self) -> Option<i32> {\n        if self.tag == 0 {\n            // SAFETY: Tag indicates integer variant is active\n            Some(unsafe { self.data.i })\n        } else {\n            None\n        }\n    }\n}\n```\n\n## When Union Is Appropriate\n\n1. **C FFI**: Matching C union layout for interoperability\n2. **MaybeUninit**: The standard library uses union internally\n3. **Very low-level optimization**: Only after profiling and careful safety analysis\n\n## Alternatives to Union\n\n| Use Case | Instead of Union | Use |\n|----------|-----------------|-----|\n| Variant types | union + tag | `enum` |\n| Optional value | union + bool | `Option<T>` |\n| Type punning | union | `transmute` or `from_ne_bytes` |\n| Uninitialized memory | union | `MaybeUninit<T>` |\n\n## Checklist\n\n- [ ] Is this for C FFI? If not, use enum\n- [ ] If union is necessary, is there a tag tracking active variant?\n- [ ] Are destructors handled correctly for Drop types?\n- [ ] Is the union #[repr(C)] for FFI?\n\n## Related Rules\n\n- `union-02`: Don't use union variants across lifetimes\n- `ffi-13`: Ensure consistent data layout\n",
        "skills/unsafe-checker/rules/union-02-no-cross-lifetime.md": "---\nid: union-02\noriginal_id: P.UNS.UNI.02\nlevel: P\nimpact: CRITICAL\n---\n\n# Do Not Use Union Variants Across Different Lifetimes\n\n## Summary\n\nDo not write to one union field and read from another field that has a different lifetime or references data with a different lifetime.\n\n## Rationale\n\nUnion fields share the same memory. If one field stores a reference with lifetime `'a` and you read it as a reference with lifetime `'b`, you bypass lifetime checking and can create dangling references.\n\n## Bad Example\n\n```rust\n// DON'T: Extend lifetime through union\nunion LifetimeBypass<'a, 'b> {\n    short: &'a str,\n    long: &'b str,\n}\n\nfn bad_lifetime_extension<'a, 'b>(short: &'a str) -> &'b str {\n    let u = LifetimeBypass { short };\n    // BAD: Reading with different lifetime is UB\n    unsafe { u.long }\n}\n\nfn exploit() {\n    let long_ref: &'static str;\n    {\n        let temp = String::from(\"temporary\");\n        // Extend local reference to 'static - dangling pointer!\n        long_ref = bad_lifetime_extension(&temp);\n    }\n    // temp is dropped, long_ref is dangling\n    println!(\"{}\", long_ref);  // UB: use after free\n}\n```\n\n## Good Example\n\n```rust\n// DO: Use same lifetime for all reference fields\nunion SafeUnion<'a> {\n    str_ref: &'a str,\n    bytes_ref: &'a [u8],\n}\n\nfn safe_conversion<'a>(s: &'a str) -> &'a [u8] {\n    let u = SafeUnion { str_ref: s };\n    // SAFETY: Both fields have same lifetime 'a\n    // AND str and [u8] have compatible representations\n    unsafe { u.bytes_ref }\n}\n\n// Better: Just use as_bytes()\nfn better_conversion(s: &str) -> &[u8] {\n    s.as_bytes()\n}\n\n// DO: Use MaybeUninit for delayed initialization, not lifetime tricks\nuse std::mem::MaybeUninit;\n\nfn delayed_init<T>(init: impl FnOnce() -> T) -> T {\n    let mut value: MaybeUninit<T> = MaybeUninit::uninit();\n    value.write(init());\n    unsafe { value.assume_init() }\n}\n```\n\n## Why This Is Dangerous\n\nThe Rust lifetime system prevents use-after-free by tracking how long references are valid. Unions can subvert this:\n\n```\nMemory: [pointer to \"hello\"]\n\nUnion as 'short: points to stack memory (valid during function)\nUnion as 'long:  claims to point to valid memory forever\n\nReality: After function returns, pointer is dangling\n```\n\n## Safe Union Patterns\n\n```rust\n// Pattern 1: All fields have same lifetime\nunion SameLifetime<'a, T, U> {\n    a: &'a T,\n    b: &'a U,\n}\n\n// Pattern 2: No references at all\n#[repr(C)]\nunion NoRefs {\n    i: i32,\n    f: f32,\n}\n\n// Pattern 3: Use ManuallyDrop for owned values (careful with Drop!)\nunion OwnedUnion {\n    s: std::mem::ManuallyDrop<String>,\n    v: std::mem::ManuallyDrop<Vec<u8>>,\n}\n```\n\n## Checklist\n\n- [ ] Do all reference fields have the same lifetime parameter?\n- [ ] Am I trying to extend a lifetime through union? (If yes, stop!)\n- [ ] For owned types, am I handling Drop correctly?\n\n## Related Rules\n\n- `union-01`: Avoid union except for C interop\n- `safety-02`: Verify safety invariants\n",
        "templates/README.md": "# Rust Code Templates\n\n## Overview\n\nReady-to-use code templates for common Rust patterns. These templates follow coding guidelines and best practices.\n\n## Directory Structure\n\n```\ntemplates/\n‚îú‚îÄ‚îÄ error-handling/     # Error type definitions\n‚îÇ   ‚îú‚îÄ‚îÄ thiserror.rs    # Library error with thiserror\n‚îÇ   ‚îú‚îÄ‚îÄ anyhow.rs       # Application error with anyhow\n‚îÇ   ‚îî‚îÄ‚îÄ custom.rs       # Manual error implementation\n‚îÇ\n‚îú‚îÄ‚îÄ concurrency/        # Concurrent patterns\n‚îÇ   ‚îú‚îÄ‚îÄ worker-pool.rs  # Thread pool pattern\n‚îÇ   ‚îú‚îÄ‚îÄ actor.rs        # Actor pattern with channels\n‚îÇ   ‚îî‚îÄ‚îÄ async-task.rs   # Async task spawning\n‚îÇ\n‚îú‚îÄ‚îÄ ffi/               # FFI patterns\n‚îÇ   ‚îú‚îÄ‚îÄ c-bindings.rs  # Calling C from Rust\n‚îÇ   ‚îú‚îÄ‚îÄ expose-api.rs  # Exposing Rust to C\n‚îÇ   ‚îî‚îÄ‚îÄ safe-wrapper.rs # Safe wrapper for unsafe FFI\n‚îÇ\n‚îú‚îÄ‚îÄ testing/           # Testing patterns\n‚îÇ   ‚îú‚îÄ‚îÄ unit-tests.rs  # Unit test examples\n‚îÇ   ‚îú‚îÄ‚îÄ mock.rs        # Mocking with traits\n‚îÇ   ‚îî‚îÄ‚îÄ integration.rs # Integration test setup\n‚îÇ\n‚îî‚îÄ‚îÄ project/           # Project templates\n    ‚îú‚îÄ‚îÄ lib.rs         # Library crate structure\n    ‚îú‚îÄ‚îÄ main.rs        # Binary crate structure\n    ‚îî‚îÄ‚îÄ Cargo.toml     # Cargo.toml with common deps\n```\n\n## Usage\n\nCopy and adapt templates for your needs:\n\n```bash\n# Copy error template\ncp templates/error-handling/thiserror.rs src/error.rs\n```\n\n## Templates Reference\n\n| Template | Use When |\n|----------|----------|\n| thiserror.rs | Library with specific error types |\n| anyhow.rs | Application with error context |\n| worker-pool.rs | CPU-bound parallel processing |\n| actor.rs | Message-passing concurrency |\n| async-task.rs | I/O-bound async operations |\n| c-bindings.rs | Calling existing C libraries |\n| expose-api.rs | Building Rust library for C |\n| safe-wrapper.rs | Wrapping unsafe FFI safely |\n",
        "tests/README.md": "# Rust Skills Tests\n\n## Overview\n\nThis directory contains test scenarios for validating rust-skills functionality.\n\n## Directory Structure\n\n```\ntests/\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ scenarios/              # Test scenarios by category\n‚îÇ   ‚îú‚îÄ‚îÄ ownership.md        # m01-m04 ownership/resource tests\n‚îÇ   ‚îú‚îÄ‚îÄ layer2-skills.md    # m05, m09-m15 design skills\n‚îÇ   ‚îú‚îÄ‚îÄ domain-skills.md    # Layer 3 domain skills\n‚îÇ   ‚îú‚îÄ‚îÄ unsafe.md           # unsafe-checker tests\n‚îÇ   ‚îú‚îÄ‚îÄ routing.md          # rust-router tests\n‚îÇ   ‚îî‚îÄ‚îÄ agents.md           # Agent integration tests\n‚îÇ\n‚îú‚îÄ‚îÄ pressure-scenarios/     # Edge case tests\n‚îÇ   ‚îú‚îÄ‚îÄ m01-ownership/\n‚îÇ   ‚îú‚îÄ‚îÄ m06-error-handling/\n‚îÇ   ‚îî‚îÄ‚îÄ m07-concurrency/\n‚îÇ\n‚îî‚îÄ‚îÄ validation/             # Validation scripts\n    ‚îî‚îÄ‚îÄ validate-skills.sh\n```\n\n## Quick Test Reference\n\nSee `test-triggers.md` in project root for complete trigger test checklist.\n\n## Running Tests\n\n### Manual Testing\n\nUse the test scenarios as prompts:\n\n```bash\n# Layer 1: Language Mechanics\nclaude -p \"E0382 ÈîôËØØÊÄé‰πàËß£ÂÜ≥\"           # m01-ownership\nclaude -p \"E0499 multiple mutable borrows\" # m03-mutability\nclaude -p \"newtype pattern\"              # m05-type-driven\nclaude -p \"Send Sync trait\"              # m07-concurrency\n\n# Layer 2: Design Choices\nclaude -p \"DDD in Rust\"                  # m09-domain\nclaude -p \"benchmark ÊÄé‰πàÂÜô\"              # m10-performance\nclaude -p \"RAII pattern\"                 # m12-lifecycle\nclaude -p \"Â∏∏ËßÅ Rust ÈîôËØØ\"                # m15-anti-pattern\n\n# Layer 3: Domain Constraints\nclaude -p \"axum web server\"              # domain-web\nclaude -p \"decimal Á≤æÂ∫¶ËÆ°ÁÆó\"              # domain-fintech\nclaude -p \"no_std embedded\"              # domain-embedded\n\n# Core Skills\nclaude -p \"unsafe ‰ª£Á†ÅÊÄé‰πàÂÜô\"             # unsafe-checker\nclaude -p \"tokio ÊúÄÊñ∞ÁâàÊú¨\"                # rust-learner\n```\n\n### Validation Script\n\n```bash\n./tests/validation/validate-skills.sh\n```\n\n## Test Categories\n\n### 1. Layer 1 - Language Mechanics (m01-m07)\n- Ownership, borrowing, lifetimes\n- Resource management\n- Mutability\n- Zero-cost abstraction\n- Type-driven design\n- Error handling\n- Concurrency\n\n### 2. Layer 2 - Design Choices (m09-m15)\n- Domain modeling\n- Performance optimization\n- Ecosystem integration\n- Resource lifecycle\n- Domain error patterns\n- Mental models\n- Anti-patterns\n\n### 3. Layer 3 - Domain Constraints\n- domain-fintech\n- domain-web\n- domain-cli\n- domain-embedded\n- domain-cloud-native\n- domain-iot\n- domain-ml\n\n### 4. Core Skills\n- rust-router\n- rust-learner\n- coding-guidelines\n- unsafe-checker\n\n### 5. Agent Integration\n- crate-researcher\n- rust-changelog\n- docs-researcher\n- clippy-researcher\n\n## Coverage Summary\n\n| Category | Skills | Tested |\n|----------|--------|--------|\n| Layer 1 | 7 | 7/7 |\n| Layer 2 | 7 | 7/7 |\n| Layer 3 | 7 | 7/7 |\n| Core | 4 | 4/4 |\n| **Total** | **25** | **25/25** |\n\n## Adding New Tests\n\n1. Create scenario file in `tests/scenarios/`\n2. Include:\n   - Test prompt\n   - Expected skill trigger\n   - Expected response elements\n3. Update `test-triggers.md` in project root\n4. Update validation script if needed\n"
      },
      "plugins": [
        {
          "name": "rust-skills",
          "description": "38 skills covering ownership, concurrency, error handling, unsafe code, LSP code intelligence, and domain-specific patterns for Rust development",
          "source": "./",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add actionbook/rust-skills",
            "/plugin install rust-skills@rust-skills"
          ]
        }
      ]
    }
  ]
}