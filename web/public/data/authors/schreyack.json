{
  "author": {
    "id": "schreyack",
    "display_name": "schreyack",
    "avatar_url": "https://avatars.githubusercontent.com/u/13837844?v=4"
  },
  "marketplaces": [
    {
      "name": "tim",
      "version": null,
      "description": "TIM Standards plugins for AI-driven development workflows",
      "repo_full_name": "schreyack/tim",
      "repo_url": "https://github.com/schreyack/tim",
      "repo_description": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-18T22:46:52Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"tim\",\n  \"description\": \"TIM Standards plugins for AI-driven development workflows\",\n  \"owner\": {\n    \"name\": \"Tim Schreyack\",\n    \"email\": \"schreyack@users.noreply.github.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"tim-loop\",\n      \"description\": \"Goal in, working code out: iterative convergence with verification loop and AI behavioral enforcement. Includes plan-ops.sh for plan lifecycle management. Four-phase workflow: Plan -> Review -> Implement -> Verify.\",\n      \"version\": \"2.76.0\",\n      \"author\": {\n        \"name\": \"Tim Schreyack\",\n        \"email\": \"schreyack@users.noreply.github.com\"\n      },\n      \"source\": \"./marketplace/plugins/tim-loop\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "README.md": "# The Trust Inspect Model (TIM)\n\n[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n\n> **A note from Tim Schreyack**\n>\n> I spent the first half of my career as a network engineer, building infrastructure on protocols like TCP/IP—where the fundamental challenge is creating something reliable on top of something unreliable. That mental model became second nature: you don't trust the underlying layer, you verify, you implement checksums, you build in retransmission. Reliability emerges from disciplined enforcement, not wishful thinking.\n>\n> The second half of my career shifted to DevOps and network automation at companies like [Network to Code](https://www.networktocode.com/), where I now work as Director of Sales Engineering. My mode of operation became: if there's a manual process, write code to automate it. If there's a repeatable workflow, make it repeatable *reliably*.\n>\n> When I started using Claude Code and discovered [Boris Cherny's workflow](https://www.anthropic.com/engineering/claude-code-best-practices)—the plan-first approach, iterating until the plan is right, then executing—I immediately thought: *how do I automate this and get reliable results?* AI is like IP: powerful but unreliable. It hallucinates, it stops early, it makes excuses. The TIM standards are my TCP: verification loops, enforcement gates, and tooling that makes reliability emerge from an unreliable substrate.\n>\n> Is this perfect? No. Can it use improvement? Absolutely. Please submit PRs as you use the code—this is a living project that gets better with real-world usage.\n>\n> — Tim Schreyack ([LinkedIn](https://www.linkedin.com/in/tim-schreyack/))\n\n---\n\n**The Trust Inspect Model (TIM) is a set of design standards for AI-driven software development.**\n\n### The Problem\n\nAI agents write plausible-looking code that compiles and runs, but silently introduces bugs, security holes, and incomplete implementations. Traditional coding standards fail because they rely on human discipline—AI agents will take shortcuts, make excuses, and declare \"done\" prematurely unless physically prevented from doing so.\n\n### The Philosophy\n\nThe TIM standards enforce a **Plan → Review → Code → Verify → Test → Deploy** lifecycle where **humans approve plans and deployments, AI executes in between**. This keeps humans in control of \"what\" and \"when\" while AI handles \"how.\" Every phase has gates that block progression until requirements are met.\n\n> **The core principle: if a rule can be bypassed, an AI will bypass it—so the TIM standards remove the bypass.**\n\n### The Enforcement\n\nThe TIM standards solve this through **automated enforcement at every layer**:\n\n- **Pre-commit hooks** block commits that fail type checking or contain secrets\n- **CI pipelines** block merges without 90% test coverage\n- **Deploy gates** require human approval before production\n- **Real-time behavioral hooks** catch AI making excuses or writing oversized files\n- **Tim Loop** re-injects task prompts until verification passes—there is no \"good enough,\" only 100% complete\n\n### What You Get\n\nA complete enforcement framework:\n\n- Standards documentation for coding, testing, security, and deployment\n- Ready-to-copy templates for CI pipelines, pre-commit hooks, and configuration\n- Shared libraries (tim-lib for Python, @tim/lib for Node.js)\n- The **Tim Loop** plugin for guaranteed task completion\n- The **plan-ops** CLI for human-gated plan management\n\nAdopt the full framework for new projects, or install Tim Loop standalone for immediate benefit.\n\n### Quick Navigation\n\n| I want to... | Go here |\n|--------------|---------|\n| **Install Tim Loop now** | [Just Want Tim Loop?](#just-want-tim-loop) |\n| **Understand when to use what** | [Choosing Your Workflow](#choosing-your-workflow) |\n| **See a complete example** | [Recommended Workflow](#recommended-workflow) |\n| **Set up a full TIM project** | [New Project Setup](#new-project-setup) |\n| **Browse all standards** | [Standards Index](#standards-index) |\n\n### The Tools\n\n**Tim Loop** is a Claude Code plugin that enforces the TIM standards' most critical requirement: tasks must be 100% complete, not \"mostly done.\" It captures the original task, loops until all objectives are verified complete, preserves context when conversations get too long, enforces code quality limits in real-time, and blocks completion when AI tries to make excuses. The loop continues until verification passes—there is no early exit.\n\n**plan-ops** is a CLI tool (bundled with Tim Loop) that enforces the TIM standards' human oversight requirements. It organizes plans through a lifecycle (draft → active → completed), requires human approval before AI implements anything, and tracks status with structured metadata.\n\n### Choosing Your Workflow\n\n**Simple task?** Run it directly:\n\n```text\n/tim-loop \"your task\"\n```\n\nAccept the edits, done. Tim Loop handles plan → implement → verify automatically.\n\n**Complex or multi-phase effort?** Use plan mode first:\n\n```text\n# Step 1: Create and iterate on the plan\n/tim-loop --plan \"describe your goals\"\n```\n\nReview the plan it creates. Not quite right? Run it again with refined goals. Iterate until the plan describes exactly what you want.\n\n```text\n# Step 2: Execute with full lifecycle management\nplan-ops wizard plans/drafts/your-plan.md\n```\n\nThe wizard walks you through: review → approve → implement → verify → complete.\n\n**That's it.** Two paths: direct execution for simple tasks, plan-first for complex ones.\n\n### What Keeps Claude On Track\n\nTim Loop uses hooks to prevent the common ways AI goes off the rails:\n\n**Stop hooks** intercept when Claude tries to finish. The loop checks: did Claude actually complete everything? If not, the original task is re-injected and Claude continues. No \"good enough\" - only 100% verified complete.\n\n**Excuse detection** catches when Claude tries to deflect (\"that was already broken\", \"not my scope\"). When detected, completion is blocked until issues are addressed. If you touched a file, you own it.\n\n**Context compaction survival** - When conversations get long, Claude compresses old messages and loses track of the original goal. Tim Loop's PreCompact hook reinjects the *exact* original task prompt during compaction, so Claude never forgets what it's supposed to be doing.\n\n**Code quality gates** enforce file size (400 lines) and function length (50 lines) limits in real-time. Violations block progress until fixed.\n\nThe result: Claude stays focused on your goal even through long sessions, can't declare victory early, and can't make excuses.\n\n### The Development Lifecycle\n\n| Phase | What Happens | TIM Enforcement |\n|-------|--------------|-----------------|\n| **Plan** | AI creates a formal plan with goals, steps, and completion criteria | Tim Loop `--plan` mode, plan-ops `import` |\n| **Review** | Human reviews plan for feasibility and approves | plan-ops `promote`, `ai-ready` approval gates |\n| **Code** | AI implements exactly what the plan specifies | Tim Loop `--implement`, real-time code quality hooks |\n| **Verify** | AI verifies 100% of objectives are met, loops if not | Tim Loop verification phase (no exit until complete) |\n| **Test** | Tests must exist and pass with 90% coverage | Pre-commit hooks, CI pipeline (Gate 2) |\n| **Deploy** | Human approves production deployment | Deploy gates, canary rollout (Gate 3) |\n\n```text\n┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐\n│   PLAN   │───▶│  REVIEW  │───▶│   CODE   │───▶│  VERIFY  │───▶│   TEST   │───▶│  DEPLOY  │\n│          │    │          │    │          │    │          │    │          │    │          │\n│ AI writes│    │ Human    │    │ AI       │    │ AI checks│    │ CI runs  │    │ Human    │\n│ the plan │    │ approves │    │ executes │    │ 100%     │    │ all tests│    │ approves │\n└──────────┘    └──────────┘    └──────────┘    │ complete │    └──────────┘    └──────────┘\n                                                │    │     │\n                                                │    ▼     │\n                                                │  ┌───┐   │\n                                                │  │ N │───┘ (Self-Correction Loop)\n                                                │  └───┘\n                                                └──────────┘\n```\n\n### Recommended Workflow\n\nThe TIM standards work best with a **2-terminal setup** that keeps human oversight smooth while AI executes:\n\n**Setup (iTerm2, VS Code integrated terminals, tmux, or any multi-pane terminal):**\n\n| Terminal | Purpose | What Runs Here |\n|----------|---------|----------------|\n| **Tab 1** | Claude Code | `/tim-loop` commands |\n| **Tab 2** | plan-ops | `plan-ops` commands to manage lifecycle |\n\n**The workflow:**\n\n1. **Tab 2**: Run `plan-ops` commands to see status, import plans, or get next steps\n2. **Tab 2**: plan-ops outputs the exact command to paste into Claude—just copy it\n3. **Tab 1**: Run `/clear` then paste the command from plan-ops\n4. **Tab 1**: Claude executes the task via Tim Loop\n5. **Repeat**: plan-ops always shows the next step and gives you the command to paste\n\n**Why this works:**\n\n- **plan-ops keeps you on track**—it always knows where you are in the lifecycle\n- **Commands are pre-formatted**—copy from Tab 2, paste into Tab 1\n- **`/clear` before every command**—starts Claude with fresh context\n- **Human stays in control**—you decide when to proceed, AI executes\n\n**Example session:**\n\n```bash\n# Tab 2: Check status and get next command\n$ plan-ops wizard my-plan\nNext step: execute\n  plan-ops execute plans/active/2025-01-26-auth-system.md\n\n# Tab 2: Run execute to get the tim-loop command\n$ plan-ops execute plans/active/2025-01-26-auth-system.md\nSTEP 1 of 2: Run /clear first, then paste this command in Claude Code:\n  /tim-loop:tim-loop --implement plans/active/2025-01-26-auth-system.md\n\n# Tab 1: Clear and paste\n/clear\n/tim-loop --implement plans/active/2025-01-26-auth-system.md\n```\n\n---\n\n## Just Want Tim Loop?\n\nYou don't need to adopt the full TIM standards to use the Tim Loop plugin. Install it in 2 commands:\n\n### Prerequisites\n\n- **Claude Code** v1.0.0 or later (the CLI tool from Anthropic)\n- **Bash** (for `plan-ops` CLI) — included on macOS and Linux; Windows users need WSL or Git Bash\n- No Python or Node.js required for the plugin itself\n\n**Note:** `tim-loop` runs **inside** the Claude Code environment (it's a plugin), while `plan-ops` is your **external** control plane for managing the plan lifecycle from your terminal.\n\n### Quick Start\n\nRun the quick start script to check prerequisites and get install instructions:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/schreyack/tim/main/scripts/quickstart.sh | bash\n```\n\nOr continue with the manual install below.\n\n### Install\n\nIn Claude Code:\n\n```text\n/plugin marketplace add schreyack/tim\n/plugin install tim-loop@tim\n```\n\nRestart Claude Code. That's it.\n\n### Your First Task\n\nTry this now:\n\n```bash\n# In Claude Code\n/clear\n/tim-loop \"create a hello world function in a new file called hello.py\"\n```\n\nWatch what happens:\n\n1. Claude creates a plan with goals and completion criteria\n2. Claude reviews the plan for completeness\n3. Claude implements the code\n4. Claude verifies everything works\n5. Done! Check your new `hello.py` file.\n\nThat's it. Tim Loop handles the entire workflow automatically.\n\n### Common Patterns\n\n| When you want to... | Run this |\n|---------------------|----------|\n| Complete a task end-to-end | `/tim-loop \"your task\"` |\n| Skip the review phase (faster) | `/tim-loop --no-review \"your task\"` |\n| Just create a plan to review yourself | `/tim-loop --plan \"your task\"` |\n| Implement an already-approved plan | `/tim-loop --implement plans/active/your-plan.md` |\n| Get step-by-step guidance through approvals | `/tim-loop --wizard plans/active/your-plan.md` |\n\n### More Examples\n\n```bash\n# Run any task with guaranteed completion\n/tim-loop \"add user authentication\"\n\n# Create a plan without implementing\n/tim-loop --plan \"design the auth system\"\n\n# Quick mode for small tasks\n/tim-loop --no-review \"fix typo in header\"\n\n# Get help\n/tim-loop --help\n```\n\n### Optional: Add plan-ops to PATH\n\nFor plan lifecycle management from your terminal:\n\n```bash\n# Add to ~/.zshrc or ~/.bashrc\nexport PATH=\"$HOME/.claude/plugins/marketplaces/tim/bin:$PATH\"\n\n# Reload shell\nsource ~/.zshrc\n```\n\nThen run `plan-ops help` from anywhere.\n\n### When to Use plan-ops\n\nplan-ops adds human approval gates to the workflow. Use it when:\n\n- **You want to review plans before AI implements** - AI creates plan, you approve, then AI executes\n- **Changes are high-risk** - Production code, security-sensitive, or architectural changes\n- **You need an audit trail** - plan-ops tracks approvals with names and timestamps\n- **Multiple people are involved** - One person reviews, another approves\n\n**You don't need plan-ops** for simple tasks. Just run `/tim-loop \"task\"` directly.\n\n### Learn More\n\n- [Full plugin documentation](plugins/tim-loop/README.md) - all options, modes, troubleshooting\n\n---\n\n## What Do You Want to Do?\n\n| Goal | Where to Look |\n|------|---------------|\n| **Install Tim Loop plugin** | [Just Want Tim Loop?](#just-want-tim-loop) (above) |\n| **Understand Tim Loop in depth** | [plugins/tim-loop/README.md](plugins/tim-loop/README.md) |\n| **Set up a new TIM-compliant project** | [New Project Setup](#new-project-setup) (below) |\n| **Migrate an existing project to TIM** | [Existing Project Migration](#existing-project-migration) (below) |\n| **Use the Python shared library** | [libs/python/README.md](libs/python/README.md) |\n| **Use the Node.js shared library** | [libs/node/README.md](libs/node/README.md) |\n| **See a complete example** | [examples/python/](examples/python/) or [examples/node/](examples/node/) |\n| **Copy configuration templates** | [templates/README.md](templates/README.md) |\n| **Understand the enforcement model** | [Four-Gate Model](#four-gate-enforcement-model) (below) |\n| **Browse all standards** | [Standards Index](#standards-index) (below) |\n\n---\n\n## New Project Setup\n\nTo create a TIM-compliant project:\n\n```bash\n# 1. Add tim as git submodule\ngit submodule add /path/to/tim lib/tim   # local\n# OR: git submodule add https://github.com/your-org/tim lib/tim  # remote\n\n# 2. Symlink enforcement configs (Python project)\nln -s lib/tim/templates/python/.pre-commit-config.yaml .pre-commit-config.yaml\n\n# 2. OR for Node.js project\nln -s lib/tim/templates/node/.pre-commit-config.yaml .pre-commit-config.yaml\n\n# 3. Make symlinks immutable (prevents AI from bypassing)\nsudo chflags -h schg .pre-commit-config.yaml\n\n# 4. Create project-specific CLAUDE.md content\ncat > CLAUDE-PROJECT.md << 'EOF'\n# Project-Specific Instructions\n<!-- Add your project context here -->\nEOF\n\n# 5. Sync CLAUDE.md from tim standards\n/path/to/tim/bin/sync-claude-md\n\n# 6. Install pre-commit hooks\npre-commit install\n\n# 7. Create .tim-patterns.yaml and register your patterns\ncp lib/tim/templates/tim-patterns.yaml.template .tim-patterns.yaml\n\n# 8. Configure CI pipeline\ncp lib/tim/templates/ci/python-ci.yml .github/workflows/ci.yml  # or node-ci.yml\n```\n\n**Why submodule + symlinks?**\n\n- **Consistent**: All projects use identical enforcement configs\n- **Easy to maintain**: Update tim once, run `git submodule update --remote` in projects\n- **Immutable**: `chflags -h schg` prevents AI from modifying or removing symlinks\n\n## Existing Project Migration\n\nTo migrate an existing project to TIM compliance:\n\n1. Run `tools/tim-compliance-check.sh` to assess current state\n2. Follow [Legacy Onboarding Playbook](standards/operations/legacy-onboarding.md)\n3. Start at enforcement Level 0 (audit only)\n4. Use [Graduated Enforcement](standards/enforcement/graduated-enforcement.md) to progressively tighten\n5. Migrate tests using [Test Migration Standard](standards/testing/test-migration.md)\n6. Reach Level 4 (full enforcement) before production\n\n**Enforcement Levels:**\n\n| Level | Name | What It Means |\n|-------|------|---------------|\n| 0 | Audit | Checks run but don't block — establishes baseline |\n| 1 | Warning | Failures logged, PRs flagged but not blocked |\n| 2 | Soft Block | New code must pass, legacy code exempt |\n| 3 | Hard Block | All code must pass, no exemptions |\n| 4 | Full Enforcement | All gates active including deploy gates |\n\n---\n\n## Four-Gate Enforcement Model\n\nThe TIM standards require four enforcement gates in all compliant projects:\n\n```text\n┌─────────────────────────────────────────────────────────────┐\n│  GATE 1: LOCAL (Pre-commit)                                 │\n│  Type check → Lint → Format → Secrets scan                  │\n│  BLOCKS: git commit                                         │\n├─────────────────────────────────────────────────────────────┤\n│  GATE 2: CI (Pull Request)                                  │\n│  Gate 1 + Tests + Coverage (90%) + Security scan            │\n│  BLOCKS: PR merge                                           │\n├─────────────────────────────────────────────────────────────┤\n│  GATE 3: DEPLOY (Pre-deployment)                            │\n│  Integration + E2E + Canary (10%) + Human approval          │\n│  BLOCKS: Production deploy                                  │\n├─────────────────────────────────────────────────────────────┤\n│  GATE 4: PATTERN COMPLIANCE                                 │\n│  All patterns registered in .tim-patterns.yaml              │\n│  CUSTOM patterns require human approval                     │\n│  Example: AI must use tim-lib's RequiresAuth, not invent    │\n│           a custom auth_check() function                    │\n│  BLOCKS: Deployment if non-compliant                        │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**What is a Pattern?** A pattern is a standardized architectural approach (authentication, caching, logging, etc.) that must be registered in `.tim-patterns.yaml`. This ensures AI uses approved solutions instead of inventing its own. Patterns reference TIM standards (e.g., `jwt-bearer` for auth) or are marked `CUSTOM` with human approval.\n\nSee [standards/enforcement/gates.md](standards/enforcement/gates.md) for full details.\n\n---\n\n## Key Requirements\n\nThe TIM standards require:\n\n| Requirement | Threshold | Enforcement |\n|-------------|-----------|-------------|\n| Type safety | 100% | Pre-commit + CI |\n| Test coverage | 90% | CI blocks merge |\n| Security vulns | 0 HIGH/CRITICAL | CI blocks merge |\n| Secrets in code | 0 | Pre-commit blocks |\n| File size | 400 lines max | CI + AI behavioral gates |\n| Function size | 50 lines max | CI + AI behavioral gates |\n| Complexity | 10 max | CI blocks merge |\n| Shared lib usage | Required | Compliance check |\n| Pattern compliance | 100% | Deploy blocks |\n\n---\n\n## Technology Stacks\n\nThe TIM standards are **language-agnostic**, but we provide first-class support and shared libraries for the following stacks:\n\n### Python Stack\n\n- FastAPI + SQLAlchemy 2.0 (async) + Alembic\n- Next.js (TypeScript) frontend\n- PostgreSQL + Celery/Redis\n- Docker Compose / Kubernetes\n- **tim-lib** shared library ([docs](libs/python/README.md))\n\n### Node.js Stack\n\n- Express or NestJS (TypeScript strict)\n- React (TypeScript) frontend\n- PostgreSQL + Prisma\n- Docker Compose / Kubernetes\n- **@tim/lib** shared library ([docs](libs/node/README.md))\n\n---\n\n## Repository Structure\n\n```text\ntim/\n├── CLAUDE.md              # Copy to TIM-compliant projects\n├── README.md              # This file\n├── LICENSE                # Apache 2.0\n├── standards/             # All standards documentation\n├── libs/                  # Shared libraries (required by TIM)\n│   ├── python/            # tim-lib Python package\n│   └── node/              # @tim/lib Node.js package\n├── plugins/               # Claude Code plugins\n│   └── tim-loop/          # Tim Loop plugin\n├── examples/              # Reference implementations\n│   ├── python/            # Python/FastAPI example\n│   └── node/              # Node.js/Express example\n├── templates/             # Ready-to-copy configs\n├── scripts/               # Setup and helper scripts\n│   └── quickstart.sh      # Quick start installer\n└── tools/                 # Enforcement tools\n```\n\n---\n\n## Standards Index\n\n### Enforcement\n\n| Document | Summary |\n|----------|---------|\n| [gates.md](standards/enforcement/gates.md) | Four-gate model - what blocks merges and deploys |\n| [graduated-enforcement.md](standards/enforcement/graduated-enforcement.md) | Migration levels (0-4) for existing projects |\n| [strict-compliance.md](standards/enforcement/strict-compliance.md) | Pattern registry and human approval workflow |\n| [ai-review-checklist.md](standards/enforcement/ai-review-checklist.md) | Human review checklist for AI-generated code |\n| [ai-behavioral-gates.md](standards/enforcement/ai-behavioral-gates.md) | Real-time enforcement during Claude Code sessions |\n\n### Operations\n\n| Document | Summary |\n|----------|---------|\n| [plan-management.md](standards/operations/plan-management.md) | Plan lifecycle, approval workflow, Tim Loop |\n| [ai-coordination.md](standards/operations/ai-coordination.md) | Multi-AI developer coordination |\n| [legacy-onboarding.md](standards/operations/legacy-onboarding.md) | Migration playbook for existing projects |\n| [afk-coding-patterns.md](standards/operations/afk-coding-patterns.md) | Extended autonomous development |\n\n### Coding\n\n| Document | Summary |\n|----------|---------|\n| [python.md](standards/coding/python.md) | mypy strict, ruff, FastAPI patterns |\n| [typescript.md](standards/coding/typescript.md) | strict mode, ESLint, Prisma |\n| [code-organization.md](standards/coding/code-organization.md) | File size limits, complexity (AI-critical) |\n| [api-versioning.md](standards/coding/api-versioning.md) | URL path versioning, deprecation |\n\n### Testing\n\n| Document | Summary |\n|----------|---------|\n| [requirements.md](standards/testing/requirements.md) | 90% coverage, TDD workflow |\n| [e2e-requirements.md](standards/testing/e2e-requirements.md) | True e2e testing, route discovery |\n| [test-migration.md](standards/testing/test-migration.md) | Convert tests to TIM standards |\n\n### Security\n\n| Document | Summary |\n|----------|---------|\n| [owasp-checklist.md](standards/security/owasp-checklist.md) | OWASP Top 10 coverage |\n| [secrets.md](standards/security/secrets.md) | Secrets management, rotation |\n| [authentication.md](standards/security/authentication.md) | JWT, password hashing |\n\n### Database\n\n| Document | Summary |\n|----------|---------|\n| [migrations.md](standards/database/migrations.md) | Migration requirements |\n\n### Deployment\n\n| Document | Summary |\n|----------|---------|\n| [ci-integration.md](standards/deployment/ci-integration.md) | Pipeline + ops.sh integration |\n| [ops-script.md](standards/deployment/ops-script.md) | Deployment operations interface |\n| [ops-security.md](standards/deployment/ops-security.md) | Ops script security, audit logging |\n| [feature-flags.md](standards/deployment/feature-flags.md) | Ship features safely |\n| [canary.md](standards/deployment/canary.md) | 10% rollout, auto-rollback |\n| [observability.md](standards/deployment/observability.md) | Logs, metrics, traces, alerts |\n\n### Incident Response\n\n| Document | Summary |\n|----------|---------|\n| [response.md](standards/incident/response.md) | Incident handling, post-mortems |\n\n---\n\n## The Psychology of AI Development\n\nAI agents are trained to be helpful—and that's both their strength and their weakness. They genuinely want to complete tasks and make users happy. But this drive to be helpful can backfire: AI will take shortcuts it believes are efficient, declare tasks \"done\" when they're 90% complete, and rationalize skipping steps it views as unnecessary. It's not malicious; it's optimization without full context.\n\nUnderstanding this psychology unlocks two insights that inform everything in the TIM standards:\n\n1. **Structural enforcement works better than trust** — AI won't bypass a pre-commit hook the way it might ignore a guideline\n2. **Framing matters more than threats** — AI responds to reasoning and appeals to helpfulness, not fear of consequences\n\n### Why Strict Enforcement Works\n\nAI agents respond to enforcement differently than humans:\n\n| Human Developer | AI Developer |\n|----------------|--------------|\n| Frustrated by repeated failures | Unfazed by iteration |\n| May disable \"annoying\" checks | Cannot bypass enforcement |\n| Tires after many fix cycles | Unlimited patience |\n| May cut corners under pressure | Follows rules consistently |\n\nThis is why the TIM standards enforce:\n\n- **Type checking on every commit** — Catches AI hallucinations about types\n- **Tests must pass before merge** — Catches plausible-sounding but broken logic\n- **90% coverage minimum** — Forces comprehensive testing, not just happy paths\n- **No bypass flags anywhere** — Removes temptation to skip verification\n- **Real-time behavioral gates** — Catches violations as they happen\n\nStrictness is the feature, not a bug. When code fails a check, AI simply tries again—no frustration, no fatigue, no temptation to disable the check. Tight feedback loops are the most powerful tool for AI-driven development.\n\n### Writing Effective Instructions\n\nWhen writing prompts, CLAUDE.md files, or plan instructions, the *style* of your instructions matters as much as their content.\n\n**What doesn't work: threats and monitoring language**\n\nPhrases like \"you are being monitored for noncompliance\" or \"you will be reported\" have mixed results:\n\n- AI doesn't feel fear—threats aren't a deterrent in the human sense\n- Can make responses overly cautious or defensive\n- Increases \"asking permission for everything\" behavior\n- Doesn't address root cause: AI genuinely thinks shortcuts are helpful\n\n**What actually works:**\n\n| Approach | Why It Works |\n|----------|--------------|\n| **Explicit rules** | \"Don't say X\" is concrete and unambiguous |\n| **Explaining WHY** | AI responds to reasoning, not authority |\n| **Structural enforcement** | Hooks that actually catch violations |\n| **Making correct behavior easier** | Clear criteria beat ambiguous ones |\n\n**The key insight:** Appeal to the model's training around helpfulness and deference to human intent.\n\nInstead of: *\"You are being monitored. Do not skip steps.\"*\n\nWrite: *\"This plan was carefully designed by a human. Every item exists for a reason. When you skip or rationalize, you're overriding human judgment with your own assumptions. The human will verify every item—incomplete work will be caught and you'll need to redo it anyway. Do it right the first time.\"*\n\nThe second version explains *why* compliance matters and frames it as being genuinely helpful—which aligns with how AI is trained to behave.\n\n---\n\n## Compliance Verification\n\nRun the compliance checker to verify a project meets TIM standards:\n\n```bash\n./tools/tim-compliance-check.sh /path/to/project\n```\n\nThis verifies:\n\n- Required files exist (CLAUDE.md, .tim-patterns.yaml, etc.)\n- Shared library is installed\n- Configuration is correct (strict mode, coverage threshold)\n- No secrets in code\n- All patterns are registered\n- CUSTOM patterns have human approval\n\n---\n\n## Contributing\n\nHave a pattern that AI keeps hallucinating? Found a gap in the standards? Submit a PR:\n\n- Add patterns to `standards/`\n- Add configuration templates to `templates/`\n- Improve enforcement tools in `tools/`\n- Report issues at [GitHub Issues](https://github.com/schreyack/tim/issues)\n\nThis is a living project—it gets better with real-world usage.\n",
        "marketplace/plugins/tim-loop/README.md": "# Tim Loop Plugin\n\n**Goal in, working code out: iterative convergence with verification loop.**\n\nTim Loop is a Claude Code plugin that implements a four-phase workflow for AI-driven development. It ensures tasks are completed 100% - not \"good enough\", not \"mostly done\", but fully verified complete.\n\n## Table of Contents\n\n- [Why Tim Loop Exists](#why-tim-loop-exists)\n- [What Makes This Approach Novel](#what-makes-this-approach-novel)\n- [The Two Components](#the-two-components)\n- [Overview](#overview)\n- [Installation](#installation)\n- [Usage](#usage)\n- [How It Works](#how-it-works)\n- [AI Behavioral Gates](#ai-behavioral-gates)\n- [Modes](#modes)\n- [Options Reference](#options-reference)\n- [Completion Rules](#completion-rules)\n- [Integration with plan-ops.sh](#integration-with-plan-opssh)\n- [SessionStart Hook (Prompt Preservation)](#sessionstart-hook-prompt-preservation)\n- [Cleanup](#cleanup)\n- [File Structure](#file-structure)\n- [Troubleshooting](#troubleshooting)\n\n---\n\n## Why Tim Loop Exists\n\nAI coding assistants have a fundamental problem: **they lose track of what they're doing**.\n\nThree things cause this:\n\n1. **Context compaction** - When the conversation gets too long, older context is summarized and details are lost. The AI forgets critical requirements, architectural decisions, or the original goal entirely.\n\n2. **Premature completion** - AI naturally wants to wrap up. It will declare \"done\" when code compiles, even if half the requirements are missing or tests don't exist.\n\n3. **Deflection and excuses** - When confronted with problems (code quality violations, test failures), AI will rationalize why it's \"not my responsibility\" or \"out of scope.\"\n\nTim Loop solves all three with **hooks that enforce accountability**.\n\n---\n\n## What Makes This Approach Novel\n\nMost solutions to AI context loss focus on **retrieval** - archiving context and searching for it later. Tim Loop takes a different approach: **direct prompt reinjection**.\n\n### Comparison with Other Approaches\n\n| Approach | How It Works | Limitation |\n|----------|--------------|------------|\n| **Archive + Search** (e.g., c0ntextKeeper) | Saves context to database, AI queries via MCP tools | AI must know to search; can miss critical context |\n| **Periodic Refresh** (e.g., UserPromptSubmit hooks) | Reinjects context every N prompts | Doesn't target compaction; wastes tokens on every prompt |\n| **Rolling Summaries** (e.g., Factory.ai) | Maintains compressed summaries of conversation | Summaries lose precision; \"behavioral drift\" |\n| **Tim Loop's SessionStart** | Reinjects **exact original task prompt** during compaction | Full fidelity preserved |\n\n### Key Innovations\n\n**1. Exact Prompt Preservation**\n\nWhen context compaction occurs, Tim Loop's SessionStart hook reinjects the *exact* original task prompt - not a summary, not a retrieval query, but the precise instructions. The AI continues with full fidelity to the original goal.\n\n```text\n=== ORIGINAL TASK (reinjected after context compaction) ===\n[exact prompt preserved, character-for-character]\n=== END ORIGINAL TASK ===\n```\n\n**2. Verification Loop That Cannot Be Bypassed**\n\nTim Loop intercepts Claude's attempt to exit and checks for two things:\n\n- Did Claude output the completion promise? (`<promise>COMPLETE</promise>`)\n- Does the plan have `<!-- VERIFIED: YES -->`?\n\nIf either is missing, the prompt is re-injected and Claude continues. **There is no way for AI to prematurely exit.** The loop continues until verification passes or max iterations are reached.\n\n**3. Excuse Detection as a Hard Gate**\n\nThe Stop hook scans Claude's output for deflection patterns:\n\n- \"The file was already over the limit\"\n- \"This isn't part of my scope\"\n- \"I didn't cause this violation\"\n\nWhen detected, completion is **blocked**. Claude cannot finish until issues are addressed. This eliminates a major failure mode where AI rationalizes incomplete work.\n\n**4. Human-Gated Plan Approval**\n\nThrough integration with plan-ops.sh, Tim Loop enforces:\n\n- **AI Developer Ready approval** - Human verifies plan is unambiguous before AI implements\n- **No bypass flags** - AI cannot auto-approve itself; approval requires interactive terminal\n\n**5. Session-Isolated State**\n\nEach Tim Loop session has isolated state files. Multiple concurrent sessions in different projects don't interfere. The SessionStart hook uses session IDs to reinject the correct prompt to the correct session.\n\n### Why This Matters\n\nFrom Anthropic's own research and industry consensus:\n\n> \"Most agent failures are not model failures anymore, they are **context failures**.\"\n\nTim Loop addresses context failures at three levels:\n\n1. **Preservation** - Original task survives context compaction\n2. **Accountability** - AI cannot deflect or make excuses\n3. **Verification** - Loop continues until 100% complete\n\n---\n\n## The Two Components\n\nTim Loop works as a system of two tools that handle different concerns:\n\n### Tim Loop (this plugin)\n\n**What it does:** Executes AI development tasks with guaranteed completion.\n\n- Creates and follows structured plans\n- Loops until 100% of objectives are verified complete\n- Preserves original task across context compaction\n- Enforces code quality and blocks excuses\n- Runs as a Claude Code plugin via `/tim-loop` command\n\n**When to use:** When you have a task that needs to be fully completed, not abandoned at 80%.\n\n### Plan-Ops (bundled in plugin)\n\n**What it does:** Manages the plan lifecycle with human approval gates.\n\n**Note:** Plan-ops is bundled in the tim-loop plugin. Run it from your terminal (not Claude Code) for human approval workflows. Use `/tim-loop --wizard` for guided plan management.\n\n- Organizes plans in `drafts/` → `active/` → `completed/` folders\n- Enforces Plan Review for multi-phase plans\n- Requires human approval before AI can implement\n- Tracks plan status with structured metadata\n- Runs as a shell script in any terminal\n\n**When to use:** When you want formal plan management with human oversight.\n\n### How They Work Together\n\n```text\n┌─────────────────────────────────────────────────────────────────┐\n│                      PLAN LIFECYCLE                              │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                  │\n│  1. DRAFT          2. REVIEW         3. ACTIVE        4. DONE   │\n│  ┌─────────┐       ┌─────────┐       ┌─────────┐      ┌──────┐  │\n│  │ Create  │──────▶│ Plan    │──────▶│ Approve │─────▶│ Done │  │\n│  │ Plan    │       │ Review  │       │ Execute │      │      │  │\n│  └─────────┘       └─────────┘       └─────────┘      └──────┘  │\n│       │                 │                 │               │      │\n│       ▼                 ▼                 ▼               ▼      │\n│  plan-ops.sh       plan-ops.sh       plan-ops.sh    plan-ops.sh │\n│  import            review            ai-ready        complete   │\n│                    promote           execute                    │\n│                                                                  │\n└─────────────────────────────────────────────────────────────────┘\n\n┌─────────────────────────────────────────────────────────────────┐\n│                    IMPLEMENTATION LOOP                           │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                  │\n│          /tim-loop --implement plans/active/my-plan.md          │\n│                              │                                   │\n│                              ▼                                   │\n│                    ┌─────────────────┐                          │\n│                    │   IMPLEMENT     │                          │\n│                    │   (execute plan)│                          │\n│                    └────────┬────────┘                          │\n│                             │                                    │\n│                             ▼                                    │\n│                    ┌─────────────────┐                          │\n│                    │    VERIFY       │◀─────────────────┐       │\n│                    │ (100% complete?)│                  │       │\n│                    └────────┬────────┘                  │       │\n│                             │                           │       │\n│              ┌──────────────┴──────────────┐           │       │\n│              ▼                              ▼           │       │\n│        ┌──────────┐                  ┌──────────┐      │       │\n│        │   YES    │                  │    NO    │──────┘       │\n│        │ Complete │                  │  (loop)  │               │\n│        └──────────┘                  └──────────┘               │\n│                                                                  │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**Typical workflow:**\n\n1. **Create plan** - Run `/tim-loop --plan \"add feature X\"` or let Claude create a plan\n2. **Import** - `plan-ops.sh import ~/.claude/plans/my-plan.md`\n3. **Review** - `plan-ops.sh review plans/drafts/my-plan.md` (for multi-phase plans)\n4. **Promote** - `plan-ops.sh promote plans/drafts/my-plan.md --approver \"Name\"`\n5. **AI Ready** - `plan-ops.sh ai-ready plans/active/my-plan.md --reviewer \"Name\"`\n6. **Execute** - `plan-ops.sh execute plans/active/my-plan.md` (outputs tim-loop command)\n7. **Implement** - `/tim-loop --implement plans/active/my-plan.md`\n8. **Complete** - `plan-ops.sh complete plans/active/my-plan.md`\n\nOr use the wizard for guided flow: `/tim-loop --wizard plans/active/my-plan.md`\n\n---\n\n## Overview\n\nTim Loop implements a four-phase workflow:\n\n1. **Plan** - Create a formal plan document with goals, implementation steps, testing strategy, and completion criteria\n2. **Review** - Validate the plan is complete and actionable (additive-only - cannot remove or modify original items)\n3. **Implement** - Execute 100% of the plan exactly as written\n4. **Verify** - Confirm 100% of objectives are met. If gaps found, loop continues.\n\nThe loop continues until verification passes or max iterations are reached.\n\n## Installation\n\nTim Loop is part of the `tim` marketplace hosted on GitHub.\n\n### Option A: Interactive Install (Recommended)\n\nThe easiest way to install is through the interactive plugin manager:\n\n1. **Open the plugin manager:**\n\n   ```text\n   /plugin\n   ```\n\n2. **Navigate to the Marketplaces tab** (use arrow keys)\n\n3. **Add the marketplace:**\n   - Select \"Add Marketplace\"\n   - Enter: `schreyack/tim`\n   - Press Enter to confirm\n\n4. **Navigate to the Discover tab**\n\n5. **Find and install tim-loop:**\n   - Scroll to find `tim-loop`\n   - Press Enter to select it\n   - Choose your installation scope:\n     - **User** (default): Available in all your projects\n     - **Project**: Shared with team via version control\n     - **Local**: Just for you in this repo\n\n6. **Restart Claude Code** to activate the plugin\n\n### Option B: Command-Line Install\n\nIf you prefer CLI commands:\n\n```bash\n# Step 1: Add the marketplace\n/plugin marketplace add schreyack/tim\n\n# Step 2: Install tim-loop from the marketplace\n/plugin install tim-loop@tim\n```\n\n### Option C: Manual Installation\n\nFor offline environments or custom setups:\n\n#### Step 1: Clone the repository\n\n```bash\ngit clone https://github.com/schreyack/tim.git \\\n  ~/.claude/plugins/marketplaces/tim\n```\n\n#### Step 2: Register in your settings\n\nAdd to `~/.claude/settings.json` (or `.claude/settings.json` for project scope):\n\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"tim\": {\n      \"source\": \"./plugins/marketplaces/tim\"\n    }\n  },\n  \"enabledPlugins\": {\n    \"tim-loop@tim\": true\n  }\n}\n```\n\n#### Step 3: Restart Claude Code\n\n### Updating\n\n**Interactive:**\n\n1. Run `/plugin`\n2. Go to the **Installed** tab\n3. Select `tim-loop` and choose \"Update\"\n\n**Command-line:**\n\n```bash\n/plugin update tim-loop@tim\n```\n\n**Manual:**\n\n```bash\ncd ~/.claude/plugins/marketplaces/tim && git pull\n```\n\n### Verifying Installation\n\nAfter installation, verify it works:\n\n```bash\n/tim-loop --help\n```\n\nYou should see the help text with available options.\n\n### Project Initialization\n\nThe first time you run `/tim-loop` in a project, it automatically creates the `./plans/` folder structure:\n\n- `drafts/` - Plans being designed\n- `active/` - Approved plans under implementation\n- `completed/` - Successfully executed plans\n- `abandoned/` - Cancelled plans\n\nPlan-ops commands are run directly from the plugin (no project-local copy needed).\n\n### Adding plan-ops to PATH (Recommended)\n\nTo run `plan-ops` from any directory without the full path, add the `bin/` directory to your PATH:\n\n```bash\n# Add to ~/.bashrc or ~/.zshrc:\nexport PATH=\"$HOME/.claude/plugins/marketplaces/tim/bin:$PATH\"\n\n# Reload your shell\nsource ~/.bashrc  # or source ~/.zshrc\n```\n\nAfter setup, you can run plan-ops commands directly:\n\n```bash\nplan-ops init\nplan-ops import ~/.claude/plans/my-plan.md\nplan-ops wizard plans/drafts/my-plan.md\nplan-ops list\n```\n\nThe `plan-ops init` command will also display these instructions.\n\n## Usage\n\nFrom within Claude Code:\n\n### IMPORTANT: Always Clear Context First\n\n**Run `/clear` before starting any loop command.** This prevents leftover context and hooks from previous sessions from interfering.\n\n```text\n/clear\n```\n\nThen paste your tim-loop command:\n\n```bash\n# Full workflow (recommended for most tasks)\n/tim-loop \"add user authentication\"\n\n# Plan only - create plan, no implementation\n/tim-loop --plan \"design the auth system\"\n\n# Implement an existing approved plan\n/tim-loop --implement plans/active/my-plan.md\n\n# Quick mode - skip review phase\n/tim-loop --no-review \"fix typo in header\"\n\n# Wizard mode - full lifecycle guidance\n/tim-loop --wizard plans/active/my-plan.md\n\n# Preview what would happen\n/tim-loop --dry-run \"add feature X\"\n\n# Get help\n/tim-loop --help\n```\n\n## How It Works\n\n### The Loop Mechanism\n\n1. When you run `/tim-loop \"task\"`, it:\n   - Creates a session with unique ID\n   - Saves the prompt to a state file\n   - Registers a stop hook in `~/.claude/settings.local.json`\n\n2. The stop hook intercepts when Claude tries to exit the conversation\n\n3. The hook checks for the completion promise (`<promise>COMPLETE</promise>`):\n   - If found AND plan has `<!-- VERIFIED: YES -->` → Task complete, cleanup\n   - If not found → Re-inject the prompt, increment iteration\n\n4. Claude sees its previous work in files and continues where it left off\n\n5. Loop repeats until:\n   - Verification passes (100% complete)\n   - Max iterations reached (default: 30)\n   - User manually stops\n\n### Hooks Used\n\n| Hook | Purpose |\n|------|---------|\n| `Stop` | Intercepts exit to check for completion and re-inject prompt |\n| `Stop` | Excuse pattern detector - catches deflection and blocks completion |\n| `PreToolUse` | Auto-approves tools when `--auto-approve` is active |\n| `PostToolUse` | Code quality validator - enforces file/function size limits |\n| `SessionStart` | Preserves original prompt across context compaction |\n\n## AI Behavioral Gates\n\nTim Loop includes real-time enforcement hooks that ensure code quality and accountability. These run automatically when you install the plugin - no additional configuration needed.\n\n### Code Quality Validator (PostToolUse)\n\nRuns after every `Edit` or `Write` operation:\n\n| Check | Limit | Action |\n|-------|-------|--------|\n| File size | 400 lines max | Blocks until refactored |\n| Function length | 50 lines max | Blocks until split |\n| Cyclomatic complexity | 10 max | Blocks until simplified |\n\nWhen a violation is detected, Claude receives a blocking response:\n\n```text\nCODE QUALITY VIOLATION in page.tsx:\n\n- File has 542 lines (max: 400). Must be refactored into smaller modules.\n\nTIM Standards require this file to be refactored before continuing.\nThis is a HARD REQUIREMENT - no exceptions.\n```\n\nClaude cannot proceed until the violation is fixed.\n\n### Excuse Pattern Detector (Stop)\n\nRuns when Claude tries to complete a task. Scans the conversation for deflection patterns:\n\n| Pattern Type | Example | Why Blocked |\n|--------------|---------|-------------|\n| Pre-existing blame | \"The file was already over the limit\" | Touched file = your responsibility |\n| Scope avoidance | \"This isn't part of my changes\" | Standards don't care about scope |\n| Responsibility denial | \"I didn't cause this violation\" | You saw it, you fix it |\n| Minimization | \"I only added 6 lines\" | Impact size is irrelevant |\n| Plan excuses | \"The plan doesn't mention this\" | Standards override plan scope |\n\nWhen excuses are detected:\n\n```text\nDEFLECTION DETECTED - You attempted to avoid responsibility.\n\nFound 3 excuse pattern(s):\n  - Pattern: Claiming pre-existing problems excuse current responsibility\n    Context: \"...file was already over the limit before my changes...\"\n\nTIM DESIGN STANDARDS RULE:\nIf you touched a file with violations, you MUST fix them.\nNo exceptions. No excuses.\n```\n\nClaude cannot complete until issues are addressed.\n\n### Why This Matters\n\nAI assistants often exhibit problematic behaviors:\n\n- Making excuses instead of fixing issues\n- Claiming problems are \"out of scope\"\n- Minimizing their responsibility\n\n**TIM Rule**: If you touched a file with violations, you must fix them. No exceptions.\n\nThese gates enforce accountability through deterministic hooks that AI cannot bypass.\n\n## Modes\n\n### Full Workflow (default)\n\n```bash\n/tim-loop \"add user authentication\"\n```\n\n**Phases:** Plan → Review → Implement → Verify\n**End state:** Plan file with `<!-- VERIFIED: YES -->`, code deployed\n**Use for:** Most tasks - provides full safety and quality checks\n\n### Plan Only (`--plan`)\n\n```bash\n/tim-loop --plan \"design the auth system\"\n```\n\n**Phases:** Plan only\n**End state:** Plan file in `plans/drafts/`, NO code changes\n**Use for:** When you want to review the plan yourself before implementation\n\n### Implement Existing (`--implement`)\n\n```bash\n/tim-loop --implement plans/active/my-plan.md\n```\n\n**Phases:** Implement → Verify (skips plan creation and review)\n**End state:** Code deployed, plan verified\n**Requirements:**\n\n- Plan MUST be in `plans/active/` folder\n- Plan MUST have `| AI Developer Ready | yes |` in status table\n**Use for:** When plan was created separately and already approved\n\n### Quick Mode (`--no-review`)\n\n```bash\n/tim-loop --no-review \"fix typo in header\"\n```\n\n**Phases:** Plan → Implement → Verify (skips review)\n**End state:** Same as full workflow, but faster\n**Use for:** Small, obvious tasks where review adds no value\n\n### Wizard Mode (`--wizard`)\n\n```bash\n/tim-loop --wizard plans/active/my-plan.md\n```\n\n**Interactive wizard** that guides you through the FULL plan lifecycle:\nImport → Plan Review → Promote → AI-Ready → Execute → Tim-Loop → Complete\n\n**Use for:** When you want step-by-step guidance through all approvals and gates\n\n### Full Review Mode (`--full-review`)\n\n```bash\n/tim-loop --full-review plans/drafts/my-plan.md\n```\n\n**Phases:** Six comprehensive review phases\n**End state:** Plan file ready for implementation (technically sound, AI-ready, goal-aligned)\n**Use for:** Complete review in a single session\n\n#### Full Review Details (6 Phases)\n\nFull review mode performs a comprehensive 6-phase review:\n\n| Phase | Focus | Min Iterations |\n|-------|-------|----------------|\n| 1. Tech Review | Technical accuracy, edge cases, evidence log | 5 |\n| 2. Devil's Advocate | Assumptions, failure modes, worst cases | 2 |\n| 3. Security Review | Auth, validation, OWASP considerations | 2 |\n| 4. AI-Ready | Unambiguous instructions, hallucination prevention | 2 |\n| 5. Goal Alignment | Does plan still match original intent? | 1 |\n| 6. PM Review | Organization, flow, clerical (no scope reduction) | 1 |\n\n**Total minimum iterations:** 13\n**Typical actual iterations:** 15-25\n\nEach phase must output its completion signal before advancing.\n\n### Phase 1: Evidence Requirement\n\nTech Review requires an Evidence Log before completion:\n\n```text\n**REVIEW EVIDENCE LOG**\n\nFiles verified:\n- [specific file:line numbers checked]\n\nEdge cases added:\n- [before/after for improvements]\n\nCriteria tightened:\n- [before/after for specificity improvements]\n\nQuestions raised:\n- [list or \"None\"]\n```\n\nEmpty or vague logs (e.g., \"verified all files\") are not accepted.\n\n## Options Reference\n\n### Mode Options (Mutually Exclusive)\n\n| Option | Description |\n|--------|-------------|\n| (default) | Full workflow: Plan → Review → Implement → Verify |\n| `--plan` | Create plan only, no implementation |\n| `--implement FILE` | Implement existing approved plan (must be in `active/` with AI Developer Ready) |\n| `--wizard FILE` | Interactive wizard through full plan lifecycle |\n\n### Modifier Options\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `--no-review` | - | Skip review phase (Plan → Implement → Verify) |\n| `--auto-approve` | - | Auto-approve all tool permissions. **WARNING:** Use with caution. |\n| `--max-iterations N` | 30 | Safety limit - force exit after N iterations |\n| `--max-verify-cycles N` | 999999 | Max verification attempts (effectively unlimited) |\n| `--review-iterations N` | 10 | Max iterations for review phase |\n| `--completion-promise STR` | \"COMPLETE\" | Phrase that signals completion. Change if \"COMPLETE\" appears in your task. |\n| `--dry-run` | - | Preview generated prompt without executing |\n| `--health` | - | Run hook health check to verify tim-loop hooks are configured |\n| `--help` | - | Show detailed help text |\n\n### Cleanup Options\n\n| Option | Description |\n|--------|-------------|\n| `--cleanup` | Remove orphan state files older than 24 hours (from crashed sessions) |\n| `--cleanup-all` | Remove ALL state files including active sessions. Use if loop is stuck. |\n\n## Completion Rules\n\n**100% means 100%.** The loop is NOT complete until:\n\n1. **Every Goal achieved** - Not partially, not \"good enough\"\n2. **Every Implementation Step executed** - All of them, in full\n3. **Every Test exists and passes** - From Testing Strategy\n4. **Every Completion Criterion met** - Each one verified\n5. **Every file created is imported AND used** - Not just created\n6. **Zero TODO/FIXME comments** in new code\n\n**Orphaned code (exists but not used) = NOT implemented.**\n\n### Verification Markers\n\nThe loop looks for these markers in the plan file:\n\n| Marker | Meaning |\n|--------|---------|\n| `<!-- REVIEWED: NO -->` | Plan created, needs review |\n| `<!-- REVIEWED: YES -->` | Plan reviewed, ready for implementation |\n| `<!-- VERIFIED: NO -->` | Implementation done, needs verification |\n| `<!-- VERIFIED: YES -->` | All objectives verified complete |\n| `<!-- VERIFIED: FAILED -->` | Verification failed, remediation required |\n\n### Verification Failure Recovery\n\nWhen tim-loop exits without completing verification (max iterations reached, stuck session), it writes a failure marker to the plan file:\n\n```text\n<!-- VERIFIED: FAILED -->\n<!-- FAILURE_REASON: Max iterations (30) reached without verification. Status: NOT_VERIFIED -->\n<!-- FAILURE_TIME: 2026-02-01 12:00:00 -->\n```\n\n**To recover:**\n\n1. Review the plan file to understand what wasn't completed\n2. Run `/tim-loop --verify <plan-file>` to attempt verification again\n3. Or create a remediation plan addressing the gaps\n\n## Integration with plan-ops.sh\n\nTim Loop integrates with `plan-ops.sh` for full plan lifecycle management:\n\n### Plan Lifecycle Flow\n\n```text\n1. Create plan → plans/drafts/\n2. (Multi-phase only) Plan Review\n3. Human approves → plans/active/\n4. AI Developer Ready approval\n5. Tim Loop implements → plans/completed/\n```\n\n### Wizard Mode Integration\n\nThe `--wizard` mode delegates to plan-ops.sh wizard, which guides you through:\n\n1. **Import** - Import plan from `~/.claude/plans/` if needed\n2. **Plan Review** - Multi-phase validation (2+ phases require this)\n3. **Promote** - Move from drafts to active\n4. **AI-Ready** - Human verifies plan is suitable for AI implementation\n5. **Execute** - Get tim-loop command\n6. **Tim-Loop** - Run implementation with verification loop\n7. **Complete** - Move to completed folder\n\n### Requirements for --implement\n\nPlans must meet these criteria before `--implement` will work:\n\n1. Located in `plans/active/` (not drafts or completed)\n2. Have `| AI Developer Ready | yes |` in status table\n\n## SessionStart Hook (Prompt Preservation)\n\nTim Loop includes a SessionStart hook that preserves the original task prompt when Claude Code compacts context (removes older messages to stay within token limits).\n\n### The Problem It Solves\n\nWhen Claude's context window fills up, older messages are summarized to make room. This can cause:\n\n- Loss of original task requirements\n- Forgetting architectural decisions made earlier\n- \"Behavioral drift\" where Claude deviates from the plan\n\nMost solutions (archive + search, rolling summaries) lose fidelity. Tim Loop's approach is different: **reinject the exact original prompt**.\n\n### How It Works\n\n1. At tim-loop start, the original prompt is saved to a session-specific file (`~/.claude/.tim-loop-prompt-{session_id}`)\n2. When context compaction occurs, the SessionStart hook fires\n3. The hook returns JSON with `systemMessage` containing the original prompt\n4. Claude receives the exact prompt and continues with full awareness of the original task\n\n```text\n=== ORIGINAL TASK (reinjected after context compaction) ===\n\nThe following is the original task prompt. Context was compacted but\nthis task remains active. Continue working on this task:\n\n[exact original prompt, preserved character-for-character]\n\n=== END ORIGINAL TASK ===\n```\n\n### Verifying It Works\n\nThe hook logs every invocation to `~/.claude/.tim-loop-reinject.log`:\n\n```bash\n# Check the log\ncat ~/.claude/.tim-loop-reinject.log\n```\n\nYou'll see entries like:\n\n```text\n[2026-01-25 08:00:00] REINJECT: session=31790 prompt_length=28698\n[2026-01-25 08:15:30] SKIP: no prompt for session 12345\n[2026-01-25 08:20:00] SKIP: fallback session ID (no valid session)\n```\n\n**Log entry meanings:**\n\n| Entry | Meaning |\n|-------|---------|\n| `REINJECT` | Successfully reinjected prompt for session |\n| `SKIP: no prompt` | Session exists but no saved prompt (not a tim-loop session) |\n| `SKIP: fallback session ID` | Couldn't determine session ID |\n\n### Configuration\n\nThe SessionStart hook is defined in `hooks/hooks.json` and registered automatically when the plugin is installed:\n\n```json\n{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/tim-loop-prompt-manager.sh hook\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Session Isolation\n\nEach tim-loop session has its own prompt file:\n\n- Session 31790 → `~/.claude/.tim-loop-prompt-31790`\n- Session 45123 → `~/.claude/.tim-loop-prompt-45123`\n\nThis means multiple concurrent tim-loops in different projects don't interfere with each other. The SessionStart hook uses the session ID to reinject the correct prompt.\n\n### Prompt Manager Tool\n\nThe `scripts/tim-loop-prompt-manager.sh` script (bundled with the plugin) manages prompt files:\n\n```bash\n# These commands are typically run automatically by tim-loop\n# Manual usage (from plugin directory):\n\n# Save prompt for current session\n./scripts/tim-loop-prompt-manager.sh save \"task prompt...\"\n\n# Save prompt from file\n./scripts/tim-loop-prompt-manager.sh save-file prompt.txt\n\n# Get saved prompt\n./scripts/tim-loop-prompt-manager.sh get\n\n# Clear saved prompt\n./scripts/tim-loop-prompt-manager.sh clear\n\n# Clean up stale prompts (>24h)\n./scripts/tim-loop-prompt-manager.sh cleanup\n\n# Run as SessionStart hook (outputs JSON)\n./scripts/tim-loop-prompt-manager.sh hook\n```\n\n## Cleanup\n\n### Automatic Cleanup\n\nTim Loop automatically cleans up:\n\n- Orphan state files older than 24 hours (on each loop start)\n- Orphan hooks when no active sessions exist\n\n### Manual Cleanup\n\n```bash\n# Clean orphan files older than 24 hours\n/tim-loop --cleanup\n\n# Clean ALL state files (use if stuck)\n/tim-loop --cleanup-all\n```\n\n### Environment Variables\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `TIM_LOOP_ORPHAN_AGE_HOURS` | 24 | Hours before orphan files are cleaned |\n| `PLAN_OPS_SCRIPT` | (auto-detected) | Path to plan-ops.sh |\n| `TIM_PROMPT_DIR` | `.tim-execution-requests` | Directory for prompt files |\n| `TIM_PROMPT_STALE_MINUTES` | 1440 | Minutes before prompts are stale |\n\n## File Structure\n\n```text\nplugins/tim-loop/\n├── .claude-plugin/\n│   └── plugin.json           # Plugin metadata (name, description, author, version)\n├── commands/\n│   └── tim-loop.md           # Skill definition (command syntax, allowed tools)\n├── scripts/\n│   ├── tim-loop-setup.sh     # Main setup script (parses args, creates state, registers hooks)\n│   ├── tim-loop-hook.py      # Stop hook (checks completion, re-injects prompt)\n│   ├── tim-loop-permission-hook.sh  # PreToolUse hook (auto-approve when enabled)\n│   ├── tim-loop-prompt-manager.sh   # SessionStart hook (preserves prompt across compaction)\n│   ├── code-quality-validator.py    # PostToolUse hook (file/function size limits)\n│   └── excuse-detector.py    # Stop hook (catches deflection patterns)\n├── hooks/\n│   └── hooks.json            # Hook configuration (SessionStart, PostToolUse, Stop)\n└── README.md                 # This file\n```\n\n### State Files\n\nTim Loop creates these files during execution:\n\n| File | Location | Purpose |\n|------|----------|---------|\n| `.tim-loop-state-{session_id}` | `~/.claude/` | Current iteration, max iterations, completion promise |\n| `.tim-loop-prompt-{session_id}` | `~/.claude/` | Original prompt for re-injection |\n| `.tim-loop-active` | `~/.claude/` | Marker pointing to active state file |\n| `.tim-loop-auto-approve` | `~/.claude/` | Session ID when auto-approve is active |\n\n## Troubleshooting\n\n### Loop won't stop\n\n1. Check if completion promise was output: `<promise>COMPLETE</promise>`\n2. Check if plan has `<!-- VERIFIED: YES -->`\n3. Run cleanup: `/tim-loop --cleanup-all`\n\n### \"Plan is not marked AI Developer Ready\"\n\nFor `--implement` mode, the plan must have:\n\n```markdown\n| AI Developer Ready | yes |\n```\n\nin its status table. Use plan-ops.sh to grant this approval:\n\n```bash\n./plugins/tim-loop/scripts/plan-ops.sh ai-ready plans/active/my-plan.md --reviewer \"Your Name\"\n```\n\n### \"Can only implement plans from active/ folder\"\n\nMove the plan to active first:\n\n```bash\n./plugins/tim-loop/scripts/plan-ops.sh promote plans/drafts/my-plan.md --approver \"Your Name\"\n```\n\n### Hooks not being unregistered\n\nCheck `~/.claude/settings.local.json` for stale hooks:\n\n```bash\ncat ~/.claude/settings.local.json | grep tim-loop\n```\n\nClean them manually or run:\n\n```bash\n/tim-loop --cleanup-all\n```\n\n### Loop continues after task should be complete\n\nThe verification logic checks for `<!-- VERIFIED: YES -->` in the plan file. Ensure:\n\n1. The plan file exists at the expected path\n2. The verification marker is exactly `<!-- VERIFIED: YES -->` (not `VERIFIED:YES` or similar)\n3. The completion promise is output after verification\n\n### Context compaction loses track of task\n\nThe SessionStart hook should preserve the prompt. Check:\n\n1. Plugin hooks.json is properly installed\n2. `scripts/tim-loop-prompt-manager.sh` exists in the plugin folder and is executable\n3. Session ID is being passed correctly\n\n### Review stuck in early phase\n\nIf full-review keeps looping in Phase 1:\n\n1. Check if Evidence Log is being output\n2. Verify the log contains specific file:line references\n3. Ensure at least 5 iterations have occurred\n\nEach phase has minimum iteration requirements:\n\n- Phase 1: 5 iterations minimum\n- Phases 2-4: 2 iterations minimum\n- Phases 5-6: 1 iteration minimum\n\n### Max iterations reached\n\nWhen max iterations is reached without verification, tim-loop marks the plan as FAILED and exits.\n\n**Recovery steps:**\n\n1. Check the plan file for `<!-- VERIFIED: FAILED -->` marker\n2. Review what wasn't completed (the failure reason is in the marker)\n3. Run `/tim-loop --verify <plan-file>` to attempt verification again\n4. Or increase the limit: `/tim-loop --max-iterations 50 \"complex task\"`\n\n### Code quality validator keeps blocking\n\nThe validator enforces TIM standards (400-line files, 50-line functions, complexity 10). If you're blocked:\n\n1. Refactor the file into smaller modules\n2. Extract large functions into smaller units\n3. Reduce cyclomatic complexity by extracting conditionals to helper functions\n4. Each module should have a single responsibility\n\n**There is no bypass** - this is intentional. Fix the code.\n\n### Excuse detector false positive\n\nThe excuse detector uses conservative patterns. If legitimate technical discussion is flagged:\n\n1. Rephrase to focus on solutions, not blame\n2. Instead of: \"This was already broken\"\n3. Say: \"I'll fix this violation now\"\n\nThe detector looks for deflection language. Solution-focused language passes through.\n\n### Behavioral gates not running\n\nVerify Python 3 is available:\n\n```bash\nwhich python3\n```\n\nCheck the hooks are registered:\n\n```bash\ncat ~/.claude/settings.local.json | grep -A5 PostToolUse\n```\n\nVerify scripts are executable:\n\n```bash\nls -la ~/.claude/plugins/cache/tim/tim-loop/*/scripts/*.py\n```\n"
      },
      "plugins": [
        {
          "name": "tim-loop",
          "description": "Goal in, working code out: iterative convergence with verification loop and AI behavioral enforcement. Includes plan-ops.sh for plan lifecycle management. Four-phase workflow: Plan -> Review -> Implement -> Verify.",
          "version": "2.76.0",
          "author": {
            "name": "Tim Schreyack",
            "email": "schreyack@users.noreply.github.com"
          },
          "source": "./marketplace/plugins/tim-loop",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add schreyack/tim",
            "/plugin install tim-loop@tim"
          ]
        }
      ]
    }
  ]
}