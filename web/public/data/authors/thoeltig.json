{
  "author": {
    "id": "thoeltig",
    "display_name": "Thore H√∂ltig",
    "avatar_url": "https://avatars.githubusercontent.com/u/41591511?v=4"
  },
  "marketplaces": [
    {
      "name": "claude-code-toolkit",
      "version": null,
      "description": "A Claude Code marketplace that cuts token costs, preserves context across sessions, and extends Claude with intelligent project exploration, workflow automation, and development standards.",
      "repo_full_name": "thoeltig/claude-code-toolkit",
      "repo_url": "https://github.com/thoeltig/claude-code-toolkit",
      "repo_description": "Claude Code marketplace: session protocol, project exploration, efficient information search, skills for Claude feature generation (MCPs, hooks, skills, prompts, slash commands, subagents), notifications, changelog and documentation. Focused on token usage, context waste and pollution.",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-16T22:30:13Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-code-toolkit\",\n  \"owner\": {\n    \"name\": \"Thore H√∂ltig\",\n    \"email\": \"[email protected]\"\n  },\n  \"metadata\": {\n    \"description\": \"A Claude Code marketplace that cuts token costs, preserves context across sessions, and extends Claude with intelligent project exploration, workflow automation, and development standards.\",\n    \"version\": \"1.15.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"session-protocol\",\n      \"source\": \"./plugins/session-protocol\",\n      \"description\": \"Save your active tasks between sessions for seamless continuity and never loss context again.\",\n      \"version\": \"1.2.0.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    },\n    {\n      \"name\": \"project-intel\",\n      \"source\": \"./plugins/project-intel\",\n      \"description\": \"Lightweight reconnaissance system that provides direction before exploration. Query for relevant files before reading them - avoid expensive blind exploration and context pollution.\",\n      \"version\": \"1.5.1.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    },\n    {\n      \"name\": \"fetch-full-content\",\n      \"source\": \"./plugins/fetch-full-content\",\n      \"description\": \"Download full page content from URLs to markdown for the purpose of full information retrieval without summarization. Applies basic filtering to remove hidden content injection but this is NO prompt injection detection or guard. Should only be used on official and trusted sources like documentations.\",\n      \"version\": \"1.2.0.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    },\n    {\n      \"name\": \"changelog\",\n      \"source\": \"./plugins/changelog\",\n      \"description\": \"CHANGELOG.md management following Keep a Changelog format\",\n      \"version\": \"1.1.0.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    },\n    {\n      \"name\": \"documentation\",\n      \"source\": \"./plugins/documentation\",\n      \"description\": \"Comprehensive skill for creating, updating, and maintaining high-quality project documentation\",\n      \"version\": \"1.0.0.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    },\n    {\n      \"name\": \"claude-code-capabilities\",\n      \"source\": \"./plugins/claude-code-capabilities\",\n      \"description\": \"Comprehensive management of Claude Code features including skills, commands, hooks, MCPs, prompts, and subagents\",\n      \"version\": \"1.8.0.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    },\n    {\n      \"name\": \"cross-platform-notification\",\n      \"source\": \"./plugins/cross-platform-notification\",\n      \"description\": \"A Claude Code plugin with a hook that sends native system notifications for Claude Code notifications.\",\n      \"version\": \"1.0.0.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    },\n    {\n      \"name\": \"transcript-duplicate-scrubber\",\n      \"source\": \"./plugins/transcript-duplicate-scrubber\",\n      \"description\": \"Remove duplicate file reads from transcripts to reduce token waste, lower hallucination risk and preserve context priority when resuming sessions.\",\n      \"version\": \"1.0.0.0\",\n      \"author\": {\n        \"name\": \"Thore H√∂ltig\"\n      },\n      \"strict\": false\n    }\n  ]\n}\n",
        "README.md": "# Claude Code Toolkit\n\nA Claude Code marketplace that cuts token costs, preserves context across sessions, and extends Claude with intelligent project exploration, workflow automation, and development standards.\n\n## üöÄ Quick Start\n\nAdd this marketplace to your Claude Code configuration:\n\n```bash\n# Add the marketplace (replace with actual installation command)\n/marketplace add https://github.com/thoeltig/claude-code-toolkit\n```\n\nThen install any plugin:\n\n```bash\n/plugin install <plugin-name>@claude-code-toolkit\n```\n\n## üì¶ Available Plugins\n\n| Plugin | Description | Version |\n|--------|-------------|---------|\n| **[session-protocol](./plugins/session-protocol/)** | Save your active tasks between sessions and never loss context again | 1.2.0.0 |\n| **[project-intel](./plugins/project-intel/)** | Lightweight reconnaissance system that provides semantic direction before code exploration with persistent knowledge across sessions | 1.5.1.0 |\n| **[fetch-full-content](./plugins/fetch-full-content/)** | Download full page content from URLs to markdown for complete information retrieval without summarization (‚ö†Ô∏è trusted sources only) | 1.2.0.0 |\n| **[changelog](./plugins/changelog/)** | Create, update, and maintain CHANGELOG.md files following Keep a Changelog and Common Changelog standards | 1.1.0.0 |\n| **[documentation](./plugins/documentation/)** | Create and maintain high-quality project documentation with quality validation, style guides, and inclusive language standards | 1.0.0.0 |\n| **[claude-code-capabilities](./plugins/claude-code-capabilities/)** | Comprehensive management of Claude Code features including skills, commands, hooks, prompts, subagents, and MCPs | 1.8.0.0 |\n| **[cross-platform-notification](./plugins/cross-platform-notification/)** | Send native system notifications for Claude Code hook events across Windows, macOS, and Linux | 1.0.0.0 |\n| **[transcript-duplicate-scrubber](./plugins/transcript-duplicate-scrubber/)** | Remove duplicate file reads from transcripts to reduce token waste, lower hallucination risk, and preserve context priority when resuming sessions | 1.0.0.0 |\n\n## üéØ Plugin Highlights\n\n### Session Protocol\nNever lose context again. Save your work state, git status, and active tasks between sessions for seamless continuity.\n\n**Install:** `/plugin install session-protocol@claude-code-toolkit`\n\n### Project Intel\nLightweight reconnaissance system that provides semantic direction before expensive code exploration. Query first to get a ranked list of relevant files - saves exploration tokens and reduces context pollution.\n\n- **`/scan` command**: Generate semantic summaries of project structure once, reuse forever\n- **`/query` command**: Search summaries by semantic relevance to find relevant files without reading them\n- Wave-based parallel processing with persistent cross-session knowledge\n- Semantic scoring on purpose, role, exports, imports, and technologies\n- Breakeven analysis: Saves 10k-20k tokens after 3-4 successful queries\n- Best for mid to large projects (25+ files), stable codebases, team projects\n\n**Install:** `/plugin install project-intel@claude-code-toolkit`\n\n### Fetch-Full-Content\nDownload complete page content as markdown to filesystem for repeated analysis and 100% information retrieval. Built-in WebFetch tool uses AI summarization which will return 30-80% of the information depending on the content size.\n\n‚ö†Ô∏è **Security**: No prompt injection guards - only use on trusted sources like official documentation. Use built-in WebFetch tool for untrusted sources.\n\n**Install:** `/plugin install fetch-full-content@claude-code-toolkit`\n\n### Changelog\nProfessional changelog management with automatic formatting, version tracking, and standards compliance validation.\n\n**Install:** `/plugin install changelog@claude-code-toolkit`\n\n### Documentation\nCreate and maintain high-quality project documentation with comprehensive validation and style guidance. Ensure clarity, accessibility, and inclusive language across all documentation types.\n  - Support for guides, API docs, README files, and architecture documentation\n  - Global audience support with simple language and concrete examples\n  - Inclusive language standards and quality validation\n  - Common issues diagnosis and anti-patterns guide\n\n**Install:** `/plugin install documentation@claude-code-toolkit`\n\n### Claude Code Capabilities\nThe most comprehensive toolkit for working with Claude Code's extensibility features. Includes 7 specialized skills for managing every aspect of your Claude Code setup.\n\n- **managing-agent-skills skill**: Create, analyze, and improve agent skills with validation frameworks and progressive disclosure\n- **managing-hooks skill**: Configure event-driven automation with all 10 hook types, prompt-based hooks, and plugin composition\n- **managing-plugins skill**: Bundle components into distributable plugins with marketplace support and team workflows\n- **managing-prompts skill**: Master prompt engineering with Claude best practices, extended thinking, caching strategies, and Structured Outputs\n- **managing-slash-commands skill**: Create and manage custom slash commands with extended thinking support, SlashCommand tool, and ecosystem integration\n- **managing-subagents skill**: Analyze, evaluate, create, and improve subagents with resumable workflows, decision scoring, and permission modes\n- **managing-mcps skill**: Create, analyze, and manage Model Context Protocol servers with Messages API integration, enterprise configuration\n\n**Install:** `/plugin install claude-code-capabilities@claude-code-toolkit`\n\n### Cross-Platform Notification\nGet alerted when Claude Code tasks complete or hook events occur with native system notifications. Works seamlessly on Windows, macOS, and Linux with automatic fallback to console output.\n\n**Install:** `/plugin install cross-platform-notification@claude-code-toolkit`\n\n### Transcript Duplicate Scrubber\nDuring development you naturally read the same file multiple times to keep important context \"fresh\" (higher priority). But when resuming a session Claude Code reconstructs the entire conversation from the transcript including all file reads which waste tokens without adding new information.\n\nThis plugin automatically deduplicates as your session ends, removing redundant reads using intelligent deduplication:\n- **Write priority**: If a Write has content, all Reads with that content are removed\n- **Keep latest**: For multiple Reads of the same content, keep only the most recent (highest token priority)\n- **Preserve changes**: Different content is always kept (edits create different hashes)\n\nThe cleaned transcript benefits every future resume‚Äîlower cost, reduced hallucination risk from context bloat.\n\n**Install:** `/plugin install transcript-duplicate-scrubber@claude-code-toolkit`\n\n## üìö Documentation\n\nEach plugin has its own detailed README with:\n- Installation instructions\n- Component listings (skills, commands, hooks)\n- Usage examples and workflows\n- Changelog and version history\n\nClick on any plugin name above to view its documentation.\n\n## ü§ù Contributing\n\nWe welcome contributions! Please see [CONTRIBUTING.md](./CONTRIBUTING.md) for guidelines on:\n- Submitting improvement ideas\n- Reporting bugs and requesting features\n- Code standards and best practices\n- Pull request process\n\n## üìú Code of Conduct\n\nThis project adheres to a [Code of Conduct](./CODE_OF_CONDUCT.md). By participating, you are expected to uphold this code.\n\n## üìÑ License\n\nSee [LICENSE](./LICENSE) for details.\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/session-protocol/README.md": "# Session Protocol Plugin\n\nToken-optimized session continuity management for Claude Code conversations.\n\n## Overview\n\nThe session-protocol plugin enables seamless context preservation across Claude Code sessions through structured JSON state management. It captures pending tasks, completed work, architectural decisions, and critical findings‚Äîallowing you to continue exactly where you left off without re-reading files or re-analyzing code.\n\n## Features\n\n- **Smart Task Management**: Automatic consolidation of related completed tasks\n- **Token Efficient**: 59-62% reduction in save/load operations compared to writing/reading markdowns\n- **Privacy Safe**: Strips usernames from paths, no personal info in JSON\n- **Git Integration**: Conditional checks (only if `.git` exists), minimal commands\n- **Session State Tracking**: Skip unnecessary reads when protocol already loaded\n- **Context Blocks**: Preserve architectural decisions and critical pitfalls\n- **Minified Storage**: Single-line JSON for efficient parsing\n\n## Installation\n\nCopy the plugin to your Claude Code plugins directory:\n\n```bash\n# Via marketplace (when available)\nclaude-code plugin install session-protocol\n\n# Manual installation\ncp -r session-protocol ~/.claude/plugins/\n```\n\n## Components\n\n### Skills\n\n- **managing-session-continuity**: Core session state management logic\n  - WF1: Save Context - capture state to session-protocol.json\n  - WF2: Load Context - restore state from session-protocol.json\n\n### Scripts\n\n- `sessionstart-session-protocol-check.py`: Auto-detect existing protocol on session start\n\n## Usage\n\n### Session Start\n\nThe session start hook automatically detects existing session-protocol.json, provides the model information on what to do with it and prompts you to load it on session start.\n\n### Save Session\n\nWhen ending a session with unfinished work:\n\n```\nYou: \"Save session\" or \"/managing-session-continuity save\"\n\nClaude: Saved ‚Üí sp.json\n- 5 pend (2 P1, 3 P2)\n- 8 done (3 individual, 1 consolidated from 12)\n- Git: feature/auth @ abc123f\nNext: TASK_001 - Fix JWT validation\n```\n\n### Load Session\n\nWhen starting a new session:\n\n```\nYou: \"Load previous session\" or \"/managing-session-continuity load\"\n\nClaude: Loaded sp.json (2d old)\n- 3 pend, 1 prog, 8 done (1 consolidated from 12)\n- Git: feature/auth @ abc123f (2 commits ahead)\nNext: TASK_001 - Fix JWT validation\n```\n\n## Workflows\n\n### WF1: Save Context\n\n**Steps**:\n1. Check if protocol loaded this session (skip Read if yes)\n2. Extract pending/in_progress tasks from TodoWrite\n3. Consolidate completed tasks (last 5 individual + groups for older)\n4. Capture git state if `.git` exists\n5. Build minified JSON with privacy rules applied\n6. Write to session-protocol.json\n\n**Task Consolidation** (3+ criteria = consolidate):\n- Same feature/area (e.g., \"redesign page X\")\n- >5 related completed tasks\n- No critical findings to preserve individually\n- >3 days since last task in group\n\n### WF2: Load Context\n\n**Steps**:\n1. Read and parse session-protocol.json\n2. Validate git state (if metadata present AND `.git` exists)\n3. Build summary: age, task counts, next action, warnings\n4. Present concise context to user\n\n## JSON Schema\n\n```json\n{\n  \"metadata\": {\n    \"version\": \"2.0\",\n    \"created\": \"2025-11-26T10:00:00Z\",\n    \"updated\": \"2025-11-26T14:00:00Z\",\n    \"git_branch\": \"feature/auth\",\n    \"git_commit\": \"abc123f5d2e8a1b4c6e9f3a7\"\n  },\n  \"tasks\": [\n    {\n      \"id\": \"TASK_001\",\n      \"title\": \"Fix auth middleware\",\n      \"status\": \"pending\",\n      \"priority\": \"P1\",\n      \"category\": \"BUGFIX\",\n      \"created\": \"2025-11-26T10:00:00Z\",\n      \"completed\": null,\n      \"consolidated\": false,\n      \"consolidated_count\": 0,\n      \"context\": \"JWT RS256 validation fails. See: src/auth/middleware.ts:45\",\n      \"files\": [\"src/auth/middleware.ts:45\"]\n    },\n    {\n      \"id\": \"TASK_010\",\n      \"title\": \"Redesign homepage\",\n      \"status\": \"completed\",\n      \"consolidated\": true,\n      \"consolidated_count\": 12,\n      \"context\": \"Redesigned nav, hero, footer (12 tasks). Pitfall: CSS grid Safari compat. Plan: docs/homepage-plan.md\",\n      \"files\": [\"docs/homepage-plan.md\"],\n      \"completed\": \"2025-11-24T18:00:00Z\"\n    }\n  ],\n  \"context_blocks\": [\n    {\n      \"title\": \"JWT Auth Setup\",\n      \"content\": \"RS256 algo. Pub key: ~/config/jwt-keys/public.pem. TTL: 1h access, 7d refresh\",\n      \"updated\": \"2025-11-26T14:00:00Z\",\n      \"related_tasks\": [\"TASK_001\"]\n    }\n  ]\n}\n```\n\n### Task Fields\n\n- **id**: TASK_XXX (sequential, unique)\n- **title**: Task description\n- **status**: pending | in_progress | completed\n- **priority**: P1 | P2 | P3 (optional)\n- **category**: BUGFIX | FEATURE | CONFIG | DOCS | TEST | REFACTOR (optional)\n- **consolidated**: true if grouped from multiple tasks\n- **consolidated_count**: number of original tasks if consolidated\n- **context**: summary, pitfalls, plan refs, file refs\n- **files**: array of path:line references (relative or ~/)\n\n## Privacy & Security\n\n**Automatic privacy enforcement**:\n- Strips usernames from paths: `/Users/john/project` ‚Üí `~/project`\n- No email addresses, API keys, tokens, or credentials\n- A bit safer for accidental git commits but to be sure include the session-protocol.json in .gitignore\n\n**Format requirements**:\n- Minified JSON (single line, no whitespace)\n- Relative or tilde paths only\n- UTC timestamps with Z suffix\n\n## Token Optimization\n\nApplied multiple token optimization techniques to the traditionally verbose markdown SKILL.md\n\n**Techniques applied**:\n- Remove Claude Knowledge (no basic tool/git/JSON explanations)\n- Compress Structure (abbreviations, symbols, code-style commands)\n- Decision Matrices (consolidation criteria with checkboxes)\n- Workflow Structure (numbered steps vs prose paragraphs)\n- Field Compression (minified JSON, compressed field names)\n- Consistent Terminology (one term per concept)\n\n**Performance vs traditional verbose documentation**:\n- SKILL.md: 271 lines vs ~500 lines traditional (46% reduction)\n- Skill token count: ~1200tk vs ~2400tk traditional (50% reduction)\n- Workflow execution: Task consolidation reduces repeated context\n- Git operations: Conditional checks save ~130tk per operation when not a repo\n- Session state tracking: Eliminates unnecessary Read operations (~2000tk saved when overwriting)\n\n## Best Practices\n\n### When to Save\n\n- Before pre compact context to avoid losssing information\n- To restart a session with already optimized and planned context (reduce noise)\n- Ending session with unfinished work\n- Before switching to different project\n- After significant progress on complex feature\n- Before risky operations (refactoring, migrations)\n\n### What Gets Saved\n\n**Always included**:\n- All pending/in_progress tasks\n- Last 5 completed tasks (individual)\n- Consolidated groups for older related work\n- Architectural decisions (context blocks)\n- Critical pitfalls and error patterns\n- Plan file references (not inline plans)\n\n**Never included**:\n- Conversation history\n- Tool outputs\n- Micro-step details (unless critical)\n- Standard operations\n- Personal information\n\n### Consolidation Strategy\n\n**Consolidate** when:\n- Multiple tasks for same feature (e.g., \"12 tasks redesigning homepage\")\n- Related work completed >3 days ago\n- No unique pitfalls per task\n- Summary + key findings sufficient\n\n**Keep individual** when:\n- Critical bugs with specific fixes\n- Unique lessons/pitfalls per task\n- Recent work (<3 days)\n- Referenced by pending tasks\n\n## Hooks Integration\n\nThe plugin includes an automated hook for session awareness.\n\n### SessionStart Hook\n\n- Auto-detects existing session-protocol.json on session start\n- Informs Claude of previous session state so user can be prompted to load it\n- No user-facing notifications (use cross-platform-notification plugin if desired)\n\n## Troubleshooting\n\n### \"Cannot load: invalid JSON\"\n\n**Cause**: session-protocol.json is corrupted\n**Fix**: Read as plain text to salvage information and overwrite with current session context\n\n### \"Git state changed\"\n\n**Info**: Warning (not error) that repository has new commits since save\n**Action**: Review git log to understand changes\n\n### No git information captured\n\n**Cause**: Not a git repository (no `.git` folder)\n**Fix**: Normal behavior, git integration is optional\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/project-intel/README.md": "# Project Intelligence (project-intel)\n\nLightweight reconnaissance system that provides direction before exploration. Query for relevant files before reading them - avoid expensive blind exploration and context pollution.\n\n---\n\n## The Value Proposition\n\n**Asymmetric Payoff:**\n```\nQuery cost:        ~1k tokens (minimal risk)\nFailed query:      Small loss, move on\nSuccessful query:  Saves 10k-20k tokens of blind exploration\n                   Eliminates context pollution\n                   Provides immediate direction\n\nRisk/Reward: Query aggressively - downside is negligible, upside is enormous\n```\n\n---\n\n## The Problem\n\nEvery new question triggers expensive exploration:\n- Spawn Explore agent or read 15-20 files blindly\n- 80% of content is irrelevant (context pollution)\n- 10k-20k tokens wasted per exploration\n- No persistent knowledge across sessions\n- Vague prompts (\"improve the API\") require figuring out where to look first\n\n## The Solution\n\nBuild a semantic map once, query before exploring:\n\n1. **Scan** full project once or incrementally scan project areas ‚Üí Generate file/directory summaries (one-time cost)\n2. **Query** before reading ‚Üí Get relevant file list (cheap reconnaissance)\n3. **Read** only relevant files ‚Üí Directed exploration vs blind searching\n4. **Maintain** alongside development ‚Üí Re-scan changed areas as needed\n\n**Result:** Cheap orientation that saves expensive exploration when successful.\n\n---\n\n## Quick Start\n\n### 1. Requirements\nInstall [Node.js](https://nodejs.org/) 16.9+\n\n### 2. Scan Your Project (full or partial)\n```bash\n/scan --location=../path/to/project --knowledgeDir=.knowledge\n```\n\nGenerates `.knowledge/summaries.json` with semantic summaries of every directory and file.\n\n**Wave-based processing:**\n- Small projects: Completes quickly in parallel\n- Large projects (20+ batches): Shows estimated time, processes in waves of max 10 concurrent agents\n\nOutput:\n```\n‚úì Analysis complete\n  Files analyzed: 230\n  Batches processed: 29\n  Summaries stored in: .knowledge/summaries.json\n```\n\n### 3. Automatic Session Notifications\n\nWhen you start a new session, project-intel automatically checks your project knowledge and notifies you:\n\n**If knowledge exists:**\n```\n‚úì Project knowledge is up to date\n  You can use /query to find relevant information about 121 files in the current project.\n\n  [If files changed]\n  ‚ö† 30 files need update since last knowledge scan. Run /scan to update.\n```\n\n**If knowledge doesn't exist:**\n```\n‚Ñπ No project knowledge found\n  Run /scan to generate intelligent summaries of project files for fast searches.\n```\n\nThis automatic notification helps you:\n- Know immediately what project knowledge is available\n- Understand when knowledge needs refreshing\n- Get prompted to generate knowledge if missing\n\n### 4. Query Before Exploring\n```bash\n/query \"authentication\"\n/query \"api endpoints rate limiting\"\n/query \"database\" --scope=src --max=10\n```\n\nReturns ranked list of relevant files/directories **without reading them** - providing direction for what to read next.\n\n---\n\n## When to Use\n\n**Query first when:**\n- ‚úÖ Answering vague prompts (\"improve the API\" ‚Üí query \"api\" first)\n- ‚úÖ Broad questions about structure (\"how does auth work?\")\n- ‚úÖ Before spawning Explore agents (cheap reconnaissance first)\n- ‚úÖ Multi-session work (persistent knowledge)\n- ‚úÖ Large codebases (500+ files where exploration is expensive)\n- ‚úÖ Team onboarding (shared semantic map)\n\n**Skip querying when:**\n- ‚ùå Very specific needle query (\"find class UserController\") ‚Üí use Grep/Glob directly\n- ‚ùå Small projects (<100 files) ‚Üí setup cost > benefit\n- ‚ùå Single-file bug fix ‚Üí no direction needed\n- ‚ùå Already know exact location ‚Üí just read the file\n\n**Default strategy:** Query first - the cost is minimal and successful queries save massive exploration effort.\n\n---\n\n## Commands\n\n### `/scan [--location=<path>] [--knowledgeDir=<path>]`\nGenerate or update semantic summaries.\n\n**Parameters:**\n- `--location`: Directory to analyze (default: current directory)\n- `--knowledgeDir`: Output location for summaries (optional - auto-detected if not provided)\n\n**Auto-detection of knowledge directory:**\nIf `--knowledgeDir` is not specified, scan searches for `.knowledge/` in this order:\n1. From provided `--location` (if different from current directory)\n2. From current working directory\n3. Falls back to creating `.knowledge/` in current directory\n\nThis means you rarely need to specify `--knowledgeDir` explicitly.\n\n**What it does:**\n1. Walks filesystem (metadata only, 0 tokens)\n2. Batches files for analysis (~8 files per batch)\n3. Launches Haiku agents in parallel waves (max 10 concurrent)\n4. Each agent summarizes files: purpose, role, exports, imports\n5. Detects changes: new files, modified files, deleted files\n6. Removes deleted files from summaries automatically\n7. Removes empty directories from summaries when all files are deleted\n8. Merges results into `summaries.json`\n\n**Cost:** ~1200 tokens + the files read tokens per batch (similiar to internal explore tool)\n\n**Incremental updates:** Re-running scan merges new summaries with existing ones. Only changed files need re-analysis.\n\n**Git optimization:** If git is available, scan automatically uses git history to identify modified files since last scan, reducing the number files to process to only what is actually needed. Fallback to filesystem modification date detection for non-git projects.\n\n**Automatic cleanup:** Deleted files are removed from summaries automatically. If an entire directory becomes empty (all files deleted), the directory entry is also removed.\n\n**Example:**\n```bash\n# Initial scan\n/scan --location=../my-project --knowledgeDir=../my-project/.knowledge\n\n# Update after changes\n/scan --location=../my-project --knowledgeDir=../my-project/.knowledge\n```\n\n### `/query \"<keywords>\" [--scope=<path>] [--max=N] [--format=<type>] [--knowledgeDir=<path>]`\nSearch summaries by semantic relevance.\n\n**Parameters:**\n- `<keywords>`: Search terms (e.g., \"authentication\", \"api rate limiting\")\n- `--scope`: Limit to specific directory (optional)\n- `--max`: Maximum results (default: 25)\n- `--format`: Result organization (default: `grouped`)\n  - `grouped`: Results organized by directory with folder context and technologies. Best for understanding subsystems and architecture.\n  - `flat`: Single ranked list sorted by relevance. Best for broad searches across unrelated parts of the project.\n- `--knowledgeDir`: Location of summaries.json (optional - auto-detected if not provided)\n\n**Auto-detection of knowledge directory:**\nLike `/scan`, query also auto-detects `.knowledge/` if not explicitly specified, searching from current directory or git root.\n\n**What it does:**\n1. Semantic scoring across summary, purpose, exports, imports, file-level technologies, and role\n2. Returns ranked results (higher score = more relevant)\n3. Results organized by format (grouped by directory or flat list)\n\n**Cost:** ~1k tokens (orchestration + CLI execution)\n\n**Examples:**\n```bash\n# Broad exploration\n/query \"authentication user login\"\n\n# Focused search\n/query \"database connection\" --scope=src/backend\n\n# Conceptual search (not just keywords)\n/query \"use purpose how what script when\"\n```\n\n---\n\n## How It Works\n\n### Semantic Scoring\n\nThe query performs **semantic matching**, not just keyword pattern matching:\n\n- **Purpose match**: +6 (intent/functionality description)\n- **Summary match**: +6 (overall topic relevance)\n- **Exports/Imports match**: +4 (concrete APIs/dependencies)\n- **Technologies/Role match**: +4 (technical context)\n- **Path match**: +2 (directory structure)\n\nResults sorted by total score, showing most relevant files first.\n\n**Example:** Query `\"use purpose how what script when\"` finds files discussing:\n- Purpose statements (\"this script's purpose is...\")\n- Usage instructions (\"how to use this...\")\n- Trigger conditions (\"when to execute...\")\n\nEven if those exact keywords don't appear, files covering these concepts score higher.\n\n### Architecture\n\n```\nInitial Setup (One-time):\n  SessionStart Hook (automatic)\n    ‚Üì [No knowledge found?]\n    ‚Üì Suggest: Run /scan\n\n  /scan [--location=<path>]\n    ‚Üì\n  Auto-detect .knowledge/ directory\n    ‚Üì\n  Filesystem walk + change detection (0 tokens)\n    ‚Üì (Detects: new files, modified files, deleted files)\n\n  Batch creation (~8 files per batch)\n    ‚Üì\n  Parallel Haiku analysis in waves\n    - Wave 1: Batches 1-10 analyze concurrently\n    - Wave 2: Batches 11-20 analyze concurrently\n    - Each batch: subagent invocation ~1200 tokens + the files read tokens\n    ‚Üì\n  Automatic cleanup:\n    - Remove deleted files from summaries\n    - Remove empty directories from summaries\n    ‚Üì\n  Merge to summaries.json\n    ‚úÖ Stored persistently\n\n\nAcross Sessions:\n  SessionStart Hook (automatic)\n    ‚Üì [Knowledge exists?]\n    ‚Üì Show file count + files needing update\n    ‚Üì [Changes detected?]\n    ‚Üì Suggest: Run /scan to update\n\n  /query \"keywords\" [--location=<path>]\n    ‚Üì\n  Auto-detect .knowledge/ directory (if needed)\n    ‚Üì\n  Semantic search summaries.json (~1k tokens)\n    ‚Üì\n  Display ranked results\n    ‚Üì\n  User reads only relevant files (directed exploration)\n```\n\n### What Gets Stored\n\n`.knowledge/summaries.json` structure:\n\n**Directory summary:**\n```json\n{\n  \"directories\": {\n    \"src/auth\": {\n      \"summary\": \"Authentication system implementation\",\n      \"purpose\": \"User login, token management, session handling\",\n      \"technologies\": [\"TypeScript\", \"JWT\", \"bcrypt\"],\n      \"fileCount\": 12,\n      \"subdirCount\": 3\n    }\n  }\n}\n```\n\n**File summary:**\n```json\n{\n  \"files\": {\n    \"src/auth/index.ts\": {\n      \"summary\": \"Main authentication module entry point\",\n      \"purpose\": \"Export auth functions and middleware\",\n      \"role\": \"implementation\",\n      \"technologies\": [\"TypeScript\", \"JWT\"],\n      \"exports\": [\"authenticate\", \"logout\", \"middleware\"],\n      \"imports\": [\"jwt\", \"bcrypt\", \"express\"],\n      \"lastUpdated\": \"2026-01-08T00:00:00Z\"\n    }\n  }\n}\n```\n\n**Note:** Query results omit `lastUpdated` (no longer necessary with SessionStart hook showing staleness). Per-file `technologies` helps with detailed matching and cross-file comparisons in flat query results.\n\n---\n\n## Best Practices\n\n### Maintenance Strategy\n\n**Summaries are like documentation** - maintain alongside code or pay re-scan cost:\n\n1. **Initial setup**: Scan entire project once\n2. **During development**: Re-scan areas you're actively changing\n3. **After major updates**: Re-scan affected directories\n4. **Team sync**: Pull teammate scans from git\n\n**Staleness signals:**\n- SessionStart hook reports files need updating (when changes detected by git or filesystem)\n- You know you've changed an area significantly\n- Summaries don't match your current understanding\n- Query results feel outdated or missing recent work\n\n**Re-scan strategy:**\n```bash\n# Full project re-scan (if everything is stale)\n/scan --location=../project --knowledgeDir=../project/.knowledge\n\n# Targeted re-scan (subset only)\n/scan --location=../project/src/auth --knowledgeDir=../project/.knowledge\n```\n\n### Query Strategies\n\n**Start broad, then narrow:**\n```bash\n# 1. Broad orientation\n/query \"api endpoints\"\n\n# 2. Based on results, narrow scope\n/query \"rate limiting\" --scope=src/api\n```\n\n**Use conceptual terms:**\n```bash\n# Good: semantic concepts\n/query \"authentication session management\"\n/query \"database connection pooling\"\n\n# Also works: technical specifics\n/query \"jwt token validation\"\n/query \"postgres migrations\"\n```\n\n**Multiple keywords improve accuracy:**\n```bash\n# Single keyword: broad results\n/query \"user\"\n\n# Multiple keywords: more focused\n/query \"user authentication login\"\n```\n\n---\n\n## Comparison to Alternatives\n\n### vs. Explore Agent\n- **project-intel**: Cheap reconnaissance, provides file list for you to read\n- **Explore agent**: Deep exploration, reads files and analyzes code\n- **Use project-intel first**: If results are good, read files directly. If not, spawn Explore agent.\n\n### vs. Grep/Glob\n- **Grep/Glob**: Pattern matching (exact strings, file names)\n- **project-intel**: Semantic matching (concepts, purpose, functionality)\n- **Grep/Glob wins**: When you know exact class/function/filename\n- **project-intel wins**: When you know what you're looking for conceptually but not literally\n\n### vs. Reading Files Directly\n- **Reading directly**: High token cost if you read wrong files (context pollution)\n- **project-intel**: Low cost reconnaissance first, read only relevant files\n- **Strategy**: Query ‚Üí read top results ‚Üí explore deeper if needed\n\n---\n\n## Performance Characteristics\n\n### Initial Scan Cost\n| Project Size | Files | Batches | Time | Token Cost |\n|--------------|-------|---------|------|------------|\n| Small | 50-100 | 6-12 | 1-2m | ~8k tokens + read file cost |\n| Medium | 200-500 | 25-60 | 3-6m | ~35k tokens + read file cost |\n| Large | 1000+ | 125+ | 10-15m | ~150k+ tokens + read file cost |\n\n**One-time investment** - results persist forever until re-scan.\n\n### Incremental Scan Cost (with git)\n| Changes | Reduction | Time | Token Cost |\n|---------|-----------|------|------------|\n| 5% changed | 80-95% fewer files | <10s | ~400 tokens |\n| 10% changed | 70-85% fewer files | <30s | ~800 tokens |\n| 25% changed | 50-75% fewer files | <1m | ~1.5k tokens |\n\n**Git optimization** dramatically reduces subsequent scans - only changed files are re-analyzed. Without git, user need to keep track of directories to re-scan and full filesystem walk will collect all files in that folder instead of the actaully needed files.\n\n### Query Cost\nSingle query (~1k tokens, <1s): \n- Failed query (no results): Minimal overhead + exploration\n- Successful query: No exploration\n\n**Comparison:**\n- Explore agent: 5k-25k tokens per exploration\n- Reading 15 files blindly: 10k-20k tokens + context pollution\n- Query + read 3 relevant files: 1k + 3k = 4k tokens (75% savings)\n\n---\n\n## Scope & Applicability\n\n**Best fit:**\n- Mid to larger projects (> 25 files)\n- Stable or legacy codebases (understanding complex structure)\n- Monorepos (navigating multiple systems)\n- Team projects (shared knowledge)\n- Multi-session work (persistent context)\n\n**It depends for:**\n- Small projects (<25 files): If most files are loaded each session the scan cost might not be worth it\n- Known locations: Just read the file directly\n- Change scope/frequency: Partial / full rewrites each session is to fast changing to create persistent knowledge\n\n**Breakeven analysis:**\n- Initial scan: 35k tokens (medium project)\n- Each successful query saves: 10k-15k tokens\n- **Breakeven**: After 3-4 successful queries\n- **Long-term**: Massive savings on recurring questions\n\n---\n\n## Troubleshooting\n\n### \"No knowledge found\"\nRun `/scan` first to generate `.knowledge/summaries.json`\n\n### \"CLI not found\" or \"Module not found\"\nBuild the scripts:\n```bash\ncd scripts\nnpm install\nnpm run build\n```\n\n### \"No matches found\"\n- Try broader keywords\n- Check if scan completed successfully\n- Verify you're searching the right knowledge directory\n\n### Query returns irrelevant results\n- Add more specific keywords\n- Use `--scope` to narrow to specific directory\n- Re-scan if summaries are outdated\n\n### Large project taking too long\n- Scan only specific areas to incrementally build persistent knowledge\n\n### When should I re-scan?\n- SessionStart hook alerts you that files need updating (automatic detection)\n- After major code changes (new features, refactoring)\n- After pulling significant teammate updates\n- When query results don't match your current understanding of the codebase\n\n---\n\n## Design Decisions\n\n**Why persistent storage?**\n- Knowledge persists across sessions automatically\n- No per-session re-exploration overhead\n- Team shares knowledge via git\n\n**Why wave-based parallel processing?**\n- Max 10 concurrent agents balances speed and stability\n- Still 10x faster than sequential\n- Large projects don't overwhelm the system\n- Progress tracking as waves complete\n\n**Why semantic scoring?**\n- Finding files by purpose/functionality is more valuable than path matching\n- \"Authentication logic\" found even if directory isn't named \"auth\"\n- Developers think conceptually, not in exact keywords\n\n**Why query-first workflow?**\n- Low-risk reconnaissance with massive upside\n- Failed queries cost little, successful queries save huge exploration effort\n- Guided exploration reduces context pollution\n- Team reuses discoveries from previous sessions\n\n**Why user-managed staleness?**\n- Developers know when their work area changed\n- Automatic staleness detection is complex and error-prone\n- Treats summaries like documentation - maintain or pay re-scan cost\n- Modification dates provide clear staleness signals\n\n**Why git-based incremental scanning?**\n- Git history provides accurate modification tracking without stat races\n- Only needed files are processed on subsequent scans\n- Transparent fallback for non-git projects (filesystem modification dates)\n- Subdirectory scans benefit from git filtering even when focusing on specific areas\n\n**Why SessionStart hook?**\n- Users need immediate feedback on knowledge status without manual checks\n- Automatic reminders prevent stale knowledge from going unnoticed\n- Low overhead (runs once per session, simple file checks)\n- Helps users understand project state before they start work\n- Reduces time spent figuring out \"should I update knowledge?\"\n\n**Why automatic deletion cleanup?**\n- Critical for query accuracy: Prevents returning information about files that no longer exist\n- Removed files are automatically deleted from summaries on next scan\n- Empty directories are removed to avoid cluttering query results\n- Users don't accidentally try to read files that have been deleted or moved\n- Keeps knowledge consistent with actual project state\n- Ensures query results only reference valid, existing code\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/fetch-full-content/README.md": "# Fetch-Full-Content Plugin\n\nDownload and cache full page content from URLs for complete information retrieval without summarization loss.\n\n## Built-in Fetch vs Fetch-Full-Content\n\n| Feature | Built-in WebFetch | Fetch-Full-Content |\n|---------|------------------|------------|\n| **Information Retrieved** | 30-80% (summarized by subagent) | 100% (full content) |\n| **Caching** | No (refetch with 5min request caching) | Yes (filesystem cached) |\n| **Format** | Markdown | Markdown |\n| **Best For** | Quick lookups, general questions | Building agent skills, comprehensive analysis |\n\n**When to use Fetch-Full-Content:**\n- Writing agent skills based on documentation (need 100% accuracy)\n- Analyzing complete API references or specifications\n- Caching official docs for repeated analysis\n- Building training data from trusted sources\n\n**When to use Built-in WebFetch:**\n- Quick information lookup\n- General web browsing\n- Untrusted or unknown sources\n\n## ‚ö†Ô∏è Security Warning\n\nFetch-Full-Content includes **basic filtering** to remove common hidden content injection vectors (comments, invisible text, display:none elements), but this is **NOT comprehensive protection**.\n\nMalicious websites can still embed instructions to manipulate Claude's behavior through other means not caught by basic filtering.\n\n**ONLY use on:**\n- ‚úÖ Official documentation sites (docs.anthropic.com, angular.dev, etc.)\n- ‚úÖ Trusted third-party sources you control\n- ‚úÖ Content under your organization's domain\n\n**NEVER use on:**\n- ‚ùå Untrusted websites or user-generated content\n- ‚ùå Public forums, comment sections, or social media\n- ‚ùå Potentially malicious sources\n\n**Security filtering includes:**\n- Removes HTML comments\n- Filters elements with `display: none` or `visibility: hidden`\n- Removes text with font-size < 6px\n- Filters elements with opacity < 10%\n- Removes elements with very low alpha channel colors (< 10%)\n\n**If unsure about a source, use the built-in WebFetch tool instead** - it includes comprehensive safeguards for untrusted content.\n\n## Installation\n\n```bash\n/plugin install fetch-full-content@claude-code-toolkit\n```\n\n## Usage\n\n### Basic Usage\n\n```bash\n# Single URL\n/fetch-full-content --folder docs https://angular.dev/essentials/signals\n\n# Multiple URLs\n/fetch-full-content --folder docs https://angular.dev/essentials/signals https://angular.dev/guide/directives\n\n# Batch from file\n/fetch-full-content --folder docs $(cat urls.txt)\n```\n\n### Use Cases\n\n**Build comprehensive agent skills:**\n```bash\n# Download complete Angular documentation for skill development\n/fetch-full-content --folder angular-docs \\\n  https://angular.dev/guide/signals \\\n  https://angular.dev/guide/directives \\\n  https://angular.dev/guide/dependency-injection\n```\n\n**Analyze complex topics:**\n```bash\n# Get all pricing and feature documentation\n/fetch-full-content --folder product-info \\\n  https://service.com/pricing \\\n  https://service.com/features \\\n  https://service.com/billing\n```\n\n**Cache official documentation:**\n```bash\n# Cache official docs for repeated analysis\n/fetch-full-content --folder claude-docs \\\n  https://docs.anthropic.com/en/docs/about-claude/models-overview \\\n  https://docs.anthropic.com/en/docs/build-with-claude/tool-use\n```\n\n## Components\n\n### Slash Command\n\n**`/fetch-full-content`**\n- Downloads full page content from URLs\n- Converts to clean markdown\n- Caches to filesystem for reuse\n- Removes navigation, ads, and scripts\n\n## Output\n\nReturns clean markdown files with:\n- All page content preserved\n- Navigation and ads removed\n- HTML attribute noise stripped\n- Code blocks preserved with syntax highlighting\n- Links maintained as reference\n\nExample output:\n```\ndocs/angular-dev_signals.md\ndocs/angular-dev_directives.md\ndocs/angular-dev_dependency-injection.md\n```\n\n## Key Features\n\n### Complete Content Retrieval\n- No summarization = no information loss\n- Every section, example, and detail preserved\n- Better foundation for building accurate skills\n\n### Filesystem Caching\n- Downloaded files persist in specified folder\n- Reuse across multiple sessions\n- Avoid redundant network requests\n- Analyze same documentation with different approaches\n\n### Smart HTML Cleaning\n- Removes navigation and headers\n- Strips ads and popups\n- Eliminates JavaScript UI code\n- Preserves actual content\n- Filters hidden content (comments, invisible text, display:none elements)\n\n### Automatic JavaScript Rendering\n- Detects dynamic content (< 500 chars detected as JS-rendered)\n- Automatically retries with Playwright\n- Route blocking removes images, styles, fonts to speed up rendering\n\n## Requirements\n\n### Python Dependencies\n```\nrequests\nbeautifulsoup4\nmarkdownify\nplaywright (optional, for JS rendering)\n```\n\n### Tools Used\n- **Bash**: Execute download script\n- **Read**: Load existing files\n- **Glob**: Find cached files\n\n## Best Practices\n\n### Do\n- ‚úÖ Cache official documentation for reuse\n- ‚úÖ Download complete topics before building skills\n- ‚úÖ Use cached files for repeated analysis\n- ‚úÖ Download from trusted sources only\n- ‚úÖ Organize by topic in separate folders\n\n### Don't\n- ‚ùå Use on untrusted websites (use built-in WebFetch instead)\n- ‚ùå Ignore security warnings\n- ‚ùå Assume partial downloads are complete\n- ‚ùå Share downloaded content from restricted sources\n- ‚ùå Rely on summarization when accuracy matters\n\n## How It Works\n\n### Built-in WebFetch Flow\n```\nURL ‚Üí Subagent summarization ‚Üí 30-80% of content ‚Üí Claude\nProblem: Content loss, incomplete information, not cacheable\n```\n\n### Fetch-Full-Content Flow\n```\nURL ‚Üí Download + clean HTML ‚Üí Markdown ‚Üí Filesystem cache ‚Üí Claude\nBenefit: 100% content, reusable, better for skill development\n```\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/changelog/README.md": "# Changelog Plugin\n\nProfessional changelog management for your projects following industry-standard formats.\n\n## Overview\n\nThe changelog plugin provides a comprehensive skill for creating, updating, and maintaining CHANGELOG.md files that follow both [Common Changelog](https://common-changelog.org) and [Keep a Changelog](https://keepachangelog.com) standards. It handles everything from initial creation to complex operations like prerelease promotion and legacy format migration.\n\n## Installation\n\n```bash\n/plugin install changelog@claude-code-toolkit\n```\n\n## Components\n\n### Skills\n\n**managing-changelog**\n- Creates, updates, and maintains CHANGELOG.md files\n- Supports both Common Changelog and Keep a Changelog formats\n- 6 comprehensive workflows covering all changelog operations\n\n### Workflows\n\n| ID | Workflow | Purpose |\n|----|----------|---------|\n| WF1 | Create CHANGELOG.md | Initialize new changelog with format selection |\n| WF2 | Add Release Entry | Add new version with categorized changes |\n| WF3 | Update Unreleased | Track pre-release changes |\n| WF4 | Validate Format | Check compliance with standards |\n| WF5 | Promote Prerelease | Convert alpha/beta/rc to stable release |\n\n## Usage Examples\n\n### Create a New Changelog\n\n```\nUser: \"Create a CHANGELOG.md for this project\"\nClaude: [Uses WF1] Creates initial CHANGELOG.md with selected format\n```\n\n### Add a Release\n\n```\nUser: \"Add version 2.1.0 to the changelog with today's date\"\nClaude: [Uses WF2] Adds properly formatted release entry with:\n- Semver-valid version (2.1.0)\n- ISO 8601 date (YYYY-MM-DD)\n- Categorized changes (Changed, Added, Removed, Fixed)\n- References to commits/PRs/issues\n- Author attribution\n```\n\n### Track Ongoing Work\n\n```\nUser: \"Add this feature to the Unreleased section\"\nClaude: [Uses WF3] Appends to Unreleased section for pre-release tracking\n```\n\n### Validate Before Release\n\n```\nUser: \"Check if our changelog follows the standards\"\nClaude: [Uses WF4] Validates format, categories, dates, and content\n```\n\n### Promote Prerelease to Stable\n\n```\nUser: \"Promote 3.0.0-rc.2 to stable 3.0.0\"\nClaude: [Uses WF5] Handles prerelease promotion with 3 approaches\n```\n\n## Key Features\n\n### Format Support\n- **Common Changelog**: Strict format with references, authors, prefixes\n- **Keep a Changelog**: Simpler format with 6 categories\n- Automatic validation against standards\n- Semantic Versioning compliance\n- Format validation and best practices enforcement\n\n### Writing Quality\n- Remove noise (dotfiles, dev deps, style tweaks)\n- Rephrase for consistency\n- Merge related changes\n- Skip no-op changes\n- Keep entries brief and scannable\n\n### Integration\n- GitHub Actions example for automated releases\n- Git history analysis\n- Reference linking (commits, PRs, issues, external tickets)\n- Author attribution with security constraints\n\n### Security\n- No email addresses in changelogs\n- No API keys, tokens, or credentials\n- No personal file paths\n- Generic repository URLs\n\n## Format Standards\n\n### Common Changelog\n```markdown\n## [1.0.0] - 2025-11-26\n\n### Changed\n- **Breaking:** refactor API to use async/await ([#45](url)) (Author)\n\n### Added\n- Add support for JSON export ([#42](url))\n\n### Fixed\n- Fix memory leak in cache ([#44](url))\n\n[1.0.0]: https://github.com/owner/repo/releases/tag/v1.0.0\n```\n\n### Keep a Changelog\n```markdown\n## [1.0.0] - 2025-11-26\n\n### Added\n- JSON export support\n\n### Changed\n- API now uses async/await (breaking change)\n\n### Fixed\n- Memory leak in cache\n\n[1.0.0]: https://github.com/owner/repo/releases/tag/v1.0.0\n```\n\n## Documentation\n\n### Standards\n- [Common Changelog](https://common-changelog.org)\n- [Keep a Changelog](https://keepachangelog.com/en/1.1.0/)\n- [Semantic Versioning](https://semver.org)\n\n### Version History\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## Tool Requirements\n\nThe skill uses the following Claude Code tools:\n- **Read**: Load existing CHANGELOG.md file\n- **Write**: Create new CHANGELOG.md file\n- **Edit**: Update existing changelog\n\n## Best Practices\n\n### Do\n- ‚úÖ Write changes in imperative mood (Add, Fix, Update)\n- ‚úÖ Include references (commits, PRs, issues)\n- ‚úÖ Categorize changes properly\n- ‚úÖ Use ISO 8601 dates (YYYY-MM-DD)\n- ‚úÖ Highlight breaking changes with **Breaking:** prefix\n- ‚úÖ Keep entries brief (one line per change)\n- ‚úÖ Sort by importance within categories\n\n### Don't\n- ‚ùå Dump raw git log\n- ‚ùå Use vague descriptions\n- ‚ùå Mix up categories\n- ‚ùå Forget dates or use wrong format\n- ‚ùå Include email addresses or sensitive data\n- ‚ùå Copy commit messages verbatim\n- ‚ùå Use past tense (Added, Fixed)\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/documentation/README.md": "# Documentation Plugin\n\nProfessional documentation management for your projects following industry best practices for clarity, accessibility, and inclusivity.\n\n## Overview\n\nThe documentation plugin provides a comprehensive skill for creating, updating, and maintaining high-quality project documentation. It combines established best practices from agile, Google, and Write the Docs methodologies with emphasis on clear communication for global audiences, inclusive language, and lean/agile principles.\n\n## Installation\n\n```bash\n/plugin install documentation@claude-code-toolkit\n```\n\n## Components\n\n### Skills\n\n**managing-documentation**\n- Creates and maintains high-quality project documentation\n- Validates documentation quality against industry standards\n- Ensures inclusive language and accessibility\n- Supports guides, API documentation, README files, and internal documentation\n- 4 comprehensive workflows covering all documentation operations\n\n### Workflows\n\n| ID | Workflow | Purpose |\n|----|----------|---------|\n| WF1 | Creating New Documentation | Define purpose, plan structure, write for global audience, ensure inclusivity, and validate quality |\n| WF2 | Updating Existing Documentation | Assess current state, prioritize improvements, update content, and verify changes |\n| WF3 | Validating Documentation Quality | Apply content quality, clarity, inclusivity, and completeness checks |\n| WF4 | Applying Agile/Lean Principles | Document late, update constantly, with purpose, and choose best communication medium |\n\n## Usage Examples\n\n### Create New Documentation\n\n```\nUser: \"Create a getting started guide for this project\"\nClaude: [Uses WF1] Creates guide with:\n- Clear purpose and audience definition\n- Skimmable structure with prerequisites\n- Step-by-step instructions with examples\n- Global audience considerations\n- Inclusive language throughout\n```\n\n### Update Existing Documentation\n\n```\nUser: \"Update the API documentation to be clearer\"\nClaude: [Uses WF2] Assesses current state, identifies issues, and updates:\n- Unclear jargon and explanations\n- Outdated information\n- Consistency problems\n- Language clarity improvements\n```\n\n### Validate Quality\n\n```\nUser: \"Check if our documentation meets accessibility standards\"\nClaude: [Uses WF3] Validates against:\n- Content quality (ARID principles)\n- Clarity and accessibility\n- Inclusive language\n- Global audience compatibility\n- Completeness checks\n```\n\n### Apply Agile Principles\n\n```\nUser: \"Help us document lean - only what we need\"\nClaude: [Uses WF4] Applies principles:\n- Document late, update constantly\n- Document with clear purpose only\n- Prefer executable specifications\n- Minimize duplication\n```\n\n## Key Features\n\n### Content Quality Standards\n- **ARID Principles**: Accept repetition, Skimmable, Exemplary, Consistent, Current\n- **Clear structure** with descriptive headings\n- **Concrete examples** for all key concepts\n- **No jargon** without explanation\n- **Consistent terminology** throughout\n\n### Global Audience Support\n- Simple, concise language without idioms or colloquialisms\n- Active voice and present tense\n- Shorter sentences for clarity and translation\n- Defined abbreviations\n- Concrete examples over abstract descriptions\n\n### Inclusive Language Standards\n- No ableist terms: \"sanity check\" ‚Üí \"final check\", \"blind to\" ‚Üí \"overlook\"\n- No gendered language: \"man-hours\" ‚Üí \"person-hours\", use \"they\"\n- No violent language or metaphors\n- Diverse names in examples\n- Respectful terminology for disabilities and minorities\n\n### Documentation Types Supported\n- **Guides & Tutorials**: Step-by-step with cumulative examples\n- **API Documentation**: Clear purposes, parameters, examples, error cases\n- **README Files**: Brief intro, installation, usage, contributing, license\n- **Architecture Documentation**: High-level overview with design decisions\n\n### Best Practices Enforcement\n- ‚úÖ Simple language for global audiences\n- ‚úÖ Examples for key concepts\n- ‚úÖ Clear purpose and audience definition\n- ‚úÖ Inclusive and accessible language\n- ‚úÖ No future features or unverifiable claims\n- ‚úÖ Agile/lean approach (just barely good enough)\n- ‚úÖ Consistent terminology and formatting\n\n### Anti-patterns to Avoid\n- ‚ùå Documenting future/unreleased features\n- ‚ùå Excessive claims: \"best\", \"fastest\", \"always\", \"never\"\n- ‚ùå Time-based language: \"new\", \"currently\", \"soon\", \"latest\"\n- ‚ùå Overusing politeness: \"please\" in instructions\n- ‚ùå Problematic language: ableist, gendered, violent, cultural slurs\n- ‚ùå Over-documentation (prefer just-barely-good-enough)\n- ‚ùå Duplicate information across documents\n\n## Quality Checklists\n\n### Content Quality (ARID)\n- [ ] Accept Repetition: Business logic described multiple ways is acceptable\n- [ ] Skimmable: Readers find what they need without reading everything\n- [ ] Exemplary: Common use cases have examples\n- [ ] Consistent: Same terms used consistently, formatting applied systematically\n- [ ] Current: Reflects actual state of product, not historical or future states\n\n### Clarity & Accessibility\n- [ ] No industry jargon without explanation\n- [ ] Sentences under 20 words when possible\n- [ ] Active voice used primarily\n- [ ] Present tense for current capabilities\n- [ ] Examples provided for important concepts\n- [ ] Headings clearly describe content below\n\n### Inclusive Language\n- [ ] No ableist language (sanity check, blind to, cripples, etc.)\n- [ ] No gendered terms (man-hours, he/she pronouns)\n- [ ] No violent language (kill, hit, slaughter metaphors)\n- [ ] No unnecessary cultural specificity\n- [ ] Diverse names in examples\n- [ ] Neutral language about disabilities\n\n### Global Audience\n- [ ] No colloquialisms, idioms, or slang\n- [ ] No humor (difficult to translate)\n- [ ] No geographic specificity (seasons, holidays)\n- [ ] Dates and times unambiguous\n- [ ] Simple words over complex synonyms\n- [ ] No assumed prior knowledge\n\n## Common Use Cases\n\n### For Project Leads\n- Create comprehensive onboarding documentation\n- Validate documentation quality before publication\n- Ensure consistent terminology across all docs\n- Plan documentation structure for new features\n\n### For Developers\n- Write clear API documentation\n- Create getting started guides\n- Document architectural decisions\n- Update docs with new features\n\n### For Technical Writers\n- Review documentation for clarity and inclusivity\n- Check for problematic language\n- Validate against style guides\n- Improve global audience accessibility\n\n### For Teams\n- Maintain consistent documentation standards\n- Ensure inclusive and accessible docs\n- Apply agile principles to documentation\n- Delegate documentation validation\n\n## Documentation Standards\n\n### Supported Document Types\n\n**Guides & Tutorials**\n- Gentle introduction before technical details\n- Clear prerequisites upfront\n- Concrete step-by-step instructions\n- Examples build on previous examples\n- Short code examples (3-5 lines)\n- Clear assumptions about reader knowledge\n\n**API Documentation**\n- Purpose of API group explained first\n- Each method: purpose, parameters, returns\n- Common use cases with examples\n- Error cases documented\n- Realistic but simplified examples\n- Shared terminology throughout\n\n**README Files**\n- Brief description in opening\n- Installation/quick start early\n- Common use cases covered\n- Troubleshooting or FAQ included\n- Links to full documentation\n- Contributing guidelines\n- License clearly stated\n\n**Architecture Documentation**\n- High-level overview first\n- Key concepts explained at high level\n- Diagrams supplement text\n- Links to code for implementation details\n- Design decisions explained (the \"why\")\n- Clear what's documented vs. what's in code\n\n## Writing Style Principles\n\n### Tone and Voice\n- Conversational, friendly, and respectful\n- Knowledgeable friend, not textbook or marketing\n- Human and memorable\n- Focus on information delivery\n\n### Best Practices\n- Read aloud to check naturalness\n- Use transitions for flow\n- Step back and clarify intent\n- Get colleague feedback\n- Focus on useful information\n\n### Techniques to Use\n- Descriptive headings\n- Paragraph key concepts first\n- Active voice\n- Short sentences\n- Concrete examples\n- Clear transitions\n\n## Implementation Approach\n\nWhen using this skill:\n\n1. **Understand context**: Purpose? Audience? What do they need?\n2. **Assess quality**: What works? What needs improvement?\n3. **Plan improvements**: Prioritize critical ‚Üí major ‚Üí minor\n4. **Apply standards**: Use clear structure, simple language, inclusive voice\n5. **Validate**: Check against skill checklists and principles\n6. **Iterate**: Get feedback, refine, publish\n\nThe goal is documentation that is clear, accessible, sufficient for actual needs, and welcoming to readers from all backgrounds.\n\n## Tool Requirements\n\nThe skill integrates with:\n- **Read**: Load existing documentation files\n- **Write**: Create new documentation files\n- **Edit**: Update existing documentation\n- **Glob**: Find documentation files by pattern\n- **Grep**: Search for problematic terms or patterns\n- **Task**: Large-scale validation across many files\n\n## Documentation Standards and Resources\n- [Write the Docs](https://www.writethedocs.org/guide/writing/docs-principles/)\n- [Agile Documentation](https://agilemodeling.com/essays/agileDocumentationBestPractices.htm)\n- [Google Developer Documentation Style Guide](https://developers.google.com/style)\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/claude-code-capabilities/README.md": "# Claude Code Capabilities Plugin\n\nComprehensive management of Claude Code features including skills, slash commands, hooks, MCPs (Model Context Protocol servers), subagents, and prompts. This plugin provides tools for creating, analyzing, and improving Claude Code capabilities with guidance from official documentation.\n\n## What's Included\n\n### managing-agent-skills\n\nA comprehensive skill for creating, analyzing, updating, and improving Claude Code agent skills.\n\n**Core Capabilities:**\n- **WF1: Create Skills** - Complete workflow from requirements to production-ready SKILL.md\n- **WF2: Analyze Skills** - Quality evaluation with 14-point rubric and gap analysis\n- **WF3: Suggest Conversion** - Decision framework for workflow ‚Üí skill conversion\n- **WF4: Update Skills** - Systematic update process for outdated skills\n\n**Key Features:**\n- Complete alignment with official Claude Code documentation (74+ sources)\n- 17 major capability areas including:\n  - Technical Architecture & Runtime Environment\n  - Security Considerations (user safety, creator guidelines)\n  - API Integration (Python SDK, beta headers, versioning)\n  - Package Dependencies & Environment Constraints\n  - MCP Tool References & Naming Conventions\n  - Skill Composition Patterns (sequential, parallel, hierarchical)\n  - Evaluation-Driven Development & Test-First Approach\n  - Iterative Development with Two-Claude Method\n  - Model-Specific Tuning (Haiku, Sonnet, Opus)\n  - Cross-Platform Path Conventions\n- 10 supporting files with progressive disclosure architecture:\n  - analysis-framework.md\n  - best-practices.md\n  - creation-checklist.md\n  - examples/ directory\n  - quick-reference.md\n  - template/ directory\n- Token-based metrics (5,000 tokens recommended)\n- YAML frontmatter with allowed-tools support\n\n**Triggers:**\n- Skill creation requests\n- Skill analysis/evaluation\n- Converting workflows to skills\n- Updating outdated skills\n- Questions about skill concepts, structure, authoring\n\n---\n\n### managing-hooks\n\nComprehensive management of Claude Code event-driven automation hooks, covering both command-based and prompt-based hooks.\n\n**Core Capabilities:**\n- **WF1: Creating Hooks** - Complete workflow from hook type selection to production deployment\n  - Step 3.5: Prompt-based hooks for LLM-powered decisions\n- **WF2: Analyzing Hooks** - Quality evaluation and security assessment\n- **WF3: Updating Hooks** - Systematic update process for outdated hooks\n- **WF4: Working with Plugin Hooks** - Distributed hook composition and multi-plugin scenarios\n- **WF5: Suggesting Hook Creation** - Decision framework for automation vs inline logic\n\n**Key Features:**\n- **Complete Event Coverage** (10 events):\n  - Tool-based: PreToolUse, PermissionRequest, PostToolUse\n  - Lifecycle: SessionStart, SessionEnd\n  - Agent: Stop, SubagentStop\n  - Context: UserPromptSubmit, Notification, PreCompact\n- **Command Hooks** (type: \"command\"): Bash/Python scripts with security validation\n- **Prompt-based Hooks** (type: \"prompt\"): LLM-powered decisions with response schemas\n  - 4 decision patterns: task completion, semantic validation, context-aware permissions, subagent verification\n- **Plugin Hooks**: Distributed hook composition with ${CLAUDE_PLUGIN_ROOT} and ${CLAUDE_ENV_FILE}\n  - Multi-plugin scenarios and execution ordering\n- **MCP Tool Integration**: Matching patterns for Model Context Protocol tools (mcp__server__tool)\n- **Complete Input/Output Schemas**: All 10 hook events with tool examples\n- **8 Supporting Guides**:\n  - prompt-hooks-guide.md\n  - plugin-hooks-guide.md\n  - hook-schemas-reference.md (complete schemas)\n  - hook-types-reference.md\n  - configuration-guide.md\n  - script-examples.md\n  - security-checklist.md\n  - debugging-guide.md\n- **3 Real-world Examples**:\n  - Intelligent Stop hook using prompt-based decisions\n  - Python formatter plugin with full structure\n  - MCP tool security and auditing patterns\n- **Progressive Disclosure**: 9 guides + 3 examples, organized by complexity\n\n**Triggers:**\n- Hook creation requests\n- Hook analysis/improvement\n- Event-driven automation questions\n- Questions about hook types, configuration, security\n- Plugin hook composition patterns\n\n---\n\n### managing-plugins\n\nComplete plugin management for creating, bundling, validating, and distributing Claude Code plugins.\n\n**Core Capabilities:**\n- **OP1: Create Plugin Structure** - Directory setup with proper organization (commands/, skills/, hooks/, .mcp.json)\n- **OP2: Bundle Components** - Pack skills/commands/hooks/MCPs by prefix or explicit list\n- **OP3: Create Marketplace Config** - Generate marketplace.json with source formats (GitHub, Git, local, URLs)\n- **OP4: Validate Plugin** - Check structure, manifests, naming conventions\n- **OP5: Pack for Distribution** - Prepare plugin for sharing with plugin.json generation\n\n**Key Features:**\n- **Plugin Structure Documentation**: Complete directory layout, component organization, naming conventions\n- **plugin.json Schema**: Required fields (name, description, version, author) and optional metadata (homepage, repository, license, keywords)\n- **Marketplace Schema**:\n  - Core fields: name, source, description\n  - Optional fields: strict (manifest requirement), category (organization), tags (discovery)\n  - Source formats: Local paths, GitHub objects, Git URL objects, direct URLs, tarballs\n- **Team Configuration Workflow**: `.claude/settings.json` with extraKnownMarketplaces and autoInstall for automatic plugin installation\n- **Team Testing Workflow**: 5-step validation process before team rollout\n- **MCP Server Configuration**: Complete field documentation (command, args, env, cwd) with ${CLAUDE_PLUGIN_ROOT} environment variable\n- **Hook Events**: All 10 events documented including PermissionRequest\n- **CLI Commands Reference**: plugin validation, install, enable, disable, update, uninstall\n- **5 Supporting Files**:\n  - plugin-spec.md - Complete plugin.json schema and field specifications\n  - marketplace-spec.md - Marketplace configuration and source object formats\n  - distribution-guide.md - Packaging and sharing plugins\n  - validation-rules.md - Plugin validation checklist\n  - team-workflow.md - Team configuration and rollout process\n\n**Triggers:**\n- Plugin creation/bundling requests\n- Plugin validation or analysis\n- Marketplace configuration questions\n- Team plugin distribution\n- Questions about plugin structure, manifest, or distribution\n\n---\n\n### managing-prompts\n\nProduction-ready prompt engineering skill with 100% coverage of all 20 Anthropic documentation files. Complete mastery of prompt creation, analysis, optimization, and Claude 4.5 best practices.\n\n**Core Capabilities:**\n- **WF1: Analyzing Existing Prompts** - Quality evaluation with rubric, issue categorization (critical/major/minor), technique identification\n- **WF2: Creating New Prompts** - Architecture selection (simple task/complex reasoning/agent/multi-window), technique application, guardrail implementation\n- **WF3: Optimizing Existing Prompts** - Goal-based transformations (reduce tokens, improve quality, increase consistency, reduce hallucinations, enable caching)\n- **WF4: Updating Outdated Prompts** - Claude 3‚Üí4.5 migration with pattern updates\n- **WF5: Deciding Logic Extraction** - Decision trees for prompt vs script extraction with criteria scoring\n\n**Key Features:**\n- **Extended Thinking Implementation**: Budget management (1024-32K+ tokens), batch processing for >32K, multi-round strategies, thinking blocks + caching interaction\n- **Prompt Caching Mastery**:\n  - 1-hour cache TTL documentation with pricing comparison and mixing rules\n  - Cache minimum thresholds by model (1024-4096 tokens)\n  - Thinking blocks + caching interaction (automatic caching, token counting, invalidation patterns)\n- **Structured Outputs API**: Complete implementation with JSON schema requirements, comparison with prefilling, decision flows, error handling\n- **Prompt Chaining Architecture**: Sequential/parallel workflows, handoff patterns, orchestration, self-correction loops\n- **Consistency Techniques**: Structured Outputs vs prefilling decision framework, format enforcement, multishot prompting\n- **Claude 4.5 Optimization**: Explicit instructions, context awareness, multi-context workflows, tool usage, vision improvements with crop tool\n- **Guardrails Implementation**: Hallucination prevention, consistency enforcement, security measures, jailbreak prevention, prompt leak reduction\n- **Context Optimization**: Token management, prompt caching strategies, document organization, splitting decisions\n- **15 Supporting Files (14 + SKILL.md)**:\n  - analysis-patterns.md - Common issues and quality assessment\n  - architecture-patterns.md - 5 pattern types with templates\n  - claude-4-5-optimization.md - Claude 4.5-specific optimizations\n  - consistency-techniques.md - Structured Outputs API, prefilling, format enforcement\n  - context-optimization.md - Token efficiency, caching with 1h TTL, document organization\n  - extended-thinking-implementation.md - Budget management, thinking + caching, batch processing\n  - extraction-decision-guide.md - Decision trees for logic extraction\n  - guardrails-implementation.md - Hallucination, security, jailbreak patterns\n  - migration-guide.md - Claude 3‚Üí4.5 migration with 10 examples\n  - optimization-strategies.md - 11 before/after optimization examples\n  - output-formats.md - Report templates for all workflows\n  - prompt-chaining-architecture.md - Sequential/parallel workflows\n  - quick-reference.md - Fast validation checklists, decision trees\n  - technique-reference.md - Indexed lookup by use case with quick table\n\n**Triggers:**\n- Prompt creation, analysis, or optimization requests\n- Questions about prompt engineering, Claude 4.5 best practices\n- Mentions of hallucinations, consistency issues, context optimization\n- Prompt caching, chain-of-thought, XML tags, Structured Outputs\n- Logic extraction decisions (prompt vs script)\n- Extended thinking or prompt chaining questions\n\n---\n\n### managing-slash-commands\n\nComplete management of custom slash commands with advanced features for programmatic invocation and ecosystem integration.\n\n**Core Capabilities:**\n- **WF1: Creating Slash Commands** - Complete workflow from requirements through production-ready command\n  - Design with proper frontmatter (description, allowed-tools, argument-hint, model)\n  - Support for extended thinking in complex reasoning tasks\n  - Validation and testing steps\n- **WF2: Analyzing Existing Commands** - Quality evaluation and best practices assessment\n- **WF3: Suggesting Command vs Skill Conversion** - Decision framework for workflow architecture\n- **WF4: Updating Outdated Commands** - Systematic modernization of existing commands\n\n**Key Features:**\n- **Complete Official Alignment**: Full coverage of Claude Code slash command documentation including all frontmatter fields\n- **Extended Thinking Support**: Guidance for complex reasoning tasks with thinking keywords\n- **SlashCommand Tool Documentation**: Programmatic invocation, permissions, character budget limits, disable-model-invocation field\n- **Plugin Command Integration**: Plugin-scoped namespacing (`plugin-name:command-name` pattern), conflict resolution\n- **MCP Command Discovery**: Dynamic command discovery from connected MCP servers, argument handling\n- **4 Argument Patterns**: No arguments, $ARGUMENTS, positional ($1-$9), and advanced patterns with edge cases\n- **Helper Scripts Guide**: When to use scripts vs interpreted logic with practical examples and best practices\n- **8 Supporting Files**:\n  - best-practices.md - Command naming, prompt content, YAML frontmatter, bash execution, advanced features\n  - creation-guide.md - Step-by-step process with decision matrix and five phases\n  - validation-checklist.md - 11-category validation with quick validation and comprehensive checks\n  - examples.md - 8 annotated examples including extended thinking patterns\n  - argument-patterns.md - 8 patterns with advanced patterns and testing strategies\n  - slashcommand-tool-reference.md - Advanced reference for SlashCommand tool, plugin commands, MCP commands\n  - templates/command-template.md - Template for new command files\n- **Progressive Disclosure**: 8 supporting files organized by complexity level\n- **Cross-Skill References**: Inline references to managing-plugins (plugin commands), managing-mcps (MCP commands), managing-prompts (advanced prompt engineering)\n\n**Triggers:**\n- Slash command creation requests\n- Command analysis/improvement\n- Command vs skill conversion questions\n- Slash command validation and best practices\n- Questions about SlashCommand tool, plugin commands, or MCP commands\n\n---\n\n### managing-subagents\n\nSystematic approach for analyzing, evaluating, creating, and improving subagent configurations to maximize effectiveness.\n\n**Core Capabilities:**\n- **WF1: Analyzing Context for Subagent Delegation** - Score tasks (0-10 points) to decide: subagent vs direct tools\n- **WF2: Explaining Subagent Concepts to Users** - Comprehensive guidance on subagent benefits, use cases, and built-in agent types\n- **WF3: Evaluating Existing Subagent Configurations** - Systematic evaluation for effectiveness, identifying improvements and issues\n- **WF4: Identifying Outdated Agent Configurations** - Verify current state against documentation, detect deprecated patterns\n- **WF5: Recommending Subagent Improvements** - Optimization patterns for descriptions, prompts, tools, and model selection\n- **WF6: Deciding When to Create New Subagents** - Decision framework with 7 criteria for custom agent creation\n- **WF7: Managing Subagents via /agents Command** - Interactive interface for creating, editing, deleting, and inspecting agents\n- **WF8: Understanding Configuration Fields** - Complete reference for all YAML configuration options with inline context\n- **WF9: Using Resumable Subagents** - Continue previous subagent work across multiple invocations with full context preservation\n\n**Key Features:**\n- **Complete Official Alignment**: 95%+ coverage of all Claude Code subagent documentation\n- **Decision Scoring Matrix**: 0-10 point scoring across 5 dimensions (context, complexity, parallelization, focus, iteration)\n- **3 Reference Implementations**: Production-ready example agents (code-reviewer, debugger, data-scientist) for adaptation patterns\n- **Configuration Fields**: All 6 fields documented (name, description, tools, model, permissionMode, skills)\n- **Resumable Agents**: agentId tracking, resume parameter, transcript management, iterative refinement workflows\n- **Permission Modes**: 5 modes explained (default, acceptEdits, bypassPermissions, plan, ignore) with decision criteria\n- **Management Patterns**: /agents command interface, CLI configuration (--agents flag), plugin agent integration\n- **Cross-Skill References**: managing-prompts (prompt optimization), managing-plugins (plugin agents), managing-agent-skills (skill authoring)\n- **10 Supporting Files**:\n  - agents-command-guide.md - /agents interface workflow and tool management\n  - analysis-framework.md - Systematic evaluation criteria for existing agents\n  - cli-configuration.md - Dynamic agent definition via CLI for session-specific or test agents\n  - configuration-reference.md - Complete field documentation with examples and migration guide\n  - decision-matrix.md - Delegation scoring rubric with practical examples\n  - example-subagents.md - Reference implementations with adaptation patterns\n  - improvement-patterns.md - 17 optimization patterns for descriptions, prompts, tools, models\n  - multi-agent-patterns.md - Parallel and sequential orchestration strategies\n  - permission-modes.md - 5 permission modes with decision criteria and use cases\n  - plugin-agents.md - Plugin agent discovery, conflicts, and integration\n\n**Triggers:**\n- Deciding if a task should delegate to a subagent\n- Analyzing existing agent effectiveness\n- Recommending agent improvements and optimizations\n- Creating specialized agents for recurring patterns\n- Managing agents via /agents or CLI\n- Questions about resumable agents or continuing previous work\n\n---\n\n### managing-mcps\n\nComprehensive management of Model Context Protocol servers with Messages API integration, enterprise configuration, and plugin bundling.\n\n**Core Capabilities:**\n- **WF1: Evaluating if Logic Should Be MCP** - 6-criteria decision checklist\n- **WF2: Creating New MCP Server** - Complete workflow with HTTP priority guidance (7 steps)\n- **WF3: Analyzing Existing MCP** - Quality evaluation and improvement discovery (5 steps)\n- **WF4: Updating Outdated MCP** - Systematic modernization for new specifications (5 steps)\n- **WF5: Configuring MCP Connection** - CLI methods, .mcp.json structure, OAuth, plugin MCPs\n- **WF6: Using MCPs via Messages API** - Server configuration, MCPToolset patterns, beta headers, response handling\n- **WF7: Using MCPs in Conversations** - Resources (@server:path), prompts (/mcp__server__prompt), output limits\n\n**Key Features:**\n- **95%+ Official Documentation Coverage**: Complete alignment with code.claude.com/docs/en/mcp and docs.claude.com/en/docs/agents-and-tools\n- **Progressive Disclosure**: Core workflows in SKILL.md (557 lines), advanced topics loaded on-demand for token efficiency\n- **HTTP Transport Priority**: Explicit guidance - HTTP recommended for remote servers (better cloud support, more reliable)\n- **Messages API Integration**: Complete programmatic workflow with Python examples, allowlist/denylist/mixed MCPToolset patterns\n- **AWS Bedrock Patterns**: Production-ready modular architecture using FastMCP framework with decorator-based tool registration\n- **FastMCP Quick Start**: Minimal template for rapid Python MCP development with type hints and docstrings\n- **Cross-Skill References**: managing-plugins (plugin bundling), managing-prompts (prompt templates)\n- **Token-Efficient Loading**: Common workflows (create/analyze) load minimal files, API integration loads detailed reference\n- **Complete CLI Coverage**: All commands documented (add, add-json, add-from-claude-desktop, serve, reset-project-choices)\n- **13 Supporting Files:**\n  - Core: `architecture-overview.md`, `creation-guide.md`, `analysis-framework.md`, `configuration-guide.md`, `security-best-practices.md`\n  - Advanced: `mcp-connector-api-integration.md` (Messages API workflow), `enterprise-mcp-configuration.md` (org policies), `environment-variable-expansion.md` (team configs), `plugin-mcp-servers.md` (plugin bundling), `mcp-resources-and-prompts.md` (conversation usage), `oauth-authentication-flow.md` (OAuth setup), `deprecation-notes.md` (SSE ‚Üí HTTP migration)\n  - Reference: `examples.md` (AWS Bedrock, FastMCP templates)\n\n**Triggers:**\n- Deciding if logic should become an MCP\n- Creating MCP servers (stdio, HTTP, remote)\n- Analyzing/improving existing MCPs\n- Connecting MCPs to Claude Code\n- Integrating MCPs via Messages API\n- Questions about MCP concepts, configuration, security, OAuth\n- Enterprise configuration, team-shared configs, plugin MCPs\n\n---\n\n## Planned Features\n\nAll core capability management skills have been released in v1.6.0. Future releases will focus on maintenance, updates, and community-requested enhancements.\n\n## Installation\n\n### Via Claude Code Marketplace\n\n```bash\n# Install from the Claude Code Toolkit marketplace\nclaude-code plugin install claude-code-capabilities\n```\n\n### Manual Installation\n\n1. Clone the repository:\n```bash\ngit clone https://github.com/thoeltig/claude-code-toolkit.git\ncd claude-code-toolkit\n```\n\n2. Copy to your Claude plugins directory:\n```bash\n# On macOS/Linux\ncp -r plugins/claude-code-capabilities ~/.claude/plugins/\n\n# On Windows\nxcopy /E /I plugins\\claude-code-capabilities %USERPROFILE%\\.claude\\plugins\\claude-code-capabilities\n```\n\n3. Restart Claude Code or reload plugins\n\n## Usage\n\n### Model Selection Guide\n\n**Haiku/Sonnet/Opus** are Claude model tiers with cost/capability trade-offs:\n- **Haiku**: ~$0.25/M output tokens - efficient for synthesis (organizing/formatting known information)\n- **Sonnet**: ~$3/M output tokens - balanced for evaluation (quality assessment, reasoning, security analysis)\n- **Opus**: ~$15/M output tokens - reserve for complex novel reasoning\n\n**Token**: Unit of text processing (~4 characters). More tokens = higher API costs. Efficient data formats (JSON/YAML) and model selection reduce token usage.\n\n---\n\n### Managing Agent Skills\n\nThe managing-agent-skills skill activates automatically when:\n- You mention \"skill\", \"agent capability\", or \"reusable workflow\" in creation/improvement context\n- You ask questions about skill concepts, structure, or authoring\n- You request skill analysis or evaluation\n- You want to convert repeated logic into a skill\n\n**Example Conversations:**\n```\nYou: \"I need to create a skill for managing database migrations\"\nClaude: [Activates managing-agent-skills skill, walks through WF1: Creating]\n\nYou: \"Can you analyze my existing skill and suggest improvements?\"\nClaude: [Activates managing-agent-skills skill, performs WF2: Analysis with rubric]\n\nYou: \"Should this logic be a skill?\"\nClaude: [Activates managing-agent-skills skill, uses WF3: Conversion decision matrix]\n```\n\n#### Technical Implementation Notes\n\n**Information Gathering**\n- **WebFetch**: Returns 30-80% summarized content. Complex topics need 2-3+ fetches (overview ‚Üí details ‚Üí verification)\n- **Data format efficiency**: JSON/YAML (30% less context) > Markdown (20% less) > Plain text (highest parsing overhead)\n- **Local files preferred**: No summarization loss, complete access\n- **Validation required**: WF1 (create) and WF2 (analyze) are separate passes. Skipping WF2 risks incomplete/incorrect skills\n\n**Model Selection**\n| Stage | Model | Rationale | Cost |\n|-------|-------|-----------|------|\n| WF1: Write | Haiku | Synthesis: organize info into structured SKILL.md | Base |\n| WF2: Validate | Sonnet | Evaluation: 14-point rubric, gap analysis | ~3x Haiku |\n| Edge cases | Opus | Complex structural issues only | ~15x Haiku |\n\n**Pattern**: Haiku write ‚Üí Sonnet validate. If WF2 reports minimal changes, Haiku quality was sufficient.\n\n---\n\n### Managing Hooks\n\nThe managing-hooks skill activates automatically when:\n- You request hook creation or configuration\n- You ask about hook types, event lifecycle, or event-driven automation\n- You mention specific hook events (PreToolUse, SessionStart, Stop, etc.)\n- You want to validate, analyze, or debug existing hooks\n- You ask about prompt-based or plugin hooks\n- You need MCP tool integration patterns\n\n**Example Conversations:**\n```\nYou: \"Create a hook to format Python files after I edit them\"\nClaude: [Activates managing-hooks skill, walks through WF1: Creating]\n\nYou: \"How do prompt-based hooks work for intelligent decisions?\"\nClaude: [Activates managing-hooks skill, covers prompt-based patterns with examples]\n\nYou: \"Can multiple plugins' hooks work together?\"\nClaude: [Activates managing-hooks skill, explains WF2.5: Plugin composition patterns]\n\nYou: \"I need to validate all MCP write operations\"\nClaude: [Activates managing-hooks skill, covers WF3: MCP tool targeting]\n```\n\n#### Technical Implementation Notes\n\n**Security Validation**\n- **Model tier**: Sonnet minimum for WF2 (analysis). Haiku cannot assess security implications adequately\n- **User review required**: Sonnet validates structure/syntax, not intent or side effects. Review:\n  - Command correctness and system impact\n  - Event trigger timing and lifecycle edge cases\n  - Permission scope and data access\n- **Sandbox testing**: Test command-based hooks in isolated environment before production to verify runtime behavior\n\n---\n\n### Managing Plugins\n\nThe managing-plugins skill activates automatically when:\n- You request plugin creation, bundling, or packaging\n- You ask about plugin structure, plugin.json, or marketplace configuration\n- You mention plugin validation or distribution\n- You ask about team plugin workflows or autoInstall configuration\n- You need to bundle skills, commands, hooks, or MCPs\n\n**Example Conversations:**\n```\nYou: \"Bundle all my git-related skills into a plugin\"\nClaude: [Activates managing-plugins skill, walks through OP2: Bundle Components]\n\nYou: \"Create a marketplace config for my team plugins\"\nClaude: [Activates managing-plugins skill, covers OP3: Create Marketplace Config]\n\nYou: \"Validate my plugin structure before sharing\"\nClaude: [Activates managing-plugins skill, performs OP4: Validate Plugin]\n\nYou: \"How do I set up autoInstall for team members?\"\nClaude: [Activates managing-plugins skill, explains team configuration workflow]\n```\n\n#### Technical Implementation Notes\n\n**Structural Validation**\n- **Model tier**: Haiku for creation (OP1-3), Sonnet for validation (OP4)\n- **Rationale**: Validation checks schema compliance, file organization, naming conventions (deterministic, not reasoning-heavy)\n- **Cost efficiency**: Haiku synthesis ‚Üí Sonnet structural validation typically requires minimal corrections\n\n---\n\n### Managing Prompts\n\nThe managing-prompts skill activates automatically when:\n- You request prompt creation, analysis, or optimization\n- You ask about prompt engineering techniques or best practices\n- You mention Claude 4.5 optimization, hallucinations, or consistency issues\n- You ask about Structured Outputs, prompt caching, or extended thinking\n- You need to migrate prompts from Claude 3 to Claude 4.5\n- You want to decide if logic should be in a prompt vs script\n\n**Example Conversations:**\n```\nYou: \"Analyze this prompt and suggest improvements\"\nClaude: [Activates managing-prompts skill, performs WF1: Analyzing with rubric]\n\nYou: \"Create a prompt for analyzing customer feedback\"\nClaude: [Activates managing-prompts skill, walks through WF2: Creating with architecture selection]\n\nYou: \"How do I reduce hallucinations in my prompt?\"\nClaude: [Activates managing-prompts skill, covers guardrails implementation patterns]\n\nYou: \"Should I use Structured Outputs or prefilling?\"\nClaude: [Activates managing-prompts skill, provides decision flow and comparison]\n\nYou: \"Optimize this prompt for token efficiency\"\nClaude: [Activates managing-prompts skill, performs WF3: Optimizing with caching strategies]\n```\n\n#### Technical Implementation Notes\n\n**Reasoning-Heavy Workflows**\n- **Model tier**: Sonnet minimum for all workflows (WF1-5). No Haiku synthesis pass.\n- **Rationale**: Prompt engineering requires reasoning, not just formatting:\n  - Quality assessment: Evaluate guardrails, hallucination risks, technique trade-offs\n  - Architecture decisions: Structured Outputs vs prefilling, sequential vs parallel chaining\n  - Claude 4.5 optimization: When to apply extended thinking, caching, or chain-of-thought\n  - Technique selection: Context-dependent reasoning about what patterns apply\n- **Cannot separate write/validate**: Analysis and creation are intertwined (unlike skill synthesis)\n- **Opus**: Reserve for novel patterns or security-critical prompt applications\n\n---\n\n### Managing Subagents\n\nThe managing-subagents skill activates automatically when:\n- You need to decide if a task should delegate to a subagent\n- You want to analyze or evaluate an existing subagent\n- You request improvements to a subagent's configuration\n- You need to create a new specialized subagent\n- You ask about subagent concepts, decision patterns, or management\n\n**Example Conversations:**\n```\nYou: \"Should I use a subagent to search this large codebase?\"\nClaude: [Activates managing-subagents skill, scores task 0-10, recommends Explore agent]\n\nYou: \"Analyze this existing agent and suggest improvements\"\nClaude: [Activates managing-subagents skill, evaluates against analysis framework]\n\nYou: \"I need a security auditing agent for Python code\"\nClaude: [Activates managing-subagents skill, creates specialized agent using patterns]\n\nYou: \"How do permission modes affect agent behavior?\"\nClaude: [Activates managing-subagents skill, explains 5 modes with use cases]\n```\n\n#### Technical Implementation Notes\n\n**Decision & Optimization Focus**\n- **Model tier**: Haiku for scoring/decision, Sonnet for analysis and creation\n- **Rationale**: Task scoring is deterministic (0-10 points), but agent analysis and creation require reasoning\n- **Pattern**: Quick decision (Haiku) ‚Üí detailed evaluation (Sonnet) if improvement needed\n- **Cost efficiency**: Many decisions can be made with Haiku, escalate to Sonnet only for optimization\n\n---\n\n### Managing Slash Commands\n\nThe managing-slash-commands skill activates automatically when:\n- You request slash command creation or configuration\n- You ask about command syntax, structure, or best practices\n- You mention \"slash command\", \"command file\", or \"/command\" in creation/improvement context\n- You want to analyze or improve existing commands\n- You ask about SlashCommand tool, plugin commands, or MCP commands\n- You need to decide between creating a command vs a skill\n\n**Example Conversations:**\n```\nYou: \"Create a slash command to review pull requests\"\nClaude: [Activates managing-slash-commands skill, walks through WF1: Creating]\n\nYou: \"Analyze this command and suggest improvements\"\nClaude: [Activates managing-slash-commands skill, performs WF2: Analyzing with evaluation]\n\nYou: \"Should I convert this logic to a slash command or skill?\"\nClaude: [Activates managing-slash-commands skill, uses WF3: Decision framework]\n\nYou: \"How do I use extended thinking in a slash command?\"\nClaude: [Activates managing-slash-commands skill, covers thinking mode patterns]\n\nYou: \"What's the SlashCommand tool and how does it work?\"\nClaude: [Activates managing-slash-commands skill, explains programmatic invocation]\n```\n\n#### Technical Implementation Notes\n\n**Command Creation and Validation**\n- **Model tier**: Haiku for simple commands (WF1), Sonnet for analysis (WF2) and optimization\n- **Rationale**: Command creation is synthesis (formatting prompts), but analysis requires evaluation\n- **Script-based commands**: When using helper scripts, validate scripts independently first\n- **Prompt content**: For complex prompt engineering within commands, consider using managing-prompts skill for advanced patterns\n- **Cost efficiency**: Haiku for straightforward commands ‚Üí Sonnet for quality assessment and improvements\n\n---\n\n### Managing MCPs\n\nThe managing-mcps skill activates automatically when:\n- You need to decide if logic should become an MCP server\n- You request MCP server creation (stdio, HTTP, remote)\n- You want to analyze or improve existing MCPs\n- You ask about MCP configuration, connection, or security\n- You mention Messages API integration or MCPToolset patterns\n- You ask about OAuth authentication, enterprise policies, or team configs\n- You need to bundle MCPs in plugins\n\n**Example Conversations:**\n```\nYou: \"Should I create an MCP for this database access layer?\"\nClaude: [Activates managing-mcps skill, evaluates using WF1: Decision checklist with 6 criteria]\n\nYou: \"Create an HTTP MCP server using FastMCP for GitHub integration\"\nClaude: [Activates managing-mcps skill, walks through WF2: Creating with HTTP priority guidance]\n\nYou: \"How do I use my MCP via the Messages API with allowlist?\"\nClaude: [Activates managing-mcps skill, covers WF6: Messages API with MCPToolset patterns]\n\nYou: \"Analyze this existing MCP and suggest improvements\"\nClaude: [Activates managing-mcps skill, performs WF3: Analysis with quality evaluation]\n\nYou: \"Configure OAuth authentication for my MCP server\"\nClaude: [Activates managing-mcps skill, references oauth-authentication-flow.md guide]\n```\n\n#### Technical Implementation Notes\n\n**Progressive Disclosure and Token Efficiency**\n- **Model tier**: Haiku for decision (WF1), Sonnet for creation (WF2) and analysis (WF3)\n- **Rationale**: Token-optimized loading strategy based on usage patterns\n  - Common workflows (create/analyze MCPs - 80% of usage): Load SKILL.md + creation-guide.md + examples.md (minimal)\n  - Rare workflows (Messages API integration - 5% of usage): Load mcp-connector-api-integration.md (detailed, 300+ lines)\n  - Result: 100-150 line token savings for common cases while preserving detailed information on-demand\n- **HTTP Transport Priority**: HTTP recommended over stdio for remote servers (better cloud support, more reliable)\n- **Cross-skill references**: References managing-plugins for plugin bundling, managing-prompts for prompt templates\n- **Security validation**: Always validate OAuth flows and enterprise policies with Sonnet minimum\n- **Cost efficiency**: Quick decision (Haiku) ‚Üí detailed creation/analysis (Sonnet) for reasoning-heavy workflows\n\n## Documentation Sources\n\nThis plugin is built from official Claude Code documentation:\n- code.claude.com\n- docs.claude.com (Agent SDK)\n- platform.anthropic.com (Anthropic API)\n- GitHub cookbook examples\n\nOver 74 documentation files were analyzed and synthesized into the current implementation.\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/cross-platform-notification/README.md": "# Cross-Platform Notification Plugin\n\nA Claude Code plugin with a hook that sends native system notifications for Claude Code notifications. Get alerted when tasks complete, operations finish, or other Claude Code events occur‚Äîdirectly on your desktop.\n\n## Features\n\n- üîî Native system notifications on Windows, macOS, and Linux\n- üéØ Hooks into Claude Code events (PostToolUse, SessionStart, etc.)\n- üí¨ Custom notification messages from hook event data\n- üîÑ Automatic fallback to console output if native notifications unavailable\n- üîä Sound alerts on supported platforms\n- üì¶ Zero configuration required\n\n## Installation\n\n### Via Claude Code Plugin Command\n\n```bash\n/plugin install cross-platform-notification\n```\n\n### Manual Installation\n\n1. Clone or download this plugin to your Claude Code plugins directory:\n   ```bash\n   ~/.claude/plugins/cross-platform-notification\n   ```\n\n2. Restart Claude Code or reload plugins\n\n## Platform Requirements\n\n### Windows\n- PowerShell (included with Windows 10+)\n- Windows 10 or later for native toast notifications\n\n### macOS\n- `terminal-notifier` (install via Homebrew):\n  ```bash\n  brew install terminal-notifier\n  ```\n\n### Linux\n- `notify-send` (usually pre-installed)\n  ```bash\n  # Ubuntu/Debian\n  sudo apt-get install libnotify-bin\n\n  # Fedora\n  sudo dnf install libnotify\n  ```\n\n## How It Works\n\nThe plugin registers a notification hook that intercepts Claude Code events and displays system notifications with:\n- Event-specific messages\n- Consistent branding (Claude Code title)\n- Platform-native appearance and sound\n\nWhen a hook event occurs:\n1. Event data is passed to the `claude_code_notifier.py` script\n2. Script extracts the message from event data\n3. Platform-specific notification system is triggered\n4. If notification fails, message falls back to console output\n\n## Configuration\n\nNo configuration needed. The plugin works out of the box with sensible defaults:\n- Uses your system's default notification sound (macOS)\n- Displays notifications in system notification center\n- Automatically detects your OS\n\n## Usage\n\nOnce installed, the plugin automatically sends notifications for Claude Code events. You'll see native notifications like:\n\n**Windows**: Windows 10+ toast notification\n**macOS**: Notification Center alert with sound\n**Linux**: Desktop notification via notify-send\n\n## Troubleshooting\n\n**Notifications not appearing?**\n- Verify platform requirements are installed (see Platform Requirements above)\n- Check console output (fallback): `Claude Code` label indicates plugin executed\n- On macOS, check Notification Center settings for Claude Code\n- On Linux, verify notify-send is working: `notify-send \"Test\" \"Message\"`\n\n**Sound not playing?**\n- macOS: Check System Preferences > Sound > Do Not Disturb settings\n- Windows/Linux: Notifications still appear visually even if sound is muted\n\n**Python script errors?**\n- Ensure Python 3.13+ is installed\n- On Windows, verify PowerShell execution policy allows scripts:\n  ```powershell\n  Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n  ```\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)",
        "plugins/transcript-duplicate-scrubber/README.md": "# Transcript Duplicate Scrubber Plugin\n\nRemove duplicate file reads from Claude Code transcripts to reduce token waste and lower hallucination risk when resuming sessions.\n\n## What It Does\n\nDuring development, you naturally read the same file multiple times:\n- Read file to understand it\n- Edit it\n- Read again to verify (duplicate - replace)\n- User and Model exchange messages\n- Read again as new starting point (duplicate - keep)\n- Edit again\n- Read again to confirm\n\nEach read gets stored in the session transcript. When you use `/resume`, Claude Code reconstructs the entire conversation from the transcript. Duplicate reads waste tokens that don't add new information‚Äîthey just repeat what Claude already saw.\n\nThis plugin removes those duplicates by keeping only the latest read (or the Write if one exists with the same content). The result is a smaller transcript that costs less to reconstruct on resume, preserving the most recent and highest-priority context.\n\n## When to Use This\n\n**This helps if you:**\n- Frequently use `/resume` to continue previous sessions\n- Work with long sessions that have heavy file reading\n- Want to reduce token costs and context bloat\n\n**This won't help if you:**\n- Don't use `/resume` (run new sessions each time)\n- Have short, one-off sessions\n\n## Installation\n\n**Requirements:** Python 3.X (developed with 3.1.3)\n\nThe plugin automatically registers and runs on session resume. No configuration needed.\n\n## Usage\n\n### Automatic (Hook Mode)\n\nThe plugin runs automatically when you end a session:\n\n```bash\n[End session with /exit, Ctrl+C, or naturally]\n# Plugin cleans transcript as session closes\n```\n\nOutput when duplicates are found:\n```\nDeduplicated 12 file reads with same content from conversation which cleared up 45230 wasted characters.\n```\n\nThe cleaned transcript benefits all future resumes of that session.\n\n### Manual (CLI Mode)\n\nPreview what would be removed:\n```bash\npython dedup_transcript.py <transcript_file> --dry-run\n```\n\nApply deduplication:\n```bash\npython dedup_transcript.py <transcript_file>\n```\n\n## How It Works\n\nThe plugin detects reads with duplicate content hashes and applies two deduplication rules:\n\n**Rule 1: Write has priority**\nIf a Write operation has content hash X, all Reads with that same hash are marked redundant (the Write already has the content):\n```\nWrite file.txt ‚Üí \"content X\"\n[Messages exchanged]\nRead file.txt ‚Üí \"content X\"  ‚Üê Marked as DEDUPLICATION_READ_AFTER_WRITE_MARKER (redundant)\n```\n\n**Rule 2: Keep latest read**\nIf no Write has that hash, keep only the latest Read and mark all earlier reads with the same hash as redundant:\n```\nRead file.txt ‚Üí \"content X\" (first)  ‚Üê Marked as DEDUPLICATION_MULTIPLE_READS_MARKER (older)\n[Messages exchanged]\nRead file.txt ‚Üí \"content X\" (latest)  ‚Üê Kept (newest tokens, higher priority)\n```\n\n**Different content is always kept:**\n```\nRead file.txt ‚Üí \"content X\"\n[Edit happens]\nRead file.txt ‚Üí \"content Y\"  ‚Üê Different hash, both kept\n```\n\nFor each redundant read, the plugin replaces the content with a marker. Two marker types indicate the deduplication reason:\n```\n<DEDUPLICATION_READ_AFTER_WRITE_MARKER|OMITTED_CHARS_COUNT:2847>\n<DEDUPLICATION_MULTIPLE_READS_MARKER|OMITTED_CHARS_COUNT:2847>\n```\n\nAll intervening messages are preserved‚Äîonly the duplicate file content is removed.\n\n## Example Workflow\n\n```\nSession 1: Multiple edits with repeated file reads\n           [Plugin cleans duplicates on exit]\n                ‚Üì\nSession 2: /resume ‚Üí Load cleaned transcript\n           ‚Üí Smaller file = fewer tokens to reconstruct\n           ‚Üí Lower cost, lower hallucination risk\n```\n\n---\n\n## Known Limitations\n\n### Top-Level Context Percentage Lags (But Token Savings Are Visible)\n\nToken savings **are immediately visible**, but appear in different places within `/context`:\n\n**‚úÖ Already Updated (Real Savings Shown):**\n- Messages section: Drops from higher to lower count (e.g., 47.9k ‚Üí 17.3k)\n- Free space: Increases (e.g., 128k ‚Üí 158k)\n\n**‚ö†Ô∏è Lags Behind:**\n- Top-level percentage: Still shows pre-deduplication value (e.g., stays at 35%) until cache invalidates\n\n**Why this split happens:**\n\nThe top-level percentage is calculated from `input_tokens + cache_creation_input_tokens + cache_read_input_tokens` which contains the cached token values from the current prompt cache. Since deduplication modified the persisted transcript and not the prompt cache these cached values don't update immediately. The messages and free space sections recalculate differently and reflect the actual smaller transcript right away.\n\nWhen the prompt cache invalidates (by default after 5 minutes), it tokenizes the deduplicated transcript and the top-level percentage updates to match.\n\n**Practical benefit when approaching context limits:**\n\nThe real token savings are **already usable** via the messages and free space readings. If you're near capacity:\n- Messages section shows actual savings (real context available)\n- Free space shows accurate headroom\n- You can confidently stay under limits based on these numbers\n\nIf you want the top-level percentage updated immediately, exit and wait for cache invalidation, then resume‚Äîthe deduplicated transcript reloads fresh.\n\n---\n\n## Technical Explanation\n\n**Why duplicate reads matter:**\n\nClaude prioritizes newer tokens over older ones during reasoning. This means older context gets deprioritized. During a session, you naturally re-read files to keep them \"fresh\" at the top of context:\n- Read file to understand logic\n- Exchange messages, discuss changes\n- Read file again (pushes it to newer tokens, higher priority)\n- Exchange more messages\n- Read file again (refreshes context, pushes it further up)\n\nThis is intentional and helps during active work. But when you `/resume`, Claude reconstructs the entire conversation from the transcript, which costs tokens (~600k+ per large session) to rebuild all that history. The duplicate reads‚Äîsame file, same content hash‚Äîdon't add information value to the reconstruction. They just repeat what's already there.\n\nThe plugin removes those redundant reads while keeping intervening messages intact. This shrinks the transcript that needs reconstruction on resume, lowering the overhead cost.\n\n**How it differs from `/compact`:**\n\n`/compact` uses an LLM to summarize early conversation and remove detail. It's non-deterministic and can lose information. This plugin uses deterministic hash-based deduplication‚Äîit only removes exact duplicates of file content, never loses information, and never makes LLM-based decisions.\n\n**When deduplication activates:**\n\nThe plugin runs on session end (SessionEnd hook), not on resume. This is because:\n- **SessionStart (resume)** runs after the transcript is already loaded - deduplication would only help future resumes\n- **SessionEnd** runs as the session closes, modifying the persisted transcript before it's finalized\n- The next time you resume that session, it loads the cleaned transcript directly\n- Benefit accumulates: Each resume pays less reconstruction cost due to smaller base file\n\n**Example cost benefit:**\n\nIf a session's transcript is 5MB with 200KB of duplicates:\n- Current `/resume`: Reconstructs full 5MB\n- After dedup: Reconstructs 4.8MB (~4% savings per resume)\n- Over 5 resumes: Saves ~250K reconstruction tokens total\n\n---\n\n## Version History\n\nSee [CHANGELOG.md](./CHANGELOG.md) for complete version history.\n\n## License\n\nSee root [LICENSE](../../LICENSE) for details.\n\n## Support\n\n- **Issues**: [Report bugs or request features](https://github.com/thoeltig/claude-code-toolkit/issues)\n- **Repository**: [claude-code-toolkit](https://github.com/thoeltig/claude-code-toolkit)\n\n---\n\n**Author**: [Thore H√∂ltig](https://github.com/thoeltig)"
      },
      "plugins": [
        {
          "name": "session-protocol",
          "source": "./plugins/session-protocol",
          "description": "Save your active tasks between sessions for seamless continuity and never loss context again.",
          "version": "1.2.0.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install session-protocol@claude-code-toolkit"
          ]
        },
        {
          "name": "project-intel",
          "source": "./plugins/project-intel",
          "description": "Lightweight reconnaissance system that provides direction before exploration. Query for relevant files before reading them - avoid expensive blind exploration and context pollution.",
          "version": "1.5.1.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install project-intel@claude-code-toolkit"
          ]
        },
        {
          "name": "fetch-full-content",
          "source": "./plugins/fetch-full-content",
          "description": "Download full page content from URLs to markdown for the purpose of full information retrieval without summarization. Applies basic filtering to remove hidden content injection but this is NO prompt injection detection or guard. Should only be used on official and trusted sources like documentations.",
          "version": "1.2.0.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install fetch-full-content@claude-code-toolkit"
          ]
        },
        {
          "name": "changelog",
          "source": "./plugins/changelog",
          "description": "CHANGELOG.md management following Keep a Changelog format",
          "version": "1.1.0.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install changelog@claude-code-toolkit"
          ]
        },
        {
          "name": "documentation",
          "source": "./plugins/documentation",
          "description": "Comprehensive skill for creating, updating, and maintaining high-quality project documentation",
          "version": "1.0.0.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install documentation@claude-code-toolkit"
          ]
        },
        {
          "name": "claude-code-capabilities",
          "source": "./plugins/claude-code-capabilities",
          "description": "Comprehensive management of Claude Code features including skills, commands, hooks, MCPs, prompts, and subagents",
          "version": "1.8.0.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install claude-code-capabilities@claude-code-toolkit"
          ]
        },
        {
          "name": "cross-platform-notification",
          "source": "./plugins/cross-platform-notification",
          "description": "A Claude Code plugin with a hook that sends native system notifications for Claude Code notifications.",
          "version": "1.0.0.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install cross-platform-notification@claude-code-toolkit"
          ]
        },
        {
          "name": "transcript-duplicate-scrubber",
          "source": "./plugins/transcript-duplicate-scrubber",
          "description": "Remove duplicate file reads from transcripts to reduce token waste, lower hallucination risk and preserve context priority when resuming sessions.",
          "version": "1.0.0.0",
          "author": {
            "name": "Thore H√∂ltig"
          },
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoeltig/claude-code-toolkit",
            "/plugin install transcript-duplicate-scrubber@claude-code-toolkit"
          ]
        }
      ]
    }
  ]
}