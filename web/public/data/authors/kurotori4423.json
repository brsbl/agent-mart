{
  "author": {
    "id": "kurotori4423",
    "display_name": "Kurotori",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/42085932?u=c38a9b4197343eb19b331f8863bc1b560bdb1792&v=4",
    "url": "https://github.com/kurotori4423",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "udonsharp-coding-skill",
      "version": null,
      "description": "UdonSharp coding utilities and scripts for VRChat.",
      "owner_info": {
        "name": "kurotori"
      },
      "keywords": [],
      "repo_full_name": "kurotori4423/udonsharp-coding-skill",
      "repo_url": "https://github.com/kurotori4423/udonsharp-coding-skill",
      "repo_description": "Agent Skills for UdonSharp",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-22T02:43:32Z",
        "created_at": "2026-01-19T15:04:20Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 542
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1312
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/udonsharp-coding",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/udonsharp-coding/SKILL.md",
          "type": "blob",
          "size": 3683
        },
        {
          "path": "skills/udonsharp-coding/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/udonsharp-coding/references/en",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_class.md",
          "type": "blob",
          "size": 2181
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network.md",
          "type": "blob",
          "size": 8369
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network/01_basics_minimum.md",
          "type": "blob",
          "size": 1637
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network/02_implementation.md",
          "type": "blob",
          "size": 1663
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network/03_sync_options.md",
          "type": "blob",
          "size": 881
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network/04_synced_types.md",
          "type": "blob",
          "size": 1700
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network/05_design_tips.md",
          "type": "blob",
          "size": 696
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_network/README.md",
          "type": "blob",
          "size": 1144
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_persistence.md",
          "type": "blob",
          "size": 5515
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_playerTracking.md",
          "type": "blob",
          "size": 1981
        },
        {
          "path": "skills/udonsharp-coding/references/en/udon_uGUI.md",
          "type": "blob",
          "size": 641
        },
        {
          "path": "skills/udonsharp-coding/references/jp",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/udonsharp-coding/references/jp/Troubleshooting.md",
          "type": "blob",
          "size": 2
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_class.md",
          "type": "blob",
          "size": 2323
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network.md",
          "type": "blob",
          "size": 11122
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network/01_basics_minimum.md",
          "type": "blob",
          "size": 2013
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network/02_implementation.md",
          "type": "blob",
          "size": 1844
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network/03_sync_options.md",
          "type": "blob",
          "size": 963
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network/04_synced_types.md",
          "type": "blob",
          "size": 1702
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network/05_design_tips.md",
          "type": "blob",
          "size": 839
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_network/README.md",
          "type": "blob",
          "size": 1274
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_persistence.md",
          "type": "blob",
          "size": 6804
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_playerTracking.md",
          "type": "blob",
          "size": 2216
        },
        {
          "path": "skills/udonsharp-coding/references/jp/udon_uGUI.md",
          "type": "blob",
          "size": 655
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\r\n    \"name\": \"udonsharp-coding-skill\",\r\n    \"owner\": {\r\n        \"name\": \"kurotori\"\r\n    },\r\n    \"metadata\": {\r\n        \"description\": \"UdonSharp coding utilities and scripts for VRChat.\",\r\n        \"version\": \"1.0.0\"\r\n    },\r\n    \"plugins\": [\r\n        {\r\n            \"name\": \"udonsharp-coding\",\r\n            \"description\": \"UdonSharp coding utilities and scripts for VRChat.\",\r\n            \"source\": \"./\",\r\n            \"strict\": false,\r\n            \"skills\": [\r\n                \"./skills/udonsharp-coding\"\r\n            ]\r\n        }\r\n    ]\r\n}",
        "README.md": "# udonsharp-coding-skill\n\nUdonSharpのコーディングを行う際に、AIエージェントがUdonSharpの知識と設計ノウハウを教えるためのAgent Skills\n\n- UdonSharpでの制限\n- ネットワーク同期に関するノウハウ \n\nが含まれており、何度もAIエージェントに対してUdonSharp特有の問題を教えなくても、これを考慮したコードが書かれるハズ。\n\n## インストール方法\n\n### Claude Code\n\nPluginとして導入できます。\n\n1. Claude Codeを起動\n2. コマンドパレットで以下を入力して、リポジトリを追加\n```\n/plugin marketplace add kurotori4423/udonsharp-coding-skill\n```\n3. 以下のコマンドでスキルをインストール\n```\n/plugin install udonsharp-coding\n```\n\n### Claude Code 以外 (GitHub Copilot や CODEXなど)\n\n[OpenSkills](https://github.com/numman-ali/openskills) でのインストールがオススメ。\n\n`Node.js`と`npm`が必要です。\n\n導入したいプロジェクトのルートフォルダで以下のコマンドを実行\n```\nnpx openskills install kurotori4423/udonsharp-coding-skill\n```\n\n## 使い方\n\n導入した状態でUdonSharpを書かせたりすれば、エージェントはこのスキルを見てUdonSharpのベストプラクティスに従って実装します。",
        "skills/udonsharp-coding/SKILL.md": "---\r\nname: udonsharp-coding\r\ndescription: A guide for coding with UdonSharp. Use this when you are asked to create or edit UdonSharp programs. Code that inherits from UdonSharpBehavior falls under UdonSharp code.\r\n---\r\n\r\nUdonSharp generally follows C# syntax, but its features are limited.\r\n\r\n# Supported C# Features\r\n\r\n- Flow control: `if`, `else`, `while`, `for`, `do`, `foreach`, `switch`, `return`, `break`, `continue`, `ternary operator (condition ? true : false)`, `??`\r\n- Implicit and explicit type conversions\r\n- Arrays and array indexers\r\n- All built-in arithmetic operators\r\n- Conditional short circuiting `(true || CheckIfTrue())` will not execute `CheckIfTrue()`\r\n- `typeof()`\r\n- Extern methods with `out` or `ref` parameters, such as many variants of `Physics.Raycast()`\r\n- User defined methods with parameters and return values, supports out/ref, extension methods, and `params`\r\n- User defined properties\r\n- Static user methods\r\n- UdonSharpBehaviour inheritence, virtual methods, etc\r\n- Unity/Udon event callbacks with arguments. For instance, registering an `OnPlayerJoined` event with a `VRCPlayerApi` argument is valid.\r\n- String interpolation\r\n- Field initializers\r\n- Jagged arrays\r\n- Referencing other custom UdonSharpBehaviour classes, accessing fields, and calling methods on them\r\n- Recursive method calls are supported via the `[RecursiveMethod]` attribute\r\n\r\n# Differences from Unity C#\r\n\r\n- Udon currently only supports array `[]` collections and by extension UdonSharp only supports arrays at the moment.\r\n- Field initilizers are evaluated at compile time, if you have any init logic that depends on other objects in the scene you should use Start for this.\r\n- Use the UdonSynced attribute on fields that you want to sync.\r\n- Numeric casts are checked for overflow due to UdonVM limitations\r\n- The internal type of variables returned by `.GetType()` will not always match what you may expect since U# abstracts some types in order to make them work in Udon. For instance, any jagged array type will return a type of `object[]` instead of something like `int[][]` for a 2D int jagged array.\r\n\r\n## Instantiate\r\n\r\nYou cannot create a new GameObject using `new GameObject()` and similar APIs. In UdonSharp, you create new objects by cloning an existing `GameObject` in the scene using `Instantiate()`. Additionally, only `GameObject` can be instantiated via `Instantiate()`.\r\n\r\n# Best Practices\r\n\r\n## Use `Utilities.IsValid` for null checks\r\n\r\n`bool IsValid(object obj)` returns true when `obj` is not null (or is otherwise valid). In UdonSharp, this is faster than doing null checks with `==`.\r\n\r\n# Basic Template\r\n\r\n```cs\r\nusing UdonSharp;\r\nusing UnityEngine;\r\nusing VRC.SDKBase;\r\nusing VRC.Udon;\r\n\r\npublic class UdonSharpScript : UdonSharpBehaviour\r\n{\r\n\r\n}\r\n```\r\n\r\n# Networking\r\n\r\nIf the problem you are addressing involves network synchronization, read the document `references/en/udon_network/README.md`. These documents describe the concepts and methods required to implement network logic in Udon.\r\n\r\n# Class Design\r\n\r\nIf you need shared logic, encapsulation, or inheritance, be aware that UdonSharp has important limitations. See `references/en/udon_class.md`.\r\n\r\n# Player Tracking\r\n\r\nIf you are implementing things like gaze-following objects or objects that follow avatar bones, see `references/en/udon_playerTracking.md`. It includes important notes and pitfalls for implementation.\r\n\r\n# Persistence\r\n\r\nIf you need to save player-specific data (like high scores, inventory, or settings) across sessions or instances, refer to `references/en/udon_persistence.md`. This document explains how to use PlayerData and PlayerObjects for persistent storage.",
        "skills/udonsharp-coding/references/en/udon_class.md": "# About Class Features\r\n\r\n## Inheritance\r\n\r\nUdonSharp allows you to use inheritance with your own classes derived from `UdonSharpBehaviour`.\r\nHowever, because interfaces are not available, it is not as flexible as “pure” C#.\r\n\r\n```cs\r\npublic class UdonBaseClass : UdonSharpBehaviour\r\n{\r\n    public virtual void Hello()\r\n    {\r\n        Debug.Log(\"Hello UdonBase\");\r\n    }\r\n}\r\n\r\npublic class UdonChildClass : UdonBaseClass\r\n{\r\n    public override void Hello()\r\n    {\r\n        Debug.Log(\"Hello UdonChild\");\r\n    }\r\n}\r\n```\r\n\r\nA common way to use this is to swap behavior via virtual methods (`virtual`/`override`), in a style close to the `Strategy Pattern` (implemented via inheritance) or the `Template Method Pattern` (put the shared flow in the base class and override only a part in derived classes).\r\n\r\nFor example, you can make internal logic replaceable, or unify differences in input methods (keyboard / VR controllers, etc.) as a “pseudo interface” in the base class and switch implementations by using derived classes.\r\n\r\n### Implementation Example\r\n\r\nThis example keeps the shared logic (movement) in the base class and replaces only the input part in derived classes (closer to the `Template Method Pattern`).\r\n\r\n```cs\r\nusing UdonSharp;\r\nusing UnityEngine;\r\nusing VRC.Udon.Common;\r\n\r\npublic class BaseMover : UdonSharpBehaviour\r\n{\r\n    [SerializeField] private float speed = 2f;\r\n\r\n    protected virtual Vector3 GetMoveDir() => Vector3.zero;\r\n\r\n    private void Update()\r\n    {\r\n        transform.position += GetMoveDir() * (speed * Time.deltaTime);\r\n    }\r\n}\r\n\r\n// Keyboard input\r\npublic class KeyboardMover : BaseMover\r\n{\r\n    protected override Vector3 GetMoveDir()\r\n        => new Vector3(Input.GetAxisRaw(\"Horizontal\"), 0f, Input.GetAxisRaw(\"Vertical\"));\r\n}\r\n\r\n// VR input (Udon Input Events)\r\npublic class VrcMoveAxisMover : BaseMover\r\n{\r\n    private float x;\r\n    private float z;\r\n\r\n    public override void InputMoveHorizontal(float value, UdonInputEventArgs args) => x = value;\r\n    public override void InputMoveVertical(float value, UdonInputEventArgs args) => z = value;\r\n    protected override Vector3 GetMoveDir() => new Vector3(x, 0f, z);\r\n}\r\n```\r\n",
        "skills/udonsharp-coding/references/en/udon_network.md": "# Networking in Udon\r\n\r\nIn Udon, objects with `UdonBehavior` or `UdonSharpBehavior` that are network-synced have the concept of an `Owner`.\r\nIn VRChat, the player called the `Owner` is responsible for syncing that object’s data. The `Owner` keeps the master data and sends it to other clients that are not the `Owner`.\r\nOnly the `Owner` can modify synced data. Non-owners can only read it.\r\n\r\n## Owner lookup\r\n\r\nTo get the owner of a specific GameObject, use:\r\n`VRCPlayerAPI Networking.GetOwner(GameObject obj)`\r\n\r\nTo check whether the local player is the owner, use:\r\n`bool Networking.IsOwner(VRCPlayerApi player, GameObject obj)`\r\n\r\nTo transfer ownership to a specific player, use:\r\n`Networking.SetOwner(VRCPlayerApi player, GameObject obj)`\r\n\r\nWhen ownership is transferred, the following callback is invoked:\r\n\r\n```cs\r\npublic void override OnOwnershipTransferred(VRCPlayerApi player)\r\n{\r\n    Debug.Log($\"Ownership Transferred {player.displayName}\");\r\n}\r\n```\r\n\r\nWhen `SetOwner` is called, the previous owner receives a callback to approve or deny the request:\r\n\r\n```cs\r\npublic bool override OnOwnershipRequest(VRCPlayerApi requester, VRCPlayerApi newOwner)\r\n{\r\n    return true;\r\n}\r\n```\r\n\r\n## Sync modes\r\n\r\nSync mode determines how data is synchronized. In UdonSharp, set the `UdonBehaviorSyncMode` attribute on a class that inherits `UdonSharpBehavior`.\r\n\r\n```cs\r\n[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]\r\npublic class Example : UdonSharpBehaviour \r\n{ \r\n}\r\n```\r\n\r\n`UdonSharp.BehaviourSyncMode`\r\n\r\n|Name|Summary|\r\n|---|---|\r\n|None|Enforces no synced variables on the behaviour and hides the selection dropdown in the UI for the sync mode. Nothing is synced and SendCustomNetworkEvent will not work on the behaviour.|\r\n|Continuous|Synced variables will be updated automatically at a very frequent rate, but may not always reliably update to save bandwidth.|\r\n|Manual|Synced variables are updated manually by the user less frequently, but ensures that updates are reliable when requested.|\r\n|NoVariableSync|Enforces that there are no synced variables on the behaviour, hides the sync mode selection dropdown, and allows you to use the behaviours on GameObjects that use either Manual or Continuous sync.|\r\n\r\nFor performance reasons, use `Manual` whenever possible. Use `Continuous` only when you need frequent updates such as position syncing with interpolation.\r\n\r\n## Synced variables\r\n\r\nSynced variables are the parameters on an `UdonBehavior` component that are actually synchronized.\r\nIn UdonSharp, declare them with the `UdonSynced` attribute.\r\n\r\n```cs\r\n[UdonSynced]\r\npublic bool synchronizedBoolean;\r\n\r\n[UdonSynced(UdonSyncMode.Linear)]\r\npublic float synchronizedFloat;\r\n```\r\n\r\nAvailable `UdonSyncMode` options:\r\n\r\n|Name|Summary|\r\n|---|---|\r\n|NotSynced||\r\n|None|No interpolation (Default)|\r\n|Linear|Lerp|\r\n|Smooth|Some kind of smoothed syncing|\r\n\r\n`Linear` and `Smooth` only take effect when the sync mode is `Continuous`. With `Manual`, use `None` in most cases.\r\n\r\n### Supported synced types\r\n\r\n#### Boolean types\r\n| Type | Size    |\r\n| ---- | ------- |\r\n| bool | 1 byte  |\r\n#### Integral numeric types\r\n| Type   | Range                           | Size    |\r\n|--------|---------------------------------|---------|\r\n| sbyte  | -128 to 127                     | 1 byte  |\r\n| byte   | 0 to 255                        | 1 byte  |\r\n| short  | -32,768 to 32,767               | 2 bytes |\r\n| ushort | 0 to 65,535                     | 2 bytes |\r\n| int    | -2,147,483,648 to 2,147,483,647 | 4 bytes |\r\n| uint   | 0 to 4,294,967,295              | 4 bytes |\r\n| long   | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 8 bytes |\r\n| ulong  | 0 to 18,446,744,073,709,551,615 | 8 bytes |\r\n#### Floating-point numeric types\r\n| Type   | Approximate range             | Precision     | Size    |\r\n|--------|-------------------------------|---------------|---------|\r\n| float  | ±1.5 x 10^(−45) to ±3.4 x 10^(38)   | ~6-9 digits   | 4 bytes |\r\n| double | ±5.0 × 10^(−324) to ±1.7 × 10^(308) | ~15-17 digits | 8 bytes |\r\n#### Vector mathematics types and structures (Unity)\r\n| Type        | Range         | Size     |\r\n|-------------|---------------|----------|\r\n| Vector2   | same as float | 8 bytes  |\r\n| Vector3   | same as float | 12 bytes  |\r\n| Vector4   | same as float | 16 bytes |\r\n| Quaternion| same as float | 16 bytes  |\r\n#### Color structures\r\n| Type     | Range / Precision | Size    |\r\n|----------|-------------------|---------|\r\n| Color  | same as float     | 16 bytes |\r\n| Color32| same as byte      | 4 bytes |\r\n#### Text types and structures\r\n| Type   | Range            | Size           |\r\n|--------|------------------|----------------|\r\n| char   | U+0000 to U+FFFF | 2 bytes        |\r\n| string | same as char     | 2 bytes / char |\r\n#### Other structures\r\n| Type   | Range            | Size           |\r\n|--------|------------------|----------------|\r\n| VRCUrl | U+0000 to U+FFFF | 2 bytes / char |\r\n\r\n### Synced arrays\r\n\r\nYou can also sync arrays of the above types.\r\nOnly one-dimensional arrays are supported; jagged arrays are not synced.\r\nArrays must be initialized with `new`, even if the length is 0.\r\n\r\n## Manual sync of synced variables\r\n\r\nIf the sync mode is `Manual`, the owner must explicitly request sync.\r\nCalling this as a non-owner has no effect.\r\n\r\n```cs\r\nRequestSerialization();\r\n```\r\n\r\nWhen a sync is requested, the owner receives these callbacks in order:\r\n\r\n```cs\r\npublic override void OnPreSerialization()\r\n{\r\n    Debug.Log(\"Processing before data transfer\");\r\n}\r\n```\r\n\r\n```cs\r\npublic override void OnPostSerialization(VRC.Udon.Common.SerializationResult result)\r\n{\r\n    Debug.Log(\"Processing after data transfer\");\r\n}\r\n```\r\n\r\nOn non-owners, the following callback is invoked:\r\n```cs\r\npublic override void OnDeserialization()\r\n{\r\n    Debug.Log(\"Received synced data\");\r\n}\r\n```\r\nWhen this is called, synced variables are updated to the received values.\r\n\r\n## FieldChangeCallback\r\n\r\n`OnDeserialization()` fires for changes to all synced variables in the class.\r\nTo react only to a specific synced variable, use `FieldChangeCallback`:\r\n\r\n```cs\r\n[UdonSynced, FieldChangeCallback(nameof(SyncedToggle))]\r\nprivate bool _syncedToggle;\r\n\r\npublic bool SyncedToggle\r\n{\r\n    set\r\n    {\r\n        Debug.Log(\"toggling the object...\");\r\n        _syncedToggle = value;\r\n        toggleObject.SetActive(value);\r\n    }\r\n    get => _syncedToggle;\r\n}\r\n```\r\n\r\nThis callback fires even for the owner (unlike `OnDeserialization()`).\r\n\r\nNote: For arrays, this callback does not fire when elements change. It only fires when the array object itself changes.\r\n\r\n## SendCustomNetworkEvent\r\n\r\n`SendCustomNetworkEvent` executes a function across the network without using synced variables.\r\nIt can only target public functions.\r\n\r\n```cs\r\n\r\npublic Function()\r\n{\r\n    Debug.Log(\"Show All Player!\");\r\n}\r\n\r\n\r\nSendCustomNetworkEvent(NetworkEventTarget.All, nameof(Function));\r\n\r\n\r\n```\r\n\r\n`NetworkEventTarget` specifies who executes the function.\r\n\r\n|Name|Summary|\r\n|---|---|\r\n|All|All players in the instance|\r\n|Owner|Owner of the game object|\r\n|Others|All players except yourself|\r\n|Self|Only yourself|\r\n\r\nThis is mainly used for simultaneous, temporary events like sounds or effects.\r\nIt is not appropriate for state changes that must persist. Use synced variables for state changes.\r\n\r\nYou can also pass arguments by using the `NetworkCallable` attribute.\r\n\r\n```cs\r\nvoid Start()\r\n{\r\n    SendCustomNetworkEvent(NetworkEventTarget.All, nameof(Greet), \"hogehoge\");\r\n}\r\n\r\n[NetworkCallable]\r\npublic void Greet(string name)\r\n{\r\n    Debug.Log(name + \" さん、こんにちは！\");\r\n}\r\n\r\n```\r\n\r\n## Designing network logic\r\n\r\n### Reduce sync frequency as much as possible\r\n\r\nHigh-frequency sync can hit bandwidth limits and cause backlog.\r\nFor example, instead of syncing remaining time every second, sync the time when the timer ends. Then show the remaining time by comparing with local time. This reduces sync to a single transmission.\r\n\r\n### Choosing between SendCustomNetworkEvent and synced variables\r\n\r\nDecide based on whether late-joining players must see the result.\r\n\r\nFor example, sounds and effects that trigger at the same time do not need to play for late joiners, so use `SendCustomNetworkEvent`.\r\n\r\nConversely, game state or object positions that must be reproduced for late joiners should be implemented with synced variables.\r\n",
        "skills/udonsharp-coding/references/en/udon_network/01_basics_minimum.md": "# Minimum Implementation (Required)\r\n\r\nThis page lists only the minimum information required to implement networking.\r\n\r\n## 1. Owner basics\r\n\r\n- Network-synced objects have an `Owner`.\r\n- Only the **Owner** can modify synced data. Non-owners are read-only.\r\n\r\n## 2. Minimum Owner APIs\r\n\r\n- Get owner: `Networking.GetOwner(GameObject obj)`\r\n- Check owner: `Networking.IsOwner(VRCPlayerApi player, GameObject obj)`\r\n- Set owner: `Networking.SetOwner(VRCPlayerApi player, GameObject obj)`\r\n\r\n## 3. Defining synced variables\r\n\r\n- Add `[UdonSynced]` to fields that should be synchronized.\r\n- For syncing, use **Manual** with `UdonBehaviourSyncMode` as the baseline.\r\n\r\n```cs\r\n[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]\r\npublic class Example : UdonSharpBehaviour\r\n{\r\n    [UdonSynced]\r\n    public bool synchronizedFlag;\r\n}\r\n```\r\n\r\n## 4. Manual sync flow (shortest)\r\n\r\n- The Owner calls `RequestSerialization()` to send sync data.\r\n- Non-owners receive `OnDeserialization()` and apply the new values.\r\n\r\n```cs\r\npublic override void OnDeserialization()\r\n{\r\n    // Process after receiving synced data\r\n}\r\n```\r\n\r\n## 5. Syncing temporary events\r\n\r\n- Use `SendCustomNetworkEvent` for temporary events that don’t need to persist.\r\n- Only public methods can be invoked.\r\n\r\n```cs\r\npublic void PlayEffect()\r\n{\r\n    // Play effect, etc.\r\n}\r\n\r\nSendCustomNetworkEvent(NetworkEventTarget.All, nameof(PlayEffect));\r\n```\r\n\r\n## 6. Minimum checklist\r\n\r\n- [ ] Only the `Owner` changes synced data\r\n- [ ] Synced fields are marked with `[UdonSynced]`\r\n- [ ] `Manual` sync uses `RequestSerialization()`\r\n- [ ] Temporary events use `SendCustomNetworkEvent`\r\n",
        "skills/udonsharp-coding/references/en/udon_network/02_implementation.md": "# Implementation (Practice)\r\n\r\nThis page summarizes design decisions and callback usage needed for implementation.\r\n\r\n## 1. Choosing a sync mode\r\n\r\nSpecify the sync mode with `UdonBehaviourSyncMode`.\r\n\r\n- `Manual`: Explicit syncing. **Recommended in most cases.**\r\n- `Continuous`: Only when you need frequent updates like position interpolation.\r\n- `None`: No synced variables are expected.\r\n- `NoVariableSync`: No synced variables; only `SendCustomNetworkEvent`.\r\n\r\n```cs\r\n[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]\r\npublic class Example : UdonSharpBehaviour { }\r\n```\r\n\r\n## 2. State sync vs temporary events\r\n\r\n- **State must persist** → use `UdonSynced`\r\n- **Temporary effects/sounds** → use `SendCustomNetworkEvent`\r\n\r\n## 3. Ownership transfer and callbacks\r\n\r\nCallbacks for ownership changes:\r\n\r\n```cs\r\npublic override void OnOwnershipTransferred(VRCPlayerApi player)\r\n{\r\n    // Process when ownership changes\r\n}\r\n```\r\n\r\n```cs\r\npublic override bool OnOwnershipRequest(VRCPlayerApi requester, VRCPlayerApi newOwner)\r\n{\r\n    // Return true to allow the change\r\n    return true;\r\n}\r\n```\r\n\r\n## 4. Serialization hooks\r\n\r\nYou can hook into sync send/receive timing:\r\n\r\n```cs\r\npublic override void OnPreSerialization()\r\n{\r\n    // Before sending\r\n}\r\n\r\npublic override void OnPostSerialization(VRC.Udon.Common.SerializationResult result)\r\n{\r\n    // After sending\r\n}\r\n\r\npublic override void OnDeserialization()\r\n{\r\n    // After receiving\r\n}\r\n```\r\n\r\n## 5. Typical implementation flow\r\n\r\n1. Check `IsOwner` before making changes\r\n2. If needed, call `SetOwner` to acquire ownership\r\n3. Update synced variables\r\n4. Call `RequestSerialization()` to send updates\r\n",
        "skills/udonsharp-coding/references/en/udon_network/03_sync_options.md": "# Supplement: Sync Options / Callbacks\r\n\r\nThis page contains supplemental information for implementation.\r\n\r\n## 1. UdonSyncMode (interpolation)\r\n\r\n`UdonSyncMode` is mainly effective with `Continuous`.\r\n\r\n- `None`: no interpolation (default)\r\n- `Linear`: linear interpolation (Lerp)\r\n- `Smooth`: smoothed interpolation\r\n\r\n```cs\r\n[UdonSynced(UdonSyncMode.Linear)]\r\npublic float synchronizedFloat;\r\n```\r\n\r\n## 2. FieldChangeCallback\r\n\r\nUse this when you want to react only to a specific synced variable.\r\n\r\n```cs\r\n[UdonSynced, FieldChangeCallback(nameof(SyncedToggle))]\r\nprivate bool _syncedToggle;\r\n\r\npublic bool SyncedToggle\r\n{\r\n    set\r\n    {\r\n        _syncedToggle = value;\r\n        toggleObject.SetActive(value);\r\n    }\r\n    get => _syncedToggle;\r\n}\r\n```\r\n\r\n### Notes\r\n\r\n- This does **not** fire when array elements change.\r\n- It only fires when the array object itself changes.\r\n",
        "skills/udonsharp-coding/references/en/udon_network/04_synced_types.md": "# Reference: Supported Synced Types\r\n\r\nThis is the list of types that can be used as synced variables.\r\n\r\n## Boolean\r\n\r\n| Type | Size |\r\n| --- | --- |\r\n| bool | 1 byte |\r\n\r\n## Integral numeric types\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| sbyte | -128 to 127 | 1 byte |\r\n| byte | 0 to 255 | 1 byte |\r\n| short | -32,768 to 32,767 | 2 bytes |\r\n| ushort | 0 to 65,535 | 2 bytes |\r\n| int | -2,147,483,648 to 2,147,483,647 | 4 bytes |\r\n| uint | 0 to 4,294,967,295 | 4 bytes |\r\n| long | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 8 bytes |\r\n| ulong | 0 to 18,446,744,073,709,551,615 | 8 bytes |\r\n\r\n## Floating-point numeric types\r\n\r\n| Type | Approximate range | Precision | Size |\r\n| --- | --- | --- | --- |\r\n| float | ±1.5 x 10^(−45) to ±3.4 x 10^(38) | ~6–9 digits | 4 bytes |\r\n| double | ±5.0 × 10^(−324) to ±1.7 × 10^(308) | ~15–17 digits | 8 bytes |\r\n\r\n## Vector / Quaternion (Unity)\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| Vector2 | same as float | 8 bytes |\r\n| Vector3 | same as float | 12 bytes |\r\n| Vector4 | same as float | 16 bytes |\r\n| Quaternion | same as float | 16 bytes |\r\n\r\n## Color\r\n\r\n| Type | Range / Precision | Size |\r\n| --- | --- | --- |\r\n| Color | same as float | 16 bytes |\r\n| Color32 | same as byte | 4 bytes |\r\n\r\n## Text\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| char | U+0000 to U+FFFF | 2 bytes |\r\n| string | same as char | 2 bytes / char |\r\n\r\n## Other\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| VRCUrl | U+0000 to U+FFFF | 2 bytes / char |\r\n\r\n## Synced arrays\r\n\r\n- Only one-dimensional arrays are supported.\r\n- Jagged arrays are not synced.\r\n- You must initialize arrays with `new`, even if the length is 0.\r\n",
        "skills/udonsharp-coding/references/en/udon_network/05_design_tips.md": "# Optimization: Design Tips\r\n\r\nThese tips help reduce sync cost and keep the experience stable.\r\n\r\n## 1. Reduce sync frequency\r\n\r\nHigh-frequency sync can hit bandwidth limits and cause backlogs.\r\n\r\n**Example**: Instead of syncing remaining time every second:\r\n- Sync the timer end time once\r\n- Display remaining time by comparing with local time\r\n\r\n## 2. State sync vs event sync\r\n\r\n- **Late joiners must reproduce state** → use synced variables\r\n- **Only simultaneous playback is needed** → `SendCustomNetworkEvent`\r\n\r\n## 3. When to use Continuous\r\n\r\nUse `Continuous` only when frequent updates are required (e.g., position interpolation).\r\nOtherwise, control sync frequency with `Manual`.\r\n",
        "skills/udonsharp-coding/references/en/udon_network/README.md": "# Udon Network Sync (Split Edition)\r\n\r\nThis folder is a split and reorganized version of `udon_network.md` for step-by-step learning. It prioritizes quick access to the minimum information needed for implementation. The original [udon_network.md](../udon_network.md) is preserved.\r\n\r\n## Learning order (shortest → advanced)\r\n\r\n1. Minimum implementation (required): [01_basics_minimum.md](01_basics_minimum.md)\r\n2. Implementation (practice): [02_implementation.md](02_implementation.md)\r\n3. Supplement (sync options / callbacks): [03_sync_options.md](03_sync_options.md)\r\n4. Reference (supported synced types): [04_synced_types.md](04_synced_types.md)\r\n5. Optimization (design tips): [05_design_tips.md](05_design_tips.md)\r\n\r\n## Shortcuts by purpose\r\n\r\n- Build something that just works: [01_basics_minimum.md](01_basics_minimum.md)\r\n- Use ownership transfer or sync hooks: [02_implementation.md](02_implementation.md)\r\n- Check interpolation or `FieldChangeCallback`: [03_sync_options.md](03_sync_options.md)\r\n- View supported synced types: [04_synced_types.md](04_synced_types.md)\r\n- Reduce sync load: [05_design_tips.md](05_design_tips.md)\r\n",
        "skills/udonsharp-coding/references/en/udon_persistence.md": "# Udon Persistence\n\nVRChat's Persistence feature allows you to save player-specific data in your world and retain it across sessions. This makes it possible to carry over high scores, inventories, settings, etc., to the next visit.\n\nThere are two main methods for persistence: **PlayerData** and **PlayerObject**.\n\n## PlayerData\n\n**PlayerData** is a simple database that stores data as key-value pairs for each player.\n\n### Basic Usage\n\nYou use the static methods of the `VRC.SDK3.Persistence.PlayerData` class to read and write data.\n\n**Saving Data:**\nUse `PlayerData.SetType(key, value)`. Saving is done for the local player.\n\n```csharp\nusing UdonSharp;\nusing UnityEngine;\nusing VRC.SDK3.Persistence;\nusing VRC.SDKBase;\n\npublic class ScoreSaver : UdonSharpBehaviour\n{\n    public void SaveScore(int score)\n    {\n        // Save an integer value to the key \"playerScore\"\n        PlayerData.SetInt(\"playerScore\", score);\n        Debug.Log(\"Saved score: \" + score);\n    }\n}\n```\n\n**Loading Data:**\nUse `PlayerData.GetType(player, key)`. You must wait for the `OnPlayerRestored` event, which indicates that the data has been loaded, before attempting to read it.\n\n```csharp\nusing UdonSharp;\nusing UnityEngine;\nusing VRC.SDK3.Persistence;\nusing VRC.SDKBase;\n\npublic class ScoreLoader : UdonSharpBehaviour\n{\n    private const string ScoreKey = \"playerScore\";\n\n    // Event called after a player's persistent data has been loaded\n    public override void OnPlayerRestored(VRCPlayerApi player)\n    {\n        if (player.isLocal)\n        {\n            if (PlayerData.HasKey(player, ScoreKey))\n            {\n                int loadedScore = PlayerData.GetInt(player, ScoreKey);\n                Debug.Log($\"Loaded score: {loadedScore}\");\n            }\n            else\n            {\n                Debug.Log(\"No saved score found.\");\n            }\n        }\n    }\n}\n```\n\n### Supported Data Types\nMajor types such as `Int`, `Float`, `String`, `Bool`, `Byte`, `Color`, `Vector2`, `Vector3`, `Vector4`, and `Quaternion` are supported.\n\n## PlayerObject\n\n**PlayerObject** is a GameObject that is automatically instantiated when a player joins. Synced variables (`[UdonSynced]`) on UdonBehaviours attached to this object can be persisted. This is suitable for saving data with complex structures, such as inventory contents.\n\n### Setup Steps\n\n1.  Create a GameObject in the scene and attach the `VRCPlayerObject` component to it.\n2.  Attach an `UdonBehaviour` to that GameObject (or a child) and define synced variables (`[UdonSynced]`).\n3.  Attach the `VRCEnablePersistence` component to the same GameObject as the `UdonBehaviour` whose variables you want to persist.\n4.  You may need to register this object as a PlayerObject in the scene descriptor (VRCSceneDescriptor), etc. (Note: Current SDK specifications may handle this automatically in some cases, but please check the documentation). Generally, you make the created object a prefab and specify it in the scene management component.\n\n### Confirming Data Load\n\nFor PlayerObjects as well, use the `OnPlayerRestored` event to know when the data has been restored.\n\n```csharp\nusing UdonSharp;\nusing UnityEngine;\nusing VRC.SDKBase;\n\npublic class InventoryPersistence : UdonSharpBehaviour\n{\n    [UdonSynced]\n    public int[] inventoryItemIds;\n\n    public override void OnPlayerRestored(VRCPlayerApi player)\n    {\n        // Data for the owner of this object (the corresponding player) has been restored\n        if (Networking.GetOwner(gameObject) == player)\n        {\n            Debug.Log(\"Inventory data restored.\");\n            // Perform processing using the restored inventoryItemIds\n        }\n    }\n}\n```\n\n### Getting PlayerObjects\n\nTo get the PlayerObjects associated with a specific player, use `Networking.GetPlayerObjects(player)`.\n\n```csharp\npublic void FindPlayerObject(VRCPlayerApi player)\n{\n    GameObject[] objects = Networking.GetPlayerObjects(player);\n    foreach (var obj in objects)\n    {\n        // Search for a specific component, etc.\n        var inventory = obj.GetComponent<InventoryPersistence>();\n        if (inventory != null)\n        {\n            Debug.Log($\"Found inventory for {player.displayName}.\");\n        }\n    }\n}\n```\n\n## Notes and Best Practices\n\n1.  **Wait for OnPlayerRestored**: Always ensure you read or write data after the `OnPlayerRestored` event has fired. Accessing it before this may result in reading/writing old data or default values.\n2.  **Storage Limits**: Both PlayerData and PlayerObject have a limit of **100KB** per player.\n3.  **Key Naming (PlayerData)**: PlayerData shares a key space across the entire world. It is recommended to add a prefix to keys to avoid collisions with other gimmicks (e.g., `MySystem_Score`, `AuthorName_Setting_Volume`).\n4.  **Save Timing**: You cannot save data immediately before a player leaves the world (`OnPlayerLeft`). Save data whenever it changes or periodically.\n5.  **PlayerObject vs PlayerData**:\n    *   **PlayerData**: Suitable for simple numerical or string settings (scores, option settings, etc.).\n    *   **PlayerObject**: Suitable for objects with complex states or data that needs synchronization (equipped items, etc.). PlayerObjects are synced individually, which also leads to bandwidth savings.\n\n## References\n*   [Persistence (VRChat Creators)](https://creators.vrchat.com/worlds/udon/persistence/)\n*   [PlayerData](https://creators.vrchat.com/worlds/udon/persistence/player-data)\n*   [PlayerObject](https://creators.vrchat.com/worlds/udon/persistence/player-object)\n",
        "skills/udonsharp-coding/references/en/udon_playerTracking.md": "# Handling Player Tracking Data\r\n\r\nVarious positional/pose information of a `VRCPlayerApi` can be obtained from `VRCPlayerApi`.\r\n\r\n## Player position\r\n\r\n```cs\r\nVRCPlayerApi player = Networking.LocalPlayer;\r\n\r\nVector3 playerPosition = ownerPlayer.GetPosition();\r\nQuaternion playerRotation = ownerPlayer.GetRotation();\r\n```\r\n\r\n## TrackingData\r\n\r\nThere are two ways to get the positions of a player's head and hands.\r\n\r\n### `TrackingData`\r\n\r\n```cs\r\nVRCPlayerApi player = Networking.LocalPlayer;\r\n\r\n// The player's actual head position\r\nVRCPlayerApi.TrackingData headTrackingData = player.GetTrackingData(VRCPlayerApi.TrackingDataType.Head);\r\nvar headPos = headTrackingData.position;\r\nvar headRot = headTrackingData.rotation;\r\n```\r\n\r\n### `VRCPlayerApi.TrackingDataType`\r\n\r\n| name | summary |\r\n|---|---|\r\n| Head | |\r\n| LeftHand | |\r\n| RightHand | |\r\n| Origin | The player's playspace origin |\r\n| AvatarRoot | The player's avatar root |\r\n\r\n### `BonePosition` / `BoneRotation`\r\n\r\n```cs\r\n// Avatar bone position\r\nvar headBonePos = player.GetBonePosition(HumanBodyBones.Head);\r\nvar headBoneRot = player.GetBoneRotation(HumanBodyBones.Head);\r\n```\r\n\r\nThe difference between these two is that `TrackingData` represents the player's *real* viewpoint position and hand controller position, while `Bone` represents the player's avatar bone position. These two positions can differ due to avatar IK processing, etc.\r\n\r\nIn general, for follow objects that matter to the user's view or actual hand positions, implement them using `TrackingData`.\r\n\r\nUse bone position information when what matters is the position as seen by third parties, or when following the avatar is important (e.g., accessories).\r\n\r\nNote: For the LocalPlayer, `TrackingData` indicates the actual viewpoint and controller positions. However, for players other than yourself (remote players), the same values as `GetBonePosition` and `GetBoneRotation` are used. In other words, remote players' tracking data is not transmitted.\r\n",
        "skills/udonsharp-coding/references/en/udon_uGUI.md": "# uGUI in Udon\r\n\r\n## Events\r\n\r\nYou can receive click/change events from UI components such as Button, Slider, and Toggle. However, in UdonSharp you cannot assign callbacks directly, so notifications are typically sent using `SendCustomEvent`. Because of this, you cannot receive the Slider/Toggle value as an event argument.\r\n\r\nTherefore, detect the change and then read the UI component’s current value via the reference set in the Inspector.\r\n\r\n```cs\r\n// Reference to the Slider\r\npublic Slider slider;\r\n\r\n// Register this function to the Slider's On Value Changed\r\npublic void OnSliderChange()\r\n{\r\n    var value = slider.value;\r\n}\r\n```\r\n",
        "skills/udonsharp-coding/references/jp/Troubleshooting.md": "# ",
        "skills/udonsharp-coding/references/jp/udon_class.md": "# クラス機能について\r\n\r\n## 継承\r\n\r\nUdonSharpは、`UdonSharpBehaviour`を継承している独自のクラスに対して、継承を行うことができます。\r\nただし、インターフェイスは使用できないため、純粋なC#程の自由度がありません。\r\n\r\n```cs\r\npublic class UdonBaseClass : UdonSharpBehaviour\r\n{\r\n    public virtual void Hello()\r\n    {\r\n        Debug.Log(\"Hello UdonBase\");\r\n    }\r\n}\r\n\r\npublic class UdonChildClass : UdonBaseClass\r\n{\r\n    public override void Hello()\r\n    {\r\n        Debug.Log(\"Hello UdonChild\");\r\n    }\r\n}\r\n```\r\n\r\n一般的な使用方法としては、基底クラスの仮想メソッド（`virtual`/`override`）を利用して処理を差し替える、`Strategy Pattern`（を継承で代替した形）や、`Template Method Pattern`（共通処理は基底に置き、一部だけ派生で上書きする）としての運用です。\r\nたとえば、内部の処理内容を差し替え可能にしたり、入力方式の違い（キーボード/VRコントローラ等）を「疑似インタフェース」として基底クラスにまとめ、派生クラスで実装を切り替える、といった用途で使います。\r\n\r\n### 実装例\r\n\r\n共通処理（移動）は基底クラスに置き、入力だけを派生クラスで差し替える例です（`Template Method Pattern` 寄り）。\r\n\r\n```cs\r\nusing UdonSharp;\r\nusing UnityEngine;\r\n\r\npublic class BaseMover : UdonSharpBehaviour\r\n{\r\n    [SerializeField] private float speed = 2f;\r\n\r\n    protected virtual Vector3 GetMoveDir() => Vector3.zero;\r\n\r\n    private void Update()\r\n    {\r\n        transform.position += GetMoveDir() * (speed * Time.deltaTime);\r\n    }\r\n}\r\n\r\n// キーボードでの入力方式\r\npublic class KeyboardMover : BaseMover\r\n{\r\n    protected override Vector3 GetMoveDir()\r\n        => new Vector3(Input.GetAxisRaw(\"Horizontal\"), 0f, Input.GetAxisRaw(\"Vertical\"));\r\n}\r\n\r\n// VRでの入力方式\r\npublic class VrcMoveAxisMover : BaseMover\r\n{\r\n    private float x;\r\n    private float z;\r\n\r\n    public override void InputMoveHorizontal(float value, UdonInputEventArgs args) => x = value;\r\n    public override void InputMoveVertical(float value, UdonInputEventArgs args) => z = value;\r\n    protected override Vector3 GetMoveDir() => new Vector3(x, 0f, z);\r\n}\r\n```",
        "skills/udonsharp-coding/references/jp/udon_network.md": "# UDONにおけるネットワークについて\r\n\r\nUdonでは、`UdonBehavior`または`UdonSharpBehavior`がアタッチされたオブジェクトで、ネットワーク同期されるものに関しては`Owner`という概念が発生します。\r\nVRChatではデータ同期されるオブジェクトに関して`Owner`と呼ばれるプレイヤーがそのオブジェクトのデータ同期の責任者となり、`Owner`がマスターデータを保持し、別の非`Owner`のプレイヤーのクライアントに対してデータを送信します。\r\n同期されるデータは`Owner`となっているプレイヤーのみ変更可能です。非`Owner`のプレイヤーは同期されるデータに対しては読み込み専用になります。\r\n\r\n## オーナーの取得関連の処理 \r\n\r\n特定のゲームオブジェクトのオーナーがどのプレイヤーかを取得する場合は\r\n`VRCPlayerAPI Networking.GetOwner(GameObject obj)`\r\nを使用してオーナーのプレイヤー情報を得ます。また、現在のクライアントのプレイヤーがオーナーかどうかは`bool Networking.IsOwner(VRCPlayerApi player, GameObject obj)`関数を使用することで確認できます。\r\n\r\nオーナー権限を特定のプレイヤーに移したい場合は`Networking.SetOwner(VRCPlayerApi player, GameObject obj)`を使用してオーナーを設定できます。\r\n\r\nオーナー権限が他のプレイヤーに移ったとき、以下のイベントコールバック関数が発火します。\r\n\r\n```cs\r\npublic void override OnOwnershipTransferred(VRCPlayerApi player)\r\n{\r\n    Debug.Log($\"Ownership Transferred {player.displayName}\");\r\n}\r\n```\r\n\r\nまた、`SetOwner`でオーナー変更されたとき、元のオーナーでは、オーナー権限変更リクエストに対して許可するか拒否するかのコールバックが発動します。 \r\n\r\n```cs\r\npublic bool override OnOwnershipRequest(VRCPlayerApi requester, VRCPlayerApi newOwner)\r\n{\r\n    return true;\r\n}\r\n```\r\n\r\n## 同期モード\r\n\r\n同期モードとは、データ同期をどのように行うかを設定します。UdonSharpでは`UdonSharpBehavior`を継承したクラスに対して`UdonBehaviorSyncMode`アトリビュートを指定することで設定できます。\r\n\r\n```cs\r\n[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]\r\npublic class Example : UdonSharpBehaviour \r\n{ \r\n}\r\n```\r\n\r\n`UdonSharp.BehaviourSyncMode`\r\n\r\n|Name|Summary|\r\n|---|---|\r\n|None|Enforces no synced variables on the behaviour and hides the selection dropdown in the UI for the sync mode. Nothing is synced and SendCustomNetworkEvent will not work on the behaviour.|\r\n|Continuous|Synced variables will be updated automatically at a very frequent rate, but may not always reliably update to save bandwidth.|\r\n|Manual|Synced variables are updated manually by the user less frequently, but ensures that updates are reliable when requested.|\r\n|NoVariableSync|Enforces that there are no synced variables on the behaviour, hides the sync mode selection dropdown, and allows you to use the behaviours on GameObjects that use either Manual or Continuous sync.|\r\n\r\n同期を行う場合はパフォーマンス上の理由からなるべく`Manual`を選択し、`Continuous`は連続して位置情報などの更新が必要かつ、補間機能を使用する場合を除いて使用を控えます。\r\n\r\n## 同期変数 (Synced Variables)\r\n\r\n同期変数はネットワーク同期において、`UdonBehavior`コンポーネントが持つ実際に同期されるパラメーターです。\r\nUdonSharpでは`UdonSynced`アトリビュートを指定することで宣言できます。\r\n\r\n```cs\r\n[UdonSynced]\r\npublic bool synchronizedBoolean;\r\n\r\n[UdonSynced(UdonSyncMode.Linear)]\r\npublic float synchronizedFloat;\r\n```\r\n\r\nUdonSyncModeで指定できるオプションは以下の通りです。\r\n\r\n|Name|Summary|\r\n|---|---|\r\n|NotSynced||\r\n|None|No interpolation (Default)|\r\n|Linear|Lerp|\r\n|Smooth|Some kind of smoothed syncing|\r\n\r\n`Linear`と`Smooth`は同期モードが`Continuous`の場合しか作用しません。`Manual`モードの場合は基本的にNoneを指定します。\r\n\r\n同期可能な型は以下になります\r\n\r\n### Boolean  types\r\n| Type | Size    |\r\n| ---- | ------- |\r\n| bool | 1 byte  |\r\n### Integral numeric types\r\n| Type   | Range                           | Size    |\r\n|--------|---------------------------------|---------|\r\n| sbyte  | -128 to 127                     | 1 byte  |\r\n| byte   | 0 to 255                        | 1 byte  |\r\n| short  | -32,768 to 32,767               | 2 bytes |\r\n| ushort | 0 to 65,535                     | 2 bytes |\r\n| int    | -2,147,483,648 to 2,147,483,647 | 4 bytes |\r\n| uint   | 0 to 4,294,967,295              | 4 bytes |\r\n| long   | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 8 bytes |\r\n| ulong  | 0 to 18,446,744,073,709,551,615 | 8 bytes |\r\n### Floating-point numeric types\r\n| Type   | Approximate range             | Precision     | Size    |\r\n|--------|-------------------------------|---------------|---------|\r\n| float  | ±1.5 x 10^(−45) to ±3.4 x 10^(38)   | ~6-9 digits   | 4 bytes |\r\n| double | ±5.0 × 10^(−324) to ±1.7 × 10^(308) | ~15-17 digits | 8 bytes |\r\n### Vector mathematics types and structures (Unity)\r\n| Type        | Range         | Size     |\r\n|-------------|---------------|----------|\r\n| Vector2   | same as float | 8 bytes  |\r\n| Vector3   | same as float | 12 bytes  |\r\n| Vector4   | same as float | 16 bytes |\r\n| Quaternion| same as float | 16 bytes  |\r\n### Color structures\r\n| Type     | Range / Precision | Size    |\r\n|----------|-------------------|---------|\r\n| Color  | same as float     | 16 bytes |\r\n| Color32| same as byte      | 4 bytes |\r\n### Text types and structures\r\n| Type   | Range            | Size           |\r\n|--------|------------------|----------------|\r\n| char   | U+0000 to U+FFFF | 2 bytes        |\r\n| string | same as char     | 2 bytes / char |\r\n### Other structures\r\n| Type   | Range            | Size           |\r\n|--------|------------------|----------------|\r\n| VRCUrl | U+0000 to U+FFFF | 2 bytes / char |\r\n\r\n### 同期配列\r\n\r\nさらに上記の型の配列も同期変数とすることができます。\r\nただし一次元配列のみで有効でジャグ配列は同期しません。\r\nまた、初期化子で要素数0でもいいので必ずnewしないと同期がされません。\r\n\r\n\r\n## 同期変数の手動同期\r\n\r\n同期モードを`Manual`に指定している場合、明示的にオーナーが同期をリクエストしなければ同期されません。\r\nまたこの処理はオーナー以外が実行しても効果はありません。    \r\n\r\n```cs\r\nRequestSerialization();\r\n```\r\n\r\n同期がリクエストされるとオーナーでは以下のコールバックが順番に発動します\r\n\r\n```cs\r\npublic override void OnPreSerialization()\r\n{\r\n    Debug.Log(\"データを転送前の処理\");\r\n}\r\n```\r\n\r\n```cs\r\npublic override void OnPostSerialization(VRC.Udon.Common.SerializationResult result)\r\n{\r\n    Debug.Log(\"データを転送後の後処理\");\r\n}\r\n```\r\n\r\nまた、受信した非オーナー側は以下のコールバックが発動します\r\n```cs\r\npublic override void OnDeserialization()\r\n{\r\n    Debug.Log(\"同期データを受信\");\r\n}\r\n```\r\nこのコールバックを受信したとき同期変数の内容が送信されてきた内容に変化します。\r\n\r\n## FieldChangeCallback\r\n\r\n`OnDeserialization()`はそのクラスで定義したすべての同期変数の変更に対して発火します。\r\n特定の同期変数の変更のみを取得したい場合は以下のような構文で可能です。\r\n\r\n```cs\r\n[UdonSynced, FieldChangeCallback(nameof(SyncedToggle))]\r\nprivate bool _syncedToggle;\r\n\r\npublic bool SyncedToggle\r\n{\r\n    set\r\n    {\r\n        Debug.Log(\"toggling the object...\");\r\n        _syncedToggle = value;\r\n        toggleObject.SetActive(value);\r\n    }\r\n    get => _syncedToggle;\r\n}\r\n```\r\n\r\nこれで`SyncedToggle`を変更されたときのコールバックを作ることができます。\r\nこのコールバックは`OnDeserialization()`と異なりオーナーでも呼ばれます。\r\n\r\n注意点として、配列に対するFieldChangeCallbackでは、配列要素の変更ではコールバックは発火しません。配列オブジェクトそのものが変わるときのみ発火します。\r\n\r\n\r\n## SendCustomNetworkEvent\r\n\r\n`SendCustomNetworkEvent`は同期変数を用いず、特定のタイミングでネットワーク越しに関数を実行したいときに使用する機能です。\r\npublicな関数に対してのみ適応することができます。\r\n\r\n\r\n```cs\r\n\r\npublic Function()\r\n{\r\n    Debug.Log(\"Show All Player!\");\r\n}\r\n\r\n\r\nSendCustomNetworkEvent(NetworkEventTarget.All, nameof(Function));\r\n\r\n\r\n```\r\n`NetworkEventTarget`はこの関数を実行する対象です。\r\n\r\n|Name|Summary|\r\n|---|---|\r\n|All|All players in the instance|\r\n|Owner|Owner of the game object|\r\n|Others|自分以外のすべてのプレイヤー|\r\n|Self|自分のみ|\r\n\r\n\r\nこの機能は、主に、音声やエフェクトをすべてのプレイヤーで鳴らしたいなどの同時かつ一時的なイベントに対して使用します。\r\n逆に、この機能を用いて状態変化など、その後も継続する状態を変化させるのに使うには不適切です。状態変化を使用する場合は同期変数で実装します。\r\n\r\nまたNetworkCallableアトリビュートを指定することで引数を持たせることもできます。\r\n\r\n```cs\r\nvoid Start()\r\n{\r\n    SendCustomNetworkEvent(NetworkEventTarget.All, nameof(Greet), \"hogehoge\");\r\n}\r\n\r\n[NetworkCallable]\r\npublic void Greet(string name)\r\n{\r\n    Debug.Log(name + \"さん、こんにちは！\");\r\n}\r\n\r\n```\r\n\r\n## ネットワーク処理の設計\r\n\r\n### 可能な限り同期の頻度を減らします。\r\n\r\n高頻度なデータ同期は最大データ転送量の制限に引っかかり、同期詰まりを起こします。\r\n例えば同期されたタイマー処理では、残り時間の表示に残り秒数を常に同期するのではなく、タイマーが0になる時刻情報を同期して、ローカルで取得した現在時刻との差から表示させれば、同期自体は一回で済みます。\r\n\r\n### SendCustomNetworkEventと同期変数の使い分け\r\n\r\n使い分けとしては、主にワールドに後から入ってくるプレイヤーに対して同期する必要があるか、ないかで判断することができます。\r\n\r\n例えば、同時タイミングで発火される音声やエフェクトなどの処理は、その再生後に後から入ってきたプレイヤーで再生される必要がありません。このような信号はSendCustomNetworkEventで送るのが良いです。\r\n\r\n逆に現在のゲーム状態・ワールドのオブジェクト位置など、後から入ってきたプレイヤーにもそれまでの状態を再現する必要があるものに関しては同期変数を使用します。",
        "skills/udonsharp-coding/references/jp/udon_network/01_basics_minimum.md": "# 最短実装（必須）\r\n\r\nこのページは「最小限の実装に必要な情報」だけをまとめています。\r\n\r\n## 1. Owner の前提\r\n\r\n- ネットワーク同期されるオブジェクトには `Owner` が存在します。\r\n- 同期データの変更は **Owner のみ** 可能です。非 Owner は読み取り専用です。\r\n\r\n## 2. Owner 関連の最小 API\r\n\r\n- オーナー取得: `Networking.GetOwner(GameObject obj)`\r\n- オーナー判定: `Networking.IsOwner(VRCPlayerApi player, GameObject obj)`\r\n- オーナー設定: `Networking.SetOwner(VRCPlayerApi player, GameObject obj)`\r\n\r\n## 3. 同期変数の定義\r\n\r\n- 同期するフィールドに `[UdonSynced]` を付けます。\r\n- 同期を行う場合は、`UdonBehaviourSyncMode` を **Manual** にして明示同期するのが基本です。\r\n\r\n```cs\r\n[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]\r\npublic class Example : UdonSharpBehaviour\r\n{\r\n    [UdonSynced]\r\n    public bool synchronizedFlag;\r\n}\r\n```\r\n\r\n## 4. 手動同期の流れ（最短）\r\n\r\n- Owner が `RequestSerialization()` を呼ぶと同期が送信されます。\r\n- 非 Owner 側は `OnDeserialization()` が呼ばれて同期値が反映されます。\r\n\r\n```cs\r\npublic override void OnDeserialization()\r\n{\r\n    // 同期データ受信後の処理\r\n}\r\n```\r\n\r\n## 5. 一時的イベントの同期\r\n\r\n- 状態を継続させる必要がない一時イベントは `SendCustomNetworkEvent` を使います。\r\n- public なメソッドに対してのみ呼び出し可能です。\r\n\r\n```cs\r\npublic void PlayEffect()\r\n{\r\n    // エフェクト再生など\r\n}\r\n\r\nSendCustomNetworkEvent(NetworkEventTarget.All, nameof(PlayEffect));\r\n```\r\n\r\n## 6. 最小チェックリスト\r\n\r\n- [ ] `Owner` のみが同期データを変更する設計になっている\r\n- [ ] 同期変数に `[UdonSynced]` が付与されている\r\n- [ ] `Manual` 同期で `RequestSerialization()` を呼んでいる\r\n- [ ] 一時イベントは `SendCustomNetworkEvent` を使っている\r\n",
        "skills/udonsharp-coding/references/jp/udon_network/02_implementation.md": "# 実装章（実践）\r\n\r\nこのページは、実装のために必要な設計判断とコールバックの使い方をまとめています。\r\n\r\n## 1. 同期モードの選択\r\n\r\n`UdonBehaviourSyncMode` で同期モードを指定します。\r\n\r\n- `Manual`: 明示的に同期。**通常はこれを推奨**。\r\n- `Continuous`: 位置補間など連続更新が必要な場合のみ。\r\n- `None`: 同期変数が存在しない前提。\r\n- `NoVariableSync`: 同期変数なし・SendCustomNetworkEvent のみ使用。\r\n\r\n```cs\r\n[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]\r\npublic class Example : UdonSharpBehaviour { }\r\n```\r\n\r\n## 2. 状態同期 vs 一時イベント\r\n\r\n- **状態を保持する必要がある** → `UdonSynced` で同期変数を使う\r\n- **一時的な演出/音/エフェクト** → `SendCustomNetworkEvent`\r\n\r\n## 3. オーナー移譲とコールバック\r\n\r\nオーナー変更時のイベントです。\r\n\r\n```cs\r\npublic override void OnOwnershipTransferred(VRCPlayerApi player)\r\n{\r\n    // 所有者変更時の処理\r\n}\r\n```\r\n\r\n```cs\r\npublic override bool OnOwnershipRequest(VRCPlayerApi requester, VRCPlayerApi newOwner)\r\n{\r\n    // 変更を許可するなら true\r\n    return true;\r\n}\r\n```\r\n\r\n## 4. シリアライズのフック\r\n\r\n同期の送受信タイミングに介入できます。\r\n\r\n```cs\r\npublic override void OnPreSerialization()\r\n{\r\n    // 送信前の処理\r\n}\r\n\r\npublic override void OnPostSerialization(VRC.Udon.Common.SerializationResult result)\r\n{\r\n    // 送信後の処理\r\n}\r\n\r\npublic override void OnDeserialization()\r\n{\r\n    // 受信後の処理\r\n}\r\n```\r\n\r\n## 5. 典型的な実装フロー\r\n\r\n1. 変更を行う前に `IsOwner` で判定\r\n2. 変更するなら `SetOwner` で権限を取得（必要時）\r\n3. 同期変数を更新\r\n4. `RequestSerialization()` で同期送信\r\n",
        "skills/udonsharp-coding/references/jp/udon_network/03_sync_options.md": "# 補足：同期オプション / コールバック\r\n\r\nこのページは、実装の補助情報をまとめています。\r\n\r\n## 1. UdonSyncMode（補間）\r\n\r\n`UdonSyncMode` は主に `Continuous` で有効です。\r\n\r\n- `None`: 補間なし（デフォルト）\r\n- `Linear`: 線形補間（Lerp）\r\n- `Smooth`: なめらか補間\r\n\r\n```cs\r\n[UdonSynced(UdonSyncMode.Linear)]\r\npublic float synchronizedFloat;\r\n```\r\n\r\n## 2. FieldChangeCallback\r\n\r\n特定の同期変数の変更時のみ処理を走らせたい場合に使用します。\r\n\r\n```cs\r\n[UdonSynced, FieldChangeCallback(nameof(SyncedToggle))]\r\nprivate bool _syncedToggle;\r\n\r\npublic bool SyncedToggle\r\n{\r\n    set\r\n    {\r\n        _syncedToggle = value;\r\n        toggleObject.SetActive(value);\r\n    }\r\n    get => _syncedToggle;\r\n}\r\n```\r\n\r\n### 注意点\r\n\r\n- 配列の **要素変更** では発火しません。\r\n- 配列オブジェクトそのものが変更された場合のみ発火します。\r\n",
        "skills/udonsharp-coding/references/jp/udon_network/04_synced_types.md": "# 参照：同期可能な型\r\n\r\n同期変数として使用できる型の一覧です。\r\n\r\n## Boolean\r\n\r\n| Type | Size |\r\n| --- | --- |\r\n| bool | 1 byte |\r\n\r\n## Integral numeric types\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| sbyte | -128 to 127 | 1 byte |\r\n| byte | 0 to 255 | 1 byte |\r\n| short | -32,768 to 32,767 | 2 bytes |\r\n| ushort | 0 to 65,535 | 2 bytes |\r\n| int | -2,147,483,648 to 2,147,483,647 | 4 bytes |\r\n| uint | 0 to 4,294,967,295 | 4 bytes |\r\n| long | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 8 bytes |\r\n| ulong | 0 to 18,446,744,073,709,551,615 | 8 bytes |\r\n\r\n## Floating-point numeric types\r\n\r\n| Type | Approximate range | Precision | Size |\r\n| --- | --- | --- | --- |\r\n| float | ±1.5 x 10^(−45) to ±3.4 x 10^(38) | ~6–9 digits | 4 bytes |\r\n| double | ±5.0 × 10^(−324) to ±1.7 × 10^(308) | ~15–17 digits | 8 bytes |\r\n\r\n## Vector / Quaternion（Unity）\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| Vector2 | same as float | 8 bytes |\r\n| Vector3 | same as float | 12 bytes |\r\n| Vector4 | same as float | 16 bytes |\r\n| Quaternion | same as float | 16 bytes |\r\n\r\n## Color\r\n\r\n| Type | Range / Precision | Size |\r\n| --- | --- | --- |\r\n| Color | same as float | 16 bytes |\r\n| Color32 | same as byte | 4 bytes |\r\n\r\n## Text\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| char | U+0000 to U+FFFF | 2 bytes |\r\n| string | same as char | 2 bytes / char |\r\n\r\n## Other\r\n\r\n| Type | Range | Size |\r\n| --- | --- | --- |\r\n| VRCUrl | U+0000 to U+FFFF | 2 bytes / char |\r\n\r\n## 同期配列\r\n\r\n- 一次元配列のみ有効です。\r\n- ジャグ配列は同期しません。\r\n- 要素数 0 でも **必ず new して初期化** してください。\r\n",
        "skills/udonsharp-coding/references/jp/udon_network/05_design_tips.md": "# 最適化：設計指針\r\n\r\n同期コストを抑え、安定した体験を作るための指針です。\r\n\r\n## 1. 同期頻度を減らす\r\n\r\n高頻度な同期は帯域制限により詰まりやすくなります。\r\n\r\n**例**: 残り時間を毎秒同期するのではなく、\r\n- 「タイマー終了時刻」を同期する\r\n- ローカルの現在時刻との差分で表示する\r\n\r\n## 2. 状態同期とイベント同期の使い分け\r\n\r\n- **後から入室するプレイヤーにも状態再現が必要** → 同期変数\r\n- **同時再生だけ必要で後からの再現不要** → `SendCustomNetworkEvent`\r\n\r\n## 3. Continuous を使うべき場面\r\n\r\n`Continuous` は位置補間など連続更新が必要な場合に限定します。\r\nそれ以外は `Manual` で同期頻度を制御する方が安全です。\r\n",
        "skills/udonsharp-coding/references/jp/udon_network/README.md": "# Udon ネットワーク同期（分割版）\r\n\r\nこのフォルダは、段階的に学べるよう `udon_network.md` を再編成した分割版ドキュメントです。最小限の実装情報に素早くアクセスできる構成を優先しています。元の [udon_network.md](../udon_network.md) は保持されています。\r\n\r\n## 学習順（最短→発展）\r\n\r\n1. 最短実装（必須）: [01_basics_minimum.md](01_basics_minimum.md)\r\n2. 実装章（実践）: [02_implementation.md](02_implementation.md)\r\n3. 補足（同期オプション/コールバック）: [03_sync_options.md](03_sync_options.md)\r\n4. 参照（同期可能な型）: [04_synced_types.md](04_synced_types.md)\r\n5. 最適化（設計指針）: [05_design_tips.md](05_design_tips.md)\r\n\r\n## 目的別ショートカット\r\n\r\n- とにかく動くものを作る: [01_basics_minimum.md](01_basics_minimum.md)\r\n- オーナー移譲や同期フックを使いたい: [02_implementation.md](02_implementation.md)\r\n- 補間や `FieldChangeCallback` を確認したい: [03_sync_options.md](03_sync_options.md)\r\n- 同期可能な型を一覧で確認したい: [04_synced_types.md](04_synced_types.md)\r\n- 同期負荷を減らす設計を考えたい: [05_design_tips.md](05_design_tips.md)\r\n",
        "skills/udonsharp-coding/references/jp/udon_persistence.md": "# Udon Persistence (永続化)\n\nVRChatのPersistence（永続化）機能を使用すると、ワールド内のプレイヤーごとのデータを保存し、セッションを超えて保持することができます。これにより、ハイスコア、所持品、設定などを次回のワールド訪問時に持ち越すことが可能になります。\n\n主な永続化の方法として、**PlayerData** と **PlayerObject** の2種類があります。\n\n## PlayerData\n\n**PlayerData** は、プレイヤーごとにキーと値のペア（Key-Value）でデータを保存するシンプルなデータベースです。\n\n### 基本的な使い方\n\n`VRC.SDK3.Persistence.PlayerData` クラスの静的メソッドを使用してデータの読み書きを行います。\n\n**データの保存:**\n`PlayerData.SetType(key, value)` を使用します。保存はローカルプレイヤーに対して行います。\n\n```csharp\nusing UdonSharp;\nusing UnityEngine;\nusing VRC.SDK3.Persistence;\nusing VRC.SDKBase;\n\npublic class ScoreSaver : UdonSharpBehaviour\n{\n    public void SaveScore(int score)\n    {\n        // キー \"playerScore\" に整数値を保存\n        PlayerData.SetInt(\"playerScore\", score);\n        Debug.Log(\"スコアを保存しました: \" + score);\n    }\n}\n```\n\n**データの読み込み:**\n`PlayerData.GetType(player, key)` を使用します。データの読み込みは、データがロードされたことを示す `OnPlayerRestored` イベントを待ってから行う必要があります。\n\n```csharp\nusing UdonSharp;\nusing UnityEngine;\nusing VRC.SDK3.Persistence;\nusing VRC.SDKBase;\n\npublic class ScoreLoader : UdonSharpBehaviour\n{\n    private const string ScoreKey = \"playerScore\";\n\n    // プレイヤーの永続データがロードされた後に呼ばれるイベント\n    public override void OnPlayerRestored(VRCPlayerApi player)\n    {\n        if (player.isLocal)\n        {\n            if (PlayerData.HasKey(player, ScoreKey))\n            {\n                int loadedScore = PlayerData.GetInt(player, ScoreKey);\n                Debug.Log($\"ロードされたスコア: {loadedScore}\");\n            }\n            else\n            {\n                Debug.Log(\"保存されたスコアはありません。\");\n            }\n        }\n    }\n}\n```\n\n### 利用可能なデータ型\n`Int`, `Float`, `String`, `Bool`, `Byte`, `Color`, `Vector2`, `Vector3`, `Vector4`, `Quaternion` など、主要な型がサポートされています。\n\n## PlayerObject\n\n**PlayerObject** は、プレイヤーが入室した際に自動的に生成されるGameObjectです。このオブジェクトについたUdonBehaviourの同期変数（Synced Variable）を永続化することができます。インベントリの中身など、複雑な構造を持つデータの保存に適しています。\n\n### セットアップ手順\n\n1. シーンにGameObjectを作成し、`VRCPlayerObject` コンポーネントをアタッチします。\n2. そのGameObject（または子）に `UdonBehaviour` をアタッチし、同期変数（`[UdonSynced]`）を定義します。\n3. 同期変数を永続化したい `UdonBehaviour` と同じGameObjectに、`VRCEnablePersistence` コンポーネントをアタッチします。\n4. シーンのディスクリプタ（VRCSceneDescriptor）などで、このオブジェクトをPlayerObjectとして登録する必要がある場合があります（※現在のSDK仕様では自動的に処理される場合もありますが、ドキュメントを確認してください）。一般的には、作成したオブジェクトをプレハブ化し、シーンの管理コンポーネント等で指定します。\n\n### データの読み込み確認\n\nPlayerObjectの場合も、データが復元されたタイミングを知るために `OnPlayerRestored` イベントを使用します。\n\n```csharp\nusing UdonSharp;\nusing UnityEngine;\nusing VRC.SDKBase;\n\npublic class InventoryPersistence : UdonSharpBehaviour\n{\n    [UdonSynced]\n    public int[] inventoryItemIds;\n\n    public override void OnPlayerRestored(VRCPlayerApi player)\n    {\n        // このオブジェクトの所有者（対応するプレイヤー）のデータが復元された\n        if (Networking.GetOwner(gameObject) == player)\n        {\n            Debug.Log(\"インベントリデータが復元されました。\");\n            // 復元された inventoryItemIds を使って処理を行う\n        }\n    }\n}\n```\n\n### PlayerObjectの取得\n\n特定のプレイヤーに紐付いたPlayerObjectを取得するには、`Networking.GetPlayerObjects(player)` を使用します。\n\n```csharp\npublic void FindPlayerObject(VRCPlayerApi player)\n{\n    GameObject[] objects = Networking.GetPlayerObjects(player);\n    foreach (var obj in objects)\n    {\n        // 特定のコンポーネントを探すなど\n        var inventory = obj.GetComponent<InventoryPersistence>();\n        if (inventory != null)\n        {\n            Debug.Log($\"{player.displayName} のインベントリが見つかりました。\");\n        }\n    }\n}\n```\n\n## 注意点とベストプラクティス\n\n1.  **OnPlayerRestored を待つ**: データの読み書きは必ず `OnPlayerRestored` イベントが発火した後に行うようにしてください。それより前にアクセスすると、古いデータや初期値を読み書きしてしまう可能性があります。\n2.  **容量制限**: PlayerData、PlayerObjectともに、プレイヤー1人あたり **100KB** の制限があります。\n3.  **キーの命名 (PlayerData)**: PlayerDataはワールド全体で共有されるキー空間を持ちます。他のギミックとキーが衝突しないように、プレフィックスを付けることを推奨します（例: `MySystem_Score`, `AuthorName_Setting_Volume`）。\n4.  **保存のタイミング**: プレイヤーがワールドから退出する直前（`OnPlayerLeft`）ではデータを保存できません。データが変更されたタイミングで随時保存するか、定期的に保存するようにしてください。\n5.  **PlayerObject vs PlayerData**: \n    *   **PlayerData**: 単純な数値や文字列設定（スコア、オプション設定など）に適しています。\n    *   **PlayerObject**: 複雑な状態を持つオブジェクトや、同期が必要なデータ（装備中のアイテムなど）に適しています。PlayerObjectは個別に同期されるため、帯域幅の節約にもつながります。\n\n## 参考リンク\n*   [Persistence (VRChat Creators)](https://creators.vrchat.com/worlds/udon/persistence/)\n*   [PlayerData](https://creators.vrchat.com/worlds/udon/persistence/player-data)\n*   [PlayerObject](https://creators.vrchat.com/worlds/udon/persistence/player-object)\n",
        "skills/udonsharp-coding/references/jp/udon_playerTracking.md": "# プレイヤーのトラッキング情報の扱い\r\n\r\nPlayerの様々な位置姿勢情報は`VRCPlayerApi`から取得可能です。\r\n\r\n## プレイヤーの位置情報\r\n\r\n```cs\r\nVRCPlayerApi player = Networking.LocalPlayer;\r\n\r\nVector3 playerPosition = ownerPlayer.GetPosition();\r\nQuaternion playerRotation = ownerPlayer.GetRotation();\r\n```\r\n\r\n## TrackingData\r\n\r\nプレイヤーの頭や手の位置を取得する方法は２つ存在します。\r\n\r\n`TrackingData`\r\n```cs\r\nVRCPlayerApi player = Networking.LocalPlayer;\r\n\r\n// プレイヤーの実際の頭の位置\r\nVRCPlayerApi.TrackingData headTrackingData = player.GetTrackingData(VRCPlayerApi.TrackingDataType.Head);\r\nvar headPos = headTrackingData.position;\r\nvar headRot = headTrackingData.rotation;\r\n```\r\n\r\n`VRCPlayerApi.TrackingDataType`\r\n|name|summary|\r\n|---|---|\r\n|Head||\r\n|LeftHand||\r\n|RightHand||\r\n|Origin|The player's playspace origin|\r\n|AvatarRoot|The player's avatar root|\r\n\r\n\r\n`BonePosition` `BoneRotation`\r\n```cs\r\n// アバターのボーンの位置\r\nvar headBonePos = player.GetBonePosition(HumanBodyBones.Head);\r\nvar headBoneRot = player.GetBoneRotation(HumanBodyBones.Head);\r\n```\r\n\r\nこの二つの違いは`TrackingData`はプレイヤーの実際の視点位置・ハンドコントローラーの位置を示すのに対して、`Bone`はプレイヤーのアバターのボーン位置を示します。この２つの位置はアバターのIK処理などによって異なる場合があります。\r\n\r\n基本的にユーザーから見た視界や実際の手の位置に関わる追従オブジェクトなどは`TrackingData`を使用して実装します。\r\nボーンの位置情報は、第三者から見た場合の位置や、アバターに追従することが重要なもの（アクセサリーなど）を実装するときに使います。\r\n\r\nちなみに`TrackingData`はLocalPlayerに対しては実際の視点位置とハンドコントローラーの位置を示しますが、自分以外のプレイヤー（リモートプレイヤー）ではGetBonePositionやGetBoneRotationと同じ値が使われます。つまりリモートプレイヤーのトラッキング情報は送信されていません。\r\n\r\n",
        "skills/udonsharp-coding/references/jp/udon_uGUI.md": "# UdonでのuGUI\r\n\r\n## イベント\r\n\r\nButton, Slider, Toggleなど、クリックや変化のイベントを取得できますが、UdonSharpでは直接コールバックを指定できず、`SendCustomEvent`を使って通知しています。この関係で、SliderやToggleの引数は取得できません。\r\n\r\nしたがって以下のように、変更を検知したら、インスペクタにセットされたスライダー情報を読み取る形にします。\r\n\r\n```cs\r\n// Sliderの参照\r\npublic Slider slider;\r\n\r\n// この関数をSliderのOn Value Changedに登録\r\npublic void OnSliderChange()\r\n{\r\n    var value = slider.value;\r\n}\r\n```"
      },
      "plugins": [
        {
          "name": "udonsharp-coding",
          "description": "UdonSharp coding utilities and scripts for VRChat.",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/udonsharp-coding"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add kurotori4423/udonsharp-coding-skill",
            "/plugin install udonsharp-coding@udonsharp-coding-skill"
          ]
        }
      ]
    }
  ]
}