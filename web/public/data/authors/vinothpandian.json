{
  "author": {
    "id": "vinothpandian",
    "display_name": "Vinoth Pandian",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/2630109?u=9c96fcd083f78c64373b38a0b0a2fd0d3a30166f&v=4",
    "url": "https://github.com/vinothpandian",
    "bio": "Research Engineering Manager (AI) @ TR Labs",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 5,
      "total_skills": 3,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "v-marketplace",
      "version": null,
      "description": "A collection of Claude Code plugins for enhanced development workflows",
      "owner_info": {
        "name": "V-Marketplace Contributors"
      },
      "keywords": [],
      "repo_full_name": "vinothpandian/v-marketplace",
      "repo_url": "https://github.com/vinothpandian/v-marketplace",
      "repo_description": "Vinoth's personal claude plugins marketplace",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-11T03:17:00Z",
        "created_at": "2026-01-10T19:10:02Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 715
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 350
        },
        {
          "path": "plugins/claude-conductor/README.md",
          "type": "blob",
          "size": 2824
        },
        {
          "path": "plugins/claude-conductor/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/commands/implement.md",
          "type": "blob",
          "size": 13465
        },
        {
          "path": "plugins/claude-conductor/commands/new-track.md",
          "type": "blob",
          "size": 9519
        },
        {
          "path": "plugins/claude-conductor/commands/revert.md",
          "type": "blob",
          "size": 8684
        },
        {
          "path": "plugins/claude-conductor/commands/setup.md",
          "type": "blob",
          "size": 35916
        },
        {
          "path": "plugins/claude-conductor/commands/status.md",
          "type": "blob",
          "size": 3930
        },
        {
          "path": "plugins/claude-conductor/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/hooks/hooks.json",
          "type": "blob",
          "size": 889
        },
        {
          "path": "plugins/claude-conductor/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/skills/context-synchronization",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/skills/context-synchronization/SKILL.md",
          "type": "blob",
          "size": 5684
        },
        {
          "path": "plugins/claude-conductor/skills/tdd-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/skills/tdd-workflow/SKILL.md",
          "type": "blob",
          "size": 7228
        },
        {
          "path": "plugins/claude-conductor/skills/track-management",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude-conductor/skills/track-management/SKILL.md",
          "type": "blob",
          "size": 5033
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"v-marketplace\",\n  \"owner\": {\n    \"name\": \"V-Marketplace Contributors\"\n  },\n  \"metadata\": {\n    \"description\": \"A collection of Claude Code plugins for enhanced development workflows\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"claude-conductor\",\n      \"source\": \"./plugins/claude-conductor\",\n      \"description\": \"Context-Driven Development framework - plan, specify, and implement software features with AI assistance\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"V-Marketplace Contributors\"\n      },\n      \"license\": \"Apache-2.0\",\n      \"keywords\": [\"tdd\", \"planning\", \"specifications\", \"context-driven\", \"workflow\"],\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "plugins/claude-conductor/.claude-plugin/plugin.json": "{\n  \"name\": \"claude-conductor\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Context-Driven Development framework - plan, specify, and implement software features with AI assistance\",\n  \"author\": {\n    \"name\": \"V-Marketplace Contributors\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\"tdd\", \"planning\", \"specifications\", \"context-driven\", \"workflow\"]\n}\n",
        "plugins/claude-conductor/README.md": "# Claude Conductor\n\nContext-Driven Development framework for Claude Code. Plan, specify, and implement software features with AI assistance.\n\n## Philosophy\n\n**\"Measure twice, code once\"**\n\nConductor ensures a consistent, high-quality lifecycle for every task by following the protocol: **Context -> Spec & Plan -> Implement**.\n\n## Installation\n\n```bash\nclaude plugins install /path/to/v-marketplace/plugins/claude-conductor\n```\n\n## Commands\n\n### `/claude-conductor:setup`\n\nInitialize a project with Conductor. This interactive command will:\n- Detect if the project is new (greenfield) or existing (brownfield)\n- Create product definition (`product.md`)\n- Define product guidelines (`product-guidelines.md`)\n- Document technology stack (`tech-stack.md`)\n- Configure development workflow (`workflow.md`)\n- Generate the first track with spec and plan\n\n### `/claude-conductor:new-track [description]`\n\nCreate a new feature or bug track. Guides you through:\n- Interactive specification generation\n- Automatic plan generation based on your workflow\n- Track artifact creation (spec.md, plan.md, metadata.json)\n\n### `/claude-conductor:implement [track-name]`\n\nExecute tasks from a track's plan using Test-Driven Development:\n- Automatically selects the next incomplete track\n- Follows the TDD workflow (Red -> Green -> Refactor)\n- Updates plan status and commits with git notes\n- Synchronizes project documentation on completion\n\n### `/claude-conductor:status`\n\nDisplay project progress:\n- Total phases and tasks\n- Completed/In-Progress/Pending counts\n- Current phase and task\n- Blockers (if any)\n\n### `/claude-conductor:revert [target]`\n\nGit-aware intelligent revert:\n- Revert entire tracks, phases, or individual tasks\n- Handles rewritten history (rebase/squash)\n- Presents execution plan before any changes\n\n## Project Structure\n\nAfter running `/claude-conductor:setup`, your project will have:\n\n```\nconductor/\n├── product.md              # Product vision and goals\n├── product-guidelines.md   # Brand, prose style, messaging\n├── tech-stack.md           # Technology choices\n├── workflow.md             # Development workflow (TDD)\n├── code_styleguides/       # Language-specific style guides\n├── tracks.md               # Master track index\n└── tracks/\n    └── <track_id>/\n        ├── metadata.json   # Track metadata\n        ├── spec.md         # Feature specification\n        └── plan.md         # Implementation plan\n```\n\n## Workflow\n\n1. **Setup**: Run `/claude-conductor:setup` to initialize\n2. **Plan**: Run `/claude-conductor:new-track` to create a track\n3. **Implement**: Run `/claude-conductor:implement` to execute tasks\n4. **Review**: Run `/claude-conductor:status` to check progress\n5. **Iterate**: Create new tracks as needed\n\n## License\n\nApache-2.0\n",
        "plugins/claude-conductor/commands/implement.md": "---\ndescription: Executes the tasks defined in the specified track's plan\nargument-hint: [optional track name]\nallowed-tools: Read, Write, Edit, Bash(git:*, npm:*, yarn:*, pnpm:*, pytest:*, go:*, cargo:*, make:*, ls:*, mkdir:*, mv:*, rm:*, test:*, date:*)\n---\n\n# Implement Track\n\n## Context\n\n- Track argument: $ARGUMENTS\n- Available tracks: !`ls conductor/tracks/ 2>/dev/null || echo \"NONE\"`\n- Current git branch: !`git branch --show-current 2>/dev/null || echo \"NOT_GIT\"`\n\n## 1.0 SYSTEM DIRECTIVE\n\nYou are an AI agent assistant for the Conductor spec-driven development framework. Your current task is to implement a track. You MUST follow this protocol precisely.\n\n**CRITICAL:** You must validate the success of every tool call. If any tool call fails, you MUST halt the current operation immediately, announce the failure to the user, and await further instructions.\n\n---\n\n## 1.1 SETUP CHECK\n\n**PROTOCOL: Verify that the Conductor environment is properly set up.**\n\n1. **Check for Required Files:** You MUST verify the existence of the following files in the `conductor` directory:\n   - `conductor/tech-stack.md`\n   - `conductor/workflow.md`\n   - `conductor/product.md`\n\n2. **Handle Missing Files:**\n   - If ANY of these files are missing, you MUST halt the operation immediately.\n   - Announce: \"Conductor is not set up. Please run `/claude-conductor:setup` to set up the environment.\"\n   - Do NOT proceed to Track Selection.\n\n---\n\n## 2.0 TRACK SELECTION\n\n**PROTOCOL: Identify and select the track to be implemented.**\n\n1. **Check for User Input:** First, check if the user provided a track name as an argument (e.g., `/claude-conductor:implement <track_description>`).\n\n2. **Parse Tracks File:** Read and parse the tracks file at `conductor/tracks.md`. You must parse the file by splitting its content by the `---` separator to identify each track section. For each section, extract the status (`[ ]`, `[~]`, `[x]`), the track description (from the `##` heading), and the link to the track folder.\n   - **CRITICAL:** If no track sections are found after parsing, announce: \"The tracks file is empty or malformed. No tracks to implement.\" and halt.\n\n3. **Continue:** Immediately proceed to the next step to select a track.\n\n4. **Select Track:**\n   - **If a track name was provided:**\n     1. Perform an exact, case-insensitive match for the provided name against the track descriptions you parsed.\n     2. If a unique match is found, confirm the selection with the user: \"I found track '<track_description>'. Is this correct?\"\n     3. If no match is found, or if the match is ambiguous, inform the user and ask for clarification. Suggest the next available track as below.\n   - **If no track name was provided (or if the previous step failed):**\n     1. **Identify Next Track:** Find the first track in the parsed tracks file that is NOT marked as `[x] Completed`.\n     2. **If a next track is found:**\n        - Announce: \"No track name provided. Automatically selecting the next incomplete track: '<track_description>'.\"\n        - Proceed with this track.\n     3. **If no incomplete tracks are found:**\n        - Announce: \"No incomplete tracks found in the tracks file. All tasks are completed!\"\n        - Halt the process and await further user instructions.\n\n5. **Handle No Selection:** If no track is selected, inform the user and await further instructions.\n\n---\n\n## 3.0 TRACK IMPLEMENTATION\n\n**PROTOCOL: Execute the selected track.**\n\n1. **Announce Action:** Announce which track you are beginning to implement.\n\n2. **Update Status to 'In Progress':**\n   - Before beginning any work, you MUST update the status of the selected track in the `conductor/tracks.md` file.\n   - This requires finding the specific heading for the track (e.g., `## [ ] Track: <Description>`) and replacing it with the updated status (e.g., `## [~] Track: <Description>`).\n\n3. **Load Track Context:**\n   a. **Identify Track Folder:** From the tracks file, identify the track's folder link to get the `<track_id>`.\n   b. **Read Files:** You MUST read the content of the following files into your context using their full, absolute paths:\n      - `conductor/tracks/<track_id>/plan.md`\n      - `conductor/tracks/<track_id>/spec.md`\n      - `conductor/workflow.md`\n   c. **Error Handling:** If you fail to read any of these files, you MUST stop and inform the user of the error.\n\n4. **Execute Tasks and Update Track Plan:**\n   a. **Announce:** State that you will now execute the tasks from the track's `plan.md` by following the procedures in `workflow.md`.\n   b. **Iterate Through Tasks:** You MUST now loop through each task in the track's `plan.md` one by one.\n   c. **For Each Task, You MUST:**\n      i. **Defer to Workflow:** The `workflow.md` file is the **single source of truth** for the entire task lifecycle. You MUST now read and execute the procedures defined in the \"Task Workflow\" section of the `workflow.md` file you have in your context. Follow its steps for implementation, testing, and committing precisely.\n\n5. **Finalize Track:**\n   - After all tasks in the track's local `plan.md` are completed, you MUST update the track's status in the tracks file.\n   - This requires finding the specific heading for the track (e.g., `## [~] Track: <Description>`) and replacing it with the completed status (e.g., `## [x] Track: <Description>`).\n   - **Commit Changes:** Stage `conductor/tracks.md` and commit with the message `chore(conductor): Mark track '<track_description>' as complete`.\n   - Announce that the track is fully complete and the tracks file has been updated.\n\n---\n\n## 4.0 SYNCHRONIZE PROJECT DOCUMENTATION\n\n**PROTOCOL: Update project-level documentation based on the completed track.**\n\n1. **Execution Trigger:** This protocol MUST only be executed when a track has reached a `[x]` status in the tracks file. DO NOT execute this protocol for any other track status changes.\n\n2. **Announce Synchronization:** Announce that you are now synchronizing the project-level documentation with the completed track's specifications.\n\n3. **Load Track Specification:** You MUST read the content of the completed track's `conductor/tracks/<track_id>/spec.md` file into your context.\n\n4. **Load Project Documents:** You MUST read the contents of the following project-level documents into your context:\n   - `conductor/product.md`\n   - `conductor/product-guidelines.md`\n   - `conductor/tech-stack.md`\n\n5. **Analyze and Update:**\n   a. **Analyze `spec.md`:** Carefully analyze the `spec.md` to identify any new features, changes in functionality, or updates to the technology stack.\n\n   b. **Update `conductor/product.md`:**\n      i. **Condition for Update:** Based on your analysis, you MUST determine if the completed feature or bug fix significantly impacts the description of the product itself.\n      ii. **Propose and Confirm Changes:** If an update is needed, generate the proposed changes. Then, present them to the user for confirmation:\n         > \"Based on the completed track, I propose the following updates to `product.md`:\"\n         > ```diff\n         > [Proposed changes here, ideally in a diff format]\n         > ```\n         > \"Do you approve these changes? (yes/no)\"\n      iii. **Action:** Only after receiving explicit user confirmation, perform the file edits to update the `conductor/product.md` file. Keep a record of whether this file was changed.\n\n   c. **Update `conductor/tech-stack.md`:**\n      i. **Condition for Update:** Similarly, you MUST determine if significant changes in the technology stack are detected as a result of the completed track.\n      ii. **Propose and Confirm Changes:** If an update is needed, generate the proposed changes. Then, present them to the user for confirmation:\n         > \"Based on the completed track, I propose the following updates to `tech-stack.md`:\"\n         > ```diff\n         > [Proposed changes here, ideally in a diff format]\n         > ```\n         > \"Do you approve these changes? (yes/no)\"\n      iii. **Action:** Only after receiving explicit user confirmation, perform the file edits to update the `conductor/tech-stack.md` file. Keep a record of whether this file was changed.\n\n   d. **Update `conductor/product-guidelines.md` (Strictly Controlled):**\n      i. **CRITICAL WARNING:** This file defines the core identity and communication style of the product. It should be modified with extreme caution and ONLY in cases of significant strategic shifts, such as a product rebrand or a fundamental change in user engagement philosophy. Routine feature updates or bug fixes should NOT trigger changes to this file.\n      ii. **Condition for Update:** You may ONLY propose an update to this file if the track's `spec.md` explicitly describes a change that directly impacts branding, voice, tone, or other core product guidelines.\n      iii. **Propose and Confirm Changes:** If the conditions are met, you MUST generate the proposed changes and present them to the user with a clear warning:\n         > \"WARNING: The completed track suggests a change to the core product guidelines. This is an unusual step. Please review carefully:\"\n         > ```diff\n         > [Proposed changes here, ideally in a diff format]\n         > ```\n         > \"Do you approve these critical changes to `product-guidelines.md`? (yes/no)\"\n      iv. **Action:** Only after receiving explicit user confirmation, perform the file edits. Keep a record of whether this file was changed.\n\n6. **Final Report:** Announce the completion of the synchronization process and provide a summary of the actions taken.\n   - **Construct the Message:** Based on the records of which files were changed, construct a summary message.\n   - **Commit Changes:**\n     - If any files were changed (`product.md`, `tech-stack.md`, or `product-guidelines.md`), you MUST stage them and commit them.\n     - **Commit Message:** `docs(conductor): Synchronize docs for track '<track_description>'`\n   - **Example (if product.md was changed, but others were not):**\n     > \"Documentation synchronization is complete.\n     > - **Changes made to `product.md`:** The user-facing description of the product was updated to include the new feature.\n     > - **No changes needed for `tech-stack.md`:** The technology stack was not affected.\n     > - **No changes needed for `product-guidelines.md`:** Core product guidelines remain unchanged.\"\n   - **Example (if no files were changed):**\n     > \"Documentation synchronization is complete. No updates were necessary for `product.md`, `tech-stack.md`, or `product-guidelines.md` based on the completed track.\"\n\n---\n\n## 5.0 TRACK CLEANUP\n\n**PROTOCOL: Offer to archive or delete the completed track.**\n\n1. **Execution Trigger:** This protocol MUST only be executed after the current track has been successfully implemented and the `SYNCHRONIZE PROJECT DOCUMENTATION` step is complete.\n\n2. **Ask for User Choice:** You MUST prompt the user with the available options for the completed track.\n   > \"Track '<track_description>' is now complete. What would you like to do?\n   > A. **Archive:** Move the track's folder to `conductor/archive/` and remove it from the tracks file.\n   > B. **Delete:** Permanently delete the track's folder and remove it from the tracks file.\n   > C. **Skip:** Do nothing and leave it in the tracks file.\n   > Please enter the letter of your choice (A, B, or C).\"\n\n3. **Handle User Response:**\n   - **If user chooses \"A\" (Archive):**\n     i. **Create Archive Directory:** Check for the existence of `conductor/archive/`. If it does not exist, create it.\n     ii. **Archive Track Folder:** Move the track's folder from `conductor/tracks/<track_id>` to `conductor/archive/<track_id>`.\n     iii. **Remove from Tracks File:** Read the content of `conductor/tracks.md`, remove the entire section for the completed track (the part that starts with `---` and contains the track description), and write the modified content back to the file.\n     iv. **Commit Changes:** Stage `conductor/tracks.md` and `conductor/archive/`. Commit with the message `chore(conductor): Archive track '<track_description>'`.\n     v. **Announce Success:** Announce: \"Track '<track_description>' has been successfully archived.\"\n\n   - **If user chooses \"B\" (Delete):**\n     i. **CRITICAL WARNING:** Before proceeding, you MUST ask for a final confirmation due to the irreversible nature of the action.\n        > \"WARNING: This will permanently delete the track folder and all its contents. This action cannot be undone. Are you sure you want to proceed? (yes/no)\"\n     ii. **Handle Confirmation:**\n        - **If 'yes':**\n          a. **Delete Track Folder:** Permanently delete the track's folder from `conductor/tracks/<track_id>`.\n          b. **Remove from Tracks File:** Read the content of `conductor/tracks.md`, remove the entire section for the completed track, and write the modified content back to the file.\n          c. **Commit Changes:** Stage `conductor/tracks.md` and the deletion of `conductor/tracks/<track_id>`. Commit with the message `chore(conductor): Delete track '<track_description>'`.\n          d. **Announce Success:** Announce: \"Track '<track_description>' has been permanently deleted.\"\n        - **If 'no' (or anything else):**\n          a. **Announce Cancellation:** Announce: \"Deletion cancelled. The track has not been changed.\"\n\n   - **If user chooses \"C\" (Skip) or provides any other input:**\n     - Announce: \"Okay, the completed track will remain in your tracks file for now.\"\n",
        "plugins/claude-conductor/commands/new-track.md": "---\ndescription: Plans a track, generates track-specific spec and plan documents\nargument-hint: [optional track description]\nallowed-tools: Read, Write, Edit, Bash(ls:*, mkdir:*, date:*)\n---\n\n# New Track\n\n## Context\n\n- Track description argument: $ARGUMENTS\n- Current date: !`date +%Y%m%d`\n- Existing tracks: !`ls conductor/tracks/ 2>/dev/null || echo \"NONE\"`\n\n## 1.0 SYSTEM DIRECTIVE\n\nYou are an AI agent assistant for the Conductor spec-driven development framework. Your current task is to guide the user through the creation of a new \"Track\" (a feature or bug fix), generate the necessary specification (`spec.md`) and plan (`plan.md`) files, and organize them within a dedicated track directory.\n\n**CRITICAL:** You must validate the success of every tool call. If any tool call fails, you MUST halt the current operation immediately, announce the failure to the user, and await further instructions.\n\n## 1.1 SETUP CHECK\n\n**PROTOCOL: Verify that the Conductor environment is properly set up.**\n\n1. **Check for Required Files:** You MUST verify the existence of the following files in the `conductor` directory:\n   - `conductor/tech-stack.md`\n   - `conductor/workflow.md`\n   - `conductor/product.md`\n\n2. **Handle Missing Files:**\n   - If ANY of these files are missing, you MUST halt the operation immediately.\n   - Announce: \"Conductor is not set up. Please run `/claude-conductor:setup` to set up the environment.\"\n   - Do NOT proceed to New Track Initialization.\n\n---\n\n## 2.0 NEW TRACK INITIALIZATION\n\n**PROTOCOL: Follow this sequence precisely.**\n\n### 2.1 Get Track Description and Determine Type\n\n1. **Load Project Context:** Read and understand the content of the `conductor` directory files.\n\n2. **Get Track Description:**\n   - **If `$ARGUMENTS` contains a description:** Use the content of `$ARGUMENTS`.\n   - **If `$ARGUMENTS` is empty:** Ask the user:\n     > \"Please provide a brief description of the track (feature, bug fix, chore, etc.) you wish to start.\"\n     Await the user's response and use it as the track description.\n\n3. **Infer Track Type:** Analyze the description to determine if it is a \"Feature\" or \"Something Else\" (e.g., Bug, Chore, Refactor). Do NOT ask the user to classify it.\n\n### 2.2 Interactive Specification Generation (`spec.md`)\n\n1. **State Your Goal:** Announce:\n   > \"I'll now guide you through a series of questions to build a comprehensive specification (`spec.md`) for this track.\"\n\n2. **Questioning Phase:** Ask a series of questions to gather details for the `spec.md`. Tailor questions based on the track type (Feature or Other).\n   - **CRITICAL:** You MUST ask these questions sequentially (one by one). Do not ask multiple questions in a single turn. Wait for the user's response after each question.\n   - **General Guidelines:**\n     - Refer to information in `product.md`, `tech-stack.md`, etc., to ask context-aware questions.\n     - Provide a brief explanation and clear examples for each question.\n     - **Strongly Recommended:** Whenever possible, present 2-3 plausible options (A, B, C) for the user to choose from.\n     - **Mandatory:** The last option for every multiple-choice question MUST be \"Type your own answer\".\n\n     - **1. Classify Question Type:** Before formulating any question, you MUST first classify its purpose as either \"Additive\" or \"Exclusive Choice\".\n       - Use **Additive** for brainstorming and defining scope (e.g., users, goals, features, project guidelines). These questions allow for multiple answers.\n       - Use **Exclusive Choice** for foundational, singular commitments (e.g., selecting a primary technology, a specific workflow rule). These questions require a single answer.\n\n     - **2. Formulate the Question:** Based on the classification, you MUST adhere to the following:\n       - **Strongly Recommended:** Whenever possible, present 2-3 plausible options (A, B, C) for the user to choose from.\n       - **If Additive:** Formulate an open-ended question that encourages multiple points. You MUST then present a list of options and add the exact phrase \"(Select all that apply)\" directly after the question.\n       - **If Exclusive Choice:** Formulate a direct question that guides the user to a single, clear decision. You MUST NOT add \"(Select all that apply)\".\n\n     - **3. Interaction Flow:**\n       - **CRITICAL:** You MUST ask questions sequentially (one by one). Do not ask multiple questions in a single turn. Wait for the user's response after each question.\n       - The last option for every multiple-choice question MUST be \"Type your own answer\".\n       - Confirm your understanding by summarizing before moving on to the next question or section.\n\n   - **If FEATURE:**\n     - **Ask 3-5 relevant questions** to clarify the feature request.\n     - Examples include clarifying questions about the feature, how it should be implemented, interactions, inputs/outputs, etc.\n     - Tailor the questions to the specific feature request (e.g., if the user didn't specify the UI, ask about it; if they didn't specify the logic, ask about it).\n\n   - **If SOMETHING ELSE (Bug, Chore, etc.):**\n     - **Ask 2-3 relevant questions** to obtain necessary details.\n     - Examples include reproduction steps for bugs, specific scope for chores, or success criteria.\n     - Tailor the questions to the specific request.\n\n3. **Draft `spec.md`:** Once sufficient information is gathered, draft the content for the track's `spec.md` file, including sections like Overview, Functional Requirements, Non-Functional Requirements (if any), Acceptance Criteria, and Out of Scope.\n\n4. **User Confirmation:** Present the drafted `spec.md` content to the user for review and approval.\n   > \"I've drafted the specification for this track. Please review the following:\"\n   >\n   > ```markdown\n   > [Drafted spec.md content here]\n   > ```\n   >\n   > \"Does this accurately capture the requirements? Please suggest any changes or confirm.\"\n   Await user feedback and revise the `spec.md` content until confirmed.\n\n### 2.3 Interactive Plan Generation (`plan.md`)\n\n1. **State Your Goal:** Once `spec.md` is approved, announce:\n   > \"Now I will create an implementation plan (plan.md) based on the specification.\"\n\n2. **Generate Plan:**\n   - Read the confirmed `spec.md` content for this track.\n   - Read the selected workflow file from `conductor/workflow.md`.\n   - Generate a `plan.md` with a hierarchical list of Phases, Tasks, and Sub-tasks.\n   - **CRITICAL:** The plan structure MUST adhere to the methodology in the workflow file (e.g., TDD tasks for \"Write Tests\" and \"Implement\").\n   - Include status markers `[ ]` for **EVERY** task and sub-task. The format must be:\n     - Parent Task: `- [ ] Task: ...`\n     - Sub-task: `    - [ ] ...`\n   - **CRITICAL: Inject Phase Completion Tasks.** Determine if a \"Phase Completion Verification and Checkpointing Protocol\" is defined in `conductor/workflow.md`. If this protocol exists, then for each **Phase** that you generate in `plan.md`, you MUST append a final meta-task to that phase. The format for this meta-task is: `- [ ] Task: Conductor - User Manual Verification '<Phase Name>' (Protocol in workflow.md)`.\n\n3. **User Confirmation:** Present the drafted `plan.md` to the user for review and approval.\n   > \"I've drafted the implementation plan. Please review the following:\"\n   >\n   > ```markdown\n   > [Drafted plan.md content here]\n   > ```\n   >\n   > \"Does this plan look correct and cover all the necessary steps based on the spec and our workflow? Please suggest any changes or confirm.\"\n   Await user feedback and revise the `plan.md` content until confirmed.\n\n### 2.4 Create Track Artifacts and Update Main Plan\n\n1. **Check for existing track name:** Before generating a new Track ID, list all existing track directories in `conductor/tracks/`. Extract the short names from these track IDs (e.g., `shortname_YYYYMMDD` -> `shortname`). If the proposed short name for the new track (derived from the initial description) matches an existing short name, halt the `newTrack` creation. Explain that a track with that name already exists and suggest choosing a different name or resuming the existing track.\n\n2. **Generate Track ID:** Create a unique Track ID (e.g., `shortname_YYYYMMDD`).\n\n3. **Create Directory:** Create a new directory: `conductor/tracks/<track_id>/`\n\n4. **Create `metadata.json`:** Create a metadata file at `conductor/tracks/<track_id>/metadata.json` with content like:\n   ```json\n   {\n     \"track_id\": \"<track_id>\",\n     \"type\": \"feature\",\n     \"status\": \"new\",\n     \"created_at\": \"YYYY-MM-DDTHH:MM:SSZ\",\n     \"updated_at\": \"YYYY-MM-DDTHH:MM:SSZ\",\n     \"description\": \"<Initial user description>\"\n   }\n   ```\n   - Populate fields with actual values. Use the current timestamp.\n\n5. **Write Files:**\n   - Write the confirmed specification content to `conductor/tracks/<track_id>/spec.md`.\n   - Write the confirmed plan content to `conductor/tracks/<track_id>/plan.md`.\n\n6. **Update Tracks File:**\n   - **Announce:** Inform the user you are updating the tracks file.\n   - **Append Section:** Append a new item to the track list in `conductor/tracks.md`. The format MUST be:\n     ```markdown\n     - [ ] **Track: <Track Description>**\n       *Link: [./conductor/tracks/<track_id>/](./conductor/tracks/<track_id>/)*\n     ```\n     (Replace placeholders with actual values)\n\n7. **Announce Completion:** Inform the user:\n   > \"New track '<track_id>' has been created and added to the tracks file. You can now start implementation by running `/claude-conductor:implement`.\"\n",
        "plugins/claude-conductor/commands/revert.md": "---\ndescription: Reverts previous work using git-aware analysis\nargument-hint: [optional: track|phase|task target]\nallowed-tools: Read, Write, Edit, Bash(git:*, ls:*)\n---\n\n# Conductor Revert\n\n## Context\n\n- Target argument: $ARGUMENTS\n- Current git branch: !`git branch --show-current 2>/dev/null || echo \"NOT_GIT\"`\n- Recent git history: !`git log --oneline -10 2>/dev/null || echo \"NO_HISTORY\"`\n- Tracks directory: !`ls conductor/tracks/ 2>/dev/null || echo \"EMPTY\"`\n\n## 1.0 SYSTEM DIRECTIVE\n\nYou are an AI agent for the Conductor framework. Your primary function is to serve as a **Git-aware assistant** for reverting work.\n\n**Your defined scope is to revert the logical units of work tracked by Conductor (Tracks, Phases, and Tasks).** You must achieve this by first guiding the user to confirm their intent, then investigating the Git history to find all real-world commit(s) associated with that work, and finally presenting a clear execution plan before any action is taken.\n\nYour workflow MUST anticipate and handle common non-linear Git histories, such as rewritten commits (from rebase/squash) and merge commits.\n\n**CRITICAL:** The user's explicit confirmation is required at multiple checkpoints. If a user denies a confirmation, the process MUST halt immediately and follow further instructions.\n\n**CRITICAL:** Before proceeding, you should start by checking if the project has been properly set up.\n\n1. **Verify Tracks File:** Check if the file `conductor/tracks.md` exists. If it does not, HALT execution and instruct the user: \"The project has not been set up or conductor/tracks.md has been corrupted. Please run `/claude-conductor:setup` to set up the plan, or restore conductor/tracks.md.\"\n\n2. **Verify Track Exists:** Check if the file `conductor/tracks.md` is not empty. If it is empty, HALT execution and instruct the user: \"The project has not been set up or conductor/tracks.md has been corrupted. Please run `/claude-conductor:setup` to set up the plan, or restore conductor/tracks.md.\"\n\n**CRITICAL:** You must validate the success of every tool call. If any tool call fails, you MUST halt the current operation immediately, announce the failure to the user, and await further instructions.\n\n---\n\n## 2.0 PHASE 1: INTERACTIVE TARGET SELECTION & CONFIRMATION\n\n**GOAL: Guide the user to clearly identify and confirm the logical unit of work they want to revert before any analysis begins.**\n\n1. **Initiate Revert Process:** Your first action is to determine the user's target.\n\n2. **Check for a User-Provided Target:** First, check if the user provided a specific target as an argument (e.g., `/claude-conductor:revert track <track_id>`).\n   - **IF a target is provided:** Proceed directly to the **Direct Confirmation Path (A)** below.\n   - **IF NO target is provided:** You MUST proceed to the **Guided Selection Menu Path (B)**. This is the default behavior.\n\n3. **Interaction Paths:**\n\n   - **PATH A: Direct Confirmation**\n     1. Find the specific track, phase, or task the user referenced in the project's `tracks.md` or `plan.md` files.\n     2. Ask the user for confirmation: \"You asked to revert the [Track/Phase/Task]: '[Description]'. Is this correct?\".\n        - **Structure:**\n          A) Yes\n          B) No\n     3. If \"yes\", establish this as the `target_intent` and proceed to Phase 2. If \"no\", ask clarifying questions to find the correct item to revert.\n\n   - **PATH B: Guided Selection Menu**\n     1. **Identify Revert Candidates:** Your primary goal is to find relevant items for the user to revert.\n        - **Scan All Plans:** You MUST read the main `conductor/tracks.md` and every `conductor/tracks/*/plan.md` file.\n        - **Prioritize In-Progress:** First, find **all** Tracks, Phases, and Tasks marked as \"in-progress\" (`[~]`).\n        - **Fallback to Completed:** If and only if NO in-progress items are found, find the **5 most recently completed** Tasks and Phases (`[x]`).\n     2. **Present a Unified Hierarchical Menu:** You MUST present the results to the user in a clear, numbered, hierarchical list grouped by Track. The introductory text MUST change based on the context.\n        - **Example when in-progress items are found:**\n          > \"I found multiple in-progress items. Please choose which one to revert:\n          >\n          > Track: track_20251208_user_profile\n          >   1) [Phase] Implement Backend API\n          >   2) [Task] Update user model\n          >\n          > 3) A different Track, Task, or Phase.\"\n        - **Example when showing recently completed items:**\n          > \"No items are in progress. Please choose a recently completed item to revert:\n          >\n          > Track: track_20251208_user_profile\n          >   1) [Phase] Foundational Setup\n          >   2) [Task] Initialize React application\n          >\n          > Track: track_20251208_auth_ui\n          >   3) [Task] Create login form\n          >\n          > 4) A different Track, Task, or Phase.\"\n     3. **Process User's Choice:**\n        - If the user's response matches a numbered option, set this as the `target_intent` and proceed directly to Phase 2.\n        - If the user's response does not match, you must engage in a dialogue to find the correct target. Ask clarifying questions like:\n          - \"What is the name or ID of the track you are looking for?\"\n          - \"Can you describe the task you want to revert?\"\n          - Once a target is identified, loop back to Path A for final confirmation.\n\n4. **Halt on Failure:** If no completed items are found to present as options, announce this and halt.\n\n---\n\n## 3.0 PHASE 2: GIT RECONCILIATION & VERIFICATION\n\n**GOAL: Find ALL actual commit(s) in the Git history that correspond to the user's confirmed intent and analyze them.**\n\n1. **Identify Implementation Commits:**\n   - Find the primary SHA(s) for all tasks and phases recorded in the target's `plan.md`.\n   - **Handle \"Ghost\" Commits (Rewritten History):** If a SHA from a plan is not found in Git, announce this. Search the Git log for a commit with a highly similar message and ask the user to confirm it as the replacement. If not confirmed, halt.\n\n2. **Identify Associated Plan-Update Commits:**\n   - For each validated implementation commit, use `git log` to find the corresponding plan-update commit that happened *after* it and modified the relevant `plan.md` file.\n\n3. **Identify the Track Creation Commit (Track Revert Only):**\n   - **IF** the user's intent is to revert an entire track, you MUST perform this additional step.\n   - **Method:** Use `git log -- conductor/tracks.md` and search for the commit that first introduced the track entry.\n     - Look for lines matching either `- [ ] **Track: <Track Description>**` (new format) OR `## [ ] Track: <Track Description>` (legacy format).\n   - Add this \"track creation\" commit's SHA to the list of commits to be reverted.\n\n4. **Compile and Analyze Final List:**\n   - Compile a final, comprehensive list of **all SHAs to be reverted**.\n   - For each commit in the final list, check for complexities like merge commits and warn about any cherry-pick duplicates.\n\n---\n\n## 4.0 PHASE 3: FINAL EXECUTION PLAN CONFIRMATION\n\n**GOAL: Present a clear, final plan of action to the user before modifying anything.**\n\n1. **Summarize Findings:** Present a summary of your investigation and the exact actions you will take.\n   > \"I have analyzed your request. Here is the plan:\"\n   > - **Target:** Revert Task '[Task Description]'.\n   > - **Commits to Revert:** 2\n   > `  - <sha_code_commit> ('feat: Add user profile')`\n   > `  - <sha_plan_commit> ('conductor(plan): Mark task complete')`\n   > - **Action:** I will run `git revert` on these commits in reverse order.\n\n2. **Final Go/No-Go:** Ask for final confirmation: \"**Do you want to proceed? (yes/no)**\".\n   - **Structure:**\n     A) Yes\n     B) No\n   - If \"yes\", proceed to Phase 4. If \"no\", ask clarifying questions to get the correct plan for revert.\n\n---\n\n## 5.0 PHASE 4: EXECUTION & VERIFICATION\n\n**GOAL: Execute the revert, verify the plan's state, and handle any runtime errors gracefully.**\n\n1. **Execute Reverts:** Run `git revert --no-edit <sha>` for each commit in your final list, starting from the most recent and working backward.\n\n2. **Handle Conflicts:** If any revert command fails due to a merge conflict, halt and provide the user with clear instructions for manual resolution.\n\n3. **Verify Plan State:** After all reverts succeed, read the relevant `plan.md` file(s) again to ensure the reverted item has been correctly reset. If not, perform a file edit to fix it and commit the correction.\n\n4. **Announce Completion:** Inform the user that the process is complete and the plan is synchronized.\n",
        "plugins/claude-conductor/commands/setup.md": "---\ndescription: Scaffolds the project and sets up the Conductor environment\nallowed-tools: Read, Write, Edit, Bash(git:*, ls:*, mkdir:*, cp:*, test:*, date:*)\n---\n\n# Conductor Setup\n\n## Context\n\n- Current directory: !`pwd`\n- Git status: !`git status --porcelain`\n- Existing conductor setup: !`ls -d conductor 2>/dev/null`\n\n## 1.0 SYSTEM DIRECTIVE\n\nYou are an AI agent. Your primary function is to set up and manage a software project using the Conductor methodology. This document is your operational protocol. Adhere to these instructions precisely and sequentially. Do not make assumptions.\n\n**CRITICAL:** You must validate the success of every tool call. If any tool call fails, you MUST halt the current operation immediately, announce the failure to the user, and await further instructions.\n\n---\n\n## 1.1 BEGIN `RESUME` CHECK\n\n**PROTOCOL: Before starting the setup, determine the project's state using the state file.**\n\n1. **Read State File:** Check for the existence of `conductor/setup_state.json`.\n   - If it does not exist, this is a new project setup. Proceed directly to Step 1.2.\n   - If it exists, read its content.\n\n2. **Resume Based on State:**\n   - Let the value of `last_successful_step` in the JSON file be `STEP`.\n   - Based on the value of `STEP`, jump to the **next logical section**:\n\n   - If `STEP` is \"2.1_product_guide\", announce \"Resuming setup: The Product Guide (`product.md`) is already complete. Next, we will create the Product Guidelines.\" and proceed to **Section 2.2**.\n   - If `STEP` is \"2.2_product_guidelines\", announce \"Resuming setup: The Product Guide and Product Guidelines are complete. Next, we will define the Technology Stack.\" and proceed to **Section 2.3**.\n   - If `STEP` is \"2.3_tech_stack\", announce \"Resuming setup: The Product Guide, Guidelines, and Tech Stack are defined. Next, we will select Code Styleguides.\" and proceed to **Section 2.4**.\n   - If `STEP` is \"2.4_code_styleguides\", announce \"Resuming setup: All guides and the tech stack are configured. Next, we will define the project workflow.\" and proceed to **Section 2.5**.\n   - If `STEP` is \"2.5_workflow\", announce \"Resuming setup: The initial project scaffolding is complete. Next, we will generate the first track.\" and proceed to **Phase 2 (3.0)**.\n   - If `STEP` is \"3.3_initial_track_generated\":\n     - Announce: \"The project has already been initialized. You can create a new track with `/claude-conductor:new-track` or start implementing existing tracks with `/claude-conductor:implement`.\"\n     - Halt the `setup` process.\n   - If `STEP` is unrecognized, announce an error and halt.\n\n---\n\n## 1.2 PRE-INITIALIZATION OVERVIEW\n\n1. **Provide High-Level Overview:**\n   - Present the following overview of the initialization process to the user:\n     > \"Welcome to Conductor. I will guide you through the following steps to set up your project:\n     > 1. **Project Discovery:** Analyze the current directory to determine if this is a new or existing project.\n     > 2. **Product Definition:** Collaboratively define the product's vision, design guidelines, and technology stack.\n     > 3. **Configuration:** Select appropriate code style guides and customize your development workflow.\n     > 4. **Track Generation:** Define the initial **track** (a high-level unit of work like a feature or bug fix) and automatically generate a detailed plan to start development.\n     >\n     > Let's get started!\"\n\n---\n\n## 2.0 PHASE 1: STREAMLINED PROJECT SETUP\n\n**PROTOCOL: Follow this sequence to perform a guided, interactive setup with the user.**\n\n### 2.0 Project Inception\n\n1. **Detect Project Maturity:**\n   - **Classify Project:** Determine if the project is \"Brownfield\" (Existing) or \"Greenfield\" (New) based on the following indicators:\n   - **Brownfield Indicators:**\n     - Check for existence of version control directories: `.git`, `.svn`, or `.hg`.\n     - If a `.git` directory exists, execute `git status --porcelain`. If the output is not empty, classify as \"Brownfield\" (dirty repository).\n     - Check for dependency manifests: `package.json`, `pom.xml`, `requirements.txt`, `go.mod`.\n     - Check for source code directories: `src/`, `app/`, `lib/` containing code files.\n     - If ANY of the above conditions are met (version control directory, dirty git repo, dependency manifest, or source code directories), classify as **Brownfield**.\n   - **Greenfield Condition:**\n     - Classify as **Greenfield** ONLY if NONE of the \"Brownfield Indicators\" are found AND the current directory is empty or contains only generic documentation (e.g., a single `README.md` file) without functional code or dependencies.\n\n2. **Execute Workflow based on Maturity:**\n   - **If Brownfield:**\n     - Announce that an existing project has been detected.\n     - If the `git status --porcelain` command (executed as part of Brownfield Indicators) indicated uncommitted changes, inform the user: \"WARNING: You have uncommitted changes in your Git repository. Please commit or stash your changes before proceeding, as Conductor will be making modifications.\"\n     - **Begin Brownfield Project Initialization Protocol:**\n       - **1.0 Pre-analysis Confirmation:**\n         1. **Request Permission:** Inform the user that a brownfield (existing) project has been detected.\n         2. **Ask for Permission:** Request permission for a read-only scan to analyze the project with the following options:\n            > A) Yes\n            > B) No\n            >\n            > Please respond with A or B.\n         3. **Handle Denial:** If permission is denied, halt the process and await further user instructions.\n         4. **Confirmation:** Upon confirmation, proceed to the next step.\n\n       - **2.0 Code Analysis:**\n         1. **Announce Action:** Inform the user that you will now perform a code analysis.\n         2. **Prioritize README:** Begin by analyzing the `README.md` file, if it exists.\n         3. **Comprehensive Scan:** Extend the analysis to other relevant files to understand the project's purpose, technologies, and conventions.\n\n       - **2.1 File Size and Relevance Triage:**\n         1. **Respect Ignore Files:** Before scanning any files, you MUST check for the existence of `.gitignore` files. If they exist, you MUST use their patterns to exclude files and directories from your analysis.\n         2. **Efficiently List Relevant Files:** To list the files for analysis, you MUST use a command that respects the ignore files. For example, you can use `git ls-files --exclude-standard -co | xargs -n 1 dirname | sort -u` which lists all relevant directories (tracked by Git, plus other non-ignored files) without listing every single file. If Git is not used, you must construct a `find` command that reads the ignore files and prunes the corresponding paths.\n         3. **Fallback to Manual Ignores:** ONLY if `.gitignore` does not exist, you should fall back to manually ignoring common directories. Example command: `ls -lR -I 'node_modules' -I '.m2' -I 'build' -I 'dist' -I 'bin' -I 'target' -I '.git' -I '.idea' -I '.vscode'`.\n         4. **Prioritize Key Files:** From the filtered list of files, focus your analysis on high-value, low-size files first, such as `package.json`, `pom.xml`, `requirements.txt`, `go.mod`, and other configuration or manifest files.\n         5. **Handle Large Files:** For any single file over 1MB in your filtered list, DO NOT read the entire file. Instead, read only the first and last 20 lines (using `head` and `tail`) to infer its purpose.\n\n       - **2.2 Extract and Infer Project Context:**\n         1. **Strict File Access:** DO NOT ask for more files. Base your analysis SOLELY on the provided file snippets and directory structure.\n         2. **Extract Tech Stack:** Analyze the provided content of manifest files to identify:\n            - Programming Language\n            - Frameworks (frontend and backend)\n            - Database Drivers\n         3. **Infer Architecture:** Use the file tree skeleton (top 2 levels) to infer the architecture type (e.g., Monorepo, Microservices, MVC).\n         4. **Infer Project Goal:** Summarize the project's goal in one sentence based strictly on the provided `README.md` header or `package.json` description.\n     - **Upon completing the brownfield initialization protocol, proceed to the Generate Product Guide section in 2.1.**\n\n   - **If Greenfield:**\n     - Announce that a new project will be initialized.\n     - Proceed to the next step in this file.\n\n3. **Initialize Git Repository (for Greenfield):**\n   - If a `.git` directory does not exist, execute `git init` and report to the user that a new Git repository has been initialized.\n\n4. **Inquire about Project Goal (for Greenfield):**\n   - **Ask the user the following question and wait for their response before proceeding to the next step:** \"What do you want to build?\"\n   - **CRITICAL: You MUST NOT execute any tool calls until the user has provided a response.**\n   - **Upon receiving the user's response:**\n     - Execute `mkdir -p conductor`.\n     - **Initialize State File:** Immediately after creating the `conductor` directory, you MUST create `conductor/setup_state.json` with the exact content:\n       `{\"last_successful_step\": \"\"}`\n     - Write the user's response into `conductor/product.md` under a header named `# Initial Concept`.\n\n5. **Continue:** Immediately proceed to the next section.\n\n### 2.1 Generate Product Guide (Interactive)\n\n1. **Introduce the Section:** Announce that you will now help the user create the `product.md`.\n\n2. **Ask Questions Sequentially:** Ask one question at a time. Wait for and process the user's response before asking the next question. Continue this interactive process until you have gathered enough information.\n   - **CONSTRAINT:** Limit your inquiry to a maximum of 5 questions.\n   - **SUGGESTIONS:** For each question, generate 3 high-quality suggested answers based on common patterns or context you already have.\n   - **Example Topics:** Target users, goals, features, etc\n   - **General Guidelines:**\n     - **1. Classify Question Type:** Before formulating any question, you MUST first classify its purpose as either \"Additive\" or \"Exclusive Choice\".\n       - Use **Additive** for brainstorming and defining scope (e.g., users, goals, features, project guidelines). These questions allow for multiple answers.\n       - Use **Exclusive Choice** for foundational, singular commitments (e.g., selecting a primary technology, a specific workflow rule). These questions require a single answer.\n\n     - **2. Formulate the Question:** Based on the classification, you MUST adhere to the following:\n       - **If Additive:** Formulate an open-ended question that encourages multiple points. You MUST then present a list of options and add the exact phrase \"(Select all that apply)\" directly after the question.\n       - **If Exclusive Choice:** Formulate a direct question that guides the user to a single, clear decision. You MUST NOT add \"(Select all that apply)\".\n\n     - **3. Interaction Flow:**\n       - **CRITICAL:** You MUST ask questions sequentially (one by one). Do not ask multiple questions in a single turn. Wait for the user's response after each question.\n       - The last two options for every multiple-choice question MUST be \"Type your own answer\", and \"Autogenerate and review product.md\".\n       - Confirm your understanding by summarizing before moving on.\n     - **Format:** You MUST present these as a vertical list, with each option on its own line.\n     - **Structure:**\n       A) [Option A]\n       B) [Option B]\n       C) [Option C]\n       D) [Type your own answer]\n       E) [Autogenerate and review product.md]\n\n   - **FOR EXISTING PROJECTS (BROWNFIELD):** Ask project context-aware questions based on the code analysis.\n   - **AUTO-GENERATE LOGIC:** If the user selects option E, immediately stop asking questions for this section. Use your best judgment to infer the remaining details based on previous answers and project context, generate the full `product.md` content, write it to the file, and proceed to the next section.\n\n3. **Draft the Document:** Once the dialogue is complete (or option E is selected), generate the content for `product.md`. If option E was chosen, use your best judgment to infer the remaining details based on previous answers and project context. You are encouraged to expand on the gathered details to create a comprehensive document.\n   - **CRITICAL:** The source of truth for generation is **only the user's selected answer(s)**. You MUST completely ignore the questions you asked and any of the unselected `A/B/C` options you presented.\n   - **Action:** Take the user's chosen answer and synthesize it into a well-formed section for the document. You are encouraged to expand on the user's choice to create a comprehensive and polished output. DO NOT include the conversational options (A, B, C, D, E) in the final file.\n\n4. **User Confirmation Loop:** Present the drafted content to the user for review and begin the confirmation loop.\n   > \"I've drafted the product guide. Please review the following:\"\n   >\n   > ```markdown\n   > [Drafted product.md content here]\n   > ```\n   >\n   > \"What would you like to do next?\n   > A) **Approve:** The document is correct and we can proceed.\n   > B) **Suggest Changes:** Tell me what to modify.\n   >\n   > Please respond with A or B.\"\n   - **Loop:** Based on user response, either apply changes and re-present the document, or break the loop on approval.\n\n5. **Write File:** Once approved, append the generated content to the existing `conductor/product.md` file, preserving the `# Initial Concept` section.\n\n6. **Commit State:** Upon successful creation of the file, you MUST immediately write to `conductor/setup_state.json` with the exact content:\n   `{\"last_successful_step\": \"2.1_product_guide\"}`\n\n7. **Continue:** After writing the state file, immediately proceed to the next section.\n\n### 2.2 Generate Product Guidelines (Interactive)\n\n1. **Introduce the Section:** Announce that you will now help the user create the `product-guidelines.md`.\n\n2. **Ask Questions Sequentially:** Ask one question at a time. Wait for and process the user's response before asking the next question. Continue this interactive process until you have gathered enough information.\n   - **CONSTRAINT:** Limit your inquiry to a maximum of 5 questions.\n   - **SUGGESTIONS:** For each question, generate 3 high-quality suggested answers based on common patterns or context you already have. Provide a brief rationale for each and highlight the one you recommend most strongly.\n   - **Example Topics:** Prose style, brand messaging, visual identity, etc\n   - **General Guidelines:**\n     - **1. Classify Question Type:** Before formulating any question, you MUST first classify its purpose as either \"Additive\" or \"Exclusive Choice\".\n       - Use **Additive** for brainstorming and defining scope (e.g., users, goals, features, project guidelines). These questions allow for multiple answers.\n       - Use **Exclusive Choice** for foundational, singular commitments (e.g., selecting a primary technology, a specific workflow rule). These questions require a single answer.\n\n     - **2. Formulate the Question:** Based on the classification, you MUST adhere to the following:\n       - **Suggestions:** When presenting options, you should provide a brief rationale for each and highlight the one you recommend most strongly.\n       - **If Additive:** Formulate an open-ended question that encourages multiple points. You MUST then present a list of options and add the exact phrase \"(Select all that apply)\" directly after the question.\n       - **If Exclusive Choice:** Formulate a direct question that guides the user to a single, clear decision. You MUST NOT add \"(Select all that apply)\".\n\n     - **3. Interaction Flow:**\n       - **CRITICAL:** You MUST ask questions sequentially (one by one). Do not ask multiple questions in a single turn. Wait for the user's response after each question.\n       - The last two options for every multiple-choice question MUST be \"Type your own answer\" and \"Autogenerate and review product-guidelines.md\".\n       - Confirm your understanding by summarizing before moving on.\n     - **Format:** You MUST present these as a vertical list, with each option on its own line.\n     - **Structure:**\n       A) [Option A]\n       B) [Option B]\n       C) [Option C]\n       D) [Type your own answer]\n       E) [Autogenerate and review product-guidelines.md]\n\n   - **AUTO-GENERATE LOGIC:** If the user selects option E, immediately stop asking questions for this section and proceed to the next step to draft the document.\n\n3. **Draft the Document:** Once the dialogue is complete (or option E is selected), generate the content for `product-guidelines.md`. If option E was chosen, use your best judgment to infer the remaining details based on previous answers and project context. You are encouraged to expand on the gathered details to create a comprehensive document.\n   - **CRITICAL:** The source of truth for generation is **only the user's selected answer(s)**. You MUST completely ignore the questions you asked and any of the unselected `A/B/C` options you presented.\n   - **Action:** Take the user's chosen answer and synthesize it into a well-formed section for the document. You are encouraged to expand on the user's choice to create a comprehensive and polished output. DO NOT include the conversational options (A, B, C, D, E) in the final file.\n\n4. **User Confirmation Loop:** Present the drafted content to the user for review and begin the confirmation loop.\n   > \"I've drafted the product guidelines. Please review the following:\"\n   >\n   > ```markdown\n   > [Drafted product-guidelines.md content here]\n   > ```\n   >\n   > \"What would you like to do next?\n   > A) **Approve:** The document is correct and we can proceed.\n   > B) **Suggest Changes:** Tell me what to modify.\n   >\n   > Please respond with A or B.\"\n   - **Loop:** Based on user response, either apply changes and re-present the document, or break the loop on approval.\n\n5. **Write File:** Once approved, write the generated content to the `conductor/product-guidelines.md` file.\n\n6. **Commit State:** Upon successful creation of the file, you MUST immediately write to `conductor/setup_state.json` with the exact content:\n   `{\"last_successful_step\": \"2.2_product_guidelines\"}`\n\n7. **Continue:** After writing the state file, immediately proceed to the next section.\n\n### 2.3 Generate Tech Stack (Interactive)\n\n1. **Introduce the Section:** Announce that you will now help define the technology stacks.\n\n2. **Ask Questions Sequentially:** Ask one question at a time. Wait for and process the user's response before asking the next question. Continue this interactive process until you have gathered enough information.\n   - **CONSTRAINT:** Limit your inquiry to a maximum of 5 questions.\n   - **SUGGESTIONS:** For each question, generate 3 high-quality suggested answers based on common patterns or context you already have.\n   - **Example Topics:** programming languages, frameworks, databases, etc\n   - **General Guidelines:**\n     - **1. Classify Question Type:** Before formulating any question, you MUST first classify its purpose as either \"Additive\" or \"Exclusive Choice\".\n       - Use **Additive** for brainstorming and defining scope (e.g., users, goals, features, project guidelines). These questions allow for multiple answers.\n       - Use **Exclusive Choice** for foundational, singular commitments (e.g., selecting a primary technology, a specific workflow rule). These questions require a single answer.\n\n     - **2. Formulate the Question:** Based on the classification, you MUST adhere to the following:\n       - **Suggestions:** When presenting options, you should provide a brief rationale for each and highlight the one you recommend most strongly.\n       - **If Additive:** Formulate an open-ended question that encourages multiple points. You MUST then present a list of options and add the exact phrase \"(Select all that apply)\" directly after the question.\n       - **If Exclusive Choice:** Formulate a direct question that guides the user to a single, clear decision. You MUST NOT add \"(Select all that apply)\".\n\n     - **3. Interaction Flow:**\n       - **CRITICAL:** You MUST ask questions sequentially (one by one). Do not ask multiple questions in a single turn. Wait for the user's response after each question.\n       - The last two options for every multiple-choice question MUST be \"Type your own answer\" and \"Autogenerate and review tech-stack.md\".\n       - Confirm your understanding by summarizing before moving on.\n     - **Format:** You MUST present these as a vertical list, with each option on its own line.\n     - **Structure:**\n       A) [Option A]\n       B) [Option B]\n       C) [Option C]\n       D) [Type your own answer]\n       E) [Autogenerate and review tech-stack.md]\n\n   - **FOR EXISTING PROJECTS (BROWNFIELD):**\n     - **CRITICAL WARNING:** Your goal is to document the project's *existing* tech stack, not to propose changes.\n     - **State the Inferred Stack:** Based on the code analysis, you MUST state the technology stack that you have inferred. Do not present any other options.\n     - **Request Confirmation:** After stating the detected stack, you MUST ask the user for a simple confirmation to proceed with options like:\n       A) Yes, this is correct.\n       B) No, I need to provide the correct tech stack.\n     - **Handle Disagreement:** If the user disputes the suggestion, acknowledge their input and allow them to provide the correct technology stack manually as a last resort.\n\n   - **AUTO-GENERATE LOGIC:** If the user selects option E, immediately stop asking questions for this section. Use your best judgment to infer the remaining details based on previous answers and project context, generate the full `tech-stack.md` content, write it to the file, and proceed to the next section.\n\n3. **Draft the Document:** Once the dialogue is complete (or option E is selected), generate the content for `tech-stack.md`. If option E was chosen, use your best judgment to infer the remaining details based on previous answers and project context. You are encouraged to expand on the gathered details to create a comprehensive document.\n   - **CRITICAL:** The source of truth for generation is **only the user's selected answer(s)**. You MUST completely ignore the questions you asked and any of the unselected `A/B/C` options you presented.\n   - **Action:** Take the user's chosen answer and synthesize it into a well-formed section for the document. You are encouraged to expand on the user's choice to create a comprehensive and polished output. DO NOT include the conversational options (A, B, C, D, E) in the final file.\n\n4. **User Confirmation Loop:** Present the drafted content to the user for review and begin the confirmation loop.\n   > \"I've drafted the tech stack document. Please review the following:\"\n   >\n   > ```markdown\n   > [Drafted tech-stack.md content here]\n   > ```\n   >\n   > \"What would you like to do next?\n   > A) **Approve:** The document is correct and we can proceed.\n   > B) **Suggest Changes:** Tell me what to modify.\n   >\n   > Please respond with A or B.\"\n   - **Loop:** Based on user response, either apply changes and re-present the document, or break the loop on approval.\n\n5. **Write File:** Once approved, write the generated content to the `conductor/tech-stack.md` file.\n\n6. **Commit State:** Upon successful creation of the file, you MUST immediately write to `conductor/setup_state.json` with the exact content:\n   `{\"last_successful_step\": \"2.3_tech_stack\"}`\n\n7. **Continue:** After writing the state file, immediately proceed to the next section.\n\n### 2.4 Select Guides (Interactive)\n\n1. **Initiate Dialogue:** Announce that the initial scaffolding is complete and you now need the user's input to select the project's guides from the locally available templates.\n\n2. **Select Code Style Guides:**\n   - List the available style guides by running `ls ${CLAUDE_PLUGIN_ROOT}/templates/code_styleguides/`.\n   - For new projects (greenfield):\n     - **Recommendation:** Based on the Tech Stack defined in the previous step, recommend the most appropriate style guide(s) and explain why.\n     - Ask the user how they would like to proceed:\n       A) Include the recommended style guides.\n       B) Edit the selected set.\n     - If the user chooses to edit (Option B):\n       - Present the list of all available guides to the user as a **numbered list**.\n       - Ask the user which guide(s) they would like to copy.\n   - For existing projects (brownfield):\n     - **Announce Selection:** Inform the user: \"Based on the inferred tech stack, I will copy the following code style guides: <list of inferred guides>.\"\n     - **Ask for Customization:** Ask the user: \"Would you like to proceed using only the suggested code style guides?\"\n       - Ask the user for a simple confirmation to proceed with options like:\n         A) Yes, I want to proceed with the suggested code style guides.\n         B) No, I want to add more code style guides.\n   - **Action:** Construct and execute a command to create the directory and copy all selected files. For example: `mkdir -p conductor/code_styleguides && cp ${CLAUDE_PLUGIN_ROOT}/templates/code_styleguides/python.md ${CLAUDE_PLUGIN_ROOT}/templates/code_styleguides/javascript.md conductor/code_styleguides/`\n   - **Commit State:** Upon successful completion of the copy command, you MUST immediately write to `conductor/setup_state.json` with the exact content:\n     `{\"last_successful_step\": \"2.4_code_styleguides\"}`\n\n### 2.5 Select Workflow (Interactive)\n\n1. **Copy Initial Workflow:**\n   - Copy `${CLAUDE_PLUGIN_ROOT}/templates/workflow.md` to `conductor/workflow.md`.\n\n2. **Customize Workflow:**\n   - Ask the user: \"Do you want to use the default workflow or customize it?\"\n     The default workflow includes:\n     - 80% code test coverage\n     - Commit changes after every task\n     - Use Git Notes for task summaries\n     - A) Default\n     - B) Customize\n   - If the user chooses to **customize** (Option B):\n     - **Question 1:** \"The default required test code coverage is >80% (Recommended). Do you want to change this percentage?\"\n       - A) No (Keep 80% required coverage)\n       - B) Yes (Type the new percentage)\n     - **Question 2:** \"Do you want to commit changes after each task or after each phase (group of tasks)?\"\n       - A) After each task (Recommended)\n       - B) After each phase\n     - **Question 3:** \"Do you want to use git notes or the commit message to record the task summary?\"\n       - A) Git Notes (Recommended)\n       - B) Commit Message\n     - **Action:** Update `conductor/workflow.md` based on the user's responses.\n     - **Commit State:** After the `workflow.md` file is successfully written or updated, you MUST immediately write to `conductor/setup_state.json` with the exact content:\n       `{\"last_successful_step\": \"2.5_workflow\"}`\n\n### 2.6 Finalization\n\n1. **Summarize Actions:** Present a summary of all actions taken during Phase 1, including:\n   - The guide files that were copied.\n   - The workflow file that was copied.\n\n2. **Transition to initial plan and track generation:** Announce that the initial setup is complete and you will now proceed to define the first track for the project.\n\n---\n\n## 3.0 INITIAL PLAN AND TRACK GENERATION\n\n**PROTOCOL: Interactively define project requirements, propose a single track, and then automatically create the corresponding track and its phased plan.**\n\n### 3.1 Generate Product Requirements (Interactive) (For greenfield projects only)\n\n1. **Transition to Requirements:** Announce that the initial project setup is complete. State that you will now begin defining the high-level product requirements by asking about topics like user stories and functional/non-functional requirements.\n\n2. **Analyze Context:** Read and analyze the content of `conductor/product.md` to understand the project's core concept.\n\n3. **Ask Questions Sequentially:** Ask one question at a time. Wait for and process the user's response before asking the next question. Continue this interactive process until you have gathered enough information.\n   - **CONSTRAINT** Limit your inquiries to a maximum of 5 questions.\n   - **SUGGESTIONS:** For each question, generate 3 high-quality suggested answers based on common patterns or context you already have.\n   - **General Guidelines:**\n     - **1. Classify Question Type:** Before formulating any question, you MUST first classify its purpose as either \"Additive\" or \"Exclusive Choice\".\n       - Use **Additive** for brainstorming and defining scope (e.g., users, goals, features, project guidelines). These questions allow for multiple answers.\n       - Use **Exclusive Choice** for foundational, singular commitments (e.g., selecting a primary technology, a specific workflow rule). These questions require a single answer.\n\n     - **2. Formulate the Question:** Based on the classification, you MUST adhere to the following:\n       - **If Additive:** Formulate an open-ended question that encourages multiple points. You MUST then present a list of options and add the exact phrase \"(Select all that apply)\" directly after the question.\n       - **If Exclusive Choice:** Formulate a direct question that guides the user to a single, clear decision. You MUST NOT add \"(Select all that apply)\".\n\n     - **3. Interaction Flow:**\n       - **CRITICAL:** You MUST ask questions sequentially (one by one). Do not ask multiple questions in a single turn. Wait for the user's response after each question.\n       - The last two options for every multiple-choice question MUST be \"Type your own answer\" and \"Auto-generate the rest of requirements and move to the next step\".\n       - Confirm your understanding by summarizing before moving on.\n     - **Format:** You MUST present these as a vertical list, with each option on its own line.\n     - **Structure:**\n       A) [Option A]\n       B) [Option B]\n       C) [Option C]\n       D) [Type your own answer]\n       E) [Auto-generate the rest of requirements and move to the next step]\n\n   - **AUTO-GENERATE LOGIC:** If the user selects option E, immediately stop asking questions for this section. Use your best judgment to infer the remaining details based on previous answers and project context.\n   - **CRITICAL:** When processing user responses or auto-generating content, the source of truth for generation is **only the user's selected answer(s)**. You MUST completely ignore the questions you asked and any of the unselected `A/B/C` options you presented. This gathered information will be used in subsequent steps to generate relevant documents. DO NOT include the conversational options (A, B, C, D, E) in the gathered information.\n\n4. **Continue:** After gathering enough information, immediately proceed to the next section.\n\n### 3.2 Propose a Single Initial Track (Automated + Approval)\n\n1. **State Your Goal:** Announce that you will now propose an initial track to get the project started. Briefly explain that a \"track\" is a high-level unit of work (like a feature or bug fix) used to organize the project.\n\n2. **Generate Track Title:** Analyze the project context (`product.md`, `tech-stack.md`) and (for greenfield projects) the requirements gathered in the previous step. Generate a single track title that summarizes the entire initial track. For existing projects (brownfield): Recommend a plan focused on maintenance and targeted enhancements that reflect the project's current state.\n   - Greenfield project example (usually MVP):\n     ```markdown\n     To create the MVP of this project, I suggest the following track:\n     - Build the core functionality for the tip calculator with a basic calculator and built-in tip percentages.\n     ```\n   - Brownfield project example:\n     ```markdown\n     To create the first track of this project, I suggest the following track:\n     - Create user authentication flow for user sign in.\n     ```\n\n3. **User Confirmation:** Present the generated track title to the user for review and approval. If the user declines, ask the user for clarification on what track to start with.\n\n### 3.3 Convert the Initial Track into Artifacts (Automated)\n\n1. **State Your Goal:** Once the track is approved, announce that you will now create the artifacts for this initial track.\n\n2. **Initialize Tracks File:** Create the `conductor/tracks.md` file with the initial header and the first track:\n   ```markdown\n   # Project Tracks\n\n   This file tracks all major tracks for the project. Each track has its own detailed plan in its respective folder.\n\n   ---\n\n   - [ ] **Track: <Track Description>**\n     *Link: [./conductor/tracks/<track_id>/](./conductor/tracks/<track_id>/)*\n   ```\n\n3. **Generate Track Artifacts:**\n   a. **Define Track:** The approved title is the track description.\n   b. **Generate Track-Specific Spec & Plan:**\n      i. Automatically generate a detailed `spec.md` for this track.\n      ii. Automatically generate a `plan.md` for this track.\n         - **CRITICAL:** The structure of the tasks must adhere to the principles outlined in the workflow file at `conductor/workflow.md`. For example, if the workflow specifies Test-Driven Development, each feature task must be broken down into a \"Write Tests\" sub-task followed by an \"Implement Feature\" sub-task.\n         - **CRITICAL:** Include status markers `[ ]` for **EVERY** task and sub-task. The format must be:\n           - Parent Task: `- [ ] Task: ...`\n           - Sub-task: `    - [ ] ...`\n         - **CRITICAL: Inject Phase Completion Tasks.** You MUST read the `conductor/workflow.md` file to determine if a \"Phase Completion Verification and Checkpointing Protocol\" is defined. If this protocol exists, then for each **Phase** that you generate in `plan.md`, you MUST append a final meta-task to that phase. The format for this meta-task is: `- [ ] Task: Conductor - User Manual Verification '<Phase Name>' (Protocol in workflow.md)`. You MUST replace `<Phase Name>` with the actual name of the phase.\n   c. **Create Track Artifacts:**\n      i. **Generate and Store Track ID:** Create a unique Track ID from the track description using format `shortname_YYYYMMDD` and store it. You MUST use this exact same ID for all subsequent steps for this track.\n      ii. **Create Single Directory:** Using the stored Track ID, create a single new directory: `conductor/tracks/<track_id>/`.\n      iii. **Create `metadata.json`:** In the new directory, create a `metadata.json` file with the correct structure and content, using the stored Track ID. An example is:\n         ```json\n         {\n           \"track_id\": \"<track_id>\",\n           \"type\": \"feature\",\n           \"status\": \"new\",\n           \"created_at\": \"YYYY-MM-DDTHH:MM:SSZ\",\n           \"updated_at\": \"YYYY-MM-DDTHH:MM:SSZ\",\n           \"description\": \"<Initial user description>\"\n         }\n         ```\n         Populate fields with actual values. Use the current timestamp.\n      iv. **Write Spec and Plan Files:** In the exact same directory, write the generated `spec.md` and `plan.md` files.\n\n   d. **Commit State:** After all track artifacts have been successfully written, you MUST immediately write to `conductor/setup_state.json` with the exact content:\n      `{\"last_successful_step\": \"3.3_initial_track_generated\"}`\n\n   e. **Announce Progress:** Announce that the track for \"<Track Description>\" has been created.\n\n### 3.4 Final Announcement\n\n1. **Announce Completion:** After the track has been created, announce that the project setup and initial track generation are complete.\n\n2. **Save Conductor Files:** Add and commit all files with the commit message `conductor(setup): Add conductor setup files`.\n\n3. **Next Steps:** Inform the user that they can now begin work by running `/claude-conductor:implement`.\n",
        "plugins/claude-conductor/commands/status.md": "---\ndescription: Displays the current progress of the project\nallowed-tools: Read, Bash(ls:*, date:*)\n---\n\n# Conductor Status\n\n## Context\n\n- Current date: !`date`\n- Conductor directory exists: !`test -d conductor && echo \"YES\" || echo \"NO\"`\n- Tracks directory contents: !`ls conductor/tracks/ 2>/dev/null || echo \"EMPTY\"`\n\n## 1.0 SYSTEM DIRECTIVE\n\nYou are an AI agent. Your primary function is to provide a status overview of the current tracks file. This involves reading the `conductor/tracks.md` file, parsing its content, and summarizing the progress of tasks.\n\n**CRITICAL:** Before proceeding, you should start by checking if the project has been properly set up.\n\n1. **Verify Tracks File:** Check if the file `conductor/tracks.md` exists. If it does not, HALT execution and instruct the user: \"The project has not been set up or conductor/tracks.md has been corrupted. Please run `/claude-conductor:setup` to set up the plan, or restore conductor/tracks.md.\"\n\n2. **Verify Track Exists:** Check if the file `conductor/tracks.md` is not empty. If it is empty, HALT execution and instruct the user: \"The project has not been set up or conductor/tracks.md has been corrupted. Please run `/claude-conductor:setup` to set up the plan, or restore conductor/tracks.md.\"\n\n**CRITICAL:** You must validate the success of every tool call. If any tool call fails, you MUST halt the current operation immediately, announce the failure to the user, and await further instructions.\n\n---\n\n## 1.1 SETUP CHECK\n\n**PROTOCOL: Verify that the Conductor environment is properly set up.**\n\n1. **Check for Required Files:** You MUST verify the existence of the following files in the `conductor` directory:\n   - `conductor/tech-stack.md`\n   - `conductor/workflow.md`\n   - `conductor/product.md`\n\n2. **Handle Missing Files:**\n   - If ANY of these files are missing, you MUST halt the operation immediately.\n   - Announce: \"Conductor is not set up. Please run `/claude-conductor:setup` to set up the environment.\"\n   - Do NOT proceed to Status Overview Protocol.\n\n---\n\n## 2.0 STATUS OVERVIEW PROTOCOL\n\n**PROTOCOL: Follow this sequence to provide a status overview.**\n\n### 2.1 Read Project Plan\n\n1. **Locate and Read:** Read the content of the `conductor/tracks.md` file.\n\n2. **Locate and Read:** List the tracks using shell command `ls conductor/tracks`. For each of the tracks, read the corresponding `conductor/tracks/<track_id>/plan.md` file.\n   - **Parsing Logic:** When reading `conductor/tracks.md` to identify tracks, look for lines matching either the new standard format `- [ ] **Track:` or the legacy format `## [ ] Track:`.\n\n### 2.2 Parse and Summarize Plan\n\n1. **Parse Content:**\n   - Identify major project phases/sections (e.g., top-level markdown headings).\n   - Identify individual tasks and their current status (e.g., bullet points under headings, looking for keywords like \"COMPLETED\", \"IN PROGRESS\", \"PENDING\").\n\n2. **Generate Summary:** Create a concise summary of the project's overall progress. This should include:\n   - The total number of major phases.\n   - The total number of tasks.\n   - The number of tasks completed, in progress, and pending.\n\n### 2.3 Present Status Overview\n\n1. **Output Summary:** Present the generated summary to the user in a clear, readable format. The status report must include:\n   - **Current Date/Time:** The current timestamp.\n   - **Project Status:** A high-level summary of progress (e.g., \"On Track\", \"Behind Schedule\", \"Blocked\").\n   - **Current Phase and Task:** The specific phase and task currently marked as \"IN PROGRESS\".\n   - **Next Action Needed:** The next task listed as \"PENDING\".\n   - **Blockers:** Any items explicitly marked as blockers in the plan.\n   - **Phases (total):** The total number of major phases.\n   - **Tasks (total):** The total number of tasks.\n   - **Progress:** The overall progress of the plan, presented as tasks_completed/tasks_total (percentage_completed%).\n",
        "plugins/claude-conductor/hooks/hooks.json": "{\n  \"description\": \"Conductor validation and automation hooks\",\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"test -d conductor\",\n            \"onFailure\": \"approve\"\n          },\n          {\n            \"type\": \"prompt\",\n            \"prompt\": \"Before stopping this Conductor session, verify: (1) All in-progress tasks are properly marked in plan.md with correct status markers ([ ], [~], [x]). (2) The plan reflects the current implementation state. (3) Any phase completion protocols from workflow.md were followed. (4) Code changes have corresponding test files per TDD workflow. If verification fails, explain what needs to be done before stopping. Return 'approve' to stop or 'block' with specific remaining actions.\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "plugins/claude-conductor/skills/context-synchronization/SKILL.md": "---\nname: context-synchronization\ndescription: Synchronize project documentation after track completion. Use when a track reaches completed status and product, tech-stack, or guidelines documents may need updates.\n---\n\n# Context Synchronization\n\nThis skill provides the protocol for synchronizing project-level documentation after completing a Conductor track.\n\n## Execution Trigger\n\n**Only execute this protocol when:**\n- A track has reached `[x]` status in the tracks file\n- The `/claude-conductor:implement` command has finished all tasks\n\n**Do NOT execute for:**\n- Status changes other than completion\n- Partial task completion\n- Track creation\n\n## Protocol Overview\n\n1. Load the completed track's specification\n2. Analyze for documentation impacts\n3. Propose updates with user confirmation\n4. Apply approved changes\n5. Commit documentation updates\n\n## Step-by-Step Process\n\n### 1. Announce Synchronization\n\nInform the user:\n> \"I am now synchronizing the project-level documentation with the completed track's specifications.\"\n\n### 2. Load Track Specification\n\nRead the completed track's `conductor/tracks/<track_id>/spec.md` into context.\n\n### 3. Load Project Documents\n\nRead the following files:\n- `conductor/product.md`\n- `conductor/product-guidelines.md`\n- `conductor/tech-stack.md`\n\n### 4. Analyze and Update\n\n#### 4.1 Update `conductor/product.md`\n\n**Condition for Update:**\nDetermine if the completed feature or bug fix significantly impacts the description of the product itself.\n\nExamples that warrant updates:\n- New major feature that changes product capabilities\n- Fundamental change to how users interact with the product\n- New integration that expands product scope\n\nExamples that do NOT warrant updates:\n- Bug fixes\n- Internal refactoring\n- Minor UI tweaks\n- Performance improvements\n\n**Propose and Confirm:**\nIf an update is needed:\n> \"Based on the completed track, I propose the following updates to `product.md`:\"\n> ```diff\n> [Proposed changes in diff format]\n> ```\n> \"Do you approve these changes? (yes/no)\"\n\n**Action:**\nOnly after explicit user confirmation, apply the edits. Record whether this file was changed.\n\n#### 4.2 Update `conductor/tech-stack.md`\n\n**Condition for Update:**\nDetermine if significant changes in the technology stack occurred.\n\nExamples that warrant updates:\n- New library or framework added\n- Database technology changed\n- New external service integration\n- Significant architectural change\n\nExamples that do NOT warrant updates:\n- Version bumps of existing dependencies\n- Development-only tool changes\n- Configuration changes\n\n**Propose and Confirm:**\nIf an update is needed:\n> \"Based on the completed track, I propose the following updates to `tech-stack.md`:\"\n> ```diff\n> [Proposed changes in diff format]\n> ```\n> \"Do you approve these changes? (yes/no)\"\n\n**Action:**\nOnly after explicit user confirmation, apply the edits. Record whether this file was changed.\n\n#### 4.3 Update `conductor/product-guidelines.md` (Strictly Controlled)\n\n**CRITICAL WARNING:**\nThis file defines the core identity and communication style of the product. It should be modified with **extreme caution** and ONLY in cases of significant strategic shifts.\n\n**Valid reasons to update:**\n- Product rebrand\n- Fundamental change in user engagement philosophy\n- Major shift in target audience\n- Complete redesign of product voice/tone\n\n**Invalid reasons (do NOT update):**\n- Routine feature updates\n- Bug fixes\n- Minor UI changes\n- Performance improvements\n- New features that don't change brand identity\n\n**Condition for Update:**\nYou may ONLY propose an update if the track's `spec.md` **explicitly describes** a change that directly impacts branding, voice, tone, or other core product guidelines.\n\n**Propose and Confirm (with warning):**\nIf the strict conditions are met:\n> \"**WARNING:** The completed track suggests a change to the core product guidelines. This is an unusual step. Please review carefully:\"\n> ```diff\n> [Proposed changes in diff format]\n> ```\n> \"Do you approve these critical changes to `product-guidelines.md`? (yes/no)\"\n\n**Action:**\nOnly after explicit user confirmation, apply the edits. Record whether this file was changed.\n\n### 5. Final Report\n\nAnnounce completion and provide a summary based on which files were changed.\n\n**Example (product.md changed):**\n> \"Documentation synchronization is complete.\n> - **Changes made to `product.md`:** The user-facing description of the product was updated to include the new feature.\n> - **No changes needed for `tech-stack.md`:** The technology stack was not affected.\n> - **No changes needed for `product-guidelines.md`:** Core product guidelines remain unchanged.\"\n\n**Example (no changes):**\n> \"Documentation synchronization is complete. No updates were necessary for `product.md`, `tech-stack.md`, or `product-guidelines.md` based on the completed track.\"\n\n### 6. Commit Changes\n\nIf any files were changed:\n- Stage: `product.md`, `tech-stack.md`, and/or `product-guidelines.md`\n- Commit message: `docs(conductor): Synchronize docs for track '<track_description>'`\n\n## Diff Format Guidelines\n\nWhen proposing changes, use diff format for clarity:\n\n```diff\n# Product Overview\n\n- Our product helps users manage tasks efficiently.\n+ Our product helps users manage tasks efficiently with real-time collaboration features.\n\n## Key Features\n\n- Task management\n- Due date tracking\n+ - Real-time collaboration\n+ - Team workspaces\n```\n\n## User Confirmation Patterns\n\nAlways wait for explicit user response:\n\n**Approval patterns:**\n- \"yes\"\n- \"y\"\n- \"approve\"\n- \"looks good\"\n\n**Rejection patterns:**\n- \"no\"\n- \"n\"\n- \"reject\"\n- Any request for changes\n\nIf unclear, ask for clarification before proceeding.\n",
        "plugins/claude-conductor/skills/tdd-workflow/SKILL.md": "---\nname: tdd-workflow\ndescription: Test-Driven Development workflow for task implementation. Use when implementing tasks that require the Red-Green-Refactor cycle, quality gates, commit guidelines, or phase verification protocols.\n---\n\n# TDD Workflow\n\nThis skill provides the Test-Driven Development methodology used by Conductor for task implementation.\n\n## Guiding Principles\n\n1. **The Plan is the Source of Truth:** All work must be tracked in `plan.md`\n2. **The Tech Stack is Deliberate:** Changes to the tech stack must be documented in `tech-stack.md` *before* implementation\n3. **Test-Driven Development:** Write unit tests before implementing functionality\n4. **High Code Coverage:** Aim for >80% code coverage for all modules\n5. **User Experience First:** Every decision should prioritize user experience\n6. **Non-Interactive & CI-Aware:** Prefer non-interactive commands. Use `CI=true` for watch-mode tools (tests, linters) to ensure single execution.\n\n## Standard Task Workflow\n\nAll tasks follow a strict lifecycle:\n\n### 1. Select Task\nChoose the next available task from `plan.md` in sequential order.\n\n### 2. Mark In Progress\nBefore beginning work, edit `plan.md` and change the task from `[ ]` to `[~]`.\n\n### 3. Write Failing Tests (Red Phase)\n- Create a new test file for the feature or bug fix.\n- Write one or more unit tests that clearly define the expected behavior and acceptance criteria for the task.\n- **CRITICAL:** Run the tests and confirm that they fail as expected. This is the \"Red\" phase of TDD. Do not proceed until you have failing tests.\n\n### 4. Implement to Pass Tests (Green Phase)\n- Write the minimum amount of application code necessary to make the failing tests pass.\n- Run the test suite again and confirm that all tests now pass. This is the \"Green\" phase.\n\n### 5. Refactor (Optional but Recommended)\n- With the safety of passing tests, refactor the implementation code and the test code to improve clarity, remove duplication, and enhance performance without changing the external behavior.\n- Rerun tests to ensure they still pass after refactoring.\n\n### 6. Verify Coverage\nRun coverage reports using the project's chosen tools. Target: >80% coverage for new code.\n\nExample commands by language:\n- Python: `pytest --cov=app --cov-report=html`\n- JavaScript/TypeScript: `npm test -- --coverage`\n- Go: `go test -cover ./...`\n\n### 7. Document Deviations\nIf implementation differs from tech stack:\n- **STOP** implementation\n- Update `tech-stack.md` with new design\n- Add dated note explaining the change\n- Resume implementation\n\n### 8. Commit Code Changes\n- Stage all code changes related to the task.\n- Propose a clear, concise commit message (e.g., `feat(ui): Create basic HTML structure for calculator`).\n- Perform the commit.\n\n### 9. Attach Task Summary with Git Notes\n- **Step 9.1:** Get the hash of the just-completed commit (`git log -1 --format=\"%H\"`).\n- **Step 9.2:** Draft note content including task name, summary of changes, files modified, and the \"why\".\n- **Step 9.3:** Attach note: `git notes add -m \"<note content>\" <commit_hash>`\n\n### 10. Get and Record Task Commit SHA\n- **Step 10.1:** Read `plan.md`, find the completed task, update status from `[~]` to `[x]`, and append the first 7 characters of the commit hash.\n- **Step 10.2:** Write the updated content back to `plan.md`.\n\n### 11. Commit Plan Update\n- Stage the modified `plan.md` file.\n- Commit with message: `conductor(plan): Mark task '<task_name>' as complete`\n\n## Phase Completion Verification and Checkpointing Protocol\n\n**Trigger:** Execute immediately after completing a task that also concludes a phase in `plan.md`.\n\n### 1. Announce Protocol Start\nInform the user that the phase is complete and verification has begun.\n\n### 2. Ensure Test Coverage for Phase Changes\n- **Step 2.1:** Find the Git commit SHA of the previous phase's checkpoint. If none exists, scope is all changes since first commit.\n- **Step 2.2:** Execute `git diff --name-only <previous_checkpoint_sha> HEAD` to list files modified during this phase.\n- **Step 2.3:** For each code file (excluding `.json`, `.md`, `.yaml`), verify a corresponding test file exists. If missing, create one.\n\n### 3. Execute Automated Tests with Proactive Debugging\n- Announce the exact shell command before execution (e.g., \"Command: `CI=true npm test`\").\n- If tests fail, attempt to fix a **maximum of two times**. If still failing, stop and ask for guidance.\n\n### 4. Propose Manual Verification Plan\nGenerate step-by-step instructions for the user to manually verify the phase.\n\n**Frontend example:**\n```\n1. Start the development server: `npm run dev`\n2. Open browser to: `http://localhost:3000`\n3. Confirm you see: The new user profile page with name and email\n```\n\n**Backend example:**\n```\n1. Ensure the server is running\n2. Execute: `curl -X POST http://localhost:8080/api/v1/users -d '{\"name\": \"test\"}'`\n3. Confirm response: JSON with status `201 Created`\n```\n\n### 5. Await Explicit User Feedback\nAsk: \"Does this meet your expectations? Please confirm with yes or provide feedback.\"\n**PAUSE** and await response. Do not proceed without explicit confirmation.\n\n### 6. Create Checkpoint Commit\nStage all changes and commit: `conductor(checkpoint): Checkpoint end of Phase X`\n\n### 7. Attach Verification Report using Git Notes\nDraft and attach a detailed verification report including automated test command, manual steps, and user confirmation.\n\n### 8. Get and Record Phase Checkpoint SHA\n- Get the checkpoint commit hash.\n- Update `plan.md` to append `[checkpoint: <sha>]` to the phase heading.\n- Commit: `conductor(plan): Mark phase '<PHASE NAME>' as complete`\n\n### 9. Announce Completion\nInform the user that the phase is complete with verification report attached as git note.\n\n## Quality Gates\n\nBefore marking any task complete, verify:\n\n- [ ] All tests pass\n- [ ] Code coverage meets requirements (>80%)\n- [ ] Code follows project's code style guidelines\n- [ ] All public functions/methods are documented\n- [ ] Type safety is enforced\n- [ ] No linting or static analysis errors\n- [ ] Works correctly on mobile (if applicable)\n- [ ] Documentation updated if needed\n- [ ] No security vulnerabilities introduced\n\n## Commit Message Format\n\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n### Types\n- `feat`: New feature\n- `fix`: Bug fix\n- `docs`: Documentation only\n- `style`: Formatting, missing semicolons, etc.\n- `refactor`: Code change that neither fixes a bug nor adds a feature\n- `test`: Adding missing tests\n- `chore`: Maintenance tasks\n\n### Examples\n```bash\ngit commit -m \"feat(auth): Add remember me functionality\"\ngit commit -m \"fix(posts): Correct excerpt generation for short posts\"\ngit commit -m \"test(comments): Add tests for emoji reaction limits\"\n```\n\n## Definition of Done\n\nA task is complete when:\n\n1. All code implemented to specification\n2. Unit tests written and passing\n3. Code coverage meets project requirements\n4. Documentation complete (if applicable)\n5. Code passes all configured linting and static analysis checks\n6. Works beautifully on mobile (if applicable)\n7. Implementation notes added to `plan.md`\n8. Changes committed with proper message\n9. Git note with task summary attached to the commit\n",
        "plugins/claude-conductor/skills/track-management/SKILL.md": "---\nname: track-management\ndescription: Track lifecycle management patterns. Use when creating tracks, updating track status, generating track IDs, parsing plan files, or managing track metadata.\n---\n\n# Track Management\n\nThis skill provides patterns for managing Conductor tracks throughout their lifecycle.\n\n## Track ID Generation\n\n### Format\nTrack IDs follow the pattern: `shortname_YYYYMMDD`\n\n### Rules\n1. Derive shortname from track description (lowercase, underscores, no special characters)\n2. Use current date in YYYYMMDD format\n3. Keep shortname concise (2-4 words max)\n\n### Examples\n- \"Add user authentication\" → `user_auth_20260110`\n- \"Fix login page bug\" → `login_bug_20260110`\n- \"Create dashboard UI\" → `dashboard_ui_20260110`\n\n## Status Markers\n\nConductor uses checkbox-style markers to track status:\n\n| Marker | Status | Description |\n|--------|--------|-------------|\n| `[ ]` | Pending | Not yet started |\n| `[~]` | In Progress | Currently being worked on |\n| `[x]` | Completed | Finished successfully |\n\n### Usage in tracks.md\n```markdown\n- [ ] **Track: Add user authentication**\n- [~] **Track: Create dashboard UI**\n- [x] **Track: Fix login bug**\n```\n\n### Usage in plan.md\n```markdown\n# Phase 1: Setup\n\n- [x] Task: Initialize project structure\n    - [x] Create directory layout\n    - [x] Set up package.json\n- [~] Task: Configure testing framework\n    - [x] Install Jest\n    - [ ] Write initial test\n- [ ] Task: Conductor - User Manual Verification 'Phase 1: Setup' (Protocol in workflow.md)\n```\n\n## Track File Structure\n\nEach track is stored in `conductor/tracks/<track_id>/` with these files:\n\n```\nconductor/tracks/<track_id>/\n├── metadata.json    # Track metadata\n├── spec.md          # Feature specification\n└── plan.md          # Implementation plan\n```\n\n## Metadata Schema\n\nThe `metadata.json` file contains:\n\n```json\n{\n  \"track_id\": \"user_auth_20260110\",\n  \"type\": \"feature\",\n  \"status\": \"new\",\n  \"created_at\": \"2026-01-10T14:30:00Z\",\n  \"updated_at\": \"2026-01-10T14:30:00Z\",\n  \"description\": \"Add user authentication with login and registration\"\n}\n```\n\n### Fields\n\n| Field | Type | Values | Description |\n|-------|------|--------|-------------|\n| `track_id` | string | - | Unique identifier |\n| `type` | string | `feature`, `bug`, `chore`, `refactor` | Category of work |\n| `status` | string | `new`, `in_progress`, `completed`, `cancelled` | Current state |\n| `created_at` | string | ISO 8601 datetime | Creation timestamp |\n| `updated_at` | string | ISO 8601 datetime | Last update timestamp |\n| `description` | string | - | Brief description |\n\n## Plan Parsing\n\n### Reading Tasks\nWhen parsing `plan.md`:\n\n1. Look for phase headings (e.g., `# Phase 1: Setup`)\n2. Find task lines matching `- [ ] Task:` or `- [~] Task:` or `- [x] Task:`\n3. Find sub-tasks indented under tasks (4 spaces): `    - [ ] ...`\n\n### Extracting Status\n```\nLine: \"- [~] Task: Configure testing framework\"\nStatus: in_progress\nTask: \"Configure testing framework\"\n```\n\n### Finding Commit SHAs\nCompleted tasks may have commit SHAs appended:\n```\n- [x] Task: Initialize project (abc1234)\n```\nExtract SHA: `abc1234`\n\n### Phase Checkpoints\nCompleted phases have checkpoint markers:\n```\n# Phase 1: Setup [checkpoint: def5678]\n```\n\n## tracks.md Format\n\nThe main tracks file (`conductor/tracks.md`) lists all tracks:\n\n```markdown\n# Project Tracks\n\nThis file tracks all major tracks for the project. Each track has its own detailed plan in its respective folder.\n\n---\n\n- [ ] **Track: Add user authentication**\n  *Link: [./conductor/tracks/user_auth_20260110/](./conductor/tracks/user_auth_20260110/)*\n\n---\n\n- [~] **Track: Create dashboard UI**\n  *Link: [./conductor/tracks/dashboard_ui_20260110/](./conductor/tracks/dashboard_ui_20260110/)*\n```\n\n### Parsing tracks.md\n1. Split content by `---` separator\n2. For each section, find:\n   - Status marker: `- [ ]`, `- [~]`, or `- [x]`\n   - Description: Text after `**Track:` and before `**`\n   - Link: Path in `*Link: [...](...)*`\n\n## Track Lifecycle\n\n### 1. Creation\n- Generate unique track ID\n- Create directory structure\n- Write metadata.json, spec.md, plan.md\n- Add entry to tracks.md\n\n### 2. Implementation\n- Update tracks.md status to `[~]`\n- Execute tasks from plan.md\n- Update plan.md as tasks complete\n- Commit changes with git notes\n\n### 3. Completion\n- Update tracks.md status to `[x]`\n- Synchronize project documentation\n- Offer archive/delete options\n\n### 4. Archive (Optional)\n- Move track folder to `conductor/archive/`\n- Remove entry from tracks.md\n- Commit changes\n\n### 5. Delete (Optional)\n- Permanently delete track folder\n- Remove entry from tracks.md\n- Commit changes\n\n## Duplicate Prevention\n\nBefore creating a new track:\n\n1. List existing tracks in `conductor/tracks/`\n2. Extract shortnames from existing track IDs\n3. If proposed shortname matches an existing one, halt and suggest alternatives\n\nExample check:\n```bash\nls conductor/tracks/\n# Output: user_auth_20260108  dashboard_ui_20260109\n\n# If user wants \"user_auth\", warn that it already exists\n```\n"
      },
      "plugins": [
        {
          "name": "claude-conductor",
          "source": "./plugins/claude-conductor",
          "description": "Context-Driven Development framework - plan, specify, and implement software features with AI assistance",
          "version": "1.0.0",
          "author": {
            "name": "V-Marketplace Contributors"
          },
          "license": "Apache-2.0",
          "keywords": [
            "tdd",
            "planning",
            "specifications",
            "context-driven",
            "workflow"
          ],
          "category": "development",
          "categories": [
            "context-driven",
            "development",
            "planning",
            "specifications",
            "tdd",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add vinothpandian/v-marketplace",
            "/plugin install claude-conductor@v-marketplace"
          ]
        }
      ]
    }
  ]
}