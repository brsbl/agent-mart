{
  "author": {
    "id": "florianbuetow",
    "display_name": "Florian Buetow",
    "avatar_url": "https://avatars.githubusercontent.com/u/2320560?u=05f6efbcdbbaf944b4b38d6dce4fc91a02a78b55&v=4"
  },
  "marketplaces": [
    {
      "name": "florianbuetow-plugins",
      "version": "1.0.0",
      "description": "A collection of Claude Code plugins for software engineering workflows: SOLID principles analysis, system-level architecture principles analysis, expert-guided specification writing, and distributed system tradeoff analysis.",
      "repo_full_name": "florianbuetow/claude-code",
      "repo_url": "https://github.com/florianbuetow/claude-code",
      "repo_description": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-02-14T06:16:11Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"florianbuetow-plugins\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A collection of Claude Code plugins for software engineering workflows: SOLID principles analysis, system-level architecture principles analysis, expert-guided specification writing, and distributed system tradeoff analysis.\",\n  \"repository\": \"https://github.com/florianbuetow/claude-code\",\n  \"owner\": {\n    \"name\": \"Florian Buetow\",\n    \"email\": \"2320560+florianbuetow@users.noreply.github.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"solid-principles\",\n      \"description\": \"Analyze code for violations of the SOLID principles of object-oriented design (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion)\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Florian Buetow\",\n        \"email\": \"2320560+florianbuetow@users.noreply.github.com\"\n      },\n      \"source\": \"./plugins/solid-principles\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"beyond-solid-principles\",\n      \"description\": \"Analyze code and architecture for violations of ten system-level software design principles: Separation of Concerns, Single Responsibility (system-level), DRY, Law of Demeter, Loose Coupling / High Cohesion, Evolvability, Resilience, KISS, Principle of Least Surprise, and YAGNI\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Florian Buetow\",\n        \"email\": \"2320560+florianbuetow@users.noreply.github.com\"\n      },\n      \"source\": \"./plugins/beyond-solid-principles\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"spec-writer\",\n      \"description\": \"An expert-guided skill for creating layered software specification documents for greenfield projects. Produces Vision, Business Requirements, Software Requirements, Architecture & Design, and Behavioral Spec & Test Verification documents.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Florian Buetow\",\n        \"email\": \"2320560+florianbuetow@users.noreply.github.com\"\n      },\n      \"source\": \"./plugins/spec-writer\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"explain-system-tradeoffs\",\n      \"description\": \"Reverse-engineer distributed system tradeoffs from code, configuration, and architecture artifacts. Analyzes six axes: Consistency & Availability, Latency & Throughput, Data Distribution, Transaction Boundaries, Resilience & Failure Isolation, and Observability, Security & Cost.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Florian Buetow\",\n        \"email\": \"2320560+florianbuetow@users.noreply.github.com\"\n      },\n      \"source\": \"./plugins/explain-system-tradeoffs\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "README.md": "# Claude Code Plugins\n\n![Made with AI](https://img.shields.io/badge/Made%20with-AI-333333?labelColor=f00) ![Verified by Humans](https://img.shields.io/badge/Verified%20by-Humans-333333?labelColor=brightgreen)\n\nA collection of Claude Code plugins for software engineering workflows.\n\n`4 plugins` · `4 skills`\n\n### Skills\n\n| Skill | Description |\n|-------|-------------|\n| [solid-principles](#solid-principles) | Automated SOLID principles analysis for OO code |\n| [beyond-solid-principles](#beyond-solid-principles) | System-level architecture principles analysis |\n| [spec-writer](#spec-writer) | Expert-guided software specification documents |\n| [explain-system-tradeoffs](#explain-system-tradeoffs) | Distributed system tradeoff analysis |\n\n---\n\n## Installation\n\nAll plugins are installed from the same marketplace.\n\n**Step 1** — Add the marketplace:\n\n```bash\nclaude plugin marketplace add florianbuetow/claude-code\n```\n\n**Step 2** — Install the plugin(s) you want:\n\n```bash\nclaude plugin install solid-principles\nclaude plugin install beyond-solid-principles\nclaude plugin install spec-writer\nclaude plugin install explain-system-tradeoffs\n```\n\n**Step 3** — Restart Claude Code.\n\n<details>\n<summary>Manual / Development Installation</summary>\n\n```bash\ngit clone https://github.com/florianbuetow/claude-code.git\ncd claude-code\n# Load a plugin directory for this session only\nclaude --plugin-dir ./plugins/solid-principles\nclaude --plugin-dir ./plugins/beyond-solid-principles\nclaude --plugin-dir ./plugins/spec-writer\nclaude --plugin-dir ./plugins/explain-system-tradeoffs\n```\n\n</details>\n\n---\n\n## solid-principles\n\nAutomated SOLID principles analysis for Claude Code.\n\n`5 principles`\n\nSOLID violations accumulate silently during development. By the time they surface — through rigid code, tangled dependencies, or brittle inheritance — refactoring is expensive.\n\nThis plugin lets you audit any class, module, or file **on demand**, getting severity-rated findings with concrete refactoring suggestions, right in your workflow.\n\n| Principle | Focus |\n|-----------|-------|\n| **SRP** — Single Responsibility | One reason to change per class |\n| **OCP** — Open/Closed | Extend without modifying |\n| **LSP** — Liskov Substitution | Subtypes honor parent contracts |\n| **ISP** — Interface Segregation | Small, focused interfaces |\n| **DIP** — Dependency Inversion | Depend on abstractions, not details |\n\n### How to Use\n\nCheck all five at once or focus on one:\n\n| Command | What it checks |\n|---------|---------------|\n| `solid` / `solid all` | All five principles |\n| `solid srp` | Single Responsibility only |\n| `solid ocp` | Open/Closed only |\n| `solid lsp` | Liskov Substitution only |\n| `solid isp` | Interface Segregation only |\n| `solid dip` | Dependency Inversion only |\n\n**Trigger** — Ask Claude to check SOLID, or mention a principle by name (\"check SRP\", \"is this violating LSP?\").\n\nEach violation is reported with severity (HIGH / MEDIUM / LOW), location, issue description, and a concrete refactoring suggestion. Ask Claude to \"fix this\" or \"refactor it\" after an audit to get refactored code.\n\n**Languages:** Any OO language — Python, Java, TypeScript, C#, C++, Kotlin, Go, Rust. The analysis adapts to each language's idioms.\n\n---\n\n## beyond-solid-principles\n\nSystem-level architecture principles analysis for Claude Code.\n\n`10 principles`\n\nSOLID covers class-level design, but architecture rot happens at a larger scale — tangled services, leaky abstractions, hidden coupling between modules, brittle failure propagation. By the time these problems surface, untangling them is far more expensive than fixing a single class.\n\nThis plugin lets you audit modules, services, layers, and component boundaries **on demand**, getting severity-rated findings with concrete remediation suggestions that operate at the architecture scale.\n\n| Principle | Focus |\n|-----------|-------|\n| **SoC** — Separation of Concerns | Distinct sections for distinct responsibilities |\n| **SRP-Sys** — Single Responsibility (system-level) | One business capability per module/service |\n| **DRY** — Don't Repeat Yourself | Eliminate knowledge duplication across boundaries |\n| **Demeter** — Law of Demeter | Talk only to immediate collaborators |\n| **Coupling** — Loose Coupling, High Cohesion | Minimize dependencies, maximize relatedness |\n| **Evolvability** — Build for Change | Support incremental evolution without rewrites |\n| **Resilience** — Design for Failure | Prevent cascading failures in distributed systems |\n| **KISS** — Keep It Simple | Avoid accidental complexity and over-engineering |\n| **POLA** — Principle of Least Surprise | Predictable APIs and system behavior |\n| **YAGNI** — You Aren't Gonna Need It | Don't build for hypothetical future requirements |\n\n### How to Use\n\nCheck all ten at once or focus on one:\n\n| Command | What it checks |\n|---------|---------------|\n| `beyond-solid-principles` | All ten principles |\n| `sw-soc` | Separation of Concerns only |\n| `sw-srp-sys` | Single Responsibility (system-level) only |\n| `sw-dry` | DRY only |\n| `sw-demeter` | Law of Demeter only |\n| `sw-coupling` | Loose Coupling, High Cohesion only |\n| `sw-evolvability` | Build for Change only |\n| `sw-resilience` | Design for Failure only |\n| `sw-kiss` | KISS only |\n| `sw-pola` | Principle of Least Surprise only |\n| `sw-yagni` | YAGNI only |\n\n**Trigger** — Ask Claude to check architecture principles, or mention a principle by name (\"check separation of concerns\", \"is this violating DRY?\", \"Law of Demeter\", \"loose coupling\").\n\nEach violation is reported with severity (HIGH / MEDIUM / LOW), location, issue description, and a concrete remediation suggestion. Ask Claude to \"fix this\" or \"refactor it\" after an audit to get refactored code or an architecture proposal.\n\n**Languages & architectures:** Any language, any architecture style — monoliths, modular monoliths, microservices, serverless, event-driven, layered, hexagonal. The analysis adapts to the idioms and scale of the target system.\n\n---\n\n## spec-writer\n\nExpert-guided software specification documents for greenfield projects.\n\n`5 document types` · `5 framework levels` · `Evidence-backed (ISO 29148, IEEE 830, IREB, DDD, C4, BDD)`\n\nWriting specifications is hard. Most teams either skip them entirely or produce documents that gather dust. This plugin walks you through creating professional, layered specification documents via an interactive guided interview — asking the right questions, suggesting intelligent defaults based on your project context, and outputting polished markdown documents.\n\n### Document Types\n\nThe skill produces five document types, each building on the previous:\n\n| Level | Command | Document | Core question |\n|-------|---------|----------|---------------|\n| L0 | `/spec-vision` | Product Vision & Strategic Alignment | \"Why are we building this?\" |\n| L1 | `/spec-brs` | Business & Stakeholder Requirements | \"What does the business need?\" |\n| L2 | `/spec-srs` | Software Requirements Specification | \"What does the system do?\" |\n| L3 | `/spec-architecture` | Architecture & Design Specification | \"How will it work?\" |\n| L4 | `/spec-test` | Behavioral Spec & Test Verification Plan | \"Prove it with examples\" |\n| All | `/spec` | Full walkthrough — all five in sequence | End-to-end specification |\n\n### How to Use\n\n#### Full walkthrough\n\nUse `/spec` to be guided through all five documents in sequence. Each level feeds into the next — goals become requirements, requirements become system behaviors, behaviors become architecture decisions, and decisions get verified by test plans.\n\n#### Individual documents\n\nYou can create any document on its own, but **the documents form a hierarchy** — each level builds on the context established by the level above it. If you skip a level, the skill will ask you for the essential upstream context it needs.\n\n**Recommended order when creating documents individually:**\n\n```\nL0: /spec-vision\n └─▶ L1: /spec-brs        (references Vision goals)\n      └─▶ L2: /spec-srs   (references BRS stakeholder needs & business rules)\n           └─▶ L3: /spec-architecture  (references SRS requirements as ASRs)\n                └─▶ L4: /spec-test     (references SRS requirements for scenarios)\n```\n\n- **Start at L0** (`/spec-vision`) if you're beginning a new project from scratch.\n- **Start at L1** (`/spec-brs`) if you already have a clear vision and need to formalize business requirements.\n- **Start at L2** (`/spec-srs`) if business requirements are already understood and you need system-level specs.\n- **Start at L3** (`/spec-architecture`) if you have an SRS and need to document design decisions.\n- **Start at L4** (`/spec-test`) if you have requirements and need to elaborate test scenarios for specific features.\n\nYou don't need to complete all five levels. Pick the level(s) that match where you are in your project:\n\n| Scenario | Recommended commands |\n|----------|---------------------|\n| New project, need full specs | `/spec` (full walkthrough) |\n| New project, want to start light | `/spec-vision` then `/spec-brs` |\n| Have requirements, need architecture | `/spec-architecture` |\n| Need test plans for existing features | `/spec-test` |\n| Stakeholder alignment needed | `/spec-vision` |\n\n### What to Expect\n\nThe skill drives an interactive conversation:\n- Questions are presented as **selectable options** with a free-text escape\n- **1-3 questions per turn**, grouped thematically — it won't overwhelm you\n- After each section, it **summarizes what was captured** and asks for confirmation\n- It **challenges vague inputs** (e.g., \"the system should be fast\" becomes \"p99 latency ≤ 200ms under 1,000 concurrent users\")\n- It provides **context-aware suggestions** based on your project domain (B2B SaaS, healthcare, startup MVP, etc.)\n\nOutput documents are saved as markdown files with traceability IDs that link across levels.\n\n---\n\n## explain-system-tradeoffs\n\nReverse-engineer distributed system tradeoffs from code, configuration, and architecture artifacts.\n\n`6 tradeoff axes` · `3 evidence tiers` · `Parallel subagent analysis` · `Evidence-based (CAP, PACELC, SRE, chaos engineering)`\n\nEvery distributed system encodes its design tradeoffs in artifacts hiding in plain sight — configuration files, schema definitions, deployment manifests, timeout values, retry policies, and code patterns. A `synchronous_commit = off` in PostgreSQL, a `failure_mode_deny: false` in Envoy, a hashed shard key on time-series data — each is a decision with consequences that ripple across the system.\n\nThis plugin reads those artifacts like an architectural blueprint. Instead of looking for *violations* (that's what beyond-solid-principles does), it identifies *decisions* — what the system prioritizes, what it sacrifices, whether those choices appear deliberate or accidental, and where they conflict with each other.\n\n### Tradeoff Axes\n\n| Axis | Focus | Example indicators |\n|------|-------|--------------------|\n| **Consistency** | Consistency & Availability | Replication factors, quorum settings, cache TTLs, conflict resolution, schema compatibility modes |\n| **Latency** | Latency & Throughput | GC flags, thread pool configs, Disruptor wait strategies, deadline propagation, hedged requests, compaction styles |\n| **Data** | Data Distribution | Shard keys, partition strategies, rack-aware replication, data sovereignty constraints, cross-shard complexity |\n| **Transactions** | Transaction Boundaries & Coordination | Sagas, outbox tables, schema evolution, API versioning, dependency boundaries, database-per-service |\n| **Resilience** | Resilience & Failure Isolation | Circuit breakers, retry budgets, chaos experiments with steady-state hypotheses, canary analysis templates, service mesh outlier detection |\n| **Operations** | Observability, Security & Cost | Tracing sampling rates, SLO/error-budget frameworks, mTLS posture, audit trail fidelity, multi-region cost topology |\n\n### How to Use\n\nAnalyze all six axes at once or focus on one:\n\n| Command | What it analyzes |\n|---------|-----------------|\n| `explain-system-tradeoffs` | All six axes (parallel) |\n| `explain-system-consistency-tradeoffs` | Consistency & Availability only |\n| `explain-system-latency-tradeoffs` | Latency & Throughput only |\n| `explain-system-data-tradeoffs` | Data Distribution only |\n| `explain-system-transaction-tradeoffs` | Transaction Boundaries & Coordination only |\n| `explain-system-resilience-tradeoffs` | Resilience & Failure Isolation only |\n| `explain-system-operations-tradeoffs` | Observability, Security & Cost only |\n\n**Trigger** — Ask Claude to explain system tradeoffs, analyze architecture decisions, or mention a tradeoff by name (\"consistency vs availability\", \"what are the latency tradeoffs\", \"CAP analysis\", \"PACELC\").\n\n### What to Expect\n\n**Single-axis commands** run the analysis directly — Claude reads the reference for that axis, scans the codebase, and reports findings.\n\n**Full analysis** (`explain-system-tradeoffs`) launches **six parallel subagents**, one per axis. Each subagent reads its own reference file and independently scans the codebase. The main agent then collects the six per-axis reports and produces a **cross-axis synthesis** — the part that requires seeing all six axes together: where tradeoff choices on one axis conflict with choices on another (e.g., AP consistency paired with synchronous saga coordination).\n\nEach finding is backed by evidence classified into three tiers:\n\n| Tier | What it means | Examples |\n|------|---------------|---------|\n| **A — Hard commitments** | User-facing guarantees, wire-protocol requirements | SLA language, quorum rules, schema invariants |\n| **B — Mechanism evidence** | Concrete mechanisms enforcing the property | Consensus protocols, circuit breaker configs, GC flags, compaction strategies |\n| **C — Operational signatures** | What engineers actually protect in production | Dashboards, alerts, SLO definitions, runbooks, error budgets |\n\nThe report distinguishes **deliberate choices** (asymmetric config, tuned values, documented rationale) from **accidental defaults** (framework defaults, copy-pasted settings, uniform config). Deliberate asymmetry — different compaction strategies per table, different TTLs per cache key, different timeout budgets per downstream call — is the hallmark of genuine tradeoff-making.\n\n**Systems:** Any distributed system — microservices, modular monoliths, event-driven, serverless. Many indicators (caching, thread pools, GC tuning, storage engines, schema evolution) also apply to non-distributed systems with performance or reliability requirements.\n\n---\n\n## Project Structure\n\n```\n.claude-plugin/\n  └── marketplace.json                # Plugin registry\nplugins/\n  ├── solid-principles/\n  │   ├── .claude-plugin/\n  │   │   └── plugin.json             # Plugin manifest\n  │   └── skills/\n  │       └── solid-principles/\n  │           ├── SKILL.md            # Skill definition & workflow\n  │           └── references/\n  │               ├── srp.md          # Single Responsibility patterns\n  │               ├── ocp.md          # Open/Closed patterns\n  │               ├── lsp.md          # Liskov Substitution patterns\n  │               ├── isp.md          # Interface Segregation patterns\n  │               └── dip.md          # Dependency Inversion patterns\n  ├── beyond-solid-principles/\n  │   ├── .claude-plugin/\n  │   │   └── plugin.json             # Plugin manifest\n  │   └── skills/\n  │       └── beyond-solid-principles/\n  │           ├── SKILL.md            # Skill definition & workflow\n  │           └── references/\n  │               ├── soc.md          # Separation of Concerns patterns\n  │               ├── srp-sys.md      # Single Responsibility (system-level)\n  │               ├── dry.md          # Don't Repeat Yourself patterns\n  │               ├── demeter.md      # Law of Demeter patterns\n  │               ├── coupling.md     # Loose Coupling, High Cohesion\n  │               ├── evolvability.md # Build for Change patterns\n  │               ├── resilience.md   # Design for Failure patterns\n  │               ├── kiss.md         # KISS patterns\n  │               ├── pola.md         # Principle of Least Surprise\n  │               └── yagni.md        # YAGNI patterns\n  ├── spec-writer/\n  │   ├── .claude-plugin/\n  │   │   └── plugin.json             # Plugin manifest\n  │   └── skills/\n  │       └── spec-writer/\n  │           ├── SKILL.md            # Skill definition & workflow\n  │           └── references/\n  │               ├── vision.md       # L0 — Product Vision reference\n  │               ├── brs.md          # L1 — Business Requirements reference\n  │               ├── srs.md          # L2 — Software Requirements reference\n  │               ├── architecture.md # L3 — Architecture & Design reference\n  │               └── verification.md # L4 — Test Verification reference\n  └── explain-system-tradeoffs/\n      ├── .claude-plugin/\n      │   └── plugin.json             # Plugin manifest\n      └── skills/\n          └── explain-system-tradeoffs/\n              ├── SKILL.md            # Skill definition & workflow\n              └── references/\n                  ├── consistency.md  # Consistency & Availability axis\n                  ├── latency.md      # Latency & Throughput axis\n                  ├── data-distribution.md # Data Distribution axis\n                  ├── transactions.md # Transaction Boundaries axis\n                  ├── resilience.md   # Resilience & Failure Isolation axis\n                  └── operations.md   # Observability, Security & Cost axis\n```\n\n---\n\n## FAQ\n\n**What languages does solid-principles support?**\nAny OO language — Python, Java, TypeScript, C#, C++, Kotlin, Go (struct methods), Rust (impl blocks). The analysis adapts to the idioms of each language.\n\n**Is solid-principles too strict?**\nNo. The skill includes pragmatism guidelines. A 50-line script doesn't get the same scrutiny as a large production system.\n\n**What's the difference between solid-principles and beyond-solid-principles?**\nsolid-principles operates at the class level — single classes, interfaces, and inheritance hierarchies. beyond-solid-principles operates at the architecture level — modules, services, layers, and system boundaries. They complement each other: use solid-principles for OO design quality, beyond-solid-principles for structural health at scale.\n\n**Does beyond-solid-principles require a distributed system?**\nNo. The principles apply to any codebase with module or package boundaries. For monoliths, the analysis focuses on dependency direction, internal layering, and package cohesion. For distributed systems, it also covers service boundaries, API contracts, failure propagation, and operational resilience.\n\n**Do I need all five spec documents?**\nNo. Each document can be created independently. Start at whatever level matches your needs. The full walkthrough (`/spec`) is there for when you want the complete suite.\n\n**Can I use spec-writer for an existing project?**\nThe skill is optimized for greenfield projects, but you can start at any level. For existing projects, `/spec-architecture` and `/spec-test` are often the most useful starting points.\n\n**What's the difference between beyond-solid-principles and explain-system-tradeoffs?**\nbeyond-solid-principles finds *violations* of design principles — things that should be fixed. explain-system-tradeoffs identifies *tradeoff decisions* — things that were chosen (deliberately or not). A system can follow all design principles perfectly and still have interesting tradeoffs to understand. Use beyond-solid-principles for \"what's wrong?\", use explain-system-tradeoffs for \"what was decided and why?\"\n\n**Does explain-system-tradeoffs require a distributed system?**\nIt's most useful for distributed systems, but many tradeoff indicators (caching, thread pools, GC tuning, storage engines, schema evolution) apply to any system with performance or reliability requirements.\n\n**How much context do the plugins use?**\nAll plugins use progressive disclosure — reference material is loaded only when needed to minimize token usage.\n\n---\n\n## License\n\nMIT\n\n---\n\n[GitHub](https://github.com/florianbuetow/claude-code) | [Issues](https://github.com/florianbuetow/claude-code/issues) | [License](LICENSE)\n"
      },
      "plugins": [
        {
          "name": "solid-principles",
          "description": "Analyze code for violations of the SOLID principles of object-oriented design (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion)",
          "version": "1.0.0",
          "author": {
            "name": "Florian Buetow",
            "email": "2320560+florianbuetow@users.noreply.github.com"
          },
          "source": "./plugins/solid-principles",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add florianbuetow/claude-code",
            "/plugin install solid-principles@florianbuetow-plugins"
          ]
        },
        {
          "name": "beyond-solid-principles",
          "description": "Analyze code and architecture for violations of ten system-level software design principles: Separation of Concerns, Single Responsibility (system-level), DRY, Law of Demeter, Loose Coupling / High Cohesion, Evolvability, Resilience, KISS, Principle of Least Surprise, and YAGNI",
          "version": "1.0.0",
          "author": {
            "name": "Florian Buetow",
            "email": "2320560+florianbuetow@users.noreply.github.com"
          },
          "source": "./plugins/beyond-solid-principles",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add florianbuetow/claude-code",
            "/plugin install beyond-solid-principles@florianbuetow-plugins"
          ]
        },
        {
          "name": "spec-writer",
          "description": "An expert-guided skill for creating layered software specification documents for greenfield projects. Produces Vision, Business Requirements, Software Requirements, Architecture & Design, and Behavioral Spec & Test Verification documents.",
          "version": "1.0.0",
          "author": {
            "name": "Florian Buetow",
            "email": "2320560+florianbuetow@users.noreply.github.com"
          },
          "source": "./plugins/spec-writer",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add florianbuetow/claude-code",
            "/plugin install spec-writer@florianbuetow-plugins"
          ]
        },
        {
          "name": "explain-system-tradeoffs",
          "description": "Reverse-engineer distributed system tradeoffs from code, configuration, and architecture artifacts. Analyzes six axes: Consistency & Availability, Latency & Throughput, Data Distribution, Transaction Boundaries, Resilience & Failure Isolation, and Observability, Security & Cost.",
          "version": "1.0.0",
          "author": {
            "name": "Florian Buetow",
            "email": "2320560+florianbuetow@users.noreply.github.com"
          },
          "source": "./plugins/explain-system-tradeoffs",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add florianbuetow/claude-code",
            "/plugin install explain-system-tradeoffs@florianbuetow-plugins"
          ]
        }
      ]
    }
  ]
}