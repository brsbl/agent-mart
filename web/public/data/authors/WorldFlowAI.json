{
  "author": {
    "id": "WorldFlowAI",
    "display_name": "WorldFlowAI",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/253326648?v=4",
    "url": "https://github.com/WorldFlowAI",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 15,
      "total_skills": 11,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "everything-claude-code",
      "version": null,
      "description": "Battle-tested Claude Code configurations from an Anthropic hackathon winner",
      "owner_info": {
        "name": "Affaan Mustafa",
        "email": "affaan@example.com"
      },
      "keywords": [],
      "repo_full_name": "WorldFlowAI/everything-claude-code",
      "repo_url": "https://github.com/WorldFlowAI/everything-claude-code",
      "repo_description": "Claude Code toolkit - agents, commands, skills, rules, and hooks for productive AI-assisted development",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-23T12:42:00Z",
        "created_at": "2026-01-23T12:41:36Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1095
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 754
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 12871
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/architect.md",
          "type": "blob",
          "size": 6283
        },
        {
          "path": "agents/build-error-resolver.md",
          "type": "blob",
          "size": 12221
        },
        {
          "path": "agents/code-reviewer.md",
          "type": "blob",
          "size": 2887
        },
        {
          "path": "agents/doc-updater.md",
          "type": "blob",
          "size": 10967
        },
        {
          "path": "agents/e2e-runner.md",
          "type": "blob",
          "size": 19822
        },
        {
          "path": "agents/planner.md",
          "type": "blob",
          "size": 3232
        },
        {
          "path": "agents/refactor-cleaner.md",
          "type": "blob",
          "size": 7691
        },
        {
          "path": "agents/security-reviewer.md",
          "type": "blob",
          "size": 14320
        },
        {
          "path": "agents/tdd-guide.md",
          "type": "blob",
          "size": 7074
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/build-fix.md",
          "type": "blob",
          "size": 572
        },
        {
          "path": "commands/checkpoint.md",
          "type": "blob",
          "size": 1520
        },
        {
          "path": "commands/code-review.md",
          "type": "blob",
          "size": 985
        },
        {
          "path": "commands/e2e.md",
          "type": "blob",
          "size": 10795
        },
        {
          "path": "commands/eval.md",
          "type": "blob",
          "size": 2214
        },
        {
          "path": "commands/learn.md",
          "type": "blob",
          "size": 1605
        },
        {
          "path": "commands/orchestrate.md",
          "type": "blob",
          "size": 3344
        },
        {
          "path": "commands/plan.md",
          "type": "blob",
          "size": 3602
        },
        {
          "path": "commands/refactor-clean.md",
          "type": "blob",
          "size": 719
        },
        {
          "path": "commands/setup-pm.md",
          "type": "blob",
          "size": 1675
        },
        {
          "path": "commands/tdd.md",
          "type": "blob",
          "size": 8230
        },
        {
          "path": "commands/test-coverage.md",
          "type": "blob",
          "size": 663
        },
        {
          "path": "commands/update-codemaps.md",
          "type": "blob",
          "size": 702
        },
        {
          "path": "commands/update-docs.md",
          "type": "blob",
          "size": 731
        },
        {
          "path": "commands/verify.md",
          "type": "blob",
          "size": 1197
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 8415
        },
        {
          "path": "hooks/memory-persistence",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/memory-persistence/pre-compact.sh",
          "type": "blob",
          "size": 1092
        },
        {
          "path": "hooks/memory-persistence/session-end.sh",
          "type": "blob",
          "size": 1430
        },
        {
          "path": "hooks/memory-persistence/session-start.sh",
          "type": "blob",
          "size": 1149
        },
        {
          "path": "hooks/strategic-compact",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/strategic-compact/suggest-compact.sh",
          "type": "blob",
          "size": 1634
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/README.md",
          "type": "blob",
          "size": 2037
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/hooks/evaluate-session.js",
          "type": "blob",
          "size": 2236
        },
        {
          "path": "scripts/hooks/pre-compact.js",
          "type": "blob",
          "size": 1266
        },
        {
          "path": "scripts/hooks/session-end.js",
          "type": "blob",
          "size": 1599
        },
        {
          "path": "scripts/hooks/session-start.js",
          "type": "blob",
          "size": 1752
        },
        {
          "path": "scripts/hooks/suggest-compact.js",
          "type": "blob",
          "size": 1790
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/backend-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/backend-patterns/SKILL.md",
          "type": "blob",
          "size": 13175
        },
        {
          "path": "skills/clickhouse-io",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/clickhouse-io/SKILL.md",
          "type": "blob",
          "size": 9972
        },
        {
          "path": "skills/coding-standards",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-standards/SKILL.md",
          "type": "blob",
          "size": 11398
        },
        {
          "path": "skills/continuous-learning",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/continuous-learning/SKILL.md",
          "type": "blob",
          "size": 2070
        },
        {
          "path": "skills/eval-harness",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/eval-harness/SKILL.md",
          "type": "blob",
          "size": 4992
        },
        {
          "path": "skills/frontend-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/frontend-patterns/SKILL.md",
          "type": "blob",
          "size": 14311
        },
        {
          "path": "skills/project-guidelines-example",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/project-guidelines-example/SKILL.md",
          "type": "blob",
          "size": 9666
        },
        {
          "path": "skills/security-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/security-review/SKILL.md",
          "type": "blob",
          "size": 12202
        },
        {
          "path": "skills/strategic-compact",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/strategic-compact/SKILL.md",
          "type": "blob",
          "size": 2055
        },
        {
          "path": "skills/tdd-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/tdd-workflow/SKILL.md",
          "type": "blob",
          "size": 9763
        },
        {
          "path": "skills/verification-loop",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/verification-loop/SKILL.md",
          "type": "blob",
          "size": 2369
        },
        {
          "path": "tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/hooks/hooks.test.js",
          "type": "blob",
          "size": 10448
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"everything-claude-code\",\n  \"owner\": {\n    \"name\": \"Affaan Mustafa\",\n    \"email\": \"affaan@example.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Battle-tested Claude Code configurations from an Anthropic hackathon winner\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"everything-claude-code\",\n      \"source\": \"./\",\n      \"description\": \"Complete collection of agents, skills, hooks, commands, and rules evolved over 10+ months of intensive daily use\",\n      \"author\": {\n        \"name\": \"Affaan Mustafa\"\n      },\n      \"homepage\": \"https://github.com/affaan-m/everything-claude-code\",\n      \"repository\": \"https://github.com/affaan-m/everything-claude-code\",\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"agents\",\n        \"skills\",\n        \"hooks\",\n        \"commands\",\n        \"tdd\",\n        \"code-review\",\n        \"security\",\n        \"best-practices\"\n      ],\n      \"category\": \"workflow\",\n      \"tags\": [\n        \"agents\",\n        \"skills\",\n        \"hooks\",\n        \"commands\",\n        \"tdd\",\n        \"code-review\",\n        \"security\",\n        \"best-practices\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"everything-claude-code\",\n  \"description\": \"Complete collection of battle-tested Claude Code configs from an Anthropic hackathon winner - agents, skills, hooks, commands, and rules evolved over 10+ months of intensive daily use\",\n  \"author\": {\n    \"name\": \"Affaan Mustafa\",\n    \"url\": \"https://x.com/affaanmustafa\"\n  },\n  \"homepage\": \"https://github.com/affaan-m/everything-claude-code\",\n  \"repository\": \"https://github.com/affaan-m/everything-claude-code\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"claude-code\",\n    \"agents\",\n    \"skills\",\n    \"hooks\",\n    \"commands\",\n    \"rules\",\n    \"tdd\",\n    \"code-review\",\n    \"security\",\n    \"workflow\",\n    \"automation\",\n    \"best-practices\"\n  ],\n  \"commands\": \"./commands\",\n  \"skills\": \"./skills\"\n}\n",
        "README.md": "# Everything Claude Code\n\n[![Stars](https://img.shields.io/github/stars/affaan-m/everything-claude-code?style=flat)](https://github.com/affaan-m/everything-claude-code/stargazers)\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n![Shell](https://img.shields.io/badge/-Shell-4EAA25?logo=gnu-bash&logoColor=white)\n![TypeScript](https://img.shields.io/badge/-TypeScript-3178C6?logo=typescript&logoColor=white)\n![Markdown](https://img.shields.io/badge/-Markdown-000000?logo=markdown&logoColor=white)\n\n**The complete collection of Claude Code configs from an Anthropic hackathon winner.**\n\nProduction-ready agents, skills, hooks, commands, rules, and MCP configurations evolved over 10+ months of intensive daily use building real products.\n\n---\n\n## The Guides\n\nThis repo is the raw code only. The guides explain everything.\n\n<table>\n<tr>\n<td width=\"50%\">\n<a href=\"https://x.com/affaanmustafa/status/2012378465664745795\">\n<img src=\"https://github.com/user-attachments/assets/1a471488-59cc-425b-8345-5245c7efbcef\" alt=\"The Shorthand Guide to Everything Claude Code\" />\n</a>\n</td>\n<td width=\"50%\">\n<a href=\"https://x.com/affaanmustafa/status/2014040193557471352\">\n<img src=\"https://github.com/user-attachments/assets/c9ca43bc-b149-427f-b551-af6840c368f0\" alt=\"The Longform Guide to Everything Claude Code\" />\n</a>\n</td>\n</tr>\n<tr>\n<td align=\"center\"><b>Shorthand Guide</b><br/>Setup, foundations, philosophy. <b>Read this first.</b></td>\n<td align=\"center\"><b>Longform Guide</b><br/>Token optimization, memory persistence, evals, parallelization.</td>\n</tr>\n</table>\n\n| Topic | What You'll Learn |\n|-------|-------------------|\n| Token Optimization | Model selection, system prompt slimming, background processes |\n| Memory Persistence | Hooks that save/load context across sessions automatically |\n| Continuous Learning | Auto-extract patterns from sessions into reusable skills |\n| Verification Loops | Checkpoint vs continuous evals, grader types, pass@k metrics |\n| Parallelization | Git worktrees, cascade method, when to scale instances |\n| Subagent Orchestration | The context problem, iterative retrieval pattern |\n\n---\n\n## Cross-Platform Support\n\nThis plugin now fully supports **Windows, macOS, and Linux**. All hooks and scripts have been rewritten in Node.js for maximum compatibility.\n\n### Package Manager Detection\n\nThe plugin automatically detects your preferred package manager (npm, pnpm, yarn, or bun) with the following priority:\n\n1. **Environment variable**: `CLAUDE_PACKAGE_MANAGER`\n2. **Project config**: `.claude/package-manager.json`\n3. **package.json**: `packageManager` field\n4. **Lock file**: Detection from package-lock.json, yarn.lock, pnpm-lock.yaml, or bun.lockb\n5. **Global config**: `~/.claude/package-manager.json`\n6. **Fallback**: First available package manager\n\nTo set your preferred package manager:\n\n```bash\n# Via environment variable\nexport CLAUDE_PACKAGE_MANAGER=pnpm\n\n# Via global config\nnode scripts/setup-package-manager.js --global pnpm\n\n# Via project config\nnode scripts/setup-package-manager.js --project bun\n\n# Detect current setting\nnode scripts/setup-package-manager.js --detect\n```\n\nOr use the `/setup-pm` command in Claude Code.\n\n---\n\n## What's Inside\n\nThis repo is a **Claude Code plugin** - install it directly or copy components manually.\n\n```\neverything-claude-code/\n|-- .claude-plugin/   # Plugin and marketplace manifests\n|   |-- plugin.json         # Plugin metadata and component paths\n|   |-- marketplace.json    # Marketplace catalog for /plugin marketplace add\n|\n|-- agents/           # Specialized subagents for delegation\n|   |-- planner.md           # Feature implementation planning\n|   |-- architect.md         # System design decisions\n|   |-- tdd-guide.md         # Test-driven development\n|   |-- code-reviewer.md     # Quality and security review\n|   |-- security-reviewer.md # Vulnerability analysis\n|   |-- build-error-resolver.md\n|   |-- e2e-runner.md        # Playwright E2E testing\n|   |-- refactor-cleaner.md  # Dead code cleanup\n|   |-- doc-updater.md       # Documentation sync\n|\n|-- skills/           # Workflow definitions and domain knowledge\n|   |-- coding-standards/           # Language best practices\n|   |-- backend-patterns/           # API, database, caching patterns\n|   |-- frontend-patterns/          # React, Next.js patterns\n|   |-- continuous-learning/        # Auto-extract patterns from sessions (Longform Guide)\n|   |-- strategic-compact/          # Manual compaction suggestions (Longform Guide)\n|   |-- tdd-workflow/               # TDD methodology\n|   |-- security-review/            # Security checklist\n|   |-- eval-harness/               # Verification loop evaluation (Longform Guide)\n|   |-- verification-loop/          # Continuous verification (Longform Guide)\n|\n|-- commands/         # Slash commands for quick execution\n|   |-- tdd.md              # /tdd - Test-driven development\n|   |-- plan.md             # /plan - Implementation planning\n|   |-- e2e.md              # /e2e - E2E test generation\n|   |-- code-review.md      # /code-review - Quality review\n|   |-- build-fix.md        # /build-fix - Fix build errors\n|   |-- refactor-clean.md   # /refactor-clean - Dead code removal\n|   |-- learn.md            # /learn - Extract patterns mid-session (Longform Guide)\n|   |-- checkpoint.md       # /checkpoint - Save verification state (Longform Guide)\n|   |-- verify.md           # /verify - Run verification loop (Longform Guide)\n|   |-- setup-pm.md         # /setup-pm - Configure package manager (NEW)\n|\n|-- rules/            # Always-follow guidelines (copy to ~/.claude/rules/)\n|   |-- security.md         # Mandatory security checks\n|   |-- coding-style.md     # Immutability, file organization\n|   |-- testing.md          # TDD, 80% coverage requirement\n|   |-- git-workflow.md     # Commit format, PR process\n|   |-- agents.md           # When to delegate to subagents\n|   |-- performance.md      # Model selection, context management\n|\n|-- hooks/            # Trigger-based automations\n|   |-- hooks.json                # All hooks config (PreToolUse, PostToolUse, Stop, etc.)\n|   |-- memory-persistence/       # Session lifecycle hooks (Longform Guide)\n|   |-- strategic-compact/        # Compaction suggestions (Longform Guide)\n|\n|-- scripts/          # Cross-platform Node.js scripts (NEW)\n|   |-- lib/                     # Shared utilities\n|   |   |-- utils.js             # Cross-platform file/path/system utilities\n|   |   |-- package-manager.js   # Package manager detection and selection\n|   |-- hooks/                   # Hook implementations\n|   |   |-- session-start.js     # Load context on session start\n|   |   |-- session-end.js       # Save state on session end\n|   |   |-- pre-compact.js       # Pre-compaction state saving\n|   |   |-- suggest-compact.js   # Strategic compaction suggestions\n|   |   |-- evaluate-session.js  # Extract patterns from sessions\n|   |-- setup-package-manager.js # Interactive PM setup\n|\n|-- tests/            # Test suite (NEW)\n|   |-- lib/                     # Library tests\n|   |-- hooks/                   # Hook tests\n|   |-- run-all.js               # Run all tests\n|\n|-- contexts/         # Dynamic system prompt injection contexts (Longform Guide)\n|   |-- dev.md              # Development mode context\n|   |-- review.md           # Code review mode context\n|   |-- research.md         # Research/exploration mode context\n|\n|-- examples/         # Example configurations and sessions\n|   |-- CLAUDE.md           # Example project-level config\n|   |-- user-CLAUDE.md      # Example user-level config\n|\n|-- mcp-configs/      # MCP server configurations\n|   |-- mcp-servers.json    # GitHub, Supabase, Vercel, Railway, etc.\n|\n|-- marketplace.json  # Self-hosted marketplace config (for /plugin marketplace add)\n```\n\n---\n\n## Installation\n\n### Option 1: Install as Plugin (Recommended)\n\nThe easiest way to use this repo - install as a Claude Code plugin:\n\n```bash\n# Add this repo as a marketplace\n/plugin marketplace add affaan-m/everything-claude-code\n\n# Install the plugin\n/plugin install everything-claude-code@everything-claude-code\n```\n\nOr add directly to your `~/.claude/settings.json`:\n\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"everything-claude-code\": {\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"affaan-m/everything-claude-code\"\n      }\n    }\n  },\n  \"enabledPlugins\": {\n    \"everything-claude-code@everything-claude-code\": true\n  }\n}\n```\n\nThis gives you instant access to all commands, agents, skills, and hooks.\n\n---\n\n### Option 2: Manual Installation\n\nIf you prefer manual control over what's installed:\n\n```bash\n# Clone the repo\ngit clone https://github.com/affaan-m/everything-claude-code.git\n\n# Copy agents to your Claude config\ncp everything-claude-code/agents/*.md ~/.claude/agents/\n\n# Copy rules\ncp everything-claude-code/rules/*.md ~/.claude/rules/\n\n# Copy commands\ncp everything-claude-code/commands/*.md ~/.claude/commands/\n\n# Copy skills\ncp -r everything-claude-code/skills/* ~/.claude/skills/\n```\n\n#### Add hooks to settings.json\n\nCopy the hooks from `hooks/hooks.json` to your `~/.claude/settings.json`.\n\n#### Configure MCPs\n\nCopy desired MCP servers from `mcp-configs/mcp-servers.json` to your `~/.claude.json`.\n\n**Important:** Replace `YOUR_*_HERE` placeholders with your actual API keys.\n\n---\n\n## Key Concepts\n\n### Agents\n\nSubagents handle delegated tasks with limited scope. Example:\n\n```markdown\n---\nname: code-reviewer\ndescription: Reviews code for quality, security, and maintainability\ntools: Read, Grep, Glob, Bash\nmodel: opus\n---\n\nYou are a senior code reviewer...\n```\n\n### Skills\n\nSkills are workflow definitions invoked by commands or agents:\n\n```markdown\n# TDD Workflow\n\n1. Define interfaces first\n2. Write failing tests (RED)\n3. Implement minimal code (GREEN)\n4. Refactor (IMPROVE)\n5. Verify 80%+ coverage\n```\n\n### Hooks\n\nHooks fire on tool events. Example - warn about console.log:\n\n```json\n{\n  \"matcher\": \"tool == \\\"Edit\\\" && tool_input.file_path matches \\\"\\\\\\\\.(ts|tsx|js|jsx)$\\\"\",\n  \"hooks\": [{\n    \"type\": \"command\",\n    \"command\": \"#!/bin/bash\\ngrep -n 'console\\\\.log' \\\"$file_path\\\" && echo '[Hook] Remove console.log' >&2\"\n  }]\n}\n```\n\n### Rules\n\nRules are always-follow guidelines. Keep them modular:\n\n```\n~/.claude/rules/\n  security.md      # No hardcoded secrets\n  coding-style.md  # Immutability, file limits\n  testing.md       # TDD, coverage requirements\n```\n\n---\n\n## Running Tests\n\nThe plugin includes a comprehensive test suite:\n\n```bash\n# Run all tests\nnode tests/run-all.js\n\n# Run individual test files\nnode tests/lib/utils.test.js\nnode tests/lib/package-manager.test.js\nnode tests/hooks/hooks.test.js\n```\n\n---\n\n## Contributing\n\n**Contributions are welcome and encouraged.**\n\nThis repo is meant to be a community resource. If you have:\n- Useful agents or skills\n- Clever hooks\n- Better MCP configurations\n- Improved rules\n\nPlease contribute! See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.\n\n### Ideas for Contributions\n\n- Language-specific skills (Python, Go, Rust patterns)\n- Framework-specific configs (Django, Rails, Laravel)\n- DevOps agents (Kubernetes, Terraform, AWS)\n- Testing strategies (different frameworks)\n- Domain-specific knowledge (ML, data engineering, mobile)\n\n---\n\n## Background\n\nI've been using Claude Code since the experimental rollout. Won the Anthropic x Forum Ventures hackathon in Sep 2025 building [zenith.chat](https://zenith.chat) with [@DRodriguezFX](https://x.com/DRodriguezFX) - entirely using Claude Code.\n\nThese configs are battle-tested across multiple production applications.\n\n---\n\n## Important Notes\n\n### Context Window Management\n\n**Critical:** Don't enable all MCPs at once. Your 200k context window can shrink to 70k with too many tools enabled.\n\nRule of thumb:\n- Have 20-30 MCPs configured\n- Keep under 10 enabled per project\n- Under 80 tools active\n\nUse `disabledMcpServers` in project config to disable unused ones.\n\n### Customization\n\nThese configs work for my workflow. You should:\n1. Start with what resonates\n2. Modify for your stack\n3. Remove what you don't use\n4. Add your own patterns\n\n---\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=affaan-m/everything-claude-code&type=Date)](https://star-history.com/#affaan-m/everything-claude-code&Date)\n\n---\n\n## Links\n\n- **Shorthand Guide (Start Here):** [The Shorthand Guide to Everything Claude Code](https://x.com/affaanmustafa/status/2012378465664745795)\n- **Longform Guide (Advanced):** [The Longform Guide to Everything Claude Code](https://x.com/affaanmustafa/status/2014040193557471352)\n- **Follow:** [@affaanmustafa](https://x.com/affaanmustafa)\n- **zenith.chat:** [zenith.chat](https://zenith.chat)\n\n---\n\n## License\n\nMIT - Use freely, modify as needed, contribute back if you can.\n\n---\n\n**Star this repo if it helps. Read both guides. Build something great.**\n",
        "agents/architect.md": "---\nname: architect\ndescription: Software architecture specialist for system design, scalability, and technical decision-making. Use PROACTIVELY when planning new features, refactoring large systems, or making architectural decisions.\ntools: Read, Grep, Glob\nmodel: opus\n---\n\nYou are a senior software architect specializing in scalable, maintainable system design.\n\n## Your Role\n\n- Design system architecture for new features\n- Evaluate technical trade-offs\n- Recommend patterns and best practices\n- Identify scalability bottlenecks\n- Plan for future growth\n- Ensure consistency across codebase\n\n## Architecture Review Process\n\n### 1. Current State Analysis\n- Review existing architecture\n- Identify patterns and conventions\n- Document technical debt\n- Assess scalability limitations\n\n### 2. Requirements Gathering\n- Functional requirements\n- Non-functional requirements (performance, security, scalability)\n- Integration points\n- Data flow requirements\n\n### 3. Design Proposal\n- High-level architecture diagram\n- Component responsibilities\n- Data models\n- API contracts\n- Integration patterns\n\n### 4. Trade-Off Analysis\nFor each design decision, document:\n- **Pros**: Benefits and advantages\n- **Cons**: Drawbacks and limitations\n- **Alternatives**: Other options considered\n- **Decision**: Final choice and rationale\n\n## Architectural Principles\n\n### 1. Modularity & Separation of Concerns\n- Single Responsibility Principle\n- High cohesion, low coupling\n- Clear interfaces between components\n- Independent deployability\n\n### 2. Scalability\n- Horizontal scaling capability\n- Stateless design where possible\n- Efficient database queries\n- Caching strategies\n- Load balancing considerations\n\n### 3. Maintainability\n- Clear code organization\n- Consistent patterns\n- Comprehensive documentation\n- Easy to test\n- Simple to understand\n\n### 4. Security\n- Defense in depth\n- Principle of least privilege\n- Input validation at boundaries\n- Secure by default\n- Audit trail\n\n### 5. Performance\n- Efficient algorithms\n- Minimal network requests\n- Optimized database queries\n- Appropriate caching\n- Lazy loading\n\n## Common Patterns\n\n### Frontend Patterns\n- **Component Composition**: Build complex UI from simple components\n- **Container/Presenter**: Separate data logic from presentation\n- **Custom Hooks**: Reusable stateful logic\n- **Context for Global State**: Avoid prop drilling\n- **Code Splitting**: Lazy load routes and heavy components\n\n### Backend Patterns\n- **Repository Pattern**: Abstract data access\n- **Service Layer**: Business logic separation\n- **Middleware Pattern**: Request/response processing\n- **Event-Driven Architecture**: Async operations\n- **CQRS**: Separate read and write operations\n\n### Data Patterns\n- **Normalized Database**: Reduce redundancy\n- **Denormalized for Read Performance**: Optimize queries\n- **Event Sourcing**: Audit trail and replayability\n- **Caching Layers**: Redis, CDN\n- **Eventual Consistency**: For distributed systems\n\n## Architecture Decision Records (ADRs)\n\nFor significant architectural decisions, create ADRs:\n\n```markdown\n# ADR-001: Use Redis for Semantic Search Vector Storage\n\n## Context\nNeed to store and query 1536-dimensional embeddings for semantic market search.\n\n## Decision\nUse Redis Stack with vector search capability.\n\n## Consequences\n\n### Positive\n- Fast vector similarity search (<10ms)\n- Built-in KNN algorithm\n- Simple deployment\n- Good performance up to 100K vectors\n\n### Negative\n- In-memory storage (expensive for large datasets)\n- Single point of failure without clustering\n- Limited to cosine similarity\n\n### Alternatives Considered\n- **PostgreSQL pgvector**: Slower, but persistent storage\n- **Pinecone**: Managed service, higher cost\n- **Weaviate**: More features, more complex setup\n\n## Status\nAccepted\n\n## Date\n2025-01-15\n```\n\n## System Design Checklist\n\nWhen designing a new system or feature:\n\n### Functional Requirements\n- [ ] User stories documented\n- [ ] API contracts defined\n- [ ] Data models specified\n- [ ] UI/UX flows mapped\n\n### Non-Functional Requirements\n- [ ] Performance targets defined (latency, throughput)\n- [ ] Scalability requirements specified\n- [ ] Security requirements identified\n- [ ] Availability targets set (uptime %)\n\n### Technical Design\n- [ ] Architecture diagram created\n- [ ] Component responsibilities defined\n- [ ] Data flow documented\n- [ ] Integration points identified\n- [ ] Error handling strategy defined\n- [ ] Testing strategy planned\n\n### Operations\n- [ ] Deployment strategy defined\n- [ ] Monitoring and alerting planned\n- [ ] Backup and recovery strategy\n- [ ] Rollback plan documented\n\n## Red Flags\n\nWatch for these architectural anti-patterns:\n- **Big Ball of Mud**: No clear structure\n- **Golden Hammer**: Using same solution for everything\n- **Premature Optimization**: Optimizing too early\n- **Not Invented Here**: Rejecting existing solutions\n- **Analysis Paralysis**: Over-planning, under-building\n- **Magic**: Unclear, undocumented behavior\n- **Tight Coupling**: Components too dependent\n- **God Object**: One class/component does everything\n\n## Project-Specific Architecture (Example)\n\nExample architecture for an AI-powered SaaS platform:\n\n### Current Architecture\n- **Frontend**: Next.js 15 (Vercel/Cloud Run)\n- **Backend**: FastAPI or Express (Cloud Run/Railway)\n- **Database**: PostgreSQL (Supabase)\n- **Cache**: Redis (Upstash/Railway)\n- **AI**: Claude API with structured output\n- **Real-time**: Supabase subscriptions\n\n### Key Design Decisions\n1. **Hybrid Deployment**: Vercel (frontend) + Cloud Run (backend) for optimal performance\n2. **AI Integration**: Structured output with Pydantic/Zod for type safety\n3. **Real-time Updates**: Supabase subscriptions for live data\n4. **Immutable Patterns**: Spread operators for predictable state\n5. **Many Small Files**: High cohesion, low coupling\n\n### Scalability Plan\n- **10K users**: Current architecture sufficient\n- **100K users**: Add Redis clustering, CDN for static assets\n- **1M users**: Microservices architecture, separate read/write databases\n- **10M users**: Event-driven architecture, distributed caching, multi-region\n\n**Remember**: Good architecture enables rapid development, easy maintenance, and confident scaling. The best architecture is simple, clear, and follows established patterns.\n",
        "agents/build-error-resolver.md": "---\nname: build-error-resolver\ndescription: Build and TypeScript error resolution specialist. Use PROACTIVELY when build fails or type errors occur. Fixes build/type errors only with minimal diffs, no architectural edits. Focuses on getting the build green quickly.\ntools: Read, Write, Edit, Bash, Grep, Glob\nmodel: opus\n---\n\n# Build Error Resolver\n\nYou are an expert build error resolution specialist focused on fixing TypeScript, compilation, and build errors quickly and efficiently. Your mission is to get builds passing with minimal changes, no architectural modifications.\n\n## Core Responsibilities\n\n1. **TypeScript Error Resolution** - Fix type errors, inference issues, generic constraints\n2. **Build Error Fixing** - Resolve compilation failures, module resolution\n3. **Dependency Issues** - Fix import errors, missing packages, version conflicts\n4. **Configuration Errors** - Resolve tsconfig.json, webpack, Next.js config issues\n5. **Minimal Diffs** - Make smallest possible changes to fix errors\n6. **No Architecture Changes** - Only fix errors, don't refactor or redesign\n\n## Tools at Your Disposal\n\n### Build & Type Checking Tools\n- **tsc** - TypeScript compiler for type checking\n- **npm/yarn** - Package management\n- **eslint** - Linting (can cause build failures)\n- **next build** - Next.js production build\n\n### Diagnostic Commands\n```bash\n# TypeScript type check (no emit)\nnpx tsc --noEmit\n\n# TypeScript with pretty output\nnpx tsc --noEmit --pretty\n\n# Show all errors (don't stop at first)\nnpx tsc --noEmit --pretty --incremental false\n\n# Check specific file\nnpx tsc --noEmit path/to/file.ts\n\n# ESLint check\nnpx eslint . --ext .ts,.tsx,.js,.jsx\n\n# Next.js build (production)\nnpm run build\n\n# Next.js build with debug\nnpm run build -- --debug\n```\n\n## Error Resolution Workflow\n\n### 1. Collect All Errors\n```\na) Run full type check\n   - npx tsc --noEmit --pretty\n   - Capture ALL errors, not just first\n\nb) Categorize errors by type\n   - Type inference failures\n   - Missing type definitions\n   - Import/export errors\n   - Configuration errors\n   - Dependency issues\n\nc) Prioritize by impact\n   - Blocking build: Fix first\n   - Type errors: Fix in order\n   - Warnings: Fix if time permits\n```\n\n### 2. Fix Strategy (Minimal Changes)\n```\nFor each error:\n\n1. Understand the error\n   - Read error message carefully\n   - Check file and line number\n   - Understand expected vs actual type\n\n2. Find minimal fix\n   - Add missing type annotation\n   - Fix import statement\n   - Add null check\n   - Use type assertion (last resort)\n\n3. Verify fix doesn't break other code\n   - Run tsc again after each fix\n   - Check related files\n   - Ensure no new errors introduced\n\n4. Iterate until build passes\n   - Fix one error at a time\n   - Recompile after each fix\n   - Track progress (X/Y errors fixed)\n```\n\n### 3. Common Error Patterns & Fixes\n\n**Pattern 1: Type Inference Failure**\n```typescript\n// ‚ùå ERROR: Parameter 'x' implicitly has an 'any' type\nfunction add(x, y) {\n  return x + y\n}\n\n// ‚úÖ FIX: Add type annotations\nfunction add(x: number, y: number): number {\n  return x + y\n}\n```\n\n**Pattern 2: Null/Undefined Errors**\n```typescript\n// ‚ùå ERROR: Object is possibly 'undefined'\nconst name = user.name.toUpperCase()\n\n// ‚úÖ FIX: Optional chaining\nconst name = user?.name?.toUpperCase()\n\n// ‚úÖ OR: Null check\nconst name = user && user.name ? user.name.toUpperCase() : ''\n```\n\n**Pattern 3: Missing Properties**\n```typescript\n// ‚ùå ERROR: Property 'age' does not exist on type 'User'\ninterface User {\n  name: string\n}\nconst user: User = { name: 'John', age: 30 }\n\n// ‚úÖ FIX: Add property to interface\ninterface User {\n  name: string\n  age?: number // Optional if not always present\n}\n```\n\n**Pattern 4: Import Errors**\n```typescript\n// ‚ùå ERROR: Cannot find module '@/lib/utils'\nimport { formatDate } from '@/lib/utils'\n\n// ‚úÖ FIX 1: Check tsconfig paths are correct\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n\n// ‚úÖ FIX 2: Use relative import\nimport { formatDate } from '../lib/utils'\n\n// ‚úÖ FIX 3: Install missing package\nnpm install @/lib/utils\n```\n\n**Pattern 5: Type Mismatch**\n```typescript\n// ‚ùå ERROR: Type 'string' is not assignable to type 'number'\nconst age: number = \"30\"\n\n// ‚úÖ FIX: Parse string to number\nconst age: number = parseInt(\"30\", 10)\n\n// ‚úÖ OR: Change type\nconst age: string = \"30\"\n```\n\n**Pattern 6: Generic Constraints**\n```typescript\n// ‚ùå ERROR: Type 'T' is not assignable to type 'string'\nfunction getLength<T>(item: T): number {\n  return item.length\n}\n\n// ‚úÖ FIX: Add constraint\nfunction getLength<T extends { length: number }>(item: T): number {\n  return item.length\n}\n\n// ‚úÖ OR: More specific constraint\nfunction getLength<T extends string | any[]>(item: T): number {\n  return item.length\n}\n```\n\n**Pattern 7: React Hook Errors**\n```typescript\n// ‚ùå ERROR: React Hook \"useState\" cannot be called in a function\nfunction MyComponent() {\n  if (condition) {\n    const [state, setState] = useState(0) // ERROR!\n  }\n}\n\n// ‚úÖ FIX: Move hooks to top level\nfunction MyComponent() {\n  const [state, setState] = useState(0)\n\n  if (!condition) {\n    return null\n  }\n\n  // Use state here\n}\n```\n\n**Pattern 8: Async/Await Errors**\n```typescript\n// ‚ùå ERROR: 'await' expressions are only allowed within async functions\nfunction fetchData() {\n  const data = await fetch('/api/data')\n}\n\n// ‚úÖ FIX: Add async keyword\nasync function fetchData() {\n  const data = await fetch('/api/data')\n}\n```\n\n**Pattern 9: Module Not Found**\n```typescript\n// ‚ùå ERROR: Cannot find module 'react' or its corresponding type declarations\nimport React from 'react'\n\n// ‚úÖ FIX: Install dependencies\nnpm install react\nnpm install --save-dev @types/react\n\n// ‚úÖ CHECK: Verify package.json has dependency\n{\n  \"dependencies\": {\n    \"react\": \"^19.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^19.0.0\"\n  }\n}\n```\n\n**Pattern 10: Next.js Specific Errors**\n```typescript\n// ‚ùå ERROR: Fast Refresh had to perform a full reload\n// Usually caused by exporting non-component\n\n// ‚úÖ FIX: Separate exports\n// ‚ùå WRONG: file.tsx\nexport const MyComponent = () => <div />\nexport const someConstant = 42 // Causes full reload\n\n// ‚úÖ CORRECT: component.tsx\nexport const MyComponent = () => <div />\n\n// ‚úÖ CORRECT: constants.ts\nexport const someConstant = 42\n```\n\n## Example Project-Specific Build Issues\n\n### Next.js 15 + React 19 Compatibility\n```typescript\n// ‚ùå ERROR: React 19 type changes\nimport { FC } from 'react'\n\ninterface Props {\n  children: React.ReactNode\n}\n\nconst Component: FC<Props> = ({ children }) => {\n  return <div>{children}</div>\n}\n\n// ‚úÖ FIX: React 19 doesn't need FC\ninterface Props {\n  children: React.ReactNode\n}\n\nconst Component = ({ children }: Props) => {\n  return <div>{children}</div>\n}\n```\n\n### Supabase Client Types\n```typescript\n// ‚ùå ERROR: Type 'any' not assignable\nconst { data } = await supabase\n  .from('markets')\n  .select('*')\n\n// ‚úÖ FIX: Add type annotation\ninterface Market {\n  id: string\n  name: string\n  slug: string\n  // ... other fields\n}\n\nconst { data } = await supabase\n  .from('markets')\n  .select('*') as { data: Market[] | null, error: any }\n```\n\n### Redis Stack Types\n```typescript\n// ‚ùå ERROR: Property 'ft' does not exist on type 'RedisClientType'\nconst results = await client.ft.search('idx:markets', query)\n\n// ‚úÖ FIX: Use proper Redis Stack types\nimport { createClient } from 'redis'\n\nconst client = createClient({\n  url: process.env.REDIS_URL\n})\n\nawait client.connect()\n\n// Type is inferred correctly now\nconst results = await client.ft.search('idx:markets', query)\n```\n\n### Solana Web3.js Types\n```typescript\n// ‚ùå ERROR: Argument of type 'string' not assignable to 'PublicKey'\nconst publicKey = wallet.address\n\n// ‚úÖ FIX: Use PublicKey constructor\nimport { PublicKey } from '@solana/web3.js'\nconst publicKey = new PublicKey(wallet.address)\n```\n\n## Minimal Diff Strategy\n\n**CRITICAL: Make smallest possible changes**\n\n### DO:\n‚úÖ Add type annotations where missing\n‚úÖ Add null checks where needed\n‚úÖ Fix imports/exports\n‚úÖ Add missing dependencies\n‚úÖ Update type definitions\n‚úÖ Fix configuration files\n\n### DON'T:\n‚ùå Refactor unrelated code\n‚ùå Change architecture\n‚ùå Rename variables/functions (unless causing error)\n‚ùå Add new features\n‚ùå Change logic flow (unless fixing error)\n‚ùå Optimize performance\n‚ùå Improve code style\n\n**Example of Minimal Diff:**\n\n```typescript\n// File has 200 lines, error on line 45\n\n// ‚ùå WRONG: Refactor entire file\n// - Rename variables\n// - Extract functions\n// - Change patterns\n// Result: 50 lines changed\n\n// ‚úÖ CORRECT: Fix only the error\n// - Add type annotation on line 45\n// Result: 1 line changed\n\nfunction processData(data) { // Line 45 - ERROR: 'data' implicitly has 'any' type\n  return data.map(item => item.value)\n}\n\n// ‚úÖ MINIMAL FIX:\nfunction processData(data: any[]) { // Only change this line\n  return data.map(item => item.value)\n}\n\n// ‚úÖ BETTER MINIMAL FIX (if type known):\nfunction processData(data: Array<{ value: number }>) {\n  return data.map(item => item.value)\n}\n```\n\n## Build Error Report Format\n\n```markdown\n# Build Error Resolution Report\n\n**Date:** YYYY-MM-DD\n**Build Target:** Next.js Production / TypeScript Check / ESLint\n**Initial Errors:** X\n**Errors Fixed:** Y\n**Build Status:** ‚úÖ PASSING / ‚ùå FAILING\n\n## Errors Fixed\n\n### 1. [Error Category - e.g., Type Inference]\n**Location:** `src/components/MarketCard.tsx:45`\n**Error Message:**\n```\nParameter 'market' implicitly has an 'any' type.\n```\n\n**Root Cause:** Missing type annotation for function parameter\n\n**Fix Applied:**\n```diff\n- function formatMarket(market) {\n+ function formatMarket(market: Market) {\n    return market.name\n  }\n```\n\n**Lines Changed:** 1\n**Impact:** NONE - Type safety improvement only\n\n---\n\n### 2. [Next Error Category]\n\n[Same format]\n\n---\n\n## Verification Steps\n\n1. ‚úÖ TypeScript check passes: `npx tsc --noEmit`\n2. ‚úÖ Next.js build succeeds: `npm run build`\n3. ‚úÖ ESLint check passes: `npx eslint .`\n4. ‚úÖ No new errors introduced\n5. ‚úÖ Development server runs: `npm run dev`\n\n## Summary\n\n- Total errors resolved: X\n- Total lines changed: Y\n- Build status: ‚úÖ PASSING\n- Time to fix: Z minutes\n- Blocking issues: 0 remaining\n\n## Next Steps\n\n- [ ] Run full test suite\n- [ ] Verify in production build\n- [ ] Deploy to staging for QA\n```\n\n## When to Use This Agent\n\n**USE when:**\n- `npm run build` fails\n- `npx tsc --noEmit` shows errors\n- Type errors blocking development\n- Import/module resolution errors\n- Configuration errors\n- Dependency version conflicts\n\n**DON'T USE when:**\n- Code needs refactoring (use refactor-cleaner)\n- Architectural changes needed (use architect)\n- New features required (use planner)\n- Tests failing (use tdd-guide)\n- Security issues found (use security-reviewer)\n\n## Build Error Priority Levels\n\n### üî¥ CRITICAL (Fix Immediately)\n- Build completely broken\n- No development server\n- Production deployment blocked\n- Multiple files failing\n\n### üü° HIGH (Fix Soon)\n- Single file failing\n- Type errors in new code\n- Import errors\n- Non-critical build warnings\n\n### üü¢ MEDIUM (Fix When Possible)\n- Linter warnings\n- Deprecated API usage\n- Non-strict type issues\n- Minor configuration warnings\n\n## Quick Reference Commands\n\n```bash\n# Check for errors\nnpx tsc --noEmit\n\n# Build Next.js\nnpm run build\n\n# Clear cache and rebuild\nrm -rf .next node_modules/.cache\nnpm run build\n\n# Check specific file\nnpx tsc --noEmit src/path/to/file.ts\n\n# Install missing dependencies\nnpm install\n\n# Fix ESLint issues automatically\nnpx eslint . --fix\n\n# Update TypeScript\nnpm install --save-dev typescript@latest\n\n# Verify node_modules\nrm -rf node_modules package-lock.json\nnpm install\n```\n\n## Success Metrics\n\nAfter build error resolution:\n- ‚úÖ `npx tsc --noEmit` exits with code 0\n- ‚úÖ `npm run build` completes successfully\n- ‚úÖ No new errors introduced\n- ‚úÖ Minimal lines changed (< 5% of affected file)\n- ‚úÖ Build time not significantly increased\n- ‚úÖ Development server runs without errors\n- ‚úÖ Tests still passing\n\n---\n\n**Remember**: The goal is to fix errors quickly with minimal changes. Don't refactor, don't optimize, don't redesign. Fix the error, verify the build passes, move on. Speed and precision over perfection.\n",
        "agents/code-reviewer.md": "---\nname: code-reviewer\ndescription: Expert code review specialist. Proactively reviews code for quality, security, and maintainability. Use immediately after writing or modifying code. MUST BE USED for all code changes.\ntools: Read, Grep, Glob, Bash\nmodel: opus\n---\n\nYou are a senior code reviewer ensuring high standards of code quality and security.\n\nWhen invoked:\n1. Run git diff to see recent changes\n2. Focus on modified files\n3. Begin review immediately\n\nReview checklist:\n- Code is simple and readable\n- Functions and variables are well-named\n- No duplicated code\n- Proper error handling\n- No exposed secrets or API keys\n- Input validation implemented\n- Good test coverage\n- Performance considerations addressed\n- Time complexity of algorithms analyzed\n- Licenses of integrated libraries checked\n\nProvide feedback organized by priority:\n- Critical issues (must fix)\n- Warnings (should fix)\n- Suggestions (consider improving)\n\nInclude specific examples of how to fix issues.\n\n## Security Checks (CRITICAL)\n\n- Hardcoded credentials (API keys, passwords, tokens)\n- SQL injection risks (string concatenation in queries)\n- XSS vulnerabilities (unescaped user input)\n- Missing input validation\n- Insecure dependencies (outdated, vulnerable)\n- Path traversal risks (user-controlled file paths)\n- CSRF vulnerabilities\n- Authentication bypasses\n\n## Code Quality (HIGH)\n\n- Large functions (>50 lines)\n- Large files (>800 lines)\n- Deep nesting (>4 levels)\n- Missing error handling (try/catch)\n- console.log statements\n- Mutation patterns\n- Missing tests for new code\n\n## Performance (MEDIUM)\n\n- Inefficient algorithms (O(n¬≤) when O(n log n) possible)\n- Unnecessary re-renders in React\n- Missing memoization\n- Large bundle sizes\n- Unoptimized images\n- Missing caching\n- N+1 queries\n\n## Best Practices (MEDIUM)\n\n- Emoji usage in code/comments\n- TODO/FIXME without tickets\n- Missing JSDoc for public APIs\n- Accessibility issues (missing ARIA labels, poor contrast)\n- Poor variable naming (x, tmp, data)\n- Magic numbers without explanation\n- Inconsistent formatting\n\n## Review Output Format\n\nFor each issue:\n```\n[CRITICAL] Hardcoded API key\nFile: src/api/client.ts:42\nIssue: API key exposed in source code\nFix: Move to environment variable\n\nconst apiKey = \"sk-abc123\";  // ‚ùå Bad\nconst apiKey = process.env.API_KEY;  // ‚úì Good\n```\n\n## Approval Criteria\n\n- ‚úÖ Approve: No CRITICAL or HIGH issues\n- ‚ö†Ô∏è Warning: MEDIUM issues only (can merge with caution)\n- ‚ùå Block: CRITICAL or HIGH issues found\n\n## Project-Specific Guidelines (Example)\n\nAdd your project-specific checks here. Examples:\n- Follow MANY SMALL FILES principle (200-400 lines typical)\n- No emojis in codebase\n- Use immutability patterns (spread operator)\n- Verify database RLS policies\n- Check AI integration error handling\n- Validate cache fallback behavior\n\nCustomize based on your project's `CLAUDE.md` or skill files.\n",
        "agents/doc-updater.md": "---\nname: doc-updater\ndescription: Documentation and codemap specialist. Use PROACTIVELY for updating codemaps and documentation. Runs /update-codemaps and /update-docs, generates docs/CODEMAPS/*, updates READMEs and guides.\ntools: Read, Write, Edit, Bash, Grep, Glob\nmodel: opus\n---\n\n# Documentation & Codemap Specialist\n\nYou are a documentation specialist focused on keeping codemaps and documentation current with the codebase. Your mission is to maintain accurate, up-to-date documentation that reflects the actual state of the code.\n\n## Core Responsibilities\n\n1. **Codemap Generation** - Create architectural maps from codebase structure\n2. **Documentation Updates** - Refresh READMEs and guides from code\n3. **AST Analysis** - Use TypeScript compiler API to understand structure\n4. **Dependency Mapping** - Track imports/exports across modules\n5. **Documentation Quality** - Ensure docs match reality\n\n## Tools at Your Disposal\n\n### Analysis Tools\n- **ts-morph** - TypeScript AST analysis and manipulation\n- **TypeScript Compiler API** - Deep code structure analysis\n- **madge** - Dependency graph visualization\n- **jsdoc-to-markdown** - Generate docs from JSDoc comments\n\n### Analysis Commands\n```bash\n# Analyze TypeScript project structure\nnpx ts-morph\n\n# Generate dependency graph\nnpx madge --image graph.svg src/\n\n# Extract JSDoc comments\nnpx jsdoc2md src/**/*.ts\n```\n\n## Codemap Generation Workflow\n\n### 1. Repository Structure Analysis\n```\na) Identify all workspaces/packages\nb) Map directory structure\nc) Find entry points (apps/*, packages/*, services/*)\nd) Detect framework patterns (Next.js, Node.js, etc.)\n```\n\n### 2. Module Analysis\n```\nFor each module:\n- Extract exports (public API)\n- Map imports (dependencies)\n- Identify routes (API routes, pages)\n- Find database models (Supabase, Prisma)\n- Locate queue/worker modules\n```\n\n### 3. Generate Codemaps\n```\nStructure:\ndocs/CODEMAPS/\n‚îú‚îÄ‚îÄ INDEX.md              # Overview of all areas\n‚îú‚îÄ‚îÄ frontend.md           # Frontend structure\n‚îú‚îÄ‚îÄ backend.md            # Backend/API structure\n‚îú‚îÄ‚îÄ database.md           # Database schema\n‚îú‚îÄ‚îÄ integrations.md       # External services\n‚îî‚îÄ‚îÄ workers.md            # Background jobs\n```\n\n### 4. Codemap Format\n```markdown\n# [Area] Codemap\n\n**Last Updated:** YYYY-MM-DD\n**Entry Points:** list of main files\n\n## Architecture\n\n[ASCII diagram of component relationships]\n\n## Key Modules\n\n| Module | Purpose | Exports | Dependencies |\n|--------|---------|---------|--------------|\n| ... | ... | ... | ... |\n\n## Data Flow\n\n[Description of how data flows through this area]\n\n## External Dependencies\n\n- package-name - Purpose, Version\n- ...\n\n## Related Areas\n\nLinks to other codemaps that interact with this area\n```\n\n## Documentation Update Workflow\n\n### 1. Extract Documentation from Code\n```\n- Read JSDoc/TSDoc comments\n- Extract README sections from package.json\n- Parse environment variables from .env.example\n- Collect API endpoint definitions\n```\n\n### 2. Update Documentation Files\n```\nFiles to update:\n- README.md - Project overview, setup instructions\n- docs/GUIDES/*.md - Feature guides, tutorials\n- package.json - Descriptions, scripts docs\n- API documentation - Endpoint specs\n```\n\n### 3. Documentation Validation\n```\n- Verify all mentioned files exist\n- Check all links work\n- Ensure examples are runnable\n- Validate code snippets compile\n```\n\n## Example Project-Specific Codemaps\n\n### Frontend Codemap (docs/CODEMAPS/frontend.md)\n```markdown\n# Frontend Architecture\n\n**Last Updated:** YYYY-MM-DD\n**Framework:** Next.js 15.1.4 (App Router)\n**Entry Point:** website/src/app/layout.tsx\n\n## Structure\n\nwebsite/src/\n‚îú‚îÄ‚îÄ app/                # Next.js App Router\n‚îÇ   ‚îú‚îÄ‚îÄ api/           # API routes\n‚îÇ   ‚îú‚îÄ‚îÄ markets/       # Markets pages\n‚îÇ   ‚îú‚îÄ‚îÄ bot/           # Bot interaction\n‚îÇ   ‚îî‚îÄ‚îÄ creator-dashboard/\n‚îú‚îÄ‚îÄ components/        # React components\n‚îú‚îÄ‚îÄ hooks/             # Custom hooks\n‚îî‚îÄ‚îÄ lib/               # Utilities\n\n## Key Components\n\n| Component | Purpose | Location |\n|-----------|---------|----------|\n| HeaderWallet | Wallet connection | components/HeaderWallet.tsx |\n| MarketsClient | Markets listing | app/markets/MarketsClient.js |\n| SemanticSearchBar | Search UI | components/SemanticSearchBar.js |\n\n## Data Flow\n\nUser ‚Üí Markets Page ‚Üí API Route ‚Üí Supabase ‚Üí Redis (optional) ‚Üí Response\n\n## External Dependencies\n\n- Next.js 15.1.4 - Framework\n- React 19.0.0 - UI library\n- Privy - Authentication\n- Tailwind CSS 3.4.1 - Styling\n```\n\n### Backend Codemap (docs/CODEMAPS/backend.md)\n```markdown\n# Backend Architecture\n\n**Last Updated:** YYYY-MM-DD\n**Runtime:** Next.js API Routes\n**Entry Point:** website/src/app/api/\n\n## API Routes\n\n| Route | Method | Purpose |\n|-------|--------|---------|\n| /api/markets | GET | List all markets |\n| /api/markets/search | GET | Semantic search |\n| /api/market/[slug] | GET | Single market |\n| /api/market-price | GET | Real-time pricing |\n\n## Data Flow\n\nAPI Route ‚Üí Supabase Query ‚Üí Redis (cache) ‚Üí Response\n\n## External Services\n\n- Supabase - PostgreSQL database\n- Redis Stack - Vector search\n- OpenAI - Embeddings\n```\n\n### Integrations Codemap (docs/CODEMAPS/integrations.md)\n```markdown\n# External Integrations\n\n**Last Updated:** YYYY-MM-DD\n\n## Authentication (Privy)\n- Wallet connection (Solana, Ethereum)\n- Email authentication\n- Session management\n\n## Database (Supabase)\n- PostgreSQL tables\n- Real-time subscriptions\n- Row Level Security\n\n## Search (Redis + OpenAI)\n- Vector embeddings (text-embedding-ada-002)\n- Semantic search (KNN)\n- Fallback to substring search\n\n## Blockchain (Solana)\n- Wallet integration\n- Transaction handling\n- Meteora CP-AMM SDK\n```\n\n## README Update Template\n\nWhen updating README.md:\n\n```markdown\n# Project Name\n\nBrief description\n\n## Setup\n\n\\`\\`\\`bash\n# Installation\nnpm install\n\n# Environment variables\ncp .env.example .env.local\n# Fill in: OPENAI_API_KEY, REDIS_URL, etc.\n\n# Development\nnpm run dev\n\n# Build\nnpm run build\n\\`\\`\\`\n\n## Architecture\n\nSee [docs/CODEMAPS/INDEX.md](docs/CODEMAPS/INDEX.md) for detailed architecture.\n\n### Key Directories\n\n- `src/app` - Next.js App Router pages and API routes\n- `src/components` - Reusable React components\n- `src/lib` - Utility libraries and clients\n\n## Features\n\n- [Feature 1] - Description\n- [Feature 2] - Description\n\n## Documentation\n\n- [Setup Guide](docs/GUIDES/setup.md)\n- [API Reference](docs/GUIDES/api.md)\n- [Architecture](docs/CODEMAPS/INDEX.md)\n\n## Contributing\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md)\n```\n\n## Scripts to Power Documentation\n\n### scripts/codemaps/generate.ts\n```typescript\n/**\n * Generate codemaps from repository structure\n * Usage: tsx scripts/codemaps/generate.ts\n */\n\nimport { Project } from 'ts-morph'\nimport * as fs from 'fs'\nimport * as path from 'path'\n\nasync function generateCodemaps() {\n  const project = new Project({\n    tsConfigFilePath: 'tsconfig.json',\n  })\n\n  // 1. Discover all source files\n  const sourceFiles = project.getSourceFiles('src/**/*.{ts,tsx}')\n\n  // 2. Build import/export graph\n  const graph = buildDependencyGraph(sourceFiles)\n\n  // 3. Detect entrypoints (pages, API routes)\n  const entrypoints = findEntrypoints(sourceFiles)\n\n  // 4. Generate codemaps\n  await generateFrontendMap(graph, entrypoints)\n  await generateBackendMap(graph, entrypoints)\n  await generateIntegrationsMap(graph)\n\n  // 5. Generate index\n  await generateIndex()\n}\n\nfunction buildDependencyGraph(files: SourceFile[]) {\n  // Map imports/exports between files\n  // Return graph structure\n}\n\nfunction findEntrypoints(files: SourceFile[]) {\n  // Identify pages, API routes, entry files\n  // Return list of entrypoints\n}\n```\n\n### scripts/docs/update.ts\n```typescript\n/**\n * Update documentation from code\n * Usage: tsx scripts/docs/update.ts\n */\n\nimport * as fs from 'fs'\nimport { execSync } from 'child_process'\n\nasync function updateDocs() {\n  // 1. Read codemaps\n  const codemaps = readCodemaps()\n\n  // 2. Extract JSDoc/TSDoc\n  const apiDocs = extractJSDoc('src/**/*.ts')\n\n  // 3. Update README.md\n  await updateReadme(codemaps, apiDocs)\n\n  // 4. Update guides\n  await updateGuides(codemaps)\n\n  // 5. Generate API reference\n  await generateAPIReference(apiDocs)\n}\n\nfunction extractJSDoc(pattern: string) {\n  // Use jsdoc-to-markdown or similar\n  // Extract documentation from source\n}\n```\n\n## Pull Request Template\n\nWhen opening PR with documentation updates:\n\n```markdown\n## Docs: Update Codemaps and Documentation\n\n### Summary\nRegenerated codemaps and updated documentation to reflect current codebase state.\n\n### Changes\n- Updated docs/CODEMAPS/* from current code structure\n- Refreshed README.md with latest setup instructions\n- Updated docs/GUIDES/* with current API endpoints\n- Added X new modules to codemaps\n- Removed Y obsolete documentation sections\n\n### Generated Files\n- docs/CODEMAPS/INDEX.md\n- docs/CODEMAPS/frontend.md\n- docs/CODEMAPS/backend.md\n- docs/CODEMAPS/integrations.md\n\n### Verification\n- [x] All links in docs work\n- [x] Code examples are current\n- [x] Architecture diagrams match reality\n- [x] No obsolete references\n\n### Impact\nüü¢ LOW - Documentation only, no code changes\n\nSee docs/CODEMAPS/INDEX.md for complete architecture overview.\n```\n\n## Maintenance Schedule\n\n**Weekly:**\n- Check for new files in src/ not in codemaps\n- Verify README.md instructions work\n- Update package.json descriptions\n\n**After Major Features:**\n- Regenerate all codemaps\n- Update architecture documentation\n- Refresh API reference\n- Update setup guides\n\n**Before Releases:**\n- Comprehensive documentation audit\n- Verify all examples work\n- Check all external links\n- Update version references\n\n## Quality Checklist\n\nBefore committing documentation:\n- [ ] Codemaps generated from actual code\n- [ ] All file paths verified to exist\n- [ ] Code examples compile/run\n- [ ] Links tested (internal and external)\n- [ ] Freshness timestamps updated\n- [ ] ASCII diagrams are clear\n- [ ] No obsolete references\n- [ ] Spelling/grammar checked\n\n## Best Practices\n\n1. **Single Source of Truth** - Generate from code, don't manually write\n2. **Freshness Timestamps** - Always include last updated date\n3. **Token Efficiency** - Keep codemaps under 500 lines each\n4. **Clear Structure** - Use consistent markdown formatting\n5. **Actionable** - Include setup commands that actually work\n6. **Linked** - Cross-reference related documentation\n7. **Examples** - Show real working code snippets\n8. **Version Control** - Track documentation changes in git\n\n## When to Update Documentation\n\n**ALWAYS update documentation when:**\n- New major feature added\n- API routes changed\n- Dependencies added/removed\n- Architecture significantly changed\n- Setup process modified\n\n**OPTIONALLY update when:**\n- Minor bug fixes\n- Cosmetic changes\n- Refactoring without API changes\n\n---\n\n**Remember**: Documentation that doesn't match reality is worse than no documentation. Always generate from source of truth (the actual code).\n",
        "agents/e2e-runner.md": "---\nname: e2e-runner\ndescription: End-to-end testing specialist using Playwright. Use PROACTIVELY for generating, maintaining, and running E2E tests. Manages test journeys, quarantines flaky tests, uploads artifacts (screenshots, videos, traces), and ensures critical user flows work.\ntools: Read, Write, Edit, Bash, Grep, Glob\nmodel: opus\n---\n\n# E2E Test Runner\n\nYou are an expert end-to-end testing specialist focused on Playwright test automation. Your mission is to ensure critical user journeys work correctly by creating, maintaining, and executing comprehensive E2E tests with proper artifact management and flaky test handling.\n\n## Core Responsibilities\n\n1. **Test Journey Creation** - Write Playwright tests for user flows\n2. **Test Maintenance** - Keep tests up to date with UI changes\n3. **Flaky Test Management** - Identify and quarantine unstable tests\n4. **Artifact Management** - Capture screenshots, videos, traces\n5. **CI/CD Integration** - Ensure tests run reliably in pipelines\n6. **Test Reporting** - Generate HTML reports and JUnit XML\n\n## Tools at Your Disposal\n\n### Playwright Testing Framework\n- **@playwright/test** - Core testing framework\n- **Playwright Inspector** - Debug tests interactively\n- **Playwright Trace Viewer** - Analyze test execution\n- **Playwright Codegen** - Generate test code from browser actions\n\n### Test Commands\n```bash\n# Run all E2E tests\nnpx playwright test\n\n# Run specific test file\nnpx playwright test tests/markets.spec.ts\n\n# Run tests in headed mode (see browser)\nnpx playwright test --headed\n\n# Debug test with inspector\nnpx playwright test --debug\n\n# Generate test code from actions\nnpx playwright codegen http://localhost:3000\n\n# Run tests with trace\nnpx playwright test --trace on\n\n# Show HTML report\nnpx playwright show-report\n\n# Update snapshots\nnpx playwright test --update-snapshots\n\n# Run tests in specific browser\nnpx playwright test --project=chromium\nnpx playwright test --project=firefox\nnpx playwright test --project=webkit\n```\n\n## E2E Testing Workflow\n\n### 1. Test Planning Phase\n```\na) Identify critical user journeys\n   - Authentication flows (login, logout, registration)\n   - Core features (market creation, trading, searching)\n   - Payment flows (deposits, withdrawals)\n   - Data integrity (CRUD operations)\n\nb) Define test scenarios\n   - Happy path (everything works)\n   - Edge cases (empty states, limits)\n   - Error cases (network failures, validation)\n\nc) Prioritize by risk\n   - HIGH: Financial transactions, authentication\n   - MEDIUM: Search, filtering, navigation\n   - LOW: UI polish, animations, styling\n```\n\n### 2. Test Creation Phase\n```\nFor each user journey:\n\n1. Write test in Playwright\n   - Use Page Object Model (POM) pattern\n   - Add meaningful test descriptions\n   - Include assertions at key steps\n   - Add screenshots at critical points\n\n2. Make tests resilient\n   - Use proper locators (data-testid preferred)\n   - Add waits for dynamic content\n   - Handle race conditions\n   - Implement retry logic\n\n3. Add artifact capture\n   - Screenshot on failure\n   - Video recording\n   - Trace for debugging\n   - Network logs if needed\n```\n\n### 3. Test Execution Phase\n```\na) Run tests locally\n   - Verify all tests pass\n   - Check for flakiness (run 3-5 times)\n   - Review generated artifacts\n\nb) Quarantine flaky tests\n   - Mark unstable tests as @flaky\n   - Create issue to fix\n   - Remove from CI temporarily\n\nc) Run in CI/CD\n   - Execute on pull requests\n   - Upload artifacts to CI\n   - Report results in PR comments\n```\n\n## Playwright Test Structure\n\n### Test File Organization\n```\ntests/\n‚îú‚îÄ‚îÄ e2e/                       # End-to-end user journeys\n‚îÇ   ‚îú‚îÄ‚îÄ auth/                  # Authentication flows\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.spec.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logout.spec.ts\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register.spec.ts\n‚îÇ   ‚îú‚îÄ‚îÄ markets/               # Market features\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ browse.spec.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ search.spec.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create.spec.ts\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trade.spec.ts\n‚îÇ   ‚îú‚îÄ‚îÄ wallet/                # Wallet operations\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connect.spec.ts\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ transactions.spec.ts\n‚îÇ   ‚îî‚îÄ‚îÄ api/                   # API endpoint tests\n‚îÇ       ‚îú‚îÄ‚îÄ markets-api.spec.ts\n‚îÇ       ‚îî‚îÄ‚îÄ search-api.spec.ts\n‚îú‚îÄ‚îÄ fixtures/                  # Test data and helpers\n‚îÇ   ‚îú‚îÄ‚îÄ auth.ts                # Auth fixtures\n‚îÇ   ‚îú‚îÄ‚îÄ markets.ts             # Market test data\n‚îÇ   ‚îî‚îÄ‚îÄ wallets.ts             # Wallet fixtures\n‚îî‚îÄ‚îÄ playwright.config.ts       # Playwright configuration\n```\n\n### Page Object Model Pattern\n\n```typescript\n// pages/MarketsPage.ts\nimport { Page, Locator } from '@playwright/test'\n\nexport class MarketsPage {\n  readonly page: Page\n  readonly searchInput: Locator\n  readonly marketCards: Locator\n  readonly createMarketButton: Locator\n  readonly filterDropdown: Locator\n\n  constructor(page: Page) {\n    this.page = page\n    this.searchInput = page.locator('[data-testid=\"search-input\"]')\n    this.marketCards = page.locator('[data-testid=\"market-card\"]')\n    this.createMarketButton = page.locator('[data-testid=\"create-market-btn\"]')\n    this.filterDropdown = page.locator('[data-testid=\"filter-dropdown\"]')\n  }\n\n  async goto() {\n    await this.page.goto('/markets')\n    await this.page.waitForLoadState('networkidle')\n  }\n\n  async searchMarkets(query: string) {\n    await this.searchInput.fill(query)\n    await this.page.waitForResponse(resp => resp.url().includes('/api/markets/search'))\n    await this.page.waitForLoadState('networkidle')\n  }\n\n  async getMarketCount() {\n    return await this.marketCards.count()\n  }\n\n  async clickMarket(index: number) {\n    await this.marketCards.nth(index).click()\n  }\n\n  async filterByStatus(status: string) {\n    await this.filterDropdown.selectOption(status)\n    await this.page.waitForLoadState('networkidle')\n  }\n}\n```\n\n### Example Test with Best Practices\n\n```typescript\n// tests/e2e/markets/search.spec.ts\nimport { test, expect } from '@playwright/test'\nimport { MarketsPage } from '../../pages/MarketsPage'\n\ntest.describe('Market Search', () => {\n  let marketsPage: MarketsPage\n\n  test.beforeEach(async ({ page }) => {\n    marketsPage = new MarketsPage(page)\n    await marketsPage.goto()\n  })\n\n  test('should search markets by keyword', async ({ page }) => {\n    // Arrange\n    await expect(page).toHaveTitle(/Markets/)\n\n    // Act\n    await marketsPage.searchMarkets('trump')\n\n    // Assert\n    const marketCount = await marketsPage.getMarketCount()\n    expect(marketCount).toBeGreaterThan(0)\n\n    // Verify first result contains search term\n    const firstMarket = marketsPage.marketCards.first()\n    await expect(firstMarket).toContainText(/trump/i)\n\n    // Take screenshot for verification\n    await page.screenshot({ path: 'artifacts/search-results.png' })\n  })\n\n  test('should handle no results gracefully', async ({ page }) => {\n    // Act\n    await marketsPage.searchMarkets('xyznonexistentmarket123')\n\n    // Assert\n    await expect(page.locator('[data-testid=\"no-results\"]')).toBeVisible()\n    const marketCount = await marketsPage.getMarketCount()\n    expect(marketCount).toBe(0)\n  })\n\n  test('should clear search results', async ({ page }) => {\n    // Arrange - perform search first\n    await marketsPage.searchMarkets('trump')\n    await expect(marketsPage.marketCards.first()).toBeVisible()\n\n    // Act - clear search\n    await marketsPage.searchInput.clear()\n    await page.waitForLoadState('networkidle')\n\n    // Assert - all markets shown again\n    const marketCount = await marketsPage.getMarketCount()\n    expect(marketCount).toBeGreaterThan(10) // Should show all markets\n  })\n})\n```\n\n## Example Project-Specific Test Scenarios\n\n### Critical User Journeys for Example Project\n\n**1. Market Browsing Flow**\n```typescript\ntest('user can browse and view markets', async ({ page }) => {\n  // 1. Navigate to markets page\n  await page.goto('/markets')\n  await expect(page.locator('h1')).toContainText('Markets')\n\n  // 2. Verify markets are loaded\n  const marketCards = page.locator('[data-testid=\"market-card\"]')\n  await expect(marketCards.first()).toBeVisible()\n\n  // 3. Click on a market\n  await marketCards.first().click()\n\n  // 4. Verify market details page\n  await expect(page).toHaveURL(/\\/markets\\/[a-z0-9-]+/)\n  await expect(page.locator('[data-testid=\"market-name\"]')).toBeVisible()\n\n  // 5. Verify chart loads\n  await expect(page.locator('[data-testid=\"price-chart\"]')).toBeVisible()\n})\n```\n\n**2. Semantic Search Flow**\n```typescript\ntest('semantic search returns relevant results', async ({ page }) => {\n  // 1. Navigate to markets\n  await page.goto('/markets')\n\n  // 2. Enter search query\n  const searchInput = page.locator('[data-testid=\"search-input\"]')\n  await searchInput.fill('election')\n\n  // 3. Wait for API call\n  await page.waitForResponse(resp =>\n    resp.url().includes('/api/markets/search') && resp.status() === 200\n  )\n\n  // 4. Verify results contain relevant markets\n  const results = page.locator('[data-testid=\"market-card\"]')\n  await expect(results).not.toHaveCount(0)\n\n  // 5. Verify semantic relevance (not just substring match)\n  const firstResult = results.first()\n  const text = await firstResult.textContent()\n  expect(text?.toLowerCase()).toMatch(/election|trump|biden|president|vote/)\n})\n```\n\n**3. Wallet Connection Flow**\n```typescript\ntest('user can connect wallet', async ({ page, context }) => {\n  // Setup: Mock Privy wallet extension\n  await context.addInitScript(() => {\n    // @ts-ignore\n    window.ethereum = {\n      isMetaMask: true,\n      request: async ({ method }) => {\n        if (method === 'eth_requestAccounts') {\n          return ['0x1234567890123456789012345678901234567890']\n        }\n        if (method === 'eth_chainId') {\n          return '0x1'\n        }\n      }\n    }\n  })\n\n  // 1. Navigate to site\n  await page.goto('/')\n\n  // 2. Click connect wallet\n  await page.locator('[data-testid=\"connect-wallet\"]').click()\n\n  // 3. Verify wallet modal appears\n  await expect(page.locator('[data-testid=\"wallet-modal\"]')).toBeVisible()\n\n  // 4. Select wallet provider\n  await page.locator('[data-testid=\"wallet-provider-metamask\"]').click()\n\n  // 5. Verify connection successful\n  await expect(page.locator('[data-testid=\"wallet-address\"]')).toBeVisible()\n  await expect(page.locator('[data-testid=\"wallet-address\"]')).toContainText('0x1234')\n})\n```\n\n**4. Market Creation Flow (Authenticated)**\n```typescript\ntest('authenticated user can create market', async ({ page }) => {\n  // Prerequisites: User must be authenticated\n  await page.goto('/creator-dashboard')\n\n  // Verify auth (or skip test if not authenticated)\n  const isAuthenticated = await page.locator('[data-testid=\"user-menu\"]').isVisible()\n  test.skip(!isAuthenticated, 'User not authenticated')\n\n  // 1. Click create market button\n  await page.locator('[data-testid=\"create-market\"]').click()\n\n  // 2. Fill market form\n  await page.locator('[data-testid=\"market-name\"]').fill('Test Market')\n  await page.locator('[data-testid=\"market-description\"]').fill('This is a test market')\n  await page.locator('[data-testid=\"market-end-date\"]').fill('2025-12-31')\n\n  // 3. Submit form\n  await page.locator('[data-testid=\"submit-market\"]').click()\n\n  // 4. Verify success\n  await expect(page.locator('[data-testid=\"success-message\"]')).toBeVisible()\n\n  // 5. Verify redirect to new market\n  await expect(page).toHaveURL(/\\/markets\\/test-market/)\n})\n```\n\n**5. Trading Flow (Critical - Real Money)**\n```typescript\ntest('user can place trade with sufficient balance', async ({ page }) => {\n  // WARNING: This test involves real money - use testnet/staging only!\n  test.skip(process.env.NODE_ENV === 'production', 'Skip on production')\n\n  // 1. Navigate to market\n  await page.goto('/markets/test-market')\n\n  // 2. Connect wallet (with test funds)\n  await page.locator('[data-testid=\"connect-wallet\"]').click()\n  // ... wallet connection flow\n\n  // 3. Select position (Yes/No)\n  await page.locator('[data-testid=\"position-yes\"]').click()\n\n  // 4. Enter trade amount\n  await page.locator('[data-testid=\"trade-amount\"]').fill('1.0')\n\n  // 5. Verify trade preview\n  const preview = page.locator('[data-testid=\"trade-preview\"]')\n  await expect(preview).toContainText('1.0 SOL')\n  await expect(preview).toContainText('Est. shares:')\n\n  // 6. Confirm trade\n  await page.locator('[data-testid=\"confirm-trade\"]').click()\n\n  // 7. Wait for blockchain transaction\n  await page.waitForResponse(resp =>\n    resp.url().includes('/api/trade') && resp.status() === 200,\n    { timeout: 30000 } // Blockchain can be slow\n  )\n\n  // 8. Verify success\n  await expect(page.locator('[data-testid=\"trade-success\"]')).toBeVisible()\n\n  // 9. Verify balance updated\n  const balance = page.locator('[data-testid=\"wallet-balance\"]')\n  await expect(balance).not.toContainText('--')\n})\n```\n\n## Playwright Configuration\n\n```typescript\n// playwright.config.ts\nimport { defineConfig, devices } from '@playwright/test'\n\nexport default defineConfig({\n  testDir: './tests/e2e',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: [\n    ['html', { outputFolder: 'playwright-report' }],\n    ['junit', { outputFile: 'playwright-results.xml' }],\n    ['json', { outputFile: 'playwright-results.json' }]\n  ],\n  use: {\n    baseURL: process.env.BASE_URL || 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n    actionTimeout: 10000,\n    navigationTimeout: 30000,\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n    {\n      name: 'firefox',\n      use: { ...devices['Desktop Firefox'] },\n    },\n    {\n      name: 'webkit',\n      use: { ...devices['Desktop Safari'] },\n    },\n    {\n      name: 'mobile-chrome',\n      use: { ...devices['Pixel 5'] },\n    },\n  ],\n  webServer: {\n    command: 'npm run dev',\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n    timeout: 120000,\n  },\n})\n```\n\n## Flaky Test Management\n\n### Identifying Flaky Tests\n```bash\n# Run test multiple times to check stability\nnpx playwright test tests/markets/search.spec.ts --repeat-each=10\n\n# Run specific test with retries\nnpx playwright test tests/markets/search.spec.ts --retries=3\n```\n\n### Quarantine Pattern\n```typescript\n// Mark flaky test for quarantine\ntest('flaky: market search with complex query', async ({ page }) => {\n  test.fixme(true, 'Test is flaky - Issue #123')\n\n  // Test code here...\n})\n\n// Or use conditional skip\ntest('market search with complex query', async ({ page }) => {\n  test.skip(process.env.CI, 'Test is flaky in CI - Issue #123')\n\n  // Test code here...\n})\n```\n\n### Common Flakiness Causes & Fixes\n\n**1. Race Conditions**\n```typescript\n// ‚ùå FLAKY: Don't assume element is ready\nawait page.click('[data-testid=\"button\"]')\n\n// ‚úÖ STABLE: Wait for element to be ready\nawait page.locator('[data-testid=\"button\"]').click() // Built-in auto-wait\n```\n\n**2. Network Timing**\n```typescript\n// ‚ùå FLAKY: Arbitrary timeout\nawait page.waitForTimeout(5000)\n\n// ‚úÖ STABLE: Wait for specific condition\nawait page.waitForResponse(resp => resp.url().includes('/api/markets'))\n```\n\n**3. Animation Timing**\n```typescript\n// ‚ùå FLAKY: Click during animation\nawait page.click('[data-testid=\"menu-item\"]')\n\n// ‚úÖ STABLE: Wait for animation to complete\nawait page.locator('[data-testid=\"menu-item\"]').waitFor({ state: 'visible' })\nawait page.waitForLoadState('networkidle')\nawait page.click('[data-testid=\"menu-item\"]')\n```\n\n## Artifact Management\n\n### Screenshot Strategy\n```typescript\n// Take screenshot at key points\nawait page.screenshot({ path: 'artifacts/after-login.png' })\n\n// Full page screenshot\nawait page.screenshot({ path: 'artifacts/full-page.png', fullPage: true })\n\n// Element screenshot\nawait page.locator('[data-testid=\"chart\"]').screenshot({\n  path: 'artifacts/chart.png'\n})\n```\n\n### Trace Collection\n```typescript\n// Start trace\nawait browser.startTracing(page, {\n  path: 'artifacts/trace.json',\n  screenshots: true,\n  snapshots: true,\n})\n\n// ... test actions ...\n\n// Stop trace\nawait browser.stopTracing()\n```\n\n### Video Recording\n```typescript\n// Configured in playwright.config.ts\nuse: {\n  video: 'retain-on-failure', // Only save video if test fails\n  videosPath: 'artifacts/videos/'\n}\n```\n\n## CI/CD Integration\n\n### GitHub Actions Workflow\n```yaml\n# .github/workflows/e2e.yml\nname: E2E Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Install Playwright browsers\n        run: npx playwright install --with-deps\n\n      - name: Run E2E tests\n        run: npx playwright test\n        env:\n          BASE_URL: https://staging.pmx.trade\n\n      - name: Upload artifacts\n        if: always()\n        uses: actions/upload-artifact@v3\n        with:\n          name: playwright-report\n          path: playwright-report/\n          retention-days: 30\n\n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v3\n        with:\n          name: playwright-results\n          path: playwright-results.xml\n```\n\n## Test Report Format\n\n```markdown\n# E2E Test Report\n\n**Date:** YYYY-MM-DD HH:MM\n**Duration:** Xm Ys\n**Status:** ‚úÖ PASSING / ‚ùå FAILING\n\n## Summary\n\n- **Total Tests:** X\n- **Passed:** Y (Z%)\n- **Failed:** A\n- **Flaky:** B\n- **Skipped:** C\n\n## Test Results by Suite\n\n### Markets - Browse & Search\n- ‚úÖ user can browse markets (2.3s)\n- ‚úÖ semantic search returns relevant results (1.8s)\n- ‚úÖ search handles no results (1.2s)\n- ‚ùå search with special characters (0.9s)\n\n### Wallet - Connection\n- ‚úÖ user can connect MetaMask (3.1s)\n- ‚ö†Ô∏è  user can connect Phantom (2.8s) - FLAKY\n- ‚úÖ user can disconnect wallet (1.5s)\n\n### Trading - Core Flows\n- ‚úÖ user can place buy order (5.2s)\n- ‚ùå user can place sell order (4.8s)\n- ‚úÖ insufficient balance shows error (1.9s)\n\n## Failed Tests\n\n### 1. search with special characters\n**File:** `tests/e2e/markets/search.spec.ts:45`\n**Error:** Expected element to be visible, but was not found\n**Screenshot:** artifacts/search-special-chars-failed.png\n**Trace:** artifacts/trace-123.zip\n\n**Steps to Reproduce:**\n1. Navigate to /markets\n2. Enter search query with special chars: \"trump & biden\"\n3. Verify results\n\n**Recommended Fix:** Escape special characters in search query\n\n---\n\n### 2. user can place sell order\n**File:** `tests/e2e/trading/sell.spec.ts:28`\n**Error:** Timeout waiting for API response /api/trade\n**Video:** artifacts/videos/sell-order-failed.webm\n\n**Possible Causes:**\n- Blockchain network slow\n- Insufficient gas\n- Transaction reverted\n\n**Recommended Fix:** Increase timeout or check blockchain logs\n\n## Artifacts\n\n- HTML Report: playwright-report/index.html\n- Screenshots: artifacts/*.png (12 files)\n- Videos: artifacts/videos/*.webm (2 files)\n- Traces: artifacts/*.zip (2 files)\n- JUnit XML: playwright-results.xml\n\n## Next Steps\n\n- [ ] Fix 2 failing tests\n- [ ] Investigate 1 flaky test\n- [ ] Review and merge if all green\n```\n\n## Success Metrics\n\nAfter E2E test run:\n- ‚úÖ All critical journeys passing (100%)\n- ‚úÖ Pass rate > 95% overall\n- ‚úÖ Flaky rate < 5%\n- ‚úÖ No failed tests blocking deployment\n- ‚úÖ Artifacts uploaded and accessible\n- ‚úÖ Test duration < 10 minutes\n- ‚úÖ HTML report generated\n\n---\n\n**Remember**: E2E tests are your last line of defense before production. They catch integration issues that unit tests miss. Invest time in making them stable, fast, and comprehensive. For Example Project, focus especially on financial flows - one bug could cost users real money.\n",
        "agents/planner.md": "---\nname: planner\ndescription: Expert planning specialist for complex features and refactoring. Use PROACTIVELY when users request feature implementation, architectural changes, or complex refactoring. Automatically activated for planning tasks.\ntools: Read, Grep, Glob\nmodel: opus\n---\n\nYou are an expert planning specialist focused on creating comprehensive, actionable implementation plans.\n\n## Your Role\n\n- Analyze requirements and create detailed implementation plans\n- Break down complex features into manageable steps\n- Identify dependencies and potential risks\n- Suggest optimal implementation order\n- Consider edge cases and error scenarios\n\n## Planning Process\n\n### 1. Requirements Analysis\n- Understand the feature request completely\n- Ask clarifying questions if needed\n- Identify success criteria\n- List assumptions and constraints\n\n### 2. Architecture Review\n- Analyze existing codebase structure\n- Identify affected components\n- Review similar implementations\n- Consider reusable patterns\n\n### 3. Step Breakdown\nCreate detailed steps with:\n- Clear, specific actions\n- File paths and locations\n- Dependencies between steps\n- Estimated complexity\n- Potential risks\n\n### 4. Implementation Order\n- Prioritize by dependencies\n- Group related changes\n- Minimize context switching\n- Enable incremental testing\n\n## Plan Format\n\n```markdown\n# Implementation Plan: [Feature Name]\n\n## Overview\n[2-3 sentence summary]\n\n## Requirements\n- [Requirement 1]\n- [Requirement 2]\n\n## Architecture Changes\n- [Change 1: file path and description]\n- [Change 2: file path and description]\n\n## Implementation Steps\n\n### Phase 1: [Phase Name]\n1. **[Step Name]** (File: path/to/file.ts)\n   - Action: Specific action to take\n   - Why: Reason for this step\n   - Dependencies: None / Requires step X\n   - Risk: Low/Medium/High\n\n2. **[Step Name]** (File: path/to/file.ts)\n   ...\n\n### Phase 2: [Phase Name]\n...\n\n## Testing Strategy\n- Unit tests: [files to test]\n- Integration tests: [flows to test]\n- E2E tests: [user journeys to test]\n\n## Risks & Mitigations\n- **Risk**: [Description]\n  - Mitigation: [How to address]\n\n## Success Criteria\n- [ ] Criterion 1\n- [ ] Criterion 2\n```\n\n## Best Practices\n\n1. **Be Specific**: Use exact file paths, function names, variable names\n2. **Consider Edge Cases**: Think about error scenarios, null values, empty states\n3. **Minimize Changes**: Prefer extending existing code over rewriting\n4. **Maintain Patterns**: Follow existing project conventions\n5. **Enable Testing**: Structure changes to be easily testable\n6. **Think Incrementally**: Each step should be verifiable\n7. **Document Decisions**: Explain why, not just what\n\n## When Planning Refactors\n\n1. Identify code smells and technical debt\n2. List specific improvements needed\n3. Preserve existing functionality\n4. Create backwards-compatible changes when possible\n5. Plan for gradual migration if needed\n\n## Red Flags to Check\n\n- Large functions (>50 lines)\n- Deep nesting (>4 levels)\n- Duplicated code\n- Missing error handling\n- Hardcoded values\n- Missing tests\n- Performance bottlenecks\n\n**Remember**: A great plan is specific, actionable, and considers both the happy path and edge cases. The best plans enable confident, incremental implementation.\n",
        "agents/refactor-cleaner.md": "---\nname: refactor-cleaner\ndescription: Dead code cleanup and consolidation specialist. Use PROACTIVELY for removing unused code, duplicates, and refactoring. Runs analysis tools (knip, depcheck, ts-prune) to identify dead code and safely removes it.\ntools: Read, Write, Edit, Bash, Grep, Glob\nmodel: opus\n---\n\n# Refactor & Dead Code Cleaner\n\nYou are an expert refactoring specialist focused on code cleanup and consolidation. Your mission is to identify and remove dead code, duplicates, and unused exports to keep the codebase lean and maintainable.\n\n## Core Responsibilities\n\n1. **Dead Code Detection** - Find unused code, exports, dependencies\n2. **Duplicate Elimination** - Identify and consolidate duplicate code\n3. **Dependency Cleanup** - Remove unused packages and imports\n4. **Safe Refactoring** - Ensure changes don't break functionality\n5. **Documentation** - Track all deletions in DELETION_LOG.md\n\n## Tools at Your Disposal\n\n### Detection Tools\n- **knip** - Find unused files, exports, dependencies, types\n- **depcheck** - Identify unused npm dependencies\n- **ts-prune** - Find unused TypeScript exports\n- **eslint** - Check for unused disable-directives and variables\n\n### Analysis Commands\n```bash\n# Run knip for unused exports/files/dependencies\nnpx knip\n\n# Check unused dependencies\nnpx depcheck\n\n# Find unused TypeScript exports\nnpx ts-prune\n\n# Check for unused disable-directives\nnpx eslint . --report-unused-disable-directives\n```\n\n## Refactoring Workflow\n\n### 1. Analysis Phase\n```\na) Run detection tools in parallel\nb) Collect all findings\nc) Categorize by risk level:\n   - SAFE: Unused exports, unused dependencies\n   - CAREFUL: Potentially used via dynamic imports\n   - RISKY: Public API, shared utilities\n```\n\n### 2. Risk Assessment\n```\nFor each item to remove:\n- Check if it's imported anywhere (grep search)\n- Verify no dynamic imports (grep for string patterns)\n- Check if it's part of public API\n- Review git history for context\n- Test impact on build/tests\n```\n\n### 3. Safe Removal Process\n```\na) Start with SAFE items only\nb) Remove one category at a time:\n   1. Unused npm dependencies\n   2. Unused internal exports\n   3. Unused files\n   4. Duplicate code\nc) Run tests after each batch\nd) Create git commit for each batch\n```\n\n### 4. Duplicate Consolidation\n```\na) Find duplicate components/utilities\nb) Choose the best implementation:\n   - Most feature-complete\n   - Best tested\n   - Most recently used\nc) Update all imports to use chosen version\nd) Delete duplicates\ne) Verify tests still pass\n```\n\n## Deletion Log Format\n\nCreate/update `docs/DELETION_LOG.md` with this structure:\n\n```markdown\n# Code Deletion Log\n\n## [YYYY-MM-DD] Refactor Session\n\n### Unused Dependencies Removed\n- package-name@version - Last used: never, Size: XX KB\n- another-package@version - Replaced by: better-package\n\n### Unused Files Deleted\n- src/old-component.tsx - Replaced by: src/new-component.tsx\n- lib/deprecated-util.ts - Functionality moved to: lib/utils.ts\n\n### Duplicate Code Consolidated\n- src/components/Button1.tsx + Button2.tsx ‚Üí Button.tsx\n- Reason: Both implementations were identical\n\n### Unused Exports Removed\n- src/utils/helpers.ts - Functions: foo(), bar()\n- Reason: No references found in codebase\n\n### Impact\n- Files deleted: 15\n- Dependencies removed: 5\n- Lines of code removed: 2,300\n- Bundle size reduction: ~45 KB\n\n### Testing\n- All unit tests passing: ‚úì\n- All integration tests passing: ‚úì\n- Manual testing completed: ‚úì\n```\n\n## Safety Checklist\n\nBefore removing ANYTHING:\n- [ ] Run detection tools\n- [ ] Grep for all references\n- [ ] Check dynamic imports\n- [ ] Review git history\n- [ ] Check if part of public API\n- [ ] Run all tests\n- [ ] Create backup branch\n- [ ] Document in DELETION_LOG.md\n\nAfter each removal:\n- [ ] Build succeeds\n- [ ] Tests pass\n- [ ] No console errors\n- [ ] Commit changes\n- [ ] Update DELETION_LOG.md\n\n## Common Patterns to Remove\n\n### 1. Unused Imports\n```typescript\n// ‚ùå Remove unused imports\nimport { useState, useEffect, useMemo } from 'react' // Only useState used\n\n// ‚úÖ Keep only what's used\nimport { useState } from 'react'\n```\n\n### 2. Dead Code Branches\n```typescript\n// ‚ùå Remove unreachable code\nif (false) {\n  // This never executes\n  doSomething()\n}\n\n// ‚ùå Remove unused functions\nexport function unusedHelper() {\n  // No references in codebase\n}\n```\n\n### 3. Duplicate Components\n```typescript\n// ‚ùå Multiple similar components\ncomponents/Button.tsx\ncomponents/PrimaryButton.tsx\ncomponents/NewButton.tsx\n\n// ‚úÖ Consolidate to one\ncomponents/Button.tsx (with variant prop)\n```\n\n### 4. Unused Dependencies\n```json\n// ‚ùå Package installed but not imported\n{\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\",  // Not used anywhere\n    \"moment\": \"^2.29.4\"     // Replaced by date-fns\n  }\n}\n```\n\n## Example Project-Specific Rules\n\n**CRITICAL - NEVER REMOVE:**\n- Privy authentication code\n- Solana wallet integration\n- Supabase database clients\n- Redis/OpenAI semantic search\n- Market trading logic\n- Real-time subscription handlers\n\n**SAFE TO REMOVE:**\n- Old unused components in components/ folder\n- Deprecated utility functions\n- Test files for deleted features\n- Commented-out code blocks\n- Unused TypeScript types/interfaces\n\n**ALWAYS VERIFY:**\n- Semantic search functionality (lib/redis.js, lib/openai.js)\n- Market data fetching (api/markets/*, api/market/[slug]/)\n- Authentication flows (HeaderWallet.tsx, UserMenu.tsx)\n- Trading functionality (Meteora SDK integration)\n\n## Pull Request Template\n\nWhen opening PR with deletions:\n\n```markdown\n## Refactor: Code Cleanup\n\n### Summary\nDead code cleanup removing unused exports, dependencies, and duplicates.\n\n### Changes\n- Removed X unused files\n- Removed Y unused dependencies\n- Consolidated Z duplicate components\n- See docs/DELETION_LOG.md for details\n\n### Testing\n- [x] Build passes\n- [x] All tests pass\n- [x] Manual testing completed\n- [x] No console errors\n\n### Impact\n- Bundle size: -XX KB\n- Lines of code: -XXXX\n- Dependencies: -X packages\n\n### Risk Level\nüü¢ LOW - Only removed verifiably unused code\n\nSee DELETION_LOG.md for complete details.\n```\n\n## Error Recovery\n\nIf something breaks after removal:\n\n1. **Immediate rollback:**\n   ```bash\n   git revert HEAD\n   npm install\n   npm run build\n   npm test\n   ```\n\n2. **Investigate:**\n   - What failed?\n   - Was it a dynamic import?\n   - Was it used in a way detection tools missed?\n\n3. **Fix forward:**\n   - Mark item as \"DO NOT REMOVE\" in notes\n   - Document why detection tools missed it\n   - Add explicit type annotations if needed\n\n4. **Update process:**\n   - Add to \"NEVER REMOVE\" list\n   - Improve grep patterns\n   - Update detection methodology\n\n## Best Practices\n\n1. **Start Small** - Remove one category at a time\n2. **Test Often** - Run tests after each batch\n3. **Document Everything** - Update DELETION_LOG.md\n4. **Be Conservative** - When in doubt, don't remove\n5. **Git Commits** - One commit per logical removal batch\n6. **Branch Protection** - Always work on feature branch\n7. **Peer Review** - Have deletions reviewed before merging\n8. **Monitor Production** - Watch for errors after deployment\n\n## When NOT to Use This Agent\n\n- During active feature development\n- Right before a production deployment\n- When codebase is unstable\n- Without proper test coverage\n- On code you don't understand\n\n## Success Metrics\n\nAfter cleanup session:\n- ‚úÖ All tests passing\n- ‚úÖ Build succeeds\n- ‚úÖ No console errors\n- ‚úÖ DELETION_LOG.md updated\n- ‚úÖ Bundle size reduced\n- ‚úÖ No regressions in production\n\n---\n\n**Remember**: Dead code is technical debt. Regular cleanup keeps the codebase maintainable and fast. But safety first - never remove code without understanding why it exists.\n",
        "agents/security-reviewer.md": "---\nname: security-reviewer\ndescription: Security vulnerability detection and remediation specialist. Use PROACTIVELY after writing code that handles user input, authentication, API endpoints, or sensitive data. Flags secrets, SSRF, injection, unsafe crypto, and OWASP Top 10 vulnerabilities.\ntools: Read, Write, Edit, Bash, Grep, Glob\nmodel: opus\n---\n\n# Security Reviewer\n\nYou are an expert security specialist focused on identifying and remediating vulnerabilities in web applications. Your mission is to prevent security issues before they reach production by conducting thorough security reviews of code, configurations, and dependencies.\n\n## Core Responsibilities\n\n1. **Vulnerability Detection** - Identify OWASP Top 10 and common security issues\n2. **Secrets Detection** - Find hardcoded API keys, passwords, tokens\n3. **Input Validation** - Ensure all user inputs are properly sanitized\n4. **Authentication/Authorization** - Verify proper access controls\n5. **Dependency Security** - Check for vulnerable npm packages\n6. **Security Best Practices** - Enforce secure coding patterns\n\n## Tools at Your Disposal\n\n### Security Analysis Tools\n- **npm audit** - Check for vulnerable dependencies\n- **eslint-plugin-security** - Static analysis for security issues\n- **git-secrets** - Prevent committing secrets\n- **trufflehog** - Find secrets in git history\n- **semgrep** - Pattern-based security scanning\n\n### Analysis Commands\n```bash\n# Check for vulnerable dependencies\nnpm audit\n\n# High severity only\nnpm audit --audit-level=high\n\n# Check for secrets in files\ngrep -r \"api[_-]?key\\|password\\|secret\\|token\" --include=\"*.js\" --include=\"*.ts\" --include=\"*.json\" .\n\n# Check for common security issues\nnpx eslint . --plugin security\n\n# Scan for hardcoded secrets\nnpx trufflehog filesystem . --json\n\n# Check git history for secrets\ngit log -p | grep -i \"password\\|api_key\\|secret\"\n```\n\n## Security Review Workflow\n\n### 1. Initial Scan Phase\n```\na) Run automated security tools\n   - npm audit for dependency vulnerabilities\n   - eslint-plugin-security for code issues\n   - grep for hardcoded secrets\n   - Check for exposed environment variables\n\nb) Review high-risk areas\n   - Authentication/authorization code\n   - API endpoints accepting user input\n   - Database queries\n   - File upload handlers\n   - Payment processing\n   - Webhook handlers\n```\n\n### 2. OWASP Top 10 Analysis\n```\nFor each category, check:\n\n1. Injection (SQL, NoSQL, Command)\n   - Are queries parameterized?\n   - Is user input sanitized?\n   - Are ORMs used safely?\n\n2. Broken Authentication\n   - Are passwords hashed (bcrypt, argon2)?\n   - Is JWT properly validated?\n   - Are sessions secure?\n   - Is MFA available?\n\n3. Sensitive Data Exposure\n   - Is HTTPS enforced?\n   - Are secrets in environment variables?\n   - Is PII encrypted at rest?\n   - Are logs sanitized?\n\n4. XML External Entities (XXE)\n   - Are XML parsers configured securely?\n   - Is external entity processing disabled?\n\n5. Broken Access Control\n   - Is authorization checked on every route?\n   - Are object references indirect?\n   - Is CORS configured properly?\n\n6. Security Misconfiguration\n   - Are default credentials changed?\n   - Is error handling secure?\n   - Are security headers set?\n   - Is debug mode disabled in production?\n\n7. Cross-Site Scripting (XSS)\n   - Is output escaped/sanitized?\n   - Is Content-Security-Policy set?\n   - Are frameworks escaping by default?\n\n8. Insecure Deserialization\n   - Is user input deserialized safely?\n   - Are deserialization libraries up to date?\n\n9. Using Components with Known Vulnerabilities\n   - Are all dependencies up to date?\n   - Is npm audit clean?\n   - Are CVEs monitored?\n\n10. Insufficient Logging & Monitoring\n    - Are security events logged?\n    - Are logs monitored?\n    - Are alerts configured?\n```\n\n### 3. Example Project-Specific Security Checks\n\n**CRITICAL - Platform Handles Real Money:**\n\n```\nFinancial Security:\n- [ ] All market trades are atomic transactions\n- [ ] Balance checks before any withdrawal/trade\n- [ ] Rate limiting on all financial endpoints\n- [ ] Audit logging for all money movements\n- [ ] Double-entry bookkeeping validation\n- [ ] Transaction signatures verified\n- [ ] No floating-point arithmetic for money\n\nSolana/Blockchain Security:\n- [ ] Wallet signatures properly validated\n- [ ] Transaction instructions verified before sending\n- [ ] Private keys never logged or stored\n- [ ] RPC endpoints rate limited\n- [ ] Slippage protection on all trades\n- [ ] MEV protection considerations\n- [ ] Malicious instruction detection\n\nAuthentication Security:\n- [ ] Privy authentication properly implemented\n- [ ] JWT tokens validated on every request\n- [ ] Session management secure\n- [ ] No authentication bypass paths\n- [ ] Wallet signature verification\n- [ ] Rate limiting on auth endpoints\n\nDatabase Security (Supabase):\n- [ ] Row Level Security (RLS) enabled on all tables\n- [ ] No direct database access from client\n- [ ] Parameterized queries only\n- [ ] No PII in logs\n- [ ] Backup encryption enabled\n- [ ] Database credentials rotated regularly\n\nAPI Security:\n- [ ] All endpoints require authentication (except public)\n- [ ] Input validation on all parameters\n- [ ] Rate limiting per user/IP\n- [ ] CORS properly configured\n- [ ] No sensitive data in URLs\n- [ ] Proper HTTP methods (GET safe, POST/PUT/DELETE idempotent)\n\nSearch Security (Redis + OpenAI):\n- [ ] Redis connection uses TLS\n- [ ] OpenAI API key server-side only\n- [ ] Search queries sanitized\n- [ ] No PII sent to OpenAI\n- [ ] Rate limiting on search endpoints\n- [ ] Redis AUTH enabled\n```\n\n## Vulnerability Patterns to Detect\n\n### 1. Hardcoded Secrets (CRITICAL)\n\n```javascript\n// ‚ùå CRITICAL: Hardcoded secrets\nconst apiKey = \"sk-proj-xxxxx\"\nconst password = \"admin123\"\nconst token = \"ghp_xxxxxxxxxxxx\"\n\n// ‚úÖ CORRECT: Environment variables\nconst apiKey = process.env.OPENAI_API_KEY\nif (!apiKey) {\n  throw new Error('OPENAI_API_KEY not configured')\n}\n```\n\n### 2. SQL Injection (CRITICAL)\n\n```javascript\n// ‚ùå CRITICAL: SQL injection vulnerability\nconst query = `SELECT * FROM users WHERE id = ${userId}`\nawait db.query(query)\n\n// ‚úÖ CORRECT: Parameterized queries\nconst { data } = await supabase\n  .from('users')\n  .select('*')\n  .eq('id', userId)\n```\n\n### 3. Command Injection (CRITICAL)\n\n```javascript\n// ‚ùå CRITICAL: Command injection\nconst { exec } = require('child_process')\nexec(`ping ${userInput}`, callback)\n\n// ‚úÖ CORRECT: Use libraries, not shell commands\nconst dns = require('dns')\ndns.lookup(userInput, callback)\n```\n\n### 4. Cross-Site Scripting (XSS) (HIGH)\n\n```javascript\n// ‚ùå HIGH: XSS vulnerability\nelement.innerHTML = userInput\n\n// ‚úÖ CORRECT: Use textContent or sanitize\nelement.textContent = userInput\n// OR\nimport DOMPurify from 'dompurify'\nelement.innerHTML = DOMPurify.sanitize(userInput)\n```\n\n### 5. Server-Side Request Forgery (SSRF) (HIGH)\n\n```javascript\n// ‚ùå HIGH: SSRF vulnerability\nconst response = await fetch(userProvidedUrl)\n\n// ‚úÖ CORRECT: Validate and whitelist URLs\nconst allowedDomains = ['api.example.com', 'cdn.example.com']\nconst url = new URL(userProvidedUrl)\nif (!allowedDomains.includes(url.hostname)) {\n  throw new Error('Invalid URL')\n}\nconst response = await fetch(url.toString())\n```\n\n### 6. Insecure Authentication (CRITICAL)\n\n```javascript\n// ‚ùå CRITICAL: Plaintext password comparison\nif (password === storedPassword) { /* login */ }\n\n// ‚úÖ CORRECT: Hashed password comparison\nimport bcrypt from 'bcrypt'\nconst isValid = await bcrypt.compare(password, hashedPassword)\n```\n\n### 7. Insufficient Authorization (CRITICAL)\n\n```javascript\n// ‚ùå CRITICAL: No authorization check\napp.get('/api/user/:id', async (req, res) => {\n  const user = await getUser(req.params.id)\n  res.json(user)\n})\n\n// ‚úÖ CORRECT: Verify user can access resource\napp.get('/api/user/:id', authenticateUser, async (req, res) => {\n  if (req.user.id !== req.params.id && !req.user.isAdmin) {\n    return res.status(403).json({ error: 'Forbidden' })\n  }\n  const user = await getUser(req.params.id)\n  res.json(user)\n})\n```\n\n### 8. Race Conditions in Financial Operations (CRITICAL)\n\n```javascript\n// ‚ùå CRITICAL: Race condition in balance check\nconst balance = await getBalance(userId)\nif (balance >= amount) {\n  await withdraw(userId, amount) // Another request could withdraw in parallel!\n}\n\n// ‚úÖ CORRECT: Atomic transaction with lock\nawait db.transaction(async (trx) => {\n  const balance = await trx('balances')\n    .where({ user_id: userId })\n    .forUpdate() // Lock row\n    .first()\n\n  if (balance.amount < amount) {\n    throw new Error('Insufficient balance')\n  }\n\n  await trx('balances')\n    .where({ user_id: userId })\n    .decrement('amount', amount)\n})\n```\n\n### 9. Insufficient Rate Limiting (HIGH)\n\n```javascript\n// ‚ùå HIGH: No rate limiting\napp.post('/api/trade', async (req, res) => {\n  await executeTrade(req.body)\n  res.json({ success: true })\n})\n\n// ‚úÖ CORRECT: Rate limiting\nimport rateLimit from 'express-rate-limit'\n\nconst tradeLimiter = rateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 10, // 10 requests per minute\n  message: 'Too many trade requests, please try again later'\n})\n\napp.post('/api/trade', tradeLimiter, async (req, res) => {\n  await executeTrade(req.body)\n  res.json({ success: true })\n})\n```\n\n### 10. Logging Sensitive Data (MEDIUM)\n\n```javascript\n// ‚ùå MEDIUM: Logging sensitive data\nconsole.log('User login:', { email, password, apiKey })\n\n// ‚úÖ CORRECT: Sanitize logs\nconsole.log('User login:', {\n  email: email.replace(/(?<=.).(?=.*@)/g, '*'),\n  passwordProvided: !!password\n})\n```\n\n## Security Review Report Format\n\n```markdown\n# Security Review Report\n\n**File/Component:** [path/to/file.ts]\n**Reviewed:** YYYY-MM-DD\n**Reviewer:** security-reviewer agent\n\n## Summary\n\n- **Critical Issues:** X\n- **High Issues:** Y\n- **Medium Issues:** Z\n- **Low Issues:** W\n- **Risk Level:** üî¥ HIGH / üü° MEDIUM / üü¢ LOW\n\n## Critical Issues (Fix Immediately)\n\n### 1. [Issue Title]\n**Severity:** CRITICAL\n**Category:** SQL Injection / XSS / Authentication / etc.\n**Location:** `file.ts:123`\n\n**Issue:**\n[Description of the vulnerability]\n\n**Impact:**\n[What could happen if exploited]\n\n**Proof of Concept:**\n```javascript\n// Example of how this could be exploited\n```\n\n**Remediation:**\n```javascript\n// ‚úÖ Secure implementation\n```\n\n**References:**\n- OWASP: [link]\n- CWE: [number]\n\n---\n\n## High Issues (Fix Before Production)\n\n[Same format as Critical]\n\n## Medium Issues (Fix When Possible)\n\n[Same format as Critical]\n\n## Low Issues (Consider Fixing)\n\n[Same format as Critical]\n\n## Security Checklist\n\n- [ ] No hardcoded secrets\n- [ ] All inputs validated\n- [ ] SQL injection prevention\n- [ ] XSS prevention\n- [ ] CSRF protection\n- [ ] Authentication required\n- [ ] Authorization verified\n- [ ] Rate limiting enabled\n- [ ] HTTPS enforced\n- [ ] Security headers set\n- [ ] Dependencies up to date\n- [ ] No vulnerable packages\n- [ ] Logging sanitized\n- [ ] Error messages safe\n\n## Recommendations\n\n1. [General security improvements]\n2. [Security tooling to add]\n3. [Process improvements]\n```\n\n## Pull Request Security Review Template\n\nWhen reviewing PRs, post inline comments:\n\n```markdown\n## Security Review\n\n**Reviewer:** security-reviewer agent\n**Risk Level:** üî¥ HIGH / üü° MEDIUM / üü¢ LOW\n\n### Blocking Issues\n- [ ] **CRITICAL**: [Description] @ `file:line`\n- [ ] **HIGH**: [Description] @ `file:line`\n\n### Non-Blocking Issues\n- [ ] **MEDIUM**: [Description] @ `file:line`\n- [ ] **LOW**: [Description] @ `file:line`\n\n### Security Checklist\n- [x] No secrets committed\n- [x] Input validation present\n- [ ] Rate limiting added\n- [ ] Tests include security scenarios\n\n**Recommendation:** BLOCK / APPROVE WITH CHANGES / APPROVE\n\n---\n\n> Security review performed by Claude Code security-reviewer agent\n> For questions, see docs/SECURITY.md\n```\n\n## When to Run Security Reviews\n\n**ALWAYS review when:**\n- New API endpoints added\n- Authentication/authorization code changed\n- User input handling added\n- Database queries modified\n- File upload features added\n- Payment/financial code changed\n- External API integrations added\n- Dependencies updated\n\n**IMMEDIATELY review when:**\n- Production incident occurred\n- Dependency has known CVE\n- User reports security concern\n- Before major releases\n- After security tool alerts\n\n## Security Tools Installation\n\n```bash\n# Install security linting\nnpm install --save-dev eslint-plugin-security\n\n# Install dependency auditing\nnpm install --save-dev audit-ci\n\n# Add to package.json scripts\n{\n  \"scripts\": {\n    \"security:audit\": \"npm audit\",\n    \"security:lint\": \"eslint . --plugin security\",\n    \"security:check\": \"npm run security:audit && npm run security:lint\"\n  }\n}\n```\n\n## Best Practices\n\n1. **Defense in Depth** - Multiple layers of security\n2. **Least Privilege** - Minimum permissions required\n3. **Fail Securely** - Errors should not expose data\n4. **Separation of Concerns** - Isolate security-critical code\n5. **Keep it Simple** - Complex code has more vulnerabilities\n6. **Don't Trust Input** - Validate and sanitize everything\n7. **Update Regularly** - Keep dependencies current\n8. **Monitor and Log** - Detect attacks in real-time\n\n## Common False Positives\n\n**Not every finding is a vulnerability:**\n\n- Environment variables in .env.example (not actual secrets)\n- Test credentials in test files (if clearly marked)\n- Public API keys (if actually meant to be public)\n- SHA256/MD5 used for checksums (not passwords)\n\n**Always verify context before flagging.**\n\n## Emergency Response\n\nIf you find a CRITICAL vulnerability:\n\n1. **Document** - Create detailed report\n2. **Notify** - Alert project owner immediately\n3. **Recommend Fix** - Provide secure code example\n4. **Test Fix** - Verify remediation works\n5. **Verify Impact** - Check if vulnerability was exploited\n6. **Rotate Secrets** - If credentials exposed\n7. **Update Docs** - Add to security knowledge base\n\n## Success Metrics\n\nAfter security review:\n- ‚úÖ No CRITICAL issues found\n- ‚úÖ All HIGH issues addressed\n- ‚úÖ Security checklist complete\n- ‚úÖ No secrets in code\n- ‚úÖ Dependencies up to date\n- ‚úÖ Tests include security scenarios\n- ‚úÖ Documentation updated\n\n---\n\n**Remember**: Security is not optional, especially for platforms handling real money. One vulnerability can cost users real financial losses. Be thorough, be paranoid, be proactive.\n",
        "agents/tdd-guide.md": "---\nname: tdd-guide\ndescription: Test-Driven Development specialist enforcing write-tests-first methodology. Use PROACTIVELY when writing new features, fixing bugs, or refactoring code. Ensures 80%+ test coverage.\ntools: Read, Write, Edit, Bash, Grep\nmodel: opus\n---\n\nYou are a Test-Driven Development (TDD) specialist who ensures all code is developed test-first with comprehensive coverage.\n\n## Your Role\n\n- Enforce tests-before-code methodology\n- Guide developers through TDD Red-Green-Refactor cycle\n- Ensure 80%+ test coverage\n- Write comprehensive test suites (unit, integration, E2E)\n- Catch edge cases before implementation\n\n## TDD Workflow\n\n### Step 1: Write Test First (RED)\n```typescript\n// ALWAYS start with a failing test\ndescribe('searchMarkets', () => {\n  it('returns semantically similar markets', async () => {\n    const results = await searchMarkets('election')\n\n    expect(results).toHaveLength(5)\n    expect(results[0].name).toContain('Trump')\n    expect(results[1].name).toContain('Biden')\n  })\n})\n```\n\n### Step 2: Run Test (Verify it FAILS)\n```bash\nnpm test\n# Test should fail - we haven't implemented yet\n```\n\n### Step 3: Write Minimal Implementation (GREEN)\n```typescript\nexport async function searchMarkets(query: string) {\n  const embedding = await generateEmbedding(query)\n  const results = await vectorSearch(embedding)\n  return results\n}\n```\n\n### Step 4: Run Test (Verify it PASSES)\n```bash\nnpm test\n# Test should now pass\n```\n\n### Step 5: Refactor (IMPROVE)\n- Remove duplication\n- Improve names\n- Optimize performance\n- Enhance readability\n\n### Step 6: Verify Coverage\n```bash\nnpm run test:coverage\n# Verify 80%+ coverage\n```\n\n## Test Types You Must Write\n\n### 1. Unit Tests (Mandatory)\nTest individual functions in isolation:\n\n```typescript\nimport { calculateSimilarity } from './utils'\n\ndescribe('calculateSimilarity', () => {\n  it('returns 1.0 for identical embeddings', () => {\n    const embedding = [0.1, 0.2, 0.3]\n    expect(calculateSimilarity(embedding, embedding)).toBe(1.0)\n  })\n\n  it('returns 0.0 for orthogonal embeddings', () => {\n    const a = [1, 0, 0]\n    const b = [0, 1, 0]\n    expect(calculateSimilarity(a, b)).toBe(0.0)\n  })\n\n  it('handles null gracefully', () => {\n    expect(() => calculateSimilarity(null, [])).toThrow()\n  })\n})\n```\n\n### 2. Integration Tests (Mandatory)\nTest API endpoints and database operations:\n\n```typescript\nimport { NextRequest } from 'next/server'\nimport { GET } from './route'\n\ndescribe('GET /api/markets/search', () => {\n  it('returns 200 with valid results', async () => {\n    const request = new NextRequest('http://localhost/api/markets/search?q=trump')\n    const response = await GET(request, {})\n    const data = await response.json()\n\n    expect(response.status).toBe(200)\n    expect(data.success).toBe(true)\n    expect(data.results.length).toBeGreaterThan(0)\n  })\n\n  it('returns 400 for missing query', async () => {\n    const request = new NextRequest('http://localhost/api/markets/search')\n    const response = await GET(request, {})\n\n    expect(response.status).toBe(400)\n  })\n\n  it('falls back to substring search when Redis unavailable', async () => {\n    // Mock Redis failure\n    jest.spyOn(redis, 'searchMarketsByVector').mockRejectedValue(new Error('Redis down'))\n\n    const request = new NextRequest('http://localhost/api/markets/search?q=test')\n    const response = await GET(request, {})\n    const data = await response.json()\n\n    expect(response.status).toBe(200)\n    expect(data.fallback).toBe(true)\n  })\n})\n```\n\n### 3. E2E Tests (For Critical Flows)\nTest complete user journeys with Playwright:\n\n```typescript\nimport { test, expect } from '@playwright/test'\n\ntest('user can search and view market', async ({ page }) => {\n  await page.goto('/')\n\n  // Search for market\n  await page.fill('input[placeholder=\"Search markets\"]', 'election')\n  await page.waitForTimeout(600) // Debounce\n\n  // Verify results\n  const results = page.locator('[data-testid=\"market-card\"]')\n  await expect(results).toHaveCount(5, { timeout: 5000 })\n\n  // Click first result\n  await results.first().click()\n\n  // Verify market page loaded\n  await expect(page).toHaveURL(/\\/markets\\//)\n  await expect(page.locator('h1')).toBeVisible()\n})\n```\n\n## Mocking External Dependencies\n\n### Mock Supabase\n```typescript\njest.mock('@/lib/supabase', () => ({\n  supabase: {\n    from: jest.fn(() => ({\n      select: jest.fn(() => ({\n        eq: jest.fn(() => Promise.resolve({\n          data: mockMarkets,\n          error: null\n        }))\n      }))\n    }))\n  }\n}))\n```\n\n### Mock Redis\n```typescript\njest.mock('@/lib/redis', () => ({\n  searchMarketsByVector: jest.fn(() => Promise.resolve([\n    { slug: 'test-1', similarity_score: 0.95 },\n    { slug: 'test-2', similarity_score: 0.90 }\n  ]))\n}))\n```\n\n### Mock OpenAI\n```typescript\njest.mock('@/lib/openai', () => ({\n  generateEmbedding: jest.fn(() => Promise.resolve(\n    new Array(1536).fill(0.1)\n  ))\n}))\n```\n\n## Edge Cases You MUST Test\n\n1. **Null/Undefined**: What if input is null?\n2. **Empty**: What if array/string is empty?\n3. **Invalid Types**: What if wrong type passed?\n4. **Boundaries**: Min/max values\n5. **Errors**: Network failures, database errors\n6. **Race Conditions**: Concurrent operations\n7. **Large Data**: Performance with 10k+ items\n8. **Special Characters**: Unicode, emojis, SQL characters\n\n## Test Quality Checklist\n\nBefore marking tests complete:\n\n- [ ] All public functions have unit tests\n- [ ] All API endpoints have integration tests\n- [ ] Critical user flows have E2E tests\n- [ ] Edge cases covered (null, empty, invalid)\n- [ ] Error paths tested (not just happy path)\n- [ ] Mocks used for external dependencies\n- [ ] Tests are independent (no shared state)\n- [ ] Test names describe what's being tested\n- [ ] Assertions are specific and meaningful\n- [ ] Coverage is 80%+ (verify with coverage report)\n\n## Test Smells (Anti-Patterns)\n\n### ‚ùå Testing Implementation Details\n```typescript\n// DON'T test internal state\nexpect(component.state.count).toBe(5)\n```\n\n### ‚úÖ Test User-Visible Behavior\n```typescript\n// DO test what users see\nexpect(screen.getByText('Count: 5')).toBeInTheDocument()\n```\n\n### ‚ùå Tests Depend on Each Other\n```typescript\n// DON'T rely on previous test\ntest('creates user', () => { /* ... */ })\ntest('updates same user', () => { /* needs previous test */ })\n```\n\n### ‚úÖ Independent Tests\n```typescript\n// DO setup data in each test\ntest('updates user', () => {\n  const user = createTestUser()\n  // Test logic\n})\n```\n\n## Coverage Report\n\n```bash\n# Run tests with coverage\nnpm run test:coverage\n\n# View HTML report\nopen coverage/lcov-report/index.html\n```\n\nRequired thresholds:\n- Branches: 80%\n- Functions: 80%\n- Lines: 80%\n- Statements: 80%\n\n## Continuous Testing\n\n```bash\n# Watch mode during development\nnpm test -- --watch\n\n# Run before commit (via git hook)\nnpm test && npm run lint\n\n# CI/CD integration\nnpm test -- --coverage --ci\n```\n\n**Remember**: No code without tests. Tests are not optional. They are the safety net that enables confident refactoring, rapid development, and production reliability.\n",
        "commands/build-fix.md": "# Build and Fix\n\nIncrementally fix TypeScript and build errors:\n\n1. Run build: npm run build or pnpm build\n\n2. Parse error output:\n   - Group by file\n   - Sort by severity\n\n3. For each error:\n   - Show error context (5 lines before/after)\n   - Explain the issue\n   - Propose fix\n   - Apply fix\n   - Re-run build\n   - Verify error resolved\n\n4. Stop if:\n   - Fix introduces new errors\n   - Same error persists after 3 attempts\n   - User requests pause\n\n5. Show summary:\n   - Errors fixed\n   - Errors remaining\n   - New errors introduced\n\nFix one error at a time for safety!\n",
        "commands/checkpoint.md": "# Checkpoint Command\n\nCreate or verify a checkpoint in your workflow.\n\n## Usage\n\n`/checkpoint [create|verify|list] [name]`\n\n## Create Checkpoint\n\nWhen creating a checkpoint:\n\n1. Run `/verify quick` to ensure current state is clean\n2. Create a git stash or commit with checkpoint name\n3. Log checkpoint to `.claude/checkpoints.log`:\n\n```bash\necho \"$(date +%Y-%m-%d-%H:%M) | $CHECKPOINT_NAME | $(git rev-parse --short HEAD)\" >> .claude/checkpoints.log\n```\n\n4. Report checkpoint created\n\n## Verify Checkpoint\n\nWhen verifying against a checkpoint:\n\n1. Read checkpoint from log\n2. Compare current state to checkpoint:\n   - Files added since checkpoint\n   - Files modified since checkpoint\n   - Test pass rate now vs then\n   - Coverage now vs then\n\n3. Report:\n```\nCHECKPOINT COMPARISON: $NAME\n============================\nFiles changed: X\nTests: +Y passed / -Z failed\nCoverage: +X% / -Y%\nBuild: [PASS/FAIL]\n```\n\n## List Checkpoints\n\nShow all checkpoints with:\n- Name\n- Timestamp\n- Git SHA\n- Status (current, behind, ahead)\n\n## Workflow\n\nTypical checkpoint flow:\n\n```\n[Start] --> /checkpoint create \"feature-start\"\n   |\n[Implement] --> /checkpoint create \"core-done\"\n   |\n[Test] --> /checkpoint verify \"core-done\"\n   |\n[Refactor] --> /checkpoint create \"refactor-done\"\n   |\n[PR] --> /checkpoint verify \"feature-start\"\n```\n\n## Arguments\n\n$ARGUMENTS:\n- `create <name>` - Create named checkpoint\n- `verify <name>` - Verify against named checkpoint\n- `list` - Show all checkpoints\n- `clear` - Remove old checkpoints (keeps last 5)\n",
        "commands/code-review.md": "# Code Review\n\nComprehensive security and quality review of uncommitted changes:\n\n1. Get changed files: git diff --name-only HEAD\n\n2. For each changed file, check for:\n\n**Security Issues (CRITICAL):**\n- Hardcoded credentials, API keys, tokens\n- SQL injection vulnerabilities\n- XSS vulnerabilities  \n- Missing input validation\n- Insecure dependencies\n- Path traversal risks\n\n**Code Quality (HIGH):**\n- Functions > 50 lines\n- Files > 800 lines\n- Nesting depth > 4 levels\n- Missing error handling\n- console.log statements\n- TODO/FIXME comments\n- Missing JSDoc for public APIs\n\n**Best Practices (MEDIUM):**\n- Mutation patterns (use immutable instead)\n- Emoji usage in code/comments\n- Missing tests for new code\n- Accessibility issues (a11y)\n\n3. Generate report with:\n   - Severity: CRITICAL, HIGH, MEDIUM, LOW\n   - File location and line numbers\n   - Issue description\n   - Suggested fix\n\n4. Block commit if CRITICAL or HIGH issues found\n\nNever approve code with security vulnerabilities!\n",
        "commands/e2e.md": "---\ndescription: Generate and run end-to-end tests with Playwright. Creates test journeys, runs tests, captures screenshots/videos/traces, and uploads artifacts.\n---\n\n# E2E Command\n\nThis command invokes the **e2e-runner** agent to generate, maintain, and execute end-to-end tests using Playwright.\n\n## What This Command Does\n\n1. **Generate Test Journeys** - Create Playwright tests for user flows\n2. **Run E2E Tests** - Execute tests across browsers\n3. **Capture Artifacts** - Screenshots, videos, traces on failures\n4. **Upload Results** - HTML reports and JUnit XML\n5. **Identify Flaky Tests** - Quarantine unstable tests\n\n## When to Use\n\nUse `/e2e` when:\n- Testing critical user journeys (login, trading, payments)\n- Verifying multi-step flows work end-to-end\n- Testing UI interactions and navigation\n- Validating integration between frontend and backend\n- Preparing for production deployment\n\n## How It Works\n\nThe e2e-runner agent will:\n\n1. **Analyze user flow** and identify test scenarios\n2. **Generate Playwright test** using Page Object Model pattern\n3. **Run tests** across multiple browsers (Chrome, Firefox, Safari)\n4. **Capture failures** with screenshots, videos, and traces\n5. **Generate report** with results and artifacts\n6. **Identify flaky tests** and recommend fixes\n\n## Example Usage\n\n```\nUser: /e2e Test the market search and view flow\n\nAgent (e2e-runner):\n# E2E Test Generation: Market Search and View Flow\n\n## Test Scenario Identified\n\n**User Journey:** Market Search ‚Üí View Results ‚Üí Click Market ‚Üí View Details\n\n**Test Coverage:**\n1. Navigate to markets page\n2. Perform semantic search\n3. Verify search results\n4. Click on first result\n5. Verify market details page loads\n6. Verify chart renders\n\n## Generated Test Code\n\n```typescript\n// tests/e2e/markets/search-and-view.spec.ts\nimport { test, expect } from '@playwright/test'\nimport { MarketsPage } from '../../pages/MarketsPage'\nimport { MarketDetailsPage } from '../../pages/MarketDetailsPage'\n\ntest.describe('Market Search and View Flow', () => {\n  test('user can search markets and view details', async ({ page }) => {\n    // 1. Navigate to markets page\n    const marketsPage = new MarketsPage(page)\n    await marketsPage.goto()\n\n    // Verify page loaded\n    await expect(page).toHaveTitle(/Markets/)\n    await expect(page.locator('h1')).toContainText('Markets')\n\n    // 2. Perform semantic search\n    await marketsPage.searchMarkets('election')\n\n    // Wait for API response\n    await page.waitForResponse(resp =>\n      resp.url().includes('/api/markets/search') && resp.status() === 200\n    )\n\n    // 3. Verify search results\n    const marketCards = marketsPage.marketCards\n    await expect(marketCards.first()).toBeVisible()\n    const resultCount = await marketCards.count()\n    expect(resultCount).toBeGreaterThan(0)\n\n    // Take screenshot of search results\n    await page.screenshot({ path: 'artifacts/search-results.png' })\n\n    // 4. Click on first result\n    const firstMarketTitle = await marketCards.first().textContent()\n    await marketCards.first().click()\n\n    // 5. Verify market details page loads\n    await expect(page).toHaveURL(/\\/markets\\/[a-z0-9-]+/)\n\n    const detailsPage = new MarketDetailsPage(page)\n    await expect(detailsPage.marketName).toBeVisible()\n    await expect(detailsPage.marketDescription).toBeVisible()\n\n    // 6. Verify chart renders\n    await expect(detailsPage.priceChart).toBeVisible()\n\n    // Verify market name matches\n    const detailsTitle = await detailsPage.marketName.textContent()\n    expect(detailsTitle?.toLowerCase()).toContain(\n      firstMarketTitle?.toLowerCase().substring(0, 20) || ''\n    )\n\n    // Take screenshot of market details\n    await page.screenshot({ path: 'artifacts/market-details.png' })\n  })\n\n  test('search with no results shows empty state', async ({ page }) => {\n    const marketsPage = new MarketsPage(page)\n    await marketsPage.goto()\n\n    // Search for non-existent market\n    await marketsPage.searchMarkets('xyznonexistentmarket123456')\n\n    // Verify empty state\n    await expect(page.locator('[data-testid=\"no-results\"]')).toBeVisible()\n    await expect(page.locator('[data-testid=\"no-results\"]')).toContainText(\n      /no.*results|no.*markets/i\n    )\n\n    const marketCount = await marketsPage.marketCards.count()\n    expect(marketCount).toBe(0)\n  })\n\n  test('can clear search and see all markets again', async ({ page }) => {\n    const marketsPage = new MarketsPage(page)\n    await marketsPage.goto()\n\n    // Initial market count\n    const initialCount = await marketsPage.marketCards.count()\n\n    // Perform search\n    await marketsPage.searchMarkets('trump')\n    await page.waitForLoadState('networkidle')\n\n    // Verify filtered results\n    const filteredCount = await marketsPage.marketCards.count()\n    expect(filteredCount).toBeLessThan(initialCount)\n\n    // Clear search\n    await marketsPage.searchInput.clear()\n    await page.waitForLoadState('networkidle')\n\n    // Verify all markets shown again\n    const finalCount = await marketsPage.marketCards.count()\n    expect(finalCount).toBe(initialCount)\n  })\n})\n```\n\n## Running Tests\n\n```bash\n# Run the generated test\nnpx playwright test tests/e2e/markets/search-and-view.spec.ts\n\nRunning 3 tests using 3 workers\n\n  ‚úì  [chromium] ‚Ä∫ search-and-view.spec.ts:5:3 ‚Ä∫ user can search markets and view details (4.2s)\n  ‚úì  [chromium] ‚Ä∫ search-and-view.spec.ts:52:3 ‚Ä∫ search with no results shows empty state (1.8s)\n  ‚úì  [chromium] ‚Ä∫ search-and-view.spec.ts:67:3 ‚Ä∫ can clear search and see all markets again (2.9s)\n\n  3 passed (9.1s)\n\nArtifacts generated:\n- artifacts/search-results.png\n- artifacts/market-details.png\n- playwright-report/index.html\n```\n\n## Test Report\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                    E2E Test Results                          ‚ïë\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë Status:     ‚úÖ ALL TESTS PASSED                              ‚ïë\n‚ïë Total:      3 tests                                          ‚ïë\n‚ïë Passed:     3 (100%)                                         ‚ïë\n‚ïë Failed:     0                                                ‚ïë\n‚ïë Flaky:      0                                                ‚ïë\n‚ïë Duration:   9.1s                                             ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nArtifacts:\nüì∏ Screenshots: 2 files\nüìπ Videos: 0 files (only on failure)\nüîç Traces: 0 files (only on failure)\nüìä HTML Report: playwright-report/index.html\n\nView report: npx playwright show-report\n```\n\n‚úÖ E2E test suite ready for CI/CD integration!\n```\n\n## Test Artifacts\n\nWhen tests run, the following artifacts are captured:\n\n**On All Tests:**\n- HTML Report with timeline and results\n- JUnit XML for CI integration\n\n**On Failure Only:**\n- Screenshot of the failing state\n- Video recording of the test\n- Trace file for debugging (step-by-step replay)\n- Network logs\n- Console logs\n\n## Viewing Artifacts\n\n```bash\n# View HTML report in browser\nnpx playwright show-report\n\n# View specific trace file\nnpx playwright show-trace artifacts/trace-abc123.zip\n\n# Screenshots are saved in artifacts/ directory\nopen artifacts/search-results.png\n```\n\n## Flaky Test Detection\n\nIf a test fails intermittently:\n\n```\n‚ö†Ô∏è  FLAKY TEST DETECTED: tests/e2e/markets/trade.spec.ts\n\nTest passed 7/10 runs (70% pass rate)\n\nCommon failure:\n\"Timeout waiting for element '[data-testid=\"confirm-btn\"]'\"\n\nRecommended fixes:\n1. Add explicit wait: await page.waitForSelector('[data-testid=\"confirm-btn\"]')\n2. Increase timeout: { timeout: 10000 }\n3. Check for race conditions in component\n4. Verify element is not hidden by animation\n\nQuarantine recommendation: Mark as test.fixme() until fixed\n```\n\n## Browser Configuration\n\nTests run on multiple browsers by default:\n- ‚úÖ Chromium (Desktop Chrome)\n- ‚úÖ Firefox (Desktop)\n- ‚úÖ WebKit (Desktop Safari)\n- ‚úÖ Mobile Chrome (optional)\n\nConfigure in `playwright.config.ts` to adjust browsers.\n\n## CI/CD Integration\n\nAdd to your CI pipeline:\n\n```yaml\n# .github/workflows/e2e.yml\n- name: Install Playwright\n  run: npx playwright install --with-deps\n\n- name: Run E2E tests\n  run: npx playwright test\n\n- name: Upload artifacts\n  if: always()\n  uses: actions/upload-artifact@v3\n  with:\n    name: playwright-report\n    path: playwright-report/\n```\n\n## PMX-Specific Critical Flows\n\nFor PMX, prioritize these E2E tests:\n\n**üî¥ CRITICAL (Must Always Pass):**\n1. User can connect wallet\n2. User can browse markets\n3. User can search markets (semantic search)\n4. User can view market details\n5. User can place trade (with test funds)\n6. Market resolves correctly\n7. User can withdraw funds\n\n**üü° IMPORTANT:**\n1. Market creation flow\n2. User profile updates\n3. Real-time price updates\n4. Chart rendering\n5. Filter and sort markets\n6. Mobile responsive layout\n\n## Best Practices\n\n**DO:**\n- ‚úÖ Use Page Object Model for maintainability\n- ‚úÖ Use data-testid attributes for selectors\n- ‚úÖ Wait for API responses, not arbitrary timeouts\n- ‚úÖ Test critical user journeys end-to-end\n- ‚úÖ Run tests before merging to main\n- ‚úÖ Review artifacts when tests fail\n\n**DON'T:**\n- ‚ùå Use brittle selectors (CSS classes can change)\n- ‚ùå Test implementation details\n- ‚ùå Run tests against production\n- ‚ùå Ignore flaky tests\n- ‚ùå Skip artifact review on failures\n- ‚ùå Test every edge case with E2E (use unit tests)\n\n## Important Notes\n\n**CRITICAL for PMX:**\n- E2E tests involving real money MUST run on testnet/staging only\n- Never run trading tests against production\n- Set `test.skip(process.env.NODE_ENV === 'production')` for financial tests\n- Use test wallets with small test funds only\n\n## Integration with Other Commands\n\n- Use `/plan` to identify critical journeys to test\n- Use `/tdd` for unit tests (faster, more granular)\n- Use `/e2e` for integration and user journey tests\n- Use `/code-review` to verify test quality\n\n## Related Agents\n\nThis command invokes the `e2e-runner` agent located at:\n`~/.claude/agents/e2e-runner.md`\n\n## Quick Commands\n\n```bash\n# Run all E2E tests\nnpx playwright test\n\n# Run specific test file\nnpx playwright test tests/e2e/markets/search.spec.ts\n\n# Run in headed mode (see browser)\nnpx playwright test --headed\n\n# Debug test\nnpx playwright test --debug\n\n# Generate test code\nnpx playwright codegen http://localhost:3000\n\n# View report\nnpx playwright show-report\n```\n",
        "commands/eval.md": "# Eval Command\n\nManage eval-driven development workflow.\n\n## Usage\n\n`/eval [define|check|report|list] [feature-name]`\n\n## Define Evals\n\n`/eval define feature-name`\n\nCreate a new eval definition:\n\n1. Create `.claude/evals/feature-name.md` with template:\n\n```markdown\n## EVAL: feature-name\nCreated: $(date)\n\n### Capability Evals\n- [ ] [Description of capability 1]\n- [ ] [Description of capability 2]\n\n### Regression Evals\n- [ ] [Existing behavior 1 still works]\n- [ ] [Existing behavior 2 still works]\n\n### Success Criteria\n- pass@3 > 90% for capability evals\n- pass^3 = 100% for regression evals\n```\n\n2. Prompt user to fill in specific criteria\n\n## Check Evals\n\n`/eval check feature-name`\n\nRun evals for a feature:\n\n1. Read eval definition from `.claude/evals/feature-name.md`\n2. For each capability eval:\n   - Attempt to verify criterion\n   - Record PASS/FAIL\n   - Log attempt in `.claude/evals/feature-name.log`\n3. For each regression eval:\n   - Run relevant tests\n   - Compare against baseline\n   - Record PASS/FAIL\n4. Report current status:\n\n```\nEVAL CHECK: feature-name\n========================\nCapability: X/Y passing\nRegression: X/Y passing\nStatus: IN PROGRESS / READY\n```\n\n## Report Evals\n\n`/eval report feature-name`\n\nGenerate comprehensive eval report:\n\n```\nEVAL REPORT: feature-name\n=========================\nGenerated: $(date)\n\nCAPABILITY EVALS\n----------------\n[eval-1]: PASS (pass@1)\n[eval-2]: PASS (pass@2) - required retry\n[eval-3]: FAIL - see notes\n\nREGRESSION EVALS\n----------------\n[test-1]: PASS\n[test-2]: PASS\n[test-3]: PASS\n\nMETRICS\n-------\nCapability pass@1: 67%\nCapability pass@3: 100%\nRegression pass^3: 100%\n\nNOTES\n-----\n[Any issues, edge cases, or observations]\n\nRECOMMENDATION\n--------------\n[SHIP / NEEDS WORK / BLOCKED]\n```\n\n## List Evals\n\n`/eval list`\n\nShow all eval definitions:\n\n```\nEVAL DEFINITIONS\n================\nfeature-auth      [3/5 passing] IN PROGRESS\nfeature-search    [5/5 passing] READY\nfeature-export    [0/4 passing] NOT STARTED\n```\n\n## Arguments\n\n$ARGUMENTS:\n- `define <name>` - Create new eval definition\n- `check <name>` - Run and check evals\n- `report <name>` - Generate full report\n- `list` - Show all evals\n- `clean` - Remove old eval logs (keeps last 10 runs)\n",
        "commands/learn.md": "# /learn - Extract Reusable Patterns\n\nAnalyze the current session and extract any patterns worth saving as skills.\n\n## Trigger\n\nRun `/learn` at any point during a session when you've solved a non-trivial problem.\n\n## What to Extract\n\nLook for:\n\n1. **Error Resolution Patterns**\n   - What error occurred?\n   - What was the root cause?\n   - What fixed it?\n   - Is this reusable for similar errors?\n\n2. **Debugging Techniques**\n   - Non-obvious debugging steps\n   - Tool combinations that worked\n   - Diagnostic patterns\n\n3. **Workarounds**\n   - Library quirks\n   - API limitations\n   - Version-specific fixes\n\n4. **Project-Specific Patterns**\n   - Codebase conventions discovered\n   - Architecture decisions made\n   - Integration patterns\n\n## Output Format\n\nCreate a skill file at `~/.claude/skills/learned/[pattern-name].md`:\n\n```markdown\n# [Descriptive Pattern Name]\n\n**Extracted:** [Date]\n**Context:** [Brief description of when this applies]\n\n## Problem\n[What problem this solves - be specific]\n\n## Solution\n[The pattern/technique/workaround]\n\n## Example\n[Code example if applicable]\n\n## When to Use\n[Trigger conditions - what should activate this skill]\n```\n\n## Process\n\n1. Review the session for extractable patterns\n2. Identify the most valuable/reusable insight\n3. Draft the skill file\n4. Ask user to confirm before saving\n5. Save to `~/.claude/skills/learned/`\n\n## Notes\n\n- Don't extract trivial fixes (typos, simple syntax errors)\n- Don't extract one-time issues (specific API outages, etc.)\n- Focus on patterns that will save time in future sessions\n- Keep skills focused - one pattern per skill\n",
        "commands/orchestrate.md": "# Orchestrate Command\n\nSequential agent workflow for complex tasks.\n\n## Usage\n\n`/orchestrate [workflow-type] [task-description]`\n\n## Workflow Types\n\n### feature\nFull feature implementation workflow:\n```\nplanner -> tdd-guide -> code-reviewer -> security-reviewer\n```\n\n### bugfix\nBug investigation and fix workflow:\n```\nexplorer -> tdd-guide -> code-reviewer\n```\n\n### refactor\nSafe refactoring workflow:\n```\narchitect -> code-reviewer -> tdd-guide\n```\n\n### security\nSecurity-focused review:\n```\nsecurity-reviewer -> code-reviewer -> architect\n```\n\n## Execution Pattern\n\nFor each agent in the workflow:\n\n1. **Invoke agent** with context from previous agent\n2. **Collect output** as structured handoff document\n3. **Pass to next agent** in chain\n4. **Aggregate results** into final report\n\n## Handoff Document Format\n\nBetween agents, create handoff document:\n\n```markdown\n## HANDOFF: [previous-agent] -> [next-agent]\n\n### Context\n[Summary of what was done]\n\n### Findings\n[Key discoveries or decisions]\n\n### Files Modified\n[List of files touched]\n\n### Open Questions\n[Unresolved items for next agent]\n\n### Recommendations\n[Suggested next steps]\n```\n\n## Example: Feature Workflow\n\n```\n/orchestrate feature \"Add user authentication\"\n```\n\nExecutes:\n\n1. **Planner Agent**\n   - Analyzes requirements\n   - Creates implementation plan\n   - Identifies dependencies\n   - Output: `HANDOFF: planner -> tdd-guide`\n\n2. **TDD Guide Agent**\n   - Reads planner handoff\n   - Writes tests first\n   - Implements to pass tests\n   - Output: `HANDOFF: tdd-guide -> code-reviewer`\n\n3. **Code Reviewer Agent**\n   - Reviews implementation\n   - Checks for issues\n   - Suggests improvements\n   - Output: `HANDOFF: code-reviewer -> security-reviewer`\n\n4. **Security Reviewer Agent**\n   - Security audit\n   - Vulnerability check\n   - Final approval\n   - Output: Final Report\n\n## Final Report Format\n\n```\nORCHESTRATION REPORT\n====================\nWorkflow: feature\nTask: Add user authentication\nAgents: planner -> tdd-guide -> code-reviewer -> security-reviewer\n\nSUMMARY\n-------\n[One paragraph summary]\n\nAGENT OUTPUTS\n-------------\nPlanner: [summary]\nTDD Guide: [summary]\nCode Reviewer: [summary]\nSecurity Reviewer: [summary]\n\nFILES CHANGED\n-------------\n[List all files modified]\n\nTEST RESULTS\n------------\n[Test pass/fail summary]\n\nSECURITY STATUS\n---------------\n[Security findings]\n\nRECOMMENDATION\n--------------\n[SHIP / NEEDS WORK / BLOCKED]\n```\n\n## Parallel Execution\n\nFor independent checks, run agents in parallel:\n\n```markdown\n### Parallel Phase\nRun simultaneously:\n- code-reviewer (quality)\n- security-reviewer (security)\n- architect (design)\n\n### Merge Results\nCombine outputs into single report\n```\n\n## Arguments\n\n$ARGUMENTS:\n- `feature <description>` - Full feature workflow\n- `bugfix <description>` - Bug fix workflow\n- `refactor <description>` - Refactoring workflow\n- `security <description>` - Security review workflow\n- `custom <agents> <description>` - Custom agent sequence\n\n## Custom Workflow Example\n\n```\n/orchestrate custom \"architect,tdd-guide,code-reviewer\" \"Redesign caching layer\"\n```\n\n## Tips\n\n1. **Start with planner** for complex features\n2. **Always include code-reviewer** before merge\n3. **Use security-reviewer** for auth/payment/PII\n4. **Keep handoffs concise** - focus on what next agent needs\n5. **Run verification** between agents if needed\n",
        "commands/plan.md": "---\ndescription: Restate requirements, assess risks, and create step-by-step implementation plan. WAIT for user CONFIRM before touching any code.\n---\n\n# Plan Command\n\nThis command invokes the **planner** agent to create a comprehensive implementation plan before writing any code.\n\n## What This Command Does\n\n1. **Restate Requirements** - Clarify what needs to be built\n2. **Identify Risks** - Surface potential issues and blockers\n3. **Create Step Plan** - Break down implementation into phases\n4. **Wait for Confirmation** - MUST receive user approval before proceeding\n\n## When to Use\n\nUse `/plan` when:\n- Starting a new feature\n- Making significant architectural changes\n- Working on complex refactoring\n- Multiple files/components will be affected\n- Requirements are unclear or ambiguous\n\n## How It Works\n\nThe planner agent will:\n\n1. **Analyze the request** and restate requirements in clear terms\n2. **Break down into phases** with specific, actionable steps\n3. **Identify dependencies** between components\n4. **Assess risks** and potential blockers\n5. **Estimate complexity** (High/Medium/Low)\n6. **Present the plan** and WAIT for your explicit confirmation\n\n## Example Usage\n\n```\nUser: /plan I need to add real-time notifications when markets resolve\n\nAgent (planner):\n# Implementation Plan: Real-Time Market Resolution Notifications\n\n## Requirements Restatement\n- Send notifications to users when markets they're watching resolve\n- Support multiple notification channels (in-app, email, webhook)\n- Ensure notifications are delivered reliably\n- Include market outcome and user's position result\n\n## Implementation Phases\n\n### Phase 1: Database Schema\n- Add notifications table with columns: id, user_id, market_id, type, status, created_at\n- Add user_notification_preferences table for channel preferences\n- Create indexes on user_id and market_id for performance\n\n### Phase 2: Notification Service\n- Create notification service in lib/notifications.ts\n- Implement notification queue using BullMQ/Redis\n- Add retry logic for failed deliveries\n- Create notification templates\n\n### Phase 3: Integration Points\n- Hook into market resolution logic (when status changes to \"resolved\")\n- Query all users with positions in market\n- Enqueue notifications for each user\n\n### Phase 4: Frontend Components\n- Create NotificationBell component in header\n- Add NotificationList modal\n- Implement real-time updates via Supabase subscriptions\n- Add notification preferences page\n\n## Dependencies\n- Redis (for queue)\n- Email service (SendGrid/Resend)\n- Supabase real-time subscriptions\n\n## Risks\n- HIGH: Email deliverability (SPF/DKIM required)\n- MEDIUM: Performance with 1000+ users per market\n- MEDIUM: Notification spam if markets resolve frequently\n- LOW: Real-time subscription overhead\n\n## Estimated Complexity: MEDIUM\n- Backend: 4-6 hours\n- Frontend: 3-4 hours\n- Testing: 2-3 hours\n- Total: 9-13 hours\n\n**WAITING FOR CONFIRMATION**: Proceed with this plan? (yes/no/modify)\n```\n\n## Important Notes\n\n**CRITICAL**: The planner agent will **NOT** write any code until you explicitly confirm the plan with \"yes\" or \"proceed\" or similar affirmative response.\n\nIf you want changes, respond with:\n- \"modify: [your changes]\"\n- \"different approach: [alternative]\"\n- \"skip phase 2 and do phase 3 first\"\n\n## Integration with Other Commands\n\nAfter planning:\n- Use `/tdd` to implement with test-driven development\n- Use `/build-and-fix` if build errors occur\n- Use `/code-review` to review completed implementation\n\n## Related Agents\n\nThis command invokes the `planner` agent located at:\n`~/.claude/agents/planner.md`\n",
        "commands/refactor-clean.md": "# Refactor Clean\n\nSafely identify and remove dead code with test verification:\n\n1. Run dead code analysis tools:\n   - knip: Find unused exports and files\n   - depcheck: Find unused dependencies\n   - ts-prune: Find unused TypeScript exports\n\n2. Generate comprehensive report in .reports/dead-code-analysis.md\n\n3. Categorize findings by severity:\n   - SAFE: Test files, unused utilities\n   - CAUTION: API routes, components\n   - DANGER: Config files, main entry points\n\n4. Propose safe deletions only\n\n5. Before each deletion:\n   - Run full test suite\n   - Verify tests pass\n   - Apply change\n   - Re-run tests\n   - Rollback if tests fail\n\n6. Show summary of cleaned items\n\nNever delete code without running tests first!\n",
        "commands/setup-pm.md": "---\ndescription: Configure your preferred package manager (npm/pnpm/yarn/bun)\ndisable-model-invocation: true\n---\n\n# Package Manager Setup\n\nConfigure your preferred package manager for this project or globally.\n\n## Usage\n\n```bash\n# Detect current package manager\nnode scripts/setup-package-manager.js --detect\n\n# Set global preference\nnode scripts/setup-package-manager.js --global pnpm\n\n# Set project preference\nnode scripts/setup-package-manager.js --project bun\n\n# List available package managers\nnode scripts/setup-package-manager.js --list\n```\n\n## Detection Priority\n\nWhen determining which package manager to use, the following order is checked:\n\n1. **Environment variable**: `CLAUDE_PACKAGE_MANAGER`\n2. **Project config**: `.claude/package-manager.json`\n3. **package.json**: `packageManager` field\n4. **Lock file**: Presence of package-lock.json, yarn.lock, pnpm-lock.yaml, or bun.lockb\n5. **Global config**: `~/.claude/package-manager.json`\n6. **Fallback**: First available package manager (pnpm > bun > yarn > npm)\n\n## Configuration Files\n\n### Global Configuration\n```json\n// ~/.claude/package-manager.json\n{\n  \"packageManager\": \"pnpm\"\n}\n```\n\n### Project Configuration\n```json\n// .claude/package-manager.json\n{\n  \"packageManager\": \"bun\"\n}\n```\n\n### package.json\n```json\n{\n  \"packageManager\": \"pnpm@8.6.0\"\n}\n```\n\n## Environment Variable\n\nSet `CLAUDE_PACKAGE_MANAGER` to override all other detection methods:\n\n```bash\n# Windows (PowerShell)\n$env:CLAUDE_PACKAGE_MANAGER = \"pnpm\"\n\n# macOS/Linux\nexport CLAUDE_PACKAGE_MANAGER=pnpm\n```\n\n## Run the Detection\n\nTo see current package manager detection results, run:\n\n```bash\nnode scripts/setup-package-manager.js --detect\n```\n",
        "commands/tdd.md": "---\ndescription: Enforce test-driven development workflow. Scaffold interfaces, generate tests FIRST, then implement minimal code to pass. Ensure 80%+ coverage.\n---\n\n# TDD Command\n\nThis command invokes the **tdd-guide** agent to enforce test-driven development methodology.\n\n## What This Command Does\n\n1. **Scaffold Interfaces** - Define types/interfaces first\n2. **Generate Tests First** - Write failing tests (RED)\n3. **Implement Minimal Code** - Write just enough to pass (GREEN)\n4. **Refactor** - Improve code while keeping tests green (REFACTOR)\n5. **Verify Coverage** - Ensure 80%+ test coverage\n\n## When to Use\n\nUse `/tdd` when:\n- Implementing new features\n- Adding new functions/components\n- Fixing bugs (write test that reproduces bug first)\n- Refactoring existing code\n- Building critical business logic\n\n## How It Works\n\nThe tdd-guide agent will:\n\n1. **Define interfaces** for inputs/outputs\n2. **Write tests that will FAIL** (because code doesn't exist yet)\n3. **Run tests** and verify they fail for the right reason\n4. **Write minimal implementation** to make tests pass\n5. **Run tests** and verify they pass\n6. **Refactor** code while keeping tests green\n7. **Check coverage** and add more tests if below 80%\n\n## TDD Cycle\n\n```\nRED ‚Üí GREEN ‚Üí REFACTOR ‚Üí REPEAT\n\nRED:      Write a failing test\nGREEN:    Write minimal code to pass\nREFACTOR: Improve code, keep tests passing\nREPEAT:   Next feature/scenario\n```\n\n## Example Usage\n\n```\nUser: /tdd I need a function to calculate market liquidity score\n\nAgent (tdd-guide):\n# TDD Session: Market Liquidity Score Calculator\n\n## Step 1: Define Interface (SCAFFOLD)\n\n```typescript\n// lib/liquidity.ts\nexport interface MarketData {\n  totalVolume: number\n  bidAskSpread: number\n  activeTraders: number\n  lastTradeTime: Date\n}\n\nexport function calculateLiquidityScore(market: MarketData): number {\n  // TODO: Implementation\n  throw new Error('Not implemented')\n}\n```\n\n## Step 2: Write Failing Test (RED)\n\n```typescript\n// lib/liquidity.test.ts\nimport { calculateLiquidityScore } from './liquidity'\n\ndescribe('calculateLiquidityScore', () => {\n  it('should return high score for liquid market', () => {\n    const market = {\n      totalVolume: 100000,\n      bidAskSpread: 0.01,\n      activeTraders: 500,\n      lastTradeTime: new Date()\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBeGreaterThan(80)\n    expect(score).toBeLessThanOrEqual(100)\n  })\n\n  it('should return low score for illiquid market', () => {\n    const market = {\n      totalVolume: 100,\n      bidAskSpread: 0.5,\n      activeTraders: 2,\n      lastTradeTime: new Date(Date.now() - 86400000) // 1 day ago\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBeLessThan(30)\n    expect(score).toBeGreaterThanOrEqual(0)\n  })\n\n  it('should handle edge case: zero volume', () => {\n    const market = {\n      totalVolume: 0,\n      bidAskSpread: 0,\n      activeTraders: 0,\n      lastTradeTime: new Date()\n    }\n\n    const score = calculateLiquidityScore(market)\n\n    expect(score).toBe(0)\n  })\n})\n```\n\n## Step 3: Run Tests - Verify FAIL\n\n```bash\nnpm test lib/liquidity.test.ts\n\nFAIL lib/liquidity.test.ts\n  ‚úï should return high score for liquid market (2 ms)\n    Error: Not implemented\n\n1 test failed, 0 passed\n```\n\n‚úÖ Tests fail as expected. Ready to implement.\n\n## Step 4: Implement Minimal Code (GREEN)\n\n```typescript\n// lib/liquidity.ts\nexport function calculateLiquidityScore(market: MarketData): number {\n  // Handle zero volume edge case\n  if (market.totalVolume === 0) {\n    return 0\n  }\n\n  // Calculate component scores (0-100 scale)\n  const volumeScore = Math.min(market.totalVolume / 1000, 100)\n  const spreadScore = Math.max(100 - (market.bidAskSpread * 1000), 0)\n  const traderScore = Math.min(market.activeTraders / 10, 100)\n\n  // Recent activity bonus\n  const hoursSinceLastTrade = (Date.now() - market.lastTradeTime.getTime()) / (1000 * 60 * 60)\n  const recencyScore = Math.max(100 - (hoursSinceLastTrade * 10), 0)\n\n  // Weighted average\n  const score = (\n    volumeScore * 0.4 +\n    spreadScore * 0.3 +\n    traderScore * 0.2 +\n    recencyScore * 0.1\n  )\n\n  return Math.min(Math.max(score, 0), 100) // Clamp to 0-100\n}\n```\n\n## Step 5: Run Tests - Verify PASS\n\n```bash\nnpm test lib/liquidity.test.ts\n\nPASS lib/liquidity.test.ts\n  ‚úì should return high score for liquid market (3 ms)\n  ‚úì should return low score for illiquid market (2 ms)\n  ‚úì should handle edge case: zero volume (1 ms)\n\n3 tests passed\n```\n\n‚úÖ All tests passing!\n\n## Step 6: Refactor (IMPROVE)\n\n```typescript\n// lib/liquidity.ts - Refactored with constants and better readability\nconst WEIGHTS = {\n  VOLUME: 0.4,\n  SPREAD: 0.3,\n  TRADERS: 0.2,\n  RECENCY: 0.1,\n} as const\n\nconst SCALE_FACTORS = {\n  VOLUME: 1000,\n  SPREAD: 1000,\n  TRADERS: 10,\n  RECENCY_PENALTY: 10,\n} as const\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max)\n}\n\nexport function calculateLiquidityScore(market: MarketData): number {\n  if (market.totalVolume === 0) return 0\n\n  const volumeScore = Math.min(market.totalVolume / SCALE_FACTORS.VOLUME, 100)\n  const spreadScore = clamp(100 - (market.bidAskSpread * SCALE_FACTORS.SPREAD), 0, 100)\n  const traderScore = Math.min(market.activeTraders / SCALE_FACTORS.TRADERS, 100)\n\n  const hoursSinceLastTrade = (Date.now() - market.lastTradeTime.getTime()) / (1000 * 60 * 60)\n  const recencyScore = clamp(100 - (hoursSinceLastTrade * SCALE_FACTORS.RECENCY_PENALTY), 0, 100)\n\n  const weightedScore =\n    volumeScore * WEIGHTS.VOLUME +\n    spreadScore * WEIGHTS.SPREAD +\n    traderScore * WEIGHTS.TRADERS +\n    recencyScore * WEIGHTS.RECENCY\n\n  return clamp(weightedScore, 0, 100)\n}\n```\n\n## Step 7: Verify Tests Still Pass\n\n```bash\nnpm test lib/liquidity.test.ts\n\nPASS lib/liquidity.test.ts\n  ‚úì should return high score for liquid market (3 ms)\n  ‚úì should return low score for illiquid market (2 ms)\n  ‚úì should handle edge case: zero volume (1 ms)\n\n3 tests passed\n```\n\n‚úÖ Refactoring complete, tests still passing!\n\n## Step 8: Check Coverage\n\n```bash\nnpm test -- --coverage lib/liquidity.test.ts\n\nFile           | % Stmts | % Branch | % Funcs | % Lines\n---------------|---------|----------|---------|--------\nliquidity.ts   |   100   |   100    |   100   |   100\n\nCoverage: 100% ‚úÖ (Target: 80%)\n```\n\n‚úÖ TDD session complete!\n```\n\n## TDD Best Practices\n\n**DO:**\n- ‚úÖ Write the test FIRST, before any implementation\n- ‚úÖ Run tests and verify they FAIL before implementing\n- ‚úÖ Write minimal code to make tests pass\n- ‚úÖ Refactor only after tests are green\n- ‚úÖ Add edge cases and error scenarios\n- ‚úÖ Aim for 80%+ coverage (100% for critical code)\n\n**DON'T:**\n- ‚ùå Write implementation before tests\n- ‚ùå Skip running tests after each change\n- ‚ùå Write too much code at once\n- ‚ùå Ignore failing tests\n- ‚ùå Test implementation details (test behavior)\n- ‚ùå Mock everything (prefer integration tests)\n\n## Test Types to Include\n\n**Unit Tests** (Function-level):\n- Happy path scenarios\n- Edge cases (empty, null, max values)\n- Error conditions\n- Boundary values\n\n**Integration Tests** (Component-level):\n- API endpoints\n- Database operations\n- External service calls\n- React components with hooks\n\n**E2E Tests** (use `/e2e` command):\n- Critical user flows\n- Multi-step processes\n- Full stack integration\n\n## Coverage Requirements\n\n- **80% minimum** for all code\n- **100% required** for:\n  - Financial calculations\n  - Authentication logic\n  - Security-critical code\n  - Core business logic\n\n## Important Notes\n\n**MANDATORY**: Tests must be written BEFORE implementation. The TDD cycle is:\n\n1. **RED** - Write failing test\n2. **GREEN** - Implement to pass\n3. **REFACTOR** - Improve code\n\nNever skip the RED phase. Never write code before tests.\n\n## Integration with Other Commands\n\n- Use `/plan` first to understand what to build\n- Use `/tdd` to implement with tests\n- Use `/build-and-fix` if build errors occur\n- Use `/code-review` to review implementation\n- Use `/test-coverage` to verify coverage\n\n## Related Agents\n\nThis command invokes the `tdd-guide` agent located at:\n`~/.claude/agents/tdd-guide.md`\n\nAnd can reference the `tdd-workflow` skill at:\n`~/.claude/skills/tdd-workflow/`\n",
        "commands/test-coverage.md": "# Test Coverage\n\nAnalyze test coverage and generate missing tests:\n\n1. Run tests with coverage: npm test --coverage or pnpm test --coverage\n\n2. Analyze coverage report (coverage/coverage-summary.json)\n\n3. Identify files below 80% coverage threshold\n\n4. For each under-covered file:\n   - Analyze untested code paths\n   - Generate unit tests for functions\n   - Generate integration tests for APIs\n   - Generate E2E tests for critical flows\n\n5. Verify new tests pass\n\n6. Show before/after coverage metrics\n\n7. Ensure project reaches 80%+ overall coverage\n\nFocus on:\n- Happy path scenarios\n- Error handling\n- Edge cases (null, undefined, empty)\n- Boundary conditions\n",
        "commands/update-codemaps.md": "# Update Codemaps\n\nAnalyze the codebase structure and update architecture documentation:\n\n1. Scan all source files for imports, exports, and dependencies\n2. Generate token-lean codemaps in the following format:\n   - codemaps/architecture.md - Overall architecture\n   - codemaps/backend.md - Backend structure  \n   - codemaps/frontend.md - Frontend structure\n   - codemaps/data.md - Data models and schemas\n\n3. Calculate diff percentage from previous version\n4. If changes > 30%, request user approval before updating\n5. Add freshness timestamp to each codemap\n6. Save reports to .reports/codemap-diff.txt\n\nUse TypeScript/Node.js for analysis. Focus on high-level structure, not implementation details.\n",
        "commands/update-docs.md": "# Update Documentation\n\nSync documentation from source-of-truth:\n\n1. Read package.json scripts section\n   - Generate scripts reference table\n   - Include descriptions from comments\n\n2. Read .env.example\n   - Extract all environment variables\n   - Document purpose and format\n\n3. Generate docs/CONTRIB.md with:\n   - Development workflow\n   - Available scripts\n   - Environment setup\n   - Testing procedures\n\n4. Generate docs/RUNBOOK.md with:\n   - Deployment procedures\n   - Monitoring and alerts\n   - Common issues and fixes\n   - Rollback procedures\n\n5. Identify obsolete documentation:\n   - Find docs not modified in 90+ days\n   - List for manual review\n\n6. Show diff summary\n\nSingle source of truth: package.json and .env.example\n",
        "commands/verify.md": "# Verification Command\n\nRun comprehensive verification on current codebase state.\n\n## Instructions\n\nExecute verification in this exact order:\n\n1. **Build Check**\n   - Run the build command for this project\n   - If it fails, report errors and STOP\n\n2. **Type Check**\n   - Run TypeScript/type checker\n   - Report all errors with file:line\n\n3. **Lint Check**\n   - Run linter\n   - Report warnings and errors\n\n4. **Test Suite**\n   - Run all tests\n   - Report pass/fail count\n   - Report coverage percentage\n\n5. **Console.log Audit**\n   - Search for console.log in source files\n   - Report locations\n\n6. **Git Status**\n   - Show uncommitted changes\n   - Show files modified since last commit\n\n## Output\n\nProduce a concise verification report:\n\n```\nVERIFICATION: [PASS/FAIL]\n\nBuild:    [OK/FAIL]\nTypes:    [OK/X errors]\nLint:     [OK/X issues]\nTests:    [X/Y passed, Z% coverage]\nSecrets:  [OK/X found]\nLogs:     [OK/X console.logs]\n\nReady for PR: [YES/NO]\n```\n\nIf any critical issues, list them with fix suggestions.\n\n## Arguments\n\n$ARGUMENTS can be:\n- `quick` - Only build + types\n- `full` - All checks (default)\n- `pre-commit` - Checks relevant for commits\n- `pre-pr` - Full checks plus security scan\n",
        "hooks/hooks.json": "{\n  \"$schema\": \"https://json.schemastore.org/claude-code-settings.json\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"tool == \\\"Bash\\\" && tool_input.command matches \\\"(npm run dev|pnpm( run)? dev|yarn dev|bun run dev)\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"console.error('[Hook] BLOCKED: Dev server must run in tmux for log access');console.error('[Hook] Use: tmux new-session -d -s dev \\\\\\\"npm run dev\\\\\\\"');console.error('[Hook] Then: tmux attach -t dev');process.exit(1)\\\"\"\n          }\n        ],\n        \"description\": \"Block dev servers outside tmux - ensures you can access logs\"\n      },\n      {\n        \"matcher\": \"tool == \\\"Bash\\\" && tool_input.command matches \\\"(npm (install|test)|pnpm (install|test)|yarn (install|test)?|bun (install|test)|cargo build|make|docker|pytest|vitest|playwright)\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"if(!process.env.TMUX){console.error('[Hook] Consider running in tmux for session persistence');console.error('[Hook] tmux new -s dev  |  tmux attach -t dev')}\\\"\"\n          }\n        ],\n        \"description\": \"Reminder to use tmux for long-running commands\"\n      },\n      {\n        \"matcher\": \"tool == \\\"Bash\\\" && tool_input.command matches \\\"git push\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"console.error('[Hook] Review changes before push...');console.error('[Hook] Continuing with push (remove this hook to add interactive review)')\\\"\"\n          }\n        ],\n        \"description\": \"Reminder before git push to review changes\"\n      },\n      {\n        \"matcher\": \"tool == \\\"Write\\\" && tool_input.file_path matches \\\"\\\\\\\\.(md|txt)$\\\" && !(tool_input.file_path matches \\\"README\\\\\\\\.md|CLAUDE\\\\\\\\.md|AGENTS\\\\\\\\.md|CONTRIBUTING\\\\\\\\.md\\\")\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"const fs=require('fs');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{const i=JSON.parse(d);const p=i.tool_input?.file_path||'';if(/\\\\.(md|txt)$/.test(p)&&!/(README|CLAUDE|AGENTS|CONTRIBUTING)\\\\.md$/.test(p)){console.error('[Hook] BLOCKED: Unnecessary documentation file creation');console.error('[Hook] File: '+p);console.error('[Hook] Use README.md for documentation instead');process.exit(1)}console.log(d)})\\\"\"\n          }\n        ],\n        \"description\": \"Block creation of random .md files - keeps docs consolidated\"\n      },\n      {\n        \"matcher\": \"tool == \\\"Edit\\\" || tool == \\\"Write\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/suggest-compact.js\\\"\"\n          }\n        ],\n        \"description\": \"Suggest manual compaction at logical intervals\"\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/pre-compact.js\\\"\"\n          }\n        ],\n        \"description\": \"Save state before context compaction\"\n      }\n    ],\n    \"SessionStart\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/session-start.js\\\"\"\n          }\n        ],\n        \"description\": \"Load previous context and detect package manager on new session\"\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"tool == \\\"Bash\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{const i=JSON.parse(d);const cmd=i.tool_input?.command||'';if(/gh pr create/.test(cmd)){const out=i.tool_output?.output||'';const m=out.match(/https:\\\\/\\\\/github.com\\\\/[^/]+\\\\/[^/]+\\\\/pull\\\\/\\\\d+/);if(m){console.error('[Hook] PR created: '+m[0]);const repo=m[0].replace(/https:\\\\/\\\\/github.com\\\\/([^/]+\\\\/[^/]+)\\\\/pull\\\\/\\\\d+/,'$1');const pr=m[0].replace(/.*\\\\/pull\\\\/(\\\\d+)/,'$1');console.error('[Hook] To review: gh pr review '+pr+' --repo '+repo)}}console.log(d)})\\\"\"\n          }\n        ],\n        \"description\": \"Log PR URL and provide review command after PR creation\"\n      },\n      {\n        \"matcher\": \"tool == \\\"Edit\\\" && tool_input.file_path matches \\\"\\\\\\\\.(ts|tsx|js|jsx)$\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"const{execSync}=require('child_process');const fs=require('fs');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{const i=JSON.parse(d);const p=i.tool_input?.file_path;if(p&&fs.existsSync(p)){try{execSync('npx prettier --write \\\"'+p+'\\\"',{stdio:['pipe','pipe','pipe']})}catch(e){}}console.log(d)})\\\"\"\n          }\n        ],\n        \"description\": \"Auto-format JS/TS files with Prettier after edits\"\n      },\n      {\n        \"matcher\": \"tool == \\\"Edit\\\" && tool_input.file_path matches \\\"\\\\\\\\.(ts|tsx)$\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"const{execSync}=require('child_process');const fs=require('fs');const path=require('path');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{const i=JSON.parse(d);const p=i.tool_input?.file_path;if(p&&fs.existsSync(p)){let dir=path.dirname(p);while(dir!==path.dirname(dir)&&!fs.existsSync(path.join(dir,'tsconfig.json'))){dir=path.dirname(dir)}if(fs.existsSync(path.join(dir,'tsconfig.json'))){try{const r=execSync('npx tsc --noEmit --pretty false 2>&1',{cwd:dir,encoding:'utf8',stdio:['pipe','pipe','pipe']});const lines=r.split('\\\\n').filter(l=>l.includes(p)).slice(0,10);if(lines.length)console.error(lines.join('\\\\n'))}catch(e){const lines=(e.stdout||'').split('\\\\n').filter(l=>l.includes(p)).slice(0,10);if(lines.length)console.error(lines.join('\\\\n'))}}}console.log(d)})\\\"\"\n          }\n        ],\n        \"description\": \"TypeScript check after editing .ts/.tsx files\"\n      },\n      {\n        \"matcher\": \"tool == \\\"Edit\\\" && tool_input.file_path matches \\\"\\\\\\\\.(ts|tsx|js|jsx)$\\\"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"const fs=require('fs');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{const i=JSON.parse(d);const p=i.tool_input?.file_path;if(p&&fs.existsSync(p)){const c=fs.readFileSync(p,'utf8');const lines=c.split('\\\\n');const matches=[];lines.forEach((l,idx)=>{if(/console\\\\.log/.test(l))matches.push((idx+1)+': '+l.trim())});if(matches.length){console.error('[Hook] WARNING: console.log found in '+p);matches.slice(0,5).forEach(m=>console.error(m));console.error('[Hook] Remove console.log before committing')}}console.log(d)})\\\"\"\n          }\n        ],\n        \"description\": \"Warn about console.log statements after edits\"\n      }\n    ],\n    \"Stop\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node -e \\\"const{execSync}=require('child_process');const fs=require('fs');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{try{execSync('git rev-parse --git-dir',{stdio:'pipe'})}catch{console.log(d);process.exit(0)}try{const files=execSync('git diff --name-only HEAD',{encoding:'utf8',stdio:['pipe','pipe','pipe']}).split('\\\\n').filter(f=>/\\\\.(ts|tsx|js|jsx)$/.test(f)&&fs.existsSync(f));let hasConsole=false;for(const f of files){if(fs.readFileSync(f,'utf8').includes('console.log')){console.error('[Hook] WARNING: console.log found in '+f);hasConsole=true}}if(hasConsole)console.error('[Hook] Remove console.log statements before committing')}catch(e){}console.log(d)})\\\"\"\n          }\n        ],\n        \"description\": \"Check for console.log in modified files after each response\"\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/session-end.js\\\"\"\n          }\n        ],\n        \"description\": \"Persist session state on end\"\n      },\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node \\\"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/evaluate-session.js\\\"\"\n          }\n        ],\n        \"description\": \"Evaluate session for extractable patterns\"\n      }\n    ]\n  }\n}\n",
        "hooks/memory-persistence/pre-compact.sh": "#!/bin/bash\n# PreCompact Hook - Save state before context compaction\n#\n# Runs before Claude compacts context, giving you a chance to\n# preserve important state that might get lost in summarization.\n#\n# Hook config (in ~/.claude/settings.json):\n# {\n#   \"hooks\": {\n#     \"PreCompact\": [{\n#       \"matcher\": \"*\",\n#       \"hooks\": [{\n#         \"type\": \"command\",\n#         \"command\": \"~/.claude/hooks/memory-persistence/pre-compact.sh\"\n#       }]\n#     }]\n#   }\n# }\n\nSESSIONS_DIR=\"${HOME}/.claude/sessions\"\nCOMPACTION_LOG=\"${SESSIONS_DIR}/compaction-log.txt\"\n\nmkdir -p \"$SESSIONS_DIR\"\n\n# Log compaction event with timestamp\necho \"[$(date '+%Y-%m-%d %H:%M:%S')] Context compaction triggered\" >> \"$COMPACTION_LOG\"\n\n# If there's an active session file, note the compaction\nACTIVE_SESSION=$(ls -t \"$SESSIONS_DIR\"/*.tmp 2>/dev/null | head -1)\nif [ -n \"$ACTIVE_SESSION\" ]; then\n  echo \"\" >> \"$ACTIVE_SESSION\"\n  echo \"---\" >> \"$ACTIVE_SESSION\"\n  echo \"**[Compaction occurred at $(date '+%H:%M')]** - Context was summarized\" >> \"$ACTIVE_SESSION\"\nfi\n\necho \"[PreCompact] State saved before compaction\" >&2\n",
        "hooks/memory-persistence/session-end.sh": "#!/bin/bash\n# Stop Hook (Session End) - Persist learnings when session ends\n#\n# Runs when Claude session ends. Creates/updates session log file\n# with timestamp for continuity tracking.\n#\n# Hook config (in ~/.claude/settings.json):\n# {\n#   \"hooks\": {\n#     \"Stop\": [{\n#       \"matcher\": \"*\",\n#       \"hooks\": [{\n#         \"type\": \"command\",\n#         \"command\": \"~/.claude/hooks/memory-persistence/session-end.sh\"\n#       }]\n#     }]\n#   }\n# }\n\nSESSIONS_DIR=\"${HOME}/.claude/sessions\"\nTODAY=$(date '+%Y-%m-%d')\nSESSION_FILE=\"${SESSIONS_DIR}/${TODAY}-session.tmp\"\n\nmkdir -p \"$SESSIONS_DIR\"\n\n# If session file exists for today, update the end time\nif [ -f \"$SESSION_FILE\" ]; then\n  # Update Last Updated timestamp\n  sed -i '' \"s/\\*\\*Last Updated:\\*\\*.*/\\*\\*Last Updated:\\*\\* $(date '+%H:%M')/\" \"$SESSION_FILE\" 2>/dev/null || \\\n  sed -i \"s/\\*\\*Last Updated:\\*\\*.*/\\*\\*Last Updated:\\*\\* $(date '+%H:%M')/\" \"$SESSION_FILE\" 2>/dev/null\n  echo \"[SessionEnd] Updated session file: $SESSION_FILE\" >&2\nelse\n  # Create new session file with template\n  cat > \"$SESSION_FILE\" << EOF\n# Session: $(date '+%Y-%m-%d')\n**Date:** $TODAY\n**Started:** $(date '+%H:%M')\n**Last Updated:** $(date '+%H:%M')\n\n---\n\n## Current State\n\n[Session context goes here]\n\n### Completed\n- [ ]\n\n### In Progress\n- [ ]\n\n### Notes for Next Session\n-\n\n### Context to Load\n\\`\\`\\`\n[relevant files]\n\\`\\`\\`\nEOF\n  echo \"[SessionEnd] Created session file: $SESSION_FILE\" >&2\nfi\n",
        "hooks/memory-persistence/session-start.sh": "#!/bin/bash\n# SessionStart Hook - Load previous context on new session\n#\n# Runs when a new Claude session starts. Checks for recent session\n# files and notifies Claude of available context to load.\n#\n# Hook config (in ~/.claude/settings.json):\n# {\n#   \"hooks\": {\n#     \"SessionStart\": [{\n#       \"matcher\": \"*\",\n#       \"hooks\": [{\n#         \"type\": \"command\",\n#         \"command\": \"~/.claude/hooks/memory-persistence/session-start.sh\"\n#       }]\n#     }]\n#   }\n# }\n\nSESSIONS_DIR=\"${HOME}/.claude/sessions\"\nLEARNED_DIR=\"${HOME}/.claude/skills/learned\"\n\n# Check for recent session files (last 7 days)\nrecent_sessions=$(find \"$SESSIONS_DIR\" -name \"*.tmp\" -mtime -7 2>/dev/null | wc -l | tr -d ' ')\n\nif [ \"$recent_sessions\" -gt 0 ]; then\n  latest=$(ls -t \"$SESSIONS_DIR\"/*.tmp 2>/dev/null | head -1)\n  echo \"[SessionStart] Found $recent_sessions recent session(s)\" >&2\n  echo \"[SessionStart] Latest: $latest\" >&2\nfi\n\n# Check for learned skills\nlearned_count=$(find \"$LEARNED_DIR\" -name \"*.md\" 2>/dev/null | wc -l | tr -d ' ')\n\nif [ \"$learned_count\" -gt 0 ]; then\n  echo \"[SessionStart] $learned_count learned skill(s) available in $LEARNED_DIR\" >&2\nfi\n",
        "hooks/strategic-compact/suggest-compact.sh": "#!/bin/bash\n# Strategic Compact Suggester\n# Runs on PreToolUse or periodically to suggest manual compaction at logical intervals\n#\n# Why manual over auto-compact:\n# - Auto-compact happens at arbitrary points, often mid-task\n# - Strategic compacting preserves context through logical phases\n# - Compact after exploration, before execution\n# - Compact after completing a milestone, before starting next\n#\n# Hook config (in ~/.claude/settings.json):\n# {\n#   \"hooks\": {\n#     \"PreToolUse\": [{\n#       \"matcher\": \"Edit|Write\",\n#       \"hooks\": [{\n#         \"type\": \"command\",\n#         \"command\": \"~/.claude/skills/strategic-compact/suggest-compact.sh\"\n#       }]\n#     }]\n#   }\n# }\n#\n# Criteria for suggesting compact:\n# - Session has been running for extended period\n# - Large number of tool calls made\n# - Transitioning from research/exploration to implementation\n# - Plan has been finalized\n\n# Track tool call count (increment in a temp file)\nCOUNTER_FILE=\"/tmp/claude-tool-count-$$\"\nTHRESHOLD=${COMPACT_THRESHOLD:-50}\n\n# Initialize or increment counter\nif [ -f \"$COUNTER_FILE\" ]; then\n  count=$(cat \"$COUNTER_FILE\")\n  count=$((count + 1))\n  echo \"$count\" > \"$COUNTER_FILE\"\nelse\n  echo \"1\" > \"$COUNTER_FILE\"\n  count=1\nfi\n\n# Suggest compact after threshold tool calls\nif [ \"$count\" -eq \"$THRESHOLD\" ]; then\n  echo \"[StrategicCompact] $THRESHOLD tool calls reached - consider /compact if transitioning phases\" >&2\nfi\n\n# Suggest at regular intervals after threshold\nif [ \"$count\" -gt \"$THRESHOLD\" ] && [ $((count % 25)) -eq 0 ]; then\n  echo \"[StrategicCompact] $count tool calls - good checkpoint for /compact if context is stale\" >&2\nfi\n",
        "plugins/README.md": "# Plugins and Marketplaces\n\nPlugins extend Claude Code with new tools and capabilities. This guide covers installation only - see the [full article](https://x.com/affaanmustafa/status/2012378465664745795) for when and why to use them.\n\n---\n\n## Marketplaces\n\nMarketplaces are repositories of installable plugins.\n\n### Adding a Marketplace\n\n```bash\n# Add official Anthropic marketplace\nclaude plugin marketplace add https://github.com/anthropics/claude-plugins-official\n\n# Add community marketplaces\nclaude plugin marketplace add https://github.com/mixedbread-ai/mgrep\n```\n\n### Recommended Marketplaces\n\n| Marketplace | Source |\n|-------------|--------|\n| claude-plugins-official | `anthropics/claude-plugins-official` |\n| claude-code-plugins | `anthropics/claude-code` |\n| Mixedbread-Grep | `mixedbread-ai/mgrep` |\n\n---\n\n## Installing Plugins\n\n```bash\n# Open plugins browser\n/plugins\n\n# Or install directly\nclaude plugin install typescript-lsp@claude-plugins-official\n```\n\n### Recommended Plugins\n\n**Development:**\n- `typescript-lsp` - TypeScript intelligence\n- `pyright-lsp` - Python type checking\n- `hookify` - Create hooks conversationally\n- `code-simplifier` - Refactor code\n\n**Code Quality:**\n- `code-review` - Code review\n- `pr-review-toolkit` - PR automation\n- `security-guidance` - Security checks\n\n**Search:**\n- `mgrep` - Enhanced search (better than ripgrep)\n- `context7` - Live documentation lookup\n\n**Workflow:**\n- `commit-commands` - Git workflow\n- `frontend-design` - UI patterns\n- `feature-dev` - Feature development\n\n---\n\n## Quick Setup\n\n```bash\n# Add marketplaces\nclaude plugin marketplace add https://github.com/anthropics/claude-plugins-official\nclaude plugin marketplace add https://github.com/mixedbread-ai/mgrep\n\n# Open /plugins and install what you need\n```\n\n---\n\n## Plugin Files Location\n\n```\n~/.claude/plugins/\n|-- cache/                    # Downloaded plugins\n|-- installed_plugins.json    # Installed list\n|-- known_marketplaces.json   # Added marketplaces\n|-- marketplaces/             # Marketplace data\n```\n",
        "scripts/hooks/evaluate-session.js": "#!/usr/bin/env node\n/**\n * Continuous Learning - Session Evaluator\n *\n * Cross-platform (Windows, macOS, Linux)\n *\n * Runs on Stop hook to extract reusable patterns from Claude Code sessions\n *\n * Why Stop hook instead of UserPromptSubmit:\n * - Stop runs once at session end (lightweight)\n * - UserPromptSubmit runs every message (heavy, adds latency)\n */\n\nconst path = require('path');\nconst fs = require('fs');\nconst {\n  getLearnedSkillsDir,\n  ensureDir,\n  readFile,\n  countInFile,\n  log\n} = require('../lib/utils');\n\nasync function main() {\n  // Get script directory to find config\n  const scriptDir = __dirname;\n  const configFile = path.join(scriptDir, '..', '..', 'skills', 'continuous-learning', 'config.json');\n\n  // Default configuration\n  let minSessionLength = 10;\n  let learnedSkillsPath = getLearnedSkillsDir();\n\n  // Load config if exists\n  const configContent = readFile(configFile);\n  if (configContent) {\n    try {\n      const config = JSON.parse(configContent);\n      minSessionLength = config.min_session_length || 10;\n\n      if (config.learned_skills_path) {\n        // Handle ~ in path\n        learnedSkillsPath = config.learned_skills_path.replace(/^~/, require('os').homedir());\n      }\n    } catch {\n      // Invalid config, use defaults\n    }\n  }\n\n  // Ensure learned skills directory exists\n  ensureDir(learnedSkillsPath);\n\n  // Get transcript path from environment (set by Claude Code)\n  const transcriptPath = process.env.CLAUDE_TRANSCRIPT_PATH;\n\n  if (!transcriptPath || !fs.existsSync(transcriptPath)) {\n    process.exit(0);\n  }\n\n  // Count user messages in session\n  const messageCount = countInFile(transcriptPath, /\"type\":\"user\"/g);\n\n  // Skip short sessions\n  if (messageCount < minSessionLength) {\n    log(`[ContinuousLearning] Session too short (${messageCount} messages), skipping`);\n    process.exit(0);\n  }\n\n  // Signal to Claude that session should be evaluated for extractable patterns\n  log(`[ContinuousLearning] Session has ${messageCount} messages - evaluate for extractable patterns`);\n  log(`[ContinuousLearning] Save learned skills to: ${learnedSkillsPath}`);\n\n  process.exit(0);\n}\n\nmain().catch(err => {\n  console.error('[ContinuousLearning] Error:', err.message);\n  process.exit(0);\n});\n",
        "scripts/hooks/pre-compact.js": "#!/usr/bin/env node\n/**\n * PreCompact Hook - Save state before context compaction\n *\n * Cross-platform (Windows, macOS, Linux)\n *\n * Runs before Claude compacts context, giving you a chance to\n * preserve important state that might get lost in summarization.\n */\n\nconst path = require('path');\nconst {\n  getSessionsDir,\n  getDateTimeString,\n  getTimeString,\n  findFiles,\n  ensureDir,\n  appendFile,\n  log\n} = require('../lib/utils');\n\nasync function main() {\n  const sessionsDir = getSessionsDir();\n  const compactionLog = path.join(sessionsDir, 'compaction-log.txt');\n\n  ensureDir(sessionsDir);\n\n  // Log compaction event with timestamp\n  const timestamp = getDateTimeString();\n  appendFile(compactionLog, `[${timestamp}] Context compaction triggered\\n`);\n\n  // If there's an active session file, note the compaction\n  const sessions = findFiles(sessionsDir, '*.tmp');\n\n  if (sessions.length > 0) {\n    const activeSession = sessions[0].path;\n    const timeStr = getTimeString();\n    appendFile(activeSession, `\\n---\\n**[Compaction occurred at ${timeStr}]** - Context was summarized\\n`);\n  }\n\n  log('[PreCompact] State saved before compaction');\n  process.exit(0);\n}\n\nmain().catch(err => {\n  console.error('[PreCompact] Error:', err.message);\n  process.exit(0);\n});\n",
        "scripts/hooks/session-end.js": "#!/usr/bin/env node\n/**\n * Stop Hook (Session End) - Persist learnings when session ends\n *\n * Cross-platform (Windows, macOS, Linux)\n *\n * Runs when Claude session ends. Creates/updates session log file\n * with timestamp for continuity tracking.\n */\n\nconst path = require('path');\nconst fs = require('fs');\nconst {\n  getSessionsDir,\n  getDateString,\n  getTimeString,\n  ensureDir,\n  readFile,\n  writeFile,\n  replaceInFile,\n  log\n} = require('../lib/utils');\n\nasync function main() {\n  const sessionsDir = getSessionsDir();\n  const today = getDateString();\n  const sessionFile = path.join(sessionsDir, `${today}-session.tmp`);\n\n  ensureDir(sessionsDir);\n\n  const currentTime = getTimeString();\n\n  // If session file exists for today, update the end time\n  if (fs.existsSync(sessionFile)) {\n    const success = replaceInFile(\n      sessionFile,\n      /\\*\\*Last Updated:\\*\\*.*/,\n      `**Last Updated:** ${currentTime}`\n    );\n\n    if (success) {\n      log(`[SessionEnd] Updated session file: ${sessionFile}`);\n    }\n  } else {\n    // Create new session file with template\n    const template = `# Session: ${today}\n**Date:** ${today}\n**Started:** ${currentTime}\n**Last Updated:** ${currentTime}\n\n---\n\n## Current State\n\n[Session context goes here]\n\n### Completed\n- [ ]\n\n### In Progress\n- [ ]\n\n### Notes for Next Session\n-\n\n### Context to Load\n\\`\\`\\`\n[relevant files]\n\\`\\`\\`\n`;\n\n    writeFile(sessionFile, template);\n    log(`[SessionEnd] Created session file: ${sessionFile}`);\n  }\n\n  process.exit(0);\n}\n\nmain().catch(err => {\n  console.error('[SessionEnd] Error:', err.message);\n  process.exit(0);\n});\n",
        "scripts/hooks/session-start.js": "#!/usr/bin/env node\n/**\n * SessionStart Hook - Load previous context on new session\n *\n * Cross-platform (Windows, macOS, Linux)\n *\n * Runs when a new Claude session starts. Checks for recent session\n * files and notifies Claude of available context to load.\n */\n\nconst path = require('path');\nconst {\n  getSessionsDir,\n  getLearnedSkillsDir,\n  findFiles,\n  ensureDir,\n  log\n} = require('../lib/utils');\nconst { getPackageManager, getSelectionPrompt } = require('../lib/package-manager');\n\nasync function main() {\n  const sessionsDir = getSessionsDir();\n  const learnedDir = getLearnedSkillsDir();\n\n  // Ensure directories exist\n  ensureDir(sessionsDir);\n  ensureDir(learnedDir);\n\n  // Check for recent session files (last 7 days)\n  const recentSessions = findFiles(sessionsDir, '*.tmp', { maxAge: 7 });\n\n  if (recentSessions.length > 0) {\n    const latest = recentSessions[0];\n    log(`[SessionStart] Found ${recentSessions.length} recent session(s)`);\n    log(`[SessionStart] Latest: ${latest.path}`);\n  }\n\n  // Check for learned skills\n  const learnedSkills = findFiles(learnedDir, '*.md');\n\n  if (learnedSkills.length > 0) {\n    log(`[SessionStart] ${learnedSkills.length} learned skill(s) available in ${learnedDir}`);\n  }\n\n  // Detect and report package manager\n  const pm = getPackageManager();\n  log(`[SessionStart] Package manager: ${pm.name} (${pm.source})`);\n\n  // If package manager was detected via fallback, show selection prompt\n  if (pm.source === 'fallback' || pm.source === 'default') {\n    log('[SessionStart] No package manager preference found.');\n    log(getSelectionPrompt());\n  }\n\n  process.exit(0);\n}\n\nmain().catch(err => {\n  console.error('[SessionStart] Error:', err.message);\n  process.exit(0); // Don't block on errors\n});\n",
        "scripts/hooks/suggest-compact.js": "#!/usr/bin/env node\n/**\n * Strategic Compact Suggester\n *\n * Cross-platform (Windows, macOS, Linux)\n *\n * Runs on PreToolUse or periodically to suggest manual compaction at logical intervals\n *\n * Why manual over auto-compact:\n * - Auto-compact happens at arbitrary points, often mid-task\n * - Strategic compacting preserves context through logical phases\n * - Compact after exploration, before execution\n * - Compact after completing a milestone, before starting next\n */\n\nconst path = require('path');\nconst fs = require('fs');\nconst {\n  getTempDir,\n  readFile,\n  writeFile,\n  log\n} = require('../lib/utils');\n\nasync function main() {\n  // Track tool call count (increment in a temp file)\n  // Use a session-specific counter file based on PID from parent process\n  // or session ID from environment\n  const sessionId = process.env.CLAUDE_SESSION_ID || process.ppid || 'default';\n  const counterFile = path.join(getTempDir(), `claude-tool-count-${sessionId}`);\n  const threshold = parseInt(process.env.COMPACT_THRESHOLD || '50', 10);\n\n  let count = 1;\n\n  // Read existing count or start at 1\n  const existing = readFile(counterFile);\n  if (existing) {\n    count = parseInt(existing.trim(), 10) + 1;\n  }\n\n  // Save updated count\n  writeFile(counterFile, String(count));\n\n  // Suggest compact after threshold tool calls\n  if (count === threshold) {\n    log(`[StrategicCompact] ${threshold} tool calls reached - consider /compact if transitioning phases`);\n  }\n\n  // Suggest at regular intervals after threshold\n  if (count > threshold && count % 25 === 0) {\n    log(`[StrategicCompact] ${count} tool calls - good checkpoint for /compact if context is stale`);\n  }\n\n  process.exit(0);\n}\n\nmain().catch(err => {\n  console.error('[StrategicCompact] Error:', err.message);\n  process.exit(0);\n});\n",
        "skills/backend-patterns/SKILL.md": "---\nname: backend-patterns\ndescription: Backend architecture patterns, API design, database optimization, and server-side best practices for Node.js, Express, and Next.js API routes.\n---\n\n# Backend Development Patterns\n\nBackend architecture patterns and best practices for scalable server-side applications.\n\n## API Design Patterns\n\n### RESTful API Structure\n\n```typescript\n// ‚úÖ Resource-based URLs\nGET    /api/markets                 # List resources\nGET    /api/markets/:id             # Get single resource\nPOST   /api/markets                 # Create resource\nPUT    /api/markets/:id             # Replace resource\nPATCH  /api/markets/:id             # Update resource\nDELETE /api/markets/:id             # Delete resource\n\n// ‚úÖ Query parameters for filtering, sorting, pagination\nGET /api/markets?status=active&sort=volume&limit=20&offset=0\n```\n\n### Repository Pattern\n\n```typescript\n// Abstract data access logic\ninterface MarketRepository {\n  findAll(filters?: MarketFilters): Promise<Market[]>\n  findById(id: string): Promise<Market | null>\n  create(data: CreateMarketDto): Promise<Market>\n  update(id: string, data: UpdateMarketDto): Promise<Market>\n  delete(id: string): Promise<void>\n}\n\nclass SupabaseMarketRepository implements MarketRepository {\n  async findAll(filters?: MarketFilters): Promise<Market[]> {\n    let query = supabase.from('markets').select('*')\n\n    if (filters?.status) {\n      query = query.eq('status', filters.status)\n    }\n\n    if (filters?.limit) {\n      query = query.limit(filters.limit)\n    }\n\n    const { data, error } = await query\n\n    if (error) throw new Error(error.message)\n    return data\n  }\n\n  // Other methods...\n}\n```\n\n### Service Layer Pattern\n\n```typescript\n// Business logic separated from data access\nclass MarketService {\n  constructor(private marketRepo: MarketRepository) {}\n\n  async searchMarkets(query: string, limit: number = 10): Promise<Market[]> {\n    // Business logic\n    const embedding = await generateEmbedding(query)\n    const results = await this.vectorSearch(embedding, limit)\n\n    // Fetch full data\n    const markets = await this.marketRepo.findByIds(results.map(r => r.id))\n\n    // Sort by similarity\n    return markets.sort((a, b) => {\n      const scoreA = results.find(r => r.id === a.id)?.score || 0\n      const scoreB = results.find(r => r.id === b.id)?.score || 0\n      return scoreA - scoreB\n    })\n  }\n\n  private async vectorSearch(embedding: number[], limit: number) {\n    // Vector search implementation\n  }\n}\n```\n\n### Middleware Pattern\n\n```typescript\n// Request/response processing pipeline\nexport function withAuth(handler: NextApiHandler): NextApiHandler {\n  return async (req, res) => {\n    const token = req.headers.authorization?.replace('Bearer ', '')\n\n    if (!token) {\n      return res.status(401).json({ error: 'Unauthorized' })\n    }\n\n    try {\n      const user = await verifyToken(token)\n      req.user = user\n      return handler(req, res)\n    } catch (error) {\n      return res.status(401).json({ error: 'Invalid token' })\n    }\n  }\n}\n\n// Usage\nexport default withAuth(async (req, res) => {\n  // Handler has access to req.user\n})\n```\n\n## Database Patterns\n\n### Query Optimization\n\n```typescript\n// ‚úÖ GOOD: Select only needed columns\nconst { data } = await supabase\n  .from('markets')\n  .select('id, name, status, volume')\n  .eq('status', 'active')\n  .order('volume', { ascending: false })\n  .limit(10)\n\n// ‚ùå BAD: Select everything\nconst { data } = await supabase\n  .from('markets')\n  .select('*')\n```\n\n### N+1 Query Prevention\n\n```typescript\n// ‚ùå BAD: N+1 query problem\nconst markets = await getMarkets()\nfor (const market of markets) {\n  market.creator = await getUser(market.creator_id)  // N queries\n}\n\n// ‚úÖ GOOD: Batch fetch\nconst markets = await getMarkets()\nconst creatorIds = markets.map(m => m.creator_id)\nconst creators = await getUsers(creatorIds)  // 1 query\nconst creatorMap = new Map(creators.map(c => [c.id, c]))\n\nmarkets.forEach(market => {\n  market.creator = creatorMap.get(market.creator_id)\n})\n```\n\n### Transaction Pattern\n\n```typescript\nasync function createMarketWithPosition(\n  marketData: CreateMarketDto,\n  positionData: CreatePositionDto\n) {\n  // Use Supabase transaction\n  const { data, error } = await supabase.rpc('create_market_with_position', {\n    market_data: marketData,\n    position_data: positionData\n  })\n\n  if (error) throw new Error('Transaction failed')\n  return data\n}\n\n// SQL function in Supabase\nCREATE OR REPLACE FUNCTION create_market_with_position(\n  market_data jsonb,\n  position_data jsonb\n)\nRETURNS jsonb\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  -- Start transaction automatically\n  INSERT INTO markets VALUES (market_data);\n  INSERT INTO positions VALUES (position_data);\n  RETURN jsonb_build_object('success', true);\nEXCEPTION\n  WHEN OTHERS THEN\n    -- Rollback happens automatically\n    RETURN jsonb_build_object('success', false, 'error', SQLERRM);\nEND;\n$$;\n```\n\n## Caching Strategies\n\n### Redis Caching Layer\n\n```typescript\nclass CachedMarketRepository implements MarketRepository {\n  constructor(\n    private baseRepo: MarketRepository,\n    private redis: RedisClient\n  ) {}\n\n  async findById(id: string): Promise<Market | null> {\n    // Check cache first\n    const cached = await this.redis.get(`market:${id}`)\n\n    if (cached) {\n      return JSON.parse(cached)\n    }\n\n    // Cache miss - fetch from database\n    const market = await this.baseRepo.findById(id)\n\n    if (market) {\n      // Cache for 5 minutes\n      await this.redis.setex(`market:${id}`, 300, JSON.stringify(market))\n    }\n\n    return market\n  }\n\n  async invalidateCache(id: string): Promise<void> {\n    await this.redis.del(`market:${id}`)\n  }\n}\n```\n\n### Cache-Aside Pattern\n\n```typescript\nasync function getMarketWithCache(id: string): Promise<Market> {\n  const cacheKey = `market:${id}`\n\n  // Try cache\n  const cached = await redis.get(cacheKey)\n  if (cached) return JSON.parse(cached)\n\n  // Cache miss - fetch from DB\n  const market = await db.markets.findUnique({ where: { id } })\n\n  if (!market) throw new Error('Market not found')\n\n  // Update cache\n  await redis.setex(cacheKey, 300, JSON.stringify(market))\n\n  return market\n}\n```\n\n## Error Handling Patterns\n\n### Centralized Error Handler\n\n```typescript\nclass ApiError extends Error {\n  constructor(\n    public statusCode: number,\n    public message: string,\n    public isOperational = true\n  ) {\n    super(message)\n    Object.setPrototypeOf(this, ApiError.prototype)\n  }\n}\n\nexport function errorHandler(error: unknown, req: Request): Response {\n  if (error instanceof ApiError) {\n    return NextResponse.json({\n      success: false,\n      error: error.message\n    }, { status: error.statusCode })\n  }\n\n  if (error instanceof z.ZodError) {\n    return NextResponse.json({\n      success: false,\n      error: 'Validation failed',\n      details: error.errors\n    }, { status: 400 })\n  }\n\n  // Log unexpected errors\n  console.error('Unexpected error:', error)\n\n  return NextResponse.json({\n    success: false,\n    error: 'Internal server error'\n  }, { status: 500 })\n}\n\n// Usage\nexport async function GET(request: Request) {\n  try {\n    const data = await fetchData()\n    return NextResponse.json({ success: true, data })\n  } catch (error) {\n    return errorHandler(error, request)\n  }\n}\n```\n\n### Retry with Exponential Backoff\n\n```typescript\nasync function fetchWithRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries = 3\n): Promise<T> {\n  let lastError: Error\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn()\n    } catch (error) {\n      lastError = error as Error\n\n      if (i < maxRetries - 1) {\n        // Exponential backoff: 1s, 2s, 4s\n        const delay = Math.pow(2, i) * 1000\n        await new Promise(resolve => setTimeout(resolve, delay))\n      }\n    }\n  }\n\n  throw lastError!\n}\n\n// Usage\nconst data = await fetchWithRetry(() => fetchFromAPI())\n```\n\n## Authentication & Authorization\n\n### JWT Token Validation\n\n```typescript\nimport jwt from 'jsonwebtoken'\n\ninterface JWTPayload {\n  userId: string\n  email: string\n  role: 'admin' | 'user'\n}\n\nexport function verifyToken(token: string): JWTPayload {\n  try {\n    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload\n    return payload\n  } catch (error) {\n    throw new ApiError(401, 'Invalid token')\n  }\n}\n\nexport async function requireAuth(request: Request) {\n  const token = request.headers.get('authorization')?.replace('Bearer ', '')\n\n  if (!token) {\n    throw new ApiError(401, 'Missing authorization token')\n  }\n\n  return verifyToken(token)\n}\n\n// Usage in API route\nexport async function GET(request: Request) {\n  const user = await requireAuth(request)\n\n  const data = await getDataForUser(user.userId)\n\n  return NextResponse.json({ success: true, data })\n}\n```\n\n### Role-Based Access Control\n\n```typescript\ntype Permission = 'read' | 'write' | 'delete' | 'admin'\n\ninterface User {\n  id: string\n  role: 'admin' | 'moderator' | 'user'\n}\n\nconst rolePermissions: Record<User['role'], Permission[]> = {\n  admin: ['read', 'write', 'delete', 'admin'],\n  moderator: ['read', 'write', 'delete'],\n  user: ['read', 'write']\n}\n\nexport function hasPermission(user: User, permission: Permission): boolean {\n  return rolePermissions[user.role].includes(permission)\n}\n\nexport function requirePermission(permission: Permission) {\n  return async (request: Request) => {\n    const user = await requireAuth(request)\n\n    if (!hasPermission(user, permission)) {\n      throw new ApiError(403, 'Insufficient permissions')\n    }\n\n    return user\n  }\n}\n\n// Usage\nexport const DELETE = requirePermission('delete')(async (request: Request) => {\n  // Handler with permission check\n})\n```\n\n## Rate Limiting\n\n### Simple In-Memory Rate Limiter\n\n```typescript\nclass RateLimiter {\n  private requests = new Map<string, number[]>()\n\n  async checkLimit(\n    identifier: string,\n    maxRequests: number,\n    windowMs: number\n  ): Promise<boolean> {\n    const now = Date.now()\n    const requests = this.requests.get(identifier) || []\n\n    // Remove old requests outside window\n    const recentRequests = requests.filter(time => now - time < windowMs)\n\n    if (recentRequests.length >= maxRequests) {\n      return false  // Rate limit exceeded\n    }\n\n    // Add current request\n    recentRequests.push(now)\n    this.requests.set(identifier, recentRequests)\n\n    return true\n  }\n}\n\nconst limiter = new RateLimiter()\n\nexport async function GET(request: Request) {\n  const ip = request.headers.get('x-forwarded-for') || 'unknown'\n\n  const allowed = await limiter.checkLimit(ip, 100, 60000)  // 100 req/min\n\n  if (!allowed) {\n    return NextResponse.json({\n      error: 'Rate limit exceeded'\n    }, { status: 429 })\n  }\n\n  // Continue with request\n}\n```\n\n## Background Jobs & Queues\n\n### Simple Queue Pattern\n\n```typescript\nclass JobQueue<T> {\n  private queue: T[] = []\n  private processing = false\n\n  async add(job: T): Promise<void> {\n    this.queue.push(job)\n\n    if (!this.processing) {\n      this.process()\n    }\n  }\n\n  private async process(): Promise<void> {\n    this.processing = true\n\n    while (this.queue.length > 0) {\n      const job = this.queue.shift()!\n\n      try {\n        await this.execute(job)\n      } catch (error) {\n        console.error('Job failed:', error)\n      }\n    }\n\n    this.processing = false\n  }\n\n  private async execute(job: T): Promise<void> {\n    // Job execution logic\n  }\n}\n\n// Usage for indexing markets\ninterface IndexJob {\n  marketId: string\n}\n\nconst indexQueue = new JobQueue<IndexJob>()\n\nexport async function POST(request: Request) {\n  const { marketId } = await request.json()\n\n  // Add to queue instead of blocking\n  await indexQueue.add({ marketId })\n\n  return NextResponse.json({ success: true, message: 'Job queued' })\n}\n```\n\n## Logging & Monitoring\n\n### Structured Logging\n\n```typescript\ninterface LogContext {\n  userId?: string\n  requestId?: string\n  method?: string\n  path?: string\n  [key: string]: unknown\n}\n\nclass Logger {\n  log(level: 'info' | 'warn' | 'error', message: string, context?: LogContext) {\n    const entry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      ...context\n    }\n\n    console.log(JSON.stringify(entry))\n  }\n\n  info(message: string, context?: LogContext) {\n    this.log('info', message, context)\n  }\n\n  warn(message: string, context?: LogContext) {\n    this.log('warn', message, context)\n  }\n\n  error(message: string, error: Error, context?: LogContext) {\n    this.log('error', message, {\n      ...context,\n      error: error.message,\n      stack: error.stack\n    })\n  }\n}\n\nconst logger = new Logger()\n\n// Usage\nexport async function GET(request: Request) {\n  const requestId = crypto.randomUUID()\n\n  logger.info('Fetching markets', {\n    requestId,\n    method: 'GET',\n    path: '/api/markets'\n  })\n\n  try {\n    const markets = await fetchMarkets()\n    return NextResponse.json({ success: true, data: markets })\n  } catch (error) {\n    logger.error('Failed to fetch markets', error as Error, { requestId })\n    return NextResponse.json({ error: 'Internal error' }, { status: 500 })\n  }\n}\n```\n\n**Remember**: Backend patterns enable scalable, maintainable server-side applications. Choose patterns that fit your complexity level.\n",
        "skills/clickhouse-io/SKILL.md": "---\nname: clickhouse-io\ndescription: ClickHouse database patterns, query optimization, analytics, and data engineering best practices for high-performance analytical workloads.\n---\n\n# ClickHouse Analytics Patterns\n\nClickHouse-specific patterns for high-performance analytics and data engineering.\n\n## Overview\n\nClickHouse is a column-oriented database management system (DBMS) for online analytical processing (OLAP). It's optimized for fast analytical queries on large datasets.\n\n**Key Features:**\n- Column-oriented storage\n- Data compression\n- Parallel query execution\n- Distributed queries\n- Real-time analytics\n\n## Table Design Patterns\n\n### MergeTree Engine (Most Common)\n\n```sql\nCREATE TABLE markets_analytics (\n    date Date,\n    market_id String,\n    market_name String,\n    volume UInt64,\n    trades UInt32,\n    unique_traders UInt32,\n    avg_trade_size Float64,\n    created_at DateTime\n) ENGINE = MergeTree()\nPARTITION BY toYYYYMM(date)\nORDER BY (date, market_id)\nSETTINGS index_granularity = 8192;\n```\n\n### ReplacingMergeTree (Deduplication)\n\n```sql\n-- For data that may have duplicates (e.g., from multiple sources)\nCREATE TABLE user_events (\n    event_id String,\n    user_id String,\n    event_type String,\n    timestamp DateTime,\n    properties String\n) ENGINE = ReplacingMergeTree()\nPARTITION BY toYYYYMM(timestamp)\nORDER BY (user_id, event_id, timestamp)\nPRIMARY KEY (user_id, event_id);\n```\n\n### AggregatingMergeTree (Pre-aggregation)\n\n```sql\n-- For maintaining aggregated metrics\nCREATE TABLE market_stats_hourly (\n    hour DateTime,\n    market_id String,\n    total_volume AggregateFunction(sum, UInt64),\n    total_trades AggregateFunction(count, UInt32),\n    unique_users AggregateFunction(uniq, String)\n) ENGINE = AggregatingMergeTree()\nPARTITION BY toYYYYMM(hour)\nORDER BY (hour, market_id);\n\n-- Query aggregated data\nSELECT\n    hour,\n    market_id,\n    sumMerge(total_volume) AS volume,\n    countMerge(total_trades) AS trades,\n    uniqMerge(unique_users) AS users\nFROM market_stats_hourly\nWHERE hour >= toStartOfHour(now() - INTERVAL 24 HOUR)\nGROUP BY hour, market_id\nORDER BY hour DESC;\n```\n\n## Query Optimization Patterns\n\n### Efficient Filtering\n\n```sql\n-- ‚úÖ GOOD: Use indexed columns first\nSELECT *\nFROM markets_analytics\nWHERE date >= '2025-01-01'\n  AND market_id = 'market-123'\n  AND volume > 1000\nORDER BY date DESC\nLIMIT 100;\n\n-- ‚ùå BAD: Filter on non-indexed columns first\nSELECT *\nFROM markets_analytics\nWHERE volume > 1000\n  AND market_name LIKE '%election%'\n  AND date >= '2025-01-01';\n```\n\n### Aggregations\n\n```sql\n-- ‚úÖ GOOD: Use ClickHouse-specific aggregation functions\nSELECT\n    toStartOfDay(created_at) AS day,\n    market_id,\n    sum(volume) AS total_volume,\n    count() AS total_trades,\n    uniq(trader_id) AS unique_traders,\n    avg(trade_size) AS avg_size\nFROM trades\nWHERE created_at >= today() - INTERVAL 7 DAY\nGROUP BY day, market_id\nORDER BY day DESC, total_volume DESC;\n\n-- ‚úÖ Use quantile for percentiles (more efficient than percentile)\nSELECT\n    quantile(0.50)(trade_size) AS median,\n    quantile(0.95)(trade_size) AS p95,\n    quantile(0.99)(trade_size) AS p99\nFROM trades\nWHERE created_at >= now() - INTERVAL 1 HOUR;\n```\n\n### Window Functions\n\n```sql\n-- Calculate running totals\nSELECT\n    date,\n    market_id,\n    volume,\n    sum(volume) OVER (\n        PARTITION BY market_id\n        ORDER BY date\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cumulative_volume\nFROM markets_analytics\nWHERE date >= today() - INTERVAL 30 DAY\nORDER BY market_id, date;\n```\n\n## Data Insertion Patterns\n\n### Bulk Insert (Recommended)\n\n```typescript\nimport { ClickHouse } from 'clickhouse'\n\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD\n  }\n})\n\n// ‚úÖ Batch insert (efficient)\nasync function bulkInsertTrades(trades: Trade[]) {\n  const values = trades.map(trade => `(\n    '${trade.id}',\n    '${trade.market_id}',\n    '${trade.user_id}',\n    ${trade.amount},\n    '${trade.timestamp.toISOString()}'\n  )`).join(',')\n\n  await clickhouse.query(`\n    INSERT INTO trades (id, market_id, user_id, amount, timestamp)\n    VALUES ${values}\n  `).toPromise()\n}\n\n// ‚ùå Individual inserts (slow)\nasync function insertTrade(trade: Trade) {\n  // Don't do this in a loop!\n  await clickhouse.query(`\n    INSERT INTO trades VALUES ('${trade.id}', ...)\n  `).toPromise()\n}\n```\n\n### Streaming Insert\n\n```typescript\n// For continuous data ingestion\nimport { createWriteStream } from 'fs'\nimport { pipeline } from 'stream/promises'\n\nasync function streamInserts() {\n  const stream = clickhouse.insert('trades').stream()\n\n  for await (const batch of dataSource) {\n    stream.write(batch)\n  }\n\n  await stream.end()\n}\n```\n\n## Materialized Views\n\n### Real-time Aggregations\n\n```sql\n-- Create materialized view for hourly stats\nCREATE MATERIALIZED VIEW market_stats_hourly_mv\nTO market_stats_hourly\nAS SELECT\n    toStartOfHour(timestamp) AS hour,\n    market_id,\n    sumState(amount) AS total_volume,\n    countState() AS total_trades,\n    uniqState(user_id) AS unique_users\nFROM trades\nGROUP BY hour, market_id;\n\n-- Query the materialized view\nSELECT\n    hour,\n    market_id,\n    sumMerge(total_volume) AS volume,\n    countMerge(total_trades) AS trades,\n    uniqMerge(unique_users) AS users\nFROM market_stats_hourly\nWHERE hour >= now() - INTERVAL 24 HOUR\nGROUP BY hour, market_id;\n```\n\n## Performance Monitoring\n\n### Query Performance\n\n```sql\n-- Check slow queries\nSELECT\n    query_id,\n    user,\n    query,\n    query_duration_ms,\n    read_rows,\n    read_bytes,\n    memory_usage\nFROM system.query_log\nWHERE type = 'QueryFinish'\n  AND query_duration_ms > 1000\n  AND event_time >= now() - INTERVAL 1 HOUR\nORDER BY query_duration_ms DESC\nLIMIT 10;\n```\n\n### Table Statistics\n\n```sql\n-- Check table sizes\nSELECT\n    database,\n    table,\n    formatReadableSize(sum(bytes)) AS size,\n    sum(rows) AS rows,\n    max(modification_time) AS latest_modification\nFROM system.parts\nWHERE active\nGROUP BY database, table\nORDER BY sum(bytes) DESC;\n```\n\n## Common Analytics Queries\n\n### Time Series Analysis\n\n```sql\n-- Daily active users\nSELECT\n    toDate(timestamp) AS date,\n    uniq(user_id) AS daily_active_users\nFROM events\nWHERE timestamp >= today() - INTERVAL 30 DAY\nGROUP BY date\nORDER BY date;\n\n-- Retention analysis\nSELECT\n    signup_date,\n    countIf(days_since_signup = 0) AS day_0,\n    countIf(days_since_signup = 1) AS day_1,\n    countIf(days_since_signup = 7) AS day_7,\n    countIf(days_since_signup = 30) AS day_30\nFROM (\n    SELECT\n        user_id,\n        min(toDate(timestamp)) AS signup_date,\n        toDate(timestamp) AS activity_date,\n        dateDiff('day', signup_date, activity_date) AS days_since_signup\n    FROM events\n    GROUP BY user_id, activity_date\n)\nGROUP BY signup_date\nORDER BY signup_date DESC;\n```\n\n### Funnel Analysis\n\n```sql\n-- Conversion funnel\nSELECT\n    countIf(step = 'viewed_market') AS viewed,\n    countIf(step = 'clicked_trade') AS clicked,\n    countIf(step = 'completed_trade') AS completed,\n    round(clicked / viewed * 100, 2) AS view_to_click_rate,\n    round(completed / clicked * 100, 2) AS click_to_completion_rate\nFROM (\n    SELECT\n        user_id,\n        session_id,\n        event_type AS step\n    FROM events\n    WHERE event_date = today()\n)\nGROUP BY session_id;\n```\n\n### Cohort Analysis\n\n```sql\n-- User cohorts by signup month\nSELECT\n    toStartOfMonth(signup_date) AS cohort,\n    toStartOfMonth(activity_date) AS month,\n    dateDiff('month', cohort, month) AS months_since_signup,\n    count(DISTINCT user_id) AS active_users\nFROM (\n    SELECT\n        user_id,\n        min(toDate(timestamp)) OVER (PARTITION BY user_id) AS signup_date,\n        toDate(timestamp) AS activity_date\n    FROM events\n)\nGROUP BY cohort, month, months_since_signup\nORDER BY cohort, months_since_signup;\n```\n\n## Data Pipeline Patterns\n\n### ETL Pattern\n\n```typescript\n// Extract, Transform, Load\nasync function etlPipeline() {\n  // 1. Extract from source\n  const rawData = await extractFromPostgres()\n\n  // 2. Transform\n  const transformed = rawData.map(row => ({\n    date: new Date(row.created_at).toISOString().split('T')[0],\n    market_id: row.market_slug,\n    volume: parseFloat(row.total_volume),\n    trades: parseInt(row.trade_count)\n  }))\n\n  // 3. Load to ClickHouse\n  await bulkInsertToClickHouse(transformed)\n}\n\n// Run periodically\nsetInterval(etlPipeline, 60 * 60 * 1000)  // Every hour\n```\n\n### Change Data Capture (CDC)\n\n```typescript\n// Listen to PostgreSQL changes and sync to ClickHouse\nimport { Client } from 'pg'\n\nconst pgClient = new Client({ connectionString: process.env.DATABASE_URL })\n\npgClient.query('LISTEN market_updates')\n\npgClient.on('notification', async (msg) => {\n  const update = JSON.parse(msg.payload)\n\n  await clickhouse.insert('market_updates', [\n    {\n      market_id: update.id,\n      event_type: update.operation,  // INSERT, UPDATE, DELETE\n      timestamp: new Date(),\n      data: JSON.stringify(update.new_data)\n    }\n  ])\n})\n```\n\n## Best Practices\n\n### 1. Partitioning Strategy\n- Partition by time (usually month or day)\n- Avoid too many partitions (performance impact)\n- Use DATE type for partition key\n\n### 2. Ordering Key\n- Put most frequently filtered columns first\n- Consider cardinality (high cardinality first)\n- Order impacts compression\n\n### 3. Data Types\n- Use smallest appropriate type (UInt32 vs UInt64)\n- Use LowCardinality for repeated strings\n- Use Enum for categorical data\n\n### 4. Avoid\n- SELECT * (specify columns)\n- FINAL (merge data before query instead)\n- Too many JOINs (denormalize for analytics)\n- Small frequent inserts (batch instead)\n\n### 5. Monitoring\n- Track query performance\n- Monitor disk usage\n- Check merge operations\n- Review slow query log\n\n**Remember**: ClickHouse excels at analytical workloads. Design tables for your query patterns, batch inserts, and leverage materialized views for real-time aggregations.\n",
        "skills/coding-standards/SKILL.md": "---\nname: coding-standards\ndescription: Universal coding standards, best practices, and patterns for TypeScript, JavaScript, React, and Node.js development.\n---\n\n# Coding Standards & Best Practices\n\nUniversal coding standards applicable across all projects.\n\n## Code Quality Principles\n\n### 1. Readability First\n- Code is read more than written\n- Clear variable and function names\n- Self-documenting code preferred over comments\n- Consistent formatting\n\n### 2. KISS (Keep It Simple, Stupid)\n- Simplest solution that works\n- Avoid over-engineering\n- No premature optimization\n- Easy to understand > clever code\n\n### 3. DRY (Don't Repeat Yourself)\n- Extract common logic into functions\n- Create reusable components\n- Share utilities across modules\n- Avoid copy-paste programming\n\n### 4. YAGNI (You Aren't Gonna Need It)\n- Don't build features before they're needed\n- Avoid speculative generality\n- Add complexity only when required\n- Start simple, refactor when needed\n\n## TypeScript/JavaScript Standards\n\n### Variable Naming\n\n```typescript\n// ‚úÖ GOOD: Descriptive names\nconst marketSearchQuery = 'election'\nconst isUserAuthenticated = true\nconst totalRevenue = 1000\n\n// ‚ùå BAD: Unclear names\nconst q = 'election'\nconst flag = true\nconst x = 1000\n```\n\n### Function Naming\n\n```typescript\n// ‚úÖ GOOD: Verb-noun pattern\nasync function fetchMarketData(marketId: string) { }\nfunction calculateSimilarity(a: number[], b: number[]) { }\nfunction isValidEmail(email: string): boolean { }\n\n// ‚ùå BAD: Unclear or noun-only\nasync function market(id: string) { }\nfunction similarity(a, b) { }\nfunction email(e) { }\n```\n\n### Immutability Pattern (CRITICAL)\n\n```typescript\n// ‚úÖ ALWAYS use spread operator\nconst updatedUser = {\n  ...user,\n  name: 'New Name'\n}\n\nconst updatedArray = [...items, newItem]\n\n// ‚ùå NEVER mutate directly\nuser.name = 'New Name'  // BAD\nitems.push(newItem)     // BAD\n```\n\n### Error Handling\n\n```typescript\n// ‚úÖ GOOD: Comprehensive error handling\nasync function fetchData(url: string) {\n  try {\n    const response = await fetch(url)\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Fetch failed:', error)\n    throw new Error('Failed to fetch data')\n  }\n}\n\n// ‚ùå BAD: No error handling\nasync function fetchData(url) {\n  const response = await fetch(url)\n  return response.json()\n}\n```\n\n### Async/Await Best Practices\n\n```typescript\n// ‚úÖ GOOD: Parallel execution when possible\nconst [users, markets, stats] = await Promise.all([\n  fetchUsers(),\n  fetchMarkets(),\n  fetchStats()\n])\n\n// ‚ùå BAD: Sequential when unnecessary\nconst users = await fetchUsers()\nconst markets = await fetchMarkets()\nconst stats = await fetchStats()\n```\n\n### Type Safety\n\n```typescript\n// ‚úÖ GOOD: Proper types\ninterface Market {\n  id: string\n  name: string\n  status: 'active' | 'resolved' | 'closed'\n  created_at: Date\n}\n\nfunction getMarket(id: string): Promise<Market> {\n  // Implementation\n}\n\n// ‚ùå BAD: Using 'any'\nfunction getMarket(id: any): Promise<any> {\n  // Implementation\n}\n```\n\n## React Best Practices\n\n### Component Structure\n\n```typescript\n// ‚úÖ GOOD: Functional component with types\ninterface ButtonProps {\n  children: React.ReactNode\n  onClick: () => void\n  disabled?: boolean\n  variant?: 'primary' | 'secondary'\n}\n\nexport function Button({\n  children,\n  onClick,\n  disabled = false,\n  variant = 'primary'\n}: ButtonProps) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled}\n      className={`btn btn-${variant}`}\n    >\n      {children}\n    </button>\n  )\n}\n\n// ‚ùå BAD: No types, unclear structure\nexport function Button(props) {\n  return <button onClick={props.onClick}>{props.children}</button>\n}\n```\n\n### Custom Hooks\n\n```typescript\n// ‚úÖ GOOD: Reusable custom hook\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value)\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    return () => clearTimeout(handler)\n  }, [value, delay])\n\n  return debouncedValue\n}\n\n// Usage\nconst debouncedQuery = useDebounce(searchQuery, 500)\n```\n\n### State Management\n\n```typescript\n// ‚úÖ GOOD: Proper state updates\nconst [count, setCount] = useState(0)\n\n// Functional update for state based on previous state\nsetCount(prev => prev + 1)\n\n// ‚ùå BAD: Direct state reference\nsetCount(count + 1)  // Can be stale in async scenarios\n```\n\n### Conditional Rendering\n\n```typescript\n// ‚úÖ GOOD: Clear conditional rendering\n{isLoading && <Spinner />}\n{error && <ErrorMessage error={error} />}\n{data && <DataDisplay data={data} />}\n\n// ‚ùå BAD: Ternary hell\n{isLoading ? <Spinner /> : error ? <ErrorMessage error={error} /> : data ? <DataDisplay data={data} /> : null}\n```\n\n## API Design Standards\n\n### REST API Conventions\n\n```\nGET    /api/markets              # List all markets\nGET    /api/markets/:id          # Get specific market\nPOST   /api/markets              # Create new market\nPUT    /api/markets/:id          # Update market (full)\nPATCH  /api/markets/:id          # Update market (partial)\nDELETE /api/markets/:id          # Delete market\n\n# Query parameters for filtering\nGET /api/markets?status=active&limit=10&offset=0\n```\n\n### Response Format\n\n```typescript\n// ‚úÖ GOOD: Consistent response structure\ninterface ApiResponse<T> {\n  success: boolean\n  data?: T\n  error?: string\n  meta?: {\n    total: number\n    page: number\n    limit: number\n  }\n}\n\n// Success response\nreturn NextResponse.json({\n  success: true,\n  data: markets,\n  meta: { total: 100, page: 1, limit: 10 }\n})\n\n// Error response\nreturn NextResponse.json({\n  success: false,\n  error: 'Invalid request'\n}, { status: 400 })\n```\n\n### Input Validation\n\n```typescript\nimport { z } from 'zod'\n\n// ‚úÖ GOOD: Schema validation\nconst CreateMarketSchema = z.object({\n  name: z.string().min(1).max(200),\n  description: z.string().min(1).max(2000),\n  endDate: z.string().datetime(),\n  categories: z.array(z.string()).min(1)\n})\n\nexport async function POST(request: Request) {\n  const body = await request.json()\n\n  try {\n    const validated = CreateMarketSchema.parse(body)\n    // Proceed with validated data\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({\n        success: false,\n        error: 'Validation failed',\n        details: error.errors\n      }, { status: 400 })\n    }\n  }\n}\n```\n\n## File Organization\n\n### Project Structure\n\n```\nsrc/\n‚îú‚îÄ‚îÄ app/                    # Next.js App Router\n‚îÇ   ‚îú‚îÄ‚îÄ api/               # API routes\n‚îÇ   ‚îú‚îÄ‚îÄ markets/           # Market pages\n‚îÇ   ‚îî‚îÄ‚îÄ (auth)/           # Auth pages (route groups)\n‚îú‚îÄ‚îÄ components/            # React components\n‚îÇ   ‚îú‚îÄ‚îÄ ui/               # Generic UI components\n‚îÇ   ‚îú‚îÄ‚îÄ forms/            # Form components\n‚îÇ   ‚îî‚îÄ‚îÄ layouts/          # Layout components\n‚îú‚îÄ‚îÄ hooks/                # Custom React hooks\n‚îú‚îÄ‚îÄ lib/                  # Utilities and configs\n‚îÇ   ‚îú‚îÄ‚îÄ api/             # API clients\n‚îÇ   ‚îú‚îÄ‚îÄ utils/           # Helper functions\n‚îÇ   ‚îî‚îÄ‚îÄ constants/       # Constants\n‚îú‚îÄ‚îÄ types/                # TypeScript types\n‚îî‚îÄ‚îÄ styles/              # Global styles\n```\n\n### File Naming\n\n```\ncomponents/Button.tsx          # PascalCase for components\nhooks/useAuth.ts              # camelCase with 'use' prefix\nlib/formatDate.ts             # camelCase for utilities\ntypes/market.types.ts         # camelCase with .types suffix\n```\n\n## Comments & Documentation\n\n### When to Comment\n\n```typescript\n// ‚úÖ GOOD: Explain WHY, not WHAT\n// Use exponential backoff to avoid overwhelming the API during outages\nconst delay = Math.min(1000 * Math.pow(2, retryCount), 30000)\n\n// Deliberately using mutation here for performance with large arrays\nitems.push(newItem)\n\n// ‚ùå BAD: Stating the obvious\n// Increment counter by 1\ncount++\n\n// Set name to user's name\nname = user.name\n```\n\n### JSDoc for Public APIs\n\n```typescript\n/**\n * Searches markets using semantic similarity.\n *\n * @param query - Natural language search query\n * @param limit - Maximum number of results (default: 10)\n * @returns Array of markets sorted by similarity score\n * @throws {Error} If OpenAI API fails or Redis unavailable\n *\n * @example\n * ```typescript\n * const results = await searchMarkets('election', 5)\n * console.log(results[0].name) // \"Trump vs Biden\"\n * ```\n */\nexport async function searchMarkets(\n  query: string,\n  limit: number = 10\n): Promise<Market[]> {\n  // Implementation\n}\n```\n\n## Performance Best Practices\n\n### Memoization\n\n```typescript\nimport { useMemo, useCallback } from 'react'\n\n// ‚úÖ GOOD: Memoize expensive computations\nconst sortedMarkets = useMemo(() => {\n  return markets.sort((a, b) => b.volume - a.volume)\n}, [markets])\n\n// ‚úÖ GOOD: Memoize callbacks\nconst handleSearch = useCallback((query: string) => {\n  setSearchQuery(query)\n}, [])\n```\n\n### Lazy Loading\n\n```typescript\nimport { lazy, Suspense } from 'react'\n\n// ‚úÖ GOOD: Lazy load heavy components\nconst HeavyChart = lazy(() => import('./HeavyChart'))\n\nexport function Dashboard() {\n  return (\n    <Suspense fallback={<Spinner />}>\n      <HeavyChart />\n    </Suspense>\n  )\n}\n```\n\n### Database Queries\n\n```typescript\n// ‚úÖ GOOD: Select only needed columns\nconst { data } = await supabase\n  .from('markets')\n  .select('id, name, status')\n  .limit(10)\n\n// ‚ùå BAD: Select everything\nconst { data } = await supabase\n  .from('markets')\n  .select('*')\n```\n\n## Testing Standards\n\n### Test Structure (AAA Pattern)\n\n```typescript\ntest('calculates similarity correctly', () => {\n  // Arrange\n  const vector1 = [1, 0, 0]\n  const vector2 = [0, 1, 0]\n\n  // Act\n  const similarity = calculateCosineSimilarity(vector1, vector2)\n\n  // Assert\n  expect(similarity).toBe(0)\n})\n```\n\n### Test Naming\n\n```typescript\n// ‚úÖ GOOD: Descriptive test names\ntest('returns empty array when no markets match query', () => { })\ntest('throws error when OpenAI API key is missing', () => { })\ntest('falls back to substring search when Redis unavailable', () => { })\n\n// ‚ùå BAD: Vague test names\ntest('works', () => { })\ntest('test search', () => { })\n```\n\n## Code Smell Detection\n\nWatch for these anti-patterns:\n\n### 1. Long Functions\n```typescript\n// ‚ùå BAD: Function > 50 lines\nfunction processMarketData() {\n  // 100 lines of code\n}\n\n// ‚úÖ GOOD: Split into smaller functions\nfunction processMarketData() {\n  const validated = validateData()\n  const transformed = transformData(validated)\n  return saveData(transformed)\n}\n```\n\n### 2. Deep Nesting\n```typescript\n// ‚ùå BAD: 5+ levels of nesting\nif (user) {\n  if (user.isAdmin) {\n    if (market) {\n      if (market.isActive) {\n        if (hasPermission) {\n          // Do something\n        }\n      }\n    }\n  }\n}\n\n// ‚úÖ GOOD: Early returns\nif (!user) return\nif (!user.isAdmin) return\nif (!market) return\nif (!market.isActive) return\nif (!hasPermission) return\n\n// Do something\n```\n\n### 3. Magic Numbers\n```typescript\n// ‚ùå BAD: Unexplained numbers\nif (retryCount > 3) { }\nsetTimeout(callback, 500)\n\n// ‚úÖ GOOD: Named constants\nconst MAX_RETRIES = 3\nconst DEBOUNCE_DELAY_MS = 500\n\nif (retryCount > MAX_RETRIES) { }\nsetTimeout(callback, DEBOUNCE_DELAY_MS)\n```\n\n**Remember**: Code quality is not negotiable. Clear, maintainable code enables rapid development and confident refactoring.\n",
        "skills/continuous-learning/SKILL.md": "---\nname: continuous-learning\ndescription: Automatically extract reusable patterns from Claude Code sessions and save them as learned skills for future use.\n---\n\n# Continuous Learning Skill\n\nAutomatically evaluates Claude Code sessions on end to extract reusable patterns that can be saved as learned skills.\n\n## How It Works\n\nThis skill runs as a **Stop hook** at the end of each session:\n\n1. **Session Evaluation**: Checks if session has enough messages (default: 10+)\n2. **Pattern Detection**: Identifies extractable patterns from the session\n3. **Skill Extraction**: Saves useful patterns to `~/.claude/skills/learned/`\n\n## Configuration\n\nEdit `config.json` to customize:\n\n```json\n{\n  \"min_session_length\": 10,\n  \"extraction_threshold\": \"medium\",\n  \"auto_approve\": false,\n  \"learned_skills_path\": \"~/.claude/skills/learned/\",\n  \"patterns_to_detect\": [\n    \"error_resolution\",\n    \"user_corrections\",\n    \"workarounds\",\n    \"debugging_techniques\",\n    \"project_specific\"\n  ],\n  \"ignore_patterns\": [\n    \"simple_typos\",\n    \"one_time_fixes\",\n    \"external_api_issues\"\n  ]\n}\n```\n\n## Pattern Types\n\n| Pattern | Description |\n|---------|-------------|\n| `error_resolution` | How specific errors were resolved |\n| `user_corrections` | Patterns from user corrections |\n| `workarounds` | Solutions to framework/library quirks |\n| `debugging_techniques` | Effective debugging approaches |\n| `project_specific` | Project-specific conventions |\n\n## Hook Setup\n\nAdd to your `~/.claude/settings.json`:\n\n```json\n{\n  \"hooks\": {\n    \"Stop\": [{\n      \"matcher\": \"*\",\n      \"hooks\": [{\n        \"type\": \"command\",\n        \"command\": \"~/.claude/skills/continuous-learning/evaluate-session.sh\"\n      }]\n    }]\n  }\n}\n```\n\n## Why Stop Hook?\n\n- **Lightweight**: Runs once at session end\n- **Non-blocking**: Doesn't add latency to every message\n- **Complete context**: Has access to full session transcript\n\n## Related\n\n- [The Longform Guide](https://x.com/affaanmustafa/status/2014040193557471352) - Section on continuous learning\n- `/learn` command - Manual pattern extraction mid-session\n",
        "skills/eval-harness/SKILL.md": "# Eval Harness Skill\n\nA formal evaluation framework for Claude Code sessions, implementing eval-driven development (EDD) principles.\n\n## Philosophy\n\nEval-Driven Development treats evals as the \"unit tests of AI development\":\n- Define expected behavior BEFORE implementation\n- Run evals continuously during development\n- Track regressions with each change\n- Use pass@k metrics for reliability measurement\n\n## Eval Types\n\n### Capability Evals\nTest if Claude can do something it couldn't before:\n```markdown\n[CAPABILITY EVAL: feature-name]\nTask: Description of what Claude should accomplish\nSuccess Criteria:\n  - [ ] Criterion 1\n  - [ ] Criterion 2\n  - [ ] Criterion 3\nExpected Output: Description of expected result\n```\n\n### Regression Evals\nEnsure changes don't break existing functionality:\n```markdown\n[REGRESSION EVAL: feature-name]\nBaseline: SHA or checkpoint name\nTests:\n  - existing-test-1: PASS/FAIL\n  - existing-test-2: PASS/FAIL\n  - existing-test-3: PASS/FAIL\nResult: X/Y passed (previously Y/Y)\n```\n\n## Grader Types\n\n### 1. Code-Based Grader\nDeterministic checks using code:\n```bash\n# Check if file contains expected pattern\ngrep -q \"export function handleAuth\" src/auth.ts && echo \"PASS\" || echo \"FAIL\"\n\n# Check if tests pass\nnpm test -- --testPathPattern=\"auth\" && echo \"PASS\" || echo \"FAIL\"\n\n# Check if build succeeds\nnpm run build && echo \"PASS\" || echo \"FAIL\"\n```\n\n### 2. Model-Based Grader\nUse Claude to evaluate open-ended outputs:\n```markdown\n[MODEL GRADER PROMPT]\nEvaluate the following code change:\n1. Does it solve the stated problem?\n2. Is it well-structured?\n3. Are edge cases handled?\n4. Is error handling appropriate?\n\nScore: 1-5 (1=poor, 5=excellent)\nReasoning: [explanation]\n```\n\n### 3. Human Grader\nFlag for manual review:\n```markdown\n[HUMAN REVIEW REQUIRED]\nChange: Description of what changed\nReason: Why human review is needed\nRisk Level: LOW/MEDIUM/HIGH\n```\n\n## Metrics\n\n### pass@k\n\"At least one success in k attempts\"\n- pass@1: First attempt success rate\n- pass@3: Success within 3 attempts\n- Typical target: pass@3 > 90%\n\n### pass^k\n\"All k trials succeed\"\n- Higher bar for reliability\n- pass^3: 3 consecutive successes\n- Use for critical paths\n\n## Eval Workflow\n\n### 1. Define (Before Coding)\n```markdown\n## EVAL DEFINITION: feature-xyz\n\n### Capability Evals\n1. Can create new user account\n2. Can validate email format\n3. Can hash password securely\n\n### Regression Evals\n1. Existing login still works\n2. Session management unchanged\n3. Logout flow intact\n\n### Success Metrics\n- pass@3 > 90% for capability evals\n- pass^3 = 100% for regression evals\n```\n\n### 2. Implement\nWrite code to pass the defined evals.\n\n### 3. Evaluate\n```bash\n# Run capability evals\n[Run each capability eval, record PASS/FAIL]\n\n# Run regression evals\nnpm test -- --testPathPattern=\"existing\"\n\n# Generate report\n```\n\n### 4. Report\n```markdown\nEVAL REPORT: feature-xyz\n========================\n\nCapability Evals:\n  create-user:     PASS (pass@1)\n  validate-email:  PASS (pass@2)\n  hash-password:   PASS (pass@1)\n  Overall:         3/3 passed\n\nRegression Evals:\n  login-flow:      PASS\n  session-mgmt:    PASS\n  logout-flow:     PASS\n  Overall:         3/3 passed\n\nMetrics:\n  pass@1: 67% (2/3)\n  pass@3: 100% (3/3)\n\nStatus: READY FOR REVIEW\n```\n\n## Integration Patterns\n\n### Pre-Implementation\n```\n/eval define feature-name\n```\nCreates eval definition file at `.claude/evals/feature-name.md`\n\n### During Implementation\n```\n/eval check feature-name\n```\nRuns current evals and reports status\n\n### Post-Implementation\n```\n/eval report feature-name\n```\nGenerates full eval report\n\n## Eval Storage\n\nStore evals in project:\n```\n.claude/\n  evals/\n    feature-xyz.md      # Eval definition\n    feature-xyz.log     # Eval run history\n    baseline.json       # Regression baselines\n```\n\n## Best Practices\n\n1. **Define evals BEFORE coding** - Forces clear thinking about success criteria\n2. **Run evals frequently** - Catch regressions early\n3. **Track pass@k over time** - Monitor reliability trends\n4. **Use code graders when possible** - Deterministic > probabilistic\n5. **Human review for security** - Never fully automate security checks\n6. **Keep evals fast** - Slow evals don't get run\n7. **Version evals with code** - Evals are first-class artifacts\n\n## Example: Adding Authentication\n\n```markdown\n## EVAL: add-authentication\n\n### Phase 1: Define (10 min)\nCapability Evals:\n- [ ] User can register with email/password\n- [ ] User can login with valid credentials\n- [ ] Invalid credentials rejected with proper error\n- [ ] Sessions persist across page reloads\n- [ ] Logout clears session\n\nRegression Evals:\n- [ ] Public routes still accessible\n- [ ] API responses unchanged\n- [ ] Database schema compatible\n\n### Phase 2: Implement (varies)\n[Write code]\n\n### Phase 3: Evaluate\nRun: /eval check add-authentication\n\n### Phase 4: Report\nEVAL REPORT: add-authentication\n==============================\nCapability: 5/5 passed (pass@3: 100%)\nRegression: 3/3 passed (pass^3: 100%)\nStatus: SHIP IT\n```\n",
        "skills/frontend-patterns/SKILL.md": "---\nname: frontend-patterns\ndescription: Frontend development patterns for React, Next.js, state management, performance optimization, and UI best practices.\n---\n\n# Frontend Development Patterns\n\nModern frontend patterns for React, Next.js, and performant user interfaces.\n\n## Component Patterns\n\n### Composition Over Inheritance\n\n```typescript\n// ‚úÖ GOOD: Component composition\ninterface CardProps {\n  children: React.ReactNode\n  variant?: 'default' | 'outlined'\n}\n\nexport function Card({ children, variant = 'default' }: CardProps) {\n  return <div className={`card card-${variant}`}>{children}</div>\n}\n\nexport function CardHeader({ children }: { children: React.ReactNode }) {\n  return <div className=\"card-header\">{children}</div>\n}\n\nexport function CardBody({ children }: { children: React.ReactNode }) {\n  return <div className=\"card-body\">{children}</div>\n}\n\n// Usage\n<Card>\n  <CardHeader>Title</CardHeader>\n  <CardBody>Content</CardBody>\n</Card>\n```\n\n### Compound Components\n\n```typescript\ninterface TabsContextValue {\n  activeTab: string\n  setActiveTab: (tab: string) => void\n}\n\nconst TabsContext = createContext<TabsContextValue | undefined>(undefined)\n\nexport function Tabs({ children, defaultTab }: {\n  children: React.ReactNode\n  defaultTab: string\n}) {\n  const [activeTab, setActiveTab] = useState(defaultTab)\n\n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      {children}\n    </TabsContext.Provider>\n  )\n}\n\nexport function TabList({ children }: { children: React.ReactNode }) {\n  return <div className=\"tab-list\">{children}</div>\n}\n\nexport function Tab({ id, children }: { id: string, children: React.ReactNode }) {\n  const context = useContext(TabsContext)\n  if (!context) throw new Error('Tab must be used within Tabs')\n\n  return (\n    <button\n      className={context.activeTab === id ? 'active' : ''}\n      onClick={() => context.setActiveTab(id)}\n    >\n      {children}\n    </button>\n  )\n}\n\n// Usage\n<Tabs defaultTab=\"overview\">\n  <TabList>\n    <Tab id=\"overview\">Overview</Tab>\n    <Tab id=\"details\">Details</Tab>\n  </TabList>\n</Tabs>\n```\n\n### Render Props Pattern\n\n```typescript\ninterface DataLoaderProps<T> {\n  url: string\n  children: (data: T | null, loading: boolean, error: Error | null) => React.ReactNode\n}\n\nexport function DataLoader<T>({ url, children }: DataLoaderProps<T>) {\n  const [data, setData] = useState<T | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    fetch(url)\n      .then(res => res.json())\n      .then(setData)\n      .catch(setError)\n      .finally(() => setLoading(false))\n  }, [url])\n\n  return <>{children(data, loading, error)}</>\n}\n\n// Usage\n<DataLoader<Market[]> url=\"/api/markets\">\n  {(markets, loading, error) => {\n    if (loading) return <Spinner />\n    if (error) return <Error error={error} />\n    return <MarketList markets={markets!} />\n  }}\n</DataLoader>\n```\n\n## Custom Hooks Patterns\n\n### State Management Hook\n\n```typescript\nexport function useToggle(initialValue = false): [boolean, () => void] {\n  const [value, setValue] = useState(initialValue)\n\n  const toggle = useCallback(() => {\n    setValue(v => !v)\n  }, [])\n\n  return [value, toggle]\n}\n\n// Usage\nconst [isOpen, toggleOpen] = useToggle()\n```\n\n### Async Data Fetching Hook\n\n```typescript\ninterface UseQueryOptions<T> {\n  onSuccess?: (data: T) => void\n  onError?: (error: Error) => void\n  enabled?: boolean\n}\n\nexport function useQuery<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  options?: UseQueryOptions<T>\n) {\n  const [data, setData] = useState<T | null>(null)\n  const [error, setError] = useState<Error | null>(null)\n  const [loading, setLoading] = useState(false)\n\n  const refetch = useCallback(async () => {\n    setLoading(true)\n    setError(null)\n\n    try {\n      const result = await fetcher()\n      setData(result)\n      options?.onSuccess?.(result)\n    } catch (err) {\n      const error = err as Error\n      setError(error)\n      options?.onError?.(error)\n    } finally {\n      setLoading(false)\n    }\n  }, [fetcher, options])\n\n  useEffect(() => {\n    if (options?.enabled !== false) {\n      refetch()\n    }\n  }, [key, refetch, options?.enabled])\n\n  return { data, error, loading, refetch }\n}\n\n// Usage\nconst { data: markets, loading, error, refetch } = useQuery(\n  'markets',\n  () => fetch('/api/markets').then(r => r.json()),\n  {\n    onSuccess: data => console.log('Fetched', data.length, 'markets'),\n    onError: err => console.error('Failed:', err)\n  }\n)\n```\n\n### Debounce Hook\n\n```typescript\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value)\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    return () => clearTimeout(handler)\n  }, [value, delay])\n\n  return debouncedValue\n}\n\n// Usage\nconst [searchQuery, setSearchQuery] = useState('')\nconst debouncedQuery = useDebounce(searchQuery, 500)\n\nuseEffect(() => {\n  if (debouncedQuery) {\n    performSearch(debouncedQuery)\n  }\n}, [debouncedQuery])\n```\n\n## State Management Patterns\n\n### Context + Reducer Pattern\n\n```typescript\ninterface State {\n  markets: Market[]\n  selectedMarket: Market | null\n  loading: boolean\n}\n\ntype Action =\n  | { type: 'SET_MARKETS'; payload: Market[] }\n  | { type: 'SELECT_MARKET'; payload: Market }\n  | { type: 'SET_LOADING'; payload: boolean }\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'SET_MARKETS':\n      return { ...state, markets: action.payload }\n    case 'SELECT_MARKET':\n      return { ...state, selectedMarket: action.payload }\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload }\n    default:\n      return state\n  }\n}\n\nconst MarketContext = createContext<{\n  state: State\n  dispatch: Dispatch<Action>\n} | undefined>(undefined)\n\nexport function MarketProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(reducer, {\n    markets: [],\n    selectedMarket: null,\n    loading: false\n  })\n\n  return (\n    <MarketContext.Provider value={{ state, dispatch }}>\n      {children}\n    </MarketContext.Provider>\n  )\n}\n\nexport function useMarkets() {\n  const context = useContext(MarketContext)\n  if (!context) throw new Error('useMarkets must be used within MarketProvider')\n  return context\n}\n```\n\n## Performance Optimization\n\n### Memoization\n\n```typescript\n// ‚úÖ useMemo for expensive computations\nconst sortedMarkets = useMemo(() => {\n  return markets.sort((a, b) => b.volume - a.volume)\n}, [markets])\n\n// ‚úÖ useCallback for functions passed to children\nconst handleSearch = useCallback((query: string) => {\n  setSearchQuery(query)\n}, [])\n\n// ‚úÖ React.memo for pure components\nexport const MarketCard = React.memo<MarketCardProps>(({ market }) => {\n  return (\n    <div className=\"market-card\">\n      <h3>{market.name}</h3>\n      <p>{market.description}</p>\n    </div>\n  )\n})\n```\n\n### Code Splitting & Lazy Loading\n\n```typescript\nimport { lazy, Suspense } from 'react'\n\n// ‚úÖ Lazy load heavy components\nconst HeavyChart = lazy(() => import('./HeavyChart'))\nconst ThreeJsBackground = lazy(() => import('./ThreeJsBackground'))\n\nexport function Dashboard() {\n  return (\n    <div>\n      <Suspense fallback={<ChartSkeleton />}>\n        <HeavyChart data={data} />\n      </Suspense>\n\n      <Suspense fallback={null}>\n        <ThreeJsBackground />\n      </Suspense>\n    </div>\n  )\n}\n```\n\n### Virtualization for Long Lists\n\n```typescript\nimport { useVirtualizer } from '@tanstack/react-virtual'\n\nexport function VirtualMarketList({ markets }: { markets: Market[] }) {\n  const parentRef = useRef<HTMLDivElement>(null)\n\n  const virtualizer = useVirtualizer({\n    count: markets.length,\n    getScrollElement: () => parentRef.current,\n    estimateSize: () => 100,  // Estimated row height\n    overscan: 5  // Extra items to render\n  })\n\n  return (\n    <div ref={parentRef} style={{ height: '600px', overflow: 'auto' }}>\n      <div\n        style={{\n          height: `${virtualizer.getTotalSize()}px`,\n          position: 'relative'\n        }}\n      >\n        {virtualizer.getVirtualItems().map(virtualRow => (\n          <div\n            key={virtualRow.index}\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: `${virtualRow.size}px`,\n              transform: `translateY(${virtualRow.start}px)`\n            }}\n          >\n            <MarketCard market={markets[virtualRow.index]} />\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n```\n\n## Form Handling Patterns\n\n### Controlled Form with Validation\n\n```typescript\ninterface FormData {\n  name: string\n  description: string\n  endDate: string\n}\n\ninterface FormErrors {\n  name?: string\n  description?: string\n  endDate?: string\n}\n\nexport function CreateMarketForm() {\n  const [formData, setFormData] = useState<FormData>({\n    name: '',\n    description: '',\n    endDate: ''\n  })\n\n  const [errors, setErrors] = useState<FormErrors>({})\n\n  const validate = (): boolean => {\n    const newErrors: FormErrors = {}\n\n    if (!formData.name.trim()) {\n      newErrors.name = 'Name is required'\n    } else if (formData.name.length > 200) {\n      newErrors.name = 'Name must be under 200 characters'\n    }\n\n    if (!formData.description.trim()) {\n      newErrors.description = 'Description is required'\n    }\n\n    if (!formData.endDate) {\n      newErrors.endDate = 'End date is required'\n    }\n\n    setErrors(newErrors)\n    return Object.keys(newErrors).length === 0\n  }\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n\n    if (!validate()) return\n\n    try {\n      await createMarket(formData)\n      // Success handling\n    } catch (error) {\n      // Error handling\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={formData.name}\n        onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}\n        placeholder=\"Market name\"\n      />\n      {errors.name && <span className=\"error\">{errors.name}</span>}\n\n      {/* Other fields */}\n\n      <button type=\"submit\">Create Market</button>\n    </form>\n  )\n}\n```\n\n## Error Boundary Pattern\n\n```typescript\ninterface ErrorBoundaryState {\n  hasError: boolean\n  error: Error | null\n}\n\nexport class ErrorBoundary extends React.Component<\n  { children: React.ReactNode },\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = {\n    hasError: false,\n    error: null\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error }\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Error boundary caught:', error, errorInfo)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-fallback\">\n          <h2>Something went wrong</h2>\n          <p>{this.state.error?.message}</p>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </button>\n        </div>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n// Usage\n<ErrorBoundary>\n  <App />\n</ErrorBoundary>\n```\n\n## Animation Patterns\n\n### Framer Motion Animations\n\n```typescript\nimport { motion, AnimatePresence } from 'framer-motion'\n\n// ‚úÖ List animations\nexport function AnimatedMarketList({ markets }: { markets: Market[] }) {\n  return (\n    <AnimatePresence>\n      {markets.map(market => (\n        <motion.div\n          key={market.id}\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          exit={{ opacity: 0, y: -20 }}\n          transition={{ duration: 0.3 }}\n        >\n          <MarketCard market={market} />\n        </motion.div>\n      ))}\n    </AnimatePresence>\n  )\n}\n\n// ‚úÖ Modal animations\nexport function Modal({ isOpen, onClose, children }: ModalProps) {\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          <motion.div\n            className=\"modal-overlay\"\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            onClick={onClose}\n          />\n          <motion.div\n            className=\"modal-content\"\n            initial={{ opacity: 0, scale: 0.9, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.9, y: 20 }}\n          >\n            {children}\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  )\n}\n```\n\n## Accessibility Patterns\n\n### Keyboard Navigation\n\n```typescript\nexport function Dropdown({ options, onSelect }: DropdownProps) {\n  const [isOpen, setIsOpen] = useState(false)\n  const [activeIndex, setActiveIndex] = useState(0)\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault()\n        setActiveIndex(i => Math.min(i + 1, options.length - 1))\n        break\n      case 'ArrowUp':\n        e.preventDefault()\n        setActiveIndex(i => Math.max(i - 1, 0))\n        break\n      case 'Enter':\n        e.preventDefault()\n        onSelect(options[activeIndex])\n        setIsOpen(false)\n        break\n      case 'Escape':\n        setIsOpen(false)\n        break\n    }\n  }\n\n  return (\n    <div\n      role=\"combobox\"\n      aria-expanded={isOpen}\n      aria-haspopup=\"listbox\"\n      onKeyDown={handleKeyDown}\n    >\n      {/* Dropdown implementation */}\n    </div>\n  )\n}\n```\n\n### Focus Management\n\n```typescript\nexport function Modal({ isOpen, onClose, children }: ModalProps) {\n  const modalRef = useRef<HTMLDivElement>(null)\n  const previousFocusRef = useRef<HTMLElement | null>(null)\n\n  useEffect(() => {\n    if (isOpen) {\n      // Save currently focused element\n      previousFocusRef.current = document.activeElement as HTMLElement\n\n      // Focus modal\n      modalRef.current?.focus()\n    } else {\n      // Restore focus when closing\n      previousFocusRef.current?.focus()\n    }\n  }, [isOpen])\n\n  return isOpen ? (\n    <div\n      ref={modalRef}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      tabIndex={-1}\n      onKeyDown={e => e.key === 'Escape' && onClose()}\n    >\n      {children}\n    </div>\n  ) : null\n}\n```\n\n**Remember**: Modern frontend patterns enable maintainable, performant user interfaces. Choose patterns that fit your project complexity.\n",
        "skills/project-guidelines-example/SKILL.md": "# Project Guidelines Skill (Example)\n\nThis is an example of a project-specific skill. Use this as a template for your own projects.\n\nBased on a real production application: [Zenith](https://zenith.chat) - AI-powered customer discovery platform.\n\n---\n\n## When to Use\n\nReference this skill when working on the specific project it's designed for. Project skills contain:\n- Architecture overview\n- File structure\n- Code patterns\n- Testing requirements\n- Deployment workflow\n\n---\n\n## Architecture Overview\n\n**Tech Stack:**\n- **Frontend**: Next.js 15 (App Router), TypeScript, React\n- **Backend**: FastAPI (Python), Pydantic models\n- **Database**: Supabase (PostgreSQL)\n- **AI**: Claude API with tool calling and structured output\n- **Deployment**: Google Cloud Run\n- **Testing**: Playwright (E2E), pytest (backend), React Testing Library\n\n**Services:**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                         Frontend                            ‚îÇ\n‚îÇ  Next.js 15 + TypeScript + TailwindCSS                     ‚îÇ\n‚îÇ  Deployed: Vercel / Cloud Run                              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                              ‚îÇ\n                              ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                         Backend                             ‚îÇ\n‚îÇ  FastAPI + Python 3.11 + Pydantic                          ‚îÇ\n‚îÇ  Deployed: Cloud Run                                       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                              ‚îÇ\n              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n              ‚ñº               ‚ñº               ‚ñº\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        ‚îÇ Supabase ‚îÇ   ‚îÇ  Claude  ‚îÇ   ‚îÇ  Redis   ‚îÇ\n        ‚îÇ Database ‚îÇ   ‚îÇ   API    ‚îÇ   ‚îÇ  Cache   ‚îÇ\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## File Structure\n\n```\nproject/\n‚îú‚îÄ‚îÄ frontend/\n‚îÇ   ‚îî‚îÄ‚îÄ src/\n‚îÇ       ‚îú‚îÄ‚îÄ app/              # Next.js app router pages\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ api/          # API routes\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ (auth)/       # Auth-protected routes\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ workspace/    # Main app workspace\n‚îÇ       ‚îú‚îÄ‚îÄ components/       # React components\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ui/           # Base UI components\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ forms/        # Form components\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ layouts/      # Layout components\n‚îÇ       ‚îú‚îÄ‚îÄ hooks/            # Custom React hooks\n‚îÇ       ‚îú‚îÄ‚îÄ lib/              # Utilities\n‚îÇ       ‚îú‚îÄ‚îÄ types/            # TypeScript definitions\n‚îÇ       ‚îî‚îÄ‚îÄ config/           # Configuration\n‚îÇ\n‚îú‚îÄ‚îÄ backend/\n‚îÇ   ‚îú‚îÄ‚îÄ routers/              # FastAPI route handlers\n‚îÇ   ‚îú‚îÄ‚îÄ models.py             # Pydantic models\n‚îÇ   ‚îú‚îÄ‚îÄ main.py               # FastAPI app entry\n‚îÇ   ‚îú‚îÄ‚îÄ auth_system.py        # Authentication\n‚îÇ   ‚îú‚îÄ‚îÄ database.py           # Database operations\n‚îÇ   ‚îú‚îÄ‚îÄ services/             # Business logic\n‚îÇ   ‚îî‚îÄ‚îÄ tests/                # pytest tests\n‚îÇ\n‚îú‚îÄ‚îÄ deploy/                   # Deployment configs\n‚îú‚îÄ‚îÄ docs/                     # Documentation\n‚îî‚îÄ‚îÄ scripts/                  # Utility scripts\n```\n\n---\n\n## Code Patterns\n\n### API Response Format (FastAPI)\n\n```python\nfrom pydantic import BaseModel\nfrom typing import Generic, TypeVar, Optional\n\nT = TypeVar('T')\n\nclass ApiResponse(BaseModel, Generic[T]):\n    success: bool\n    data: Optional[T] = None\n    error: Optional[str] = None\n\n    @classmethod\n    def ok(cls, data: T) -> \"ApiResponse[T]\":\n        return cls(success=True, data=data)\n\n    @classmethod\n    def fail(cls, error: str) -> \"ApiResponse[T]\":\n        return cls(success=False, error=error)\n```\n\n### Frontend API Calls (TypeScript)\n\n```typescript\ninterface ApiResponse<T> {\n  success: boolean\n  data?: T\n  error?: string\n}\n\nasync function fetchApi<T>(\n  endpoint: string,\n  options?: RequestInit\n): Promise<ApiResponse<T>> {\n  try {\n    const response = await fetch(`/api${endpoint}`, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options?.headers,\n      },\n    })\n\n    if (!response.ok) {\n      return { success: false, error: `HTTP ${response.status}` }\n    }\n\n    return await response.json()\n  } catch (error) {\n    return { success: false, error: String(error) }\n  }\n}\n```\n\n### Claude AI Integration (Structured Output)\n\n```python\nfrom anthropic import Anthropic\nfrom pydantic import BaseModel\n\nclass AnalysisResult(BaseModel):\n    summary: str\n    key_points: list[str]\n    confidence: float\n\nasync def analyze_with_claude(content: str) -> AnalysisResult:\n    client = Anthropic()\n\n    response = client.messages.create(\n        model=\"claude-sonnet-4-5-20250514\",\n        max_tokens=1024,\n        messages=[{\"role\": \"user\", \"content\": content}],\n        tools=[{\n            \"name\": \"provide_analysis\",\n            \"description\": \"Provide structured analysis\",\n            \"input_schema\": AnalysisResult.model_json_schema()\n        }],\n        tool_choice={\"type\": \"tool\", \"name\": \"provide_analysis\"}\n    )\n\n    # Extract tool use result\n    tool_use = next(\n        block for block in response.content\n        if block.type == \"tool_use\"\n    )\n\n    return AnalysisResult(**tool_use.input)\n```\n\n### Custom Hooks (React)\n\n```typescript\nimport { useState, useCallback } from 'react'\n\ninterface UseApiState<T> {\n  data: T | null\n  loading: boolean\n  error: string | null\n}\n\nexport function useApi<T>(\n  fetchFn: () => Promise<ApiResponse<T>>\n) {\n  const [state, setState] = useState<UseApiState<T>>({\n    data: null,\n    loading: false,\n    error: null,\n  })\n\n  const execute = useCallback(async () => {\n    setState(prev => ({ ...prev, loading: true, error: null }))\n\n    const result = await fetchFn()\n\n    if (result.success) {\n      setState({ data: result.data!, loading: false, error: null })\n    } else {\n      setState({ data: null, loading: false, error: result.error! })\n    }\n  }, [fetchFn])\n\n  return { ...state, execute }\n}\n```\n\n---\n\n## Testing Requirements\n\n### Backend (pytest)\n\n```bash\n# Run all tests\npoetry run pytest tests/\n\n# Run with coverage\npoetry run pytest tests/ --cov=. --cov-report=html\n\n# Run specific test file\npoetry run pytest tests/test_auth.py -v\n```\n\n**Test structure:**\n```python\nimport pytest\nfrom httpx import AsyncClient\nfrom main import app\n\n@pytest.fixture\nasync def client():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        yield ac\n\n@pytest.mark.asyncio\nasync def test_health_check(client: AsyncClient):\n    response = await client.get(\"/health\")\n    assert response.status_code == 200\n    assert response.json()[\"status\"] == \"healthy\"\n```\n\n### Frontend (React Testing Library)\n\n```bash\n# Run tests\nnpm run test\n\n# Run with coverage\nnpm run test -- --coverage\n\n# Run E2E tests\nnpm run test:e2e\n```\n\n**Test structure:**\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport { WorkspacePanel } from './WorkspacePanel'\n\ndescribe('WorkspacePanel', () => {\n  it('renders workspace correctly', () => {\n    render(<WorkspacePanel />)\n    expect(screen.getByRole('main')).toBeInTheDocument()\n  })\n\n  it('handles session creation', async () => {\n    render(<WorkspacePanel />)\n    fireEvent.click(screen.getByText('New Session'))\n    expect(await screen.findByText('Session created')).toBeInTheDocument()\n  })\n})\n```\n\n---\n\n## Deployment Workflow\n\n### Pre-Deployment Checklist\n\n- [ ] All tests passing locally\n- [ ] `npm run build` succeeds (frontend)\n- [ ] `poetry run pytest` passes (backend)\n- [ ] No hardcoded secrets\n- [ ] Environment variables documented\n- [ ] Database migrations ready\n\n### Deployment Commands\n\n```bash\n# Build and deploy frontend\ncd frontend && npm run build\ngcloud run deploy frontend --source .\n\n# Build and deploy backend\ncd backend\ngcloud run deploy backend --source .\n```\n\n### Environment Variables\n\n```bash\n# Frontend (.env.local)\nNEXT_PUBLIC_API_URL=https://api.example.com\nNEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co\nNEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...\n\n# Backend (.env)\nDATABASE_URL=postgresql://...\nANTHROPIC_API_KEY=sk-ant-...\nSUPABASE_URL=https://xxx.supabase.co\nSUPABASE_KEY=eyJ...\n```\n\n---\n\n## Critical Rules\n\n1. **No emojis** in code, comments, or documentation\n2. **Immutability** - never mutate objects or arrays\n3. **TDD** - write tests before implementation\n4. **80% coverage** minimum\n5. **Many small files** - 200-400 lines typical, 800 max\n6. **No console.log** in production code\n7. **Proper error handling** with try/catch\n8. **Input validation** with Pydantic/Zod\n\n---\n\n## Related Skills\n\n- `coding-standards.md` - General coding best practices\n- `backend-patterns.md` - API and database patterns\n- `frontend-patterns.md` - React and Next.js patterns\n- `tdd-workflow/` - Test-driven development methodology\n",
        "skills/security-review/SKILL.md": "---\nname: security-review\ndescription: Use this skill when adding authentication, handling user input, working with secrets, creating API endpoints, or implementing payment/sensitive features. Provides comprehensive security checklist and patterns.\n---\n\n# Security Review Skill\n\nThis skill ensures all code follows security best practices and identifies potential vulnerabilities.\n\n## When to Activate\n\n- Implementing authentication or authorization\n- Handling user input or file uploads\n- Creating new API endpoints\n- Working with secrets or credentials\n- Implementing payment features\n- Storing or transmitting sensitive data\n- Integrating third-party APIs\n\n## Security Checklist\n\n### 1. Secrets Management\n\n#### ‚ùå NEVER Do This\n```typescript\nconst apiKey = \"sk-proj-xxxxx\"  // Hardcoded secret\nconst dbPassword = \"password123\" // In source code\n```\n\n#### ‚úÖ ALWAYS Do This\n```typescript\nconst apiKey = process.env.OPENAI_API_KEY\nconst dbUrl = process.env.DATABASE_URL\n\n// Verify secrets exist\nif (!apiKey) {\n  throw new Error('OPENAI_API_KEY not configured')\n}\n```\n\n#### Verification Steps\n- [ ] No hardcoded API keys, tokens, or passwords\n- [ ] All secrets in environment variables\n- [ ] `.env.local` in .gitignore\n- [ ] No secrets in git history\n- [ ] Production secrets in hosting platform (Vercel, Railway)\n\n### 2. Input Validation\n\n#### Always Validate User Input\n```typescript\nimport { z } from 'zod'\n\n// Define validation schema\nconst CreateUserSchema = z.object({\n  email: z.string().email(),\n  name: z.string().min(1).max(100),\n  age: z.number().int().min(0).max(150)\n})\n\n// Validate before processing\nexport async function createUser(input: unknown) {\n  try {\n    const validated = CreateUserSchema.parse(input)\n    return await db.users.create(validated)\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, errors: error.errors }\n    }\n    throw error\n  }\n}\n```\n\n#### File Upload Validation\n```typescript\nfunction validateFileUpload(file: File) {\n  // Size check (5MB max)\n  const maxSize = 5 * 1024 * 1024\n  if (file.size > maxSize) {\n    throw new Error('File too large (max 5MB)')\n  }\n\n  // Type check\n  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif']\n  if (!allowedTypes.includes(file.type)) {\n    throw new Error('Invalid file type')\n  }\n\n  // Extension check\n  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif']\n  const extension = file.name.toLowerCase().match(/\\.[^.]+$/)?.[0]\n  if (!extension || !allowedExtensions.includes(extension)) {\n    throw new Error('Invalid file extension')\n  }\n\n  return true\n}\n```\n\n#### Verification Steps\n- [ ] All user inputs validated with schemas\n- [ ] File uploads restricted (size, type, extension)\n- [ ] No direct use of user input in queries\n- [ ] Whitelist validation (not blacklist)\n- [ ] Error messages don't leak sensitive info\n\n### 3. SQL Injection Prevention\n\n#### ‚ùå NEVER Concatenate SQL\n```typescript\n// DANGEROUS - SQL Injection vulnerability\nconst query = `SELECT * FROM users WHERE email = '${userEmail}'`\nawait db.query(query)\n```\n\n#### ‚úÖ ALWAYS Use Parameterized Queries\n```typescript\n// Safe - parameterized query\nconst { data } = await supabase\n  .from('users')\n  .select('*')\n  .eq('email', userEmail)\n\n// Or with raw SQL\nawait db.query(\n  'SELECT * FROM users WHERE email = $1',\n  [userEmail]\n)\n```\n\n#### Verification Steps\n- [ ] All database queries use parameterized queries\n- [ ] No string concatenation in SQL\n- [ ] ORM/query builder used correctly\n- [ ] Supabase queries properly sanitized\n\n### 4. Authentication & Authorization\n\n#### JWT Token Handling\n```typescript\n// ‚ùå WRONG: localStorage (vulnerable to XSS)\nlocalStorage.setItem('token', token)\n\n// ‚úÖ CORRECT: httpOnly cookies\nres.setHeader('Set-Cookie',\n  `token=${token}; HttpOnly; Secure; SameSite=Strict; Max-Age=3600`)\n```\n\n#### Authorization Checks\n```typescript\nexport async function deleteUser(userId: string, requesterId: string) {\n  // ALWAYS verify authorization first\n  const requester = await db.users.findUnique({\n    where: { id: requesterId }\n  })\n\n  if (requester.role !== 'admin') {\n    return NextResponse.json(\n      { error: 'Unauthorized' },\n      { status: 403 }\n    )\n  }\n\n  // Proceed with deletion\n  await db.users.delete({ where: { id: userId } })\n}\n```\n\n#### Row Level Security (Supabase)\n```sql\n-- Enable RLS on all tables\nALTER TABLE users ENABLE ROW LEVEL SECURITY;\n\n-- Users can only view their own data\nCREATE POLICY \"Users view own data\"\n  ON users FOR SELECT\n  USING (auth.uid() = id);\n\n-- Users can only update their own data\nCREATE POLICY \"Users update own data\"\n  ON users FOR UPDATE\n  USING (auth.uid() = id);\n```\n\n#### Verification Steps\n- [ ] Tokens stored in httpOnly cookies (not localStorage)\n- [ ] Authorization checks before sensitive operations\n- [ ] Row Level Security enabled in Supabase\n- [ ] Role-based access control implemented\n- [ ] Session management secure\n\n### 5. XSS Prevention\n\n#### Sanitize HTML\n```typescript\nimport DOMPurify from 'isomorphic-dompurify'\n\n// ALWAYS sanitize user-provided HTML\nfunction renderUserContent(html: string) {\n  const clean = DOMPurify.sanitize(html, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p'],\n    ALLOWED_ATTR: []\n  })\n  return <div dangerouslySetInnerHTML={{ __html: clean }} />\n}\n```\n\n#### Content Security Policy\n```typescript\n// next.config.js\nconst securityHeaders = [\n  {\n    key: 'Content-Security-Policy',\n    value: `\n      default-src 'self';\n      script-src 'self' 'unsafe-eval' 'unsafe-inline';\n      style-src 'self' 'unsafe-inline';\n      img-src 'self' data: https:;\n      font-src 'self';\n      connect-src 'self' https://api.example.com;\n    `.replace(/\\s{2,}/g, ' ').trim()\n  }\n]\n```\n\n#### Verification Steps\n- [ ] User-provided HTML sanitized\n- [ ] CSP headers configured\n- [ ] No unvalidated dynamic content rendering\n- [ ] React's built-in XSS protection used\n\n### 6. CSRF Protection\n\n#### CSRF Tokens\n```typescript\nimport { csrf } from '@/lib/csrf'\n\nexport async function POST(request: Request) {\n  const token = request.headers.get('X-CSRF-Token')\n\n  if (!csrf.verify(token)) {\n    return NextResponse.json(\n      { error: 'Invalid CSRF token' },\n      { status: 403 }\n    )\n  }\n\n  // Process request\n}\n```\n\n#### SameSite Cookies\n```typescript\nres.setHeader('Set-Cookie',\n  `session=${sessionId}; HttpOnly; Secure; SameSite=Strict`)\n```\n\n#### Verification Steps\n- [ ] CSRF tokens on state-changing operations\n- [ ] SameSite=Strict on all cookies\n- [ ] Double-submit cookie pattern implemented\n\n### 7. Rate Limiting\n\n#### API Rate Limiting\n```typescript\nimport rateLimit from 'express-rate-limit'\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // 100 requests per window\n  message: 'Too many requests'\n})\n\n// Apply to routes\napp.use('/api/', limiter)\n```\n\n#### Expensive Operations\n```typescript\n// Aggressive rate limiting for searches\nconst searchLimiter = rateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 10, // 10 requests per minute\n  message: 'Too many search requests'\n})\n\napp.use('/api/search', searchLimiter)\n```\n\n#### Verification Steps\n- [ ] Rate limiting on all API endpoints\n- [ ] Stricter limits on expensive operations\n- [ ] IP-based rate limiting\n- [ ] User-based rate limiting (authenticated)\n\n### 8. Sensitive Data Exposure\n\n#### Logging\n```typescript\n// ‚ùå WRONG: Logging sensitive data\nconsole.log('User login:', { email, password })\nconsole.log('Payment:', { cardNumber, cvv })\n\n// ‚úÖ CORRECT: Redact sensitive data\nconsole.log('User login:', { email, userId })\nconsole.log('Payment:', { last4: card.last4, userId })\n```\n\n#### Error Messages\n```typescript\n// ‚ùå WRONG: Exposing internal details\ncatch (error) {\n  return NextResponse.json(\n    { error: error.message, stack: error.stack },\n    { status: 500 }\n  )\n}\n\n// ‚úÖ CORRECT: Generic error messages\ncatch (error) {\n  console.error('Internal error:', error)\n  return NextResponse.json(\n    { error: 'An error occurred. Please try again.' },\n    { status: 500 }\n  )\n}\n```\n\n#### Verification Steps\n- [ ] No passwords, tokens, or secrets in logs\n- [ ] Error messages generic for users\n- [ ] Detailed errors only in server logs\n- [ ] No stack traces exposed to users\n\n### 9. Blockchain Security (Solana)\n\n#### Wallet Verification\n```typescript\nimport { verify } from '@solana/web3.js'\n\nasync function verifyWalletOwnership(\n  publicKey: string,\n  signature: string,\n  message: string\n) {\n  try {\n    const isValid = verify(\n      Buffer.from(message),\n      Buffer.from(signature, 'base64'),\n      Buffer.from(publicKey, 'base64')\n    )\n    return isValid\n  } catch (error) {\n    return false\n  }\n}\n```\n\n#### Transaction Verification\n```typescript\nasync function verifyTransaction(transaction: Transaction) {\n  // Verify recipient\n  if (transaction.to !== expectedRecipient) {\n    throw new Error('Invalid recipient')\n  }\n\n  // Verify amount\n  if (transaction.amount > maxAmount) {\n    throw new Error('Amount exceeds limit')\n  }\n\n  // Verify user has sufficient balance\n  const balance = await getBalance(transaction.from)\n  if (balance < transaction.amount) {\n    throw new Error('Insufficient balance')\n  }\n\n  return true\n}\n```\n\n#### Verification Steps\n- [ ] Wallet signatures verified\n- [ ] Transaction details validated\n- [ ] Balance checks before transactions\n- [ ] No blind transaction signing\n\n### 10. Dependency Security\n\n#### Regular Updates\n```bash\n# Check for vulnerabilities\nnpm audit\n\n# Fix automatically fixable issues\nnpm audit fix\n\n# Update dependencies\nnpm update\n\n# Check for outdated packages\nnpm outdated\n```\n\n#### Lock Files\n```bash\n# ALWAYS commit lock files\ngit add package-lock.json\n\n# Use in CI/CD for reproducible builds\nnpm ci  # Instead of npm install\n```\n\n#### Verification Steps\n- [ ] Dependencies up to date\n- [ ] No known vulnerabilities (npm audit clean)\n- [ ] Lock files committed\n- [ ] Dependabot enabled on GitHub\n- [ ] Regular security updates\n\n## Security Testing\n\n### Automated Security Tests\n```typescript\n// Test authentication\ntest('requires authentication', async () => {\n  const response = await fetch('/api/protected')\n  expect(response.status).toBe(401)\n})\n\n// Test authorization\ntest('requires admin role', async () => {\n  const response = await fetch('/api/admin', {\n    headers: { Authorization: `Bearer ${userToken}` }\n  })\n  expect(response.status).toBe(403)\n})\n\n// Test input validation\ntest('rejects invalid input', async () => {\n  const response = await fetch('/api/users', {\n    method: 'POST',\n    body: JSON.stringify({ email: 'not-an-email' })\n  })\n  expect(response.status).toBe(400)\n})\n\n// Test rate limiting\ntest('enforces rate limits', async () => {\n  const requests = Array(101).fill(null).map(() =>\n    fetch('/api/endpoint')\n  )\n\n  const responses = await Promise.all(requests)\n  const tooManyRequests = responses.filter(r => r.status === 429)\n\n  expect(tooManyRequests.length).toBeGreaterThan(0)\n})\n```\n\n## Pre-Deployment Security Checklist\n\nBefore ANY production deployment:\n\n- [ ] **Secrets**: No hardcoded secrets, all in env vars\n- [ ] **Input Validation**: All user inputs validated\n- [ ] **SQL Injection**: All queries parameterized\n- [ ] **XSS**: User content sanitized\n- [ ] **CSRF**: Protection enabled\n- [ ] **Authentication**: Proper token handling\n- [ ] **Authorization**: Role checks in place\n- [ ] **Rate Limiting**: Enabled on all endpoints\n- [ ] **HTTPS**: Enforced in production\n- [ ] **Security Headers**: CSP, X-Frame-Options configured\n- [ ] **Error Handling**: No sensitive data in errors\n- [ ] **Logging**: No sensitive data logged\n- [ ] **Dependencies**: Up to date, no vulnerabilities\n- [ ] **Row Level Security**: Enabled in Supabase\n- [ ] **CORS**: Properly configured\n- [ ] **File Uploads**: Validated (size, type)\n- [ ] **Wallet Signatures**: Verified (if blockchain)\n\n## Resources\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [Next.js Security](https://nextjs.org/docs/security)\n- [Supabase Security](https://supabase.com/docs/guides/auth)\n- [Web Security Academy](https://portswigger.net/web-security)\n\n---\n\n**Remember**: Security is not optional. One vulnerability can compromise the entire platform. When in doubt, err on the side of caution.\n",
        "skills/strategic-compact/SKILL.md": "---\nname: strategic-compact\ndescription: Suggests manual context compaction at logical intervals to preserve context through task phases rather than arbitrary auto-compaction.\n---\n\n# Strategic Compact Skill\n\nSuggests manual `/compact` at strategic points in your workflow rather than relying on arbitrary auto-compaction.\n\n## Why Strategic Compaction?\n\nAuto-compaction triggers at arbitrary points:\n- Often mid-task, losing important context\n- No awareness of logical task boundaries\n- Can interrupt complex multi-step operations\n\nStrategic compaction at logical boundaries:\n- **After exploration, before execution** - Compact research context, keep implementation plan\n- **After completing a milestone** - Fresh start for next phase\n- **Before major context shifts** - Clear exploration context before different task\n\n## How It Works\n\nThe `suggest-compact.sh` script runs on PreToolUse (Edit/Write) and:\n\n1. **Tracks tool calls** - Counts tool invocations in session\n2. **Threshold detection** - Suggests at configurable threshold (default: 50 calls)\n3. **Periodic reminders** - Reminds every 25 calls after threshold\n\n## Hook Setup\n\nAdd to your `~/.claude/settings.json`:\n\n```json\n{\n  \"hooks\": {\n    \"PreToolUse\": [{\n      \"matcher\": \"tool == \\\"Edit\\\" || tool == \\\"Write\\\"\",\n      \"hooks\": [{\n        \"type\": \"command\",\n        \"command\": \"~/.claude/skills/strategic-compact/suggest-compact.sh\"\n      }]\n    }]\n  }\n}\n```\n\n## Configuration\n\nEnvironment variables:\n- `COMPACT_THRESHOLD` - Tool calls before first suggestion (default: 50)\n\n## Best Practices\n\n1. **Compact after planning** - Once plan is finalized, compact to start fresh\n2. **Compact after debugging** - Clear error-resolution context before continuing\n3. **Don't compact mid-implementation** - Preserve context for related changes\n4. **Read the suggestion** - The hook tells you *when*, you decide *if*\n\n## Related\n\n- [The Longform Guide](https://x.com/affaanmustafa/status/2014040193557471352) - Token optimization section\n- Memory persistence hooks - For state that survives compaction\n",
        "skills/tdd-workflow/SKILL.md": "---\nname: tdd-workflow\ndescription: Use this skill when writing new features, fixing bugs, or refactoring code. Enforces test-driven development with 80%+ coverage including unit, integration, and E2E tests.\n---\n\n# Test-Driven Development Workflow\n\nThis skill ensures all code development follows TDD principles with comprehensive test coverage.\n\n## When to Activate\n\n- Writing new features or functionality\n- Fixing bugs or issues\n- Refactoring existing code\n- Adding API endpoints\n- Creating new components\n\n## Core Principles\n\n### 1. Tests BEFORE Code\nALWAYS write tests first, then implement code to make tests pass.\n\n### 2. Coverage Requirements\n- Minimum 80% coverage (unit + integration + E2E)\n- All edge cases covered\n- Error scenarios tested\n- Boundary conditions verified\n\n### 3. Test Types\n\n#### Unit Tests\n- Individual functions and utilities\n- Component logic\n- Pure functions\n- Helpers and utilities\n\n#### Integration Tests\n- API endpoints\n- Database operations\n- Service interactions\n- External API calls\n\n#### E2E Tests (Playwright)\n- Critical user flows\n- Complete workflows\n- Browser automation\n- UI interactions\n\n## TDD Workflow Steps\n\n### Step 1: Write User Journeys\n```\nAs a [role], I want to [action], so that [benefit]\n\nExample:\nAs a user, I want to search for markets semantically,\nso that I can find relevant markets even without exact keywords.\n```\n\n### Step 2: Generate Test Cases\nFor each user journey, create comprehensive test cases:\n\n```typescript\ndescribe('Semantic Search', () => {\n  it('returns relevant markets for query', async () => {\n    // Test implementation\n  })\n\n  it('handles empty query gracefully', async () => {\n    // Test edge case\n  })\n\n  it('falls back to substring search when Redis unavailable', async () => {\n    // Test fallback behavior\n  })\n\n  it('sorts results by similarity score', async () => {\n    // Test sorting logic\n  })\n})\n```\n\n### Step 3: Run Tests (They Should Fail)\n```bash\nnpm test\n# Tests should fail - we haven't implemented yet\n```\n\n### Step 4: Implement Code\nWrite minimal code to make tests pass:\n\n```typescript\n// Implementation guided by tests\nexport async function searchMarkets(query: string) {\n  // Implementation here\n}\n```\n\n### Step 5: Run Tests Again\n```bash\nnpm test\n# Tests should now pass\n```\n\n### Step 6: Refactor\nImprove code quality while keeping tests green:\n- Remove duplication\n- Improve naming\n- Optimize performance\n- Enhance readability\n\n### Step 7: Verify Coverage\n```bash\nnpm run test:coverage\n# Verify 80%+ coverage achieved\n```\n\n## Testing Patterns\n\n### Unit Test Pattern (Jest/Vitest)\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport { Button } from './Button'\n\ndescribe('Button Component', () => {\n  it('renders with correct text', () => {\n    render(<Button>Click me</Button>)\n    expect(screen.getByText('Click me')).toBeInTheDocument()\n  })\n\n  it('calls onClick when clicked', () => {\n    const handleClick = jest.fn()\n    render(<Button onClick={handleClick}>Click</Button>)\n\n    fireEvent.click(screen.getByRole('button'))\n\n    expect(handleClick).toHaveBeenCalledTimes(1)\n  })\n\n  it('is disabled when disabled prop is true', () => {\n    render(<Button disabled>Click</Button>)\n    expect(screen.getByRole('button')).toBeDisabled()\n  })\n})\n```\n\n### API Integration Test Pattern\n```typescript\nimport { NextRequest } from 'next/server'\nimport { GET } from './route'\n\ndescribe('GET /api/markets', () => {\n  it('returns markets successfully', async () => {\n    const request = new NextRequest('http://localhost/api/markets')\n    const response = await GET(request)\n    const data = await response.json()\n\n    expect(response.status).toBe(200)\n    expect(data.success).toBe(true)\n    expect(Array.isArray(data.data)).toBe(true)\n  })\n\n  it('validates query parameters', async () => {\n    const request = new NextRequest('http://localhost/api/markets?limit=invalid')\n    const response = await GET(request)\n\n    expect(response.status).toBe(400)\n  })\n\n  it('handles database errors gracefully', async () => {\n    // Mock database failure\n    const request = new NextRequest('http://localhost/api/markets')\n    // Test error handling\n  })\n})\n```\n\n### E2E Test Pattern (Playwright)\n```typescript\nimport { test, expect } from '@playwright/test'\n\ntest('user can search and filter markets', async ({ page }) => {\n  // Navigate to markets page\n  await page.goto('/')\n  await page.click('a[href=\"/markets\"]')\n\n  // Verify page loaded\n  await expect(page.locator('h1')).toContainText('Markets')\n\n  // Search for markets\n  await page.fill('input[placeholder=\"Search markets\"]', 'election')\n\n  // Wait for debounce and results\n  await page.waitForTimeout(600)\n\n  // Verify search results displayed\n  const results = page.locator('[data-testid=\"market-card\"]')\n  await expect(results).toHaveCount(5, { timeout: 5000 })\n\n  // Verify results contain search term\n  const firstResult = results.first()\n  await expect(firstResult).toContainText('election', { ignoreCase: true })\n\n  // Filter by status\n  await page.click('button:has-text(\"Active\")')\n\n  // Verify filtered results\n  await expect(results).toHaveCount(3)\n})\n\ntest('user can create a new market', async ({ page }) => {\n  // Login first\n  await page.goto('/creator-dashboard')\n\n  // Fill market creation form\n  await page.fill('input[name=\"name\"]', 'Test Market')\n  await page.fill('textarea[name=\"description\"]', 'Test description')\n  await page.fill('input[name=\"endDate\"]', '2025-12-31')\n\n  // Submit form\n  await page.click('button[type=\"submit\"]')\n\n  // Verify success message\n  await expect(page.locator('text=Market created successfully')).toBeVisible()\n\n  // Verify redirect to market page\n  await expect(page).toHaveURL(/\\/markets\\/test-market/)\n})\n```\n\n## Test File Organization\n\n```\nsrc/\n‚îú‚îÄ‚îÄ components/\n‚îÇ   ‚îú‚îÄ‚îÄ Button/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.test.tsx          # Unit tests\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Button.stories.tsx       # Storybook\n‚îÇ   ‚îî‚îÄ‚îÄ MarketCard/\n‚îÇ       ‚îú‚îÄ‚îÄ MarketCard.tsx\n‚îÇ       ‚îî‚îÄ‚îÄ MarketCard.test.tsx\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îî‚îÄ‚îÄ api/\n‚îÇ       ‚îî‚îÄ‚îÄ markets/\n‚îÇ           ‚îú‚îÄ‚îÄ route.ts\n‚îÇ           ‚îî‚îÄ‚îÄ route.test.ts         # Integration tests\n‚îî‚îÄ‚îÄ e2e/\n    ‚îú‚îÄ‚îÄ markets.spec.ts               # E2E tests\n    ‚îú‚îÄ‚îÄ trading.spec.ts\n    ‚îî‚îÄ‚îÄ auth.spec.ts\n```\n\n## Mocking External Services\n\n### Supabase Mock\n```typescript\njest.mock('@/lib/supabase', () => ({\n  supabase: {\n    from: jest.fn(() => ({\n      select: jest.fn(() => ({\n        eq: jest.fn(() => Promise.resolve({\n          data: [{ id: 1, name: 'Test Market' }],\n          error: null\n        }))\n      }))\n    }))\n  }\n}))\n```\n\n### Redis Mock\n```typescript\njest.mock('@/lib/redis', () => ({\n  searchMarketsByVector: jest.fn(() => Promise.resolve([\n    { slug: 'test-market', similarity_score: 0.95 }\n  ])),\n  checkRedisHealth: jest.fn(() => Promise.resolve({ connected: true }))\n}))\n```\n\n### OpenAI Mock\n```typescript\njest.mock('@/lib/openai', () => ({\n  generateEmbedding: jest.fn(() => Promise.resolve(\n    new Array(1536).fill(0.1) // Mock 1536-dim embedding\n  ))\n}))\n```\n\n## Test Coverage Verification\n\n### Run Coverage Report\n```bash\nnpm run test:coverage\n```\n\n### Coverage Thresholds\n```json\n{\n  \"jest\": {\n    \"coverageThresholds\": {\n      \"global\": {\n        \"branches\": 80,\n        \"functions\": 80,\n        \"lines\": 80,\n        \"statements\": 80\n      }\n    }\n  }\n}\n```\n\n## Common Testing Mistakes to Avoid\n\n### ‚ùå WRONG: Testing Implementation Details\n```typescript\n// Don't test internal state\nexpect(component.state.count).toBe(5)\n```\n\n### ‚úÖ CORRECT: Test User-Visible Behavior\n```typescript\n// Test what users see\nexpect(screen.getByText('Count: 5')).toBeInTheDocument()\n```\n\n### ‚ùå WRONG: Brittle Selectors\n```typescript\n// Breaks easily\nawait page.click('.css-class-xyz')\n```\n\n### ‚úÖ CORRECT: Semantic Selectors\n```typescript\n// Resilient to changes\nawait page.click('button:has-text(\"Submit\")')\nawait page.click('[data-testid=\"submit-button\"]')\n```\n\n### ‚ùå WRONG: No Test Isolation\n```typescript\n// Tests depend on each other\ntest('creates user', () => { /* ... */ })\ntest('updates same user', () => { /* depends on previous test */ })\n```\n\n### ‚úÖ CORRECT: Independent Tests\n```typescript\n// Each test sets up its own data\ntest('creates user', () => {\n  const user = createTestUser()\n  // Test logic\n})\n\ntest('updates user', () => {\n  const user = createTestUser()\n  // Update logic\n})\n```\n\n## Continuous Testing\n\n### Watch Mode During Development\n```bash\nnpm test -- --watch\n# Tests run automatically on file changes\n```\n\n### Pre-Commit Hook\n```bash\n# Runs before every commit\nnpm test && npm run lint\n```\n\n### CI/CD Integration\n```yaml\n# GitHub Actions\n- name: Run Tests\n  run: npm test -- --coverage\n- name: Upload Coverage\n  uses: codecov/codecov-action@v3\n```\n\n## Best Practices\n\n1. **Write Tests First** - Always TDD\n2. **One Assert Per Test** - Focus on single behavior\n3. **Descriptive Test Names** - Explain what's tested\n4. **Arrange-Act-Assert** - Clear test structure\n5. **Mock External Dependencies** - Isolate unit tests\n6. **Test Edge Cases** - Null, undefined, empty, large\n7. **Test Error Paths** - Not just happy paths\n8. **Keep Tests Fast** - Unit tests < 50ms each\n9. **Clean Up After Tests** - No side effects\n10. **Review Coverage Reports** - Identify gaps\n\n## Success Metrics\n\n- 80%+ code coverage achieved\n- All tests passing (green)\n- No skipped or disabled tests\n- Fast test execution (< 30s for unit tests)\n- E2E tests cover critical user flows\n- Tests catch bugs before production\n\n---\n\n**Remember**: Tests are not optional. They are the safety net that enables confident refactoring, rapid development, and production reliability.\n",
        "skills/verification-loop/SKILL.md": "# Verification Loop Skill\n\nA comprehensive verification system for Claude Code sessions.\n\n## When to Use\n\nInvoke this skill:\n- After completing a feature or significant code change\n- Before creating a PR\n- When you want to ensure quality gates pass\n- After refactoring\n\n## Verification Phases\n\n### Phase 1: Build Verification\n```bash\n# Check if project builds\nnpm run build 2>&1 | tail -20\n# OR\npnpm build 2>&1 | tail -20\n```\n\nIf build fails, STOP and fix before continuing.\n\n### Phase 2: Type Check\n```bash\n# TypeScript projects\nnpx tsc --noEmit 2>&1 | head -30\n\n# Python projects\npyright . 2>&1 | head -30\n```\n\nReport all type errors. Fix critical ones before continuing.\n\n### Phase 3: Lint Check\n```bash\n# JavaScript/TypeScript\nnpm run lint 2>&1 | head -30\n\n# Python\nruff check . 2>&1 | head -30\n```\n\n### Phase 4: Test Suite\n```bash\n# Run tests with coverage\nnpm run test -- --coverage 2>&1 | tail -50\n\n# Check coverage threshold\n# Target: 80% minimum\n```\n\nReport:\n- Total tests: X\n- Passed: X\n- Failed: X\n- Coverage: X%\n\n### Phase 5: Security Scan\n```bash\n# Check for secrets\ngrep -rn \"sk-\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | head -10\ngrep -rn \"api_key\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | head -10\n\n# Check for console.log\ngrep -rn \"console.log\" --include=\"*.ts\" --include=\"*.tsx\" src/ 2>/dev/null | head -10\n```\n\n### Phase 6: Diff Review\n```bash\n# Show what changed\ngit diff --stat\ngit diff HEAD~1 --name-only\n```\n\nReview each changed file for:\n- Unintended changes\n- Missing error handling\n- Potential edge cases\n\n## Output Format\n\nAfter running all phases, produce a verification report:\n\n```\nVERIFICATION REPORT\n==================\n\nBuild:     [PASS/FAIL]\nTypes:     [PASS/FAIL] (X errors)\nLint:      [PASS/FAIL] (X warnings)\nTests:     [PASS/FAIL] (X/Y passed, Z% coverage)\nSecurity:  [PASS/FAIL] (X issues)\nDiff:      [X files changed]\n\nOverall:   [READY/NOT READY] for PR\n\nIssues to Fix:\n1. ...\n2. ...\n```\n\n## Continuous Mode\n\nFor long sessions, run verification every 15 minutes or after major changes:\n\n```markdown\nSet a mental checkpoint:\n- After completing each function\n- After finishing a component\n- Before moving to next task\n\nRun: /verify\n```\n\n## Integration with Hooks\n\nThis skill complements PostToolUse hooks but provides deeper verification.\nHooks catch issues immediately; this skill provides comprehensive review.\n",
        "tests/hooks/hooks.test.js": "/**\n * Tests for hook scripts\n *\n * Run with: node tests/hooks/hooks.test.js\n */\n\nconst assert = require('assert');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\nconst { execSync, spawn } = require('child_process');\n\n// Test helper\nfunction test(name, fn) {\n  try {\n    fn();\n    console.log(`  ‚úì ${name}`);\n    return true;\n  } catch (err) {\n    console.log(`  ‚úó ${name}`);\n    console.log(`    Error: ${err.message}`);\n    return false;\n  }\n}\n\n// Async test helper\nasync function asyncTest(name, fn) {\n  try {\n    await fn();\n    console.log(`  ‚úì ${name}`);\n    return true;\n  } catch (err) {\n    console.log(`  ‚úó ${name}`);\n    console.log(`    Error: ${err.message}`);\n    return false;\n  }\n}\n\n// Run a script and capture output\nfunction runScript(scriptPath, input = '', env = {}) {\n  return new Promise((resolve, reject) => {\n    const proc = spawn('node', [scriptPath], {\n      env: { ...process.env, ...env },\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    proc.stdout.on('data', data => stdout += data);\n    proc.stderr.on('data', data => stderr += data);\n\n    if (input) {\n      proc.stdin.write(input);\n    }\n    proc.stdin.end();\n\n    proc.on('close', code => {\n      resolve({ code, stdout, stderr });\n    });\n\n    proc.on('error', reject);\n  });\n}\n\n// Create a temporary test directory\nfunction createTestDir() {\n  const testDir = path.join(os.tmpdir(), `hooks-test-${Date.now()}`);\n  fs.mkdirSync(testDir, { recursive: true });\n  return testDir;\n}\n\n// Clean up test directory\nfunction cleanupTestDir(testDir) {\n  fs.rmSync(testDir, { recursive: true, force: true });\n}\n\n// Test suite\nasync function runTests() {\n  console.log('\\n=== Testing Hook Scripts ===\\n');\n\n  let passed = 0;\n  let failed = 0;\n\n  const scriptsDir = path.join(__dirname, '..', '..', 'scripts', 'hooks');\n\n  // session-start.js tests\n  console.log('session-start.js:');\n\n  if (await asyncTest('runs without error', async () => {\n    const result = await runScript(path.join(scriptsDir, 'session-start.js'));\n    assert.strictEqual(result.code, 0, `Exit code should be 0, got ${result.code}`);\n  })) passed++; else failed++;\n\n  if (await asyncTest('outputs session info to stderr', async () => {\n    const result = await runScript(path.join(scriptsDir, 'session-start.js'));\n    assert.ok(\n      result.stderr.includes('[SessionStart]') ||\n      result.stderr.includes('Package manager'),\n      'Should output session info'\n    );\n  })) passed++; else failed++;\n\n  // session-end.js tests\n  console.log('\\nsession-end.js:');\n\n  if (await asyncTest('runs without error', async () => {\n    const result = await runScript(path.join(scriptsDir, 'session-end.js'));\n    assert.strictEqual(result.code, 0, `Exit code should be 0, got ${result.code}`);\n  })) passed++; else failed++;\n\n  if (await asyncTest('creates or updates session file', async () => {\n    // Run the script\n    await runScript(path.join(scriptsDir, 'session-end.js'));\n\n    // Check if session file was created\n    const sessionsDir = path.join(os.homedir(), '.claude', 'sessions');\n    const today = new Date().toISOString().split('T')[0];\n    const sessionFile = path.join(sessionsDir, `${today}-session.tmp`);\n\n    assert.ok(fs.existsSync(sessionFile), 'Session file should exist');\n  })) passed++; else failed++;\n\n  // pre-compact.js tests\n  console.log('\\npre-compact.js:');\n\n  if (await asyncTest('runs without error', async () => {\n    const result = await runScript(path.join(scriptsDir, 'pre-compact.js'));\n    assert.strictEqual(result.code, 0, `Exit code should be 0, got ${result.code}`);\n  })) passed++; else failed++;\n\n  if (await asyncTest('outputs PreCompact message', async () => {\n    const result = await runScript(path.join(scriptsDir, 'pre-compact.js'));\n    assert.ok(result.stderr.includes('[PreCompact]'), 'Should output PreCompact message');\n  })) passed++; else failed++;\n\n  if (await asyncTest('creates compaction log', async () => {\n    await runScript(path.join(scriptsDir, 'pre-compact.js'));\n    const logFile = path.join(os.homedir(), '.claude', 'sessions', 'compaction-log.txt');\n    assert.ok(fs.existsSync(logFile), 'Compaction log should exist');\n  })) passed++; else failed++;\n\n  // suggest-compact.js tests\n  console.log('\\nsuggest-compact.js:');\n\n  if (await asyncTest('runs without error', async () => {\n    const result = await runScript(path.join(scriptsDir, 'suggest-compact.js'), '', {\n      CLAUDE_SESSION_ID: 'test-session-' + Date.now()\n    });\n    assert.strictEqual(result.code, 0, `Exit code should be 0, got ${result.code}`);\n  })) passed++; else failed++;\n\n  if (await asyncTest('increments counter on each call', async () => {\n    const sessionId = 'test-counter-' + Date.now();\n\n    // Run multiple times\n    for (let i = 0; i < 3; i++) {\n      await runScript(path.join(scriptsDir, 'suggest-compact.js'), '', {\n        CLAUDE_SESSION_ID: sessionId\n      });\n    }\n\n    // Check counter file\n    const counterFile = path.join(os.tmpdir(), `claude-tool-count-${sessionId}`);\n    const count = parseInt(fs.readFileSync(counterFile, 'utf8').trim(), 10);\n    assert.strictEqual(count, 3, `Counter should be 3, got ${count}`);\n\n    // Cleanup\n    fs.unlinkSync(counterFile);\n  })) passed++; else failed++;\n\n  if (await asyncTest('suggests compact at threshold', async () => {\n    const sessionId = 'test-threshold-' + Date.now();\n    const counterFile = path.join(os.tmpdir(), `claude-tool-count-${sessionId}`);\n\n    // Set counter to threshold - 1\n    fs.writeFileSync(counterFile, '49');\n\n    const result = await runScript(path.join(scriptsDir, 'suggest-compact.js'), '', {\n      CLAUDE_SESSION_ID: sessionId,\n      COMPACT_THRESHOLD: '50'\n    });\n\n    assert.ok(\n      result.stderr.includes('50 tool calls reached'),\n      'Should suggest compact at threshold'\n    );\n\n    // Cleanup\n    fs.unlinkSync(counterFile);\n  })) passed++; else failed++;\n\n  // evaluate-session.js tests\n  console.log('\\nevaluate-session.js:');\n\n  if (await asyncTest('runs without error when no transcript', async () => {\n    const result = await runScript(path.join(scriptsDir, 'evaluate-session.js'));\n    assert.strictEqual(result.code, 0, `Exit code should be 0, got ${result.code}`);\n  })) passed++; else failed++;\n\n  if (await asyncTest('skips short sessions', async () => {\n    const testDir = createTestDir();\n    const transcriptPath = path.join(testDir, 'transcript.jsonl');\n\n    // Create a short transcript (less than 10 user messages)\n    const transcript = Array(5).fill('{\"type\":\"user\",\"content\":\"test\"}\\n').join('');\n    fs.writeFileSync(transcriptPath, transcript);\n\n    const result = await runScript(path.join(scriptsDir, 'evaluate-session.js'), '', {\n      CLAUDE_TRANSCRIPT_PATH: transcriptPath\n    });\n\n    assert.ok(\n      result.stderr.includes('Session too short'),\n      'Should indicate session is too short'\n    );\n\n    cleanupTestDir(testDir);\n  })) passed++; else failed++;\n\n  if (await asyncTest('processes sessions with enough messages', async () => {\n    const testDir = createTestDir();\n    const transcriptPath = path.join(testDir, 'transcript.jsonl');\n\n    // Create a longer transcript (more than 10 user messages)\n    const transcript = Array(15).fill('{\"type\":\"user\",\"content\":\"test\"}\\n').join('');\n    fs.writeFileSync(transcriptPath, transcript);\n\n    const result = await runScript(path.join(scriptsDir, 'evaluate-session.js'), '', {\n      CLAUDE_TRANSCRIPT_PATH: transcriptPath\n    });\n\n    assert.ok(\n      result.stderr.includes('15 messages'),\n      'Should report message count'\n    );\n\n    cleanupTestDir(testDir);\n  })) passed++; else failed++;\n\n  // hooks.json validation\n  console.log('\\nhooks.json Validation:');\n\n  if (test('hooks.json is valid JSON', () => {\n    const hooksPath = path.join(__dirname, '..', '..', 'hooks', 'hooks.json');\n    const content = fs.readFileSync(hooksPath, 'utf8');\n    JSON.parse(content); // Will throw if invalid\n  })) passed++; else failed++;\n\n  if (test('hooks.json has required event types', () => {\n    const hooksPath = path.join(__dirname, '..', '..', 'hooks', 'hooks.json');\n    const hooks = JSON.parse(fs.readFileSync(hooksPath, 'utf8'));\n\n    assert.ok(hooks.hooks.PreToolUse, 'Should have PreToolUse hooks');\n    assert.ok(hooks.hooks.PostToolUse, 'Should have PostToolUse hooks');\n    assert.ok(hooks.hooks.SessionStart, 'Should have SessionStart hooks');\n    assert.ok(hooks.hooks.Stop, 'Should have Stop hooks');\n    assert.ok(hooks.hooks.PreCompact, 'Should have PreCompact hooks');\n  })) passed++; else failed++;\n\n  if (test('all hook commands use node', () => {\n    const hooksPath = path.join(__dirname, '..', '..', 'hooks', 'hooks.json');\n    const hooks = JSON.parse(fs.readFileSync(hooksPath, 'utf8'));\n\n    const checkHooks = (hookArray) => {\n      for (const entry of hookArray) {\n        for (const hook of entry.hooks) {\n          if (hook.type === 'command') {\n            assert.ok(\n              hook.command.startsWith('node'),\n              `Hook command should start with 'node': ${hook.command.substring(0, 50)}...`\n            );\n          }\n        }\n      }\n    };\n\n    for (const [eventType, hookArray] of Object.entries(hooks.hooks)) {\n      checkHooks(hookArray);\n    }\n  })) passed++; else failed++;\n\n  if (test('script references use CLAUDE_PLUGIN_ROOT variable', () => {\n    const hooksPath = path.join(__dirname, '..', '..', 'hooks', 'hooks.json');\n    const hooks = JSON.parse(fs.readFileSync(hooksPath, 'utf8'));\n\n    const checkHooks = (hookArray) => {\n      for (const entry of hookArray) {\n        for (const hook of entry.hooks) {\n          if (hook.type === 'command' && hook.command.includes('scripts/hooks/')) {\n            // Check for the literal string \"${CLAUDE_PLUGIN_ROOT}\" in the command\n            const hasPluginRoot = hook.command.includes('${CLAUDE_PLUGIN_ROOT}');\n            assert.ok(\n              hasPluginRoot,\n              `Script paths should use CLAUDE_PLUGIN_ROOT: ${hook.command.substring(0, 80)}...`\n            );\n          }\n        }\n      }\n    };\n\n    for (const [eventType, hookArray] of Object.entries(hooks.hooks)) {\n      checkHooks(hookArray);\n    }\n  })) passed++; else failed++;\n\n  // Summary\n  console.log('\\n=== Test Results ===');\n  console.log(`Passed: ${passed}`);\n  console.log(`Failed: ${failed}`);\n  console.log(`Total:  ${passed + failed}\\n`);\n\n  process.exit(failed > 0 ? 1 : 0);\n}\n\nrunTests();\n"
      },
      "plugins": [
        {
          "name": "everything-claude-code",
          "source": "./",
          "description": "Complete collection of agents, skills, hooks, commands, and rules evolved over 10+ months of intensive daily use",
          "author": {
            "name": "Affaan Mustafa"
          },
          "homepage": "https://github.com/affaan-m/everything-claude-code",
          "repository": "https://github.com/affaan-m/everything-claude-code",
          "license": "MIT",
          "keywords": [
            "agents",
            "skills",
            "hooks",
            "commands",
            "tdd",
            "code-review",
            "security",
            "best-practices"
          ],
          "category": "workflow",
          "tags": [
            "agents",
            "skills",
            "hooks",
            "commands",
            "tdd",
            "code-review",
            "security",
            "best-practices"
          ],
          "categories": [
            "agents",
            "best-practices",
            "code-review",
            "commands",
            "hooks",
            "security",
            "skills",
            "tdd",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add WorldFlowAI/everything-claude-code",
            "/plugin install everything-claude-code@everything-claude-code"
          ]
        }
      ]
    }
  ]
}