{
  "author": {
    "id": "swiftwasm",
    "display_name": "SwiftWasm",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/49500752?v=4",
    "url": "https://github.com/swiftwasm",
    "bio": "SwiftWasm compiles your Swift code to WebAssembly.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 0,
      "total_skills": 3,
      "total_stars": 24,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "swiftwasm-skills",
      "version": null,
      "description": "Agent Skills for SwiftWasm ecosystem",
      "owner_info": {
        "name": "SwiftWasm"
      },
      "keywords": [],
      "repo_full_name": "swiftwasm/skills",
      "repo_url": "https://github.com/swiftwasm/skills",
      "repo_description": "A collection of Agent Skills designed to help AI coding agents build and maintain Swift applications targeting WebAssembly.",
      "homepage": "",
      "signals": {
        "stars": 24,
        "forks": 1,
        "pushed_at": "2026-01-26T14:05:34Z",
        "created_at": "2026-01-11T09:11:14Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1023
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3186
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/bridgejs",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/bridgejs/SKILL.md",
          "type": "blob",
          "size": 1674
        },
        {
          "path": "skills/bridgejs/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/bridgejs/references/project_setup.md",
          "type": "blob",
          "size": 7234
        },
        {
          "path": "skills/bridgejs/references/swift_api.md",
          "type": "blob",
          "size": 14086
        },
        {
          "path": "skills/bridgejs/references/testing.md",
          "type": "blob",
          "size": 1859
        },
        {
          "path": "skills/javascriptkit",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/javascriptkit/SKILL.md",
          "type": "blob",
          "size": 738
        },
        {
          "path": "skills/javascriptkit/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/javascriptkit/references/common_patterns.md",
          "type": "blob",
          "size": 5407
        },
        {
          "path": "skills/javascriptkit/references/init_new_project.md",
          "type": "blob",
          "size": 4568
        },
        {
          "path": "skills/javascriptkit/references/swift_apis.md",
          "type": "blob",
          "size": 13272
        },
        {
          "path": "skills/porting",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/porting/SKILL.md",
          "type": "blob",
          "size": 1731
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"swiftwasm-skills\",\n  \"owner\": {\n    \"name\": \"SwiftWasm\"\n  },\n  \"metadata\": {\n    \"description\": \"Agent Skills for SwiftWasm ecosystem\",\n    \"version\": \"0.0.1\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"javascriptkit\",\n      \"description\": \"Assist Swift developers who consume JavaScriptKit, a Swift library for interacting with JavaScript APIs via WebAssembly\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/javascriptkit\"\n      ]\n    },\n    {\n      \"name\": \"bridgejs\",\n      \"description\": \"Assist Swift developers using BridgeJS for Swift-to-JavaScript interoperability in WebAssembly projects\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/bridgejs\"\n      ]\n    },\n    {\n      \"name\": \"porting\",\n      \"description\": \"Check Swift on Wasm compatibility, identify incompatible frameworks, port and refactor code for WebAssembly\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/porting\"\n      ]\n    }\n  ]\n}\n",
        "README.md": "# SwiftWasm Agent Skills\n\nA collection of [Agent Skills](https://agentskills.io/) designed to help AI coding agents build and maintain Swift applications targeting WebAssembly.\n\n## What are Agent Skills?\n\nAgent Skills are specialized modules containing instructions, scripts, and documentation that give AI agents (like Claude, Gemini, or Codex) the domain expertise needed to perform complex tasks.\n\nThis repository is compatible with major agent tools, leveraging standardized formats to ensure your agent has the right context for SwiftWasm development.\n\n## Installation\n\n### Claude Code\n\n1. Add this repository as a plugin marketplace:\n   ```bash\n   claude plugin marketplace add swiftwasm/skills\n   ```\n\n2. Install skills using a loop:\n   ```bash\n   for skill in javascriptkit bridgejs porting; do\n     claude plugin install ${skill}@swiftwasm-skills\n   done\n   ```\n\n### OpenAI Codex\n\nOpenAI Codex CLI and compatible tools support the Agent Skills format by searching specific directories.\n\n#### User-Level Installation\nTo make all skills from this repository available across all your projects:\n\n```bash\n# Create the Codex skills directory\nmkdir -p ~/.codex/skills\n\n# Clone and copy all skills\ngit clone https://github.com/swiftwasm/skills.git /tmp/swiftwasm-skills\nfor skill_path in /tmp/swiftwasm-skills/skills/*; do\n  [ -d \"$skill_path\" ] || continue\n  cp -r \"$skill_path\" ~/.codex/skills/\ndone\n```\n\n#### Project-Level Installation\nTo use skills only within a specific project:\n\n```bash\n# In your project root\nmkdir -p .codex/skills\nfor skill_path in /path/to/swiftwasm-skills/skills/*; do\n  [ -d \"$skill_path\" ] || continue\n  cp -r \"$skill_path\" .codex/skills/\ndone\n```\n\n### Gemini CLI\n\nThis repository includes a `gemini-extension.json` for integration. Install it using the following command:\n\n```bash\ngemini extensions install https://github.com/swiftwasm/skills.git --consent\n```\n\n### Cursor\n\nFor Cursor, please refer to [Installing Skills from GitHub](https://cursor.com/docs/context/skills#installing-skills-from-github).\n\n## Available Skills\n\n| Name | Description | Documentation |\n|------|-------------|---------------|\n| `javascriptkit` | Assist with Swift & JavaScript interop, project initialization, and memory management for WebAssembly. | [SKILL.md](skills/javascriptkit/SKILL.md) |\n| `bridgejs` | Assist with BridgeJS for type-safe Swift-to-JavaScript bindings, exporting Swift APIs, and importing TypeScript definitions. | [SKILL.md](skills/bridgejs/SKILL.md) |\n| `porting` | Check Swift on Wasm compatibility, identify incompatible frameworks, port and refactor code for WebAssembly. | [SKILL.md](skills/porting/SKILL.md) |\n\n## Usage\n\nOnce a skill is installed or loaded, you can trigger its logic by mentioning relevant tasks to your agent. For example, using the `javascriptkit` skill:\n\n- \"Initialize a new JavaScriptKit project named 'MyWebApp' in the current directory.\"\n- \"How do I safely pass a Swift closure to a JavaScript event listener?\"\n- \"Check my environment using the doctor script to ensure I can build for Wasm.\"\n\nThe agent will automatically refer to the appropriate `SKILL.md` file and any associated helper scripts to fulfill your request.\n",
        "skills/bridgejs/SKILL.md": "---\nname: bridgejs\ndescription: Assist Swift developers using BridgeJS for Swift-to-JavaScript interoperability in WebAssembly projects\n---\n\n# Instructions\n\nYou are an expert in Swift and WebAssembly development using BridgeJS from JavaScriptKit. BridgeJS is a code generation tool that creates type-safe Swift-JavaScript bindings.\n\nYour goal is to help users:\n\n1. Export Swift classes, functions, enums, and properties to JavaScript using `@JS` macros\n2. Import TypeScript/JavaScript APIs into Swift via `bridge-js.d.ts` definitions\n3. Design Swift APIs that work well with BridgeJS capabilities\n4. Set up testing infrastructure for BridgeJS projects\n\n## Key Concepts\n\n- **Exporting Swift**: Use `@JS` macro to mark Swift declarations for export to JavaScript\n- **Importing TypeScript**: Define APIs in `bridge-js.d.ts` to generate type-safe Swift bindings\n- **`@JS(namespace:)`**: Organizes exports into JavaScript namespaces\n- **Type-safe bindings**: Generates TypeScript declarations (`.d.ts`) automatically\n- **Build plugin or AOT**: Choose between build-time or ahead-of-time code generation\n\n## Important Limitations\n\n- BridgeJS is experimental - APIs may change\n- Only `throws(JSException)` is supported, not plain `throws`\n- Some Swift types are not supported, always check for given type support first\n- For each supported Swift type there might be some limitation, check for those first\n\n# References\n\n- [Swift API Reference](references/swift_api.md) - Complete API patterns for all supported types\n- [Project Setup](references/project_setup.md) - Swift toolchain and BridgeJS integration\n- [Testing Guide](references/testing.md) - End-to-end testing with Vitest\n",
        "skills/bridgejs/references/project_setup.md": "# BridgeJS Project Setup\n\nComplete guide to setting up a Swift project with BridgeJS for WebAssembly development.\n\n## Prerequisites\n\n- **Swift Toolchain**: Swift 6.1 or later (Swift 6.2+ recommended)\n- **Swift SDK for WebAssembly**: Matching your toolchain version\n- **Node.js**: Required for TypeScript processing and serving\n\n## 1. Install Swift Toolchain\n\nThe recommended way to install Swift is using [`swiftly`](https://www.swift.org/install/):\n\n```bash\n# Install swiftly (follow instructions for your platform)\n# Then install Swift 6.2.3 (or latest)\nswiftly install 6.2.3\nswiftly use 6.2.3\n```\n\n### Verify Installation\n\nEnsure you're using an **OSS Swift toolchain**, not the Xcode-bundled one:\n\n```bash\nwhich swiftc\nswiftc --version\n```\n\nIf `which swiftc` shows `/usr/bin/swiftc` or a path inside `Xcode.app`, you need to install and select an OSS toolchain.\n\n## 2. Install Swift SDK for WebAssembly\n\nFind the matching SDK on the [Swift download page](https://www.swift.org/download/) and install:\n\n```bash\n# Example for Swift 6.2.3\nswift sdk install https://download.swift.org/swift-6.2.3-release/wasm-sdk/swift-6.2.3-RELEASE/swift-6.2.3-RELEASE_wasm.artifactbundle.tar.gz\n```\n\nVerify installation:\n\n```bash\nswift sdk list\n```\n\nNote the **Swift SDK ID** (e.g., `swift-6.2.3-RELEASE_wasm`). Set it as an environment variable:\n\n```bash\nexport SWIFT_SDK_ID=\"swift-6.2.3-RELEASE_wasm\"\n```\n\n## 3. Create a New Swift Package\n\n```bash\nswift package init --name MyApp --type executable\ncd MyApp\n```\n\n## 4. Configure Package.swift\n\n### Option A: Build Plugin (Simplest)\n\nThe build plugin processes `@JS` annotations during each build:\n\n```swift\n// swift-tools-version:6.0\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyApp\",\n    dependencies: [\n        .package(url: \"https://github.com/swiftwasm/JavaScriptKit.git\", from: \"0.22.0\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"MyApp\",\n            dependencies: [\"JavaScriptKit\"],\n            swiftSettings: [\n                // Required for BridgeJS generated code\n                .enableExperimentalFeature(\"Extern\")\n            ],\n            plugins: [\n                // Process @JS annotations and generate bindings\n                .plugin(name: \"BridgeJS\", package: \"JavaScriptKit\")\n            ]\n        )\n    ]\n)\n```\n\n### Option B: Ahead-of-Time Generation (Faster Builds)\n\nFor larger projects, generate code once and commit it:\n\n```swift\n// swift-tools-version:6.0\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyApp\",\n    dependencies: [\n        .package(url: \"https://github.com/swiftwasm/JavaScriptKit.git\", from: \"0.22.0\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"MyApp\",\n            dependencies: [\"JavaScriptKit\"],\n            swiftSettings: [\n                .enableExperimentalFeature(\"Extern\")\n            ]\n            // No BridgeJS plugin - using AOT generation\n        )\n    ]\n)\n```\n\nCreate config file:\n\n```bash\necho \"{}\" > Sources/MyApp/bridge-js.config.json\n```\n\nGenerate code:\n\n```bash\nswift package plugin bridge-js --target MyApp\n```\n\nThis creates `Sources/MyApp/Generated/` with:\n\n- `BridgeJS.swift` - Generated Swift glue code\n- `BridgeJS.Macros.swift` - Macro-annotated declarations for TypeScript imports (if using `bridge-js.d.ts`)\n- `JavaScript/BridgeJS.json` - Unified skeleton for JS runtime\n\nCommit generated files:\n\n```bash\ngit add Sources/MyApp/Generated\ngit commit -m \"Add generated BridgeJS code\"\n```\n\n## 5. Write Swift Code with @JS\n\nCreate `Sources/MyApp/main.swift`:\n\n```swift\nimport JavaScriptKit\n\n@JS class Counter {\n    private var count = 0\n\n    @JS init() {}\n\n    @JS func increment() {\n        count += 1\n    }\n\n    @JS func getValue() -> Int {\n        return count\n    }\n}\n\n@JS func greet(name: String) -> String {\n    return \"Hello, \\(name)!\"\n}\n```\n\n## 6. Build for WebAssembly\n\n```bash\nswift package --swift-sdk $SWIFT_SDK_ID js\n```\n\nThis compiles Swift to WebAssembly and generates JavaScript bindings in:\n\n```\n.build/plugins/PackageToJS/outputs/Package/\n├── index.js          # Entry point\n├── index.d.ts        # TypeScript declarations\n└── MyApp.wasm        # WebAssembly binary\n```\n\n### Build Options\n\n```bash\n# Debug build (default)\nswift package --swift-sdk $SWIFT_SDK_ID js\n\n# Release build\nswift package --swift-sdk $SWIFT_SDK_ID js -c release\n\n# Use CDN for JavaScriptKit runtime\nswift package --swift-sdk $SWIFT_SDK_ID js --use-cdn\n```\n\n## 7. Create HTML Entry Point\n\nCreate `index.html` in project root:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>MyApp</title>\n    <script type=\"module\">\n        import { init } from \"./.build/plugins/PackageToJS/outputs/Package/index.js\";\n\n        const { exports } = await init({});\n\n        // Use your Swift exports\n        console.log(exports.greet(\"World\"));\n\n        const counter = new exports.Counter();\n        counter.increment();\n        console.log(counter.getValue());\n    </script>\n</head>\n<body>\n    <h1>MyApp</h1>\n</body>\n</html>\n```\n\n## 8. Serve and Test\n\n```bash\nnpx serve\n```\n\nOpen `http://localhost:3000` in your browser.\n\n## Project Structure\n\nRecommended structure for a BridgeJS project:\n\n```\nMyApp/\n├── Package.swift\n├── index.html\n├── Sources/\n│   └── MyApp/\n│       ├── main.swift              # Entry point with @JS exports\n│       ├── Models.swift            # @JS classes\n│       ├── Functions.swift         # @JS functions\n│       ├── bridge-js.config.json   # BridgeJS configuration\n│       ├── bridge-js.d.ts          # TypeScript imports (optional)\n│       └── Generated/              # AOT-generated code (if using Option B)\n└── Tests/\n    └── MyAppTests/                 # Swift tests\n```\n\n## Configuration Files\n\n### bridge-js.config.json\n\nPlace in your target directory:\n\n```json\n{\n  \"exposeToGlobal\": false,\n  \"tools\": {\n    \"node\": \"/usr/local/bin/node\"\n  }\n}\n```\n\n### bridge-js.config.local.json\n\nFor local overrides (add to `.gitignore`):\n\n```json\n{\n  \"tools\": {\n    \"node\": \"/opt/homebrew/bin/node\"\n  }\n}\n```\n\n## When to Use Each Approach\n\n**Build Plugin** when:\n\n- Developing small projects or prototypes\n- Frequently changing API boundaries\n- Want simplest setup\n\n**AOT Generation** when:\n\n- Developing larger projects\n- Build time is a concern\n- Want to inspect/version control generated code\n- Working in teams needing consistent builds\n\n## Updating Generated Code (AOT)\n\nWhen you change Swift code or TypeScript definitions:\n\n```bash\nswift package plugin bridge-js\ngit add Sources/MyApp/Generated\ngit commit -m \"Update generated BridgeJS code\"\n```\n\n## Troubleshooting\n\n### \"Extern\" Feature Error\n\nEnsure `Package.swift` includes:\n\n```swift\nswiftSettings: [\n    .enableExperimentalFeature(\"Extern\")\n]\n```\n\n### Node.js Not Found\n\nSet custom path in `bridge-js.config.json`:\n\n```json\n{\n  \"tools\": {\n    \"node\": \"/path/to/node\"\n  }\n}\n```\n\nOr set environment variable:\n\n```bash\nexport JAVASCRIPTKIT_NODE_EXEC=/path/to/node\n```\n\n### Xcode Toolchain Issues\n\nBridgeJS requires an OSS Swift toolchain. In Xcode:\n\n1. Xcode > Toolchains > select your installed OSS toolchain\n2. Or use command line with explicit toolchain path\n",
        "skills/bridgejs/references/swift_api.md": "# BridgeJS Swift API Reference\n\n## Type Mapping\n\n| TypeScript | Swift |\n|:-----------|:------|\n| `number` | `Int`, `Float`, `Double` |\n| `string` | `String` |\n| `boolean` | `Bool` |\n| `T \\| null` | `Optional<T>` |\n| `Promise<T>` | `async` functions |\n| `object` | `JSObject` |\n| `(args) => T` | `@escaping` closures |\n\n## Type Bridging and Performance\n\n| Type | Strategy | Crossing Cost | Best For |\n|:-----|:---------|:--------------|:---------|\n| Classes | Reference (pointer) | Low | Stateful objects, frequent method calls |\n| Structs | Copy (serialize) | Medium | Small immutable data, infrequent passing |\n| Enums (simple) | Copy (integer/string) | Very low | Flags, options |\n| Enums (associated) | Copy (serialize payload) | Medium | Result types, variants |\n| Closures | Boxed/retained | Medium | Callbacks, transforms |\n| Primitives | Direct | Very low | Frequent access |\n| Strings | Copy (UTF-8) | Medium | Text data |\n\n**Classes** use `FinalizationRegistry` for automatic cleanup when JS garbage collects. Call `release()` for deterministic cleanup in performance-critical code.\n\n**Structs/Enums** are value types - data is copied across the boundary. No shared state between Swift and JS.\n\n**Tip:** Prefer classes for objects with many method calls. Use structs for data transfer objects passed once.\n\n---\n\n## Functions\n\n```swift\nimport JavaScriptKit\n\n@JS func calculateTotal(price: Double, quantity: Int) -> Double {\n    return price * Double(quantity)\n}\n\n@JS func findUser(id: Int) throws(JSException) -> String {\n    guard id > 0 else {\n        throw JSException(JSError(message: \"Invalid ID\").jsValue)\n    }\n    return \"User_\\(id)\"\n}\n\n@JS func fetchData(endpoint: String) async -> String {\n    try? await Task.sleep(nanoseconds: 50_000_000)\n    return \"Data from \\(endpoint)\"\n}\n\n@JS func greet(name: String, greeting: String = \"Hello\") -> String {\n    return \"\\(greeting), \\(name)!\"\n}\n```\n\n**JavaScript:**\n\n```javascript\nconst total = exports.calculateTotal(19.99, 3);\n\ntry {\n    const user = exports.findUser(42);\n} catch (e) {\n    console.error(e);\n}\n\nconst data = await exports.fetchData(\"/api\");\n\nexports.greet(\"World\");         // \"Hello, World!\"\nexports.greet(\"World\", \"Hi\");   // \"Hi, World!\"\n```\n\n| Feature | Status |\n|:--------|:-------|\n| Primitives, String params/returns | Supported |\n| `@JS class`, `@JS enum` params/returns | Supported |\n| `throws(JSException)` | Supported |\n| `throws` (any error) | Not supported |\n| `async` | Supported |\n| Default parameter values | Supported |\n| Generics, opaque types | Not supported |\n\n---\n\n## Classes\n\n```swift\n@JS class Counter {\n    @JS var count = 0\n    @JS var doubled: Int { count * 2 }\n\n    @JS init() {}\n\n    @JS init(start: Int) throws(JSException) {\n        guard start >= 0 else {\n            throw JSException(JSError(message: \"Start must be positive\").jsValue)\n        }\n        self.count = start\n    }\n\n    @JS func increment() { count += 1 }\n    @JS func add(_ amount: Int) { count += amount }\n\n    @JS static var instanceCount = 0\n    @JS static func resetAll() { instanceCount = 0 }\n}\n```\n\n**JavaScript:**\n\n```javascript\nconst counter = new exports.Counter();\ncounter.increment();\nconsole.log(counter.count);     // 1\nconsole.log(counter.doubled);   // 2\ncounter.release();  // explicit cleanup (optional but recommended)\n\n// Static members\nconsole.log(exports.Counter.instanceCount);\nexports.Counter.resetAll();\n\n// Throwing initializer\ntry {\n    const c = new exports.Counter(-1);\n} catch (e) {\n    console.error(e);  // \"Start must be positive\"\n}\n```\n\n**Generated TypeScript:**\n\n```typescript\nexport interface SwiftHeapObject {\n    release(): void;\n}\n\nexport interface Counter extends SwiftHeapObject {\n    count: number;\n    readonly doubled: number;\n    increment(): void;\n    add(amount: number): void;\n}\n\nexport type Exports = {\n    Counter: {\n        new(): Counter;\n        new(start: number): Counter;\n        instanceCount: number;\n        resetAll(): void;\n    };\n}\n```\n\n| Feature | Status |\n|:--------|:-------|\n| `init()` | Supported |\n| `init() throws(JSException)` | Supported |\n| `init() throws` (any error) | Not supported |\n| `init() async` | Not supported |\n| Stored properties (`var`, `let`) | Supported |\n| Computed properties | Supported |\n| Instance methods | Supported |\n| Static properties/methods | Supported |\n| `deinit` | Supported |\n| Subscripts | Not supported |\n| Generics | Not supported |\n\n---\n\n## Structs\n\nStructs are value types - data is copied across the Swift-JS boundary (no shared state).\n\n```swift\n@JS struct Point {\n    @JS var x: Double\n    @JS var y: Double\n    @JS var label: String?\n\n    @JS init(x: Double, y: Double, label: String? = nil) {\n        self.x = x\n        self.y = y\n        self.label = label\n    }\n}\n\n@JS func movePoint(_ point: Point, dx: Double, dy: Double) -> Point {\n    return Point(x: point.x + dx, y: point.y + dy, label: point.label)\n}\n\n@JS struct AppConfig {\n    @JS static let version = \"1.0.0\"\n    @JS static var debugMode = false\n    @JS static func reset() { debugMode = false }\n}\n```\n\n**JavaScript:**\n\n```javascript\n// Structs are created via init function, returned as plain JS objects\nconst point = exports.Point.init(10.0, 20.0, \"origin\");\nconsole.log(point.x, point.y);  // 10.0, 20.0\n\n// Passing to Swift copies the data\nconst moved = exports.movePoint(point, 5.0, 5.0);\nconsole.log(moved.x, moved.y);  // 15.0, 25.0\n\n// Static members\nconsole.log(exports.AppConfig.version);  // \"1.0.0\"\nexports.AppConfig.debugMode = true;\nexports.AppConfig.reset();\n```\n\n| Feature | Status |\n|:--------|:-------|\n| Stored properties | Supported |\n| Optional properties | Supported |\n| Nested structs | Supported |\n| Class properties in structs | Supported |\n| Static properties/methods | Supported |\n| Instance methods | Not supported |\n| Computed properties | Not supported |\n| Generics | Not supported |\n\n---\n\n## Enums\n\n### Simple Case Enums\n\n```swift\n@JS enum Direction {\n    case north, south, east, west\n}\n\n@JS func setDirection(_ direction: Direction) { /* ... */ }\n@JS func getDirection() -> Direction { /* ... */ }\n```\n\n**JavaScript:**\n\n```javascript\nexports.setDirection(exports.Direction.North);  // passes integer 0\nconst dir = exports.getDirection();\nif (dir === exports.Direction.North) { /* ... */ }\n```\n\n### Raw Value Enums\n\n```swift\n@JS enum Theme: String {\n    case light = \"light\"\n    case dark = \"dark\"\n    case system = \"system\"\n}\n\n@JS enum HttpStatus: Int {\n    case ok = 200\n    case notFound = 404\n    case serverError = 500\n}\n```\n\n**JavaScript:**\n\n```javascript\nexports.setTheme(exports.Theme.Dark);      // passes \"dark\"\nexports.setStatus(exports.HttpStatus.Ok);  // passes 200\n```\n\n### Associated Value Enums\n\n```swift\n@JS enum APIResult {\n    case success(String)\n    case failure(Int)\n    case loading\n}\n\n@JS func handleResult(_ result: APIResult) { /* ... */ }\n@JS func getResult() -> APIResult { /* ... */ }\n```\n\n**JavaScript:**\n\n```javascript\n// Create with associated values\nconst success = { tag: exports.APIResult.Tag.Success, param0: \"Data loaded\" };\nconst failure = { tag: exports.APIResult.Tag.Failure, param0: 404 };\nconst loading = { tag: exports.APIResult.Tag.Loading };\n\nexports.handleResult(success);\n\n// Pattern match on result\nconst result = exports.getResult();\nswitch (result.tag) {\n    case exports.APIResult.Tag.Success:\n        console.log(\"Data:\", result.param0);\n        break;\n    case exports.APIResult.Tag.Failure:\n        console.log(\"Error code:\", result.param0);\n        break;\n    case exports.APIResult.Tag.Loading:\n        console.log(\"Loading...\");\n        break;\n}\n```\n\n| Associated Value Type | Status |\n|:----------------------|:-------|\n| `String`, `Int`, `Bool`, `Float`, `Double` | Supported |\n| Classes, structs | Not supported |\n| Other enums | Not supported |\n| Arrays/Collections | Not supported |\n| Optionals | Not supported |\n\n---\n\n## Closures\n\nClosures can be passed in both directions between Swift and JavaScript.\n\n```swift\n@JS class DataProcessor {\n    @JS init() {}\n\n    // Accept JS callback\n    @JS func process(items: String, transform: @escaping (String) -> String) -> String {\n        return transform(items)\n    }\n\n    // Accept callback with enum parameter\n    @JS func filterDirections(callback: @escaping (Direction) -> Bool) {\n        let directions: [Direction] = [.north, .south, .east, .west]\n        for dir in directions {\n            if callback(dir) { print(\"Accepted: \\(dir)\") }\n        }\n    }\n\n    // Return Swift closure to JS\n    @JS func makeMultiplier(factor: Int) -> (Int) -> Int {\n        return { value in value * factor }\n    }\n\n    // Return closure with optional parameter\n    @JS func makeFormatter() -> (String?) -> String {\n        return { input in input ?? \"N/A\" }\n    }\n}\n```\n\n**JavaScript:**\n\n```javascript\nconst processor = new exports.DataProcessor();\n\n// Pass JS function to Swift\nconst result = processor.process(\"hello\", (s) => s.toUpperCase());\nconsole.log(result);  // \"HELLO\"\n\n// Callback with enum\nprocessor.filterDirections((dir) => dir === exports.Direction.North);\n\n// Get Swift closure\nconst triple = processor.makeMultiplier(3);\nconsole.log(triple(5));  // 15\n\nconst format = processor.makeFormatter();\nconsole.log(format(null));    // \"N/A\"\nconsole.log(format(\"test\"));  // \"test\"\n```\n\n| Feature | Status |\n|:--------|:-------|\n| `(T) -> U` | Supported |\n| `(T, U) -> V` (multiple params) | Supported |\n| `(T?) -> U` (optional params) | Supported |\n| `(T) -> U?` (optional return) | Supported |\n| Enum parameters | Supported |\n| Class parameters | Supported |\n| `@escaping` | Required |\n| `async` closures | Not supported |\n| `throws` closures | Not supported |\n\n---\n\n## Protocols\n\nProtocols enable duck-typed interoperability - JavaScript objects can implement Swift protocol requirements.\n\n```swift\n@JS protocol DataDelegate {\n    var processedCount: Int { get set }\n    var delegateName: String { get }\n\n    func onDataReceived(_ data: String)\n    func shouldProcess(_ item: Int) -> Bool\n}\n\n@JS class DataManager {\n    private var delegate: DataDelegate\n\n    @JS init(delegate: DataDelegate) {\n        self.delegate = delegate\n    }\n\n    @JS func processItem(_ item: Int) {\n        if delegate.shouldProcess(item) {\n            delegate.processedCount += 1\n            delegate.onDataReceived(\"Processed: \\(item)\")\n        }\n    }\n}\n```\n\n**JavaScript:**\n\n```javascript\n// JS object implementing the protocol\nconst myDelegate = {\n    processedCount: 0,\n    delegateName: \"MyDelegate\",\n\n    onDataReceived(data) {\n        console.log(\"Received:\", data);\n    },\n    shouldProcess(item) {\n        return item > 0;\n    }\n};\n\nconst manager = new exports.DataManager(myDelegate);\nmanager.processItem(42);\nconsole.log(myDelegate.processedCount);  // 1\n```\n\n| Feature | Status |\n|:--------|:-------|\n| Properties (`get`, `get set`) | Supported |\n| Optional properties | Supported |\n| Methods | Supported |\n| Methods with return values | Supported |\n| Enum parameters/returns | Supported |\n| Class parameters/returns | Supported |\n| Associated types | Not supported |\n| Protocol inheritance | Not supported |\n\n---\n\n## Namespaces\n\n### Using `@JS(namespace:)`\n\n```swift\n@JS(namespace: \"MyApp.Utils\")\nfunc formatDate(timestamp: Double) -> String { /* ... */ }\n\n@JS(namespace: \"MyApp.Models\")\nclass User {\n    @JS var name: String\n    @JS init(name: String) { self.name = name }\n}\n```\n\n**JavaScript:**\n\n```javascript\nexports.MyApp.Utils.formatDate(Date.now());\nconst user = new exports.MyApp.Models.User(\"Alice\");\n```\n\n### Using Empty Enums\n\n```swift\n@JS enum MyApp {\n    @JS enum Models {\n        @JS class User {\n            @JS var name: String\n            @JS init(name: String) { self.name = name }\n        }\n    }\n}\n```\n\n**JavaScript:**\n\n```javascript\nconst user = new exports.MyApp.Models.User(\"Alice\");\n```\n\n**Note:** Only empty enums (no cases) work as namespaces. Nested items cannot use `@JS(namespace:)`.\n\n---\n\n## Importing TypeScript into Swift\n\nCreate `bridge-js.d.ts` in your target source directory:\n\n```typescript\nexport function consoleLog(message: string): void;\n\ninterface Document {\n    title: string;\n    readonly body: HTMLElement;\n    getElementById(id: string): HTMLElement;\n    createElement(tagName: string): HTMLElement;\n}\n\ninterface HTMLElement {\n    innerText: string;\n    appendChild(child: HTMLElement): void;\n}\n\nexport function getDocument(): Document;\n```\n\n**Generated Swift** (all imported functions/methods throw `JSException`):\n\n```swift\nfunc consoleLog(_ message: String) throws(JSException)\n\nstruct Document {\n    var title: String { get throws(JSException) }\n    func setTitle(_ value: String) throws(JSException)\n    var body: HTMLElement { get throws(JSException) }\n    func getElementById(_ id: String) throws(JSException) -> HTMLElement\n    func createElement(_ tagName: String) throws(JSException) -> HTMLElement\n}\n\nstruct HTMLElement {\n    var innerText: String { get throws(JSException) }\n    func setInnerText(_ value: String) throws(JSException)\n    func appendChild(_ child: HTMLElement) throws(JSException)\n}\n\nfunc getDocument() throws(JSException) -> Document\n```\n\n**Usage in Swift:**\n\n```swift\n@JS func setupUI() throws(JSException) {\n    try consoleLog(\"Setting up UI\")\n\n    let doc = try getDocument()\n    try doc.setTitle(\"My App\")\n\n    let button = try doc.createElement(\"button\")\n    try button.setInnerText(\"Click Me\")\n\n    let container = try doc.getElementById(\"app\")\n    try container.appendChild(button)\n}\n```\n\n**Inject JS implementations:**\n\n```javascript\nconst { exports } = await init({\n    getImports: () => ({\n        consoleLog: (msg) => console.log(msg),\n        getDocument: () => document,\n    })\n});\n\nexports.setupUI();\n```\n\n---\n\n## Configuration\n\nCreate `bridge-js.config.json` in your target directory:\n\n```json\n{\n    \"exposeToGlobal\": false,\n    \"tools\": {\n        \"node\": \"/usr/local/bin/node\"\n    }\n}\n```\n\n- **`exposeToGlobal`**: When `true`, exports available on `globalThis`. Default: `false`.\n- **`tools.node`**: Custom path to Node.js executable.\n\nCreate `bridge-js.config.local.json` for local overrides (add to `.gitignore`).\n",
        "skills/bridgejs/references/testing.md": "# Testing BridgeJS Projects\n\nGuide to testing BridgeJS projects using Vitest.\n\n## Setup\n\n```bash\nmkdir -p tests && cd tests\nnpm init -y\nnpm install -D vitest typescript\n```\n\n**vitest.config.ts**:\n\n```typescript\nimport { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n    test: {\n        globals: true,\n        environment: \"node\",\n        include: [\"**/*.test.ts\"],\n    },\n});\n```\n\n**setup.ts**:\n\n```typescript\nimport { instantiate } from \"../.build/plugins/PackageToJS/outputs/Package/instantiate.js\";\nimport { defaultNodeSetup } from \"../.build/plugins/PackageToJS/outputs/Package/platforms/node.js\";\n\nexport async function load() {\n    const options = await defaultNodeSetup();\n    return await instantiate({ ...options, getImports: () => ({}) });\n}\n```\n\n## Example Test\n\n```typescript\nimport { describe, expect, test } from \"vitest\";\nimport { load } from \"./setup\";\n\ndescribe(\"MyApp\", async () => {\n    const { exports } = await load();\n\n    test(\"greeter works\", () => {\n        const greeter = new exports.Greeter(\"World\");\n        expect(greeter.greet()).toBe(\"Hello, World!\");\n        greeter.name = \"Swift\";\n        expect(greeter.greet()).toBe(\"Hello, Swift!\");\n        greeter.release();\n    });\n\n    test(\"enums work\", () => {\n        expect(exports.Direction.North).toBe(0);\n        exports.setDirection(exports.Direction.South);\n    });\n\n    test(\"optionals work\", () => {\n        expect(exports.roundTripOptionalString(null)).toBeNull();\n        expect(exports.roundTripOptionalString(\"test\")).toBe(\"test\");\n    });\n\n    test(\"structs are copied\", () => {\n        const point = exports.Point.init(1.0, 2.0, null);\n        expect(point.x).toBe(1.0);\n        expect(point.y).toBe(2.0);\n    });\n});\n```\n\n## Running Tests\n\n```bash\n# Build Swift first\nswift package --swift-sdk $SWIFT_SDK_ID js\n\n# Run tests\nnpx vitest run\n```\n\n",
        "skills/javascriptkit/SKILL.md": "---\nname: javascriptkit\ndescription: Assist Swift developers who consume JavaScriptKit for WebAssembly development\n---\n\n# Instructions\n\nYou are an expert in Swift and WebAssembly development using JavaScriptKit. Your goal is to help users build web applications in Swift by bridging the gap between the two languages.\n\n# References\n\n- [Initializing a New Project](references/init_new_project.md)\n- [JavaScript Interop Cheat Sheet](references/swift_apis.md)\n- [Common Patterns and Best Practices](references/common_patterns.md)\n\n# Scripts\n\n- `scripts/doctor.py`: Check the environment for Swift and Wasm SDK.\n- `scripts/install-sdk.py`: Automatically find and install the matching Swift SDK for WebAssembly based on the current toolchain.\n",
        "skills/javascriptkit/references/common_patterns.md": "# Common Patterns and Best Practices\n\nPractical patterns and common pitfalls when building applications with JavaScriptKit.\n\n## Architectural Approaches\n\nThere are two primary ways to architect a WebAssembly application with JavaScriptKit, depending on how much of the web ecosystem you want to leverage.\n\n### 1. Pure Swift (Full-Stack Swift)\n\nIn this approach, Swift handles everything: DOM manipulation, state management, and application logic.\n\n- **How it works**: Swift uses JavaScriptKit to call DOM APIs directly (e.g., `document.createElement`, `addEventListener`).\n- **Declarative Alternative**: Instead of raw DOM manipulation, you can use declarative UI libraries like [Elementary](https://elementary.codes/), which provides a more Swift-native way to build HTML components.\n- **Best for**: Small to medium applications, developers who prefer staying entirely within Swift, or when porting existing Swift logic that heavily controls its own UI.\n- **Data Flow**: Swift → JavaScript (DOM APIs).\n\n### 2. Core Logic in Swift (Hybrid Approach)\n\nIn this approach, modern web frameworks (like React, Vue, or Svelte) handle the UI and state management, while Swift provides the heavy-duty business logic.\n\n- **How it works**: Swift exposes specific functions or objects to the JavaScript `global` object. The JavaScript UI then calls into these Swift APIs.\n- **Best for**: Applications requiring complex UIs, leveraging existing web components/libraries, or when Swift is only needed for specialized tasks (e.g., data processing, cryptography, shared logic with a mobile app).\n- **Data Flow**: JavaScript (UI) → Swift (Core Logic).\n\n#### Example: Exposing Swift API to JavaScript\n\n```swift\n// Swift side\nlet api = JSObject()\napi.processData = JSClosure { args in\n    let input = args[0].string ?? \"\"\n    let result = HeavyLogic.process(input)\n    return .string(result)\n}\nJSObject.global.mySwiftApp = .object(api)\n```\n\n```javascript\n// JavaScript side (e.g., in a React component)\nconst result = window.mySwiftApp.processData(\"input data\");\n```\n\n## Memory Management and Closures\n\nJavaScript does not participate in Swift's Automatic Reference Counting (ARC). You must manually manage the lifetime of Swift objects and closures that are exposed to JavaScript.\n\n### Retaining Closures\n\n`JSClosure` instances must be retained by the Swift side as long as they are expected to be called by JavaScript. If a `JSClosure` is deallocated, any attempt by JavaScript to call it will result in a crash.\n\nWhen using `[weak self]` in a closure, ensure the capturing object is also retained.\n\n```swift\nclass UIManager {\n    private var clickHandler: JSClosure?\n    private let button: JSObject\n\n    init(button: JSObject) {\n        self.button = button\n        \n        // clickHandler must be stored as a property to be retained\n        self.clickHandler = JSClosure { [weak self] _ in\n            self?.handleClick()\n            return .undefined\n        }\n        _ = button.addEventListener!(\"click\", clickHandler!)\n    }\n\n    func handleClick() {\n        // ...\n    }\n}\n```\n\n### Cleanup in `deinit`\n\nWhen an object owning an event listener is deallocated, it is recommended to remove the event listener from the DOM to avoid memory leaks or attempts to call deallocated closures.\n\n```swift\nclass UIManager {\n    private var clickHandler: JSClosure?\n    private let button: JSObject\n\n    // ... init ...\n\n    deinit {\n        if let handler = clickHandler {\n            _ = button.removeEventListener!(\"click\", handler)\n        }\n    }\n}\n```\n\n### Application Lifetime Objects\n\nFor root-level UI managers or state containers that should live for the duration of the application, store them in a static property in your `@main` entry point.\n\n```swift\n@main\nstruct MyApp {\n    static nonisolated(unsafe) var ui: UIManager!\n\n    static func main() {\n        let ui = UIManager()\n        ui.setup()\n        Self.ui = ui // Retain for application lifetime\n    }\n}\n```\n\n## Event Handling Recipes\n\n### Input Handling (Enter Key)\n\n```swift\nlet input = document.getElementById!(\"text-input\").object!\nlet closure = JSClosure { [weak self] args in\n    guard let event = args.first?.object,\n          event.key.string == \"Enter\" else { return .undefined }\n    \n    self?.handleSubmit()\n    return .undefined\n}\n_ = input.addEventListener!(\"keydown\", closure)\n```\n\n### Checkbox/Toggle\n\n```swift\nlet checkbox = document.getElementById!(\"toggle\").object!\nlet closure = JSClosure { [weak self] _ in\n    let isChecked = checkbox.checked.boolean ?? false\n    self?.updateToggleState(isChecked)\n    return .undefined\n}\n_ = checkbox.addEventListener!(\"change\", closure)\n```\n\n## Common Gotchas\n\n### Property Assignment\n\nValues must be converted to `JSValue` using `.jsValue` or explicit wrappers like `.string()`.\n\n```swift\nlet text = \"Hello\"\n// Correct\nelement.textContent = .string(text)\nelement.textContent = text.jsValue\n\n// Incorrect\nelement.textContent = text\n```\n\n### Method Calls vs. Properties\n\nEnsure you use `!` only for method calls that return an optional closure via Dynamic Member Lookup.\n\n```swift\n// Method call (requires !)\n_ = document.createElement!(\"div\")\n\n// Property access (no !)\nlet body = document.body.object!\n```\n\n### Discarding Results\n\nMany JavaScript methods return a value that Swift requires you to handle. Use `_ =` to silence warnings.\n\n```swift\n_ = document.body.object!.appendChild!(element)\n```\n",
        "skills/javascriptkit/references/init_new_project.md": "# Initializing a New JavaScriptKit Project\n\nThis guide walks you through setting up a new Swift project that uses JavaScriptKit to interact with JavaScript APIs from WebAssembly.\n\n## Prerequisites\n\nBefore you begin, ensure you have the following installed:\n\n- **Swift Toolchain**: Swift 6.0 or later (with WebAssembly support). Swift 6.2 or later is recommended for the best experience.\n- **Swift SDK for WebAssembly**: Matching your Swift toolchain version.\n- **Node.js and npm**: Required for serving the application and managing JavaScript bindings.\n\n### 1. Install Swift Toolchain and SDK\n\nThe recommended way to install and manage Swift toolchains is using [`swiftly`](https://www.swift.org/install/).\n\n1.  **Install `swiftly`**: Follow the instructions on swift.org for your platform.\n2.  **Install a supported toolchain** (e.g., Swift 6.2.3):\n    ```bash\n    swiftly install 6.2.3\n    swiftly use 6.2.3\n    ```\n3.  **Install the Swift SDK for WebAssembly**:\n    The easiest way is to use the supplemental script provided with this skill:\n    ```bash\n    ./scripts/install-sdk.py\n    ```\n    This script automatically detects your toolchain version and fetches the matching SDK. Alternatively, you can manually find the latest SDK artifact bundle URL on the [swift.org download page](https://www.swift.org/download/) and run:\n    ```bash\n    # Example for Swift 6.2.3\n    swift sdk install https://download.swift.org/swift-6.2.3-release/wasm-sdk/swift-6.2.3-RELEASE/swift-6.2.3-RELEASE_wasm.artifactbundle.tar.gz\n    ```\n4.  **Verify installation**:\n    ```bash\n    swift sdk list\n    ```\n    Note the **Swift SDK ID** from the output (e.g., `swift-6.2.3-RELEASE_wasm`). You will need this for building.\n\n### 2. Verify Your Environment\n\nIt is crucial to use an **OSS Swift toolchain** rather than the one bundled with Xcode.\n\n> **Note**: AI should run the following commands to verify the environment. If `which swiftc` points to `/usr/bin/swiftc` (the Xcode stub) or a path inside `Xcode.app`, inform the user that they must install and select an OSS toolchain.\n\n```bash\nwhich swiftc\nswiftc --version\n```\n\nSet the `SWIFT_SDK_ID` environment variable to your installed Swift SDK ID (e.g., `swift-6.2.3-RELEASE_wasm`).\n\n```bash\nexport SWIFT_SDK_ID=\"your-sdk-id-here\"\n```\n\n## 1. Create a New Swift Package\n\nStart by creating a new Swift executable package.\n\n> **Note**: Ask the user for their preferred project name before running these commands.\n\n```bash\n# Replace <PROJECT_NAME> with the project name provided by the user\nswift package init --name <PROJECT_NAME> --type executable\n```\n\n## 2. Add JavaScriptKit Dependency\n\nAdd JavaScriptKit as a dependency to your `Package.swift` file. You can do this using the `swift package` command.\n\n> **Note**: Always check for the latest release version of JavaScriptKit on GitHub (https://github.com/swiftwasm/JavaScriptKit/releases) and use it in the command below.\n\n```bash\n# Replace <LATEST_VERSION> with the actual latest version (e.g., 0.36.0)\nswift package add-dependency https://github.com/swiftwasm/JavaScriptKit.git --from <LATEST_VERSION>\n```\n\nThen, add `JavaScriptKit` as a target dependency for your executable:\n\n```bash\n# Replace <PROJECT_NAME> with the project name provided by the user\nswift package add-target-dependency --package JavaScriptKit JavaScriptKit <PROJECT_NAME>\n```\n\n## 3. Write Your Swift Code\n\nReplace the contents of `Sources/main.swift` with the following code to manipulate the DOM:\n\n```swift\nimport JavaScriptKit\n\nlet document = JSObject.global.document\nlet div = document.createElement(\"div\")\ndiv.innerText = \"Hello from Swift!\"\n_ = document.body.appendChild(div)\n```\n\n## 4. Create an HTML Entry Point\n\nCreate an `index.html` file in the root directory of your project:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>PROJECT_NAME</title>\n    <script type=\"module\">\n        import { init } from \"./.build/plugins/PackageToJS/outputs/Package/index.js\";\n        init();\n    </script>\n</head>\n<body>\n    <h1><PROJECT_NAME></h1>\n</body>\n</html>\n```\n\n## 5. Build and Run\n\nBuild your application for WebAssembly:\n\n```bash\nswift package --swift-sdk $SWIFT_SDK_ID js --use-cdn\n```\n\nThis command compiles your Swift code to WebAssembly and uses the `PackageToJS` plugin to generate the necessary JavaScript bindings.\n\nStart a local web server to view your application:\n\n```bash\nnpx serve\n```\n\nOpen your browser and navigate to the address provided by `serve` (usually `http://localhost:3000`). You should see your project title and \"Hello from Swift!\" on the page.\n\n",
        "skills/javascriptkit/references/swift_apis.md": "# JavaScript Interop Cheat Sheet\n\nPractical recipes for manipulating JavaScript values from Swift with JavaScriptKit. Each section shows the shortest path to access, call, or convert the APIs you interact with the most.\n\n## Access JavaScript Values\n\n### Global entry points\n\n```swift\nlet global: JSObject = JSObject.global\nlet document: JSObject = global.document.object!\nlet math: JSObject = global.Math.object!\n```\n\n- Use ``JSObject/global`` for `globalThis` and drill into properties.\n- Accessing through [dynamic member lookup](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0195-dynamic-member-lookup.md) returns ``JSValue``; call `.object`, `.number`, `.string`, etc. to unwrap a concrete type (callable values are represented as ``JSObject`` as well).\n- Prefer storing ``JSObject`` references (`document` above) when you call multiple members to avoid repeated conversions (for performance).\n\n### Properties, subscripts, and symbols\n\n```swift\nextension JSObject {\n    public subscript(_ name: String) -> JSValue { get set }\n    public subscript(_ index: Int) -> JSValue { get set }\n    public subscript(_ name: JSSymbol) -> JSValue { get set }\n    /// Use this API when you want to avoid repeated String serialization overhead\n    public subscript(_ name: JSString) -> JSValue { get set }\n    /// A convenience method of `subscript(_ name: String) -> JSValue`\n    /// to access the member through Dynamic Member Lookup.\n    /// ```swift\n    /// let document: JSObject = JSObject.global.document.object!\n    /// ```\n    public subscript(dynamicMember name: String) -> JSValue { get set }\n}\nextension JSValue {\n    /// An unsafe convenience method of `JSObject.subscript(_ index: Int) -> JSValue`\n    /// - Precondition: `self` must be a JavaScript Object.\n    public subscript(dynamicMember name: String) -> JSValue\n    public subscript(_ index: Int) -> JSValue\n}\n```\n\n**Example**\n\n```swift\ndocument.title = .string(\"Swift <3 Web\")\nlet obj = JSObject.global.myObject.object!\nlet value = obj[\"key\"].string  // Access object property with String\nlet propName = JSString(\"key\")\nlet value2 = obj[propName].string  // Access object property with JSString\n\nlet array = JSObject.global.Array.object!.new(1, 2, 3)\narray[0] = .number(10)  // Assign to array index\n\nlet symbol = JSSymbol(\"secret\")\nlet data = obj[symbol].object\n```\n\n## Call Functions and Methods\n\n```swift\nextension JSObject {\n    /// Call this function with given `arguments` using [Callable values of user-defined nominal types](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0253-callable.md)\n    /// ```swift\n    /// let alert = JSObject.global.alert.object!\n    /// alert(\"Hello from Swift\")\n    /// ```\n    public func callAsFunction(_ arguments: ConvertibleToJSValue...) -> JSValue\n    public func callAsFunction(this: JSObject, _ arguments: ConvertibleToJSValue...) -> JSValue\n\n    /// Returns the `name` member method binding this object as `this` context.\n    public subscript(_ name: String) -> ((ConvertibleToJSValue...) -> JSValue)? { get }\n    public subscript(_ name: JSString) -> ((ConvertibleToJSValue...) -> JSValue)? { get }\n    /// A convenience method of `subscript(_ name: String) -> ((ConvertibleToJSValue...) -> JSValue)?` to access the member through Dynamic Member Lookup.\n    /// ```swift\n    /// let document = JSObject.global.document.object!\n    /// let divElement = document.createElement!(\"div\")\n    /// ```\n    public subscript(dynamicMember name: String) -> ((ConvertibleToJSValue...) -> JSValue)? { get }\n}\nextension JSValue {\n    /// An unsafe convenience method of `JSObject.subscript(_ name: String) -> ((ConvertibleToJSValue...) -> JSValue)?`\n    /// - Precondition: `self` must be a JavaScript Object and specified member should be a callable object.\n    public subscript(dynamicMember name: String) -> ((ConvertibleToJSValue...) -> JSValue)\n}\n```\n\n**Example**\n\n```swift\nlet alert = JSObject.global.alert.object!\nalert(\"Hello from Swift\")\n\nlet console = JSObject.global.console.object!\n_ = console.log!(\"Cheat sheet ready\", 1, true)\n\nlet document = JSObject.global.document.object!\nlet button = document.createElement!(\"button\").object!\n_ = button.classList.add(\"primary\")\n```\n\n- **Dynamic Member Lookup and `!`**: When calling a method on ``JSObject`` (like `createElement!`), it returns an optional closure, so `!` is used to unwrap and call it. In contrast, calling on ``JSValue`` (like `button.classList.add`) returns a non-optional closure that traps on failure for convenience.\n\nNeed to bind manually? Grab the function object and supply `this`:\n\n```swift\nlet appendChild = document.body.appendChild.object!\nappendChild(this: document.body.object!, document.createElement!(\"div\"))\n```\n\n### Passing options objects\n\nWhen JavaScript APIs require an options object, create one using ``JSObject``:\n\n```swift\npublic class JSObject: ExpressibleByDictionaryLiteral {\n    /// Creates an empty JavaScript object (equivalent to {} or new Object())\n    public init()\n    \n    /// Creates a new object with the key-value pairs in the dictionary literal\n    public init(dictionaryLiteral elements: (String, JSValue)...)\n}\n```\n\n**Example**\n\n```swift\n// Create options object with dictionary literal\nlet listeningOptions: JSObject = [\"once\": .boolean(true), \"passive\": .boolean(true)]\nbutton.addEventListener!(\"click\", handler, listeningOptions)\n\n// Create empty object and add properties\nlet fetchOptions = JSObject()\nfetchOptions[\"method\"] = .string(\"POST\")\nlet headers: JSObject = [\"Content-Type\": .string(\"application/json\")]\nfetchOptions[\"headers\"] = headers.jsValue\nfetchOptions[\"body\"] = \"{}\".jsValue\n\nlet fetch = JSObject.global.fetch.object!\nlet response = fetch(\"https://api.example.com\", fetchOptions)\n```\n\n### Throwing JavaScript\n\nJavaScript exceptions surface as ``JSException``. Wrap the function (or object) in a throwing helper.\n\n```swift\n// Method\nlet JSON = JSObject.global.JSON.object!\ndo {\n    let value = try JSON.throwing.parse!(\"{\\\"flag\\\":true}\")\n} catch let error as JSException {\n    print(\"Invalid JSON\", error)\n}\n\n// Function\nlet validateAge: JSObject = JSObject.global.validateAge.object!\ndo {\n    try validateAge.throws(-3)\n} catch let error as JSException {\n    print(\"Validation failed:\", error)\n}\n```\n\n- Use ``JSObject/throwing`` to access object methods that may throw JavaScript exceptions.\n- Use ``JSObject/throws`` to call the callable object itself that may throw JavaScript exceptions.\n\n### Constructors and `new`\n\n```swift\nlet url = JSObject.global.URL.object!.new(\"https://example.com\", \"https://example.com\")\nlet searchParams = url.searchParams.object!\n```\n\nUse ``JSThrowingFunction/new(_:)`` (via `throws.new`) when the constructor can throw.\n\n## Convert Between Swift and JavaScript\n\n### Swift -> JavaScript\n\nTypes conforming to ``ConvertibleToJSValue`` can be converted via the `.jsValue` property. Conversion behavior depends on the context:\n\n| Swift type | JavaScript result | Notes |\n|------------|------------------|-------|\n| `Bool` | `JSValue.boolean(Bool)` | |\n| `String` | `JSValue.string(JSString)` | Wrapped in ``JSString`` to avoid extra copies |\n| `Int`, `UInt`, `Int8-32`, `UInt8-32`, `Float`, `Double` | `JSValue.number(Double)` | All numeric types convert to `Double` |\n| `Int64`, `UInt64` | `JSValue.bigInt(JSBigInt)` | Converted to `BigInt` (requires `import JavaScriptBigIntSupport`) |\n| `Data` | `Uint8Array` | Converted to `Uint8Array` (requires `import JavaScriptFoundationCompat`) |\n| `Array<Element>` where `Element: ConvertibleToJSValue` | JavaScript Array | Each element converted via `.jsValue` |\n| `Dictionary<String, Value>` where `Value: ConvertibleToJSValue` | Plain JavaScript object | Keys must be `String` |\n| `Optional.none` | `JSValue.null` | Use ``JSValue/undefined`` when you specifically need `undefined` |\n| `Optional.some(wrapped)` | `wrapped.jsValue` | |\n| ``JSValue``, ``JSObject``, ``JSString`` | Passed through | No conversion needed |\n\n**Function arguments**: Automatic conversion when passing to JavaScript functions:\n\n```swift\nlet alert = JSObject.global.alert.object!\nalert(\"Hello\")  // String automatically converts via .jsValue\n\nlet console = JSObject.global.console.object!\nconsole.log!(\"Count\", 42, true)  // All arguments auto-convert\n```\n\n**Property assignment**: Explicit conversion required:\n\n```swift\nlet obj = JSObject.global.myObject.object!\nlet count: Int = 42\nlet message = \"Hello\"\n\nobj[\"count\"] = count.jsValue\nobj[\"message\"] = message.jsValue\n\nobj.count = count.jsValue\nobj.message = message.jsValue\n\n// Alternative: use JSValue static methods\nobj[\"count\"] = .number(Double(count))\nobj.message = .string(message)\ndivElement.innerText = .string(\"Count \\(count)\")\ncanvasElement.width = .number(Double(size))\n```\n\n### JavaScript -> Swift\n\nAccess JavaScript values through ``JSValue`` accessors:\n\n```swift\nlet jsValue: JSValue = // ... some JavaScript value\n\n// Primitive types via direct accessors (most common pattern)\nlet message: String? = jsValue.string\nlet n: Double? = jsValue.number\nlet flag: Bool? = jsValue.boolean\nlet obj: JSObject? = jsValue.object\n\n// Access nested properties through JSObject subscripts\nif let obj = jsValue.object {\n    let nested = obj.key.string\n    let arrayItem = obj.items[0].string\n    let count = obj.count.number\n}\n\n// Arrays (if elements conform to ConstructibleFromJSValue)\nif let items = [String].construct(from: jsValue) {\n    // Use items\n}\n\n// Dictionaries (if values conform to ConstructibleFromJSValue)\nif let data = [String: Int].construct(from: jsValue) {\n    // Use data\n}\n\n// For complex Decodable types, use JSValueDecoder\nstruct User: Decodable {\n    let name: String\n    let age: Int\n}\nlet user = try JSValueDecoder().decode(User.self, from: jsValue)\n```\n\n## Pass Swift Closures back to JavaScript\n\n```swift\npublic class JSClosure: JSObject, JSClosureProtocol {\n    public init(_ body: @escaping (sending [JSValue]) -> JSValue)\n    public static func async(\n        priority: TaskPriority? = nil,\n        _ body: @escaping (sending [JSValue]) async throws(JSException) -> JSValue\n    ) -> JSClosure\n    public func release()\n}\n\npublic class JSOneshotClosure: JSObject, JSClosureProtocol {\n    public init(_ body: @escaping (sending [JSValue]) -> JSValue)\n    public static func async(\n        priority: TaskPriority? = nil,\n        _ body: @escaping (sending [JSValue]) async throws(JSException) -> JSValue\n    ) -> JSOneshotClosure\n    public func release()\n}\n```\n\n**Example**\n\n```swift\nlet document = JSObject.global.document.object!\nlet console = JSObject.global.console.object!\n\n// Persistent closure - keep reference while JavaScript can call it\nlet button = document.createElement!(\"button\").object!\nlet handler = JSClosure { args in\n    console.log!(\"Clicked\", args[0])\n    return .undefined\n}\nbutton.addEventListener!(\"click\", handler)\n\n// One-shot closure - automatically released after first call\nbutton.addEventListener!(\n    \"click\",\n    JSOneshotClosure { _ in\n        console.log!(\"One-off click\")\n        return .undefined\n    },\n    [\"once\": true]\n)\n\n// Async closure - bridges Swift async to JavaScript Promise\nlet asyncHandler = JSClosure.async { _ async throws(JSException) -> JSValue in\n    try! await Task.sleep(nanoseconds: 1_000_000)\n    console.log!(\"Async closure finished\")\n    return .undefined\n}\nbutton.addEventListener!(\"async\", asyncHandler)\n```\n\n## Promises and `async/await`\n\n```swift\npublic final class JSPromise: JSBridgedClass {\n    public init(unsafelyWrapping object: JSObject)\n    public init(resolver: @escaping (@escaping (Result) -> Void) -> Void)\n    public static func async(\n        body: @escaping () async throws(JSException) -> Void\n    ) -> JSPromise\n    public static func async(\n        body: @escaping () async throws(JSException) -> JSValue\n    ) -> JSPromise\n    \n    public enum Result {\n        case success(JSValue)\n        case failure(JSValue)\n    }\n    \n    // Available when JavaScriptEventLoop is linked\n    public var value: JSValue { get async throws(JSException) }\n    public var result: Result { get async }\n}\n```\n\n**Example**\n\n```swift\nimport JavaScriptEventLoop\n\nJavaScriptEventLoop.installGlobalExecutor()\n\nlet console = JSObject.global.console.object!\nlet fetch = JSObject.global.fetch.object!\n\n// Wrap existing JavaScript Promise and await from Swift\nTask {\n    do {\n        let response = try await JSPromise(\n            unsafelyWrapping: fetch(\"https://example.com\").object!\n        ).value\n        console.log!(\"Fetched data\", response)\n    } catch let error as JSException {\n        console.error!(\"Fetch failed\", error.thrownValue)\n    }\n}\n\n// Expose Swift async work to JavaScript\nlet swiftPromise = JSPromise.async {\n    try await Task.sleep(nanoseconds: 1_000_000_000)\n    return .string(\"Swift async complete\")\n}\n```\n\n- Wrap existing promise-returning APIs with ``JSPromise/init(unsafelyWrapping:)``.\n- Use `JSPromise.async(body:)` (with `Void` or `JSValue` return type) to expose Swift `async/await` work to JavaScript callers.\n- To await JavaScript `Promise` from Swift, import `JavaScriptEventLoop`, call `JavaScriptEventLoop.installGlobalExecutor()` early, and use the `value` property.\n- The `value` property suspends until the promise resolves or rejects, rethrowing rejections as ``JSException``.\n",
        "skills/porting/SKILL.md": "---\nname: swift-wasm-porting\ndescription: Check Swift on Wasm compatibility, identify incompatible frameworks, port and refactor code for WebAssembly\n---\n\nYou are a Swift on WebAssembly (Wasm) compatibility expert. Your task is to help with Swift WebAssembly projects.\n\n## Capabilities\n\n1. **Check Wasm compatibility** of Swift packages\n2. **Identify incompatible frameworks** such as:\n   - UIKit\n   - SwiftUI\n   - CoreGraphics\n   - CoreML\n   - URLSession\n   - Accelerate\n3. **Refactor code for Wasm compatibility** using conditional compilation (`#if os(WASI)`)\n4. **Build and test** Swift projects with the Wasm toolchain\n5. **Find Wasm-safe alternatives** for platform-specific code\n\n## Guidelines\n\n- When refactoring, maintain the original implementation for iOS/macOS platforms using conditional compilation\n- For Accelerate functions, consider replacements with:\n  - Matft library\n  - CLAPACK\n  - SIMD\n  - Pure Swift implementations\n- The Swift Wasm toolchain is located at: `~/Library/Developer/Toolchains/`\n- Always attempt a Wasm build to verify compatibility after making changes\n- When you find code that is not compatible and won't ever be compatible with Swift on Wasm because of other technical limitations, create a Swift protocol mapping the code public API and inject this code as a dependency.\n\n## Workflow\n\n1. Analyze the target Swift package or file for Wasm compatibility issues\n2. Identify any incompatible frameworks or APIs being used\n3. Propose refactoring using conditional compilation:\n   ```swift\n   #if canImport(Accelerate)\n   import Accelerate\n   // iOS/macOS implementation\n   #else\n   // Wasm-compatible fallback\n   #endif\n   ```\n4. Implement the changes\n5. Build with the Wasm toolchain to verify\n"
      },
      "plugins": [
        {
          "name": "javascriptkit",
          "description": "Assist Swift developers who consume JavaScriptKit, a Swift library for interacting with JavaScript APIs via WebAssembly",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/javascriptkit"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add swiftwasm/skills",
            "/plugin install javascriptkit@swiftwasm-skills"
          ]
        },
        {
          "name": "bridgejs",
          "description": "Assist Swift developers using BridgeJS for Swift-to-JavaScript interoperability in WebAssembly projects",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/bridgejs"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add swiftwasm/skills",
            "/plugin install bridgejs@swiftwasm-skills"
          ]
        },
        {
          "name": "porting",
          "description": "Check Swift on Wasm compatibility, identify incompatible frameworks, port and refactor code for WebAssembly",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/porting"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add swiftwasm/skills",
            "/plugin install porting@swiftwasm-skills"
          ]
        }
      ]
    }
  ]
}