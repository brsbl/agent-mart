{
  "author": {
    "id": "StirlingMarketingGroup",
    "display_name": "Stirling Marketing Group",
    "avatar_url": "https://avatars.githubusercontent.com/u/41347613?v=4"
  },
  "marketplaces": [
    {
      "name": "cool-mysql",
      "version": null,
      "description": "Comprehensive guide for cool-mysql Go library - MySQL helper with dual connection pools, named parameters, template syntax, caching, and advanced query patterns",
      "repo_full_name": "StirlingMarketingGroup/cool-mysql",
      "repo_url": "https://github.com/StirlingMarketingGroup/cool-mysql",
      "repo_description": "A cool MySQL library for cool people",
      "signals": {
        "stars": 3,
        "forks": 0,
        "pushed_at": "2026-02-19T19:06:55Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"cool-mysql\",\n  \"owner\": {\n    \"name\": \"Stirling Marketing Group\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"cool-mysql\",\n      \"source\": \"./.claude/skills/cool-mysql\",\n      \"description\": \"Comprehensive guide for cool-mysql Go library - MySQL helper with dual connection pools, named parameters, template syntax, caching, and advanced query patterns\"\n    }\n  ]\n}\n",
        "README.md": "# cool-mysql\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/StirlingMarketingGroup/cool-mysql.svg)](https://pkg.go.dev/github.com/StirlingMarketingGroup/cool-mysql)\n[![Go Tests](https://github.com/StirlingMarketingGroup/cool-mysql/actions/workflows/tests.yml/badge.svg)](https://github.com/StirlingMarketingGroup/cool-mysql/actions/workflows/tests.yml)\n[![codecov](https://codecov.io/gh/StirlingMarketingGroup/cool-mysql/branch/master/graph/badge.svg)](https://codecov.io/gh/StirlingMarketingGroup/cool-mysql)\n[![license](https://img.shields.io/badge/license-MIT-red.svg)](LICENSE)\n\n`cool-mysql` is a small library that wraps Go's `database/sql` with MySQL oriented helpers. It keeps the underlying interfaces intact while providing conveniences that save you time when writing data access code.\n\n## Features\n\n- **Dual pools** for reads and writes\n- **Named template parameters** using `@@name` tokens\n- **Automatic retries** with exponential backoff\n- **Pluggable caching** (Redis, Memcached, or in-memory weak pointers) with optional distributed locks\n- **Insert/Upsert helpers** that chunk large sets to respect `max_allowed_packet`\n- **Go template syntax** in queries for conditional logic\n- **Flexible selection** into structs, slices, maps, channels or functions\n- **Select single values** (e.g. `string`, `time.Time`)\n- **JSON columns** can unmarshal directly into struct fields\n- **Channels** supported for selecting and inserting\n- Optional **query logging** and transaction helpers\n- **Pluggable logging** using `log/slog` by default with a Zap adapter\n\n## Installation\n\n```bash\ngo get github.com/StirlingMarketingGroup/cool-mysql\n```\n\n## Quick Start\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"time\"\n\n    mysql \"github.com/StirlingMarketingGroup/cool-mysql\"\n)\n\ntype User struct {\n    ID   int    `mysql:\"id\"`\n    Name string `mysql:\"name\"`\n}\n\nfunc main() {\n    db, err := mysql.New(\n        \"writeUser\", \"writePass\", \"mydb\", \"127.0.0.1\", 3306,\n        \"readUser\", \"readPass\", \"mydb\", \"127.0.0.1\", 3306,\n        \"utf8mb4_unicode_ci\", time.Local,\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    var users []User\n    err = db.Select(&users,\n        \"SELECT id, name FROM users WHERE created_at > @@since\",\n        time.Minute, // cache TTL when caching is configured\n        mysql.Params{\"since\": time.Now().Add(-24 * time.Hour)},\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Printf(\"loaded %d users\", len(users))\n}\n```\n\n## Configuration\n\ncool-mysql can be configured using environment variables:\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `COOL_MAX_EXECUTION_TIME_TIME` | `27` (seconds) | Maximum query execution time (90% of 30 seconds) |\n| `COOL_MAX_ATTEMPTS` | `0` (attempts) | Maximum query attempts including the first try (<=0 disables the cap) |\n| `COOL_REDIS_LOCK_RETRY_DELAY` | `0.020` (seconds) | Delay between Redis lock retry attempts |\n| `COOL_MYSQL_MAX_QUERY_LOG_LENGTH` | `4096` (bytes) | Maximum length of queries in error logs |\n\n**Example:**\n\n```bash\nexport COOL_MAX_EXECUTION_TIME_TIME=60  # 60 second timeout\nexport COOL_MAX_ATTEMPTS=5              # limit to 5 attempts per query\nexport COOL_REDIS_LOCK_RETRY_DELAY=0.050  # 50ms retry delay\nexport COOL_MYSQL_MAX_QUERY_LOG_LENGTH=8192  # 8KB log limit\n```\n\n### Enabling caching\n\n```go\n// use Redis\nr := redis.NewClient(&redis.Options{Addr: \"localhost:6379\"})\ndb.EnableRedis(r)\n\n// or Memcached\ndb.EnableMemcache(memcache.New(\"localhost:11211\"))\n\n// or a simple in-memory cache using weak pointers\ndb.UseCache(mysql.NewWeakCache())\n\n// caches can be stacked\ndb.UseCache(mysql.NewMultiCache(mysql.NewWeakCache(), mysql.NewRedisCache(r)))\n```\n\n## Usage\n\n### Selecting into structs\n\n```go\ntype Profile struct {\n    Likes []string `json:\"likes\"`\n}\n\ntype User struct {\n    ID      int\n    Name    string\n    Profile Profile `db:\"profile_json\"`\n}\n\nvar u User\nerr := db.Select(&u,\n    \"SELECT id, name, profile_json FROM users WHERE id=@@id\",\n    0,\n    mysql.Params{\"id\": 1},\n)\nif err != nil {\n    // if no row is returned, err == sql.ErrNoRows\n    log.Fatal(err)\n}\n```\n\nSelecting into a slice never returns `sql.ErrNoRows` if empty:\n\n```go\nvar all []User\nerr := db.Select(&all, \"SELECT * FROM users WHERE active=1\", 0)\nif err != nil {\n    log.Fatal(err)\n}\nlog.Println(len(all))\n```\n\n### Selecting into single values\n\n```go\nvar name string\nerr := db.Select(&name, \"SELECT name FROM users WHERE id=@@id\", 0, 5) // single param value\n```\n\n### Selecting into channels\n\n```go\nuserCh := make(chan User)\ngo func() {\n    defer close(userCh)\n    if err := db.Select(userCh, \"SELECT id, name FROM users\", 0); err != nil {\n        log.Fatal(err)\n    }\n}()\nfor u := range userCh {\n    log.Printf(\"%d: %s\", u.ID, u.Name)\n}\n```\n\n### Selecting with a function receiver\n\n```go\nerr = db.Select(func(u User) {\n    log.Printf(\"found %s\", u.Name)\n}, \"SELECT id, name FROM users WHERE active=1\", 0)\n```\n\n### Additional query methods\n\n**Count records efficiently:**\n\n```go\ncount, err := db.Count(\"SELECT COUNT(*) FROM users WHERE active = @@active\", 0, mysql.Params{\"active\": 1})\n```\n\n**Check existence:**\n\n```go\nexists, err := db.Exists(\"SELECT 1 FROM users WHERE email = @@email\", 0, mysql.Params{\"email\": \"user@example.com\"})\n// Use ExistsWrites() to query the write connection\nexistsOnWrite, err := db.ExistsWrites(\"SELECT 1 FROM users WHERE email = @@email\", mysql.Params{\"email\": \"user@example.com\"})\n```\n\n**Query against write connection:**\n\n```go\nvar users []User\nerr := db.SelectWrites(&users, \"SELECT id, name FROM users WHERE id = @@id\", mysql.Params{\"id\": 123})\n```\n\n**Direct JSON results:**\n\n```go\nvar result json.RawMessage\nerr := db.SelectJSON(&result, \"SELECT JSON_OBJECT('id', id, 'name', name) FROM users WHERE id = @@id\", 0, mysql.Params{\"id\": 123})\n```\n\n**Execute with detailed results:**\n\n```go\nresult, err := db.ExecResult(\"UPDATE users SET name = @@name WHERE id = @@id\", mysql.Params{\"name\": \"Alice\", \"id\": 123})\nif err != nil {\n    log.Fatal(err)\n}\nrowsAffected, _ := result.RowsAffected()\nlastInsertID, _ := result.LastInsertId()\n```\n\n**Context-aware operations:**\nAll major functions have Context variants (`SelectContext`, `InsertContext`, `UpsertContext`, etc.) for cancellation and timeout support:\n\n```go\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\nvar users []User\nerr := db.SelectContext(ctx, &users, \"SELECT id, name FROM users\", 0)\n```\n\n**Raw SQL strings:**\nUse `mysql.Raw` for literal SQL that shouldn't be escaped:\n\n```go\nerr := db.Select(&users,\n    \"SELECT id, name FROM users WHERE created_at > @@date AND @@condition\",\n    0,\n    mysql.Params{\n        \"date\": time.Now().Add(-24*time.Hour),\n        \"condition\": mysql.Raw(\"status = 'active'\"), // not escaped\n    },\n)\n```\n\n### Conditional queries with templates\n\n```go\nvar since *time.Time\nquery := `SELECT id, name FROM users WHERE 1=1 {{ if .since }}AND created_at > @@since{{ end }}`\nerr = db.Select(&users, query, 0, mysql.Params{\"since\": since})\n```\n\n### Insert helper\n\n```go\nnewUser := User{ID: 123, Name: \"Alice\"}\nerr = db.Insert(\"users\", newUser) // query is built automatically\n```\n\nThe source can also be a channel of structs for batch inserts.\n\n```go\nch := make(chan User)\ngo func() {\n    for _, u := range users {\n        ch <- u\n    }\n    close(ch)\n}()\nif err := db.Insert(\"users\", ch); err != nil { // batch insert\n    log.Fatal(err)\n}\n```\n\n### Upsert helper\n\n```go\nup := User{ID: 123, Name: \"Alice\"}\nerr = db.Upsert(\n    \"users\",            // table name only\n    []string{\"id\"},    // unique columns\n    []string{\"name\"},  // columns to update on conflict\n    \"\",                // additional WHERE clause\n    up,\n)\n```\n\n### Struct tags\n\nFields in a struct can include a `mysql` tag to control how they map to the database. The tag name overrides the column name used by the insert and upsert helpers and when scanning query results.\n\n**Available options:**\n\n- `defaultzero` – write `default(column_name)` instead of the zero value during inserts and parameter interpolation\n- `insertDefault` – alias for `defaultzero` (same behavior)\n- `omitempty` – alias for `defaultzero` (same behavior)\n- `\"-\"` – skip this field entirely (not included in inserts, selects, or parameter interpolation)\n\n**Hex encoding support:**\nColumn names can include hex-encoded characters using `0x` notation (e.g., `0x2c` for comma, `0x20` for space).\n\n```go\ntype Person struct {\n    ID       int       `mysql:\"id\"`\n    Name     string    `mysql:\"name,defaultzero\"`\n    Email    string    `mysql:\"email,omitempty\"`        // same as defaultzero\n    Internal string    `mysql:\"-\"`                      // completely ignored\n    Created  time.Time `mysql:\"created_at,insertDefault\"` // same as defaultzero\n    Special  string    `mysql:\"column0x2cname\"`         // becomes \"column,name\"\n}\n\ndb.Insert(\"people\", Person{})\n// name, email, created_at become default(`name`), default(`email`), default(`created_at`)\n// Internal field is completely ignored\n\n_, _, _ = mysql.InterpolateParams(\n    \"SELECT * FROM people WHERE name = @@Name\",\n    Person{},\n) // produces: SELECT * FROM people WHERE name = default(`name`)\n\ntmpl := `SELECT * FROM people {{ if .Name }}WHERE name=@@Name{{ end }}`\n```\n\n**Important notes:**\n\n- When using template syntax, the struct field name (`.Name` above) is used for lookups, not the column name from the `mysql` tag\n- All three options (`defaultzero`, `insertDefault`, `omitempty`) have identical behavior\n- The `\"-\"` option completely excludes the field from all database operations\n\n### Transactions\n\n```go\ntx, commit, cancel, err := mysql.GetOrCreateTxFromContext(ctx)\ndefer cancel()\nif err != nil {\n    return fmt.Errorf(\"failed to create transaction: %w\", err)\n}\nctx = mysql.NewContextWithTx(ctx, tx)\n\n// do DB work with tx in context\n\nif err := commit(); err != nil {\n    return fmt.Errorf(\"failed to commit tx: %w\", err)\n}\n```\n\n## Advanced Features\n\n### Context Management\n\ncool-mysql provides utilities for managing database connections and transactions through context:\n\n```go\n// Create a new context with a database connection\nctx := mysql.NewContext(context.Background(), db)\n\n// Retrieve the database from context\ndbFromCtx := mysql.FromContext(ctx)\n\n// Transaction management with context\ntx, commit, cancel, err := mysql.GetOrCreateTxFromContext(ctx)\nif err != nil {\n    return err\n}\ndefer cancel()\n\n// Use the transaction\nctx = mysql.NewContextWithTx(ctx, tx)\nerr = db.SelectContext(ctx, &users, \"SELECT * FROM users WHERE active = 1\", 0)\nif err != nil {\n    return err\n}\n\n// Commit the transaction\nif err := commit(); err != nil {\n    return err\n}\n```\n\n### Interfaces and Custom Types\n\n**Zeroer Interface:** Custom zero-value detection\n\n```go\ntype CustomTime struct {\n    time.Time\n}\n\nfunc (ct CustomTime) IsZero() bool {\n    return ct.Time.IsZero() || ct.Year() < 1900\n}\n\n// Use in struct with defaultzero tag\ntype Event struct {\n    ID   int        `mysql:\"id\"`\n    Date CustomTime `mysql:\"created_at,defaultzero\"`\n}\n```\n\n**Valueser Interface:** Custom value conversion\n\n```go\ntype Status int\n\nconst (\n    StatusInactive Status = 0\n    StatusActive   Status = 1\n)\n\nfunc (s Status) Values() []any {\n    return []any{int(s)}\n}\n\n// Use in parameters or struct fields\ntype User struct {\n    ID     int    `mysql:\"id\"`\n    Status Status `mysql:\"status\"`\n}\n```\n\n### Advanced Caching\n\n**MultiCache:** Stack multiple cache layers\n\n```go\n// Combine in-memory and Redis caching\nweak := mysql.NewWeakCache()\nredis := mysql.NewRedisCache(redisClient)\nmulti := mysql.NewMultiCache(weak, redis)\n\ndb.UseCache(multi)\n```\n\n**Cache with distributed locking:**\n\n```go\ndb.EnableRedis(redisClient)\n// Queries will use distributed locks to prevent cache stampedes\nerr := db.Select(&users, \"SELECT * FROM users WHERE popular = 1\",\n    5*time.Minute, // cache TTL\n)\n```\n\n### Row Types and Converters\n\n```go\n// MapRow - convert query results to maps\nvar rows []mysql.MapRow\nerr := db.Select(&rows, \"SELECT id, name, email FROM users\", 0)\n\n// SliceRow - convert to slices\nvar rows []mysql.SliceRow\nerr := db.Select(&rows, \"SELECT id, name, email FROM users\", 0)\n\n// Custom row processing\nerr = db.SelectRows(\"SELECT * FROM large_table\", 0, func(rows *sql.Rows) error {\n    for rows.Next() {\n        // Process each row individually\n        var id int\n        var name string\n        if err := rows.Scan(&id, &name); err != nil {\n            return err\n        }\n        // Handle row...\n    }\n    return rows.Err()\n})\n```\n\n## Performance & Best Practices\n\n### Connection Pooling\n\ncool-mysql uses separate connection pools for read and write operations:\n\n```go\n// Reads use the read pool (optimized for read-heavy workloads)\nvar users []User\nerr := db.Select(&users, \"SELECT * FROM users\", cacheTTL)\n\n// Writes use the write pool (ensures consistency)\nerr := db.Insert(\"users\", newUser)\n\n// Force use of write pool for reads (when read consistency is critical)\nerr := db.SelectWrites(&users, \"SELECT * FROM users WHERE just_created = 1\", nil)\n```\n\n### Large Dataset Handling\n\n**Chunked inserts** automatically respect MySQL's `max_allowed_packet`:\n\n```go\n// Automatically chunks large slices\nlargeUserSlice := make([]User, 10000)\nerr := db.Insert(\"users\", largeUserSlice) // Inserts in optimal chunks\n\n// Channel-based streaming inserts\nuserCh := make(chan User, 100)\ngo func() {\n    defer close(userCh)\n    for _, user := range largeUserSlice {\n        userCh <- user\n    }\n}()\nerr := db.Insert(\"users\", userCh) // Processes in batches\n```\n\n**Streaming selects** for large result sets:\n\n```go\n// Use channels for memory-efficient processing\nuserCh := make(chan User, 100)\ngo func() {\n    defer close(userCh)\n    err := db.Select(userCh, \"SELECT * FROM users\", 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n}()\n\nfor user := range userCh {\n    // Process each user without loading all into memory\n    processUser(user)\n}\n```\n\n### Query Optimization\n\n**Effective caching strategies:**\n\n```go\n// Short TTL for frequently changing data\nerr := db.Select(&activeUsers, \"SELECT * FROM users WHERE active = 1\",\n    30*time.Second)\n\n// Long TTL for relatively static data\nerr := db.Select(&countries, \"SELECT * FROM countries\",\n    24*time.Hour)\n\n// No caching for real-time data\nerr := db.Select(&currentBalance, \"SELECT balance FROM accounts WHERE id = ?\",\n    0, userID) // TTL = 0 means no caching\n```\n\n**Template optimization:**\n\n```go\n// Use templates for dynamic queries to reduce query plan cache pollution\nquery := `\nSELECT * FROM users\nWHERE 1=1\n{{ if .ActiveOnly }}AND active = 1{{ end }}\n{{ if .Department }}AND department = @@Department{{ end }}\n`\n\nparams := struct {\n    ActiveOnly bool\n    Department string\n}{\n    ActiveOnly: true,\n    Department: \"engineering\",\n}\n\nerr := db.Select(&users, query, cacheTTL, params)\n```\n\n### Best Practices\n\n1. **Use appropriate TTL values:**\n   - Static data: hours to days\n   - Semi-static data: minutes to hours\n   - Dynamic data: seconds to minutes\n   - Real-time data: no caching (TTL = 0)\n\n2. **Leverage read/write separation:**\n   - Use regular `Select()` for most reads\n   - Use `SelectWrites()` only when read-after-write consistency is critical\n\n3. **Handle large datasets efficiently:**\n   - Use channels for streaming large result sets\n   - Let the library handle insert chunking automatically\n   - Consider using `Count()` instead of `SELECT COUNT(*)`\n\n4. **Optimize for your caching setup:**\n   - Use `MultiCache` to combine fast local cache with shared Redis cache\n   - Configure appropriate Redis lock retry delays for your workload\n   - Monitor cache hit rates and adjust TTLs accordingly\n\n## Error Handling & Reliability\n\ncool-mysql includes comprehensive error handling and automatic retry mechanisms:\n\n### Automatic Retries\n\nThe library automatically retries operations that fail due to transient MySQL errors:\n\n**Retry-eligible MySQL error codes:**\n\n- `1213` - Deadlock found when trying to get lock\n- `1205` - Lock wait timeout exceeded\n- `2006` - MySQL server has gone away\n- `2013` - Lost connection to MySQL server during query\n\n**Retry behavior:**\n\n- Uses exponential backoff with jitter\n- Maximum retry attempts determined by context timeout\n- Delays start at ~20ms and increase exponentially\n\n```go\n// Operations will automatically retry on transient errors\nerr := db.Select(&users, \"SELECT * FROM users\", 0)\n// If this fails with a deadlock (1213), it will retry automatically\n```\n\n### Custom Error Handling\n\n```go\n// Check for specific error types\nvar users []User\nerr := db.Select(&users, \"SELECT * FROM users WHERE id = ?\", 0, 999)\nif err == sql.ErrNoRows {\n    log.Println(\"No users found\")\n} else if err != nil {\n    log.Printf(\"Database error: %v\", err)\n}\n```\n\n### Transaction Retry Pattern\n\n```go\nfunc performComplexOperation(ctx context.Context, db *mysql.DB) error {\n    return mysql.RetryableTransaction(ctx, db, func(tx *sql.Tx) error {\n        // Your transactional operations here\n        // If this returns a retryable error, the entire transaction will be retried\n        _, err := tx.ExecContext(ctx, \"UPDATE accounts SET balance = balance - 100 WHERE id = ?\", 1)\n        if err != nil {\n            return err\n        }\n        _, err = tx.ExecContext(ctx, \"UPDATE accounts SET balance = balance + 100 WHERE id = ?\", 2)\n        return err\n    })\n}\n```\n\n## License\n\nThis project is licensed under the [MIT License](LICENSE).\n"
      },
      "plugins": [
        {
          "name": "cool-mysql",
          "source": "./.claude/skills/cool-mysql",
          "description": "Comprehensive guide for cool-mysql Go library - MySQL helper with dual connection pools, named parameters, template syntax, caching, and advanced query patterns",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add StirlingMarketingGroup/cool-mysql",
            "/plugin install cool-mysql@cool-mysql"
          ]
        }
      ]
    }
  ]
}