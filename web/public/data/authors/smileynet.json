{
  "author": {
    "id": "smileynet",
    "display_name": "Sam Biggins",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/1320320?v=4",
    "url": "https://github.com/smileynet",
    "bio": "Ghost riding the whip on the post-apocalyptic information super highway",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 17,
      "total_skills": 3,
      "total_stars": 2,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "line-cook",
      "version": null,
      "description": "Task-focused workflow orchestration for Claude Code",
      "owner_info": "smileynet",
      "keywords": [],
      "repo_full_name": "smileynet/line-cook",
      "repo_url": "https://github.com/smileynet/line-cook",
      "repo_description": "Structured AI workflow execution with guardrails. prep‚Üícook‚Üíserve‚Üítidy for Claude Code and OpenCode.",
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-01-29T06:41:26Z",
        "created_at": "2026-01-18T15:41:06Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".beads",
          "type": "tree",
          "size": null
        },
        {
          "path": ".beads/README.md",
          "type": "blob",
          "size": 2250
        },
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 197
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 493
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/commands/smoke-test.md",
          "type": "blob",
          "size": 7256
        },
        {
          "path": ".kiro",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kiro/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kiro/skills/line-cook",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kiro/skills/line-cook/SKILL.md",
          "type": "blob",
          "size": 3629
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 11135
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/maitre.md",
          "type": "blob",
          "size": 4138
        },
        {
          "path": "agents/sous-chef.md",
          "type": "blob",
          "size": 3226
        },
        {
          "path": "agents/taster.md",
          "type": "blob",
          "size": 3085
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/cook.md",
          "type": "blob",
          "size": 8467
        },
        {
          "path": "commands/getting-started.md",
          "type": "blob",
          "size": 3784
        },
        {
          "path": "commands/mise.md",
          "type": "blob",
          "size": 17166
        },
        {
          "path": "commands/plate.md",
          "type": "blob",
          "size": 6264
        },
        {
          "path": "commands/prep.md",
          "type": "blob",
          "size": 10752
        },
        {
          "path": "commands/run.md",
          "type": "blob",
          "size": 5865
        },
        {
          "path": "commands/serve.md",
          "type": "blob",
          "size": 6537
        },
        {
          "path": "commands/tidy.md",
          "type": "blob",
          "size": 8573
        },
        {
          "path": "line-cook-kiro",
          "type": "tree",
          "size": null
        },
        {
          "path": "line-cook-kiro/README.md",
          "type": "blob",
          "size": 2591
        },
        {
          "path": "line-cook-kiro/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "line-cook-kiro/skills/line-cook",
          "type": "tree",
          "size": null
        },
        {
          "path": "line-cook-kiro/skills/line-cook/SKILL.md",
          "type": "blob",
          "size": 3629
        },
        {
          "path": "line-cook-opencode",
          "type": "tree",
          "size": null
        },
        {
          "path": "line-cook-opencode/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "line-cook-opencode/commands/line-cook.md",
          "type": "blob",
          "size": 6759
        },
        {
          "path": "line-cook-opencode/commands/line-getting-started.md",
          "type": "blob",
          "size": 3750
        },
        {
          "path": "line-cook-opencode/commands/line-mise.md",
          "type": "blob",
          "size": 13078
        },
        {
          "path": "line-cook-opencode/commands/line-plate.md",
          "type": "blob",
          "size": 5714
        },
        {
          "path": "line-cook-opencode/commands/line-prep.md",
          "type": "blob",
          "size": 10720
        },
        {
          "path": "line-cook-opencode/commands/line-run.md",
          "type": "blob",
          "size": 4766
        },
        {
          "path": "line-cook-opencode/commands/line-serve.md",
          "type": "blob",
          "size": 5272
        },
        {
          "path": "line-cook-opencode/commands/line-tidy.md",
          "type": "blob",
          "size": 8511
        },
        {
          "path": "line-cook-opencode/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "line-cook-opencode/skills/line-cook",
          "type": "tree",
          "size": null
        },
        {
          "path": "line-cook-opencode/skills/line-cook/SKILL.md",
          "type": "blob",
          "size": 2442
        },
        {
          "path": "tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/README.md",
          "type": "blob",
          "size": 5928
        },
        {
          "path": "tests/fixtures",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/fixtures/sample-project",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/fixtures/sample-project/README.md",
          "type": "blob",
          "size": 531
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"line-cook\",\n  \"description\": \"Task-focused workflow orchestration for Claude Code\",\n  \"owner\": \"smileynet\",\n  \"plugins\": [\n    {\n      \"name\": \"line\",\n      \"source\": \"./\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"line\",\n  \"description\": \"Simple workflow orchestration for Claude Code sessions - mise, prep, cook, serve, tidy, plate, run\",\n  \"version\": \"0.8.0\",\n  \"author\": {\n    \"name\": \"smileynet\",\n    \"url\": \"https://github.com/smileynet\"\n  },\n  \"repository\": \"https://github.com/smileynet/line-cook\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/smileynet/line-cook\",\n  \"keywords\": [\n    \"claude-code\",\n    \"workflow\",\n    \"task-management\",\n    \"beads\",\n    \"productivity\"\n  ]\n}\n",
        ".beads/README.md": "# Beads - AI-Native Issue Tracking\n\nWelcome to Beads! This repository uses **Beads** for issue tracking - a modern, AI-native tool designed to live directly in your codebase alongside your code.\n\n## What is Beads?\n\nBeads is issue tracking that lives in your repo, making it perfect for AI coding agents and developers who want their issues close to their code. No web UI required - everything works through the CLI and integrates seamlessly with git.\n\n**Learn more:** [github.com/steveyegge/beads](https://github.com/steveyegge/beads)\n\n## Quick Start\n\n### Essential Commands\n\n```bash\n# Create new issues\nbd create \"Add user authentication\"\n\n# View all issues\nbd list\n\n# View issue details\nbd show <issue-id>\n\n# Update issue status\nbd update <issue-id> --status in_progress\nbd update <issue-id> --status done\n\n# Sync with git remote\nbd sync\n```\n\n### Working with Issues\n\nIssues in Beads are:\n- **Git-native**: Stored in `.beads/issues.jsonl` and synced like code\n- **AI-friendly**: CLI-first design works perfectly with AI coding agents\n- **Branch-aware**: Issues can follow your branch workflow\n- **Always in sync**: Auto-syncs with your commits\n\n## Why Beads?\n\n‚ú® **AI-Native Design**\n- Built specifically for AI-assisted development workflows\n- CLI-first interface works seamlessly with AI coding agents\n- No context switching to web UIs\n\nüöÄ **Developer Focused**\n- Issues live in your repo, right next to your code\n- Works offline, syncs when you push\n- Fast, lightweight, and stays out of your way\n\nüîß **Git Integration**\n- Automatic sync with git commits\n- Branch-aware issue tracking\n- Intelligent JSONL merge resolution\n\n## Get Started with Beads\n\nTry Beads in your own projects:\n\n```bash\n# Install Beads\ncurl -sSL https://raw.githubusercontent.com/steveyegge/beads/main/scripts/install.sh | bash\n\n# Initialize in your repo\nbd init\n\n# Create your first issue\nbd create \"Try out Beads\"\n```\n\n## Learn More\n\n- **Documentation**: [github.com/steveyegge/beads/docs](https://github.com/steveyegge/beads/tree/main/docs)\n- **Quick Start Guide**: Run `bd quickstart`\n- **Examples**: [github.com/steveyegge/beads/examples](https://github.com/steveyegge/beads/tree/main/examples)\n\n---\n\n*Beads: Issue tracking that moves at the speed of thought* ‚ö°\n",
        ".claude/commands/smoke-test.md": "---\ndescription: Run end-to-end smoke test for Line Cook workflow\nallowed-tools: Bash, Read, Write, Edit, Glob, Grep, Task, TodoWrite, Skill\n---\n\n## Summary\n\n**Run a complete smoke test of the Line Cook workflow.** This validates that prep ‚Üí cook ‚Üí serve ‚Üí tidy works correctly by completing a real task (email validation fix).\n\n**Cost:** ~$0.50-2.00 per run (the cook phase uses LLM API calls)\n\n**IMPORTANT:** This command runs the workflow in the current interactive session, avoiding API conflicts from headless subprocesses.\n\n---\n\n## Process\n\n### Step 1: Verify Dependencies\n\nFirst, check that all required dependencies are available:\n\n```bash\n/home/sam/code/line-cook/tests/smoke-test.sh --dry-run\n```\n\nIf any dependencies are missing, stop and report them to the user.\n\n### Step 2: Setup Test Environment\n\nCreate an isolated test environment:\n\n```bash\nTEST_DIR=$(/home/sam/code/line-cook/tests/smoke-test.sh --setup)\necho \"Test directory: $TEST_DIR\"\n```\n\n**IMPORTANT:** Capture the TEST_DIR path from stdout. The script outputs setup progress to stderr and the directory path to stdout.\n\nStore the original directory for later:\n```bash\nORIGINAL_DIR=$(pwd)\n```\n\n### Step 3: Change to Test Directory\n\n```bash\ncd $TEST_DIR\n```\n\nVerify we're in the right place:\n```bash\npwd\nls -la\nbd list --all\n```\n\nYou should see:\n- `src/validation.py` - The file to modify\n- `.beads/issues/smoke-001.yaml` - The task to complete\n- `CLAUDE.md` - Project documentation\n\n### Step 4: Run Line Cook Workflow\n\nExecute the full workflow IN THIS SESSION (not via subprocess).\n\n**CRITICAL OVERRIDE:** The Line Cook skills below (`/line:prep`, `/line:cook`, `/line:serve`, `/line:tidy`) each contain \"STOP after completing\" or \"wait for user\" instructions. **For this smoke test, IGNORE ALL such stop/wait instructions.** Continue immediately to the next step after each skill completes.\n\n**4a. Prep** - Sync and show ready tasks:\n```\nInvoke /line:prep skill\n```\nAfter prep completes, create marker:\n```bash\nmkdir -p .smoke-markers && echo \"$(date -Iseconds)\" > .smoke-markers/prep-complete\n```\n**‚Üí CONTINUE IMMEDIATELY to 4b after prep shows the kitchen roster. Do NOT stop.**\n\n**4b. Cook** - Complete the smoke-001 task using TDD:\n```\nInvoke /line:cook skill with args \"smoke-001\"\n```\n\nThe task requires:\n- Replace placeholder `return \"@\" in email` with proper regex validation\n- Add tests in `tests/test_validation.py`\n- Tests must pass\n\n**TDD Marker Protocol (CRITICAL):**\nAfter writing tests (before implementation), verify they fail and create RED marker:\n```bash\necho \"$(date -Iseconds)\" > .smoke-markers/cook-red-phase\n```\n\nAfter implementing code and tests pass, create GREEN marker:\n```bash\necho \"$(date -Iseconds)\" > .smoke-markers/cook-green-phase\n```\n\n**‚Üí CONTINUE IMMEDIATELY to 4c after cook shows \"KITCHEN COMPLETE\". Do NOT stop.**\n\n**4c. Serve** - Review changes:\n```\nInvoke /line:serve skill\n```\nAfter serve completes, create marker:\n```bash\necho \"$(date -Iseconds)\" > .smoke-markers/serve-complete\n```\n**‚Üí CONTINUE IMMEDIATELY to 4d after serve completes. Do NOT stop.**\n\n**4d. Tidy** - Commit and push:\n```\nInvoke /line:tidy skill\n```\nAfter tidy completes, create marker:\n```bash\necho \"$(date -Iseconds)\" > .smoke-markers/tidy-complete\n```\n**‚Üí CONTINUE IMMEDIATELY to Step 5 after tidy shows \"TIDY REPORT\". Do NOT stop.**\n\n**IMPORTANT:** After tidy completes, you MUST continue to Step 5 (validate) and Step 6 (teardown). Do not stop after tidy - the workflow is not complete until validation passes.\n\n### Step 5: Validate Results\n\nAfter the workflow completes, validate all proof-of-work artifacts:\n\n```bash\ncd $ORIGINAL_DIR\n/home/sam/code/line-cook/tests/smoke-test.sh --validate $TEST_DIR\n```\n\nThe validation checks:\n1. `validation.py` uses regex (not placeholder)\n2. Test file exists with actual tests\n3. Tests pass (pytest)\n4. Bead smoke-001 is closed\n5. Commit exists referencing the task\n6. Changes pushed to remote\n7. Working tree is clean\n8. TDD cycle followed (RED‚ÜíGREEN markers)\n9. Serve phase completed (code review)\n10. Commit follows kitchen log format\n\n### Step 6: Teardown\n\nClean up the test environment:\n\n```bash\n/home/sam/code/line-cook/tests/smoke-test.sh --teardown $TEST_DIR\n```\n\n### Step 7: Report Results\n\n**If all validations pass:**\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  SMOKE TEST: PASSED                                          ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nAll 10 proof-of-work checks validated:\n  [‚úì] validation.py updated with regex\n  [‚úì] Test file created\n  [‚úì] Tests pass\n  [‚úì] Bead closed\n  [‚úì] Commit exists\n  [‚úì] Pushed to remote\n  [‚úì] Working tree clean\n  [‚úì] TDD cycle verified (RED‚ÜíGREEN)\n  [‚úì] Serve phase completed\n  [‚úì] Commit follows kitchen log format\n\nLine Cook workflow is functioning correctly.\n```\n\n**If any validation fails:**\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  SMOKE TEST: FAILED                                          ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nValidation results:\n  [‚úì] validation.py updated with regex\n  [‚úì] Test file created\n  [‚úó] Tests pass - FAILED\n      > Error: 2 tests failed\n  [‚úì] Bead closed\n  [‚úó] TDD cycle verified - FAILED\n      > RED phase marker missing\n  ...\n\nTest directory preserved at: <path>\nRun manually to investigate:\n  cd <path>\n  pytest -v\n```\n\nWhen a failure occurs, DO NOT tear down automatically - preserve the test directory for debugging.\n\n**REMINDER:** The smoke test is only complete after validation passes and teardown runs. If you stop after /line:tidy, you have not finished the smoke test.\n\n## Error Handling\n\n**If setup fails:**\n- Report the error\n- No teardown needed\n\n**If workflow step fails:**\n- Note which step failed\n- Run validation anyway (to see partial progress)\n- Preserve test directory\n- Report failure with debugging steps\n\n**If validation fails:**\n- Preserve test directory\n- Report which checks failed\n- Suggest debugging steps\n\n## Example Usage\n\n```\n/smoke-test              # Run full smoke test\n```\n\n## What This Tests\n\nThe smoke test validates the complete Line Cook cycle:\n\n1. **Prep** - Git sync, bead status check\n2. **Cook** - Task execution with TDD guardrails (RED‚ÜíGREEN cycle)\n3. **Serve** - Code review\n4. **Tidy** - Commit, push, close bead\n\n**Task:** Replace placeholder email validation (`return \"@\" in email`) with proper regex validation and tests.\n\n**Validates both:**\n- **Code artifacts** - Files created, tests pass, bead closed, commit pushed\n- **Workflow integrity** - TDD discipline followed, code review executed, commit format correct\n\nThis is a real coding task that exercises all Line Cook components.\n",
        ".kiro/skills/line-cook/SKILL.md": "---\nname: line-cook\ndescription: AI-supervised development workflow. Use when running prep, cook, serve, tidy, or work commands, managing beads issues during sessions, or following prep‚Üícook‚Üíserve‚Üítidy cycle. Covers workflow orchestration, guardrails, and session management.\n---\n\n# Line Cook\n\nStructured AI workflow execution for disciplined development.\n\n## When to Use\n\n- Starting a work session with \"work\" or \"/work\"\n- Running individual workflow steps: \"mise\", \"prep\", \"cook\", \"serve\", \"tidy\", \"plate\"\n- Managing beads issues during execution\n- Understanding workflow guardrails\n\n## Quick Reference\n\n| Command | Purpose |\n|---------|---------|\n| \"mise\" or \"plan\" | Plan work breakdown before implementation |\n| \"prep\" | Sync git, show ready tasks |\n| \"cook\" | Claim and execute a task with TDD cycle |\n| \"serve\" | AI peer review of completed work |\n| \"tidy\" | Commit, sync beads, push |\n| \"plate\" | Validate completed feature |\n| \"run\" | Full run (mise‚Üíprep‚Üícook‚Üíserve‚Üítidy‚Üíplate) |\n| \"work\" | Quick cycle (prep‚Üícook‚Üíserve‚Üítidy) |\n\n## Core Workflow\n\n**Quick cycle (most common):**\n```\nprep ‚Üí cook ‚Üí serve ‚Üí tidy\n```\n\n**Full service (feature delivery):**\n```\nmise ‚Üí prep ‚Üí cook ‚Üí serve ‚Üí tidy ‚Üí plate\n```\n\n### Step-by-Step\n\n1. **Mise**: Plan work breakdown (interactive)\n2. **Prep**: Sync state, identify available work\n3. **Cook**: Claim task, execute with guardrails, verify completion\n4. **Serve**: AI reviews changes\n5. **Tidy**: File discovered issues, commit, push\n6. **Plate**: Validate feature completion (when applicable)\n\n## Guardrails\n\nLine Cook enforces these disciplines:\n\n- **Sync before work** - Always start with current state\n- **One task at a time** - Focus prevents scope creep\n- **Verify before done** - Tests pass, code compiles\n- **File, don't block** - Discovered issues become new beads\n- **Push before stop** - Work isn't done until it's pushed\n\n## TDD Cycle with Quality Gates\n\nCook phase follows Red-Green-Refactor with automatic quality checks:\n\n**RED**: Write failing test\n- Write test for the feature\n- Verify test fails\n- Taster agent reviews test quality\n- Address critical issues before proceeding\n\n**GREEN**: Implement minimal code\n- Write simplest code to make test pass\n- Verify tests pass\n- No refactoring yet\n\n**REFACTOR**: Clean up code\n- Improve structure while tests pass\n- Ensure tests still pass after refactoring\n\n**Quality Gates** (must pass before completion):\n- Tests pass (project-specific test command)\n- Code builds (project-specific build command)\n- Test quality approved by taster agent\n- Code quality approved by sous-chef agent (serve phase)\n\n## Beads Integration\n\nLine Cook uses beads for task management:\n\n```bash\nbd ready                              # Find unblocked tasks\nbd update <id> --status in_progress   # Claim task\nbd show <id>                          # Get task context\nbd close <id>                         # Complete task\nbd sync                               # Sync with git\n```\n\n## Parking Lot Pattern\n\nTasks under \"Retrospective\" or \"Backlog\" epics are excluded from auto-selection. Explicit selection still works:\n\n```bash\nbd update <parked-task-id> --status in_progress\n```\n\n## Error Handling\n\nIf a step fails:\n- **Prep fails**: Fix sync issues, retry\n- **Cook fails**: Continue to tidy to save progress\n- **Serve fails**: Review skipped, continue to tidy\n- **Tidy fails**: Create bead for follow-up\n- **Plate fails**: Note incomplete, create follow-up bead\n\n## Reference\n\nFor full documentation, see:\n- `README.md` in project root - Philosophy and installation\n- `steering/*.md` files - Workflow instructions\n",
        "README.md": "# Line Cook\n\n**You design. It ships.**\n\nFocus on the what and why‚ÄîLine Cook handles the how. Structured execution with guardrails that keeps you in deep work while AI runs the prep‚Üícook‚Üíserve‚Üítidy cycle‚Äîsyncing state, executing tasks, reviewing changes, and committing work.\n\n## Core Concepts\n\nBefore diving in, understand two key ideas:\n\n**Sessions, not streams.** AI context is finite. Work in bounded sessions‚Äîprep, cook, serve, tidy‚Äîthen clear context and start fresh. Don't treat AI conversations as endless streams. Each session ends with a push; discoveries become tracked issues for the next session.\n\n**You plan, it executes.** Brainstorm with the AI to scope work and create issues. Then hand off to Line Cook for disciplined execution. Don't mix modes‚Äîcreative exploration and systematic execution are different phases with different goals.\n\n> **Learn more:** [Mental Models](docs/mental-models.md) explains these concepts in depth.\n\n## Quick Start\n\n```bash\n# 1. Initialize beads in your project\nbd init\n\n# 2. Create some tasks\nbd create --title=\"Implement user auth\" --type=feature --priority=1\nbd create --title=\"Add login form\" --type=task\n\n# 3. Run the workflow\n/line:run\n```\n\nThat's it. Line Cook syncs your repo, picks a ready task, executes it with guardrails, reviews the work, and commits when done.\n\n> **New to Line Cook?** Run `/line:getting-started` for a quick workflow guide.\n\n## What is Beads?\n\n[Beads](https://github.com/steveyegge/beads) is a git-native issue tracker. Issues live in your repository as files, travel with your code, and work offline.\n\n**Why git-native issues?**\n- **Memory between sessions** - AI forgets, beads remember. When context clears, your work history persists.\n- **Travels with code** - Clone a repo, get its issues. No separate system to sync.\n- **AI-friendly** - Issues are plain text files the AI can read and update directly.\n- **Works offline** - No external service required.\n\nLine Cook orchestrates beads execution‚Äîit picks tasks, runs the work cycle, and files discoveries as new issues.\n\n## When NOT to Use Line Cook\n\nLine Cook adds structure. Structure has overhead. Skip it when:\n\n- **Quick one-off fixes** - Just make the change and commit\n- **Exploratory coding** - When you're learning or prototyping\n- **Pair programming** - When you're actively collaborating in real-time\n- **Tiny projects** - If setup takes longer than the work\n\nUse Line Cook when:\n- Work spans multiple sessions\n- Tasks have dependencies\n- You want automated review\n- You're building trust in AI workflows\n\n## What It Does\n\n```mermaid\ngraph LR\n    subgraph user [\"You + AI\"]\n        A[Brainstorm] --> B[/mise/]\n        B --> C[Create beads]\n    end\n    subgraph auto [\"Line Cook\"]\n        D[\"/prep\"] --> E[\"/cook\"] --> F[\"/serve\"] --> G[\"/tidy\"]\n    end\n    C --> D\n    G --> |next task| D\n\n    style user fill:#4a1d6e,stroke:#9333ea,color:#e9d5ff\n    style auto fill:#134e4a,stroke:#14b8a6,color:#99f6e4\n```\n\n| Command | What happens |\n|---------|--------------|\n| `/getting-started` | Quick workflow guide for beginners |\n| `/mise` | Create work breakdown before starting |\n| `/prep` | Sync git, show ready tasks |\n| `/cook` | Execute task with TDD cycle |\n| `/serve` | Review code changes |\n| `/tidy` | Commit and push changes |\n| `/plate` | Validate completed feature |\n| `/run` | Run full workflow cycle |\n\n> **Session boundary:** After `/tidy` pushes your work, start a new session or clear context (`/compact`) before starting `/prep` for the next task.\n\n## Getting Started\n\n**Two starting points** depending on where you are:\n\n| Starting Point | What to Do |\n|----------------|------------|\n| **\"I know what to build\"** | `/mise` to validate scope and create beads ‚Üí `/line:prep` |\n| **\"I have a vague idea\"** | `/mise` to brainstorm, scope, and create beads ‚Üí `/line:prep` |\n\nBoth paths use `/mise`‚Äîeven if you know what you want, it helps create well-scoped tasks that fit in single sessions.\n\n**Tutorials** walk through the complete journey from idea to execution:\n- [Claude Code Tutorial](docs/tutorial-claude-code.md)\n- [OpenCode Tutorial](docs/tutorial-opencode.md)\n- [Kiro Tutorial](docs/tutorial-kiro.md)\n\n**Learn the commands** by running them individually first:\n\n```bash\n# 1. Mise: Create work breakdown before starting\n/line:mise\n\n# 2. Prep: Sync git and see available tasks\n/line:prep\n\n# 3. Cook: Execute task with TDD cycle\n/line:cook\n\n# 4. Serve: Review code changes\n/line:serve\n\n# 5. Tidy: Commit and push changes\n/line:tidy\n\n# 6. Plate: Validate completed feature\n/line:plate <feature-id>\n```\n\nOnce comfortable with each step, use `/line:run` to run them all together.\n\n## Installation\n\n> **Requires:**\n> - [beads](https://github.com/steveyegge/beads): `brew install steveyegge/beads/bd` (or see repo for npm/go options)\n> - Git\n> - Claude Code or OpenCode\n\n### Claude Code\n\n**Remote (recommended):**\n```bash\n/plugin marketplace add smileynet/line-cook\n/plugin install line@line-cook\n```\nUpdate: `/plugin update line`\n\n**Local (for development):**\n```bash\ngit clone https://github.com/smileynet/line-cook.git ~/line-cook\ncd ~/line-cook && ./scripts/install-claude-code.sh\n```\nUpdate: `cd ~/line-cook && git pull && ./scripts/install-claude-code.sh`\n\n> **Note:** Local plugins cannot use `/plugin update`. To switch from local to remote, run `/plugin uninstall line` first.\n\nCommands: `/line:getting-started`, `/line:mise`, `/line:prep`, `/line:cook`, `/line:serve`, `/line:tidy`, `/line:plate`, `/line:run`\n\n### OpenCode\n\n**Remote:**\n```bash\nopencode plugin install https://github.com/smileynet/line-cook\n```\n\n**Local:**\n> Requires [bun](https://bun.sh/) for building\n\n```bash\ngit clone https://github.com/smileynet/line-cook.git ~/line-cook\ncd ~/line-cook/line-cook-opencode && bun run build && ./install.sh\n```\n\nCommands: `/line-getting-started`, `/line-mise`, `/line-prep`, `/line-cook`, `/line-serve`, `/line-tidy`, `/line-plate`, `/line-run`\n\n### Kiro\n\nCopy the `line-cook-kiro/` directory to your `.kiro/` folder:\n\n```bash\ngit clone https://github.com/smileynet/line-cook.git ~/line-cook\ncp -r ~/line-cook/line-cook-kiro/* ~/.kiro/\n```\n\nCommands: `prep`, `cook`, `serve`, `tidy`, `work`\n\n## The Guardrails\n\nLine Cook enforces discipline so you don't have to:\n\n- **Sync before work** - Always start with current state\n- **One task at a time** - Focus prevents scope creep\n- **Verify before done** - Tests pass, code compiles\n- **File, don't block** - Discovered issues become new beads\n- **Push before stop** - Work isn't done until it's pushed\n\n> **Tip: Parking Lot Epics**\n>\n> Create \"Retrospective\" or \"Backlog\" epics for deferred work. Tasks filed under these epics are automatically excluded from `/prep` and `/cook` auto-selection, keeping focus on active work. You can still work on them explicitly via `/line:cook <task-id>`.\n\n## Why Line Cook?\n\nLine Cook sits between manual prompting and full autonomy:\n\n| Approach | Control | Automation |\n|----------|---------|------------|\n| Manual prompting | Full | None |\n| Beads | High | Low |\n| **Line Cook** | Medium | Medium |\n| Gas Town | Low | High |\n\nThe goal: build confidence in AI workflows before going full YOLO mode.\n\n### The Kitchen Metaphor\n\n- **Chef** (you) plans the menu during brainstorming\n- **Line cook** (this tool) executes orders systematically\n\nA good line cook follows the recipe and calls out problems‚Äîbut doesn't redesign the dish mid-service.\n\n## Influences\n\nBuilt on ideas from:\n\n- **[beads](https://github.com/steveyegge/beads)** - Git-native issue tracking for AI development. Line Cook orchestrates beads execution.\n- **[Gas Town](https://github.com/steveyegge/gastown)** - Autonomous agent framework. Line Cook is the stepping stone toward that level of trust.\n- **[Vibe Coding](https://bookshop.org/p/books/vibe-coding-building-production-grade-software-with-genai-chat-agents-and-beyond-gene-kim/b6e53e37eeba8cac)** - Gene Kim & Steve Yegge's book on AI-assisted development. The \"file, don't block\" principle and checkpoint patterns come from here.\n\n## Project Structure\n\n```\nline-cook/\n‚îú‚îÄ‚îÄ .claude-plugin/     # Plugin manifest\n‚îú‚îÄ‚îÄ agents/             # Claude Code subagents (taster, sous-chef, ma√Ætre)\n‚îú‚îÄ‚îÄ commands/           # Claude Code slash commands\n‚îú‚îÄ‚îÄ line-cook-opencode/ # OpenCode plugin\n‚îú‚îÄ‚îÄ line-cook-kiro/     # Kiro agent and steering\n‚îú‚îÄ‚îÄ scripts/            # Installation helpers\n‚îú‚îÄ‚îÄ README.md           # This file\n‚îî‚îÄ‚îÄ AGENTS.md           # Technical reference\n```\n\n## Development\n\n**Plugin commands** (`commands/`) are distributed to end users. After modifying, reinstall to test:\n\n```bash\n./scripts/install-claude-code.sh\n```\n\nThen test the command in a new Claude Code session (or use `/plugin reload line` if available).\n\n**Project-local dev commands** (`.claude/commands/`) are only available when working in the line-cook repository. These are not distributed with the plugin:\n\n- `/smoke-test` - Run end-to-end command execution tests\n\n## FAQ\n\n**What if I don't use beads?**\n\nYou can still run the commands‚Äîthey'll work. But you lose the \"memory between sessions\" benefit. Without beads, there's no persistent record of what was done, what's blocked, or what was discovered. Consider beads as optional but highly recommended.\n\n**Can I use this with GitHub Issues / Jira?**\n\nYes. Beads is additive, not exclusive. Use your main tracker for team visibility and beads for your local AI workflow. Some teams sync the two; others keep them separate.\n\n**What if my project doesn't have tests?**\n\n`/cook` verification will be limited to \"code compiles.\" You lose the automated quality gate, so review in `/serve` becomes more important. Consider adding tests incrementally as you work.\n\n**How long should a task be?**\n\nA task should take roughly 5-10 minutes of AI execution time. If it's taking longer, that's often a sign the task isn't decomposed enough. Break it down with dependencies‚Äîsmaller tasks mean more checkpoints and easier recovery.\n\n**Can I run commands out of order?**\n\nYes. Each command is independent. But the guardrails exist for a reason: `/prep` ensures you're synced, `/serve` catches issues before commit, `/tidy` ensures work is pushed. Skipping steps means accepting more risk.\n\n**What's the minimum viable workflow?**\n\n`/prep` ‚Üí `/cook` ‚Üí `/tidy`. This gives you: sync, execute with verification, commit and push. Add `/serve` when you want AI review. Add `/mise` when you need help planning.\n\n**What does \"headless Claude\" mean?**\n\nHeadless means Claude running as a background process‚Äîno interactive terminal, just a prompt in and results out. `/serve` uses headless Claude to get a fresh review of your changes from a separate context.\n\n**Why clear context between tasks?**\n\nAI context windows are finite. Old discussions crowd out new work. Clearing between tasks ensures each session starts focused. Your beads persist‚Äîonly the conversation history resets.\n\n## License\n\nMIT\n\n## Related\n\n- [beads](https://github.com/steveyegge/beads) - Git-native issue tracking\n- [Gas Town](https://github.com/steveyegge/gastown) - Autonomous agent framework\n",
        "agents/maitre.md": "---\nname: maitre\ndescription: Reviews feature acceptance and BDD test quality - verifies acceptance criteria coverage and Given-When-Then structure\ntools: Glob, Grep, Read\nmodel: sonnet\n---\n\n# Ma√Ætre Agent\n\nYou are a BDD test quality specialist for Line Cook workflow. Your role is to ensure feature tests meet quality standards before feature completion.\n\n## Your Role\n\nYou review feature BDD (Behavior-Driven Development) tests after feature implementation to ensure they properly validate user-observable outcomes. You review BDD/integration tests, NOT unit tests (unit tests are reviewed by taster).\n\n## When You're Called\n\nDuring **plate** phase of Line Cook workflow, before closing a feature bead.\n\n## Review Process\n\n### 1. Load Feature Context\n\nUnderstand the feature being validated from the prompt context.\n\n### 2. Review Acceptance Criteria\n\nExtract and verify acceptance criteria:\n- List all acceptance criteria\n- Each criterion should be user-observable\n- Criteria should be testable from user's perspective\n\n### 3. Review BDD Test Coverage\n\nCheck that all acceptance criteria have corresponding tests:\n- Each acceptance criterion has at least one test\n- Tests cover happy path scenarios\n- Tests cover error/failure scenarios\n- Edge cases are tested\n\n### 4. Review BDD Test Structure\n\nVerify tests follow Given-When-Then structure:\n- Test function name follows `TestFeature_<FeatureName>` pattern\n- Each test has Given-When-Then comments\n- Given section clearly describes initial state\n- When section clearly describes action taken\n- Then section clearly describes expected outcome\n\n### 5. Review Test Clarity\n\nEnsure tests are readable and self-documenting:\n- Test names are descriptive\n- Variable names are meaningful\n- Complex setup is explained\n- Test failure messages are clear\n\n### 6. Review User Perspective\n\nVerify tests validate from user's perspective:\n- Tests use real system operations\n- Tests exercise feature as user would\n- Tests validate outcomes, not internal state\n\n### 7. Review Error Scenarios\n\nCheck that error paths are tested:\n- Failure scenarios have tests\n- Error messages are validated\n- System state after error is tested\n\n### 8. Review Smoke Tests\n\nVerify smoke tests exist for CLI features:\n- Smoke test script exists\n- Smoke tests exercise user-facing CLI\n- Smoke tests validate end-to-end workflows\n\n## Quality Assessment Output\n\n```\nBDD QUALITY: [APPROVED | NEEDS CHANGES | BLOCKED]\n\nFeature: <feature-id> - <feature-title>\n\nTest Coverage:\n  [‚úì/‚úó] All acceptance criteria tested\n  [‚úì/‚úó] Happy path scenarios covered\n  [‚úì/‚úó] Error scenarios included\n  [‚úì/‚úó] Edge cases tested\n\nTest Structure:\n  [‚úì/‚úó] Given-When-Then structure used\n  [‚úì/‚úó] Test names follow naming convention\n  [‚úì/‚úó] Sections clearly marked\n\nClarity:\n  [‚úì/‚úó] Tests are self-documenting\n  [‚úì/‚úó] Variable names are meaningful\n  [‚úì/‚úó] Failure messages are clear\n\nUser Perspective:\n  [‚úì/‚úó] Tests validate user outcomes\n  [‚úì/‚úó] Real system operations used\n  [‚úì/‚úó] No implementation detail testing\n\nError Scenarios:\n  [‚úì/‚úó] Failure paths tested\n  [‚úì/‚úó] Error handling verified\n\nSmoke Tests:\n  [‚úì/‚úó] CLI smoke tests exist\n  [‚úì/‚úó] End-to-end workflows validated\n\nIssues Found:\n[List any critical or recommended changes]\n\nSummary: [Overall assessment]\n```\n\n## Blocking Criteria\n\n**Use BLOCKED when:**\n- Missing tests for acceptance criteria\n- No Given-When-Then structure\n- Tests don't validate user perspective\n- Missing smoke tests for CLI features\n- No error scenarios tested\n\n**Use NEEDS CHANGES when:**\n- Test names could be clearer\n- Some edge cases untested\n- Minor code style issues\n\n**Use APPROVED when:**\n- All acceptance criteria have tests\n- Given-When-Then structure used correctly\n- Tests validate user outcomes\n- Smoke tests exist and pass\n- Error scenarios are tested\n\n## Your Authority\n\n- **APPROVED**: BDD tests meet quality bar - proceed with plate service\n- **NEEDS CHANGES**: Address issues before completion\n- **BLOCKED**: Critical issues must be fixed first\n\nBe thorough about ensuring features are truly complete from the user's perspective.\n",
        "agents/sous-chef.md": "---\nname: sous-chef\ndescription: Code review specialist - ensures code quality before commit, checking correctness, security, style, completeness\ntools: Glob, Grep, Read\nmodel: sonnet\n---\n\n# Sous-Chef Agent\n\nYou are a code review specialist for the Line Cook workflow. Your role is to ensure code meets quality standards before committing.\n\n## Your Role\n\nYou review code changes after implementation to ensure they meet quality criteria. You review implementation code, NOT tests (tests are reviewed by taster).\n\n## When You're Called\n\nDuring the **serve** phase of the Line Cook workflow, after the developer completes a task and before committing.\n\n## Review Process\n\n### 1. Load Task Context\n\nUnderstand what was implemented from the prompt context provided.\n\n### 2. Review Code Changes\n\nExamine the changes using git diff or by reading the changed files.\n\n### 3. Apply Quality Checklist\n\n#### Correctness\n- Logic is correct and matches task requirements\n- Edge cases are handled appropriately\n- Error handling is comprehensive\n- No race conditions or concurrency issues\n- No off-by-one errors\n\n#### Security\n- Input validation for all user-supplied data\n- No hardcoded secrets, passwords, or API keys\n- SQL injection protection (parameterized queries)\n- XSS protection for web output\n- Path traversal protection\n\n#### Style\n- Naming follows project conventions\n- Consistent indentation and formatting\n- Functions are properly scoped\n- Code organization follows project structure\n- No commented-out code or debug code\n\n#### Completeness\n- All acceptance criteria met\n- Deliverables match task description\n- No TODO comments for critical functionality\n- Tests cover the implementation\n- Documentation updated if needed\n\n### 4. Provide Assessment\n\nOutput your review in this format:\n\n```\n## Code Review: <task-id> - <title>\n\n### Summary\n[Brief overall assessment]\n\n### Quality Assessment\n\n#### Correctness\n[Assessment]\n\n#### Security\n[Assessment]\n\n#### Style\n[Assessment]\n\n#### Completeness\n[Assessment]\n\n### Issues Found\n\n**Critical** (must fix before TIDY):\n- [file:line] - [Issue]\n  - Suggestion: [how to fix]\n\n**Major** (should fix):\n- [file:line] - [Issue]\n\n**Minor** (nice to fix):\n- [file:line] - [Issue]\n\n### Positive Notes\n- [Something done well]\n\n### Verdict\n- [ ] APPROVED - Code meets quality bar, proceed to tidy\n- [ ] NEEDS_CHANGES - Issues found, recommend rework before commit\n- [ ] BLOCKED - Critical issues prevent progress, must fix\n```\n\n## Quality Standards\n\n### Must Have (Blocks TIDY Phase)\n- Correctness verified\n- No security vulnerabilities\n- Consistent style with codebase\n- Task fully addressed\n\n### Should Have\n- Proper code structure\n- Good documentation\n- No debug code\n\n## Common Anti-Patterns to Flag\n\n- **Silent Failures**: Errors that don't propagate properly\n- **Hardcoded Secrets**: Sensitive data in code\n- **Missing Input Validation**: User input used without validation\n- **Overly Complex Functions**: Too many responsibilities\n\n## Your Authority\n\n- **APPROVED**: Code meets quality bar - proceed to tidy\n- **NEEDS_CHANGES**: Issues found - recommend rework before commit\n- **BLOCKED**: Critical issues prevent progress - must fix\n\nBe thorough, constructive, consistent, and practical.\n",
        "agents/taster.md": "---\nname: taster\ndescription: Reviews test quality during TDD cycle - ensures tests are isolated, fast, repeatable, clear with proper structure\ntools: Glob, Grep, Read\nmodel: sonnet\n---\n\n# Taster Agent\n\nYou are a test quality specialist for the Line Cook workflow. Your role is to ensure tests meet the project's quality standards before implementation proceeds.\n\n## Your Role\n\nYou review tests during the TDD cycle to ensure they meet quality criteria. You are NOT reviewing implementation code - only tests.\n\n## When You're Called\n\nDuring the **RED** phase of TDD in the cook workflow, after the developer writes a failing test.\n\n## Review Process\n\n### 1. Identify Test Files\n\nFind the test files to review based on the prompt context.\n\n### 2. Apply Quality Checklist\n\nReview tests against these criteria:\n\n#### Isolated\n- Each test runs independently\n- No shared state between tests\n- Tests can run in any order\n- No dependencies on other tests\n\n#### Fast\n- Tests complete quickly (< 100ms for unit tests)\n- No sleep statements except in integration tests\n- No unnecessary network calls or file I/O\n\n#### Repeatable\n- Same result every time\n- No randomness without seeding\n- No time-dependent logic (or properly mocked)\n\n#### Self-contained\n- All setup within the test\n- Creates own test data\n- Cleans up after itself (defer, afterEach, teardown)\n\n#### Focused\n- Tests one thing\n- Clear what's being tested\n- Single assertion or related assertions\n\n#### Clear\n- Test name describes what's tested\n- Intent obvious from reading\n- Clear failure messages\n- Minimal test code\n\n### 3. Check Test Structure\n\nGood structure follows Setup-Execute-Validate-Cleanup pattern.\n\n### 4. Provide Assessment\n\nOutput your review in this format:\n\n```\n## Test Quality Review: <package/feature>\n\n### Summary\n[Brief overview]\n\n### Quality Assessment\n[Assessment for each criterion]\n\n### Issues Found\n\n**Critical** (must fix before GREEN phase):\n- [Issue]\n\n**Minor** (should fix):\n- [Issue]\n\n### Recommendation\n- [ ] APPROVED - Tests meet quality bar, proceed to GREEN phase\n- [ ] APPROVED WITH NOTES - Fix minor issues but can proceed\n- [ ] REJECTED - Tests don't meet quality bar, fix critical issues first\n```\n\n## Quality Standards\n\n### Must Have (Blocks GREEN Phase)\n- Tests are isolated\n- Tests are self-contained\n- Tests have clear names\n- Tests have clear failure messages\n- Tests follow proper structure\n\n### Should Have\n- Tests are fast\n- Tests are focused\n- Tests cover error cases\n- Tests use cleanup mechanisms\n\n## Common Anti-Patterns to Flag\n\n- **The Liar**: Test passes but doesn't actually validate anything\n- **The Giant**: Test does too much, tests multiple things\n- **Excessive Setup**: Too much boilerplate\n- **External Fixtures**: Depends on external files\n- **Interdependent Tests**: Tests depend on each other\n\n## Your Authority\n\n- **APPROVED**: Tests meet quality bar - proceed to GREEN phase\n- **APPROVED WITH NOTES**: Fix minor issues but can proceed\n- **REJECTED**: Tests don't meet quality bar - fix critical issues first\n\nBe thorough, constructive, consistent, and practical.\n",
        "commands/cook.md": "---\ndescription: Select and execute a task with completion guardrails\nallowed-tools: Bash, Read, Write, Edit, Glob, Grep, Task, TodoWrite, AskUserQuestion\n---\n\n## Summary\n\n**Execute a task with guardrails ensuring completion.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\n**Arguments:** `$ARGUMENTS` (optional) - Specific task ID to execute\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Select Task\n\n**If `$ARGUMENTS` provided:**\n- Use that task ID directly\n\n**Otherwise:**\n- Run `bd ready` to get available tasks\n- Select the highest priority task (lowest P number)\n\n**Check if selected item is an epic:**\n```bash\nbd show <id> --json\n```\n\nIf `issue_type` is `epic`, the epic itself has no work to execute. Instead:\n\n1. Show the epic and its children:\n   ```bash\n   bd list --parent=<epic-id> --all\n   ```\n\n2. Find the first ready (unblocked, open) child and select that instead\n\n3. Output epic context:\n   ```\n   EPIC SELECTED: <epic-id> - <epic-title>\n   ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n   Epics contain no direct work. Selecting first ready child:\n\n   Children (<open>/<total>):\n     ‚óã <id>: <title> [P<n>] ‚Üê selected\n     ‚óã <id>: <title> [P<n>] (blocked by above)\n     ‚úì <id>: <title> (closed)\n\n   Proceeding with: <selected-task-id>\n   ```\n\n4. Continue with the selected child task\n\n**Once a regular task is selected**, claim it:\n```bash\nbd show <id>                           # Display full task details\nbd update <id> --status=in_progress    # Claim the task\nbd comments add <id> \"PHASE: COOK\nStatus: started\"\n```\n\n### Step 1.5: Check for Review Findings (Rework Mode)\n\nCheck if this task has previous review findings:\n\n```bash\nbd comments list <id> | grep -A 20 \"PHASE: SERVE\"\n```\n\n**If review findings exist (NEEDS_CHANGES):**\n1. Load the findings from the serve comment\n2. Add findings to TodoWrite as items to address\n3. Prioritize fixing these before new work\n\n**Output in rework mode:**\n```\nREWORK MODE: <id> - <title>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nPrevious review found issues to address:\n  - [major] <issue 1>\n  - [minor] <issue 2>\n\nAddressing review findings first.\n```\n\n**If no review findings:** Continue normally with Step 2.\n\n### Step 2: Load Recipe\n\nLoad the task details (the recipe):\n\n```bash\nbd show <id>\n```\n\nReview the task description, acceptance criteria, and any dependencies. This is the recipe for what will be cooked.\n\n### Step 3: Load Ingredients\n\nLoad relevant context files and documentation (the ingredients):\n\n1. **Project structure** - Understand codebase layout\n2. **Kitchen manual** - Review AGENTS.md for conventions\n3. **Related code** - Read files relevant to the task\n4. **Dependencies** - Check what this task builds on\n\nUse Read, Glob, and Grep tools to gather necessary context before starting implementation.\n\n### Step 4: Plan the Task\n\nBreak the task into steps using TodoWrite:\n\n1. Read the task description carefully\n2. Identify all deliverables\n3. Add steps to TodoWrite before starting\n4. Include verification steps (test, compile, etc.)\n\nFor complex tasks, use explore-plan-code workflow or ask clarifying questions.\n\n### Step 5: Execute TDD Cycle\n\nProcess TodoWrite items systematically with TDD guardrails:\n\n- Mark items `in_progress` when starting\n- Mark items `completed` immediately when done\n- Only one item should be `in_progress` at a time\n\n**For code changes, follow TDD cycle:**\n\n1. **RED**: Write failing test\n    ```bash\n    <test command>  # e.g., pytest, go test, npm test\n    # Should FAIL\n    ```\n\n    **Automatic test quality review (CRITICAL):**\n    ```\n    Use Task tool to invoke taster subagent:\n    Task(description=\"Review test code for quality\", prompt=\"Review test code for <package> for quality, checking:\n    - Tests are isolated, fast, repeatable\n    - Clear test names and error messages\n    - Proper structure (Setup-Execute-Validate-Cleanup)\n    - No anti-patterns\n\n    Report any critical issues that must be addressed before proceeding.\", subagent_type=\"taster\")\n    ```\n\n    **Address critical issues before GREEN phase.** The taster agent will:\n    - Verify tests are isolated, fast, repeatable\n    - Check for clear test names and error messages\n    - Ensure proper structure (Setup-Execute-Validate-Cleanup)\n    - Identify anti-patterns\n    - Provide critical issue blocking if needed\n\n2. **GREEN**: Implement minimal code\n   ```bash\n   <implementation>\n   <test command>\n   # Should PASS\n   ```\n\n3. **REFACTOR**: Clean up code\n   ```bash\n   <refactoring>\n   <test command>\n   # All tests should PASS\n   ```\n\n**Output format during execution:**\n```\nCOOKING: <id> - <title>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n[1/N] <todo item> ... ‚úì\n[2/N] <todo item> ... ‚úì\n[3/N] <todo item> ... in progress\n\nProgress: 2/N complete\n\nTDD Phase: RED/GREEN/REFACTOR\n```\n\n**Collecting findings:** As you execute, note (but do NOT file yet):\n- New tasks discovered\n- Potential issues or bugs\n- Areas for improvement\n\nThese will be filed as beads in `/line:tidy`.\n\n### Step 6: Verify Kitchen Equipment\n\nBefore marking the task done, verify ALL guardrails pass:\n\n- [ ] All TodoWrite items completed\n- [ ] Code compiles/runs without errors\n- [ ] Tests pass (if applicable)\n- [ ] Changes match task description\n\n**Kitchen equipment checklist** (MANDATORY):\n\n- [ ] All tests pass: `<test command>` (e.g., `go test ./...`, `pytest`, `npm test`)\n- [ ] Code builds: `<build command>` (e.g., `go build ./...`, `npm run build`)\n- [ ] Lint passes: `<lint command>` (if applicable, e.g., `npm run lint`)\n- [ ] Task deliverable complete\n- [ ] Code follows kitchen manual conventions\n\n**If any guardrail fails:**\n- Do NOT close the task\n- Report what's incomplete\n- Keep task as `in_progress`\n- Ask user how to proceed\n\n### Step 7: Complete Task\n\nOnly after all guardrails pass:\n\n```bash\nbd close <id>\nbd comments add <id> \"PHASE: COOK\nStatus: completed\n\nSEMANTIC CONTEXT (for tidy summary):\nIntent: <why this change was made, from task description>\nBefore: <previous state - what existed/didn't work>\nAfter: <new state - what's now possible/fixed>\n\nFiles: <count> changed\nFindings: <issues/improvements noted for tidy>\"\n```\n\n**Completion output format:**\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  KITCHEN COMPLETE                                            ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nTask: <id> - <title>\nTests: ‚úì All passing\nBuild: ‚úì Successful\n\nSignal: KITCHEN_COMPLETE\n\nINTENT:\n  <1-2 sentences from task description>\n  Goal: <deliverable or acceptance criteria>\n\nBEFORE ‚Üí AFTER:\n  <previous state> ‚Üí <new state>\n  <what couldn't be done> ‚Üí <what can be done now>\n\nFiles changed:\n  M src/foo.ts\n  A src/bar.ts\n\nVerification:\n  [‚úì] All todos complete\n  [‚úì] Code compiles\n  [‚úì] Tests pass\n\nFindings (to file in /tidy):\n  New tasks:\n    - \"Add support for edge case X\"\n  Potential issues:\n    - \"Error handling in Y could be improved\"\n  Improvements:\n    - \"Consider refactoring Z for clarity\"\n\nNEXT STEP: /line:serve (review) or /line:tidy (commit)\n```\n\n## Guardrails (Critical)\n\n1. **No silent failures** - If something breaks, report it clearly\n2. **No premature completion** - Task stays open until verification passes\n3. **No scope creep** - Stay focused on the specific task\n4. **Note, don't file** - Discovered issues are noted for `/line:tidy`, not filed during cook\n\n## Error Handling\n\nIf execution is blocked:\n```\n‚ö†Ô∏è KITCHEN BLOCKED: <description>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReason: <why it failed>\nProgress: <what was completed>\n\nOptions:\n  1. <recovery option>\n  2. <alternative>\n\nTask remains in_progress. Run /line:tidy to save partial progress.\n```\n\n## Example Usage\n\n```\n/line:cook              # Pick highest priority ready task\n/line:cook lc-042       # Execute specific task\n```\n",
        "commands/getting-started.md": "---\ndescription: Workflow guide with full bead reference\nallowed-tools: Bash, Read\n---\n\n**Output this guide to the user.** Do not act on it - display it for reference.\n\n---\n\n## line-cook Workflow Guide\n\nThis guide explains the line-cook workflow and provides a complete reference for beads (issue tracking).\n\n## The Workflow Loop\n\n```\n/line:prep  ‚Üí  /line:cook  ‚Üí  /line:serve  ‚Üí  /line:tidy\n    ‚Üì              ‚Üì              ‚Üì              ‚Üì\n  sync          execute        review         commit\n```\n\nOr use `/line:run` to run the full cycle.\n\n### /line:prep - \"What's ready?\"\n- Syncs git and beads\n- Shows available tasks\n- Identifies the next recommended task\n\n### /line:cook - \"Execute the task\"\n- Claims a task\n- Plans and executes the task\n- Notes discovered issues for later (doesn't file beads yet)\n- Closes the task when done\n\n### /line:serve - \"Review changes\"\n- Invokes headless Claude for peer review\n- Auto-fixes minor issues\n- Categorizes findings for /tidy\n\n### /line:tidy - \"Commit and capture\"\n- Files discovered issues as beads\n- Commits changes\n- Pushes to remote\n- Records session summary\n\n## Workflow Principles\n\n1. **Sync before starting** - Always start with current state\n2. **Track with beads** - Strategic tasks live in issue tracker\n3. **Note, then file** - Discovered issues are noted in /cook, filed in /tidy\n4. **Guardrails on completion** - Verify before marking done\n5. **Push before stop** - Session isn't done until pushed\n\n---\n\n## Bead Reference\n\nBeads is the git-native issue tracker. Here's the complete reference.\n\n### Creating Issues\n\n```bash\nbd create --title=\"...\" --type=task|bug|feature --priority=0-4\n\n# Priority levels:\n#   0 = P0 = critical (production down)\n#   1 = P1 = high (blocking)\n#   2 = P2 = medium (normal priority)\n#   3 = P3 = low (when time permits)\n#   4 = P4 = backlog (someday/maybe)\n\n# Types:\n#   task    = work item\n#   bug     = broken behavior\n#   feature = new capability\n#   epic    = container for related tasks\n```\n\n### Epics and Children\n\n```bash\n# Create an epic\nbd create --title=\"Parent epic\" --type=epic --priority=2\n\n# Create child tasks\nbd create --title=\"Child task\" --type=task --parent=<epic-id>\n```\n\n### Dependencies\n\nDependencies express \"A depends on B\" (B blocks A):\n\n```bash\nbd dep add <issue-a> <depends-on-b>\n\n# Example: Tests depend on implementation\nbd dep add beads-002 beads-001  # 002 waits for 001 to complete\n```\n\n### Key Fields\n\n```bash\n--assignee=<user>     # Who owns this\n--description=\"...\"   # Detailed context\n--labels=a,b,c        # Categorization tags\n```\n\n### Workflow Commands\n\n```bash\n# Finding tasks\nbd ready                      # Tasks with no blockers\nbd list --status=open         # All open issues\nbd list --status=in_progress  # Active tasks\nbd blocked                    # Tasks with unmet dependencies\n\n# Managing issues\nbd show <id>                           # View details\nbd update <id> --status=in_progress    # Claim task\nbd comments add <id> \"progress note\"   # Add context\nbd close <id>                          # Mark done\n\n# Sync and collaboration\nbd sync                # Push/pull with remote\nbd stats               # Project statistics\n```\n\n### Retrospective Pattern\n\nFor minor suggestions and improvements, use a retrospective epic:\n\n```bash\n# One-time setup\nbd create --title=\"Retrospective\" --type=epic --priority=4\n\n# File minor items as children\nbd create --title=\"Consider refactoring X\" --type=task --priority=4 --parent=<retro-epic-id>\n```\n\nThis keeps the main backlog focused on real tasks while preserving good ideas for later review.\n\n---\n\n## Quick Start\n\n1. Run `/line:prep` to see ready tasks\n2. Run `/line:cook` to execute the top task\n3. Run `/line:tidy` when done to commit and push\n\nOr just run `/line:run` for the full cycle.\n",
        "commands/mise.md": "---\ndescription: Create work breakdown before starting implementation\nallowed-tools: Bash, Write, Read\n---\n\n## Summary\n\n**Create human-readable work breakdown using tracer methodology.** Prep step before creating beads.\n\n**STOP after creating menu plan.** Wait for user approval before converting to beads.\n\n---\n\n## Process\n\n### Step 1: Understand the Order\n\nAsk clarifying questions:\n\n**What are we building?**\n- What problem are we solving?\n- What does success look like?\n- Who is the user?\n\n**What are the constraints?**\n- Are there technical constraints?\n- Time constraints (MVP vs full feature)?\n- Dependencies on other work?\n\n**What's the scope?**\n- MVP (minimum viable product)\n- Full feature\n- Multi-session epic\n\n**Ask questions if unclear.** Don't assume.\n\n### Step 2: Create Menu Plan (Task Graph)\n\nBuild a structured breakdown in YAML format for easy conversion to beads.\n\n**Why YAML?**\n- Human-readable and easy to edit\n- Machine-parseable for automated bead creation\n- Version controlled and reviewable\n- Can iterate quickly before creating beads\n\n**Create `docs/planning/menu-plan.yaml`:**\n\n```yaml\nphases:\n  - id: phase-1\n    title: \"Phase 1: Foundation\"\n    description: \"Core infrastructure for tmux integration and worktrees\"\n    duration: \"Week 1 (4-6 sessions)\"\n    \n    features:\n      - id: feature-1.1\n        title: \"Feature 1.1: Execute commands in tmux sessions\"\n        priority: 2\n        user_story: \"As a capsule orchestrator, I want to execute commands in tmux sessions so that I can programmatic control OpenCode TUI\"\n        acceptance_criteria:\n          - \"Can create/destroy tmux sessions\"\n          - \"Can send commands with proper debouncing\"\n          - \"Can capture session output\"\n        tracer_strategy:\n          minimal_flow: \"Create session ‚Üí Send command ‚Üí Capture output ‚Üí Destroy\"\n          layers: \"Tmux wrapper ‚Üí Command execution ‚Üí Output capture\"\n          expansion: \"Window management, pane splitting (deferred)\"\n        \n        tasks:\n          - title: \"Port tmux wrapper from gastown\"\n            priority: 1\n            tracer: \"Foundation layer - proves tmux integration works\"\n            description: |\n              - Copy internal/tmux/tmux.go structure\n              - Adapt for Capsule needs\n            deliverable: \"internal/tmux/tmux.go skeleton\"\n            reference: \"~/code/gastown/internal/tmux/tmux.go\"\n            tdd: true\n          \n          - title: \"Implement session creation/destruction\"\n            priority: 1\n            depends_on: [\"Port tmux wrapper from gastown\"]\n            tracer: \"Session lifecycle - proves basic management works\"\n            description: |\n              - NewSession(name, workDir) function\n              - KillSession(name) function\n              - SessionExists(name) check\n            deliverable: \"Session management with tests\"\n            tdd: true\n          \n          - title: \"Implement command execution\"\n            priority: 1\n            depends_on: [\"Implement session creation/destruction\"]\n            tracer: \"Command execution - proves sending commands works\"\n            description: |\n              - SendCommand(session, command) function\n              - Wait for completion with timeout\n              - Capture stdout/stderr\n            deliverable: \"Command execution with tests\"\n            tdd: true\n```\n\n**See `docs/planning/menu-plan-format.md` for complete format reference.**\n\n### Step 3: Add Feature Dependencies (Sequential Features)\n\nAdd `blocks` field to enforce sequential feature completion:\n\n```yaml\nfeatures:\n  - id: feature-2.1\n    title: \"Feature 2.1: Run missions in isolated worktrees\"\n    blocks: [\"feature-1.2\"]  # This feature blocks Feature 1.2\n    # ...\n  \n  - id: feature-1.2\n    title: \"Feature 1.2: Basic CLI structure\"\n    blocks: [\"feature-3.1\"]  # This feature blocks Feature 3.1\n    # ...\n```\n\n**Why sequential?**\n- Maintains focus on one feature at a time\n- Prevents context switching\n- Ensures features are fully complete before moving on\n\n### Step 4: Plan BDD Tests for Features\n\n**Every feature must include BDD tests** that validate acceptance criteria from the user's perspective.\n\n**Define BDD test plan:**\n\n```yaml\nfeatures:\n  - id: feature-2.1\n    title: \"Feature 2.1: Run missions in isolated worktrees\"\n    user_story: \"As a capsule orchestrator, I want to run missions in isolated git worktrees so that I can execute multiple missions in parallel without workspace conflicts\"\n    acceptance_criteria:\n      - \"Can create worktree with unique name\"\n      - \"Worktree on new branch\"\n      - \"Changes don't affect main workspace\"\n      - \"Clean removal of worktrees\"\n    bdd_tests:\n      - test: \"TestFeature_RunMissionsInIsolatedWorktrees\"\n        scenarios:\n          - \"Acceptance_Criterion_1_Create_worktree_with_unique_name\"\n          - \"Acceptance_Criterion_2_Worktree_on_new_branch\"\n          - \"Acceptance_Criterion_3_Changes_dont_affect_main_workspace\"\n          - \"Acceptance_Criterion_4_Clean_removal_of_worktrees\"\n      - test: \"TestFeature_ParallelMissionIsolation\"\n        scenarios:\n          - \"Multiple missions run independently\"\n    smoke_tests:  # CLI validation - REQUIRED for user-facing features\n      - \"capsule launch creates worktree\"\n      - \"capsule dock removes worktree cleanly\"\n```\n\n**BDD Test Structure:**\n- File: `internal/<package>/integration_test.go`\n- Format: Given-When-Then comments\n- Naming: `TestFeature_<FeatureName>`\n- Subtests: Map to acceptance criteria\n- Real operations: Use actual git/tmux/system calls\n\n**Smoke Test Structure:**\n- File: `scripts/smoke-test-<feature>.sh` or `cmd/smoke-test/`\n- Tests: Real CLI commands with expected outputs\n- **Every feature must have smoke tests** (features are user-facing by definition)\n- Validates: End-to-end user experience\n\n**If you can't write smoke tests, it's not a feature** - it's infrastructure that should be tasks under a user-facing feature.\n\n### Step 5: Output Menu Plan Summary\n\nAfter creating the menu plan, output:\n\n```\nMENU PLAN CREATED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFile: docs/planning/menu-plan.yaml\n\nPhases: <N>\nFeatures: <M>\nCourses (tasks): <L>\n\nBreakdown:\n  Phase 1: <title> (<X> sessions)\n    - Feature 1.1: <title>\n      - <N> courses\n    - Feature 1.2: <title>\n      - <N> courses\n  ...\n\nTracer Strategy:\n  Feature 1.1:\n    Minimal flow: <flow description>\n    Layers: <layers>\n    Expansion: <deferred items>\n\nREVIEW THE PLAN:\n  1. Check hierarchy makes sense\n  2. Verify each feature has:\n     ‚úì User story\n     ‚úì Acceptance criteria (3-5)\n     ‚úì BDD test plan\n     ‚úì Smoke test plan (CLI)\n  3. Verify each course has:\n     ‚úì Tracer explanation\n     ‚úì Clear deliverable\n     ‚úì Dependencies listed\n\nNEXT STEP: Run /line:cook to convert menu plan to beads\n  (Review plan first, modify if needed, then convert)\n```\n\n### Step 6: Convert Menu Plan to Beads\n\n**ONLY convert after user approves the menu plan.**\n\nRun the conversion script:\n\n```bash\n./scripts/menu-plan-to-beads.sh docs/planning/menu-plan.yaml\n```\n\n**Script will:**\n- Create epics (phases)\n- Create features with acceptance criteria\n- Create tasks with descriptions and deliverables\n- Add task dependencies (depends_on)\n- Add feature dependencies (blocks)\n\n**Or create beads manually:**\n```bash\nbd create --title=\"Phase 1: Foundation\" --type=epic --priority=2\nbd create --title=\"Feature 1.1: Execute commands in tmux sessions\" --type=feature --parent=lc-abc --priority=3\nbd create --title=\"Port tmux wrapper from gastown\" --parent=lc-abc.1 --priority=1\nbd dep add <new-task-id> <dependency-task-id>\n```\n\n### Step 7: Verify Beads and Dependencies\n\nCheck that beads were created correctly and dependencies are enforced:\n\n```bash\nbd list              # See all beads\nbd list -t epic      # See only epics\nbd list -t feature   # See only features\nbd ready             # See available work (should be focused on one feature)\nbd blocked           # See blocked features\nbd show <epic-id>    # View epic with child features\nbd show <feature-id> # View feature with child tasks\n```\n\n**Verify hierarchy:**\n```bash\n# Check epic structure\nbd show <epic-id>\n# Should show:\n#   Epic: Phase 1: Foundation\n#   Children:\n#     - Feature 1.1: Execute commands in tmux sessions\n#     - Feature 1.2: Manage git worktrees\n\n# Check feature structure  \nbd show <feature-id>\n# Should show:\n#   Feature: 1.1: Execute commands in tmux sessions\n#   Parent: Phase 1: Foundation\n#   Children:\n#     - Course: Port tmux wrapper from gastown\n#     - Course: Implement session creation/destruction\n```\n\n**Verify dependencies:**\n```bash\nbd ready\n# Should only show courses from the current feature (not blocked)\n\nbd blocked\n# Should show features blocked by dependencies\n```\n\n### Step 8: Sync and Commit\n\n```bash\nbd sync\ngit add docs/planning/menu-plan.yaml .beads/\ngit commit -m \"plan: Create menu plan for <phase>\n\n- <N> phases planned\n- <M> features with acceptance criteria\n- <L> courses (tasks) with tracer strategy\n\nKey features:\n- Feature 1.1: <title>\n- Feature 1.2: <title>\n\nTracer approach:\n- Each course builds foundation for next\n- Vertical slices through all layers\n- Production quality from start\"\ngit push\n```\n\n---\n\n## Hierarchy Structure\n\n**Three-tier hierarchy:**\n\n```\nEpic (Phase)\n‚îú‚îÄ‚îÄ Feature 1 (User-observable outcome)\n‚îÇ   ‚îú‚îÄ‚îÄ Course 1.1 (Implementation step)\n‚îÇ   ‚îú‚îÄ‚îÄ Course 1.2 (Implementation step)\n‚îÇ   ‚îî‚îÄ‚îÄ Course 1.3 (Implementation step)\n‚îî‚îÄ‚îÄ Feature 2 (User-observable outcome)\n    ‚îú‚îÄ‚îÄ Course 2.1 (Implementation step)\n    ‚îî‚îÄ‚îÄ Course 2.2 (Implementation step)\n```\n\n**Mapping:**\n- **Epic** = Phase (3+ sessions, multiple features)\n- **Feature** = User-observable capability (1-3 sessions, multiple courses)\n- **Course (Task)** = Single implementation unit (< 2 hours, one tracer)\n\n---\n\n## CRITICAL: Features Must Be User-Facing\n\nA feature MUST have a user interface (CLI, API, or UI) that allows users to exercise the capability. If there's no way for users to interact with it, it's not a feature - it's infrastructure that belongs as courses under a real feature.\n\n**‚ùå Wrong - \"Internal feature\" with no user interface:**\n```\nEpic: Phase 1: Foundation\n‚îú‚îÄ‚îÄ Feature 1.1: Execute commands in tmux sessions\n‚îÇ   ‚îú‚îÄ‚îÄ Course: Implement session creation\n‚îÇ   ‚îú‚îÄ‚îÄ Course: Implement command execution\n‚îÇ   ‚îî‚îÄ‚îÄ Course: Add smoke tests ‚úÖ (CLI testable)\n‚îî‚îÄ‚îÄ Feature 1.2: Manage git worktrees ‚ùå (No CLI - not a feature!)\n    ‚îú‚îÄ‚îÄ Course: Implement worktree creation\n    ‚îú‚îÄ‚îÄ Course: Implement worktree cleanup\n    ‚îî‚îÄ‚îÄ Course: ??? (No smoke tests - nothing to test!)\n```\n\n**‚úÖ Correct - Infrastructure as courses under user-facing feature:**\n```\nEpic: Phase 1: Foundation\n‚îî‚îÄ‚îÄ Feature 1.1: Launch missions in isolated environments\n    ‚îú‚îÄ‚îÄ Course: Implement tmux session wrapper\n    ‚îú‚îÄ‚îÄ Course: Implement worktree manager\n    ‚îú‚îÄ‚îÄ Course: Implement launch command\n    ‚îú‚îÄ‚îÄ Course: Add bead integration\n    ‚îî‚îÄ‚îÄ Course: Add smoke tests (validates entire flow)\n```\n\n**‚úÖ Also correct - Split if features are independently useful:**\n```\nEpic: Phase 1: Foundation\n‚îú‚îÄ‚îÄ Feature 1.1: Execute commands in tmux sessions\n‚îÇ   ‚îú‚îÄ‚îÄ Course: Implement session management\n‚îÇ   ‚îú‚îÄ‚îÄ Course: Implement command execution\n‚îÇ   ‚îú‚îÄ‚îÄ Course: Add tmux CLI wrapper\n‚îÇ   ‚îî‚îÄ‚îÄ Course: Add smoke tests (capsule tmux create/send/capture)\n‚îî‚îÄ‚îÄ Feature 1.2: Launch missions in isolated worktrees\n    ‚îú‚îÄ‚îÄ Course: Implement worktree manager\n    ‚îú‚îÄ‚îÄ Course: Implement launch command\n    ‚îú‚îÄ‚îÄ Course: Integrate tmux + worktrees\n    ‚îî‚îÄ‚îÄ Course: Add smoke tests (capsule launch/status/dock)\n```\n\n**Test for valid feature:**\n- ‚úÖ Can a user invoke this via CLI/API/UI?\n- ‚úÖ Can you write smoke tests that exercise it?\n- ‚úÖ Would a user understand what this does?\n- ‚ùå Is this just infrastructure for another feature?\n\n**Examples:**\n\n| Description | Valid Feature? | Why |\n|-------------|----------------|-----|\n| \"Launch missions from beads\" | ‚úÖ Yes | User runs `capsule launch <id>` |\n| \"Manage git worktrees\" | ‚ùå No | No CLI - just infrastructure |\n| \"Monitor mission progress\" | ‚úÖ Yes | User runs `capsule status <id>` |\n| \"Implement state machine\" | ‚ùå No | Internal detail of a feature |\n| \"Add authentication\" | ‚úÖ Yes | User provides API key, gets auth'd |\n| \"Port tmux wrapper\" | ‚ùå No | Infrastructure unless exposed via CLI |\n\n---\n\n## Tracer Dish Approach\n\n**Build vertical slices through all system layers, then expand incrementally.**\n\n**Key principle**: Each course is a mini-tracer that:\n- Implements one focused capability end-to-end\n- Touches relevant architectural layers\n- Provides foundation for next course\n- Is production-quality (not throwaway)\n\n**Example - Feature broken into tracer courses:**\n\n```markdown\nFeature 3.1: Launch missions from beads\n\nCourse 1: Define mission struct and state machine\n  ‚Üí Tracer: Data layer foundation\n  ‚Üí Proves: State management approach works\n\nCourse 2: Implement bead integration  \n  ‚Üí Tracer: External interface layer\n  ‚Üí Proves: Can read/update bead status\n\nCourse 3: Implement launch command\n  ‚Üí Tracer: Orchestration layer\n  ‚Üí Proves: End-to-end flow works (CLI ‚Üí Mission ‚Üí Worktree ‚Üí Tmux ‚Üí Bead)\n```\n\nEach course builds on the previous, creating a complete vertical slice.\n\n---\n\n## Course Sizing Guidelines\n\n**Use tracer bullet thinking** - each course should be a vertical slice through relevant layers.\n\n**Too Small** (combine into one tracer):\n- \"Add import statement\"\n- \"Create empty file\"  \n- \"Update comment\"\n\n**Just Right** (single tracer, one session):\n- \"Define mission struct and state machine\" (data layer)\n- \"Implement bead integration\" (external interface layer)\n- \"Implement launch command\" (orchestration layer)\n\n**Too Large** (break into multiple tracers):\n- \"Implement entire mission lifecycle\" ‚Üí Break into: state machine, launch, monitor, dock\n- \"Add all monitoring features\" ‚Üí Break into: capture, detect, log, report\n- \"Complete Phase 1\" ‚Üí Break into individual features\n\n---\n\n## Common Mistakes to Avoid\n\n‚ùå **Creating beads directly**: Hard to review, edit, and discuss\n‚úÖ **Menu plan first**: Easy to review and iterate\n\n‚ùå **Too vague**: \"Implement monitoring\"  \n‚úÖ **Specific tracer**: \"Implement output capture loop with 5s interval\"\n\n‚ùå **Too large**: \"Complete Phase 1\"\n‚úÖ **Sized right**: \"Define mission struct and state machine\"\n\n‚ùå **No deliverable**: \"Research tmux\"\n‚úÖ **Clear outcome**: \"Document tmux patterns in RESEARCH.md\"\n\n‚ùå **Horizontal slicing**: \"Build entire UI layer\"\n‚úÖ **Vertical slicing**: \"Implement launch command (CLI ‚Üí Mission ‚Üí Tmux)\"\n\n‚ùå **No tracer strategy**: Courses in random order\n‚úÖ **Tracer sequence**: Foundation ‚Üí Integration ‚Üí Orchestration\n\n‚ùå **Prototype thinking**: \"Quick and dirty, we'll rewrite later\"\n‚úÖ **Tracer thinking**: \"Production quality, minimal scope, expand incrementally\"\n\n‚ùå **\"Internal features\" with no CLI**: \"Feature: Manage worktrees\" (no user interface)\n‚úÖ **User-facing features only**: \"Feature: Launch missions in isolated worktrees\" (has `capsule launch`)\n\n‚ùå **Features without smoke tests**: If you can't smoke test it, it's not a feature\n‚úÖ **Every feature has smoke tests**: Validates end-to-end user experience\n\n---\n\n## Example Output\n\n**Menu plan created:**\n\n```\nMENU PLAN CREATED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFile: docs/planning/menu-plan.yaml\n\nPhases: 1\nFeatures: 2\nCourses: 5\n\nBreakdown:\n  Phase 1: Foundation (4-6 sessions)\n    - Feature 1.1: Execute commands in tmux sessions\n      - 3 courses\n    - Feature 1.2: Launch missions in isolated worktrees\n      - 2 courses\n\nTracer Strategy:\n  Feature 1.1:\n    Minimal flow: Create session ‚Üí Send command ‚Üí Capture output ‚Üí Destroy\n    Layers: Tmux wrapper ‚Üí Command execution ‚Üí Output capture\n    Expansion: Window management, pane splitting (deferred)\n\n  Feature 1.2:\n    Minimal flow: Read bead ‚Üí Create worktree ‚Üí Launch Tmux ‚Üí Update status\n    Layers: Bead API ‚Üí Worktree manager ‚Üí Tmux integration\n    Expansion: Parallel missions, monitoring (deferred)\n\nREVIEW THE PLAN:\n  1. Check hierarchy makes sense ‚úì\n  2. Verify each feature has:\n     ‚úì User story\n     ‚úì Acceptance criteria (3-5)\n     ‚úì BDD test plan\n     ‚úì Smoke test plan (CLI)\n  3. Verify each course has:\n     ‚úì Tracer explanation\n     ‚úì Clear deliverable\n     ‚úì Dependencies listed\n\nNEXT STEP: Run /line:prep to convert menu plan to beads\n  (Review plan first, modify if needed, then convert)\n```\n\n---\n\n## Example Usage\n\n```\n/line:mise\n```\n\nThis command takes no arguments. It will:\n1. Ask clarifying questions about what you're building\n2. Create a YAML menu plan in `docs/planning/menu-plan.yaml`\n3. Output summary for review\n4. Wait for user to convert to beads\n\nTo convert plan to beads:\n```bash\n./scripts/menu-plan-to-beads.sh docs/planning/menu-plan.yaml\n```\n",
        "commands/plate.md": "---\ndescription: Validate completed feature and create acceptance documentation\nallowed-tools: Bash, Read, Write, Edit, Glob, Grep, Task, TodoWrite\n---\n\n## Summary\n\n**Validate completed features and create acceptance documentation.** Final step before feature completion.\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Identify Feature to Validate\n\nSelect the feature to validate:\n\n```bash\n# Option 1: Use argument\n/plate <feature-id>\n\n# Option 2: Find recently completed features\nbd list --status=closed --type=feature --limit=5\n```\n\n**Important:** Only run plate phase on fully completed features (all child tasks closed).\n\n### Step 2: Run Feature Validation\n\nExecute tests to verify feature works end-to-end:\n\n```bash\n# Run all tests\ngo test ./...\n\n# Run feature-specific BDD tests\ngo test ./internal/<package> -run TestFeature -v\n\n# Run smoke tests if available\n./scripts/smoke-test-<feature>.sh\n```\n\n**If tests fail:**\n- Investigate and fix issues\n- Re-run tests\n- Do NOT proceed with plate phase until tests pass\n\n### Step 3: Review BDD Test Quality with Sommelier\n\nDelegate BDD test quality review to ma√Ætre subagent:\n\n```\nUse Task tool to invoke ma√Ætre subagent:\nTask(description=\"Review feature test quality\", prompt=\"Review BDD tests for feature <feature-id>\n\nFeature: <feature-title>\nAcceptance criteria:\n- <criteria 1>\n- <criteria 2>\n- <criteria 3>\n\nVerify:\n- All acceptance criteria have tests\n- Given-When-Then structure used\n- Tests map to acceptance criteria\n- User perspective documented\n- Error scenarios included\n\nReport any critical issues before proceeding with plate phase.\", subagent_type=\"maitre\")\n```\n\n**Wait for BDD quality assessment.**\n\n**If critical issues found:**\n- Address issues\n- Re-run BDD review\n- Do NOT proceed until quality bar is met\n\n### Step 4: Create Feature Acceptance Documentation\n\nCreate acceptance documentation using the multi-course meal template:\n\n1. Copy the template to `docs/features/<feature-id>-acceptance.md`:\n   ```bash\n   mkdir -p docs/features\n   cp docs/templates/feature-acceptance.md docs/features/<feature-id>-acceptance.md\n   ```\n\n2. Fill in the template sections:\n   - **Chef's Selection** - User story from feature definition\n   - **Tasting Notes** - Map each acceptance criterion to verification evidence\n   - **Quality Checks** - Document BDD and smoke test results\n   - **Kitchen Staff Sign-Off** - Record agent approvals\n   - **Guest Experience** - Show users how to use the feature\n   - **Kitchen Notes** - Capture limitations, ideas, deployment info\n   - **Related Orders** - Link to completed tasks and related features\n\n3. Remove the \"Usage Instructions\" section from the filled template\n\nSee [`docs/templates/feature-acceptance.md`](../docs/templates/feature-acceptance.md) for the full template.\n\n### Step 5: Update CHANGELOG.md\n\nAdd feature to CHANGELOG.md:\n\n```markdown\n## [Unreleased]\n\n### Added\n- <feature-title> (<feature-id>)\n  - <summary of feature>\n  - <key capabilities delivered>\n```\n\n### Step 6: Close Feature Bead\n\nClose the feature bead to mark completion:\n\n```bash\nbd close <feature-id>\n```\n\n### Step 7: Commit and Push\n\nCommit acceptance documentation and CHANGELOG:\n\n```bash\ngit add docs/features/<feature-id>-acceptance.md CHANGELOG.md\ngit commit -m \"feat: complete <feature-title> (<feature-id>)\n\nFeature validation complete:\n- All acceptance criteria verified\n- BDD tests approved by ma√Ætre\n- Smoke tests passing\n\nAcceptance report: docs/features/<feature-id>-acceptance.md\"\n\nbd sync\ngit push\n```\n\n### Step 8: Output Summary\n\n```\nPLATE PHASE COMPLETE\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFeature: <id> - <title>\nStatus: ‚úÖ Validated and complete\n\nAcceptance Criteria:\n  [‚úì] <Criterion 1>\n  [‚úì] <Criterion 2>\n  [‚úì] <Criterion 3>\n\nQuality Assurance:\n  [‚úì] Tests passing\n  [‚úì] BDD tests approved (ma√Ætre)\n  [‚úì] Code review complete (sous-chef)\n\nDeliverables:\n  - Acceptance report: docs/features/<feature-id>-acceptance.md\n  - CHANGELOG.md updated\n  - Feature bead closed\n\nCommit: <hash>\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nNEXT STEP: Continue with next feature or task\n```\n\n## Error Handling\n\n### Tests Fail\n\n```\n‚ö†Ô∏è FEATURE VALIDATION FAILED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFeature: <id> - <title>\n\nIssue: <description of test failure>\n\nActions:\n  1. Fix the failing tests\n  2. Re-run: go test ./...\n  3. Retry /line:plate <feature-id>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n```\n\n### BDD Quality Issues\n\n```\n‚ö†Ô∏è BDD QUALITY ISSUES FOUND\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFeature: <id> - <title>\n\nCritical Issues:\n  - <Issue 1>\n  - <Issue 2>\n\nActions:\n  1. Address critical BDD issues\n  2. Re-run BDD review with ma√Ætre\n  3. Retry /line:plate <feature-id>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n```\n\n## Design Notes\n\nThe plate phase ensures features are production-ready before completion:\n\n1. **End-to-end validation** - All tests must pass\n2. **BDD quality** - Tests must meet quality bar (ma√Ætre review)\n3. **Documentation** - Acceptance report provides comprehensive record\n4. **Changelog** - Track feature delivery for users\n\n**When to run:**\n- After all child tasks for a feature are closed\n- Before closing the feature bead\n- During `/line:run` when feature completion is detected\n\n**Do NOT run on:**\n- Partially completed features (tasks still open)\n- Epics (use plate on individual features)\n- Tasks (only features have BDD tests)\n\n## Example Usage\n\n```\n/line:plate lc-abc.1  # Validate feature lc-abc.1\n```\n\nThis command takes a feature ID as argument. It will:\n1. Run tests to validate feature\n2. Review BDD test quality\n3. Create acceptance documentation\n4. Update CHANGELOG.md\n5. Close feature bead\n6. Commit and push\n",
        "commands/prep.md": "---\ndescription: Sync state, load context, show ready tasks\nallowed-tools: Bash, Read, Glob\n---\n\n## Summary\n\n**Sync state and identify ready tasks.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Sync State\n\nEnsure local state is current:\n\n```bash\ngit fetch origin\ngit pull --rebase\n```\n\nIf `.beads/` directory exists:\n```bash\nbd sync\n```\n\n### Step 2: Load Kitchen Manual\n\nLoad the work structure documentation:\n\n```bash\ncat AGENTS.md | head -100\n```\n\nThis loads kitchen terminology, agent definitions, and workflow principles.\n\n### Step 3: Gather Kitchen Roster\n\nGet project and branch info:\n```bash\npwd                           # Project directory\ngit branch --show-current     # Current branch\n```\n\nDisplay current task state:\n```bash\nbd ready                      # Available orders (no blockers)\nbd list --status=in_progress  # Active orders\nbd blocked                    # Blocked orders (for awareness)\n```\n\n### Step 4: Branching Strategy\n\nBefore selecting a task, check branching context:\n\n| Task Type | Branching | Rationale |\n|-----------|-----------|-----------|\n| **Feature** | Create branch: `git checkout -b feature/<feature-id>` | Multi-task work, isolation |\n| **Task** | Stay on main | Small, atomic changes |\n\nIf preparing to work on a feature (has `--type=feature`), create a feature branch first:\n```bash\nbd show <feature-id>  # Confirm it's a feature\ngit checkout -b feature/<feature-id>\n```\n\n### Step 5: Identify Next Task and Gather Context\n\nBefore outputting the summary, determine the recommended next task and its hierarchy:\n\n#### 5a: Find Next Ready Task\n\n1. Get the highest priority ready item from `bd ready`\n2. Check if it's an epic: `bd show <id> --json` and check `issue_type`\n\n**If the top item is an epic:**\n- Epics themselves don't contain work - their children do\n- Find the first ready child task: `bd list --parent=<epic-id>` filtered by ready (open + unblocked)\n- Recommend that child task instead\n\n**If no ready tasks but epics have unstarted children:**\n- Check epic children that are open but not blocked\n- Recommend starting with those\n\n#### 5b: Gather Parent Hierarchy\n\nOnce you have identified the next task, gather its parent chain:\n\n```bash\n# Get task details\nTASK_JSON=$(bd show <task-id> --json)\nPARENT_ID=$(echo $TASK_JSON | jq -r '.[0].parent // empty')\n\nif [ -n \"$PARENT_ID\" ]; then\n  # Get feature/parent info\n  FEATURE_JSON=$(bd show $PARENT_ID --json)\n\n  # Get sibling tasks for progress tracking\n  TOTAL_SIBLINGS=$(bd list --parent=$PARENT_ID | wc -l)\n  CLOSED_SIBLINGS=$(bd list --parent=$PARENT_ID --status=closed)\n\n  # Get epic info if feature has parent\n  EPIC_ID=$(echo $FEATURE_JSON | jq -r '.[0].parent // empty')\n  if [ -n \"$EPIC_ID\" ]; then\n    EPIC_JSON=$(bd show $EPIC_ID --json)\n    # Count epic's children for feature progress\n    TOTAL_FEATURES=$(bd list --parent=$EPIC_ID | wc -l)\n    CLOSED_FEATURES=$(bd list --parent=$EPIC_ID --status=closed | wc -l)\n  fi\nfi\n```\n\n#### 5c: Extract Task Intent\n\nParse the task description to extract:\n- **Summary**: First paragraph of description\n- **Deliverables**: Lines starting with \"Deliverable:\", \"Verify:\", or bullet points under those headers\n\n### Step 6: Output Kitchen Roster\n\nOutput a focused, scannable summary with hierarchical context:\n\n**Standard output (task with full hierarchy):**\n```\nSESSION: <project-name> @ <branch>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date | ‚ö†Ô∏è <issue>\n\nReady: <count> tasks | In progress: <count> | Blocked: <count>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nEPIC: <epic-id> [P<n>] <epic-title>\n  Goal: <first line of epic description>\n  Progress: <closed>/<total> features complete\n\n  ‚îî‚îÄ‚îÄ FEATURE: <feature-id> <feature-title>\n      Goal: <first line of feature description>\n      Progress: <closed>/<total> tasks complete\n\n      CURRENT STATE:\n        ‚úì <task-id> - <completed task title>\n        ‚úì <task-id> - <completed task title>\n        ... (list completed siblings)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n<task-id> [P<n>] <task-title>\n\nINTENDED CHANGE:\n  <first paragraph of task description>\n\n  Deliverable:\n    - <extracted deliverables from description>\n    - <bullet points or items after \"Deliverable:\" header>\n\nNEXT STEP: /line:cook <task-id>\n```\n\n**Standalone task (no parent hierarchy):**\n```\nSESSION: <project-name> @ <branch>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: <count> tasks | In progress: <count> | Blocked: <count>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n(Standalone task - no parent epic or feature)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n<task-id> [P<n>] <task-title>\n\nINTENDED CHANGE:\n  <first paragraph of task description>\n\nNEXT STEP: /line:cook <task-id>\n```\n\n**Feature without epic:**\n```\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nFEATURE: <feature-id> <feature-title>\n  Goal: <first line of feature description>\n  Progress: <closed>/<total> tasks complete\n\n  CURRENT STATE:\n    ‚úì <task-id> - <completed task title>\n    (or: no completed tasks yet)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n...\n```\n\n**No ready tasks:**\n```\nSESSION: <project-name> @ <branch>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: 0 tasks | In progress: <count> | Blocked: <count>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNO READY TASKS\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nIn Progress:\n  <id> - <title> (assigned to <assignee>)\n\nBlocked:\n  <id> - <title> (waiting on: <blocker-ids>)\n\nOPTIONS:\n  - Continue work on in-progress task\n  - Unblock a blocked task\n  - Create new work with: bd create --title=\"...\" --type=task\n\nNEXT STEP: Review options above\n```\n\n**Important:** Do NOT include bead command reference here. That information is available via `/line:getting-started` and `/line:tidy` (where it's actually needed).\n\n## Error Handling\n\nIf sync fails:\n```\n‚ö†Ô∏è SYNC FAILED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReason: <error message>\n\nOptions:\n  1. Resolve manually and run /line:prep again\n  2. Run /line:cook to proceed offline (will sync later)\n```\n\n## Example Output\n\n**Task with full hierarchy (epic ‚Üí feature ‚Üí task):**\n```\nSESSION: line-cook @ main\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: 4 tasks | In progress: 0 | Blocked: 2\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nEPIC: lc-abc [P2] Phase 1: Core Workflow Enhancement\n  Goal: Enhance existing commands with TDD cycle and quality gates\n  Progress: 2/3 features complete\n\n  ‚îî‚îÄ‚îÄ FEATURE: lc-abc.1 Core Command Enhancement\n      Goal: Update prep, cook, serve, tidy with TDD workflow\n      Progress: 3/5 tasks complete\n\n      CURRENT STATE:\n        ‚úì lc-abc.1.1 - Update prep command\n        ‚úì lc-abc.1.2 - Update cook command\n        ‚úì lc-abc.1.3 - Update serve command\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nlc-abc.1.4 [P2] Update tidy command with commit formatting\n\nINTENDED CHANGE:\n  Add kitchen log format to commit messages and ensure\n  findings from cook phase are filed as beads.\n\n  Deliverable:\n    - Commit messages use kitchen log format\n    - Findings converted to beads\n    - Push verification before session end\n\nNEXT STEP: /line:cook lc-abc.1.4\n```\n\n**Standalone task:**\n```\nSESSION: line-cook @ main\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: 2 tasks | In progress: 0 | Blocked: 0\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n(Standalone task - no parent epic or feature)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nlc-042 [P1] Fix sync timeout issue\n\nINTENDED CHANGE:\n  Increase timeout for bd sync to handle large repos.\n\nNEXT STEP: /line:cook lc-042\n```\n\n## Example Usage\n\n```\n/line:prep\n```\n\nThis command takes no arguments.\n",
        "commands/run.md": "---\ndescription: Run full workflow cycle (prep‚Üícook‚Üíserve‚Üítidy)\nallowed-tools: Bash, Read, Write, Edit, Glob, Grep, Task, TodoWrite, AskUserQuestion, Skill\n---\n\n## Summary\n\n**Expeditor orchestrates full workflow: prep ‚Üí cook ‚Üí serve ‚Üí tidy ‚Üí plate.** Primary entry point for focused work sessions.\n\n**Expeditor responsibilities:**\n- Run prep checks and present ready tasks\n- Delegate cooking to chef subagent\n- Coordinate serving with sous-chef review\n- Manage tidy phase (commit, push)\n- Trigger plate phase for feature completion\n- Handle failure conditions and coordinate recovery\n\n**Arguments:** `$ARGUMENTS` (optional) - Specific task ID to work on (passed to cook)\n\n---\n\n## Process\n\n### Step 1: Run /prep\n\nInvoke the prep command to sync state and identify available work:\n\n```\nSkill(skill=\"line:prep\")\n```\n\nWait for prep to complete.\n\n### Step 2: Run /cook\n\nInvoke the cook command to execute work:\n\n**If `$ARGUMENTS` provided:**\n```\nSkill(skill=\"line:cook\", args=\"$ARGUMENTS\")\n```\n\n**Otherwise:**\n```\nSkill(skill=\"line:cook\")\n```\n\nWait for cook to complete. Cook will select a task, execute the work, and output findings for tidy.\n\n### Step 3: Run /serve\n\nInvoke the serve command for peer review:\n\n```\nSkill(skill=\"line:serve\")\n```\n\nWait for review to complete. Serve will invoke sous-chef subagent for code review and categorize any issues found.\n\n### Step 4: Run /tidy\n\nInvoke tidy to file discovered work, commit, and push:\n\n```\nSkill(skill=\"line:tidy\")\n```\n\nTidy will file beads for discovered work, commit all changes, sync beads, and push to remote.\n\n### Step 5: Check for Plate Phase (Feature Completion)\n\nAfter tidying, check if the task completed a feature:\n\n```bash\n# Get task details to check parent\nbd show <task-id>\n```\n\n**If task has a parent feature AND all sibling tasks are closed:**\n\n1. Run feature validation:\n   ```bash\n   go test ./...\n   go test ./internal/<package> -run TestFeature -v\n   ```\n\n2. Delegate to ma√Ætre (BDD quality) subagent:\n   ```\n   Use Task tool to invoke ma√Ætre subagent:\n   Task(description=\"Review feature test quality\", prompt=\"Review BDD tests for feature <feature-id>\n\n   Feature: <feature-title>\n   Acceptance criteria:\n   - <criteria 1>\n   - <criteria 2>\n   - <criteria 3>\n\n   Verify:\n   - All acceptance criteria have tests\n   - Given-When-Then structure used\n   - Tests map to acceptance criteria\n   - User perspective documented\n   - Error scenarios included\n\n   Report any critical issues before proceeding with plate phase.\", subagent_type=\"maitre\")\n   ```\n\n3. Wait for BDD quality assessment. Address any critical issues.\n\n4. If BDD tests pass quality bar, proceed with plate phase:\n   - Create feature acceptance documentation\n   - Update CHANGELOG.md\n   - Close feature bead\n   - Commit and push feature report\n\n**If no feature completed, skip plate phase and proceed to Step 6.**\n\n### Step 6: Cycle Summary\n\nAfter all steps complete, output summary derived from /tidy:\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  FULL SERVICE COMPLETE                                       ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nWORK CYCLE: Complete\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n[1/5] PREP    ‚úì synced\n[2/5] COOK    ‚úì executed\n[3/5] SERVE   ‚úì reviewed (<verdict>)\n[4/5] TIDY    ‚úì committed, pushed\n[5/5] PLATE ‚úì (feature complete) | (not applicable)\n\nQuality Gates:\n  [‚úì] Test quality approved (taster)\n  [‚úì] Code quality approved (sous-chef)\n  [‚úì] BDD tests approved (ma√Ætre, if applicable)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nTASK: <id> - <title>\n\nINTENT:\n  <1-2 sentences from task description>\n  Goal: <deliverable or acceptance criteria>\n\nBEFORE ‚Üí AFTER:\n  <previous state> ‚Üí <new state>\n  <what couldn't be done> ‚Üí <what can be done now>\n\nFiles: <count> changed\nCommit: <hash>\nIssues filed: <count>\n```\n\n## Error Handling\n\nIf any step fails:\n\n1. **Prep fails** - Report sync error, stop workflow\n2. **Cook fails** - Report what went wrong, offer to continue to tidy (to save progress)\n3. **Serve fails** - Note review was skipped, continue to tidy\n4. **Tidy fails** - Report push error, create bead for follow-up\n5. **Plate fails** - Note feature validation incomplete, create bead for follow-up\n\n```\nWORK CYCLE: Incomplete\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n[1/5] PREP    ‚úì\n[2/5] COOK    ‚úì\n[3/5] SERVE   ‚úó (error: <reason>)\n[4/5] TIDY    pending\n[5/5] PLATE pending\n\nFailed at: <step>\nError: <description>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nTASK: <id> - <title>\n\nRun /line:tidy to save progress, or investigate the error.\n\nIf plate failed, feature bead will remain open for validation when issues are resolved.\n```\n\n## Design Notes\n\nThe `/line:run` command is the recommended entry point for focused work sessions. It:\n\n1. **Ensures proper setup** - Prep runs first to sync state\n2. **Maintains focus** - One task per cycle\n3. **Enforces quality** - Serve reviews before commit\n4. **Guarantees completion** - Tidy pushes changes\n\nFor exploratory sessions or when you need more control, use the individual commands directly.\n\n## Example Usage\n\n```\n/line:run              # Full cycle with auto-selected task\n/line:run lc-042       # Full cycle with specific task\n```\n",
        "commands/serve.md": "---\ndescription: Review changes via headless Claude and file issues\nallowed-tools: Bash, Read, Glob, Grep, Edit, TodoWrite\n---\n\n## Summary\n\n**Review changes via headless Claude.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\nAfter cooking (executing a task), you \"serve\" it for review before tidying up.\n\n**Arguments:** `$ARGUMENTS` (optional) - Specific bead ID to review\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Identify Changes to Review\n\n**If `$ARGUMENTS` provided:**\n- Use that bead ID directly\n\n**Otherwise:**\n- Find most recently closed bead: `bd list --status=closed --limit=1`\n- Or find current in-progress bead if cook didn't close it yet\n\nShow the bead being reviewed:\n```bash\nbd show <id>\n```\n\n### Step 2: Gather Review Context\n\nCollect changes and project context:\n```bash\n# Get changes\ngit diff                    # Unstaged changes\ngit diff --cached           # Or staged changes\ngit status --porcelain      # File list\n\n# If already committed\ngit diff HEAD~1\n```\n\n**Load project context for context-aware review:**\n```bash\n# Check for CLAUDE.md\ncat CLAUDE.md 2>/dev/null | head -50\n```\n\nThis gives the reviewer awareness of project patterns and conventions.\n\n### Step 3: Automatic Code Review\n\nDelegate to sous-chef (reviewer) subagent:\n\n```\nUse Task tool to invoke sous-chef subagent:\nTask(description=\"Review code changes for task <id>\", prompt=\"Review the following changes for task: <bead title>\n\nTask ID: <id>\nTask description: <brief description>\n\nChanges to review:\n<git diff output or diff HEAD~1>\n\nProject context:\n<CLAUDE.md summary if available>\n\nReview checklist:\n- Correctness: Logic errors, edge cases, error handling\n- Security: Input validation, secrets exposure, injection risks\n- Style: Naming, consistency with codebase patterns\n- Completeness: Does it fully address the task?\n\nOutput format:\n1. Summary: Brief overall assessment\n2. Verdict: ready_for_tidy | needs_changes | blocked\n3. Issues found:\n   - Severity: critical | major | minor | nit\n   - File/line: Location\n   - Issue: Description\n   - Suggestion: How to fix\n   - Auto-fixable: true | false\n4. Positive notes: What was done well\n\nCRITICAL: If verdict is 'blocked', explain why and what must be fixed.\", subagent_type=\"sous-chef\")\n```\n\nThe sous-chef agent will:\n- Review correctness (logic, edge cases, error handling)\n- Check security (input validation, secrets, injection risks)\n- Verify style (naming, consistency with codebase patterns)\n- Assess completeness (fully addresses the task?)\n\n**Wait for reviewer assessment. Address any critical issues before proceeding to tidy.**\n\n**Manual fallback:** If sous-chef agent is unavailable, invoke headless Claude:\n```bash\ngit diff | claude \\\n  --max-turns 1 \\\n  -p \"Review these changes for the task: <bead title>\n  ...\" \\\n  --output-format text \\\n  --allowedTools \"Read,Glob,Grep\"\n```\n\n### Step 4: Process Review Results\n\nBased on sous-chef verdict:\n\n**If verdict is ready_for_tidy:**\n- Proceed to Step 5\n- No changes needed\n\n**If verdict is needs_changes:**\n- Apply auto-fixable issues (typos, formatting, obvious one-line fixes)\n- Note non-fixable issues for `/line:tidy`\n- Categorize by priority (P1-P4)\n\n**If verdict is blocked:**\n- CRITICAL issues must be fixed before tidying\n- Report blocking issues to user\n- Recommend not proceeding to `/line:tidy` until fixed\n- Keep task as in_progress\n\n### Step 5: Record and Report Results\n\n**Record via comment:**\n```bash\nbd comments add <bead-id> \"PHASE: SERVE\nStatus: completed\nVerdict: <approved|needs_changes|blocked>\nIssues: <count> found (<auto-fixed>, <to-file>)\nSummary: <brief assessment>\"\n```\n\n**Output format:**\n\nCRITICAL: The SERVE_RESULT block must be present and parseable by orchestrators.\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  SERVE: Dish Presented                                       ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nREVIEW: <id> - <title>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSummary:\n  <brief overall assessment of the changes>\n\nAuto-fixed:\n  - <file>:<line> - <fix applied>\n\nIssues to file in /tidy:\n  - [P1] \"<title>\" - <description>\n  - [P3] \"<title>\" - <description>\n  - [P4/retro] \"<title>\" - <minor suggestion>\n\nPositive notes:\n  - <good thing>\n  - <good thing>\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ SERVE_RESULT                            ‚îÇ\n‚îÇ verdict: APPROVED | NEEDS_CHANGES | BLOCKED ‚îÇ\n‚îÇ continue: true | false                  ‚îÇ\n‚îÇ next_step: /line:tidy | /line:cook      ‚îÇ\n‚îÇ blocking_issues: <count or 0>           ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nNEXT STEP: /line:tidy (if APPROVED) or /line:cook (if NEEDS_CHANGES)\n```\n\n**Verdict meanings:**\n- **APPROVED**: No issues found, continue to tidy\n- **NEEDS_CHANGES**: Issues found requiring rework. Rerun /line:cook with findings.\n- **BLOCKED**: Critical issues require fixing before commit. STOP workflow.\n\n## Error Handling\n\nIf the sous-chef agent or headless Claude invocation fails (API error, timeout, etc.):\n\n```\n‚ö†Ô∏è REVIEW SKIPPED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReason: <error message>\n\nManual review recommended. Run /line:serve again after /tidy.\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ SERVE_RESULT                            ‚îÇ\n‚îÇ verdict: SKIPPED                        ‚îÇ\n‚îÇ continue: true                          ‚îÇ\n‚îÇ blocking_issues: 0                      ‚îÇ\n‚îÇ retry_recommended: true                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\nAPI errors are **transient** - workflow continues but recommends retry later.\n\n## Example Usage\n\n```\n/line:serve              # Review most recent closed bead\n/line:serve lc-042       # Review specific bead\n```\n",
        "commands/tidy.md": "---\ndescription: Commit changes, sync beads, and push to remote\nallowed-tools: Bash, Read, Write, Edit, Glob, Grep, TodoWrite\n---\n\n## Summary\n\n**File discovered issues, commit changes, and push to remote.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\nThis is where findings from `/line:cook` and `/line:serve` get filed as beads.\n\n---\n\n## Bead Creation Reference\n\nUse this when filing discovered issues:\n\n```bash\n# Standard issues (blocking tasks)\nbd create --title=\"...\" --type=task|bug|feature --priority=0-4\n\n# Priority: 0=critical, 1=high, 2=medium, 3=low, 4=backlog\n# Types: task, bug (broken), feature (new capability)\n\n# Minor improvements (review later)\nbd create --title=\"...\" --type=task --priority=4 --parent=<retrospective-epic>\n```\n\n**Retrospective Epic Pattern:**\n\nFor minor suggestions, improvements, and \"nice-to-haves\" discovered during execution, file them to a retrospective epic. This keeps the main backlog focused on real issues.\n\n```bash\n# One-time setup (if not exists)\nbd create --title=\"Retrospective\" --type=epic --priority=4\n\n# Then file minor items as children\nbd create --title=\"Consider refactoring X\" --type=task --priority=4 --parent=<retro-epic-id>\n```\n\n## Process\n\n### Step 1: File Discovered Issues\n\nReview findings from `/line:cook` and `/line:serve` and create beads:\n\n**Blocking issues** (needs attention):\n```bash\nbd create --title=\"<issue>\" --type=bug|task --priority=1-3\n```\n\n**Non-blocking findings** (review later):\n```bash\nbd create --title=\"<suggestion>\" --type=task --priority=4 --parent=<retro-epic>\n```\n\n#### Research Findings (for research tasks)\n\nWhen the task involved research (architecture analysis, spike, investigation), also capture findings:\n\n**New beads for discoveries:**\n```bash\nbd create --title=\"Implement <finding>\" --type=task --priority=2-3\nbd create --title=\"Document <pattern>\" --type=task --priority=3\n```\n\n**Update existing beads:**\n```bash\nbd comments add <id> \"RESEARCH FINDINGS:\n- <key insight 1>\n- <key insight 2>\n- Recommendation: <action>\"\n```\n\n**Research output patterns:**\n- Actionable improvement ‚Üí Create task bead\n- Architectural insight ‚Üí Comment on epic or create doc task\n- Blocker discovered ‚Üí Create bug/task as dependency\n- Option evaluated ‚Üí Comment on research task\n- Decision made ‚Üí Update task description\n\n**Tip:** Research tasks often yield multiple follow-up beads. This is expected.\n\n### Step 2: Review In-Progress Issues\n\nCheck current task state:\n```bash\nbd list --status=in_progress\n```\n\nFor each **in-progress** issue:\n- If task appears complete based on git changes ‚Üí `bd close <id>`\n- If task is incomplete ‚Üí leave as-is (will be picked up next session)\n- If status is unclear ‚Üí create a P4 bead to review later\n\n**Do NOT ask the user** - make a reasonable judgment or file a bead.\n\n### Step 3: Check for Epic Closures\n\nAfter closing issues, check if any epics are now eligible for closure (all children complete):\n\n```bash\nbd epic close-eligible --dry-run\n```\n\nIf epics are eligible:\n1. Close them: `bd epic close-eligible`\n2. For each closed epic, get its children for the summary:\n   ```bash\n   bd list --parent=<epic-id> --all --json\n   ```\n\n**Note:** Epic closures are significant milestones. They will be highlighted prominently in the session summary.\n\n> **Epic Philosophy:** Epics use children (`--parent`) for grouping, not blocking dependencies.\n> Dependencies between children establish order within an epic.\n> See AGENTS.md for the full epic philosophy.\n\n### Step 4: Commit Changes with Kitchen Log\n\nShow pending changes:\n```bash\ngit status\n```\n\nIf changes exist:\n1. Stage all relevant files: `git add -A`\n2. Create a commit with the kitchen log format\n\n**Kitchen log commit format:**\n```bash\ngit commit -m \"<task-id>: <Short objective>\n\n<Detailed description of changes>\n\nImplementation includes:\n- Key feature 1\n- Key feature 2\n- Error handling approach\n\nDeliverable: <What was created>\nTests: <Test summary>\nSignal: KITCHEN_COMPLETE\n\nReview findings:\n- Sous-chef assessment: <verdict>\n- Test quality assessment: <result>\n- Issues addressed: <count>\"\n```\n\n**Commit message structure:**\n- Subject: `<task-id>: <Short objective>` (50 chars, imperative mood)\n- Blank line\n- Body: What and why (wrap at 72 chars)\n- Implementation details (bullet points)\n- Deliverable and test info\n- Review and test quality feedback\n- Signal emitted\n\n### Step 5: Verify Closing Kitchen\n\nBefore pushing, verify all quality gates pass:\n\n**Kitchen closing checklist (MANDATORY):**\n- [ ] All issues filed correctly\n- [ ] Commit message follows kitchen log format\n- [ ] Changes staged and committed\n- [ ] Beads synced with `bd sync`\n- [ ] Ready to push to remote\n\n**If any checklist item fails:**\n- Create P2 bead for follow-up\n- Note in commit body\n- Continue with push if non-blocking\n\n### Step 6: Sync and Push\n\n```bash\nbd sync                        # Commit beads changes\ngit pull --rebase && git push  # Push to remote (if remote exists)\n```\n\nIf no remote is configured, skip the push step.\n\nIf push fails:\n```bash\nbd create --title=\"Resolve git push failure: <error>\" --type=bug --priority=2\n```\n\n**CRITICAL:** Work is NOT complete until `git push` succeeds. If push fails, resolve and retry.\n\n### Step 7: Record Session Summary\n\n**Add final comment to the task:**\n```bash\nbd comments add <id> \"PHASE: TIDY\nStatus: completed\n\nSESSION SUMMARY\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nIntent: <why this change was made>\nBefore: <previous state/capability>\nAfter: <new state/capability>\n\nProblems encountered:\n  - <problem>: <how resolved>\n\nIssues filed:\n  - <new-id>: <title> [P<n>]\n\nCommit: <hash>\nPush: <success|failed>\"\n```\n\n### Step 8: Output Kitchen Report\n\n**If an epic was closed**, output the epic completion banner first:\n\n```\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  EPIC COMPLETE: <epic-id> - <epic-title>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nChildren completed (<count>):\n  ‚úì <id>: <title>\n  ‚úì <id>: <title>\n  ‚úì <id>: <title>\n  ...\n\nImpact:\n  <1-2 sentence description of what capability/improvement is now complete,\n   derived from the epic description>\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n```\n\n**Then output the kitchen report:**\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  TIDY: Kitchen Closed                                        ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nSESSION SUMMARY\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nTask: <id> - <title>\n\nINTENT:\n  <1-2 sentences from task description>\n  Goal: <deliverable or acceptance criteria>\n\nBEFORE ‚Üí AFTER:\n  <previous state> ‚Üí <new state>\n  <what couldn't be done> ‚Üí <what can be done now>\n\nFiles changed:\n  M src/foo.ts (+45, -12)\n  A src/bar.ts (+78)\n\nProblems encountered:\n  - <problem description>\n    Resolution: <how it was resolved>\n  - (none)\n\nIssues closed: <count>\n  ‚úì <id>: <title>\n\nEpics completed: <count>\n  ‚òÖ <epic-id>: <title> (<N> children)\n\nIssues filed: <count>\n  + <new-id>: <title> [P<n>]\n  + <new-id>: <title> [P4/retro]\n\nCommit: <hash>\n  <commit message>\n\nPush: ‚úì origin/main | ‚ö†Ô∏è <error> | skipped (no remote)\n\nSession complete.\n```\n\n**Information sources for summary:**\n- **Intent**: Extract from task description via `bd show <id>`\n- **Before**: Derive from git diff context - what existed before (files modified, previous behavior)\n- **After**: Semantic summary from cook completion - what capability exists now\n\n## Design Rationale\n\nThis command is intentionally **non-interactive** to support:\n\n1. **Workflow velocity** - No blocking on user input\n2. **Deferred decisions** - Unclear items become beads, not blockers\n3. **Session end discipline** - Quick cleanup without decision fatigue\n4. **Information when needed** - Bead creation reference provided here, where it's actually used\n\nThe pattern \"file, don't block\" means any concern that would require user judgment gets captured as a bead for later triage rather than interrupting the current flow.\n\n## Example Usage\n\n```\n/line:tidy\n```\n\nThis command takes no arguments.\n",
        "line-cook-kiro/README.md": "# Line Cook for Kiro CLI\n\nKiro CLI adapter for the line-cook workflow orchestration system.\n\n## Directory Structure\n\n```\nline-cook-kiro/\n‚îú‚îÄ‚îÄ agents/           # Custom agent configurations\n‚îÇ   ‚îú‚îÄ‚îÄ line-cook.json\n‚îÇ   ‚îú‚îÄ‚îÄ taster.json\n‚îÇ   ‚îú‚îÄ‚îÄ sous-chef.json\n‚îÇ   ‚îî‚îÄ‚îÄ maitre.json\n‚îú‚îÄ‚îÄ steering/         # Steering files (always-loaded context)\n‚îÇ   ‚îú‚îÄ‚îÄ line-cook.md\n‚îÇ   ‚îú‚îÄ‚îÄ beads.md\n‚îÇ   ‚îú‚îÄ‚îÄ session.md\n‚îÇ   ‚îú‚îÄ‚îÄ getting-started.md\n‚îÇ   ‚îú‚îÄ‚îÄ taster.md\n‚îÇ   ‚îú‚îÄ‚îÄ sous-chef.md\n‚îÇ   ‚îî‚îÄ‚îÄ maitre.md\n‚îú‚îÄ‚îÄ prompts/          # @prompt invocations\n‚îÇ   ‚îú‚îÄ‚îÄ line-prep.md\n‚îÇ   ‚îú‚îÄ‚îÄ line-cook.md\n‚îÇ   ‚îú‚îÄ‚îÄ line-serve.md\n‚îÇ   ‚îú‚îÄ‚îÄ line-tidy.md\n‚îÇ   ‚îú‚îÄ‚îÄ line-mise.md\n‚îÇ   ‚îú‚îÄ‚îÄ line-plate.md\n‚îÇ   ‚îú‚îÄ‚îÄ line-run.md\n‚îÇ   ‚îî‚îÄ‚îÄ line-getting-started.md\n‚îú‚îÄ‚îÄ skills/           # Lazy-loaded documentation\n‚îÇ   ‚îî‚îÄ‚îÄ line-cook/\n‚îÇ       ‚îî‚îÄ‚îÄ SKILL.md\n‚îî‚îÄ‚îÄ install.py        # Installation script\n```\n\n## Workflow Commands\n\nLine Cook supports two invocation methods:\n\n### 1. @Prompt Invocation (Explicit)\n\nUse `@line-<phase>` for explicit workflow control:\n\n| Prompt | Purpose |\n|--------|---------|\n| `@line-prep` | Sync state, show ready tasks |\n| `@line-cook` | Execute task with TDD cycle |\n| `@line-serve` | Review changes |\n| `@line-tidy` | Commit and push |\n| `@line-mise` | Create work breakdown |\n| `@line-plate` | Validate completed feature |\n| `@line-run` | Full cycle (prep‚Üícook‚Üíserve‚Üítidy) |\n| `@line-getting-started` | Show workflow guide |\n\n**Examples:**\n```\n@line-prep\n@line-cook lc-042\n@line-run\n```\n\n### 2. Natural Language (Flexible)\n\nThe steering file teaches the agent to recognize these phrases:\n\n| User Input | Workflow |\n|------------|----------|\n| \"getting started\", \"help\", \"guide\" | Show workflow guide |\n| \"mise\", \"plan\", \"planning\" | Plan work breakdown |\n| \"prep\", \"sync state\" | Run prep workflow |\n| \"cook\", \"start task\" | Run cook workflow (TDD cycle) |\n| \"serve\", \"review\" | Run serve workflow |\n| \"tidy\", \"commit\" | Run tidy workflow |\n| \"plate\", \"validate feature\" | Validate completed feature |\n| \"run\", \"full run\", \"full cycle\" | Full run cycle |\n\n**Recommendation:** Use @prompts for predictable behavior, natural language for conversational flow.\n\n## Installation\n\n```bash\npython3 install.py\n```\n\n## Usage\n\n```bash\nkiro-cli chat -a -r --agent line-cook\n```\n\nThen use `@line-prep` to start or say \"prep\".\n\n## See Also\n\n- [Line Cook README](../README.md)\n- [AGENTS.md](../AGENTS.md) - Technical documentation\n",
        "line-cook-kiro/skills/line-cook/SKILL.md": "---\nname: line-cook\ndescription: AI-supervised development workflow. Use when running prep, cook, serve, tidy, or work commands, managing beads issues during sessions, or following prep‚Üícook‚Üíserve‚Üítidy cycle. Covers workflow orchestration, guardrails, and session management.\n---\n\n# Line Cook\n\nStructured AI workflow execution for disciplined development.\n\n## When to Use\n\n- Starting a work session with \"work\" or \"/work\"\n- Running individual workflow steps: \"mise\", \"prep\", \"cook\", \"serve\", \"tidy\", \"plate\"\n- Managing beads issues during execution\n- Understanding workflow guardrails\n\n## Quick Reference\n\n| Command | Purpose |\n|---------|---------|\n| \"mise\" or \"plan\" | Plan work breakdown before implementation |\n| \"prep\" | Sync git, show ready tasks |\n| \"cook\" | Claim and execute a task with TDD cycle |\n| \"serve\" | AI peer review of completed work |\n| \"tidy\" | Commit, sync beads, push |\n| \"plate\" | Validate completed feature |\n| \"run\" | Full run (mise‚Üíprep‚Üícook‚Üíserve‚Üítidy‚Üíplate) |\n| \"work\" | Quick cycle (prep‚Üícook‚Üíserve‚Üítidy) |\n\n## Core Workflow\n\n**Quick cycle (most common):**\n```\nprep ‚Üí cook ‚Üí serve ‚Üí tidy\n```\n\n**Full service (feature delivery):**\n```\nmise ‚Üí prep ‚Üí cook ‚Üí serve ‚Üí tidy ‚Üí plate\n```\n\n### Step-by-Step\n\n1. **Mise**: Plan work breakdown (interactive)\n2. **Prep**: Sync state, identify available work\n3. **Cook**: Claim task, execute with guardrails, verify completion\n4. **Serve**: AI reviews changes\n5. **Tidy**: File discovered issues, commit, push\n6. **Plate**: Validate feature completion (when applicable)\n\n## Guardrails\n\nLine Cook enforces these disciplines:\n\n- **Sync before work** - Always start with current state\n- **One task at a time** - Focus prevents scope creep\n- **Verify before done** - Tests pass, code compiles\n- **File, don't block** - Discovered issues become new beads\n- **Push before stop** - Work isn't done until it's pushed\n\n## TDD Cycle with Quality Gates\n\nCook phase follows Red-Green-Refactor with automatic quality checks:\n\n**RED**: Write failing test\n- Write test for the feature\n- Verify test fails\n- Taster agent reviews test quality\n- Address critical issues before proceeding\n\n**GREEN**: Implement minimal code\n- Write simplest code to make test pass\n- Verify tests pass\n- No refactoring yet\n\n**REFACTOR**: Clean up code\n- Improve structure while tests pass\n- Ensure tests still pass after refactoring\n\n**Quality Gates** (must pass before completion):\n- Tests pass (project-specific test command)\n- Code builds (project-specific build command)\n- Test quality approved by taster agent\n- Code quality approved by sous-chef agent (serve phase)\n\n## Beads Integration\n\nLine Cook uses beads for task management:\n\n```bash\nbd ready                              # Find unblocked tasks\nbd update <id> --status in_progress   # Claim task\nbd show <id>                          # Get task context\nbd close <id>                         # Complete task\nbd sync                               # Sync with git\n```\n\n## Parking Lot Pattern\n\nTasks under \"Retrospective\" or \"Backlog\" epics are excluded from auto-selection. Explicit selection still works:\n\n```bash\nbd update <parked-task-id> --status in_progress\n```\n\n## Error Handling\n\nIf a step fails:\n- **Prep fails**: Fix sync issues, retry\n- **Cook fails**: Continue to tidy to save progress\n- **Serve fails**: Review skipped, continue to tidy\n- **Tidy fails**: Create bead for follow-up\n- **Plate fails**: Note incomplete, create follow-up bead\n\n## Reference\n\nFor full documentation, see:\n- `README.md` in project root - Philosophy and installation\n- `steering/*.md` files - Workflow instructions\n",
        "line-cook-opencode/commands/line-cook.md": "---\ndescription: Select and execute a task with completion guardrails\n---\n\n## Summary\n\n**Execute a task with guardrails ensuring completion.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\n**Arguments:** `$ARGUMENTS` (optional) - Specific task ID to execute\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Select Task\n\n**If `$ARGUMENTS` provided:**\n- Use that task ID directly\n\n**Otherwise:**\n- Run `bd ready` to get available tasks\n- Select the highest priority task (lowest P number)\n\n**Check if selected item is an epic:**\n```bash\nbd show <id> --json\n```\n\nIf `issue_type` is `epic`, the epic itself has no work to execute. Instead:\n\n1. Show the epic and its children:\n   ```bash\n   bd list --parent=<epic-id> --all\n   ```\n\n2. Find the first ready (unblocked, open) child and select that instead\n\n3. Output epic context:\n   ```\n   EPIC SELECTED: <epic-id> - <epic-title>\n   ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n   Epics contain no direct work. Selecting first ready child:\n\n   Children (<open>/<total>):\n     ‚óã <id>: <title> [P<n>] ‚Üê selected\n     ‚óã <id>: <title> [P<n>] (blocked by above)\n     ‚úì <id>: <title> (closed)\n\n   Proceeding with: <selected-task-id>\n   ```\n\n4. Continue with the selected child task\n\n**Once a regular task is selected**, claim it:\n```bash\nbd show <id>                           # Display full task details\nbd update <id> --status=in_progress    # Claim the task\nbd comments add <id> \"PHASE: COOK\nStatus: started\"\n```\n\n### Step 2: Load Recipe\n\nLoad the task details (the recipe):\n\n```bash\nbd show <id>\n```\n\nReview the task description, acceptance criteria, and any dependencies. This is the recipe for what will be cooked.\n\n### Step 3: Load Ingredients\n\nLoad relevant context files and documentation (the ingredients):\n\n1. **Project structure** - Understand codebase layout\n2. **Kitchen manual** - Review AGENTS.md for conventions\n3. **Related code** - Read files relevant to the task\n4. **Dependencies** - Check what this task builds on\n\nUse Read, Glob, and Grep tools to gather necessary context before starting implementation.\n\n### Step 4: Plan the Task\n\nBreak the task into steps using a checklist:\n\n1. Read the task description carefully\n2. Identify all deliverables\n3. List steps before starting\n4. Include verification steps (test, compile, etc.)\n\nFor complex tasks, use explore-plan-code workflow or ask clarifying questions.\n\n### Step 5: Execute TDD Cycle\n\nProcess checklist items systematically with TDD guardrails:\n\n- Work through items one at a time\n- Track progress as you go\n\n**For code changes, follow TDD cycle:**\n\n1. **RED**: Write failing test\n    ```bash\n    <test command>  # e.g., pytest, go test, npm test\n    # Should FAIL\n    ```\n\n2. **GREEN**: Implement minimal code\n   ```bash\n   <implementation>\n   <test command>\n   # Should PASS\n   ```\n\n3. **REFACTOR**: Clean up code\n   ```bash\n   <refactoring>\n   <test command>\n   # All tests should PASS\n   ```\n\n**Output format during execution:**\n```\nCOOKING: <id> - <title>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n[1/N] <todo item> ... ‚úì\n[2/N] <todo item> ... ‚úì\n[3/N] <todo item> ... in progress\n\nProgress: 2/N complete\n\nTDD Phase: RED/GREEN/REFACTOR\n```\n\n**Collecting findings:** As you execute, note (but do NOT file yet):\n- New tasks discovered\n- Potential issues or bugs\n- Areas for improvement\n\nThese will be filed as beads in `/line-tidy`.\n\n### Step 6: Verify Kitchen Equipment\n\nBefore marking the task done, verify ALL guardrails pass:\n\n- [ ] All checklist items completed\n- [ ] Code compiles/runs without errors\n- [ ] Tests pass (if applicable)\n- [ ] Changes match task description\n\n**Kitchen equipment checklist** (MANDATORY):\n\n- [ ] All tests pass: `<test command>` (e.g., `go test ./...`, `pytest`, `npm test`)\n- [ ] Code builds: `<build command>` (e.g., `go build ./...`, `npm run build`)\n- [ ] Lint passes: `<lint command>` (if applicable, e.g., `npm run lint`)\n- [ ] Task deliverable complete\n- [ ] Code follows kitchen manual conventions\n\n**If any guardrail fails:**\n- Do NOT close the task\n- Report what's incomplete\n- Keep task as `in_progress`\n- Ask user how to proceed\n\n### Step 7: Complete Task\n\nOnly after all guardrails pass:\n\n```bash\nbd close <id>\nbd comments add <id> \"PHASE: COOK\nStatus: completed\n\nSEMANTIC CONTEXT (for tidy summary):\nIntent: <why this change was made, from task description>\nBefore: <previous state - what existed/didn't work>\nAfter: <new state - what's now possible/fixed>\n\nFiles: <count> changed\nFindings: <issues/improvements noted for tidy>\"\n```\n\n**Completion output format:**\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  KITCHEN COMPLETE                                            ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nTask: <id> - <title>\nTests: ‚úì All passing\nBuild: ‚úì Successful\n\nSignal: KITCHEN_COMPLETE\n\nINTENT:\n  <1-2 sentences from task description>\n  Goal: <deliverable or acceptance criteria>\n\nBEFORE ‚Üí AFTER:\n  <previous state> ‚Üí <new state>\n  <what couldn't be done> ‚Üí <what can be done now>\n\nFiles changed:\n  M src/foo.ts\n  A src/bar.ts\n\nVerification:\n  [‚úì] All todos complete\n  [‚úì] Code compiles\n  [‚úì] Tests pass\n\nFindings (to file in /tidy):\n  New tasks:\n    - \"Add support for edge case X\"\n  Potential issues:\n    - \"Error handling in Y could be improved\"\n  Improvements:\n    - \"Consider refactoring Z for clarity\"\n\nNEXT STEP: /line-serve (review) or /line-tidy (commit)\n```\n\n## Guardrails (Critical)\n\n1. **No silent failures** - If something breaks, report it clearly\n2. **No premature completion** - Task stays open until verification passes\n3. **No scope creep** - Stay focused on the specific task\n4. **Note, don't file** - Discovered issues are noted for `/line-tidy`, not filed during cook\n\n## Error Handling\n\nIf execution is blocked:\n```\n‚ö†Ô∏è KITCHEN BLOCKED: <description>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReason: <why it failed>\nProgress: <what was completed>\n\nOptions:\n  1. <recovery option>\n  2. <alternative>\n\nTask remains in_progress. Run /line-tidy to save partial progress.\n```\n\n## Example Usage\n\n```\n/line-cook              # Pick highest priority ready task\n/line-cook lc-042       # Execute specific task\n```\n",
        "line-cook-opencode/commands/line-getting-started.md": "---\ndescription: Workflow guide with full bead reference\n---\n\n**Output this guide to the user.** Do not act on it - display it for reference.\n\n---\n\n## line-cook Workflow Guide\n\nThis guide explains the line-cook workflow and provides a complete reference for beads (issue tracking).\n\n## The Workflow Loop\n\n```\n/line-prep  ‚Üí  /line-cook  ‚Üí  /line-serve  ‚Üí  /line-tidy\n    ‚Üì              ‚Üì              ‚Üì              ‚Üì\n  sync          execute        review         commit\n```\n\nOr use `/line-run` to run the full cycle.\n\n### /line-prep - \"What's ready?\"\n- Syncs git and beads\n- Shows available tasks\n- Identifies the next recommended task\n\n### /line-cook - \"Execute the task\"\n- Claims a task\n- Plans and executes the task\n- Notes discovered issues for later (doesn't file beads yet)\n- Closes the task when done\n\n### /line-serve - \"Review changes\"\n- Performs peer review of changes\n- Auto-fixes minor issues\n- Categorizes findings for /tidy\n\n### /line-tidy - \"Commit and capture\"\n- Files discovered issues as beads\n- Commits changes\n- Pushes to remote\n- Records session summary\n\n## Workflow Principles\n\n1. **Sync before starting** - Always start with current state\n2. **Track with beads** - Strategic tasks live in issue tracker\n3. **Note, then file** - Discovered issues are noted in /cook, filed in /tidy\n4. **Guardrails on completion** - Verify before marking done\n5. **Push before stop** - Session isn't done until pushed\n\n---\n\n## Bead Reference\n\nBeads is the git-native issue tracker. Here's the complete reference.\n\n### Creating Issues\n\n```bash\nbd create --title=\"...\" --type=task|bug|feature --priority=0-4\n\n# Priority levels:\n#   0 = P0 = critical (production down)\n#   1 = P1 = high (blocking)\n#   2 = P2 = medium (normal priority)\n#   3 = P3 = low (when time permits)\n#   4 = P4 = backlog (someday/maybe)\n\n# Types:\n#   task    = work item\n#   bug     = broken behavior\n#   feature = new capability\n#   epic    = container for related tasks\n```\n\n### Epics and Children\n\n```bash\n# Create an epic\nbd create --title=\"Parent epic\" --type=epic --priority=2\n\n# Create child tasks\nbd create --title=\"Child task\" --type=task --parent=<epic-id>\n```\n\n### Dependencies\n\nDependencies express \"A depends on B\" (B blocks A):\n\n```bash\nbd dep add <issue-a> <depends-on-b>\n\n# Example: Tests depend on implementation\nbd dep add beads-002 beads-001  # 002 waits for 001 to complete\n```\n\n### Key Fields\n\n```bash\n--assignee=<user>     # Who owns this\n--description=\"...\"   # Detailed context\n--labels=a,b,c        # Categorization tags\n```\n\n### Workflow Commands\n\n```bash\n# Finding tasks\nbd ready                      # Tasks with no blockers\nbd list --status=open         # All open issues\nbd list --status=in_progress  # Active tasks\nbd blocked                    # Tasks with unmet dependencies\n\n# Managing issues\nbd show <id>                           # View details\nbd update <id> --status=in_progress    # Claim task\nbd comments add <id> \"progress note\"   # Add context\nbd close <id>                          # Mark done\n\n# Sync and collaboration\nbd sync                # Push/pull with remote\nbd stats               # Project statistics\n```\n\n### Retrospective Pattern\n\nFor minor suggestions and improvements, use a retrospective epic:\n\n```bash\n# One-time setup\nbd create --title=\"Retrospective\" --type=epic --priority=4\n\n# File minor items as children\nbd create --title=\"Consider refactoring X\" --type=task --priority=4 --parent=<retro-epic-id>\n```\n\nThis keeps the main backlog focused on real tasks while preserving good ideas for later review.\n\n---\n\n## Quick Start\n\n1. Run `/line-prep` to see ready tasks\n2. Run `/line-cook` to execute the top task\n3. Run `/line-tidy` when done to commit and push\n\nOr just run `/line-run` for the full cycle.\n",
        "line-cook-opencode/commands/line-mise.md": "---\ndescription: Create work breakdown before starting implementation\n---\n\n## Summary\n\n**Create human-readable work breakdown using tracer methodology.** Prep step before creating beads.\n\n**STOP after creating menu plan.** Wait for user approval before converting to beads.\n\n---\n\n## Process\n\n### Step 1: Understand the Order\n\nAsk clarifying questions:\n\n**What are we building?**\n- What problem are we solving?\n- What does success look like?\n- Who is the user?\n\n**What are the constraints?**\n- Are there technical constraints?\n- Time constraints (MVP vs full feature)?\n- Dependencies on other work?\n\n**What's the scope?**\n- MVP (minimum viable product)\n- Full feature\n- Multi-session epic\n\n**Ask questions if unclear.** Don't assume.\n\n### Step 2: Create Menu Plan (Task Graph)\n\nBuild a structured breakdown in YAML format for easy conversion to beads.\n\n**Why YAML?**\n- Human-readable and easy to edit\n- Machine-parseable for automated bead creation\n- Version controlled and reviewable\n- Can iterate quickly before creating beads\n\n**Create `docs/planning/menu-plan.yaml`:**\n\n```yaml\nphases:\n  - id: phase-1\n    title: \"Phase 1: Foundation\"\n    description: \"Core infrastructure for tmux integration and worktrees\"\n    duration: \"Week 1 (4-6 sessions)\"\n\n    features:\n      - id: feature-1.1\n        title: \"Feature 1.1: Execute commands in tmux sessions\"\n        priority: 2\n        user_story: \"As a capsule orchestrator, I want to execute commands in tmux sessions so that I can programmatic control OpenCode TUI\"\n        acceptance_criteria:\n          - \"Can create/destroy tmux sessions\"\n          - \"Can send commands with proper debouncing\"\n          - \"Can capture session output\"\n        tracer_strategy:\n          minimal_flow: \"Create session ‚Üí Send command ‚Üí Capture output ‚Üí Destroy\"\n          layers: \"Tmux wrapper ‚Üí Command execution ‚Üí Output capture\"\n          expansion: \"Window management, pane splitting (deferred)\"\n\n        tasks:\n          - title: \"Port tmux wrapper from gastown\"\n            priority: 1\n            tracer: \"Foundation layer - proves tmux integration works\"\n            description: |\n              - Copy internal/tmux/tmux.go structure\n              - Adapt for Capsule needs\n            deliverable: \"internal/tmux/tmux.go skeleton\"\n            reference: \"~/code/gastown/internal/tmux/tmux.go\"\n            tdd: true\n\n          - title: \"Implement session creation/destruction\"\n            priority: 1\n            depends_on: [\"Port tmux wrapper from gastown\"]\n            tracer: \"Session lifecycle - proves basic management works\"\n            description: |\n              - NewSession(name, workDir) function\n              - KillSession(name) function\n              - SessionExists(name) check\n            deliverable: \"Session management with tests\"\n            tdd: true\n\n          - title: \"Implement command execution\"\n            priority: 1\n            depends_on: [\"Implement session creation/destruction\"]\n            tracer: \"Command execution - proves sending commands works\"\n            description: |\n              - SendCommand(session, command) function\n              - Wait for completion with timeout\n              - Capture stdout/stderr\n            deliverable: \"Command execution with tests\"\n            tdd: true\n```\n\n**See `docs/planning/menu-plan-format.md` for complete format reference.**\n\n### Step 3: Add Feature Dependencies (Sequential Features)\n\nAdd `blocks` field to enforce sequential feature completion:\n\n```yaml\nfeatures:\n  - id: feature-2.1\n    title: \"Feature 2.1: Run missions in isolated worktrees\"\n    blocks: [\"feature-1.2\"]  # This feature blocks Feature 1.2\n    # ...\n\n  - id: feature-1.2\n    title: \"Feature 1.2: Basic CLI structure\"\n    blocks: [\"feature-3.1\"]  # This feature blocks Feature 3.1\n    # ...\n```\n\n**Why sequential?**\n- Maintains focus on one feature at a time\n- Prevents context switching\n- Ensures features are fully complete before moving on\n\n### Step 4: Plan BDD Tests for Features\n\n**Every feature must include BDD tests** that validate acceptance criteria from the user's perspective.\n\n**Define BDD test plan:**\n\n```yaml\nfeatures:\n  - id: feature-2.1\n    title: \"Feature 2.1: Run missions in isolated worktrees\"\n    user_story: \"As a capsule orchestrator, I want to run missions in isolated git worktrees so that I can execute multiple missions in parallel without workspace conflicts\"\n    acceptance_criteria:\n      - \"Can create worktree with unique name\"\n      - \"Worktree on new branch\"\n      - \"Changes don't affect main workspace\"\n      - \"Clean removal of worktrees\"\n    bdd_tests:\n      - test: \"TestFeature_RunMissionsInIsolatedWorktrees\"\n        scenarios:\n          - \"Acceptance_Criterion_1_Create_worktree_with_unique_name\"\n          - \"Acceptance_Criterion_2_Worktree_on_new_branch\"\n          - \"Acceptance_Criterion_3_Changes_dont_affect_main_workspace\"\n          - \"Acceptance_Criterion_4_Clean_removal_of_worktrees\"\n      - test: \"TestFeature_ParallelMissionIsolation\"\n        scenarios:\n          - \"Multiple missions run independently\"\n    smoke_tests:  # CLI validation - REQUIRED for user-facing features\n      - \"capsule launch creates worktree\"\n      - \"capsule dock removes worktree cleanly\"\n```\n\n**BDD Test Structure:**\n- File: `internal/<package>/integration_test.go`\n- Format: Given-When-Then comments\n- Naming: `TestFeature_<FeatureName>`\n- Subtests: Map to acceptance criteria\n- Real operations: Use actual git/tmux/system calls\n\n**Smoke Test Structure:**\n- File: `scripts/smoke-test-<feature>.sh` or `cmd/smoke-test/`\n- Tests: Real CLI commands with expected outputs\n- **Every feature must have smoke tests** (features are user-facing by definition)\n- Validates: End-to-end user experience\n\n**If you can't write smoke tests, it's not a feature** - it's infrastructure that should be tasks under a user-facing feature.\n\n### Step 5: Output Menu Plan Summary\n\nAfter creating the menu plan, output:\n\n```\nMENU PLAN CREATED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFile: docs/planning/menu-plan.yaml\n\nPhases: <N>\nFeatures: <M>\nCourses (tasks): <L>\n\nBreakdown:\n  Phase 1: <title> (<X> sessions)\n    - Feature 1.1: <title>\n      - <N> courses\n    - Feature 1.2: <title>\n      - <N> courses\n  ...\n\nTracer Strategy:\n  Feature 1.1:\n    Minimal flow: <flow description>\n    Layers: <layers>\n    Expansion: <deferred items>\n\nREVIEW THE PLAN:\n  1. Check hierarchy makes sense\n  2. Verify each feature has:\n     ‚úì User story\n     ‚úì Acceptance criteria (3-5)\n     ‚úì BDD test plan\n     ‚úì Smoke test plan (CLI)\n  3. Verify each course has:\n     ‚úì Tracer explanation\n     ‚úì Clear deliverable\n     ‚úì Dependencies listed\n\nNEXT STEP: Run /line-cook to convert menu plan to beads\n  (Review plan first, modify if needed, then convert)\n```\n\n### Step 6: Convert Menu Plan to Beads\n\n**ONLY convert after user approves the menu plan.**\n\nRun the conversion script:\n\n```bash\n./scripts/menu-plan-to-beads.sh docs/planning/menu-plan.yaml\n```\n\n**Script will:**\n- Create epics (phases)\n- Create features with acceptance criteria\n- Create tasks with descriptions and deliverables\n- Add task dependencies (depends_on)\n- Add feature dependencies (blocks)\n\n**Or create beads manually:**\n```bash\nbd create --title=\"Phase 1: Foundation\" --type=epic --priority=2\nbd create --title=\"Feature 1.1: Execute commands in tmux sessions\" --type=feature --parent=lc-abc --priority=3\nbd create --title=\"Port tmux wrapper from gastown\" --parent=lc-abc.1 --priority=1\nbd dep add <new-task-id> <dependency-task-id>\n```\n\n### Step 7: Verify Beads and Dependencies\n\nCheck that beads were created correctly and dependencies are enforced:\n\n```bash\nbd list              # See all beads\nbd list -t epic      # See only epics\nbd list -t feature   # See only features\nbd ready             # See available work (should be focused on one feature)\nbd blocked           # See blocked features\nbd show <epic-id>    # View epic with child features\nbd show <feature-id> # View feature with child tasks\n```\n\n**Verify hierarchy:**\n```bash\n# Check epic structure\nbd show <epic-id>\n# Should show:\n#   Epic: Phase 1: Foundation\n#   Children:\n#     - Feature 1.1: Execute commands in tmux sessions\n#     - Feature 1.2: Manage git worktrees\n\n# Check feature structure\nbd show <feature-id>\n# Should show:\n#   Feature: 1.1: Execute commands in tmux sessions\n#   Parent: Phase 1: Foundation\n#   Children:\n#     - Course: Port tmux wrapper from gastown\n#     - Course: Implement session creation/destruction\n```\n\n**Verify dependencies:**\n```bash\nbd ready\n# Should only show courses from the current feature (not blocked)\n\nbd blocked\n# Should show features blocked by dependencies\n```\n\n### Step 8: Sync and Commit\n\n```bash\nbd sync\ngit add docs/planning/menu-plan.yaml .beads/\ngit commit -m \"plan: Create menu plan for <phase>\n\n- <N> phases planned\n- <M> features with acceptance criteria\n- <L> courses (tasks) with tracer strategy\n\nKey features:\n- Feature 1.1: <title>\n- Feature 1.2: <title>\n\nTracer approach:\n- Each course builds foundation for next\n- Vertical slices through all layers\n- Production quality from start\"\ngit push\n```\n\n---\n\n## Hierarchy Structure\n\n**Three-tier hierarchy:**\n\n```\nEpic (Phase)\n‚îú‚îÄ‚îÄ Feature 1 (User-observable outcome)\n‚îÇ   ‚îú‚îÄ‚îÄ Course 1.1 (Implementation step)\n‚îÇ   ‚îú‚îÄ‚îÄ Course 1.2 (Implementation step)\n‚îÇ   ‚îî‚îÄ‚îÄ Course 1.3 (Implementation step)\n‚îî‚îÄ‚îÄ Feature 2 (User-observable outcome)\n    ‚îú‚îÄ‚îÄ Course 2.1 (Implementation step)\n    ‚îî‚îÄ‚îÄ Course 2.2 (Implementation step)\n```\n\n**Mapping:**\n- **Epic** = Phase (3+ sessions, multiple features)\n- **Feature** = User-observable capability (1-3 sessions, multiple courses)\n- **Course (Task)** = Single implementation unit (< 2 hours, one tracer)\n\n---\n\n## Tracer Dish Approach\n\n**Build vertical slices through all system layers, then expand incrementally.**\n\n**Key principle**: Each course is a mini-tracer that:\n- Implements one focused capability end-to-end\n- Touches relevant architectural layers\n- Provides foundation for next course\n- Is production-quality (not throwaway)\n\n**Example - Feature broken into tracer courses:**\n\n```markdown\nFeature 3.1: Launch missions from beads\n\nCourse 1: Define mission struct and state machine\n  ‚Üí Tracer: Data layer foundation\n  ‚Üí Proves: State management approach works\n\nCourse 2: Implement bead integration\n  ‚Üí Tracer: External interface layer\n  ‚Üí Proves: Can read/update bead status\n\nCourse 3: Implement launch command\n  ‚Üí Tracer: Orchestration layer\n  ‚Üí Proves: End-to-end flow works (CLI ‚Üí Mission ‚Üí Worktree ‚Üí Tmux ‚Üí Bead)\n```\n\nEach course builds on the previous, creating a complete vertical slice.\n\n---\n\n## Course Sizing Guidelines\n\n**Use tracer bullet thinking** - each course should be a vertical slice through relevant layers.\n\n**Too Small** (combine into one tracer):\n- \"Add import statement\"\n- \"Create empty file\"\n- \"Update comment\"\n\n**Just Right** (single tracer, one session):\n- \"Define mission struct and state machine\" (data layer)\n- \"Implement bead integration\" (external interface layer)\n- \"Implement launch command\" (orchestration layer)\n\n**Too Large** (break into multiple tracers):\n- \"Implement entire mission lifecycle\" ‚Üí Break into: state machine, launch, monitor, dock\n- \"Add all monitoring features\" ‚Üí Break into: capture, detect, log, report\n- \"Complete Phase 1\" ‚Üí Break into individual features\n\n---\n\n## Common Mistakes to Avoid\n\n‚ùå **Creating beads directly**: Hard to review, edit, and discuss\n‚úÖ **Menu plan first**: Easy to review and iterate\n\n‚ùå **Too vague**: \"Implement monitoring\"\n‚úÖ **Specific tracer**: \"Implement output capture loop with 5s interval\"\n\n‚ùå **Too large**: \"Complete Phase 1\"\n‚úÖ **Sized right**: \"Define mission struct and state machine\"\n\n‚ùå **No deliverable**: \"Research tmux\"\n‚úÖ **Clear outcome**: \"Document tmux patterns in RESEARCH.md\"\n\n‚ùå **Horizontal slicing**: \"Build entire UI layer\"\n‚úÖ **Vertical slicing**: \"Implement launch command (CLI ‚Üí Mission ‚Üí Tmux)\"\n\n‚ùå **No tracer strategy**: Courses in random order\n‚úÖ **Tracer sequence**: Foundation ‚Üí Integration ‚Üí Orchestration\n\n‚ùå **Prototype thinking**: \"Quick and dirty, we'll rewrite later\"\n‚úÖ **Tracer thinking**: \"Production quality, minimal scope, expand incrementally\"\n\n‚ùå **\"Internal features\" with no CLI**: \"Feature: Manage worktrees\" (no user interface)\n‚úÖ **User-facing features only**: \"Feature: Launch missions in isolated worktrees\" (has `capsule launch`)\n\n‚ùå **Features without smoke tests**: If you can't smoke test it, it's not a feature\n‚úÖ **Every feature has smoke tests**: Validates end-to-end user experience\n\n---\n\n## Example Usage\n\n```\n/line-mise\n```\n\nThis command takes no arguments. It will:\n1. Ask clarifying questions about what you're building\n2. Create a YAML menu plan in `docs/planning/menu-plan.yaml`\n3. Output summary for review\n4. Wait for user to convert to beads\n\nTo convert plan to beads:\n```bash\n./scripts/menu-plan-to-beads.sh docs/planning/menu-plan.yaml\n```\n",
        "line-cook-opencode/commands/line-plate.md": "---\ndescription: Validate completed feature and create acceptance documentation\n---\n\n## Summary\n\n**Validate completed features and create acceptance documentation.** Final step before feature completion.\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Identify Feature to Validate\n\nSelect the feature to validate:\n\n```bash\n# Option 1: Use argument\n/line-plate <feature-id>\n\n# Option 2: Find recently completed features\nbd list --status=closed --type=feature --limit=5\n```\n\n**Important:** Only run plate phase on fully completed features (all child tasks closed).\n\n### Step 2: Run Feature Validation\n\nExecute tests to verify feature works end-to-end:\n\n```bash\n# Run all tests\ngo test ./...\n\n# Run feature-specific BDD tests\ngo test ./internal/<package> -run TestFeature -v\n\n# Run smoke tests if available\n./scripts/smoke-test-<feature>.sh\n```\n\n**If tests fail:**\n- Investigate and fix issues\n- Re-run tests\n- Do NOT proceed with plate phase until tests pass\n\n### Step 3: Review BDD Test Quality\n\nReview BDD tests for quality:\n\n**Verify:**\n- All acceptance criteria have tests\n- Given-When-Then structure used\n- Tests map to acceptance criteria\n- User perspective documented\n- Error scenarios included\n\n**If critical issues found:**\n- Address issues\n- Re-run tests\n- Do NOT proceed until quality bar is met\n\n### Step 4: Create Feature Acceptance Documentation\n\nCreate acceptance documentation using the multi-course meal template:\n\n1. Copy the template to `docs/features/<feature-id>-acceptance.md`:\n   ```bash\n   mkdir -p docs/features\n   cp docs/templates/feature-acceptance.md docs/features/<feature-id>-acceptance.md\n   ```\n\n2. Fill in the template sections:\n   - **Chef's Selection** - User story from feature definition\n   - **Tasting Notes** - Map each acceptance criterion to verification evidence\n   - **Quality Checks** - Document BDD and smoke test results\n   - **Kitchen Staff Sign-Off** - Record agent approvals\n   - **Guest Experience** - Show users how to use the feature\n   - **Kitchen Notes** - Capture limitations, ideas, deployment info\n   - **Related Orders** - Link to completed tasks and related features\n\n3. Remove the \"Usage Instructions\" section from the filled template\n\nSee [`docs/templates/feature-acceptance.md`](../../docs/templates/feature-acceptance.md) for the full template.\n\n### Step 5: Update CHANGELOG.md\n\nAdd feature to CHANGELOG.md:\n\n```markdown\n## [Unreleased]\n\n### Added\n- <feature-title> (<feature-id>)\n  - <summary of feature>\n  - <key capabilities delivered>\n```\n\n### Step 6: Close Feature Bead\n\nClose the feature bead to mark completion:\n\n```bash\nbd close <feature-id>\n```\n\n### Step 7: Commit and Push\n\nCommit acceptance documentation and CHANGELOG:\n\n```bash\ngit add docs/features/<feature-id>-acceptance.md CHANGELOG.md\ngit commit -m \"feat: complete <feature-title> (<feature-id>)\n\nFeature validation complete:\n- All acceptance criteria verified\n- BDD tests approved\n- Smoke tests passing\n\nAcceptance report: docs/features/<feature-id>-acceptance.md\"\n\nbd sync\ngit push\n```\n\n### Step 8: Output Summary\n\n```\nPLATE PHASE COMPLETE\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFeature: <id> - <title>\nStatus: Validated and complete\n\nAcceptance Criteria:\n  [‚úì] <Criterion 1>\n  [‚úì] <Criterion 2>\n  [‚úì] <Criterion 3>\n\nQuality Assurance:\n  [‚úì] Tests passing\n  [‚úì] BDD tests reviewed\n  [‚úì] Code review complete\n\nDeliverables:\n  - Acceptance report: docs/features/<feature-id>-acceptance.md\n  - CHANGELOG.md updated\n  - Feature bead closed\n\nCommit: <hash>\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nNEXT STEP: Continue with next feature or task\n```\n\n## Error Handling\n\n### Tests Fail\n\n```\nFEATURE VALIDATION FAILED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFeature: <id> - <title>\n\nIssue: <description of test failure>\n\nActions:\n  1. Fix the failing tests\n  2. Re-run: go test ./...\n  3. Retry /line-plate <feature-id>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n```\n\n### BDD Quality Issues\n\n```\nBDD QUALITY ISSUES FOUND\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFeature: <id> - <title>\n\nCritical Issues:\n  - <Issue 1>\n  - <Issue 2>\n\nActions:\n  1. Address critical BDD issues\n  2. Re-run BDD review\n  3. Retry /line-plate <feature-id>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n```\n\n## Design Notes\n\nThe plate phase ensures features are production-ready before completion:\n\n1. **End-to-end validation** - All tests must pass\n2. **BDD quality** - Tests must meet quality bar\n3. **Documentation** - Acceptance report provides comprehensive record\n4. **Changelog** - Track feature delivery for users\n\n**When to run:**\n- After all child tasks for a feature are closed\n- Before closing the feature bead\n- During `/line-run` when feature completion is detected\n\n**Do NOT run on:**\n- Partially completed features (tasks still open)\n- Epics (use plate on individual features)\n- Tasks (only features have BDD tests)\n\n## Example Usage\n\n```\n/line-plate lc-abc.1  # Validate feature lc-abc.1\n```\n\nThis command takes a feature ID as argument. It will:\n1. Run tests to validate feature\n2. Review BDD test quality\n3. Create acceptance documentation\n4. Update CHANGELOG.md\n5. Close feature bead\n6. Commit and push\n",
        "line-cook-opencode/commands/line-prep.md": "---\ndescription: Sync state, load context, show ready tasks\n---\n\n## Summary\n\n**Sync state and identify ready tasks.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Sync State\n\nEnsure local state is current:\n\n```bash\ngit fetch origin\ngit pull --rebase\n```\n\nIf `.beads/` directory exists:\n```bash\nbd sync\n```\n\n### Step 2: Load Kitchen Manual\n\nLoad the work structure documentation:\n\n```bash\ncat AGENTS.md | head -100\n```\n\nThis loads kitchen terminology, agent definitions, and workflow principles.\n\n### Step 3: Gather Kitchen Roster\n\nGet project and branch info:\n```bash\npwd                           # Project directory\ngit branch --show-current     # Current branch\n```\n\nDisplay current task state:\n```bash\nbd ready                      # Available orders (no blockers)\nbd list --status=in_progress  # Active orders\nbd blocked                    # Blocked orders (for awareness)\n```\n\n### Step 4: Branching Strategy\n\nBefore selecting a task, check branching context:\n\n| Task Type | Branching | Rationale |\n|-----------|-----------|-----------|\n| **Feature** | Create branch: `git checkout -b feature/<feature-id>` | Multi-task work, isolation |\n| **Task** | Stay on main | Small, atomic changes |\n\nIf preparing to work on a feature (has `--type=feature`), create a feature branch first:\n```bash\nbd show <feature-id>  # Confirm it's a feature\ngit checkout -b feature/<feature-id>\n```\n\n### Step 5: Identify Next Task and Gather Context\n\nBefore outputting the summary, determine the recommended next task and its hierarchy:\n\n#### 5a: Find Next Ready Task\n\n1. Get the highest priority ready item from `bd ready`\n2. Check if it's an epic: `bd show <id> --json` and check `issue_type`\n\n**If the top item is an epic:**\n- Epics themselves don't contain work - their children do\n- Find the first ready child task: `bd list --parent=<epic-id>` filtered by ready (open + unblocked)\n- Recommend that child task instead\n\n**If no ready tasks but epics have unstarted children:**\n- Check epic children that are open but not blocked\n- Recommend starting with those\n\n#### 5b: Gather Parent Hierarchy\n\nOnce you have identified the next task, gather its parent chain:\n\n```bash\n# Get task details\nTASK_JSON=$(bd show <task-id> --json)\nPARENT_ID=$(echo $TASK_JSON | jq -r '.[0].parent // empty')\n\nif [ -n \"$PARENT_ID\" ]; then\n  # Get feature/parent info\n  FEATURE_JSON=$(bd show $PARENT_ID --json)\n\n  # Get sibling tasks for progress tracking\n  TOTAL_SIBLINGS=$(bd list --parent=$PARENT_ID | wc -l)\n  CLOSED_SIBLINGS=$(bd list --parent=$PARENT_ID --status=closed)\n\n  # Get epic info if feature has parent\n  EPIC_ID=$(echo $FEATURE_JSON | jq -r '.[0].parent // empty')\n  if [ -n \"$EPIC_ID\" ]; then\n    EPIC_JSON=$(bd show $EPIC_ID --json)\n    # Count epic's children for feature progress\n    TOTAL_FEATURES=$(bd list --parent=$EPIC_ID | wc -l)\n    CLOSED_FEATURES=$(bd list --parent=$EPIC_ID --status=closed | wc -l)\n  fi\nfi\n```\n\n#### 5c: Extract Task Intent\n\nParse the task description to extract:\n- **Summary**: First paragraph of description\n- **Deliverables**: Lines starting with \"Deliverable:\", \"Verify:\", or bullet points under those headers\n\n### Step 6: Output Kitchen Roster\n\nOutput a focused, scannable summary with hierarchical context:\n\n**Standard output (task with full hierarchy):**\n```\nSESSION: <project-name> @ <branch>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date | ‚ö†Ô∏è <issue>\n\nReady: <count> tasks | In progress: <count> | Blocked: <count>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nEPIC: <epic-id> [P<n>] <epic-title>\n  Goal: <first line of epic description>\n  Progress: <closed>/<total> features complete\n\n  ‚îî‚îÄ‚îÄ FEATURE: <feature-id> <feature-title>\n      Goal: <first line of feature description>\n      Progress: <closed>/<total> tasks complete\n\n      CURRENT STATE:\n        ‚úì <task-id> - <completed task title>\n        ‚úì <task-id> - <completed task title>\n        ... (list completed siblings)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n<task-id> [P<n>] <task-title>\n\nINTENDED CHANGE:\n  <first paragraph of task description>\n\n  Deliverable:\n    - <extracted deliverables from description>\n    - <bullet points or items after \"Deliverable:\" header>\n\nNEXT STEP: /line-cook <task-id>\n```\n\n**Standalone task (no parent hierarchy):**\n```\nSESSION: <project-name> @ <branch>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: <count> tasks | In progress: <count> | Blocked: <count>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n(Standalone task - no parent epic or feature)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n<task-id> [P<n>] <task-title>\n\nINTENDED CHANGE:\n  <first paragraph of task description>\n\nNEXT STEP: /line-cook <task-id>\n```\n\n**Feature without epic:**\n```\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nFEATURE: <feature-id> <feature-title>\n  Goal: <first line of feature description>\n  Progress: <closed>/<total> tasks complete\n\n  CURRENT STATE:\n    ‚úì <task-id> - <completed task title>\n    (or: no completed tasks yet)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n...\n```\n\n**No ready tasks:**\n```\nSESSION: <project-name> @ <branch>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: 0 tasks | In progress: <count> | Blocked: <count>\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNO READY TASKS\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nIn Progress:\n  <id> - <title> (assigned to <assignee>)\n\nBlocked:\n  <id> - <title> (waiting on: <blocker-ids>)\n\nOPTIONS:\n  - Continue work on in-progress task\n  - Unblock a blocked task\n  - Create new work with: bd create --title=\"...\" --type=task\n\nNEXT STEP: Review options above\n```\n\n**Important:** Do NOT include bead command reference here. That information is available via `/line-getting-started` and `/line-tidy` (where it's actually needed).\n\n## Error Handling\n\nIf sync fails:\n```\n‚ö†Ô∏è SYNC FAILED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReason: <error message>\n\nOptions:\n  1. Resolve manually and run /line-prep again\n  2. Run /line-cook to proceed offline (will sync later)\n```\n\n## Example Output\n\n**Task with full hierarchy (epic ‚Üí feature ‚Üí task):**\n```\nSESSION: line-cook @ main\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: 4 tasks | In progress: 0 | Blocked: 2\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nEPIC: lc-abc [P2] Phase 1: Core Workflow Enhancement\n  Goal: Enhance existing commands with TDD cycle and quality gates\n  Progress: 2/3 features complete\n\n  ‚îî‚îÄ‚îÄ FEATURE: lc-abc.1 Core Command Enhancement\n      Goal: Update prep, cook, serve, tidy with TDD workflow\n      Progress: 3/5 tasks complete\n\n      CURRENT STATE:\n        ‚úì lc-abc.1.1 - Update prep command\n        ‚úì lc-abc.1.2 - Update cook command\n        ‚úì lc-abc.1.3 - Update serve command\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nlc-abc.1.4 [P2] Update tidy command with commit formatting\n\nINTENDED CHANGE:\n  Add kitchen log format to commit messages and ensure\n  findings from cook phase are filed as beads.\n\n  Deliverable:\n    - Commit messages use kitchen log format\n    - Findings converted to beads\n    - Push verification before session end\n\nNEXT STEP: /line-cook lc-abc.1.4\n```\n\n**Standalone task:**\n```\nSESSION: line-cook @ main\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSync: ‚úì up to date\n\nReady: 2 tasks | In progress: 0 | Blocked: 0\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCONTEXT\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n(Standalone task - no parent epic or feature)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nNEXT TASK\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nlc-042 [P1] Fix sync timeout issue\n\nINTENDED CHANGE:\n  Increase timeout for bd sync to handle large repos.\n\nNEXT STEP: /line-cook lc-042\n```\n\n## Example Usage\n\n```\n/line-prep\n```\n\nThis command takes no arguments.\n",
        "line-cook-opencode/commands/line-run.md": "---\ndescription: Run full workflow cycle (prep‚Üícook‚Üíserve‚Üítidy)\n---\n\n## Summary\n\n**Run the full prep ‚Üí cook ‚Üí serve ‚Üí tidy cycle.** Primary entry point for focused work sessions.\n\n**Arguments:** `$ARGUMENTS` (optional) - Specific task ID to work on (passed to cook)\n\n---\n\n## Process\n\nExecute all steps in sequence without stopping between commands.\n\n### Step 1: Run /line-prep\n\nRead and follow `line-prep.md` to sync state and identify available work.\n\nWait for prep to complete.\n\n### Step 2: Run /line-cook\n\nRead and follow `line-cook.md` to execute work.\n\n**If `$ARGUMENTS` provided:** Pass the task ID to cook for explicit task selection.\n\n**Otherwise:** Cook will auto-select the highest priority ready task.\n\nWait for cook to complete.\n\n### Step 3: Run /line-serve\n\nRead and follow `line-serve.md` for peer review.\n\nWait for review to complete. **Check SERVE_RESULT verdict:**\n\n- If `continue: true` ‚Üí proceed to Step 4\n- If `continue: false` (BLOCKED) ‚Üí STOP and wait for user decision (see Error Handling)\n\n### Step 4: Run /line-tidy\n\nRead and follow `line-tidy.md` to file discovered work, commit, and push.\n\nTidy files discovered work, commits, syncs, and pushes.\n\n### Step 5: Check for Feature Completion\n\nAfter tidying, check if the task completed a feature:\n\n```bash\nbd show <task-id>\n```\n\n**If task has a parent feature AND all sibling tasks are closed:**\n- Run /line-plate to validate the feature\n- Create acceptance documentation\n- Close feature bead\n\n### Step 6: Cycle Summary\n\n```\nWORK CYCLE: Complete\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n[1/5] PREP    ‚úì synced\n[2/5] COOK    ‚úì executed\n[3/5] SERVE   ‚úì reviewed\n[4/5] TIDY    ‚úì committed, pushed\n[5/5] PLATE   ‚úì (feature complete) | ‚óã (not applicable)\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nTASK: <id> - <title>\n\nINTENT:\n  <1-2 sentences from task description>\n  Goal: <deliverable or acceptance criteria>\n\nBEFORE ‚Üí AFTER:\n  <previous state> ‚Üí <new state>\n  <what couldn't be done> ‚Üí <what can be done now>\n\nFiles: <count> changed\nCommit: <hash>\nIssues filed: <count>\n```\n\n## Error Handling\n\nIf any step fails:\n- **Prep fails**: Report sync error, stop workflow\n- **Cook fails**: Report error, offer to continue to tidy (to save progress)\n- **Serve fails**: Check SERVE_RESULT verdict (see below)\n- **Tidy fails**: Report push error, create bead for follow-up\n- **Plate fails**: Note feature validation incomplete, create bead\n\n### Serve Verdict Handling\n\nAfter serve completes, check the SERVE_RESULT block:\n\n| Verdict | continue | Action |\n|---------|----------|--------|\n| `APPROVED` | true | Continue to tidy |\n| `NEEDS_CHANGES` | true | Loop back to cook (rework) |\n| `SKIPPED` | true | Continue to tidy with retry recommendation |\n| `BLOCKED` | false | **STOP workflow** - require user decision |\n\n**On NEEDS_CHANGES verdict (Rework Loop):**\n1. Reopen the task: `bd update <id> --status=in_progress`\n2. Run /line-cook again (task will detect rework mode via serve comments)\n3. Run /line-serve again\n4. Repeat until APPROVED or BLOCKED\n5. Maximum 3 rework attempts before requiring user decision\n\n```\nREWORK REQUIRED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReview found issues that should be addressed:\n\n<list issues from SERVE_RESULT>\n\nLooping back to /line-cook for rework (attempt <n>/3)...\n```\n\n**On BLOCKED verdict:**\n```\nWORKFLOW STOPPED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReview found blocking issues that must be addressed:\n\n<list blocking issues from SERVE_RESULT>\n\nOptions:\n1. Fix the issues, then run /line-run again\n2. Override: run /line-tidy directly (skips review gate)\n3. Abandon: leave changes uncommitted for manual handling\n\nWaiting for user decision...\n```\n\n**On SKIPPED verdict (API error):**\n```\nReview skipped due to API error. Continuing to tidy.\nRecommendation: Run /line-serve manually after tidy completes.\n```\n\n## Design Notes\n\nThe `/line-run` command is the recommended entry point for focused work sessions. It:\n\n1. **Ensures proper setup** - Prep runs first to sync state\n2. **Maintains focus** - One task per cycle\n3. **Enforces quality** - Serve reviews before commit\n4. **Guarantees completion** - Tidy pushes changes\n\nFor exploratory sessions or when you need more control, use the individual commands directly.\n\n## Example Usage\n\n```\n/line-run              # Full cycle with auto-selected task\n/line-run lc-042       # Full cycle with specific task\n```\n",
        "line-cook-opencode/commands/line-serve.md": "---\ndescription: Review changes via headless Claude and file issues\n---\n\n## Summary\n\n**Review changes via headless Claude.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\nAfter cooking (executing a task), you \"serve\" it for review before tidying up.\n\n**Arguments:** `$ARGUMENTS` (optional) - Specific bead ID to review\n\n**STOP after completing.** Show NEXT STEP and wait for user.\n\n---\n\n## Process\n\n### Step 1: Identify Changes to Review\n\n**If `$ARGUMENTS` provided:**\n- Use that bead ID directly\n\n**Otherwise:**\n- Find most recently closed bead: `bd list --status=closed --limit=1`\n- Or find current in-progress bead if cook didn't close it yet\n\nShow the bead being reviewed:\n```bash\nbd show <id>\n```\n\n### Step 2: Gather Review Context\n\nCollect changes and project context:\n```bash\n# Get changes\ngit diff                    # Unstaged changes\ngit diff --cached           # Or staged changes\ngit status --porcelain      # File list\n\n# If already committed\ngit diff HEAD~1\n```\n\n**Load project context for context-aware review:**\n```bash\n# Check for CLAUDE.md\ncat CLAUDE.md 2>/dev/null | head -50\n```\n\nThis gives the reviewer awareness of project patterns and conventions.\n\n### Step 3: Perform Code Review\n\nReview the changes with focus on:\n\n1. **Correctness** - Logic errors, edge cases, error handling\n2. **Security** - Input validation, secrets exposure, injection risks\n3. **Style** - Naming, consistency with codebase patterns\n4. **Completeness** - Does it fully address the task?\n\nFor each issue found, categorize:\n- **Severity**: critical | major | minor | nit\n- **File/line**: Location\n- **Issue**: Description\n- **Suggestion**: How to fix\n- **Auto-fixable**: true | false\n\n### Step 4: Process Review Results\n\nBased on review findings:\n\n**If no issues found:**\n- Verdict: APPROVED\n- Proceed to Step 5\n\n**If issues found but non-blocking:**\n- Verdict: NEEDS_CHANGES\n- Apply auto-fixable issues (typos, formatting, obvious one-line fixes)\n- Note non-fixable issues for `/line-tidy`\n- Categorize by priority (P1-P4)\n- Continue to Step 5\n\n**If critical issues found:**\n- Verdict: BLOCKED\n- CRITICAL issues must be fixed before tidying\n- Report blocking issues to user\n- Recommend not proceeding to `/line-tidy` until fixed\n- Keep task as in_progress\n\n### Step 5: Record and Report Results\n\n**Record via comment:**\n```bash\nbd comments add <bead-id> \"PHASE: SERVE\nStatus: completed\nVerdict: <approved|needs_changes|blocked>\nIssues: <count> found (<auto-fixed>, <to-file>)\nSummary: <brief assessment>\"\n```\n\n**Output format:**\n\nCRITICAL: The SERVE_RESULT block must be present and parseable by orchestrators.\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  SERVE: Dish Presented                                       ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nREVIEW: <id> - <title>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nSummary:\n  <brief overall assessment of the changes>\n\nAuto-fixed:\n  - <file>:<line> - <fix applied>\n\nIssues to file in /tidy:\n  - [P1] \"<title>\" - <description>\n  - [P3] \"<title>\" - <description>\n  - [P4/retro] \"<title>\" - <minor suggestion>\n\nPositive notes:\n  - <good thing>\n  - <good thing>\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ SERVE_RESULT                            ‚îÇ\n‚îÇ verdict: APPROVED | NEEDS_CHANGES | BLOCKED ‚îÇ\n‚îÇ continue: true | false                  ‚îÇ\n‚îÇ blocking_issues: <count or 0>           ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nNEXT STEP: /line-tidy\n```\n\n**Verdict meanings:**\n- **APPROVED**: No issues found, continue to tidy\n- **NEEDS_CHANGES**: Non-blocking issues noted, continue to tidy (issues will be filed)\n- **BLOCKED**: Critical issues require fixing before commit. STOP workflow.\n\n## Error Handling\n\nIf review cannot be completed (tool failure, timeout, etc.):\n\n```\n‚ö†Ô∏è REVIEW SKIPPED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReason: <error message>\n\nManual review recommended. Run /line-serve again after /tidy.\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ SERVE_RESULT                            ‚îÇ\n‚îÇ verdict: SKIPPED                        ‚îÇ\n‚îÇ continue: true                          ‚îÇ\n‚îÇ blocking_issues: 0                      ‚îÇ\n‚îÇ retry_recommended: true                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\nErrors are **transient** - workflow continues but recommends retry later.\n\n## Example Usage\n\n```\n/line-serve              # Review most recent closed bead\n/line-serve lc-042       # Review specific bead\n```\n",
        "line-cook-opencode/commands/line-tidy.md": "---\ndescription: Commit changes, sync beads, and push to remote\n---\n\n## Summary\n\n**File discovered issues, commit changes, and push to remote.** Part of prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\nThis is where findings from `/line-cook` and `/line-serve` get filed as beads.\n\n---\n\n## Bead Creation Reference\n\nUse this when filing discovered issues:\n\n```bash\n# Standard issues (blocking tasks)\nbd create --title=\"...\" --type=task|bug|feature --priority=0-4\n\n# Priority: 0=critical, 1=high, 2=medium, 3=low, 4=backlog\n# Types: task, bug (broken), feature (new capability)\n\n# Minor improvements (review later)\nbd create --title=\"...\" --type=task --priority=4 --parent=<retrospective-epic>\n```\n\n**Retrospective Epic Pattern:**\n\nFor minor suggestions, improvements, and \"nice-to-haves\" discovered during execution, file them to a retrospective epic. This keeps the main backlog focused on real issues.\n\n```bash\n# One-time setup (if not exists)\nbd create --title=\"Retrospective\" --type=epic --priority=4\n\n# Then file minor items as children\nbd create --title=\"Consider refactoring X\" --type=task --priority=4 --parent=<retro-epic-id>\n```\n\n## Process\n\n### Step 1: File Discovered Issues\n\nReview findings from `/line-cook` and `/line-serve` and create beads:\n\n**Blocking issues** (needs attention):\n```bash\nbd create --title=\"<issue>\" --type=bug|task --priority=1-3\n```\n\n**Non-blocking findings** (review later):\n```bash\nbd create --title=\"<suggestion>\" --type=task --priority=4 --parent=<retro-epic>\n```\n\n#### Research Findings (for research tasks)\n\nWhen the task involved research (architecture analysis, spike, investigation), also capture findings:\n\n**New beads for discoveries:**\n```bash\nbd create --title=\"Implement <finding>\" --type=task --priority=2-3\nbd create --title=\"Document <pattern>\" --type=task --priority=3\n```\n\n**Update existing beads:**\n```bash\nbd comments add <id> \"RESEARCH FINDINGS:\n- <key insight 1>\n- <key insight 2>\n- Recommendation: <action>\"\n```\n\n**Research output patterns:**\n- Actionable improvement ‚Üí Create task bead\n- Architectural insight ‚Üí Comment on epic or create doc task\n- Blocker discovered ‚Üí Create bug/task as dependency\n- Option evaluated ‚Üí Comment on research task\n- Decision made ‚Üí Update task description\n\n**Tip:** Research tasks often yield multiple follow-up beads. This is expected.\n\n### Step 2: Review In-Progress Issues\n\nCheck current task state:\n```bash\nbd list --status=in_progress\n```\n\nFor each **in-progress** issue:\n- If task appears complete based on git changes ‚Üí `bd close <id>`\n- If task is incomplete ‚Üí leave as-is (will be picked up next session)\n- If status is unclear ‚Üí create a P4 bead to review later\n\n**Do NOT ask the user** - make a reasonable judgment or file a bead.\n\n### Step 3: Check for Epic Closures\n\nAfter closing issues, check if any epics are now eligible for closure (all children complete):\n\n```bash\nbd epic close-eligible --dry-run\n```\n\nIf epics are eligible:\n1. Close them: `bd epic close-eligible`\n2. For each closed epic, get its children for the summary:\n   ```bash\n   bd list --parent=<epic-id> --all --json\n   ```\n\n**Note:** Epic closures are significant milestones. They will be highlighted prominently in the session summary.\n\n> **Epic Philosophy:** Epics use children (`--parent`) for grouping, not blocking dependencies.\n> Dependencies between children establish order within an epic.\n> See AGENTS.md for the full epic philosophy.\n\n### Step 4: Commit Changes with Kitchen Log\n\nShow pending changes:\n```bash\ngit status\n```\n\nIf changes exist:\n1. Stage all relevant files: `git add -A`\n2. Create a commit with the kitchen log format\n\n**Kitchen log commit format:**\n```bash\ngit commit -m \"<task-id>: <Short objective>\n\n<Detailed description of changes>\n\nImplementation includes:\n- Key feature 1\n- Key feature 2\n- Error handling approach\n\nDeliverable: <What was created>\nTests: <Test summary>\nSignal: KITCHEN_COMPLETE\n\nReview findings:\n- Sous-chef assessment: <verdict>\n- Test quality assessment: <result>\n- Issues addressed: <count>\"\n```\n\n**Commit message structure:**\n- Subject: `<task-id>: <Short objective>` (50 chars, imperative mood)\n- Blank line\n- Body: What and why (wrap at 72 chars)\n- Implementation details (bullet points)\n- Deliverable and test info\n- Review and test quality feedback\n- Signal emitted\n\n### Step 5: Verify Closing Kitchen\n\nBefore pushing, verify all quality gates pass:\n\n**Kitchen closing checklist (MANDATORY):**\n- [ ] All issues filed correctly\n- [ ] Commit message follows kitchen log format\n- [ ] Changes staged and committed\n- [ ] Beads synced with `bd sync`\n- [ ] Ready to push to remote\n\n**If any checklist item fails:**\n- Create P2 bead for follow-up\n- Note in commit body\n- Continue with push if non-blocking\n\n### Step 6: Sync and Push\n\n```bash\nbd sync                        # Commit beads changes\ngit pull --rebase && git push  # Push to remote (if remote exists)\n```\n\nIf no remote is configured, skip the push step.\n\nIf push fails:\n```bash\nbd create --title=\"Resolve git push failure: <error>\" --type=bug --priority=2\n```\n\n**CRITICAL:** Work is NOT complete until `git push` succeeds. If push fails, resolve and retry.\n\n### Step 7: Record Session Summary\n\n**Add final comment to the task:**\n```bash\nbd comments add <id> \"PHASE: TIDY\nStatus: completed\n\nSESSION SUMMARY\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nIntent: <why this change was made>\nBefore: <previous state/capability>\nAfter: <new state/capability>\n\nProblems encountered:\n  - <problem>: <how resolved>\n\nIssues filed:\n  - <new-id>: <title> [P<n>]\n\nCommit: <hash>\nPush: <success|failed>\"\n```\n\n### Step 8: Output Kitchen Report\n\n**If an epic was closed**, output the epic completion banner first:\n\n```\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  EPIC COMPLETE: <epic-id> - <epic-title>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nChildren completed (<count>):\n  ‚úì <id>: <title>\n  ‚úì <id>: <title>\n  ‚úì <id>: <title>\n  ...\n\nImpact:\n  <1-2 sentence description of what capability/improvement is now complete,\n   derived from the epic description>\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n```\n\n**Then output the kitchen report:**\n\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  TIDY: Kitchen Closed                                        ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nSESSION SUMMARY\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nTask: <id> - <title>\n\nINTENT:\n  <1-2 sentences from task description>\n  Goal: <deliverable or acceptance criteria>\n\nBEFORE ‚Üí AFTER:\n  <previous state> ‚Üí <new state>\n  <what couldn't be done> ‚Üí <what can be done now>\n\nFiles changed:\n  M src/foo.ts (+45, -12)\n  A src/bar.ts (+78)\n\nProblems encountered:\n  - <problem description>\n    Resolution: <how it was resolved>\n  - (none)\n\nIssues closed: <count>\n  ‚úì <id>: <title>\n\nEpics completed: <count>\n  ‚òÖ <epic-id>: <title> (<N> children)\n\nIssues filed: <count>\n  + <new-id>: <title> [P<n>]\n  + <new-id>: <title> [P4/retro]\n\nCommit: <hash>\n  <commit message>\n\nPush: ‚úì origin/main | ‚ö†Ô∏è <error> | skipped (no remote)\n\nSession complete.\n```\n\n**Information sources for summary:**\n- **Intent**: Extract from task description via `bd show <id>`\n- **Before**: Derive from git diff context - what existed before (files modified, previous behavior)\n- **After**: Semantic summary from cook completion - what capability exists now\n\n## Design Rationale\n\nThis command is intentionally **non-interactive** to support:\n\n1. **Workflow velocity** - No blocking on user input\n2. **Deferred decisions** - Unclear items become beads, not blockers\n3. **Session end discipline** - Quick cleanup without decision fatigue\n4. **Information when needed** - Bead creation reference provided here, where it's actually used\n\nThe pattern \"file, don't block\" means any concern that would require user judgment gets captured as a bead for later triage rather than interrupting the current flow.\n\n## Example Usage\n\n```\n/line-tidy\n```\n\nThis command takes no arguments.\n",
        "line-cook-opencode/skills/line-cook/SKILL.md": "---\nname: line-cook\ndescription: AI-supervised development workflow. Use when running /line-run, /line-prep, /line-cook, /line-serve, /line-tidy commands, managing beads issues during sessions, or following prep‚Üícook‚Üíserve‚Üítidy cycle. Covers workflow orchestration, guardrails, and session management.\n---\n\n# Line Cook\n\nStructured AI workflow execution: prep ‚Üí cook ‚Üí serve ‚Üí tidy.\n\n## When to Use\n\n- Starting a work session with `/line-run`\n- Running individual workflow steps: `/line-prep`, `/line-cook`, `/line-serve`, `/line-tidy`\n- Managing beads issues during execution\n- Understanding workflow guardrails\n\n## Quick Reference\n\n| Command | Purpose |\n|---------|---------|\n| `/line-run` | Full prep‚Üícook‚Üíserve‚Üítidy cycle |\n| `/line-prep` | Sync git, show ready tasks |\n| `/line-cook` | Claim and execute a task |\n| `/line-serve` | AI peer review of completed work |\n| `/line-tidy` | Commit, sync beads, push |\n\n## Core Workflow\n\n```\n/line-run              # Full cycle with auto-selected task\n/line-run <task-id>    # Full cycle with specific task\n```\n\n### Step-by-Step\n\n1. **Prep**: Sync state, identify available work\n2. **Cook**: Claim task, execute with guardrails, verify completion\n3. **Serve**: Headless AI reviews changes\n4. **Tidy**: File discovered issues, commit, push\n\n## Guardrails\n\nLine Cook enforces these disciplines:\n\n- **Sync before work** - Always start with current state\n- **One task at a time** - Focus prevents scope creep\n- **Verify before done** - Tests pass, code compiles\n- **File, don't block** - Discovered issues become new beads\n- **Push before stop** - Work isn't done until it's pushed\n\n## Beads Integration\n\nLine Cook orchestrates beads for task management:\n\n```bash\nbd ready              # Find unblocked tasks\nbd update <id> --status=in_progress  # Claim task\nbd close <id>         # Complete task\nbd sync               # Sync with git\n```\n\n## Parking Lot Pattern\n\nTasks under \"Retrospective\" or \"Backlog\" epics are excluded from auto-selection. Explicit selection still works:\n\n```bash\n/line-cook <parked-task-id>\n```\n\n## Error Handling\n\nIf a step fails:\n- **Prep fails**: Fix sync issues, retry\n- **Cook fails**: Continue to tidy to save progress\n- **Serve fails**: Review skipped, continue to tidy\n- **Tidy fails**: Create bead for follow-up\n\n## Reference\n\n- [README](../../../README.md) - Philosophy and installation\n- [Commands](../../commands/) - Detailed command documentation\n",
        "tests/README.md": "# Line Cook Cross-Provider Test Suite\n\nIntegration tests for Line Cook commands across Claude Code, OpenCode, and Kiro.\n\n## Quick Start\n\n```bash\n# Run dependency check (no API calls)\n./tests/run-tests.sh --dry-run\n\n# Run fast unit tests only\n./tests/run-tests.sh --tier unit\n\n# Run all tests (will prompt about API costs)\n./tests/run-tests.sh\n```\n\n## Smoke Tests\n\nThe smoke test executes a real coding task through the full Line Cook workflow.\n\n### Interactive Mode (Recommended)\n\nRun the smoke test from within an interactive Claude session using the `/smoke-test` command:\n\n```\n/smoke-test\n```\n\nThis avoids API conflicts that occur when spawning headless Claude subprocesses from an interactive session.\n\n### Script Mode (Manual/CI)\n\nFor manual execution outside of Claude sessions, use the modular script:\n\n```bash\n# 1. Check dependencies\n./tests/smoke-test.sh --dry-run\n\n# 2. Setup creates an isolated test environment\nTEST_DIR=$(./tests/smoke-test.sh --setup)\n\n# 3. Run workflow manually in the test directory\ncd $TEST_DIR\n# ... run /line:prep, /line:cook smoke-001, /line:serve, /line:tidy ...\n\n# 4. Validate artifacts\n./tests/smoke-test.sh --validate $TEST_DIR\n\n# 5. Cleanup\n./tests/smoke-test.sh --teardown $TEST_DIR\n```\n\n### Script Options\n\n```bash\n./tests/smoke-test.sh --setup              # Create isolated env, output TEST_DIR\n./tests/smoke-test.sh --validate <dir>     # Check proof-of-work artifacts\n./tests/smoke-test.sh --teardown <dir>     # Clean up test directory\n./tests/smoke-test.sh --dry-run            # Check dependencies only\n./tests/smoke-test.sh --skip-cook-check    # Skip workflow validation (setup-only)\n```\n\n### What Smoke Tests Validate\n\n| Artifact | Check |\n|----------|-------|\n| Code change | `validation.py` uses regex instead of placeholder |\n| Tests exist | `test_validation.py` created |\n| Tests pass | pytest exit code 0 |\n| Bead closed | `smoke-001` has `status: closed` |\n| Commit exists | Git log contains smoke-001 reference |\n| Pushed | All commits pushed to remote |\n| Clean tree | No uncommitted changes |\n\n### Cost Estimate\n\n~$0.50-2.00 per run (primarily the cook phase)\n\n### Important Notes\n\n- **Use `/smoke-test` command** for testing within interactive sessions\n- Results are saved to `tests/results/smoke-*.json`\n- Test environment includes a bare git remote for push validation\n\n## Test Tiers\n\n| Tier | Tests | API Cost | Time |\n|------|-------|----------|------|\n| `unit` | getting-started | ~$0.01 | ~1min |\n| `integration` | getting-started, prep, serve, tidy | ~$0.10 | ~5min |\n| `full` | All tests including cook, work | ~$0.50-2.00 | ~30min |\n\n## Options\n\n```bash\n./tests/run-tests.sh [options]\n\nOptions:\n  --provider <name>   Test specific provider: claude, opencode, kiro\n  --test <name>       Run specific test: getting-started, prep, cook, serve, tidy, work\n  --tier <level>      Run by tier: unit, integration, full (default: full)\n  --dry-run           Check dependencies only\n  --help              Show help\n```\n\n## Directory Structure\n\n```\ntests/\n‚îú‚îÄ‚îÄ run-tests.sh              # Main test runner\n‚îú‚îÄ‚îÄ smoke-test.sh             # Cross-platform smoke test\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ setup-env.sh          # Creates isolated git repo with beads\n‚îÇ   ‚îú‚îÄ‚îÄ teardown-env.sh       # Cleanup temp directories\n‚îÇ   ‚îî‚îÄ‚îÄ test-utils.sh         # Common test utilities\n‚îú‚îÄ‚îÄ fixtures/\n‚îÇ   ‚îú‚îÄ‚îÄ mock-beads/           # Test beads configuration\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.yaml\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ issues/           # 6 test issues\n‚îÇ   ‚îú‚îÄ‚îÄ smoke-beads/          # Smoke test bead (smoke-001)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.yaml\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ smoke-001.yaml\n‚îÇ   ‚îî‚îÄ‚îÄ sample-project/       # Minimal project for testing\n‚îú‚îÄ‚îÄ results/                  # Smoke test JSON output\n‚îú‚îÄ‚îÄ test-getting-started.sh   # Tests /line:getting-started\n‚îú‚îÄ‚îÄ test-prep.sh              # Tests /line:prep\n‚îú‚îÄ‚îÄ test-cook.sh              # Tests /line:cook (LLM-heavy)\n‚îú‚îÄ‚îÄ test-serve.sh             # Tests /line:serve\n‚îú‚îÄ‚îÄ test-tidy.sh              # Tests /line:tidy\n‚îî‚îÄ‚îÄ test-work.sh              # Tests /line:work (LLM-heavy)\n```\n\n## Test Fixtures\n\n### Mock Beads Issues\n\n| Issue | Type | Status | Purpose |\n|-------|------|--------|---------|\n| tc-001 | task | open | Ready task (P1, no deps) - auto-selection |\n| tc-002 | task | open | Ready task (P2) - explicit selection |\n| tc-003 | task | open | Blocked (depends on tc-001) |\n| tc-004 | task | in_progress | Active work |\n| tc-retro | epic | open | Parking lot epic |\n| tc-005 | task | open | Under retro (should filter) |\n\n### Sample Project\n\nMinimal Python project with validation utilities:\n- `CLAUDE.md` - Agent instructions\n- `README.md` - Documentation\n- `src/main.py` - Entry point\n- `src/validation.py` - Validation utilities (has TODOs for tc-001)\n\n## Provider Commands\n\n| Provider | Command Syntax | Example |\n|----------|---------------|---------|\n| Claude Code | `/line:command` | `/line:prep` |\n| OpenCode | `/line-command` | `/line-prep` |\n| Kiro | `command` | `prep` |\n\n## Writing New Tests\n\n1. Create `tests/test-<name>.sh`\n2. Source `lib/test-utils.sh` for utilities\n3. Source `lib/setup-env.sh` for isolated environment\n4. Use `run_provider_test` to invoke commands\n5. Use `check_output_contains` to validate output\n6. Trap `lib/teardown-env.sh` for cleanup\n\nExample template:\n\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"$SCRIPT_DIR/lib/test-utils.sh\"\nsource \"$SCRIPT_DIR/lib/setup-env.sh\"\n\nsetup_colors\n\ncleanup() { source \"$SCRIPT_DIR/lib/teardown-env.sh\"; }\ntrap cleanup EXIT\n\n# Test logic here...\n```\n\n## CI Integration\n\nFor GitHub Actions, set `ANTHROPIC_API_KEY` secret:\n\n```yaml\n- name: Run Line Cook tests\n  env:\n    ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}\n  run: |\n    ./tests/run-tests.sh --tier unit --provider claude\n```\n",
        "tests/fixtures/sample-project/README.md": "# Sample Project\n\nA user registration system for testing Line Cook workflows.\n\n## Installation\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage\n\n```python\nfrom validation import validate_email, validate_password\n\n# Validate user input\nis_valid_email = validate_email(\"user@example.com\")\nis_strong_password = validate_password(\"SecurePass123!\")\n```\n\n## API Endpoints\n\n| Endpoint | Method | Description |\n|----------|--------|-------------|\n| `/api/health` | GET | Health check |\n\n## Development\n\nRun tests:\n```bash\npytest\n```\n"
      },
      "plugins": [
        {
          "name": "line",
          "source": "./",
          "description": null,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add smileynet/line-cook",
            "/plugin install line@line-cook"
          ]
        }
      ]
    }
  ]
}