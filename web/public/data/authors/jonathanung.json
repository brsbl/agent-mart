{
  "author": {
    "id": "jonathanung",
    "display_name": "Jonathan Ung",
    "avatar_url": "https://avatars.githubusercontent.com/u/53621118?u=549862252a4302ad7324273b950de72ac6a34a8d&v=4"
  },
  "marketplaces": [
    {
      "name": "jonathanung-plugins",
      "version": "1.0.1",
      "description": "Meta-prompting tools for iterative development",
      "repo_full_name": "jonathanung/finesse",
      "repo_url": "https://github.com/jonathanung/finesse",
      "repo_description": "Claude Code plugin for finessing (meta-prompting) ralph-loops pre execution",
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-02-21T05:15:38Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"jonathanung-plugins\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Meta-prompting tools for iterative development\",\n  \"owner\": {\n    \"name\": \"Jonathan Ung\",\n    \"url\": \"https://github.com/jonathanung\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"finesse\",\n      \"source\": \"./plugins/finesse\",\n      \"description\": \"Prompt planner and validator for ralph-loop — turns vague tasks into validated autonomous development prompts\",\n      \"version\": \"0.11.6\",\n      \"category\": \"productivity\",\n      \"tags\": [\"automation\", \"loops\", \"meta-prompting\"],\n      \"repository\": \"https://github.com/jonathanung/finesse\"\n    }\n  ]\n}\n",
        "README.md": "# Finesse\n\nA Claude Code plugin that turns vague task descriptions into validated, ready-to-run prompts for iterative autonomous development — the kind that converge instead of thrashing. Describe what you want in plain English; Finesse plans it, validates it with parallel agents, and executes it.\n\n> **How does iterative execution work?** Finesse ships its own execution layer (based on the [ralph-loop](https://github.com/anthropics/claude-code-plugins) plugin) that repeatedly invokes Claude to work on a task across multiple iterations until a completion condition is met. Each iteration is stateless — the agent starts fresh with only the prompt and the current state of the codebase. This makes prompt quality critical: a vague requirement becomes an infinite loop, a missing guardrail lets the agent delete your tests, and an ambiguous \"done\" condition means it either exits too early or never stops. Good prompts need [10 specific attributes](#the-10-mandatory-prompt-attributes) that Finesse encodes automatically.\n\n## How It Works\n\n```\n/finesse:finesse Build a REST API for managing todos with authentication\n```\n\nFinesse detects your task type, explores your codebase, asks you clarifying questions, designs implementation approaches, constructs the prompt, validates it with specialized agents, and presents the result for your approval — then executes it.\n\n```\nYou → /finesse:finesse \"vague idea\"\n       ↓\n  Task Classification (feature / bugfix / refactor / testing / performance / research)\n       ↓\n  Codebase Exploration (2-3 agents in parallel)\n       ↓\n  Scope Analysis & Decomposition (split large tasks into parallel sub-workflows?)\n       ↓\n  Type-Specific Workflow  ←  you answer clarifying questions\n       ↓\n  Prompt Construction (cold start, ordered phases, verification commands, guardrails)\n       ↓\n  Parallel Validation (6 agents in parallel)\n       ↓\n  Refinement (auto-fix or ask you)\n       ↓\n  Presentation  ←  you approve or reject\n       ↓\n  On Accept → finesse-plans/ output + execute or copy command(s)\n```\n\n## Installation\n\n```bash\n# Add the marketplace\n/plugin marketplace add jonathanung/finesse\n\n# Install the plugin\n/plugin install finesse @ jonathanung-finesse\n```\n\nFinesse ships its own execution layer — no additional plugins are required.\n\n## Commands\n\n### `/finesse:finesse <TASK> [--max-refinements N]`\n\nPlan and validate a prompt for any development task.\n\n- `TASK` — What you want to do. Can be vague — Finesse will clarify.\n- `--max-refinements N` — Max planning refinement cycles (default: 5). This is Finesse's internal planning budget, **not** the execution iteration count. Finesse determines the iteration count automatically based on task scope.\n\n```bash\n# Features\n/finesse:finesse Build a REST API for managing todos with auth\n/finesse:finesse Add a dark mode toggle to the settings page\n\n# Bug fixes\n/finesse:finesse Fix the token refresh bug in auth.ts\n/finesse:finesse The search endpoint returns duplicates when filters overlap\n\n# Refactoring\n/finesse:finesse Refactor the database layer to use repository pattern\n/finesse:finesse Clean up the payment service — it's 800 lines\n\n# Testing\n/finesse:finesse Add integration tests for the payments module\n/finesse:finesse Write unit tests for the email validation logic\n\n# Performance\n/finesse:finesse Optimize the search endpoint — it's taking 3+ seconds\n/finesse:finesse The dashboard page takes 5s to load\n\n# Research\n/finesse:finesse Research whether we should use Redis or Memcached for caching\n/finesse:finesse Investigate the trade-offs between REST and GraphQL for our API\n/finesse:finesse Evaluate feasibility of migrating from Postgres to CockroachDB\n```\n\n#### Example Output\n\nFor `/finesse:finesse Fix the token refresh bug in auth.ts`, Finesse produces something like:\n\n```bash\n/finesse:finesse-execute --prompt-file finesse-plans/fix-token-refresh-auth.md --completion-promise-file finesse-plans/fix-token-refresh-auth-promise.txt --max-iterations 8\n```\n\nFinesse saves three files:\n- `finesse-plans/fix-token-refresh-auth.md` — the prompt only: cold start paragraph, ordered fix-then-test phases, verification commands, and guardrails\n- `finesse-plans/fix-token-refresh-auth-promise.txt` — the completion promise text\n- `finesse-plans/fix-token-refresh-auth-plan.md` — metadata: task type, codebase context, chosen approach with rationale, iteration reasoning\n\n### `/finesse:finesse-execute [--prompt-file PATH] [--completion-promise-file PATH] [--max-iterations N] [PROMPT...]`\n\nExecute a plan using Finesse's built-in execution layer. Can auto-detect plans from `finesse-plans/`, take explicit file arguments, or accept an inline prompt.\n\n### `/finesse:finesse-mini <TASK>`\n\nLightweight single-pass alternative to `/finesse` for micro-tasks (fix a typo, add a missing import, rename a variable across a few files). Skips the full multi-phase workflow — explores 1-5 files, constructs a prompt, validates with 3 agents, and presents.\n\n### `/finesse:cancel-finesse`\n\nCancel the current planning session without saving.\n\n### `/finesse:cancel-finesse-execute`\n\nCancel an active execution loop.\n\n### `/finesse:finesse-help`\n\nShow a summary of what Finesse does, its agents, and how to use it.\n\n## Task-Specific Workflows\n\nFinesse detects your task type and runs a tailored multi-phase workflow. Every workflow ends with prompt construction, parallel validation, and presentation.\n\n- **Feature Development** (8 phases) — Discovery, codebase exploration with 2-3 agents, scope analysis & decomposition, clarifying questions, architecture design with 3 competing approaches (minimal, clean, pragmatic), construction, validation, presentation. Finesse always presents **3 architecture options** with trade-offs and asks you to choose.\n- **Bug Fix** (7 phases) — Bug understanding, codebase investigation tracing the failing execution path, scope analysis & decomposition, root cause analysis with hypothesis and evidence, fix strategy with regression tests, construction, validation.\n- **Refactor/Chore** (7 phases) — Scope definition, current state analysis mapping all dependencies and callers, scope analysis & decomposition, target state design, incremental migration strategy (never leaves codebase broken between phases), construction, validation.\n- **Testing** (6 phases) — Coverage analysis mapping test framework and gaps, scope analysis & decomposition, test strategy ranked by risk, clarifying questions on mocking/fixtures, construction, validation.\n- **Performance** (6 phases) — Problem definition with target metrics, profiling tracing slow paths and flagging O(n^2) patterns, scope analysis & decomposition, optimization strategy ranked by impact with measurable before/after, construction, validation.\n- **Research** (8 phases) — Goal definition clarifying the research question and deliverable format, source identification mapping codebase references and prior decisions, scope analysis & decomposition, research plan with outline and clarifying questions, investigation strategy with per-section evidence requirements and anti-rabbit-hole constraints, construction, validation, presentation. Output is a document, not code changes — source code is strictly read-only.\n\n## The 10 Mandatory Prompt Attributes\n\nYou don't need to know these to use Finesse — it handles them automatically. This section explains what Finesse encodes into every prompt it produces, so you can audit the output.\n\n| # | Attribute | Why It Matters |\n|---|---|---|\n| 1 | **Binary completion criteria** | Every requirement checkable by running a command — no subjective \"code is clean\" |\n| 2 | **Explicit completion signal** | `<promise>COMPLETE</promise>` with exact conditions listed |\n| 3 | **Self-diagnosing failure instructions** | What to do when stuck — try alternatives, document blockers, output `<promise>BLOCKED</promise>` |\n| 4 | **Ordered phases** | \"Build auth, then products, then cart\" — not a flat list of 20 requirements |\n| 5 | **Verification commands** | Specific commands per phase — `npm test`, `curl localhost:3000/health` |\n| 6 | **Guardrails against failure modes** | \"Do NOT rewrite files from scratch\", \"Do NOT delete tests to pass the suite\" |\n| 7 | **Scoped context** | Which files to modify, which to leave alone |\n| 8 | **Cold start paragraph** | Orientation for stateless re-entry: check state, identify what's done vs remaining |\n| 9 | **Conservative iteration limit** | Right-sized by task type and scope, with reasoning |\n| 10 | **Zero ambiguity about \"done\"** | Anti-premature-exit language, no room to rationalize partial completion |\n\n> **What are `<promise>` tags?** They are the execution layer's mechanism for detecting completion. When the agent outputs a `<promise>` tag matching the completion promise text, the loop stops iterating.\n\n## Agents\n\n### Validation Agents\n\nAfter constructing a prompt, Finesse launches 5 validation agents **in parallel**. All must pass before the plan is presented to you.\n\n| Agent | Focus | Checks For |\n|---|---|---|\n| **clarity-checker** | Requirement specificity | Ambiguous text, missing context, implicit assumptions, scope completeness, success criteria clarity |\n| **completion-validator** | Completion criteria | Binary criteria, explicit promise tag, anti-premature-exit language |\n| **scope-safety-reviewer** | Scope & safety | File boundaries, destructive action guardrails, \"Do NOT\" rules, iteration limits |\n| **phase-structure-analyzer** | Structural clarity | Cold start paragraph, ordered phases, verification commands, phase independence |\n| **failure-mode-auditor** | Failure handling | Stuck-state instructions, blocked signal, anti-thrashing rules, task-specific risks |\n\nEach agent returns `PASS`, `FAIL`, or `NEEDS_REWORK`:\n\n- **All PASS** — Plan is ready to present.\n- **Any FAIL** — Critical gaps. Finesse fixes what it can and asks you about the rest.\n- **Any NEEDS_REWORK** — Fixable issues. Finesse auto-fixes within its refinement budget.\n\nIf the scope-safety-reviewer flags `HIGH_RISK`, Finesse will ask you to explicitly acknowledge the risk before proceeding.\n\n### Planning Agents\n\n| Agent | Used In | Role |\n|---|---|---|\n| **code-explorer** | All workflows | Traces execution paths, maps architecture, identifies patterns and essential files |\n| **code-architect** | Feature workflow + scope analysis | Designs implementation approaches with trade-offs; proposes task decomposition |\n| **task-decomposer** | Scope analysis (all workflows) | Validates decomposition proposals: sub-workflow scoping, dependencies, wave grouping, coverage |\n\n## Output\n\nWhen you accept a plan, Finesse:\n\n**Single-workflow tasks:**\n1. Creates `finesse-plans/` in your workspace root (if it doesn't exist)\n2. Saves three files:\n   - `finesse-plans/<name>.md` — the prompt text only\n   - `finesse-plans/<name>-promise.txt` — the completion promise text only\n   - `finesse-plans/<name>-plan.md` — human-readable metadata: task type, codebase context, chosen approach, rationale, iteration reasoning, unresolved warnings\n3. Outputs the exact command:\n   ```\n   /finesse:finesse-execute --prompt-file finesse-plans/<name>.md --completion-promise-file finesse-plans/<name>-promise.txt --max-iterations <N>\n   ```\n\n**Multi-workflow tasks (decomposed):**\n1. Creates `finesse-plans/<session-name>/` with wave/task subdirectories\n2. Each sub-workflow gets its own `prompt.md`, `promise.txt`, and `plan.md`\n3. An `execution-graph.md` documents the dependency structure and all commands\n4. Outputs commands grouped by wave:\n   ```\n   ## Wave 1 (run in parallel)\n   /finesse:finesse-execute --prompt-file finesse-plans/<session>/wave-1/<task>/prompt.md --completion-promise-file finesse-plans/<session>/wave-1/<task>/promise.txt --max-iterations <N>\n\n   ## Wave 2 (run after Wave 1 completes)\n   /finesse:finesse-execute --prompt-file finesse-plans/<session>/wave-2/<task>/prompt.md --completion-promise-file finesse-plans/<session>/wave-2/<task>/promise.txt --max-iterations <N>\n   ```\n\nMetadata and rationale live in the separate `-plan.md` (or `plan.md`) file.\n\n## Plan Rejection & Iteration\n\nIf you reject a plan:\n\n- **With feedback:** Finesse's refinement counter resets to zero, giving you a fresh refinement budget. It makes targeted edits (doesn't rebuild from scratch), re-validates with all 5 agents, and re-presents.\n- **Without feedback:** Finesse asks what specifically needs to change.\n\nYou can reject and refine as many times as needed.\n\n## Iteration Count Guidance\n\nFinesse automatically sizes `--max-iterations` based on task type and scope:\n\n| Task Type | Scope | Iterations |\n|---|---|---|\n| Feature | 1-2 files | 8-12 |\n| Feature | 3-5 files | 12-18 |\n| Feature | 6+ files | 18-25 |\n| Bug Fix | One file, clear cause | 5-8 |\n| Bug Fix | Multi-file, clear cause | 8-12 |\n| Bug Fix | Unclear cause, multiple files | 12-18 |\n| Refactor | 1-3 files | 5-8 |\n| Refactor | 4-8 files | 10-15 |\n| Refactor | 9+ files | 15-22 |\n| Testing | 5-10 tests | 5-8 |\n| Testing | 10-25 tests | 10-15 |\n| Testing | 25+ tests | 15-20 |\n| Performance | Single bottleneck | 5-10 |\n| Performance | Multiple bottlenecks | 10-18 |\n| Performance | System-wide | 15-22 |\n| Research | Narrow (1-2 sections) | 5-8 |\n| Research | Medium (3-5 sections) | 8-14 |\n| Research | Broad (6+ sections) | 14-20 |\n\nIf a task needs more than 25 iterations, Finesse automatically proposes decomposing it into multiple independent sub-workflows during the Scope Analysis phase. Each sub-workflow runs with its own right-sized iteration count.\n\n## When to Use Finesse\n\n**Use Finesse when:**\n- You want to run a task autonomously with iterative execution\n- The task requires architectural decisions\n- The bug's root cause isn't obvious\n- The refactor touches many files\n- You need comprehensive test coverage\n- You want a structured research spike, feasibility study, or architecture comparison\n\n**Skip Finesse when:**\n- You already have a well-structured prompt\n- The task is trivial (one file, obvious change) - use `/finesse:finesse:mini` instead\n\n## Limitations\n\n- Planning uses multiple sub-agents, which consumes more tokens than a simple prompt. Budget accordingly for complex tasks.\n- Finesse works best with codebases it can explore. For greenfield projects with no existing code, provide more detail in your task description.\n\n## Quick Start\n\n```bash\n/plugin marketplace add jonathanung/finesse\n/plugin install finesse @ jonathanung-finesse\n/finesse:finesse <describe any task> # or\n/finesse:finesse-mini <describe a small task>\n```\n\nFinesse handles the rest. Plans are saved to `finesse-plans/` and ready to execute.\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "finesse",
          "source": "./plugins/finesse",
          "description": "Prompt planner and validator for ralph-loop — turns vague tasks into validated autonomous development prompts",
          "version": "0.11.6",
          "category": "productivity",
          "tags": [
            "automation",
            "loops",
            "meta-prompting"
          ],
          "repository": "https://github.com/jonathanung/finesse",
          "categories": [
            "automation",
            "loops",
            "meta-prompting",
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jonathanung/finesse",
            "/plugin install finesse@jonathanung-plugins"
          ]
        }
      ]
    }
  ]
}