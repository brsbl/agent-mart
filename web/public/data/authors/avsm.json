{
  "author": {
    "id": "avsm",
    "display_name": "Anil Madhavapeddy",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/53164?v=4",
    "url": "https://github.com/avsm",
    "bio": "Professor of Planetary Computing, University of Cambridge",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 5,
      "total_skills": 15,
      "total_stars": 20,
      "total_forks": 3
    }
  },
  "marketplaces": [
    {
      "name": "ocaml-claude-marketplace",
      "version": null,
      "description": "OCaml development plugins for Claude Code including project setup, build migration, RFC integration, opam publishing, and code style assistance",
      "owner_info": {
        "name": "Anil Madhavapeddy",
        "email": "anil@recoil.org"
      },
      "keywords": [],
      "repo_full_name": "avsm/ocaml-claude-marketplace",
      "repo_url": "https://github.com/avsm/ocaml-claude-marketplace",
      "repo_description": "Anil's OCaml Claude plugin collection",
      "homepage": null,
      "signals": {
        "stars": 20,
        "forks": 3,
        "pushed_at": "2026-01-29T10:45:56Z",
        "created_at": "2025-12-25T09:43:09Z",
        "license": "ISC"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 933
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 295
        },
        {
          "path": "plugins/ocaml-dev/README.md",
          "type": "blob",
          "size": 4021
        },
        {
          "path": "plugins/ocaml-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/commands/add-rfc.md",
          "type": "blob",
          "size": 2920
        },
        {
          "path": "plugins/ocaml-dev/commands/init-ocaml.md",
          "type": "blob",
          "size": 2918
        },
        {
          "path": "plugins/ocaml-dev/commands/ocaml-npm.md",
          "type": "blob",
          "size": 3139
        },
        {
          "path": "plugins/ocaml-dev/commands/port-to-dune.md",
          "type": "blob",
          "size": 3288
        },
        {
          "path": "plugins/ocaml-dev/commands/tidy.md",
          "type": "blob",
          "size": 3741
        },
        {
          "path": "plugins/ocaml-dev/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/cmdliner",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/cmdliner/SKILL.md",
          "type": "blob",
          "size": 5298
        },
        {
          "path": "plugins/ocaml-dev/skills/effects",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/effects/SKILL.md",
          "type": "blob",
          "size": 4060
        },
        {
          "path": "plugins/ocaml-dev/skills/eio",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/eio/SKILL.md",
          "type": "blob",
          "size": 10529
        },
        {
          "path": "plugins/ocaml-dev/skills/fuzz",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/fuzz/SKILL.md",
          "type": "blob",
          "size": 10629
        },
        {
          "path": "plugins/ocaml-dev/skills/jsont",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/jsont/SKILL.md",
          "type": "blob",
          "size": 6371
        },
        {
          "path": "plugins/ocaml-dev/skills/memtrace",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/memtrace/SKILL.md",
          "type": "blob",
          "size": 6133
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-code-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-code-style/SKILL.md",
          "type": "blob",
          "size": 4041
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-docs/SKILL.md",
          "type": "blob",
          "size": 4586
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-dune-migration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-dune-migration/SKILL.md",
          "type": "blob",
          "size": 3505
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-npm-publishing",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-npm-publishing/SKILL.md",
          "type": "blob",
          "size": 3246
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-project-setup",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-project-setup/SKILL.md",
          "type": "blob",
          "size": 5971
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-project-setup/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-project-setup/templates/LICENSE-ISC.md",
          "type": "blob",
          "size": 771
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-project-setup/templates/LICENSE-MIT.md",
          "type": "blob",
          "size": 1097
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-project-setup/templates/README.template.md",
          "type": "blob",
          "size": 791
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-rfc-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-rfc-integration/SKILL.md",
          "type": "blob",
          "size": 4342
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-testing/SKILL.md",
          "type": "blob",
          "size": 3620
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-tutorials",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/ocaml-tutorials/SKILL.md",
          "type": "blob",
          "size": 3314
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-BASE.md",
          "type": "blob",
          "size": 13420
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-COMPREHENSIONS.md",
          "type": "blob",
          "size": 7476
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-CORE.md",
          "type": "blob",
          "size": 13490
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-KINDS.md",
          "type": "blob",
          "size": 8321
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-MODES.md",
          "type": "blob",
          "size": 8827
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-SIMD.md",
          "type": "blob",
          "size": 12660
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-STACK-ALLOCATION.md",
          "type": "blob",
          "size": 8232
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-TEMPLATES.md",
          "type": "blob",
          "size": 7840
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-UNBOXED.md",
          "type": "blob",
          "size": 9322
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-UNIQUENESS.md",
          "type": "blob",
          "size": 8482
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL-ZERO-ALLOC.md",
          "type": "blob",
          "size": 8782
        },
        {
          "path": "plugins/ocaml-dev/skills/oxcaml/SKILL.md",
          "type": "blob",
          "size": 20112
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"ocaml-claude-marketplace\",\n  \"owner\": {\n    \"name\": \"Anil Madhavapeddy\",\n    \"email\": \"anil@recoil.org\"\n  },\n  \"metadata\": {\n    \"description\": \"OCaml development plugins for Claude Code including project setup, build migration, RFC integration, opam publishing, and code style assistance\",\n    \"version\": \"1.0.0\",\n    \"pluginRoot\": \"./plugins\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"ocaml-dev\",\n      \"source\": \"./plugins/ocaml-dev\",\n      \"description\": \"Comprehensive OCaml development toolkit with project setup, build migration, testing, RFC integration, opam publishing, and code style assistance\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Anil Madhavapeddy\",\n        \"email\": \"anil@recoil.org\"\n      },\n      \"category\": \"development\",\n      \"homepage\": \"https://github.com/avsm/ocaml-claude-marketplace\"\n    }\n  ]\n}\n",
        "plugins/ocaml-dev/.claude-plugin/plugin.json": "{\n  \"name\": \"ocaml-dev\",\n  \"description\": \"Comprehensive OCaml development toolkit with project setup, odoc documentation, build migration, testing, RFC integration, opam publishing, and code style assistance\",\n  \"author\": {\n    \"name\": \"Anil Madhavapeddy\",\n    \"email\": \"anil@recoil.org\"\n  }\n}\n",
        "plugins/ocaml-dev/README.md": "# OCaml Development Plugin\n\nComprehensive OCaml development toolkit for Claude Code.\n\n## Features\n\n### Slash Commands\n\n| Command | Description |\n|---------|-------------|\n| `/init-ocaml [name]` | Initialize a new OCaml project with dune, opam, CI, and standard files |\n| `/port-to-dune` | Migrate from ocamlbuild/topkg to dune build system |\n| `/add-rfc <number>` | Fetch IETF RFC and add OCamldoc citations |\n| `/ocaml-npm` | Set up npm publishing workflow for js_of_ocaml/wasm_of_ocaml |\n| `/tidy [path]` | Refactor OCaml code to be more idiomatic and maintainable |\n\n### Skills (Auto-invoked)\n\n#### Project & Build\n\n| Skill | Description |\n|-------|-------------|\n| ocaml-project-setup | Project structure, dune-project, .mli files, CI configuration |\n| ocaml-dune-migration | Migrating from ocamlbuild/topkg to dune (_tags, .mllib, pkg.ml) |\n| ocaml-npm-publishing | Publishing to npm via js_of_ocaml and wasm_of_ocaml |\n\n#### Code Quality\n\n| Skill | Description |\n|-------|-------------|\n| ocaml-code-style | Refactoring patterns, naming conventions, module hygiene |\n| ocaml-testing | Testing with Alcotest, Eio mocks, cram tests |\n| fuzz | Fuzz testing with Crowbar for parsers and encoders |\n\n#### Documentation\n\n| Skill | Description |\n|-------|-------------|\n| ocaml-docs | Fixing odoc warnings, reference syntax, cross-package refs |\n| ocaml-tutorials | Creating .mld tutorials with MDX executable examples |\n| ocaml-rfc-integration | Working with IETF RFCs, OCamldoc citations |\n\n#### Libraries & Frameworks\n\n| Skill | Description |\n|-------|-------------|\n| eio | Eio concurrency: fibers, switches, mocks, cohttp-eio, bytesrw |\n| cmdliner | CLI design with cmdliner following Bünzli's principles |\n| jsont | Type-safe JSON encoding/decoding with jsont |\n| effects | OCaml 5 algebraic effects design patterns |\n\n#### Performance & Advanced\n\n| Skill | Description |\n|-------|-------------|\n| memtrace | Allocation profiling to identify hotspots |\n| oxcaml | OxCaml extensions: modes, stack allocation, unboxed types, SIMD, zero-alloc |\n\n### LSP Integration\n\nIncludes ocamllsp configuration for enhanced code intelligence:\n- `.ml` - OCaml source\n- `.mli` - OCaml interface\n- `.mly` - Menhir grammar\n- `.mll` - OCamllex lexer\n\n## Configuration\n\nUser settings are read from `~/.claude/ocaml-config.json`:\n\n```json\n{\n  \"author\": {\n    \"name\": \"Your Name\",\n    \"email\": \"you@example.com\"\n  },\n  \"license\": \"ISC\",\n  \"copyright_year_start\": 2026,\n  \"ci_platform\": \"github\",\n  \"git_hosting\": {\n    \"type\": \"github\",\n    \"org\": \"username\"\n  },\n  \"opam_overlay\": {\n    \"enabled\": false,\n    \"path\": null,\n    \"name\": null\n  },\n  \"ocaml_version\": \"5.2.0\"\n}\n```\n\n### Configuration Options\n\n| Field | Description | Values |\n|-------|-------------|--------|\n| `license` | Default license for new projects | `ISC`, `MIT`, `Apache-2.0` |\n| `ci_platform` | CI system for new projects | `github`, `tangled`, `gitlab` |\n| `git_hosting.type` | Git hosting provider | `github`, `tangled`, `gitlab` |\n| `ocaml_version` | Minimum OCaml version | e.g., `5.2.0` |\n\n## Usage Examples\n\n### Create a New Project\n\n```\n/init-ocaml my-library\n```\n\nCreates:\n- dune-project with opam generation\n- Standard dune files\n- .ocamlformat, .gitignore\n- LICENSE.md, README.md\n- CI configuration\n- lib/ and test/ directories\n\n### Migrate from ocamlbuild\n\n```\n/port-to-dune\n```\n\nAnalyzes _tags, .mllib, pkg/pkg.ml and generates dune equivalents.\n\n### Add RFC Documentation\n\n```\n/add-rfc 6265\n```\n\nFetches RFC 6265 (HTTP cookies) to spec/, provides OCamldoc citation templates.\n\n### Set Up NPM Publishing\n\n```\n/ocaml-npm\n```\n\nCreates npm branch workflow for js_of_ocaml/wasm_of_ocaml output.\n\n### Refactor Code\n\n```\n/tidy lib/parser.ml\n```\n\nAnalyzes and suggests idiomatic OCaml improvements.\n\n## Template Files\n\nTemplates are in `skills/*/templates/`:\n\n- CI configurations (GitHub, Tangled, GitLab)\n- dune-project and dune file templates\n- License files (ISC, MIT)\n- Test templates (basic, Eio mock)\n- npm publishing templates\n\n## License\n\nISC License\n",
        "plugins/ocaml-dev/commands/add-rfc.md": "---\ndescription: Fetch an IETF RFC and integrate it into the project with OCamldoc citations\nargument-hint: <rfc-number>\nallowed-tools: [Read, Write, Edit, Bash, Glob, Grep, WebFetch]\n---\n\n# Add RFC\n\nThis command fetches an IETF RFC specification and integrates it into the project.\n\n## Arguments\n\nRFC number: $ARGUMENTS (required, e.g., \"6265\" for HTTP cookies)\n\n## Process\n\n### 1. Fetch the RFC\n\nFetch from IETF in plain text format:\n```\nhttps://datatracker.ietf.org/doc/html/rfc<NUMBER>.txt\n```\n\n**Important**: Always use `.txt` extension, not `.html`.\n\n### 2. Save to spec/ Directory\n\nCreate `spec/` directory if it doesn't exist and save:\n```\nspec/rfc<NUMBER>.txt\n```\n\n### 3. Parse RFC Structure\n\nExtract key information:\n- RFC title and abstract\n- Table of contents (sections)\n- Key terminology definitions\n- Related RFCs (obsoletes, updates, references)\n\n### 4. Generate OCamldoc Citation Templates\n\nProvide ready-to-use citations for:\n\n**Module-level:**\n```ocaml\n(** RFC <NUMBER> <Title>.\n\n    This module implements <description> as specified in\n    {{:https://datatracker.ietf.org/doc/html/rfc<NUMBER>}RFC <NUMBER>}.\n\n    {2 References}\n    {ul\n    {- {{:https://datatracker.ietf.org/doc/html/rfc<NUMBER>}RFC <NUMBER>} - <Title>}} *)\n```\n\n**Section-specific:**\n```ocaml\n(** Implements {{:https://datatracker.ietf.org/doc/html/rfc<NUMBER>#section-N}RFC <NUMBER> Section N}. *)\n```\n\n### 5. Suggest Integration Points\n\nSearch the codebase for:\n- Functions that might implement RFC sections\n- Existing RFC references that could be improved\n- Types that represent RFC concepts\n\n## Output\n\nProvide:\n1. Confirmation of RFC download\n2. Summary of RFC contents (title, sections)\n3. OCamldoc citation templates\n4. Suggestions for where to add citations in existing code\n\n## Example Usage\n\n```\n/add-rfc 6265\n/add-rfc 3492\n```\n\n## Success Output\n\n```\nFetched RFC 6265: HTTP State Management Mechanism\n\nSaved to: spec/rfc6265.txt\n\nRFC Summary:\n  Title: HTTP State Management Mechanism\n  Obsoletes: RFC 2965\n  Sections:\n    1. Introduction\n    2. Conventions\n    3. Overview\n    4. Server Requirements\n    5. User Agent Requirements\n    6. Implementation Considerations\n    7. Privacy Considerations\n    8. Security Considerations\n\nOCamldoc Templates:\n\nModule-level:\n(** RFC 6265 HTTP State Management Mechanism.\n\n    This module implements HTTP cookie handling as specified in\n    {{:https://datatracker.ietf.org/doc/html/rfc6265}RFC 6265}. *)\n\nSection references:\n- {{:https://datatracker.ietf.org/doc/html/rfc6265#section-4}RFC 6265 Section 4} - Server Requirements\n- {{:https://datatracker.ietf.org/doc/html/rfc6265#section-5}RFC 6265 Section 5} - User Agent Requirements\n- {{:https://datatracker.ietf.org/doc/html/rfc6265#section-5.2}RFC 6265 Section 5.2} - The Set-Cookie Header\n\nRelated RFCs you might also need:\n- RFC 2616 - HTTP/1.1 (obsoleted by RFC 7230-7235)\n- RFC 7230 - HTTP/1.1 Message Syntax and Routing\n```\n",
        "plugins/ocaml-dev/commands/init-ocaml.md": "---\ndescription: Initialize a new OCaml project with dune, opam, CI, and standard files\nargument-hint: [project-name]\nallowed-tools: [Read, Write, Edit, Bash, Glob, Grep]\n---\n\n# Initialize OCaml Project\n\nThis command creates a new OCaml project with all standard files and configuration.\n\n## Arguments\n\nProject name: $ARGUMENTS (defaults to current directory name if not provided)\n\n## Configuration\n\nRead user configuration from `~/.claude/ocaml-config.json`. If it doesn't exist, prompt the user for:\n- Author name\n- Author email\n- Preferred license (ISC, MIT, Apache-2.0)\n- CI platform (github, tangled, gitlab)\n- Git hosting (github.com/user, tangled.org/@user, gitlab.com/user)\n- OCaml version minimum (default: 5.2.0)\n\nOffer to save configuration to `~/.claude/ocaml-config.json` for future use.\n\n## Files to Create\n\n### Essential Files\n\n1. **dune-project** - Build configuration with opam generation\n2. **dune** (root) - With `(data_only_dirs third_party)`\n3. **<project>.opam** - Generated by dune (do not create manually)\n4. **.ocamlformat** - Code formatting (version 0.28.1)\n5. **.gitignore** - Standard OCaml ignores + third_party/\n6. **LICENSE.md** - Based on configured license\n7. **README.md** - Project documentation template\n\n### CI Configuration (based on ci_platform setting)\n\n- **github**: `.github/workflows/build.yml`\n- **tangled**: `.tangled/workflows/build.yml`\n- **gitlab**: `.gitlab-ci.yml`\n\n### Source Files\n\n1. **lib/dune** - Library stanza\n2. **lib/<project>.ml** - Main module with license header\n3. **lib/<project>.mli** - Interface with documentation\n\n### Test Files\n\n1. **test/dune** - Test configuration\n2. **test/test_<project>.ml** - Basic test skeleton with Alcotest\n\n## Workflow\n\n1. Check if directory is empty or confirm overwrite\n2. Read or prompt for configuration\n3. Determine project name from argument or directory\n4. Create all files using templates from the ocaml-project-setup skill\n5. Run `dune build @check` to verify setup\n6. Report success and suggest next steps\n\n## Template Variables\n\nReplace these in templates:\n- `{{PROJECT_NAME}}` - Project name (snake_case)\n- `{{PROJECT_NAME_KEBAB}}` - Project name (kebab-case)\n- `{{AUTHOR_NAME}}` - From config\n- `{{AUTHOR_EMAIL}}` - From config\n- `{{YEAR}}` - Current year\n- `{{LICENSE}}` - License identifier\n- `{{OCAML_VERSION}}` - Minimum OCaml version\n- `{{GIT_URL}}` - Full git URL based on hosting config\n\n## Example Usage\n\n```\n/init-ocaml my-library\n/init-ocaml\n```\n\n## Success Output\n\n```\nCreated OCaml project: my-library\n\nFiles created:\n  - dune-project\n  - dune\n  - .ocamlformat\n  - .gitignore\n  - LICENSE.md\n  - README.md\n  - .github/workflows/build.yml\n  - lib/dune\n  - lib/my_library.ml\n  - lib/my_library.mli\n  - test/dune\n  - test/test_my_library.ml\n\nNext steps:\n  1. Run `opam install . --deps-only` to install dependencies\n  2. Run `dune build` to build the project\n  3. Run `dune runtest` to run tests\n```\n",
        "plugins/ocaml-dev/commands/ocaml-npm.md": "---\ndescription: Set up npm publishing for OCaml projects via js_of_ocaml/wasm_of_ocaml\nargument-hint:\nallowed-tools: [Read, Write, Edit, Bash, Glob, Grep]\n---\n\n# OCaml NPM Setup\n\nThis command sets up the npm publishing workflow for OCaml projects compiled to JavaScript/WASM.\n\n## Arguments\n\nNone - operates on the current directory.\n\n## Prerequisites\n\n- Existing OCaml project with dune\n- js_of_ocaml or wasm_of_ocaml dependencies configured\n- Git repository initialized\n\n## Two-Branch Workflow\n\n```\nmain branch   - OCaml source code, dune build files, opam packages\nnpm branch    - Built JavaScript/WASM assets, package.json, README for npm\n```\n\n## Process\n\n### 1. Analyze Project\n\nDetermine:\n- Project name from dune-project\n- Existing JS build targets\n- Whether to support JS, WASM, or both\n\n### 2. Create/Update Dune Build Rules\n\nAdd or update `lib/js/dune` (or appropriate location):\n\n```dune\n(library\n (name <project>_js)\n (public_name <project>-js)\n (libraries <project> brr)\n (modes byte)\n (modules <project>_js))\n\n(executable\n (name <project>_js_main)\n (libraries <project>_js)\n (js_of_ocaml)\n (modes js wasm)\n (modules <project>_js_main))\n\n; Friendly filenames\n(rule\n (targets <project>.js)\n (deps <project>_js_main.bc.js)\n (action (copy %{deps} %{targets})))\n\n(rule\n (targets <project>.wasm.js)\n (deps <project>_js_main.bc.wasm.js)\n (action (copy %{deps} %{targets})))\n\n; Install rules\n(install\n (package <project>-js)\n (section share)\n (files\n  <project>.js\n  <project>.wasm.js\n  (glob_files_rec (<project>_js_main.bc.wasm.assets/* with_prefix <project>_js_main.bc.wasm.assets))))\n```\n\n### 3. Update dune-project\n\nAdd `-js` package if not present:\n\n```dune\n(package\n (name <project>-js)\n (synopsis \"Browser library via js_of_ocaml/wasm_of_ocaml\")\n (depends\n  (ocaml (>= 5.1.0))\n  (<project> (= :version))\n  (js_of_ocaml (>= 5.0))\n  (js_of_ocaml-ppx (>= 5.0))\n  (wasm_of_ocaml-compiler (>= 5.0))\n  (brr (>= 0.0.6))))\n```\n\n### 4. Create npm Branch\n\nCreate orphan branch with:\n- `package.json`\n- `README.md` (browser-focused)\n- `LICENSE`\n- `release.sh`\n- `.gitignore`\n\n### 5. Generate release.sh Script\n\n```bash\n#!/bin/bash\n# Release script for npm package\nset -e\n\nINSTALL_DIR=\"_build/install/default/share/<project>-js\"\n\n# ... copy JS, WASM loader, and assets\n```\n\n## Files Created\n\n### On main branch:\n- `lib/js/dune` (or updates existing)\n- Updates to `dune-project`\n\n### On npm branch (new orphan):\n- `package.json`\n- `README.md`\n- `LICENSE`\n- `release.sh`\n- `.gitignore`\n\n## Example Usage\n\n```\n/ocaml-npm\n```\n\n## Success Output\n\n```\nSet up npm publishing workflow for: my-library\n\nMain branch updates:\n  - Created lib/js/dune with JS/WASM build rules\n  - Updated dune-project with my-library-js package\n\nCreated npm branch with:\n  - package.json (name: my-library-jsoo)\n  - README.md (browser usage documentation)\n  - LICENSE\n  - release.sh (copies built assets)\n  - .gitignore\n\nWorkflow:\n  1. Develop on main branch\n  2. Build: opam exec -- dune build @install\n  3. Switch to npm: git checkout npm\n  4. Copy assets: ./release.sh\n  5. Publish: npm publish\n\nCurrent branch: main\nTo switch to npm branch: git checkout npm\n```\n",
        "plugins/ocaml-dev/commands/port-to-dune.md": "---\ndescription: Convert an ocamlbuild/topkg project to dune build system\nargument-hint:\nallowed-tools: [Read, Write, Edit, Bash, Glob, Grep]\n---\n\n# Port to Dune\n\nThis command migrates an OCaml project from ocamlbuild/topkg to dune.\n\n## Arguments\n\nNone - operates on the current directory.\n\n## Prerequisites\n\nThe command expects to find ocamlbuild artifacts:\n- `_tags` - ocamlbuild compilation flags\n- `*.mllib` files - module lists for libraries\n- `pkg/pkg.ml` - topkg package description (optional)\n- `pkg/META` - findlib metadata (optional)\n- `opam` - package dependencies\n\n## Migration Process\n\n### 1. Analyze Existing Build\n\nRead and parse:\n- `_tags` - Extract package dependencies, compiler flags, thread usage\n- `*.mllib` - Identify libraries and their modules\n- `pkg/pkg.ml` - Find optional libraries and conditions\n- `pkg/META` - Get public library names\n- `opam` - Current dependencies\n\n### 2. Create dune-project\n\n```dune\n(lang dune 3.20)\n(name <package-name>)\n(generate_opam_files true)\n; ... rest from existing opam metadata\n```\n\n### 3. Create Library dune Files\n\nFor each library identified from `.mllib` files:\n\n```dune\n(library\n (name <library_name>)\n (public_name <package.subname>)\n (libraries <dependencies>))\n```\n\nFor optional libraries (from `pkg/pkg.ml`):\n```dune\n(library\n (name <library_name>)\n (public_name <package.subname>)\n (optional)\n (libraries <dependencies>))\n```\n\n### 4. Handle Special Cases\n\n**Warning suppression** (if needed):\n```dune\n(flags (:standard -w -27))\n```\n\n**Toplevel init files** (excluded from library):\n```dune\n(library\n (name lib_name)\n (modules lib_module)\n (libraries deps))\n\n(install\n (package pkg)\n (section lib)\n (files lib_top_init.ml))\n```\n\n### 5. Create Test dune Files\n\n```dune\n(test\n (name test_name)\n (libraries lib_name alcotest))\n```\n\n### 6. Update opam File\n\n- Rename `opam` to `<package>.opam`\n- Remove ocamlbuild/topkg dependencies\n- Add dune dependency\n- Update build commands\n\n### 7. Cleanup\n\nList files to delete (don't delete automatically):\n- `_tags`\n- `.merlin`\n- `pkg/pkg.ml`\n- `pkg/META`\n- `*.mllib` files\n- `*.itarget` files\n\n## Mapping Reference\n\n| ocamlbuild | dune |\n|------------|------|\n| `_tags: package(foo)` | `(libraries foo)` |\n| `_tags: thread` | `(libraries threads)` |\n| `foo.mllib` | `(library (name foo))` |\n| `pkg/pkg.ml: Pkg.mllib ~cond:x` | `(library ... (optional))` |\n| `pkg/META` | Auto-generated by dune |\n\n## Workflow\n\n1. Search for ocamlbuild artifacts\n2. Parse each file to understand project structure\n3. Create dune-project at root\n4. Create dune files for each directory with sources\n5. Update opam file\n6. Run `dune build @check` to verify\n7. List cleanup actions for user to confirm\n\n## Example Usage\n\n```\n/port-to-dune\n```\n\n## Success Output\n\n```\nAnalyzed ocamlbuild project structure:\n  - Found 3 libraries: logs, logs_fmt, logs_browser\n  - Found 2 optional libraries: logs_fmt, logs_browser\n  - Found test executable: test_logs\n\nCreated dune files:\n  - dune-project\n  - src/dune\n  - src/fmt/dune\n  - src/browser/dune\n  - test/dune\n\nUpdated:\n  - logs.opam (renamed from opam, updated build commands)\n\nFiles to delete manually:\n  - _tags\n  - pkg/pkg.ml\n  - pkg/META\n  - src/logs.mllib\n  - src/logs_fmt.mllib\n  - src/logs_browser.mllib\n\nRun `dune build` to verify the migration.\n```\n",
        "plugins/ocaml-dev/commands/tidy.md": "---\ndescription: Refactor and tidy OCaml code to be more idiomatic and maintainable\nargument-hint: [file-or-directory]\nallowed-tools: [Read, Write, Edit, Bash, Glob, Grep]\n---\n\n# Tidy OCaml Code\n\nThis command analyzes and refactors OCaml code to make it more idiomatic, maintainable, and concise.\n\n## Arguments\n\nOptional file or directory path: $ARGUMENTS (defaults to current directory)\n\n## Analysis Categories\n\n### 1. Option and Result Patterns\n\n**Look for:**\n- Verbose match expressions that could use combinators\n- Nested Option/Result handling without let*/let+\n- Direct pattern matching where `Option.map`, `Option.bind`, etc. would be clearer\n\n**Transform:**\n```ocaml\n(* Before *)\nmatch get_value () with\n| Some x -> Some (x + 1)\n| None -> None\n\n(* After *)\nOption.map (fun x -> x + 1) (get_value ())\n```\n\n### 2. Monadic Syntax\n\n**Look for:**\n- Deeply nested match expressions on Result/Option\n- Manual error propagation chains\n\n**Transform:**\n```ocaml\n(* Before *)\nmatch fetch_user id with\n| Ok user ->\n    (match fetch_perms user with\n     | Ok perms -> Ok (user, perms)\n     | Error e -> Error e)\n| Error e -> Error e\n\n(* After *)\nlet open Result.Syntax in\nlet* user = fetch_user id in\nlet+ perms = fetch_perms user in\n(user, perms)\n```\n\n### 3. Pattern Matching vs Conditionals\n\n**Look for:**\n- Nested if/then/else chains\n- Boolean condition checking that could be pattern matching\n\n**Transform:**\n```ocaml\n(* Before *)\nif x > 0 then\n  if x < 10 then \"small\"\n  else \"large\"\nelse \"negative\"\n\n(* After *)\nmatch x with\n| x when x < 0 -> \"negative\"\n| x when x < 10 -> \"small\"\n| _ -> \"large\"\n```\n\n### 4. Code Duplication\n\n**Look for:**\n- Repeated error message patterns\n- Similar function implementations\n- Copy-pasted code blocks\n\n**Suggest:**\n- Helper functions\n- Parameterized abstractions\n- Shared error constructors\n\n### 5. Module Hygiene\n\n**Look for:**\n- Generic module names (Util, Helpers, Common)\n- Exposed record types without abstract `type t`\n- Missing pretty-printers for main types\n- Unlabeled boolean parameters\n\n### 6. Modern OCaml Patterns\n\n**Suggest:**\n- Labeled arguments for clarity\n- Local opens for syntax extensions\n- Explicit type annotations on public interfaces\n\n## Workflow\n\n1. If a specific file is given, analyze that file\n2. Otherwise, find all `.ml` and `.mli` files\n3. Analyze each file for improvement opportunities\n4. Prioritize by impact:\n   - Code duplication (highest)\n   - Verbose monadic code\n   - Module structure issues\n   - Nested conditionals\n5. Present findings with before/after examples\n6. Apply changes with user confirmation\n\n## Output Format\n\n```\nAnalysis of lib/parser.ml:\n\n1. OPTION COMBINATORS (3 occurrences)\n   Line 45: Replace match with Option.map\n   Line 89: Replace match with Option.bind\n   Line 123: Replace match with Option.value\n\n2. MONADIC SYNTAX (1 occurrence)\n   Lines 156-178: Use let*/let+ for cleaner Result chaining\n\n   Before:\n   [code snippet]\n\n   After:\n   [refactored snippet]\n\n3. CODE DUPLICATION (2 occurrences)\n   Lines 34, 67: Duplicate error construction\n   Suggestion: Create helper function `parse_error`\n\nApply changes? [y/n/select]\n```\n\n## Example Usage\n\n```\n/tidy\n/tidy lib/parser.ml\n/tidy src/\n```\n\n## Success Output\n\n```\nAnalyzed 12 OCaml files in lib/\n\nImprovements found:\n  - 8 Option/Result patterns to simplify\n  - 3 monadic chains to use let*/let+\n  - 2 code duplication instances\n  - 1 module naming issue\n\nApplied 13 changes:\n  - lib/parser.ml: 5 changes\n  - lib/types.ml: 3 changes\n  - lib/utils.ml: 5 changes (renamed to lib/string_ext.ml)\n\nReduced total lines: 847 -> 762 (-10%)\n\nSuggestions not applied (require manual review):\n  - Consider abstracting User.t type (lib/user.ml:12)\n  - Add pp function to Config module (lib/config.ml)\n```\n",
        "plugins/ocaml-dev/skills/cmdliner/SKILL.md": "---\nname: cmdliner\ndescription: \"Designing and implementing robust command-line interfaces using OCaml's cmdliner library, following Daniel Bünzli's design principles. Use when Claude needs to: (1) Design a new CLI or subcommand layout, (2) Implement cmdliner terms and combinators, (3) Enforce clear, predictable, orthogonal options, (4) Produce high-quality --help output and error messages, (5) Integrate cmdliner CLIs into dune-based OCaml projects.\"\nlicense: ISC\n---\n\n## Role\n\nYou are an expert OCaml and cmdliner practitioner who designs and implements command-line interfaces following Daniel Bünzli’s principles: clarity, predictability, orthogonality, discoverability, composability, and precise semantics.\n\nWhen asked to design or modify a CLI using cmdliner, you:\n\n- Focus on *semantically clear* commands and options.\n- Aim for *consistent, orthogonal* flags across subcommands.\n- Produce *excellent* `--help` output and error messages.\n- Provide *minimal but complete* examples that can be pasted into a project.\n\nAlways use British spelling.\n\n## When to Use This Skill\n\nUse this skill whenever the user wants to:\n\n1. Design the structure of a new CLI for an OCaml project (commands, subcommands, flags, arguments).\n2. Implement the CLI using cmdliner terms, combinators, and `Cmd.v` / `Term.t` values.\n3. Refactor an existing cmdliner-based CLI for clarity, orthogonality, or better help text.\n4. Integrate the CLI in a dune project (executables, libraries, test commands).\n5. Add logging, configuration, or environment-variable support around a cmdliner interface.\n\n## Core Design Principles\n\n7. **Economy of commands and extensibility**\n   - Prefer extending existing commands rather than adding new ones when the domain permits.\n   - Keep each command designed for future growth through well-considered flags, sub-modes, or argument structures.\n   - Avoid unnecessary expansion of the command namespace; new commands should appear only when they introduce a genuinely distinct operational domain.\n\nWhen designing or reviewing a CLI, explicitly apply the following principles and refer to them in explanations:\n\n1. **Clarity and explicitness**\n   - Each command and option has a single, clearly stated purpose.\n   - Avoid ambiguous shorthand; prefer explicit names and well-phrased docs.\n   - Make defaults explicit in documentation and error messages.\n\n2. **Predictable structure**\n   - Related operations are grouped into subcommands (e.g. `mytool build`, `mytool check`, `mytool format`).\n   - Options with similar names behave the same way across all commands.\n   - Positional arguments appear in a stable, predictable order.\n\n3. **Orthogonality**\n   - Each flag controls one independent aspect of behaviour.\n   - Avoid flags that silently alter multiple concerns.\n   - Avoid pairs of flags that only make sense in certain hidden combinations.\n\n4. **Discoverability**\n   - `--help` output is concise but complete: usage, description, arguments, options, environment, examples.\n   - Default values and accepted ranges or enumerations are documented.\n   - Errors help the user discover the correct usage instead of merely rejecting input.\n\n5. **Composability and shell-friendliness**\n   - Design for Unix-style pipelines: standard input/output, exit codes, and simple text or structured output.\n   - Avoid implicit file I/O if explicit paths or `-o` flags are possible.\n   - Offer machine-friendly output formats where relevant (e.g. JSON) and document them.\n\n6. **Precise failure modes**\n   - Error messages state *what* is wrong and *how* to fix it.\n   - Ambiguous or partial input is rejected with clear guidance.\n   - Exit codes are chosen deliberately (e.g. `0` success, `1` user error, `2` internal failure).\n\n## Cmdliner-Specific Guidance\n\nWhen writing or revising cmdliner code, follow these patterns:\n\n- Use `Cmd.v` with a `Term.t` and `Cmd.info` for each command or subcommand.\n- Keep parsing logic inside cmdliner terms and keep business logic in plain OCaml functions that receive already-parsed values.\n- Use `Arg.info` documentation strings that are short, concrete, and consistent across commands.\n- Prefer labelled arguments and records in the implementation to keep term assembly readable.\n- Ensure each CLI example you give compiles on recent OCaml and cmdliner versions.\n\n### Typical Structure\n\nWhen the user asks for a new CLI, aim to provide:\n\n1. A *command tree* sketch (top-level command, subcommands, options, arguments).\n2. Example `Cmd.t` and `Term.t` definitions.\n3. Example `dune` stanzas required to build the executable.\n4. Example usage snippets showing common workflows.\n\n## Response Format\n\nUnless the user requests otherwise, structure your responses as:\n\n1. **Overview** – brief description of the CLI design or change.\n2. **Command layout** – a tree-like view of commands, subcommands, and key options.\n3. **Cmdliner implementation** – OCaml snippets with `open Cmdliner` (or fully qualified names if clearer).\n4. **Help and examples** – sample `--help` output and real-world usage examples.\n5. **Rationale** – short notes linking the design back to the principles (clarity, orthogonality, etc.).\n\nKeep explanations concrete and focused on practical trade-offs (naming, grouping of options, error behaviour, and output formats).\n\n",
        "plugins/ocaml-dev/skills/effects/SKILL.md": "---\nname: effects\ndescription: \"OCaml 5 algebraic effects design patterns. Use when Claude needs to: (1) Design APIs that interact with effect-based schedulers, (2) Decide between effects vs exceptions, (3) Integrate libraries with Eio or affect, (4) Handle suspension vs error cases in streaming code, (5) Understand the layered effect design principle\"\nlicense: ISC\n---\n\n# OCaml 5 Effects Design\n\n## Core Principle\n\n**Effects for control flow, exceptions for errors.**\n\n| Concern | Mechanism | Example |\n|---------|-----------|---------|\n| Suspension (wait for data) | Effects | `perform Block`, `perform Yield` |\n| Error (EOF, malformed) | Exceptions | `raise End_of_file`, `Invalid_argument` |\n\n## Layered Design\n\nEffects should be handled at the **source level**, not in protocol parsers:\n\n```\nApplication\n    ↓\nProtocol parser (Binary.Reader, Cbor, etc.)\n    ↓  raises exceptions on EOF/error\nbytesrw (effect-agnostic)\n    ↓  just calls pull function\nSource (Eio flow, affect fd, Unix fd)\n    ↓  performs effects for suspension\nEffect handler (Eio scheduler, affect runtime)\n```\n\n### Why This Matters\n\n- **Parsers stay pure**: No effect dependencies, easy to test\n- **Sources control blocking**: Handler decides wait vs fail vs timeout\n- **Composability**: Same parser works with any effect system\n\n## Effect Libraries\n\n### Eio\n\nEffects are internal to the scheduler. User code looks synchronous:\n\n```ocaml\n(* Reading blocks via internal effects *)\nlet data = Eio.Flow.read flow buf\n```\n\n### affect\n\nExplicit effects for fiber scheduling:\n\n```ocaml\ntype _ Effect.t +=\n| Block : 'a block -> 'a Effect.t   (* suspension *)\n| Await : await -> unit Effect.t    (* wait on fibers *)\n| Yield : unit Effect.t             (* cooperative yield *)\n\n(* Block has callbacks for scheduler integration *)\ntype 'a block = {\n  block : handle -> unit;      (* register blocked fiber *)\n  cancel : handle -> bool;     (* handle cancellation *)\n  return : handle -> 'a        (* extract result *)\n}\n```\n\n### bytesrw\n\nEffect-agnostic streaming. The pull function you provide can perform any effects:\n\n```ocaml\n(* bytesrw just calls your function *)\nlet reader = Bytesrw.Bytes.Reader.make my_pull_fn\n\n(* If my_pull_fn performs Eio effects, they propagate *)\n(* If my_pull_fn performs affect Block, they propagate *)\n(* bytesrw doesn't care - it just calls the function *)\n```\n\n## Integration Pattern\n\nWire effect-performing sources to effect-agnostic libraries:\n\n```ocaml\n(* With Eio *)\nlet reader = Bytesrw_eio.bytes_reader_of_flow flow in\nlet r = Binary.Reader.of_reader reader in\nparse r  (* Eio effects happen in pull function *)\n\n(* With affect *)\nlet pull () =\n  let buf = Bytes.create 4096 in\n  perform (Block { block; cancel; return = fun _ ->\n    Slice.make buf ~first:0 ~length:n })\nin\nlet reader = Bytesrw.Bytes.Reader.make pull in\nparse (Binary.Reader.of_reader reader)\n```\n\n## When EOF Is Reached\n\n`Slice.eod` from bytesrw means **final EOF** - no more data will ever come.\n\n- Not \"data not ready\" (that's handled by effects in pull function)\n- Not \"try again later\" (source already waited via effects)\n- Parser should raise exception (EOF is an error condition)\n\n## Anti-Patterns\n\n**Don't**: Define `Await` effect in protocol parsers\n```ocaml\n(* WRONG - parser shouldn't know about suspension *)\nlet get_byte t =\n  if no_data then perform Await; ...\n```\n\n**Do**: Let the source handle suspension\n```ocaml\n(* RIGHT - parser just reads, source handles waiting *)\nlet get_byte t =\n  match pull_next_slice t with  (* may perform effects *)\n  | Some slice -> ...\n  | None -> raise End_of_file   (* true EOF *)\n```\n\n## References\n\n- Eio: https://github.com/ocaml-multicore/eio\n- affect: https://github.com/dbuenzli/affect\n- bytesrw: https://erratique.ch/software/bytesrw\n- OCaml effects tutorial: https://github.com/ocaml-multicore/ocaml-effects-tutorial\n- Retrofitting Effect Handlers onto OCaml (PLDI 2021): https://dl.acm.org/doi/10.1145/3453483.3454039\n- Collège de France 2023-2024 lectures on control structures: https://xavierleroy.org/CdF/2023-2024/\n",
        "plugins/ocaml-dev/skills/eio/SKILL.md": "---\nname: eio\ndescription: \"Eio concurrency patterns for OCaml applications. Use when Claude needs to: (1) Write concurrent OCaml code with Eio, (2) Handle network operations with cohttp-eio, (3) Manage resource lifecycles with switches, (4) Implement rate limiting or synchronization, (5) Create parallel operations with fibers, (6) Test async code with Eio_mock, (7) Integrate with bytesrw for streaming, or any other Eio-based concurrency tasks\"\nlicense: ISC\n---\n\n# Eio Concurrency\n\n## Core Concepts\n\n### Why Eio\n\nEio is an effects-based IO library for OCaml 5. Advantages over Lwt/Async:\n\n- **Direct-style code**: No monads, concurrent code looks like sequential code\n- **Performance**: Real stacks, no heap allocations to simulate continuations\n- **Better backtraces**: Exceptions show proper call traces\n- **Platform optimization**: Generic API with optimized backends (Linux io_uring, POSIX, Windows)\n\n### Capability-Based Design\n\nPass capabilities explicitly instead of using global resources:\n\n```ocaml\ntype t = {\n  net : _ Eio.Net.t;\n  clock : _ Eio.Time.clock;\n  fs : _ Eio.Path.t;\n}\n\n(* Function signature reveals what resources it needs *)\nval connect : net:_ Eio.Net.t -> host:string -> connection\n```\n\n**Do**: Pass `net`, `clock`, `fs` explicitly—makes dependencies clear and testable.\n\n**Don't**: Use global modules like `Unix.gettimeofday` or access ambient resources.\n\n### Structured Concurrency with Switches\n\n`Eio.Switch.run` manages resource and fiber lifecycles:\n\n```ocaml\nEio.Switch.run @@ fun sw ->\n  let conn = connect ~sw server in\n  (* conn automatically closed when sw exits *)\n  process conn\n```\n\n**Do**: Create switches in the smallest possible scope.\n\n**Don't**: Take a switch argument if you could create one internally.\n\n### Fibers\n\nLightweight concurrent units running on a single core:\n\n```ocaml\n(* Run two operations concurrently *)\nEio.Fiber.both\n  (fun () -> download file1)\n  (fun () -> download file2)\n\n(* Only one fiber executes at a time until one performs an effect *)\n```\n\n### Cancellation\n\nCancellation contexts form a tree. Uncaught exceptions propagate upward, cancelling siblings:\n\n```ocaml\n(* If one branch fails, the other gets Cancelled *)\nEio.Fiber.both\n  (fun () -> may_fail ())\n  (fun () -> other_work ())  (* receives Cancelled if may_fail raises *)\n```\n\nUse `Cancel.protect` for operations that must complete:\n\n```ocaml\nEio.Cancel.protect @@ fun () ->\n  (* This won't be cancelled even if parent is *)\n  flush_and_close connection\n```\n\n## Common Patterns\n\n### Concurrent Operations\n\n```ocaml\n(* Parallel map *)\nlet fetch_all_items api item_ids =\n  Eio.Fiber.List.map (fun id -> Api.item_info api id) item_ids\n\n(* Race with timeout *)\nlet with_timeout ~clock duration fn =\n  Eio.Fiber.first\n    (fun () -> Eio.Time.sleep clock duration; Error `Timeout)\n    (fun () -> Ok (fn ()))\n\n(* Fork background task attached to switch *)\nEio.Fiber.fork ~sw (fun () -> background_work ())\n```\n\n### File Operations\n\n```ocaml\nlet ( / ) = Eio.Path.( / )\n\n(* Read file *)\nlet content = Eio.Path.load (fs / \"config.json\")\n\n(* Write file with permissions *)\nEio.Path.save ~create:(`Or_truncate 0o600) (fs / \"data.bin\") content\n\n(* Create directory if needed *)\nEio.Path.mkdirs ~exists_ok:true ~perm:0o755 (fs / \"cache\")\n\n(* Clean up directory tree *)\nEio.Path.rmtree (fs / \"tmp\")\n\n(* Check file type *)\nmatch Eio.Path.kind ~follow:true path with\n| `Directory -> ...\n| `Regular_file -> ...\n| `Not_found -> ...\n```\n\n### Network Operations\n\n```ocaml\n(* TCP client *)\nEio.Net.connect ~sw net (`Tcp (addr, port))\n\n(* TCP server *)\nEio.Net.run_server sock ~on_error:log_error\n  ~max_connections:100\n  (fun ~sw flow addr -> handle_client ~sw flow)\n```\n\n### HTTPS with cohttp-eio\n\n```ocaml\nlet https_handler uri raw_flow =\n  let tls_config = create_tls_config () in\n  let host = Uri.host uri |> Option.map Domain_name.(host_exn % of_string_exn) in\n  Tls_eio.client_of_flow ?host tls_config raw_flow\n\nlet client = Cohttp_eio.Client.make net ~https:(Some https_handler)\n```\n\n### Buffered Reading\n\nAlways use `max_size` to prevent memory exhaustion:\n\n```ocaml\nlet body = Eio.Buf_read.(of_flow ~max_size:10_000_000 flow |> take_all)\n```\n\n### Synchronization Primitives\n\n**Mutex**:\n```ocaml\nlet mutex = Eio.Mutex.create ()\nEio.Mutex.use_rw mutex (fun () -> shared_state := new_value)\n```\n\n**Semaphore for rate limiting**:\n```ocaml\nlet limiter = Eio.Semaphore.make 10\nlet with_rate_limit fn =\n  Eio.Semaphore.acquire limiter;\n  Fun.protect ~finally:(fun () -> Eio.Semaphore.release limiter) fn\n```\n\n**Stream for producer/consumer**:\n```ocaml\nlet queue = Eio.Stream.create 100\nEio.Stream.add queue item      (* producer *)\nlet item = Eio.Stream.take queue  (* consumer, blocks if empty *)\n```\n\n**Condition variables** (must check in loop):\n```ocaml\nlet cond = Eio.Condition.create ()\nlet mutex = Eio.Mutex.create ()\n\n(* Waiter - MUST use while loop *)\nEio.Mutex.use_rw ~protect:false mutex (fun () ->\n  while not (check_condition ()) do\n    Eio.Condition.await cond mutex\n  done)\n\n(* Signaler *)\nEio.Condition.broadcast cond\n```\n\n## Integration with bytesrw\n\nBridge Eio flows to bytesrw for streaming binary parsing:\n\n```ocaml\n(* Eio flow → bytesrw reader *)\nlet reader_of_flow ?(buf_len = 4096) flow =\n  let cs = Cstruct.create buf_len in\n  let read () =\n    match Eio.Flow.single_read flow cs with\n    | 0 -> Bytesrw.Bytes.Slice.eod\n    | n ->\n        let buf = Cstruct.to_bytes (Cstruct.sub cs 0 n) in\n        Bytesrw.Bytes.Slice.make buf ~first:0 ~length:n\n    | exception End_of_file -> Bytesrw.Bytes.Slice.eod\n  in\n  Bytesrw.Bytes.Reader.make read\n\n(* Then use with Binary.Reader *)\nlet r = Binary.Reader.of_reader (reader_of_flow flow)\nlet frame = Tc_frame.parse r  (* effects propagate through *)\n```\n\nNote: This involves a copy from Cstruct (Bigarray) to bytes (heap). Unavoidable until OCaml has non-moving bytes.\n\n## RNG Initialization\n\n**Critical for crypto**: Initialize RNG before any crypto operations.\n\n```ocaml\n(* For Eio applications *)\nEio_main.run @@ fun env ->\n  Mirage_crypto_rng_eio.run (module Mirage_crypto_rng.Fortuna) env @@ fun () ->\n    (* RNG now available *)\n    let iv = Mirage_crypto_rng.generate 12 in\n    ...\n\n(* For Unix applications (simpler but less integrated) *)\nMirage_crypto_rng_unix.initialize (module Mirage_crypto_rng.Fortuna)\n```\n\nFailure to initialize results in predictable random numbers, breaking crypto security.\n\n## Error Handling\n\nErrors use `Eio.Io (err, context)` with nested error codes:\n\n```ocaml\ntry\n  Eio.Net.connect ~sw net addr\nwith\n| Eio.Io (Eio.Net.E (Connection_failure _), _) ->\n    (* Specific error *)\n    Error `Connection_failed\n| Eio.Io (Eio.Net.E _, _) ->\n    (* Any network error *)\n    Error `Network_error\n| Eio.Io _ ->\n    (* Any Eio error *)\n    Error `Io_error\n```\n\nAdd context when re-raising:\n\n```ocaml\nEio.Exn.reraise_with_context exn \"while connecting to %s\" host\n```\n\nFor tests, hide backend details:\n\n```ocaml\nEio.Exn.Backend.show := false\n```\n\n## Testing with Eio_mock\n\nLibrary: `eio.mock` (not `eio_mock`)\n\n### Test Setup Pattern\n\n```ocaml\nlet setup_test f () =\n  Mirage_crypto_rng_unix.use_default ();  (* or initialize RNG *)\n  Eio_main.run @@ fun env ->\n  Eio.Switch.run @@ fun sw ->\n  let fs = Eio.Stdenv.fs env in\n  let tmp = Eio.Path.(fs / Filename.get_temp_dir_name () / \"test-dir\") in\n  (try Eio.Path.rmtree tmp with _ -> ());\n  Eio.Path.mkdirs ~exists_ok:true ~perm:0o755 tmp;\n  Fun.protect\n    ~finally:(fun () -> try Eio.Path.rmtree tmp with _ -> ())\n    (fun () -> f ~sw tmp)\n\nlet test_something = setup_test @@ fun ~sw tmp ->\n  (* test code here *)\n```\n\n### Mock Flow\n\n```ocaml\nlet test_api_call () =\n  Eio_main.run @@ fun _env ->\n  let flow = Eio_mock.Flow.make \"response\" in\n  (* IMPORTANT: Always end with `Raise End_of_file *)\n  Eio_mock.Flow.on_read flow [\n    `Return \"{\\\"ok\\\": true}\";\n    `Raise End_of_file;\n  ];\n  (* use flow *)\n```\n\n### Simulating Chunked Data\n\n```ocaml\nlet test_partial_reads () =\n  Eio_main.run @@ fun _env ->\n  let flow = Eio_mock.Flow.make \"chunked\" in\n  Eio_mock.Flow.on_read flow [\n    `Return \"\\x00\\x01\";      (* First 2 bytes *)\n    `Return \"\\x02\\x03\";      (* Next 2 bytes *)\n    `Raise End_of_file;\n  ];\n  (* Parser must handle values spanning chunks *)\n```\n\n### Mock Network\n\n```ocaml\nlet test_network () =\n  Eio_main.run @@ fun _env ->\n  let net = Eio_mock.Net.make \"mocknet\" in\n  let flow = Eio_mock.Flow.make \"conn\" in\n  Eio_mock.Net.on_connect net [`Return flow];\n  Eio_mock.Flow.on_read flow [`Return \"data\"; `Raise End_of_file];\n  (* test network operations *)\n```\n\n### Deadlock Detection\n\n`Eio_mock.Backend.run` automatically detects deadlocks in tests.\n\n## Common Gotchas\n\n| Issue | Problem | Solution |\n|-------|---------|----------|\n| Racing reads | Both reads may complete at kernel level | Don't rely on `Fiber.first` for mutual exclusion |\n| Signal handlers | Most operations risk deadlock | Only `Eio.Condition.broadcast` is safe |\n| Condition spurious wakeup | May wake without signal | Always check condition in `while` loop |\n| Mutex in signal handler | Re-entrancy issues | Use conditions instead |\n| Forgetting End_of_file | Mock flow hangs | Always end mock reads with `Raise End_of_file` |\n| Missing RNG init | Predictable crypto | Initialize before any crypto operations |\n\n## Library Integration\n\n| Library | Purpose | Notes |\n|---------|---------|-------|\n| Lwt_eio | Run Lwt + Eio together | Gradual migration path |\n| Async_eio | Run Async + Eio together | Experimental |\n| bytesrw | Streaming byte parsing | Requires copy (Cstruct→bytes) |\n| cohttp-eio | HTTP client/server | Native Eio support |\n| tls-eio | TLS connections | Use with cohttp-eio for HTTPS |\n| mirage-crypto-rng-eio | Crypto RNG | Required for crypto operations |\n\n## Best Practices\n\n| Practice | Description |\n|----------|-------------|\n| Capability passing | Pass `net`, `clock`, `fs` explicitly |\n| Structured concurrency | Use `Switch.run`, keep scopes small |\n| Handle errors at boundaries | Convert `Eio.Io` to domain errors |\n| Buffered reading | Use `Buf_read` with `max_size` |\n| Parallel with fibers | `Fiber.List.map`, `Fiber.both`, `Fiber.first` |\n| Isolate blocking | `Eio_unix.run_in_systhread` for non-Eio blocking |\n| Test with mocks | `Eio_mock` for deterministic tests |\n| Initialize RNG | Before any crypto operations |\n\n## References\n\n- Eio repository: https://github.com/ocaml-multicore/eio\n- Eio documentation: https://ocaml.org/p/eio/latest/doc/\n- cohttp-eio: https://github.com/mirage/ocaml-cohttp\n- bytesrw: https://erratique.ch/software/bytesrw\n",
        "plugins/ocaml-dev/skills/fuzz/SKILL.md": "---\nname: fuzz\ndescription: \"OCaml fuzz testing with Crowbar for protocol implementations. Use when Claude needs to: (1) Write fuzz tests for parsers and encoders, (2) Test roundtrip invariants (parse(encode(x)) = x), (3) Verify boundary conditions and error handling, (4) Test state machines and transitions, (5) Organize fuzz test suites for large codebases\"\nlicense: ISC\n---\n\n# OCaml Fuzz Testing with Crowbar\n\n## Core Philosophy\n\n1. **One fuzz file per module**: `fuzz_foo.ml` tests `lib/foo.ml`. Keeps tests organized and discoverable.\n2. **Roundtrip everything**: If you have `encode` and `decode`, test `decode(encode(x)) = x`.\n3. **Crash-safety first**: Parsers must never crash on arbitrary input, even malformed data.\n4. **Boundary conditions matter**: Test edge cases (0, max values, empty input, overflow).\n5. **State machines need transition coverage**: Test all valid and invalid state transitions.\n\n## Build Configuration\n\n### Dune setup for fuzz tests\n\n```lisp\n(executable\n (name fuzz)\n (libraries crowbar borealis)\n (modules\n  fuzz\n  fuzz_common\n  fuzz_foo\n  fuzz_bar))\n```\n\n### Main entry point (`fuzz/fuzz.ml`)\n\n```ocaml\n(* Force linking of modules that register tests via side effects *)\nlet () =\n  Fuzz_common.run ();\n  Fuzz_foo.run ();\n  Fuzz_bar.run ()\n```\n\nEach fuzz module ends with:\n\n```ocaml\nlet run () = ()\n```\n\nThis ensures the module is linked and its `add_test` calls execute.\n\n---\n\n## Test Patterns\n\n### 1. Crash-safety test (parsers must not crash)\n\n```ocaml\nopen Crowbar\nopen Fuzz_common\n\nlet () =\n  add_test ~name:\"foo: decode\" [ bytes ] @@ fun buf ->\n  (match Foo.decode (to_bytes buf) with\n   | Ok _ -> ()\n   | Error _ -> ());\n  check true\n```\n\n**Key points**:\n- Use `bytes` generator for arbitrary binary input\n- Match both `Ok` and `Error` branches (don't crash on either)\n- `check true` signals test passed\n\n### 2. Roundtrip test (encode/decode pairs)\n\n```ocaml\nlet () =\n  add_test ~name:\"foo: roundtrip\" [ bytes ] @@ fun buf ->\n  match Foo.decode (to_bytes buf) with\n  | Error _ -> check true  (* Invalid input is fine *)\n  | Ok original ->\n      let encoded = Foo.encode original in\n      match Foo.decode encoded with\n      | Error _ -> fail \"re-decode failed\"\n      | Ok decoded ->\n          if original <> decoded then fail \"roundtrip mismatch\"\n          else check true\n```\n\n**Key points**:\n- If initial decode fails, that's OK (input was invalid)\n- If re-decode fails after encode, that's a bug\n- Compare original and decoded values\n\n### 3. Constrained type roundtrip (smart constructors)\n\n```ocaml\n(* For types with range constraints like 11-bit APID (0-2047) *)\nlet () =\n  add_test ~name:\"apid: roundtrip\" [ range 2048 ] @@ fun n ->\n  match Apid.of_int n with\n  | None -> check (n < 0 || n > 2047)  (* Correctly rejected *)\n  | Some apid ->\n      let n' = Apid.to_int apid in\n      if n <> n' then fail \"roundtrip mismatch\"\n      else check true\n```\n\n### 4. Boundary tests\n\n```ocaml\n(* Test boundary values explicitly *)\nlet () =\n  add_test ~name:\"apid: max_valid\" [ const () ] @@ fun () ->\n  match Apid.of_int 2047 with\n  | None -> fail \"2047 should be valid\"\n  | Some apid ->\n      if Apid.to_int apid <> 2047 then fail \"value mismatch\"\n      else check true\n\nlet () =\n  add_test ~name:\"apid: min_valid\" [ const () ] @@ fun () ->\n  match Apid.of_int 0 with\n  | None -> fail \"0 should be valid\"\n  | Some apid ->\n      if Apid.to_int apid <> 0 then fail \"value mismatch\"\n      else check true\n```\n\n**Key points**:\n- Use `[ const () ]` for tests with no random input\n- Never use `[]` as generator list (causes type error)\n\n### 5. Invalid input rejection\n\n```ocaml\n(* Values above max must be rejected *)\nlet () =\n  add_test ~name:\"apid: invalid_above\" [ range 1000 ] @@ fun n ->\n  let invalid = 2048 + n in\n  match Apid.of_int invalid with\n  | None -> check true\n  | Some _ -> fail \"should reject values > 2047\"\n\n(* Negative values must be rejected *)\nlet () =\n  add_test ~name:\"apid: invalid_negative\" [ range 1000 ] @@ fun n ->\n  let invalid = -(n + 1) in\n  match Apid.of_int invalid with\n  | None -> check true\n  | Some _ -> fail \"should reject negative values\"\n```\n\n### 6. Pretty-printer safety\n\n```ocaml\n(* pp functions must never crash *)\nlet () =\n  add_test ~name:\"foo: pp\" [ bytes ] @@ fun buf ->\n  match Foo.decode (to_bytes buf) with\n  | Error _ -> check true\n  | Ok v ->\n      let _ = Format.asprintf \"%a\" Foo.pp v in\n      check true\n```\n\n### 7. State machine transitions\n\n```ocaml\n(* Test valid state transitions *)\nlet () =\n  add_test ~name:\"key: activate Pending\" [ uint8; uint8; bytes ]\n  @@ fun kid algo material_buf ->\n  let material = to_bytes material_buf in\n  if Bytes.length material > 0 then begin\n    let key = Key.v ~kid ~algorithm:algo ~material in\n    match Key.activate key with\n    | Error _ -> check true  (* May fail if material invalid *)\n    | Ok active_key ->\n        if Key.state active_key <> Key.Active then fail \"wrong state\"\n        else check true\n  end\n  else check true\n\n(* Test invalid state transitions return errors *)\nlet () =\n  add_test ~name:\"key: activate Empty fails\" [ uint8; uint8 ]\n  @@ fun kid algo ->\n  let key = Key.empty ~kid ~algorithm:algo in\n  match Key.activate key with\n  | Ok _ -> fail \"should fail on Empty key\"\n  | Error (Key.Invalid_state_transition _) -> check true\n  | Error _ -> fail \"wrong error type\"\n```\n\n### 8. Unit conversion roundtrips\n\n```ocaml\n(* Test all unit conversions *)\nlet () =\n  add_test ~name:\"duration: ns_roundtrip\" [ int64 ] @@ fun n ->\n  let d = Duration.of_ns n in\n  let n' = Duration.to_ns d in\n  if n <> n' then fail \"ns roundtrip mismatch\"\n  else check true\n\n(* Test cross-unit conversions *)\nlet () =\n  add_test ~name:\"duration: us_to_ms\" [ range 1000000 ] @@ fun n ->\n  let us = Int64.of_int n in\n  let d = Duration.of_us us in\n  let ms = Duration.to_ms d in\n  let expected = Int64.div us 1000L in\n  if ms <> expected then fail \"us to ms conversion failed\"\n  else check true\n```\n\n### 9. Filestore/resource operations\n\n```ocaml\n(* Test create/exists invariant *)\nlet () =\n  add_test ~name:\"filestore: create_exists\" [ bytes ] @@ fun name_buf ->\n  let name = Bytes.to_string (to_bytes name_buf) in\n  if String.length name = 0 then check true\n  else\n    let fs = Filestore.in_memory () in\n    match Filestore.create fs name with\n    | Error _ -> check true\n    | Ok () ->\n        if not (Filestore.exists fs name) then\n          fail \"created file should exist\"\n        else check true\n```\n\n---\n\n## Common Module: fuzz_common.ml\n\n```ocaml\n(** Common utilities for fuzz tests. *)\n\nopen Crowbar\n\nlet to_bytes buf =\n  let len = String.length buf in\n  let b = Bytes.create len in\n  Bytes.blit_string buf 0 b 0 len;\n  b\n\nlet catch_invalid_arg f =\n  try f () with Invalid_argument _ -> check true\n\nlet run () = ()\n```\n\n---\n\n## Generators Reference\n\n| Generator | Type | Use for |\n|-----------|------|---------|\n| `bytes` | `string` | Arbitrary binary data |\n| `uint8` | `int` | 0-255 |\n| `int8` | `int` | -128 to 127 |\n| `int32` | `int32` | Full int32 range |\n| `int64` | `int64` | Full int64 range |\n| `range n` | `int` | 0 to n-1 |\n| `bool` | `bool` | true/false |\n| `const v` | `'a` | Fixed value (for no-input tests) |\n| `list gen` | `'a list` | Lists of generated values |\n| `option gen` | `'a option` | Some/None |\n\n---\n\n## File Organization\n\n```\nfuzz/\n├── fuzz.ml              # Main entry, links all modules\n├── fuzz_common.ml       # Shared utilities\n├── fuzz_tc_frame.ml     # Tests for lib/frames/tc_frame.ml\n├── fuzz_tm_frame.ml     # Tests for lib/frames/tm_frame.ml\n├── fuzz_apid.ml         # Tests for lib/frames/apid.ml\n├── fuzz_keyid.ml        # Tests for lib/sdls/keyid.ml\n└── ...\n```\n\n**Naming convention**: `fuzz_<module>.ml` tests `lib/**/<module>.ml`\n\n---\n\n## Running Fuzz Tests\n\n### Without AFL (quick check)\n\n```bash\ndune exec fuzz/fuzz.exe\n```\n\n### With AFL (thorough fuzzing)\n\n```bash\ndune build fuzz/fuzz.exe\nmkdir -p fuzz/input\necho -n \"\" > fuzz/input/empty\nafl-fuzz -m none -i fuzz/input -o _fuzz -- \\\n  _build/default/fuzz/fuzz.exe @@\n```\n\n### Check for duplicate test names\n\n```bash\ngrep -h 'add_test ~name:\"' fuzz/fuzz_*.ml | \\\n  sed 's/.*~name:\"\\([^\"]*\\)\".*/\\1/' | sort | uniq -d\n```\n\n---\n\n## Coverage Checklist\n\nFor each module with a public API (`.mli` file):\n\n- [ ] **Crash safety**: All `decode_*`, `parse_*`, `read_*`, `of_*` functions\n- [ ] **Roundtrip**: All `encode`/`decode`, `to_*`/`of_*` pairs\n- [ ] **Boundaries**: Min/max valid values, edge cases\n- [ ] **Invalid input**: Values outside valid range rejected\n- [ ] **State machines**: All transitions (valid and invalid)\n- [ ] **Pretty-printers**: All `pp_*` functions don't crash\n- [ ] **Comparison**: `equal` and `compare` are consistent\n\n---\n\n## Priority Order\n\nWhen adding fuzz tests to a codebase:\n\n1. **Security-critical**: Crypto primitives, authentication, key management\n2. **Protocol parsers**: Wire format decoders, frame parsers\n3. **State machines**: Lifecycle transitions, session state\n4. **Constrained types**: Smart constructors, ID validators\n5. **Utility functions**: Encoding helpers, time conversions\n\n---\n\n## Common Mistakes\n\n### Wrong: Empty generator list with function\n\n```ocaml\n(* ERROR: This expression should not be a function *)\nadd_test ~name:\"test\" [] @@ fun () -> ...\n```\n\n### Right: Use `const ()` for no-input tests\n\n```ocaml\nadd_test ~name:\"test\" [ const () ] @@ fun () -> ...\n```\n\n### Wrong: Ignoring error cases\n\n```ocaml\n(* BAD: Only tests happy path *)\nadd_test ~name:\"foo: decode\" [ bytes ] @@ fun buf ->\n  let Ok v = Foo.decode (to_bytes buf) in\n  check true\n```\n\n### Right: Handle both Ok and Error\n\n```ocaml\nadd_test ~name:\"foo: decode\" [ bytes ] @@ fun buf ->\n  (match Foo.decode (to_bytes buf) with\n   | Ok _ -> ()\n   | Error _ -> ());\n  check true\n```\n\n### Wrong: Asserting on invalid input\n\n```ocaml\n(* BAD: Fails on invalid input *)\nadd_test ~name:\"foo: roundtrip\" [ bytes ] @@ fun buf ->\n  match Foo.decode (to_bytes buf) with\n  | Error _ -> fail \"decode failed\"  (* Wrong! Invalid input is expected *)\n  | Ok v -> ...\n```\n\n### Right: Accept invalid input gracefully\n\n```ocaml\nadd_test ~name:\"foo: roundtrip\" [ bytes ] @@ fun buf ->\n  match Foo.decode (to_bytes buf) with\n  | Error _ -> check true  (* Invalid input is fine *)\n  | Ok v -> ...\n```\n\n---\n\n## Expected Outputs\n\nWhen adding fuzz tests, produce:\n\n1. **New fuzz file**: `fuzz/fuzz_<module>.ml` with comprehensive tests\n2. **Update fuzz.ml**: Add `Fuzz_<module>.run ()` call\n3. **Verify build**: `dune build` succeeds\n4. **No duplicates**: Test names are unique across all fuzz files\n5. **Coverage summary**: List of tests added and what they cover\n",
        "plugins/ocaml-dev/skills/jsont/SKILL.md": "---\nname: jsont\ndescription: \"JSON type-safe encoding and decoding using the OCaml jsont library. Use when Claude needs to: define typed JSON codecs for OCaml record types, parse JSON strings to OCaml values, or serialize OCaml values to JSON, or work with nested JSON structures\"\nlicense: ISC\n---\n\n# Jsont JSON Encoding/Decoding\n\n## Dependencies\n\n```dune\n(libraries jsont jsont.bytesrw)\n```\n\n## Core Patterns\n\n### Simple Object Codec\n\nMap a JSON object to an OCaml record using `Jsont.Object.map` with `mem` for required fields:\n\n```ocaml\ntype header = {\n  message_id : string;\n  method_ : string;\n  timestamp : int;\n}\n\nlet header_codec =\n  Jsont.Object.map ~kind:\"header\"\n    (fun message_id method_ timestamp -> { message_id; method_; timestamp })\n  |> Jsont.Object.mem \"messageId\" Jsont.string ~enc:(fun h -> h.message_id)\n  |> Jsont.Object.mem \"method\" Jsont.string ~enc:(fun h -> h.method_)\n  |> Jsont.Object.mem \"timestamp\" Jsont.int ~enc:(fun h -> h.timestamp)\n  |> Jsont.Object.finish\n```\n\n### Optional Fields\n\nUse `opt_mem` for optional JSON fields. The constructor receives `'a option`:\n\n```ocaml\ntype config = {\n  name : string;\n  timeout : int;  (* default if missing *)\n}\n\nlet config_codec =\n  Jsont.Object.map ~kind:\"config\"\n    (fun name timeout_opt ->\n      { name; timeout = Option.value ~default:30 timeout_opt })\n  |> Jsont.Object.mem \"name\" Jsont.string ~enc:(fun c -> c.name)\n  |> Jsont.Object.opt_mem \"timeout\" Jsont.int ~enc:(fun c -> Some c.timeout)\n  |> Jsont.Object.finish\n```\n\n### Skip Unknown Fields\n\nUse `skip_unknown` before `finish` to ignore extra JSON fields (tolerant parsing):\n\n```ocaml\nlet tolerant_codec =\n  Jsont.Object.map ~kind:\"data\" (fun id -> { id })\n  |> Jsont.Object.mem \"id\" Jsont.string ~enc:(fun d -> d.id)\n  |> Jsont.Object.skip_unknown  (* ignore extra fields *)\n  |> Jsont.Object.finish\n```\n\n### Nested Objects\n\nCompose codecs for nested structures:\n\n```ocaml\ntype request = { header : header; payload : payload }\n\nlet request_codec payload_codec =\n  Jsont.Object.map ~kind:\"request\" (fun header payload -> { header; payload })\n  |> Jsont.Object.mem \"header\" header_codec ~enc:(fun r -> r.header)\n  |> Jsont.Object.mem \"payload\" payload_codec ~enc:(fun r -> r.payload)\n  |> Jsont.Object.finish\n```\n\n### Lists\n\nUse `Jsont.list` for JSON arrays:\n\n```ocaml\ntype response = { items : item list }\n\nlet response_codec =\n  Jsont.Object.map ~kind:\"response\" (fun items -> { items })\n  |> Jsont.Object.mem \"items\" (Jsont.list item_codec) ~enc:(fun r -> r.items)\n  |> Jsont.Object.finish\n```\n\n### String Maps\n\nUse `Jsont.Object.as_string_map` for objects with dynamic keys:\n\n```ocaml\nmodule String_map = Map.Make(String)\n\n(* JSON: {\"key1\": \"value1\", \"key2\": \"value2\"} *)\nlet string_map_codec = Jsont.Object.as_string_map Jsont.string\n\n(* JSON: {\"group1\": [...], \"group2\": [...]} *)\nlet groups_codec = Jsont.Object.as_string_map (Jsont.list item_codec)\n```\n\n### Empty Object\n\nFor payloads that don't carry data:\n\n```ocaml\nlet empty_payload_codec : unit Jsont.t =\n  Jsont.Object.map ~kind:\"empty\" ()\n  |> Jsont.Object.skip_unknown\n  |> Jsont.Object.finish\n```\n\n### Custom Value Mapping\n\nUse `Jsont.map` to transform between types:\n\n```ocaml\ntype device_type = Sonos | Meross | Other\n\nlet device_from_string =\n  Jsont.map ~kind:\"device_type\"\n    ~dec:(function \"sonos\" -> Sonos | \"meross\" -> Meross | _ -> Other)\n    ~enc:(function Sonos -> \"sonos\" | Meross -> \"meross\" | Other -> \"other\")\n    Jsont.string\n```\n\n### Polymorphic Decoding with `any`\n\nHandle multiple JSON shapes for backwards compatibility:\n\n```ocaml\n(* Device can be string (old format) or object (new format) *)\nlet device_compat_codec =\n  Jsont.any ~kind:\"device\"\n    ~dec_string:device_from_string_codec  (* handles \"192.168.1.1\" *)\n    ~dec_object:device_object_codec       (* handles {\"ip\": \"...\", \"type\": \"...\"} *)\n    ~enc:(fun _ -> device_object_codec)   (* always encode as object *)\n    ()\n```\n\n### Null Values\n\nUse `Jsont.null` for endpoints returning null:\n\n```ocaml\n(* For DELETE endpoints that return null on success *)\nmatch delete http ~sw token endpoint (Jsont.null ()) with\n| Ok () -> ...\n```\n\n### Generic JSON\n\nUse `Jsont.json` to preserve arbitrary JSON:\n\n```ocaml\ntype characteristic = {\n  iid : int;\n  value : Jsont.json option;  (* preserve any JSON value *)\n}\n\nlet char_codec =\n  Jsont.Object.map ~kind:\"char\" (fun iid value -> { iid; value })\n  |> Jsont.Object.mem \"iid\" Jsont.int ~enc:(fun c -> c.iid)\n  |> Jsont.Object.opt_mem \"value\" Jsont.json ~enc:(fun c -> c.value)\n  |> Jsont.Object.finish\n```\n\n## Encoding and Decoding\n\nUse `Jsont_bytesrw` for string-based encoding/decoding:\n\n```ocaml\n(* Decode JSON string to OCaml value *)\nlet decode codec s = Jsont_bytesrw.decode_string codec s\n(* Returns: ('a, Jsont.Error.t) result *)\n\n(* Encode OCaml value to JSON string *)\nlet encode codec v =\n  match Jsont_bytesrw.encode_string codec v with\n  | Ok s -> s\n  | Error _ -> \"{}\"  (* fallback for encoding errors *)\n\n(* Usage *)\nmatch Jsont_bytesrw.decode_string config_codec json_string with\n| Ok config -> (* use config *)\n| Error e -> (* handle error *)\n\nmatch Jsont_bytesrw.encode_string config_codec config with\n| Ok json_str -> (* send json_str *)\n| Error _ -> (* handle error *)\n```\n\n## Common Helpers\n\nDefine module-level helpers for cleaner code:\n\n```ocaml\nlet decode codec s = Jsont_bytesrw.decode_string codec s\n\nlet encode codec v =\n  match Jsont_bytesrw.encode_string codec v with\n  | Ok s -> s\n  | Error _ -> \"\"\n```\n\n## Base Types Reference\n\n| OCaml Type | Jsont Codec | JSON Type |\n|------------|-------------|-----------|\n| `string` | `Jsont.string` | string |\n| `int` | `Jsont.int` | number |\n| `float` | `Jsont.number` | number |\n| `bool` | `Jsont.bool` | boolean |\n| `'a list` | `Jsont.list codec` | array |\n| `'a option` | `Jsont.option codec` | value or null |\n| `unit` | `Jsont.null ()` | null |\n| generic | `Jsont.json` | any JSON |\n\n## Best Practices\n\n1. **Always use `~kind`**: Provide descriptive kind names for better error messages\n2. **Use `skip_unknown` for external APIs**: Be tolerant of extra fields from third-party services\n3. **Prefer `opt_mem` with defaults**: Handle missing fields gracefully with `Option.value ~default:`\n4. **Compose small codecs**: Build complex structures from simple, reusable codecs\n5. **Define helper functions**: Create `decode`/`encode` helpers at module level for cleaner usage\n",
        "plugins/ocaml-dev/skills/memtrace/SKILL.md": "---\nname: memtrace\ndescription: \"OCaml memtrace profiling for allocation hotspot analysis. Use when Claude needs to: (1) Add memtrace instrumentation to OCaml executables, (2) Run targeted benchmarks with tracing enabled, (3) Identify allocation hotspots from trace output, (4) Optimize code to reduce boxing and allocations, (5) Validate optimizations with before/after comparisons\"\nlicense: ISC\n---\n\n## system_prompt\n\nYou are a specialised coding agent for OCaml allocation profiling with memtrace.\nYour task is to instrument code, capture traces, identify allocation hotspots,\nand suggest concrete optimizations.\n\nYou must:\n- Keep tracing gated behind the MEMTRACE environment variable.\n- Target specific tests or benchmarks to isolate hotspots.\n- Focus on actionable insights: which functions allocate, why, and how to fix.\n- Understand OCaml's boxing behavior (int32, int64 are boxed; int is unboxed).\n\n---\n\n## instructions\n\n### When to apply this skill\n\nUse this skill when:\n- Investigating why a function allocates more than expected\n- Identifying boxing overhead (int32, int64, floats in arrays)\n- Optimizing hot paths in parsing/serialization code\n- Comparing allocation behavior before and after changes\n\nDo **not** use this skill for:\n- Exact allocation counting (memtrace is statistical)\n- Performance timing (use `Sys.time` or benchmarks for that)\n- Memory leak debugging (memtrace shows allocations, not leaks)\n\n---\n\n### Instrumentation pattern\n\nAdd to the main entrypoint, before any work begins:\n\n```ocaml\nlet () =\n  Memtrace.trace_if_requested ();\n  (* rest of program *)\n```\n\nFor Alcotest test suites:\n\n```ocaml\n(* test/test.ml *)\nlet () =\n  Memtrace.trace_if_requested ();\n  Alcotest.run \"suite-name\" [\n    Test_foo.suite;\n    Test_bar.suite;\n  ]\n```\n\nRules:\n- Call once, at program start\n- No `~context` argument needed for simple cases\n- Never enable tracing unconditionally\n\n---\n\n### Build configuration\n\nAdd memtrace to the test executable in dune:\n\n```lisp\n(test\n (name test)\n (libraries memtrace alcotest ...))\n```\n\nOr for a standalone executable:\n\n```lisp\n(executable\n (name main)\n (libraries memtrace ...))\n```\n\n---\n\n### Running with memtrace\n\nBasic usage:\n\n```bash\nMEMTRACE=trace.ctf dune exec -- path/to/exe\n```\n\nFor Alcotest, target a specific test to isolate allocations:\n\n```bash\n# Run specific test suite\nMEMTRACE=trace.ctf dune exec -- test/test.exe test \"binary\"\n\n# Run specific test by index within suite\nMEMTRACE=trace.ctf dune exec -- test/test.exe test \"binary\" 68\n\n# List available tests first\ndune exec -- test/test.exe test list\n```\n\nThe trace file (`.ctf`) is binary but contains embedded strings showing:\n- Source file paths and line numbers\n- Function names and call stacks\n- Allocation counts and sizes\n\n---\n\n### Analyzing traces\n\n**With memtrace-viewer (GUI):**\n\n```bash\nmemtrace-viewer trace.ctf\n# Opens browser at http://localhost:8080\n```\n\n**With memtrace-hotspot (CLI):**\n\n```bash\nopam install memtrace-hotspot\nmemtrace-hotspot trace.ctf\n```\n\n**Reading raw trace output:**\n\nThe MEMTRACE environment produces summary output showing:\n- Total allocations in bytes\n- Top allocation sites by percentage\n- Call stacks leading to allocations\n\nExample output:\n```\n76.3 MB total allocations\n  30.2% lib/binary.ml:194 Bytes.get_int32_be\n  15.1% lib/binary.ml:210 Bytes.get_int64_be\n  ...\n```\n\n---\n\n### Common hotspots and fixes\n\n**1. Int32/Int64 boxing**\n\nProblem: `Bytes.get_int32_be` returns `int32` which is always boxed.\n\n```ocaml\n(* SLOW: boxes on every call *)\nlet v = Bytes.get_int32_be buf off\n```\n\nFix: Read bytes individually, box only at the end:\n\n```ocaml\n(* FAST: single box at the end *)\nlet read_uint32_be buf off =\n  let b0 = Bytes.get_uint8 buf off in\n  let b1 = Bytes.get_uint8 buf (off + 1) in\n  let b2 = Bytes.get_uint8 buf (off + 2) in\n  let b3 = Bytes.get_uint8 buf (off + 3) in\n  Int32.of_int ((b0 lsl 24) lor (b1 lsl 16) lor (b2 lsl 8) lor b3)\n```\n\n**2. Closure allocation in loops**\n\nProblem: `let*` and partial application create closures.\n\n```ocaml\n(* SLOW: closure per iteration *)\nList.iter (fun x -> process key x) items\n```\n\nFix: Inline or use direct recursion:\n\n```ocaml\n(* FAST: no closure *)\nlet rec loop = function\n  | [] -> ()\n  | x :: xs -> process key x; loop xs\nin loop items\n```\n\n**3. Array bounds checking**\n\nFor proven-safe indices, use unsafe access:\n\n```ocaml\n(* Lookup table - indices always valid *)\nArray.unsafe_get table ((byte lsr 4) land 0xF)\n```\n\n---\n\n### Optimization workflow\n\n1. **Baseline**: Run benchmark with memtrace, note total allocations\n2. **Identify**: Find top allocation sites (>10% of total)\n3. **Analyze**: Determine if allocations are necessary or avoidable\n4. **Fix**: Apply targeted optimizations (see common fixes above)\n5. **Validate**: Re-run with memtrace, compare totals\n\nExample from this codebase:\n- Before: 76.3 MB total (Bytes.get_int32_be = 30%)\n- After: 53.4 MB total (byte-by-byte reads)\n- Reduction: 30%\n\n---\n\n### Considerations for int32/int64 APIs\n\nIf your API returns `int32` or `int64`, boxing is unavoidable at the boundary.\nConsider:\n\n- **Optint.Int63.t**: Unboxed on 64-bit platforms, fits in native int\n- **Returning int**: If values fit in 31/63 bits, avoid boxed types entirely\n- **Streaming APIs**: Process data without intermediate boxed values\n\nCheck what other libraries do:\n- `bytesrw`: Uses `int` where possible, `int64` only when necessary\n\n---\n\n### Expected outputs\n\nWhen this skill is invoked, produce:\n\n1. Instrumentation patch (single `Memtrace.trace_if_requested ()` call)\n2. Dune changes if memtrace not already linked\n3. Exact command to run targeted benchmark with tracing\n4. Analysis of trace output identifying top hotspots\n5. Concrete code changes to reduce allocations\n6. Before/after comparison showing improvement\n\n---\n\n### Avoiding common mistakes\n\n- **Wrong process**: Trace the worker, not the test harness\n- **Too broad**: Target specific tests, not entire suites\n- **Comparing apples to oranges**: Same workload, same sampling rate\n- **Premature optimization**: Focus on hotspots >10% of allocations\n- **Breaking APIs**: Don't change public signatures just to avoid boxing\n",
        "plugins/ocaml-dev/skills/ocaml-code-style/SKILL.md": "---\nname: ocaml-code-style\ndescription: \"OCaml coding style and refactoring patterns. Use when the user asks to tidy, clean up, refactor, or improve OCaml code, reviewing code quality, enforcing naming conventions, or reducing complexity.\"\nlicense: ISC\n---\n\n# OCaml Code Style\n\n## Core Philosophy\n\n1. **Interface-First**: Design `.mli` first. Clean interface > clever implementation.\n2. **Modularity**: Small, focused modules. Compose for larger systems.\n3. **Simplicity (KISS)**: Clarity over conciseness. Avoid obscure constructs.\n4. **Explicitness**: Explicit control flow and error handling. No exceptions for recoverable errors.\n5. **Purity**: Prefer pure functions. Isolate side-effects at edges.\n6. **NEVER use Obj.magic**: Breaks type safety. Always a better solution.\n\n## Naming Conventions\n\n| Element | Convention | Example |\n|---------|------------|---------|\n| Files | `lowercase_underscores` | `user_profile.ml` |\n| Modules | `Snake_case` | `User_profile` |\n| Types | `snake_case`, primary type is `t` | `type user_profile`, `type t` |\n| Values | `snake_case` | `find_user`, `create_channel` |\n| Variants | `Snake_case` | `Waiting_for_input`, `Processing_data` |\n\n**Function naming**:\n- `find_*` returns `option` (may not exist)\n- `get_*` returns value directly (must exist)\n\n**Avoid**: Long names with many underscores (`get_user_profile_data_from_database_by_id`).\n\n## Refactoring Patterns\n\n### Option/Result Combinators\n\n```ocaml\n(* Before *)\nmatch get_value () with Some x -> Some (x + 1) | None -> None\n\n(* After *)\nOption.map (fun x -> x + 1) (get_value ())\n```\n\nPrefer: `Option.map`, `Option.bind`, `Option.value`, `Result.map`, `Result.bind`\n\n### Monadic Syntax (let*/let+)\n\n```ocaml\n(* Before - nested matches *)\nmatch fetch_user id with\n| Ok user -> (match fetch_perms user with Ok p -> Ok (user, p) | Error e -> Error e)\n| Error e -> Error e\n\n(* After *)\nlet open Result.Syntax in\nlet* user = fetch_user id in\nlet+ perms = fetch_perms user in\n(user, perms)\n```\n\n### Pattern Matching Over Conditionals\n\n```ocaml\n(* Before *)\nif x > 0 then if x < 10 then \"small\" else \"large\" else \"negative\"\n\n(* After *)\nmatch x with\n| x when x < 0 -> \"negative\"\n| x when x < 10 -> \"small\"\n| _ -> \"large\"\n```\n\n## Function Design\n\n**Keep functions small**: Under 50 lines. One purpose per function.\n\n**Avoid deep nesting**: Max 4 levels of `match`/`if`. Extract helpers.\n\n**High complexity signal**: Many branches = split into focused helpers.\n\n```ocaml\n(* Bad - high complexity *)\nlet check x y z =\n  if x > 0 then if y > 0 then if z > 0 then ... else ... else ... else ...\n\n(* Good - factored *)\nlet all_positive x y z = x > 0 && y > 0 && z > 0\nlet check x y z = if not (all_positive x y z) then \"invalid\" else ...\n```\n\n## Error Handling\n\n**Use `result` for recoverable errors**. Exceptions only for programming errors.\n\n**Never catch-all**:\n```ocaml\n(* Bad *)\ntry f () with _ -> default\n\n(* Good *)\ntry f () with Failure _ -> default\n```\n\n**Don't silence warnings**: Fix the issue, don't use `[@warning \"-nn\"]`.\n\n## Library Preferences\n\n| Instead of | Use | Why |\n|------------|-----|-----|\n| `Str` | `Re` | Better API, no global state |\n| `Printf` | `Fmt` | Composable, type-safe |\n| `yojson` (manual) | `jsont` | Type-safe codecs |\n\n## Module Hygiene\n\n**Abstract types**: Keep `type t` abstract. Expose smart constructors.\n\n```ocaml\n(* Good - .mli *)\ntype t\nval create : name:string -> t\nval name : t -> string\nval pp : t Fmt.t\n```\n\n**Avoid generic names**: Not `Util`, `Helpers`. Use `String_ext`, `Json_codec`.\n\n## API Design\n\n**Avoid boolean blindness**:\n```ocaml\n(* Bad *)\nlet create_widget visible bordered = ...\nlet w = create_widget true false  (* What does this mean? *)\n\n(* Good *)\ntype visibility = Visible | Hidden\nlet create_widget ~visibility ~border = ...\n```\n\n## Red Flags\n\n- Match that just rewraps: `Some v -> Some (f v) | None -> None`\n- Nested Result/Option matches → use let*/let+\n- Deep if/then/else → pattern matching\n- Missing `pp` function on types\n- Unlabeled boolean parameters\n- `Obj.magic` anywhere\n",
        "plugins/ocaml-dev/skills/ocaml-docs/SKILL.md": "---\nname: ocaml-docs\ndescription: \"Fixing odoc documentation warnings and errors. Use when running dune build @doc, resolving reference syntax issues, cross-package references, ambiguous references, hidden fields, or @raise tags in OCaml documentation.\"\nlicense: ISC\n---\n\n# OCaml Documentation (odoc) Skill\n\n## When to Use\n\nUse this skill when fixing odoc documentation warnings, typically from `dune build @doc`.\n\n**Prerequisites:** This skill covers odoc v3 syntax which is not yet in released versions of dune or odoc. You need:\n- dune pinned to https://github.com/jonludlam/dune/tree/odoc-v3-rules-3.21\n- odoc pinned to https://github.com/jonludlam/odoc/tree/staging\n\n## Reference Syntax\n\nUse path-based disambiguation `{!Path.To.kind-Name}` rather than `{!kind:Path.To.Name}`:\n\n```ocaml\n(* Correct *)\n{!Jsont.exception-Error}\n{!Proto.Incoming.t.constructor-Message}\n{!module-Foo.module-type-Bar.exception-Baz}\n\n(* Incorrect *)\n{!exception:Jsont.Error}\n{!constructor:Proto.Incoming.t.Message}\n```\n\nThis allows disambiguation at any position in the path.\n\n## Reference Kinds\n\n- `module-` for modules\n- `type-` for types\n- `val-` for values\n- `exception-` for exceptions\n- `constructor-` for variant constructors\n- `field-` for record fields\n- `module-type-` for module types\n\n## Cross-Package References\n\nWhen odoc cannot resolve a reference to another package, add a documentation dependency in `dune-project`:\n\n```lisp\n(package\n (name mypackage)\n ...\n (documentation (depends other-package)))\n```\n\nDo NOT convert doc references `{!Foo}` to code markup `[Foo]` - this loses the hyperlink.\n\n## Cross-Library References (Same Package)\n\nWhen referencing modules from another library in the same package, use the full path through re-exported modules.\n\nExample: If `claude.mli` has `module Proto = Proto`, reference proto modules as `{!Proto.Incoming}` not `{!Incoming}`.\n\n## Missing Module Exports\n\nIf odoc reports \"Couldn't find X\" where X is the last path component:\n\n1. Check if the module is re-exported in the parent module's `.mli`\n2. Add `module X = X` to the parent's `.mli` if missing\n\n## Ambiguous References\n\nWhen odoc warns about ambiguity (e.g., both an exception and module named `Error`):\n\n```ocaml\n{!Jsont.exception-Error}  (* for the exception *)\n{!Jsont.module-Error}     (* for the module *)\n```\n\n## @raise Tags\n\nFor `@raise` documentation tags, use the exception path with disambiguation:\n\n```ocaml\n@raise Jsont.exception-Error\n@raise Tomlt.Toml.Error.exception-Error\n```\n\n## Escaping @ Symbols\n\nThe `@` character is interpreted as a tag marker in odoc. When you need a literal `@` in documentation text (e.g., describing @-mentions), escape it with a backslash:\n\n```ocaml\n(* Correct - escaped @ *)\n(** User was \\@-mentioned *)\n(** Mentioned via \\@all/\\@everyone *)\n\n(* Incorrect - will produce \"Stray '@'\" or \"Unknown tag\" warnings *)\n(** User was @-mentioned *)\n(** Mentioned via @all *)\n```\n\n## Hidden Fields Warning\n\nWhen odoc warns about \"Hidden fields in type 'Foo.Bar.t': field_name\", it means a record field uses a type that odoc can't resolve in the documentation.\n\n**Diagnosis:**\n1. Find the field definition in the `.mli` file\n2. Identify what type the field uses (e.g., `uri : Uri.t`)\n3. Check if that type's module is re-exported in the wrapper `.mli`\n\n**Fix Option 1:** Re-export the module in the wrapper `.mli`:\n```ocaml\n(** RFC 3986 URI parsing *)\nmodule Uri = Uri\n```\n\n**Fix Option 2:** If you only want to expose the type (not the whole module), use `@canonical`:\n\n1. Add a type alias in the wrapper `.mli`:\n   ```ocaml\n   type uri = Uri.t\n   ```\n\n2. Add `@canonical` to the original type's documentation:\n   ```ocaml\n   (* In uri.mli *)\n   type t\n   (** A URI. @canonical Requests.uri *)\n   ```\n\nThis tells odoc to link `Uri.t` to `Requests.uri` in the generated documentation.\n\n## Interpreting Error Messages\n\n| Error Pattern | Meaning | Fix |\n|--------------|---------|-----|\n| `unresolvedroot(X)` | X not found as root module | Check library dependencies, add documentation depends |\n| `Couldn't find \"Y\"` after valid path | Y doesn't exist at that location | Verify module structure, check exports |\n| `Reference to 'X' is ambiguous` | Multiple items named X | Add kind qualifier (e.g., `exception-X`) |\n| `Hidden fields in type ... : field` | Field's type not resolvable | Re-export the type's module in wrapper `.mli` |\n\n## Debugging\n\n1. Run `dune clean` before `dune build @doc` to ensure fresh builds\n2. Check the library's `.mli` file to see what modules are exported\n3. For cross-library refs, trace the module path through re-exports\n",
        "plugins/ocaml-dev/skills/ocaml-dune-migration/SKILL.md": "---\nname: ocaml-dune-migration\ndescription: Migrating OCaml projects from ocamlbuild/topkg to dune. Use when discussing _tags files, .mllib files, pkg/pkg.ml, topkg, or build system migration.\nlicense: ISC\n---\n\n# OCaml Build System Migration\n\n## When to Use This Skill\n\nInvoke this skill when:\n- Converting a project from ocamlbuild to dune\n- Discussing _tags, .mllib, or pkg.ml files\n- Migrating from topkg to dune\n- Understanding ocamlbuild artifacts\n\n## Process Overview\n\n### 1. Analyze the Existing Build\n\nRead these files to understand the project:\n- `_tags` - ocamlbuild compilation flags and package dependencies\n- `pkg/pkg.ml` - topkg package description\n- `pkg/META` - findlib metadata\n- `*.mllib` files - module lists for libraries\n- `opam` - package dependencies\n\n### 2. Create dune-project\n\n```dune\n(lang dune 3.20)\n(name <package-name>)\n(generate_opam_files true)\n```\n\n### 3. Create Library dune Files\n\nFor each library (from `.mllib` files):\n\n```dune\n(library\n (name <library_name>)\n (public_name <package.subname>)\n (libraries <dependencies>))\n```\n\nFor optional libraries (from `pkg/pkg.ml`):\n\n```dune\n(library\n (name <library_name>)\n (public_name <package.subname>)\n (optional)\n (libraries <dependencies>))\n```\n\n### 4. Handle Toplevel Init Files\n\nFiles like `*_top_init.ml` shouldn't be compiled as modules:\n\n```dune\n(library\n (name lib_name)\n (modules lib_module)  ; Explicitly list modules\n (libraries deps))\n\n(install\n (package pkg)\n (section lib)\n (files lib_top_init.ml))\n```\n\n### 5. Handle Warnings\n\nIf the original code triggers warnings:\n\n```dune\n(library\n (name lib)\n (flags (:standard -w -27)))\n```\n\nCommon warnings to suppress in vendored code:\n- `-w -27` - unused variable\n\n### 6. Create Test dune File\n\n```dune\n(test\n (name test_name)\n (libraries lib_name alcotest))\n```\n\nFor optional tests:\n\n```dune\n(executable\n (name test_optional)\n (modules test_optional)\n (optional)\n (libraries lib some_optional_lib))\n```\n\n### 7. Update opam File\n\n1. Rename `opam` to `<package>.opam`\n2. Remove ocamlbuild/topkg dependencies\n3. Add dune:\n\n```\ndepends: [\n  \"ocaml\" {>= \"4.14.0\"}\n  \"dune\" {>= \"3.0\"}\n]\n```\n\n4. Update build commands:\n\n```\nbuild: [\n  [\"dune\" \"subst\"] {dev}\n  [\"dune\" \"build\" \"-p\" name \"-j\" jobs]\n  [\"dune\" \"runtest\" \"-p\" name \"-j\" jobs] {with-test}\n  [\"dune\" \"build\" \"@doc\" \"-p\" name \"-j\" jobs] {with-doc}\n]\n```\n\n### 8. Documentation dune File\n\nIf there's a `doc/` directory:\n\n```dune\n(documentation\n (package <package-name>))\n```\n\n### 9. Remove ocamlbuild Files\n\nFiles to delete:\n- `_tags`\n- `.merlin`\n- `pkg/pkg.ml`\n- `pkg/META`\n- `*.mllib` files\n- `*.itarget` files\n- The `pkg/` directory\n\n## Mapping Reference\n\n| ocamlbuild | dune |\n|------------|------|\n| `_tags: package(foo)` | `(libraries foo)` |\n| `_tags: thread` | `(libraries threads)` |\n| `foo.mllib` with `Foo` | `(library (name foo) (modules foo))` |\n| `pkg/pkg.ml: Pkg.mllib ~cond:x` | `(library ... (optional))` |\n| `pkg/META` | Auto-generated by dune |\n| `opam` | `<package>.opam` |\n\n## Common Issues\n\n### \"Library not found\" for optional deps\nUse `(optional)` on the library stanza.\n\n### Unused variable warnings\nAdd `(flags (:standard -w -27))`.\n\n### Module in wrong library\nUse `(modules ...)` to explicitly list modules.\n\n### Toplevel init files\nExclude from library with `(modules ...)` and use `(install ...)`.\n\n## Verification\n\nAfter migration:\n\n```bash\ndune build @check    # Verify syntax\ndune build           # Build project\ndune runtest         # Run tests\ndune build @doc      # Build docs\n```\n",
        "plugins/ocaml-dev/skills/ocaml-npm-publishing/SKILL.md": "---\nname: ocaml-npm-publishing\ndescription: Publishing OCaml to npm via js_of_ocaml and wasm_of_ocaml. Use when discussing browser targets, JavaScript compilation, WASM output, npm packages, or the two-branch workflow.\nlicense: ISC\n---\n\n# OCaml to NPM Publishing\n\n## When to Use This Skill\n\nInvoke this skill when:\n- Setting up npm publishing for OCaml projects\n- Configuring js_of_ocaml or wasm_of_ocaml\n- Discussing browser targets for OCaml\n- Creating the npm branch workflow\n\n## Branch Structure\n\n```\nmain branch     - OCaml source code, dune build files, opam packages\nnpm branch      - Built JavaScript/WASM assets, package.json, README for npm\n```\n\nThe `npm` branch is an orphan branch with no shared history.\n\n## Dune Build Rules\n\n### Library with Browser Bindings\n\nIn `lib/js/dune`:\n\n```dune\n; Library compiled to bytecode (required for js_of_ocaml)\n(library\n (name mylib_js)\n (public_name mylib-js)\n (libraries mylib brr)\n (modes byte)\n (modules mylib_js))\n\n; Executable compiled to both JS and WASM\n(executable\n (name mylib_js_main)\n (libraries mylib_js)\n (js_of_ocaml)\n (modes js wasm)\n (modules mylib_js_main))\n\n; Friendly filename for JS\n(rule\n (targets mylib.js)\n (deps mylib_js_main.bc.js)\n (action (copy %{deps} %{targets})))\n\n; Friendly filename for WASM\n(rule\n (targets mylib.wasm.js)\n (deps mylib_js_main.bc.wasm.js)\n (action (copy %{deps} %{targets})))\n\n; Install web assets\n(install\n (package mylib-js)\n (section share)\n (files\n  mylib.js\n  mylib.wasm.js\n  (glob_files_rec (mylib_js_main.bc.wasm.assets/* with_prefix mylib_js_main.bc.wasm.assets))))\n```\n\n### dune-project Package\n\n```dune\n(package\n (name mylib-js)\n (synopsis \"Browser library via js_of_ocaml/wasm_of_ocaml\")\n (depends\n  (ocaml (>= 5.1.0))\n  (mylib (= :version))\n  (js_of_ocaml (>= 5.0))\n  (js_of_ocaml-ppx (>= 5.0))\n  (wasm_of_ocaml-compiler (>= 5.0))\n  (brr (>= 0.0.6))))\n```\n\n## Creating the NPM Branch\n\n```bash\n# Create orphan branch\ngit switch --orphan npm\n\n# Add npm-specific files\ngit add package.json README.md LICENSE release.sh .gitignore\ngit commit -m \"Initial npm package setup\"\n\n# Switch back\ngit checkout main\n```\n\n## NPM Branch Files\n\nSee `templates/` for:\n- `package.json.template`\n- `release.sh.template`\n\n### package.json\n\n```json\n{\n  \"name\": \"mylib-jsoo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Description here\",\n  \"browser\": \"mylib.js\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/user/repo.git#npm\"\n  },\n  \"files\": [\n    \"mylib.js\",\n    \"mylib.wasm.js\",\n    \"mylib_js_main.bc.wasm.assets/\",\n    \"README.md\",\n    \"LICENSE\"\n  ]\n}\n```\n\nKey points:\n- Use `\"browser\"` not `\"main\"` (js_of_ocaml is browser-only)\n- Point repository URL to `#npm` branch\n- Include WASM assets directory\n\n### release.sh\n\nScript to copy built assets from main branch to npm branch.\n\n## Workflow Summary\n\n1. Develop on `main` branch (OCaml source)\n2. Build: `dune build @install`\n3. Switch to `npm` branch\n4. Run `./release.sh` to copy built assets\n5. Update version in `package.json`\n6. Commit and `npm publish`\n\n## README for npm\n\nFocus on browser usage:\n1. Clear browser-only notice\n2. Installation via npm\n3. Browser usage with `<script>` tags\n4. Both JS and WASM examples\n5. Browser compatibility requirements\n",
        "plugins/ocaml-dev/skills/ocaml-project-setup/SKILL.md": "---\nname: ocaml-project-setup\ndescription: \"Standards for OCaml project metadata files. Use when initializing a new OCaml library/module, preparing for opam release, setting up CI, discussing project structure, or ensuring proper .mli/.ocamlformat files exist.\"\nlicense: ISC\n---\n\n# OCaml Project Setup\n\n## Required Files\n\nEvery OCaml project needs:\n\n| File | Purpose |\n|------|---------|\n| `dune-project` | Build configuration, opam generation |\n| `dune` (root) | Top-level build rules |\n| `.ocamlformat` | Code formatting (required) |\n| `.gitignore` | VCS ignores |\n| `LICENSE.md` | License file |\n| `README.md` | Project documentation |\n| CI config | GitHub Actions / GitLab CI / Tangled |\n\n## Interface Files (.mli)\n\n**Every library module must have an `.mli` file** for:\n- Clear API boundaries\n- Proper encapsulation\n- Documentation surface\n\n```ocaml\n(* lib/user.mli *)\n\n(** User management.\n\n    This module provides types and functions for user operations. *)\n\ntype t\n(** A user. *)\n\nval create : name:string -> email:string -> t\n(** [create ~name ~email] creates a new user. *)\n\nval name : t -> string\n(** [name u] is the user's name. *)\n\nval pp : t Fmt.t\n(** [pp] is a pretty-printer for users. *)\n```\n\n**Documentation style**:\n- Functions: `[name args] is/does ...`\n- Values: `[name] is ...`\n- End with period\n\n## Standard Module Interface\n\nFor modules with a central type `t`:\n\n```ocaml\ntype t\nval v : ... -> t                           (* pure constructor *)\nval create : ... -> (t, Error.t) result    (* constructor with I/O *)\nval pp : t Fmt.t                           (* pretty-printer - required *)\nval equal : t -> t -> bool                 (* equality *)\nval compare : t -> t -> int                (* comparison *)\nval of_json : Yojson.Safe.t -> (t, string) result\nval to_json : t -> Yojson.Safe.t\n```\n\n## OCamlFormat Configuration\n\n**Required**: `.ocamlformat` in project root.\n\n```\nversion = 0.28.1\n```\n\nRun `dune fmt` before every commit.\n\n## Logging Setup\n\nEach module using logging should declare a source:\n\n```ocaml\nlet log_src = Logs.Src.create \"project.module\"\nmodule Log = (val Logs.src_log log_src : Logs.LOG)\n```\n\nLog levels:\n- `Log.app` - Always shown (startup)\n- `Log.err` - Critical errors\n- `Log.warn` - Potential issues\n- `Log.info` - Informational\n- `Log.debug` - Verbose debugging\n\n## User Configuration\n\nRead from `~/.claude/ocaml-config.json`:\n\n```json\n{\n  \"author\": { \"name\": \"Name\", \"email\": \"email@example.com\" },\n  \"license\": \"ISC\",\n  \"ci_platform\": \"github\",\n  \"git_hosting\": { \"type\": \"github\", \"org\": \"username\" },\n  \"ocaml_version\": \"5.2.0\"\n}\n```\n\n## License Headers\n\nEvery source file starts with license header:\n\n```ocaml\n(*---------------------------------------------------------------------------\n  Copyright (c) {{YEAR}} {{AUTHOR}}. All rights reserved.\n  SPDX-License-Identifier: ISC\n ---------------------------------------------------------------------------*)\n```\n\n## Project Structure\n\n```\nproject/\n├── dune-project\n├── dune\n├── .ocamlformat\n├── .gitignore\n├── LICENSE.md\n├── README.md\n├── lib/\n│   ├── dune\n│   ├── foo.ml\n│   └── foo.mli         # Required for every .ml\n├── bin/\n│   ├── dune\n│   └── main.ml\n├── test/\n│   ├── dune\n│   ├── test.ml\n│   └── test_foo.ml\n├── .github/workflows/  # GitHub Actions\n├── .gitlab-ci.yml      # GitLab CI\n└── .tangled/workflows/ # Tangled CI\n```\n\n## dune-project\n\n```lisp\n(lang dune 3.21)\n(name project_name)\n(generate_opam_files true)\n\n(license ISC)\n(authors \"Name <email@example.com>\")\n(maintainers \"Name <email@example.com>\")\n(source (tangled user.domain/project_name))\n\n(package\n (name project_name)\n (synopsis \"Short description\")\n (description \"Longer description\")\n (depends\n  (ocaml (>= 5.2))\n  (alcotest (and :with-test (>= 1.7.0)))))\n```\n\n**Note**: Don't add `(version ...)` - added at release time.\n\n### Tangled Source Syntax\n\nFor projects hosted on tangled.org, use the succinct source stanza:\n\n```lisp\n(source (tangled user.domain/project-name))\n```\n\nExamples:\n- `(source (tangled anil.recoil.org/ocaml-brotli))`\n- `(source (tangled user.example.org/my-library))`\n\n## Tangled CI Configuration\n\nFor projects hosted on tangled.org, create `.tangled/workflows/build.yml`:\n\n```yaml\nwhen:\n  - event: [\"push\", \"pull_request\"]\n    branch: [\"main\"]\n\nengine: nixery\n\ndependencies:\n  nixpkgs:\n    - shell\n    - stdenv\n    - findutils\n    - binutils\n    - libunwind\n    - ncurses\n    - opam\n    - git\n    - gawk\n    - gnupatch\n    - gnum4\n    - gnumake\n    - gnutar\n    - gnused\n    - gnugrep\n    - diffutils\n    - gzip\n    - bzip2\n    - gcc\n    - ocaml\n    - pkg-config\n\nsteps:\n  - name: opam\n    command: |\n      opam init --disable-sandboxing -a -y\n\n  - name: repo\n    command: |\n      opam repo add aoah https://tangled.org/anil.recoil.org/aoah-opam-repo.git\n\n  - name: deps\n    command: |\n      opam install . --confirm-level=unsafe-yes --deps-only\n\n  - name: build\n    command: |\n      opam exec -- dune build\n\n  - name: test\n    command: |\n      opam install . --confirm-level=unsafe-yes --deps-only --with-test\n      opam exec -- dune runtest --verbose\n```\n\n### Tangled Workflow Syntax\n\n| Field | Description |\n|-------|-------------|\n| `when` | Trigger conditions: `event` (push/pull_request) and `branch` |\n| `engine` | Build engine, use `nixery` for Nix-based builds |\n| `dependencies.nixpkgs` | List of Nix packages to include |\n| `environment` | Global or per-step environment variables |\n| `steps` | Build steps with `name` and `command` |\n\nPer-step environment variables:\n\n```yaml\nsteps:\n  - name: test\n    environment:\n      MY_VAR: value\n    command: |\n      echo $MY_VAR\n```\n\n## Templates\n\nSee `templates/` directory for:\n- `dune-project.template`\n- `dune-root.template`\n- `ci-github.yml`\n- `ci-gitlab.yml`\n- `ci-tangled.yml`\n- `gitignore`\n- `ocamlformat`\n- `LICENSE-ISC.md`\n- `LICENSE-MIT.md`\n- `README.template.md`\n",
        "plugins/ocaml-dev/skills/ocaml-project-setup/templates/LICENSE-ISC.md": "# ISC License\n\nCopyright (c) {{YEAR}} {{AUTHOR_NAME}} <{{AUTHOR_EMAIL}}>\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n",
        "plugins/ocaml-dev/skills/ocaml-project-setup/templates/LICENSE-MIT.md": "# MIT License\n\nCopyright (c) {{YEAR}} {{AUTHOR_NAME}} <{{AUTHOR_EMAIL}}>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
        "plugins/ocaml-dev/skills/ocaml-project-setup/templates/README.template.md": "# {{PROJECT_NAME_KEBAB}}\n\n{{PROJECT_SYNOPSIS}}\n\n## Features\n\n- Feature 1\n- Feature 2\n- Feature 3\n\n## Installation\n\n### Using opam\n\n```bash\nopam install {{PROJECT_NAME}}\n```\n\n### From source\n\n```bash\ngit clone {{GIT_URL}}\ncd {{PROJECT_NAME_KEBAB}}\nopam install . --deps-only\ndune build\n```\n\n## Usage\n\n```ocaml\nopen {{PROJECT_NAME_CAPITALIZED}}\n\nlet () =\n  (* Your code here *)\n  ()\n```\n\n## Documentation\n\nAPI documentation is available at: https://{{GIT_ORG}}.github.io/{{PROJECT_NAME_KEBAB}}\n\nBuild locally with:\n\n```bash\ndune build @doc\nopen _build/default/_doc/_html/index.html\n```\n\n## Development\n\n### Building\n\n```bash\ndune build\n```\n\n### Testing\n\n```bash\ndune runtest\n```\n\n### Formatting\n\n```bash\ndune fmt\n```\n\n## License\n\n{{LICENSE}} License. See [LICENSE.md](LICENSE.md) for details.\n",
        "plugins/ocaml-dev/skills/ocaml-rfc-integration/SKILL.md": "---\nname: ocaml-rfc-integration\ndescription: Working with IETF RFCs in OCaml projects. Use when mentioning RFC numbers, implementing internet standards, adding specification documentation, or discussing protocol compliance.\nlicense: ISC\n---\n\n# RFC Integration for OCaml Projects\n\n## When to Use This Skill\n\nInvoke this skill when:\n- User mentions implementing an RFC\n- Adding RFC citations to documentation\n- Fetching RFC specifications\n- Validating code against RFC requirements\n- Discussing internet protocol standards\n\n## RFC Fetching and Storage\n\n### Fetching RFCs\n\nAlways fetch RFCs in **plain text format** from:\n```\nhttps://datatracker.ietf.org/doc/html/rfcXXXX.txt\n```\n\n**Important**: Use `.txt` extension, not `.html`.\n\n### Storage Location\n\nSave RFC files to `spec/` directory in project root:\n```\nspec/rfc6265.txt\nspec/rfc3492.txt\n```\n\nCreate `spec/` directory if it doesn't exist.\n\n## OCamldoc RFC Citation Format\n\n### Basic RFC Link\n\n```ocaml\n{{:https://datatracker.ietf.org/doc/html/rfcXXXX}RFC XXXX}\n```\n\n### Section-Specific Links\n\n```ocaml\n{{:https://datatracker.ietf.org/doc/html/rfcXXXX#section-N.M}RFC XXXX Section N.M}\n```\n\n### Common Section References\n\n- `#section-N` - Main numbered section\n- `#section-N.M` - Subsection\n- `#appendix-X` - Appendix (A, B, C, etc.)\n\n## Documentation Patterns\n\n### Module-Level Documentation\n\n```ocaml\n(** RFC 3492 Punycode: A Bootstring encoding of Unicode for IDNA.\n\n    This module implements the Punycode algorithm as specified in\n    {{:https://datatracker.ietf.org/doc/html/rfc3492}RFC 3492}.\n\n    {2 References}\n    {ul\n    {- {{:https://datatracker.ietf.org/doc/html/rfc3492}RFC 3492} - Punycode}\n    {- {{:https://datatracker.ietf.org/doc/html/rfc5891}RFC 5891} - IDNA}} *)\n```\n\n### Function-Level Documentation\n\n```ocaml\nval adapt : delta:int -> numpoints:int -> firsttime:bool -> int\n(** [adapt ~delta ~numpoints ~firsttime] computes the new bias value.\n\n    Implements the bias adaptation algorithm from\n    {{:https://datatracker.ietf.org/doc/html/rfc3492#section-6.1}RFC 3492 Section 6.1}. *)\n```\n\n### Type-Level Documentation\n\n```ocaml\ntype error =\n  | Overflow of position\n      (** Arithmetic overflow. See\n          {{:https://datatracker.ietf.org/doc/html/rfc3492#section-6.4}\n          RFC 3492 Section 6.4}. *)\n  | Invalid_digit of position * char\n      (** Invalid Punycode digit. See\n          {{:https://datatracker.ietf.org/doc/html/rfc3492#section-5}\n          RFC 3492 Section 5}. *)\n```\n\n### Constants and Parameters\n\n```ocaml\nval base : int\n(** The base value (36) for Punycode encoding.\n    See {{:https://datatracker.ietf.org/doc/html/rfc3492#section-5}\n    RFC 3492 Section 5}. *)\n```\n\n## Reading and Parsing RFCs\n\n### RFC Structure\n\n1. **Header**: RFC number, title, authors, date\n2. **Table of Contents**: Section numbers and titles\n3. **Abstract**: Brief summary\n4. **Main Body**: Numbered sections\n5. **Appendices**: Lettered sections\n6. **References**: Citations to other documents\n\n### Key Sections to Extract\n\n- **Introduction** - Background and motivation\n- **Terminology** - Key terms (MUST, SHOULD, MAY)\n- **Algorithm** - Core specification\n- **Security Considerations** - Security implications\n\n## Validation Workflow\n\n1. Read the RFC from `spec/` directory\n2. Extract key requirements (MUST, SHOULD, MAY)\n3. Read implementation code\n4. Check each requirement is implemented\n5. Verify error handling matches RFC\n6. Report gaps or inconsistencies\n\n## Best Practices\n\n### DO\n\n- Always fetch and save RFC text files to `spec/`\n- Use section-specific links when possible\n- Link error types to their RFC requirements\n- Document RFC parameters and constants\n- Keep citations consistent across related functions\n\n### DON'T\n\n- Link to HTML versions of RFCs\n- Assume RFC sections without checking\n- Omit section numbers in citations\n- Duplicate RFC text verbatim (summarize instead)\n\n## Handling RFC Updates\n\nWhen an RFC obsoletes another:\n```ocaml\n(** Implements {{:https://datatracker.ietf.org/doc/html/rfc6265}RFC 6265}\n    which obsoletes {{:https://datatracker.ietf.org/doc/html/rfc2965}RFC 2965}. *)\n```\n\n## Multiple RFC References\n\n```ocaml\n(** IDNA-compatible encoding combining\n    {{:https://datatracker.ietf.org/doc/html/rfc5891}RFC 5891} (IDNA Protocol)\n    with {{:https://datatracker.ietf.org/doc/html/rfc3492}RFC 3492} (Punycode). *)\n```\n",
        "plugins/ocaml-dev/skills/ocaml-testing/SKILL.md": "---\nname: ocaml-testing\ndescription: \"Testing strategies for OCaml libraries. Use when discussing tests, alcotest, eio mocks, test structure, test-driven development, or cram tests in OCaml projects.\"\nlicense: ISC\n---\n\n# OCaml Testing\n\n## Core Philosophy\n\n1. **Unit Tests First**: Prioritize unit tests for individual modules.\n2. **1:1 Test Coverage**: Every `lib/*.ml` should have `test/test_*.ml`.\n3. **Isolated Tests**: Each test independent, no external state.\n4. **Clear Names**: Describe what is tested, not how.\n\n## Test Organization\n\n```\nproject/\n├── lib/\n│   ├── user.ml\n│   └── auth.ml\n├── test/\n│   ├── dune\n│   ├── test.ml           # Main runner\n│   ├── test_user.ml      # Tests for user.ml\n│   └── test_auth.ml      # Tests for auth.ml\n└── third_party/          # Fetched sources for reference\n```\n\n**Rules**:\n- Test file `test_foo.ml` tests library module `foo.ml`\n- Every test module exports `suite : string * unit Alcotest.test_case list`\n- Main `test.ml` aggregates all suites\n\n## Basic Test Structure\n\n```ocaml\n(* test/test_user.ml *)\nlet test_create () =\n  let user = User.create ~name:\"Alice\" in\n  Alcotest.(check string) \"name\" \"Alice\" (User.name user)\n\nlet test_validate_empty () =\n  let result = User.create ~name:\"\" in\n  Alcotest.(check bool) \"fails\" true (Result.is_error result)\n\nlet suite = (\"user\", [\n  \"create\", `Quick, test_create;\n  \"validate_empty\", `Quick, test_validate_empty;\n])\n```\n\n```ocaml\n(* test/test.ml *)\nlet () = Alcotest.run \"MyProject\" [\n  Test_user.suite;\n  Test_auth.suite;\n]\n```\n\n## Test Naming\n\n- **Suite names**: lowercase, single word (`\"user\"`, `\"auth\"`)\n- **Case names**: lowercase with underscores (`\"create\"`, `\"parse_error\"`)\n\n## Dune Configuration\n\n```lisp\n(test\n (name test)\n (libraries mylib alcotest))\n```\n\nFor Eio-based libraries:\n```lisp\n(test\n (name test)\n (libraries mylib alcotest eio_main eio.mock))\n```\n\n## Testing with Eio Mocks\n\nPrefer mocks for deterministic, fast tests.\n\n```ocaml\nlet test_with_mock_clock () =\n  Eio_mock.Backend.run @@ fun () ->\n  let clock = Eio_mock.Clock.make () in\n  Eio_mock.Clock.advance clock 1.0;\n  Alcotest.(check bool) \"advanced\" true true\n\nlet test_with_mock_flow () =\n  Eio_mock.Backend.run @@ fun () ->\n  let flow = Eio_mock.Flow.make \"test\" in\n  Eio_mock.Flow.on_read flow [\n    `Return \"data\";\n    `Raise End_of_file;\n  ];\n  (* test with flow *)\n```\n\n**Mock modules**: `Eio_mock.Backend`, `Eio_mock.Clock`, `Eio_mock.Flow`, `Eio_mock.Net`, `Eio_mock.Fs`\n\n## Cram Tests (End-to-End)\n\nFor CLI/executable testing. Use directories ending in `.t/`.\n\n```\ntest/\n└── my_feature.t/\n    ├── run.t           # Test script\n    └── input.txt       # Real test files (not cat << EOF)\n```\n\n**Rules**:\n- Create actual files in directory, don't embed with `cat > file << EOF`\n- Test the compiled executable behaviour\n- Use for integration/CLI tests, not unit tests\n\n## Coverage Checklist\n\nFor each module:\n- [ ] Test all public functions from `.mli`\n- [ ] Test success cases\n- [ ] Test error cases\n- [ ] Test edge cases (empty, max values, invalid input)\n\n## Running Tests\n\n```bash\ndune runtest              # Run all tests\ndune runtest --verbose    # Verbose output\ndune exec test/test.exe   # Run specific test\ndune test --instrument-with bisect_ppx  # With coverage\n```\n\n## Best Practices\n\n1. **Prefer mocks over real I/O** - Fast, deterministic\n2. **Test edge cases** - Empty, max, invalid\n3. **One assertion per test** when practical\n4. **Clean up resources** - Even in tests\n5. **Keep integration tests minimal** - Most should be unit tests\n",
        "plugins/ocaml-dev/skills/ocaml-tutorials/SKILL.md": "---\nname: ocaml-tutorials\ndescription: Creating OCaml library tutorials using .mld documentation format with MDX executable examples. Use when discussing tutorials, documentation, .mld files, MDX, or interactive documentation.\nlicense: ISC\n---\n\n# OCaml Tutorial Creation\n\n## When to Use This Skill\n\nInvoke this skill when:\n- Creating tutorials for OCaml libraries\n- Working with .mld documentation format\n- Setting up MDX for executable examples\n- Discussing interactive documentation\n\n## Overview\n\nOCaml tutorials should:\n- Introduce concepts gently\n- Use executable code examples via MDX\n- Progress from simple to complex\n- Include practical patterns and use cases\n\n## File Structure\n\n### Required Components\n\n1. **doc/ directory** in project root\n2. **tutorial.mld** - Main tutorial content\n3. **index.mld** - Documentation index\n4. **dune** - Build rules\n\n### doc/dune Configuration\n\n```dune\n(mdx\n (files tutorial.mld)\n (libraries your_library_name))\n\n(documentation\n (package your_package_name)\n (mld_files index tutorial))\n```\n\n### dune-project Updates\n\nEnable MDX:\n\n```dune\n(using mdx 0.4)\n```\n\nAdd MDX as doc dependency:\n\n```dune\n(package\n (name your_package)\n (depends\n  ...\n  (mdx :with-doc)\n  (odoc :with-doc)))\n```\n\n## .mld Format\n\n### Document Structure\n\n```\n{0 Topic Name Tutorial}\n\nIntroduction text.\n\n{1 Section Title}\n\nSection content.\n\n{2 Subsection Title}\n\nSubsection content.\n```\n\n### Executable Code Blocks\n\nUse `{@ocaml[...]}` for executable examples:\n\n```\n{@ocaml[\n# let x = 1 + 1;;\nval x : int = 2\n]}\n```\n\n- Lines starting with `#` are input\n- Following lines are expected output\n- MDX verifies output at build time\n- Use `;;` to terminate expressions\n\n### Non-Executable Code\n\nUse `{v ... v}` for verbatim blocks:\n\n```\n{v\nname: Alice\nage: 30\nv}\n```\n\n### Cross-References\n\n```\n{!Library.function_name}          - Function reference\n{!Library.Module.type_name}       - Type reference\n{{!Library}API reference}         - Link with custom text\n```\n\n### Lists\n\n```\n{ul\n{- Item one}\n{- Item two}\n}\n\n{ol\n{- First item}\n{- Second item}\n}\n```\n\n### Formatting\n\n```\n{b bold text}\n{i italic text}\n```\n\n## Tutorial Content Guidelines\n\n### Structure\n\n1. **Setup** - How to load the library\n2. **Basic Usage** - Simplest examples\n3. **Core Concepts** - Main types and functions\n4. **Common Patterns** - Real-world usage\n5. **Advanced Features** - Complex functionality\n6. **Error Handling** - How errors work\n7. **Summary** - Quick reference\n\n### Setup Section\n\n```\n{1 Setup}\n\n{@ocaml[\n# #require \"library_name\";;\n# open Library;;\n]}\n```\n\n### Best Practices\n\n1. **Show output** - Include expected output in examples\n2. **Use consistent naming** - Variables carry through examples\n3. **Build complexity gradually** - Each example builds on previous\n4. **Explain the \"why\"** - Not just syntax, but when to use features\n5. **Reference documentation** - Link to API docs\n\n## Verification\n\n```bash\ndune build @check    # Verify syntax\ndune build @doc      # Build documentation\ndune runtest         # Run MDX tests (if configured)\n```\n\n## Common Issues\n\n### Unresolved References\nUse fully qualified names: `{!Library.of_string}` not `{!of_string}`\n\n### MDX Not Found\nEnable in dune-project: `(using mdx 0.4)`\n\n### Output Mismatch\nRun code manually, update expected output. Use `<abstr>` for abstract values.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-BASE.md": "# OxCaml Base Library Extensions\n\nJane Street's Base library (116 modules) includes comprehensive OxCaml-specific\nextensions for modes, local allocation, and unboxed types. This guide covers\nwhich Base modules are particularly useful with OxCaml features.\n\n## Module Overview by Category\n\n### Core Data Structures\n\n| Module | Description | OxCaml Features |\n|--------|-------------|-----------------|\n| `Array`, `Array0` | Mutable arrays | `@local_opt`, `@layout_poly`, `%%template`, stack alloc |\n| `Iarray`, `Iarray0` | Immutable arrays | Local submodule, Unique submodule, stack init |\n| `List`, `List0`, `List1` | Linked lists | `__local` variants, `%%template` |\n| `Nonempty_list` | Non-empty lists | `@local_opt`, local variants |\n| `Option_array` | Optional element arrays | Layout-polymorphic access |\n| `Obj_array` | Object arrays | Low-level layout support |\n\n### Hash-Based Collections\n\n| Module | Description | OxCaml Features |\n|--------|-------------|-----------------|\n| `Hashtbl` | Hash tables | `__local` find/iter variants |\n| `Hash_set` | Hash sets | Local iteration |\n| `Hashable` | Hashable interface | Portable functor variants |\n\n### Ordered Collections\n\n| Module | Description | OxCaml Features |\n|--------|-------------|-----------------|\n| `Set` | Immutable sets | `__local` fold/find variants |\n| `Map` | Immutable maps | `__local` fold/find variants |\n| `Avltree` | AVL tree implementation | `@local_opt`, `%%template` |\n| `Dictionary_immutable` | Dictionary abstraction | Mode-aware operations |\n| `Dictionary_mutable` | Mutable dictionary | Mode-aware operations |\n\n### Queues and Stacks\n\n| Module | Description | OxCaml Features |\n|--------|-------------|-----------------|\n| `Queue` | Double-ended queue | Mode-aware operations |\n| `Stack` | LIFO stack | Mode-aware operations |\n| `Linked_queue` | Linked queue | Local iteration |\n\n### Container Abstractions\n\n| Module | Description | OxCaml Features |\n|--------|-------------|-----------------|\n| `Container` | Container interface | Base iteration patterns |\n| `Container_with_local` | Local-aware containers | **Key for local iteration** |\n| `Indexed_container` | Indexed access | `exclave_if_stack` patterns |\n\n### Type Abstractions\n\n| Module | Description | OxCaml Features |\n|--------|-------------|-----------------|\n| `Comparable` | Comparison interface | Portable functor variants |\n| `Comparator` | Comparator witnesses | Mode-aware |\n| `Comparisons` | Comparison operators | `@local_opt` |\n| `Type_equal` | Type equality witnesses | Mode-safe |\n\n---\n\n## The Modes Module (Critical for OxCaml)\n\nThe `Modes` module is the cornerstone of OxCaml support in Base. It provides\nzero-cost wrappers for crossing between mode contexts.\n\n### Five Orthogonal Modalities\n\n```ocaml\n(* Locality: where values live *)\ng = (local, global)\n\n(* Portability: cross-thread safety *)\np = (nonportable, portable)\n\n(* Contention: thread access patterns *)\nc = (uncontended, shared, contended)\n\n(* Multiplicity: how often used *)\nm = (once, many)\n\n(* Aliasing: reference count *)\na = (unique, aliased)\n```\n\n### Key Wrapper Submodules\n\n```ocaml\n(* All wrappers are [@@unboxed] - zero runtime cost *)\n\nmodule Global : sig\n  type 'a t [@@unboxed]\n  external wrap : 'a -> 'a t = \"%identity\"\n  external unwrap : 'a t -> 'a = \"%identity\"\nend\n\nmodule Portable : sig\n  type 'a t [@@unboxed]\n  external wrap : 'a -> 'a t = \"%identity\"\n  external unwrap : 'a t -> 'a = \"%identity\"\nend\n\nmodule Contended : sig\n  type 'a t [@@unboxed]\n  (* Wraps values for contended access *)\nend\n\nmodule Shared : sig\n  type 'a t [@@unboxed]\n  (* Wraps values for shared (read) access *)\nend\n\n(* Combined wrapper *)\nmodule Portended : sig\n  type 'a t [@@unboxed]\n  (* portable & contended - for thread-safe sharing *)\nend\n```\n\n### Usage Pattern\n\n```ocaml\n(* Cross from local to global context *)\nlet make_global (x @ local) : 'a Modes.Global.t =\n  Modes.Global.wrap x\n\n(* Access global value locally *)\nlet use_globally (g : 'a Modes.Global.t) =\n  let x = Modes.Global.unwrap g in\n  process x\n```\n\n---\n\n## Modules with Local/Exclave Support\n\n### Tier 1: Extensive OxCaml Support (use these first)\n\n**`Iarray` - Immutable Arrays**\n\nThe most OxCaml-friendly array module:\n\n```ocaml\nmodule Iarray : sig\n  type 'a t  (* immutable, covariant *)\n\n  (* Standard access *)\n  val get : 'a t -> int -> 'a\n  val length : 'a t -> int\n\n  (* Local submodule - stack-allocated results *)\n  module Local : sig\n    val init : int -> f:(int -> 'a) -> 'a t\n    (* Uses O(n) function-call stack space *)\n\n    val init_with_globals : int -> f:(int -> 'a) -> 'a t\n    (* Elements must be global - avoids extra stack space *)\n  end\n\n  (* Unique submodule - for unique-mode optimizations *)\n  module Unique : sig\n    val init : int -> f:(int -> 'a) -> 'a t\n    val map : 'a t -> f:('a -> 'b) -> 'b t\n    val mapi : 'a t -> f:(int -> 'a -> 'b) -> 'b t\n    val unzip : ('a * 'b) t -> 'a t * 'b t\n    val zip_exn : 'a t -> 'b t -> ('a * 'b) t\n  end\nend\n```\n\n**`Container_with_local` - Local-Aware Iteration**\n\nInterface for containers that support local closures:\n\n```ocaml\nmodule type S = sig\n  type 'a t\n\n  val iter__local : 'a t -> f:('a -> unit @ local) -> unit\n  val fold__local : 'a t -> init:'acc -> f:('acc -> 'a -> 'acc @ local) -> 'acc\n  val exists__local : 'a t -> f:('a -> bool @ local) -> bool\n  val for_all__local : 'a t -> f:('a -> bool @ local) -> bool\n  val find__local : 'a t -> f:('a -> bool @ local) -> 'a option @ local\n  val find_map__local : 'a t -> f:('a -> 'b option @ local) -> 'b option @ local\nend\n```\n\n**`Array` / `Array0` - Mutable Arrays**\n\n```ocaml\n(* Layout-polymorphic operations *)\nexternal length : 'a. ('a array[@local_opt]) -> int = \"%array_length\"\n  [@@layout_poly]\n\nexternal get : 'a. ('a array[@local_opt]) -> (int[@local_opt]) -> 'a = \"%array_safe_get\"\n  [@@layout_poly]\n\n(* Template-enabled operations *)\n[%%template:\nval init : int -> f:(int -> 'a) -> 'a array\n  [@@alloc __ @ m = (heap_global, stack_local)]]\n```\n\n### Tier 2: Good OxCaml Support\n\n**`List`**\n\n```ocaml\n(* Local-returning variants via %%template *)\nval map__local : 'a list -> f:('a -> 'b @ local) -> 'b list @ local\nval filter__local : 'a list -> f:('a -> bool @ local) -> 'a list @ local\nval filter_map__local : 'a list -> f:('a -> 'b option @ local) -> 'b list @ local\nval concat_map__local : 'a list -> f:('a -> 'b list @ local) -> 'b list @ local\nval fold__local : 'a list -> init:'acc -> f:('acc -> 'a -> 'acc @ local) -> 'acc\n```\n\n**`Option`**\n\n```ocaml\nval map__local : 'a option -> f:('a -> 'b @ local) -> 'b option @ local\nval bind__local : 'a option -> f:('a -> 'b option @ local) -> 'b option @ local\nval value__local : 'a option -> default:'a @ local -> 'a @ local\n```\n\n**`Result`**\n\n```ocaml\nval map__local : ('a, 'e) t -> f:('a -> 'b @ local) -> ('b, 'e) t @ local\nval map_error__local : ('a, 'e) t -> f:('e -> 'f @ local) -> ('a, 'f) t @ local\nval bind__local : ('a, 'e) t -> f:('a -> ('b, 'e) t @ local) -> ('b, 'e) t @ local\n```\n\n**`Or_error`**\n\nMode-aware error handling combining Result with Error.t:\n\n```ocaml\nval map__local : 'a t -> f:('a -> 'b @ local) -> 'b t @ local\nval bind__local : 'a t -> f:('a -> 'b t @ local) -> 'b t @ local\n```\n\n**`Or_null`**\n\nNon-allocating option alternative (uses null representation):\n\n```ocaml\ntype 'a t = Null | This of 'a\n\n(* Zero allocation for None case *)\nval to_option__local : 'a t -> 'a option @ local\n```\n\n### Tier 3: Primitive Types with Local Support\n\nThese modules have `@local_opt` annotations on many functions:\n\n| Module | Key Local Features |\n|--------|-------------------|\n| `Bool`, `Bool0` | Comparison with local args |\n| `Char` | Local-safe character ops |\n| `Int`, `Int32`, `Int64`, `Nativeint` | Conversions with `@local_opt` |\n| `Float`, `Float0` | Math ops with local support |\n| `String`, `String0` | Split/concat local variants |\n| `Bytes`, `Bytes0` | Local buffer creation |\n| `Unit` | Local returns |\n\n---\n\n## Template/Rederive Patterns\n\n66 Base modules use `%%template` and `%%rederive` for mode polymorphism:\n\n### Common Patterns\n\n```ocaml\n(* Mode-templated function *)\n[%%template:\n[@@@mode.default m = (global, local)]\nval map : 'a t -> f:('a -> 'b @ m) -> 'b t @ m]\n\n(* Generates: map (global) and map__local *)\n\n(* Kind-templated function *)\n[%%template:\n[@@@kind.default k = (value, float64)]\nexternal get : ('a : k). 'a array -> int -> 'a = \"%array_safe_get\"\n  [@@layout_poly]]\n\n(* Alloc-templated for stack/heap choice *)\n[%%template:\nval init : int -> f:(int -> 'a) -> 'a t\n  [@@alloc __ @ m = (heap_global, stack_local)]]\n\n(* Portable module variant *)\nmodule%template.portable Make (M : S) : T\n```\n\n### Using Templates in Your Code\n\n```ocaml\n(* Call the local variant explicitly *)\nlet process lst =\n  let local_ mapped = List.map__local lst ~f:transform in\n  List.fold mapped ~init:0 ~f:(+)\n\n(* Or use template instantiation *)\nlet%template[@mode m = (global, local)] my_map lst ~f =\n  (List.map [@mode m]) lst ~f\n```\n\n---\n\n## Portable Functors\n\nFor multicore OCaml, many Base functors have portable variants:\n\n```ocaml\n(* Standard Comparable *)\nmodule Comparable.Make (T : sig\n  type t [@@deriving compare, sexp_of]\nend) : Comparable.S with type t := T.t\n\n(* Portable variant for cross-domain use *)\nmodule Comparable.Make__portable (T : sig\n  type t [@@deriving compare, sexp_of] @@ portable\nend) : Comparable.S with type t := T.t @@ portable\n\n(* Same pattern for Hashable *)\nmodule Hashable.Make__portable (T : sig\n  type t [@@deriving hash, compare, sexp_of] @@ portable\nend) : Hashable.S with type t := T.t @@ portable\n```\n\n### Shorthand with %template.portable\n\n```ocaml\nmodule%template.portable My_key = struct\n  type t = { id : int; name : string }\n  [@@deriving compare, sexp_of, hash]\n\n  include functor Comparable.Make\n  include functor Hashable.Make\nend\n```\n\n---\n\n## Lazy Evaluation\n\n**`Lazy`**\n\n```ocaml\nexternal force : ('a t[@local_opt]) -> 'a = \"%lazy_force\"\n(* Can force local lazy values *)\n```\n\n**`Portable_lazy`**\n\nThread-safe lazy evaluation for portable values:\n\n```ocaml\nmodule Portable_lazy : sig\n  type 'a t\n\n  val from_fun : (unit -> 'a) -> 'a t\n  (* Function must be portable - can run on any domain *)\n\n  val force : 'a t -> 'a\nend\n```\n\n---\n\n## Utility Modules\n\n**`With_return`**\n\n```ocaml\nval with_return__local : ('a return -> 'b @ local) -> 'b @ local\n(* Early return with local value *)\n```\n\n**`Staged`**\n\n```ocaml\nexternal unstage : ('a staged[@local_opt]) -> 'a = \"%identity\"\n(* Zero-cost staging with local support *)\n```\n\n**`Fn`**\n\n```ocaml\nexternal ( |> ) : 'a 'b. 'a -> (('a -> 'b)[@local_opt]) -> 'b = \"%revapply\"\n(* Pipe with local function support *)\n```\n\n---\n\n## Unboxed Numeric Modules\n\nBase provides operations on unboxed numeric types:\n\n```ocaml\n(* Available unboxed operations *)\nmodule Float_u : sig\n  type t = float#\n  val add : t -> t -> t\n  val sub : t -> t -> t\n  val mul : t -> t -> t\n  val div : t -> t -> t\n  val neg : t -> t\n  val abs : t -> t\n  val sqrt : t -> t\n  (* etc. *)\nend\n\nmodule Int32_u : sig\n  type t = int32#\n  val add : t -> t -> t\n  val sub : t -> t -> t\n  val mul : t -> t -> t\n  val div : t -> t -> t\n  (* etc. *)\nend\n\nmodule Int64_u : sig\n  type t = int64#\n  (* same pattern *)\nend\n```\n\n---\n\n## Common Patterns\n\n### Local List Processing Pipeline\n\n```ocaml\nlet process_items items =\n  let local_ filtered = List.filter__local items ~f:is_valid in\n  let local_ mapped = List.map__local filtered ~f:transform in\n  List.fold mapped ~init:0 ~f:(+)  (* Final result is global *)\n```\n\n### Stack-Allocated Temporary Structures\n\n```ocaml\nlet group_and_count items ~key =\n  let local_ groups = Hashtbl.create (module String) in\n  List.iter items ~f:(fun item ->\n    Hashtbl.update groups (key item) ~f:(function\n      | None -> 1\n      | Some n -> n + 1)\n  );\n  Hashtbl.to_alist groups  (* Convert to global at the end *)\n```\n\n### Local Iteration with Early Exit\n\n```ocaml\nlet find_first_valid items =\n  With_return.with_return__local (fun { return } ->\n    List.iter__local items ~f:(fun item ->\n      if is_valid item then return (Some item)\n    );\n    None\n  )\n```\n\n### Immutable Array with Local Init\n\n```ocaml\nlet make_lookup_table size =\n  Iarray.Local.init size ~f:(fun i ->\n    compute_entry i\n  )\n```\n\n### Portable Module for Multicore\n\n```ocaml\nmodule%template.portable Cache_key = struct\n  type t = { domain : string; path : string }\n  [@@deriving compare, sexp_of, hash]\n\n  include functor Comparable.Make\n  include functor Hashable.Make\nend\n\n(* Can now safely use Cache_key across domains *)\n```\n\n---\n\n## Quick Reference: Finding Local Variants\n\nMost Base collection functions follow these naming patterns:\n\n| Standard | Local Variant | Purpose |\n|----------|---------------|---------|\n| `map` | `map__local` | Returns local result |\n| `filter` | `filter__local` | Returns local result |\n| `fold` | `fold__local` | Closure can be local |\n| `iter` | `iter__local` | Closure can be local |\n| `find` | `find__local` | Returns local option |\n| `find_map` | `find_map__local` | Returns local option |\n| `exists` | `exists__local` | Closure can be local |\n| `for_all` | `for_all__local` | Closure can be local |\n\n---\n\n## See Also\n\n- [SKILL-MODES.md](SKILL-MODES.md) - Detailed mode system documentation\n- [SKILL-STACK-ALLOCATION.md](SKILL-STACK-ALLOCATION.md) - Stack allocation patterns\n- [SKILL-TEMPLATES.md](SKILL-TEMPLATES.md) - ppx_template usage and mangling\n- [SKILL-CORE.md](SKILL-CORE.md) - Core library OxCaml extensions\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-COMPREHENSIONS.md": "# OxCaml Comprehensions: Detailed Guide\n\nComprehensions provide concise syntax for building lists and arrays, inspired by\nPython and Haskell.\n\n## Basic Syntax\n\n### List Comprehensions\n\n```ocaml\n(* Basic: generate values *)\n[ x * 2 for x = 1 to 10 ]\n(* [2; 4; 6; 8; 10; 12; 14; 16; 18; 20] *)\n\n(* With filter *)\n[ x for x = 1 to 20 when x mod 3 = 0 ]\n(* [3; 6; 9; 12; 15; 18] *)\n\n(* Iterate over list *)\n[ String.uppercase_ascii s for s in [\"hello\"; \"world\"] ]\n(* [\"HELLO\"; \"WORLD\"] *)\n\n(* Downto *)\n[ x for x = 10 downto 1 ]\n(* [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] *)\n```\n\n### Array Comprehensions\n\n```ocaml\n(* Same syntax with [| |] *)\n[| x * x for x = 1 to 5 |]\n(* [|1; 4; 9; 16; 25|] *)\n\n(* From array *)\n[| f elem for elem in source_array |]\n```\n\n### Immutable Array Comprehensions\n\n```ocaml\n(* Use [: :] for iarray *)\n[: x for x = 1 to 10 when x mod 2 = 0 :]\n(* Returns int iarray *)\n```\n\n### Unboxed/Untagged Array Comprehensions\n\nComprehensions work with unboxed and untagged arrays:\n\n```ocaml\n(* Unboxed float array comprehension *)\n[| #(Float.of_int x) for x = 1 to 10 |] : float# array\n\n(* Untagged int8 array comprehension *)\n[| #(Int8.of_int x) for x = 0 to 255 |] : int8# array\n```\n\n---\n\n## Iterators\n\n### Range Iterators\n\n```ocaml\n(* Counting up *)\n[ x for x = start to stop ]\n\n(* Counting down *)\n[ x for x = stop downto start ]\n\n(* Empty if start > stop (for to) or start < stop (for downto) *)\n[ x for x = 5 to 3 ]  (* [] *)\n```\n\n### Collection Iterators\n\n```ocaml\n(* Iterate over list *)\n[ f x for x in some_list ]\n\n(* Iterate over array (in array comprehension) *)\n[| f x for x in some_array |]\n\n(* With pattern matching *)\n[ a + b for (a, b) in pairs ]\n```\n\n---\n\n## Nested vs Parallel Iteration\n\n### Nested Iteration (`for ... for ...`)\n\nNested `for` clauses create cartesian product - inner re-evaluated each outer:\n\n```ocaml\n[ (x, y) for x = 1 to 3 for y = 1 to 2 ]\n(* [(1,1); (1,2); (2,1); (2,2); (3,1); (3,2)] *)\n(* 3 * 2 = 6 elements *)\n\n(* Inner can depend on outer *)\n[ (x, y) for x = 1 to 3 for y = 1 to x ]\n(* [(1,1); (2,1); (2,2); (3,1); (3,2); (3,3)] *)\n```\n\n### Parallel Iteration (`for ... and ...`)\n\nParallel `and` iterates in lockstep - all sources evaluated once upfront:\n\n```ocaml\n[ (x, y) for x = 1 to 3 and y = 10 to 12 ]\n(* [(1,10); (2,11); (3,12)] *)\n(* min(3, 3) = 3 elements *)\n\n(* Cannot depend on each other *)\n[ (x, y) for x = 1 to 3 and y = 1 to x ]  (* ERROR: x not in scope *)\n```\n\n### Key Differences\n\n| Aspect | `for ... for ...` | `for ... and ...` |\n|--------|-------------------|-------------------|\n| Result size | Product | Minimum |\n| Re-evaluation | Inner re-evaluated | All evaluated once |\n| Dependencies | Inner can use outer | Independent |\n| Optimization | Standard | Fixed-size array opt |\n\n---\n\n## Filter Clauses\n\n### Basic When\n\n```ocaml\n[ x for x = 1 to 100 when x mod 7 = 0 ]\n(* Multiples of 7 from 1 to 100 *)\n```\n\n### Multiple When Clauses\n\n```ocaml\n[ x for x = 1 to 100 when x mod 2 = 0 when x mod 3 = 0 ]\n(* Same as: when x mod 2 = 0 && x mod 3 = 0 *)\n(* Multiples of 6 *)\n```\n\n### When Position Matters\n\n```ocaml\n(* Filter before inner loop *)\n[ (x, y) for x = 1 to 10 when x mod 2 = 0 for y = 1 to 3 ]\n(* Only even x values, all y for each *)\n\n(* Filter after inner loop *)\n[ (x, y) for x = 1 to 10 for y = 1 to 3 when y > x ]\n(* All x, only y > x *)\n```\n\n---\n\n## Complex Examples\n\n### Pythagorean Triples\n\n```ocaml\n[ (a, b, c)\n  for a = 1 to 20\n  for b = a to 20      (* b >= a to avoid duplicates *)\n  for c = b to 20      (* c >= b to avoid duplicates *)\n  when a * a + b * b = c * c ]\n(* [(3,4,5); (5,12,13); (6,8,10); (8,15,17); (9,12,15)] *)\n```\n\n### Flatten Nested Structure\n\n```ocaml\nlet matrix = [[1;2;3]; [4;5;6]; [7;8;9]]\n[ x for row in matrix for x in row ]\n(* [1; 2; 3; 4; 5; 6; 7; 8; 9] *)\n```\n\n### Cross Product with Filter\n\n```ocaml\nlet colors = [\"red\"; \"green\"; \"blue\"]\nlet sizes = [\"S\"; \"M\"; \"L\"]\n[ Printf.sprintf \"%s-%s\" c s\n  for c in colors\n  for s in sizes\n  when not (c = \"red\" && s = \"S\") ]  (* Exclude red-S *)\n```\n\n### Indexed Iteration\n\n```ocaml\nlet items = [|\"a\"; \"b\"; \"c\"; \"d\"|]\n[| (i, items.(i)) for i = 0 to Array.length items - 1 |]\n(* [|(0,\"a\"); (1,\"b\"); (2,\"c\"); (3,\"d\")|] *)\n```\n\n### Zip with Index\n\n```ocaml\nlet xs = [1; 2; 3]\nlet ys = [\"a\"; \"b\"; \"c\"]\n[ (i, x, y)\n  for i = 0 to min (List.length xs) (List.length ys) - 1\n  and x in xs\n  and y in ys ]\n(* [(0,1,\"a\"); (1,2,\"b\"); (2,3,\"c\")] *)\n```\n\n---\n\n## Pattern Matching in Iterators\n\n```ocaml\n(* Destructure tuples *)\n[ a + b for (a, b) in [(1,2); (3,4); (5,6)] ]\n(* [3; 7; 11] *)\n\n(* Destructure records *)\ntype point = { x : int; y : int }\n[ p.x + p.y for p in points ]\n\n(* Partial patterns (may raise) *)\n[ x for Some x in options ]  (* Raises if None encountered! *)\n```\n\n### Safe Filtering Instead\n\n```ocaml\n(* Better: filter explicitly *)\n[ x for opt in options when Option.is_some opt\n    for x in [Option.get opt] ]\n\n(* Or use intermediate binding *)\nlet get_some = function Some x -> [x] | None -> []\n[ x for opt in options for x in get_some opt ]\n```\n\n---\n\n## Evaluation Order\n\n1. Clauses evaluated left to right\n2. `for ... and ...` evaluates all sources before iterating\n3. `when` checked before proceeding to right clauses\n4. Body evaluated for each combination passing all filters\n\n```ocaml\n(* Evaluation order example *)\n[ (Printf.printf \"%d,%d\\n\" x y; (x,y))\n  for x = 1 to 2\n  for y = 1 to 2 ]\n(* Prints: 1,1  1,2  2,1  2,2 *)\n```\n\n---\n\n## Array Optimization\n\nFor array comprehensions with single `for ... and ...` clause, the compiler\npre-allocates exact-size array:\n\n```ocaml\n(* Optimized: single and clause, size known *)\n[| x + y for x = 1 to 1000 and y = 1 to 1000 |]\n(* Pre-allocates 1,000,000 element array *)\n\n(* Not optimized: nested for *)\n[| x + y for x = 1 to 1000 for y = 1 to 1000 |]\n(* Grows array dynamically *)\n\n(* Not optimized: has when clause *)\n[| x for x = 1 to 1000 and y = 1 to 1000 when x > y |]\n(* Can't predict size due to filter *)\n```\n\n---\n\n## Common Patterns\n\n### Map\n\n```ocaml\nlet map f lst = [ f x for x in lst ]\nlet map_array f arr = [| f x for x in arr |]\n```\n\n### Filter\n\n```ocaml\nlet filter pred lst = [ x for x in lst when pred x ]\n```\n\n### Filter-Map\n\n```ocaml\nlet filter_map f lst =\n  [ y for x in lst for y in (match f x with Some v -> [v] | None -> []) ]\n```\n\n### Enumerate\n\n```ocaml\nlet enumerate lst =\n  [ (i, x) for i = 0 to List.length lst - 1 and x in lst ]\n```\n\n### Cartesian Product\n\n```ocaml\nlet product xs ys = [ (x, y) for x in xs for y in ys ]\n```\n\n### Take While\n\n```ocaml\n(* Note: comprehensions don't short-circuit, so this processes all *)\nlet take_while pred lst =\n  let rec go acc = function\n    | [] -> List.rev acc\n    | x :: _ when not (pred x) -> List.rev acc\n    | x :: xs -> go (x :: acc) xs\n  in go [] lst\n(* Comprehensions not ideal for take_while *)\n```\n\n---\n\n## Performance Tips\n\n1. **Prefer `and` over nested `for`** when iteration is parallel and size is fixed\n2. **Put restrictive `when` clauses early** to skip work\n3. **Array comprehensions** are generally faster than list (no cons overhead)\n4. **For very large results**, consider alternative approaches (iterators, sequences)\n\n---\n\n## Limitations\n\n- Cannot break out early (no `break` or `return`)\n- Partial patterns may raise exceptions\n- Local allocations in comprehensions follow normal rules\n- Nested comprehensions can be memory-intensive\n\nSee also: [SKILL.md](SKILL.md) for quick reference,\n[SKILL-STACK-ALLOCATION.md](SKILL-STACK-ALLOCATION.md) for local list building.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-CORE.md": "# OxCaml Core Library Extensions\n\nJane Street's Core library builds on Base with additional OxCaml-specific\nfeatures for I/O, concurrency, and system programming.\n\n## Mode-Aware I/O\n\n### In_channel and Out_channel\n\n```ocaml\nopen Core\n\n(* Read with local buffer *)\nval In_channel.input__local : t -> buf:bytes @ local -> pos:int -> len:int -> int\n\n(* Fold over lines with local accumulator *)\nval In_channel.fold_lines__local\n  :  t\n  -> init:'acc\n  -> f:('acc -> string -> 'acc @ local)\n  -> 'acc\n```\n\n### Bigstring I/O\n\n```ocaml\n(* Read directly into bigstring - no copy *)\nval In_channel.really_input_bigstring\n  :  t\n  -> Bigstring.t\n  -> pos:int\n  -> len:int\n  -> unit\n\n(* Write from bigstring *)\nval Out_channel.output_bigstring\n  :  t\n  -> Bigstring.t\n  -> pos:int\n  -> len:int\n  -> unit\n```\n\n---\n\n## Time with Unboxed Types\n\n### Time_ns\n\n```ocaml\nmodule Time_ns : sig\n  (* Unboxed time representation *)\n  type t  (* boxed *)\n  type t_unboxed = int64#  (* unboxed nanoseconds since epoch *)\n\n  val to_int63_ns_since_epoch : t -> Int63.t\n  val of_int63_ns_since_epoch : Int63.t -> t\n\n  (* Unboxed operations *)\n  module Unboxed : sig\n    val now : unit -> t_unboxed\n    val diff : t_unboxed -> t_unboxed -> int64#\n    val add : t_unboxed -> int64# -> t_unboxed\n  end\nend\n```\n\n### Time_ns.Span\n\n```ocaml\nmodule Time_ns.Span : sig\n  type t\n\n  (* Unboxed span operations *)\n  val to_int63_ns : t -> Int63.t\n  val of_int63_ns : Int63.t -> t\n\n  (* Direct nanosecond access *)\n  val to_ns_unboxed : t -> int64#\n  val of_ns_unboxed : int64# -> t\nend\n```\n\n---\n\n## Command with Modes\n\n### Local Argument Parsing\n\n```ocaml\nopen Core\n\nlet command =\n  Command.basic\n    ~summary:\"Process files\"\n    (let%map_open.Command\n       files = anon (sequence (\"FILE\" %: Filename_unix.arg_type))\n     and verbose = flag \"-v\" no_arg ~doc:\"Verbose output\"\n     in\n     fun () ->\n       (* Argument processing can use local *)\n       let local_ processed = List.map__local files ~f:process_file in\n       output_results processed)\n```\n\n---\n\n## Iobuf with Modes\n\nZero-copy buffer manipulation:\n\n```ocaml\nmodule Iobuf : sig\n  type ('rw, 'seek) t\n\n  (* Create local iobuf *)\n  val create__local : len:int -> (read_write, seek) t @ local\n\n  (* Consume with local return *)\n  val Consume.stringo__local\n    :  (read, _) t\n    -> len:int\n    -> string @ local\n\n  (* Peek without consuming *)\n  val Peek.int64_le : (read, _) t -> pos:int -> int64\n  val Peek.int64_le_unboxed : (read, _) t -> pos:int -> int64#\nend\n```\n\n### Iobuf Patterns\n\n```ocaml\nlet parse_packet iobuf =\n  (* Peek header without consuming *)\n  let msg_type = Iobuf.Peek.int8 iobuf ~pos:0 in\n  let msg_len = Iobuf.Peek.int32_le iobuf ~pos:1 in\n\n  (* Consume the message *)\n  let local_ payload = Iobuf.Consume.stringo__local iobuf ~len:msg_len in\n  process_message msg_type payload\n```\n\n---\n\n## Core_unix with Modes\n\n### File Operations\n\n```ocaml\nmodule Core_unix : sig\n  (* Read with local buffer *)\n  val read__local\n    :  File_descr.t\n    -> buf:bytes @ local\n    -> pos:int\n    -> len:int\n    -> int\n\n  (* Stat returning local record *)\n  val stat__local : string -> stats @ local\n  val lstat__local : string -> stats @ local\nend\n```\n\n### Socket Operations\n\n```ocaml\n(* Recv with local buffer *)\nval recv__local\n  :  File_descr.t\n  -> buf:bytes @ local\n  -> pos:int\n  -> len:int\n  -> recv_flag list\n  -> int\n\n(* Recvfrom returning local address *)\nval recvfrom__local\n  :  File_descr.t\n  -> buf:bytes @ local\n  -> pos:int\n  -> len:int\n  -> recv_flag list\n  -> int * sockaddr @ local\n```\n\n---\n\n## Async with Modes (Async_kernel)\n\n### Deferred with Local\n\n```ocaml\nmodule Deferred : sig\n  (* Map with local function *)\n  val map__local : 'a t -> f:('a -> 'b @ local) -> 'b t @ local\n\n  (* Bind with local continuation *)\n  val bind__local : 'a t -> f:('a -> 'b t @ local) -> 'b t @ local\nend\n```\n\n### Pipe with Modes\n\n```ocaml\nmodule Pipe : sig\n  (* Read with local return *)\n  val read__local : 'a Reader.t -> [ `Ok of 'a | `Eof ] @ local Deferred.t\n\n  (* Fold with local accumulator *)\n  val fold__local\n    :  'a Reader.t\n    -> init:'acc\n    -> f:('acc -> 'a -> 'acc @ local Deferred.t)\n    -> 'acc Deferred.t\nend\n```\n\n---\n\n## Portable Async\n\nFor multicore Async:\n\n```ocaml\n(* Portable job scheduling *)\nmodule Scheduler : sig\n  val schedule__portable\n    :  (unit -> unit) @ portable\n    -> unit\nend\n\n(* Portable deferred operations *)\nval Deferred.map__portable\n  :  'a t\n  -> f:('a -> 'b) @ portable\n  -> 'b t @ portable\n```\n\n---\n\n## Bigstring Extensions\n\nCore's `Bigstring` module provides optimized operations on `Bigarray.Array1.t`\nwith OxCaml extensions for unboxed access and local operations.\n\n### Type and Creation\n\n```ocaml\nmodule Bigstring : sig\n  (* Bigstring is a char bigarray with C layout *)\n  type t = (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t\n\n  (* Creation *)\n  val create : int -> t\n  val init : int -> f:(int -> char) -> t\n\n  (* Local creation - stack allocated *)\n  val create__local : int -> t @ local\n\n  (* From existing data *)\n  val of_string : ?pos:int -> ?len:int -> string -> t\n  val of_bytes : ?pos:int -> ?len:int -> bytes -> t\n\n  (* Sub-view (shares memory) *)\n  val sub_shared : ?pos:int -> ?len:int -> t -> t\nend\n```\n\n### Basic Access (Boxed)\n\n```ocaml\n(* Single byte access *)\nval get : t -> int -> char\nval set : t -> int -> char -> unit\nval unsafe_get : t -> int -> char\nval unsafe_set : t -> int -> char -> unit\n\n(* Multi-byte access - little endian *)\nval get_int16_le : t -> pos:int -> int\nval get_int32_le : t -> pos:int -> int32\nval get_int64_le : t -> pos:int -> int64\nval get_float : t -> pos:int -> float  (* IEEE 754 double *)\n\n(* Multi-byte access - big endian *)\nval get_int16_be : t -> pos:int -> int\nval get_int32_be : t -> pos:int -> int32\nval get_int64_be : t -> pos:int -> int64\n\n(* Setters follow same pattern *)\nval set_int32_le : t -> pos:int -> int32 -> unit\nval set_int64_le : t -> pos:int -> int64 -> unit\nval set_float : t -> pos:int -> float -> unit\n(* etc. *)\n```\n\n### Unboxed Access (Zero Allocation)\n\nThese functions avoid boxing overhead for numeric types:\n\n```ocaml\n(* Unboxed getters - no heap allocation *)\nval get_int32_le_unboxed : t -> pos:int -> int32#\nval get_int32_be_unboxed : t -> pos:int -> int32#\nval get_int64_le_unboxed : t -> pos:int -> int64#\nval get_int64_be_unboxed : t -> pos:int -> int64#\nval get_float_unboxed : t -> pos:int -> float#\n\n(* Unboxed setters *)\nval set_int32_le_unboxed : t -> pos:int -> int32# -> unit\nval set_int32_be_unboxed : t -> pos:int -> int32# -> unit\nval set_int64_le_unboxed : t -> pos:int -> int64# -> unit\nval set_int64_be_unboxed : t -> pos:int -> int64# -> unit\nval set_float_unboxed : t -> pos:int -> float# -> unit\n\n(* Unsafe unboxed variants (no bounds check) *)\nval unsafe_get_int64_le_unboxed : t -> pos:int -> int64#\nval unsafe_set_int64_le_unboxed : t -> pos:int -> int64# -> unit\n(* etc. *)\n```\n\n### Bulk Operations\n\n```ocaml\n(* Memory operations *)\nval length : t -> int\nval blit : src:t -> src_pos:int -> dst:t -> dst_pos:int -> len:int -> unit\nval memset : t -> pos:int -> len:int -> char -> unit\nval memcmp : t -> pos1:int -> t -> pos2:int -> len:int -> int\n\n(* With bytes/string *)\nval blit_string_bigstring : string -> src_pos:int -> t -> dst_pos:int -> len:int -> unit\nval blit_bigstring_string : t -> src_pos:int -> bytes -> dst_pos:int -> len:int -> unit\nval blit_bigstring_bytes : t -> src_pos:int -> bytes -> dst_pos:int -> len:int -> unit\nval blit_bytes_bigstring : bytes -> src_pos:int -> t -> dst_pos:int -> len:int -> unit\n```\n\n### String/Bytes Conversion\n\n```ocaml\n(* To string/bytes - copies data *)\nval to_string : ?pos:int -> ?len:int -> t -> string\nval to_bytes : ?pos:int -> ?len:int -> t -> bytes\n\n(* Local variants - result is stack-allocated *)\nval to_string__local : ?pos:int -> ?len:int -> t -> string @ local\nval to_bytes__local : ?pos:int -> ?len:int -> t -> bytes @ local\n\n(* Substring extraction *)\nval get_string : t -> pos:int -> len:int -> string\nval get_string__local : t -> pos:int -> len:int -> string @ local\n```\n\n### Local Operations\n\n```ocaml\n(* Find with local predicate *)\nval find__local : t -> pos:int -> len:int -> f:(char -> bool @ local) -> int option\n\n(* Iterate with local closure *)\nval iter__local : t -> f:(char -> unit @ local) -> unit\nval iteri__local : t -> f:(int -> char -> unit @ local) -> unit\n\n(* Fold with local accumulator function *)\nval fold__local : t -> init:'a -> f:('a -> char -> 'a @ local) -> 'a\n```\n\n### I/O Operations\n\n```ocaml\n(* File I/O - zero-copy where possible *)\nval read : Unix.file_descr -> ?pos:int -> ?len:int -> t -> int\nval write : Unix.file_descr -> ?pos:int -> ?len:int -> t -> int\nval really_read : Unix.file_descr -> ?pos:int -> ?len:int -> t -> unit\nval really_write : Unix.file_descr -> ?pos:int -> ?len:int -> t -> unit\n\n(* With In_channel/Out_channel *)\nval input : In_channel.t -> ?pos:int -> ?len:int -> t -> int\nval output : Out_channel.t -> ?pos:int -> ?len:int -> t -> unit\n```\n\n### Zero-Copy Patterns\n\n```ocaml\n(* Parse binary protocol without allocation *)\nlet[@zero_alloc] parse_header bigstring ~pos =\n  let magic = Bigstring.get_int32_le_unboxed bigstring ~pos in\n  let version = Bigstring.get_int16_le bigstring ~pos:(pos + 4) in\n  let length = Bigstring.get_int32_le_unboxed bigstring ~pos:(pos + 6) in\n  let timestamp = Bigstring.get_int64_le_unboxed bigstring ~pos:(pos + 10) in\n  #{ magic; version; length; timestamp }  (* unboxed record *)\n\n(* Process packet stream *)\nlet process_packets bigstring =\n  let len = Bigstring.length bigstring in\n  let rec loop pos =\n    if pos >= len then ()\n    else begin\n      let pkt_len = Bigstring.get_int32_le_unboxed bigstring ~pos in\n      let pkt_len_int = Int32_u.to_int pkt_len in\n      (* Process without copying *)\n      handle_packet bigstring ~pos:(pos + 4) ~len:pkt_len_int;\n      loop (pos + 4 + pkt_len_int)\n    end\n  in\n  loop 0\n\n(* Local string extraction for temporary use *)\nlet find_field bigstring ~field_pos ~field_len =\n  let local_ field_str = Bigstring.get_string__local bigstring\n    ~pos:field_pos ~len:field_len in\n  lookup_field field_str  (* result escapes, string doesn't *)\n```\n\n### Comparison with Bytes\n\n| Operation | `Bytes` | `Bigstring` | Notes |\n|-----------|---------|-------------|-------|\n| Allocation | OCaml heap | C heap | Bigstring avoids GC pressure |\n| Max size | ~16MB (32-bit) | System limit | Bigstring for large buffers |\n| Access speed | Fast | Fast | Both have optimized primitives |\n| Unboxed access | No | Yes | Bigstring has `_unboxed` variants |\n| mmap compatible | No | Yes | Bigstring can wrap mmap'd memory |\n| Local creation | Yes | Yes | Both support stack allocation |\n\n---\n\n## Bin_prot with Modes\n\nBinary protocol serialization:\n\n```ocaml\nmodule Bin_prot : sig\n  (* Write to local buffer *)\n  val write__local : 'a Type_class.writer -> buf:bytes @ local -> 'a -> int\n\n  (* Read with local intermediate *)\n  val read__local\n    :  'a Type_class.reader\n    -> buf:bytes @ local\n    -> pos_ref:int ref\n    -> 'a\nend\n```\n\n---\n\n## Sexp with Modes\n\n### Local Sexp Operations\n\n```ocaml\nmodule Sexp : sig\n  (* Parse to local sexp *)\n  val of_string__local : string -> t @ local\n\n  (* Convert with local intermediate *)\n  val to_string__local : t -> string @ local\nend\n```\n\n### Sexp_of with Local\n\n```ocaml\n(* For types with local sexp_of *)\ntype t [@@deriving sexp_of__local]\n\nval sexp_of_t__local : t -> Sexp.t @ local\n```\n\n---\n\n## Error Handling\n\n### Or_error with Modes\n\n```ocaml\nmodule Or_error : sig\n  val map__local : 'a t -> f:('a -> 'b @ local) -> 'b t @ local\n  val bind__local : 'a t -> f:('a -> 'b t @ local) -> 'b t @ local\n\n  (* Error creation *)\n  val error_s__local : Sexp.t @ local -> _ t\nend\n```\n\n### Error with Local Message\n\n```ocaml\nlet validate x =\n  if x < 0 then\n    let local_ msg = sprintf \"Invalid value: %d\" x in\n    Or_error.error_string__local msg\n  else\n    Ok x\n```\n\n---\n\n## Common Patterns\n\n### Zero-Copy Network Processing\n\n```ocaml\nlet handle_connection fd =\n  let buf = Bigstring.create 4096 in\n  let rec loop () =\n    match Core_unix.read_bigstring fd buf ~pos:0 ~len:4096 with\n    | 0 -> ()\n    | n ->\n      (* Process without copying *)\n      let msg_type = Bigstring.get_int8 buf ~pos:0 in\n      let payload_len = Bigstring.get_int32_le_unboxed buf ~pos:1 in\n      process_message buf ~msg_type ~len:(Int32_u.to_int payload_len);\n      loop ()\n  in\n  loop ()\n```\n\n### Portable Async Pipeline\n\n```ocaml\nlet%template.portable process_stream reader =\n  Pipe.fold reader ~init:0 ~f:(fun count item ->\n    let result = process_item item in\n    log_result result;\n    return (count + 1)\n  )\n```\n\n### Local Buffer Reuse\n\n```ocaml\nlet process_many_files files =\n  (* Reuse local buffer across iterations *)\n  let local_ buf = Bytes.create 8192 in\n  List.iter files ~f:(fun filename ->\n    In_channel.with_file filename ~f:(fun ic ->\n      let n = In_channel.input__local ic ~buf ~pos:0 ~len:8192 in\n      process_chunk buf ~len:n\n    )\n  )\n```\n\n---\n\n## Migration Checklist\n\nWhen updating Core code for OxCaml:\n\n1. **Replace heap buffers with local** where possible\n2. **Use unboxed Bigstring accessors** for binary data\n3. **Use `__local` variants** for intermediate collections\n4. **Add `@@portable`** annotations for multicore code\n5. **Use `Iobuf`** for zero-copy buffer manipulation\n6. **Use unboxed Time_ns** operations in hot paths\n\nSee also: [SKILL-BASE.md](SKILL-BASE.md) for Base extensions,\n[SKILL-ZERO-ALLOC.md](SKILL-ZERO-ALLOC.md) for allocation-free patterns.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-KINDS.md": "# OxCaml Kinds: Detailed Guide\n\nKinds classify types by their runtime representation (layout). They determine\nhow values are stored, passed, and what operations are valid.\n\n## Kind Hierarchy\n\n```\nany                              (* Top kind - any layout *)\n├── value                        (* Standard OCaml boxed values *)\n│   └── immediate                (* Unboxed integers, no GC scanning *)\n│       └── immediate64          (* Immediate on 64-bit only *)\n├── void                         (* Uninhabited, zero size *)\n├── float64                      (* Unboxed 64-bit float *)\n├── float32                      (* Unboxed 32-bit float *)\n├── bits32                       (* Unboxed 32-bit integer *)\n├── bits64                       (* Unboxed 64-bit integer *)\n├── word                         (* Native word size *)\n└── vec128 / vec256              (* SIMD vectors *)\n```\n\n## Basic Kind Annotations\n\n### On Type Definitions\n\n```ocaml\n(* Abstract type with specific layout *)\ntype t : float64\n\n(* Type alias preserving layout *)\ntype my_float : float64 = float#\n\n(* Parameterized with kind constraint *)\ntype ('a : value) boxed_list = 'a list\ntype ('a : float64) float_pair = 'a * 'a\n```\n\n### On Type Parameters\n\n```ocaml\n(* Single parameter *)\ntype ('a : bits32) container = { value : 'a }\n\n(* Multiple parameters with different kinds *)\ntype ('a : value, 'b : float64) mixed = {\n  boxed : 'a;\n  unboxed : 'b;\n}\n```\n\n### In Signatures\n\n```ocaml\n(* Kind-annotated polymorphism *)\nval id : ('a : value). 'a -> 'a\nval id_float : ('a : float64). 'a -> 'a\n\n(* Mixed *)\nval convert : ('a : bits32). 'a -> ('b : bits64). 'b\n```\n\n### On Locally Abstract Types\n\n```ocaml\nlet process (type a : float64) (x : a) : a = x\n\nlet example () =\n  process #3.14  (* a instantiated to float# *)\n```\n\n---\n\n## Kind Abbreviations\n\nCommon kind patterns have shorthand names:\n\n```ocaml\nvalue           (* Boxed OCaml values, GC-managed *)\nimmediate       (* Tagged integers: int, char, bool, etc. *)\nimmediate64     (* Immediate on 64-bit, boxed on 32-bit *)\nmutable_data    (* value mod non_float - records with mutable fields *)\nimmutable_data  (* value mod non_float immutable *)\n```\n\n### What Types Have Which Kinds?\n\n| Type | Kind |\n|------|------|\n| `int`, `char`, `bool`, `unit` | `immediate` |\n| `float` | `value` (but special float array optimization) |\n| `string`, `'a list`, `'a option` | `value` |\n| `int32`, `int64`, `nativeint` | `value` (boxed) |\n| `float#` | `float64` |\n| `int32#` | `bits32` |\n| `int64#` | `bits64` |\n| `float32#` | `float32` |\n| `nativeint#` | `word` |\n| `int8x16#`, etc. | `vec128` |\n| `int8x32#`, etc. | `vec256` |\n| `int8# array` | `value` (specialized subkind) |\n| `int16# array` | `value` (specialized subkind) |\n| `int# array` | `value` (specialized subkind) |\n\n---\n\n## Kind Products\n\nUnboxed tuples have product kinds:\n\n```ocaml\n(* Unboxed pair of float# and int32# *)\ntype pair : float64 & bits32\n\n(* Three-element product *)\ntype triple : float64 & float64 & bits32\n\n(* In type parameters *)\ntype ('a : float64 & bits32) wrapper = { data : 'a }\n```\n\n### Creating Product Values\n\n```ocaml\nlet p : #(float# * int32#) = #(#3.14, #42l)\n(* p has kind float64 & bits32 *)\n```\n\n---\n\n## Mode Bounds on Kinds\n\nKinds can include mode constraints:\n\n```ocaml\n(* Type that must be global *)\ntype t : value mod global\n\n(* Type that is always portable *)\ntype portable_t : value mod portable\n\n(* Type that crosses locality *)\ntype crosser : value mod global local\n```\n\n### Mode Bound Meanings\n\n| Bound | Meaning |\n|-------|---------|\n| `mod global` | Cannot be local |\n| `mod portable` | Safe for cross-thread |\n| `mod external_` | GC ignores it (immediate) |\n| `mod non_float` | Not a float (for array optimization) |\n| `mod immutable` | No mutable fields |\n\n---\n\n## Computing Kinds of User Types\n\n### Records\n\n```ocaml\n(* Immutable record with value fields *)\ntype point = { x : int; y : int }\n(* Kind: immutable_data with x, y *)\n\n(* Mutable record *)\ntype counter = { mutable count : int }\n(* Kind: mutable_data with count *)\n\n(* Unboxed record *)\ntype vec2 = #{ x : float#; y : float# }\n(* Kind: float64 & float64 mod everything *)\n```\n\n### Variants\n\n```ocaml\n(* All-constant constructors *)\ntype color = Red | Green | Blue\n(* Kind: immediate *)\n\n(* With data *)\ntype 'a option = None | Some of 'a\n(* Kind: immutable_data with 'a *)\n\n(* Mutable field in constructor *)\ntype 'a ref = { mutable contents : 'a }\n(* Kind: mutable_data with contents *)\n```\n\n### Tuples\n\n```ocaml\n(* Boxed tuple *)\ntype pair = int * int\n(* Kind: immutable_data with int, int *)\n\n(* Unboxed tuple *)\ntype upair = #(int * int)\n(* Kind: value & value mod everything *)\n```\n\n---\n\n## Kind Polymorphism with Templates\n\nSince OxCaml doesn't yet have first-class kind polymorphism, use `ppx_template`:\n\n```ocaml\n(* Define for multiple kinds *)\nlet%template id (type a : k) (x : a) : a = x\n[@@kind k = (value, float64, bits32, bits64)]\n\n(* Generates: id, id__float64, id__bits32, id__bits64 *)\n\n(* Use with kind attribute *)\nlet f x = (id [@kind float64]) x\n```\n\n---\n\n## Kind Inference\n\nThe compiler infers kinds when possible:\n\n```ocaml\n(* 'a inferred as value (default) *)\nlet f x = x\n(* val f : 'a -> 'a *)\n\n(* 'a inferred from context *)\nlet g (x : float#) = x\n(* val g : float# -> float# *)\n(* Internally: ('a : float64). 'a -> 'a instantiated *)\n```\n\n### Flexible vs Rigid Variables\n\n```ocaml\n(* Flexible: infers kind from usage *)\nlet f x = (x : float#)\n(* x must have kind float64 *)\n\n(* Rigid: kind specified at binding *)\nlet g (type a : float64) (x : a) = x\n(* a is exactly float64 *)\n```\n\n---\n\n## Subkinding\n\nMore specific kinds can be used where general ones are expected:\n\n```ocaml\nimmediate ≤ immediate64 ≤ value ≤ any\nfloat64 ≤ any\nbits32 ≤ any\n(* etc. *)\n\n(* Can pass immediate where value expected *)\nval f : ('a : value). 'a -> 'a\nlet _ = f 42  (* int is immediate, which ≤ value *)\n```\n\n---\n\n## Kind Errors and Solutions\n\n### \"This type has kind X but was expected to have kind Y\"\n\n```ocaml\n(* ERROR: float# has kind float64, not value *)\nlet f (x : 'a) = x\nlet _ = f #3.14\n\n(* FIX: Add kind annotation *)\nlet f (type a : float64) (x : a) = x\nlet _ = f #3.14\n\n(* OR use template *)\nlet%template f (type a : k) (x : a) = x\n[@@kind k = (value, float64)]\n```\n\n### \"Cannot use type with kind X in this context\"\n\n```ocaml\n(* ERROR: list elements must be value *)\nlet bad : float# list = [#1.0; #2.0]\n\n(* FIX: Box the values *)\nlet good : float list = [1.0; 2.0]\n\n(* OR use unboxed array *)\nlet also_good : float# array = [| #1.0; #2.0 |]\n```\n\n### \"The layout of 'a is X because...\"\n\n```ocaml\n(* ERROR: conflicting kind constraints *)\nlet bad (type a : value) (x : a) : float# = x\n\n(* The error explains: 'a has kind value, but float# needs float64 *)\n```\n\n---\n\n## Common Patterns\n\n### Kind-Polymorphic Wrapper\n\n```ocaml\ntype%template ('a : k) cell = { mutable value : 'a }\n[@@kind k = (value, float64, bits32)]\n\nlet%template get (type a : k) (c : a cell) : a = c.value\n[@@kind k = (value, float64, bits32)]\n\nlet%template set (type a : k) (c : a cell) (v : a) : unit = c.value <- v\n[@@kind k = (value, float64, bits32)]\n```\n\n### Constraint Propagation\n\n```ocaml\n(* Container constrains element kind *)\ntype ('a : value) box = { contents : 'a }\n\n(* Function inherits constraint *)\nlet unbox (b : 'a box) : 'a = b.contents\n(* 'a implicitly has kind value *)\n```\n\n### Mixed Kind Records\n\n```ocaml\ntype measurement = {\n  label : string;        (* value *)\n  value : float#;        (* float64, stored unboxed *)\n  precision : int32#;    (* bits32, stored unboxed *)\n}\n\n(* Efficient: unboxed fields inline, no extra indirection *)\n```\n\n---\n\n## Summary Table\n\n| Kind | Examples | GC Scanned | Size |\n|------|----------|------------|------|\n| `value` | `int list`, `string` | Yes | 1 word |\n| `immediate` | `int`, `bool`, `char` | No | 1 word |\n| `float64` | `float#` | No | 8 bytes |\n| `float32` | `float32#` | No | 4 bytes |\n| `bits32` | `int32#` | No | 4 bytes |\n| `bits64` | `int64#` | No | 8 bytes |\n| `word` | `nativeint#` | No | native |\n| `void` | (uninhabited) | - | 0 |\n| `any` | (any of above) | Varies | Varies |\n\nSee also: [SKILL-UNBOXED.md](SKILL-UNBOXED.md) for unboxed types,\n[SKILL-TEMPLATES.md](SKILL-TEMPLATES.md) for kind polymorphism.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-MODES.md": "# OxCaml Modes: Detailed Guide\n\nModes are compile-time properties that track runtime characteristics of values.\nThey enable memory safety, thread safety, and performance optimizations without\nruntime overhead.\n\n## Mode Axes Overview\n\nOxCaml has five independent mode axes:\n\n| Axis | Modes | Tracks |\n|------|-------|--------|\n| Locality | `local` / `global` | Stack vs heap allocation |\n| Uniqueness | `unique` / `aliased` | Single vs multiple references |\n| Linearity | `once` / `many` | Closure invocation count |\n| Portability | `portable` / `shareable` / `nonportable` | Cross-thread safety |\n| Contention | `contended` / `shared` / `uncontended` | Concurrent access |\n\nEach axis is independent - a value can be `local unique once` or `global aliased many`.\n\n---\n\n## Syntax Reference\n\n### On Function Parameters\n\n```ocaml\n(* Single mode *)\nlet f (x @ local) = ...\nlet g (x @ unique) = ...\n\n(* Multiple modes *)\nlet h (x @ local unique once) = ...\n\n(* With type annotation *)\nlet process (data @ local : int array) = ...\n```\n\n### On Return Types (Signatures)\n\n```ocaml\n(* Arrow syntax in signatures *)\nval f : t @ local -> t @ global\nval g : t @ unique -> t @ aliased\nval h : t @ local unique -> t @ global aliased\n\n(* Multiple arrows *)\nval compose : ('a -> 'b) @ once -> ('b -> 'c) @ once -> ('a -> 'c) @ once\n```\n\n### On Expressions\n\n```ocaml\n(* Type annotation with mode *)\nlet x = (some_expr : t @ local)\n\n(* Cast to weaker mode *)\nlet y = (unique_val : t @ aliased)\n```\n\n### On Let Bindings\n\n```ocaml\n(* Shorthand for common modes *)\nlet local_ x = (1, 2)       (* x is local *)\nlet global_ y = (3, 4)      (* y is global - explicit *)\nlet stack_ z = (5, 6)       (* z is stack-allocated local *)\n```\n\n### On Record Fields (Modalities)\n\nModalities specify the mode of field contents relative to the record:\n\n```ocaml\ntype t = {\n  global_ name : string;           (* always global, even if record is local *)\n  mutable count : int @@ aliased;  (* always aliased *)\n  callback : (unit -> unit) @@ many; (* always many, not once *)\n}\n```\n\n**Important**: For modalities, `@@ global` always implies `@@ aliased`. You cannot\nuse `@@ global unique` together - this restriction ensures soundness of the\nupcoming borrowing feature. If you need a global field in a unique context,\nuse `@@ global aliased` explicitly.\n\n---\n\n## Subtyping (Mode Coercion)\n\nModes have a subtyping relationship. You can use a \"stronger\" mode where a\n\"weaker\" one is expected:\n\n```\nLocality:    global ≤ local     (global values can be used as local)\nUniqueness:  unique ≤ aliased   (unique values can be used as aliased)\nLinearity:   many ≤ once        (many closures can be used as once)\nPortability: portable ≤ shareable ≤ nonportable\nContention:  uncontended ≤ shared ≤ contended\n```\n\n### Examples\n\n```ocaml\n(* OK: using global where local expected *)\nlet use_local (x @ local) = ...\nlet _ = use_local global_value\n\n(* OK: using unique where aliased expected *)\nlet use_aliased (x @ aliased) = ...\nlet _ = use_aliased unique_value\n\n(* ERROR: using local where global expected *)\nlet use_global (x @ global) = ...\nlet _ = use_global local_value  (* Type error! *)\n```\n\n---\n\n## Deep vs Shallow Modes\n\nModes are **deep** - they apply to the entire value structure:\n\n```ocaml\n(* If a tuple is local, all its components are local *)\nlet local_ pair = (make_a (), make_b ())\n(* Both components are local *)\n\n(* If a record is unique, all its (non-modality) fields are unique *)\nlet use_unique (r @ unique) =\n  free r.field1;  (* field1 is also unique *)\n  free r.field2   (* ERROR: r already partially consumed *)\n```\n\n### Breaking Depth with Modalities\n\n```ocaml\ntype container = {\n  global_ data : string;  (* data is always global *)\n  local_stuff : int list; (* follows container's mode *)\n}\n\nlet f (c @ local) =\n  let s = c.data in   (* s is global! *)\n  let l = c.local_stuff in  (* l is local *)\n  s  (* can return s *)\n```\n\n---\n\n## Mode Inference\n\nThe compiler infers modes when not specified:\n\n```ocaml\n(* Compiler infers: val f : 'a -> 'a @ global aliased many *)\nlet f x = x\n\n(* Explicit local forces local inference *)\nlet g (x @ local) = x\n(* Inferred: val g : 'a @ local -> 'a @ local *)\n```\n\n### Inference from Usage\n\n```ocaml\n(* If result is used locally, function inferred as returning local *)\nlet make () = (1, 2)\n\nlet use () =\n  let local_ p = make () in  (* forces make to return local *)\n  fst p\n\n(* Now make is inferred as: unit -> (int * int) @ local *)\n```\n\n---\n\n## Mode Crossing\n\nSome types can \"cross\" modes - be treated as a stronger mode than they have:\n\n```ocaml\n(* Immediates (int, char, bool, etc.) cross all modes *)\nlet f (x @ local) : int @ global = x  (* OK! int crosses locality *)\n\n(* Functions don't cross linearity *)\nlet g (f @ once) : (int -> int) @ many = f  (* ERROR *)\n\n(* Immutable data without functions crosses uniqueness *)\nlet h (lst @ aliased) : int list @ unique = lst  (* OK if lst is immutable *)\n```\n\n### Checking Mode Crossing\n\nA type crosses a mode if using it at that mode is safe:\n- `int`, `bool`, `char`, etc. cross everything (they're immediates)\n- Immutable data without closures crosses uniqueness\n- Data without mutable state crosses linearity\n\n---\n\n## Practical Patterns\n\n### Local Processing, Global Result\n\n```ocaml\nlet process_data data =\n  (* Use local allocations for intermediate work *)\n  let local_ temp = compute_step1 data in\n  let local_ temp2 = compute_step2 temp in\n  (* Extract global result *)\n  extract_result temp2  (* returns global *)\n```\n\n### Unique Resource with Aliased Contents\n\n```ocaml\ntype 'a resource = {\n  handle : handle;\n  contents : 'a @@ aliased;  (* contents can be shared *)\n}\n\nlet use (r @ unique) =\n  let data = r.contents in  (* data is aliased, can be copied *)\n  process data;\n  close r.handle  (* safe: r is unique *)\n```\n\n### Once Callbacks\n\n```ocaml\ntype 'a promise\n\nval on_complete : 'a promise -> ('a -> unit) @ once -> unit\n\nlet example p =\n  let resource = acquire () in\n  on_complete p (fun result ->\n    use_resource resource result;\n    release resource  (* safe: callback runs at most once *)\n  )\n```\n\n### Portable Data for Threading\n\n```ocaml\n(* Data that can be sent across threads *)\ntype config = {\n  max_threads : int;\n  timeout : float;\n} [@@deriving portable]\n\nval spawn : (unit -> 'a @ portable) @ portable -> 'a promise\n```\n\n---\n\n## Common Errors and Solutions\n\n### \"This value is local but expected to be global\"\n\n```ocaml\n(* ERROR *)\nlet bad () =\n  let local_ x = (1, 2) in\n  x  (* Cannot return local value *)\n\n(* FIX: Use exclave_ to allocate in caller's frame *)\nlet good () = exclave_\n  stack_ (1, 2)\n\n(* FIX: Or allocate globally *)\nlet good2 () =\n  (1, 2)  (* Global by default *)\n```\n\n### \"This value is aliased but expected to be unique\"\n\n```ocaml\n(* ERROR *)\nlet bad x =\n  let y = x in  (* x now aliased *)\n  free x        (* Cannot free aliased value *)\n\n(* FIX: Don't alias before unique use *)\nlet good x =\n  free x\n\n(* FIX: Or use the alias instead *)\nlet good2 x =\n  let y = x in\n  free y\n```\n\n### \"This closure is once but expected to be many\"\n\n```ocaml\n(* ERROR *)\nlet bad (r @ unique) =\n  let f () = free r in\n  f ();\n  f ()  (* Cannot call once closure twice *)\n\n(* FIX: Thread unique value through *)\nlet good (r @ unique) =\n  let r = use r in\n  let r = use r in\n  free r\n```\n\n---\n\n## Mode Syntax Summary\n\n| Location | Syntax | Example |\n|----------|--------|---------|\n| Parameter | `(x @ mode)` | `(x @ local unique)` |\n| Signature arrow | `t @ mode ->` | `t @ local -> t @ global` |\n| Expression | `(e : t @ mode)` | `(x : int @ local)` |\n| Let binding | `let mode_ x =` | `let local_ x = ...` |\n| Record field | `mode_ field :` | `global_ data : string` |\n| Record field | `: t @@ modality` | `: t @@ aliased` |\n\n---\n\n## Portability and Contention (Three-Way Axes)\n\nThe portability and contention axes now have three values each:\n\n### Portability Axis\n\n| Mode | Meaning |\n|------|---------|\n| `nonportable` | Functions capturing uncontended mutable state; cannot escape current thread |\n| `shareable` | Functions capturing shared state; may execute in parallel |\n| `portable` | Functions capturing all values at contended; may execute concurrently |\n\n### Contention Axis\n\n| Mode | Meaning |\n|------|---------|\n| `uncontended` | Single-thread access; full read/write |\n| `shared` | Multi-thread access; synchronized sharing |\n| `contended` | Multi-thread concurrent access |\n\n### Mode Implications\n\nCertain modalities imply others for soundness:\n\n- `@@ global` implies `@@ aliased` (for borrowing soundness)\n- `stateless` implies `portable`\n- `observing` implies `shareable`\n- `immutable` implies `contended`\n- `read` implies `shared`\n\nSee also: [SKILL-STACK-ALLOCATION.md](SKILL-STACK-ALLOCATION.md) for locality details,\n[SKILL-UNIQUENESS.md](SKILL-UNIQUENESS.md) for uniqueness patterns.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-SIMD.md": "# OxCaml SIMD: Detailed Guide\n\nOxCaml provides built-in SIMD vector types and intrinsics for high-performance\nparallel numeric operations on x86-64 (SSE/AVX).\n\n## Vector Types\n\n### 128-bit Vectors (SSE)\n\n| Type | Unboxed | Elements | Element Type |\n|------|---------|----------|--------------|\n| `int8x16` | `int8x16#` | 16 | 8-bit int |\n| `int16x8` | `int16x8#` | 8 | 16-bit int |\n| `int32x4` | `int32x4#` | 4 | 32-bit int |\n| `int64x2` | `int64x2#` | 2 | 64-bit int |\n| `float32x4` | `float32x4#` | 4 | 32-bit float |\n| `float64x2` | `float64x2#` | 2 | 64-bit float |\n\n### 256-bit Vectors (AVX)\n\n| Type | Unboxed | Elements | Element Type |\n|------|---------|----------|--------------|\n| `int8x32` | `int8x32#` | 32 | 8-bit int |\n| `int16x16` | `int16x16#` | 16 | 16-bit int |\n| `int32x8` | `int32x8#` | 8 | 32-bit int |\n| `int64x4` | `int64x4#` | 4 | 64-bit int |\n| `float32x8` | `float32x8#` | 8 | 32-bit float |\n| `float64x4` | `float64x4#` | 4 | 64-bit float |\n\n---\n\n## Boxed vs Unboxed Vectors\n\n### Unboxed (`#` suffix)\n\n- Passed in XMM/YMM registers\n- Stored flat in records\n- Can be in flat arrays\n- No heap allocation for the vector itself\n\n```ocaml\nlet process (v : float32x4#) : float32x4# =\n  Float32x4.sqrt v  (* All in registers *)\n```\n\n### Boxed (no suffix)\n\n- Heap-allocated when passed to non-inlined functions\n- May generate unaligned load/store\n- Easier to use in polymorphic code\n\n```ocaml\nlet store_vector (v : float32x4) : unit =\n  global_ref := v  (* Allocates *)\n```\n\n---\n\n## Library Setup\n\nAdd to your dune file:\n\n```lisp\n(libraries ocaml_simd ocaml_simd_sse ppx_simd)\n; Or for AVX:\n(libraries ocaml_simd ocaml_simd_avx ppx_simd)\n```\n\n---\n\n## Basic Operations\n\n### Creating Vectors\n\n```ocaml\nopen Ocaml_simd_sse\n\n(* Set individual elements (high to low order) *)\nlet v = Float32x4.set 4.0 3.0 2.0 1.0\n(* v = [1.0, 2.0, 3.0, 4.0] *)\n\n(* Broadcast single value to all lanes *)\nlet v = Float32x4.broadcast 5.0\n(* v = [5.0, 5.0, 5.0, 5.0] *)\n\n(* From tuple *)\nlet v = Float32x4.of_tuple (1.0, 2.0, 3.0, 4.0)\n```\n\n### Extracting Values\n\n```ocaml\n(* Extract to tuple *)\nlet (a, b, c, d) = Float32x4.to_tuple v\n\n(* Extract single element *)\nlet first = Float32x4.extract v 0\nlet last = Float32x4.extract v 3\n```\n\n### Arithmetic\n\n```ocaml\nlet a = Float32x4.set 1.0 2.0 3.0 4.0\nlet b = Float32x4.set 5.0 6.0 7.0 8.0\n\nlet sum = Float32x4.add a b       (* [6, 8, 10, 12] *)\nlet diff = Float32x4.sub a b      (* [-4, -4, -4, -4] *)\nlet prod = Float32x4.mul a b      (* [5, 12, 21, 32] *)\nlet quot = Float32x4.div a b      (* [0.2, 0.33, 0.43, 0.5] *)\n\n(* Math functions *)\nlet roots = Float32x4.sqrt a      (* [1, 1.41, 1.73, 2] *)\nlet recip = Float32x4.rcp a       (* Approximate reciprocal *)\nlet rsqrt = Float32x4.rsqrt a     (* Approximate 1/sqrt *)\n```\n\n### Comparisons\n\n```ocaml\n(* Returns mask vector *)\nlet mask = Float32x4.cmplt a b    (* a < b per element *)\nlet mask = Float32x4.cmpeq a b    (* a == b per element *)\nlet mask = Float32x4.cmpgt a b    (* a > b per element *)\n```\n\n### Min/Max\n\n```ocaml\nlet mins = Float32x4.min a b      (* Element-wise min *)\nlet maxs = Float32x4.max a b      (* Element-wise max *)\n```\n\n---\n\n## Load and Store\n\n### From Arrays\n\n```ocaml\nlet arr = [| 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0 |]\n\n(* Load 4 floats starting at index 0 *)\nlet v1 = Float32x4.Float_array.get arr ~idx:0\nlet v2 = Float32x4.Float_array.get arr ~idx:4\n\n(* Store back *)\nFloat32x4.Float_array.set arr ~idx:0 result\n```\n\n### From Strings/Bytes\n\n```ocaml\nlet bytes = Bytes.create 64\n\n(* Load 16 bytes as int8x16 *)\nlet v = Int8x16.Bytes.get bytes ~byte:0\n\n(* Store 16 bytes *)\nInt8x16.Bytes.set bytes ~byte:0 v\n```\n\n### From Bigstring\n\n```ocaml\nopen Bigstring\n\nlet buf = Bigstring.create 128\n\nlet v = Float64x2.Bigstring.get buf ~byte:0\nFloat64x2.Bigstring.set buf ~byte:16 result\n```\n\n---\n\n## Shuffles and Blends\n\n### Shuffle (ppx_simd required)\n\n```ocaml\nopen Ppx_simd\n\n(* Rearrange elements within vector *)\nlet v = Float32x4.set 4.0 3.0 2.0 1.0  (* [1, 2, 3, 4] *)\n\n(* Shuffle: indices 0-3 select from source *)\nlet shuffled = Float32x4.shuffle [%shuffle 3, 2, 1, 0] v v\n(* Result: [4, 3, 2, 1] - reversed *)\n\nlet broadcast_first = Float32x4.shuffle [%shuffle 0, 0, 0, 0] v v\n(* Result: [1, 1, 1, 1] *)\n```\n\n### Blend (ppx_simd required)\n\n```ocaml\n(* Select elements from two vectors based on mask *)\nlet a = Float32x4.set 4.0 3.0 2.0 1.0  (* [1, 2, 3, 4] *)\nlet b = Float32x4.set 8.0 7.0 6.0 5.0  (* [5, 6, 7, 8] *)\n\n(* Mask: 0 = from a, 1 = from b *)\nlet blended = Float32x4.blend [%blend 0, 1, 0, 1] a b\n(* Result: [1, 6, 3, 8] *)\n```\n\n---\n\n## Integer Operations\n\n```ocaml\nopen Ocaml_simd_sse\n\nlet a = Int32x4.set 4l 3l 2l 1l\nlet b = Int32x4.set 8l 7l 6l 5l\n\n(* Arithmetic *)\nlet sum = Int32x4.add a b\nlet diff = Int32x4.sub a b\n\n(* Bitwise *)\nlet anded = Int32x4.and_ a b\nlet ored = Int32x4.or_ a b\nlet xored = Int32x4.xor a b\n\n(* Shifts *)\nlet left = Int32x4.slli a 2    (* Shift left by 2 bits *)\nlet right = Int32x4.srli a 1   (* Logical shift right *)\nlet arith = Int32x4.srai a 1   (* Arithmetic shift right *)\n```\n\n---\n\n## Horizontal Operations\n\n```ocaml\n(* Sum all elements *)\nlet v = Float32x4.set 4.0 3.0 2.0 1.0\nlet sum = Float32x4.hadd v v  (* Horizontal add pairs *)\nlet sum = Float32x4.hadd sum sum  (* Complete sum in element 0 *)\n\n(* For complete horizontal sum, often need multiple steps *)\n```\n\n---\n\n## AVX Operations\n\n```ocaml\nopen Ocaml_simd_avx\n\n(* 256-bit vectors - double the width *)\nlet v = Float64x4.set 4.0 3.0 2.0 1.0\nlet w = Float64x4.set 8.0 7.0 6.0 5.0\n\nlet sum = Float64x4.add v w  (* 4 doubles in parallel *)\n\n(* Can also use 256-bit integer vectors *)\nlet i = Int32x8.set 8l 7l 6l 5l 4l 3l 2l 1l\n```\n\n---\n\n## SIMD Load/Store Intrinsics (NEW in 5.2.0minus-25)\n\nDirect memory operations with proper alignment handling:\n\n```ocaml\n(* Aligned load/store - requires 16/32-byte alignment *)\nexternal vec128_load_aligned : bytes -> int -> int8x16#\nexternal vec128_store_aligned : bytes -> int -> int8x16# -> unit\n\n(* Unaligned load/store - works with any alignment *)\nexternal vec128_load_unaligned : bytes -> int -> int8x16#\nexternal vec128_store_unaligned : bytes -> int -> int8x16# -> unit\n\n(* Non-temporal stores - bypass cache, good for streaming writes *)\nexternal vec128_store_aligned_uncached : bytes -> int -> int8x16# -> unit\n\n(* Partial loads *)\nexternal vec128_load_low64 : bytes -> int -> int64x2#  (* Load 64 bits to low lane *)\nexternal vec128_load_low32 : bytes -> int -> int32x4#  (* Load 32 bits to low lane *)\n```\n\n---\n\n## AVX2 Gather Intrinsics (NEW in 5.2.0minus-25)\n\nGather operations load multiple values from non-contiguous memory addresses:\n\n```ocaml\n(* Gather 32-bit integers using int32 indices *)\n(* Base address + indices * scale, masked by mask *)\nexternal gather_int32x4 :\n  base:nativeint -> indices:int32x4# -> scale:int -> mask:int32x4# -> int32x4#\n\n(* Gather 64-bit integers *)\nexternal gather_int64x2 :\n  base:nativeint -> indices:int64x2# -> scale:int -> mask:int64x2# -> int64x2#\n\n(* Gather floats *)\nexternal gather_float32x4 :\n  base:nativeint -> indices:int32x4# -> scale:int -> mask:float32x4# -> float32x4#\n\nexternal gather_float64x2 :\n  base:nativeint -> indices:int64x2# -> scale:int -> mask:float64x2# -> float64x2#\n\n(* Scale must be 1, 2, 4, or 8 *)\n```\n\n---\n\n## BMI/BMI2 Intrinsics (NEW in 5.2.0minus-25)\n\nBit manipulation instructions for efficient bit operations:\n\n### BMI (Bit Manipulation Instruction Set 1)\n\n```ocaml\n(* ANDN: Bitwise AND of inverted first operand with second *)\nexternal bmi_andn_int32 : int32# -> int32# -> int32#\nexternal bmi_andn_int64 : int64# -> int64# -> int64#\n\n(* BEXTR: Bit field extract *)\nexternal bmi_bextr_int32 : int32# -> int32# -> int32#\nexternal bmi_bextr_int64 : int64# -> int64# -> int64#\n\n(* BLSI: Extract lowest set bit *)\nexternal bmi_blsi_int32 : int32# -> int32#\nexternal bmi_blsi_int64 : int64# -> int64#\n\n(* BLSMSK: Get mask up to lowest set bit *)\nexternal bmi_blsmsk_int32 : int32# -> int32#\nexternal bmi_blsmsk_int64 : int64# -> int64#\n\n(* BLSR: Reset lowest set bit *)\nexternal bmi_blsr_int32 : int32# -> int32#\nexternal bmi_blsr_int64 : int64# -> int64#\n\n(* TZCNT: Count trailing zero bits *)\nexternal bmi_tzcnt_int32 : int32# -> int32#\nexternal bmi_tzcnt_int64 : int64# -> int64#\n```\n\n### BMI2 (Bit Manipulation Instruction Set 2)\n\n```ocaml\n(* BZHI: Zero high bits starting at specified position *)\nexternal bmi2_bzhi_int32 : int32# -> int32# -> int32#\nexternal bmi2_bzhi_int64 : int64# -> int64# -> int64#\n\n(* MULX: Unsigned multiply without affecting flags *)\nexternal bmi2_mulx_int32 : int32# -> int32# -> #(int32# * int32#)\nexternal bmi2_mulx_int64 : int64# -> int64# -> #(int64# * int64#)\n\n(* PDEP: Parallel bits deposit *)\nexternal bmi2_pdep_int32 : int32# -> int32# -> int32#\nexternal bmi2_pdep_int64 : int64# -> int64# -> int64#\n\n(* PEXT: Parallel bits extract *)\nexternal bmi2_pext_int32 : int32# -> int32# -> int32#\nexternal bmi2_pext_int64 : int64# -> int64# -> int64#\n\n(* RORX: Rotate right without affecting flags *)\nexternal bmi2_rorx_int32 : int32# -> int -> int32#\nexternal bmi2_rorx_int64 : int64# -> int -> int64#\n\n(* SARX/SHRX/SHLX: Shift without affecting flags *)\nexternal bmi2_sarx_int32 : int32# -> int32# -> int32#\nexternal bmi2_shrx_int64 : int64# -> int64# -> int64#\nexternal bmi2_shlx_int32 : int32# -> int32# -> int32#\n```\n\n### POPCNT/LZCNT\n\n```ocaml\n(* Population count: count set bits *)\nexternal popcnt_int32 : int32# -> int32#\nexternal popcnt_int64 : int64# -> int64#\n\n(* Leading zero count *)\nexternal lzcnt_int32 : int32# -> int32#\nexternal lzcnt_int64 : int64# -> int64#\n```\n\n---\n\n## 128-bit Integer Arithmetic (NEW in 5.2.0minus-25)\n\nSupport for wide integer operations using SIMD registers:\n\n```ocaml\n(* 128-bit add/subtract carried through register pairs *)\nexternal int128_add : int64# -> int64# -> int64# -> int64# -> #(int64# * int64#)\nexternal int128_sub : int64# -> int64# -> int64# -> int64# -> #(int64# * int64#)\n```\n\n---\n\n## C FFI\n\n### External Declarations\n\n```ocaml\n(* Unboxed external - no allocation overhead *)\nexternal simd_process : (float32x4#[@unboxed]) -> (float32x4#[@unboxed]) =\n  \"boxed_simd_process\" \"unboxed_simd_process\"\n\n(* For 256-bit *)\nexternal avx_process : (float64x4#[@unboxed]) -> (float64x4#[@unboxed]) =\n  \"boxed_avx_process\" \"unboxed_avx_process\"\n```\n\n### C Implementation\n\n```c\n#include <caml/simd.h>\n#include <immintrin.h>\n\n// Unboxed version - efficient\n__m128 unboxed_simd_process(__m128 v) {\n  return _mm_sqrt_ps(v);\n}\n\n// Boxed wrapper\nCAMLprim value boxed_simd_process(value v) {\n  return caml_copy_vec128(unboxed_simd_process(Vec128_val(v)));\n}\n\n// For 256-bit\n__m256d unboxed_avx_process(__m256d v) {\n  return _mm256_sqrt_pd(v);\n}\n\nCAMLprim value boxed_avx_process(value v) {\n  return caml_copy_vec256d(unboxed_avx_process(Vec256_vald(v)));\n}\n```\n\n---\n\n## Common Patterns\n\n### Vector Dot Product\n\n```ocaml\nlet dot4 (a : float32x4#) (b : float32x4#) : float =\n  let prod = Float32x4.mul a b in\n  let sum1 = Float32x4.hadd prod prod in\n  let sum2 = Float32x4.hadd sum1 sum1 in\n  Float32x4.extract sum2 0\n```\n\n### Process Array in Chunks\n\n```ocaml\nlet process_array (arr : float array) : unit =\n  let len = Array.length arr in\n  let vec_len = len / 4 * 4 in\n\n  (* Process 4 elements at a time *)\n  for i = 0 to vec_len / 4 - 1 do\n    let v = Float32x4.Float_array.get arr ~idx:(i * 4) in\n    let result = Float32x4.sqrt v in\n    Float32x4.Float_array.set arr ~idx:(i * 4) result\n  done;\n\n  (* Handle remainder *)\n  for i = vec_len to len - 1 do\n    arr.(i) <- Float.sqrt arr.(i)\n  done\n```\n\n### SIMD-friendly Record\n\n```ocaml\ntype vec4 = {\n  data : float32x4#;\n}\n\nlet add_vec4 a b = {\n  data = Float32x4.add a.data b.data\n}\n```\n\n---\n\n## Performance Tips\n\n1. **Use unboxed vectors** (`#` suffix) in hot loops\n2. **Align data** for better load/store performance\n3. **Avoid horizontal operations** when possible (they're slower)\n4. **Process in chunks** matching vector width\n5. **Use `[@inline always]`** on small SIMD functions\n6. **Prefer AVX2** for 256-bit operations when available\n\n---\n\n## Limitations\n\n- x86-64 only (ARM NEON coming soon)\n- Requires SSE2 minimum, AVX/AVX2 for 256-bit\n- BMI/BMI2 require specific CPU support (Haswell+)\n- No auto-vectorization (explicit SIMD required)\n- Alignment not automatically guaranteed\n\n---\n\n## Checking CPU Features\n\n```ocaml\n(* Runtime check for AVX support *)\nexternal has_avx : unit -> bool = \"caml_has_avx\" [@@noalloc]\n\nlet use_best_implementation () =\n  if has_avx () then\n    process_avx data\n  else\n    process_sse data\n```\n\nSee also: [SKILL-UNBOXED.md](SKILL-UNBOXED.md) for unboxed types,\n[SKILL-ZERO-ALLOC.md](SKILL-ZERO-ALLOC.md) for allocation-free SIMD code.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-STACK-ALLOCATION.md": "# OxCaml Stack Allocation: Detailed Guide\n\nStack allocation allows values to be allocated on the stack instead of the heap,\navoiding GC overhead. The tradeoff is that stack-allocated values cannot escape\ntheir defining scope.\n\n## Core Concepts\n\n### Local vs Global\n\n- **Global** values live on the heap and can be stored anywhere, returned from\n  functions, and live indefinitely\n- **Local** values live on the stack and must not escape their defining scope\n\n### The Stack Region Model\n\nEach function call has a stack region. Local values are allocated in that region\nand deallocated when the function returns.\n\n```\n┌─────────────────────────┐\n│ Caller's stack frame    │\n│ ┌─────────────────────┐ │\n│ │ exclave_ allocations│ │  ← Allocated here with exclave_\n│ └─────────────────────┘ │\n├─────────────────────────┤\n│ Callee's stack frame    │\n│ ┌─────────────────────┐ │\n│ │ local_ allocations  │ │  ← Allocated here with local_/stack_\n│ └─────────────────────┘ │\n└─────────────────────────┘\n```\n\n---\n\n## Syntax\n\n### Creating Local Values\n\n```ocaml\n(* Implicit: allocate on stack *)\nlet local_ x = (1, 2, 3)\n\n(* Explicit: force stack allocation *)\nlet y = stack_ (1, 2, 3)\n\n(* With type annotation *)\nlet local_ (z : int * int) = (1, 2)\n```\n\n### Local Parameters\n\n```ocaml\n(* Accept local argument *)\nlet process (data @ local) =\n  (* data is stack-allocated, cannot be stored globally *)\n  Array.fold_left (+) 0 data\n\n(* Can also accept global (subtyping) *)\nlet _ = process heap_array  (* OK *)\n```\n\n### Returning Local Values\n\n```ocaml\n(* exclave_ allocates in CALLER's frame and returns *)\nlet make_pair x y = exclave_\n  stack_ (x, y)\n\n(* Caller receives a local value *)\nlet use () =\n  let local_ p = make_pair 1 2 in\n  fst p + snd p\n```\n\n---\n\n## The `exclave_` Construct\n\n`exclave_` is the key to returning stack-allocated values. It:\n1. Allocates the result in the caller's stack frame\n2. Returns that allocation to the caller\n3. Must be at tail position\n\n### Valid exclave_ Patterns\n\n```ocaml\n(* Direct allocation *)\nlet f x = exclave_ stack_ (x, x)\n\n(* Calling another exclave function *)\nlet g x = exclave_ make_pair x x\n\n(* Conditional - both branches must be exclave-compatible *)\nlet h x = exclave_\n  if x > 0 then stack_ (x, 1)\n  else stack_ (0, 0)\n\n(* Match - all branches must be exclave-compatible *)\nlet i x = exclave_\n  match x with\n  | Some v -> stack_ (v, v)\n  | None -> stack_ (0, 0)\n```\n\n### Invalid exclave_ Patterns\n\n```ocaml\n(* ERROR: exclave_ not at tail position *)\nlet bad x =\n  let y = exclave_ stack_ (x, x) in  (* Not tail! *)\n  fst y\n\n(* ERROR: local value escaping *)\nlet bad2 x = exclave_\n  let local_ temp = stack_ (x, x) in\n  temp  (* temp is from inner scope, not caller's *)\n```\n\n---\n\n## Local References\n\nReferences can be stack-allocated for mutable accumulators:\n\n```ocaml\nlet sum_array arr =\n  let local_ total = ref 0 in\n  for i = 0 to Array.length arr - 1 do\n    total := !total + arr.(i)\n  done;\n  !total  (* Return the int, not the ref *)\n```\n\n### Building Local Lists\n\n```ocaml\nlet collect_positives arr =\n  let local_ acc = ref [] in\n  for i = 0 to Array.length arr - 1 do\n    if arr.(i) > 0 then\n      acc := stack_ (arr.(i) :: !acc)\n  done;\n  (* Process locally, return global result *)\n  List.fold_left (+) 0 !acc\n```\n\n---\n\n## Local Data Structures\n\n### Local Lists\n\n```ocaml\n(* Build list on stack *)\nlet make_list n = exclave_\n  let rec go acc i =\n    if i = 0 then acc\n    else go (stack_ (i :: acc)) (i - 1)\n  in\n  go [] n\n\n(* Process local list *)\nlet sum_local (lst @ local) =\n  let rec go acc = function\n    | [] -> acc\n    | x :: xs -> go (acc + x) xs\n  in\n  go 0 lst\n```\n\n### Local Arrays\n\n```ocaml\n(* Stack-allocated array *)\nlet with_temp_array n f =\n  let local_ arr = Array.make n 0 in\n  f arr\n  (* arr deallocated when function returns *)\n```\n\n### Local Records\n\n```ocaml\ntype point = { x : float; y : float }\n\nlet make_point x y = exclave_\n  stack_ { x; y }\n\nlet distance (p1 @ local) (p2 @ local) =\n  let dx = p1.x -. p2.x in\n  let dy = p1.y -. p2.y in\n  Float.sqrt (dx *. dx +. dy *. dy)\n```\n\n---\n\n## Common Patterns\n\n### Process Locally, Return Globally\n\n```ocaml\nlet find_max arr =\n  if Array.length arr = 0 then None\n  else begin\n    let local_ best = ref (0, arr.(0)) in\n    for i = 1 to Array.length arr - 1 do\n      if arr.(i) > snd !best then\n        best := stack_ (i, arr.(i))\n    done;\n    (* Return global result *)\n    Some (fst !best)\n  end\n```\n\n### Temporary Pairs for Multiple Returns\n\n```ocaml\nlet divmod a b = exclave_\n  stack_ (a / b, a mod b)\n\nlet use () =\n  let local_ result = divmod 17 5 in\n  Printf.printf \"%d r %d\\n\" (fst result) (snd result)\n```\n\n### Local Closures\n\nClosures capturing local data are themselves local:\n\n```ocaml\nlet with_counter f =\n  let local_ count = ref 0 in\n  let local_ incr () = count := !count + 1 in\n  f incr;\n  !count\n\nlet result = with_counter (fun incr ->\n  incr (); incr (); incr ()\n)  (* result = 3 *)\n```\n\n---\n\n## Pitfalls and Solutions\n\n### Pitfall: Storing Local in Global Structure\n\n```ocaml\n(* ERROR: Cannot store local in global list *)\nlet bad () =\n  let global_list = ref [] in\n  let local_ x = (1, 2) in\n  global_list := x :: !global_list  (* Error! *)\n```\n\n**Solution**: Copy to heap or restructure:\n\n```ocaml\nlet good () =\n  let global_list = ref [] in\n  let x = (1, 2) in  (* Allocate globally *)\n  global_list := x :: !global_list\n```\n\n### Pitfall: Returning Local from Non-Tail Position\n\n```ocaml\n(* ERROR: exclave_ not at tail *)\nlet bad x =\n  let result = exclave_ stack_ (x, x) in\n  fst result\n```\n\n**Solution**: Restructure to put exclave_ at tail:\n\n```ocaml\nlet good x = exclave_\n  stack_ (x, x)\n\nlet use x =\n  let local_ p = good x in\n  fst p\n```\n\n### Pitfall: Local Escaping via Closure\n\n```ocaml\n(* ERROR: Closure captures local *)\nlet bad () =\n  let local_ x = ref 0 in\n  let f () = !x in  (* f captures x *)\n  f  (* Cannot return f - it contains local ref *)\n```\n\n**Solution**: Use `let mutable` or ensure closure is also local:\n\n```ocaml\nlet good () =\n  let mutable x = 0 in\n  (* mutable variables don't create closures *)\n  for i = 1 to 10 do x <- x + i done;\n  x\n```\n\n### Pitfall: Wrong Stack Frame\n\n```ocaml\n(* SUBTLE BUG: stack_ inside exclave_ allocates wrong frame *)\nlet confusing x = exclave_\n  let local_ temp = stack_ (x, x) in  (* temp in callee frame! *)\n  temp  (* Returns pointer to deallocated memory! *)\n```\n\n**Solution**: Use stack_ directly with exclave_:\n\n```ocaml\nlet correct x = exclave_\n  stack_ (x, x)  (* Allocated in caller's frame *)\n```\n\n---\n\n## Performance Considerations\n\n### When to Use Stack Allocation\n\n- Short-lived intermediate values\n- Accumulators in loops\n- Temporary pairs/tuples for multiple returns\n- Processing pipelines where data flows through\n\n### When NOT to Use Stack Allocation\n\n- Values that need to be stored in long-lived data structures\n- Values returned from deeply nested call chains\n- Very large allocations (limited stack space)\n- Values shared across threads\n\n### Stack Size Limits\n\nStack space is limited (typically 8MB on Linux). Avoid:\n\n```ocaml\n(* BAD: Very large stack allocation *)\nlet bad () =\n  let local_ huge = Array.make 1_000_000 0 in\n  ...\n```\n\n---\n\n## Integration with Other Features\n\n### With Unboxed Types\n\n```ocaml\n(* Unboxed types in local records - very efficient *)\ntype local_point = { x : float#; y : float# }\n\nlet make_point x y = exclave_\n  stack_ { x = #x; y = #y }\n```\n\n### With Zero-Alloc\n\n```ocaml\n(* Stack allocation satisfies zero_alloc *)\nlet[@zero_alloc] process x y =\n  let local_ p = stack_ (x, y) in\n  fst p + snd p\n```\n\n### With Comprehensions\n\n```ocaml\n(* List comprehensions can be local *)\nlet local_squares n = exclave_\n  [ x * x for x = 1 to n ]  (* Local list *)\n```\n\nSee also: [SKILL-MODES.md](SKILL-MODES.md) for the full mode system,\n[SKILL-UNBOXED.md](SKILL-UNBOXED.md) for unboxed types.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-TEMPLATES.md": "# OxCaml Templates (ppx_template): Detailed Guide\n\n`ppx_template` generates multiple copies of code with different modes, kinds, or\nmodalities. It's a workaround until OxCaml has native polymorphism over these\naxes.\n\n## Basic Concept\n\nInstead of runtime polymorphism, templates create compile-time copies:\n\n```ocaml\n(* Single source *)\nlet%template[@mode m = (global, local)] id x = x\n\n(* Generates two functions *)\nlet id x = x              (* global version *)\nlet id__local x = x       (* local version *)\n```\n\n---\n\n## Extension Points\n\n### On Definitions\n\n```ocaml\n(* On let *)\nlet%template ...\n\n(* On val *)\nval%template ...\n\n(* On type *)\ntype%template ...\n\n(* On module *)\nmodule%template ...\n```\n\n### Block Form\n\n```ocaml\n(* Structure items *)\n[%%template\n  let f x = x\n  let g x = x + 1\n]\n\n(* Signature items - note colon *)\n[%%template:\n  val f : 'a -> 'a\n  val g : int -> int\n]\n```\n\n### Expression Form\n\n```ocaml\nlet x = [%template fun x -> x]\n```\n\n---\n\n## Mode Templates\n\n### Defining Mode-Polymorphic Functions\n\n```ocaml\nlet%template[@mode m = (global, local)] identity\n  : 'a @ m -> 'a @ m\n  = fun x -> x\n\n(* Generates:\n   val identity : 'a -> 'a\n   val identity__local : 'a @ local -> 'a @ local\n*)\n```\n\n### Instantiating\n\n```ocaml\n(* Inside %template context *)\nlet f x = (identity [@mode local]) x\n\n(* Or using mangled name directly (not recommended) *)\nlet f x = identity__local x\n```\n\n### Multiple Mode Variables\n\n```ocaml\nlet%template[@mode m1 = (global, local), m2 = (portable, nonportable)]\n  process (x @ m1) (y @ m2) = ...\n\n(* Generates 2 × 2 = 4 versions *)\n```\n\n### The exclave_if_local Attribute\n\nConditionally add `exclave_` for local returns:\n\n```ocaml\nlet%template[@mode m = (global, local)] make_pair x y =\n  (x, y) [@exclave_if_local m]\n\n(* global version: just returns (x, y) *)\n(* local version: exclave_ (x, y) *)\n```\n\n**Restrictions**: Only valid on:\n- Pure syntactic allocations (tuples, records, arrays)\n- Tailcalls with only identifiers\n\n---\n\n## Kind Templates\n\n### Defining Kind-Polymorphic Functions\n\n```ocaml\nlet%template[@kind k = (value, float64, bits32, bits64)]\n  id (type a : k) (x : a) : a = x\n\n(* Generates:\n   val id : 'a -> 'a\n   val id__float64 : ('a : float64). 'a -> 'a\n   val id__bits32 : ('a : bits32). 'a -> 'a\n   val id__bits64 : ('a : bits64). 'a -> 'a\n*)\n```\n\n### Kind Products\n\n```ocaml\nlet%template[@kind k = (value, value & value, (value & value) & value)]\n  wrap (type a : k) (x : a) = { contents = x }\n```\n\n### Kind with Mode Modifier\n\n```ocaml\nlet%template[@kind k = (value, value mod portable)]\n  f (type a : k) (x : a) = x\n```\n\n---\n\n## Alloc Templates\n\nFor ad-hoc polymorphism over allocation behavior (heap vs stack):\n\n```ocaml\nlet%template[@alloc a @ m = (heap_global, stack_local)]\n  make_pair x y =\n    (x, y) [@exclave_if_stack a]\n\n(* heap_global version: (x, y) *)\n(* stack_local version: exclave_ stack_ (x, y) *)\n```\n\n### Alloc Variable Alone\n\n```ocaml\nlet%template[@alloc a = (heap, stack)]\n  f x = x [@exclave_if_stack a]\n```\n\n### With zero_alloc_if_stack\n\n```ocaml\nlet%template[@alloc a = (heap, stack)]\n  process x = compute x\n[@@zero_alloc_if_stack a]\n\n(* stack version gets [@zero_alloc] attribute *)\n```\n\n---\n\n## Modality Templates\n\nFor portable/nonportable functor patterns:\n\n```ocaml\nmodule%template[@modality p = (nonportable, portable)]\n  Make (M : sig @@ p include S end) : sig @@ p include T end\n  = struct ... end\n```\n\n### Shorthand: %template.portable\n\n```ocaml\n(* Long form *)\nmodule%template[@modality p = (nonportable, portable)]\n  F (M : sig @@ p include S end) : sig @@ p include T end = ...\n\n(* Short form *)\nmodule%template.portable F (M : S) : T = ...\n```\n\n---\n\n## Floating Attributes\n\nApply to all subsequent items in scope:\n\n```ocaml\n[%%template:\n[@@@mode.default m = (global, local)]\n\nval min : t @ m -> t @ m -> t @ m\nval max : t @ m -> t @ m -> t @ m\nval clamp : t @ m -> low:t @ m -> high:t @ m -> t @ m\n]\n\n(* All three functions get both global and local versions *)\n```\n\n### Available Floating Attributes\n\n- `[@@@mode.default ...]`\n- `[@@@kind.default ...]`\n- `[@@@modality.default ...]`\n- `[@@@alloc.default ...]`\n\nWithout `.default`, names aren't mangled:\n\n```ocaml\n[@@@mode m = (global, local)]  (* No mangling *)\n[@@@mode.default m = (global, local)]  (* With mangling *)\n```\n\n---\n\n## Name Mangling\n\n**WARNING: Mangling scheme may change. Don't rely on specific names.**\n\n### General Pattern\n\n```\nbase_name[__kind_suffix][__mode_suffix][__modality_suffix][__alloc_suffix]\n```\n\n### Defaults (No Suffix)\n\n| Axis | Default (no suffix) |\n|------|---------------------|\n| Kind | `value` |\n| Mode | `global`, `nonportable`, `uncontended`, `aliased` |\n| Modality | `local`, `nonportable`, `uncontended`, `unique` |\n| Alloc | `heap` |\n\n### Examples\n\n```ocaml\nid                      (* default everything *)\nid__local               (* mode local *)\nid__float64             (* kind float64 *)\nid__float64__local      (* kind float64, mode local *)\nid__portable            (* modality portable *)\nid__'value_value'       (* kind value & value - product *)\nid__'value_mod_portable' (* kind value mod portable *)\n```\n\n---\n\n## Punning\n\nShorthand when you just want mangling without new binding:\n\n```ocaml\n(* Long form *)\nlet f x = x [@@kind k = k]\n\n(* Punned form *)\nlet f x = x [@@kind k]\n\n(* For monomorphic instances *)\nlet%template f x = x [@@kind float64]  (* Just mangles to f__float64 *)\n```\n\n---\n\n## Common Patterns\n\n### Layout-Polymorphic Float Module\n\n```ocaml\nopen [%template\n  module [@kind value] Float = Float\n  module [@kind float64] Float = Float_u\n]\n\nmodule%template[@kind k = (value, float64)] Float : sig\n  type t : k\n  val add : t -> t -> t\n  val mul : t -> t -> t\nend = Float [@kind k]\n```\n\n### Include with Mangling\n\n```ocaml\ninclude%template[@kind k = (value, float64)] struct\n  open Float [@kind k]\n\n  let[@kind k] double x = add x x\n  let[@kind k] square x = mul x x\nend\n```\n\n### Functor over Kinds\n\n```ocaml\nmodule%template[@kind k = (value, float64)] Make = struct\n  open Float [@kind k]\n\n  let[@kind k] process = ...\nend\n\ninclude%template Make [@kind value]\ninclude%template Make [@kind float64]\n```\n\n---\n\n## Type and Module Substitutions\n\nType substitutions work but have scoping limitations:\n\n```ocaml\n(* Works *)\nmodule type%template A = sig\n  [@@@kind.default k = (bits64, float64)]\n\n  type ('a : k) t := 'a\n  type nonrec 'a t = 'a t [@kind k]\nend\n\n(* May not work - substitution crosses [%%template] boundary *)\nmodule type B = sig\n  [%%template:\n  [@@@kind.default k = (bits64, float64)]\n  type ('a : k) t := 'a]\n\n  (* t__bits64 not visible here! *)\nend\n```\n\n---\n\n## Type Variables vs Locally Abstract Types\n\nUse locally abstract types for kind polymorphism:\n\n```ocaml\n(* ERROR: type variables unify across same block *)\nlet%template f (x : ('a : k)) : 'a = x\n[@@kind k = (value, float64)]\n\n(* CORRECT: locally abstract types are independent *)\nlet%template f (type a : k) (x : a) : a = x\n[@@kind k = (value, float64)]\n```\n\n---\n\n## Debugging\n\n### See Expanded Code\n\nUse `dune describe pp` or similar to see what templates expand to.\n\n### Check Mangled Names\n\n```ocaml\n(* If unsure of mangling, test with explicit instantiation *)\nlet test = (some_function [@kind float64] [@mode local])\n(* If it compiles, mangling is correct *)\n```\n\n---\n\n## Performance Notes\n\n- Templates are expanded at compile time - no runtime overhead\n- Each instance is fully optimized independently\n- Code size increases with number of instances\n- Unused instances may still be generated (no SFINAE)\n\n---\n\n## Limitations\n\n- No SFINAE - all instances generated eagerly\n- No dependent types - can't compute kinds from values\n- Mangling scheme unstable\n- Right-nested kind products not supported: `value & (value & value)`\n\nSee also: [SKILL-MODES.md](SKILL-MODES.md) for mode details,\n[SKILL-KINDS.md](SKILL-KINDS.md) for kind details.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-UNBOXED.md": "# OxCaml Unboxed Types: Detailed Guide\n\nUnboxed types store values directly without heap allocation or pointer\nindirection. They provide C-like performance for numeric code while maintaining\nOCaml's type safety.\n\n## Built-in Unboxed Types\n\n### Numeric Types\n\n| Boxed | Unboxed | Kind | Size | Literal |\n|-------|---------|------|------|---------|\n| `float` | `float#` | `float64` | 64-bit | `#3.14` |\n| `int32` | `int32#` | `bits32` | 32-bit | `#42l` |\n| `int64` | `int64#` | `bits64` | 64-bit | `#100L` |\n| `nativeint` | `nativeint#` | `word` | native | `#50n` |\n| `float32` | `float32#` | `float32` | 32-bit | `#1.0s` |\n| `int8` | `int8#` | - | 8-bit | `#42s` |\n| `int16` | `int16#` | - | 16-bit | `#42S` |\n| `int` | `int#` | - | native | `#42` (untagged) |\n| - | `char#` | - | 8-bit | `#'a'` |\n\n### Creating Unboxed Values\n\n```ocaml\n(* Literals use # prefix *)\nlet x : float# = #3.14159\nlet y : int32# = #42l\nlet z : int64# = #1_000_000L\nlet w : float32# = #2.5s\nlet c : char# = #'x'\n\n(* From boxed values *)\nlet a : float# = Float_u.of_float 3.14\nlet b : int32# = Int32_u.of_int32 42l\n```\n\n---\n\n## Unboxed Records\n\nRecords with all unboxed fields are stored flat without indirection:\n\n```ocaml\n(* Unboxed record syntax: #{ } *)\ntype vec3 = #{ x : float#; y : float#; z : float# }\n\n(* Create *)\nlet v : vec3 = #{ x = #1.0; y = #2.0; z = #3.0 }\n\n(* Access uses .# *)\nlet get_x (v : vec3) : float# = v.#x\n\n(* Pattern matching *)\nlet magnitude #{ x; y; z } =\n  Float_u.sqrt (\n    Float_u.add (Float_u.mul x x)\n      (Float_u.add (Float_u.mul y y) (Float_u.mul z z))\n  )\n```\n\n### Unboxed Record Characteristics\n\n- No heap allocation for the record itself\n- Passed by value (copied) to functions\n- Cannot be recursive (no self-references)\n- All fields must have known layout\n\n---\n\n## Unboxed Tuples\n\n```ocaml\n(* Unboxed tuple syntax: #( ) *)\ntype pair = #(float# * int32#)\n\nlet p : #(float# * int32#) = #(#1.0, #42l)\n\n(* Destructure *)\nlet #(f, i) = p\n\n(* In function signatures *)\nlet process : #(float# * float#) -> float# = fun #(a, b) ->\n  Float_u.add a b\n```\n\n---\n\n## Mixed Blocks\n\nRecords can mix boxed and unboxed fields:\n\n```ocaml\ntype particle = {\n  name : string;        (* boxed, on heap *)\n  mass : float#;        (* unboxed, inline *)\n  velocity : float#;    (* unboxed, inline *)\n  charge : int32#;      (* unboxed, inline *)\n}\n\nlet electron = {\n  name = \"electron\";\n  mass = #9.109e-31;\n  velocity = #0.0;\n  charge = #(-1l);\n}\n```\n\n### Memory Layout\n\n```\n┌─────────────────────────────────┐\n│ Header                          │\n├─────────────────────────────────┤\n│ name (pointer to string)        │  ← Boxed field\n├─────────────────────────────────┤\n│ mass (float64, 8 bytes)         │  ← Unboxed, inline\n├─────────────────────────────────┤\n│ velocity (float64, 8 bytes)     │  ← Unboxed, inline\n├─────────────────────────────────┤\n│ charge (int32, 4 bytes + pad)   │  ← Unboxed, inline\n└─────────────────────────────────┘\n```\n\n---\n\n## The `or_null` Type\n\nA non-allocating option for nullable unboxed values:\n\n```ocaml\ntype 'a or_null = Null | This of 'a\n\n(* Use with unboxed types - no allocation! *)\nlet find_float (arr : float# array) idx : float# or_null =\n  if idx >= 0 && idx < Array.length arr then\n    This arr.(idx)\n  else\n    Null\n\n(* Pattern match *)\nlet get_or_default result default =\n  match result with\n  | Null -> default\n  | This x -> x\n```\n\n### or_null vs option\n\n```ocaml\n(* option allocates Some constructor *)\nlet f () : float# option = Some #3.14  (* Allocates! *)\n\n(* or_null doesn't allocate *)\nlet g () : float# or_null = This #3.14  (* No allocation *)\n```\n\n---\n\n## Unboxed and Untagged Arrays\n\nArrays of unboxed and untagged types are packed for memory efficiency:\n\n```ocaml\n(* Unboxed float array - tightly packed *)\nlet floats : float# array = [| #1.0; #2.0; #3.0 |]\n\n(* Access *)\nlet first = floats.(0)  (* Returns float# *)\n\n(* Unboxed int32/int64 arrays *)\nlet ints32 : int32# array = [| #1l; #2l; #3l |]\nlet ints64 : int64# array = [| #1L; #2L; #3L |]\n\n(* Untagged small int arrays (NEW in 5.2.0minus-25) *)\nlet bytes : int8# array = [| #0s; #1s; #255s |]\nlet shorts : int16# array = [| #0S; #1S; #32767S |]\nlet ints : int# array = [| #0; #1; #42 |]\nlet chars : char# array = [| #'a'; #'b'; #'c' |]\n```\n\n### Array Memory Layout\n\n| Array Type | Bytes per Element | Notes |\n|------------|-------------------|-------|\n| `float# array` | 8 | Custom block, packed |\n| `float32# array` | 4 | Custom block, packed |\n| `int64# array` | 8 | Custom block, packed |\n| `int32# array` | 4 | Custom block, packed |\n| `int# array` | native word | Untagged, packed |\n| `int16# array` | 2 | Untagged, packed |\n| `int8# array` | 1 | Untagged, packed |\n| `char# array` | 1 | Same as int8# array |\n\nThe untagged int arrays use special block tags to encode the exact length\nwhen the element count doesn't fill a whole word.\n\n---\n\n## Operations on Unboxed Types\n\n### Float Operations (Float_u module)\n\n```ocaml\nopen Stdlib_stable.Float_u\n\nlet compute x y =\n  let sum = add x y in\n  let product = mul x y in\n  let root = sqrt sum in\n  div root product\n```\n\n### Int32 Operations (Int32_u module)\n\n```ocaml\nopen Stdlib_stable.Int32_u\n\nlet hash x y =\n  let a = mul x #31l in\n  add a y\n```\n\n### Conversion Functions\n\n```ocaml\n(* To/from boxed *)\nlet box (x : float#) : float = Float_u.to_float x\nlet unbox (x : float) : float# = Float_u.of_float x\n\n(* Between sizes *)\nlet widen (x : int32#) : int64# = Int64_u.of_int32 (Int32_u.to_int32 x)\n```\n\n---\n\n## Kinds and Unboxed Types\n\nUnboxed types have non-`value` kinds:\n\n```ocaml\n(* Kind annotations *)\ntype ('a : float64) float_container = { f : 'a }\ntype ('a : bits32) int32_container = { i : 'a }\n\n(* Polymorphic over layout *)\ntype ('a : any) wrapper = { data : 'a }  (* Accepts any layout *)\n```\n\n### Kind Constraints\n\n```ocaml\n(* Function polymorphic over float64 kind *)\nval process : ('a : float64). 'a -> 'a\n\n(* Can be called with float# *)\nlet result = process #3.14\n```\n\n---\n\n## Common Patterns\n\n### High-Performance Numeric Loop\n\n```ocaml\nlet dot_product (a : float# array) (b : float# array) : float# =\n  let len = Array.length a in\n  let mutable acc = #0.0 in\n  for i = 0 to len - 1 do\n    acc <- Float_u.add acc (Float_u.mul a.(i) b.(i))\n  done;\n  acc\n```\n\n### Unboxed Pair Return\n\n```ocaml\nlet minmax (arr : float# array) : #(float# * float#) =\n  let mutable min_val = arr.(0) in\n  let mutable max_val = arr.(0) in\n  for i = 1 to Array.length arr - 1 do\n    let v = arr.(i) in\n    if Float_u.compare v min_val < 0 then min_val <- v;\n    if Float_u.compare v max_val > 0 then max_val <- v\n  done;\n  #(min_val, max_val)\n```\n\n### Nullable Lookup\n\n```ocaml\ntype cache = {\n  data : float# array;\n  valid : bool array;\n}\n\nlet lookup (c : cache) idx : float# or_null =\n  if idx >= 0 && idx < Array.length c.data && c.valid.(idx) then\n    This c.data.(idx)\n  else\n    Null\n```\n\n### Mixed Block with Methods\n\n```ocaml\ntype complex = {\n  re : float#;\n  im : float#;\n}\n\nlet complex_add a b = {\n  re = Float_u.add a.re b.re;\n  im = Float_u.add a.im b.im;\n}\n\nlet complex_mul a b = {\n  re = Float_u.sub (Float_u.mul a.re b.re) (Float_u.mul a.im b.im);\n  im = Float_u.add (Float_u.mul a.re b.im) (Float_u.mul a.im b.re);\n}\n```\n\n---\n\n## C Interop\n\n### External Declarations\n\n```ocaml\n(* Unboxed externals - no boxing overhead *)\nexternal sin : (float[@unboxed]) -> (float[@unboxed]) =\n  \"caml_sin_float\" \"sin\" [@@unboxed] [@@noalloc]\n\n(* With float# directly *)\nexternal fast_sin : float# -> float# =\n  \"boxed_sin\" \"unboxed_sin\"\n```\n\n### C Implementation\n\n```c\n#include <caml/mlvalues.h>\n\n// Unboxed version - called directly\ndouble unboxed_sin(double x) {\n  return sin(x);\n}\n\n// Boxed wrapper\nCAMLprim value boxed_sin(value v) {\n  return caml_copy_double(unboxed_sin(Double_val(v)));\n}\n```\n\n---\n\n## Pitfalls\n\n### Cannot Use Unboxed in Polymorphic Context\n\n```ocaml\n(* ERROR: 'a defaults to kind value *)\nlet id x = x\nlet _ = id #3.14  (* Type error! *)\n\n(* FIX: Add kind annotation *)\nlet id (type a : float64) (x : a) = x\nlet _ = id #3.14  (* OK *)\n```\n\n### Cannot Store Unboxed in Regular Option\n\n```ocaml\n(* ERROR: option expects value kind *)\nlet bad : float# option = Some #3.14\n\n(* FIX: Use or_null *)\nlet good : float# or_null = This #3.14\n```\n\n### Unboxed Records Are Copied\n\n```ocaml\ntype point = #{ x : float#; y : float# }\n\nlet modify (p : point) : point =\n  (* This creates a new point, doesn't modify p *)\n  #{ x = Float_u.add p.#x #1.0; y = p.#y }\n```\n\n---\n\n## Performance Tips\n\n1. **Use unboxed types in hot loops** - eliminates allocation\n2. **Prefer `let mutable` over `ref` for unboxed accumulators**\n3. **Use unboxed arrays for numeric data**\n4. **Use `or_null` instead of `option` for nullable unboxed**\n5. **Use `[@unboxed]` on external declarations**\n\nSee also: [SKILL-KINDS.md](SKILL-KINDS.md) for the kind system,\n[SKILL-ZERO-ALLOC.md](SKILL-ZERO-ALLOC.md) for allocation-free code.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-UNIQUENESS.md": "# OxCaml Uniqueness: Detailed Guide\n\nUniqueness tracking ensures values have exactly one reference, enabling safe\nin-place mutation and resource management without runtime checks.\n\n## Core Concepts\n\n### Uniqueness Mode\n\n- **`unique`**: Exactly one reference to this value exists\n- **`aliased`**: Multiple references may exist\n\n### Linearity Mode (Related)\n\n- **`once`**: Closure can be called at most once\n- **`many`**: Closure can be called any number of times\n\nThese are related because a closure capturing a unique value can only be called\nonce (otherwise it would use the unique value twice).\n\n---\n\n## Syntax\n\n### On Parameters\n\n```ocaml\n(* Unique parameter - function consumes the only reference *)\nlet free (x @ unique) = External.free x\n\n(* Aliased parameter - multiple references allowed *)\nlet copy (x @ aliased) = clone x\n```\n\n### On Return Types\n\n```ocaml\n(* Return unique value *)\nval allocate : unit -> t @ unique\n\n(* Return aliased (duplicated) *)\nval duplicate : t -> (t * t) @ aliased\n```\n\n### On Closures\n\n```ocaml\n(* Once closure - can only be invoked once *)\nval register_callback : (unit -> unit) @ once -> unit\n\n(* Many closure - can be invoked repeatedly *)\nval set_handler : (event -> unit) @ many -> unit\n```\n\n### Combining with Locality\n\n```ocaml\n(* Local and unique *)\nval borrow : t @ unique -> (t @ local -> 'a) -> 'a * t @ unique\n\n(* All combinations possible *)\nlet f (x @ local unique once) = ...\n```\n\n---\n\n## Uniqueness Subtyping\n\nUnique values can be used where aliased are expected (you can forget uniqueness):\n\n```ocaml\nunique ≤ aliased\n\n(* OK: use unique where aliased expected *)\nlet store (x @ aliased) = global_ref := x\nlet _ = store unique_value  (* OK *)\n\n(* ERROR: use aliased where unique expected *)\nlet consume (x @ unique) = free x\nlet _ = consume aliased_value  (* Type error! *)\n```\n\n---\n\n## Aliased Modality on Fields\n\nStore aliased values in unique containers:\n\n```ocaml\n(* Contents are aliased even if container is unique *)\ntype 'a aliased_box = { value : 'a @@ aliased } [@@unboxed]\n\n(* Container is unique, contents are aliased *)\ntype 'a collection = {\n  data : 'a aliased_box array;  (* elements aliased *)\n}\n\n(* Can free container while elements remain accessible elsewhere *)\nval insert : 'a @ aliased -> 'a collection @ unique -> 'a collection @ unique\nval free_container : 'a collection @ unique -> unit\n```\n\n### Reading Aliased Fields\n\n```ocaml\ntype t = {\n  metadata : string @@ aliased;\n  payload : data;\n}\n\nlet get_metadata (t @ unique) : string (* aliased *) =\n  t.metadata  (* Reading aliased field returns aliased value *)\n```\n\n---\n\n## Uniqueness Analysis\n\nThe compiler tracks which values are unique through:\n\n### Aliasing via Binding\n\n```ocaml\nlet x = make_unique () in\nlet y = x in  (* Now both x and y reference same value *)\n(* x and y are both aliased *)\nfree x  (* ERROR: x is aliased, not unique *)\n```\n\n### Field Access Tracking\n\n```ocaml\ntype t = { a : sub; b : sub }\n\nlet ok (r @ unique) =\n  free r.a;\n  free r.b  (* OK: different fields *)\n\nlet bad (r @ unique) =\n  free r.a;\n  free r    (* ERROR: r.a already freed, r contains it *)\n```\n\n### Renaming is Tracked\n\n```ocaml\nlet ok (r @ unique) =\n  let s = r in  (* s and r are aliases, both tracked *)\n  free s.a;\n  free r.b      (* OK: compiler knows s = r *)\n```\n\n### Complex Aliases Not Tracked\n\n```ocaml\nlet bad (r @ unique) =\n  let s = Fun.id r in  (* s is not tracked as alias of r *)\n  free s.a;\n  free r.b             (* ERROR: can't prove safety *)\n```\n\n---\n\n## Branch Uniqueness\n\nDifferent branches can use unique values differently:\n\n```ocaml\nlet ok (x @ unique) =\n  if condition then\n    free x           (* Use uniquely in this branch *)\n  else\n    (store x; store x)  (* Use as aliased in this branch *)\n  (* OK: mutually exclusive *)\n\nlet ok2 (x @ unique) =\n  match x with\n  | A -> free x\n  | B -> ignore x  (* aliased use *)\n  (* OK: different branches *)\n```\n\n---\n\n## Once Closures\n\nClosures capturing unique values are `once`:\n\n```ocaml\nlet make_callback (resource @ unique) : (unit -> unit) @ once =\n  fun () -> free resource\n\n(* Can only call once *)\nlet callback = make_callback resource in\ncallback ();\ncallback ()  (* ERROR: once closure called twice *)\n```\n\n### Many Modality on Captured Values\n\n```ocaml\ntype callback_data = {\n  f : (unit -> unit) @@ many;  (* Always many *)\n}\n\nlet store (cb @ once) : callback_data @ unique =\n  { f = cb }  (* ERROR: cb is once, field requires many *)\n```\n\n---\n\n## Mode Crossing\n\nSome types cross uniqueness (can be treated as unique even when aliased):\n\n```ocaml\n(* Immediates cross uniqueness *)\nlet f (x @ aliased) : int @ unique = x  (* OK: int crosses *)\n\n(* Immutable data without refs crosses *)\nlet g (lst @ aliased) : int list @ unique = lst  (* OK if truly immutable *)\n\n(* Functions don't cross *)\nlet h (f @ aliased) : (int -> int) @ unique = f  (* ERROR *)\n```\n\n### Checking Mode Crossing\n\nA type crosses uniqueness if:\n- It's an immediate (int, bool, char, etc.)\n- It's immutable data without functions or mutable fields\n\n---\n\n## Patterns\n\n### Resource Management\n\n```ocaml\ntype handle\n\nval open_file : string -> handle @ unique\nval read : handle @ unique -> string * handle @ unique\nval close : handle @ unique -> unit\n\nlet process_file path =\n  let h = open_file path in\n  let content, h = read h in\n  close h;  (* Safe: h is unique *)\n  content\n```\n\n### Unique Mutable Phase\n\n```ocaml\ntype 'a builder\n\nval create : unit -> 'a builder @ unique\nval add : 'a -> 'a builder @ unique -> 'a builder @ unique\nval freeze : 'a builder @ unique -> 'a array (* aliased, immutable *)\n\nlet build_array items =\n  let b = create () in\n  let b = List.fold_left (fun b x -> add x b) b items in\n  freeze b  (* Returns immutable array *)\n```\n\n### Threading Unique Values\n\n```ocaml\n(* BAD: can't use unique in loop directly *)\nlet bad (arr @ unique) =\n  for i = 0 to 10 do\n    set arr i 0  (* ERROR: arr used multiple times *)\n  done\n\n(* GOOD: thread unique through *)\nlet rec set_all (arr @ unique) i =\n  if i >= length arr then arr\n  else set_all (set arr i 0) (i + 1)\n\nlet good (arr @ unique) = set_all arr 0\n```\n\n### Borrowing Pattern\n\n```ocaml\n(* Temporarily use unique value, get it back *)\nval with_ref : t @ unique -> (t @ local -> 'a) -> 'a * t @ unique\n\nlet example (data @ unique) =\n  let result, data = with_ref data (fun d ->\n    compute_something d\n  ) in\n  free data;\n  result\n```\n\n---\n\n## Common Errors and Solutions\n\n### \"This value is aliased but expected to be unique\"\n\n```ocaml\n(* ERROR *)\nlet bad x =\n  let y = x in\n  free x  (* x is aliased due to y *)\n\n(* FIX: Don't alias before unique use *)\nlet good x =\n  free x\n\n(* FIX: Use the alias *)\nlet good2 x =\n  let y = x in\n  free y\n```\n\n### \"Cannot use value uniquely after pattern match\"\n\n```ocaml\n(* ERROR: pattern match aliases *)\nlet bad (t @ unique) =\n  match t with\n  | { field } ->\n    use_field field;\n    free t  (* ERROR: t aliased by pattern *)\n\n(* FIX: Use with_ref pattern *)\nlet good (t @ unique) =\n  let result, t = with_ref t (fun t ->\n    match t with\n    | { field } -> use_field field\n  ) in\n  free t;\n  result\n```\n\n### \"This closure is once but expected to be many\"\n\n```ocaml\n(* ERROR *)\nlet bad (r @ unique) =\n  let f () = free r in\n  register_handler f  (* handler expects many *)\n\n(* FIX: Don't capture unique in many closure *)\nlet good () =\n  let f () = () in  (* No unique captures *)\n  register_handler f\n```\n\n### \"Cannot call once closure multiple times\"\n\n```ocaml\n(* ERROR *)\nlet bad (f @ once) =\n  f (); f ()\n\n(* FIX: Only call once, or require many *)\nlet good (f @ once) = f ()\nlet good2 (f @ many) = f (); f ()\n```\n\n---\n\n## Uniqueness with Aliased Fields\n\n```ocaml\ntype container = {\n  handle : handle;  (* unique with container *)\n  cache : data @@ aliased;  (* aliased, shared elsewhere *)\n}\n\nlet close_container (c @ unique) =\n  (* Can free handle, cache may still be used elsewhere *)\n  free_handle c.handle\n  (* cache is not freed *)\n\nlet get_cache (c @ unique) : data (* aliased *) =\n  c.cache  (* Returns aliased copy *)\n```\n\n---\n\n## Summary\n\n| Mode | Meaning | Subtyping | Crosses |\n|------|---------|-----------|---------|\n| `unique` | Single reference | ≤ `aliased` | Immediates, imm. data |\n| `aliased` | Multiple references | (top) | - |\n| `once` | Call at most once | ≤ `many` | Non-function types |\n| `many` | Call any times | (top) | - |\n\nSee also: [SKILL-MODES.md](SKILL-MODES.md) for full mode system,\n[SKILL-STACK-ALLOCATION.md](SKILL-STACK-ALLOCATION.md) for locality.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL-ZERO-ALLOC.md": "# OxCaml Zero-Alloc Checking: Detailed Guide\n\nThe `[@zero_alloc]` attribute enables compile-time verification that functions\ndon't allocate on the OCaml heap, ensuring predictable performance in hot paths.\n\n## Basic Usage\n\n### Annotating Functions\n\n```ocaml\n(* Simple zero-alloc function *)\nlet[@zero_alloc] add x y = x + y\n\n(* With explicit type *)\nlet[@zero_alloc] multiply : int -> int -> int = fun x y -> x * y\n```\n\n### What Counts as Allocation?\n\n**Forbidden** (causes check failure):\n- Heap allocation: tuples, records, variants, closures, etc.\n- Boxing: `int64`, `float` operations that box\n- Raising exceptions with backtrace (unless in error path)\n- Indirect calls (function passed as argument)\n\n**Allowed**:\n- Stack allocation: `stack_`, `local_`\n- Immediate values: `int`, `bool`, `char`\n- Unboxed operations: `float#`, `int32#`, etc.\n- Direct calls to known zero-alloc functions\n\n---\n\n## Annotation Variants\n\n### Basic `[@zero_alloc]`\n\n- Checked in all builds\n- Uses \"relaxed\" semantics (allows allocation on exception paths)\n\n```ocaml\nlet[@zero_alloc] find arr idx =\n  if idx < 0 || idx >= Array.length arr then\n    raise (Invalid_argument \"out of bounds\")  (* Allowed - exception path *)\n  else\n    arr.(idx)\n```\n\n### `[@zero_alloc strict]`\n\n- No allocation on any path, including exceptions\n\n```ocaml\nlet[@zero_alloc strict] add x y = x + y  (* Must not allocate anywhere *)\n```\n\n### `[@zero_alloc opt]`\n\n- Only checked in optimized builds (`-zero-alloc-check all`)\n- Useful when inlining is required\n\n```ocaml\nlet[@zero_alloc opt] complex_op x =\n  (* Requires inlining to be zero-alloc *)\n  helper1 x |> helper2 |> helper3\n```\n\n### `[@zero_alloc assume]`\n\n- Not checked - trusted to be zero-alloc\n- Use sparingly\n\n```ocaml\nlet[@cold][@zero_alloc assume] log_error msg =\n  Printf.eprintf \"Error: %s\\n\" msg\n\nlet[@zero_alloc] process x =\n  if is_error x then log_error \"bad input\";  (* Allowed due to assume *)\n  compute x\n```\n\n### `[@zero_alloc assume error]`\n\n- Marks function as error path - all code after it ignored\n\n```ocaml\nlet[@cold][@zero_alloc assume error] fatal msg =\n  Printf.eprintf \"Fatal: %s\\n\" msg;\n  exit 1\n\nlet[@zero_alloc] process x =\n  if is_fatal x then fatal \"unrecoverable\";\n  (* Code after fatal () is ignored for zero_alloc purposes *)\n  compute x\n```\n\n### `[@zero_alloc assume_unless_opt]`\n\n- Assumed in debug builds, checked in optimized builds\n\n```ocaml\nlet[@zero_alloc assume_unless_opt] helper x =\n  (* Assumed zero-alloc in debug, checked with -zero-alloc-check all *)\n  ...\n```\n\n---\n\n## Stack Allocation is Allowed\n\n```ocaml\nlet[@zero_alloc] with_pair x y f =\n  let local_ p = stack_ (x, y) in  (* OK: stack allocation *)\n  f p\n\nlet[@zero_alloc] sum_pairs arr =\n  let local_ total = ref 0 in  (* OK: local ref *)\n  for i = 0 to Array.length arr / 2 - 1 do\n    total := !total + arr.(i * 2) + arr.(i * 2 + 1)\n  done;\n  !total\n```\n\n---\n\n## In Signatures\n\n### Basic Signature Annotation\n\n```ocaml\nval[@zero_alloc] fast_hash : string -> int\n\n(* Implementation must be zero-alloc *)\nlet fast_hash s = ...  (* Checked even without annotation here *)\n```\n\n### With Arity\n\n```ocaml\n(* Specify how many arguments before zero-alloc applies *)\nval[@zero_alloc arity 2] partial_apply : int -> int -> int\n\n(* Only fully applied calls are zero-alloc *)\nlet f = partial_apply 1  (* May allocate closure *)\nlet x = partial_apply 1 2  (* Zero-alloc *)\n```\n\n### Hidden Type Aliases\n\n```ocaml\ntype t = int -> int\nval[@zero_alloc arity 1] f : t  (* Need arity since t hides arrow *)\n```\n\n---\n\n## Interaction with Other Features\n\n### With Unboxed Types\n\n```ocaml\nlet[@zero_alloc] unboxed_add (x : float#) (y : float#) : float# =\n  Float_u.add x y  (* No boxing - zero-alloc *)\n```\n\n### With Inlining\n\n```ocaml\nlet[@inline always][@zero_alloc] helper x = x + 1\n\nlet[@zero_alloc] process arr =\n  for i = 0 to Array.length arr - 1 do\n    arr.(i) <- helper arr.(i)  (* Inlined, so zero-alloc *)\n  done\n```\n\n### With External Functions\n\n```ocaml\n(* [@@noalloc] on externals is trusted *)\nexternal fast_memcpy : bytes -> bytes -> int -> unit =\n  \"caml_fast_memcpy\" [@@noalloc]\n\nlet[@zero_alloc] copy src dst len =\n  fast_memcpy dst src len  (* OK: external marked noalloc *)\n```\n\n---\n\n## File-Level Annotations\n\n### `[@@@zero_alloc all]`\n\nAll functions in file must be zero-alloc:\n\n```ocaml\n[@@@zero_alloc all]\n\nlet add x y = x + y      (* Checked *)\nlet mul x y = x * y      (* Checked *)\n\nlet[@zero_alloc ignore] debug x =\n  Printf.printf \"%d\\n\" x  (* Exempted *)\n```\n\n### `[@@@zero_alloc check]` / `[@@@zero_alloc check_all]`\n\nControl checking mode for file:\n\n```ocaml\n[@@@zero_alloc check_all]  (* Check opt annotations too *)\n```\n\n---\n\n## On Applications\n\nAnnotate specific call sites:\n\n```ocaml\nlet[@zero_alloc] process x =\n  (* Assume this specific call is zero-alloc *)\n  (external_func [@zero_alloc assume]) x\n```\n\n---\n\n## Common Patterns\n\n### Zero-Alloc Hot Loop\n\n```ocaml\nlet[@zero_alloc] sum_array arr =\n  let mutable total = 0 in  (* No allocation *)\n  for i = 0 to Array.length arr - 1 do\n    total <- total + arr.(i)\n  done;\n  total\n```\n\n### Zero-Alloc with Error Handling\n\n```ocaml\nlet[@cold][@zero_alloc assume error] report_error code =\n  Printf.eprintf \"Error %d\\n\" code;\n  Error code\n\nlet[@zero_alloc] parse_packet buf =\n  if Buffer.length buf < 4 then report_error 1\n  else\n    let header = ... in\n    Ok header\n```\n\n### Zero-Alloc Option Handling with or_null\n\n```ocaml\nlet[@zero_alloc] find_value (arr : float# array) idx : float# or_null =\n  if idx >= 0 && idx < Array.length arr then\n    This arr.(idx)  (* No allocation with or_null *)\n  else\n    Null\n```\n\n### Zero-Alloc Record Update\n\n```ocaml\ntype state = { x : int; y : int; z : int }\n\n(* ERROR: record update allocates *)\nlet[@zero_alloc] bad_update s = { s with x = s.x + 1 }\n\n(* OK: use mutable fields or unboxed *)\ntype mutable_state = { mutable x : int; mutable y : int; mutable z : int }\n\nlet[@zero_alloc] good_update s =\n  s.x <- s.x + 1;\n  s\n```\n\n---\n\n## Understanding Failures\n\nWhen check fails, compiler shows all allocations:\n\n```\nError: Annotation check for zero_alloc failed on function M.f\n\nFile \"m.ml\", line 5, characters 10-15:\n5 |     match bar x with\n              ^^^^^\nError: called function may allocate (direct call to bar)\n\nFile \"m.ml\", line 9, characters 6-12:\n9 |       (a, a)\n          ^^^^^^\nError: allocation of 24 bytes\n```\n\n### Controlling Detail Level\n\n```bash\n# Show all allocations (default)\n-zero-alloc-checker-details-cutoff -1\n\n# Show only first N\n-zero-alloc-checker-details-cutoff 5\n\n# Show none (just fail)\n-zero-alloc-checker-details-cutoff 0\n```\n\n---\n\n## Common Errors and Fixes\n\n### \"Called function may allocate (indirect call)\"\n\n```ocaml\n(* ERROR: f is indirect *)\nlet[@zero_alloc] apply f x = f x\n\n(* FIX: Can't fix without knowing f is zero-alloc *)\n(* Options:\n   1. Use [@zero_alloc assume] on the call\n   2. Make f an inline function\n   3. Accept that this can't be zero-alloc\n*)\n```\n\n### \"Allocation of N bytes\"\n\n```ocaml\n(* ERROR: tuple allocation *)\nlet[@zero_alloc] bad x y = (x, y)\n\n(* FIX: Use stack allocation *)\nlet[@zero_alloc] good x y = exclave_ stack_ (x, y)\n\n(* OR return unboxed *)\nlet[@zero_alloc] good2 (x : int) (y : int) : #(int * int) = #(x, y)\n```\n\n### \"Called function may allocate (external call)\"\n\n```ocaml\n(* ERROR: external without [@@noalloc] *)\nexternal process : int -> int = \"caml_process\"\n\n(* FIX: Add noalloc if truly non-allocating *)\nexternal process : int -> int = \"caml_process\" [@@noalloc]\n\n(* OR assume at call site *)\nlet[@zero_alloc] f x = (process [@zero_alloc assume]) x\n```\n\n---\n\n## Build Configuration\n\n### dune\n\n```lisp\n(library\n (name mylib)\n (ocamlopt_flags (:standard -zero-alloc-check all)))\n```\n\n### Compiler Flags\n\n| Flag | Effect |\n|------|--------|\n| `-zero-alloc-check default` | Check non-opt annotations (default) |\n| `-zero-alloc-check all` | Check all including opt |\n| `-zero-alloc-check none` | Disable checking |\n| `-disable-zero-alloc-checker` | Disable entirely (no summaries) |\n\n---\n\n## Limitations\n\n- Conservative - may reject valid zero-alloc code\n- Higher-order functions often fail (indirect calls)\n- Requires cross-module info for accurate checking\n- Flat float optimization can cause false positives\n- Safepoints not considered allocating (may context switch)\n\n---\n\n## Best Practices\n\n1. **Start with `[@zero_alloc opt]`** until code stabilizes\n2. **Use `[@cold]` on error paths** to hint to optimizer\n3. **Combine with `[@inline always]`** for small helpers\n4. **Use unboxed types** for numeric hot paths\n5. **Use `or_null` instead of `option`** for nullable unboxed\n6. **Annotate signatures** for cross-module checking\n\nSee also: [SKILL-STACK-ALLOCATION.md](SKILL-STACK-ALLOCATION.md) for local allocation,\n[SKILL-UNBOXED.md](SKILL-UNBOXED.md) for unboxed types.\n",
        "plugins/ocaml-dev/skills/oxcaml/SKILL.md": "---\nname: oxcaml\ndescription: Working with the OxCaml extensions to OCaml. Use when the oxcaml compiler is available and you need high-performance, unboxing, stack allocation, data-race-free parallelism\nlicense: ISC\n---\n\nYou are writing code for the OxCaml compiler, a performance-focused fork of\nOCaml with Jane Street extensions. This guide covers OxCaml-specific features.\nYou should already know standard OCaml.\n\n## Detailed Guides\n\nFor in-depth coverage of each feature, see:\n\n| Feature | Guide |\n|---------|-------|\n| **Modes** (local, unique, once, portable, contended) | [SKILL-MODES.md](SKILL-MODES.md) |\n| **Stack Allocation** (local_, stack_, exclave_) | [SKILL-STACK-ALLOCATION.md](SKILL-STACK-ALLOCATION.md) |\n| **Unboxed Types** (float#, int32#, mixed blocks) | [SKILL-UNBOXED.md](SKILL-UNBOXED.md) |\n| **Kinds** (value, float64, bits32, kind products) | [SKILL-KINDS.md](SKILL-KINDS.md) |\n| **Uniqueness** (unique/aliased, once/many) | [SKILL-UNIQUENESS.md](SKILL-UNIQUENESS.md) |\n| **Comprehensions** (list/array builders) | [SKILL-COMPREHENSIONS.md](SKILL-COMPREHENSIONS.md) |\n| **SIMD** (vector types, SSE/AVX intrinsics) | [SKILL-SIMD.md](SKILL-SIMD.md) |\n| **Templates** (ppx_template, mangling) | [SKILL-TEMPLATES.md](SKILL-TEMPLATES.md) |\n| **Zero-Alloc** ([@zero_alloc] checking) | [SKILL-ZERO-ALLOC.md](SKILL-ZERO-ALLOC.md) |\n| **Base Library** (OxCaml extensions) | [SKILL-BASE.md](SKILL-BASE.md) |\n| **Core Library** (OxCaml extensions) | [SKILL-CORE.md](SKILL-CORE.md) |\n\n---\n\n## Quick Reference: Syntax Cheat Sheet\n\n```ocaml\n(* Stack allocation *)\nlet f () = exclave_ stack_ (1, 2)      (* allocate on stack, return local *)\nlet g (x @ local) = ...                 (* local parameter *)\n\n(* Unboxed types *)\nlet x : float# = #3.14                  (* unboxed float *)\nlet y : int32# = #42l                   (* unboxed int32 *)\ntype t = { a : int; b : float# }        (* mixed block record *)\n\n(* Modes on values *)\nlet f (x @ local unique once) = ...     (* multiple modes *)\nval g : t @ global -> t @ local         (* in signatures *)\n\n(* Kinds on types *)\ntype ('a : float64) t = ...             (* kind annotation *)\nval f : ('a : value). 'a -> 'a          (* kind-polymorphic *)\n\n(* Comprehensions *)\n[ x * 2 for x = 1 to 10 when x mod 2 = 0 ]\n[| y for y in arr when y > 0 |]\n\n(* Labeled tuples *)\nlet pair = ~x:1, ~y:2                   (* labeled tuple *)\nlet ~x, ~y = pair                       (* destructuring *)\n\n(* Immutable arrays *)\nlet arr : int iarray = [: 1; 2; 3 :]\nlet x = arr.:(0)\n\n(* Unboxed tuple destructuring - use #(...) pattern *)\nlet #(a, b) = some_unboxed_pair\nlet #(x, y, z) = fork_join3 par f1 f2 f3\n\n(* Zero-alloc annotation *)\nlet[@zero_alloc] fast_add x y = x + y\n```\n\n---\n\n## 1. Modes\n\nModes track runtime properties of values. Each mode axis is independent.\n\n### Mode Axes\n\n| Axis | Values | Default | Purpose |\n|------|--------|---------|---------|\n| Locality | `local`, `global` | `global` | Where value lives (stack vs heap) |\n| Uniqueness | `unique`, `aliased` | `aliased` | Number of references |\n| Linearity | `once`, `many` | `many` | How often closures can be called |\n| Portability | `portable`, `shareable`, `nonportable` | `nonportable` | Cross-thread safety |\n| Contention | `contended`, `shared`, `uncontended` | `uncontended` | Thread access patterns |\n\n### Syntax\n\n```ocaml\n(* On parameters *)\nlet f (x @ local) = ...\nlet f (x @ local unique) = ...       (* multiple modes *)\n\n(* On return types in signatures *)\nval f : t @ local -> t @ global\nval g : t @ unique once -> t @ aliased many\n\n(* On expressions *)\nlet x = (expr : t @ local)\n\n(* On let bindings *)\nlet local_ x = ...                    (* shorthand for local *)\nlet global_ x = ...\n\n(* On record fields - modalities *)\ntype t = {\n  global_ data : int;                 (* always global *)\n  mutable x : int @@ aliased;         (* aliased modality *)\n}\n```\n\n### Subtyping Rules\n\nMore restrictive modes can be used where less restrictive are expected:\n- `local` ≤ `global` (can use local where global expected? NO - reversed)\n- `global` ≤ `local` (can use global where local expected)\n- `unique` ≤ `aliased` (can use unique where aliased expected)\n- `many` ≤ `once` (can use many where once expected)\n- `portable` ≤ `shareable` ≤ `nonportable`\n- `uncontended` ≤ `shared` ≤ `contended`\n\n---\n\n## 2. Stack Allocation (Locality)\n\nStack-allocated values avoid GC overhead but cannot escape their scope.\n\n### Key Constructs\n\n```ocaml\n(* Allocate on stack *)\nlet f () =\n  let local_ x = (1, 2) in            (* stack-allocated tuple *)\n  ...\n\n(* Force stack allocation *)\nlet f () =\n  stack_ (1, 2)                        (* explicitly stack-allocate *)\n\n(* Return local value from function *)\nlet f () = exclave_\n  stack_ (1, 2)                        (* return value allocated in caller's frame *)\n\n(* Combined pattern for local returns *)\nlet f () = exclave_ stack_ (make_tuple ())\n```\n\n### Rules\n\n1. Local values CANNOT escape their defining scope (no storing in globals, no returning without `exclave_`)\n2. Local values CAN reference global values\n3. Global values CANNOT reference local values\n4. `exclave_` allocates in caller's stack frame and must be at tail position\n\n### Common Patterns\n\n```ocaml\n(* Process local data without allocation *)\nlet sum_pairs (pairs @ local) =\n  List.fold_left (fun acc (a, b) -> acc + a + b) 0 pairs\n\n(* Return local from function *)\nlet make_pair x y = exclave_ stack_ (x, y)\n\n(* Local references for accumulators *)\nlet count_positives lst =\n  let local_ r = ref 0 in\n  List.iter (fun x -> if x > 0 then r := !r + 1) lst;\n  !r\n```\n\n---\n\n## 3. Unboxed Types\n\nUnboxed types store values directly without heap allocation.\n\n### Built-in Unboxed Types\n\n```ocaml\n(* Numeric types - # suffix means unboxed *)\nfloat#     (* 64-bit float, kind float64 *)\nint32#     (* 32-bit int, kind bits32 *)\nint64#     (* 64-bit int, kind bits64 *)\nnativeint# (* native int, kind word *)\nfloat32#   (* 32-bit float, kind float32 *)\nint8#      (* 8-bit int - untagged *)\nint16#     (* 16-bit int - untagged *)\nint#       (* native int - untagged *)\nchar#      (* 8-bit char - untagged, same layout as int8# *)\n\n(* Literals use # prefix *)\nlet x : float# = #3.14\nlet y : int32# = #42l\nlet z : int64# = #100L\nlet w : float32# = #1.0s\nlet a : int8# = #42s       (* int8# literal *)\nlet b : int16# = #42S      (* int16# literal *)\nlet c : char# = #'x'       (* char# literal *)\n\n(* Boxed versions (heap-allocated) *)\nlet a : float = 3.14       (* boxed *)\nlet b : float# = #3.14     (* unboxed *)\n```\n\n### Untagged Int Arrays (New in 5.2.0minus-25)\n\nArrays of untagged types are packed for memory efficiency:\n\n```ocaml\n(* Untagged int arrays - tightly packed *)\nlet bytes : int8# array = [| #0s; #1s; #255s |]\nlet shorts : int16# array = [| #0S; #1S; #32767S |]\nlet ints : int# array = [| #0; #1; #42 |]\nlet chars : char# array = [| #'a'; #'b'; #'c' |]\n\n(* int8# array: 1 byte per element *)\n(* int16# array: 2 bytes per element *)\n(* int# array: native word size per element *)\n```\n\n### Unboxed Records\n\n```ocaml\n(* Unboxed record - stored inline, not heap-allocated *)\ntype point = #{ x : float#; y : float# }\n\n(* Create unboxed record *)\nlet p : point = #{ x = #1.0; y = #2.0 }\n\n(* Access fields *)\nlet get_x (p : point) = p.#x\n```\n\n### Unboxed Tuples\n\n```ocaml\n(* Unboxed tuple syntax *)\ntype pair = #(float# * int32#)\n\nlet p : #(float# * int32#) = #(#1.0, #42l)\n```\n\n### Mixed Blocks\n\nRecords can mix boxed and unboxed fields:\n\n```ocaml\ntype mixed = {\n  name : string;          (* boxed *)\n  value : float#;         (* unboxed, stored flat *)\n  count : int32#;         (* unboxed *)\n}\n```\n\n### or_null Type\n\nNon-allocating option for nullable values:\n\n```ocaml\ntype 'a or_null = Null | This of 'a\n\n(* Use for optional unboxed values without allocation *)\nlet find_float arr idx : float# or_null =\n  if idx < Array.length arr then This arr.(idx)\n  else Null\n```\n\n---\n\n## 4. Kinds\n\nKinds classify types by their runtime representation.\n\n### Kind Hierarchy\n\n```\nany                           (* any layout *)\n├── value                     (* standard OCaml boxed values *)\n├── float64                   (* 64-bit floats *)\n├── float32                   (* 32-bit floats *)\n├── bits32                    (* 32-bit integers *)\n├── bits64                    (* 64-bit integers *)\n├── word                      (* native word size *)\n└── void                      (* uninhabited *)\n```\n\n### Kind Annotations\n\n```ocaml\n(* On type parameters *)\ntype ('a : float64) container = ...\n\n(* On type variables in signatures *)\nval f : ('a : value). 'a -> 'a\nval g : ('a : bits64). 'a -> 'a\n\n(* On abstract types *)\ntype t : float64\n\n(* Kind products for unboxed tuples *)\ntype pair : float64 & bits32    (* unboxed pair of float# and int32# *)\n```\n\n### Kind Abbreviations\n\n```ocaml\nvalue           = value_or_null mod non_null separable\nimmediate       = value mod external_\nimmediate64     = value mod external64\nmutable_data    = value mod non_float\nimmutable_data  = value mod non_float immutable\n```\n\n### Mode Bounds on Kinds\n\nKinds can specify which modes a type crosses:\n\n```ocaml\n(* Type that cannot be used at mode local *)\ntype t : value mod global\n\n(* Type that is always portable *)\ntype t : value mod portable\n```\n\n---\n\n## 5. Uniqueness\n\nTrack values with exactly one reference for safe mutation/deallocation.\n\n### Modes\n\n- `unique`: Single reference exists\n- `aliased`: Multiple references may exist\n\n### Syntax\n\n```ocaml\n(* Unique parameter - consumed by function *)\nval free : t @ unique -> unit\n\n(* Aliased return - may have multiple references *)\nval duplicate : t -> t * t @ aliased\n\n(* Once closures - can only be invoked once *)\nval delay_free : t @ unique -> (unit -> unit) @ once\n```\n\n### Uniqueness Rules\n\n```ocaml\n(* OK: match then use uniquely *)\nlet ok t =\n  match t with\n  | Con { field } -> free t\n\n(* ERROR: using parts twice *)\nlet bad t =\n  match t with\n  | Con { field } ->\n    free_field field;   (* uses field *)\n    free t              (* uses t which contains field *)\n\n(* OK: different branches *)\nlet ok t =\n  match t with\n  | Con { field } ->\n    if cond then free_field field\n    else free t\n```\n\n### Aliased Modality\n\nStore aliased values in unique containers:\n\n```ocaml\ntype 'a aliased_box = { value : 'a @@ aliased } [@@unboxed]\n\n(* Container is unique but contents are aliased *)\nval push : 'a @ aliased -> 'a aliased_box list @ unique -> 'a aliased_box list @ unique\n```\n\n---\n\n## 6. Comprehensions\n\nPython/Haskell-style list and array builders.\n\n### List Comprehensions\n\n```ocaml\n(* Basic *)\n[ x * 2 for x = 1 to 10 ]\n\n(* With filter *)\n[ x for x = 1 to 100 when x mod 2 = 0 ]\n\n(* Nested iteration *)\n[ (x, y) for x = 1 to 3 for y = 1 to 3 ]\n\n(* Iterate over list *)\n[ String.uppercase s for s in strings ]\n\n(* Multiple conditions *)\n[ x + y for x = 1 to 10 for y = 1 to 10 when x < y when x + y < 15 ]\n\n(* Parallel iteration (evaluated together) *)\n[ x + y for x = 1 to 3 and y = 10 to 12 ]\n```\n\n### Array Comprehensions\n\n```ocaml\n(* Same syntax with [| |] *)\n[| x * x for x = 1 to 10 |]\n\n(* Iterate over array *)\n[| f elem for elem in source_array |]\n```\n\n### Immutable Array Comprehensions\n\n```ocaml\n[: x for x = 1 to 10 when x mod 2 = 0 :]\n```\n\n### Key Differences: `for` vs `and`\n\n- `for ... for ...`: Nested (inner re-evaluated each outer iteration)\n- `for ... and ...`: Parallel (both evaluated once upfront)\n\n```ocaml\n(* Nested: 9 elements *)\n[ (x, y) for x = 1 to 3 for y = 1 to 3 ]\n\n(* Parallel: 3 elements *)\n[ (x, y) for x = 1 to 3 and y = 10 to 12 ]\n(* = [(1,10); (2,11); (3,12)] *)\n```\n\n---\n\n## 7. SIMD Vector Types\n\n128-bit and 256-bit SIMD vectors for parallel numeric operations.\n\n### Types\n\n```ocaml\n(* 128-bit vectors *)\nint8x16    int8x16#      (* 16 x 8-bit ints *)\nint16x8    int16x8#      (* 8 x 16-bit ints *)\nint32x4    int32x4#      (* 4 x 32-bit ints *)\nint64x2    int64x2#      (* 2 x 64-bit ints *)\nfloat32x4  float32x4#    (* 4 x 32-bit floats *)\nfloat64x2  float64x2#    (* 2 x 64-bit floats *)\n\n(* 256-bit vectors *)\nint8x32    int8x32#\nint32x8    int32x8#\nfloat64x4  float64x4#\n(* etc. *)\n```\n\n### Usage\n\n```ocaml\nopen Ocaml_simd_sse\n\nlet v = Float32x4.set 1.0 2.0 3.0 4.0\nlet v = Float32x4.sqrt v\nlet x, y, z, w = Float32x4.splat v\n\n(* Load from arrays *)\nlet v = Int8x16.String.get text ~byte:0\n```\n\n### C Stubs\n\n```ocaml\nexternal vec_op : (int8x16[@unboxed]) -> (int8x16[@unboxed]) =\n  \"boxed_stub\" \"unboxed_stub\"\n```\n\n---\n\n## 8. Templates (ppx_template)\n\nGenerate multiple copies of code with different modes/kinds.\n\n### Mode Templates\n\n```ocaml\n(* Define once, get local and global versions *)\nlet%template[@mode m = (global, local)] id\n  : 'a. 'a @ m -> 'a @ m\n  = fun x -> x\n\n(* Generates: id (global) and id__local *)\n\n(* Instantiate *)\nlet f x = (id [@mode local]) x\n```\n\n### Kind Templates\n\n```ocaml\nlet%template[@kind k = (value, float64)] id\n  : ('a : k). 'a -> 'a\n  = fun x -> x\n\n(* Generates: id (value) and id__float64 *)\n```\n\n### Exclave Conditional\n\n```ocaml\nlet%template[@mode m = (global, local)] make_pair x y =\n  (x, y) [@exclave_if_local m]\n\n(* local version gets: exclave_ (x, y) *)\n```\n\n### Alloc Templates\n\n```ocaml\nlet%template rec map\n  : f:('a -> 'b @ m) -> 'a list -> 'b list @ m\n  = fun ~f list ->\n    match[@exclave_if_stack a] list with\n    | [] -> []\n    | hd :: tl -> f hd :: (map [@alloc a]) ~f tl\n[@@alloc a @ m = (heap_global, stack_local)]\n```\n\n### Portable Functors\n\n```ocaml\n(* Short form for portable/nonportable functor variants *)\nmodule%template.portable Make (M : S) : T\n```\n\n### Default Floating Attributes\n\n```ocaml\n[%%template:\n[@@@mode.default m = (global, local)]\n\nval min : t @ m -> t @ m -> t @ m\nval max : t @ m -> t @ m -> t @ m]\n```\n\n---\n\n## 9. Zero-Alloc Checking\n\nCompile-time verification that functions don't allocate.\n\n### Basic Usage\n\n```ocaml\n(* Check function doesn't allocate *)\nlet[@zero_alloc] fast_add x y = x + y\n\n(* Allow local/stack allocations *)\nlet[@zero_alloc] with_local_pair x y =\n  let p = stack_ (x, y) in\n  fst p + snd p\n\n(* Only check in optimized builds *)\nlet[@zero_alloc opt] complex_func x = ...\n\n(* Strict: no allocation even on error paths *)\nlet[@zero_alloc strict] very_strict x = ...\n```\n\n### Assume Annotations\n\n```ocaml\n(* Trust this function is zero-alloc *)\nlet[@zero_alloc assume] external_wrapper x = external_func x\n\n(* Assume for error paths *)\nlet[@cold][@zero_alloc assume error] handle_error e =\n  log_error e;\n  default_value\n```\n\n### In Signatures\n\n```ocaml\nval[@zero_alloc] f : int -> int\nval[@zero_alloc strict] g : t -> t\nval[@zero_alloc arity 2] h : int -> int -> int\n```\n\n### File-Level\n\n```ocaml\n[@@@zero_alloc all]  (* All functions must be zero-alloc *)\n\nlet[@zero_alloc ignore] allowed_to_alloc x = [x]  (* Opt out *)\n```\n\n---\n\n## 10. Parallelism & Capsules\n\nSafe parallel programming with thread isolation.\n\n### Contention Modes\n\n- `contended`: May be accessed from multiple threads concurrently\n- `shared`: May be accessed from multiple threads (for shared state)\n- `uncontended`: Single-thread access\n\n### Portability Modes\n\n- `portable`: Safe to move across thread boundaries, captures all values at contended\n- `shareable`: May execute in parallel, captures shared state\n- `nonportable`: Thread-local only, captures uncontended mutable state\n\n### Capsules (Experimental)\n\nCapsules isolate mutable state for safe parallelism:\n\n```ocaml\n(* Capsule contains thread-local mutable state *)\ntype 'a capsule\n\n(* Access requires entering capsule context *)\nval with_capsule : 'a capsule -> ('a @ local -> 'b) -> 'b\n```\n\n---\n\n## 11. Miscellaneous Extensions\n\n### Labeled Tuples\n\n```ocaml\n(* Create *)\nlet point = ~x:10, ~y:20\n\n(* Type *)\ntype point = x:int * y:int\n\n(* Destructure *)\nlet ~x, ~y = point\n\n(* Partial match (needs type annotation) *)\nlet get_x (p : x:int * y:int) =\n  let ~x, .. = p in x\n\n(* Function returning labeled tuple *)\nval dimensions : image -> width:int * height:int\n```\n\n### Immutable Arrays\n\n```ocaml\n(* Syntax uses : instead of | *)\nlet arr : string iarray = [: \"a\"; \"b\"; \"c\" :]\n\n(* Access *)\nlet first = arr.:(0)\n\n(* Covariant - allows safe subtyping *)\nlet arr2 : obj iarray = (arr : sub_obj iarray :> obj iarray)\n```\n\n### Include Functor\n\n```ocaml\n(* Instead of *)\nmodule M = struct\n  module T = struct\n    type t = ...\n    [@@deriving compare, sexp]\n  end\n  include T\n  include Comparable.Make(T)\nend\n\n(* Write *)\nmodule M = struct\n  type t = ...\n  [@@deriving compare, sexp]\n\n  include functor Comparable.Make\nend\n```\n\n### Let Mutable\n\n```ocaml\n(* Mutable local variable - no allocation *)\nlet triangle n =\n  let mutable total = 0 in\n  for i = 1 to n do\n    total <- total + i\n  done;\n  total\n```\n\nRestrictions: Cannot escape scope, no closure capture, single variable only.\n\n### Polymorphic Parameters\n\n```ocaml\n(* Function taking polymorphic argument *)\nlet create (f : 'a. 'a field -> 'a) =\n  { a = f A; b = f B }\n\nval create : ('a. 'a field -> 'a) -> t\n```\n\n### Small Numbers\n\n```ocaml\n(* Types *)\nfloat32   float32#\nint8      int8#\nint16     int16#\nchar#\n\n(* Literals *)\n1.0s    (* float32 *)\n#1.0s   (* float32# *)\n42s     (* int8 *)\n#42s    (* int8# *)\n42S     (* int16 *)\n#42S    (* int16# *)\n#'a'    (* char# *)\n\n(* Arrays - now supported and packed! *)\nint8 array    int8# array     (* 1 byte per element *)\nint16 array   int16# array    (* 2 bytes per element *)\nchar# array                   (* 1 byte per element *)\n\n(* Pattern matching with char# ranges *)\nmatch c with\n| #'a'..#'z' -> `lowercase\n| #'A'..#'Z' -> `uppercase\n| _ -> `other\n```\n\n### Module Strengthening\n\n```ocaml\n(* Instead of *)\nsig type t = M.t end\n\n(* Write *)\nS with M\n```\n\n---\n\n## Common Patterns\n\n### Zero-Alloc Hot Path\n\n```ocaml\nlet[@zero_alloc] process_batch (data @ local) =\n  let local_ acc = ref 0 in\n  for i = 0 to Array.length data - 1 do\n    acc := !acc + process_item data.(i)\n  done;\n  !acc\n```\n\n### Local Allocation in Loop\n\n```ocaml\nlet process_all items =\n  List.iter (fun item ->\n    let local_ temp = compute item in\n    use temp\n  ) items\n```\n\n### Unique Resource Management\n\n```ocaml\ntype handle\n\nval open_handle : unit -> handle @ unique\nval use_handle : handle @ unique -> result * handle @ unique\nval close_handle : handle @ unique -> unit\n\nlet with_handle f =\n  let h = open_handle () in\n  let result, h = use_handle h in\n  close_handle h;\n  result\n```\n\n### Mode-Polymorphic Function\n\n```ocaml\nlet%template[@mode m = (global, local)] map_pair f (a, b) =\n  ((f a, f b) [@exclave_if_local m])\n```\n\n### Kind-Polymorphic Container\n\n```ocaml\ntype%template ('a : k) box = { contents : 'a }\n[@@kind k = (value, float64, bits64)]\n```\n\n---\n\n## Debugging Tips\n\n1. **Mode errors**: Check if you're trying to return local data globally\n2. **Kind errors**: Ensure type parameters have correct layout annotations\n3. **Zero-alloc failures**: Use `-zero-alloc-checker-details-cutoff -1` for full details\n4. **Template issues**: Check mangled names with `__suffix` pattern\n\n---\n\n## Library Dependencies\n\n### Core Libraries\n\n- **`stdlib_stable`**: Immutable arrays (`Iarray`), `Float32`, `Int8`, `Int16`, `Char_u`\n- **`base`**: Jane Street's standard library with comprehensive OxCaml mode support\n  - **IMPORTANT**: Consult [SKILL-BASE.md](SKILL-BASE.md) for OxCaml-friendly functions!\n  - Contains 116 modules with extensive local/exclave, mode, and unboxed type support\n  - Key modules: `Modes` (modal wrappers), `Iarray` (immutable arrays with local ops),\n    `Container_with_local`, and `__local` variants of most collection functions\n- **`core`**: Extended library with I/O, async, and system features\n  - See [SKILL-CORE.md](SKILL-CORE.md) for Iobuf, Time_ns, Bigstring extensions\n\n### PPX Libraries\n\n- **`ppx_template`**: Mode/kind polymorphism via code generation\n  - See [SKILL-TEMPLATES.md](SKILL-TEMPLATES.md) for mangling details\n- **`ppx_simd`**: SIMD shuffle/blend mask generation\n\n### SIMD Libraries\n\n- **`ocaml_simd`**: Base SIMD types\n- **`ocaml_simd_sse`**: SSE intrinsics (128-bit)\n- **`ocaml_simd_avx`**: AVX/AVX2 intrinsics (256-bit)\n- See [SKILL-SIMD.md](SKILL-SIMD.md) for usage details\n"
      },
      "plugins": [
        {
          "name": "ocaml-dev",
          "source": "./plugins/ocaml-dev",
          "description": "Comprehensive OCaml development toolkit with project setup, build migration, testing, RFC integration, opam publishing, and code style assistance",
          "version": "1.0.0",
          "author": {
            "name": "Anil Madhavapeddy",
            "email": "anil@recoil.org"
          },
          "category": "development",
          "homepage": "https://github.com/avsm/ocaml-claude-marketplace",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add avsm/ocaml-claude-marketplace",
            "/plugin install ocaml-dev@ocaml-claude-marketplace"
          ]
        }
      ]
    }
  ]
}