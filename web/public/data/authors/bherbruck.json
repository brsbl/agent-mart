{
  "author": {
    "id": "bherbruck",
    "display_name": "bherbruck",
    "avatar_url": "https://avatars.githubusercontent.com/u/5258126?u=5c3a2a887f59e2bd401b5b223472816efee02f67&v=4"
  },
  "marketplaces": [
    {
      "name": "mcp-debugger",
      "version": null,
      "description": "Multi-language debugging via DAP - debug Python, JavaScript/TypeScript, Go, and Rust",
      "repo_full_name": "bherbruck/mcp-debugger",
      "repo_url": "https://github.com/bherbruck/mcp-debugger",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-02-20T17:02:35Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"mcp-debugger\",\n  \"owner\": {\n    \"name\": \"MCP Debugger Team\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"mcp-debugger\",\n      \"source\": \"./\",\n      \"description\": \"Multi-language debugging via DAP - debug Python, JavaScript/TypeScript, Go, and Rust\",\n      \"version\": \"1.1.3\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"mcp-debugger\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Multi-language debugging plugin for Claude Code using Debug Adapter Protocol. Debug JavaScript/TypeScript, Python, Go, and Rust with real breakpoints, stepping, and variable inspection.\",\n  \"author\": {\n    \"name\": \"bherbruck\"\n  },\n  \"homepage\": \"https://github.com/bherbruck/mcp-debugger\",\n  \"repository\": \"https://github.com/bherbruck/mcp-debugger\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"debugger\",\n    \"dap\",\n    \"debug-adapter-protocol\",\n    \"python\",\n    \"javascript\",\n    \"typescript\",\n    \"go\",\n    \"rust\",\n    \"breakpoints\",\n    \"debugging\"\n  ],\n  \"commands\": [\n    \"./commands/debug.md\",\n    \"./commands/breakpoint.md\",\n    \"./commands/step.md\"\n  ],\n  \"agents\": [\n    \"./agents/debug-assistant.md\"\n  ],\n  \"skills\": [\n    \"./skills/debugging-guide.md\"\n  ],\n  \"mcpServers\": \"./.mcp.json\"\n}",
        "README.md": "# MCP Debugger\n\n**A Claude Code plugin that enables fully autonomous debugging — coding agents pause programs, step through execution, inspect locals, and compare expected vs actual values using real debuggers. No human intervention. No log statements.**\n\nThis is a **game changer** for AI-assisted development. Claude autonomously investigates bugs by debugging itself, finding discrepancies between expected and actual runtime state. It works today.\n\n## Why This Exists\n\nTraditional AI debugging means:\n- Stop execution\n- Edit code to add debug logs\n- Adjust log levels\n- Rerun the program\n- Parse log spam\n- Repeat\n\n**This wastes tokens, time, and iteration cycles.**\n\n**MCP Debugger eliminates all of that.**\n\nNo debug logs. No log levels. No reruns. No code edits. Claude pauses your running program, inspects the actual state, and tells you what's wrong — in one shot.\n\n**Result**: Faster debugging, fewer tokens spent on log spam, and no polluted git diffs from print statements.\n\n## What Makes This Different\n\n- ✓ **Fully Autonomous**: Claude decides when to debug, sets breakpoints, and investigates without human prompting\n- ✓ **Real DAP Backends**: Uses production debuggers (debugpy, vscode-js-debug, Delve, CodeLLDB), not mocks or interpreters\n- ✓ **Expanded Locals**: Inspects full object trees, compares expected vs actual values\n- ✓ **Multi-Language**: Same autonomous debugging across Python, JavaScript/TypeScript, Go, and Rust\n\nThis isn't \"AI explains stack traces\" or \"human-directed debugging\" — it's **autonomous runtime investigation**.\n\n**Claude debugs itself. No human intervention required.**\n\n## Language Support\n\nFully functional with real debugger backends:\n\n- **Python** — debugpy\n- **JavaScript / TypeScript** — vscode-js-debug\n- **Go** — Delve\n- **Rust** — CodeLLDB\n\nDebug adapters auto-install on first use.\n\n## How It Works\n\n```\nClaude Code → MCP Protocol → mcp-debugger → DAP → Runtime Debugger\n                                                    ↓\n                                              Your Program (paused)\n```\n\n1. Claude detects something might be wrong (test failure, unexpected behavior, etc.)\n2. Claude autonomously decides to debug instead of guessing\n3. Breakpoints are set, program runs\n4. Claude inspects locals, compares expected vs actual values\n5. Claude identifies the discrepancy and fixes the bug\n\n**Fully autonomous** — Claude invokes debugging tools on its own when investigating issues.\n\n## Installation\n\nIn Claude Code:\n\n1. Use `/plugin` to open the plugin manager\n2. Add the registry: `bherbruck/mcp-debugger`\n3. Install the `mcp-debugger` plugin\n\nThat's it. Claude autonomously uses it when investigating issues — no commands needed.\n\n**Optional**: Add to your `CLAUDE.md` to encourage autonomous debugging over print statements:\n\n```markdown\n## Debugging\n\nUse the mcp-debugger plugin for debugging instead of adding print/log statements.\nSet breakpoints and inspect variables using real debuggers.\n```\n\n**Requirements**: Language runtimes for what you want to debug (Python 3.7+, Node.js 18+, Go 1.18+, Rust). Debug adapters install automatically on first use.\n\n## Concrete Example\n\n**Scenario**: A test fails. Expected return value, got None instead.\n\n**Claude** (autonomously): *Test failure detected. Instead of guessing or adding logs, I'll debug this to see what's actually happening at runtime.*\n\n```\n[Claude creates debug session, sets breakpoint at process_orders(), runs code]\n\nPaused at line 47 in process_orders()\n\nStack frame:\n  process_orders() → validate_items() → calculate_total()\n\nExpanded locals at breakpoint:\n  orders = [\n    Order(id=1, items=[...], total=150.00, status='pending'),\n    Order(id=2, items=[], total=0.00, status='pending'),  ← suspicious\n    Order(id=3, items=[...], total=200.00, status='pending')\n  ]\n  valid_orders = []\n\n[Claude steps into validate_items(), inspects]\n\nFound it: Order #2 has an empty items list. The function returns None\nwhen items is empty instead of raising an exception or returning an\nempty result.\n\nThe bug is in line 52 — it returns early without a value when\nlen(order.items) == 0.\n\n[Claude fixes the bug to return an empty result instead of None]\n```\n\n**Claude found and fixed this autonomously.** No log statements added. No human debugging. Just runtime inspection, expected vs actual comparison, and a fix.\n\n## Who This Is For\n\n- **Autonomous coding agents** that need to debug themselves without human intervention\n- **Developers who want agents to investigate and fix bugs independently**\n- **Anyone building with AI agents** who's tired of log-based debugging cycles\n\nThis is agent-first debugging. **Claude investigates, debugs, and fixes autonomously.**\n\n## Scope & Safety\n\n**Intended for**: Local development and debugging environments\n**Not intended for**: Production runtime debugging (yet)\n**Agent capabilities**: Inspect state, set breakpoints, evaluate expressions\n**Agent limitations**: Cannot modify code through the debugger\n\nMCP Debugger gives agents read-only runtime inspection. It's designed for dev environments where pausing execution is safe.\n\n**Known limitations**: Rust multithreaded debugging behaves like a regular VS Code debugger — cross-thread symbol resolution can be limited. This is a CodeLLDB/DAP limitation, not specific to MCP Debugger.\n\n## Available Tools\n\nClaude has access to these debugging capabilities (invoked automatically):\n\n**Session Management**: `create_debug_session`, `start_debugging`, `terminate_session`, `list_sessions`\n**Breakpoints**: `set_breakpoint`, `remove_breakpoint`, `list_breakpoints`\n**Execution Control**: `continue`, `pause`, `step_in`, `step_over`, `step_out`\n**Inspection**: `get_stack_trace`, `get_variables`, `expand_variable`, `evaluate_expression`, `get_source_context`\n\nYou don't call these directly — Claude chooses when to use them.\n\n## Development & Architecture\n\n**Build**: `npm install && npm run build`\n**Test**: `npm test`\n**Watch**: `npm run dev`\n\nArchitecture layers:\n1. **MCP Server** (`src/server.ts`) — Routes tool calls from Claude Code to handlers\n2. **Session Manager** (`src/session/`) — Manages debug session lifecycle and state machine\n3. **DAP Client** (`src/dap/`) — Implements Debug Adapter Protocol, handles message parsing\n4. **Adapters** (`src/adapters/`) — Language-specific debugger implementations (Python, JS/TS, Go, Rust)\n\nSee [CLAUDE.md](CLAUDE.md) for detailed architecture notes.\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "mcp-debugger",
          "source": "./",
          "description": "Multi-language debugging via DAP - debug Python, JavaScript/TypeScript, Go, and Rust",
          "version": "1.1.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add bherbruck/mcp-debugger",
            "/plugin install mcp-debugger@mcp-debugger"
          ]
        }
      ]
    }
  ]
}