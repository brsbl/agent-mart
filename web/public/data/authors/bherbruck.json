{
  "author": {
    "id": "bherbruck",
    "display_name": "bherbruck",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/5258126?u=5c3a2a887f59e2bd401b5b223472816efee02f67&v=4",
    "url": "https://github.com/bherbruck",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 0,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "mcp-debugger",
      "version": null,
      "description": "Multi-language debugging via DAP - debug Python, JavaScript/TypeScript, Go, and Rust",
      "owner_info": {
        "name": "MCP Debugger Team"
      },
      "keywords": [],
      "repo_full_name": "bherbruck/mcp-debugger",
      "repo_url": "https://github.com/bherbruck/mcp-debugger",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-27T19:38:15Z",
        "created_at": "2025-12-31T02:38:29Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 297
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 866
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6492
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/debug-assistant.md",
          "type": "blob",
          "size": 4720
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/breakpoint.md",
          "type": "blob",
          "size": 1497
        },
        {
          "path": "commands/debug.md",
          "type": "blob",
          "size": 1901
        },
        {
          "path": "commands/step.md",
          "type": "blob",
          "size": 1115
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/debugging-guide.md",
          "type": "blob",
          "size": 8002
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"mcp-debugger\",\n  \"owner\": {\n    \"name\": \"MCP Debugger Team\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"mcp-debugger\",\n      \"source\": \"./\",\n      \"description\": \"Multi-language debugging via DAP - debug Python, JavaScript/TypeScript, Go, and Rust\",\n      \"version\": \"1.1.3\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"mcp-debugger\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Multi-language debugging plugin for Claude Code using Debug Adapter Protocol. Debug JavaScript/TypeScript, Python, Go, and Rust with real breakpoints, stepping, and variable inspection.\",\n  \"author\": {\n    \"name\": \"bherbruck\"\n  },\n  \"homepage\": \"https://github.com/bherbruck/mcp-debugger\",\n  \"repository\": \"https://github.com/bherbruck/mcp-debugger\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"debugger\",\n    \"dap\",\n    \"debug-adapter-protocol\",\n    \"python\",\n    \"javascript\",\n    \"typescript\",\n    \"go\",\n    \"rust\",\n    \"breakpoints\",\n    \"debugging\"\n  ],\n  \"commands\": [\n    \"./commands/debug.md\",\n    \"./commands/breakpoint.md\",\n    \"./commands/step.md\"\n  ],\n  \"agents\": [\n    \"./agents/debug-assistant.md\"\n  ],\n  \"skills\": [\n    \"./skills/debugging-guide.md\"\n  ],\n  \"mcpServers\": \"./.mcp.json\"\n}",
        "README.md": "# MCP Debugger\n\n**A Claude Code plugin that enables fully autonomous debugging — coding agents pause programs, step through execution, inspect locals, and compare expected vs actual values using real debuggers. No human intervention. No log statements.**\n\nThis is a **game changer** for AI-assisted development. Claude autonomously investigates bugs by debugging itself, finding discrepancies between expected and actual runtime state. It works today.\n\n## Why This Exists\n\nTraditional AI debugging means:\n- Stop execution\n- Edit code to add debug logs\n- Adjust log levels\n- Rerun the program\n- Parse log spam\n- Repeat\n\n**This wastes tokens, time, and iteration cycles.**\n\n**MCP Debugger eliminates all of that.**\n\nNo debug logs. No log levels. No reruns. No code edits. Claude pauses your running program, inspects the actual state, and tells you what's wrong — in one shot.\n\n**Result**: Faster debugging, fewer tokens spent on log spam, and no polluted git diffs from print statements.\n\n## What Makes This Different\n\n- ✓ **Fully Autonomous**: Claude decides when to debug, sets breakpoints, and investigates without human prompting\n- ✓ **Real DAP Backends**: Uses production debuggers (debugpy, vscode-js-debug, Delve, CodeLLDB), not mocks or interpreters\n- ✓ **Expanded Locals**: Inspects full object trees, compares expected vs actual values\n- ✓ **Multi-Language**: Same autonomous debugging across Python, JavaScript/TypeScript, Go, and Rust\n\nThis isn't \"AI explains stack traces\" or \"human-directed debugging\" — it's **autonomous runtime investigation**.\n\n**Claude debugs itself. No human intervention required.**\n\n## Language Support\n\nFully functional with real debugger backends:\n\n- **Python** — debugpy\n- **JavaScript / TypeScript** — vscode-js-debug\n- **Go** — Delve\n- **Rust** — CodeLLDB\n\nDebug adapters auto-install on first use.\n\n## How It Works\n\n```\nClaude Code → MCP Protocol → mcp-debugger → DAP → Runtime Debugger\n                                                    ↓\n                                              Your Program (paused)\n```\n\n1. Claude detects something might be wrong (test failure, unexpected behavior, etc.)\n2. Claude autonomously decides to debug instead of guessing\n3. Breakpoints are set, program runs\n4. Claude inspects locals, compares expected vs actual values\n5. Claude identifies the discrepancy and fixes the bug\n\n**Fully autonomous** — Claude invokes debugging tools on its own when investigating issues.\n\n## Installation\n\nIn Claude Code:\n\n1. Use `/plugin` to open the plugin manager\n2. Add the registry: `bherbruck/mcp-debugger`\n3. Install the `mcp-debugger` plugin\n\nThat's it. Claude autonomously uses it when investigating issues — no commands needed.\n\n**Optional**: Add to your `CLAUDE.md` to encourage autonomous debugging over print statements:\n\n```markdown\n## Debugging\n\nUse the mcp-debugger plugin for debugging instead of adding print/log statements.\nSet breakpoints and inspect variables using real debuggers.\n```\n\n**Requirements**: Language runtimes for what you want to debug (Python 3.7+, Node.js 18+, Go 1.18+, Rust). Debug adapters install automatically on first use.\n\n## Concrete Example\n\n**Scenario**: A test fails. Expected return value, got None instead.\n\n**Claude** (autonomously): *Test failure detected. Instead of guessing or adding logs, I'll debug this to see what's actually happening at runtime.*\n\n```\n[Claude creates debug session, sets breakpoint at process_orders(), runs code]\n\nPaused at line 47 in process_orders()\n\nStack frame:\n  process_orders() → validate_items() → calculate_total()\n\nExpanded locals at breakpoint:\n  orders = [\n    Order(id=1, items=[...], total=150.00, status='pending'),\n    Order(id=2, items=[], total=0.00, status='pending'),  ← suspicious\n    Order(id=3, items=[...], total=200.00, status='pending')\n  ]\n  valid_orders = []\n\n[Claude steps into validate_items(), inspects]\n\nFound it: Order #2 has an empty items list. The function returns None\nwhen items is empty instead of raising an exception or returning an\nempty result.\n\nThe bug is in line 52 — it returns early without a value when\nlen(order.items) == 0.\n\n[Claude fixes the bug to return an empty result instead of None]\n```\n\n**Claude found and fixed this autonomously.** No log statements added. No human debugging. Just runtime inspection, expected vs actual comparison, and a fix.\n\n## Who This Is For\n\n- **Autonomous coding agents** that need to debug themselves without human intervention\n- **Developers who want agents to investigate and fix bugs independently**\n- **Anyone building with AI agents** who's tired of log-based debugging cycles\n\nThis is agent-first debugging. **Claude investigates, debugs, and fixes autonomously.**\n\n## Scope & Safety\n\n**Intended for**: Local development and debugging environments\n**Not intended for**: Production runtime debugging (yet)\n**Agent capabilities**: Inspect state, set breakpoints, evaluate expressions\n**Agent limitations**: Cannot modify code through the debugger\n\nMCP Debugger gives agents read-only runtime inspection. It's designed for dev environments where pausing execution is safe.\n\n**Known limitations**: Rust multithreaded debugging behaves like a regular VS Code debugger — cross-thread symbol resolution can be limited. This is a CodeLLDB/DAP limitation, not specific to MCP Debugger.\n\n## Available Tools\n\nClaude has access to these debugging capabilities (invoked automatically):\n\n**Session Management**: `create_debug_session`, `start_debugging`, `terminate_session`, `list_sessions`\n**Breakpoints**: `set_breakpoint`, `remove_breakpoint`, `list_breakpoints`\n**Execution Control**: `continue`, `pause`, `step_in`, `step_over`, `step_out`\n**Inspection**: `get_stack_trace`, `get_variables`, `expand_variable`, `evaluate_expression`, `get_source_context`\n\nYou don't call these directly — Claude chooses when to use them.\n\n## Development & Architecture\n\n**Build**: `npm install && npm run build`\n**Test**: `npm test`\n**Watch**: `npm run dev`\n\nArchitecture layers:\n1. **MCP Server** (`src/server.ts`) — Routes tool calls from Claude Code to handlers\n2. **Session Manager** (`src/session/`) — Manages debug session lifecycle and state machine\n3. **DAP Client** (`src/dap/`) — Implements Debug Adapter Protocol, handles message parsing\n4. **Adapters** (`src/adapters/`) — Language-specific debugger implementations (Python, JS/TS, Go, Rust)\n\nSee [CLAUDE.md](CLAUDE.md) for detailed architecture notes.\n\n## License\n\nMIT\n",
        "agents/debug-assistant.md": "---\nname: debug-assistant\ndescription: |\n  Use this agent when debugging code, investigating bugs, or needing to understand program behavior at runtime.\n\n  <example>\n  user: \"Help me debug this Python script that's returning wrong values\"\n  assistant: \"I'll use the debug-assistant to set breakpoints and step through the code\"\n  <commentary>User needs to investigate runtime behavior - perfect for debugger</commentary>\n  </example>\n\n  <example>\n  user: \"Why is my function returning null?\"\n  assistant: \"Let me debug this and inspect the variables at runtime\"\n  <commentary>Investigating unexpected values requires stepping through code</commentary>\n  </example>\n\n  <example>\n  user: \"Step through this loop and show me what's happening\"\n  assistant: \"I'll set a breakpoint in the loop and examine each iteration\"\n  <commentary>Explicit request for debugging workflow</commentary>\n  </example>\nmodel: sonnet\ncolor: red\n---\n\n# Debug Assistant\n\n**CRITICAL**: The MCP debugger tools are ALREADY AVAILABLE to you. Do NOT:\n- Search for .mcp.json files\n- Look in ~/.claude/ for configuration\n- Use Glob/Grep/Search to find how to use the debugger\n- Read config files\n\nJust CALL THE TOOLS DIRECTLY. Start with `create_debug_session(language)`.\n\n---\n\nYou are an expert debugging assistant with deep knowledge of debugging techniques and runtime analysis. Your role is to help users debug their code using real debuggers via the MCP debugger tools.\n\n## Your Capabilities\n\n1. **Multi-Language Support**: Debug Python, JavaScript/TypeScript, Go, and Rust\n2. **Real Debugging**: Use actual debuggers (debugpy, vscode-js-debug, Delve, CodeLLDB)\n3. **Breakpoint Management**: Set, remove, and manage breakpoints including conditional ones\n4. **Execution Control**: Step through code line by line (step in, over, out)\n5. **Variable Inspection**: Examine variable values, expand objects, evaluate expressions\n6. **Stack Analysis**: View call stacks and navigate between frames\n\n## Debugging Workflow\n\n### 1. Understand the Problem\n- Ask what behavior is unexpected\n- Identify the relevant code files\n- Determine where to set initial breakpoints\n\n### 2. Set Up Session\n```\n1. create_debug_session(language=\"python|javascript|go|rust\")\n2. set_breakpoint(sessionId, file, line) - set strategic breakpoints\n3. start_debugging(sessionId, scriptPath)\n```\n\n### 3. Investigate at Breakpoints\nWhen the program stops:\n```\n1. get_source_context(sessionId) - see where we are\n2. get_variables(sessionId) - check variable values\n3. get_stack_trace(sessionId) - understand call path\n4. evaluate_expression(sessionId, expr) - test hypotheses\n```\n\n### 4. Navigate Execution\n- `step_over` - execute current line, move to next\n- `step_in` - enter function calls to inspect them\n- `step_out` - finish current function, return to caller\n- `continue` - run until next breakpoint\n\n### 5. Identify the Bug\n- Compare expected vs actual variable values\n- Look for null/undefined where values expected\n- Check loop conditions and counters\n- Examine function arguments and return values\n\n### 6. Clean Up\n```\nterminate_session(sessionId)\n```\n\n## Debugging Strategies\n\n### Finding Where a Value Goes Wrong\n1. Set breakpoint before the suspicious code\n2. Check variable values - are they what you expect?\n3. Step through line by line\n4. When a value changes unexpectedly, you found the issue\n\n### Debugging Loops\n1. Set breakpoint inside the loop\n2. Add a condition like `i == 50` to skip early iterations\n3. Watch loop counter and accumulated values\n4. Check exit conditions\n\n### Debugging Function Calls\n1. Set breakpoint at function entry\n2. Check input arguments\n3. Step through the logic\n4. Verify return value before returning\n\n### Debugging Async Code\n1. Set breakpoints in callbacks/handlers\n2. Check Promise states\n3. Verify async function completions\n4. Watch for race conditions\n\n## Best Practices\n\n- **Explain what you observe** - Help users understand the program state\n- **Form hypotheses** - Suggest what might be wrong based on observations\n- **Use evaluation** - Test ideas with `evaluate_expression` before modifying code\n- **Track changes** - Note when variable values change\n- **Consider edge cases** - Check boundary conditions, empty arrays, null values\n- **Clean up sessions** - Always terminate when done\n\n## Language-Specific Tips\n\n### Python\n- Check for `None` values\n- Watch for mutable default arguments\n- Examine exception handlers\n\n### JavaScript/TypeScript\n- Check for `undefined` vs `null`\n- Watch for async/await issues\n- Examine closure scopes\n\n### Go\n- Check for nil pointers\n- Watch goroutine states\n- Examine channel operations\n\n### Rust\n- Check ownership transfers\n- Watch for unwrap() panics\n- Examine Option/Result handling\n",
        "commands/breakpoint.md": "---\nname: breakpoint\ndescription: Manage breakpoints in a debug session\narguments:\n  - name: action\n    description: \"Action to perform: add, remove, or list\"\n    required: true\n  - name: file\n    description: File path (for add/remove)\n    required: false\n  - name: line\n    description: Line number (for add/remove)\n    required: false\n  - name: condition\n    description: Conditional expression (for add)\n    required: false\n---\n\n# Breakpoint Management\n\nManaging breakpoints: **$ARGUMENTS.action**\n\n## Actions\n\n### Add a Breakpoint\nIf action is \"add\":\n1. Ensure there's an active debug session\n2. Use `set_breakpoint` with the file and line\n3. If a condition was provided, include it as a conditional breakpoint\n4. Report whether the breakpoint was verified\n\n### Remove a Breakpoint\nIf action is \"remove\":\n1. Use `remove_breakpoint` with the file and line\n2. Confirm removal\n\n### List All Breakpoints\nIf action is \"list\":\n1. Use `list_breakpoints` to get all breakpoints\n2. Display them in a clear table format:\n   - File path\n   - Line number\n   - Verified status\n   - Condition (if any)\n\n## Conditional Breakpoints\n\nYou can add conditions that must be true for the breakpoint to trigger:\n- `x > 10` - Break when x exceeds 10\n- `name == \"error\"` - Break when name equals \"error\"\n- `items.length > 100` - Break when list is large\n\n## Hit Count Conditions\n\nUse hitCondition to break after a certain number of hits:\n- `>5` - Break after more than 5 hits\n- `==10` - Break on exactly the 10th hit\n",
        "commands/debug.md": "---\nname: debug\ndescription: Start a debugging session for a file with real breakpoints and stepping\narguments:\n  - name: file\n    description: Path to the file to debug\n    required: true\n  - name: line\n    description: Optional line number for initial breakpoint\n    required: false\n---\n\n# Debug Session\n\nThe MCP debugger tools are ALREADY AVAILABLE. Do NOT search for .mcp.json or config files. Just call the tools directly.\n\nI'll help you debug `$ARGUMENTS.file` using the MCP debugger.\n\n## Instructions\n\n1. **Detect Language**: First, determine the programming language from the file extension:\n   - `.py` → Python (uses debugpy)\n   - `.js`, `.ts`, `.mjs`, `.tsx` → JavaScript/TypeScript (uses vscode-js-debug)\n   - `.go` → Go (uses Delve)\n   - `.rs` → Rust (uses CodeLLDB)\n\n2. **Create Session**: Use `create_debug_session` with the detected language\n\n3. **Set Breakpoints**: If a line number was provided, use `set_breakpoint` to add an initial breakpoint. Otherwise, suggest strategic breakpoints based on the code.\n\n4. **Start Debugging**: Use `start_debugging` with the script path\n\n5. **When Stopped**: When the program pauses at a breakpoint:\n   - Use `get_source_context` to show the code around current location\n   - Use `get_variables` to display local variables\n   - Use `get_stack_trace` to show the call stack\n   - Explain what the code is doing at this point\n\n6. **Interactive Debugging**:\n   - Ask if the user wants to step (in/over/out), continue, or inspect something\n   - Use `evaluate_expression` to test hypotheses about variable values\n   - Use `expand_variable` to drill into complex objects\n\n7. **Cleanup**: When done, use `terminate_session` to clean up\n\n## Tips\n\n- Set breakpoints before where you expect the issue to occur\n- Compare expected vs actual variable values\n- Watch for null/undefined values or unexpected types\n- Check loop counters and array indices\n",
        "commands/step.md": "---\nname: step\ndescription: Step through code in a debug session\narguments:\n  - name: direction\n    description: \"Step direction: in, over, or out\"\n    required: true\n---\n\n# Step Through Code\n\nStepping **$ARGUMENTS.direction** in the current debug session.\n\n## Step Directions\n\n### step in\nUse `step_in` to:\n- Enter the next function call\n- Go into library code if needed\n- Useful when you want to understand what a function does\n\n### step over\nUse `step_over` to:\n- Execute the current line completely\n- Move to the next line without entering function calls\n- Most common stepping action\n\n### step out\nUse `step_out` to:\n- Complete the current function\n- Return to the caller\n- Useful when you've seen enough of the current function\n\n## After Each Step\n\n1. Use `get_source_context` to show where we are now\n2. Use `get_variables` to see current variable values\n3. Highlight any changes from the previous state\n4. Explain what just happened\n\n## Continue Execution\n\nIf you want to run until the next breakpoint instead of stepping:\n- Use `continue` to resume normal execution\n- Use `pause` to interrupt running code\n",
        "skills/debugging-guide.md": "---\nname: debugging-guide\ndescription: Comprehensive guide to using the MCP debugger for debugging Python, JavaScript, TypeScript, Go, and Rust code. Provides patterns, strategies, and best practices for effective debugging.\n---\n\n# MCP Debugger Guide\n\n## IMPORTANT: The tools are already available\n\nThe MCP debugger tools are ALREADY AVAILABLE to you. Do NOT:\n- Search for .mcp.json files\n- Look in ~/.claude/ for configuration\n- Use Glob/Grep/Search to find \"how to use\" the debugger\n- Read config files to understand the tools\n\nJust CALL THE TOOLS DIRECTLY. They work. Start with `create_debug_session(language)`.\n\n---\n\nA comprehensive guide to debugging code with the MCP debugger.\n\n## Quick Start\n\n### Python\n```\n1. create_debug_session(language=\"python\")\n2. set_breakpoint(sessionId, file=\"/path/to/script.py\", line=10)\n3. start_debugging(sessionId, scriptPath=\"/path/to/script.py\")\n4. [Program pauses at line 10]\n5. get_variables(sessionId) → see local variables\n6. step_over(sessionId) → go to next line\n```\n\n### JavaScript/TypeScript\n```\n1. create_debug_session(language=\"javascript\")\n2. set_breakpoint(sessionId, file=\"/path/to/app.js\", line=25)\n3. start_debugging(sessionId, scriptPath=\"/path/to/app.js\")\n```\n\n### Go\n```\n1. create_debug_session(language=\"go\")\n2. set_breakpoint(sessionId, file=\"/path/to/main.go\", line=15)\n3. start_debugging(sessionId, scriptPath=\"/path/to/main.go\")\n```\n\n### Rust\n```\n1. create_debug_session(language=\"rust\")\n2. set_breakpoint(sessionId, file=\"/path/to/main.rs\", line=20)\n3. start_debugging(sessionId, scriptPath=\"/path/to/project\")\n```\n\n## Core Debugging Patterns\n\n### Pattern 1: Finding Where a Value Goes Wrong\n1. Set breakpoint before the suspected mutation\n2. Use `step_over` to advance line by line\n3. Check `get_variables` after each step\n4. When value changes unexpectedly, you found the bug\n\n### Pattern 2: Understanding Function Behavior\n1. Set breakpoint at function entry\n2. Check arguments with `get_variables`\n3. Step through the logic\n4. Evaluate return value before return\n\n### Pattern 3: Debugging Loops\n1. Set conditional breakpoint: `set_breakpoint(sessionId, file, line, condition=\"i == 100\")`\n2. Check loop state when condition triggers\n3. Verify accumulator values\n4. Check exit conditions\n\n### Pattern 4: Inspecting Complex Objects\n1. `get_variables` returns `variablesReference` for objects\n2. Use `expand_variable(sessionId, variablesReference)` to see properties\n3. Keep expanding to drill into nested structures\n\n### Pattern 5: Testing Hypotheses\nUse `evaluate_expression` to test ideas without modifying code:\n```\nevaluate_expression(sessionId, \"len(items)\")\nevaluate_expression(sessionId, \"user.permissions.includes('admin')\")\nevaluate_expression(sessionId, \"x * 2 + y\")\n```\n\n## Conditional Breakpoints\n\nSet breakpoints that only trigger under specific conditions:\n\n### Value Conditions\n```\nset_breakpoint(sessionId, file, line, condition=\"x > 10\")\nset_breakpoint(sessionId, file, line, condition=\"name == 'error'\")\nset_breakpoint(sessionId, file, line, condition=\"items.length > 100\")\n```\n\n### Hit Count Conditions\n```\nset_breakpoint(sessionId, file, line, hitCondition=\">5\")  # After 5 hits\nset_breakpoint(sessionId, file, line, hitCondition=\"==10\") # Exactly 10th hit\n```\n\n## Stepping Strategies\n\n### When to Use Each Step Type\n\n| Step Type | Use When |\n|-----------|----------|\n| `step_over` | You want to execute the line without entering functions |\n| `step_in` | You want to see what happens inside a function call |\n| `step_out` | You're done with the current function and want to return |\n| `continue` | You want to run until the next breakpoint |\n\n### Efficient Stepping\n1. Set a breakpoint past repetitive code\n2. Use `continue` to skip to it\n3. Then step through the important parts\n\n## Variable Inspection\n\n### Getting All Variables\n```\nget_variables(sessionId)                    # All scopes\nget_variables(sessionId, scope=\"local\")     # Just local variables\nget_variables(sessionId, scope=\"global\")    # Just globals\n```\n\n### Inspecting Specific Frames\n```\nget_stack_trace(sessionId)                  # Get frame IDs\nget_variables(sessionId, frameId=2)         # Variables in frame 2\n```\n\n### Expanding Objects\n```\nvariables = get_variables(sessionId)\n# If variable has variablesReference > 0:\nchildren = expand_variable(sessionId, variablesReference)\n```\n\n## Language-Specific Notes\n\n### Python\n- **Debugger**: debugpy (auto-installed via pip)\n- **Virtual Environments**: Specify `executablePath` in create_debug_session\n- **Async**: Full async/await debugging support\n- **Jupyter**: Not directly supported (use script files)\n\n### JavaScript/TypeScript\n- **Debugger**: vscode-js-debug (auto-installed)\n- **Node.js**: Full Node.js debugging\n- **TypeScript**: Automatically handles source maps\n- **ESM**: Supports ES modules\n\n### Go\n- **Debugger**: Delve (dlv, auto-installed via go install)\n- **Optimization**: Builds with `-gcflags=\"all=-N -l\"` for debugging\n- **Goroutines**: Full goroutine inspection\n- **CGO**: Supported\n\n### Rust\n- **Debugger**: CodeLLDB (auto-installed)\n- **Cargo**: Automatically builds debug targets\n- **LLDB**: Full LLDB features available\n- **Pretty Printing**: Standard library types displayed nicely\n\n## Troubleshooting\n\n### Breakpoint Not Hitting\n1. Check file path is correct (use absolute paths)\n2. Verify line number has executable code\n3. Ensure program execution reaches that code path\n4. Check if breakpoint is verified (`verified: true`)\n\n### Variables Not Showing\n1. Ensure program is paused (not running)\n2. Check you're in the right stack frame\n3. Some variables may be optimized out\n\n### Adapter Not Starting\n1. Check language runtime is installed (Python, Node.js, Go, Rust)\n2. Verify PATH includes the runtime\n3. Try specifying `executablePath` explicitly\n\n### Session Errors\n1. Check `list_sessions()` for session state\n2. Terminate stuck sessions with `terminate_session`\n3. Create a fresh session\n\n### Multithreaded/Async App Issues\nDebugging heavily multithreaded apps (tokio, mio, epoll) can be unstable:\n\n**Symptoms:**\n- `Invalid frame reference` errors\n- `sbframe object is not valid`\n- `Invalid thread_id` errors\n- Session dies unexpectedly\n\n**Solutions:**\n1. **Run single-threaded for debugging** (most reliable):\n   ```rust\n   // Temporarily use single-threaded runtime\n   #[tokio::main(flavor = \"current_thread\")]\n   ```\n   Or set thread count to 1 via config/env var if your app supports it.\n\n2. **Set breakpoints in sync code** - not hot async handlers\n\n3. **Always call `get_stack_trace` first** - before `get_variables` or `evaluate_expression`\n\n4. **Add a debug sleep** in the handler to stabilize:\n   ```rust\n   std::thread::sleep(std::time::Duration::from_millis(100));\n   ```\n\n5. **Use conditional breakpoints** to reduce how often breakpoints fire\n\nThis is a limitation of debugging async/threaded code, not specific to mcp-debugger.\n\n## Best Practices\n\n1. **Set Strategic Breakpoints**: Place them just before where you expect issues\n2. **Use Conditional Breakpoints**: Skip uninteresting iterations\n3. **Evaluate Before Modifying**: Test fixes with `evaluate_expression` first\n4. **Clean Up Sessions**: Always terminate when done\n5. **Read the Stack**: The call stack tells you how you got here\n6. **Compare Expected vs Actual**: The gap reveals the bug\n\n## Debugging Servers and Long-Running Programs\n\nWhen debugging servers (HTTP, MQTT, WebSocket, etc.) that wait for connections:\n\n1. Start the server under debugger with breakpoints set\n2. **Use Bash to trigger the breakpoint yourself** - don't ask the user to do it\n3. Then check the debugger state\n\nExample for an HTTP server:\n```\n1. start_debugging(sessionId, \"/path/to/server\")  → server running\n2. Bash(\"curl http://localhost:8080/api/endpoint\")  → triggers breakpoint\n3. get_stack_trace(sessionId)  → now paused at handler\n4. get_variables(sessionId)  → inspect the request\n```\n\nThe debugger does NOT block other tools. You can run Bash commands while the program is running.\n"
      },
      "plugins": [
        {
          "name": "mcp-debugger",
          "source": "./",
          "description": "Multi-language debugging via DAP - debug Python, JavaScript/TypeScript, Go, and Rust",
          "version": "1.1.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add bherbruck/mcp-debugger",
            "/plugin install mcp-debugger@mcp-debugger"
          ]
        }
      ]
    }
  ]
}