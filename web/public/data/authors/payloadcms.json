{
  "author": {
    "id": "payloadcms",
    "display_name": "Payload",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/62968818?v=4",
    "url": "https://github.com/payloadcms",
    "bio": "Headless CMS and Application Framework",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 40246,
      "total_forks": 3319
    }
  },
  "marketplaces": [
    {
      "name": "payload-marketplace",
      "version": "0.0.1",
      "description": "Development marketplace for Payload",
      "owner_info": {
        "name": "Payload",
        "email": "info@payloadcms.com"
      },
      "keywords": [],
      "repo_full_name": "payloadcms/payload",
      "repo_url": "https://github.com/payloadcms/payload",
      "repo_description": "Payload is the open-source, fullstack Next.js framework, giving you instant backend superpowers. Get a full TypeScript backend and admin panel instantly. Use Payload as a headless CMS or for building powerful applications.",
      "homepage": "https://payloadcms.com",
      "signals": {
        "stars": 40246,
        "forks": 3319,
        "pushed_at": "2026-01-29T23:01:12Z",
        "created_at": "2021-01-05T18:49:45Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 542
        },
        {
          "path": "tools",
          "type": "tree",
          "size": null
        },
        {
          "path": "tools/claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "tools/claude-plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "tools/claude-plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 513
        },
        {
          "path": "tools/claude-plugin/README.md",
          "type": "blob",
          "size": 2454
        },
        {
          "path": "tools/claude-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "tools/claude-plugin/skills/payload",
          "type": "tree",
          "size": null
        },
        {
          "path": "tools/claude-plugin/skills/payload/SKILL.md",
          "type": "blob",
          "size": 15345
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/ACCESS-CONTROL-ADVANCED.md",
          "type": "blob",
          "size": 17993
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/ACCESS-CONTROL.md",
          "type": "blob",
          "size": 18343
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/ADAPTERS.md",
          "type": "blob",
          "size": 7437
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/ADVANCED.md",
          "type": "blob",
          "size": 9009
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/COLLECTIONS.md",
          "type": "blob",
          "size": 6000
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/ENDPOINTS.md",
          "type": "blob",
          "size": 15435
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/FIELD-TYPE-GUARDS.md",
          "type": "blob",
          "size": 10900
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/FIELDS.md",
          "type": "blob",
          "size": 17544
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/HOOKS.md",
          "type": "blob",
          "size": 4345
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/PLUGIN-DEVELOPMENT.md",
          "type": "blob",
          "size": 35287
        },
        {
          "path": "tools/claude-plugin/skills/payload/reference/QUERIES.md",
          "type": "blob",
          "size": 6097
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"payload-marketplace\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Development marketplace for Payload\",\n  \"owner\": {\n    \"name\": \"Payload\",\n    \"email\": \"info@payloadcms.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"payload\",\n      \"description\": \"Payload Development plugin - covers collections, fields, hooks, access control, plugins, and database adapters.\",\n      \"version\": \"0.0.1\",\n      \"source\": \"./tools/claude-plugin\",\n      \"author\": {\n        \"name\": \"Payload\",\n        \"email\": \"info@payloadcms.com\"\n      }\n    }\n  ]\n}\n",
        "tools/claude-plugin/.claude-plugin/plugin.json": "{\n  \"name\": \"payload\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Payload Development plugin - covers collections, fields, hooks, access control, plugins, and database adapters.\",\n  \"author\": {\n    \"name\": \"Payload\",\n    \"email\": \"info@payloadcms.com\",\n    \"url\": \"https://payloadcms.com\"\n  },\n  \"homepage\": \"https://github.com/payloadcms/payload\",\n  \"repository\": \"https://github.com/payloadcms/payload\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"payload\", \"cms\", \"payload-cms\", \"nextjs\", \"typescript\", \"headless-cms\"]\n}\n",
        "tools/claude-plugin/README.md": "# Payload Skill for Claude Code\n\nClaude Code skill providing comprehensive guidance for Payload development with TypeScript patterns, field configurations, hooks, access control, and API examples.\n\n## Installation\n\n### From GitHub\n\nInstall this skill directly from the Payload repository:\n\n```bash\n/plugin install github:payloadcms/payload\n```\n\n## What's Included\n\nThe `payload` skill provides expert guidance on:\n\n- **Collections**: Auth, uploads, drafts, live preview configurations\n- **Fields**: All field types including relationships, arrays, blocks, joins, virtual fields\n- **Hooks**: beforeChange, afterChange, beforeValidate, field hooks\n- **Access Control**: Collection, field, and global access patterns including RBAC and multi-tenant\n- **Queries**: Local API, REST, and GraphQL with complex operators\n- **Database Adapters**: MongoDB, Postgres, SQLite configurations and transactions\n- **Advanced Features**: Jobs queue, custom endpoints, localization, plugins\n\n## Usage\n\nOnce installed, Claude will automatically invoke the skill when you're working on Payload CMS projects. The skill activates when you:\n\n- Edit `payload.config.ts` files\n- Work with collection or global configurations\n- Ask about Payload-specific patterns\n- Need guidance on fields, hooks, or access control\n\nYou can also explicitly invoke it:\n\n```\n@payload how do I implement row-level access control?\n```\n\n## Documentation Structure\n\n```\nskills/payload/\n├── SKILL.md                              # Main skill file with quick reference\n└── reference/\n    ├── FIELDS.md                         # All field types and configurations\n    ├── COLLECTIONS.md                    # Collection patterns\n    ├── HOOKS.md                          # Hook patterns and examples\n    ├── ACCESS-CONTROL.md                 # Basic access control\n    ├── ACCESS-CONTROL-ADVANCED.md        # Advanced access patterns\n    ├── QUERIES.md                        # Query patterns and APIs\n    ├── ADAPTERS.md                       # Database and storage adapters\n    └── ADVANCED.md                       # Jobs, endpoints, localization\n```\n\n## Resources\n\n- [Payload Documentation](https://payloadcms.com/docs)\n- [GitHub Repository](https://github.com/payloadcms/payload)\n- [Examples](https://github.com/payloadcms/payload/tree/main/examples)\n- [Templates](https://github.com/payloadcms/payload/tree/main/templates)\n\n## License\n\nMIT\n",
        "tools/claude-plugin/skills/payload/SKILL.md": "---\nname: payload\ndescription: Use when working with Payload CMS projects (payload.config.ts, collections, fields, hooks, access control, Payload API). Use when debugging validation errors, security issues, relationship queries, transactions, or hook behavior.\n---\n\n# Payload CMS Application Development\n\nPayload is a Next.js native CMS with TypeScript-first architecture, providing admin panel, database management, REST/GraphQL APIs, authentication, and file storage.\n\n## Quick Reference\n\n| Task                     | Solution                                  | Details                                                                                                                          |\n| ------------------------ | ----------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |\n| Auto-generate slugs      | `slugField()`                             | [FIELDS.md#slug-field-helper](reference/FIELDS.md#slug-field-helper)                                                             |\n| Restrict content by user | Access control with query                 | [ACCESS-CONTROL.md#row-level-security-with-complex-queries](reference/ACCESS-CONTROL.md#row-level-security-with-complex-queries) |\n| Local API user ops       | `user` + `overrideAccess: false`          | [QUERIES.md#access-control-in-local-api](reference/QUERIES.md#access-control-in-local-api)                                       |\n| Draft/publish workflow   | `versions: { drafts: true }`              | [COLLECTIONS.md#versioning--drafts](reference/COLLECTIONS.md#versioning--drafts)                                                 |\n| Computed fields          | `virtual: true` with afterRead            | [FIELDS.md#virtual-fields](reference/FIELDS.md#virtual-fields)                                                                   |\n| Conditional fields       | `admin.condition`                         | [FIELDS.md#conditional-fields](reference/FIELDS.md#conditional-fields)                                                           |\n| Custom field validation  | `validate` function                       | [FIELDS.md#validation](reference/FIELDS.md#validation)                                                                           |\n| Filter relationship list | `filterOptions` on field                  | [FIELDS.md#relationship](reference/FIELDS.md#relationship)                                                                       |\n| Select specific fields   | `select` parameter                        | [QUERIES.md#field-selection](reference/QUERIES.md#field-selection)                                                               |\n| Auto-set author/dates    | beforeChange hook                         | [HOOKS.md#collection-hooks](reference/HOOKS.md#collection-hooks)                                                                 |\n| Prevent hook loops       | `req.context` check                       | [HOOKS.md#context](reference/HOOKS.md#context)                                                                                   |\n| Cascading deletes        | beforeDelete hook                         | [HOOKS.md#collection-hooks](reference/HOOKS.md#collection-hooks)                                                                 |\n| Geospatial queries       | `point` field with `near`/`within`        | [FIELDS.md#point-geolocation](reference/FIELDS.md#point-geolocation)                                                             |\n| Reverse relationships    | `join` field type                         | [FIELDS.md#join-fields](reference/FIELDS.md#join-fields)                                                                         |\n| Next.js revalidation     | Context control in afterChange            | [HOOKS.md#nextjs-revalidation-with-context-control](reference/HOOKS.md#nextjs-revalidation-with-context-control)                 |\n| Query by relationship    | Nested property syntax                    | [QUERIES.md#nested-properties](reference/QUERIES.md#nested-properties)                                                           |\n| Complex queries          | AND/OR logic                              | [QUERIES.md#andor-logic](reference/QUERIES.md#andor-logic)                                                                       |\n| Transactions             | Pass `req` to operations                  | [ADAPTERS.md#threading-req-through-operations](reference/ADAPTERS.md#threading-req-through-operations)                           |\n| Background jobs          | Jobs queue with tasks                     | [ADVANCED.md#jobs-queue](reference/ADVANCED.md#jobs-queue)                                                                       |\n| Custom API routes        | Collection custom endpoints               | [ADVANCED.md#custom-endpoints](reference/ADVANCED.md#custom-endpoints)                                                           |\n| Cloud storage            | Storage adapter plugins                   | [ADAPTERS.md#storage-adapters](reference/ADAPTERS.md#storage-adapters)                                                           |\n| Multi-language           | `localization` config + `localized: true` | [ADVANCED.md#localization](reference/ADVANCED.md#localization)                                                                   |\n| Create plugin            | `(options) => (config) => Config`         | [PLUGIN-DEVELOPMENT.md#plugin-architecture](reference/PLUGIN-DEVELOPMENT.md#plugin-architecture)                                 |\n| Plugin package setup     | Package structure with SWC                | [PLUGIN-DEVELOPMENT.md#plugin-package-structure](reference/PLUGIN-DEVELOPMENT.md#plugin-package-structure)                       |\n| Add fields to collection | Map collections, spread fields            | [PLUGIN-DEVELOPMENT.md#adding-fields-to-collections](reference/PLUGIN-DEVELOPMENT.md#adding-fields-to-collections)               |\n| Plugin hooks             | Preserve existing hooks in array          | [PLUGIN-DEVELOPMENT.md#adding-hooks](reference/PLUGIN-DEVELOPMENT.md#adding-hooks)                                               |\n| Check field type         | Type guard functions                      | [FIELD-TYPE-GUARDS.md](reference/FIELD-TYPE-GUARDS.md)                                                                           |\n\n## Quick Start\n\n```bash\nnpx create-payload-app@latest my-app\ncd my-app\npnpm dev\n```\n\n### Minimal Config\n\n```ts\nimport { buildConfig } from 'payload'\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nexport default buildConfig({\n  admin: {\n    user: 'users',\n    importMap: {\n      baseDir: path.resolve(dirname),\n    },\n  },\n  collections: [Users, Media],\n  editor: lexicalEditor(),\n  secret: process.env.PAYLOAD_SECRET,\n  typescript: {\n    outputFile: path.resolve(dirname, 'payload-types.ts'),\n  },\n  db: mongooseAdapter({\n    url: process.env.DATABASE_URL,\n  }),\n})\n```\n\n## Essential Patterns\n\n### Basic Collection\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  admin: {\n    useAsTitle: 'title',\n    defaultColumns: ['title', 'author', 'status', 'createdAt'],\n  },\n  fields: [\n    { name: 'title', type: 'text', required: true },\n    { name: 'slug', type: 'text', unique: true, index: true },\n    { name: 'content', type: 'richText' },\n    { name: 'author', type: 'relationship', relationTo: 'users' },\n  ],\n  timestamps: true,\n}\n```\n\nFor more collection patterns (auth, upload, drafts, live preview), see [COLLECTIONS.md](reference/COLLECTIONS.md).\n\n### Common Fields\n\n```ts\n// Text field\n{ name: 'title', type: 'text', required: true }\n\n// Relationship\n{ name: 'author', type: 'relationship', relationTo: 'users', required: true }\n\n// Rich text\n{ name: 'content', type: 'richText', required: true }\n\n// Select\n{ name: 'status', type: 'select', options: ['draft', 'published'], defaultValue: 'draft' }\n\n// Upload\n{ name: 'image', type: 'upload', relationTo: 'media' }\n```\n\nFor all field types (array, blocks, point, join, virtual, conditional, etc.), see [FIELDS.md](reference/FIELDS.md).\n\n### Hook Example\n\n```ts\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  hooks: {\n    beforeChange: [\n      async ({ data, operation }) => {\n        if (operation === 'create') {\n          data.slug = slugify(data.title)\n        }\n        return data\n      },\n    ],\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\nFor all hook patterns, see [HOOKS.md](reference/HOOKS.md). For access control, see [ACCESS-CONTROL.md](reference/ACCESS-CONTROL.md).\n\n### Access Control with Type Safety\n\n```ts\nimport type { Access } from 'payload'\nimport type { User } from '@/payload-types'\n\n// Type-safe access control\nexport const adminOnly: Access = ({ req }) => {\n  const user = req.user as User\n  return user?.roles?.includes('admin') || false\n}\n\n// Row-level access control\nexport const ownPostsOnly: Access = ({ req }) => {\n  const user = req.user as User\n  if (!user) return false\n  if (user.roles?.includes('admin')) return true\n\n  return {\n    author: { equals: user.id },\n  }\n}\n```\n\n### Query Example\n\n```ts\n// Local API\nconst posts = await payload.find({\n  collection: 'posts',\n  where: {\n    status: { equals: 'published' },\n    'author.name': { contains: 'john' },\n  },\n  depth: 2,\n  limit: 10,\n  sort: '-createdAt',\n})\n\n// Query with populated relationships\nconst post = await payload.findByID({\n  collection: 'posts',\n  id: '123',\n  depth: 2, // Populates relationships (default is 2)\n})\n// Returns: { author: { id: \"user123\", name: \"John\" } }\n\n// Without depth, relationships return IDs only\nconst post = await payload.findByID({\n  collection: 'posts',\n  id: '123',\n  depth: 0,\n})\n// Returns: { author: \"user123\" }\n```\n\nFor all query operators and REST/GraphQL examples, see [QUERIES.md](reference/QUERIES.md).\n\n### Getting Payload Instance\n\n```ts\n// In API routes (Next.js)\nimport { getPayload } from 'payload'\nimport config from '@payload-config'\n\nexport async function GET() {\n  const payload = await getPayload({ config })\n\n  const posts = await payload.find({\n    collection: 'posts',\n  })\n\n  return Response.json(posts)\n}\n\n// In Server Components\nimport { getPayload } from 'payload'\nimport config from '@payload-config'\n\nexport default async function Page() {\n  const payload = await getPayload({ config })\n  const { docs } = await payload.find({ collection: 'posts' })\n\n  return <div>{docs.map(post => <h1 key={post.id}>{post.title}</h1>)}</div>\n}\n```\n\n## Security Pitfalls\n\n### 1. Local API Access Control (CRITICAL)\n\n**By default, Local API operations bypass ALL access control**, even when passing a user.\n\n```ts\n// ❌ SECURITY BUG: Passes user but ignores their permissions\nawait payload.find({\n  collection: 'posts',\n  user: someUser, // Access control is BYPASSED!\n})\n\n// ✅ SECURE: Actually enforces the user's permissions\nawait payload.find({\n  collection: 'posts',\n  user: someUser,\n  overrideAccess: false, // REQUIRED for access control\n})\n```\n\n**When to use each:**\n\n- `overrideAccess: true` (default) - Server-side operations you trust (cron jobs, system tasks)\n- `overrideAccess: false` - When operating on behalf of a user (API routes, webhooks)\n\nSee [QUERIES.md#access-control-in-local-api](reference/QUERIES.md#access-control-in-local-api).\n\n### 2. Transaction Failures in Hooks\n\n**Nested operations in hooks without `req` break transaction atomicity.**\n\n```ts\n// ❌ DATA CORRUPTION RISK: Separate transaction\nhooks: {\n  afterChange: [\n    async ({ doc, req }) => {\n      await req.payload.create({\n        collection: 'audit-log',\n        data: { docId: doc.id },\n        // Missing req - runs in separate transaction!\n      })\n    },\n  ]\n}\n\n// ✅ ATOMIC: Same transaction\nhooks: {\n  afterChange: [\n    async ({ doc, req }) => {\n      await req.payload.create({\n        collection: 'audit-log',\n        data: { docId: doc.id },\n        req, // Maintains atomicity\n      })\n    },\n  ]\n}\n```\n\nSee [ADAPTERS.md#threading-req-through-operations](reference/ADAPTERS.md#threading-req-through-operations).\n\n### 3. Infinite Hook Loops\n\n**Hooks triggering operations that trigger the same hooks create infinite loops.**\n\n```ts\n// ❌ INFINITE LOOP\nhooks: {\n  afterChange: [\n    async ({ doc, req }) => {\n      await req.payload.update({\n        collection: 'posts',\n        id: doc.id,\n        data: { views: doc.views + 1 },\n        req,\n      }) // Triggers afterChange again!\n    },\n  ]\n}\n\n// ✅ SAFE: Use context flag\nhooks: {\n  afterChange: [\n    async ({ doc, req, context }) => {\n      if (context.skipHooks) return\n\n      await req.payload.update({\n        collection: 'posts',\n        id: doc.id,\n        data: { views: doc.views + 1 },\n        context: { skipHooks: true },\n        req,\n      })\n    },\n  ]\n}\n```\n\nSee [HOOKS.md#context](reference/HOOKS.md#context).\n\n## Project Structure\n\n```txt\nsrc/\n├── app/\n│   ├── (frontend)/\n│   │   └── page.tsx\n│   └── (payload)/\n│       └── admin/[[...segments]]/page.tsx\n├── collections/\n│   ├── Posts.ts\n│   ├── Media.ts\n│   └── Users.ts\n├── globals/\n│   └── Header.ts\n├── components/\n│   └── CustomField.tsx\n├── hooks/\n│   └── slugify.ts\n└── payload.config.ts\n```\n\n## Type Generation\n\n```ts\n// payload.config.ts\nexport default buildConfig({\n  typescript: {\n    outputFile: path.resolve(dirname, 'payload-types.ts'),\n  },\n  // ...\n})\n\n// Usage\nimport type { Post, User } from '@/payload-types'\n```\n\n## Reference Documentation\n\n- **[FIELDS.md](reference/FIELDS.md)** - All field types, validation, admin options\n- **[FIELD-TYPE-GUARDS.md](reference/FIELD-TYPE-GUARDS.md)** - Type guards for runtime field type checking and narrowing\n- **[COLLECTIONS.md](reference/COLLECTIONS.md)** - Collection configs, auth, upload, drafts, live preview\n- **[HOOKS.md](reference/HOOKS.md)** - Collection hooks, field hooks, context patterns\n- **[ACCESS-CONTROL.md](reference/ACCESS-CONTROL.md)** - Collection, field, global access control, RBAC, multi-tenant\n- **[ACCESS-CONTROL-ADVANCED.md](reference/ACCESS-CONTROL-ADVANCED.md)** - Context-aware, time-based, subscription-based access, factory functions, templates\n- **[QUERIES.md](reference/QUERIES.md)** - Query operators, Local/REST/GraphQL APIs\n- **[ENDPOINTS.md](reference/ENDPOINTS.md)** - Custom API endpoints: authentication, helpers, request/response patterns\n- **[ADAPTERS.md](reference/ADAPTERS.md)** - Database, storage, email adapters, transactions\n- **[ADVANCED.md](reference/ADVANCED.md)** - Authentication, jobs, endpoints, components, plugins, localization\n- **[PLUGIN-DEVELOPMENT.md](reference/PLUGIN-DEVELOPMENT.md)** - Plugin architecture, monorepo structure, patterns, best practices\n\n## Resources\n\n- llms-full.txt: <https://payloadcms.com/llms-full.txt>\n- Docs: <https://payloadcms.com/docs>\n- GitHub: <https://github.com/payloadcms/payload>\n- Examples: <https://github.com/payloadcms/payload/tree/main/examples>\n- Templates: <https://github.com/payloadcms/payload/tree/main/templates>\n",
        "tools/claude-plugin/skills/payload/reference/ACCESS-CONTROL-ADVANCED.md": "# Payload CMS Access Control - Advanced Patterns\n\nAdvanced access control patterns including context-aware access, time-based restrictions, factory functions, and production templates.\n\n## Context-Aware Access Patterns\n\n### Locale-Specific Access\n\nControl access based on user locale for internationalized content.\n\n```ts\nimport type { Access } from 'payload'\n\nexport const localeSpecificAccess: Access = ({ req: { user, locale } }) => {\n  // Authenticated users can access all locales\n  if (user) return true\n\n  // Public users can only access English content\n  if (locale === 'en') return true\n\n  return false\n}\n\n// Usage in collection\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  access: {\n    read: localeSpecificAccess,\n  },\n  fields: [{ name: 'title', type: 'text', localized: true }],\n}\n```\n\n**Source**: `docs/access-control/overview.mdx` (req.locale argument)\n\n### Device-Specific Access\n\nRestrict access based on device type or user agent.\n\n```ts\nimport type { Access } from 'payload'\n\nexport const mobileOnlyAccess: Access = ({ req: { headers } }) => {\n  const userAgent = headers?.get('user-agent') || ''\n  return /mobile|android|iphone/i.test(userAgent)\n}\n\nexport const desktopOnlyAccess: Access = ({ req: { headers } }) => {\n  const userAgent = headers?.get('user-agent') || ''\n  return !/mobile|android|iphone/i.test(userAgent)\n}\n\n// Usage\nexport const MobileContent: CollectionConfig = {\n  slug: 'mobile-content',\n  access: {\n    read: mobileOnlyAccess,\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\n**Source**: Synthesized (headers pattern)\n\n### IP-Based Access\n\nRestrict access from specific IP addresses (requires middleware/proxy headers).\n\n```ts\nimport type { Access } from 'payload'\n\nexport const restrictedIpAccess = (allowedIps: string[]): Access => {\n  return ({ req: { headers } }) => {\n    const ip = headers?.get('x-forwarded-for') || headers?.get('x-real-ip')\n    return allowedIps.includes(ip || '')\n  }\n}\n\n// Usage\nconst internalIps = ['192.168.1.0/24', '10.0.0.5']\n\nexport const InternalDocs: CollectionConfig = {\n  slug: 'internal-docs',\n  access: {\n    read: restrictedIpAccess(internalIps),\n  },\n  fields: [{ name: 'content', type: 'richText' }],\n}\n```\n\n**Note**: Requires your server to pass IP address via headers (common with proxies/load balancers).\n\n**Source**: Synthesized (headers pattern)\n\n## Time-Based Access Patterns\n\n### Today's Records Only\n\n```ts\nimport type { Access } from 'payload'\n\nexport const todayOnlyAccess: Access = ({ req: { user } }) => {\n  if (!user) return false\n\n  const now = new Date()\n  const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate())\n  const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000)\n\n  return {\n    createdAt: {\n      greater_than_equal: startOfDay.toISOString(),\n      less_than: endOfDay.toISOString(),\n    },\n  }\n}\n```\n\n**Source**: `test/access-control/config.ts` (query constraint patterns)\n\n### Recent Records (Last N Days)\n\n```ts\nimport type { Access } from 'payload'\n\nexport const recentRecordsAccess = (days: number): Access => {\n  return ({ req: { user } }) => {\n    if (!user) return false\n    if (user.roles?.includes('admin')) return true\n\n    const cutoff = new Date()\n    cutoff.setDate(cutoff.getDate() - days)\n\n    return {\n      createdAt: {\n        greater_than_equal: cutoff.toISOString(),\n      },\n    }\n  }\n}\n\n// Usage: Users see only last 30 days, admins see all\nexport const Logs: CollectionConfig = {\n  slug: 'logs',\n  access: {\n    read: recentRecordsAccess(30),\n  },\n  fields: [{ name: 'message', type: 'text' }],\n}\n```\n\n### Scheduled Content (Publish Date Range)\n\n```ts\nimport type { Access } from 'payload'\n\nexport const scheduledContentAccess: Access = ({ req: { user } }) => {\n  // Editors see all content\n  if (user?.roles?.includes('admin') || user?.roles?.includes('editor')) {\n    return true\n  }\n\n  const now = new Date().toISOString()\n\n  // Public sees only content within publish window\n  return {\n    and: [\n      { publishDate: { less_than_equal: now } },\n      {\n        or: [{ unpublishDate: { exists: false } }, { unpublishDate: { greater_than: now } }],\n      },\n    ],\n  }\n}\n```\n\n**Source**: Synthesized (query constraint + date patterns)\n\n## Subscription-Based Access\n\n### Active Subscription Required\n\n```ts\nimport type { Access } from 'payload'\n\nexport const activeSubscriptionAccess: Access = async ({ req: { user } }) => {\n  if (!user) return false\n  if (user.roles?.includes('admin')) return true\n\n  try {\n    const subscription = await req.payload.findByID({\n      collection: 'subscriptions',\n      id: user.subscriptionId,\n    })\n\n    return subscription?.status === 'active'\n  } catch {\n    return false\n  }\n}\n\n// Usage\nexport const PremiumContent: CollectionConfig = {\n  slug: 'premium-content',\n  access: {\n    read: activeSubscriptionAccess,\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\n### Subscription Tier-Based Access\n\n```ts\nimport type { Access } from 'payload'\n\nexport const tierBasedAccess = (requiredTier: string): Access => {\n  const tierHierarchy = ['free', 'basic', 'pro', 'enterprise']\n\n  return async ({ req: { user } }) => {\n    if (!user) return false\n    if (user.roles?.includes('admin')) return true\n\n    try {\n      const subscription = await req.payload.findByID({\n        collection: 'subscriptions',\n        id: user.subscriptionId,\n      })\n\n      if (subscription?.status !== 'active') return false\n\n      const userTierIndex = tierHierarchy.indexOf(subscription.tier)\n      const requiredTierIndex = tierHierarchy.indexOf(requiredTier)\n\n      return userTierIndex >= requiredTierIndex\n    } catch {\n      return false\n    }\n  }\n}\n\n// Usage\nexport const EnterpriseFeatures: CollectionConfig = {\n  slug: 'enterprise-features',\n  access: {\n    read: tierBasedAccess('enterprise'),\n  },\n  fields: [{ name: 'feature', type: 'text' }],\n}\n```\n\n**Source**: Synthesized (async + cross-collection pattern)\n\n## Factory Functions\n\nReusable functions that generate access control configurations.\n\n### createRoleBasedAccess\n\nGenerate access control for specific roles.\n\n```ts\nimport type { Access } from 'payload'\n\nexport function createRoleBasedAccess(roles: string[]): Access {\n  return ({ req: { user } }) => {\n    if (!user) return false\n    return roles.some((role) => user.roles?.includes(role))\n  }\n}\n\n// Usage\nconst adminOrEditor = createRoleBasedAccess(['admin', 'editor'])\nconst moderatorAccess = createRoleBasedAccess(['admin', 'moderator'])\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  access: {\n    create: adminOrEditor,\n    update: adminOrEditor,\n    delete: moderatorAccess,\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\n**Source**: `test/access-control/config.ts`\n\n### createOrgScopedAccess\n\nGenerate organization-scoped access with optional admin bypass.\n\n```ts\nimport type { Access } from 'payload'\n\nexport function createOrgScopedAccess(allowAdmin = true): Access {\n  return ({ req: { user } }) => {\n    if (!user) return false\n    if (allowAdmin && user.roles?.includes('admin')) return true\n\n    return {\n      organizationId: { in: user.organizationIds || [] },\n    }\n  }\n}\n\n// Usage\nconst orgScoped = createOrgScopedAccess() // Admins bypass\nconst strictOrgScoped = createOrgScopedAccess(false) // Admins also scoped\n\nexport const Projects: CollectionConfig = {\n  slug: 'projects',\n  access: {\n    read: orgScoped,\n    update: orgScoped,\n    delete: strictOrgScoped,\n  },\n  fields: [\n    { name: 'title', type: 'text' },\n    { name: 'organizationId', type: 'text', required: true },\n  ],\n}\n```\n\n**Source**: `test/access-control/config.ts`\n\n### createTeamBasedAccess\n\nGenerate team-scoped access with configurable field name.\n\n```ts\nimport type { Access } from 'payload'\n\nexport function createTeamBasedAccess(teamField = 'teamId'): Access {\n  return ({ req: { user } }) => {\n    if (!user) return false\n    if (user.roles?.includes('admin')) return true\n\n    return {\n      [teamField]: { in: user.teamIds || [] },\n    }\n  }\n}\n\n// Usage with custom field name\nconst projectTeamAccess = createTeamBasedAccess('projectTeam')\n\nexport const Tasks: CollectionConfig = {\n  slug: 'tasks',\n  access: {\n    read: projectTeamAccess,\n    update: projectTeamAccess,\n  },\n  fields: [\n    { name: 'title', type: 'text' },\n    { name: 'projectTeam', type: 'text', required: true },\n  ],\n}\n```\n\n**Source**: Synthesized (org pattern variation)\n\n### createTimeLimitedAccess\n\nGenerate access limited to records within specified days.\n\n```ts\nimport type { Access } from 'payload'\n\nexport function createTimeLimitedAccess(daysAccess: number): Access {\n  return ({ req: { user } }) => {\n    if (!user) return false\n    if (user.roles?.includes('admin')) return true\n\n    const cutoff = new Date()\n    cutoff.setDate(cutoff.getDate() - daysAccess)\n\n    return {\n      createdAt: {\n        greater_than_equal: cutoff.toISOString(),\n      },\n    }\n  }\n}\n\n// Usage: Users see 90 days, admins see all\nexport const ActivityLogs: CollectionConfig = {\n  slug: 'activity-logs',\n  access: {\n    read: createTimeLimitedAccess(90),\n  },\n  fields: [{ name: 'action', type: 'text' }],\n}\n```\n\n**Source**: Synthesized (time + query pattern)\n\n## Configuration Templates\n\nComplete collection configurations for common scenarios.\n\n### Basic Authenticated Collection\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const BasicCollection: CollectionConfig = {\n  slug: 'basic-collection',\n  access: {\n    create: ({ req: { user } }) => Boolean(user),\n    read: ({ req: { user } }) => Boolean(user),\n    update: ({ req: { user } }) => Boolean(user),\n    delete: ({ req: { user } }) => Boolean(user),\n  },\n  fields: [\n    { name: 'title', type: 'text', required: true },\n    { name: 'content', type: 'richText' },\n  ],\n}\n```\n\n**Source**: `docs/access-control/collections.mdx`\n\n### Public + Authenticated Collection\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const PublicAuthCollection: CollectionConfig = {\n  slug: 'posts',\n  access: {\n    // Only admins/editors can create\n    create: ({ req: { user } }) => {\n      return user?.roles?.some((role) => ['admin', 'editor'].includes(role)) || false\n    },\n\n    // Authenticated users see all, public sees only published\n    read: ({ req: { user } }) => {\n      if (user) return true\n      return { _status: { equals: 'published' } }\n    },\n\n    // Only admins/editors can update\n    update: ({ req: { user } }) => {\n      return user?.roles?.some((role) => ['admin', 'editor'].includes(role)) || false\n    },\n\n    // Only admins can delete\n    delete: ({ req: { user } }) => {\n      return user?.roles?.includes('admin') || false\n    },\n  },\n  versions: {\n    drafts: true,\n  },\n  fields: [\n    { name: 'title', type: 'text', required: true },\n    { name: 'content', type: 'richText', required: true },\n    { name: 'author', type: 'relationship', relationTo: 'users' },\n  ],\n}\n```\n\n**Source**: `templates/website/src/collections/Posts/index.ts`\n\n### Multi-User/Self-Service Collection\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const SelfServiceCollection: CollectionConfig = {\n  slug: 'users',\n  auth: true,\n  access: {\n    // Admins can create users\n    create: ({ req: { user } }) => user?.roles?.includes('admin') || false,\n\n    // Anyone can read user profiles\n    read: () => true,\n\n    // Users can update self, admins can update anyone\n    update: ({ req: { user }, id }) => {\n      if (!user) return false\n      if (user.roles?.includes('admin')) return true\n      return user.id === id\n    },\n\n    // Only admins can delete\n    delete: ({ req: { user } }) => user?.roles?.includes('admin') || false,\n  },\n  fields: [\n    { name: 'name', type: 'text', required: true },\n    { name: 'email', type: 'email', required: true },\n    {\n      name: 'roles',\n      type: 'select',\n      hasMany: true,\n      options: ['admin', 'editor', 'user'],\n      access: {\n        // Only admins can read/update roles\n        read: ({ req: { user } }) => user?.roles?.includes('admin') || false,\n        update: ({ req: { user } }) => user?.roles?.includes('admin') || false,\n      },\n    },\n  ],\n}\n```\n\n**Source**: `templates/website/src/collections/Users/index.ts`\n\n## Debugging Tips\n\n### Log Access Check Execution\n\n```ts\nexport const debugAccess: Access = ({ req: { user }, id }) => {\n  console.log('Access check:', {\n    userId: user?.id,\n    userRoles: user?.roles,\n    docId: id,\n    timestamp: new Date().toISOString(),\n  })\n  return true\n}\n```\n\n### Verify Arguments Availability\n\n```ts\nexport const checkArgsAccess: Access = (args) => {\n  console.log('Available arguments:', {\n    hasReq: 'req' in args,\n    hasUser: args.req?.user ? 'yes' : 'no',\n    hasId: args.id ? 'provided' : 'undefined',\n    hasData: args.data ? 'provided' : 'undefined',\n  })\n  return true\n}\n```\n\n### Measure Async Operation Timing\n\n```ts\nexport const timedAsyncAccess: Access = async ({ req }) => {\n  const start = Date.now()\n\n  const result = await fetch('https://auth-service.example.com/validate', {\n    headers: { userId: req.user?.id },\n  })\n\n  console.log(`Access check took ${Date.now() - start}ms`)\n\n  return result.ok\n}\n```\n\n### Test Access Without User\n\n```ts\n// In test/development\nconst testAccess = await payload.find({\n  collection: 'posts',\n  overrideAccess: false, // Enforce access control\n  user: undefined, // Simulate no user\n})\n\nconsole.log('Public access result:', testAccess.docs.length)\n```\n\n**Source**: Synthesized (debugging best practices)\n\n## Performance Considerations\n\n### Async Operations Impact\n\n```ts\n// ❌ Slow: Multiple sequential async calls\nexport const slowAccess: Access = async ({ req: { user } }) => {\n  const org = await req.payload.findByID({ collection: 'orgs', id: user.orgId })\n  const team = await req.payload.findByID({ collection: 'teams', id: user.teamId })\n  const subscription = await req.payload.findByID({ collection: 'subs', id: user.subId })\n\n  return org.active && team.active && subscription.active\n}\n\n// ✅ Fast: Use query constraints or cache in context\nexport const fastAccess: Access = ({ req: { user, context } }) => {\n  // Cache expensive lookups\n  if (!context.orgStatus) {\n    context.orgStatus = checkOrgStatus(user.orgId)\n  }\n\n  return context.orgStatus\n}\n```\n\n### Query Constraint Optimization\n\n```ts\n// ❌ Avoid: Non-indexed fields in constraints\nexport const slowQuery: Access = () => ({\n  'metadata.internalCode': { equals: 'ABC123' }, // Slow if not indexed\n})\n\n// ✅ Better: Use indexed fields\nexport const fastQuery: Access = () => ({\n  status: { equals: 'active' }, // Indexed field\n  organizationId: { in: ['org1', 'org2'] }, // Indexed field\n})\n```\n\n### Field Access on Large Arrays\n\n```ts\n// ❌ Slow: Complex access on array fields\nconst arrayField: ArrayField = {\n  name: 'items',\n  type: 'array',\n  fields: [\n    {\n      name: 'secretData',\n      type: 'text',\n      access: {\n        read: async ({ req }) => {\n          // Async call runs for EVERY array item\n          const result = await expensiveCheck()\n          return result\n        },\n      },\n    },\n  ],\n}\n\n// ✅ Fast: Simple checks or cache result\nconst optimizedArrayField: ArrayField = {\n  name: 'items',\n  type: 'array',\n  fields: [\n    {\n      name: 'secretData',\n      type: 'text',\n      access: {\n        read: ({ req: { user }, context }) => {\n          // Cache once, reuse for all items\n          if (context.canReadSecret === undefined) {\n            context.canReadSecret = user?.roles?.includes('admin')\n          }\n          return context.canReadSecret\n        },\n      },\n    },\n  ],\n}\n```\n\n### Avoid N+1 Queries\n\n```ts\n// ❌ N+1 Problem: Query per access check\nexport const n1Access: Access = async ({ req, id }) => {\n  // Runs for EACH document in list\n  const doc = await req.payload.findByID({ collection: 'docs', id })\n  return doc.isPublic\n}\n\n// ✅ Better: Use query constraint to filter at DB level\nexport const efficientAccess: Access = () => {\n  return { isPublic: { equals: true } }\n}\n```\n\n**Performance Best Practices:**\n\n1. **Minimize Async Operations**: Use query constraints over async lookups when possible\n2. **Cache Expensive Checks**: Store results in `req.context` for reuse\n3. **Index Query Fields**: Ensure fields in query constraints are indexed\n4. **Avoid Complex Logic in Array Fields**: Simple boolean checks preferred\n5. **Use Query Constraints**: Let database filter rather than loading all records\n\n**Source**: Synthesized (operational best practices)\n\n## Enhanced Best Practices\n\nComprehensive security and implementation guidelines:\n\n1. **Default Deny**: Start with restrictive access, gradually add permissions\n2. **Type Guards**: Use TypeScript for user type safety and better IDE support\n3. **Validate Data**: Never trust frontend-provided IDs or data\n4. **Async for Critical Checks**: Use async operations for important security decisions\n5. **Consistent Logic**: Apply same rules at field and collection levels\n6. **Test Edge Cases**: Test with no user, wrong user, admin user scenarios\n7. **Monitor Access**: Log failed access attempts for security review\n8. **Regular Audit**: Review access rules quarterly or after major changes\n9. **Cache Wisely**: Use `req.context` for expensive operations\n10. **Document Intent**: Add comments explaining complex access rules\n11. **Avoid Secrets in Client**: Never expose sensitive logic to client-side\n12. **Rate Limit External Calls**: Protect against DoS on external validation services\n13. **Handle Errors Gracefully**: Access functions should return `false` on error, not throw\n14. **Use Environment Vars**: Store configuration (IPs, API keys) in env vars\n15. **Test Local API**: Remember to set `overrideAccess: false` when testing\n16. **Consider Performance**: Measure impact of async operations on login time\n17. **Version Control**: Track access control changes in git history\n18. **Principle of Least Privilege**: Grant minimum access required for functionality\n\n**Sources**: `docs/access-control/*.mdx`, synthesized best practices\n",
        "tools/claude-plugin/skills/payload/reference/ACCESS-CONTROL.md": "# Payload CMS Access Control Reference\n\nComplete reference for access control patterns across collections, fields, and globals.\n\n## At a Glance\n\n| Feature               | Scope                                                     | Returns                | Use Case                           |\n| --------------------- | --------------------------------------------------------- | ---------------------- | ---------------------------------- |\n| **Collection Access** | create, read, update, delete, admin, unlock, readVersions | boolean \\| Where query | Document-level permissions         |\n| **Field Access**      | create, read, update                                      | boolean only           | Field-level visibility/editability |\n| **Global Access**     | read, update, readVersions                                | boolean \\| Where query | Global document permissions        |\n\n## Three Layers of Access Control\n\nPayload provides three distinct access control layers:\n\n1. **Collection-Level**: Controls operations on entire documents (create, read, update, delete, admin, unlock, readVersions)\n2. **Field-Level**: Controls access to individual fields (create, read, update)\n3. **Global-Level**: Controls access to global documents (read, update, readVersions)\n\n## Return Value Types\n\nAccess control functions can return:\n\n- **Boolean**: `true` (allow) or `false` (deny)\n- **Query Constraint**: `Where` object for row-level security (collection-level only)\n\nField-level access does NOT support query constraints - only boolean returns.\n\n## Operation Decision Tree\n\n```txt\nUser makes request\n    │\n    ├─ Collection access check\n    │   ├─ Returns false? → Deny entire operation\n    │   ├─ Returns true? → Continue\n    │   └─ Returns Where? → Apply query constraint\n    │\n    ├─ Field access check (if applicable)\n    │   ├─ Returns false? → Field omitted from result\n    │   └─ Returns true? → Include field\n    │\n    └─ Operation completed\n```\n\n## Collection Access Control\n\n### Basic Patterns\n\n```ts\nimport type { CollectionConfig, Access } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  access: {\n    // Boolean: Only authenticated users can create\n    create: ({ req: { user } }) => Boolean(user),\n\n    // Query constraint: Public sees published, users see all\n    read: ({ req: { user } }) => {\n      if (user) return true\n      return { status: { equals: 'published' } }\n    },\n\n    // User-specific: Admins or document owner\n    update: ({ req: { user }, id }) => {\n      if (user?.roles?.includes('admin')) return true\n      return { author: { equals: user?.id } }\n    },\n\n    // Async: Check related data\n    delete: async ({ req, id }) => {\n      const hasComments = await req.payload.count({\n        collection: 'comments',\n        where: { post: { equals: id } },\n      })\n      return hasComments === 0\n    },\n\n    // Admin panel visibility\n    admin: ({ req: { user } }) => {\n      return user?.roles?.includes('admin') || user?.roles?.includes('editor')\n    },\n  },\n  fields: [\n    { name: 'title', type: 'text' },\n    { name: 'status', type: 'select', options: ['draft', 'published'] },\n    { name: 'author', type: 'relationship', relationTo: 'users' },\n  ],\n}\n```\n\n### Role-Based Access Control (RBAC) Pattern\n\nPayload does NOT provide a roles system by default. The following is a commonly accepted pattern for implementing role-based access control in auth collections:\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: true,\n  fields: [\n    { name: 'name', type: 'text', required: true },\n    { name: 'email', type: 'email', required: true },\n    {\n      name: 'roles',\n      type: 'select',\n      hasMany: true,\n      options: ['admin', 'editor', 'user'],\n      defaultValue: ['user'],\n      required: true,\n      // Save roles to JWT for access control without database lookups\n      saveToJWT: true,\n      access: {\n        // Only admins can update roles\n        update: ({ req: { user } }) => user?.roles?.includes('admin'),\n      },\n    },\n  ],\n}\n```\n\n**Important Notes:**\n\n1. **Not Built-In**: Payload does not provide a roles system out of the box. You must add a `roles` field to your auth collection.\n2. **Save to JWT**: Use `saveToJWT: true` to include roles in the JWT token, enabling role checks without database queries.\n3. **Default Value**: Set a `defaultValue` to automatically assign new users a default role.\n4. **Access Control**: Restrict who can modify roles (typically only admins).\n5. **Role Options**: Define your own role hierarchy based on your application needs.\n\n**Using Roles in Access Control:**\n\n```ts\nimport type { Access } from 'payload'\n\n// Check for specific role\nexport const adminOnly: Access = ({ req: { user } }) => {\n  return user?.roles?.includes('admin')\n}\n\n// Check for multiple roles\nexport const adminOrEditor: Access = ({ req: { user } }) => {\n  return Boolean(user?.roles?.some((role) => ['admin', 'editor'].includes(role)))\n}\n\n// Role hierarchy check\nexport const hasMinimumRole: Access = ({ req: { user } }, minRole: string) => {\n  const roleHierarchy = ['user', 'editor', 'admin']\n  const userHighestRole = Math.max(...(user?.roles?.map((r) => roleHierarchy.indexOf(r)) || [-1]))\n  const requiredRoleIndex = roleHierarchy.indexOf(minRole)\n\n  return userHighestRole >= requiredRoleIndex\n}\n```\n\n### Reusable Access Functions\n\n```ts\nimport type { Access } from 'payload'\n\n// Anyone (public)\nexport const anyone: Access = () => true\n\n// Authenticated only\nexport const authenticated: Access = ({ req: { user } }) => Boolean(user)\n\n// Authenticated or published content\nexport const authenticatedOrPublished: Access = ({ req: { user } }) => {\n  if (user) return true\n  return { _status: { equals: 'published' } }\n}\n\n// Admin only\nexport const admins: Access = ({ req: { user } }) => {\n  return user?.roles?.includes('admin')\n}\n\n// Admin or editor\nexport const adminsOrEditors: Access = ({ req: { user } }) => {\n  return Boolean(user?.roles?.some((role) => ['admin', 'editor'].includes(role)))\n}\n\n// Self or admin\nexport const adminsOrSelf: Access = ({ req: { user } }) => {\n  if (user?.roles?.includes('admin')) return true\n  return { id: { equals: user?.id } }\n}\n\n// Usage\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  access: {\n    create: authenticated,\n    read: authenticatedOrPublished,\n    update: adminsOrEditors,\n    delete: admins,\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\n### Row-Level Security with Complex Queries\n\n```ts\nimport type { Access } from 'payload'\n\n// Organization-scoped access\nexport const organizationScoped: Access = ({ req: { user } }) => {\n  if (user?.roles?.includes('admin')) return true\n\n  // Users see only their organization's data\n  return {\n    organization: {\n      equals: user?.organization,\n    },\n  }\n}\n\n// Multiple conditions with AND\nexport const complexAccess: Access = ({ req: { user } }) => {\n  return {\n    and: [\n      { status: { equals: 'published' } },\n      { 'author.isActive': { equals: true } },\n      {\n        or: [{ visibility: { equals: 'public' } }, { author: { equals: user?.id } }],\n      },\n    ],\n  }\n}\n\n// Team-based access\nexport const teamMemberAccess: Access = ({ req: { user } }) => {\n  if (!user) return false\n  if (user.roles?.includes('admin')) return true\n\n  return {\n    'team.members': {\n      contains: user.id,\n    },\n  }\n}\n```\n\n### Header-Based Access (API Keys)\n\n```ts\nimport type { Access } from 'payload'\n\nexport const apiKeyAccess: Access = ({ req }) => {\n  const apiKey = req.headers.get('x-api-key')\n\n  if (!apiKey) return false\n\n  // Validate against stored keys\n  return apiKey === process.env.VALID_API_KEY\n}\n\n// Bearer token validation\nexport const bearerTokenAccess: Access = async ({ req }) => {\n  const auth = req.headers.get('authorization')\n\n  if (!auth?.startsWith('Bearer ')) return false\n\n  const token = auth.slice(7)\n  const isValid = await validateToken(token)\n\n  return isValid\n}\n```\n\n## Field Access Control\n\nField access does NOT support query constraints - only boolean returns.\n\n### Basic Field Access\n\n```ts\nimport type { NumberField, FieldAccess } from 'payload'\n\nconst salaryReadAccess: FieldAccess = ({ req: { user }, doc }) => {\n  // Self can read own salary\n  if (user?.id === doc?.id) return true\n  // Admin can read all salaries\n  return user?.roles?.includes('admin')\n}\n\nconst salaryUpdateAccess: FieldAccess = ({ req: { user } }) => {\n  // Only admins can update salary\n  return user?.roles?.includes('admin')\n}\n\nconst salaryField: NumberField = {\n  name: 'salary',\n  type: 'number',\n  access: {\n    read: salaryReadAccess,\n    update: salaryUpdateAccess,\n  },\n}\n```\n\n### Sibling Data Access\n\n```ts\nimport type { ArrayField, FieldAccess } from 'payload'\n\nconst contentReadAccess: FieldAccess = ({ req: { user }, siblingData }) => {\n  // Authenticated users see all\n  if (user) return true\n  // Public sees only if marked public\n  return siblingData?.isPublic === true\n}\n\nconst arrayField: ArrayField = {\n  name: 'sections',\n  type: 'array',\n  fields: [\n    {\n      name: 'isPublic',\n      type: 'checkbox',\n      defaultValue: false,\n    },\n    {\n      name: 'content',\n      type: 'text',\n      access: {\n        read: contentReadAccess,\n      },\n    },\n  ],\n}\n```\n\n### Nested Field Access\n\n```ts\nimport type { GroupField, FieldAccess } from 'payload'\n\nconst internalOnlyAccess: FieldAccess = ({ req: { user } }) => {\n  return user?.roles?.includes('admin') || user?.roles?.includes('internal')\n}\n\nconst groupField: GroupField = {\n  name: 'internalMetadata',\n  type: 'group',\n  access: {\n    read: internalOnlyAccess,\n    update: internalOnlyAccess,\n  },\n  fields: [\n    { name: 'internalNotes', type: 'textarea' },\n    { name: 'priority', type: 'select', options: ['low', 'medium', 'high'] },\n  ],\n}\n```\n\n### Hiding Admin Fields\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: true,\n  fields: [\n    { name: 'name', type: 'text', required: true },\n    { name: 'email', type: 'email', required: true },\n    {\n      name: 'roles',\n      type: 'select',\n      hasMany: true,\n      options: ['admin', 'editor', 'user'],\n      access: {\n        // Hide from UI, but still saved/queried\n        read: ({ req: { user } }) => user?.roles?.includes('admin'),\n        // Only admins can update roles\n        update: ({ req: { user } }) => user?.roles?.includes('admin'),\n      },\n    },\n  ],\n}\n```\n\n## Global Access Control\n\n```ts\nimport type { GlobalConfig, Access } from 'payload'\n\nconst adminOnly: Access = ({ req: { user } }) => {\n  return user?.roles?.includes('admin')\n}\n\nexport const SiteSettings: GlobalConfig = {\n  slug: 'site-settings',\n  access: {\n    read: () => true, // Anyone can read settings\n    update: adminOnly, // Only admins can update\n    readVersions: adminOnly, // Only admins can see version history\n  },\n  fields: [\n    { name: 'siteName', type: 'text' },\n    { name: 'maintenanceMode', type: 'checkbox' },\n  ],\n}\n```\n\n## Multi-Tenant Access Control\n\n```ts\nimport type { Access, CollectionConfig } from 'payload'\n\n// Add tenant field to user type\ninterface User {\n  id: string\n  tenantId: string\n  roles?: string[]\n}\n\n// Tenant-scoped access\nconst tenantAccess: Access = ({ req: { user } }) => {\n  // No user = no access\n  if (!user) return false\n\n  // Super admin sees all\n  if (user.roles?.includes('super-admin')) return true\n\n  // Users see only their tenant's data\n  return {\n    tenant: {\n      equals: (user as User).tenantId,\n    },\n  }\n}\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  access: {\n    create: tenantAccess,\n    read: tenantAccess,\n    update: tenantAccess,\n    delete: tenantAccess,\n  },\n  fields: [\n    { name: 'title', type: 'text' },\n    {\n      name: 'tenant',\n      type: 'text',\n      required: true,\n      access: {\n        // Tenant field hidden from non-admins\n        update: ({ req: { user } }) => user?.roles?.includes('super-admin'),\n      },\n      hooks: {\n        // Auto-set tenant on create\n        beforeChange: [\n          ({ req, operation, value }) => {\n            if (operation === 'create' && !value) {\n              return (req.user as User)?.tenantId\n            }\n            return value\n          },\n        ],\n      },\n    },\n  ],\n}\n```\n\n## Auth Collection Patterns\n\n### Self or Admin Pattern\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: true,\n  access: {\n    // Anyone can read user profiles\n    read: () => true,\n\n    // Users can update themselves, admins can update anyone\n    update: ({ req: { user }, id }) => {\n      if (user?.roles?.includes('admin')) return true\n      return user?.id === id\n    },\n\n    // Only admins can delete\n    delete: ({ req: { user } }) => user?.roles?.includes('admin'),\n  },\n  fields: [\n    { name: 'name', type: 'text' },\n    { name: 'email', type: 'email' },\n  ],\n}\n```\n\n### Restrict Self-Updates\n\n```ts\nimport type { CollectionConfig, FieldAccess } from 'payload'\n\nconst preventSelfRoleChange: FieldAccess = ({ req: { user }, id }) => {\n  // Admins can change anyone's roles\n  if (user?.roles?.includes('admin')) return true\n  // Users cannot change their own roles\n  if (user?.id === id) return false\n  return false\n}\n\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: true,\n  fields: [\n    {\n      name: 'roles',\n      type: 'select',\n      hasMany: true,\n      options: ['admin', 'editor', 'user'],\n      access: {\n        update: preventSelfRoleChange,\n      },\n    },\n  ],\n}\n```\n\n## Cross-Collection Validation\n\n```ts\nimport type { Access } from 'payload'\n\n// Check if user is a project member before allowing access\nexport const projectMemberAccess: Access = async ({ req, id }) => {\n  const { user, payload } = req\n\n  if (!user) return false\n  if (user.roles?.includes('admin')) return true\n\n  // Check if document exists and user is member\n  const project = await payload.findByID({\n    collection: 'projects',\n    id: id as string,\n    depth: 0,\n  })\n\n  return project.members?.includes(user.id)\n}\n\n// Prevent deletion if document has dependencies\nexport const preventDeleteWithDependencies: Access = async ({ req, id }) => {\n  const { payload } = req\n\n  const dependencyCount = await payload.count({\n    collection: 'related-items',\n    where: {\n      parent: { equals: id },\n    },\n  })\n\n  return dependencyCount === 0\n}\n```\n\n## Access Control Function Arguments\n\n### Collection Create\n\n```ts\ncreate: ({ req, data }) => boolean | Where\n\n// req: PayloadRequest\n//   - req.user: Authenticated user (if any)\n//   - req.payload: Payload instance for queries\n//   - req.headers: Request headers\n//   - req.locale: Current locale\n// data: The data being created\n```\n\n### Collection Read\n\n```ts\nread: ({ req, id }) => boolean | Where\n\n// req: PayloadRequest\n// id: Document ID being read\n//   - undefined during Access Operation (login check)\n//   - string when reading specific document\n```\n\n### Collection Update\n\n```ts\nupdate: ({ req, id, data }) => boolean | Where\n\n// req: PayloadRequest\n// id: Document ID being updated\n// data: New values being applied\n```\n\n### Collection Delete\n\n```ts\ndelete: ({ req, id }) => boolean | Where\n\n// req: PayloadRequest\n// id: Document ID being deleted\n```\n\n### Field Create\n\n```ts\naccess: {\n  create: ({ req, data, siblingData }) => boolean\n}\n\n// req: PayloadRequest\n// data: Full document data\n// siblingData: Adjacent field values at same level\n```\n\n### Field Read\n\n```ts\naccess: {\n  read: ({ req, id, doc, siblingData }) => boolean\n}\n\n// req: PayloadRequest\n// id: Document ID\n// doc: Full document\n// siblingData: Adjacent field values\n```\n\n### Field Update\n\n```ts\naccess: {\n  update: ({ req, id, data, doc, siblingData }) => boolean\n}\n\n// req: PayloadRequest\n// id: Document ID\n// data: New values\n// doc: Current document\n// siblingData: Adjacent field values\n```\n\n## Important Notes\n\n1. **Local API Default**: Access control is **skipped by default** in Local API (`overrideAccess: true`). When passing a `user` parameter, you almost always want to set `overrideAccess: false` to respect that user's permissions:\n\n   ```ts\n   // ❌ WRONG: Passes user but bypasses access control (default behavior)\n   await payload.find({\n     collection: 'posts',\n     user: someUser, // User is ignored for access control!\n   })\n\n   // ✅ CORRECT: Respects the user's permissions\n   await payload.find({\n     collection: 'posts',\n     user: someUser,\n     overrideAccess: false, // Required to enforce access control\n   })\n   ```\n\n   **Why this matters**: If you pass `user` without `overrideAccess: false`, the operation runs with admin privileges regardless of the user's actual permissions. This is a common security mistake.\n\n2. **Field Access Limitations**: Field-level access does NOT support query constraints - only boolean returns.\n\n3. **Admin Panel Visibility**: The `admin` access control determines if a collection appears in the admin panel for a user.\n\n4. **Access Before Hooks**: Access control executes BEFORE hooks run, so hooks cannot modify access behavior.\n\n5. **Query Constraints**: Only collection-level `read` access supports query constraints. All other operations and field-level access require boolean returns.\n\n## Best Practices\n\n1. **Reusable Functions**: Create named access functions for common patterns\n2. **Fail Secure**: Default to `false` for sensitive operations\n3. **Cache Checks**: Use `req.context` to cache expensive validation\n4. **Type Safety**: Type your user object for better IDE support\n5. **Test Thoroughly**: Write tests for complex access control logic\n6. **Document Intent**: Add comments explaining access rules\n7. **Audit Logs**: Track access control decisions for security review\n8. **Performance**: Avoid N+1 queries in access functions\n9. **Error Handling**: Access functions should not throw - return `false` instead\n10. **Tenant Hooks**: Auto-set tenant fields in `beforeChange` hooks\n\n## Advanced Patterns\n\nFor advanced access control patterns including context-aware access, time-based restrictions, subscription-based access, factory functions, configuration templates, debugging tips, and performance optimization, see [ACCESS-CONTROL-ADVANCED.md](ACCESS-CONTROL-ADVANCED.md).\n",
        "tools/claude-plugin/skills/payload/reference/ADAPTERS.md": "# Payload CMS Adapters Reference\n\nComplete reference for database, storage, and email adapters.\n\n## Database Adapters\n\n### MongoDB\n\n```ts\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\n\nexport default buildConfig({\n  db: mongooseAdapter({\n    url: process.env.DATABASE_URL,\n  }),\n})\n```\n\n### Postgres\n\n```ts\nimport { postgresAdapter } from '@payloadcms/db-postgres'\n\nexport default buildConfig({\n  db: postgresAdapter({\n    pool: {\n      connectionString: process.env.DATABASE_URL,\n    },\n    push: false, // Don't auto-push schema changes\n    migrationDir: './migrations',\n  }),\n})\n```\n\n### SQLite\n\n```ts\nimport { sqliteAdapter } from '@payloadcms/db-sqlite'\n\nexport default buildConfig({\n  db: sqliteAdapter({\n    client: {\n      url: 'file:./payload.db',\n    },\n    transactionOptions: {}, // Enable transactions (disabled by default)\n  }),\n})\n```\n\n## Transactions\n\nPayload automatically uses transactions for all-or-nothing database operations. Pass `req` to include operations in the same transaction.\n\n```ts\nimport type { CollectionAfterChangeHook } from 'payload'\n\nconst afterChange: CollectionAfterChangeHook = async ({ req, doc }) => {\n  // This will be part of the same transaction\n  await req.payload.create({\n    req, // Pass req to use same transaction\n    collection: 'audit-log',\n    data: { action: 'created', docId: doc.id },\n  })\n}\n\n// Manual transaction control\nconst transactionID = await payload.db.beginTransaction()\ntry {\n  await payload.create({\n    collection: 'orders',\n    data: orderData,\n    req: { transactionID },\n  })\n  await payload.update({\n    collection: 'inventory',\n    id: itemId,\n    data: { stock: newStock },\n    req: { transactionID },\n  })\n  await payload.db.commitTransaction(transactionID)\n} catch (error) {\n  await payload.db.rollbackTransaction(transactionID)\n  throw error\n}\n```\n\n**Note**: MongoDB requires replicaset for transactions. SQLite requires `transactionOptions: {}` to enable.\n\n### Threading req Through Operations\n\n**Critical**: When performing nested operations in hooks, always pass `req` to maintain transaction context. Failing to do so breaks atomicity and can cause partial updates.\n\n```ts\nimport type { CollectionAfterChangeHook } from 'payload'\n\n// ✅ CORRECT: Thread req through nested operations\nconst resaveChildren: CollectionAfterChangeHook = async ({ collection, doc, req }) => {\n  // Find children - pass req\n  const children = await req.payload.find({\n    collection: 'children',\n    where: { parent: { equals: doc.id } },\n    req, // Maintains transaction context\n  })\n\n  // Update each child - pass req\n  for (const child of children.docs) {\n    await req.payload.update({\n      id: child.id,\n      collection: 'children',\n      data: { updatedField: 'value' },\n      req, // Same transaction as parent operation\n    })\n  }\n}\n\n// ❌ WRONG: Missing req breaks transaction\nconst brokenHook: CollectionAfterChangeHook = async ({ collection, doc, req }) => {\n  const children = await req.payload.find({\n    collection: 'children',\n    where: { parent: { equals: doc.id } },\n    // Missing req - separate transaction or no transaction\n  })\n\n  for (const child of children.docs) {\n    await req.payload.update({\n      id: child.id,\n      collection: 'children',\n      data: { updatedField: 'value' },\n      // Missing req - if parent operation fails, these updates persist\n    })\n  }\n}\n```\n\n**Why This Matters:**\n\n- **MongoDB (with replica sets)**: Creates atomic session across operations\n- **PostgreSQL**: All operations use same Drizzle transaction\n- **SQLite (with transactions enabled)**: Ensures rollback on errors\n- **Without req**: Each operation runs independently, breaking atomicity\n\n**When req is Required:**\n\n- All mutating operations in hooks (create, update, delete)\n- Operations that must succeed/fail together\n- When using MongoDB replica sets or Postgres\n- Any operation that relies on `req.context` or `req.user`\n\n**When req is Optional:**\n\n- Read-only lookups independent of current transaction\n- Operations with `disableTransaction: true`\n- Administrative operations with `overrideAccess: true`\n\n## Storage Adapters\n\nAvailable storage adapters:\n\n- **@payloadcms/storage-s3** - AWS S3\n- **@payloadcms/storage-azure** - Azure Blob Storage\n- **@payloadcms/storage-gcs** - Google Cloud Storage\n- **@payloadcms/storage-r2** - Cloudflare R2\n- **@payloadcms/storage-vercel-blob** - Vercel Blob\n- **@payloadcms/storage-uploadthing** - Uploadthing\n\n### AWS S3\n\n```ts\nimport { s3Storage } from '@payloadcms/storage-s3'\n\nexport default buildConfig({\n  plugins: [\n    s3Storage({\n      collections: {\n        media: true,\n      },\n      bucket: process.env.S3_BUCKET,\n      config: {\n        credentials: {\n          accessKeyId: process.env.S3_ACCESS_KEY_ID,\n          secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,\n        },\n        region: process.env.S3_REGION,\n      },\n    }),\n  ],\n})\n```\n\n### Azure Blob Storage\n\n```ts\nimport { azureStorage } from '@payloadcms/storage-azure'\n\nexport default buildConfig({\n  plugins: [\n    azureStorage({\n      collections: {\n        media: true,\n      },\n      connectionString: process.env.AZURE_STORAGE_CONNECTION_STRING,\n      containerName: process.env.AZURE_STORAGE_CONTAINER_NAME,\n    }),\n  ],\n})\n```\n\n### Google Cloud Storage\n\n```ts\nimport { gcsStorage } from '@payloadcms/storage-gcs'\n\nexport default buildConfig({\n  plugins: [\n    gcsStorage({\n      collections: {\n        media: true,\n      },\n      bucket: process.env.GCS_BUCKET,\n      options: {\n        projectId: process.env.GCS_PROJECT_ID,\n        credentials: JSON.parse(process.env.GCS_CREDENTIALS),\n      },\n    }),\n  ],\n})\n```\n\n### Cloudflare R2\n\n```ts\nimport { r2Storage } from '@payloadcms/storage-r2'\n\nexport default buildConfig({\n  plugins: [\n    r2Storage({\n      collections: {\n        media: true,\n      },\n      bucket: process.env.R2_BUCKET,\n      config: {\n        credentials: {\n          accessKeyId: process.env.R2_ACCESS_KEY_ID,\n          secretAccessKey: process.env.R2_SECRET_ACCESS_KEY,\n        },\n        region: 'auto',\n        endpoint: process.env.R2_ENDPOINT,\n      },\n    }),\n  ],\n})\n```\n\n### Vercel Blob\n\n```ts\nimport { vercelBlobStorage } from '@payloadcms/storage-vercel-blob'\n\nexport default buildConfig({\n  plugins: [\n    vercelBlobStorage({\n      collections: {\n        media: true,\n      },\n      token: process.env.BLOB_READ_WRITE_TOKEN,\n    }),\n  ],\n})\n```\n\n### Uploadthing\n\n```ts\nimport { uploadthingStorage } from '@payloadcms/storage-uploadthing'\n\nexport default buildConfig({\n  plugins: [\n    uploadthingStorage({\n      collections: {\n        media: true,\n      },\n      options: {\n        token: process.env.UPLOADTHING_TOKEN,\n        acl: 'public-read',\n      },\n    }),\n  ],\n})\n```\n\n## Email Adapters\n\n### Nodemailer (SMTP)\n\n```ts\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\n\nexport default buildConfig({\n  email: nodemailerAdapter({\n    defaultFromAddress: 'noreply@example.com',\n    defaultFromName: 'My App',\n    transportOptions: {\n      host: process.env.SMTP_HOST,\n      port: 587,\n      auth: {\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASS,\n      },\n    },\n  }),\n})\n```\n\n### Resend\n\n```ts\nimport { resendAdapter } from '@payloadcms/email-resend'\n\nexport default buildConfig({\n  email: resendAdapter({\n    defaultFromAddress: 'noreply@example.com',\n    defaultFromName: 'My App',\n    apiKey: process.env.RESEND_API_KEY,\n  }),\n})\n```\n",
        "tools/claude-plugin/skills/payload/reference/ADVANCED.md": "# Payload CMS Advanced Features\n\nComplete reference for authentication, jobs, custom endpoints, components, plugins, and localization.\n\n## Authentication\n\n### Login\n\n```ts\n// REST API\nconst response = await fetch('/api/users/login', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    email: 'user@example.com',\n    password: 'password',\n  }),\n})\n\n// Local API\nconst result = await payload.login({\n  collection: 'users',\n  data: {\n    email: 'user@example.com',\n    password: 'password',\n  },\n})\n```\n\n### Forgot Password\n\n```ts\nawait payload.forgotPassword({\n  collection: 'users',\n  data: {\n    email: 'user@example.com',\n  },\n})\n```\n\n### Custom Strategy\n\n```ts\nimport type { CollectionConfig, Strategy } from 'payload'\n\nconst customStrategy: Strategy = {\n  name: 'custom',\n  authenticate: async ({ payload, headers }) => {\n    const token = headers.get('authorization')?.split(' ')[1]\n    if (!token) return { user: null }\n\n    const user = await verifyToken(token)\n    return { user }\n  },\n}\n\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: {\n    strategies: [customStrategy],\n  },\n  fields: [],\n}\n```\n\n### API Keys\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const APIKeys: CollectionConfig = {\n  slug: 'api-keys',\n  auth: {\n    disableLocalStrategy: true,\n    useAPIKey: true,\n  },\n  fields: [],\n}\n```\n\n## Jobs Queue\n\nOffload long-running or scheduled tasks to background workers.\n\n### Tasks\n\n```ts\nimport { buildConfig } from 'payload'\nimport type { TaskConfig } from 'payload'\n\nexport default buildConfig({\n  jobs: {\n    tasks: [\n      {\n        slug: 'sendWelcomeEmail',\n        inputSchema: [\n          { name: 'userEmail', type: 'text', required: true },\n          { name: 'userName', type: 'text', required: true },\n        ],\n        outputSchema: [{ name: 'emailSent', type: 'checkbox', required: true }],\n        retries: 2, // Retry up to 2 times on failure\n        handler: async ({ input, req }) => {\n          await sendEmail({\n            to: input.userEmail,\n            subject: `Welcome ${input.userName}`,\n          })\n          return { output: { emailSent: true } }\n        },\n      } as TaskConfig<'sendWelcomeEmail'>,\n    ],\n  },\n})\n```\n\n### Queueing Jobs\n\n```ts\n// In a hook or endpoint\nawait req.payload.jobs.queue({\n  task: 'sendWelcomeEmail',\n  input: {\n    userEmail: 'user@example.com',\n    userName: 'John',\n  },\n  waitUntil: new Date('2024-12-31'), // Optional: schedule for future\n})\n```\n\n### Workflows\n\nMulti-step jobs that run in sequence:\n\n```ts\n{\n  slug: 'onboardUser',\n  inputSchema: [{ name: 'userId', type: 'text' }],\n  handler: async ({ job, req }) => {\n    const results = await job.runInlineTask({\n      task: async ({ input }) => {\n        // Step 1: Send welcome email\n        await sendEmail(input.userId)\n        return { output: { emailSent: true } }\n      },\n    })\n\n    await job.runInlineTask({\n      task: async () => {\n        // Step 2: Create onboarding tasks\n        await createTasks()\n        return { output: { tasksCreated: true } }\n      },\n    })\n  },\n}\n```\n\n## Custom Endpoints\n\nAdd custom REST API routes to collections, globals, or root config. See [ENDPOINTS.md](ENDPOINTS.md) for detailed patterns, authentication, helpers, and real-world examples.\n\n### Root Endpoints\n\n```ts\nimport { buildConfig } from 'payload'\nimport type { Endpoint } from 'payload'\n\nconst helloEndpoint: Endpoint = {\n  path: '/hello',\n  method: 'get',\n  handler: () => {\n    return Response.json({ message: 'Hello!' })\n  },\n}\n\nconst greetEndpoint: Endpoint = {\n  path: '/greet/:name',\n  method: 'get',\n  handler: (req) => {\n    return Response.json({\n      message: `Hello ${req.routeParams.name}!`,\n    })\n  },\n}\n\nexport default buildConfig({\n  endpoints: [helloEndpoint, greetEndpoint],\n  collections: [],\n  secret: process.env.PAYLOAD_SECRET || '',\n})\n```\n\n### Collection Endpoints\n\n```ts\nimport type { CollectionConfig, Endpoint } from 'payload'\n\nconst featuredEndpoint: Endpoint = {\n  path: '/featured',\n  method: 'get',\n  handler: async (req) => {\n    const posts = await req.payload.find({\n      collection: 'posts',\n      where: { featured: { equals: true } },\n    })\n    return Response.json(posts)\n  },\n}\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  endpoints: [featuredEndpoint],\n  fields: [\n    { name: 'title', type: 'text' },\n    { name: 'featured', type: 'checkbox' },\n  ],\n}\n```\n\n## Custom Components\n\n### Field Component (Client)\n\n```tsx\n'use client'\nimport { useField } from '@payloadcms/ui'\nimport type { TextFieldClientComponent } from 'payload'\n\nexport const CustomField: TextFieldClientComponent = () => {\n  const { value, setValue } = useField()\n\n  return <input value={value || ''} onChange={(e) => setValue(e.target.value)} />\n}\n```\n\n### Custom View\n\n```tsx\n'use client'\nimport { DefaultTemplate } from '@payloadcms/next/templates'\n\nexport const CustomView = () => {\n  return (\n    <DefaultTemplate>\n      <h1>Custom Dashboard</h1>\n      {/* Your content */}\n    </DefaultTemplate>\n  )\n}\n```\n\n### Admin Config\n\n```ts\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  admin: {\n    components: {\n      beforeDashboard: ['/components/BeforeDashboard'],\n      beforeLogin: ['/components/BeforeLogin'],\n      views: {\n        custom: {\n          Component: '/views/Custom',\n          path: '/custom',\n        },\n      },\n    },\n  },\n  collections: [],\n  secret: process.env.PAYLOAD_SECRET || '',\n})\n```\n\n## Plugins\n\n### Available Plugins\n\n- **@payloadcms/plugin-seo** - SEO fields with meta title/description, Open Graph, preview generation\n- **@payloadcms/plugin-redirects** - Manage URL redirects (301/302) for Next.js apps\n- **@payloadcms/plugin-nested-docs** - Hierarchical document structures with breadcrumbs\n- **@payloadcms/plugin-form-builder** - Dynamic form builder with submissions and validation\n- **@payloadcms/plugin-search** - Full-text search integration (Algolia support)\n- **@payloadcms/plugin-stripe** - Stripe payments, subscriptions, webhooks\n- **@payloadcms/plugin-ecommerce** - Complete ecommerce solution (products, variants, carts, orders)\n- **@payloadcms/plugin-import-export** - Import/export data via CSV\n- **@payloadcms/plugin-multi-tenant** - Multi-tenancy with tenant isolation\n- **@payloadcms/plugin-sentry** - Sentry error tracking integration\n- **@payloadcms/plugin-mcp** - Model Context Protocol for AI integrations\n\n### Using Plugins\n\n```ts\nimport { buildConfig } from 'payload'\nimport { seoPlugin } from '@payloadcms/plugin-seo'\nimport { redirectsPlugin } from '@payloadcms/plugin-redirects'\n\nexport default buildConfig({\n  plugins: [\n    seoPlugin({\n      collections: ['posts', 'pages'],\n    }),\n    redirectsPlugin({\n      collections: ['pages'],\n    }),\n  ],\n  collections: [],\n  secret: process.env.PAYLOAD_SECRET || '',\n})\n```\n\n### Creating Plugins\n\n```ts\nimport type { Config } from 'payload'\n\ninterface PluginOptions {\n  enabled?: boolean\n}\n\nexport const myPlugin =\n  (options: PluginOptions) =>\n  (config: Config): Config => ({\n    ...config,\n    collections: [\n      ...(config.collections || []),\n      {\n        slug: 'plugin-collection',\n        fields: [{ name: 'title', type: 'text' }],\n      },\n    ],\n    onInit: async (payload) => {\n      if (config.onInit) await config.onInit(payload)\n      // Plugin initialization\n    },\n  })\n```\n\n## Localization\n\n```ts\nimport { buildConfig } from 'payload'\nimport type { Field, Payload } from 'payload'\n\nexport default buildConfig({\n  localization: {\n    locales: ['en', 'es', 'de'],\n    defaultLocale: 'en',\n    fallback: true,\n  },\n  collections: [],\n  secret: process.env.PAYLOAD_SECRET || '',\n})\n\n// Localized field\nconst localizedField: TextField = {\n  name: 'title',\n  type: 'text',\n  localized: true,\n}\n\n// Query with locale\nconst posts = await payload.find({\n  collection: 'posts',\n  locale: 'es',\n})\n```\n\n## TypeScript Type References\n\nFor complete TypeScript type definitions and signatures, reference these files from the Payload source:\n\n### Core Configuration Types\n\n- **[All Commonly-Used Types](https://github.com/payloadcms/payload/blob/main/packages/payload/src/index.ts)** - Check here first for commonly used types and interfaces. All core types are exported from this file.\n\n### Database & Adapters\n\n- **[Database Adapter Types](https://github.com/payloadcms/payload/blob/main/packages/payload/src/database/types.ts)** - Base adapter interface\n- **[MongoDB Adapter](https://github.com/payloadcms/payload/blob/main/packages/db-mongodb/src/index.ts)** - MongoDB-specific options\n- **[Postgres Adapter](https://github.com/payloadcms/payload/blob/main/packages/db-postgres/src/index.ts)** - Postgres-specific options\n\n### Rich Text & Plugins\n\n- **[Lexical Types](https://github.com/payloadcms/payload/blob/main/packages/richtext-lexical/src/exports/server/index.ts)** - Lexical editor configuration\n\nWhen users need detailed type information, fetch these URLs to provide complete signatures and optional parameters.\n",
        "tools/claude-plugin/skills/payload/reference/COLLECTIONS.md": "# Payload CMS Collections Reference\n\nComplete reference for collection configurations and patterns.\n\n## Basic Collection\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  labels: {\n    singular: 'Post',\n    plural: 'Posts',\n  },\n  admin: {\n    useAsTitle: 'title',\n    defaultColumns: ['title', 'author', 'status', 'createdAt'],\n    group: 'Content', // Organize in admin sidebar\n    description: 'Blog posts and articles',\n    listSearchableFields: ['title', 'slug'],\n  },\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n      required: true,\n      index: true,\n    },\n    {\n      name: 'slug',\n      type: 'text',\n      unique: true,\n      index: true,\n      admin: { position: 'sidebar' },\n    },\n    {\n      name: 'status',\n      type: 'select',\n      options: ['draft', 'published'],\n      defaultValue: 'draft',\n    },\n  ],\n  defaultSort: '-createdAt',\n  timestamps: true,\n}\n```\n\n## Auth Collection\n\n```ts\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: {\n    tokenExpiration: 7200, // 2 hours\n    verify: true,\n    maxLoginAttempts: 5,\n    lockTime: 600000, // 10 minutes\n    useAPIKey: true,\n  },\n  admin: {\n    useAsTitle: 'email',\n  },\n  fields: [\n    {\n      name: 'roles',\n      type: 'select',\n      hasMany: true,\n      options: ['admin', 'editor', 'user'],\n      required: true,\n      defaultValue: ['user'],\n      saveToJWT: true,\n    },\n    {\n      name: 'name',\n      type: 'text',\n      required: true,\n    },\n  ],\n}\n```\n\n## Upload Collection\n\n```ts\nexport const Media: CollectionConfig = {\n  slug: 'media',\n  upload: {\n    staticDir: 'media',\n    mimeTypes: ['image/*'],\n    imageSizes: [\n      {\n        name: 'thumbnail',\n        width: 400,\n        height: 300,\n        position: 'centre',\n      },\n      {\n        name: 'card',\n        width: 768,\n        height: 1024,\n      },\n    ],\n    adminThumbnail: 'thumbnail',\n    focalPoint: true,\n    crop: true,\n  },\n  access: {\n    read: () => true,\n  },\n  fields: [\n    {\n      name: 'alt',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'caption',\n      type: 'text',\n      localized: true,\n    },\n  ],\n}\n```\n\n## Live Preview\n\nEnable real-time content preview during editing.\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nconst generatePreviewPath = ({\n  slug,\n  collection,\n  req,\n}: {\n  slug: string\n  collection: string\n  req: any\n}) => {\n  const baseUrl = process.env.NEXT_PUBLIC_SERVER_URL\n  return `${baseUrl}/api/preview?slug=${slug}&collection=${collection}`\n}\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  admin: {\n    useAsTitle: 'title',\n    // Live preview during editing\n    livePreview: {\n      url: ({ data, req }) =>\n        generatePreviewPath({\n          slug: data?.slug as string,\n          collection: 'pages',\n          req,\n        }),\n    },\n    // Static preview button\n    preview: (data, { req }) =>\n      generatePreviewPath({\n        slug: data?.slug as string,\n        collection: 'pages',\n        req,\n      }),\n  },\n  fields: [\n    { name: 'title', type: 'text' },\n    { name: 'slug', type: 'text' },\n  ],\n}\n```\n\n## Versioning & Drafts\n\nPayload maintains version history and supports draft/publish workflows.\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\n// Basic versioning (audit log only)\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  versions: true, // or { maxPerDoc: 100 }\n  fields: [{ name: 'name', type: 'text' }],\n}\n\n// Drafts enabled (draft/publish workflow)\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  versions: {\n    drafts: true, // Enables _status field\n    maxPerDoc: 50,\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n\n// Full configuration with autosave and scheduled publish\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  versions: {\n    drafts: {\n      autosave: true, // Auto-save while editing\n      schedulePublish: true, // Schedule future publish/unpublish\n      validate: false, // Don't validate drafts (default)\n    },\n    maxPerDoc: 100, // Keep last 100 versions (0 = unlimited)\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\n### Draft API Usage\n\n```ts\n// Create draft\nawait payload.create({\n  collection: 'posts',\n  data: { title: 'Draft Post' },\n  draft: true, // Saves as draft, skips required field validation\n})\n\n// Update as draft\nawait payload.update({\n  collection: 'posts',\n  id: '123',\n  data: { title: 'Updated Draft' },\n  draft: true,\n})\n\n// Read with drafts (returns newest draft if available)\nconst post = await payload.findByID({\n  collection: 'posts',\n  id: '123',\n  draft: true, // Returns draft version if exists\n})\n\n// Query only published (REST API)\n// GET /api/posts (returns only _status: 'published')\n\n// Access control for drafts\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  versions: { drafts: true },\n  access: {\n    read: ({ req: { user } }) => {\n      // Public can only see published\n      if (!user) return { _status: { equals: 'published' } }\n      // Authenticated can see all\n      return true\n    },\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\n### Document Status\n\nThe `_status` field is auto-injected when drafts are enabled:\n\n- `draft` - Never published\n- `published` - Published with no newer drafts\n- `changed` - Published but has newer unpublished drafts\n\n## Globals\n\nGlobals are single-instance documents (not collections).\n\n```ts\nimport type { GlobalConfig } from 'payload'\n\nexport const Header: GlobalConfig = {\n  slug: 'header',\n  label: 'Header',\n  admin: {\n    group: 'Settings',\n  },\n  fields: [\n    {\n      name: 'logo',\n      type: 'upload',\n      relationTo: 'media',\n      required: true,\n    },\n    {\n      name: 'nav',\n      type: 'array',\n      maxRows: 8,\n      fields: [\n        {\n          name: 'link',\n          type: 'relationship',\n          relationTo: 'pages',\n        },\n        {\n          name: 'label',\n          type: 'text',\n        },\n      ],\n    },\n  ],\n}\n```\n",
        "tools/claude-plugin/skills/payload/reference/ENDPOINTS.md": "# Payload Custom API Endpoints Reference\n\nCustom REST API endpoints extend Payload's auto-generated CRUD operations with custom logic, authentication flows, webhooks, and integrations.\n\n## Quick Reference\n\n### Endpoint Configuration\n\n| Property  | Type                                              | Description                                                     |\n| --------- | ------------------------------------------------- | --------------------------------------------------------------- |\n| `path`    | `string`                                          | Route path after collection/global slug (e.g., `/:id/tracking`) |\n| `method`  | `'get' \\| 'post' \\| 'put' \\| 'patch' \\| 'delete'` | HTTP method (lowercase)                                         |\n| `handler` | `(req: PayloadRequest) => Promise<Response>`      | Async function returning Web API Response                       |\n| `custom`  | `Record<string, any>`                             | Extension point for plugins/metadata                            |\n\n### Request Context\n\n| Property          | Type                    | Description                                            |\n| ----------------- | ----------------------- | ------------------------------------------------------ |\n| `req.user`        | `User \\| null`          | Authenticated user (null if not authenticated)         |\n| `req.payload`     | `Payload`               | Payload instance for operations (find, create...)      |\n| `req.routeParams` | `Record<string, any>`   | Path parameters (e.g., `:id`)                          |\n| `req.url`         | `string`                | Full request URL                                       |\n| `req.method`      | `string`                | HTTP method                                            |\n| `req.headers`     | `Headers`               | Request headers                                        |\n| `req.json()`      | `() => Promise<any>`    | Parse JSON body                                        |\n| `req.text()`      | `() => Promise<string>` | Read body as text                                      |\n| `req.data`        | `any`                   | Parsed body (after `addDataAndFileToRequest()`)        |\n| `req.file`        | `File`                  | Uploaded file (after `addDataAndFileToRequest()`)      |\n| `req.locale`      | `string`                | Request locale (after `addLocalesToRequestFromData()`) |\n| `req.i18n`        | `I18n`                  | i18n instance                                          |\n| `req.t`           | `TFunction`             | Translation function                                   |\n\n## Common Patterns\n\n### Authentication Check\n\nCustom endpoints are **not authenticated by default**. Check `req.user` to enforce authentication.\n\n```ts\nimport { APIError } from 'payload'\n\nexport const authenticatedEndpoint = {\n  path: '/protected',\n  method: 'get',\n  handler: async (req) => {\n    if (!req.user) {\n      throw new APIError('Unauthorized', 401)\n    }\n\n    // User is authenticated\n    return Response.json({ message: 'Access granted' })\n  },\n}\n```\n\n### Using Payload Operations\n\nUse `req.payload` for database operations with access control and hooks.\n\n```ts\nexport const getRelatedPosts = {\n  path: '/:id/related',\n  method: 'get',\n  handler: async (req) => {\n    const { id } = req.routeParams\n\n    // Find related posts\n    const posts = await req.payload.find({\n      collection: 'posts',\n      where: {\n        category: {\n          equals: id,\n        },\n      },\n      limit: 5,\n      sort: '-createdAt',\n    })\n\n    return Response.json(posts)\n  },\n}\n```\n\n### Route Parameters\n\nAccess path parameters via `req.routeParams`.\n\n```ts\nexport const getTrackingEndpoint = {\n  path: '/:id/tracking',\n  method: 'get',\n  handler: async (req) => {\n    const orderId = req.routeParams.id\n\n    const tracking = await getTrackingInfo(orderId)\n\n    if (!tracking) {\n      return Response.json({ error: 'not found' }, { status: 404 })\n    }\n\n    return Response.json(tracking)\n  },\n}\n```\n\n### Request Body Handling\n\n**Option 1: Manual JSON parsing**\n\n```ts\nexport const createEndpoint = {\n  path: '/create',\n  method: 'post',\n  handler: async (req) => {\n    const data = await req.json()\n\n    const result = await req.payload.create({\n      collection: 'posts',\n      data,\n    })\n\n    return Response.json(result)\n  },\n}\n```\n\n**Option 2: Using helper (handles JSON + files)**\n\n```ts\nimport { addDataAndFileToRequest } from 'payload'\n\nexport const uploadEndpoint = {\n  path: '/upload',\n  method: 'post',\n  handler: async (req) => {\n    await addDataAndFileToRequest(req)\n\n    // req.data now contains parsed body\n    // req.file contains uploaded file (if multipart)\n\n    const result = await req.payload.create({\n      collection: 'media',\n      data: req.data,\n      file: req.file,\n    })\n\n    return Response.json(result)\n  },\n}\n```\n\n### CORS Headers\n\nUse `headersWithCors` helper to apply config CORS settings.\n\n```ts\nimport { headersWithCors } from 'payload'\n\nexport const corsEndpoint = {\n  path: '/public-data',\n  method: 'get',\n  handler: async (req) => {\n    const data = await fetchPublicData()\n\n    return Response.json(data, {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n    })\n  },\n}\n```\n\n### Error Handling\n\nThrow `APIError` with status codes for proper error responses.\n\n```ts\nimport { APIError } from 'payload'\n\nexport const validateEndpoint = {\n  path: '/validate',\n  method: 'post',\n  handler: async (req) => {\n    const data = await req.json()\n\n    if (!data.email) {\n      throw new APIError('Email is required', 400)\n    }\n\n    // Validation passed\n    return Response.json({ valid: true })\n  },\n}\n```\n\n### Query Parameters\n\nExtract query params from URL.\n\n```ts\nexport const searchEndpoint = {\n  path: '/search',\n  method: 'get',\n  handler: async (req) => {\n    const url = new URL(req.url)\n    const query = url.searchParams.get('q')\n    const limit = parseInt(url.searchParams.get('limit') || '10')\n\n    const results = await req.payload.find({\n      collection: 'posts',\n      where: {\n        title: {\n          contains: query,\n        },\n      },\n      limit,\n    })\n\n    return Response.json(results)\n  },\n}\n```\n\n## Helper Functions\n\n### addDataAndFileToRequest\n\nParses request body and attaches to `req.data` and `req.file`.\n\n```ts\nimport { addDataAndFileToRequest } from 'payload'\n\nexport const endpoint = {\n  path: '/process',\n  method: 'post',\n  handler: async (req) => {\n    await addDataAndFileToRequest(req)\n\n    // req.data: parsed JSON or form data\n    // req.file: uploaded file (if multipart)\n\n    console.log(req.data) // { title: 'My Post' }\n    console.log(req.file) // File object or undefined\n  },\n}\n```\n\n**Handles:**\n\n- JSON bodies (`Content-Type: application/json`)\n- Form data (`Content-Type: multipart/form-data`)\n- File uploads\n\n### addLocalesToRequestFromData\n\nExtracts locale from request data and validates against config.\n\n```ts\nimport { addLocalesToRequestFromData } from 'payload'\n\nexport const endpoint = {\n  path: '/translate',\n  method: 'post',\n  handler: async (req) => {\n    await addLocalesToRequestFromData(req)\n\n    // req.locale: validated locale string\n    // req.fallbackLocale: fallback locale string\n\n    const result = await req.payload.find({\n      collection: 'posts',\n      locale: req.locale,\n    })\n\n    return Response.json(result)\n  },\n}\n```\n\n### headersWithCors\n\nApplies CORS headers from Payload config.\n\n```ts\nimport { headersWithCors } from 'payload'\n\nexport const endpoint = {\n  path: '/data',\n  method: 'get',\n  handler: async (req) => {\n    const data = { message: 'Hello' }\n\n    return Response.json(data, {\n      headers: headersWithCors({\n        headers: new Headers({\n          'Cache-Control': 'public, max-age=3600',\n        }),\n        req,\n      }),\n    })\n  },\n}\n```\n\n## Real-World Examples\n\n### Multi-Tenant Login Endpoint\n\nFrom `examples/multi-tenant`:\n\n```ts\nimport { APIError, generatePayloadCookie, headersWithCors } from 'payload'\n\nexport const externalUsersLogin = {\n  path: '/login-external',\n  method: 'post',\n  handler: async (req) => {\n    const { email, password, tenant } = await req.json()\n\n    if (!email || !password || !tenant) {\n      throw new APIError('Missing credentials', 400)\n    }\n\n    // Find user with tenant constraint\n    const userQuery = await req.payload.find({\n      collection: 'users',\n      where: {\n        and: [\n          { email: { equals: email } },\n          {\n            or: [{ tenants: { equals: tenant } }, { 'tenants.tenant': { equals: tenant } }],\n          },\n        ],\n      },\n    })\n\n    if (!userQuery.docs.length) {\n      throw new APIError('Invalid credentials', 401)\n    }\n\n    // Authenticate user\n    const result = await req.payload.login({\n      collection: 'users',\n      data: { email, password },\n    })\n\n    return Response.json(result, {\n      headers: headersWithCors({\n        headers: new Headers({\n          'Set-Cookie': generatePayloadCookie({\n            collectionAuthConfig: req.payload.config.collections.find((c) => c.slug === 'users')\n              .auth,\n            cookiePrefix: req.payload.config.cookiePrefix,\n            token: result.token,\n          }),\n        }),\n        req,\n      }),\n    })\n  },\n}\n```\n\n### Webhook Handler (Stripe)\n\nFrom `packages/plugin-ecommerce`:\n\n```ts\nexport const webhookEndpoint = {\n  path: '/webhooks',\n  method: 'post',\n  handler: async (req) => {\n    const body = await req.text()\n    const signature = req.headers.get('stripe-signature')\n\n    try {\n      const event = stripe.webhooks.constructEvent(body, signature, webhookSecret)\n\n      // Process event\n      switch (event.type) {\n        case 'payment_intent.succeeded':\n          await handlePaymentSuccess(req.payload, event.data.object)\n          break\n        case 'payment_intent.failed':\n          await handlePaymentFailure(req.payload, event.data.object)\n          break\n      }\n\n      return Response.json({ received: true })\n    } catch (err) {\n      req.payload.logger.error(`Webhook error: ${err.message}`)\n      return Response.json({ error: err.message }, { status: 400 })\n    }\n  },\n}\n```\n\n### Data Preview Endpoint\n\nFrom `packages/plugin-import-export`:\n\n```ts\nimport { addDataAndFileToRequest } from 'payload'\n\nexport const previewEndpoint = {\n  path: '/preview',\n  method: 'post',\n  handler: async (req) => {\n    if (!req.user) {\n      throw new APIError('Unauthorized', 401)\n    }\n\n    await addDataAndFileToRequest(req)\n\n    const { collection, where, limit = 10 } = req.data\n\n    // Validate collection exists\n    const collectionConfig = req.payload.config.collections.find((c) => c.slug === collection)\n    if (!collectionConfig) {\n      throw new APIError('Collection not found', 404)\n    }\n\n    // Preview data\n    const results = await req.payload.find({\n      collection,\n      where,\n      limit,\n      depth: 0,\n    })\n\n    return Response.json({\n      docs: results.docs,\n      totalDocs: results.totalDocs,\n      fields: collectionConfig.fields,\n    })\n  },\n}\n```\n\n### Reindex Action Endpoint\n\nFrom `packages/plugin-search`:\n\n```ts\nexport const reindexEndpoint = (pluginConfig) => ({\n  path: '/reindex',\n  method: 'post',\n  handler: async (req) => {\n    if (!req.user) {\n      throw new APIError('Unauthorized', 401)\n    }\n\n    const { collection } = req.routeParams\n\n    // Reindex collection\n    const result = await reindexCollection(req.payload, collection, pluginConfig)\n\n    return Response.json({\n      message: `Reindexed ${result.count} documents`,\n      count: result.count,\n    })\n  },\n})\n```\n\n## Endpoint Placement\n\n### Collection Endpoints\n\nMounted at `/api/{collection-slug}/{path}`.\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Orders: CollectionConfig = {\n  slug: 'orders',\n  fields: [\n    /* ... */\n  ],\n  endpoints: [\n    {\n      path: '/:id/tracking',\n      method: 'get',\n      handler: async (req) => {\n        // Available at: /api/orders/:id/tracking\n        const orderId = req.routeParams.id\n        return Response.json({ orderId })\n      },\n    },\n  ],\n}\n```\n\n### Global Endpoints\n\nMounted at `/api/globals/{global-slug}/{path}`.\n\n```ts\nimport type { GlobalConfig } from 'payload'\n\nexport const Settings: GlobalConfig = {\n  slug: 'settings',\n  fields: [\n    /* ... */\n  ],\n  endpoints: [\n    {\n      path: '/clear-cache',\n      method: 'post',\n      handler: async (req) => {\n        // Available at: /api/globals/settings/clear-cache\n        await clearCache()\n        return Response.json({ message: 'Cache cleared' })\n      },\n    },\n  ],\n}\n```\n\n## Advanced Patterns\n\n### Factory Functions\n\nCreate reusable endpoint factories for plugins.\n\n```ts\nexport const createWebhookEndpoint = (config) => ({\n  path: '/webhook',\n  method: 'post',\n  handler: async (req) => {\n    const signature = req.headers.get('x-webhook-signature')\n\n    if (!verifySignature(signature, config.secret)) {\n      throw new APIError('Invalid signature', 401)\n    }\n\n    const data = await req.json()\n    await processWebhook(req.payload, data, config)\n\n    return Response.json({ received: true })\n  },\n})\n```\n\n### Conditional Endpoints\n\nAdd endpoints based on config options.\n\n```ts\nexport const MyCollection: CollectionConfig = {\n  slug: 'posts',\n  fields: [\n    /* ... */\n  ],\n  endpoints: [\n    // Always included\n    {\n      path: '/public',\n      method: 'get',\n      handler: async (req) => Response.json({ data: [] }),\n    },\n    // Conditionally included\n    ...(process.env.ENABLE_ANALYTICS\n      ? [\n          {\n            path: '/analytics',\n            method: 'get',\n            handler: async (req) => Response.json({ analytics: [] }),\n          },\n        ]\n      : []),\n  ],\n}\n```\n\n### OpenAPI Documentation\n\nUse `custom` property for API documentation metadata.\n\n```ts\nexport const endpoint = {\n  path: '/search',\n  method: 'get',\n  handler: async (req) => {\n    // Handler implementation\n  },\n  custom: {\n    openapi: {\n      summary: 'Search posts',\n      parameters: [\n        {\n          name: 'q',\n          in: 'query',\n          required: true,\n          schema: { type: 'string' },\n        },\n      ],\n      responses: {\n        200: {\n          description: 'Search results',\n          content: {\n            'application/json': {\n              schema: { type: 'array' },\n            },\n          },\n        },\n      },\n    },\n  },\n}\n```\n\n## Best Practices\n\n1. **Always check authentication** - Custom endpoints are not authenticated by default\n2. **Use `req.payload` for operations** - Ensures access control and hooks execute\n3. **Use helpers for common tasks** - `addDataAndFileToRequest`, `headersWithCors`, etc.\n4. **Throw `APIError` for errors** - Provides consistent error responses\n5. **Return Web API `Response`** - Use `Response.json()` for consistent responses\n6. **Validate input** - Check required fields, validate types\n7. **Handle CORS** - Use `headersWithCors` for cross-origin requests\n8. **Log errors** - Use `req.payload.logger` for debugging\n9. **Document with `custom`** - Add OpenAPI metadata for API docs\n10. **Factory pattern for reuse** - Create endpoint factories for plugins\n\n## Resources\n\n- REST API Overview: <https://payloadcms.com/docs/rest-api/overview>\n- Custom Endpoints: <https://payloadcms.com/docs/rest-api/overview#custom-endpoints>\n- Access Control: <https://payloadcms.com/docs/access-control/overview>\n- Local API: <https://payloadcms.com/docs/local-api/overview>\n",
        "tools/claude-plugin/skills/payload/reference/FIELD-TYPE-GUARDS.md": "# Payload Field Type Guards Reference\n\nComplete reference with detailed examples and patterns. See [FIELDS.md](FIELDS.md#field-type-guards) for quick reference table of all guards.\n\n## Structural Guards\n\n### fieldHasSubFields\n\nChecks if field contains nested fields (group, array, row, or collapsible).\n\n```ts\nimport type { Field } from 'payload'\nimport { fieldHasSubFields } from 'payload'\n\nfunction traverseFields(fields: Field[]): void {\n  fields.forEach((field) => {\n    if (fieldHasSubFields(field)) {\n      // Safe to access field.fields\n      traverseFields(field.fields)\n    }\n  })\n}\n```\n\n**Signature:**\n\n```ts\nfieldHasSubFields<TField extends ClientField | Field>(\n  field: TField\n): field is TField & (FieldWithSubFieldsClient | FieldWithSubFields)\n```\n\n**Common Pattern - Exclude Arrays:**\n\n```ts\nif (fieldHasSubFields(field) && !fieldIsArrayType(field)) {\n  // Groups, rows, collapsibles only (not arrays)\n}\n```\n\n### fieldIsArrayType\n\nChecks if field type is `'array'`.\n\n```ts\nimport { fieldIsArrayType } from 'payload'\n\nif (fieldIsArrayType(field)) {\n  // field.type === 'array'\n  console.log(`Min rows: ${field.minRows}`)\n  console.log(`Max rows: ${field.maxRows}`)\n}\n```\n\n**Signature:**\n\n```ts\nfieldIsArrayType<TField extends ClientField | Field>(\n  field: TField\n): field is TField & (ArrayFieldClient | ArrayField)\n```\n\n### fieldIsBlockType\n\nChecks if field type is `'blocks'`.\n\n```ts\nimport { fieldIsBlockType } from 'payload'\n\nif (fieldIsBlockType(field)) {\n  // field.type === 'blocks'\n  field.blocks.forEach((block) => {\n    console.log(`Block: ${block.slug}`)\n  })\n}\n```\n\n**Signature:**\n\n```ts\nfieldIsBlockType<TField extends ClientField | Field>(\n  field: TField\n): field is TField & (BlocksFieldClient | BlocksField)\n```\n\n**Common Pattern - Distinguish Containers:**\n\n```ts\nif (fieldIsArrayType(field)) {\n  // Handle array rows\n} else if (fieldIsBlockType(field)) {\n  // Handle block types\n}\n```\n\n### fieldIsGroupType\n\nChecks if field type is `'group'`.\n\n```ts\nimport { fieldIsGroupType } from 'payload'\n\nif (fieldIsGroupType(field)) {\n  // field.type === 'group'\n  console.log(`Interface: ${field.interfaceName}`)\n}\n```\n\n**Signature:**\n\n```ts\nfieldIsGroupType<TField extends ClientField | Field>(\n  field: TField\n): field is TField & (GroupFieldClient | GroupField)\n```\n\n## Capability Guards\n\n### fieldSupportsMany\n\nChecks if field can have multiple values (select, relationship, or upload with `hasMany`).\n\n```ts\nimport { fieldSupportsMany } from 'payload'\n\nif (fieldSupportsMany(field)) {\n  // field.type is 'select' | 'relationship' | 'upload'\n  // Safe to check field.hasMany\n  if (field.hasMany) {\n    console.log('Field accepts multiple values')\n  }\n}\n```\n\n**Signature:**\n\n```ts\nfieldSupportsMany<TField extends ClientField | Field>(\n  field: TField\n): field is TField & (FieldWithManyClient | FieldWithMany)\n```\n\n### fieldHasMaxDepth\n\nChecks if field is relationship/upload/join with numeric `maxDepth` property.\n\n```ts\nimport { fieldHasMaxDepth } from 'payload'\n\nif (fieldHasMaxDepth(field)) {\n  // field.type is 'upload' | 'relationship' | 'join'\n  // AND field.maxDepth is number\n  const remainingDepth = field.maxDepth - currentDepth\n}\n```\n\n**Signature:**\n\n```ts\nfieldHasMaxDepth<TField extends ClientField | Field>(\n  field: TField\n): field is TField & (FieldWithMaxDepthClient | FieldWithMaxDepth)\n```\n\n### fieldShouldBeLocalized\n\nChecks if field needs localization handling (accounts for parent localization).\n\n```ts\nimport { fieldShouldBeLocalized } from 'payload'\n\nfunction processField(field: Field, parentIsLocalized: boolean) {\n  if (fieldShouldBeLocalized({ field, parentIsLocalized })) {\n    // Create locale-specific table or index\n  }\n}\n```\n\n**Signature:**\n\n```ts\nfieldShouldBeLocalized({\n  field,\n  parentIsLocalized,\n}: {\n  field: ClientField | ClientTab | Field | Tab\n  parentIsLocalized: boolean\n}): boolean\n```\n\n```ts\n// Accounts for parent localization\nif (fieldShouldBeLocalized({ field, parentIsLocalized: false })) {\n  /* ... */\n}\n```\n\n### fieldIsVirtual\n\nChecks if field is virtual (computed or virtual relationship).\n\n```ts\nimport { fieldIsVirtual } from 'payload'\n\nif (fieldIsVirtual(field)) {\n  // field.virtual is truthy\n  if (typeof field.virtual === 'string') {\n    // Virtual relationship path\n    console.log(`Virtual path: ${field.virtual}`)\n  } else {\n    // Computed virtual field (uses hooks)\n  }\n}\n```\n\n**Signature:**\n\n```ts\nfieldIsVirtual(field: Field | Tab): boolean\n```\n\n## Data Guards\n\n### fieldAffectsData\n\n**Most commonly used guard.** Checks if field stores data (has name and is not UI-only).\n\n```ts\nimport { fieldAffectsData } from 'payload'\n\nfunction generateSchema(fields: Field[]) {\n  fields.forEach((field) => {\n    if (fieldAffectsData(field)) {\n      // Safe to access field.name\n      schema[field.name] = getFieldType(field)\n    }\n  })\n}\n```\n\n**Signature:**\n\n```ts\nfieldAffectsData<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField\n): field is TField & (FieldAffectingDataClient | FieldAffectingData)\n```\n\n**Pattern - Data Fields Only:**\n\n```ts\nconst dataFields = fields.filter(fieldAffectsData)\n```\n\n### fieldIsPresentationalOnly\n\nChecks if field is UI-only (type `'ui'`).\n\n```ts\nimport { fieldIsPresentationalOnly } from 'payload'\n\nif (fieldIsPresentationalOnly(field)) {\n  // field.type === 'ui'\n  // Skip in data operations, GraphQL schema, etc.\n  return\n}\n```\n\n**Signature:**\n\n```ts\nfieldIsPresentationalOnly<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField\n): field is TField & (UIFieldClient | UIField)\n```\n\n### fieldIsID\n\nChecks if field name is exactly `'id'`.\n\n```ts\nimport { fieldIsID } from 'payload'\n\nif (fieldIsID(field)) {\n  // field.name === 'id'\n  // Special handling for ID field\n}\n```\n\n**Signature:**\n\n```ts\nfieldIsID<TField extends ClientField | Field>(\n  field: TField\n): field is { name: 'id' } & TField\n```\n\n### fieldIsHiddenOrDisabled\n\nChecks if field is hidden or admin-disabled.\n\n```ts\nimport { fieldIsHiddenOrDisabled } from 'payload'\n\nconst visibleFields = fields.filter((field) => !fieldIsHiddenOrDisabled(field))\n```\n\n**Signature:**\n\n```ts\nfieldIsHiddenOrDisabled<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField\n): field is { admin: { hidden: true } } & TField\n```\n\n## Layout Guards\n\n### fieldIsSidebar\n\nChecks if field is positioned in sidebar.\n\n```ts\nimport { fieldIsSidebar } from 'payload'\n\nconst [mainFields, sidebarFields] = fields.reduce(\n  ([main, sidebar], field) => {\n    if (fieldIsSidebar(field)) {\n      return [main, [...sidebar, field]]\n    }\n    return [[...main, field], sidebar]\n  },\n  [[], []],\n)\n```\n\n**Signature:**\n\n```ts\nfieldIsSidebar<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField\n): field is { admin: { position: 'sidebar' } } & TField\n```\n\n## Tab & Group Guards\n\n### tabHasName\n\nChecks if tab is named (stores data under tab name).\n\n```ts\nimport { tabHasName } from 'payload'\n\ntabs.forEach((tab) => {\n  if (tabHasName(tab)) {\n    // tab.name exists\n    dataPath.push(tab.name)\n  }\n  // Process tab.fields\n})\n```\n\n**Signature:**\n\n```ts\ntabHasName<TField extends ClientTab | Tab>(\n  tab: TField\n): tab is NamedTab & TField\n```\n\n### groupHasName\n\nChecks if group is named (stores data under group name).\n\n```ts\nimport { groupHasName } from 'payload'\n\nif (groupHasName(group)) {\n  // group.name exists\n  return data[group.name]\n}\n```\n\n**Signature:**\n\n```ts\ngroupHasName(group: Partial<NamedGroupFieldClient>): group is NamedGroupFieldClient\n```\n\n## Option & Value Guards\n\n### optionIsObject\n\nChecks if option is object format `{label, value}` vs string.\n\n```ts\nimport { optionIsObject } from 'payload'\n\nfield.options.forEach((option) => {\n  if (optionIsObject(option)) {\n    console.log(`${option.label}: ${option.value}`)\n  } else {\n    console.log(option) // string value\n  }\n})\n```\n\n**Signature:**\n\n```ts\noptionIsObject(option: Option): option is OptionObject\n```\n\n### optionsAreObjects\n\nChecks if entire options array contains objects.\n\n```ts\nimport { optionsAreObjects } from 'payload'\n\nif (optionsAreObjects(field.options)) {\n  // All options are OptionObject[]\n  const labels = field.options.map((opt) => opt.label)\n}\n```\n\n**Signature:**\n\n```ts\noptionsAreObjects(options: Option[]): options is OptionObject[]\n```\n\n### optionIsValue\n\nChecks if option is string value (not object).\n\n```ts\nimport { optionIsValue } from 'payload'\n\nif (optionIsValue(option)) {\n  // option is string\n  const value = option\n}\n```\n\n**Signature:**\n\n```ts\noptionIsValue(option: Option): option is string\n```\n\n### valueIsValueWithRelation\n\nChecks if relationship value is polymorphic format `{relationTo, value}`.\n\n```ts\nimport { valueIsValueWithRelation } from 'payload'\n\nif (valueIsValueWithRelation(fieldValue)) {\n  // fieldValue.relationTo exists\n  // fieldValue.value exists\n  console.log(`Related to ${fieldValue.relationTo}: ${fieldValue.value}`)\n}\n```\n\n**Signature:**\n\n```ts\nvalueIsValueWithRelation(value: unknown): value is ValueWithRelation\n```\n\n## Common Patterns\n\n### Recursive Field Traversal\n\n```ts\nimport { fieldAffectsData, fieldHasSubFields } from 'payload'\n\nfunction traverseFields(fields: Field[], callback: (field: Field) => void) {\n  fields.forEach((field) => {\n    if (fieldAffectsData(field)) {\n      callback(field)\n    }\n\n    if (fieldHasSubFields(field)) {\n      traverseFields(field.fields, callback)\n    }\n  })\n}\n```\n\n### Filter Data-Bearing Fields\n\n```ts\nimport { fieldAffectsData, fieldIsPresentationalOnly, fieldIsHiddenOrDisabled } from 'payload'\n\nconst dataFields = fields.filter(\n  (field) =>\n    fieldAffectsData(field) && !fieldIsPresentationalOnly(field) && !fieldIsHiddenOrDisabled(field),\n)\n```\n\n### Container Type Switching\n\n```ts\nimport { fieldIsArrayType, fieldIsBlockType, fieldHasSubFields } from 'payload'\n\nif (fieldIsArrayType(field)) {\n  // Handle array-specific logic\n} else if (fieldIsBlockType(field)) {\n  // Handle blocks-specific logic\n} else if (fieldHasSubFields(field)) {\n  // Handle group/row/collapsible\n}\n```\n\n### Safe Property Access\n\n```ts\nimport { fieldSupportsMany, fieldHasMaxDepth } from 'payload'\n\n// Without guard - TypeScript error\n// if (field.hasMany) { /* ... */ }\n\n// With guard - safe access\nif (fieldSupportsMany(field) && field.hasMany) {\n  console.log('Multiple values supported')\n}\n\nif (fieldHasMaxDepth(field)) {\n  const depth = field.maxDepth // TypeScript knows this is number\n}\n```\n\n## Type Preservation\n\nAll guards preserve the original type constraint:\n\n```ts\nimport type { ClientField, Field } from 'payload'\nimport { fieldHasSubFields } from 'payload'\n\nfunction processServerField(field: Field) {\n  if (fieldHasSubFields(field)) {\n    // field is Field & FieldWithSubFields (not ClientField)\n  }\n}\n\nfunction processClientField(field: ClientField) {\n  if (fieldHasSubFields(field)) {\n    // field is ClientField & FieldWithSubFieldsClient\n  }\n}\n```\n",
        "tools/claude-plugin/skills/payload/reference/FIELDS.md": "# Payload CMS Field Types Reference\n\nComplete reference for all Payload field types with examples.\n\n## Text Field\n\n```ts\nimport type { TextField } from 'payload'\n\nconst textField: TextField = {\n  name: 'title',\n  type: 'text',\n  required: true,\n  unique: true,\n  minLength: 5,\n  maxLength: 100,\n  index: true,\n  localized: true,\n  defaultValue: 'Default Title',\n  validate: (value) => Boolean(value) || 'Required',\n  admin: {\n    placeholder: 'Enter title...',\n    position: 'sidebar',\n    condition: (data) => data.showTitle === true,\n  },\n}\n```\n\n### Slug Field Helper\n\nBuilt-in helper for auto-generating slugs:\n\n```ts\nimport { slugField } from 'payload'\nimport type { CollectionConfig } from 'payload'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    { name: 'title', type: 'text', required: true },\n    slugField({\n      name: 'slug', // defaults to 'slug'\n      useAsSlug: 'title', // defaults to 'title'\n      checkboxName: 'generateSlug', // defaults to 'generateSlug'\n      localized: true,\n      required: true,\n      overrides: (defaultField) => {\n        // Customize the generated fields if needed\n        return defaultField\n      },\n    }),\n  ],\n}\n```\n\n## Rich Text (Lexical)\n\n```ts\nimport type { RichTextField } from 'payload'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\nimport { HeadingFeature, LinkFeature } from '@payloadcms/richtext-lexical'\n\nconst richTextField: RichTextField = {\n  name: 'content',\n  type: 'richText',\n  required: true,\n  localized: true,\n  editor: lexicalEditor({\n    features: ({ defaultFeatures }) => [\n      ...defaultFeatures,\n      HeadingFeature({\n        enabledHeadingSizes: ['h1', 'h2', 'h3'],\n      }),\n      LinkFeature({\n        enabledCollections: ['posts', 'pages'],\n      }),\n    ],\n  }),\n}\n```\n\n### Advanced Lexical Configuration\n\n```ts\nimport {\n  BoldFeature,\n  EXPERIMENTAL_TableFeature,\n  FixedToolbarFeature,\n  HeadingFeature,\n  IndentFeature,\n  InlineToolbarFeature,\n  ItalicFeature,\n  LinkFeature,\n  OrderedListFeature,\n  UnderlineFeature,\n  UnorderedListFeature,\n  lexicalEditor,\n} from '@payloadcms/richtext-lexical'\n\n// Global editor config with full features\nexport default buildConfig({\n  editor: lexicalEditor({\n    features: () => {\n      return [\n        UnderlineFeature(),\n        BoldFeature(),\n        ItalicFeature(),\n        OrderedListFeature(),\n        UnorderedListFeature(),\n        LinkFeature({\n          enabledCollections: ['pages'],\n          fields: ({ defaultFields }) => {\n            const defaultFieldsWithoutUrl = defaultFields.filter((field) => {\n              if ('name' in field && field.name === 'url') return false\n              return true\n            })\n\n            return [\n              ...defaultFieldsWithoutUrl,\n              {\n                name: 'url',\n                type: 'text',\n                admin: {\n                  condition: ({ linkType }) => linkType !== 'internal',\n                },\n                label: ({ t }) => t('fields:enterURL'),\n                required: true,\n              },\n            ]\n          },\n        }),\n        IndentFeature(),\n        EXPERIMENTAL_TableFeature(),\n      ]\n    },\n  }),\n})\n\n// Field-specific editor with custom toolbar\nconst richTextWithToolbars: RichTextField = {\n  name: 'richText',\n  type: 'richText',\n  editor: lexicalEditor({\n    features: ({ rootFeatures }) => {\n      return [\n        ...rootFeatures,\n        HeadingFeature({ enabledHeadingSizes: ['h2', 'h3', 'h4'] }),\n        FixedToolbarFeature(),\n        InlineToolbarFeature(),\n      ]\n    },\n  }),\n  label: false,\n}\n```\n\n## Relationship\n\n```ts\nimport type { RelationshipField } from 'payload'\n\n// Single relationship\nconst singleRelationship: RelationshipField = {\n  name: 'author',\n  type: 'relationship',\n  relationTo: 'users',\n  required: true,\n  maxDepth: 2,\n}\n\n// Multiple relationships (hasMany)\nconst multipleRelationship: RelationshipField = {\n  name: 'categories',\n  type: 'relationship',\n  relationTo: 'categories',\n  hasMany: true,\n  filterOptions: {\n    active: { equals: true },\n  },\n}\n\n// Polymorphic relationship\nconst polymorphicRelationship: PolymorphicRelationshipField = {\n  name: 'relatedContent',\n  type: 'relationship',\n  relationTo: ['posts', 'pages'],\n  hasMany: true,\n}\n```\n\n## Array\n\n```ts\nimport type { ArrayField } from 'payload'\n\nconst arrayField: ArrayField = {\n  name: 'slides',\n  type: 'array',\n  minRows: 2,\n  maxRows: 10,\n  labels: {\n    singular: 'Slide',\n    plural: 'Slides',\n  },\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'image',\n      type: 'upload',\n      relationTo: 'media',\n    },\n  ],\n  admin: {\n    initCollapsed: true,\n  },\n}\n```\n\n## Blocks\n\n```ts\nimport type { BlocksField, Block } from 'payload'\n\nconst HeroBlock: Block = {\n  slug: 'hero',\n  interfaceName: 'HeroBlock',\n  fields: [\n    {\n      name: 'heading',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'background',\n      type: 'upload',\n      relationTo: 'media',\n    },\n  ],\n}\n\nconst ContentBlock: Block = {\n  slug: 'content',\n  fields: [\n    {\n      name: 'text',\n      type: 'richText',\n    },\n  ],\n}\n\nconst blocksField: BlocksField = {\n  name: 'layout',\n  type: 'blocks',\n  blocks: [HeroBlock, ContentBlock],\n}\n```\n\n## Select\n\n```ts\nimport type { SelectField } from 'payload'\n\nconst selectField: SelectField = {\n  name: 'status',\n  type: 'select',\n  options: [\n    { label: 'Draft', value: 'draft' },\n    { label: 'Published', value: 'published' },\n  ],\n  defaultValue: 'draft',\n  required: true,\n}\n\n// Multiple select\nconst multiSelectField: SelectField = {\n  name: 'tags',\n  type: 'select',\n  hasMany: true,\n  options: ['tech', 'news', 'sports'],\n}\n```\n\n## Upload\n\n```ts\nimport type { UploadField } from 'payload'\n\nconst uploadField: UploadField = {\n  name: 'featuredImage',\n  type: 'upload',\n  relationTo: 'media',\n  required: true,\n  filterOptions: {\n    mimeType: { contains: 'image' },\n  },\n}\n```\n\n## Point (Geolocation)\n\nPoint fields store geographic coordinates with automatic 2dsphere indexing for geospatial queries.\n\n```ts\nimport type { PointField } from 'payload'\n\nconst locationField: PointField = {\n  name: 'location',\n  type: 'point',\n  label: 'Location',\n  required: true,\n}\n\n// Returns [longitude, latitude]\n// Example: [-122.4194, 37.7749] for San Francisco\n```\n\n### Geospatial Queries\n\n```ts\n// Query by distance (sorted by nearest first)\nconst nearbyLocations = await payload.find({\n  collection: 'stores',\n  where: {\n    location: {\n      near: [10, 20], // [longitude, latitude]\n      maxDistance: 5000, // in meters\n      minDistance: 1000,\n    },\n  },\n})\n\n// Query within polygon area\nconst polygon: Point[] = [\n  [9.0, 19.0], // bottom-left\n  [9.0, 21.0], // top-left\n  [11.0, 21.0], // top-right\n  [11.0, 19.0], // bottom-right\n  [9.0, 19.0], // closing point\n]\n\nconst withinArea = await payload.find({\n  collection: 'stores',\n  where: {\n    location: {\n      within: {\n        type: 'Polygon',\n        coordinates: [polygon],\n      },\n    },\n  },\n})\n\n// Query intersecting area\nconst intersecting = await payload.find({\n  collection: 'stores',\n  where: {\n    location: {\n      intersects: {\n        type: 'Polygon',\n        coordinates: [polygon],\n      },\n    },\n  },\n})\n```\n\n**Note**: Point fields are not supported in SQLite.\n\n## Join Fields\n\nJoin fields create reverse relationships, allowing you to access related documents from the \"other side\" of a relationship.\n\n```ts\nimport type { JoinField } from 'payload'\n\n// From Users collection - show user's orders\nconst ordersJoinField: JoinField = {\n  name: 'orders',\n  type: 'join',\n  collection: 'orders',\n  on: 'customer', // The field in 'orders' that references this user\n  admin: {\n    allowCreate: false,\n    defaultColumns: ['id', 'createdAt', 'total', 'currency', 'items'],\n  },\n}\n\n// From Users collection - show user's cart\nconst cartJoinField: JoinField = {\n  name: 'cart',\n  type: 'join',\n  collection: 'carts',\n  on: 'customer',\n  admin: {\n    allowCreate: false,\n    defaultColumns: ['id', 'createdAt', 'total', 'currency'],\n  },\n}\n```\n\n## Virtual Fields\n\n```ts\nimport type { TextField } from 'payload'\n\n// Computed from siblings\nconst computedVirtualField: TextField = {\n  name: 'fullName',\n  type: 'text',\n  virtual: true,\n  hooks: {\n    afterRead: [({ siblingData }) => `${siblingData.firstName} ${siblingData.lastName}`],\n  },\n}\n\n// From relationship path\nconst pathVirtualField: TextField = {\n  name: 'authorName',\n  type: 'text',\n  virtual: 'author.name',\n}\n```\n\n## Conditional Fields\n\n```ts\nimport type { UploadField, CheckboxField } from 'payload'\n\n// Simple boolean condition\nconst enableFeatureField: CheckboxField = {\n  name: 'enableFeature',\n  type: 'checkbox',\n}\n\nconst conditionalField: TextField = {\n  name: 'featureText',\n  type: 'text',\n  admin: {\n    condition: (data) => data.enableFeature === true,\n  },\n}\n\n// Sibling data condition (from hero field pattern)\nconst typeField: SelectField = {\n  name: 'type',\n  type: 'select',\n  options: ['none', 'highImpact', 'mediumImpact', 'lowImpact'],\n  defaultValue: 'lowImpact',\n}\n\nconst mediaField: UploadField = {\n  name: 'media',\n  type: 'upload',\n  relationTo: 'media',\n  admin: {\n    condition: (_, { type } = {}) => ['highImpact', 'mediumImpact'].includes(type),\n  },\n  required: true,\n}\n```\n\n## Radio\n\nRadio fields present options as radio buttons for single selection.\n\n```ts\nimport type { RadioField } from 'payload'\n\nconst radioField: RadioField = {\n  name: 'priority',\n  type: 'radio',\n  options: [\n    { label: 'Low', value: 'low' },\n    { label: 'Medium', value: 'medium' },\n    { label: 'High', value: 'high' },\n  ],\n  defaultValue: 'medium',\n  admin: {\n    layout: 'horizontal', // or 'vertical'\n  },\n}\n```\n\n## Row (Layout)\n\nRow fields arrange fields horizontally in the admin panel (presentational only).\n\n```ts\nimport type { RowField } from 'payload'\n\nconst rowField: RowField = {\n  type: 'row',\n  fields: [\n    {\n      name: 'firstName',\n      type: 'text',\n      admin: { width: '50%' },\n    },\n    {\n      name: 'lastName',\n      type: 'text',\n      admin: { width: '50%' },\n    },\n  ],\n}\n```\n\n## Collapsible (Layout)\n\nCollapsible fields group fields in an expandable/collapsible section.\n\n```ts\nimport type { CollapsibleField } from 'payload'\n\nconst collapsibleField: CollapsibleField = {\n  label: ({ data }) => data?.title || 'Advanced Options',\n  type: 'collapsible',\n  admin: {\n    initCollapsed: true,\n  },\n  fields: [\n    { name: 'customCSS', type: 'textarea' },\n    { name: 'customJS', type: 'code' },\n  ],\n}\n```\n\n## UI (Custom Components)\n\nUI fields allow fully custom React components in the admin (no data stored).\n\n```ts\nimport type { UIField } from 'payload'\n\nconst uiField: UIField = {\n  name: 'customMessage',\n  type: 'ui',\n  admin: {\n    components: {\n      Field: '/path/to/CustomFieldComponent',\n      Cell: '/path/to/CustomCellComponent', // For list view\n    },\n  },\n}\n```\n\n## Tabs & Groups\n\n```ts\nimport type { TabsField, GroupField } from 'payload'\n\n// Tabs\nconst tabsField: TabsField = {\n  type: 'tabs',\n  tabs: [\n    {\n      label: 'Content',\n      fields: [\n        { name: 'title', type: 'text' },\n        { name: 'body', type: 'richText' },\n      ],\n    },\n    {\n      label: 'SEO',\n      fields: [\n        { name: 'metaTitle', type: 'text' },\n        { name: 'metaDescription', type: 'textarea' },\n      ],\n    },\n  ],\n}\n\n// Group (named)\nconst groupField: GroupField = {\n  name: 'meta',\n  type: 'group',\n  fields: [\n    { name: 'title', type: 'text' },\n    { name: 'description', type: 'textarea' },\n  ],\n}\n```\n\n## Reusable Field Factories\n\nCreate composable field patterns that can be customized with overrides.\n\n```ts\nimport type { Field, GroupField } from 'payload'\n\n// Utility for deep merging\nconst deepMerge = <T>(target: T, source: Partial<T>): T => {\n  // Implementation would deeply merge objects\n  return { ...target, ...source }\n}\n\n// Reusable link field factory\ntype LinkType = (options?: {\n  appearances?: ('default' | 'outline')[] | false\n  disableLabel?: boolean\n  overrides?: Record<string, unknown>\n}) => GroupField\n\nexport const link: LinkType = ({ appearances, disableLabel = false, overrides = {} } = {}) => {\n  const linkField: GroupField = {\n    name: 'link',\n    type: 'group',\n    admin: {\n      hideGutter: true,\n    },\n    fields: [\n      {\n        type: 'row',\n        fields: [\n          {\n            name: 'type',\n            type: 'radio',\n            options: [\n              { label: 'Internal link', value: 'reference' },\n              { label: 'Custom URL', value: 'custom' },\n            ],\n            defaultValue: 'reference',\n            admin: {\n              layout: 'horizontal',\n              width: '50%',\n            },\n          },\n          {\n            name: 'newTab',\n            type: 'checkbox',\n            label: 'Open in new tab',\n            admin: {\n              width: '50%',\n              style: {\n                alignSelf: 'flex-end',\n              },\n            },\n          },\n        ],\n      },\n      {\n        name: 'reference',\n        type: 'relationship',\n        relationTo: ['pages'],\n        required: true,\n        maxDepth: 1,\n        admin: {\n          condition: (_, siblingData) => siblingData?.type === 'reference',\n        },\n      },\n      {\n        name: 'url',\n        type: 'text',\n        label: 'Custom URL',\n        required: true,\n        admin: {\n          condition: (_, siblingData) => siblingData?.type === 'custom',\n        },\n      },\n    ],\n  }\n\n  if (!disableLabel) {\n    linkField.fields.push({\n      name: 'label',\n      type: 'text',\n      required: true,\n    })\n  }\n\n  if (appearances !== false) {\n    linkField.fields.push({\n      name: 'appearance',\n      type: 'select',\n      defaultValue: 'default',\n      options: [\n        { label: 'Default', value: 'default' },\n        { label: 'Outline', value: 'outline' },\n      ],\n    })\n  }\n\n  return deepMerge(linkField, overrides) as GroupField\n}\n\n// Usage\nconst navItem = link({ appearances: false })\nconst ctaButton = link({\n  overrides: {\n    name: 'cta',\n    admin: {\n      description: 'Call to action button',\n    },\n  },\n})\n```\n\n## Field Type Guards\n\nType guards for runtime field type checking and safe type narrowing.\n\n| Type Guard                  | Checks For                                                  | Use When                                 |\n| --------------------------- | ----------------------------------------------------------- | ---------------------------------------- |\n| `fieldAffectsData`          | Field stores data (has name, not UI-only)                   | Need to access field data or name        |\n| `fieldHasSubFields`         | Field contains nested fields (group/array/row/collapsible)  | Need to recursively traverse fields      |\n| `fieldIsArrayType`          | Field is array type                                         | Distinguish arrays from other containers |\n| `fieldIsBlockType`          | Field is blocks type                                        | Handle blocks-specific logic             |\n| `fieldIsGroupType`          | Field is group type                                         | Handle group-specific logic              |\n| `fieldSupportsMany`         | Field can have multiple values (select/relationship/upload) | Check for `hasMany` support              |\n| `fieldHasMaxDepth`          | Field supports population depth control                     | Control relationship/upload/join depth   |\n| `fieldIsPresentationalOnly` | Field is UI-only (no data storage)                          | Exclude from data operations             |\n| `fieldIsSidebar`            | Field positioned in sidebar                                 | Separate sidebar rendering               |\n| `fieldIsID`                 | Field name is 'id'                                          | Special ID field handling                |\n| `fieldIsHiddenOrDisabled`   | Field is hidden or disabled                                 | Filter from UI operations                |\n| `fieldShouldBeLocalized`    | Field needs localization handling                           | Proper locale table checks               |\n| `fieldIsVirtual`            | Field is virtual (computed/no DB column)                    | Skip in database transforms              |\n| `tabHasName`                | Tab is named (stores data)                                  | Distinguish named vs unnamed tabs        |\n| `groupHasName`              | Group is named (stores data)                                | Distinguish named vs unnamed groups      |\n| `optionIsObject`            | Option is `{label, value}` format                           | Access option properties safely          |\n| `optionsAreObjects`         | All options are objects                                     | Batch option processing                  |\n| `optionIsValue`             | Option is string value                                      | Handle string options                    |\n| `valueIsValueWithRelation`  | Value is polymorphic relationship                           | Handle polymorphic relationships         |\n\n```ts\nimport { fieldAffectsData, fieldHasSubFields, fieldIsArrayType } from 'payload'\n\nfunction processField(field: Field) {\n  if (fieldAffectsData(field)) {\n    // Safe to access field.name\n    console.log(field.name)\n  }\n\n  if (fieldHasSubFields(field)) {\n    // Safe to access field.fields\n    field.fields.forEach(processField)\n  }\n}\n```\n\nSee [FIELD-TYPE-GUARDS.md](FIELD-TYPE-GUARDS.md) for detailed usage patterns.\n",
        "tools/claude-plugin/skills/payload/reference/HOOKS.md": "# Payload CMS Hooks Reference\n\nComplete reference for collection hooks, field hooks, and hook context patterns.\n\n## Collection Hooks\n\n```ts\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  hooks: {\n    // Before validation\n    beforeValidate: [\n      async ({ data, operation }) => {\n        if (operation === 'create') {\n          data.slug = slugify(data.title)\n        }\n        return data\n      },\n    ],\n\n    // Before save\n    beforeChange: [\n      async ({ data, req, operation, originalDoc }) => {\n        if (operation === 'update' && data.status === 'published') {\n          data.publishedAt = new Date()\n        }\n        return data\n      },\n    ],\n\n    // After save\n    afterChange: [\n      async ({ doc, req, operation, previousDoc }) => {\n        if (operation === 'create') {\n          await sendNotification(doc)\n        }\n        return doc\n      },\n    ],\n\n    // After read\n    afterRead: [\n      async ({ doc, req }) => {\n        doc.viewCount = await getViewCount(doc.id)\n        return doc\n      },\n    ],\n\n    // Before delete\n    beforeDelete: [\n      async ({ req, id }) => {\n        await cleanupRelatedData(id)\n      },\n    ],\n  },\n}\n```\n\n## Field Hooks\n\n```ts\nimport type { EmailField, FieldHook } from 'payload'\n\nconst beforeValidateHook: FieldHook = ({ value }) => {\n  return value.trim().toLowerCase()\n}\n\nconst afterReadHook: FieldHook = ({ value, req }) => {\n  // Hide email from non-admins\n  if (!req.user?.roles?.includes('admin')) {\n    return value.replace(/(.{2})(.*)(@.*)/, '$1***$3')\n  }\n  return value\n}\n\nconst emailField: EmailField = {\n  name: 'email',\n  type: 'email',\n  hooks: {\n    beforeValidate: [beforeValidateHook],\n    afterRead: [afterReadHook],\n  },\n}\n```\n\n## Hook Context\n\nShare data between hooks or control hook behavior using request context:\n\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  hooks: {\n    beforeChange: [\n      async ({ context }) => {\n        context.expensiveData = await fetchExpensiveData()\n      },\n    ],\n    afterChange: [\n      async ({ context, doc }) => {\n        // Reuse from previous hook\n        await processData(doc, context.expensiveData)\n      },\n    ],\n  },\n  fields: [{ name: 'title', type: 'text' }],\n}\n```\n\n## Next.js Revalidation with Context Control\n\n```ts\nimport type { CollectionAfterChangeHook, CollectionAfterDeleteHook } from 'payload'\nimport { revalidatePath } from 'next/cache'\nimport type { Page } from '../payload-types'\n\nexport const revalidatePage: CollectionAfterChangeHook<Page> = ({\n  doc,\n  previousDoc,\n  req: { payload, context },\n}) => {\n  if (!context.disableRevalidate) {\n    if (doc._status === 'published') {\n      const path = doc.slug === 'home' ? '/' : `/${doc.slug}`\n      payload.logger.info(`Revalidating page at path: ${path}`)\n      revalidatePath(path)\n    }\n\n    // Revalidate old path if unpublished\n    if (previousDoc?._status === 'published' && doc._status !== 'published') {\n      const oldPath = previousDoc.slug === 'home' ? '/' : `/${previousDoc.slug}`\n      payload.logger.info(`Revalidating old page at path: ${oldPath}`)\n      revalidatePath(oldPath)\n    }\n  }\n  return doc\n}\n\nexport const revalidateDelete: CollectionAfterDeleteHook<Page> = ({ doc, req: { context } }) => {\n  if (!context.disableRevalidate) {\n    const path = doc?.slug === 'home' ? '/' : `/${doc?.slug}`\n    revalidatePath(path)\n  }\n  return doc\n}\n```\n\n## Date Field Auto-Set\n\nAutomatically set date when document is published:\n\n```ts\nimport type { DateField } from 'payload'\n\nconst publishedOnField: DateField = {\n  name: 'publishedOn',\n  type: 'date',\n  admin: {\n    date: {\n      pickerAppearance: 'dayAndTime',\n    },\n    position: 'sidebar',\n  },\n  hooks: {\n    beforeChange: [\n      ({ siblingData, value }) => {\n        if (siblingData._status === 'published' && !value) {\n          return new Date()\n        }\n        return value\n      },\n    ],\n  },\n}\n```\n\n## Hook Patterns Best Practices\n\n- Use `beforeValidate` for data formatting\n- Use `beforeChange` for business logic\n- Use `afterChange` for side effects\n- Use `afterRead` for computed fields\n- Store expensive operations in `context`\n- Pass `req` to nested operations for transaction safety (see [ADAPTERS.md#threading-req-through-operations](ADAPTERS.md#threading-req-through-operations))\n",
        "tools/claude-plugin/skills/payload/reference/PLUGIN-DEVELOPMENT.md": "# Payload Plugin Development\n\nComplete guide to creating Payload CMS plugins with TypeScript patterns, package structure, and best practices from the official Payload plugin template.\n\n## Plugin Architecture\n\nPlugins are functions that receive configuration options and return a function that transforms the Payload config:\n\n```ts\nimport type { Config, Plugin } from 'payload'\n\ninterface MyPluginConfig {\n  enabled?: boolean\n  collections?: string[]\n}\n\nexport const myPlugin =\n  (options: MyPluginConfig): Plugin =>\n  (config: Config): Config => ({\n    ...config,\n    // Transform config here\n  })\n```\n\n**Key Pattern:** Double arrow function (currying)\n\n- First function: Accepts plugin options, returns plugin function\n- Second function: Accepts Payload config, returns modified config\n\n## Plugin Package Structure\n\n### Simple Structure\n\n```\nplugin-<name>/\n├── package.json              # Package metadata and dependencies\n├── README.md                 # Plugin documentation\n├── LICENSE.md                # License file\n└── src/\n    ├── index.ts              # Entry point, re-exports plugin and config types\n    ├── plugin.ts             # Plugin implementation\n    ├── types.ts              # TypeScript type definitions\n    └── exports/              # Additional entry points (optional)\n        └── types.ts          # Type-only exports\n```\n\n### Exhaustive Structure\n\n```\nplugin-<name>/\n├── .swcrc                    # SWC compiler config\n├── package.json              # Package metadata and dependencies\n├── tsconfig.json             # TypeScript config\n├── README.md                 # Plugin documentation\n├── LICENSE.md                # License file\n├── eslint.config.js          # ESLint configuration (optional)\n├── vitest.config.js          # Vitest test configuration (optional)\n├── playwright.config.js      # Playwright e2e tests (optional)\n└── src/\n    ├── index.ts              # Entry point, re-exports plugin and config types\n    ├── plugin.ts             # Plugin implementation\n    ├── types.ts              # TypeScript type definitions\n    ├── defaults.ts           # Default configuration values (optional)\n    ├── endpoints/            # Custom API endpoints (optional)\n    │   └── handler.ts\n    ├── components/           # React components (optional)\n    │   ├── ClientComponent.tsx    # 'use client' components\n    │   └── ServerComponent.tsx    # RSC components\n    ├── fields/               # Custom field components (optional)\n    │   ├── FieldName/\n    │   │   ├── index.ts      # Field config\n    │   │   └── Component.tsx # Client component\n    ├── exports/              # Additional entry points\n    │   ├── types.ts          # Type-only exports\n    │   ├── fields.ts         # Field-only exports\n    │   ├── client.ts         # Re-export client components\n    │   └── rsc.ts            # Re-export server components (RSC)\n    ├── translations/         # i18n translations (optional)\n    │   └── index.ts\n    └── ui/                   # Admin UI components (optional)\n        └── Component.tsx\n```\n\n**Key additions from official template:**\n\n- **dev/** directory with complete Payload project for local testing\n- **src/exports/rsc.ts** for React Server Component exports\n- **src/components/** for organizing React components\n- **src/endpoints/** for custom API endpoint handlers\n- Test configuration files (vitest.config.js, playwright.config.js)\n\n## Package.json Configuration\n\n```json\n{\n  \"name\": \"payload-plugin-example\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Payload CMS plugin\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\",\n      \"default\": \"./dist/index.js\"\n    },\n    \"./types\": {\n      \"import\": \"./dist/exports/types.js\",\n      \"types\": \"./dist/exports/types.d.ts\"\n    },\n    \"./client\": {\n      \"import\": \"./dist/exports/client.js\",\n      \"types\": \"./dist/exports/client.d.ts\"\n    },\n    \"./rsc\": {\n      \"import\": \"./dist/exports/rsc.js\",\n      \"types\": \"./dist/exports/rsc.d.ts\"\n    }\n  },\n  \"files\": [\"dist\"],\n  \"scripts\": {\n    \"build\": \"npm run copyfiles && npm run build:types && npm run build:swc\",\n    \"build:swc\": \"swc ./src -d ./dist --config-file .swcrc --strip-leading-paths\",\n    \"build:types\": \"tsc --emitDeclarationOnly --outDir dist\",\n    \"clean\": \"rimraf dist *.tsbuildinfo\",\n    \"copyfiles\": \"copyfiles -u 1 \\\"src/**/*.{html,css,scss,ttf,woff,woff2,eot,svg,jpg,png,json}\\\" dist/\",\n    \"dev\": \"next dev dev --turbo\",\n    \"dev:generate-types\": \"cross-env PAYLOAD_CONFIG_PATH=./dev/payload.config.ts payload generate:types\",\n    \"dev:payload\": \"cross-env PAYLOAD_CONFIG_PATH=./dev/payload.config.ts payload\",\n    \"test\": \"npm run test:int && npm run test:e2e\",\n    \"test:int\": \"vitest\",\n    \"test:e2e\": \"playwright test\",\n    \"lint\": \"eslint\",\n    \"lint:fix\": \"eslint ./src --fix\",\n    \"prepublishOnly\": \"npm run clean && npm run build\"\n  },\n  \"dependencies\": {\n    \"@payloadcms/translations\": \"^3.0.0\",\n    \"@payloadcms/ui\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"@payloadcms/db-mongodb\": \"^3.0.0\",\n    \"@payloadcms/next\": \"^3.0.0\",\n    \"@payloadcms/richtext-lexical\": \"^3.0.0\",\n    \"@playwright/test\": \"^1.40.0\",\n    \"@swc/cli\": \"^0.1.62\",\n    \"@swc/core\": \"^1.3.0\",\n    \"copyfiles\": \"^2.4.1\",\n    \"cross-env\": \"^7.0.3\",\n    \"eslint\": \"^9.0.0\",\n    \"next\": \"^15.4.10\",\n    \"payload\": \"^3.0.0\",\n    \"react\": \"^19.2.1\",\n    \"react-dom\": \"^19.2.1\",\n    \"rimraf\": \"^5.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vitest\": \"^3.0.0\"\n  },\n  \"peerDependencies\": {\n    \"payload\": \"^3.0.0\"\n  }\n}\n```\n\n**Key Points:**\n\n- `type: \"module\"` for ESM\n- Compiled output in `./dist`, source in `./src`\n- Payload as peer dependency (user installs it)\n- Multiple export entry points: main, `/types`, `/client`, `/rsc`\n- `/client` for client components, `/rsc` for React Server Components\n- SWC for fast compilation\n- Dev scripts for local development with Next.js\n- Test scripts for both integration (Vitest) and e2e (Playwright) tests\n- `prepublishOnly` ensures build before publish\n\n## Plugin Patterns\n\n### Adding Fields to Collections\n\n```ts\nimport type { Config, Plugin, Field } from 'payload'\n\nexport const seoPlugin =\n  (options: { collections?: string[] }): Plugin =>\n  (config: Config): Config => {\n    const seoFields: Field[] = [\n      {\n        name: 'meta',\n        type: 'group',\n        fields: [\n          { name: 'title', type: 'text' },\n          { name: 'description', type: 'textarea' },\n        ],\n      },\n    ]\n\n    return {\n      ...config,\n      collections: config.collections?.map((collection) => {\n        if (options.collections?.includes(collection.slug)) {\n          return {\n            ...collection,\n            fields: [...(collection.fields || []), ...seoFields],\n          }\n        }\n        return collection\n      }),\n    }\n  }\n```\n\n### Adding New Collections\n\n```ts\nimport type { Config, Plugin, CollectionConfig } from 'payload'\n\nexport const redirectsPlugin =\n  (options: { overrides?: Partial<CollectionConfig> }): Plugin =>\n  (config: Config): Config => {\n    const redirectsCollection: CollectionConfig = {\n      slug: 'redirects',\n      access: { read: () => true },\n      fields: [\n        { name: 'from', type: 'text', required: true, unique: true },\n        { name: 'to', type: 'text', required: true },\n      ],\n      ...options.overrides,\n    }\n\n    return {\n      ...config,\n      collections: [...(config.collections || []), redirectsCollection],\n    }\n  }\n```\n\n### Adding Hooks\n\n```ts\nimport type { Config, Plugin, CollectionAfterChangeHook } from 'payload'\n\nconst resaveChildrenHook: CollectionAfterChangeHook = async ({ doc, req, operation }) => {\n  if (operation === 'update') {\n    // Resave child documents\n    const children = await req.payload.find({\n      collection: 'pages',\n      where: { parent: { equals: doc.id } },\n    })\n\n    for (const child of children.docs) {\n      await req.payload.update({\n        collection: 'pages',\n        id: child.id,\n        data: child,\n      })\n    }\n  }\n  return doc\n}\n\nexport const nestedDocsPlugin =\n  (options: { collections: string[] }): Plugin =>\n  (config: Config): Config => ({\n    ...config,\n    collections: (config.collections || []).map((collection) => {\n      if (options.collections.includes(collection.slug)) {\n        return {\n          ...collection,\n          hooks: {\n            ...(collection.hooks || {}),\n            afterChange: [resaveChildrenHook, ...(collection.hooks?.afterChange || [])],\n          },\n        }\n      }\n      return collection\n    }),\n  })\n```\n\n### Adding Root-Level Endpoints\n\nAdd endpoints at the root config level (accessible at `/api/<path>`):\n\n```ts\nimport type { Config, Plugin, Endpoint } from 'payload'\n\nexport const seoPlugin =\n  (options: { generateTitle?: (doc: any) => string }): Plugin =>\n  (config: Config): Config => {\n    const generateTitleEndpoint: Endpoint = {\n      path: '/plugin-seo/generate-title',\n      method: 'post',\n      handler: async (req) => {\n        const data = await req.json?.()\n        const result = options.generateTitle ? options.generateTitle(data.doc) : ''\n        return Response.json({ result })\n      },\n    }\n\n    return {\n      ...config,\n      endpoints: [...(config.endpoints ?? []), generateTitleEndpoint],\n    }\n  }\n```\n\n**Example webhook endpoint:**\n\n```ts\n// Useful for integrations like Stripe\nconst webhookEndpoint: Endpoint = {\n  path: '/stripe/webhook',\n  method: 'post',\n  handler: async (req) => {\n    const signature = req.headers.get('stripe-signature')\n    const event = stripe.webhooks.constructEvent(\n      await req.text(),\n      signature,\n      process.env.STRIPE_WEBHOOK_SECRET,\n    )\n    // Handle webhook\n    return Response.json({ received: true })\n  },\n}\n```\n\n### Field Overrides with Defaults\n\n```ts\nimport type { Config, Plugin, Field } from 'payload'\n\ntype FieldsOverride = (args: { defaultFields: Field[] }) => Field[]\n\ninterface PluginConfig {\n  collections?: string[]\n  fields?: FieldsOverride\n}\n\nexport const myPlugin =\n  (options: PluginConfig): Plugin =>\n  (config: Config): Config => {\n    const defaultFields: Field[] = [\n      { name: 'title', type: 'text' },\n      { name: 'description', type: 'textarea' },\n    ]\n\n    const fields =\n      options.fields && typeof options.fields === 'function'\n        ? options.fields({ defaultFields })\n        : defaultFields\n\n    return {\n      ...config,\n      collections: config.collections?.map((collection) => {\n        if (options.collections?.includes(collection.slug)) {\n          return {\n            ...collection,\n            fields: [...(collection.fields || []), ...fields],\n          }\n        }\n        return collection\n      }),\n    }\n  }\n```\n\n### Tabs UI Pattern\n\n```ts\nimport type { Config, Plugin, TabsField, GroupField } from 'payload'\n\nexport const seoPlugin =\n  (options: { tabbedUI?: boolean }): Plugin =>\n  (config: Config): Config => {\n    const seoFields: GroupField[] = [\n      {\n        name: 'meta',\n        type: 'group',\n        fields: [{ name: 'title', type: 'text' }],\n      },\n    ]\n\n    return {\n      ...config,\n      collections: config.collections?.map((collection) => {\n        if (options.tabbedUI) {\n          const seoTabs: TabsField[] = [\n            {\n              type: 'tabs',\n              tabs: [\n                // If existing tabs, preserve them\n                ...(collection.fields?.[0]?.type === 'tabs'\n                  ? collection.fields[0].tabs\n                  : [\n                      {\n                        label: 'Content',\n                        fields: collection.fields || [],\n                      },\n                    ]),\n                // Add SEO tab\n                {\n                  label: 'SEO',\n                  fields: seoFields,\n                },\n              ],\n            },\n          ]\n\n          return {\n            ...collection,\n            fields: [\n              ...seoTabs,\n              ...(collection.fields?.[0]?.type === 'tabs' ? collection.fields.slice(1) : []),\n            ],\n          }\n        }\n\n        return {\n          ...collection,\n          fields: [...(collection.fields || []), ...seoFields],\n        }\n      }),\n    }\n  }\n```\n\n### Disable Plugin Pattern\n\nAllow users to disable plugin without removing it (important for database schema consistency):\n\n```ts\nimport type { Config, Plugin } from 'payload'\n\ninterface PluginConfig {\n  disabled?: boolean\n  collections?: string[]\n}\n\nexport const myPlugin =\n  (options: PluginConfig): Plugin =>\n  (config: Config): Config => {\n    // Always add collections/fields for database schema consistency\n    if (!config.collections) {\n      config.collections = []\n    }\n\n    config.collections.push({\n      slug: 'plugin-collection',\n      fields: [{ name: 'title', type: 'text' }],\n    })\n\n    // Add fields to specified collections\n    if (options.collections) {\n      for (const collectionSlug of options.collections) {\n        const collection = config.collections.find((c) => c.slug === collectionSlug)\n        if (collection) {\n          collection.fields.push({\n            name: 'addedByPlugin',\n            type: 'text',\n          })\n        }\n      }\n    }\n\n    // If disabled, return early but keep schema changes\n    if (options.disabled) {\n      return config\n    }\n\n    // Add endpoints, hooks, components only when enabled\n    config.endpoints = [\n      ...(config.endpoints ?? []),\n      {\n        path: '/my-endpoint',\n        method: 'get',\n        handler: async () => Response.json({ message: 'Hello' }),\n      },\n    ]\n\n    return config\n  }\n```\n\n### Admin Components\n\nAdd custom UI components to the admin panel:\n\n```ts\nimport type { Config, Plugin } from 'payload'\n\nexport const myPlugin =\n  (options: PluginConfig): Plugin =>\n  (config: Config): Config => {\n    if (!config.admin) config.admin = {}\n    if (!config.admin.components) config.admin.components = {}\n    if (!config.admin.components.beforeDashboard) {\n      config.admin.components.beforeDashboard = []\n    }\n\n    // Add client component\n    config.admin.components.beforeDashboard.push('my-plugin-name/client#BeforeDashboardClient')\n\n    // Add server component (RSC)\n    config.admin.components.beforeDashboard.push('my-plugin-name/rsc#BeforeDashboardServer')\n\n    return config\n  }\n```\n\n**Component file structure:**\n\n```tsx\n// src/components/BeforeDashboardClient.tsx\n'use client'\nimport { useConfig } from '@payloadcms/ui'\nimport { useEffect, useState } from 'react'\nimport { formatAdminURL } from 'payload/shared'\n\nexport const BeforeDashboardClient = () => {\n  const { config } = useConfig()\n  const [data, setData] = useState('')\n\n  useEffect(() => {\n    fetch(\n      formatAdminURL({\n        apiRoute: config.routes.api,\n        path: '/my-endpoint',\n      }),\n    )\n      .then((res) => res.json())\n      .then(setData)\n  }, [config.serverURL, config.routes.api])\n\n  return <div>Client Component: {data}</div>\n}\n\n// src/components/BeforeDashboardServer.tsx\nexport const BeforeDashboardServer = () => {\n  return <div>Server Component</div>\n}\n\n// src/exports/client.ts\nexport { BeforeDashboardClient } from '../components/BeforeDashboardClient.js'\n\n// src/exports/rsc.ts\nexport { BeforeDashboardServer } from '../components/BeforeDashboardServer.js'\n```\n\n### Translations (i18n)\n\n```ts\n// src/translations/index.ts\nexport const translations = {\n  en: {\n    'plugin-name:fieldLabel': 'Field Label',\n    'plugin-name:fieldDescription': 'Field description',\n  },\n  es: {\n    'plugin-name:fieldLabel': 'Etiqueta del campo',\n    'plugin-name:fieldDescription': 'Descripción del campo',\n  },\n}\n\n// src/plugin.ts\nimport { deepMergeSimple } from 'payload/shared'\nimport { translations } from './translations/index.js'\n\nexport const myPlugin =\n  (options: PluginConfig): Plugin =>\n  (config: Config): Config => ({\n    ...config,\n    i18n: {\n      ...config.i18n,\n      translations: deepMergeSimple(translations, config.i18n?.translations ?? {}),\n    },\n  })\n```\n\n### onInit Hook\n\n```ts\nexport const myPlugin =\n  (options: PluginConfig): Plugin =>\n  (config: Config): Config => {\n    const incomingOnInit = config.onInit\n\n    config.onInit = async (payload) => {\n      // IMPORTANT: Call existing onInit first\n      if (incomingOnInit) await incomingOnInit(payload)\n\n      // Plugin initialization\n      payload.logger.info('Plugin initialized')\n\n      // Example: Seed data\n      const { totalDocs } = await payload.count({\n        collection: 'plugin-collection',\n        where: { id: { equals: 'seeded-by-plugin' } },\n      })\n\n      if (totalDocs === 0) {\n        await payload.create({\n          collection: 'plugin-collection',\n          data: { id: 'seeded-by-plugin' },\n        })\n      }\n    }\n\n    return config\n  }\n```\n\n## TypeScript Patterns\n\n### Plugin Config Types\n\n```ts\nimport type { CollectionSlug, GlobalSlug, Field, CollectionConfig } from 'payload'\n\nexport type FieldsOverride = (args: { defaultFields: Field[] }) => Field[]\n\nexport interface MyPluginConfig {\n  /**\n   * Collections to enable this plugin for\n   */\n  collections?: CollectionSlug[]\n  /**\n   * Globals to enable this plugin for\n   */\n  globals?: GlobalSlug[]\n  /**\n   * Override default fields\n   */\n  fields?: FieldsOverride\n  /**\n   * Enable tabbed UI\n   */\n  tabbedUI?: boolean\n  /**\n   * Override collection config\n   */\n  overrides?: Partial<CollectionConfig>\n}\n```\n\n### Export Types\n\n```ts\n// src/exports/types.ts\nexport type { MyPluginConfig, FieldsOverride } from '../types.js'\n\n// Usage\nimport type { MyPluginConfig } from '@payloadcms/plugin-example/types'\n```\n\n## Client Components\n\n### Custom Field Component\n\n```tsx\n// src/fields/CustomField/Component.tsx\n'use client'\nimport { useField } from '@payloadcms/ui'\nimport type { TextFieldClientComponent } from 'payload'\n\nexport const CustomFieldComponent: TextFieldClientComponent = ({ field, path }) => {\n  const { value, setValue } = useField<string>({ path })\n\n  return (\n    <div>\n      <label>{field.label}</label>\n      <input value={value || ''} onChange={(e) => setValue(e.target.value)} />\n    </div>\n  )\n}\n```\n\n```ts\n// src/fields/CustomField/index.ts\nimport type { Field } from 'payload'\n\nexport const CustomField = (overrides?: Partial<Field>): Field => ({\n  name: 'customField',\n  type: 'text',\n  admin: {\n    components: {\n      Field: '/fields/CustomField/Component#CustomFieldComponent',\n    },\n  },\n  ...overrides,\n})\n```\n\n## Best Practices\n\n### Preserve Existing Config\n\nAlways spread existing config and add to arrays:\n\n```ts\n// ✅ Good\ncollections: [...(config.collections || []), newCollection]\n\n// ❌ Bad\ncollections: [newCollection]\n```\n\n### Respect User Overrides\n\nAllow users to override plugin defaults:\n\n```ts\nconst collection: CollectionConfig = {\n  slug: 'redirects',\n  fields: defaultFields,\n  ...options.overrides, // User overrides last\n}\n```\n\n### Conditional Logic\n\nCheck if collections/globals are enabled:\n\n```ts\ncollections: config.collections?.map((collection) => {\n  const isEnabled = options.collections?.includes(collection.slug)\n  if (isEnabled) {\n    // Transform collection\n  }\n  return collection\n})\n```\n\n### Hook Composition\n\nPreserve existing hooks:\n\n```ts\nhooks: {\n  ...collection.hooks,\n  afterChange: [\n    myHook,\n    ...(collection.hooks?.afterChange || []),\n  ],\n}\n```\n\n### Type Safety\n\nUse Payload's exported types:\n\n```ts\nimport type { Config, Plugin, CollectionConfig, Field, CollectionSlug, GlobalSlug } from 'payload'\n```\n\n### Field Path Imports\n\nUse absolute paths for client components:\n\n```ts\nadmin: {\n  components: {\n    Field: '/fields/CustomField/Component#CustomFieldComponent',\n  },\n}\n```\n\n### onInit Pattern\n\nAlways call existing `onInit` before your initialization. See [onInit Hook](#oninit-hook) pattern for full example.\n\n## Advanced Patterns\n\nThese patterns are extracted from official Payload plugins and represent production-ready techniques for complex plugin development.\n\n### Advanced Configuration\n\n#### Async Plugin Function\n\nAllow plugin function to be async for awaiting collection overrides or async operations:\n\n```ts\nexport const myPlugin =\n  (pluginConfig?: PluginConfig) =>\n  async (incomingConfig: Config): Promise<Config> => {\n    // Can await async operations during initialization\n    const customCollection = await pluginConfig.collectionOverride?.({\n      defaultCollection,\n    })\n\n    return {\n      ...incomingConfig,\n      collections: [...incomingConfig.collections, customCollection],\n    }\n  }\n```\n\n#### Collection Override with Async Support\n\nAllow users to override entire collections with async functions:\n\n```ts\ntype CollectionOverride = (args: {\n  defaultCollection: CollectionConfig\n}) => CollectionConfig | Promise<CollectionConfig>\n\ninterface PluginConfig {\n  products?: {\n    collectionOverride?: CollectionOverride\n  }\n}\n\n// In plugin\nconst defaultCollection = createProductsCollection(config)\nconst finalCollection = config.products?.collectionOverride\n  ? await config.products.collectionOverride({ defaultCollection })\n  : defaultCollection\n```\n\n#### Config Sanitization Pattern\n\nNormalize plugin configuration with defaults:\n\n```ts\nexport const sanitizePluginConfig = ({ pluginConfig }: Props): SanitizedPluginConfig => {\n  const config = { ...pluginConfig } as Partial<SanitizedPluginConfig>\n\n  // Normalize boolean|object configs\n  if (typeof config.addresses === 'undefined' || config.addresses === true) {\n    config.addresses = { addressFields: defaultAddressFields() }\n  } else if (config.addresses === false) {\n    config.addresses = null\n  }\n\n  // Validate required fields\n  if (!config.stripeSecretKey) {\n    throw new Error('Stripe secret key is required')\n  }\n\n  return config as SanitizedPluginConfig\n}\n\n// Use at plugin start\nexport const myPlugin =\n  (pluginConfig: PluginConfig): Plugin =>\n  (config) => {\n    const sanitized = sanitizePluginConfig({ pluginConfig })\n    // Use sanitized config throughout\n  }\n```\n\n#### Collection Slug Mapping\n\nTrack collection slugs when users can override them:\n\n```ts\ntype CollectionSlugMap = {\n  products: string\n  variants: string\n  orders: string\n}\n\nconst getCollectionSlugMap = ({ config }: { config: PluginConfig }): CollectionSlugMap => ({\n  products: config.products?.slug || 'products',\n  variants: config.variants?.slug || 'variants',\n  orders: config.orders?.slug || 'orders',\n})\n\n// Use throughout plugin\nconst collectionSlugMap = getCollectionSlugMap({ config: pluginConfig })\n\n// When creating relationship fields\n{\n  name: 'product',\n  type: 'relationship',\n  relationTo: collectionSlugMap.products,\n}\n```\n\n#### Multi-Collection Configuration\n\nPlugin operates on multiple collections with collection-specific config:\n\n```ts\ninterface PluginConfig {\n  sync: Array<{\n    collection: string\n    fields?: string[]\n    onSync?: (doc: any) => Promise<void>\n  }>\n}\n\n// In plugin\nfor (const collection of config.collections!) {\n  const syncConfig = pluginConfig.sync?.find((s) => s.collection === collection.slug)\n  if (!syncConfig) continue\n\n  collection.hooks.afterChange = [\n    ...(collection.hooks?.afterChange || []),\n    async ({ doc, operation }) => {\n      if (operation === 'create' || operation === 'update') {\n        await syncConfig.onSync?.(doc)\n      }\n    },\n  ]\n}\n```\n\n### TypeScript Extensions\n\n#### TypeScript Schema Extension\n\nAdd custom properties to generated TypeScript schema:\n\n```ts\nincomingConfig.typescript = incomingConfig.typescript || {}\nincomingConfig.typescript.schema = incomingConfig.typescript.schema || []\n\nincomingConfig.typescript.schema.push((args) => {\n  const { jsonSchema } = args\n\n  jsonSchema.properties.ecommerce = {\n    type: 'object',\n    properties: {\n      collections: {\n        type: 'object',\n        properties: {\n          products: { type: 'string' },\n          orders: { type: 'string' },\n        },\n      },\n    },\n  }\n\n  return jsonSchema\n})\n```\n\n#### Module Declaration Augmentation\n\nExtend Payload types for plugin-specific field properties:\n\n```ts\n// In plugin types file\ndeclare module 'payload' {\n  export interface FieldCustom {\n    'plugin-import-export'?: {\n      disabled?: boolean\n      toCSV?: (value: any) => string\n      fromCSV?: (value: string) => any\n    }\n  }\n}\n\n// Usage with TypeScript support\n{\n  name: 'price',\n  type: 'number',\n  custom: {\n    'plugin-import-export': {\n      toCSV: (value) => `$${value.toFixed(2)}`,\n      fromCSV: (value) => parseFloat(value.replace('$', '')),\n    },\n  },\n}\n```\n\n### Advanced Hooks\n\n#### Global Error Hooks\n\nAdd global error handling:\n\n```ts\nreturn {\n  ...config,\n  hooks: {\n    afterError: [\n      ...(config.hooks?.afterError ?? []),\n      async (args) => {\n        const { error } = args\n        const status = (error as APIError).status ?? 500\n\n        if (status >= 500 || captureErrors.includes(status)) {\n          captureException(error, {\n            tags: {\n              collection: args.collection?.slug,\n              operation: args.operation,\n            },\n            user: args.req?.user ? { id: args.req.user.id } : undefined,\n          })\n        }\n      },\n    ],\n  },\n}\n```\n\n#### Multiple Hook Types on Same Collection\n\nCoordinate multiple lifecycle hooks together for complex workflows (e.g., validation → sync → cache → cleanup):\n\n```ts\ncollection.hooks = {\n  ...collection.hooks,\n\n  beforeValidate: [\n    ...(collection.hooks?.beforeValidate || []),\n    async ({ data }) => {\n      // Normalize before validation\n      return data\n    },\n  ],\n\n  beforeChange: [\n    ...(collection.hooks?.beforeChange || []),\n    async ({ data, operation }) => {\n      // Sync to external service\n      if (operation === 'create') {\n        data.externalId = await externalService.create(data)\n      }\n      return data\n    },\n  ],\n\n  afterChange: [\n    ...(collection.hooks?.afterChange || []),\n    async ({ doc }) => {\n      // Invalidate cache\n      await cache.invalidate(`doc:${doc.id}`)\n    },\n  ],\n\n  afterDelete: [\n    ...(collection.hooks?.afterDelete || []),\n    async ({ doc }) => {\n      // Cleanup external resources\n      await externalService.delete(doc.externalId)\n    },\n  ],\n}\n```\n\n### Access Control & Filtering\n\n#### Access Control Wrapper Pattern\n\nWrap existing access control with plugin-specific logic:\n\n```ts\n// From plugin-multi-tenant\nexport const multiTenantPlugin =\n  (pluginOptions: PluginOptions) =>\n  (config: Config): Config => ({\n    ...config,\n    collections: (config.collections || []).map((collection) => {\n      if (!pluginOptions.collections.includes(collection.slug)) {\n        return collection\n      }\n\n      return {\n        ...collection,\n        access: {\n          ...collection.access,\n          read: ({ req }) => {\n            // Inject tenant filter\n            return {\n              and: [\n                collection.access?.read ? collection.access.read({ req }) : {},\n                { tenant: { equals: req.user?.tenant } },\n              ],\n            }\n          },\n        },\n      }\n    }),\n  })\n```\n\n#### BaseFilter Composition\n\nCombine plugin filters with existing baseListFilter:\n\n```ts\n// From plugin-multi-tenant\nconst existingBaseFilter = collection.admin?.baseListFilter\nconst tenantFilter = { tenant: { equals: req.user?.tenant } }\n\ncollection.admin = {\n  ...collection.admin,\n  baseListFilter: existingBaseFilter ? { and: [existingBaseFilter, tenantFilter] } : tenantFilter,\n}\n```\n\n#### Relationship FilterOptions Modification\n\nAdd filters to relationship field options:\n\n```ts\n// From plugin-multi-tenant\ncollection.fields = collection.fields.map((field) => {\n  if (field.type === 'relationship') {\n    return {\n      ...field,\n      filterOptions: ({ relationTo }) => {\n        return {\n          and: [field.filterOptions?.(relationTo) || {}, { tenant: { equals: req.user?.tenant } }],\n        }\n      },\n    }\n  }\n  return field\n})\n```\n\n### Admin UI Customization\n\n#### Metadata Storage Pattern\n\nUse admin.meta for plugin-specific UI state without database fields:\n\n```ts\n// From plugin-nested-docs\nexport const nestedDocsPlugin =\n  (pluginOptions: PluginOptions) =>\n  (config: Config): Config => ({\n    ...config,\n    collections: config.collections?.map((collection) => ({\n      ...collection,\n      admin: {\n        ...collection.admin,\n        meta: {\n          ...collection.admin?.meta,\n          nestedDocs: {\n            breadcrumbsFieldSlug: pluginOptions.breadcrumbsFieldSlug || 'breadcrumbs',\n            parentFieldSlug: pluginOptions.parentFieldSlug || 'parent',\n          },\n        },\n      },\n    })),\n  })\n```\n\n#### Conditional Component Rendering\n\nAdd components based on plugin configuration:\n\n```ts\n// From plugin-seo\nconst beforeFields = collection.admin?.components?.beforeFields || []\n\nif (pluginOptions.uploadsCollection === collection.slug) {\n  beforeFields.push('/path/to/ImagePreview#ImagePreview')\n}\n\ncollection.admin = {\n  ...collection.admin,\n  components: {\n    ...collection.admin?.components,\n    beforeFields,\n  },\n}\n```\n\n#### Custom Provider Pattern\n\nInject context providers for shared state:\n\n```ts\n// From plugin-nested-docs\ncollection.admin = {\n  ...collection.admin,\n  components: {\n    ...collection.admin?.components,\n    providers: [\n      ...(collection.admin?.components?.providers || []),\n      '/components/NestedDocsProvider#NestedDocsProvider',\n    ],\n  },\n}\n```\n\n#### Custom Actions\n\nAdd collection-level action buttons:\n\n```ts\n// From plugin-import-export\ncollection.admin = {\n  ...collection.admin,\n  components: {\n    ...collection.admin?.components,\n    actions: [\n      ...(collection.admin?.components?.actions || []),\n      '/components/ImportButton#ImportButton',\n      '/components/ExportButton#ExportButton',\n    ],\n  },\n}\n```\n\n#### Custom List Item Views\n\nModify how items appear in collection lists:\n\n```ts\n// From plugin-ecommerce\ncollection.admin = {\n  ...collection.admin,\n  components: {\n    ...collection.admin?.components,\n    views: {\n      ...collection.admin?.components?.views,\n      list: {\n        ...collection.admin?.components?.views?.list,\n        Component: '/views/ProductList#ProductList',\n      },\n    },\n  },\n}\n```\n\n#### Custom Collection Endpoints\n\nAdd collection-scoped endpoints (accessible at `/api/<collection-slug>/<path>`):\n\n```ts\n// From plugin-import-export\ncollection.endpoints = [\n  ...(collection.endpoints || []),\n  {\n    path: '/import',\n    method: 'post',\n    handler: async (req) => {\n      // Import logic accessible at /api/posts/import\n      return Response.json({ success: true })\n    },\n  },\n  {\n    path: '/export',\n    method: 'get',\n    handler: async (req) => {\n      // Export logic accessible at /api/posts/export\n      return Response.json({ data: exportedData })\n    },\n  },\n]\n```\n\n### Field & Collection Modifications\n\n#### Admin Folders Override\n\nControl admin UI organization:\n\n```ts\n// From plugin-redirects\ncollection.admin = {\n  ...collection.admin,\n  group: pluginOptions.group || 'Settings',\n  hidden: pluginOptions.hidden,\n  defaultColumns: pluginOptions.defaultColumns || ['from', 'to', 'updatedAt'],\n}\n```\n\n### Background Jobs & Async Operations\n\n#### Jobs Registration\n\nRegister plugin background tasks:\n\n```ts\n// From plugin-stripe\nexport const stripePlugin =\n  (pluginOptions: PluginOptions) =>\n  (config: Config): Config => ({\n    ...config,\n    jobs: {\n      ...config.jobs,\n      tasks: [\n        ...(config.jobs?.tasks || []),\n        {\n          slug: 'syncStripeProducts',\n          handler: async ({ req }) => {\n            const products = await stripe.products.list()\n            // Sync to Payload\n            return { output: { synced: products.data.length } }\n          },\n        },\n      ],\n    },\n  })\n```\n\n## Testing Plugins\n\n### Local Development with dev/ Directory (optional)\n\nInclude a `dev/` directory with a complete Payload project for local development:\n\n1. Create `dev/.env` from `.env.example`:\n\n```bash\nDATABASE_URL=mongodb://127.0.0.1/plugin-dev\nPAYLOAD_SECRET=your-secret-here\n```\n\n2. Configure `dev/payload.config.ts`:\n\n```ts\nimport { buildConfig } from 'payload'\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\nimport { myPlugin } from '../src/index.js'\n\nexport default buildConfig({\n  secret: process.env.PAYLOAD_SECRET!,\n  db: mongooseAdapter({ url: process.env.DATABASE_URL! }),\n  plugins: [\n    myPlugin({\n      collections: ['posts'],\n    }),\n  ],\n  collections: [\n    {\n      slug: 'posts',\n      fields: [{ name: 'title', type: 'text' }],\n    },\n  ],\n})\n```\n\n3. Run development server:\n\n```bash\nnpm run dev  # Starts Next.js on http://localhost:3000\n```\n\n### Integration Tests (Vitest) (optional)\n\nCreate `dev/int.spec.ts`:\n\n```ts\nimport type { Payload } from 'payload'\nimport config from '@payload-config'\nimport { createPayloadRequest, getPayload } from 'payload'\nimport { afterAll, beforeAll, describe, expect, test } from 'vitest'\nimport { customEndpointHandler } from '../src/endpoints/handler.js'\n\nlet payload: Payload\n\nbeforeAll(async () => {\n  payload = await getPayload({ config })\n})\n\nafterAll(async () => {\n  await payload.destroy()\n})\n\ndescribe('Plugin integration tests', () => {\n  test('should add field to collection', async () => {\n    const post = await payload.create({\n      collection: 'posts',\n      data: {\n        title: 'Test',\n        addedByPlugin: 'plugin value',\n      },\n    })\n    expect(post.addedByPlugin).toBe('plugin value')\n  })\n\n  test('should create plugin collection', async () => {\n    expect(payload.collections['plugin-collection']).toBeDefined()\n    const { docs } = await payload.find({ collection: 'plugin-collection' })\n    expect(docs.length).toBeGreaterThan(0)\n  })\n\n  test('should query custom endpoint', async () => {\n    const request = new Request('http://localhost:3000/api/my-endpoint')\n    const payloadRequest = await createPayloadRequest({ config, request })\n    const response = await customEndpointHandler(payloadRequest)\n    const data = await response.json()\n    expect(data).toMatchObject({ message: 'Hello' })\n  })\n})\n```\n\nRun: `npm run test:int`\n\n### End-to-End Tests (Playwright)\n\nCreate `dev/e2e.spec.ts`:\n\n```ts\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Plugin e2e tests', () => {\n  test('should render custom admin component', async ({ page }) => {\n    await page.goto('http://localhost:3000/admin')\n    await expect(page.getByText('Added by the plugin')).toBeVisible()\n  })\n})\n```\n\nRun: `npm run test:e2e`\n\n## Common Plugin Types\n\n### Field Enhancer\n\nAdds fields to existing collections (SEO, timestamps, audit logs)\n\n### Collection Provider\n\nAdds new collections (redirects, forms, logs)\n\n### Hook Injector\n\nAdds hooks to collections (nested docs, cache invalidation)\n\n### UI Enhancer\n\nAdds custom components (dashboards, field types)\n\n### Integration\n\nConnects external services (Stripe, Sentry, storage adapters)\n\n### Adapter\n\nProvides infrastructure (database, storage, email)\n\n## Resources\n\n- [Plugin Examples](https://github.com/payloadcms/payload/tree/main/packages/) - Official plugins source code, payload-\\* prefix\n- [Plugin Template](https://github.com/payloadcms/payload/tree/main/templates/plugin) - Starter template for new plugins\n",
        "tools/claude-plugin/skills/payload/reference/QUERIES.md": "# Payload CMS Querying Reference\n\nComplete reference for querying data across Local API, REST, and GraphQL.\n\n## Query Operators\n\n```ts\nimport type { Where } from 'payload'\n\n// Equals\nconst equalsQuery: Where = { color: { equals: 'blue' } }\n\n// Not equals\nconst notEqualsQuery: Where = { status: { not_equals: 'draft' } }\n\n// Greater/less than\nconst greaterThanQuery: Where = { price: { greater_than: 100 } }\nconst lessThanEqualQuery: Where = { age: { less_than_equal: 65 } }\n\n// Contains (case-insensitive)\nconst containsQuery: Where = { title: { contains: 'payload' } }\n\n// Like (all words present)\nconst likeQuery: Where = { description: { like: 'cms headless' } }\n\n// In/not in\nconst inQuery: Where = { category: { in: ['tech', 'news'] } }\n\n// Exists\nconst existsQuery: Where = { image: { exists: true } }\n\n// Near (point fields)\nconst nearQuery: Where = { location: { near: '-122.4194,37.7749,10000' } }\n```\n\n## AND/OR Logic\n\n```ts\nimport type { Where } from 'payload'\n\nconst complexQuery: Where = {\n  or: [\n    { color: { equals: 'mint' } },\n    {\n      and: [{ color: { equals: 'white' } }, { featured: { equals: false } }],\n    },\n  ],\n}\n```\n\n## Nested Properties\n\n```ts\nimport type { Where } from 'payload'\n\nconst nestedQuery: Where = {\n  'author.role': { equals: 'editor' },\n  'meta.featured': { exists: true },\n}\n```\n\n## Local API\n\n```ts\n// Find documents\nconst posts = await payload.find({\n  collection: 'posts',\n  where: {\n    status: { equals: 'published' },\n    'author.name': { contains: 'john' },\n  },\n  depth: 2,\n  limit: 10,\n  page: 1,\n  sort: '-createdAt',\n  locale: 'en',\n  select: {\n    title: true,\n    author: true,\n  },\n})\n\n// Find by ID\nconst post = await payload.findByID({\n  collection: 'posts',\n  id: '123',\n  depth: 2,\n})\n\n// Create\nconst post = await payload.create({\n  collection: 'posts',\n  data: {\n    title: 'New Post',\n    status: 'draft',\n  },\n})\n\n// Update\nawait payload.update({\n  collection: 'posts',\n  id: '123',\n  data: {\n    status: 'published',\n  },\n})\n\n// Delete\nawait payload.delete({\n  collection: 'posts',\n  id: '123',\n})\n\n// Count\nconst count = await payload.count({\n  collection: 'posts',\n  where: {\n    status: { equals: 'published' },\n  },\n})\n```\n\n### Threading req Parameter\n\nWhen performing operations in hooks or nested operations, pass the `req` parameter to maintain transaction context:\n\n```ts\n// ✅ CORRECT: Pass req for transaction safety\nconst afterChange: CollectionAfterChangeHook = async ({ doc, req }) => {\n  await req.payload.create({\n    collection: 'audit-log',\n    data: { action: 'created', docId: doc.id },\n    req, // Maintains transaction atomicity\n  })\n}\n\n// ❌ WRONG: Missing req breaks transaction\nconst afterChange: CollectionAfterChangeHook = async ({ doc, req }) => {\n  await req.payload.create({\n    collection: 'audit-log',\n    data: { action: 'created', docId: doc.id },\n    // Missing req - runs in separate transaction\n  })\n}\n```\n\nThis is critical for MongoDB replica sets and Postgres. See [ADAPTERS.md#threading-req-through-operations](ADAPTERS.md#threading-req-through-operations) for details.\n\n### Access Control in Local API\n\n**Important**: Local API bypasses access control by default (`overrideAccess: true`). When passing a `user` parameter, you must explicitly set `overrideAccess: false` to respect that user's permissions.\n\n```ts\n// ❌ WRONG: User is passed but access control is bypassed\nconst posts = await payload.find({\n  collection: 'posts',\n  user: currentUser,\n  // Missing: overrideAccess: false\n  // Result: Operation runs with ADMIN privileges, ignoring user's permissions\n})\n\n// ✅ CORRECT: Respects user's access control permissions\nconst posts = await payload.find({\n  collection: 'posts',\n  user: currentUser,\n  overrideAccess: false, // Required to enforce access control\n  // Result: User only sees posts they have permission to read\n})\n\n// Administrative operation (intentionally bypass access control)\nconst allPosts = await payload.find({\n  collection: 'posts',\n  // No user parameter\n  // overrideAccess defaults to true\n  // Result: Returns all posts regardless of access control\n})\n```\n\n**When to use `overrideAccess: false`:**\n\n- Performing operations on behalf of a user\n- Testing access control logic\n- API routes that should respect user permissions\n- Any operation where `user` parameter is provided\n\n**When `overrideAccess: true` is appropriate:**\n\n- Administrative operations (migrations, seeds, cron jobs)\n- Internal system operations\n- Operations explicitly intended to bypass access control\n\nSee [ACCESS-CONTROL.md#important-notes](ACCESS-CONTROL.md#important-notes) for more details.\n\n## REST API\n\n```ts\nimport { stringify } from 'qs-esm'\n\nconst query = {\n  status: { equals: 'published' },\n}\n\nconst queryString = stringify(\n  {\n    where: query,\n    depth: 2,\n    limit: 10,\n  },\n  { addQueryPrefix: true },\n)\n\nconst response = await fetch(`https://api.example.com/api/posts${queryString}`)\nconst data = await response.json()\n```\n\n### REST Endpoints\n\n```txt\nGET    /api/{collection}           - Find documents\nGET    /api/{collection}/{id}      - Find by ID\nPOST   /api/{collection}           - Create\nPATCH  /api/{collection}/{id}      - Update\nDELETE /api/{collection}/{id}      - Delete\nGET    /api/{collection}/count     - Count documents\n\nGET    /api/globals/{slug}         - Get global\nPOST   /api/globals/{slug}         - Update global\n```\n\n## GraphQL\n\n```graphql\nquery {\n  Posts(where: { status: { equals: published } }, limit: 10, sort: \"-createdAt\") {\n    docs {\n      id\n      title\n      author {\n        name\n      }\n    }\n    totalDocs\n    hasNextPage\n  }\n}\n\nmutation {\n  createPost(data: { title: \"New Post\", status: draft }) {\n    id\n    title\n  }\n}\n\nmutation {\n  updatePost(id: \"123\", data: { status: published }) {\n    id\n    status\n  }\n}\n\nmutation {\n  deletePost(id: \"123\") {\n    id\n  }\n}\n```\n\n## Performance Best Practices\n\n- Set `maxDepth` on relationships to prevent over-fetching\n- Use `select` to limit returned fields\n- Index frequently queried fields\n- Use `virtual` fields for computed data\n- Cache expensive operations in hook `context`\n"
      },
      "plugins": [
        {
          "name": "payload",
          "description": "Payload Development plugin - covers collections, fields, hooks, access control, plugins, and database adapters.",
          "version": "0.0.1",
          "source": "./tools/claude-plugin",
          "author": {
            "name": "Payload",
            "email": "info@payloadcms.com"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add payloadcms/payload",
            "/plugin install payload@payload-marketplace"
          ]
        }
      ]
    }
  ]
}