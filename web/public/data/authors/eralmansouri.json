{
  "author": {
    "id": "eralmansouri",
    "display_name": "eralmansouri",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/4578832?v=4",
    "url": "https://github.com/eralmansouri",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "tanstack-claude-plugin",
      "version": null,
      "description": "Claude skill for Tanstack libraries",
      "owner_info": {
        "name": "Essam Almansouri",
        "email": "me@eralmansouri.com"
      },
      "keywords": [],
      "repo_full_name": "eralmansouri/tanstack-claude-plugin",
      "repo_url": "https://github.com/eralmansouri/tanstack-claude-plugin",
      "repo_description": "A Claude Code plugin marketplace providing skills for Tanstack.",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-22T22:02:51Z",
        "created_at": "2026-01-22T22:01:34Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 473
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1876
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/forms",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/forms/SKILL.md",
          "type": "blob",
          "size": 9577
        },
        {
          "path": "skills/forms/tanstack-form-api.md",
          "type": "blob",
          "size": 4260
        },
        {
          "path": "skills/forms/tanstack-form-guides.md",
          "type": "blob",
          "size": 10807
        },
        {
          "path": "skills/forms/tanstack-form-overview.md",
          "type": "blob",
          "size": 2737
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"tanstack-claude-plugin\",\n  \"owner\": {\n    \"name\": \"Essam Almansouri\",\n    \"email\": \"me@eralmansouri.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude skill for Tanstack libraries\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"forms\",\n      \"source\": \"./\",\n      \"description\": \"Tanstack Forms - Headless UI for building performant and type-safe forms\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/forms\"\n      ]\n    }\n  ]\n}",
        "README.md": "# TanStack Plugin Marketplace for Claude Code\n\nA Claude Code plugin marketplace providing skills for [TanStack](https://tanstack.com) libraries.\n\n> **Note:** Currently only TanStack Form is supported. More TanStack libraries (Query, Router, Table, etc.) may be added in the future.\n\n## Installation\n\n### 1. Add the marketplace\n\n```bash\n/plugin marketplace add eralmansouri/tanstack-claude-plugin\n```\n\n### 2. Install the plugin\n\n```bash\n/plugin install forms@tanstack-claude-plugin\n```\n\nOr use the interactive menu:\n\n```bash\n/plugin\n```\n\nThen browse to \"Discover\" tab and select the forms plugin.\n\n### 3. Restart Claude Code\n\nRestart to load the skill.\n\n## What's Included\n\n### TanStack Form Skill\n\nThis plugin adds a TanStack Form **skill** that Claude automatically uses when you:\n\n- Ask about TanStack Form or `@tanstack/react-form`, `@tanstack/vue-form`, etc.\n- Build forms with validation (field-level, form-level, async)\n- Work with array/dynamic fields\n- Need SSR form integration (Next.js, TanStack Start, Remix)\n- Integrate forms with UI libraries (shadcn, Material UI, Chakra, etc.)\n\n### Skill Contents\n\n- **instructions.md** — When and how Claude should apply TanStack Form knowledge\n- **tanstack-form-overview.md** — Installation, philosophy, core concepts\n- **tanstack-form-api.md** — FormApi & FieldApi reference\n- **tanstack-form-guides.md** — Validation, arrays, listeners, SSR, UI integration patterns\n\n## Usage Examples\n\nOnce installed, just ask Claude naturally:\n\n- \"Create a form with email and password validation using TanStack Form\"\n- \"How do I handle array fields in TanStack Form?\"\n- \"Add async username validation with debouncing\"\n- \"Set up TanStack Form with Next.js server actions\"\n\n## Supported Frameworks\n\nTanStack Form supports React, Vue, Angular, Solid, Svelte, and Lit. The skill includes patterns for all frameworks.\n\n## License\n\nMIT\n",
        "skills/forms/SKILL.md": "---\nname: tanstack-form\ndescription: Headless, type-safe form management library. Use when building forms with validation, handling form state, working with array fields, or integrating forms in React, Vue, Angular, Solid, Svelte, or Lit.\n---\n\n# TanStack Form\n\nHeadless, type-safe form management for React, Vue, Angular, Solid, Svelte, and Lit.\n\n## Installation\n\n```bash\nnpm install @tanstack/react-form    # React\nnpm install @tanstack/vue-form      # Vue\nnpm install @tanstack/angular-form  # Angular\nnpm install @tanstack/solid-form    # Solid\nnpm install @tanstack/svelte-form   # Svelte\nnpm install @tanstack/lit-form      # Lit\n```\n\nRequires TypeScript >=5.4 with `strict: true` in tsconfig.\n\n## Quick Start (React)\n\n```tsx\nimport { useForm } from '@tanstack/react-form'\n\nfunction MyForm() {\n  const form = useForm({\n    defaultValues: { email: '', password: '' },\n    onSubmit: async ({ value }) => {\n      console.log(value)\n    },\n  })\n\n  return (\n    <form onSubmit={(e) => { e.preventDefault(); form.handleSubmit() }}>\n      <form.Field name=\"email\">\n        {(field) => (\n          <input\n            value={field.state.value}\n            onChange={(e) => field.handleChange(e.target.value)}\n            onBlur={field.handleBlur}\n          />\n        )}\n      </form.Field>\n      <form.Field name=\"password\">\n        {(field) => (\n          <input\n            type=\"password\"\n            value={field.state.value}\n            onChange={(e) => field.handleChange(e.target.value)}\n            onBlur={field.handleBlur}\n          />\n        )}\n      </form.Field>\n      <button type=\"submit\" disabled={!form.state.canSubmit}>Submit</button>\n    </form>\n  )\n}\n```\n\n## Field Validation\n\n```tsx\n<form.Field\n  name=\"email\"\n  validators={{\n    onChange: ({ value }) =>\n      !value.includes('@') ? 'Invalid email' : undefined,\n    onBlur: ({ value }) =>\n      !value ? 'Email is required' : undefined,\n  }}\n>\n  {(field) => (\n    <>\n      <input\n        value={field.state.value}\n        onChange={(e) => field.handleChange(e.target.value)}\n        onBlur={field.handleBlur}\n      />\n      {field.state.meta.errors.length > 0 && (\n        <span>{field.state.meta.errors.join(', ')}</span>\n      )}\n    </>\n  )}\n</form.Field>\n```\n\n### Validation Timing Options\n\n| Option | When it runs |\n|--------|--------------|\n| `onChange` | Every value change |\n| `onBlur` | When field loses focus |\n| `onSubmit` | On form submission |\n| `onMount` | When field mounts |\n| `onChangeAsync` | Async on change |\n| `onBlurAsync` | Async on blur |\n\n### Async Validation with Debounce\n\n```tsx\nvalidators={{\n  onChangeAsyncDebounceMs: 500,\n  onChangeAsync: async ({ value }) => {\n    const exists = await checkUsernameExists(value)\n    return exists ? 'Username taken' : undefined\n  },\n}}\n```\n\n### Schema Validation (Zod)\n\n```tsx\nimport { zodValidator } from '@tanstack/zod-form-adapter'\nimport { z } from 'zod'\n\n<form.Field\n  name=\"email\"\n  validators={{\n    onChange: zodValidator(z.string().email()),\n  }}\n>\n```\n\n## Form-Level Validation\n\n```tsx\nconst form = useForm({\n  defaultValues: { password: '', confirmPassword: '' },\n  validators: {\n    onChange: ({ value }) => {\n      if (value.password !== value.confirmPassword) {\n        return { fields: { confirmPassword: 'Passwords must match' } }\n      }\n      return undefined\n    },\n  },\n  onSubmit: ({ value }) => console.log(value),\n})\n```\n\n## Linked Fields (Cross-Field Validation)\n\n```tsx\n<form.Field\n  name=\"confirmPassword\"\n  validators={{\n    onChangeListenTo: ['password'],\n    onChange: ({ value, fieldApi }) => {\n      if (value !== fieldApi.form.getFieldValue('password')) {\n        return 'Passwords do not match'\n      }\n      return undefined\n    },\n  }}\n>\n```\n\n## Array Fields\n\n```tsx\nconst form = useForm({\n  defaultValues: { people: [] as Array<{ name: string; age: number }> },\n  onSubmit: ({ value }) => console.log(value),\n})\n\n<form.Field name=\"people\" mode=\"array\">\n  {(field) => (\n    <>\n      {field.state.value.map((_, i) => (\n        <div key={i}>\n          <form.Field name={`people[${i}].name`}>\n            {(subField) => (\n              <input\n                value={subField.state.value}\n                onChange={(e) => subField.handleChange(e.target.value)}\n              />\n            )}\n          </form.Field>\n          <button type=\"button\" onClick={() => field.removeValue(i)}>\n            Remove\n          </button>\n        </div>\n      ))}\n      <button type=\"button\" onClick={() => field.pushValue({ name: '', age: 0 })}>\n        Add Person\n      </button>\n    </>\n  )}\n</form.Field>\n```\n\n### Array Methods\n\n| Method | Description |\n|--------|-------------|\n| `pushValue(value)` | Add to end |\n| `insertValue(index, value)` | Insert at index |\n| `removeValue(index)` | Remove at index |\n| `replaceValue(index, value)` | Replace at index |\n| `swapValues(indexA, indexB)` | Swap positions |\n| `moveValue(from, to)` | Move to new position |\n| `clearValues()` | Remove all |\n\n## Listeners (Side Effects)\n\n```tsx\n<form.Field\n  name=\"country\"\n  listeners={{\n    onChange: ({ value }) => {\n      form.setFieldValue('province', '') // Reset dependent field\n    },\n    onChangeDebounceMs: 300, // Optional debounce\n  }}\n>\n```\n\n### Form-Level Listeners\n\n```tsx\nconst form = useForm({\n  defaultValues: { /* ... */ },\n  listeners: {\n    onChange: ({ fieldApi, formApi }) => {\n      autoSave(formApi.state.values)\n    },\n    onSubmit: ({ formApi }) => {\n      console.log('Submitted')\n    },\n  },\n})\n```\n\n## Form State\n\n| Property | Description |\n|----------|-------------|\n| `values` | Current form values |\n| `errors` | Array of form errors |\n| `isValid` | All validations passing |\n| `isValidating` | Validation in progress |\n| `isSubmitting` | Submission in progress |\n| `canSubmit` | Form can be submitted |\n| `isDirty` | Values changed from default |\n| `isPristine` | No changes made |\n\n## Field State\n\n| Property | Description |\n|----------|-------------|\n| `value` | Current field value |\n| `meta.errors` | Array of field errors |\n| `meta.errorMap` | Errors keyed by timing |\n| `meta.isValid` | Field is valid |\n| `meta.isTouched` | Field was changed/blurred |\n| `meta.isDirty` | Value differs from default |\n| `meta.isBlurred` | Field lost focus |\n\n## FormApi Methods\n\n```tsx\nform.getFieldValue('email')\nform.setFieldValue('email', 'new@email.com')\nform.reset()\nform.resetField('email')\nform.validateField('email')\nform.validateAllFields()\nform.handleSubmit()\n```\n\n## Vue Quick Start\n\n```vue\n<script setup>\nimport { useForm } from '@tanstack/vue-form'\n\nconst form = useForm({\n  defaultValues: { name: '' },\n  onSubmit: ({ value }) => console.log(value),\n})\n</script>\n\n<template>\n  <form @submit.prevent=\"form.handleSubmit()\">\n    <form.Field name=\"name\" v-slot=\"{ field }\">\n      <input\n        :value=\"field.state.value\"\n        @input=\"(e) => field.handleChange(e.target.value)\"\n        @blur=\"field.handleBlur()\"\n      />\n    </form.Field>\n    <button type=\"submit\">Submit</button>\n  </form>\n</template>\n```\n\n## Angular Quick Start\n\n```typescript\nimport { Component } from '@angular/core'\nimport { TanStackField, injectForm } from '@tanstack/angular-form'\n\n@Component({\n  standalone: true,\n  imports: [TanStackField],\n  template: `\n    <form (submit)=\"handleSubmit($event)\">\n      <ng-container [tanstackField]=\"form\" name=\"name\" #field=\"field\">\n        <input\n          [value]=\"field.api.state.value\"\n          (input)=\"field.api.handleChange($any($event.target).value)\"\n          (blur)=\"field.api.handleBlur()\"\n        />\n      </ng-container>\n      <button type=\"submit\">Submit</button>\n    </form>\n  `,\n})\nexport class MyFormComponent {\n  form = injectForm({\n    defaultValues: { name: '' },\n    onSubmit: ({ value }) => console.log(value),\n  })\n\n  handleSubmit(event: Event) {\n    event.preventDefault()\n    this.form.handleSubmit()\n  }\n}\n```\n\n## SSR (Next.js)\n\n```tsx\n// actions.ts\n'use server'\nimport { formOptions, createServerValidate } from '@tanstack/react-form-nextjs'\n\nexport const formOpts = formOptions({\n  defaultValues: { email: '' },\n})\n\nexport async function submitForm(prevState: unknown, formData: FormData) {\n  const serverValidate = createServerValidate({\n    ...formOpts,\n    onServerValidate: ({ value }) => {\n      if (!value.email.includes('@')) {\n        return { fields: { email: 'Invalid email' } }\n      }\n    },\n  })\n  return await serverValidate(formData)\n}\n```\n\n```tsx\n// component.tsx\n'use client'\nimport { useForm, mergeForm, initialFormState, useTransform } from '@tanstack/react-form-nextjs'\nimport { useActionState } from 'react'\nimport { formOpts, submitForm } from './actions'\n\nexport function MyForm() {\n  const [state, action] = useActionState(submitForm, initialFormState)\n  const form = useForm({\n    ...formOpts,\n    transform: useTransform((baseForm) => mergeForm(baseForm, state), [state]),\n  })\n\n  return (\n    <form action={action}>\n      <form.Field name=\"email\">\n        {(field) => <input name=\"email\" value={field.state.value} />}\n      </form.Field>\n      <button type=\"submit\">Submit</button>\n    </form>\n  )\n}\n```\n\n## UI Library Integration\n\nTanStack Form is headless — integrate with any UI library:\n\n```tsx\n<form.Field name=\"terms\">\n  {(field) => (\n    <Checkbox\n      checked={field.state.value}\n      onCheckedChange={(checked) => field.handleChange(!!checked)}\n    />\n  )}\n</form.Field>\n```\n\n## References\n\n- [API Reference](tanstack-form-api.md) - Complete FormApi and FieldApi documentation\n- [Guides](tanstack-form-guides.md) - Detailed patterns and examples\n- [Overview](tanstack-form-overview.md) - Philosophy and core concepts\n",
        "skills/forms/tanstack-form-api.md": "# TanStack Form API Reference\n\n## FormApi Class\n\nThe core class managing form state. Access through framework hooks (`useForm`, `injectForm`) rather than direct instantiation.\n\n### Properties\n\n| Property | Description |\n|----------|-------------|\n| `baseStore` | Foundational form state store |\n| `store` | Derived store with complete form state |\n| `options` | Configuration object |\n| `fieldInfo` | Record tracking metadata for each field |\n| `fieldMetaDerived` | Derived state with partial field metadata |\n\n### Accessors\n\n| Accessor | Description |\n|----------|-------------|\n| `formId` | Unique string identifier |\n| `state` | Current FormState snapshot |\n\n### Methods\n\n#### Field Value Operations\n\n```typescript\n// Get/Set values\nform.getFieldValue(name)\nform.setFieldValue(name, value, opts?)\n\n// Array operations\nform.pushFieldValue(name, value, opts?)\nform.insertFieldValue(name, index, value, opts?)\nform.removeFieldValue(name, index, opts?)\nform.replaceFieldValue(name, index, value, opts?)\nform.swapFieldValues(name, indexA, indexB, opts?)\nform.moveFieldValues(name, fromIndex, toIndex, opts?)\nform.clearFieldValues(name, opts?)\nform.deleteField(name)\n```\n\n#### Validation\n\n```typescript\nform.validateField(name, cause?)\nform.validateAllFields(cause?)\nform.setErrorMap(errorMap)\n```\n\n#### Submission\n\n```typescript\nform.handleSubmit()\n```\n\n#### State Management\n\n```typescript\nform.reset()\nform.resetField(name)\nform.resetFieldMeta(name)\nform.update(options)\nform.mount()\n```\n\n---\n\n## FieldApi Class\n\nManages individual field state and validation.\n\n### Properties\n\n| Property | Description |\n|----------|-------------|\n| `form` | Parent FormApi reference |\n| `name` | Field identifier |\n| `options` | Field configuration |\n| `store` | Derived FieldState container |\n\n### Methods\n\n#### State Management\n\n```typescript\nfield.getValue()\nfield.setValue(updater, opts?)\nfield.getMeta()\nfield.setMeta(updater)\nfield.getInfo()\n```\n\n#### Array Operations (for array fields)\n\n```typescript\nfield.pushValue(value, opts?)\nfield.insertValue(index, value, opts?)\nfield.removeValue(index, opts?)\nfield.replaceValue(index, value, opts?)\nfield.moveValue(fromIndex, toIndex, opts?)\nfield.swapValues(indexA, indexB, opts?)\nfield.clearValues(opts?)\n```\n\n#### Validation & Events\n\n```typescript\nfield.validate(cause, opts?)\nfield.handleChange(updater)\nfield.handleBlur()\nfield.setErrorMap(errorMap)\n```\n\n#### Lifecycle\n\n```typescript\nfield.mount()\nfield.update(opts)\nfield.parseValueWithSchema(schema)\n```\n\n---\n\n## Key Functions\n\n| Function | Description |\n|----------|-------------|\n| `formOptions()` | Create shared form configuration |\n| `createFormHook()` | Create reusable form hook factory |\n| `createFormHookContexts()` | Create form contexts for hook factory |\n| `mergeForm()` | Merge server state with client form state (SSR) |\n| `createFieldMap()` | Create field mapping utilities |\n| `isGlobalFormValidationError()` | Check if error is form-level |\n| `isStandardSchemaValidator()` | Check if validator uses Standard Schema |\n\n---\n\n## Form State\n\n```typescript\ninterface FormState {\n  values: TFormData\n  errors: string[]\n  errorMap: Record<string, string>\n  isValid: boolean\n  isValidating: boolean\n  isSubmitting: boolean\n  isSubmitted: boolean\n  submitCount: number\n  canSubmit: boolean\n  isPristine: boolean\n  isDirty: boolean\n}\n```\n\n## Field State\n\n```typescript\ninterface FieldState {\n  value: TData\n  meta: {\n    errors: string[]\n    errorMap: Record<string, string>\n    isValid: boolean\n    isValidating: boolean\n    isTouched: boolean\n    isBlurred: boolean\n    isDirty: boolean\n    isPristine: boolean\n    isDefaultValue: boolean\n  }\n}\n```\n\n## Validation Timing Options\n\n| Option | When Validation Runs |\n|--------|---------------------|\n| `onChange` | On every value change |\n| `onChangeAsync` | Async validation on change |\n| `onBlur` | When field loses focus |\n| `onBlurAsync` | Async validation on blur |\n| `onSubmit` | On form submission |\n| `onSubmitAsync` | Async validation on submit |\n| `onMount` | When field mounts |\n| `onMountAsync` | Async validation on mount |\n\n## Debouncing Options\n\n```typescript\nvalidators={{\n  onChangeAsyncDebounceMs: 500,\n  onBlurAsyncDebounceMs: 500,\n  onChangeAsync: async ({ value }) => { /* ... */ }\n}}\n```\n",
        "skills/forms/tanstack-form-guides.md": "# TanStack Form Guides & Patterns\n\n## Quick Start (React)\n\n### Recommended: createFormHook Pattern\n\n```tsx\nimport { createFormHookContexts, createFormHook } from '@tanstack/react-form'\nimport { zodValidator } from '@tanstack/zod-form-adapter'\n\n// 1. Create contexts\nconst { fieldContext, formContext } = createFormHookContexts()\n\n// 2. Create hook with bound components\nconst { useAppForm, AppField, AppForm } = createFormHook({\n  fieldContext,\n  formContext,\n  fieldComponents: {\n    TextField: ({ field }) => (\n      <input\n        value={field.state.value}\n        onChange={(e) => field.handleChange(e.target.value)}\n        onBlur={field.handleBlur}\n      />\n    ),\n  },\n  formComponents: {\n    SubmitButton: ({ form }) => (\n      <button type=\"submit\" disabled={!form.state.canSubmit}>\n        Submit\n      </button>\n    ),\n  },\n})\n\n// 3. Use in component\nfunction MyForm() {\n  const form = useAppForm({\n    defaultValues: { email: '', password: '' },\n    onSubmit: ({ value }) => console.log(value),\n  })\n\n  return (\n    <form onSubmit={(e) => { e.preventDefault(); form.handleSubmit() }}>\n      <AppField name=\"email\" component=\"TextField\" />\n      <AppField name=\"password\" component=\"TextField\" />\n      <AppForm component=\"SubmitButton\" />\n    </form>\n  )\n}\n```\n\n### Alternative: useForm Hook\n\n```tsx\nimport { useForm } from '@tanstack/react-form'\n\nfunction MyForm() {\n  const form = useForm({\n    defaultValues: { firstName: '', age: 0 },\n    onSubmit: async ({ value }) => {\n      console.log(value)\n    },\n  })\n\n  return (\n    <form onSubmit={(e) => { e.preventDefault(); form.handleSubmit() }}>\n      <form.Field name=\"firstName\">\n        {(field) => (\n          <input\n            value={field.state.value}\n            onChange={(e) => field.handleChange(e.target.value)}\n            onBlur={field.handleBlur}\n          />\n        )}\n      </form.Field>\n      <button type=\"submit\">Submit</button>\n    </form>\n  )\n}\n```\n\n---\n\n## Validation\n\n### Field-Level Validation\n\n```tsx\n<form.Field\n  name=\"age\"\n  validators={{\n    onChange: ({ value }) =>\n      value < 13 ? 'Must be 13 or older' : undefined,\n    onBlur: ({ value }) =>\n      value < 0 ? 'Age cannot be negative' : undefined,\n  }}\n>\n  {(field) => (\n    <>\n      <input\n        type=\"number\"\n        value={field.state.value}\n        onChange={(e) => field.handleChange(Number(e.target.value))}\n        onBlur={field.handleBlur}\n      />\n      {field.state.meta.errors.length > 0 && (\n        <span>{field.state.meta.errors.join(', ')}</span>\n      )}\n    </>\n  )}\n</form.Field>\n```\n\n### Async Validation with Debouncing\n\n```tsx\n<form.Field\n  name=\"username\"\n  validators={{\n    onChangeAsyncDebounceMs: 500,\n    onChangeAsync: async ({ value }) => {\n      const exists = await checkUsernameExists(value)\n      return exists ? 'Username taken' : undefined\n    },\n  }}\n>\n  {(field) => /* ... */}\n</form.Field>\n```\n\n### Form-Level Validation\n\n```tsx\nconst form = useForm({\n  defaultValues: { password: '', confirmPassword: '' },\n  validators: {\n    onChange: ({ value }) => {\n      if (value.password !== value.confirmPassword) {\n        return {\n          fields: {\n            confirmPassword: 'Passwords do not match',\n          },\n        }\n      }\n      return undefined\n    },\n  },\n  onSubmit: ({ value }) => console.log(value),\n})\n```\n\n### Schema Validation (Zod)\n\n```tsx\nimport { z } from 'zod'\nimport { zodValidator } from '@tanstack/zod-form-adapter'\n\nconst schema = z.object({\n  email: z.string().email(),\n  age: z.number().min(18),\n})\n\n<form.Field\n  name=\"email\"\n  validators={{\n    onChange: zodValidator(schema.shape.email),\n  }}\n>\n  {(field) => /* ... */}\n</form.Field>\n```\n\n### Displaying Errors\n\n```tsx\n// Array of all errors\n{field.state.meta.errors.map((error, i) => (\n  <span key={i}>{error}</span>\n))}\n\n// Errors by timing\n{field.state.meta.errorMap['onChange'] && (\n  <span>{field.state.meta.errorMap['onChange']}</span>\n)}\n```\n\n---\n\n## Linked Fields (Cross-Field Validation)\n\n```tsx\n<form.Field name=\"password\">\n  {(field) => (\n    <input\n      type=\"password\"\n      value={field.state.value}\n      onChange={(e) => field.handleChange(e.target.value)}\n    />\n  )}\n</form.Field>\n\n<form.Field\n  name=\"confirmPassword\"\n  validators={{\n    onChangeListenTo: ['password'],\n    onChange: ({ value, fieldApi }) => {\n      if (value !== fieldApi.form.getFieldValue('password')) {\n        return 'Passwords do not match'\n      }\n      return undefined\n    },\n  }}\n>\n  {(field) => (\n    <input\n      type=\"password\"\n      value={field.state.value}\n      onChange={(e) => field.handleChange(e.target.value)}\n    />\n  )}\n</form.Field>\n```\n\n---\n\n## Array Fields\n\n```tsx\nconst form = useForm({\n  defaultValues: {\n    people: [] as Array<{ name: string; age: number }>,\n  },\n  onSubmit: ({ value }) => console.log(value),\n})\n\n// In render:\n<form.Field name=\"people\" mode=\"array\">\n  {(field) => (\n    <>\n      {field.state.value.map((_, i) => (\n        <div key={i}>\n          <form.Field name={`people[${i}].name`}>\n            {(subField) => (\n              <input\n                value={subField.state.value}\n                onChange={(e) => subField.handleChange(e.target.value)}\n              />\n            )}\n          </form.Field>\n          <form.Field name={`people[${i}].age`}>\n            {(subField) => (\n              <input\n                type=\"number\"\n                value={subField.state.value}\n                onChange={(e) => subField.handleChange(Number(e.target.value))}\n              />\n            )}\n          </form.Field>\n          <button type=\"button\" onClick={() => field.removeValue(i)}>\n            Remove\n          </button>\n        </div>\n      ))}\n      <button\n        type=\"button\"\n        onClick={() => field.pushValue({ name: '', age: 0 })}\n      >\n        Add Person\n      </button>\n    </>\n  )}\n</form.Field>\n```\n\n---\n\n## Listeners (Side Effects)\n\n### Field-Level Listener\n\n```tsx\n<form.Field\n  name=\"country\"\n  listeners={{\n    onChange: ({ value }) => {\n      // Reset province when country changes\n      form.setFieldValue('province', '')\n    },\n  }}\n>\n  {(field) => /* ... */}\n</form.Field>\n```\n\n### Debounced Listener\n\n```tsx\n<form.Field\n  name=\"search\"\n  listeners={{\n    onChangeDebounceMs: 300,\n    onChange: ({ value }) => {\n      // API call on debounced change\n      fetchResults(value)\n    },\n  }}\n>\n  {(field) => /* ... */}\n</form.Field>\n```\n\n### Form-Level Listeners\n\n```tsx\nconst form = useForm({\n  defaultValues: { /* ... */ },\n  listeners: {\n    onSubmit: ({ formApi }) => {\n      console.log('Form submitted')\n    },\n    onChange: ({ fieldApi, formApi }) => {\n      // Auto-save on any change\n      saveFormData(formApi.state.values)\n    },\n  },\n  onSubmit: ({ value }) => /* ... */,\n})\n```\n\n---\n\n## Submission Handling\n\n### Basic Submission\n\n```tsx\nconst form = useForm({\n  defaultValues: { email: '' },\n  onSubmit: async ({ value }) => {\n    await submitToServer(value)\n  },\n})\n\n<form onSubmit={(e) => {\n  e.preventDefault()\n  form.handleSubmit()\n}}>\n```\n\n### Submission with Metadata\n\n```tsx\ntype FormMeta = { action: 'save' | 'saveAndContinue' }\n\nconst form = useForm({\n  defaultValues: { /* ... */ },\n  onSubmitMeta: { action: 'save' } as FormMeta,\n  onSubmit: async ({ value, meta }) => {\n    await save(value)\n    if (meta.action === 'saveAndContinue') {\n      navigate('/next')\n    }\n  },\n})\n\n// Different buttons\n<button onClick={() => form.handleSubmit()}>Save</button>\n<button onClick={() => form.handleSubmit({ action: 'saveAndContinue' })}>\n  Save & Continue\n</button>\n```\n\n---\n\n## SSR Integration (Next.js Example)\n\n### Server Action\n\n```tsx\n// actions.ts\n'use server'\nimport { formOptions, createServerValidate } from '@tanstack/react-form-nextjs'\n\nexport const formOpts = formOptions({\n  defaultValues: { email: '' },\n})\n\nconst serverValidate = createServerValidate({\n  ...formOpts,\n  onServerValidate: ({ value }) => {\n    if (!value.email.includes('@')) {\n      return { fields: { email: 'Invalid email' } }\n    }\n  },\n})\n\nexport async function submitForm(prevState: unknown, formData: FormData) {\n  return await serverValidate(formData)\n}\n```\n\n### Client Component\n\n```tsx\n'use client'\nimport { useForm, mergeForm, initialFormState } from '@tanstack/react-form-nextjs'\nimport { useActionState } from 'react'\nimport { formOpts, submitForm } from './actions'\n\nexport function MyForm() {\n  const [state, action] = useActionState(submitForm, initialFormState)\n\n  const form = useForm({\n    ...formOpts,\n    transform: useTransform((baseForm) => mergeForm(baseForm, state), [state]),\n  })\n\n  return (\n    <form action={action}>\n      <form.Field name=\"email\">\n        {(field) => <input name=\"email\" value={field.state.value} /* ... */ />}\n      </form.Field>\n      <button type=\"submit\">Submit</button>\n    </form>\n  )\n}\n```\n\n---\n\n## UI Library Integration\n\nTanStack Form is headless - integrate with any UI library via render props.\n\n### Pattern\n\n```tsx\n<form.Field name=\"fieldName\">\n  {({ state, handleChange, handleBlur }) => (\n    <UIComponent\n      value={state.value}\n      onChange={(e) => handleChange(e.target.value)}\n      onBlur={handleBlur}\n      error={state.meta.errors[0]}\n    />\n  )}\n</form.Field>\n```\n\n### shadcn/ui Checkbox\n\n```tsx\n<form.Field name=\"terms\">\n  {(field) => (\n    <Checkbox\n      checked={field.state.value}\n      onCheckedChange={(checked) => field.handleChange(!!checked)}\n    />\n  )}\n</form.Field>\n```\n\n---\n\n## Vue Quick Start\n\n```vue\n<script setup>\nimport { useForm } from '@tanstack/vue-form'\n\nconst form = useForm({\n  defaultValues: { firstName: '' },\n  onSubmit: ({ value }) => console.log(value),\n})\n</script>\n\n<template>\n  <form @submit.prevent=\"form.handleSubmit()\">\n    <form.Field name=\"firstName\" v-slot=\"{ field }\">\n      <input\n        :value=\"field.state.value\"\n        @input=\"(e) => field.handleChange(e.target.value)\"\n        @blur=\"field.handleBlur()\"\n      />\n    </form.Field>\n    <button type=\"submit\">Submit</button>\n  </form>\n</template>\n```\n\n---\n\n## Angular Quick Start\n\n```typescript\nimport { Component } from '@angular/core'\nimport { TanStackField, injectForm } from '@tanstack/angular-form'\n\n@Component({\n  standalone: true,\n  imports: [TanStackField],\n  template: `\n    <form (submit)=\"handleSubmit($event)\">\n      <ng-container [tanstackField]=\"form\" name=\"fullName\" #field=\"field\">\n        <input\n          [value]=\"field.api.state.value\"\n          (input)=\"field.api.handleChange($any($event.target).value)\"\n          (blur)=\"field.api.handleBlur()\"\n        />\n      </ng-container>\n      <button type=\"submit\">Submit</button>\n    </form>\n  `,\n})\nexport class MyFormComponent {\n  form = injectForm({\n    defaultValues: { fullName: '' },\n    onSubmit: ({ value }) => console.log(value),\n  })\n\n  handleSubmit(event: Event) {\n    event.preventDefault()\n    this.form.handleSubmit()\n  }\n}\n```\n",
        "skills/forms/tanstack-form-overview.md": "# TanStack Form Overview\n\nTanStack Form is a headless, type-safe form management library supporting React, Vue, Angular, Solid, Svelte, and Lit.\n\n## Installation\n\n```bash\n# React\nnpm install @tanstack/react-form\n\n# Vue\nnpm install @tanstack/vue-form\n\n# Angular\nnpm install @tanstack/angular-form\n\n# Solid\nnpm install @tanstack/solid-form\n\n# Svelte\nnpm install @tanstack/svelte-form\n\n# Lit\nnpm install @tanstack/lit-form\n```\n\n### Meta-Framework Adapters (React)\n\n```bash\n# TanStack Start\nnpm install @tanstack/react-form-start\n\n# Next.js\nnpm install @tanstack/react-form-nextjs\n\n# Remix\nnpm install @tanstack/react-form-remix\n```\n\n### DevTools\n\n```bash\n# React\nnpm install @tanstack/react-devtools @tanstack/react-form-devtools\n\n# Solid\nnpm install @tanstack/solid-devtools @tanstack/solid-form-devtools\n```\n\n## Philosophy & Design Principles\n\n### 1. Unified API\nOne cohesive API rather than multiple approaches. Higher initial learning curve but eliminates confusion.\n\n### 2. Flexibility\n- Multiple validation timing options (blur, change, submit, mount)\n- Various validation strategies (field, form, or subsets)\n- Integration with Zod, Valibot, ArkType, Yup\n- Async validation with built-in debouncing\n\n### 3. Controlled Inputs\nCommitted to controlled inputs for:\n- Predictability and testability\n- Non-DOM renderer support (React Native, Three.js)\n- Conditional field logic\n- State inspection for debugging\n\n### 4. Type Inference\nNo generics needed - types are inferred from runtime defaults. TypeScript and JavaScript usage is nearly identical.\n\n### 5. Composability\nDesigned to be wrapped into your own component/design systems.\n\n## TypeScript Requirements\n\n- `strict: true` in `tsconfig.json`\n- TypeScript v5.4+\n- Type enhancements are non-breaking (patch releases)\n\n## Core Concepts\n\n### Form Instance\nCreated via framework-specific hooks (`useForm`, `injectForm`). Manages overall state and provides field manipulation methods.\n\n### Field\nIndividual inputs created with `form.Field` components. Use `name` prop matching form data keys.\n\n### Field State\n- `isTouched` - After user change or blur\n- `isDirty` - Persists after any change\n- `isPristine` - Opposite of isDirty\n- `isBlurred` - After losing focus\n- `isDefaultValue` - Matches initial value\n\n### Validation\nSynchronous and asynchronous validators via the `validators` prop. Integrates with Standard Schema libraries.\n\n### Reactivity\nUse `useStore(form.store)` with selectors and `form.Subscribe` for optimized rendering.\n\n### Array Fields\nUse `mode=\"array\"` with helpers: `pushValue`, `removeValue`, `swapValues`, `moveValue`, `insertValue`, `replaceValue`, `clearValues`.\n\n### Listeners\nRespond to events (`onChange`, `onBlur`, `onMount`, `onSubmit`) with side effects.\n"
      },
      "plugins": [
        {
          "name": "forms",
          "source": "./",
          "description": "Tanstack Forms - Headless UI for building performant and type-safe forms",
          "strict": false,
          "skills": [
            "./skills/forms"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add eralmansouri/tanstack-claude-plugin",
            "/plugin install forms@tanstack-claude-plugin"
          ]
        }
      ]
    }
  ]
}