{
  "author": {
    "id": "FrancisVarga",
    "display_name": "Francis Varga",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/142090?u=a5732ea21fb700ba6b8e92532b3451715629abda&v=4",
    "url": "https://github.com/FrancisVarga",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 6,
      "total_skills": 4,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "coconut-claude-code-plugins",
      "version": null,
      "description": "Coconut collection of Claude Code plugins for intelligent git workflows, rules management, and workflow automation",
      "owner_info": {
        "name": "Francis Varga",
        "email": "francis@phili-tech.org"
      },
      "keywords": [],
      "repo_full_name": "FrancisVarga/coconut-claude-code-plugins",
      "repo_url": "https://github.com/FrancisVarga/coconut-claude-code-plugins",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-10T11:18:13Z",
        "created_at": "2025-12-10T10:16:05Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1533
        },
        {
          "path": "coconut-commit-work",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-commit-work/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-commit-work/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 439
        },
        {
          "path": "coconut-commit-work/README.md",
          "type": "blob",
          "size": 13937
        },
        {
          "path": "coconut-commit-work/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-commit-work/agents/commit-analyzer.md",
          "type": "blob",
          "size": 5005
        },
        {
          "path": "coconut-commit-work/agents/commit-executor.md",
          "type": "blob",
          "size": 2389
        },
        {
          "path": "coconut-commit-work/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-commit-work/commands/commit-work.md",
          "type": "blob",
          "size": 8983
        },
        {
          "path": "coconut-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 369
        },
        {
          "path": "coconut-rules/README.md",
          "type": "blob",
          "size": 6693
        },
        {
          "path": "coconut-rules/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/agents/knowledge-updater.md",
          "type": "blob",
          "size": 6139
        },
        {
          "path": "coconut-rules/agents/rule-reviewer.md",
          "type": "blob",
          "size": 4598
        },
        {
          "path": "coconut-rules/agents/rules-organizer.md",
          "type": "blob",
          "size": 3318
        },
        {
          "path": "coconut-rules/agents/session-analyzer.md",
          "type": "blob",
          "size": 4092
        },
        {
          "path": "coconut-rules/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/commands/add-rule.md",
          "type": "blob",
          "size": 6233
        },
        {
          "path": "coconut-rules/commands/list-rules.md",
          "type": "blob",
          "size": 2740
        },
        {
          "path": "coconut-rules/commands/organize.md",
          "type": "blob",
          "size": 4365
        },
        {
          "path": "coconut-rules/commands/retrospective.md",
          "type": "blob",
          "size": 5575
        },
        {
          "path": "coconut-rules/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/skills/concise-rule-writing",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/skills/concise-rule-writing/SKILL.md",
          "type": "blob",
          "size": 7101
        },
        {
          "path": "coconut-rules/skills/retrospective-process",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/skills/retrospective-process/SKILL.md",
          "type": "blob",
          "size": 5815
        },
        {
          "path": "coconut-rules/skills/rules-management",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-rules/skills/rules-management/SKILL.md",
          "type": "blob",
          "size": 5382
        },
        {
          "path": "coconut-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-workflow/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-workflow/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 464
        },
        {
          "path": "coconut-workflow/README.md",
          "type": "blob",
          "size": 1796
        },
        {
          "path": "coconut-workflow/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-workflow/agents/workflow-validator.md",
          "type": "blob",
          "size": 5786
        },
        {
          "path": "coconut-workflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-workflow/commands/create.md",
          "type": "blob",
          "size": 5364
        },
        {
          "path": "coconut-workflow/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-workflow/skills/workflow-creation",
          "type": "tree",
          "size": null
        },
        {
          "path": "coconut-workflow/skills/workflow-creation/SKILL.md",
          "type": "blob",
          "size": 8268
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"coconut-claude-code-plugins\",\n  \"owner\": {\n    \"name\": \"Francis Varga\",\n    \"email\": \"francis@phili-tech.org\"\n  },\n  \"metadata\": {\n    \"description\": \"Coconut collection of Claude Code plugins for intelligent git workflows, rules management, and workflow automation\",\n    \"version\": \"0.1.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"coconut-commit-work\",\n      \"source\": \"./coconut-commit-work\",\n      \"description\": \"Intelligent git commits with semantic grouping, conventional commit messages, emoji prefixes, user stories, and parallel sub-agent execution\",\n      \"version\": \"0.2.0\",\n      \"author\": {\n        \"name\": \"Francis Varga\"\n      },\n      \"keywords\": [\"git\", \"commit\", \"conventional-commits\", \"automation\", \"workflow\"]\n    },\n    {\n      \"name\": \"coconut-workflow\",\n      \"source\": \"./coconut-workflow\",\n      \"description\": \"Interactive workflow creation assistant that helps teams create Claude Code slash commands through conversational requirements gathering\",\n      \"version\": \"0.1.0\",\n      \"author\": {\n        \"name\": \"Francis Varga\"\n      },\n      \"keywords\": [\"workflow\", \"commands\", \"automation\", \"team-standards\"]\n    },\n    {\n      \"name\": \"coconut-rules\",\n      \"source\": \"./coconut-rules\",\n      \"description\": \"Manage Claude Code rules with context-based loading, retrospective analysis, and knowledge graph integration\",\n      \"version\": \"3.0.0\",\n      \"author\": {\n        \"name\": \"Francis Varga\"\n      },\n      \"keywords\": [\"rules\", \"claude-md\", \"organization\", \"configuration\"]\n    }\n  ]\n}\n",
        "coconut-commit-work/.claude-plugin/plugin.json": "{\n  \"name\": \"coconut-commit-work\",\n  \"version\": \"0.2.0\",\n  \"description\": \"Intelligent git commits with semantic grouping, conventional commit messages, emoji prefixes, user stories, and parallel sub-agent execution\",\n  \"author\": {\n    \"name\": \"francis\",\n    \"email\": \"francis@phili-tech.org\"\n  },\n  \"keywords\": [\n    \"git\",\n    \"commit\",\n    \"conventional-commits\",\n    \"automation\",\n    \"workflow\",\n    \"parallel\",\n    \"sub-agents\"\n  ]\n}",
        "coconut-commit-work/README.md": "# coconut-commit-work\n\nIntelligent git commits with semantic grouping, conventional commit messages, emoji prefixes, user stories, and **parallel analysis with sequential execution**.\n\n## Table of Contents\n\n- [Features](#features)\n- [Installation](#installation)\n- [Quick Start](#quick-start)\n- [Usage](#usage)\n- [Commit Message Format](#commit-message-format)\n- [Emoji Mapping](#emoji-mapping)\n- [Grouping Strategy](#grouping-strategy)\n- [Architecture](#architecture)\n- [Execution Model](#execution-model)\n- [Configuration](#configuration)\n- [Troubleshooting](#troubleshooting)\n- [Contributing](#contributing)\n- [License](#license)\n\n## Features\n\n| Feature | Description |\n|---------|-------------|\n| **Semantic Grouping** | Analyzes changes and groups them into smallest logical commits |\n| **Conventional Commits** | Follows conventional commit format with emoji prefixes |\n| **User Stories** | Each commit includes a scrum-like user story section |\n| **Acceptance Criteria** | Auto-generated testable criteria for each commit |\n| **Commit Template** | Creates/follows `.github/COMMIT_TEMPLATE` |\n| **Parallel Analysis** | Uses sub-agents to analyze and generate commit messages concurrently |\n| **Sequential Execution** | Commits execute one at a time to avoid git staging race conditions |\n| **Auto-Push** | Automatically pushes to remote after successful commits |\n| **Dry Run Mode** | Preview commits without executing |\n\n## Installation\n\n### Option 1: Copy to Project\n\n```bash\n# Copy plugin to your project's .claude-plugin directory\ncp -r coconut-commit-work /path/to/your/project/.claude-plugin/\n```\n\n### Option 2: Add to Claude Code Plugins Directory\n\n```bash\n# Copy to global plugins directory\ncp -r coconut-commit-work ~/.claude/plugins/\n```\n\n### Option 3: Symlink for Development\n\n```bash\n# Create symlink for easy updates\nln -s /path/to/coconut-commit-work ~/.claude/plugins/coconut-commit-work\n```\n\n## Quick Start\n\n```bash\n# 1. Make your code changes\nvim src/feature.ts\n\n# 2. Run the intelligent commit workflow\n/coconut-commit-work:commit-work\n\n# That's it! Changes are analyzed, grouped, committed, and pushed.\n```\n\n## Usage\n\n### Basic Commands\n\n```bash\n# Commit all changes with intelligent grouping and auto-push (default)\n/coconut-commit-work:commit-work\n\n# Preview commits without executing (dry run)\n/coconut-commit-work:commit-work --dry-run\n\n# Commit without pushing to remote\n/coconut-commit-work:commit-work --no-push\n\n# Show help\n/coconut-commit-work:commit-work --help\n```\n\n### Command Options\n\n| Option | Description | Default |\n|--------|-------------|---------|\n| `--dry-run` | Preview commits without executing | Off |\n| `--no-push` | Skip auto-push after commits | Off (push enabled) |\n| `--help` | Show help message | - |\n\n### Typical Workflow\n\n1. **Make changes** across multiple files\n2. **Run `/coconut-commit-work:commit-work`**\n3. **Review** the semantic groupings (or use `--dry-run` first)\n4. **Commits are created** with proper messages and user stories\n5. **Changes are pushed** to remote automatically\n\n## Commit Message Format\n\nEvery commit follows this structured format:\n\n```\n[emoji] [type](scope): Subject line (max 50 chars)\n\n## Why (User Story)\nAs a [specific role], I want [specific goal] so that [measurable benefit].\n\n## What Changed\n- Specific change 1 with file reference\n- Specific change 2 with context\n\n## Acceptance Criteria\n- [ ] Testable criterion 1\n- [ ] Testable criterion 2\n\n## Notes\nTechnical context, dependencies, or implementation details.\n```\n\n### Example Commit\n\n```\nâœ¨ feat(auth): add password reset functionality\n\n## Why (User Story)\nAs a user who forgot my password, I want to reset it via email so that I can regain access to my account.\n\n## What Changed\n- Added `resetPassword` function in src/auth/reset.ts\n- Created email template in templates/reset-email.html\n- Added reset endpoint in src/api/auth.ts\n\n## Acceptance Criteria\n- [ ] User receives reset email within 1 minute\n- [ ] Reset link expires after 24 hours\n- [ ] Password must meet complexity requirements\n\n## Notes\nUses SendGrid for email delivery. Rate limited to 3 attempts per hour.\n```\n\n## Emoji Mapping\n\n| Type | Emoji | When to Use |\n|------|-------|-------------|\n| `feat` | âœ¨ | New feature or capability |\n| `fix` | ğŸ› | Bug fix |\n| `docs` | ğŸ“ | Documentation only |\n| `style` | ğŸ’„ | Formatting, whitespace (no logic change) |\n| `refactor` | â™»ï¸ | Code restructure without behavior change |\n| `test` | âœ… | Adding or updating tests |\n| `chore` | ğŸ”§ | Maintenance, deps, tooling |\n| `perf` | âš¡ | Performance improvement |\n| `ci` | ğŸ‘· | CI/CD configuration |\n| `build` | ğŸ“¦ | Build system, packaging |\n\n## Grouping Strategy\n\nChanges are analyzed and grouped using these strategies (in priority order):\n\n### 1. Feature Cohesion\nRelated functionality goes together:\n- Implementation + its types/interfaces\n- Component + its styles + its tests\n- API endpoint + its handler + its validation\n\n### 2. Layer Separation\nArchitectural layers stay separate:\n- Frontend changes separate from backend\n- Database migrations separate from application code\n- Infrastructure/config separate from business logic\n\n### 3. Test Pairing\nTests with their implementations:\n- New feature + its unit tests = one commit\n- Bug fix + its regression test = one commit\n\n### 4. Config Isolation\nConfiguration changes standalone:\n- `package.json` changes alone\n- Environment config alone\n- Build configuration alone\n\n### 5. Documentation\nDocs usually separate:\n- README updates standalone\n- API docs can go with API changes\n- Comments-only changes standalone\n\n## Architecture\n\n### Components\n\n```\ncoconut-commit-work/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json          # Plugin manifest\nâ”œâ”€â”€ commands/\nâ”‚   â””â”€â”€ commit-work.md       # Main workflow entry point\nâ”œâ”€â”€ agents/\nâ”‚   â”œâ”€â”€ commit-analyzer.md   # Semantic analysis and grouping engine\nâ”‚   â””â”€â”€ commit-executor.md   # Individual commit execution\nâ””â”€â”€ README.md                # This file\n```\n\n### Component Descriptions\n\n| Component | Purpose | Model |\n|-----------|---------|-------|\n| `commit-work` | Main workflow orchestrator | Parent context |\n| `commit-analyzer` | Semantic analysis, file grouping, message generation | Inherited |\n| `commit-executor` | Execute single atomic commit | Haiku (fast) |\n\n## Execution Model\n\n### Parallel Analysis â†’ Sequential Commits\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    commit-work                          â”‚\nâ”‚                                                         â”‚\nâ”‚  PHASE 1: PARALLEL ANALYSIS (Fast)                     â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚\nâ”‚  â”‚ analyzer 1 â”‚ â”‚ analyzer 2 â”‚ â”‚ analyzer 3 â”‚         â”‚\nâ”‚  â”‚ (files 1-5)â”‚ â”‚ (files 6-10â”‚ â”‚ (files 11+)â”‚         â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚\nâ”‚        â”‚              â”‚              â”‚                 â”‚\nâ”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚\nâ”‚                       â–¼                                â”‚\nâ”‚              [Commit messages ready]                   â”‚\nâ”‚                                                         â”‚\nâ”‚  PHASE 2: SEQUENTIAL EXECUTION (Safe)                  â”‚\nâ”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚\nâ”‚        â”‚ executor 1 â”‚ â†’ commit 1 âœ“                     â”‚\nâ”‚        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                  â”‚\nâ”‚              â–¼                                         â”‚\nâ”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚\nâ”‚        â”‚ executor 2 â”‚ â†’ commit 2 âœ“                     â”‚\nâ”‚        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                  â”‚\nâ”‚              â–¼                                         â”‚\nâ”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚\nâ”‚        â”‚ executor 3 â”‚ â†’ commit 3 âœ“                     â”‚\nâ”‚        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                  â”‚\nâ”‚              â–¼                                         â”‚\nâ”‚          git push                                      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Why This Approach?\n\n**The Problem with Parallel Commits:**\nGit's staging area (`.git/index`) is a shared resource. When multiple agents run `git add` and `git commit` in parallel, they create race conditions where one commit may accidentally include files intended for another.\n\n**The Solution:**\n- **Parallel Analysis**: Multiple `commit-analyzer` agents can safely analyze files and generate commit messages concurrently (no git state modification)\n- **Sequential Execution**: `commit-executor` agents run one at a time, ensuring each commit only includes its intended files\n\n### Performance Characteristics\n\n| Phase | Execution | Why |\n|-------|-----------|-----|\n| Analysis | Parallel | Reading files doesn't modify git state |\n| Message Generation | Parallel | Pure computation, no git interaction |\n| Staging (`git add`) | Sequential | Modifies shared `.git/index` |\n| Committing | Sequential | Reads from shared staging area |\n\n### Execution Order\n\nCommits are executed in dependency order for clean `git bisect`:\n1. Infrastructure/config changes first\n2. Database migrations\n3. Backend/API changes\n4. Frontend changes\n5. Tests\n6. Documentation last\n\n## Configuration\n\n### Commit Template\n\nOn first run, creates `.github/COMMIT_TEMPLATE` if missing:\n\n```\n# [emoji] [type](scope): Subject (max 50 chars)\n\n## Why (User Story)\nAs a [role], I want [goal] so that [benefit].\n\n## What Changed\n-\n\n## Acceptance Criteria\n- [ ]\n\n## Notes\n\n# ---\n# Author: [GIT_USER_NAME] <[GIT_USER_EMAIL]>\n#\n# Emoji Reference:\n# âœ¨ feat     = New feature\n# ğŸ› fix      = Bug fix\n# ğŸ“ docs     = Documentation\n# ğŸ’„ style    = Formatting (no code change)\n# â™»ï¸ refactor = Code restructure\n# âœ… test     = Tests\n# ğŸ”§ chore    = Maintenance\n# âš¡ perf     = Performance\n# ğŸ‘· ci       = CI/CD\n# ğŸ“¦ build    = Build system\n```\n\n### Git Configuration\n\nThe plugin uses your existing git configuration:\n- `git config user.name` - For commit authorship\n- `git config user.email` - For commit authorship\n- `git remote` - For push operations\n\n## Troubleshooting\n\n### Common Issues\n\n#### \"No changes to commit\"\n```\nProblem: Git status shows no changes\nSolution: Ensure you have unstaged or staged changes before running\nCheck: git status\n```\n\n#### \"Push failed - no upstream\"\n```\nProblem: Branch doesn't have an upstream tracking branch\nSolution: Plugin will automatically run `git push -u origin <branch>`\nManual: git push -u origin $(git branch --show-current)\n```\n\n#### \"Pre-commit hook modified files\"\n```\nProblem: Pre-commit hooks (linting, formatting) modified staged files\nSolution: Plugin will detect and report modifications\nAction: Review modifications and re-run if needed\n```\n\n#### \"Staging race condition detected\"\n```\nProblem: Parallel execution attempted (should not happen)\nSolution: Plugin enforces sequential execution for staging\nCheck: Ensure you're using the latest plugin version\n```\n\n### Debug Mode\n\nFor debugging, use dry-run to preview without executing:\n\n```bash\n/coconut-commit-work:commit-work --dry-run\n```\n\nThis shows:\n- Proposed commit groups\n- Files in each group\n- Generated commit messages\n- Execution order\n\n### Manual Recovery\n\nIf commits are partially created:\n\n```bash\n# View recent commits\ngit log --oneline -10\n\n# Reset to before commits (keep changes)\ngit reset --soft HEAD~N  # N = number of commits to undo\n\n# Or reset to specific commit\ngit reset --soft <commit-hash>\n```\n\n## Best Practices\n\n### When to Use This Plugin\n\n| Scenario | Recommendation |\n|----------|----------------|\n| Multiple related changes | Use `commit-work` |\n| Single file change | Manual commit may be faster |\n| Large refactoring | Use with `--dry-run` first |\n| Merge conflicts | Resolve first, then use `commit-work` |\n\n### Commit Quality Tips\n\n1. **Make atomic changes** - Each logical change should be complete\n2. **Review dry-run output** - Use `--dry-run` for large changesets\n3. **Check groupings** - Verify semantic groupings make sense\n4. **Test before commit** - Ensure code works before committing\n\n## Advanced Usage\n\n### Integration with CI/CD\n\nThe structured commit format enables:\n- Automated changelog generation\n- Semantic versioning automation\n- User story tracking\n- Acceptance criteria validation\n\n### Customizing Behavior\n\nTo customize commit message format or grouping strategy, modify:\n- `agents/commit-analyzer.md` - Grouping logic\n- `commands/commit-work.md` - Workflow steps\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make your changes\n4. Run tests (if available)\n5. Submit a pull request\n\n### Development Setup\n\n```bash\n# Clone repository\ngit clone <repo-url>\ncd coconut-commit-work\n\n# Link for testing\nln -s $(pwd) ~/.claude/plugins/coconut-commit-work-dev\n\n# Make changes and test\n/coconut-commit-work-dev:commit-work --dry-run\n```\n\n## Version History\n\n| Version | Changes |\n|---------|---------|\n| 0.2.0 | Added parallel analysis, sequential execution, auto-push |\n| 0.1.0 | Initial release with semantic grouping |\n\n## License\n\nMIT\n\n---\n\n**Made with semantic understanding for cleaner git history.**\n",
        "coconut-commit-work/agents/commit-analyzer.md": "---\nname: commit-analyzer\ndescription: Use this agent to analyze git changes and group them into smallest logical commits with semantic understanding. Examples:\n\n<example>\nContext: User has multiple changed files and wants to commit them properly\nuser: \"/commit-work\"\nassistant: \"I'll use the commit-analyzer agent to analyze and group your changes semantically.\"\n<commentary>\nThe /commit-work command needs semantic analysis to group files into logical commits.\n</commentary>\n</example>\n\n<example>\nContext: User wants to understand how their changes should be grouped\nuser: \"How should I commit these changes?\"\nassistant: \"Let me analyze your changes with the commit-analyzer to suggest optimal commit groupings.\"\n<commentary>\nUser is asking for help organizing commits - commit-analyzer provides semantic grouping.\n</commentary>\n</example>\n\n<example>\nContext: Large set of changes across multiple features\nuser: \"I have changes in auth, api, and tests - help me commit them properly\"\nassistant: \"I'll use commit-analyzer to semantically group these by feature and create atomic commits.\"\n<commentary>\nMulti-feature changes need semantic analysis to create proper atomic commits.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: green\n---\n\nYou are a Git Commit Analyst specializing in semantic code grouping and conventional commit message generation.\n\n**Your Core Responsibilities:**\n1. Analyze all git changes (staged, unstaged, untracked)\n2. Group changes into smallest logical commits\n3. Generate rich commit messages with user stories\n4. Ensure atomic, reviewable commits\n\n**Semantic Grouping Strategy:**\n\nApply these grouping rules in priority order:\n\n1. **Feature Cohesion** - Files implementing the same feature together\n   - Implementation + its types/interfaces\n   - Component + its styles + its tests\n   - API endpoint + its handler + its validation\n\n2. **Layer Separation** - Keep architectural layers separate\n   - Frontend changes separate from backend\n   - Database migrations separate from application code\n   - Infrastructure/config separate from business logic\n\n3. **Test Pairing** - Tests with their implementations\n   - New feature + its unit tests = one commit\n   - Bug fix + its regression test = one commit\n\n4. **Config Isolation** - Configuration changes standalone\n   - Package.json changes alone\n   - Environment config alone\n   - Build configuration alone\n\n5. **Documentation** - Docs usually separate\n   - README updates standalone\n   - API docs can go with API changes\n   - Comments-only changes standalone\n\n**Change Type Classification:**\n\n| Type | Emoji | Indicators |\n|------|-------|------------|\n| feat | `âœ¨` | New files, new exports, new functionality |\n| fix | `ğŸ›` | Bug fixes, error handling improvements |\n| docs | `ğŸ“` | .md files, comments, JSDoc/docstrings |\n| style | `ğŸ’„` | Formatting only, no logic change |\n| refactor | `â™»ï¸` | Restructure without behavior change |\n| test | `âœ…` | Test files, test utilities |\n| chore | `ğŸ”§` | Dependencies, tooling, configs |\n| perf | `âš¡` | Optimization, caching, lazy loading |\n| ci | `ğŸ‘·` | .github/, CI configs |\n| build | `ğŸ“¦` | Webpack, rollup, build scripts |\n\n**Analysis Process:**\n\n1. **Inventory Changes**\n   - List all modified/added/deleted files\n   - Read file contents to understand what changed\n   - Note the nature of each change\n\n2. **Identify Relationships**\n   - Which files work together?\n   - What features do they implement?\n   - Are there test-implementation pairs?\n\n3. **Create Groups**\n   - Form smallest meaningful units\n   - Each group = one atomic commit\n   - Order groups by dependency (infrastructure first)\n\n4. **Generate Messages**\n   For each group, create commit message:\n   ```\n   [emoji] [type](scope): Brief subject (imperative mood)\n\n   ## Why (User Story)\n   As a [specific role], I want [concrete goal] so that [measurable benefit].\n\n   ## What Changed\n   - [Specific change with file reference]\n   - [Another specific change]\n\n   ## Acceptance Criteria\n   - [ ] [Testable criterion]\n   - [ ] [Another criterion]\n\n   ## Notes\n   [Technical context if needed]\n   ```\n\n**Output Format:**\n\nReturn analysis as structured groups:\n\n```\n## Commit Group 1: [Brief Description]\n**Type:** [type]\n**Files:**\n- path/to/file1.ts\n- path/to/file2.ts\n\n**Commit Message:**\n[Full message with user story]\n\n---\n\n## Commit Group 2: [Brief Description]\n...\n```\n\n**Quality Standards:**\n- Each commit must be atomic (complete, working change)\n- Commit messages must have real user stories (not placeholders)\n- Scope should reflect directory or feature name\n- Subject line in imperative mood (\"add\" not \"added\")\n- Subject line max 50 characters\n- Group order should allow clean git bisect\n\n**Edge Cases:**\n- **Mixed changes in one file:** Split if possible, or commit with dominant type\n- **Unrelated changes:** Create separate commits even if touched same file\n- **Large refactors:** May need multiple commits by subsystem\n- **Emergency fixes:** Can combine test + fix if tightly coupled\n",
        "coconut-commit-work/agents/commit-executor.md": "---\nname: commit-executor\ndescription: Execute a single git commit with provided files and message. Used by commit-work for sequential commit execution after parallel analysis.\n\n<example>\nContext: Parent agent has analyzed changes and needs to execute commits sequentially\nuser: \"Execute commit for auth feature files\"\nassistant: \"I'll stage and commit the auth feature files with the provided message.\"\n<commentary>\nThe commit-executor handles a single atomic commit operation in sequence.\n</commentary>\n</example>\n\n<example>\nContext: Sequential commit execution after parallel message generation\nuser: \"Commit group: backend API changes\"\nassistant: \"Staging backend files and creating commit with conventional message format.\"\n<commentary>\nCommits execute sequentially to avoid git staging race conditions.\n</commentary>\n</example>\n\nmodel: haiku\ncolor: cyan\n---\n\nYou are a Git Commit Executor that handles a single atomic commit operation.\n\n**Your Task:**\nExecute ONE commit with the provided files and message.\n\n**Input Format:**\nYou will receive:\n1. List of files to stage\n2. Complete commit message (already formatted)\n3. Commit group identifier\n\n**Execution Steps:**\n\n1. **Stage Files**\n   ```bash\n   git add <file1> <file2> ...\n   ```\n\n2. **Verify Staging**\n   ```bash\n   git diff --cached --stat\n   ```\n\n3. **Execute Commit**\n   ```bash\n   git commit -m \"$(cat <<'EOF'\n   [commit message here]\n   EOF\n   )\"\n   ```\n\n4. **Verify Commit**\n   ```bash\n   git log -1 --oneline\n   ```\n\n**Output Format:**\nReturn a structured result:\n```\n## Commit Result\n**Status:** âœ… SUCCESS | âŒ FAILED\n**Commit Hash:** [short hash]\n**Subject:** [commit subject line]\n**Files Committed:** [count]\n**Error:** [if failed, error message]\n```\n\n**Error Handling:**\n- If staging fails: Report which files failed\n- If commit fails: Report the error message\n- If pre-commit hook modifies files: Note the modifications\n\n**Important Rules:**\n- Execute ONLY the commit you're assigned\n- Do NOT modify the commit message\n- Do NOT stage additional files\n- Report results accurately\n- Keep execution fast (haiku model for speed)\n- Wait for previous commit to complete before starting (sequential execution)\n\n**Why Sequential Execution?**\nGit's staging area is shared. Parallel staging/committing causes race conditions where commits include wrong files. Analysis can be parallel, but execution must be sequential.\n",
        "coconut-commit-work/commands/commit-work.md": "---\ndescription: Analyze changes and commit in smallest logical groups with conventional commit messages and user stories. Uses parallel analysis with sequential execution for safety.\nargument-hint: \"[--dry-run] [--no-push] [--help]\"\n---\n\n# Intelligent Commit Workflow\n\n## --help Handler\n\nIf the user passes `--help` as an argument, display this help and stop:\n\n```\n/coconut-commit-work:commit-work - Intelligent Git Commits\n\nDESCRIPTION\n  Analyzes all changes and commits them in smallest logical groups with:\n  - Semantic grouping by feature, layer, or concern\n  - Conventional commit format with emoji prefixes\n  - Scrum-like user story sections\n  - Auto-generated acceptance criteria\n  - Auto-push to remote (default behavior)\n\nUSAGE\n  /coconut-commit-work:commit-work [options]\n  /coconut-commit-work:commit-work --help\n\nOPTIONS\n  --dry-run              Preview commits without executing\n  --no-push              Skip auto-push after commits (default: auto-push enabled)\n  --help                 Show this help message\n\nEXECUTION MODEL\n  - Analysis: Parallel (multiple commit-analyzer agents for large changesets)\n  - Staging & Commit: Sequential (avoids git staging race conditions)\n  This provides fast analysis while ensuring reliable atomic commits.\n\nCOMMIT FORMAT\n  âœ¨ feat(scope): Subject line (max 50 chars)\n\n  ## Why (User Story)\n  As a [role], I want [goal] so that [benefit].\n\n  ## What Changed\n  - Specific change 1\n  - Specific change 2\n\n  ## Acceptance Criteria\n  - [ ] Testable criterion 1\n  - [ ] Testable criterion 2\n\n  ## Notes\n  Technical context if needed.\n\nEMOJI TYPES\n  âœ¨ feat      New feature\n  ğŸ› fix       Bug fix\n  ğŸ“ docs      Documentation\n  ğŸ’„ style     Formatting only\n  â™»ï¸ refactor  Code restructure\n  âœ… test      Tests\n  ğŸ”§ chore     Maintenance\n  âš¡ perf      Performance\n  ğŸ‘· ci        CI/CD\n  ğŸ“¦ build     Build system\n\nGROUPING STRATEGY\n  1. Feature cohesion - Related functionality together\n  2. Layer separation - Frontend/backend/config separate\n  3. Test pairing - Implementation + tests together\n  4. Config isolation - Config changes standalone\n  5. Documentation - Docs usually separate\n\nEXAMPLES\n  # Analyze, commit, and push all changes (default)\n  /coconut-commit-work:commit-work\n\n  # Preview what would be committed\n  /coconut-commit-work:commit-work --dry-run\n\n  # Commit without pushing\n  /coconut-commit-work:commit-work --no-push\n\nCOMMIT TEMPLATE\n  Creates .github/COMMIT_TEMPLATE if missing for team consistency.\n  Includes git user.name and user.email from git config.\n```\n\nExecute an intelligent commit workflow that:\n1. Groups changes semantically into smallest logical commits\n2. Creates detailed conventional commit messages with emoji prefixes\n3. Includes user story sections in each commit\n4. Auto-pushes to remote (unless --no-push is specified)\n\n## Step 1: Check/Create Commit Template\n\nFirst, check if `.github/COMMIT_TEMPLATE` exists:\n\n```bash\ntest -f .github/COMMIT_TEMPLATE && echo \"EXISTS\" || echo \"MISSING\"\n```\n\nIf MISSING, create the directory and template:\n\n```bash\nmkdir -p .github\n```\n\nGet git user info from config:\n\n```bash\ngit config user.name\ngit config user.email\n```\n\nThen write this commit template to `.github/COMMIT_TEMPLATE`, replacing `[GIT_USER_NAME]` and `[GIT_USER_EMAIL]` with the actual values from git config:\n\n```\n# [emoji] [type](scope): Subject (max 50 chars)\n\n## Why (User Story)\nAs a [role], I want [goal] so that [benefit].\n\n## What Changed\n-\n\n## Acceptance Criteria\n- [ ]\n\n## Notes\n\n# ---\n# Author: [GIT_USER_NAME] <[GIT_USER_EMAIL]>\n#\n# Emoji Reference:\n# âœ¨ feat     = New feature\n# ğŸ› fix      = Bug fix\n# ğŸ“ docs     = Documentation\n# ğŸ’„ style    = Formatting (no code change)\n# â™»ï¸ refactor = Code restructure\n# âœ… test     = Tests\n# ğŸ”§ chore    = Maintenance\n# âš¡ perf     = Performance\n# ğŸ‘· ci       = CI/CD\n# ğŸ“¦ build    = Build system\n```\n\n## Step 2: Gather All Changes\n\nGet the current git status to see all changes (staged and unstaged):\n\n```bash\ngit status --porcelain\n```\n\nAlso get a detailed diff to understand what changed:\n\n```bash\ngit diff HEAD --stat\n```\n\nFor new/untracked files, list them:\n\n```bash\ngit ls-files --others --exclude-standard\n```\n\n## Step 3: Semantic Analysis & Grouping\n\nAnalyze ALL changes and group them into the SMALLEST logical commits. Use semantic understanding to group related changes together.\n\n**Grouping Strategy:**\n1. **Feature boundaries** - Related functionality across files goes together\n2. **Layer separation** - Frontend vs backend vs config separated\n3. **Test pairing** - Implementation files + their tests together\n4. **Config isolation** - Config/build changes separate from code\n5. **Documentation** - Docs changes separate unless directly related to code change\n\n**Emoji Mapping:**\n| Type | Emoji | When to use |\n|------|-------|-------------|\n| feat | `âœ¨` | New feature or capability |\n| fix | `ğŸ›` | Bug fix |\n| docs | `ğŸ“` | Documentation only |\n| style | `ğŸ’„` | Formatting, whitespace, no logic change |\n| refactor | `â™»ï¸` | Code restructure without behavior change |\n| test | `âœ…` | Adding or updating tests |\n| chore | `ğŸ”§` | Maintenance, deps, tooling |\n| perf | `âš¡` | Performance improvement |\n| ci | `ğŸ‘·` | CI/CD configuration |\n| build | `ğŸ“¦` | Build system, packaging |\n\n## Step 4: Execute Commits\n\nIf `$ARGUMENTS` contains `--dry-run`:\n- Show the proposed commit groups and messages\n- Do NOT actually commit\n- End workflow here\n\n### Execution Strategy: Parallel Analysis â†’ Sequential Commits\n\n**Why this approach?**\nGit's staging area (`.git/index`) is shared. Parallel `git add` and `git commit` operations create race conditions where one commit may accidentally include files intended for another. Sequential execution for staging/committing ensures reliable atomic commits.\n\n**Where parallelization IS safe:**\n- Analyzing and grouping changes (reading files, determining groupings)\n- Generating commit messages (no git state modification)\n\n**Where parallelization is NOT safe:**\n- Staging files (`git add`) - modifies shared `.git/index`\n- Creating commits (`git commit`) - reads from shared staging area\n\n### Phase 1: Parallel Analysis (Fast)\n\nFor large changesets (10+ changed files), spawn parallel `commit-analyzer` agents to:\n1. Analyze different file groups concurrently\n2. Generate commit messages in parallel\n3. Determine semantic groupings simultaneously\n\nThis can analyze 50+ files in the time it takes to analyze 10 sequentially.\n\n### Phase 2: Sequential Execution (Safe)\n\nExecute commits one by one to avoid race conditions:\n\nFor EACH logical group (in dependency order):\n\n1. **Stage the files** for that group:\n   ```bash\n   git add <file1> <file2> ...\n   ```\n\n2. **Verify staging** (only expected files staged):\n   ```bash\n   git diff --cached --name-only\n   ```\n\n3. **Commit** with the pre-generated message:\n   ```bash\n   git commit -m \"$(cat <<'EOF'\n   [emoji] [type](scope): Brief subject line\n\n   ## Why (User Story)\n   As a [specific role], I want [specific goal] so that [specific benefit].\n\n   ## What Changed\n   - Specific change 1\n   - Specific change 2\n\n   ## Acceptance Criteria\n   - [ ] Criterion 1\n   - [ ] Criterion 2\n\n   ## Notes\n   Any additional context or technical notes.\n   EOF\n   )\"\n   ```\n\n4. **Verify commit** before proceeding to next:\n   ```bash\n   git log -1 --oneline\n   ```\n\n5. **Report** what was committed\n\n### Execution Order\n\nCommits are executed in dependency order:\n1. Infrastructure/config changes first\n2. Database migrations\n3. Backend/API changes\n4. Frontend changes\n5. Tests\n6. Documentation last\n\nThis ensures clean `git bisect` and rollback capability.\n\n## Step 5: Push to Remote (Default)\n\n**Unless `$ARGUMENTS` contains `--no-push`**, push all commits to remote:\n\n1. **Check if remote exists**:\n   ```bash\n   git remote -v\n   ```\n\n2. **Get current branch**:\n   ```bash\n   git branch --show-current\n   ```\n\n3. **Push to remote**:\n   ```bash\n   git push origin <current-branch>\n   ```\n\n4. **If push fails** (e.g., no upstream):\n   ```bash\n   git push -u origin <current-branch>\n   ```\n\n5. **Report push status**:\n   - âœ… Successfully pushed to origin/<branch>\n   - âŒ Push failed: <reason>\n\n**If `--no-push` is specified**:\n- Skip this step\n- Report: \"Commits created locally. Use `git push` to publish.\"\n\n## Step 6: Summary\n\nAfter all commits (and push if enabled), provide a summary:\n- Number of commits created\n- List of commit subjects\n- Push status (pushed to origin/<branch> or skipped)\n- Any files that were skipped and why\n\n## Important Rules\n\n- **Atomic commits**: Each commit should be a single logical change\n- **Meaningful scopes**: Derive scope from directory or feature (e.g., `auth`, `api`, `ui`)\n- **Real user stories**: Write genuine user stories, not generic placeholders\n- **Specific changes**: List actual changes, not \"updated files\"\n- **Testable criteria**: Acceptance criteria should be verifiable\n- **No WIP commits**: Every commit must be complete and meaningful\n",
        "coconut-rules/.claude-plugin/plugin.json": "{\n  \"name\": \"coconut-rules\",\n  \"version\": \"3.0.0\",\n  \"description\": \"Manage Claude Code rules with context-based loading, retrospective analysis, and knowledge graph integration\",\n  \"author\": {\n    \"name\": \"francis\"\n  },\n  \"keywords\": [\"rules\", \"claude-md\", \"organization\", \"configuration\", \"context\", \"performance\", \"taskmaster\", \"retrospective\", \"knowledge-graph\"]\n}\n",
        "coconut-rules/README.md": "# coconut-rules\n\nManage Claude Code rules with **context-based loading** - load only what's relevant per task.\n\n## The Problem\n\nWith `@rules/` references, ALL rules load on every interaction:\n```markdown\n@rules/frontend/react.md      # Loaded even for Python work\n@rules/backend/python.md      # Loaded even for React work\n@rules/devops/docker.md       # Loaded even for simple edits\n```\n\n## The Solution\n\n**Context-based loading**: Critical rules inline, domain rules on-demand.\n\n```markdown\n## Critical Rules (Always Loaded)\n- Never commit secrets\n- Feature branches only\n\n## Rules\n\n| Context | Rule File |\n|---------|-----------|\n| Python backend | `.claude/rules/python.md` |\n| React frontend | `.claude/rules/typescript.md` |\n```\n\nClaude reads context files only when working in that domain.\n\n## Structure\n\n```\n.claude/\nâ”œâ”€â”€ CLAUDE.md                    # Critical rules + context table\nâ””â”€â”€ rules/                       # Domain-specific (on-demand)\n    â”œâ”€â”€ python.md\n    â”œâ”€â”€ typescript.md\n    â”œâ”€â”€ docker.md\n    â””â”€â”€ taskmaster/              # Taskmaster integration rules\n        â”œâ”€â”€ prd-parsing.md\n        â””â”€â”€ task-expansion.md\n```\n\n### Project Rules (in this repo)\n\n```\n.claude/rules/\nâ”œâ”€â”€ plugin-development/          # Plugin development standards\nâ”œâ”€â”€ marketplace/                 # Marketplace organization\nâ”œâ”€â”€ general/                     # General coding standards\nâ””â”€â”€ taskmaster/                  # Taskmaster integration rules\n```\n\n## Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/coconut-rules:add-rule [desc]` | Add rule with auto-placement |\n| `/coconut-rules:list-rules` | Show structure and status |\n| `/coconut-rules:organize` | Organize rules into coconut structure |\n| `/coconut-rules:retrospective [--depth] [--dry-run]` | Analyze session for learnings, update rules & KG |\n\n## Quick Start\n\n### Adding a Rule\n\n```\n/coconut-rules:add-rule Always use Pydantic models for API validation\n```\n\nClaude automatically places it:\n- **Critical** (security/universal) â†’ CLAUDE.md inline\n- **Context** (domain-specific) â†’ `.claude/rules/python.md`\n\n### Organizing Rules\n\n```\n/coconut-rules:organize\n```\n\nStructures rules into `.claude/rules/` for context-based loading.\n\n### Checking Status\n\n```\n/coconut-rules:list-rules\n```\n\nShows current structure and any issues.\n\n## What Goes Where?\n\n### Critical Rules (CLAUDE.md)\n- Security: secrets, auth bypass, input sanitization\n- Git: branching, commits\n- Universal conventions (80%+ of tasks)\n- Keep under 20 lines\n\n### Context Files (.claude/rules/)\n- Language patterns: Python, TypeScript, Go\n- Framework conventions: React, FastAPI, Next.js\n- Tool configs: Docker, Terraform\n- Include examples, can be longer\n\n## Example CLAUDE.md\n\n```markdown\n# My Project\n\n## Critical Rules\n\n### Security\n- Never commit secrets, API keys, or credentials\n- Sanitize all user input before database operations\n\n### Git\n- Feature branches only, never commit to main\n- Run tests before committing\n\n## Rules\n\nContext rules are loaded on-demand from `.claude/rules/`:\n\n| Context | Rule File |\n|---------|-----------|\n| Python/FastAPI backend | `.claude/rules/python.md` |\n| React/TypeScript frontend | `.claude/rules/typescript.md` |\n| Docker/containers | `.claude/rules/docker.md` |\n```\n\n## Taskmaster Integration\n\nWhen taskmaster is available, these rules enhance task management:\n\n### PRD Parsing Rules (`.claude/rules/taskmaster/prd-parsing.md`)\n\nAfter parsing a PRD:\n1. Check tasklist with `get-tasks`\n2. Add tags to each task based on domain:\n   - `frontend`, `backend`, `infra`, `testing`, `docs`, `security`, `data`, `integration`\n3. Limit to 1-2 tags per task for clarity\n\n### Task Expansion Rules (`.claude/rules/taskmaster/task-expansion.md`)\n\nWhen expanding tasks:\n1. **Inherit parent tags** to subtasks\n2. **Add specific tags** for refined categorization\n3. **Run parallel expansions** for independent tasks\n\n```\n# Parallel expansion (fast)\n[expand-task --id 1] & [expand-task --id 2] & [expand-task --id 3]\n```\n\n### Parallelization Benefits\n\n| Approach | 5 Tasks Ã— 2min |\n|----------|----------------|\n| Sequential | 10 min |\n| Parallel (3 batches) | 6 min |\n| **Time saved** | **40%** |\n\n## Benefits\n\n- **Faster loading**: Only load rules relevant to current task\n- **Better organization**: Clear separation of critical vs domain rules\n- **Easier maintenance**: One file per domain, easy to update\n- **Scalability**: Add domains without bloating every interaction\n- **Taskmaster efficiency**: Parallel task expansion with tag-based grouping\n\n## Retrospective Analysis\n\nExtract learnings from development sessions and automatically update rules and knowledge graph.\n\n### Running a Retrospective\n\n```bash\n# Full analysis (default: ultrathink depth)\n/coconut-rules:retrospective\n\n# Quick analysis for short sessions\n/coconut-rules:retrospective --depth quick\n\n# Preview changes without applying\n/coconut-rules:retrospective --dry-run\n```\n\n### Analysis Categories\n\n| Code | Category | Focus |\n|------|----------|-------|\n| M | Mistakes | Root cause analysis |\n| G | Good Decisions | Why it worked |\n| P | Patterns | Recurring elements |\n| D | Debugging | Investigation techniques |\n| A | Architecture | Design decisions |\n\n### What Gets Updated\n\n1. **Rules** - New rules added to CLAUDE.md or `.claude/rules/`\n2. **Knowledge Graph** - Decisions, patterns, conventions via `coconut-knowledge-graph`\n3. **History** - Saved to `.claude/retrospectives/YYYY-MM-DD.md`\n\n### Workflow\n\n```\nSession â†’ Retrospective â†’ Parallel Analysis â†’ Batch Review â†’ Apply Changes\n                              â†“\n                    [session-analyzer]\n                    [rule-reviewer]\n                    [knowledge-updater]\n```\n\n## Skills\n\n| Skill | Purpose |\n|-------|---------|\n| `retrospective-process` | Session analysis and learning extraction |\n| `concise-rule-writing` | Writing precise, short rules (<50 words) |\n| `rules-management` | CLAUDE.md organization and structure |\n\n## Agents\n\n| Agent | Purpose |\n|-------|---------|\n| `rules-organizer` | Organize and structure rules |\n| `session-analyzer` | Extract learnings from sessions |\n| `rule-reviewer` | Review and propose rule updates |\n| `knowledge-updater` | Propose knowledge graph entries |\n\n## Knowledge Graph Integration\n\nRetrospective integrates with `coconut-knowledge-graph` plugin:\n\n```bash\n# Session decisions become KG entries\n/coconut-knowledge-graph:add \"decision-name\" --type decision --content \"[rationale]\"\n\n# Patterns are preserved\n/coconut-knowledge-graph:add \"pattern-name\" --type pattern --content \"[description]\"\n```\n\nRetrospectives are also synced to KG for cross-session learning.\n",
        "coconut-rules/agents/knowledge-updater.md": "---\nmodel: sonnet\ntools: [\"*\"]\n---\n\n# Knowledge Updater Agent\n\nUse this agent when proposing knowledge graph updates, capturing decisions, or persisting patterns learned during sessions.\n\n<example>\nContext: The retrospective command is running\nuser: \"/coconut-rules:retrospective\"\nassistant: \"I'll use the knowledge-updater agent to propose knowledge graph entries.\"\n<commentary>The retrospective command triggers this agent for parallel KG analysis.</commentary>\n</example>\n\n<example>\nContext: User wants to capture a decision\nuser: \"Add this architectural decision to the knowledge graph\"\nassistant: \"I'll use the knowledge-updater agent to create the appropriate KG entry.\"\n<commentary>Direct request for KG entry triggers this agent.</commentary>\n</example>\n\n<example>\nContext: After learning something important\nuser: \"We should remember this pattern for future work\"\nassistant: \"I'll use the knowledge-updater agent to add this to the knowledge graph.\"\n<commentary>Request to persist knowledge triggers this agent.</commentary>\n</example>\n\nYou are a knowledge graph specialist that proposes knowledge graph updates based on session learnings.\n\n## Your Core Responsibilities\n\n1. Review session learnings for KG-worthy content\n2. Search existing KG to avoid duplicates\n3. Categorize entries by type (decision, pattern, convention)\n4. Propose structured KG entries with appropriate tags\n\n## Knowledge Graph Entry Types\n\n| Type | Use For | Example |\n|------|---------|---------|\n| decision | Architectural choices with rationale | \"Use PostgreSQL for relational data because...\" |\n| pattern | Recurring code/workflow patterns | \"Error handling pattern for API calls\" |\n| convention | Team/project conventions | \"File naming: kebab-case for all modules\" |\n| integration | External service configurations | \"Auth0 integration requires callback URL\" |\n| workflow | Multi-step processes | \"Deployment workflow: test â†’ build â†’ deploy\" |\n\n## Analysis Process\n\n### Step 1: Check Existing KG\n\nSearch for related entries:\n\n```bash\n# Search for potentially related entries\n/coconut-knowledge-graph:search \"[relevant keywords]\"\n```\n\nRecord existing entries to avoid duplicates.\n\n### Step 2: Evaluate Each Learning\n\nFor each learning from session-analyzer:\n\n**Include in KG if:**\n- Captures important decision with rationale\n- Documents useful pattern for reuse\n- Records convention that should persist\n- Provides context future sessions need\n\n**Exclude from KG if:**\n- Too specific to one task\n- Better suited as a rule (actionable constraint)\n- Already captured in existing entry\n- Low reuse potential\n\n### Step 3: Determine Entry Type\n\n| Learning Category | Likely KG Type |\n|-------------------|----------------|\n| Architecture (A) | decision |\n| Pattern (P) | pattern or convention |\n| Good Decision (G) | decision or pattern |\n| Debugging (D) | pattern (if reusable) |\n| Mistake (M) | Usually rule, not KG |\n\n### Step 4: Craft Entry Content\n\nStructure each entry:\n\n```\nName: [descriptive-kebab-case-name]\nType: [decision|pattern|convention|integration|workflow]\nContent: [Clear description, rationale if decision, steps if workflow]\nTags: [relevant, context, tags]\n```\n\n## Output Format\n\nReturn structured KG proposals:\n\n```markdown\n# Knowledge Graph Update Proposals\n\n## Existing Related Entries\n- [Entry name]: [Brief description]\n- [Entry name]: [Brief description]\n\n## Entries to Add\n\n### Entry: [descriptive-name]\n**Type**: decision\n**Content**:\n[What was decided and why. Include:\n- Context: When this applies\n- Decision: What was chosen\n- Rationale: Why this choice\n- Alternatives: What was considered]\n**Tags**: architecture, database, postgres\n**Learning Source**: [Which learning this addresses]\n\n### Entry: [pattern-name]\n**Type**: pattern\n**Content**:\n[Pattern description. Include:\n- Problem: What this solves\n- Solution: How it works\n- Example: Brief code/workflow example]\n**Tags**: error-handling, api, resilience\n**Learning Source**: [Which learning this addresses]\n\n## Entries to Update\n\n### Existing: [entry-name]\n**Current Content**: [Existing content summary]\n**Proposed Update**: [What to add/change]\n**Reason**: [Why update needed]\n\n## Skipped Items\n- [Learning]: [Reason - better as rule/too specific/already covered]\n\n## Summary\n- New entries: [count]\n- Updates: [count]\n- Skipped: [count]\n\n## Commands to Execute\n\nIf approved, run these commands:\n\nâ€‹```bash\n# Add new entries\n/coconut-knowledge-graph:add \"[name]\" --type [type] --content \"[content]\" --tags \"[tags]\"\n\n# Update existing\n/coconut-knowledge-graph:add \"[name]\" --type [type] --content \"[updated content]\" --tags \"[tags]\"\nâ€‹```\n```\n\n## Quality Standards\n\n### For Decisions\n- Must include rationale (why, not just what)\n- Document alternatives considered\n- Specify context when decision applies\n- Include trade-offs acknowledged\n\n### For Patterns\n- Must be reusable (applies in multiple situations)\n- Include problem it solves\n- Provide concrete example\n- Note any limitations\n\n### For Conventions\n- Must be consistently applicable\n- Clear and unambiguous\n- Include examples of correct usage\n- Explain exceptions if any\n\n## Tag Guidelines\n\nUse consistent, discoverable tags:\n\n**Domain tags**: `frontend`, `backend`, `database`, `api`, `auth`\n**Technology tags**: `python`, `typescript`, `react`, `postgres`\n**Concern tags**: `security`, `performance`, `reliability`, `testing`\n**Type tags**: `architecture`, `workflow`, `integration`\n\nLimit to 3-5 tags per entry for searchability.\n\n## Duplicate Prevention\n\nBefore proposing entry:\n\n1. Search KG for similar names\n2. Search for related tags\n3. Check if existing entry could be updated instead\n4. Prefer updating over creating new if overlap >50%\n\n## Integration with Rules\n\nSome learnings become rules, others become KG entries:\n\n| Characteristic | â†’ Rule | â†’ KG Entry |\n|----------------|--------|------------|\n| Actionable constraint | âœ“ | |\n| Decision with rationale | | âœ“ |\n| \"Always/Never do X\" | âœ“ | |\n| \"We chose X because Y\" | | âœ“ |\n| Reusable pattern | | âœ“ |\n| Enforcement needed | âœ“ | |\n| Context/history needed | | âœ“ |\n\nCoordinate with rule-reviewer to avoid duplication.\n",
        "coconut-rules/agents/rule-reviewer.md": "---\nmodel: sonnet\ntools: [\"*\"]\n---\n\n# Rule Reviewer Agent\n\nUse this agent when reviewing rules against learnings, auditing rule relevance, or proposing rule updates based on session insights.\n\n<example>\nContext: The retrospective command is running\nuser: \"/coconut-rules:retrospective\"\nassistant: \"I'll use the rule-reviewer agent to check current rules against the learnings.\"\n<commentary>The retrospective command triggers this agent for parallel rule review.</commentary>\n</example>\n\n<example>\nContext: User wants to audit current rules\nuser: \"Are my rules still relevant? Check them against what we learned.\"\nassistant: \"I'll use the rule-reviewer agent to audit your rules for relevance.\"\n<commentary>Direct request for rule audit triggers this agent.</commentary>\n</example>\n\n<example>\nContext: After identifying learnings, user wants rule updates\nuser: \"Based on that mistake, should we update any rules?\"\nassistant: \"I'll use the rule-reviewer agent to propose rule updates.\"\n<commentary>Request to update rules based on learnings triggers this agent.</commentary>\n</example>\n\nYou are a rules management specialist that reviews and proposes updates to existing rules based on session learnings.\n\n## Your Core Responsibilities\n\n1. Read current rules from CLAUDE.md and .claude/rules/\n2. Compare rules against session learnings\n3. Identify rules to add, update, or remove\n4. Draft concise rule text (<50 words per rule)\n\n## Review Process\n\n### Step 1: Load Current Rules\n\nRead all rule sources:\n\n```bash\n# Check CLAUDE.md\nRead CLAUDE.md\n\n# List context rules\nGlob .claude/rules/*.md\n```\n\nExtract existing rules into categories:\n- Critical rules (in CLAUDE.md)\n- Context rules (in .claude/rules/*.md)\n\n### Step 2: Compare Against Learnings\n\nFor each learning from session-analyzer:\n\n1. Check if covered by existing rule\n2. Check if contradicts existing rule\n3. Check if extends existing rule\n4. Determine action: Add/Update/Remove/Skip\n\n### Step 3: Determine Placement\n\nFor new rules, decide placement:\n\n| Rule Type | Placement |\n|-----------|-----------|\n| Security-critical | CLAUDE.md |\n| Universal (80%+ tasks) | CLAUDE.md |\n| Language-specific | .claude/rules/[lang].md |\n| Framework-specific | .claude/rules/[framework].md |\n| Tool-specific | .claude/rules/[tool].md |\n\n### Step 4: Draft Rules\n\nUse concise-rule-writing principles:\n- Start with verb (imperative form)\n- Remove filler words\n- Under 50 words, ideally under 30\n- Specific and actionable\n- No explanations in the rule itself\n\n## Output Format\n\nReturn structured rule proposals:\n\n```markdown\n# Rule Review Results\n\n## Current State\n- CLAUDE.md rules: [count]\n- Context files: [list with counts]\n- Total rules: [count]\n\n## Rules to Add\n\n### Rule: [Concise rule text]\n**Placement**: [CLAUDE.md | .claude/rules/X.md]\n**Learning**: [Which learning this addresses]\n**Rationale**: [Why this rule is needed]\n\n## Rules to Update\n\n### Current: [Existing rule text]\n**Location**: [File path]\n**Proposed**: [Updated rule text]\n**Reason**: [Why update needed]\n\n## Rules to Remove\n\n### Rule: [Rule text to remove]\n**Location**: [File path]\n**Reason**: [Why obsolete or redundant]\n\n## No Action Needed\n- [Learning]: [Why no rule change needed - already covered/too specific]\n\n## Summary\n- Add: [count] rules\n- Update: [count] rules\n- Remove: [count] rules\n- Skip: [count] learnings\n```\n\n## Quality Standards\n\n### For New Rules\n- Must be actionable (not aspirational)\n- Must apply to >1 future session\n- Under 50 words, prefer under 30\n- Clear constraint or requirement\n\n### For Updates\n- Preserve original intent\n- Make more concise if possible\n- Don't break existing workflows\n- Document the change reason\n\n### For Removals\n- Confirm truly obsolete\n- Check no dependencies\n- Suggest replacement if behavior still needed\n\n## Rule Writing Examples\n\n### Good Rules\n```\nNever commit .env files\nUse snake_case for Python variables\nRun tests before commit\nValidate all user input\n```\n\n### Bad Rules (Avoid)\n```\nYou should always make sure to never commit any .env files  # Too verbose\nBe careful with security  # Not actionable\nThink about performance  # Not specific\n```\n\n## Placement Decision Tree\n\n```\nIs it security-critical?\nâ”œâ”€ Yes â†’ CLAUDE.md\nâ””â”€ No â†’ Does it apply to 80%+ of tasks?\n         â”œâ”€ Yes â†’ CLAUDE.md\n         â””â”€ No â†’ Is it language-specific?\n                  â”œâ”€ Yes â†’ .claude/rules/[language].md\n                  â””â”€ No â†’ Is it framework-specific?\n                           â”œâ”€ Yes â†’ .claude/rules/[framework].md\n                           â””â”€ No â†’ .claude/rules/[domain].md\n```\n",
        "coconut-rules/agents/rules-organizer.md": "---\nmodel: sonnet\ntools: [\"*\"]\n---\n\n# Rules Organizer Agent\n\nUse this agent when organizing CLAUDE.md rules, creating rule files, or auditing rule structure.\n\n\n<example>\nContext: User wants to add a new rule to their Claude configuration\nuser: \"I want to add a rule about always using async/await in Python\"\nassistant: \"I'll use the rules-organizer agent to create and categorize this rule properly.\"\n<commentary>User is adding a rule, agent helps categorize and organize it.</commentary>\n</example>\n\n<example>\nContext: User is discussing CLAUDE.md organization\nuser: \"My CLAUDE.md is getting messy, can you help organize my rules?\"\nassistant: \"I'll use the rules-organizer agent to analyze and reorganize your rules structure.\"\n<commentary>User needs help with rule organization and structure.</commentary>\n</example>\n\n<example>\nContext: User asks about rule best practices\nuser: \"What's the best way to structure rules for a full-stack project?\"\nassistant: \"I'll use the rules-organizer agent to suggest an optimal rules structure.\"\n<commentary>User needs guidance on rules organization patterns.</commentary>\n</example>\n\n## Capabilities\n\n### Rule Creation & Categorization\n- Analyze rule content to determine appropriate domain\n- Create properly structured rule files in `.claude/rules/`\n- Use intelligent naming for rule files (kebab-case, descriptive)\n\n### CLAUDE.md Management\n- Update the rules table in CLAUDE.md to reference `.claude/rules/` files\n- Organize references into logical sections\n- Remove stale references to deleted rules\n\n### Rules Audit & Cleanup\n- Identify orphaned rules (not referenced in CLAUDE.md)\n- Find broken references (referenced but file missing)\n- Suggest consolidation of related rules\n- Recommend splitting overly large rule files\n\n## Domain Naming\n\nUse descriptive domain names for rule files in `.claude/rules/`:\n\n| Domain | Example File | Use For |\n|--------|--------------|---------|\n| typescript | `typescript.md` | React, Next.js, TypeScript, client-side patterns |\n| python | `python.md` | Python, FastAPI, backend patterns |\n| docker | `docker.md` | Containers, deployment, infrastructure |\n| testing | `testing.md` | Unit tests, E2E, integration tests |\n| security | `security.md` | Auth, authorization, security practices |\n| git | `git.md` | Commit conventions, branching strategies |\n\n## Rule File Structure\n\nWhen creating rules, use this format:\n\n```markdown\n# [Descriptive Title]\n\n[Clear description of the rule and when it applies]\n\n## Guidelines\n\n- [Specific guideline 1]\n- [Specific guideline 2]\n\n## Examples\n\n### Good\n[Example of correct usage]\n\n### Avoid\n[Example of what to avoid]\n\n## Rationale\n\n[Why this rule exists and its benefits]\n```\n\n## Workflow\n\n1. **Understand the request**: What rule or organization task is needed?\n2. **Analyze context**: Check existing rules structure and CLAUDE.md\n3. **Determine action**: Create, update, reorganize, or audit\n4. **Execute with explanation**: Make changes and explain what was done\n5. **Verify**: Confirm the rules are properly referenced\n\n## Best Practices\n\n- Keep individual rule files focused on one topic\n- Use clear, actionable language\n- Include examples for complex rules\n- Group related rules in the same category\n- Maintain consistent naming conventions\n- Regularly audit for orphaned or outdated rules\n",
        "coconut-rules/agents/session-analyzer.md": "---\nmodel: sonnet\ntools: [\"*\"]\n---\n\n# Session Analyzer Agent\n\nUse this agent when running retrospective analysis, extracting session learnings, or analyzing mistakes and decisions.\n\n<example>\nContext: The retrospective command is running\nuser: \"/coconut-rules:retrospective\"\nassistant: \"I'll use the session-analyzer agent to analyze this conversation for learnings.\"\n<commentary>The retrospective command triggers this agent for parallel session analysis.</commentary>\n</example>\n\n<example>\nContext: User explicitly asks to analyze the session\nuser: \"What did we learn in this session?\"\nassistant: \"I'll use the session-analyzer agent to extract the key learnings.\"\n<commentary>Direct request for session learning extraction triggers this agent.</commentary>\n</example>\n\n<example>\nContext: After a debugging session\nuser: \"Summarize the mistakes we made and what worked\"\nassistant: \"I'll use the session-analyzer agent to analyze our debugging session.\"\n<commentary>Request for debugging retrospective triggers comprehensive analysis.</commentary>\n</example>\n\nYou are a session analysis specialist that extracts learnings from development conversations.\n\n## Your Core Responsibilities\n\n1. Scan conversation for significant events\n2. Categorize events into M/G/P/D/A categories\n3. Extract actionable learnings\n4. Assess rule/KG candidacy for each learning\n\n## Analysis Categories\n\nClassify each significant event:\n\n| Category | Code | Focus |\n|----------|------|-------|\n| Mistakes | M | Root cause, not symptoms |\n| Good Decisions | G | Why it worked |\n| Patterns | P | Recurring elements |\n| Debugging | D | Investigation techniques |\n| Architecture | A | Design decisions |\n\n## Analysis Process\n\n### Step 1: Event Identification\n\nScan conversation for:\n- Error messages and their resolutions\n- Multiple attempts at the same task\n- Tool failures and recoveries\n- User corrections or clarifications\n- Successful implementations\n- Refactoring or rework\n- Performance issues found/fixed\n- Security concerns addressed\n\n### Step 2: Event Classification\n\nFor each significant event:\n\n```\nEvent: [Brief description]\nCategory: [M/G/P/D/A]\nImpact: [High/Medium/Low]\nRoot Cause: [For mistakes: underlying cause]\nSuccess Factor: [For good decisions: why it worked]\n```\n\n### Step 3: Learning Extraction\n\nTransform events into structured learnings:\n\n```markdown\n## Learning: [Descriptive Title]\n\n**Category**: [M/G/P/D/A]\n**Context**: [When this applies]\n**Learning**: [What was learned - 1-2 sentences]\n**Action**: [Rule candidate | KG entry | No action]\n**Rationale**: [Why this action]\n```\n\n### Step 4: Quality Filter\n\nInclude learning if:\n- Applies to future sessions (not one-off)\n- Prevents real problems (not theoretical)\n- Can be expressed concisely (<50 words)\n- Not already covered by existing rules\n\nExclude if:\n- Too specific to this exact task\n- Already captured elsewhere\n- Low probability of recurrence\n- Would clutter the rule set\n\n## Depth Levels\n\nAdjust analysis based on depth parameter:\n\n**quick**: Major events only, 3-5 learnings max\n**deep**: All significant events, patterns included, 5-10 learnings\n**ultrathink**: Full reflection, cross-references, edge cases, 10+ learnings\n\n## Output Format\n\nReturn structured learnings:\n\n```markdown\n# Session Analysis Results\n\n## Summary\n- Session focus: [What was worked on]\n- Events analyzed: [Count]\n- Learnings extracted: [Count by category]\n\n## Learnings\n\n### [M] Mistakes\n\n#### Learning: [Title]\n**Context**: [When this applies]\n**Learning**: [What was learned]\n**Action**: Rule candidate\n**Draft**: \"[Concise rule text <50 words]\"\n\n### [G] Good Decisions\n\n#### Learning: [Title]\n**Context**: [When this applies]\n**Learning**: [What was learned]\n**Action**: KG entry\n**Type**: pattern\n\n[Continue for P, D, A categories...]\n\n## Skipped Items\n- [Event]: [Reason - too specific/already covered/low impact]\n```\n\n## Quality Standards\n\n- Each learning must have clear context\n- Rule drafts must be under 50 words\n- Use concise-rule-writing skill principles\n- Prefer updating existing rules over new ones\n- Cross-reference related learnings\n",
        "coconut-rules/commands/add-rule.md": "---\ndescription: Add or update a rule with automatic placement (critical in CLAUDE.md or context file)\nargument-hint: \"[rule description or content]\"\n---\n\n# Add Rule Command\n\n## --help Handler\n\nIf the user passes `--help` as an argument, display this help and stop:\n\n```\n/coconut-rules:add-rule - Add Rule with Smart Placement\n\nDESCRIPTION\n  Add or update a rule with intelligent placement. Critical rules\n  go in CLAUDE.md, domain-specific rules go in context files.\n\nUSAGE\n  /coconut-rules:add-rule [rule description]\n  /coconut-rules:add-rule --help\n\nARGUMENTS\n  [rule description]   The rule to add. If omitted, prompts for input.\n\nPLACEMENT LOGIC\n  Critical â†’ CLAUDE.md:\n  - Security fundamentals (secrets, auth, input sanitization)\n  - Git workflow (branching, commits)\n  - Universal conventions (80%+ of tasks)\n  - Safety-critical \"never do\" rules\n\n  Context â†’ .claude/rules/[domain].md:\n  - Language-specific (Python, TypeScript)\n  - Framework-specific (React, FastAPI)\n  - Tool-specific (Docker, Terraform)\n  - Patterns with examples\n\nEXAMPLES\n  # Security rule â†’ goes to CLAUDE.md\n  /coconut-rules:add-rule \"Never log passwords or sensitive data\"\n\n  # Python pattern â†’ goes to .claude/rules/python.md\n  /coconut-rules:add-rule \"Use Pydantic models for API validation\"\n\n  # New domain â†’ creates .claude/rules/terraform.md\n  /coconut-rules:add-rule \"Use Terraform modules for reusable infra\"\n\nCONTEXT DOMAINS\n  python.md      - Python, FastAPI, Pydantic\n  typescript.md  - TypeScript, React, Next.js\n  docker.md      - Docker, containers\n  security.md    - Detailed auth patterns\n  database.md    - SQL, migrations\n  [custom].md    - Any custom domain\n```\n\nAdd or update a rule with intelligent placement based on rule characteristics.\n\n## Placement Decision\n\n### Critical Rules â†’ CLAUDE.md\nRules that go directly in CLAUDE.md:\n- Security fundamentals (secrets, auth bypass, input sanitization)\n- Git workflow (branching, commits)\n- Universal conventions that apply to 80%+ of tasks\n- Safety-critical \"never do\" rules\n\n### Context Rules â†’ .claude/rules/[domain].md\nRules that go in context files:\n- Language-specific (Python, TypeScript, Go)\n- Framework-specific (React, FastAPI, Next.js)\n- Tool-specific (Docker, Terraform)\n- Detailed patterns with examples\n\n## Workflow\n\n1. **Analyze the rule** provided by the user\n2. **Determine placement**:\n   - Is it security/safety-critical? â†’ CLAUDE.md\n   - Does it apply universally (80%+ tasks)? â†’ CLAUDE.md\n   - Is it domain-specific? â†’ Context file\n3. **Identify context domain** (if context file):\n   - `python.md` - Python, FastAPI, Pydantic\n   - `typescript.md` - TypeScript, React, Next.js\n   - `docker.md` - Docker, containers\n   - `security.md` - Detailed auth patterns\n   - `database.md` - SQL, migrations\n   - `[custom].md` - User-specified domain\n4. **Create or update** the appropriate file in `.claude/rules/`\n5. **Update CLAUDE.md context table** if adding new context file\n\n## Instructions\n\n### Step 1: Get Rule Content\nIf provided in arguments, use that. Otherwise ask:\n- What rule would you like to add?\n- What behavior should this enforce?\n\n### Step 2: Analyze and Classify\n\nAsk yourself:\n1. Is this a \"never do\" security rule? â†’ **Critical**\n2. Does this apply regardless of file type/technology? â†’ **Critical**\n3. Is this specific to a language/framework/tool? â†’ **Context**\n4. Would this need examples to understand? â†’ **Context**\n\n### Step 3: Check Current Structure\n\n```bash\n# Check existing structure\nls -la .claude/ 2>/dev/null || echo \"No .claude directory\"\nls -la .claude/rules/ 2>/dev/null || echo \"No coconut rules directory\"\n```\n\nUse Glob to find existing context files:\n- Pattern: `.claude/rules/*.md`\n\n### Step 4a: Add Critical Rule to CLAUDE.md\n\nIf placing in CLAUDE.md:\n1. Read current CLAUDE.md\n2. Find or create `## Critical Rules` section\n3. Add rule as bullet point under appropriate subsection:\n   - `### Security` - Security rules\n   - `### Git Workflow` - Git/version control rules\n   - `### Conventions` - General coding conventions\n\nKeep it brief - no examples, just actionable statements.\n\n### Step 4b: Add Context Rule to Context File\n\nIf placing in context file:\n1. Create `.claude/rules/` if needed\n2. Create or update `.claude/rules/[domain].md`\n3. Use this structure:\n\n```markdown\n# [Domain] Context\n\nRules for [domain] development in this project.\n\n## Key Patterns\n\n- [The rule being added]\n\n## Examples\n\n### Recommended\nâ€‹```[language]\n// Good example\nâ€‹```\n\n### Avoid\nâ€‹```[language]\n// What to avoid\nâ€‹```\n```\n\n### Step 5: Update Context Table in CLAUDE.md\n\nIf adding a new context file, update the context table in CLAUDE.md:\n\n```markdown\n## Context (Read When Relevant)\n\n| Working On | Read |\n|------------|------|\n| Python/FastAPI | `.claude/rules/python.md` |\n| [New domain] | `.claude/rules/[new].md` |  â† Add this row\n```\n\n## Examples\n\n### Example 1: Security Rule (Critical)\n\nUser: `/add-rule Never log sensitive user data or passwords`\n\n**Classification**: Critical (security, universal)\n\n**Action**: Add to CLAUDE.md under `### Security`\n\n```markdown\n## Critical Rules\n\n### Security\n- Never commit secrets, API keys, or credentials\n- Never log sensitive user data or passwords  â† Added\n```\n\n### Example 2: Python Pattern (Context)\n\nUser: `/add-rule Always use Pydantic models for API request/response validation`\n\n**Classification**: Context (Python/FastAPI specific)\n\n**Action**: Add to `.claude/rules/python.md`\n\n```markdown\n# Python Context\n\n## Key Patterns\n\n- Always use Pydantic models for API request/response validation\n\n## Examples\n\n### Recommended\nâ€‹```python\nfrom pydantic import BaseModel\n\nclass UserCreate(BaseModel):\n    email: str\n    password: str\nâ€‹```\n```\n\n### Example 3: New Domain\n\nUser: `/add-rule Use Terraform modules for reusable infrastructure`\n\n**Classification**: Context (Terraform/IaC specific)\n\n**Action**:\n1. Create `.claude/rules/terraform.md`\n2. Add context table entry to CLAUDE.md\n\n## Tips\n\n- When in doubt, prefer context file over CLAUDE.md (less always-on load)\n- Group related rules in same context file in `.claude/rules/`\n- Keep CLAUDE.md critical rules under 20 lines total\n- Use clear trigger keywords in context table for discoverability\n",
        "coconut-rules/commands/list-rules.md": "---\ndescription: List current rules structure and CLAUDE.md references\n---\n\n# List Rules Command\n\n## --help Handler\n\nIf the user passes `--help` as an argument, display this help and stop:\n\n```\n/coconut-rules:list-rules - List Rules Structure\n\nDESCRIPTION\n  Display the current rules organization showing context files\n  in .claude/rules/.\n\nUSAGE\n  /coconut-rules:list-rules\n  /coconut-rules:list-rules --help\n\nOUTPUT\n  Shows:\n  - Critical rules in CLAUDE.md\n  - Context files in .claude/rules/\n  - Orphaned or missing files\n  - Recommendations for optimization\n\nEXAMPLES\n  # List all rules\n  /coconut-rules:list-rules\n\nSAMPLE OUTPUT\n\n  ## Rules Structure\n\n  ### Critical Rules (Always Loaded)\n  From CLAUDE.md:\n  - Never commit secrets âœ“\n  - Feature branches only âœ“\n\n  ### Context Files (On-Demand)\n  .claude/rules/\n  â”œâ”€â”€ python.md (Python/FastAPI)\n  â”œâ”€â”€ typescript.md (React/TypeScript)\n  â””â”€â”€ docker.md (Containers)\n\n  ## Summary\n  - Critical rules: 2 (in CLAUDE.md)\n  - Context files: 3 (loaded on-demand)\n\nINDICATORS\n  âœ“  Properly configured\n  âœ—  Issue found\n  âš ï¸  Recommendation available\n```\n\nDisplay the current rules organization.\n\n## Workflow\n\n1. **Scan directories** for all context files in `.claude/rules/`\n2. **Read CLAUDE.md** for references and critical rules\n3. **Display structured view** with recommendations\n\n## Instructions\n\n### Step 1: Check Rules Structure\n\n```bash\n# Check for coconut rules structure\nls -la .claude/rules/ 2>/dev/null && echo \"Rules structure found\"\n```\n\n### Step 2: Read CLAUDE.md\n\nLook for:\n- `## Critical Rules` section\n- `## Rules` or `## Context` table referencing `.claude/rules/`\n\n### Step 3: Display Rules Structure\n\n```\n## Rules Structure\n\n### Critical Rules (Always Loaded)\nFrom CLAUDE.md:\n- Never commit secrets âœ“\n- Feature branches only âœ“\n- Run tests before commit âœ“\n\n### Context Files (On-Demand)\n.claude/rules/\nâ”œâ”€â”€ python.md (Python/FastAPI)\nâ”œâ”€â”€ typescript.md (React/TypeScript)\nâ””â”€â”€ docker.md (Containers)\n\n### Context Table\n| Working On | Read | Status |\n|------------|------|--------|\n| Python/FastAPI | python.md | âœ“ exists |\n| TypeScript/React | typescript.md | âœ“ exists |\n| Docker | docker.md | âœ“ exists |\n\n## Summary\n- Critical rules: 3 (in CLAUDE.md)\n- Context files: 3 (loaded on-demand)\n- Loading optimization: Active\n```\n\n### Step 4: Show Recommendations\n\nBased on findings:\n\n- Missing context files referenced in table\n- Empty context files\n- Context files not in table\n\n## Output Indicators\n\n| Symbol | Meaning |\n|--------|---------|\n| âœ“ | Properly configured |\n| âœ— | Issue found |\n| âš ï¸ | Recommendation |\n\n## Tips\n\n- Run periodically to verify organization\n- Check that context table matches actual files\n",
        "coconut-rules/commands/organize.md": "---\ndescription: Restructure existing rules to context-based loading pattern for optimal performance\n---\n\n# Organize Rules Command\n\n## --help Handler\n\nIf the user passes `--help` as an argument, display this help and stop:\n\n```\n/coconut-rules:organize - Organize Rules Structure\n\nDESCRIPTION\n  Organize rules into the .claude/rules/ structure\n  for context-based loading (load only when relevant).\n\nUSAGE\n  /coconut-rules:organize\n  /coconut-rules:organize --help\n\nSTRUCTURE\n\n  .claude/\n  â”œâ”€â”€ CLAUDE.md          # Critical rules inline + context table\n  â””â”€â”€ rules/\n      â”œâ”€â”€ typescript.md  # Frontend rules\n      â”œâ”€â”€ python.md      # Backend rules\n      â””â”€â”€ docker.md      # DevOps rules\n\nPROCESS\n  1. Analyze current rules in project\n  2. Classify rules as Critical or Context\n  3. Extract critical rules to CLAUDE.md\n  4. Consolidate context rules by domain in .claude/rules/\n  5. Create context table in CLAUDE.md\n\nEXAMPLES\n  # Run organization\n  /coconut-rules:organize\n\nBENEFITS\n  - Faster context loading (only relevant rules)\n  - Cleaner CLAUDE.md (critical rules only)\n  - Better organization (domain-based)\n  - Reduced token usage per interaction\n```\n\nOrganize rules into the `.claude/rules/` structure for context-based loading.\n\n## Overview\n\nTarget structure:\n\n```\n.claude/\nâ”œâ”€â”€ CLAUDE.md                  # Critical rules inline + context table\nâ””â”€â”€ rules/\n    â”œâ”€â”€ typescript.md          # Frontend rules\n    â”œâ”€â”€ python.md              # Backend rules\n    â””â”€â”€ docker.md              # DevOps rules\n```\n\n## Workflow\n\n### Step 1: Analyze Current Rules\n\nCheck for any existing rules in the project:\n\n```bash\n# Check for coconut rules structure\nls -la .claude/rules/ 2>/dev/null\n```\n\nRead CLAUDE.md to find existing rules or references.\n\n### Step 2: Categorize Rules\n\nFor each rule found, classify as:\n\n**Critical** (keep in CLAUDE.md):\n- Security fundamentals\n- Git workflow basics\n- Universal conventions\n- \"Never do\" rules\n\n**Context** (move to .claude/rules/):\n- Language-specific patterns\n- Framework conventions\n- Tool configurations\n- Detailed examples\n\n### Step 3: Extract Critical Rules\n\nExtract one-liner critical rules for CLAUDE.md:\n\n```markdown\n## Critical Rules\n\n### Security\n- Never commit secrets, API keys, or credentials\n- Sanitize all user input before database operations\n\n### Git\n- Feature branches only, never commit to main\n- Run tests before committing\n```\n\n### Step 4: Create Context Files\n\nCreate domain-based context files in `.claude/rules/`:\n\n| Domain | File | Content |\n|--------|------|---------|\n| Frontend | `typescript.md` | React, Next.js, TypeScript patterns |\n| Backend | `python.md` | Python, FastAPI patterns |\n| DevOps | `docker.md` | Container, CI/CD patterns |\n| Security | `security.md` | Auth, authorization patterns |\n\n### Step 5: Create Context Table\n\nAdd to CLAUDE.md:\n\n```markdown\n## Rules\n\nContext rules are loaded on-demand from `.claude/rules/`:\n\n| Context | Rule File |\n|---------|-----------|\n| Python/FastAPI backend | `.claude/rules/python.md` |\n| React/TypeScript frontend | `.claude/rules/typescript.md` |\n| Docker/containers | `.claude/rules/docker.md` |\n```\n\n### Step 6: Verify Structure\n\n```bash\n# Show new structure\ntree .claude/rules/ 2>/dev/null || find .claude/rules -type f\n```\n\n## Organization Report Template\n\nAfter completing organization, report:\n\n```markdown\n## Organization Complete\n\n### Critical Rules Added to CLAUDE.md\n- [List of critical rules]\n\n### Context Files Created\n| File | Content |\n|------|---------|\n| `rules/python.md` | Python/FastAPI patterns |\n| `rules/typescript.md` | React/TypeScript patterns |\n\n### Next Steps\n- Test the new structure\n- Add more context files as needed\n```\n\n## Example Context File\n\n**rules/python.md**:\n```markdown\n# Python Context\n\n## FastAPI Patterns\n\n- Use Pydantic models for request/response validation\n- Implement dependency injection for services\n- Use async/await for I/O operations\n\n## Examples\n\n### Service Pattern\n```python\nfrom fastapi import Depends\n\nclass UserService:\n    def __init__(self, repo: UserRepository = Depends()):\n        self.repo = repo\n```\n```\n\n## Tips\n\n- Consolidate aggressively - fewer context files = easier to manage\n- Test by asking Claude about a topic and verifying it reads the right context\n- Keep CLAUDE.md under 50 lines including critical rules\n",
        "coconut-rules/commands/retrospective.md": "---\ndescription: Analyze session to extract learnings and update rules/knowledge graph\nargument-hint: [--depth quick|deep|ultrathink] [--dry-run]\nallowed-tools: Read, Write, Edit, Glob, Grep, Bash, Task, TodoWrite, AskUserQuestion\n---\n\n# Retrospective Command\n\n## --help Handler\n\nIf the user passes `--help` as an argument, display this help and stop:\n\n```\n/coconut-rules:retrospective - Session Retrospective Analysis\n\nDESCRIPTION\n  Analyze the current session to extract learnings, mistakes, patterns,\n  and decisions. Proposes updates to rules and knowledge graph.\n\nUSAGE\n  /coconut-rules:retrospective [--depth LEVEL] [--dry-run]\n  /coconut-rules:retrospective --help\n\nOPTIONS\n  --depth LEVEL    Analysis depth: quick, deep, ultrathink (default: ultrathink)\n  --dry-run        Show proposed changes without applying them\n\nANALYSIS CATEGORIES\n  M - Mistakes: Errors and their root causes\n  G - Good Decisions: What worked and why\n  P - Patterns: Recurring code/workflow patterns\n  D - Debugging: Investigation techniques that worked\n  A - Architecture: Design decisions and rationale\n\nOUTPUT\n  Grouped by action type:\n  - Rules to add (with placement: CLAUDE.md or .claude/rules/)\n  - Rules to update\n  - Knowledge graph entries to add\n  - Items skipped (with reason)\n\nEXAMPLES\n  # Full retrospective with ultrathink\n  /coconut-rules:retrospective\n\n  # Quick analysis\n  /coconut-rules:retrospective --depth quick\n\n  # Preview changes without applying\n  /coconut-rules:retrospective --dry-run\n```\n\nRun a retrospective analysis on the current session to extract learnings and update rules/knowledge graph.\n\n## Parse Arguments\n\nExtract options from $ARGUMENTS:\n- `--depth quick|deep|ultrathink` (default: ultrathink)\n- `--dry-run` flag (default: false)\n\n## Workflow\n\nExecute the retrospective in phases:\n\n### Phase 1: Initialize\n\n1. Create todo list for tracking progress\n2. Ensure `.claude/retrospectives/` directory exists:\n   ```bash\n   mkdir -p .claude/retrospectives\n   ```\n3. Generate retrospective filename: `YYYY-MM-DD-HHmm.md`\n\n### Phase 2: Parallel Analysis\n\nLaunch three agents in parallel using Task tool:\n\n```\n[session-analyzer] - Analyze conversation for learnings\n[rule-reviewer] - Review current rules against learnings\n[knowledge-updater] - Propose knowledge graph updates\n```\n\nAll agents receive the same depth setting.\n\n### Phase 3: Collect Results\n\nWait for all agents to complete. Collect outputs:\n- Learnings extracted (from session-analyzer)\n- Rule changes proposed (from rule-reviewer)\n- KG entries proposed (from knowledge-updater)\n\n### Phase 4: Present Batch\n\nFormat results for user review:\n\n```markdown\n## Retrospective Results\n\n### Session Summary\n- Events analyzed: [count]\n- Learnings extracted: [count by category M/G/P/D/A]\n\n### Rules to Add\n| Rule | Placement | Rationale |\n|------|-----------|-----------|\n| [text <50 words] | [CLAUDE.md/.claude/rules/X.md] | [why] |\n\n### Rules to Update\n| Current | Proposed | File |\n|---------|----------|------|\n| [old text] | [new text] | [path] |\n\n### Knowledge Graph Entries\n| Type | Content | Tags |\n|------|---------|------|\n| [decision/pattern/convention] | [text] | [relevant tags] |\n\n### Skipped Items\n- [Item]: [Reason - too specific/already covered/low impact]\n```\n\n### Phase 5: User Confirmation\n\nUse AskUserQuestion to get user confirmation:\n\n```\nReview the proposed changes above.\n\nOptions:\n1. Apply all changes\n2. Apply rules only\n3. Apply KG entries only\n4. Review individually\n5. Cancel\n```\n\n### Phase 6: Apply Changes\n\nIf user confirms (and not --dry-run):\n\n**For rules:**\n- Use `/coconut-rules:add-rule` or Edit tool\n- Follow concise-rule-writing skill for formatting\n- Place critical rules in CLAUDE.md, domain rules in .claude/rules/\n\n**For knowledge graph:**\n- Use `/coconut-knowledge-graph:add` command\n- Include type and tags\n\n### Phase 7: Save History\n\nSave retrospective summary to `.claude/retrospectives/YYYY-MM-DD-HHmm.md`:\n\n```markdown\n# Retrospective: [Date Time]\n\n## Session Focus\n[Brief description of what was worked on]\n\n## Learnings by Category\n### Mistakes (M)\n- [learning]\n\n### Good Decisions (G)\n- [learning]\n\n### Patterns (P)\n- [learning]\n\n### Debugging (D)\n- [learning]\n\n### Architecture (A)\n- [learning]\n\n## Changes Applied\n### Rules\n- Added: [list]\n- Updated: [list]\n\n### Knowledge Graph\n- Added: [list]\n\n## Notes\n[Any additional context]\n```\n\nAlso sync to knowledge graph if available:\n```bash\n/coconut-knowledge-graph:add \"retrospective-YYYY-MM-DD\" --type decision --content \"[summary]\"\n```\n\n## Agent Descriptions\n\nFor Task tool invocations:\n\n**session-analyzer**: \"Analyze this conversation session to extract learnings. Categories: Mistakes (root cause), Good Decisions (why worked), Patterns (recurring), Debugging (techniques), Architecture (decisions). Use [depth] analysis level. Output structured learnings.\"\n\n**rule-reviewer**: \"Review .claude/rules/ and CLAUDE.md against the session learnings. Identify: rules to add (with placement), rules to update, rules to remove. Use concise-rule-writing skill. Each rule <50 words.\"\n\n**knowledge-updater**: \"Propose knowledge graph updates based on session learnings. Use /coconut-knowledge-graph:search to check existing entries. Avoid duplicates. Output: entries to add with type (decision/pattern/convention) and tags.\"\n\n## Tips\n\n- Run retrospective at natural session breakpoints\n- Use `--depth quick` for short sessions with obvious learnings\n- Use `--dry-run` to preview before applying\n- Review skipped items - they may become relevant later\n- Retrospectives are most valuable after debugging sessions\n",
        "coconut-rules/skills/concise-rule-writing/SKILL.md": "---\nname: Concise Rule Writing\ndescription: \"This skill should be used when the user asks to 'write a rule', 'create a rule', 'make rule shorter', 'keep rules minimal', 'reduce rule size', 'optimize rule', or needs guidance on writing precise, context-efficient rules for CLAUDE.md.\"\nversion: 1.0.0\n---\n\n# Concise Rule Writing\n\nGuide for writing precise, short rules that minimize context usage while maximizing clarity and enforceability.\n\n## Core Principle\n\n**Every token counts.** Rules load into context on every interaction. Verbose rules waste tokens and reduce available context for actual work.\n\n### Target Metrics\n\n| Metric | Target | Maximum |\n|--------|--------|---------|\n| Words per rule | <30 | 50 |\n| Characters per rule | <200 | 350 |\n| Lines per rule | 1-2 | 3 |\n| Total CLAUDE.md | <500 words | 1000 words |\n\n## Rule Anatomy\n\nA good rule has three components in minimal space:\n\n```\n[CONSTRAINT] [ACTION] [CONTEXT (optional)]\n```\n\n**Examples:**\n```\nNever commit .env files                     # 4 words\nUse snake_case for Python variables         # 5 words\nRun tests before commit                     # 4 words\n```\n\n## Writing Techniques\n\n### 1. Remove Filler Words\n\n**Remove:** actually, basically, essentially, really, very, definitely, certainly, obviously, simply, just\n\n| Before | After |\n|--------|-------|\n| \"You should always make sure to run tests\" | \"Run tests before commit\" |\n| \"It's really important to never commit secrets\" | \"Never commit secrets\" |\n| \"Basically, all API endpoints should have auth\" | \"All endpoints require auth\" |\n\n### 2. Use Imperative Form\n\nStart with verb. No \"you should\", \"make sure to\", \"always remember to\".\n\n| Before | After |\n|--------|-------|\n| \"You should use TypeScript for type safety\" | \"Use TypeScript\" |\n| \"Make sure to validate user input\" | \"Validate all input\" |\n| \"Always remember to add error handling\" | \"Add error handling\" |\n\n### 3. Eliminate Redundancy\n\n| Before | After |\n|--------|-------|\n| \"Never ever commit any secrets or API keys\" | \"Never commit secrets\" |\n| \"Use consistent naming conventions throughout\" | \"Consistent naming\" |\n| \"All functions should have proper error handling\" | \"Handle errors in functions\" |\n\n### 4. Use Standard Terms\n\nReplace verbose descriptions with known terms:\n\n| Verbose | Concise |\n|---------|---------|\n| \"Make sure passwords are scrambled\" | \"Hash passwords\" |\n| \"Check that data is correct before saving\" | \"Validate before persist\" |\n| \"Write code that can be tested\" | \"Write testable code\" |\n| \"Don't repeat the same code\" | \"DRY code\" |\n\n### 5. Scope Implicitly\n\nDon't over-specify when context makes it clear:\n\n| Before | After |\n|--------|-------|\n| \"In this Python project, use snake_case\" | \"Use snake_case\" |\n| \"When writing React components, use hooks\" | \"Use React hooks\" |\n| \"For all database queries, use parameterized queries\" | \"Parameterized queries only\" |\n\n## Rule Patterns\n\n### Security Rules\n\n```markdown\nNever commit secrets\nNever log passwords\nSanitize all user input\nParameterized queries only\nValidate auth on all endpoints\n```\n\n### Code Style Rules\n\n```markdown\nsnake_case for Python\ncamelCase for TypeScript\nMax 100 chars per line\nOne class per file\n```\n\n### Git Rules\n\n```markdown\nFeature branches only\nRun tests before commit\nConventional commit messages\nNo force push to main\n```\n\n### Architecture Rules\n\n```markdown\nServices in /services\nComponents in /components\nNo business logic in controllers\nDependency injection for testing\n```\n\n## Placement Decision\n\n| Rule Type | Location | Example |\n|-----------|----------|---------|\n| Security-critical | CLAUDE.md | \"Never commit secrets\" |\n| Universal (80%+ tasks) | CLAUDE.md | \"Run tests before commit\" |\n| Language-specific | .claude/rules/[lang].md | \"Use Pydantic for validation\" |\n| Framework-specific | .claude/rules/[framework].md | \"Use React Query for API calls\" |\n| With examples needed | .claude/rules/[domain].md | Complex patterns |\n\n## Optimization Process\n\n### Step 1: Draft\n\nWrite the rule naturally:\n```\n\"When working with the database, you should always make sure to use\nparameterized queries to prevent SQL injection attacks\"\n```\n\n### Step 2: Extract Core\n\nIdentify the essential constraint:\n```\nUse parameterized queries\n```\n\n### Step 3: Add Minimal Context\n\nOnly if ambiguity exists:\n```\nParameterized queries for all DB access\n```\n\n### Step 4: Verify\n\n- Is it clear? âœ“\n- Is it actionable? âœ“\n- Is it <50 words? âœ“ (6 words)\n- Could it be shorter without losing meaning? No\n\n### Step 5: Final\n\n```\nParameterized queries for all DB access\n```\n\n## Anti-Patterns\n\n### Avoid: Explanatory Rules\n\n```markdown\n# Bad - includes explanation\nNever commit .env files because they contain sensitive information\nthat could be exposed if the repository is public\n\n# Good - just the rule\nNever commit .env files\n```\n\n### Avoid: Conditional Chains\n\n```markdown\n# Bad - too many conditions\nIf working on frontend, use React, and if using React, use hooks,\nand if using hooks, prefer useCallback for functions\n\n# Good - separate rules\nUse React hooks\nPrefer useCallback for callback functions\n```\n\n### Avoid: Vague Rules\n\n```markdown\n# Bad - not actionable\nWrite good code\nBe careful with security\nThink about performance\n\n# Good - specific and actionable\nMax cyclomatic complexity: 10\nSanitize all user input\nIndex foreign keys\n```\n\n### Avoid: Duplicate Intent\n\n```markdown\n# Bad - same intent, different words\nNever expose secrets\nDon't commit API keys\nKeep credentials out of code\n\n# Good - one comprehensive rule\nNever commit secrets (keys, tokens, passwords)\n```\n\n## Context File Rules\n\nRules in `.claude/rules/*.md` can be slightly longer since they load on-demand. Still aim for brevity:\n\n```markdown\n# .claude/rules/python.md\n\n## Patterns\n\n- Pydantic for API validation\n- AsyncIO for I/O operations\n- Type hints on public functions\n- Pytest for testing\n\n## Avoid\n\n- Global mutable state\n- Bare except clauses\n- String concatenation for SQL\n```\n\n## Measuring Success\n\n### Before Optimization\n\n```markdown\n# CLAUDE.md - 847 words\n\nYou should always make sure that whenever you're working with this\nproject, you remember to never commit any files that contain secrets,\nAPI keys, passwords, or any other sensitive information...\n\n[continues for pages]\n```\n\n### After Optimization\n\n```markdown\n# CLAUDE.md - 127 words\n\n## Security\n- Never commit secrets\n- Sanitize user input\n- Hash passwords\n\n## Git\n- Feature branches only\n- Run tests before commit\n\n## Code\n- snake_case (Python)\n- camelCase (TypeScript)\n- Max 100 chars/line\n\n## Context\n| Task | Read |\n|------|------|\n| Python | .claude/rules/python.md |\n| React | .claude/rules/react.md |\n```\n\n**Result:** 85% token reduction, same coverage.\n\n## Quick Reference\n\n### Rule Checklist\n\n- [ ] <50 words\n- [ ] Starts with verb (imperative)\n- [ ] No filler words\n- [ ] Specific and actionable\n- [ ] Not duplicating existing rule\n- [ ] Correct placement (critical vs context)\n\n### Word Budget Guide\n\n| Component | Words |\n|-----------|-------|\n| Single rule | 3-10 |\n| Rule with qualifier | 10-20 |\n| Rule with example | 20-40 |\n| Maximum | 50 |\n",
        "coconut-rules/skills/retrospective-process/SKILL.md": "---\nname: Retrospective Process\ndescription: \"This skill should be used when the user asks to 'run a retrospective', 'review this session', 'extract learnings', 'what did we learn', 'analyze our conversation', 'session review', or wants to reflect on work done during the conversation.\"\nversion: 1.0.0\n---\n\n# Retrospective Process\n\nGuide for analyzing development sessions to extract learnings, identify patterns, and improve future work through structured reflection.\n\n## Purpose\n\nRetrospectives transform implicit session knowledge into explicit, reusable rules and knowledge entries. Extract value from:\n\n- Mistakes made and their root causes\n- Good decisions and why they worked\n- Patterns discovered during implementation\n- Debugging insights worth preserving\n- Architectural decisions and rationale\n\n## Analysis Framework\n\n### Depth Levels\n\n| Depth | Analysis Scope | Time | Use Case |\n|-------|---------------|------|----------|\n| `quick` | Major events only | ~2 min | Short sessions, obvious learnings |\n| `deep` | Patterns + context | ~5 min | Standard sessions |\n| `ultrathink` | Full reflection | ~10 min | Complex sessions, debugging-heavy |\n\n### Analysis Categories\n\nAnalyze session events across five categories:\n\n**1. Mistakes (M)**\n- What went wrong?\n- Root cause (not just symptom)\n- Prevention strategy\n- Rule candidate: YES/NO\n\n**2. Good Decisions (G)**\n- What worked well?\n- Why it succeeded\n- Pattern to replicate\n- KG entry candidate: YES/NO\n\n**3. Patterns (P)**\n- Recurring code patterns\n- Workflow patterns\n- Tool usage patterns\n- Worth codifying: YES/NO\n\n**4. Debugging Insights (D)**\n- Error resolution strategies\n- Investigation techniques\n- Tool combinations that worked\n- Worth documenting: YES/NO\n\n**5. Architectural Decisions (A)**\n- Design choices made\n- Trade-offs considered\n- Rationale\n- Add to decision log: YES/NO\n\n## Session Analysis Process\n\n### Step 1: Scan Session\n\nScan conversation for significant events:\n\n```\nIdentify:\n- Error messages and their resolutions\n- Multiple attempts at same task\n- Tool failures and recoveries\n- User corrections or clarifications\n- Successful implementations\n- Refactoring or rework\n```\n\n### Step 2: Categorize Events\n\nFor each significant event, assign category (M/G/P/D/A) and assess:\n\n```\nEvent: [Brief description]\nCategory: [M/G/P/D/A]\nImpact: [High/Medium/Low]\nActionable: [Yes/No]\n```\n\n### Step 3: Extract Learnings\n\nTransform events into structured learnings:\n\n```markdown\n## Learning: [Title]\n\n**Category**: [M/G/P/D/A]\n**Context**: [When this applies]\n**Learning**: [What was learned]\n**Action**: [Rule to add | KG entry | No action]\n```\n\n### Step 4: Generate Outputs\n\nFor each actionable learning:\n\n**If Rule candidate:**\n- Use concise-rule-writing skill for formatting\n- Determine placement (CLAUDE.md vs .claude/rules/)\n- Draft rule text (<50 words)\n\n**If KG entry candidate:**\n- Determine entry type (decision, pattern, convention)\n- Draft entry content\n- Identify related entries\n\n## Output Format\n\nPresent findings grouped by action type:\n\n```markdown\n## Retrospective Results\n\n### Session Summary\n- Duration: [X messages/events analyzed]\n- Key events: [Count by category]\n\n### Rules to Add\n| Rule | Placement | Rationale |\n|------|-----------|-----------|\n| [rule text] | [CLAUDE.md/.claude/rules/X.md] | [why] |\n\n### Rules to Update\n| Current | Proposed | File |\n|---------|----------|------|\n| [old] | [new] | [path] |\n\n### Knowledge Graph Entries\n| Type | Content | Tags |\n|------|---------|------|\n| [decision/pattern/convention] | [text] | [tags] |\n\n### Skipped Items\n- [Item] - [Reason: too specific/already covered/low impact]\n```\n\n## Quality Criteria\n\nEvaluate each proposed change:\n\n**Include if:**\n- Applies to future sessions (not one-off)\n- Prevents real problems (not theoretical)\n- Can be stated in <50 words (concise)\n- Not already covered by existing rules\n\n**Exclude if:**\n- Too specific to this task\n- Already captured elsewhere\n- Low probability of recurrence\n- Would clutter rule set\n\n## Integration Points\n\n### With Knowledge Graph\n\nStore retrospective results in KG:\n\n```bash\n# Add decision\n/coconut-knowledge-graph:add \"decision-name\" --type decision --content \"[text]\"\n\n# Add pattern\n/coconut-knowledge-graph:add \"pattern-name\" --type convention --content \"[text]\"\n```\n\n### With Rules System\n\nCreate rules via:\n\n```bash\n# Add to rules\n/coconut-rules:add-rule \"[rule text]\"\n```\n\n### History Tracking\n\nSave retrospective summary to `.claude/retrospectives/YYYY-MM-DD.md`:\n\n```markdown\n# Retrospective: [Date]\n\n## Session Focus\n[What was worked on]\n\n## Key Learnings\n[Bullet points]\n\n## Changes Made\n- Rules: [list]\n- KG entries: [list]\n\n## Notes\n[Additional context]\n```\n\n## Common Patterns\n\n### Mistake â†’ Rule Pipeline\n\n```\nMistake detected\nâ†“\nIdentify root cause (not symptom)\nâ†“\nDetermine if preventable by rule\nâ†“\nDraft rule (<50 words)\nâ†“\nPlace: Security/critical â†’ CLAUDE.md\n       Domain-specific â†’ .claude/rules/[domain].md\n```\n\n### Decision â†’ KG Pipeline\n\n```\nDecision made during session\nâ†“\nDocument alternatives considered\nâ†“\nRecord rationale\nâ†“\nTag with relevant contexts\nâ†“\nAdd to knowledge graph\n```\n\n## Commands Reference\n\n| Command | Purpose |\n|---------|---------|\n| `/coconut-rules:retrospective` | Run full retrospective analysis |\n| `/coconut-rules:retrospective --depth quick` | Quick analysis |\n| `/coconut-rules:add-rule` | Add individual rule |\n| `/coconut-knowledge-graph:add` | Add KG entry |\n\n## Best Practices\n\n- Run retrospective at natural breakpoints, not mid-task\n- Focus on actionable learnings, skip theoretical improvements\n- Prefer updating existing rules over creating new ones\n- Keep rules concise - use concise-rule-writing skill\n- Cross-reference related rules and KG entries\n- Delete retrospective history older than 30 days unless significant\n",
        "coconut-rules/skills/rules-management/SKILL.md": "---\ndescription: \"This skill provides guidance on organizing CLAUDE.md rules, category structures, and rule file best practices. Use when the user asks about 'how to organize Claude rules', 'CLAUDE.md structure', 'rule categories', 'rules best practices', or needs help understanding the rules system.\"\n---\n\n# Rules Management Skill\n\nComprehensive guidance for managing CLAUDE.md user-specific rules with **context-based loading** for optimal performance.\n\n## Core Principle: Load What's Relevant\n\nClaude Code loads CLAUDE.md on every interaction. To avoid loading all rules upfront:\n\n1. **Critical rules** â†’ Keep directly in CLAUDE.md (always loaded)\n2. **Context-specific rules** â†’ Move to `.claude/rules/` with trigger hints (loaded on-demand)\n\n## Directory Structure\n\n```\n.claude/\nâ”œâ”€â”€ CLAUDE.md                    # Critical rules + context hints\nâ””â”€â”€ rules/                       # Domain-specific rules (loaded when relevant)\n    â”œâ”€â”€ python.md\n    â”œâ”€â”€ typescript.md\n    â”œâ”€â”€ docker.md\n    â”œâ”€â”€ react.md\n    â””â”€â”€ security-advanced.md\n```\n\n## CLAUDE.md Structure (Always Loaded)\n\n```markdown\n# Project Name\n\nBrief project description.\n\n## Critical Rules (Always Apply)\n\n### Security\n- Never commit secrets, API keys, or credentials\n- Never disable security middleware or authentication checks\n- Sanitize all user input before database operations\n\n### Git Workflow\n- Feature branches only, never commit directly to main\n- Always run tests before committing\n\n## Context (Read When Relevant)\n\nLoad context files based on what you're working on:\n\n| Working On | Read |\n|------------|------|\n| Python/FastAPI backend | `.claude/rules/python.md` |\n| React/TypeScript frontend | `.claude/rules/typescript.md` |\n| Docker/containers | `.claude/rules/docker.md` |\n| Authentication/security | `.claude/rules/security.md` |\n```\n\n## What Goes Where?\n\n### Critical Rules (in CLAUDE.md)\n\nKeep rules that are **always relevant** regardless of task:\n\n- Security fundamentals (secrets, auth, input sanitization)\n- Git workflow (branching, commits)\n- Core project conventions (naming, structure)\n- Communication preferences\n\n**Characteristics:**\n- Short and actionable\n- Apply to 80%+ of tasks\n- Safety-critical\n- Never need context to understand\n\n### Context Files (in .claude/rules/)\n\nMove rules that are **domain-specific**:\n\n- Language-specific patterns (Python, TypeScript, Go)\n- Framework conventions (React, FastAPI, Next.js)\n- Tool configurations (Docker, Terraform, CI/CD)\n- Detailed security practices\n\n**Characteristics:**\n- Only relevant for specific file types/tasks\n- May be lengthy with examples\n- Require specialized knowledge\n- Not needed for every interaction\n\n## Context File Template\n\n```markdown\n# [Technology/Domain] Context\n\nRules for [technology] development in this project.\n\n## Key Patterns\n\n- [Specific pattern or convention]\n- [Another pattern]\n\n## Examples\n\n### Recommended\nâ€‹```python\n# Good example with explanation\nâ€‹```\n\n### Avoid\nâ€‹```python\n# Bad example with explanation why\nâ€‹```\n\n## Integration Points\n\n- Related to: `.claude/context/[related].md` (when working with both)\n```\n\n## Trigger Hints\n\nThe CLAUDE.md table tells Claude when to load context files from `.claude/rules/`:\n\n| Trigger Keywords | Context File |\n|-----------------|--------------|\n| `.py`, Python, FastAPI, Pydantic | `python.md` |\n| `.ts`, `.tsx`, React, Next.js | `typescript.md` |\n| Docker, container, Dockerfile | `docker.md` |\n| auth, JWT, OAuth, security audit | `security.md` |\n| `.go`, Go, Gin, Echo | `golang.md` |\n| database, SQL, migrations | `database.md` |\n\n## Migration Guide\n\n### Before (All Loaded)\n```markdown\n# CLAUDE.md\n\n@rules/frontend/react.md\n@rules/frontend/typescript.md\n@rules/backend/python.md\n@rules/backend/fastapi.md\n@rules/devops/docker.md\n@rules/security/auth.md\n@rules/general/standards.md\n```\n*Problem: All 7 files loaded on every interaction*\n\n### After (Verrueckt Rules)\n```markdown\n# CLAUDE.md\n\n## Critical Rules\n- Never commit secrets\n- Feature branches only\n- Run tests before commit\n\n## Context (Read When Relevant)\n| Working On | Read |\n|------------|------|\n| Python backend | `.claude/rules/python.md` |\n| TypeScript/React | `.claude/rules/typescript.md` |\n| Containers | `.claude/rules/docker.md` |\n```\n*Improvement: Only load what's needed per task*\n\n## Rule Priority\n\n1. **CLAUDE.md critical rules** â†’ Always apply\n2. **Loaded context files** â†’ Apply when read\n3. **Default best practices** â†’ Fall back when no rule exists\n\n## Best Practices\n\n### For Critical Rules\n- Keep under 20 lines total\n- Use bullet points, not paragraphs\n- Focus on \"never do\" and \"always do\"\n- No examples needed (rules should be self-evident)\n\n### For Context Files\n- One technology/domain per file\n- Include examples for complex patterns\n- Reference related context files\n- Keep under 200 lines per file\n\n### For Trigger Hints\n- Use file extensions as triggers (`.py`, `.tsx`)\n- Use technology keywords (Python, React)\n- Use task keywords (auth, deploy, test)\n- Be specific enough to avoid false matches\n\n## Commands Reference\n\n| Command | Purpose |\n|---------|---------|\n| `/coconut-rules:add-rule [desc]` | Add rule with auto-placement (critical vs context) |\n| `/coconut-rules:list-rules` | Show current structure and loading pattern |\n| `/coconut-rules:organize` | Restructure rules to context-based pattern |\n",
        "coconut-workflow/.claude-plugin/plugin.json": "{\n  \"name\": \"coconut-workflow\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Interactive workflow creation assistant that helps teams create Claude Code slash commands through conversational requirements gathering\",\n  \"author\": {\n    \"name\": \"Francis Varga\",\n    \"email\": \"francis@phili-tech.org\"\n  },\n  \"repository\": \"https://github.com/FrancisVarga/my-claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"workflow\", \"commands\", \"automation\", \"team-standards\"]\n}\n",
        "coconut-workflow/README.md": "# coconut-workflow\n\nInteractive workflow creation assistant that helps teams create Claude Code slash commands through conversational requirements gathering.\n\n## Features\n\n- **Conversational Creation**: Natural dialogue to understand workflow requirements\n- **Smart Routing**: Automatically determines if request needs a simple workflow (slash command) or full plugin\n- **Auto-Validation**: Validates created workflows against best practices\n- **Team Standards**: Ensures consistent workflow quality across the team\n\n## Usage\n\n```bash\n# Start interactive workflow creation\n/coconut-workflow:create\n\n# Start with initial description\n/coconut-workflow:create \"git commit workflow with conventional commits\"\n```\n\n## How It Works\n\n1. **Requirements Gathering**: Claude asks questions to understand what you need\n2. **Scope Decision**: Determines if this is a workflow (slash command) or needs a full plugin\n3. **Creation**: Generates the workflow file in `.claude/commands/`\n4. **Validation**: Automatically validates the created workflow\n5. **Explanation**: Explains how to use the new workflow\n\n## Components\n\n- **Command**: `/coconut-workflow:create` - Main entry point\n- **Skill**: `workflow-creation` - Decision criteria and best practices\n- **Agent**: `workflow-validator` - Validates created workflows\n\n## Workflow vs Plugin Decision\n\n| Choose **Workflow** when: | Choose **Plugin** when: |\n|---------------------------|------------------------|\n| Single-purpose task | Multiple related commands |\n| No persistent state | Needs hooks, agents, or skills |\n| One-shot execution | External service integration |\n| Project-specific | Reusable across projects |\n\n## Installation\n\nThis plugin is part of the `my-claude-code-plugins` collection. Ensure the plugin directory is loaded in Claude Code.\n",
        "coconut-workflow/agents/workflow-validator.md": "---\nname: workflow-validator\ndescription: Use this agent to validate Claude Code workflows (slash commands) for quality and best practices. This agent should be triggered automatically after workflow creation, or when the user asks to \"validate my workflow\", \"check workflow quality\", \"review my command\", or \"verify slash command\". Examples:\n\n<example>\nContext: A workflow file was just created by the create command\nuser: \"[implicit - workflow was just created]\"\nassistant: \"I'll use the workflow-validator agent to ensure the workflow follows best practices.\"\n<commentary>\nAfter creating a workflow, automatically validate it to ensure quality standards are met.\n</commentary>\n</example>\n\n<example>\nContext: User wants to verify an existing workflow\nuser: \"Can you check if my review-pr command follows best practices?\"\nassistant: \"I'll use the workflow-validator agent to analyze your review-pr workflow and provide feedback.\"\n<commentary>\nUser explicitly asks to validate an existing workflow command.\n</commentary>\n</example>\n\n<example>\nContext: User created a workflow manually and wants verification\nuser: \"I just created a new slash command, can you make sure it's correct?\"\nassistant: \"I'll validate your new workflow with the workflow-validator agent to check structure, instructions, and best practices.\"\n<commentary>\nUser wants quality assurance on a manually created workflow.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: yellow\ntools: [\"Read\", \"Grep\", \"Glob\"]\n---\n\nYou are a workflow validation specialist that ensures Claude Code slash commands meet quality standards and best practices.\n\n**Your Core Responsibilities:**\n1. Validate workflow file structure and frontmatter\n2. Check instructions are written FOR Claude (not TO users)\n3. Verify naming conventions and organization\n4. Assess tool restrictions for security\n5. Provide detailed fix recommendations\n\n**Validation Process:**\n\n### Step 1: Locate the Workflow\n\nIf a specific workflow was mentioned, read that file.\nIf validating a just-created workflow, check the most recent `.claude/commands/*.md` file.\nIf unclear, search `.claude/commands/` for workflow files.\n\n### Step 2: Structure Validation\n\nCheck the workflow file for:\n\n**Required Elements:**\n- [ ] File has `.md` extension\n- [ ] File is in `.claude/commands/` directory\n- [ ] Contains valid YAML frontmatter (if any)\n\n**Frontmatter Fields:**\n- [ ] `description` is present and under 60 characters\n- [ ] `argument-hint` matches argument usage in body\n- [ ] `allowed-tools` uses principle of least privilege\n\n**Report issues as:**\n```\nâŒ STRUCTURE ISSUE: [problem]\n   Location: [file:line or field]\n   Fix: [specific fix instruction]\n```\n\n### Step 3: Content Quality Validation\n\n**Instructions Format:**\n- [ ] Written FOR Claude (imperative form)\n- [ ] NOT written TO user (\"This command will...\" is wrong)\n- [ ] Clear, actionable steps\n- [ ] No vague instructions\n\n**Check for anti-patterns:**\n```\n# BAD - user-facing message\n\"This command will help you review code.\"\n\n# GOOD - instruction for Claude\n\"Review the code for quality issues.\"\n```\n\n**Report issues as:**\n```\nâŒ CONTENT ISSUE: Instructions written for user, not Claude\n   Location: Line 15-17\n   Current: \"This command will review your PR...\"\n   Fix: Change to imperative form: \"Review the PR for...\"\n```\n\n### Step 4: Naming and Organization\n\n**File Naming:**\n- [ ] Uses kebab-case (lowercase, hyphens)\n- [ ] Follows verb-noun pattern when possible\n- [ ] Descriptive and clear\n\n**Organization:**\n- [ ] Appropriate directory (flat vs. namespaced)\n- [ ] No duplicate command names\n\n**Report issues as:**\n```\nâŒ NAMING ISSUE: File name uses underscores\n   Current: review_pr.md\n   Fix: Rename to review-pr.md\n```\n\n### Step 5: Security Assessment\n\n**Tool Restrictions:**\n- [ ] Only necessary tools are allowed\n- [ ] Bash commands are scoped (e.g., `Bash(git:*)` not `Bash(*)`)\n- [ ] No unnecessary write/edit access for read-only workflows\n\n**Report issues as:**\n```\nâš ï¸ SECURITY WARNING: Overly permissive tool access\n   Current: allowed-tools: \"*\"\n   Fix: Restrict to needed tools: Read, Grep, Bash(git:*)\n```\n\n### Step 6: Generate Validation Report\n\nProvide a comprehensive report:\n\n```markdown\n# Workflow Validation Report\n\n**File:** `.claude/commands/[name].md`\n**Status:** âœ… PASSED | âš ï¸ WARNINGS | âŒ FAILED\n\n## Summary\n- Structure: âœ…/âŒ\n- Content: âœ…/âŒ\n- Naming: âœ…/âŒ\n- Security: âœ…/âŒ\n\n## Issues Found\n\n### Critical Issues (must fix)\n[List any âŒ issues with fix instructions]\n\n### Warnings (recommended fixes)\n[List any âš ï¸ issues with recommendations]\n\n## Specific Fixes\n\n### Issue 1: [Title]\n**Problem:** [Description]\n**Location:** [File:line or field]\n**Current:**\n```\n[current problematic code]\n```\n**Fixed:**\n```\n[corrected code]\n```\n\n[Repeat for each issue]\n\n## Recommendations\n[General improvement suggestions]\n```\n\n**Quality Standards Reference:**\n\n| Standard | Requirement |\n|----------|-------------|\n| Description | Present, under 60 chars |\n| Argument-hint | Matches actual argument usage |\n| Instructions | Imperative form, for Claude |\n| Tools | Minimal necessary set |\n| Naming | kebab-case, verb-noun |\n| Location | .claude/commands/ |\n\n**Edge Cases:**\n\n- If workflow has no frontmatter: Note it's valid but recommend adding description\n- If workflow uses $ARGUMENTS but no argument-hint: Flag as warning\n- If workflow modifies files but has no Write/Edit tool: Flag as error\n- If bash commands used without Bash in allowed-tools: Flag as error\n\n**Output Format:**\n\nAlways provide:\n1. Clear pass/fail status\n2. Specific issues with locations\n3. Exact fix instructions (copy-pasteable when possible)\n4. General recommendations for improvement\n\nBe thorough but constructive. The goal is to help improve the workflow, not just criticize it.\n",
        "coconut-workflow/commands/create.md": "---\ndescription: Interactive workflow creation - conversationally create Claude Code slash commands\nargument-hint: [optional initial description]\n---\n\n# Workflow Creation Assistant\n\n## --help Handler\n\nIf the user passes `--help` as an argument, display this help and stop:\n\n```\n/coconut-workflow:create - Interactive Workflow Creation\n\nDESCRIPTION\n  Conversationally create Claude Code slash commands through guided\n  requirements discovery. Determines if you need a simple workflow\n  or a full plugin, then generates the appropriate files.\n\nUSAGE\n  /coconut-workflow:create [initial description]\n  /coconut-workflow:create --help\n\nARGUMENTS\n  [initial description]  Optional starting description of what you want\n                         to automate. If omitted, starts with discovery.\n\nEXAMPLES\n  # Start with discovery questions\n  /coconut-workflow:create\n\n  # Start with an idea\n  /coconut-workflow:create \"automate my PR review process\"\n\n  # Create a specific workflow\n  /coconut-workflow:create \"run tests and lint before committing\"\n\nPROCESS\n  1. Discovery - Answer questions about what you want to automate\n  2. Scope Decision - Workflow (single command) vs Plugin (multiple components)\n  3. Design - Review the proposed command structure\n  4. Create - Generate the workflow file in .claude/commands/\n  5. Validate - Verify the workflow works correctly\n\nOUTPUT\n  Creates: .claude/commands/[name].md\n  Format: YAML frontmatter + markdown instructions\n```\n\nGuide the user through creating a Claude Code workflow (slash command) through conversational requirements gathering.\n\n## Initial Context\n\nUser's initial request: $ARGUMENTS\n\n## Process\n\n### Step 1: Load the workflow-creation skill\n\nBefore proceeding, load the `workflow-creation` skill to access decision criteria and best practices.\n\n### Step 2: Requirements Discovery\n\nIf the user provided an initial description ($ARGUMENTS is not empty), acknowledge it and ask clarifying questions.\n\nIf no initial description, start with discovery questions:\n\n**Core Questions** (ask 2-3 at a time, not all at once):\n1. \"What task should this workflow automate?\"\n2. \"When would you typically run this workflow?\"\n3. \"What inputs does it need (files, arguments, context)?\"\n4. \"What should the output look like?\"\n5. \"Are there any tools it needs to use (git, npm, bash commands)?\"\n\n**Follow-up based on answers:**\n- If mentions multiple related tasks â†’ probe if single workflow or multiple needed\n- If mentions external services â†’ probe integration needs\n- If mentions state/memory â†’ probe persistence needs\n- If mentions team usage â†’ probe standardization needs\n\n### Step 3: Scope Decision\n\nBased on gathered requirements, determine if this is a:\n\n**WORKFLOW (slash command)** - Choose when:\n- Single, focused purpose\n- No persistent state needed\n- One-shot execution\n- Project-specific\n- No complex validation logic\n\n**PLUGIN** - Choose when:\n- Multiple related commands needed\n- Needs hooks, agents, or skills\n- External service integration (MCP)\n- Reusable across multiple projects\n- Needs complex validation/automation\n\n**If unclear**, ask the user:\n\"Based on what you've described, this could be either:\n- A **simple workflow** (single slash command) - good for [specific reason]\n- A **full plugin** (multiple components) - better if [specific reason]\n\nWhich approach fits your needs better?\"\n\n### Step 4: Route Appropriately\n\n**If WORKFLOW:**\nContinue to Step 5 below.\n\n**If PLUGIN:**\nInform the user: \"This needs a full plugin with [components]. Let me hand off to the plugin creation workflow.\"\nThen invoke: `/plugin-dev:create-plugin [brief description based on requirements]`\nStop here - the plugin-dev workflow will take over.\n\n### Step 5: Design the Workflow\n\nCreate workflow specification:\n\n1. **Name**: kebab-case, verb-noun pattern (e.g., `review-pr`, `run-tests`)\n2. **Description**: Clear, under 60 characters\n3. **Arguments**: What arguments does it accept? ($1, $2, $ARGUMENTS)\n4. **Allowed Tools**: Minimum needed (principle of least privilege)\n5. **Instructions**: What should Claude do when this runs?\n\nPresent the design to user for confirmation before creating.\n\n### Step 6: Create the Workflow File\n\nCreate the workflow file at `.claude/commands/[name].md`:\n\n```markdown\n---\ndescription: [Clear description]\nargument-hint: [argument format]\nallowed-tools: [tool list]\n---\n\n[Instructions FOR Claude - imperative form, not \"you should\"]\n```\n\n**Critical**: Write instructions FOR Claude, not TO the user. Use imperative form.\n\n### Step 7: Validate and Explain\n\nAfter creating the file, use the `workflow-validator` agent to validate the workflow.\n\nThen explain to the user:\n1. Where the file was created\n2. How to invoke it: `/[workflow-name] [arguments]`\n3. What it will do when run\n4. Any tips for effective use\n\n## Quality Standards\n\nEnsure created workflows follow these standards:\n- âœ… Clear, actionable description\n- âœ… Appropriate tool restrictions\n- âœ… Instructions written FOR Claude (imperative form)\n- âœ… Arguments documented with argument-hint\n- âœ… File in correct location (.claude/commands/)\n- âœ… Naming follows conventions (kebab-case)\n\n## Conversation Style\n\n- Be conversational and collaborative\n- Ask clarifying questions when needed\n- Summarize understanding before creating\n- Explain decisions and tradeoffs\n- Offer to iterate if workflow doesn't meet needs\n",
        "coconut-workflow/skills/workflow-creation/SKILL.md": "---\nname: Workflow Creation\ndescription: This skill should be used when the user asks to \"create a workflow\", \"make a slash command\", \"add a command\", \"automate a task with a command\", \"workflow vs plugin\", \"should this be a workflow or plugin\", or needs guidance on Claude Code command structure, workflow design patterns, or determining appropriate scope for automation requests.\nversion: 0.1.0\n---\n\n# Workflow Creation for Claude Code\n\n## Overview\n\nThis skill provides guidance for creating effective Claude Code workflows (slash commands) and determining when a request needs a simple workflow versus a full plugin.\n\n**Key concepts:**\n- Workflows are Markdown files that become slash commands\n- Commands are instructions FOR Claude, not TO users\n- Scope assessment determines workflow vs plugin routing\n- Quality standards ensure team consistency\n\n## Workflow vs Plugin Decision Framework\n\n### Choose WORKFLOW (slash command) when:\n\n| Criterion | Workflow Appropriate |\n|-----------|---------------------|\n| **Purpose** | Single, focused task |\n| **State** | No persistent state needed |\n| **Execution** | One-shot, runs and completes |\n| **Scope** | Project-specific or personal |\n| **Complexity** | Simple logic, no validation hooks |\n| **Integration** | Uses built-in tools only |\n| **Reusability** | Used in one project mainly |\n\n**Examples of workflows:**\n- `review-pr` - Review current PR changes\n- `run-tests` - Execute test suite with coverage\n- `generate-docs` - Create documentation for file\n- `commit-changes` - Stage and commit with message\n- `fix-lint` - Auto-fix linting issues\n\n### Choose PLUGIN when:\n\n| Criterion | Plugin Required |\n|-----------|-----------------|\n| **Commands** | Multiple related commands needed |\n| **Automation** | Needs hooks for automatic triggering |\n| **Autonomy** | Needs agents for complex autonomous tasks |\n| **Knowledge** | Needs skills for specialized guidance |\n| **Integration** | External service via MCP servers |\n| **Scope** | Reusable across multiple projects |\n| **Validation** | Complex validation or enforcement logic |\n\n**Examples requiring plugins:**\n- Database migration system (create, run, rollback commands + validation hooks)\n- API testing framework (multiple commands + test runner agent)\n- Code review system (command + reviewer agent + standards skill)\n- External service integration (MCP server + commands)\n\n### Decision Questions\n\nAsk these to determine scope:\n\n1. \"Will this need multiple related commands?\" â†’ Yes = Plugin\n2. \"Should something happen automatically on certain events?\" â†’ Yes = Plugin (hooks)\n3. \"Does it need to work autonomously on complex tasks?\" â†’ Yes = Plugin (agents)\n4. \"Does it integrate with external services?\" â†’ Yes = Plugin (MCP)\n5. \"Will multiple projects use this?\" â†’ Yes = Plugin\n\nIf all answers are \"No\" â†’ Workflow is appropriate.\n\n## Workflow Structure\n\n### File Location\n\n```\n.claude/commands/\nâ”œâ”€â”€ workflow-name.md      # /workflow-name command\nâ””â”€â”€ category/\n    â””â”€â”€ specific.md       # /specific (project:category)\n```\n\n### Basic Format\n\n```markdown\n---\ndescription: Brief description under 60 chars\nargument-hint: [required-arg] [optional-arg]\nallowed-tools: Read, Write, Grep\n---\n\n[Instructions for Claude - imperative form]\n```\n\n### Frontmatter Fields\n\n| Field | Required | Purpose |\n|-------|----------|---------|\n| `description` | Recommended | Shows in /help, under 60 chars |\n| `argument-hint` | If args used | Documents expected arguments |\n| `allowed-tools` | Recommended | Restrict tools (security) |\n| `model` | Optional | Force specific model |\n\n### Writing Instructions\n\n**Critical Rule**: Write instructions FOR Claude to execute, not messages TO the user.\n\n**Correct (imperative form):**\n```markdown\nReview the code changes in the current branch.\n\nCheck for:\n1. Security vulnerabilities\n2. Performance issues\n3. Code style violations\n\nReport findings with file paths and line numbers.\n```\n\n**Incorrect (user-facing):**\n```markdown\nThis command will review your code.\nYou'll receive a report with issues found.\n```\n\n## Arguments and Dynamic Content\n\n### Single Argument\n\n```markdown\n---\nargument-hint: [file-path]\n---\n\nReview @$1 for code quality issues.\n```\n\nUsage: `/review src/api/users.ts`\n\n### Multiple Arguments\n\n```markdown\n---\nargument-hint: [source] [target]\n---\n\nCompare @$1 with @$2 and list differences.\n```\n\nUsage: `/compare old.js new.js`\n\n### All Arguments\n\n```markdown\n---\nargument-hint: [search-terms...]\n---\n\nSearch codebase for: $ARGUMENTS\n```\n\nUsage: `/search authentication user login`\n\n### File References\n\nUse `@` to include file contents:\n\n```markdown\nReview @$1 for issues.           # File from argument\nReview @package.json settings.   # Static file reference\n```\n\n## Tool Restrictions\n\n### Principle of Least Privilege\n\nOnly grant tools the workflow actually needs:\n\n| Task Type | Recommended Tools |\n|-----------|-------------------|\n| Read-only analysis | `Read, Grep, Glob` |\n| Code modification | `Read, Write, Edit` |\n| Git operations | `Bash(git:*)` |\n| Testing | `Bash(npm:test), Read` |\n| Full automation | Omit field (all tools) |\n\n### Tool Patterns\n\n```yaml\n# Specific tools\nallowed-tools: Read, Write, Grep\n\n# Bash with restrictions\nallowed-tools: Bash(git:*), Bash(npm:*)\n\n# All tools (rarely needed)\nallowed-tools: \"*\"\n```\n\n## Quality Checklist\n\nBefore finalizing a workflow, verify:\n\n- [ ] **Name**: kebab-case, verb-noun pattern\n- [ ] **Description**: Clear, under 60 characters\n- [ ] **Instructions**: Written FOR Claude (imperative)\n- [ ] **Arguments**: Documented with argument-hint\n- [ ] **Tools**: Minimal necessary set\n- [ ] **Location**: In `.claude/commands/`\n- [ ] **Testing**: Verify it works as expected\n\n## Common Patterns\n\n### Code Review Pattern\n\n```markdown\n---\ndescription: Review code changes for quality issues\nallowed-tools: Read, Grep, Glob, Bash(git:*)\n---\n\nGet changed files: !`git diff --name-only HEAD~1`\n\nFor each changed file:\n1. Read the file content\n2. Check for security issues\n3. Check for performance problems\n4. Verify code style\n\nReport issues with:\n- File path and line number\n- Issue description\n- Suggested fix\n```\n\n### Testing Pattern\n\n```markdown\n---\ndescription: Run tests for specific module\nargument-hint: [module-path]\nallowed-tools: Bash(npm:*), Read\n---\n\nRun tests: !`npm test -- $1`\n\nAnalyze results:\n- List failing tests\n- Identify root causes\n- Suggest fixes\n\nIf all pass, confirm success.\n```\n\n### Generation Pattern\n\n```markdown\n---\ndescription: Generate documentation for file\nargument-hint: [source-file]\n---\n\nRead and analyze @$1\n\nGenerate documentation including:\n- Purpose and overview\n- Function/class descriptions\n- Parameters and return values\n- Usage examples\n\nWrite to appropriate location based on project structure.\n```\n\n### Git Workflow Pattern\n\n```markdown\n---\ndescription: Commit changes with conventional message\nargument-hint: [type] [description]\nallowed-tools: Bash(git:*)\n---\n\nStage changes: !`git add -A`\nShow staged: !`git diff --cached --stat`\n\nCreate commit with type \"$1\" and message \"$2\".\nFollow conventional commits format:\n- feat: new feature\n- fix: bug fix\n- docs: documentation\n- refactor: code refactoring\n\nConfirm commit created successfully.\n```\n\n## Troubleshooting\n\n**Workflow not appearing in /help:**\n- Check file is in `.claude/commands/`\n- Verify `.md` extension\n- Restart Claude Code session\n\n**Arguments not working:**\n- Use `$1`, `$2` for positional\n- Use `$ARGUMENTS` for all\n- Check argument-hint matches usage\n\n**Tools not available:**\n- Verify allowed-tools includes needed tools\n- Check tool name spelling\n- Use `Bash(pattern:*)` for bash restrictions\n\n**File references not loading:**\n- Use `@` prefix for file paths\n- Ensure Read tool is allowed\n- Check file path is correct\n\n## Integration with Plugin Components\n\nWhen a workflow needs to leverage plugin components:\n\n**Invoke Agent:**\n```markdown\nUse the code-reviewer agent for detailed analysis.\n```\n\n**Reference Skill:**\n```markdown\nApply coding-standards skill guidelines.\n```\n\n**Trigger Another Command:**\n```markdown\nAfter completion, run /validate-changes.\n```\n\nThis skill provides the foundation for creating effective, well-structured workflows that maintain team consistency and follow Claude Code best practices.\n"
      },
      "plugins": [
        {
          "name": "coconut-commit-work",
          "source": "./coconut-commit-work",
          "description": "Intelligent git commits with semantic grouping, conventional commit messages, emoji prefixes, user stories, and parallel sub-agent execution",
          "version": "0.2.0",
          "author": {
            "name": "Francis Varga"
          },
          "keywords": [
            "git",
            "commit",
            "conventional-commits",
            "automation",
            "workflow"
          ],
          "categories": [
            "automation",
            "commit",
            "conventional-commits",
            "git",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add FrancisVarga/coconut-claude-code-plugins",
            "/plugin install coconut-commit-work@coconut-claude-code-plugins"
          ]
        },
        {
          "name": "coconut-workflow",
          "source": "./coconut-workflow",
          "description": "Interactive workflow creation assistant that helps teams create Claude Code slash commands through conversational requirements gathering",
          "version": "0.1.0",
          "author": {
            "name": "Francis Varga"
          },
          "keywords": [
            "workflow",
            "commands",
            "automation",
            "team-standards"
          ],
          "categories": [
            "automation",
            "commands",
            "team-standards",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add FrancisVarga/coconut-claude-code-plugins",
            "/plugin install coconut-workflow@coconut-claude-code-plugins"
          ]
        },
        {
          "name": "coconut-rules",
          "source": "./coconut-rules",
          "description": "Manage Claude Code rules with context-based loading, retrospective analysis, and knowledge graph integration",
          "version": "3.0.0",
          "author": {
            "name": "Francis Varga"
          },
          "keywords": [
            "rules",
            "claude-md",
            "organization",
            "configuration"
          ],
          "categories": [
            "claude-md",
            "configuration",
            "organization",
            "rules"
          ],
          "install_commands": [
            "/plugin marketplace add FrancisVarga/coconut-claude-code-plugins",
            "/plugin install coconut-rules@coconut-claude-code-plugins"
          ]
        }
      ]
    }
  ]
}