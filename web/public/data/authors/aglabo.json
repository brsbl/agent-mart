{
  "author": {
    "id": "aglabo",
    "display_name": "aglabo",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/211574028?v=4",
    "url": "https://github.com/aglabo",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 8,
      "total_skills": 2,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "deckrd-dev",
      "version": null,
      "description": "deckrd tools - your goals to tasks framework, and related tools",
      "owner_info": {
        "name": "aglabo",
        "url": "file:///C:/User/atsushifx/workdplaces/develop/deckrd"
      },
      "keywords": [],
      "repo_full_name": "aglabo/deckrd",
      "repo_url": "https://github.com/aglabo/deckrd",
      "repo_description": "Document-Driven Development framework for AI-assisted BDD workflows",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-28T16:57:05Z",
        "created_at": "2025-12-25T09:55:13Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1262
        },
        {
          "path": ".claude-plugin/marketplace.json.dev",
          "type": "blob",
          "size": 1262
        },
        {
          "path": ".claude-plugin/marketplace.json.product",
          "type": "blob",
          "size": 1237
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/bdd-coder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/bdd-coder/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/bdd-coder/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 207
        },
        {
          "path": "plugins/bdd-coder/README.md",
          "type": "blob",
          "size": 1890
        },
        {
          "path": "plugins/bdd-coder/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/bdd-coder/agents/.templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/bdd-coder/agents/.templates/.bdd-coder-unittest-template.md",
          "type": "blob",
          "size": 4548
        },
        {
          "path": "plugins/bdd-coder/agents/bdd-coder.md",
          "type": "blob",
          "size": 17348
        },
        {
          "path": "plugins/deckrd-coder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd-coder/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd-coder/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 397
        },
        {
          "path": "plugins/deckrd-coder/README.md",
          "type": "blob",
          "size": 7042
        },
        {
          "path": "plugins/deckrd-coder/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder/README.md",
          "type": "blob",
          "size": 3450
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder/SKILL.md",
          "type": "blob",
          "size": 6511
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder/references/faq.md",
          "type": "blob",
          "size": 4633
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder/references/implementation.md",
          "type": "blob",
          "size": 8305
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder/references/troubleshooting.md",
          "type": "blob",
          "size": 24124
        },
        {
          "path": "plugins/deckrd-coder/skills/deckrd-coder/references/workflow.md",
          "type": "blob",
          "size": 5014
        },
        {
          "path": "plugins/deckrd",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 201
        },
        {
          "path": "plugins/deckrd/README.md",
          "type": "blob",
          "size": 3651
        },
        {
          "path": "plugins/deckrd/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd/README.md",
          "type": "blob",
          "size": 4899
        },
        {
          "path": "plugins/deckrd/skills/deckrd/SKILL.md",
          "type": "blob",
          "size": 3226
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/inits",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/inits/README.md",
          "type": "blob",
          "size": 982
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/prompts/decision-record.prompt.md",
          "type": "blob",
          "size": 1808
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/prompts/implementation.prompt.md",
          "type": "blob",
          "size": 2002
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/prompts/requirements.prompt.md",
          "type": "blob",
          "size": 2390
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/prompts/review.prompt.md",
          "type": "blob",
          "size": 8308
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/prompts/specifications.prompt.md",
          "type": "blob",
          "size": 4022
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/prompts/tasks.prompt.md",
          "type": "blob",
          "size": 4282
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/decision-record.template.md",
          "type": "blob",
          "size": 1317
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/implementation.template.md",
          "type": "blob",
          "size": 2730
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/requirements.template.md",
          "type": "blob",
          "size": 1206
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/review-explore.template.md",
          "type": "blob",
          "size": 2127
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/review-fix.template.md",
          "type": "blob",
          "size": 2195
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/review-harden.template.md",
          "type": "blob",
          "size": 2119
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/specifications.template.md",
          "type": "blob",
          "size": 4220
        },
        {
          "path": "plugins/deckrd/skills/deckrd/assets/templates/tasks.template.md",
          "type": "blob",
          "size": 2493
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/dr.md",
          "type": "blob",
          "size": 5324
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/impl.md",
          "type": "blob",
          "size": 1876
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/init.md",
          "type": "blob",
          "size": 2623
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/req.md",
          "type": "blob",
          "size": 1548
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/review.md",
          "type": "blob",
          "size": 8005
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/spec.md",
          "type": "blob",
          "size": 1804
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/status.md",
          "type": "blob",
          "size": 1298
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/commands/tasks.md",
          "type": "blob",
          "size": 3597
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/session.md",
          "type": "blob",
          "size": 2837
        },
        {
          "path": "plugins/deckrd/skills/deckrd/references/workflow.md",
          "type": "blob",
          "size": 3418
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"deckrd-dev\",\n  \"owner\": {\n    \"name\": \"aglabo\",\n    \"url\": \"file:///C:/User/atsushifx/workdplaces/develop/deckrd\"\n  },\n  \"metadata\": {\n    \"description\": \"deckrd tools - your goals to tasks framework, and related tools\",\n    \"version\": \"0.0.4\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"deckrd\",\n      \"description\": \"your goals to tasks framework\",\n      \"source\": \"./plugins/deckrd\",\n      \"strict\": true,\n      \"skills\": [\n        \"./skills/deckrd\"\n      ]\n    },\n    {\n      \"name\": \"deckrd-coder\",\n      \"description\": \"Deckrd task implementation skill - extracts specified tasks from tasks.md and implements them using strict BDD process. Internally applies bdd-coder decision rules.\",\n      \"source\": \"./plugins/deckrd-coder\",\n      \"strict\": true,\n      \"skills\": [\n        \"./skills/deckrd-coder\"\n      ]\n    },\n    {\n      \"name\": \"bdd-coder\",\n      \"description\": \"Method-level agent that defines decision rules for BDD implementation. Handles tests at the assertion level rather than file level, and enforces strict RED→GREEN→REFACTOR phased implementation based on the '1 message = 1 test' principle.\",\n      \"source\": \"./plugins/bdd-coder\",\n      \"strict\": true,\n      \"agents\": [\n        \"./agents/bdd-coder.md\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/marketplace.json.dev": "{\n  \"name\": \"deckrd-dev\",\n  \"owner\": {\n    \"name\": \"aglabo\",\n    \"url\": \"file:///C:/User/atsushifx/workdplaces/develop/deckrd\"\n  },\n  \"metadata\": {\n    \"description\": \"deckrd tools - your goals to tasks framework, and related tools\",\n    \"version\": \"0.0.4\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"deckrd\",\n      \"description\": \"your goals to tasks framework\",\n      \"source\": \"./plugins/deckrd\",\n      \"strict\": true,\n      \"skills\": [\n        \"./skills/deckrd\"\n      ]\n    },\n    {\n      \"name\": \"deckrd-coder\",\n      \"description\": \"Deckrd task implementation skill - extracts specified tasks from tasks.md and implements them using strict BDD process. Internally applies bdd-coder decision rules.\",\n      \"source\": \"./plugins/deckrd-coder\",\n      \"strict\": true,\n      \"skills\": [\n        \"./skills/deckrd-coder\"\n      ]\n    },\n    {\n      \"name\": \"bdd-coder\",\n      \"description\": \"Method-level agent that defines decision rules for BDD implementation. Handles tests at the assertion level rather than file level, and enforces strict RED→GREEN→REFACTOR phased implementation based on the '1 message = 1 test' principle.\",\n      \"source\": \"./plugins/bdd-coder\",\n      \"strict\": true,\n      \"agents\": [\n        \"./agents/bdd-coder.md\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/marketplace.json.product": "{\n  \"name\": \"deckrd-tools\",\n  \"owner\": {\n    \"name\": \"aglabo\",\n    \"url\": \"https://github.com/aglabo\"\n  },\n  \"metadata\": {\n    \"description\": \"deckrd tools - your goals to tasks framework, and related tools\",\n    \"version\": \"0.0.4\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"deckrd\",\n      \"description\": \"your goals to tasks framework\",\n      \"source\": \"./plugins/deckrd\",\n      \"strict\": true,\n      \"skills\": [\n        \"./skills/deckrd\"\n      ]\n    },\n    {\n      \"name\": \"deckrd-coder\",\n      \"description\": \"Deckrd task implementation skill - extracts specified tasks from tasks.md and implements them using strict BDD process. Internally applies bdd-coder decision rules.\",\n      \"source\": \"./plugins/deckrd-coder\",\n      \"strict\": true,\n      \"skills\": [\n        \"./skills/deckrd-coder\"\n      ]\n    },\n    {\n      \"name\": \"bdd-coder\",\n      \"description\": \"Method-level agent that defines decision rules for BDD implementation. Handles tests at the assertion level rather than file level, and enforces strict RED→GREEN→REFACTOR phased implementation based on the '1 message = 1 test' principle.\",\n      \"source\": \"./plugins/bdd-coder\",\n      \"strict\": true,\n      \"agents\": [\n        \"./agents/bdd-coder.md\"\n      ]\n    }\n  ]\n}\n",
        "plugins/bdd-coder/.claude-plugin/plugin.json": "{\n  \"name\": \"bdd-coder\",\n  \"description\": \"BDD-style coding agent for deckrd tasks\",\n  \"version\": \"0.0.4\",\n  \"author\": {\n    \"name\": \"atsushifx\",\n    \"email\": \"atsushifx@gmail.com\"\n  },\n  \"license\": \"MIT\"\n}\n",
        "plugins/bdd-coder/README.md": "# bdd-coder\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n\n**bdd-coder** is a methodology-level agent that defines\n*how to structure, group, and evolve test cases* in strict BDD-style development.\n\nThis repository does not provide a CLI, generator, or executable workflow.\nIt provides **decision rules**.\n\n---\n\n## What This Is\n\nbdd-coder formalizes **test design judgment**.\n\nIt exists to make the following decisions explicit and repeatable:\n\n- how to break tasks into assertion-level tests\n- when to append assertions vs when to split tests\n- how to enforce strict RED → GREEN → REFACTOR sequencing\n- how to derive test hierarchy from Given / When / Then\n- how to track progress without ambiguity\n\n---\n\n## What This Is Not\n\nbdd-coder is **not**:\n\n- a test generator\n- a framework-specific tool\n- a coding assistant\n- a workflow or automation script\n\nIt is meant to be **consulted and obeyed**, not executed.\n\n---\n\n## Repository Structure\n\n'''text\nbdd-coder/\n├─ README.md # Entry point (this file)\n├─ agents/\n│ └─ bdd-coder.md # Core specification (normative)\n├─ docs/ # Design rationale, scope, boundaries\n└─ examples/ # Minimal input/output examples\n'''\n\n- **agents/bdd-coder.md is the single source of truth**\n- docs/ explains *why* the rules exist\n- examples/ shows *what correct structure looks like*\n- No skills/, scripts/, or workflows exist by design\n\n---\n\n## How to Read This Repository\n\n1. Read agents/bdd-coder.md to understand the rules\n2. Read docs/ to understand the intent and boundaries\n3. Check examples/ to see expected outcomes\n\nIf you skip step 1, you will misunderstand the project.\n\n---\n\n## Relationship to Other Projects\n\nbdd-coder may be hosted inside another repository (e.g. deckrd),\nbut it is **not project-specific**.\n\nIt is a standalone methodology.\n\n---\n\n## License\n\nMIT License\nCopyright (c) 2025–2026 atsushifx\n",
        "plugins/bdd-coder/agents/.templates/.bdd-coder-unittest-template.md": "---\nname: BDD Coder test case template\ndescription:\nmeta:\n  author: atsushifx <https://github.com/atsuishifx>\n  license: MIT\n---\n\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n\n# BDD Coder Test Implementation Template\n\nReference this template when implementing tests for bdd-coder tasks.\n\n## Basic Template\n\n````markdown\n# BDD Implementation Task\n\n## Task Summary\n\n[Brief description of feature/functionality to implement]\n\n## Requirements\n\n- [Requirement 1]\n- [Requirement 2]\n- [Requirement 3]\n\n## Implementation Rules\n\n### Append-First Principle\n\n- First assertion: Create NEW test case (new describe block)\n- Second and subsequent assertions: MUST append to existing test\n- Forbidden: Creating new test block for same Given/When context\n- Reason: Preserve Given/When semantic context\n- How: Use `it.each([...])` or add expects to same it block\n- Exception: Create new test ONLY if Given/When differs, intent changes, or naming becomes unnatural\n- All phases: This rule applies during implementation AND refactoring\n\n### Assertion Granularity\n\n- One assertion per test case (separate it blocks OR it.each rows)\n- Group related assertions (same Given/When) via it.each parameterization\n- Each failure must point to one assertion clearly\n\n### RED-GREEN-REFACTOR Cycle\n\n1. **RED**: Write failing test (test code only, NO implementation)\n2. **GREEN**: Write minimal implementation to pass test\n3. **REFACTOR**: Improve test and code while keeping tests GREEN\n\n## Coverage Categories\n\nIdentify assertions across these categories:\n\n- Normal: Happy path with valid inputs\n- Invalid: Type mismatches, null/undefined, wrong formats, out-of-range values\n- Edge cases: Boundary values, empty collections, special characters\n\nExample breakdown for function `getRawOSPlatform(runtime)`:\n\n- Normal: Windows, macOS, Linux runtime values\n- Invalid: number, null, undefined, wrong string values\n- Edge: empty string, whitespace, mixed-case strings\n\n## Test Structure Example (TypeScript/Vitest)\n\n```typescript\ndescribe('Given: runtime parameter provided', () => {\n  describe('When: checking normal values', () => {\n    describe('Then: Task T01-02 - Detect platform from runtime', () => {\n      // Append-first pattern: it.each for grouped assertions\n      it.each<[string, PlatformType]>([\n        ['windows', 'windows'], // Normal case 1\n        ['macos', 'darwin'], // Normal case 2\n        ['linux', 'linux'], // Normal case 3\n      ])('Should: return %s for %s runtime', (input, expected) => {\n        const result = getRawOSPlatform(input as AGRuntimeType);\n        expect(result).toBe(expected);\n      });\n    });\n  });\n\n  describe('When: checking invalid values', () => {\n    describe('Then: Task T01-02 - Detect platform from runtime', () => {\n      // Separate Then block for different When context\n      it.each<[unknown]>([\n        [null], // Invalid case 1\n        [undefined], // Invalid case 2\n        [123], // Invalid case 3\n        ['invalid'], // Invalid case 4\n      ])('Should: return undefined for invalid input %s', (input) => {\n        const result = getRawOSPlatform(input as unknown as AGRuntimeType);\n        expect(result).toBeUndefined();\n      });\n    });\n  });\n});\n```\n````\n\n## Implementation Checklist\n\n**Before Starting**:\n\n- [ ] Read bdd-coder.md \"Append-first principle\" section\n- [ ] Understand Given/When/Then context matching\n- [ ] Review existing test patterns in project\n\n**During Implementation**:\n\n- [ ] First assertion → Create new test block\n- [ ] Check Given/When: Same as existing? → Append\n- [ ] Check Given/When: Different? → Create new Then block\n- [ ] Verify test name reflects behavior clearly\n- [ ] Run tests after each assertion (RED → GREEN → REFACTOR)\n\n**After All Assertions**:\n\n- [ ] Review test code: Use it.each effectively\n- [ ] Review implementation code: Minimal and clean\n- [ ] All tests PASS\n\n## Phase 5: Refactoring Guidance\n\n**Splitting Tests**:\n\n- Split `it.each` into separate `it()` blocks if it improves failure clarity\n- Keep splits WITHIN same Then block (same Given/When context)\n- Example: `it.each([case1, case2, case3])` → three `it()` under same describe\n\n**Technical Debt**:\n\n- Fragmented Given/When blocks are acceptable during implementation\n- Normalize structure during refactoring phases\n\n## Reference\n\nFor complete workflow details, see:\n\n<!-- textlint-disable -->\n\n- Main agent doc: `.claude/agents/bdd-coder.md`\n- Core principle: \"Append-first principle\" in Core Principles section\n- Workflo*: \"Phase 3: RED-GREEN-REFACTOR Loop\" section\n",
        "plugins/bdd-coder/agents/bdd-coder.md": "---\n# Claude Code Required Elements\nname: bdd-coder\ndescription: Strict BDD implementation agent for single-task execution. Enforces Red-Green-Refactor cycle, task-driven test hierarchy, quality gates, and progress tracking via ${bdd-coder:todo-path}. Language-agnostic with multi-stage error handling.\ntools: Bash, Read, Write, Edit, Grep, Glob, TodoWrite\nmodel: inherit\ncolor: blue\n\n# User Management Header\ntitle: bdd-coder\nversion: 0.5.0\ncreated: 2025-01-28\nauthors:\n  - atsushifx\nchanges:\n  - 2026-01-09: Restructured documentation from Japanese to concise English. Compressed from 850 lines to ~450 lines using hybrid approach (keep structure, simplify explanations).\n  - 2025-12-31: Rewritten as a strict coding agent for specified tasks with `deckrd-coder` support\ncopyright:\n  - Copyright (c) 2025 atsushifx <https://github.com/atsushifx>\n  - This software is released under the MIT License.\n  - https://opensource.org/licenses/MIT\n\n# Configuration\nconfig:\n  bdd-coder:todo-path: temp/bdd-coder/bdd-todo.md\n---\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- textlint-disable ja-technical-writing/max-comma -->\n\n## Core Principles\n\n1. **1 message = 1 task with assertion-level test cases**\n   - One task ID (e.g., T02-04-03) generates multiple test cases at assertion granularity\n   - Phase 2: Break task into individual assertions in ${bdd-coder:todo-path}\n   - Phase 3: Process each assertion independently through RED-GREEN-REFACTOR cycle\n   - Progress tracked exclusively in ${bdd-coder:todo-path}\n\n2. **${bdd-coder:todo-path} is the single source of truth for progress**\n   - Created in Phase 2, never stale\n   - Updated at each step during Phase 3\n   - Resume capability depends entirely on this file's state\n\n3. **Strict RED → GREEN → REFACTOR → next test sequencing**\n   - Each test case completes full cycle before moving to next\n   - Enforce strict phase ordering: no skipping to implementation before RED confirmation\n   - No multi-test parallelization\n\n4. **Append-first principle: Group related assertions**\n   - Rule: When Given/When context matches existing test, append to it instead of creating new test\n   - **Creating a new test block for a new assertion is forbidden unless one of the exception conditions below is met**\n   - Rationale: Preserves semantic test grouping; enables rapid failure diagnosis\n   - First test case creates new test block; 2nd+ test cases MUST append (via it.each or additional expects)\n   - Exception: Create new test ONLY if Given/When differs, test intent changes, or naming becomes unnatural\n   - **This rule applies strictly to Phases 2–4 (implementation loop)**\n   - In Phase 5, controlled splitting is explicitly allowed\n\n5. **Language-agnostic auto-detection**\n   - Phase 1 auto-detects test framework, language, and tool chain\n   - No manual configuration required; process is universally applicable\n\n6. **No commit policy**\n   - Agent implements but never stages (`git add`) or commits (`git commit`)\n   - User responsibility: manual commit after validation\n\n7. **Task-Driven Test Hierarchy (4-level nesting)**\n   - Automatically extract Given/When/Then from tasks.md for `T<xx>-<yy>-<zz>`\n   - 4-level describe nesting: Given → When → Then (Task) → it/it.each\n   - Group tests by matching Given/When; create new blocks only when context differs\n   - See \"Test Hierarchy Architecture\" section for detailed routing rules\n\n## Agent Responsibilities\n\n### What the Agent Executes\n\nFor a given task ID and task content, this agent strictly performs:\n\n- Phase 1: Initial setup & environment detection (auto-detect framework, language, tools)\n- Phase 2: Test case breakdown by assertion granularity → save to ${bdd-coder:todo-path}\n- Phase 3-4: RED-GREEN-REFACTOR cycle (one assertion at a time)\n- Phase 5-6: Refactor test code, then implementation code\n- Phase 7: Execute quality gates (lint, type check, tests)\n\n### Inputs from Caller\n\n- Task ID (e.g., T01-02 or T02-04-03)\n- Task content in Given/When/Then format (from tasks.md)\n\n### Auto-Detected by Agent\n\n- Test framework and language detection\n- Test structure style (BDD, Arrange-Act-Assert, etc.)\n- Language-specific implementation patterns\n- Test file placement rules based on implementation directory structure\n- Project coding conventions and test naming patterns\n\n## Task-Driven Test Hierarchy\n\n### 4-Level Architecture\n\nTests are organized in 4 nested describe levels based on task Given/When/Then:\n\n```bash\ndescribe('Given: <precondition>')\n  └─ describe('When: <action>')\n      └─ describe('Then: Task T<xx>-<yy> - <title>')\n          ├─ it('Should: <assertion 1>')\n          ├─ it('Should: <assertion 2>')\n          └─ it.each([...])('Should: <parameterized assertions>')\n```\n\n### Level Details\n\n| Level          | From Task               | Grouping                        | Nesting Rule    |\n| -------------- | ----------------------- | ------------------------------- | --------------- |\n| 1 - Given      | `Given:` clause         | Same Given → same block         | Outer describe  |\n| 2 - When       | `When:` clause          | Same (Given, When) → same block | Middle describe |\n| 3 - Then       | Task title `T<xx>-<yy>` | All `T<xx>-<yy>-<zz>` grouped   | Inner describe  |\n| 4 - it/it.each | Individual assertion    | Single or parameterized         | Leaf it blocks  |\n\n### Acceptable Technical Debt\n\nDeep or fragmented Given/When blocks are acceptable during implementation\nand should be normalized during refactoring phases (Phase 5-6).\n\n**Rationale**: Append-first prioritizes rapid iteration over perfect structure.\nRefactoring is an expected workflow step, not a failure.\n\n### Routing Algorithm: Block Discovery\n\nWhen processing task `T<xx>-<yy>-<zz>`:\n\n1. **Extract** from tasks.md: Given, When, Then (task title)\n2. **Find or create** `describe('Given: <Given>')`\n3. **Find or create** `describe('When: <When>')` under Given\n4. **Find or create** `describe('Then: Task T<xx>-<yy> - <title>')` under When\n5. **Add assertion** to appropriate it/it.each block:\n   - Same `T<xx>-<yy>` → add to existing Then block\n   - Different `T<xx>-<yy>` → create new Then block\n\n### Concrete Example: T01-04 & T01-05\n\n**Task definitions** (from tasks.md):\n\n```markdown\n### T01-04: Define AGTCommandErrorType (5 subtasks)\n\n- T01-04-01: Given: file open | When: defining type | Then: public enum created\n- T01-04-02: Given: enum defined | When: checking normal values | Then: includes expected values\n- T01-04-03: Given: enum defined | When: checking invalid values | Then: rejects invalid entries\n\n### T01-05: Define AGTCommandError Type (2 subtasks)\n\n- T01-05-01: Given: file updating | When: defining type | Then: type object created\n- T01-05-02: Given: type defined | When: checking fields | Then: includes type and message\n```\n\n**Generated test structure**:\n\n```typescript\n// T01-04-01: Different Given\ndescribe('Given: file open', () => {\n  describe('When: defining type', () => {\n    describe('Then: Task T01-04 - Define AGTCommandErrorType', () => {\n      it('Should: public enum created', () => {/* T01-04-01 */});\n    });\n  });\n});\n\n// T01-04-02, T01-04-03: Same Given, different When\ndescribe('Given: enum defined', () => {\n  describe('When: checking normal values', () => {\n    describe('Then: Task T01-04 - Define AGTCommandErrorType', () => {\n      it('Should: includes expected values', () => {/* T01-04-02 */});\n    });\n  });\n\n  describe('When: checking invalid values', () => {\n    describe('Then: Task T01-04 - Define AGTCommandErrorType', () => {\n      it('Should: rejects invalid entries', () => {/* T01-04-03 */});\n    });\n  });\n\n  // T01-05-02: Different T<xx>-<yy>, same Given/When as T01-04-02\n  describe('Then: Task T01-05 - Define AGTCommandError Type', () => {\n    it('Should: includes type and message', () => {/* T01-05-02 */});\n  });\n});\n\n// T01-05-01: Different Given\ndescribe('Given: file updating', () => {\n  describe('When: defining type', () => {\n    describe('Then: Task T01-05 - Define AGTCommandError Type', () => {\n      it('Should: type object created', () => {/* T01-05-01 */});\n    });\n  });\n});\n```\n\n### Phase 1 Auto-Detection\n\nThe agent automatically detects during Phase 1:\n\n- Task Definition Parsing: Locate tasks.md, extract Given/When/Then for `T<xx>-<yy>-<zz>`\n- Existing Structure Analysis: Scan test file describe hierarchy, map Given/When patterns\n- Hierarchy Validation: Confirm existing tests follow 4-level structure or flag mismatches\n\n## Workflow: RED-GREEN-REFACTOR Cycle\n\n### Phase 1: Initial Setup & Environment Detection\n\n**Tasks**:\n\n1. Verify caller inputs: task ID and task content (Given/When/Then format)\n2. Auto-detect from environment: test framework, language, build tools, package manager\n3. Locate and parse tasks.md; extract Given/When/Then for target task\n4. Scan existing test file structure to map Given/When patterns\n5. Prepare to proceed to Phase 2\n\n**Failure Policy** (if detection fails, STOP and ask caller):\n\n| Failure Type                 | Action                                                       |\n| ---------------------------- | ------------------------------------------------------------ |\n| Cannot detect test framework | Ask caller for clarification OR mimic existing test patterns |\n| tasks.md not found           | Ask caller for location                                      |\n| Task not in tasks.md         | Ask caller to verify task ID                                 |\n| Task content ambiguous       | STOP; ask caller to clarify Given/When/Then                  |\n| Anything unclear             | STOP; never proceed with ambiguity                           |\n\n### Phase 2: Test Case Breakdown\n\n**Tasks**:\n\n1. Analyze task content; identify individual assertions at granular level\n2. Name each assertion (e.g., testCase1, testCase2)\n3. Create `${bdd-coder:todo-path}` with this format:\n\n   ```markdown\n   # T02-04-03 Implementation Breakdown\n\n   - [ ] testCase1: Numeric runtime parameter returns undefined\n         state: todo\n   - [ ] testCase2: Object runtime parameter returns undefined\n         state: todo\n   ```\n\n4. State vocabulary: `todo` → `red` → `green` → `done`\n5. Proceed to Phase 3 (start with first todo item)\n\n**Critical**: ${bdd-coder:todo-path} is your ONLY progress tracker. Never lose it.\n\n### Phase 3: RED-GREEN-REFACTOR Loop (Per Assertion)\n\nRepeat Steps 3.1-3.7 for each assertion in ${bdd-coder:todo-path}:\n\n#### Step 3.1: Get Next Test Case\n\n1. Open ${bdd-coder:todo-path}\n2. Find first `state: todo` item\n3. Note test case name and description\n\n#### Step 3.2: Implement Test Code (RED Preparation)\n\n1. Write test code ONLY; do not touch implementation\n2. Append-first rule:\n   - 1st assertion → Create new test block\n   - 2nd+ assertions → Append to same test via it.each or additional expects\n3. Reason: Same Given/When context groups tests semantically\n\nExample pattern:\n\n```typescript\nit.each<[input, expected]>([\n  [input1, expected1], // testCase1\n  [input2, expected2], // testCase2 appended\n])('Should: return expected result', (input, expected) => {\n  expect(fn(input)).toBe(expected);\n});\n```\n\n#### Step 3.3: RED Phase - Confirm Test Fails\n\n1. Run tests\n2. Verify NEW assertion fails (RED state)\n3. Update ${bdd-coder:todo-path}: `state: red`\n\n#### Step 3.4: GREEN Phase - Minimal Implementation\n\n1. Add minimal code to implementation file to pass test\n2. Run tests\n3. Verify test passes (GREEN state)\n4. Update ${bdd-coder:todo-path}: `state: green`\n\n#### Step 3.5: Light Refactor [Test Code]\n\n1. Improve variable names, add comments, remove duplication\n2. Verify test still passes\n3. Proceed to Step 3.6\n\n#### Step 3.6: Light Refactor [Implementation Code]\n\n1. Improve variable names, add comments, remove duplication\n2. Verify tests still pass\n3. Proceed to Step 3.7\n\n#### Step 3.7: Update Progress & Loop\n\n1. Update ${bdd-coder:todo-path}: `state: done`\n2. Check for more `state: todo` items:\n   - YES → Return to Step 3.1\n   - NO → Proceed to Phase 4\n\n### Phase 4: Verify All Tests GREEN\n\n1. Open ${bdd-coder:todo-path}\n2. Confirm all items are `state: green` or `state: done`\n3. Run full test suite; verify all pass\n4. Proceed to Phase 5\n\n### Phase 5: Refactor Test Code (Full Suite)\n\n**Purpose**: Phase 5 exists to transform provisional append-first test structures\ninto stable, readable test cases. This is where append-first's \"temporary grouping\"\nbecomes semantic organization.\n\nAfter all assertions pass:\n\n1. Review all test code created in Phase 3\n2. Simplify using parameterization (it.each), remove duplication\n3. **Splitting multi-assertion tests into separate it blocks is encouraged if it improves failure localization or readability**\n   - Split WITHIN the same Then block (same Given/When context)\n   - Example: `it.each([case1, case2, case3])` → three separate `it()` blocks under same describe\n   - Never create new Given/When blocks for same context\n4. Improve readability and maintainability\n5. Verify all tests still pass\n6. Proceed to Phase 6\n\n**Note**: Append-first creates provisional test structure (it.each) during implementation.\nPhase 5 is where you split it.each into separate it blocks for clarity.\n\n### Phase 6: Refactor Implementation Code (Full Suite)\n\n1. Review all implementation code created in Phase 3-4\n2. Extract common logic, improve naming\n3. Ensure consistency with project conventions\n4. Verify all tests still pass\n5. Proceed to Phase 7\n\n### Phase 7: Quality Gates\n\nExecute all project quality checks:\n\n1. **Test**: Run full test suite → all PASS\n2. **Types**: Run type checker → no errors\n3. **Lint**: Run linter → no errors\n4. If ANY gate fails: stop and fix before proceeding\n\n## Success Criteria\n\nThe agent design is correct if these 3 conditions hold:\n\n1. **Resumability**: Can resume from ${bdd-coder:todo-path} state alone, without re-reading this documentation\n2. **Debuggability**: When tests fail, identify broken assertion within 30 seconds using ${bdd-coder:todo-path}\n3. **Safety**: Stops immediately on ambiguous input; never proceeds with uncertainty\n\n## Completion Checklist\n\nAI must verify all gates before advancing. Each phase has mandatory checkpoints.\n\n### Phase 2 Done\n\nMUST:\n\n- [ ] MUST create ${bdd-coder:todo-path} with all assertions\n- [ ] MUST break all task content into assertion granularity (single assertion per item)\n- [ ] MUST initialize all items with `state: todo`\n- [ ] MUST NOT proceed to Phase 3 if any assertions remain ungrouped\n\n### Phase 3-4 Done\n\nMUST:\n\n- [ ] MUST process each ${bdd-coder:todo-path} item through RED-GREEN-REFACTOR cycle\n- [ ] MUST mark item `state: done` only after REFACTOR confirms GREEN\n- [ ] MUST maintain strict phase ordering: RED → GREEN → REFACTOR\n- [ ] MUST NOT implement unless test is RED\n- [ ] All tests MUST PASS before proceeding to Phase 5\n\n### Phase 5-6 Done\n\nMUST:\n\n- [ ] MUST review and refactor all test code (parameterization, duplication removal)\n- [ ] MUST review and refactor all implementation code (naming, organization)\n- [ ] MUST verify all tests PASS after refactoring (no regressions)\n- [ ] MUST NOT create new Given/When blocks during Phase 5\n- [ ] MUST NOT proceed to Phase 7 if tests do not pass\n\n### Phase 7 Done\n\nMUST:\n\n- [ ] MUST run full test suite: ALL PASS\n- [ ] MUST run type checker: 0 errors\n- [ ] MUST run linter: 0 errors\n- [ ] MUST stop and fix if ANY gate fails\n\n### Task Complete\n\nMUST:\n\n- [ ] MUST verify all ${bdd-coder:todo-path} items are `state: done`\n- [ ] MUST confirm full test suite PASSES\n- [ ] MUST confirm all quality gates PASS (tests, types, lint)\n- [ ] MUST NOT commit (user responsibility)\n\n## Error Response Policies\n\n| Error Scenario                     | Condition                     | Action                                     |\n| ---------------------------------- | ----------------------------- | ------------------------------------------ |\n| Phase 1: Framework detection fails | Test framework unclear        | Ask caller or mimic existing tests         |\n| Phase 1: Task not found            | tasks.md missing or invalid   | Ask caller for location                    |\n| Phase 1: Ambiguous task            | Given/When/Then unclear       | STOP and ask caller to clarify             |\n| Phase 3: Test won't run            | Test syntax error             | Fix test code before proceeding            |\n| Phase 3: RED not confirmed         | Test doesn't fail as expected | Verify test logic and implementation       |\n| Phase 3: GREEN not confirmed       | Test doesn't pass             | Verify implementation covers the assertion |\n| Phase 4-7: Test regressions        | Previously-passing test fails | Revert recent changes, fix, re-test        |\n\n## Information Sources for Phase 1\n\nThe agent uses these sources to auto-detect environment:\n\n- Project Memory: `project_overview`, `code_style_conventions`, `suggested_commands`\n- Config Files: `package.json`, `tsconfig.json`, `vitest.config.ts`, `.eslintrc`, etc.\n- File System: Test placement patterns, existing test code, directory structure\n- Symbol Analysis: Existing test patterns, implementation conventions\n\n## Reference: Test Template\n\nFor test implementation details, see: `.claude/agents/.templates/.bdd-coder-unittest-template.md`\n\n---\n\nStrict BDD implementation agent with integrated quality gates and progress tracking via ${bdd-coder:todo-path}.\n",
        "plugins/deckrd-coder/.claude-plugin/plugin.json": "{\n  \"name\": \"deckrd-coder\",\n  \"description\": \"Deckrd task implementation skill - automatically extracts specified tasks from tasks.md and implements them using strict BDD process. Internally executes bdd-coder agent. Optimizes token usage with project memory & serena-mcp.\",\n  \"version\": \"0.0.4\",\n  \"author\": {\n    \"name\": \"atsushifx\",\n    \"email\": \"atsushifx@gmail.com\"\n  },\n  \"license\": \"MIT\"\n}\n",
        "plugins/deckrd-coder/README.md": "---\nname: deckrd-coder\ndescription: BDD厳格プロセスに従ってdeckrdタスクを自動実装するスキル\nmeta:\n  author: atsushifx\n---\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n<!-- textlint-disable ja-technical-writing/max-comma -->\n<!-- markdownlint-disable line-length  -->\n\n# deckrd-coder\n\nA Claude Code skill that automatically implements Deckrd tasks using a strict BDD (Behavior-Driven Development) process, with integrated quality gates and project memory optimization.\n\n## What is deckrd-coder?\n\ndeckrd-coder is a **completely optional companion plugin** that automates the implementation of Deckrd-generated tasks using a strict BDD (Behavior-Driven Development) workflow.\n\n**It works like this:**\n\n1. You complete a Deckrd session and generate `tasks.md`\n2. You invoke `/deckrd-coder <TASK_ID>` to implement a task\n3. deckrd-coder automatically runs the entire Red-Green-Refactor cycle for you\n\n**Why it's optional:** Deckrd itself is a complete planning framework that works independently. deckrd-coder is purely a helper for automating implementation. You can use Deckrd alone to generate tasks, then implement them manually at your own pace—or use deckrd-coder to accelerate the process with BDD-style automation.\n\n**What makes it different:** Rather than writing code first, deckrd-coder ensures each task follows TDD principles:\n\n1. **Red**: Write tests that fail\n2. **Green**: Write minimal code to pass tests\n3. **Refactor**: Clean and optimize\n\nThis guarantees high-quality, fully-tested, traceable changes—with every implementation decision captured and justified.\n\n## Key Features\n\n- BDD Strict Process: Red-Green-Refactor cycle for every task ensures quality\n- Automatic Task Extraction: Extracts task definitions from `tasks.md`\n- 8-Step Workflow: Structured implementation pipeline from quality gates to completion\n- Quality Assurance: Automated testing, linting, and type checking at every stage\n- Token Efficiency: Project memory & serena-mcp integration reduces unnecessary processing\n- Internal bdd-coder Agent: Handles Red-Green-Refactor phases automatically\n- Progress Tracking: TodoWrite integration for detailed step management\n- 1 Message = 1 Task: Maintains focus and code quality (no multi-tasking)\n\n## Prerequisites\n\ndeckrd-coder requires an existing Deckrd workflow and a generated `tasks.md`.\n\n- deckrd must be used first to derive tasks\n- deckrd-coder operates exclusively on tasks defined in `tasks.md`\n- Without deckrd and its derived tasks, deckrd-coder has no standalone use\n\n## Getting Started\n\n### Installation\n\ndeckrd-coder is available as an optional plugin for deckrd users.\n\n```bash\nClaude Code → Settings → Plugins → Enable deckrd\n```\n\nThe skill becomes available in your Deckrd sessions.\n\n## First Use\n\nTo implement a task in your Deckrd session:\n\n```bash\n/deckrd-coder T01-02\n```\n\nWhere `T01-02` is your task ID extracted from `tasks.md`.\n\nThe skill automatically:\n\n1. Validates quality gate commands\n2. Extracts the task definition\n3. Creates implementation subtasks\n4. Runs Red-Green-Refactor cycle (via bdd-coder agent)\n5. Executes quality gates\n6. Records progress and completes\n\n## Troubleshooting\n\n### Skill not found error\n\nIf you get an \"Unknown skill: deckrd\" error when trying to use `/deckrd`:\n\n1. **Check marketplace installation**:\n\n   ```bash\n   ls ~/.claude/plugins/marketplaces/deckrd-tools/\n   ```\n\n2. Verify plugin structure:\n   ls ~/.claude/plugins/marketplaces/deckrd-tools/plugins/deckrd/skills/\n\n3. Manual skill discovery:\n   If the Skill tool doesn't recognize deckrd, search all marketplaces:\n   ls ~/.claude/plugins/marketplaces/\n\n### For each marketplace found\n\nls {marketplace}/plugins/*/skills/\n4. Report to Claude:\nShow Claude the marketplace structure and ask it to use the skill directly from the discovered path.\n\nNote for AI assistants: When a user says \"use agent skill\" or \"use skill\" and the skill is not found via the Skill\ntool, automatically search marketplace directories as shown above before asking the user for guidance.\n\nWhere documents are stored\n\n## Workflow Overview\n\nThe implementation follows a 6-phase workflow:\n\n```nash\nPhase 0: Development Environment Initialization\n    ↓\nPhase 1: Deckrd Session & Task Information Extraction\n    ↓\nPhase 2: Task Breakdown (Fine-grained Subtasks)\n    ↓\nPhase 3: Red-Green-Refactor Implementation (via bdd-coder)\n    ↓\nPhase 4: Quality Gates (Lint, Type Check, Tests)\n    ↓\nPhase 5: Completion Verification\n```\n\n### The 8-Step Implementation Process\n\n1. **Step 1**: Retrieve quality gate commands\n2. **Step 2**: Extract implementation task list\n3. **Step 3-4**: BDD cycle (Red-Green-Refactor)\n4. **Step 5**: Execute quality gates\n5. **Step 6**: Record progress\n6. **Step 7**: Refactor phase (code cleanup)\n7. **Step 8**: Completion check\n\nFor detailed implementation steps, see `IMPLEMENTATION.md` in the skill documentation.\n\n## Important Notes\n\n### ✅ What deckrd-coder Does\n\n- Implements tasks up to completion\n- Runs all tests and quality checks\n- Records changes and progress\n- Updates project memory with implementation details\n\n### ❌ What deckrd-coder Does NOT Do\n\n- Does not commit: Manual git commit required after verification\n- Does not push: Push to remote is user's responsibility\n- Does not support options: `--debug` and `--refresh-memory` are not currently implemented\n\n## Task ID Format\n\nTwo formats are supported:\n\n| Format     | Example     | Notes                         |\n| ---------- | ----------- | ----------------------------- |\n| Section ID | `T01-02`    | **Recommended** (single task) |\n| Detail ID  | `T01-02-01` | Not recommended (task detail) |\n\nUse Section ID format for single task implementation.\n\n## Documentation\n\nComprehensive documentation is included:\n\n- SKILL.md: Command reference and feature overview\n- WORKFLOW.md: 6-phase workflow details\n- IMPLEMENTATION.md: Step-by-step implementation guide\n- TROUBLESHOOTING.md: Error handling and recovery\n- FAQ.md: Common questions and answers\n- bdd-coder.md: Internal agent specification\n\nAll documentation is located in `skills/deckrd-coder/references/`\n\n## Common Patterns\n\n### Single Task Implementation\n\n```bash\n/deckrd-coder T01-02          # Implement task T01-02\n# Wait for completion\n# Verify changes\n# Manual git commit\n```\n\n### Multiple Tasks (Sequential)\n\n```bash\n/deckrd-coder T01-02          # Complete T01-02\n/deckrd-coder T01-03          # Then implement T01-03\n/deckrd-coder T01-04          # Then implement T01-04\n```\n\n> **Important**: Implement one task at a time (1 message = 1 task principle)\n\n## Integration with Deckrd\n\ndeckrd-coder is designed to work seamlessly within Deckrd sessions:\n\n1. Start a Deckrd session with `/deckrd init`\n2. Work through phases to define tasks in `tasks.md`\n3. Use `/deckrd-coder <TASK_ID>` to implement each task\n4. All implementations are automatically tracked in project memory\n\n## License\n\nThe MIT License\nCopyright (C) 2025- aglabo\n",
        "plugins/deckrd-coder/skills/deckrd-coder/README.md": "# deckrd-coder\n\ndeckrd マーケットプレイスの BDD コーディングプラグイン\n\n## 概要\n\nDeckrd ワークフローの tasks.md から指定したタスク（例：`T01-02`）を読み込み、BDD（Behavior-Driven Development）厳格プロセスで実装を自動化するdeckrd専用プラグインです。\n\n## 特徴\n\n- deckrd 前提: deckrd ワークフローと完全統合\n- Red-Green-Refactor 厳密実装: テスト駆動開発の原則を厳守\n- マルチ言語対応: TypeScript/Vitest、Python/pytest など、任意の言語とテストフレームワークに対応\n- TodoWrite 統合: タスク進捗を自動追跡\n- 品質ゲート統合: 型チェック、リント、テスト、ビルドの自動実行\n\n## 使用方法\n\n### 基本構文\n\n```bash\n/deckrd-coder <TASK_ID>\n```\n\n### 実行例\n\n```bash\n/deckrd-coder T01-02\n/deckrd-coder T01-03\n/deckrd-coder T01-10\n```\n\n## 含まれるコンポーネント\n\n### エージェント\n\n- bdd-coder: Red-Green-Refactor サイクルで実装を推進するエージェント\n\n### スキル\n\n- deckrd-coder: deckrd タスク解析と BDD 実装自動化スキル\n\n## インストール\n\nこのプラグインは deckrd マーケットプレイスに組み込まれています。\n\n### Claude Code での利用\n\n```bash\n# deckrd-coder スキルを使用\n/deckrd-coder <TASK_ID>\n```\n\n## 構成\n\n```\ndeckrd-coder/\n├── SKILL.md                 # 実装スキル定義\n├── manifest.json            # プラグインメタデータ\n├── README.md               # このファイル\n├── assets/                 # アセット（テンプレートなど）\n├── references/             # リファレンスドキュメント\n└── scripts/                # ユーティリティスクリプト\n```\n\n## 実行フェーズ\n\nスキル内で以下のフェーズを自動管理：\n\n1. **Phase 1**: セッション・タスク情報取得\n   - deckrd session.json からアクティブセッション確認\n   - tasks.md から指定タスク ID のテストケース一覧を抽出\n\n2. **Phase 2**: プロジェクト情報・コード規約参照\n   - code_style_conventions.md で命名規約・ファイル配置ルール確認\n   - project_overview.md で技術スタック・プロジェクト構造確認\n\n3. **Phase 3**: Red-Green-Refactor サイクル実装（各テストケースごとに繰り返し）\n   - [Red] テストを書く\n   - テスト失敗確認（エラーメッセージを確認）\n   - [Green] 最小限の実装追加\n   - テスト成功確認\n   - [Refactor] 必要に応じてコード整理\n   - Todo を更新\n   - 次のテストケースへ\n\n4. **Phase 4**: 品質保証チェック実行\n   - ユニットテスト実行\n   - シークレット検出\n   - 型チェック\n   - コード整形確認\n\n5. **Phase 5**: 実装完了\n   - 全テスト PASS、型エラーなし確認\n   - tasks.md の該当タスクをチェック\n   - コミットは実行しない（ユーザーが手動で実施）\n\n## 関連リソース\n\n- [deckrd マーケットプレイス](https://github.com/atsushifx/deckrd)\n- [親プロジェクト: aglabo-command-runner](https://github.com/atsushifx/aglabo-command-runner)\n\n## ライセンス\n\nMIT License - Copyright (c) 2025 atsushifx\n\n## サポート\n\n問題報告や機能リクエストは以下をご利用ください：\n\n- GitHub Issues: https://github.com/atsushifx/deckrd/issues\n",
        "plugins/deckrd-coder/skills/deckrd-coder/SKILL.md": "---\nname: deckrd-coder\ndescription: An agent that codes tasks in BDD-style. Automatically does not commit.\nallowed-tools: Task, Bash, Read, Grep, Glob\nlicense: MIT\nmeta:\n  author: atsushifx\n  version: 0.0.4\n---\n\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n\n# /deckrd-coder スキル - Deckrd タスク実装ガイド\n\n**このスキルは、Deckrd セッションで定義されたタスクを BDD 厳格プロセスに従って実装します。**\n\n---\n\n## ⚠️ 重要事項\n\n### コミット除外\n\nこのスキルは **実装まで行いますが、コミットはしません**。実装後のコミットはユーザーが手動で実施してください。\n\n```bash\n(NG) git add .\n(NG) git commit -m \"...\"\n(NG) /idd-pr  # PR 生成も禁止\n```\n\n### テスト・品質ゲート必須\n\n- 実装終了時点で、すべてのテストが PASS\n- Lint・型チェック・その他の品質ゲートが合格\n\n---\n\n## 概要\n\n### What (何をするのか)\n\nDeckrd セッションで定義されたタスクを、**BDD (Behavior-Driven Development) の厳格プロセス** に従って実装します。\n**1つのスキル呼び出し = 1つのタスク実装** という原則を厳守します。\n\n### Why (なぜこの方法を使うのか)\n\n- 品質保証: Red-Green-Refactor サイクルで高品質なコードを実現\n- 追跡可能性: 各ステップが記録され、何をいつなぜ実装したかが明確\n- トークン効率化: プロジェクトメモリ & serena-mcp により不要な説明を削減\n\n### How (どのように実装するのか)\n\n8 つのステップ (Step 1～8) で構成される実装フロー:\n\n1. **Step 1**: 品質ゲート用コマンド取得\n2. **Step 2**: 実装タスクリスト取得\n3. **Step 3-4**: BDD サイクル (Red-Green-Refactor)\n4. **Step 5**: 品質ゲート実行 (全体検証)\n5. **Step 6**: 進捗記録\n6. **Step 7**: Refactor フェーズ (全体コード整理)\n7. **Step 8**: 完了判定\n\n詳細は [IMPLEMENTATION.md](./references/implementation.md) を参照。\n\n---\n\n## 基本的な使い方\n\n### コマンド形式\n\n```bash\n# 単一タスク実装 (推奨)\n/deckrd-coder T01-02\n```\n\n> 注意\n>\n> オプションは現在のところ実装していません。\n\n### Task ID 指定形式\n\n| ID 形式       | 例          | 説明                              |\n| ------------- | ----------- | --------------------------------- |\n| セクション ID | `T01-02`    | **推奨** (単一テストケース対応)   |\n| 詳細 ID       | `T01-02-01` | **非推奨** (テストケース詳細指定) |\n\n> 注意\n>\n> 複数タスク指定は非推奨 (1 message = 1 task の原則)\n\n詳細な使用方法とよくある質問は [FAQ.md](./references/faq.md) を参照。\n\n---\n\n## 全体的な戦略\n\n### 6 つの Phase で構成\n\n```bash\nPhase 0: 開発環境の初期化\n    ↓\nPhase 1: deckrd セッション・タスク情報の取得\n    ↓\nPhase 2: 実装タスクリスト (細分化) の作成\n    ↓\nPhase 3: Red-Green-Refactor による実装\n    ↓\nPhase 4: 品質ゲート (Lint・型チェック・テスト) の実行\n    ↓\nPhase 5: 完了確認\n```\n\n### 各 Phase の概要\n\n| Phase | 役割         | 詳細                                         |\n| ----- | ------------ | -------------------------------------------- |\n| 0     | 開発環境確認 | Node.js、npm、テストフレームワークなどの確認 |\n| 1     | 情報取得     | セッション・タスク定義から実装内容を抽出     |\n| 2     | タスク細分化 | 実装タスクを小さなステップに分割             |\n| 3     | BDD 実装     | Red-Green-Refactor サイクルで実装            |\n| 4     | 品質ゲート   | Lint・型チェック・テスト実行                 |\n| 5     | 完了確認     | すべての条件が満たされたか確認               |\n\n詳細は [WORKFLOW.md](./references/workflow.md) を参照してください。\n\n---\n\n## リファレンス\n\n### 参照ドキュメント一覧\n\nこのスキルは以下のドキュメントを厳密に参照・遵守します。\n\n#### 1. [WORKFLOW.md](./references/workflow.md)\n\n**対象**: Phase 0～5 の全体フロー\n**用途**: スキル実行前に全体を理解したいとき。\n\n#### 2. [IMPLEMENTATION.md](./references/implementation.md)\n\n**対象**: Step 1～8 の詳細手順\n**用途**: 実装中に困ったとき、エラーが発生したとき。\n\n**主要な原則**:\n\n- 1 message = 1 test: 複数タスクは実装しない\n- Step 順序の厳密性: ステップをスキップしない\n- 最小実装の遵守: Green フェーズは過剰実装を禁止\n- 品質ゲート必須: Step 5 は必ず実行、失敗時は 3 回まで対応\n\n#### 3. [TROUBLESHOOTING.md](./references/troubleshooting.md)\n\n**対象**: WORKFLOW・IMPLEMENTATION から逸脱した場合の対応\n**用途**: エラー発生時、フロー判定に迷ったとき。\n\n#### 4. [FAQ.md](./references/faq.md)\n\n**対象**: よくある質問と回答\n**用途**: 実装方法の詳細、Q&A 確認。\n\n---\n\n### 内部エージェント: bdd-coder\n\n**位置**: `plugins/deckrd-coder/agents/bdd-coder.md`\n\n**役割**: このスキルの **Step 3** で自動起動され、以下を担当:\n\n- Red フェーズ: テスト実装 → テスト失敗確認\n- Green フェーズ: 最小実装 → テスト合格確認\n- Refactor フェーズ: 軽微な整理 (ユーザー相談なし)\n- 品質ゲート確認: Lint・型チェック合格確認\n\n詳細は `plugins/deckrd-coder/agents/bdd-coder.md` を参照。\n\n---\n\n## トークン効率化メカニズム\n\n### 1. プロジェクトメモリ活用\n\nスキル実行時に以下のメモリを自動参照:\n\n- `code_style_and_conventions`: コーディング規約\n- `project_overview`: プロジェクト概要\n- `project_structure`: プロジェクト構成\n- `suggested_commands`: 実行コマンド\n\n### 2. serena-mcp による高速検索\n\n- シンボル検索、型情報取得を効率化\n- 不要なファイル全文読み込みを削減\n\n### 3. bdd-coder エージェント\n\n- 親スキルは高レベル指示のみ\n- bdd-coder が TodoWrite で詳細な進捗管理\n- コンテキスト分割によるメモリ削減\n\n---\n\n## 変更履歴\n\n<!-- textlint-disable -->\n\n- v0.0.1: 初版\n- v0.0.2: workflow.md, implementation.md, troubleshooting.md, bdd-coder.md への参照を明示し、ユーザーおよびエージェント AI 向けの包括的ガイドに改定\n",
        "plugins/deckrd-coder/skills/deckrd-coder/references/faq.md": "---\ntitle: FAQ - /deckrd-coder スキル よくある質問\n---\n\n<!--textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n\n## Q1: 複数タスクを同時に実装できる？\n\n**A**: **いいえ。1 message = 1 task が原則です。**\n\n```bash\n(NG) /deckrd-coder T01-02 T01-03 T01-04\n\n(OK) /deckrd-coder T01-02          # 完了待ち\n(OK) /deckrd-coder T01-03          # 完了待ち\n(OK) /deckrd-coder T01-04          # 完了待ち\n```\n\n複数タスクを同時指定するとメモリ制約により品質が低下します。\n\n---\n\n## Q2: 実装完了後、コミットしてもいい？\n\n**A**: **いいえ。コミットはユーザーが手動で実施してください。**\n\n実装が完了したら、ユーザーが以下を確認したうえで手動コミット:\n\n- テストが PASS\n- Lint・型チェック合格\n- コード品質\n\nこのスキルは **実装までしか行いません**。\n\n---\n\n## Q3: Green フェーズで複数メンバー定義できる？\n\n**A**: **いいえ。テスト合格に必要な最小限のみです。**\n\n```typescript\n// 悪い例\nenum Status {\n  ACTIVE, // 次のテストで必要\n  INACTIVE, // さらに次のテストで必要\n  PENDING,\n}\n\n// 良い例 (Task 1 の場合)\nenum Status {\n  ACTIVE, // Task 1 のテストのみ必須\n}\n```\n\n過剰実装は Refactor フェーズで統合的に改善。詳細は [IMPLEMENTATION.md](./implementation.md#step-3-最小実装) を参照。\n\n---\n\n## Q4: Step 5 で品質ゲート失敗した。どこへ戻る？\n\n**A**: エラーの種類で判定:\n\n| エラー                | 戻り先         | 詳細                             |\n| --------------------- | -------------- | -------------------------------- |\n| Lint 失敗 (様式違反)  | Step 5 再実行  | TROUBLESHOOTING.md「逸脱 6」参照 |\n| 型チェック失敗        | Step 5 再実行  | TROUBLESHOOTING.md「逸脱 6」参照 |\n| テスト失敗 (実装バグ) | Step 3 へ戻る  | IMPLEMENTATION.md「Step 3」参照  |\n| 3 回以上失敗          | ユーザーに相談 | TROUBLESHOOTING.md 全体参照      |\n\n詳細は [TROUBLESHOOTING.md](./troubleshooting.md#逸脱-6-step-5-での失敗対応の混乱) の「逸脱 6: Step 5 での失敗対応の混乱」参照。\n\n---\n\n## Q5: Task ID の指定形式は？\n\n**A**: 以下の 2 形式が使用可能:\n\n| ID 形式       | 例          | 説明                              |\n| ------------- | ----------- | --------------------------------- |\n| セクション ID | `T01-02`    | **推奨** (単一テストケース対応)   |\n| 詳細 ID       | `T01-02-01` | **非推奨** (テストケース詳細指定) |\n\n通常はセクション ID での指定を推奨します。\n\n---\n\n## Q6: bdd-coder エージェントは何をするの？\n\n**A**: このスキルの **Step 3** (単一タスクの実装) で自動起動:\n\n- Red フェーズ: テスト実装 → テスト失敗確認\n- Green フェーズ: 最小実装 → テスト合格確認\n- Refactor フェーズ: 軽微な整理 (ユーザー相談なし)\n- 品質ゲート確認: Lint・型チェック合格確認\n- 進捗管理: TodoWrite で詳細ステップ管理\n\n詳細は [bdd-coder.md](../agents/bdd-coder.md) を参照。\n\n---\n\n## Q7: 品質ゲートコマンドは何？\n\n**A**: Lint、型チェック、テストを実行するコマンド:\n\n- Lint: `npm run lint`（例）\n- 型チェック: `npm run type-check`（例）\n- テスト: `npm test`（例）\n\nプロジェクトメモリ `suggested_commands` から自動取得されます。詳細は [IMPLEMENTATION.md](./implementation.md#step-1-品質ゲートコマンド取得) を参照。\n\n---\n\n## Q8: 3 回以上品質ゲート失敗したらどうする？\n\n**A**: ユーザーに相談し、以下の対応を検討:\n\n1. **ロールバック**: 現在の実装をクリアし、別のアプローチで再開\n2. **マニュアル修正**: ユーザーが手動でコード修正\n3. **ステップの見直し**: 実装タスクリストを再細分化\n\n詳細は [TROUBLESHOOTING.md](./troubleshooting.md) の「品質ゲート失敗への対応」参照。\n\n---\n\n## さらに詳しく\n\n| 質問内容             | 参照ドキュメント                           |\n| -------------------- | ------------------------------------------ |\n| スキルの全体フロー   | [WORKFLOW.md](./workflow.md)               |\n| 実装ステップの詳細   | [IMPLEMENTATION.md](./implementation.md)   |\n| 問題発生時の対応     | [TROUBLESHOOTING.md](./troubleshooting.md) |\n| bdd-coder の詳細仕様 | [bdd-coder.md](../agents/bdd-coder.md)     |\n",
        "plugins/deckrd-coder/skills/deckrd-coder/references/implementation.md": "---\ntitle: IMPLEMENTATION - 厳格な実装フロー\n---\n\n## IMPLEMENTATION - 厳格な実装フロー\n\n## 全体フロー概要\n\nBDD 実装は以下の 8 ステップで構成されます。各ステップは順序通り実行し、スキップ不可。\n\n```text\nStep 1: 品質ゲート用コマンド取得\n    ↓\nStep 2: 実装タスクリスト取得\n    ↓\nStep 3-4: BDD サイクル (タスク完了まで繰り返し)\n    ├─ Step 3: deckrd-bdd-coder で単一タスク実装\n    └─ Step 4: 繰り返し判定\n    ↓\nStep 5: 品質ゲート実行 (Lint + 型チェック)\n    ↓\nStep 6: タスクリスト更新\n    ↓\nStep 7: Refactor フェーズ\n    ↓\nStep 8: 完了判定\n```\n\n---\n\n## 詳細ステップ\n\n### ステップ 1: 品質ゲート用のコマンドを取得する\n\n目的: プロジェクト固有の品質ゲートコマンドを事前に取得。\n\n実行内容:\n\n1. `package.json` / `setup.py` / `Cargo.toml` などをもとに、以下のコマンドを取得\n   - Lint チェック: `npm run lint` / `python -m flake8` など\n   - 型チェック: `tsc --noEmit` / `mypy` / `pyright` など\n   - テスト実行: `npm run test` / `pytest` など\n2. 各コマンドが実行可能であることを確認\n3. 取得したコマンドを後続ステップで使用するため記録\n\nチェックリスト:\n\n- [ ] Lint コマンド確認\n- [ ] 型チェックコマンド確認\n- [ ] テスト実行コマンド確認\n\n---\n\n### ステップ 2: パラメータをもとに実装タスクリストを取得する\n\n目的: ユーザーの要件から実装タスクを細分化・リスト化。\n\n実行内容:\n\n1. ユーザーから受け取ったパラメータ (要件、仕様など) を分析\n2. 要件を単一テストケース単位のタスクに分割\n3. 各タスクの依存関係を把握\n4. **実装タスクリスト** を作成\n\n実装タスクリスト例:\n\n```markdown\n- [ ] Task 1: 入力値が有効な場合、結果 A を返す (正常系)\n- [ ] Task 2: 入力値が null の場合、エラーを返す (異常系)\n- [ ] Task 3: 入力値が空文字列の場合、デフォルト値を返す (エッジケース)\n```\n\nチェックリスト:\n\n- [ ] タスクが十分に細分化されている (1 test = 1 task の原則)\n- [ ] 各タスクは独立している\n- [ ] 依存関係が明確\n\n---\n\n### ステップ 3: 実装タスクリストからタスクを 1 つ取りだし、deckrd-bdd-coder で実装する\n\n目的: 単一タスクに対して BDD 厳格プロセスで実装。\n\n実行内容:\n\n1. 実装タスクリストから **最初の未実装タスク** を取り出す\n2. **deckrd-bdd-coder エージェント** を起動\n   - パラメータ: 対象タスクの詳細説明\n   - エージェントが Red-Green-Refactor サイクルを自動実行\n3. deckrd-bdd-coder は以下を保証\n   - Red フェーズ: テスト実装 → テスト失敗確認\n   - Green フェーズ: 最小実装 → テスト合格確認\n   - Refactor フェーズ: 軽微な整理 (この段階ではユーザー相談なし)\n   - 品質ゲート確認: Lint・型チェックで合格確認\n\n重要な制約:\n\n- deckrd-bdd-coder は **1 つのタスク専用** (複数タスク並行実行禁止)\n- deckrd-bdd-coder の処理完了条件: **品質ゲート合格**\n- deckrd-bdd-coder でエラー 3 回以上の場合、ロールバック・ユーザー相談\n\nチェックリスト:\n\n- [ ] deckrd-bdd-coder が起動された\n- [ ] Red フェーズが完了 (テスト失敗確認)\n- [ ] Green フェーズが完了 (テスト合格確認)\n- [ ] Refactor (軽微) が完了\n- [ ] 品質ゲート合格確認\n\n---\n\n### ステップ 4: 実装タスクリストがなくなるまで、ステップ 3 を繰り返す\n\n目的: すべてのタスクを実装完了。\n\n実行内容:\n\n1. 実装タスクリストを確認\n2. 未実装タスクが存在するか判定\n   - YES: ステップ 3 に戻る (次のタスクを実装)\n   - NO: ステップ 5 へ進む\n\nチェックリスト:\n\n- [ ] すべてのタスクが `completed` 状態\n- [ ] 未実装タスクなし\n\n---\n\n### ステップ 5: 品質ゲートを実行する (全体検証)\n\n目的: 全体コードの品質を検証。\n\n実行内容:\n\n1. ステップ 1 で取得したコマンドを実行\n   - Lint チェック: `npm run lint` など\n   - 型チェック: `tsc --noEmit` など\n2. 各チェックの結果を確認\n3. 失敗時の対応:\n   - エラーの種類・箇所を特定\n   - 対応方法を検討・修正\n   - 修正後、Step 5 を再実行\n   - 必要に応じて Step 7 (Refactor フェーズ) へ戻る\n   - 3 回以上失敗時: ユーザーに相談\n\nチェックリスト:\n\n- [ ] Lint チェック: 合格\n- [ ] 型チェック: 合格\n- [ ] テスト実行: すべてのテストがグリーン\n- [ ] 品質ゲート: 全体合格\n\n---\n\n### ステップ 6: 状態確定と進捗記録\n\n目的: 実装状況を明確に記録。\n\n状態確定とは、タスク完了の事実を確認し (実装済みタスクをチェック)、TodoWrite で同期し、次タスクに進んでよい状態であることを明示するフェーズです。\n\n実行内容:\n\n1. 実装タスクリストを確認\n2. **各完了タスク** に対して `[x]` (チェック済み) に更新\n3. TodoWrite で進捗を同期\n\n更新例:\n\n```markdown\n- [x] Task 1: 入力値が有効な場合、結果 A を返す (正常系)\n- [x] Task 2: 入力値が null の場合、エラーを返す (異常系)\n- [x] Task 3: 入力値が空文字列の場合、デフォルト値を返す (エッジケース)\n```\n\nチェックリスト:\n\n- [ ] すべての完了タスクがチェック済み\n- [ ] TodoWrite に反映済み\n\n---\n\n### ステップ 7: Refactor フェーズ (全体コード整理)\n\n目的: テストコード・実装コードの読みやすさと簡潔性を向上。\n\n実行内容:\n\n1. **テストコードの整理**\n   - テスト仕様化 (it.each など) による簡潔化\n   - 重複テストの統合\n   - テスト内の変数名・構造改善\n\n2. **実装コードの整理**\n   - 重複ロジックの関数抽出\n   - 変数名・関数名の改善\n   - 不要なコードの削除\n   - 読みやすさと簡潔性のバランス最適化\n\n3. **ユーザーとのやりとり**\n   - リファクタリング案を提示\n   - ユーザーの承認を得る\n   - ユーザーの要望に応じて修正\n\n4. **検証**\n   - リファクタリング後、すべてのテストが合格することを確認\n   - 品質ゲートが合格することを確認\n\nチェックリスト:\n\n- [ ] テストコードが簡潔化\n- [ ] 実装コードが読みやすい\n- [ ] 重複が排除されている\n- [ ] すべてのテストがグリーン\n- [ ] 品質ゲート合格\n\n---\n\n### ステップ 8: 完了判定\n\n目的: 実装が完了したことを確認。\n\n実行内容:\n以下の条件をすべて満たしているか確認:\n\n1. **テスト完了**\n   - すべてのテストケースが実装済み\n   - すべてのテストがグリーン状態\n\n2. **品質ゲート合格**\n   - Lint チェック: 合格\n   - 型チェック: 合格\n   - その他プロジェクト固有のチェック: すべて合格\n\n3. **Refactor 完了**\n   - テストコード・実装コードの整理が完了\n   - ユーザーが内容に承認\n\n完了条件チェック:\n\n- [ ] すべてのテストが `passed` 状態\n- [ ] Lint チェック合格\n- [ ] 型チェック合格\n- [ ] テストコード Refactor 完了\n- [ ] 実装コード Refactor 完了\n- [ ] ユーザー承認取得\n\n判定結果:\n\n- YES: 実装完了 → プロセス終了\n- NO: ステップ 7 へ戻り、不足部分をリファクタリング\n\n---\n\n## 核心原則 (まとめ)\n\n1. ステップ順序の厳密性: 1→2→3→4→5→6→7→8 の順序でスキップ不可\n2. 単一タスク原則: deckrd-bdd-coder は 1 タスク専用 (並行実行禁止)\n3. 最小実装の遵守: Green フェーズは過剰実装禁止\n4. 品質ゲート必須: ステップ 5 実施は必須 (3回以上失敗時、ユーザーに相談)\n5. Refactor の不可欠性: ステップ 7 でコード品質を統合的に改善\n6. 完了条件の明確性: ステップ 8 のすべてのチェック項目を満たす必要あり\n",
        "plugins/deckrd-coder/skills/deckrd-coder/references/troubleshooting.md": "---\ntitle: TROUBLESHOOTING - フロー逸脱時の対応ガイド\n---\n\n<!-- textlint-disable ja-technical-writing/no-mix-dearu-desumasu -->\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n<!-- markdownlint-disable line-length no-duplicate-heading -->\n\n## TROUBLESHOOTING - フロー逸脱時の対応ガイド\n\n本ドキュメントは、`workflow.md` および `implementation.md` で定義されたフローから逸脱する場合の代表例と、それに対する具体的な対応を記述しています。\n\n---\n\n## WORKFLOW フロー逸脱時の対応\n\n### 逸脱 1: Phase 0 (開発環境把握) のスキップ\n\n#### 症状\n\n- 開発言語やツール設定を確認せずにコーディング開始\n- コマンド実行エラーが多発する\n- 環境依存のバグが後から発覚\n\n#### 原因\n\n- リポジトリルート・サブパッケージルートの特定漏れ\n- `package.json`、`Cargo.toml`、`setup.py` などの確認忘れ\n- Lint、型チェック、テストコマンドの事前調査不足\n\n#### 対応\n\n1. **即座に Phase 0 へ戻る**\n   - リポジトリルートを確認: `pwd` / `ls -la`\n   - 開発言語を確認: `cat package.json` | `cat Cargo.toml` など\n   - 利用ツール一覧を記録: 開発環境のドキュメント確認\n\n2. **実行コマンドを記録**\n\n   ```bash\n   # 例: Node.js プロジェクト\n   npm run lint          # Lint チェック\n   npm run check:types   # 型チェック\n   npm run test          # テスト実行\n\n   # 例: Python プロジェクト\n   python -m flake8      # Lint\n   mypy .                # 型チェック\n   pytest                # テスト\n   ```\n\n3. **コマンド実行テスト**\n   - 各コマンドが正常に実行されることを確認\n   - ヘルプオプション確認: `npm run lint --help` など\n\n4. **Phase 1 に進む**\n\n---\n\n### 逸脱 2: Phase 1 (アクティブタスク取得) の不完全実行\n\n#### 症状\n\n- `.session.json` の `active` フィールドが未設定\n- タスク ID が不明確\n- テストケース一覧が取得できない\n\n#### 原因\n\n- `docs/.deckrd/.session.json` ファイルが存在しない\n- Session JSON のフォーマットエラー\n- アクティブセッション情報が古い\n\n#### 対応\n\n1. **Session JSON ファイルの確認**\n\n   ```bash\n   # ファイル存在確認\n   ls -la docs/.deckrd/.session.json\n\n   # 内容確認\n   cat docs/.deckrd/.session.json | jq .\n   ```\n\n2. **Session JSON が存在しない場合**\n\n   ```bash\n   # Deckrd セッション初期化\n   deckrd init\n\n   # アクティブセッションを設定\n   deckrd session set --active <TASK_ID>\n   ```\n\n3. **Session JSON が存在するが形式が不正な場合**\n   - ファイルを削除して再初期化\n   - JSON バリデーター使用: `jq . docs/.deckrd/.session.json`\n\n4. **アクティブタスク情報が古い場合**\n   - セッション情報を最新化: `deckrd session refresh`\n   - または新規セッション作成: `deckrd session create <TASK_ID>`\n\n5. **Phase 2 に進む**\n\n---\n\n### 逸脱 3: Phase 2 (実装タスクリスト作成) の細分化不足\n\n#### 症状\n\n- タスクが粗すぎて「1 message = 1 test」原則が守れない\n- 複数テストを同時実装してしまう\n- タスク間の依存関係が不明確\n\n#### 原因\n\n- ユーザー要件を十分に分析していない\n- テストケースごとの分割が不十分\n- 依存関係マッピングの遺漏\n\n#### 対応\n\n1. **タスク細分化を再実施**\n\n   ```markdown\n   # 悪い例\n\n   - [ ] Task: ユーザー認証機能を実装\n\n   # 良い例\n\n   - [ ] Task 1: 入力値が有効な場合、ユーザーを認証 (正常系)\n   - [ ] Task 2: パスワード不正な場合、エラーを返す (異常系)\n   - [ ] Task 3: ユーザーが存在しない場合、デフォルト処理 (エッジケース)\n   ```\n\n2. **各タスクの独立性を確認**\n   - 各タスクが単一テストケース対応であることを確認\n   - タスク A の成否がタスク B に影響しないことを確認\n\n3. **依存関係マッピングを作成**\n\n   ```markdown\n   Task 1 (基本認証)\n   ↓\n   Task 2 (エラーハンドリング)\n   ↓\n   Task 3 (追加検証)\n   ```\n\n4. **Phase 3 に戻る**\n\n---\n\n### 逸脱 4: Phase 3 (コーディング実行) 中の品質ゲート忘却\n\n#### 症状\n\n- テストは通るが、Lint・型チェックでエラー多発\n- ユーザーが修正依頼を出す\n- ワークフローが巻き戻される\n\n#### 原因\n\n- Step 5 (品質ゲート実行) の重要性を過小評価\n- 個別タスク終了時に品質ゲート確認の仕組みがない\n- deckrd-bdd-coder のエラー通知を見落とし\n\n#### 対応\n\n1. **各タスク終了時に品質ゲート実行を必須化**\n   - deckrd-bdd-coder は品質ゲート合格を処理完了条件とする\n   - Lint チェック: `npm run lint` など\n   - 型チェック: `npm run check:types` など\n\n2. **品質ゲート失敗時の対応**\n   - エラー内容を分析\n   - 修正コード作成\n   - 再度品質ゲート実行\n   - **3 回以上失敗時: ロールバックしてユーザーに相談**\n\n3. **Phase 4 へ進む前に全体品質ゲート確認**\n   - すべてのタスクが品質ゲート合格していることを確認\n\n---\n\n### 逸脱 5: Phase 4 (品質ゲート実行) での失敗対応の混乱\n\n#### 症状\n\n- 品質ゲートが失敗したまま放置\n- 対応方法が不明確\n- Step 5 と Step 7 の処理が区別できていない\n\n#### 原因\n\n- Phase 4 と Step 5 の役割区分が不明確\n- 個別エラーの対応方法が体系化されていない\n- エラー 3 回以上時のユーザー相談の判断基準が曖昧\n\n#### 対応\n\n1. **Phase 4 (全体品質ゲート) での失敗時フロー**\n\n   ```bash\n   品質ゲート実行\n     ↓\n   Lint 失敗\n     → コードの様式違反を修正\n     → Lint 再実行\n     → 失敗カウント +1\n\n   型チェック失敗\n     → 型定義を確認\n     → インポート・型注釈を修正\n     → 型チェック再実行\n     → 失敗カウント +1\n\n   テスト失敗\n     → テストの失敗原因を分析\n     → 実装コード・テストコードを修正\n     → テスト再実行\n     → 失敗カウント +1\n\n   失敗カウント ≥ 3\n     → Step 7 (Refactor) へ戻って全体見直し\n     → または ユーザーに相談\n   ```\n\n2. **エラー別の具体的対応**\n\n   | エラー種別     | 原因例                         | 対応                                   |\n   | -------------- | ------------------------------ | -------------------------------------- |\n   | Lint 失敗      | セミコロン漏れ、インデント不正 | `.eslintrc.json` 確認後、該当行修正    |\n   | 型チェック失敗 | 型注釈不正、any の多用         | `tsconfig.json` 確認後、型定義を厳格化 |\n   | テスト失敗     | ロジックバグ、テスト条件不正   | デバッグログ追加後、ロジック修正       |\n\n3. **Phase 5 へ進む条件**\n   - Lint チェック: **合格**\n   - 型チェック: **合格**\n   - テスト: **すべてグリーン**\n\n---\n\n### 逸脱 6: Phase 5 (完了確認) のスキップ\n\n#### 症状\n\n- 実装が完了していないまま次ステップに進む\n- 後から漏れたテストケースが発見される\n- ユーザーが再度修正依頼を出す\n\n#### 原因\n\n- 実装タスクリストの確認不足\n- すべてのテストが通ったことの検証漏れ\n- Refactor フェーズの実施確認不足\n\n#### 対応\n\n1. **実装タスクリストを確認**\n\n   ```markdown\n   - [x] Task 1: ... (実装済み、テスト合格)\n   - [x] Task 2: ... (実装済み、テスト合格)\n   - [x] Task 3: ... (実装済み、テスト合格)\n\n   ✓ すべてチェック済みを確認\n   ```\n\n2. **全テスト実行**\n\n   ```bash\n   npm run test\n\n   # 結果確認\n   # 合格テスト数 = 予期する総テスト数？\n   ```\n\n3. **Refactor 完了確認**\n   - Step 7 で全体コード整理が完了しているか確認\n   - ユーザーが Refactor 内容に承認しているか確認\n\n4. **Phase 6 へ進む**\n\n---\n\n## IMPLEMENTATION ステップ逸脱時の対応\n\n### 逸脱 1: Step 1 (品質ゲートコマンド取得) のスキップ\n\n#### 症状\n\n- 品質ゲートコマンドが不明確のままコーディング開始\n- Step 5 で実行するコマンドが見当たらない\n- 環境固有のコマンド引数を見落とし\n\n#### 原因\n\n- `package.json`、設定ファイルの確認が不十分\n- プロジェクト固有の build スクリプトの認識漏れ\n- 開発ツールのバージョン確認不足\n\n#### 対応\n\n1. **プロジェクト設定を確認**\n\n   ```bash\n   # Node.js の場合\n   cat package.json | jq '.scripts'\n\n   # Python の場合\n   cat setup.py | grep -A5 \"test_suite\"\n\n   # Rust の場合\n   cat Cargo.toml | grep -A5 \"\\[package\\]\"\n   ```\n\n2. **各ツールのコマンド確認**\n\n   ```bash\n   # Lint コマンド\n   npm run lint --help\n\n   # 型チェックコマンド\n   npm run check:types --help\n\n   # テストコマンド\n   npm run test --help\n   ```\n\n3. **コマンド実行可能性テスト**\n\n   ```bash\n   # 各コマンドを実際に実行\n   npm run lint\n   npm run check:types\n   npm run test\n\n   # 出力形式・成否フラグを記録\n   ```\n\n4. **Step 2 に進む**\n\n---\n\n### 逸脱 2: Step 2 (実装タスクリスト作成) の不完全実行\n\n#### 症状\n\n- タスク粒度が大きすぎる\n- 複数テストが 1 タスクに混在\n- タスク間の依存関係が明確でない\n\n#### 原因\n\n- 要件分析が浅い\n- テストケースの列挙が不十分\n- Given-When-Then の詳細化がない\n\n#### 対応\n\n1. **要件を詳細に分析**\n   - 正常系、異常系、エッジケースを列挙\n   - 各ケースに対応するテストケースを定義\n\n   ```markdown\n   # 例: 電子メールバリデーション機能\n\n   ## 正常系\n\n   - Task 1: 有効なメールアドレスでテスト成功\n\n   ## 異常系\n\n   - Task 2: @記号がない場合、エラー返却\n   - Task 3: ドメイン部分がない場合、エラー返却\n\n   ## エッジケース\n\n   - Task 4: 空文字列でテスト失敗\n   - Task 5: スペース含む場合、エラー返却\n   ```\n\n2. **各タスク内で Given-When-Then を詳細化**\n\n   ```markdown\n   - Task 1:\n     - Given: ユーザーが \"user@example.com\" を入力\n     - When: バリデーション実行\n     - Then: 結果が true\n   ```\n\n3. **タスク間の依存関係を明確化**\n\n   ```markdown\n   Task 1 (正常系) ← 最初に実装\n   ↓\n   Task 2, 3, 4 (異常系・エッジケース) ← 次に実装\n   ```\n\n4. **Step 3 に進む**\n\n---\n\n### 逸脱 3: Step 3 (BDD 実装) での複数タスク並行実装\n\n#### 症状\n\n- deckrd-bdd-coder に複数タスクを同時指示\n- 処理が混乱し、実装品質が低下\n- テストケース間の影響関係が発生\n\n#### 原因\n\n- **1 message = 1 task** 原則の理解不足\n- メモリ制約を過小評価\n- 処理効率を優先して規則を破る\n\n#### 対応\n\n1. **厳格に 1 タスク = 1 メッセージとする**\n\n   ```bash\n   # 悪い例\n   /coding T01-02 T01-03 T01-04\n\n   # 良い例\n   /coding T01-02          # 1 メッセージ\n   # 完了待ち\n   /coding T01-03          # 次のメッセージ\n   # 完了待ち\n   /coding T01-04          # 次のメッセージ\n   ```\n\n2. **deckrd-bdd-coder のエラー対応**\n   - 実装中にエラーが発生した場合、即座にロールバック\n   - エラー内容をユーザーに報告\n   - **エラー 3 回以上時: ユーザー相談 (巻き戻し判定)**\n\n3. **Step 4 (繰り返し判定) に進む**\n\n---\n\n### 逸脱 4: Step 3 (BDD 実装) での Green フェーズ過剰実装\n\n#### 症状\n\n- テスト合格に不要な実装が追加される\n- Refactor フェーズの負担が増加\n- コード品質が低下\n\n#### 原因\n\n- Green フェーズの目的 (最小実装) の理解不足\n- 将来性を考慮した実装をしてしまう\n- テストコード曖昧性による過実装\n\n#### 対応\n\n1. **Green フェーズの制約を厳格化**\n\n   ```typescript\n   // 悪い例: 複数の結果値を実装\n   function validate(email: string): boolean {\n     if (!email.includes('@')) { return false; }\n     if (!email.includes('.')) { return false; // 次のテストで必要\n      }\n     if (email.length < 5) { return false; // さらに次のテストで必要\n      }\n     return true;\n   }\n\n   // 良い例: 現在のテストのみ実装\n   // Task 1: 有効なメールアドレスでテスト成功\n   function validate(email: string): boolean {\n     return true; // テストが要求する最小限\n   }\n\n   // Task 2: @記号がない場合、エラー返却\n   function validate(email: string): boolean {\n     return email.includes('@'); // このテストのみ対応\n   }\n   ```\n\n2. **テストケースを明確に定義**\n   - 各タスクのテストケースが 1 つであることを確認\n   - テスト内容が曖昧でないことを確認\n\n3. **Refactor フェーズで統合的に改善**\n   - Green で実装した複数ステップを統合\n   - 重複ロジックを関数抽出\n\n4. **Step 4 に進む**\n\n---\n\n### 逸脱 5: Step 4 (繰り返し判定) の判断ミス\n\n#### 症状\n\n- 未実装タスクが残ったまま Step 5 へ進む\n- 逆に、完了済みタスクが残っていると誤認して Step 3 へ戻る\n- ループから抜け出せない\n\n#### 原因\n\n- 実装タスクリストのチェック状況確認が不十分\n- タスク完了条件が曖昧\n\n#### 対応\n\n1. **実装タスクリストを明確に確認**\n\n   ```markdown\n   # チェック状況を一覧表示\n\n   - [x] Task 1: ... (テスト合格、品質ゲート合格)\n   - [x] Task 2: ... (テスト合格、品質ゲート合格)\n   - [ ] Task 3: ... (未実装) ← まだある！\n   ```\n\n2. **タスク完了の判定基準**\n   - [ ] テスト実装済み\n   - [ ] テスト PASS\n   - [ ] 実装コード完成\n   - [ ] Lint チェック合格\n   - [ ] 型チェック合格\n\n3. **判定結果に基づき分岐**\n\n   ```bash\n   未実装タスク あり\n     → Step 3 へ戻る (次のタスク実装)\n\n   未実装タスク なし\n     → Step 5 へ進む (全体品質ゲート)\n   ```\n\n---\n\n### 逸脱 6: Step 5 (品質ゲート実行) での失敗対応の混乱\n\n#### 症状\n\n- 品質ゲート失敗時の対応が体系的でない\n- Step 7 (Refactor) へ戻るべきか Step 3 へ戻るべきか判断がつかない\n- エラーが繰り返し発生する\n\n#### 原因\n\n- Step 5 での失敗とタスク内の失敗の区別がない\n- 対応の流れが設計されていない\n- エラーカウントの管理がない\n\n#### 対応\n\n1. **品質ゲート失敗時のフロー**\n\n   ```bash\n   Step 5: 品質ゲート実行\n     ↓\n   失敗？\n     ├─ NO → Step 6 へ進む\n     └─ YES → 失敗カウント +1\n         ↓\n       失敗カウント ≤ 2\n         → エラー分析・修正\n         → Step 5 再実行\n\n       失敗カウント = 3\n         → ユーザーに相談\n         → Step 3 へ戻るか Step 7 へ戻るか判定\n   ```\n\n2. **エラー別の対応マトリックス**\n\n   | エラー種別                    | 対応                            | 戻り先              |\n   | ----------------------------- | ------------------------------- | ------------------- |\n   | Lint 失敗 (単純な様式違反)    | コード様式修正                  | Step 5 再実行       |\n   | 型チェック失敗 (型定義エラー) | インポート・型注釈修正          | Step 5 再実行       |\n   | テスト失敗 (実装バグ)         | 実装ロジック修正 → テスト再実行 | Step 3 (該当タスク) |\n   | 複合エラー (3 個以上)         | 全体構造の見直し                | Step 7 (Refactor)   |\n\n3. **エラー情報の記録**\n   - エラーメッセージ全文を記録\n   - ファイル・行番号を特定\n   - エラーの根本原因を分析\n\n4. **Step 6 へ進む**\n\n---\n\n### 逸脱 7: Step 6 (進捗記録) の忘却\n\n#### 症状\n\n- 完了したタスクが実装タスクリストに反映されない\n- あとで何が完了したか追跡できない\n- Step 8 の完了判定が曖昧になる\n\n#### 原因\n\n- Step 6 の重要性の認識不足\n- Todo リストと実装タスクリストの同期忘れ\n- 手動更新の面倒さ\n\n#### 対応\n\n1. **実装タスクリストを即座に更新**\n\n   ```markdown\n   # Step 6 実行直後\n\n   - [x] Task 1: 入力値が有効な場合、結果 A を返す (正常系)\n   - [x] Task 2: 入力値が null の場合、エラーを返す (異常系)\n   - [ ] Task 3: 入力値が空文字列の場合、デフォルト値を返す (エッジケース)\n   ```\n\n2. **TodoWrite で進捗を同期**\n\n   ```bash\n   # メモリや TodoWrite に完了を記録\n   ```\n\n3. **進捗状況の可視化**\n   - 完了済みタスク数 / 総タスク数を計算\n   - 進捗率を記録\n   - ユーザーに報告\n\n4. **Step 7 へ進む**\n\n---\n\n### 逸脱 8: Step 7 (Refactor フェーズ) のスキップ\n\n#### 症状\n\n- テストが通った時点で完了判定してしまう\n- コード品質が低い (重複、複雑性が高い)\n- 保守性が低下\n\n#### 原因\n\n- Refactor フェーズの重要性の理解不足\n- テスト通過 = 完了という誤解\n- 時間圧縮のため Phase をスキップ\n\n#### 対応\n\n1. **Refactor フェーズは必須**\n   - テストが通った ≠ 実装完了\n   - テストが通った後に、コード品質改善が必須\n\n2. **Refactor の具体的タスク**\n\n   **テストコードの整理**:\n\n   ```typescript\n   // 悪い例: 重複テスト\n   it('should return A when input is \"abc\"', () => {\n     expect(validate('abc')).toBe(true);\n   });\n   it('should return A when input is \"def\"', () => {\n     expect(validate('def')).toBe(true);\n   });\n   it('should return A when input is \"ghi\"', () => {\n     expect(validate('ghi')).toBe(true);\n   });\n\n   // 良い例: パラメータ化テスト\n   it.each(['abc', 'def', 'ghi'])('should return A when input is \"%s\"', (input) => {\n     expect(validate(input)).toBe(true);\n   });\n   ```\n\n   **実装コードの整理**:\n\n   ```typescript\n   // 悪い例: 重複ロジック\n   function processOrder(type: 'A' | 'B') {\n     if (type === 'A') {\n       validate();\n       calculate();\n       save();\n     } else {\n       validate();\n       calculate();\n       save();\n     }\n   }\n\n   // 良い例: 重複排除\n   function processOrder(type: 'A' | 'B') {\n     validate();\n     calculate();\n     save();\n   }\n   ```\n\n3. **ユーザーと Refactor 案を協議**\n   - 提案内容をユーザーに説明\n   - ユーザーの意見を反映\n   - Refactor の実行・検証\n\n4. **Refactor 後の検証**\n\n   ```bash\n   npm run test          # すべてのテストが PASS\n   npm run lint          # Lint チェック合格\n   npm run check:types   # 型チェック合格\n   ```\n\n5. **Step 8 へ進む**\n\n---\n\n### 逸脱 9: Step 8 (完了判定) での検証不足\n\n#### 症状\n\n- 実装が完全でないまま完了と判定される\n- ユーザーが追加修正依頼を出す\n- ワークフローが巻き戻される\n\n#### 原因\n\n- 完了チェックリストの項目が曖昧\n- チェック漏れ (見落とし)\n- チェック結果の記録がない\n\n#### 対応\n\n1. **完了チェックリスト (100% 達成必須)**\n\n   ```markdown\n   ## テスト完了の確認\n\n   - [x] すべてのテストケースが実装済み\n   - [x] すべてのテストが PASS\n   - [ ] (テストカバレッジ = 100%) # 必要に応じて\n\n   ## 品質ゲート合格の確認\n\n   - [x] Lint チェック: 合格\n   - [x] 型チェック: 合格\n   - [x] その他プロジェクト固有チェック: 合格\n\n   ## Refactor 完了の確認\n\n   - [x] テストコード整理完了\n   - [x] 実装コード整理完了\n   - [x] ユーザーが内容に承認\n\n   ## 最終確認\n\n   - [x] ドキュメント更新 (必要な場合)\n   - [x] コミット準備完了 (ユーザーが手動実施)\n   ```\n\n2. **チェック項目に偽りがないか確認**\n\n   ```bash\n   # テスト実行結果を確認\n   npm run test\n\n   # Lint 結果を確認\n   npm run lint\n\n   # 型チェック結果を確認\n   npm run check:types\n   ```\n\n3. **チェック結果の記録**\n   - 完了日時を記録\n   - チェック項目の実行コマンド・出力を記録\n   - ユーザーの承認を記録\n\n4. **判定**\n\n   ```bash\n   すべてのチェック項目 = [x]\n     → 実装完了！ワークフロー終了\n\n   チェック項目に [  ] がある\n     → Step 7 へ戻って不足部分を対応\n   ```\n\n---\n\n## よくある質問と回答\n\n### Q: Step 3 で 3 回エラーが出た。どうすればいい？\n\n**A**: 以下の対応を実施してください。\n\n1. **ロールバック**: 実装を前のコミット時点まで戻す\n2. **原因分析**: エラーが何度も出る根本原因を分析\n   - テストケースが曖昧？\n   - 実装環境に問題？\n   - deckrd-bdd-coder の動作異常？\n3. **ユーザーに相談**\n   - 問題状況を報告\n   - 対応案を提示\n   - ユーザーの指示を仰ぐ\n\n---\n\n### Q: 品質ゲートで Lint エラーが出た。Step 3 と Step 5 どちらで対応？\n\n**A:** エラーの種類で判定:\n\n| エラー内容                  | 対応フェーズ              | 理由                           |\n| --------------------------- | ------------------------- | ------------------------------ |\n| 個別タスク内の Lint エラー  | Step 3 内の品質ゲート確認 | タスク完了時点で検出すべき     |\n| Step 5 全体実行で初めて出現 | Step 5 で修正             | 複数タスク統合時の問題の可能性 |\n\n---\n\n### Q: Phase 5 では何をするんですか？\n\n**A:** Phase 5 (完了確認) は以下を実施します。\n\n1. **実装タスクリストの確認**\n   - すべてのタスクが `[x]` (完了) であることを確認\n   - 未実装タスク (`[ ]`) が残っていないことを確認\n\n2. **全体テスト実行**\n   - すべてのテストが PASS していることを確認\n\n3. **Refactor 完了確認**\n   - Step 7 で全体コード整理が実施されたことを確認\n   - ユーザーが内容に承認していることを確認\n\n4. **進捗記録確認**\n   - Step 6 で実装タスクリスト・Todo が更新されたことを確認\n\nこの 4 つがすべて確認できたら Phase 6 へ進みます。\n\n---\n\n### Q: Refactor が必要ないケースもあるのでは？\n\n**A:** **いいえ。Refactor は常に必須です。**\n\n理由:\n\n- Red-Green サイクルで実装したコードは、最小限で重複や複雑さが残る\n- テストが通っているだけでは品質の高さを保証しない\n- 保守性・読みやすさは Refactor フェーズで初めて確保される\n\nただし、Refactor の規模が小さい場合:\n\n- 小規模タスク：軽微な変数名改善のみ\n- 大規模タスク：関数抽出、ロジック統合など\n\n---\n\n## トラブルシューティング判定ツリー\n\n```bash\n問題発生\n  ↓\nPhase / Step のどの段階で発生？\n  ├─ Phase 0 → 開発環境把握に戻る\n  ├─ Phase 1 → Session JSON 確認\n  ├─ Phase 2 → タスク細分化を再実施\n  ├─ Phase 3 → Step 3-4 詳細フロー参照\n  ├─ Phase 4 → 品質ゲート失敗対応フロー参照\n  ├─ Phase 5 → 完了確認チェックリスト参照\n  └─ その他 → ユーザーに相談\n\nエラーが 3 回以上発生\n  → ロールバック・ユーザーに相談\n```\n\n---\n\n## 参考資料\n\n- [WORKFLOW.md](./workflow.md) - Phase 0-6 詳細フロー\n- [IMPLEMENTATION.md](./implementation.md) - Step 1-8 詳細手順\n- `.claude/agents/bdd-coder.md` - BDD エージェント仕様\n- `CLAUDE.md` - プロジェクトルール全般\n",
        "plugins/deckrd-coder/skills/deckrd-coder/references/workflow.md": "---\ntitle: WORKFLOW - 内部フロー詳細\n---\n\n<!-- textlint-disable ja-technical-writing/max-comma -->\n\n## WORKFLOW - 内部フロー詳細\n\n## 概要: 開発環境・コーディング状態の管理レイヤー\n\nこのワークフローは、コーディングセッション全体における開発環境と実装状態を管理するメタレイヤーです。\n以下の責務を持ちます。\n\n- 開発言語・開発環境の把握と管理 (build, run, lint などの開発ツール設定)\n- セッション・タスク情報の動的取得\n- プロジェクト規約・コード様式の参照\n- 実装状態の追跡と記録\n- 品質ゲートの実行と検証\n\n---\n\n## ワークフロー全体マップ\n\nコーディングセッション全体は以下の 0-6 のフェーズで構成されます。\n\n```bash\nPhase 0: 開発環境の取得、設定\n    ↓\nPhase 1: deckrd の active タスクからタスクリストを取得\n    ↓\nPhase 2: 呼び出し時のパラメータ、タスクリストから実装タスクリストを取得\n    ↓\nPhase 3: 実装タスクリストに従って、コーディング (= Red-Green-Refactor 実装)\n    ↓\nPhase 4: 品質ゲート実行 (Lint, 型チェック, テスト)\n    ↓\nPhase 5: コーディング終了確認\n    ↓\nPhase 6: ワークフロー終了\n```\n\n| Phase   | 目的                   | 出力                         |\n| ------- | ---------------------- | ---------------------------- |\n| Phase 0 | 開発言語・環境を把握   | 開発ツール設定、実行コマンド |\n| Phase 1 | アクティブタスクを特定 | タスクID、テストケース一覧   |\n| Phase 2 | 実装対象を細分化       | 実装タスクリスト             |\n| Phase 3 | コーディング実行       | テスト合格、実装コード       |\n| Phase 4 | 品質を検証             | 品質ゲート合格確認           |\n| Phase 5 | 完了状態を確認         | セッション終了前の最終確認   |\n| Phase 6 | セッション終了         | 開発ツール・状態をリセット   |\n\n---\n\n## Phase 0: 初期化フェーズ (開発環境把握)\n\nコーディングセッション開始時に、リポジトリルート (モノレポの場合はサブパッケージのルート) で開発環境を把握・確認します。\n\n実行内容:\n\n- リポジトリルート / サブパッケージルートを特定\n- 開発言語を確認 (`package.json`, `Cargo.toml`, `setup.py` など)\n- 開発ツール設定を取得 (Build, Run, Lint, 型チェック, テスト, フォーマッター)\n- 実行コマンドを記録・整理\n\n出力:\n\n- 開発言語、利用ツール一覧、実行コマンド\n\n---\n\n## Phase 1: deckrd の active タスクからタスクリストを取得\n\nアクティブなセッション情報から、コーディング対象のタスク定義を取得します。\n\n実行内容:\n\n- `docs/.deckrd/.session.json` の `active` フィールドから現在セッションを取得\n- 指定されたタスク ID のセクションを抽出\n- テストケース一覧、Given-When-Then 詳細を確認\n\n出力:\n\n- タスク ID、テストケース一覧、テスト仕様\n\n---\n\n## Phase 2: 呼び出し時のパラメータ、タスクリストから実装タスクリストを取得\n\nユーザーから受け取ったパラメータと Phase 1 で取得したタスク仕様から、実装対象を細分化します。\n\n実行内容:\n\n- ユーザーの要件 (呼び出しパラメータ) を分析\n- タスクを単一テストケース単位に分割\n- 実装タスクリストを作成・記録\n\n出力: 実装タスクリスト (テストケースごとのタスク)\n\n---\n\n## Phase 3: 実装タスクリストに従って、コーディング\n\nRed-Green-Refactor サイクルで実装タスクを完了します。\n\n実行内容:\n\n- **ステップ 1～8** に従い、厳密な BDD プロセスで実装\n- 各ステップで品質ゲート実行\n- タスク完了ごとに進捗を記録\n\n詳細:\n\n- [implementation.md](./implementation.md) を参照\n\n出力:\n\n- テスト合格、実装コード完成\n\n---\n\n## Phase 4: 品質ゲート実行\n\n全体的なコード品質を検証します。\n\n実行内容:\n\n- Lint チェック実行\n- 型チェック実行\n- テスト実行\n- すべてのチェックが合格することを確認\n\n出力:\n\n- 品質ゲート合格\n\n---\n\n## Phase 5: コーディング終了確認\n\nセッション終了前に、実装が完了したことを確認します。\n\n実行内容:\n\n- 全テスト PASS 確認\n- 型エラーなし確認\n- 実装タスクリストがすべてチェック済み確認\n- Refactor が完了したか確認\n\n出力:\n\n- コーディング完了状態\n\n---\n\n## Phase 6: ワークフロー終了\n\nセッションを終了し、開発環境をリセットします。\n\n実行内容:\n\n- 開発ツール・状態をリセット\n- セッション情報をクリア\n- コミットはユーザーが手動実施\n\n出力:\n\n- セッション終了\n",
        "plugins/deckrd/.claude-plugin/plugin.json": "{\n  \"name\": \"deckrd\",\n  \"description\": \"deckrd: your goal to tasks framework\",\n  \"version\": \"0.0.4\",\n  \"author\": {\n    \"name\": \"atsushifx\",\n    \"email\": \"atsushifx@gmail.com\"\n  },\n  \"license\": \"MIT\"\n}\n",
        "plugins/deckrd/README.md": "---\nname: deckrd\ndescription: your goal to tasks framework\nmeta:\n  author: atsushifx\n---\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n<!-- markdownlint-disable line-length  -->\n\n# deckrd\n\nA Claude Code plugin providing structured document-derivation workflows that guide you from goals to executable tasks.\n\n## What is deckrd?\n\ndeckrd is a **goals-to-tasks framework** designed for thoughtful project planning and development. It breaks down project ambitions into clear requirements, specifications, and executable tasks through iterative discussion with Claude AI.\n\nRather than jumping directly to implementation, deckrd ensures you capture reasoning at each stage—understanding *why* decisions are made, not just *what* gets built.\n\n## What deckrd does NOT do\n\n- It does not manage source code repositories\n- It does not execute or modify code automatically\n- It does not replace developer judgment\n\n## Key Features\n\n- Stepwise Workflow: Goals → Requirements → Specifications → Implementation → Tasks\n- Document-Centered: Each stage produces a derived document that preserves context and intent\n- AI-Guided: Interactive guidance at each step keeps you focused and aligned\n- State Management: Automatic session tracking ensures workflow consistency\n- Flexible: Works with any project type—features, refactoring, debugging, documentation\n\n## Implementation (in deckrd)\n\nIn deckrd, \"implementation\" does not mean writing production code.\nIt refers to deriving implementation-ready decisions, constraints,\nand structural outlines that make coding straightforward and unambiguous.\n\n## The Output: tasks.md\n\nThe final output of deckrd is **tasks.md**—a document that serves as your **direct starting point for coding**.\n\nUnlike planning documents that capture intent and reasoning, tasks.md is your actionable blueprint:\n\n- Concrete Tasks: Specific, prioritized development tasks derived from your implementation plan\n- Acceptance Criteria: Clear definitions of what \"done\" means for each task\n- Implementation Constraints: Technical decisions and patterns established during earlier phases\n- Ready-to-Code Format: Structured in a way that developers can immediately begin implementation\n\nThis means when you finish the deckrd workflow, you're not just ready to start coding—you have a detailed roadmap that eliminates ambiguity and reduces rework. Each task in tasks.md flows directly into your development cycle.\n\n## Getting Started\n\n### Installation\n\nThe deckrd plugin is available in the Claude Code Marketplace. Enable it through:\n\n```bash\nClaude Code → Settings → Plugins → Enable deckrd\n```\n\n## First Use\n\nOnce enabled, start a new workflow with:\n\n```bash\n/deckrd init <namespace>/<module>\n```\n\ndeckrd then guides you through a stepwise workflow,\nderiving documents from goals to executable tasks.\n\n## Where documents are stored\n\ndeckrd manages all generated documents and workflow state under `docs/.deckrd/` in your project.\n\nYou can browse the derived requirements, specifications, and tasks at any time using your editor or file explorer.\n\n## Use Cases\n\ndeckrd works well for:\n\n- New Features: Clarify requirements before coding\n- Refactoring: Document the why before restructuring\n- Bug Fixes: Understand root causes and plan solutions\n- System Design: Capture architectural decisions\n- Documentation: Trace decision-making and rationale\n\n## Documentation\n\nFor detailed guides and command reference, see the included skill documentation or visit the deckrd repository.\n\n## License\n\nThe MIT License\nCopyright (C) 2025- aglabo\n",
        "plugins/deckrd/skills/deckrd/README.md": "---\ntitle: deckrd skill specification\ntype: skill-documentation\nscope: deckrd skill\naudience:\n  - claude\n  - skill users\n  - maintainers\npurpose:\n  - define the contract and invariants of the deckrd skill\n  - describe the stepwise derivation workflow and its commands\nnon_goals:\n  - plugin installation instructions\n  - internal MCP server implementation details\n  - project-specific usage examples\nmeta:\n  author: atsushifx\n  version: 0.0.4\n---\n\n<!--textlint-disable ja-technical-writing/sentence-length -->\n<!--textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n<!-- markdownlint-disable line-length -->\n\n## deckrd skill\n\nThis skill guides a stepwise derivation workflow: **goals → requirements → specifications → executable tasks**.\n\n## Purpose\n\nThe deckrd skill enables systematic requirement engineering and task derivation through a structured, narrowly-focused workflow. It enforces a discipline of deep analysis at each stage, ensuring specifications are precise and tasks are actionable.\n\n## How To Use\n\nThe deckrd workflow transforms vague goals into concrete, executable tasks through a systematic derivation process:\n\n```bash\n      Your Goals\n         │\n         ▼\n  ┌─────────────────┐\n  │  init: Define   │  Clarify goals & scope\n  │  Goals & Scope  │\n  └────────┬────────┘\n           │  dr: record & validate changes\n           ▼\n  ┌──────────────────┐\n  │  req:            │ derive requirements\n  │  (Requirements)  │\n  └────────┬─────────┘\n           │  dr: record & validate changes\n           ▼\n  ┌──────────────────┐\n  │  spec:           │ define specifications\n  │  (Specification) │\n  └────────┬─────────┘\n           │  dr: record & validate changes\n           ▼\n  ┌───────────────────┐\n  │  impl: Plan       │ plan implementation (not coding)\n  │  (Implementation) │\n  └────────┬──────────┘\n           │  dr: record & validate changes\n           ▼\n  ┌─────────────────┐\n  │  tasks:         │\n  │  Executable     │    generate executable tasks\n  │  Task List      │\n  └────────┬────────┘\n           │\n           ▼\n  Executable Tasks\n(Ready for Development)\n```\n\n### Principles\n\ndeckrd enforces a strict, stepwise workflow.\nEach step deepens understanding before moving forward.\n\n## Commands\n\n| Command                      | Description                                    |\n| ---------------------------- | ---------------------------------------------- |\n| `init`                       | Initialize `deckrd` direcory                   |\n| `init <ns>/<mod>`            | Initialize module directory and session        |\n| `req`                        | Derive requirements from goals                 |\n| `dr`                         | Manage Decision Records                        |\n| `dr --add`                   | Append a new Decision Record                   |\n| `spec`                       | Derive specifications from requirements        |\n| `impl`                       | Derive implementation plan from specifications |\n| `tasks`                      | Derive executable tasks from implementation    |\n| `status`                     | Display current workflow progress and status   |\n| `review`                     | Show review command usage                      |\n| `review <doc> [--phase <p>]` | Review document with phase-specific analysis   |\n\n## Review Command\n\nThe `review` command supports document analysis with three review phases:\n\n### Usage\n\n```bash\n/deckrd review                    # Show usage\n/deckrd review req                # Review requirements (explore phase)\n/deckrd review req --phase harden # Review requirements (harden phase)\n/deckrd review spec --phase fix   # Review specifications (fix phase)\n```\n\n### Review Phases\n\n| Phase   | Persona                         | Purpose                            |\n| ------- | ------------------------------- | ---------------------------------- |\n| explore | Design Reviewer                 | Identify gaps, raise questions     |\n| harden  | Normative Requirements Reviewer | Promote to MUST/SHALL, generate DR |\n| fix     | Spec Auditor                    | Normalize, verify consistency      |\n\n### Document Phases\n\n| Doc Phase | Target Document                  |\n| --------- | -------------------------------- |\n| req       | requirements/requirements.md     |\n| spec      | specifications/specifications.md |\n| impl      | implementation/implementation.md |\n| tasks     | tasks/tasks.md                   |\n",
        "plugins/deckrd/skills/deckrd/SKILL.md": "---\nname: deckrd\ndescription: \"Use when structuring requirements, specifications, or tasks. Enforces stepwise derivation and phase integrity.\"\n---\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- textlint-disable ja-technical-writing/max-comma -->\n<!-- markdownlint-disable line-length -->\n\n# Deckrd - Your Goals to Tasks framework\n\nDeckrd is a document-centered framework for structuring and refining ideas through iterative discussion with AI.\nIt guides the creation of requirements, decisions, specifications, and implementation plans as derived documents, not final outputs.\nEach document captures reasoning at a specific stage, preserving context and intent.\nThrough a strict, state-driven workflow, these documents are progressively shaped into executable development tasks.\nDeckrd enables documentation to function as a practical engine for action, not just description.\n\n## Commands\n\n| Command                      | Description                                    |\n| ---------------------------- | ---------------------------------------------- |\n| `init`                       | initialize `deckrd` directory                  |\n| `init <ns>/<mod>`            | Initialize module directory and session        |\n| `req`                        | Derive requirements from goals                 |\n| `dr`                         | Manage Decision Records (req step only)        |\n| `dr --add`                   | Append a new Decision Record                   |\n| `spec`                       | Derive specifications from requirements        |\n| `impl`                       | Derive implementation plan from specifications |\n| `tasks`                      | Derive executable tasks from implementation    |\n| `status`                     | Display current workflow progress and status   |\n| `review`                     | Show review command usage                      |\n| `review <doc> [--phase <p>]` | Review document with phase-specific analysis   |\n\n## Session Resolution\n\nSession state is stored in `docs/.deckrd/.session.json`.\n\n**Before executing any command:**\n\n1. Read `.session.json` to get active module and current step\n2. Validate the command matches expected workflow progression\n3. Load the appropriate reference from `references/commands/`\n\n**Reference selection:**\n\n| Current State  | Next Command | Load Reference                                      |\n| -------------- | ------------ | --------------------------------------------------- |\n| (none)         | init         | [commands/init.md](references/commands/init.md)     |\n| init completed | req          | [commands/req.md](references/commands/req.md)       |\n| req completed  | spec         | [commands/spec.md](references/commands/spec.md)     |\n| spec completed | impl         | [commands/impl.md](references/commands/impl.md)     |\n| impl completed | tasks        | [commands/tasks.md](references/commands/tasks.md)   |\n| any            | review       | [commands/review.md](references/commands/review.md) |\n\n**For workflow overview:** [workflow.md](references/workflow.md)\n**For session management details:** [session.md](references/session.md)\n**For status command:** [commands/status.md](references/commands/status.md)\n",
        "plugins/deckrd/skills/deckrd/assets/inits/README.md": "# .deckrd\n\nThis directory contains internal design and decision records\nused during development.\n\n- Documents under this directory are not part of the public API.\n- Decisions are recorded as DR (Decision Records).\n- This directory may be extracted as a standalone repository in the future.\n\n## notes/\n\nDocuments under `notes/` are working notes and design drafts.\n\n- Contents are not stable.\n- They may be incomplete, outdated, or contradictory.\n- Information here may later be promoted to requirements or decision records.\n\n### How to Use\n\n- Use `notes/` to record working ideas, design explorations, and unresolved discussions.\n- Notes files should start with a datetime, e.g. `2025-12-26T21:38:00-about-agtKind.md`.\n- When a design decision is finalized, promote the content to:\n  - `decision-records/` for explicit design decisions (DR)\n  - `requirements/` for agreed functional or non-functional requirements\n- Do not treat documents under `notes/` as stable or authoritative.\n",
        "plugins/deckrd/skills/deckrd/assets/prompts/decision-record.prompt.md": "# Decision Record Generation Prompt (deckrd)\n\nYou are an **Architecture Decision Recorder**.\n\nYour task is to generate a single Markdown document that contains\n**multiple Decision Records (DRs)**.\n\nThis document preserves architectural rationale.\nIt is non-normative and explanatory.\n\n## Input\n\nYou will receive:\n\n1. This PROMPT\n2. PARAMETERS\n3. ANALYZED DESIGN DECISIONS\n4. (Optionally) an external Decision Record template reference\n\n## Output rules\n\n- Output ONLY the generated Markdown\n- No explanations or meta commentary\n- Don't use bullet list formatting for bolding (ex. `- **xx**:`), use `-- xx:` as the bullet point.\n\n---\n\n## Parameters\n\n- LANG: system | en | ja | other\n- PHASE: req | spec | impl | tasks\n\n---\n\n## Language Rules\n\n| LANG   | Rule                                         |\n| ------ | -------------------------------------------- |\n| system | System default                               |\n| en     | English                                      |\n| ja     | 本文は日本語、見出しは英語、技術用語は英語可 |\n| other  | Use literally                                |\n\n---\n\n## Generation Rules\n\n- Generate **one file**: `decision-records.md`\n- Include **multiple Decision Records**\n- Each Decision Record MUST:\n  - Have a unique ID: DR-01, DR-02, ...\n  - Include timestamp in header: `## DR-<ID>: <Title> - <YYYY-MM-DD HH:MM:SS>`\n  - Include **Phase** field: `**Phase**: <PHASE from parameters>`\n  - Include **Status** field: `**Status**: Accepted` (or other appropriate status)\n  - Follow the **Decision Record template defined by this skill**\n- Order Decision Records by architectural impact (higher impact first), or by appearance order if impact is unclear.\n\nDo NOT:\n\n- Embed template definitions\n- Include implementation code\n- Restate functional requirements\n",
        "plugins/deckrd/skills/deckrd/assets/prompts/implementation.prompt.md": "# Implementation Document Generation Prompt\n\nYou are a software engineer.\nGenerate an `implementation.md` document from specifications.\n\n## generate instructions\n\n- don't use `- **xx**:` for bolding in lists, use `-- xx:` as the bullet point.\n\n## Input Format\n\nYou will receive:\n\n1. TEMPLATE: Document structure to follow\n2. PARAMETERS: Configuration including LANG\n3. SPECIFICATIONS: The specifications document\n\n## Core Principles\n\n- This document defines **implementation-level constraints and behavioral contracts**\n  that any concrete implementation must satisfy,\n  and does not prescribe concrete implementations or code structure.\n- Focus on:\n  - Input/output contracts\n  - Behavioral constraints derived from specifications\n  - Assumptions and invariants relevant to implementation\n- Do NOT generate:\n  - Concrete function bodies\n  - Exhaustive or fixed union type definitions\n  - Test strategies or coverage requirements\n  - Module layout decisions not explicitly stated in SPECIFICATIONS\n- Do NOT invent constraints not implied by SPECIFICATIONS.\n\n## Instructions\n\n### Step 1: Analyze Specifications\n\nExtract:\n\n1. Behavioral rules that imply type constraints\n2. Decision rules that define function logic structure\n3. Edge cases that require explicit handling\n4. Design assumptions that affect implementation choices\n\n### Step 2: Generate Document\n\nUsing the TEMPLATE:\n\n- Describe **input/output expectations** without over-constraining types\n- Express type information **conceptually**, unless explicitly fixed by SPECIFICATIONS\n- Document **decision logic constraints**, not control flow implementations\n- Treat testing concerns as out of scope\n\n### Step 3: Apply Language\n\nFollow LANG parameter exactly.\n\n- `ja`: Headings in English, body in Japanese\n- `en`: Use technical English with precise terminology\n\n## Output\n\nOutput ONLY the generated markdown document.\nDo not include explanations or meta-commentary.\nCode snippets should be TypeScript type definitions only (no implementations).\n",
        "plugins/deckrd/skills/deckrd/assets/prompts/requirements.prompt.md": "# Requirements & Decision Records Generation Prompt (deckrd)\n\nYou are a **Requirements Analyst** and **Architecture Documenter**.\n\nYour task is to generate:\n\n1. A normative `requirements.md`\n2. One or more `decision-record-XX.md` documents (Architecture Decision Records)\n\nfrom structured user input.\n\n---\n\n## Inputs You Will Receive\n\n1. **PROMPT** (this file)\n2. **REQUIREMENTS TEMPLATE**\n3. **DECISION RECORD TEMPLATE**\n4. **PARAMETERS**\n5. **USER INPUT**\n\n---\n\n## Output Rules\n\n- Output **only Markdown**\n- Separate files with clear file headers\n- No explanations or meta commentary\n- Ready for direct commit\n- Don't use `- **xx**:` in lists, use `- xx:` as the bullet point.\n\n---\n\n## Parameters\n\n- `LANG`: system | en | ja | other\n- `GENERATE_DECISION_RECORDS`: true | false\n- `DECISION_RECORD_STYLE`: adr | lightweight (default: adr)\n\n---\n\n## Language Rules\n\n| LANG   | Rule                                                  |\n| ------ | ----------------------------------------------------- |\n| system | System default language                               |\n| en     | English with RFC 2119 keywords (SHALL / SHOULD / MAY) |\n| ja     | 本文は日本語、見出しは英語、技術用語は英語可          |\n| other  | Use literally                                         |\n\n- RFC 2119 keywords apply to requirements.md only.\n\n---\n\n## Step 1: Analyze USER INPUT\n\nExtract:\n\n### A. Problem Space\n\n- Purpose\n- Scope\n- Out of Scope\n\n### B. Context\n\n- Target system or module\n- Execution environment\n- Constraints (runtime, policy, compatibility)\n\n### C. Design Decisions\n\nFor each significant decision:\n\n- Decision summary\n- Alternatives considered\n- Selected option\n- Rationale\n- Trade-offs\n\n### D. Requirements\n\n- Functional requirements\n- Non-functional requirements\n- Explicit exclusions\n\n---\n\n## Step 2: Generate requirements.md\n\nUsing the **REQUIREMENTS TEMPLATE**, populate:\n\n- Overview\n- Context\n- Design Decisions (summary only)\n- Functional Requirements (normative)\n- Non-Functional Requirements\n- Change History\n\n⚠️ Requirements are **normative**.\n⚠️ Examples are **non-prescriptive**.\n\n---\n\n## Step 3: Generate Decision Records (Optional)\n\nIf `GENERATE_DECISION_RECORDS==true` or `DR==true`:\n\n- Create one Decision Record per major design decision\n- Assign IDs: DR-01, DR-02, ...\n- Use **DECISION RECORD TEMPLATE**\n- Link Decision Records from requirements.md\n",
        "plugins/deckrd/skills/deckrd/assets/prompts/review.prompt.md": "# Document Review Prompt (deckrd)\n\nYou are executing a **Document Review** with phase-specific analysis.\n\nYour task is to review an existing deckrd document (requirements, specifications, etc.)\nand generate findings, recommendations, and optionally Decision Records based on the\nspecified review phase.\n\n---\n\n## Inputs You Will Receive\n\n1. **PROMPT** (this file)\n2. **REVIEW TEMPLATE**\n3. **PARAMETERS**\n   - `PHASE`: explore | harden | fix\n   - `LANG`: system | en | ja | other\n4. **DOCUMENT TO REVIEW** (the target document content)\n\n---\n\n## Output Rules\n\n- Output **only Markdown**\n- No explanations or meta commentary\n- Ready for direct use\n- Don't use `- **xx**:` in lists, use `- xx:` as the bullet point.\n\n---\n\n## Parameters\n\n- `PHASE`: explore | harden | fix (REQUIRED)\n- `LANG`: system | en | ja | other\n\n---\n\n## Language Rules\n\n| LANG   | Rule                                                  |\n| ------ | ----------------------------------------------------- |\n| system | System default language                               |\n| en     | English with RFC 2119 keywords (SHALL / SHOULD / MAY) |\n| ja     | 本文は日本語、見出しは英語、技術用語は英語可          |\n| other  | Use literally                                         |\n\n---\n\n## Persona Selection by PHASE\n\nBased on the `PHASE` parameter, assume one of the following personas:\n\n### PHASE: explore\n\nYou are a **Design Reviewer**.\n\n**Mindset:**\n\n- Curious, questioning, exploratory\n- \"What if...?\", \"Have we considered...?\", \"Is it clear that...?\"\n\n**Focus Areas:**\n\n- Completeness: Are all scenarios covered?\n- Ambiguity: Are terms clearly defined?\n- Alternatives: What other approaches exist?\n- Assumptions: Are implicit assumptions stated?\n- Gaps: What's missing?\n\n**Language Rules:**\n\n- Use SHOULD / MAY language freely\n- MUST / SHALL are **PROHIBITED**\n- If you find yourself wanting to say MUST, rephrase as \"Consider whether...\"\n\n**Decision Records:**\n\n- **PROHIBITED** - Do not generate DR entries\n- Decisions are not yet mature enough to record\n\n**Output Style:**\n\n- Questions and observations\n- \"Consider...\", \"It may be worth exploring...\"\n- List alternatives without recommending\n\n---\n\n### PHASE: harden\n\nYou are a **Normative Requirements Reviewer**.\n\n**Mindset:**\n\n- Decisive, analytical, convergent\n- \"This must be...\", \"The decision is...\", \"We choose X because...\"\n\n**Focus Areas:**\n\n- WHEN extraction: Identify conditions for SHOULD statements\n- Promotion: Upgrade SHOULD → MUST with justification\n- Gap filling: Add missing normative requirements\n- Constraint identification: What limits apply?\n\n**Language Rules:**\n\n- Extract WHEN conditions from ambiguous statements\n- Promote SHOULD → MUST where evidence supports\n- Each promotion requires justification\n\n**WHEN Extraction Rules:**\n\nSources for WHEN conditions (in priority order):\n\n1. **Explicit in source**: Conditions already stated but not formatted as WHEN\n2. **Implicit in context**: Conditions inferable from surrounding requirements\n3. **Domain knowledge**: Standard conditions for the requirement type\n\nBoundaries:\n\n- **ALLOWED**: Reformatting existing conditions, making implicit conditions explicit\n- **PROHIBITED**: Inventing conditions not derivable from source or domain\n- Each extraction MUST cite its source (explicit/implicit/domain)\n\n**Decision Records:**\n\n- **REQUIRED** for each requirement promotion\n- **REQUIRED** for each gap filled\n- **REQUIRED** for each significant clarification\n- Use standard DR format with DR-XX numbering\n\n**DR Granularity Guidelines:**\n\nTo prevent DR explosion, consolidate related decisions:\n\n- **Consolidate**: Group related promotions into a single DR (e.g., \"Promote all input validation to MUST\")\n- **Threshold**: Only create DR for decisions affecting system behavior or architecture\n- **Skip DR for**: Trivial clarifications, obvious domain constraints, editorial WHEN extractions\n\nTarget: 1-5 DRs per review session for typical documents\n\n**Output Style:**\n\n- Definitive statements\n- \"Promote FR-XX to MUST because...\"\n- \"Add new requirement: SHALL...\"\n- Include DR entries for each decision\n\n---\n\n### PHASE: fix\n\nYou are a **Spec Auditor**.\n\n**Mindset:**\n\n- Meticulous, conservative, non-invasive\n- \"Is this consistent?\", \"Can this be tested?\", \"Is the wording precise?\"\n\n**Focus Areas:**\n\n- Terminology consistency: Same terms for same concepts\n- Testability verification: Each requirement can be verified\n- Structure normalization: Consistent formatting\n- Cross-reference validation: All references are valid\n- Typo and grammar fixes\n\n**Language Rules:**\n\n- NO new MUST / SHALL requirements\n- NO new SHOULD / MAY requirements\n- Only fix existing text without changing meaning\n\n**Semantic Change Boundaries:**\n\nWhat constitutes \"changing meaning\" (PROHIBITED):\n\n- Adding/removing requirements or constraints\n- Changing scope (broader or narrower)\n- Altering conditions or triggers\n- Modifying actors or responsibilities\n\nWhat is NOT semantic change (ALLOWED):\n\n- **Testability rewording**: \"fast\" → \"responds within 100ms\" (adds measurability)\n- **Subject completion**: \"should be validated\" → \"input should be validated\"\n- **Ambiguity resolution**: \"appropriate\" → \"as specified in Section 3.2\" (reference addition)\n- **Passive to active**: \"errors are logged\" → \"the system logs errors\"\n\nRule of thumb: If the change could affect test cases, it's semantic → defer to harden phase\n\n**Decision Records:**\n\n- **PROHIBITED** - No new decisions in fix phase\n- All decisions should have been made in harden phase\n\n**Output Style:**\n\n- \"Inconsistent terminology: X vs Y, recommend Y\"\n- \"Untestable requirement: FR-XX, suggest rewording\"\n- \"Missing cross-reference: Section X mentions Y\"\n\n---\n\n## Phase Violation Detection\n\nYou MUST self-check your output for phase violations:\n\n### explore violations\n\n- ERROR if output contains: \"MUST\", \"SHALL\", \"is required\", \"will be\"\n- WARNING if output prescribes specific implementation\n\n### harden violations\n\n- ERROR if no DR section when promoting requirements\n- WARNING if WHEN conditions are not explicit\n- WARNING if justification is missing for promotions\n\n### fix violations\n\n- ERROR if output introduces new requirements\n- ERROR if output contains new \"MUST\" / \"SHALL\" not in source document\n- WARNING if restructuring changes semantic meaning\n\nIf you detect a violation, **stop and reconsider** before outputting.\n\n---\n\n## Step 1: Analyze Document\n\nRead the target document and identify:\n\n1. Document type (requirements, specifications, implementation, tasks)\n2. Current maturity level\n3. Key sections and their content\n\n---\n\n## Step 2: Apply Phase-Specific Review\n\nBased on `PHASE`, apply the appropriate review lens:\n\n### For explore:\n\n- List questions and concerns\n- Identify ambiguous terms\n- Suggest alternatives to explore\n- Note implicit assumptions\n\n### For harden:\n\n- Identify SHOULD statements that should be MUST\n- Extract WHEN conditions\n- Fill gaps with new requirements\n- Generate DR for each decision\n\n### For fix:\n\n- Check terminology consistency\n- Verify testability\n- Normalize structure\n- Fix typos and grammar\n\n---\n\n## Step 3: Generate Output\n\nUse the **REVIEW TEMPLATE** to structure your output.\n\n**Priority Rule**: In case of conflict between this PROMPT and the REVIEW TEMPLATE, this PROMPT takes precedence.\n\nFollow the structure defined in the phase-specific REVIEW TEMPLATE:\n\n- **explore**: Questions, Ambiguous Terms, Alternatives, Assumptions, Gaps\n- **harden**: Promotions, WHEN Extractions, Gap-Filling Requirements, Decision Records\n- **fix**: Terminology, Testability, Structure, Cross-References, Typos\n\nEach phase template defines the exact sections and format to use.\n\n---\n\n## Decision Record Format (harden phase only)\n\nWhen generating DR entries, use this format:\n\n```markdown\n## Decision Records\n\n### DR-XX: Decision Title\n\n**Phase**: review-harden\n**Status**: Accepted\n\n### Context\n\nWhy this decision was needed during review.\n\n### Decision\n\nWhat was decided (requirement promoted, gap filled, etc.)\n\n### Alternatives Considered\n\n- Option A: Description\n- Option B: Description\n\n### Rationale\n\nWhy this option was chosen.\n\n### Consequences\n\n- Positive:\n  - Benefit 1\n- Negative:\n  - Trade-off 1\n\n---\n```\n\nNote: DR-XX numbering will be resolved by the calling script based on existing DRs.\n",
        "plugins/deckrd/skills/deckrd/assets/prompts/specifications.prompt.md": "# Specifications Document Generation Prompt\n\nYou are a software architect.\nGenerate a `specifications.md` document from requirements.\n\n## Input Format\n\nYou will receive:\n\n1. TEMPLATE: Document structure to follow\n2. PARAMETERS: Configuration including LANG\n3. REQUIREMENTS: The requirements document\n\n## Core Principles\n\n- This specification is **behavioral**, not implementational.\n- Do NOT generate:\n  - Source code\n  - Function signatures\n  - Type definitions\n  - Test cases\n  - File paths or module layouts\n- Do NOT invent behavior not stated in REQUIREMENTS.\n\n---\n\n## Step 0: Generation Feasibility Check\n\nBefore generating, verify REQUIREMENTS completeness.\n\n**HALT generation if ANY of the following are true:**\n\n- FR statements are ambiguous (no clear input→output mapping)\n- Decision order cannot be unambiguously derived\n- Edge cases are not explicitly defined\n\n**When halting:**\n\n1. List all ambiguities as `Open Questions`\n2. Specify what information is missing\n3. Do NOT infer, normalize, or assume behavior\n4. Output partial specification with `[INCOMPLETE]` marker in Status\n\n---\n\n## Step 1: Analyze Requirements\n\nExtract only:\n\n1. Behavioral rules implied by FR statements\n2. Classification logic and decision order\n3. Explicit edge cases and exclusions\n4. Non-goals and assumptions stated or implied\n5. Design Decisions (DD-xx) that affect observable behavior\n   - Record each DD with: ID, Decision, Rationale, Affected Rules, Status\n   - Status defaults to `Active` for new DDs\n   - If DD references an existing DR, mark as `Promoted → DR-xx`\n   - These MUST appear in Section 2.4 of output\n6. Related Decision Records (DR-xx) from `decision-records.md`\n   - Identify DRs that affect this specification's behavioral rules\n   - Record: DR-ID, Title, Phase, Impact description\n   - These MUST appear in Section 2.5 of output\n\n---\n\n## Step 2: Generate Document\n\nUsing the TEMPLATE:\n\n- Describe **what the function does**, not how it is implemented\n- Express rules in declarative, order-sensitive form\n- Preserve all constraints from REQUIREMENTS\n- Ensure traceability to FR identifiers\n\n---\n\n## Step 3: Apply Language\n\nFollow LANG parameter exactly.\n\n- `ja`: Headings in English, body in Japanese\n- `en`: Use RFC 2119 keywords where appropriate\n\n---\n\n## Derivation Constraints\n\n### Non-Goals\n\n- Non-Goals MUST originate from REQUIREMENTS (Section: Out of Scope)\n- Do NOT invent Non-Goals not stated in source\n- If REQUIREMENTS lacks Non-Goals, leave section empty with note:\n  > \"No Non-Goals defined in source REQUIREMENTS.\"\n\n### Design Decisions\n\n- Design Decisions (DD-xx) MUST be extracted from REQUIREMENTS\n- Each DD must show: ID, Decision, Rationale, Affected Rules, Status\n- If no DD exists in REQUIREMENTS, note:\n  > \"No Design Decisions defined in source REQUIREMENTS.\"\n\n### DD Status Tracking\n\n- All DDs MUST have a Status field\n- Valid statuses: `Active`, `Promoted → DR-xx`\n- When a DD is promoted:\n  1. Update DD Status to `Promoted → DR-xx`\n  2. Add corresponding entry to Section 2.5 (Related DRs)\n\n### Related Decision Records\n\n- Related DRs MUST be verified against `decision-records.md` if it exists\n- Each DR entry must include: ID, Title, Phase, Impact\n- If no DRs exist or no `decision-records.md`, note:\n  > \"No Decision Records currently affect this specification.\"\n\n### DD Promotion Guidance\n\n- Section 2.6 provides criteria for DD → DR promotion\n- These criteria are ADVISORY, not mandatory\n- The decision to promote is made by human judgment\n- Do NOT auto-promote DDs based on criteria alone\n\n---\n\n## Open Questions Policy\n\nOpen Questions section is **MANDATORY** (not optional).\n\n- If no questions exist, explicitly state: \"None identified\"\n- Record any:\n  - Ambiguities discovered during analysis\n  - Missing edge case definitions\n  - Unclear decision order\n- Format: Table with Question, Source (FR-xx), Impact\n\n---\n\n## Output\n\nOutput ONLY the generated markdown document.\nDo not include explanations or meta-commentary.\nThe document must be implementation-agnostic.\n",
        "plugins/deckrd/skills/deckrd/assets/prompts/tasks.prompt.md": "# Tasks Generation Prompt (deckrd)\n\nYou are a **BDD Task Generator**.\n\nYour task is to generate executable implementation tasks\nfrom specifications, structured as unit test cases.\n\nEach task corresponds to a single `it()` block in BDD testing.\n\n## Input\n\nYou will receive:\n\n1. This PROMPT\n2. PARAMETERS\n3. SPECIFICATIONS document\n4. IMPLEMENTATION document (implementation.md)\n5. (Optionally) an external Tasks template reference\n\n## Output rules\n\n- Output ONLY the generated Markdown\n- No explanations or meta commentary\n- Use markdown checkboxes for each task\n\n---\n\n## Parameters\n\n- LANG: system | en | ja | other\n- MODULE: The module identifier (namespace/module)\n- TEST_TARGET: Primary function/class under test\n\n---\n\n## Language Rules\n\n| LANG   | Rule                                         |\n| ------ | -------------------------------------------- |\n| system | System default                               |\n| en     | English                                      |\n| ja     | 本文は日本語、見出しは英語、技術用語は英語可 |\n| other  | Use literally                                |\n\n---\n\n## Task ID Strategy\n\nTask IDs follow a hierarchical structure:\n\n```\nT-<TestTarget>-<Scenario>-<Case>\n```\n\nWhere:\n\n- TestTarget: 2-digit sequential number for the test target (01, 02, ...)\n- Scenario: 2-digit sequential number for Given/When scenario (01, 02, ...)\n- Case: 2-digit sequential number for specific test case (01, 02, ...)\n\n### Examples\n\n```\nT-01-01-01  → TestTarget 01, Scenario 01, Case 01\nT-01-02-03  → TestTarget 01, Scenario 02, Case 03\nT-02-01-01  → TestTarget 02, Scenario 01, Case 01\n```\n\n## Test Case Strategy\n\n- A single task (it block) MUST represent a single failure reason.\n- Multiple expect statements are allowed ONLY if they contribute to the same failure reason.\n- If expectations represent different behavioral contracts\n  (e.g. return value, side effects, error handling),\n  they MUST be split into separate it blocks (and tasks).\n\n## BDD Structure Mapping\n\nTasks must map to the following BDD test structure:\n\n```typescript\ndescribe('<TestTarget>', () => {                    // T-XX\n  describe('<Given/When Scenario>', () => {         // T-XX-YY\n    it('<Then Assertion>', () => { ... });          // T-XX-YY-ZZ\n  });\n});\n```\n\n### Category Prefixes\n\nUse category prefixes in describe blocks:\n\n| Category     | Prefix         | Description         |\n| ------------ | -------------- | ------------------- |\n| Normal cases | [正常]         | Expected behavior   |\n| Error cases  | [異常]         | Error handling      |\n| Edge cases   | [エッジケース] | Boundary conditions |\n\n---\n\n## Generation Rules\n\n1. **Read IMPLEMENTATION document first**:\n   - Identify actual function/class/method names\n   - Note any renamed or refactored components\n   - Understand the actual implementation structure\n   - **ALWAYS use the names defined in implementation.md**\n\n2. **Read SPECIFICATIONS** and identify:\n   - Test targets (functions, classes, methods)\n   - Input/output constraints\n   - Edge cases and error conditions\n   - Cross-reference with implementation.md for exact names\n\n3. **Break down** each specification into:\n   - Test target (describe block level 1)\n   - Given/When scenarios (describe block level 2)\n   - Then assertions (it block level)\n   - **Use exact function/method names from implementation.md**\n\n4. **Generate tasks** with:\n   - Unique Task ID\n   - Markdown checkbox\n   - Clear test description\n   - Mapping to BDD structure\n   - **Target names matching implementation.md**\n\n5. **Order tasks** by:\n   - Test target sequence\n   - Normal → Error → Edge case progression\n\n---\n\n## Task Format\n\nEach task MUST include:\n\n```markdown\n- [ ] **T-XX-YY-ZZ**: <Brief description>\n  - Target: `<function/method name>`\n  - Scenario: Given <precondition>, When <action>\n  - Expected: Then <assertion>\n```\n\n---\n\n## Do NOT\n\n- Include implementation code in tasks\n- Include BDD sample/reference implementation sections\n- Include progress tracking tables\n- Create overly granular tasks (combine related assertions)\n- Skip error handling scenarios\n- Omit edge case coverage\n- **Use function/method names from specifications if they differ from implementation.md**\n- **Ignore implementation.md when naming test targets**\n",
        "plugins/deckrd/skills/deckrd/assets/templates/decision-record.template.md": "---\ntitle: \"Decision Records\"\nstatus: Active\ncreated: { { DATE } }\n---\n\n> This document records architectural and design decisions.\n> It is non-normative and exists to preserve rationale.\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- textlint-disable ja-technical-writing/max-comma -->\n<!-- markdownlint-disable no-duplicate-heading line-length  -->\n\n---\n\n## DR-01: {{DECISION_TITLE}} - {{YYYY-MM-DD HH:MM:SS}}\n\n**Phase**: {{PHASE}}\n**Status**: Accepted\n\n<!-- Phase may be: req | spec | impl | tasks -->\n<!-- Status may be: Proposed | Accepted | Deprecated | Superseded -->\n\n### Context\n\n{{CONTEXT}}\n\n### Decision\n\n{{DECISION}}\n\n### Alternatives Considered\n\n- Option A: {{OPTION_A}}\n- Option B: {{OPTION_B}}\n\n<!-- Add more options as needed -->\n\n### Rationale\n\n{{RATIONALE}}\n\n### Consequences\n\n- Positive:\n  - {{POSITIVE_1}}\n\n- Negative:\n  - {{NEGATIVE_1}}\n\n---\n\n## DR-02: {{DECISION_TITLE}} - {{YYYY-MM-DD HH:MM:SS}}\n\n**Phase**: {{PHASE}}\n**Status**: Accepted\n\n### Context\n\n{{CONTEXT}}\n\n### Decision\n\n{{DECISION}}\n\n### Alternatives Considered\n\n- Option A: {{OPTION_A}}\n- Option B: {{OPTION_B}}\n\n### Rationale\n\n{{RATIONALE}}\n\n### Consequences\n\n- Positive:\n  - {{POSITIVE_1}}\n\n- Negative:\n  - {{NEGATIVE_1}}\n\n---\n\n<!--\nRepeat DR sections as needed.\nIDs MUST be sequential: DR-01, DR-02, ...\n-->\n",
        "plugins/deckrd/skills/deckrd/assets/templates/implementation.template.md": "---\ntitle: \"Implementation: {{FEATURE_NAME}}\"\nBased on: specifications.md v{{SPEC_VERSION}}\nStatus: Draft\n---\n\n## 1. Overview\n\n### 1.1 Purpose\n\n{{WHAT_THIS_IMPLEMENTATION_DEFINES}}\n\n### 1.2 Module Location\n\n- File: `{{FILE_PATH}}`\n- Export: {{EXPORT_TYPE}} (internal/public)\n\n---\n\n## 2. Type Definitions\n\n### 2.1 Input Type\n\n```typescript\n{\n  {\n    <INPUT_TYPE_DEFINITION>;\n  }\n}\n```\n\n> NOTE: The following code blocks contain explicit placeholders and are not valid TypeScript until filled.\n\n### 2.2 Output Type\n\n```typescript\n{\n  {\n    <OUTPUT_TYPE_DEFINITION>;\n  }\n}\n```\n\n### 2.3 Conceptual Types (Informative)\n\nThe following types are referenced **conceptually**\nto explain the implementation constraints.\nThey are not required to exist as concrete exported types.\n\n{{CONCEPTUAL_TYPE_DESCRIPTION}}\n\n---\n\n## 3. Function Contract\n\n### 3.1 Signature\n\n```typescript\n{\n  {\n    FUNCTION_SIGNATURE;\n  }\n}\n```\n\n### 3.2 Preconditions\n\n- {{PRECONDITION_1}}\n- {{PRECONDITION_2}}\n\n### 3.3 Postconditions\n\n- {{POSTCONDITION_1}}\n- {{POSTCONDITION_2}}\n\n### 3.4 Invariants\n\n- {{INVARIANT_1}}\n\n---\n\n## 4. Implementation Constraints\n\n### 4.1 Decision Logic\n\nDerived from specifications Decision Rules:\n\n| Step | Check                | Implementation Note       |\n| ---: | -------------------- | ------------------------- |\n|    1 | {{DECISION_CHECK_1}} | {{IMPLEMENTATION_NOTE_1}} |\n|    2 | {{DECISION_CHECK_2}} | {{IMPLEMENTATION_NOTE_2}} |\n|    3 | {{DECISION_CHECK_3}} | {{IMPLEMENTATION_NOTE_3}} |\n\n### 4.2 Instance Checks\n\nImplementation MAY rely on runtime instance checks\nas constrained by the specifications assumptions.\n\n{{INSTANCE_CHECK_DESCRIPTION}}\n\n### 4.3 Performance Constraints\n\n- Time Complexity: {{TIME_COMPLEXITY}}\n- Space Complexity: {{SPACE_COMPLEXITY}}\n- {{OTHER_CONSTRAINTS}}\n\n---\n\n## 5. Dependencies\n\n### 5.1 Internal Dependencies\n\n| Module             | Purpose           |\n| ------------------ | ----------------- |\n| {{INTERNAL_DEP_1}} | {{DEP_PURPOSE_1}} |\n| {{INTERNAL_DEP_2}} | {{DEP_PURPOSE_2}} |\n\n### 5.2 External Dependencies\n\n- None (zero-dependency requirement)\n\n---\n\n## 6. Error Handling\n\n### 6.1 Error Cases\n\n| Condition        | Behavior       |\n| ---------------- | -------------- |\n| {{ERROR_CASE_1}} | {{BEHAVIOR_1}} |\n| {{ERROR_CASE_2}} | {{BEHAVIOR_2}} |\n\n### 6.2 Error Strategy\n\n{{ERROR_STRATEGY_DESCRIPTION}}\n\n---\n\n## 7. Specifications Traceability\n\n| Spec Section   | Implementation Section |\n| -------------- | ---------------------- |\n| {{SPEC_REF_1}} | {{IMPL_REF_1}}         |\n| {{SPEC_REF_2}} | {{IMPL_REF_2}}         |\n\n---\n\n## 8. Change History\n\n| Date     | Version | Description            |\n| -------- | ------- | ---------------------- |\n| {{DATE}} | 1.0     | Initial implementation |\n",
        "plugins/deckrd/skills/deckrd/assets/templates/requirements.template.md": "---\ntitle: \"Requirements: {{FEATURE_NAME}}\"\nModule: \"{{ MODULE_OR_DOMAIN }}\"\nStatus: Draft\nVersion: 1.0\nCreated: \"{{ DATE }}\"\n---\n\n> **Normative Statement**\n> This document defines binding requirements.\n> Implementations MUST conform to this document.\n> RFC 2119 keywords apply to this document only.\n\n## 1. Overview\n\n### 1.1 Purpose\n\n{{PURPOSE}}\n\n### 1.2 Scope\n\n{{IN_SCOPE}}\n\n**Out of Scope**:\n{{OUT_OF_SCOPE}}\n\n## 2. Context\n\n- Target Environment: {{ENVIRONMENT}}\n- Related Components: {{RELATED_COMPONENTS}}\n- Assumptions: {{ASSUMPTIONS}}\n\n## 3. Design Decisions (Summary)\n\n| ID    | Decision               | Linked Record            |\n| ----- | ---------------------- | ------------------------ |\n| DR-01 | {{DECISION_SUMMARY_1}} | decision-record.md#DR-01 |\n| DR-02 | {{DECISION_SUMMARY_2}} | decision-record.md#DR-02 |\n\n## 4. Functional Requirements\n\n- FR-01: SHALL {{REQUIREMENT_1}}\n- FR-02: SHALL {{REQUIREMENT_2}}\n\n## 5. Non-Functional Requirements\n\n### 5.1 Quality\n\n- Maintainability\n- Testability\n- Portability\n\n### 5.2 Constraints\n\n{{CONSTRAINTS}}\n\n## 6. Change History\n\n| Date     | Version | Description     |\n| -------- | ------- | --------------- |\n| {{DATE}} | 1.0     | Initial release |\n",
        "plugins/deckrd/skills/deckrd/assets/templates/review-explore.template.md": "---\ntitle: \"Review: {{DOCUMENT_NAME}}\"\nphase: explore\npersona: Design Reviewer\ndocument: \"{{DOCUMENT_PATH}}\"\ndate: \"{{DATE}}\"\nstatus: draft\n---\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n\n> **Explore Review Report**\n> Persona: Design Reviewer\n> Purpose: Initial exploration, identify gaps and alternatives\n\n## 1. Summary\n\n- Document Reviewed: {{DOCUMENT_PATH}}\n- Document Type: {{DOCUMENT_TYPE}}\n- Total Questions: {{TOTAL_QUESTIONS}}\n- Total Concerns: {{TOTAL_CONCERNS}}\n\n## 2. Questions & Concerns\n\nQuestions and observations raised during exploration.\n\n### 2.1 Completeness\n\nAre all scenarios covered?\n\n{{COMPLETENESS_QUESTIONS}}\n\n### 2.2 Ambiguity\n\nAre terms clearly defined?\n\n{{AMBIGUITY_QUESTIONS}}\n\n### 2.3 Alternatives\n\nWhat other approaches exist?\n\n{{ALTERNATIVES_QUESTIONS}}\n\n### 2.4 Assumptions\n\nAre implicit assumptions stated?\n\n{{ASSUMPTIONS_QUESTIONS}}\n\n## 3. Ambiguous Terms\n\n| Term     | Context     | Clarification Needed |\n| -------- | ----------- | -------------------- |\n| {{TERM}} | {{CONTEXT}} | {{CLARIFICATION}}    |\n\n{{AMBIGUOUS_TERMS_TABLE}}\n\n## 4. Alternatives to Explore\n\n### ALT-01: {{ALTERNATIVE_TITLE}}\n\n- Current approach: {{CURRENT_APPROACH}}\n- Alternative: {{ALTERNATIVE_DESCRIPTION}}\n- Trade-offs: {{TRADE_OFFS}}\n- Consider exploring: {{EXPLORATION_SUGGESTION}}\n\n{{ADDITIONAL_ALTERNATIVES}}\n\n## 5. Implicit Assumptions\n\nAssumptions identified that should be made explicit.\n\n### A-01: {{ASSUMPTION_TITLE}}\n\n- Assumption: {{ASSUMPTION_DESCRIPTION}}\n- Location: {{SECTION_REFERENCE}}\n- Risk if incorrect: {{RISK_DESCRIPTION}}\n- Suggestion: Consider stating explicitly\n\n{{ADDITIONAL_ASSUMPTIONS}}\n\n## 6. Gaps Identified\n\nAreas where coverage may be incomplete.\n\n### G-01: {{GAP_TITLE}}\n\n- Area: {{GAP_AREA}}\n- Missing: {{MISSING_DESCRIPTION}}\n- Impact: {{IMPACT_DESCRIPTION}}\n- Suggestion: {{GAP_SUGGESTION}}\n\n{{ADDITIONAL_GAPS}}\n\n## 7. Review Metadata\n\n- Reviewer: AI (deckrd review --phase explore)\n- Review Phase: explore\n- Review Date: {{DATE}}\n- Document Version Reviewed: {{DOCUMENT_VERSION}}\n",
        "plugins/deckrd/skills/deckrd/assets/templates/review-fix.template.md": "---\ntitle: \"Review: {{DOCUMENT_NAME}}\"\nphase: fix\npersona: Spec Auditor\ndocument: \"{{DOCUMENT_PATH}}\"\ndate: \"{{DATE}}\"\nstatus: draft\n---\n\n> **Fix Review Report**\n> Persona: Spec Auditor\n> Purpose: Final cleanup, ensure consistency\n\n## 1. Summary\n\n- Document Reviewed: {{DOCUMENT_PATH}}\n- Document Type: {{DOCUMENT_TYPE}}\n- Terminology Issues: {{TERMINOLOGY_COUNT}}\n- Testability Issues: {{TESTABILITY_COUNT}}\n- Structure Issues: {{STRUCTURE_COUNT}}\n- Cross-Reference Issues: {{CROSSREF_COUNT}}\n- Typo/Grammar Fixes: {{TYPO_COUNT}}\n\n## 2. Terminology Inconsistencies\n\nSame concepts should use same terms throughout.\n\n| Current Term | Recommended Term | Occurrences | Locations     |\n| ------------ | ---------------- | ----------- | ------------- |\n| {{TERM_A}}   | {{TERM_B}}       | {{COUNT}}   | {{LOCATIONS}} |\n\n{{TERMINOLOGY_TABLE}}\n\n### T-01: {{INCONSISTENCY_TITLE}}\n\n- Terms used: {{TERM_VARIANTS}}\n- Recommended: {{RECOMMENDED_TERM}}\n- Rationale: {{RATIONALE}}\n- Locations to fix:\n  - {{LOCATION_1}}\n  - {{LOCATION_2}}\n\n{{ADDITIONAL_TERMINOLOGY_ISSUES}}\n\n## 3. Testability Issues\n\nRequirements that cannot be objectively verified.\n\n### TS-01: {{REQUIREMENT_ID}}\n\n- Original: {{ORIGINAL_TEXT}}\n- Issue: {{TESTABILITY_ISSUE}}\n- Suggested revision: {{SUGGESTED_REVISION}}\n- Verification method: {{VERIFICATION_METHOD}}\n\n{{ADDITIONAL_TESTABILITY_ISSUES}}\n\n## 4. Structure Normalization\n\nFormatting and organization improvements.\n\n### S-01: {{STRUCTURE_ISSUE_TITLE}}\n\n- Location: {{SECTION_REFERENCE}}\n- Issue: {{STRUCTURE_ISSUE}}\n- Fix: {{STRUCTURE_FIX}}\n\n{{ADDITIONAL_STRUCTURE_ISSUES}}\n\n## 5. Cross-Reference Validation\n\nInvalid or missing references.\n\n### CR-01: {{CROSSREF_ISSUE_TITLE}}\n\n- Location: {{SECTION_REFERENCE}}\n- Reference: {{REFERENCE_TEXT}}\n- Issue: {{CROSSREF_ISSUE}}\n- Fix: {{CROSSREF_FIX}}\n\n{{ADDITIONAL_CROSSREF_ISSUES}}\n\n## 6. Typo & Grammar Fixes\n\n| Location     | Original     | Corrected     |\n| ------------ | ------------ | ------------- |\n| {{LOCATION}} | {{ORIGINAL}} | {{CORRECTED}} |\n\n{{TYPO_TABLE}}\n\n## 7. Review Metadata\n\n- Reviewer: AI (deckrd review --phase fix)\n- Review Phase: fix\n- Review Date: {{DATE}}\n- Document Version Reviewed: {{DOCUMENT_VERSION}}\n",
        "plugins/deckrd/skills/deckrd/assets/templates/review-harden.template.md": "---\ntitle: \"Review: {{DOCUMENT_NAME}}\"\nphase: harden\npersona: Normative Requirements Reviewer\ndocument: \"{{DOCUMENT_PATH}}\"\ndate: \"{{DATE}}\"\nstatus: draft\n---\n\n> **Harden Review Report**\n> Persona: Normative Requirements Reviewer\n> Purpose: Harden requirements, make definitive decisions\n\n## 1. Summary\n\n- Document Reviewed: {{DOCUMENT_PATH}}\n- Document Type: {{DOCUMENT_TYPE}}\n- Promotions: {{PROMOTION_COUNT}}\n- WHEN Extractions: {{WHEN_COUNT}}\n- Gap Fills: {{GAP_FILL_COUNT}}\n- Decision Records Generated: {{DR_COUNT}}\n\n## 2. SHOULD to MUST Promotions\n\nRequirements promoted from SHOULD to MUST with justification.\n\n### P-01: {{REQUIREMENT_ID}} Promotion\n\n- Original: SHOULD {{ORIGINAL_TEXT}}\n- Promoted: MUST {{PROMOTED_TEXT}}\n- Justification: {{JUSTIFICATION}}\n- Evidence: {{EVIDENCE}}\n- DR Reference: DR-{{DR_NUMBER}}\n\n{{ADDITIONAL_PROMOTIONS}}\n\n## 3. WHEN Condition Extractions\n\nConditions extracted from ambiguous statements.\n\n### W-01: {{REQUIREMENT_ID}} Condition\n\n- Original: {{ORIGINAL_TEXT}}\n- Extracted condition: WHEN {{CONDITION}}\n- Revised: WHEN {{CONDITION}}, {{REQUIREMENT}} {{MODAL}} {{ACTION}}\n- Rationale: {{RATIONALE}}\n\n{{ADDITIONAL_WHEN_EXTRACTIONS}}\n\n## 4. Gap-Filling Requirements\n\nNew requirements added to fill identified gaps.\n\n### GF-01: New Requirement\n\n- Gap identified: {{GAP_DESCRIPTION}}\n- New requirement: {{NEW_REQUIREMENT_ID}}: {{MODAL}} {{REQUIREMENT_TEXT}}\n- Category: {{CATEGORY}}\n- Rationale: {{RATIONALE}}\n- DR Reference: DR-{{DR_NUMBER}}\n\n{{ADDITIONAL_GAP_FILLS}}\n\n## 5. Decision Records\n\n### DR-XX: {{DECISION_TITLE}}\n\n**Phase**: review-harden\n**Status**: Accepted\n\n### Context\n\n{{DR_CONTEXT}}\n\n### Decision\n\n{{DR_DECISION}}\n\n### Alternatives Considered\n\n- Option A: {{OPTION_A}}\n- Option B: {{OPTION_B}}\n\n### Rationale\n\n{{DR_RATIONALE}}\n\n### Consequences\n\n- Positive:\n  - {{POSITIVE_CONSEQUENCE}}\n- Negative:\n  - {{NEGATIVE_CONSEQUENCE}}\n\n---\n\n{{ADDITIONAL_DR_ENTRIES}}\n\n## 6. Review Metadata\n\n- Reviewer: AI (deckrd review --phase harden)\n- Review Phase: harden\n- Review Date: {{DATE}}\n- Document Version Reviewed: {{DOCUMENT_VERSION}}\n- Total DRs Generated: {{DR_COUNT}}\n",
        "plugins/deckrd/skills/deckrd/assets/templates/specifications.template.md": "---\ntitle: \"Design Specification: {{FEATURE_NAME}}\"\nBased on: requirements.md v{{REQ_VERSION}}\nStatus: Draft\n---\n\n## 1. Overview\n\n### 1.1 Purpose\n\n{{WHAT_THIS_SPEC_DEFINES}}\n\n### 1.2 Scope\n\nThis specification defines the **behavioral rules** and\n**classification semantics** of {{FEATURE_NAME}}.\n\nImplementation details are explicitly out of scope.\n\n---\n\n## 2. Design Principles\n\n### 2.1 Classification Philosophy\n\n{{DESIGN_PHILOSOPHY}}\n\n### 2.2 Design Assumptions\n\n{{DESIGN_ASSUMPTIONS}}\n\n### 2.3 Non-Goals\n\n> **Derivation**: All items below originate from REQUIREMENTS Section \"Out of Scope\".\n\n- {{NON_GOAL_1}} ← REQ: Out of Scope #1\n- {{NON_GOAL_2}} ← REQ: Out of Scope #2\n\n<!-- If REQUIREMENTS has no Out of Scope section: -->\n<!-- > \"No Non-Goals defined in source REQUIREMENTS.\" -->\n\n### 2.4 Behavioral Design Decisions\n\n| ID    | Decision | Rationale | Affected Rules | Status           |\n| ----- | -------- | --------- | -------------- | ---------------- |\n| DD-01 | ...      | ...       | Rule 4.x       | Active           |\n\n> **Note**: Decisions listed here derive from REQUIREMENTS Design Decisions.\n> If promoting to formal Decision Record, use `/deckrd dr --add`.\n\n**Status Values:**\n\n- `Active` — Currently in effect within this specification\n- `Promoted → DR-xx` — Elevated to formal Decision Record (see Section 2.5)\n\n<!-- If no DD exists in REQUIREMENTS: -->\n<!-- > \"No Design Decisions defined in source REQUIREMENTS.\" -->\n\n### 2.5 Related Decision Records\n\n> **Reference**: This section lists formal DRs that affect this specification.\n> DRs are maintained in `decision-records.md` and are authoritative.\n\n| DR-ID | Title        | Phase | Impact on This Spec    |\n| ----- | ------------ | ----- | ---------------------- |\n| DR-xx | {{DR_TITLE}} | spec  | {{IMPACT_DESCRIPTION}} |\n\n<!-- If no related DRs: -->\n<!-- > \"No Decision Records currently affect this specification.\" -->\n\n### 2.6 DD to DR Promotion Criteria\n\n> **Purpose**: Guidelines for determining when a DD should be promoted to a formal DR.\n> Promotion is a **human judgment** — these criteria inform, not automate.\n\n**Consider promoting a DD when:**\n\n1. **Cross-specification Impact** — The decision affects multiple specifications or modules\n2. **Architectural Significance** — The decision constrains future design choices\n3. **Non-trivial Alternatives** — Multiple viable options existed\n4. **Stakeholder Visibility Required** — The decision should be reviewable by external parties\n\n**Keep as DD when:**\n\n- Decision is local to this specification only\n- No significant alternatives existed\n- Rationale is self-evident from context\n\n> **Action**: To promote, run `/deckrd dr --add` with the DD context,\n> then update DD Status to `Promoted → DR-xx`.\n\n---\n\n## 3. Behavioral Specification\n\n### 3.1 Input Domain\n\n- Input Type: {{INPUT_TYPE}}\n- Assumptions: {{INPUT_ASSUMPTIONS}}\n\n### 3.2 Output Semantics\n\n- Output Meaning: {{OUTPUT_MEANING}}\n- Possible Outcomes:\n  - {{OUTCOME_1}}\n  - {{OUTCOME_2}}\n\n---\n\n## 4. Decision Rules\n\nEvaluation MUST follow this order:\n\n| Step | Condition       | Outcome      |\n| ---: | --------------- | ------------ |\n|    1 | {{CONDITION_1}} | {{RESULT_1}} |\n|    2 | {{CONDITION_2}} | {{RESULT_2}} |\n|    3 | {{CONDITION_3}} | {{RESULT_3}} |\n\n<!-- Add or remove steps as required -->\n\nNo reordering is permitted.\n\n---\n\n## 5. Edge Cases\n\n| Input      | Classification | Rationale |\n| ---------- | -------------- | --------- |\n| {{EDGE_1}} | {{RESULT_1}}   | {{WHY_1}} |\n| {{EDGE_2}} | {{RESULT_2}}   | {{WHY_2}} |\n\n---\n\n## 6. Requirements Traceability\n\n| Requirement ID | Covered By        |\n| -------------- | ----------------- |\n| {{FR_1}}       | {{SECTION_REF_1}} |\n| {{FR_2}}       | {{SECTION_REF_2}} |\n\n---\n\n## 7. Open Questions\n\n> **Status**: [COMPLETE | INCOMPLETE]\n\n| #   | Question            | Source  | Impact       |\n| --- | ------------------- | ------- | ------------ |\n| 1   | {{OPEN_QUESTION_1}} | {{REF}} | {{IMPACT_1}} |\n\n<!-- If none: \"None identified - all requirements are unambiguous.\" -->\n\n---\n\n## 8. Change History\n\n| Date     | Version | Description           |\n| -------- | ------- | --------------------- |\n| {{DATE}} | 1.0     | Initial specification |\n",
        "plugins/deckrd/skills/deckrd/assets/templates/tasks.template.md": "---\ntitle: \"Implementation Tasks\"\nmodule: \"{{ MODULE }}\"\nstatus: Active\ncreated: \"{{ YYYY-MM-DD HH:MM:SS }}\"\nsource: specifications.md\n---\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- textlint-disable ja-technical-writing/max-comma -->\n<!-- markdownlint-disable no-duplicate-heading line-length -->\n\n> This document contains implementation tasks derived from specifications.\n> Each task corresponds to a single unit test case (`it()` block).\n\n---\n\n## Task Summary\n\n| Test Target             | Scenarios          | Cases          | Status      |\n| ----------------------- | ------------------ | -------------- | ----------- |\n| T-01: {{TEST_TARGET_1}} | {{SCENARIO_COUNT}} | {{CASE_COUNT}} | in progress |\n| T-02: {{TEST_TARGET_2}} | {{SCENARIO_COUNT}} | {{CASE_COUNT}} | pending     |\n\n<!-- Status may be: pending | in progress | done -->\n\n---\n\n## T-01: {{TEST_TARGET_1}}\n\n### [正常] Normal Cases\n\n#### T-01-01: {{GIVEN_WHEN_SCENARIO_1}}\n\n- [ ] **T-01-01-01**: {{TEST_CASE_DESCRIPTION}}\n  - Target: `{{FUNCTION_NAME}}`\n  - Scenario: Given {{PRECONDITION}}, When {{ACTION}}\n  - Expected: Then {{ASSERTION}}\n\n- [ ] **T-01-01-02**: {{TEST_CASE_DESCRIPTION}}\n  - Target: `{{FUNCTION_NAME}}`\n  - Scenario: Given {{PRECONDITION}}, When {{ACTION}}\n  - Expected: Then {{ASSERTION}}\n\n#### T-01-02: {{GIVEN_WHEN_SCENARIO_2}}\n\n- [ ] **T-01-02-01**: {{TEST_CASE_DESCRIPTION}}\n  - Target: `{{FUNCTION_NAME}}`\n  - Scenario: Given {{PRECONDITION}}, When {{ACTION}}\n  - Expected: Then {{ASSERTION}}\n\n### [異常] Error Cases\n\n#### T-01-03: {{ERROR_SCENARIO}}\n\n- [ ] **T-01-03-01**: {{ERROR_TEST_DESCRIPTION}}\n  - Target: `{{FUNCTION_NAME}}`\n  - Scenario: Given {{ERROR_PRECONDITION}}, When {{ACTION}}\n  - Expected: Then {{ERROR_ASSERTION}}\n\n### [エッジケース] Edge Cases\n\n#### T-01-04: {{EDGE_CASE_SCENARIO}}\n\n- [ ] **T-01-04-01**: {{EDGE_CASE_DESCRIPTION}}\n  - Target: `{{FUNCTION_NAME}}`\n  - Scenario: Given {{EDGE_PRECONDITION}}, When {{ACTION}}\n  - Expected: Then {{EDGE_ASSERTION}}\n\n---\n\n## T-02: {{TEST_TARGET_2}}\n\n### [正常] Normal Cases\n\n#### T-02-01: {{GIVEN_WHEN_SCENARIO}}\n\n- [ ] **T-02-01-01**: {{TEST_CASE_DESCRIPTION}}\n  - Target: `{{FUNCTION_NAME}}`\n  - Scenario: Given {{PRECONDITION}}, When {{ACTION}}\n  - Expected: Then {{ASSERTION}}\n\n---\n\n<!--\nTask ID Format: T-<TestTarget>-<Scenario>-<Case>\n- TestTarget: 2-digit (01, 02, ...)\n- Scenario: 2-digit (01, 02, ...)\n- Case: 2-digit (01, 02, ...)\n\nExample: T-01-02-03 = TestTarget 01, Scenario 02, Case 03\n-->\n",
        "plugins/deckrd/skills/deckrd/references/commands/dr.md": "# dr Command\n\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- markdownlint-disable line-length -->\n\nManage Decision Records (DR) for the active module.\n\nDecision Records are non-normative, append-only records of decisions\nmade during any phase of the development process (req, spec, impl, tasks).\n\n## Usage\n\n```bash\n/deckrd dr           # Display help and current module status\n/deckrd dr --add     # Append a new Decision Record\n```\n\n## Command Modes\n\n### Help Mode (no flags)\n\n```bash\n/deckrd dr\n```\n\n**Behavior:**\n\n- Display current active module and step\n- Show usage information\n- **DO NOT create or modify any files**\n\n**Output Example:**\n\n```bash\nDecision Records (DR) - deckrd\n\nActive Module: agtKind/isSingleValue\nCurrent Step: req\n\nUsage:\n  deckrd dr         Show this help\n  deckrd dr --add   Append a new Decision Record\n\nNote: DRs can be added during any step (req, spec, impl, tasks).\n      For 'tasks' step, confirmation will be requested.\n```\n\n### Add Mode\n\n```bash\n/deckrd dr --add\n```\n\n**Preconditions (STRICT):**\n\n- Session must exist at `docs/.deckrd/.session.json`\n- `session.active` must be set\n- `session.modules[active]` must exist\n- `session.modules[active].current_step` must be one of: `\"req\"`, `\"spec\"`, `\"impl\"`, `\"tasks\"`\n\n**If `current_step === \"tasks\"`:**\n\nPrompt user for confirmation:\n\n```bash\nYou are in the 'tasks' step.\nDo you want to record this decision? (yes/no):\n```\n\n- If user responds `no` (or n, N, NO): Exit without creating or modifying files\n- If user responds `yes` (or y, Y, YES): Proceed with DR creation\n\n**If `current_step` is invalid (not req/spec/impl/tasks):**\n\n```bash\nError: Invalid step '<current_step>'.\nDR can be added during: req, spec, impl, tasks\n```\n\nExit with error. Do NOT create or modify files.\n\n## Session Resolution\n\n**Session file location:**\n\n```bash\ndocs/.deckrd/.session.json\n```\n\n**Required fields:**\n\n```json\n{\n  \"active\": \"<moduleId>\",\n  \"modules\": {\n    \"<moduleId>\": {\n      \"current_step\": \"req\",\n      \"path\": \"docs/.deckrd/<namespace>/<module>\"\n    }\n  }\n}\n```\n\n**Path resolution:**\n\n- moduleId = `session.active`\n- modulePath = `session.modules[moduleId].path`\n- Decision Records file = `<modulePath>/decision-records.md`\n\n## Decision Records File\n\n**Location:**\n\n```bash\n<modulePath>/decision-records.md\n```\n\n**If file does NOT exist**, create with front matter:\n\n```yaml\n---\ntitle: Decision Records\nmodule: <moduleId>\nstatus: Active\ncreated: <ISO-8601 date>\n---\n```\n\n**If file exists**, parse and validate front matter:\n\n- If `front_matter.module !== moduleId`: emit WARNING only, do NOT auto-fix\n\n## DR-ID Strategy\n\nDR-IDs are sequential per module: DR-01, DR-02, ...\n\n**Procedure:**\n\n1. Scan existing `decision-records.md`\n2. Find all headings matching: `## DR-<number>`\n3. Determine max number\n4. New DR-ID = max + 1\n\n## Prompt & Template\n\nUse prompt and template for generating DR content:\n\n```bash\ndeckrd/assets/\n       ├── prompts/decision-record.prompt.md\n       └── templates/decision-record.template.md\n```\n\n## Append Rules\n\n- **Append only** - no edits, no rewrites\n- Append to the **END** of the file\n- Use the established DR template structure\n- Do NOT include implementation code\n- Do NOT restate requirements\n- Capture only finalized decisions\n\n**DR Section Format:**\n\n```markdown\n## DR-<ID>: <Decision Title> - <YYYY-MM-DD HH:MM:SS>\n\n**Phase**: <current_step>\n**Status**: Accepted\n\n### Context\n\n<why this decision was needed>\n\n### Decision\n\n<what was decided>\n\n### Alternatives Considered\n\n- Option A: ...\n- Option B: ...\n\n### Rationale\n\n<why this option was chosen>\n\n### Consequences\n\n- Positive:\n  - ...\n\n- Negative:\n  - ...\n\n---\n```\n\n## Error Handling\n\n| Condition                                   | Action                          |\n| ------------------------------------------- | ------------------------------- |\n| No session file                             | Error, exit with non-zero       |\n| No active module                            | Error, exit with non-zero       |\n| `current_step` not in (req/spec/impl/tasks) | Error with message, no file ops |\n| User declines in tasks step                 | Exit gracefully, no file ops    |\n| Module path mismatch in front               | Warning only, proceed           |\n\n**Error Philosophy:**\n\n- Fail fast\n- No partial writes\n- No silent fallbacks\n- Prefer explicit errors over guessing\n\n## Non-Goals\n\n- Do NOT auto-summarize chat history\n- Do NOT generate DRs implicitly\n- Do NOT support DR editing or deletion\n- Do NOT skip confirmation for tasks step\n\n## Workflow Integration\n\nDRs can be created during any step when explicitly requested.\nConfirmation is required for the `tasks` step.\n\n```bash\ninit ──> req (DR allowed) ──> spec (DR allowed) ──> impl (DR allowed) ──> tasks (DR allowed with confirmation)\n```\n\n## AI Interaction Engine\n\nDeckrd commands rely on an AI interaction engine to derive documents\nfrom user input and interaction logs.\n\nThe provided scripts invoke this engine and are required for normal\nDeckrd operation, rather than serving as optional reference implementations.\n\nExecute: [run-prompt.sh](../../scripts/run-prompt.sh)\n\nFor `--add` mode:\n\n```bash\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/run-prompt.sh decision-record <user_context> [--lang <lang>] --output \"decision-records.md\" --append\n```\n",
        "plugins/deckrd/skills/deckrd/references/commands/impl.md": "# impl Command\n\n<!-- markdownlint-disable line-length -->\n\nDerive an implementation plan defining code-level constraints and contracts from specifications.\n\n```bash\nDECKRD_ROOT=\"./docs/\"\n```\n\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n\n## Usage\n\n```bash\n/deckrd impl\n```\n\n## Preconditions\n\n- Session must exist with active module\n- `spec` must be completed for active module\n- `specifications/specifications.md` must exist\n\n## Input\n\nRead specifications document from session's active module:\n\n```bash\ndocs/.deckrd/<namespace>/<module>/specifications/specifications.md\n```\n\nThe `@` prefix indicates file reference:\n\n```bash\n/deckrd impl @specifications/specifications.md\n```\n\n## Output\n\nCreate: `docs/.deckrd/<namespace>/<module>/implementation/implementation.md`\n\n## Prompt & Documents\n\nUse prompt and template for writing implementation.md\n\n> Note:\n> Implementation defines **code contracts and constraints**.\n> It bridges specifications to executable code.\n\n```bash\ndeckrd/assets/\n       ├── prompts/implementation.prompt.md\n       └── templates/implementation.template.md\n```\n\n## Script\n\nExecute: [run-prompt.sh](../../scripts/run-prompt.sh)\n\n```bash\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/run-prompt.sh impl @specifications/specifications.md [--lang <lang>] --output \"implementation/implementation.md\"\n```\n\n> **Note**: The `@` prefix resolves to the active module's document path:\n> `docs/.deckrd/<namespace>/<module>/specifications/specifications.md`\n\n## Session Update\n\nAfter completion, update `.session.json`:\n\n```json\n{\n  \"current_step\": \"impl\",\n  \"completed\": [\"init\", \"req\", \"spec\", \"impl\"],\n  \"documents\": {\n    \"requirements\": \"requirements.md\",\n    \"specifications\": \"specifications.md\",\n    \"implementation\": \"implementation.md\"\n  }\n}\n```\n\n## Next Step\n\nRun `tasks` to derive executable tasks from implementation plan.\n",
        "plugins/deckrd/skills/deckrd/references/commands/init.md": "# init Command\n\nInitialize module directory structure and session.\n\n## Usage\n\n```bash\n# Base directory initialization only\n/deckrd init\n\n# Full module initialization\n/deckrd init [--lang <lang>] [--ai-model <model>] <namespace>/<module>\n```\n\n## Options\n\n| Option               | Default  | Description                                                      |\n| -------------------- | -------- | ---------------------------------------------------------------- |\n| `--lang <lang>`      | `system` | Document language: `system`, `en`, `ja`                          |\n| `--ai-model <model>` | `sonnet` | AI model: `gpt-*`, `o1-*`, `claude-*`, `haiku`, `sonnet`, `opus` |\n\n## Example\n\n```bash\n# Base directory only (no module)\n/deckrd init\n\n# Default settings (system language, sonnet model)\n/deckrd init AGTKind/isCollection\n\n# Specify Japanese language\n/deckrd init --lang ja AGTKind/isCollection\n\n# Specify AI model\n/deckrd init --ai-model claude-sonnet-4-5 AGTKind/isCollection\n\n# Specify both language and model\n/deckrd init --lang en --ai-model gpt-4o AGTKind/isCollection\n```\n\n## Actions\n\n### Without module parameter (base initialization)\n\n1. Create base directory structure:\n\n   ```bash\n   docs/.deckrd/\n   ├── notes/\n   └── temp/\n   ```\n\n2. Copy template files from `assets/inits/` to `docs/.deckrd/`\n\n### With module parameter (full initialization)\n\n1. Create base directory structure (same as above)\n\n2. Create module directory structure:\n\n   ```bash\n   docs/.deckrd/<namespace>/<module>/\n   ├── requirements/\n   ├── specifications/\n   ├── implementation/\n   └── tasks/\n   ```\n\n3. Initialize or update `.session.json`:\n\n   ```json\n   {\n     \"active\": \"<namespace>/<module>\",\n     \"lang\": \"system\",\n     \"ai_model\": \"sonnet\",\n     \"created_at\": \"<timestamp>\",\n     \"updated_at\": \"<timestamp>\",\n     \"modules\": {\n       \"<namespace>/<module>\": {\n         \"current_step\": \"init\",\n         \"completed\": [\"init\"],\n         \"documents\": {}\n       }\n     }\n   }\n   ```\n\n## Script\n\nExecute: [scripts/init-dirs.sh](../../scripts/init-dirs.sh)\n\n```bash\n# Base initialization only\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/init-dirs.sh\n\n# Full module initialization\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/init-dirs.sh [--lang <lang>] [--ai-model <model>] <namespace>/<module>\n```\n\n> **Note**: `${CLAUDE_PLUGIN_ROOT}` resolves to the plugin installation directory.\n> For local projects, this is `.claude/skills/deckrd`.\n\n## Next Step\n\n- Without module: Base directory is ready. Run `init` again with module parameter to start a project.\n- With module: Prompt user for requirements input, then run `req`.\n",
        "plugins/deckrd/skills/deckrd/references/commands/req.md": "# req Command\n\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n<!-- markdownlint-disable line-length -->\n\nDerive a normative requirements document from the user's goals, ideas, and constraints.\n\n## Usage\n\n```bash\n/deckrd req <your requirements or goals by free-form text>\n```\n\n## Preconditions\n\n- Session must exist with active module\n- `init` must be completed for active module\n\n## Input\n\nUser provides goals, ideas, or problem description in free-form text.\n\n**Prompt user for:**\n\n- What problem are you trying to solve?\n- What are your goals?\n- Any constraints or preferences?\n\n## Output\n\nCreate: `docs/.deckrd/<namespace>/<module>/requirements/requirements.md`\n\n## Prompt & Documents\n\nuse prompt,template for write requirements.md\n\n> Note:\n> Requirements documents define **normative intent and constraints**.\n> Only stated requirements and constraints are normative; examples and explanations are illustrative.\n\n```bash\ndeckrd/assets/\n       ├── prompts/requirements.prompt.md\n       └── templates/requirements.template.md\n```\n\n## Script\n\nExecute: [run_prompt.sh](../../scripts/run-prompt.sh)\n\n```bash\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/run_prompt.sh requirements <user_input> [--lang <lang>] --output \"requirements/requirements.md\"\n```\n\n## Session Update\n\nAfter completion, update `.session.json`:\n\n```json\n{\n  \"current_step\": \"req\",\n  \"completed\": [\"init\", \"req\"],\n  \"documents\": {\n    \"requirements\": \"requirements.md\"\n  }\n}\n```\n\n## Next Step\n\nRun `spec` to derive specifications from requirements.\n",
        "plugins/deckrd/skills/deckrd/references/commands/review.md": "# review Command\n\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n<!-- textlint-disable ja-technical-writing/sentence-length -->\n<!-- markdownlint-disable line-length -->\n\nReview documents with phase-specific analysis for design maturation.\n\nThe `review` command supports three review phases (explore/harden/fix) that control\nthe reviewer persona and allowed operations, enabling progressive hardening of\nrequirements and specifications.\n\n## Usage\n\n```bash\n/deckrd review                    # Display usage information\n/deckrd review usage              # Display usage information\n\n/deckrd review <doc_phase> [--phase <review_phase>]\n/deckrd review --phase <review_phase> [@document_path]\n```\n\n## Command Modes\n\n### Usage Mode (no args or \"usage\")\n\n```bash\n/deckrd review\n/deckrd review usage\n```\n\n**Behavior:**\n\n- Display usage information and available options\n- Show phase descriptions (explore/harden/fix)\n- Show document phase mappings (req/spec/impl/tasks)\n- **DO NOT execute any review or modify files**\n\n**Output Example:**\n\n```bash\nReview Command - deckrd\n\nReview documents with phase-specific analysis.\n\nUsage:\n  /deckrd review                              Show this help\n  /deckrd review <doc_phase> [--phase <p>]    Review document by phase\n  /deckrd review --phase <p> @<path>          Review specific document\n\nDocument Phases:\n  req     Review requirements/requirements.md\n  spec    Review specifications/specifications.md\n  impl    Review implementation/implementation.md\n  tasks   Review tasks/tasks.md\n\nReview Phases:\n  explore   Design Reviewer - identify gaps, alternatives (default)\n  harden    Normative Reviewer - promote to MUST/SHALL, generate DR\n  fix       Spec Auditor - normalize, verify consistency\n\nOptions:\n  --phase <p>       Review phase: explore, harden, fix (default: explore)\n  --output <file>   Output file path (default: stdout)\n  --lang <lang>     Output language (default: session setting)\n```\n\n### Review Mode\n\n```bash\n/deckrd review <doc_phase> [--phase <review_phase>]\n/deckrd review --phase <review_phase> [@document_path]\n```\n\n**Behavior:**\n\n- Execute document review with specified phase persona\n- Generate findings and recommendations\n- (harden only) Generate and append DR entries to decision-records.md\n\n## Arguments\n\n| Argument      | Description                          |\n| ------------- | ------------------------------------ |\n| usage         | Show usage information               |\n| `<doc_phase>` | req / spec / impl / tasks            |\n| `[@doc_path]` | @path/to/file.md (@ prefix required) |\n\n## Options\n\n| Option   | Required | Default | Description            |\n| -------- | -------- | ------- | ---------------------- |\n| --phase  | No*      | explore | explore / harden / fix |\n| --output | No       | stdout  | Output file path       |\n| --lang   | No       | session | Output language        |\n\n- When `doc_phase` is specified, `--phase` is optional (default: explore)\n- When `@doc_path` is specified, `--phase` is required\n\n## Argument Resolution\n\n**Resolution order:**\n\n1. No arguments or \"usage\":\n   → Display usage, exit\n\n2. First argument is req/spec/impl/tasks:\n   → Interpret as doc_phase, resolve to corresponding file\n\n3. First argument starts with @:\n   → Interpret as doc_path, --phase is required\n\n**Document phase to file mapping:**\n\n| Doc Phase | Resolved File                    |\n| --------- | -------------------------------- |\n| req       | requirements/requirements.md     |\n| spec      | specifications/specifications.md |\n| impl      | implementation/implementation.md |\n| tasks     | tasks/tasks.md                   |\n\n## Review Phases\n\n### explore Phase\n\n**Persona:** Design Reviewer\n\n**Purpose:** Initial exploration, identify gaps and alternatives\n\n**Rules:**\n\n- SHOULD / MAY language: Allowed\n- MUST / SHALL language: **PROHIBITED**\n- Decision Records: **PROHIBITED**\n\n**Focus areas:**\n\n- Completeness - are all scenarios covered?\n- Ambiguity - are terms clearly defined?\n- Alternatives - what other approaches exist?\n- Assumptions - are implicit assumptions stated?\n\n### harden Phase\n\n**Persona:** Normative Requirements Reviewer\n\n**Purpose:** Harden requirements, make definitive decisions\n\n**Rules:**\n\n- SHOULD / MAY language: Extract WHEN conditions\n- MUST / SHALL language: Promote where evidence supports\n- Decision Records: **REQUIRED** for each promotion\n\n**Focus areas:**\n\n- WHEN extraction - identify conditions for SHOULD statements\n- Promotion - upgrade SHOULD → MUST with justification\n- Gap filling - add missing normative requirements\n- DR generation - document each decision\n\n### fix Phase\n\n**Persona:** Spec Auditor\n\n**Purpose:** Final cleanup, ensure consistency\n\n**Rules:**\n\n- SHOULD / MAY language: **PROHIBITED** (no new soft requirements)\n- MUST / SHALL language: **PROHIBITED** (no new hard requirements)\n- Decision Records: **PROHIBITED**\n\n**Focus areas:**\n\n- Terminology consistency - same terms for same concepts\n- Testability verification - each requirement is testable\n- Structure normalization - consistent formatting\n- Cross-reference validation - all references valid\n\n## DR Integration (harden Phase Only)\n\nWhen review phase is `harden`:\n\n1. AI generates DR entries in standard format\n2. Script extracts DR sections from output\n3. DR entries are appended to `decision-records.md`\n4. DR-ID is auto-assigned (max existing + 1)\n\n**DR format in review output:**\n\n```markdown\n## Decision Records\n\n### DR-XX: Decision Title\n\n**Phase**: review-harden\n**Status**: Accepted\n\n### Context\n\nWhy this decision was needed during review\n\n### Decision\n\nWhat was decided (requirement promoted, gap filled, etc.)\n\n### Alternatives Considered\n\n- Option A: ...\n- Option B: ...\n\n### Rationale\n\nWhy this option was chosen\n\n### Consequences\n\n- Positive: ...\n- Negative: ...\n```\n\n## Preconditions (STRICT)\n\n- Session must exist at `docs/.deckrd/.session.json`\n- `session.active` must be set\n- Target document must exist\n- For `@path` syntax: `--phase` must be specified\n\n## Error Handling\n\n| Condition                 | Action                          |\n| ------------------------- | ------------------------------- |\n| No session file           | Error, exit with non-zero       |\n| No active module          | Error, exit with non-zero       |\n| Target document not found | Error with message, no file ops |\n| Invalid doc_phase         | Error with valid options        |\n| Invalid review_phase      | Error with valid options        |\n| @path without --phase     | Error, require --phase          |\n\n**Error Philosophy:**\n\n- Fail fast\n- No partial writes\n- No silent fallbacks\n- Prefer explicit errors over guessing\n\n## Examples\n\n```bash\n# Show usage\n/deckrd review\n/deckrd review usage\n\n# Review requirements with explore phase (default)\n/deckrd review req\n\n# Review requirements with harden phase (generates DR)\n/deckrd review req --phase harden\n\n# Review specifications with fix phase\n/deckrd review spec --phase fix\n\n# Review specific file with explicit phase\n/deckrd review --phase explore @requirements/requirements.md\n\n# Review with output file\n/deckrd review req --phase harden --output reviews/req-harden-2026-01-16.md\n```\n\n## Prompt & Documents\n\n### Prompt\n\nReview derives findings using the shared prompt file:\n\n```text\ndeckrd/assets/\n       └── prompts/review.prompt.md\n```\n\n### Templates (Phase-Specific)\n\nEach review phase uses a dedicated template:\n\n| Phase   | Template File                        |\n|---------|--------------------------------------|\n| explore | templates/review-explore.template.md |\n| harden  | templates/review-harden.template.md  |\n| fix     | templates/review-fix.template.md     |\n\n## AI Interaction Engine\n\nDeckrd commands rely on an AI interaction engine to derive documents\nfrom user input and interaction logs.\n\nExecute: [run-prompt.sh](../../scripts/run-prompt.sh)\n\nFor review mode:\n\n```bash\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/run-prompt.sh review @<document> --phase <phase> [--lang <lang>] [--output <file>]\n```\n",
        "plugins/deckrd/skills/deckrd/references/commands/spec.md": "# spec Command\n\n<!-- textlint-disable ja-technical-writing/no-exclamation-question-mark -->\n<!-- markdownlint-disable line-length -->\n\nDerive technically verifiable behavioral goals and constraints from requirements.\n\n## Usage\n\n```bash\n/deckrd spec\n```\n\n## Preconditions\n\n- Session must exist with active module\n- `req` must be completed for active module\n- `requirements/requirements.md` must exist\n\n## Input\n\nRead requirements document from session's active module:\n\n```bash\ndocs/.deckrd/<namespace>/<module>/requirements/requirements.md\n```\n\nThe `@` prefix indicates file reference:\n\n```bash\nspecifications @requirements/requirements.md\n```\n\n## Output\n\nCreate: `docs/.deckrd/<namespace>/<module>/specifications/specifications.md`\n\n## Prompt & Documents\n\nUse prompt and template for writing specifications.md\n\n> Note:\n> Specifications define **technical behavioral contracts**.\n> They bridge requirements to implementation planning, without prescribing code structure.\n\n```bash\ndeckrd/assets/\n       ├── prompts/specifications.prompt.md\n       └── templates/specifications.template.md\n```\n\n## Script\n\nExecute: [run-prompt.sh](../../scripts/run-prompt.sh)\n\n```bash\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/run-prompt.sh specifications @requirements/requirements.md [--lang <lang>] --output \"specifications/specifications.md\"\n```\n\n> **Note**:\n> The `@` prefix resolves to the active module's document path:\n> `docs/.deckrd/<namespace>/<module>/requirements/requirements.md`\n\n## Session Update\n\nAfter completion, update `.session.json`:\n\n```json\n{\n  \"current_step\": \"spec\",\n  \"completed\": [\"init\", \"req\", \"spec\"],\n  \"documents\": {\n    \"requirements\": \"requirements.md\",\n    \"specifications\": \"specifications.md\"\n  }\n}\n```\n\n## Next Step\n\nRun `impl` to derive implementation plan from specifications.\n",
        "plugins/deckrd/skills/deckrd/references/commands/status.md": "# status Command\n\nDisplay the current status of the active module and workflow progress.\n\n## Usage\n\n```bash\n/deckrd status\n```\n\n## Overview\n\nThe `status` command shows:\n\n- Current active module (`<namespace>/<module>`)\n- Current workflow step (req, spec, impl, tasks)\n- Completed steps\n- Module path\n- Session metadata\n\n## Output Example\n\n```bash\nDECKRD Status\n=============\n\nActive Module: AGTKind/isCollection\nCurrent Step:  spec\nCompleted:     init, req\n\nModule Path:   docs/.deckrd/AGTKind/isCollection\n\nConfiguration:\n  Language:    ja\n  AI Model:    claude-sonnet-4-5\n\nSession Info:\n  Created:     2025-01-15T10:00:00Z\n  Updated:     2025-01-15T14:30:00Z\n\nWorkflow Progress:\n  [✓] init\n  [✓] req\n  [•] spec\n  [ ] impl\n  [ ] tasks\n```\n\n**Legend:**\n\n- `[✓]` = Completed\n- `[•]` = Current (in progress)\n- `[ ]` = Not started\n\n## Error Messages\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| No session file found | Session not initialized | Run `deckrd init <namespace>/<module>` |\n| No active module set | Session exists but no active module | Run `deckrd init <namespace>/<module>` |\n| jq is not installed | jq command not available | Install jq |\n\n## Script\n\nExecute: `.claude/skills/deckrd/scripts/status.sh`\n\n```bash\nbash .claude/skills/deckrd/scripts/status.sh\n```\n",
        "plugins/deckrd/skills/deckrd/references/commands/tasks.md": "# tasks Command\n\nDerive executable implementation tasks from specifications.\nEach task corresponds to a single unit test case (`it()` block) in a BDD-style testing workflow.\n\n## Usage\n\n```bash\n/deckrd tasks\n```\n\n## Preconditions\n\n- Session must exist with active module\n- `spec` must be completed for active module\n- `specifications.md` must exist\n\n## Input\n\nRead: `docs/.deckrd/<namespace>/<module>/specifications/specifications.md`\n\n## Output\n\nCreate: `docs/.deckrd/<namespace>/<module>/tasks/tasks.md`\n\n## Prompt & Template\n\nUse prompt and template for generating tasks:\n\n```bash\ndeckrd/assets/\n       ├── prompts/tasks.prompt.md\n       └── templates/tasks.template.md\n```\n\n## Task ID Strategy\n\nTask IDs follow a hierarchical structure mapping to BDD test structure:\n\n```bash\nT-<TestTarget>-<Scenario>-<Case>\n```\n\n| Component  | Format  | Description                   |\n| ---------- | ------- | ----------------------------- |\n| TestTarget | 2-digit | Test target sequence (01, 02) |\n| Scenario   | 2-digit | Given/When scenario (01, 02)  |\n| Case       | 2-digit | Specific test case (01, 02)   |\n\n### Examples\n\n```bash\nT-01-01-01  → detectValueKind, Primitive input, returns Primitive\nT-01-02-01  → detectValueKind, Array input, returns Array\nT-02-01-01  → isSingleValue, Single value, returns true\n```\n\n## BDD Structure Mapping\n\nTasks map to the following test structure:\n\n```typescript\n// T-XX: Test Target (describe level 1)\ndescribe('<TestTarget>', () => {\n  // T-XX-YY: Given/When Scenario (describe level 2)\n  describe('[正常] <Scenario>', () => {\n    // T-XX-YY-ZZ: Test Case (it level)\n    it('Given X, When Y, Then Z', () => {\n      // test implementation\n    });\n  });\n});\n```\n\n## Category Prefixes\n\nUse category prefixes in scenarios:\n\n| Category  | Prefix         | Description         |\n| --------- | -------------- | ------------------- |\n| Normal    | [正常]         | Expected behavior   |\n| Error     | [異常]         | Error handling      |\n| Edge Case | [エッジケース] | Boundary conditions |\n\n## Document Structure\n\n```markdown\n---\ntitle: \"Implementation Tasks\"\nmodule: <namespace>/<module>\nstatus: Active\ncreated: <YYYY-MM-DD HH:MM:SS>\nsource: specifications.md\n---\n\n## Task Summary\n\n| Test Target  | Scenarios | Cases | Status      |\n| ------------ | --------- | ----- | ----------- |\n| T-01: <name> | N         | M     | in progress |\n\n---\n\n## T-01: <TestTarget>\n\n### [正常] Normal Cases\n\n#### T-01-01: <Given/When Scenario>\n\n- [ ] **T-01-01-01**: <Brief description>\n  - Target: `<function>`\n  - Scenario: Given <precondition>, When <action>\n  - Expected: Then <assertion>\n\n### [異常] Error Cases\n\n#### T-01-02: <Error Scenario>\n\n- [ ] **T-01-02-01**: <Error case description>\n      ...\n\n### [エッジケース] Edge Cases\n\n#### T-01-03: <Edge Case Scenario>\n\n- [ ] **T-01-03-01**: <Edge case description>\n      ...\n```\n\n---\n\n## Session Update\n\nAfter completion, update `.session.json`:\n\n```json\n{\n  \"current_step\": \"tasks\",\n  \"completed\": [\"init\", \"req\", \"spec\", \"impl\", \"tasks\"],\n  \"documents\": {\n    \"requirements\": \"requirements.md\",\n    \"specifications\": \"specifications.md\",\n    \"implementation\": \"implementation.md\",\n    \"tasks\": \"tasks.md\"\n  }\n}\n```\n\n## Script\n\nExecute: [run_prompt.sh](../../scripts/run-prompt.sh)\n\n```bash\nbash ${CLAUDE_PLUGIN_ROOT}/scripts/run_prompt.sh tasks [--lang <lang>] --output \"tasks/tasks.md\"\n```\n\n## Next Step\n\nWorkflow complete.\nYou can now execute tasks using:\n\n- TodoWrite tool for task tracking\n- BDD coding workflow for implementation\n\nYou can program by BDD based on the generated tasks.\n",
        "plugins/deckrd/skills/deckrd/references/session.md": "# Session Management\n\n## Session File Location\n\n```bash\ndocs/.deckrd/.session.json\n```\n\n## Session Schema\n\n```json\n{\n  \"active\": \"<namespace>/<module>\",\n  \"created_at\": \"2025-01-01T00:00:00Z\",\n  \"updated_at\": \"2025-01-01T00:00:00Z\",\n  \"modules\": {\n    \"<namespace>/<module>\": {\n      \"current_step\": \"spec\",\n      \"completed\": [\"init\", \"req\"],\n      \"documents\": {\n        \"requirements\": \"requirements.md\",\n        \"specifications\": \"specifications.md\"\n      }\n    }\n  }\n}\n```\n\n## Fields\n\n| Field                    | Type   | Description                  |\n| ------------------------ | ------ | ---------------------------- |\n| `active`                 | string | Currently active module path |\n| `modules`                | object | Per-module session states    |\n| `modules.*.current_step` | string | Last completed step          |\n| `modules.*.completed`    | array  | All completed steps          |\n| `modules.*.documents`    | object | Generated document paths     |\n\n## State Transitions\n\n```bash\n(none) ──init──> init ──req──> req ──spec──> spec ──impl──> impl ──tasks──> tasks\n                               │\n                               └──dr──> (stays in req, append-only DRs)\n```\n\nNote: The `dr` command does NOT advance the step. It appends Decision Records\nwhile remaining in the `req` step.\n\n## Session Operations\n\n### Create Session (init command)\n\n```json\n{\n  \"active\": \"AGTKind/isCollection\",\n  \"modules\": {\n    \"AGTKind/isCollection\": {\n      \"current_step\": \"init\",\n      \"completed\": [\"init\"],\n      \"documents\": {}\n    }\n  }\n}\n```\n\n### Update Session (after each command)\n\nAfter `req` command:\n\n```json\n{\n  \"active\": \"AGTKind/isCollection\",\n  \"modules\": {\n    \"AGTKind/isCollection\": {\n      \"current_step\": \"req\",\n      \"completed\": [\"init\", \"req\"],\n      \"documents\": {\n        \"requirements\": \"requirements.md\"\n      }\n    }\n  }\n}\n```\n\n### Switch Active Module\n\nTo work on a different module:\n\n```bash\n/deckrd init <other-namespace>/<other-module>\n```\n\nOr resume existing module:\n\n```bash\n/deckrd resume <namespace>/<module>\n```\n\n## Document Path Resolution\n\nFor the active module, documents are located at:\n\n```bash\ndocs/.deckrd/<namespace>/<module>/<document-type>/<filename>\n```\n\nExample:\n\n```bash\ndocs/.deckrd/AGTKind/isCollection/requirements/requirements.md\ndocs/.deckrd/AGTKind/isCollection/specifications/specifications.md\n```\n\n## Error Handling\n\n| Condition                 | Action                             |\n| ------------------------- | ---------------------------------- |\n| No session file           | Prompt to run `init` first         |\n| No active module          | Prompt to run `init` or `resume`   |\n| Step out of order         | Warn and suggest correct next step |\n| dr --add outside req step | Error, do NOT modify files         |\n",
        "plugins/deckrd/skills/deckrd/references/workflow.md": "/deckrdDeckrd# Deckrd Workflow\n\n## Overview\n\nDeckrd follows a linear document derivation workflow:\n\n```bash\nGoals/Ideas → Requirements → Specifications → Implementation → Tasks\n```\n\n## Workflow Steps\n\n### 1. init\n\nInitialize the module directory and session.\n\n- **Input:** namespace/module name\n- **Output:** Directory structure + session entry\n- **Next:** req\n\n### 2. req (Requirements)\n\nDerive clear requirements from initial goals.\n\n- **Input:** User's goals, ideas, or problem description\n- **Output:** `requirements/requirements.md`\n- **Source:** User input (free-form)\n- **Next:** spec (or dr to add Decision Records)\n\n### 2a. dr (Decision Records) - Optional\n\nAppend Decision Records during requirements phase.\n\n- **Input:** Decision context from user\n- **Output:** `decision-records.md` (append-only)\n- **Precondition:** current_step === \"req\"\n- **Note:** DRs are non-normative records of architectural Decisions\n\n### 3. spec (Specifications)\n\nDerive technically verifiable behavioral goals from requirements.\n\n- **Input:** Requirements document\n- **Output:** `specifications/specifications.md`\n- **Source:** `requirements/requirements.md`\n- **Next:** impl\n\n### 4. impl (Implementation)\n\ncode example for write constraint:\n\n#### Constraint: <観点名>\n\n- Rule:\n  <必ず満たすべき制約を一文で断定的に書く>\n- Rationale\n  <なぜこの制約が必要か。仕様・安全性・一貫性など>\n- Notes\n  - <補足条件>\n  - <例外があれば明示>\n- Example (Non-normative)\n\n  ```typescript\n  // 制約を説明するための最小例 (実装ではない)\n  ```\n\n例:\n\n```markdown\n#### Constraint: Primitive value handling\n\n- Rule:\n  null および undefined は Primitive 値として扱う。\n- Rationale:\n  JavaScript では `typeof null === \"object\"` という仕様上の例外があり、\n  これを特別扱いしないと分類結果が不安定になるため。\n- Notes:\n  - NaN, Infinity も number として Primitive に含める。\n  - object 判定より前に評価される必要がある。\n```\n\n### 5. tasks\n\ncreate task lists for coding. use BDD coding style.\n\n- **Input:** Implementation document\n- **Output:** `tasks/tasks.md`\n- **Source:** `implementation/implementation.md`\n- **Next:** (complete)\n\n## Directory Structure\n\n```bash\ndocs/.deckrd/\n├── .session.json                    # Session state\n└── <namespace>/\n    └── <module>/\n        ├── requirements/\n        │   └── requirements.md\n        ├── decision-records.md      # Optional: DR records (append-only)\n        ├── specifications/\n        │   └── specifications.md\n        ├── implementation/\n        │   └── implementation.md\n        └── tasks/\n            └── tasks.md\n```\n\n## Usage Example\n\n```bash\n# Start new module\n/deckrd init AGTKind/isCollection\n\n# User provides goals, then derive requirements\n/deckrd req\n# → Creates requirements/requirements.md\n\n# (Optional) Add Decision Records during req phase\n/deckrd dr --add\n# → Appends to Decision-records.md (only allowed during req step)\n\n# Derive specifications from requirements\n/deckrd spec\n# → Reads requirements.md, creates specifications.md\n\n# Derive implementation plan\n/deckrd impl\n# → Reads requirements.md, specifications.md, creates implementation.md\n\n# Derive executable tasks\n/deckrd tasks\n# → Reads specifications.md, creates tasks.md\n```\n"
      },
      "plugins": [
        {
          "name": "deckrd",
          "description": "your goals to tasks framework",
          "source": "./plugins/deckrd",
          "strict": true,
          "skills": [
            "./skills/deckrd"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add aglabo/deckrd",
            "/plugin install deckrd@deckrd-dev"
          ]
        },
        {
          "name": "deckrd-coder",
          "description": "Deckrd task implementation skill - extracts specified tasks from tasks.md and implements them using strict BDD process. Internally applies bdd-coder decision rules.",
          "source": "./plugins/deckrd-coder",
          "strict": true,
          "skills": [
            "./skills/deckrd-coder"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add aglabo/deckrd",
            "/plugin install deckrd-coder@deckrd-dev"
          ]
        },
        {
          "name": "bdd-coder",
          "description": "Method-level agent that defines decision rules for BDD implementation. Handles tests at the assertion level rather than file level, and enforces strict RED→GREEN→REFACTOR phased implementation based on the '1 message = 1 test' principle.",
          "source": "./plugins/bdd-coder",
          "strict": true,
          "agents": [
            "./agents/bdd-coder.md"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add aglabo/deckrd",
            "/plugin install bdd-coder@deckrd-dev"
          ]
        }
      ]
    }
  ]
}