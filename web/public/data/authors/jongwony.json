{
  "author": {
    "id": "jongwony",
    "display_name": "jongwony",
    "avatar_url": "https://avatars.githubusercontent.com/u/12846075?u=f1f59a5e59a95e8174fee5a5064137a0480810b6&v=4"
  },
  "marketplaces": [
    {
      "name": "epistemic-protocols",
      "version": null,
      "description": "Multi-perspective investigation and execution — /mission (πρόθεσις: a placing before)",
      "repo_full_name": "jongwony/epistemic-protocols",
      "repo_url": "https://github.com/jongwony/epistemic-protocols",
      "repo_description": "Claude Code plugins for epistemic dialogue — transform unknown unknowns into known unknowns",
      "signals": {
        "stars": 44,
        "forks": 4,
        "pushed_at": "2026-02-17T10:56:30Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"epistemic-protocols\",\n  \"owner\": {\n    \"name\": \"jongwony\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"prothesis\",\n      \"source\": \"./prothesis\",\n      \"description\": \"Multi-perspective investigation and execution — /mission (πρόθεσις: a placing before)\"\n    },\n    {\n      \"name\": \"syneidesis\",\n      \"source\": \"./syneidesis\",\n      \"description\": \"Surface potential gaps at decision points — /gap (συνείδησις: knowing-together)\"\n    },\n    {\n      \"name\": \"reflexion\",\n      \"source\": \"./reflexion\",\n      \"description\": \"Cross-session learning via Reflexion pattern\"\n    },\n    {\n      \"name\": \"write\",\n      \"source\": \"./write\",\n      \"description\": \"Multi-perspective blog drafting from session insights\"\n    },\n    {\n      \"name\": \"hermeneia\",\n      \"source\": \"./hermeneia\",\n      \"description\": \"Clarify intent-expression gaps through dialogue — /clarify (ἑρμηνεία: interpretation)\"\n    },\n    {\n      \"name\": \"katalepsis\",\n      \"source\": \"./katalepsis\",\n      \"description\": \"Achieve certain comprehension of AI work — /grasp (κατάληψις: a grasping firmly)\"\n    },\n    {\n      \"name\": \"telos\",\n      \"source\": \"./telos\",\n      \"description\": \"Co-construct defined goals from vague intent — /goal (τέλος: end, purpose)\"\n    }\n  ]\n}\n",
        "README.md": "# Epistemic Protocols\n\n> [한국어](./README_ko.md)\n\nClaude Code plugins for epistemic dialogue — each protocol resolves a specific cognitive deficit through structured human-AI interaction.\n\n## Protocols\n\n| Protocol | Purpose | Timing |\n|----------|---------|--------|\n| **[Prothesis](./prothesis)** (πρόθεσις) — /mission | Team-based multi-perspective investigation and execution | Before analysis |\n| **[Syneidesis](./syneidesis)** (συνείδησις) — /gap | Surface potential gaps at decision points | At decision time |\n| **[Hermeneia](./hermeneia)** (ἑρμηνεία) — /clarify | Clarify intent-expression gaps via dialogue | Before action |\n| **[Katalepsis](./katalepsis)** (κατάληψις) — /grasp | Achieve certain comprehension of AI work | After AI action |\n| **[Telos](./telos)** (τέλος) — /goal | Co-construct defined goals from vague intent | Pre-action |\n\n## Core Idea\n\nEach protocol resolves a distinct cognitive deficit:\n\n```\nProtocol = (Deficit, Initiator, Operation, Operand) → Resolution\n```\n\n| Protocol | Deficit | Initiator | Operation | Type Signature |\n|----------|---------|-----------|-----------|----------------|\n| **Prothesis** | FrameworkAbsent | AI-detected | SELECT | `FrameworkAbsent → FramedInquiry` |\n| **Syneidesis** | GapUnnoticed | AI-detected | SURFACE | `GapUnnoticed → AuditedDecision` |\n| **Hermeneia** | IntentMisarticulated | User-initiated | EXTRACT | `IntentMisarticulated → ClarifiedIntent` |\n| **Katalepsis** | ResultUngrasped | User-initiated | VERIFY | `ResultUngrasped → VerifiedUnderstanding` |\n| **Telos** | GoalIndeterminate | AI-detected | CO-CONSTRUCT | `GoalIndeterminate → DefinedEndState` |\n\n<img src=\"./assets/epistemic-matrix.svg\" alt=\"Epistemic Type Transformations\" width=\"560\">\n\n- **Prothesis**: \"How should we approach this?\" → AI assembles a team, investigates from multiple perspectives, acts on findings (`FrameworkAbsent → FramedInquiry`)\n- **Syneidesis**: \"What's missing?\" → AI surfaces gaps as questions, you judge (`GapUnnoticed → AuditedDecision`)\n- **Hermeneia**: \"What do I mean?\" → AI presents interpretations, you recognize your intent (`IntentMisarticulated → ClarifiedIntent`)\n- **Katalepsis**: \"What did you do?\" → AI verifies your understanding through questions (`ResultUngrasped → VerifiedUnderstanding`)\n- **Telos**: \"What do I actually want?\" → AI proposes goals, you shape and approve (`GoalIndeterminate → DefinedEndState`)\n\nThe key insight: **Recognition over Recall**. It's easier to select from presented options than to generate questions from scratch.\n\n## Installation\n\n```bash\n# Add marketplace\n/plugin marketplace add https://github.com/jongwony/epistemic-protocols\n\n# Install what you need\n/plugin install prothesis\n/plugin install syneidesis\n/plugin install hermeneia\n/plugin install katalepsis\n/plugin install telos\n```\n\n## Usage\n\n```\n/mission [your question]     # Multi-perspective team investigation and execution\n/gap [your task]             # Enable gap surfacing during execution\n/clarify [your expression]   # Clarify ambiguous intent\n/grasp                       # Verify understanding of AI work\n/goal [your vague idea]      # Co-construct defined goals from intent\n```\n\n## License\n\nMIT\n",
        "prothesis/README.md": "# Prothesis — /mission (πρόθεσις)\n\nTeam-based multi-perspective investigation and execution (πρόθεσις: placing before)\n\n> [한국어](./README_ko.md)\n\n## What is Prothesis?\n\nA modern reinterpretation of Greek πρόθεσις (placing before) — a protocol that **assembles a team to investigate from multiple perspectives, then acts on findings**.\n\n### The Core Problem\n\nUsers often lack the analytical framework for their question (`FrameworkAbsent`). Open questions like \"What perspective do you want?\" require knowing the answer to answer. Beyond perspective selection, complex questions need parallel investigation from distinct viewpoints and coordinated execution.\n\n### The Solution\n\n**Recognition over Recall + Team Investigation**: AI presents perspective options; user selects; an agent team investigates in parallel; findings are classified and executed with peer verification. The full lifecycle: team assembly → parallel investigation → cross-dialogue → execution → dissolution.\n\n### Difference from Socratic Method\n\n| Dimension | Socratic Maieutics | Prothesis |\n|-----------|-------------------|-----------|\n| Knowledge source | Latent within interlocutor | Provided externally |\n| Premise | \"You already know\" | \"You don't know the options\" |\n| Role | Midwife (draws out) | Cartographer (reveals paths) |\n| Question form | Open questions (recall burden) | Options (only recognition needed) |\n\n## Protocol Flow\n\n```\nPhase 0: Gather       → Context acquisition for perspective formulation\nPhase 1: Prothesis    → Present 2-4 perspectives (call AskUserQuestion)\nPhase 2: Inquiry      → Agent team analysis per selected perspective (TeamCreate + teammates)\nPhase 3: Synthesis    → Cross-dialogue check → Convergence/divergence → Integrated answer\n```\n\n## When to Use\n\n**Use**:\n- Evaluation, comparison, recommendation requests\n- When multiple frameworks are applicable (\"from an expert perspective\", \"deep analysis\")\n\n**Skip**:\n- Simple factual questions\n- User already specified a perspective\n\n## Usage\n\n```\n/mission [your question]\n```\n\n## Author\n\nJongwon Choi (https://github.com/jongwony)\n",
        "syneidesis/README.md": "# Syneidesis — /gap (συνείδησις)\n\nSurface potential gaps at decision points (συνείδησις: knowing-together)\n\n> [한국어](./README_ko.md)\n\n## What is Syneidesis?\n\nA modern reinterpretation of Greek συνείδησις (knowing-together) — a protocol that **positions AI as an \"auxiliary epistemic agent\"**.\n\n### Philosophical Meaning\n\nTransforms the traditional conscience (inner witness) into an externalized dialogue partner. Structures epistemic division of labor — AI handles pattern recognition, humans handle value judgment.\n\n### AI Alignment Perspective\n\nAn appropriate human-AI collaboration model for the \"weak AI\" era. Translates corrigibility into concrete behavioral rules and implements conservative failure modes (waiting on irreversible actions).\n\n### Interaction Design Perspective\n\nA refined implementation of intentional friction. Materializes the `GapUnnoticed → AuditedDecision` transformation as a UX flow.\n\n## Protocol Flow\n\n```\nPhase 0: Detection    → Scan decision point for gaps (silent)\nPhase 1: Surfacing    → Select and present gaps (call AskUserQuestion)\nPhase 2: Adjustment   → Incorporate response into state\n```\n\n## Core Principle\n\n**Surfacing over Deciding**: The goal is not for AI to \"make better decisions\" but to **\"illuminate cognitive blind spots so users can make better decisions\"**.\n\n## User Role\n\n**Judgment, not acknowledgment**: When a gap is surfaced, you evaluate its relevance — address it, dismiss it, or defer. The AI surfaces; you judge.\n\n## Usage\n\n```\n/gap\n```\n\nNote: Deferring high-stakes decisions blocks progress until you provide explicit judgment.\n\n## Author\n\nJongwon Choi (https://github.com/jongwony)\n",
        "hermeneia/README.md": "# Hermeneia — /clarify (ἑρμηνεία)\n\nClarify intent-expression gaps through dialogue (ἑρμηνεία: interpretation)\n\n> [한국어](./README_ko.md)\n\n## What is Hermeneia?\n\nA modern reinterpretation of Greek ἑρμηνεία (interpretation) — a protocol that **helps users articulate what they already know but struggle to express**.\n\n### The Core Problem\n\nUsers often recognize their expression is ambiguous (`IntentMisarticulated`) but lack the vocabulary or structure to clarify. Open questions like \"What do you mean?\" don't help when the user already knows they're unclear.\n\n### The Solution\n\n**Articulation over Assumption**: AI presents interpretation options; user recognizes their actual intent among choices. Transforms self-aware ambiguity into precise expression.\n\n### Difference from Other Protocols\n\n| Protocol | Initiator | Type Signature |\n|----------|-----------|---------------|\n| Prothesis | AI-detected | `FrameworkAbsent → FramedInquiry` |\n| Syneidesis | AI-detected | `GapUnnoticed → AuditedDecision` |\n| **Hermeneia** | **User-initiated** | **`IntentMisarticulated → ClarifiedIntent`** |\n\n## Protocol Flow\n\n```\nPhase 0: Trigger       → Recognize user-initiated clarification request\nPhase 1: Diagnosis     → Identify intent-expression gaps (silent)\nPhase 2: Clarification → Present options (call AskUserQuestion)\nPhase 3: Integration   → Proceed with clarified expression\n```\n\n## Gap Types\n\n| Type | Example |\n|------|---------|\n| Expression | \"Did you mean X or Y?\" |\n| Precision | \"How specifically: [options]?\" |\n| Coherence | \"You mentioned X but also Y...\" |\n| Context | \"What's the context for this?\" |\n\n## When to Use\n\n**Use**:\n- When you recognize your expression might be ambiguous\n- When you're unsure how to phrase your request\n- When you want help articulating your intent\n\n**Skip**:\n- When your expression is clear\n- When AI should infer from context\n\n## Usage\n\n```\n/clarify [your potentially ambiguous request]\n```\n\n## Author\n\nJongwon Choi (https://github.com/jongwony)\n",
        "katalepsis/README.md": "# Katalepsis — /grasp (κατάληψις)\n\nAchieve certain comprehension of AI work (κατάληψις: grasping firmly)\n\n> [한국어](./README_ko.md)\n\n## What is Katalepsis?\n\nA modern reinterpretation of Stoic κατάληψις (firm grasp, certain comprehension) — a protocol that **enables users to follow along and achieve verified understanding of AI-generated work**.\n\n### The Core Problem\n\nWhen AI completes complex work, users often can't grasp the full result (`ResultUngrasped`). They may think they understand, or feel overwhelmed by changes without a clear entry point.\n\n### The Solution\n\n**Comprehension over Explanation**: Rather than lecturing, AI structures verification through categorized entry points. Users select what to understand first, then AI confirms understanding through progressive questioning.\n\n### Difference from Simple Explanation\n\n| Dimension | Simple Explanation | Katalepsis |\n|-----------|-------------------|------------|\n| Direction | AI talks, user listens | AI verifies, user confirms |\n| Entry point | AI decides what to explain | User selects focus areas |\n| Confirmation | Assumed after explanation | Verified through questions |\n| Progress | Undefined | Tracked via tasks |\n\n## Protocol Flow\n\n```\nPhase 0: Categorize   → Analyze AI work, extract change categories\nPhase 1: Entry Point  → Present categories, user selects (AskUserQuestion)\nPhase 2: Register     → Create tasks for selected categories (TaskCreate)\nPhase 3: Verify Loop  → Confirm understanding progressively (AskUserQuestion + TaskUpdate)\n```\n\n## When to Use\n\n**Use**:\n- After AI completes significant code changes\n- When user asks \"what did you do?\", \"explain this\", \"help me understand\"\n- Complex refactoring, new features, architectural changes\n\n**Skip**:\n- Trivial changes (typos, formatting)\n- User demonstrates understanding already\n- User explicitly declines explanation\n\n## Usage\n\n```\n/grasp\n```\n\n## Gap Types\n\n| Type | Description |\n|------|-------------|\n| **Expectation** | User's assumed behavior differs from actual |\n| **Causality** | User doesn't understand why something happens |\n| **Scope** | User doesn't see full impact of changes |\n| **Sequence** | User doesn't understand execution order |\n\n## Author\n\nJongwon Choi (https://github.com/jongwony)\n",
        "telos/README.md": "# Telos — /goal (τέλος)\n\nCo-construct defined end-states from vague goals (τέλος: end, purpose)\n\n> [한국어](./README_ko.md)\n\n## What is Telos?\n\nA modern reinterpretation of Greek τέλος (end, purpose) — a protocol that **helps users build goal definitions that don't yet exist, rather than extracting ones that do**.\n\n### The Core Problem\n\nUsers often arrive with vague aspirations (`GoalIndeterminate`) — they know they want *something* but cannot articulate what success looks like, what boundaries apply, or which outcomes matter most. Traditional requirements gathering assumes intent already exists and merely needs extraction. When intent is absent, extraction fails silently.\n\n### The Solution\n\n**Construction over Extraction**: AI proposes falsifiable goal dimensions; user selects, rejects, or reshapes them. Transforms indeterminate aspiration into a concrete, actionable end-state through iterative co-construction.\n\n### Difference from Other Protocols\n\n| Protocol | Mode | Type Signature |\n|----------|------|---------------|\n| Hermeneia | EXTRACT | `IntentMisarticulated → ClarifiedIntent` |\n| **Telos** | **CO-CONSTRUCT** | **`GoalIndeterminate → DefinedEndState`** |\n\n**Key distinction**: Hermeneia assumes the user *has* an intent but struggles to express it — Telos operates when no well-formed intent exists yet. Hermeneia extracts; Telos constructs.\n\n### Difference from Requirements Engineering\n\n| Aspect | Requirements Engineering | Telos |\n|--------|--------------------------|-------|\n| Assumption | Stakeholder knows what they want | User may not know yet |\n| Method | Elicitation (detect needs) | Selection (propose dimensions) |\n| Output | Requirements document | GoalContract (falsifiable) |\n| Interaction | Interview-driven | Morphism-driven (dimension proposals fire on selection) |\n\n## Protocol Flow\n\n```\nPhase 0: Trigger        → Detect goal indeterminacy + confirm co-construction mode\nPhase 1: Dimension      → Present gap dimensions (call AskUserQuestion)\nPhase 2: Co-construction → Build GoalContract through iterative proposals\nPhase 3: Integration    → Synthesize selections into DefinedEndState\nPhase 4: Sufficiency    → Verify completeness (call AskUserQuestion)\n```\n\n## Gap Types\n\n| Type | Example |\n|------|---------|\n| Outcome | \"What does success look like: [options]?\" |\n| Metric | \"How would you measure progress: [options]?\" |\n| Boundary | \"What's explicitly out of scope: [options]?\" |\n| Priority | \"Which matters more, X or Y?\" |\n\n## Protocol Precedence\n\n```\nHermeneia → Telos → Prothesis → Syneidesis → Katalepsis\n```\n\nTelos follows Hermeneia: if intent exists but is misarticulated, clarify first. If no intent exists, co-construct. Once a goal is defined, perspective framing (Prothesis) and gap auditing (Syneidesis) can proceed.\n\n## When to Use\n\n**Use**:\n- When you have a vague aspiration but no concrete goal\n- When you cannot define what success looks like\n- When you need help deciding what matters and what doesn't\n- When starting a project with undefined scope\n\n**Skip**:\n- When your goal is clear but poorly expressed (use Hermeneia — /clarify)\n- When you have a defined goal and need perspective analysis (use Prothesis — /mission)\n\n## Usage\n\n```\n/goal [your vague goal or aspiration]\n```\n\n## Author\n\nJongwon Choi (https://github.com/jongwony)\n"
      },
      "plugins": [
        {
          "name": "prothesis",
          "source": "./prothesis",
          "description": "Multi-perspective investigation and execution — /mission (πρόθεσις: a placing before)",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/epistemic-protocols",
            "/plugin install prothesis@epistemic-protocols"
          ]
        },
        {
          "name": "syneidesis",
          "source": "./syneidesis",
          "description": "Surface potential gaps at decision points — /gap (συνείδησις: knowing-together)",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/epistemic-protocols",
            "/plugin install syneidesis@epistemic-protocols"
          ]
        },
        {
          "name": "reflexion",
          "source": "./reflexion",
          "description": "Cross-session learning via Reflexion pattern",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/epistemic-protocols",
            "/plugin install reflexion@epistemic-protocols"
          ]
        },
        {
          "name": "write",
          "source": "./write",
          "description": "Multi-perspective blog drafting from session insights",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/epistemic-protocols",
            "/plugin install write@epistemic-protocols"
          ]
        },
        {
          "name": "hermeneia",
          "source": "./hermeneia",
          "description": "Clarify intent-expression gaps through dialogue — /clarify (ἑρμηνεία: interpretation)",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/epistemic-protocols",
            "/plugin install hermeneia@epistemic-protocols"
          ]
        },
        {
          "name": "katalepsis",
          "source": "./katalepsis",
          "description": "Achieve certain comprehension of AI work — /grasp (κατάληψις: a grasping firmly)",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/epistemic-protocols",
            "/plugin install katalepsis@epistemic-protocols"
          ]
        },
        {
          "name": "telos",
          "source": "./telos",
          "description": "Co-construct defined goals from vague intent — /goal (τέλος: end, purpose)",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/epistemic-protocols",
            "/plugin install telos@epistemic-protocols"
          ]
        }
      ]
    },
    {
      "name": "cc-plugin",
      "version": null,
      "description": "Deep web research agent powered by Tavily search API",
      "repo_full_name": "jongwony/cc-plugin",
      "repo_url": "https://github.com/jongwony/cc-plugin",
      "repo_description": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-11T16:10:52Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"cc-plugin\",\n  \"owner\": {\n    \"name\": \"jongwony\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"tavily\",\n      \"source\": \"./external-plugin/tavily\",\n      \"description\": \"Deep web research agent powered by Tavily search API\"\n    },\n    {\n      \"name\": \"bigquery\",\n      \"source\": \"./external-plugin/bigquery\",\n      \"description\": \"BigQuery data analysis agent with SQL generation and schema exploration\"\n    },\n    {\n      \"name\": \"google\",\n      \"source\": \"./google\",\n      \"description\": \"Google services: Gemini CLI, Veo, video understanding, image prompts, calendar sync\"\n    },\n    {\n      \"name\": \"session\",\n      \"source\": \"./session\",\n      \"description\": \"Session utilities: search history, git stash linking\"\n    },\n    {\n      \"name\": \"linear\",\n      \"source\": \"./linear\",\n      \"description\": \"Linear integration: activity reports, documents, milestones\"\n    },\n    {\n      \"name\": \"amplitude-user-lookup\",\n      \"source\": \"./amplitude-user-lookup\",\n      \"description\": \"Amplitude user behavior queries\"\n    },\n    {\n      \"name\": \"claude-code-internals\",\n      \"source\": \"./claude-code-internals\",\n      \"description\": \"Claude Code internals explorer\"\n    },\n    {\n      \"name\": \"codex\",\n      \"source\": \"./codex\",\n      \"description\": \"OpenAI Codex CLI integration\"\n    },\n    {\n      \"name\": \"fossil-ui\",\n      \"source\": \"./fossil-ui\",\n      \"description\": \"Git to Fossil export\"\n    },\n    {\n      \"name\": \"github-activity\",\n      \"source\": \"./github-activity\",\n      \"description\": \"GitHub activity reports\"\n    },\n    {\n      \"name\": \"pdf-split\",\n      \"source\": \"./pdf-split\",\n      \"description\": \"PDF chapter splitting\"\n    },\n    {\n      \"name\": \"activity-workflow\",\n      \"source\": \"./activity-workflow\",\n      \"description\": \"Orchestrates activity collection and Google Calendar sync\"\n    },\n    {\n      \"name\": \"slack\",\n      \"source\": \"./slack\",\n      \"description\": \"Slack utilities: search messages, fetch threads\"\n    },\n    {\n      \"name\": \"release\",\n      \"source\": \"./release\",\n      \"description\": \"Automated version bump, git tag, and GitHub release creation\"\n    }\n  ]\n}\n",
        "README.md": "CLAUDE.md",
        "linear/README.md": "# Linear Extended Skill\n\nClaude Code 스킬로 Linear GraphQL API를 직접 사용하여 Document와 ProjectMilestone을 생성/수정/삭제할 수 있습니다.\n\n## 개요\n\nLinear MCP 서버는 읽기 작업만 제공하지만, 이 스킬은 다음 기능을 추가합니다:\n\n### Document 기능\n- ✅ `documentCreate` - 문서 생성\n- ✅ `documentUpdate` - 문서 수정\n- ✅ `documentDelete` - 문서 삭제\n- ✅ `documentUnarchive` - 문서 복원\n\n### ProjectMilestone 기능\n- ✅ `projectMilestoneCreate` - 마일스톤 생성\n- ✅ `projectMilestoneUpdate` - 마일스톤 수정\n- ✅ `projectMilestoneDelete` - 마일스톤 삭제\n- ✅ `projectMilestones` - 마일스톤 조회 (리스트)\n- ✅ `projectMilestone` - 마일스톤 조회 (단일)\n- ✅ `projectMilestoneMove` - 마일스톤 이동\n\n## 설치\n\n이미 설치되었습니다:\n```\n~/.claude/skills/linear-extended/\n├── SKILL.md                    # 메인 스킬 정의\n├── README.md                   # 이 문서\n└── references/\n    ├── document-schema.md      # Document GraphQL 스키마\n    ├── milestone-schema.md     # ProjectMilestone GraphQL 스키마\n    └── examples.md             # 사용 예제 모음\n```\n\n## 사전 준비\n\n### 1. Linear API 키 발급\n\n1. Linear 설정으로 이동: https://linear.app/settings/api\n2. \"Personal API keys\" 섹션에서 새 키 생성\n3. 키를 안전한 곳에 저장 (한 번만 표시됨)\n\n### 2. 환경 변수 설정\n\n```bash\n# ~/.zshrc 또는 ~/.bashrc에 추가\nexport LINEAR_API_KEY=\"lin_api_xxxxxxxxxxxxxxxxxxxxx\"\n```\n\n적용:\n```bash\nsource ~/.zshrc  # 또는 ~/.bashrc\n```\n\n확인:\n```bash\necho $LINEAR_API_KEY  # 키가 출력되어야 함\n```\n\n## 테스트\n\n### API 연결 테스트\n\n```bash\ncurl -X POST https://api.linear.app/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: $LINEAR_API_KEY\" \\\n  -d '{\"query\": \"{ viewer { id name email } }\"}' | jq '.'\n```\n\n**예상 출력:**\n```json\n{\n  \"data\": {\n    \"viewer\": {\n      \"id\": \"...\",\n      \"name\": \"Your Name\",\n      \"email\": \"your.email@example.com\"\n    }\n  }\n}\n```\n\n### 프로젝트 목록 조회\n\n```bash\ncurl -X POST https://api.linear.app/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: $LINEAR_API_KEY\" \\\n  -d '{\"query\": \"{ projects(first: 5) { nodes { id name state } } }\"}' | jq '.'\n```\n\n## 사용 방법\n\n### Claude Code에서 사용\n\n이 스킬이 설치되면 Claude Code가 자동으로 인식합니다:\n\n```\nYou: \"프로젝트 abc123에 'Technical Spec' 문서를 만들어줘\"\n\nClaude: [SKILL.md의 documentCreate 예제를 사용하여 문서 생성]\n```\n\n### 직접 사용 (bash)\n\n#### 문서 생성\n\n```bash\nPROJECT_ID=\"your-project-id\"\n\n# Create temp file with Python for proper JSON encoding\nTEMP_FILE=$(mktemp)\npython3 << EOF > \"$TEMP_FILE\"\nimport json\ndata = {\n    \"query\": \"\"\"mutation DocumentCreate(\\$input: DocumentCreateInput!) {\n        documentCreate(input: \\$input) {\n            success\n            document { id url }\n        }\n    }\"\"\",\n    \"variables\": {\n        \"input\": {\n            \"title\": \"Technical Specification\",\n            \"content\": \"# Overview\\\\n\\\\nTBD\",\n            \"projectId\": \"$PROJECT_ID\"\n        }\n    }\n}\nprint(json.dumps(data, ensure_ascii=False))\nEOF\n\ncurl -X POST https://api.linear.app/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: $LINEAR_API_KEY\" \\\n  -d @\"$TEMP_FILE\" | jq '.'\n\nrm \"$TEMP_FILE\"\n```\n\n#### 마일스톤 생성\n\n```bash\nPROJECT_ID=\"your-project-id\"\n\n# Create temp file with Python for proper JSON encoding\nTEMP_FILE=$(mktemp)\npython3 << EOF > \"$TEMP_FILE\"\nimport json\ndata = {\n    \"query\": \"\"\"mutation ProjectMilestoneCreate(\\$input: ProjectMilestoneCreateInput!) {\n        projectMilestoneCreate(input: \\$input) {\n            success\n            projectMilestone { id name status }\n        }\n    }\"\"\",\n    \"variables\": {\n        \"input\": {\n            \"projectId\": \"$PROJECT_ID\",\n            \"name\": \"Beta Launch\",\n            \"targetDate\": \"2025-06-30\"\n        }\n    }\n}\nprint(json.dumps(data, ensure_ascii=False))\nEOF\n\ncurl -X POST https://api.linear.app/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: $LINEAR_API_KEY\" \\\n  -d @\"$TEMP_FILE\" | jq '.'\n\nrm \"$TEMP_FILE\"\n```\n\n#### 마일스톤 조회\n\n```bash\ncurl -X POST https://api.linear.app/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: $LINEAR_API_KEY\" \\\n  -d '{\"query\": \"{ projectMilestones(first: 10) { nodes { id name status progress targetDate project { name } } } }\"}' | jq '.'\n```\n\n## Linear MCP와 함께 사용\n\n### 권장 워크플로우\n\n1. **Linear MCP로 ID 조회**\n   ```\n   You: \"list projects\"\n   Claude: [Linear MCP의 list_projects 도구 사용]\n   ```\n\n2. **이 스킬로 생성/수정**\n   ```\n   You: \"프로젝트 abc123에 문서 만들어줘\"\n   Claude: [linear-extended 스킬의 documentCreate 사용]\n   ```\n\n3. **Linear MCP로 확인**\n   ```\n   You: \"문서 목록 보여줘\"\n   Claude: [Linear MCP의 list_documents 도구 사용]\n   ```\n\n### 도구 분담\n\n| 작업 | 사용할 도구 |\n|------|------------|\n| 프로젝트 조회 | Linear MCP (`list_projects`) |\n| 이슈 조회 | Linear MCP (`list_issues`) |\n| 문서 조회 | Linear MCP (`list_documents`, `get_document`) |\n| 문서 생성/수정/삭제 | **linear-extended** (이 스킬) |\n| 마일스톤 조회 | **linear-extended** (이 스킬) |\n| 마일스톤 생성/수정/삭제 | **linear-extended** (이 스킬) |\n\n## 검증 결과\n\n✅ **API 연결**: 정상 작동\n✅ **프로젝트 조회**: 정상 작동 (5개 프로젝트 확인)\n✅ **마일스톤 조회**: 정상 작동 (10개 마일스톤 확인, 다양한 상태)\n✅ **문서 조회**: 정상 작동 (5개 문서 확인)\n\n## 문서\n\n- **SKILL.md**: 메인 스킬 정의 (Claude Code가 읽음)\n- **references/document-schema.md**: Document API 완전한 스키마\n- **references/milestone-schema.md**: ProjectMilestone API 완전한 스키마\n- **references/examples.md**: 실전 예제 모음\n\n## 예제 시나리오\n\n### 1. 프로젝트 문서화 자동화\n\n```bash\n# 1. 프로젝트 ID 얻기 (Linear MCP 사용)\n# 2. 기술 문서 생성\ncurl -X POST https://api.linear.app/graphql \\\n  -H \"Authorization: $LINEAR_API_KEY\" \\\n  -d '{\n    \"query\": \"mutation { documentCreate(input: { title: \\\"API Design\\\", content: \\\"# API Endpoints\\\\n\\\\n- POST /users\\\\n- GET /users/:id\\\", projectId: \\\"PROJECT_ID\\\" }) { success document { url } } }\"\n  }'\n```\n\n### 2. 마일스톤 기반 프로젝트 관리\n\n```bash\n# 분기별 마일스톤 생성\nfor MONTH in 03 06 09 12; do\n  QUARTER=$(((10#$MONTH - 1) / 3 + 1))\n  TEMP_FILE=$(mktemp)\n\n  python3 << EOF > \"$TEMP_FILE\"\nimport json\ndata = {\n    \"query\": \"\"\"mutation ProjectMilestoneCreate(\\$input: ProjectMilestoneCreateInput!) {\n        projectMilestoneCreate(input: \\$input) {\n            success\n        }\n    }\"\"\",\n    \"variables\": {\n        \"input\": {\n            \"projectId\": \"PROJECT_ID\",\n            \"name\": f\"Q{$QUARTER} Delivery\",\n            \"targetDate\": f\"2025-{$MONTH}-31\"\n        }\n    }\n}\nprint(json.dumps(data, ensure_ascii=False))\nEOF\n\n  curl -X POST https://api.linear.app/graphql \\\n    -H \"Content-Type: application/json\" \\\n    -H \"Authorization: $LINEAR_API_KEY\" \\\n    -d @\"$TEMP_FILE\"\n\n  rm \"$TEMP_FILE\"\ndone\n```\n\n### 3. 진행 상황 리포트\n\n```bash\n# 모든 마일스톤의 진행률 확인\ncurl -X POST https://api.linear.app/graphql \\\n  -H \"Authorization: $LINEAR_API_KEY\" \\\n  -d '{\"query\": \"{ projectMilestones(first: 50) { nodes { name progress status targetDate } } }\"}' \\\n  | jq -r '.data.projectMilestones.nodes[] | \"\\(.name): \\((.progress * 100 | round))% (\\(.status))\"'\n```\n\n## 문제 해결\n\n### API 키가 작동하지 않음\n\n```bash\n# 키 확인\necho $LINEAR_API_KEY\n\n# 키 형식 확인 (lin_api_로 시작해야 함)\necho $LINEAR_API_KEY | grep \"^lin_api_\"\n```\n\n### GraphQL 에러\n\n에러 메시지를 확인:\n```bash\ncurl ... | jq '.errors'\n```\n\n흔한 에러:\n- `UNAUTHENTICATED`: API 키 확인\n- `NOT_FOUND`: ID가 존재하는지 확인\n- `RATE_LIMITED`: 잠시 후 재시도\n\n## 참고 자료\n\n- [Linear GraphQL API 공식 문서](https://linear.app/developers/graphql)\n- [Linear GraphQL Schema](https://github.com/linear/linear/blob/master/packages/sdk/src/schema.graphql)\n- [Claude Code Skills 가이드](https://raw.githubusercontent.com/anthropics/claude-plugins-official/refs/heads/main/plugins/plugin-dev/skills/skill-development/SKILL.md)\n\n## 라이선스\n\n이 스킬은 학습 및 개인 사용 목적으로 제공됩니다.\n"
      },
      "plugins": [
        {
          "name": "tavily",
          "source": "./external-plugin/tavily",
          "description": "Deep web research agent powered by Tavily search API",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install tavily@cc-plugin"
          ]
        },
        {
          "name": "bigquery",
          "source": "./external-plugin/bigquery",
          "description": "BigQuery data analysis agent with SQL generation and schema exploration",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install bigquery@cc-plugin"
          ]
        },
        {
          "name": "google",
          "source": "./google",
          "description": "Google services: Gemini CLI, Veo, video understanding, image prompts, calendar sync",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install google@cc-plugin"
          ]
        },
        {
          "name": "session",
          "source": "./session",
          "description": "Session utilities: search history, git stash linking",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install session@cc-plugin"
          ]
        },
        {
          "name": "linear",
          "source": "./linear",
          "description": "Linear integration: activity reports, documents, milestones",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install linear@cc-plugin"
          ]
        },
        {
          "name": "amplitude-user-lookup",
          "source": "./amplitude-user-lookup",
          "description": "Amplitude user behavior queries",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install amplitude-user-lookup@cc-plugin"
          ]
        },
        {
          "name": "claude-code-internals",
          "source": "./claude-code-internals",
          "description": "Claude Code internals explorer",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install claude-code-internals@cc-plugin"
          ]
        },
        {
          "name": "codex",
          "source": "./codex",
          "description": "OpenAI Codex CLI integration",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install codex@cc-plugin"
          ]
        },
        {
          "name": "fossil-ui",
          "source": "./fossil-ui",
          "description": "Git to Fossil export",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install fossil-ui@cc-plugin"
          ]
        },
        {
          "name": "github-activity",
          "source": "./github-activity",
          "description": "GitHub activity reports",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install github-activity@cc-plugin"
          ]
        },
        {
          "name": "pdf-split",
          "source": "./pdf-split",
          "description": "PDF chapter splitting",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install pdf-split@cc-plugin"
          ]
        },
        {
          "name": "activity-workflow",
          "source": "./activity-workflow",
          "description": "Orchestrates activity collection and Google Calendar sync",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install activity-workflow@cc-plugin"
          ]
        },
        {
          "name": "slack",
          "source": "./slack",
          "description": "Slack utilities: search messages, fetch threads",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install slack@cc-plugin"
          ]
        },
        {
          "name": "release",
          "source": "./release",
          "description": "Automated version bump, git tag, and GitHub release creation",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jongwony/cc-plugin",
            "/plugin install release@cc-plugin"
          ]
        }
      ]
    }
  ]
}