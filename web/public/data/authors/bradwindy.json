{
  "author": {
    "id": "bradwindy",
    "display_name": "Bradley Windybank",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/38803010?u=e3aa5ca4bdf44b17732770599cc87bcef0c90dba&v=4",
    "url": "https://github.com/bradwindy",
    "bio": "iOS developer - @TradeMe ",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "writing-xcuitests-marketplace",
      "version": null,
      "description": "Claude Code plugin for writing XCUITests",
      "owner_info": {
        "name": "bradwindy"
      },
      "keywords": [],
      "repo_full_name": "bradwindy/writing-xcuitests",
      "repo_url": "https://github.com/bradwindy/writing-xcuitests",
      "repo_description": "Claude Code skill for writing robust, maintainable XCUITests for iOS and macOS applications",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-21T19:54:55Z",
        "created_at": "2025-12-21T05:22:53Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 665
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 418
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1402
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/writing-xcuitests",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/writing-xcuitests/SKILL.md",
          "type": "blob",
          "size": 8024
        },
        {
          "path": "skills/writing-xcuitests/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/writing-xcuitests/reference/assertions.md",
          "type": "blob",
          "size": 1647
        },
        {
          "path": "skills/writing-xcuitests/reference/element-queries.md",
          "type": "blob",
          "size": 2243
        },
        {
          "path": "skills/writing-xcuitests/reference/examples.md",
          "type": "blob",
          "size": 6877
        },
        {
          "path": "skills/writing-xcuitests/reference/flaky-tests.md",
          "type": "blob",
          "size": 3764
        },
        {
          "path": "skills/writing-xcuitests/reference/gestures.md",
          "type": "blob",
          "size": 1375
        },
        {
          "path": "skills/writing-xcuitests/reference/interactions.md",
          "type": "blob",
          "size": 1633
        },
        {
          "path": "skills/writing-xcuitests/reference/page-objects.md",
          "type": "blob",
          "size": 3387
        },
        {
          "path": "skills/writing-xcuitests/reference/waiting.md",
          "type": "blob",
          "size": 3233
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"writing-xcuitests-marketplace\",\n  \"owner\": {\n    \"name\": \"bradwindy\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugin for writing XCUITests\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"writing-xcuitests\",\n      \"source\": \"./\",\n      \"description\": \"Write robust, maintainable XCUITests for iOS and macOS applications.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"bradwindy\"\n      },\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"xcuitest\",\n        \"ios\",\n        \"macos\",\n        \"swift\",\n        \"ui-testing\",\n        \"xcode\",\n        \"accessibility\",\n        \"page-object\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"writing-xcuitests\",\n  \"description\": \"Write robust, maintainable XCUITests for iOS and macOS applications.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"bradwindy\"\n  },\n  \"repository\": \"https://github.com/bradwindy/writing-xcuitests\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"xcuitest\",\n    \"ios\",\n    \"macos\",\n    \"swift\",\n    \"ui-testing\",\n    \"xcode\",\n    \"accessibility\",\n    \"page-object\"\n  ]\n}\n",
        "README.md": "# writing-xcuitests\n\nA Claude Code skill for writing robust, maintainable XCUITests for iOS and macOS applications.\n\n## What It Enables\n\nThis skill helps Claude assist with:\n\n- Writing reliable XCUITests using best practices\n- Querying UI elements with accessibility identifiers\n- Implementing the Page Object pattern for maintainable tests\n- Handling waiting and synchronization correctly\n- Debugging and fixing flaky tests\n- Using advanced gestures (swipe, pinch, rotate, long press)\n- Structuring test suites for scalability\n\n## Installation\n\n**Direct Repository Method:**\n```\n/plugin install --git https://github.com/bradwindy/writing-xcuitests\n```\n\n**Marketplace Approach:**\n```\n/plugin marketplace add bradwindy/writing-xcuitests\n/plugin install writing-xcuitests@writing-xcuitests-marketplace\n```\n\n**Local Setup:**\n```\ngit clone https://github.com/bradwindy/writing-xcuitests.git\n/plugin marketplace add ./writing-xcuitests\n/plugin install writing-xcuitests@writing-xcuitests-marketplace\n```\n\n## Requirements\n\n- macOS with Xcode installed\n- Claude Code CLI\n\n## When It Activates\n\nThe skill automatically engages when you discuss:\n\n- Writing XCUITests or UI tests for iOS/macOS\n- Querying XCUIElements or accessibility identifiers\n- Implementing Page Object pattern\n- Fixing flaky or unreliable tests\n- Test waiting and synchronization strategies\n- Advanced gestures in UI tests\n\n## License\n\nMIT\n",
        "skills/writing-xcuitests/SKILL.md": "---\nname: writing-xcuitests\ndescription: This skill should be used when the user asks to \"write XCUITest\", \"create UI tests\", \"fix flaky tests\", \"query XCUIElements\", \"implement Page Object pattern\", or mentions XCUITest, UI testing for iOS/macOS apps. Targets experienced iOS developers who want best practices and efficiency improvements.\n---\n\n# Writing XCUITests\n\nGuide for writing robust, maintainable XCUITests for iOS and macOS applications. This skill focuses on practical patterns, element querying strategies, and techniques to reduce test flakiness.\n\n## Quick Start\n\n### Element Queries\n\nPrefer accessibility identifiers for reliable element queries:\n\n```swift\n// Best: Accessibility identifier\napp.buttons[\"loginButton\"].tap()\n\n// Good: Text matching (fragile to localization)\napp.buttons[\"Log In\"].tap()\n\n// Avoid: Index-based queries (brittle to UI changes)\napp.buttons.element(boundBy: 0).tap()\n```\n\nSet accessibility identifiers in your app code:\n\n```swift\nbutton.accessibilityIdentifier = \"loginButton\"\n```\n\nQuery by element type and identifier:\n\n```swift\nlet emailField = app.textFields[\"emailField\"]\nlet passwordField = app.secureTextFields[\"passwordField\"]\nlet submitButton = app.buttons[\"submitButton\"]\nlet statusLabel = app.staticTexts[\"statusLabel\"]\n```\n\n### Common Interactions\n\n**Tap elements:**\n\n```swift\napp.buttons[\"submitButton\"].tap()\n```\n\n**Type text:**\n\n```swift\napp.textFields[\"emailField\"].tap()\napp.textFields[\"emailField\"].typeText(\"user@example.com\")\n```\n\n**Clear and type (preferred for input fields):**\n\n```swift\nlet emailField = app.textFields[\"emailField\"]\nemailField.tap()\n// Clear existing text by typing delete keys\nif let value = emailField.value as? String, !value.isEmpty {\n    let deleteString = String(repeating: XCUIKeyboardKey.delete.rawValue,\n                              count: value.count)\n    emailField.typeText(deleteString)\n}\nemailField.typeText(\"new@example.com\")\n```\n\n**Toggle switches:**\n\n```swift\nlet toggleSwitch = app.switches[\"notificationSwitch\"]\nif toggleSwitch.value as? String == \"0\" {\n    toggleSwitch.tap()\n}\n```\n\n### Waiting for Elements\n\nAlways wait for elements before interacting:\n\n```swift\nlet loginButton = app.buttons[\"loginButton\"]\nXCTAssertTrue(loginButton.waitForExistence(timeout: 5))\nloginButton.tap()\n```\n\nWait for element to disappear (loading indicators):\n\n```swift\n// Using expectation-based wait for disappearance\nlet spinner = app.activityIndicators[\"loadingSpinner\"]\nlet predicate = NSPredicate(format: \"exists == false\")\nlet expectation = expectation(for: predicate, evaluatedWith: spinner)\nwait(for: [expectation], timeout: 10)\n```\n\nAlternative simpler approach:\n\n```swift\n// Wait for element to disappear (simple polling approach)\nlet spinner = app.activityIndicators[\"loadingSpinner\"]\nlet timeout: TimeInterval = 10\nlet startTime = Date()\nwhile spinner.exists && Date().timeIntervalSince(startTime) < timeout {\n    Thread.sleep(forTimeInterval: 0.1)\n}\nXCTAssertFalse(spinner.exists, \"Spinner did not disappear within timeout\")\n```\n\n### Basic Assertions\n\nCheck element existence:\n\n```swift\nXCTAssertTrue(app.buttons[\"loginButton\"].exists)\n```\n\nCheck element properties:\n\n```swift\nlet errorLabel = app.staticTexts[\"errorLabel\"]\nXCTAssertTrue(errorLabel.exists)\nXCTAssertEqual(errorLabel.label, \"Invalid credentials\")\n```\n\nCheck element state:\n\n```swift\nlet submitButton = app.buttons[\"submitButton\"]\nXCTAssertTrue(submitButton.isEnabled)\nXCTAssertTrue(submitButton.isHittable)\n```\n\n## Test Structure\n\n### Basic XCTestCase Setup\n\n```swift\nimport XCTest\n\nclass LoginTests: XCTestCase {\n    var app: XCUIApplication!\n\n    override func setUpWithError() throws {\n        continueAfterFailure = false\n        app = XCUIApplication()\n        app.launch()\n    }\n\n    override func tearDownWithError() throws {\n        app = nil\n    }\n\n    func testSuccessfulLogin() throws {\n        // Arrange\n        let emailField = app.textFields[\"emailField\"]\n        let passwordField = app.secureTextFields[\"passwordField\"]\n        let loginButton = app.buttons[\"loginButton\"]\n\n        // Act\n        XCTAssertTrue(emailField.waitForExistence(timeout: 5))\n        emailField.tap()\n        emailField.typeText(\"user@example.com\")\n\n        passwordField.tap()\n        passwordField.typeText(\"password123\")\n\n        loginButton.tap()\n\n        // Assert\n        let welcomeLabel = app.staticTexts[\"welcomeLabel\"]\n        XCTAssertTrue(welcomeLabel.waitForExistence(timeout: 5))\n        XCTAssertEqual(welcomeLabel.label, \"Welcome back!\")\n    }\n}\n```\n\n### Launch Arguments and Environment Variables\n\nConfigure app state for testing:\n\n```swift\noverride func setUpWithError() throws {\n    continueAfterFailure = false\n    app = XCUIApplication()\n\n    // Pass launch arguments\n    app.launchArguments = [\"--uitesting\", \"--reset-data\"]\n\n    // Set environment variables\n    app.launchEnvironment = [\n        \"MOCK_API\": \"true\",\n        \"ANIMATION_SPEED\": \"0\"\n    ]\n\n    app.launch()\n}\n```\n\n## Reference Documentation\n\nFor detailed guidance on specific topics:\n\n| Topic | Reference File |\n|-------|---------------|\n| Element Query Strategies | [reference/element-queries.md](reference/element-queries.md) |\n| Interactions & Gestures | [reference/interactions.md](reference/interactions.md) |\n| Waiting & Synchronization | [reference/waiting.md](reference/waiting.md) |\n| Assertions & Validation | [reference/assertions.md](reference/assertions.md) |\n| Page Object Pattern | [reference/page-objects.md](reference/page-objects.md) |\n| Advanced Gestures | [reference/gestures.md](reference/gestures.md) |\n| Fixing Flaky Tests | [reference/flaky-tests.md](reference/flaky-tests.md) |\n| Complete Examples | [reference/examples.md](reference/examples.md) |\n\n## Key Principles\n\n1. **Use accessibility identifiers** - Most reliable query method\n2. **Always wait for elements** - Use `waitForExistence(timeout:)` before interactions\n3. **Test behavior, not implementation** - Focus on user-visible outcomes\n4. **Keep tests independent** - Each test should run in isolation\n5. **Use Page Objects** - Encapsulate screen structure and reduce duplication\n6. **Minimize sleeps** - Prefer explicit waits over `sleep()` calls\n7. **Handle animations** - Disable or account for UI animations in tests\n8. **Verify preconditions** - Assert element state before interactions\n\n## Common Patterns\n\n**Login flow:**\n\n```swift\nfunc login(email: String, password: String) {\n    let emailField = app.textFields[\"emailField\"]\n    let passwordField = app.secureTextFields[\"passwordField\"]\n    let loginButton = app.buttons[\"loginButton\"]\n\n    XCTAssertTrue(emailField.waitForExistence(timeout: 5))\n\n    emailField.tap()\n    emailField.typeText(email)\n\n    passwordField.tap()\n    passwordField.typeText(password)\n\n    loginButton.tap()\n}\n```\n\n**Navigate and verify:**\n\n```swift\nfunc testNavigationToSettings() {\n    // Navigate\n    app.tabBars.buttons[\"Settings\"].tap()\n\n    // Verify arrival\n    let settingsTitle = app.navigationBars[\"Settings\"]\n    XCTAssertTrue(settingsTitle.waitForExistence(timeout: 3))\n}\n```\n\n**Form submission with validation:**\n\n```swift\nfunc testFormValidation() {\n    let nameField = app.textFields[\"nameField\"]\n    let submitButton = app.buttons[\"submitButton\"]\n\n    // Submit empty form\n    submitButton.tap()\n\n    // Verify validation message\n    let errorLabel = app.staticTexts[\"nameErrorLabel\"]\n    XCTAssertTrue(errorLabel.waitForExistence(timeout: 2))\n    XCTAssertEqual(errorLabel.label, \"Name is required\")\n\n    // Fix and resubmit\n    nameField.tap()\n    nameField.typeText(\"John Doe\")\n    submitButton.tap()\n\n    // Verify error cleared\n    XCTAssertFalse(errorLabel.exists)\n}\n```\n\n## Next Steps\n\n- Implement Page Objects for complex screens: [reference/page-objects.md](reference/page-objects.md)\n- Learn advanced gestures (swipe, pinch, rotate): [reference/gestures.md](reference/gestures.md)\n- Debug flaky tests: [reference/flaky-tests.md](reference/flaky-tests.md)\n- Review complete test examples: [reference/examples.md](reference/examples.md)\n",
        "skills/writing-xcuitests/reference/assertions.md": "# Assertions\n\n## Contents\n\n- [Existence](#existence)\n- [Visibility](#visibility)\n- [Text Content](#text-content)\n- [State](#state)\n- [Element Counts](#element-counts)\n\n## Existence\n\nCheck if an element exists in the view hierarchy:\n\n```swift\nXCTAssertTrue(app.buttons[\"Submit\"].exists)\n```\n\nWait for an element to appear:\n\n```swift\nXCTAssertTrue(app.alerts[\"Error\"].waitForExistence(timeout: 5))\n```\n\n## Visibility\n\nCheck if an element is visible, enabled, and hittable:\n\n```swift\nXCTAssertTrue(app.buttons[\"Login\"].isHittable)\n```\n\n## Text Content\n\nAssert exact text match on labels:\n\n```swift\nXCTAssertEqual(app.staticTexts[\"title\"].label, \"Welcome\")\n```\n\nAssert button title:\n\n```swift\nXCTAssertEqual(app.buttons.firstMatch.label, \"Continue\")\n```\n\nAssert text field value:\n\n```swift\nXCTAssertEqual(app.textFields[\"email\"].value as? String, \"user@example.com\")\n```\n\nCheck if text contains a substring:\n\n```swift\nXCTAssertTrue(app.staticTexts.firstMatch.label.contains(\"Success\"))\n```\n\n## State\n\nAssert element is enabled:\n\n```swift\nXCTAssertTrue(app.buttons[\"Submit\"].isEnabled)\n```\n\nAssert element is disabled:\n\n```swift\nXCTAssertFalse(app.buttons[\"Submit\"].isEnabled)\n```\n\nAssert element is selected:\n\n```swift\nXCTAssertTrue(app.buttons[\"Favorite\"].isSelected)\n```\n\nAssert toggle state:\n\n```swift\nXCTAssertEqual(app.switches[\"notifications\"].value as? String, \"1\")\n```\n\n## Element Counts\n\nAssert exact element count:\n\n```swift\nXCTAssertEqual(app.cells.count, 10)\n```\n\nAssert at least N elements exist:\n\n```swift\nXCTAssertGreaterThanOrEqual(app.buttons.count, 3)\n```\n\nAssert no elements exist:\n\n```swift\nXCTAssertEqual(app.alerts.count, 0)\n```\n",
        "skills/writing-xcuitests/reference/element-queries.md": "# Element Queries Reference\n\n## Contents\n\n1. [Accessibility Identifiers (Recommended)](#accessibility-identifiers-recommended)\n2. [Label-Based Queries](#label-based-queries)\n3. [Predicate Queries](#predicate-queries)\n4. [Index-Based Queries](#index-based-queries)\n5. [Hierarchy Traversal](#hierarchy-traversal)\n6. [Debugging](#debugging)\n\n## Accessibility Identifiers (Recommended)\n\n**Setting identifiers:**\n```swift\n// SwiftUI\nText(\"Welcome\").accessibilityIdentifier(\"welcomeLabel\")\nButton(\"Login\") { }.accessibilityIdentifier(\"loginButton\")\n\n// UIKit\nbutton.accessibilityIdentifier = \"loginButton\"\n```\n\n**Querying:**\n```swift\napp.buttons[\"loginButton\"]\napp.staticTexts[\"welcomeLabel\"]\n```\n\n## Label-Based Queries\n\nMatch by exact label text:\n```swift\napp.buttons[\"Login\"]\napp.staticTexts[\"Welcome\"]\n```\n\n## Predicate Queries\n\n**Basic patterns:**\n```swift\napp.buttons.containing(NSPredicate(format: \"label CONTAINS 'Login'\"))\napp.buttons.matching(NSPredicate(format: \"label BEGINSWITH 'Submit'\"))\napp.staticTexts.containing(NSPredicate(format: \"label CONTAINS[c] 'welcome'\"))  // case-insensitive\n```\n\n**Multiple conditions:**\n```swift\napp.buttons.matching(NSPredicate(format: \"label CONTAINS 'Login' AND isEnabled == true\"))\napp.cells.containing(NSPredicate(format: \"label CONTAINS %@\", searchTerm))\n```\n\n## Index-Based Queries\n\nAccess elements by position (fragile, avoid when possible):\n```swift\napp.buttons.element(boundBy: 0)  // first button\n```\n\nSafer with count validation:\n```swift\nlet buttons = app.buttons.allElementsBoundByIndex\nXCTAssertEqual(buttons.count, 3)\nbuttons[1].tap()\n```\n\n## Hierarchy Traversal\n\n**Navigate element tree:**\n```swift\napp.navigationBars[\"Settings\"].buttons[\"Done\"]\napp.tables.cells.staticTexts[\"Username\"]\n\nlet cell = app.cells.element(boundBy: 0)\ncell.buttons[\"Delete\"]\n```\n\n## Debugging\n\n**Inspect hierarchy:**\n```swift\nprint(app.debugDescription)\nprint(\"Button count: \\(app.buttons.count)\")\n```\n\n**Iterate elements:**\n```swift\nlet buttons = app.buttons.allElementsBoundByIndex\nfor (index, button) in buttons.enumerated() {\n    print(\"Button \\(index): \\(button.label)\")\n}\n```\n\n**Verify existence:**\n```swift\nlet button = app.buttons[\"Login\"]\nif button.exists {\n    print(\"Found: \\(button.label)\")\n}\n```\n",
        "skills/writing-xcuitests/reference/examples.md": "# XCUITest Examples\n\n## Contents\n- [Simple Login Test](#simple-login-test)\n- [Login Test with Page Objects](#login-test-with-page-objects)\n- [Complex User Flow](#complex-user-flow)\n\n## Simple Login Test\n\nDirect approach without page objects:\n\n```swift\nimport XCTest\n\nclass LoginUITests: XCTestCase {\n    var app: XCUIApplication!\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n        app = XCUIApplication()\n        app.launch()\n    }\n\n    override func tearDown() {\n        app = nil\n        super.tearDown()\n    }\n\n    func testSuccessfulLogin() {\n        // Wait for login screen\n        let emailField = app.textFields[\"emailTextField\"]\n        XCTAssertTrue(emailField.waitForExistence(timeout: 5))\n\n        // Enter credentials\n        emailField.tap()\n        emailField.typeText(\"user@example.com\")\n\n        let passwordField = app.secureTextFields[\"passwordTextField\"]\n        passwordField.tap()\n        passwordField.typeText(\"password123\")\n\n        // Tap login button\n        app.buttons[\"loginButton\"].tap()\n\n        // Verify home screen appears\n        let welcomeLabel = app.staticTexts[\"welcomeLabel\"]\n        XCTAssertTrue(welcomeLabel.waitForExistence(timeout: 3))\n        XCTAssertEqual(welcomeLabel.label, \"Welcome!\")\n    }\n\n    func testInvalidCredentials() {\n        let emailField = app.textFields[\"emailTextField\"]\n        emailField.tap()\n        emailField.typeText(\"wrong@example.com\")\n\n        let passwordField = app.secureTextFields[\"passwordTextField\"]\n        passwordField.tap()\n        passwordField.typeText(\"wrongpass\")\n\n        app.buttons[\"loginButton\"].tap()\n\n        // Verify error alert appears\n        let alert = app.alerts[\"Error\"]\n        XCTAssertTrue(alert.waitForExistence(timeout: 2))\n        XCTAssertTrue(alert.staticTexts[\"Invalid credentials\"].exists)\n        alert.buttons[\"OK\"].tap()\n    }\n}\n```\n\n## Login Test with Page Objects\n\nSame tests refactored with page objects:\n\n```swift\nprotocol Screen {\n    var app: XCUIApplication { get }\n}\n\nstruct LoginScreen: Screen {\n    let app: XCUIApplication\n\n    // Elements\n    var emailField: XCUIElement { app.textFields[\"emailTextField\"] }\n    var passwordField: XCUIElement { app.secureTextFields[\"passwordTextField\"] }\n    var loginButton: XCUIElement { app.buttons[\"loginButton\"] }\n    var errorAlert: XCUIElement { app.alerts[\"Error\"] }\n\n    // Actions\n    func enterEmail(_ email: String) {\n        emailField.tap()\n        emailField.typeText(email)\n    }\n\n    func enterPassword(_ password: String) {\n        passwordField.tap()\n        passwordField.typeText(password)\n    }\n\n    func tapLogin() {\n        loginButton.tap()\n    }\n\n    func login(email: String, password: String) {\n        enterEmail(email)\n        enterPassword(password)\n        tapLogin()\n    }\n\n    // Assertions\n    func verifyErrorAlert(message: String) {\n        XCTAssertTrue(errorAlert.waitForExistence(timeout: 2))\n        XCTAssertTrue(errorAlert.staticTexts[message].exists)\n    }\n}\n\nstruct HomeScreen: Screen {\n    let app: XCUIApplication\n\n    var welcomeLabel: XCUIElement { app.staticTexts[\"welcomeLabel\"] }\n\n    func verifyWelcomeMessage() {\n        XCTAssertTrue(welcomeLabel.waitForExistence(timeout: 3))\n        XCTAssertEqual(welcomeLabel.label, \"Welcome!\")\n    }\n}\n\nclass LoginPageObjectUITests: XCTestCase {\n    var app: XCUIApplication!\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n        app = XCUIApplication()\n        app.launch()\n    }\n\n    func testSuccessfulLogin() {\n        let loginScreen = LoginScreen(app: app)\n        loginScreen.login(email: \"user@example.com\", password: \"password123\")\n\n        let homeScreen = HomeScreen(app: app)\n        homeScreen.verifyWelcomeMessage()\n    }\n\n    func testInvalidCredentials() {\n        let loginScreen = LoginScreen(app: app)\n        loginScreen.login(email: \"wrong@example.com\", password: \"wrongpass\")\n        loginScreen.verifyErrorAlert(message: \"Invalid credentials\")\n\n        app.alerts[\"Error\"].buttons[\"OK\"].tap()\n    }\n}\n```\n\n## Complex User Flow\n\nMulti-screen flow with cart and checkout:\n\n```swift\nclass ShoppingFlowUITests: XCTestCase {\n    var app: XCUIApplication!\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n        app = XCUIApplication()\n        app.launch()\n    }\n\n    func testCompleteCheckoutFlow() {\n        // Login\n        let emailField = app.textFields[\"emailTextField\"]\n        emailField.tap()\n        emailField.typeText(\"user@example.com\")\n        app.secureTextFields[\"passwordTextField\"].tap()\n        app.secureTextFields[\"passwordTextField\"].typeText(\"password123\")\n        app.buttons[\"loginButton\"].tap()\n\n        // Navigate to products\n        let productsTab = app.tabBars.buttons[\"Products\"]\n        XCTAssertTrue(productsTab.waitForExistence(timeout: 3))\n        productsTab.tap()\n\n        // Wait for products to load (network call)\n        let firstProduct = app.cells.element(boundBy: 0)\n        let productLoaded = firstProduct.waitForExistence(timeout: 10)\n        XCTAssertTrue(productLoaded, \"Products failed to load within timeout\")\n\n        // Add product to cart\n        firstProduct.buttons[\"addToCartButton\"].tap()\n\n        // Wait for cart badge to update\n        let cartBadge = app.tabBars.buttons[\"Cart\"].badges.element\n        let expectation = XCTNSPredicateExpectation(\n            predicate: NSPredicate(format: \"exists == true AND label == '1'\"),\n            object: cartBadge\n        )\n        let result = XCTWaiter.wait(for: [expectation], timeout: 5)\n        XCTAssertEqual(result, .completed, \"Cart badge did not update\")\n\n        // Navigate to cart\n        app.tabBars.buttons[\"Cart\"].tap()\n\n        // Verify product in cart\n        let cartItem = app.cells.staticTexts.element(matching: .any, identifier: \"cartItemName\")\n        XCTAssertTrue(cartItem.exists)\n\n        // Proceed to checkout\n        app.buttons[\"checkoutButton\"].tap()\n\n        // Fill checkout form\n        let nameField = app.textFields[\"nameField\"]\n        XCTAssertTrue(nameField.waitForExistence(timeout: 2))\n        nameField.tap()\n        nameField.typeText(\"John Doe\")\n\n        app.textFields[\"addressField\"].tap()\n        app.textFields[\"addressField\"].typeText(\"123 Main St\")\n\n        app.textFields[\"cardNumberField\"].tap()\n        app.textFields[\"cardNumberField\"].typeText(\"4242424242424242\")\n\n        // Submit order\n        app.buttons[\"placeOrderButton\"].tap()\n\n        // Verify confirmation screen with network timeout\n        let confirmationLabel = app.staticTexts[\"orderConfirmationLabel\"]\n        let confirmed = confirmationLabel.waitForExistence(timeout: 15)\n        XCTAssertTrue(confirmed, \"Order confirmation did not appear within 15 seconds\")\n        XCTAssertTrue(confirmationLabel.label.contains(\"Order Confirmed\"))\n    }\n}\n```\n",
        "skills/writing-xcuitests/reference/flaky-tests.md": "# Flaky Tests\n\n## Contents\n\n- [Timing Issues](#timing-issues)\n- [Simulator State](#simulator-state)\n- [Test Isolation](#test-isolation)\n\n## Timing Issues\n\n### Element Not Found\n\n**Symptoms:**\n- \"No matches found\" or \"Failed to get matching snapshot\"\n- Intermittent failures that pass on retry\n\n**Causes:**\n- Querying elements before they appear\n- Network requests incomplete\n- View transitions in progress\n\n**Fixes:**\n\n```swift\nlet button = app.buttons[\"Submit\"]\nXCTAssertTrue(button.waitForExistence(timeout: 5))\nbutton.tap()\n```\n\n### Animation Timing\n\n**Symptoms:**\n- \"Element is not hittable\" errors\n- Taps registered but no action occurs\n\n**Causes:**\n- Tapping during animation blocks interaction\n- Gesture recognizers not ready during transitions\n\n**Fixes:**\n\n```swift\nlet button = app.buttons[\"Next\"]\nlet predicate = NSPredicate(format: \"isHittable == true\")\nexpectation(for: predicate, evaluatedWith: button)\nwaitForExpectations(timeout: 5)\nbutton.tap()\n```\n\n### Async Operations\n\n**Symptoms:**\n- Pass locally, fail in CI\n- Timeout errors on slower machines\n\n**Fixes:**\n\n```swift\nlet timeout: TimeInterval = ProcessInfo.processInfo.environment[\"CI\"] != nil ? 10 : 5\nXCTAssertTrue(element.waitForExistence(timeout: timeout))\n\napp.buttons[\"Load\"].tap()\nXCTAssertFalse(app.activityIndicators[\"Loading\"].waitForExistence(timeout: 10))\n```\n\n## Simulator State\n\n### Keyboard Issues\n\n**Symptoms:**\n- Characters not appearing\n- \"Failed to synthesize event\" errors\n\n**Fixes:**\n\n```swift\n// Disable hardware keyboard\napp.launchArguments = [\"-ApplePersistenceIgnoreKeyboardType\", \"YES\"]\n\n// Tap before typing\nemailField.tap()\nsleep(0.5)\nemailField.typeText(\"user@example.com\")\n```\n\n### System Alerts\n\nUse `addUIInterruptionMonitor` for permission alerts:\n\n```swift\naddUIInterruptionMonitor(withDescription: \"Location\") { alert -> Bool in\n    let allowButton = alert.buttons[\"Allow While Using App\"]\n    if allowButton.exists {\n        allowButton.tap()\n        return true\n    }\n    return false\n}\n\napp.launch()\napp.tap() // Trigger monitor\n```\n\n### Simulator Reset\n\nUse launch arguments for clean state:\n\n```swift\napp.launchArguments = [\n    \"-RESET_APP_STATE\", \"YES\",\n    \"-CLEAR_USER_DEFAULTS\", \"YES\"\n]\napp.launch()\n```\n\nHandle in app:\n\n```swift\nif CommandLine.arguments.contains(\"-RESET_APP_STATE\") {\n    UserDefaults.standard.removePersistentDomain(forName: Bundle.main.bundleIdentifier!)\n}\n```\n\n## Test Isolation\n\n### State Leaking Between Tests\n\n**Symptoms:**\n- First test passes, subsequent fail\n- Test order affects results\n\n**Causes:**\n- Shared state not cleaned up\n- UserDefaults persist across tests\n\n**Fixes:**\n\n```swift\noverride func setUpWithError() throws {\n    continueAfterFailure = false\n    let app = XCUIApplication()\n    app.launchArguments = [\"-RESET_STATE\", \"YES\"]\n    app.launch()\n}\n\noverride func tearDownWithError() throws {\n    if let testRun = testRun, testRun.hasSucceeded == false {\n        let screenshot = XCUIScreen.main.screenshot()\n        let attachment = XCTAttachment(screenshot: screenshot)\n        attachment.lifetime = .keepAlways\n        add(attachment)\n    }\n}\n```\n\n### Login State\n\nCreate helpers for consistent auth state:\n\n```swift\nfunc ensureLoggedIn() {\n    if app.buttons[\"Profile\"].exists { return }\n    app.textFields[\"Email\"].tap()\n    app.textFields[\"Email\"].typeText(\"test@example.com\")\n    app.secureTextFields[\"Password\"].tap()\n    app.secureTextFields[\"Password\"].typeText(\"password123\")\n    app.buttons[\"Login\"].tap()\n    XCTAssertTrue(app.buttons[\"Profile\"].waitForExistence(timeout: 5))\n}\n\nfunc ensureLoggedOut() {\n    if app.textFields[\"Email\"].exists { return }\n    app.buttons[\"Profile\"].tap()\n    app.buttons[\"Logout\"].tap()\n    XCTAssertTrue(app.textFields[\"Email\"].waitForExistence(timeout: 5))\n}\n```\n",
        "skills/writing-xcuitests/reference/gestures.md": "# Gestures\n\n## Contents\n\n- [Long Press](#long-press)\n- [Drag and Drop](#drag-and-drop)\n- [Pinch](#pinch)\n- [Rotate](#rotate)\n\n## Long Press\n\nHold an element for a specified duration:\n\n```swift\nelement.press(forDuration: 2.0)\n```\n\nPress and drag to another location:\n\n```swift\nelement.press(forDuration: 1.0, thenDragTo: targetElement)\n```\n\n## Drag and Drop\n\nPerform basic drag from one element to another:\n\n```swift\nsourceElement.press(forDuration: 0.5, thenDragTo: destinationElement)\n```\n\nDrag with specific velocity (points per second):\n\n```swift\ncoordinate.press(forDuration: 0.1, thenDragTo: destination, withVelocity: .fast)\ncoordinate.press(forDuration: 0.1, thenDragTo: destination, withVelocity: .slow)\n```\n\n## Pinch\n\nPinch out to zoom in (scale > 1.0):\n\n```swift\nelement.pinch(withScale: 2.0, velocity: 1.0)\n```\n\nPinch in to zoom out (scale < 1.0):\n\n```swift\nelement.pinch(withScale: 0.5, velocity: 1.0)\n```\n\nParameters:\n- `scale`: Magnification factor (2.0 = double size, 0.5 = half size)\n- `velocity`: Speed in scale factor per second\n\n## Rotate\n\nRotate clockwise (positive radians):\n\n```swift\nelement.rotate(CGFloat.pi, withVelocity: 1.0)\n```\n\nRotate counter-clockwise (negative radians):\n\n```swift\nelement.rotate(-CGFloat.pi, withVelocity: 1.0)\n```\n\nParameters:\n- `rotation`: Angle in radians (π = 180°, 2π = 360°)\n- `velocity`: Speed in radians per second\n",
        "skills/writing-xcuitests/reference/interactions.md": "# XCUITest Interactions Reference\n\n## Contents\n[Tapping](#tapping) • [Text Entry](#text-entry) • [Swipe and Scroll](#swipe-and-scroll) • [Coordinate-Based Taps](#coordinate-based-taps)\n\n## Tapping\n\n```swift\napp.buttons[\"Submit\"].tap()                      // Single tap\napp.images[\"Photo\"].doubleTap()                  // Double tap\napp.maps.firstMatch.twoFingerTap()               // Two-finger tap\napp.cells.firstMatch.press(forDuration: 1.5)     // Long press\n```\n\n## Text Entry\n\n**Tap and type:**\n```swift\nlet field = app.textFields[\"Username\"]\nfield.tap()\nfield.typeText(\"john@example.com\")\n```\n\n**Secure fields:**\n```swift\napp.secureTextFields[\"Password\"].tap()\napp.secureTextFields[\"Password\"].typeText(\"secret123\")\n```\n\n**Clear existing text then type:**\n```swift\nlet field = app.textFields[\"Search\"]\nfield.tap()\nfield.typeText(XCUIKeyboardKey.delete.rawValue)  // Clear existing\nfield.typeText(\"new query\")\n```\n\n**Special keys:**\n```swift\nfield.typeText(\"Line one\\n\")      // Return/newline\nfield.typeText(\"Column\\tValue\")   // Tab\n```\n\n## Swipe and Scroll\n\n```swift\napp.tables.firstMatch.swipeUp()                  // Directional swipe\napp.collectionViews.firstMatch.swipeLeft()\napp.cells[\"Row 5\"].swipeLeft()                   // Swipe on element\n\n// Scroll to element\nwhile !app.staticTexts[\"Bottom Text\"].isHittable { app.swipeUp() }\n```\n\n## Coordinate-Based Taps\n\n```swift\n// Normalized coordinate (0-1 range)\napp.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5)).tap()\n\n// Relative to element\nlet cell = app.cells.firstMatch\ncell.coordinate(withNormalizedOffset: CGVector(dx: 0.9, dy: 0.5)).tap()\n```\n",
        "skills/writing-xcuitests/reference/page-objects.md": "# Page Objects\n\n## Contents\n\n- [Why Use Page Objects](#why-use-page-objects)\n- [Protocol-Based Approach](#protocol-based-approach)\n- [Implementation Example](#implementation-example)\n- [Usage in Tests](#usage-in-tests)\n\n## Why Use Page Objects\n\n- **Maintainability**: Centralize UI element queries in one location. When UI changes, update only the page object.\n- **Readability**: Express test intent clearly with high-level actions like `login()` instead of low-level element interactions.\n- **Reusability**: Share common actions across multiple tests without duplicating element queries.\n\n## Protocol-Based Approach\n\nDefine a `Screen` protocol that all page objects conform to:\n\n```swift\nprotocol Screen {\n    var app: XCUIApplication { get }\n    func waitForScreen()\n}\n```\n\n- `app`: Reference to the application instance\n- `waitForScreen()`: Verify the screen has loaded before interactions\n\n## Implementation Example\n\n### LoginScreen\n\n```swift\nstruct LoginScreen: Screen {\n    let app: XCUIApplication\n\n    // Private element properties\n    private var emailField: XCUIElement { app.textFields[\"emailField\"] }\n    private var passwordField: XCUIElement { app.secureTextFields[\"passwordField\"] }\n    private var loginButton: XCUIElement { app.buttons[\"loginButton\"] }\n    private var errorAlert: XCUIElement { app.alerts[\"errorAlert\"] }\n\n    func waitForScreen() {\n        XCTAssertTrue(loginButton.waitForExistence(timeout: 5))\n    }\n\n    // Actions that return self\n    @discardableResult\n    func enterEmail(_ email: String) -> Self {\n        emailField.tap()\n        emailField.typeText(email)\n        return self\n    }\n\n    @discardableResult\n    func enterPassword(_ password: String) -> Self {\n        passwordField.tap()\n        passwordField.typeText(password)\n        return self\n    }\n\n    // Action that returns next screen\n    @discardableResult\n    func tapLogin() -> HomeScreen {\n        loginButton.tap()\n        return HomeScreen(app: app)\n    }\n\n    // Convenience method\n    @discardableResult\n    func login(email: String, password: String) -> HomeScreen {\n        return enterEmail(email)\n            .enterPassword(password)\n            .tapLogin()\n    }\n\n    // Assertions\n    func assertErrorDisplayed() {\n        XCTAssertTrue(errorAlert.exists)\n    }\n}\n```\n\n### HomeScreen\n\n```swift\nstruct HomeScreen: Screen {\n    let app: XCUIApplication\n\n    private var welcomeLabel: XCUIElement { app.staticTexts[\"welcomeLabel\"] }\n\n    func waitForScreen() {\n        XCTAssertTrue(welcomeLabel.waitForExistence(timeout: 5))\n    }\n}\n```\n\n## Usage in Tests\n\n```swift\nclass LoginTests: XCTestCase {\n    var app: XCUIApplication!\n\n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n        app = XCUIApplication()\n        app.launch()\n    }\n\n    func testSuccessfulLogin() {\n        let loginScreen = LoginScreen(app: app)\n        loginScreen.waitForScreen()\n\n        let homeScreen = loginScreen.login(\n            email: \"user@example.com\",\n            password: \"password123\"\n        )\n        homeScreen.waitForScreen()\n    }\n\n    func testInvalidCredentials() {\n        let loginScreen = LoginScreen(app: app)\n        loginScreen.waitForScreen()\n\n        loginScreen\n            .enterEmail(\"invalid@example.com\")\n            .enterPassword(\"wrongpass\")\n            .tapLogin()\n\n        loginScreen.assertErrorDisplayed()\n    }\n}\n```\n",
        "skills/writing-xcuitests/reference/waiting.md": "# Waiting Strategies Reference\n\nChoose the right waiting strategy for your scenario.\n\n## Decision Table\n\n| Scenario | Strategy | Method |\n|----------|----------|--------|\n| Element appears | Wait for existence | `waitForExistence(timeout:)` |\n| Element disappears | Wait for non-existence | XCTNSPredicateExpectation |\n| Property changes | Wait for condition | XCTNSPredicateExpectation |\n| Multiple conditions | Custom helper | Combined predicates |\n| Polling needed | Custom helper | Loop with sleep |\n\n## Wait for Existence\n\nUse `waitForExistence(timeout:)` when waiting for an element to appear.\n\n```swift\nlet button = app.buttons[\"Submit\"]\nXCTAssertTrue(button.waitForExistence(timeout: 5))\nbutton.tap()\n\n// Guard pattern for async content\nlet cell = app.cells.firstMatch\nguard cell.waitForExistence(timeout: 10) else {\n    XCTFail(\"Cell did not appear\")\n    return\n}\n```\n\n## Wait for Disappearance\n\nUse expectations with predicates for disappearing elements.\n\n```swift\nlet spinner = app.activityIndicators.firstMatch\nlet predicate = NSPredicate(format: \"exists == false\")\nlet expectation = XCTNSPredicateExpectation(predicate: predicate, object: spinner)\nwait(for: [expectation], timeout: 5)\n```\n## Wait for Condition\n\nWait for property changes using predicates.\n\n```swift\n// Wait for enabled state\nlet button = app.buttons[\"Submit\"]\nlet predicate = NSPredicate(format: \"isEnabled == true\")\nlet expectation = XCTNSPredicateExpectation(predicate: predicate, object: button)\nwait(for: [expectation], timeout: 3)\n\n// Wait for label text\nlet label = app.staticTexts[\"StatusLabel\"]\nlet predicate = NSPredicate(format: \"label == %@\", \"Completed\")\nlet expectation = XCTNSPredicateExpectation(predicate: predicate, object: label)\nwait(for: [expectation], timeout: 5)\n\n// Wait for value change\nlet slider = app.sliders.firstMatch\nlet predicate = NSPredicate(format: \"value == %@\", \"50%\")\nlet expectation = XCTNSPredicateExpectation(predicate: predicate, object: slider)\nwait(for: [expectation], timeout: 2)\n```\n\n## Custom Wait Helpers\n\nReusable helpers for complex scenarios.\n\n```swift\n// Wait for element and tap\nfunc waitAndTap(_ element: XCUIElement, timeout: TimeInterval = 5) {\n    XCTAssertTrue(element.waitForExistence(timeout: timeout))\n    element.tap()\n}\n\n// Wait for element to disappear\nfunc waitForDisappearance(_ element: XCUIElement, timeout: TimeInterval = 5) {\n    let predicate = NSPredicate(format: \"exists == false\")\n    let expectation = XCTNSPredicateExpectation(predicate: predicate, object: element)\n    wait(for: [expectation], timeout: timeout)\n}\n\n// Wait with polling\nfunc waitUntil(_ condition: () -> Bool, timeout: TimeInterval = 5) -> Bool {\n    let deadline = Date().addingTimeInterval(timeout)\n    while Date() < deadline {\n        if condition() { return true }\n        sleep(1)\n    }\n    return false\n}\n// Usage: XCTAssertTrue(waitUntil({ app.buttons.count == 3 }, timeout: 10))\n\n// Wait for multiple conditions\nfunc waitForReady(_ element: XCUIElement, timeout: TimeInterval = 5) {\n    let predicate = NSPredicate(format: \"exists == true AND isEnabled == true\")\n    let expectation = XCTNSPredicateExpectation(predicate: predicate, object: element)\n    wait(for: [expectation], timeout: timeout)\n}\n```"
      },
      "plugins": [
        {
          "name": "writing-xcuitests",
          "source": "./",
          "description": "Write robust, maintainable XCUITests for iOS and macOS applications.",
          "version": "1.0.0",
          "author": {
            "name": "bradwindy"
          },
          "license": "MIT",
          "keywords": [
            "xcuitest",
            "ios",
            "macos",
            "swift",
            "ui-testing",
            "xcode",
            "accessibility",
            "page-object"
          ],
          "categories": [
            "accessibility",
            "ios",
            "macos",
            "page-object",
            "swift",
            "ui-testing",
            "xcode",
            "xcuitest"
          ],
          "install_commands": [
            "/plugin marketplace add bradwindy/writing-xcuitests",
            "/plugin install writing-xcuitests@writing-xcuitests-marketplace"
          ]
        }
      ]
    }
  ]
}