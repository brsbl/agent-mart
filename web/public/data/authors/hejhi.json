{
  "author": {
    "id": "hejhi",
    "display_name": "Henry Ivry",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/1711164?u=54ce01f04bd428dd721be118b41b078efb03b411&v=4",
    "url": "https://github.com/hejhi",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 4,
      "total_commands": 0,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "rimitive-plugins",
      "version": null,
      "description": "Claude Code plugins for developing with Rimitive - composable reactive primitives",
      "owner_info": {
        "name": "Rimitive",
        "email": "hello@rimitive.dev"
      },
      "keywords": [],
      "repo_full_name": "hejhi/rimitive",
      "repo_url": "https://github.com/hejhi/rimitive",
      "repo_description": "Composable, reactive primitive libraries for TypeScript",
      "homepage": "https://rimitive.dev/",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-26T04:25:57Z",
        "created_at": "2025-07-18T23:40:36Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1091
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-behavior",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-behavior/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-behavior/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 202
        },
        {
          "path": "plugins/rimitive-behavior/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-behavior/skills/skill.md",
          "type": "blob",
          "size": 9798
        },
        {
          "path": "plugins/rimitive-compose",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-compose/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-compose/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 206
        },
        {
          "path": "plugins/rimitive-compose/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-compose/skills/skill.md",
          "type": "blob",
          "size": 6795
        },
        {
          "path": "plugins/rimitive-module",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-module/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-module/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 200
        },
        {
          "path": "plugins/rimitive-module/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-module/skills/skill.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": "plugins/rimitive-view",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-view/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-view/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 194
        },
        {
          "path": "plugins/rimitive-view/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/rimitive-view/skills/skill.md",
          "type": "blob",
          "size": 10780
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"rimitive-plugins\",\n  \"owner\": {\n    \"name\": \"Rimitive\",\n    \"email\": \"hello@rimitive.dev\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugins for developing with Rimitive - composable reactive primitives\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"rimitive-compose\",\n      \"source\": \"./plugins/rimitive-compose\",\n      \"description\": \"Help composing Rimitive services with the right modules and imports\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"rimitive-behavior\",\n      \"source\": \"./plugins/rimitive-behavior\",\n      \"description\": \"Create headless behaviors - portable reactive logic without UI\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"rimitive-view\",\n      \"source\": \"./plugins/rimitive-view\",\n      \"description\": \"Build views with el, map, match, and other view primitives\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"rimitive-module\",\n      \"source\": \"./plugins/rimitive-module\",\n      \"description\": \"Create custom modules with defineModule for extending Rimitive\",\n      \"version\": \"1.0.0\"\n    }\n  ]\n}\n",
        "plugins/rimitive-behavior/.claude-plugin/plugin.json": "{\n  \"name\": \"rimitive-behavior\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Create headless behaviors - portable reactive logic without UI\",\n  \"author\": { \"name\": \"Rimitive\" },\n  \"skills\": [\"./skills/\"]\n}\n",
        "plugins/rimitive-behavior/skills/skill.md": "---\nname: rimitive-behavior\ndescription: Create headless behaviors in Rimitive. Use when creating reusable state logic, hooks, or headless UI patterns like toggles, forms, disclosure, or any portable reactive logic.\n---\n\n# Creating Rimitive Behaviors\n\nA **behavior** is a portable function that encapsulates reactive logic without any UI. It receives a service, returns a factory, and that factory returns an API of signals, computeds, and actions.\n\nThink of behaviors as headless components—all the state and logic, none of the markup.\n\n**Important:** Behaviors run once. They are not reactive closures—there's no re-rendering or re-execution at the function level. All reactivity is encapsulated in the primitives (`signal`, `computed`, `effect`). The function creates the reactive graph once; signals handle updates from there.\n\n---\n\n## The Simple Approach\n\nThe easiest way to create a behavior is to import primitives directly from your service:\n\n```typescript\n// behaviors/useCounter.ts\nimport { signal, computed } from '../service';\n\nexport const useCounter = (initial = 0) => {\n  const count = signal(initial);\n  const doubled = computed(() => count() * 2);\n\n  return {\n    count,\n    doubled,\n    increment: () => count(count() + 1),\n    decrement: () => count(count() - 1),\n    reset: () => count(initial),\n  };\n};\n```\n\nUse it anywhere:\n\n```typescript\nimport { useCounter } from './behaviors/useCounter';\n\nconst counter = useCounter(10);\ncounter.increment();\ncounter.count();  // 11\n```\n\nThis works great for simple cases when you have a single app context.\n\n---\n\n## The Portable Pattern\n\nWhen you need behaviors that work across different contexts—testing with mocks, sharing between apps, or SSR—use the portable pattern.\n\n```typescript\nconst behaviorName = (svc: SignalsSvc) => (options?) => {\n  // Create state\n  // Return API\n};\n```\n\nThree levels:\n1. **Service injection**: `(svc) =>` — receives primitives\n2. **Factory**: `(options?) =>` — configures the instance\n3. **API**: `{ ... }` — the reactive interface consumers use\n\n### Counter Behavior\n\n```typescript\ntype SignalsSvc = {\n  signal: <T>(initial: T) => Writable<T>;\n  computed: <T>(fn: () => T) => Readable<T>;\n  effect: (fn: () => void | (() => void)) => () => void;\n};\n\nconst counter = (svc: SignalsSvc) => (initial = 0) => {\n  const { signal, computed } = svc;\n\n  const count = signal(initial);\n  const doubled = computed(() => count() * 2);\n\n  return {\n    count,\n    doubled,\n    increment: () => count(count() + 1),\n    decrement: () => count(count() - 1),\n    reset: () => count(initial),\n  };\n};\n```\n\n### Using It\n\n```typescript\nimport { svc } from './service';\n\nconst useCounter = svc(counter);\n\nconst c = useCounter(10);\nc.count();      // 10\nc.increment();\nc.count();      // 11\nc.doubled();    // 22\n```\n\n`svc(counter)` injects the service. The caller just provides options.\n\n---\n\n## Composing Behaviors\n\nBehaviors can use other behaviors. This is where the pattern shines.\n\n### Disclosure (open/close)\n\n```typescript\nconst disclosure = (svc: SignalsSvc) => (initialOpen = false) => {\n  const { signal, computed } = svc;\n  const isOpen = signal(initialOpen);\n\n  return {\n    isOpen,\n    open: () => isOpen(true),\n    close: () => isOpen(false),\n    toggle: () => isOpen(!isOpen()),\n    triggerProps: computed(() => ({\n      'aria-expanded': String(isOpen()),\n    })),\n    contentProps: computed(() => ({\n      hidden: !isOpen(),\n    })),\n  };\n};\n```\n\n### Dropdown (disclosure + keyboard)\n\n```typescript\nconst dropdown = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {\n  const disc = disclosure(svc)(options?.initialOpen ?? false);\n\n  const onKeyDown = (e: KeyboardEvent) => {\n    switch (e.key) {\n      case 'Escape':\n        disc.close();\n        break;\n      case 'Enter':\n      case ' ':\n        e.preventDefault();\n        disc.toggle();\n        break;\n    }\n  };\n\n  return {\n    ...disc,\n    triggerProps: svc.computed(() => ({\n      ...disc.triggerProps(),\n      onkeydown: onKeyDown,\n    })),\n  };\n};\n```\n\n### Modal (disclosure + focus trap + scroll lock)\n\n```typescript\nconst modal = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {\n  const { signal, effect } = svc;\n\n  const disc = disclosure(svc)(options?.initialOpen ?? false);\n  const previousFocus = signal<HTMLElement | null>(null);\n\n  effect(() => {\n    if (disc.isOpen()) {\n      previousFocus(document.activeElement as HTMLElement);\n      document.body.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = '';\n      previousFocus()?.focus();\n    }\n  });\n\n  return {\n    ...disc,\n    backdropProps: svc.computed(() => ({\n      onclick: disc.close,\n    })),\n    contentProps: svc.computed(() => ({\n      ...disc.contentProps(),\n      onclick: (e: Event) => e.stopPropagation(),\n    })),\n  };\n};\n```\n\n---\n\n## Behaviors with Options\n\nUse options for configuration:\n\n```typescript\ntype PaginationOptions = {\n  totalItems: number;\n  pageSize?: number;\n  initialPage?: number;\n};\n\nconst pagination = (svc: SignalsSvc) => (options: PaginationOptions) => {\n  const { signal, computed } = svc;\n\n  const pageSize = options.pageSize ?? 10;\n  const currentPage = signal(options.initialPage ?? 1);\n\n  const totalPages = computed(() =>\n    Math.ceil(options.totalItems / pageSize)\n  );\n\n  const hasNext = computed(() => currentPage() < totalPages());\n  const hasPrev = computed(() => currentPage() > 1);\n\n  return {\n    currentPage,\n    totalPages,\n    hasNext,\n    hasPrev,\n    next: () => hasNext() && currentPage(currentPage() + 1),\n    prev: () => hasPrev() && currentPage(currentPage() - 1),\n    goTo: (page: number) => {\n      if (page >= 1 && page <= totalPages()) {\n        currentPage(page);\n      }\n    },\n  };\n};\n```\n\n---\n\n## Behaviors with Reactive Options\n\nWhen options need to be reactive, accept signals:\n\n```typescript\nimport type { Readable } from '@rimitive/signals';\n\ntype SearchOptions = {\n  query: Readable<string>;\n  debounceMs?: number;\n};\n\nconst search = (svc: SignalsSvc) => (options: SearchOptions) => {\n  const { signal, computed, effect } = svc;\n\n  const results = signal<SearchResult[]>([]);\n  const isSearching = signal(false);\n\n  let timeoutId: number | undefined;\n\n  effect(() => {\n    const q = options.query();\n\n    clearTimeout(timeoutId);\n\n    if (!q) {\n      results([]);\n      return;\n    }\n\n    isSearching(true);\n\n    timeoutId = window.setTimeout(async () => {\n      const data = await performSearch(q);\n      results(data);\n      isSearching(false);\n    }, options.debounceMs ?? 300);\n  });\n\n  return {\n    results,\n    isSearching,\n    resultCount: computed(() => results().length),\n  };\n};\n```\n\n---\n\n## Using Behaviors in React\n\nBehaviors work in React via `@rimitive/react`:\n\n```typescript\nimport { SignalProvider, createHook, useSubscribe } from '@rimitive/react';\nimport { compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';\n\n// Create hooks from behaviors\nconst useCounter = createHook(counter);\nconst useDisclosure = createHook(disclosure);\n\nfunction ReactDropdown() {\n  const disc = useDisclosure(false);\n\n  // Subscribe to signals for React re-renders\n  const isOpen = useSubscribe(disc.isOpen);\n  const triggerProps = useSubscribe(disc.triggerProps);\n\n  return (\n    <div>\n      <button {...triggerProps} onClick={disc.toggle}>\n        Toggle\n      </button>\n      {isOpen && <div>Dropdown content</div>}\n    </div>\n  );\n}\n\n// Wrap app with provider\nconst svc = compose(SignalModule, ComputedModule, EffectModule);\n\nfunction App() {\n  return (\n    <SignalProvider svc={svc}>\n      <ReactDropdown />\n    </SignalProvider>\n  );\n}\n```\n\n**Note:** In React, use `useSubscribe(signal)` to read signal values and trigger re-renders. Calling `signal()` directly won't cause React to update.\n\n---\n\n## When to Use Behaviors\n\n**Good candidates:**\n- State that multiple components share (disclosure, selection, pagination)\n- Complex state logic (forms, wizards, data fetching)\n- Reusable interaction patterns (drag-and-drop, keyboard navigation)\n- Anything you'd put in a custom hook in React\n\n**Not necessary for:**\n- One-off component state (just use signals directly)\n- Pure presentation logic (no state to manage)\n- Framework-specific integrations\n\n---\n\n## Testing Behaviors\n\nBehaviors are trivial to test—no DOM, no framework:\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';\n\ndescribe('counter', () => {\n  const createTestSvc = () => compose(SignalModule, ComputedModule, EffectModule);\n\n  it('increments and decrements', () => {\n    const svc = createTestSvc();\n    const c = counter(svc)(5);\n\n    expect(c.count()).toBe(5);\n\n    c.increment();\n    expect(c.count()).toBe(6);\n\n    c.decrement();\n    c.decrement();\n    expect(c.count()).toBe(4);\n  });\n\n  it('computes doubled', () => {\n    const svc = createTestSvc();\n    const c = counter(svc)(3);\n\n    expect(c.doubled()).toBe(6);\n\n    c.increment();\n    expect(c.doubled()).toBe(8);\n  });\n});\n```\n\nPure functions, pure tests.\n\n---\n\n## Naming Conventions\n\nChoose one consistently:\n\n- Plain: `counter`, `disclosure`, `pagination`\n- `use` prefix: `useCounter`, `useDisclosure` (familiar to React users)\n- `create` prefix: `createCounter` (emphasizes factory nature)\n\nThe `use` prefix doesn't mean React hooks. There's no magic—behaviors are plain functions.\n\n---\n\n## Common Patterns\n\n- **Toggle**: boolean with on/off/toggle\n- **Disclosure**: open/close state with ARIA props\n- **Field**: value + touched + error for forms\n- **Pagination**: currentPage, totalPages, hasNext, hasPrev\n- **Selection**: selected items in a list\n- **Async Action**: pending/error/result for mutations\n",
        "plugins/rimitive-compose/.claude-plugin/plugin.json": "{\n  \"name\": \"rimitive-compose\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Help composing Rimitive services with the right modules and imports\",\n  \"author\": { \"name\": \"Rimitive\" },\n  \"skills\": [\"./skills/\"]\n}\n",
        "plugins/rimitive-compose/skills/skill.md": "---\nname: rimitive-compose\ndescription: Compose Rimitive services with the right modules. Use when setting up a new service, adding primitives, or understanding what modules to import and from where.\n---\n\n# Composing Rimitive Services\n\nRimitive uses `compose()` to wire modules together into a reactive service. This guide helps you choose the right modules and imports.\n\n## Import Paths\n\n```typescript\n// Core composition\nimport { compose } from '@rimitive/core';\n\n// Signal modules (from /extend path)\nimport {\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  BatchModule,\n  SubscribeModule,\n  UntrackModule,\n} from '@rimitive/signals/extend';\n\n// View module factories (need an adapter)\nimport { createElModule } from '@rimitive/view/el';\nimport { createMapModule } from '@rimitive/view/map';\nimport { createMatchModule } from '@rimitive/view/match';\nimport { createPortalModule } from '@rimitive/view/portal';\nimport { createLoadModule } from '@rimitive/view/load';\n\n// Adapters\nimport { createDOMAdapter } from '@rimitive/view/adapters/dom';\nimport { createSSRAdapter } from '@rimitive/ssr/adapter';\nimport { createHydrationAdapter } from '@rimitive/ssr/hydration';\n\n// View helpers\nimport { MountModule } from '@rimitive/view/deps/mount';\nimport { OnModule } from '@rimitive/view/deps/addEventListener';\n\n// Router\nimport { createRouter } from '@rimitive/router';\n\n// Resource (async data)\nimport { createResource } from '@rimitive/resource';\n```\n\n## Common Service Configurations\n\n### Signals Only (No UI)\n\nFor headless logic, state management, or Node.js:\n\n```typescript\nimport { compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';\n\nconst svc = compose(SignalModule, ComputedModule, EffectModule);\nconst { signal, computed, effect } = svc;\n```\n\n### Signals + Batching\n\nWhen you need to batch multiple updates:\n\n```typescript\nimport { compose } from '@rimitive/core';\nimport {\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  BatchModule,\n} from '@rimitive/signals/extend';\n\nconst svc = compose(SignalModule, ComputedModule, EffectModule, BatchModule);\nconst { signal, computed, effect, batch } = svc;\n```\n\n### Full View Service (Browser)\n\nFor building UI components:\n\n```typescript\nimport { compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';\nimport { createElModule } from '@rimitive/view/el';\nimport { createMapModule } from '@rimitive/view/map';\nimport { createMatchModule } from '@rimitive/view/match';\nimport { createDOMAdapter } from '@rimitive/view/adapters/dom';\nimport { MountModule } from '@rimitive/view/deps/mount';\nimport { OnModule } from '@rimitive/view/deps/addEventListener';\n\nconst adapter = createDOMAdapter();\n\nconst svc = compose(\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  createElModule(adapter),\n  createMapModule(adapter),\n  createMatchModule(adapter),\n  MountModule,\n  OnModule\n);\n\nconst { signal, computed, effect, el, map, match, mount, on } = svc;\n```\n\n### View Service with Router\n\nAdd client-side routing:\n\n```typescript\nimport { compose, merge } from '@rimitive/core';\nimport { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';\nimport { createElModule } from '@rimitive/view/el';\nimport { createMapModule } from '@rimitive/view/map';\nimport { createMatchModule } from '@rimitive/view/match';\nimport { createDOMAdapter } from '@rimitive/view/adapters/dom';\nimport { MountModule } from '@rimitive/view/deps/mount';\nimport { createRouter } from '@rimitive/router';\n\nconst adapter = createDOMAdapter();\n\nconst baseSvc = compose(\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  createElModule(adapter),\n  createMapModule(adapter),\n  createMatchModule(adapter),\n  MountModule\n);\n\n// Add router (uses merge because router needs the base service)\nconst router = createRouter(baseSvc);\nconst svc = merge(baseSvc, router);\n\nconst { signal, computed, el, map, match, mount, route, link, navigate } = svc;\n```\n\n### SSR Service\n\nFor server-side rendering:\n\n```typescript\nimport { compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';\nimport { createElModule } from '@rimitive/view/el';\nimport { createMapModule } from '@rimitive/view/map';\nimport { createMatchModule } from '@rimitive/view/match';\nimport { createSSRAdapter } from '@rimitive/ssr/adapter';\n\nconst adapter = createSSRAdapter();\n\nconst svc = compose(\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  createElModule(adapter),\n  createMapModule(adapter),\n  createMatchModule(adapter)\n);\n```\n\n## Module Reference\n\n| Module | Provides | Use When |\n|--------|----------|----------|\n| `SignalModule` | `signal()` | Always - core reactive state |\n| `ComputedModule` | `computed()` | Deriving values from signals |\n| `EffectModule` | `effect()` | Side effects on signal changes |\n| `BatchModule` | `batch()` | Batching multiple updates |\n| `SubscribeModule` | `subscribe()` | External subscriptions to signals |\n| `UntrackModule` | `untrack()` | Reading without tracking |\n| `createElModule(adapter)` | `el()` | Building DOM elements |\n| `createMapModule(adapter)` | `map()` | Reactive lists |\n| `createMatchModule(adapter)` | `match()` | Conditional rendering |\n| `createPortalModule(adapter)` | `portal()` | Render to different DOM location |\n| `createLoadModule(adapter)` | `load()` | Async component loading |\n| `MountModule` | `mount()` | Mounting specs to DOM |\n| `OnModule` | `on()` | Event listener helper with auto-batching |\n\n## Adapter Pattern\n\nView modules need an adapter because Rimitive is renderer-agnostic:\n\n```typescript\n// DOM (browser)\nconst adapter = createDOMAdapter();\n\n// SSR (server)\nconst adapter = createSSRAdapter();\n\n// Hydration (client, after SSR)\nconst adapter = createHydrationAdapter(ssrHtml);\n\n// Custom (canvas, WebGL, etc.)\nconst adapter = createMyAdapter();\n```\n\nThe same view code works with any adapter—swap adapters to change where/how elements render.\n\n## Service Types\n\nExport a type for your service to use in behaviors and components:\n\n```typescript\n// service.ts\nimport { compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';\nimport { createElModule } from '@rimitive/view/el';\nimport { createDOMAdapter } from '@rimitive/view/adapters/dom';\n\nconst adapter = createDOMAdapter();\n\nexport const svc = compose(\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  createElModule(adapter)\n);\n\n// Export the service type for behaviors\nexport type Service = typeof svc;\n```\n\nThen use in behaviors:\n\n```typescript\nimport type { Service } from './service';\n\nconst myBehavior = (svc: Service) => () => {\n  const { signal, computed } = svc;\n  // ...\n};\n```\n",
        "plugins/rimitive-module/.claude-plugin/plugin.json": "{\n  \"name\": \"rimitive-module\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Create custom modules with defineModule for extending Rimitive\",\n  \"author\": { \"name\": \"Rimitive\" },\n  \"skills\": [\"./skills/\"]\n}\n",
        "plugins/rimitive-module/skills/skill.md": "---\nname: rimitive-module\ndescription: Create Rimitive modules with defineModule. Use when adding new primitives, extending the signal system, creating adapters, or building composable functionality that integrates with compose().\n---\n\n# Creating Rimitive Modules\n\nModules are the fundamental unit of composition in Rimitive. They declare dependencies and provide an implementation that becomes available on the composed service.\n\nRimitive's composition system isn't limited to the built-in primitives. You can define your own modules with `defineModule` and compose them alongside signals, view, or anything else.\n\n---\n\n## The Pattern\n\n```typescript\nimport { defineModule } from '@rimitive/core';\n\nconst MyModule = defineModule({\n  name: 'myFeature', // becomes svc.myFeature\n  dependencies: [OtherModule], // optional, resolved by compose()\n  create: ({ otherModule }) => {\n    // receives resolved deps\n    // Return the implementation\n    return { /* API */ };\n  },\n});\n```\n\nThe `name` becomes the key on the composed service. Whatever `create` returns becomes the value.\n\n---\n\n## Basic Module\n\n```typescript\nimport { defineModule, compose } from '@rimitive/core';\n\nconst LoggerModule = defineModule({\n  name: 'logger',\n  create: () => ({\n    log: (msg: string) => console.log(`[LOG] ${msg}`),\n    error: (msg: string) => console.error(`[ERROR] ${msg}`),\n  }),\n});\n\nconst svc = compose(LoggerModule);\nsvc.logger.log('hello');\n```\n\n---\n\n## Modules with Dependencies\n\nDependencies are other modules. They're resolved automatically by `compose()`.\n\n```typescript\nimport { defineModule, compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule } from '@rimitive/signals/extend';\n\nconst CounterModule = defineModule({\n  name: 'counter',\n  dependencies: [SignalModule, ComputedModule],\n  create: ({ signal, computed }) => (initial = 0) => {\n    const count = signal(initial);\n    const doubled = computed(() => count() * 2);\n    return {\n      count,\n      doubled,\n      increment: () => count(count() + 1),\n      decrement: () => count(count() - 1),\n    };\n  },\n});\n\nconst svc = compose(CounterModule);\nconst myCounter = svc.counter(10);\n\nmyCounter.count();      // 10\nmyCounter.increment();\nmyCounter.count();      // 11\nmyCounter.doubled();    // 22\n```\n\nDependencies are resolved automatically. You only need to pass the modules you want—`compose()` includes transitive dependencies.\n\n---\n\n## Module Lifecycle\n\nModules can hook into lifecycle events:\n\n```typescript\nconst ConnectionModule = defineModule({\n  name: 'connection',\n  create: () => {\n    const ws = new WebSocket('wss://example.com');\n    return {\n      send: (msg: string) => ws.send(msg),\n      socket: ws,\n    };\n  },\n  init: (ctx) => {\n    // Called before create, useful for setup\n  },\n  destroy: (ctx) => {\n    // Called when svc.dispose() is invoked\n  },\n});\n\nconst svc = compose(ConnectionModule);\n// ... use the connection\nsvc.dispose(); // triggers destroy hooks\n```\n\n---\n\n## Factory Modules (for Adapters)\n\nWhen a module needs configuration, export a factory function:\n\n```typescript\nimport { defineModule } from '@rimitive/core';\nimport type { Adapter } from '@rimitive/view/types';\n\nexport const createElModule = (adapter: Adapter) =>\n  defineModule({\n    name: 'el',\n    dependencies: [EffectModule],\n    create: ({ effect }) => {\n      // Use adapter and effect to build el()\n      return (tag: string) => { /* ... */ };\n    },\n  });\n\n// Usage:\nconst ElModule = createElModule(domAdapter);\nconst svc = compose(ElModule);\n```\n\n---\n\n## Beyond Reactivity\n\nHere's the thing: `@rimitive/core` has no concept of reactivity. It's just a composition mechanism. You can use it for anything:\n\n```typescript\nimport { defineModule, compose } from '@rimitive/core';\n\nconst HttpModule = defineModule({\n  name: 'http',\n  create: () => ({\n    get: (url: string) => fetch(url).then(r => r.json()),\n    post: (url: string, data: unknown) =>\n      fetch(url, { method: 'POST', body: JSON.stringify(data) }).then(r => r.json()),\n  }),\n});\n\nconst CacheModule = defineModule({\n  name: 'cache',\n  create: () => {\n    const store = new Map<string, unknown>();\n    return {\n      get: <T>(key: string): T | undefined => store.get(key) as T,\n      set: <T>(key: string, value: T): void => { store.set(key, value); },\n      clear: () => store.clear(),\n    };\n  },\n});\n\nconst ApiModule = defineModule({\n  name: 'api',\n  dependencies: [HttpModule, CacheModule],\n  create: ({ http, cache }) => ({\n    async getUser(id: string) {\n      const cached = cache.get<User>(`user:${id}`);\n      if (cached) return cached;\n\n      const user = await http.get(`/api/users/${id}`);\n      cache.set(`user:${id}`, user);\n      return user;\n    },\n  }),\n});\n\nconst svc = compose(ApiModule);\nawait svc.api.getUser('123');\n```\n\nThis makes `compose()` useful for any library or application architecture—not just UI frameworks. You control what gets composed.\n\n---\n\n## Tree-Shaking\n\nBecause you explicitly compose modules, everything is fully tree-shakeable. If you don't use `EffectModule`, it won't be in your bundle:\n\n```typescript\nimport { compose } from '@rimitive/core';\nimport { SignalModule, ComputedModule } from '@rimitive/signals/extend';\n\nconst svc = compose(SignalModule, ComputedModule);\n// No effect or view code bundled\n```\n\n---\n\n## Instrumentation\n\nFor debugging/profiling support:\n\n```typescript\nconst SignalModule = defineModule({\n  name: 'signal',\n  dependencies: [GraphEdgesModule, SchedulerModule],\n  create: ({ graphEdges, scheduler }) =>\n    createSignalFactory({ graphEdges, scheduler }),\n  instrument: (impl, instr, ctx) => (initialValue) => {\n    const sig = impl(initialValue);\n    instr.register(sig, 'signal', { initialValue });\n    return sig;\n  },\n});\n```\n\n---\n\n## Export Types\n\nAlways export the implementation type for consumers:\n\n```typescript\nexport type Logger = {\n  log: (msg: string) => void;\n  error: (msg: string) => void;\n};\n\nexport const LoggerModule = defineModule({\n  name: 'logger',\n  create: (): Logger => ({\n    log: (msg) => console.log(`[LOG] ${msg}`),\n    error: (msg) => console.error(`[ERROR] ${msg}`),\n  }),\n});\n```\n\n---\n\n## File Structure\n\n```\npackages/my-package/src/\n├── index.ts          # Re-exports types\n├── extend.ts         # Exports modules\n├── my-feature.ts     # Module implementation\n└── types.ts          # Type definitions\n```\n\n**index.ts** (types only):\n```typescript\nexport type { MyFeature, MyOptions } from './types';\n```\n\n**extend.ts** (modules):\n```typescript\nexport { MyFeatureModule } from './my-feature';\n```\n\n---\n\n## Naming Conventions\n\n- Module variable: `PascalCaseModule` (e.g., `SignalModule`, `BatchModule`)\n- Module name property: `camelCase` (e.g., `'signal'`, `'batch'`)\n- Factory function: `createXModule` (e.g., `createElModule`)\n\n---\n\n## When to Create Modules\n\nCreate a module when you want to:\n\n- **Add new primitives** to the composed service\n- **Share infrastructure** (logging, http, storage) across behaviors\n- **Encapsulate setup/teardown** with lifecycle hooks\n- **Build your own libraries** on top of composition\n\nFor reusable reactive logic, prefer behaviors. Behaviors are simpler and don't require `defineModule`. Use modules when you need something that lives at the composition level.\n\n---\n\n## Testing Modules\n\n```typescript\nimport { compose } from '@rimitive/core';\nimport { MyModule } from './my-module';\n\ndescribe('MyModule', () => {\n  it('provides the expected API', () => {\n    const svc = compose(MyModule);\n\n    expect(typeof svc.myFeature.doSomething).toBe('function');\n  });\n\n  it('integrates with dependencies', () => {\n    const svc = compose(MyModule, OtherModule);\n\n    svc.myFeature.doSomething();\n    expect(svc.otherModule.wasNotified()).toBe(true);\n  });\n});\n```\n\n---\n\n## Common Module Types\n\n- **Primitive modules**: `SignalModule`, `ComputedModule`, `EffectModule`\n- **Adapter-bound modules**: `createElModule(adapter)`, `createMapModule(adapter)`\n- **Helper modules**: `BatchModule`, `UntrackModule`, `OnModule`\n- **Integration modules**: `MountModule`, `PortalModule`\n",
        "plugins/rimitive-view/.claude-plugin/plugin.json": "{\n  \"name\": \"rimitive-view\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Build views with el, map, match, and other view primitives\",\n  \"author\": { \"name\": \"Rimitive\" },\n  \"skills\": [\"./skills/\"]\n}\n",
        "plugins/rimitive-view/skills/skill.md": "---\nname: rimitive-view\ndescription: Build Rimitive views with el, map, and match. Use when building UI components, rendering reactive content, handling events, or creating reusable view elements.\n---\n\n# Creating Rimitive Views\n\nRimitive components are functions that return element specs. They use `el()` for elements, `map()` for lists, and `match()` for conditionals.\n\n**Important:** Components run once. They are not reactive closures—there's no re-rendering or reconciliation at the function level. All reactivity is encapsulated in the primitives (`signal`, `computed`, `effect`). The function builds the element tree once; signals and computeds handle updates from there.\n\n**Important:** computeds CANNOT return an `el`. It will break.\n\n---\n\n## Setting Up the Service\n\nAdd view modules to your service:\n\n```typescript\nimport { compose } from '@rimitive/core';\nimport {\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n} from '@rimitive/signals/extend';\nimport { createDOMAdapter } from '@rimitive/view/adapters/dom';\nimport { createElModule } from '@rimitive/view/el';\nimport { createMapModule } from '@rimitive/view/map';\nimport { createMatchModule } from '@rimitive/view/match';\nimport { MountModule } from '@rimitive/view/deps/mount';\nimport { OnModule } from '@rimitive/view/deps/addEventListener';\n\nconst adapter = createDOMAdapter();\n\nexport const svc = compose(\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  createElModule(adapter),\n  createMapModule(adapter),\n  createMatchModule(adapter),\n  MountModule,\n  OnModule\n);\n\nexport const { signal, computed, effect, el, map, match, mount, on } = svc;\nexport type Service = typeof svc;\n```\n\n---\n\n## Creating Elements\n\n`el()` is curried: `el(tag)(children)`.\n\n```typescript\n// Just a tag\nconst div = el('div')();\n\n// With text content\nconst heading = el('h1')('Hello, World');\n\n// With children\nconst container = el('div')(el('h1')('Title'), el('p')('Some text'));\n```\n\n---\n\n## Adding Props\n\nUse `.props()` to set attributes and event handlers:\n\n```typescript\nconst button = el('button').props({\n  className: 'primary',\n  disabled: false,\n  onclick: () => console.log('clicked'),\n})('Click me');\n```\n\nProps are fully typed based on the adapter.\n\n---\n\n## Reactive Content\n\nPass a computed for reactive text:\n\n```typescript\nconst count = signal(0);\n\nconst display = el('div')(computed(() => `Count: ${count()}`));\n\ncount(5); // display updates to \"Count: 5\"\n```\n\n---\n\n## Reactive Props\n\nProps can be reactive too:\n\n```typescript\nconst isDisabled = signal(false);\n\nconst button = el('button').props({\n  disabled: isDisabled, // reactive prop\n  onclick: () => console.log('clicked'),\n})('Submit');\n\nisDisabled(true); // button becomes disabled\n```\n\nOr use a computed for derived props:\n\n```typescript\nconst count = signal(0);\n\nconst display = el('div').props({\n  className: computed(() => (count() > 10 ? 'warning' : 'normal')),\n})(computed(() => `Count: ${count()}`));\n```\n\n---\n\n## Components\n\nComponents are just functions that return elements:\n\n```typescript\nconst Greeting = (name: string) => {\n  return el('div')(\n    el('h2')(`Hello, ${name}!`),\n    el('p')('Welcome to Rimitive.')\n  );\n};\n\nconst app = el('div')(Greeting('Ada'), Greeting('Grace'));\n```\n\n---\n\n## Lifecycle with ref()\n\n```typescript\nel('input').ref(\n  // Autofocus on mount\n  (elem) => elem.focus(),\n\n  // ResizeObserver with cleanup\n  (elem) => {\n    const observer = new ResizeObserver(() => console.log('resized'));\n    observer.observe(elem);\n    return () => observer.disconnect();\n  },\n\n  // Event listener using on() helper\n  on('input', (e) => value((e.target as HTMLInputElement).value))\n)();\n```\n\n---\n\n## Reactive Lists with map()\n\n`map()` renders a reactive list efficiently. When items change, it updates only what's necessary.\n\n### Basic Usage\n\nFor primitive arrays:\n\n```typescript\nconst items = signal(['Apple', 'Banana', 'Cherry']);\n\nconst list = el('ul')(map(items, (item) => el('li')(item)));\n```\n\n### Keyed Lists\n\nFor object arrays, provide a key function:\n\n```typescript\ntype Todo = { id: number; text: string; done: boolean };\n\nconst todos = signal<Todo[]>([\n  { id: 1, text: 'Learn Rimitive', done: false },\n  { id: 2, text: 'Build something', done: false },\n]);\n\nconst list = el('ul')(\n  map(\n    todos,\n    (todo) => todo.id, // key function (receives plain value)\n    (todo) =>\n      el('li')(\n        // render function (receives signal)\n        el('span')(computed(() => todo().text)),\n        el('input').props({\n          type: 'checkbox',\n          checked: computed(() => todo().done),\n        })()\n      )\n  )\n);\n```\n\nThe key function receives the plain item value. The render function receives a signal wrapping the item.\n\n### Reactive Item Updates\n\nEach item is wrapped in a signal. When you update an item, the item signal updates—no element recreation:\n\n```typescript\nconst toggleTodo = (id: number) => {\n  todos(todos().map((t) => (t.id === id ? { ...t, done: !t.done } : t)));\n};\n// The checkbox updates reactively without recreating the <li>\n```\n\n---\n\n## Conditional Rendering with match()\n\n`match()` swaps elements based on a reactive value.\n\n### Show/Hide\n\n```typescript\nconst showMessage = signal(true);\n\nconst message = match(showMessage, (show) =>\n  show ? el('div')('Hello!') : null\n);\n\nconst app = el('div')(\n  el('button').props({\n    onclick: () => showMessage(!showMessage()),\n  })('Toggle'),\n  message\n);\n```\n\n### Switching Views\n\n```typescript\nconst isEditMode = signal(false);\nconst text = signal('Click edit to change');\n\nconst content = match(isEditMode, (editing) =>\n  editing ? el('input').props({ value: text })() : el('span')(text)\n);\n```\n\n### Multi-Way Switch\n\n```typescript\ntype Tab = 'home' | 'settings' | 'profile';\nconst currentTab = signal<Tab>('home');\n\nconst tabContent = match(currentTab, (tab) => {\n  switch (tab) {\n    case 'home':\n      return el('div')('Welcome home');\n    case 'settings':\n      return el('div')('Settings panel');\n    case 'profile':\n      return el('div')('Your profile');\n  }\n});\n```\n\n---\n\n## Portals\n\n`portal()` renders content to a different DOM location—useful for modals, tooltips, overlays:\n\n```typescript\nimport { createPortalModule } from '@rimitive/view/portal';\n\n// Add to your service composition\nconst svc = compose(\n  // ... other modules\n  createPortalModule(adapter)\n);\n\nconst { portal } = svc;\n\n// Render to document.body (default)\nconst modal = match(showModal, (show) =>\n  show\n    ? portal()(\n        el('div').props({ className: 'modal-backdrop' })(\n          el('div').props({ className: 'modal' })(\n            el('h2')('Modal Title'),\n            el('button').props({\n              onclick: () => showModal(false),\n            })('Close')\n          )\n        )\n      )\n    : null\n);\n```\n\n---\n\n## Event Handling\n\n### Direct Props\n\n```typescript\nel('button').props({\n  onclick: () => count((c) => c + 1),\n  onmouseenter: () => setHovered(true),\n})('Click');\n```\n\n### Using on() Helper (Auto-Batches)\n\n```typescript\nel('input').ref(\n  on('input', (e) => {\n    // Multiple updates are batched automatically\n    value((e.target as HTMLInputElement).value);\n    touched(true);\n  }),\n  on('blur', () => validate())\n)();\n```\n\n### Prevent Default / Stop Propagation\n\n```typescript\nel('form').props({\n  onsubmit: (e) => {\n    e.preventDefault();\n    handleSubmit();\n  },\n})(/* ... */);\n```\n\n---\n\n## Component Patterns\n\n### With Behaviors\n\n```typescript\nimport { svc, el, computed } from './service';\nimport { counter } from './behaviors/counter';\n\nconst useCounter = svc(counter);\n\nconst Counter = (initial: number) => {\n  const { count, doubled, increment, decrement } = useCounter(initial);\n\n  return el('div')(\n    el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),\n    el('div')(\n      el('button').props({ onclick: decrement })('-'),\n      el('button').props({ onclick: increment })('+')\n    )\n  );\n};\n```\n\n### Portable Components\n\n```typescript\nconst Counter = (svc: Service) => {\n  const { el, computed } = svc;\n  const useCounter = svc(counter);\n\n  return (initial: number) => {\n    const { count, increment, decrement } = useCounter(initial);\n\n    return el('div')(\n      el('span')(computed(() => `Count: ${count()}`)),\n      el('button').props({ onclick: decrement })('-'),\n      el('button').props({ onclick: increment })('+')\n    );\n  };\n};\n\n// Usage\nconst App = (svc: Service) => {\n  const { el, use } = svc;\n  return el('div')(use(Counter)(0), use(Counter)(100));\n};\n```\n\n---\n\n## Mounting\n\n```typescript\nimport { el, mount } from './service';\n\nconst App = () => el('div')(el('h1')('My App'));\n\nconst app = mount(App());\ndocument.querySelector('#app')?.appendChild(app.element!);\n```\n\n---\n\n## Complete Example: Todo List\n\n```typescript\ntype Todo = { id: number; text: string; done: boolean };\ntype Filter = 'all' | 'active' | 'done';\n\nconst todos = signal<Todo[]>([]);\nconst filter = signal<Filter>('all');\nconst inputValue = signal('');\nlet nextId = 0;\n\nconst filteredTodos = computed(() => {\n  const f = filter();\n  const items = todos();\n  if (f === 'all') return items;\n  return items.filter((t) => (f === 'done' ? t.done : !t.done));\n});\n\nconst addTodo = () => {\n  const text = inputValue().trim();\n  if (!text) return;\n  todos([...todos(), { id: nextId++, text, done: false }]);\n  inputValue('');\n};\n\nconst toggleTodo = (id: number) => {\n  todos(todos().map((t) => (t.id === id ? { ...t, done: !t.done } : t)));\n};\n\nconst FilterButton = (value: Filter, label: string) =>\n  el('button').props({\n    className: computed(() => (filter() === value ? 'active' : '')),\n    onclick: () => filter(value),\n  })(label);\n\nconst App = () =>\n  el('div')(\n    el('h1')('Todos'),\n\n    // Input\n    el('div')(\n      el('input').props({\n        type: 'text',\n        placeholder: 'What needs to be done?',\n        value: inputValue,\n        oninput: (e: Event) => inputValue((e.target as HTMLInputElement).value),\n        onkeydown: (e: KeyboardEvent) => {\n          if (e.key === 'Enter') addTodo();\n        },\n      })(),\n      el('button').props({ onclick: addTodo })('Add')\n    ),\n\n    // Filters\n    el('div')(\n      FilterButton('all', 'All'),\n      FilterButton('active', 'Active'),\n      FilterButton('done', 'Done')\n    ),\n\n    // List\n    el('ul')(\n      map(\n        filteredTodos,\n        (t) => t.id,\n        (todo) =>\n          el('li')(\n            el('input').props({\n              type: 'checkbox',\n              checked: computed(() => todo().done),\n              onclick: () => toggleTodo(todo().id),\n            })(),\n            el('span')(computed(() => todo().text))\n          )\n      )\n    ),\n\n    // Empty state\n    match(filteredTodos, (items) =>\n      items.length === 0 ? el('p')('No todos yet') : null\n    )\n  );\n\nconst app = mount(App());\ndocument.body.appendChild(app.element!);\n```\n"
      },
      "plugins": [
        {
          "name": "rimitive-compose",
          "source": "./plugins/rimitive-compose",
          "description": "Help composing Rimitive services with the right modules and imports",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-compose@rimitive-plugins"
          ]
        },
        {
          "name": "rimitive-behavior",
          "source": "./plugins/rimitive-behavior",
          "description": "Create headless behaviors - portable reactive logic without UI",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-behavior@rimitive-plugins"
          ]
        },
        {
          "name": "rimitive-view",
          "source": "./plugins/rimitive-view",
          "description": "Build views with el, map, match, and other view primitives",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-view@rimitive-plugins"
          ]
        },
        {
          "name": "rimitive-module",
          "source": "./plugins/rimitive-module",
          "description": "Create custom modules with defineModule for extending Rimitive",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-module@rimitive-plugins"
          ]
        }
      ]
    }
  ]
}