{
  "author": {
    "id": "hejhi",
    "display_name": "Henry Ivry",
    "avatar_url": "https://avatars.githubusercontent.com/u/1711164?u=54ce01f04bd428dd721be118b41b078efb03b411&v=4"
  },
  "marketplaces": [
    {
      "name": "rimitive-plugins",
      "version": null,
      "description": "Claude Code plugins for developing with Rimitive - composable reactive modules",
      "repo_full_name": "hejhi/rimitive",
      "repo_url": "https://github.com/hejhi/rimitive",
      "repo_description": "Composable, reactive primitive libraries for TypeScript",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-01T03:33:46Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"rimitive-plugins\",\n  \"owner\": {\n    \"name\": \"Rimitive\",\n    \"email\": \"hello@rimitive.dev\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugins for developing with Rimitive - composable reactive modules\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"rimitive-compose\",\n      \"source\": \"./plugins/rimitive-compose\",\n      \"description\": \"Help composing Rimitive services with the right modules and imports\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"rimitive-behavior\",\n      \"source\": \"./plugins/rimitive-behavior\",\n      \"description\": \"Create headless behaviors - portable reactive logic without UI\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"rimitive-view\",\n      \"source\": \"./plugins/rimitive-view\",\n      \"description\": \"Build views with el, map, match, and other view modules\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"rimitive-module\",\n      \"source\": \"./plugins/rimitive-module\",\n      \"description\": \"Create custom modules with defineModule for extending Rimitive\",\n      \"version\": \"1.0.0\"\n    }\n  ]\n}\n",
        "README.md": "<p align=\"center\">\n  <img src=\"assets/rimitive-logo.png\" alt=\"Rimitive\" width=\"200\" />\n</p>\n\n<p align=\"center\">\n  <a href=\"https://github.com/hejhi/rimitive/actions/workflows/ci.yml\"><img src=\"https://github.com/hejhi/rimitive/actions/workflows/ci.yml/badge.svg\" alt=\"CI\"></a>\n  <a href=\"https://www.npmjs.com/package/@rimitive/signals\"><img src=\"https://img.shields.io/npm/v/@rimitive/signals\" alt=\"npm\"></a>\n  <a href=\"LICENSE\"><img src=\"https://img.shields.io/badge/License-MIT-blue.svg\" alt=\"License: MIT\"></a>\n  <a href=\"https://www.typescriptlang.org/\"><img src=\"https://img.shields.io/badge/TypeScript-5.0+-blue\" alt=\"TypeScript\"></a>\n</p>\n\n# Rimitive\n\nType-safe reactive primitives, atomic tooling, and compositional patterns you can use anywhere:\n\n- Add signals to your no-build vanilla js project\n- Build a headless design system with portable, reactive UI logic\n- Write UI components for any javascript environment or platform\n- Create a full stack SSR-with-streaming app\n\nAll constructed on a foundation of reactive primitives. Rimitive is built for low commitment and no framework lock-in. Take as much or as little of it as you want, and easily customize, extend, or replace along the way.\n\n## Quickstart\n\n### Install and Create a Service\n\n```bash\nnpm install @rimitive/core @rimitive/signals\n```\n\nRimitive allows you to create isolated reactive services (with no leakage or pollution of global state) through composition:\n\n```ts\nimport { compose } from '@rimitive/core';\n\n// 1. Import the modules you want to use\nimport {\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n} from '@rimitive/signals/extend';\n\n// 2. Create a reactive service for your app or portable component\nconst { signal, computed, effect } = compose(\n  SignalModule,\n  ComputedModule,\n  EffectModule\n);\n\n// 3. Use it wherever you want, no build or transpilation required\nconst count = signal(0);\nconst doubled = computed(() => count() * 2);\n\neffect(() => console.log(doubled())); // logs: 0\n\ncount(1); // logs: 2\ncount(2); // logs: 4\n```\n\nIf that's what you came for, you can stop here and use this in your vanilla js app or use/write bindings to bring Rimitive signals to other frameworks!\n\n### Add Some UI\n\nIf you don't want to opt-in to a reactive framework like React, you can use Rimitive to tack on only the UI you need, complete with **fine-grained reactivity**:\n\n```bash\nnpm install @rimitive/view\n```\n\n```ts\nimport { createElModule } from '@rimitive/view/el';\nimport { createDOMAdapter } from '@rimitive/view/adapters/dom';\nimport { MountModule } from '@rimitive/view/deps/mount';\n\nconst { signal, computed, el, mount } = compose(\n  SignalModule,\n  ComputedModule,\n  EffectModule,\n  // ðŸ‘‡ As easy as adding some new modules or module factories to your service\n  createElModule(createDOMAdapter()),\n  MountModule\n);\n\nconst Counter = () => {\n  const count = signal(0);\n\n  return el('div')(\n    el('span')(computed(() => `Count: ${count()}`)),\n    el('button').props({ onclick: () => count(count() + 1) })('Increment')\n  );\n};\n\ndocument.body.appendChild(mount(Counter()).element!);\n```\n\nFun fact: UI \"components\" in Rimitive are just a functionâ€”they never re-render. They return a **spec** of a UI that can be mounted and unmounted...that's it. No build or transpilation required!\n\n### Create Some Behaviors\n\nA **behavior** is a pattern for encapsulating reactive state and actions into a reusable function (inspired by [SAM](https://sam.js.org/) and [downshift](https://www.downshift-js.com/)):\n\n```ts\nconst useDisclosure = (initialOpen = false) => {\n  const isOpen = signal(initialOpen);\n\n  return {\n    isOpen,\n    open: () => isOpen(true),\n    close: () => isOpen(false),\n    toggle: () => isOpen(!isOpen()),\n  };\n};\n\n// Use it anywhere\nconst disc = useDisclosure();\ndisc.open();\n```\n\n`use*` is just a naming convention; it doesn't confer any reactive superpowers like other frameworks, and there's no rules. This is just a pattern.\n\n### Composition and Portability\n\nInstead of directly importing from a shared service, you can wrap functions for service injection:\n\n```ts\n// Instead of importing directly...\nconst useDisclosure = (initialOpen = false) => {\n  const isOpen = signal(initialOpen); // signal comes from somewhere\n  // ...\n};\n\n// ...receive what you need\nconst disclosure =\n  ({ signal }: Service) =>\n  (initialOpen = false) => {\n    const isOpen = signal(initialOpen);\n    // ...\n  };\n\n// Then wire it up\nconst useDisclosure = svc(counter); // svc provides signal, computed, etc.\n```\n\nThe same pattern works for components and ergonomic composition:\n\n```ts\nconst dropdown = (svc: Service) => {\n  // Compose other components or behaviors in the service closure\n  // Runs a single time (not on every mount/unmount)\n  const useDisclosure = svc(disclosure);\n\n  return (options?: { initialOpen?: boolean }) => {\n    const disc = useDisclosure(options?.initialOpen ?? false);\n\n    // Add keyboard handling\n    // Look ma, no memoization required! Remember? No re-rendering?\n    const onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Enter') return;\n      e.preventDefault();\n      disc.toggle();\n    };\n\n    return {\n      ...disc,\n      onKeyDown,\n    };\n  };\n};\n\n// Wire it up\nconst Dropdown = svc(dropdown);\nconst app = svc.mount(Dropdown());\n```\n\nTyping is a breeze:\n\n```ts\nexport const svc = compose(SignalModule, ComputedModule);\nexport type Service = typeof svc;\n\nconst myComponent = ({ signal, computed }: Service) => {\n  return () => // ...\n};\n```\n\nNow you're a Rimitive expert! Everything else simply builds on top of this. Routing, data fetching, even SSR (with or without streaming)â€”they all work the same way. This just demonstrates the beginnings of what's possible with Rimitive.\n\n---\n\n## The stack\n\nRimitive is intentionally layered, allowing you to opt-in only as needed.\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Domain Tooling                         â”‚\nâ”‚  view (el, map), router, resource, etc  â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Adapters                               â”‚\nâ”‚  DOM, SSR, canvas, your own             â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Reactive Core                          â”‚\nâ”‚  signal, computed, effect, etc          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n- **Reactive core** â€” `signal`, `computed`, `effect`, etc. The foundation everything else is built with.\n- **Domain tooling** â€” `el`, `map`, etc for views, `matches` for routing, `resource` for data. Each domain provides (but does not prescribe) tools built on the reactive core. Create your own!\n- **Adapters** â€” Plug in where you want it to run, and the types flow through. DOM, SSR, logic-only (for hydration or testing), or roll your own. Any UI that can be modeled as a tree can have an adapter.\n\nEach layer is tiny, opt-in, swappable, and extensible. Use just the signals, plug in only the views you need later, or bring behaviors to other frameworks like React.\n\n---\n\n## Packages\n\n| Package                                   | Layer          | What it does                         |\n| ----------------------------------------- | -------------- | ------------------------------------ |\n| [`@rimitive/core`](packages/core)         | Core           | Wires modules together â€” `compose()` |\n| [`@rimitive/signals`](packages/signals)   | Reactive core  | `signal`, `computed`, `effect`       |\n| [`@rimitive/view`](packages/view)         | Domain tooling | View layer â€” `el`, `map`, `match`    |\n| [`@rimitive/router`](packages/router)     | Domain tooling | Routing â€” `matches`, `navigate()`    |\n| [`@rimitive/resource`](packages/resource) | Domain tooling | Async data fetching                  |\n| [`@rimitive/ssr`](packages/ssr)           | Adapters       | Server-side rendering and streaming  |\n| [`@rimitive/react`](packages/react)       | Bindings       | Use Rimitive behaviors in React      |\n\nStart with `@rimitive/core` and `@rimitive/signals`. Add the rest as you need them.\n\n## Advanced\n\n### Adapters\n\nSame code, different targets:\n\n```ts\ncreateElModule(createDOMAdapter()); // Browser\ncreateElModule(createParse5Adapter()); // Server (SSR)\ncreateElModule(myCanvasAdapter()); // Your own\n```\n\n### Extending\n\nCreate your own modules with `defineModule()`:\n\n```ts\nimport { defineModule } from '@rimitive/core';\n\nconst LoggerModule = defineModule({\n  name: 'logger',\n  provides: { log: (msg: string) => console.log(`[app] ${msg}`) },\n});\n\nconst { signal, log } = compose(SignalModule, LoggerModule);\n```\n\nSee [Custom Modules](https://rimitive.dev/guides/custom-modules/) for the full picture.\n\n---\n\n## Status\n\nAlpha. Tested, benchmarked, used in personal projects. Not yet battle-tested in production.\n\n[Why Rimitive?](https://rimitive.dev/why/) â€” the story behind the project.\n\n[Get started â†’](https://rimitive.dev/guides/getting-started)\n"
      },
      "plugins": [
        {
          "name": "rimitive-compose",
          "source": "./plugins/rimitive-compose",
          "description": "Help composing Rimitive services with the right modules and imports",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-compose@rimitive-plugins"
          ]
        },
        {
          "name": "rimitive-behavior",
          "source": "./plugins/rimitive-behavior",
          "description": "Create headless behaviors - portable reactive logic without UI",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-behavior@rimitive-plugins"
          ]
        },
        {
          "name": "rimitive-view",
          "source": "./plugins/rimitive-view",
          "description": "Build views with el, map, match, and other view modules",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-view@rimitive-plugins"
          ]
        },
        {
          "name": "rimitive-module",
          "source": "./plugins/rimitive-module",
          "description": "Create custom modules with defineModule for extending Rimitive",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hejhi/rimitive",
            "/plugin install rimitive-module@rimitive-plugins"
          ]
        }
      ]
    }
  ]
}