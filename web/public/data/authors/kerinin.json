{
  "author": {
    "id": "kerinin",
    "display_name": "Ryan Michael",
    "avatar_url": "https://avatars.githubusercontent.com/u/161938?v=4"
  },
  "marketplaces": [
    {
      "name": "claude-modes",
      "version": null,
      "description": "Modal execution plugins for Claude Code",
      "repo_full_name": "kerinin/claude-modes",
      "repo_url": "https://github.com/kerinin/claude-modes",
      "repo_description": "Modal execution plugin for Claude Code",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-12T00:00:36Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"claude-modes\",\n  \"description\": \"Modal execution plugins for Claude Code\",\n  \"owner\": {\n    \"name\": \"Ryan Michael\",\n    \"email\": \"ryan@example.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"modes\",\n      \"description\": \"Enforce workflows like TDD by limiting actions based on current mode\",\n      \"version\": \"0.1.0\",\n      \"author\": {\n        \"name\": \"Ryan Michael\"\n      },\n      \"source\": \"./plugins/modes\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "README.md": "# Modes Plugin\n\nModal execution for Claude Code - enforce workflows like TDD by limiting actions based on current mode.\n\n## The Problem\n\nClaude Code is great at completing tasks, but it often takes shortcuts. Ask it to do TDD and it might:\n- Jump straight to implementation without writing a test\n- Modify your test file while \"fixing\" a bug\n- Skip the red-green-refactor cycle entirely\n\nYou can remind Claude to follow the process, but those instructions get lost during context compaction. There's no enforcement - just hope.\n\n## The Solution\n\nDefine your own workflow as a state machine. You create modes with:\n- **Permissions** - what files/tools Claude can use in each mode\n- **Transition constraints** - conditions for moving between modes\n\nYou decide what works for you. Want strict TDD? Lock down source files until tests fail. Prefer a lighter touch? Skip permissions and just use transitions as guideposts.\n\n**Example: a TDD workflow**\n\n```\nidle ──────────► test-dev ──────────► feature-dev ──────────► idle\n     \"describe a       \"test exists        \"all tests\n      bug/feature\"      and fails\"          pass\"\n```\n\nThis config restricts `test-dev` to test files only, `feature-dev` to source files only. But that's just one approach - your `modes.yaml` defines whatever workflow fits your process.\n\n**Why this works:**\n- Mode state survives context compaction (injected every prompt)\n- Permissions enforced by hooks, not just instructions\n- Constraints visible to Claude, guiding rather than just blocking\n- Fully customizable to match how you actually work\n\n## Installation\n\n```\n/plugin marketplace add kerinin/claude-modes\n/plugin install modes@claude-modes\n```\n\nThen run `/modes:setup` to configure permissions. This adds the modes MCP tools to your allow list so Claude can check and update mode state without prompting you each time.\n\n## Setup\n\n### Quick Start\n\nCopy the example TDD workflow to your project:\n\n```bash\ncp -r ~/.claude/plugins/modes/examples/tdd/* .claude/\n```\n\nThis gives you a working TDD workflow out of the box. Read on to understand what each file does and how to customize it.\n\n### Configuration Files\n\nModes config lives in your project's `.claude/` directory:\n\n#### `.claude/modes.yaml` - The Workflow Definition\n\nThis is your state machine. It defines what modes exist and when Claude can move between them.\n\n```yaml\nname: tdd-workflow\ndefault: idle\n\nmodes:\n  idle:\n    transitions:\n      - to: test-dev\n        constraint: User has described a bug or feature to work on\n\n  test-dev:\n    transitions:\n      - to: feature-dev\n        constraint: |\n          A test exists that targets the bug/feature.\n          The test has been executed and is currently failing.\n\n  feature-dev:\n    transitions:\n      - to: idle\n        constraint: All tests are passing.\n```\n\nThe `constraint` is shown to Claude and guides when it should transition. Claude evaluates whether the constraint is satisfied and calls the transition tool when ready.\n\n#### `.claude/CLAUDE.<mode>.md` - Mode Instructions\n\nThese work just like your project's root `CLAUDE.md`, but only get loaded when Claude is in that mode. Use them to give Claude mode-specific guidance.\n\n```markdown\n<!-- .claude/CLAUDE.test-dev.md -->\nYou are writing a failing test. Focus on:\n1. Understanding the expected behavior\n2. Writing a test that verifies that behavior\n3. Running the test to confirm it fails\n\nDo NOT modify implementation code in this mode.\n```\n\nYour root `CLAUDE.md` is always loaded. Mode instructions are additive - they don't replace your base instructions, they supplement them for that phase of work.\n\n#### `.claude/settings.<mode>.json` - Mode Permissions\n\nThese constrain what Claude can do while in a specific mode. The `allow` and `deny` lists use glob patterns to control file and tool access.\n\n```json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Read(**)\",\n      \"Write({test/**,**/*.test.ts})\",\n      \"Edit({test/**,**/*.test.ts})\",\n      \"Bash(npm test*)\"\n    ],\n    \"deny\": [\n      \"Write(src/**)\",\n      \"Edit(src/**)\"\n    ]\n  }\n}\n```\n\nIn this example, while in `test-dev` mode Claude can read anything, write/edit test files, and run tests - but it cannot touch source files. The hook blocks the action before it happens.\n\n**Permissions are optional.** If you just want transitions as guideposts without hard enforcement, skip the settings files entirely.\n\n## Usage\n\n### How It Works in Practice\n\nOnce configured, modes work automatically. Here's what a TDD session might look like:\n\n```\nYou: Fix the bug where users can't log in with email addresses containing a plus sign\n\nClaude: I'll help fix that login bug. Let me first write a test to verify the issue.\n        [MODE: idle → test-dev]\n\n        Creating test for plus sign in email...\n        [Creates test/auth.test.ts]\n\n        Running the test to confirm it fails...\n        [Runs: npm test]\n\n        Test fails as expected. Now I'll implement the fix.\n        [MODE: test-dev → feature-dev]\n\n        [Edits src/auth.ts to fix email parsing]\n\n        Running tests to verify the fix...\n        [Runs: npm test]\n\n        All tests pass.\n        [MODE: feature-dev → idle]\n\nYou: Great, thanks!\n```\n\n**What's happening behind the scenes:**\n\n1. **Context injection** - Every prompt, Claude sees the current mode, its instructions, and available transitions. This is why Claude knows to start with a test.\n\n2. **Permission enforcement** - In `test-dev`, if Claude tried to edit `src/auth.ts`, the hook would block it. Claude literally can't skip ahead.\n\n3. **Transition gating** - Claude can't move to `feature-dev` until it's written and run a failing test. The constraint is visible, so Claude knows what it needs to do.\n\n4. **State persistence** - Even if the conversation compacts and loses earlier messages, the mode state persists. Claude stays in `feature-dev` until tests pass.\n\n### Escape Hatches\n\nSometimes you need to override the workflow. The slash commands let you intervene:\n\n- `/modes:mode` - Check current mode and available transitions\n- `/modes:mode <name>` - Force transition to a specific mode (requires approval)\n- `/modes:mode reset` - Return to the default mode\n\nForce transitions require explicit approval because they bypass the constraint system. This is intentional - the workflow should guide normal operation, with manual overrides as the exception.\n\n### Status Line\n\nYou can display the current mode in Claude Code's status line - similar to how terminal prompts show the git branch. This gives you constant visibility into which mode is active.\n\nWhen configured, you'll see something like `⟪test-dev⟫` at the bottom of Claude Code.\n\nTo set this up, run `/modes:setup` and opt in when asked about the status line. Or manually:\n\n1. Copy the script:\n```bash\ncp ~/.claude/plugins/modes/examples/statusline/modes-statusline.sh ~/.claude/\nchmod +x ~/.claude/modes-statusline.sh\n```\n\n2. Add to `~/.claude/settings.json`:\n```json\n{\n  \"statusLine\": {\n    \"type\": \"command\",\n    \"command\": \"~/.claude/modes-statusline.sh\"\n  }\n}\n```\n\nThe status line updates automatically when you transition between modes.\n\n## Example Workflows\n\nThe `examples/` directory includes a TDD workflow. Here are other workflows where modes shine:\n\n### Test-Driven Development\n\n**The problem:** Claude jumps straight to implementation, or modifies tests while \"fixing\" bugs.\n\n**Why modes help:** Separate `test-dev` and `feature-dev` phases with file permissions. Claude literally cannot edit source files until a failing test exists, and cannot touch tests while implementing. The red-green-refactor cycle becomes the only path forward.\n\n### Design-First Development\n\n**The problem:** Claude starts coding before design decisions are documented and approved.\n\n**Why modes help:** A `design` mode that only allows editing docs/design files. The transition constraint requires design approval before moving to implementation. Claude can explore and prototype in design mode, but can't ship code until the approach is locked in.\n\n### Bug Triage\n\n**The problem:** Claude attempts fixes without first reproducing and diagnosing the issue.\n\n**Why modes help:** A `reproduce` → `diagnose` → `fix` workflow. In `reproduce` mode, Claude can only read code and run tests - no edits allowed. It must demonstrate the bug exists before moving on. In `diagnose` mode, it documents the root cause before `fix` mode unlocks editing.\n\n### Refactoring\n\n**The problem:** Claude makes changes without ensuring tests pass before and after.\n\n**Why modes help:** A `verify-green` → `refactor` → `verify-green` cycle. The first phase confirms tests pass (constraint: \"all tests passing\"). Refactoring mode allows edits but the transition back requires tests to pass again. No refactor can leave tests broken.\n\n### Security-Sensitive Changes\n\n**The problem:** Claude modifies auth, crypto, or other sensitive code without proper review.\n\n**Why modes help:** Permissions can restrict which files are editable in each mode. A `security-review` mode might allow reading sensitive files but require explicit user approval (via forced transition) before entering a mode that can edit them.\n\n## Best Practices\n\n### Keep your base permissions open\n\nYour project's base `settings.json` permissions are always enforced - mode permissions can only add restrictions, not remove them. If your base settings deny `Write(src/**)`, no mode can override that.\n\nThis means your base permissions should generally be permissive. Let modes handle the restrictions for specific workflow phases.\n\n### Start with transitions, add permissions later\n\nYou don't need permissions to get value from modes. Start with just `modes.yaml` - the transition constraints alone help Claude follow your workflow. Add `settings.<mode>.json` files later if you find Claude needs harder guardrails.\n\n### Write constraints for Claude, not for you\n\nConstraints are shown to Claude to help it decide when to transition. Write them as clear conditions Claude can evaluate:\n\n```yaml\n# Good - Claude can check this\nconstraint: A failing test exists that covers the bug\n\n# Less good - vague, hard to evaluate\nconstraint: Ready to implement\n```\n\n### Mode instructions should focus, not repeat\n\n`CLAUDE.<mode>.md` files work best when they focus Claude's attention on the current phase. Don't repeat everything from your root `CLAUDE.md` - mode instructions are additive.\n\n```markdown\n<!-- Good - focused on this phase -->\nYou are writing a failing test. Focus on the expected behavior.\nDo NOT modify implementation code yet.\n\n<!-- Less good - restating general practices -->\nYou are writing a failing test. Follow our coding standards.\nUse TypeScript. Write clean code. Add comments...\n```\n\n### Design for how you actually work\n\nDon't copy a workflow verbatim - adapt it to your actual process. If you sometimes skip writing tests for trivial changes, maybe your constraint should be \"User has described a bug or feature that warrants a test\" rather than requiring tests for everything.\n"
      },
      "plugins": [
        {
          "name": "modes",
          "description": "Enforce workflows like TDD by limiting actions based on current mode",
          "version": "0.1.0",
          "author": {
            "name": "Ryan Michael"
          },
          "source": "./plugins/modes",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add kerinin/claude-modes",
            "/plugin install modes@claude-modes"
          ]
        }
      ]
    }
  ]
}