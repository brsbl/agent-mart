{
  "author": {
    "id": "dvdsgl",
    "display_name": "David Siegel",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/108197?u=f24d534a751a733b7b47a4265bd6d4f061a2c129&v=4",
    "url": "https://github.com/dvdsgl",
    "bio": "Creating developer tools for everyone.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 1,
      "total_skills": 4,
      "total_stars": 1359,
      "total_forks": 136
    }
  },
  "marketplaces": [
    {
      "name": "claude-canvas",
      "version": null,
      "description": "Claude Code plugin marketplace for interactive terminal TUI components",
      "owner_info": {
        "name": "David Siegel",
        "email": "djsiegel@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "dvdsgl/claude-canvas",
      "repo_url": "https://github.com/dvdsgl/claude-canvas",
      "repo_description": "Give Claude Code an external monitor",
      "homepage": "",
      "signals": {
        "stars": 1359,
        "forks": 136,
        "pushed_at": "2026-01-08T02:19:55Z",
        "created_at": "2026-01-06T23:24:00Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 492
        },
        {
          "path": "canvas",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/README.md",
          "type": "blob",
          "size": 1490
        },
        {
          "path": "canvas/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/commands/canvas.md",
          "type": "blob",
          "size": 2246
        },
        {
          "path": "canvas/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/skills/calendar",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/skills/calendar/SKILL.md",
          "type": "blob",
          "size": 3571
        },
        {
          "path": "canvas/skills/canvas",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/skills/canvas/SKILL.md",
          "type": "blob",
          "size": 3366
        },
        {
          "path": "canvas/skills/document",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/skills/document/SKILL.md",
          "type": "blob",
          "size": 3741
        },
        {
          "path": "canvas/skills/flight",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/skills/flight/SKILL.md",
          "type": "blob",
          "size": 4656
        },
        {
          "path": "canvas/src",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/src/canvases",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/src/canvases/calendar",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/src/canvases/calendar/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/src/canvases/calendar/hooks/index.ts",
          "type": "blob",
          "size": 82
        },
        {
          "path": "canvas/src/canvases/calendar/hooks/use-ipc-server.ts",
          "type": "blob",
          "size": 4035
        },
        {
          "path": "canvas/src/canvases/calendar/hooks/use-ipc.ts",
          "type": "blob",
          "size": 3109
        },
        {
          "path": "canvas/src/canvases/calendar/hooks/use-mouse.ts",
          "type": "blob",
          "size": 6605
        },
        {
          "path": "canvas/src/canvases/document",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/src/canvases/document/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "canvas/src/canvases/document/hooks/index.ts",
          "type": "blob",
          "size": 210
        },
        {
          "path": "canvas/src/canvases/document/hooks/use-text-selection.ts",
          "type": "blob",
          "size": 6602
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-canvas\",\n  \"owner\": {\n    \"name\": \"David Siegel\",\n    \"email\": \"djsiegel@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugin marketplace for interactive terminal TUI components\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"canvas\",\n      \"source\": \"./canvas\",\n      \"description\": \"Spawn and control interactive terminal displays (calendars, documents, flights) with real-time IPC communication\",\n      \"version\": \"0.1.0\",\n      \"strict\": false\n    }\n  ]\n}\n",
        "canvas/README.md": "# Canvas Plugin\n\nInteractive terminal TUI components for Claude Code.\n\n## Overview\n\nCanvas provides spawnable terminal displays (calendars, documents, flight booking) with real-time IPC communication. Claude can spawn these TUIs in tmux split panes and receive user selections.\n\n## Canvas Types\n\n| Type | Description |\n|------|-------------|\n| `calendar` | Display events, pick meeting times |\n| `document` | View/edit markdown documents |\n| `flight` | Compare flights and select seats |\n\n## Installation\n\n```bash\n# Add as Claude Code plugin\nclaude --plugin-dir /path/to/claude-canvas/canvas\n\n# Or via marketplace\n/plugin marketplace add djsiegel/claude-canvas\n/plugin install claude-canvas@canvas\n```\n\n## Usage\n\n```bash\n# Show calendar in current terminal\nbun run src/cli.ts show calendar\n\n# Spawn meeting picker in tmux split\nbun run src/cli.ts spawn calendar --scenario meeting-picker --config '{\"calendars\": [...]}'\n\n# Spawn document editor\nbun run src/cli.ts spawn document --scenario edit --config '{\"content\": \"# Hello\"}'\n```\n\n## Commands\n\n- `/canvas` - Interactive canvas spawning\n\n## Skills\n\n- `canvas` - Main skill with overview and IPC details\n- `calendar` - Calendar display and meeting picker\n- `document` - Markdown rendering and text selection\n- `flight` - Flight comparison and seatmaps\n\n## Requirements\n\n- **tmux** - Canvas spawning requires a tmux session\n- **Bun** - Runtime for CLI commands\n- **Terminal with mouse support** - For interactive scenarios\n\n## License\n\nMIT\n",
        "canvas/commands/canvas.md": "---\nname: canvas\ndescription: Spawn interactive terminal canvases for calendars, documents, and flight booking\n---\n\n# Canvas Command\n\nSpawn and control interactive terminal displays (TUIs) in tmux split panes.\n\n## Usage\n\nWhen the user invokes `/canvas`, help them spawn the appropriate canvas type based on their needs.\n\n## Workflow\n\n### Step 1: Determine Canvas Type\n\nAsk what kind of canvas the user needs:\n\n- **Calendar** - Display events or pick meeting times\n- **Document** - View or edit markdown content\n- **Flight** - Compare flights and select seats\n\n### Step 2: Gather Configuration\n\nBased on the canvas type, collect the necessary configuration:\n\n**Calendar:**\n- Events to display (title, start/end times)\n- For meeting picker: multiple calendars with busy times\n- Slot granularity (15/30/60 minutes)\n\n**Document:**\n- Markdown content to display\n- Document title\n- Edit mode or display-only\n- Optional diff highlighting\n\n**Flight:**\n- Flight options (airline, times, prices)\n- Seatmap configuration\n- Origin/destination airports\n\n### Step 3: Spawn Canvas\n\nUse the CLI to spawn the canvas:\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT}\nbun run src/cli.ts spawn [type] --scenario [scenario] --config '[json]'\n```\n\n**Examples:**\n\n```bash\n# Calendar display\nbun run src/cli.ts spawn calendar --config '{\"events\": [...]}'\n\n# Meeting picker\nbun run src/cli.ts spawn calendar --scenario meeting-picker --config '{\"calendars\": [...]}'\n\n# Document editor\nbun run src/cli.ts spawn document --scenario edit --config '{\"content\": \"# Title\", \"title\": \"Doc\"}'\n\n# Flight booking\nbun run src/cli.ts spawn flight --config '{\"flights\": [...]}'\n```\n\n### Step 4: Handle Results\n\nWait for user interaction and handle the result:\n\n- **Selected**: User made a selection (time slot, text, flight+seat)\n- **Cancelled**: User pressed Escape or quit\n- **Error**: Something went wrong\n\n## Requirements\n\n- Must be running inside a tmux session\n- Terminal should support mouse input for interactive scenarios\n\n## Skills Reference\n\nRead these skills for detailed configuration options:\n\n- `canvas` - Overview and IPC communication\n- `calendar` - Calendar events and meeting picker\n- `document` - Markdown rendering and text selection\n- `flight` - Flight comparison and seatmaps\n",
        "canvas/skills/calendar/SKILL.md": "---\nname: calendar\ndescription: |\n  Calendar canvas for displaying events and picking meeting times.\n  Use when showing calendar views or when users need to select available time slots.\n---\n\n# Calendar Canvas\n\nDisplay calendar views and enable interactive meeting time selection.\n\n## Example Prompts\n\nTry asking Claude:\n\n- \"Schedule a 30-minute meeting with Alice and Bob sometime next week\"\n- \"Find a time when the engineering team is all free on Tuesday\"\n- \"Show me my calendar for this week\"\n- \"When is everyone available for a 1-hour planning session?\"\n- \"Block off 2-4pm on Friday for focused work\"\n\n## Scenarios\n\n### `display` (default)\nView-only calendar display. User can navigate weeks but cannot select times.\n\n```bash\nbun run src/cli.ts show calendar --scenario display --config '{\n  \"title\": \"My Week\",\n  \"events\": [\n    {\"id\": \"1\", \"title\": \"Meeting\", \"startTime\": \"2025-01-06T09:00:00\", \"endTime\": \"2025-01-06T10:00:00\"}\n  ]\n}'\n```\n\n### `meeting-picker`\nInteractive scenario for selecting a free time slot when viewing multiple people's calendars.\n\n- Shows multiple calendars overlaid with different colors\n- User can **click** on free slots to select a meeting time\n- Selection is sent back via IPC\n- Supports configurable time slot granularity (15/30/60 min)\n\n```bash\nbun run src/cli.ts spawn calendar --scenario meeting-picker --config '{\n  \"calendars\": [\n    {\n      \"name\": \"Alice\",\n      \"color\": \"blue\",\n      \"events\": [\n        {\"id\": \"1\", \"title\": \"Standup\", \"startTime\": \"2025-01-06T09:00:00\", \"endTime\": \"2025-01-06T09:30:00\"}\n      ]\n    },\n    {\n      \"name\": \"Bob\",\n      \"color\": \"green\",\n      \"events\": [\n        {\"id\": \"2\", \"title\": \"Call\", \"startTime\": \"2025-01-06T14:00:00\", \"endTime\": \"2025-01-06T15:00:00\"}\n      ]\n    }\n  ],\n  \"slotGranularity\": 30,\n  \"minDuration\": 30,\n  \"maxDuration\": 120\n}'\n```\n\n## Configuration\n\n### Display Config\n```typescript\ninterface CalendarConfig {\n  title?: string;\n  events: CalendarEvent[];\n}\n\ninterface CalendarEvent {\n  id: string;\n  title: string;\n  startTime: string;  // ISO datetime\n  endTime: string;    // ISO datetime\n  color?: string;     // blue, green, red, yellow, magenta, cyan\n}\n```\n\n### Meeting Picker Config\n```typescript\ninterface MeetingPickerConfig {\n  calendars: Calendar[];\n  slotGranularity?: number;  // 15, 30, or 60 minutes (default: 30)\n  minDuration?: number;      // Minimum meeting duration in minutes\n  maxDuration?: number;      // Maximum meeting duration in minutes\n}\n\ninterface Calendar {\n  name: string;              // Person's name\n  color: string;             // Calendar color\n  events: CalendarEvent[];   // Their busy times\n}\n```\n\n## Controls\n\n**Display scenario:**\n- `←/→` or `h/l`: Navigate between days\n- `n` or `PageDown`: Next week\n- `p` or `PageUp`: Previous week\n- `t`: Jump to today\n- `q` or `Esc`: Quit\n\n**Meeting picker scenario:**\n- **Mouse click**: Select a free time slot\n- `←/→`: Navigate weeks\n- `t`: Jump to today\n- `q` or `Esc`: Cancel selection\n\n## Selection Result\n\n```typescript\ninterface MeetingSelection {\n  startTime: string;  // ISO datetime\n  endTime: string;    // ISO datetime\n  duration: number;   // Minutes\n}\n```\n\n## API Usage\n\n```typescript\nimport { pickMeetingTime } from \"${CLAUDE_PLUGIN_ROOT}/src/api\";\n\nconst result = await pickMeetingTime({\n  calendars: [\n    { name: \"Alice\", color: \"blue\", events: [...] },\n    { name: \"Bob\", color: \"green\", events: [...] },\n  ],\n  slotGranularity: 30,\n});\n\nif (result.success && result.data) {\n  console.log(`Selected: ${result.data.startTime} - ${result.data.endTime}`);\n}\n```\n",
        "canvas/skills/canvas/SKILL.md": "---\nname: canvas\ndescription: |\n  **The primary skill for terminal TUI components.** Covers spawning, controlling, and interacting with terminal canvases.\n  Use when displaying calendars, documents, or flight bookings.\n---\n\n# Canvas TUI Toolkit\n\n**Start here when using terminal canvases.** This skill covers the overall workflow, canvas types, and IPC communication.\n\n## Example Prompts\n\nTry asking Claude things like:\n\n**Calendar:**\n- \"Schedule a meeting with the team next week\"\n- \"Find a time when Alice and Bob are both free\"\n\n**Document:**\n- \"Draft an email to the sales team about the new feature\"\n- \"Help me edit this document — let me select what to change\"\n\n**Flight:**\n- \"Find flights from SFO to Denver next Friday\"\n- \"Book me a window seat on the morning flight\"\n\n## Overview\n\nCanvas provides interactive terminal displays (TUIs) that Claude can spawn and control. Each canvas type supports multiple scenarios for different interaction modes.\n\n## Available Canvas Types\n\n| Canvas | Purpose | Scenarios |\n|--------|---------|-----------|\n| `calendar` | Display calendars, pick meeting times | `display`, `meeting-picker` |\n| `document` | View/edit markdown documents | `display`, `edit`, `email-preview` |\n| `flight` | Flight comparison and seat selection | `booking` |\n\n## Quick Start\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT}\n\n# Run canvas in current terminal\nbun run src/cli.ts show calendar\n\n# Spawn canvas in new tmux split\nbun run src/cli.ts spawn calendar --scenario meeting-picker --config '{...}'\n```\n\n## Spawning Canvases\n\n**Always use `spawn` for interactive scenarios** - this opens the canvas in a tmux split pane while keeping the conversation terminal available.\n\n```bash\nbun run src/cli.ts spawn [kind] --scenario [name] --config '[json]'\n```\n\n**Parameters:**\n- `kind`: Canvas type (calendar, document, flight)\n- `--scenario`: Interaction mode (e.g., display, meeting-picker, edit)\n- `--config`: JSON configuration for the canvas\n- `--id`: Optional canvas instance ID for IPC\n\n## IPC Communication\n\nInteractive canvases communicate via Unix domain sockets.\n\n**Canvas → Controller:**\n```typescript\n{ type: \"ready\", scenario }        // Canvas is ready\n{ type: \"selected\", data }         // User made a selection\n{ type: \"cancelled\", reason? }     // User cancelled\n{ type: \"error\", message }         // Error occurred\n```\n\n**Controller → Canvas:**\n```typescript\n{ type: \"update\", config }  // Update canvas configuration\n{ type: \"close\" }           // Request canvas to close\n{ type: \"ping\" }            // Health check\n```\n\n## High-Level API\n\nFor programmatic use, import the API module:\n\n```typescript\nimport { pickMeetingTime, editDocument, bookFlight } from \"${CLAUDE_PLUGIN_ROOT}/src/api\";\n\n// Spawn meeting picker and wait for selection\nconst result = await pickMeetingTime({\n  calendars: [...],\n  slotGranularity: 30,\n});\n\nif (result.success && result.data) {\n  console.log(`Selected: ${result.data.startTime}`);\n}\n```\n\n## Requirements\n\n- **tmux**: Canvas spawning requires a tmux session\n- **Terminal with mouse support**: For click-based interactions\n- **Bun**: Runtime for executing canvas commands\n\n## Skills Reference\n\n| Skill | Purpose |\n|-------|---------|\n| `calendar` | Calendar display and meeting picker details |\n| `document` | Document rendering and text selection |\n| `flight` | Flight comparison and seat map details |\n",
        "canvas/skills/document/SKILL.md": "---\nname: document\ndescription: |\n  Document canvas for displaying and editing markdown content.\n  Use when showing documents, emails, or when users need to select text for editing.\n---\n\n# Document Canvas\n\nDisplay markdown documents with optional text selection and diff highlighting.\n\n## Example Prompts\n\nTry asking Claude:\n\n- \"Draft an email to the marketing team about the Q1 product launch\"\n- \"Help me edit this blog post — show it so I can highlight the parts to revise\"\n- \"Write a project proposal and let me review it\"\n- \"Show me the README so I can select sections to update\"\n- \"Compose a response to this customer complaint\"\n\n## Scenarios\n\n### `display` (default)\nRead-only document view with markdown rendering. User can scroll but cannot select text.\n\n```bash\nbun run src/cli.ts show document --scenario display --config '{\n  \"content\": \"# Hello World\\n\\nThis is **markdown** content.\",\n  \"title\": \"My Document\"\n}'\n```\n\n### `edit`\nInteractive document view with text selection. User can click and drag to select text, which is sent via IPC in real-time.\n\n- Renders markdown with syntax highlighting (headers, bold, italic, code, links, lists, blockquotes)\n- Diff highlighting: green background for additions, red for deletions\n- Click and drag to select text\n- Selection automatically sent via IPC\n\n```bash\nbun run src/cli.ts spawn document --scenario edit --config '{\n  \"content\": \"# My Blog Post\\n\\nThis is the **introduction** to my post.\\n\\n## Section One\\n\\n- Point one\\n- Point two\",\n  \"title\": \"Blog Post Draft\",\n  \"diffs\": [\n    {\"startOffset\": 50, \"endOffset\": 62, \"type\": \"add\"}\n  ]\n}'\n```\n\n### `email-preview`\nSpecialized view for email content display.\n\n```bash\nbun run src/cli.ts show document --scenario email-preview --config '{\n  \"content\": \"Dear Team,\\n\\nPlease review the attached document.\\n\\nBest regards,\\nAlice\",\n  \"title\": \"RE: Project Update\"\n}'\n```\n\n## Configuration\n\n```typescript\ninterface DocumentConfig {\n  content: string;        // Markdown content\n  title?: string;         // Document title (shown in header)\n  diffs?: DocumentDiff[]; // Optional diff markers for highlighting\n  readOnly?: boolean;     // Disable selection (default: false for edit)\n}\n\ninterface DocumentDiff {\n  startOffset: number;    // Character offset in content\n  endOffset: number;\n  type: \"add\" | \"delete\";\n}\n```\n\n## Markdown Rendering\n\nSupported markdown features:\n- **Headers** (`# H1`, `## H2`, etc.)\n- **Bold** (`**text**`)\n- **Italic** (`*text*`)\n- **Code** (`` `inline` `` and fenced blocks)\n- **Links** (`[text](url)`)\n- **Lists** (`-` or `*` bullets)\n- **Blockquotes** (`>`)\n\n## Selection Result\n\n```typescript\ninterface DocumentSelection {\n  selectedText: string;   // The selected text\n  startOffset: number;    // Start character offset\n  endOffset: number;      // End character offset\n  startLine: number;      // Line number (1-based)\n  endLine: number;\n  startColumn: number;    // Column in start line\n  endColumn: number;\n}\n```\n\n## Controls\n\n- **Mouse click and drag**: Select text (edit scenario)\n- `↑/↓` or scroll: Navigate document\n- `q` or `Esc`: Close/cancel\n\n## API Usage\n\n```typescript\nimport { editDocument, displayDocument } from \"${CLAUDE_PLUGIN_ROOT}/src/api\";\n\n// Display read-only document\nawait displayDocument({\n  content: \"# My Document\\n\\nContent here.\",\n  title: \"View Mode\",\n});\n\n// Interactive editing with selection\nconst result = await editDocument({\n  content: \"# My Document\\n\\nSelect some **text** here.\",\n  title: \"Edit Mode\",\n  diffs: [{ startOffset: 20, endOffset: 30, type: \"add\" }],\n});\n\nif (result.success && result.data) {\n  console.log(`Selected: \"${result.data.selectedText}\"`);\n  console.log(`Position: ${result.data.startOffset}-${result.data.endOffset}`);\n}\n```\n",
        "canvas/skills/flight/SKILL.md": "---\nname: flight\ndescription: |\n  Flight canvas for comparing flights and selecting seats.\n  Use when users need to browse flight options and book seats.\n---\n\n# Flight Canvas\n\nCyberpunk-themed flight comparison and seat selection interface.\n\n## Example Prompts\n\nTry asking Claude:\n\n- \"Find flights from San Francisco to Denver on January 15th\"\n- \"Book me a window seat on the cheapest nonstop to NYC\"\n- \"Compare morning flights from LAX to Seattle next Monday\"\n- \"I need a business class seat to Chicago with extra legroom\"\n- \"Show me United flights to Boston under $300\"\n\n## Scenarios\n\n### `booking` (default)\nInteractive flight comparison and seat selection.\n\n- Shows flight options with airline, times, duration, and price\n- Interactive seat map for seat selection\n- Keyboard navigation between flights and seats\n- Returns selected flight and seat via IPC\n\n```bash\nbun run src/cli.ts spawn flight --scenario booking --config '{\n  \"title\": \"// FLIGHT_BOOKING_TERMINAL //\",\n  \"flights\": [\n    {\n      \"id\": \"ua123\",\n      \"airline\": \"United Airlines\",\n      \"flightNumber\": \"UA 123\",\n      \"origin\": {\n        \"code\": \"SFO\",\n        \"name\": \"San Francisco International\",\n        \"city\": \"San Francisco\",\n        \"timezone\": \"PST\"\n      },\n      \"destination\": {\n        \"code\": \"DEN\",\n        \"name\": \"Denver International\",\n        \"city\": \"Denver\",\n        \"timezone\": \"MST\"\n      },\n      \"departureTime\": \"2026-01-08T12:55:00-08:00\",\n      \"arrivalTime\": \"2026-01-08T16:37:00-07:00\",\n      \"duration\": 162,\n      \"price\": 34500,\n      \"currency\": \"USD\",\n      \"cabinClass\": \"economy\",\n      \"aircraft\": \"Boeing 737-800\",\n      \"stops\": 0,\n      \"seatmap\": {\n        \"rows\": 30,\n        \"seatsPerRow\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\n        \"aisleAfter\": [\"C\"],\n        \"unavailable\": [\"1A\", \"1B\", \"1C\", \"1D\", \"1E\", \"1F\"],\n        \"premium\": [\"2A\", \"2B\", \"2C\", \"2D\", \"2E\", \"2F\"],\n        \"occupied\": [\"3A\", \"3C\", \"4B\", \"5D\"]\n      }\n    }\n  ]\n}'\n```\n\n## Configuration\n\n```typescript\ninterface FlightConfig {\n  flights: Flight[];\n  title?: string;           // Header title\n  showSeatmap?: boolean;    // Enable seat selection\n  selectedFlightId?: string; // Pre-select a flight\n}\n\ninterface Flight {\n  id: string;\n  airline: string;          // e.g., \"United Airlines\"\n  flightNumber: string;     // e.g., \"UA 123\"\n  origin: Airport;\n  destination: Airport;\n  departureTime: string;    // ISO datetime\n  arrivalTime: string;      // ISO datetime\n  duration: number;         // Minutes\n  price: number;            // Cents\n  currency: string;         // e.g., \"USD\"\n  cabinClass: \"economy\" | \"premium\" | \"business\" | \"first\";\n  aircraft?: string;        // e.g., \"Boeing 737-800\"\n  stops: number;            // 0 = nonstop\n  seatmap?: Seatmap;        // Optional seat selection\n}\n\ninterface Airport {\n  code: string;             // 3-letter code\n  name: string;             // Full airport name\n  city: string;\n  timezone: string;\n}\n\ninterface Seatmap {\n  rows: number;\n  seatsPerRow: string[];    // e.g., [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n  aisleAfter: string[];     // e.g., [\"C\"] = aisle after seat C\n  unavailable: string[];    // Blocked seats\n  premium: string[];        // Extra legroom/exit row\n  occupied: string[];       // Already booked\n}\n```\n\n## Controls\n\n- `↑/↓`: Navigate between flights\n- `Tab`: Switch focus between flight list and seatmap\n- `←/→/↑/↓` (in seatmap): Move seat cursor\n- `Space`: Select/deselect seat\n- `Enter`: Confirm selection\n- `Shift+Enter`: Confirm immediately (skip countdown)\n- `q` or `Esc`: Cancel\n\n## Selection Result\n\n```typescript\ninterface FlightResult {\n  selectedFlight: Flight;\n  selectedSeat?: string;    // e.g., \"12A\"\n}\n```\n\n## Seat Legend\n\n- `[ ]` - Available seat\n- `[X]` - Occupied seat\n- `[/]` - Unavailable/blocked\n- `[+]` - Premium seat (extra legroom)\n- `[*]` - Currently selected\n\n## API Usage\n\n```typescript\nimport { bookFlight } from \"${CLAUDE_PLUGIN_ROOT}/src/api\";\n\nconst result = await bookFlight({\n  flights: [\n    {\n      id: \"ua123\",\n      airline: \"United Airlines\",\n      flightNumber: \"UA 123\",\n      origin: { code: \"SFO\", name: \"San Francisco\", city: \"SF\", timezone: \"PST\" },\n      destination: { code: \"DEN\", name: \"Denver\", city: \"Denver\", timezone: \"MST\" },\n      departureTime: \"2026-01-08T12:55:00-08:00\",\n      arrivalTime: \"2026-01-08T16:37:00-07:00\",\n      duration: 162,\n      price: 34500,\n      currency: \"USD\",\n      cabinClass: \"economy\",\n      stops: 0,\n      seatmap: { ... }\n    }\n  ]\n});\n\nif (result.success && result.data) {\n  console.log(`Booked: ${result.data.selectedFlight.flightNumber}`);\n  console.log(`Seat: ${result.data.selectedSeat}`);\n}\n```\n",
        "canvas/src/canvases/calendar/hooks/index.ts": "// Calendar hooks exports\nexport * from \"./use-mouse\";\nexport * from \"./use-ipc\";\n",
        "canvas/src/canvases/calendar/hooks/use-ipc-server.ts": "// IPC hook for canvas running as server (standalone CLI mode)\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport { useApp } from \"ink\";\nimport { createIPCServer, type IPCServer } from \"../../../ipc/server\";\nimport type { CanvasMessage, ControllerMessage } from \"../../../ipc/types\";\n\nexport interface UseIPCServerOptions {\n  socketPath: string | undefined;\n  scenario: string;\n  onClose?: () => void;\n  onUpdate?: (config: unknown) => void;\n  onGetSelection?: () => { selectedText: string; startOffset: number; endOffset: number } | null;\n  onGetContent?: () => { content: string; cursorPosition: number };\n}\n\nexport interface IPCServerHandle {\n  isConnected: boolean;\n  sendReady: () => void;\n  sendSelected: (data: unknown) => void;\n  sendCancelled: (reason?: string) => void;\n  sendError: (message: string) => void;\n}\n\nexport function useIPCServer(options: UseIPCServerOptions): IPCServerHandle {\n  const { socketPath, scenario, onClose, onUpdate, onGetSelection, onGetContent } = options;\n  const { exit } = useApp();\n  const [isConnected, setIsConnected] = useState(false);\n  const serverRef = useRef<IPCServer | null>(null);\n  const onCloseRef = useRef(onClose);\n  const onUpdateRef = useRef(onUpdate);\n  const onGetSelectionRef = useRef(onGetSelection);\n  const onGetContentRef = useRef(onGetContent);\n\n  useEffect(() => {\n    onCloseRef.current = onClose;\n    onUpdateRef.current = onUpdate;\n    onGetSelectionRef.current = onGetSelection;\n    onGetContentRef.current = onGetContent;\n  }, [onClose, onUpdate, onGetSelection, onGetContent]);\n\n  // Start server on mount\n  useEffect(() => {\n    if (!socketPath) return;\n\n    let mounted = true;\n\n    const startServer = async () => {\n      try {\n        const server = await createIPCServer({\n          socketPath,\n          onMessage: (msg: ControllerMessage) => {\n            switch (msg.type) {\n              case \"close\":\n                onCloseRef.current?.();\n                exit();\n                break;\n              case \"update\":\n                onUpdateRef.current?.(msg.config);\n                break;\n              case \"ping\":\n                server.broadcast({ type: \"pong\" });\n                break;\n              case \"getSelection\":\n                const selection = onGetSelectionRef.current?.() || null;\n                server.broadcast({ type: \"selection\", data: selection });\n                break;\n              case \"getContent\":\n                const contentData = onGetContentRef.current?.();\n                if (contentData) {\n                  server.broadcast({ type: \"content\", data: contentData });\n                }\n                break;\n            }\n          },\n          onClientConnect: () => {\n            if (mounted) {\n              setIsConnected(true);\n            }\n          },\n          onClientDisconnect: () => {\n            if (mounted) {\n              setIsConnected(false);\n            }\n          },\n          onError: (err) => {\n            console.error(\"IPC error:\", err);\n          },\n        });\n\n        if (mounted) {\n          serverRef.current = server;\n        } else {\n          server.close();\n        }\n      } catch (err) {\n        console.error(\"Failed to start IPC server:\", err);\n      }\n    };\n\n    startServer();\n\n    return () => {\n      mounted = false;\n      serverRef.current?.close();\n      serverRef.current = null;\n    };\n  }, [socketPath, scenario, exit]);\n\n  const sendReady = useCallback(() => {\n    serverRef.current?.broadcast({ type: \"ready\", scenario });\n  }, [scenario]);\n\n  const sendSelected = useCallback((data: unknown) => {\n    serverRef.current?.broadcast({ type: \"selected\", data });\n  }, []);\n\n  const sendCancelled = useCallback((reason?: string) => {\n    serverRef.current?.broadcast({ type: \"cancelled\", reason });\n  }, []);\n\n  const sendError = useCallback((message: string) => {\n    serverRef.current?.broadcast({ type: \"error\", message });\n  }, []);\n\n  return {\n    isConnected,\n    sendReady,\n    sendSelected,\n    sendCancelled,\n    sendError,\n  };\n}\n",
        "canvas/src/canvases/calendar/hooks/use-ipc.ts": "// IPC hook for canvas-side communication with controller\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport { useApp } from \"ink\";\nimport { connectWithRetry, type IPCClient } from \"../../../ipc/client\";\nimport type { CanvasMessage, ControllerMessage } from \"../../../ipc/types\";\n\nexport interface UseIPCOptions {\n  socketPath: string | undefined;\n  scenario: string;\n  onClose?: () => void;\n  onUpdate?: (config: unknown) => void;\n}\n\nexport interface IPCHandle {\n  isConnected: boolean;\n  sendReady: () => void;\n  sendSelected: (data: unknown) => void;\n  sendCancelled: (reason?: string) => void;\n  sendError: (message: string) => void;\n}\n\nexport function useIPC(options: UseIPCOptions): IPCHandle {\n  const { socketPath, scenario, onClose, onUpdate } = options;\n  const { exit } = useApp();\n  const [isConnected, setIsConnected] = useState(false);\n  const clientRef = useRef<IPCClient | null>(null);\n  const onCloseRef = useRef(onClose);\n  const onUpdateRef = useRef(onUpdate);\n\n  useEffect(() => {\n    onCloseRef.current = onClose;\n    onUpdateRef.current = onUpdate;\n  }, [onClose, onUpdate]);\n\n  // Connect to controller on mount\n  useEffect(() => {\n    if (!socketPath) return;\n\n    let mounted = true;\n\n    const connect = async () => {\n      try {\n        const client = await connectWithRetry({\n          socketPath,\n          onMessage: (msg: ControllerMessage) => {\n            switch (msg.type) {\n              case \"close\":\n                onCloseRef.current?.();\n                exit();\n                break;\n              case \"update\":\n                onUpdateRef.current?.(msg.config);\n                break;\n              case \"ping\":\n                client.send({ type: \"pong\" });\n                break;\n            }\n          },\n          onDisconnect: () => {\n            if (mounted) {\n              setIsConnected(false);\n            }\n          },\n          onError: (err) => {\n            console.error(\"IPC error:\", err);\n          },\n        });\n\n        if (mounted) {\n          clientRef.current = client;\n          setIsConnected(true);\n          // Send ready message automatically\n          client.send({ type: \"ready\", scenario });\n        } else {\n          client.close();\n        }\n      } catch (err) {\n        console.error(\"Failed to connect to controller:\", err);\n      }\n    };\n\n    connect();\n\n    return () => {\n      mounted = false;\n      clientRef.current?.close();\n      clientRef.current = null;\n    };\n  }, [socketPath, scenario, exit]);\n\n  const sendReady = useCallback(() => {\n    clientRef.current?.send({ type: \"ready\", scenario });\n  }, [scenario]);\n\n  const sendSelected = useCallback((data: unknown) => {\n    clientRef.current?.send({ type: \"selected\", data });\n  }, []);\n\n  const sendCancelled = useCallback((reason?: string) => {\n    clientRef.current?.send({ type: \"cancelled\", reason });\n  }, []);\n\n  const sendError = useCallback((message: string) => {\n    clientRef.current?.send({ type: \"error\", message });\n  }, []);\n\n  return {\n    isConnected,\n    sendReady,\n    sendSelected,\n    sendCancelled,\n    sendError,\n  };\n}\n",
        "canvas/src/canvases/calendar/hooks/use-mouse.ts": "// Mouse tracking hook for Ink components\n// Uses SGR extended mouse mode for accurate position tracking\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport { useStdin } from \"ink\";\n\n// SGR extended mouse mode escape sequences\nconst MOUSE_ENABLE = \"\\x1b[?1003h\\x1b[?1006h\"; // Track all movements + SGR format\nconst MOUSE_DISABLE = \"\\x1b[?1003l\\x1b[?1006l\";\n\nexport interface MousePosition {\n  x: number; // 1-based column\n  y: number; // 1-based row\n}\n\nexport interface MouseEvent {\n  x: number;\n  y: number;\n  button: number; // 0=left, 1=middle, 2=right\n  pressed: boolean; // true on press, false on release\n  isMotion: boolean; // true if this is a motion event (mouse move)\n  modifiers: {\n    shift: boolean;\n    meta: boolean;\n    ctrl: boolean;\n  };\n}\n\nexport interface MouseState {\n  position: MousePosition | null;\n  isPressed: boolean;\n  lastClick: MousePosition | null;\n}\n\nexport interface UseMouseOptions {\n  enabled?: boolean;\n  onClick?: (event: MouseEvent) => void;\n  onMove?: (event: MouseEvent) => void;\n  onRelease?: (event: MouseEvent) => void;\n}\n\n// Parse SGR mouse sequence: ESC[<btn;x;y(M|m)\n// M = press, m = release\nfunction parseMouseEvent(data: string): MouseEvent | null {\n  // SGR format: \\x1b[<btn;x;yM or \\x1b[<btn;x;ym\n  const match = data.match(/\\x1b\\[<(\\d+);(\\d+);(\\d+)([Mm])/);\n  if (!match) return null;\n\n  const [, btnStr, xStr, yStr, action] = match;\n  const btn = parseInt(btnStr, 10);\n  const x = parseInt(xStr, 10);\n  const y = parseInt(yStr, 10);\n  const pressed = action === \"M\";\n\n  // Decode button and modifiers from btn byte\n  // Bits 0-1: button (0=left, 1=middle, 2=right, 3=release/no button)\n  // Bit 2: shift\n  // Bit 3: meta\n  // Bit 4: ctrl\n  // Bit 5: motion event (32)\n  // Bit 6: scroll wheel (64)\n  const button = btn & 3;\n  const shift = (btn & 4) !== 0;\n  const meta = (btn & 8) !== 0;\n  const ctrl = (btn & 16) !== 0;\n  const isMotion = (btn & 32) !== 0;\n\n  return {\n    x,\n    y,\n    button: button === 3 ? 0 : button, // button 3 means no button held\n    pressed,\n    isMotion,\n    modifiers: { shift, meta, ctrl },\n  };\n}\n\nexport function useMouse(options: UseMouseOptions = {}): MouseState {\n  const { enabled = true, onClick, onMove, onRelease } = options;\n  const { stdin, setRawMode } = useStdin();\n  const [state, setState] = useState<MouseState>({\n    position: null,\n    isPressed: false,\n    lastClick: null,\n  });\n\n  // Use refs for callbacks to avoid re-registering handlers\n  const onClickRef = useRef(onClick);\n  const onMoveRef = useRef(onMove);\n  const onReleaseRef = useRef(onRelease);\n\n  useEffect(() => {\n    onClickRef.current = onClick;\n    onMoveRef.current = onMove;\n    onReleaseRef.current = onRelease;\n  }, [onClick, onMove, onRelease]);\n\n  useEffect(() => {\n    if (!enabled || !stdin) return;\n\n    // Enable mouse tracking\n    process.stdout.write(MOUSE_ENABLE);\n    setRawMode(true);\n\n    let buffer = \"\";\n\n    const handleData = (data: Buffer) => {\n      buffer += data.toString();\n\n      // Try to parse mouse events from buffer\n      let match;\n      while ((match = buffer.match(/\\x1b\\[<\\d+;\\d+;\\d+[Mm]/))) {\n        const event = parseMouseEvent(match[0]);\n        if (event) {\n          setState((prev) => {\n            const newState = {\n              position: { x: event.x, y: event.y },\n              // Only update isPressed for non-motion events\n              isPressed: event.isMotion ? prev.isPressed : event.pressed,\n              // Only update lastClick for actual clicks (not motion)\n              lastClick: (!event.isMotion && event.pressed)\n                ? { x: event.x, y: event.y }\n                : prev.lastClick,\n            };\n            return newState;\n          });\n\n          // Call appropriate callback based on event type\n          if (event.isMotion) {\n            // Motion event (mouse move)\n            onMoveRef.current?.(event);\n          } else if (event.pressed) {\n            // Button press (actual click)\n            onClickRef.current?.(event);\n          } else {\n            // Button release\n            onReleaseRef.current?.(event);\n          }\n        }\n\n        // Remove processed event from buffer\n        buffer = buffer.slice(match.index! + match[0].length);\n      }\n\n      // Keep buffer from growing too large (in case of junk data)\n      if (buffer.length > 100) {\n        buffer = buffer.slice(-50);\n      }\n    };\n\n    stdin.on(\"data\", handleData);\n\n    return () => {\n      stdin.off(\"data\", handleData);\n      process.stdout.write(MOUSE_DISABLE);\n    };\n  }, [enabled, stdin, setRawMode]);\n\n  return state;\n}\n\n// Hook to track mouse position relative to a grid\nexport interface GridPosition {\n  col: number; // 0-based column index\n  row: number; // 0-based row index\n}\n\nexport interface UseGridMouseOptions {\n  enabled?: boolean;\n  gridLeft: number; // Grid left edge (1-based terminal column)\n  gridTop: number; // Grid top edge (1-based terminal row)\n  cellWidth: number; // Width of each cell in characters\n  cellHeight: number; // Height of each cell in rows\n  cols: number; // Number of columns\n  rows: number; // Number of rows\n  onClick?: (position: GridPosition) => void;\n}\n\nexport function useGridMouse(options: UseGridMouseOptions): {\n  hoveredCell: GridPosition | null;\n  clickedCell: GridPosition | null;\n} {\n  const {\n    enabled = true,\n    gridLeft,\n    gridTop,\n    cellWidth,\n    cellHeight,\n    cols,\n    rows,\n    onClick,\n  } = options;\n\n  const [hoveredCell, setHoveredCell] = useState<GridPosition | null>(null);\n  const [clickedCell, setClickedCell] = useState<GridPosition | null>(null);\n\n  const terminalToGrid = useCallback(\n    (x: number, y: number): GridPosition | null => {\n      const relX = x - gridLeft;\n      const relY = y - gridTop;\n\n      if (relX < 0 || relY < 0) return null;\n\n      const col = Math.floor(relX / cellWidth);\n      const row = Math.floor(relY / cellHeight);\n\n      if (col >= cols || row >= rows) return null;\n\n      return { col, row };\n    },\n    [gridLeft, gridTop, cellWidth, cellHeight, cols, rows]\n  );\n\n  const handleClick = useCallback(\n    (event: MouseEvent) => {\n      const gridPos = terminalToGrid(event.x, event.y);\n      if (gridPos) {\n        setClickedCell(gridPos);\n        onClick?.(gridPos);\n      }\n    },\n    [terminalToGrid, onClick]\n  );\n\n  const handleMove = useCallback(\n    (event: MouseEvent) => {\n      const gridPos = terminalToGrid(event.x, event.y);\n      setHoveredCell(gridPos);\n    },\n    [terminalToGrid]\n  );\n\n  useMouse({\n    enabled,\n    onClick: handleClick,\n    onMove: handleMove,\n  });\n\n  return { hoveredCell, clickedCell };\n}\n",
        "canvas/src/canvases/document/hooks/index.ts": "// Document canvas hooks\nexport { useTextSelection, terminalToOffset, offsetToLineCol } from \"./use-text-selection\";\nexport type { UseTextSelectionOptions, UseTextSelectionResult } from \"./use-text-selection\";\n",
        "canvas/src/canvases/document/hooks/use-text-selection.ts": "// Text Selection Hook - Click and drag text selection with offset tracking\n\nimport { useState, useCallback, useRef, useEffect } from \"react\";\nimport { useMouse, type MouseEvent } from \"../../calendar/hooks/use-mouse\";\nimport type { PositionMapping, SelectionState, DocumentSelection } from \"../types\";\n\nexport interface UseTextSelectionOptions {\n  enabled: boolean;\n  positionMap: PositionMapping[];\n  content: string;\n  scrollOffset?: number;\n  startRow?: number; // Row where content starts (for header offset)\n  startCol?: number; // Column where content starts (for centering/border offset)\n  onSelectionChange?: (selection: DocumentSelection | null) => void;\n}\n\nexport interface UseTextSelectionResult {\n  selection: SelectionState;\n  selectionData: DocumentSelection | null;\n}\n\n// Find source offset from terminal position\nfunction terminalToOffset(\n  x: number,\n  y: number,\n  positionMap: PositionMapping[]\n): number | null {\n  // Try exact match first\n  const exact = positionMap.find(\n    (p) => p.terminalRow === y && p.terminalCol === x\n  );\n  if (exact) return exact.sourceOffset;\n\n  // Find closest on same row\n  const rowEntries = positionMap.filter((p) => p.terminalRow === y);\n  if (rowEntries.length === 0) {\n    // Try closest row\n    const rows = [...new Set(positionMap.map((p) => p.terminalRow))].sort(\n      (a, b) => a - b\n    );\n    const closestRow = rows.reduce((prev, curr) =>\n      Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev\n    );\n    const closestRowEntries = positionMap.filter(\n      (p) => p.terminalRow === closestRow\n    );\n    if (closestRowEntries.length === 0) return null;\n\n    // Get start or end of that row depending on whether we're above or below\n    if (y < closestRow) {\n      return Math.min(...closestRowEntries.map((p) => p.sourceOffset));\n    } else {\n      return Math.max(...closestRowEntries.map((p) => p.sourceOffset));\n    }\n  }\n\n  // Find closest column on this row\n  const closest = rowEntries.reduce((prev, curr) =>\n    Math.abs(curr.terminalCol - x) < Math.abs(prev.terminalCol - x)\n      ? curr\n      : prev\n  );\n  return closest.sourceOffset;\n}\n\n// Calculate line and column from offset\nfunction offsetToLineCol(\n  offset: number,\n  content: string\n): { line: number; column: number } {\n  let line = 1;\n  let column = 1;\n  for (let i = 0; i < offset && i < content.length; i++) {\n    if (content[i] === \"\\n\") {\n      line++;\n      column = 1;\n    } else {\n      column++;\n    }\n  }\n  return { line, column };\n}\n\nexport function useTextSelection(\n  options: UseTextSelectionOptions\n): UseTextSelectionResult {\n  const { enabled, positionMap, content, scrollOffset = 0, startRow = 0, startCol = 0, onSelectionChange } = options;\n\n  const [selection, setSelection] = useState<SelectionState>({\n    isSelecting: false,\n    anchorOffset: null,\n    focusOffset: null,\n    startOffset: null,\n    endOffset: null,\n  });\n\n  // Track if mouse button is held down\n  const mouseDownRef = useRef(false);\n\n  // Build selection data from state\n  const getSelectionData = useCallback(\n    (state: SelectionState): DocumentSelection | null => {\n      if (state.startOffset === null || state.endOffset === null) return null;\n      if (state.startOffset === state.endOffset) return null;\n\n      const start = state.startOffset;\n      const end = state.endOffset;\n      const selectedText = content.slice(start, end);\n\n      const startPos = offsetToLineCol(start, content);\n      const endPos = offsetToLineCol(end, content);\n\n      return {\n        selectedText,\n        startOffset: start,\n        endOffset: end,\n        startLine: startPos.line,\n        endLine: endPos.line,\n        startColumn: startPos.column,\n        endColumn: endPos.column,\n      };\n    },\n    [content]\n  );\n\n  // Current selection data\n  const selectionData = getSelectionData(selection);\n\n  // Ref for callback to avoid stale closures\n  const onSelectionChangeRef = useRef(onSelectionChange);\n  useEffect(() => {\n    onSelectionChangeRef.current = onSelectionChange;\n  }, [onSelectionChange]);\n\n  // Handle mouse down - start selection\n  const handleClick = useCallback(\n    (event: MouseEvent) => {\n      if (!enabled) return;\n\n      // Adjust coordinates for content offset\n      // x: subtract startCol (centering + border + padding)\n      // y: add scrollOffset (scrolled lines)\n      const adjustedX = event.x - startCol;\n      const adjustedY = event.y + scrollOffset;\n      const offset = terminalToOffset(adjustedX, adjustedY, positionMap);\n      if (offset === null) return;\n\n      mouseDownRef.current = true;\n\n      setSelection({\n        isSelecting: true,\n        anchorOffset: offset,\n        focusOffset: offset,\n        startOffset: offset,\n        endOffset: offset,\n      });\n    },\n    [enabled, positionMap, scrollOffset, startCol]\n  );\n\n  // Handle mouse move - extend selection\n  const handleMove = useCallback(\n    (event: MouseEvent) => {\n      if (!enabled || !mouseDownRef.current) return;\n\n      // Adjust coordinates for content offset\n      const adjustedX = event.x - startCol;\n      const adjustedY = event.y + scrollOffset;\n      const offset = terminalToOffset(adjustedX, adjustedY, positionMap);\n      if (offset === null) return;\n\n      setSelection((prev) => {\n        if (prev.anchorOffset === null) return prev;\n\n        const start = Math.min(prev.anchorOffset, offset);\n        const end = Math.max(prev.anchorOffset, offset);\n\n        const newState = {\n          ...prev,\n          isSelecting: true,\n          focusOffset: offset,\n          startOffset: start,\n          endOffset: end,\n        };\n\n        // Notify on change\n        const data = getSelectionData(newState);\n        onSelectionChangeRef.current?.(data);\n\n        return newState;\n      });\n    },\n    [enabled, positionMap, scrollOffset, getSelectionData]\n  );\n\n  // Handle mouse up - finalize selection\n  const handleRelease = useCallback(\n    (event: MouseEvent) => {\n      if (!enabled) return;\n\n      mouseDownRef.current = false;\n\n      setSelection((prev) => {\n        const newState = {\n          ...prev,\n          isSelecting: false,\n        };\n\n        // Send final selection\n        const data = getSelectionData(newState);\n        if (data && data.startOffset !== data.endOffset) {\n          onSelectionChangeRef.current?.(data);\n        }\n\n        return newState;\n      });\n    },\n    [enabled, getSelectionData]\n  );\n\n  // Use mouse hook\n  useMouse({\n    enabled,\n    onClick: handleClick,\n    onMove: handleMove,\n    onRelease: handleRelease,\n  });\n\n  return { selection, selectionData };\n}\n\nexport { terminalToOffset, offsetToLineCol };\n"
      },
      "plugins": [
        {
          "name": "canvas",
          "source": "./canvas",
          "description": "Spawn and control interactive terminal displays (calendars, documents, flights) with real-time IPC communication",
          "version": "0.1.0",
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add dvdsgl/claude-canvas",
            "/plugin install canvas@claude-canvas"
          ]
        }
      ]
    }
  ]
}