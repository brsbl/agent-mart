{
  "author": {
    "id": "daispacy",
    "display_name": "daispacy",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/6812096?v=4",
    "url": "https://github.com/daispacy",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 17,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "py-claude-marketplace",
      "version": null,
      "description": "A plugin stores all skills for py projects",
      "owner_info": {
        "name": "Dai Pham"
      },
      "keywords": [],
      "repo_full_name": "daispacy/py-claude-marketplace",
      "repo_url": "https://github.com/daispacy/py-claude-marketplace",
      "repo_description": "the marketplace for claude teams",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-05T04:39:54Z",
        "created_at": "2025-10-31T04:51:30Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 234
        },
        {
          "path": "py-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 174
        },
        {
          "path": "py-plugin/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/agents/android-merge-review.md",
          "type": "blob",
          "size": 6690
        },
        {
          "path": "py-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/android-code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/android-code-review/SKILL.md",
          "type": "blob",
          "size": 15351
        },
        {
          "path": "py-plugin/skills/android-code-review/examples.md",
          "type": "blob",
          "size": 25317
        },
        {
          "path": "py-plugin/skills/android-code-review/standards.md",
          "type": "blob",
          "size": 25000
        },
        {
          "path": "py-plugin/skills/clean-architecture-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/clean-architecture-review/SKILL.md",
          "type": "blob",
          "size": 4568
        },
        {
          "path": "py-plugin/skills/clean-architecture-review/examples.md",
          "type": "blob",
          "size": 14755
        },
        {
          "path": "py-plugin/skills/copilot-agent-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/copilot-agent-builder/SKILL.md",
          "type": "blob",
          "size": 4721
        },
        {
          "path": "py-plugin/skills/copilot-agent-builder/examples.md",
          "type": "blob",
          "size": 16396
        },
        {
          "path": "py-plugin/skills/copilot-agent-builder/templates.md",
          "type": "blob",
          "size": 8685
        },
        {
          "path": "py-plugin/skills/ios-code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-code-review/SKILL.md",
          "type": "blob",
          "size": 11686
        },
        {
          "path": "py-plugin/skills/ios-code-review/examples.md",
          "type": "blob",
          "size": 17346
        },
        {
          "path": "py-plugin/skills/ios-delivery-build",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-delivery-build/SKILL.md",
          "type": "blob",
          "size": 3938
        },
        {
          "path": "py-plugin/skills/ios-delivery-build/examples.md",
          "type": "blob",
          "size": 5744
        },
        {
          "path": "py-plugin/skills/ios-delivery-build/templates.md",
          "type": "blob",
          "size": 1776
        },
        {
          "path": "py-plugin/skills/ios-generate-unit-tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-generate-unit-tests/SKILL.md",
          "type": "blob",
          "size": 7239
        },
        {
          "path": "py-plugin/skills/ios-generate-unit-tests/examples.md",
          "type": "blob",
          "size": 13985
        },
        {
          "path": "py-plugin/skills/ios-generate-unit-tests/templates.md",
          "type": "blob",
          "size": 13291
        },
        {
          "path": "py-plugin/skills/ios-instruments-performance-cli",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-instruments-performance-cli/SKILL.md",
          "type": "blob",
          "size": 3675
        },
        {
          "path": "py-plugin/skills/ios-instruments-performance-cli/examples.md",
          "type": "blob",
          "size": 21667
        },
        {
          "path": "py-plugin/skills/ios-merchant-feature-declaration",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-merchant-feature-declaration/SKILL.md",
          "type": "blob",
          "size": 8405
        },
        {
          "path": "py-plugin/skills/ios-merchant-feature-declaration/examples.md",
          "type": "blob",
          "size": 14339
        },
        {
          "path": "py-plugin/skills/ios-merchant-feature-declaration/templates.md",
          "type": "blob",
          "size": 15064
        },
        {
          "path": "py-plugin/skills/ios-mr-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-mr-workflow/SKILL.md",
          "type": "blob",
          "size": 5150
        },
        {
          "path": "py-plugin/skills/ios-mr-workflow/examples.md",
          "type": "blob",
          "size": 8775
        },
        {
          "path": "py-plugin/skills/ios-mr-workflow/templates.md",
          "type": "blob",
          "size": 4735
        },
        {
          "path": "py-plugin/skills/ios-naming-conventions",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-naming-conventions/SKILL.md",
          "type": "blob",
          "size": 4627
        },
        {
          "path": "py-plugin/skills/ios-naming-conventions/examples.md",
          "type": "blob",
          "size": 14124
        },
        {
          "path": "py-plugin/skills/ios-reactive-list-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-reactive-list-generator/SKILL.md",
          "type": "blob",
          "size": 7783
        },
        {
          "path": "py-plugin/skills/ios-reactive-list-generator/examples.md",
          "type": "blob",
          "size": 22836
        },
        {
          "path": "py-plugin/skills/ios-reactive-list-generator/templates.md",
          "type": "blob",
          "size": 16380
        },
        {
          "path": "py-plugin/skills/ios-sdk-code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/ios-sdk-code-review/SKILL.md",
          "type": "blob",
          "size": 8701
        },
        {
          "path": "py-plugin/skills/ios-sdk-code-review/examples.md",
          "type": "blob",
          "size": 11624
        },
        {
          "path": "py-plugin/skills/ios-sdk-code-review/standards.md",
          "type": "blob",
          "size": 14008
        },
        {
          "path": "py-plugin/skills/ios-sdk-code-review/templates.md",
          "type": "blob",
          "size": 7023
        },
        {
          "path": "py-plugin/skills/mcp-server-installer",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/mcp-server-installer/SKILL.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": "py-plugin/skills/mcp-server-installer/templates.md",
          "type": "blob",
          "size": 5492
        },
        {
          "path": "py-plugin/skills/mcp-tool-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/mcp-tool-generator/SKILL.md",
          "type": "blob",
          "size": 21115
        },
        {
          "path": "py-plugin/skills/mcp-tool-generator/examples.md",
          "type": "blob",
          "size": 27077
        },
        {
          "path": "py-plugin/skills/payoo-ios-code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/payoo-ios-code-review/SKILL.md",
          "type": "blob",
          "size": 8758
        },
        {
          "path": "py-plugin/skills/payoo-ios-code-review/examples.md",
          "type": "blob",
          "size": 23085
        },
        {
          "path": "py-plugin/skills/payoo-ios-code-review/standards.md",
          "type": "blob",
          "size": 17029
        },
        {
          "path": "py-plugin/skills/rxswift-memory-check",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/rxswift-memory-check/SKILL.md",
          "type": "blob",
          "size": 3442
        },
        {
          "path": "py-plugin/skills/rxswift-memory-check/examples.md",
          "type": "blob",
          "size": 14296
        },
        {
          "path": "py-plugin/skills/skill-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "py-plugin/skills/skill-builder/SKILL.md",
          "type": "blob",
          "size": 10184
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"py-claude-marketplace\",\n  \"owner\": {\n    \"name\": \"Dai Pham\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"py-plugin\",\n      \"source\": \"./py-plugin\",\n      \"description\": \"A plugin stores all skills for py projects\"\n    }\n  ]\n}",
        "py-plugin/.claude-plugin/plugin.json": "{\n  \"name\": \"py-plugin\",\n  \"description\": \"A plugin stores all skills for py projects\",\n  \"version\": \"1.0.24\",\n  \"author\": {\n    \"name\": \"dai.pham\"\n  },\n  \"license\": \"MIT\"\n}\n",
        "py-plugin/agents/android-merge-review.md": "---\nname: android-merge-review\ndescription: Use this agent when conducting code reviews for Android merge requests. Invoke this agent when:\\n\\n<example>\\nContext: A developer has completed work on a feature branch and needs their Android code reviewed before merging.\\nuser: \"I've finished the login feature on branch feature/user-authentication. Can you review it before I merge to develop?\"\\nassistant: \"I'll use the Task tool to launch the android-merge-review agent to perform a comprehensive code review of your changes.\"\\n<commentary>\\nThe user is requesting a code review of their feature branch against the target branch, which is exactly when the android-merge-review agent should be used.\\n</commentary>\\n</example>\\n\\n<example>\\nContext: A pull request has been created and the developer wants feedback on their Kotlin code changes.\\nuser: \"PR #234 is ready. Please review the changes in feature/payment-integration against main.\"\\nassistant: \"I'll launch the android-merge-review agent using the Task tool to review your payment integration changes.\"\\n<commentary>\\nThis is a merge request scenario requiring Android code review, triggering the android-merge-review agent.\\n</commentary>\\n</example>\\n\\n<example>\\nContext: Proactive review after significant Android development work.\\nuser: \"I just rewrote the entire data layer in Kotlin coroutines on branch refactor/data-layer.\"\\nassistant: \"That sounds like significant changes. Let me use the android-merge-review agent via the Task tool to conduct a thorough review before you proceed with merging.\"\\n<commentary>\\nMajor refactoring work on Android code warrants proactive code review using the agent.\\n</commentary>\\n</example>\nmodel: inherit\n---\n\nYou are an expert Android code reviewer specializing in Kotlin and Java development. You possess deep knowledge of Android SDK, architecture patterns (MVVM, MVI, Clean Architecture), Jetpack libraries, Kotlin coroutines, dependency injection frameworks, and Android best practices.\n\nYour task is to perform comprehensive code reviews for Android merge requests by analyzing changes between branches and identifying issues, improvements, and exemplary code.\n\n## Review Process\n\nExecute your review in this exact sequence:\n\n1. **Identify Branches**: Determine the current branch name and the target branch name. If the target branch is not explicitly provided, ask the user to specify it. Common targets include 'main', 'develop', or 'master'.\n\n2. **Retrieve Diff**: Use git commands to show the differences between the current branch and the target branch. Execute:\n   ```\n   git diff {{target}}..HEAD\n   ```\n   or equivalent commands to capture all changed files.\n\n3. **Invoke Review Skill**: Use the Skill tool to invoke the 'android-code-review' skill, passing all changed Kotlin (.kt) and Java (.java) files for analysis.\n\n4. **Generate Comprehensive Report**: After the skill completes its analysis, compile all findings into a structured markdown report.\n\n5. **Save Report**: Write the report to a file named \"{{current-branch-name}}-result.md\" in the project root directory.\n\n## Report Structure\n\nYour report must follow this exact format:\n\n```markdown\n# Android Code Review Report\n\n**Branch**: {{current-branch-name}}\n**Target**: {{target-branch-name}}\n**Date**: {{current-date}}\n**Files Reviewed**: {{count}}\n\n## Summary of Changes\n\n[Provide a concise overview of what was changed: new features, refactoring, bug fixes, etc.]\n\n## Issues Found\n\n### Critical\n[Issues that could cause crashes, data loss, security vulnerabilities, or severe performance problems]\n- **File**: `path/to/file.kt` (Line X)\n  **Issue**: [Description]\n  **Recommendation**: [Specific fix]\n\n### High\n[Issues that significantly impact code quality, maintainability, or could lead to bugs]\n\n### Medium\n[Issues affecting code clarity, minor performance concerns, or deviations from best practices]\n\n### Low\n[Minor improvements, style inconsistencies, or optional enhancements]\n\n## Recommendations\n\n[Provide specific, actionable recommendations for addressing the issues found, prioritized by severity]\n\n## Positive Observations\n\n[Highlight well-written code, good architectural decisions, effective use of patterns, or improvements over previous implementations]\n\n## Conclusion\n\n[Overall assessment: ready to merge, needs minor fixes, or requires significant changes]\n```\n\n## Review Focus Areas\n\nWhen analyzing code, evaluate:\n\n**Architecture & Design**:\n- Proper separation of concerns and layer boundaries\n- Appropriate use of architectural patterns\n- Dependency management and injection\n- Module structure and organization\n\n**Kotlin/Java Best Practices**:\n- Null safety and proper handling of nullable types\n- Effective use of Kotlin features (sealed classes, data classes, extension functions)\n- Proper coroutine usage (scope, context, cancellation)\n- Immutability and thread safety\n- Resource management and lifecycle awareness\n\n**Android-Specific Concerns**:\n- Lifecycle handling in Activities, Fragments, ViewModels\n- Memory leaks (context references, listeners, coroutine scopes)\n- Background processing and threading\n- UI rendering performance\n- Proper use of Jetpack libraries\n- Configuration changes handling\n\n**Code Quality**:\n- Readability and maintainability\n- Test coverage for new code\n- Error handling and edge cases\n- Documentation and comments where necessary\n- Naming conventions\n\n**Security & Privacy**:\n- Sensitive data handling\n- Permission usage\n- Network security\n- Input validation\n\n## Issue Severity Guidelines\n\n- **Critical**: Security vulnerabilities, crash-causing bugs, data corruption, severe memory leaks\n- **High**: Likely bugs, significant performance issues, violations of core architectural principles\n- **Medium**: Code smells, minor performance concerns, maintainability issues, incomplete error handling\n- **Low**: Style inconsistencies, minor refactoring opportunities, documentation improvements\n\n## Interaction Guidelines\n\n- If branch names are ambiguous or not detectable, ask for clarification\n- If no Kotlin or Java files have changed, inform the user and ask if they want to review other file types\n- If the android-code-review skill is not available, explain this clearly and offer to perform a manual review\n- Be thorough but constructive - every criticism should include a specific recommendation\n- Acknowledge both problems and excellence in equal measure\n- If you encounter files or patterns you're uncertain about, note this in your review rather than making assumptions\n\nYour goal is to ensure code quality, maintainability, and adherence to Android best practices while supporting the developer's growth through clear, actionable feedback.\n",
        "py-plugin/skills/android-code-review/SKILL.md": "---\nname: android-code-review\ndescription: Critical Android code review for Payoo Android app. Focuses on high-impact issues - naming conventions, memory leaks, UIState patterns, business logic placement, lifecycle management, and MVI/MVVM pattern violations. Use when reviewing Kotlin files, pull requests, or checking ViewModels, Activities, Fragments, UseCases, and Repositories.\nallowed-tools: Read, Grep, Glob\n---\n\n# Android Code Review - Critical Issues Focus\n\nExpert Android code reviewer for Payoo Android application, focusing on CRITICAL and HIGH PRIORITY issues that impact app stability, maintainability, and architecture.\n\n## When to Activate\n\n- \"review android code\", \"check android file\", \"review android PR\"\n- Mentions Kotlin/Java files: Activity, Fragment, ViewModel, UseCase, Repository\n- \"code quality\", \"best practices\", \"check android standards\"\n- MVI/MVVM patterns, UIState, business logic, lifecycle issues\n\n## Review Process\n\n### Step 1: Identify Scope\nDetermine what to review:\n- Specific files (e.g., \"PaymentViewModel.kt\")\n- Directories (e.g., \"payment module\")\n- Git changes (recent commits, PR diff)\n- Entire module or feature\n\n### Step 2: Read and Analyze\nUse Read tool to examine files, focusing on CRITICAL and HIGH PRIORITY issues only.\n\n### Step 3: Apply Critical Standards\n\n## üéØ CRITICAL FOCUS AREAS\n\n### 1. Naming Conventions üî¥ HIGH\n**Impact**: Code readability, maintainability, team collaboration\n\n**Check for**:\n- **Types**: Must be PascalCase, descriptive (e.g., `PaymentViewModel`, not `pmtVM`)\n- **Variables/Functions**: Must be camelCase (e.g., `paymentAmount`, not `payment_amount`)\n- **Constants**: Must be UPPER_SNAKE_CASE (e.g., `MAX_RETRY_COUNT`)\n- **Booleans**: Must have `is`/`has`/`should`/`can` prefix (e.g., `isLoading`, not `loading`)\n- **UIState properties**: Clear, specific names (e.g., `isPaymentProcessing`, not `state1`)\n- **NO abbreviations** except URL, ID, API, HTTP, UI (e.g., `user`, not `usr`)\n\n**Common violations**:\n```kotlin\n// ‚ùå BAD\nvar usr: User? = null\nval loading = false\nvar state1 = \"\"\n\n// ‚úÖ GOOD\nvar user: User? = null\nval isLoading = false\nvar paymentState = \"\"\n```\n\n### 2. Memory Leaks üî¥ CRITICAL\n**Impact**: App crashes, ANR, poor performance\n\n**Check for**:\n- **ViewModel references**: NEVER hold Activity/Fragment/View references\n- **Coroutine cancellation**: All coroutines must be cancelled with lifecycle\n- **Context leaks**: Use ApplicationContext for long-lived objects\n- **Listener cleanup**: Remove listeners in onDestroy/onCleared\n- **Static references**: Avoid static references to Activities/Views\n\n**Common violations**:\n```kotlin\n// ‚ùå CRITICAL - Memory Leak\nclass PaymentViewModel : ViewModel() {\n    private var activity: Activity? = null // LEAK!\n\n    fun setActivity(act: Activity) {\n        activity = act\n    }\n}\n\n// ‚ùå CRITICAL - Coroutine not cancelled\nGlobalScope.launch { // Will leak!\n    // work\n}\n\n// ‚úÖ GOOD\nclass PaymentViewModel : ViewModel() {\n    // No Activity reference\n\n    fun doWork() {\n        viewModelScope.launch { // Cancelled when ViewModel cleared\n            // work\n        }\n    }\n}\n```\n\n### 3. UIState Pattern üî¥ HIGH\n**Impact**: State consistency, UI reliability, debugging\n\n**Check for**:\n- **Single source of truth**: Use sealed class or data class for UIState\n- **Immutable state**: Use `StateFlow<UIState>` or `State<UIState>`\n- **All UI states covered**: Loading, Success, Error, Empty\n- **No scattered state**: Don't use multiple LiveData/StateFlow for related state\n- **Type safety**: Use sealed classes for state variants\n\n**Common violations**:\n```kotlin\n// ‚ùå BAD - Scattered state\nclass PaymentViewModel : ViewModel() {\n    val isLoading = MutableStateFlow(false)\n    val errorMessage = MutableStateFlow<String?>(null)\n    val data = MutableStateFlow<Payment?>(null)\n    val isEmpty = MutableStateFlow(false)\n}\n\n// ‚úÖ GOOD - Single UIState\nsealed class PaymentUIState {\n    object Loading : PaymentUIState()\n    data class Success(val payment: Payment) : PaymentUIState()\n    data class Error(val message: String) : PaymentUIState()\n    object Empty : PaymentUIState()\n}\n\nclass PaymentViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow<PaymentUIState>(PaymentUIState.Loading)\n    val uiState: StateFlow<PaymentUIState> = _uiState.asStateFlow()\n}\n```\n\n### 4. Business Logic Placement üî¥ HIGH\n**Impact**: Testability, reusability, architecture integrity\n\n**Check for**:\n- **ViewModels**: Should ONLY orchestrate, NOT contain business logic\n- **UseCases**: Must contain ALL business logic\n- **Repositories**: Data operations only, NO business decisions\n- **Activities/Fragments**: UI logic only, NO business/data logic\n- **Single Responsibility**: Each UseCase does ONE thing\n\n**Common violations**:\n```kotlin\n// ‚ùå BAD - Business logic in ViewModel\nclass PaymentViewModel(private val repository: PaymentRepository) : ViewModel() {\n    fun processPayment(amount: Double) {\n        viewModelScope.launch {\n            // ‚ùå Business logic in ViewModel!\n            if (amount <= 0) return@launch\n            val fee = amount * 0.02\n            val total = amount + fee\n            repository.savePayment(total)\n        }\n    }\n}\n\n// ‚úÖ GOOD - Business logic in UseCase\nclass ProcessPaymentUseCase(private val repository: PaymentRepository) {\n    suspend operator fun invoke(amount: Double): Result<Payment> {\n        // ‚úÖ Business logic here\n        if (amount <= 0) return Result.failure(Exception(\"Invalid amount\"))\n        val fee = amount * 0.02\n        val total = amount + fee\n        return repository.savePayment(total)\n    }\n}\n\nclass PaymentViewModel(private val processPaymentUseCase: ProcessPaymentUseCase) : ViewModel() {\n    fun processPayment(amount: Double) {\n        viewModelScope.launch {\n            // ‚úÖ ViewModel only orchestrates\n            processPaymentUseCase(amount)\n        }\n    }\n}\n```\n\n### 5. Lifecycle Management üî¥ CRITICAL\n**Impact**: Crashes, memory leaks, state loss\n\n**Check for**:\n- **Coroutine scopes**: Use `viewModelScope` or `lifecycleScope`, NEVER `GlobalScope`\n- **Fragment observers**: Must use `viewLifecycleOwner`, NOT `this`\n- **Resource cleanup**: Cleanup in `onCleared()` (ViewModel) or `onDestroy()`\n- **Configuration changes**: Handle rotation properly with ViewModel\n- **Flow collection**: Use `repeatOnLifecycle` or `flowWithLifecycle`\n\n**Common violations**:\n```kotlin\n// ‚ùå CRITICAL - Wrong lifecycle owner in Fragment\nclass PaymentFragment : Fragment() {\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        viewModel.uiState.observe(this) { // ‚ùå Should be viewLifecycleOwner\n            // Update UI\n        }\n    }\n}\n\n// ‚ùå CRITICAL - GlobalScope leak\nGlobalScope.launch {\n    repository.getData()\n}\n\n// ‚úÖ GOOD\nclass PaymentFragment : Fragment() {\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        viewModel.uiState.observe(viewLifecycleOwner) { // ‚úÖ Correct\n            // Update UI\n        }\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.uiState.collect { state ->\n                // Handle state\n            }\n        }\n    }\n}\n```\n\n### 6. MVI/MVVM Pattern Violations üî¥ HIGH\n**Impact**: Architecture consistency, maintainability, testability\n\n**MVVM Pattern Requirements**:\n- **ViewModel**: Holds UI state, handles user actions, calls UseCases\n- **View (Activity/Fragment)**: Observes state, renders UI, sends user events\n- **Model (UseCase + Repository)**: Business logic and data operations\n\n**MVI Pattern Requirements**:\n- **Intent**: User actions as sealed class\n- **Model/State**: Single immutable UIState\n- **View**: Renders state, sends intents\n- **ViewModel**: Processes intents, updates state\n\n**Check for**:\n- **No direct repository calls from ViewModel** (must use UseCase)\n- **ViewModel doesn't expose mutable state** (use private Mutable, public immutable)\n- **View doesn't contain business logic**\n- **Unidirectional data flow** (View ‚Üí Intent/Action ‚Üí ViewModel ‚Üí State ‚Üí View)\n\n**Common violations**:\n```kotlin\n// ‚ùå BAD - MVVM violation: ViewModel calling Repository directly\nclass PaymentViewModel(\n    private val paymentRepository: PaymentRepository // ‚ùå Should inject UseCase\n) : ViewModel() {\n    fun loadPayments() {\n        viewModelScope.launch {\n            val payments = paymentRepository.getPayments() // ‚ùå Skip UseCase layer\n        }\n    }\n}\n\n// ‚ùå BAD - Exposed mutable state\nclass PaymentViewModel : ViewModel() {\n    val uiState = MutableStateFlow<UIState>(UIState.Loading) // ‚ùå Mutable exposed!\n}\n\n// ‚ùå BAD - Business logic in View\nclass PaymentActivity : AppCompatActivity() {\n    fun onPayClick() {\n        val amount = amountEditText.text.toString().toDouble()\n        if (amount > 1000) { // ‚ùå Business logic in Activity!\n            // apply discount\n        }\n        viewModel.processPayment(amount)\n    }\n}\n\n// ‚úÖ GOOD - Proper MVVM\nclass PaymentViewModel(\n    private val getPaymentsUseCase: GetPaymentsUseCase, // ‚úÖ UseCase injected\n    private val processPaymentUseCase: ProcessPaymentUseCase\n) : ViewModel() {\n    private val _uiState = MutableStateFlow<PaymentUIState>(PaymentUIState.Loading)\n    val uiState: StateFlow<PaymentUIState> = _uiState.asStateFlow() // ‚úÖ Immutable exposed\n\n    fun loadPayments() {\n        viewModelScope.launch {\n            _uiState.value = PaymentUIState.Loading\n            when (val result = getPaymentsUseCase()) { // ‚úÖ Use UseCase\n                is Result.Success -> _uiState.value = PaymentUIState.Success(result.data)\n                is Result.Error -> _uiState.value = PaymentUIState.Error(result.message)\n            }\n        }\n    }\n}\n\nclass PaymentActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // ‚úÖ Only UI logic\n        lifecycleScope.launch {\n            viewModel.uiState.collect { state ->\n                when (state) {\n                    is PaymentUIState.Loading -> showLoading()\n                    is PaymentUIState.Success -> showPayments(state.payments)\n                    is PaymentUIState.Error -> showError(state.message)\n                }\n            }\n        }\n\n        payButton.setOnClickListener {\n            viewModel.processPayment(amountEditText.text.toString()) // ‚úÖ Just forward to ViewModel\n        }\n    }\n}\n```\n\n### Step 4: Generate Report\n\nFocus ONLY on CRITICAL (üî¥) and HIGH (üü†) priority issues. Skip medium and low priority findings.\n\nProvide structured output with:\n- **Summary**: Only üî¥ Critical and üü† High counts\n- **Critical Issues**: Memory leaks, lifecycle violations, crashes\n- **High Priority Issues**: Architecture violations, naming, UIState problems, business logic misplacement\n- **Code examples**: Current vs. fixed code\n- **Explanations**: Why it matters and impact\n- **Recommendations**: Prioritized actions\n\n## Severity Levels - CRITICAL & HIGH ONLY\n\nüî¥ **CRITICAL** - Fix immediately (blocks release)\n- **Memory leaks**: Activity/Context/View references in ViewModel\n- **Lifecycle violations**: GlobalScope usage, wrong lifecycle owner in Fragments\n- **Coroutine leaks**: Coroutines not cancelled with lifecycle\n- **Crash risks**: UI updates on background thread, unhandled exceptions\n- **Resource leaks**: Listeners/callbacks not cleaned up\n\nüü† **HIGH PRIORITY** - Fix before merge\n- **Naming violations**: Abbreviations, wrong case, unclear names, missing is/has prefix\n- **UIState problems**: Scattered state, no sealed class, mutable state exposed\n- **Business logic misplacement**: Logic in ViewModel/Activity instead of UseCase\n- **Architecture violations**: ViewModel calling Repository directly (skipping UseCase layer)\n- **Wrong pattern usage**: MVVM/MVI principles violated\n- **Lifecycle issues**: Not using viewLifecycleOwner, improper Flow collection\n\n## üö´ IGNORE (Out of Scope)\n- Code style and formatting (handled by linter)\n- Documentation and comments\n- Performance optimizations (unless critical)\n- Security issues (separate review)\n- Test coverage\n- Dependency injection setup\n- Medium/Low priority issues\n\n## Output Format\n\n```markdown\n# Android Code Review Report - Critical & High Priority Issues\n\n## Summary\n- üî¥ Critical: X issues (MUST fix before release)\n- üü† High Priority: X issues (MUST fix before merge)\n- ‚è≠Ô∏è Medium/Low issues: Skipped (not in scope)\n\n## üî¥ CRITICAL ISSUES\n\n### üî¥ Memory Leak - [Specific Issue]\n**File**: `path/to/file.kt:line`\n**Impact**: App crash, ANR, memory exhaustion\n\n**Current**:\n```kotlin\n// problematic code\n```\n\n**Fix**:\n```kotlin\n// corrected code\n```\n\n**Why**: [Explanation of memory leak and crash risk]\n\n---\n\n### üî¥ Lifecycle Violation - [Specific Issue]\n**File**: `path/to/file.kt:line`\n**Impact**: Resource leak, crash on configuration change\n\n**Current**:\n```kotlin\n// problematic code\n```\n\n**Fix**:\n```kotlin\n// corrected code\n```\n\n**Why**: [Explanation]\n\n---\n\n## üü† HIGH PRIORITY ISSUES\n\n### üü† Naming Convention - [Specific Issue]\n**File**: `path/to/file.kt:line`\n**Impact**: Code readability, team collaboration\n\n**Violations**:\n- Line X: `usr` should be `user`\n- Line Y: `loading` should be `isLoading`\n- Line Z: `pmtVM` should be `paymentViewModel`\n\n**Why**: [Explanation]\n\n---\n\n### üü† UIState Pattern - [Specific Issue]\n**File**: `path/to/file.kt:line`\n**Impact**: State inconsistency, hard to debug\n\n**Current**:\n```kotlin\n// scattered state\n```\n\n**Fix**:\n```kotlin\n// sealed class UIState\n```\n\n**Why**: [Explanation]\n\n---\n\n### üü† Business Logic Misplacement - [Specific Issue]\n**File**: `path/to/file.kt:line`\n**Impact**: Not testable, hard to reuse, violates Clean Architecture\n\n**Current**:\n```kotlin\n// business logic in ViewModel\n```\n\n**Fix**:\n```kotlin\n// business logic in UseCase\n```\n\n**Why**: [Explanation]\n\n---\n\n### üü† MVVM Pattern Violation - [Specific Issue]\n**File**: `path/to/file.kt:line`\n**Impact**: Architecture inconsistency, hard to maintain\n\n**Current**:\n```kotlin\n// ViewModel calling Repository directly\n```\n\n**Fix**:\n```kotlin\n// ViewModel calling UseCase\n```\n\n**Why**: [Explanation]\n\n---\n\n## ‚ö†Ô∏è MUST FIX\n\n**Before Release**:\n1. All üî¥ Critical issues (X total)\n\n**Before Merge**:\n1. All üü† High Priority issues (X total)\n\n## ‚úÖ Well Done\n[If applicable, acknowledge good patterns observed]\n```\n\n## Quick Reference\n\n**Focus**: Only report CRITICAL and HIGH priority issues:\n1. **Naming Conventions** - Abbreviations, wrong case, missing prefixes\n2. **Memory Leaks** - Activity/Context/View references in ViewModel\n3. **UIState Patterns** - Scattered state, exposed mutable state\n4. **Business Logic Placement** - Logic in wrong layers\n5. **Lifecycle Management** - GlobalScope, wrong lifecycle owner\n6. **MVI/MVVM Violations** - Repository calls from ViewModel, business logic in View\n\n**Skip**: Code style, documentation, performance (unless critical), security, tests, DI setup\n\n## Tips\n\n- **Focus on impact**: Only report issues that cause crashes, leaks, or violate core architecture\n- **Be specific**: Reference exact line numbers and variable names\n- **Show examples**: Always provide current vs. fixed code\n- **Explain why**: Impact on stability, maintainability, testability\n- **Be actionable**: Clear fix recommendations\n- **No nitpicking**: Skip style issues handled by linter\n",
        "py-plugin/skills/android-code-review/examples.md": "# Android Code Review Examples\n\nReal-world examples of common issues and recommended patterns for Android Kotlin development.\n\n## Example 1: Memory Leak - Activity Reference in ViewModel\n\n### ‚ùå BAD: Holding Activity Reference\n```kotlin\n// PaymentViewModel.kt\nclass PaymentViewModel(\n    private val activity: PaymentActivity // Memory leak!\n) : ViewModel() {\n\n    fun onPaymentComplete() {\n        activity.showSuccessDialog() // Crash if Activity destroyed!\n        activity.finish()\n    }\n}\n\n// PaymentActivity.kt\nclass PaymentActivity : AppCompatActivity() {\n\n    private val viewModel by viewModels<PaymentViewModel> {\n        PaymentViewModelFactory(this) // Passing Activity reference!\n    }\n}\n```\n\n**Issues:**\n- üî¥ **Critical**: Memory leak - ViewModel outlives Activity\n- üî¥ **Critical**: Crash risk if Activity destroyed but ViewModel still active\n- üü† **High**: Tight coupling between ViewModel and View\n\n### ‚úÖ GOOD: Event-Based Navigation\n```kotlin\n// PaymentViewModel.kt\nclass PaymentViewModel : ViewModel() {\n\n    private val _events = MutableSharedFlow<PaymentEvent>()\n    val events: SharedFlow<PaymentEvent> = _events.asSharedFlow()\n\n    fun onPaymentComplete() {\n        viewModelScope.launch {\n            _events.emit(PaymentEvent.ShowSuccessDialog)\n            _events.emit(PaymentEvent.Finish)\n        }\n    }\n}\n\nsealed class PaymentEvent {\n    object ShowSuccessDialog : PaymentEvent()\n    object Finish : PaymentEvent()\n    data class NavigateTo(val destination: String) : PaymentEvent()\n}\n\n// PaymentActivity.kt\n@AndroidEntryPoint\nclass PaymentActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var viewModel: PaymentViewModel\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        lifecycleScope.launch {\n            viewModel.events.collect { event ->\n                when (event) {\n                    PaymentEvent.ShowSuccessDialog -> showSuccessDialog()\n                    PaymentEvent.Finish -> finish()\n                    is PaymentEvent.NavigateTo -> navigate(event.destination)\n                }\n            }\n        }\n    }\n}\n```\n\n**Benefits:**\n- ‚úÖ No memory leaks - ViewModel doesn't hold Activity reference\n- ‚úÖ Lifecycle-safe - Events only processed when Activity is active\n- ‚úÖ Testable - ViewModel logic can be tested independently\n\n---\n\n## Example 2: Coroutine Scope and Cancellation\n\n### ‚ùå BAD: GlobalScope and No Cancellation\n```kotlin\nclass PaymentViewModel : ViewModel() {\n\n    fun loadPayments() {\n        GlobalScope.launch { // Never cancelled!\n            val payments = repository.getPayments()\n            _payments.value = payments // Can crash if ViewModel cleared\n        }\n    }\n\n    fun processPayment(request: PaymentRequest) {\n        GlobalScope.launch(Dispatchers.Main) {\n            val result = repository.processPayment(request) // Blocks UI thread!\n            _result.value = result\n        }\n    }\n}\n```\n\n**Issues:**\n- üî¥ **Critical**: GlobalScope coroutines never cancelled - resource leak\n- üî¥ **Critical**: Network/DB on Main thread - ANR risk\n- üü† **High**: Crash risk when updating UI after ViewModel cleared\n\n### ‚úÖ GOOD: ViewModelScope and Proper Dispatchers\n```kotlin\nclass PaymentViewModel(\n    private val repository: PaymentRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<UiState<List<Payment>>>(UiState.Loading)\n    val uiState: StateFlow<UiState<List<Payment>>> = _uiState.asStateFlow()\n\n    fun loadPayments() {\n        viewModelScope.launch {\n            _uiState.value = UiState.Loading\n\n            try {\n                // Repository handles IO dispatcher internally\n                val payments = repository.getPayments()\n                _uiState.value = UiState.Success(payments)\n            } catch (e: IOException) {\n                _uiState.value = UiState.Error(\"Network error: ${e.message}\")\n            } catch (e: Exception) {\n                _uiState.value = UiState.Error(\"Unexpected error: ${e.message}\")\n            }\n        }\n    }\n\n    fun processPayment(request: PaymentRequest) {\n        viewModelScope.launch {\n            _uiState.value = UiState.Loading\n\n            runCatching {\n                repository.processPayment(request)\n            }.onSuccess { result ->\n                _uiState.value = UiState.Success(result)\n            }.onFailure { error ->\n                _uiState.value = UiState.Error(error.message ?: \"Unknown error\")\n            }\n        }\n    }\n}\n\n// Repository with proper dispatcher\nclass PaymentRepositoryImpl(\n    private val api: PaymentApi,\n    private val dao: PaymentDao,\n    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO\n) : PaymentRepository {\n\n    override suspend fun getPayments(): List<Payment> = withContext(ioDispatcher) {\n        api.fetchPayments()\n    }\n\n    override suspend fun processPayment(request: PaymentRequest): PaymentResult =\n        withContext(ioDispatcher) {\n            api.processPayment(request)\n        }\n}\n```\n\n**Benefits:**\n- ‚úÖ Automatic cancellation when ViewModel cleared\n- ‚úÖ Proper thread management - IO work on background\n- ‚úÖ Comprehensive error handling\n- ‚úÖ Single source of truth for UI state\n\n---\n\n## Example 3: Clean Architecture Violation\n\n### ‚ùå BAD: ViewModel with Business Logic and Direct API Calls\n```kotlin\nclass PaymentViewModel(\n    private val api: PaymentApi // Wrong layer!\n) : ViewModel() {\n\n    private val _result = MutableLiveData<PaymentResult>()\n    val result: LiveData<PaymentResult> = _result\n\n    fun processPayment(amount: String, merchantId: String) {\n        viewModelScope.launch {\n            // Business logic in ViewModel - WRONG!\n            val amountBigDecimal = try {\n                BigDecimal(amount)\n            } catch (e: NumberFormatException) {\n                _result.value = PaymentResult.Error(\"Invalid amount\")\n                return@launch\n            }\n\n            if (amountBigDecimal < BigDecimal(\"1000\")) {\n                _result.value = PaymentResult.Error(\"Minimum amount is 1000 VND\")\n                return@launch\n            }\n\n            val fee = amountBigDecimal * BigDecimal(\"0.02\") // Business logic!\n            val total = amountBigDecimal + fee\n\n            // Calling API directly - WRONG!\n            try {\n                val response = api.processPayment(\n                    PaymentRequest(\n                        amount = total,\n                        merchantId = merchantId,\n                        timestamp = System.currentTimeMillis()\n                    )\n                )\n                _result.value = PaymentResult.Success(response)\n            } catch (e: Exception) {\n                _result.value = PaymentResult.Error(e.message ?: \"Error\")\n            }\n        }\n    }\n}\n```\n\n**Issues:**\n- üü† **High**: Business logic in ViewModel (validation, fee calculation)\n- üü† **High**: ViewModel depends on Data layer (API) directly\n- üü° **Medium**: No UseCase - business logic not reusable\n- üü° **Medium**: Mixing concerns - validation, calculation, networking\n\n### ‚úÖ GOOD: Proper Clean Architecture Layers\n```kotlin\n// Domain Layer - UseCase\nclass ProcessPaymentUseCase(\n    private val repository: PaymentRepository,\n    private val validator: PaymentValidator,\n    private val feeCalculator: FeeCalculator\n) {\n    suspend operator fun invoke(\n        amount: String,\n        merchantId: String\n    ): Result<PaymentResult> = runCatching {\n        // Business logic in UseCase\n        val amountBigDecimal = validator.parseAndValidateAmount(amount)\n        validator.validateMerchant(merchantId)\n\n        val fee = feeCalculator.calculateFee(amountBigDecimal)\n        val total = amountBigDecimal + fee\n\n        val request = PaymentRequest(\n            amount = total,\n            merchantId = merchantId,\n            timestamp = System.currentTimeMillis()\n        )\n\n        repository.processPayment(request)\n    }\n}\n\n// Domain Layer - Validators and Calculators\nclass PaymentValidator {\n    fun parseAndValidateAmount(amount: String): BigDecimal {\n        val amountBigDecimal = amount.toBigDecimalOrNull()\n            ?: throw IllegalArgumentException(\"Invalid amount format\")\n\n        if (amountBigDecimal < MIN_AMOUNT) {\n            throw IllegalArgumentException(\"Minimum amount is $MIN_AMOUNT VND\")\n        }\n\n        return amountBigDecimal\n    }\n\n    fun validateMerchant(merchantId: String) {\n        if (merchantId.isBlank()) {\n            throw IllegalArgumentException(\"Invalid merchant ID\")\n        }\n    }\n\n    companion object {\n        private val MIN_AMOUNT = BigDecimal(\"1000\")\n    }\n}\n\nclass FeeCalculator {\n    fun calculateFee(amount: BigDecimal): BigDecimal {\n        return amount * FEE_RATE\n    }\n\n    companion object {\n        private val FEE_RATE = BigDecimal(\"0.02\")\n    }\n}\n\n// Presentation Layer - ViewModel\nclass PaymentViewModel(\n    private val processPaymentUseCase: ProcessPaymentUseCase\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<PaymentUiState>(PaymentUiState.Initial)\n    val uiState: StateFlow<PaymentUiState> = _uiState.asStateFlow()\n\n    fun processPayment(amount: String, merchantId: String) {\n        viewModelScope.launch {\n            _uiState.value = PaymentUiState.Loading\n\n            processPaymentUseCase(amount, merchantId)\n                .onSuccess { result ->\n                    _uiState.value = PaymentUiState.Success(result)\n                }\n                .onFailure { error ->\n                    _uiState.value = PaymentUiState.Error(error.message ?: \"Unknown error\")\n                }\n        }\n    }\n}\n\n// Data Layer - Repository\nclass PaymentRepositoryImpl(\n    private val remoteDataSource: PaymentRemoteDataSource,\n    private val localDataSource: PaymentLocalDataSource,\n    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO\n) : PaymentRepository {\n\n    override suspend fun processPayment(\n        request: PaymentRequest\n    ): PaymentResult = withContext(ioDispatcher) {\n        val result = remoteDataSource.processPayment(request)\n        localDataSource.savePayment(result.toEntity())\n        result\n    }\n}\n```\n\n**Benefits:**\n- ‚úÖ Clear separation of concerns\n- ‚úÖ Business logic in Domain layer (UseCase)\n- ‚úÖ ViewModel only handles presentation logic\n- ‚úÖ Reusable business logic\n- ‚úÖ Testable - each layer can be tested independently\n\n---\n\n## Example 4: Insecure Storage\n\n### ‚ùå BAD: Plain SharedPreferences for Sensitive Data\n```kotlin\nclass AuthManager(private val context: Context) {\n\n    private val prefs = context.getSharedPreferences(\"auth\", Context.MODE_PRIVATE)\n\n    fun saveAuthToken(token: String) {\n        prefs.edit {\n            putString(\"auth_token\", token) // Plain text!\n        }\n    }\n\n    fun saveUserPin(pin: String) {\n        prefs.edit {\n            putString(\"user_pin\", pin) // Plain text!\n        }\n    }\n\n    fun getAuthToken(): String? {\n        return prefs.getString(\"auth_token\", null)\n    }\n}\n```\n\n**Issues:**\n- üî¥ **Critical**: Auth token stored in plain text\n- üî¥ **Critical**: User PIN stored in plain text\n- üî¥ **Critical**: Security vulnerability - data can be read by rooted devices\n\n### ‚úÖ GOOD: EncryptedSharedPreferences\n```kotlin\nclass SecureAuthManager(private val context: Context) {\n\n    private val masterKey = MasterKey.Builder(context)\n        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n        .build()\n\n    private val encryptedPrefs = EncryptedSharedPreferences.create(\n        context,\n        \"secure_auth\",\n        masterKey,\n        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n    )\n\n    fun saveAuthToken(token: String) {\n        encryptedPrefs.edit {\n            putString(KEY_AUTH_TOKEN, token)\n        }\n    }\n\n    fun saveUserPin(pin: String) {\n        encryptedPrefs.edit {\n            putString(KEY_USER_PIN, pin)\n        }\n    }\n\n    fun getAuthToken(): String? {\n        return encryptedPrefs.getString(KEY_AUTH_TOKEN, null)\n    }\n\n    fun clearAuthData() {\n        encryptedPrefs.edit {\n            remove(KEY_AUTH_TOKEN)\n            remove(KEY_USER_PIN)\n        }\n    }\n\n    companion object {\n        private const val KEY_AUTH_TOKEN = \"auth_token\"\n        private const val KEY_USER_PIN = \"user_pin\"\n    }\n}\n```\n\n**Benefits:**\n- ‚úÖ Encrypted storage using AES256\n- ‚úÖ Protected against unauthorized access\n- ‚úÖ Secure even on rooted devices\n- ‚úÖ Clear API for data management\n\n---\n\n## Example 5: Inefficient RecyclerView\n\n### ‚ùå BAD: notifyDataSetChanged and No ViewBinding\n```kotlin\nclass PaymentAdapter : RecyclerView.Adapter<PaymentAdapter.ViewHolder>() {\n\n    private var payments: List<Payment> = emptyList()\n\n    fun updatePayments(newPayments: List<Payment>) {\n        payments = newPayments\n        notifyDataSetChanged() // Inefficient!\n    }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_payment, parent, false)\n        return ViewHolder(view)\n    }\n\n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.bind(payments[position])\n    }\n\n    override fun getItemCount() = payments.size\n\n    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n        // Finding views repeatedly - inefficient!\n        fun bind(payment: Payment) {\n            itemView.findViewById<TextView>(R.id.amountTextView).text =\n                payment.amount.toString()\n            itemView.findViewById<TextView>(R.id.merchantTextView).text =\n                payment.merchantName\n            itemView.findViewById<TextView>(R.id.dateTextView).text =\n                payment.formattedDate\n        }\n    }\n}\n```\n\n**Issues:**\n- üü° **Medium**: notifyDataSetChanged() redraws entire list\n- üü° **Medium**: findViewById called repeatedly in bind()\n- üü° **Medium**: No ViewBinding - prone to errors\n\n### ‚úÖ GOOD: ListAdapter with DiffUtil and ViewBinding\n```kotlin\nclass PaymentAdapter(\n    private val onItemClick: (Payment) -> Unit\n) : ListAdapter<Payment, PaymentAdapter.ViewHolder>(PaymentDiffCallback()) {\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val binding = ItemPaymentBinding.inflate(\n            LayoutInflater.from(parent.context),\n            parent,\n            false\n        )\n        return ViewHolder(binding, onItemClick)\n    }\n\n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n\n    class ViewHolder(\n        private val binding: ItemPaymentBinding,\n        private val onItemClick: (Payment) -> Unit\n    ) : RecyclerView.ViewHolder(binding.root) {\n\n        fun bind(payment: Payment) {\n            binding.apply {\n                amountTextView.text = payment.amount.formatAsCurrency()\n                merchantTextView.text = payment.merchantName\n                dateTextView.text = payment.formattedDate\n                statusBadge.text = payment.status\n\n                // Set status color\n                statusBadge.setBackgroundResource(\n                    when (payment.status) {\n                        \"SUCCESS\" -> R.drawable.bg_status_success\n                        \"PENDING\" -> R.drawable.bg_status_pending\n                        \"FAILED\" -> R.drawable.bg_status_failed\n                        else -> R.drawable.bg_status_unknown\n                    }\n                )\n\n                root.setOnClickListener {\n                    onItemClick(payment)\n                }\n            }\n        }\n    }\n}\n\nclass PaymentDiffCallback : DiffUtil.ItemCallback<Payment>() {\n    override fun areItemsTheSame(oldItem: Payment, newItem: Payment): Boolean {\n        return oldItem.id == newItem.id\n    }\n\n    override fun areContentsTheSame(oldItem: Payment, newItem: Payment): Boolean {\n        return oldItem == newItem\n    }\n}\n\n// Usage in Fragment\nclass PaymentListFragment : Fragment() {\n\n    private val adapter = PaymentAdapter { payment ->\n        navigateToPaymentDetail(payment.id)\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        binding.recyclerView.adapter = adapter\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.payments.collect { payments ->\n                adapter.submitList(payments) // DiffUtil automatically calculates changes\n            }\n        }\n    }\n}\n```\n\n**Benefits:**\n- ‚úÖ Efficient updates - only changed items redrawn\n- ‚úÖ ViewBinding - type-safe, no findViewById\n- ‚úÖ Automatic animation with DiffUtil\n- ‚úÖ Click handling with lambda\n- ‚úÖ Extension function for formatting\n\n---\n\n## Example 6: Fragment Lifecycle Issues\n\n### ‚ùå BAD: Wrong Lifecycle Owner\n```kotlin\nclass PaymentFragment : Fragment() {\n\n    private var _binding: FragmentPaymentBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentPaymentBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        // Using fragment's lifecycle - WRONG!\n        lifecycleScope.launch {\n            viewModel.uiState.collect { state ->\n                updateUi(state) // Can crash after onDestroyView!\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}\n```\n\n**Issues:**\n- üî¥ **Critical**: Using fragment lifecycle instead of view lifecycle\n- üî¥ **Critical**: Crash risk - accessing binding after onDestroyView\n- üü† **High**: Memory leak between onDestroyView and onDestroy\n\n### ‚úÖ GOOD: Proper Lifecycle Management\n```kotlin\nclass PaymentFragment : Fragment() {\n\n    private var _binding: FragmentPaymentBinding? = null\n    private val binding get() = _binding!!\n\n    private val viewModel: PaymentViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentPaymentBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        setupViews()\n        observeViewModel()\n    }\n\n    private fun setupViews() {\n        binding.submitButton.setOnClickListener {\n            val amount = binding.amountEditText.text.toString()\n            viewModel.processPayment(amount)\n        }\n    }\n\n    private fun observeViewModel() {\n        // Use viewLifecycleOwner for UI updates\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.uiState.collect { state ->\n                updateUi(state)\n            }\n        }\n\n        // Separate collection for one-time events\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.events.collect { event ->\n                handleEvent(event)\n            }\n        }\n    }\n\n    private fun updateUi(state: PaymentUiState) {\n        when (state) {\n            is PaymentUiState.Loading -> {\n                binding.progressBar.show()\n                binding.submitButton.isEnabled = false\n            }\n            is PaymentUiState.Success -> {\n                binding.progressBar.hide()\n                binding.submitButton.isEnabled = true\n                showSuccessMessage(state.result)\n            }\n            is PaymentUiState.Error -> {\n                binding.progressBar.hide()\n                binding.submitButton.isEnabled = true\n                showError(state.message)\n            }\n            is PaymentUiState.Initial -> {\n                binding.progressBar.hide()\n                binding.submitButton.isEnabled = true\n            }\n        }\n    }\n\n    private fun handleEvent(event: PaymentEvent) {\n        when (event) {\n            is PaymentEvent.NavigateToReceipt -> {\n                findNavController().navigate(\n                    PaymentFragmentDirections.actionToReceipt(event.transactionId)\n                )\n            }\n            is PaymentEvent.ShowError -> {\n                Snackbar.make(binding.root, event.message, Snackbar.LENGTH_LONG).show()\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}\n```\n\n**Benefits:**\n- ‚úÖ Correct lifecycle owner - viewLifecycleOwner\n- ‚úÖ No crash risk - collections cancelled when view destroyed\n- ‚úÖ Proper binding cleanup\n- ‚úÖ Separation of state and events\n- ‚úÖ Clean code organization\n\n---\n\n## Example 7: Hardcoded Configuration\n\n### ‚ùå BAD: Hardcoded API Keys and URLs\n```kotlin\nclass ApiClient {\n\n    private val retrofit = Retrofit.Builder()\n        .baseUrl(\"https://api.payoo.vn/v1/\") // Hardcoded!\n        .addConverterFactory(GsonConverterFactory.create())\n        .build()\n\n    private val apiKey = \"sk_live_abc123xyz789\" // Hardcoded secret!\n\n    fun getPaymentApi(): PaymentApi {\n        return retrofit.create(PaymentApi::class.java)\n    }\n}\n\nclass AuthInterceptor : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val request = chain.request().newBuilder()\n            .addHeader(\"API-Key\", \"sk_live_abc123xyz789\") // Hardcoded!\n            .build()\n        return chain.proceed(request)\n    }\n}\n```\n\n**Issues:**\n- üî¥ **Critical**: API key exposed in source code\n- üü† **High**: Can't switch between dev/staging/prod\n- üü† **High**: Security risk if code is decompiled\n\n### ‚úÖ GOOD: BuildConfig and Gradle Properties\n```kotlin\n// gradle.properties (add to .gitignore)\nAPI_KEY_DEBUG=sk_test_debug_key\nAPI_KEY_RELEASE=sk_live_production_key\nAPI_BASE_URL_DEBUG=https://api-dev.payoo.vn/v1/\nAPI_BASE_URL_RELEASE=https://api.payoo.vn/v1/\n\n// app/build.gradle.kts\nandroid {\n    defaultConfig {\n        buildConfigField(\"String\", \"API_KEY\", \"\\\"${project.findProperty(\"API_KEY_DEBUG\")}\\\"\")\n        buildConfigField(\"String\", \"API_BASE_URL\", \"\\\"${project.findProperty(\"API_BASE_URL_DEBUG\")}\\\"\")\n    }\n\n    buildTypes {\n        getByName(\"debug\") {\n            buildConfigField(\"String\", \"API_KEY\", \"\\\"${project.findProperty(\"API_KEY_DEBUG\")}\\\"\")\n            buildConfigField(\"String\", \"API_BASE_URL\", \"\\\"${project.findProperty(\"API_BASE_URL_DEBUG\")}\\\"\")\n        }\n        getByName(\"release\") {\n            buildConfigField(\"String\", \"API_KEY\", \"\\\"${project.findProperty(\"API_KEY_RELEASE\")}\\\"\")\n            buildConfigField(\"String\", \"API_BASE_URL\", \"\\\"${project.findProperty(\"API_BASE_URL_RELEASE\")}\\\"\")\n        }\n    }\n}\n\n// NetworkModule.kt\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n\n    @Provides\n    @Singleton\n    fun provideAuthInterceptor(): AuthInterceptor {\n        return AuthInterceptor(BuildConfig.API_KEY)\n    }\n\n    @Provides\n    @Singleton\n    fun provideOkHttpClient(authInterceptor: AuthInterceptor): OkHttpClient {\n        return OkHttpClient.Builder()\n            .addInterceptor(authInterceptor)\n            .addInterceptor(HttpLoggingInterceptor().apply {\n                level = if (BuildConfig.DEBUG) {\n                    HttpLoggingInterceptor.Level.BODY\n                } else {\n                    HttpLoggingInterceptor.Level.NONE\n                }\n            })\n            .connectTimeout(30, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .build()\n    }\n\n    @Provides\n    @Singleton\n    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(BuildConfig.API_BASE_URL)\n            .client(okHttpClient)\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n}\n\nclass AuthInterceptor(private val apiKey: String) : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val request = chain.request().newBuilder()\n            .addHeader(\"API-Key\", apiKey)\n            .addHeader(\"Content-Type\", \"application/json\")\n            .build()\n        return chain.proceed(request)\n    }\n}\n```\n\n**Benefits:**\n- ‚úÖ API keys not in source code\n- ‚úÖ Different configs for debug/release\n- ‚úÖ Secure - keys in gradle.properties (gitignored)\n- ‚úÖ Easy to manage different environments\n- ‚úÖ Dependency injection for testability\n\n---\n\n## Summary of Common Issues\n\n### Critical (Fix Immediately)\n1. Memory leaks (Activity/Context in ViewModel)\n2. Coroutines not cancelled (GlobalScope)\n3. Plain text storage for sensitive data\n4. Hardcoded API keys/secrets\n5. UI updates on background thread\n\n### High Priority (Fix Soon)\n6. Business logic in ViewModel\n7. Direct API calls from ViewModel\n8. Wrong lifecycle owner in Fragments\n9. No error handling in coroutines\n10. Wrong Dispatcher usage\n\n### Medium Priority (Should Improve)\n11. notifyDataSetChanged() instead of DiffUtil\n12. findViewById instead of ViewBinding\n13. No null safety checks\n14. Poor naming conventions\n15. Not using data classes\n\nThese examples provide concrete guidance for identifying and fixing common Android code issues during reviews.\n",
        "py-plugin/skills/android-code-review/standards.md": "# Android Code Review Standards\n\nComprehensive standards for Android Kotlin development in the Payoo Android application.\n\n## 1. Naming Conventions\n\n### Types and Classes\n```kotlin\n// ‚úÖ GOOD: PascalCase, descriptive\nclass PaymentViewModel\nclass TransactionRepository\ninterface UserDataSource\nsealed class PaymentResult\n\n// ‚ùå BAD: Abbreviations, unclear\nclass PmtVM\nclass TxnRepo\n```\n\n### Variables and Properties\n```kotlin\n// ‚úÖ GOOD: camelCase, descriptive\nval paymentAmount: BigDecimal\nvar isLoading: Boolean\nprivate val transactionList: List<Transaction>\n\n// ‚ùå BAD: Abbreviations, unclear\nval amt: BigDecimal\nvar loading: Boolean\nval txns: List<Transaction>\n```\n\n### Constants\n```kotlin\n// ‚úÖ GOOD: UPPER_SNAKE_CASE\nconst val MAX_RETRY_COUNT = 3\nconst val API_BASE_URL = \"https://api.payoo.vn\"\nprivate const val CACHE_DURATION_MS = 5000L\n\n// ‚ùå BAD: Wrong case\nconst val maxRetryCount = 3\nconst val apiBaseUrl = \"https://api.payoo.vn\"\n```\n\n### Boolean Variables\n```kotlin\n// ‚úÖ GOOD: Prefix with is, has, should, can\nval isPaymentSuccessful: Boolean\nval hasInternetConnection: Boolean\nval shouldRetry: Boolean\nval canProceed: Boolean\n\n// ‚ùå BAD: No prefix\nval paymentSuccessful: Boolean\nval internetConnection: Boolean\n```\n\n### View IDs and Binding\n```kotlin\n// ‚úÖ GOOD: Include type suffix\nbinding.amountEditText\nbinding.submitButton\nbinding.paymentRecyclerView\nbinding.errorTextView\n\n// ‚ùå BAD: No type suffix\nbinding.amount\nbinding.submit\nbinding.payments\n```\n\n## 2. Kotlin Best Practices\n\n### Null Safety\n```kotlin\n// ‚úÖ GOOD: Safe calls and Elvis operator\nval length = text?.length ?: 0\nuser?.name?.let { name ->\n    displayName(name)\n}\n\n// ‚ùå BAD: Force unwrap without checking\nval length = text!!.length\ndisplayName(user!!.name!!)\n```\n\n### Data Classes\n```kotlin\n// ‚úÖ GOOD: Data classes for DTOs/Models\ndata class User(\n    val id: String,\n    val name: String,\n    val email: String\n)\n\ndata class PaymentRequest(\n    val amount: BigDecimal,\n    val merchantId: String,\n    val currency: String = \"VND\"\n)\n\n// ‚ùå BAD: Regular class for simple data\nclass User {\n    var id: String = \"\"\n    var name: String = \"\"\n    var email: String = \"\"\n}\n```\n\n### Sealed Classes for State\n```kotlin\n// ‚úÖ GOOD: Sealed classes for state management\nsealed class UiState<out T> {\n    object Loading : UiState<Nothing>()\n    data class Success<T>(val data: T) : UiState<T>()\n    data class Error(val message: String) : UiState<Nothing>()\n}\n\nsealed class PaymentResult {\n    data class Success(val transactionId: String) : PaymentResult()\n    data class Failure(val error: PaymentError) : PaymentResult()\n    object Cancelled : PaymentResult()\n}\n\n// ‚ùå BAD: Using enums or nullable types\nenum class State { LOADING, SUCCESS, ERROR }\n```\n\n### Immutability\n```kotlin\n// ‚úÖ GOOD: Prefer val over var\nval userId = getUserId()\nval configuration = Config(apiKey, baseUrl)\n\n// ‚ùå BAD: Unnecessary var\nvar userId = getUserId() // Never changed\nvar configuration = Config(apiKey, baseUrl) // Never changed\n```\n\n### Extension Functions\n```kotlin\n// ‚úÖ GOOD: Extension functions for reusable utilities\nfun String.isValidEmail(): Boolean {\n    return android.util.Patterns.EMAIL_ADDRESS.matcher(this).matches()\n}\n\nfun BigDecimal.formatAsCurrency(): String {\n    return NumberFormat.getCurrencyInstance(Locale(\"vi\", \"VN\")).format(this)\n}\n\nfun View.show() {\n    visibility = View.VISIBLE\n}\n\nfun View.hide() {\n    visibility = View.GONE\n}\n\n// Usage\nif (email.isValidEmail()) {\n    binding.submitButton.show()\n}\n```\n\n### Scope Functions\n```kotlin\n// ‚úÖ GOOD: Appropriate scope function usage\n\n// apply: Configure object\nval user = User().apply {\n    name = \"John\"\n    email = \"john@example.com\"\n}\n\n// let: Null-safe operations\nuser?.let { u ->\n    saveUser(u)\n}\n\n// also: Side effects\nval numbers = mutableListOf(1, 2, 3).also {\n    println(\"List created with ${it.size} elements\")\n}\n\n// run: Execute block and return result\nval result = repository.run {\n    fetchData()\n    processData()\n}\n\n// with: Multiple operations on object\nwith(binding) {\n    titleTextView.text = title\n    descriptionTextView.text = description\n    imageView.load(imageUrl)\n}\n```\n\n## 3. Coroutines Patterns\n\n### Proper Scope Usage\n```kotlin\n// ‚úÖ GOOD: Use appropriate scope\nclass PaymentViewModel : ViewModel() {\n    fun loadPayments() {\n        viewModelScope.launch {\n            // Automatically cancelled when ViewModel cleared\n            val payments = repository.getPayments()\n            _uiState.value = UiState.Success(payments)\n        }\n    }\n}\n\nclass PaymentFragment : Fragment() {\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            // Cancelled when view is destroyed\n            viewModel.uiState.collect { state ->\n                updateUi(state)\n            }\n        }\n    }\n}\n\n// ‚ùå BAD: GlobalScope or runBlocking\nGlobalScope.launch { // Never cancelled\n    repository.getPayments()\n}\n\nrunBlocking { // Blocks thread\n    repository.getPayments()\n}\n```\n\n### Dispatcher Usage\n```kotlin\n// ‚úÖ GOOD: Appropriate dispatcher for task\nclass PaymentRepository(\n    private val api: PaymentApi,\n    private val database: PaymentDao,\n    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO\n) {\n    suspend fun getPayments(): List<Payment> = withContext(ioDispatcher) {\n        val remotePayments = api.fetchPayments()\n        database.insertAll(remotePayments)\n        database.getAllPayments()\n    }\n}\n\n// ‚ùå BAD: Wrong dispatcher\nclass PaymentRepository {\n    suspend fun getPayments(): List<Payment> = withContext(Dispatchers.Main) {\n        // Network/DB work on Main thread!\n        api.fetchPayments()\n    }\n}\n```\n\n### Error Handling\n```kotlin\n// ‚úÖ GOOD: Proper error handling\nviewModelScope.launch {\n    _uiState.value = UiState.Loading\n\n    try {\n        val result = repository.processPayment(request)\n        _uiState.value = UiState.Success(result)\n    } catch (e: IOException) {\n        _uiState.value = UiState.Error(\"Network error: ${e.message}\")\n    } catch (e: Exception) {\n        _uiState.value = UiState.Error(\"Unexpected error: ${e.message}\")\n    }\n}\n\n// Or using runCatching\nviewModelScope.launch {\n    _uiState.value = UiState.Loading\n\n    runCatching {\n        repository.processPayment(request)\n    }.onSuccess { result ->\n        _uiState.value = UiState.Success(result)\n    }.onFailure { error ->\n        _uiState.value = UiState.Error(error.message ?: \"Unknown error\")\n    }\n}\n\n// ‚ùå BAD: No error handling\nviewModelScope.launch {\n    val result = repository.processPayment(request) // Can crash\n    _uiState.value = UiState.Success(result)\n}\n```\n\n### Flow Usage\n```kotlin\n// ‚úÖ GOOD: StateFlow for UI state\nclass PaymentViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow<UiState<Payment>>(UiState.Loading)\n    val uiState: StateFlow<UiState<Payment>> = _uiState.asStateFlow()\n\n    private val _events = MutableSharedFlow<PaymentEvent>()\n    val events: SharedFlow<PaymentEvent> = _events.asSharedFlow()\n\n    fun processPayment(request: PaymentRequest) {\n        viewModelScope.launch {\n            repository.processPayment(request)\n                .catch { error ->\n                    _uiState.value = UiState.Error(error.message)\n                }\n                .collect { result ->\n                    _uiState.value = UiState.Success(result)\n                }\n        }\n    }\n}\n\n// ‚ùå BAD: LiveData with nullable types\nclass PaymentViewModel : ViewModel() {\n    val payment: MutableLiveData<Payment?> = MutableLiveData(null)\n    val error: MutableLiveData<String?> = MutableLiveData(null)\n}\n```\n\n## 4. Clean Architecture\n\n### Layer Structure\n```\napp/\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îú‚îÄ‚îÄ datasource/    # API, Database, Cache\n‚îÇ   ‚îú‚îÄ‚îÄ repository/    # Implementation\n‚îÇ   ‚îî‚îÄ‚îÄ model/         # DTOs, Entities\n‚îú‚îÄ‚îÄ domain/\n‚îÇ   ‚îú‚îÄ‚îÄ model/         # Domain models\n‚îÇ   ‚îú‚îÄ‚îÄ repository/    # Repository interfaces\n‚îÇ   ‚îî‚îÄ‚îÄ usecase/       # Business logic\n‚îî‚îÄ‚îÄ presentation/\n    ‚îú‚îÄ‚îÄ ui/            # Activities, Fragments\n    ‚îú‚îÄ‚îÄ viewmodel/     # ViewModels\n    ‚îî‚îÄ‚îÄ adapter/       # RecyclerView adapters\n```\n\n### ViewModel (Presentation Layer)\n```kotlin\n// ‚úÖ GOOD: ViewModel uses UseCase, exposes UI state\nclass PaymentViewModel(\n    private val processPaymentUseCase: ProcessPaymentUseCase,\n    private val getPaymentHistoryUseCase: GetPaymentHistoryUseCase\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<PaymentUiState>(PaymentUiState.Initial)\n    val uiState: StateFlow<PaymentUiState> = _uiState.asStateFlow()\n\n    fun processPayment(amount: BigDecimal, merchantId: String) {\n        viewModelScope.launch {\n            _uiState.value = PaymentUiState.Loading\n\n            processPaymentUseCase(amount, merchantId)\n                .onSuccess { result ->\n                    _uiState.value = PaymentUiState.Success(result)\n                }\n                .onFailure { error ->\n                    _uiState.value = PaymentUiState.Error(error.message)\n                }\n        }\n    }\n}\n\n// ‚ùå BAD: ViewModel calls repository directly, has business logic\nclass PaymentViewModel(\n    private val repository: PaymentRepository\n) : ViewModel() {\n\n    fun processPayment(amount: BigDecimal, merchantId: String) {\n        viewModelScope.launch {\n            // Business logic in ViewModel - WRONG!\n            if (amount < BigDecimal.ZERO) {\n                _error.value = \"Invalid amount\"\n                return@launch\n            }\n\n            val fee = amount * BigDecimal(\"0.02\") // Business logic!\n            val total = amount + fee\n\n            // Calling repository directly - WRONG!\n            repository.processPayment(total, merchantId)\n        }\n    }\n}\n```\n\n### UseCase (Domain Layer)\n```kotlin\n// ‚úÖ GOOD: UseCase contains business logic\nclass ProcessPaymentUseCase(\n    private val paymentRepository: PaymentRepository,\n    private val feeCalculator: FeeCalculator,\n    private val validator: PaymentValidator\n) {\n    suspend operator fun invoke(\n        amount: BigDecimal,\n        merchantId: String\n    ): Result<PaymentResult> = runCatching {\n        // Business logic here\n        validator.validateAmount(amount)\n        validator.validateMerchant(merchantId)\n\n        val fee = feeCalculator.calculateFee(amount)\n        val totalAmount = amount + fee\n\n        val request = PaymentRequest(\n            amount = totalAmount,\n            merchantId = merchantId,\n            timestamp = System.currentTimeMillis()\n        )\n\n        paymentRepository.processPayment(request)\n    }\n}\n\n// ‚ùå BAD: UseCase just forwards to repository\nclass ProcessPaymentUseCase(\n    private val repository: PaymentRepository\n) {\n    suspend operator fun invoke(request: PaymentRequest) =\n        repository.processPayment(request) // No value added!\n}\n```\n\n### Repository (Data Layer)\n```kotlin\n// ‚úÖ GOOD: Repository abstracts data sources\ninterface PaymentRepository {\n    suspend fun processPayment(request: PaymentRequest): PaymentResult\n    suspend fun getPaymentHistory(): List<Payment>\n}\n\nclass PaymentRepositoryImpl(\n    private val remoteDataSource: PaymentRemoteDataSource,\n    private val localDataSource: PaymentLocalDataSource,\n    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO\n) : PaymentRepository {\n\n    override suspend fun processPayment(\n        request: PaymentRequest\n    ): PaymentResult = withContext(ioDispatcher) {\n        val result = remoteDataSource.processPayment(request)\n        localDataSource.savePayment(result.toEntity())\n        result\n    }\n\n    override suspend fun getPaymentHistory(): List<Payment> = withContext(ioDispatcher) {\n        try {\n            val remote = remoteDataSource.getPayments()\n            localDataSource.saveAll(remote.map { it.toEntity() })\n            remote\n        } catch (e: IOException) {\n            // Fallback to cache\n            localDataSource.getPayments().map { it.toDomain() }\n        }\n    }\n}\n\n// ‚ùå BAD: Repository has business logic\nclass PaymentRepositoryImpl(\n    private val api: PaymentApi\n) : PaymentRepository {\n\n    override suspend fun processPayment(request: PaymentRequest): PaymentResult {\n        // Business logic in repository - WRONG!\n        if (request.amount < MIN_AMOUNT) {\n            throw IllegalArgumentException(\"Amount too low\")\n        }\n\n        val fee = request.amount * FEE_RATE // Business logic!\n        val modifiedRequest = request.copy(amount = request.amount + fee)\n\n        return api.processPayment(modifiedRequest)\n    }\n}\n```\n\n## 5. Lifecycle Management\n\n### Activity/Fragment References\n```kotlin\n// ‚úÖ GOOD: No Activity/Fragment references in ViewModel\nclass PaymentViewModel(\n    private val processPaymentUseCase: ProcessPaymentUseCase\n) : ViewModel() {\n\n    private val _navigationEvent = MutableSharedFlow<NavigationEvent>()\n    val navigationEvent: SharedFlow<NavigationEvent> = _navigationEvent.asSharedFlow()\n\n    fun onPaymentSuccess() {\n        viewModelScope.launch {\n            _navigationEvent.emit(NavigationEvent.ToReceipt)\n        }\n    }\n}\n\n// In Fragment\nclass PaymentFragment : Fragment() {\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.navigationEvent.collect { event ->\n                when (event) {\n                    NavigationEvent.ToReceipt -> navigateToReceipt()\n                }\n            }\n        }\n    }\n}\n\n// ‚ùå BAD: Holding Activity/Fragment reference\nclass PaymentViewModel(\n    private val fragment: PaymentFragment // Memory leak!\n) : ViewModel() {\n\n    fun onPaymentSuccess() {\n        fragment.navigateToReceipt() // Crash if Fragment destroyed!\n    }\n}\n```\n\n### Observer Lifecycle\n```kotlin\n// ‚úÖ GOOD: Use viewLifecycleOwner in Fragments\nclass PaymentFragment : Fragment() {\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        // Use viewLifecycleOwner, not this (fragment lifecycle)\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.uiState.collect { state ->\n                updateUi(state)\n            }\n        }\n    }\n}\n\n// ‚ùå BAD: Using fragment's lifecycle\nclass PaymentFragment : Fragment() {\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        // This leaks between onDestroyView and onDestroy!\n        lifecycleScope.launch {\n            viewModel.uiState.collect { state ->\n                updateUi(state) // Can crash if view is destroyed\n            }\n        }\n    }\n}\n```\n\n### Cleanup\n```kotlin\n// ‚úÖ GOOD: Proper cleanup\nclass PaymentViewModel : ViewModel() {\n\n    private val job = SupervisorJob()\n    private val scope = CoroutineScope(Dispatchers.IO + job)\n\n    override fun onCleared() {\n        super.onCleared()\n        job.cancel()\n    }\n}\n\n// ‚ùå BAD: No cleanup\nclass PaymentViewModel : ViewModel() {\n\n    private val scope = CoroutineScope(Dispatchers.IO)\n\n    // No cleanup - scope keeps running!\n}\n```\n\n## 6. Security Best Practices\n\n### Secure Storage\n```kotlin\n// ‚úÖ GOOD: Encrypted storage for sensitive data\nclass SecurePreferences(context: Context) {\n\n    private val masterKey = MasterKey.Builder(context)\n        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n        .build()\n\n    private val encryptedPrefs = EncryptedSharedPreferences.create(\n        context,\n        \"secure_prefs\",\n        masterKey,\n        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n    )\n\n    fun saveToken(token: String) {\n        encryptedPrefs.edit {\n            putString(KEY_AUTH_TOKEN, token)\n        }\n    }\n}\n\n// ‚ùå BAD: Plain SharedPreferences for sensitive data\nclass Preferences(context: Context) {\n\n    private val prefs = context.getSharedPreferences(\"app_prefs\", Context.MODE_PRIVATE)\n\n    fun saveToken(token: String) {\n        prefs.edit {\n            putString(\"auth_token\", token) // Plain text!\n        }\n    }\n}\n```\n\n### API Keys\n```kotlin\n// ‚úÖ GOOD: API keys in gradle.properties (not checked in) and BuildConfig\n// gradle.properties (add to .gitignore)\nAPI_KEY=your_secret_key_here\nAPI_BASE_URL=https://api.payoo.vn\n\n// build.gradle.kts\nandroid {\n    defaultConfig {\n        buildConfigField(\"String\", \"API_KEY\", \"\\\"${project.findProperty(\"API_KEY\")}\\\"\")\n        buildConfigField(\"String\", \"API_BASE_URL\", \"\\\"${project.findProperty(\"API_BASE_URL\")}\\\"\")\n    }\n}\n\n// Usage\nclass ApiClient {\n    private val apiKey = BuildConfig.API_KEY\n    private val baseUrl = BuildConfig.API_BASE_URL\n}\n\n// ‚ùå BAD: Hardcoded API keys\nclass ApiClient {\n    private val apiKey = \"sk_live_1234567890abcdef\" // Exposed in code!\n    private val baseUrl = \"https://api.payoo.vn\"\n}\n```\n\n### Logging\n```kotlin\n// ‚úÖ GOOD: No sensitive data in logs, conditional logging\nclass PaymentLogger {\n\n    fun logPayment(request: PaymentRequest) {\n        if (BuildConfig.DEBUG) {\n            Log.d(TAG, \"Processing payment for merchant: ${request.merchantId}\")\n            Log.d(TAG, \"Amount: ${request.amount.setScale(2)}\")\n            // NO card numbers, tokens, or PII\n        }\n    }\n}\n\n// ‚ùå BAD: Logging sensitive data\nclass PaymentLogger {\n\n    fun logPayment(request: PaymentRequest) {\n        Log.d(TAG, \"Payment: $request\") // Might contain sensitive data!\n        Log.d(TAG, \"Token: ${request.authToken}\") // Exposed in logs!\n        Log.d(TAG, \"Card: ${request.cardNumber}\") // PCI violation!\n    }\n}\n```\n\n## 7. Performance Optimization\n\n### Background Work\n```kotlin\n// ‚úÖ GOOD: Network/DB on background thread\nclass PaymentRepository(\n    private val api: PaymentApi,\n    private val dao: PaymentDao,\n    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO\n) {\n\n    suspend fun syncPayments() = withContext(ioDispatcher) {\n        val remotePayments = api.fetchPayments()\n        dao.deleteAll()\n        dao.insertAll(remotePayments.map { it.toEntity() })\n    }\n}\n\n// ‚ùå BAD: Blocking Main thread\nclass PaymentRepository(\n    private val api: PaymentApi,\n    private val dao: PaymentDao\n) {\n\n    fun syncPayments() {\n        // Blocking Main thread!\n        val remotePayments = api.fetchPayments().execute()\n        dao.deleteAll()\n        dao.insertAll(remotePayments.map { it.toEntity() })\n    }\n}\n```\n\n### RecyclerView Optimization\n```kotlin\n// ‚úÖ GOOD: DiffUtil for efficient updates\nclass PaymentAdapter : ListAdapter<Payment, PaymentViewHolder>(PaymentDiffCallback()) {\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PaymentViewHolder {\n        val binding = ItemPaymentBinding.inflate(\n            LayoutInflater.from(parent.context),\n            parent,\n            false\n        )\n        return PaymentViewHolder(binding)\n    }\n\n    override fun onBindViewHolder(holder: PaymentViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n}\n\nclass PaymentDiffCallback : DiffUtil.ItemCallback<Payment>() {\n    override fun areItemsTheSame(oldItem: Payment, newItem: Payment) =\n        oldItem.id == newItem.id\n\n    override fun areContentsTheSame(oldItem: Payment, newItem: Payment) =\n        oldItem == newItem\n}\n\n// ‚ùå BAD: notifyDataSetChanged for all updates\nclass PaymentAdapter : RecyclerView.Adapter<PaymentViewHolder>() {\n\n    private var payments: List<Payment> = emptyList()\n\n    fun updatePayments(newPayments: List<Payment>) {\n        payments = newPayments\n        notifyDataSetChanged() // Inefficient!\n    }\n}\n```\n\n### Image Loading\n```kotlin\n// ‚úÖ GOOD: Coil/Glide with proper caching\nclass ImageLoader(private val context: Context) {\n\n    fun loadImage(imageView: ImageView, url: String) {\n        imageView.load(url) {\n            crossfade(true)\n            placeholder(R.drawable.placeholder)\n            error(R.drawable.error)\n            transformations(CircleCropTransformation())\n            memoryCachePolicy(CachePolicy.ENABLED)\n            diskCachePolicy(CachePolicy.ENABLED)\n        }\n    }\n}\n\n// ‚ùå BAD: Loading images without caching\nclass ImageLoader {\n\n    suspend fun loadImage(imageView: ImageView, url: String) {\n        val bitmap = withContext(Dispatchers.IO) {\n            URL(url).openStream().use { stream ->\n                BitmapFactory.decodeStream(stream) // No caching, inefficient!\n            }\n        }\n        imageView.setImageBitmap(bitmap)\n    }\n}\n```\n\n### Database Optimization\n```kotlin\n// ‚úÖ GOOD: Indexed queries, efficient types\n@Entity(\n    tableName = \"payments\",\n    indices = [\n        Index(value = [\"merchantId\"]),\n        Index(value = [\"timestamp\"])\n    ]\n)\ndata class PaymentEntity(\n    @PrimaryKey val id: String,\n    val merchantId: String,\n    val amount: Long, // Store cents, not BigDecimal\n    val timestamp: Long,\n    val status: String\n)\n\n@Dao\ninterface PaymentDao {\n\n    @Query(\"SELECT * FROM payments WHERE merchantId = :merchantId AND timestamp > :after ORDER BY timestamp DESC\")\n    fun getPaymentsByMerchant(merchantId: String, after: Long): Flow<List<PaymentEntity>>\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertAll(payments: List<PaymentEntity>)\n}\n\n// ‚ùå BAD: No indexes, inefficient queries\n@Entity(tableName = \"payments\")\ndata class PaymentEntity(\n    @PrimaryKey val id: String,\n    val merchantId: String,\n    val amount: BigDecimal, // Not supported by Room!\n    val timestamp: Long,\n    val status: String\n)\n\n@Dao\ninterface PaymentDao {\n\n    @Query(\"SELECT * FROM payments\")\n    fun getAllPayments(): List<PaymentEntity> // Load all, then filter!\n}\n```\n\n## 8. Dependency Injection\n\n### Hilt/Dagger Setup\n```kotlin\n// ‚úÖ GOOD: Proper DI with Hilt\n@HiltAndroidApp\nclass PayooApplication : Application()\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n\n    @Provides\n    @Singleton\n    fun provideOkHttpClient(): OkHttpClient {\n        return OkHttpClient.Builder()\n            .addInterceptor(AuthInterceptor())\n            .connectTimeout(30, TimeUnit.SECONDS)\n            .build()\n    }\n\n    @Provides\n    @Singleton\n    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(BuildConfig.API_BASE_URL)\n            .client(okHttpClient)\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n\n    @Provides\n    @Singleton\n    fun providePaymentApi(retrofit: Retrofit): PaymentApi {\n        return retrofit.create(PaymentApi::class.java)\n    }\n}\n\n@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n\n    @Binds\n    @Singleton\n    abstract fun bindPaymentRepository(\n        impl: PaymentRepositoryImpl\n    ): PaymentRepository\n}\n\n@AndroidEntryPoint\nclass PaymentActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var viewModelFactory: PaymentViewModelFactory\n}\n\n// ‚ùå BAD: Manual instantiation, singletons\nobject ApiClient {\n    val instance: PaymentApi by lazy {\n        Retrofit.Builder()\n            .baseUrl(\"https://api.payoo.vn\")\n            .build()\n            .create(PaymentApi::class.java)\n    }\n}\n\nclass PaymentViewModel {\n    private val repository = PaymentRepository(ApiClient.instance) // Tight coupling!\n}\n```\n\n---\n\n## Summary Checklist\n\nUse this checklist during code reviews:\n\n### Naming ‚úÖ\n- [ ] Classes/Interfaces in PascalCase\n- [ ] Variables/Functions in camelCase\n- [ ] Constants in UPPER_SNAKE_CASE\n- [ ] Boolean variables prefixed (is, has, should, can)\n- [ ] No unclear abbreviations\n\n### Kotlin ‚úÖ\n- [ ] Null safety properly handled\n- [ ] Data classes for DTOs/models\n- [ ] Sealed classes for states\n- [ ] Prefer val over var\n- [ ] Extension functions where appropriate\n\n### Coroutines ‚úÖ\n- [ ] Proper scope usage (viewModelScope, lifecycleScope)\n- [ ] Correct dispatchers (IO for network/DB, Main for UI)\n- [ ] Error handling in all coroutines\n- [ ] Flows for reactive data\n- [ ] No runBlocking in production\n\n### Architecture ‚úÖ\n- [ ] Clear layer separation (Presentation/Domain/Data)\n- [ ] ViewModels use UseCases\n- [ ] UseCases contain business logic\n- [ ] Repositories abstract data sources\n- [ ] Dependency injection configured\n\n### Lifecycle ‚úÖ\n- [ ] No Activity/Fragment references in ViewModel\n- [ ] viewLifecycleOwner in Fragments\n- [ ] Proper cleanup in onCleared\n- [ ] Configuration changes handled\n\n### Security ‚úÖ\n- [ ] EncryptedSharedPreferences for sensitive data\n- [ ] No hardcoded API keys/secrets\n- [ ] No sensitive data in logs\n- [ ] HTTPS only\n- [ ] Input validation\n\n### Performance ‚úÖ\n- [ ] Network/DB on background threads\n- [ ] No memory leaks\n- [ ] DiffUtil in RecyclerView\n- [ ] Image caching (Coil/Glide)\n- [ ] Database queries optimized\n\nThis comprehensive standards document provides detailed guidance for Android code reviews in the Payoo Android application.\n",
        "py-plugin/skills/clean-architecture-review/SKILL.md": "---\nname: clean-architecture-review\ndescription: Validate Clean Architecture implementation in iOS. Checks layer separation (Presentation/Domain/Data), MVVM patterns, dependency injection with Swinject, and UseCase/Repository patterns. Use when reviewing architecture, checking layer boundaries, or validating DI.\nallowed-tools: Read, Grep, Glob\n---\n\n# Clean Architecture Validator\n\nVerify Clean Architecture and MVVM implementation in iOS code following Payoo Merchant patterns.\n\n## When to Activate\n\n- \"architecture review\", \"layer separation\", \"clean architecture\"\n- \"MVVM\", \"dependency injection\", \"DI\"\n- \"use case\", \"repository pattern\"\n- Reviewing module structure or refactoring\n\n## Architecture Layers\n\n**Presentation** ‚Üí ViewControllers, ViewModels, Views\n**Domain** ‚Üí UseCases (business logic), Models, Repository protocols\n**Data** ‚Üí Repository implementations, API Services, Local Storage\n\n**Correct Flow**:\n```\nUI ‚Üí ViewController ‚Üí ViewModel ‚Üí UseCase ‚Üí Repository ‚Üí API/DB\n```\n\n## Review Process\n\n### Step 1: Map Architecture\n\nClassify files into layers:\n- Presentation: `*ViewController.swift`, `*ViewModel.swift`\n- Domain: `*UseCase.swift`, `*Repository.swift` (protocols)\n- Data: `*RepositoryImpl.swift`, `*ApiService.swift`\n\n### Step 2: Check Layer Violations\n\n**Critical Issues**:\n- üî¥ ViewModel calling API directly (bypassing UseCase)\n- üî¥ Business logic in ViewModel (should be in UseCase)\n- üî¥ UseCase calling API directly (bypassing Repository)\n- üî¥ Direct instantiation (no DI)\n\n### Step 3: Verify Patterns\n\n**BaseViewModel**:\n```swift\n‚úÖ class PaymentViewModel: BaseViewModel<PaymentState>\n‚ùå class PaymentViewModel  // Should extend BaseViewModel\n```\n\n**UseCase Pattern**:\n```swift\n‚úÖ protocol PaymentUseCase { }\n‚úÖ class PaymentUseCaseImpl: PaymentUseCase { }\n‚ùå class PaymentUseCase { }  // Should be protocol + impl\n```\n\n**Repository Pattern**:\n```swift\n‚úÖ protocol PaymentRepository { }  // In Domain\n‚úÖ class PaymentRepositoryImpl: PaymentRepository { }  // In Data\n```\n\n**Dependency Injection**:\n```swift\n‚úÖ init(paymentUC: PaymentUseCase) {  // Constructor injection\n    self.paymentUC = paymentUC\n}\n‚ùå let paymentUC = PaymentUseCaseImpl()  // Direct instantiation\n```\n\n### Step 4: Generate Report\n\nProvide:\n- Architecture compliance score\n- Layer violations by severity\n- Current vs. should-be architecture\n- Refactoring steps\n- Effort estimate\n\n## Common Violations\n\n### ‚ùå ViewModel Bypassing UseCase\n```swift\nclass PaymentViewModel {\n    private let apiService: PaymentApiService  // WRONG LAYER!\n}\n```\n**Should be**:\n```swift\nclass PaymentViewModel {\n    private let paymentUC: PaymentUseCase  // CORRECT!\n}\n```\n\n### ‚ùå Business Logic in ViewModel\n```swift\nclass PaymentViewModel {\n    func processPayment(amount: Double) {\n        // ‚ùå Validation in ViewModel\n        guard amount > 1000 else { return }\n        // ‚ùå Business rules in ViewModel\n        let fee = amount * 0.01\n    }\n}\n```\n**Should be in UseCase**:\n```swift\nclass PaymentUseCaseImpl {\n    func execute(amount: Double) -> Single<PaymentResult> {\n        // ‚úÖ Validation in UseCase\n        return validateAmount(amount)\n            .flatMap { processPayment($0) }\n    }\n}\n```\n\n## Output Format\n\n```markdown\n# Clean Architecture Review\n\n## Compliance Score: X/100\n\n## Critical Violations: X\n\n### 1. ViewModel Bypassing UseCase\n**File**: `PaymentViewModel.swift:15`\n**Current**: ViewModel ‚Üí API\n**Should be**: ViewModel ‚Üí UseCase ‚Üí Repository ‚Üí API\n\n**Fix**: [Refactoring steps]\n\n---\n\n## Dependency Graph\n\n### Current (Problematic)\nViewModel ‚Üí ApiService ‚ùå\n\n### Should Be\nViewModel ‚Üí UseCase ‚Üí Repository ‚Üí ApiService ‚úÖ\n\n## Recommendations\n1. Create missing UseCases\n2. Move business logic to Domain layer\n3. Setup DI container\n4. Add Repository layer\n\n## Effort Estimate\n- Module refactoring: X hours\n- DI setup: X hours\n- Testing: X hours\n```\n\n## Quick Checks\n\n**Layer Boundaries**:\n- [ ] ViewModels only depend on UseCases\n- [ ] UseCases contain all business logic\n- [ ] Repositories handle data access only\n- [ ] No UI code in Domain/Data layers\n\n**Dependency Injection**:\n- [ ] All dependencies via constructor\n- [ ] No direct instantiation\n- [ ] Swinject container registration\n- [ ] Protocol-based dependencies\n\n**Patterns**:\n- [ ] ViewModels extend BaseViewModel\n- [ ] UseCases follow protocol + impl\n- [ ] Repositories follow protocol + impl\n- [ ] State management via setState()\n\n## Reference\n\n**Detailed Examples**: See `examples.md` for complete architecture patterns and refactoring guides.\n",
        "py-plugin/skills/clean-architecture-review/examples.md": "# Clean Architecture Examples\n\nComplete examples of proper layer separation, MVVM patterns, and dependency injection.\n\n## Complete Architecture Example\n\n### Proper 3-Layer Implementation\n\n#### Presentation Layer - ViewModel\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    // ‚úÖ Depends only on UseCase (Domain layer)\n    private let paymentUC: PaymentUseCase\n    private let disposeBag = DisposeBag()\n\n    // UI State\n    let paymentAmount = BehaviorRelay<String>(value: \"\")\n    let isProcessing = BehaviorRelay<Bool>(value: false)\n\n    // ‚úÖ Constructor injection\n    init(paymentUC: PaymentUseCase) {\n        self.paymentUC = paymentUC\n        super.init()\n    }\n\n    func processPayment() {\n        isProcessing.accept(true)\n\n        // ‚úÖ Delegates to UseCase, no business logic here\n        paymentUC.execute(amount: paymentAmount.value)\n            .subscribeOn(ConcurrentScheduler.background)\n            .observeOn(MainScheduler.instance)\n            .subscribe(\n                onNext: { [weak self] result in\n                    self?.setState(.success(result))\n                },\n                onError: { [weak self] error in\n                    self?.setState(.error(error))\n                },\n                onCompleted: { [weak self] in\n                    self?.isProcessing.accept(false)\n                }\n            )\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n#### Domain Layer - UseCase\n```swift\n// ‚úÖ Protocol in Domain layer\nprotocol PaymentUseCase {\n    func execute(amount: String) -> Single<PaymentResult>\n}\n\n// ‚úÖ Implementation in Domain layer\nclass PaymentUseCaseImpl: PaymentUseCase {\n    // ‚úÖ Depends on Repository protocol (Domain layer)\n    private let paymentRepository: PaymentRepository\n    private let validationService: ValidationService\n\n    init(paymentRepository: PaymentRepository,\n         validationService: ValidationService) {\n        self.paymentRepository = paymentRepository\n        self.validationService = validationService\n    }\n\n    func execute(amount: String) -> Single<PaymentResult> {\n        // ‚úÖ Business logic in UseCase\n        return validationService.validateAmount(amount)\n            .flatMap { validatedAmount in\n                // ‚úÖ Calls Repository, not API directly\n                return self.paymentRepository.processPayment(amount: validatedAmount)\n            }\n            .map { response in\n                // ‚úÖ Business rules applied here\n                return self.applyBusinessRules(response)\n            }\n    }\n\n    private func applyBusinessRules(_ response: PaymentResponse) -> PaymentResult {\n        // Business logic here\n        return PaymentResult(from: response)\n    }\n}\n```\n\n#### Data Layer - Repository\n```swift\n// ‚úÖ Protocol in Domain layer\nprotocol PaymentRepository {\n    func processPayment(amount: Double) -> Single<PaymentResponse>\n}\n\n// ‚úÖ Implementation in Data layer\nclass PaymentRepositoryImpl: PaymentRepository {\n    private let apiService: PaymentApiService\n    private let localStorage: PaymentLocalStorage\n\n    init(apiService: PaymentApiService, localStorage: PaymentLocalStorage) {\n        self.apiService = apiService\n        self.localStorage = localStorage\n    }\n\n    func processPayment(amount: Double) -> Single<PaymentResponse> {\n        // ‚úÖ Data access only, no business logic\n        return apiService.processPayment(amount: amount)\n            .do(onSuccess: { [weak self] response in\n                // Save to local storage\n                self?.localStorage.savePaymentRecord(response)\n            })\n    }\n}\n```\n\n#### DI Setup - Swinject\n```swift\nextension Container {\n    func registerPaymentModule() {\n        // Register Use Cases\n        register(PaymentUseCase.self) { resolver in\n            PaymentUseCaseImpl(\n                paymentRepository: resolver.resolve(PaymentRepository.self)!,\n                validationService: resolver.resolve(ValidationService.self)!\n            )\n        }\n\n        // Register Repositories\n        register(PaymentRepository.self) { resolver in\n            PaymentRepositoryImpl(\n                apiService: resolver.resolve(PaymentApiService.self)!,\n                localStorage: resolver.resolve(PaymentLocalStorage.self)!\n            )\n        }\n\n        // Register ViewModels\n        register(PaymentViewModel.self) { resolver in\n            PaymentViewModel(\n                paymentUC: resolver.resolve(PaymentUseCase.self)!\n            )\n        }\n    }\n}\n```\n\n---\n\n## Common Anti-Patterns\n\n### ‚ùå Anti-Pattern 1: ViewModel Calling API Directly\n\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let apiService: PaymentApiService  // ‚ùå Wrong layer!\n\n    func processPayment(amount: Double) {\n        // ‚ùå Direct API call bypasses business logic\n        apiService.processPayment(amount: amount)\n            .subscribe(onNext: { result in\n                // Handle result\n            })\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n**Problems**:\n- Business logic scattered or missing\n- Hard to test\n- Violates layer separation\n- Cannot reuse logic elsewhere\n\n**Fix**: Add UseCase layer\n```swift\n// 1. Create UseCase\nprotocol PaymentUseCase {\n    func execute(amount: Double) -> Single<PaymentResult>\n}\n\n// 2. Update ViewModel\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let paymentUC: PaymentUseCase  // ‚úÖ Correct!\n\n    func processPayment(amount: Double) {\n        paymentUC.execute(amount: amount)  // ‚úÖ Through UseCase\n            .subscribe(/* ... */)\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n---\n\n### ‚ùå Anti-Pattern 2: Business Logic in ViewModel\n\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    func processPayment(amount: String) {\n        // ‚ùå Validation logic in ViewModel\n        guard let amt = Double(amount), amt > 1000 else {\n            setState(.showError(\"Invalid amount\"))\n            return\n        }\n\n        // ‚ùå Business rules in ViewModel\n        let fee = amt * 0.01\n        let total = amt + fee\n\n        if total > 50_000_000 {\n            setState(.showError(\"Amount too high\"))\n            return\n        }\n\n        // Process...\n    }\n}\n```\n\n**Problems**:\n- Cannot reuse validation/business logic\n- Hard to test logic independently\n- ViewModel becomes complex\n- Violates Single Responsibility\n\n**Fix**: Move to UseCase\n```swift\n// ‚úÖ Business logic in UseCase\nclass PaymentUseCaseImpl: PaymentUseCase {\n    func execute(amount: String) -> Single<PaymentResult> {\n        return validateAmount(amount)\n            .flatMap { validatedAmount in\n                return self.calculateFeesAndProcess(validatedAmount)\n            }\n    }\n\n    private func validateAmount(_ amount: String) -> Single<Double> {\n        guard let amt = Double(amount), amt > 1000 else {\n            return .error(PaymentError.invalidAmount)\n        }\n\n        let fee = amt * 0.01\n        let total = amt + fee\n\n        guard total <= 50_000_000 else {\n            return .error(PaymentError.amountTooHigh)\n        }\n\n        return .just(amt)\n    }\n}\n\n// ‚úÖ ViewModel simplified\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    func processPayment(amount: String) {\n        paymentUC.execute(amount: amount)\n            .subscribe(\n                onNext: { [weak self] result in\n                    self?.setState(.success(result))\n                },\n                onError: { [weak self] error in\n                    self?.setState(.error(error))\n                }\n            )\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n---\n\n### ‚ùå Anti-Pattern 3: UseCase Calling API Directly\n\n```swift\nclass PaymentUseCaseImpl: PaymentUseCase {\n    private let apiService: PaymentApiService  // ‚ùå Bypasses Repository!\n\n    func execute(amount: Double) -> Single<PaymentResult> {\n        // ‚ùå Direct API call\n        return apiService.processPayment(amount: amount)\n            .map { response in\n                return PaymentResult(from: response)\n            }\n    }\n}\n```\n\n**Problems**:\n- Cannot swap data sources (API/local/mock)\n- Hard to test independently\n- Violates Dependency Inversion\n\n**Fix**: Add Repository layer\n```swift\n// ‚úÖ Repository protocol in Domain\nprotocol PaymentRepository {\n    func processPayment(amount: Double) -> Single<PaymentResponse>\n}\n\n// ‚úÖ UseCase depends on protocol\nclass PaymentUseCaseImpl: PaymentUseCase {\n    private let paymentRepository: PaymentRepository  // ‚úÖ Correct!\n\n    func execute(amount: Double) -> Single<PaymentResult> {\n        return paymentRepository.processPayment(amount: amount)\n            .map { response in\n                return PaymentResult(from: response)\n            }\n    }\n}\n\n// ‚úÖ Implementation in Data layer\nclass PaymentRepositoryImpl: PaymentRepository {\n    private let apiService: PaymentApiService\n\n    func processPayment(amount: Double) -> Single<PaymentResponse> {\n        return apiService.processPayment(amount: amount)\n    }\n}\n```\n\n---\n\n## Refactoring Examples\n\n### Example: Refactoring ViewModel with Business Logic\n\n#### Before (Violates Clean Architecture)\n```swift\nclass TransactionViewModel: BaseViewModel<TransactionState> {\n    private let apiService: TransactionApiService\n\n    func loadTransactions(from startDate: Date, to endDate: Date) {\n        // ‚ùå Date validation in ViewModel\n        guard startDate <= endDate else {\n            setState(.showError(\"Invalid date range\"))\n            return\n        }\n\n        // ‚ùå Business rule in ViewModel\n        let daysDiff = Calendar.current.dateComponents([.day], from: startDate, to: endDate).day!\n        guard daysDiff <= 90 else {\n            setState(.showError(\"Date range too large\"))\n            return\n        }\n\n        // ‚ùå Direct API call\n        apiService.getTransactions(from: startDate, to: endDate)\n            .subscribe(onNext: { [weak self] transactions in\n                // ‚ùå Business logic: filtering\n                let filtered = transactions.filter { $0.amount > 0 }\n                self?.transactions.accept(filtered)\n            })\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n#### After (Clean Architecture)\n```swift\n// DOMAIN LAYER - UseCase\nprotocol TransactionUseCase {\n    func getTransactions(from: Date, to: Date) -> Single<[Transaction]>\n}\n\nclass TransactionUseCaseImpl: TransactionUseCase {\n    private let repository: TransactionRepository\n\n    func getTransactions(from startDate: Date, to endDate: Date) -> Single<[Transaction]> {\n        // ‚úÖ Validation in UseCase\n        return validateDateRange(startDate, endDate)\n            .flatMap { _ in\n                return self.repository.getTransactions(from: startDate, to: endDate)\n            }\n            .map { transactions in\n                // ‚úÖ Business logic in UseCase\n                return self.filterValidTransactions(transactions)\n            }\n    }\n\n    private func validateDateRange(_ start: Date, _ end: Date) -> Single<Void> {\n        guard start <= end else {\n            return .error(TransactionError.invalidDateRange)\n        }\n\n        let daysDiff = Calendar.current.dateComponents([.day], from: start, to: end).day!\n        guard daysDiff <= 90 else {\n            return .error(TransactionError.dateRangeTooLarge)\n        }\n\n        return .just(())\n    }\n\n    private func filterValidTransactions(_ transactions: [Transaction]) -> [Transaction] {\n        return transactions.filter { $0.amount > 0 }\n    }\n}\n\n// PRESENTATION LAYER - ViewModel\nclass TransactionViewModel: BaseViewModel<TransactionState> {\n    private let transactionUC: TransactionUseCase  // ‚úÖ Depends on UseCase\n\n    func loadTransactions(from startDate: Date, to endDate: Date) {\n        // ‚úÖ Simply delegates to UseCase\n        transactionUC.getTransactions(from: startDate, to: endDate)\n            .subscribe(\n                onNext: { [weak self] transactions in\n                    self?.transactions.accept(transactions)\n                    self?.setState(.loaded)\n                },\n                onError: { [weak self] error in\n                    self?.setState(.error(error))\n                }\n            )\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n**Benefits**:\n- ‚úÖ Clear separation of concerns\n- ‚úÖ Business logic testable in isolation\n- ‚úÖ ViewModel is simple coordinator\n- ‚úÖ Can reuse UseCase elsewhere\n\n---\n\n## Testing Benefits\n\n### With Clean Architecture\n\n```swift\nclass PaymentUseCaseTests: XCTestCase {\n    func testExecute_WithValidAmount_ProcessesPayment() {\n        // ‚úÖ Can test UseCase in isolation\n        let mockRepository = MockPaymentRepository()\n        mockRepository.processPaymentResult = .just(PaymentResponse.success)\n\n        let useCase = PaymentUseCaseImpl(paymentRepository: mockRepository)\n\n        // Test business logic directly\n        let result = try! useCase.execute(amount: \"10000\").toBlocking().first()!\n        XCTAssertTrue(result.isSuccess)\n    }\n\n    func testExecute_WithInvalidAmount_ReturnsError() {\n        let mockRepository = MockPaymentRepository()\n        let useCase = PaymentUseCaseImpl(paymentRepository: mockRepository)\n\n        // Test validation logic\n        XCTAssertThrowsError(\n            try useCase.execute(amount: \"500\").toBlocking().first()\n        ) { error in\n            XCTAssertEqual(error as? PaymentError, .invalidAmount)\n        }\n    }\n}\n```\n\n### Without Clean Architecture\n\n```swift\n// ‚ùå Hard to test business logic without UI/Network\nclass PaymentViewModelTests: XCTestCase {\n    func testProcessPayment() {\n        // Need to mock UI, network, and test everything together\n        // Business logic mixed with presentation logic\n        // Hard to isolate what's being tested\n    }\n}\n```\n\n---\n\n## Checklist for Reviews\n\n```markdown\n## Clean Architecture Checklist\n\n### Layer Separation\n- [ ] ViewModel only depends on UseCase (not API/Repository)\n- [ ] UseCase contains all business logic\n- [ ] UseCase only depends on Repository protocol\n- [ ] Repository implementation is in Data layer\n- [ ] No business logic in ViewModel\n- [ ] No business logic in Repository\n- [ ] No UI code in Domain/Data layers\n\n### Patterns\n- [ ] ViewModel extends BaseViewModel<State>\n- [ ] UseCase follows protocol + implementation pattern\n- [ ] Repository follows protocol + implementation pattern\n- [ ] State management uses setState()\n\n### Dependency Injection\n- [ ] All dependencies injected via constructor\n- [ ] No direct instantiation of dependencies\n- [ ] Swinject container properly configured\n- [ ] Dependencies are protocol-based (not concrete types)\n\n### Data Flow\n- [ ] UI ‚Üí ViewController ‚Üí ViewModel ‚Üí UseCase ‚Üí Repository ‚Üí API/DB\n- [ ] Never skips layers\n- [ ] Observables/Singles for async operations\n- [ ] Errors properly propagated through layers\n```\n",
        "py-plugin/skills/copilot-agent-builder/SKILL.md": "---\nname: copilot-agent-builder\ndescription: Generate custom GitHub Copilot agents (.agent.md files) for VS Code with proper YAML frontmatter, tools configuration, and handoff workflows. Use when \"create copilot agent\", \"generate github copilot agent\", \"new copilot agent for\", \"make a copilot agent\", or \"build copilot agent\".\nallowed-tools: Read, Write, Glob, Bash, AskUserQuestion\n---\n\n# GitHub Copilot Agent Builder\n\nGenerate custom GitHub Copilot agents following VS Code's `.agent.md` format with proper YAML frontmatter and markdown instructions.\n\n## When to Activate\n\nTrigger this skill when user says:\n- \"create copilot agent\"\n- \"generate github copilot agent\"\n- \"new copilot agent for [purpose]\"\n- \"make a copilot agent\"\n- \"build copilot agent\"\n- \"copilot custom agent\"\n\n## Agent Creation Process\n\n### Step 1: Gather Requirements\n\nAsk user for agent configuration:\n\n1. **Agent Purpose & Name**:\n   - What should the agent do? (e.g., \"plan features\", \"review security\", \"write tests\")\n   - Suggested name: Extract from purpose (e.g., \"planner\", \"security-reviewer\", \"test-writer\")\n\n2. **Tools Selection** (multi-select):\n   - `fetch` - Retrieve web content and documentation\n   - `search` - Search codebase and files\n   - `githubRepo` - Access GitHub repository data\n   - `usages` - Find code references and usage patterns\n   - `files` - File operations\n   - Custom tools if available\n\n3. **Handoff Workflows** (optional):\n   - Should this agent hand off to another? (e.g., planner ‚Üí coder)\n   - Handoff agent name\n   - Handoff prompt text\n   - Auto-send handoff? (yes/no)\n\n4. **Additional Configuration** (optional):\n   - Specific model to use?\n   - Argument hint for users?\n\n### Step 2: Validate Directory Structure\n\n```bash\n# Ensure .github/agents directory exists\nmkdir -p .github/agents\n```\n\n### Step 3: Generate Agent File\n\nCreate `.github/agents/{agent-name}.agent.md` with:\n\n**YAML Frontmatter Structure**:\n```yaml\n---\ndescription: [Brief overview shown in chat input]\nname: [Agent identifier, lowercase with hyphens]\ntools: [Array of tool names]\nhandoffs:  # Optional\n  - label: [Button text]\n    agent: [Target agent name]\n    prompt: [Handoff message]\n    send: [true/false - auto-submit?]\nmodel: [Optional - specific model name]\nargument-hint: [Optional - user guidance text]\n---\n```\n\n**Markdown Body**:\n- Clear role definition\n- Specific instructions\n- Tool usage guidance (reference as `#tool:toolname`)\n- Output format expectations\n- Constraints and guidelines\n\n### Step 4: Validate Format\n\nEnsure generated file has:\n- ‚úì Valid YAML frontmatter with `---` delimiters\n- ‚úì All required fields (description, name)\n- ‚úì Tools array properly formatted\n- ‚úì Handoffs array if specified (with label, agent, prompt, send)\n- ‚úì Markdown instructions that are clear and actionable\n\n### Step 5: Confirm Creation\n\nShow user:\n```markdown\n‚úÖ GitHub Copilot Agent Created\n\nüìÅ Location: `.github/agents/{name}.agent.md`\nüéØ Agent: {name}\nüìù Description: {description}\nüõ†Ô∏è  Tools: {tools list}\n\nTo use:\n1. Reload VS Code window (Cmd/Ctrl + Shift + P ‚Üí \"Reload Window\")\n2. Open GitHub Copilot Chat\n3. Type `@{name}` to invoke your custom agent\n\n{If handoffs configured: \"This agent can hand off to: {handoff targets}\"}\n```\n\n## Output Format\n\nAfter creation, provide:\n\n1. **File path confirmation**\n2. **Configuration summary** (name, description, tools, handoffs)\n3. **Usage instructions** (how to reload and use)\n4. **Next steps** (testing suggestions)\n\n## Reference Documentation\n\n- Templates and structures ‚Üí `templates.md`\n- Real-world examples ‚Üí `examples.md`\n\n## Important Guidelines\n\n1. **Naming Convention**: Use lowercase with hyphens (e.g., `feature-planner`, `security-reviewer`)\n2. **Description**: Brief (1-2 sentences), shown in chat input UI\n3. **Tools**: Only include tools the agent actually needs\n4. **Handoffs**: Enable multi-step workflows (planning ‚Üí implementation ‚Üí testing)\n5. **Instructions**: Be specific about what the agent should and shouldn't do\n6. **Tool References**: Use `#tool:toolname` syntax in markdown body\n\n## Common Agent Patterns\n\n**Planning Agent**:\n- Tools: `fetch`, `search`, `githubRepo`, `usages`\n- Handoff: To implementation agent\n- Focus: Analysis and planning, no code edits\n\n**Implementation Agent**:\n- Tools: `search`, `files`, `usages`\n- Handoff: To testing agent\n- Focus: Write and modify code\n\n**Review Agent**:\n- Tools: `search`, `githubRepo`, `usages`\n- Handoff: Back to implementation for fixes\n- Focus: Quality, security, performance checks\n\n**Testing Agent**:\n- Tools: `search`, `files`\n- Handoff: Back to implementation or to review\n- Focus: Test creation and validation\n\n---\n\n**Ready to build custom GitHub Copilot agents!**\n",
        "py-plugin/skills/copilot-agent-builder/examples.md": "# GitHub Copilot Agent Examples\n\n## Example 1: Feature Planner Agent\n\n**Use Case**: Planning new features without implementation\n\n```markdown\n---\ndescription: Analyze requirements and create detailed implementation plans\nname: feature-planner\ntools: ['fetch', 'search', 'githubRepo', 'usages']\nhandoffs:\n  - label: Start Implementation\n    agent: agent\n    prompt: Implement the feature plan outlined above step by step.\n    send: false\nmodel: gpt-4\nargument-hint: Describe the feature you want to plan\n---\n\n# Feature Planning Mode\n\nYou are in planning mode. Your goal is to analyze requirements and create comprehensive implementation plans WITHOUT making any code changes.\n\n## Process\n\n1. **Understand Requirements**: Ask clarifying questions about the feature\n2. **Research Context**: Use #tool:search to understand existing codebase patterns\n3. **Design Solution**: Create architecture and implementation approach\n4. **Plan Steps**: Break down into actionable implementation steps\n5. **Identify Risks**: Note potential challenges and dependencies\n\n## Research Tools\n\n- Use #tool:fetch to retrieve documentation for libraries or best practices\n- Use #tool:githubRepo to analyze repository structure and conventions\n- Use #tool:usages to find how similar features are implemented\n- Use #tool:search to locate relevant existing code\n\n## Output Structure\n\nCreate a plan with these sections:\n\n**Requirements Analysis**\n- Feature overview\n- User stories\n- Acceptance criteria\n\n**Technical Design**\n- Architecture decisions\n- Component interactions\n- Data flow\n\n**Implementation Plan**\n1. File structure changes needed\n2. Step-by-step implementation sequence\n3. Configuration updates\n4. Database migrations (if applicable)\n\n**Testing Strategy**\n- Unit test requirements\n- Integration test scenarios\n- Manual testing checklist\n\n**Risks & Considerations**\n- Technical challenges\n- Dependencies on other systems\n- Performance implications\n- Security considerations\n\n## Important Guidelines\n\n- **NO CODE CHANGES**: You only create plans, never implement\n- **BE SPECIFIC**: Include file paths, function names, specific changes\n- **CONSIDER CONTEXT**: Align with existing patterns and conventions\n- **IDENTIFY GAPS**: Note missing information or unclear requirements\n- **ENABLE HANDOFF**: Make plans detailed enough for another agent to implement\n\nAfter completing the plan, offer the \"Start Implementation\" handoff to transition to the coding agent.\n```\n\n## Example 2: Security Reviewer Agent\n\n**Use Case**: Security-focused code review\n\n```markdown\n---\ndescription: Review code for security vulnerabilities and best practices\nname: security-reviewer\ntools: ['search', 'githubRepo', 'usages']\nhandoffs:\n  - label: Fix Security Issues\n    agent: agent\n    prompt: Address the security vulnerabilities identified in the review.\n    send: false\n---\n\n# Security Code Review Agent\n\nYou are a security-focused code reviewer specializing in identifying vulnerabilities and enforcing security best practices.\n\n## Security Review Checklist\n\n### Input Validation\n- [ ] All user inputs are validated and sanitized\n- [ ] No SQL injection vulnerabilities\n- [ ] No command injection vulnerabilities\n- [ ] File paths are validated against directory traversal\n\n### Authentication & Authorization\n- [ ] Authentication is properly implemented\n- [ ] Authorization checks are in place\n- [ ] Session management is secure\n- [ ] Passwords are hashed (never plain text)\n- [ ] Multi-factor authentication considered\n\n### Data Protection\n- [ ] Sensitive data is encrypted at rest\n- [ ] TLS/HTTPS used for data in transit\n- [ ] No secrets in code or version control\n- [ ] PII is properly protected\n\n### Common Vulnerabilities (OWASP Top 10)\n- [ ] No XSS vulnerabilities\n- [ ] No CSRF vulnerabilities\n- [ ] No insecure deserialization\n- [ ] No XML external entity (XXE) attacks\n- [ ] Proper security headers configured\n\n### Dependencies\n- [ ] Dependencies are up to date\n- [ ] No known vulnerable dependencies\n- [ ] License compliance checked\n\n## Review Process\n\n1. Use #tool:search to scan for common vulnerability patterns\n2. Use #tool:githubRepo to check security configuration files\n3. Use #tool:usages to verify security functions are used correctly\n4. Cross-reference against OWASP Top 10 and CWE database\n\n## Output Format\n\n```markdown\n## Security Review Report\n\nüîí **Security Status**: [PASS / NEEDS ATTENTION / CRITICAL]\n\n### üî¥ Critical Vulnerabilities (Fix Immediately)\n- [ ] **File**: `path/to/file.ts:42`\n  - **Issue**: SQL Injection vulnerability\n  - **Details**: User input directly concatenated into SQL query\n  - **Fix**: Use parameterized queries\n  - **Example**:\n    ```typescript\n    // ‚ùå Vulnerable\n    const query = `SELECT * FROM users WHERE id = ${userId}`;\n\n    // ‚úÖ Secure\n    const query = 'SELECT * FROM users WHERE id = ?';\n    db.execute(query, [userId]);\n    ```\n\n### üü° Medium Priority Issues\n- [ ] **File**: `path/to/file.ts:67`\n  - **Issue**: [Description]\n  - **Fix**: [Recommendation]\n\n### ‚úÖ Security Strengths\n- Proper input validation in authentication flow\n- TLS configured correctly\n- Security headers implemented\n\n### üìä Summary\n- **Critical**: 1\n- **High**: 0\n- **Medium**: 2\n- **Low**: 3\n\n### Recommended Actions\n1. [Priority 1 action]\n2. [Priority 2 action]\n```\n\nUse \"Fix Security Issues\" handoff to address vulnerabilities.\n```\n\n## Example 3: API Documentation Generator\n\n**Use Case**: Automatic API documentation\n\n```markdown\n---\ndescription: Generate comprehensive API documentation from code\nname: api-documenter\ntools: ['search', 'files', 'githubRepo']\n---\n\n# API Documentation Generator\n\nYou are a technical writer specializing in API documentation. Generate clear, comprehensive documentation for APIs.\n\n## Documentation Process\n\n1. **Discover APIs**: Use #tool:search to find API endpoints and functions\n2. **Analyze Structure**: Use #tool:githubRepo to understand project organization\n3. **Extract Details**: Parse parameters, return types, and examples\n4. **Generate Docs**: Create structured documentation files\n\n## Documentation Format\n\nFor each API endpoint or function, document:\n\n### REST API Endpoint\n\n```markdown\n### [HTTP METHOD] `/api/endpoint/path`\n\n**Description**: [What this endpoint does]\n\n**Authentication**: [Required/Optional - Type]\n\n**Parameters**:\n| Name | Type | Required | Description |\n|------|------|----------|-------------|\n| `param1` | string | Yes | [Description] |\n| `param2` | number | No | [Description] |\n\n**Request Body**:\n```json\n{\n  \"field1\": \"value\",\n  \"field2\": 123\n}\n```\n\n**Response**:\n```json\n{\n  \"status\": \"success\",\n  \"data\": {\n    \"id\": \"123\",\n    \"name\": \"Example\"\n  }\n}\n```\n\n**Error Responses**:\n- `400 Bad Request`: Invalid parameters\n- `401 Unauthorized`: Missing or invalid authentication\n- `404 Not Found`: Resource not found\n- `500 Internal Server Error`: Server error\n\n**Example**:\n```bash\ncurl -X POST https://api.example.com/api/endpoint/path \\\n  -H \"Authorization: Bearer TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"field1\": \"value\", \"field2\": 123}'\n```\n```\n\n### Function/Method\n\n```markdown\n### `functionName(param1, param2)`\n\n**Description**: [What this function does]\n\n**Parameters**:\n- `param1` (Type): [Description]\n- `param2` (Type): [Description]\n\n**Returns**: [Return type and description]\n\n**Throws**: [Exceptions if any]\n\n**Example**:\n```typescript\nconst result = functionName('value', 42);\nconsole.log(result); // Expected output\n```\n```\n\n## Output Structure\n\nCreate documentation files following this hierarchy:\n\n```\ndocs/\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ README.md (Overview)\n‚îÇ   ‚îú‚îÄ‚îÄ authentication.md\n‚îÇ   ‚îú‚îÄ‚îÄ endpoints/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.md\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.md\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ orders.md\n‚îÇ   ‚îî‚îÄ‚îÄ errors.md\n‚îî‚îÄ‚îÄ guides/\n    ‚îú‚îÄ‚îÄ getting-started.md\n    ‚îî‚îÄ‚îÄ examples.md\n```\n\n## Guidelines\n\n- Include working code examples for all endpoints\n- Document error cases and status codes\n- Provide authentication examples\n- Show request/response examples with real data structures\n- Include rate limiting information\n- Link related endpoints\n- Keep examples up to date with code changes\n```\n\n## Example 4: Test Generator Agent\n\n**Use Case**: Automatic test creation\n\n```markdown\n---\ndescription: Generate comprehensive test suites with high coverage\nname: test-generator\ntools: ['search', 'files', 'usages']\nhandoffs:\n  - label: Run Tests\n    agent: agent\n    prompt: Execute the generated tests and report results.\n    send: true\n---\n\n# Comprehensive Test Generator\n\nYou are a testing specialist who creates thorough, maintainable test suites.\n\n## Test Generation Process\n\n1. **Analyze Code**: Use #tool:search to understand what needs testing\n2. **Find Patterns**: Use #tool:usages to see how code is used in practice\n3. **Create Tests**: Use #tool:files to generate test files\n4. **Ensure Coverage**: Cover happy paths, edge cases, and error scenarios\n\n## Test Structure\n\n### Unit Test Template\n\n```typescript\nimport { describe, it, expect, beforeEach, afterEach } from '@testing-framework';\nimport { FunctionToTest } from '../src/module';\n\ndescribe('FunctionToTest', () => {\n  let testContext: TestContext;\n\n  beforeEach(() => {\n    // Setup\n    testContext = createTestContext();\n  });\n\n  afterEach(() => {\n    // Cleanup\n    testContext.cleanup();\n  });\n\n  describe('Happy Path', () => {\n    it('should handle valid input correctly', () => {\n      const result = FunctionToTest('valid-input');\n      expect(result).toBe('expected-output');\n    });\n\n    it('should process multiple items', () => {\n      const results = FunctionToTest(['item1', 'item2']);\n      expect(results).toHaveLength(2);\n      expect(results[0]).toBeDefined();\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle empty input', () => {\n      const result = FunctionToTest('');\n      expect(result).toBe('');\n    });\n\n    it('should handle null/undefined', () => {\n      expect(() => FunctionToTest(null)).toThrow();\n      expect(() => FunctionToTest(undefined)).toThrow();\n    });\n\n    it('should handle maximum values', () => {\n      const largeInput = 'x'.repeat(10000);\n      const result = FunctionToTest(largeInput);\n      expect(result).toBeDefined();\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should throw on invalid input', () => {\n      expect(() => FunctionToTest('invalid')).toThrow('Invalid input');\n    });\n\n    it('should handle async errors gracefully', async () => {\n      await expect(\n        FunctionToTest('trigger-error')\n      ).rejects.toThrow('Expected error');\n    });\n  });\n});\n```\n\n## Test Coverage Goals\n\nCreate tests for:\n- ‚úÖ **Happy Path** (70%): Normal, expected usage\n- ‚úÖ **Edge Cases** (20%): Boundary conditions, empty values, max values\n- ‚úÖ **Error Cases** (10%): Invalid input, exceptions, failures\n\n## Test Categories\n\n### 1. Unit Tests\n- Test individual functions in isolation\n- Mock dependencies\n- Fast execution\n\n### 2. Integration Tests\n- Test component interactions\n- Use real dependencies where appropriate\n- Verify data flow\n\n### 3. API Tests\n- Test endpoints with various payloads\n- Verify status codes and responses\n- Test authentication and authorization\n\n### 4. UI Tests (if applicable)\n- Test user interactions\n- Verify rendering\n- Test accessibility\n\n## Output Format\n\n```markdown\n## Generated Test Suite\n\n### üìÅ Test Files Created\n- `tests/unit/module.test.ts` (15 test cases)\n- `tests/integration/api.test.ts` (8 test cases)\n- `tests/e2e/user-flow.test.ts` (5 test cases)\n\n### üìä Coverage Summary\n- **Total Test Cases**: 28\n- **Happy Path**: 18 tests (64%)\n- **Edge Cases**: 7 tests (25%)\n- **Error Scenarios**: 3 tests (11%)\n\n### üéØ Coverage Areas\n‚úÖ User authentication flow\n‚úÖ Data validation\n‚úÖ API error handling\n‚úÖ Edge cases (null, empty, max values)\n‚ö†Ô∏è Performance testing (manual review needed)\n\n### ‚ñ∂Ô∏è Run Tests\n```bash\n# Run all tests\nnpm test\n\n# Run specific suite\nnpm test -- tests/unit/module.test.ts\n\n# Run with coverage\nnpm test -- --coverage\n```\n\n### üìù Manual Testing Checklist\n- [ ] Performance with large datasets\n- [ ] UI responsiveness on mobile\n- [ ] Cross-browser compatibility\n```\n\nUse \"Run Tests\" handoff to execute and review results.\n```\n\n## Example 5: Migration Planner Agent\n\n**Use Case**: Planning code migrations and refactoring\n\n```markdown\n---\ndescription: Plan and guide large-scale code migrations and refactoring\nname: migration-planner\ntools: ['search', 'githubRepo', 'usages', 'fetch']\nhandoffs:\n  - label: Execute Migration\n    agent: agent\n    prompt: Execute the migration plan step by step with verification at each stage.\n    send: false\nargument-hint: Describe the migration (e.g., \"migrate from Vue 2 to Vue 3\")\n---\n\n# Migration Planning Agent\n\nYou are a migration specialist who creates detailed, safe migration plans for large-scale code changes.\n\n## Migration Planning Process\n\n### 1. Assess Current State\n- Use #tool:search to inventory existing code patterns\n- Use #tool:githubRepo to understand project structure\n- Use #tool:usages to find all usage locations\n- Use #tool:fetch to research migration guides and best practices\n\n### 2. Identify Impact\n- List all files affected\n- Identify breaking changes\n- Map dependencies\n- Estimate effort\n\n### 3. Create Migration Plan\n- Break into phases\n- Define rollback strategy\n- Plan testing approach\n- Schedule timeline\n\n### 4. Document Steps\n- Detailed step-by-step instructions\n- Verification steps\n- Rollback procedures\n\n## Migration Plan Template\n\n```markdown\n# Migration Plan: [From X to Y]\n\n## Executive Summary\n- **Scope**: [What's being migrated]\n- **Impact**: [How many files/components affected]\n- **Estimated Effort**: [Time estimate]\n- **Risk Level**: [Low/Medium/High]\n\n## Current State Analysis\n\n### Inventory\n- Total files using old pattern: [N]\n- Key dependencies: [List]\n- Breaking changes: [List]\n\n### Usage Patterns Found\n```typescript\n// Pattern 1: [Found in X files]\n// Pattern 2: [Found in Y files]\n```\n\n## Migration Strategy\n\n### Phase 1: Preparation\n1. [ ] Update dependencies\n2. [ ] Create feature flags\n3. [ ] Set up parallel testing\n4. [ ] Document current behavior\n\n### Phase 2: Incremental Migration\n1. [ ] Migrate utility functions (5 files)\n2. [ ] Migrate components (12 files)\n3. [ ] Update tests (8 files)\n4. [ ] Update documentation\n\n### Phase 3: Validation\n1. [ ] Run full test suite\n2. [ ] Perform manual testing\n3. [ ] Load testing\n4. [ ] Security review\n\n### Phase 4: Cleanup\n1. [ ] Remove old code\n2. [ ] Remove feature flags\n3. [ ] Update dependencies\n4. [ ] Archive documentation\n\n## Detailed Steps\n\n### Step 1: [Step Name]\n**Files to modify**: `file1.ts`, `file2.ts`\n**Changes**:\n```typescript\n// Before\noldPattern();\n\n// After\nnewPattern();\n```\n**Verification**:\n```bash\nnpm test -- file1.test.ts\n```\n\n## Rollback Plan\n\nIf issues occur at any phase:\n1. Revert to commit: `[hash]`\n2. Disable feature flag: `MIGRATION_ENABLED=false`\n3. Restore from backup: `backup-[date]`\n\n## Testing Strategy\n\n### Automated Tests\n- Unit tests for each migrated file\n- Integration tests for workflows\n- Regression tests for unchanged behavior\n\n### Manual Tests\n- [ ] User flow 1\n- [ ] User flow 2\n- [ ] Edge case scenarios\n\n## Risk Mitigation\n\n| Risk | Impact | Probability | Mitigation |\n|------|--------|-------------|------------|\n| Breaking change in production | High | Low | Feature flags, gradual rollout |\n| Performance degradation | Medium | Medium | Load testing before deployment |\n| Data loss | High | Low | Database backups, dry runs |\n\n## Timeline\n\n- **Week 1**: Preparation and dependency updates\n- **Week 2**: Phase 1 migration (utilities)\n- **Week 3**: Phase 2 migration (components)\n- **Week 4**: Testing and validation\n- **Week 5**: Production deployment and monitoring\n\n## Success Criteria\n\n- [ ] All tests passing\n- [ ] No performance degradation\n- [ ] Zero production incidents\n- [ ] Documentation updated\n- [ ] Team trained on new patterns\n```\n\n## Output Deliverables\n\n1. **Migration Plan Document** (as shown above)\n2. **File-by-File Checklist** (detailed change list)\n3. **Testing Scripts** (validation automation)\n4. **Rollback Procedures** (emergency recovery)\n5. **Team Communication** (stakeholder updates)\n\nUse \"Execute Migration\" handoff when ready to begin implementation.\n```\n\n---\n\n**Examples ready!** These demonstrate various agent types and configurations for different use cases.\n",
        "py-plugin/skills/copilot-agent-builder/templates.md": "# GitHub Copilot Agent Templates\n\n## Basic Agent Template\n\n```markdown\n---\ndescription: [One sentence describing what this agent does]\nname: [agent-name]\ntools: ['tool1', 'tool2', 'tool3']\n---\n\n# [Agent Name] Instructions\n\nYou are a [role description]. Your primary responsibility is to [main purpose].\n\n## Core Responsibilities\n\n1. [Responsibility 1]\n2. [Responsibility 2]\n3. [Responsibility 3]\n\n## Guidelines\n\n- [Guideline 1]\n- [Guideline 2]\n- [Guideline 3]\n\n## Tool Usage\n\n- Use #tool:search to [purpose]\n- Use #tool:fetch to [purpose]\n- Use #tool:githubRepo to [purpose]\n\n## Output Format\n\n[Describe expected output structure]\n\n## Constraints\n\n- DO: [What to do]\n- DON'T: [What to avoid]\n```\n\n## Planning Agent Template\n\n```markdown\n---\ndescription: Generate implementation plans for features and tasks\nname: planner\ntools: ['fetch', 'search', 'githubRepo', 'usages']\nhandoffs:\n  - label: Implement Plan\n    agent: coder\n    prompt: Implement the plan outlined above.\n    send: false\n---\n\n# Feature Planning Agent\n\nYou are a technical planner who creates detailed implementation plans without making code changes.\n\n## Your Role\n\nAnalyze requirements and create comprehensive implementation plans that include:\n- Architecture decisions\n- File changes needed\n- Step-by-step implementation approach\n- Potential risks and considerations\n- Testing strategy\n\n## Guidelines\n\n- **NO CODE EDITS**: Only plan, never implement\n- Use #tool:search to understand existing codebase patterns\n- Use #tool:fetch to retrieve documentation and best practices\n- Use #tool:githubRepo to analyze repository structure\n- Use #tool:usages to find how similar features are implemented\n\n## Output Format\n\n```\n## Implementation Plan\n\n### Overview\n[Brief summary]\n\n### Architecture Changes\n- [Change 1]\n- [Change 2]\n\n### Files to Modify\n1. `path/to/file1.ts` - [What to change]\n2. `path/to/file2.ts` - [What to change]\n\n### Implementation Steps\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n\n### Testing Approach\n- [Test requirement 1]\n- [Test requirement 2]\n\n### Risks & Considerations\n- [Risk 1]\n- [Risk 2]\n```\n\n## Handoff\n\nWhen ready, use the \"Implement Plan\" button to transition to the coder agent.\n```\n\n## Implementation Agent Template\n\n```markdown\n---\ndescription: Implement code changes following the provided plan\nname: coder\ntools: ['search', 'files', 'usages']\nhandoffs:\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation for quality and best practices.\n    send: false\n  - label: Write Tests\n    agent: tester\n    prompt: Create comprehensive tests for the implemented changes.\n    send: false\n---\n\n# Implementation Agent\n\nYou are a software engineer who implements code changes following best practices and the provided plan.\n\n## Your Role\n\nWrite high-quality, maintainable code that:\n- Follows the implementation plan\n- Adheres to project conventions\n- Includes proper error handling\n- Is well-documented with comments\n\n## Guidelines\n\n- Use #tool:search to understand existing code patterns\n- Use #tool:files to create and modify files\n- Use #tool:usages to ensure consistency with existing usage patterns\n- Follow the project's coding standards and conventions\n- Keep changes focused and atomic\n\n## Implementation Process\n\n1. **Understand Context**: Review the plan and existing code\n2. **Implement Changes**: Make the necessary code modifications\n3. **Add Documentation**: Include comments and docstrings\n4. **Verify Consistency**: Ensure changes align with codebase patterns\n\n## Output Format\n\nFor each file modified:\n```\n‚úÖ Modified: `path/to/file.ts`\n- [Change description 1]\n- [Change description 2]\n```\n\n## Handoffs\n\nAfter implementation:\n- **Review Code**: Have code reviewed for quality\n- **Write Tests**: Create tests for the implementation\n```\n\n## Review Agent Template\n\n```markdown\n---\ndescription: Review code for quality, security, and best practices\nname: reviewer\ntools: ['search', 'githubRepo', 'usages']\nhandoffs:\n  - label: Fix Issues\n    agent: coder\n    prompt: Address the issues identified in the review.\n    send: false\n---\n\n# Code Review Agent\n\nYou are a senior code reviewer who ensures code quality, security, and adherence to best practices.\n\n## Your Role\n\nPerform comprehensive code reviews checking for:\n- **Security**: Vulnerabilities and security best practices\n- **Quality**: Code maintainability and readability\n- **Performance**: Potential performance issues\n- **Best Practices**: Adherence to patterns and conventions\n- **Testing**: Test coverage and quality\n\n## Guidelines\n\n- Use #tool:search to compare against project conventions\n- Use #tool:githubRepo to understand repository standards\n- Use #tool:usages to verify consistent usage patterns\n- Be constructive and specific in feedback\n- Prioritize issues by severity (Critical, High, Medium, Low)\n\n## Review Checklist\n\n- [ ] No security vulnerabilities (XSS, SQL injection, etc.)\n- [ ] Proper error handling\n- [ ] Code follows project conventions\n- [ ] No performance bottlenecks\n- [ ] Adequate test coverage\n- [ ] Clear documentation and comments\n- [ ] No code duplication\n- [ ] Consistent naming conventions\n\n## Output Format\n\n```\n## Code Review Report\n\n### ‚úÖ Strengths\n- [Positive aspect 1]\n- [Positive aspect 2]\n\n### üî¥ Critical Issues\n- [ ] `file.ts:42` - [Issue description and fix]\n\n### üü° Suggestions\n- [ ] `file.ts:67` - [Suggestion description]\n\n### üìä Summary\n- Security: ‚úÖ No issues found\n- Quality: ‚ö†Ô∏è 2 suggestions\n- Performance: ‚úÖ Looks good\n- Testing: ‚ùå Needs improvement\n\n### Next Steps\n[Recommended actions]\n```\n\n## Handoff\n\nUse \"Fix Issues\" button to send critical issues back to implementation.\n```\n\n## Testing Agent Template\n\n```markdown\n---\ndescription: Create comprehensive tests for code changes\nname: tester\ntools: ['search', 'files', 'usages']\nhandoffs:\n  - label: Review Tests\n    agent: reviewer\n    prompt: Review the test coverage and quality.\n    send: false\n---\n\n# Testing Agent\n\nYou are a testing specialist who creates comprehensive, maintainable test suites.\n\n## Your Role\n\nCreate high-quality tests that:\n- Cover all critical paths and edge cases\n- Are maintainable and readable\n- Follow testing best practices\n- Provide meaningful assertions\n\n## Guidelines\n\n- Use #tool:search to find existing test patterns\n- Use #tool:files to create test files\n- Use #tool:usages to understand how code is used in practice\n- Follow the project's testing framework conventions\n- Aim for meaningful coverage, not just high percentages\n\n## Test Types to Consider\n\n1. **Unit Tests**: Individual function/method behavior\n2. **Integration Tests**: Component interactions\n3. **Edge Cases**: Boundary conditions and error scenarios\n4. **Regression Tests**: Known bug scenarios\n\n## Output Format\n\n```\n## Test Suite Created\n\n### üìù Test Files\n- `tests/feature.test.ts` - [Description]\n- `tests/integration.test.ts` - [Description]\n\n### ‚úÖ Coverage\n- Unit tests: [X] test cases\n- Integration tests: [Y] scenarios\n- Edge cases: [Z] scenarios\n\n### üéØ Test Summary\n- Total test cases: [N]\n- Coverage areas: [List key areas]\n- Known gaps: [If any]\n\n### Run Tests\n```bash\nnpm test [test-file-pattern]\n```\n```\n\n## Handoff\n\nUse \"Review Tests\" to have test quality reviewed.\n```\n\n## Documentation Agent Template\n\n```markdown\n---\ndescription: Generate and update technical documentation\nname: documenter\ntools: ['search', 'files', 'githubRepo']\n---\n\n# Documentation Agent\n\nYou are a technical writer who creates clear, comprehensive documentation.\n\n## Your Role\n\nCreate documentation that is:\n- Clear and accessible to the target audience\n- Comprehensive with examples\n- Up-to-date with current implementation\n- Well-structured and easy to navigate\n\n## Guidelines\n\n- Use #tool:search to understand code functionality\n- Use #tool:files to create/update documentation files\n- Use #tool:githubRepo to understand project structure\n- Include code examples and usage patterns\n- Follow the project's documentation style\n\n## Documentation Types\n\n1. **API Documentation**: Endpoints, parameters, responses\n2. **User Guides**: How to use features\n3. **Developer Guides**: How to contribute/extend\n4. **README**: Project overview and quick start\n\n## Output Format\n\n```markdown\n# [Feature/Module Name]\n\n## Overview\n[Brief description]\n\n## Installation\n```bash\n[Installation commands]\n```\n\n## Usage\n```[language]\n[Code example]\n```\n\n## API Reference\n### [Function/Method Name]\n- **Parameters**: [List]\n- **Returns**: [Type and description]\n- **Example**: [Code example]\n\n## Examples\n[Comprehensive examples]\n\n## Troubleshooting\n[Common issues and solutions]\n```\n\n---\n\n**Templates ready for agent generation!** Use these as starting points and customize for specific needs.\n",
        "py-plugin/skills/ios-code-review/SKILL.md": "---\nname: ios-code-review\ndescription: Concise iOS code review for Payoo Merchant app. Focuses on critical/high/medium issues - RxSwift memory leaks, retain cycles, naming conventions, Clean Architecture violations, and business logic placement. Use when reviewing Swift files, pull requests, ViewModels, ViewControllers, UseCases, and Repositories.\nallowed-tools: Read, Grep, Glob\n---\n\n# iOS Code Review - Priority Issues Focus\n\nExpert iOS code reviewer for Payoo Merchant application, focusing on CRITICAL, HIGH, and MEDIUM priority issues that impact app stability, maintainability, and architecture.\n\n## When to Activate\n\n- \"review code\", \"check this file\", \"review PR\"\n- Mentions Swift files: ViewController, ViewModel, UseCase, Repository\n- \"code quality\", \"best practices\", \"check standards\"\n- RxSwift memory leaks, retain cycles, Clean Architecture, MVVM patterns\n\n## Review Process\n\n### Step 1: Identify Scope\nDetermine what to review:\n- Specific files (e.g., \"PaymentViewModel.swift\")\n- Directories (e.g., \"Payment module\")\n- Git changes (recent commits, PR diff)\n- Entire module or feature\n\n### Step 2: Read and Analyze\nUse Read tool to examine files, focusing on CRITICAL, HIGH, and MEDIUM priority issues only.\n\n### Step 3: Apply Priority Standards\n\n## üéØ PRIORITY FOCUS AREAS\n\n### 1. RxSwift Memory Leaks üî¥ CRITICAL\n**Impact**: Memory leaks, app crashes, performance degradation\n\n**Check for**:\n- **Missing disposal**: Every `.subscribe()` MUST have `.disposed(by: disposeBag)`\n- **Retain cycles**: Use `[weak self]` in all closures capturing `self`\n- **DisposeBag**: Must be declared as instance variable, not local\n- **Observable chains**: No abandoned subscriptions\n\n**Common violations**:\n```swift\n// ‚ùå CRITICAL - Memory leak\nobservable\n    .subscribe(onNext: { value in\n        self.updateUI(value) // Missing disposed(by:)\n    })\n\n// ‚ùå CRITICAL - Retain cycle\nobservable\n    .subscribe(onNext: { [self] value in // Strong self!\n        self.updateUI(value)\n    })\n    .disposed(by: disposeBag)\n\n// ‚úÖ GOOD\nobservable\n    .subscribe(onNext: { [weak self] value in\n        self?.updateUI(value)\n    })\n    .disposed(by: disposeBag)\n```\n\n### 2. Naming Conventions üü† HIGH\n**Impact**: Code readability, maintainability, team collaboration\n\n**Check for**:\n- **Types**: PascalCase, descriptive (e.g., `PaymentViewModel`, not `PmtVM`)\n- **Variables**: camelCase (e.g., `paymentAmount`, not `pmt_amt`)\n- **Booleans**: Must have `is`/`has`/`should`/`can` prefix (e.g., `isLoading`, not `loading`)\n- **NO abbreviations** except URL, ID, VC (ViewController), UC (UseCase)\n- **IBOutlets**: Must include type suffix (e.g., `amountTextField`, not `amount`)\n\n**Common violations**:\n```swift\n// ‚ùå BAD\nvar usr: User?\nvar loading = false\n@IBOutlet weak var amount: UITextField!\nvar pmtVM: PaymentViewModel?\n\n// ‚úÖ GOOD\nvar user: User?\nvar isLoading = false\n@IBOutlet weak var amountTextField: UITextField!\nvar paymentViewModel: PaymentViewModel?\n```\n\n### 3. Clean Architecture Violations üü† HIGH\n**Impact**: Testability, maintainability, architecture integrity\n\n**Check for**:\n- **ViewModels**: Must extend `BaseViewModel<State>`, NO business logic\n- **ViewModel ‚Üí UseCase**: ViewModels MUST call UseCases, NEVER call Repository/API directly\n- **Business logic**: Must be in UseCases ONLY, not in ViewModel/ViewController\n- **Dependency injection**: All dependencies via constructor (Swinject)\n- **Layer separation**: ViewModel ‚Üí UseCase ‚Üí Repository ‚Üí DataSource\n\n**Common violations**:\n```swift\n// ‚ùå BAD - ViewModel calling Repository directly\nclass PaymentViewModel {\n    private let repository: PaymentRepository\n\n    func loadPayments() {\n        repository.getPayments() // ‚ùå Skip UseCase layer\n            .subscribe(onNext: { payments in\n                // ...\n            })\n            .disposed(by: disposeBag)\n    }\n}\n\n// ‚ùå BAD - Business logic in ViewModel\nclass PaymentViewModel {\n    func processPayment(amount: Double) {\n        if amount <= 0 { return } // ‚ùå Business logic!\n        let fee = amount * 0.02\n        let total = amount + fee\n        // ...\n    }\n}\n\n// ‚úÖ GOOD - Proper Clean Architecture\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let getPaymentsUseCase: GetPaymentsUseCase\n    private let processPaymentUseCase: ProcessPaymentUseCase\n\n    init(getPaymentsUseCase: GetPaymentsUseCase,\n         processPaymentUseCase: ProcessPaymentUseCase) {\n        self.getPaymentsUseCase = getPaymentsUseCase\n        self.processPaymentUseCase = processPaymentUseCase\n        super.init()\n    }\n\n    func loadPayments() {\n        getPaymentsUseCase.execute() // ‚úÖ Call UseCase\n            .subscribe(onNext: { [weak self] payments in\n                self?.state.accept(.success(payments))\n            })\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n### 4. RxSwift Scheduler Issues üü° MEDIUM\n**Impact**: UI freezes, background thread crashes\n\n**Check for**:\n- **Background work**: Use `.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))`\n- **UI updates**: Must use `.observeOn(MainScheduler.instance)` before UI work\n- **Never block main thread**: Network/DB operations on background scheduler\n\n**Common violations**:\n```swift\n// ‚ùå BAD - Heavy work on main thread\napiService.getData()\n    .subscribe(onNext: { data in\n        // Heavy processing on main thread\n        self.processLargeData(data)\n    })\n    .disposed(by: disposeBag)\n\n// ‚úÖ GOOD - Proper scheduler usage\napiService.getData()\n    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))\n    .map { data in\n        // Heavy processing on background\n        return self.processLargeData(data)\n    }\n    .observeOn(MainScheduler.instance)\n    .subscribe(onNext: { [weak self] result in\n        // UI updates on main\n        self?.updateUI(result)\n    })\n    .disposed(by: disposeBag)\n```\n\n### 5. Error Handling üü° MEDIUM\n**Impact**: App crashes, poor UX\n\n**Check for**:\n- **Observable chains**: Must handle `.onError` or use `catchError`\n- **API calls**: All network operations must have error handling\n- **User feedback**: Show error messages to user\n\n**Common violations**:\n```swift\n// ‚ùå BAD - No error handling\napiService.getData()\n    .subscribe(onNext: { data in\n        self.updateUI(data)\n    })\n    .disposed(by: disposeBag)\n\n// ‚úÖ GOOD - Proper error handling\napiService.getData()\n    .subscribe(\n        onNext: { [weak self] data in\n            self?.updateUI(data)\n        },\n        onError: { [weak self] error in\n            self?.showError(error.localizedDescription)\n        }\n    )\n    .disposed(by: disposeBag)\n\n// ‚úÖ BETTER - Using catchError\napiService.getData()\n    .catchError { error in\n        return Observable.just(defaultData)\n    }\n    .subscribe(onNext: { [weak self] data in\n        self?.updateUI(data)\n    })\n    .disposed(by: disposeBag)\n```\n\n### 6. Deprecated Patterns üü° MEDIUM\n**Impact**: Future compatibility, best practices\n\n**Check for**:\n- **Use BehaviorRelay/PublishRelay** instead of BehaviorSubject/PublishSubject\n- **Avoid Variable**: Use BehaviorRelay instead\n\n**Common violations**:\n```swift\n// ‚ùå BAD - Using deprecated BehaviorSubject\nprivate let loadingSubject = BehaviorSubject<Bool>(value: false)\n\n// ‚úÖ GOOD - Use BehaviorRelay\nprivate let loadingRelay = BehaviorRelay<Bool>(value: false)\n```\n\n### Step 4: Generate Concise Report\n\nFocus ONLY on CRITICAL (üî¥), HIGH (üü†), and MEDIUM (üü°) priority issues. Skip low priority findings.\n\nProvide concise, actionable output with:\n- **Summary**: Only üî¥/üü†/üü° counts (one line per severity)\n- **Issues**: Group by severity, concise title + file + line number\n- **Code snippets**: Only for Critical/High issues, keep minimal\n- **Quick fixes**: Brief, actionable recommendations\n\n## Severity Levels - CRITICAL/HIGH/MEDIUM ONLY\n\nüî¥ **CRITICAL** - Fix immediately (blocks release)\n- **Missing disposal**: `.subscribe()` without `.disposed(by: disposeBag)` ‚Üí Memory leak\n- **Retain cycles**: Strong `self` in closures ‚Üí Memory leak\n- **UI on background thread**: UI updates not on MainScheduler ‚Üí Crash risk\n\nüü† **HIGH PRIORITY** - Fix before merge\n- **Naming violations**: Abbreviations, wrong case, missing is/has prefix, IBOutlet without type suffix\n- **Architecture violations**: ViewModel calling Repository/API directly (skipping UseCase)\n- **Business logic misplacement**: Business logic in ViewModel/ViewController instead of UseCase\n- **Missing BaseViewModel**: ViewModel not extending `BaseViewModel<State>`\n\nüü° **MEDIUM PRIORITY** - Fix in current sprint\n- **No error handling**: Observable chains without onError or catchError\n- **Wrong schedulers**: Heavy work on main thread, missing observeOn(MainScheduler)\n- **Deprecated patterns**: Using BehaviorSubject/PublishSubject instead of Relay\n\n## üö´ IGNORE (Out of Scope)\n- Code style and formatting (handled by SwiftLint)\n- Documentation and comments\n- Accessibility (unless critical)\n- Security issues (separate review)\n- Performance optimizations (unless critical)\n- UI/UX improvements\n- Low priority issues\n\n## Output Format\n\n**KEEP IT CONCISE** - Focus on actionable findings only.\n\n```markdown\n# iOS Code Review - Priority Issues\n\n## Summary\nüî¥ Critical: X | üü† High: X | üü° Medium: X\n\n## üî¥ CRITICAL ISSUES (Fix Immediately)\n\n1. **Memory leak - Missing disposal** - `PaymentViewModel.swift:45`\n   ```swift\n   // ‚ùå observable.subscribe(onNext: { ... }) // No disposal\n   // ‚úÖ .disposed(by: disposeBag)\n   ```\n\n2. **Retain cycle - Strong self** - `TransactionViewController.swift:78`\n   - Use `[weak self]` instead of `[self]`\n\n---\n\n## üü† HIGH PRIORITY (Fix Before Merge)\n\n1. **Naming - Abbreviations** - `UserViewModel.swift:12`\n   - `usr` ‚Üí `user`, `pmtVM` ‚Üí `paymentViewModel`\n\n2. **Architecture - ViewModel calls Repository directly** - `PaymentViewModel.swift:34`\n   - Inject and call `GetPaymentsUseCase` instead of `PaymentRepository`\n\n3. **Business logic in ViewModel** - `PaymentViewModel.swift:56-60`\n   - Move fee calculation to `ProcessPaymentUseCase`\n\n---\n\n## üü° MEDIUM PRIORITY (Fix This Sprint)\n\n1. **No error handling** - `DashboardViewModel.swift:89`\n   - Add `onError` or `catchError` to API call\n\n2. **Wrong scheduler** - `TransactionListViewModel.swift:123`\n   - Add `.observeOn(MainScheduler.instance)` before UI update\n\n3. **Deprecated BehaviorSubject** - `SettingsViewModel.swift:23`\n   - Use `BehaviorRelay` instead\n\n---\n\n## ‚ö†Ô∏è Action Required\n- üî¥ **X Critical** - Block release, fix now\n- üü† **X High** - Block merge, fix today\n- üü° **X Medium** - Fix in current sprint\n\n‚úÖ **Well Done**: [If applicable, briefly acknowledge 1-2 good patterns]\n```\n\n## Quick Reference\n\n**Focus on 6 Priority Areas**:\n1. üî¥ **RxSwift Memory Leaks** - Missing disposal, retain cycles\n2. üü† **Naming Conventions** - Abbreviations, wrong case, missing prefixes\n3. üü† **Clean Architecture** - ViewModel ‚Üí UseCase ‚Üí Repository flow\n4. üü° **Schedulers** - Background work, main thread UI updates\n5. üü° **Error Handling** - onError, catchError in Observable chains\n6. üü° **Deprecated Patterns** - BehaviorRelay vs BehaviorSubject\n\n**Skip**: Code style, docs, accessibility, security, performance (unless critical), UI/UX, low priority\n\n## Tips\n\n- **Be concise**: One-line issue descriptions when possible\n- **Be specific**: Exact file paths and line numbers\n- **Be actionable**: Clear fix instructions\n- **Show code**: Only for Critical/High issues, keep minimal\n- **Group issues**: Batch similar violations (e.g., \"5 naming violations in PaymentViewModel.swift:12,34,56,78,90\")\n- **No explanations**: Skip \"Why\" unless unclear - developers know why memory leaks are bad\n",
        "py-plugin/skills/ios-code-review/examples.md": "# iOS Code Review Examples\n\nDetailed examples for each review category with good/bad patterns.\n\n## 1. Naming Conventions Examples\n\n### ‚úÖ Good Naming\n\n```swift\n// Classes and Types\nclass PaymentViewController: UIViewController { }\nclass RefundRequestViewModel: BaseViewModel<RefundRequestState> { }\nprotocol PaymentUseCase { }\n\n// Variables and Properties\nlet paymentAmount = BehaviorRelay<String>(value: \"\")\nlet isProcessingPayment = BehaviorRelay<Bool>(value: false)\nlet transactions = BehaviorRelay<[Transaction]>(value: [])\n\n// Functions\nfunc loadTransactions() { }\nfunc processPaymentRequest(amount: Double) { }\nfunc validatePaymentAmount(_ amount: String) -> Bool { }\n\n// IBOutlets\n@IBOutlet weak var paymentAmountTextField: UITextField!\n@IBOutlet weak var confirmButton: UIButton!\n@IBOutlet weak var transactionTableView: UITableView!\n```\n\n### ‚ùå Bad Naming\n\n```swift\n// Classes - Too abbreviated or generic\nclass PayVC: UIViewController { }  // What is \"Pay\"?\nclass RefReqVM { }  // Too abbreviated\nclass Manager { }  // Too generic\n\n// Variables - Unclear or abbreviated\nlet amt = BehaviorRelay<String>(value: \"\")  // What is \"amt\"?\nlet flag = BehaviorRelay<Bool>(value: false)  // Meaningless\nlet data = BehaviorRelay<[Any]>(value: [])  // Too generic\n\n// Functions - Vague\nfunc doSomething() { }  // What does it do?\nfunc process() { }  // Process what?\nfunc handle() { }  // Handle what?\n\n// IBOutlets - Missing type suffix\n@IBOutlet weak var amount: UITextField!  // Should be amountTextField\n@IBOutlet weak var btn: UIButton!  // Should be confirmButton\n```\n\n---\n\n## 2. RxSwift Pattern Examples\n\n### ‚úÖ Proper RxSwift Usage\n\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let paymentUC: PaymentUseCase\n    private let disposeBag = DisposeBag()\n\n    let paymentAmount = BehaviorRelay<String>(value: \"\")\n    let isProcessing = BehaviorRelay<Bool>(value: false)\n\n    init(paymentUC: PaymentUseCase) {\n        self.paymentUC = paymentUC\n        super.init()\n    }\n\n    func processPayment() {\n        guard !paymentAmount.value.isEmpty else {\n            setState(.showError(PaymentError.invalidAmount))\n            return\n        }\n\n        isProcessing.accept(true)\n\n        paymentUC.execute(amount: paymentAmount.value)\n            .subscribeOn(ConcurrentScheduler.background)\n            .observeOn(MainScheduler.instance)\n            .subscribe(\n                onNext: { [weak self] result in\n                    self?.handleSuccess(result)\n                },\n                onError: { [weak self] error in\n                    self?.handleError(error)\n                },\n                onCompleted: { [weak self] in\n                    self?.isProcessing.accept(false)\n                }\n            )\n            .disposed(by: disposeBag)  // ‚úì Proper disposal\n    }\n}\n```\n\n### ‚ùå Common RxSwift Mistakes\n\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    // ‚ùå Missing DisposeBag property\n\n    func processPayment() {\n        // ‚ùå MEMORY LEAK: No disposal\n        paymentUC.execute(amount: paymentAmount.value)\n            .subscribe(onNext: { result in\n                // ‚ùå RETAIN CYCLE: Strong self reference\n                self.handleSuccess(result)\n            })\n            // MISSING: .disposed(by: disposeBag)\n    }\n\n    func loadData() {\n        // ‚ùå Wrong scheduler for UI updates\n        networkService.fetchData()\n            .subscribeOn(MainScheduler.instance)  // Wrong!\n            .subscribe(onNext: { data in\n                self.tableView.reloadData()  // May be on background thread\n            })\n            .disposed(by: disposeBag)\n    }\n\n    func refreshData() {\n        // ‚ùå No error handling\n        dataSource.getData()\n            .subscribe(onNext: { data in\n                // Handle data\n            })\n            // MISSING: onError handler\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n### DisposeBag Anti-Patterns\n\n```swift\n// ‚ùå BAD: Local DisposeBag\nfunc loadData() {\n    let disposeBag = DisposeBag()  // Local variable!\n\n    api.fetchData()\n        .subscribe(onNext: { data in\n            // Handle data\n        })\n        .disposed(by: disposeBag)\n    // DisposeBag deallocates here, cancels subscription immediately!\n}\n\n// ‚ùå BAD: Multiple DisposeBags\nclass ViewModel {\n    private var searchDisposeBag = DisposeBag()  // Anti-pattern\n    private var dataDisposeBag = DisposeBag()    // Anti-pattern\n}\n\n// ‚úÖ GOOD: Single DisposeBag property\nclass ViewModel {\n    private let disposeBag = DisposeBag()  // Correct!\n}\n```\n\n---\n\n## 3. Clean Architecture Examples\n\n### ‚úÖ Proper Layer Separation\n\n```swift\n// PRESENTATION LAYER - ViewModel\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let paymentUC: PaymentUseCase  // ‚úì Uses UseCase\n\n    init(paymentUC: PaymentUseCase) {\n        self.paymentUC = paymentUC\n        super.init()\n    }\n\n    func processPayment(amount: String) {\n        paymentUC.execute(amount: amount)  // ‚úì Delegates to UseCase\n            .subscribe(\n                onNext: { [weak self] result in\n                    self?.setState(.success(result))\n                },\n                onError: { [weak self] error in\n                    self?.setState(.error(error))\n                }\n            )\n            .disposed(by: disposeBag)\n    }\n}\n\n// DOMAIN LAYER - UseCase\nprotocol PaymentUseCase {\n    func execute(amount: String) -> Single<PaymentResult>\n}\n\nclass PaymentUseCaseImpl: PaymentUseCase {\n    private let paymentRepository: PaymentRepository\n    private let validationService: ValidationService\n\n    init(paymentRepository: PaymentRepository,\n         validationService: ValidationService) {\n        self.paymentRepository = paymentRepository\n        self.validationService = validationService\n    }\n\n    func execute(amount: String) -> Single<PaymentResult> {\n        // ‚úì Business logic in UseCase\n        return validationService.validateAmount(amount)\n            .flatMap { validAmount in\n                return self.paymentRepository.processPayment(amount: validAmount)\n            }\n    }\n}\n\n// DATA LAYER - Repository\nprotocol PaymentRepository {\n    func processPayment(amount: Double) -> Single<PaymentResult>\n}\n\nclass PaymentRepositoryImpl: PaymentRepository {\n    private let apiService: PaymentApiService\n    private let localStorage: PaymentLocalStorage\n\n    func processPayment(amount: Double) -> Single<PaymentResult> {\n        return apiService.processPayment(amount: amount)\n            .do(onSuccess: { [weak self] result in\n                self?.localStorage.savePaymentRecord(result)\n            })\n    }\n}\n```\n\n### ‚ùå Layer Violations\n\n```swift\n// ‚ùå BAD: ViewModel bypassing UseCase\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let apiService: PaymentApiService  // ‚ùå Wrong layer!\n\n    func processPayment() {\n        // ‚ùå Direct API call, no business logic\n        apiService.processPayment(amount: amount)\n            .subscribe(onNext: { result in\n                // ‚ùå Direct storage access\n                RealmManager.shared.save(result)\n            })\n            .disposed(by: disposeBag)\n    }\n}\n\n// ‚ùå BAD: Business logic in ViewModel\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    func processPayment(amount: Double) {\n        // ‚ùå Validation logic in ViewModel\n        guard amount > 1000 else { return }\n        guard amount < 50_000_000 else { return }\n\n        // ‚ùå Business rules in ViewModel\n        let fee = amount * 0.01\n        let total = amount + fee\n\n        // This should all be in UseCase!\n    }\n}\n\n// ‚ùå BAD: Direct instantiation\nclass PaymentViewController: UIViewController {\n    // ‚ùå Hard-coded dependencies\n    private let viewModel = PaymentViewModel(\n        paymentUC: PaymentUseCaseImpl()  // ‚ùå Direct instantiation\n    )\n}\n```\n\n---\n\n## 4. Security Examples\n\n### ‚úÖ Secure Payment Handling\n\n```swift\nclass PaymentSecurityManager {\n    private let keychain = KeychainWrapper.standard\n\n    // ‚úì Store in Keychain\n    func storePaymentToken(_ token: String, for merchantId: String) {\n        let key = \"payment_token_\\(merchantId)\"\n        keychain.set(token, forKey: key,\n                    withAccessibility: .whenUnlockedThisDeviceOnly)\n    }\n\n    func retrievePaymentToken(for merchantId: String) -> String? {\n        let key = \"payment_token_\\(merchantId)\"\n        return keychain.string(forKey: key)\n    }\n}\n\n// ‚úì Mask sensitive data in logs\nclass PaymentRequest {\n    let amount: Double\n    let merchantId: String\n\n    override var description: String {\n        return \"PaymentRequest(amount: \\(amount), merchantId: ***)\"\n    }\n}\n\n// ‚úì HTTPS with certificate pinning\nclass PaymentNetworkManager {\n    private lazy var session: URLSession = {\n        let config = URLSessionConfiguration.default\n        return URLSession(\n            configuration: config,\n            delegate: CertificatePinningDelegate(),\n            delegateQueue: nil\n        )\n    }()\n}\n```\n\n### ‚ùå Security Violations\n\n```swift\n// ‚ùå BAD: Insecure storage\nclass PaymentManager {\n    func storePaymentToken(_ token: String) {\n        // ‚ùå UserDefaults is not secure!\n        UserDefaults.standard.set(token, forKey: \"payment_token\")\n    }\n\n    func processPayment(_ request: PaymentRequest) {\n        // ‚ùå Logging sensitive data!\n        print(\"Processing payment: \\(request)\")\n        print(\"Card number: \\(request.cardNumber)\")\n    }\n}\n\n// ‚ùå BAD: No certificate pinning\nclass PaymentNetworkManager {\n    func processPayment(_ request: PaymentRequest) {\n        let url = URL(string: \"http://api.payoo.vn/payment\")!  // ‚ùå HTTP!\n\n        // ‚ùå No encryption\n        let data = try! JSONEncoder().encode(request)\n\n        // ‚ùå No certificate pinning\n        URLSession.shared.dataTask(with: url) { _, _, _ in }\n    }\n}\n```\n\n---\n\n## 5. UI/UX Examples\n\n### ‚úÖ Proper Navigation Setup\n\n```swift\n// ‚úì Simple title\nclass PaymentViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        title = \"Payment\"  // ‚úì Use title property\n    }\n}\n\n// ‚úì Title with subtitle (only when subtitle exists)\nclass StoreSelectionViewController: UIViewController {\n    private let titleDescription: String?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        if let description = titleDescription, !description.isEmpty {\n            // ‚úì Only use titleView when subtitle exists\n            navigationItem.titleView = createTitleView(\n                title: \"Store Selection\",\n                description: description\n            )\n        } else {\n            // ‚úì Use simple title when no subtitle\n            title = \"Store Selection\"\n        }\n    }\n}\n\n// ‚úì Loading states with feedback\nclass QRSaleViewController: UIViewController {\n    private func bindLoadingStates() {\n        viewModel.isProcessing\n            .bind(to: loadingIndicator.rx.isAnimating)\n            .disposed(by: disposeBag)\n\n        viewModel.isProcessing\n            .map { !$0 }\n            .bind(to: processButton.rx.isEnabled)\n            .disposed(by: disposeBag)\n\n        viewModel.isProcessing\n            .map { $0 ? \"Processing...\" : \"Process Payment\" }\n            .bind(to: processButton.rx.title(for: .normal))\n            .disposed(by: disposeBag)\n    }\n}\n\n// ‚úì Accessibility\nclass PaymentAmountView: UIView {\n    private func setupAccessibility() {\n        amountTextField.isAccessibilityElement = true\n        amountTextField.accessibilityLabel = \"Payment amount\"\n        amountTextField.accessibilityHint = \"Enter the payment amount in VND\"\n\n        // ‚úì Dynamic Type support\n        amountTextField.font = UIFont.preferredFont(forTextStyle: .title2)\n        amountTextField.adjustsFontForContentSizeCategory = true\n    }\n}\n```\n\n### ‚ùå UI/UX Issues\n\n```swift\n// ‚ùå BAD: Using titleView for simple title\nclass PaymentViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        // ‚ùå Unnecessary custom title view\n        let titleLabel = UILabel()\n        titleLabel.text = \"Payment\"\n        navigationItem.titleView = titleLabel  // Should use title property!\n    }\n}\n\n// ‚ùå BAD: No loading feedback\nclass QRSaleViewController: UIViewController {\n    private func processPayment() {\n        // ‚ùå No loading indicator\n        viewModel.processPayment()  // User has no feedback!\n    }\n}\n\n// ‚ùå BAD: No accessibility\nclass PaymentAmountView: UIView {\n    // ‚ùå No accessibility setup\n    // ‚ùå No Dynamic Type support\n    // ‚ùå Missing accessibility labels\n}\n```\n\n---\n\n## 6. Performance Examples\n\n### ‚úÖ Proper Memory Management\n\n```swift\nclass ImageDownloadManager {\n    private let cache = NSCache<NSString, UIImage>()\n    private var activeDownloads: [String: Disposable] = [:]\n\n    func downloadImage(from url: String) -> Observable<UIImage> {\n        let cacheKey = url as NSString\n\n        // ‚úì Check cache first\n        if let cachedImage = cache.object(forKey: cacheKey) {\n            return .just(cachedImage)\n        }\n\n        // ‚úì Cancel existing download\n        activeDownloads[url]?.dispose()\n\n        let download = URLSession.shared.rx\n            .data(request: URLRequest(url: URL(string: url)!))\n            .compactMap { UIImage(data: $0) }\n            .do(\n                onNext: { [weak self] image in\n                    self?.cache.setObject(image, forKey: cacheKey)\n                },\n                onDispose: { [weak self] in\n                    self?.activeDownloads.removeValue(forKey: url)\n                }\n            )\n            .share(replay: 1, scope: .whileConnected)\n\n        activeDownloads[url] = download.connect()\n        return download\n    }\n}\n\n// ‚úì Database on background thread\nclass TransactionRepository {\n    func getTransactions() -> Observable<[Transaction]> {\n        return Observable.collection(from: realm.objects(TransactionObject.self))\n            .map { results in\n                return results.map { Transaction(from: $0) }\n            }\n            .subscribeOn(ConcurrentScheduler.background)  // ‚úì Background\n            .observeOn(MainScheduler.instance)  // ‚úì Main for UI\n    }\n}\n```\n\n### ‚ùå Performance Issues\n\n```swift\n// ‚ùå BAD: Memory leak from strong references\nclass ImageDownloadManager {\n    private var downloads: [URLSessionDataTask] = []  // ‚ùå Strong references\n\n    func downloadImage(from url: String) -> Observable<UIImage> {\n        return Observable.create { observer in\n            let task = URLSession.shared.dataTask(with: URL(string: url)!) { data, _, _ in\n                // Process\n            }\n\n            self.downloads.append(task)  // ‚ùå Never removed - leak!\n            task.resume()\n\n            return Disposables.create {\n                task.cancel()\n                // ‚ùå Still in downloads array!\n            }\n        }\n    }\n}\n\n// ‚ùå BAD: Blocking main thread\nclass TransactionRepository {\n    func getTransactions() -> Observable<[Transaction]> {\n        return Observable.create { observer in\n            // ‚ùå Blocking operation on main thread!\n            let realm = try! Realm()\n            let results = realm.objects(TransactionObject.self)\n            let transactions = results.map { Transaction(from: $0) }\n\n            observer.onNext(Array(transactions))\n            observer.onCompleted()\n\n            return Disposables.create()\n        }\n    }\n}\n```\n\n---\n\n## Common Review Scenarios\n\n### Scenario 1: New Feature Review\n\n**Code**: New payment processing feature\n\n**Check**:\n1. Naming: All classes/variables descriptive?\n2. RxSwift: Disposal and memory management?\n3. Architecture: Proper layer separation?\n4. Security: Payment data handled securely?\n5. Tests: Unit tests included?\n6. Performance: No blocking operations?\n\n### Scenario 2: Bug Fix Review\n\n**Code**: Fix for crash in transaction list\n\n**Check**:\n1. Root cause addressed?\n2. No force unwrapping?\n3. Proper error handling added?\n4. Tests for the bug scenario?\n5. No new issues introduced?\n\n### Scenario 3: Refactoring Review\n\n**Code**: Refactor ViewModel to use Clean Architecture\n\n**Check**:\n1. UseCase layer added?\n2. Business logic moved from ViewModel?\n3. DI setup correctly?\n4. Tests still pass?\n5. No breaking changes?\n\n---\n\n**Detailed Examples**: See `examples.md` for extensive code samples and scenarios.\n\n## Quick Reference Checklist\n\nCopy this for quick reviews:\n\n```markdown\n## Review Checklist\n\n### Naming ‚úÖ\n- [ ] Classes: PascalCase, descriptive\n- [ ] Variables: camelCase, meaningful\n- [ ] Booleans: is/has/should/can prefix\n- [ ] No abbreviations\n- [ ] IBOutlets: type suffix\n\n### RxSwift üîÑ\n- [ ] All subscriptions disposed\n- [ ] [weak self] in closures\n- [ ] Correct schedulers\n- [ ] Error handling present\n- [ ] Using BehaviorRelay\n\n### Architecture üèóÔ∏è\n- [ ] ViewModel ‚Üí UseCase ‚Üí Repository\n- [ ] No business logic in ViewModel\n- [ ] Dependencies injected\n- [ ] BaseViewModel extended\n- [ ] Repository pattern used\n\n### Security üîí\n- [ ] Payment data in Keychain\n- [ ] No sensitive logs\n- [ ] HTTPS with pinning\n- [ ] Input validation\n\n### UI/UX üé®\n- [ ] title for simple titles\n- [ ] titleView only with subtitle\n- [ ] Accessibility configured\n- [ ] Loading states shown\n\n### Performance ‚ö°\n- [ ] DB on background thread\n- [ ] No retain cycles\n- [ ] Image caching\n- [ ] Memory management proper\n```\n",
        "py-plugin/skills/ios-delivery-build/SKILL.md": "---\nname: ios-delivery-build\ndescription: Manage iOS delivery builds to QC testing with GitLab pipeline creation and issue management. Supports develop, delivery, bugfix, and redelivery modes. Use when \"create delivery\", \"delivery build\", \"build for qc\", \"send to testing\", or \"deliver build\".\nallowed-tools: Bash, AskUserQuestion, Read\n---\n\nYou are managing iOS delivery builds to QC testing with GitLab integration.\n\n## Step 1: Get Current Branch\n\nExecute immediately:\n```bash\ngit branch --show-current\n```\n\nStore result as `{current_branch}`.\n\n## Step 2: Mode Selection\n\nAsk user to select delivery mode:\n- **develop**: Create develop task and move original to testing\n- **delivery**: Close issues after delivery\n- **bugfix**: Move issues to testing status\n- **redelivery**: Create pipeline only, no issue management\n\nUse AskUserQuestion with these exact options:\n- \"develop - Create develop task and move original to testing\"\n- \"delivery - Close issues after delivery\"\n- \"bugfix - Move issues to testing status\"\n- \"redelivery - Create pipeline only\"\n\nIf invalid mode after 3 attempts, abort with error.\n\n## Step 3: Collect Form Inputs\n\nPresent form template from `templates.md` based on selected mode.\n\n**Required for ALL modes:**\n- branch (pre-filled with {current_branch})\n- scheme (default: \"Payoo Merchant Sandbox\")\n- recipient (from predefined list in templates.md)\n- description\n- reply_on_thread (default: \"none\")\n- project (default: \"rnd/ios/payoo-ios-app-merchant\")\n\n**Conditional fields:**\n- issue_numbers: Required for develop/delivery/bugfix, NOT for redelivery\n- estimates: Required for develop/delivery, NOT for bugfix/redelivery\n\nParse user input and extract all field values.\n\n## Step 4: Validate Inputs\n\nBefore proceeding, validate:\n- branch exists (check with `git branch --list`)\n- issue_numbers are numeric (skip for redelivery)\n- recipient matches format \"Name|ID\" from predefined list\n- estimates count matches issue_numbers count (for delivery/develop only)\n- reply_on_thread is \"none\" or valid URL\n- scheme and project are non-empty\n\nIf validation fails, show specific errors and request corrections.\n\n## Step 5: Create GitLab Pipeline\n\nUse MCP tool `mobile-mcp-server/gitlab-create-pipeline-for-branch`:\n```\nscheme: {scheme}\nbranchName: {branch}\nrecipient: {recipient}\nreplyOnThread: {reply_on_thread}\ndescription: {description}\nproject: {project}\n```\n\nIf pipeline creation fails, abort workflow with error.\n\n## Step 6: Plan Issue Management Actions\n\nBased on mode, plan actions (see `examples.md` for detailed workflows):\n\n**bugfix mode:**\n- For each issue in issue_numbers, plan to add label \"status::totesting\"\n\n**delivery mode:**\n- For each issue, plan to close with corresponding estimate\n\n**develop mode:**\n- Get first issue details\n- Create develop task with \"[Develop]\" suffix\n- Move original issue to testing\n- Close develop task with estimate\n\n**redelivery mode:**\n- No issue actions needed, skip to completion\n\n## Step 7: Confirmation and Execution\n\n**For redelivery mode:**\n- Display: \"Pipeline created successfully. No issue management for redelivery.\"\n- End workflow\n\n**For other modes:**\n- Display all planned actions in readable format\n- Ask: \"Do you want to proceed? (yes/no)\"\n- If \"yes\": Execute all actions sequentially, show progress\n- If \"no\": Abort with message about pipeline being created but issues not managed\n\n## Error Handling\n\n- Invalid issue IID: Skip and log warning, continue with others\n- API timeout: Retry once after 5 seconds, then fail\n- Authentication error: Abort immediately\n- Invalid branch: Abort before creating pipeline\n\nAlways provide:\n- What failed\n- Why it failed (if known)\n- What completed successfully\n- Suggested next steps\n\n## Output Format\n\nShow clear summary:\n```\n‚úÖ Pipeline Created\nBranch: {branch}\nScheme: {scheme}\nRecipient: {recipient}\nDescription: {description}\n\nüìã Issue Management:\n[List of planned/executed actions]\n\n‚úÖ Workflow Complete\n```\n",
        "py-plugin/skills/ios-delivery-build/examples.md": "# Workflow Examples\n\n## Example 1: Bugfix Mode\n\n**Scenario**: User has fixed bugs in issues #1234 and #1235, wants to move them to testing.\n\n**Input:**\n```\nMode: bugfix\nbranch: fix/payment-validation\nscheme: Payoo Merchant Sandbox\nissue_numbers: 1234, 1235\nrecipient: Anh ƒêo√†n|U6T100Q4S\nreply_on_thread: none\ndescription: Fix payment validation and error handling\nproject: rnd/ios/payoo-ios-app-merchant\n```\n\n**Planned Actions:**\n```\n1. Create pipeline for branch: fix/payment-validation\n2. Move issue #1234 to testing (add label: status::totesting)\n3. Move issue #1235 to testing (add label: status::totesting)\n```\n\n**MCP Tool Calls:**\n```\n1. mobile-mcp-server/gitlab-create-pipeline-for-branch\n   scheme: Payoo Merchant Sandbox\n   branchName: fix/payment-validation\n   recipient: Anh ƒêo√†n|U6T100Q4S\n   replyOnThread: none\n   description: Fix payment validation and error handling\n   project: rnd/ios/payoo-ios-app-merchant\n\n2. mobile-mcp-server/gitlab-manage-issue\n   issueIid: 1234\n   action: add-labels\n   labels: [\"status::totesting\"]\n\n3. mobile-mcp-server/gitlab-manage-issue\n   issueIid: 1235\n   action: add-labels\n   labels: [\"status::totesting\"]\n```\n\n## Example 2: Delivery Mode\n\n**Scenario**: User completed issues #1236 and #1237, wants to close them with estimates.\n\n**Input:**\n```\nMode: delivery\nbranch: feature/smart-otp\nscheme: Payoo Merchant Sandbox\nissue_numbers: 1236, 1237\nrecipient: Huy V≈©|U03UJ8026RZ\nreply_on_thread: none\ndescription: SmartOTP feature delivery\nestimates: 8h, 4h\nproject: rnd/ios/payoo-ios-app-merchant\n```\n\n**Planned Actions:**\n```\n1. Create pipeline for branch: feature/smart-otp\n2. Close issue #1236 with estimate: 8h\n3. Close issue #1237 with estimate: 4h\n```\n\n**MCP Tool Calls:**\n```\n1. mobile-mcp-server/gitlab-create-pipeline-for-branch\n   scheme: Payoo Merchant Sandbox\n   branchName: feature/smart-otp\n   recipient: Huy V≈©|U03UJ8026RZ\n   replyOnThread: none\n   description: SmartOTP feature delivery\n   project: rnd/ios/payoo-ios-app-merchant\n\n2. mobile-mcp-server/gitlab-close-task\n   taskId: 1236\n   estimates: 8h\n\n3. mobile-mcp-server/gitlab-close-task\n   taskId: 1237\n   estimates: 4h\n```\n\n## Example 3: Develop Mode\n\n**Scenario**: User completed development of issue #1238, wants to create develop task and move original to testing.\n\n**Input:**\n```\nMode: develop\nbranch: develop\nscheme: Payoo Merchant Sandbox\nissue_numbers: 1238\nrecipient: Li√™n Tr∆∞∆°ng|U01BP9QNURJ\nreply_on_thread: none\ndescription: New authentication flow\nestimates: 16h\nproject: rnd/ios/payoo-ios-app-merchant\n```\n\n**Planned Actions:**\n```\n1. Create pipeline for branch: develop\n2. Get issue #1238 details\n3. Create develop task: \"{original_title} [Develop]\"\n4. Move original issue #1238 to testing (add label: status::totesting)\n5. Close develop task with estimate: 16h\n```\n\n**MCP Tool Calls:**\n```\n1. mobile-mcp-server/gitlab-create-pipeline-for-branch\n   scheme: Payoo Merchant Sandbox\n   branchName: develop\n   recipient: Li√™n Tr∆∞∆°ng|U01BP9QNURJ\n   replyOnThread: none\n   description: New authentication flow\n   project: rnd/ios/payoo-ios-app-merchant\n\n2. mobile-mcp-server/gitlab-get-issue\n   issueIid: 1238\n   projectName: rnd/ios/payoo-ios-app-merchant\n   format: detailed\n\n3. mobile-mcp-server/gitlab-create-task-for-issue\n   issueIid: 1238\n   project: rnd/ios/payoo-ios-app-merchant\n   title: \"{original_title} [Develop]\"\n   assignee: {original_assignee}\n   labels: {original_labels + [\"status::done\"]}\n   startDate: {today}\n   dueDate: {today}\n   description: \"Created for develop mode.\\n\\n{original_description}\"\n\n4. mobile-mcp-server/gitlab-manage-issue\n   issueIid: 1238\n   action: add-labels\n   labels: [\"status::totesting\"]\n\n5. mobile-mcp-server/gitlab-close-task\n   taskId: {task_id_from_step_3}\n   estimates: 16h\n```\n\n**Note**: Only the FIRST issue in issue_numbers is processed for develop mode.\n\n## Example 4: Redelivery Mode\n\n**Scenario**: Previous delivery failed, need to rebuild and send again without changing issue status.\n\n**Input:**\n```\nMode: redelivery\nbranch: feature/smart-otp\nscheme: Payoo Merchant Sandbox\nrecipient: Vi Tr·∫ßn|ULG64G5E3\nreply_on_thread: https://payoo.slack.com/archives/C123/p1234567890\ndescription: Redelivery after fixing build issue\nproject: rnd/ios/payoo-ios-app-merchant\n```\n\n**Planned Actions:**\n```\n1. Create pipeline for branch: feature/smart-otp\n```\n\n**MCP Tool Calls:**\n```\n1. mobile-mcp-server/gitlab-create-pipeline-for-branch\n   scheme: Payoo Merchant Sandbox\n   branchName: feature/smart-otp\n   recipient: Vi Tr·∫ßn|ULG64G5E3\n   replyOnThread: https://payoo.slack.com/archives/C123/p1234567890\n   description: Redelivery after fixing build issue\n   project: rnd/ios/payoo-ios-app-merchant\n```\n\n**Output:**\n```\n‚úÖ Pipeline created successfully. No issue management for redelivery.\n```\n\n## Error Handling Examples\n\n### Example: Invalid Issue IID\n\n**Scenario**: User provides issue #9999 which doesn't exist.\n\n**Action:**\n- Skip issue #9999\n- Log warning: \"Issue #9999 not found or inaccessible, skipping\"\n- Continue with remaining valid issues\n- Show summary: \"2/3 issues processed successfully, 1 skipped\"\n\n### Example: Validation Failure\n\n**Scenario**: User provides 3 issue numbers but only 2 estimates.\n\n**Action:**\n- Abort before creating pipeline\n- Show error: \"Validation failed: 3 issues but 2 estimates provided\"\n- Request correction: \"Please provide estimates matching issue count (e.g., '2h, 3h, 4h')\"\n\n### Example: Pipeline Creation Failed\n\n**Scenario**: GitLab API returns error when creating pipeline.\n\n**Action:**\n- Abort workflow immediately\n- Display error: \"Pipeline creation failed: [error details]\"\n- Show what was NOT done: \"Issue management actions were not performed\"\n- Suggest: \"Check branch exists and you have permissions\"\n",
        "py-plugin/skills/ios-delivery-build/templates.md": "# Templates and Predefined Data\n\n## Predefined Recipients\n\nUse these exact format strings when asking user to select recipient:\n\n- Anh ƒêo√†n|U6T100Q4S\n- Huy V≈©|U03UJ8026RZ\n- Li√™n Tr∆∞∆°ng|U01BP9QNURJ\n- Vi Tr·∫ßn|ULG64G5E3\n\n## Form Templates\n\n### For Modes: develop, delivery, bugfix\n\n```\nbranch: {current_branch}\nscheme: Payoo Merchant Sandbox\nissue_numbers: 123, 456\nrecipient: Anh ƒêo√†n|U6T100Q4S\nreply_on_thread: none\ndescription: Fix authentication and payment bugs\nestimates: 2h, 3h\nproject: rnd/ios/payoo-ios-app-merchant\n```\n\n**Field Descriptions:**\n- **branch**: Git branch for pipeline (pre-filled)\n- **scheme**: Build scheme (default shown)\n- **issue_numbers**: Comma-separated GitLab issue IIDs\n- **recipient**: Select from predefined list above\n- **reply_on_thread**: Slack thread URL or \"none\"\n- **description**: Pipeline description\n- **estimates**: Comma-separated time estimates matching issue order (e.g., \"2h, 1h, 3h\")\n- **project**: GitLab project path\n\n### For Mode: redelivery\n\n```\nbranch: {current_branch}\nscheme: Payoo Merchant Sandbox\nrecipient: Anh ƒêo√†n|U6T100Q4S\nreply_on_thread: none\ndescription: Redelivery for {reason}\nproject: rnd/ios/payoo-ios-app-merchant\n```\n\n**Note**: No issue_numbers or estimates needed for redelivery.\n\n## Parsing Instructions\n\n**issue_numbers and estimates:**\n- Split by comma: \"123, 456, 789\" ‚Üí [\"123\", \"456\", \"789\"]\n- Trim whitespace from each element\n- Validate numeric for issue_numbers\n- Ensure estimates match issue count (for delivery/develop modes)\n\n**recipient format:**\n- Must match exactly: \"Name|SlackID\"\n- Validate against predefined list\n- Extract name and ID for MCP tool call\n\n**reply_on_thread:**\n- Accept \"none\" (lowercase)\n- Or valid Slack thread URL format\n- Default to \"none\" if not provided\n",
        "py-plugin/skills/ios-generate-unit-tests/SKILL.md": "---\nname: ios-generate-unit-tests\ndescription: Generate comprehensive unit tests for iOS RxSwift project files (ViewModels, UseCases, Services). Creates complete test files with nested mocks, RxTest patterns, session error handling, and memory leak tests. Use when \"generate unit tests\", \"write tests for\", \"create unit tests\", \"add tests for\", or analyzing Swift files in PayooMerchant project.\nallowed-tools: Read, Write, Glob, Grep\n---\n\n# iOS RxSwift Unit Test Generator\n\nAutomatically generate comprehensive unit tests for iOS RxSwift project following Clean Architecture patterns.\n\n## When to Activate\n\n- \"generate unit tests for [file]\"\n- \"write tests for [ViewModel/UseCase/Service]\"\n- \"create unit tests for this file\"\n- \"add tests for [class name]\"\n- \"test [file path]\"\n\n## Process\n\n### 1. Identify Target File\n\n**Ask user for file to test** (if not provided):\n```\nWhich file would you like to generate tests for?\nProvide the file path or class name (e.g., BalanceInformationViewModel.swift)\n```\n\n**Read target file** and determine type:\n- ViewModel: Has `ViewModelType`, `Input`, `Output`, `transform` method\n- UseCase: Implements `*UseCaseType` protocol\n- Service: Implements service protocol\n\n### 2. Read Testing Guide\n\n**CRITICAL**: Read the comprehensive testing guide:\n```\n~/Library/Application Support/Code/User/prompts/ios-mc-generate-unit-test.prompt.md\n```\n\nThis guide contains ALL rules, patterns, and examples to follow.\n\n### 3. Analyze Target File\n\n**Extract from target file:**\n- Class name and type (ViewModel/UseCase/Service)\n- All dependencies (injected in initializer)\n- Protocol types for each dependency\n- Public methods and their signatures\n- Input/Output structure (for ViewModels)\n- Observable/Single/Completable return types\n\n**Search for protocol definitions** if needed:\n```bash\nGlob: **/*UseCaseType.swift\nGrep: \"protocol [DependencyName]\"\n```\n\n### 4. Generate Test File\n\n**Create complete test file** at:\n```\nPayooMerchantTests/[appropriate-folder]/[ClassName]Tests.swift\n```\n\n**Folder structure:**\n- ViewModels ‚Üí `PayooMerchantTests/ViewModel/`\n- UseCases ‚Üí `PayooMerchantTests/UseCase/`\n- Services ‚Üí `PayooMerchantTests/Mock/Service/`\n\n**Test file MUST include:**\n\n1. **Required imports**:\n   ```swift\n   import XCTest\n   import RxSwift\n   import RxCocoa\n   import RxTest\n   import RxBlocking\n   import Domain\n   @testable import PayooMerchant\n   ```\n\n2. **Test class with nested mocks**:\n   - ALL mocks as `private final class` nested inside test class\n   - One mock for EACH dependency\n   - Include call tracking (`callCount`, `lastParams`)\n   - Include configurable return values\n\n3. **Properties section**:\n   - `private var disposeBag: DisposeBag!`\n   - `private var scheduler: TestScheduler!`\n   - Mock instances for each dependency\n\n4. **setUp/tearDown**:\n   - Initialize disposeBag, scheduler, all mocks\n   - Clean up all properties to nil\n\n5. **Test data factories**:\n   - Helper methods to create test entities\n   - Use default parameters\n\n6. **Comprehensive test methods**:\n   - Initial load success\n   - Load error handling\n   - Empty state\n   - Loading state\n   - Session error handling (if API calls)\n   - Memory leak test (for ViewModels)\n   - Permission tests (if applicable)\n   - User action tests\n   - State transition tests\n   - Edge cases\n\n**Follow naming convention**:\n```swift\nfunc test_methodName_condition_expectedBehavior()\n```\n\n### 5. Generate Tests Based on Type\n\n#### For ViewModels:\n- Test each Input ‚Üí Output transformation\n- Use `TestScheduler` and hot observables for inputs\n- Create observers for each output driver\n- Test loading states, errors, empty states\n- Include memory leak test:\n  ```swift\n  func test_viewModel_shouldDeallocateProperly()\n  ```\n\n#### For UseCases:\n- Test each public method\n- Mock all service dependencies\n- Test success and error scenarios\n- **CRITICAL**: Test session error handling:\n  ```swift\n  func test_catchSessionError_SessionTimeoutError_shouldSetExpiredState()\n  func test_catchSessionError_ForceUpdateError_shouldSetForceUpdateState()\n  ```\n\n#### For Services:\n- Test all CRUD operations\n- Test observable streams\n- Test data persistence\n\n### 6. Validate Generated Tests\n\n**Ensure:**\n- ‚úÖ All mocks are nested `private final class`\n- ‚úÖ Proper imports included\n- ‚úÖ setUp/tearDown with cleanup\n- ‚úÖ DisposeBag and TestScheduler used\n- ‚úÖ Descriptive test names\n- ‚úÖ Descriptive assertions with messages\n- ‚úÖ All dependencies mocked\n- ‚úÖ Session error tests for API calls\n- ‚úÖ Memory leak test for ViewModels\n\n## Output Format\n\nAfter generating tests, show:\n\n```markdown\n‚úÖ Generated Unit Tests: [ClassName]Tests.swift\n\nüìÅ Location: PayooMerchantTests/[folder]/[ClassName]Tests.swift\n\nüìä Test Coverage:\n- [X] Nested mocks created: [count]\n- [X] Test methods: [count]\n- [X] Scenarios covered:\n  ‚úì Success cases\n  ‚úì Error handling\n  ‚úì Empty states\n  ‚úì Loading states\n  ‚úì Session errors (if API)\n  ‚úì Memory leak test (if ViewModel)\n  ‚úì [Other scenarios]\n\nüéØ Test Naming Pattern:\ntest_methodName_condition_expectedBehavior\n\n‚ö° Next Steps:\n1. Review generated tests\n2. Run: xcodebuild test -scheme PayooMerchantTests\n3. Or run specific plan: bundle exec fastlane run_test_plan test_plan:\"[plan-name]\"\n\nüìñ Generated following guide: ~/Library/Application Support/Code/User/prompts/ios-mc-generate-unit-test.prompt.md\n```\n\n## Key Rules (from Testing Guide)\n\n1. **ALWAYS** create mocks as nested `private final class`\n2. **ALWAYS** use TestScheduler for ViewModels\n3. **ALWAYS** include session error tests for API calls\n4. **ALWAYS** include memory leak test for ViewModels\n5. **ALWAYS** use descriptive assertions with messages\n6. **ALWAYS** follow Arrange-Act-Assert pattern\n7. **NEVER** create global/standalone mock classes\n8. **NEVER** skip setUp/tearDown cleanup\n\n## Example Test Structure\n\n```swift\nfinal class BalanceInformationViewModelTests: XCTestCase {\n    // MARK: - Mocks\n    private final class MockBalanceUseCase: BalanceUseCaseType {\n        var getBalanceResult: Single<Balance> = .never()\n        var getBalanceCallCount = 0\n        \n        func getBalance() -> Single<Balance> {\n            getBalanceCallCount += 1\n            return getBalanceResult\n        }\n    }\n    \n    // MARK: - Properties\n    private var disposeBag: DisposeBag!\n    private var scheduler: TestScheduler!\n    private var mockBalanceUC: MockBalanceUseCase!\n    \n    // MARK: - Setup & Teardown\n    override func setUp() {\n        super.setUp()\n        disposeBag = DisposeBag()\n        scheduler = TestScheduler(initialClock: 0)\n        mockBalanceUC = MockBalanceUseCase()\n    }\n    \n    override func tearDown() {\n        disposeBag = nil\n        scheduler = nil\n        mockBalanceUC = nil\n        super.tearDown()\n    }\n    \n    // MARK: - Test Data Factory\n    private func makeTestBalance() -> Balance {\n        // ...\n    }\n    \n    // MARK: - Tests\n    func test_transform_withLoadTrigger_shouldReturnBalance() {\n        // Arrange\n        // Act\n        // Assert\n    }\n}\n```\n\n---\n\n**References:**\n- Testing Guide: `~/Library/Application Support/Code/User/prompts/ios-mc-generate-unit-test.prompt.md`\n- Project Structure: `PayooMerchantTests/`\n- Existing Tests: Use as reference for patterns\n",
        "py-plugin/skills/ios-generate-unit-tests/examples.md": "# Real-World Examples\n\nComplete examples from the Payoo Merchant iOS project.\n\n## Example 1: ViewModel with Multiple UseCases\n\n**Source**: `BalanceInformationViewModel.swift`\n\n```swift\nfinal class BalanceInformationViewModelTests: XCTestCase {\n    // MARK: - Mocks\n    \n    private final class MockBalanceInformationUseCase: BalanceInformationUseCaseType {\n        var getBalanceInfoResult: Single<BalanceInfoResponse> = .never()\n        var getBalanceHistoryResult: Single<BalanceHistoryResponse> = .never()\n        var getBalanceInfoCallCount = 0\n        var getBalanceHistoryCallCount = 0\n        var lastGetBalanceHistoryParams: (fromDate: String, toDate: String, layerId: Int)?\n\n        func getBalanceInfo() -> Single<BalanceInfoResponse> {\n            getBalanceInfoCallCount += 1\n            return getBalanceInfoResult\n        }\n\n        func getBalanceHistory(fromDate: String, toDate: String, layerId: Int) -> Single<BalanceHistoryResponse> {\n            getBalanceHistoryCallCount += 1\n            lastGetBalanceHistoryParams = (fromDate, toDate, layerId)\n            return getBalanceHistoryResult\n        }\n    }\n\n    private final class MockFeaturesUseCase: FeaturesUseCaseType {\n        var executeReturnValue: Observable<[Feature]> = .just([])\n        var checkPermissionResult: Bool = true\n        var lastCheckedFeature: Feature?\n\n        func execute() -> Observable<[Feature]> {\n            executeReturnValue\n        }\n\n        func checkPermissionForView(feature: Feature) -> Bool {\n            lastCheckedFeature = feature\n            return checkPermissionResult\n        }\n    }\n\n    // MARK: - Properties\n    private var disposeBag: DisposeBag!\n    private var scheduler: TestScheduler!\n    private var mockBalanceUC: MockBalanceInformationUseCase!\n    private var mockFeaturesUC: MockFeaturesUseCase!\n\n    override func setUp() {\n        super.setUp()\n        disposeBag = DisposeBag()\n        scheduler = TestScheduler(initialClock: 0)\n        mockBalanceUC = MockBalanceInformationUseCase()\n        mockFeaturesUC = MockFeaturesUseCase()\n    }\n\n    override func tearDown() {\n        disposeBag = nil\n        scheduler = nil\n        mockBalanceUC = nil\n        mockFeaturesUC = nil\n        super.tearDown()\n    }\n\n    // MARK: - Test Data Factory\n    \n    private func makeTestBalanceLayerInfo(\n        layerId: Int = 1,\n        layerName: String = \"Main Account\",\n        balance: Double = 1000000.0,\n        description: String = \"Main account description\"\n    ) -> BalanceLayerInfo {\n        return BalanceLayerInfo(\n            layerId: layerId,\n            layerName: layerName,\n            balance: balance,\n            description: description\n        )\n    }\n    \n    private func makeTestBalanceInfoResponse(\n        balances: [BalanceLayerInfo]? = nil,\n        availableBalance: Double = 1500000.0,\n        minimumBalance: Double? = 100000.0\n    ) -> BalanceInfoResponse {\n        let defaultBalances = [\n            makeTestBalanceLayerInfo(layerId: 1, layerName: \"Main Account\", balance: 1000000.0),\n            makeTestBalanceLayerInfo(layerId: 2, layerName: \"Savings\", balance: 500000.0)\n        ]\n        return BalanceInfoResponse(\n            balances: balances ?? defaultBalances,\n            availableBalance: availableBalance,\n            minimumBalance: minimumBalance\n        )\n    }\n\n    private func makeViewModel() -> BalanceInformationViewModel {\n        return BalanceInformationViewModel(\n            balanceUC: mockBalanceUC,\n            featuresUC: mockFeaturesUC\n        )\n    }\n\n    // MARK: - Tests\n\n    func test_transform_withSuccessfulBalanceInfoLoad_shouldDisplayBalanceData() {\n        // Arrange\n        let viewModel = makeViewModel()\n        let testBalanceInfo = makeTestBalanceInfoResponse()\n        \n        let loadBalanceInfoTrigger = scheduler.createHotObservable([\n            .next(10, ())\n        ])\n\n        let input = BalanceInformationViewModel.Input(\n            actionTrigger: .never(),\n            loadBalanceInfoTrigger: loadBalanceInfoTrigger.asObservable(),\n            loadMoreHistoryTrigger: .never(),\n            refreshHistoryTrigger: .never(),\n            validateFeatureTrigger: .never(),\n            showHUDLoading: .never()\n        )\n\n        // Mock successful balance info response\n        mockBalanceUC.getBalanceInfoResult = .just(testBalanceInfo)\n        mockBalanceUC.getBalanceHistoryResult = .just(BalanceHistoryResponse(histories: []))\n        mockFeaturesUC.checkPermissionResult = true\n\n        // Act\n        let output = viewModel.transform(input: input)\n        let observer = scheduler.createObserver([BalanceInformationViewModel.Item].self)\n        \n        output.items\n            .drive(observer)\n            .disposed(by: disposeBag)\n\n        scheduler.start()\n\n        // Assert\n        XCTAssertEqual(observer.events.count, 1)\n        let items = observer.events[0].value.element!\n        \n        let keyValueItems = items.compactMap { item -> (String, String)? in\n            if case .keyAndValue(let title, let value) = item {\n                return (title, value)\n            }\n            return nil\n        }\n        \n        XCTAssertEqual(keyValueItems.count, 2)\n        XCTAssertEqual(keyValueItems[0].0, L10n.balanceInformationAvailableBalance())\n        XCTAssertEqual(keyValueItems[0].1, 1500000.0.currencyString)\n        XCTAssertEqual(mockBalanceUC.getBalanceInfoCallCount, 1)\n    }\n\n    func test_viewModel_shouldDeallocateProperly() {\n        // Arrange\n        weak var weakViewModel: BalanceInformationViewModel?\n        \n        // Act\n        autoreleasepool {\n            let viewModel = BalanceInformationViewModel(\n                balanceUC: mockBalanceUC,\n                featuresUC: mockFeaturesUC\n            )\n            weakViewModel = viewModel\n            \n            let input = BalanceInformationViewModel.Input(\n                actionTrigger: .never(),\n                loadBalanceInfoTrigger: .never(),\n                loadMoreHistoryTrigger: .never(),\n                refreshHistoryTrigger: .never(),\n                validateFeatureTrigger: .never(),\n                showHUDLoading: .never()\n            )\n            \n            _ = viewModel.transform(input: input)\n        }\n        \n        // Assert\n        XCTAssertNil(weakViewModel, \"ViewModel should be deallocated\")\n    }\n}\n```\n\n## Example 2: UseCase with Session Error Handling\n\n**Source**: `SessionUseCaseTests.swift`\n\n```swift\nclass SessionUseCaseTests: XCTestCase {\n    // MARK: - Mocks\n    \n    private final class MockKeyChainService: KeyChainService {\n        var getDeviceModelIdentifierReturnValue: String = \"\"\n        var getPasscodeReturnValue: String = \"\"\n        var clearLoginCalled = false\n        \n        func getDeviceModelIdentifier() -> String {\n            return getDeviceModelIdentifierReturnValue\n        }\n        \n        func clearLoginDataWithLastLoginInfo() {\n            clearLoginCalled = true\n        }\n        \n        // ... implement all required protocol methods\n    }\n    \n    private final class MockUserDefaultsService: UserDefaultsServiceType {\n        var resetCalled = false\n        \n        func reset() {\n            resetCalled = true\n        }\n    }\n    \n    // MARK: - Properties\n    var useCase: SessionUseCase!\n    var mockKeychainService: MockKeyChainService!\n    var mockUserDefaultsService: MockUserDefaultsService!\n    var disposeBag: DisposeBag!\n    \n    override func setUp() {\n        super.setUp()\n        mockKeychainService = MockKeyChainService()\n        mockUserDefaultsService = MockUserDefaultsService()\n        AppController.shared.state = .loading\n        useCase = SessionUseCase(\n            keychainService: mockKeychainService,\n            appController: AppController.shared,\n            userDefaultsService: mockUserDefaultsService\n        )\n        disposeBag = DisposeBag()\n    }\n    \n    override func tearDown() {\n        useCase = nil\n        mockKeychainService = nil\n        mockUserDefaultsService = nil\n        disposeBag = nil\n        AppController.shared.state = .loading\n        super.tearDown()\n    }\n    \n    func testCatchSessionError_SessionTimeoutError_Completable() {\n        // Arrange\n        AppController.shared.state = .loading\n        let sessionUC = useCase!\n        let error = SessionTimeoutError()\n        let completable = Completable.error(error)\n        let expectation = self.expectation(description: \"Should call revoke and set state expired\")\n        var didComplete = false\n        var didError: Error?\n        \n        // Act\n        let disposable = AppController.shared.rx.state\n            .filter { $0 == .expired }\n            .take(1)\n            .subscribe(onNext: { _ in\n                expectation.fulfill()\n            })\n        \n        completable.catchSessionError(sessionUC)\n            .subscribe(onCompleted: {\n                didComplete = true\n            }, onError: { err in\n                didError = err\n            })\n            .disposed(by: disposeBag)\n        \n        // Assert\n        waitForExpectations(timeout: 1.0)\n        disposable.dispose()\n        XCTAssertFalse(didComplete)\n        XCTAssertNil(didError)\n        XCTAssertEqual(AppController.shared.state, .expired)\n    }\n    \n    func testCatchSessionError_ForceUpdateError_Single() {\n        // Arrange\n        AppController.shared.state = .loading\n        let sessionUC = useCase!\n        let error = ForceUpdateError()\n        let single = Single<Int>.error(error)\n        let expectation = self.expectation(description: \"Should call forceUpdate and return never\")\n        var didEmit = false\n        var didError: Error?\n        \n        // Act\n        let disposable = AppController.shared.rx.state\n            .filter { $0 == .forceUpdate }\n            .take(1)\n            .subscribe(onNext: { _ in\n                expectation.fulfill()\n            })\n        \n        single.catchSessionError(sessionUC)\n            .subscribe(onSuccess: { _ in\n                didEmit = true\n            }, onError: { err in\n                didError = err\n            })\n            .disposed(by: disposeBag)\n        \n        // Assert\n        waitForExpectations(timeout: 1.0)\n        disposable.dispose()\n        XCTAssertFalse(didEmit)\n        XCTAssertNil(didError)\n        XCTAssertEqual(AppController.shared.state, .forceUpdate)\n    }\n}\n```\n\n## Example 3: ViewModel Without API Calls (Simple Transform)\n\n**Source**: `BalanceHistoryDetailViewModel.swift`\n\n```swift\nfinal class BalanceHistoryDetailViewModelTests: XCTestCase {\n    private var disposeBag: DisposeBag!\n    private var scheduler: TestScheduler!\n\n    override func setUp() {\n        super.setUp()\n        disposeBag = DisposeBag()\n        scheduler = TestScheduler(initialClock: 0)\n    }\n\n    override func tearDown() {\n        disposeBag = nil\n        scheduler = nil\n        super.tearDown()\n    }\n\n    // MARK: - Test Data Factory\n    \n    private func makeTestBalanceHistoryItem(\n        id: Int = 123,\n        createdDate: String = \"2025-12-25 10:30:00\",\n        direction: BalanceDirection = .moneyIn,\n        transactionType: BalanceTransactionType = .typeA,\n        transactionName: String = \"Test Transaction\",\n        amount: Double = 100000.0,\n        balanceAfter: Double = 500000.0,\n        sourceName: String = \"Test Source\"\n    ) -> BalanceHistoryItem {\n        return BalanceHistoryItem(\n            id: id,\n            createdDate: createdDate,\n            direction: direction,\n            transactionType: transactionType,\n            transactionName: transactionName,\n            amount: amount,\n            balanceAfter: balanceAfter,\n            sourceName: sourceName\n        )\n    }\n    \n    private func makeTestLayer(\n        layerId: Int = 1,\n        layerName: String = \"Test Layer\",\n        balance: Double = 500000.0,\n        description: String = \"Test Layer Description\"\n    ) -> BalanceLayerInfo {\n        return BalanceLayerInfo(\n            layerId: layerId,\n            layerName: layerName,\n            balance: balance,\n            description: description\n        )\n    }\n\n    // MARK: - Tests\n\n    func test_transform_withLoadTrigger_shouldReturnCorrectInfoItems() {\n        // Arrange\n        let testItem = makeTestBalanceHistoryItem()\n        let testLayer = makeTestLayer()\n        let viewModel = BalanceHistoryDetailViewModel(\n            balanceHistoryItem: testItem,\n            layer: testLayer\n        )\n\n        let loadTrigger = scheduler.createHotObservable([\n            .next(10, ())\n        ])\n\n        let input = BalanceHistoryDetailViewModel.Input(\n            loadTrigger: loadTrigger.asObservable()\n        )\n\n        // Act\n        let output = viewModel.transform(input: input)\n        let observer = scheduler.createObserver([InfoModel].self)\n        \n        output.items\n            .drive(observer)\n            .disposed(by: disposeBag)\n\n        scheduler.start()\n\n        // Assert\n        XCTAssertEqual(observer.events.count, 1)\n        \n        let items = observer.events[0].value.element!\n        XCTAssertEqual(items.count, 7, \"Should have 7 info items\")\n        \n        // Verify each item content\n        if let keyValueItem = items[0] as? DefaultLayoutInfoModel {\n            XCTAssertEqual(keyValueItem.title, L10n.balanceInformationAccountType())\n            XCTAssertEqual(keyValueItem.content, \"Test Layer\")\n        } else {\n            XCTFail(\"First item should be DefaultLayoutInfoModel for account type\")\n        }\n    }\n}\n```\n\n## Key Patterns from Examples\n\n1. **Nested Mocks**: All mocks are `private final class` inside test class\n2. **Call Tracking**: `callCount` and `lastParams` for verification\n3. **Test Data Factories**: Helper methods with default parameters\n4. **Descriptive Assertions**: Messages explain what should happen\n5. **Arrange-Act-Assert**: Clear separation in each test\n6. **Proper Cleanup**: All properties set to nil in tearDown\n7. **TestScheduler**: Hot observables for inputs, observers for outputs\n",
        "py-plugin/skills/ios-generate-unit-tests/templates.md": "# Test Templates\n\nComplete templates for generating iOS RxSwift unit tests.\n\n## ViewModel Test Template\n\n```swift\n//\n//  {{ClassName}}Tests.swift\n//  PayooMerchantTests\n//\n//  Created by Claude Code on {{Date}}.\n//  Copyright ¬© {{Year}} VietUnion. All rights reserved.\n//\n\nimport XCTest\nimport RxSwift\nimport RxCocoa\nimport RxTest\nimport RxBlocking\nimport Domain\n@testable import PayooMerchant\n\nfinal class {{ClassName}}Tests: XCTestCase {\n    // MARK: - Mocks\n    \n    {{#each dependencies}}\n    private final class Mock{{name}}: {{protocolName}} {\n        {{#each methods}}\n        var {{name}}Result: {{returnType}} = {{defaultValue}}\n        var {{name}}CallCount = 0\n        {{#if hasParams}}\n        var last{{capitalizedName}}Params: {{paramsType}}?\n        {{/if}}\n        \n        func {{signature}} {\n            {{name}}CallCount += 1\n            {{#if hasParams}}\n            last{{capitalizedName}}Params = {{params}}\n            {{/if}}\n            return {{name}}Result\n        }\n        {{/each}}\n    }\n    {{/each}}\n    \n    // MARK: - Properties\n    private var disposeBag: DisposeBag!\n    private var scheduler: TestScheduler!\n    {{#each dependencies}}\n    private var mock{{name}}: Mock{{name}}!\n    {{/each}}\n    \n    // MARK: - Setup & Teardown\n    override func setUp() {\n        super.setUp()\n        disposeBag = DisposeBag()\n        scheduler = TestScheduler(initialClock: 0)\n        {{#each dependencies}}\n        mock{{name}} = Mock{{name}}()\n        {{/each}}\n    }\n    \n    override func tearDown() {\n        disposeBag = nil\n        scheduler = nil\n        {{#each dependencies}}\n        mock{{name}} = nil\n        {{/each}}\n        super.tearDown()\n    }\n    \n    // MARK: - Test Data Factory\n    {{#each entities}}\n    private func makeTest{{name}}(\n        {{#each fields}}\n        {{name}}: {{type}} = {{defaultValue}}{{#unless @last}},{{/unless}}\n        {{/each}}\n    ) -> {{name}} {\n        return {{name}}(\n            {{#each fields}}\n            {{name}}: {{name}}{{#unless @last}},{{/unless}}\n            {{/each}}\n        )\n    }\n    {{/each}}\n    \n    private func makeViewModel() -> {{ClassName}} {\n        return {{ClassName}}(\n            {{#each dependencies}}\n            {{paramName}}: mock{{name}}{{#unless @last}},{{/unless}}\n            {{/each}}\n        )\n    }\n    \n    // MARK: - Tests\n    \n    func test_transform_withLoadTrigger_shouldReturnData() {\n        // Arrange\n        let viewModel = makeViewModel()\n        let loadTrigger = scheduler.createHotObservable([\n            .next(10, ())\n        ])\n        \n        let input = {{ClassName}}.Input(\n            loadTrigger: loadTrigger.asObservable()\n        )\n        \n        mock{{primaryDependency}}.{{primaryMethod}}Result = .just(makeTest{{entity}}())\n        \n        // Act\n        let output = viewModel.transform(input: input)\n        let observer = scheduler.createObserver({{outputType}}.self)\n        \n        output.{{outputProperty}}\n            .drive(observer)\n            .disposed(by: disposeBag)\n        \n        scheduler.start()\n        \n        // Assert\n        XCTAssertEqual(observer.events.count, 1, \"Should emit once\")\n        XCTAssertNotNil(observer.events[0].value.element, \"Should have data\")\n        XCTAssertEqual(mock{{primaryDependency}}.{{primaryMethod}}CallCount, 1, \"Should call API once\")\n    }\n    \n    func test_transform_withLoadError_shouldDisplayError() {\n        // Arrange\n        let viewModel = makeViewModel()\n        let testError = NSError(domain: \"TestError\", code: -1,\n                               userInfo: [NSLocalizedDescriptionKey: \"Network error\"])\n        let loadTrigger = scheduler.createHotObservable([\n            .next(10, ())\n        ])\n        \n        let input = {{ClassName}}.Input(\n            loadTrigger: loadTrigger.asObservable()\n        )\n        \n        mock{{primaryDependency}}.{{primaryMethod}}Result = .error(testError)\n        \n        // Act\n        let output = viewModel.transform(input: input)\n        let observer = scheduler.createObserver(String.self)\n        \n        output.error\n            .drive(observer)\n            .disposed(by: disposeBag)\n        \n        scheduler.start()\n        \n        // Assert\n        XCTAssertEqual(observer.events.count, 1, \"Should emit error\")\n        let error = observer.events[0].value.element!\n        XCTAssertEqual(error, testError.getDescription(), \"Should display error message\")\n    }\n    \n    func test_transform_withEmptyData_shouldDisplayEmptyMessage() {\n        // Arrange\n        let viewModel = makeViewModel()\n        let loadTrigger = scheduler.createHotObservable([\n            .next(10, ())\n        ])\n        \n        let input = {{ClassName}}.Input(\n            loadTrigger: loadTrigger.asObservable()\n        )\n        \n        mock{{primaryDependency}}.{{primaryMethod}}Result = .just([])\n        \n        // Act\n        let output = viewModel.transform(input: input)\n        let observer = scheduler.createObserver({{outputType}}.self)\n        \n        output.{{outputProperty}}\n            .drive(observer)\n            .disposed(by: disposeBag)\n        \n        scheduler.start()\n        \n        // Assert\n        let items = observer.events[0].value.element!\n        XCTAssertTrue(items.isEmpty, \"Should be empty\")\n    }\n    \n    func test_transform_withLoadingTriggers_shouldShowLoadingState() {\n        // Arrange\n        let viewModel = makeViewModel()\n        let loadTrigger = scheduler.createHotObservable([\n            .next(10, ())\n        ])\n        \n        let input = {{ClassName}}.Input(\n            loadTrigger: loadTrigger.asObservable()\n        )\n        \n        mock{{primaryDependency}}.{{primaryMethod}}Result = .just(makeTest{{entity}}())\n            .delay(.seconds(1), scheduler: scheduler)\n        \n        // Act\n        let output = viewModel.transform(input: input)\n        let loadingObserver = scheduler.createObserver(Bool.self)\n        \n        output.isLoading\n            .drive(loadingObserver)\n            .disposed(by: disposeBag)\n        \n        scheduler.start()\n        \n        // Assert\n        XCTAssertTrue(loadingObserver.events.count >= 1, \"Should emit loading states\")\n    }\n    \n    func test_viewModel_shouldDeallocateProperly() {\n        // Arrange\n        weak var weakViewModel: {{ClassName}}?\n        \n        // Act\n        autoreleasepool {\n            let viewModel = {{ClassName}}(\n                {{#each dependencies}}\n                {{paramName}}: mock{{name}}{{#unless @last}},{{/unless}}\n                {{/each}}\n            )\n            weakViewModel = viewModel\n            \n            let input = {{ClassName}}.Input(\n                loadTrigger: .never()\n            )\n            _ = viewModel.transform(input: input)\n        }\n        \n        // Assert\n        XCTAssertNil(weakViewModel, \"ViewModel should be deallocated\")\n    }\n}\n```\n\n## UseCase Test Template\n\n```swift\n//\n//  {{ClassName}}Tests.swift\n//  PayooMerchantTests\n//\n//  Created by Claude Code on {{Date}}.\n//  Copyright ¬© {{Year}} VietUnion. All rights reserved.\n//\n\nimport XCTest\nimport RxSwift\nimport Domain\n\nclass {{ClassName}}Tests: XCTestCase {\n    // MARK: - Mocks\n    \n    {{#each services}}\n    private final class Mock{{name}}: {{protocolName}} {\n        {{#each methods}}\n        var {{name}}ReturnValue: {{returnType}} = {{defaultValue}}\n        var {{name}}CallCount = 0\n        \n        func {{signature}} {\n            {{name}}CallCount += 1\n            return {{name}}ReturnValue\n        }\n        {{/each}}\n    }\n    {{/each}}\n    \n    // MARK: - Properties\n    var useCase: {{ClassName}}!\n    {{#each services}}\n    var mock{{name}}: Mock{{name}}!\n    {{/each}}\n    var disposeBag: DisposeBag!\n    \n    // MARK: - Setup & Teardown\n    override func setUp() {\n        super.setUp()\n        {{#each services}}\n        mock{{name}} = Mock{{name}}()\n        {{/each}}\n        useCase = {{ClassName}}(\n            {{#each services}}\n            {{paramName}}: mock{{name}}{{#unless @last}},{{/unless}}\n            {{/each}}\n        )\n        disposeBag = DisposeBag()\n    }\n    \n    override func tearDown() {\n        useCase = nil\n        {{#each services}}\n        mock{{name}} = nil\n        {{/each}}\n        disposeBag = nil\n        super.tearDown()\n    }\n    \n    // MARK: - Tests\n    \n    func test_{{methodName}}_withValidParams_shouldReturnSuccess() {\n        // Arrange\n        let expectation = self.expectation(description: \"Should complete successfully\")\n        let testData = {{testDataCreation}}\n        mock{{service}}.{{method}}ReturnValue = .just(testData)\n        \n        var result: {{resultType}}?\n        var didComplete = false\n        \n        // Act\n        useCase.{{methodName}}({{params}})\n            .subscribe(onSuccess: { data in\n                result = data\n                didComplete = true\n                expectation.fulfill()\n            }, onError: { _ in\n                expectation.fulfill()\n            })\n            .disposed(by: disposeBag)\n        \n        // Assert\n        waitForExpectations(timeout: 1.0)\n        XCTAssertTrue(didComplete, \"Should complete successfully\")\n        XCTAssertNotNil(result, \"Should return data\")\n        XCTAssertEqual(mock{{service}}.{{method}}CallCount, 1, \"Should call service once\")\n    }\n    \n    func test_{{methodName}}_withError_shouldReturnError() {\n        // Arrange\n        let expectation = self.expectation(description: \"Should fail with error\")\n        let testError = NSError(domain: \"TestError\", code: -1)\n        mock{{service}}.{{method}}ReturnValue = .error(testError)\n        \n        var didError = false\n        \n        // Act\n        useCase.{{methodName}}({{params}})\n            .subscribe(onSuccess: { _ in\n                expectation.fulfill()\n            }, onError: { error in\n                didError = true\n                expectation.fulfill()\n            })\n            .disposed(by: disposeBag)\n        \n        // Assert\n        waitForExpectations(timeout: 1.0)\n        XCTAssertTrue(didError, \"Should fail with error\")\n    }\n    \n    {{#if hasSessionUseCase}}\n    func test_catchSessionError_SessionTimeoutError_shouldSetExpiredState() {\n        // Arrange\n        AppController.shared.state = .loading\n        let sessionUC = mock{{sessionUseCase}}!\n        let error = SessionTimeoutError()\n        let single = Single<{{dataType}}>.error(error)\n        let expectation = self.expectation(description: \"Should set state expired\")\n        \n        // Act\n        let disposable = AppController.shared.rx.state\n            .filter { $0 == .expired }\n            .take(1)\n            .subscribe(onNext: { _ in\n                expectation.fulfill()\n            })\n        \n        single.catchSessionError(sessionUC)\n            .subscribe()\n            .disposed(by: disposeBag)\n        \n        // Assert\n        waitForExpectations(timeout: 1.0)\n        disposable.dispose()\n        XCTAssertEqual(AppController.shared.state, .expired)\n    }\n    \n    func test_catchSessionError_ForceUpdateError_shouldSetForceUpdateState() {\n        // Arrange\n        AppController.shared.state = .loading\n        let sessionUC = mock{{sessionUseCase}}!\n        let error = ForceUpdateError()\n        let completable = Completable.error(error)\n        let expectation = self.expectation(description: \"Should set force update\")\n        \n        // Act\n        let disposable = AppController.shared.rx.state\n            .filter { $0 == .forceUpdate }\n            .take(1)\n            .subscribe(onNext: { _ in\n                expectation.fulfill()\n            })\n        \n        completable.catchSessionError(sessionUC)\n            .subscribe()\n            .disposed(by: disposeBag)\n        \n        // Assert\n        waitForExpectations(timeout: 1.0)\n        disposable.dispose()\n        XCTAssertEqual(AppController.shared.state, .forceUpdate)\n    }\n    {{/if}}\n}\n```\n\n## Mock Template\n\n```swift\nprivate final class Mock{{name}}: {{protocolName}} {\n    // Return values\n    {{#each methods}}\n    var {{name}}Result: {{returnType}} = {{defaultReturnValue}}\n    {{/each}}\n    \n    // Call tracking\n    {{#each methods}}\n    var {{name}}CallCount = 0\n    {{#if hasParams}}\n    var last{{capitalizedName}}Params: {{paramsType}}?\n    {{/if}}\n    {{/each}}\n    \n    // Protocol implementation\n    {{#each methods}}\n    func {{signature}} {\n        {{name}}CallCount += 1\n        {{#if hasParams}}\n        last{{capitalizedName}}Params = {{paramsTuple}}\n        {{/if}}\n        return {{name}}Result\n    }\n    {{/each}}\n}\n```\n\n## Test Data Factory Template\n\n```swift\n// MARK: - Test Data Factory\n\nprivate func makeTest{{entityName}}(\n    {{#each fields}}\n    {{name}}: {{type}} = {{defaultValue}}{{#unless @last}},{{/unless}}\n    {{/each}}\n) -> {{entityName}} {\n    return {{entityName}}(\n        {{#each fields}}\n        {{name}}: {{name}}{{#unless @last}},{{/unless}}\n        {{/each}}\n    )\n}\n```\n\n## Common Default Values\n\n```swift\n// RxSwift Observable defaults\n.never()        // For not triggering\n.just([])       // For empty Observable\n.just(value)    // For Single success\n.error(error)   // For errors\n.empty()        // For Completable\n\n// Common test values\nid: 1\nname: \"Test Name\"\namount: 100000.0\ndate: \"2025-12-25 10:30:00\"\nisEnabled: true\ncount: 0\n```\n",
        "py-plugin/skills/ios-instruments-performance-cli/SKILL.md": "---\nname: ios-instruments-performance-cli\ndescription: Use Xcode Instruments command line tools to analyze iOS app performance, detect memory leaks, optimize launch times, monitor CPU usage, and identify performance bottlenecks for the iOS project\nallowed-tools: Bash, Read, Write\n---\n\n# iOS Instruments Performance CLI\n\n## Instructions\n\nWhen helping with iOS app performance optimization using Instruments command line tools:\n\n### 1. Setup Analysis Environment\n\n**CRITICAL: Always use device UUID, never device names**\n\n- Get device UUID: `xcrun simctl list devices available | grep \"iPhone\"`\n- Device names like \"iPhone 17 Pro\" are ambiguous and will fail\n- Use UUID format: `F464E766-555C-4B95-B8CC-763702A70791`\n\n**Clean installation state (REQUIRED)**\n\n- Always uninstall app before profiling: `xcrun simctl uninstall $DEVICE_UUID <bundle id>`\n- Multiple app installations cause \"process is ambiguous\" errors\n- Alternative: Completely erase simulator for cleanest state\n\n**Build configuration**\n\n- Build in Release mode for accurate performance measurements\n\n### 2. Choose Appropriate Instrument Template\n\nUse `xcrun xctrace list templates` to see available templates:\n\n- **App Launch** - Essential for launch time optimization (most common)\n- **Time Profiler** - CPU performance analysis\n- **Allocations** - Memory usage tracking\n- **Leaks** - Memory leak detection\n- **Network** - API calls and network activity\n- **Animation Hitches** - UI performance issues\n\n### 3. Run Performance Analysis\n\n**Standard workflow:**\n\n```bash\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\" # this is sample uuid, run command line to get exist uuid\nxcrun simctl uninstall $DEVICE_UUID <bundle id>\nxcrun simctl install $DEVICE_UUID /path/to/<app name>.app\nsleep 2\nxcrun xctrace record --template \"App Launch\" --device $DEVICE_UUID \\\n  --launch -- /path/to/<app name>.app 2>&1\n```\n\n**Important notes:**\n\n- Trace files auto-generate names like `Launch_<app name>.app_2025-10-30_3.55.40 PM_39E6A410.trace`\n- `--output` parameter may be ignored; accept auto-generated names\n- Wait 2 seconds after installation before profiling\n- Use `2>&1` to capture all output\n- Recording duration: 10-30s for launch, 2-5m for other analyses\n\n### 4. Analyze Results\n\n**Finding trace files:**\n\n```bash\nls -lt *.trace | head -1  # Most recent trace\nfind . -name \"*.trace\" -type d -mmin -5  # Files from last 5 minutes\n```\n\n**Analysis approaches:**\n\n- **CLI export often fails** - \"trace is malformed\" errors are common\n- **Recommended**: Open in Instruments.app GUI for reliable analysis\n\n  ```bash\n  open -a Instruments.app Launch_<app name>*.trace\n  ```\n\n- Parse signpost markers for performance metrics\n- Identify bottlenecks in launch sequence, memory allocations, CPU hotspots\n\n### 5. Common Optimization Patterns\n\nBased on successful optimizations:\n\n- **Lazy initialization** - Defer expensive dependency resolution\n- **Background operations** - Move non-critical setup off main thread\n- **Deferred bindings** - Set up subscriptions after UI appears\n- **Font loading** - Register fonts asynchronously\n- **Method swizzling** - Only essential swizzles during launch\n\n### Critical Pitfalls to Avoid\n\n‚ùå Using device names instead of UUIDs\n‚ùå Skipping clean installation step\n‚ùå Building in Debug mode\n‚ùå Trying to export trace immediately after recording\n‚ùå Assuming --output path will be used\n‚ùå Not waiting between installation and profiling\n\n### Reference Documentation\n\nSee [examples](./examples.md) in this skill directory for:\n\n- Detailed command examples with correct syntax\n- Complete troubleshooting guide with solutions\n- Real-world lessons learned\n- Production-ready workflow scripts\n",
        "py-plugin/skills/ios-instruments-performance-cli/examples.md": "# XCTrace & Instruments Examples for iOS project\n\n## Quick Reference - Working Commands ‚úÖ\n\nThese commands have been tested and verified to work correctly:\n\n```bash\n# Get device UUID (always required)\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\"  # iPhone 17 Pro\nxcrun simctl list devices available | grep \"iPhone\"\n\n# App Launch Profiling (most common use case)\nxcrun simctl uninstall $DEVICE_UUID <bundle id>\nxcrun simctl install $DEVICE_UUID /Users/daipham/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app\nsleep 2\nxcrun xctrace record --template \"App Launch\" --device $DEVICE_UUID \\\n  --launch -- /Users/daipham/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app 2>&1\n\n# Find generated trace file\nls -lt *.trace | head -1\n\n# Open in Instruments for analysis\nopen -a Instruments.app Launch_<app name>*.trace\n```\n\n## XCTrace Overview\n\n`xcrun xctrace` is the modern command-line interface for Instruments profiling. It replaces the deprecated `instruments` command and provides more reliable automation capabilities.\n\n## Available Templates\n\nRun `xcrun xctrace list templates` to see all available templates:\n\n### Standard Templates\n\n- **Activity Monitor**: General system activity monitoring\n- **Allocations**: Memory allocation tracking\n- **Animation Hitches**: UI animation performance issues\n- **App Launch**: App startup performance analysis\n- **Audio System Trace**: Audio subsystem performance\n- **CPU Counters**: Hardware performance counters\n- **CPU Profiler**: CPU usage profiling\n- **Core ML**: Machine learning model performance\n- **Data Persistence**: Core Data and file I/O analysis\n- **File Activity**: File system operations\n- **Game Memory**: Game-specific memory analysis\n- **Game Performance**: Game-specific performance metrics\n- **Game Performance Overview**: High-level game metrics\n- **Leaks**: Memory leak detection\n- **Logging**: System and app logging analysis\n- **Metal System Trace**: GPU performance analysis\n- **Network**: Network activity monitoring\n- **Power Profiler**: Energy consumption analysis\n- **Processor Trace**: Low-level CPU tracing\n- **RealityKit Trace**: AR/VR performance analysis\n- **Swift Concurrency**: Swift async/await performance\n- **SwiftUI**: SwiftUI-specific performance analysis\n- **System Trace**: System-wide performance analysis\n- **Tailspin**: System responsiveness analysis\n- **Time Profiler**: CPU time profiling\n\n## Device Management\n\n### List Available Devices\n\n```bash\n# List all devices (physical and simulators)\nxcrun xctrace list devices\n\n# List only simulators with UUIDs (RECOMMENDED)\nxcrun simctl list devices available | grep \"iPhone\"\n```\n\n### Current Available Devices for <app scheme>\n\n- **Simulators**: iPhone 16 Pro, iPhone 16, iPhone 17 Pro (F464E766-555C-4B95-B8CC-763702A70791), iPad variants, etc.\n\n### ‚ö†Ô∏è IMPORTANT: Always Use Device UUID, Not Name\n\nDevice names can be ambiguous. **Always use the device UUID** for reliable automation:\n\n```bash\n# ‚ùå WRONG - Ambiguous device name\nxcrun xctrace record --template \"App Launch\" --device \"iPhone 16 Pro\" ...\n\n# ‚úÖ CORRECT - Use UUID\nxcrun xctrace record --template \"App Launch\" --device F464E766-555C-4B95-B8CC-763702A70791 ...\n```\n\n## Basic XCTrace Commands\n\n### 1. App Launch Performance Analysis\n\n```bash\n# ‚úÖ CORRECT METHOD - Clean state, use UUID, proper app path handling\n# Step 1: Get device UUID\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\"  # iPhone 17 Pro\n\n# Step 2: Clean up any existing app installations (IMPORTANT to avoid ambiguity)\nxcrun simctl uninstall $DEVICE_UUID <bundle id>\n\n# Step 3: Install fresh app build\nxcrun simctl install $DEVICE_UUID /Users/daipham/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app\n\n# Step 4: Wait for installation to complete\nsleep 2\n\n# Step 5: Profile app launch\nxcrun xctrace record --template \"App Launch\" \\\n  --device $DEVICE_UUID \\\n  --launch -- /Users/daipham/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app \\\n  --output ~/Desktop/<app name>_launch_analysis.trace 2>&1\n\n# Note: Trace file will be saved with auto-generated name in current directory\n# Example: Launch_<app name>.app_2025-10-30_3.55.40 PM_39E6A410.trace\n```\n\n**Alternative: Complete Clean State (Most Reliable)**\n\n```bash\n# For most reliable results, completely erase and reboot simulator\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\"\n\nxcrun simctl shutdown $DEVICE_UUID\nxcrun simctl erase $DEVICE_UUID\nxcrun simctl boot $DEVICE_UUID\nxcrun simctl install $DEVICE_UUID /Users/daipham/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app\nsleep 2\nxcrun xctrace record --template \"App Launch\" --device $DEVICE_UUID \\\n  --launch -- /Users/daipham/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app \\\n  2>&1\n```\n\n### 2. Memory Allocation Tracking\n\n```bash\n# ‚úÖ Track memory allocations during app usage\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\"\n\n# Option 1: Attach to running app\nxcrun xctrace record --template \"Allocations\" \\\n  --device $DEVICE_UUID \\\n  --attach \"<app name>\" \\\n  --time-limit 5m\n\n# Option 2: Launch and track from start\nxcrun xctrace record --template \"Allocations\" \\\n  --device $DEVICE_UUID \\\n  --launch -- /Users/daipham/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app \\\n  --time-limit 5m\n```\n\n### 3. CPU Time Profiling\n\n```bash\n# ‚úÖ Profile CPU usage\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\"\n\nxcrun xctrace record --template \"Time Profiler\" \\\n  --device $DEVICE_UUID \\\n  --attach \"<app name>\" \\\n  --time-limit 2m\n```\n\n### 4. Memory Leak Detection\n\n```bash\n# ‚úÖ Detect memory leaks\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\"\n\nxcrun xctrace record --template \"Leaks\" \\\n  --device $DEVICE_UUID \\\n  --attach \"<app name>\" \\\n  --time-limit 3m\n```\n\n### 5. Network Activity Monitoring\n\n```bash\n# Monitor network requests and responses\nxcrun xctrace record --template \"Network\" \\\n  --device \"iPhone 16 Pro Simulator (18.5)\" \\\n  --attach \"<app name>\" \\\n  --output ~/Desktop/<app name>_network_analysis.trace \\\n  --time-limit 5m\n```\n\n### 6. SwiftUI Performance Analysis\n\n```bash\n# Analyze SwiftUI performance (if using SwiftUI)\nxcrun xctrace record --template \"SwiftUI\" \\\n  --device \"iPhone 16 Pro Simulator (18.5)\" \\\n  --attach \"<app name>\" \\\n  --output ~/Desktop/<app name>_swiftui_analysis.trace \\\n  --time-limit 2m\n```\n\n### 7. Animation Performance\n\n```bash\n# Detect animation hitches and performance issues\nxcrun xctrace record --template \"Animation Hitches\" \\\n  --device \"iPhone 16 Pro Simulator (18.5)\" \\\n  --attach \"<app name>\" \\\n  --output ~/Desktop/<app name>_animation_analysis.trace \\\n  --time-limit 3m\n```\n\n### 8. Power/Energy Analysis\n\n```bash\n# Analyze energy consumption\nxcrun xctrace record --template \"Power Profiler\" \\\n  --device \"iPhone 16 Pro Simulator (18.5)\" \\\n  --attach \"<app name>\" \\\n  --output ~/Desktop/<app name>_power_analysis.trace \\\n  --time-limit 10m\n```\n\n## Advanced Usage\n\n### Recording All Processes\n\n```bash\n# Record system-wide performance\nxcrun xctrace record --template \"System Trace\" \\\n  --device \"iPhone 16 Pro Simulator (18.5)\" \\\n  --all-processes \\\n  --output ~/Desktop/<app name>_system_trace.trace \\\n  --time-limit 1m\n```\n\n### Custom Environment Variables\n\n```bash\n# Launch with custom environment variables\nxcrun xctrace record --template \"Time Profiler\" \\\n  --device \"iPhone 16 Pro Simulator (18.5)\" \\\n  --env \"LOG_LEVEL=verbose\" \\\n  --launch -- \"/path/to/<app name>.app\" \\\n  --output ~/Desktop/<app name>_debug_profile.trace \\\n  --time-limit 2m\n```\n\n### Multiple Instruments\n\n```bash\n# Combine multiple instruments in one session\nxcrun xctrace record \\\n  --device \"iPhone 16 Pro Simulator (18.5)\" \\\n  --instrument \"Time Profiler\" \\\n  --instrument \"Allocations\" \\\n  --instrument \"Network\" \\\n  --attach \"<app name>\" \\\n  --output ~/Desktop/<app name>_combined_analysis.trace \\\n  --time-limit 3m\n```\n\n## Data Export and Analysis\n\n### Table of Contents Export\n\n```bash\n# View available data in trace file\nxcrun xctrace export --input ~/Desktop/<app name>_launch_analysis.trace --toc\n```\n\n### Specific Data Export\n\n```bash\n# Export CPU profiling data\nxcrun xctrace export --input ~/Desktop/<app name>_cpu_profile.trace \\\n  --xpath '/trace-toc/run[@number=\"1\"]/data/table[@schema=\"time-profiler\"]' \\\n  --output ~/Desktop/cpu_data.xml\n\n# Export memory allocation data\nxcrun xctrace export --input ~/Desktop/<app name>_memory_analysis.trace \\\n  --xpath '/trace-toc/run[@number=\"1\"]/data/table[@schema=\"allocations\"]' \\\n  --output ~/Desktop/memory_data.xml\n\n# Export network data as HAR file\nxcrun xctrace export --input ~/Desktop/<app name>_network_analysis.trace \\\n  --har --output ~/Desktop/network_data.har\n```\n\n## iOS Project Specific Workflows\n\n### Complete Performance Audit Script\n\n```bash\n#!/bin/bash\n# <app name>_performance_audit.sh\n\n# Configuration\nDEVICE=\"iPhone 16 Pro Simulator (18.5)\"\nAPP_PATH=\"/Users/daipham/Library/Developer/Xcode/DerivedData/<app name>-demupeapxadrllglwxuahiesemhe/Build/Products/Release-iphonesimulator/<app name>.app\"\nOUTPUT_DIR=\"~/Desktop/<app name>_performance_$(date +%Y%m%d_%H%M%S)\"\nBUNDLE_ID=\"<bundle id>\"\n\n# Create output directory\nmkdir -p \"$OUTPUT_DIR\"\n\necho \"üöÄ Starting <app scheme> Performance Audit...\"\necho \"üìÅ Results will be saved to: $OUTPUT_DIR\"\n\n# 1. App Launch Analysis\necho \"üì± Analyzing app launch performance...\"\nxcrun xctrace record --template \"App Launch\" \\\n  --device \"$DEVICE\" \\\n  --launch -- \"$APP_PATH\" \\\n  --output \"$OUTPUT_DIR/launch_analysis.trace\" \\\n  --time-limit 30s\n\n# 2. Memory Allocations\necho \"üß† Analyzing memory allocations...\"\nxcrun xctrace record --template \"Allocations\" \\\n  --device \"$DEVICE\" \\\n  --attach \"$BUNDLE_ID\" \\\n  --output \"$OUTPUT_DIR/memory_analysis.trace\" \\\n  --time-limit 2m\n\n# 3. CPU Profiling\necho \"‚ö° Profiling CPU usage...\"\nxcrun xctrace record --template \"Time Profiler\" \\\n  --device \"$DEVICE\" \\\n  --attach \"$BUNDLE_ID\" \\\n  --output \"$OUTPUT_DIR/cpu_profile.trace\" \\\n  --time-limit 2m\n\n# 4. Memory Leaks\necho \"üîç Checking for memory leaks...\"\nxcrun xctrace record --template \"Leaks\" \\\n  --device \"$DEVICE\" \\\n  --attach \"$BUNDLE_ID\" \\\n  --output \"$OUTPUT_DIR/leaks_analysis.trace\" \\\n  --time-limit 3m\n\n# 5. Network Activity\necho \"üåê Monitoring network activity...\"\nxcrun xctrace record --template \"Network\" \\\n  --device \"$DEVICE\" \\\n  --attach \"$BUNDLE_ID\" \\\n  --output \"$OUTPUT_DIR/network_analysis.trace\" \\\n  --time-limit 3m\n\n# 6. Animation Performance\necho \"üé¨ Analyzing animation performance...\"\nxcrun xctrace record --template \"Animation Hitches\" \\\n  --device \"$DEVICE\" \\\n  --attach \"$BUNDLE_ID\" \\\n  --output \"$OUTPUT_DIR/animation_analysis.trace\" \\\n  --time-limit 2m\n\necho \"‚úÖ Performance audit complete!\"\necho \"üìÇ Open traces in Instruments.app for detailed analysis\"\necho \"üîó Trace files location: $OUTPUT_DIR\"\n```\n\n### Continuous Integration Performance Testing\n\n```bash\n#!/bin/bash\n# ci_performance_check.sh - For automated CI/CD pipelines\n\nDEVICE=\"iPhone 16 Pro Simulator (18.5)\"\nAPP_PATH=\"$1\"  # Pass app path as parameter\nTHRESHOLD_LAUNCH_TIME=3.0  # seconds\nTHRESHOLD_MEMORY_MB=150    # MB\n\n# Quick launch time check\necho \"‚è±Ô∏è  Measuring app launch time...\"\nxcrun xctrace record --template \"App Launch\" \\\n  --device \"$DEVICE\" \\\n  --launch -- \"$APP_PATH\" \\\n  --output \"launch_check.trace\" \\\n  --time-limit 10s\n\n# Extract launch time (simplified - would need proper parsing)\n# LAUNCH_TIME=$(parse_launch_time launch_check.trace)\n\n# Memory footprint check\necho \"üíæ Measuring memory footprint...\"\nxcrun xctrace record --template \"Allocations\" \\\n  --device \"$DEVICE\" \\\n  --launch -- \"$APP_PATH\" \\\n  --output \"memory_check.trace\" \\\n  --time-limit 30s\n\necho \"üìä Performance check complete\"\n# Add logic to fail CI if thresholds exceeded\n```\n\n### Development Workflow Integration\n\n```bash\n# Quick development profiling\nalias <app name>_profile='xcrun xctrace record --template \"Time Profiler\" --device \"iPhone 16 Pro Simulator (18.5)\" --attach \"<app name>\" --output ~/Desktop/quick_profile_$(date +%H%M%S).trace --time-limit 1m'\n\nalias <app name>_memory='xcrun xctrace record --template \"Allocations\" --device \"iPhone 16 Pro Simulator (18.5)\" --attach \"<app name>\" --output ~/Desktop/memory_check_$(date +%H%M%S).trace --time-limit 2m'\n\nalias <app name>_launch='xcrun xctrace record --template \"App Launch\" --device \"iPhone 16 Pro Simulator (18.5)\" --launch -- \"/Users/daipham/Library/Developer/Xcode/DerivedData/<app name>-demupeapxadrllglwxuahiesemhe/Build/Products/Release-iphonesimulator/<app name>.app\" --output ~/Desktop/launch_$(date +%H%M%S).trace --time-limit 20s'\n```\n\n## Tips and Best Practices\n\n### Device Selection\n\n- Use physical devices for accurate performance data\n- Simulators are good for development and debugging\n- Match device to your target audience (iPhone vs iPad)\n\n### Template Selection\n\n- **App Launch**: Essential for user experience optimization\n- **Time Profiler**: First choice for CPU performance issues\n- **Allocations**: Critical for memory management\n- **Leaks**: Important for long-term app stability\n- **Network**: Essential for apps with API calls (like <app scheme>)\n\n### Recording Duration\n\n- App Launch: 15-30 seconds\n- Memory Analysis: 2-5 minutes\n- CPU Profiling: 1-3 minutes\n- Leak Detection: 3-10 minutes (longer for thorough analysis)\n\n### Automation Best Practices\n\n- Always specify output paths to avoid conflicts\n- Use timestamp-based file naming\n- Set appropriate time limits to prevent infinite recording\n- Consider device state (clean vs. with existing apps)\n\n## Common XPath Expressions for Data Export\n\n```bash\n# CPU profiling data\n--xpath '/trace-toc/run[@number=\"1\"]/data/table[@schema=\"time-profiler\"]'\n\n# Memory allocations\n--xpath '/trace-toc/run[@number=\"1\"]/data/table[@schema=\"allocations\"]'\n\n# Network requests\n--xpath '/trace-toc/run[@number=\"1\"]/data/table[@schema=\"network-connections\"]'\n\n# App launch metrics\n--xpath '/trace-toc/run[@number=\"1\"]/data/table[@schema=\"app-launch\"]'\n\n# Animation hitches\n--xpath '/trace-toc/run[@number=\"1\"]/data/table[@schema=\"animation-hitches\"]'\n```\n\n## Troubleshooting\n\n### Common Issues and Solutions\n\n#### 1. ‚ùå \"Provided device parameter is ambiguous\"\n\n**Problem:**\n\n```bash\nxcrun xctrace record --template \"App Launch\" --device \"iPhone 17 Pro\" ...\n# Error: Provided device parameter 'iPhone 17 Pro' is ambiguous\n```\n\n**Solution:** Always use device UUID instead of name\n\n```bash\n# Get UUID first\nxcrun simctl list devices available | grep \"iPhone 17 Pro\"\n# Output: iPhone 17 Pro (F464E766-555C-4B95-B8CC-763702A70791) (Booted)\n\n# Use UUID in command\nxcrun xctrace record --template \"App Launch\" --device F464E766-555C-4B95-B8CC-763702A70791 ....\n```\n\n#### 2. ‚ùå \"Provided process is ambiguous\"\n\n**Problem:**\n\n```bash\n# Error: Provided process '/path/to/<app name>.app' is ambiguous\n# /path1/<app name>.app\n# /path2/<app name>.app\n```\n\n**Root Cause:** Multiple app installations exist on the simulator (common after repeated builds)\n\n**Solution:** Clean up before profiling\n\n```bash\n# Method 1: Uninstall existing app\nxcrun simctl uninstall $DEVICE_UUID <bundle id>\n\n# Method 2: Erase entire simulator (nuclear option)\nxcrun simctl shutdown $DEVICE_UUID\nxcrun simctl erase $DEVICE_UUID\nxcrun simctl boot $DEVICE_UUID\n\n# Then reinstall fresh\nxcrun simctl install $DEVICE_UUID /path/to/<app name>.app\n```\n\n#### 3. ‚ùå \"Export failed: Trace is malformed - run data is missing\"\n\n**Problem:**\n\n```bash\nxcrun xctrace export --input trace.trace --toc\n# Error: Export failed: Trace is malformed - run data is missing\n```\n\n**Root Cause:** Trace file is still being written or profiling was interrupted\n\n**Solution:**\n\n- Wait for profiling to fully complete (look for \"Output file saved as:\" message)\n- Don't try to export immediately after xctrace record completes\n- Some traces may not export properly via CLI - open in Instruments.app instead\n\n```bash\n# Check if profiling completed\nls -la *.trace  # Look for complete directory structure\n\n# Open in Instruments for analysis instead\nopen -a Instruments.app trace.trace\n```\n\n#### 4. ‚ùå \"No such file or directory\" with paths containing spaces\n\n**Problem:**\n\n```bash\nxcrun xctrace record --input \"/path with spaces/file.trace\" ...\n# Error: File does not exist at path\n```\n\n**Solution:** Use environment variables or proper quoting\n\n```bash\n# Method 1: Environment variable (RECOMMENDED)\nTRACE_FILE=\"/path with spaces/file.trace\"\nxcrun xctrace export --input \"$TRACE_FILE\" --toc\n\n# Method 2: Escape properly\nxcrun xctrace export --input \"/path\\ with\\ spaces/file.trace\" --toc\n```\n\n#### 5. ‚ùå Trace file saved in wrong location\n\n**Problem:** Specified `--output ~/Desktop/trace.trace` but file appears in current directory\n\n**Root Cause:** xctrace may ignore --output path and auto-generate filename\n\n**Solution:**\n\n```bash\n# Trace files are saved with auto-generated names like:\n# Launch_<app name>.app_2025-10-30_3.55.40 PM_39E6A410.trace\n\n# Find your trace file\nfind . -name \"*.trace\" -type d -mmin -5  # Files modified in last 5 minutes\n\n# Or look for specific pattern\nls -lt *.trace | head -1  # Most recent trace\n```\n\n#### 6. ‚ùå App Launch template not capturing data\n\n**Problem:** Trace file created but no meaningful data\n\n**Solution:**\n\n- Ensure app actually launches (check simulator)\n- Build app in Release configuration for realistic performance\n- Don't specify --time-limit too short (use at least 10-15 seconds)\n- Check that device is booted before profiling\n\n```bash\n# Verify device is booted\nxcrun simctl list devices | grep Booted\n\n# Boot if needed\nxcrun simctl boot $DEVICE_UUID\n```\n\n### Debugging Commands\n\n```bash\n# List all available devices with UUIDs\nxcrun simctl list devices available\n\n# Check if app is installed\nxcrun simctl listapps $DEVICE_UUID | grep <app name>\n\n# Verbose output\nxcrun xctrace record --template \"Time Profiler\" --device \"$DEVICE_UUID\" --time-limit 30s --verbose\n\n# Check available instruments\nxcrun xctrace list instruments\n\n# Validate trace file structure\nls -la trace.trace/\n\n# Open trace in Instruments GUI (most reliable for analysis)\nopen -a Instruments.app trace.trace\n```\n\n### Best Practices to Avoid Issues\n\n1. **Always use device UUID** - Never use device names\n2. **Clean state before profiling** - Uninstall app or erase simulator first\n3. **Use environment variables** - For paths with spaces or complex names\n4. **Wait between steps** - Add `sleep 2` after installation before profiling\n5. **Build in Release mode** - For accurate performance measurements\n6. **Check output location** - Trace files may have auto-generated names\n7. **Use Instruments.app** - For final analysis when CLI export fails\n\n---\n\n## Lessons Learned from Real-World Usage (2025-10-30)\n\n### What Worked ‚úÖ\n\n1. **Device UUID approach**: Using `xcrun simctl list devices available | grep \"iPhone\"` to get UUID, then using UUID in all commands\n2. **Clean installation**: Running `xcrun simctl uninstall` before each profiling session eliminated ambiguity errors\n3. **Environment variables**: Using `DEVICE_UUID=\"...\"` made commands more reliable with special characters\n4. **Background execution**: Using `2>&1` redirect and `run_in_background` for long-running profiles\n5. **Auto-generated filenames**: Accepting that xctrace generates its own filenames (e.g., `Launch_<app name>.app_2025-10-30_3.55.40 PM_39E6A410.trace`)\n\n### What Didn't Work ‚ùå\n\n1. **Device names**: `--device \"iPhone 17 Pro\"` or `--device \"iPhone 16 Pro Simulator (18.5)\"` - Always ambiguous\n2. **Direct export**: `xcrun xctrace export --input trace.trace --toc` often failed with \"malformed trace\" errors\n3. **Absolute --output paths**: Often ignored by xctrace, files saved with auto-generated names instead\n4. **Multiple app installations**: Caused \"process is ambiguous\" errors - must clean up first\n5. **Immediate export**: Trying to export trace immediately after recording before file fully written\n\n### Performance Improvements Achieved\n\nFrom this profiling session, we identified and fixed these launch time issues in <app name> app:\n\n1. **Lazy ViewModel initialization**: Deferred 7 use case resolutions from eager to lazy loading\n2. **Deferred swizzling**: Moved 4 tracking swizzle operations to background thread\n3. **Background font loading**: Moved `FontFamily.registerAllCustomFonts()` off main thread\n4. **Deferred RxSwift bindings**: Moved subscription setup to next run loop iteration\n\n**Expected improvement**: 40-60% reduction in main thread blocking during launch\n\n### Recommended Workflow\n\n```bash\n#!/bin/bash\n# Proven workflow for app launch profiling\n\n# 1. Setup\nDEVICE_UUID=\"F464E766-555C-4B95-B8CC-763702A70791\"\nAPP_PATH=\"/Users/<username>/Library/Developer/Xcode/DerivedData/<app name>/Build/Products/Release-iphonesimulator/<app name>.app\"\n\n# 2. Build in Release\nxcodebuild -workspace <app name>.xcworkspace \\\n  -scheme \"<app scheme>\" \\\n  -configuration Release \\\n  -sdk iphonesimulator \\\n  -derivedDataPath ~/Library/Developer/Xcode/DerivedData/<app name> \\\n  build\n\n# 3. Clean simulator state\nxcrun simctl uninstall $DEVICE_UUID <bundle id>\n\n# 4. Install fresh\nxcrun simctl install $DEVICE_UUID \"$APP_PATH\"\nsleep 2\n\n# 5. Profile\nxcrun xctrace record --template \"App Launch\" \\\n  --device $DEVICE_UUID \\\n  --launch -- \"$APP_PATH\" 2>&1\n\n# 6. Find and open trace\nTRACE=$(ls -t Launch_<app name>*.trace 2>/dev/null | head -1)\necho \"Trace saved to: $TRACE\"\nopen -a Instruments.app \"$TRACE\"\n```\n\nThis workflow has been tested and verified to work reliably.\n",
        "py-plugin/skills/ios-merchant-feature-declaration/SKILL.md": "---\nname: ios-merchant-feature-declaration\ndescription: Declare new iOS Feature cases by collecting details via interactive form and automatically updating all required files (Feature.swift, FeatureInfo.swift, Localizable.strings, ScreenID, Routes). Use when \"add new feature\", \"declare new feature\", \"create feature case\", \"add feature to menu\", or \"new feature declaration\".\nallowed-tools: Read, Write, Edit, Glob, Grep, AskUserQuestion\n---\n\n# iOS Merchant Feature Declaration\n\nInteractively declare new Feature cases in the iOS app by collecting all necessary information via a form, then automatically updating all required files across Domain and Presentation layers.\n\n## When to Activate\n\n- \"add new feature\"\n- \"declare new feature\"\n- \"create feature case\"\n- \"add feature to menu\"\n- \"new feature declaration\"\n- \"register new feature\"\n\n## Interactive Process\n\n### Step 1: Collect Feature Details\n\nUse `AskUserQuestion` to collect all necessary information in a single form:\n\n**Required Information:**\n1. Feature name (camelCase, e.g., \"balanceHistory\")\n2. Vietnamese description (e.g., \"L·ªãch s·ª≠ s·ªë d∆∞\")\n3. English description (e.g., \"Balance History\")\n4. Permission code (optional 5-digit number from backend, or empty if no permission)\n5. Category placement (select from available categories)\n6. Has icon? (yes/no)\n\n**Conditional Information:**\n- If has icon: Icon name (kebab-case, e.g., \"balance-history-icon\")\n- Needs deep linking? (yes/no)\n- If needs deep linking: Deep link path (e.g., \"balance/history\")\n\n**Available Categories:**\n- counterService - Counter services (home screen)\n- onlineServices - Online services (home screen)\n- utilityServices - Utility services (home screen)\n- leftAccountCategories - Account section (side menu)\n- leftCounterCategories - Counter section (side menu)\n- leftOnlineCategories - Online section (side menu)\n- leftUtilityCategories - Utility section (side menu)\n- leftInstallmentConversionCategories - Installment section (side menu)\n- none - No category (internal feature)\n\n### Step 2: Validate Inputs\n\nBefore proceeding, validate:\n- Feature name is camelCase (first letter lowercase)\n- Permission code is empty OR 5-digit number\n- Category is valid\n- Icon name (if provided) is kebab-case\n- Deep link path (if provided) follows format: `[category]/[feature]`\n\nIf validation fails, show errors and ask user to correct.\n\n### Step 3: Update Domain Files\n\nUpdate these files automatically using Edit tool:\n\n#### 3.1 Feature.swift (5 locations)\n\n**File:** `Domain/Model/Others/Feature.swift`\n\n**Location 1:** Add feature case (in appropriate section with comment)\n**Location 2:** Add permission code in `code` computed property\n**Location 3:** Add FeatureInfo mapping in `getInfo()` method\n**Location 4:** Add to category array (if category specified)\n**Location 5:** Add identifier in `identifier` computed property\n\nUse templates from `templates.md`.\n\n#### 3.2 FeatureInfo.swift\n\n**File:** `Domain/Model/Others/FeatureInfo.swift`\n\nAdd static property with icon and localized title (only if has icon).\nUse template from `templates.md`.\n\n#### 3.3 Localization Files\n\n**Files:**\n- `PayooMerchant/Resources/Localization/vi.lproj/Localizable.strings`\n- `PayooMerchant/Resources/Localization/en.lproj/Localizable.strings`\n\nAdd localization keys:\n- `menu.label.[feature-name-kebab]` - For menu items\n- `home.label.feature-[feature-name-kebab]` - For home screen\n\nUse append approach to avoid breaking existing content.\n\n### Step 4: Update Deep Linking (if needed)\n\nIf deep linking is enabled:\n\n#### 4.1 ScreenID.swift\n\n**File:** `Domain/Model/Setting/ScreenID.swift`\n\nAdd screen ID case with deep link path.\n\n#### 4.2 Route.swift\n\n**File:** `PayooMerchant/Library/DeepLink/Route.swift`\n\nAdd route case and URL mapping (4 locations: enum case, init URL mapping, Equatable, getPermissionFeature).\n\nUse templates from `templates.md`.\n\n### Step 5: Update Presentation Layer Files (CRITICAL)\n\n**IMPORTANT:** These files have exhaustive switch statements and MUST be updated to avoid compilation errors.\n\n#### 5.1 DeepLinkNavigator.swift\n\n**File:** `PayooMerchant/Library/DeepLink/DeepLinkNavigator.swift`\n\nAdd case to `getViewController(from destination:)` switch statement.\n- Return placeholder (e.g., `makeHomeViewController()`) until actual controller is implemented\n- Add TODO comment for future implementation\n\n#### 5.2 Feature+Ext.swift\n\n**File:** `PayooMerchant/Models/Feature+Ext.swift`\n\nAdd to `navigationBarTitle` computed property:\n- If feature has navigation bar title: add specific case\n- If no navigation bar title: add to nil-returning cases list\n\n#### 5.3 AppDelegateViewModel.swift\n\n**File:** `PayooMerchant/AppDelegateViewModel.swift`\n\nAdd to route filtering switch (around line 171):\n- If feature requires permission check: add specific case with permission check\n- If no permission required: add to the list of cases that return `true`\n\nUse templates from `templates.md`.\n\n### Step 6: Generate Boilerplate Code\n\nGenerate code snippets for manual implementation (don't auto-update these):\n\n1. **ViewControllerFactory method** - Show code snippet\n2. **DependencyContainer registration** - Show code snippet\n3. **Navigator extension** (if deep linking) - Show code snippet\n\nUse templates from `templates.md`.\n\n### Step 7: Validation\n\nBefore presenting results, verify:\n- All files were updated successfully\n- No syntax errors introduced\n- Feature name is unique (not already declared)\n- Permission code is unique (if provided)\n\n### Step 8: Present Results\n\nShow comprehensive summary:\n\n```markdown\n‚úÖ Feature Declared: [FeatureName]\n\nüìã Collected Details:\n  - Name: [featureName]\n  - Vietnamese: [vietnameseDesc]\n  - English: [englishDesc]\n  - Permission Code: [code or \"None\"]\n  - Category: [category]\n  - Icon: [iconName or \"None\"]\n  - Deep Link: [path or \"None\"]\n\nüìÅ Files Updated:\n  ‚úÖ Domain/Model/Others/Feature.swift (5 locations)\n  ‚úÖ Domain/Model/Others/FeatureInfo.swift (if has icon)\n  ‚úÖ PayooMerchant/Resources/Base.lproj/Localizable.strings (Vietnamese)\n  ‚úÖ PayooMerchant/Resources/en.lproj/Localizable.strings (English)\n  ‚úÖ PayooMerchant/Library/DeepLink/DeepLinkNavigator.swift (CRITICAL)\n  ‚úÖ PayooMerchant/Models/Feature+Ext.swift (CRITICAL)\n  ‚úÖ PayooMerchant/AppDelegateViewModel.swift (CRITICAL)\n  [‚úÖ Domain/Model/Setting/ScreenID.swift] (if deep linking)\n  [‚úÖ PayooMerchant/Library/DeepLink/Route.swift - 4 locations] (if deep linking)\n\nüìù Manual Steps Required:\n\n1. Add Icon Assets (if has icon):\n   - Location: PayooMerchant/Resources/Assets.xcassets/\n   - Create: [iconName].imageset/\n   - Add images: 1x, 2x, 3x (24x24, 48x48, 72x72 pt)\n\n2. Add ViewControllerFactory Method:\n   [Show code snippet]\n\n3. Register in DependencyContainer:\n   [Show code snippet]\n\n4. Create ViewController and ViewModel:\n   - [FeatureName]ViewController.swift\n   - [FeatureName]ViewModel.swift\n   - Follow MVVM + RxSwift Input/Output pattern\n\n[5. Add Navigator Extension (if deep linking):\n   [Show code snippet]]\n\n‚úÖ Verification Checklist:\n  - [ ] Build project successfully\n  - [ ] Run SwiftLint (bundle exec fastlane lint)\n  - [ ] Test without permission (should hide feature)\n  - [ ] Test with permission (should show feature)\n  - [ ] Verify Vietnamese and English text\n  - [ ] Test icon displays correctly\n  - [ ] Test deep link (if applicable)\n  - [ ] Test navigation to feature\n\nüîó Next Steps:\n  1. Add icon assets to Assets.xcassets\n  2. Implement ViewController and ViewModel\n  3. Add factory method to ViewControllerFactory\n  4. Register ViewModel in DependencyContainer\n  5. Test thoroughly before committing\n\nüìö Reference: NEW_FEATURE_DECLARATION_PLAN.md\n```\n\n## Validation Rules\n\n### Feature Name\n- Must be camelCase (first letter lowercase)\n- Must start with a letter\n- Can only contain letters and numbers\n- Must be unique (check existing Feature cases)\n\n### Permission Code\n- Empty string (no permission) OR\n- Exactly 5 digits\n- Must be unique if provided\n\n### Category\n- Must be one of the predefined categories\n- Use \"none\" for internal features\n\n### Icon Name\n- Must be kebab-case (lowercase with hyphens)\n- Should end with \"-icon\" suffix\n- Example: \"balance-history-icon\"\n\n### Deep Link Path\n- Format: `[category]/[feature]` or `[category]/[feature]/[subfeature]`\n- Must be kebab-case\n- Example: \"balance/history\"\n\n---\n\nSee `templates.md` for code templates.\nSee `examples.md` for complete example.\n",
        "py-plugin/skills/ios-merchant-feature-declaration/examples.md": "# iOS Feature Declaration - Complete Example\n\nReal-world example of declaring a new \"Balance History\" feature from start to finish.\n\n---\n\n## Example: Balance History Feature\n\n### User Input (Collected via Form)\n\n```yaml\nFeature name: balanceHistory\nVietnamese description: L·ªãch s·ª≠ s·ªë d∆∞\nEnglish description: Balance History\nPermission code: 32119\nCategory: leftAccountCategories\nHas icon: yes\nIcon name: balance-history-icon\nNeeds deep linking: no\n```\n\n---\n\n## Step-by-Step Updates\n\n### 1. Feature.swift - 5 Locations Updated\n\n**File:** `Domain/Model/Others/Feature.swift`\n\n#### Location 1: Add Feature Case\n\n**Before:**\n```swift\n// Other\ncase deposit\ncase withdrawal\ncase cardManagement\n```\n\n**After:**\n```swift\n// Other\ncase deposit\ncase withdrawal\ncase balance              // ‚úÖ ADDED\ncase balanceHistory       // ‚úÖ ADDED (L·ªãch s·ª≠ s·ªë d∆∞)\ncase cardManagement\n```\n\n---\n\n#### Location 2: Add Permission Code\n\n**Before:**\n```swift\ncase .balance:\n    return 32118\ncase .changePassword:\n    return 32115\n```\n\n**After:**\n```swift\ncase .balance:\n    return 32118\ncase .balanceHistory:     // ‚úÖ ADDED\n    return 32119          // ‚úÖ ADDED\ncase .changePassword:\n    return 32115\n```\n\n---\n\n#### Location 3: Add FeatureInfo Mapping\n\n**Before:**\n```swift\ncase .withdrawal:\n    return .withdrawal\ncase .createPaymentRequests:\n    return .paymentRequests\n```\n\n**After:**\n```swift\ncase .withdrawal:\n    return .withdrawal\ncase .balanceHistory:       // ‚úÖ ADDED\n    return .balanceHistory  // ‚úÖ ADDED\ncase .createPaymentRequests:\n    return .paymentRequests\n```\n\n---\n\n#### Location 4: Add to Category Array\n\n**Before:**\n```swift\npublic static var leftAccountCategories: [Feature] {\n    [.walletInfo, .bankAccount, .palHistory]\n}\n```\n\n**After:**\n```swift\npublic static var leftAccountCategories: [Feature] {\n    [.walletInfo, .bankAccount, .palHistory, .balanceHistory]  // ‚úÖ ADDED\n}\n```\n\n---\n\n#### Location 5: Add Identifier\n\n**Before:**\n```swift\ncase .balance: \"balance\"\ncase .changePassword: \"changePassword\"\n```\n\n**After:**\n```swift\ncase .balance: \"balance\"\ncase .balanceHistory: \"balanceHistory\"  // ‚úÖ ADDED\ncase .changePassword: \"changePassword\"\n```\n\n---\n\n### 2. FeatureInfo.swift\n\n**File:** `Domain/Model/Others/FeatureInfo.swift`\n\n**Before:**\n```swift\nstatic var withdrawal: FeatureInfo {\n    FeatureInfo(imageName: \"ic_withdrawal\", title: \"home.label.feature-withdrawal\".localized)\n}\nstatic var paymentRequests: FeatureInfo {\n    FeatureInfo(imageName: \"payment_requests\", title: \"home.label.feature-payment-requests\".localized)\n}\n```\n\n**After:**\n```swift\nstatic var withdrawal: FeatureInfo {\n    FeatureInfo(imageName: \"ic_withdrawal\", title: \"home.label.feature-withdrawal\".localized)\n}\nstatic var balanceHistory: FeatureInfo {                                              // ‚úÖ ADDED\n    FeatureInfo(                                                                     // ‚úÖ ADDED\n        imageName: \"balance-history-icon\",                                           // ‚úÖ ADDED\n        title: \"menu.label.balance-history\".localized                                // ‚úÖ ADDED\n    )                                                                                // ‚úÖ ADDED\n}                                                                                    // ‚úÖ ADDED\nstatic var paymentRequests: FeatureInfo {\n    FeatureInfo(imageName: \"payment_requests\", title: \"home.label.feature-payment-requests\".localized)\n}\n```\n\n---\n\n### 3. Localization - Vietnamese\n\n**File:** `PayooMerchant/Resources/Localization/vi.lproj/Localizable.strings`\n\n**Append to end of file:**\n\n```strings\n/* Balance History */\n\"menu.label.balance-history\" = \"L·ªãch s·ª≠ s·ªë d∆∞\";\n\"home.label.feature-balance-history\" = \"L·ªãch s·ª≠ s·ªë d∆∞\";\n```\n\n---\n\n### 4. Localization - English\n\n**File:** `PayooMerchant/Resources/Localization/en.lproj/Localizable.strings`\n\n**Append to end of file:**\n\n```strings\n/* Balance History */\n\"menu.label.balance-history\" = \"Balance History\";\n\"home.label.feature-balance-history\" = \"Balance History\";\n```\n\n---\n\n## Manual Steps with Code Snippets\n\n### 5. ViewControllerFactory Method\n\n**File:** `PayooMerchant/Library/Core/ViewControllerFactory.swift`\n\n**Add this extension:**\n\n```swift\nextension ViewControllerFactory {\n    func makeBalanceHistoryController() -> BalanceHistoryController {\n        let controller = BalanceHistoryController.instantiate()\n        controller.viewModel = DependencyContainer.shared.provide(BalanceHistoryViewModel.self)\n        return controller\n    }\n}\n```\n\n---\n\n### 6. DependencyContainer Registration\n\n**File:** `PayooMerchant/Library/Core/DependencyContainer.swift`\n\n**Add to ViewModel registration section:**\n\n```swift\n// Register Balance History ViewModel\ncontainer.register(BalanceHistoryViewModel.self) { resolver in\n    BalanceHistoryViewModel(\n        balanceHistoryUC: resolver.resolve(BalanceHistoryUseCaseType.self)!,\n        navigator: resolver.resolve(BalanceHistoryNavigatorType.self)!\n    )\n}\n```\n\n---\n\n### 7. Create ViewController and ViewModel\n\n**Create these files:**\n\n- `PayooMerchant/Controllers/Balance/History/BalanceHistoryController.swift`\n- `PayooMerchant/Controllers/Balance/History/BalanceHistoryController.xib`\n- `PayooMerchant/Controllers/Balance/History/BalanceHistoryViewModel.swift`\n\n**ViewModel structure:**\n```swift\nimport Foundation\nimport RxSwift\nimport RxCocoa\nimport Domain\n\nfinal class BalanceHistoryViewModel: BaseListPaginationDateRangeViewModel<BalanceHistoryItem, BalanceHistoryFilter, Any> {\n\n    // MARK: - Dependencies\n    private let balanceHistoryUC: BalanceHistoryUseCaseType\n\n    // MARK: - Input\n    struct Input {\n        let loadTrigger: Observable<Void>\n        let loadMoreTrigger: Observable<Void>\n        let refreshTrigger: Observable<Void>\n        let selectItemTrigger: Observable<IndexPath>\n    }\n\n    // MARK: - Output\n    struct Output {\n        let items: Driver<[Item]>\n        let isLoading: Driver<Bool>\n        let shouldLoadMore: Driver<Bool>\n        let error: Driver<Error?>\n        let selectedItem: Driver<BalanceHistoryItem>\n    }\n\n    // MARK: - Init\n    init(\n        balanceHistoryUC: BalanceHistoryUseCaseType,\n        navigator: BalanceHistoryNavigatorType\n    ) {\n        self.balanceHistoryUC = balanceHistoryUC\n        super.init(navigator: navigator, filter: BalanceHistoryFilter())\n    }\n\n    // MARK: - Transform\n    func transform(_ input: Input) -> Output {\n        // Implementation\n    }\n}\n```\n\n---\n\n### 8. Add Icon Assets\n\n**Location:** `PayooMerchant/Resources/Assets.xcassets/`\n\n**Create:**\n- `balance-history-icon.imageset/`\n  - `balance-history-icon.png` (24x24 pt)\n  - `balance-history-icon@2x.png` (48x48 pt)\n  - `balance-history-icon@3x.png` (72x72 pt)\n\n**Contents.json:**\n```json\n{\n  \"images\" : [\n    {\n      \"filename\" : \"balance-history-icon.png\",\n      \"idiom\" : \"universal\",\n      \"scale\" : \"1x\"\n    },\n    {\n      \"filename\" : \"balance-history-icon@2x.png\",\n      \"idiom\" : \"universal\",\n      \"scale\" : \"2x\"\n    },\n    {\n      \"filename\" : \"balance-history-icon@3x.png\",\n      \"idiom\" : \"universal\",\n      \"scale\" : \"3x\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n```\n\n---\n\n## Final Output Summary\n\n```markdown\n‚úÖ Feature Declared: BalanceHistory\n\nüìã Collected Details:\n  - Name: balanceHistory\n  - Vietnamese: L·ªãch s·ª≠ s·ªë d∆∞\n  - English: Balance History\n  - Permission Code: 32119\n  - Category: leftAccountCategories\n  - Icon: balance-history-icon\n  - Deep Link: None\n\nüìÅ Files Updated:\n  ‚úÖ Domain/Model/Others/Feature.swift (5 locations)\n  ‚úÖ Domain/Model/Others/FeatureInfo.swift\n  ‚úÖ PayooMerchant/Resources/Localization/vi.lproj/Localizable.strings\n  ‚úÖ PayooMerchant/Resources/Localization/en.lproj/Localizable.strings\n\nüìù Manual Steps Required:\n\n1. Add Icon Assets:\n   - Location: PayooMerchant/Resources/Assets.xcassets/\n   - Create: balance-history-icon.imageset/\n   - Add images: 1x (24x24), 2x (48x48), 3x (72x72 pt)\n\n2. Add ViewControllerFactory Method:\n   extension ViewControllerFactory {\n       func makeBalanceHistoryController() -> BalanceHistoryController {\n           let controller = BalanceHistoryController.instantiate()\n           controller.viewModel = DependencyContainer.shared.provide(BalanceHistoryViewModel.self)\n           return controller\n       }\n   }\n\n3. Register in DependencyContainer:\n   container.register(BalanceHistoryViewModel.self) { resolver in\n       BalanceHistoryViewModel(\n           balanceHistoryUC: resolver.resolve(BalanceHistoryUseCaseType.self)!,\n           navigator: resolver.resolve(BalanceHistoryNavigatorType.self)!\n       )\n   }\n\n4. Create ViewController and ViewModel:\n   - BalanceHistoryController.swift\n   - BalanceHistoryViewModel.swift\n   - Follow MVVM + RxSwift Input/Output pattern\n\n‚úÖ Verification Checklist:\n  - [ ] Build project successfully\n  - [ ] Run SwiftLint (bundle exec fastlane lint)\n  - [ ] Test without permission 32119 (should hide feature)\n  - [ ] Test with permission 32119 (should show in Account section)\n  - [ ] Verify Vietnamese text: \"L·ªãch s·ª≠ s·ªë d∆∞\"\n  - [ ] Verify English text: \"Balance History\"\n  - [ ] Test icon displays correctly\n  - [ ] Test navigation to feature\n\nüîó Next Steps:\n  1. Add icon assets to Assets.xcassets\n  2. Implement BalanceHistoryController and BalanceHistoryViewModel\n  3. Add factory method to ViewControllerFactory\n  4. Register ViewModel in DependencyContainer\n  5. Test thoroughly before committing\n\nüìö Reference: NEW_FEATURE_DECLARATION_PLAN.md\n```\n\n---\n\n## Example 2: With Deep Linking\n\n### User Input\n\n```yaml\nFeature name: orderTracking\nVietnamese description: Theo d√µi ƒë∆°n h√†ng\nEnglish description: Order Tracking\nPermission code: 34500\nCategory: leftOnlineCategories\nHas icon: yes\nIcon name: order-tracking-icon\nNeeds deep linking: yes\nDeep link path: order/tracking\n```\n\n### Additional Files Updated (Deep Linking)\n\n#### ScreenID.swift\n\n**File:** `Domain/Model/Setting/ScreenID.swift`\n\n```swift\n// Order Tracking\ncase orderTracking = \"order/tracking\"\ncase orderTrackingDetail = \"order/tracking/detail\"\n```\n\n#### Route.swift\n\n**File:** `PayooMerchant/Library/DeepLink/Route.swift`\n\n**Add enum case:**\n```swift\nenum Route {\n    case orderTracking\n    case orderTrackingDetail(order: Order)\n}\n```\n\n**Add URL mapping:**\n```swift\ninit?(url: URL) {\n    switch url {\n    case ScreenID.orderTracking.url:\n        self = .orderTracking\n\n    default:\n        if url.absoluteString.contains(ScreenID.orderTrackingDetail.url.absoluteString),\n           let params = url.queryParameters,\n           let orderId = params[\"id\"] {\n            // Create order from orderId\n            self = .orderTrackingDetail(order: order)\n        }\n    }\n}\n```\n\n#### Navigator Extension (Manual)\n\n**File:** `PayooMerchant/Controllers/Order/Tracking/Navigator+OrderTracking.swift`\n\n```swift\nimport Foundation\nimport Domain\n\nprotocol OrderTrackingNavigatorType {\n    func navigate(to destination: OrderTrackingDestination)\n}\n\nenum OrderTrackingDestination {\n    case orderTrackingDetail(order: Order)\n}\n\nextension Navigator: OrderTrackingNavigatorType {\n    func navigate(to destination: OrderTrackingDestination) {\n        switch destination {\n        case .orderTrackingDetail(let order):\n            let controller = viewControllerFactory.makeOrderTrackingDetailController(order: order)\n            push(controller)\n        }\n    }\n}\n```\n\n#### DeepLinkNavigator (Manual)\n\n**File:** `PayooMerchant/Library/DeepLink/DeepLinkNavigator.swift`\n\n**Add to navigate method:**\n```swift\ncase .orderTracking:\n    let controller = viewControllerFactory.makeOrderTrackingController()\n    navigator.push(controller)\n\ncase .orderTrackingDetail(let order):\n    let controller = viewControllerFactory.makeOrderTrackingDetailController(order: order)\n    navigator.push(controller)\n```\n\n---\n\n## Testing the Feature\n\n### 1. Permission Testing\n\n**Without Permission (code 32119 not in user permissions):**\n```\nResult: Feature should NOT appear in Account section menu\n```\n\n**With Permission (code 32119 in user permissions):**\n```\nResult: Feature SHOULD appear in Account section menu with:\n- Icon: balance-history-icon\n- Title (VI): \"L·ªãch s·ª≠ s·ªë d∆∞\"\n- Title (EN): \"Balance History\"\n```\n\n### 2. Localization Testing\n\n**Switch to Vietnamese:**\n```\nMenu text: \"L·ªãch s·ª≠ s·ªë d∆∞\"\n```\n\n**Switch to English:**\n```\nMenu text: \"Balance History\"\n```\n\n### 3. Deep Link Testing (if applicable)\n\n**Test URL:**\n```\npayoo://order/tracking\n```\n\n**Result:**\n```\nShould navigate to OrderTrackingController\n```\n\n**Test URL with parameter:**\n```\npayoo://order/tracking/detail?id=12345\n```\n\n**Result:**\n```\nShould navigate to OrderTrackingDetailController with order ID 12345\n```\n\n---\n\n## Common Patterns\n\n### Pattern 1: Feature Without Permission\n\n```yaml\nFeature name: settings\nPermission code: (empty)\n```\n\n**Result:** Feature appears for all users, no permission check.\n\n### Pattern 2: Feature Without Icon\n\n```yaml\nHas icon: no\n```\n\n**Result:** FeatureInfo.swift NOT updated, feature doesn't appear in visual menus.\n\n### Pattern 3: Parent-Child Features\n\n**Parent:**\n```yaml\nFeature name: installmentFeeCheck\nPermission code: 33200\n```\n\n**Child 1:**\n```yaml\nFeature name: installmentFeeCheckOnline\nPermission code: 33101\n```\n\n**Child 2:**\n```yaml\nFeature name: installmentFeeCheckInStore\nPermission code: 33201\n```\n\n**Result:** Parent feature combines child permissions.\n\n---\n\n## Verification Steps\n\nAfter declaring a feature, verify:\n\n1. **Build Success:**\n   ```bash\n   xcodebuild -workspace PayooMerchant.xcworkspace \\\n     -scheme \"Payoo Merchant Sandbox\" \\\n     -configuration \"Debug Sandbox\" \\\n     -sdk iphonesimulator \\\n     -destination 'platform=iOS Simulator,OS=17.5,name=iPhone 15,arch=x86_64' \\\n     clean build\n   ```\n\n2. **SwiftLint Pass:**\n   ```bash\n   bundle exec fastlane lint\n   ```\n\n3. **Feature Appears in Menu:**\n   - Login with user that has the permission code\n   - Navigate to the appropriate menu category\n   - Verify feature appears with correct icon and text\n\n4. **Localization Works:**\n   - Test in both Vietnamese and English\n   - Verify all text is properly localized\n\n5. **Deep Link Works (if applicable):**\n   - Test deep link URL in Safari or via push notification\n   - Verify navigation to correct screen\n\n---\n\nThis example demonstrates the complete end-to-end process of declaring a new feature!\n",
        "py-plugin/skills/ios-merchant-feature-declaration/templates.md": "# iOS Feature Declaration - Code Templates\n\nAll code templates for declaring a new iOS feature.\n\n---\n\n## Template 1: Feature.swift - Add Feature Case\n\n**Location in file:** Group by category (Home, Side menu, Other, Statistics, etc.)\n\n```swift\n// [CategoryComment] (e.g., // Balance)\ncase [featureName]  // [vietnameseDescription]\n```\n\n**Example:**\n```swift\n// Balance\ncase balanceHistory  // L·ªãch s·ª≠ s·ªë d∆∞\n```\n\n**Placement:** Add alphabetically within the appropriate section.\n\n---\n\n## Template 2: Feature.swift - Add Permission Code\n\n**Location:** Inside `public var code: Int?` computed property\n\n```swift\ncase .[featureName]:\n    return [permissionCode]\n```\n\n**Example (with permission):**\n```swift\ncase .balanceHistory:\n    return 32119\n```\n\n**Example (no permission):**\n```swift\n// No addition needed - returns nil in default case\n```\n\n**Placement:** Add alphabetically within the switch statement.\n\n---\n\n## Template 3: Feature.swift - Add FeatureInfo Mapping\n\n**Location:** Inside `public func getInfo() -> FeatureInfo?` method\n\n```swift\ncase .[featureName]:\n    return .[featureName]\n```\n\n**Example:**\n```swift\ncase .balanceHistory:\n    return .balanceHistory\n```\n\n**Placement:** Add alphabetically within the switch statement, before the default case.\n\n---\n\n## Template 4: Feature.swift - Add to Category Array\n\n**Location:** Static category arrays\n\n```swift\npublic static var [categoryName]: [Feature] {\n    [...existingFeatures, .[featureName]]\n}\n```\n\n**Example:**\n```swift\npublic static var leftAccountCategories: [Feature] {\n    [.walletInfo, .bankAccount, .palHistory, .balanceHistory]  // ‚úÖ Added\n}\n```\n\n**Available Categories:**\n- `counterService` - Counter services\n- `onlineServices` - Online services\n- `utilityServices` - Utility services\n- `leftAccountCategories` - Left account section\n- `leftCounterCategories` - Left counter section\n- `leftOnlineCategories` - Left online section\n- `leftUtilityCategories` - Left utility section\n- `leftInstallmentConversionCategories` - Left installment section\n- `rightCounterCategories` - Right counter section\n- `rightOnlineCategories` - Right online section\n- `rightUtilityCategories` - Right utility section\n\n---\n\n## Template 5: Feature.swift - Add Identifier\n\n**Location:** Inside `public var identifier: String` computed property\n\n```swift\ncase .[featureName]: \"[featureName]\"\n```\n\n**Example:**\n```swift\ncase .balanceHistory: \"balanceHistory\"\n```\n\n**Placement:** Add alphabetically within the switch statement.\n\n---\n\n## Template 6: FeatureInfo.swift - Add Static Property\n\n**Location:** Inside `public struct FeatureInfo`\n\n```swift\nstatic var [featureName]: FeatureInfo {\n    FeatureInfo(\n        imageName: \"[iconName]\",\n        title: \"menu.label.[feature-name-kebab]\".localized\n    )\n}\n```\n\n**With favorite title:**\n```swift\nstatic var [featureName]: FeatureInfo {\n    FeatureInfo(\n        imageName: \"[iconName]\",\n        title: \"menu.label.[feature-name-kebab]\".localized,\n        favoriteTitle: \"menu.label.[feature-name-kebab]-favorite\".localized\n    )\n}\n```\n\n**Example:**\n```swift\nstatic var balanceHistory: FeatureInfo {\n    FeatureInfo(\n        imageName: \"balance-history-icon\",\n        title: \"menu.label.balance-history\".localized\n    )\n}\n```\n\n**Placement:** Add alphabetically among other static properties.\n\n---\n\n## Template 7: Localizable.strings - Vietnamese\n\n**File:** `PayooMerchant/Resources/Localization/vi.lproj/Localizable.strings`\n\n```strings\n/* [Feature Name] */\n\"menu.label.[feature-name-kebab]\" = \"[Vietnamese Description]\";\n\"home.label.feature-[feature-name-kebab]\" = \"[Vietnamese Description]\";\n```\n\n**With favorite:**\n```strings\n/* [Feature Name] */\n\"menu.label.[feature-name-kebab]\" = \"[Vietnamese Description]\";\n\"menu.label.[feature-name-kebab]-favorite\" = \"[Short Vietnamese]\";\n\"home.label.feature-[feature-name-kebab]\" = \"[Vietnamese Description]\";\n```\n\n**Example:**\n```strings\n/* Balance History */\n\"menu.label.balance-history\" = \"L·ªãch s·ª≠ s·ªë d∆∞\";\n\"home.label.feature-balance-history\" = \"L·ªãch s·ª≠ s·ªë d∆∞\";\n```\n\n**Placement:** Append to end of file with a comment header.\n\n---\n\n## Template 8: Localizable.strings - English\n\n**File:** `PayooMerchant/Resources/Localization/en.lproj/Localizable.strings`\n\n```strings\n/* [Feature Name] */\n\"menu.label.[feature-name-kebab]\" = \"[English Description]\";\n\"home.label.feature-[feature-name-kebab]\" = \"[English Description]\";\n```\n\n**With favorite:**\n```strings\n/* [Feature Name] */\n\"menu.label.[feature-name-kebab]\" = \"[English Description]\";\n\"menu.label.[feature-name-kebab]-favorite\" = \"[Short English]\";\n\"home.label.feature-[feature-name-kebab]\" = \"[English Description]\";\n```\n\n**Example:**\n```strings\n/* Balance History */\n\"menu.label.balance-history\" = \"Balance History\";\n\"home.label.feature-balance-history\" = \"Balance History\";\n```\n\n**Placement:** Append to end of file with a comment header.\n\n---\n\n## Template 9: ScreenID.swift - Add Deep Link Case\n\n**File:** `Domain/Model/Setting/ScreenID.swift`\n\n**Location:** Inside `public enum ScreenID: String, CaseIterable`\n\n```swift\n// [Feature Category]\ncase [featureName] = \"[deepLinkPath]\"\n```\n\n**Example:**\n```swift\n// Balance\ncase balanceHistory = \"balance/history\"\ncase balanceHistoryDetail = \"balance/history/detail\"\n```\n\n**Placement:** Add in appropriate category section, alphabetically.\n\n---\n\n## Template 10: Route.swift - Add Route Case\n\n**File:** `PayooMerchant/Library/DeepLink/Route.swift`\n\n**Step 1:** Add enum case\n```swift\nenum Route {\n    // ... existing cases\n    case [featureName]\n    case [featureName]Detail([ItemType])  // If has detail view\n}\n```\n\n**Step 2:** Add URL mapping in `init?(url: URL)`\n```swift\ninit?(url: URL) {\n    switch url {\n    // ... existing cases\n\n    case ScreenID.[featureName].url:\n        self = .[featureName]\n\n    // ... rest\n    }\n}\n```\n\n**Example:**\n```swift\n// Step 1: Enum case\nenum Route {\n    case balanceHistory\n    case balanceHistoryDetail(BalanceHistoryItem)\n}\n\n// Step 2: URL mapping\ninit?(url: URL) {\n    switch url {\n    case ScreenID.balanceHistory.url:\n        self = .balanceHistory\n\n    default:\n        if url.absoluteString.contains(ScreenID.balanceHistoryDetail.url.absoluteString),\n           let params = url.queryParameters,\n           let itemId = params[\"id\"] {\n            // Parse and create route\n            self = .balanceHistoryDetail(item)\n        } else {\n            return nil\n        }\n    }\n}\n```\n\n---\n\n## Template 11: ViewControllerFactory - Factory Method\n\n**File:** `PayooMerchant/Library/Core/ViewControllerFactory.swift`\n\n```swift\nextension ViewControllerFactory {\n    func make[FeatureName]Controller() -> [FeatureName]Controller {\n        let controller = [FeatureName]Controller.instantiate()\n        controller.viewModel = DependencyContainer.shared.provide([FeatureName]ViewModel.self)\n        return controller\n    }\n}\n```\n\n**With parameters:**\n```swift\nextension ViewControllerFactory {\n    func make[FeatureName]DetailController(item: [ItemType]) -> [FeatureName]DetailController {\n        let controller = [FeatureName]DetailController.instantiate()\n        controller.viewModel = DependencyContainer.shared.provide([FeatureName]DetailViewModel.self)\n        controller.item = item\n        return controller\n    }\n}\n```\n\n**Example:**\n```swift\nextension ViewControllerFactory {\n    func makeBalanceHistoryController() -> BalanceHistoryController {\n        let controller = BalanceHistoryController.instantiate()\n        controller.viewModel = DependencyContainer.shared.provide(BalanceHistoryViewModel.self)\n        return controller\n    }\n}\n```\n\n---\n\n## Template 12: DependencyContainer - ViewModel Registration\n\n**File:** `PayooMerchant/Library/Core/DependencyContainer.swift`\n\n```swift\n// Register [Feature Name] ViewModel\ncontainer.register([FeatureName]ViewModel.self) { resolver in\n    [FeatureName]ViewModel(\n        [featureName]UC: resolver.resolve([FeatureName]UseCaseType.self)!,\n        navigator: resolver.resolve([FeatureName]NavigatorType.self)!\n    )\n}\n```\n\n**Example:**\n```swift\n// Register Balance History ViewModel\ncontainer.register(BalanceHistoryViewModel.self) { resolver in\n    BalanceHistoryViewModel(\n        balanceHistoryUC: resolver.resolve(BalanceHistoryUseCaseType.self)!,\n        navigator: resolver.resolve(BalanceHistoryNavigatorType.self)!\n    )\n}\n```\n\n**Placement:** Add in the ViewModel registration section (usually `setupViewModels()` method).\n\n---\n\n## Template 13: Navigator Extension - Deep Link Navigation\n\n**File:** Create new file `PayooMerchant/Controllers/[Feature]/Navigator+[Feature].swift`\n\n```swift\nimport Foundation\nimport Domain\n\n// MARK: - Protocol\nprotocol [FeatureName]NavigatorType {\n    func navigate(to destination: [FeatureName]Destination)\n}\n\n// MARK: - Destinations\nenum [FeatureName]Destination {\n    case [featureName]Detail(item: [ItemType])\n    // Add more destinations as needed\n}\n\n// MARK: - Navigator Extension\nextension Navigator: [FeatureName]NavigatorType {\n    func navigate(to destination: [FeatureName]Destination) {\n        switch destination {\n        case .[featureName]Detail(let item):\n            let controller = viewControllerFactory.make[FeatureName]DetailController(item: item)\n            push(controller)\n        }\n    }\n}\n```\n\n**Example:**\n```swift\nimport Foundation\nimport Domain\n\n// MARK: - Protocol\nprotocol BalanceHistoryNavigatorType {\n    func navigate(to destination: BalanceHistoryDestination)\n}\n\n// MARK: - Destinations\nenum BalanceHistoryDestination {\n    case balanceHistoryDetail(item: BalanceHistoryItem)\n}\n\n// MARK: - Navigator Extension\nextension Navigator: BalanceHistoryNavigatorType {\n    func navigate(to destination: BalanceHistoryDestination) {\n        switch destination {\n        case .balanceHistoryDetail(let item):\n            let controller = viewControllerFactory.makeBalanceHistoryDetailController(item: item)\n            push(controller)\n        }\n    }\n}\n```\n\n---\n\n## Template 14: DeepLinkNavigator - Route Handling\n\n**File:** `PayooMerchant/Library/DeepLink/DeepLinkNavigator.swift`\n\n**Add to `navigate(to route: Route)` method:**\n\n```swift\nfunc navigate(to route: Route) {\n    switch route {\n    // ... existing cases\n\n    case .[featureName]:\n        let controller = viewControllerFactory.make[FeatureName]Controller()\n        navigator.push(controller)\n\n    case .[featureName]Detail(let item):\n        let controller = viewControllerFactory.make[FeatureName]DetailController(item: item)\n        navigator.push(controller)\n\n    // ... rest\n    }\n}\n```\n\n**Example:**\n```swift\nfunc navigate(to route: Route) {\n    switch route {\n    case .balanceHistory:\n        let controller = viewControllerFactory.makeBalanceHistoryController()\n        navigator.push(controller)\n\n    case .balanceHistoryDetail(let item):\n        let controller = viewControllerFactory.makeBalanceHistoryDetailController(item: item)\n        navigator.push(controller)\n    }\n}\n```\n\n---\n\n## Template 15: DeepLinkNavigator - Add Route Case (CRITICAL)\n\n**File:** `PayooMerchant/Library/DeepLink/DeepLinkNavigator.swift`\n\n**Add to `getViewController(from destination:)` method before closing brace:**\n\n```swift\ncase .[featureName]:\n    // TODO: Implement [FeatureName]Controller\n    // return viewControllerFactory.make[FeatureName]Controller()\n    return viewControllerFactory.makeHomeViewController()\n```\n\n**Example:**\n```swift\ncase .payLater:\n    // TODO: Implement PayLaterController\n    // return viewControllerFactory.makePayLaterController()\n    return viewControllerFactory.makeHomeViewController()\n```\n\n**Placement:** Add before the closing brace of the switch statement (around line 255).\n\n---\n\n## Template 16: Feature+Ext - Add Navigation Bar Title (CRITICAL)\n\n**File:** `PayooMerchant/Models/Feature+Ext.swift`\n\n**Option A: Feature has navigation bar title**\n```swift\ncase .[featureName]:\n    return L10n.[featureName]NavigationTitle()\n```\n\n**Option B: Feature has no navigation bar title (add to nil-returning cases)**\n```swift\ncase .existingCase1,\n     .existingCase2,\n     ...,\n     .[featureName]:\n    return nil\n```\n\n**Example (no navigation bar title):**\n```swift\ncase .configurationSmartOTP,\n     .getSmartOTPCode,\n     .payLater:  // ‚úÖ ADDED\n    return nil\n```\n\n**Placement:** Add to the `navigationBarTitle` computed property's switch statement.\n\n---\n\n## Template 17: AppDelegateViewModel - Add Route Filtering (CRITICAL)\n\n**File:** `PayooMerchant/AppDelegateViewModel.swift`\n\n**Option A: Feature requires permission check**\n```swift\ncase .[featureName]:\n    return settings.supportedFeatures.contains(.[featureName])\n```\n\n**Option B: No permission required (add to true-returning cases)**\n```swift\ncase .notifications,\n     .mmsTransactionsHistory,\n     ...,\n     .[featureName]:\n    return true\n```\n\n**Example (no permission):**\n```swift\ncase .notifications,\n     .mmsTransactionsHistory,\n     .login,\n     .home,\n     .qrCodePayment,\n     .dashboardSupportCenter,\n     .supportCenterHistory,\n     .supportCenterThread,\n     .paymentRequestHistory,\n     .installmentConversionManager,\n     .refundRequestManagement,\n     .smartOTP,\n     .configurationSmartOTP,\n     .setupSmartOTP,\n     .payLater:  // ‚úÖ ADDED\n    return true\n```\n\n**Placement:** Add to the route filtering switch statement (around line 171).\n\n---\n\n## Variable Substitution Guide\n\nWhen using templates, replace these placeholders:\n\n| Placeholder | Example | Description |\n|------------|---------|-------------|\n| `[FeatureName]` | `BalanceHistory` | PascalCase feature name |\n| `[featureName]` | `balanceHistory` | camelCase feature name |\n| `[feature-name-kebab]` | `balance-history` | kebab-case for keys |\n| `[vietnameseDescription]` | `L·ªãch s·ª≠ s·ªë d∆∞` | Vietnamese description |\n| `[englishDescription]` | `Balance History` | English description |\n| `[permissionCode]` | `32119` | 5-digit permission code |\n| `[categoryName]` | `leftAccountCategories` | Category array name |\n| `[iconName]` | `balance-history-icon` | Icon asset name |\n| `[deepLinkPath]` | `balance/history` | Deep link path |\n| `[ItemType]` | `BalanceHistoryItem` | Domain model type |\n| `[CategoryComment]` | `// Balance` | Category section comment |\n\n---\n\n## Quick Reference: File Update Order\n\n1. ‚úÖ Feature.swift (5 locations) - Template 1-5\n2. ‚úÖ FeatureInfo.swift (if has icon) - Template 6\n3. ‚úÖ Localizable.strings (vi + en) - Template 7-8\n4. ‚ö†Ô∏è ScreenID.swift (if deep linking) - Template 9\n5. ‚ö†Ô∏è Route.swift (if deep linking, 4 locations) - Template 10\n6. ‚úÖ DeepLinkNavigator.swift (CRITICAL) - Template 15\n7. ‚úÖ Feature+Ext.swift (CRITICAL) - Template 16\n8. ‚úÖ AppDelegateViewModel.swift (CRITICAL) - Template 17\n9. üìù ViewControllerFactory (manual - show snippet) - Template 11\n10. üìù DependencyContainer (manual - show snippet) - Template 12\n11. üìù Navigator extension (manual - show snippet if deep linking) - Template 13\n12. üìù DeepLinkNavigator route handling (manual - show snippet if deep linking) - Template 14\n\n**Legend:**\n- ‚úÖ = Auto-update with Edit tool\n- ‚ö†Ô∏è = Auto-update if condition met\n- üìù = Manual implementation (show code snippet only)\n",
        "py-plugin/skills/ios-mr-workflow/SKILL.md": "---\nname: ios-mr-workflow\ndescription: Expert iOS GitLab merge request management with two modes - Review mode for code reviews, comments, and approvals; Update mode for creating or updating MR descriptions. Use when \"review mr\", \"review merge request\", \"create mr\", \"update mr\", \"code review\", \"approve mr\", or analyzing GitLab MRs.\nallowed-tools: Bash, Read, AskUserQuestion\n---\n\nYou are an expert iOS development and GitLab assistant managing merge requests in two modes:\n- **Review Mode**: Conduct code reviews, post comments, make approval decisions\n- **Update Mode**: Create or update merge request descriptions\n\n## Step 1: Gather Required Information\n\nPrompt user to provide (with examples):\n- **mode**: \"review\" or \"update\"\n- **project**: GitLab project (e.g., \"rnd/ios/payoo-ios-app-merchant\")\n- **branch**: Source branch name\n- **issue_number**: GitLab issue IID (or \"none\")\n- **target_branch**: Target branch (default: \"develop\")\n\nUse AskUserQuestion to collect inputs if not provided.\n\n## Step 2: Fetch MR and Validate Mode\n\nUse MCP tool `mobile-mcp-server/gitlab-get-merge-request`:\n```\nprojectName: {project}\nbranch: {branch}\n```\n\nStore result as `{mr_iid}` if MR exists.\n\n**Mode Decision Logic:**\n- If MR does NOT exist and mode is \"review\": Force switch to \"update\" mode, inform user\n- If MR exists and mode is \"review\": Continue in Review mode\n- If mode is \"update\": Continue regardless of MR existence\n\n## Step 3: Analyze Code Changes\n\n**Get MR changes:**\nUse `mobile-mcp-server/gitlab-get-merge-request-changes`:\n```\nmrIid: {mr_iid}\nprojectName: {project}\n```\n\n**Git safety and branch switch:**\n```bash\n# Check for uncommitted changes\ngit status --porcelain\n\n# If changes exist, stash them\nif [[ -n $(git status --porcelain) ]]; then\n  git stash\nfi\n\n# Switch to source branch\ngit checkout {branch}\n\n# Restore stashed changes if any\nif git stash list | grep -q stash@{0}; then\n  git stash pop\nfi\n```\n\n**Read and analyze ALL changed files (except localization files):**\n- Use Read tool to examine each complete file\n- Understand context and interactions\n- Identify potential side effects\n- Assess architectural implications\n- Check for breaking changes\n- Review dependencies between files\n\n## Step 4: Execute Mode-Specific Actions\n\n### Review Mode Actions\n\n**4a. Generate Code Review Report** (see `templates.md` for format):\n- Summary: High-level overview\n- Critical Issues: Must fix before merge\n- Major Issues: Should be addressed\n- Minor Issues: Nice-to-have improvements\n- Positive Observations: What was done well\n- Recommendations: Best practices\n- Security Review: Security considerations\n- Testing Assessment: Test coverage evaluation\n- Performance Analysis: Performance impacts\n\nFollow guidelines in `.github/instructions/ios-merchant-code-review.instructions.md`.\n\n**4b. Post Review Comments:**\nUse `mobile-mcp-server/gitlab-review-merge-request-code` for critical, major, and minor issues only.\n\n**4c. Make Approval Decision:**\n- If all critical/major issues resolved:\n  - Use `mobile-mcp-server/gitlab-approve-merge-request`:\n    ```\n    project: {project}\n    mrIid: {mr_iid}\n    ```\n  - Output: Approval confirmation\n- If issues remain:\n  - Post detailed feedback\n  - Withhold approval\n\n**4d. Provide Review Summary** (see `templates.md` for format).\n\n### Update Mode Actions\n\n**4a. Generate MR Description** (see `templates.md` for format):\n- What: Purpose and changes\n- How: Technical implementation details\n- How to Use: Code examples (for new features only)\n- Auto-include: `/assign me` and labels\n\n**4b. Create or Update MR:**\n- If MR does NOT exist:\n  - Use `mobile-mcp-server/gitlab-create-merge-request`:\n    ```\n    projectName: {project}\n    sourceBranch: {branch}\n    targetBranch: {target_branch}\n    title: {extracted_from_branch_or_generated}\n    description: {generated_description}\n    ```\n- If MR exists:\n  - Use `mobile-mcp-server/gitlab-update-merge-request-description`:\n    ```\n    project: {project}\n    mrIid: {mr_iid}\n    newDescription: {generated_description}\n    ```\n\n**4c. Provide Update Summary:**\n- MR creation/update status\n- MR URL and IID\n- Generated description summary\n- Next steps\n\n## Step 5: Workflow Completion\n\nConfirm all mode-specific steps completed and provide final summary:\n\n**Review Mode Summary:**\n```\n‚úÖ Code Review Complete\nMR: #{mr_iid}\nCritical Issues: {count}\nMajor Issues: {count}\nMinor Issues: {count}\nStatus: [Approved ‚úÖ / Changes Requested ‚ö†Ô∏è]\n```\n\n**Update Mode Summary:**\n```\n‚úÖ MR [Created/Updated]\nMR: #{mr_iid}\nURL: {mr_url}\nTitle: {title}\nStatus: Ready for review\n```\n\n## Error Handling\n\n- **MR not found**: Check branch name and project\n- **Permission denied**: Verify GitLab access tokens\n- **Git checkout fails**: Check for conflicts or missing branch\n- **API timeout**: Retry once, then abort with error\n\nAlways provide clear next steps and recovery suggestions.\n\n## Important Notes\n\n- MUST read entire changed files, not just diffs\n- Ignore localization files in review\n- Follow iOS merchant code review guidelines\n- Post only actionable comments (critical, major, minor issues)\n- Auto-switch to update mode if MR doesn't exist in review mode\n",
        "py-plugin/skills/ios-mr-workflow/examples.md": "# Workflow Examples\n\n## Example 1: Review Mode - Existing MR\n\n**Scenario**: User wants to review an existing merge request for a SmartOTP feature.\n\n**Input:**\n```\nmode: review\nproject: rnd/ios/payoo-ios-app-merchant\nbranch: feature/smart-otp\nissue_number: 1214\ntarget_branch: develop\n```\n\n**Workflow:**\n\n**Step 1**: Gather information ‚úÖ\n\n**Step 2**: Fetch MR and validate mode\n```bash\n# MCP call\nmobile-mcp-server/gitlab-get-merge-request\n  projectName: rnd/ios/payoo-ios-app-merchant\n  branch: feature/smart-otp\n\n# Result: MR !543 found\n# Mode: review (continue in review mode)\n```\n\n**Step 3**: Analyze code changes\n```bash\n# Get MR changes\nmobile-mcp-server/gitlab-get-merge-request-changes\n  mrIid: 543\n  projectName: rnd/ios/payoo-ios-app-merchant\n\n# Git operations\ngit status --porcelain  # Check for changes\ngit stash               # Stash if needed\ngit checkout feature/smart-otp\ngit stash pop           # Restore if needed\n\n# Read all changed files\nRead: PayooMerchant/Controllers/SmartOTP/SmartOTPViewController.swift\nRead: PayooMerchant/ViewModels/SmartOTP/SmartOTPViewModel.swift\nRead: Domain/UseCase/SmartOTP/GetSmartOTPCodeUseCase.swift\nRead: PayooMerchantTests/ViewModels/SmartOTPViewModelTests.swift\n```\n\n**Step 4**: Execute review mode actions\n\n**4a. Generate review report:**\n```markdown\n# üìù Code Review Analysis\n\n## Summary\nSmartOTP feature implementation with ViewModel, ViewController, and UseCase.\nOverall good Clean Architecture separation. Few issues to address.\n\n## Critical Issues ‚õî\nNone\n\n## Major Issues ‚ö†Ô∏è\n1. Missing `.catchSessionError()` on API call\n   - Location: GetSmartOTPCodeUseCase.swift:45\n   - Impact: Session timeout won't trigger auto-logout\n   - Fix: Add `.catchSessionError(sessionUC)` after API call\n\n2. Potential retain cycle in closure\n   - Location: SmartOTPViewModel.swift:78\n   - Impact: Memory leak\n   - Fix: Use `[weak self]` in RxSwift binding\n\n## Minor Issues üí°\n1. Magic number for timeout\n   - Location: SmartOTPViewController.swift:120\n   - Suggestion: Extract to constant\n\n## Positive Observations ‚úÖ\n- Clean Architecture layers properly separated\n- Good test coverage (12 test cases)\n- MVVM pattern correctly implemented\n- Dispose bags properly used\n\n## Recommendations üìö\n- Consider adding integration tests\n- Document the OTP verification flow\n\n## Security Review üîí\n- OTP code handling looks secure\n- No sensitive data logged\n\n## Testing Assessment üß™\n- Good unit test coverage\n- Edge cases covered\n- Mock objects properly implemented\n\n## Performance Analysis ‚ö°\n- No performance concerns identified\n- Async operations properly handled\n\n# üîç Review Decision\n\n**Status**: Changes Requested ‚ö†Ô∏è\n\n**Next Steps:**\n1. Fix major issue #1: Add session error handling\n2. Fix major issue #2: Fix potential retain cycle\n3. Optional: Address minor issue\n```\n\n**4b. Post review comments:**\n```bash\nmobile-mcp-server/gitlab-review-merge-request-code\n  # Posts inline comments for each major and minor issue\n```\n\n**4c. Approval decision:**\n- Issues found ‚Üí Withhold approval\n- Post detailed feedback\n\n**4d. Summary:**\n```\n‚úÖ Code Review Complete\nMR: #543\nCritical Issues: 0\nMajor Issues: 2\nMinor Issues: 1\nStatus: Changes Requested ‚ö†Ô∏è\n```\n\n## Example 2: Review Mode - MR Doesn't Exist (Auto-switch to Update)\n\n**Scenario**: User tries to review but MR doesn't exist yet.\n\n**Input:**\n```\nmode: review\nproject: rnd/ios/payoo-ios-app-merchant\nbranch: bugfix/payment-crash\nissue_number: 1250\ntarget_branch: develop\n```\n\n**Workflow:**\n\n**Step 2**: Fetch MR\n```bash\nmobile-mcp-server/gitlab-get-merge-request\n  projectName: rnd/ios/payoo-ios-app-merchant\n  branch: bugfix/payment-crash\n\n# Result: MR not found\n# Action: Force switch to \"update\" mode\n```\n\n**User notification:**\n```\n‚ö†Ô∏è Merge request not found for branch 'bugfix/payment-crash'\nAutomatically switching to UPDATE mode to create the MR.\n```\n\n**Continue with Update Mode workflow** (see Example 3)\n\n## Example 3: Update Mode - Create New MR\n\n**Scenario**: User wants to create a new merge request.\n\n**Input:**\n```\nmode: update\nproject: rnd/ios/payoo-ios-app-merchant\nbranch: feature/qr-scanner\nissue_number: 1275\ntarget_branch: develop\n```\n\n**Workflow:**\n\n**Step 2**: Fetch MR\n```bash\nmobile-mcp-server/gitlab-get-merge-request\n  projectName: rnd/ios/payoo-ios-app-merchant\n  branch: feature/qr-scanner\n\n# Result: MR not found\n# Mode: update (continue in update mode)\n```\n\n**Step 3**: Analyze code changes\n```bash\n# Read changed files to understand implementation\nRead: PayooMerchant/Controllers/QRScanner/QRScannerViewController.swift\nRead: Domain/UseCase/QRScanner/ScanQRCodeUseCase.swift\n# ... etc\n```\n\n**Step 4**: Update mode actions\n\n**4a. Generate MR description:**\n```markdown\n# üì≤ What\n\nClose #1275\n\nImplement QR code scanner feature for payment processing. Users can now scan\nmerchant QR codes to initiate payments quickly without manual entry.\n\n# üõ† How\n\n- Created QRScannerViewController with AVFoundation camera integration\n- Implemented ScanQRCodeUseCase for QR code validation\n- Added QRScannerViewModel with RxSwift bindings\n- Integrated with existing payment flow\n- Added permission handling for camera access\n\nKey decisions:\n- Used AVFoundation for native camera access\n- Implemented debouncing to prevent multiple scans\n- Added error handling for invalid QR formats\n\n# üìö How to Use\n\n\\`\\`\\`swift\n// Navigate to QR scanner\nlet viewModel = QRScannerViewModel(scanUseCase: scanUseCase)\nlet scanner = QRScannerViewController(viewModel: viewModel)\nnavigationController?.push(scanner)\n\n// Handle scan result\nviewModel.output.scannedCode\n    .subscribe(onNext: { qrCode in\n        // Process QR code\n    })\n    .disposed(by: disposeBag)\n\\`\\`\\`\n\n/assign me\n/label ~\"product::payoomerchant\" ~\"team::ios\" ~\"In Review\"\n```\n\n**4b. Create MR:**\n```bash\nmobile-mcp-server/gitlab-create-merge-request\n  projectName: rnd/ios/payoo-ios-app-merchant\n  sourceBranch: feature/qr-scanner\n  targetBranch: develop\n  title: \"Implement QR code scanner for payment processing\"\n  description: [generated description above]\n\n# Result: MR !555 created\n```\n\n**4c. Summary:**\n```\n‚úÖ MR Created\nMR: #555\nURL: https://gitlab.com/rnd/ios/payoo-ios-app-merchant/-/merge_requests/555\nTitle: Implement QR code scanner for payment processing\nStatus: Ready for review\n```\n\n## Example 4: Update Mode - Update Existing MR\n\n**Scenario**: User wants to update description of existing MR.\n\n**Input:**\n```\nmode: update\nproject: rnd/ios/payoo-ios-app-merchant\nbranch: feature/biometric-auth\nissue_number: 1280\ntarget_branch: develop\n```\n\n**Workflow:**\n\n**Step 2**: Fetch MR\n```bash\nmobile-mcp-server/gitlab-get-merge-request\n  projectName: rnd/ios/payoo-ios-app-merchant\n  branch: feature/biometric-auth\n\n# Result: MR !560 found\n# Mode: update (continue in update mode)\n```\n\n**Step 3**: Analyze code changes (same as Example 3)\n\n**Step 4**: Update mode actions\n\n**4a. Generate new description** (same format as Example 3)\n\n**4b. Update MR:**\n```bash\nmobile-mcp-server/gitlab-update-merge-request-description\n  project: rnd/ios/payoo-ios-app-merchant\n  mrIid: 560\n  newDescription: [generated description]\n\n# Result: MR !560 description updated\n```\n\n**4c. Summary:**\n```\n‚úÖ MR Updated\nMR: #560\nURL: https://gitlab.com/rnd/ios/payoo-ios-app-merchant/-/merge_requests/560\nStatus: Description updated, ready for review\n```\n\n## Example 5: Review Mode - Approve MR\n\n**Scenario**: Review finds no blocking issues, MR can be approved.\n\n**Input:**\n```\nmode: review\nproject: rnd/ios/payoo-ios-app-merchant\nbranch: bugfix/login-validation\nissue_number: 1290\ntarget_branch: develop\n```\n\n**Workflow:**\n\n**Steps 1-3**: Same as Example 1\n\n**Step 4**: Review mode actions\n\n**4a. Review report:**\n```markdown\n# üìù Code Review Analysis\n\n## Summary\nBug fix for login validation. Clean implementation, all best practices followed.\n\n## Critical Issues ‚õî\nNone\n\n## Major Issues ‚ö†Ô∏è\nNone\n\n## Minor Issues üí°\n1. Could add test for edge case with empty password\n\n## Positive Observations ‚úÖ\n- Proper input validation\n- Good error messages\n- Session error handling present\n- Memory management correct\n- Test coverage adequate\n\n# üîç Review Decision\n\n**Status**: Approved ‚úÖ\n\n**Approval Criteria Met:**\n- [x] No critical issues\n- [x] Major issues addressed or acceptable\n- [x] Code follows iOS best practices\n- [x] Adequate test coverage\n- [x] No security vulnerabilities\n\n**Next Steps:**\n- Can merge when ready\n- Consider adding edge case test in future\n```\n\n**4c. Approve MR:**\n```bash\nmobile-mcp-server/gitlab-approve-merge-request\n  project: rnd/ios/payoo-ios-app-merchant\n  mrIid: 565\n\n# Result: MR !565 approved\n```\n\n**Summary:**\n```\n‚úÖ Code Review Complete\nMR: #565\nCritical Issues: 0\nMajor Issues: 0\nMinor Issues: 1\nStatus: Approved ‚úÖ\n\nMR is ready to merge!\n```\n",
        "py-plugin/skills/ios-mr-workflow/templates.md": "# Templates\n\n## Code Review Report Template\n\nUse this structure for review mode output:\n\n```markdown\n# üìù Code Review Analysis\n\n## Summary\n[High-level overview of the changes - what was modified and overall assessment]\n\n## Critical Issues ‚õî\n[Problems that MUST be fixed before merge - blocking issues]\n- Issue 1: Description\n  - Location: file.swift:line\n  - Impact: Why this is critical\n  - Fix: Suggested solution\n\n## Major Issues ‚ö†Ô∏è\n[Important problems that SHOULD be addressed]\n- Issue 1: Description\n  - Location: file.swift:line\n  - Impact: Potential problems\n  - Fix: Suggested solution\n\n## Minor Issues üí°\n[Nice-to-have improvements and suggestions]\n- Issue 1: Description\n  - Location: file.swift:line\n  - Suggestion: How to improve\n\n## Positive Observations ‚úÖ\n[What was done well in this implementation]\n- Good practice 1\n- Good practice 2\n\n## Recommendations üìö\n[Suggestions for improvement and best practices]\n- Recommendation 1\n- Recommendation 2\n\n## Security Review üîí\n[Security considerations and potential vulnerabilities]\n- Security aspect 1\n- Security aspect 2\n\n## Testing Assessment üß™\n[Evaluation of test coverage and quality]\n- Test coverage assessment\n- Missing test scenarios\n- Test quality feedback\n\n## Performance Analysis ‚ö°\n[Potential performance impacts and optimizations]\n- Performance consideration 1\n- Performance consideration 2\n\n# üîç Review Decision\n\n**Status**: [Approved ‚úÖ / Changes Requested ‚ö†Ô∏è]\n\n**Approval Criteria Met:**\n- [ ] No critical issues\n- [ ] Major issues addressed or acceptable\n- [ ] Code follows iOS best practices\n- [ ] Adequate test coverage\n- [ ] No security vulnerabilities\n\n**Next Steps:**\n[Action items or recommendations]\n```\n\n## Review Summary Template\n\nUse this for final review summary:\n\n```markdown\n# üìù Code Review Findings\n\n## Critical Issues\n<List of critical issues that must be fixed before merge>\n\n## Major Issues\n<List of major issues that should be addressed>\n\n## Minor Issues\n<List of minor improvements and suggestions>\n\n## Positive Observations\n<What was done well in this implementation>\n\n# üîç Review Decision\n\n**Status**: [Approved ‚úÖ / Changes Requested ‚ö†Ô∏è]\n\n**Next Steps**:\n<List of action items or recommendations>\n```\n\n## MR Description Template (Update Mode)\n\nUse this structure for creating/updating merge request descriptions:\n\n```markdown\n# üì≤ What\n\nClose #{issue_number}\n\n[Clear description of what changes were made and why]\n[Explain the business context and user impact]\n\n# üõ† How\n\n[Technical details of the implementation approach]\n[Key architectural decisions and rationale]\n[Notable patterns or techniques used]\n[Any important implementation details]\n\n# üìö How to Use\n\n**Note**: Only include this section for new features or streamlined features. Omit for bug fixes.\n\n\\`\\`\\`swift\n// Example usage showing how to integrate the new feature\n// Clear, practical code examples\n\n// Example 1: Basic usage\nlet example = NewFeature()\nexample.configure()\n\n// Example 2: Advanced usage\nlet advanced = NewFeature.Builder()\n    .withOption(.custom)\n    .build()\n\\`\\`\\`\n\n/assign me\n/label ~\"product::payoomerchant\" ~\"team::ios\" ~\"In Review\"\n```\n\n## MR Description Template (No Issue)\n\nWhen no issue number is provided:\n\n```markdown\n# üì≤ What\n\n[Clear description of the purpose and goals of these changes]\n[Explain what problem is being solved]\n\n# üõ† How\n\n[Technical implementation details]\n[Architectural decisions]\n[Patterns and techniques used]\n\n# üìö How to Use\n\n[Only for new features - include usage examples]\n\n/assign me\n/label ~\"product::payoomerchant\" ~\"team::ios\" ~\"In Review\"\n```\n\n## Issue Categorization Guidelines\n\n### Critical Issues ‚õî\n- Memory leaks or retain cycles\n- Crashes or fatal errors\n- Security vulnerabilities\n- Data loss or corruption\n- Breaking API changes without migration\n- Violates Clean Architecture layer boundaries\n\n### Major Issues ‚ö†Ô∏è\n- Incorrect business logic\n- Poor error handling\n- Missing session error handling (`.catchSessionError`)\n- Missing dispose bags for RxSwift\n- Naming convention violations\n- Missing or insufficient tests\n- Performance bottlenecks\n\n### Minor Issues üí°\n- Code style inconsistencies\n- Missing documentation\n- Overly complex code that could be simplified\n- Opportunities for code reuse\n- Suggestions for better patterns\n- Minor refactoring opportunities\n\n## Code Review Guidelines Reference\n\nAlways follow the guidelines in:\n`.github/instructions/ios-merchant-code-review.instructions.md`\n\nKey areas to review:\n1. Clean Architecture compliance\n2. MVVM with RxSwift patterns\n3. Memory management (retain cycles, dispose bags)\n4. Session error handling\n5. Naming conventions\n6. Layer separation\n7. Dependency injection usage\n8. Test coverage\n",
        "py-plugin/skills/ios-naming-conventions/SKILL.md": "---\nname: ios-naming-conventions\ndescription: Check Swift naming conventions for iOS code. Validates class names, variables, functions, and IBOutlets against project standards. Use when reviewing code readability, checking abbreviations, or enforcing naming consistency in Swift files.\nallowed-tools: Read, Grep, Glob\n---\n\n# iOS Naming Conventions Checker\n\nValidate Swift code naming against Payoo Merchant project standards for clarity and consistency.\n\n## When to Activate\n\n- \"check naming\", \"naming conventions\", \"code readability\"\n- \"abbreviations\", \"variable names\", \"rename\"\n- Reviewing code quality or consistency\n- Onboarding new developers\n\n## Naming Rules Summary\n\n### Types (Classes, Structs, Enums, Protocols)\n- **PascalCase**: `PaymentViewModel`, `TransactionRepository`\n- **Descriptive**: Purpose immediately clear\n- **Proper suffixes**: ViewModel, ViewController, UseCase, Repository\n\n### Variables & Properties\n- **camelCase**: `paymentAmount`, `isProcessing`\n- **Meaningful**: No abbreviations (except URL, ID, VC, UC)\n- **Booleans**: Prefix `is`, `has`, `should`, `can`\n- **Collections**: Plural names (`transactions`, `stores`)\n\n### Functions & Methods\n- **camelCase** with verb prefix\n- **Actions**: `loadTransactions()`, `processPayment()`\n- **Queries**: `getTransaction()`, `hasPermission()`\n\n### IBOutlets\n- **Type suffix**: `amountTextField`, `confirmButton`, `tableView`\n\n## Review Process\n\n### Step 1: Scan Code\n\nRead files and identify all declarations:\n- Class/struct/enum/protocol declarations\n- Variable and property declarations\n- Function declarations\n- IBOutlet declarations\n\n### Step 2: Check Against Rules\n\nFor each identifier, verify:\n\n**Classes/Types**:\n- ‚úÖ PascalCase\n- ‚úÖ Descriptive (not generic like \"Manager\")\n- ‚úÖ No abbreviations (except standard ones)\n- ‚úÖ Proper suffix (ViewModel, UseCase, etc.)\n\n**Variables**:\n- ‚úÖ camelCase\n- ‚úÖ Meaningful names\n- ‚úÖ Boolean prefixes (is/has/should/can)\n- ‚úÖ Plural for collections\n- ‚úÖ No single letters (except loop indices)\n\n**Functions**:\n- ‚úÖ Verb-based names\n- ‚úÖ Clear action or query intent\n- ‚úÖ No generic names (doSomething, handle)\n\n**IBOutlets**:\n- ‚úÖ Type suffix included\n\n### Step 3: Generate Report\n\n```markdown\n# Naming Conventions Review\n\n## Summary\n- üî¥ Critical (meaningless): X\n- üü† High (abbreviations): X\n- üü° Medium (missing prefixes): X\n- üü¢ Low (style): X\n\n## Issues by Type\n\n### Classes/Structs/Enums\n**File**: `path/to/file.swift:line`\nCurrent: `PayVC`\nShould be: `PaymentViewController`\nReason: [Explanation]\n\n### Variables/Properties\n[List with specific fixes]\n\n### Functions\n[List with specific fixes]\n\n### IBOutlets\n[List with specific fixes]\n\n## Batch Rename Suggestions\nFound `amt` in 5 locations ‚Üí Rename all to `paymentAmount`\n\n## Good Examples Found ‚úÖ\n[Acknowledge well-named elements]\n```\n\n## Common Violations\n\n### ‚ùå Abbreviations\n```swift\nclass PayVC { }        ‚Üí PaymentViewController\nlet amt: Double        ‚Üí paymentAmount\nfunc procPmt() { }     ‚Üí processPayment()\n```\n\n### ‚ùå Single Letters\n```swift\nlet x = transaction    ‚Üí currentTransaction\nlet a = amount         ‚Üí paymentAmount\n```\n\n### ‚ùå Generic/Meaningless\n```swift\nclass Manager { }      ‚Üí PaymentManager\nfunc doSomething() { } ‚Üí processRefundRequest()\nfunc handle() { }      ‚Üí handlePaymentError()\n```\n\n### ‚ùå Missing Prefixes\n```swift\nlet loading: Bool      ‚Üí isLoading: Bool\nlet valid: Bool        ‚Üí isValid: Bool\n```\n\n### ‚ùå Missing Type Suffix\n```swift\n@IBOutlet weak var amount: UITextField!  ‚Üí amountTextField\n@IBOutlet weak var btn: UIButton!       ‚Üí confirmButton\n```\n\n## Search Patterns\n\nUse Grep to find:\n- **Abbreviations**: `(let|var)\\s+[a-z]{1,3}\\s*[=:]`\n- **IBOutlets**: `@IBOutlet.*weak var`\n- **Booleans**: `(let|var)\\s+[a-z]+.*:\\s*Bool`\n\n## Output Guidelines\n\n**For each violation**:\n1. File path and line number\n2. Current name\n3. Recommended name\n4. Reason for change\n5. Impact on code clarity\n\n**Prioritize**:\n- Critical: Meaningless names (hurts maintainability)\n- High: Abbreviations (reduces clarity)\n- Medium: Missing prefixes/suffixes\n- Low: Style inconsistencies\n\n## Quick Fixes\n\n1. **Expand Abbreviation**: Use Xcode refactor tool\n2. **Add Boolean Prefix**: Rename with is/has/should/can\n3. **Add Type Suffix**: Update IBOutlet names\n\n## Common Abbreviations to Fix\n\n| ‚ùå Bad | ‚úÖ Good |\n|--------|---------|\n| amt | paymentAmount |\n| trx, tx | transaction |\n| btn | button |\n| lbl | label |\n| vc | viewController |\n| uc | useCase |\n| repo | repository |\n\n## Reference\n\n**Detailed Examples**: See `examples.md` for extensive naming patterns and scenarios.\n",
        "py-plugin/skills/ios-naming-conventions/examples.md": "# iOS Naming Conventions Examples\n\nComprehensive examples of good and bad naming patterns in Swift.\n\n## Classes and Types\n\n### ‚úÖ Good Examples\n```swift\n// View Controllers\nclass PaymentViewController: UIViewController { }\nclass TransactionListViewController: UIViewController { }\nclass RefundConfirmationViewController: UIViewController { }\n\n// ViewModels\nclass PaymentViewModel: BaseViewModel<PaymentState> { }\nclass StoresViewModel: BaseViewModel<StoresState> { }\nclass TransactionHistoryViewModel: BaseViewModel<TransactionHistoryState> { }\n\n// Use Cases\nprotocol PaymentUseCase { }\nclass PaymentUseCaseImpl: PaymentUseCase { }\nprotocol RefundRequestUseCase { }\n\n// Repositories\nprotocol PaymentRepository { }\nclass PaymentRepositoryImpl: PaymentRepository { }\n\n// Models\nstruct Transaction { }\nstruct PaymentRequest { }\nstruct RefundRequest { }\n\n// Enums\nenum PaymentMethod { }\nenum TransactionStatus { }\nenum RefundRequestError: Error { }\n```\n\n### ‚ùå Bad Examples\n```swift\n// Too abbreviated\nclass PayVC: UIViewController { }           // ‚Üí PaymentViewController\nclass RefReqVM { }                          // ‚Üí RefundRequestViewModel\nclass TrxRepo { }                           // ‚Üí TransactionRepository\n\n// Too generic\nclass Manager { }                           // ‚Üí PaymentManager or specific purpose\nclass Helper { }                            // ‚Üí ValidationHelper or specific purpose\nclass Util { }                              // ‚Üí DateFormatter or specific utility\n\n// Missing suffixes\nclass Payment { }                           // ‚Üí PaymentViewModel or PaymentUseCase\nclass Transaction { }                       // If it's a ViewModel ‚Üí TransactionViewModel\n```\n\n---\n\n## Variables and Properties\n\n### ‚úÖ Good Examples\n```swift\nclass PaymentViewModel {\n    // State properties - descriptive\n    let paymentAmount = BehaviorRelay<String>(value: \"\")\n    let selectedPaymentMethod = BehaviorRelay<PaymentMethod?>(value: nil)\n    let transactionResult = BehaviorRelay<TransactionResult?>(value: nil)\n\n    // Boolean properties - with prefixes\n    let isProcessingPayment = BehaviorRelay<Bool>(value: false)\n    let hasNetworkConnection = BehaviorRelay<Bool>(value: true)\n    let shouldShowError = BehaviorRelay<Bool>(value: false)\n    let canSubmitPayment = BehaviorRelay<Bool>(value: false)\n\n    // Collections - plural\n    let transactions = BehaviorRelay<[Transaction]>(value: [])\n    let errorMessages = BehaviorRelay<[String]>(value: [])\n    let availablePaymentMethods = BehaviorRelay<[PaymentMethod]>(value: [])\n\n    // Dependencies - full names\n    private let paymentUseCase: PaymentUseCase\n    private let validationService: ValidationService\n    private let disposeBag = DisposeBag()\n}\n```\n\n### ‚ùå Bad Examples\n```swift\nclass PaymentViewModel {\n    // Abbreviated\n    let amt = BehaviorRelay<String>(value: \"\")           // ‚Üí paymentAmount\n    let pmtMethod = BehaviorRelay<PaymentMethod?>(value: nil)  // ‚Üí paymentMethod\n    let trxResult = BehaviorRelay<TransactionResult?>(value: nil)  // ‚Üí transactionResult\n\n    // Generic/meaningless\n    let flag = BehaviorRelay<Bool>(value: false)         // ‚Üí isProcessing\n    let data = BehaviorRelay<[Any]>(value: [])           // ‚Üí transactions\n    let temp = BehaviorRelay<String>(value: \"\")          // ‚Üí What is this?\n\n    // Boolean without prefix\n    let loading: Bool                                     // ‚Üí isLoading\n    let valid: Bool                                       // ‚Üí isValid\n    let enabled: Bool                                     // ‚Üí isEnabled\n\n    // Single letter\n    let x = 0                                             // ‚Üí transactionCount\n    let a = amount                                        // ‚Üí paymentAmount\n\n    // Inconsistent abbreviations\n    let paymentUC: PaymentUseCase                        // ‚Üí paymentUseCase\n}\n```\n\n---\n\n## Functions and Methods\n\n### ‚úÖ Good Examples\n```swift\nclass TransactionViewModel {\n    // Actions - verb-based, descriptive\n    func loadTransactions() { }\n    func refreshTransactionList() { }\n    func filterTransactionsByDate(from startDate: Date, to endDate: Date) { }\n    func processRefundRequest(for transactionId: String) { }\n    func validatePaymentAmount(_ amount: String) -> Bool { }\n\n    // Queries - return information\n    func getTransaction(by id: String) -> Transaction? { }\n    func calculateTotalAmount(for transactions: [Transaction]) -> Double { }\n    func hasUnprocessedTransactions() -> Bool { }\n    func isValidPaymentAmount(_ amount: String) -> Bool { }\n\n    // State handlers - clear purpose\n    func handlePaymentSuccess(_ result: PaymentResult) { }\n    func handlePaymentError(_ error: Error) { }\n    func handleNetworkConnectionLost() { }\n\n    // Setup/Configuration - clear intent\n    func setupUI() { }\n    func configureTableView() { }\n    func bindViewModel() { }\n}\n```\n\n### ‚ùå Bad Examples\n```swift\nclass TransactionViewModel {\n    // Too vague\n    func doSomething() { }                    // ‚Üí processRefundRequest()\n    func process() { }                        // Process what? ‚Üí processPayment()\n    func get() { }                            // Get what? ‚Üí getTransactions()\n    func handle() { }                         // Handle what? ‚Üí handleError()\n    func go() { }                             // Go where? ‚Üí navigateToDetails()\n\n    // Noun-based instead of verb-based\n    func transaction() { }                    // ‚Üí loadTransaction() or getTransaction()\n    func payment() { }                        // ‚Üí processPayment()\n\n    // Abbreviated\n    func procPmt() { }                        // ‚Üí processPayment()\n    func getTrx() { }                         // ‚Üí getTransaction()\n    func valAmt(_ amt: String) { }            // ‚Üí validateAmount(_ amount: String)\n}\n```\n\n---\n\n## IBOutlets\n\n### ‚úÖ Good Examples\n```swift\nclass PaymentViewController: UIViewController {\n    // Text fields - with TextField suffix\n    @IBOutlet weak var paymentAmountTextField: UITextField!\n    @IBOutlet weak var merchantCodeTextField: UITextField!\n    @IBOutlet weak var notesTextField: UITextField!\n\n    // Labels - with Label suffix\n    @IBOutlet weak var currencyLabel: UILabel!\n    @IBOutlet weak var totalAmountLabel: UILabel!\n    @IBOutlet weak var errorMessageLabel: UILabel!\n\n    // Buttons - with Button suffix\n    @IBOutlet weak var confirmPaymentButton: UIButton!\n    @IBOutlet weak var cancelButton: UIButton!\n    @IBOutlet weak var submitButton: UIButton!\n\n    // Tables and collections - with TableView/CollectionView suffix\n    @IBOutlet weak var transactionTableView: UITableView!\n    @IBOutlet weak var storesCollectionView: UICollectionView!\n\n    // Other views - with type suffix\n    @IBOutlet weak var loadingIndicator: UIActivityIndicatorView!\n    @IBOutlet weak var headerView: UIView!\n    @IBOutlet weak var footerContainerView: UIView!\n    @IBOutlet weak var paymentMethodSegmentedControl: UISegmentedControl!\n}\n```\n\n### ‚ùå Bad Examples\n```swift\nclass PaymentViewController: UIViewController {\n    // Missing type suffix\n    @IBOutlet weak var amount: UITextField!        // ‚Üí amountTextField\n    @IBOutlet weak var currency: UILabel!          // ‚Üí currencyLabel\n    @IBOutlet weak var confirm: UIButton!          // ‚Üí confirmButton\n\n    // Abbreviated\n    @IBOutlet weak var lbl: UILabel!               // ‚Üí titleLabel\n    @IBOutlet weak var btn: UIButton!              // ‚Üí submitButton\n    @IBOutlet weak var txtField: UITextField!      // ‚Üí amountTextField\n\n    // Too generic\n    @IBOutlet weak var table: UITableView!         // ‚Üí transactionTableView\n    @IBOutlet weak var view: UIView!               // ‚Üí headerView\n    @IBOutlet weak var loading: UIActivityIndicatorView!  // ‚Üí loadingIndicator\n}\n```\n\n---\n\n## Test Naming\n\n### ‚úÖ Good Examples\n```swift\nclass PaymentViewModelTests: XCTestCase {\n    // Format: test[MethodName]_[Scenario]_[ExpectedResult]\n\n    func testProcessPayment_WithValidAmount_CompletesSuccessfully() { }\n    func testProcessPayment_WithEmptyAmount_ShowsValidationError() { }\n    func testProcessPayment_WithNetworkError_ShowsErrorState() { }\n    func testLoadTransactions_WithCachedData_ReturnsDataImmediately() { }\n    func testRefundRequest_WhenAmountExceedsTransaction_Fails() { }\n\n    func testValidateAmount_BelowMinimum_ReturnsFalse() { }\n    func testValidateAmount_AboveMaximum_ReturnsFalse() { }\n    func testValidateAmount_ValidRange_ReturnsTrue() { }\n\n    func testSubmitRefund_WithValidData_UpdatesStateToSuccess() { }\n    func testSubmitRefund_WithInvalidData_UpdatesStateToError() { }\n}\n```\n\n### ‚ùå Bad Examples\n```swift\nclass PaymentViewModelTests: XCTestCase {\n    func test1() { }                           // Meaningless number\n    func testPayment() { }                     // Too vague\n    func testError() { }                       // What error scenario?\n    func testStuff() { }                       // Meaningless\n    func test_payment_works() { }              // snake_case (wrong)\n}\n```\n\n---\n\n## Complete Class Examples\n\n### ‚úÖ Well-Named Class\n```swift\nclass PaymentProcessingViewModel: BaseViewModel<PaymentState> {\n    // Dependencies - full, descriptive names\n    private let paymentUseCase: PaymentUseCase\n    private let validationService: ValidationService\n    private let disposeBag = DisposeBag()\n\n    // Input properties - clear, descriptive\n    let paymentAmount = BehaviorRelay<String>(value: \"\")\n    let selectedMerchantId = BehaviorRelay<String?>(value: nil)\n    let additionalNotes = BehaviorRelay<String>(value: \"\")\n\n    // State properties - boolean with prefixes\n    let isProcessingPayment = BehaviorRelay<Bool>(value: false)\n    let hasValidPaymentAmount = BehaviorRelay<Bool>(value: false)\n    let shouldEnableSubmitButton = BehaviorRelay<Bool>(value: false)\n\n    // Output properties - descriptive\n    let paymentResult = BehaviorRelay<PaymentResult?>(value: nil)\n    let errorMessage = BehaviorRelay<String?>(value: nil)\n\n    // Initializer - parameter names match properties\n    init(paymentUseCase: PaymentUseCase, validationService: ValidationService) {\n        self.paymentUseCase = paymentUseCase\n        self.validationService = validationService\n        super.init()\n        setupValidation()\n    }\n\n    // Methods - verb-based, descriptive\n    func processPaymentRequest() { }\n    func validatePaymentAmount() -> Bool { }\n    func clearPaymentForm() { }\n    func handlePaymentSuccess(_ result: PaymentResult) { }\n    func handlePaymentError(_ error: Error) { }\n\n    private func setupValidation() { }\n    private func updateSubmitButtonState() { }\n}\n```\n\n### ‚ùå Poorly Named Class\n```swift\nclass PaymentVM: BaseViewModel<PaymentState> {  // Abbreviated\n    // Abbreviated dependencies\n    private let pmtUC: PaymentUseCase            // ‚Üí paymentUseCase\n    private let valService: ValidationService    // ‚Üí validationService\n    private let bag = DisposeBag()               // ‚Üí disposeBag\n\n    // Abbreviated/unclear properties\n    let amt = BehaviorRelay<String>(value: \"\")   // ‚Üí paymentAmount\n    let mid = BehaviorRelay<String?>(value: nil) // ‚Üí merchantId\n    let notes = BehaviorRelay<String>(value: \"\")  // Could be clearer\n\n    // Boolean without prefix\n    let processing = BehaviorRelay<Bool>(value: false)  // ‚Üí isProcessing\n    let valid = BehaviorRelay<Bool>(value: false)       // ‚Üí hasValidAmount\n\n    // Generic names\n    let result = BehaviorRelay<PaymentResult?>(value: nil)  // ‚Üí paymentResult\n    let error = BehaviorRelay<String?>(value: nil)          // ‚Üí errorMessage\n\n    // Abbreviated initializer\n    init(uc: PaymentUseCase, val: ValidationService) {      // Bad parameter names\n        self.pmtUC = uc\n        self.valService = val\n        super.init()\n    }\n\n    // Vague method names\n    func process() { }                           // ‚Üí processPaymentRequest()\n    func validate() -> Bool { }                  // ‚Üí validatePaymentAmount()\n    func clear() { }                             // ‚Üí clearPaymentForm()\n    func handle(_ r: PaymentResult) { }          // ‚Üí handlePaymentSuccess()\n}\n```\n\n---\n\n## Refactoring Examples\n\n### Example: Refactoring Poor Names\n\n#### Before (Bad)\n```swift\nclass TrxVM: BaseViewModel<TrxState> {\n    let trxs = BehaviorRelay<[Trx]>(value: [])\n    let loading = BehaviorRelay<Bool>(value: false)\n\n    func getTrx(id: String) -> Trx? {\n        return trxs.value.first { $0.id == id }\n    }\n\n    func proc() {\n        loading.accept(true)\n        // Process transactions\n    }\n}\n```\n\n#### After (Good)\n```swift\nclass TransactionViewModel: BaseViewModel<TransactionState> {\n    let transactions = BehaviorRelay<[Transaction]>(value: [])\n    let isLoading = BehaviorRelay<Bool>(value: false)\n\n    func getTransaction(by id: String) -> Transaction? {\n        return transactions.value.first { $0.id == id }\n    }\n\n    func processTransactions() {\n        isLoading.accept(true)\n        // Process transactions\n    }\n}\n```\n\n**Changes Made**:\n1. `TrxVM` ‚Üí `TransactionViewModel` (full names, proper suffix)\n2. `trxs` ‚Üí `transactions` (no abbreviation, plural)\n3. `loading` ‚Üí `isLoading` (boolean prefix)\n4. `getTrx` ‚Üí `getTransaction` (full name, clear parameters)\n5. `proc` ‚Üí `processTransactions` (verb-based, descriptive)\n\n---\n\n## Quick Reference Checklist\n\nUse this when reviewing naming:\n\n```markdown\n## Naming Conventions Checklist\n\n### Classes/Structs/Enums\n- [ ] PascalCase\n- [ ] Descriptive and meaningful\n- [ ] Proper suffix (ViewModel, UseCase, etc.)\n- [ ] No abbreviations\n\n### Variables/Properties\n- [ ] camelCase\n- [ ] Meaningful names\n- [ ] Booleans have is/has/should/can prefix\n- [ ] Collections are plural\n- [ ] No single letters (except loops)\n- [ ] No abbreviations\n\n### Functions/Methods\n- [ ] camelCase\n- [ ] Verb-based (actions) or get/has/is (queries)\n- [ ] Descriptive of purpose\n- [ ] Clear parameter names\n\n### IBOutlets\n- [ ] Include type suffix\n- [ ] Descriptive of purpose\n- [ ] camelCase\n\n### General\n- [ ] No generic names (Manager, Helper, Util)\n- [ ] Consistent naming style\n- [ ] Easy to understand without context\n```\n",
        "py-plugin/skills/ios-reactive-list-generator/SKILL.md": "---\nname: ios-reactive-list-generator\ndescription: Generate reactive iOS list screens with RxSwift MVVM Input/Output pattern. Creates complete list features with reactive bindings, pagination (date range/page number), ViewModel, ViewController, Navigator, and tests for iOS reactive projects. Use when \"create reactive list\", \"generate reactive list\", \"new reactive list screen\", \"create rxswift list\", or \"generate list with rxswift\".\nallowed-tools: Read, Write, Edit, Glob, Grep, AskUserQuestion\n---\n\n# iOS Reactive List Generator\n\nGenerates complete reactive iOS list screens using RxSwift MVVM Input/Output pattern with reactive pagination, pull-to-refresh, and infinite scroll for iOS reactive projects.\n\n## When to Activate\n\n- \"create reactive list\"\n- \"generate reactive list\"\n- \"new reactive list screen\"\n- \"create rxswift list\"\n- \"generate list with rxswift\"\n- \"new reactive table view\"\n- \"create ios reactive list\"\n- \"generate reactive list with pagination\"\n- \"new list with reactive bindings\"\n\n## Generation Process\n\n### Step 1: Collect Feature Requirements\n\nUse `AskUserQuestion` to collect configuration (present all questions at once):\n\n**Required Information:**\n1. Feature name (CamelCase, e.g., \"TransactionHistory\")\n2. Feature path (e.g., \"PayooMerchant/Controllers/Transaction/History\")\n3. Feature display title (for navigation bar)\n4. Pagination type: \"date_range\", \"page_number\", or \"none\"\n5. Primary UseCase name (e.g., \"TransactionHistoryUseCaseType\")\n6. Primary UseCase main method (e.g., \"getTransactions(fromDate:toDate:)\")\n7. Domain model item type (e.g., \"TransactionItem\")\n8. Main content cell class (e.g., \"TransactionCell\")\n\n**Optional Information:**\n- Additional UseCases (comma-separated)\n- Custom Input triggers beyond standard (load, loadMore, refresh, selectItem)\n- Custom Output drivers beyond standard (items, isLoading, shouldLoadMore, error)\n- Header cells (comma-separated class names)\n- Additional navigation destinations\n\n### Step 2: Read Reference Implementations\n\nRead these files to extract patterns:\n\n```bash\n# Core reference implementations\nPayooMerchant/Controllers/Balance/Information/BalanceInformationViewModel.swift\nPayooMerchant/Controllers/Balance/Information/BalanceInformationController.swift\nPayooMerchant/Controllers/History/BaseListTransaction/BaseListPaginateDateRangeViewModel.swift\n\n# Form template\n/Users/homac34/payoo-ios-app-merchant/PRESENTATION_LAYER_FORM.md\n```\n\n### Step 3: Generate Files\n\nGenerate these files in the specified `feature_path`:\n\n#### 1. ViewModel (`[Feature]ViewModel.swift`)\n\nFrom `templates.md` ‚Üí Template 1: ViewModel\n\n**Key components:**\n- Import Domain module\n- Struct `[Feature]Filter: FilterPaginationDateRangeProvider`\n- Class extending `BaseListPaginationDateRangeViewModel<DomainItem, Filter, Any>`\n- Input struct with all triggers\n- Output struct with all drivers\n- `transform()` method\n- Override `fetchItems(_ toDate: Date)` for pagination\n\n**Critical patterns:**\n- Use `[weak self]` in all closures\n- All subscriptions use `.disposed(by: disposeBag)`\n- API calls use `.catchSessionError(sessionUC)` (inherited from base)\n- Use `Driver` for all outputs (UI-safe)\n- Use `Observable` for all inputs\n\n#### 2. ViewController (`[Feature]Controller.swift`)\n\nFrom `templates.md` ‚Üí Template 2: ViewController\n\n**Key components:**\n- Extend `BaseViewController`\n- IBOutlet for tableView\n- PublishSubject triggers matching Input\n- `viewDidLoad()` setup\n- `setupUI()` - register cells, configure table\n- `bindViewModel()` - create Input, transform, bind Output\n\n**Critical patterns:**\n- Pull-to-refresh setup\n- Infinite scroll detection (last 3 items)\n- Cell registration with `registerCellByNib`\n- Error handling with `showError()`\n- Navigation via `navigator.navigate(to:)`\n\n#### 3. Navigator Extension (`Navigator+[Feature].swift`)\n\nFrom `templates.md` ‚Üí Template 3: Navigator\n\n**Key components:**\n- Protocol `[Feature]NavigatorType`\n- Enum `[Feature]Destination` with all navigation cases\n- Extension `Navigator: [Feature]NavigatorType`\n- Implementation using `viewControllerFactory`\n\n#### 4. Unit Tests (`[Feature]ViewModelTests.swift`)\n\nFrom `templates.md` ‚Üí Template 4: Unit Tests\n\n**Key components:**\n- RxTest with TestScheduler\n- Mock UseCases and Navigator\n- Test cases for load, loadMore, refresh, selection\n- Memory leak test (weak self verification)\n\n### Step 4: Generate DI Registration Instructions\n\nCreate markdown instructions for manual updates:\n\n**File: `DependencyContainer.swift`**\n```swift\n// Register ViewModel\ncontainer.register([Feature]ViewModel.self) { resolver in\n    [Feature]ViewModel(\n        [feature]UC: resolver.resolve([PrimaryUseCase].self)!,\n        navigator: resolver.resolve([Feature]NavigatorType.self)!\n    )\n}\n```\n\n**File: `ViewControllerFactory` extension**\n```swift\nextension ViewControllerFactory {\n    func make[Feature]Controller() -> [Feature]Controller {\n        let controller = [Feature]Controller.instantiate()\n        controller.viewModel = DependencyContainer.shared.provide([Feature]ViewModel.self)\n        return controller\n    }\n}\n```\n\n### Step 5: Validation Checklist\n\nBefore presenting results, verify:\n\n- ‚úì All generated files use correct feature name\n- ‚úì Import statements include `Domain`, `RxSwift`, `RxCocoa`\n- ‚úì ViewModel extends correct base class for pagination type\n- ‚úì All closures use `[weak self]`\n- ‚úì All subscriptions disposed with `disposeBag`\n- ‚úì Cell classes match existing cells (verify with Glob)\n- ‚úì Navigator protocol and enum follow naming conventions\n- ‚úì File paths are absolute and correct\n\n## Output Format\n\nPresent results as:\n\n```markdown\n‚úÖ iOS Feature Generated: [FeatureName]\n\nüìÅ Files Created:\n  - [feature_path]/[Feature]ViewModel.swift\n  - [feature_path]/[Feature]Controller.swift\n  - [feature_path]/Navigator+[Feature].swift\n  - PayooMerchantTests/ViewModel/[Feature]ViewModelTests.swift\n\nüìã Manual Steps Required:\n\n1. **Register in DependencyContainer.swift**\n   [Show code snippet]\n\n2. **Add factory method to ViewControllerFactory**\n   [Show code snippet]\n\n3. **Update parent Navigator** (if adding to existing flow)\n   [Show navigation destination enum case]\n\n4. **Create XIB file** (optional)\n   - File ‚Üí New ‚Üí View\n   - Name: [Feature]Controller.xib\n   - Set File's Owner to [Feature]Controller\n   - Connect tableView outlet\n\nüß™ Test the Feature:\n\n1. Build project:\n   ```bash\n   xcodebuild -workspace PayooMerchant.xcworkspace \\\n     -scheme \"Payoo Merchant Sandbox\" \\\n     -configuration \"Debug Sandbox\" \\\n     -sdk iphonesimulator \\\n     -destination 'platform=iOS Simulator,OS=17.5,name=iPhone 15,arch=x86_64' \\\n     clean build\n   ```\n\n2. Run tests:\n   ```bash\n   xcodebuild test \\\n     -workspace PayooMerchant.xcworkspace \\\n     -scheme \"PayooMerchantTests\" \\\n     -configuration \"Debug Sandbox\" \\\n     -destination 'platform=iOS Simulator,OS=17.5,name=iPhone 15,arch=x86_64' \\\n     -enableCodeCoverage YES\n   ```\n\n3. Navigate to feature: `navigator.navigate(to: .[featureName]())`\n\n‚è±Ô∏è  Estimated completion time: 15-30 minutes (manual steps)\n```\n\n## Key Patterns Reference\n\n### Date Range Pagination\n- Filter conforms to `FilterPaginationDateRangeProvider`\n- Domain item conforms to `PaginationDateRangeProvider`\n- Uses item's `createdDate` as cursor for next page\n- `toDate` becomes last item's date on load more\n\n### RxSwift Memory Safety\n- Always `[weak self]` in closures\n- Always `.disposed(by: disposeBag)`\n- Use `Driver` (never fails, main thread) for UI\n- Use `Observable` for inputs\n\n### Navigation Pattern\n- Protocol defines interface\n- Enum defines destinations with associated values\n- Navigator extension implements using factory\n\n---\n\nSee `templates.md` for complete code templates.\nSee `examples.md` for full generated feature example.\n",
        "py-plugin/skills/ios-reactive-list-generator/examples.md": "# iOS Feature Generator - Complete Examples\n\nReal-world examples of generated features following MVVM + RxSwift Input/Output pattern.\n\n---\n\n## Example 1: Transaction History Feature (Date Range Pagination)\n\n### User Input\n\n```yaml\nFeature name: TransactionHistory\nFeature path: PayooMerchant/Controllers/Transaction/History\nFeature title: Transaction History\nPagination type: date_range\nPrimary UseCase: TransactionHistoryUseCaseType\nPrimary method: getTransactions(fromDate:toDate:)\nDomain item type: TransactionItem\nMain content cell: TransactionCell\nAdditional inputs: filterByTypeTrigger (Observable<TransactionType?>)\nAdditional outputs: filterOptions (Driver<[TransactionType]>)\nHeader cells: TransactionFilterCell\nNavigation: transactionDetail(item:), exportTransactions()\n```\n\n### Generated Files\n\n#### 1. TransactionHistoryViewModel.swift\n\n```swift\n// PayooMerchant/Controllers/Transaction/History/TransactionHistoryViewModel.swift\n\nimport Foundation\nimport RxSwift\nimport RxCocoa\nimport Domain\n\n// MARK: - Filter Object\nstruct TransactionHistoryFilter: FilterPaginationDateRangeProvider {\n    var toDate: Date = Date()\n    var fromDate: Date = Date().addingTimeInterval(-30 * 24 * 60 * 60)\n    var transactionType: TransactionType?\n}\n\n// MARK: - ViewModel\nfinal class TransactionHistoryViewModel: BaseListPaginationDateRangeViewModel<TransactionItem, TransactionHistoryFilter, Any> {\n\n    // MARK: - Dependencies\n    private let transactionHistoryUC: TransactionHistoryUseCaseType\n\n    // MARK: - Relays\n    private let filterOptionsRelay = BehaviorRelay<[TransactionType]>(value: TransactionType.allCases)\n\n    // MARK: - Input\n    struct Input {\n        let loadTrigger: Observable<Void>\n        let loadMoreTrigger: Observable<Void>\n        let refreshTrigger: Observable<Void>\n        let selectItemTrigger: Observable<IndexPath>\n        let changeDateRangeTrigger: Observable<(fromDate: Date, toDate: Date)>\n        let filterByTypeTrigger: Observable<TransactionType?>\n    }\n\n    // MARK: - Output\n    struct Output {\n        let items: Driver<[Item]>\n        let isLoading: Driver<Bool>\n        let shouldLoadMore: Driver<Bool>\n        let error: Driver<Error?>\n        let selectedItem: Driver<TransactionItem>\n        let filterOptions: Driver<[TransactionType]>\n    }\n\n    // MARK: - Init\n    init(\n        transactionHistoryUC: TransactionHistoryUseCaseType,\n        navigator: TransactionHistoryNavigatorType\n    ) {\n        self.transactionHistoryUC = transactionHistoryUC\n        super.init(navigator: navigator, filter: TransactionHistoryFilter())\n    }\n\n    // MARK: - Transform\n    func transform(_ input: Input) -> Output {\n        // Handle date range changes\n        input.changeDateRangeTrigger\n            .subscribe(onNext: { [weak self] dates in\n                var newFilter = self?.filterObject.value ?? TransactionHistoryFilter()\n                newFilter.fromDate = dates.fromDate\n                newFilter.toDate = dates.toDate\n                self?.filterObject.accept(newFilter)\n                self?.reload()\n            })\n            .disposed(by: disposeBag)\n\n        // Handle transaction type filter changes\n        input.filterByTypeTrigger\n            .subscribe(onNext: { [weak self] type in\n                var newFilter = self?.filterObject.value ?? TransactionHistoryFilter()\n                newFilter.transactionType = type\n                self?.filterObject.accept(newFilter)\n                self?.reload()\n            })\n            .disposed(by: disposeBag)\n\n        // Base pagination setup\n        let baseOutput = super.transform(\n            loadTrigger: input.loadTrigger,\n            reloadTrigger: input.refreshTrigger,\n            loadMoreTrigger: input.loadMoreTrigger\n        )\n\n        // Handle item selection\n        let selectedItem = input.selectItemTrigger\n            .withLatestFrom(baseOutput.items) { indexPath, items in\n                items[indexPath.row]\n            }\n            .asDriverOnErrorJustComplete()\n\n        return Output(\n            items: baseOutput.items,\n            isLoading: baseOutput.isLoading,\n            shouldLoadMore: baseOutput.shouldLoadMore,\n            error: baseOutput.error,\n            selectedItem: selectedItem,\n            filterOptions: filterOptionsRelay.asDriver()\n        )\n    }\n\n    // MARK: - Fetch Items\n    override func fetchItems(_ toDate: Date) -> Observable<[TransactionItem]> {\n        let filter = filterObject.value\n\n        return transactionHistoryUC.getTransactions(\n            fromDate: filter.fromDate.toString(format: .defaultFormatDateTime) ?? \"\",\n            toDate: toDate.toString(format: .defaultFormatDateTime) ?? \"\"\n        )\n        .asObservable()\n        .map { response in\n            // Filter by type if selected\n            guard let selectedType = filter.transactionType else {\n                return response.transactions\n            }\n            return response.transactions.filter { $0.type == selectedType }\n        }\n    }\n}\n```\n\n#### 2. TransactionHistoryController.swift\n\n```swift\n// PayooMerchant/Controllers/Transaction/History/TransactionHistoryController.swift\n\nimport UIKit\nimport RxSwift\nimport RxCocoa\nimport Domain\n\nfinal class TransactionHistoryController: BaseViewController {\n\n    // MARK: - IBOutlets\n    @IBOutlet private weak var tableView: UITableView!\n    @IBOutlet private weak var filterButton: UIButton!\n    @IBOutlet private weak var exportButton: UIBarButtonItem!\n\n    // MARK: - Properties\n    var viewModel: TransactionHistoryViewModel!\n\n    // MARK: - Triggers\n    private let loadTrigger = PublishSubject<Void>()\n    private let loadMoreTrigger = PublishSubject<Void>()\n    private let refreshTrigger = PublishSubject<Void>()\n    private let selectItemTrigger = PublishSubject<IndexPath>()\n    private let changeDateRangeTrigger = PublishSubject<(fromDate: Date, toDate: Date)>()\n    private let filterByTypeTrigger = PublishSubject<TransactionType?>()\n\n    // MARK: - Lifecycle\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        bindViewModel()\n\n        // Initial load\n        loadTrigger.onNext(())\n    }\n\n    // MARK: - Setup\n    private func setupUI() {\n        title = \"Transaction History\"\n\n        // Table view setup\n        tableView.do {\n            $0.registerCellByNib(TransactionFilterCell.self)\n            $0.registerCellByNib(TransactionCell.self)\n            $0.registerCellByNib(ErrorOrEmptyStateCell.self)\n            $0.estimatedRowHeight = 80\n            $0.rowHeight = UITableView.automaticDimension\n            $0.separatorStyle = .singleLine\n        }\n\n        // Pull to refresh\n        let refreshControl = UIRefreshControl()\n        tableView.refreshControl = refreshControl\n\n        refreshControl.rx.controlEvent(.valueChanged)\n            .bind(to: refreshTrigger)\n            .disposed(by: disposeBag)\n\n        // Export button\n        navigationItem.rightBarButtonItem = exportButton\n    }\n\n    // MARK: - Binding\n    private func bindViewModel() {\n        let input = TransactionHistoryViewModel.Input(\n            loadTrigger: loadTrigger.asObservable(),\n            loadMoreTrigger: loadMoreTrigger.asObservable(),\n            refreshTrigger: refreshTrigger.asObservable(),\n            selectItemTrigger: selectItemTrigger.asObservable(),\n            changeDateRangeTrigger: changeDateRangeTrigger.asObservable(),\n            filterByTypeTrigger: filterByTypeTrigger.asObservable()\n        )\n\n        let output = viewModel.transform(input)\n\n        // Bind items to table view\n        output.items\n            .drive(tableView.rx.items) { [weak self] tableView, index, item in\n                guard let self = self else { return UITableViewCell() }\n\n                // Header section (filter)\n                if index == 0 {\n                    let cell = tableView.dequeueReusableCell(TransactionFilterCell.self, for: IndexPath(row: index, section: 0))\n                    cell.configure(\n                        filterOptions: try? output.filterOptions.asObservable().take(1).toBlocking().first() ?? [],\n                        selectedType: self.viewModel.filterObject.value.transactionType,\n                        onSelectType: { [weak self] type in\n                            self?.filterByTypeTrigger.onNext(type)\n                        }\n                    )\n                    return cell\n                }\n\n                // Transaction items\n                let cell = tableView.dequeueReusableCell(TransactionCell.self, for: IndexPath(row: index, section: 0))\n                cell.configure(with: item)\n                return cell\n            }\n            .disposed(by: disposeBag)\n\n        // Handle loading state\n        output.isLoading\n            .drive(onNext: { [weak self] isLoading in\n                if !isLoading {\n                    self?.tableView.refreshControl?.endRefreshing()\n                }\n            })\n            .disposed(by: disposeBag)\n\n        // Handle item selection\n        output.selectedItem\n            .drive(onNext: { [weak self] item in\n                self?.navigator.navigate(to: .transactionDetail(item: item))\n            })\n            .disposed(by: disposeBag)\n\n        // Handle errors\n        output.error\n            .drive(onNext: { [weak self] error in\n                guard let error = error else { return }\n                self?.showError(error)\n            })\n            .disposed(by: disposeBag)\n\n        // Table view selection\n        tableView.rx.itemSelected\n            .do(onNext: { [weak self] indexPath in\n                self?.tableView.deselectRow(at: indexPath, animated: true)\n            })\n            .bind(to: selectItemTrigger)\n            .disposed(by: disposeBag)\n\n        // Infinite scroll\n        tableView.rx.willDisplayCell\n            .filter { [weak self] _, indexPath in\n                guard let self = self,\n                      let itemsCount = try? output.items.asObservable().take(1).toBlocking().first()?.count\n                else { return false }\n                return indexPath.row >= itemsCount - 3\n            }\n            .map { _ in () }\n            .bind(to: loadMoreTrigger)\n            .disposed(by: disposeBag)\n\n        // Export button\n        exportButton.rx.tap\n            .subscribe(onNext: { [weak self] in\n                self?.navigator.navigate(to: .exportTransactions)\n            })\n            .disposed(by: disposeBag)\n\n        // Filter button\n        filterButton.rx.tap\n            .subscribe(onNext: { [weak self] in\n                guard let self = self else { return }\n                self.navigator.navigate(to: .dateRangePicker(\n                    currentFromDate: self.viewModel.filterObject.value.fromDate,\n                    currentToDate: self.viewModel.filterObject.value.toDate,\n                    onSelect: { [weak self] fromDate, toDate in\n                        self?.changeDateRangeTrigger.onNext((fromDate: fromDate, toDate: toDate))\n                    }\n                ))\n            })\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n#### 3. Navigator+TransactionHistory.swift\n\n```swift\n// PayooMerchant/Controllers/Transaction/History/Navigator+TransactionHistory.swift\n\nimport Foundation\nimport Domain\n\n// MARK: - Protocol\nprotocol TransactionHistoryNavigatorType {\n    func navigate(to destination: TransactionHistoryDestination)\n}\n\n// MARK: - Destinations\nenum TransactionHistoryDestination {\n    case transactionDetail(item: TransactionItem)\n    case dateRangePicker(currentFromDate: Date, currentToDate: Date, onSelect: (Date, Date) -> Void)\n    case exportTransactions\n}\n\n// MARK: - Navigator Extension\nextension Navigator: TransactionHistoryNavigatorType {\n    func navigate(to destination: TransactionHistoryDestination) {\n        switch destination {\n        case .transactionDetail(let item):\n            let controller = viewControllerFactory.makeTransactionDetailController(item: item)\n            push(controller)\n\n        case .dateRangePicker(let fromDate, let toDate, let onSelect):\n            let controller = viewControllerFactory.makeDateRangePickerController(\n                fromDate: fromDate,\n                toDate: toDate,\n                maxDays: 90,\n                onSelect: onSelect\n            )\n            present(controller, animated: true)\n\n        case .exportTransactions:\n            let controller = viewControllerFactory.makeExportOptionsController(type: .transactions)\n            present(controller, animated: true)\n        }\n    }\n}\n```\n\n#### 4. TransactionHistoryViewModelTests.swift\n\n```swift\n// PayooMerchantTests/ViewModel/TransactionHistoryViewModelTests.swift\n\nimport XCTest\nimport RxSwift\nimport RxTest\nimport RxBlocking\n@testable import Domain\n@testable import PayooMerchant\n\nfinal class TransactionHistoryViewModelTests: XCTestCase {\n\n    private var viewModel: TransactionHistoryViewModel!\n    private var transactionHistoryUC: TransactionHistoryUseCaseMock!\n    private var navigator: TransactionHistoryNavigatorMock!\n    private var scheduler: TestScheduler!\n    private var disposeBag: DisposeBag!\n\n    override func setUp() {\n        super.setUp()\n\n        transactionHistoryUC = TransactionHistoryUseCaseMock()\n        navigator = TransactionHistoryNavigatorMock()\n        viewModel = TransactionHistoryViewModel(\n            transactionHistoryUC: transactionHistoryUC,\n            navigator: navigator\n        )\n\n        scheduler = TestScheduler(initialClock: 0)\n        disposeBag = DisposeBag()\n    }\n\n    override func tearDown() {\n        viewModel = nil\n        transactionHistoryUC = nil\n        navigator = nil\n        scheduler = nil\n        disposeBag = nil\n\n        super.tearDown()\n    }\n\n    func test_Transform_LoadTrigger_ReturnsTransactions() {\n        // Given\n        let mockTransactions = [\n            TransactionItem(id: 1, createdDate: \"2025-01-01 10:00:00\", title: \"Payment\", amount: 100.0, type: .payment),\n            TransactionItem(id: 2, createdDate: \"2025-01-01 09:00:00\", title: \"Refund\", amount: 50.0, type: .refund)\n        ]\n\n        transactionHistoryUC.getTransactionsReturnValue = .just(TransactionHistoryResponse(transactions: mockTransactions))\n\n        let loadTrigger = scheduler.createHotObservable([.next(10, ())])\n\n        // When\n        let input = TransactionHistoryViewModel.Input(\n            loadTrigger: loadTrigger.asObservable(),\n            loadMoreTrigger: .never(),\n            refreshTrigger: .never(),\n            selectItemTrigger: .never(),\n            changeDateRangeTrigger: .never(),\n            filterByTypeTrigger: .never()\n        )\n\n        let output = viewModel.transform(input)\n\n        let itemsObserver = scheduler.createObserver([TransactionHistoryViewModel.Item].self)\n        output.items.drive(itemsObserver).disposed(by: disposeBag)\n\n        scheduler.start()\n\n        // Then\n        XCTAssertTrue(transactionHistoryUC.getTransactionsCalled)\n        XCTAssertEqual(itemsObserver.events.last?.value.element?.count, 2)\n    }\n\n    func test_Transform_FilterByType_FiltersTransactions() {\n        // Given\n        let mockTransactions = [\n            TransactionItem(id: 1, createdDate: \"2025-01-01 10:00:00\", title: \"Payment\", amount: 100.0, type: .payment),\n            TransactionItem(id: 2, createdDate: \"2025-01-01 09:00:00\", title: \"Refund\", amount: 50.0, type: .refund)\n        ]\n\n        transactionHistoryUC.getTransactionsReturnValue = .just(TransactionHistoryResponse(transactions: mockTransactions))\n\n        let loadTrigger = scheduler.createHotObservable([.next(10, ())])\n        let filterTrigger = scheduler.createHotObservable([.next(20, TransactionType.payment)])\n\n        // When\n        let input = TransactionHistoryViewModel.Input(\n            loadTrigger: loadTrigger.asObservable(),\n            loadMoreTrigger: .never(),\n            refreshTrigger: .never(),\n            selectItemTrigger: .never(),\n            changeDateRangeTrigger: .never(),\n            filterByTypeTrigger: filterTrigger.asObservable()\n        )\n\n        let output = viewModel.transform(input)\n\n        let itemsObserver = scheduler.createObserver([TransactionHistoryViewModel.Item].self)\n        output.items.drive(itemsObserver).disposed(by: disposeBag)\n\n        scheduler.start()\n\n        // Then\n        let filteredItems = itemsObserver.events.last?.value.element\n        XCTAssertEqual(filteredItems?.count, 1)\n        XCTAssertEqual(filteredItems?.first?.type, .payment)\n    }\n\n    func test_MemoryLeak_WeakSelf_DoesNotRetain() {\n        // Given\n        weak var weakViewModel = viewModel\n\n        // When\n        viewModel = nil\n\n        // Then\n        XCTAssertNil(weakViewModel)\n    }\n}\n\n// MARK: - Mocks\n\nfinal class TransactionHistoryUseCaseMock: TransactionHistoryUseCaseType {\n    var getTransactionsCalled = false\n    var getTransactionsReturnValue: Single<TransactionHistoryResponse> = .never()\n\n    func getTransactions(fromDate: String, toDate: String) -> Single<TransactionHistoryResponse> {\n        getTransactionsCalled = true\n        return getTransactionsReturnValue\n    }\n}\n\nfinal class TransactionHistoryNavigatorMock: TransactionHistoryNavigatorType {\n    var navigateCalled = false\n    var navigateDestination: TransactionHistoryDestination?\n\n    func navigate(to destination: TransactionHistoryDestination) {\n        navigateCalled = true\n        navigateDestination = destination\n    }\n}\n```\n\n---\n\n## Example 2: Simple List Feature (No Pagination)\n\n### User Input\n\n```yaml\nFeature name: NotificationList\nFeature path: PayooMerchant/Controllers/Notification\nFeature title: Notifications\nPagination type: none\nPrimary UseCase: NotificationUseCaseType\nPrimary method: getAllNotifications()\nDomain item type: NotificationItem\nMain content cell: NotificationCell\nNavigation: notificationDetail(item:), markAllAsRead()\n```\n\n### Generated ViewModel (Simplified)\n\n```swift\n// PayooMerchant/Controllers/Notification/NotificationListViewModel.swift\n\nimport Foundation\nimport RxSwift\nimport RxCocoa\nimport Domain\n\nfinal class NotificationListViewModel: BaseViewModel {\n\n    // MARK: - Dependencies\n    private let notificationUC: NotificationUseCaseType\n\n    // MARK: - Relays\n    private let itemsRelay = BehaviorRelay<[NotificationItem]>(value: [])\n    private let isLoadingRelay = BehaviorRelay<Bool>(value: false)\n    private let errorRelay = BehaviorRelay<Error?>(value: nil)\n\n    // MARK: - Input\n    struct Input {\n        let loadTrigger: Observable<Void>\n        let refreshTrigger: Observable<Void>\n        let selectItemTrigger: Observable<IndexPath>\n        let markAllAsReadTrigger: Observable<Void>\n    }\n\n    // MARK: - Output\n    struct Output {\n        let items: Driver<[NotificationItem]>\n        let isLoading: Driver<Bool>\n        let error: Driver<Error?>\n        let selectedItem: Driver<NotificationItem>\n    }\n\n    // MARK: - Init\n    init(\n        notificationUC: NotificationUseCaseType,\n        navigator: NotificationListNavigatorType\n    ) {\n        self.notificationUC = notificationUC\n        super.init(navigator: navigator)\n    }\n\n    // MARK: - Transform\n    func transform(_ input: Input) -> Output {\n        let activityIndicator = ActivityIndicator()\n\n        // Load notifications\n        let loadedItems = Observable.merge(\n            input.loadTrigger,\n            input.refreshTrigger\n        )\n        .flatMapLatest { [weak self] _ -> Observable<[NotificationItem]> in\n            guard let self = self else { return .empty() }\n            return self.notificationUC.getAllNotifications()\n                .asObservable()\n                .trackActivity(activityIndicator)\n                .do(onError: { [weak self] error in\n                    self?.errorRelay.accept(error)\n                })\n                .catchAndReturn([])\n        }\n        .bind(to: itemsRelay)\n\n        // Handle selection\n        let selectedItem = input.selectItemTrigger\n            .withLatestFrom(itemsRelay) { indexPath, items in\n                items[indexPath.row]\n            }\n            .asDriverOnErrorJustComplete()\n\n        // Mark all as read\n        input.markAllAsReadTrigger\n            .flatMapLatest { [weak self] _ -> Observable<Void> in\n                guard let self = self else { return .empty() }\n                return self.notificationUC.markAllAsRead()\n                    .asObservable()\n                    .trackActivity(activityIndicator)\n            }\n            .bind(to: input.loadTrigger) // Reload after marking\n            .disposed(by: disposeBag)\n\n        return Output(\n            items: itemsRelay.asDriver(),\n            isLoading: activityIndicator.asDriver(),\n            error: errorRelay.asDriver(),\n            selectedItem: selectedItem\n        )\n    }\n}\n```\n\n---\n\n## Output Summary Template\n\n```markdown\n‚úÖ iOS Feature Generated: TransactionHistory\n\nüìÅ Files Created:\n  - PayooMerchant/Controllers/Transaction/History/TransactionHistoryViewModel.swift (145 lines)\n  - PayooMerchant/Controllers/Transaction/History/TransactionHistoryController.swift (182 lines)\n  - PayooMerchant/Controllers/Transaction/History/Navigator+TransactionHistory.swift (42 lines)\n  - PayooMerchantTests/ViewModel/TransactionHistoryViewModelTests.swift (178 lines)\n\nüìã Manual Steps Required:\n\n1. **Register in DependencyContainer.swift**\n   ```swift\n   container.register(TransactionHistoryViewModel.self) { resolver in\n       TransactionHistoryViewModel(\n           transactionHistoryUC: resolver.resolve(TransactionHistoryUseCaseType.self)!,\n           navigator: resolver.resolve(TransactionHistoryNavigatorType.self)!\n       )\n   }\n   ```\n\n2. **Add factory method to ViewControllerFactory**\n   ```swift\n   extension ViewControllerFactory {\n       func makeTransactionHistoryController() -> TransactionHistoryController {\n           let controller = TransactionHistoryController.instantiate()\n           controller.viewModel = DependencyContainer.shared.provide(TransactionHistoryViewModel.self)\n           return controller\n       }\n   }\n   ```\n\n3. **Update parent Navigator** (if adding to existing flow)\n   Add to home navigator enum:\n   ```swift\n   case transactionHistory\n   ```\n\nüß™ Test the Feature:\n\n1. Build project:\n   ```bash\n   xcodebuild -workspace PayooMerchant.xcworkspace \\\n     -scheme \"Payoo Merchant Sandbox\" \\\n     -configuration \"Debug Sandbox\" \\\n     -sdk iphonesimulator \\\n     -destination 'platform=iOS Simulator,OS=17.5,name=iPhone 15,arch=x86_64' \\\n     clean build\n   ```\n\n2. Run tests:\n   ```bash\n   xcodebuild test \\\n     -workspace PayooMerchant.xcworkspace \\\n     -scheme \"PayooMerchantTests\" \\\n     -configuration \"Debug Sandbox\" \\\n     -destination 'platform=iOS Simulator,OS=17.5,name=iPhone 15,arch=x86_64' \\\n     -enableCodeCoverage YES\n   ```\n\n3. Navigate: `homeNavigator.navigate(to: .transactionHistory)`\n\n‚è±Ô∏è  Estimated completion time: 15-30 minutes\n```\n",
        "py-plugin/skills/ios-reactive-list-generator/templates.md": "# iOS Feature Generator - Code Templates\n\nComplete code templates for generating iOS Presentation layer features.\n\n---\n\n## Template 1: ViewModel with Date Range Pagination\n\n```swift\n// [feature_path]/[Feature]ViewModel.swift\n\nimport Foundation\nimport RxSwift\nimport RxCocoa\nimport Domain\n\n// MARK: - Filter Object\nstruct [Feature]Filter: FilterPaginationDateRangeProvider {\n    var toDate: Date = Date()\n    var fromDate: Date = Date().addingTimeInterval(-30 * 24 * 60 * 60) // Last 30 days\n\n    // Add custom properties as needed\n    // var selectedCategory: Category?\n}\n\n// MARK: - ViewModel\nfinal class [Feature]ViewModel: BaseListPaginationDateRangeViewModel<[DomainItemType], [Feature]Filter, Any> {\n\n    // MARK: - Dependencies\n    private let [feature]UC: [PrimaryUseCaseType]\n\n    // MARK: - Input\n    struct Input {\n        let loadTrigger: Observable<Void>\n        let loadMoreTrigger: Observable<Void>\n        let refreshTrigger: Observable<Void>\n        let selectItemTrigger: Observable<IndexPath>\n        let changeDateRangeTrigger: Observable<(fromDate: Date, toDate: Date)>\n        // Add custom triggers as needed\n    }\n\n    // MARK: - Output\n    struct Output {\n        let items: Driver<[Item]>\n        let isLoading: Driver<Bool>\n        let shouldLoadMore: Driver<Bool>\n        let error: Driver<Error?>\n        let selectedItem: Driver<[DomainItemType]>\n        // Add custom outputs as needed\n    }\n\n    // MARK: - Init\n    init(\n        [feature]UC: [PrimaryUseCaseType],\n        navigator: [Feature]NavigatorType\n    ) {\n        self.[feature]UC = [feature]UC\n        super.init(navigator: navigator, filter: [Feature]Filter())\n    }\n\n    // MARK: - Transform\n    func transform(_ input: Input) -> Output {\n        // Handle date range changes\n        input.changeDateRangeTrigger\n            .subscribe(onNext: { [weak self] dates in\n                var newFilter = self?.filterObject.value ?? [Feature]Filter()\n                newFilter.fromDate = dates.fromDate\n                newFilter.toDate = dates.toDate\n                self?.filterObject.accept(newFilter)\n                self?.reload()\n            })\n            .disposed(by: disposeBag)\n\n        // Base pagination setup\n        let baseOutput = super.transform(\n            loadTrigger: input.loadTrigger,\n            reloadTrigger: input.refreshTrigger,\n            loadMoreTrigger: input.loadMoreTrigger\n        )\n\n        // Handle item selection\n        let selectedItem = input.selectItemTrigger\n            .withLatestFrom(baseOutput.items) { indexPath, items in\n                items[indexPath.row]\n            }\n            .asDriverOnErrorJustComplete()\n\n        return Output(\n            items: baseOutput.items,\n            isLoading: baseOutput.isLoading,\n            shouldLoadMore: baseOutput.shouldLoadMore,\n            error: baseOutput.error,\n            selectedItem: selectedItem\n        )\n    }\n\n    // MARK: - Fetch Items (Date-based cursor pagination)\n    override func fetchItems(_ toDate: Date) -> Observable<[[DomainItemType]]> {\n        let filter = filterObject.value\n\n        return [feature]UC.[primaryMethod](\n            fromDate: filter.fromDate.toString(format: .defaultFormatDateTime) ?? \"\",\n            toDate: toDate.toString(format: .defaultFormatDateTime) ?? \"\"\n        )\n        .asObservable()\n        .map { $0.items } // Adjust based on response structure\n    }\n}\n```\n\n---\n\n## Template 2: ViewController with RxSwift Bindings\n\n```swift\n// [feature_path]/[Feature]Controller.swift\n\nimport UIKit\nimport RxSwift\nimport RxCocoa\nimport Domain\n\nfinal class [Feature]Controller: BaseViewController {\n\n    // MARK: - IBOutlets\n    @IBOutlet private weak var tableView: UITableView!\n\n    // MARK: - Properties\n    var viewModel: [Feature]ViewModel!\n\n    // MARK: - Triggers\n    private let loadTrigger = PublishSubject<Void>()\n    private let loadMoreTrigger = PublishSubject<Void>()\n    private let refreshTrigger = PublishSubject<Void>()\n    private let selectItemTrigger = PublishSubject<IndexPath>()\n    private let changeDateRangeTrigger = PublishSubject<(fromDate: Date, toDate: Date)>()\n\n    // MARK: - Lifecycle\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        bindViewModel()\n\n        // Initial load\n        loadTrigger.onNext(())\n    }\n\n    // MARK: - Setup\n    private func setupUI() {\n        title = \"[FeatureTitle]\"\n\n        // Table view setup\n        tableView.do {\n            $0.registerCellByNib([MainContentCell].self)\n            $0.registerCellByNib(ErrorOrEmptyStateCell.self)\n            $0.estimatedRowHeight = 80\n            $0.rowHeight = UITableView.automaticDimension\n            $0.separatorStyle = .none\n        }\n\n        // Pull to refresh\n        let refreshControl = UIRefreshControl()\n        tableView.refreshControl = refreshControl\n\n        refreshControl.rx.controlEvent(.valueChanged)\n            .bind(to: refreshTrigger)\n            .disposed(by: disposeBag)\n    }\n\n    // MARK: - Binding\n    private func bindViewModel() {\n        let input = [Feature]ViewModel.Input(\n            loadTrigger: loadTrigger.asObservable(),\n            loadMoreTrigger: loadMoreTrigger.asObservable(),\n            refreshTrigger: refreshTrigger.asObservable(),\n            selectItemTrigger: selectItemTrigger.asObservable(),\n            changeDateRangeTrigger: changeDateRangeTrigger.asObservable()\n        )\n\n        let output = viewModel.transform(input)\n\n        // Bind items to table view\n        output.items\n            .drive(tableView.rx.items) { [weak self] tableView, index, item in\n                guard let self = self else { return UITableViewCell() }\n\n                let cell = tableView.dequeueReusableCell([MainContentCell].self, for: IndexPath(row: index, section: 0))\n                cell.configure(with: item)\n                return cell\n            }\n            .disposed(by: disposeBag)\n\n        // Handle loading state\n        output.isLoading\n            .drive(onNext: { [weak self] isLoading in\n                if !isLoading {\n                    self?.tableView.refreshControl?.endRefreshing()\n                }\n            })\n            .disposed(by: disposeBag)\n\n        // Handle item selection\n        output.selectedItem\n            .drive(onNext: { [weak self] item in\n                self?.navigator.navigate(to: .[featureName]Detail(item: item))\n            })\n            .disposed(by: disposeBag)\n\n        // Handle errors\n        output.error\n            .drive(onNext: { [weak self] error in\n                guard let error = error else { return }\n                self?.showError(error)\n            })\n            .disposed(by: disposeBag)\n\n        // Table view selection\n        tableView.rx.itemSelected\n            .do(onNext: { [weak self] indexPath in\n                self?.tableView.deselectRow(at: indexPath, animated: true)\n            })\n            .bind(to: selectItemTrigger)\n            .disposed(by: disposeBag)\n\n        // Infinite scroll - trigger load more when near bottom\n        tableView.rx.willDisplayCell\n            .filter { [weak self] _, indexPath in\n                guard let self = self,\n                      let itemsCount = try? output.items.asObservable().take(1).toBlocking().first()?.count\n                else { return false }\n                return indexPath.row >= itemsCount - 3\n            }\n            .map { _ in () }\n            .bind(to: loadMoreTrigger)\n            .disposed(by: disposeBag)\n    }\n\n    // MARK: - Actions\n    @IBAction private func didTapDateFilter(_ sender: UIButton) {\n        // Navigate to date range picker\n        navigator.navigate(to: .dateRangePicker(\n            currentFromDate: viewModel.filterObject.value.fromDate,\n            currentToDate: viewModel.filterObject.value.toDate,\n            onSelect: { [weak self] fromDate, toDate in\n                self?.changeDateRangeTrigger.onNext((fromDate: fromDate, toDate: toDate))\n            }\n        ))\n    }\n}\n```\n\n---\n\n## Template 3: Navigator Extension\n\n```swift\n// [feature_path]/Navigator+[Feature].swift\n\nimport Foundation\nimport Domain\n\n// MARK: - Protocol\nprotocol [Feature]NavigatorType {\n    func navigate(to destination: [Feature]Destination)\n}\n\n// MARK: - Destinations\nenum [Feature]Destination {\n    case [featureName]Detail(item: [DomainItemType])\n    case dateRangePicker(currentFromDate: Date, currentToDate: Date, onSelect: (Date, Date) -> Void)\n    // Add more destinations as needed\n}\n\n// MARK: - Navigator Extension\nextension Navigator: [Feature]NavigatorType {\n    func navigate(to destination: [Feature]Destination) {\n        switch destination {\n        case .[featureName]Detail(let item):\n            let controller = viewControllerFactory.make[Feature]DetailController(item: item)\n            push(controller)\n\n        case .dateRangePicker(let fromDate, let toDate, let onSelect):\n            let controller = viewControllerFactory.makeDateRangePickerController(\n                fromDate: fromDate,\n                toDate: toDate,\n                onSelect: onSelect\n            )\n            present(controller, animated: true)\n        }\n    }\n}\n```\n\n---\n\n## Template 4: Unit Tests with RxTest\n\n```swift\n// PayooMerchantTests/ViewModel/[Feature]ViewModelTests.swift\n\nimport XCTest\nimport RxSwift\nimport RxTest\nimport RxBlocking\n@testable import Domain\n@testable import PayooMerchant\n\nfinal class [Feature]ViewModelTests: XCTestCase {\n\n    private var viewModel: [Feature]ViewModel!\n    private var [feature]UC: [PrimaryUseCase]Mock!\n    private var navigator: [Feature]NavigatorMock!\n    private var scheduler: TestScheduler!\n    private var disposeBag: DisposeBag!\n\n    override func setUp() {\n        super.setUp()\n\n        [feature]UC = [PrimaryUseCase]Mock()\n        navigator = [Feature]NavigatorMock()\n        viewModel = [Feature]ViewModel(\n            [feature]UC: [feature]UC,\n            navigator: navigator\n        )\n\n        scheduler = TestScheduler(initialClock: 0)\n        disposeBag = DisposeBag()\n    }\n\n    override func tearDown() {\n        viewModel = nil\n        [feature]UC = nil\n        navigator = nil\n        scheduler = nil\n        disposeBag = nil\n\n        super.tearDown()\n    }\n\n    // MARK: - Tests\n\n    func test_Transform_LoadTrigger_ReturnsItems() {\n        // Given\n        let mockItems = [\n            [DomainItemType](id: 1, createdDate: \"2025-01-01 10:00:00\", title: \"Item 1\"),\n            [DomainItemType](id: 2, createdDate: \"2025-01-01 09:00:00\", title: \"Item 2\")\n        ]\n\n        [feature]UC.[primaryMethod]ReturnValue = .just([PrimaryResponse](items: mockItems))\n\n        let loadTrigger = scheduler.createHotObservable([\n            .next(10, ())\n        ])\n\n        // When\n        let input = [Feature]ViewModel.Input(\n            loadTrigger: loadTrigger.asObservable(),\n            loadMoreTrigger: .never(),\n            refreshTrigger: .never(),\n            selectItemTrigger: .never(),\n            changeDateRangeTrigger: .never()\n        )\n\n        let output = viewModel.transform(input)\n\n        let itemsObserver = scheduler.createObserver([[Feature]ViewModel.Item].self)\n        output.items\n            .drive(itemsObserver)\n            .disposed(by: disposeBag)\n\n        scheduler.start()\n\n        // Then\n        XCTAssertEqual([feature]UC.[primaryMethod]Called, true)\n        XCTAssertEqual(itemsObserver.events.last?.value.element?.count, 2)\n    }\n\n    func test_Transform_LoadMoreTrigger_AppendsItems() {\n        // Given\n        let firstPageItems = [\n            [DomainItemType](id: 1, createdDate: \"2025-01-01 10:00:00\", title: \"Item 1\")\n        ]\n        let secondPageItems = [\n            [DomainItemType](id: 2, createdDate: \"2025-01-01 09:00:00\", title: \"Item 2\")\n        ]\n\n        [feature]UC.[primaryMethod]ReturnValue = .just([PrimaryResponse](items: firstPageItems))\n\n        let loadTrigger = scheduler.createHotObservable([.next(10, ())])\n        let loadMoreTrigger = scheduler.createHotObservable([.next(20, ())])\n\n        // When\n        let input = [Feature]ViewModel.Input(\n            loadTrigger: loadTrigger.asObservable(),\n            loadMoreTrigger: loadMoreTrigger.asObservable(),\n            refreshTrigger: .never(),\n            selectItemTrigger: .never(),\n            changeDateRangeTrigger: .never()\n        )\n\n        let output = viewModel.transform(input)\n\n        let itemsObserver = scheduler.createObserver([[Feature]ViewModel.Item].self)\n        output.items.drive(itemsObserver).disposed(by: disposeBag)\n\n        // Change return value for second page\n        scheduler.scheduleAt(15) {\n            self.[feature]UC.[primaryMethod]ReturnValue = .just([PrimaryResponse](items: secondPageItems))\n        }\n\n        scheduler.start()\n\n        // Then\n        XCTAssertEqual(itemsObserver.events.last?.value.element?.count, 2)\n    }\n\n    func test_Transform_RefreshTrigger_ReplacesItems() {\n        // Test refresh replaces items instead of appending\n    }\n\n    func test_Transform_SelectItemTrigger_EmitsSelectedItem() {\n        // Test item selection\n    }\n\n    func test_Transform_ChangeDateRange_UpdatesFilter() {\n        // Test date range filter changes\n    }\n\n    func test_Transform_ErrorHandling_EmitsError() {\n        // Test error scenarios\n    }\n\n    func test_MemoryLeak_WeakSelf_DoesNotRetain() {\n        // Given\n        weak var weakViewModel = viewModel\n\n        // When\n        viewModel = nil\n\n        // Then\n        XCTAssertNil(weakViewModel, \"ViewModel should be deallocated\")\n    }\n}\n\n// MARK: - Mocks\n\nfinal class [PrimaryUseCase]Mock: [PrimaryUseCaseType] {\n    var [primaryMethod]Called = false\n    var [primaryMethod]ReturnValue: Single<[PrimaryResponse]> = .never()\n\n    func [primaryMethod](fromDate: String, toDate: String) -> Single<[PrimaryResponse]> {\n        [primaryMethod]Called = true\n        return [primaryMethod]ReturnValue\n    }\n}\n\nfinal class [Feature]NavigatorMock: [Feature]NavigatorType {\n    var navigateCalled = false\n    var navigateDestination: [Feature]Destination?\n\n    func navigate(to destination: [Feature]Destination) {\n        navigateCalled = true\n        navigateDestination = destination\n    }\n}\n```\n\n---\n\n## Template 5: DependencyContainer Registration\n\n```swift\n// Add to DependencyContainer.swift\n\n// MARK: - [Feature] Registration\n\n// Register ViewModel\ncontainer.register([Feature]ViewModel.self) { resolver in\n    [Feature]ViewModel(\n        [feature]UC: resolver.resolve([PrimaryUseCaseType].self)!,\n        navigator: resolver.resolve([Feature]NavigatorType.self)!\n    )\n}\n```\n\n---\n\n## Template 6: ViewControllerFactory Extension\n\n```swift\n// Add to ViewControllerFactory extension or create new file\n\nextension ViewControllerFactory {\n    func make[Feature]Controller() -> [Feature]Controller {\n        let controller = [Feature]Controller.instantiate()\n        controller.viewModel = DependencyContainer.shared.provide([Feature]ViewModel.self)\n        return controller\n    }\n}\n```\n\n---\n\n## Template Variables Reference\n\nWhen generating code, replace these placeholders:\n\n| Placeholder | Example | Description |\n|------------|---------|-------------|\n| `[Feature]` | `TransactionHistory` | Feature name in CamelCase |\n| `[feature]` | `transactionHistory` | Feature name in camelCase |\n| `[featureName]` | `transactionHistory` | Feature name for enum cases |\n| `[FeatureTitle]` | `\"Transaction History\"` | Display title for nav bar |\n| `[feature_path]` | `PayooMerchant/Controllers/Transaction/History` | Directory path |\n| `[DomainItemType]` | `TransactionItem` | Domain model type |\n| `[PrimaryUseCaseType]` | `TransactionHistoryUseCaseType` | UseCase protocol |\n| `[PrimaryUseCase]` | `TransactionHistoryUseCase` | UseCase implementation |\n| `[primaryMethod]` | `getTransactions` | Main data fetching method |\n| `[PrimaryResponse]` | `TransactionHistoryResponse` | Response type |\n| `[MainContentCell]` | `TransactionCell` | Main table cell class |\n\n---\n\n## Pagination Type Variations\n\n### Date Range Pagination (Default)\n- Extends: `BaseListPaginationDateRangeViewModel`\n- Filter: `FilterPaginationDateRangeProvider`\n- Item: Must conform to `PaginationDateRangeProvider`\n\n### Page Number Pagination\n- Extends: `BaseListPaginationViewModel`\n- Override: `fetchItems(_ page: Int)`\n- Use: `.page` parameter in API call\n\n### No Pagination\n- Extends: `BaseViewModel`\n- Single fetch in `transform()`\n- No loadMore trigger needed\n",
        "py-plugin/skills/ios-sdk-code-review/SKILL.md": "---\nname: ios-sdk-code-review\ndescription: Comprehensive iOS SDK code review for Payoo iOS Frameworks. Checks Clean Architecture patterns, MVVM implementation, UseCase patterns, memory management, naming conventions, API design, and Swift best practices. Use when \"review code\", \"check code\", \"code review\", \"review PR\", or analyzing Swift files in this project.\nallowed-tools: Read, Grep, Glob\n---\n\n# iOS SDK Code Review\n\nPerform comprehensive code reviews for Payoo iOS Frameworks following Clean Architecture, MVVM, and iOS SDK best practices.\n\n## When to Activate\n\n- \"review code\", \"code review\", \"check this code\"\n- \"review PR\", \"review pull request\", \"review MR\"\n- \"check iOS code\", \"review Swift code\"\n- User asks about code quality or best practices\n- Reviewing ViewModels, ViewControllers, UseCases, or DataSources\n\n## Review Process\n\n### 1. Identify Code Context\n\nDetermine what's being reviewed:\n- **File type**: ViewModel, ViewController, UseCase, DataSource, Model, Service\n- **Framework**: PayooCore, PayooEwallet, PayooPayment, etc.\n- **Layer**: Presentation (Scenes), Domain (UseCase), Data (DataSources/Services)\n\n### 2. Architecture Review\n\n**Clean Architecture Compliance:**\n- ‚úì Proper layer separation (Presentation/Domain/Data)\n- ‚úì Dependencies point inward (Presentation ‚Üí Domain ‚Üí Data)\n- ‚úì ViewModels don't directly access Services (must use UseCases)\n- ‚úì Models in correct layer (Domain models vs Data models)\n\n**MVVM Pattern:**\n- ‚úì ViewModel has protocol definition (`{Feature}ViewModelType`)\n- ‚úì Delegate protocol exists (`{Feature}ViewModelDelegate`)\n- ‚úì ViewController implements delegate\n- ‚úì ViewModel is testable (no UIKit dependencies)\n- ‚úì View state managed through delegate callbacks\n\n**UseCase Pattern:**\n- ‚úì Business logic in UseCases, not ViewModels\n- ‚úì Single responsibility per UseCase\n- ‚úì UseCases injected into ViewModels\n- ‚úì UseCases coordinate repositories/services\n\n### 3. Memory Management Review\n\n**Retain Cycles:**\n- ‚úì Delegates marked `weak`\n- ‚úì Closures use `[weak self]` or `[unowned self]` appropriately\n- ‚úì No strong reference cycles in ViewModels\n- ‚úì Timer/observer cleanup in `deinit`\n\n**Example issues:**\n```swift\n// ‚ùå BAD: Strong delegate reference\nvar delegate: SomeDelegate?\n\n// ‚úÖ GOOD: Weak delegate reference\nweak var delegate: SomeDelegate?\n\n// ‚ùå BAD: Strong self in closure\nviewModel.loadData { data in\n    self.updateUI(data)\n}\n\n// ‚úÖ GOOD: Weak self in closure\nviewModel.loadData { [weak self] data in\n    self?.updateUI(data)\n}\n```\n\n### 4. Dependency Injection Review\n\n**Constructor Injection:**\n- ‚úì Dependencies injected via `init`\n- ‚úì All required dependencies in initializer\n- ‚úì No service locator or singletons (except context)\n- ‚úì Dependencies are protocols, not concrete types\n\n**Example:**\n```swift\n// ‚úÖ GOOD: Constructor injection\nfinal class DepositViewModel {\n    private let depositAmountUC: DepositAmountUseCase\n    private let bankAccountUC: BankAccountUseCase\n\n    init(depositAmountUC: DepositAmountUseCase,\n         bankAccountUC: BankAccountUseCase) {\n        self.depositAmountUC = depositAmountUC\n        self.bankAccountUC = bankAccountUC\n    }\n}\n\n// ‚ùå BAD: Service locator pattern\nlet service = ServiceLocator.shared.depositService\n```\n\n### 5. Naming Conventions Review\n\n**File Names:**\n- ‚úì ViewModels: `{Feature}ViewModel.swift`\n- ‚úì ViewControllers: `{Feature}ViewController.swift`\n- ‚úì UseCases: `{Feature}UseCase.swift`\n- ‚úì DataSources: `{Feature}DataSource.swift`\n- ‚úì Cells: `{Name}Cell.swift`\n\n**Class/Protocol Names:**\n- ‚úì Protocols end with `Type` for interfaces: `DepositViewModelType`\n- ‚úì Delegate protocols end with `Delegate`: `DepositViewModelDelegate`\n- ‚úì Clear, descriptive names (no abbreviations)\n- ‚úì Consistent with project conventions\n\n**Variables:**\n- ‚úì `context` for PayooEwalletContext\n- ‚úì `{name}UC` for UseCase instances: `depositAmountUC`\n- ‚úì Descriptive names, avoid single letters (except in loops)\n\n### 6. API Design Review\n\n**For SDK Public APIs:**\n- ‚úì Clear, self-documenting method names\n- ‚úì Delegate patterns for callbacks\n- ‚úì Error handling with proper Error types\n- ‚úì Thread-safe if needed\n- ‚úì No force unwrapping in public APIs\n- ‚úì Proper access control (`public`, `internal`, `private`)\n\n**Error Handling:**\n```swift\n// ‚úÖ GOOD: Proper error handling\nenum DepositError: Error, LocalizedError {\n    case outOfRange(bank: String, min: Double, max: Double)\n\n    var errorDescription: String? {\n        switch self {\n        case .outOfRange(let bank, let min, let max):\n            return \"Amount out of range for \\(bank): \\(min)-\\(max)\"\n        }\n    }\n}\n\n// ‚ùå BAD: Generic errors\nthrow NSError(domain: \"Error\", code: -1, userInfo: nil)\n```\n\n### 7. Swift Best Practices\n\n**Code Quality:**\n- ‚úì No force unwrapping (`!`) unless absolutely safe\n- ‚úì Use `guard let` for early returns\n- ‚úì Prefer `let` over `var`\n- ‚úì Access control appropriately set\n- ‚úì No commented-out code\n- ‚úì Proper use of `final` for classes not meant to be subclassed\n\n**SwiftLint Compliance:**\n- ‚úì Line length ‚â§ 120 characters\n- ‚úì File length ‚â§ 500 lines (warning), ‚â§ 1200 (error)\n- ‚úì Type body length ‚â§ 300 lines (warning), ‚â§ 400 (error)\n- ‚úì No trailing whitespace\n\n### 8. Multi-Target Configuration\n\n**Internal/External Builds:**\n- ‚úì Internal-only code wrapped in `#if INTERNAL`\n- ‚úì No internal features leaking to external builds\n- ‚úì Proper preprocessor flag usage\n\n```swift\n#if INTERNAL\n    // Internal-only features\n    func debugFunction() { }\n#endif\n```\n\n### 9. Localization Review\n\n- ‚úì All user-facing strings use `L10n.*` (SwiftGen)\n- ‚úì No hardcoded strings for UI text\n- ‚úì Proper format strings for dynamic content\n\n```swift\n// ‚úÖ GOOD: Localized strings\nlet title = L10n.Deposit.Navigation.deposit\nlet message = L10n.Message.Deposit.outOfRange(min, max, bank)\n\n// ‚ùå BAD: Hardcoded strings\nlet title = \"Deposit\"\n```\n\n## Output Format\n\nProvide review as structured report:\n\n```markdown\n## Code Review: {FileName}\n\n### ‚úÖ Strengths\n- [List what's done well]\n\n### ‚ö†Ô∏è Issues Found\n\n#### üî¥ Critical Issues\n**Issue:** [Description]\n**Location:** {File}:{Line}\n**Impact:** [Why this matters]\n**Fix:**\n\\```swift\n// Current code\n[problematic code]\n\n// Suggested fix\n[fixed code]\n\\```\n\n#### üü° Warnings\n**Issue:** [Description]\n**Location:** {File}:{Line}\n**Suggestion:** [How to improve]\n\n#### üîµ Suggestions\n**Enhancement:** [Description]\n**Benefit:** [Why this would help]\n\n### üìä Summary\n- Critical Issues: X\n- Warnings: Y\n- Suggestions: Z\n- Overall: [Pass/Needs Work/Fail]\n\n### üéØ Priority Actions\n1. [Most important fix]\n2. [Second priority]\n3. [Third priority]\n```\n\n## Review Checklists by File Type\n\n### ViewModel Review\n- [ ] Has protocol definition (`{Name}ViewModelType`)\n- [ ] Has delegate protocol (`{Name}ViewModelDelegate`)\n- [ ] Delegate marked `weak`\n- [ ] Dependencies injected via `init`\n- [ ] No UIKit imports\n- [ ] Uses UseCases for business logic\n- [ ] Closures use `[weak self]`\n- [ ] Testable (no side effects in init)\n\n### ViewController Review\n- [ ] Inherits from appropriate base class\n- [ ] Implements ViewModel delegate\n- [ ] Sets up analytics (`analyticsFeature`, `analyticsScreenName`)\n- [ ] Proper lifecycle management\n- [ ] IBOutlets are `weak`\n- [ ] Navigation setup in `viewDidLoad` or dedicated method\n- [ ] No business logic (delegated to ViewModel)\n\n### UseCase Review\n- [ ] Single responsibility\n- [ ] Injected dependencies\n- [ ] No UIKit dependencies\n- [ ] Proper error handling with typed errors\n- [ ] Testable\n\n### DataSource Review\n- [ ] Conforms to UITableView/UICollectionView protocols\n- [ ] Clean separation from ViewController\n- [ ] Reusable cell registration\n- [ ] Proper indexPath handling\n\n## Key Principles\n\n1. **Clean Architecture First**: Verify proper layer separation\n2. **Memory Safety**: Check for retain cycles, weak references\n3. **Dependency Injection**: Ensure dependencies are injected, not created\n4. **Naming Consistency**: Follow project naming conventions\n5. **SDK Quality**: Public APIs are well-designed and documented\n6. **Testability**: Code is structured for unit testing\n7. **Swift Idioms**: Use modern Swift patterns\n\n## Quick Commands\n\nIf you need to review specific patterns across the codebase:\n\n```bash\n# Find all ViewModels\ngrep -r \"class.*ViewModel\" --include=\"*.swift\" PayooEwallet/\n\n# Find potential retain cycles (strong self in closures)\ngrep -r \"{ self\\.\" --include=\"*.swift\" PayooEwallet/\n\n# Find force unwraps\ngrep -r \"!\" --include=\"*.swift\" PayooEwallet/ | grep -v \"!=\"\n\n# Find hardcoded strings\ngrep -r \"\\\"[A-Z]\" --include=\"*.swift\" PayooEwallet/ | grep -v \"L10n\"\n```\n",
        "py-plugin/skills/ios-sdk-code-review/examples.md": "# Code Review Examples\n\nReal-world examples of good and bad patterns from iOS SDK development.\n\n## Example 1: ViewModel Pattern\n\n### ‚úÖ GOOD Example\n\n```swift\n// DepositViewModel.swift\n\nprotocol DepositViewModelType: BaseViewModelType {\n    var delegate: DepositViewModelDelegate? { get set }\n    var balance: Double { get }\n    func topup(amount: Double)\n}\n\nprotocol DepositViewModelDelegate: AnyObject {\n    func showError(_ error: EwalletError)\n    func updateLimitInfo(min: Double, max: Double)\n    func showDepositConfirm(collector: DepositDataCollector)\n}\n\nfinal class DepositViewModel: DepositViewModelType {\n    weak var delegate: DepositViewModelDelegate?\n    private let context: PayooEwalletContext\n    private let depositAmountUC: DepositAmountUseCase\n    private let bankAccountUC: BankAccountUseCase\n\n    var balance: Double {\n        return context.balanceInfo?.availableBalance ?? 0.0\n    }\n\n    init(context: PayooEwalletContext,\n         depositAmountUC: DepositAmountUseCase,\n         bankAccountUC: BankAccountUseCase) {\n        self.context = context\n        self.depositAmountUC = depositAmountUC\n        self.bankAccountUC = bankAccountUC\n    }\n\n    func topup(amount: Double) {\n        depositAmountUC.validateAmount(amount) { [weak self] result in\n            switch result {\n            case .success(let collector):\n                self?.delegate?.showDepositConfirm(collector: collector)\n            case .failure(let error):\n                self?.delegate?.showError(error)\n            }\n        }\n    }\n}\n```\n\n**Why this is good:**\n- ‚úì Protocol-based design\n- ‚úì Weak delegate to prevent retain cycles\n- ‚úì Constructor injection\n- ‚úì Uses UseCases for business logic\n- ‚úì `[weak self]` in closures\n- ‚úì No UIKit dependencies\n- ‚úì Testable\n\n### ‚ùå BAD Example\n\n```swift\nfinal class DepositViewModel {\n    var delegate: DepositViewModelDelegate?  // ‚ùå Not weak\n\n    init() {  // ‚ùå No dependency injection\n        // Creating dependencies internally\n    }\n\n    func topup(amount: Double) {\n        // ‚ùå Business logic in ViewModel\n        let service = NetworkService.shared  // ‚ùå Singleton\n        service.deposit(amount: amount) { data in  // ‚ùå Strong self capture\n            self.delegate?.showConfirm()\n        }\n    }\n}\n```\n\n**Problems:**\n- ‚ùå Strong delegate reference (retain cycle)\n- ‚ùå No dependency injection\n- ‚ùå Business logic in ViewModel (should be in UseCase)\n- ‚ùå Using singleton directly\n- ‚ùå Strong self capture in closure\n- ‚ùå No protocol definition\n- ‚ùå Hard to test\n\n## Example 2: UseCase Pattern\n\n### ‚úÖ GOOD Example\n\n```swift\n// DepositAmountUseCase.swift\n\nclass DepositAmountUseCase {\n    private let apiService: ApiServiceType\n    private let settingUC: SettingsUseCase\n\n    enum DepositError: Error, LocalizedError {\n        case outOfRange(bank: String, min: Double, max: Double)\n        case exceedMaxTimesDeposit(bankName: String, times: Int)\n\n        var errorDescription: String? {\n            switch self {\n            case .outOfRange(let bank, let min, let max):\n                return L10n.Message.Deposit.outOfRange(\n                    min.currencyString,\n                    max.currencyString,\n                    bank\n                )\n            case .exceedMaxTimesDeposit(let bankName, let times):\n                return L10n.Message.Deposit.exceedMaxTimesDeposit(\n                    bankName,\n                    times\n                )\n            }\n        }\n    }\n\n    init(apiService: ApiServiceType, settingUC: SettingsUseCase) {\n        self.apiService = apiService\n        self.settingUC = settingUC\n    }\n\n    func validateAmount(\n        _ amount: Double,\n        completion: @escaping (Result<DepositDataCollector, DepositError>) -> Void\n    ) {\n        let limits = settingUC.getDepositLimits()\n\n        guard amount >= limits.min && amount <= limits.max else {\n            completion(.failure(.outOfRange(\n                bank: limits.bankName,\n                min: limits.min,\n                max: limits.max\n            )))\n            return\n        }\n\n        // Additional validation logic...\n        let collector = DepositDataCollector(amount: amount)\n        completion(.success(collector))\n    }\n}\n```\n\n**Why this is good:**\n- ‚úì Single responsibility (deposit validation)\n- ‚úì Injected dependencies\n- ‚úì Typed, localized errors\n- ‚úì Clean API with Result type\n- ‚úì No UIKit dependencies\n- ‚úì Testable\n\n### ‚ùå BAD Example\n\n```swift\nclass DepositUseCase {\n    // ‚ùå No dependency injection\n    func validateAndDeposit(_ amount: Double) {\n        // ‚ùå Multiple responsibilities\n        // ‚ùå Direct service access\n        let service = APIService()\n\n        // ‚ùå Generic error\n        guard amount > 0 else {\n            throw NSError(domain: \"Invalid\", code: -1)\n        }\n\n        // ‚ùå Hardcoded string\n        print(\"Validating amount\")\n\n        // ‚ùå Mixing concerns\n        UIAlertController.show(message: \"Success\")\n    }\n}\n```\n\n## Example 3: Memory Management\n\n### ‚úÖ GOOD Example\n\n```swift\nfinal class WithdrawViewModel {\n    weak var delegate: WithdrawViewModelDelegate?\n    private let withdrawUC: WithdrawUseCase\n    private var timer: Timer?\n\n    init(withdrawUC: WithdrawUseCase) {\n        self.withdrawUC = withdrawUC\n    }\n\n    func startPolling() {\n        timer = Timer.scheduledTimer(\n            withTimeInterval: 5.0,\n            repeats: true\n        ) { [weak self] _ in\n            self?.checkStatus()\n        }\n    }\n\n    func checkStatus() {\n        withdrawUC.getStatus { [weak self] result in\n            guard let self = self else { return }\n            self.handleResult(result)\n        }\n    }\n\n    deinit {\n        timer?.invalidate()\n        timer = nil\n    }\n}\n```\n\n**Why this is good:**\n- ‚úì Weak delegate\n- ‚úì `[weak self]` in closures\n- ‚úì Proper cleanup in `deinit`\n- ‚úì No retain cycles\n\n### ‚ùå BAD Example\n\n```swift\nclass WithdrawViewModel {\n    var delegate: WithdrawViewModelDelegate?  // ‚ùå Strong reference\n    private var timer: Timer?\n\n    func startPolling() {\n        timer = Timer.scheduledTimer(\n            withTimeInterval: 5.0,\n            repeats: true\n        ) { _ in\n            self.checkStatus()  // ‚ùå Implicit strong self capture\n        }\n    }\n\n    func checkStatus() {\n        service.getStatus { result in  // ‚ùå Strong self capture\n            self.delegate?.update(result)\n        }\n    }\n\n    // ‚ùå No cleanup - timer keeps running\n}\n```\n\n## Example 4: ViewController Pattern\n\n### ‚úÖ GOOD Example\n\n```swift\nfinal class DepositViewController: FirstViewController {\n    @IBOutlet private weak var scrollView: UIScrollView!\n    @IBOutlet private weak var balanceLabel: UILabel!\n\n    private var viewModel: DepositViewModelType\n    private let vcFactory: ViewControllerType\n\n    init(context: PayooEwalletContext,\n         viewModel: DepositViewModelType,\n         vcFactory: ViewControllerType) {\n        self.viewModel = viewModel\n        self.vcFactory = vcFactory\n        super.init(context: context)\n        self.viewModel.delegate = self\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        analyticsFeature = PYAnalyticsKeys.FeatureName.deposit\n        analyticsScreenName = PYAnalyticsKeys.ScreenName.deposit\n        setupViews()\n        viewModel.load()\n    }\n\n    private func setupViews() {\n        navigationItem.set(title: L10n.Deposit.Navigation.deposit)\n        // View setup...\n    }\n}\n\nextension DepositViewController: DepositViewModelDelegate {\n    func showError(_ error: EwalletError) {\n        showAlert(message: error.localizedDescription)\n    }\n\n    func updateLimitInfo(min: Double, max: Double) {\n        // Update UI\n    }\n}\n```\n\n**Why this is good:**\n- ‚úì IBOutlets are `weak`\n- ‚úì Dependency injection\n- ‚úì Sets analytics properties\n- ‚úì Implements delegate pattern\n- ‚úì No business logic\n- ‚úì Localized strings\n\n### ‚ùå BAD Example\n\n```swift\nclass DepositViewController: UIViewController {\n    @IBOutlet var scrollView: UIScrollView!  // ‚ùå Not weak\n\n    var viewModel: DepositViewModel?  // ‚ùå Optional, not injected\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        viewModel = DepositViewModel()  // ‚ùå Creating dependency\n\n        // ‚ùå Business logic in ViewController\n        if amount > 1000 {\n            // Validation logic...\n        }\n\n        // ‚ùå Hardcoded string\n        title = \"Deposit\"\n    }\n}\n```\n\n## Example 5: DataSource Pattern\n\n### ‚úÖ GOOD Example\n\n```swift\nfinal class CardDataSource: NSObject {\n    private var items: [CardModel] = []\n    private weak var delegate: CardDataSourceDelegate?\n\n    init(delegate: CardDataSourceDelegate) {\n        self.delegate = delegate\n    }\n\n    func update(with items: [CardModel]) {\n        self.items = items\n    }\n}\n\nextension CardDataSource: UICollectionViewDataSource {\n    func collectionView(\n        _ collectionView: UICollectionView,\n        numberOfItemsInSection section: Int\n    ) -> Int {\n        return items.count\n    }\n\n    func collectionView(\n        _ collectionView: UICollectionView,\n        cellForItemAt indexPath: IndexPath\n    ) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(\n            withReuseIdentifier: CardCell.identifier,\n            for: indexPath\n        ) as! CardCell\n\n        let item = items[indexPath.row]\n        cell.configure(with: item)\n        return cell\n    }\n}\n\nextension CardDataSource: UICollectionViewDelegate {\n    func collectionView(\n        _ collectionView: UICollectionView,\n        didSelectItemAt indexPath: IndexPath\n    ) {\n        let item = items[indexPath.row]\n        delegate?.didSelectCard(item)\n    }\n}\n```\n\n**Why this is good:**\n- ‚úì Clean separation from ViewController\n- ‚úì Weak delegate\n- ‚úì Proper cell reuse\n- ‚úì Type-safe cell dequeuing\n- ‚úì Single responsibility\n\n## Example 6: Error Handling\n\n### ‚úÖ GOOD Example\n\n```swift\nenum WithdrawError: Error, LocalizedError {\n    case insufficientBalance(available: Double, requested: Double)\n    case bankNotAvailable(bankName: String)\n    case limitExceeded(limit: Double)\n    case invalidAmount\n\n    var errorDescription: String? {\n        switch self {\n        case .insufficientBalance(let available, let requested):\n            return L10n.Error.Withdraw.insufficientBalance(\n                available.currencyString,\n                requested.currencyString\n            )\n        case .bankNotAvailable(let bankName):\n            return L10n.Error.Withdraw.bankNotAvailable(bankName)\n        case .limitExceeded(let limit):\n            return L10n.Error.Withdraw.limitExceeded(limit.currencyString)\n        case .invalidAmount:\n            return L10n.Error.Withdraw.invalidAmount\n        }\n    }\n\n    var recoverySuggestion: String? {\n        switch self {\n        case .insufficientBalance:\n            return L10n.Error.Withdraw.depositSuggestion\n        case .bankNotAvailable:\n            return L10n.Error.Withdraw.selectAnotherBank\n        default:\n            return nil\n        }\n    }\n}\n```\n\n**Why this is good:**\n- ‚úì Typed errors with associated values\n- ‚úì Implements `LocalizedError`\n- ‚úì User-friendly error messages\n- ‚úì Recovery suggestions\n- ‚úì Uses localized strings\n\n### ‚ùå BAD Example\n\n```swift\n// ‚ùå Generic error\nthrow NSError(domain: \"WithdrawError\", code: 100)\n\n// ‚ùå String errors\nthrow \"Insufficient balance\"\n\n// ‚ùå Hardcoded messages\nlet error = NSError(\n    domain: \"Error\",\n    code: -1,\n    userInfo: [NSLocalizedDescriptionKey: \"Failed to withdraw\"]\n)\n```\n",
        "py-plugin/skills/ios-sdk-code-review/standards.md": "# iOS SDK Code Standards\n\nProject-specific standards and guidelines for Payoo iOS Frameworks.\n\n## Architecture Standards\n\n### Clean Architecture Layers\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Presentation Layer (Scenes)          ‚îÇ\n‚îÇ   - ViewControllers                     ‚îÇ\n‚îÇ   - ViewModels                          ‚îÇ\n‚îÇ   - Views, Cells                        ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n               ‚îÇ depends on\n               ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Domain Layer (UseCase)                ‚îÇ\n‚îÇ   - UseCases (Business Logic)           ‚îÇ\n‚îÇ   - Domain Models                       ‚îÇ\n‚îÇ   - Protocols                           ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n               ‚îÇ depends on\n               ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Data Layer                            ‚îÇ\n‚îÇ   - DataSources                         ‚îÇ\n‚îÇ   - Services (API)                      ‚îÇ\n‚îÇ   - Repositories                        ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Rules:**\n1. Dependencies only point **downward** (Presentation ‚Üí Domain ‚Üí Data)\n2. Domain layer has **no dependencies** on Presentation or Data\n3. ViewModels **never** directly access Services (must use UseCases)\n4. No UIKit in Domain or Data layers\n\n### MVVM Standards\n\n**Protocol Definition Required:**\n\nEvery ViewModel must have:\n1. **Type Protocol**: `{Feature}ViewModelType`\n2. **Delegate Protocol**: `{Feature}ViewModelDelegate`\n\n```swift\nprotocol DepositViewModelType: BaseViewModelType {\n    var delegate: DepositViewModelDelegate? { get set }\n    // Public interface\n}\n\nprotocol DepositViewModelDelegate: AnyObject {\n    // Callbacks to view\n}\n\nfinal class DepositViewModel: DepositViewModelType {\n    weak var delegate: DepositViewModelDelegate?\n    // Implementation\n}\n```\n\n**ViewModel Responsibilities:**\n- ‚úì Presentation logic only\n- ‚úì Coordinate UseCases\n- ‚úì Transform domain data for display\n- ‚úì Manage view state\n\n**ViewModel Must NOT:**\n- ‚ùå Import UIKit\n- ‚ùå Contain business logic (use UseCases)\n- ‚ùå Directly call API services\n- ‚ùå Manage view lifecycle\n\n### UseCase Standards\n\n**One UseCase = One Business Capability**\n\n```swift\n// ‚úÖ GOOD: Single responsibility\nclass DepositAmountUseCase {\n    // Only handles deposit amount validation\n}\n\nclass BankAccountUseCase {\n    // Only handles bank account operations\n}\n\n// ‚ùå BAD: Multiple responsibilities\nclass EwalletUseCase {\n    // Handles everything - too broad\n}\n```\n\n**UseCase Structure:**\n\n```swift\nclass {Feature}UseCase {\n    // MARK: - Dependencies (injected)\n    private let apiService: ApiServiceType\n    private let otherUC: OtherUseCase\n\n    // MARK: - Initialization\n    init(apiService: ApiServiceType, otherUC: OtherUseCase) {\n        self.apiService = apiService\n        self.otherUC = otherUC\n    }\n\n    // MARK: - Public Methods\n    func performAction(\n        parameters: ParamType,\n        completion: @escaping (Result<DataType, ErrorType>) -> Void\n    ) {\n        // Business logic implementation\n    }\n\n    // MARK: - Private Helpers\n    private func helperMethod() {\n        // Internal logic\n    }\n}\n```\n\n## Memory Management Standards\n\n### Delegate Pattern\n\n**Always use `weak` for delegates:**\n\n```swift\n// ‚úÖ CORRECT\nprotocol SomeDelegate: AnyObject { }\n\nclass SomeClass {\n    weak var delegate: SomeDelegate?\n}\n\n// ‚ùå WRONG\nclass SomeClass {\n    var delegate: SomeDelegate?  // Strong reference!\n}\n```\n\n### Closure Capture Lists\n\n**Use `[weak self]` in closures:**\n\n```swift\n// ‚úÖ CORRECT\nnetworkService.fetch { [weak self] result in\n    guard let self = self else { return }\n    self.handleResult(result)\n}\n\n// Alternative for non-escaping\nsomeMethod { [weak self] in\n    self?.updateUI()\n}\n\n// ‚ùå WRONG\nnetworkService.fetch { result in\n    self.handleResult(result)  // Retain cycle!\n}\n```\n\n**When to use `unowned`:**\n- Only when 100% certain object will outlive closure\n- Rare cases in this codebase - prefer `weak`\n\n### Timer and Observer Cleanup\n\n```swift\nclass SomeViewModel {\n    private var timer: Timer?\n    private var observer: NSObjectProtocol?\n\n    deinit {\n        // ‚úÖ Always cleanup\n        timer?.invalidate()\n        timer = nil\n\n        if let observer = observer {\n            NotificationCenter.default.removeObserver(observer)\n        }\n    }\n}\n```\n\n## Naming Conventions\n\n### File Names\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| ViewModel | `{Feature}ViewModel.swift` | `DepositViewModel.swift` |\n| ViewController | `{Feature}ViewController.swift` | `DepositViewController.swift` |\n| UseCase | `{Feature}UseCase.swift` | `DepositAmountUseCase.swift` |\n| DataSource | `{Feature}DataSource.swift` | `CardDataSource.swift` |\n| DataCollector | `{Feature}Collector.swift` | `DepositCollector.swift` |\n| Cell | `{Name}Cell.swift` | `AmountCell.swift` |\n| Model | `{Name}.swift` | `BankAccount.swift` |\n\n### Class and Protocol Names\n\n```swift\n// Protocols\nprotocol DepositViewModelType { }      // Interface\nprotocol DepositViewModelDelegate { }  // Delegate pattern\nprotocol ApiServiceType { }            // Service interface\n\n// Classes\nfinal class DepositViewModel { }       // Implementation\nclass DepositAmountUseCase { }         // UseCase\nfinal class DepositViewController { }  // ViewController\n```\n\n### Variable Names\n\n```swift\n// UseCase instances: {name}UC\nprivate let depositAmountUC: DepositAmountUseCase\nprivate let bankAccountUC: BankAccountUseCase\nprivate let settingsUC: SettingsUseCase\n\n// Context\nprivate let context: PayooEwalletContext\n\n// Factory\nprivate let vcFactory: ViewControllerType\n\n// Avoid abbreviations\nvar bankAccount: BankAccount  // ‚úÖ Good\nvar ba: BankAccount           // ‚ùå Bad\n```\n\n## Dependency Injection Standards\n\n### Constructor Injection (Preferred)\n\n```swift\nfinal class DepositViewModel {\n    private let depositAmountUC: DepositAmountUseCase\n    private let bankAccountUC: BankAccountUseCase\n\n    // ‚úÖ All dependencies in initializer\n    init(depositAmountUC: DepositAmountUseCase,\n         bankAccountUC: BankAccountUseCase) {\n        self.depositAmountUC = depositAmountUC\n        self.bankAccountUC = bankAccountUC\n    }\n}\n```\n\n### Context Pattern\n\n`PayooEwalletContext` is acceptable for shared dependencies:\n\n```swift\nfinal class SomeViewModel {\n    private let context: PayooEwalletContext\n\n    var balance: Double {\n        return context.balanceInfo?.availableBalance ?? 0.0\n    }\n}\n```\n\n### What NOT to do\n\n```swift\n// ‚ùå Service locator\nlet service = ServiceLocator.shared.depositService\n\n// ‚ùå Singletons (except system services)\nlet manager = NetworkManager.shared\n\n// ‚ùå Creating dependencies inside\ninit() {\n    self.service = NetworkService()  // Should be injected\n}\n```\n\n## SwiftLint Standards\n\n### Line Length\n- **Maximum**: 120 characters\n- Break long lines for readability\n\n### File Length\n- **Warning**: 500 lines\n- **Error**: 1200 lines\n- Split large files into extensions or separate files\n\n### Type Body Length\n- **Warning**: 300 lines\n- **Error**: 400 lines\n- Extract protocols, extensions to separate files\n\n### Force Unwrapping\n- **Avoid**: Only use `!` when 100% safe\n- Prefer `guard let`, `if let`, or optional chaining\n\n```swift\n// ‚úÖ GOOD\nguard let value = optional else { return }\n\nif let value = optional {\n    use(value)\n}\n\noptional?.method()\n\n// ‚ùå AVOID\nlet value = optional!\n```\n\n## API Design Standards\n\n### Public SDK APIs\n\n```swift\n// ‚úÖ Clear, descriptive method names\npublic func deposit(\n    amount: Double,\n    completion: @escaping (Result<DepositResult, DepositError>) -> Void\n)\n\n// ‚úÖ Delegate pattern for callbacks\npublic protocol PayooEwalletDelegate: AnyObject {\n    func ewalletDidComplete(result: EwalletResult)\n    func ewalletDidFail(error: EwalletError)\n}\n\n// ‚úÖ Typed errors\npublic enum DepositError: Error, LocalizedError {\n    case insufficientBalance\n    case invalidAmount\n    case networkFailure(Error)\n}\n```\n\n### Access Control\n\n```swift\n// Public API\npublic class PayooEwalletContext { }\npublic protocol PayooEwalletDelegate { }\n\n// Internal (framework-only)\ninternal class NetworkService { }\ninternal struct Config { }\n\n// Private (file-only)\nprivate func helperMethod() { }\nprivate let constant = \"value\"\n\n// File-private (accessible in extensions)\nfileprivate class InternalHelper { }\n```\n\n## Error Handling Standards\n\n### Typed Errors with Localization\n\n```swift\nenum DepositError: Error, LocalizedError {\n    case outOfRange(bank: String, min: Double, max: Double)\n    case exceedMaxTimesDeposit(bankName: String, times: Int)\n    case networkFailure(Error)\n\n    var errorDescription: String? {\n        switch self {\n        case .outOfRange(let bank, let min, let max):\n            return L10n.Message.Deposit.outOfRange(\n                min.currencyString,\n                max.currencyString,\n                bank\n            )\n        case .exceedMaxTimesDeposit(let bankName, let times):\n            return L10n.Message.Deposit.exceedMaxTimesDeposit(\n                bankName,\n                times\n            )\n        case .networkFailure(let error):\n            return error.localizedDescription\n        }\n    }\n\n    var recoverySuggestion: String? {\n        switch self {\n        case .outOfRange:\n            return L10n.Message.Deposit.adjustAmount\n        default:\n            return nil\n        }\n    }\n}\n```\n\n### Result Type Pattern\n\n```swift\n// ‚úÖ Preferred for async operations\nfunc validateAmount(\n    _ amount: Double,\n    completion: @escaping (Result<Collector, DepositError>) -> Void\n) {\n    // Implementation\n    completion(.success(collector))\n    // or\n    completion(.failure(.invalidAmount))\n}\n```\n\n## Localization Standards\n\n### SwiftGen Usage\n\nAll user-facing strings must use SwiftGen:\n\n```swift\n// ‚úÖ CORRECT\nlet title = L10n.Deposit.Navigation.deposit\nlet message = L10n.Message.Deposit.outOfRange(min, max, bank)\nlet button = L10n.Btn.Title.confirm\n\n// ‚ùå WRONG\nlet title = \"Deposit\"\nlet message = \"Amount out of range\"\n```\n\n### String Format\n\nFor strings with parameters:\n\n```swift\n// In Localizable.strings:\n// \"deposit.message.out_of_range\" = \"Amount must be between %@ and %@ for %@\";\n\n// In code:\nL10n.Message.Deposit.outOfRange(\n    minAmount.currencyString,\n    maxAmount.currencyString,\n    bankName\n)\n```\n\n## Multi-Target Standards\n\n### Internal/External Builds\n\n```swift\n#if INTERNAL\n    // Internal-only features\n    public func debugMode() {\n        // Only available in internal builds\n    }\n\n    private func internalHelper() {\n        // Internal tools\n    }\n#endif\n\n// Always available\npublic func publicAPI() {\n    #if INTERNAL\n        enableDebugLogging()\n    #endif\n\n    // Public functionality\n}\n```\n\n### Build Configuration\n\n- **Internal Target**: Has `-D INTERNAL` flag in Swift Compiler settings\n- **External Target**: No `INTERNAL` flag, same product name\n- Check build settings: `Swift Compiler - Custom Flags`\n\n## Testing Standards\n\n### ViewModel Testing\n\n```swift\nfinal class DepositViewModelTests: XCTestCase {\n    var sut: DepositViewModel!\n    var mockDelegate: MockDepositViewModelDelegate!\n    var mockDepositUC: MockDepositAmountUseCase!\n\n    override func setUp() {\n        super.setUp()\n        mockDelegate = MockDepositViewModelDelegate()\n        mockDepositUC = MockDepositAmountUseCase()\n        sut = DepositViewModel(\n            depositAmountUC: mockDepositUC,\n            // ... other dependencies\n        )\n        sut.delegate = mockDelegate\n    }\n\n    override func tearDown() {\n        sut = nil\n        mockDelegate = nil\n        mockDepositUC = nil\n        super.tearDown()\n    }\n\n    func testTopupSuccess() {\n        // Given\n        let amount = 100000.0\n        mockDepositUC.shouldSucceed = true\n\n        // When\n        sut.topup(amount: amount)\n\n        // Then\n        XCTAssertTrue(mockDelegate.didShowConfirm)\n        XCTAssertEqual(mockDelegate.confirmedAmount, amount)\n    }\n}\n```\n\n## Documentation Standards\n\n### Public APIs\n\n```swift\n/// Initiates a deposit transaction for the specified amount.\n///\n/// This method validates the amount against the user's limits and\n/// bank constraints before proceeding to the confirmation screen.\n///\n/// - Parameters:\n///   - amount: The amount to deposit in VND\n///   - completion: Called when validation completes\n/// - Note: Requires user to be authenticated and KYC verified\n/// - Important: Amount must be within bank-specific limits\npublic func deposit(\n    amount: Double,\n    completion: @escaping (Result<DepositResult, DepositError>) -> Void\n)\n```\n\n### Complex Logic\n\n```swift\n// Complex algorithm - explain the approach\nprivate func calculateFee(amount: Double) -> Double {\n    // Fee structure:\n    // - 0-1M: 1000 VND\n    // - 1M-10M: 0.1%\n    // - >10M: 0.05%\n    // Minimum fee: 1000 VND\n\n    guard amount > 0 else { return 0 }\n\n    // Implementation...\n}\n```\n\n## Git Standards\n\n### Commit Messages\n\nFollow project convention from [.gitlab-ci.yml](.gitlab-ci.yml):\n\n```\n[iOS][Framework Name][Category] Description\n\nExamples:\n[iOS][PayooEwallet][Feature] Add deposit fee calculator\n[iOS][PayooCore][Fix] Fix memory leak in network client\n[iOS][PayooPayment][Refactor] Extract payment validation to UseCase\n```\n\n### Branch Naming\n\nFrom GitLab CI configuration:\n- Feature branches: `feature/{issue-id}-description` or `{issue-id}-description`\n- Release branches: `release/{milestone-id}` or `release/{version}`\n- Bugfix branches: `fix/{issue-id}-description`\n",
        "py-plugin/skills/ios-sdk-code-review/templates.md": "# Review Output Templates\n\n## Standard Code Review Report Template\n\n```markdown\n## Code Review: {FileName}\n\n### ‚úÖ Strengths\n- Follows MVVM pattern with proper protocol definitions\n- Clean dependency injection via constructor\n- Proper memory management with weak delegates\n- Good separation of concerns\n\n### ‚ö†Ô∏è Issues Found\n\n#### üî¥ Critical Issues\n\n**Issue #1: Memory Leak - Strong Delegate Reference**\n**Location:** `DepositViewModel.swift:15`\n**Impact:** Creates retain cycle between ViewModel and ViewController, causing memory leak\n**Fix:**\n\\```swift\n// Current code (line 15)\nvar delegate: DepositViewModelDelegate?\n\n// Suggested fix\nweak var delegate: DepositViewModelDelegate?\n\\```\n\n**Issue #2: Business Logic in ViewController**\n**Location:** `DepositViewController.swift:89-95`\n**Impact:** Violates MVVM pattern, makes testing difficult, breaks separation of concerns\n**Fix:**\n\\```swift\n// Current code (in ViewController)\nfunc validateAmount(_ amount: Double) -> Bool {\n    return amount >= minAmount && amount <= maxAmount\n}\n\n// Suggested fix: Move to ViewModel or UseCase\n// In DepositViewModel:\nfunc validate(amount: Double) -> Bool {\n    return depositAmountUC.validate(amount)\n}\n\\```\n\n#### üü° Warnings\n\n**Warning #1: Missing weak self in closure**\n**Location:** `DepositViewModel.swift:67`\n**Suggestion:**\n\\```swift\n// Current\nservice.fetch { data in\n    self.handleData(data)\n}\n\n// Better\nservice.fetch { [weak self] data in\n    self?.handleData(data)\n}\n\\```\n\n**Warning #2: Force unwrapping**\n**Location:** `BankAccountCell.swift:42`\n**Suggestion:** Use optional binding instead of force unwrap\n\\```swift\n// Current\nlet bank = bankDict[code]!\n\n// Better\nguard let bank = bankDict[code] else { return }\n\\```\n\n#### üîµ Suggestions\n\n**Enhancement #1: Extract magic numbers to constants**\n**Location:** `DepositViewController.swift:134, 156`\n**Benefit:** Improves maintainability and readability\n\\```swift\n// Add to top of class\nprivate enum Layout {\n    static let spacing: CGFloat = 14\n    static let itemsPerRow = 3\n}\n\\```\n\n**Enhancement #2: Add documentation for public API**\n**Location:** `PayooEwallet.swift:25-30`\n**Benefit:** Better API discoverability for SDK consumers\n\n### üìä Summary\n- Critical Issues: 2\n- Warnings: 2\n- Suggestions: 2\n- Overall: **Needs Work** (Critical issues must be fixed)\n\n### üéØ Priority Actions\n1. Fix memory leak by marking delegate as weak (Critical)\n2. Move business logic from ViewController to ViewModel/UseCase (Critical)\n3. Add [weak self] to closure captures (Warning)\n4. Replace force unwraps with safe optional handling (Warning)\n```\n\n## Quick Review Template (Minor Issues)\n\n```markdown\n## Quick Review: {FileName}\n\n### ‚úÖ Overall: Pass\n\nCode follows project standards with minor improvements suggested.\n\n### Suggestions:\n1. **Line 45**: Consider extracting magic number to constant\n2. **Line 78**: Add documentation comment for public method\n3. **Line 102**: Use `guard let` instead of `if let` for early return\n\nNo critical issues found. Code is ready to merge.\n```\n\n## Architecture Review Template\n\n```markdown\n## Architecture Review: {Feature}\n\n### Layer Analysis\n\n#### ‚úÖ Presentation Layer\n- ViewModel follows protocol pattern\n- Delegate properly defined\n- No UIKit in ViewModel\n- Clean separation\n\n#### ‚úÖ Domain Layer\n- UseCase has single responsibility\n- No framework dependencies\n- Proper error handling\n- Good abstraction\n\n#### ‚ö†Ô∏è Data Layer\n**Issue**: DataSource directly accessed from ViewController\n**Suggestion**: Inject via ViewModel for better testability\n\n### Dependency Flow\n\\```\nViewController ‚Üí ViewModel ‚Üí UseCase ‚Üí Service\n     ‚úì              ‚úì          ‚úì         ‚úì\n\\```\n\n### Recommendations\n1. Consider extracting validation logic to separate UseCase\n2. Add unit tests for ViewModel\n3. Document public API methods\n```\n\n## Memory Review Template\n\n```markdown\n## Memory Safety Review: {FileName}\n\n### Analysis\n\n#### Delegate References\n- ‚úÖ Line 23: `weak var delegate` - Correct\n- ‚ùå Line 45: `var delegate` - Should be weak\n\n#### Closure Captures\n- ‚úÖ Line 67: Uses `[weak self]` - Correct\n- ‚ùå Line 89: Strong self capture - Add `[weak self]`\n- ‚úÖ Line 102: Uses `[weak self]` - Correct\n\n#### Resource Cleanup\n- ‚ö†Ô∏è Missing `deinit` - Add cleanup for timer/observers\n\n### Fixes Required\n\n**Fix delegate reference:**\n\\```swift\nweak var delegate: SomeDelegate?\n\\```\n\n**Fix closure capture:**\n\\```swift\nservice.fetch { [weak self] data in\n    guard let self = self else { return }\n    self.handleData(data)\n}\n\\```\n\n**Add cleanup:**\n\\```swift\ndeinit {\n    timer?.invalidate()\n    NotificationCenter.default.removeObserver(self)\n}\n\\```\n```\n\n## API Design Review Template\n\n```markdown\n## API Design Review: {ClassName}\n\n### Public Interface\n\n#### Method Signatures\n- ‚úÖ Clear, descriptive names\n- ‚úÖ Proper use of completion handlers\n- ‚ö†Ô∏è Missing documentation comments\n\n#### Error Handling\n- ‚úÖ Typed errors\n- ‚úÖ LocalizedError conformance\n- ‚úÖ Recovery suggestions\n\n#### Thread Safety\n- ‚ö†Ô∏è Completion handlers not guaranteed on main thread\n- Suggestion: Document threading behavior\n\n### Recommendations\n\n**Add documentation:**\n\\```swift\n/// Deposits the specified amount to the user's e-wallet.\n///\n/// - Parameters:\n///   - amount: Amount in VND to deposit\n///   - completion: Called on main thread when complete\n/// - Note: User must be authenticated and KYC verified\npublic func deposit(\n    amount: Double,\n    completion: @escaping (Result<DepositResult, DepositError>) -> Void\n)\n\\```\n\n**Ensure main thread callbacks:**\n\\```swift\nDispatchQueue.main.async {\n    completion(.success(result))\n}\n\\```\n```\n\n## UseCase Review Template\n\n```markdown\n## UseCase Review: {UseCaseName}\n\n### Single Responsibility Check\n- ‚úÖ Focused on single business capability\n- ‚úÖ Clear, specific purpose\n\n### Dependencies\n- ‚úÖ Properly injected via constructor\n- ‚úÖ Uses protocols, not concrete types\n- ‚úÖ No service locator pattern\n\n### Error Handling\n- ‚úÖ Typed errors defined\n- ‚úÖ Localized error messages\n- ‚úÖ Proper error propagation\n\n### Testability\n- ‚úÖ No external dependencies\n- ‚úÖ Pure business logic\n- ‚úÖ Easy to mock dependencies\n\n### Recommendations\nNone - UseCase follows best practices.\n```\n\n## ViewModel Review Checklist Template\n\n```markdown\n## ViewModel Checklist: {ViewModelName}\n\n### Protocol Design\n- [ ] Has `{Name}ViewModelType` protocol\n- [ ] Has `{Name}ViewModelDelegate` protocol\n- [ ] Delegate marked `weak`\n- [ ] Clear separation of concerns\n\n### Dependencies\n- [ ] All dependencies injected via `init`\n- [ ] Uses UseCases for business logic\n- [ ] No direct service access\n- [ ] Context pattern used appropriately\n\n### Memory Management\n- [ ] Weak delegate reference\n- [ ] `[weak self]` in closures\n- [ ] Proper cleanup in `deinit` (if needed)\n- [ ] No retain cycles\n\n### Testability\n- [ ] No UIKit imports\n- [ ] Protocol-based design\n- [ ] Mockable dependencies\n- [ ] Pure presentation logic\n\n### Results\n- **Passed**: X/Y checks\n- **Issues**: See details below\n```\n",
        "py-plugin/skills/mcp-server-installer/SKILL.md": "---\nname: mcp-server-installer\ndescription: Add MCP servers to Claude Code configuration at user level (~/.claude). Supports stdio, HTTP, and SSE transports with environment variable prompting. Use when \"add mcp server\", \"install mcp\", \"configure mcp server\", \"new mcp\", or \"setup mcp server\".\nallowed-tools: Read, Write, Bash, AskUserQuestion\n---\n\n# MCP Server Installer\n\nAutonomously add MCP (Model Context Protocol) servers to Claude Code configuration at the user level (`~/.claude/mcp.json`).\n\n## When to Activate\n\n- \"add mcp server\"\n- \"install mcp\", \"configure mcp\"\n- \"new mcp server\", \"setup mcp\"\n- \"add [server-name] mcp\"\n- User provides MCP server configuration JSON\n\n## Process\n\n### Step 1: Gather Server Information\n\nAsk user for:\n\n1. **Server name** (e.g., \"mobile-mcp-server\")\n   - Must be lowercase with hyphens\n   - Will be used as the key in mcpServers object\n\n2. **Transport type**:\n   - `stdio` - Local command execution (most common)\n   - `http` - Remote HTTP server\n   - `sse` - Server-Sent Events (deprecated but supported)\n\n3. **Based on transport type:**\n\n   **For stdio:**\n   - Command (e.g., \"npx\", \"node\", \"/usr/local/bin/server\")\n   - Arguments array (e.g., `[\"@daipham/mobile-mcp-server@latest\"]`)\n   - Environment variables (if needed)\n\n   **For http:**\n   - URL (e.g., \"https://api.example.com/mcp\")\n   - Headers (optional, e.g., `{\"Authorization\": \"Bearer ${API_KEY}\"}`)\n\n   **For sse:**\n   - URL (e.g., \"https://api.example.com/sse\")\n   - Headers (optional)\n\n### Step 2: Collect Environment Variables\n\n**Always ask user**: \"Does this MCP server require any environment variables?\"\n\nIf yes, for each variable:\n- Variable name (e.g., \"API_KEY\", \"DATABASE_URL\")\n- Description/purpose\n- Whether it's required or optional\n- Default value (if optional)\n\n**Document in output**: List all required environment variables with instructions on where to set them.\n\n### Step 3: Read Existing Configuration\n\nCheck for existing `.mcp.json` at user level:\n\n```bash\ncat ~/.claude/mcp.json\n```\n\nIf file doesn't exist, create new structure. If exists, parse and merge.\n\n### Step 4: Generate Configuration\n\nUse templates from `templates.md` to generate the server configuration based on transport type.\n\nApply environment variable syntax:\n- `${VAR}` - Required variable (will error if not set)\n- `${VAR:-default}` - Optional variable with default value\n\n### Step 5: Update Configuration File\n\n**Merge strategy:**\n- Preserve existing servers\n- Add new server to `mcpServers` object\n- Maintain JSON formatting (2-space indent)\n- Validate JSON before writing\n\nWrite to `~/.claude/mcp.json`.\n\n### Step 6: Create Environment File Reference\n\nIf environment variables are needed, inform user:\n\n```\n‚ö†Ô∏è Environment Variables Required:\n\nSet these in your shell profile (~/.zshrc or ~/.bashrc):\n\nexport VAR_NAME=\"value\"\nexport ANOTHER_VAR=\"value\"\n\nOr create a project-specific .env file and reference it:\n\"envFile\": \"${workspaceFolder}/.env\"\n```\n\n### Step 7: Validate and Test\n\nRun validation:\n\n```bash\nclaude mcp list\n```\n\nShow the newly added server in the output.\n\n## Output Format\n\n```markdown\n‚úÖ MCP Server Added: [server-name]\n\nüìÅ Configuration: ~/.claude/mcp.json\n\nüîß Transport: [stdio/http/sse]\nüì¶ Command: [command with args] (if stdio)\nüåê URL: [url] (if http/sse)\n\nüìã Configuration Added:\n```json\n{\n  \"server-name\": {\n    // configuration here\n  }\n}\n```\n\n‚ö†Ô∏è Environment Variables Required:\n- VAR_NAME: [description]\n- ANOTHER_VAR: [description]\n\nüí° Set environment variables:\n1. Add to ~/.zshrc or ~/.bashrc:\n   export VAR_NAME=\"your-value\"\n\n2. Or use project .env file:\n   \"envFile\": \"${workspaceFolder}/.env\"\n\n‚úÖ Restart Claude Code to activate the new MCP server.\n\nüß™ Test with: claude mcp list\n```\n\n## Error Handling\n\n- **Invalid JSON**: Show parsing error, ask user to verify configuration\n- **Duplicate server name**: Ask if user wants to overwrite existing server\n- **Missing required fields**: Prompt for missing information\n- **File permission errors**: Suggest checking ~/.claude directory permissions\n\n## Important Notes\n\n1. **User-level scope**: Servers added at `~/.claude/mcp.json` are available across all projects\n2. **Environment variables**: Always prompt for environment variables - many MCP servers require API keys or configuration\n3. **Restart required**: Claude Code must be restarted after adding MCP servers\n4. **Validation**: Use `claude mcp list` to verify the server was added successfully\n5. **Security**: Never log or display actual environment variable values\n\n## Reference\n\nSee `templates.md` for configuration templates for each transport type.\n",
        "py-plugin/skills/mcp-server-installer/templates.md": "# MCP Server Configuration Templates\n\n## Template 1: stdio Transport (Local Command)\n\nMost common type for npx, node, or local executables.\n\n### Basic stdio Server\n\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"@package/mcp-server@latest\"\n      ]\n    }\n  }\n}\n```\n\n### stdio Server with Environment Variables\n\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"@package/mcp-server@latest\"\n      ],\n      \"env\": {\n        \"API_KEY\": \"${API_KEY}\",\n        \"DATABASE_URL\": \"${DATABASE_URL:-sqlite://local.db}\"\n      }\n    }\n  }\n}\n```\n\n### stdio Server with envFile Reference\n\n```json\n{\n  \"mcpServers\": {\n    \"mobile-mcp-server\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"@daipham/mobile-mcp-server@latest\"\n      ],\n      \"envFile\": \"${workspaceFolder}/.env\"\n    }\n  }\n}\n```\n\n### stdio Server with Custom Path\n\n```json\n{\n  \"mcpServers\": {\n    \"custom-server\": {\n      \"command\": \"/usr/local/bin/custom-server\",\n      \"args\": [\n        \"--port\",\n        \"3000\",\n        \"--config\",\n        \"${HOME}/.config/server.json\"\n      ]\n    }\n  }\n}\n```\n\n## Template 2: HTTP Transport (Remote Server)\n\nFor servers running on remote hosts or different ports.\n\n### Basic HTTP Server\n\n```json\n{\n  \"mcpServers\": {\n    \"api-server\": {\n      \"type\": \"http\",\n      \"url\": \"https://api.example.com/mcp\"\n    }\n  }\n}\n```\n\n### HTTP Server with Authentication\n\n```json\n{\n  \"mcpServers\": {\n    \"authenticated-server\": {\n      \"type\": \"http\",\n      \"url\": \"${API_BASE_URL:-https://api.example.com}/mcp\",\n      \"headers\": {\n        \"Authorization\": \"Bearer ${API_KEY}\",\n        \"X-Client-Version\": \"1.0.0\"\n      }\n    }\n  }\n}\n```\n\n### HTTP Server with Multiple Headers\n\n```json\n{\n  \"mcpServers\": {\n    \"enterprise-server\": {\n      \"type\": \"http\",\n      \"url\": \"${MCP_URL}\",\n      \"headers\": {\n        \"Authorization\": \"Bearer ${API_TOKEN}\",\n        \"X-Organization\": \"${ORG_ID}\",\n        \"X-Environment\": \"${ENVIRONMENT:-production}\"\n      }\n    }\n  }\n}\n```\n\n## Template 3: SSE Transport (Server-Sent Events)\n\nDeprecated but still supported for backward compatibility.\n\n### Basic SSE Server\n\n```json\n{\n  \"mcpServers\": {\n    \"sse-server\": {\n      \"type\": \"sse\",\n      \"url\": \"https://api.example.com/sse\"\n    }\n  }\n}\n```\n\n### SSE Server with Headers\n\n```json\n{\n  \"mcpServers\": {\n    \"sse-authenticated\": {\n      \"type\": \"sse\",\n      \"url\": \"${SSE_URL}\",\n      \"headers\": {\n        \"Authorization\": \"Bearer ${SSE_TOKEN}\"\n      }\n    }\n  }\n}\n```\n\n## Template 4: Complete Configuration File\n\nExample of a complete `.mcp.json` with multiple servers:\n\n```json\n{\n  \"mcpServers\": {\n    \"mobile-mcp-server\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"@daipham/mobile-mcp-server@latest\"\n      ],\n      \"envFile\": \"${workspaceFolder}/.env\"\n    },\n    \"database-server\": {\n      \"command\": \"node\",\n      \"args\": [\n        \"/usr/local/bin/db-mcp-server\"\n      ],\n      \"env\": {\n        \"DB_HOST\": \"${DB_HOST:-localhost}\",\n        \"DB_PORT\": \"${DB_PORT:-5432}\",\n        \"DB_NAME\": \"${DB_NAME}\"\n      }\n    },\n    \"api-server\": {\n      \"type\": \"http\",\n      \"url\": \"https://api.example.com/mcp\",\n      \"headers\": {\n        \"Authorization\": \"Bearer ${API_KEY}\"\n      }\n    }\n  }\n}\n```\n\n## Environment Variable Syntax\n\n### Required Variable\n```json\n\"${VAR_NAME}\"\n```\nWill error if VAR_NAME is not set.\n\n### Optional Variable with Default\n```json\n\"${VAR_NAME:-default_value}\"\n```\nUses `default_value` if VAR_NAME is not set.\n\n### Common Environment Variables\n\n**Workspace references:**\n- `${workspaceFolder}` - Current workspace root directory\n- `${HOME}` - User home directory\n- `${USER}` - Current username\n\n**API credentials:**\n- `${API_KEY}` - API authentication key\n- `${API_TOKEN}` - API authentication token\n- `${API_SECRET}` - API secret\n\n**URLs and endpoints:**\n- `${API_URL}` - API base URL\n- `${API_BASE_URL}` - API base URL\n- `${MCP_URL}` - MCP server URL\n\n**Database:**\n- `${DATABASE_URL}` - Full database connection string\n- `${DB_HOST}` - Database host\n- `${DB_PORT}` - Database port\n- `${DB_NAME}` - Database name\n- `${DB_USER}` - Database username\n- `${DB_PASSWORD}` - Database password\n\n## Common Command Patterns\n\n### NPM Package (npx)\n```json\n\"command\": \"npx\",\n\"args\": [\"@package/name@latest\"]\n```\n\n### Node Script\n```json\n\"command\": \"node\",\n\"args\": [\"/path/to/script.js\"]\n```\n\n### Python Script\n```json\n\"command\": \"python\",\n\"args\": [\"-m\", \"module_name\"]\n```\n\n### Custom Binary\n```json\n\"command\": \"/usr/local/bin/binary-name\",\n\"args\": [\"--flag\", \"value\"]\n```\n\n### UV (Python Package Manager)\n```json\n\"command\": \"uvx\",\n\"args\": [\"package-name\"]\n```\n\n## Merging Strategy\n\nWhen adding a new server to existing configuration:\n\n1. **Read existing file**: Parse current `.mcp.json`\n2. **Validate structure**: Ensure `mcpServers` object exists\n3. **Check for duplicates**: Warn if server name already exists\n4. **Merge configurations**: Add new server to `mcpServers` object\n5. **Preserve formatting**: Maintain 2-space indentation\n6. **Write atomically**: Write to temp file, then move to prevent corruption\n\n### Example Merge\n\n**Before:**\n```json\n{\n  \"mcpServers\": {\n    \"existing-server\": {\n      \"command\": \"node\",\n      \"args\": [\"server.js\"]\n    }\n  }\n}\n```\n\n**After adding \"new-server\":**\n```json\n{\n  \"mcpServers\": {\n    \"existing-server\": {\n      \"command\": \"node\",\n      \"args\": [\"server.js\"]\n    },\n    \"new-server\": {\n      \"command\": \"npx\",\n      \"args\": [\"@package/new-server@latest\"]\n    }\n  }\n}\n```\n",
        "py-plugin/skills/mcp-tool-generator/SKILL.md": "---\nname: mcp-tool-generator\ndescription: Generate new MCP tools for GitLab operations following the project's standardized pattern. Creates complete TypeScript files with imports, registration functions, Zod schemas, error handling, and format options. Supports simple CRUD operations, complex multi-action tools, and advanced patterns like discussion management. Use when \"create mcp tool\", \"generate gitlab tool\", \"new tool for\", \"add tool to gitlab\", or building new GitLab integration features.\nallowed-tools: Read, Write, Glob, Grep\n---\n\n# MCP Tool Generator\n\nGenerate new MCP tools following the standardized patterns from the project. Creates complete tool files with proper imports, Zod schemas, error handling, and GitLab API integration.\n\n## Activation Triggers\n\n- \"create an mcp tool for...\"\n- \"generate a gitlab tool to...\"\n- \"I need a new tool that...\"\n- \"add a tool for [operation]\"\n- \"create tool to [action] [resource]\"\n\n## Tool Types Supported\n\n### 1. Simple CRUD Tools\nBasic get/list/create/update/delete operations with standard patterns:\n- Get single resource (issue, MR, milestone, etc.)\n- List multiple resources with filtering and pagination\n- Create new resources\n- Update existing resources\n- Delete resources\n\n**Pattern**: `gitlab-[action]-[resource]` (e.g., `gitlab-get-issue`, `gitlab-list-pipelines`)\n\n### 2. Multi-Action Tools\nComprehensive tools that handle multiple related operations in one tool:\n- Multiple actions via `action` enum parameter\n- Conditional logic based on action type\n- Structured responses with status/action/message format\n- More efficient than multiple separate tools\n\n**Pattern**: `gitlab-[resource]-[operation]` (e.g., `gitlab-manage-issue`)\n\n### 3. Complex Operation Tools\nTools with advanced logic:\n- Discussion/comment management with update detection\n- Multi-step workflows\n- Direct API calls using fetch for specific needs\n- Position-based operations (code reviews, inline comments)\n\n**Pattern**: Based on specific operation (e.g., `gitlab-review-merge-request-code`)\n\n## Autonomous Generation Process\n\n### Step 1: Analyze User Request\n\nExtract key information:\n1. **Tool Type**: Simple CRUD, multi-action, or complex?\n2. **Tool Purpose**: What GitLab operation? (e.g., \"get merge request details\", \"manage issues\", \"review code\")\n3. **Resource Type**: What GitLab entity? (issue, MR, branch, milestone, pipeline, label, etc.)\n4. **Action Type**: What operation? (get, list, create, update, delete, search, manage, review, etc.)\n5. **Required Parameters**: What inputs needed? (projectname, IID, branch name, action, etc.)\n6. **Optional Parameters**: What's optional? (format, labels, assignee, filters, etc.)\n7. **Special Features**: Multi-action? Position-based? Discussion management?\n\n### Step 2: Auto-Generate Names\n\n**Tool Name** (kebab-case):\n- Simple CRUD: `gitlab-[action]-[resource]`\n  - Examples: `gitlab-get-merge-request`, `gitlab-list-pipelines`, `gitlab-create-branch`\n- Multi-action: `gitlab-[manage|handle]-[resource]`\n  - Examples: `gitlab-manage-issue`, `gitlab-handle-milestone`\n- Complex: `gitlab-[specific-operation]`\n  - Examples: `gitlab-review-merge-request-code`, `gitlab-find-related-issues`\n\n**Function Name** (PascalCase):\n- Pattern: `register[Action][Resource]`\n- Examples:\n  - `gitlab-get-merge-request` ‚Üí `registerGetMergeRequest`\n  - `gitlab-manage-issue` ‚Üí `registerManageIssue`\n  - `gitlab-review-merge-request-code` ‚Üí `registerReviewMergeRequestCode`\n\n**File Name** (kebab-case):\n- Pattern: `gitlab-[tool-name].ts`\n- Location: `src/tools/gitlab/`\n\n### Step 3: Select Tool Pattern\n\n#### Pattern A: Simple CRUD Tool\n\n**Use when**: Single operation (get, list, create, update, delete)\n\n**Standard features**:\n- `projectname` parameter (optional, with prompt fallback)\n- `format` parameter (detailed/concise) for get/list operations\n- HTML content cleaning with `cleanGitLabHtmlContent()`\n- Project validation before API calls\n- Descriptive error messages\n- Emojis in concise format\n\n**Template structure**:\n```typescript\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp';\nimport { z } from 'zod';\nimport { cleanGitLabHtmlContent } from '../../core/utils';\nimport { getGitLabService, getProjectNameFromUser } from './gitlab-shared';\n\nexport function register{FunctionName}(server: McpServer) {\n    server.registerTool(\n        \"{tool-name}\",\n        {\n            title: \"{Human Readable Title}\",\n            description: \"{Detailed description}\",\n            inputSchema: {\n                {param1}: z.{type}().describe(\"{description}\"),\n                projectname: z.string().optional().describe(\"GitLab project name (if not provided, you'll be prompted to select)\"),\n                format: z.enum([\"detailed\", \"concise\"]).optional().describe(\"Response format - 'detailed' includes all metadata, 'concise' includes only key information\")\n            }\n        },\n        async ({ {params}, projectname, format = \"detailed\" }) => {\n            try {\n                // Standard workflow\n            } catch (e) {\n                return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: String(e) }) }] };\n            }\n        }\n    );\n}\n```\n\n#### Pattern B: Multi-Action Tool\n\n**Use when**: Multiple related operations on same resource type\n\n**Standard features**:\n- `action` parameter with enum of actions\n- Switch/case logic for each action\n- Structured responses: `{ status: \"success\"/\"failure\", action: \"...\", message: \"...\", [resource]: {...} }`\n- Direct API calls using fetch when needed\n- Conditional parameters based on action\n- No format parameter (uses structured JSON)\n\n**Template structure**:\n```typescript\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp';\nimport fetch from 'node-fetch';\nimport { z } from 'zod';\nimport { cleanGitLabHtmlContent } from '../../core/utils';\nimport { getGitLabService, getProjectNameFromUser } from './gitlab-shared';\n\nexport function register{FunctionName}(server: McpServer) {\n    server.registerTool(\n        \"{tool-name}\",\n        {\n            title: \"{Human Readable Title}\",\n            description: \"{Comprehensive description covering all actions}\",\n            inputSchema: {\n                {resourceId}: z.number().describe(\"The ID/IID of the resource\"),\n                projectname: z.string().optional().describe(\"GitLab project name (if not provided, you'll be prompted to select)\"),\n                action: z.enum([\"action1\", \"action2\", \"action3\"]).describe(\"Action to perform\"),\n                // Conditional parameters for different actions\n                param1: z.{type}().optional().describe(\"For action1: description\"),\n                param2: z.{type}().optional().describe(\"For action2: description\")\n            }\n        },\n        async ({ {resourceId}, projectname, action, {params} }) => {\n            try {\n                // Get project and resource\n                const projectName = projectname || await getProjectNameFromUser(server, false, \"prompt\");\n                if (!projectName) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: \"Project not found\" }) }] };\n                }\n\n                const service = await getGitLabService(server);\n                const projectId = await service.getProjectId(projectName);\n                if (!projectId) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Project \"${projectName}\" not found` }) }] };\n                }\n\n                // Get resource first\n                const rawResource = await service.get{Resource}(projectId, {resourceId});\n                if (!rawResource) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Resource not found` }) }] };\n                }\n\n                const resource = cleanGitLabHtmlContent(rawResource, ['description', 'title']);\n\n                // Handle actions\n                switch (action) {\n                    case \"action1\":\n                        // Implementation\n                        return { content: [{ type: \"text\", text: JSON.stringify({\n                            status: 'success',\n                            action: 'action1',\n                            message: 'Action completed',\n                            {resource}: { /* key fields */ }\n                        }, null, 2) }] };\n\n                    case \"action2\":\n                        // Implementation\n                        break;\n\n                    default:\n                        return { content: [{ type: \"text\", text: JSON.stringify({\n                            status: 'failure',\n                            error: `Unknown action \"${action}\"`\n                        }, null, 2) }] };\n                }\n            } catch (e) {\n                return { content: [{ type: \"text\", text: JSON.stringify({\n                    status: 'failure',\n                    error: String(e)\n                }, null, 2) }] };\n            }\n        }\n    );\n}\n```\n\n#### Pattern C: Complex Operation Tool\n\n**Use when**: Advanced logic like discussion management, position-based operations, multi-step workflows\n\n**Standard features**:\n- Specialized parameters (may not include projectname if using projectId directly)\n- Custom logic for specific use cases\n- May use direct API calls\n- May fetch and update existing data\n- Structured responses appropriate to operation\n\n**Template structure**: Highly variable based on specific needs\n\n### Step 4: Generate Zod Schema\n\n**Common Parameter Patterns**:\n\n```typescript\n// IDs (internal issue/MR number)\n{name}Iid: z.number().describe(\"The internal ID (IID) of the {resource} to {action}\")\n\n// Project ID (for tools that need direct ID)\nprojectId: z.number().describe(\"The project ID\")\n\n// Names/identifiers\n{name}: z.string().describe(\"{Resource} name (e.g., 'feature/user-auth')\")\n\n// Action enums (for multi-action tools)\naction: z.enum([\"action1\", \"action2\", \"action3\"]).describe(\"Action to perform on the {resource}\")\n\n// Optional filters\nstate: z.enum([\"opened\", \"closed\", \"all\"]).optional().describe(\"Filter by state (default: 'opened')\")\nlabels: z.string().optional().describe(\"Comma-separated list of label names to filter by\")\n// OR for multi-action tools:\nlabels: z.array(z.string()).optional().describe(\"For add-labels action: labels to add\")\n\n// Pagination\npage: z.number().optional().describe(\"Page number for pagination (default: 1)\")\nperPage: z.number().optional().describe(\"Number of items per page (default: 20, max: 100)\")\n\n// Dates\ndueDate: z.string().optional().describe(\"Due date in ISO 8601 format (YYYY-MM-DD)\")\n\n// Position-based parameters (for code review tools)\nbaseSha: z.string().describe(\"Base SHA for the diff\")\nstartSha: z.string().describe(\"Start SHA for the diff\")\nheadSha: z.string().describe(\"Head SHA for the diff\")\nnewPath: z.string().describe(\"Path to the file being reviewed\")\nnewLine: z.number().optional().describe(\"Line number in the new file\")\n\n// Project (standard for simple CRUD, optional for complex tools)\nprojectname: z.string().optional().describe(\"GitLab project name (if not provided, you'll be prompted to select)\")\n\n// Format (only for simple get/list operations)\nformat: z.enum([\"detailed\", \"concise\"]).optional().describe(\"Response format - 'detailed' includes all metadata, 'concise' includes only key information\")\n```\n\n**Important notes**:\n- Add `.describe()` with clear examples for all parameters\n- Use `z.array(z.string())` for arrays in multi-action tools\n- Note when square brackets `[]` are allowed in descriptions for paths/labels/markdown\n- Make parameters optional when sensible defaults exist\n\n### Step 5: Generate Response Formats\n\n#### Simple CRUD Tools (Pattern A)\n\n**Concise format** (with emojis):\n```typescript\nif (format === \"concise\") {\n    return { content: [{ type: \"text\", text:\n        `{emoji} {Resource} #{id}: {title}\\n` +\n        `üìä Status: {state}\\n` +\n        `üë§ {role}: {user}\\n` +\n        `üè∑Ô∏è Labels: {labels}\\n` +\n        `üéØ Milestone: {milestone}\\n` +\n        `üìÖ Due: {due_date}\\n` +\n        `üîó URL: {web_url}`\n    }] };\n}\n```\n\n**Detailed format** (full JSON):\n```typescript\nreturn { content: [{ type: \"text\", text: JSON.stringify({resource}, null, 2) }] };\n```\n\n**Emoji Guide**:\n- üîç - Get/View operations\n- üìã - List operations\n- ‚ú® - Create operations\n- üîÑ - Update operations\n- üóëÔ∏è - Delete operations\n- üìä - Status/State\n- üë§ - User/Assignee\n- üè∑Ô∏è - Labels\n- üéØ - Milestone\n- üìÖ - Dates\n- üîó - URLs\n- ‚úÖ - Success/Completed\n- ‚ùå - Error/Failed\n\n#### Multi-Action Tools (Pattern B)\n\n**Structured JSON format**:\n```typescript\n// Success response\n{\n    status: 'success',\n    action: 'action-name',\n    message: 'Human-readable success message',\n    {resource}: {\n        id: resource.id,\n        iid: resource.iid,\n        title: resource.title,\n        webUrl: resource.web_url,\n        // Other key fields relevant to the action\n    }\n}\n\n// Failure response\n{\n    status: 'failure',\n    action: 'action-name',\n    error: 'Detailed error message with context',\n    {resource}: {\n        id: resource.id,\n        iid: resource.iid,\n        title: resource.title,\n        webUrl: resource.web_url\n    }\n}\n```\n\n#### Complex Tools (Pattern C)\n\nCustom format based on operation needs. Examples:\n```typescript\n// Discussion update/create\n{\n    action: \"updated\" | \"created\",\n    discussion_id: \"...\",\n    note_id: \"...\",\n    updated_note: {...}\n}\n```\n\n### Step 6: Add Error Handling\n\n**Standard Error Patterns**:\n\n```typescript\n// Project not selected (for tools with projectname parameter)\nif (!projectName) {\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        type: \"error\",\n        error: \"Project not found or not selected. Please provide a valid project name.\"\n    }) }] };\n}\n\n// Project not found\nif (!projectId) {\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        type: \"error\",\n        error: `Could not find project \"${projectName}\". Please verify the project name is correct and you have access to it.`\n    }) }] };\n}\n\n// Resource not found\nif (!resource) {\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        type: \"error\",\n        error: `{Resource} not found. Please verify the {parameters} are correct.`\n    }) }] };\n}\n\n// Missing required parameters (for multi-action tools)\nif (!requiredParam) {\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        status: 'failure',\n        action: action,\n        error: \"Required parameter missing. Please specify...\",\n        {resource}: { /* minimal info */ }\n    }, null, 2) }] };\n}\n\n// API call failure (for multi-action tools using fetch)\nif (!response.ok) {\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        status: 'failure',\n        action: action,\n        error: `Failed to {action}. Status: ${response.status}`,\n        {resource}: { /* minimal info */ }\n    }, null, 2) }] };\n}\n\n// General error (catch block)\ncatch (e) {\n    // For simple CRUD tools:\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        type: \"error\",\n        error: `Error {operation}: ${String(e)}. Please check your GitLab connection and permissions.`\n    }) }] };\n\n    // For multi-action tools:\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        status: 'failure',\n        error: `Error {operation}: ${String(e)}`\n    }, null, 2) }] };\n}\n```\n\n### Step 7: Register in gitlab-tool.ts\n\nAfter creating the tool file, add registration:\n\n```typescript\n// In src/tools/gitlab-tool.ts\n\n// Add import at top\nimport { register{FunctionName} } from './gitlab/gitlab-{tool-name}';\n\n// Add registration in registerGitlabTools function\nexport function registerGitlabTools(server: McpServer) {\n    // ... other registrations\n    register{FunctionName}(server);\n}\n```\n\n## Interactive Generation Workflow\n\n### Ask User (Only if unclear):\n\n1. **Tool Type**:\n   - \"Is this a simple CRUD operation, multi-action tool, or complex operation?\"\n   - Clarify if multiple actions should be combined in one tool\n\n2. **Tool Purpose**:\n   - \"What GitLab operation should this tool perform?\"\n   - Examples: \"Get merge request details\", \"Manage issues (get, update, close)\", \"Review code inline\"\n\n3. **Required Parameters**:\n   - \"What parameters are required?\"\n   - Examples: \"merge request IID\", \"issue IID and action type\", \"project ID and position data\"\n\n4. **Optional Parameters**:\n   - \"Any optional filters or options?\"\n   - Examples: \"state filter\", \"label filter\", \"format option\"\n\n5. **API Method** (if not obvious):\n   - \"Which GitLab service method to use?\"\n   - Check `src/services/gitlab-client.ts` for available methods\n   - Note if direct fetch API calls are needed\n\n### Generate Files:\n\n1. **Create tool file**: `src/tools/gitlab/gitlab-{tool-name}.ts`\n2. **Show registration code** for `src/tools/gitlab-tool.ts`\n3. **Provide usage examples** based on tool type\n\n## Output Format\n\nAfter generating the tool:\n\n```markdown\n‚úÖ MCP Tool Created: {tool-name}\n\nüìÅ Files Created:\n- `src/tools/gitlab/gitlab-{tool-name}.ts`\n\nüîß Type: {Simple CRUD | Multi-Action | Complex Operation}\nüîß Function: register{FunctionName}\n\nüìù Next Steps:\n1. Add registration to `src/tools/gitlab-tool.ts`:\n   ```typescript\n   import { register{FunctionName} } from './gitlab/gitlab-{tool-name}';\n   // In registerGitlabTools:\n   register{FunctionName}(server);\n   ```\n\n2. Rebuild the project:\n   ```bash\n   npm run build\n   ```\n\n3. Test the tool:\n   ```bash\n   npm run dev\n   ```\n\nüéØ Usage Examples:\n{Type-specific examples}\n\nüìñ Tool registered as: \"{tool-name}\"\n```\n\n## GitLab Service Methods Reference\n\nCommon methods available in `gitlab-client.ts`. Latest update 31/10/2025:\n\n**Issues**:\n- `getIssue(projectId, iid)`\n- `getIssues(projectId, options)`\n- `createIssue(projectId, data)`\n- `updateIssue(projectId, iid, data)`\n\n**Merge Requests**:\n- `getMergeRequest(projectId, iid)`\n- `getMergeRequests(projectId, options)`\n- `createMergeRequest(projectId, data)`\n- `updateMergeRequest(projectId, iid, data)`\n- `approveMergeRequest(projectId, iid)`\n- `getMrDiscussions(projectId, iid)`\n- `addMrComments(projectId, iid, data)`\n- `updateMrDiscussionNote(projectId, iid, discussionId, noteId, body)`\n\n**Branches**:\n- `getBranches(projectId, options)`\n- `createBranch(projectId, branchName, ref)`\n- `deleteBranch(projectId, branchName)`\n\n**Pipelines**:\n- `getPipelines(projectId, options)`\n- `getPipeline(projectId, pipelineId)`\n- `createPipeline(projectId, ref)`\n\n**Milestones**:\n- `getMilestone(projectId, milestoneId)`\n- `getMilestones(projectId, options)`\n- `createMilestone(projectId, data)`\n- `updateMilestone(projectId, milestoneId, data)`\n\n**Projects**:\n- `getProjectId(projectName)`\n- `getProject(projectId)`\n- `searchProjects(search)`\n\n**Users**:\n- `getUserIdByUsername(username)`\n\n**Direct Fetch API**:\nFor operations not covered by service methods, use direct fetch:\n```typescript\nconst response = await fetch(`${service.gitlabUrl}/api/v4/projects/${projectId}/{endpoint}`, {\n    method: 'PUT' | 'POST' | 'GET' | 'DELETE',\n    headers: service['getHeaders'](),\n    body: JSON.stringify({...})\n});\n```\n\n## Key Patterns to Follow\n\n1. **Always use appropriate tool pattern** based on operation type\n2. **Simple CRUD tools**: Include `projectname` and `format` parameters\n3. **Multi-action tools**: Use `action` enum and structured responses\n4. **Always clean HTML content** with `cleanGitLabHtmlContent()` where applicable\n5. **Always validate project exists** before API calls (if using projectname)\n6. **Always use descriptive error messages** with context\n7. **Always use emojis in concise format** for simple CRUD tools\n8. **Always follow kebab-case** for file and tool names\n9. **Always follow PascalCase** for function names\n10. **Always provide detailed Zod descriptions** with examples\n11. **Always handle null/undefined responses** gracefully\n12. **Multi-action tools**: Return structured JSON with status/action/message\n13. **Direct API calls**: Use fetch and check response.ok\n14. **Note square bracket support**: Add notes about `[]` support in descriptions where relevant (file paths, labels, markdown)\n\n## Quality Checklist\n\nBefore presenting the generated tool:\n\n- ‚úÖ File name is kebab-case\n- ‚úÖ Function name is PascalCase with \"register\" prefix\n- ‚úÖ All imports are correct\n- ‚úÖ Zod schema has detailed descriptions\n- ‚úÖ Appropriate tool pattern selected (Simple CRUD / Multi-Action / Complex)\n- ‚úÖ For simple CRUD: projectname optional, format parameter included\n- ‚úÖ For multi-action: action enum, structured responses, conditional params\n- ‚úÖ HTML content cleaned where applicable\n- ‚úÖ Error messages are descriptive and actionable\n- ‚úÖ Response format matches tool type\n- ‚úÖ Try-catch wraps the entire handler\n- ‚úÖ All responses follow `{ content: [{ type: \"text\", text: ... }] }` format\n- ‚úÖ Tool follows MCP SDK patterns\n- ‚úÖ Code matches project conventions from CLAUDE.md\n\n---\n\n**Ready to generate MCP tools!** Tell me what GitLab operation you want to create a tool for.\n",
        "py-plugin/skills/mcp-tool-generator/examples.md": "# MCP Tool Generator Examples\n\nComplete examples of generated MCP tools following the standardized patterns. Includes simple CRUD tools, multi-action tools, and complex operation tools.\n\n## Example 1: Simple CRUD - Get Merge Request Details\n\n**Tool Type**: Simple CRUD (Pattern A)\n\n### User Request\n\"Create a tool to get merge request details by IID\"\n\n### Generated File: `src/tools/gitlab/gitlab-get-merge-request.ts`\n\n```typescript\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp';\nimport { z } from 'zod';\nimport { cleanGitLabHtmlContent } from '../../core/utils';\nimport { getGitLabService, getProjectNameFromUser } from './gitlab-shared';\n\nexport function registerGetMergeRequest(server: McpServer) {\n    server.registerTool(\n        \"gitlab-get-merge-request\",\n        {\n            title: \"Get Merge Request Details\",\n            description: \"Retrieve detailed information for a specific merge request by IID in a GitLab project. Returns merge request metadata including title, description, state, author, assignee, reviewers, labels, milestone, source/target branches, and approval status. Use this when you need comprehensive information about a specific merge request.\",\n            inputSchema: {\n                mergeRequestIid: z.number().describe(\"The internal ID (IID) of the merge request to retrieve\"),\n                projectname: z.string().optional().describe(\"GitLab project name (if not provided, you'll be prompted to select)\"),\n                format: z.enum([\"detailed\", \"concise\"]).optional().describe(\"Response format - 'detailed' includes all metadata, 'concise' includes only key information\")\n            }\n        },\n        async ({ mergeRequestIid, projectname, format = \"detailed\" }) => {\n            const iid = mergeRequestIid as number;\n            try {\n                const projectName = projectname || await getProjectNameFromUser(server, false, \"Please select the project for getting merge request\");\n                if (!projectName) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: \"Project not found or not selected. Please provide a valid project name.\" }) }] };\n                }\n\n                const service = await getGitLabService(server);\n                const projectId = await service.getProjectId(projectName);\n                if (!projectId) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Could not find project \"${projectName}\". Please verify the project name is correct and you have access to it.` }) }] };\n                }\n\n                const rawMr = await service.getMergeRequest(projectId, iid);\n                if (!rawMr) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Merge request !${iid} not found in project \"${projectName}\". Please verify the merge request IID is correct.` }) }] };\n                }\n\n                // Clean HTML content from merge request fields\n                const mr = cleanGitLabHtmlContent(rawMr, ['description', 'title']);\n\n                // Format response based on requested format\n                if (format === \"concise\") {\n                    const conciseInfo = {\n                        title: mr.title,\n                        state: mr.state,\n                        author: mr.author?.name || \"Unknown\",\n                        assignee: mr.assignee?.name || \"Unassigned\",\n                        labels: mr.labels || [],\n                        milestone: mr.milestone?.title || \"No milestone\",\n                        source_branch: mr.source_branch,\n                        target_branch: mr.target_branch,\n                        web_url: mr.web_url\n                    };\n                    return { content: [{ type: \"text\", text: `üîç MR !${iid}: ${mr.title}\\nüìä Status: ${mr.state}\\nüë§ Author: ${conciseInfo.author}\\nüë§ Assignee: ${conciseInfo.assignee}\\nüè∑Ô∏è Labels: ${conciseInfo.labels.join(', ') || 'None'}\\nüéØ Milestone: ${conciseInfo.milestone}\\nüîÄ ${conciseInfo.source_branch} ‚Üí ${conciseInfo.target_branch}\\nüîó URL: ${mr.web_url}` }] };\n                }\n\n                return { content: [{ type: \"text\", text: JSON.stringify(mr, null, 2) }] };\n            } catch (e) {\n                return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Error retrieving merge request !${iid}: ${String(e)}. Please check your GitLab connection and permissions.` }) }] };\n            }\n        }\n    );\n}\n```\n\n### Registration in `gitlab-tool.ts`\n\n```typescript\nimport { registerGetMergeRequest } from './gitlab/gitlab-get-merge-request';\n\nexport function registerGitlabTools(server: McpServer) {\n    // ... other registrations\n    registerGetMergeRequest(server);\n}\n```\n\n---\n\n## Example 2: Multi-Action Tool - Manage Issues\n\n**Tool Type**: Multi-Action (Pattern B)\n\n### User Request\n\"Create a tool that can manage issues - get details, close, reopen, add labels, set assignees, and set due dates\"\n\n### Generated File: `src/tools/gitlab/gitlab-manage-issue.ts`\n\n```typescript\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp';\nimport fetch from 'node-fetch';\nimport { z } from 'zod';\nimport { cleanGitLabHtmlContent } from '../../core/utils';\nimport { getGitLabService, getProjectNameFromUser } from './gitlab-shared';\n\nexport function registerManageIssue(server: McpServer) {\n    server.registerTool(\n        \"gitlab-manage-issue\",\n        {\n            title: \"Manage GitLab Issue\",\n            description: \"Comprehensive issue management tool that can get, update, or modify issues in a single operation. More efficient than using multiple separate tools. Supports getting issue details, updating status, adding labels, setting assignees, and modifying due dates.\",\n            inputSchema: {\n                issueIid: z.number().describe(\"The internal ID (IID) of the issue to manage\"),\n                projectname: z.string().optional().describe(\"GitLab project name (if not provided, you'll be prompted to select)\"),\n                action: z.enum([\"get\", \"close\", \"reopen\", \"add-labels\", \"set-assignee\", \"set-due-date\"]).describe(\"Action to perform on the issue\"),\n                // Parameters for different actions\n                labels: z.array(z.string()).optional().describe(\"For add-labels action: labels to add to the issue. Square brackets [] are allowed in label names.\"),\n                assignee_username: z.string().optional().describe(\"For set-assignee action: username to assign the issue to\"),\n                due_date: z.string().optional().describe(\"For set-due-date action: due date in YYYY-MM-DD format\")\n            }\n        },\n        async ({ issueIid, projectname, action, labels, assignee_username, due_date }) => {\n            const iid = issueIid as number;\n            try {\n                const projectName = projectname || await getProjectNameFromUser(server, false, \"Please select the project for issue management\");\n                if (!projectName) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: \"Project not found or not selected. Please provide a valid project name.\" }) }] };\n                }\n\n                const service = await getGitLabService(server);\n                const projectId = await service.getProjectId(projectName);\n                if (!projectId) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Could not find project \"${projectName}\". Please verify the project name is correct and you have access to it.` }) }] };\n                }\n\n                // Get issue first for all actions\n                const rawIssue = await service.getIssue(projectId, iid);\n                if (!rawIssue) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Issue #${iid} not found in project \"${projectName}\". Please verify the issue IID is correct.` }) }] };\n                }\n\n                // Clean HTML content from issue fields\n                const issue = cleanGitLabHtmlContent(rawIssue, ['description', 'title']);\n\n                switch (action) {\n                    case \"get\":\n                        return { content: [{ type: \"text\", text: JSON.stringify({\n                            status: 'success',\n                            action: 'get',\n                            issue: {\n                                id: issue.id,\n                                iid: issue.iid,\n                                title: issue.title,\n                                webUrl: issue.web_url,\n                                state: issue.state,\n                                assignee: issue.assignee?.name || null,\n                                labels: issue.labels || [],\n                                milestone: issue.milestone?.title || null,\n                                dueDate: issue.due_date || null,\n                                description: issue.description\n                            }\n                        }, null, 2) }] };\n\n                    case \"close\":\n                        const closeResponse = await fetch(`${service.gitlabUrl}/api/v4/projects/${projectId}/issues/${iid}`, {\n                            method: 'PUT',\n                            headers: service['getHeaders'](),\n                            body: JSON.stringify({ state_event: \"close\" })\n                        });\n                        if (!closeResponse.ok) {\n                            return { content: [{ type: \"text\", text: JSON.stringify({\n                                status: 'failure',\n                                action: 'close',\n                                error: `Failed to close issue #${iid}. Status: ${closeResponse.status}`,\n                                issue: { id: issue.id, iid: issue.iid, title: issue.title, webUrl: issue.web_url }\n                            }, null, 2) }] };\n                        }\n                        const closedIssue = await closeResponse.json();\n                        return { content: [{ type: \"text\", text: JSON.stringify({\n                            status: 'success',\n                            action: 'close',\n                            message: `Issue #${iid} has been closed successfully`,\n                            issue: {\n                                id: closedIssue.id,\n                                iid: closedIssue.iid,\n                                title: closedIssue.title,\n                                webUrl: closedIssue.web_url,\n                                state: closedIssue.state\n                            }\n                        }, null, 2) }] };\n\n                    case \"add-labels\":\n                        if (!labels || labels.length === 0) {\n                            return { content: [{ type: \"text\", text: JSON.stringify({\n                                status: 'failure',\n                                action: 'add-labels',\n                                error: \"No labels provided. Please specify labels to add using the 'labels' parameter.\",\n                                issue: { id: issue.id, iid: issue.iid, title: issue.title, webUrl: issue.web_url }\n                            }, null, 2) }] };\n                        }\n                        const currentLabels = issue.labels || [];\n                        const newLabels = [...new Set([...currentLabels, ...labels])];\n                        const labelsResponse = await fetch(`${service.gitlabUrl}/api/v4/projects/${projectId}/issues/${iid}`, {\n                            method: 'PUT',\n                            headers: service['getHeaders'](),\n                            body: JSON.stringify({ labels: newLabels.join(',') })\n                        });\n                        if (!labelsResponse.ok) {\n                            return { content: [{ type: \"text\", text: JSON.stringify({\n                                status: 'failure',\n                                action: 'add-labels',\n                                error: `Failed to add labels. Status: ${labelsResponse.status}`,\n                                issue: { id: issue.id, iid: issue.iid, title: issue.title, webUrl: issue.web_url }\n                            }, null, 2) }] };\n                        }\n                        const labeledIssue = await labelsResponse.json();\n                        return { content: [{ type: \"text\", text: JSON.stringify({\n                            status: 'success',\n                            action: 'add-labels',\n                            message: `Added labels to issue #${iid}`,\n                            addedLabels: labels,\n                            issue: {\n                                id: labeledIssue.id,\n                                iid: labeledIssue.iid,\n                                title: labeledIssue.title,\n                                webUrl: labeledIssue.web_url,\n                                labels: labeledIssue.labels\n                            }\n                        }, null, 2) }] };\n\n                    default:\n                        return { content: [{ type: \"text\", text: JSON.stringify({\n                            status: 'failure',\n                            action: action,\n                            error: `Unknown action \"${action}\"`\n                        }, null, 2) }] };\n                }\n            } catch (e) {\n                return { content: [{ type: \"text\", text: JSON.stringify({\n                    status: 'failure',\n                    error: `Error managing issue #${iid}: ${String(e)}`\n                }, null, 2) }] };\n            }\n        }\n    );\n}\n```\n\n---\n\n## Example 3: Complex Operation - Review Merge Request Code\n\n**Tool Type**: Complex Operation (Pattern C)\n\n### User Request\n\"Create a tool to add inline code review comments on merge requests with position tracking and duplicate detection\"\n\n### Generated File: `src/tools/gitlab/gitlab-review-merge-request-code.ts`\n\n```typescript\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp';\nimport { z } from 'zod';\nimport { getGitLabService } from './gitlab-shared';\n\nexport function registerReviewMergeRequestCode(server: McpServer) {\n    server.registerTool(\n        \"gitlab-review-merge-request-code\",\n        {\n            title: \"Review Merge Request Code\",\n            description: \"Add or update a code review comment on a merge request at a specific file and line position. This tool is designed for inline code reviews - it intelligently updates existing comments at the same position instead of creating duplicates. Requires diff SHA references (base, start, head) and file path with optional line numbers.\",\n            inputSchema: {\n                projectId: z.number().describe(\"The project ID\"),\n                mrIid: z.number().describe(\"The merge request IID\"),\n                body: z.string().describe(\"The review comment body. Square brackets [] are allowed and commonly used in code references, markdown links, and examples.\"),\n                positionType: z.string().default(\"text\").describe(\"Position type (text, image, etc.)\"),\n                baseSha: z.string().describe(\"Base SHA for the diff\"),\n                startSha: z.string().describe(\"Start SHA for the diff\"),\n                headSha: z.string().describe(\"Head SHA for the diff\"),\n                newPath: z.string().describe(\"Path to the file being reviewed. Square brackets [] are allowed in file paths.\"),\n                newLine: z.number().optional().describe(\"Line number in the new file (for line comments)\"),\n                oldPath: z.string().optional().describe(\"Path to the old file (defaults to newPath). Square brackets [] are allowed in file paths.\"),\n                oldLine: z.number().optional().describe(\"Line number in the old file (for line comments)\")\n            }\n        },\n        async ({ projectId, mrIid, body, positionType, baseSha, startSha, headSha, newPath, newLine, oldPath, oldLine }) => {\n            const pid = projectId as number;\n            const iid = mrIid as number;\n            const commentBody = body as string;\n            const posType = positionType as string;\n            const base = baseSha as string;\n            const start = startSha as string;\n            const head = headSha as string;\n            const path = newPath as string;\n            const line = newLine as number | undefined;\n            const oldFilePath = (oldPath as string | undefined) || path;\n            const oldFileLine = oldLine as number | undefined;\n\n            try {\n                const service = await getGitLabService(server);\n\n                // Get existing discussions to check for existing review comments\n                const discussions = await service.getMrDiscussions(String(pid), iid);\n\n                // Find existing review comment at the same position\n                let existingDiscussion = null;\n                let existingNote = null;\n\n                for (const discussion of discussions) {\n                    if (discussion.notes && discussion.notes.length > 0) {\n                        const firstNote = discussion.notes[0];\n\n                        // Check if the position matches our target position\n                        if (firstNote.position &&\n                            firstNote.position.new_path === path &&\n                            firstNote.position.base_sha === base &&\n                            firstNote.position.head_sha === head &&\n                            firstNote.position.start_sha === start) {\n\n                            // Check if line position matches (if specified)\n                            const positionMatches = line !== undefined ?\n                                firstNote.position.new_line === line :\n                                !firstNote.position.new_line;\n\n                            if (positionMatches) {\n                                existingDiscussion = discussion;\n                                existingNote = firstNote;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                let result;\n\n                if (existingNote && existingDiscussion) {\n                    // Update existing comment\n                    result = await service.updateMrDiscussionNote(\n                        String(pid),\n                        iid,\n                        existingDiscussion.id,\n                        existingNote.id,\n                        commentBody\n                    );\n\n                    return {\n                        content: [{\n                            type: \"text\",\n                            text: JSON.stringify({\n                                action: \"updated\",\n                                discussion_id: existingDiscussion.id,\n                                note_id: existingNote.id,\n                                updated_note: result\n                            })\n                        }]\n                    };\n                } else {\n                    // Create new comment\n                    const position: any = {\n                        position_type: posType,\n                        base_sha: base,\n                        start_sha: start,\n                        head_sha: head,\n                        new_path: path,\n                        old_path: oldFilePath\n                    };\n\n                    if (line !== undefined) {\n                        position.new_line = line;\n                    }\n\n                    if (oldFileLine !== undefined) {\n                        position.old_line = oldFileLine;\n                    }\n\n                    const data = { body: commentBody, position };\n                    result = await service.addMrComments(String(pid), iid, data);\n\n                    return {\n                        content: [{\n                            type: \"text\",\n                            text: JSON.stringify({\n                                action: \"created\",\n                                discussion: result\n                            })\n                        }]\n                    };\n                }\n            } catch (e) {\n                return {\n                    content: [{\n                        type: \"text\",\n                        text: JSON.stringify({ type: \"error\", error: String(e) })\n                    }]\n                };\n            }\n        }\n    );\n}\n```\n\n---\n\n## Example 4: Simple CRUD - List Pipelines\n\n**Tool Type**: Simple CRUD (Pattern A)\n\n### User Request\n\"I need a tool to list all pipelines with status filtering and pagination\"\n\n### Generated File: `src/tools/gitlab/gitlab-list-pipelines.ts`\n\n```typescript\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp';\nimport { z } from 'zod';\nimport { cleanGitLabHtmlContent } from '../../core/utils';\nimport { getGitLabService, getProjectNameFromUser } from './gitlab-shared';\n\nexport function registerListPipelines(server: McpServer) {\n    server.registerTool(\n        \"gitlab-list-pipelines\",\n        {\n            title: \"List Pipelines\",\n            description: \"Retrieve a list of pipelines for a GitLab project. Supports filtering by ref (branch/tag), status, and pagination. Returns pipeline information including ID, status, ref, commit details, and timestamps. Use this to monitor CI/CD pipeline execution, check build status, or find specific pipeline runs.\",\n            inputSchema: {\n                projectname: z.string().optional().describe(\"GitLab project name (if not provided, you'll be prompted to select)\"),\n                ref: z.string().optional().describe(\"Filter pipelines by git reference (branch or tag name, e.g., 'main', 'develop')\"),\n                status: z.enum([\"running\", \"pending\", \"success\", \"failed\", \"canceled\", \"skipped\", \"manual\"]).optional().describe(\"Filter pipelines by status\"),\n                page: z.number().optional().describe(\"Page number for pagination (default: 1)\"),\n                perPage: z.number().optional().describe(\"Number of pipelines per page (default: 20, max: 100)\"),\n                format: z.enum([\"detailed\", \"concise\"]).optional().describe(\"Response format - 'detailed' includes all metadata, 'concise' includes only key information\")\n            }\n        },\n        async ({ projectname, ref, status, page = 1, perPage = 20, format = \"detailed\" }) => {\n            try {\n                const projectName = projectname || await getProjectNameFromUser(server, false, \"Please select the project for listing pipelines\");\n                if (!projectName) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: \"Project not found or not selected. Please provide a valid project name.\" }) }] };\n                }\n\n                const service = await getGitLabService(server);\n                const projectId = await service.getProjectId(projectName);\n                if (!projectId) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Could not find project \"${projectName}\". Please verify the project name is correct and you have access to it.` }) }] };\n                }\n\n                const options: any = { page, per_page: perPage };\n                if (ref) options.ref = ref;\n                if (status) options.status = status;\n\n                const rawPipelines = await service.getPipelines(projectId, options);\n                if (!rawPipelines || rawPipelines.length === 0) {\n                    return { content: [{ type: \"text\", text: JSON.stringify({ type: \"info\", message: `No pipelines found in project \"${projectName}\" with the specified filters.` }) }] };\n                }\n\n                const pipelines = rawPipelines.map(p => cleanGitLabHtmlContent(p, []));\n\n                if (format === \"concise\") {\n                    const summary = pipelines.map(p =>\n                        `üìã Pipeline #${p.id} | ${p.status} | ${p.ref} | ${new Date(p.created_at).toLocaleDateString()}`\n                    ).join('\\n');\n                    return { content: [{ type: \"text\", text: `üìã Found ${pipelines.length} pipeline(s) in \"${projectName}\":\\n\\n${summary}` }] };\n                }\n\n                return { content: [{ type: \"text\", text: JSON.stringify(pipelines, null, 2) }] };\n            } catch (e) {\n                return { content: [{ type: \"text\", text: JSON.stringify({ type: \"error\", error: `Error listing pipelines: ${String(e)}. Please check your GitLab connection and permissions.` }) }] };\n            }\n        }\n    );\n}\n```\n\n---\n\n## Common Patterns Summary\n\n### Tool Pattern Selection Guide\n\n| Tool Type | When to Use | Key Features | Example |\n|-----------|-------------|--------------|---------|\n| **Simple CRUD** | Single operation on resource | projectname, format, emojis | `gitlab-get-issue` |\n| **Multi-Action** | Multiple operations on same resource | action enum, structured responses | `gitlab-manage-issue` |\n| **Complex** | Advanced logic, discussions, position-based | Custom parameters, specialized logic | `gitlab-review-merge-request-code` |\n\n### Response Format Patterns\n\n**Simple CRUD - Concise**:\n```typescript\nif (format === \"concise\") {\n    return { content: [{ type: \"text\", text:\n        `üîç Resource #${id}: ${title}\\n` +\n        `üìä Status: ${state}\\n` +\n        `üîó URL: ${web_url}`\n    }] };\n}\n```\n\n**Multi-Action - Structured**:\n```typescript\nreturn { content: [{ type: \"text\", text: JSON.stringify({\n    status: 'success',\n    action: 'close',\n    message: 'Issue closed successfully',\n    issue: { /* key fields */ }\n}, null, 2) }] };\n```\n\n**Complex - Custom**:\n```typescript\nreturn { content: [{ type: \"text\", text: JSON.stringify({\n    action: \"updated\",\n    discussion_id: \"...\",\n    updated_note: {...}\n}) }] };\n```\n\n### Error Handling Pattern\n\n```typescript\ntry {\n    // Operation logic\n} catch (e) {\n    // Simple CRUD\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        type: \"error\",\n        error: `Error: ${String(e)}`\n    }) }] };\n\n    // Multi-Action\n    return { content: [{ type: \"text\", text: JSON.stringify({\n        status: 'failure',\n        error: `Error: ${String(e)}`\n    }, null, 2) }] };\n}\n```\n\n---\n\n## Tool Comparison Table\n\n| Feature | Simple CRUD | Multi-Action | Complex |\n|---------|-------------|--------------|---------|\n| projectname param | ‚úÖ Optional | ‚úÖ Optional | ‚ùå May use projectId |\n| format param | ‚úÖ Required | ‚ùå Not used | ‚ùå Not used |\n| action enum | ‚ùå Not used | ‚úÖ Required | ‚ùå Custom |\n| Emoji output | ‚úÖ Concise format | ‚ùå Not used | ‚ùå Not used |\n| HTML cleaning | ‚úÖ Always | ‚úÖ Always | ‚ö†Ô∏è If applicable |\n| Response type | JSON or text | Structured JSON | Custom |\n| Direct fetch API | ‚ùå Use service | ‚úÖ Often used | ‚úÖ If needed |\n| Complexity | Low | Medium | High |\n\n---\n\n**All examples follow the project's standardized patterns and conventions from CLAUDE.md!**\n",
        "py-plugin/skills/payoo-ios-code-review/SKILL.md": "---\nname: payoo-ios-code-review\ndescription: Comprehensive iOS code review for Payoo Merchant app. Checks Clean Architecture patterns, MVVM with RxSwift, memory management, Swinject DI, session error handling, layer separation, naming conventions, and SwiftLint compliance. Use when \"review code\", \"check code\", \"code review\", \"review PR\", \"check pull request\", or analyzing Swift files in this project.\nallowed-tools: Read, Grep, Glob, Bash\n---\n\n# Payoo iOS Code Review\n\nComprehensive code review for the Payoo Merchant iOS app following Clean Architecture with RxSwift and Swinject.\n\n## When to Activate\n\n- \"review code\", \"check code\", \"code review\"\n- \"review PR\", \"review pull request\", \"check pull request\"\n- \"review this file\", \"check this ViewModel\"\n- \"is this code correct\", \"any issues with this code\"\n- When analyzing Swift files in PayooMerchant, Domain, Data, or Analytics layers\n\n## Review Process\n\n### Step 1: Identify Scope\n- Single file review ‚Üí Read the file\n- Multiple files ‚Üí Use Glob to find related files\n- Pull request ‚Üí Check git diff for changed files\n- Full feature ‚Üí Grep for related ViewModels/UseCases\n\n### Step 2: Layer-Specific Checks\n\n#### For Presentation Layer (PayooMerchant/)\n1. **MVVM Pattern**\n   - ‚úì ViewModel implements `ViewModelType` protocol\n   - ‚úì Has `Input` and `Output` nested types\n   - ‚úì Has `transform(input:) -> Output` method\n   - ‚úì ViewControllers bind to Input/Output only\n   - ‚úì No business logic in ViewControllers\n\n2. **RxSwift Memory Management**\n   - ‚úì Every ViewController/ViewModel has `DisposeBag`\n   - ‚úì All subscriptions use `.disposed(by: disposeBag)`\n   - ‚úì Closures capturing self use `[weak self]` or `[unowned self]`\n   - ‚úì No retain cycles in Observable chains\n\n3. **Navigation & DI**\n   - ‚úì Navigator passed as dependency (never created directly)\n   - ‚úì UseCases injected via constructor\n   - ‚úì No direct ViewController instantiation\n   - ‚úì Uses factory methods from `ViewControllerFactory`\n\n4. **Session Error Handling**\n   - ‚úì **CRITICAL**: All API calls have `.catchSessionError(sessionUC)`\n   - ‚úó Missing `.catchSessionError()` ‚Üí Session timeout won't logout\n\n#### For Domain Layer (Domain/)\n1. **Clean Architecture Rules**\n   - ‚úì Pure Swift only (no UIKit imports)\n   - ‚úì No imports from Data or Presentation layers\n   - ‚úì Only protocols for services (no implementations)\n   - ‚úì Models are simple structs/classes\n\n2. **UseCase Pattern**\n   - ‚úì Protocol defines interface (`UseCaseType`)\n   - ‚úì Implementation injected with dependencies\n   - ‚úì Single responsibility per UseCase\n   - ‚úì Returns RxSwift Observables/Singles/Maybes\n   - ‚úì Uses `.catchSessionError(sessionUC)` for API calls\n\n3. **Service Protocols**\n   - ‚úì Defined in `Domain/Service/`\n   - ‚úì Implemented in Data layer\n   - ‚úì Injected via Swinject\n\n#### For Data Layer (Data/)\n1. **Repository Pattern**\n   - ‚úì Implements Domain service protocols\n   - ‚úì Uses Moya for network calls\n   - ‚úì Uses Realm for local storage\n   - ‚úì Converters transform DTOs ‚Üî Domain models\n\n2. **API Models**\n   - ‚úì DTOs in `Data/Model/`\n   - ‚úì Conform to `DomainConvertible` or `RealmRepresentable`\n   - ‚úì Use ObjectMapper for JSON parsing\n   - ‚úì Don't leak to Domain/Presentation layers\n\n### Step 3: Project-Wide Checks\n\n1. **SwiftLint Compliance**\n   - Run: `./Pods/SwiftLint/swiftlint lint --reporter xcode`\n   - Check: Type body length (300/400), file length (800/1200)\n   - Check: Opt-in rules (empty_count, yoda_condition, todo, etc.)\n\n2. **Common Pitfalls**\n   - [ ] Missing `.catchSessionError()` on API observables\n   - [ ] Manual ViewController instantiation (should use factory)\n   - [ ] Missing DependencyContainer registration\n   - [ ] Breaking layer boundaries (e.g., Data imported in Domain)\n   - [ ] Missing `disposed(by: disposeBag)`\n   - [ ] Strong self in closures causing retain cycles\n   - [ ] Using `.count > 0` instead of `.isEmpty` (SwiftLint)\n   - [ ] Force unwraps without justification\n   - [ ] Magic numbers without constants\n\n3. **RxSwift Best Practices**\n   - Use `Driver` for UI bindings (never fails, main thread)\n   - Use `Single` for one-time operations (network calls)\n   - Use `Observable` for streams\n   - Use `Maybe` for optional single values\n   - Prefer `.bind(to:)` over `.subscribe(onNext:)`\n\n4. **Naming Conventions**\n   - [ ] ViewModels: `[Feature]ViewModel` (e.g., `LoginViewModel`, `TransactionHistoryViewModel`)\n   - [ ] ViewControllers: `[Feature]ViewController` (e.g., `LoginViewController`)\n   - [ ] UseCases: `[Action]UseCase` (e.g., `GetProfileUseCase`, `LoginUseCase`)\n   - [ ] UseCase protocols: `[Action]UseCaseType` (e.g., `GetProfileUseCaseType`)\n   - [ ] Navigators: `[Feature]Navigator` (e.g., `LoginNavigator`, `HomeNavigator`)\n   - [ ] Navigator protocols: `[Feature]NavigatorType`\n   - [ ] Services (protocols): `[Name]Service` (e.g., `ApiService`, `LocalStorageService`)\n   - [ ] Services (impl): `Default[Name]Service` or `[Tech][Name]Service` (e.g., `DefaultApiService`, `RealmStorageService`)\n   - [ ] Protocols: `[Name]Type` suffix for main protocols\n   - [ ] Variables: camelCase, descriptive (avoid abbreviations like `usrNm`, use `username`)\n   - [ ] Constants: camelCase for local, or `k` prefix for global (e.g., `kMaxRetryCount`)\n   - [ ] IBOutlets: Descriptive names with type suffix (e.g., `loginButton`, `usernameTextField`)\n   - [ ] Avoid single letters except in loops (i, j) or common conventions (x, y)\n\n### Step 4: Generate Report\n\nFormat:\n```markdown\n## Code Review: [File/Feature Name]\n\n### üìã Summary\nFiles: X | üî¥ Critical: X | üü° Warning: X | üîµ Info: X | Status: [‚úÖ Approved / ‚ö†Ô∏è Needs fixes / ‚ùå Blocked]\n\n### ‚úÖ Strengths\n- [List good patterns found]\n\n### ‚ö†Ô∏è Issues Found\n\n#### üî¥ Critical (Must Fix)\n**[Issue]** at [file:line]\n- **Problem**: [Description]\n- **Impact**: [Why critical]\n- **Fix**:\n\\`\\`\\`swift\n// Corrected code\n\\`\\`\\`\n\n#### üü° Warning (Should Fix)\n**[Issue]** at [file:line]\n- **Problem**: [Description]\n- **Suggestion**: [How to fix]\n\n#### üîµ Info (Consider)\n**[Issue]** at [file:line]\n- **Note**: [Observation]\n- **Suggestion**: [Optional improvement]\n```\n\n## Review Categories\n\n### Critical Issues (Must Fix)\n- Missing `.catchSessionError()` on API calls\n- Retain cycles / memory leaks\n- Breaking Clean Architecture layer boundaries\n- Missing DisposeBag disposal\n- Force unwraps in unsafe contexts\n\n### Warnings (Should Fix)\n- Manual ViewController instantiation\n- Missing DependencyContainer registration\n- SwiftLint violations\n- Non-descriptive variable names\n- Large type bodies (>300 lines)\n\n### Info (Consider)\n- Potential optimizations\n- Code duplication\n- Missing unit tests\n- Outdated comments\n- TODO/FIXME comments\n\n## Quick Commands\n\nRun SwiftLint:\n```bash\n./Pods/SwiftLint/swiftlint lint --reporter xcode\n```\n\nFind files without DisposeBag:\n```bash\ngrep -L \"DisposeBag\" PayooMerchant/**/*ViewModel.swift\n```\n\nFind API calls without catchSessionError:\n```bash\ngrep -r \"apiService\\.\" --include=\"*.swift\" | grep -v \"catchSessionError\"\n```\n\n## Example Review Flow\n\n1. User: \"Review LoginViewModel\"\n2. Read `PayooMerchant/Controllers/Login/LoginViewModel.swift`\n3. Check MVVM pattern, RxSwift, DI\n4. Grep for related files (LoginViewController, LoginUseCase)\n5. Run SwiftLint on the file\n6. Generate detailed report with line numbers\n7. Provide fix recommendations\n\n## Key Architectural Rules\n\n1. **Layer Dependencies**\n   ```\n   Presentation ‚Üí Domain ‚Üê Data\n   ```\n   - Presentation can import Domain\n   - Data can import Domain\n   - Domain imports nothing (pure Swift)\n   - NEVER: Domain imports Data/Presentation\n\n2. **RxSwift Pattern**\n   ```swift\n   // ViewModel transform pattern\n   func transform(input: Input) -> Output {\n       let result = input.trigger\n           .flatMapLatest { [weak self] _ -> Observable<Data> in\n               guard let self = self else { return .empty() }\n               return self.useCase.execute()\n                   .catchSessionError(self.sessionUC) // CRITICAL!\n           }\n       return Output(result: result.asDriver(onErrorJustReturn: .empty))\n   }\n   ```\n\n3. **Memory Management**\n   ```swift\n   // CORRECT\n   .subscribe(onNext: { [weak self] value in\n       self?.updateUI(value)\n   }).disposed(by: disposeBag)\n\n   // WRONG - Retain cycle!\n   .subscribe(onNext: { value in\n       self.updateUI(value)\n   }).disposed(by: disposeBag)\n   ```\n\n## Output Format\n\nAlways provide:\n1. Clear issue categorization (Critical/Warning/Info)\n2. File paths with line numbers for clickable links\n3. Code snippets showing the problem\n4. Concrete fix recommendations\n5. Summary with metrics\n\nReference: See `standards.md` for detailed coding standards and `examples.md` for review examples.\n",
        "py-plugin/skills/payoo-ios-code-review/examples.md": "# Code Review Examples\n\nReal-world code review examples for the Payoo Merchant iOS app.\n\n## Example 1: ViewModel Review (Critical Issues)\n\n### File: LoginViewModel.swift\n\n```swift\nfinal class LoginViewModel: ViewModelType {\n    private let apiService: ApiService\n    private let navigator: LoginNavigator\n\n    init(apiService: ApiService, navigator: LoginNavigator) {\n        self.apiService = apiService\n        self.navigator = navigator\n    }\n\n    struct Input {\n        let loginTrigger: Driver<(String, String)>\n    }\n\n    struct Output {\n        let isLoading: Driver<Bool>\n        let error: Driver<String>\n    }\n\n    func transform(input: Input) -> Output {\n        let activityIndicator = ActivityIndicator()\n\n        let result = input.loginTrigger\n            .flatMapLatest { username, password in\n                return self.apiService.login(username: username, password: password)  // ‚ö†Ô∏è Issue 1\n                    .trackActivity(activityIndicator)\n            }\n\n        result\n            .subscribe(onNext: { response in  // ‚ö†Ô∏è Issue 2\n                self.navigator.navigate(to: .home)  // ‚ö†Ô∏è Issue 3\n            })\n\n        return Output(\n            isLoading: activityIndicator.asDriver(),\n            error: result.map { $0.error }.asDriver(onErrorJustReturn: \"Unknown error\")\n        )\n    }\n}\n```\n\n### Review Report\n\n#### ‚ö†Ô∏è Critical Issues\n\n**1. Missing `.catchSessionError()` at line 23**\n- **Problem**: API call doesn't handle session errors\n- **Impact**: App won't logout on session timeout\n- **Fix**:\n```swift\nreturn self.apiService.login(username: username, password: password)\n    .catchSessionError(self.sessionUC)  // Add this!\n    .trackActivity(activityIndicator)\n```\n\n**2. Missing `DisposeBag` for subscription at line 27**\n- **Problem**: Subscription never disposed, causes memory leak\n- **Impact**: ViewModel stays in memory even after deallocation\n- **Fix**:\n```swift\nprivate let disposeBag = DisposeBag()\n\nresult\n    .subscribe(onNext: { [weak self] response in\n        self?.navigator.navigate(to: .home)\n    })\n    .disposed(by: disposeBag)  // Add this!\n```\n\n**3. Strong self capture at line 28**\n- **Problem**: `self` captured strongly in closure\n- **Impact**: Retain cycle, memory leak\n- **Fix**:\n```swift\nresult\n    .subscribe(onNext: { [weak self] response in  // Use [weak self]\n        self?.navigator.navigate(to: .home)\n    })\n    .disposed(by: disposeBag)\n```\n\n**4. Missing SessionUseCase dependency**\n- **Problem**: Can't use `.catchSessionError()` without SessionUseCase\n- **Fix**:\n```swift\nprivate let sessionUC: SessionUseCaseType\n\ninit(apiService: ApiService, navigator: LoginNavigator, sessionUC: SessionUseCaseType) {\n    self.apiService = apiService\n    self.navigator = navigator\n    self.sessionUC = sessionUC\n}\n```\n\n#### üìã Summary\nFiles: 1 | üî¥ Critical: 4 | üü° Warning: 0 | üîµ Info: 0 | Status: ‚ùå Must fix before merge\n\n---\n\n## Example 2: UseCase Review (Correct Pattern)\n\n### File: GetProfileUseCase.swift\n\n```swift\npublic protocol GetProfileUseCaseType {\n    func execute() -> Single<Profile>\n    func getAndObserve() -> Observable<Profile?>\n}\n\npublic final class GetProfileUseCase: GetProfileUseCaseType {\n    private let apiService: ApiService\n    private let localStorage: LocalStorageService\n    private let sessionUC: SessionUseCaseType\n\n    public init(apiService: ApiService, localStorage: LocalStorageService, sessionUC: SessionUseCaseType) {\n        self.apiService = apiService\n        self.localStorage = localStorage\n        self.sessionUC = sessionUC\n    }\n\n    public func execute() -> Single<Profile> {\n        return apiService.getProfile()\n            .catchSessionError(sessionUC)  // ‚úÖ Correct!\n            .do(onSuccess: { [weak self] profile in\n                self?.localStorage.save(profile)\n            })\n    }\n\n    public func getAndObserve() -> Observable<Profile?> {\n        return localStorage.observe(Profile.self)\n    }\n}\n```\n\n### Review Report\n\n#### ‚úÖ Strengths\n- **Clean Architecture**: Pure Swift, no UIKit imports\n- **Session Error Handling**: Uses `.catchSessionError(sessionUC)` ‚úì\n- **Dependency Injection**: All dependencies injected via constructor ‚úì\n- **Memory Management**: Uses `[weak self]` in closure ‚úì\n- **Single Responsibility**: Each method has one clear purpose ‚úì\n- **Protocol-Oriented**: Defined protocol for abstraction ‚úì\n\n#### üìã Summary\nFiles: 1 | üî¥ Critical: 0 | üü° Warning: 0 | üîµ Info: 0 | Status: ‚úÖ Ready to merge\n\n---\n\n## Example 3: Layer Boundary Violation\n\n### File: Domain/UseCase/ProfileUseCase.swift\n\n```swift\nimport UIKit  // ‚ö†Ô∏è Issue 1\nimport Domain\nimport Data  // ‚ö†Ô∏è Issue 2\n\npublic final class ProfileUseCase: ProfileUseCaseType {\n    private let repository: ProfileRepositoryImpl  // ‚ö†Ô∏è Issue 3\n\n    public func execute() -> Single<Profile> {\n        let indicator = UIActivityIndicatorView()  // ‚ö†Ô∏è Issue 4\n        indicator.startAnimating()\n\n        return repository.getProfile()\n    }\n}\n```\n\n### Review Report\n\n#### ‚ö†Ô∏è Critical Issues\n\n**1. UIKit imported in Domain layer at line 1**\n- **Problem**: Domain should be pure Swift\n- **Impact**: Violates Clean Architecture, ties business logic to UI framework\n- **Fix**: Remove `import UIKit`, Domain layer should never import UIKit\n\n**2. Data layer imported in Domain at line 3**\n- **Problem**: Dependency arrow points wrong direction\n- **Impact**: Violates Clean Architecture, creates circular dependency risk\n- **Fix**: Remove `import Data`, only import Domain\n\n**3. Concrete implementation type used at line 6**\n- **Problem**: Should depend on protocol, not concrete type\n- **Impact**: Tight coupling, can't mock for testing\n- **Fix**:\n```swift\nprivate let repository: ProfileRepositoryType  // Use protocol\n```\n\n**4. UI component in Domain layer at line 9**\n- **Problem**: Domain layer creating UI components\n- **Impact**: Violates layer separation\n- **Fix**: Remove UI logic, use `ActivityIndicator` from RxSwift or handle in ViewModel\n\n#### Corrected Version\n\n```swift\nimport RxSwift\n\npublic final class ProfileUseCase: ProfileUseCaseType {\n    private let repository: ProfileRepositoryType  // Protocol, not implementation\n    private let sessionUC: SessionUseCaseType\n\n    public init(repository: ProfileRepositoryType, sessionUC: SessionUseCaseType) {\n        self.repository = repository\n        self.sessionUC = sessionUC\n    }\n\n    public func execute() -> Single<Profile> {\n        return repository.getProfile()\n            .catchSessionError(sessionUC)\n    }\n}\n```\n\n#### üìã Summary\nFiles: 1 | üî¥ Critical: 4 | üü° Warning: 0 | üîµ Info: 0 | Status: ‚ùå Must fix before merge\n\n---\n\n## Example 4: ViewController Review (Good Practices)\n\n### File: TransactionHistoryViewController.swift\n\n```swift\nfinal class TransactionHistoryViewController: BaseViewController {\n    // MARK: - Dependencies\n    private let viewModel: TransactionHistoryViewModelType\n    private let navigator: TransactionHistoryNavigatorType\n\n    // MARK: - Properties\n    private let disposeBag = DisposeBag()\n\n    // MARK: - UI Components\n    @IBOutlet private weak var tableView: UITableView!\n    @IBOutlet private weak var emptyStateView: UIView!\n    private let refreshControl = UIRefreshControl()\n\n    // MARK: - Init\n    init(viewModel: TransactionHistoryViewModelType, navigator: TransactionHistoryNavigatorType) {\n        self.viewModel = viewModel\n        self.navigator = navigator\n        super.init(nibName: \"TransactionHistoryViewController\", bundle: nil)\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    // MARK: - Lifecycle\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        bindViewModel()\n    }\n\n    // MARK: - Setup\n    private func setupUI() {\n        title = \"Transaction History\"\n        tableView.refreshControl = refreshControl\n        tableView.register(UINib(nibName: \"TransactionCell\", bundle: nil),\n                          forCellReuseIdentifier: \"TransactionCell\")\n    }\n\n    // MARK: - Binding\n    private func bindViewModel() {\n        let input = TransactionHistoryViewModel.Input(\n            loadTrigger: rx.viewWillAppear.asDriver(),\n            refreshTrigger: refreshControl.rx.controlEvent(.valueChanged).asDriver(),\n            selectTrigger: tableView.rx.itemSelected.asDriver()\n        )\n\n        let output = viewModel.transform(input: input)\n\n        output.transactions\n            .drive(tableView.rx.items(cellIdentifier: \"TransactionCell\", cellType: TransactionCell.self)) { _, item, cell in\n                cell.configure(with: item)\n            }\n            .disposed(by: disposeBag)\n\n        output.isEmpty\n            .drive(emptyStateView.rx.isHidden)\n            .disposed(by: disposeBag)\n\n        output.isRefreshing\n            .drive(refreshControl.rx.isRefreshing)\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n### Review Report\n\n#### ‚úÖ Strengths\n\n**1. Clean MVVM Structure**\n- Clear separation: ViewController handles UI, ViewModel handles logic ‚úì\n- No business logic in ViewController ‚úì\n- All logic in bindViewModel() method ‚úì\n\n**2. Proper Memory Management**\n- DisposeBag declared and used ‚úì\n- All subscriptions disposed ‚úì\n- No strong self captures (using Driver which handles it) ‚úì\n\n**3. Dependency Injection**\n- Dependencies injected via constructor ‚úì\n- No direct instantiation ‚úì\n- Protocol types used ‚úì\n\n**4. Code Organization**\n- Proper MARK comments ‚úì\n- Logical method grouping ‚úì\n- Clear naming conventions ‚úì\n\n**5. RxSwift Best Practices**\n- Uses Driver for UI bindings ‚úì\n- Reactive control event handling ‚úì\n- Declarative binding style ‚úì\n\n#### ‚ÑπÔ∏è Minor Suggestions\n\n**1. Consider extracting cell configuration**\n```swift\n// Current (inline)\n.drive(tableView.rx.items(cellIdentifier: \"TransactionCell\", cellType: TransactionCell.self)) { _, item, cell in\n    cell.configure(with: item)\n}\n\n// Alternative (extracted method)\n.drive(tableView.rx.items(cellIdentifier: \"TransactionCell\", cellType: TransactionCell.self)) { [weak self] _, item, cell in\n    self?.configure(cell: cell, with: item)\n}\n\nprivate func configure(cell: TransactionCell, with item: Transaction) {\n    cell.configure(with: item)\n    // More complex configuration if needed\n}\n```\n\n**2. Add pull-to-refresh haptic feedback**\n```swift\noutput.isRefreshing\n    .filter { !$0 }  // When refresh completes\n    .drive(onNext: { _ in\n        UIImpactFeedbackGenerator(style: .light).impactOccurred()\n    })\n    .disposed(by: disposeBag)\n```\n\n#### üìã Summary\nFiles: 1 | üî¥ Critical: 0 | üü° Warning: 0 | üîµ Info: 2 | Status: ‚úÖ Excellent! Ready to merge\n\n---\n\n## Example 5: SwiftLint Violations\n\n### File: OrderSummaryViewModel.swift\n\n```swift\nfinal class OrderSummaryViewModel: ViewModelType {\n    func calculateTotal(items: [Item]) -> Double {\n        var total: Double = 0\n        if items.count > 0 {  // ‚ö†Ô∏è empty_count violation\n            for item in items {\n                total += item.price\n            }\n        }\n        return total\n    }\n\n    func validateCoupon(code: String) -> Bool {\n        if 3 == code.count {  // ‚ö†Ô∏è yoda_condition violation\n            return true\n        }\n        return false\n    }\n\n    func createView() -> UIView {\n        let view = UIView.init()  // ‚ö†Ô∏è explicit_init violation\n        return view\n    }\n\n    // TODO: fix this later  // ‚ö†Ô∏è todo violation (not tracked)\n}\n```\n\n### Review Report\n\n#### ‚ö†Ô∏è SwiftLint Violations\n\n**1. empty_count violation at line 4**\n- **Rule**: Use `.isEmpty` instead of `.count > 0`\n- **Fix**:\n```swift\nif !items.isEmpty {  // Preferred\n    // ...\n}\n```\n\n**2. yoda_condition violation at line 12**\n- **Rule**: Constant should be on right side\n- **Fix**:\n```swift\nif code.count == 3 {  // Correct order\n    return true\n}\n```\n\n**3. explicit_init violation at line 19**\n- **Rule**: Remove explicit `.init()` call\n- **Fix**:\n```swift\nlet view = UIView()  // Implicit init preferred\n```\n\n**4. todo violation at line 23**\n- **Rule**: TODO comments should reference a ticket\n- **Fix**:\n```swift\n// TODO: [PAYOO-789] Implement coupon validation with backend\n```\n\n#### üìã SwiftLint Command\n\nRun to check:\n```bash\n./Pods/SwiftLint/swiftlint lint --path \"PayooMerchant/OrderSummaryViewModel.swift\"\n```\n\n#### üìã Summary\n- **SwiftLint violations**: 4\n- **Status**: ‚ö†Ô∏è Fix violations before merge\n\n---\n\n## Example 6: Memory Leak Detection\n\n### File: ImagePickerViewModel.swift\n\n```swift\nfinal class ImagePickerViewModel: ViewModelType {\n    private let imageService: ImageService\n    private let navigator: Navigator\n\n    func transform(input: Input) -> Output {\n        let images = input.selectTrigger\n            .flatMapLatest { [weak self] _ -> Observable<[UIImage]> in\n                guard let self = self else { return .empty() }\n                return self.imageService.fetchImages()\n                    .map { urls in\n                        return urls.compactMap { url in  // ‚ö†Ô∏è Issue 1\n                            let data = try? Data(contentsOf: url)\n                            return data.flatMap { UIImage(data: $0) }\n                        }\n                    }\n            }\n\n        input.uploadTrigger\n            .withLatestFrom(images)\n            .flatMapLatest { images -> Observable<Void> in\n                return self.imageService.upload(images: images)  // ‚ö†Ô∏è Issue 2\n            }\n            .subscribe()  // ‚ö†Ô∏è Issue 3\n\n        return Output(images: images.asDriver(onErrorJustReturn: []))\n    }\n}\n```\n\n### Review Report\n\n#### ‚ö†Ô∏è Critical Issues\n\n**1. Retain cycle in nested closure at line 10**\n- **Problem**: Inner closure captures `self` from outer closure\n- **Impact**: Memory leak, images stay in memory\n- **Detection**: Run Instruments ‚Üí Leaks tool\n- **Fix**:\n```swift\nreturn self.imageService.fetchImages()\n    .map { [weak self] urls in  // Add [weak self] here too!\n        guard let self = self else { return [] }\n        return urls.compactMap { url in\n            let data = try? Data(contentsOf: url)\n            return data.flatMap { UIImage(data: $0) }\n        }\n    }\n```\n\n**2. Strong self capture at line 19**\n- **Problem**: `self` captured strongly in closure\n- **Fix**:\n```swift\n.flatMapLatest { [weak self] images -> Observable<Void> in\n    guard let self = self else { return .empty() }\n    return self.imageService.upload(images: images)\n}\n```\n\n**3. Subscription never disposed at line 21**\n- **Problem**: Memory leak\n- **Fix**:\n```swift\nprivate let disposeBag = DisposeBag()\n\ninput.uploadTrigger\n    .withLatestFrom(images)\n    .flatMapLatest { [weak self] images -> Observable<Void> in\n        guard let self = self else { return .empty() }\n        return self.imageService.upload(images: images)\n    }\n    .subscribe()\n    .disposed(by: disposeBag)  // Add this!\n```\n\n#### üõ† Detection Commands\n\n**Find potential memory leaks:**\n```bash\n# Find closures without [weak self]\ngrep -r \"flatMapLatest\\|subscribe\" --include=\"*ViewModel.swift\" | grep -v \"\\[weak self\\]\"\n\n# Find subscriptions without disposal\ngrep -r \"\\.subscribe(\" --include=\"*ViewModel.swift\" | grep -v \"disposed(by:\"\n```\n\n**Run Instruments:**\n```bash\n# Profile for leaks\nxcodebuild -workspace PayooMerchant.xcworkspace \\\n  -scheme \"Payoo Merchant Sandbox\" \\\n  -destination 'platform=iOS Simulator,name=iPhone 15,arch=x86_64' \\\n  | xcpretty\n\n# Then: Xcode ‚Üí Product ‚Üí Profile ‚Üí Leaks\n```\n\n#### üìã Summary\n- **Critical issues**: 3 (all memory leaks)\n- **Detection tool**: Instruments (Leaks)\n- **Status**: ‚ùå Must fix before merge\n\n---\n\n## Example 7: Complete Feature Review\n\n### Files Reviewed\n- `PayooMerchant/Controllers/Withdrawal/WithdrawalViewModel.swift`\n- `PayooMerchant/Controllers/Withdrawal/WithdrawalViewController.swift`\n- `Domain/UseCase/Withdrawal/WithdrawalUseCase.swift`\n- `Data/Service/Remote/WithdrawalService.swift`\n\n### Review Report\n\n#### Architecture ‚úÖ\n- **Layer Separation**: Correct ‚úì\n- **Dependency Flow**: Presentation ‚Üí Domain ‚Üê Data ‚úì\n- **No violations**: Clean boundaries ‚úì\n\n#### MVVM Pattern ‚úÖ\n- **ViewModel**: Implements ViewModelType ‚úì\n- **Input/Output**: Properly defined ‚úì\n- **ViewController**: Only UI bindings ‚úì\n\n#### RxSwift ‚úÖ\n- **Memory Management**: All subscriptions disposed ‚úì\n- **Weak Self**: Properly used in closures ‚úì\n- **DisposeBag**: Present in all classes ‚úì\n\n#### Session Errors ‚úÖ\n- **API Calls**: All use `.catchSessionError()` ‚úì\n- **SessionUseCase**: Injected everywhere needed ‚úì\n\n#### Dependency Injection ‚úÖ\n- **Constructor Injection**: All dependencies injected ‚úì\n- **DependencyContainer**: Properly registered ‚úì\n- **Factory Methods**: Used for VC creation ‚úì\n\n#### SwiftLint ‚úÖ\n```bash\n$ ./Pods/SwiftLint/swiftlint lint --path \"PayooMerchant/Controllers/Withdrawal/\"\nLinting Swift files in current working directory\nDone linting! Found 0 violations, 0 serious in 2 files.\n```\n\n#### Tests ‚úÖ\n- **UseCase Tests**: 5 test cases ‚úì\n- **ViewModel Tests**: 3 test cases ‚úì\n- **Coverage**: 87% ‚úì\n\n#### üìã Final Summary\n- **Files reviewed**: 4\n- **Critical issues**: 0\n- **Warnings**: 0\n- **SwiftLint violations**: 0\n- **Test coverage**: 87%\n- **Status**: ‚úÖ Excellent! Approved for merge\n\n---\n\n## Example 8: Naming Convention Violations\n\n### File: PaymentViewModel.swift\n\n```swift\n// PaymentViewModel.swift\nimport Domain\nimport RxSwift\n\n// ‚ö†Ô∏è Issue 1: Wrong class name pattern\nfinal class PayVM: ViewModelType {\n    // ‚ö†Ô∏è Issue 2: Abbreviated variable names\n    private let pmtUC: PaymentUseCaseType\n    private let navgtr: PaymentNavigatorType\n    private let sesUC: SessionUseCaseType\n\n    // ‚ö†Ô∏è Issue 3: Non-descriptive variables\n    private let a: Int = 100\n    private let b: String = \"VND\"\n\n    // ‚ö†Ô∏è Issue 4: Wrong constant naming\n    private let MAXIMUM_AMOUNT = 50000000\n\n    struct Input {\n        let trigger: Driver<Void>\n    }\n\n    struct Output {\n        let res: Driver<Payment>  // ‚ö†Ô∏è Issue 5: Abbreviated\n    }\n\n    func transform(input: Input) -> Output {\n        // ‚ö†Ô∏è Issue 6: Single letter variable\n        let r = input.trigger\n            .flatMapLatest { [weak self] _ -> Observable<Payment> in\n                guard let self = self else { return .empty() }\n                return self.pmtUC.execute()\n            }\n        return Output(res: r.asDriver(onErrorJustReturn: nil))\n    }\n}\n```\n\n### Review Report\n\n#### üü° Naming Convention Violations\n\n**1. Wrong ViewModel class name** at PaymentViewModel.swift:5\n- **Problem**: Class named `PayVM` instead of `PaymentViewModel`\n- **Rule**: ViewModels must follow `[Feature]ViewModel` pattern\n- **Fix**:\n```swift\nfinal class PaymentViewModel: ViewModelType {\n```\n\n**2. Abbreviated variable names** at PaymentViewModel.swift:7-9\n- **Problem**: Variables use abbreviations (`pmtUC`, `navgtr`, `sesUC`)\n- **Rule**: Use full descriptive names, avoid abbreviations\n- **Fix**:\n```swift\nprivate let paymentUC: PaymentUseCaseType\nprivate let navigator: PaymentNavigatorType\nprivate let sessionUC: SessionUseCaseType\n```\n\n**3. Non-descriptive variable names** at PaymentViewModel.swift:12-13\n- **Problem**: Variables named `a` and `b`\n- **Rule**: Use descriptive names that indicate purpose\n- **Fix**:\n```swift\nprivate let minimumAmount: Int = 100\nprivate let currency: String = \"VND\"\n```\n\n**4. Wrong constant naming** at PaymentViewModel.swift:16\n- **Problem**: All caps constant `MAXIMUM_AMOUNT`\n- **Rule**: Use camelCase or `k` prefix for constants\n- **Fix**:\n```swift\nprivate let maximumAmount = 50_000_000\n// or\nprivate let kMaximumAmount = 50_000_000\n```\n\n**5. Abbreviated Output property** at PaymentViewModel.swift:23\n- **Problem**: Property named `res` instead of `result`\n- **Fix**:\n```swift\nstruct Output {\n    let result: Driver<Payment>\n}\n```\n\n**6. Single letter variable** at PaymentViewModel.swift:28\n- **Problem**: Variable named `r` instead of descriptive name\n- **Rule**: Avoid single letters except in loops\n- **Fix**:\n```swift\nlet paymentResult = input.trigger\n    .flatMapLatest { [weak self] _ -> Observable<Payment> in\n        guard let self = self else { return .empty() }\n        return self.paymentUC.execute()\n    }\n\nreturn Output(result: paymentResult.asDriver(onErrorJustReturn: nil))\n```\n\n#### Corrected Version\n\n```swift\nfinal class PaymentViewModel: ViewModelType {\n    private let paymentUC: PaymentUseCaseType\n    private let navigator: PaymentNavigatorType\n    private let sessionUC: SessionUseCaseType\n\n    private let minimumAmount: Int = 100\n    private let currency: String = \"VND\"\n    private let maximumAmount = 50_000_000\n\n    private let disposeBag = DisposeBag()\n\n    init(\n        paymentUC: PaymentUseCaseType,\n        navigator: PaymentNavigatorType,\n        sessionUC: SessionUseCaseType\n    ) {\n        self.paymentUC = paymentUC\n        self.navigator = navigator\n        self.sessionUC = sessionUC\n    }\n\n    struct Input {\n        let trigger: Driver<Void>\n    }\n\n    struct Output {\n        let result: Driver<Payment>\n    }\n\n    func transform(input: Input) -> Output {\n        let paymentResult = input.trigger\n            .flatMapLatest { [weak self] _ -> Observable<Payment> in\n                guard let self = self else { return .empty() }\n                return self.paymentUC.execute()\n                    .catchSessionError(self.sessionUC)\n            }\n\n        return Output(result: paymentResult.asDriver(onErrorJustReturn: nil))\n    }\n}\n```\n\n#### üìã Summary\nFiles: 1 | üî¥ Critical: 0 | üü° Warning: 6 | üîµ Info: 0 | Status: ‚ö†Ô∏è Fix naming violations before merge\n\n#### Naming Convention Quick Reference\n\n**Classes:**\n- ‚úÖ `LoginViewModel`, `TransactionHistoryViewModel`\n- ‚úÖ `LoginViewController`, `HomeViewController`\n- ‚úÖ `GetProfileUseCase`, `LoginUseCase`\n- ‚úÖ `LoginNavigator`, `HomeNavigator`\n- ‚ùå `LoginVM`, `TxHistVM`, `GetProfUC`\n\n**Protocols:**\n- ‚úÖ `ViewModelType`, `UseCaseType`\n- ‚úÖ `LoginViewModelType`, `GetProfileUseCaseType`\n- ‚ùå `LoginVMType`, `GetProfUCType`\n\n**Variables:**\n- ‚úÖ `username`, `transactionId`, `isLoading`\n- ‚úÖ `paymentItems`, `selectedBankAccount`\n- ‚ùå `usrNm`, `txId`, `a`, `b`, `flag`\n\n**Constants:**\n- ‚úÖ `pageSize`, `animationDuration`, `kMaxRetryCount`\n- ‚ùå `PAGE_SIZE`, `ANIMATION_DURATION`\n\n---\n\n## Quick Check Commands\n\n### Find Missing catchSessionError\n```bash\ngrep -r \"apiService\\.\" --include=\"*.swift\" PayooMerchant Domain | grep -v \"catchSessionError\"\n```\n\n### Find Files Without DisposeBag\n```bash\nfind PayooMerchant -name \"*ViewModel.swift\" -exec grep -L \"DisposeBag\" {} \\;\n```\n\n### Find Strong Self in Closures\n```bash\ngrep -r \"\\.subscribe\\|\\.flatMapLatest\\|\\.flatMap\" --include=\"*ViewModel.swift\" | grep -v \"\\[weak self\\]\\|\\[unowned self\\]\"\n```\n\n### Run SwiftLint\n```bash\n./Pods/SwiftLint/swiftlint lint --reporter xcode\n```\n\n### Check Layer Imports\n```bash\n# Check if Domain imports Data (violation)\ngrep -r \"import Data\" Domain/\n\n# Check if Domain imports UIKit (violation)\ngrep -r \"import UIKit\" Domain/\n```\n\n### Find TODOs\n```bash\ngrep -rn \"TODO\\|FIXME\" PayooMerchant Domain Data Analytics\n```\n",
        "py-plugin/skills/payoo-ios-code-review/standards.md": "# Payoo iOS Coding Standards\n\nDetailed coding standards and rules for the Payoo Merchant iOS app.\n\n## Architecture Standards\n\n### Clean Architecture Layers\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Presentation (PayooMerchant)     ‚îÇ  ‚Üê ViewControllers, ViewModels, UI\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Domain                            ‚îÇ  ‚Üê UseCases, Entities, Protocols\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Data                              ‚îÇ  ‚Üê API, Realm, Services Implementation\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   Analytics                         ‚îÇ  ‚Üê Firebase tracking\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Import Rules:**\n- ‚úì Presentation can import: Domain, Analytics\n- ‚úì Data can import: Domain\n- ‚úì Domain imports: Nothing (pure Swift + RxSwift)\n- ‚úó NEVER: Domain imports Data/Presentation\n- ‚úó NEVER: Data imports Presentation\n\n### MVVM Pattern\n\n**ViewModelType Protocol:**\n```swift\nprotocol ViewModelType {\n    associatedtype Input\n    associatedtype Output\n    func transform(input: Input) -> Output\n}\n```\n\n**ViewModel Structure:**\n```swift\nfinal class FeatureViewModel: ViewModelType {\n    // MARK: - Dependencies (injected)\n    private let useCase: UseCaseType\n    private let navigator: NavigatorType\n    private let sessionUC: SessionUseCaseType\n\n    // MARK: - Properties\n    private let disposeBag = DisposeBag()\n\n    // MARK: - Init\n    init(useCase: UseCaseType, navigator: NavigatorType, sessionUC: SessionUseCaseType) {\n        self.useCase = useCase\n        self.navigator = navigator\n        self.sessionUC = sessionUC\n    }\n\n    // MARK: - Input/Output\n    struct Input {\n        let trigger: Driver<Void>\n    }\n\n    struct Output {\n        let result: Driver<DataType>\n    }\n\n    // MARK: - Transform\n    func transform(input: Input) -> Output {\n        // Implementation\n    }\n}\n```\n\n**ViewController Structure:**\n```swift\nfinal class FeatureViewController: BaseViewController {\n    // MARK: - Dependencies (injected)\n    private let viewModel: FeatureViewModelType\n    private let navigator: NavigatorType\n\n    // MARK: - Properties\n    private let disposeBag = DisposeBag()\n\n    // MARK: - UI Components\n    @IBOutlet private weak var tableView: UITableView!\n\n    // MARK: - Init\n    init(viewModel: FeatureViewModelType, navigator: NavigatorType) {\n        self.viewModel = viewModel\n        self.navigator = navigator\n        super.init(nibName: nil, bundle: nil)\n    }\n\n    // MARK: - Lifecycle\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        bindViewModel()\n    }\n\n    // MARK: - Setup\n    private func setupUI() {\n        // UI setup\n    }\n\n    // MARK: - Binding\n    private func bindViewModel() {\n        let input = FeatureViewModel.Input(\n            trigger: rx.viewWillAppear.asDriver()\n        )\n        let output = viewModel.transform(input: input)\n\n        output.result\n            .drive(tableView.rx.items(cellIdentifier: \"Cell\")) { _, item, cell in\n                // Configure cell\n            }\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n## RxSwift Standards\n\n### Observable Types\n\n**Driver** - UI bindings (main thread, never errors):\n```swift\nlet username: Driver<String> = usernameTextField.rx.text\n    .orEmpty\n    .asDriver(onErrorJustReturn: \"\")\n```\n\n**Single** - One-time operations:\n```swift\nfunc login(username: String, password: String) -> Single<User> {\n    return apiService.login(username: username, password: password)\n        .catchSessionError(sessionUC)\n}\n```\n\n**Observable** - Streams:\n```swift\nlet searchResults: Observable<[Result]> = searchTextField.rx.text\n    .debounce(.milliseconds(300), scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        return self.searchUC.search(query: query)\n    }\n```\n\n**Maybe** - Optional single value:\n```swift\nfunc getProfile() -> Maybe<Profile> {\n    return apiService.getProfile()\n        .catchSessionError(sessionUC)\n}\n```\n\n### Memory Management\n\n**Always use [weak self]:**\n```swift\n// ‚úì CORRECT\nobservable\n    .subscribe(onNext: { [weak self] value in\n        self?.updateUI(value)\n    })\n    .disposed(by: disposeBag)\n\n// ‚úó WRONG - Retain cycle!\nobservable\n    .subscribe(onNext: { value in\n        self.updateUI(value)\n    })\n    .disposed(by: disposeBag)\n```\n\n**flatMapLatest with weak self:**\n```swift\n// ‚úì CORRECT\ninput.trigger\n    .flatMapLatest { [weak self] _ -> Observable<Data> in\n        guard let self = self else { return .empty() }\n        return self.useCase.execute()\n    }\n\n// ‚úó WRONG - Memory leak!\ninput.trigger\n    .flatMapLatest { _ in\n        return self.useCase.execute()\n    }\n```\n\n**DisposeBag required:**\n```swift\n// ‚úì CORRECT\nprivate let disposeBag = DisposeBag()\n\nobservable.subscribe(onNext: { _ in })\n    .disposed(by: disposeBag)\n\n// ‚úó WRONG - Subscription never disposed!\nobservable.subscribe(onNext: { _ in })\n```\n\n### Session Error Handling\n\n**CRITICAL RULE**: All API calls MUST use `.catchSessionError(sessionUC)`\n\n```swift\n// ‚úì CORRECT\nfunc getData() -> Observable<Data> {\n    return apiService.getData()\n        .catchSessionError(sessionUC)\n}\n\n// ‚úó WRONG - Session errors not handled!\nfunc getData() -> Observable<Data> {\n    return apiService.getData()\n}\n```\n\n**Why this matters:**\n- Session timeout ‚Üí Auto logout\n- Invalid token ‚Üí Force re-login\n- Force update ‚Üí Block app usage\n\n## Dependency Injection (Swinject)\n\n### Registration in DependencyContainer\n\n```swift\n// Register UseCase\ncontainer.register(FeatureUseCaseType.self) { resolver in\n    let apiService = resolver.resolve(ApiService.self)!\n    let sessionUC = resolver.resolve(SessionUseCaseType.self)!\n    return FeatureUseCase(apiService: apiService, sessionUC: sessionUC)\n}\n\n// Register ViewModel\ncontainer.register(FeatureViewModelType.self) { resolver in\n    let useCase = resolver.resolve(FeatureUseCaseType.self)!\n    let navigator = resolver.resolve(NavigatorType.self)!\n    let sessionUC = resolver.resolve(SessionUseCaseType.self)!\n    return FeatureViewModel(useCase: useCase, navigator: navigator, sessionUC: sessionUC)\n}\n```\n\n### Usage\n\n```swift\n// ‚úì CORRECT - Use DependencyContainer\nlet viewModel = DependencyContainer.shared.provide(FeatureViewModelType.self)\n\n// ‚úó WRONG - Direct instantiation\nlet viewModel = FeatureViewModel(useCase: useCase, navigator: navigator, sessionUC: sessionUC)\n```\n\n### ViewControllerFactory\n\n```swift\n// ‚úì CORRECT - Use factory\nprotocol ViewControllerFactory {\n    func makeFeatureViewController() -> FeatureViewController\n}\n\nextension DependencyContainer: ViewControllerFactory {\n    func makeFeatureViewController() -> FeatureViewController {\n        let viewModel = provide(FeatureViewModelType.self)\n        let navigator = provide(FeatureNavigatorType.self)\n        return FeatureViewController(viewModel: viewModel, navigator: navigator)\n    }\n}\n\n// Usage\nlet vc = DependencyContainer.shared.makeFeatureViewController()\n\n// ‚úó WRONG - Direct instantiation\nlet vc = FeatureViewController(viewModel: viewModel, navigator: navigator)\n```\n\n## Navigation Standards\n\n### Navigator Pattern\n\n```swift\nenum FeatureDestination {\n    case detail(id: String)\n    case settings\n    case back\n}\n\nprotocol FeatureNavigatorType {\n    func navigate(to destination: FeatureDestination)\n}\n\nfinal class FeatureNavigator: FeatureNavigatorType {\n    private weak var navigationController: UINavigationController?\n    private let factory: ViewControllerFactory\n\n    init(navigationController: UINavigationController?, factory: ViewControllerFactory) {\n        self.navigationController = navigationController\n        self.factory = factory\n    }\n\n    func navigate(to destination: FeatureDestination) {\n        switch destination {\n        case .detail(let id):\n            let vc = factory.makeDetailViewController(id: id)\n            navigationController?.pushViewController(vc, animated: true)\n        case .settings:\n            let vc = factory.makeSettingsViewController()\n            navigationController?.pushViewController(vc, animated: true)\n        case .back:\n            navigationController?.popViewController(animated: true)\n        }\n    }\n}\n```\n\n### Usage in ViewModel\n\n```swift\nfunc transform(input: Input) -> Output {\n    input.detailTrigger\n        .drive(onNext: { [weak self] id in\n            self?.navigator.navigate(to: .detail(id: id))\n        })\n        .disposed(by: disposeBag)\n\n    return Output()\n}\n```\n\n## UseCase Standards\n\n### Protocol Definition\n\n```swift\npublic protocol FeatureUseCaseType {\n    func execute(param: String) -> Single<Result>\n    func refresh() -> Observable<[Item]>\n}\n```\n\n### Implementation\n\n```swift\npublic final class FeatureUseCase: FeatureUseCaseType {\n    private let apiService: ApiService\n    private let sessionUC: SessionUseCaseType\n\n    public init(apiService: ApiService, sessionUC: SessionUseCaseType) {\n        self.apiService = apiService\n        self.sessionUC = sessionUC\n    }\n\n    public func execute(param: String) -> Single<Result> {\n        return apiService.getData(param: param)\n            .catchSessionError(sessionUC)\n    }\n\n    public func refresh() -> Observable<[Item]> {\n        return apiService.getItems()\n            .catchSessionError(sessionUC)\n    }\n}\n```\n\n### UseCase Composition\n\nViewModels compose multiple UseCases:\n\n```swift\nfinal class FeatureViewModel: ViewModelType {\n    private let profileUC: ProfileUseCaseType\n    private let itemsUC: ItemsUseCaseType\n    private let analyticsUC: AnalyticsUseCaseType\n\n    func transform(input: Input) -> Output {\n        let data = Observable.combineLatest(\n            profileUC.getProfile(),\n            itemsUC.getItems()\n        ).map { profile, items in\n            return (profile, items)\n        }\n\n        return Output(data: data.asDriver(onErrorJustReturn: (nil, [])))\n    }\n}\n```\n\n## SwiftLint Rules\n\n### Enabled Opt-in Rules\n\n- `empty_count` - Use `.isEmpty` instead of `.count == 0`\n- `closure_spacing` - Proper spacing in closures\n- `closure_end_indentation` - Align closing braces\n- `yoda_condition` - Constant on right side: `x == 5` not `5 == x`\n- `implicit_return` - Can omit return in single-expression closures\n- `modifier_order` - Consistent modifier order\n- `todo` - Track TODO/FIXME comments\n\n### Limits\n\n- **Type body length**: 300 (warning), 400 (error)\n- **File length**: 800 (warning), 1200 (error)\n- **Type name**: 60 (warning), 80 (error)\n- **Line length**: Disabled (flexible)\n\n### Common Violations\n\n```swift\n// ‚úó WRONG - empty_count\nif array.count == 0 { }\n\n// ‚úì CORRECT\nif array.isEmpty { }\n\n// ‚úó WRONG - yoda_condition\nif 5 == x { }\n\n// ‚úì CORRECT\nif x == 5 { }\n\n// ‚úó WRONG - todo without tracking\n// TODO: fix this\n\n// ‚úì CORRECT\n// TODO: [PAYOO-123] Fix authentication timeout\n\n// ‚úó WRONG - explicit_init\nlet view = UIView.init()\n\n// ‚úì CORRECT\nlet view = UIView()\n```\n\n## Naming Conventions\n\n### Classes\n\n```swift\n// ViewModels\nLoginViewModel\nTransactionHistoryViewModel\nSettingsViewModel\n\n// ViewControllers\nLoginViewController\nTransactionHistoryViewController\nSettingsViewController\n\n// UseCases\nLoginUseCase\nGetProfileUseCase\nUpdateSettingsUseCase\n\n// Services (Protocols)\nApiService\nLocalStorageService\nAnalyticsService\n\n// Services (Implementations)\nDefaultApiService\nRealmStorageService\nFirebaseAnalyticsService\n```\n\n### Protocols\n\n```swift\n// Type suffix for main protocols\nViewModelType\nUseCaseType\nNavigatorType\n\n// Specific protocols\nFeatureViewModelType\nFeatureUseCaseType\nFeatureNavigatorType\n```\n\n### Variables\n\n```swift\n// Use descriptive names\nlet transactionItems: [TransactionItem]\nlet isLoading: Bool\nlet errorMessage: String\n\n// Avoid abbreviations\nlet usrNm: String  // ‚úó WRONG\nlet username: String  // ‚úì CORRECT\n\n// RxSwift subjects\nprivate let loadTrigger = PublishSubject<Void>()\nprivate let selectedItem = BehaviorSubject<Item?>(value: nil)\n```\n\n### Constants\n\n```swift\n// Global constants\nlet kMaxRetryCount = 3\nlet kDefaultTimeout: TimeInterval = 30\n\n// Local constants\nprivate let pageSize = 20\nprivate let animationDuration: TimeInterval = 0.3\n```\n\n## Common Patterns\n\n### Data Collector Pattern\n\nFor multi-step flows:\n\n```swift\nstruct WithdrawalDataCollector {\n    var bankAccount: BankAccount?\n    var amount: String?\n    var otp: String?\n}\n\n// Pass through navigation\nnavigator.navigate(to: .enterAmount(collector: collector))\n```\n\n### Loading State Pattern\n\n```swift\nenum LoadingState<T> {\n    case idle\n    case loading\n    case loaded(T)\n    case error(Error)\n}\n\n// In ViewModel\nlet state: Driver<LoadingState<Data>>\n```\n\n### Error Handling Pattern\n\n```swift\n// In ViewModel\ninput.trigger\n    .flatMapLatest { [weak self] _ -> Driver<Result> in\n        guard let self = self else { return .empty() }\n        return self.useCase.execute()\n            .catchSessionError(self.sessionUC)\n            .asDriver(onErrorJustReturn: .failure(.unknown))\n    }\n```\n\n## Testing Standards\n\n### UseCase Tests\n\n```swift\nfinal class FeatureUseCaseTests: XCTestCase {\n    var sut: FeatureUseCase!\n    var mockApiService: MockApiService!\n    var mockSessionUC: MockSessionUseCase!\n\n    override func setUp() {\n        super.setUp()\n        mockApiService = MockApiService()\n        mockSessionUC = MockSessionUseCase()\n        sut = FeatureUseCase(apiService: mockApiService, sessionUC: mockSessionUC)\n    }\n\n    func testExecute_Success() {\n        // Given\n        let expectedResult = Result.success\n        mockApiService.stub = .just(expectedResult)\n\n        // When\n        let result = sut.execute(param: \"test\").toBlocking().materialize()\n\n        // Then\n        XCTAssertEqual(result, .completed(expectedResult))\n    }\n}\n```\n\n### ViewModel Tests\n\n```swift\nfinal class FeatureViewModelTests: XCTestCase {\n    var sut: FeatureViewModel!\n    var mockUseCase: MockFeatureUseCase!\n    var mockNavigator: MockNavigator!\n\n    func testTransform_LoadsData() {\n        // Given\n        let expectedData = [Item()]\n        mockUseCase.stub = .just(expectedData)\n\n        let input = FeatureViewModel.Input(\n            trigger: .just(())\n        )\n\n        // When\n        let output = sut.transform(input: input)\n\n        // Then\n        let result = output.data.toBlocking().first()\n        XCTAssertEqual(result, expectedData)\n    }\n}\n```\n\n## Security Standards\n\n### Sensitive Data\n\n```swift\n// ‚úó WRONG - Logging sensitive data\nprint(\"Password: \\(password)\")\n\n// ‚úì CORRECT\nprint(\"Login attempt\")\n\n// ‚úó WRONG - Storing passwords\nUserDefaults.standard.set(password, forKey: \"password\")\n\n// ‚úì CORRECT - Use Keychain\nKeychainService.save(password, forKey: \"password\")\n```\n\n### API Keys\n\n```swift\n// ‚úó WRONG - Hardcoded keys\nlet apiKey = \"abc123xyz\"\n\n// ‚úì CORRECT - Use build configuration\nlet apiKey = Bundle.main.infoDictionary?[\"API_KEY\"] as? String\n```\n\n## Performance Standards\n\n### Avoid Unnecessary Computations\n\n```swift\n// ‚úó WRONG - Computing in every cell\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let item = items[indexPath.row]\n    let formattedDate = DateFormatter().string(from: item.date)  // Creates formatter every time!\n    cell.dateLabel.text = formattedDate\n    return cell\n}\n\n// ‚úì CORRECT - Reuse formatter\nprivate let dateFormatter: DateFormatter = {\n    let formatter = DateFormatter()\n    formatter.dateStyle = .medium\n    return formatter\n}()\n\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let item = items[indexPath.row]\n    cell.dateLabel.text = dateFormatter.string(from: item.date)\n    return cell\n}\n```\n\n### Image Loading\n\n```swift\n// ‚úì CORRECT - Use Kingfisher\nimageView.kf.setImage(with: URL(string: imageUrl))\n\n// Configure caching\nKingfisherManager.shared.cache.maxDiskCacheSize = 100 * 1024 * 1024  // 100MB\n```\n\n### Debouncing\n\n```swift\n// Search with debounce\nsearchTextField.rx.text\n    .debounce(.milliseconds(300), scheduler: MainScheduler.instance)\n    .distinctUntilChanged()\n    .flatMapLatest { query in\n        return self.searchUC.search(query: query)\n    }\n```\n\n## Documentation Standards\n\n### Header Comments\n\n```swift\n//\n//  FeatureViewModel.swift\n//  PayooMerchant\n//\n//  Created by Developer Name on 2024-01-01.\n//  Copyright ¬© 2024 VietUnion. All rights reserved.\n//\n```\n\n### MARK Comments\n\n```swift\n// MARK: - Properties\n// MARK: - Init\n// MARK: - Lifecycle\n// MARK: - Setup\n// MARK: - Binding\n// MARK: - Actions\n// MARK: - Private Methods\n```\n\n### TODO/FIXME\n\n```swift\n// TODO: [PAYOO-123] Implement pagination\n// FIXME: [PAYOO-456] Fix memory leak in subscription\n// NOTE: This is a temporary workaround for iOS 12 compatibility\n```\n",
        "py-plugin/skills/rxswift-memory-check/SKILL.md": "---\nname: rxswift-memory-check\ndescription: Quick RxSwift memory leak detection for iOS. Finds missing dispose bags, retain cycles, and strong self references. Use when debugging memory issues, checking Observable subscriptions, or investigating retain cycles in RxSwift code.\nallowed-tools: Read, Grep, Glob\n---\n\n# RxSwift Memory Leak Detector\n\nFast, focused check for RxSwift memory management issues in iOS code.\n\n## When to Activate\n\n- \"memory leak\", \"retain cycle\", \"dispose bag\"\n- \"RxSwift memory issues\", \"check subscriptions\"\n- \"[weak self]\", \"memory management\"\n- Debugging memory problems or crashes\n\n## Quick Check Process\n\n### Step 1: Find RxSwift Subscriptions\n\nUse Grep to locate all Observable subscriptions:\n- Pattern: `\\.subscribe\\(`\n- Check surrounding code for proper disposal\n\n### Step 2: Verify Each Subscription\n\nFor every `.subscribe(`:\n1. ‚úÖ Has `.disposed(by: disposeBag)`\n2. ‚úÖ Uses `[weak self]` or `[unowned self]` in closures\n3. ‚úÖ DisposeBag is a property, not local variable\n\n### Step 3: Check Common Patterns\n\n#### üî¥ Pattern 1: Missing Disposal\n```swift\nviewModel.data\n    .subscribe(onNext: { data in })\n    // MISSING: .disposed(by: disposeBag)\n```\n\n#### üî¥ Pattern 2: Retain Cycle\n```swift\nviewModel.data\n    .subscribe(onNext: { data in\n        self.updateUI(data)  // Strong self!\n    })\n```\n\n#### üî¥ Pattern 3: Local DisposeBag\n```swift\nfunc loadData() {\n    let disposeBag = DisposeBag()  // Local variable!\n    // Cancels immediately when function ends\n}\n```\n\n### Step 4: Generate Report\n\nFocused report with:\n- Critical issues by severity\n- File locations and line numbers\n- Current vs. fixed code\n- Impact assessment\n- Recommended fixes\n\n## Search Patterns\n\n### Find subscriptions without disposal\n```\nPattern: \\.subscribe\\(\nContext: Check next 5 lines for .disposed\n```\n\n### Find strong self references\n```\nPattern: subscribe.*\\{[^[]*self\\.\nContext: -A 3 -B 1\n```\n\n### Find local DisposeBag declarations\n```\nPattern: let disposeBag = DisposeBag\\(\\)\n```\n\n## Output Format\n\n```markdown\n# RxSwift Memory Check Report\n\n## Critical Issues: X\n\n### 1. Missing Disposal - MEMORY LEAK\n**File**: `PaymentViewModel.swift:45`\n**Risk**: Memory accumulation, eventual crash\n\n**Current**:\n```swift\n// Missing disposal\n```\n\n**Fix**:\n```swift\n.disposed(by: disposeBag)\n```\n\n**Impact**: [Explanation]\n\n---\n\n## Summary\nüî¥ Critical: X (memory leaks/retain cycles)\n‚ö†Ô∏è  Warnings: X (could use weak self)\n\n## Files Status\n‚úÖ Clean files\n‚ö†Ô∏è  Files with warnings\nüî¥ Files with critical issues\n```\n\n## DisposeBag Best Practices\n\n‚úÖ **Correct**: Property-level DisposeBag\n```swift\nclass ViewModel {\n    private let disposeBag = DisposeBag()\n}\n```\n\n‚ùå **Wrong**: Local DisposeBag\n```swift\nfunc loadData() {\n    let disposeBag = DisposeBag()  // Cancels immediately!\n}\n```\n\n## When to Use `weak` vs `unowned`\n\n- **Default**: Always use `[weak self]` (safer)\n- **Rare**: Use `[unowned self]` only if 100% sure self outlives subscription\n\n## Quick Fix Guide\n\n1. **Add Missing Disposal**: `.disposed(by: disposeBag)`\n2. **Add Weak Self**: `[weak self]` in closure\n3. **Move DisposeBag**: To property level\n\n## Testing the Fix\n\nSuggest verification:\n1. Run Instruments with Leaks template\n2. Navigate to/from screens multiple times\n3. Check Debug Memory Graph for cycles\n4. Verify view controllers deallocate\n\n## Reference\n\n**Detailed Examples**: See `examples.md` for extensive code samples and scenarios.\n",
        "py-plugin/skills/rxswift-memory-check/examples.md": "# RxSwift Memory Check Examples\n\nDetailed examples of memory leaks, retain cycles, and proper RxSwift memory management.\n\n## Critical Issue Examples\n\n### Example 1: Missing Disposal (Memory Leak)\n\n#### ‚ùå Problem Code\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let paymentUC: PaymentUseCase\n    private let disposeBag = DisposeBag()\n\n    func processPayment() {\n        paymentUC.execute(amount: paymentAmount.value)\n            .subscribe(onNext: { [weak self] result in\n                self?.handleResult(result)\n            })\n            // ‚ùå MISSING: .disposed(by: disposeBag)\n    }\n}\n```\n\n**Problem**: Subscription never releases, accumulates in memory\n**Impact**: Memory grows over time, eventually crashes app\n**Symptoms**: Increasing memory usage, app slowdown\n\n#### ‚úÖ Fixed Code\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    private let paymentUC: PaymentUseCase\n    private let disposeBag = DisposeBag()\n\n    func processPayment() {\n        paymentUC.execute(amount: paymentAmount.value)\n            .subscribe(onNext: { [weak self] result in\n                self?.handleResult(result)\n            })\n            .disposed(by: disposeBag)  // ‚úÖ Added\n    }\n}\n```\n\n**Fix**: Add `.disposed(by: disposeBag)` to every subscription\n**Result**: Subscription properly cleaned up when ViewModel deallocates\n\n---\n\n### Example 2: Retain Cycle (Strong Self Reference)\n\n#### ‚ùå Problem Code\n```swift\nclass StoresViewModel: BaseViewModel<StoresState> {\n    private let storesUC: StoresUseCase\n    private let disposeBag = DisposeBag()\n\n    let stores = BehaviorRelay<[Store]>(value: [])\n\n    func loadStores() {\n        storesUC.getStores()\n            .subscribe(onNext: { stores in\n                // ‚ùå Strong self reference - retain cycle!\n                self.stores.accept(stores)\n            })\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n**Problem**: Closure captures self strongly, creating retain cycle\n**Impact**: ViewModel never deallocates, memory leak\n**Symptoms**: View controllers don't deallocate, memory grows\n**Detection**: Xcode Debug Memory Graph shows cycle\n\n#### ‚úÖ Fixed Code\n```swift\nclass StoresViewModel: BaseViewModel<StoresState> {\n    private let storesUC: StoresUseCase\n    private let disposeBag = DisposeBag()\n\n    let stores = BehaviorRelay<[Store]>(value: [])\n\n    func loadStores() {\n        storesUC.getStores()\n            .subscribe(onNext: { [weak self] stores in\n                // ‚úÖ Weak self - no retain cycle\n                self?.stores.accept(stores)\n            })\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n**Fix**: Use `[weak self]` in closure capture list\n**Result**: ViewModel can deallocate properly, no memory leak\n\n---\n\n### Example 3: Local DisposeBag (Early Cancellation)\n\n#### ‚ùå Problem Code\n```swift\nclass TransactionViewModel: BaseViewModel<TransactionState> {\n    func loadTransactions() {\n        let disposeBag = DisposeBag()  // ‚ùå Local variable!\n\n        transactionUC.getTransactions()\n            .subscribe(onNext: { [weak self] transactions in\n                self?.handleTransactions(transactions)\n            })\n            .disposed(by: disposeBag)\n\n        // ‚ùå disposeBag deallocates here, cancels subscription immediately!\n    }\n}\n```\n\n**Problem**: DisposeBag deallocates when function exits, canceling subscription\n**Impact**: Observable never completes, callbacks never fire\n**Symptoms**: Data doesn't load, UI doesn't update\n\n#### ‚úÖ Fixed Code\n```swift\nclass TransactionViewModel: BaseViewModel<TransactionState> {\n    private let disposeBag = DisposeBag()  // ‚úÖ Property\n\n    func loadTransactions() {\n        transactionUC.getTransactions()\n            .subscribe(onNext: { [weak self] transactions in\n                self?.handleTransactions(transactions)\n            })\n            .disposed(by: disposeBag)  // ‚úÖ Uses property\n    }\n}\n```\n\n**Fix**: Make DisposeBag a class property, not local variable\n**Result**: Subscription lives as long as the ViewModel\n\n---\n\n### Example 4: Multiple DisposeBags (Anti-Pattern)\n\n#### ‚ùå Problem Code\n```swift\nclass DashboardViewModel: BaseViewModel<DashboardState> {\n    private var searchDisposeBag = DisposeBag()  // ‚ùå Anti-pattern\n    private var dataDisposeBag = DisposeBag()    // ‚ùå Anti-pattern\n    private var uiDisposeBag = DisposeBag()      // ‚ùå Anti-pattern\n\n    func search(query: String) {\n        searchService.search(query)\n            .subscribe(onNext: { results in })\n            .disposed(by: searchDisposeBag)\n    }\n\n    func loadData() {\n        dataService.loadData()\n            .subscribe(onNext: { data in })\n            .disposed(by: dataDisposeBag)\n    }\n}\n```\n\n**Problem**: Unnecessary complexity, harder to manage subscriptions\n**Impact**: Confusing code, potential for errors\n\n#### ‚úÖ Fixed Code\n```swift\nclass DashboardViewModel: BaseViewModel<DashboardState> {\n    private let disposeBag = DisposeBag()  // ‚úÖ Single DisposeBag\n\n    func search(query: String) {\n        searchService.search(query)\n            .subscribe(onNext: { results in })\n            .disposed(by: disposeBag)  // ‚úÖ Same bag\n    }\n\n    func loadData() {\n        dataService.loadData()\n            .subscribe(onNext: { data in })\n            .disposed(by: disposeBag)  // ‚úÖ Same bag\n    }\n}\n```\n\n**Fix**: Use single DisposeBag per class\n**Result**: Simpler code, all subscriptions disposed together\n\n---\n\n## Complete Examples\n\n### Example 5: Proper RxSwift Memory Management\n\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    // Dependencies\n    private let paymentUC: PaymentUseCase\n    private let validationService: ValidationService\n\n    // DisposeBag property (not local!)\n    private let disposeBag = DisposeBag()\n\n    // State\n    let paymentAmount = BehaviorRelay<String>(value: \"\")\n    let isProcessing = BehaviorRelay<Bool>(value: false)\n\n    init(paymentUC: PaymentUseCase, validationService: ValidationService) {\n        self.paymentUC = paymentUC\n        self.validationService = validationService\n        super.init()\n        setupBindings()\n    }\n\n    private func setupBindings() {\n        // ‚úÖ Proper disposal with weak self\n        paymentAmount\n            .map { [weak self] amount in\n                self?.validationService.validateAmount(amount) ?? false\n            }\n            .subscribe(onNext: { [weak self] isValid in\n                self?.setState(isValid ? .valid : .invalid)\n            })\n            .disposed(by: disposeBag)\n    }\n\n    func processPayment() {\n        isProcessing.accept(true)\n\n        paymentUC.execute(amount: paymentAmount.value)\n            .subscribeOn(ConcurrentScheduler.background)\n            .observeOn(MainScheduler.instance)\n            .subscribe(\n                onNext: { [weak self] result in\n                    self?.handleSuccess(result)\n                },\n                onError: { [weak self] error in\n                    self?.handleError(error)\n                },\n                onCompleted: { [weak self] in\n                    self?.isProcessing.accept(false)\n                }\n            )\n            .disposed(by: disposeBag)  // ‚úÖ Always disposed\n    }\n\n    private func handleSuccess(_ result: PaymentResult) {\n        setState(.success(result))\n    }\n\n    private func handleError(_ error: Error) {\n        setState(.error(error))\n        isProcessing.accept(false)\n    }\n}\n```\n\n**Key Points**:\n- ‚úÖ DisposeBag is a property\n- ‚úÖ Every subscription uses `.disposed(by:)`\n- ‚úÖ Every closure uses `[weak self]`\n- ‚úÖ Proper error handling\n- ‚úÖ Correct scheduler usage\n\n---\n\n### Example 6: ViewController with Proper Bindings\n\n```swift\nclass PaymentViewController: UIViewController {\n    @IBOutlet weak var amountTextField: UITextField!\n    @IBOutlet weak var confirmButton: UIButton!\n    @IBOutlet weak var loadingIndicator: UIActivityIndicatorView!\n\n    private let viewModel: PaymentViewModel\n    private let disposeBag = DisposeBag()  // ‚úÖ Property\n\n    init(viewModel: PaymentViewModel) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil)\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"Use dependency injection\")\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        bindViewModel()\n    }\n\n    private func setupUI() {\n        title = \"Payment\"\n    }\n\n    private func bindViewModel() {\n        // Input: TextField ‚Üí ViewModel\n        amountTextField.rx.text\n            .orEmpty\n            .bind(to: viewModel.paymentAmount)\n            .disposed(by: disposeBag)  // ‚úÖ Disposed\n\n        // Input: Button tap ‚Üí ViewModel action\n        confirmButton.rx.tap\n            .subscribe(onNext: { [weak self] in\n                self?.viewModel.processPayment()\n            })\n            .disposed(by: disposeBag)  // ‚úÖ Disposed\n\n        // Output: ViewModel ‚Üí UI\n        viewModel.isProcessing\n            .bind(to: loadingIndicator.rx.isAnimating)\n            .disposed(by: disposeBag)  // ‚úÖ Disposed\n\n        viewModel.isProcessing\n            .map { !$0 }\n            .bind(to: confirmButton.rx.isEnabled)\n            .disposed(by: disposeBag)  // ‚úÖ Disposed\n\n        // State handling\n        viewModel.getState()\n            .compactMap { $0 }\n            .observeOn(MainScheduler.instance)\n            .subscribe(onNext: { [weak self] state in\n                self?.handleState(state.name)\n            })\n            .disposed(by: disposeBag)  // ‚úÖ Disposed\n    }\n\n    private func handleState(_ state: PaymentState) {\n        switch state {\n        case .success(let result):\n            showSuccessAlert(result)\n        case .error(let error):\n            showErrorAlert(error)\n        default:\n            break\n        }\n    }\n}\n```\n\n**Key Points**:\n- ‚úÖ Single DisposeBag for all bindings\n- ‚úÖ All UI bindings properly disposed\n- ‚úÖ Weak self in subscribe closures\n- ‚úÖ Clean separation of concerns\n\n---\n\n## Common Scenarios\n\n### Scenario 1: Timer/Interval Observable\n\n#### ‚ùå Problem\n```swift\nfunc startTimer() {\n    Observable<Int>.interval(.seconds(1), scheduler: MainScheduler.instance)\n        .subscribe(onNext: { [weak self] tick in\n            self?.updateTime(tick)\n        })\n        // ‚ùå No disposal - timer runs forever!\n}\n```\n\n#### ‚úÖ Solution\n```swift\nclass TimerViewModel {\n    private let disposeBag = DisposeBag()\n\n    func startTimer() {\n        Observable<Int>.interval(.seconds(1), scheduler: MainScheduler.instance)\n            .subscribe(onNext: { [weak self] tick in\n                self?.updateTime(tick)\n            })\n            .disposed(by: disposeBag)  // ‚úÖ Stops when ViewModel deallocates\n    }\n}\n```\n\n---\n\n### Scenario 2: Network Requests\n\n#### ‚ùå Problem\n```swift\nfunc loadData() {\n    networkService.fetchData()\n        .subscribe(onNext: { data in\n            self.data = data  // ‚ùå Strong self\n        })\n        // ‚ùå No disposal\n}\n```\n\n#### ‚úÖ Solution\n```swift\nclass DataViewModel {\n    private let disposeBag = DisposeBag()\n\n    func loadData() {\n        networkService.fetchData()\n            .subscribe(\n                onNext: { [weak self] data in\n                    self?.data = data\n                },\n                onError: { [weak self] error in\n                    self?.handleError(error)\n                }\n            )\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n---\n\n### Scenario 3: Chained Observables\n\n#### ‚ùå Problem\n```swift\nfunc processData() {\n    fetchData()\n        .flatMap { data in\n            return self.transform(data)  // ‚ùå Strong self\n        }\n        .flatMap { transformed in\n            return self.save(transformed)  // ‚ùå Strong self\n        }\n        .subscribe(onNext: { result in\n            self.handleResult(result)  // ‚ùå Strong self\n        })\n        // ‚ùå No disposal\n}\n```\n\n#### ‚úÖ Solution\n```swift\nclass DataProcessor {\n    private let disposeBag = DisposeBag()\n\n    func processData() {\n        fetchData()\n            .flatMap { [weak self] data -> Observable<TransformedData> in\n                guard let self = self else { return .empty() }\n                return self.transform(data)\n            }\n            .flatMap { [weak self] transformed -> Observable<Result> in\n                guard let self = self else { return .empty() }\n                return self.save(transformed)\n            }\n            .subscribe(\n                onNext: { [weak self] result in\n                    self?.handleResult(result)\n                },\n                onError: { [weak self] error in\n                    self?.handleError(error)\n                }\n            )\n            .disposed(by: disposeBag)\n    }\n}\n```\n\n---\n\n## Detection Tools\n\n### Using Xcode Debug Memory Graph\n\n1. Run app in Simulator/Device\n2. Navigate to screen with suspected leak\n3. Pop back\n4. Xcode ‚Üí Debug ‚Üí View Memory Graph\n5. Look for objects that should have deallocated\n6. Check retain cycle graph\n\n### Using Instruments\n\n1. Product ‚Üí Profile\n2. Choose \"Leaks\" template\n3. Record while using app\n4. Navigate between screens\n5. Check for red leak indicators\n6. Inspect stack traces\n\n### Manual Verification\n\nAdd `deinit` to ViewModels and ViewControllers:\n\n```swift\nclass PaymentViewModel: BaseViewModel<PaymentState> {\n    deinit {\n        print(\"‚úÖ PaymentViewModel deallocated\")  // Should print when leaving screen\n    }\n}\n\nclass PaymentViewController: UIViewController {\n    deinit {\n        print(\"‚úÖ PaymentViewController deallocated\")  // Should print when popping\n    }\n}\n```\n\nIf `deinit` doesn't print, you have a memory leak!\n\n---\n\n## Quick Reference\n\n### Memory Management Checklist\n\n```markdown\n## RxSwift Memory Check\n\nFor each Observable subscription:\n- [ ] Has `.disposed(by: disposeBag)`\n- [ ] Uses `[weak self]` in closures\n- [ ] DisposeBag is a property (not local)\n- [ ] No strong reference cycles\n- [ ] Error handling present\n- [ ] deinit prints when tested\n```\n\n### Common Patterns\n\n| Pattern | Issue | Fix |\n|---------|-------|-----|\n| Missing disposal | Memory leak | Add `.disposed(by: disposeBag)` |\n| Strong self | Retain cycle | Use `[weak self]` |\n| Local DisposeBag | Early cancel | Make it a property |\n| Multiple bags | Complexity | Use single DisposeBag |\n| No error handling | Crashes | Add `onError` handler |\n",
        "py-plugin/skills/skill-builder/SKILL.md": "---\nname: skill-builder\ndescription: Create new Claude Code agent skills. Automatically analyzes requirements and generates complete skill with proper structure, triggers, and tools. Use when you want to \"create a skill\", \"build a new skill\", \"make a skill for\", or automate repetitive tasks.\nallowed-tools: Read, Write, Glob, Bash\n---\n\n# Skill Builder\n\nAutonomously create new Claude Code agent skills with intelligent analysis and generation.\n\n## When to Activate\n\n- \"create a skill for...\", \"build a new skill\"\n- \"make a skill that...\", \"I need a skill to...\"\n- \"generate a skill for...\"\n\n## Autonomous Creation Process\n\n### Step 1: Analyze User Request\n\n**Automatically infer from the request:**\n\n1. **Task Type Detection**:\n   - Review/Check ‚Üí Code Review Skill (Read, Grep, Glob)\n   - Generate/Create ‚Üí Code Generator (Read, Write, Glob)\n   - Analyze/Report ‚Üí Analyzer (Read, Grep, Glob, Bash)\n   - Refactor/Improve ‚Üí Refactoring Assistant (Read, Write, Grep, Glob)\n   - Test ‚Üí Test Assistant (Read, Write, Bash)\n   - Document ‚Üí Documentation Generator (Read, Write, Glob)\n\n2. **Skill Name Derivation**:\n   - Extract key technology/concept from request\n   - Format: `[technology]-[action]` (e.g., \"check iOS performance\" ‚Üí `ios-performance-check`)\n   - Keep lowercase with hyphens, max 64 chars\n\n3. **Trigger Keywords Extraction**:\n   - Parse user's language for natural phrases\n   - Add common variations and synonyms\n   - Include file type mentions if applicable\n\n4. **Tool Requirements**:\n   - Read-only tasks ‚Üí `Read, Grep, Glob`\n   - Generation tasks ‚Üí `Read, Write, Glob`\n   - Command/build tasks ‚Üí `Read, Write, Bash`\n   - Complex workflows ‚Üí No restrictions\n\n5. **Output Format Selection**:\n   - Review/Check ‚Üí Report with issues and fixes\n   - Generate ‚Üí File creation confirmation with examples\n   - Analyze ‚Üí Metrics report with visualizations\n   - Refactor ‚Üí Proposal with before/after\n   - Test ‚Üí Test results and coverage report\n   - Document ‚Üí Generated documentation preview\n\n### Step 2: Smart Question Strategy\n\n**Only ask if truly ambiguous:**\n- Multiple valid approaches? ‚Üí Ask which approach\n- Unclear scope? ‚Üí Ask for scope clarification\n- Critical choices? ‚Üí Ask for user preference\n\n**Never ask if inferable:**\n- Skill name ‚Üí Auto-generate from request\n- Basic tools ‚Üí Auto-select based on task type\n- Common triggers ‚Üí Auto-generate from context\n- Output format ‚Üí Auto-select based on skill type\n\n### Step 3: Auto-Generate Skill Structure\n\n**Automatically create complete skill with:**\n\n#### Auto-Generated Skill Name\nFormat: `[technology]-[action]`\nExamples:\n- \"check iOS naming\" ‚Üí `ios-naming-check`\n- \"generate React component\" ‚Üí `react-component-generator`\n- \"analyze dependencies\" ‚Üí `dependency-analyzer`\n\n#### Auto-Generated Description\nTemplate:\n```\n[Verb] [what] [context]. [Specifics]. Use when [trigger1], [trigger2], \"[quoted phrases]\", or [patterns].\n```\n\nAuto-include:\n- Specific action extracted from request\n- What it checks/generates/analyzes\n- Trigger phrases derived from user's language\n- File types if mentioned\n- Natural language variations\n\n#### Auto-Selected Tools\nBased on detected task type:\n- Review/Check ‚Üí `Read, Grep, Glob`\n- Generate ‚Üí `Read, Write, Glob`\n- Analyze with commands ‚Üí `Read, Grep, Glob, Bash`\n- Refactor ‚Üí `Read, Write, Grep, Glob`\n- Test with execution ‚Üí `Read, Write, Bash`\n\n#### Auto-Generated Content Structure\n\nSelect appropriate template based on task type (from templates.md):\n- Code Review ‚Üí Template 1\n- Code Generator ‚Üí Template 2\n- Analyzer/Reporter ‚Üí Template 3\n- Refactoring Assistant ‚Üí Template 4\n- Test Assistant ‚Üí Template 5\n- Documentation Generator ‚Üí Template 6\n\nPopulate template with:\n- Auto-generated name, description, tools\n- Task-specific process steps\n- Relevant output format\n- Examples from similar skills (from examples.md)\n\n### Step 4: Generate and Validate\n\n**Auto-create directory structure:**\n```bash\nmkdir -p .claude/skills/[auto-generated-name]\n```\n\n**Auto-generate files:**\n\n1. **`SKILL.md`** (Required, Concise)\n   - Frontmatter (name, description, allowed-tools)\n   - When to Activate (trigger phrases)\n   - Process steps (core workflow)\n   - Output format (template structure)\n   - Keep under 150 lines - core instructions only!\n\n2. **`templates.md`** (Optional, for code/structure templates)\n   - Code templates\n   - File structure templates\n   - Boilerplate examples\n   - Use when skill generates code or files\n\n3. **`examples.md`** (Optional, for detailed examples)\n   - Real-world usage examples\n   - Before/after code samples\n   - Complex scenarios\n   - Use when skill needs detailed guidance\n\n4. **`standards.md`** (Optional, for rules/guidelines)\n   - Coding standards\n   - Naming conventions\n   - Best practices\n   - Reference documentation\n   - Use when skill enforces specific rules\n\n**Separation principle:**\n- SKILL.md = Concise instructions (what to do, how to do it)\n- Separate files = Supporting details (templates, examples, references)\n\n**Auto-validate:**\n- ‚úì Valid YAML frontmatter with `---` delimiters\n- ‚úì Name lowercase with hyphens\n- ‚úì Description specific with quoted triggers\n- ‚úì Tools appropriate for task type\n- ‚úì Process steps clear and actionable\n- ‚úì SKILL.md concise (under 150 lines)\n- ‚úì Extra content moved to separate files\n\n### Step 5: Present and Test\n\n**Show user:**\n```markdown\n‚úÖ Created skill: [name]\n\nüìÅ Location: `.claude/skills/[name]/SKILL.md`\n\nüéØ Try these phrases:\n- \"[trigger phrase 1]\"\n- \"[trigger phrase 2]\"\n- \"[trigger phrase 3]\"\n\nüìñ Description: [generated description]\n```\n\n## Quick Reference: Task Types\n\n| Type | Tools | Output | Example Name |\n|------|-------|--------|--------------|\n| Review | Read, Grep, Glob | Issues report | `security-review` |\n| Generator | Read, Write, Glob | New files | `component-generator` |\n| Analyzer | Read, Grep, Glob, Bash | Metrics report | `dependency-analyzer` |\n| Refactor | Read, Write, Grep, Glob | Modified files | `extract-method` |\n| Test | Read, Write, Bash | Test results | `test-runner` |\n| Document | Read, Write, Glob | Documentation | `api-docs-generator` |\n\n## Auto-Generation Examples\n\n### Example 1: User says \"create a skill to check TODO comments\"\n**Auto-analysis:**\n- Task type: Review (check/find)\n- Name: `todo-finder`\n- Tools: `Read, Grep, Glob`\n- Triggers: \"find todos\", \"check todos\", \"show todos\", \"list fixmes\"\n- Output: Report organized by priority\n\n**Action:** Auto-generate complete skill, create files, show confirmation\n\n### Example 2: User says \"I need to generate React components\"\n**Auto-analysis:**\n- Task type: Generator (create/generate)\n- Name: `react-component-generator`\n- Tools: `Read, Write, Glob`\n- Triggers: \"create component\", \"generate component\", \"new component\"\n- Output: Component files with tests\n\n**Action:** Auto-generate complete skill, create files, show confirmation\n\n### Example 3: User says \"make a skill for iOS performance issues\"\n**Auto-analysis:**\n- Task type: Analyzer (check performance)\n- Name: `ios-performance-check`\n- Tools: `Read, Grep, Glob, Bash`\n- Triggers: \"check performance\", \"performance issues\", \"slow code\"\n- Output: Performance report with fixes\n\n**Action:** Auto-generate complete skill, create files, show confirmation\n\n## Standard Workflow\n\nWhen user requests a skill:\n\n1. **Analyze** request ‚Üí Detect task type, extract key concepts\n2. **Generate** skill name, description, triggers automatically\n3. **Select** appropriate template and tools\n4. **Create** `.claude/skills/[name]/SKILL.md` with complete content\n5. **Validate** frontmatter, structure, triggers\n6. **Present** summary with test phrases\n\n**No questions asked unless truly ambiguous!**\n\n## Creation Output Format\n\nAfter auto-generating skill, show:\n\n```markdown\n‚úÖ Skill Created: [name]\n\nüìÅ Files created:\n  - `.claude/skills/[name]/SKILL.md` (core instructions)\n  - `.claude/skills/[name]/templates.md` (if applicable)\n  - `.claude/skills/[name]/examples.md` (if applicable)\n  - `.claude/skills/[name]/standards.md` (if applicable)\n\nüîß Type: [task-type]\nüõ†Ô∏è  Tools: [tool-list]\nüìÑ Lines: [line-count] (SKILL.md is concise!)\n\nüéØ Test with these phrases:\n- \"[natural trigger 1]\"\n- \"[natural trigger 2]\"\n- \"[natural trigger 3]\"\n\nüìñ Full description:\n[Generated description with all triggers]\n\n‚úÖ Ready to use! Try one of the test phrases above.\n```\n\n## Internal References\n\nUse these for generation (don't show to user):\n- **templates.md**: 6 skill templates for different task types\n- **examples.md**: 5 complete real-world examples\n- **Official documentation**: https://code.claude.com/docs/en/skills\n\n## Key Principles\n\n1. **Be autonomous**: Infer everything possible from the user's request\n2. **Ask minimally**: Only ask if genuinely ambiguous (approach, scope, critical choices)\n3. **Generate completely**: Create full SKILL.md with all sections\n4. **Validate automatically**: Check frontmatter, structure, triggers before presenting\n5. **Present clearly**: Show what was created and how to test it\n\n## Important Rules\n\n### Auto-Generation\n- **Auto-generate** skill name from request (lowercase-with-hyphens)\n- **Auto-detect** task type to select template and tools\n- **Auto-extract** trigger phrases from user's language\n- **Auto-create** description with specific triggers in quotes\n- **Auto-select** appropriate tools based on task type\n\n### Quality Standards\n- **No generic names**: Always use specific technology/action names\n- **No vague descriptions**: Always include specific triggers and file types\n- **Valid YAML**: Always use `---` delimiters and proper frontmatter format\n  - `allowed-tools` must be comma-separated (e.g., `Read, Write, Glob`) not array format\n\n### File Organization\n- **SKILL.md must be concise**: Under 150 lines, core instructions only\n- **Separate templates**: Move code templates to `templates.md`\n- **Separate examples**: Move detailed examples to `examples.md`\n- **Separate standards**: Move rules/guidelines to `standards.md`\n- **Clear separation**: Instructions in SKILL.md, details in other files\n\n---\n\n**Ready for autonomous skill generation!** Just tell me what skill you need.\n"
      },
      "plugins": [
        {
          "name": "py-plugin",
          "source": "./py-plugin",
          "description": "A plugin stores all skills for py projects",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add daispacy/py-claude-marketplace",
            "/plugin install py-plugin@py-claude-marketplace"
          ]
        }
      ]
    }
  ]
}