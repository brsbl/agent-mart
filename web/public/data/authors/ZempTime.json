{
  "author": {
    "id": "ZempTime",
    "display_name": "Chris Zempel",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/3596468?v=4",
    "url": "https://github.com/ZempTime",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 1,
      "total_skills": 14,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "zemptime-marketplace",
      "version": null,
      "description": "Production-tested Rails patterns: CRUD controllers, rich models, concerns, fixtures, small PRs.",
      "owner_info": {
        "name": "Chris Zempel"
      },
      "keywords": [],
      "repo_full_name": "ZempTime/zemptime-marketplace",
      "repo_url": "https://github.com/ZempTime/zemptime-marketplace",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-03T20:47:12Z",
        "created_at": "2025-12-25T19:33:36Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 537
        },
        {
          "path": "swiss-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-design/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-design/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 528
        },
        {
          "path": "swiss-design/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-design/skills/swiss-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-design/skills/swiss-design/SKILL.md",
          "type": "blob",
          "size": 3254
        },
        {
          "path": "swiss-design/skills/swiss-design/grid.md",
          "type": "blob",
          "size": 4734
        },
        {
          "path": "swiss-design/skills/swiss-design/hierarchy.md",
          "type": "blob",
          "size": 6450
        },
        {
          "path": "swiss-design/skills/swiss-design/reduction.md",
          "type": "blob",
          "size": 4164
        },
        {
          "path": "swiss-design/skills/swiss-design/typography.md",
          "type": "blob",
          "size": 5811
        },
        {
          "path": "vanilla-rails",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 513
        },
        {
          "path": "vanilla-rails/README.md",
          "type": "blob",
          "size": 4681
        },
        {
          "path": "vanilla-rails/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/commands/shape.md",
          "type": "blob",
          "size": 323
        },
        {
          "path": "vanilla-rails/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/controllers",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/controllers/SKILL.md",
          "type": "blob",
          "size": 8136
        },
        {
          "path": "vanilla-rails/skills/data-modeling",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/data-modeling/SKILL.md",
          "type": "blob",
          "size": 11299
        },
        {
          "path": "vanilla-rails/skills/delegated-types",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/delegated-types/SKILL.md",
          "type": "blob",
          "size": 3156
        },
        {
          "path": "vanilla-rails/skills/delegated-types/flattening.md",
          "type": "blob",
          "size": 4161
        },
        {
          "path": "vanilla-rails/skills/delegated-types/implementing.md",
          "type": "blob",
          "size": 5049
        },
        {
          "path": "vanilla-rails/skills/hotwire",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/hotwire/SKILL.md",
          "type": "blob",
          "size": 7174
        },
        {
          "path": "vanilla-rails/skills/jobs",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/jobs/SKILL.md",
          "type": "blob",
          "size": 7017
        },
        {
          "path": "vanilla-rails/skills/models",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/models/SKILL.md",
          "type": "blob",
          "size": 8459
        },
        {
          "path": "vanilla-rails/skills/naming",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/naming/SKILL.md",
          "type": "blob",
          "size": 7110
        },
        {
          "path": "vanilla-rails/skills/shaping",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/shaping/SKILL.md",
          "type": "blob",
          "size": 3730
        },
        {
          "path": "vanilla-rails/skills/style",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/style/SKILL.md",
          "type": "blob",
          "size": 10552
        },
        {
          "path": "vanilla-rails/skills/testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/testing/SKILL.md",
          "type": "blob",
          "size": 9663
        },
        {
          "path": "vanilla-rails/skills/views",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/views/SKILL.md",
          "type": "blob",
          "size": 3090
        },
        {
          "path": "vanilla-rails/skills/work-breakdown",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/work-breakdown/SKILL.md",
          "type": "blob",
          "size": 2947
        },
        {
          "path": "vanilla-rails/skills/writing-affordances",
          "type": "tree",
          "size": null
        },
        {
          "path": "vanilla-rails/skills/writing-affordances/SKILL.md",
          "type": "blob",
          "size": 3726
        },
        {
          "path": "vanilla-rails/skills/writing-affordances/detecting.md",
          "type": "blob",
          "size": 4868
        },
        {
          "path": "vanilla-rails/skills/writing-affordances/implementing.md",
          "type": "blob",
          "size": 7983
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"zemptime-marketplace\",\n  \"owner\": {\n    \"name\": \"Chris Zempel\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"vanilla-rails\",\n      \"description\": \"Production-tested Rails patterns: CRUD controllers, rich models, concerns, fixtures, small PRs.\",\n      \"source\": \"./vanilla-rails\",\n      \"version\": \"1.1.0\"\n    },\n    {\n      \"name\": \"swiss-design\",\n      \"description\": \"Swiss/International Typographic Style principles for software and interaction design.\",\n      \"source\": \"./swiss-design\",\n      \"version\": \"1.1.0\"\n    }\n  ]\n}\n",
        "swiss-design/.claude-plugin/plugin.json": "{\n  \"name\": \"swiss-design\",\n  \"description\": \"Swiss/International Typographic Style principles for software and interaction design - clarity through reduction, grid systems, hierarchy, and typography\",\n  \"version\": \"1.1.0\",\n  \"author\": {\n    \"name\": \"Chris Zempel\"\n  },\n  \"homepage\": \"https://github.com/zemptime/zemptime-marketplace\",\n  \"repository\": \"https://github.com/zemptime/zemptime-marketplace\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"design\", \"typography\", \"grids\", \"ui\", \"clarity\", \"swiss-style\", \"interaction-design\"]\n}\n",
        "swiss-design/skills/swiss-design/SKILL.md": "---\nname: swiss-design\ndescription: Use when designing interfaces, data visualizations, documentation, or any output where clarity and visual hierarchy matter - applies Swiss design principles of reduction, grid structure, hierarchy, and typography\n---\n\n# Swiss Design for Software\n\n**Core principle:** Clarity through reduction. Every element must earn its place. Remove until removing more would harm understanding.\n\nThe Swiss/International Typographic Style emerged in 1950s Switzerland as a reaction against decorative excess. Its principles—mathematical grids, typographic hierarchy, ruthless reduction—created a universal visual language that transcends culture and context.\n\nThese same principles apply directly to software and interaction design. A well-designed interface, like a well-designed poster, guides attention through structure rather than decoration.\n\n## The Four Principles\n\n1. **Reduction** — Strip to essentials. If it doesn't serve comprehension, it's noise. → [reduction.md]\n\n2. **Grid** — Mathematical structure creates visual order that reduces cognitive load. → [grid.md]\n\n3. **Hierarchy** — Control attention through contrast in size, weight, and position. → [hierarchy.md]\n\n4. **Typography** — Type is the primary tool. It carries content and creates structure without ornament. → [typography.md]\n\n## When This Skill Applies\n\n- Generating UI components or layouts\n- Creating documentation or technical prose\n- Building data visualizations, tables, charts\n- Designing CLI output or terminal interfaces\n- Any output where a human needs to quickly comprehend information\n\n## The Swiss Test\n\nBefore finalizing any design output, ask:\n\n1. **Reduction:** Can I remove anything without losing meaning?\n2. **Grid:** Does alignment create rhythm and relationships?\n3. **Hierarchy:** Is there a clear reading order through size/weight/position?\n4. **Typography:** Is type doing the structural work (not color or decoration)?\n\nIf any answer is \"no,\" revise before shipping.\n\n## Common Failures\n\n**Decoration creep:** Adding visual elements \"to make it look better\" rather than to aid comprehension. Gradients, shadows, illustrations, icons—each must justify its presence.\n\n**Hierarchy collapse:** When everything is bold, nothing is. When there are twelve font sizes, there's no system. Constraint creates clarity.\n\n**Grid abandonment:** \"Just this once\" alignment exceptions accumulate into visual chaos. The grid is not a suggestion.\n\n**Color as crutch:** Using color to create hierarchy that should exist in type. If the design doesn't work in grayscale, the structure is weak.\n\n## Philosophy\n\nSwiss design is not a style—it's a discipline. The goal isn't to \"look Swiss.\" The goal is to remove everything that doesn't serve the reader's comprehension.\n\nMüller-Brockmann: \"The grid system is an aid, not a guarantee. It permits a number of possible uses and each designer can look for a solution appropriate to his personal style. But one must learn how to use the grid; it is an art that requires practice.\"\n\nThe same applies to all four principles. They are constraints that, properly applied, create freedom—freedom from arbitrary decisions, freedom from visual noise, freedom for the content to speak.\n",
        "swiss-design/skills/swiss-design/grid.md": "# Grid: Mathematical Structure\n\n**Principle:** Grids create visual order that reduces cognitive load. Alignment implies relationship. Rhythm creates predictability.\n\nA grid is not a container—it's a set of relationships. Elements that share alignment are perceived as related. Consistent spacing creates rhythm that the eye follows without effort.\n\n## Grid Fundamentals\n\n### The Base Unit\n\nChoose a base unit. Derive all spacing from multiples of it.\n\n```\nBase unit: 8px\n\nSpacing scale:\n- xs: 4px   (0.5×)\n- sm: 8px   (1×)\n- md: 16px  (2×)\n- lg: 24px  (3×)\n- xl: 32px  (4×)\n- 2xl: 48px (6×)\n```\n\nWhy 8? It divides evenly at common viewport sizes, works well with line heights, and is large enough to create visible rhythm.\n\n### Alignment Points\n\nFewer alignment points = stronger grid.\n\n**Weak grid:** Elements start at 12px, 16px, 24px, 32px, 40px (5 alignment points)\n\n**Strong grid:** Elements start at 16px or 48px only (2 alignment points)\n\nEvery unique alignment point adds cognitive load. Each \"exception\" weakens the system.\n\n## Applying Grids\n\n### In Interfaces\n\n**Column grids** for page layout:\n```css\n.layout {\n  display: grid;\n  grid-template-columns: repeat(12, 1fr);\n  gap: 24px; /* 3× base unit */\n}\n```\n\n**Baseline grids** for vertical rhythm:\n```css\n:root {\n  --baseline: 8px;\n}\n\np {\n  line-height: 24px; /* 3× baseline */\n  margin-bottom: 24px;\n}\n\nh2 {\n  line-height: 32px; /* 4× baseline */\n  margin-bottom: 16px;\n}\n```\n\n**Component grids** for internal structure:\n```css\n.card {\n  padding: 24px;\n  gap: 16px;\n}\n\n.card-header {\n  padding-bottom: 16px;\n  border-bottom: 1px solid var(--border);\n}\n```\n\nThe card's internal spacing uses the same base unit as the page.\n\n### In Data Visualization\n\n**Axis alignment:** Data points should align to grid lines where possible. Jagged alignment makes comparison harder.\n\n**Chart sizing:** Chart dimensions should be multiples of your base unit. A 400×300 chart fits a 100px grid cleanly.\n\n**Label positioning:** Labels align to consistent positions. Don't float labels based on data position—anchor them.\n\n```\nGood: Labels at fixed y-positions\n┌─────────────────────────┐\n│ Revenue    ████████ 50k │\n│ Costs      █████    30k │\n│ Profit     ███      20k │\n└─────────────────────────┘\n\nBad: Labels following bar ends\n┌─────────────────────────┐\n│ Revenue    ████████ 50k │\n│ Costs      █████ 30k    │\n│ Profit     ███ 20k      │\n└─────────────────────────┘\n```\n\n### In Documentation\n\n**Margin consistency:** All content blocks share the same left margin. Code blocks, quotes, lists—same starting point.\n\n**Heading levels as grid:** Each heading level represents a structural tier. Don't skip levels. Don't use headings for styling.\n\n```markdown\n# Page Title (H1)\n\n## Major Section (H2)\n\n### Subsection (H3)\n\nContent always at the same depth.\n```\n\n**Table alignment:** Columns align by data type. Numbers right-align. Text left-aligns. Headers match their column.\n\n### In CLI Output\n\n**Column alignment:** Related data shares columns.\n\n```\nGood:\nNAME        STATUS    REPLICAS\napi         Running   3/3\nweb         Running   2/2\nworker      Failed    0/1\n\nBad:\napi is Running with 3/3 replicas\nweb is Running with 2/2 replicas\nworker is Failed with 0/1 replicas\n```\n\n**Indentation as structure:** Nested information indents by consistent amounts (2 or 4 spaces, not mixed).\n\n```\nProject: my-app\n  Dependencies:\n    react: 18.2.0\n    next: 14.0.0\n  Scripts:\n    dev: next dev\n    build: next build\n```\n\n## Grid Violations\n\nSometimes breaking the grid is correct. But treat violations as exceptional:\n\n**Allowed violations:**\n- Full-bleed images or backgrounds (intentional break)\n- Pull quotes or callouts (offset for emphasis)\n- Optical adjustments (icons that appear misaligned at mathematical center)\n\n**Red flag violations:**\n- \"Just this once\" positioning\n- Pixel nudges to \"make it look right\"\n- Different spacing in similar components\n\nIf you're nudging pixels, either your grid is wrong or your content doesn't fit your grid. Fix the system, don't patch around it.\n\n## Building a Grid\n\n1. **Choose your base unit** (8px is safe)\n2. **Define your spacing scale** (multiples of base)\n3. **Set your column grid** (12-column is flexible)\n4. **Apply consistently** (no exceptions for 2 weeks)\n5. **Evaluate and adjust** (the grid serves the content)\n\nThe grid is an aid, not a prison. But you must master the grid before you earn the right to break it.\n",
        "swiss-design/skills/swiss-design/hierarchy.md": "# Hierarchy: Controlling Attention\n\n**Principle:** Control attention through contrast in size, weight, and position. If everything is emphasized, nothing is.\n\nHierarchy tells readers where to look first, second, third. It converts a collection of elements into a sequence. Without hierarchy, users must scan everything to find what matters.\n\n## The Three Levers\n\nHierarchy is created through **contrast** in:\n\n1. **Size** — Larger elements attract attention first\n2. **Weight** — Bolder elements stand out from regular text\n3. **Position** — Top-left (in LTR languages) is scanned first; isolation draws focus\n\nUse one lever strongly. Using all three on every element flattens the hierarchy.\n\n## The Squint Test\n\nBlur your vision or step back from the screen. What do you see first? That's your primary element. What do you see second? That's your secondary.\n\nIf you see everything at once—or nothing stands out—your hierarchy is broken.\n\n## Applying Hierarchy\n\n### In Interfaces\n\n**Define three levels maximum:**\n\n| Level | Purpose | Treatment |\n|-------|---------|-----------|\n| Primary | The main action or message | Large, bold, prominent position |\n| Secondary | Supporting actions or context | Regular size, normal weight |\n| Tertiary | Metadata, auxiliary info | Smaller, lighter, peripheral |\n\n```html\n<!-- Clear hierarchy -->\n<article>\n  <h1 class=\"text-2xl font-bold\">Article Title</h1>        <!-- Primary -->\n  <p class=\"text-base\">Article content goes here...</p>    <!-- Secondary -->\n  <span class=\"text-sm text-gray-500\">Jan 15, 2025</span>  <!-- Tertiary -->\n</article>\n\n<!-- Broken hierarchy: everything competes -->\n<article>\n  <h1 class=\"text-xl font-bold text-blue-600\">Article Title</h1>\n  <p class=\"text-lg font-medium\">Article content goes here...</p>\n  <span class=\"text-base font-semibold text-gray-800\">Jan 15, 2025</span>\n</article>\n```\n\n**Button hierarchy:**\n\n```\nPrimary:    Filled, high contrast       [  Submit  ]\nSecondary:  Outlined, lower contrast    [  Cancel  ]\nTertiary:   Text only, lowest contrast   Learn more\n```\n\nOne primary action per view. If two things are equally important, neither is important.\n\n### In Data Visualization\n\n**Data is primary.** Everything else (axes, labels, legends) is secondary or tertiary.\n\n```\nGood: Data dominates, labels recede\n┌─────────────────────────────────────┐\n│ ████████████████████████████ 847    │  <- Bold data\n│ █████████████████            512    │\n│ █████████                    298    │\n│                                     │\n│ Revenue  ──────────────────────────→│  <- Light axis\n└─────────────────────────────────────┘\n  Q1     Q2     Q3     Q4               <- Subtle labels\n\nBad: Labels compete with data\n┌─────────────────────────────────────┐\n│ REVENUE (USD)                       │\n│ ════════════════════════════════════│\n│ ████████████████████████████ $847M  │\n│ █████████████████            $512M  │\n│ █████████                    $298M  │\n│ ════════════════════════════════════│\n│        Q1     Q2     Q3     Q4      │\n└─────────────────────────────────────┘\n```\n\n**Highlight selectively.** If one data point matters most, make it visually distinct. If all points matter equally, make them uniform.\n\n### In Documentation\n\n**Heading hierarchy is literal hierarchy.** H1 > H2 > H3 in importance and scope.\n\n```markdown\n# API Reference                    <- Page scope\n\n## Authentication                  <- Section scope\n\n### Bearer Tokens                  <- Subsection scope\n\nUse bearer tokens for API access.  <- Content (no heading)\n```\n\n**Body text is secondary.** Don't bold entire paragraphs. Bold individual terms that readers might scan for.\n\n```markdown\nBad:\n**Authentication is required for all endpoints. Include your API key in the Authorization header.**\n\nGood:\nAuthentication is required for all endpoints. Include your **API key** in the `Authorization` header.\n```\n\n**Code is primary in technical docs.** When showing how to do something, the code example should be the most prominent element.\n\n### In CLI Output\n\n**Hierarchy through caps, symbols, and weight:**\n\n```\nERROR: Connection refused           <- Primary (caps, symbol)\n  Could not reach api.example.com   <- Secondary (context)\n  Check your network connection     <- Tertiary (suggestion)\n```\n\n**Use whitespace as hierarchy:**\n\n```\nBuild completed\n\n  Compiled 142 files\n  Bundle size: 1.2MB\n  Time: 3.2s\n\nWarnings: 2\n  src/utils.js:42 - Unused variable 'temp'\n  src/api.js:18 - Missing return type\n```\n\nGroups separated by blank lines. Primary info gets its own line.\n\n## Hierarchy Failures\n\n**Everything is bold:** When emphasis is everywhere, nothing is emphasized. Reserve bold for true primary elements.\n\n**Rainbow highlighting:** Using color to distinguish 8 different things creates visual noise, not hierarchy. Color is one hierarchy lever—use it sparingly.\n\n**Size escalation:** Each new feature gets \"a bit bigger\" until you have 47px headings and 22px body text. Set sizes once, use them consistently.\n\n**Position chaos:** Important elements scattered across the page instead of anchored in high-attention zones (top, left, center).\n\n## Establishing Hierarchy\n\n1. **Rank your elements** — What's most important? What's second?\n2. **Assign levels** — Primary, secondary, tertiary. No more.\n3. **Choose one lever** — Size OR weight OR position. Not all three.\n4. **Create contrast** — The gap between levels should be obvious, not subtle.\n5. **Squint test** — Can you see the hierarchy at a glance?\n\nHierarchy is about sacrifice. To make something important, you must make other things less important. If you can't decide what's primary, you don't understand the content.\n",
        "swiss-design/skills/swiss-design/reduction.md": "# Reduction: The Discipline of Removal\n\n**Principle:** Every element must earn its place. Remove until removing more would harm understanding.\n\nReduction is not minimalism as aesthetic. It's minimalism as function. The question isn't \"does this look clean?\" but \"does this element serve comprehension?\"\n\n## The Reduction Test\n\nFor each element, ask: **If I remove this, what do users lose?**\n\n- If the answer is \"nothing\"—remove it\n- If the answer is \"beauty\" or \"polish\"—remove it\n- If the answer is \"they won't understand X\"—keep it\n\n## Applying Reduction\n\n### In Interfaces\n\n**Remove:**\n- Decorative borders, dividers, and containers when whitespace suffices\n- Icons that duplicate adjacent text labels\n- Color variations that don't encode meaning\n- Hover states, animations, transitions that don't aid understanding\n- \"Helper\" text that restates the obvious\n\n**Keep:**\n- Visual separation that creates semantic grouping\n- Icons that work without labels (rare—test this)\n- Color that encodes state, type, or severity\n- Motion that shows causation or spatial relationships\n\n**Before:**\n```html\n<div class=\"card shadow-lg rounded-xl border border-gray-200 p-6\">\n  <div class=\"flex items-center gap-2 mb-4\">\n    <UserIcon class=\"w-5 h-5 text-blue-500\" />\n    <h3 class=\"text-lg font-semibold text-gray-800\">User Profile</h3>\n  </div>\n  <div class=\"divider border-t border-gray-100 my-4\"></div>\n  <p class=\"text-gray-600 text-sm\">View and edit your profile information below.</p>\n  <!-- actual content -->\n</div>\n```\n\n**After:**\n```html\n<section>\n  <h3>User Profile</h3>\n  <!-- actual content -->\n</section>\n```\n\nThe card, shadow, icon, divider, and helper text added nothing. The heading does the work.\n\n### In Data Visualization\n\n**Remove:**\n- Grid lines when data points are dense enough to imply the scale\n- Legends when direct labeling is possible\n- 3D effects, gradients, decorative chart elements\n- Redundant encoding (don't use both position AND color for the same variable)\n\n**Keep:**\n- Axis labels with units\n- Data point labels when precision matters\n- Reference lines that encode meaningful thresholds\n\nTufte's data-ink ratio: maximize the share of ink devoted to data.\n\n### In Documentation\n\n**Remove:**\n- Introductory paragraphs that delay useful content\n- Hedging language (\"In some cases, you might want to consider...\")\n- Obvious statements (\"This function returns a value\")\n- Section headers for single paragraphs\n\n**Keep:**\n- Context that prevents misuse\n- Examples that demonstrate, not decorate\n- Warnings that prevent real errors\n\n**Before:**\n```markdown\n## Overview\n\nThis section provides a comprehensive overview of the authentication\nsystem. Authentication is a critical component of any web application,\nand our implementation follows industry best practices.\n\n## Getting Started\n\nTo get started with authentication, you'll need to configure...\n```\n\n**After:**\n```markdown\n## Authentication\n\nConfigure in `config/auth.rb`:\n```\n\n### In CLI Output\n\n**Remove:**\n- ASCII art and decorative banners\n- Progress messages for sub-second operations\n- Confirmation of obvious success (\"File saved successfully!\")\n- Color that doesn't encode meaning\n\n**Keep:**\n- Errors with actionable context\n- Progress for operations over 2 seconds\n- Color for severity (red=error, yellow=warning)\n\n## Reduction Traps\n\n**\"Users expect it\"** — Users expect to accomplish their goal. They don't expect specific decorative elements. Test actual comprehension, not preference.\n\n**\"It looks empty\"** — Empty space is not a problem to solve. It's breathing room for content. Resist the urge to fill it.\n\n**\"It's just a small addition\"** — Each element creates cognitive load. Small additions compound into cluttered interfaces.\n\n**\"Competitors have it\"** — Competitors may be wrong. Reduce to what YOUR users need to understand.\n\n## The Reduction Process\n\n1. Build the feature with all elements you think you need\n2. Remove one element\n3. Check: can users still accomplish the goal? Still understand the content?\n4. If yes, repeat from step 2\n5. If no, restore that element and stop\n\nYou've found the minimum when removing anything breaks comprehension.\n",
        "swiss-design/skills/swiss-design/typography.md": "# Typography: The Primary Tool\n\n**Principle:** Type carries content and creates structure. It's the only ornament you need.\n\nSwiss designers chose sans-serif typefaces not because they were trendy, but because they were neutral—the type disappears, the content remains. Typography in Swiss design is not decorative. It's structural.\n\n## Type as Structure\n\nGood typography does three things:\n\n1. **Delivers content** — Readable, scannable, comprehensible\n2. **Creates hierarchy** — Size and weight signal importance\n3. **Establishes rhythm** — Consistent spacing creates visual flow\n\nIt should NOT:\n\n- Draw attention to itself\n- Require decoration to \"look finished\"\n- Fight with the content\n\n## The Typography Stack\n\n### One Typeface, Two Weights\n\nThe Swiss tradition: one sans-serif typeface, regular and bold weights.\n\n```css\n:root {\n  --font-family: Inter, -apple-system, sans-serif;\n  --font-weight-normal: 400;\n  --font-weight-bold: 600;\n}\n```\n\nWhy just one? Typeface variety is decoration. It adds personality, not clarity. For software, personality is noise.\n\nWhy just two weights? Regular and bold create sufficient hierarchy. Light weights reduce readability. Extra-bold weights shout.\n\n### A Type Scale\n\nSizes should follow a ratio. The classic is 1.25× (major third):\n\n```css\n:root {\n  --text-xs: 0.64rem;   /* 10px */\n  --text-sm: 0.8rem;    /* 13px */\n  --text-base: 1rem;    /* 16px */\n  --text-lg: 1.25rem;   /* 20px */\n  --text-xl: 1.563rem;  /* 25px */\n  --text-2xl: 1.953rem; /* 31px */\n  --text-3xl: 2.441rem; /* 39px */\n}\n```\n\nUse 4-5 sizes maximum in any interface. More sizes = weaker system.\n\n### Line Height and Measure\n\n**Line height:** 1.4-1.6 for body text. Tighter (1.2) for headings.\n\n**Measure:** 45-75 characters per line. Wider loses tracking. Narrower feels choppy.\n\n```css\n.prose {\n  max-width: 65ch;\n  line-height: 1.5;\n}\n\nh1, h2, h3 {\n  line-height: 1.2;\n  max-width: 25ch; /* Headlines can be shorter */\n}\n```\n\n## Applying Typography\n\n### In Interfaces\n\n**Limit type treatments:**\n\n| Element | Size | Weight | Color |\n|---------|------|--------|-------|\n| Page title | text-2xl | bold | primary |\n| Section head | text-lg | bold | primary |\n| Body | text-base | normal | primary |\n| Caption | text-sm | normal | secondary |\n| Label | text-sm | normal | secondary |\n\nFive treatments. That's enough for most interfaces.\n\n**Don't use type for decoration:**\n\n```html\n<!-- Bad: Type as decoration -->\n<h1 class=\"text-5xl font-black uppercase tracking-widest\n           bg-gradient-to-r from-purple-500 to-pink-500\n           bg-clip-text text-transparent\">\n  Welcome\n</h1>\n\n<!-- Good: Type as structure -->\n<h1 class=\"text-2xl font-bold\">Welcome</h1>\n```\n\n### In Data Visualization\n\n**Data labels must be readable.** Don't sacrifice legibility for aesthetics.\n\n- Minimum 11px for data labels\n- Sans-serif, regular weight\n- High contrast against background\n- Aligned consistently (see grid.md)\n\n**Use tabular figures for numbers.** Monospace numerals align in columns:\n\n```css\n.data-value {\n  font-variant-numeric: tabular-nums;\n}\n```\n\n**Axis labels are secondary.** Smaller, lighter than data labels.\n\n### In Documentation\n\n**Monospace for code.** All of it. Inline and blocks.\n\n```markdown\nRun `npm install` to install dependencies.\n```\n\n**Body text is the workhorse.** Don't stylize it. 16px minimum, comfortable measure, good line height.\n\n**Headings signal structure, not importance.** An H2 isn't \"more important\" than body text—it's a different structural tier.\n\n### In CLI Output\n\n**Monospace by default.** CLI is a typographic medium—embrace it.\n\n**Create hierarchy with whitespace and caps, not special characters:**\n\n```\nGood:\nERROR: Build failed\n\n  src/app.js:42\n  SyntaxError: Unexpected token\n\n  > npm run build\n\nBad:\n╔═══════════════════════════════════╗\n║  ⚠️  ERROR: Build failed  ⚠️      ║\n╚═══════════════════════════════════╝\n```\n\n**Fixed-width columns for tables:**\n\n```\nNAME        STATUS      UPTIME\napi         running     3d 4h\nworker      stopped     -\nscheduler   running     1d 12h\n```\n\n## Typography Failures\n\n**Too many fonts:** Each typeface is a decision the user must process. One family, maybe two (sans + mono for code).\n\n**Too many sizes:** If you have 12px, 13px, 14px, 15px, and 16px in one view, you have no system.\n\n**Weight as emphasis:** Don't bold entire paragraphs. Bold specific terms. Weight is scarce—spend it wisely.\n\n**Color as typography:** Using color to distinguish text levels (blue for links, gray for captions, red for errors) is fine. Using 8 colors for \"visual interest\" is decoration.\n\n**Tight line height:** Body text below 1.4 line height strains reading. Don't sacrifice readability for density.\n\n## Choosing Typefaces\n\nFor software and interfaces, choose:\n\n- **Sans-serif** (Helvetica, Inter, SF Pro, Roboto)\n- **Neutral** (no distinctive personality)\n- **Wide character set** (supports internationalization)\n- **Readable at small sizes** (clear at 12-14px)\n\nDon't choose:\n- Display fonts (designed for headlines)\n- Serif fonts (unless you have a specific reason)\n- Trendy fonts (personality dates quickly)\n\nThe best typeface is one nobody notices.\n\n## Building a Type System\n\n1. **Pick one sans-serif family** — Inter, SF Pro, or system stack\n2. **Define your scale** — 4-5 sizes max, based on ratio\n3. **Set your weights** — Regular and bold. Maybe medium.\n4. **Establish line heights** — 1.2 for headings, 1.5 for body\n5. **Set max widths** — 65ch for prose, shorter for headings\n6. **Apply consistently** — Don't invent new treatments\n\nTypography is the foundation. If your type system is solid, half your design work is done.\n",
        "vanilla-rails/.claude-plugin/plugin.json": "{\n  \"name\": \"vanilla-rails\",\n  \"description\": \"Production-tested Rails patterns: CRUD controllers, rich models, concerns, fixtures, small PRs. Extracted from Basecamp-style applications.\",\n  \"version\": \"1.2.1\",\n  \"author\": {\n    \"name\": \"Chris Zempel\"\n  },\n  \"homepage\": \"https://github.com/zemptime/zemptime-marketplace\",\n  \"repository\": \"https://github.com/zemptime/zemptime-marketplace\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"rails\", \"basecamp\", \"crud\", \"concerns\", \"fixtures\", \"hotwire\", \"turbo\", \"stimulus\"]\n}\n",
        "vanilla-rails/README.md": "# vanilla-rails\n\nThis is an experimental take on distilling the ideas and approaches in https://github.com/basecamp/fizzy and turning them into a set of skills which can ship some great rails code.\n\nInspired by https://github.com/obra/superpowers (and strongly encouraged to use that with this!)\n\n## What is this?\n\nA Claude Code plugin that teaches vanilla Rails conventions:\n- **CRUD controllers** - No custom actions, extract resources for state changes\n- **Rich models** - Concerns as adjectives, state-as-records pattern\n- **Fixtures** - Always fixtures, never factories\n- **Thin jobs** - `_later`/`_now` pattern, logic in models\n- **Hotwire** - Turbo Streams, focused Stimulus controllers\n- **Small PRs** - 2-5 files, one sentence description\n\nThese patterns come from analyzing production Basecamp applications and distilling the key conventions.\n\n## Installation\n\n### Option 1: Via Marketplace (Recommended)\n\n```bash\nclaude marketplace add https://github.com/zemptime/vanilla-rails-marketplace\nclaude plugin install vanilla-rails\n```\n\n### Option 2: Local Development\n\n```bash\ngit clone https://github.com/zemptime/vanilla-rails.git\ncd vanilla-rails\nclaude --plugin-dir .\n```\n\n## Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/shape` | Apply vanilla-rails patterns to a feature, produce structured handoff for planning |\n\n**Workflow with superpowers:**\n```\nsuperpowers:brainstorming → /shape → superpowers:writing-plans\n```\n\n## Skills Included\n\n| Skill | When It Activates |\n|-------|-------------------|\n| `vanilla-rails-controllers` | Writing Rails controllers |\n| `vanilla-rails-models` | Writing Rails models or concerns |\n| `vanilla-rails-data-modeling` | Designing database schema, writing migrations |\n| `vanilla-rails-delegated-types` | 5+ content types in unified feeds/timelines |\n| `vanilla-rails-testing` | Writing Rails tests |\n| `vanilla-rails-jobs` | Writing background jobs |\n| `vanilla-rails-naming` | Naming classes, methods, files |\n| `vanilla-rails-hotwire` | Writing Turbo/Stimulus code |\n| `vanilla-rails-work-breakdown` | Planning features or PRs |\n| `vanilla-rails-style` | Ruby code style questions |\n| `vanilla-rails-views` | Writing ERB templates, partials, Turbo Streams |\n| `vanilla-rails-writing-affordances` | Extracting PORO wrappers for related operations |\n| `shaping` | Applying patterns to features (via `/shape`) |\n\nSkills auto-invoke based on context. No manual activation needed.\n\n## Reference Implementations\n\nThe `reference/` directory contains detailed implementations:\n- `authentication.md` - Passwordless magic link auth\n- `multi-tenancy.md` - URL path-based multi-tenancy\n- `events-audit-trail.md` - Polymorphic event system\n\nThese are for deep dives, not auto-loaded by Claude.\n\n## AGENTS.md Template\n\nUse `templates/AGENTS.md` as a starting point for your Rails projects. Copy it to your project root and customize.\n\n## Key Patterns\n\n### Resource Extraction\n```ruby\n# Instead of custom actions\nresources :cards { post :close }\n\n# Extract a resource\nresources :cards { resource :closure }\n```\n\n### State as Records\n```ruby\n# Instead of boolean columns\nclass Card < ApplicationRecord\n  # closed: boolean\nend\n\n# State records with who/when\nclass Card < ApplicationRecord\n  has_one :closure\nend\n```\n\n### Concerns as Adjectives\n```ruby\nclass Card < ApplicationRecord\n  include Closeable    # can be closed\n  include Assignable   # can be assigned\n  include Taggable     # can be tagged\nend\n```\n\n### Job Pattern\n```ruby\n# Model\ndef notify_later\n  NotifyJob.perform_later(self)\nend\n\ndef notify_now\n  # actual logic\nend\n\n# Job - just a wrapper\nclass NotifyJob < ApplicationJob\n  def perform(record)\n    record.notify_now\n  end\nend\n```\n\n### Data Modeling\n```ruby\n# All tables use UUIDs\ncreate_table :cards, id: :uuid do |t|\n  t.uuid :account_id, null: false  # Multi-tenancy\n  # ...\nend\n\n# No foreign key constraints (app-level integrity)\n# State as separate tables, not booleans\n# Lead indexes with account_id\n```\n\n### Delegated Types (Recording/Recordable)\n```ruby\n# For 5+ content types in unified timelines\nclass Recording < ApplicationRecord\n  delegated_type :recordable, types: %w[Message Document Upload Comment]\nend\n\n# Query the container, not individual types\nproject.recordings.includes(:recordable).chronologically\n```\n\n## Philosophy\n\n> \"Vanilla Rails is plenty\"\n\nThese patterns prove you don't need:\n- Service objects for simple operations\n- Factories (fixtures are faster and clearer)\n- Custom controller actions (extract resources)\n- Complex gems for common patterns\n\nTrust the framework. Keep it simple.\n\n## Contributing\n\nIssues and PRs welcome at https://github.com/zemptime/vanilla-rails\n\n## License\n\nMIT\n",
        "vanilla-rails/commands/shape.md": "| description | Shape a feature: scope it, apply vanilla-rails patterns, produce handoff for implementation planning |\n|-------------|--------------------------------------------------------------------------------------------------------|\n\nInvoke the vanilla-rails:shaping skill and follow it exactly as presented to you.\n",
        "vanilla-rails/skills/controllers/SKILL.md": "---\nname: vanilla-rails-controllers\ndescription: Use when writing Rails controllers, adding controller actions, or implementing state changes (close, archive, publish, assign) - enforces resource extraction instead of custom actions\n---\n\n# Vanilla Rails Controllers\n\n**Core principle:** State changes are resources. Model state changes with CRUD operations on resource controllers, never custom actions.\n\n## When to Use\n\nUse this skill when:\n- Adding any state change to a model (close, archive, publish, assign, follow, etc.)\n- Creating new controller actions\n- Routing state transitions\n\n**Red flags - STOP and extract a resource:**\n- Adding `post :close`, `post :archive`, `patch :activate`\n- Adding custom actions to existing resource routes\n- Thinking \"it's just a boolean toggle\"\n- Time pressure rationalizing \"can refactor later\"\n\n## Resource Extraction Pattern\n\n**The 37signals pattern:** Every state change becomes its own resource controller.\n\n```ruby\n# ❌ BAD - custom actions (typical Rails tutorials)\nresources :cards do\n  post :close\n  post :reopen\n  post :archive\n  post :unarchive\nend\n\n# ✅ GOOD - state as resource (37signals pattern)\nresources :cards do\n  resource :closure, only: [:create, :destroy]\n  resource :archival, only: [:create, :destroy]\nend\n```\n\n**Why singular `resource`?** Each card has at most ONE closure state, ONE archival state. Singular resource = no ID in URL.\n\n**Why `only: [:create, :destroy]`?** Creating resource = entering state. Destroying resource = leaving state.\n\n## Thin Controllers Calling Model Methods\n\nControllers delegate to intention-revealing model API. Keep business logic in models.\n\n```ruby\n# ❌ BAD - ActiveRecord calls in controller\nclass Cards::ArchivalsController < ApplicationController\n  def create\n    @card = Card.find(params[:id])\n    @card.update(archived: true)  # Business logic in controller\n    redirect_to board_cards_path(@card.board)\n  end\nend\n\n# ✅ GOOD - delegate to model\nclass Cards::ArchivalsController < ApplicationController\n  include CardScoped  # Sets @card from params\n\n  def create\n    @card.archive  # Intention-revealing model method\n\n    respond_to do |format|\n      format.turbo_stream\n      format.json { head :no_content }\n    end\n  end\n\n  def destroy\n    @card.unarchive\n\n    respond_to do |format|\n      format.turbo_stream\n      format.json { head :no_content }\n    end\n  end\nend\n```\n\n**Model implements business logic:**\n\n```ruby\nmodule Card::Archivable\n  extend ActiveSupport::Concern\n\n  included do\n    has_one :archival, dependent: :destroy\n    scope :archived, -> { joins(:archival) }\n    scope :active, -> { where.missing(:archival) }\n  end\n\n  def archived?\n    archival.present?\n  end\n\n  def archive(user: Current.user)\n    unless archived?\n      transaction do\n        create_archival! user: user\n        track_event :archived, creator: user\n      end\n    end\n  end\n\n  def unarchive\n    archival&.destroy if archived?\n  end\nend\n```\n\n## Strong Parameters with params.expect()\n\nUse `params.expect()` instead of `params.require().permit()`:\n\n```ruby\n# ❌ BAD - old Rails pattern\ndef card_params\n  params.require(:card).permit(:title, :description, :column_id)\nend\n\n# ✅ GOOD - Rails 8+ params.expect\ndef card_params\n  params.expect(card: [:title, :description, :column_id])\nend\n```\n\n## Common State Resource Patterns\n\n| State Change | Resource Name | create = | destroy = |\n|--------------|---------------|----------|-----------|\n| Close/Reopen | `closure` | close | reopen |\n| Archive/Unarchive | `archival` | archive | unarchive |\n| Pin/Unpin | `pinning` or `pin` | pin | unpin |\n| Publish/Unpublish | `publication` | publish | unpublish |\n| Assign/Unassign | `assignment` | assign | unassign |\n| Follow/Unfollow | `subscription` | subscribe | unsubscribe |\n| Mark/Unmark as golden | `goldness` | gild | ungild |\n\n## Common Rationalizations (STOP)\n\n| Excuse | Reality |\n|--------|---------|\n| \"It's just a boolean toggle - resource is overkill\" | Booleans ARE state. State changes ARE resources. Pattern applies. |\n| \"I've seen `post :close` in Rails guides\" | Standard Rails != 37signals Rails. Follow the codebase pattern. |\n| \"Creating a whole controller adds complexity\" | 15 lines of controller is NOT complex. Clear, intention-revealing code. |\n| \"Time pressure - customer demo tomorrow\" | Writing it wrong takes same time. Doing it right the first time is FASTER. |\n| \"Can refactor to resources later\" | You won't. Do it right now while context is fresh. |\n| \"Direct `update()` is more readable\" | `@card.archive` is MORE readable than `@card.update(archived: true)`. |\n| \"Association/table overhead for a boolean\" | Tracks WHO and WHEN. Enables auditing, activity timeline, proper scopes. Worth it. |\n| \"Migration adds extra step\" | One migration is NOT extra work. It's standard implementation. Do it. |\n\n**All of these mean: Extract resource, delegate to model. No exceptions.**\n\n## Real-World Examples from Fizzy\n\n**Closing cards:**\n```ruby\n# routes.rb\nresources :cards do\n  resource :closure\nend\n\n# app/controllers/cards/closures_controller.rb\nclass Cards::ClosuresController < ApplicationController\n  include CardScoped\n\n  def create\n    @card.close\n    respond_to do |format|\n      format.turbo_stream\n      format.json { head :no_content }\n    end\n  end\n\n  def destroy\n    @card.reopen\n    respond_to do |format|\n      format.turbo_stream\n      format.json { head :no_content }\n    end\n  end\nend\n\n# app/models/card/closeable.rb\nmodule Card::Closeable\n  def close(user: Current.user)\n    unless closed?\n      transaction do\n        create_closure! user: user\n        track_event :closed, creator: user\n      end\n    end\n  end\n\n  def reopen(user: Current.user)\n    if closed?\n      transaction do\n        closure&.destroy\n        track_event :reopened, creator: user\n      end\n    end\n  end\nend\n```\n\n## Implementation Checklist\n\nWhen adding state change to a model:\n\n- [ ] Extract resource (singular if card has one state, plural if many)\n- [ ] Add route: `resource :archival, only: [:create, :destroy]`\n- [ ] Create migration for state table (see Migration Pattern below)\n- [ ] Create resource controller in namespace (e.g., `Cards::ArchivalsController`)\n- [ ] Implement `create` (enter state) and `destroy` (leave state) actions\n- [ ] Controllers delegate to model methods (`@card.archive`, not `@card.update`)\n- [ ] Create model concern with intention-revealing methods\n- [ ] Use `has_one :archival` association for state tracking\n- [ ] Add scopes (`.archived`, `.active`) for querying\n- [ ] Use `params.expect()` for strong parameters (if needed)\n\n## Migration Pattern\n\nState resources need a join table tracking when the state was entered and by whom:\n\n```ruby\n# db/migrate/TIMESTAMP_create_card_archivals.rb\nclass CreateCardArchivals < ActiveRecord::Migration[8.0]\n  def change\n    create_table :card_archivals, id: :uuid do |t|\n      t.uuid :card_id, null: false\n      t.uuid :user_id\n      t.timestamps\n\n      t.index [:card_id], unique: true\n    end\n  end\nend\n```\n\n**Note:** Table name follows pattern: `card_` + plural of resource name\n- `resource :closure` → table `closures` (not `card_closures`)\n- `resource :goldness` → table `card_goldnesses` (prefixed because goldness is namespaced)\n- `resource :archival` → table `card_archivals` (prefixed for clarity)\n\n## Quick Reference\n\n**Naming formula:**\n- Route: `resource :STATE_NAME` (singular)\n- Controller: `Cards::STATE_NAMEsController` (ALWAYS plural - `ClosuresController`, `ArchivalsController`)\n- Controller file: `app/controllers/cards/STATE_NAMEs_controller.rb`\n- Model: `def STATE_VERB` (e.g., `def archive`, `def close`)\n- Association: `has_one :STATE_NAME`\n- Migration: `create_table :card_STATE_NAMEs` or `create_table :STATE_NAMEs`\n\n**Controller template:**\n```ruby\nclass Cards::STATEsController < ApplicationController\n  include CardScoped\n\n  def create\n    @card.enter_state\n    respond_to do |format|\n      format.turbo_stream\n      format.json { head :no_content }\n    end\n  end\n\n  def destroy\n    @card.leave_state\n    respond_to do |format|\n      format.turbo_stream\n      format.json { head :no_content }\n    end\n  end\nend\n```\n",
        "vanilla-rails/skills/data-modeling/SKILL.md": "---\nname: vanilla-rails-data-modeling\ndescription: Use when designing database schema, writing migrations, or making data storage decisions - enforces UUIDs, account_id multi-tenancy, state-as-records, no foreign keys, and proper index patterns\n---\n\n# Vanilla Rails Data Modeling\n\nDatabase schema conventions following production 37signals patterns. Design for multi-tenancy, auditability, and operational flexibility.\n\n## UUID Primary Keys\n\n**All tables use UUIDs** - no auto-incrementing integers.\n\n```ruby\n# ❌ BAD - default integer\ncreate_table :cards do |t|\n  t.string :title\nend\n\n# ✅ GOOD - explicit UUID\ncreate_table :cards, id: :uuid do |t|\n  t.string :title\nend\n```\n\n**UUID format:** UUIDv7 (timestamp-ordered), base36 encoded as 25-character strings.\n\n**Why UUIDs:**\n- No ID enumeration attacks\n- Merge-safe across environments\n- Timestamp ordering preserved (UUIDv7)\n- No sequence contention under load\n\n**Fixture considerations:** Fixtures need deterministic UUIDs that sort \"older\" than runtime records. Use a custom generator based on fixture name hash.\n\n## Multi-Tenancy via account_id\n\n**Every tenant-scoped table has `account_id`** - no exceptions for tables containing user data.\n\n```ruby\ncreate_table :cards, id: :uuid do |t|\n  t.uuid :account_id, null: false  # Always present\n  t.uuid :board_id, null: false\n  t.string :title\n  t.timestamps\nend\n```\n\n**Tables WITHOUT account_id** (global/cross-tenant):\n- `identities` - email addresses span accounts\n- `sessions` - tied to identity, not account\n- `magic_links` - authentication, not tenant data\n\n**Automatic scoping:** Use `Current.account` and ApplicationRecord to scope queries:\n\n```ruby\nclass ApplicationRecord < ActiveRecord::Base\n  def self.default_scope\n    if Current.account\n      where(account_id: Current.account.id)\n    else\n      all\n    end\n  end\nend\n```\n\n**Common mistake:** Forgetting account_id on join tables:\n\n```ruby\n# ❌ BAD - missing account_id\ncreate_table :taggings, id: :uuid do |t|\n  t.uuid :card_id, null: false\n  t.uuid :tag_id, null: false\nend\n\n# ✅ GOOD - includes account_id\ncreate_table :taggings, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.uuid :card_id, null: false\n  t.uuid :tag_id, null: false\nend\n```\n\n## State as Records (NOT Booleans)\n\n**Critical:** Don't use boolean columns for state. Create state records that capture who/when.\n\n```ruby\n# ❌ BAD\nadd_column :cards, :closed, :boolean, default: false\n\n# ✅ GOOD\ncreate_table :closures, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.uuid :card_id, null: false\n  t.uuid :user_id        # who closed it\n  t.timestamps           # when closed\nend\nadd_index :closures, :card_id, unique: true\n```\n\n**State table examples from production:**\n\n| Table | State | Unique Constraint |\n|-------|-------|-------------------|\n| `closures` | card is closed | `card_id` (one per card) |\n| `card_goldnesses` | card is highlighted | `card_id` |\n| `card_not_nows` | card is postponed | `card_id` |\n| `pins` | user pinned card | `[card_id, user_id]` (per user) |\n| `card_activity_spikes` | card has recent activity | `card_id` |\n| `board_publications` | board is public | `board_id` |\n\n**Pattern:** Unique constraint determines has_one vs has_many:\n- `unique: card_id` → `has_one :closure`\n- `unique: [card_id, user_id]` → `has_many :pins` (one per user)\n\n## Index Strategy\n\n**Lead with account_id** in composite indexes for tenant-scoped queries:\n\n```ruby\n# ❌ BAD - account_id not leading\nadd_index :cards, [:status, :account_id]\n\n# ✅ GOOD - account_id leads\nadd_index :cards, [:account_id, :status]\nadd_index :cards, [:account_id, :last_active_at, :status]\n```\n\n**Polymorphic indexes** - always `[type, id]`:\n\n```ruby\nadd_index :events, [:eventable_type, :eventable_id]\nadd_index :mentions, [:source_type, :source_id]\nadd_index :storage_entries, [:recordable_type, :recordable_id]\n```\n\n**Unique constraints** - prevent duplicates at database level:\n\n```ruby\n# Binary state (one per item)\nadd_index :closures, :card_id, unique: true\n\n# Per-user state\nadd_index :pins, [:card_id, :user_id], unique: true\n\n# Tenant-scoped uniqueness\nadd_index :cards, [:account_id, :number], unique: true\nadd_index :tags, [:account_id, :title], unique: true\n```\n\n**Compound query patterns:**\n\n```ruby\n# Timeline queries\nadd_index :events, [:board_id, :action, :created_at]\n\n# Notification queries\nadd_index :notifications, [:user_id, :read_at, :created_at],\n  order: { read_at: :desc, created_at: :desc }\n```\n\n## No Foreign Key Constraints\n\n**Explicitly avoid foreign key constraints** - use application-level integrity.\n\n```ruby\n# ❌ BAD - foreign key constraint\nt.references :card, foreign_key: true\n\n# ✅ GOOD - no constraint\nt.uuid :card_id, null: false\nadd_index :table, :card_id\n```\n\n**Why no foreign keys:**\n- Prevents deadlocks during bulk operations\n- Allows flexible deletion order\n- Simplifies data migrations\n- Production 37signals pattern\n\n**Maintain integrity via:**\n- `dependent: :destroy` in associations\n- Application validations\n- Nullify or cascade in application code\n\n## Join Table Patterns\n\n**Two patterns based on whether join needs its own identity:**\n\n### Pattern 1: Pure HABTM (no ID, no account_id)\n\nUse for simple many-to-many without metadata:\n\n```ruby\n# For filters (saved search criteria)\ncreate_table :boards_filters, id: false do |t|\n  t.uuid :board_id, null: false\n  t.uuid :filter_id, null: false\nend\nadd_index :boards_filters, :board_id\nadd_index :boards_filters, :filter_id\n```\n\n**Naming:** `plural_plural` alphabetically (`assignees_filters`, `boards_filters`)\n\n### Pattern 2: has_many :through (with ID and account_id)\n\nUse when join records need:\n- Their own timestamps\n- Additional metadata\n- Tenant scoping\n- Event tracking\n\n```ruby\ncreate_table :taggings, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.uuid :card_id, null: false\n  t.uuid :tag_id, null: false\n  t.timestamps\nend\nadd_index :taggings, [:card_id, :tag_id], unique: true\n```\n\n**Naming:** Singular noun (`taggings`, `assignments`, `accesses`)\n\n**Decision guide:**\n\n| Need | Pattern |\n|------|---------|\n| Just link two things | `id: false` HABTM |\n| Track when linked | `id: :uuid` with timestamps |\n| Track who linked | Add `user_id` column |\n| Account scoping | Add `account_id` column |\n\n## Polymorphic Associations\n\n**Use meaningful names** that describe the relationship:\n\n| Name | Meaning | Example |\n|------|---------|---------|\n| `eventable` | thing the event is about | Event tracks Card change |\n| `source` | where it came from | Notification from Event |\n| `container` | what holds it | Entropy config for Board |\n| `searchable` | what is searchable | SearchRecord for Card |\n| `recordable` | what it's attached to | StorageEntry for Comment |\n| `owner` | who owns it | StorageTotal for Account |\n\n**Schema pattern:**\n\n```ruby\ncreate_table :events, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.string :eventable_type, null: false\n  t.uuid :eventable_id, null: false\n  # ...\nend\nadd_index :events, [:eventable_type, :eventable_id]\n```\n\n**Model pattern:**\n\n```ruby\nclass Event < ApplicationRecord\n  belongs_to :eventable, polymorphic: true\nend\n\nclass Card < ApplicationRecord\n  has_many :events, as: :eventable\nend\n```\n\n## Counter Caches and Denormalization\n\n**Use manual increment/decrement** - not Rails' `counter_cache:` option:\n\n```ruby\n# In model callback or explicit method\nclass Card < ApplicationRecord\n  after_create :increment_account_counter\n\n  private\n    def increment_account_counter\n      account.increment!(:cards_count)\n    end\nend\n```\n\n**Why manual counters:**\n- More control over when counts update\n- Can batch updates\n- Explicit about side effects\n\n**Denormalized fields examples:**\n- `accounts.cards_count` - avoid COUNT(*) queries\n- `account_join_codes.usage_count` - track usage\n- `search_records.content` - denormalized for fulltext\n\n## Settings and Config Tables\n\n**Polymorphic config with inheritance:**\n\n```ruby\n# entropies table - config for Account OR Board\ncreate_table :entropies, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.string :container_type, null: false  # \"Account\" or \"Board\"\n  t.uuid :container_id, null: false\n  t.bigint :auto_postpone_period, default: 2592000  # 30 days\n  t.timestamps\nend\nadd_index :entropies, [:container_type, :container_id], unique: true\n```\n\n**Fallback pattern:**\n\n```ruby\nclass Board < ApplicationRecord\n  def auto_postpone_period\n    entropy&.auto_postpone_period || account.auto_postpone_period\n  end\nend\n```\n\n**Per-user settings table:**\n\n```ruby\ncreate_table :user_settings, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.uuid :user_id, null: false\n  t.integer :bundle_email_frequency, default: 0\n  t.string :timezone_name\n  t.timestamps\nend\n```\n\n## Migration Conventions\n\n**Prefer `change` method** - Rails handles reversibility:\n\n```ruby\n# ✅ GOOD - reversible\ndef change\n  add_column :cards, :due_on, :date\n  add_index :cards, [:account_id, :due_on]\nend\n```\n\n**Use `up/down` only when needed:**\n\n```ruby\n# When change isn't reversible\ndef up\n  remove_column :cards, :legacy_field\nend\n\ndef down\n  add_column :cards, :legacy_field, :string\nend\n```\n\n**Always specify UUID type for references:**\n\n```ruby\n# ❌ BAD - assumes integer\nt.references :card\n\n# ✅ GOOD - explicit UUID\nt.uuid :card_id, null: false\nadd_index :table, :card_id\n```\n\n**Index separately when table is large:**\n\n```ruby\n# For new tables - inline is fine\ncreate_table :small_table, id: :uuid do |t|\n  t.uuid :card_id, null: false, index: true\nend\n\n# For existing large tables - separate migration\nadd_index :large_table, :new_column, algorithm: :concurrently\n```\n\n## Quick Reference\n\n| Decision | Pattern |\n|----------|---------|\n| Primary key | `id: :uuid` always |\n| Tenant column | `account_id` on all tenant tables |\n| State tracking | Separate table, not boolean |\n| Binary state | `unique: true` on parent_id |\n| Per-user state | `unique: [parent_id, user_id]` |\n| Foreign keys | None - app-level integrity |\n| Simple join | `id: false`, no account_id |\n| Rich join | `id: :uuid`, with account_id |\n| Polymorphic index | `[type, id]` compound |\n| Query index | Lead with `account_id` |\n| Counter cache | Manual `increment!` |\n| Config inheritance | Polymorphic container with fallback |\n\n## Common Mistakes\n\n| Mistake | Fix |\n|---------|-----|\n| Integer primary keys | Use `id: :uuid` |\n| Boolean for state | Create state record table |\n| Missing account_id | Add to all tenant tables |\n| Foreign key constraints | Remove - use app-level |\n| Index without account_id lead | Reorder with account_id first |\n| Rails counter_cache | Use manual increment! |\n| HABTM for tracked joins | Use has_many :through with ID |\n| Generic polymorphic name | Use semantic name (eventable, source) |\n\n## Sharding Pattern (Advanced)\n\nFor large tables, shard by account:\n\n```ruby\n# 16 identical tables\n(0..15).each do |shard|\n  create_table \"search_records_#{shard}\", id: :uuid do |t|\n    t.uuid :account_id, null: false\n    t.text :content\n    # ...\n  end\n  add_index \"search_records_#{shard}\", [:account_key, :content, :title],\n    type: :fulltext\nend\n```\n\n**Shard routing via CRC32:**\n\n```ruby\ndef shard_for(account_id)\n  Zlib.crc32(account_id.to_s) % 16\nend\n```\n\n**Use case:** Fulltext search without Elasticsearch - MySQL native fulltext across 16 shards.\n",
        "vanilla-rails/skills/delegated-types/SKILL.md": "---\nname: vanilla-rails-delegated-types\ndescription: Use when designing content systems where 5+ distinct types need to comingle in feeds, timelines, or searches with shared metadata and operations - NOT for simple polymorphic associations or 1-3 similar types\n---\n\n# Delegated Types (Recording/Recordable Pattern)\n\nA container model (Recording) unifies many content types (Recordables) that share metadata, access control, and operations.\n\n**Core insight:** When many content types must comingle and share behavior, create a unified container rather than duplicating metadata or using complex polymorphic queries.\n\n## When to Use\n\n```dot\ndigraph decision {\n    \"How many content types?\" [shape=diamond];\n    \"Do they comingle in UI?\" [shape=diamond];\n    \"Share metadata/operations?\" [shape=diamond];\n    \"Direct associations\" [shape=box];\n    \"Delegated types\" [shape=box];\n    \"Consider merging types\" [shape=box];\n\n    \"How many content types?\" -> \"Direct associations\" [label=\"1-2\"];\n    \"How many content types?\" -> \"Do they comingle in UI?\" [label=\"3-4\"];\n    \"How many content types?\" -> \"Share metadata/operations?\" [label=\"5+\"];\n    \"Do they comingle in UI?\" -> \"Consider merging types\" [label=\"rarely\"];\n    \"Do they comingle in UI?\" -> \"Share metadata/operations?\" [label=\"often\"];\n    \"Share metadata/operations?\" -> \"Direct associations\" [label=\"no\"];\n    \"Share metadata/operations?\" -> \"Delegated types\" [label=\"yes\"];\n}\n```\n\n**Use when:**\n- 5+ content types (Messages, Documents, Uploads, Comments, etc.)\n- Types appear together in feeds, timelines, activity streams\n- Shared metadata: project, creator, timestamps, access control\n- Common operations: copy, move, archive, search across all types\n- Single query needed: \"all content in project X sorted by date\"\n\n**Don't use when:**\n- Only 1-3 types (use direct associations)\n- Types are similar enough to merge (see flattening.md)\n- Types don't comingle in UI\n- No shared metadata or operations\n\n## Quick Reference\n\n| Decision | Answer |\n|----------|--------|\n| 1-2 content types | Direct associations |\n| 3-4 types, rarely comingle | Consider merging or direct |\n| 3-4 types, often comingle | Maybe delegated types |\n| 5+ types, shared metadata | Delegated types |\n| Only 1 type left | Flatten (see flattening.md) |\n| Container adds no value | Flatten |\n\n## Difference from Simple Polymorphic\n\n| Aspect | Simple Polymorphic | Delegated Types |\n|--------|-------------------|-----------------|\n| Query target | Each concrete type | Recording (container) |\n| Shared metadata | Duplicated in each table | Once in Recording |\n| Pagination | Complex (merge in Ruby) | Natural (query Recording) |\n| Access control | Per-type | On Recording |\n\n## Sub-Documents\n\n- **implementing.md** - Two-layer pattern (Bucket + Recording), schema, models, querying\n- **flattening.md** - When to remove delegated types, PR 445 example, signals\n\n## Real-World Usage\n\n**Basecamp uses this for:** Messages, Documents, Uploads, Comments, Todos - unified project timeline with shared access control and operations.\n\n**Fizzy removed it:** When only Comments remained after merging EventSummary (see flattening.md).\n",
        "vanilla-rails/skills/delegated-types/flattening.md": "# Flattening Delegated Types\n\nWhen the abstraction no longer pays for itself, remove it.\n\n## When to Flatten\n\n**Flatten when:**\n- Only 1-2 recordable types remain\n- Types are similar enough to merge\n- Container adds complexity without value\n- Queries get simpler without indirection\n\n**Signals to flatten:**\n- \"This container just wraps one type\"\n- \"These types could share a table with a type column\"\n- \"The indirection makes code harder to follow\"\n\n## Real Example: Fizzy PR 445\n\nFizzy had a `Message` container with delegated types to `Comment` and `EventSummary`. It was flattened to just `Comments`.\n\n**Why flattened:**\n- Only 2 types (Comment, EventSummary)\n- EventSummary was conceptually \"system-generated Comment\"\n- Container added complexity without enough benefit\n\n### Before (with delegated types)\n\n```ruby\nclass Message < ApplicationRecord\n  delegated_type :messageable, types: %w[Comment EventSummary]\n  belongs_to :card\nend\n\nclass Comment < ApplicationRecord\n  include Messageable  # has_one :message, has_one :card through: :message\nend\n\nclass EventSummary < ApplicationRecord\n  include Messageable\n  has_many :events\nend\n\n# Usage\n@card.capture Comment.new(comment_params)\n@card.messages.chronologically  # unified timeline\n```\n\n### After (flattened)\n\n```ruby\nclass Comment < ApplicationRecord\n  belongs_to :card\n  belongs_to :creator, class_name: \"User\"\n\n  scope :by_system, -> { joins(:creator).where(creator: { role: :system }) }\n  scope :by_user, -> { joins(:creator).where.not(creator: { role: :system }) }\n  scope :chronologically, -> { order(created_at: :asc) }\nend\n\n# Usage\n@card.comments.create!(comment_params)\n@card.comments.chronologically  # same unified timeline, simpler\n```\n\n### What Changed\n\n| Aspect | Before | After |\n|--------|--------|-------|\n| Tables | messages, comments, event_summaries | comments |\n| Models | 3 | 1 |\n| Indirection | Message → Messageable | Direct |\n| System comments | EventSummary type | `creator.role == :system` |\n| Query | `card.messages` | `card.comments` |\n\n### Migration\n\n```ruby\nclass FlattenMessagesAndComments < ActiveRecord::Migration[8.1]\n  def change\n    add_reference :comments, :card, null: true\n\n    execute <<~SQL\n      UPDATE comments\n      SET card_id = (\n        SELECT messages.card_id\n        FROM messages\n        WHERE messages.messageable_type = 'Comment'\n          AND messages.messageable_id = comments.id\n        LIMIT 1\n      )\n    SQL\n\n    change_column_null :comments, :card_id, false\n    drop_table :messages\n  end\nend\n```\n\n## Decision Framework\n\n```dot\ndigraph flatten_decision {\n    \"How many recordable types?\" [shape=diamond];\n    \"Types diverging?\" [shape=diamond];\n    \"Container adds value?\" [shape=diamond];\n    \"Keep delegated types\" [shape=box];\n    \"Flatten\" [shape=box];\n\n    \"How many recordable types?\" -> \"Flatten\" [label=\"1\"];\n    \"How many recordable types?\" -> \"Types diverging?\" [label=\"2-3\"];\n    \"How many recordable types?\" -> \"Keep delegated types\" [label=\"4+\"];\n    \"Types diverging?\" -> \"Keep delegated types\" [label=\"yes\"];\n    \"Types diverging?\" -> \"Container adds value?\" [label=\"no\"];\n    \"Container adds value?\" -> \"Keep delegated types\" [label=\"yes\"];\n    \"Container adds value?\" -> \"Flatten\" [label=\"no\"];\n}\n```\n\n## Common Flattening Patterns\n\n### Pattern 1: Merge similar types\n\nEventSummary → system-generated Comment (distinguished by creator role)\n\n### Pattern 2: Use STI instead\n\nIf types share most fields but differ in behavior:\n\n```ruby\nclass TimelineEntry < ApplicationRecord\n  # STI with type column\nend\n\nclass Comment < TimelineEntry\nend\n\nclass SystemEvent < TimelineEntry\nend\n```\n\n### Pattern 3: Direct association\n\nIf only one recordable type remains:\n\n```ruby\n# Before: Card → Recording → Comment\n# After: Card → Comment (direct)\n\nclass Card < ApplicationRecord\n  has_many :comments, dependent: :destroy\nend\n```\n\n## Red Flags: Don't Flatten\n\n**Keep delegated types if:**\n- Types are genuinely different (different fields, different behavior)\n- You expect more types to be added\n- Container provides real value (access control, unified operations)\n- Flattening would create a wide table with many nullable columns\n",
        "vanilla-rails/skills/delegated-types/implementing.md": "# Implementing Delegated Types\n\n## The Pattern: Two Layers\n\n### Layer 1: Bucket (Container for Recordings)\n\nA **Bucket** is what holds recordings. Examples: Project, Template, Channel.\n\n```ruby\nclass Bucket < ApplicationRecord\n  delegated_type :bucketable, types: %w[Project Template Channel]\n  has_many :recordings, dependent: :destroy\nend\n\nclass Project < ApplicationRecord\n  has_one :bucket, as: :bucketable, touch: true\n  delegate :recordings, to: :bucket\nend\n```\n\n**When to use Bucket layer:**\n- Multiple container types (Project, Template, Channel) need unified recording access\n- Access control lives at container level\n\n**When to skip Bucket:**\n- Only one container type (just use `Project has_many :recordings` directly)\n\n### Layer 2: Recording (Container for Recordables)\n\n**Recording** is the unified content wrapper holding shared metadata:\n\n```ruby\nclass Recording < ApplicationRecord\n  belongs_to :bucket  # or belongs_to :project if skipping Bucket layer\n  belongs_to :creator, class_name: \"User\"\n\n  delegated_type :recordable, types: %w[Message Document Upload Comment]\n\n  # Shared metadata lives here, NOT duplicated in each recordable\n  # bucket_id, creator_id, created_at, archived_at, etc.\n\n  scope :chronologically, -> { order(created_at: :desc) }\n  scope :active, -> { where(archived_at: nil) }\nend\n```\n\n### Layer 3: Recordables (Concrete Content Types)\n\nEach **Recordable** holds only type-specific fields:\n\n```ruby\nclass Message < ApplicationRecord\n  has_one :recording, as: :recordable, touch: true\n  has_rich_text :body\n\n  # Only message-specific: subject, body\n  # NOT: project_id, creator_id (those live on Recording)\nend\n\nclass Document < ApplicationRecord\n  has_one :recording, as: :recordable, touch: true\n  has_rich_text :content\n\n  # Only document-specific: title, content, version\nend\n\nclass Upload < ApplicationRecord\n  has_one :recording, as: :recordable, touch: true\n  has_one_attached :file\n\n  # Only upload-specific: filename, file attachment\nend\n```\n\n## Schema\n\n```ruby\n# Optional: Bucket layer for multiple container types\ncreate_table :buckets, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.string :bucketable_type, null: false\n  t.uuid :bucketable_id, null: false\n  t.timestamps\nend\nadd_index :buckets, [:bucketable_type, :bucketable_id], unique: true\n\n# Recording: the unified container\ncreate_table :recordings, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.uuid :bucket_id, null: false        # or project_id if no Bucket layer\n  t.uuid :creator_id, null: false\n  t.string :recordable_type, null: false\n  t.uuid :recordable_id, null: false\n  t.datetime :archived_at\n  t.timestamps\nend\nadd_index :recordings, [:recordable_type, :recordable_id], unique: true\nadd_index :recordings, [:bucket_id, :created_at]\n\n# Recordables: NO shared metadata columns\ncreate_table :messages, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.string :subject\n  t.timestamps\nend\n\ncreate_table :documents, id: :uuid do |t|\n  t.uuid :account_id, null: false\n  t.string :title\n  t.timestamps\nend\n```\n\n## Querying: Recording is the Target\n\n**This is the key difference from simple polymorphic:**\n\n```ruby\n# Simple polymorphic: query each type, merge in Ruby (slow, no pagination)\nmessages = project.messages.where(...)\ndocuments = project.documents.where(...)\nall_content = (messages + documents).sort_by(&:created_at)\n\n# Delegated types: query Recording, eager load recordable\nproject.recordings\n  .includes(:recordable)\n  .chronologically\n  .limit(50)  # Pagination works naturally\n```\n\n**Recording is the query target.** Unified pagination, sorting, filtering for free.\n\n## Cross-Cutting Capabilities\n\nRecording can include concerns that all recordables share:\n\n```ruby\nmodule Recording::Commentable\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :comments, as: :commentable\n  end\nend\n\nmodule Recording::Subscribable\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :subscriptions\n  end\n\n  def subscribe(user)\n    subscriptions.find_or_create_by!(user: user)\n  end\nend\n\nclass Recording < ApplicationRecord\n  include Commentable, Subscribable, Archivable, Copyable\nend\n```\n\n**Recording provides the API**, delegates type-specific rendering to recordables.\n\n## Common Operations\n\n```ruby\nclass Recording < ApplicationRecord\n  def copy_to(target_bucket)\n    transaction do\n      new_recordable = recordable.dup\n      new_recordable.save!\n\n      recordings.create!(\n        bucket: target_bucket,\n        creator: Current.user,\n        recordable: new_recordable\n      )\n    end\n  end\n\n  def move_to(target_bucket)\n    update!(bucket: target_bucket)\n  end\n\n  def archive\n    update!(archived_at: Time.current)\n  end\nend\n```\n\n## View Rendering\n\n```erb\n<% @recordings.each do |recording| %>\n  <div class=\"timeline-entry\">\n    <div class=\"meta\">\n      <%= recording.creator.name %> · <%= time_ago_in_words(recording.created_at) %>\n    </div>\n    <%= render recording.recordable %>\n  </div>\n<% end %>\n```\n\nEach recordable provides its own partial (`messages/_message.html.erb`, etc.).\n",
        "vanilla-rails/skills/hotwire/SKILL.md": "---\nname: vanilla-rails-hotwire\ndescription: Use when writing Hotwire (Turbo/Stimulus) code in Rails - enforces dom_id helpers, morph updates, focused Stimulus controllers, and JavaScript private methods\n---\n\n# Vanilla Rails Hotwire\n\n37signals conventions for Hotwire beyond the official documentation.\n\n## Turbo Streams\n\n### ALWAYS Use dom_id Helper (NEVER String Interpolation)\n\n**WRONG:**\n```erb\n<%= turbo_stream.replace \"card_#{@card.id}\" do %>\n```\n\n**RIGHT:**\n```erb\n<%# Both syntaxes acceptable %>\n<%= turbo_stream.replace dom_id(@card) do %>\n<%= turbo_stream.replace [ @card ] do %>\n```\n\n### Use Prefixes for Targetable Sections\n\nPrefixed dom_id enables granular updates to specific parts:\n\n```ruby\ndom_id(@card)                    # \"card_abc123\"\ndom_id(@card, :header)           # \"header_card_abc123\"\ndom_id(@card, :comments)         # \"comments_card_abc123\"\ndom_id(@card, :status_badge)     # \"status_badge_card_abc123\"\n\n# Array syntax (Rails shorthand)\n[ @card, :header ]               # Same as dom_id(@card, :header)\n```\n\n**Example:**\n```erb\n<%= turbo_stream.replace dom_id(@card, :status_badge), method: :morph do %>\n  <%= render \"cards/status_badge\", card: @card %>\n<% end %>\n```\n\n### ALWAYS Use method: :morph for Updates\n\nMorph avoids layout shift and preserves scroll position.\n\n**WRONG:**\n```erb\n<%= turbo_stream.replace dom_id(@card) do %>\n  <%= render @card %>\n<% end %>\n```\n\n**RIGHT:**\n```erb\n<%= turbo_stream.replace dom_id(@card), method: :morph do %>\n  <%= render @card %>\n<% end %>\n```\n\n**When to use morph:**\n- Updating existing content (cards, comments, headers)\n- Replacing sections that users might be reading\n- Any update where layout shift would be jarring\n\n**When NOT to use morph:**\n- Adding new items to lists (use `append`/`prepend`)\n- Removing items (use `remove`)\n- First-time rendering\n\n## Stimulus Controllers\n\n### Keep Controllers Small and Focused\n\n**One purpose per controller.** Split large controllers.\n\n**WRONG:**\n```javascript\n// card_controller.js - does too much\nexport default class extends Controller {\n  connect() { }\n  fadeIn() { }\n  handleClick() { }\n  validateForm() { }\n  submitForm() { }\n  showNotification() { }\n}\n```\n\n**RIGHT:**\n```javascript\n// status_animation_controller.js - focused\nexport default class extends Controller {\n  connect() {\n    this.#fadeIn()\n  }\n\n  #fadeIn() {\n    // Use CSS transitions, minimal JS\n    this.element.classList.add('fade-in')\n  }\n}\n```\n\n### ALWAYS Mark Private Methods and Fields with # Prefix\n\nUse JavaScript private fields syntax for methods/fields not called from HTML.\n\n**WRONG:**\n```javascript\nexport default class extends Controller {\n  debounceTimer = null  // Public field (shouldn't be)\n\n  copy() {\n    navigator.clipboard.writeText(this.sourceTarget.value)\n    this.showNotification()  // Public method (shouldn't be)\n  }\n\n  showNotification() {\n    this.element.classList.add('success')\n  }\n}\n```\n\n**RIGHT:**\n```javascript\nexport default class extends Controller {\n  #debounceTimer = null  // Private field\n\n  copy() {\n    navigator.clipboard.writeText(this.sourceTarget.value)\n    this.#showNotification()\n  }\n\n  #showNotification() {\n    this.element.classList.add('success')\n  }\n}\n```\n\n### Decision Tree: Public vs Private\n\nAsk yourself: **\"Is this method called from HTML via data-action?\"**\n\n- **YES** → Keep it public (no #)\n- **NO** → Make it private (#)\n\n**Public methods:** Only those in `data-action=\"controller#method\"` OR Stimulus lifecycle methods\n\n**Private methods:** Everything else - helpers, callbacks, utilities\n\n**Example:**\n```html\n<!-- This means mouseEnter and mouseLeave are public -->\n<div data-controller=\"preview\"\n     data-action=\"mouseenter->preview#mouseEnter mouseleave->preview#mouseLeave\">\n```\n\n```javascript\nexport default class extends Controller {\n  // Public - called from data-action\n  mouseEnter() { this.#show() }\n  mouseLeave() { this.#hide() }\n\n  // Public - Stimulus lifecycle (framework calls these)\n  connect() { this.#initialize() }\n  disconnect() { this.#cleanup() }\n\n  // Private - only called internally\n  #initialize() { }\n  #cleanup() { }\n  #show() { }\n  #hide() { }\n  #fetch() { }\n}\n```\n\n**Stimulus lifecycle methods** (always public, no #):\n- `connect()`, `disconnect()`\n- `[name]TargetConnected()`, `[name]TargetDisconnected()`\n- `[name]ValueChanged()`\n\n### Red Flags - Methods That Should Be Private\n\nIf you write any of these without `#`, STOP:\n\n- Helper methods: `show`, `hide`, `toggle`, `clear`, `reset`, `update`\n- Fetch/API methods: `fetch`, `load`, `save`, `submit`\n- Callback methods called only from `connect()` or other methods\n- Any method not referenced in HTML `data-action`\n\n**Check:** Search your HTML for `data-action`. If the method isn't there, add `#`.\n\n### NO Business Logic in Stimulus\n\nControllers coordinate UI behavior only. No data transformations, validations, or domain logic.\n\n**WRONG:**\n```javascript\nexport default class extends Controller {\n  submit() {\n    // Don't validate/transform data in JS\n    if (this.priceValue < 0) {\n      this.priceValue = 0\n    }\n    this.element.submit()\n  }\n}\n```\n\n**RIGHT:**\n```javascript\nexport default class extends Controller {\n  submit() {\n    // Just coordinate the UI\n    this.element.submit()\n  }\n}\n```\n\nLet Rails controllers and models handle business logic.\n\n## View Organization\n\n### Container Pattern for Granular Updates\n\nStructure partials with prefixed dom_id for targetable sections:\n\n```erb\n<%# app/views/cards/_card.html.erb %>\n<article id=\"<%= dom_id(card) %>\" class=\"card\">\n  <div id=\"<%= dom_id(card, :status) %>\">\n    <%= render \"cards/status\", card: card %>\n  </div>\n\n  <div id=\"<%= dom_id(card, :header) %>\">\n    <%= render \"cards/header\", card: card %>\n  </div>\n\n  <div id=\"<%= dom_id(card, :comments) %>\">\n    <%= render \"cards/comments\", card: card %>\n  </div>\n</article>\n```\n\nThis enables targeted updates:\n\n```erb\n<%# app/views/cards/closures/create.turbo_stream.erb %>\n<%= turbo_stream.replace dom_id(@card, :status), method: :morph do %>\n  <%= render \"cards/status\", card: @card %>\n<% end %>\n```\n\n## Common Violations\n\n| Violation | Fix |\n|-----------|-----|\n| `\"card_#{@card.id}\"` | `dom_id(@card)` or `[ @card ]` |\n| `turbo_stream.replace dom_id(@card)` | `turbo_stream.replace dom_id(@card), method: :morph` |\n| `fadeIn() { }` | `#fadeIn() { }` |\n| `debounceTimer = null` | `#debounceTimer = null` |\n| Animation logic in Stimulus | Use CSS transitions, minimal JS |\n| One controller doing many things | Split into focused controllers |\n| Validations in Stimulus | Move to Rails models/controllers |\n| Helper methods without # | Add # to all helpers not in data-action |\n\n## Quick Reference\n\n**Turbo Stream with morph:**\n```erb\n<%= turbo_stream.replace dom_id(@record, :section), method: :morph do %>\n  <%= render \"partial\", record: @record %>\n<% end %>\n```\n\n**Stimulus with private methods and fields:**\n```javascript\nexport default class extends Controller {\n  #privateField = null\n\n  publicAction() {\n    this.#privateHelper()\n  }\n\n  #privateHelper() {\n    // Implementation\n  }\n}\n```\n\n**View containers:**\n```erb\n<div id=\"<%= dom_id(record, :prefix) %>\">\n  <%= render \"partial\", record: record %>\n</div>\n```\n",
        "vanilla-rails/skills/jobs/SKILL.md": "---\nname: vanilla-rails-jobs\ndescription: Use when writing background jobs or async operations - enforces thin job wrappers (3-5 lines) that delegate to models using _later/_now naming pattern\n---\n\n# Vanilla Rails Jobs\n\n**Jobs are thin wrappers (3-5 lines). ALL business logic lives in models.**\n\n## The Pattern\n\n```ruby\n# Model concern - WHERE THE LOGIC LIVES\nmodule Card::ClosureNotifications\n  extend ActiveSupport::Concern\n\n  included do\n    after_update :notify_watchers_later, if: :just_closed?\n  end\n\n  # _later: Enqueues the job\n  def notify_watchers_later\n    Card::ClosureNotificationJob.perform_later(self)\n  end\n\n  # _now: Contains ALL business logic\n  def notify_watchers_now\n    watchers.each do |watcher|\n      CardMailer.closure_notification(watcher, self).deliver_now\n      Notification.create!(user: watcher, card: self, action: 'closed')\n    end\n  end\n\n  private\n    def just_closed?\n      saved_change_to_status? && closed?\n    end\nend\n\n# Job - ONLY delegates (3 lines)\nclass Card::ClosureNotificationJob < ApplicationJob\n  def perform(card)\n    card.notify_watchers_now\n  end\nend\n```\n\n## Why Jobs Stay Thin\n\n**Testability:** Test `_now` synchronously (no job infrastructure needed)\n**Reusability:** Call `_now` in console, tests, anywhere\n**Debuggability:** Stack traces point to model, not job framework\n\n## Naming Convention\n\n| Method | Purpose |\n|--------|---------|\n| `action_later` | Enqueues job |\n| `action_now` | Actual logic (called by job, ALWAYS create for testing) |\n| `action` | No async version |\n\n**Flow:** Callback → `_later` → enqueue job → job calls `_now` → logic executes\n\n## Red Flags - STOP and Fix\n\nIf you see ANY of these, you're doing it wrong:\n\n- [ ] Job longer than 5 lines (except ActiveJob config like `retry_on`)\n- [ ] Business logic in job (queries, conditionals, loops)\n- [ ] Job creates/updates records\n- [ ] Job sends emails directly\n- [ ] Job calls multiple models directly\n- [ ] No `_later`/`_now` naming\n- [ ] Passing IDs to job instead of objects\n- [ ] Logic split between job and model\n- [ ] Job has error handling beyond `retry_on`/`discard_on`\n- [ ] Model missing `_now` method (\"I don't need it\")\n\n**ALL of these mean: Move logic to model. Job should only delegate.**\n\n## Common Mistakes\n\n| Wrong | Right | Why |\n|-------|-------|-----|\n| Logic in job | Logic in model | Jobs = thin wrappers |\n| `perform(card_id)` then `Card.find` | `perform(card)` | Let ActiveJob serialize |\n| 20+ line job | 3-5 line job | Logic belongs in domain model |\n| `send_notifications` | `send_notifications_later` | Naming shows async intent |\n| Job has conditionals | Model has conditionals | Domain logic in domain model |\n\n## Examples: Wrong vs Right\n\n### ❌ WRONG: Fat job with business logic\n```ruby\nclass Card::ClosureNotificationJob < ApplicationJob\n  def perform(card_id, closer_id)\n    card = Card.find(card_id)\n    card.watchers.each do |watcher|\n      CardMailer.closure_notification(watcher, card).deliver_now\n      Notification.create!(user: watcher, card: card, action: 'closed')\n    end\n    card.update!(last_notification_sent_at: Time.current)\n  end\nend\n```\n\n**Problems:** 12 lines of logic, re-queries by ID, hard to test, not reusable, no `_later`/`_now`\n\n### ✅ RIGHT: Thin job delegates to model\n```ruby\n# Job (3 lines)\nclass Card::ClosureNotificationJob < ApplicationJob\n  def perform(card)\n    card.notify_watchers_now\n  end\nend\n\n# Model (where logic belongs)\ndef notify_watchers_later\n  Card::ClosureNotificationJob.perform_later(self)\nend\n\ndef notify_watchers_now\n  watchers.each do |watcher|\n    CardMailer.closure_notification(watcher, self).deliver_now\n    Notification.create!(user: watcher, card: self, action: 'closed')\n  end\n  update_column(:last_notification_sent_at, Time.current)\nend\n```\n\n**Benefits:** Job is 3 lines, testable without jobs, reusable in console\n\n## Common Rationalizations (All Wrong)\n\n| Excuse | Reality |\n|--------|---------|\n| \"Jobs are meant to contain async work logic\" | Jobs are infrastructure. Models contain business logic. |\n| \"Notification logic belongs in notification job\" | Domain logic belongs in domain models, not infrastructure. |\n| \"Models shouldn't know about email delivery\" | Models orchestrate their domain. Mailers handle delivery details. |\n| \"This follows separation of concerns\" | Concern = business vs infrastructure, not job vs model. |\n| \"The _later/_now pattern adds indirection\" | It adds clarity and reusability. Worth it. |\n| \"Most Rails apps structure jobs this way\" | We follow vanilla Rails: rich models, thin everything else. |\n| \"30 lines is small for a job\" | 30 lines is huge. Jobs should be 3-5 lines. |\n| \"Keeps models thin\" | Models should be rich. Jobs should be thin. |\n| \"This spans multiple models, no natural home\" | Primary model orchestrates. See multi-model example. |\n| \"This is a utility job, no model exists\" | Use class methods on relevant model. See cleanup example. |\n| \"Error handling belongs in jobs\" | Use ActiveJob retries. Domain errors in models. |\n| \"I don't need _now for this\" | You need it for testing. Always create _now. |\n| \"This calls external APIs, not domain logic\" | API integration IS domain logic. Model orchestrates. |\n\n## Edge Cases\n\n### Multi-Model: Primary model orchestrates\n```ruby\nclass User::DigestJob < ApplicationJob\n  def perform(user); user.send_digest_now; end\nend\n\ndef send_digest_now\n  cards = boards.flat_map { |b| b.cards.mine(self) }\n  DigestMailer.send(self, cards).deliver_now\nend\n```\n\n### Utility/Cleanup: Use class methods\n```ruby\nclass Session::CleanupJob < ApplicationJob\n  def perform; Session.cleanup_expired_now; end\nend\n\ndef self.cleanup_expired_now\n  where(\"created_at < ?\", 30.days.ago).delete_all\nend\n```\n\n### Error Handling: ActiveJob retries + model errors\n```ruby\nclass Card::SyncJob < ApplicationJob\n  retry_on ExternalAPI::Error, wait: 5.minutes\n  def perform(card); card.sync_to_external_system_now; end\nend\n\ndef sync_to_external_system_now\n  ExternalAPI.update_task(external_id, attributes)\nrescue ExternalAPI::Error => e\n  errors.add(:base, \"Sync failed: #{e.message}\")\n  raise\nend\n```\n\n## When You're About to Violate This\n\n**STOP if you're thinking:**\n- \"I'll put the logic in the job because it's async work\"\n- \"This job needs to query/update records\"\n- \"The model would get too big\"\n- \"It's clearer to have everything in one place\"\n- \"I don't need the _later/_now pattern for this simple case\"\n- \"This spans multiple models, no natural home\"\n- \"This is a utility job, no model exists\"\n- \"Error handling belongs in jobs\"\n- \"I don't need _now because I won't call it directly\"\n\n**ALL of these mean: You're about to write a fat job. Stop. Put logic in model.**\n\n## Quick Check\n\nGood job checklist:\n- [ ] 3-5 lines total\n- [ ] Only calls one model method\n- [ ] Receives model instance (not ID)\n- [ ] No queries, conditionals, or loops\n- [ ] Model has `_later` method\n- [ ] Model has `_now` method with logic (ALWAYS, even if only async path)\n\nIf ANY checkbox fails, refactor: move logic to model.\n",
        "vanilla-rails/skills/models/SKILL.md": "---\nname: vanilla-rails-models\ndescription: Use when writing Rails models - enforces state-as-records not booleans, concerns as adjectives namespaced under model, invocation ordering, and private indentation\n---\n\n# Vanilla Rails Models\n\nRich domain models with concerns, following production Basecamp/37signals patterns. Decompose with concerns, not services.\n\n## State as Separate Records (NOT Booleans)\n\n**Critical pattern:** Don't use boolean columns for state. Create state records that capture who/when.\n\n```ruby\n# ❌ BAD - boolean column\nclass AddStarredToCards < ActiveRecord::Migration[7.0]\n  def change\n    add_column :cards, :starred, :boolean, default: false\n    add_column :cards, :starred_at, :datetime\n  end\nend\n\nclass Card < ApplicationRecord\n  def star\n    update(starred: true, starred_at: Time.current)\n  end\nend\n\n# ✅ GOOD - state record\nclass CreateStars < ActiveRecord::Migration[7.0]\n  def change\n    create_table :stars, id: :uuid do |t|\n      t.references :card, null: false, foreign_key: true, type: :uuid\n      t.references :user, null: false, foreign_key: true, type: :uuid\n      t.timestamps\n    end\n  end\nend\n\nclass Star < ApplicationRecord\n  belongs_to :card\n  belongs_to :user\nend\n\nclass Card < ApplicationRecord\n  has_one :star, dependent: :destroy\n\n  def star(user: Current.user)\n    create_star!(user: user) unless starred?\n  end\n\n  def starred?\n    star.present?\n  end\nend\n```\n\n**Why state records:**\n- Captures who (user) and when (created_at) automatically\n- Can add metadata later without altering main table\n- Explicit presence/absence vs true/false ambiguity\n- Database enforces referential integrity\n\n**Use has_one for binary state, has_many for multi-user:**\n\n```ruby\n# Binary state (one per item) - use has_one\nhas_one :closure    # card is either closed or not\nhas_one :triage     # card is either triaged or not\n\n# Multi-user actions - use has_many\nhas_many :pins      # multiple users can pin\nhas_many :watches   # multiple users can watch\nhas_many :assignments\n```\n\n**Common rationalizations to reject:**\n\n| Excuse | Reality |\n|--------|---------|\n| \"Boolean is simpler\" | State records capture metadata you'll need later |\n| \"Just a flag\" | Today's flag is tomorrow's \"who changed this and when?\" |\n| \"YAGNI\" | Capturing who/when is always valuable for state changes |\n| \"Extra table is overkill\" | This is the 37signals pattern. Follow it. |\n\n## Concerns as Adjectives, Namespaced Under Model\n\n**Extract capabilities to concerns** - even for single use. Concerns are for decomposition, not just reuse.\n\n**Name as adjectives** (capabilities), namespace under the model:\n\n```ruby\n# ❌ BAD - wrong names\nmodule Starring          # verb, not adjective\nmodule Stars             # noun, not adjective\nmodule Starrable         # not namespaced under model\nmodule Starred           # past participle, describes state not capability\n\n# ✅ GOOD - adjective, namespaced\nmodule Card::Starrable   # adjective, shows Card owns this capability\nmodule Card::Closeable   # can be closed\nmodule Card::Assignable  # can be assigned\nmodule Card::Pinnable    # can be pinned\n```\n\n**File location:** `app/models/card/starrable.rb` (NOT `app/models/concerns/starrable.rb`)\n\n**Full example with private methods:**\n\n```ruby\n# app/models/card/closeable.rb\nmodule Card::Closeable\n  extend ActiveSupport::Concern\n\n  included do\n    has_one :closure, dependent: :destroy\n\n    scope :closed, -> { joins(:closure) }\n    scope :open, -> { where.missing(:closure) }\n  end\n\n  def close(user: Current.user)\n    unless closed?\n      transaction do\n        create_closure!(user: user)\n        track_event :closed, creator: user\n      end\n    end\n  end\n\n  def reopen(user: Current.user)\n    if closed?\n      transaction do\n        closure&.destroy\n        track_event :reopened, creator: user\n      end\n    end\n  end\n\n  def closed?\n    closure.present?\n  end\n\n  def closed_by\n    closure&.user\n  end\n\n  private\n    def track_event(action, creator:)\n      # private helper methods go in concern, indented\n    end\nend\n\n# app/models/card.rb\nclass Card < ApplicationRecord\n  include Card::Closeable\n  # ... rest of model\nend\n```\n\n**Multi-user state example:**\n\n```ruby\n# app/models/card/pinnable.rb\nmodule Card::Pinnable\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :pins, dependent: :destroy\n  end\n\n  def pinned_by?(user)\n    pins.exists?(user: user)\n  end\n\n  def pin_by(user)\n    pins.find_or_create_by!(user: user)\n  end\n\n  def unpin_by(user)\n    pins.find_by(user: user)&.destroy\n  end\nend\n```\n\n**When to extract:**\n- Feature adds 3+ methods to model\n- Clear capability/adjective name exists\n- Even if only one model uses it (decomposition, not reuse)\n- Model exceeds ~100 lines\n\n**Common mistakes:**\n\n```ruby\n# ❌ BAD - verb names\nCard::Closing, Card::Assigning\n\n# ✅ GOOD - adjective names\nCard::Closeable, Card::Assignable\n\n# ❌ BAD - past participle (describes state)\nCard::Assigned, Card::Closed\n\n# ✅ GOOD - adjective (describes capability)\nCard::Assignable, Card::Closeable\n\n# ❌ BAD - not namespaced\nStarrable, Closeable\n\n# ✅ GOOD - namespaced under model\nCard::Starrable, Card::Closeable\n```\n\n## Method Ordering by Invocation\n\nOrder methods vertically by invocation: callers before callees.\n\n```ruby\nclass Card < ApplicationRecord\n  def close(user: Current.user)\n    transaction do\n      create_closure!(user: user)\n      notify_watchers  # called here\n    end\n  end\n\n  private\n    def notify_watchers  # defined after caller\n      watchers.each { |w| notify_user(w) }\n    end\n\n    def notify_user(user)  # defined after its caller\n      # ...\n    end\nend\n```\n\n**Benefit:** Read top-to-bottom following execution flow.\n\n## Private Method Indentation\n\nIndent private methods under the `private` keyword (no newline after `private`):\n\n```ruby\nclass Card < ApplicationRecord\n  def public_method\n    # ...\n  end\n\n  private\n    def private_method_one\n      # indented\n    end\n\n    def private_method_two\n      # indented\n    end\nend\n```\n\n**In concerns:** Same pattern - private methods indented under `private`\n\n```ruby\nmodule Card::Closeable\n  def close\n    create_closure!\n    notify_team\n  end\n\n  private\n    def notify_team\n      # indented under private\n    end\nend\n```\n\n**Exception:** Module with only private methods - mark `private` at top, add newline, don't indent:\n\n```ruby\nmodule Card::Internal\n  private\n\n  def helper_method\n    # not indented\n  end\nend\n```\n\n## Class Method Ordering\n\n1. Class methods first\n2. Public instance methods (with `initialize` at top if present)\n3. Private instance methods\n\n```ruby\nclass Card < ApplicationRecord\n  def self.pending\n    where(closure: nil)\n  end\n\n  def initialize(attrs = {})\n    super\n  end\n\n  def close\n    # ...\n  end\n\n  private\n    def notify_watchers\n      # ...\n    end\nend\n```\n\n## Quick Reference\n\n| Pattern | Bad | Good |\n|---------|-----|------|\n| State | `starred: boolean` | `has_one :star` |\n| Multi-user | `starred_by_user_ids: []` | `has_many :stars` |\n| Concern name | `Starring`, `Stars`, `Starred` | `Starrable` |\n| Concern namespace | `module Starrable` | `module Card::Starrable` |\n| Concern location | `concerns/starrable.rb` | `card/starrable.rb` |\n| Method order | Random | Invocation order |\n| Private indent | No indent | Indented under `private` |\n| Extraction | \"Only if reused\" | \"3+ methods or >100 lines\" |\n\n## Real-World Examples from Production\n\n**Binary state (has_one):**\n- Card::Closeable → has_one :closure\n- Card::Triageable → has_one :triage\n- Card::Golden → has_one :goldness\n\n**Multi-user state (has_many):**\n- Card::Pinnable → has_many :pins\n- Card::Watchable → has_many :watches\n- Card::Assignable → has_many :assignments\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"Boolean is simpler than a whole table\" | State records capture who/when you'll need later |\n| \"Concerns are for shared code\" | Concerns decompose models, not just for reuse |\n| \"Global namespace is fine\" | Namespacing shows ownership and scales better |\n| \"Just following Rails guides\" | 37signals patterns intentionally differ from Rails defaults |\n| \"Extraction is premature\" | 3+ methods = extract. Decomposition aids understanding |\n| \"has_many defeats the pattern\" | State record pattern works for both has_one and has_many |\n| \"Adjective doesn't sound right\" | Find the right adjective. Not negotiable. |\n| \"Too much indirection\" | This is the 37signals pattern. It's explicit state modeling. Follow it. |\n",
        "vanilla-rails/skills/naming/SKILL.md": "---\nname: vanilla-rails-naming\ndescription: Use when naming classes, methods, routes in vanilla Rails codebases - fixes concern verb/noun confusion, bang method misuse, custom action anti-patterns\n---\n\n# Vanilla Rails Naming\n\n37signals naming patterns from production Basecamp codebases (Fizzy, HEY, Basecamp).\n\n**Scope:** These are 37signals-specific conventions. They differ from generic Rails guides and may contradict advice from other sources. When in doubt, follow these patterns for vanilla Rails codebases.\n\n## Core Pattern: State as Resource\n\nState changes (pin, close, assign) become **resources**, not actions:\n\n```ruby\n# ❌ WRONG - Custom actions\nresources :cards do\n  member do\n    post :pin\n    post :close\n  end\nend\n\n# ✓ RIGHT - Singular resources\nresources :cards do\n  resource :pin      # POST=create, DELETE=destroy\n  resource :closure  # POST=close, DELETE=reopen\nend\n```\n\nThis creates the naming cascade:\n- Concern: `Closeable` (adjective)\n- Model: `Closure` (noun)\n- Controller: `ClosuresController` (plural of noun)\n- Routes: `resource :closure` (singular)\n\n## Quick Reference\n\n| Type | Pattern | Example | ❌ Wrong |\n|------|---------|---------|----------|\n| **Concern** | Adjective (-able/-ible ONLY) | `Pinnable`, `Closeable`, `Assignable` | `Pinning`, `Pinnish`, `Pinlike`, `PinManager` |\n| **State Model** | Noun | `Pin`, `Closure`, `Assignment` | `CardPin`, `CloseRecord` |\n| **State Method** | Plain verb (no !) | `card.close`, `card.pin` | `card.close!`, `card.pin!` |\n| **Async Enqueue** | `*_later` | `notify_watchers_later` | `notify_watchers_async` |\n| **Sync Execute** | Plain or `*_now` | `notify_watchers` or `notify_watchers_now` | - |\n| **Controller** | Plural noun | `PinsController`, `ClosuresController` | `PinController` (singular) |\n| **Routes** | `resource` (singular) | `resource :closure` | `post :close` |\n\n## Common Violations\n\n### ❌ Violation 1: Verb/Noun Concerns\n**Rationalization:** \"It describes the behavior being added\"\n\n```ruby\n# ❌ WRONG - Verb/noun/other adjective forms\nmodule Card::Pinning      # verb -ing\nmodule Card::PinManager   # Manager/Handler/Logic\nmodule Card::Pinnish      # wrong adjective form\n\n# ✓ RIGHT - Adjective with -able/-ible ONLY\nmodule Card::Pinnable\n  def pin_by(user); end\nend\n```\n\n**If concern name doesn't end in -able/-ible, STOP and rename immediately.**\n\n### ❌ Violation 2: Bang Methods for State\n**Rationalization:** \"Rails uses bangs for state changes (save!)\"\n\n```ruby\n# ❌ WRONG - Contradicts 37signals style\ndef pin!\n  pins.create!(user: Current.user)\nend\n\n# ✓ RIGHT - Plain method\ndef pin_by(user)\n  pins.find_or_create_by!(user: user)\nend\n```\n\n**Why no bangs:** `save!` is about error handling (raise vs return false). State methods like `close` don't need this distinction.\n\n**Counter-argument:** \"But my tech lead says Rails conventions use bangs!\" - 37signals patterns differ from generic Rails guides. In production Basecamp code, state methods use plain verbs. Follow the codebase style.\n\n### ❌ Violation 3: Custom Route Actions\n**Rationalization:** \"Member routes for individual card actions\"\n\n```ruby\n# ❌ WRONG - Custom actions break REST\nresources :cards do\n  member do\n    post :pin\n    delete :unpin\n  end\nend\n\n# ✓ RIGHT - Singular resource\nresources :cards do\n  resource :pin, only: [:create, :destroy]\nend\n```\n\n### ❌ Violation 4: Missing _later Pattern\n**Problem:** Not recognizing async enqueue pattern\n\n```ruby\n# ❌ WRONG - Unclear if async\ndef notify_watchers\n  NotifyWatchersJob.perform_later(self)\nend\n\n# ✓ RIGHT - _later suffix on enqueue method\ndef notify_watchers_later\n  NotifyWatchersJob.perform_later(self)\nend\n\ndef notify_watchers  # Called by job, does actual work\n  # actual notification logic\nend\n```\n\n**Compound verbs:** `_later` always goes at the end:\n```ruby\ndef pin_and_notify_later    # ✓ RIGHT\ndef notify_after_pin_later  # ✓ RIGHT\ndef later_notify_pin        # ❌ WRONG\n```\n\n## Complete Example\n\nFor \"pinning cards\":\n\n```ruby\n# app/models/card/pinnable.rb\nmodule Card::Pinnable\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :pins, dependent: :destroy\n  end\n\n  def pin_by(user)\n    pins.find_or_create_by!(user: user)\n  end\n\n  def unpin_by(user)\n    pins.find_by(user: user)&.destroy\n  end\nend\n\n# app/models/pin.rb\nclass Pin < ApplicationRecord\n  belongs_to :card\n  belongs_to :user\nend\n\n# app/controllers/cards/pins_controller.rb\nclass Cards::PinsController < ApplicationController\n  def create\n    @pin = @card.pin_by(Current.user)\n  end\n\n  def destroy\n    @card.unpin_by(Current.user)\n  end\nend\n\n# config/routes.rb\nresources :cards do\n  resource :pin, only: [:create, :destroy], module: :cards\nend\n```\n\n## File Locations\n\n```\napp/models/card/closeable.rb           # Card-specific concern\napp/models/concerns/eventable.rb       # Shared concern\napp/models/closure.rb                  # State record\napp/controllers/cards/closures_controller.rb\n```\n\n## Red Flags - STOP and Rename\n\n**If you see ANY of these, STOP immediately and rename before proceeding:**\n\n- Concern NOT ending in `-able` or `-ible`\n  - Including: `-ing`, `-er`, `-ish`, `-like`, `Logic`, `Management`, `Handler`, `Service`\n- State method with bang suffix (e.g., pin!, close!, assign!)\n- Routes using member/collection blocks for state changes\n- Async method without `_later` suffix\n- Controller mismatch: plural name with singular resource (`ClosureController` instead of `ClosuresController`)\n\n**Sunk cost fallacy:** \"I already implemented it wrong\" - Rename now. Cost of renaming < cost of confusion later.\n\n**Pattern check:** Does the naming cascade flow correctly?\n- Concern (adjective -able/-ible) → Model (noun) → Controller (plural noun) → Route (singular resource)\n\n## Commit Messages\n\nPresent tense, lowercase, no type prefixes:\n\n```\n✓ add pin feature to cards\n✓ extract closeable concern\n✓ fix closure validation\n✓ update card pinning logic\n✓ remove unused pin methods\n✓ rename pinning concern to pinnable\n\n❌ feat: Add pin feature        # no conventional commit prefixes\n❌ Added pin feature            # no past tense\n❌ [FEATURE] Pin cards          # no brackets/tags\n❌ Add Pin Feature              # no title case\n❌ adding pin feature           # no -ing form\n```\n\n**Time pressure:** \"Need to commit fast\" - Still follow the format. Takes 2 seconds to fix.\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"Rails conventions say to use bangs\" | 37signals style differs. Follow the codebase patterns. |\n| \"Pinnable sounds weird, I'll use Pinnish\" | Only -able/-ible adjectives. Rename immediately. |\n| \"Already implemented as Pinning\" | Rename now. Sunk cost < confusion cost. |\n| \"Team will understand PinManagement\" | No. Use Pinnable. Pattern must be consistent. |\n| \"This is complex, needs a service\" | Concerns handle complexity fine. See actual Fizzy code. |\n| \"Member routes are clearer\" | Singular resources are the pattern. Follow it. |\n| \"Commit message format doesn't matter\" | It does. Present tense, lowercase, no prefixes. |\n| \"Close enough, ship it\" | Wrong names compound. Fix now. |\n",
        "vanilla-rails/skills/shaping/SKILL.md": "---\nname: shaping\ndescription: Use after brainstorming to apply vanilla-rails patterns to a feature, producing structured handoff for implementation planning. Invoke with /shape.\n---\n\n# /shape\n\n**Position in workflow:**\n1. `superpowers:brainstorming` → explores what, clarifies requirements\n2. **`/shape` (this)** → applies patterns, defines right things to do\n3. `superpowers:writing-plans` → detailed implementation steps\n\n**When invoked, execute this workflow. Do not skip phases.**\n\n---\n\n## Phase 1: Confirm Scope\n\nIf brainstorming already happened, summarize:\n- Problem being solved\n- What's in/out of scope\n- Who can use this\n\nIf not, ask these questions before proceeding.\n\n---\n\n## Phase 2: Discover Applicable Skills\n\nCheck each vanilla-rails skill. For each, state whether it applies:\n\n**Always apply:**\n- **work-breakdown** - How to split into PRs\n- **testing** - Test patterns\n- **style** - Code style conventions\n- **naming** - Naming conventions\n\n**Apply if relevant:**\n- **data-modeling** - Adding tables, migrations, schema decisions?\n- **delegated-types** - 5+ content types comingling in feeds/timelines?\n- **models** - Adding model behavior, state tracking, concerns?\n- **controllers** - Adding endpoints, state changes, resources?\n- **views** - ERB templates, partials, Turbo Streams?\n- **jobs** - Background processing needed?\n- **hotwire** - Dynamic UI updates?\n- **writing-affordances** - 3+ related methods or prefix clusters?\n\n**Say:** \"These skills apply: [list]. Loading each to apply patterns.\"\n\n---\n\n## Phase 3: Apply Patterns\n\nFor each applicable skill, invoke it and document the decision:\n\n```\n**data-modeling:** UUID primary key, account_id, state-as-records\n**models:** State as records → `has_one :pin`, not `pinned: boolean`\n**models:** Concern as adjective → `Card::Pinnable`\n**controllers:** Resource extraction → `resource :pinning`\n**naming:** Resource noun → `Pin` (create = pin, destroy = unpin)\n```\n\nAsk the user to confirm or adjust decisions.\n\n---\n\n## Phase 4: Break Down Work\n\nUsing work-breakdown patterns, propose PRs:\n\n```\nPR 1: \"Add pinning to cards\" (migration + model + concern + tests) - 4 files\nPR 2: \"Add UI for pinning cards\" (controller + views + tests) - 4 files\nPR 3: \"Sort pinned cards first\" (scope + view + tests) - 3 files\n```\n\n**Check:** Does any PR title have \"and\"? Split it.\n\n---\n\n## Phase 5: Output Shaping Document\n\nWrite to `docs/shaping/YYYY-MM-DD-feature-name.md`:\n\n```markdown\n# [Feature] Shaping\n\n## Scope\n- Problem: [what problem this solves]\n- In scope: [list]\n- Out of scope: [list]\n- Users: [who can use this]\n\n## Pattern Decisions\n[from Phase 3 - which skills applied and how]\n\n## PRs\n[from Phase 4 - ordered list of PRs with file counts]\n\n## Open Questions\n[any unresolved items]\n```\n\n---\n\n## Phase 6: Handoff to Planning\n\nAsk: \"Ready to create implementation plan?\"\n\nIf yes, invoke `superpowers:writing-plans` with the shaping document as context.\n\nThe writing-plans skill will create detailed, step-by-step implementation tasks for each PR.\n\n---\n\n## Skill Reference\n\n| Skill | When to Apply |\n|-------|---------------|\n| data-modeling | New tables, migrations, schema |\n| delegated-types | 5+ types in unified timeline/feed |\n| models | State tracking, concerns, associations |\n| controllers | Endpoints, resources, state changes |\n| views | ERB templates, partials, collection rendering |\n| jobs | Background processing |\n| hotwire | Dynamic UI, Turbo frames/streams |\n| writing-affordances | 3+ related methods, prefix clusters |\n| work-breakdown | Always (PR structure) |\n| testing | Always |\n| style | Always |\n| naming | Always (new code) |\n\n---\n\n**Remember:** This is a command. Execute each phase in order. Do not skip to code.\n",
        "vanilla-rails/skills/style/SKILL.md": "---\nname: vanilla-rails-style\ndescription: Use when refactoring Ruby/Rails code, organizing methods, deciding on guard clauses vs if/else, or following 37signals conventions - these patterns are counter to standard Ruby style guides\n---\n\n# Vanilla Rails Style\n\n**These conventions CONTRADICT standard Ruby style guides.** They reflect production 37signals/Basecamp code.\n\n## When to Use\n\nYou're writing Ruby/Rails code for 37signals-style projects. Symptoms that trigger this skill:\n- Refactoring methods with guard clauses\n- Organizing private methods in a class\n- Deciding whether to add a bang to method name\n- Structuring controllers and models\n- Creating background jobs\n\n## Counter-Intuitive Patterns\n\nThese patterns violate what most Ruby developers consider \"best practice\":\n\n| Pattern | 37signals Way | Standard Ruby Way |\n|---------|---------------|-------------------|\n| Conditionals | Prefer if/else | Prefer guard clauses |\n| Private indentation | Indent under `private` | No indentation (Rubocop) |\n| Bang methods | Only with counterpart | Flag \"dangerous\" actions |\n| Method order | Invocation sequence | Alphabetical |\n| Controllers | Thin + rich models | Service objects |\n\n## Red Flags - STOP and Reconsider\n\nIf you're about to do any of these, you're violating 37signals style:\n\n| Red Flag | Instead, Do This |\n|----------|------------------|\n| Add guard clauses (`return unless`, `return if`) | Use if/else (unless at method start with complex body) |\n| Remove indentation from private methods | Indent 2 spaces under `private` |\n| Add bang to a method without counterpart | Use plain name (e.g., `close` not `close!`) |\n| Alphabetize private methods | Order by invocation sequence |\n| Create a service object as special artifact | Move logic to model, call from controller |\n\n**These violations require explicit approval. Don't deviate without discussion.**\n\n## Quick Reference\n\n| Situation | 37signals Way | See Section |\n|-----------|---------------|-------------|\n| Early return needed? | if/else (or guard at method start if body complex) | Expanded Conditionals |\n| Private methods? | Indent 2 spaces under `private` | Private Indentation |\n| Ordering methods? | Invocation sequence (caller before callee) | Method Ordering |\n| New controller action? | Create new resource instead | CRUD Controllers |\n| Complex business logic? | Rich model method, thin controller | Controller/Model |\n| Destructive method name? | No bang unless counterpart exists | Bang Methods |\n| Background job? | Use `_later`/`_now` pattern | Background Jobs |\n\n## Code Style Patterns\n\n### Expanded Conditionals (NOT Guard Clauses)\n\n**Prefer `if/else` over guard clauses** - opposite of most Ruby advice:\n\n```ruby\n# Good (37signals style)\ndef todos_for_new_group\n  if ids = params.require(:todolist)[:todo_ids]\n    @bucket.recordings.todos.find(ids.split(\",\"))\n  else\n    []\n  end\nend\n\n# Bad\ndef todos_for_new_group\n  ids = params.require(:todolist)[:todo_ids]\n  return [] unless ids\n  @bucket.recordings.todos.find(ids.split(\",\"))\nend\n```\n\n**Why:** Guard clauses can be hard to read, especially when nested.\n\n**Exception - Guard Clauses ARE Allowed When BOTH:**\n- Return is RIGHT AT THE BEGINNING of the method (first line after method def), AND\n- Main method body is NOT TRIVIAL (5+ lines of substantial logic)\n\n```ruby\n# Allowed - guard at start, complex body below\ndef after_recorded_as_commit(recording)\n  return if recording.parent.was_created?\n\n  if recording.was_created?\n    broadcast_new_column(recording)\n  else\n    broadcast_column_change(recording)\n  end\nend\n```\n\n**Multiple guard clauses - convert to nested if/else:**\n\n```ruby\n# Bad - multiple guard clauses\ndef process_payment(params)\n  amount = params[:amount]\n  return { error: \"Missing amount\" } unless amount\n\n  method = params[:method]\n  return { error: \"Missing method\" } unless method\n\n  valid = validate_payment(amount, method)\n  return { error: \"Invalid\" } unless valid\n\n  charge(amount, method)\nend\n\n# Good - nested if/else\ndef process_payment(params)\n  if amount = params[:amount]\n    if method = params[:method]\n      if validate_payment(amount, method)\n        charge(amount, method)\n      else\n        { error: \"Invalid\" }\n      end\n    else\n      { error: \"Missing method\" }\n    end\n  else\n    { error: \"Missing amount\" }\n  end\nend\n```\n\n### Private Method Indentation (YES, Really)\n\n**Indent methods under `private`** - counter to Rubocop default:\n\n```ruby\nclass SomeClass\n  def some_method\n    # ...\n  end\n\n  private\n    def private_method_1\n      # indented 2 spaces\n    end\n\n    def private_method_2\n      # indented 2 spaces\n    end\nend\n```\n\n**Important:** No newline after `private` keyword.\n\n**Exception - Module with ONLY Private Methods:**\n\n```ruby\nmodule SomeModule\n  private\n\n  def some_private_method\n    # not indented\n    # blank line after private\n  end\nend\n```\n\n### Method Ordering\n\n**Order by invocation sequence, not alphabetically:**\n\n1. `class` methods\n2. `public` methods (with `initialize` at the very top)\n3. `private` methods (ordered by call sequence)\n\n```ruby\nclass SomeClass\n  def self.class_method\n    # class methods first\n  end\n\n  def initialize\n    # initialize first among instance methods\n  end\n\n  def some_method\n    method_1\n    method_2\n  end\n\n  private\n    def method_1\n      method_1_1\n      method_1_2\n    end\n\n    def method_1_1\n      # appears after caller (method_1)\n    end\n\n    def method_1_2\n      # appears after method_1_1\n    end\n\n    def method_2\n      # appears after method_1 (called second)\n    end\nend\n```\n\n**Why:** Invocation order shows execution flow. Makes code easier to trace.\n\n### Bang Methods (Restrictive Rule)\n\n**Only use bang when non-bang counterpart exists:**\n\n```ruby\n# Good - has counterpart\nsave / save!\nupdate / update!\n\n# Bad - no counterpart, just use `close`\ndef close!\n  # wrong - there's no `close` method\nend\n\n# Good - single method, no bang\ndef close\n  # destructive action, but no bang needed\nend\n```\n\n**Why:** Don't use bang to flag \"destructive actions\". Many destructive Ruby/Rails methods lack it.\n\n## Architecture Patterns\n\n### CRUD Controllers (Resource-Oriented)\n\n**Model actions as CRUD on resources.** When action doesn't map to standard CRUD verb, introduce new resource:\n\n```ruby\n# Bad - custom actions\nresources :cards do\n  post :close\n  post :reopen\nend\n\n# Good - new resource\nresources :cards do\n  resource :closure\nend\n```\n\n### Controller/Model Interaction (Vanilla Rails)\n\n**Thin controllers, rich domain models.** No service objects as special artifacts.\n\n**Plain Active Record is fine:**\n\n```ruby\nclass Cards::CommentsController < ApplicationController\n  def create\n    @comment = @card.comments.create!(comment_params)\n  end\nend\n```\n\n**Complex behavior - clear model APIs:**\n\n```ruby\nclass Cards::GoldnessesController < ApplicationController\n  def create\n    @card.gild\n  end\nend\n```\n\n**Form objects when truly needed (e.g., coordinating multiple models):**\n\n```ruby\n# Signup coordinates Identity + User creation\nSignup.new(email_address: email_address).create_identity\n```\n\nDon't create service objects as default pattern. Prefer rich model methods.\n\n### Background Jobs (_later/_now Pattern)\n\n**Shallow job classes delegating to models:**\n\n- Suffix `_later` for methods that enqueue jobs\n- Suffix `_now` for synchronous counterpart\n\n```ruby\nmodule Event::Relaying\n  extend ActiveSupport::Concern\n\n  included do\n    after_create_commit :relay_later\n  end\n\n  def relay_later\n    Event::RelayJob.perform_later(self)\n  end\n\n  def relay_now\n    # actual logic here\n  end\nend\n\nclass Event::RelayJob < ApplicationJob\n  def perform(event)\n    event.relay_now\n  end\nend\n```\n\n## Common Mistakes\n\n### Guard Clause in Middle of Method\n\n```ruby\n# WRONG - guard clause after other logic\ndef process\n  setup_data\n  return unless valid?\n  execute_action\nend\n\n# RIGHT - if/else shows full flow\ndef process\n  setup_data\n  if valid?\n    execute_action\n  end\nend\n```\n\n### Private Method Not Indented\n\n```ruby\n# WRONG - no indentation under private\nclass Processor\n  def process\n    # ...\n  end\n\n  private\n  def helper\n    # ...\n  end\nend\n\n# RIGHT - indent under private\nclass Processor\n  def process\n    # ...\n  end\n\n  private\n    def helper\n      # ...\n    end\nend\n```\n\n### Bang Without Counterpart\n\n```ruby\n# WRONG - no close method exists\nclass Account\n  def close!\n    update(closed: true)\n  end\nend\n\n# RIGHT - no bang needed\nclass Account\n  def close\n    update(closed: true)\n  end\nend\n```\n\n### Alphabetical Method Order\n\n```ruby\n# WRONG - alphabetized\nclass Builder\n  def build\n    prepare\n    format\n    output\n  end\n\n  private\n    def format\n      # ...\n    end\n\n    def output\n      # ...\n    end\n\n    def prepare\n      # ...\n    end\nend\n\n# RIGHT - invocation order\nclass Builder\n  def build\n    prepare\n    format\n    output\n  end\n\n  private\n    def prepare\n      # ...\n    end\n\n    def format\n      # ...\n    end\n\n    def output\n      # ...\n    end\nend\n```\n\n## Common Rationalizations\n\n| You'll Think | Reality |\n|--------------|---------|\n| \"Guard clauses are Ruby best practice\" | 37signals prefers if/else for readability, especially with nesting |\n| \"Early returns reduce nesting\" | Nested if/else shows complete logic flow |\n| \"Rubocop doesn't indent private methods\" | 37signals style intentionally differs from Rubocop |\n| \"Bang means dangerous/destructive\" | Only use ! when you have both safe and dangerous variants |\n| \"Alphabetical order helps find methods\" | Invocation order helps trace execution flow |\n| \"I should extract a service object\" | Keep logic in models, controllers call rich model APIs |\n| \"Service objects separate concerns\" | Only use when truly justified, not as default pattern |\n\n## Philosophy\n\n37signals optimizes for **reading code**, not writing it. These conventions:\n\n- Make execution flow explicit (invocation ordering)\n- Show complete logic in one place (if/else over guard clauses)\n- Reduce indirection (rich models over service layers)\n- Maintain visual consistency (private indentation)\n\n**These rules apply to ALL new code. Apply these patterns strictly. Don't deviate without explicit approval.**\n\n## Self-Check Before Committing\n\n- [ ] Used if/else instead of guard clauses (except single guard at method start with complex body)\n- [ ] Indented all private methods under `private` keyword\n- [ ] Ordered methods by invocation sequence, not alphabetically\n- [ ] Only added bang to methods with non-bang counterparts\n- [ ] Kept business logic in models, not service objects\n- [ ] Used resource-oriented routing (no custom controller actions)\n",
        "vanilla-rails/skills/testing/SKILL.md": "---\nname: vanilla-rails-testing\ndescription: Use when writing Rails tests - enforces fixtures-only, integration-style controller tests, Current context setup, simple naming, and Minitest syntax\n---\n\n# Vanilla Rails Testing\n\n**Counter-intuitive patterns from 37signals.** These are NOT standard Rails community practices.\n\n**Core principle:** Fixtures over factories. Always. Integration tests for controllers. Minitest, not RSpec.\n\n## The Iron Law\n\n**NO FACTORYBOT. NO RSPEC. NO DATA CREATION IN TESTS.**\n\nIf you write `create(:model)`, `FactoryBot`, `let`, `describe`, `it`, `expect`, or `before_each` → DELETE IT.\n\n## Fixtures Only\n\n```ruby\n# ✅ GOOD - Reference fixtures\ntest \"close card\" do\n  cards(:logo).close\n  assert cards(:logo).closed?\nend\n\n# ❌ BAD - Never create data\ntest \"close card\" do\n  card = create(:card)  # DELETE THIS\n  card.close\nend\n\n# ❌ BAD - Never use FactoryBot\nlet(:card) { create(:card) }  # DELETE THIS\n\n# ❌ BAD - Never use RSpec\ndescribe Card do  # DELETE THIS\n  it \"closes\" do  # DELETE THIS\n```\n\n**Reference fixtures by symbol:** `cards(:logo)`, `users(:david)`, `boards(:writebook)`, `sessions(:kevin)`\n\n**Why fixtures?** They're real data, loaded once, fast, and force you to think about realistic scenarios.\n\n**Q: What if the fixture I need doesn't exist?**\n**A:** Add it to the fixtures file. Never create data in tests.\n\n## Controller Tests Use Integration Style\n\n```ruby\n# ✅ GOOD - ActionDispatch::IntegrationTest\nclass Cards::ClosuresControllerTest < ActionDispatch::IntegrationTest\n  setup do\n    sign_in_as :kevin\n  end\n\n  test \"create\" do\n    post card_closure_path(cards(:logo)), as: :turbo_stream\n    assert_response :success\n  end\nend\n\n# ❌ BAD - Never use ActionController::TestCase\nclass Cards::ClosuresControllerTest < ActionController::TestCase  # DELETE THIS\n  post :create, params: { card_id: card.id }  # DELETE THIS\nend\n```\n\n**Why integration style?** Tests the full request cycle including routing, middleware, and response rendering.\n\n## Model Tests Require Current.session\n\n```ruby\n# ✅ GOOD - Set Current.session in setup\nclass Card::CloseableTest < ActiveSupport::TestCase\n  setup do\n    Current.session = sessions(:david)\n  end\n\n  test \"close records user\" do\n    cards(:logo).close(user: users(:kevin))\n    assert_equal users(:kevin), cards(:logo).closed_by\n  end\nend\n\n# ❌ BAD - Missing Current.session\nclass Card::CloseableTest < ActiveSupport::TestCase\n  # Missing setup - tests may fail or behave incorrectly\n  test \"close records user\" do\n    cards(:logo).close(user: users(:kevin))\n  end\nend\n```\n\n**Why Current.session?** Models often rely on `Current.session` for user context, event recording, and authorization.\n\n**Always set it, even if you think it's not needed.**\n\n## Simple Test Names\n\n```ruby\n# ✅ GOOD - Concise, clear\ntest \"create\"\ntest \"close records user\"\ntest \"reopen creates event\"\n\n# ❌ BAD - Verbose, repetitive\ntest \"should create a new card when given valid parameters\"\ntest \"should mark the card as closed when user closes it\"\nit \"should record the user who closed the card\"  # Also wrong syntax\n```\n\n**Why simple names?** File and test method name provide enough context. No need to repeat.\n\n## Use Minitest Syntax\n\n```ruby\n# ✅ GOOD - Minitest assertions\ntest \"close\" do\n  assert cards(:logo).close\n  assert cards(:logo).closed?\n  assert_not cards(:shipping).open?\nend\n\n# ✅ GOOD - Exception testing\nassert_raises ActiveRecord::RecordNotFound do\n  Card.find(\"nonexistent\")\nend\n\n# ❌ BAD - RSpec syntax\nit \"should close\" do  # DELETE THIS\n  expect(card.close).to be_truthy  # DELETE THIS\n  expect(card.closed?).to be true  # DELETE THIS\nend\n\n# ❌ BAD - RSpec describe/context\ndescribe \"#close\" do  # DELETE THIS\n  context \"when card is open\" do  # DELETE THIS\n```\n\n**Use:** `test`, `setup`, `assert`, `assert_equal`, `assert_not`, `assert_difference`, `assert_changes`, `assert_raises`\n\n**NEVER use:** `it`, `describe`, `context`, `before_each`, `let`, `expect`, `refute` (use `assert_not` instead)\n\n## assert_difference for State Changes\n\n```ruby\n# ✅ GOOD - Single change with lambda syntax\nassert_difference -> { Card.count }, +1 do\n  post board_cards_path(boards(:writebook))\nend\n\n# ✅ GOOD - Multiple changes\nassert_difference({\n  -> { cards(:logo).events.count } => +1,\n  -> { Event.count } => +1\n}) do\n  cards(:logo).close(user: users(:kevin))\nend\n\n# ❌ BAD - RSpec expect/to change\nexpect {  # DELETE THIS\n  card.close\n}.to change { Event.count }.by(1)  # DELETE THIS\n```\n\n**Why lambda syntax?** Evaluates the expression in the block's context, capturing state changes correctly.\n\n## assert_changes for Boolean Toggles\n\n```ruby\n# ✅ GOOD - Boolean state changes\nassert_changes -> { cards(:logo).reload.closed? }, from: false, to: true do\n  post card_closure_path(cards(:logo)), as: :turbo_stream\nend\n\n# ❌ BAD - Manual before/after checks\nclosed_before = card.closed?  # Too verbose\ncard.close\nassert_not_equal closed_before, card.reload.closed?\n```\n\n## System Tests (Capybara)\n\nSystem tests follow the same rules:\n\n```ruby\n# ✅ GOOD - ApplicationSystemTestCase with fixtures\nclass SmokeTest < ApplicationSystemTestCase\n  test \"create a card\" do\n    sign_in_as(users(:david))\n    visit board_url(boards(:writebook))\n    click_on \"Add a card\"\n    # ...\n  end\nend\n\n# ❌ BAD - Creating data in system tests\ntest \"create a card\" do\n  user = create(:user)  # DELETE THIS\n  sign_in_as(user)\nend\n```\n\n## Stubbing and Mocking\n\nUse mocha for stubbing, webmock for HTTP requests:\n\n```ruby\n# ✅ GOOD - Mocha for stubbing\nTestMailer.stubs(:goes_boom).raises(Net::SMTPSyntaxError)\n\n# ✅ GOOD - WebMock for HTTP\nstub_request(:post, webhook.url).to_return(status: 200)\n\n# ❌ BAD - RSpec mocks\nallow(TestMailer).to receive(:goes_boom)  # DELETE THIS\n```\n\n## Common Rationalizations (All Wrong)\n\n| Excuse | Reality |\n|--------|---------|\n| \"FactoryBot is standard Rails practice\" | Not in vanilla Rails. Fixtures only. |\n| \"RSpec is more expressive\" | Minitest is simpler. Use it. |\n| \"Creating test data makes tests clearer\" | Fixtures make tests realistic. No creation. |\n| \"ActionController::TestCase is for controllers\" | Integration tests cover more. Use those. |\n| \"Current.session isn't needed here\" | Models rely on it. Always set it. |\n| \"Verbose names document the test\" | File name + method name = enough context. |\n| \"let makes setup DRY\" | setup method does the same. No let. |\n| \"describe/context organizes tests\" | Class and file organization is enough. |\n| \"I'll just create one record since fixture missing\" | Add the fixture. Never create in tests. |\n| \"refute is more idiomatic Minitest\" | Use assert_not for consistency. |\n\n## Red Flags - STOP and Rewrite\n\nSeeing any of these? DELETE THE CODE and start over:\n\n- `create(:model)`, `build(:model)`, or `FactoryBot`\n- `let`, `describe`, `it`, `context`, `before_each`, `subject`\n- `expect(...).to` or `.should`\n- `ActionController::TestCase`\n- Model test without `Current.session = sessions(:fixture)`\n- Test names starting with \"should\"\n- Data creation in tests (`User.create`, `Card.new`, `Board.build`)\n- `refute` (use `assert_not`)\n\n## Quick Reference\n\n| Pattern | Use | Never Use |\n|---------|-----|-----------|\n| **Test framework** | Minitest | RSpec |\n| **Test data** | Fixtures (`cards(:logo)`) | Factories (`create(:card)`) |\n| **Controller tests** | `ActionDispatch::IntegrationTest` | `ActionController::TestCase` |\n| **System tests** | `ApplicationSystemTestCase` | Any other base class |\n| **Model setup** | `Current.session = sessions(:david)` | Nothing (missing context) |\n| **Test blocks** | `test \"name\"` | `it \"should...\"`, `describe` |\n| **Setup** | `setup do` | `before_each`, `let`, `subject` |\n| **Assertions** | `assert`, `assert_not` | `expect`, `should`, `refute` |\n| **Test names** | `test \"create\"` | `it \"should create...\"` |\n| **Stubbing** | `mocha` (`.stubs`) | RSpec mocks (`allow`, `expect`) |\n| **HTTP mocking** | `webmock` | VCR, other tools |\n\n## Real Example Comparison\n\n### ❌ What NOT to Write (Common Mistakes)\n```ruby\nrequire \"rails_helper\"\n\nRSpec.describe Card, type: :model do\n  let(:board) { create(:board) }\n  let(:card) { create(:card, board: board) }\n  let(:user) { create(:user) }\n\n  describe \"#close\" do\n    it \"should mark card as closed when user closes it\" do\n      expect {\n        card.close(user: user)\n      }.to change { card.reload.closed? }.from(false).to(true)\n\n      expect(card.closed_by).to eq(user)\n    end\n\n    context \"when already closed\" do\n      let(:card) { create(:card, :closed) }\n\n      it \"should not create duplicate events\" do\n        expect {\n          card.close(user: user)\n        }.not_to change { Event.count }\n      end\n    end\n  end\nend\n```\n\n### ✅ What to Write (Vanilla Rails)\n```ruby\nrequire \"test_helper\"\n\nclass Card::CloseableTest < ActiveSupport::TestCase\n  setup do\n    Current.session = sessions(:david)\n  end\n\n  test \"close\" do\n    assert_not cards(:logo).closed?\n\n    cards(:logo).close(user: users(:kevin))\n\n    assert cards(:logo).closed?\n    assert_equal users(:kevin), cards(:logo).closed_by\n  end\n\n  test \"close creates event\" do\n    assert_difference -> { cards(:logo).events.count }, +1 do\n      cards(:logo).close(user: users(:kevin))\n    end\n  end\nend\n```\n\n## The Bottom Line\n\n**Vanilla Rails is deliberately simple:**\n- Fixtures, not factories\n- Integration tests, not controller unit tests\n- Minitest, not RSpec\n- Current.session for model tests\n- Simple names, minimal ceremony\n- Always use fixtures, even if you need to create new ones\n\n**If the Rails community does it differently, that's fine. We don't.**\n\nFollow these patterns exactly. No exceptions, no \"better\" alternatives.\n",
        "vanilla-rails/skills/views/SKILL.md": "---\nname: vanilla-rails-views\ndescription: Use when writing ERB templates, partials, view helpers, or Turbo Stream responses - covers partial organization, optional locals, CSS class patterns, collection rendering\n---\n\n# Views & Templates\n\nERB conventions for vanilla Rails applications.\n\n## Partial Organization\n\n**Lowest common ancestor** - place partials at the highest shared directory:\n\n```\n# Shared by cards/show and cards/index\napp/views/cards/_card.html.erb\n\n# Shared across controllers\napp/views/application/_flash.html.erb\n\n# Display variants of same model\napp/views/cards/display/_compact.html.erb\napp/views/cards/display/_full.html.erb\n```\n\n**Never** create deeply nested partials only used in one place.\n\n## Optional Locals\n\nUse `local_assigns.fetch` with explicit defaults:\n\n```erb\n<%# Good - explicit default, raises if required %>\n<% pinned = local_assigns.fetch(:pinned, false) %>\n<% card = local_assigns.fetch(:card) %>\n\n<%# Bad - silent nil, ambiguous intent %>\n<% pinned = local_assigns[:pinned] || false %>\n```\n\n## CSS Class Helper\n\nBuild classes with array + compact + join:\n\n```erb\n<%# Good %>\n<div class=\"<%= [\n  'card',\n  ('card--pinned' if card.pinned?),\n  ('card--closed' if card.closed?)\n].compact.join(' ') %>\">\n\n<%# Bad - string interpolation %>\n<div class=\"card <%= 'card--pinned' if card.pinned? %>\">\n```\n\nFor complex cases, use `token_list` helper:\n\n```erb\n<div class=\"<%= token_list('card', 'card--pinned': card.pinned?) %>\">\n```\n\n## Collection Rendering\n\nAlways cache, always specify `as:`:\n\n```erb\n<%= render partial: 'cards/card',\n           collection: @cards,\n           as: :card,\n           cached: true %>\n```\n\n## Turbo Streams\n\nPrepend/append with update for empty states:\n\n```erb\n<%# Add item and update counter/empty state %>\n<%= turbo_stream.before :cards, @card %>\n<%= turbo_stream.update :cards_count, @cards.count %>\n\n<%# Remove and handle empty %>\n<%= turbo_stream.remove @card %>\n<%= turbo_stream.update :cards_empty, partial: 'empty' if @cards.none? %>\n```\n\n## Stimulus Integration\n\nLayer controllers on existing elements:\n\n```erb\n<%# Good - multiple controllers on body %>\n<body data-controller=\"keyboard shortcuts dropdown\">\n\n<%# Bad - wrapper div just for controller %>\n<div data-controller=\"card-actions\">\n  <%= render @card %>\n</div>\n```\n\nKeyboard shortcuts via body controller:\n\n```erb\n<body data-controller=\"keyboard\"\n      data-action=\"keydown->keyboard#handle\">\n```\n\n## Quick Reference\n\n| Pattern | Use |\n|---------|-----|\n| `local_assigns.fetch(:x, default)` | Optional locals |\n| `[...].compact.join(' ')` | Conditional CSS classes |\n| `cached: true, as: :item` | Collection rendering |\n| `turbo_stream.before` + `.update` | Add + refresh related |\n| `data-controller=\"a b c\"` | Multiple controllers |\n\n## Common Mistakes\n\n| Wrong | Right |\n|-------|-------|\n| `local_assigns[:x] \\|\\| default` | `local_assigns.fetch(:x, default)` |\n| Wrapper div for Stimulus | Add controller to existing element |\n| `render @cards` without cache | `render collection:, cached: true` |\n| Partial in deep nested path | Lowest common ancestor |\n",
        "vanilla-rails/skills/work-breakdown/SKILL.md": "---\nname: vanilla-rails-work-breakdown\ndescription: Use when planning Rails features or breaking down work into PRs - enforces 2-5 file PRs, bug fix separation, and one-sentence scope test\n---\n\n# Vanilla Rails Work Breakdown\n\n## Core Rule\n\n**Each PR = one sentence. Target 2-5 files, max 7-8.**\n\nIf you can't describe the PR in one sentence, split it.\n\n**CRITICAL: If your PR description uses \"and\", STOP and split it.**\n\n## Bundle Together\n\n- Model + tests (but NOT scopes/sorting)\n- Controller + view + tests\n- Migration + model using it\n- Routes + controller they configure\n\n**Tests go with the functional change, never with styling.**\n\n## Keep Separate (ALWAYS)\n\nEach of these MUST be its own PR:\n\n- Bug fixes\n- Refactoring\n- Styling/CSS (even one line)\n- Filters (even simple params)\n- Sort options (including scopes like `pinned_first`)\n\n## Example: Card Pinning\n\n**Wrong (3 PRs):**\n1. \"Add pinning to cards with sorting\" (model + sorting scope + tests)\n2. \"Add UI for pinning\" (controller + views + tests)\n3. \"Add filtering and styling\" (filter + CSS)\n\n**Right (5 PRs):**\n1. \"Add pinning to cards\" (migration + model methods + tests, 3 files)\n2. \"Add UI for pinning cards\" (controller + view + tests, 4 files)\n3. \"Sort pinned cards first\" (scope + tests, 2 files)\n4. \"Add filter for pinned cards\" (controller param + view + tests, 3 files)\n5. \"Style pinned cards\" (CSS, 1 file)\n\n## Commit Messages\n\nPresent tense, no prefixes:\n\n```\nAdd hotkeys for triaging cards\nFix HTML injection in webhook titles\nExpose card ID on comments\n```\n\nNot: `feat:`, `fix:`, `WIP:`\n\n## Red Flags\n\nStop and split if:\n- More than 7-8 files\n- PR title has \"and\"\n- Mixing refactoring with features\n- Bug fix included with feature\n\n## Bug During Feature Work\n\n1. Branch from main for bug fix\n2. Fix + test in separate PR\n3. Return to feature branch\n4. Rebase after bug fix merges\n\n**Never bundle bug fixes with feature PRs.**\n\n## One Sentence Test\n\n✅ \"This PR adds pinning to cards\"\n❌ \"This PR adds pinning, styling, and filters\"\n\nIf you use \"and\", split the PR.\n\n## Common Rationalizations (STOP)\n\n| Excuse | Reality |\n|--------|---------|\n| \"Sorting is part of the model concern\" | No. Sorting is a feature that ships separately. Core pinning works without sorting. |\n| \"Styling and filtering touch the same view\" | Different concerns. Filtering is functional, styling is visual. Separate PRs. |\n| \"More efficient to bundle them\" | 37signals values small PRs over efficiency. 2-5 files is the target. |\n| \"They're logically grouped\" | \"Logical grouping\" is not the test. One sentence without \"and\" is the test. |\n| \"Just a few lines of CSS\" | Styling ALWAYS separate. Even one line. |\n| \"Just a tiny partial\" | View code goes with controller, not model. Size irrelevant. |\n| \"It's related functionality\" | Each feature = one PR. Even if related. One sentence test applies. |\n| \"The change is trivial\" | Size doesn't matter. Separate concerns = separate PRs. |\n",
        "vanilla-rails/skills/writing-affordances/SKILL.md": "---\nname: writing-affordances\ndescription: Use when refactoring fat Rails models with repetitive prefixes like entropy_*, notification_*, or multi-association coordination. Extracts PORO wrappers that group operations around nouns/concepts.\n---\n\n# Writing Affordances\n\nExtract PORO wrappers that group 3+ operations around a noun/concept, keeping parent model focused.\n\n**Announce:** \"I'm using the writing-affordances skill to evaluate this for affordance extraction.\"\n\n## Detection Triggers\n\n- 3+ methods share prefix: `entropy_calculate`, `entropy_remind`, `entropy_cleanup`\n- Methods coordinate 2+ associations (`assignments` + `watches` + `events`)\n- Fat model with mixed conceptual domains\n- Related methods but connection non-obvious\n\n**Don't use for:** Single trait (use concern) | Single association (use extension) | 1-2 methods (use plain method)\n\n## Decision Heuristics\n\nAsk yourself:\n\n1. **\"Can I pass this around?\"** - Would `notify(description)` be clearer than `notify(event)`?\n2. **\"Do I call it or does Rails?\"** - Explicit calls = Affordance | Callbacks/validations = Concern\n3. **\"Prefix cluster?\"** - `entropy_*` methods = Extract `entropy` affordance (prefix = noun)\n4. **\"Call site clarity?\"** - `card.entropy.auto_clean_at` vs `card.entropy_auto_clean_at`\n5. **\"Need infrastructure + operations?\"** - Concern provides associations/callbacks, affordance provides API\n\nSee @detecting.md for complete decision framework.\n\n## Pattern Comparison\n\n| Pattern | Use When | Example | Key Question |\n|---------|----------|---------|--------------|\n| **Affordance** | Group operations around noun | `card.entropy.auto_clean_at` | \"Can I pass this around?\" |\n| **Concern** | Infrastructure or implicit behavior | `Searchable` (callbacks only) | \"Does Rails call it implicitly?\" |\n| **Concern + Affordance** | Both infrastructure AND operations | Concern sets up associations, affordance provides API | \"Need both?\" |\n| **Association Ext** | Single association operations | `card.comments.recent` | \"Only touching one has_many?\" |\n\n## Critical Constraints\n\n**Violating these = wrong pattern:**\n\n- **3+ methods minimum** - Don't create single-method affordances\n- **PORO only** - No ActiveRecord inheritance\n- **Parent is ONLY dependency** - `Card::Entropy.new(card)`, not `new(card, user)`\n- **Don't memoize parameterized** - `entropy(as_of: date)` should NOT use `||=`\n\n## Quick Pattern\n\n```ruby\n# Before: Methods scattered in model or prefix smell\ncard.entropy_auto_clean_at\ncard.entropy_days_before_reminder\ncard.entropy_reminder_sent?\n\n# After: Affordance\ncard.entropy.auto_clean_at\ncard.entropy.days_before_reminder\ncard.entropy.reminder_sent?\n\n# Entry point in concern\nmodule Card::Entropic\n  def entropy\n    Card::Entropy.for(self)  # Factory pattern\n  end\n\n  def entropic?\n    entropy.present?\n  end\nend\n\n# PORO affordance class\nclass Card::Entropy\n  attr_reader :card, :auto_clean_period\n\n  class << self\n    def for(card)\n      return unless card.last_active_at\n      new(card, card.auto_postpone_period)\n    end\n  end\n\n  def initialize(card, auto_clean_period)\n    @card = card\n    @auto_clean_period = auto_clean_period\n  end\n\n  def auto_clean_at\n    card.last_active_at + auto_clean_period\n  end\n\n  def days_before_reminder\n    (auto_clean_period * 0.25).seconds.in_days.round\n  end\nend\n```\n\n## Verification\n\nNon-obvious checks before completion:\n\n- [ ] 3+ related methods (not single-method wrapper)\n- [ ] Parameterized affordances NOT memoized\n- [ ] Class documentation with usage examples\n- [ ] Tests: both isolated and integration\n\n## Sub-documents\n\n- @detecting.md - Full decision framework with clarifying questions\n- @implementing.md - File organization, naming, concerns + affordances patterns\n",
        "vanilla-rails/skills/writing-affordances/detecting.md": "# Detecting Affordance Opportunities\n\n## Table of Contents\n\n- [Primary Indicators](#primary-indicators)\n- [Decision Framework](#decision-framework)\n- [Clarifying Questions](#clarifying-questions)\n- [Example: Multiple Valid Designs](#example-multiple-valid-designs)\n- [Anti-Indicators](#anti-indicators)\n- [Quick Reference](#quick-reference)\n\n## Primary Indicators\n\n**1. Repetitive Method Prefixes** (3+ methods)\n```ruby\nentropy_auto_clean_at, entropy_days_before_reminder, entropy_reminder_sent?\n# Prefix \"entropy\" = affordance noun\n```\n\n**2. Multi-Association Coordination** (2+ `has_many`)\n```ruby\ndef assign(user)\n  # Touches assignments AND watches AND events\n  transaction do\n    assignments.create!(user: user)\n    watch_by(user)\n    track_event :assigned\n  end\nend\n# Coordinating affordance provides unified interface\n```\n\n**3. Unclear Relationship Clusters**\n```ruby\n# Related but scattered, connection non-obvious\nauto_clean_at, days_before_reminder, reminder_sent?\n# Group under explicit \"entropy\" concept\n```\n\n**4. Fat Model with Mixed Domains** (50+ methods across concepts)\n```ruby\n# Closeable (4 methods) + Assignable (6) + Entropic (5) + Watchable (4)\n# Extract each domain to focused concern + affordance\n```\n\n## Decision Framework\n\n```\nMethods share prefix (3+)?\n  |-- Yes --> Extract affordance (prefix = noun)\n  |-- No --> Continue\n\nCoordinate 2+ associations?\n  |-- Yes --> Likely affordance\n  |-- No --> Continue\n\nImplicit behavior only (callbacks/validations)?\n  |-- Yes --> Concern, not affordance\n  |-- No --> Continue\n\nSingle association only?\n  |-- Yes --> Association extension\n  |-- No --> Affordance or concern + affordance\n```\n\n## Clarifying Questions\n\nWhen decision unclear, ask:\n\n### 1. Call-Site Clarity (The North Star)\n\"Would someone understand what this does from the call site?\"\n\n- `card.entropy.auto_clean_at` - Self-evident\n- `card.entropy_auto_clean_at` - Prefix smell\n- `include Searchable` - Clear trait\n\n**Use the clearest option. Don't force a pattern.**\n\n### 2. Explicit vs Implicit\n\"Do I call this, or does Rails call it?\"\n\n**Explicit (you call):**\n```ruby\ncard.entropy.auto_clean_at\nevent.description.to_html\n# --> Affordance\n```\n\n**Implicit (Rails calls):**\n```ruby\nafter_save :update_search_index\nvalidates :title, presence: true\n# --> Concern\n```\n\n**Both:** Concern provides infrastructure, affordance provides API\n\n### 3. Composition Test\n\"Can I pass just this piece to a method?\"\n\n```ruby\n# Makes sense to pass around --> Affordance\ndef render_notification(description)\n  description.to_html\nend\n\nrender_notification(event.description)\n\n# Doesn't make sense --> Concern\ninclude Searchable  # Not a passable object\n```\n\n### 4. Prefix Clustering\n\"Do 3+ methods share a prefix that reveals a noun?\"\n\n```ruby\nentropy_calculate, entropy_remind, entropy_cleanup\n# Prefix \"entropy\" IS the affordance\n```\n\n**Pattern:** Extract noun, remove prefix\n\n### 5. Infrastructure vs Operations\n\"Need both associations/callbacks AND explicit methods?\"\n\n**Both --> Concern + Affordance:**\n```ruby\nmodule Card::Entropic\n  extend ActiveSupport::Concern\n\n  included do\n    has_one :activity_spike     # Infrastructure\n    after_save :check_entropy   # Callbacks\n  end\n\n  def entropy                   # Entry to affordance\n    Card::Entropy.for(self)\n  end\nend\n```\n\n**Just infrastructure --> Concern only:**\n```ruby\nmodule Searchable\n  included do\n    after_save :reindex  # Automatic only\n  end\nend\n```\n\n**Just operations --> Affordance (entry in model):**\n```ruby\ndef description\n  @description ||= Event::Description.new(self, user)\nend\n```\n\n## Example: Multiple Valid Designs\n\n**Event rendering can be implemented three ways:**\n\n**A. Concern only (automatic):**\n```ruby\nmodule Event::Describable\n  included do\n    after_create :cache_description\n  end\nend\n```\n\n**B. Affordance only (explicit):**\n```ruby\nevent.description.to_html\nevent.description.to_plain_text\n```\n\n**C. Both (automatic + explicit):**\n```ruby\nmodule Event::Describable\n  included do\n    after_create :cache_description  # Automatic\n  end\n\n  def description\n    Event::Description.new(self, user)  # Explicit when needed\n  end\nend\n```\n\n**Let domain guide the choice.**\n\n## Anti-Indicators\n\n**Use Concern:** Pure implicit behavior (callbacks, validations only)\n\n**Use Association Extension:** Operations on single `has_many` only\n\n**Use Plain Method:** Only 1-2 related methods\n\n## Quick Reference\n\n| What You See | Pattern |\n|--------------|---------|\n| `entropy_*` prefix (3+ methods) | Extract `Entropy` affordance |\n| Coordinates `assignments` + `watches` | Coordinating affordance |\n| 50+ methods, multiple domains | Extract by domain to affordances |\n| Callbacks/validations only | Concern, not affordance |\n| Explicit operations called | Affordance (possibly via concern) |\n| Single `has_many` operations | Association extension |\n| 1-2 methods | Plain method |\n",
        "vanilla-rails/skills/writing-affordances/implementing.md": "# Implementing Affordances\n\n## Table of Contents\n\n- [Core Principles](#core-principles)\n- [Concerns and Affordances](#concerns-and-affordances)\n- [Entry Point Patterns](#entry-point-patterns)\n- [PORO Affordance Class](#poro-affordance-class)\n- [Naming & Organization](#naming--organization)\n- [Common Patterns](#common-patterns)\n- [Memoization Rules](#memoization-rules)\n- [Anti-Patterns](#anti-patterns)\n- [Verification](#verification)\n\n## Core Principles\n\n- **Focused Interface:** 3+ operations around single noun/concept\n- **Composable:** Return first-class object you can pass around\n- **Discoverable:** Class docs with usage examples\n- **Encapsulated:** Private delegation to wrapped objects\n\n## Concerns and Affordances\n\n**Not competing patterns - they work together:**\n\n**Concerns:** Associations, callbacks, validations, shared setup\n**Affordances:** Explicit operations, composable interfaces\n\n**Three valid patterns:**\n\n1. **Concern only** - Pure infrastructure (e.g., `Searchable` with callbacks)\n2. **Affordance only** - Entry in model, no concern needed\n3. **Concern + Affordance** - Concern provides infrastructure, affordance provides API\n\n## Entry Point Patterns\n\n### Pattern 1: Entry via Concern (With Infrastructure)\n\nUse when: Affordance needs associations, callbacks, or validations\n\n```ruby\n# app/models/card/entropic.rb\nmodule Card::Entropic\n  extend ActiveSupport::Concern\n\n  included do\n    has_one :activity_spike, dependent: :destroy  # Infrastructure\n    after_save :check_entropy_status\n  end\n\n  def entropy  # Entry to affordance\n    Card::Entropy.for(self)\n  end\n\n  def entropic?\n    entropy.present?\n  end\nend\n```\n\n### Pattern 2: Entry Directly in Model\n\nUse when: No concern infrastructure needed\n\n```ruby\n# app/models/event.rb\nclass Event < ApplicationRecord\n  def description\n    @description ||= Event::Description.new(self, Current.user)\n  end\nend\n```\n\n**Don't create concern just for entry point.**\n\n### Pattern 3: Factory Method Pattern\n\nUse when: Affordance may not apply to all instances\n\n```ruby\n# Entry returns nil when not applicable\ndef entropy\n  Card::Entropy.for(self)  # Returns nil if card.last_active_at.nil?\nend\n\n# Class factory method\nclass Card::Entropy\n  class << self\n    def for(card)\n      return unless card.last_active_at\n      new(card, card.auto_postpone_period)\n    end\n  end\nend\n```\n\n## PORO Affordance Class\n\n**Always:** Plain Ruby object, no ActiveRecord inheritance\n\n```ruby\n# app/models/card/entropy.rb\n\n# Calculates entropy timing for auto-postponement\n#\n# Usage:\n#   card.entropy.auto_clean_at\n#   card.entropy.days_before_reminder\n#   card.entropy.reminder_due?\n#\nclass Card::Entropy\n  attr_reader :card, :auto_clean_period\n\n  class << self\n    def for(card)\n      return unless card.last_active_at\n      new(card, card.auto_postpone_period)\n    end\n  end\n\n  def initialize(card, auto_clean_period)\n    @card = card\n    @auto_clean_period = auto_clean_period\n  end\n\n  def auto_clean_at\n    card.last_active_at + auto_clean_period\n  end\n\n  def days_before_reminder\n    (auto_clean_period * 0.25).seconds.in_days.round\n  end\n\n  def reminder_due?\n    Time.current >= reminder_at\n  end\n\n  private\n\n    def reminder_at\n      auto_clean_at - days_before_reminder.days\n    end\nend\n```\n\n**Always add class-level usage examples.**\n\n## Naming & Organization\n\n### Class Names\n\n**Pattern:** `Parent::Concept` or `ParentConcept`\n\n| Entry Method | Class Name |\n|--------------|------------|\n| `card.entropy` | `Card::Entropy` |\n| `event.description` | `Event::Description` |\n| `notifier.for(source)` | `Notifier` (factory) |\n\n### File Organization\n\n```\napp/models/\n├── card.rb\n├── card/\n│   ├── entropy.rb              # Affordance PORO\n│   ├── entropic.rb             # Concern with entry point\n│   ├── closeable.rb            # Concern (no affordance needed)\n│   └── activity_spike/\n│       └── detector.rb         # Nested affordance\n├── event.rb\n└── event/\n    └── description.rb          # Affordance PORO\n```\n\n### Module Namespacing\n\n```ruby\n# app/models/card/entropy.rb\nclass Card::Entropy  # Namespaced under parent\n  # ...\nend\n\n# app/models/event/description.rb\nclass Event::Description\n  # ...\nend\n```\n\n## Common Patterns\n\n### Multiple Output Formats\n\n```ruby\nclass Event::Description\n  include ActionView::Helpers::TagHelper\n\n  def initialize(event, user)\n    @event = event\n    @user = user\n  end\n\n  def to_html\n    to_sentence(creator_tag, card_title_tag).html_safe\n  end\n\n  def to_plain_text\n    to_sentence(creator_name, card.title)\n  end\n\n  private\n\n    attr_reader :event, :user\n\n    delegate :card, :creator, to: :event\n\n    def to_sentence(*parts)\n      parts.compact.join(\" \")\n    end\nend\n```\n\n### Factory Dispatching\n\n```ruby\nclass Notifier\n  class << self\n    def for(source)\n      case source\n      when Event\n        notifier_for_event(source)\n      when Mention\n        MentionNotifier.new(source)\n      end\n    end\n\n    private\n\n      def notifier_for_event(event)\n        \"Notifier::#{event.eventable.class}EventNotifier\"\n          .safe_constantize\n          &.new(event)\n      end\n  end\n\n  def notify\n    recipients.map { |r| create_notification(r) } if should_notify?\n  end\nend\n```\n\n### Coordinating Detection Logic\n\n```ruby\nclass Card::ActivitySpike::Detector\n  def initialize(card)\n    @card = card\n  end\n\n  def detect\n    if has_activity_spike?\n      register_activity_spike\n      true\n    else\n      false\n    end\n  end\n\n  private\n\n    attr_reader :card\n\n    def has_activity_spike?\n      card.entropic? && (\n        multiple_people_commented? ||\n        card_was_just_assigned? ||\n        card_was_just_reopened?\n      )\n    end\n\n    def multiple_people_commented?\n      recent_commenters.count > 1\n    end\n\n    def recent_commenters\n      card.comments.where(\"created_at > ?\", 1.day.ago).distinct(:creator_id)\n    end\nend\n```\n\n### Chainable Affordances\n\n```ruby\nclass Board::Cards\n  def initialize(board)\n    @board = board\n  end\n\n  def for_user(user)\n    Board::UserCards.new(self, user)  # More granular\n  end\n\n  def active\n    board.cards.active\n  end\nend\n\n# Usage\nboard.cards.for_user(user).visible\n```\n\n### Passing as Dependencies\n\n```ruby\n# Narrow interface instead of full model\ndef render_notification_preview(description)\n  description.to_plain_text.truncate(100)\nend\n\nrender_notification_preview(event.description)  # Clear dependencies\n```\n\n## Memoization Rules\n\n**Memoize:** Stateless wrapper (no parameters beyond parent)\n```ruby\ndef entropy\n  @entropy ||= Card::Entropy.for(self)\nend\n\ndef description\n  @description ||= Event::Description.new(self, Current.user)\nend\n```\n\n**Don't memoize:** Parameterized affordances\n```ruby\ndef entropy(as_of: Time.current)\n  Card::Entropy.new(self, as_of: as_of)  # Different params = different instances\nend\n```\n\n## Anti-Patterns\n\n**Single-method wrapper:**\n```ruby\nclass Permissions\n  def can_edit?  # Only method - use plain method instead\n  end\nend\n```\n\n**ActiveRecord inheritance:**\n```ruby\nclass Card::Entropy < ApplicationRecord  # WRONG - use PORO\nend\n\nclass Card::Entropy  # Correct\n  def initialize(card, period)\n    @card = card\n    @period = period\n  end\nend\n```\n\n**Memoizing parameterized:**\n```ruby\ndef entropy(as_of: Time.current)\n  @entropy ||= Card::Entropy.new(self, as_of: as_of)  # WRONG - ignores param changes\nend\n```\n\n**Creating concern just for entry point:**\n```ruby\n# WRONG - unnecessary concern\nmodule Event::Describable\n  def description\n    Event::Description.new(self)\n  end\nend\n\n# RIGHT - put entry directly in model\nclass Event < ApplicationRecord\n  def description\n    @description ||= Event::Description.new(self)\n  end\nend\n```\n\n## Verification\n\n- [ ] PORO (no ActiveRecord inheritance)\n- [ ] 3+ methods (not single-method wrapper)\n- [ ] Class docs with usage examples\n- [ ] Memoization only for stateless\n- [ ] Private delegation to wrapped objects\n- [ ] File: `app/models/<parent>/<affordance>.rb`\n- [ ] Named: `Parent::Concept` pattern\n"
      },
      "plugins": [
        {
          "name": "vanilla-rails",
          "description": "Production-tested Rails patterns: CRUD controllers, rich models, concerns, fixtures, small PRs.",
          "source": "./vanilla-rails",
          "version": "1.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add ZempTime/zemptime-marketplace",
            "/plugin install vanilla-rails@zemptime-marketplace"
          ]
        },
        {
          "name": "swiss-design",
          "description": "Swiss/International Typographic Style principles for software and interaction design.",
          "source": "./swiss-design",
          "version": "1.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add ZempTime/zemptime-marketplace",
            "/plugin install swiss-design@zemptime-marketplace"
          ]
        }
      ]
    }
  ]
}