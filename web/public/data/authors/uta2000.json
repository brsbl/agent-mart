{
  "author": {
    "id": "uta2000",
    "display_name": "uta2000",
    "avatar_url": "https://avatars.githubusercontent.com/u/37979122?v=4"
  },
  "marketplaces": [
    {
      "name": "spec-driven",
      "version": null,
      "description": "Full feature development lifecycle — from design through implementation to verification, with live documentation lookups via Context7",
      "repo_full_name": "uta2000/spec-driven",
      "repo_url": "https://github.com/uta2000/spec-driven",
      "repo_description": "Claude Code plugin: acceptance criteria discipline for AI-assisted development",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-19T22:19:39Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"spec-driven\",\n  \"description\": \"Full feature development lifecycle — from design through implementation to verification, with live documentation lookups via Context7\",\n  \"owner\": {\n    \"name\": \"uta2000\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"spec-driven\",\n      \"description\": \"Full feature development lifecycle — design docs, verification, acceptance criteria, coding standards enforcement, and automated checks. Queries Context7 for current library patterns. Anti-pattern detection hooks. Requires superpowers and context7 plugins.\",\n      \"version\": \"1.6.0\",\n      \"source\": \"./\",\n      \"author\": {\n        \"name\": \"uta2000\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"spec-driven\",\n  \"description\": \"Full feature development lifecycle — design docs, verification, acceptance criteria, and automated checks. Requires superpowers plugin.\",\n  \"version\": \"1.6.0\",\n  \"author\": {\n    \"name\": \"uta2000\"\n  },\n  \"homepage\": \"https://github.com/uta2000/spec-driven\",\n  \"repository\": \"https://github.com/uta2000/spec-driven\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"spec-driven\", \"lifecycle\", \"design-verification\", \"acceptance-criteria\", \"platform-aware\", \"auto-discovery\", \"gotchas\", \"context7\", \"documentation\", \"coding-standards\"]\n}\n",
        "README.md": "# spec-driven\n\nA Claude Code plugin that enforces discipline across the feature development lifecycle — from design through implementation to verification. Context-aware: adapts to your platform (web, iOS, Android) and tech stack, and queries up-to-date documentation via [Context7](https://context7.com/) to ensure code follows current best practices.\n\n## The Problem\n\nFeatures get brainstormed, then jump straight to code. Halfway through, you discover schema constraints that don't match, types that need changing, pipeline assumptions that break. A 2-hour feature becomes a 6-hour debugging session.\n\n## The Solution\n\nSix skills and an orchestrator that cover the full feature development lifecycle. Catch conflicts when they're cheap to fix — a line edit in a design doc instead of a code rewrite.\n\nspec-driven handles the **design and verification** phases. For **implementation and delivery**, it delegates to the [superpowers](https://github.com/obra/superpowers) plugin — brainstorming, TDD, code review, worktrees, and PRs. For **documentation lookups**, it uses [Context7](https://context7.com/) to query current patterns from official docs before writing code.\n\n## Requirements\n\n- [Claude Code](https://docs.anthropic.com/en/docs/claude-code) CLI\n- [superpowers](https://github.com/obra/superpowers) plugin (required — handles brainstorming, implementation planning, TDD, code review, worktrees, and PR workflow)\n- [Context7](https://marketplace.claude.ai/plugin/context7) MCP plugin (required — provides live documentation lookups for any tech stack during design and implementation)\n\n## Installation\n\n### From the marketplace\n\n```bash\n# Install required plugins first\nclaude plugins add superpowers\nclaude plugins add context7\n\n# Install spec-driven\nclaude plugins add spec-driven\n```\n\n### From GitHub\n\n```bash\n# Install required plugins first\nclaude plugins add https://github.com/obra/superpowers\nclaude plugins add context7\n\n# Install spec-driven\nclaude plugins add https://github.com/uta2000/spec-driven\n```\n\n### Per-project (manual)\n\nCopy the `agents/`, `skills/`, `hooks/`, and `references/` directories into your project's `.claude/` directory. You still need the superpowers and context7 plugins installed separately.\n\n## Quick Start\n\nAfter installing, open any project and tell Claude:\n\n```\nstart feature: add user notifications\n```\n\nspec-driven will:\n1. Scan your project files and auto-detect your platform and tech stack\n2. Resolve Context7 documentation libraries for each detected technology\n3. Create a `.spec-driven.yml` with your project context (first time only)\n4. Classify the scope (quick fix → major feature)\n5. Walk you through the right steps — brainstorm, look up docs, design, verify, implement, ship\n\nThe lifecycle adds ~20-30 minutes of upfront design but typically saves 2-4 hours of mid-implementation debugging per feature.\n\nFor a quick fix, just say what's broken — the lifecycle is 4 steps: understand, fix (TDD), verify, PR.\n\n## How It Works with Superpowers and Context7\n\nspec-driven owns the design and verification phases. superpowers owns implementation and delivery. Context7 provides live documentation lookups. The `start-feature` orchestrator coordinates all three:\n\n| Lifecycle Step | Plugin | Skill / Tool |\n|---------------|--------|-------------|\n| Brainstorm | superpowers | `brainstorming` |\n| Spike / PoC | **spec-driven** | `spike` (queries Context7 docs before experiments) |\n| Documentation lookup | **Context7** | `resolve-library-id` + `query-docs` |\n| Design document | **spec-driven** | `design-document` |\n| Design verification | **spec-driven** + **Context7** | `design-verification` (includes doc compliance check) |\n| Create issue | **spec-driven** | `create-issue` |\n| Implementation plan | superpowers | `writing-plans` |\n| Verify plan criteria | **spec-driven** | `verify-plan-criteria` |\n| Worktree setup | superpowers | `using-git-worktrees` |\n| Study existing patterns | **spec-driven** (inline) | Reads codebase conventions, generates \"How to Code This\" notes |\n| Implement (TDD) | superpowers | `test-driven-development` |\n| Self-review | **spec-driven** (inline) | Reviews code against `coding-standards.md` checklist |\n| Code review | superpowers | `requesting-code-review` |\n| Final verification | **spec-driven** + superpowers | `verify-acceptance-criteria` + `verification-before-completion` |\n| Commit and PR | superpowers | `finishing-a-development-branch` |\n\n## Skills\n\n### Lifecycle Orchestrator\n\n| Skill | Purpose |\n|-------|---------|\n| `start-feature` | Orchestrates the full lifecycle from idea to PR — classifies scope, loads project context, builds the platform-aware step list, and invokes the right skill at each stage |\n\n### Pre-Implementation (Design Phase)\n\n| Skill | Step | Purpose |\n|-------|------|---------|\n| `spike` | 3 | De-risk technical unknowns with time-boxed experiments before committing to a design |\n| `design-document` | 4 | Turn brainstorming decisions into structured, implementable design docs |\n| `design-verification` | 5 | Verify a design against the actual codebase — schema, types, pipelines, routes, dependencies, plus stack and platform-specific checks |\n| `create-issue` | 6 | Create well-structured GitHub issues from verified designs |\n\n### Post-Implementation (Verification Phase)\n\n| Skill | Step | Purpose |\n|-------|------|---------|\n| `verify-plan-criteria` | 8 | Validate every task has machine-verifiable acceptance criteria, auto-draft missing ones |\n| `verify-acceptance-criteria` | 12 | Mechanically check each criterion against the codebase before claiming work is done |\n\n### Agent\n\n| Component | Purpose |\n|-----------|---------|\n| `task-verifier` | Runs PASS/FAIL/CANNOT_VERIFY checks with evidence |\n\n## Using Skills Standalone\n\nWhile `start-feature` is the recommended entry point, you can invoke any skill directly:\n\n```\nrun design-verification on docs/plans/2024-03-15-notifications-design.md\n```\n\n```\nrun verify-acceptance-criteria against the plan in docs/plans/\n```\n\nSkills that need project context (`design-verification`, `spike`) will auto-create `.spec-driven.yml` if it doesn't exist (same auto-discovery flow as `start-feature`). Other skills like `verify-plan-criteria` and `verify-acceptance-criteria` work without it.\n\n## Where These Fit in the Lifecycle\n\n```\n 1. Idea\n 2. Brainstorming                  ← superpowers:brainstorming\n 3. Spike / PoC                    ← spike (queries Context7 docs first)\n 4. Documentation Lookup           ← Context7 (resolve-library-id + query-docs)\n 5. Design Document                ← design-document\n 6. Design Verification            ← design-verification (+ stack/platform/doc compliance checks)\n 7. GitHub Issue                   ← create-issue\n 8. Implementation Plan            ← superpowers:writing-plans\n 9. Plan Criteria Check            ← verify-plan-criteria\n10. Worktree Setup                 ← superpowers:using-git-worktrees\n11. Study Existing Patterns        ← inline (reads codebase, generates \"How to Code This\" notes)\n12. Implementation (TDD)           ← superpowers:test-driven-development\n12b. Device Matrix Testing         ← mobile only\n13. Self-Review                    ← inline (coding-standards.md checklist)\n14. Code Review                    ← superpowers:requesting-code-review\n15. Final Verification             ← verify-acceptance-criteria + superpowers:verification-before-completion\n15b. Beta Testing                  ← mobile only (TestFlight / Play Console)\n16. PR / Merge                     ← superpowers:finishing-a-development-branch\n16b. App Store Review              ← mobile only\n17. Deploy\n```\n\n## Hooks\n\n| Hook | Trigger | Action |\n|------|---------|--------|\n| PreToolUse (Write) | New source file being created | Reminds to check Context7 docs; **BLOCKS** if code contains `any` types, `as any`, or empty catch blocks |\n| PreToolUse (Edit) | Source file being edited | **BLOCKS** if new code contains `any` types, `as any`, or empty catch blocks |\n| PostToolUse (Write) | Plan file written to `plans/*.md` | Reminds to run `verify-plan-criteria` |\n| PostToolUse (Write/Edit) | Source file written or edited | Warns about `console.log`/`console.debug` (non-blocking — useful during TDD, cleaned up in self-review) |\n| SessionStart | Every session | Injects spec-driven conventions into context |\n| Stop | Session ending | Blocks if code was implemented without running `verify-acceptance-criteria` |\n\n## Project Context\n\nspec-driven uses a `.spec-driven.yml` file in your project root for platform and stack-specific behavior. **You don't need to create this manually** — `start-feature` auto-detects your platform and stack from project files (package.json, Gemfile, go.mod, config files, directory structure, etc.) and creates it for you on first run.\n\n```yaml\n# .spec-driven.yml (auto-generated, then curated)\nplatform: web          # web | ios | android | cross-platform\nstack:\n  - supabase\n  - next-js\n  - vercel\ncontext7:              # Context7 library IDs for live doc lookups\n  next-js: /vercel/next.js\n  supabase:\n    - /websites/supabase\n    - /supabase/supabase-js\n    - /supabase/ssr\n  vercel: /vercel/next.js\ngotchas:\n  - \"PostgREST caps all queries at 1000 rows without .range() pagination\"\n```\n\n**Should you commit this file?** Yes — `.spec-driven.yml` should be committed to your repo. It captures project-specific knowledge (especially gotchas) that benefits the whole team. It's not sensitive data and evolves with the project.\n\n**How it works:**\n- `platform` adjusts the lifecycle — mobile adds beta testing, app store review, required feature flags\n- `stack` loads stack-specific verification checks during design verification\n- `context7` maps each stack to Context7 library IDs — skills query these for current patterns before designing and implementing\n- `gotchas` are injected into every verification — project-specific pitfalls learned from past bugs\n\n**Auto-discovery:** On first run, `start-feature` scans your project files, detects the stack, and resolves Context7 library IDs for each detected technology. It presents the full context for confirmation. On subsequent runs, it cross-checks for new dependencies and suggests additions.\n\n**Context7 resolution:** For every detected stack entry, spec-driven calls Context7's `resolve-library-id` to find the best documentation library. Well-known stacks (Next.js, Supabase, Vercel) use pre-verified mappings. All other stacks are resolved dynamically — this means spec-driven works with **any technology** Context7 has documentation for (Django, Rails, FastAPI, Vue, Angular, Stripe, Prisma, etc.).\n\n**Gotcha write-back:** When `design-verification` finds a reusable pitfall or `spike` discovers a denied assumption that could affect future features, the skill offers to add it to your gotchas list automatically. The file gets smarter over time without manual curation.\n\n### Pre-Built Stack References\n\n| Stack | Checks |\n|-------|--------|\n| `supabase` | PostgREST 1000-row limit, RLS policies, migration safety, Edge Function limits |\n| `next-js` | Server/client boundaries, route conflicts, env variable exposure, middleware |\n| `react-native` | Native bridge compat, Hermes engine, platform-specific code, app store compliance |\n| `vercel` | Serverless limits, Edge Function constraints, build time, cold starts |\n\n**Unknown stacks:** If no pre-built reference exists, skills research gotchas dynamically via web search and the project's own documentation.\n\n### Coding Standards and Code Quality\n\nspec-driven enforces senior-engineer code quality through three layers:\n\n1. **Study Existing Patterns** (before implementation) — Reads 2-3 existing files per area being modified, extracts conventions, and generates per-task \"How to Code This\" notes that map implementation tasks to specific codebase patterns\n2. **Self-Review** (after implementation) — Reviews all changed code against a 10-point checklist: function size (≤30 lines), naming conventions, error handling, type safety (no `any`), DRY, pattern adherence, separation of concerns, guard clauses (≤3 nesting levels), debug artifacts, import organization\n3. **Anti-pattern hooks** (real-time) — PreToolUse hooks on Write and Edit that **block** `any` types, `as any` assertions, and empty catch blocks from being written. `console.log/debug` is warned but not blocked (useful during TDD, cleaned up in self-review)\n\nAll three reference `references/coding-standards.md` — a comprehensive guide covering functions, error handling, DRY, TypeScript types, separation of concerns, naming, comments, performance, and testing. Stack-specific standards (Next.js, Supabase, React) are included.\n\n### Context7 Documentation Integration\n\nContext7 provides live documentation lookups for any technology, ensuring code follows current best practices even when frameworks release breaking changes or deprecate APIs.\n\n**How it works:**\n\n1. During auto-detection, spec-driven resolves Context7 library IDs for each stack entry\n2. Before writing the design document, the \"Documentation lookup\" step queries relevant libraries for current patterns\n3. During design verification, the \"Documentation Compliance\" check (category #17) verifies the design uses current patterns\n4. A PreToolUse hook reminds about doc lookups before creating new source files\n\n**Works with any stack:** Context7 hosts docs for thousands of libraries. Even if spec-driven doesn't have a pre-built stack reference file (e.g., for Django or Stripe), it can still resolve and query Context7 documentation dynamically.\n\n**Example — what doc lookups catch:**\n- Supabase deprecated `auth-helpers` in favor of `@supabase/ssr` — Context7 docs show the new `createServerClient` pattern\n- Next.js Server Actions should return `{ errors }` objects, not throw — Context7 docs show the `useActionState` pattern\n- A library changed its API between versions — Context7 has the current version's patterns\n\n### Platform Lifecycle Differences\n\n| Step | Web | Mobile |\n|------|-----|--------|\n| Feature flags | Recommended | Required |\n| API contract testing | Good practice | Required |\n| Migration dry-run | Recommended | Required |\n| Beta testing | Preview deploy | TestFlight / Play Console (added step) |\n| App store review | N/A | Required gate (added step) |\n| Rollback | Revert deploy | Feature flag kill switch + multi-version compat |\n| Device testing | Browser testing | OS + device + screen matrix |\n\n## Example: Design Verification in Action\n\nA design for a \"Creative Domain Generator\" was verified against the codebase before any code was written. The verification caught 5 issues:\n\n| Finding | What would have happened |\n|---------|------------------------|\n| `keyword_phrase` is NOT NULL | Runtime crash when inserting creative results without a keyword |\n| `service_id` / `location_id` are required FKs | Insert fails for freeform creative searches |\n| `format` CHECK constraint | DB rejects rows without `location_service` or `service_location` |\n| Pipeline hook assumes mechanical generation | Hook crashes when called without service/location IDs |\n| Results page assumes non-null relations | UI crash rendering creative search results |\n\nEach would have been 30-60 minutes of debugging mid-implementation. Total time saved: 3-4 hours.\n\n## Example: Project Gotchas Preventing Repeat Bugs\n\nAfter discovering Supabase's PostgREST 1000-row silent truncation bug (21+ queries affected, zero error signals), the team added it to `.spec-driven.yml`:\n\n```yaml\ngotchas:\n  - \"PostgREST caps all queries at 1000 rows without .range() pagination — causes silent data truncation with 200 OK\"\n```\n\nEvery future design verification now automatically checks: \"Does any new query expect >1,000 rows without pagination?\" The bug that took hours to diagnose becomes a checklist item that takes seconds to verify.\n\n## Acceptance Criteria Format\n\n```markdown\n### Task N: [Title]\n\n**Acceptance Criteria:**\n- [ ] File exists at `src/components/Badge.tsx`\n- [ ] Component exports `Badge` as named export\n- [ ] `npm run typecheck` passes with no new errors\n- [ ] `npm run lint` passes with no new warnings\n- [ ] [MANUAL] Badge renders red when condition is met\n\n**Files:**\n...\n```\n\nCriteria prefixed with `[MANUAL]` are flagged for human review rather than failing verification.\n\n## Verification Report\n\n```\n| # | Criterion | Status | Evidence |\n|---|-----------|--------|----------|\n| 1 | File exists at src/... | PASS | Found at expected path, 38 lines |\n| 2 | typecheck passes | PASS | 0 errors |\n| 3 | Badge renders red | CANNOT_VERIFY | Requires visual/runtime test |\n\nVerdict: VERIFIED (2/3 pass, 1 requires manual verification)\n```\n\n## Contributing Stack References\n\nTo add support for a new tech stack:\n\n1. Create `references/stacks/{stack-name}.md`\n2. Include sections: Context7 Documentation, Verification Checks, Common Gotchas, Risky Assumptions (for Spike)\n3. For the Context7 section, use `resolve-library-id` to find the best library IDs, and list key patterns to look up\n4. Follow the format of existing stack files (e.g., `references/stacks/supabase.md`)\n5. If the stack has well-known Context7 library IDs, add them to the Known Mappings table in `references/auto-discovery.md`\n6. Submit a PR\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "spec-driven",
          "description": "Full feature development lifecycle — design docs, verification, acceptance criteria, coding standards enforcement, and automated checks. Queries Context7 for current library patterns. Anti-pattern detection hooks. Requires superpowers and context7 plugins.",
          "version": "1.6.0",
          "source": "./",
          "author": {
            "name": "uta2000"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add uta2000/spec-driven",
            "/plugin install spec-driven@spec-driven"
          ]
        }
      ]
    }
  ]
}