{
  "author": {
    "id": "corca-ai",
    "display_name": "Corca",
    "avatar_url": "https://avatars.githubusercontent.com/u/72978860?v=4"
  },
  "marketplaces": [
    {
      "name": "corca-plugins",
      "version": null,
      "description": "A collection of Claude Code plugins for AI-Native Product Teams",
      "repo_full_name": "corca-ai/claude-plugins",
      "repo_url": "https://github.com/corca-ai/claude-plugins",
      "repo_description": null,
      "signals": {
        "stars": 66,
        "forks": 11,
        "pushed_at": "2026-02-21T12:19:14Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"corca-plugins\",\n  \"owner\": {\n    \"name\": \"Corca\",\n    \"email\": \"contact@corca.ai\"\n  },\n  \"metadata\": {\n    \"description\": \"A collection of Claude Code plugins for AI-Native Product Teams\",\n    \"version\": \"3.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"cwf\",\n      \"source\": \"./plugins/cwf\",\n      \"version\": \"0.8.9\",\n      \"description\": \"Corca Workflow Framework — consolidated hooks and skill orchestration for structured development sessions\",\n      \"keywords\": [\n        \"workflow\",\n        \"cwf\",\n        \"skills\",\n        \"hooks\",\n        \"clarify\",\n        \"plan\",\n        \"impl\",\n        \"retro\",\n        \"refactor\",\n        \"gather\",\n        \"review\",\n        \"ship\",\n        \"handoff\",\n        \"hitl\"\n      ]\n    }\n  ]\n}\n",
        "README.md": "# CWF (Corca Workflow Framework)\n\n> **Disclaimer (SoT)**  \n> `README.ko.md` is the single source of truth for CWF user-facing policy. If docs and implementation diverge, fix the plugin to match docs and report the mismatch via issue/PR.\n\n[한국어](README.ko.md)\n\nA Claude Code plugin that turns structured development sessions into a repeatable workflow — from gathering context through retrospective analysis. Maintained by [Corca](https://www.corca.ai/) for [AI-Native Product Teams](AI_NATIVE_PRODUCT_TEAM.md).\n\n## Installation\n\n### Quick start\n\n```bash\n# Add the marketplace\nclaude plugin marketplace add https://github.com/corca-ai/claude-plugins.git\n\n# Install CWF\nclaude plugin install cwf@corca-plugins\n\n# Restart Claude Code for hooks to take effect\n```\n\nAfter restart, run one-time bootstrap in Claude Code / Codex CLI:\n\n```text\ncwf:setup\n```\n\n`cwf:setup` standardizes first-run behavior by handling:\n\n- project config bootstrap (`.cwf-config.yaml`, `.cwf-config.local.yaml`)\n- tool detection (Codex/Gemini/Tavily/Exa) and optional Codex integration\n- local runtime dependency checks with install prompts (`shellcheck`, `jq`, `gh`, `node`, `python3`, `lychee`, `markdownlint-cli2`)\n- optional index generation (improves agent routing and progressive-disclosure navigation)\n\nFor detailed flags, see [setup](#setup).\n\n### Codex users (recommended)\n\nIf you also use Codex CLI, running only `cwf:setup` is enough to get guided defaults. Codex integration now follows the active plugin scope by default (`local > project > user`). Use the commands below when you want to re-apply Codex integration only:\n\n```bash\ncwf:setup --codex\ncwf:setup --codex-wrapper\n```\n\n### First workflow scenario\n\nIn Claude Code / Codex CLI, start with a plain prompt:\n\n```text\nI need to solve <problem>. Please use CWF and drive the workflow.\n```\n\nThe agent can invoke `cwf:run` and chain gather → clarify → plan → review(plan) → impl → review(code) → refactor → retro → ship. If automated review is not enough, switch to `cwf:hitl` to document key decision points and user concerns first, then continue chunk-by-chunk review.\n\nYou do not need to memorize every skill. The sections below explain why each skill exists and when to use it.\n\n### Update to latest version\n\n```bash\nclaude plugin marketplace update corca-plugins\nclaude plugin update cwf@corca-plugins\n```\n\nOr from inside Claude Code / Codex CLI:\n\n```text\ncwf:update               # Check + auto-update if newer version exists\ncwf:update --check       # Version check only\n```\n\n### Standalone plugins (legacy)\n\nAs of v3.0.0, legacy standalone plugins have been removed from the marketplace. If pre-v3.0 standalone plugins are installed, uninstall them and install `cwf` instead.\n\n## Operating Principles\n\n### What CWF Is\n\n- A single workflow plugin (`cwf`) that integrates context gathering, requirement clarification, planning, implementation, review, retrospective, handoff, and shipping.\n- A stateful workflow system where .cwf/cwf-state.yaml, session-log artifacts, and hooks preserve context across phase/session boundaries.\n- A composable skill framework built on shared concepts (Expert Advisor, Tier Classification, Agent Orchestration, Decision Point, Handoff, Provenance Tracking, Adaptive Setup Contract).\n- A cross-skill context-deficit resilience contract: after auto-compact/session restart, skills recover from persisted state/artifacts/handoff files instead of implicit chat memory.\n- A roadmap toward lower user bottlenecks by chaining smaller approval units (for example, dark-factory-style operating patterns).\n\n### What CWF Is Not\n\n- Not a replacement for project-specific engineering standards, CI gates, or human product ownership decisions.\n- Not a guarantee that every decision can be fully automated; subjective decisions still require user confirmation.\n- While each skill can be invoked independently, CWF is intentionally designed as a tightly coupled system and works best when skills are used together.\n\n### Assumptions\n\n- Users work in repositories where session artifacts (.cwf/projects/, .cwf/cwf-state.yaml) are allowed and useful.\n- Users accept progressive disclosure: start from AGENTS.md, then load deeper docs as needed.\n- Users prefer deterministic validation scripts for recurring quality checks over relying on behavioral memory.\n- Users expect missing prerequisites to trigger an install/configure prompt with retry, not a passive unavailable-only message.\n- Users expect skills to remain operable when prior conversation context is missing, using persisted state/artifacts/handoff contracts.\n- Users assume tokens are already cheap and likely to get cheaper (CWF targets heavy coding-agent usage patterns, including Claude Code/Codex `$200 Max` plan users).\n\n## Why CWF?\n\n### Problem\n\nAI coding sessions lose context at every boundary. When a session ends, the next one starts from scratch. When requirements shift from clarification to implementation, protocols and constraints are forgotten. When quality criteria are written for a five-skill system, they silently become irrelevant as the system grows.\n\nAs long-running work is parallelized, the final bottleneck shifts to human cognition and review throughput. Agent output can scale faster than human decision/verification capacity, so token minimization alone does not reduce end-to-end lead time.\n\n### Approach\n\nCWF addresses this with seven building-block concepts that compose across thirteen skills.\n\nDesign choices behind this approach:\n\n1. **Unified plugin over standalone plugins**\n   - Why: prevent context loss and protocol drift between phases.\n2. **Pre-impl human gates, post-impl autonomous chaining (`run`)**\n   - Why: keep high-judgment decisions human-controlled while preserving execution speed after scope is fixed.\n3. **File-path-only handoff start contracts**\n   - Why: make session continuation deterministic and reduce startup ambiguity.\n4. **Provenance Tracking checks for concept/review references**\n   - Why: detect stale criteria when skill/hook inventory changes.\n\nCWF prioritizes effectiveness over immediate token efficiency. It spends tokens to reduce human review bottlenecks up front, uses agent assistance during human review (`cwf:hitl`), then improves efficiency over repeated sessions through retro-driven iteration.\n\n### Result\n\nThe result: one plugin (`cwf`), thirteen skills, nine hook groups. Context survives session boundaries. Decisions are evidence-backed. Quality criteria evolve with the system.\n\n## Core Concepts\n\nSeven reusable behavioral patterns that CWF skills compose. Each concept below describes a job CWF must do to keep long-running AI sessions reliable.\n\n**Expert Advisor** — JTBD: re-check the same decision points through different expert frames so hidden assumptions and risks surface early. Decision Point structures what to decide; Expert Advisor strengthens how that decision is validated.\n\n**Tier Classification** — JTBD: route each decision to the right authority at the right time. Evidence-backed decisions (T1/T2) stay autonomous; genuinely subjective decisions (T3) are escalated to the user.\n\n**Agent Orchestration** — JTBD: increase throughput without losing consistency. The orchestrator sizes agent teams by complexity, executes dependency-aware batches, and synthesizes outputs into one coherent result.\n\n**Decision Point** — JTBD: turn ambiguity into explicit, reviewable choices. Requirements are decomposed into concrete questions so every decision has recorded evidence and rationale.\n\n**Handoff** — JTBD: prevent restart-from-zero at phase/session boundaries. Session handoffs preserve task context and lessons, while phase handoffs preserve protocols and constraints.\n\n**Provenance Tracking** — JTBD: prevent stale standards from silently driving current work. Reference docs carry system-state metadata and are checked before reuse.\n\n**Adaptive Setup Contract** — JTBD: keep setup portable while still adapting to each repository's real toolchain. First-run setup bootstraps a contract with core deterministic dependencies plus repo-specific tool suggestions for explicit approval.\n\n## The Workflow\n\nCWF's default `cwf:run` chain is:\n\n```text\ngather → clarify → plan → review(plan) → impl → review(code) → refactor → retro → ship\n```\n\n| # | Skill | Trigger | What It Does |\n|---|-------|---------|-------------|\n| 1 | [gather](#gather) | `cwf:gather` | Acquire information — URLs, web search, local code exploration |\n| 2 | [clarify](#clarify) | `cwf:clarify` | Turn vague requirements into precise specs via research + tier classification |\n| 3 | [plan](#plan) | `cwf:plan` | Draft a research-backed implementation plan with explicit testable success criteria |\n| 4 | [impl](#impl) | `cwf:impl` | Orchestrate parallel implementation from a plan |\n| 5 | [retro](#retro) | `cwf:retro` | Extract durable learnings through CDM analysis and expert lens |\n| 6 | [refactor](#refactor) | `cwf:refactor` | Multi-mode code and skill review — scan, tidy, deep review, holistic |\n| 7 | [handoff](#handoff) | `cwf:handoff` | Generate session or phase handoff documents |\n| 8 | [ship](#ship) | `cwf:ship` | Automate GitHub workflow — issues, PRs, and merge management |\n| 9 | [review](#review) | `cwf:review` | Multi-perspective review with 6 parallel reviewers |\n| 10 | [hitl](#hitl) | `cwf:hitl` | Human-in-the-loop diff/chunk review with resumable state and rule propagation |\n| 11 | [run](#run) | `cwf:run` | Orchestrate full pipeline chaining from gather to ship with stage gates |\n| 12 | [setup](#setup) | `cwf:setup` | Configure hooks/tools, bootstrap setup/env/index contracts, and propose repo-specific setup dependencies |\n| 13 | [update](#update) | `cwf:update` | Check and apply CWF plugin updates |\n\n## Skills Reference\n\nThis section is outcome-focused by design.\n\n- It defines each skill by intent (`why`) and expected behavior (`what happens`).\n- It omits detailed flag matrices, edge-case command flows, and rollback internals.\n- For full execution contracts, read each linked `SKILL.md` and its local references.\n- This summary format is standardized in [skill-conventions](plugins/cwf/references/skill-conventions.md#readme-skill-summary-format).\n\n### [gather](plugins/cwf/skills/gather/SKILL.md)\n\nPrimary trigger: `cwf:gather`\n\n**Why**\n\nTurn scattered external context into local, reusable evidence before reasoning and implementation start.\n\n**What Happens**\n\nCollects URL/web/local context, normalizes it into artifact files under `.cwf/projects/`, and preserves provenance so downstream stages reason from files rather than memory.\n\n**Expected Outcomes**\n\n1. Scattered documents and links are converted into normalized local artifacts with source traceability.\n2. If external web-search keys are missing, setup guidance is reported while available collection paths continue.\n3. Downstream skills can reference explicit gathered evidence instead of implicit chat memory.\n\n### [clarify](plugins/cwf/skills/clarify/SKILL.md)\n\nPrimary trigger: `cwf:clarify`\n\n**Why**\n\nResolve ambiguity early so implementation does not absorb avoidable rework.\n\n**What Happens**\n\nDecomposes requirements into decision points, classifies them by tier (evidence/standards/subjective), resolves what can be resolved autonomously, and escalates only true preference/policy choices.\n\n**Expected Outcomes**\n\n1. Vague requests are transformed into explicit decision points.\n2. Evidence-backed questions produce autonomous answers with rationale.\n3. Remaining preference or policy choices are returned to the user with concrete trade-offs.\n\n### [plan](plugins/cwf/skills/plan/SKILL.md)\n\nPrimary trigger: `cwf:plan`\n\n**Why**\n\nCreate an execution contract that implementation and review can enforce consistently.\n\n**What Happens**\n\nBuilds a structured `plan.md` with scope, file-level changes, and testable success criteria, then records carry-forward lessons for later phases.\n\n**Expected Outcomes**\n\n1. `plan.md` includes explicit scope, target files, and testable success criteria.\n2. Unresolved assumptions are surfaced as open items instead of being embedded silently.\n3. `cwf:review --mode plan` can validate contract quality before coding starts.\n\n### [impl](plugins/cwf/skills/impl/SKILL.md)\n\nPrimary trigger: `cwf:impl`\n\n**Why**\n\nConvert an approved plan into predictable execution without losing constraints.\n\n**What Happens**\n\nDecomposes approved work into dependency-aware execution units, runs safe parallel batches, and validates completion against the plan's success criteria.\n\n**Expected Outcomes**\n\n1. Produced changes map back to approved plan work units.\n2. Order-sensitive tasks remain sequenced while independent tasks are parallelized.\n3. Unresolved risks and follow-up actions are captured with supporting evidence.\n\n### [retro](plugins/cwf/skills/retro/SKILL.md)\n\nPrimary trigger: `cwf:retro`\n\n**Why**\n\nTurn a single session into durable operating improvements instead of one-off notes.\n\n**What Happens**\n\nAnalyzes session evidence, captures causes and decisions, and routes actionable improvements into reusable documentation/check/process changes.\n\n**Expected Outcomes**\n\n1. `retro.md` records what happened, why it happened, and what should change next.\n2. Repeated friction patterns are categorized by enforcement tier.\n3. Deep mode persists expert-lens outputs and learning resources alongside core retro artifacts.\n\n### [refactor](plugins/cwf/skills/refactor/SKILL.md)\n\nPrimary trigger: `cwf:refactor`\n\n**Why**\n\nControl drift across code, skills, docs, hooks, and scripts as capability surface grows.\n\n**What Happens**\n\nRuns quick/deep/docs-oriented inspections and produces concrete findings and fix targets so maintainability can be recovered systematically.\n\n**Expected Outcomes**\n\n1. Structural and quality drift is reported with explicit severity and impacted scope.\n2. Docs mode surfaces consistency, link, and provenance issues deterministically.\n3. Re-runs after fixes show warning/error convergence with traceable evidence.\n\n### [handoff](plugins/cwf/skills/handoff/SKILL.md)\n\nPrimary trigger: `cwf:handoff`\n\n**Why**\n\nPreserve continuity across session and phase boundaries without relying on conversational memory.\n\n**What Happens**\n\nGenerates session or phase handoff artifacts from persisted state and outputs, capturing scope, constraints, unresolved items, and restart instructions.\n\n**Expected Outcomes**\n\n1. The next session gets an explicit file-based starting contract.\n2. Phase handoff adds HOW-level constraints that complement WHAT-level planning artifacts.\n3. After compact/restart events, execution can resume from artifacts without hidden memory assumptions.\n\n### [ship](plugins/cwf/skills/ship/SKILL.md)\n\nPrimary trigger: `cwf:ship`\n\n**Why**\n\nStandardize issue/PR/merge preparation while keeping final human judgment explicit.\n\n**What Happens**\n\nTransforms validated session artifacts into structured issue/PR/merge-ready outputs with clear guardrails for unresolved risk.\n\n**Expected Outcomes**\n\n1. Issue and PR materials include decision context and verification evidence.\n2. Unresolved blocking items hold progression and are surfaced explicitly.\n3. Merge remains actionable only with explicit user approval and a clean state.\n\n### [review](plugins/cwf/skills/review/SKILL.md)\n\nPrimary trigger: `cwf:review`\n\n**Why**\n\nApply one consistent quality gate at high-leverage points before and after implementation.\n\n**What Happens**\n\nRuns parallel multi-perspective review (internal, external, domain experts), synthesizes findings into a verdict, and records deterministic gate outcomes.\n\n**Expected Outcomes**\n\n1. Plan-mode review exposes specification risks before code is written.\n2. Code-mode review synthesizes regression, security, and architecture concerns into explicit findings.\n3. Fallback routing preserves gate semantics when external providers are unavailable.\n\n### [hitl](plugins/cwf/skills/hitl/SKILL.md)\n\nPrimary trigger: `cwf:hitl`\n\n**Why**\n\nInject deliberate human judgment where automated review is insufficient.\n\n**What Happens**\n\nStarts with an agreement round, then runs resumable chunk-based review with persisted rules/state so long review sessions remain controllable.\n\n**Expected Outcomes**\n\n1. Large diffs are reviewed as resumable chunks with persisted cursor/state.\n2. New review rules are propagated to the remaining queue behavior.\n3. Interrupted review sessions can restore progress and rationale from artifacts.\n\n### [run](plugins/cwf/skills/run/SKILL.md)\n\nPrimary trigger: `cwf:run`\n\n**Why**\n\nDelegate end-to-end workflow orchestration without manually chaining individual skills.\n\n**What Happens**\n\nOrchestrates the default stage chain with human gates before implementation and autonomous chaining after implementation, while persisting stage state for safe continuation.\n\n**Expected Outcomes**\n\n1. The pipeline progresses stage by stage with explicit gates.\n2. Unresolved pre-implementation ambiguity triggers user decisions before irreversible execution.\n3. Persisted run-state checkpoints support reliable resume after compact/restart events.\n\n### [setup](plugins/cwf/skills/setup/SKILL.md)\n\nPrimary trigger: `cwf:setup`\n\n**Why**\n\nStandardize runtime/tool contracts once so later workflow runs stay reproducible.\n\n**What Happens**\n\nGuides initial contract bootstrap for hooks, dependencies, environment, config, and optional integrations, then persists the chosen baseline for deterministic operation.\n\n**Expected Outcomes**\n\n1. Baseline setup artifacts and policy context are created for a fresh repository.\n2. Missing required dependencies trigger interactive install-now prompts and deterministic rechecks.\n3. Selected Codex integration reports reconciled scope-aware links and wrapper state.\n\n### [update](plugins/cwf/skills/update/SKILL.md)\n\nPrimary trigger: `cwf:update`\n\n**Why**\n\nKeep installed CWF behavior aligned with the latest contracts, fixes, and guardrails.\n\n**What Happens**\n\nChecks scope-specific installed vs latest state, auto-applies updates for the selected scope when a newer version exists, and reconciles scope-aware Codex linkage when needed.\n\n**Expected Outcomes**\n\n1. A newer version is applied immediately in the selected scope (unless `--check` is used).\n2. Check mode reports status without installation or reconcile mutations.\n3. Reconcile reports before/after integration state when install-path drift exists.\n4. If latest-version verification is `UNVERIFIED`, update flow fails closed (no success-style no-update verdict).\n5. Changelog summary runs only when the user explicitly opts in.\n\n### Codex Integration\n\nIf Codex CLI is installed, recommended setup is:\n\n```bash\ncwf:setup --codex\ncwf:setup --codex-wrapper\n```\n\nWhat this enables:\n- Script map for Codex/session helpers: [plugins/cwf/scripts/README.md](plugins/cwf/scripts/README.md)\n- Scope-aware target resolution (active plugin scope precedence: `local > project > user`)\n- User scope targets: `~/.agents/skills/*`, `~/.agents/references`, `~/.local/bin/codex`\n- Project/local scope targets: `{projectRoot}/.codex/skills/*`, `{projectRoot}/.codex/references`, `{projectRoot}/.codex/bin/codex`\n- Non-user runs do not mutate user-global Codex paths unless explicitly confirmed\n- Every `codex` run auto-syncs session markdown logs into `.cwf/sessions/` as `*.codex.md`\n- Session log sync is append-first with checkpointed incremental updates to reduce exit-time latency; if state is missing/inconsistent, it safely falls back to full rebuild\n- Session artifact directories (`plan.md`, `retro.md`, `next-session.md`) remain under `.cwf/projects/{YYMMDD}-{NN}-{title}/`\n- Sync is anchored to the session updated during the current run (reduces wrong-session exports on shared cwd)\n- Raw JSONL copy is opt-in (`--raw`); redaction still applies when raw export is enabled\n- Post-run quality checks on changed files (markdownlint, local link checks, shellcheck when available, live state check, `apply_patch via exec_command` hygiene detection, and HITL scratchpad sync detection for doc edits) with `warn|strict` mode control\n- `cwf:update` reconciles stale Codex symlink/wrapper targets for the selected scope after plugin update\n- Runtime controls:\n  - `CWF_CODEX_POST_RUN_CHECKS=true|false` (default: `true`)\n  - `CWF_CODEX_POST_RUN_MODE=warn|strict` (default: `warn`)\n  - `CWF_CODEX_POST_RUN_QUIET=true|false` (default: `false`)\n\nVerify:\n\n```bash\nbash plugins/cwf/scripts/codex/install-wrapper.sh --scope user --status\n# or for project/local scope\nbash plugins/cwf/scripts/codex/install-wrapper.sh --scope project --project-root \"$PWD\" --status\ntype -a codex\n```\n\nFor one-time cleanup of existing session logs:\n\n```bash\nbash plugins/cwf/scripts/codex/redact-session-logs.sh\n```\n\nAfter install, open a new shell (or `source ~/.zshrc`). Aliases that call `codex` (for example `codexyolo='codex ...'`) also use the wrapper.\n\n## Hooks\n\nCWF includes 9 hook groups that run automatically. All are enabled by default; use `cwf:setup --hooks` to toggle individual groups.\n\n| Group | Hook Type | What It Does |\n|-------|-----------|-------------|\n| `attention` | Notification, Pre/PostToolUse | Slack notifications on idle and AskUserQuestion |\n| `log` | Stop, SessionEnd | Auto-log conversation turns to markdown |\n| `read` | PreToolUse → Read | File-size aware reading guard (warn >500 lines, block >2000) |\n| `lint_markdown` | PostToolUse → Write\\|Edit | Markdown lint + local link validation — lint violations trigger self-correction, broken links reported async |\n| `lint_shell` | PostToolUse → Write\\|Edit | ShellCheck validation for shell scripts |\n| `deletion_safety` | PreToolUse → Bash | Block risky deletion commands and require policy-compliant justification |\n| `workflow_gate` | UserPromptSubmit | Block `cwf:run` when setup prerequisites are missing, and block ship/push/merge intents when run-stage gates are unresolved |\n| `websearch_redirect` | PreToolUse → WebSearch | Redirect Claude's WebSearch to `cwf:gather --search` |\n| `compact_recovery` | SessionStart → compact, UserPromptSubmit | Inject live session state after auto-compact and guard session↔worktree binding on prompts |\n\n## Configuration\n\nCWF runtime loads configuration in this priority order:\n\n1. `.cwf-config.local.yaml` (local/secret, highest priority)\n2. `.cwf-config.yaml` (team-shared defaults)\n3. Process environment\n4. Shell profiles (`~/.zshenv`, `~/.zprofile`, `~/.zshrc`, `~/.bash_profile`, `~/.bashrc`, `~/.profile`)\n\n`cwf:setup` bootstraps project config templates and ensures `.cwf-config.local.yaml` is gitignored.\n\nUse `.cwf-config.yaml` for shared non-secret defaults:\n\n```yaml\n# .cwf-config.yaml\n# Optional artifact path overrides\n# CWF_ARTIFACT_ROOT: \".cwf\"\n# CWF_PROJECTS_DIR: \".cwf/projects\"\n# CWF_STATE_FILE: \".cwf/cwf-state.yaml\"\n\n# Optional runtime overrides (non-secret)\n# CWF_GATHER_OUTPUT_DIR: \".cwf/projects\"\n# CWF_READ_WARN_LINES: 500\n# CWF_READ_DENY_LINES: 2000\n# CWF_SESSION_LOG_DIR: \".cwf/sessions\"\n# CWF_SESSION_LOG_ENABLED: true\n# CWF_SESSION_LOG_TRUNCATE: 10\n# CWF_SESSION_LOG_AUTO_COMMIT: false\n```\n\nUse `.cwf-config.local.yaml` for local/secret values:\n\n```yaml\n# .cwf-config.local.yaml\nSLACK_BOT_TOKEN: \"xoxb-your-bot-token\"\nSLACK_CHANNEL_ID: \"D0123456789\"\nTAVILY_API_KEY: \"tvly-your-key\"\nEXA_API_KEY: \"your-key\"\n# SLACK_WEBHOOK_URL: \"https://hooks.slack.com/services/...\"\n```\n\nIf you prefer global fallback defaults, environment variables are still supported:\n\n```bash\n# Required — Slack notifications (attention hook)\nSLACK_BOT_TOKEN=\"xoxb-your-bot-token\"           # Slack App with chat:write + im:write scopes\nSLACK_CHANNEL_ID=\"D0123456789\"                  # Bot DM channel ID (or C... for channels)\n# SLACK_WEBHOOK_URL=\"https://hooks.slack.com/services/...\"  # Optional fallback, no threading\n\n# Required — search APIs (gather)\nTAVILY_API_KEY=\"tvly-...\"                       # Web search and URL extraction (https://app.tavily.com)\nEXA_API_KEY=\"...\"                               # Code search (https://dashboard.exa.ai)\n\n# Optional overrides — attention\nCWF_ATTENTION_DELAY=45                          # default: 30\nCWF_ATTENTION_REPLY_BROADCAST=true              # default: false\nCWF_ATTENTION_TRUNCATE=20                       # default: 10\nCWF_ATTENTION_USER_ID=\"U0123456789\"             # default: unset\n# CWF_ATTENTION_USER_HANDLE=\"your-handle\"       # default: unset\n# CWF_ATTENTION_PARENT_MENTION=\"<@U0123456789>\" # default: unset\n\n# Optional overrides — gather/read/session log\nCWF_GATHER_OUTPUT_DIR=\".cwf/projects\"               # default: .cwf/projects\nCWF_READ_WARN_LINES=700                            # default: 500\nCWF_READ_DENY_LINES=2500                           # default: 2000\nCWF_SESSION_LOG_DIR=\".cwf/sessions\"                # default: .cwf/sessions\nCWF_SESSION_LOG_ENABLED=false                      # default: true\nCWF_SESSION_LOG_TRUNCATE=20                        # default: 10\nCWF_SESSION_LOG_AUTO_COMMIT=true                   # default: false\n\n# Optional overrides — artifact layout (advanced)\n# CWF_ARTIFACT_ROOT=\".cwf-data\"                    # default: .cwf\n# CWF_PROJECTS_DIR=\".cwf/projects\"                 # default: {CWF_ARTIFACT_ROOT}/projects\n# CWF_STATE_FILE=\".cwf/custom-state.yaml\"          # default: {CWF_ARTIFACT_ROOT}/cwf-state.yaml\n```\n\nLegacy env migration is intentionally out of the default `cwf:setup` flow in v3. If you are upgrading from pre-v3 keys (`CLAUDE_CORCA_*`, `CLAUDE_ATTENTION_*`), run this prompt in Claude Code / Codex:\n\n```text\nI upgraded from a pre-v3 CWF setup and may still have legacy CLAUDE_CORCA_* / CLAUDE_ATTENTION_* env vars.\nPlease detect my installed CWF plugin path, run migrate-env-vars.sh --scan, show the migration candidates, and ask for confirmation before running --apply --cleanup-legacy --include-placeholders.\n```\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "cwf",
          "source": "./plugins/cwf",
          "version": "0.8.9",
          "description": "Corca Workflow Framework — consolidated hooks and skill orchestration for structured development sessions",
          "keywords": [
            "workflow",
            "cwf",
            "skills",
            "hooks",
            "clarify",
            "plan",
            "impl",
            "retro",
            "refactor",
            "gather",
            "review",
            "ship",
            "handoff",
            "hitl"
          ],
          "categories": [
            "clarify",
            "cwf",
            "gather",
            "handoff",
            "hitl",
            "hooks",
            "impl",
            "plan",
            "refactor",
            "retro",
            "review",
            "ship",
            "skills",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add corca-ai/claude-plugins",
            "/plugin install cwf@corca-plugins"
          ]
        }
      ]
    }
  ]
}