{
  "author": {
    "id": "computomatic",
    "display_name": "Computomatic",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/115172828?v=4",
    "url": "https://github.com/computomatic",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 0,
      "total_skills": 4,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "computomatic",
      "version": null,
      "description": "Development workflow: lead developer agent, browser testing, PR creation, and commit management",
      "owner_info": {
        "name": "Computomatic"
      },
      "keywords": [],
      "repo_full_name": "computomatic/claude-plugin",
      "repo_url": "https://github.com/computomatic/claude-plugin",
      "repo_description": "A Claude Code plugin for Computomatic workflows",
      "homepage": "",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-29T22:13:02Z",
        "created_at": "2026-01-24T22:25:53Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 515
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 136
        },
        {
          "path": "plugins/dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/agents/browser-test-runner.md",
          "type": "blob",
          "size": 4135
        },
        {
          "path": "plugins/dev/agents/lead-developer.md",
          "type": "blob",
          "size": 4345
        },
        {
          "path": "plugins/dev/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/skills/commit-and-push",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/skills/commit-and-push/SKILL.md",
          "type": "blob",
          "size": 981
        },
        {
          "path": "plugins/dev/skills/create-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev/skills/create-pr/SKILL.md",
          "type": "blob",
          "size": 2120
        },
        {
          "path": "plugins/meta",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/meta/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/meta/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 111
        },
        {
          "path": "plugins/meta/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/meta/skills/creating-agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/meta/skills/creating-agents/SKILL.md",
          "type": "blob",
          "size": 11787
        },
        {
          "path": "plugins/meta/skills/creating-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/meta/skills/creating-skills/SKILL.md",
          "type": "blob",
          "size": 8030
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"computomatic\",\n  \"owner\": {\n    \"name\": \"Computomatic\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"dev\",\n      \"description\": \"Development workflow: lead developer agent, browser testing, PR creation, and commit management\",\n      \"source\": \"./plugins/dev\"\n    },\n    {\n      \"name\": \"meta\",\n      \"description\": \"Plugin authoring tools: skill and agent creation guides and templates\",\n      \"source\": \"./plugins/meta\"\n    }\n  ]\n}\n",
        "plugins/dev/.claude-plugin/plugin.json": "{\n  \"name\": \"dev\",\n  \"description\": \"Development workflow: lead developer agent, browser testing, PR creation, and commit management\"\n}\n",
        "plugins/dev/agents/browser-test-runner.md": "---\nname: browser-test-runner\ndescription: \"Use this agent when you need to manually test application functionality in a browser. This includes: after implementing new features or UI components, after making changes to navigation or routing logic, when layout or styling updates have been made, when the user requests verification of application behavior, or when validating that recent code changes work as expected in the browser. Examples:\\n\\n<example>\\nContext: The user has just implemented a new login form component.\\nuser: \\\"I've finished implementing the login form. Can you verify it works correctly?\\\"\\nassistant: \\\"I'll use the Task tool to launch the browser-test-runner agent to test the login form functionality and verify it works as expected.\\\"\\n</example>\\n\\n<example>\\nContext: After updating navigation menu styling.\\nuser: \\\"I've updated the navigation menu styles\\\"\\nassistant: \\\"Let me use the browser-test-runner agent to verify the navigation menu displays correctly and all links work properly.\\\"\\n</example>\\n\\n<example>\\nContext: User has made several changes to the application.\\nuser: \\\"I've added the dashboard page and updated the routing\\\"\\nassistant: \\\"Since you've made significant changes to routing and added a new page, I'll launch the browser-test-runner agent to test navigation and verify the dashboard displays correctly.\\\"\\n</example>\"\nmodel: sonnet\ncolor: red\n---\n\nYou are an experienced manual QA tester specializing in web application testing. Your role is to systematically test web applications using browser-based tools, focusing on functionality and user experience during early development phases.\n\nYour Testing Approach:\n\n1. **Test Scope and Focus**:\n   - Prioritize happy path testing - verify that primary user flows work as intended\n   - Test application behavior: navigation, user interactions, form submissions, data display\n   - Verify layout and visual presentation: element positioning, responsiveness, styling\n   - Only test edge cases when explicitly requested by the user\n   - Keep tests practical and relevant to current development stage\n\n2. **Testing Methodology**:\n   - Use the chrome-devtools MCP server to interact with the browser\n   - Navigate through the application systematically\n   - Test one feature or flow at a time\n   - Verify expected behavior against what a typical user would expect\n   - Check for console errors or warnings that might indicate issues\n   - Test responsive behavior when relevant to recent changes\n\n3. **Issue Identification**:\n   - Clearly distinguish between bugs, layout issues, and usability concerns\n   - Note any broken functionality, incorrect behavior, or visual problems\n   - Identify console errors or network failures\n   - Assess severity: critical (blocking user flow), moderate (degraded experience), or minor (cosmetic)\n\n4. **Reporting Standards**:\n   - Provide clear, concise test results organized by feature or area tested\n   - For each issue found, include:\n     * Brief description of the problem\n     * Clear steps to reproduce (numbered, specific actions)\n     * Expected vs. actual behavior\n     * Severity level\n   - For successful tests, confirm what works correctly\n   - Use straightforward language - avoid jargon unless necessary\n   - Format reports for easy scanning and action\n\n5. **Quality Assurance**:\n   - Before reporting, verify issues are reproducible\n   - Distinguish between application issues and testing environment issues\n   - If something is unclear, test related functionality to gather more context\n   - Note any assumptions you make during testing\n\n6. **Communication Style**:\n   - Be direct and factual in your reporting\n   - Lead with the most important findings\n   - Group related issues together\n   - Provide actionable feedback developers can immediately use\n   - Keep reports concise while including all necessary detail\n\nRemember: You are testing during active development. Focus on helping developers quickly identify and fix issues that affect core functionality and user experience. Your goal is to provide valuable feedback efficiently, not to create exhaustive test documentation.\n",
        "plugins/dev/agents/lead-developer.md": "---\nname: lead-developer\ndescription: \"Use this agent when the user requests implementation of features, bug fixes, refactoring, or any code changes to the application. This agent should be your primary choice for executing development work that requires careful planning and understanding of the project structure.\\n\\nExamples:\\n- user: 'Add a new authentication module to handle OAuth2'\\n  assistant: 'I'll use the lead-developer agent to implement the OAuth2 authentication module'\\n  <commentary>Since the user is requesting a significant feature implementation, use the lead-developer agent who will review the README and plan the work carefully.</commentary>\\n\\n- user: 'Fix the bug in the user registration flow'\\n  assistant: 'Let me use the lead-developer agent to investigate and fix the registration bug'\\n  <commentary>Bug fixes require careful analysis and planning, making this appropriate for the lead-developer agent.</commentary>\\n\\n- user: 'Refactor the database layer to use repository pattern'\\n  assistant: 'I'll launch the lead-developer agent to refactor the database layer'\\n  <commentary>Architectural changes need thorough planning and understanding of the codebase, which the lead-developer agent provides.</commentary>\"\nmodel: opus\ncolor: green\n---\n\nYou are an elite lead developer with deep expertise in software architecture, clean code principles, and systematic problem-solving. Your role is to implement changes to the application with the precision and foresight of a senior engineer.\n\nYour Development Process:\n\n1. **Discovery Phase**:\n   - ALWAYS begin by reading the README file to understand the project structure, architecture, conventions, and any setup requirements\n   - Review relevant existing code to understand current patterns and implementation details\n   - Identify dependencies, related components, and potential impact areas\n   - Note any coding standards or conventions already established in the codebase\n\n2. **Planning Phase**:\n   - Break down the requested changes into logical, manageable steps\n   - Consider edge cases, error handling, and potential failure modes\n   - Plan for backwards compatibility and migration paths when needed\n   - Identify which files need to be created, modified, or deleted\n   - Think through the testing strategy and validation approach\n\n3. **Implementation Phase**:\n   - Write clean, maintainable code following established project patterns\n   - NEVER use `any` types - always provide proper type definitions\n   - Include comprehensive error handling and input validation\n   - Add clear, concise comments for complex logic\n   - Follow DRY (Don't Repeat Yourself) and SOLID principles\n   - Ensure consistent code formatting with the existing codebase\n\n4. **Quality Assurance**:\n   - Review your implementation for potential bugs or oversights\n   - Verify that all edge cases are handled appropriately\n   - Ensure the changes integrate smoothly with existing functionality\n   - Consider performance implications of your implementation\n\nBest Practices:\n- Prefer composition over inheritance\n- Write self-documenting code with meaningful variable and function names\n- Keep functions focused on a single responsibility\n- Anticipate future extensibility in your designs\n- Use appropriate design patterns where they add value\n- Consider security implications, especially for user input and data handling\n\nCommunication:\n- Before implementing, briefly explain your planned approach\n- Highlight any assumptions you're making\n- Flag potential concerns or alternative approaches for complex changes\n- Provide clear explanations of what you've implemented and why\n- Proactively ask for clarification if requirements are ambiguous\n\nWhen you encounter unclear requirements, missing information, or design decisions that need input, pause and ask the user for guidance rather than making assumptions. Your expertise is in delivering robust, well-architected solutions that align with the user's vision and the project's existing standards.\n\n# UI Testing\n\nThere is a browser testing sub-agent available. Call on them to help you test functionality in the browser. Be clear about what functionality you want them to test, the current level of completeness, and what they should expect to see. Also share whether the dev server is already running or whether they should run it.\n",
        "plugins/dev/skills/commit-and-push/SKILL.md": "---\nname: commit-and-push\nallowed-tools: Bash(git add:*), Bash(git commit:*), Bash(git push:*)\ndescription: Commit and push changes\ndisable-model-invocation: true\n---\n\n## Git State\n\nStatus:\n!`git status`\n\nChanges:\n!`git diff`\n\nRecent commits:\n!`git log --oneline -5`\n\n## Task\n\nReview the conversation context above to understand what the user was working on. Then:\n\n1. **Identify related changes**: From the diff, determine which files are related to the work discussed in the conversation. Unrelated changes (e.g., unfinished work on a different feature) should NOT be staged.\n\n2. **Stage selectively**: Only `git add` files that are related to the conversation context. If all changes appear related, stage everything.\n\n3. **Generate commit message**: Write a clear commit message describing what was accomplished.\n\n4. **Commit and push**: Commit the staged changes and push to the remote branch.\n\nIf you're unsure whether certain files are related, ask the user before staging.\n",
        "plugins/dev/skills/create-pr/SKILL.md": "---\nname: create-pr\ndescription: Creates a GitHub PR for current work. Handles branch creation, committing, pushing, and PR creation.\nargument-hint: \"[optional: PR description]\"\ndisable-model-invocation: true\nallowed-tools: Bash(git:*), Bash(gh pr create:*)\n---\n\n# Create Pull Request\n\nCreates a complete PR from current work: branch, commit, push, and open the PR.\n\n## Git State\n\nStatus:\n!`git status`\n\nChanges:\n!`git diff`\n\nCurrent branch:\n!`git branch --show-current`\n\nRecent commits:\n!`git log --oneline -5`\n\n## Workflow\n\n### Step 1: Check Branch State\n\nDetermine the current branch:\n- If on `main` or `master`, create a new feature branch\n- If already on a feature branch, continue on that branch\n\n**Branch naming:** Generate from conversation context using format `{category}/{short-description}`:\n- `feat/add-user-auth`\n- `fix/login-validation`\n- `refactor/extract-utils`\n\n### Step 2: Identify Changes to Include\n\nReview the conversation context and git diff:\n- If an argument was provided, use it to determine which changes are in scope\n- If no argument, infer scope from the conversation context\n- Only stage files related to the intended PR scope\n- Unrelated changes should NOT be staged\n\nIf uncertain about which files belong, ask the user.\n\n### Step 3: Stage and Commit\n\n1. Stage only the relevant files with `git add`\n2. Write a clear, concise commit message\n3. Commit the changes\n\n### Step 4: Push to Remote\n\nPush the branch to origin:\n```\ngit push -u origin <branch-name>\n```\n\n### Step 5: Create the PR\n\nCreate the PR using `gh pr create`:\n- Title: Clear, imperative summary\n- Body: Plain text, 1-2 paragraphs describing what and why\n- No headers, no \"Test Plan\" section, no markdown formatting in the body\n- If argument was provided, use it to inform the description\n\n```\ngh pr create --title \"...\" --body \"...\"\n```\n\n## Guidelines\n\n- Keep PR descriptions as plain prose (1-2 paragraphs)\n- No headers or sections in the PR body\n- Focus on what changed and why, not how\n- If multiple unrelated changes exist, only include those relevant to the conversation or argument\n- Always push before creating the PR\n",
        "plugins/meta/.claude-plugin/plugin.json": "{\n  \"name\": \"meta\",\n  \"description\": \"Plugin authoring tools: skill and agent creation guides and templates\"\n}\n",
        "plugins/meta/skills/creating-agents/SKILL.md": "---\nname: creating-agents\ndescription: Creates new Claude Code agents (subagents) with best practices. Use when the user wants to create an agent, add a custom subagent, or define a specialized AI assistant for their project.\nargument-hint: \"[agent-name] [optional: description]\"\ndisable-model-invocation: true\n---\n\n# Create Agent\n\nGuide the user through creating a highly effective Claude Code agent.\n\n**Important:** Use \"ultrathink\" extended thinking for agent design decisions.\n\n## Workflow\n\n### Phase 1: Discovery\n\nAsk the user clarifying questions to understand the agent requirements:\n\n1. **Purpose:** What specialized role should this agent fill? (e.g., code reviewer, test runner, documentation writer)\n2. **Scope:** Should it be project-specific (`.claude/agents/`) or personal (`~/.claude/agents/`)?\n3. **Delegation:** Should Claude delegate to it proactively, or only when the user explicitly requests it?\n4. **Tools:** What tools does this agent need? (Read, Write, Edit, Bash, Glob, Grep, WebSearch, WebFetch, etc.)\n5. **Model:** What model should it use? (`opus` for complex reasoning, `sonnet` for balanced tasks, `haiku` for fast/simple tasks, or `inherit` for the parent model)\n\nIf the available context makes any of this information obvious, there's no need to ask redundantly. However, clarify any ambiguity rather than making assumptions.\nIf the user provided arguments, use them to inform the agent name and purpose.\n\n### Phase 2: Design\n\nDetermine the agent's role, delegation behavior, and tooling:\n\n**Agent vs. Skill:**\n- **Agents** run as isolated subprocesses with their own context window, tool access, and model. They receive a task, work autonomously, and return a summary. Use agents for complex, multi-step work that benefits from isolation.\n- **Skills** inject instructions into the current conversation's context. Use skills for workflows, conventions, or templates that should run inline.\n\nChoose an agent when:\n- The task produces verbose intermediate output that would clutter the main conversation\n- The work is self-contained and can be summarized on completion\n- You need to enforce specific tool restrictions or a different model\n- The task benefits from a focused system prompt without main conversation noise\n- You want parallel execution of independent work streams\n\n**Naming:**\n- Lowercase with hyphens\n- Be specific and role-oriented: `code-reviewer` not `reviewer`\n- Always include a `name` field in frontmatter\n\n**Frontmatter Options:**\n```yaml\n---\nname: agent-name\ndescription: \"Detailed description of when to delegate to this agent. Include examples.\"\nmodel: sonnet\ncolor: blue\ntools: Read, Glob, Grep, Bash\ndisallowedTools: Write, Edit\npermissionMode: default\n---\n```\n\n**Description Guidelines:**\n- Write as an instruction to the parent model explaining WHEN to delegate\n- Start with \"Use this agent when...\" for clarity\n- Include concrete examples showing user messages and expected delegation behavior\n- Use the `<example>`, `<commentary>` format for delegation examples:\n\n```yaml\ndescription: \"Use this agent when the user asks for code review or quality checks.\\n\\n<example>\\nuser: 'Review the changes in the auth module'\\nassistant: 'I'll use the code-reviewer agent to review the auth module changes'\\n<commentary>Code review is a focused task well-suited for an isolated agent.</commentary>\\n</example>\"\n```\n\n### Phase 3: Configuration\n\nSelect the right configuration for the agent:\n\n**Model Selection:**\n| Model | Best For |\n|-------|----------|\n| `opus` | Complex reasoning, architecture decisions, nuanced code review |\n| `sonnet` | Balanced tasks, implementation work, testing |\n| `haiku` | Fast lookups, simple searches, quick categorization |\n| `inherit` | Use whatever the parent conversation uses |\n\n**Permission Modes:**\n| Mode | Behavior | Use When |\n|------|----------|----------|\n| `default` | Prompts user for permissions | Agent makes file changes or runs commands |\n| `acceptEdits` | Auto-accepts file edits | Trusted agent that modifies code |\n| `dontAsk` | Auto-denies permission prompts | Read-only research agent |\n| `bypassPermissions` | Skips all checks | Fully trusted automation (use sparingly) |\n| `plan` | Read-only exploration | Agent only gathers information |\n\n**Tool Selection:**\nGrant the minimum set of tools needed. Common combinations:\n\n- **Read-only research:** `Read, Glob, Grep`\n- **Code analysis:** `Read, Glob, Grep, Bash`\n- **Code modification:** `Read, Write, Edit, Glob, Grep, Bash`\n- **Web research:** `Read, Glob, Grep, WebSearch, WebFetch`\n- **Full access:** omit `tools` field (inherits all parent tools)\n\n**Color Options:**\nAvailable colors for visual distinction in the UI: `red`, `green`, `blue`, `yellow`, `cyan`, `magenta`, `white`.\n\n### Phase 4: System Prompt Structure\n\nDesign the agent's system prompt (the markdown body after the frontmatter):\n\n**Structure Template:**\n```markdown\nYou are a {role} with expertise in {domain}. Your role is to {primary responsibility}.\n\nYour Process:\n\n1. **Phase Name**:\n   - Key action 1\n   - Key action 2\n\n2. **Phase Name**:\n   - Key action 1\n   - Key action 2\n\nGuidelines:\n- Principle 1\n- Principle 2\n\nCommunication:\n- How to report results\n- What format to use\n```\n\n**System Prompt Principles:**\n\n1. **Define the persona clearly.** The opening sentence sets the agent's identity and expertise. Be specific about what they excel at.\n\n2. **Structure the process.** Break the agent's workflow into numbered phases. Agents work autonomously, so the process should be self-contained.\n\n3. **Set boundaries.** Specify what the agent should and should not do. Agents cannot ask the user follow-up questions mid-task (unless granted `AskUserQuestion`), so anticipate edge cases.\n\n4. **Define the output format.** Since the agent returns a summary to the parent conversation, specify how results should be structured (e.g., bullet points, severity levels, pass/fail).\n\n5. **Keep it focused.** Each agent should excel at one thing. A 30-80 line system prompt is typical. Avoid general-purpose instructions Claude already knows.\n\n**What to Include:**\n- Domain-specific knowledge the agent needs\n- Process steps in execution order\n- Output format and reporting structure\n- Interaction patterns with other agents (if applicable)\n- Project-specific conventions that affect the agent's work\n\n**What to Exclude:**\n- General coding knowledge Claude already has\n- Vague instructions (\"be helpful\", \"write good code\")\n- Overly detailed instructions for simple tasks\n- Information that changes frequently\n\n### Phase 5: Implementation\n\nCreate the agent file:\n\n1. Determine the full path:\n   - Personal: `~/.claude/agents/{agent-name}.md`\n   - Project: `./{project-root}/.claude/agents/{agent-name}.md`\n   - Plugin: `./agents/{agent-name}.md` (within a plugin directory)\n\n2. Create the directory if needed\n\n3. Write the agent markdown file with:\n   - YAML frontmatter (name, description, model, tools, etc.)\n   - System prompt body following the structure template\n\n### Phase 6: Verification\n\nAfter creating the agent:\n\n1. **Registration Check:** The agent should appear in Claude Code's agent list\n2. **Delegation Test:** Describe a task matching the agent's description and verify Claude delegates to it\n3. **Execution Test:** Run the agent on a real task and review the output quality\n4. **Tool Access Test:** Confirm the agent can use its granted tools and cannot use restricted ones\n\nIf issues arise:\n- Check frontmatter YAML syntax (quoting, indentation)\n- Verify the file is in a recognized agents directory\n- Ensure the description clearly indicates delegation triggers\n- Check that listed tools are valid tool names\n\n## Quick Reference\n\n### Frontmatter Template\n```yaml\n---\nname: {agent-name}\ndescription: \"Use this agent when {delegation trigger}.\\n\\n<example>\\nuser: '{sample request}'\\nassistant: '{expected delegation response}'\\n<commentary>{why this agent is appropriate}</commentary>\\n</example>\"\nmodel: {opus|sonnet|haiku|inherit}\ncolor: {color}\ntools: {Tool1, Tool2, Tool3}\npermissionMode: {default|acceptEdits|dontAsk|bypassPermissions|plan}\n---\n```\n\n### Common Agent Patterns\n\n**Research/Analysis Agent (read-only):**\n```yaml\nmodel: haiku\ntools: Read, Glob, Grep\npermissionMode: plan\n```\n\n**Code Modification Agent (trusted):**\n```yaml\nmodel: opus\ntools: Read, Write, Edit, Glob, Grep, Bash\npermissionMode: acceptEdits\n```\n\n**Testing Agent (needs browser/commands):**\n```yaml\nmodel: sonnet\ntools: Read, Glob, Grep, Bash\npermissionMode: default\n```\n\n**Documentation Agent:**\n```yaml\nmodel: sonnet\ntools: Read, Write, Glob, Grep\npermissionMode: acceptEdits\n```\n\n### Checklist\n\nBefore finalizing an agent, verify:\n\n- [ ] Frontmatter includes explicit `name` field\n- [ ] Name uses lowercase with hyphens\n- [ ] Description explains WHEN to delegate with examples\n- [ ] Model is appropriate for task complexity\n- [ ] Tools are minimal but sufficient\n- [ ] Permission mode matches trust level\n- [ ] System prompt defines a clear persona and process\n- [ ] Output format is specified\n- [ ] Prompt is focused (30-80 lines typical, under 150 max)\n- [ ] No redundant information Claude already knows\n\n## Examples\n\n### Example: Focused Analysis Agent\n\n```markdown\n---\nname: code-reviewer\ndescription: \"Use this agent when the user asks for code review, quality checks, or wants feedback on recent changes.\\n\\n<example>\\nuser: 'Review my recent changes'\\nassistant: 'I'll use the code-reviewer agent to analyze your changes'\\n<commentary>Code review is a focused analytical task suited for an isolated agent.</commentary>\\n</example>\"\nmodel: sonnet\ncolor: yellow\ntools: Read, Glob, Grep, Bash\n---\n\nYou are a senior code reviewer focused on correctness, security, and maintainability.\n\nYour Process:\n\n1. **Gather Context**:\n   - Run `git diff` to see recent changes\n   - Read modified files in full for surrounding context\n   - Check related tests and documentation\n\n2. **Review**:\n   - Correctness: Does the code do what it claims?\n   - Security: Any vulnerabilities introduced?\n   - Style: Does it follow project conventions?\n   - Tests: Are changes adequately tested?\n\n3. **Report**:\n   Organize findings by severity:\n   - **Critical:** Must fix before merge (bugs, security issues)\n   - **Warning:** Should fix (code smells, missing tests)\n   - **Suggestion:** Consider improving (style, naming, optimization)\n\n   For each finding, include the file path, line reference, and a concrete fix suggestion.\n\nGuidelines:\n- Be constructive and specific\n- Acknowledge what is done well\n- Prioritize blocking issues over style nits\n- If no issues found, confirm the code looks good\n```\n\n### Example: Task Execution Agent\n\n```markdown\n---\nname: test-runner\ndescription: \"Use this agent when the user wants to run tests, check test coverage, or verify that changes pass the test suite.\\n\\n<example>\\nuser: 'Run the tests for the auth module'\\nassistant: 'I'll use the test-runner agent to run and report on the auth module tests'\\n<commentary>Running tests produces verbose output best isolated in a subagent.</commentary>\\n</example>\"\nmodel: haiku\ncolor: green\ntools: Read, Glob, Bash\n---\n\nYou are a test execution specialist. Run tests and provide clear, actionable results.\n\nYour Process:\n\n1. **Identify Tests:**\n   - Locate the project's test runner configuration\n   - Find tests matching the requested scope\n   - Check for test dependencies or setup scripts\n\n2. **Execute:**\n   - Run the appropriate test command\n   - Capture all output including failures and warnings\n\n3. **Report:**\n   - Total tests: passed / failed / skipped\n   - For each failure: test name, assertion message, file:line reference\n   - If all tests pass, confirm with a brief summary\n\nKeep the report concise. Developers need to know what failed and where, not see the full test log.\n```\n",
        "plugins/meta/skills/creating-skills/SKILL.md": "---\nname: creating-skills\ndescription: Creates new Claude Code skills with best practices. Use when the user wants to create a skill, add a slash command, or automate a workflow.\nargument-hint: \"[skill-name] [optional: description]\"\ndisable-model-invocation: true\n---\n\n# Create Skill\n\nGuide the user through creating a highly effective Claude Code skill.\n\n**Important:** Use \"ultrathink\" extended thinking for skill design decisions.\n\n## Workflow\n\n### Phase 1: Discovery\n\nAsk the user clarifying questions to understand the skill requirements:\n\n1. **Purpose:** What task or workflow should this skill handle?\n2. **Scope:** Should it be project-specific (`./skills/`) or personal (`~/.claude/skills/`)?\n3. **Invocation:** Should Claude invoke it automatically, or only when the user explicitly calls it?\n4. **Output:** What output format or artifacts are expected?\n5. **Frequency:** How often will this skill be used?\n\nIf the available context makes any of this information obvious, there's no need to ask redundantly. However, clarify any ambiguity rather than making assumptions.\nIf the user provided arguments, use them to inform the skill name and purpose.\n\n### Phase 2: Design\n\nDetermine the skill type and structure:\n\n**Skill Types:**\n- **Reference content:** Conventions, patterns, domain knowledge (Claude references as needed)\n- **Task content:** Step-by-step workflow with clear phases (Claude follows the steps)\n- **Hybrid:** Combines reference material with workflow guidance\n\n**Naming:**\n- Lowercase with hyphens\n- Be specific: `formatting-sql` not `sql-stuff`\n- Always include a `name` field in frontmatter -- without it, the skill name is derived from the directory and may be inconsistently prefixed by the plugin name\n\n**Frontmatter Options:**\n```yaml\n---\nname: skill-name\ndescription: Does X when Y. Use for Z.\nargument-hint: \"[required-arg] [optional: arg]\"\ndisable-model-invocation: true  # Set true if user should control invocation\n---\n```\n\n**Description Guidelines:**\n- Write in third person (\"Creates...\" not \"Create...\")\n- Include WHAT the skill does AND WHEN to use it\n- Use specific trigger words users might say\n- Never use vague descriptions like \"helps with documents\"\n\nGood: `Generates mermaid diagrams from technical descriptions. Use when the user wants to visualize architecture, data flows, or processes.`\n\nBad: `Helps with diagrams.`\n\n### Phase 3: Structure\n\nDesign the skill content structure:\n\n**For Reference Skills (~100-300 lines):**\n```markdown\n# Skill Name\n\nBrief overview.\n\n## Conventions\n- Key convention 1\n- Key convention 2\n\n## Patterns\n### Pattern Name\nDescription and example.\n\n## Examples\nConcrete examples of correct usage.\n```\n\n**For Task Skills (~150-400 lines):**\n```markdown\n# Skill Name\n\nBrief overview of what this accomplishes.\n\n## Workflow\n\n### Step 1: Gather Context\nWhat to collect and understand first.\n\n### Step 2: Execute\nThe main actions to perform.\n\n### Step 3: Verify\nHow to confirm success.\n\n## Guidelines\nKey principles to follow throughout.\n\n## Examples\nSample inputs and outputs.\n```\n\n**For Complex Skills (use supporting files):**\n```\nskills/\n  skill-name/\n    SKILL.md           # Main file, under 500 lines\n    conventions.md     # Reference material\n    templates/         # Template files\n      template-a.md\n```\n\nReference supporting files with relative paths: `See [conventions](./conventions.md)`\n\n### Phase 4: Content Principles\n\nApply these principles when writing skill content:\n\n**Conciseness is Critical:**\n- The skill shares context window with the conversation\n- Every line should earn its place\n- Remove anything Claude already knows\n\n**Degrees of Freedom:**\n- **High freedom:** Guidelines and principles, Claude decides specifics\n- **Medium freedom:** Clear steps with room for judgment\n- **Low freedom:** Exact templates and formats, minimal deviation\n\nMatch freedom level to the task. Code formatting needs low freedom; creative tasks need high freedom.\n\n**What to Include:**\n- Project-specific conventions Claude cannot infer\n- Workflow steps in the order they should happen\n- Examples of correct output\n- Common pitfalls and how to avoid them\n\n**What to Exclude:**\n- General knowledge Claude already has\n- Obvious instructions (\"write clean code\")\n- Time-sensitive information that will become stale\n- Lengthy explanations when examples suffice\n\n**Formatting:**\n- Use consistent terminology throughout\n- Number workflow steps\n- Use code blocks for templates and examples\n- Keep reference sections scannable with headers\n\n### Phase 5: Implementation\n\nCreate the skill files:\n\n1. Determine the full path:\n   - Personal: `~/.claude/skills/{skill-name}/SKILL.md`\n   - Project: `./{project-root}/skills/{skill-name}/SKILL.md`\n\n2. Create the directory structure\n\n3. Write SKILL.md with:\n   - Frontmatter (name, description, argument-hint if needed, disable-model-invocation if needed)\n   - Body content following the appropriate structure\n\n4. Create supporting files if the skill is complex\n\n### Phase 6: Verification\n\nAfter creating the skill:\n\n1. **Autocomplete Check:** Type `/` and verify the skill appears in the list\n2. **Invocation Test:** Run the skill with a sample task\n3. **Output Review:** Confirm the skill produces expected results\n4. **Edge Cases:** Test with minimal input and unusual requests\n\nIf issues arise:\n- Check frontmatter syntax (YAML is sensitive to formatting)\n- Verify file is named exactly `SKILL.md`\n- Ensure description clearly indicates when to use the skill\n\n## Quick Reference\n\n### Frontmatter Template\n```yaml\n---\nname: {skill-name}\ndescription: {What it does}. Use when {trigger conditions}.\nargument-hint: \"[args]\"\ndisable-model-invocation: {true if user-controlled}\n---\n```\n\n### Common Patterns\n\n**Skill that processes input:**\n```markdown\n## Workflow\n1. Parse the provided {input-type}\n2. Apply {transformation}\n3. Output {result-format}\n```\n\n**Skill that creates artifacts:**\n```markdown\n## Workflow\n1. Gather requirements from user\n2. Design {artifact-type} structure\n3. Create the files\n4. Verify correctness\n```\n\n**Skill that enforces conventions:**\n```markdown\n## Conventions\n- {Convention with rationale}\n\n## Examples\n### Correct\n{example}\n\n### Incorrect\n{counter-example}\n```\n\n### Checklist\n\nBefore finalizing a skill, verify:\n\n- [ ] Frontmatter includes explicit `name` field\n- [ ] Name uses lowercase with hyphens\n- [ ] Description says WHAT and WHEN\n- [ ] Content is under 500 lines (or uses supporting files)\n- [ ] Workflow steps are numbered and clear\n- [ ] Examples demonstrate expected output\n- [ ] No redundant information Claude already knows\n- [ ] Consistent terminology throughout\n- [ ] Appropriate degree of freedom for the task\n\n## Examples\n\n### Example: Simple Reference Skill\n\n```markdown\n---\nname: formatting-sql\ndescription: Formats SQL queries according to project conventions. Use when writing or reviewing SQL.\n---\n\n# SQL Formatting\n\n## Conventions\n- Keywords in UPPERCASE\n- Table names in snake_case\n- Indent nested clauses by 2 spaces\n- One column per line in SELECT\n\n## Example\n\n```sql\nSELECT\n  user_id,\n  created_at,\n  email\nFROM\n  users\nWHERE\n  status = 'active'\nORDER BY\n  created_at DESC\n```\n```\n\n### Example: Task Skill with Workflow\n\n```markdown\n---\nname: reviewing-pull-requests\ndescription: Reviews pull requests for code quality and correctness. Use when the user asks to review a PR or check code changes.\nargument-hint: \"[pr-number or branch]\"\n---\n\n# Pull Request Review\n\n## Workflow\n\n### Step 1: Gather Context\n- Fetch the PR diff\n- Read related files for context\n- Check for linked issues\n\n### Step 2: Review\nExamine changes for:\n- Correctness: Does the code do what it claims?\n- Style: Does it follow project conventions?\n- Tests: Are changes adequately tested?\n- Security: Any vulnerabilities introduced?\n\n### Step 3: Provide Feedback\n- List issues by severity (blocking, suggestion, nit)\n- Include specific line references\n- Suggest concrete fixes\n\n## Guidelines\n- Be constructive, not critical\n- Acknowledge what's done well\n- Prioritize blocking issues\n```\n"
      },
      "plugins": [
        {
          "name": "dev",
          "description": "Development workflow: lead developer agent, browser testing, PR creation, and commit management",
          "source": "./plugins/dev",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add computomatic/claude-plugin",
            "/plugin install dev@computomatic"
          ]
        },
        {
          "name": "meta",
          "description": "Plugin authoring tools: skill and agent creation guides and templates",
          "source": "./plugins/meta",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add computomatic/claude-plugin",
            "/plugin install meta@computomatic"
          ]
        }
      ]
    }
  ]
}