{
  "author": {
    "id": "king8fisher",
    "display_name": "king8fisher",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/140904760?v=4",
    "url": "https://github.com/king8fisher",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "king8fisher-plugins",
      "version": null,
      "description": "Claude Code plugins collection",
      "owner_info": {
        "name": "king8fisher"
      },
      "keywords": [],
      "repo_full_name": "king8fisher/claude-code-marketplace",
      "repo_url": "https://github.com/king8fisher/claude-code-marketplace",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-12T15:51:56Z",
        "created_at": "2025-12-29T20:02:13Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 399
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 292
        },
        {
          "path": "plugins/ralph-wiggum/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/commands/cancel-ralph.md",
          "type": "blob",
          "size": 447
        },
        {
          "path": "plugins/ralph-wiggum/commands/help.md",
          "type": "blob",
          "size": 1443
        },
        {
          "path": "plugins/ralph-wiggum/commands/ralph-loop.md",
          "type": "blob",
          "size": 888
        },
        {
          "path": "plugins/ralph-wiggum/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/ralph-wiggum/hooks/hooks.json",
          "type": "blob",
          "size": 283
        },
        {
          "path": "plugins/ralph-wiggum/hooks/stop-hook.sh",
          "type": "blob",
          "size": 9113
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"king8fisher-plugins\",\n  \"owner\": {\n    \"name\": \"king8fisher\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugins collection\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"ralph-wiggum\",\n      \"source\": \"./plugins/ralph-wiggum\",\n      \"description\": \"Self-referential AI loop - Claude iterates on tasks until completion\",\n      \"tags\": [\"loop\", \"iteration\", \"automation\"]\n    }\n  ]\n}",
        "plugins/ralph-wiggum/.claude-plugin/plugin.json": "{\n  \"name\": \"ralph-wiggum\",\n  \"version\": \"1.2.2\",\n  \"description\": \"Self-referential AI loop - Claude iterates on tasks until completion or max iterations\",\n  \"author\": {\n    \"name\": \"king8fisher\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\"loop\", \"iteration\", \"automation\", \"self-correction\"]\n}",
        "plugins/ralph-wiggum/commands/cancel-ralph.md": "---\ndescription: \"Cancel active Ralph Wiggum loop\"\nallowed-tools: Bash\nhide-from-slash-command-tool: true\n---\n\n# Cancel Ralph Loop\n\nRemove the Ralph loop state file for this session:\n\n!`CLAUDE_PID=$(ps -o ppid= -p $PPID 2>/dev/null | tr -d ' '); rm -f \".claude/ralph-loop.${CLAUDE_PID}.local.md\" \".claude/ralph-loop-history.${CLAUDE_PID}.tmp\" 2>/dev/null; echo \"Ralph loop cancelled\"`\n\nThe Ralph loop has been cancelled. You can now exit normally.",
        "plugins/ralph-wiggum/commands/help.md": "---\ndescription: \"Explain Ralph Wiggum technique and available commands\"\nallowed-tools: []\nhide-from-slash-command-tool: true\n---\n\n# Ralph Wiggum Plugin Help\n\n## What is the Ralph Wiggum Technique?\n\nThe Ralph Wiggum technique is a self-referential AI development pattern where Claude runs in a loop, receiving the same prompt repeatedly until task completion. Each iteration builds on previous work visible in files and git history.\n\n## Available Commands\n\n### /ralph-loop\nStart an in-session loop with stop hook integration.\n\n```\n/ralph-loop PROMPT [--max-iterations N] [--completion-promise TEXT]\n```\n\n**Examples:**\n- `/ralph-loop Build a REST API --completion-promise 'DONE'`\n- `/ralph-loop Fix bugs --max-iterations 10`\n\n### /cancel-ralph\nCancel the current Ralph loop immediately.\n\n## How It Works\n\n1. You provide a prompt describing the task\n2. Claude works on the task\n3. When Claude tries to exit, the stop hook:\n   - Checks for completion (max iterations or promise text)\n   - If not complete, feeds the SAME prompt back\n   - Claude sees previous work in files\n4. Loop continues until completion criteria met\n\n## Completion Criteria\n\n- **Max iterations**: Loop stops after N iterations\n- **Completion promise**: Loop stops when Claude outputs `<promise>TEXT</promise>`\n\n## Tips\n\n- Use `--completion-promise` for defined end states\n- Use `--max-iterations` as a safety limit\n- Monitor progress: `head -10 .claude/ralph-loop.*.local.md`",
        "plugins/ralph-wiggum/commands/ralph-loop.md": "---\ndescription: \"Start Ralph Wiggum loop in current session\"\nargument-hint: \"PROMPT [-n N] [-p '<promise>']\"\nallowed-tools: Bash\nhide-from-slash-command-tool: true\n---\n\n# Ralph Loop Command\n\nExecute the setup script to initialize the Ralph loop. Run this Bash command:\n\n```bash\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" <<'RALPH_EOF'\n$ARGUMENTS\nRALPH_EOF\n```\n\nPlease work on the task. When you try to exit, the Ralph loop will feed the SAME PROMPT back to you for the next iteration. You'll see your previous work in files and git history, allowing you to iterate and improve.\n\nCRITICAL RULE: If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion.",
        "plugins/ralph-wiggum/hooks/hooks.json": "{\n  \"description\": \"Ralph Wiggum plugin stop hook for self-referential loops\",\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/stop-hook.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}",
        "plugins/ralph-wiggum/hooks/stop-hook.sh": "#!/bin/bash\n\n# Ralph Wiggum Stop Hook\n# Prevents session exit when a ralph-loop is active\n# Feeds Claude's output back as input to continue the loop\n\nset -euo pipefail\n\n# Read hook input from stdin (advanced stop hook API)\nHOOK_INPUT=$(cat)\n\n# Find state file for THIS session using Claude Code's PID (our direct parent)\n# Setup stores files as ralph-loop.{CLAUDE_PID}.local.md\nRALPH_STATE_FILE=\".claude/ralph-loop.${PPID}.local.md\"\n\nif [[ ! -f \"$RALPH_STATE_FILE\" ]]; then\n  # No active loop for this session - allow exit\n  # Clean up stale files from dead processes while we're here\n  for stale in .claude/ralph-loop.*.local.md .claude/ralph-loop-history.*.tmp; do\n    [[ -f \"$stale\" ]] || continue\n    # Extract PID from filename (handles both state and history files)\n    stale_pid=$(basename \"$stale\" | sed -E 's/ralph-loop(-history)?\\.([0-9]+)\\..*/\\2/')\n    if ! kill -0 \"$stale_pid\" 2>/dev/null; then\n      rm -f \"$stale\"\n    fi\n  done\n  exit 0\nfi\n\n# Parse markdown frontmatter (YAML between ---) and extract values\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$RALPH_STATE_FILE\")\nITERATION=$(echo \"$FRONTMATTER\" | grep '^iteration:' | sed 's/iteration: *//')\nMAX_ITERATIONS=$(echo \"$FRONTMATTER\" | grep '^max_iterations:' | sed 's/max_iterations: *//')\n# Extract completion_promise and strip surrounding quotes if present\nCOMPLETION_PROMISE=$(echo \"$FRONTMATTER\" | grep '^completion_promise:' | sed 's/completion_promise: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n# Extract started_at timestamp (optional field)\nSTARTED_AT=$(echo \"$FRONTMATTER\" | grep '^started_at:' | sed 's/started_at: *//' | sed 's/^\"\\(.*\\)\"$/\\1/' || echo \"\")\n\n# Timeout warning (inspired by ralph-orchestrator safety guards)\n# Warn if loop has been running > 30 minutes\nif [[ -n \"$STARTED_AT\" ]]; then\n  START_EPOCH=$(date -j -f \"%Y-%m-%dT%H:%M:%SZ\" \"$STARTED_AT\" \"+%s\" 2>/dev/null || date -d \"$STARTED_AT\" \"+%s\" 2>/dev/null || echo \"\")\n  if [[ -n \"$START_EPOCH\" ]]; then\n    NOW_EPOCH=$(date \"+%s\")\n    ELAPSED_MINS=$(( (NOW_EPOCH - START_EPOCH) / 60 ))\n    if [[ $ELAPSED_MINS -gt 30 ]]; then\n      echo \"âš ï¸  Ralph loop: Running for ${ELAPSED_MINS} minutes (long running loop)\" >&2\n    fi\n  fi\nfi\n\n# Validate numeric fields before arithmetic operations\nif [[ ! \"$ITERATION\" =~ ^[0-9]+$ ]]; then\n  echo \"âš ï¸  Ralph loop: State file corrupted\" >&2\n  echo \"   File: $RALPH_STATE_FILE\" >&2\n  echo \"   Problem: 'iteration' field is not a valid number (got: '$ITERATION')\" >&2\n  echo \"\" >&2\n  echo \"   This usually means the state file was manually edited or corrupted.\" >&2\n  echo \"   Ralph loop is stopping. Run /ralph-loop again to start fresh.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\nif [[ ! \"$MAX_ITERATIONS\" =~ ^[0-9]+$ ]]; then\n  echo \"âš ï¸  Ralph loop: State file corrupted\" >&2\n  echo \"   File: $RALPH_STATE_FILE\" >&2\n  echo \"   Problem: 'max_iterations' field is not a valid number (got: '$MAX_ITERATIONS')\" >&2\n  echo \"\" >&2\n  echo \"   This usually means the state file was manually edited or corrupted.\" >&2\n  echo \"   Ralph loop is stopping. Run /ralph-loop again to start fresh.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Check if max iterations reached\nif [[ $MAX_ITERATIONS -gt 0 ]] && [[ $ITERATION -ge $MAX_ITERATIONS ]]; then\n  echo \"ðŸ›‘ Ralph loop: Max iterations ($MAX_ITERATIONS) reached.\"\n  rm -f \"$RALPH_STATE_FILE\" \".claude/ralph-loop-history.${PPID}.tmp\"\n  exit 0\nfi\n\n# Get transcript path from hook input\nTRANSCRIPT_PATH=$(echo \"$HOOK_INPUT\" | jq -r '.transcript_path')\n\nif [[ ! -f \"$TRANSCRIPT_PATH\" ]]; then\n  echo \"âš ï¸  Ralph loop: Transcript file not found\" >&2\n  echo \"   Expected: $TRANSCRIPT_PATH\" >&2\n  echo \"   This is unusual and may indicate a Claude Code internal issue.\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Read last assistant message from transcript (JSONL format - one JSON per line)\n# First check if there are any assistant messages\nif ! grep -q '\"role\":\"assistant\"' \"$TRANSCRIPT_PATH\"; then\n  echo \"âš ï¸  Ralph loop: No assistant messages found in transcript\" >&2\n  echo \"   Transcript: $TRANSCRIPT_PATH\" >&2\n  echo \"   This is unusual and may indicate a transcript format issue\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Extract last assistant message with explicit error handling\nLAST_LINE=$(grep '\"role\":\"assistant\"' \"$TRANSCRIPT_PATH\" | tail -1)\nif [[ -z \"$LAST_LINE\" ]]; then\n  echo \"âš ï¸  Ralph loop: Failed to extract last assistant message\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Parse JSON with error handling\nLAST_OUTPUT=$(echo \"$LAST_LINE\" | jq -r '\n  .message.content |\n  map(select(.type == \"text\")) |\n  map(.text) |\n  join(\"\\n\")\n' 2>&1)\n\n# Check if jq succeeded\nif [[ $? -ne 0 ]]; then\n  echo \"âš ï¸  Ralph loop: Failed to parse assistant message JSON\" >&2\n  echo \"   Error: $LAST_OUTPUT\" >&2\n  echo \"   This may indicate a transcript format issue\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\nif [[ -z \"$LAST_OUTPUT\" ]]; then\n  echo \"âš ï¸  Ralph loop: Assistant message contained no text content\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Loop detection (inspired by ralph-orchestrator)\n# Detect if Claude is outputting nearly identical content repeatedly\nLOOP_HISTORY_FILE=\".claude/ralph-loop-history.${PPID}.tmp\"\nOUTPUT_HASH=$(echo \"$LAST_OUTPUT\" | head -c 2000 | md5sum 2>/dev/null | cut -d' ' -f1 || md5 -q 2>/dev/null <<< \"${LAST_OUTPUT:0:2000}\" || echo \"\")\nif [[ -n \"$OUTPUT_HASH\" ]] && [[ -f \"$LOOP_HISTORY_FILE\" ]]; then\n  # Check if this hash appeared in last 3 outputs\n  if grep -q \"^${OUTPUT_HASH}$\" \"$LOOP_HISTORY_FILE\" 2>/dev/null; then\n    REPEAT_COUNT=$(grep -c \"^${OUTPUT_HASH}$\" \"$LOOP_HISTORY_FILE\" 2>/dev/null || echo \"0\")\n    if [[ $REPEAT_COUNT -ge 2 ]]; then\n      echo \"ðŸ” Ralph loop: Detected repeated identical output ($((REPEAT_COUNT + 1)) times)\" >&2\n      echo \"   This may indicate the task is stuck or complete.\" >&2\n      echo \"   Stopping loop to prevent infinite repetition.\" >&2\n      rm -f \"$RALPH_STATE_FILE\" \"$LOOP_HISTORY_FILE\"\n      exit 0\n    fi\n  fi\nfi\n# Store output hash (keep last 5)\nif [[ -n \"$OUTPUT_HASH\" ]]; then\n  echo \"$OUTPUT_HASH\" >> \"$LOOP_HISTORY_FILE\"\n  tail -5 \"$LOOP_HISTORY_FILE\" > \"$LOOP_HISTORY_FILE.tmp\" 2>/dev/null && mv \"$LOOP_HISTORY_FILE.tmp\" \"$LOOP_HISTORY_FILE\"\nfi\n\n# Check for completion promise (only if set)\nif [[ \"$COMPLETION_PROMISE\" != \"null\" ]] && [[ -n \"$COMPLETION_PROMISE\" ]]; then\n  # Extract text from <promise> tags using Perl for multiline support\n  # -0777 slurps entire input, s flag makes . match newlines\n  # .*? is non-greedy (takes FIRST tag), whitespace normalized\n  PROMISE_TEXT=$(echo \"$LAST_OUTPUT\" | perl -0777 -pe 's/.*?<promise>(.*?)<\\/promise>.*/$1/s; s/^\\s+|\\s+$//g; s/\\s+/ /g' 2>/dev/null || echo \"\")\n\n  # Use = for literal string comparison (not pattern matching)\n  # == in [[ ]] does glob pattern matching which breaks with *, ?, [ characters\n  if [[ -n \"$PROMISE_TEXT\" ]] && [[ \"$PROMISE_TEXT\" = \"$COMPLETION_PROMISE\" ]]; then\n    echo \"âœ… Ralph loop: Detected <promise>$COMPLETION_PROMISE</promise>\"\n    rm -f \"$RALPH_STATE_FILE\" \"$LOOP_HISTORY_FILE\"\n    exit 0\n  fi\nfi\n\n# Not complete - continue loop with SAME PROMPT\nNEXT_ITERATION=$((ITERATION + 1))\n\n# Extract prompt (everything after the closing ---)\n# Skip first --- line, skip until second --- line, then print everything after\n# Use i>=2 instead of i==2 to handle --- in prompt content\nPROMPT_TEXT=$(awk '/^---$/{i++; next} i>=2' \"$RALPH_STATE_FILE\")\n\nif [[ -z \"$PROMPT_TEXT\" ]]; then\n  echo \"âš ï¸  Ralph loop: State file corrupted or incomplete\" >&2\n  echo \"   File: $RALPH_STATE_FILE\" >&2\n  echo \"   Problem: No prompt text found\" >&2\n  echo \"\" >&2\n  echo \"   This usually means:\" >&2\n  echo \"     â€¢ State file was manually edited\" >&2\n  echo \"     â€¢ File was corrupted during writing\" >&2\n  echo \"\" >&2\n  echo \"   Ralph loop is stopping. Run /ralph-loop again to start fresh.\" >&2\n  rm -f \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Update iteration in frontmatter (portable across macOS and Linux)\n# Create temp file, then atomically replace\nTEMP_FILE=\"${RALPH_STATE_FILE}.tmp.$$\"\nsed \"s/^iteration: .*/iteration: $NEXT_ITERATION/\" \"$RALPH_STATE_FILE\" > \"$TEMP_FILE\"\nmv \"$TEMP_FILE\" \"$RALPH_STATE_FILE\"\n\n# Build system message with iteration count and completion promise info\nif [[ \"$COMPLETION_PROMISE\" != \"null\" ]] && [[ -n \"$COMPLETION_PROMISE\" ]]; then\n  SYSTEM_MSG=\"ðŸ”„ Ralph iteration $NEXT_ITERATION | To stop: output <promise>$COMPLETION_PROMISE</promise> (ONLY when statement is TRUE - do not lie to exit!)\"\nelse\n  SYSTEM_MSG=\"ðŸ”„ Ralph iteration $NEXT_ITERATION | No completion promise set - loop runs infinitely\"\nfi\n\n# Output JSON to block the stop and feed prompt back\n# The \"reason\" field contains the prompt that will be sent back to Claude\njq -n \\\n  --arg prompt \"$PROMPT_TEXT\" \\\n  --arg msg \"$SYSTEM_MSG\" \\\n  '{\n    \"decision\": \"block\",\n    \"reason\": $prompt,\n    \"systemMessage\": $msg\n  }'\n\n# Exit 0 for successful hook execution\nexit 0\n"
      },
      "plugins": [
        {
          "name": "ralph-wiggum",
          "source": "./plugins/ralph-wiggum",
          "description": "Self-referential AI loop - Claude iterates on tasks until completion",
          "tags": [
            "loop",
            "iteration",
            "automation"
          ],
          "categories": [
            "automation",
            "iteration",
            "loop"
          ],
          "install_commands": [
            "/plugin marketplace add king8fisher/claude-code-marketplace",
            "/plugin install ralph-wiggum@king8fisher-plugins"
          ]
        }
      ]
    }
  ]
}