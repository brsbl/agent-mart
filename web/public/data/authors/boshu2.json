{
  "author": {
    "id": "boshu2",
    "display_name": "Bo",
    "avatar_url": "https://avatars.githubusercontent.com/u/241868352?u=2884b19153971636ad05a0dd021b2826db79b16a&v=4"
  },
  "marketplaces": [
    {
      "name": "agentops-marketplace",
      "version": null,
      "description": "The missing DevOps layer for coding agents. Give it a goal, it ships validated code and gets smarter.",
      "repo_full_name": "boshu2/agentops",
      "repo_url": "https://github.com/boshu2/agentops",
      "repo_description": "The missing DevOps layer for coding agents. Give it a goal, it ships validated code and gets smarter.",
      "signals": {
        "stars": 86,
        "forks": 7,
        "pushed_at": "2026-02-17T05:30:54Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"agentops-marketplace\",\n  \"owner\": {\n    \"name\": \"Boden Fuller\",\n    \"email\": \"fullerbt@users.noreply.github.com\"\n  },\n  \"metadata\": {\n    \"description\": \"The missing DevOps layer for coding agents. Give it a goal, it ships validated code and gets smarter.\",\n    \"version\": \"2.9.3\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agentops\",\n      \"description\": \"The missing DevOps layer for coding agents. Give it a goal, it ships validated code and gets smarter.\",\n      \"version\": \"2.9.3\",\n      \"source\": \"./\",\n      \"author\": {\n        \"name\": \"Boden Fuller\",\n        \"email\": \"fullerbt@users.noreply.github.com\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"$schema\": \"../schemas/plugin-manifest.v1.schema.json\",\n  \"name\": \"agentops\",\n  \"version\": \"2.9.3\",\n  \"description\": \"The missing DevOps layer for coding agents. Give it a goal, it ships validated code and gets smarter.\",\n  \"author\": {\n    \"name\": \"Boden Fuller\",\n    \"email\": \"fullerbt@users.noreply.github.com\"\n  },\n  \"homepage\": \"https://github.com/boshu2/agentops\",\n  \"repository\": \"https://github.com/boshu2/agentops\",\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\n    \"devops\",\n    \"vibe-coding\",\n    \"shift-left\",\n    \"validation\",\n    \"coding-agents\",\n    \"knowledge-flywheel\",\n    \"pre-mortem\",\n    \"vibe-check\",\n    \"workflow\",\n    \"skills\",\n    \"ao-cli\"\n  ]\n}\n",
        "README.md": "<div align=\"center\">\n\n<img src=\"docs/assets/hero.jpg\" alt=\"Context engineering — crafting what enters the window\" width=\"700\">\n\n# AgentOps\n\n### DevOps for coding agents. Give it a goal, it ships validated code — and remembers what worked.\n\n*Context orchestration for every phase — research, planning, validation, execution.*\n\n[![GitHub stars](https://img.shields.io/github/stars/boshu2/agentops?style=social)](https://github.com/boshu2/agentops)\n[![Version](https://img.shields.io/badge/version-2.9.3-brightgreen)](CHANGELOG.md)\n[![Skills](https://img.shields.io/badge/skills-37-7c3aed)](skills/)\n[![License: Apache-2.0](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n[![Claude Code](https://img.shields.io/badge/Claude_Code-Plugin-blueviolet)](https://github.com/anthropics/claude-code)\n\n[See It Work](#see-it-work) · [Install](#install) · [The Workflow](#the-workflow) · [The Flywheel](#the-flywheel) · [Skills](#skills) · [CLI](#the-ao-cli) · [FAQ](#faq)\n\n</div>\n\n---\n\n**The context window determines quality.** When your agent does everything in one conversation, the window fills up with stuff it doesn't need by the time it's actually writing code. That's why results are inconsistent.\n\nI come from DevOps, so I started treating my agent like a pipeline — isolated stages, validated gates, fresh context at each phase. Then I built a knowledge flywheel on top so each session compounds on the last.\n\nA spec-first pipeline forgets everything when the session ends. A fast iteration loop does too. AgentOps is composable primitives that remember what they learned.\n\nWhat makes this different from \"write spec → implement → check against spec → done\":\n\n1. **It remembers across sessions.** The system extracts what worked, what failed, and what patterns emerged — then injects that knowledge into the next session. Session 10 is smarter than session 1 because it learned from 1–9.\n2. **It self-corrects.** Validation happens *before* coding (pre-mortem simulates failures on the plan) and *after* (multi-model council reviews the code). Failures retry automatically with context. No human escalation unless it fails 3 times.\n3. **Every skill works standalone.** Use one skill or all of them. Wire them together when you're ready. `/rpi \"goal\"` runs the full lifecycle, but you don't have to start there.\n\n[Detailed comparisons →](docs/comparisons/) · Works with **Claude Code**, **Codex CLI**, **Cursor**, **Open Code** — any agent that supports [Skills](https://skills.sh).\n\n---\n\n## See It Work\n\n**Use one piece.** No pipeline required:\n```\n> /council validate this PR\n\n[council] 3 judges spawned\n[judge-1] PASS — JWT implementation correct\n[judge-2] WARN — rate limiting missing on /login\n[judge-3] PASS — refresh rotation implemented\nConsensus: WARN — add rate limiting before shipping\n```\n\n**It remembers.** Three weeks later, different session:\n```\n> ao search \"rate limiting\"\n\n1. .agents/learnings/2026-01-28-rate-limiting.md  (score: 0.92)\n   [established] Token bucket with Redis — chose over sliding window for burst tolerance\n2. .agents/patterns/api-middleware.md  (score: 0.84)\n   Pattern: rate limit at middleware layer, not per-handler\n```\nYour agent reads these automatically at session start. No copy-paste, no \"remember last time we...\"\n\n**Wire it all together** when you're ready:\n```\n> /rpi \"add retry backoff to rate limiter\"\n\n[research]    Found 2 prior learnings on rate limiting (injected)\n[plan]        2 issues, 1 wave → epic ag-0058\n[pre-mortem]  4 judges → PASS (knew about Redis choice from prior session)\n[crank]       Wave 1: ██ 2/2\n[vibe]        3 judges → PASS\n[post-mortem] 2 new learnings → .agents/\n[flywheel]    Next: /rpi \"add circuit breaker to external API calls\"\n```\n\nSession 2 was faster and better because session 1's learnings were already in context. That's the flywheel.\n\n<details>\n<summary>More examples</summary>\n\n**Parallel agents with fresh context:**\n```\n> /crank ag-0042\n\n[crank] Epic: ag-0042 — 6 issues, 3 waves\n[wave-1] ██████ 3/3 complete\n[wave-2] ████── 2/2 complete\n[wave-3] ██──── 1/1 complete\n[vibe] PASS — all gates locked\n[post-mortem] 4 learnings extracted\n```\n\n**Goal-driven improvement loop:**\n```\n> /evolve --max-cycles=5\n\n[evolve] GOALS.yaml: 4 goals loaded\n[cycle-1] Measuring fitness... 2/4 passing\n         Worst gap: test-pass-rate (weight: 10)\n         /rpi \"Improve test-pass-rate\" → 3 issues, 2 waves\n         Re-measure: 3/4 passing ✓\n[cycle-2] Worst gap: doc-coverage (weight: 7)\n         /rpi \"Improve doc-coverage\" → 2 issues, 1 wave\n         Re-measure: 4/4 passing ✓\n[cycle-3] All goals met. Checking harvested work...\n         Picked: \"add smoke test for /evolve\" (from post-mortem)\n[teardown] /post-mortem → 5 learnings extracted\n```\n\n**From vision to town** (big goal → many small pieces):\n```\n> /product                    # define mission, personas, value props\n> /research \"build auth system\"\n> /plan \"build auth system\"   # → 8 issues, 3 waves\n\n> /evolve --max-cycles=3\n[cycle-1] /rpi \"add user model + migrations\" → 2 issues, 1 wave ✓\n[cycle-2] /rpi \"add login/signup endpoints\" → 3 issues, 1 wave ✓\n[cycle-3] /rpi \"add JWT refresh + middleware\" → 3 issues, 2 waves ✓\n[teardown] 9 learnings extracted. All goals met.\n```\n\n</details>\n\n---\n\n## Install\n\n**Requires:** Node.js 18+ and a coding agent that supports [Skills](https://skills.sh) (Claude Code, Codex CLI, Cursor, Open Code).\n\n```bash\nnpx skills@latest add boshu2/agentops --all -g\n```\n\nThen open your coding agent and type `/quickstart`. That's it.\n\n<details>\n<summary>Full setup (CLI + hooks)</summary>\n\n```bash\nbrew tap boshu2/agentops https://github.com/boshu2/homebrew-agentops && brew install agentops\nao init              # Directories + .gitignore (idempotent)\nao init --hooks      # + flywheel hooks (SessionStart + Stop)\nao init --hooks --full  # + all 12 hooks across 8 lifecycle events\n```\n\nThe `ao` CLI adds automatic knowledge injection/extraction, ratchet gates, and session lifecycle. `ao init` is the canonical setup command — creates all `.agents/` directories, configures `.gitignore`, and optionally registers hooks. All 37 skills work without it.\n\n</details>\n\n<details>\n<summary>Other install methods</summary>\n\n**Claude Code plugin path:**\n```bash\nclaude plugin add boshu2/agentops\n```\n\n**Install script** (plugin + optional CLI + hooks):\n```bash\nbash <(curl -fsSL https://raw.githubusercontent.com/boshu2/agentops/main/scripts/install.sh)\n```\n\n</details>\n\n<details>\n<summary>Troubleshooting</summary>\n\nIf slash commands don't appear: `npx skills@latest update`\n\nMore: [docs/troubleshooting.md](docs/troubleshooting.md)\n\n</details>\n\n<details>\n<summary><strong>.gitignore</strong></summary>\n\n`ao init` automatically adds `.agents/` to your `.gitignore`. If you prefer stealth mode (no `.gitignore` modification), use `ao init --stealth` to write to `.git/info/exclude` instead. The session-start hook also auto-adds the entry as a safety net.\n\nFor `.beads/`, add manually if using beads issue tracking:\n```gitignore\n.beads/\n```\n\n</details>\n\n---\n\n## The Path\n\n```\n/quickstart                          ← Day 1: guided tour on your codebase (~10 min)\n    │\n/council, /research, /vibe           ← Week 1: use skills standalone, learn the pieces\n    │\n/rpi \"goal\"                          ← Week 2: full lifecycle — research → ship → learn\n    │\nGOALS.yaml + /evolve                 ← Ongoing: define fitness goals, the system compounds\n```\n\nStart with `/quickstart`. Use individual skills when you need them. Graduate to `/rpi` for end-to-end. Set `GOALS.yaml` and let `/evolve` compound from there.\n\n**Where does the knowledge live?** Everything the system learns is stored in `.agents/` — a local knowledge vault in your repo. Learnings, research artifacts, plans, fitness snapshots, and session handoffs all live there. Knowledge survives across sessions automatically. You never configure it; skills read from and write to it automatically.\n\n---\n\n## The Workflow\n\n1. **`/research`** — Explores your codebase. Produces a research artifact with findings and recommendations.\n\n2. **`/plan`** — Decomposes the goal into issues with dependency waves. Derives three-tier boundaries (Always / Ask First / Never) to prevent scope creep, and conformance checks — verifiable assertions generated from the spec itself. Creates a [beads](https://github.com/steveyegge/beads) epic (git-native issue tracking).\n\n3. **`/pre-mortem`** — 4 judges simulate failures before you write code, including a spec-completeness judge that validates plan boundaries and conformance checks. FAIL? Re-plan with feedback and try again (max 3).\n\n4. **`/crank`** — Spawns parallel agents in waves. Each worker gets fresh context. Cross-cutting constraints from the plan are injected into every wave's validation pass. `--test-first` uses a spec-first TDD model — specs and tests before implementation in every wave. Lead validates and commits. Runs until every issue is closed.\n\n5. **`/vibe`** — 3 judges validate the code. FAIL? Re-crank with failure context and re-vibe (max 3).\n\n6. **`/post-mortem`** — Council validates the implementation. Retro extracts learnings. Synthesizes process improvements. **Suggests the next `/rpi` command.**\n\n`/rpi \"goal\"` runs all six, end to end (micro-epics of 2 or fewer issues auto-detect fast-path: inline validation instead of full council, ~15 min faster with no quality loss). Use `--interactive` if you want human gates at research and plan.\n\n### Phased RPI: Own Your Context Window\n\nFor larger goals, `ao rpi phased \"goal\"` runs each phase in its own fresh Claude session — no context bleed between phases. Supports `--interactive` (human gates at research/plan), `--from=<phase>` (resume), and parallel worktrees.\n\n```bash\nao rpi phased \"add rate limiting\"      # Hands-free, fresh context per phase\nao rpi phased \"add auth\" &             # Run multiple in parallel (auto-worktrees)\nao rpi phased --from=crank \"fix perf\"  # Resume from any phase\n```\n\nUse `/rpi` when context fits in one session. Use `ao rpi phased` when it doesn't.\n\n---\n\n## The Flywheel\n\nThis is what makes AgentOps different. Each session learns from every session before it.\n\n```\n  /rpi \"goal A\"\n    │\n    ├── research → plan → pre-mortem → crank → vibe\n    │\n    ▼\n  /post-mortem\n    ├── council validates what shipped\n    ├── retro extracts what you learned\n    ├── proposes how to improve the skills   ← the tools get better\n    └── \"Next: /rpi <enhancement>\" ────┐\n                                       │\n  /rpi \"goal B\" ◄──────────────────────┘\n    │\n    └── ...repeat forever\n```\n\nPost-mortem analyzes every learning from the retro, asks \"what process would this improve?\", and writes concrete improvement proposals. Then it hands you a ready-to-copy `/rpi` command targeting the highest-priority improvement. You come back, paste it, walk away. The knowledge base grows with each cycle.\n\nLearnings pass quality gates (specificity, actionability, novelty) and land in gold/silver/bronze tiers. [MemRL](https://arxiv.org/abs/2502.06173)-inspired freshness decay ensures recent insights outweigh stale patterns.\n\n### Goal-Driven Mode: `/evolve`\n\nDefine fitness goals in `GOALS.yaml`, then `/evolve` measures them, picks the worst gap, runs `/rpi` to fix it, re-measures ALL goals (regressed commits auto-revert), and loops. Kill switch: `echo \"stop\" > ~/.config/evolve/KILL`\n\n---\n\n## Skills\n\n37 skills: 27 user-facing, 10 internal (fire automatically).\n\n| | Key skills |\n|---|---|\n| **Orchestration** | `/rpi` (full lifecycle), `/council` (multi-model consensus), `/crank` (parallel waves), `/evolve` (goal-driven loop) |\n| **Workflow** | `/research`, `/plan`, `/implement`, `/vibe` (validate code), `/pre-mortem` (validate plans), `/post-mortem` |\n| **Utilities** | `/status`, `/quickstart`, `/bug-hunt`, `/doc`, `/release`, `/knowledge`, `/handoff` |\n\nFull reference with all 37 skills: [docs/SKILLS.md](docs/SKILLS.md)\n\n---\n\n## How It Works\n\nParallel agents produce noisy output; councils filter it; ratchets lock progress so it can never regress. Every worker gets fresh context — no bleed-through between waves. 12 hooks enforce the workflow automatically (kill switch: `AGENTOPS_HOOKS_DISABLED=1`).\n\nDeep dive: [docs/how-it-works.md](docs/how-it-works.md) — Brownian Ratchet, Ralph Loops, agent backends, hooks, context windowing.\n\n---\n\n## The `ao` CLI\n\nOptional but recommended. The CLI is plumbing — skills and hooks call it automatically. You install it, your agent uses it.\n\n```bash\nbrew tap boshu2/agentops https://github.com/boshu2/homebrew-agentops && brew install agentops\nao hooks install --full # All 12 hooks across 8 lifecycle events\n```\n\n**The three commands you'll actually type:**\n```bash\nao rpi phased \"goal\"   # Full RPI lifecycle, fresh context per phase\nao search \"query\"      # Search knowledge across files and chat history\nao demo                # Interactive demo of capabilities\n```\n\nEverything else runs automatically. 73 commands total — full reference: [CLI Commands](cli/docs/COMMANDS.md)\n\n---\n\n## FAQ\n\n**No data leaves your machine.** All state lives in `.agents/` (local; git-ignored by default). No telemetry, no cloud. Works with Claude Code, Codex CLI, Cursor, Open Code — anything supporting [Skills](https://skills.sh).\n\nMore questions: [docs/FAQ.md](docs/FAQ.md) — comparisons, limitations, subagent nesting, PRODUCT.md, uninstall.\n\n---\n\n<details>\n<summary><strong>Built on</strong></summary>\n\n| Project | Role |\n|---------|------|\n| [Ralph Wiggum pattern](https://ghuntley.com/ralph/) | Fresh context per agent — no bleed-through |\n| [Multiclaude](https://github.com/dlorenc/multiclaude) | Validation gates that lock — no regression |\n| [beads](https://github.com/steveyegge/beads) | Git-native issue tracking |\n| [CASS](https://github.com/Dicklesworthstone/coding_agent_session_search) | Unified search across coding agent chat histories |\n| [MemRL](https://arxiv.org/abs/2502.06173) | Two-phase retrieval for cross-session memory |\n\n</details>\n\n## Contributing\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md). If AgentOps helped you ship something, post in [Discussions](https://github.com/boshu2/agentops?tab=discussions).\n\n## License\n\nApache-2.0 · [Docs](docs/INDEX.md) · [How It Works](docs/how-it-works.md) · [FAQ](docs/FAQ.md) · [Architecture](docs/ARCHITECTURE.md) · [CLI Reference](cli/docs/COMMANDS.md) · [Changelog](CHANGELOG.md)\n"
      },
      "plugins": [
        {
          "name": "agentops",
          "description": "The missing DevOps layer for coding agents. Give it a goal, it ships validated code and gets smarter.",
          "version": "2.9.3",
          "source": "./",
          "author": {
            "name": "Boden Fuller",
            "email": "fullerbt@users.noreply.github.com"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add boshu2/agentops",
            "/plugin install agentops@agentops-marketplace"
          ]
        }
      ]
    }
  ]
}