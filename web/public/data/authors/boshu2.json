{
  "author": {
    "id": "boshu2",
    "display_name": "Bo",
    "avatar_url": "https://avatars.githubusercontent.com/u/241868352?u=2884b19153971636ad05a0dd021b2826db79b16a&v=4"
  },
  "marketplaces": [
    {
      "name": "agentops-marketplace",
      "version": null,
      "description": "The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.",
      "repo_full_name": "boshu2/agentops",
      "repo_url": "https://github.com/boshu2/agentops",
      "repo_description": "The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.",
      "signals": {
        "stars": 131,
        "forks": 14,
        "pushed_at": "2026-02-20T12:58:25Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"agentops-marketplace\",\n  \"owner\": {\n    \"name\": \"Boden Fuller\",\n    \"email\": \"fullerbt@users.noreply.github.com\"\n  },\n  \"metadata\": {\n    \"description\": \"The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.\",\n    \"version\": \"2.12.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agentops\",\n      \"description\": \"The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.\",\n      \"version\": \"2.12.0\",\n      \"source\": \"./\",\n      \"author\": {\n        \"name\": \"Boden Fuller\",\n        \"email\": \"fullerbt@users.noreply.github.com\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"$schema\": \"../schemas/plugin-manifest.v1.schema.json\",\n  \"name\": \"agentops\",\n  \"version\": \"2.12.0\",\n  \"description\": \"The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.\",\n  \"author\": {\n    \"name\": \"Boden Fuller\",\n    \"email\": \"fullerbt@users.noreply.github.com\"\n  },\n  \"homepage\": \"https://github.com/boshu2/agentops\",\n  \"repository\": \"https://github.com/boshu2/agentops\",\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\n    \"devops\",\n    \"vibe-coding\",\n    \"shift-left\",\n    \"validation\",\n    \"coding-agents\",\n    \"knowledge-flywheel\",\n    \"pre-mortem\",\n    \"vibe-check\",\n    \"workflow\",\n    \"skills\",\n    \"ao-cli\"\n  ]\n}\n",
        "README.md": "<div align=\"center\">\n\n# AgentOps\n\n### Coding agents forget everything between sessions. This fixes that.\n\n[How It Works](#how-it-works) · [See It Work](#see-it-work) · [Skill Router](#skill-router) · [Install](#install) · [Deep Dive](#deep-dive) · [Skills](#skills) · [CLI](#the-ao-cli) · [FAQ](#faq)\n\n</div>\n\n<p align=\"center\">\n<img src=\"docs/assets/swarm-6-rpi.png\" alt=\"Agents running full development cycles in parallel with validation gates and a coordinating team leader\" width=\"800\">\n<br>\n<i>From goal to shipped code — agents research, plan, and implement in parallel. Councils validate before and after. Every learning feeds the next session.</i>\n</p>\n\n---\n\n## How It Works\n\nCoding agents get a blank context window every session. AgentOps is a toolbox of primitives — pick the ones you need, skip the ones you don't. Every skill works standalone. Swarm any of them for parallelism. Chain them into a pipeline when you want structure. Knowledge compounds between sessions automatically.\n\n**DevOps' Three Ways** — applied to the agent loop as composable primitives:\n\n- **Flow** (`/research`, `/plan`, `/crank`, `/swarm`, `/rpi`): orchestration skills that move work through the system. Single-piece flow, minimizing context switches. Swarm parallelizes any skill; crank runs dependency-ordered waves; rpi chains the full pipeline.\n- **Feedback** (`/council`, `/vibe`, `/pre-mortem`, hooks): shorten the feedback loop until defects can't survive it. Independent judges catch issues before code ships. Hooks make the rules unavoidable — validation gates, push blocking, standards injection. Problems found Friday don't wait until Monday.\n- **Learning** (`.agents/`, `ao` CLI, `/retro`, `/knowledge`): stop rediscovering what you already know. Every session extracts learnings into an append-only ledger, scores them by freshness, and re-injects the best ones at next session start. Session 50 knows what session 1 learned the hard way.\n\n---\n\n## See It Work\n\n```text\n/quickstart                          ← Day 1: guided tour on your codebase (~10 min)\n    │\nNot sure what to do?                 ─────────► /brainstorm\n    │\nHave an idea of what you want?       ─────────► /research\n    │\nReady to scope it cleanly?           ─────────► /plan\n    │\n/implement (small) · /crank (epic)   ← Build and ship\n    │\n/vibe → /post-mortem                 ← Validate and learn\n    │\n/rpi \"goal\"                          ← One command for the full flow\n```\n\n**Use one skill** — validate a PR:\n\n```text\n> /council validate this PR\n\n[council] 3 judges spawned (independent, no anchoring)\n[judge-1] PASS — token bucket implementation correct\n[judge-2] WARN — rate limiting missing on /login endpoint\n[judge-3] PASS — Redis integration follows middleware pattern\nConsensus: WARN — add rate limiting to /login before shipping\n```\n\nThe council verdict, your decisions, and the patterns used are automatically written to `.agents/` — an append-only ledger. Nothing gets overwritten. Session ends, hooks extract learnings.\n\n**Knowledge compounds** — three weeks later, different task, but your agent already knows:\n\n```text\n> /research \"retry backoff strategies\"\n\n[inject] 3 prior learnings loaded (freshness-weighted):\n  - Token bucket with Redis (established, high confidence)\n  - Rate limit at middleware layer, not per-handler (pattern)\n  - /login endpoint was missing rate limiting (decision)\n[research] Found prior art in your codebase + injected context\n           Recommends: exponential backoff with jitter, reuse existing Redis client\n```\n\nSession 5 didn't start from scratch — it started with what session 1 learned. Stale insights [decay automatically](docs/the-science.md).\n\n**Parallelize anything** with `/swarm`:\n\n```text\n> /swarm \"research auth patterns, brainstorm rate limiting improvements\"\n\n[swarm] 3 agents spawned — each gets fresh context\n[agent-1] /research auth — found JWT + session patterns, 2 prior learnings\n[agent-2] /research rate-limiting — found token bucket, middleware pattern\n[agent-3] /brainstorm improvements — 4 approaches ranked\n[swarm] Complete — artifacts in .agents/\n```\n\n**Full pipeline** — one command, walk away:\n\n```text\n> /rpi \"add retry backoff to rate limiter\"\n\n[research]    Found 3 prior learnings on rate limiting (injected)\n[plan]        2 issues, 1 wave → epic ag-0058\n[pre-mortem]  Council validates plan → PASS (knew about Redis choice)\n[crank]       Parallel agents: Wave 1 ██ 2/2\n[vibe]        Council validates code → PASS\n[post-mortem] 2 new learnings → .agents/\n[flywheel]    Next: /rpi \"add circuit breaker to external API calls\"\n```\n\n<p align=\"center\">\n<img src=\"docs/assets/crank-3-parallel-epics.png\" alt=\"Completed crank run with 3 parallel epics and 15 issues shipped in 5 waves\" width=\"800\">\n<br>\n<i>AgentOps building AgentOps: completed `/crank` across 3 parallel epics (15 issues, 5 waves, 0 regressions).</i>\n</p>\n\n<details>\n<summary><b>More examples</b> — /evolve, session continuity</summary>\n\n<br>\n\n**Session continuity across compaction or restart:**\n```text\n> /handoff\n[handoff] Saved: 3 open issues, current branch, next action\n         Continuation prompt written to .agents/handoffs/\n\n--- next session ---\n\n> /recover\n[recover] Found in-progress epic ag-0058 (2/5 issues closed)\n          Branch: feature/rate-limiter\n          Next: /implement ag-0058.3\n```\n\n**Goal-driven improvement loop:**\n```text\n> /evolve --max-cycles=5\n\n[evolve] GOALS.yaml: 4 goals loaded\n[cycle-1] Measuring fitness... 2/4 passing\n         Worst gap: test-pass-rate (weight: 10)\n         /rpi \"Improve test-pass-rate\" → 3 issues, 2 waves\n         Re-measure: 3/4 passing ✓\n[cycle-2] Worst gap: doc-coverage (weight: 7)\n         /rpi \"Improve doc-coverage\" → 2 issues, 1 wave\n         Re-measure: 4/4 passing ✓\n[cycle-3] All goals met. Checking harvested work...\n         Picked: \"add smoke test for /evolve\" (from post-mortem)\n[teardown] /post-mortem → 5 learnings extracted\n```\n\n</details>\n\n<details>\n<summary><b>Different developers, different setups</b> — use what fits your workflow</summary>\n\n<br>\n\n**The PR reviewer** — uses one skill, nothing else:\n```text\n> /council validate this PR\nConsensus: WARN — missing error handling in 2 locations\n```\nThat's it. No pipeline, no setup, no commitment. One command, actionable feedback.\n\n**The team lead** — composes skills manually:\n```text\n> /research \"performance bottlenecks in the API layer\"\n> /plan \"optimize database queries identified in research\"\n> /council validate the plan\n```\nPicks skills as needed, stays in control of sequencing.\n\n**The solo dev** — runs the full pipeline, walks away:\n```text\n> /rpi \"add user authentication\"\n[3 phases run autonomously, learnings extracted]\n```\nOne command does research through post-mortem. Comes back to committed code.\n\n**The platform team** — parallel agents, hands-free improvement:\n```text\n> /swarm \"run /rpi on each of these 3 epics\"\n> /evolve --max-cycles=5\n```\nSwarms full pipelines in parallel. Evolve measures goals and fixes gaps in a loop.\n\n</details>\n\n---\n\n## Skill Router\n\nUse this when you're not sure which skill to run.\n\n```text\nWhat are you trying to do?\n│\n├─ \"Not sure what to do yet\"\n│   └─ Generate options first ─────► /brainstorm\n│\n├─ \"I have an idea\"\n│   └─ Understand code + context ──► /research\n│\n├─ \"I know what I want to build\"\n│   └─ Break it into issues ───────► /plan\n│\n├─ \"Now build it\"\n│   ├─ Small/single issue ─────────► /implement\n│   ├─ Multi-issue epic ───────────► /crank <epic-id>\n│   └─ Full flow in one command ───► /rpi \"goal\"\n│\n├─ \"Fix a bug\"\n│   ├─ Know which file? ──────────► /implement <issue-id>\n│   └─ Need to investigate? ──────► /bug-hunt\n│\n├─ \"Build a feature\"\n│   ├─ Small (1-2 files) ─────────► /implement\n│   ├─ Medium (3-6 issues) ───────► /plan → /crank\n│   └─ Large (7+ issues) ─────────► /rpi (full pipeline)\n│\n├─ \"Validate something\"\n│   ├─ Code ready to ship? ───────► /vibe\n│   ├─ Plan ready to build? ──────► /pre-mortem\n│   ├─ Work ready to close? ──────► /post-mortem\n│   └─ Quick sanity check? ───────► /council --quick validate\n│\n├─ \"Explore or research\"\n│   ├─ Understand this codebase ──► /research\n│   ├─ Compare approaches ────────► /council research <topic>\n│   └─ Generate ideas ────────────► /brainstorm\n│\n├─ \"Learn from past work\"\n│   ├─ What do we know about X? ──► /knowledge <query>\n│   ├─ Save this insight ─────────► /learn \"insight\"\n│   └─ Run a retrospective ───────► /retro\n│\n├─ \"Parallelize work\"\n│   ├─ Multiple independent tasks ► /swarm\n│   └─ Full epic with waves ──────► /crank <epic-id>\n│\n├─ \"Ship a release\"\n│   └─ Changelog + tag ──────────► /release <version>\n│\n├─ \"Session management\"\n│   ├─ Where was I? ──────────────► /status\n│   ├─ Save for next session ─────► /handoff\n│   └─ Recover after compaction ──► /recover\n│\n└─ \"First time here\" ────────────► /quickstart\n```\n\n---\n\n## Install\n\n**Requirements**\n\n- `node` 18+ (for `npx skills`) and `git`\n- One supported runtime: Claude Code, Codex CLI, Cursor, or OpenCode\n- Optional for `ao` CLI install path shown below: Homebrew (`brew`)\n\n```bash\n# Claude Code, Codex CLI, Cursor (most users)\nnpx skills@latest add boshu2/agentops --all -g\n\n# OpenCode\ncurl -fsSL https://raw.githubusercontent.com/boshu2/agentops/main/scripts/install-opencode.sh | bash\n```\n\n**Works with:** Claude Code · Codex CLI · Cursor · OpenCode — skills are portable across runtimes (`/converter` exports to native formats).\n\nThen type `/quickstart` in your agent chat.\n\n```bash\n# Claude Code plugin (alternative)\nclaude plugin add boshu2/agentops\n```\n\n`npx skills` installs skills into your agent's global skills directory. The plugin path registers AgentOps as a Claude Code plugin instead — same skills, different integration point. Most users should start with `npx skills`.\n\n<details>\n<summary><b>The ao CLI</b> — powers the knowledge flywheel</summary>\n\nSkills work standalone. The `ao` CLI powers the automated learning loop — knowledge extraction, injection with freshness decay, maturity lifecycle, and progress gates. Install it when you want knowledge to compound between sessions.\n\n```bash\nbrew tap boshu2/agentops https://github.com/boshu2/homebrew-agentops && brew install agentops\ncd /path/to/your/repo\nao init --hooks\n```\n\nThis installs 25+ hooks across core lifecycle events:\n\n| Event | What happens |\n|-------|-------------|\n| **SessionStart** | Extract from prior session, inject top learnings (freshness-weighted), check progress gates |\n| **SessionEnd** | Mine transcript for knowledge, record session outcome, expire stale artifacts, evict dead knowledge |\n| **PreToolUse** | Inject coding standards before edits, gate dangerous git ops, validate before push |\n| **PostToolUse** | Advance progress ratchets, track citations |\n| **TaskCompleted** | Validate task output against acceptance criteria |\n| **Stop/PreCompact** | Close feedback loops, snapshot before compaction |\n\n</details>\n\n<details>\n<summary><b>OpenCode</b> — plugin + skills</summary>\n\nInstalls 7 hooks (tool enrichment, audit logging, compaction resilience) and symlinks all skills. Restart OpenCode after install. Details: [.opencode/INSTALL.md](.opencode/INSTALL.md)\n\n</details>\n\n**Local-only. No telemetry. No cloud. No accounts.**\n\n| What | Where | Reversible? |\n|------|-------|:-----------:|\n| Skills | Global skills dir (outside your repo; for Claude Code: `~/.claude/skills/`) | `npx skills@latest remove boshu2/agentops -g` |\n| Knowledge artifacts | `.agents/` in your repo (git-ignored by default) | `rm -rf .agents/` |\n| Hook registration | `.claude/settings.json` | `ao hooks uninstall` or delete entries |\n| Git push gate | Pre-push hook (optional, only with CLI) | `AGENTOPS_HOOKS_DISABLED=1` |\n\nNothing modifies your source code. Nothing phones home. Everything is [open source](cli/) — audit it yourself.\n\n<details>\n<summary><b>Configuration</b> — environment variables</summary>\n\nAll optional. AgentOps works out of the box with no configuration.\n\n**Council / validation:**\n\n| Variable | Default | What it does |\n|----------|---------|-------------|\n| `COUNCIL_TIMEOUT` | 120 | Judge timeout in seconds |\n| `COUNCIL_CLAUDE_MODEL` | sonnet | Claude model for judges (`opus` for high-stakes) |\n| `COUNCIL_CODEX_MODEL` | (user's Codex default) | Override Codex model for `--mixed` |\n| `COUNCIL_EXPLORER_MODEL` | sonnet | Model for explorer sub-agents |\n| `COUNCIL_EXPLORER_TIMEOUT` | 60 | Explorer timeout in seconds |\n| `COUNCIL_R2_TIMEOUT` | 90 | Debate round 2 timeout in seconds |\n\n**Hooks:**\n\n| Variable | Default | What it does |\n|----------|---------|-------------|\n| `AGENTOPS_HOOKS_DISABLED` | 0 | `1` to disable all hooks (kill switch) |\n| `AGENTOPS_PRECOMPACT_DISABLED` | 0 | `1` to disable pre-compaction snapshot |\n| `AGENTOPS_TASK_VALIDATION_DISABLED` | 0 | `1` to disable task validation gate |\n| `AGENTOPS_SESSION_START_DISABLED` | 0 | `1` to disable session-start hook |\n| `AGENTOPS_EVICTION_DISABLED` | 0 | `1` to disable knowledge eviction |\n| `AGENTOPS_GITIGNORE_AUTO` | 1 | `0` to skip auto-adding `.agents/` to `.gitignore` |\n| `AGENTOPS_WORKER` | 0 | `1` to skip push gate (for worker agents) |\n\nFull reference with examples and precedence rules: [docs/ENV-VARS.md](docs/ENV-VARS.md)\n\n</details>\n\nTroubleshooting: [docs/troubleshooting.md](docs/troubleshooting.md)\n\n---\n\n## Deep Dive\n\nStandard iterative development — research, plan, validate, build, review, learn — automated for agents that can't carry context between sessions.\n\nThis is DevOps thinking applied to agent work: the **Three Ways** as composable primitives.\n\n- **Flow**: wave-based execution (`/crank`) + workflow orchestration (`/rpi`) to keep work moving.\n- **Feedback**: shift-left validation (`/pre-mortem`, `/vibe`, `/council`) plus optional gates/hooks to make feedback unavoidable.\n- **Continual learning**: post-mortems turn outcomes into reusable knowledge in `.agents/`, so the next session starts smarter. `/flywheel` monitors health.\n\n### The Knowledge Ledger\n\n`.agents/` is an append-only ledger with cache-like semantics. Nothing gets overwritten — every learning, council verdict, pattern, and decision is a new dated file. Freshness decay prunes what's stale. The cycle:\n\n```\nSession N ends\n    → ao forge: mine transcript for learnings, decisions, patterns\n    → ao maturity --expire: mark stale artifacts (freshness decay)\n    → ao maturity --evict: archive what's decayed past threshold\n\nSession N+1 starts\n    → ao inject --apply-decay: score all artifacts by recency,\n      inject top-N within token budget\n    → Agent starts with institutional knowledge, not a blank slate\n```\n\nWrite once, score by freshness, inject the best, prune the rest. If `retrieval_rate × usage_rate` stays above decay and scale friction, knowledge compounds. If not, growth stalls unless fresh input or stronger controls are added. The [formal model](docs/the-science.md) is cache eviction with a decay function and limits-to-growth controls.\n\n```\n  /rpi \"goal\"\n    │\n    ├── /research → /plan → /pre-mortem → /crank → /vibe\n    │\n    ▼\n  /post-mortem\n    ├── validates what shipped\n    ├── extracts learnings → .agents/\n    └── suggests next /rpi command ────┐\n                                       │\n   /rpi \"next goal\" ◄──────────────────┘\n```\n\nThe post-mortem analyzes each learning, asks \"what process would this improve?\", and writes improvement proposals. It hands you a ready-to-copy `/rpi` command. Paste it, walk away.\n\nLearnings pass quality gates (specificity, actionability, novelty) and land in tiered pools. Freshness decay ensures recent insights outweigh stale patterns.\n\n<details>\n<summary><b>Phase details</b> — what each step does</summary>\n\n1. **`/research`** — Explores your codebase. Produces a research artifact with findings and recommendations.\n\n2. **`/plan`** — Decomposes the goal into issues with dependency waves. Derives scope boundaries and conformance checks. Creates a [beads](https://github.com/steveyegge/beads) epic (git-native issue tracking).\n\n3. **`/pre-mortem`** — Judges simulate failures before you write code, including a spec-completeness judge. FAIL? Re-plan with feedback (max 3 retries).\n\n4. **`/crank`** — Spawns parallel agents in dependency-ordered waves. Each worker gets fresh context. Lead validates and commits. Runs until every issue is closed. `--test-first` for spec-first TDD.\n\n5. **`/vibe`** — Judges validate the code. FAIL? Re-crank with failure context and re-vibe (max 3).\n\n6. **`/post-mortem`** — Council validates the implementation. Retro extracts learnings. **Suggests the next `/rpi` command.**\n\n`/rpi \"goal\"` runs all six end to end. Use `--interactive` for human gates at research and plan.\n\n</details>\n\n<details>\n<summary><b>Phased RPI</b> — fresh context per phase for larger goals</summary>\n\n`ao rpi phased \"goal\"` runs each phase in its own session — no context bleed between phases.\n\n```bash\nao rpi phased \"add rate limiting\"      # Hands-free, fresh context per phase\nao rpi phased \"add auth\" &             # Run multiple in parallel (auto-worktrees)\nao rpi phased --from=implementation \"fix perf\"  # Resume at execution phase\nao rpi status --watch                   # Monitor active phased runs\n```\n\nUse `/rpi` when context fits in one session. Use `ao rpi phased` when it doesn't.\n\n</details>\n\n<details>\n<summary><b>Goal-driven mode</b> — /evolve with GOALS.yaml</summary>\n\nBootstrap with `/goals generate` — it scans your repo (PRODUCT.md, README, skills, tests) and proposes mechanically verifiable goals. Or write them by hand:\n\n```yaml\n# GOALS.yaml\nversion: 1\ngoals:\n  - id: test-pass-rate\n    description: \"All tests pass\"\n    check: \"make test\"\n    weight: 10\n```\n\nThen `/evolve` measures them, picks the worst gap, runs `/rpi` to fix it, re-measures ALL goals (regressed commits auto-revert), and loops. It commits locally — you control when to push. Kill switch: `echo \"stop\" > ~/.config/evolve/KILL`\n\nMaintain over time: `/goals` shows pass/fail status, `/goals prune` finds stale or broken checks.\n\n</details>\n\n<details>\n<summary><b>References</b> — science, systems theory, prior art</summary>\n\nBuilt on [Darr 1995](docs/the-science.md) (decay rates), Sweller 1988 (cognitive load), [Liu et al. 2023](docs/the-science.md) (lost-in-the-middle), [MemRL 2025](https://arxiv.org/abs/2601.03192) (RL for memory).\n\nAgentOps concentrates on the high-leverage end of [Meadows' hierarchy](https://en.wikipedia.org/wiki/Twelve_leverage_points): information flows (#6), rules (#5), self-organization (#4), goals (#3). The bet: changing the loop beats tuning the output.\n\nDeep dive: [docs/how-it-works.md](docs/how-it-works.md) — Brownian Ratchet, Ralph Wiggum Pattern, agent backends, hooks, context windowing.\n\n</details>\n\n---\n\n## Architecture\n\nFive pillars, one recursive shape. The same pattern — lead decomposes work, workers execute atomically, validation gates lock progress, next wave begins — repeats at every scale:\n\n```\n/implement ── one worker, one issue, one verify cycle\n    └── /crank ── waves of /implement (FIRE loop)\n        └── /rpi ── research → plan → crank → validate → learn\n            └── /evolve ── fitness-gated /rpi cycles\n```\n\nEach level treats the one below as a black box: spec in, validated result out. Workers get fresh context per wave ([Ralph Wiggum Pattern](https://ghuntley.com/ralph/)), never commit (lead-only), and communicate through the filesystem — not accumulated chat context. Parallel execution works because each unit of work is **atomic**: no shared mutable state with concurrent workers.\n\nValidation is mechanical, not advisory. [Multi-model councils](docs/ARCHITECTURE.md#pillar-2-brownian-ratchet) judge before and after implementation. [Hooks](docs/how-it-works.md) enforce gates — push blocked until `/vibe` passes, `/crank` blocked until `/pre-mortem` passes. The [knowledge flywheel](docs/ARCHITECTURE.md#pillar-4-knowledge-flywheel) extracts learnings, scores them, and re-injects them at session start so each cycle compounds.\n\nFull treatment: [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) — all five pillars, operational invariants, component overview.\n\n---\n\n## Skills\n\nEvery skill works alone. Compose them however you want.\n\n**Judgment** — the foundation everything validates against:\n\n| Skill | What it does |\n|-------|-------------|\n| `/council` | Independent judges (Claude + Codex) debate, surface disagreement, converge. `--preset=security-audit`, `--perspectives`, `--debate` for adversarial review |\n| `/vibe` | Code quality review — complexity analysis + council |\n| `/pre-mortem` | Validate plans before implementation — council simulates failures |\n| `/post-mortem` | Wrap up completed work — council validates + retro extracts learnings |\n\n**Execution** — research, plan, build, ship:\n\n| Skill | What it does |\n|-------|-------------|\n| `/research` | Deep codebase exploration — produces structured findings |\n| `/plan` | Decompose a goal into trackable issues with dependency waves |\n| `/implement` | Full lifecycle for one task — research, plan, build, validate, learn |\n| `/crank` | Parallel agents in dependency-ordered waves, fresh context per worker |\n| `/swarm` | Parallelize any skill — run research, brainstorms, implementations in parallel |\n| `/rpi` | Full pipeline: discovery (research + plan + pre-mortem) → implementation (crank) → validation (vibe + post-mortem) |\n| `/evolve` | Measure fitness goals, fix the worst gap, roll back regressions, loop |\n\n**Knowledge** — the flywheel that makes sessions compound:\n\n| Skill | What it does |\n|-------|-------------|\n| `/knowledge` | Query learnings, patterns, and decisions across `.agents/` |\n| `/learn` | Manually capture a decision, pattern, or lesson |\n| `/retro` | Extract learnings from completed work |\n| `/flywheel` | Monitor knowledge health — velocity, staleness, pool depths |\n\n**Supporting skills:**\n\n| | |\n|---|---|\n| **Onboarding** | `/quickstart`, `/using-agentops` |\n| **Session** | `/handoff`, `/recover`, `/status` |\n| **Traceability** | `/trace`, `/provenance` |\n| **Product** | `/product`, `/goals`, `/release`, `/readme`, `/doc` |\n| **Utility** | `/quickstart`, `/brainstorm`, `/bug-hunt`, `/complexity` |\n\nFull reference: [docs/SKILLS.md](docs/SKILLS.md)\n\n<details>\n<summary><b>Cross-runtime orchestration</b> — mix Claude, Codex, OpenCode</summary>\n\nAgentOps orchestrates across runtimes. Claude can lead a team of Codex workers. Codex judges can review Claude's output.\n\n| Spawning Backend | How it works | Best for |\n|-----------------|-------------|----------|\n| **Native teams** | `TeamCreate` + `SendMessage` — built into Claude Code | Tight coordination, debate |\n| **Background tasks** | `Task(run_in_background=true)` — last-resort fallback | When no team APIs available |\n| **Codex sub-agents** | `/codex-team` — Claude orchestrates Codex workers | Cross-vendor validation |\n| **tmux + Agent Mail** | `/swarm --mode=distributed` — full process isolation | Long-running work, crash recovery |\n\n</details>\n\nDistributed mode workers survive disconnects — each runs in its own tmux session with crash recovery. `tmux attach` to debug live.\n\n---\n\n## The `ao` CLI\n\nSkills work standalone — no CLI required. The `ao` CLI adds two things: (1) the knowledge flywheel that makes sessions compound (extract, inject, decay, maturity), and (2) terminal-based RPI that runs without an active chat session. Each phase gets its own fresh context window, so large goals don't hit context limits.\n\n```bash\nao rpi phased \"add rate limiting\"              # 3 sessions: discover → build → validate\nao rpi phased \"fix auth bug\" &                 # Run multiple in parallel (auto-worktrees)\nao rpi phased --from=implementation \"ag-058\"   # Resume at build phase\nao rpi status --watch                          # Monitor active runs\n```\n\nWalk away, come back to committed code + extracted learnings.\n\n```bash\nao search \"query\"      # Search knowledge across files and chat history\nao demo                # Interactive demo\n```\n\nFull reference: [CLI Commands](cli/docs/COMMANDS.md)\n\n---\n\n## How AgentOps Fits With Other Tools\n\nThese are fellow experiments in making coding agents work. Use pieces from any of them.\n\n| Alternative | What it does well | Where AgentOps focuses differently |\n|-------------|-------------------|-------------------------------------|\n| **[GSD](https://github.com/glittercowboy/get-shit-done)** | Clean subagent spawning, fights context rot | Cross-session memory (GSD keeps context fresh *within* a session; AgentOps carries knowledge *between* sessions) |\n| **[Compound Engineer](https://github.com/EveryInc/compound-engineering-plugin)** | Knowledge compounding, structured loop | Multi-model councils and validation gates — independent judges debating before and after code ships |\n\n[Detailed comparisons →](docs/comparisons/)\n\n---\n\n## FAQ\n\n[docs/FAQ.md](docs/FAQ.md) — comparisons, limitations, subagent nesting, PRODUCT.md, uninstall.\n\n---\n\n<details>\n<summary><b>Built on</b> — Ralph Wiggum, Multiclaude, beads, CASS, MemRL</summary>\n\n[Ralph Wiggum](https://ghuntley.com/ralph/) (fresh context per agent) · [Multiclaude](https://github.com/dlorenc/multiclaude) (validation gates) · [beads](https://github.com/steveyegge/beads) (git-native issues) · [CASS](https://github.com/Dicklesworthstone/coding_agent_session_search) (session search) · [MemRL](https://arxiv.org/abs/2601.03192) (cross-session memory)\n\n</details>\n\n## Contributing\n\n<details>\n<summary><b>Issue tracking</b> — Beads / bd</summary>\n\nGit-native issues in `.beads/`. `bd onboard` (setup) · `bd ready` (find work) · `bd show <id>` · `bd close <id>` · `bd sync`. More: [AGENTS.md](AGENTS.md)\n\n</details>\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md). If AgentOps helped you ship something, post in [Discussions](https://github.com/boshu2/agentops?tab=discussions).\n\n## License\n\nApache-2.0 · [Docs](docs/INDEX.md) · [How It Works](docs/how-it-works.md) · [FAQ](docs/FAQ.md) · [Glossary](docs/GLOSSARY.md) · [Architecture](docs/ARCHITECTURE.md) · [Configuration](docs/ENV-VARS.md) · [CLI Reference](cli/docs/COMMANDS.md) · [Changelog](CHANGELOG.md)\n"
      },
      "plugins": [
        {
          "name": "agentops",
          "description": "The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.",
          "version": "2.12.0",
          "source": "./",
          "author": {
            "name": "Boden Fuller",
            "email": "fullerbt@users.noreply.github.com"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add boshu2/agentops",
            "/plugin install agentops@agentops-marketplace"
          ]
        }
      ]
    }
  ]
}