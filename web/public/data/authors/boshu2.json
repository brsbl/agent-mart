{
  "author": {
    "id": "boshu2",
    "display_name": "Bo",
    "avatar_url": "https://avatars.githubusercontent.com/u/241868352?u=2884b19153971636ad05a0dd021b2826db79b16a&v=4"
  },
  "marketplaces": [
    {
      "name": "agentops-marketplace",
      "version": null,
      "description": "The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.",
      "repo_full_name": "boshu2/agentops",
      "repo_url": "https://github.com/boshu2/agentops",
      "repo_description": "The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.",
      "signals": {
        "stars": 119,
        "forks": 12,
        "pushed_at": "2026-02-18T13:00:18Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"agentops-marketplace\",\n  \"owner\": {\n    \"name\": \"Boden Fuller\",\n    \"email\": \"fullerbt@users.noreply.github.com\"\n  },\n  \"metadata\": {\n    \"description\": \"The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.\",\n    \"version\": \"2.10.1\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agentops\",\n      \"description\": \"The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.\",\n      \"version\": \"2.10.1\",\n      \"source\": \"./\",\n      \"author\": {\n        \"name\": \"Boden Fuller\",\n        \"email\": \"fullerbt@users.noreply.github.com\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"$schema\": \"../schemas/plugin-manifest.v1.schema.json\",\n  \"name\": \"agentops\",\n  \"version\": \"2.10.1\",\n  \"description\": \"The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.\",\n  \"author\": {\n    \"name\": \"Boden Fuller\",\n    \"email\": \"fullerbt@users.noreply.github.com\"\n  },\n  \"homepage\": \"https://github.com/boshu2/agentops\",\n  \"repository\": \"https://github.com/boshu2/agentops\",\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\n    \"devops\",\n    \"vibe-coding\",\n    \"shift-left\",\n    \"validation\",\n    \"coding-agents\",\n    \"knowledge-flywheel\",\n    \"pre-mortem\",\n    \"vibe-check\",\n    \"workflow\",\n    \"skills\",\n    \"ao-cli\"\n  ]\n}\n",
        "README.md": "<div align=\"center\">\n\n<img src=\"docs/assets/hero.jpg\" alt=\"Context engineering — crafting what enters the window\" width=\"700\">\n\n# AgentOps\n\n### Coding agents forget everything between sessions. This fixes that.\n\n[![Version](https://img.shields.io/github/v/tag/boshu2/agentops?display_name=tag&sort=semver&label=version&color=8b5cf6)](CHANGELOG.md)\n[![Skills](https://img.shields.io/badge/skills-43-7c3aed)](skills/)\n[![License](https://img.shields.io/badge/license-Apache--2.0-blue.svg)](LICENSE)\n\n[How It Works](#how-it-works) · [See It Work](#see-it-work) · [Install](#install) · [The Path](#the-path) · [Skills](#skills) · [Deep Dive](#deep-dive) · [FAQ](#faq)\n\n</div>\n\n---\n\n## How It Works\n\nCoding agents get a blank context window every session. AgentOps automates the feedback loop so each session starts smarter than the last — learnings extracted, quality-gated, and re-injected automatically.\n\n**DevOps' Three Ways:** flow, feedback, continual learning. AgentOps applies them to the agent loop, then compounds memory between sessions.\n\n**The building blocks:** primitives you can mix and match into a custom pipeline that fits your workflow.\n\n- **Flow:** orchestration skills that move WIP through the system. Research → plan → validate → build → review → learn — single-piece flow, minimizing context switches.\n- **Feedback:** shorten the feedback loop until defects can't survive it. Multi-model councils catch issues before code ships. Hooks make the rules unavoidable — validation gates, push blocking, regression auto-revert. Problems found Friday don't wait until Monday.\n- **Learning:** stop rediscovering what you already know. Every session extracts learnings, scores them, and re-injects them at the next session start. Knowledge compounds instead of decaying. Session 50 knows what session 1 learned the hard way.\n\n---\n\n## See It Work\n\n**Use one piece.** No pipeline required — every skill works standalone:\n```text\n> /council validate this PR\n\n[council] 3 judges spawned\n[judge-1] PASS — JWT implementation correct\n[judge-2] WARN — rate limiting missing on /login\n[judge-3] PASS — refresh rotation implemented\nConsensus: WARN — add rate limiting before shipping\n```\n\n**Three weeks later, different session:**\n```text\n> /knowledge \"rate limiting\"\n\n1. .agents/learnings/2026-01-28-rate-limiting.md\n   [established] Token bucket with Redis — chose over sliding window for burst tolerance\n2. .agents/patterns/api-middleware.md\n   Pattern: rate limit at middleware layer, not per-handler\n```\nYour agent reads these automatically at session start — no CLI required, just skills + `.agents/`.\n\n**Wire it all together** when you're ready:\n```text\n> /rpi \"add retry backoff to rate limiter\"\n\n[research]    Found 2 prior learnings on rate limiting (injected)\n[plan]        2 issues, 1 wave → epic ag-0058\n[pre-mortem]  4 judges → PASS (knew about Redis choice from prior session)\n[crank]       Wave 1: ██ 2/2\n[vibe]        3 judges → PASS\n[post-mortem] 2 new learnings → .agents/\n[flywheel]    Next: /rpi \"add circuit breaker to external API calls\"\n```\n\n<details>\n<summary><b>More examples</b> — /crank, /evolve</summary>\n\n<br>\n\n**Parallel agents with fresh context:**\n```text\n> /crank ag-0042\n\n[crank] Epic: ag-0042 — 6 issues, 3 waves\n[wave-1] ██████ 3/3 complete\n[wave-2] ████── 2/2 complete\n[wave-3] ██──── 1/1 complete\n[vibe] PASS — all gates locked\n[post-mortem] 4 learnings extracted\n```\n\n**Goal-driven improvement loop:**\n```text\n> /evolve --max-cycles=5\n\n[evolve] GOALS.yaml: 4 goals loaded\n[cycle-1] Measuring fitness... 2/4 passing\n         Worst gap: test-pass-rate (weight: 10)\n         /rpi \"Improve test-pass-rate\" → 3 issues, 2 waves\n         Re-measure: 3/4 passing ✓\n[cycle-2] Worst gap: doc-coverage (weight: 7)\n         /rpi \"Improve doc-coverage\" → 2 issues, 1 wave\n         Re-measure: 4/4 passing ✓\n[cycle-3] All goals met. Checking harvested work...\n         Picked: \"add smoke test for /evolve\" (from post-mortem)\n[teardown] /post-mortem → 5 learnings extracted\n```\n\n</details>\n\n---\n\n## Install\n\n```bash\n# Claude Code, Codex CLI, Cursor (most users)\nnpx skills@latest add boshu2/agentops --all -g\n\n# OpenCode\ncurl -fsSL https://raw.githubusercontent.com/boshu2/agentops/main/scripts/install-opencode.sh | bash\n```\n\nThen type `/quickstart` in your agent chat.\n\n```bash\n# Claude Code plugin (alternative)\nclaude plugin add boshu2/agentops\n```\n\n<details>\n<summary><b>Full setup</b> — CLI + hooks (optional)</summary>\n\n```bash\nbrew tap boshu2/agentops https://github.com/boshu2/homebrew-agentops && brew install agentops\ncd /path/to/your/repo\nao init --hooks --full\n```\n\n12 hooks across 8 lifecycle event types. Adds knowledge injection/extraction, validation gates, session lifecycle. All skills work without it.\n\n</details>\n\n<details>\n<summary><b>OpenCode</b> — plugin + skills</summary>\n\nInstalls 7 hooks (tool enrichment, audit logging, compaction resilience) and symlinks all skills. Restart OpenCode after install. Details: [.opencode/INSTALL.md](.opencode/INSTALL.md)\n\n</details>\n\n<details>\n<summary><b>Your data</b> — what it touches, where it lives, how to remove it</summary>\n\n**Local-only. No telemetry. No cloud. No accounts.**\n\n| What | Where | Reversible? |\n|------|-------|:-----------:|\n| Skills | Global skills dir (outside your repo; for Claude Code: `~/.claude/skills/`) | `npx skills@latest remove boshu2/agentops -g` |\n| Knowledge artifacts | `.agents/` in your repo (git-ignored by default) | `rm -rf .agents/` |\n| Hook registration | `.claude/settings.json` | `ao hooks uninstall` or delete entries |\n| Git push gate | Pre-push hook (optional, only with CLI) | `AGENTOPS_HOOKS_DISABLED=1` |\n\nNothing modifies your source code. Nothing phones home. Everything is [open source](cli/) — audit it yourself.\n\n</details>\n\nTroubleshooting: [docs/troubleshooting.md](docs/troubleshooting.md)\n\n---\n\n## The Path\n\n```text\n/quickstart                          ← Day 1: guided tour on your codebase (~10 min)\n    │\n/council, /research, /vibe           ← Week 1: use skills standalone\n    │\n/rpi \"goal\"                          ← Week 2: full lifecycle — research → ship → learn\n    │\n/product → /goals generate           ← Define what good looks like\n    │\n/evolve                              ← Ongoing: measure goals, fix gaps, compound\n```\n\nStart with `/quickstart`. Use individual skills when you need them. Graduate to `/rpi` for end-to-end. When you're ready for hands-free improvement: `/product` defines your mission and personas, `/goals generate` scans for fitness goals, and `/evolve` pursues them.\n\n---\n\n## Deep Dive\n\nStandard iterative development — research, plan, validate, build, review, learn — automated for agents that can't carry context between sessions.\n\nThis is DevOps thinking applied to agent work: the **Three Ways** as composable primitives.\n\n- **Flow**: wave-based execution (`/crank`) + workflow orchestration (`/rpi`) to keep work moving.\n- **Feedback**: shift-left validation (`/pre-mortem`, `/vibe`, `/council`) plus optional gates/hooks to make feedback unavoidable.\n- **Continual learning**: post-mortems turn outcomes into reusable knowledge in `.agents/`, so the next session starts smarter.\n\n```\n  /rpi \"goal\"\n    │\n    ├── /research → /plan → /pre-mortem → /crank → /vibe\n    │\n    ▼\n  /post-mortem\n    ├── validates what shipped\n    ├── extracts learnings → .agents/\n    └── suggests next /rpi command ────┐\n                                       │\n   /rpi \"next goal\" ◄──────────────────┘\n```\n\nThe post-mortem analyzes each learning, asks \"what process would this improve?\", and writes improvement proposals. It hands you a ready-to-copy `/rpi` command. Paste it, walk away.\n\nLearnings pass quality gates (specificity, actionability, novelty) and land in tiered pools. Freshness decay ensures recent insights outweigh stale patterns. The [formal model](docs/the-science.md) is straightforward: if retrieval rate × usage rate exceeds decay rate, knowledge compounds. If not, it decays to zero.\n\n<details>\n<summary><b>Phase details</b> — what each step does</summary>\n\n1. **`/research`** — Explores your codebase. Produces a research artifact with findings and recommendations.\n\n2. **`/plan`** — Decomposes the goal into issues with dependency waves. Derives scope boundaries and conformance checks. Creates a [beads](https://github.com/steveyegge/beads) epic (git-native issue tracking).\n\n3. **`/pre-mortem`** — Judges simulate failures before you write code, including a spec-completeness judge. FAIL? Re-plan with feedback (max 3 retries).\n\n4. **`/crank`** — Spawns parallel agents in dependency-ordered waves. Each worker gets fresh context. Lead validates and commits. Runs until every issue is closed. `--test-first` for spec-first TDD.\n\n5. **`/vibe`** — Judges validate the code. FAIL? Re-crank with failure context and re-vibe (max 3).\n\n6. **`/post-mortem`** — Council validates the implementation. Retro extracts learnings. **Suggests the next `/rpi` command.**\n\n`/rpi \"goal\"` runs all six end to end. Use `--interactive` for human gates at research and plan.\n\n</details>\n\n<details>\n<summary><b>Phased RPI</b> — fresh context per phase for larger goals</summary>\n\n`ao rpi phased \"goal\"` runs each phase in its own session — no context bleed between phases.\n\n```bash\nao rpi phased \"add rate limiting\"      # Hands-free, fresh context per phase\nao rpi phased \"add auth\" &             # Run multiple in parallel (auto-worktrees)\nao rpi phased --from=crank \"fix perf\"  # Resume from any phase\n```\n\nUse `/rpi` when context fits in one session. Use `ao rpi phased` when it doesn't.\n\n</details>\n\n<details>\n<summary><b>Goal-driven mode</b> — /evolve with GOALS.yaml</summary>\n\nBootstrap with `/goals generate` — it scans your repo (PRODUCT.md, README, skills, tests) and proposes mechanically verifiable goals. Or write them by hand:\n\n```yaml\n# GOALS.yaml\nversion: 1\ngoals:\n  - id: test-pass-rate\n    description: \"All tests pass\"\n    check: \"make test\"\n    weight: 10\n```\n\nThen `/evolve` measures them, picks the worst gap, runs `/rpi` to fix it, re-measures ALL goals (regressed commits auto-revert), and loops. It commits locally — you control when to push. Kill switch: `echo \"stop\" > ~/.config/evolve/KILL`\n\nMaintain over time: `/goals` shows pass/fail status, `/goals prune` finds stale or broken checks.\n\n</details>\n\n<details>\n<summary><b>References</b> — science, systems theory, prior art</summary>\n\nBuilt on [Darr 1995](docs/the-science.md) (decay rates), Sweller 1988 (cognitive load), [Liu et al. 2023](docs/the-science.md) (lost-in-the-middle), [MemRL 2025](https://arxiv.org/abs/2502.06173) (RL for memory).\n\nAgentOps concentrates on the high-leverage end of [Meadows' hierarchy](https://en.wikipedia.org/wiki/Twelve_leverage_points): information flows (#6), rules (#5), self-organization (#4), goals (#3). The bet: changing the loop beats tuning the output.\n\nDeep dive: [docs/how-it-works.md](docs/how-it-works.md) — Brownian Ratchet, Ralph Loops, agent backends, hooks, context windowing.\n\n</details>\n\n---\n\n## Skills\n\n43 skills: 33 user-facing, 10 internal (fire automatically). Each level composes the ones below it.\n\n| Scope | Skill | What it does |\n|-------|-------|-------------|\n| **Single review** | `/council` | Multiple judges (Claude + Codex) debate, surface disagreement, converge on a verdict. Customize with `--preset=security-audit`, `--perspectives=\"a,b,c\"`, or `--perspectives-file` |\n| **Single issue** | `/implement` | Full lifecycle for one task — research, plan, build, validate, learn |\n| **Multi-issue waves** | `/crank` | Parallel agents in dependency-ordered waves with fresh context per worker |\n| **Full lifecycle** | `/rpi` | Research → Plan → Pre-mortem → Crank → Vibe → Post-mortem — one command |\n| **Hands-free loop** | `/evolve` | Measures fitness goals, picks the worst gap, ships a fix, rolls back regressions, repeats |\n\n**Supporting skills:** `/research`, `/plan`, `/vibe`, `/pre-mortem`, `/post-mortem`, `/product`, `/goals`, `/readme`, `/status`, `/quickstart`, `/bug-hunt`, `/doc`, `/release`, `/knowledge`, `/handoff`\n\nFull reference: [docs/SKILLS.md](docs/SKILLS.md)\n\n<details>\n<summary><b>Cross-runtime orchestration</b> — mix Claude, Codex, OpenCode</summary>\n\nAgentOps orchestrates across runtimes. Claude can lead a team of Codex workers. Codex judges can review Claude's output.\n\n| Spawning Backend | How it works | Best for |\n|-----------------|-------------|----------|\n| **Native teams** | `TeamCreate` + `SendMessage` — built into Claude Code | Tight coordination, debate |\n| **Background tasks** | `Task(run_in_background=true)` — last-resort fallback | When no team APIs available |\n| **Codex sub-agents** | `/codex-team` — Claude orchestrates Codex workers | Cross-vendor validation |\n| **tmux + Agent Mail** | `/swarm --mode=distributed` — full process isolation | Long-running work, crash recovery |\n\n</details>\n\n---\n\n## How AgentOps Fits With Other Tools\n\nThese are fellow experiments in making coding agents work. Use pieces from any of them.\n\n| Alternative | What it does well | Where AgentOps focuses differently |\n|-------------|-------------------|-------------------------------------|\n| **[GSD](https://github.com/glittercowboy/get-shit-done)** | Clean subagent spawning, fights context rot | Cross-session memory (GSD keeps context fresh *within* a session; AgentOps carries knowledge *between* sessions) |\n| **[Compound Engineer](https://github.com/EveryInc/compound-engineering-plugin)** | Knowledge compounding, structured loop | Multi-model councils and validation gates — independent judges debating before and after code ships |\n\n[Detailed comparisons →](docs/comparisons/)\n\n---\n\n## The `ao` CLI\n\nOptional. The CLI is plumbing — skills and hooks call it automatically. Install via the [Full setup](#install) section above.\n\n**The killer feature:** run the full lifecycle from your terminal — no chat session required:\n```bash\nao rpi phased \"add rate limiting\"   # Spawns Claude, runs research → plan → ship → learn\nao rpi phased \"fix auth bug\" &      # Run multiple in parallel (auto-worktrees)\nao rpi phased --from=crank ag-058   # Resume from any phase\n```\nEach phase gets its own fresh context window. Walk away, come back to committed code + extracted learnings.\n\n**Other commands you'll use:**\n```bash\nao search \"query\"      # Search knowledge across files and chat history\nao demo                # Interactive demo\n```\n\nFull reference: [CLI Commands](cli/docs/COMMANDS.md)\n\n---\n\n## FAQ\n\n[docs/FAQ.md](docs/FAQ.md) — comparisons, limitations, subagent nesting, PRODUCT.md, uninstall.\n\n---\n\n<details>\n<summary><b>Built on</b> — Ralph Wiggum, Multiclaude, beads, CASS, MemRL</summary>\n\n[Ralph Wiggum](https://ghuntley.com/ralph/) (fresh context per agent) · [Multiclaude](https://github.com/dlorenc/multiclaude) (validation gates) · [beads](https://github.com/steveyegge/beads) (git-native issues) · [CASS](https://github.com/Dicklesworthstone/coding_agent_session_search) (session search) · [MemRL](https://arxiv.org/abs/2502.06173) (cross-session memory)\n\n</details>\n\n## Contributing\n\n<details>\n<summary><b>Issue tracking</b> — Beads / bd</summary>\n\nGit-native issues in `.beads/`. `bd onboard` (setup) · `bd ready` (find work) · `bd show <id>` · `bd close <id>` · `bd sync`. More: [AGENTS.md](AGENTS.md)\n\n</details>\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md). If AgentOps helped you ship something, post in [Discussions](https://github.com/boshu2/agentops?tab=discussions).\n\n## License\n\nApache-2.0 · [Docs](docs/INDEX.md) · [How It Works](docs/how-it-works.md) · [FAQ](docs/FAQ.md) · [Glossary](docs/GLOSSARY.md) · [Architecture](docs/ARCHITECTURE.md) · [CLI Reference](cli/docs/COMMANDS.md) · [Changelog](CHANGELOG.md)\n"
      },
      "plugins": [
        {
          "name": "agentops",
          "description": "The missing DevOps layer for coding agents. Flow, feedback, and memory that compounds between sessions.",
          "version": "2.10.1",
          "source": "./",
          "author": {
            "name": "Boden Fuller",
            "email": "fullerbt@users.noreply.github.com"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add boshu2/agentops",
            "/plugin install agentops@agentops-marketplace"
          ]
        }
      ]
    }
  ]
}