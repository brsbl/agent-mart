{
  "author": {
    "id": "jschulte",
    "display_name": "Jonah Schulte",
    "avatar_url": "https://avatars.githubusercontent.com/u/1323372?u=bc2e3a165b19c76b5088a6ea32b489ae9976e781&v=4"
  },
  "marketplaces": [
    {
      "name": "jschulte",
      "version": null,
      "description": "Developer tools and Claude Code plugins by Jonah Schulte",
      "repo_full_name": "jschulte/stackshift",
      "repo_url": "https://github.com/jschulte/stackshift",
      "repo_description": "üí´ Toolkit to help you transform your existing codebase into Github Spec Kit managed code, or rebuild it as a new spec-driven greenfield app.",
      "signals": {
        "stars": 3,
        "forks": 1,
        "pushed_at": "2026-02-12T17:35:10Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"jschulte\",\n  \"owner\": {\n    \"name\": \"Jonah Schulte\"\n  },\n  \"metadata\": {\n    \"description\": \"Developer tools and Claude Code plugins by Jonah Schulte\",\n    \"homepage\": \"https://github.com/jschulte\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"stackshift\",\n      \"version\": \"2.1.0\",\n      \"source\": \".\",\n      \"description\": \"Reverse engineering toolkit - shift gears between tech stacks or manage existing code with GitHub Spec Kit. Start in reverse (engineering), shift through 6 gears, cruise into spec-driven development. Dual workflow: Greenfield (extract business logic) or Brownfield (manage existing). Interactive skills with auto-activation.\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"stackshift\",\n  \"version\": \"2.1.0\",\n  \"description\": \"Reverse engineering toolkit with manual control ‚Äî shift gears in your codebase. Analyze, document, and spec-drive any project through a 6-gear process. Dual workflow: Greenfield (extract for rebuild) or Brownfield (manage existing). Includes BMAD synthesis, architecture generation, multi-repo reimagine, and incremental doc refresh.\",\n  \"author\": {\n    \"name\": \"Jonah Schulte\"\n  },\n  \"repository\": \"https://github.com/jschulte/stackshift\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"stackshift\",\n    \"reverse-engineering\",\n    \"specifications\",\n    \"spec-driven\",\n    \"github-spec-kit\",\n    \"migration\",\n    \"refactoring\",\n    \"greenfield\",\n    \"brownfield\",\n    \"monorepo\",\n    \"nx\",\n    \"turborepo\",\n    \"modernization\",\n    \"validation\",\n    \"code-review\",\n    \"ecosystem-discovery\"\n  ]\n}\n",
        "README.md": "<div align=\"center\">\n\n<img src=\"public/stackshift-logo.png\" alt=\"StackShift\" width=\"400\">\n\n**A reverse engineering toolkit that lets you shift gears in your codebase.**\n\nTransform any application into a fully-specified, spec-driven project with complete control - whether you're shifting to a new tech stack or taking the wheel on existing code.\n\n<p>\n  <a href=\"https://github.com/sponsors/jschulte\"><img src=\"https://img.shields.io/badge/Sponsor-GitHub-ea4aaa?style=for-the-badge&logo=github\" alt=\"GitHub Sponsors\"></a>\n  <a href=\"https://ko-fi.com/jschulte\"><img src=\"https://img.shields.io/badge/Support-Ko--fi-ff5e5b?style=for-the-badge&logo=ko-fi&logoColor=white\" alt=\"Ko-fi\"></a>\n</p>\n\n<p>\n  <a href=\"https://github.com/jschulte/stackshift/actions/workflows/ci.yml\"><img src=\"https://github.com/jschulte/stackshift/actions/workflows/ci.yml/badge.svg\" alt=\"CI Status\"></a>\n  <a href=\"https://github.com/jschulte/stackshift/blob/main/LICENSE\"><img src=\"https://img.shields.io/badge/License-MIT-blue.svg\" alt=\"License\"></a>\n  <img src=\"https://img.shields.io/badge/TypeScript-5.3.0-blue\" alt=\"TypeScript\">\n</p>\n\n</div>\n\n> **Two paths, two frameworks, complete control:**\n>\n> **üîÄ Greenfield:** Extract business logic from your legacy app, then rebuild in a modern stack using tech-agnostic specs.\n>\n> **‚öôÔ∏è Brownfield:** Transform your existing codebase into a spec-driven project for ongoing management.\n>\n> **üõ†Ô∏è Choose Your Implementation Framework:**\n> - **GitHub Spec Kit** - Feature specs in `.specify/`, task-driven workflow\n> - **BMAD Method** - Handoff to BMAD agents for collaborative artifact creation\n>\n> Start in reverse (engineering), shift through 6 gears, and cruise into spec-driven development!\n>\n> *Free and open source. [Support development](https://github.com/sponsors/jschulte) to keep the gears turning!* ‚òïüöó\n\n---\n\n## üìö Documentation\n\n- **[Quick Start](QUICKSTART.md)** - Get started in 5 minutes!\n- **[Installation Guide](docs/guides/INSTALLATION.md)** - Detailed installation for all platforms\n- **[Plugin Guide](docs/guides/PLUGIN_GUIDE.md)** - Claude Code plugin usage\n- **[Web Guide](web/README.md)** - Using in Claude Code Web (browser)\n- **[Batch Processing](scripts/BATCH_PROCESSING_GUIDE.md)** - Process multiple projects efficiently\n- **[Ecosystem Discovery](#-ecosystem-discovery)** - Auto-discover all related repos from a single starting point\n\n---\n\n## üéØ What StackShift Does\n\n**Reverse Engineering Meets Manual Control** - StackShift provides a **systematic, 6-gear process** to:\n\n0. **üó∫Ô∏è Pre-Gear:** Discover - Auto-discover the entire ecosystem from one repo *(optional)*\n1. **üîç First Gear:** Analyze - Detect tech stack and assess completeness\n2. **üîÑ Second Gear (Reverse!):** Reverse Engineer - Extract comprehensive documentation\n3. **üìã Third Gear:** Create Specifications - Transform into GitHub Spec Kit format\n4. **üîé Fourth Gear:** Gap Analysis - Identify what's missing or incomplete\n5. **‚ú® Fifth Gear:** Complete Specification - Resolve ambiguities and clarifications\n6. **üöÄ Sixth Gear:** Implement - Build features from specs!\n\n**Two Paths - Choose Your Route:**\n\n<!-- DIAGRAM: workflow-start -->\n### Workflow State Machine\n\n```mermaid\nstateDiagram-v2\n    [*] --> Discover: optional pre-step\n    [*] --> Analyze\n    Discover --> Batch: ecosystem map\n    Discover --> Reimagine: capability synthesis\n    Batch --> Analyze: per-repo\n    Analyze --> ReverseEngineer: Gear 2\n    ReverseEngineer --> CreateSpecs: Gear 3\n    CreateSpecs --> GapAnalysis: Gear 4\n    GapAnalysis --> CompleteSpec: Gear 5\n    CompleteSpec --> Implement: Gear 6\n    Analyze --> CruiseControl: auto mode\n    Implement --> [*]\n    CruiseControl --> [*]\n    Reimagine --> [*]\n```\n\n*Last generated: 2026-02-12*\n<!-- DIAGRAM: workflow-end -->\n\n\n### üîÄ Path A: Greenfield (Shift to New Stack)\n**Use when:** Rebuilding in a different tech stack or platform\n\n**Approach:** Extract business logic ONLY (tech-agnostic)\n- Focus on WHAT the system does, not HOW\n- Framework-agnostic specifications\n- Can implement in any technology\n- Perfect for platform migrations\n\n**Example:** \"Extract business logic from Rails app to rebuild in Next.js\"\n\n### ‚öôÔ∏è Path B: Brownfield (Take the Wheel on Existing Code)\n**Use when:** Managing existing codebase with GitHub Spec Kit\n\n**Approach:** Extract business logic + technical implementation (tech-prescriptive)\n- Document both WHAT and HOW\n- Capture exact tech stack, versions, file paths\n- Enables `/speckit.analyze` validation\n- Perfect for ongoing spec-driven development\n\n**Two Modes:**\n- **Standard**: Create specs for current state (as-is)\n- **Upgrade** üÜï: Create specs + upgrade all dependencies to latest versions\n\n**Example:** \"Add GitHub Spec Kit to existing Next.js app for spec-driven management\"\n**Example (Upgrade):** \"Spec this legacy app AND upgrade everything to modern versions\"\n\n**Result**: A fully-documented, specification-driven application ready for enterprise development.\n\n---\n\n## üöó 6-Gear Process\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                  Shift Through 6 Gears                       ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ                                                              ‚îÇ\n‚îÇ  Gear 1: Initial Analysis + Route + Framework Selection     ‚îÇ\n‚îÇ  ‚îú‚îÄ Detect technology stack                                 ‚îÇ\n‚îÇ  ‚îú‚îÄ Choose route: Greenfield or Brownfield?                 ‚îÇ\n‚îÇ  ‚îî‚îÄ Choose framework: GitHub Spec Kit or BMAD Method?       ‚îÇ\n‚îÇ         ‚îÇ                                                    ‚îÇ\n‚îÇ         ‚ñº                                                    ‚îÇ\n‚îÇ  Gear 2: Reverse Engineer (Reverse Gear!)                   ‚îÇ\n‚îÇ  ‚îú‚îÄ Extract business logic + tech details                   ‚îÇ\n‚îÇ  ‚îî‚îÄ Generate 9 docs to docs/reverse-engineering/ (BOTH)     ‚îÇ\n‚îÇ         ‚îÇ                                                    ‚îÇ\n‚îÇ         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ\n‚îÇ         ‚îÇ                 ‚îÇ                    ‚îÇ            ‚îÇ\n‚îÇ    Spec Kit           BMAD Method              ‚îÇ            ‚îÇ\n‚îÇ         ‚îÇ          (Skip to Gear 6)            ‚îÇ            ‚îÇ\n‚îÇ         ‚ñº                 ‚îÇ                    ‚îÇ            ‚îÇ\n‚îÇ  Gears 3-5: Spec Kit Path                     ‚îÇ            ‚îÇ\n‚îÇ  ‚îú‚îÄ Gear 3: Create .specify/ specs            ‚îÇ            ‚îÇ\n‚îÇ  ‚îú‚îÄ Gear 4: Gap analysis                      ‚îÇ            ‚îÇ\n‚îÇ  ‚îî‚îÄ Gear 5: Complete specification            ‚îÇ            ‚îÇ\n‚îÇ         ‚îÇ                 ‚îÇ                    ‚îÇ            ‚îÇ\n‚îÇ         ‚ñº                 ‚ñº                    ‚îÇ            ‚îÇ\n‚îÇ  Gear 6: Implement / Handoff                                ‚îÇ\n‚îÇ  ‚îú‚îÄ Spec Kit: /speckit.tasks & /speckit.implement           ‚îÇ\n‚îÇ  ‚îî‚îÄ BMAD: Handoff to *workflow-init (collaborative PRD)     ‚îÇ\n‚îÇ                                                              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## üöÄ Quick Start\n\n### Three Ways to Use StackShift\n\n#### Option 1: Claude Code Plugin (Local - Best Experience)\n\n**Recommended for:** Regular use, local development\n\nInstall as a Claude Code plugin for interactive skills and workflow tracking:\n\n```bash\n# In Claude Code\n> /plugin marketplace add jschulte/claude-plugins\n> /plugin install stackshift\n```\n\nRestart Claude Code. Skills will now be available:\n- `analyze` - Initial Analysis\n- `reverse-engineer` - Reverse Engineer\n- `create-specs` - Create Specifications\n- `gap-analysis` - Gap Analysis\n- `complete-spec` - Complete Specification\n- `implement` - Implement from Spec\n- `discover` - Ecosystem Discovery (find all related repos from one starting point)\n\n**Usage:**\n\nSkills auto-activate based on context, or invoke explicitly:\n\n```\n# Auto-activation\nUser: \"I need to reverse engineer this codebase\"\nClaude: [analyze skill activates automatically]\n\n# Explicit invocation\nJust ask naturally: \"Run initial analysis\" or \"Analyze this codebase\"\n```\n\n### Prerequisites\n\n- Claude Code with plugin support\n- Git repository with existing codebase\n- ~2-4 hours total time for complete process\n\n### Run the Process\n\n**With Plugin (Recommended):**\n\n```bash\n# Navigate to your project\ncd /path/to/your/project\n\n# Start Claude Code\n# Skills will guide you through the process automatically\n```\n\nSimply say: \"I want to reverse engineer this application\" and Claude will guide you through all 6 steps.\n\n**Initial Configuration:**\n\nStackShift will ask a few questions upfront:\n1. Route: Greenfield or Brownfield?\n2. Implementation Framework: GitHub Spec Kit or BMAD Method?\n3. Transmission: Manual or Cruise Control?\n4. (If Cruise Control + Spec Kit) Clarifications strategy & implementation scope\n5. (If Greenfield) Target tech stack\n\nAll answers saved to `.stackshift-state.json` - configure once, use throughout!\n\n**Without Plugin (Manual):**\n\nIf not using the plugin, use the web bootstrap for manual execution:\n\n```bash\n# 1. Clone StackShift\ngit clone https://github.com/jschulte/stackshift.git\n\n# 2. Use web bootstrap prompt\ncat web/WEB_BOOTSTRAP.md\n# Copy and paste into Claude.ai or Claude Code Web\n\n# Or use the legacy prompts (for reference):\ncat legacy/original-prompts/01-initial-analysis.md\n```\n\n**Recommended**: Use the web bootstrap or plugin for the best experience.\n\n#### Option 2: Claude Code Web (Browser - No Install!)\n\n**Recommended for:** Quick analysis, trying before installing, working on any device\n\n```bash\n# In Claude Code Web (https://claude.ai/code)\n1. Connect to your GitHub account\n2. Select your repo from the dropdown\n3. Copy-paste web/WEB_BOOTSTRAP.md\n4. Hit enter and shift through the gears! üöó\n```\n\nSee [`web/README.md`](web/README.md) for complete instructions.\n\n**Benefits:**\n- ‚òÅÔ∏è Works in browser (any device)\n- üöÄ No installation required\n- üîÑ Full cruise control support\n- üíæ Download specs when complete\n\n---\n\n## üîÄ Choose Your Route\n\n**StackShift asks this question in Gear 1 (Initial Analysis):**\n\n> Which path best aligns with your goals?\n>\n> **A) Greenfield:** Build new app based on business logic\n>    - Extract business requirements only (tech-agnostic)\n>    - Can implement in any stack\n>    - Focus: WHAT the system does\n>\n> **B) Brownfield:** Manage this app with Spec Kit\n>    - Extract business logic + technical details (prescriptive)\n>    - Manage existing codebase with specs\n>    - Focus: WHAT it does + HOW it's implemented\n\n### When to Choose Greenfield (Path A)\n\n**Perfect for:**\n- üîÑ **Platform migrations** - Rails ‚Üí Next.js, PHP ‚Üí Python, Monolith ‚Üí Microservices\n- üèóÔ∏è **Technology modernization** - Rebuild with modern stack\n- üì± **Cross-platform** - Web app ‚Üí Mobile app using same business logic\n- ‚ôªÔ∏è **Clean slate** - Start fresh with better architecture\n- üéØ **Team flexibility** - Let new team choose their preferred stack\n\n**Results in:**\n- Specifications that describe business requirements only\n- No framework or library mentions\n- Can be implemented in ANY technology\n- Example: \"User authentication with email/password\" (not \"JWT via passport.js\")\n\n### When to Choose Brownfield (Path B)\n\n**Perfect for:**\n- üìã **Spec-driven management** - Add GitHub Spec Kit to existing codebase\n- üîç **Validation** - Use `/speckit.analyze` to ensure specs match code\n- ‚¨ÜÔ∏è **Planned upgrades** - Manage framework/dependency upgrades via specs\n- üîß **Gradual refactoring** - Spec-driven modernization of existing app\n- üë• **Team onboarding** - Use prescriptive specs as documentation\n\n**Results in:**\n- Specifications that describe business requirements + exact implementation\n- Framework, library, version details included\n- `/speckit.analyze` validates code matches specs\n- Example: \"User authentication using JWT via jose 5.1.0, bcrypt 5.1.1, stored in httpOnly cookies\"\n\n### Path Comparison\n\n| Aspect | Greenfield (A) | Brownfield (B) |\n|--------|----------------|----------------|\n| **Focus** | WHAT only | WHAT + HOW |\n| **Tech Stack** | Any (your choice) | Current (documented) |\n| **Specifications** | Agnostic | Prescriptive |\n| **Implementation** | Build new | Manage existing |\n| **Flexibility** | High | Constrained to current stack |\n| **Validation** | Manual | Automated |\n| **Use Case** | Platform migration | Ongoing development |\n\n---\n\n## üõ†Ô∏è Implementation Framework Choice\n\nAfter choosing your route (Greenfield/Brownfield), StackShift asks which implementation framework to use:\n\n### GitHub Spec Kit (Recommended for most projects)\n\n**Output structure:**\n```\n.specify/\n‚îú‚îÄ‚îÄ memory/\n‚îÇ   ‚îú‚îÄ‚îÄ constitution.md      # Project principles\n‚îÇ   ‚îî‚îÄ‚îÄ [feature-name]/      # Per-feature specs\n‚îÇ       ‚îú‚îÄ‚îÄ spec.md\n‚îÇ       ‚îú‚îÄ‚îÄ plan.md\n‚îÇ       ‚îî‚îÄ‚îÄ tasks.md\n‚îî‚îÄ‚îÄ templates/               # Spec templates\n```\n\n**Workflow:**\n- `/speckit.specify` - Create feature specs\n- `/speckit.plan` - Create implementation plans\n- `/speckit.tasks` - Generate task lists\n- `/speckit.implement` - Execute implementation\n\n**Best for:** Most projects, task-driven development, smaller teams\n\n### BMAD Method (For larger/enterprise projects)\n\n**Output structure (same as Spec Kit):**\n```\ndocs/reverse-engineering/\n‚îú‚îÄ‚îÄ functional-specification.md   # Business logic, requirements\n‚îú‚îÄ‚îÄ integration-points.md         # External services, APIs\n‚îú‚îÄ‚îÄ configuration-reference.md    # All config options\n‚îú‚îÄ‚îÄ data-architecture.md          # Data models, API contracts\n‚îú‚îÄ‚îÄ operations-guide.md           # Deployment, infrastructure\n‚îú‚îÄ‚îÄ technical-debt-analysis.md    # Issues, improvements\n‚îú‚îÄ‚îÄ observability-requirements.md # Monitoring, logging\n‚îú‚îÄ‚îÄ visual-design-system.md       # UI/UX patterns\n‚îî‚îÄ‚îÄ test-documentation.md         # Testing requirements\n```\n\n**Workflow:**\n1. StackShift generates `docs/reverse-engineering/` (Gears 1-2) - same output as Spec Kit\n2. Gears 3-5 skipped (BMAD's agents handle PRD/Architecture collaboratively)\n3. Gear 6 hands off to BMAD's `*workflow-init` with rich context\n4. BMAD's PM and Architect agents create artifacts through conversation\n\n**Key difference:** StackShift provides the same reverse-engineering docs as input. BMAD's value is the **collaborative artifact creation** - PM agent discusses requirements with you, Architect agent discusses technical decisions with you. The PRD and Architecture emerge from conversation, not auto-generation.\n\n**Best for:** Large projects, enterprise teams, agent-driven workflows\n\n### Framework Comparison\n\n| Aspect | GitHub Spec Kit | BMAD Method |\n|--------|-----------------|-------------|\n| **Gear 2 Output** | Same 9 docs | Same 9 docs |\n| **Gears 3-5** | Create `.specify/` specs | Skipped (BMAD handles) |\n| **Gear 6** | `/speckit.implement` | Handoff to `*workflow-init` |\n| **Artifact Creation** | Automated from docs | Collaborative with BMAD agents |\n| **Best For** | Task-driven teams | Agent-driven enterprise teams |\n\n**Note:** StackShift's reverse engineering (Gear 2) replaces BMAD's Phase 0 (`document-project`) with deeper analysis. Both frameworks get the same rich context.\n\n---\n\n## üìÅ StackShift Structure\n\n### Plugin Structure\n\n```\nstackshift/\n‚îú‚îÄ‚îÄ .claude-plugin/       # Plugin metadata\n‚îú‚îÄ‚îÄ .claude/              # Settings and commands\n‚îÇ   ‚îú‚îÄ‚îÄ commands/         # Slash commands\n‚îÇ   ‚îî‚îÄ‚îÄ settings.json     # Plugin settings\n‚îú‚îÄ‚îÄ agents/               # Agent definitions\n‚îú‚îÄ‚îÄ docs/                 # Documentation\n‚îú‚îÄ‚îÄ public/               # Public assets\n‚îú‚îÄ‚îÄ scripts/              # Utility scripts\n‚îú‚îÄ‚îÄ skills/               # Skill definitions (6 gears + extras)\n‚îú‚îÄ‚îÄ web/                  # Web resources\n‚îú‚îÄ‚îÄ package.json          # Plugin metadata\n‚îî‚îÄ‚îÄ README.md\n```\n\n### Plugin Benefits\n\n**Why use the plugin over manual prompts?**\n\n‚úÖ **Auto-activation** - Skills activate based on context, no copy-paste needed\n‚úÖ **Progress tracking** - State management tracks where you are (which gear)\n‚úÖ **Resume capability** - Pick up where you left off if interrupted\n‚úÖ **Guided experience** - StackShift knows the full context and next steps\n‚úÖ **Templates included** - Access all templates without file operations\n‚úÖ **Updates** - Get improvements via plugin updates\n‚úÖ **Smooth shifting** - Seamless transitions between steps\n\n---\n\n## üìñ Detailed Process Guide\n\n### Step 1: Initial Analysis (5 minutes)\n\n**What it does:**\n- Detects programming language and framework\n- Identifies application type (web, mobile, API, etc.)\n- Maps directory structure\n- Finds configuration files\n- Estimates codebase size and completeness\n\n**Output:**\n- `analysis-report.md` with tech stack summary\n- Quick assessment of what exists\n\n**Plugin Skill:** `/stackshift:analyze`\n**Manual:** Use `web/WEB_BOOTSTRAP.md` (Gear 1)\n\n---\n\n### Step 2: Reverse Engineer (30 minutes)\n\n**What it does:**\n- Deep codebase analysis using specialized agents\n- Extracts all data models, API endpoints, components\n- Documents configuration, infrastructure, operations\n- Analyzes technical debt and test coverage\n- Generates 9 comprehensive documents\n\n**Output:**\n```\ndocs/reverse-engineering/\n‚îú‚îÄ‚îÄ functional-specification.md     (Business logic, requirements)\n‚îú‚îÄ‚îÄ integration-points.md           (External services, APIs, dependencies)\n‚îú‚îÄ‚îÄ configuration-reference.md      (All config options)\n‚îú‚îÄ‚îÄ data-architecture.md            (Data models, API contracts)\n‚îú‚îÄ‚îÄ operations-guide.md             (Deployment, infrastructure)\n‚îú‚îÄ‚îÄ technical-debt-analysis.md      (Issues, improvements)\n‚îú‚îÄ‚îÄ observability-requirements.md   (Monitoring, logging)\n‚îú‚îÄ‚îÄ visual-design-system.md         (UI/UX patterns)\n‚îî‚îÄ‚îÄ test-documentation.md           (Testing requirements)\n```\n\n**Plugin Skill:** `/stackshift:reverse-engineer`\n**Manual:** Use `web/WEB_BOOTSTRAP.md` (Gear 2)\n\n---\n\n### Step 3: Create Specifications (30 minutes)\n\n**What it does:**\n- Transforms reverse-eng docs into formal specifications\n- Creates feature specs (F001-F0XX format)\n- Marks implementation status (‚úÖ COMPLETE, ‚ö†Ô∏è PARTIAL, ‚ùå MISSING)\n- Generates OpenAPI specification for APIs\n- Creates JSON Schemas for data models\n- Sets up GitHub Spec Kit structure\n\n**Output:**\n```\nspecs/\n‚îú‚îÄ‚îÄ features/\n‚îÇ   ‚îú‚îÄ‚îÄ F001-user-authentication.md     (‚úÖ COMPLETE)\n‚îÇ   ‚îú‚îÄ‚îÄ F002-data-management.md         (‚ö†Ô∏è PARTIAL)\n‚îÇ   ‚îú‚îÄ‚îÄ F003-advanced-features.md       (‚ùå MISSING)\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îî‚îÄ‚îÄ openapi.yaml                    (Complete API spec)\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îî‚îÄ‚îÄ schemas/                        (JSON Schemas)\n‚îú‚îÄ‚îÄ implementation-status.md            (Gap summary)\n‚îî‚îÄ‚îÄ constitution.md                     (Project principles)\n```\n\n**Plugin Skill:** `/stackshift:create-specs`\n**Manual:** Use `web/WEB_BOOTSTRAP.md` (Gear 3)\n\n---\n\n### Step 4: Gap Analysis (15 minutes)\n\n**What it does:**\n- Compares specifications against implementation\n- Identifies incomplete features\n- Lists missing UI components\n- Highlights technical debt\n- Creates `[NEEDS CLARIFICATION]` markers for ambiguities\n- Generates prioritized gap list\n\n**Output:**\n```\nspecs/gap-analysis.md\n‚îú‚îÄ‚îÄ Missing Features (not started)\n‚îú‚îÄ‚îÄ Partial Features (backend done, UI missing)\n‚îú‚îÄ‚îÄ Technical Debt (needs improvement)\n‚îú‚îÄ‚îÄ Clarifications Needed (ambiguous requirements)\n‚îî‚îÄ‚îÄ Prioritized Implementation Plan\n```\n\n**Plugin Skill:** `/stackshift:gap-analysis`\n**Manual:** Use `web/WEB_BOOTSTRAP.md` (Gear 4)\n\n---\n\n### Step 5: Complete Specification (30-60 minutes, INTERACTIVE)\n\n**What it does:**\n- **Interactive conversation** to fill specification gaps\n- Claude asks clarifying questions about missing features\n- You provide details on UX, UI, behavior, priorities\n- Specifications updated with your answers\n- `[NEEDS CLARIFICATION]` markers resolved\n- Final, complete specification created\n\n**Example Questions:**\n- \"Analytics dashboard is missing - what charts do you want?\"\n- \"Should offline sync be priority P0 or P2?\"\n- \"For photo upload, drag-drop or click to browse?\"\n- \"Species input: free-text or autocomplete dropdown?\"\n\n**Output:**\n- Complete, unambiguous specifications\n- No `[NEEDS CLARIFICATION]` markers remaining\n- Clear implementation roadmap\n- Prioritized feature list\n\n**Plugin Skill:** `/stackshift:complete-spec`\n**Manual:** Use `web/WEB_BOOTSTRAP.md` (Gear 5)\n\n---\n\n### Step 6: Implement from Spec (Hours to Days)\n\n**What it does:**\n- Systematically implements missing features from specs\n- Works through prioritized list (P0 ‚Üí P1 ‚Üí P2)\n- Checks off items as completed\n- Validates implementation against specification\n- Achieves 100% completion\n\n**Approach:**\n```bash\n# For each missing feature:\n1. Review specification\n2. Implement according to spec\n3. Test against acceptance criteria\n4. Mark as complete\n5. Move to next feature\n```\n\n**Output:**\n- Fully implemented application\n- All specs marked ‚úÖ COMPLETE\n- Test coverage at target levels\n- Production-ready codebase\n\n**Plugin Skill:** `/stackshift:implement`\n**Manual:** Use `web/WEB_BOOTSTRAP.md` (Gear 6)\n\n---\n\n## üîÑ Adapting for Different Application Types\n\nThis toolkit works for:\n\n### Web Applications\n- Frontend frameworks: React, Vue, Angular, Svelte\n- Backend: Node.js, Python, Ruby, Go, Java\n- Databases: SQL, NoSQL, any data store\n\n### Mobile Applications\n- React Native, Flutter, Swift, Kotlin\n- Adapts documentation to mobile-specific patterns\n\n### APIs / Microservices\n- REST, GraphQL, gRPC\n- Generates OpenAPI/AsyncAPI specs\n- Documents service contracts\n\n### Monoliths\n- Breaks into logical modules\n- Creates specifications per domain\n- Identifies bounded contexts\n\n### Legacy Systems\n- Works even with minimal documentation\n- Infers behavior from code\n- Creates modernization roadmap\n\n---\n\n## Ecosystem Discovery\n\n**Start with one repo. Discover the entire platform.**\n\nWhen reverse-engineering a large system, the hardest part is figuring out *which repos matter*. The `discover` skill solves this:\n\n```\n/stackshift.discover\n```\n\n### How It Works\n\n```mermaid\nflowchart LR\n    A[Starting Repo] --> B[Scan 10 Signal Types]\n    B --> C{GitHub org detected?}\n    C -->|Yes| D[Search GitHub Org]\n    C -->|No| E[Skip]\n    D --> F[Scan Local Filesystem]\n    E --> F\n    F --> G[Merge & Score Confidence]\n    G --> H[Present Ecosystem Map]\n    H --> I{User confirms}\n    I -->|Add/Remove| H\n    I -->|Looks good| J{Next step?}\n    J --> K[\"/stackshift.batch\"]\n    J --> L[\"/stackshift.reimagine\"]\n    J --> M[Export map only]\n```\n\n### The Full Pipeline\n\n```mermaid\nflowchart TD\n    D[\"/stackshift.discover\"] -->|ecosystem map| B[\"/stackshift.batch\"]\n    D -->|ecosystem map| R[\"/stackshift.reimagine\"]\n    B -->|per repo| G1[\"Gear 1: Analyze\"]\n    G1 --> G2[\"Gear 2: Reverse Engineer\"]\n    G2 --> G3[\"Gear 3: Create Specs\"]\n    G3 --> G4[\"Gear 4: Gap Analysis\"]\n    G4 --> G5[\"Gear 5: Complete Spec\"]\n    G5 --> G6[\"Gear 6: Implement\"]\n    B -->|all docs| R\n    R --> V[\"Reimagined Vision + New Specs\"]\n```\n\n### 10 Signal Categories\n\n| # | Signal | Where It Looks | Example |\n|---|--------|---------------|---------|\n| 1 | Scoped npm packages | `package.json` | `@myorg/shared-utils` |\n| 2 | Docker Compose services | `docker-compose*.yml` | `depends_on: [auth-api]` |\n| 3 | Environment variables | `.env*`, config files | `USER_SERVICE_URL` |\n| 4 | API client calls | Source code | `fetch('http://auth-service')` |\n| 5 | Shared databases | Connection strings | Same DB in multiple configs |\n| 6 | CI/CD triggers | `.github/workflows/` | `repository_dispatch` |\n| 7 | Workspace configs | `pnpm-workspace.yaml`, `turbo.json`, `nx.json` | Monorepo packages |\n| 8 | Message queues | Source code, config | SQS queues, Kafka topics |\n| 9 | Infrastructure refs | `terraform/`, `k8s/` | Shared VPCs, ALBs |\n| 10 | Language-specific deps | `go.mod`, `requirements.txt` | `replace ../shared` |\n\n### Confidence Scoring\n\nEach discovered repo gets a confidence level:\n\n| Level | Meaning | Example |\n|-------|---------|---------|\n| **CONFIRMED** | User-listed or workspace config | Found in `pnpm-workspace.yaml` |\n| **HIGH** | 2+ independent signals | Docker Compose + env var + API call |\n| **MEDIUM** | 1 strong signal | Scoped npm package dep |\n| **LOW** | Naming pattern or GitHub search only | Repo name matches org convention |\n\n### Key Features\n\n- **Auto-detects GitHub org** from `git remote` (SSH and HTTPS, GitHub and GitLab)\n- **Monorepo-aware** ‚Äî workspace packages are auto-CONFIRMED, intra-monorepo deps mapped\n- **Seamless batch handoff** ‚Äî `/stackshift.batch` reads the discovered repo list automatically\n- **Graceful degradation** ‚Äî works without GitHub access (local scan only), handles rate limits\n- **Large ecosystem support** ‚Äî Mermaid diagrams auto-simplify for 20+ repos\n\n### Example Session\n\n```\nYou: /stackshift.discover\nStackShift: \"Auto-detected GitHub org: myorg (from git remote)\"\nStackShift: \"Scanning user-service for integration signals...\"\nStackShift: \"Found 12 related repos!\"\n\n  CONFIRMED: user-service, shared-utils, auth-service\n  HIGH:      inventory-api, notification-hub, billing-api, order-service\n  MEDIUM:    admin-dashboard, reporting-service, config-repo\n  LOW:       legacy-gateway, monitoring-stack\n\nStackShift: \"Does this look right? (add/remove/proceed)\"\nYou: \"Looks good, run batch\"\n‚Üí /stackshift.batch picks up the discovered repo list automatically\n‚Üí All 12 repos analyzed in parallel batches of 5\n```\n\n---\n\n## üìã Checklist: Is This Toolkit Right for You?\n\nUse this toolkit if:\n\n- ‚úÖ You have an existing codebase (partial or complete)\n- ‚úÖ Documentation is lacking or outdated\n- ‚úÖ You want to establish spec-driven development\n- ‚úÖ You need to understand what's implemented vs. missing\n- ‚úÖ You want a systematic approach to completion\n- ‚úÖ You're using AI coding agents (Claude Code, Copilot, etc.)\n\n**This toolkit is NOT for:**\n\n- ‚ùå Brand new projects (use GitHub Spec Kit from the start)\n- ‚ùå Throwaway prototypes\n- ‚ùå Applications you plan to completely rewrite\n\n---\n\n## üí° Best Practices\n\n### Before Starting\n\n1. **Commit current state** - Create a clean git state\n2. **Create a branch** - Don't work on main\n3. **Set aside time** - Steps 1-5 take ~2-4 hours\n4. **Have context ready** - Know your app's purpose and users\n\n### During Process\n\n1. **Follow prompts in order** - Each step builds on previous\n2. **Don't skip Step 5** - The interactive refinement is crucial\n3. **Be thorough with clarifications** - Vague specs = buggy implementations\n4. **Review generated specs** - Validate accuracy before implementing\n\n### After Completion\n\n1. **Keep specs updated** - Update specs when adding features\n2. **Use spec-driven workflow** - New features start with specs\n3. **Run periodically** - Re-run on major refactors or after acquisitions\n\n---\n\n## üõ†Ô∏è Troubleshooting\n\n### \"Claude can't find my configuration files\"\n- Make sure you're in the project root directory\n- Check that config files aren't gitignored\n- Explicitly mention unusual config locations\n\n### \"Generated specs are inaccurate\"\n- Step 5 is where you correct inaccuracies\n- Use `[NEEDS CLARIFICATION]` to mark uncertain areas\n- Review and refine before implementing\n\n### \"Too much output, can't process\"\n- Break large monoliths into modules\n- Run toolkit per module/microservice\n- Increase context window (use Claude Sonnet 4.5)\n\n### \"Missing important features in gap analysis\"\n- Manually add to `specs/features/`\n- Use templates in `templates/` folder\n- Re-run Step 4 with hints about what's missing\n\n---\n\n## üìà Success Metrics\n\nAfter running this toolkit, you should have:\n\n- ‚úÖ **100% documentation coverage** - Every feature documented\n- ‚úÖ **Clear implementation status** - Know exactly what exists\n- ‚úÖ **Formal specifications** - Unambiguous feature definitions\n- ‚úÖ **Identified gaps** - Complete list of missing pieces\n- ‚úÖ **Implementation roadmap** - Prioritized plan to completion\n- ‚úÖ **Spec-driven workflow** - Established for future development\n\n---\n\n## ü§ù Contributing\n\nThis toolkit is designed to be:\n- **Generic** - Works for any application\n- **Extensible** - Add your own prompts/templates\n- **Shareable** - Use across teams and organizations\n\nImprovements welcome:\n1. Fork this toolkit\n2. Add/improve prompts or templates\n3. Share back with community\n4. Help others achieve spec-driven development\n\n---\n\n## üìö Additional Resources\n\n- [GitHub Spec Kit](https://github.com/github/spec-kit) - Official spec-driven development toolkit\n- [OpenAPI Specification](https://swagger.io/specification/) - API specification standard\n- [JSON Schema](https://json-schema.org/) - Data validation standard\n- [Architecture Decision Records](https://adr.github.io/) - Document key decisions\n\n---\n\n## üìù License\n\nThis toolkit is provided as-is for use in any project. Adapt and modify as needed for your organization.\n\n---\n\n## ‚ùì Questions & Feedback\n\nThis toolkit was created to solve a real problem: **transforming partially-complete applications into fully-specified, enterprise-grade codebases**.\n\n**Encountered an issue or have a suggestion?**\n\n- üêõ **Found a bug?** [Open an issue](https://github.com/jschulte/stackshift/issues/new)\n- üí° **Have an idea?** [Start a discussion](https://github.com/jschulte/stackshift/discussions)\n- üîß **Want to contribute?** [Submit a pull request](https://github.com/jschulte/stackshift/pulls)\n\nThe toolkit improves with real-world usage and community feedback!\n\n---\n\n**Happy Shifting! üöóüí®**\n\n*Start in reverse (engineering), shift through 6 gears, cruise into spec-driven development.*\n"
      },
      "plugins": [
        {
          "name": "stackshift",
          "version": "2.1.0",
          "source": ".",
          "description": "Reverse engineering toolkit - shift gears between tech stacks or manage existing code with GitHub Spec Kit. Start in reverse (engineering), shift through 6 gears, cruise into spec-driven development. Dual workflow: Greenfield (extract business logic) or Brownfield (manage existing). Interactive skills with auto-activation.",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jschulte/stackshift",
            "/plugin install stackshift@jschulte"
          ]
        }
      ]
    }
  ]
}