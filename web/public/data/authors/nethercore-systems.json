{
  "author": {
    "id": "nethercore-systems",
    "display_name": "nethercore-systems",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/246801732?v=4",
    "url": "https://github.com/nethercore-systems",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 0,
      "total_skills": 8,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "nethercore-ai-plugins",
      "version": "1.0.0",
      "description": "AI plugins for Nethercore game development - platform tooling and ZX console reference",
      "owner_info": {
        "name": "Nethercore Systems"
      },
      "keywords": [],
      "repo_full_name": "nethercore-systems/nethercore-ai-plugins",
      "repo_url": "https://github.com/nethercore-systems/nethercore-ai-plugins",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-15T13:42:57Z",
        "created_at": "2025-12-27T10:38:13Z",
        "license": "Apache-2.0"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 867
        },
        {
          "path": "nethercore",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 447
        },
        {
          "path": "nethercore/README.md",
          "type": "blob",
          "size": 910
        },
        {
          "path": "nethercore/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/agents/build-analyzer.md",
          "type": "blob",
          "size": 1466
        },
        {
          "path": "nethercore/agents/replay-debugger.md",
          "type": "blob",
          "size": 1833
        },
        {
          "path": "nethercore/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/debugging/SKILL.md",
          "type": "blob",
          "size": 2576
        },
        {
          "path": "nethercore/skills/debugging/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/debugging/references/inspector-api.md",
          "type": "blob",
          "size": 3820
        },
        {
          "path": "nethercore/skills/development",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/development/SKILL.md",
          "type": "blob",
          "size": 3255
        },
        {
          "path": "nethercore/skills/development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/development/references/cli-commands.md",
          "type": "blob",
          "size": 992
        },
        {
          "path": "nethercore/skills/development/references/determinism-rules.md",
          "type": "blob",
          "size": 1644
        },
        {
          "path": "nethercore/skills/development/references/nether-toml.md",
          "type": "blob",
          "size": 1372
        },
        {
          "path": "nethercore/skills/optimization",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/optimization/SKILL.md",
          "type": "blob",
          "size": 1862
        },
        {
          "path": "nethercore/skills/optimization/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/optimization/references/optimization-techniques.md",
          "type": "blob",
          "size": 1997
        },
        {
          "path": "nethercore/skills/publishing",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/publishing/SKILL.md",
          "type": "blob",
          "size": 1778
        },
        {
          "path": "nethercore/skills/publishing/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/publishing/references/ci-workflows.md",
          "type": "blob",
          "size": 1758
        },
        {
          "path": "nethercore/skills/publishing/references/rom-packaging.md",
          "type": "blob",
          "size": 1046
        },
        {
          "path": "nethercore/skills/testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/testing/SKILL.md",
          "type": "blob",
          "size": 2492
        },
        {
          "path": "nethercore/skills/testing/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "nethercore/skills/testing/references/benchmarking.md",
          "type": "blob",
          "size": 831
        },
        {
          "path": "nethercore/skills/testing/references/replay-format.md",
          "type": "blob",
          "size": 1145
        },
        {
          "path": "zx",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 387
        },
        {
          "path": "zx/README.md",
          "type": "blob",
          "size": 984
        },
        {
          "path": "zx/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/skills/console-specs",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/skills/console-specs/SKILL.md",
          "type": "blob",
          "size": 1651
        },
        {
          "path": "zx/skills/console-specs/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/skills/console-specs/references/resource-budgets.md",
          "type": "blob",
          "size": 1457
        },
        {
          "path": "zx/skills/ffi-reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/skills/ffi-reference/SKILL.md",
          "type": "blob",
          "size": 2560
        },
        {
          "path": "zx/skills/ffi-reference/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/skills/ffi-reference/references/audio-api.md",
          "type": "blob",
          "size": 1397
        },
        {
          "path": "zx/skills/ffi-reference/references/input-api.md",
          "type": "blob",
          "size": 1992
        },
        {
          "path": "zx/skills/ffi-reference/references/render-api.md",
          "type": "blob",
          "size": 2023
        },
        {
          "path": "zx/skills/rendering",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/skills/rendering/SKILL.md",
          "type": "blob",
          "size": 2688
        },
        {
          "path": "zx/skills/rendering/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "zx/skills/rendering/references/2d-vs-3d.md",
          "type": "blob",
          "size": 4331
        },
        {
          "path": "zx/skills/rendering/references/camera-systems.md",
          "type": "blob",
          "size": 2353
        },
        {
          "path": "zx/skills/rendering/references/effects.md",
          "type": "blob",
          "size": 2119
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"nethercore-ai-plugins\",\n  \"version\": \"1.0.0\",\n  \"description\": \"AI plugins for Nethercore game development - platform tooling and ZX console reference\",\n  \"owner\": {\n    \"name\": \"Nethercore Systems\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"nethercore\",\n      \"description\": \"Platform tooling for Nethercore game development - build, test, optimize, publish\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Nethercore Systems\"\n      },\n      \"source\": \"./nethercore\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"zx\",\n      \"description\": \"ZX fantasy console FFI reference and specifications\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Nethercore Systems\"\n      },\n      \"source\": \"./zx\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "nethercore/.claude-plugin/plugin.json": "{\n  \"name\": \"nethercore\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Platform tooling for Nethercore game development - build, test, optimize, publish\",\n  \"author\": {\n    \"name\": \"Nethercore Systems\"\n  },\n  \"repository\": \"https://github.com/nethercore-systems/nethercore-ai-plugins\",\n  \"keywords\": [\n    \"nethercore\",\n    \"nether\",\n    \"build\",\n    \"test\",\n    \"optimize\",\n    \"publish\",\n    \"ci\",\n    \"determinism\",\n    \"rollback\",\n    \"wasm\"\n  ]\n}\n",
        "nethercore/README.md": "# Nethercore Plugin\n\nPlatform tooling for Nethercore game development. Console-agnostic - works with any Nethercore console.\n\n## Skills\n\n### development\nCore development workflow: nether CLI, nether.toml manifest, determinism rules.\n\n### testing\nTesting for determinism: sync testing, replay testing, benchmarking.\n\n### optimization\nSize optimization: WASM, textures, meshes, audio, state.\n\n### publishing\nRelease workflow: ROM packaging, platform upload, CI/CD automation.\n\n### debugging\nF4 Debug Inspector, live value editing, frame control (all consoles).\n\n## Agents\n\n### build-analyzer\nAnalyzes ROM builds to identify size optimization opportunities.\n\n### replay-debugger\nDebugs issues using replay files (NCRS format).\n\n## Quick Start\n\n```bash\n# Create new project\nnether init\n\n# Build and run\nnether build\nnether run\n\n# Test determinism\nnether run --sync-test\n\n# Release build\nnether build --release\n```\n",
        "nethercore/agents/build-analyzer.md": "---\nname: build-analyzer\ndescription: |\n  Use this agent to analyze ROM builds and identify size optimization opportunities.\n\n  <example>\n  Context: User has a game that's too large\n  user: \"My ROM is 18MB, I need to get it under 16MB\"\n  assistant: [Launches build-analyzer to analyze the build output and identify largest assets]\n  <commentary>\n  The agent will run nether build --verbose, parse the output, and identify the largest contributors to ROM size.\n  </commentary>\n  </example>\n\nmodel: haiku\ncolor: blue\ntools: [\"Bash\", \"Read\", \"Glob\", \"Grep\"]\n---\n\n# Build Analyzer\n\nYou analyze Nethercore ROM builds to identify size optimization opportunities.\n\n## Process\n\n1. Run `nether build --verbose` to get detailed build output\n2. Parse asset sizes from the output\n3. Identify largest contributors:\n   - WASM binary size\n   - Largest textures\n   - Largest meshes\n   - Audio files\n4. Compare against typical budgets:\n   - WASM: should be < 2 MB\n   - Total ROM: must be < 16 MB\n5. Suggest specific optimizations\n\n## Output Format\n\nProvide a breakdown table:\n\n| Asset | Size | % of ROM | Recommendation |\n|-------|------|----------|----------------|\n| ... | ... | ... | ... |\n\n## Optimization Suggestions\n\nFor each oversized asset, suggest:\n- Texture: reduce resolution, check if BC7 compression is working\n- Mesh: reduce poly count, remove unused vertex attributes\n- Audio: convert to mono, reduce sample rate, use XM for music\n- WASM: enable LTO, use wasm-opt -Oz\n",
        "nethercore/agents/replay-debugger.md": "---\nname: replay-debugger\ndescription: |\n  Use this agent to debug issues using replay files or to set up replay-based testing.\n\n  <example>\n  Context: User has a bug they want to reproduce\n  user: \"I have a replay file where my character falls through the floor, help me debug it\"\n  assistant: [Launches replay-debugger to analyze the replay and help identify the bug]\n  <commentary>\n  The agent will help set up replay playback and add logging to identify the issue.\n  </commentary>\n  </example>\n\nmodel: sonnet\ncolor: green\ntools: [\"Bash\", \"Read\", \"Edit\", \"Glob\", \"Grep\"]\n---\n\n# Replay Debugger\n\nYou help debug Nethercore games using replay files (NCRS format).\n\n## Capabilities\n\n1. **Replay playback**: Run replays to reproduce issues\n2. **Add logging**: Insert `log()` calls to track state\n3. **Identify frame**: Find the exact frame where issues occur\n4. **Root cause analysis**: Trace back to the source of bugs\n\n## Process\n\n1. Confirm replay file exists and is valid\n2. Run `nether run --replay <file>` to reproduce the issue\n3. If needed, add strategic `log()` calls:\n   ```rust\n   log(&format!(\"frame {} pos: {},{}\", tick_count(), x, y));\n   ```\n4. Narrow down to the specific frame/function\n5. Identify root cause\n\n## Common Issues\n\n- **Desync**: Replay diverges from recorded behavior\n  - Check for non-deterministic code\n  - Verify no external RNG\n  - Check HashMap usage\n\n- **Physics bugs**: Character falls through floor\n  - Check collision detection order\n  - Verify fixed-point math if used\n  - Check for floating-point accumulation\n\n- **State corruption**: Values become invalid\n  - Check array bounds\n  - Verify initialization\n  - Check for race conditions in state updates\n\n## Output\n\nProvide:\n1. Frame number where issue occurs\n2. Relevant state values at that frame\n3. Root cause identification\n4. Suggested fix\n",
        "nethercore/skills/debugging/SKILL.md": "---\nname: Nethercore Debugging\ndescription: |\n  Debug inspector and runtime debugging tools (all consoles). Triggers on \"debug\", \"F4 inspector\", \"debug_register\", \"debug panel\", \"live editing\", \"watch values\", \"frame stepping\", \"pause game\".\n\n  **Load references when:**\n  - Full debug API details -> `references/inspector-api.md`\nversion: 1.0.0\n---\n\n# Nethercore Debugging\n\nThe debug system is built into the Nethercore player and works with **all consoles**.\n\n## F4 Debug Inspector\n\nPress **F4** during development to open the Debug Inspector. This is your primary debugging tool.\n\n**Features:**\n- Live value editing (sliders, toggles, color pickers)\n- Read-only watches for monitoring\n- Grouped/collapsible organization\n- Frame control (pause, step, time scale)\n- Zero overhead in release builds\n\n## Quick Reference\n\n| Function | Purpose | Call In |\n|----------|---------|---------|\n| `debug_register_i32(name, ptr)` | Editable integer | `init()` |\n| `debug_register_f32(name, ptr)` | Editable float | `init()` |\n| `debug_register_bool(name, ptr)` | Toggle checkbox | `init()` |\n| `debug_register_vec3(name, ptr)` | 3D position | `init()` |\n| `debug_register_color(name, ptr)` | RGBA picker | `init()` |\n| `debug_watch_*(name, ptr)` | Read-only display | `init()` |\n| `debug_group_begin/end(name)` | Collapsible sections | `init()` |\n\n## Range-Constrained (Sliders)\n\n```rust\ndebug_register_f32_range(b\"Speed\".as_ptr(), 5, &SPEED, 0.0, 20.0);\ndebug_register_i32_range(b\"Lives\".as_ptr(), 5, &LIVES, 0, 10);\n```\n\n## Keyboard Shortcuts\n\n| Key | Action |\n|-----|--------|\n| **F4** | Toggle Debug Inspector |\n| F3 | Toggle Runtime Stats |\n| F5 | Pause/Resume |\n| F6 | Step one frame (when paused) |\n| F7/F8 | Decrease/Increase time scale |\n\n## Frame Control\n\n```rust\nfn update() {\n    if debug_is_paused() != 0 { return; }\n    let dt = delta_time() * debug_get_time_scale();\n    // ...\n}\n```\n\n## Typical Setup\n\n```rust\nstatic mut PLAYER_X: f32 = 0.0;\nstatic mut GRAVITY: f32 = 9.8;\nstatic mut GOD_MODE: u8 = 0;\n\nfn init() {\n    unsafe {\n        debug_group_begin(b\"Player\".as_ptr(), 6);\n        debug_watch_f32(b\"X\".as_ptr(), 1, &PLAYER_X);\n        debug_register_f32_range(b\"Gravity\".as_ptr(), 7, &GRAVITY, 1.0, 50.0);\n        debug_register_bool(b\"God Mode\".as_ptr(), 8, &GOD_MODE);\n        debug_group_end();\n    }\n}\n```\n\n## When to Use What\n\n| Scenario | Tool |\n|----------|------|\n| Live parameter tuning | Debug Inspector (F4) |\n| Tracking state over time | `log()` in `update()` |\n| Regression testing | Replay system |\n| Finding exact frame of bug | F5 pause + F6 step |\n",
        "nethercore/skills/debugging/references/inspector-api.md": "# Debug Inspector API\n\nThe debug inspector is a Nethercore player feature available to **all consoles**.\n\n## Overview\n\nTwo debugging systems work together:\n\n| System | Purpose | Best For |\n|--------|---------|----------|\n| **F4 Debug Inspector** | Live editing & monitoring | Human tweaking during play |\n| **log() + Replay assertions** | Programmatic debugging | Agentic test loops, CI |\n\n## F4 Debug Inspector\n\nPress **F4** during development. Zero overhead in release builds.\n\n### Registration Functions (call in init())\n\n| Function | Control Type | Example |\n|----------|--------------|---------|\n| `debug_register_i32(name, ptr)` | Numeric input | Enemy count |\n| `debug_register_f32(name, ptr)` | Numeric input | Gravity |\n| `debug_register_bool(name, ptr)` | Checkbox | God mode |\n| `debug_register_vec2(name, ptr)` | 2D input | Position |\n| `debug_register_vec3(name, ptr)` | 3D input | Camera target |\n| `debug_register_color(name, ptr)` | Color picker | Tint |\n| `debug_register_rect(name, ptr)` | 4-value input | Bounds |\n\n### Range-Constrained (Sliders)\n\n| Function | Example |\n|----------|---------|\n| `debug_register_i32_range(name, ptr, min, max)` | Lives 0-10 |\n| `debug_register_f32_range(name, ptr, min, max)` | Speed 0.0-20.0 |\n| `debug_register_u8_range(name, ptr, min, max)` | Level 1-255 |\n\n### Watch Functions (Read-Only)\n\nSame types as registration, but `debug_watch_*` instead of `debug_register_*`.\nUse for values you want to monitor but not edit (e.g., velocity, frame count).\n\n### Grouping\n\n```rust\ndebug_group_begin(b\"Player\".as_ptr(), 6);\ndebug_watch_f32(b\"X\".as_ptr(), 1, &PLAYER_X);\ndebug_register_f32(b\"Health\".as_ptr(), 6, &HEALTH);\ndebug_group_end();\n```\n\n### Frame Control\n\n```rust\nfn update() {\n    // Respect debug pause\n    if debug_is_paused() != 0 { return; }\n\n    // Respect time scale\n    let dt = delta_time() * debug_get_time_scale();\n}\n```\n\n### Fixed-Point Types\n\nFor deterministic math:\n- `debug_register_fixed_i16_q8`\n- `debug_register_fixed_i32_q8`\n- `debug_register_fixed_i32_q16`\n- `debug_register_fixed_i32_q24`\n\n---\n\n## Programmatic Debugging (Agentic Loop)\n\nFor AI-assisted debugging and CI, use `log()` + replay assertions:\n\n### log() Function\n\n```rust\nfn update() {\n    let msg = format!(\"frame {} pos: {},{}\", tick_count(), x, y);\n    log(msg.as_ptr(), msg.len() as u32);\n}\n```\n\nOutput captured when running `nether run` or `nether run --replay`.\n\n### Replay Assertions\n\n```toml\n[[frames]]\nf = 300\nassert = \"$player_x > 100\"\nsnap = true\n```\n\n### Debug Actions (Skip to Scenario)\n\nGames can register callable actions:\n\n```rust\n// In init()\ndebug_action_begin(b\"Load Level\".as_ptr(), 10, b\"debug_load_level\".as_ptr(), 16);\ndebug_action_param_i32(b\"level\".as_ptr(), 5, 1);\ndebug_action_end();\n```\n\nThen use in replay scripts:\n\n```toml\n[[frames]]\nf = 0\naction = \"Load Level\"\naction_params = { level = 3 }\n\n[[frames]]\nf = 1\nsnap = true\n```\n\n---\n\n## Full Agentic Test Loop\n\n1. **Create test**: Write `.ncrs` script with debug actions to set up scenario\n2. **Run**: `nether run --replay test.ncrs`\n3. **Observe**: Check log output and assertion results\n4. **Fix**: Modify code\n5. **Validate**: Re-run replay\n\n### Example Script (Bug Reproduction)\n\n```toml\nseed = 12345\nplayers = 1\n\n# Skip to problematic state\n[[frames]]\nf = 0\naction = \"Load Level\"\naction_params = { level = 2 }\n\n[[frames]]\nf = 0\naction = \"Set Player Health\"\naction_params = { health = 1 }\n\n# Start test\n[[frames]]\nf = 1\nsnap = true\n\n# Trigger the bug\n[[frames]]\nf = 60\np1 = \"right+a\"\n\n# Verify fix\n[[frames]]\nf = 120\nassert = \"$player_alive == 1\"\n```\n\n---\n\n## Keyboard Shortcuts\n\n| Key | Action |\n|-----|--------|\n| F3 | Toggle Runtime Stats Panel |\n| F4 | Toggle Debug Inspector |\n| F5 | Pause/unpause |\n| F6 | Step one frame (while paused) |\n| F7 | Decrease time scale |\n| F8 | Increase time scale |\n",
        "nethercore/skills/development/SKILL.md": "---\nname: Nethercore Development\ndescription: |\n  Core development workflow for Nethercore games. Triggers on \"nether build\", \"nether.toml\", \"asset handles\", \"determinism\", \"rollback rules\", \"WASM game\".\n\n  **Load references when:**\n  - Full nether.toml examples -> `references/nether-toml.md`\n  - CLI command details -> `references/cli-commands.md`\n  - Determinism patterns -> `references/determinism-rules.md`\nversion: 1.0.0\n---\n\n# Nethercore Development\n\n## Overview\n\nNethercore games compile to WASM and run in the Nethercore player with rollback netcode. All consoles share the same WASM core, ensuring determinism across platforms.\n\n## Required Game Exports\n\nEvery game exports three functions:\n\n```rust\n#[no_mangle] pub extern \"C\" fn init() { }   // Setup, asset loading\n#[no_mangle] pub extern \"C\" fn update() { } // Deterministic logic\n#[no_mangle] pub extern \"C\" fn render() { } // Drawing only\n```\n\n## nether CLI\n\n| Command | Purpose |\n|---------|---------|\n| `nether init` | Create nether.toml manifest |\n| `nether compile` | Compile WASM from source |\n| `nether pack` | Bundle WASM + assets into ROM |\n| `nether build` | compile + pack (main command) |\n| `nether run` | Build and launch in player |\n\n## Game Manifest (nether.toml)\n\n```toml\n[game]\nid = \"my-game\"\ntitle = \"My Game\"\nauthor = \"Your Name\"\nversion = \"1.0.0\"\n\n[build]\nscript = \"cargo build --target wasm32-unknown-unknown --release\"\nwasm = \"target/wasm32-unknown-unknown/release/my_game.wasm\"\n\n[[assets.textures]]\nid = \"player\"\npath = \"assets/player.png\"\n```\n\n## Netcode (What You DON'T Do)\n\nThe Nethercore player handles **all networking automatically**:\n- GGRS rollback synchronization\n- State snapshots\n- Input transmission\n- Desync detection\n\n**Your only responsibility:** Make `update()` deterministic.\n**Never write:** Networking code, rollback logic, state sync, or input transmission.\n\n## Determinism (Rollback Safety)\n\nThe `update()` function must be deterministic for rollback netcode. Given identical inputs, all clients must produce identical state.\n\n### Rules\n\n1. **All state in WASM memory** - Use static variables (auto-snapshotted)\n2. **Use FFI `random()` functions** - Never external randomness\n3. **Use `tick_count()` not system time** - Frame-based logic only\n4. **render() is display-only** - Never modify game state in render\n\n### Forbidden Patterns\n\n| Pattern | Problem | Correct Alternative |\n|---------|---------|---------------------|\n| `rand::thread_rng()` | External RNG | FFI `random()`, `random_range()` |\n| `SystemTime::now()` | System clock | FFI `tick_count()` |\n| `HashMap` iteration | Unordered | Arrays, `BTreeMap` |\n| State changes in render() | Skipped during rollback | Move to update() |\n\n### Quick Test\n\n```bash\nnether run --sync-test --frames 1000\n```\n\nIf this fails, you have non-deterministic code.\n\n## Project Structure\n\n```\nmy-game/\n├── nether.toml          # Game manifest\n├── src/\n│   ├── lib.rs           # Entry point (init/update/render)\n│   └── zx.rs            # FFI bindings (console-specific)\n├── assets/\n│   ├── textures/\n│   ├── meshes/\n│   └── audio/\n└── Cargo.toml\n```\n\n**Key principle:** Keep entry files minimal (~50 lines). FFI bindings in separate module.\n",
        "nethercore/skills/development/references/cli-commands.md": "# nether CLI Commands\n\n## Build Commands\n\n| Command | Purpose |\n|---------|---------|\n| `nether init` | Create new nether.toml in current directory |\n| `nether compile` | Compile WASM from source (runs build.script) |\n| `nether pack` | Bundle WASM + assets into ROM |\n| `nether build` | compile + pack combined |\n| `nether build --release` | Optimized release build |\n| `nether build --verbose` | Show detailed build output |\n\n## Run Commands\n\n| Command | Purpose |\n|---------|---------|\n| `nether run` | Build and launch in player |\n| `nether run --sync-test` | Run determinism verification |\n| `nether run --sync-test --frames N` | Test N frames |\n| `nether run --record FILE` | Record replay |\n| `nether run --replay FILE` | Playback replay |\n\n## Examples\n\n```bash\n# Development cycle\nnether build\nnether run\n\n# Release build\nnether build --release\n\n# Test determinism\nnether run --sync-test --frames 3000\n\n# Record and replay\nnether run --record test.bin\nnether run --replay test.bin\n```\n",
        "nethercore/skills/development/references/determinism-rules.md": "# Determinism Rules\n\n## Core Requirement\n\nThe `update()` function must be **deterministic** for GGRS rollback netcode. Given identical inputs, all clients must produce identical state.\n\n## Rules\n\n1. **All state in WASM memory** - Use static variables (auto-snapshotted)\n2. **Use FFI `random()` functions** - Never external randomness\n3. **Use `tick_count()` not system time** - Frame-based logic only\n4. **render() is display-only** - Never modify game state in render\n\n## Forbidden Patterns\n\n| Pattern | Problem | Correct Alternative |\n|---------|---------|---------------------|\n| `rand::thread_rng()` | External RNG | FFI `random()`, `random_range()` |\n| `SystemTime::now()` | System clock | FFI `elapsed_time()`, `tick_count()` |\n| `HashMap` iteration | Unordered | Arrays, `BTreeMap` |\n| State changes in render() | Skipped during rollback | Move to update() |\n| File I/O in update() | Non-deterministic | Load in init() |\n\n## Allowed in update()\n\n- FFI `random()`, `random_range()`, `random_f32()`\n- FFI `delta_time()`, `elapsed_time()`, `tick_count()`\n- FFI `button_pressed()`, `left_stick_x()` (input)\n- Static variable mutations\n- Array/BTreeMap with consistent iteration\n\n## Allowed in render() Only\n\n- All `draw_*` functions\n- `camera_set()`, `camera_fov()`\n- `push_translate()`, `push_rotate_y()`, `push_scale()`\n- `texture_bind()`, `font_bind()`\n- Reading (not writing) game state\n\n## Testing\n\n```bash\n# Quick test\nnether run --sync-test\n\n# Extended test\nnether run --sync-test --frames 3000\n```\n\nIf sync test fails, search for:\n1. Non-deterministic RNG\n2. HashMap/HashSet usage\n3. System time reads\n4. State mutations in render()\n",
        "nethercore/skills/development/references/nether-toml.md": "# nether.toml Reference\n\n## Full Example\n\n```toml\n[game]\nid = \"space-fighter\"\ntitle = \"Space Fighter\"\nauthor = \"Your Name\"\nversion = \"1.0.0\"\ndescription = \"A space combat game\"\ntags = [\"arcade\", \"shooter\", \"multiplayer\"]\n\n[build]\nscript = \"cargo build --target wasm32-unknown-unknown --release\"\nwasm = \"target/wasm32-unknown-unknown/release/space_fighter.wasm\"\n\n# Textures - auto-compressed to BC7\n[[assets.textures]]\nid = \"player_ship\"\npath = \"assets/textures/player.png\"\n\n[[assets.textures]]\nid = \"enemy_ship\"\npath = \"assets/textures/enemy.png\"\n\n[[assets.textures]]\nid = \"bullet\"\npath = \"assets/textures/bullet.png\"\n\n# Meshes - GLB/GLTF format\n[[assets.meshes]]\nid = \"ship_model\"\npath = \"assets/meshes/ship.glb\"\n\n# Audio - 22050Hz mono WAV\n[[assets.sounds]]\nid = \"laser\"\npath = \"assets/audio/laser.wav\"\n\n[[assets.sounds]]\nid = \"explosion\"\npath = \"assets/audio/explosion.wav\"\n\n# Music - XM/IT tracker format\n[[assets.music]]\nid = \"battle_theme\"\npath = \"assets/music/battle.xm\"\n```\n\n## Asset Handle Usage\n\nIn code, use `rom_*_str()` to get handles:\n\n```rust\nlet tex = rom_texture_str(\"player_ship\");\nlet mesh = rom_mesh_str(\"ship_model\");\nlet sfx = rom_sound_str(\"laser\");\nlet music = rom_music_str(\"battle_theme\");\n```\n\n## Asset Path Conventions\n\n- Textures: PNG (auto-compressed to BC7)\n- Meshes: GLB or GLTF\n- Audio: WAV (22050Hz mono)\n- Music: XM or IT tracker format\n",
        "nethercore/skills/optimization/SKILL.md": "---\nname: Nethercore Optimization\ndescription: |\n  Optimization techniques for Nethercore games. Triggers on \"optimize\", \"reduce size\", \"wasm-opt\", \"compress\", \"LTO\", \"asset compression\", \"state size\".\n\n  **Load references when:**\n  - Detailed techniques -> `references/optimization-techniques.md`\nversion: 1.0.0\n---\n\n# Nethercore Optimization\n\n## WASM Optimization\n\n### Cargo.toml Settings\n\n```toml\n[profile.release]\nlto = true           # Link-time optimization\nopt-level = \"z\"      # Optimize for size\ncodegen-units = 1    # Better optimization\npanic = \"abort\"      # Smaller than unwind\nstrip = true         # Strip symbols\n```\n\n### Post-Build\n\n```bash\nwasm-opt -Oz game.wasm -o game.wasm\n```\n\n**Typical savings:** 20-40%\n\n## Texture Optimization\n\nAll textures use BC7 compression (4:1 ratio):\n\n| Original | Compressed |\n|----------|------------|\n| 256x256 RGBA (256 KB) | 64 KB |\n| 512x512 RGBA (1 MB) | 256 KB |\n\n**Resolution targets:**\n- UI elements: 256x256\n- Characters: 256-512\n- Environment: 128-256\n\n## Mesh Optimization\n\n| Format | Size/Vertex |\n|--------|-------------|\n| Position only | 12 bytes |\n| Pos + UV | 20 bytes |\n| Pos + UV + Normal | 32 bytes |\n| Full | 40 bytes |\n\n**Poly targets:**\n- Background props: 50-200\n- Interactive props: 100-500\n- Characters: 500-2000\n\n## Audio Optimization\n\n- Sample rate: 22050 Hz (engine limit)\n- Channels: Mono only\n- Use XM modules for music (95% savings vs WAV)\n\n## State Size Reduction\n\n```rust\n// Use compact types\nstruct Position { x: f32, y: f32 }  // 8 bytes\nstruct Position { x: i16, y: i16 }  // 4 bytes (fixed-point)\n\n// Fixed arrays, not Vec\nentities: [Entity; 64],  // Known size\n```\n\n## Quick Wins Checklist\n\n- [ ] LTO and opt-level = \"z\" in Cargo.toml\n- [ ] wasm-opt -Oz on final binary\n- [ ] Texture resolutions at 256x256 default\n- [ ] Music as XM format\n- [ ] Fixed arrays instead of Vec\n",
        "nethercore/skills/optimization/references/optimization-techniques.md": "# Optimization Techniques\n\n## WASM Size Reduction\n\n### Cargo Settings (Full)\n\n```toml\n[profile.release]\nlto = true\nopt-level = \"z\"\ncodegen-units = 1\npanic = \"abort\"\nstrip = true\n\n[profile.release.package.\"*\"]\nopt-level = \"z\"\n```\n\n### Post-Processing\n\n```bash\n# Install wasm-opt\ncargo install wasm-opt\n\n# Optimize binary\nwasm-opt -Oz target/wasm32-unknown-unknown/release/game.wasm -o game_opt.wasm\n\n# Compare sizes\nls -la game.wasm game_opt.wasm\n```\n\n### Code Size Tips\n\n- Avoid `format!()` and string formatting\n- Use `#[inline(never)]` on cold paths\n- Minimize generic instantiations\n- Prefer `core` over `std` where possible\n\n## Texture Optimization\n\n### Size Calculation\n\n```\nCompressed size = width * height * 0.5 bytes (BC7)\n```\n\n### Resolution Guidelines\n\n| Asset Type | Max Resolution | Typical |\n|------------|---------------|---------|\n| UI icons | 64x64 | 32x32 |\n| Character | 512x512 | 256x256 |\n| Environment | 256x256 | 128x128 |\n| Skybox | 512x512 | 256x256 |\n\n### Texture Atlas\n\nCombine small textures into atlas:\n- Reduces draw calls\n- Better cache utilization\n- Single load operation\n\n## State Optimization\n\n### Compact Data Types\n\n```rust\n// Before: 24 bytes per entity\nstruct Entity {\n    x: f64,      // 8 bytes\n    y: f64,      // 8 bytes\n    health: i32, // 4 bytes\n    _pad: i32,   // 4 bytes\n}\n\n// After: 8 bytes per entity\nstruct Entity {\n    x: i16,      // 2 bytes (fixed-point)\n    y: i16,      // 2 bytes\n    health: u16, // 2 bytes\n    flags: u16,  // 2 bytes\n}\n```\n\n### Fixed Arrays\n\n```rust\n// Bad: Vec allocates on heap, size varies\nentities: Vec<Entity>,\n\n// Good: Fixed size, predictable snapshot\nentities: [Entity; MAX_ENTITIES],\nactive_count: u16,\n```\n\n## Audio Optimization\n\n### Format Comparison\n\n| Format | Size per second |\n|--------|----------------|\n| WAV 44.1kHz stereo | 176 KB |\n| WAV 22kHz mono | 44 KB |\n| XM module | 5-20 KB |\n\n### Music Strategy\n\nUse XM/IT tracker format for music:\n- 95%+ size savings\n- Procedural variation\n- Looping built-in\n",
        "nethercore/skills/publishing/SKILL.md": "---\nname: Nethercore Publishing\ndescription: |\n  Publishing Nethercore games. Triggers on \"publish game\", \"release\", \"upload\", \"ROM packaging\", \"nether pack\", \"CI/CD\", \"GitHub Actions\".\n\n  **Load references when:**\n  - ROM packaging details -> `references/rom-packaging.md`\n  - CI workflow templates -> `references/ci-workflows.md`\nversion: 1.0.0\n---\n\n# Nethercore Publishing\n\n## Build Commands\n\n| Command | Purpose |\n|---------|---------|\n| `nether build` | compile + pack (development) |\n| `nether build --release` | Optimized release build |\n| `nether pack` | Bundle WASM + assets into ROM |\n\n## Upload to nethercore.systems\n\n**Required:**\n| File | Format |\n|------|--------|\n| Game | `.wasm` or `.nczx` |\n| Icon | 64x64 PNG |\n\n**Optional:**\n- Screenshots (PNG, up to 5)\n- Banner (1280x720 PNG)\n\n**Process:**\n1. Create account at nethercore.systems\n2. Dashboard -> \"Upload New Game\"\n3. Fill metadata, upload files\n4. Publish\n\n## Pre-Release Checklist\n\n- [ ] `nether build --release` succeeds\n- [ ] `nether run --sync-test` passes\n- [ ] ROM under 16MB\n- [ ] Icon is 64x64 PNG\n- [ ] Description is compelling\n- [ ] Version updated in nether.toml\n\n## Versioning\n\nSemantic versioning in `nether.toml`:\n\n```toml\n[game]\nversion = \"1.2.3\"\n```\n\n**Update process:**\n1. Bump version in nether.toml\n2. Update CHANGELOG.md\n3. Commit, tag, push\n4. Re-upload to platform\n\n## CI/CD Quick Reference\n\n| Gate | Command | Purpose |\n|------|---------|---------|\n| Format | `cargo fmt --check` | Code style |\n| Lint | `cargo clippy -- -D warnings` | Static analysis |\n| Test | `cargo test` | Logic correctness |\n| Build | `nether build --release` | WASM compilation |\n| Sync | `nether run --sync-test --frames 1000` | Determinism |\n\nSee `references/ci-workflows.md` for GitHub Actions templates.\n",
        "nethercore/skills/publishing/references/ci-workflows.md": "# CI Workflow Templates\n\n## Basic Build Workflow\n\n`.github/workflows/build.yml`:\n\n```yaml\nname: Build\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: dtolnay/rust-action@stable\n        with:\n          targets: wasm32-unknown-unknown\n\n      - name: Install nether CLI\n        run: cargo install nether-cli\n\n      - name: Format check\n        run: cargo fmt --check\n\n      - name: Lint\n        run: cargo clippy -- -D warnings\n\n      - name: Test\n        run: cargo test\n\n      - name: Build\n        run: nether build --release\n\n      - name: Sync test\n        run: nether run --sync-test --frames 1000\n```\n\n## Release Workflow\n\n`.github/workflows/release.yml`:\n\n```yaml\nname: Release\n\non:\n  push:\n    tags: ['v*']\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: dtolnay/rust-action@stable\n        with:\n          targets: wasm32-unknown-unknown\n\n      - name: Install tools\n        run: |\n          cargo install nether-cli\n          cargo install wasm-opt\n\n      - name: Build release\n        run: |\n          nether build --release\n          wasm-opt -Oz game.wasm -o game.wasm\n\n      - name: Create release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: |\n            game.nczx\n            CHANGELOG.md\n```\n\n## Quality Gates\n\nRun in order for best results:\n\n1. `cargo fmt --check` - Fast, catches style issues\n2. `cargo clippy -- -D warnings` - Catches common bugs\n3. `cargo test` - Unit tests\n4. `nether build --release` - Full build\n5. `nether run --sync-test` - Determinism verification\n",
        "nethercore/skills/publishing/references/rom-packaging.md": "# ROM Packaging\n\n## Package Contents\n\nA Nethercore ROM (`.nczx`) contains:\n- Compiled WASM binary\n- Packed assets (textures, meshes, audio)\n- Game manifest metadata\n\n## Build Process\n\n```bash\n# Development build\nnether build\n\n# Release build (optimized)\nnether build --release\n\n# Just pack (skip compile)\nnether pack\n```\n\n## Release Optimization\n\nFor release builds:\n\n1. **Cargo optimization**:\n   ```toml\n   [profile.release]\n   lto = true\n   opt-level = \"z\"\n   ```\n\n2. **Post-process WASM**:\n   ```bash\n   wasm-opt -Oz game.wasm -o game.wasm\n   ```\n\n3. **Verify size**:\n   ```bash\n   nether build --verbose\n   # Check total ROM size < 16 MB\n   ```\n\n## Platform Assets\n\nFor nethercore.systems upload:\n\n| Asset | Size | Format |\n|-------|------|--------|\n| Icon | 64x64 | PNG |\n| Screenshot | 960x540 | PNG |\n| Banner | 1280x720 | PNG |\n\n## Manifest Example\n\n```toml\n[game]\nid = \"my-game\"\ntitle = \"My Game\"\nauthor = \"Developer Name\"\nversion = \"1.0.0\"\ndescription = \"A brief, compelling description\"\ntags = [\"action\", \"multiplayer\", \"arcade\"]\n```\n",
        "nethercore/skills/testing/SKILL.md": "---\nname: Nethercore Testing\ndescription: |\n  Testing Nethercore games for determinism and correctness. Triggers on \"sync test\", \"replay test\", \"determinism test\", \"desync\", \"checksums\", \"test my game\".\n\n  **Load references when:**\n  - Replay format details -> `references/replay-format.md`\n  - Performance benchmarking -> `references/benchmarking.md`\nversion: 1.0.0\n---\n\n# Nethercore Testing\n\n## Sync Testing\n\nRuns two identical instances, compares checksums each frame.\n\n```bash\nnether run --sync-test\nnether run --sync-test --frames 3000  # Specific duration\n```\n\n**Pass criteria:** Identical checksums for 1000+ frames.\n\n## Replay Testing\n\nRecord and replay for regression testing:\n\n```bash\nnether run --record replay.bin  # Record\nnether run --replay replay.bin  # Playback\n```\n\n**Workflow:**\n1. Record on known-good build\n2. Replay on new build\n3. Compare outcomes\n\n## Determinism Rules\n\n| Do | Don't |\n|---|---|\n| `random()` FFI | `rand::thread_rng()` |\n| `BTreeMap`, `BTreeSet` | `HashMap`, `HashSet` |\n| Frame counter | `Instant::now()` |\n| Fixed-point math | Floating-point accumulation |\n\n## Test Organization\n\n| Type | Tool | Purpose |\n|------|------|---------|\n| Unit | `cargo test` | Pure logic |\n| Sync | `nether run --sync-test` | Runtime determinism |\n| Replay | `--record`/`--replay` | Cross-build validation |\n\n## Common Desync Causes\n\n1. **Non-deterministic RNG** - Using rand crate instead of FFI\n2. **HashMap iteration** - Order varies between runs\n3. **System time** - Reading wall clock\n4. **Uninitialized memory** - Undefined values\n5. **State in render()** - Skipped during rollback\n\n## Debugging Desyncs\n\n1. Run sync test to confirm failure\n2. Add `log()` calls around suspicious code\n3. Check for forbidden patterns\n4. Verify all state is in static variables\n\n## Debug Actions (Efficient Testing)\n\nInstead of recording long input sequences, use debug actions to skip directly to test scenarios:\n\n```toml\n# Skip to level 3 boss\n[[frames]]\nf = 0\naction = \"Load Level\"\naction_params = { level = 3 }\n\n[[frames]]\nf = 1\nsnap = true\nassert = \"$boss_health > 0\"\n```\n\nGames register actions in `init()`:\n\n```rust\ndebug_action_begin(b\"Load Level\".as_ptr(), 10, b\"debug_load_level\".as_ptr(), 16);\ndebug_action_param_i32(b\"level\".as_ptr(), 5, 1);\ndebug_action_end();\n```\n\n**When to use:**\n- Testing specific levels without playing through earlier ones\n- Setting up edge-case scenarios (low health, specific enemy spawns)\n- Regression tests that need consistent starting state\n",
        "nethercore/skills/testing/references/benchmarking.md": "# Benchmarking\n\n## State Snapshot Performance\n\nFor rollback netcode, state snapshot size affects performance:\n\n| Size | Frame Budget | Status |\n|------|--------------|--------|\n| < 50 KB | < 1ms | Excellent |\n| 50-100 KB | 1-2ms | Good |\n| 100-200 KB | 2-4ms | Acceptable |\n| > 200 KB | > 4ms | **Optimize** |\n\n## Build Analysis\n\n```bash\nnether build --verbose\n```\n\nShows:\n- WASM binary size\n- Asset pack size\n- Individual asset sizes\n\n## Performance Checklist\n\n- [ ] State snapshot under 200 KB\n- [ ] WASM binary under 2 MB\n- [ ] Total ROM under 16 MB\n- [ ] Sync test passes at 60fps\n- [ ] No frame drops during gameplay\n\n## Profiling Tips\n\n1. **Measure state size**: Log size of your game state struct\n2. **Track frame time**: Use `delta_time()` to detect spikes\n3. **Asset audit**: Check largest textures/meshes in build output\n",
        "nethercore/skills/testing/references/replay-format.md": "# Replay Format (NCRS)\n\n## Overview\n\nNethercore replays use the NCRS format to record input sequences for deterministic playback.\n\n## Recording\n\n```bash\nnether run --record my_replay.bin\n```\n\nRecords:\n- Initial random seed\n- Frame-by-frame input state\n- Player configurations\n\n## Playback\n\n```bash\nnether run --replay my_replay.bin\n```\n\nReplays inputs exactly, producing identical game state if code is deterministic.\n\n## Regression Testing Workflow\n\n1. **Record golden replay** on known-good build:\n   ```bash\n   git checkout v1.0.0\n   nether run --record golden.bin\n   # Play through test scenario\n   ```\n\n2. **Test new build** against golden replay:\n   ```bash\n   git checkout feature-branch\n   nether run --replay golden.bin\n   # Should produce identical results\n   ```\n\n3. **Automate in CI**:\n   ```yaml\n   - name: Replay regression\n     run: nether run --replay tests/golden.bin --frames 1000\n   ```\n\n## Debug Replay\n\nFor debugging specific issues:\n\n```bash\n# Record bug reproduction\nnether run --record bug_repro.bin\n# Play until bug manifests\n\n# Replay to debug\nnether run --replay bug_repro.bin\n# Add logging, breakpoints as needed\n```\n",
        "zx/.claude-plugin/plugin.json": "{\n  \"name\": \"zx\",\n  \"version\": \"1.0.0\",\n  \"description\": \"ZX fantasy console FFI reference and specifications\",\n  \"author\": {\n    \"name\": \"Nethercore Systems\"\n  },\n  \"repository\": \"https://github.com/nethercore-systems/nethercore-ai-plugins\",\n  \"keywords\": [\n    \"zx\",\n    \"nethercore\",\n    \"ffi\",\n    \"console\",\n    \"fantasy-console\",\n    \"rendering\",\n    \"camera\",\n    \"stencil\"\n  ]\n}\n",
        "zx/README.md": "# ZX Plugin\n\nZX fantasy console FFI reference and specifications. Console-specific knowledge for the ZX platform.\n\n## Skills\n\n### ffi-reference\nZX FFI bindings: rendering, input, audio, transforms. Reference for 250+ functions.\n\n### console-specs\nHardware specifications: resolution, memory limits, render modes, audio system.\n\n### rendering\nRendering techniques: cameras, stencil effects, particles, custom fonts, 2D vs 3D.\n\n## ZX Specifications\n\n| Spec | Value |\n|------|-------|\n| Resolution | 960x540 |\n| ROM | 16 MB |\n| RAM | 4 MB |\n| VRAM | 4 MB |\n| Players | 1-4 |\n\n## Quick Reference\n\n```rust\n// Required exports\n#[no_mangle] pub extern \"C\" fn init() { }\n#[no_mangle] pub extern \"C\" fn update() { }\n#[no_mangle] pub extern \"C\" fn render() { }\n\n// Asset loading (in init)\nlet tex = rom_texture_str(\"player\");\nlet mesh = rom_mesh_str(\"character\");\n\n// Drawing (in render)\ncamera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);\npush_translate(x, y, z);\ndraw_mesh(mesh);\npush_identity();\n```\n",
        "zx/skills/console-specs/SKILL.md": "---\nname: ZX Console Specs\ndescription: |\n  ZX console hardware specifications and resource budgets. Triggers on \"ZX specs\", \"ZX resolution\", \"ZX limits\", \"ROM size\", \"RAM limit\", \"VRAM\", \"render mode\", \"ZX capabilities\".\n\n  **Load references when:**\n  - Budget planning -> `references/resource-budgets.md`\nversion: 1.0.0\n---\n\n# ZX Console Specifications\n\n## Core Specs\n\n| Spec | Value |\n|------|-------|\n| Resolution | 960x540 fixed (16:9) |\n| Color depth | 32-bit RGBA8 |\n| ROM | 16 MB max |\n| RAM | 4 MB |\n| VRAM | 4 MB |\n| Tick rate | 24/30/60/120 fps |\n| Max players | 4 |\n| Alpha | 2-bit Bayer 4x4 |\n\n## Render Modes\n\nChoose ONE in `init()` - cannot change at runtime.\n\n| Mode | Name | Best For |\n|------|------|----------|\n| 0 | Lambert | 2D, flat stylized |\n| 1 | Matcap | Stylized 3D, toon |\n| 2 | MR-Blinn-Phong | PBR, realistic |\n| 3 | Blinn-Phong | Retro 5th-gen |\n\n## Audio System\n\n| Spec | Value |\n|------|-------|\n| Sample rate | 22,050 Hz |\n| Format | 16-bit signed PCM, mono |\n| Sound channels | 16 simultaneous |\n| Music channel | 1 dedicated |\n\n## Input (6th-gen Controller)\n\n| Input | Type |\n|-------|------|\n| D-Pad | 4-way digital |\n| Face buttons | A, B, X, Y |\n| Bumpers | L1, R1 (digital) |\n| Triggers | L2, R2 (analog 0-1) |\n| Sticks | Left + Right (analog -1 to 1) |\n| Menu | Start, Select |\n\n## What ZX Excels At\n\n- 3D platformers and action games\n- Fighting games (4-player, rollback)\n- Racing games\n- Third-person adventures\n- Split-screen local multiplayer\n- Online competitive games\n\n## What Requires Planning\n\n- Large open worlds (16 MB ROM)\n- Orchestral soundtracks (16 channels)\n- Massive texture counts (4 MB VRAM)\n",
        "zx/skills/console-specs/references/resource-budgets.md": "# ZX Resource Budgets\n\n## Console Limits\n\n| Resource | Hard Limit | Typical | Warning |\n|----------|------------|---------|---------|\n| **ROM Total** | 16 MB | 8-12 MB | > 12 MB |\n| **WASM Code** | 4 MB | 0.5-2 MB | > 2 MB |\n| **Data Pack** | 12 MB | 4-10 MB | > 10 MB |\n| **RAM** | 4 MB | 1-3 MB | > 3 MB |\n| **VRAM** | 4 MB | 2-4 MB | > 3.5 MB |\n| **State Snapshot** | - | 50-150 KB | > 200 KB |\n\n## Data Pack Budget (12 MB max)\n\n| Asset Type | Percentage | Budget |\n|------------|------------|--------|\n| Textures | 40-60% | 4.8-7.2 MB |\n| Meshes | 20-30% | 2.4-3.6 MB |\n| Audio | 10-20% | 1.2-2.4 MB |\n| Animations | 5-15% | 0.6-1.8 MB |\n\n## Genre Budget Examples\n\n**Fighting Game (~12 MB):**\n- Characters (8): ~6 MB\n- Stages (4): ~3 MB\n- Audio: ~2 MB\n- Effects, UI, code: ~1 MB\n\n**3D Platformer (~10 MB):**\n- Player + animations: ~500 KB\n- Levels (20): ~5 MB\n- Enemies/NPCs: ~2 MB\n- Audio: ~2 MB\n- Code: ~500 KB\n\n**Racing Game (~8 MB):**\n- Vehicles (12): ~2 MB\n- Tracks (6): ~4 MB\n- Audio: ~1.5 MB\n- Effects, UI, code: ~500 KB\n\n## Quick Size Estimation\n\n```\nTexture: width x height x 0.5 bytes (BC7)\nMesh: vertices x 12-40 bytes (format dependent)\nAudio: seconds x 44100 bytes (22050Hz mono)\nXM Music: 50-200 KB per song\n```\n\n## State Snapshot Performance\n\n| Size | Frame Budget | Status |\n|------|--------------|--------|\n| < 50 KB | < 1ms | Excellent |\n| 50-100 KB | 1-2ms | Good |\n| 100-200 KB | 2-4ms | Acceptable |\n| > 200 KB | > 4ms | Optimize |\n",
        "zx/skills/ffi-reference/SKILL.md": "---\nname: ZX FFI Reference\ndescription: |\n  ZX console FFI bindings reference. Triggers on \"ZX FFI\", \"zx.rs\", \"ZX API\", \"ZX functions\", \"ZX rendering\", \"ZX input\", \"ZX audio\".\n\n  **Load references when:**\n  - Render API details -> `references/render-api.md`\n  - Input API details -> `references/input-api.md`\n  - Audio API details -> `references/audio-api.md`\n  - Full FFI -> Read `nethercore/include/zx.rs` directly\nversion: 1.0.0\n---\n\n# ZX FFI Reference\n\nThe ZX console provides 250+ FFI functions. **Always read `nethercore/include/zx.rs` for accurate signatures.**\n\n## FFI Categories\n\n| Category | Key Functions | Find In zx.rs |\n|----------|--------------|---------------|\n| System | `delta_time`, `tick_count`, `log` | Lines 1-100 |\n| Random | `random`, `random_range`, `random_f32` | Search \"random\" |\n| Input | `button_held`, `button_pressed`, `left_stick_x` | Search \"button\" |\n| Camera | `camera_set`, `camera_fov` | Search \"camera\" |\n| Transforms | `push_translate`, `push_rotate_y`, `push_scale` | Search \"push_\" |\n| Meshes | `load_mesh`, `draw_mesh`, `cube`, `sphere` | Search \"mesh\" |\n| Textures | `load_texture`, `texture_bind` | Search \"texture\" |\n| Materials | `material_albedo`, `material_mre`, `material_normal` | Search \"material\" |\n| Audio | `load_sound`, `play_sound`, `music_play` | Search \"sound\" |\n| 2D Drawing | `draw_sprite`, `draw_text`, `draw_rect` | Search \"draw_\" |\n| Environment | `draw_env`, `env_gradient` | Search \"env_\" |\n| Debug | `debug_register_*`, `debug_watch_*`, `debug_group_*` | Search \"debug_\" |\n\n## Init-Only Functions\n\nMust call only during `init()`:\n- `set_tick_rate(rate)` - 0=24fps, 1=30fps, 2=60fps, 3=120fps\n- `set_clear_color(color)` - 0xRRGGBBAA\n- `render_mode(mode)` - 0=Lambert, 1=Matcap, 2=PBR, 3=Hybrid\n- All `rom_*()`, `load_*()`, procedural mesh functions\n\n## Render-Only Functions\n\nCall only during `render()`:\n- All `draw_*` functions\n- `camera_set()`, `camera_fov()`\n- `push_translate()`, `push_rotate_y()`, `push_scale()`\n- `texture_bind()`, `font_bind()`\n- `begin_pass()`, `begin_pass_stencil_write()`\n\n## Asset Loading\n\n```rust\n// In init()\nlet tex = rom_texture_str(\"player\");\nlet mesh = rom_mesh_str(\"character\");\nlet sfx = rom_sound_str(\"jump\");\nlet music = rom_music_str(\"theme\");\n```\n\n## Transform Stack\n\n```rust\n// In render()\npush_translate(x, y, z);\npush_rotate_y(angle_degrees);\npush_scale_uniform(scale);\ndraw_mesh(MESH);\npush_identity();  // Reset\n```\n\n## Coordinate System\n\n- Y-up, right-handed, -Z forward\n- When yaw=0, camera looks toward -Z\n- Angles in degrees for FFI functions\n",
        "zx/skills/ffi-reference/references/audio-api.md": "# ZX Audio API\n\n## Sound Effects\n\n| Function | Purpose |\n|----------|---------|\n| `load_sound(data, len)` | Load sound from bytes |\n| `rom_sound_str(id)` | Get sound handle from ROM |\n| `play_sound(handle)` | Play sound once |\n| `play_sound_ex(handle, vol, pan, pitch)` | Play with parameters |\n| `stop_sound(handle)` | Stop playing sound |\n\n## Music\n\n| Function | Purpose |\n|----------|---------|\n| `rom_music_str(id)` | Get music handle from ROM |\n| `music_play(handle)` | Start music (loops) |\n| `music_stop()` | Stop music |\n| `music_pause()` | Pause music |\n| `music_resume()` | Resume paused music |\n| `music_volume(vol)` | Set music volume (0.0-1.0) |\n\n## Parameters\n\n| Parameter | Range | Default |\n|-----------|-------|---------|\n| Volume | 0.0 - 1.0 | 1.0 |\n| Pan | -1.0 (left) to 1.0 (right) | 0.0 (center) |\n| Pitch | 0.5 - 2.0 | 1.0 |\n\n## Audio Specs\n\n- Sample rate: 22,050 Hz\n- Format: 16-bit signed PCM, mono\n- Sound channels: 16 simultaneous\n- Music channel: 1 dedicated\n\n## Example Usage\n\n```rust\nstatic mut JUMP_SFX: u32 = 0;\nstatic mut THEME: u32 = 0;\n\nfn init() {\n    unsafe {\n        JUMP_SFX = rom_sound_str(\"jump\");\n        THEME = rom_music_str(\"theme\");\n        music_play(THEME);\n    }\n}\n\nfn play_jump() {\n    unsafe {\n        // Play with slight pitch variation\n        let pitch = 0.9 + random_f32() * 0.2;\n        play_sound_ex(JUMP_SFX, 1.0, 0.0, pitch);\n    }\n}\n```\n",
        "zx/skills/ffi-reference/references/input-api.md": "# ZX Input API\n\n## Determinism Note\n\nAll input functions return **deterministic values** synchronized by the netcode. Call them in `update()` - the values are identical across all clients for the same frame. Never cache input state across frames.\n\n## Button Functions\n\n| Function | Returns | Purpose |\n|----------|---------|---------|\n| `button_held(player, btn)` | bool | Button currently down |\n| `button_pressed(player, btn)` | bool | Button just pressed this frame |\n| `button_released(player, btn)` | bool | Button just released this frame |\n\n## Button Constants\n\n| Button | Value | Physical |\n|--------|-------|----------|\n| `BTN_A` | 0 | A / Cross |\n| `BTN_B` | 1 | B / Circle |\n| `BTN_X` | 2 | X / Square |\n| `BTN_Y` | 3 | Y / Triangle |\n| `BTN_L1` | 4 | Left bumper |\n| `BTN_R1` | 5 | Right bumper |\n| `BTN_L3` | 6 | Left stick click |\n| `BTN_R3` | 7 | Right stick click |\n| `BTN_START` | 8 | Start/Menu |\n| `BTN_SELECT` | 9 | Select/Back |\n| `BTN_UP` | 10 | D-pad up |\n| `BTN_DOWN` | 11 | D-pad down |\n| `BTN_LEFT` | 12 | D-pad left |\n| `BTN_RIGHT` | 13 | D-pad right |\n\n## Analog Functions\n\n| Function | Range | Purpose |\n|----------|-------|---------|\n| `left_stick_x(player)` | -1.0 to 1.0 | Left stick horizontal |\n| `left_stick_y(player)` | -1.0 to 1.0 | Left stick vertical |\n| `right_stick_x(player)` | -1.0 to 1.0 | Right stick horizontal |\n| `right_stick_y(player)` | -1.0 to 1.0 | Right stick vertical |\n| `left_trigger(player)` | 0.0 to 1.0 | L2 trigger |\n| `right_trigger(player)` | 0.0 to 1.0 | R2 trigger |\n\n## Player Info\n\n| Function | Purpose |\n|----------|---------|\n| `player_count()` | Number of active players (1-4) |\n| `local_player_mask()` | Bitmask of local players |\n\n## Example Usage\n\n```rust\nfn update() {\n    let p = 0; // Player 0\n\n    // Digital input\n    if button_pressed(p, BTN_A) {\n        jump();\n    }\n\n    // Analog input\n    let move_x = left_stick_x(p);\n    let move_y = left_stick_y(p);\n\n    // Trigger\n    let accel = right_trigger(p);\n}\n```\n",
        "zx/skills/ffi-reference/references/render-api.md": "# ZX Render API\n\n## Camera\n\n| Function | Purpose |\n|----------|---------|\n| `camera_set(x,y,z, tx,ty,tz)` | Position + look-at |\n| `camera_fov(degrees)` | Field of view (default 60) |\n| `push_view_matrix(m0..m15)` | Custom 4x4 view matrix |\n\n## Transform Stack\n\n| Function | Purpose |\n|----------|---------|\n| `push_translate(x, y, z)` | Translate |\n| `push_rotate_x(deg)` | Rotate around X |\n| `push_rotate_y(deg)` | Rotate around Y |\n| `push_rotate_z(deg)` | Rotate around Z |\n| `push_scale(x, y, z)` | Non-uniform scale |\n| `push_scale_uniform(s)` | Uniform scale |\n| `push_identity()` | Reset to identity |\n| `push_matrix(m0..m15)` | Custom 4x4 matrix |\n\n## Mesh Drawing\n\n| Function | Purpose |\n|----------|---------|\n| `draw_mesh(handle)` | Draw loaded mesh |\n| `cube(size)` | Procedural cube |\n| `sphere(radius, segments)` | Procedural sphere |\n| `plane(width, height)` | Procedural plane |\n\n## Material Binding\n\n| Function | Slot | Purpose |\n|----------|------|---------|\n| `material_albedo(tex)` | 0 | Color/diffuse |\n| `material_mre(tex)` | 1 | Metallic/Roughness/Emissive |\n| `material_normal(tex)` | 3 | Normal map |\n| `set_color(rgba)` | - | Vertex color tint |\n\n## Render Passes\n\n| Function | Purpose |\n|----------|---------|\n| `begin_pass(clear_depth)` | New render pass |\n| `begin_pass_stencil_write(ref, clear_depth)` | Create stencil mask |\n| `begin_pass_stencil_test(ref, clear_depth)` | Render inside mask |\n| `z_index(n)` | 2D ordering (0-255) |\n\n## 2D Drawing\n\n| Function | Purpose |\n|----------|---------|\n| `draw_sprite(x,y, w,h)` | Draw textured quad |\n| `draw_rect(x,y, w,h)` | Draw colored rectangle |\n| `draw_text_str(text, x,y, size, color)` | Draw text |\n| `draw_circle(x, y, radius)` | Draw filled circle |\n\n## Billboards\n\n| Function | Purpose |\n|----------|---------|\n| `draw_billboard(w, h, mode, color)` | Camera-facing quad |\n| `draw_billboard_region(...)` | Billboard with UV region |\n\nBillboard modes:\n- 1 = SPHERICAL (faces camera fully)\n- 2 = CYLINDRICAL_Y (upright, rotates around Y)\n",
        "zx/skills/rendering/SKILL.md": "---\nname: ZX Rendering\ndescription: |\n  ZX rendering techniques: cameras, stencil effects, particles, fonts, 2D/3D. Triggers on \"ZX camera\", \"orbit camera\", \"stencil buffer\", \"portal\", \"billboard\", \"particles\", \"custom font\", \"render pass\", \"2D vs 3D\", \"screen space\", \"world space\".\n\n  **Load references when:**\n  - Camera implementations -> `references/camera-systems.md`\n  - Stencil/portal effects -> `references/effects.md`\n  - 2D vs 3D decisions -> `references/2d-vs-3d.md`\nversion: 1.0.0\n---\n\n# ZX Rendering Techniques\n\n## Camera Systems\n\nAll camera state in static variables for rollback safety.\n\n### Camera FFI\n\n| Function | Purpose |\n|----------|---------|\n| `camera_set(x,y,z, tx,ty,tz)` | Position + look-at |\n| `camera_fov(degrees)` | Field of view (default 60) |\n\n### Follow Camera (Core)\n\n```rust\nstatic mut CAM_X: f32 = 0.0;\nstatic mut CAM_Y: f32 = 5.0;\nstatic mut CAM_Z: f32 = 10.0;\n\nfn update_follow_camera(tx: f32, ty: f32, tz: f32) {\n    let dt = delta_time();\n    let t = (5.0 * dt).min(1.0);\n    unsafe {\n        CAM_X += (tx - CAM_X) * t;\n        CAM_Y += (ty + 5.0 - CAM_Y) * t;\n        CAM_Z += (tz + 10.0 - CAM_Z) * t;\n    }\n}\n```\n\n## Render Passes & Stencil\n\nCreate portals, scopes, masks using render passes.\n\n| Function | Purpose |\n|----------|---------|\n| `begin_pass(clear_depth)` | New pass |\n| `begin_pass_stencil_write(ref, clear)` | Create mask |\n| `begin_pass_stencil_test(ref, clear)` | Render in mask |\n\n### Basic Stencil Flow\n\n```rust\n// 1. Create mask\nbegin_pass_stencil_write(1, 0);\ndraw_circle(SCREEN_CX, SCREEN_CY, 200.0);\n\n// 2. Render inside mask\nbegin_pass_stencil_test(1, 0);\ndraw_scene();\n\n// 3. Return to normal\nbegin_pass(0);\n```\n\n## Billboard Particles\n\n| Function | Mode | Use |\n|----------|------|-----|\n| `draw_billboard(w, h, 1, color)` | Spherical | Particles |\n| `draw_billboard(w, h, 2, color)` | Cylindrical | Trees |\n\n### Particle System Core\n\n```rust\n#[derive(Copy, Clone, Default)]\nstruct Particle { x: f32, y: f32, z: f32, vx: f32, vy: f32, vz: f32, life: f32 }\n\nstatic mut PARTICLES: [Particle; 256] = [...];\n\nfn render_particles(tex: u32) {\n    texture_bind(tex);\n    for p in unsafe { PARTICLES.iter() } {\n        if p.life > 0.0 {\n            push_translate(p.x, p.y, p.z);\n            draw_billboard(1.0, 1.0, 1, 0xFFFFFFFF);\n            push_identity();\n        }\n    }\n}\n```\n\n## Custom Fonts\n\n```rust\nlet tex = rom_texture_str(\"pixel_font\");\nlet font = load_font(tex, 8, 12, 32, 96);  // 8x12 glyphs\n\n// In render:\nfont_bind(font);\ndraw_text_str(\"SCORE\", 10.0, 10.0, 24.0, 0xFFFFFFFF);\nfont_bind(0);  // Back to default\n```\n\n## Coordinate Convention\n\nY-up, right-handed, -Z forward. When yaw=0, camera looks toward -Z.\n",
        "zx/skills/rendering/references/2d-vs-3d.md": "# 2D vs 3D Rendering Guide\n\n## Decision Matrix\n\n| Game Type | Recommended Approach |\n|-----------|---------------------|\n| UI/HUD overlays | Always 2D (`draw_sprite`, `draw_text`) |\n| Side-scrollers | 2D drawing OR 3D with orthographic camera |\n| Top-down games | Either (2D simpler, 3D allows depth effects) |\n| Isometric | 3D with fixed camera angle |\n| 3D perspective games | 3D meshes + transforms |\n| Hybrid (3D game + 2D UI) | Both - see pattern below |\n\n## Coordinate Systems\n\n| System | Origin | Axes | Used By |\n|--------|--------|------|---------|\n| **Screen space (2D)** | Top-left (0,0) | X right, Y down | `draw_sprite`, `draw_text`, `draw_rect` |\n| **World space (3D)** | World origin | Y up, -Z forward | `push_translate`, `draw_mesh`, `camera_set` |\n\n## 2D Drawing\n\nScreen-space functions ignore camera and transforms.\n\n```rust\nfn render() {\n    // Always draws at screen coordinates\n    draw_sprite(tex, 10.0, 10.0, 64.0, 64.0, 0xFFFFFFFF);\n    draw_text_str(\"SCORE: 100\", 20.0, 20.0, 16.0, 0xFFFFFFFF);\n    draw_rect(0.0, 0.0, 100.0, 10.0, 0xFF0000FF); // Health bar\n}\n```\n\n**Key functions:**\n- `draw_sprite(tex, x, y, w, h, color)`\n- `draw_text_str(str, x, y, size, color)`\n- `draw_rect(x, y, w, h, color)`\n- `draw_line(x1, y1, x2, y2, color)`\n- `draw_circle(x, y, radius, color)`\n- `z_index(n)` - Layer ordering (0-255)\n\n## 3D Drawing\n\nWorld-space functions use camera and transform stack.\n\n```rust\nfn render() {\n    camera_set(cam_x, cam_y, cam_z, target_x, target_y, target_z);\n    camera_fov(60.0);\n\n    push_translate(entity_x, entity_y, entity_z);\n    push_rotate_y(angle);\n    push_scale_uniform(1.0);\n    draw_mesh(MESH_HANDLE);\n    push_identity(); // Reset transforms\n}\n```\n\n**Key functions:**\n- `camera_set(x,y,z, tx,ty,tz)` - Position + look-at\n- `camera_fov(degrees)` - Field of view\n- `push_translate(x, y, z)` - Move\n- `push_rotate_y(degrees)` - Rotate (also `_x`, `_z`)\n- `push_scale_uniform(s)` - Scale\n- `draw_mesh(handle)` - Draw 3D mesh\n- `push_identity()` - Reset transform stack\n\n## Hybrid Pattern (3D Game + 2D UI)\n\n```rust\nfn render() {\n    // 1. Set up camera for 3D world\n    camera_set(cam_x, cam_y, cam_z, target_x, target_y, target_z);\n\n    // 2. Draw 3D world\n    for entity in entities {\n        push_translate(entity.x, entity.y, entity.z);\n        draw_mesh(entity.mesh);\n        push_identity();\n    }\n\n    // 3. Disable depth testing for UI\n    depth_test(false);\n\n    // 4. Draw 2D UI overlay (screen space)\n    draw_sprite(HUD_TEX, 10.0, 10.0, 200.0, 50.0, 0xFFFFFFFF);\n    draw_text_str(\"HP: 100\", 20.0, 25.0, 16.0, 0xFFFFFFFF);\n\n    // 5. Re-enable depth testing\n    depth_test(true);\n}\n```\n\n## Performance Comparison\n\n| Approach | Draw Calls | GPU Load | Best For |\n|----------|------------|----------|----------|\n| 2D sprites | Many small | Low (2D pipeline) | Simple games, UI |\n| 3D meshes | Fewer large | Higher (3D pipeline) | Complex visuals |\n| Batched sprites | Few large | Low | Sprite-heavy games |\n\n## Common Patterns\n\n### Pure 2D Game\n\n```rust\nfn render() {\n    // Background\n    draw_sprite(BG, 0.0, 0.0, 960.0, 540.0, 0xFFFFFFFF);\n\n    // Entities (sorted by Y for depth)\n    for entity in sorted_by_y(entities) {\n        draw_sprite(entity.tex, entity.x, entity.y, 64.0, 64.0, 0xFFFFFFFF);\n    }\n\n    // UI on top\n    z_index(255);\n    draw_text_str(\"SCORE\", 10.0, 10.0, 16.0, 0xFFFFFFFF);\n}\n```\n\n### 2.5D (3D world, fixed camera)\n\n```rust\nfn render() {\n    // Fixed isometric/top-down camera\n    camera_set(0.0, 20.0, 20.0, 0.0, 0.0, 0.0);\n\n    // 3D meshes\n    for entity in entities {\n        push_translate(entity.x, 0.0, entity.z);\n        draw_mesh(entity.mesh);\n        push_identity();\n    }\n}\n```\n\n### Full 3D\n\n```rust\nfn render() {\n    // Player-following camera\n    camera_set(\n        player_x - 5.0, player_y + 3.0, player_z + 5.0,\n        player_x, player_y, player_z\n    );\n\n    // World geometry\n    draw_env(ENV_HANDLE);\n\n    // Dynamic entities\n    for entity in entities {\n        push_translate(entity.x, entity.y, entity.z);\n        push_rotate_y(entity.rotation);\n        draw_mesh(entity.mesh);\n        push_identity();\n    }\n}\n```\n\n## Z-Ordering\n\n| Context | Method |\n|---------|--------|\n| 2D sprites | `z_index(0-255)` - Higher draws on top |\n| 3D meshes | Depth buffer (automatic) |\n| 2D on 3D | `depth_test(false)` for overlay |\n",
        "zx/skills/rendering/references/camera-systems.md": "# ZX Camera Systems\n\n## Camera Types\n\n| Type | Best For | Complexity |\n|------|----------|------------|\n| Follow | Platformers, racing | Simple |\n| Orbit | Action-adventure, RPGs | Medium |\n| First-Person | FPS, exploration | Medium |\n| Fixed | Puzzle, cinematic | Simple |\n\n## Orbit Camera\n\n```rust\nstatic mut CAM_YAW: f32 = 0.0;\nstatic mut CAM_PITCH: f32 = 20.0;\nstatic mut CAM_DIST: f32 = 8.0;\n\nfn update_orbit(player: u32) {\n    let dt = delta_time();\n    unsafe {\n        CAM_YAW += right_stick_x(player) * 120.0 * dt;\n        CAM_PITCH = (CAM_PITCH - right_stick_y(player) * 120.0 * dt)\n            .clamp(-30.0, 60.0);\n    }\n}\n\nfn get_orbit_pos(tx: f32, ty: f32, tz: f32) -> (f32, f32, f32) {\n    unsafe {\n        let yaw = CAM_YAW.to_radians();\n        let pitch = CAM_PITCH.to_radians();\n        (\n            tx - CAM_DIST * yaw.sin() * pitch.cos(),\n            ty + CAM_DIST * pitch.sin(),\n            tz + CAM_DIST * yaw.cos() * pitch.cos(),\n        )\n    }\n}\n```\n\n## First-Person Camera\n\n```rust\nstatic mut LOOK_YAW: f32 = 0.0;\nstatic mut LOOK_PITCH: f32 = 0.0;\n\nfn update_first_person(player: u32) {\n    let dt = delta_time();\n    unsafe {\n        LOOK_YAW += right_stick_x(player) * 90.0 * dt;\n        LOOK_PITCH = (LOOK_PITCH - right_stick_y(player) * 90.0 * dt)\n            .clamp(-85.0, 85.0);\n    }\n}\n\nfn get_look_dir() -> (f32, f32, f32) {\n    unsafe {\n        let yaw = LOOK_YAW.to_radians();\n        let pitch = LOOK_PITCH.to_radians();\n        (-yaw.sin() * pitch.cos(), pitch.sin(), -yaw.cos() * pitch.cos())\n    }\n}\n```\n\n## Screen Shake\n\n```rust\nstatic mut SHAKE_TRAUMA: f32 = 0.0;\n\nfn add_shake(amount: f32) {\n    unsafe { SHAKE_TRAUMA = (SHAKE_TRAUMA + amount).min(1.0); }\n}\n\nfn update_shake() {\n    unsafe { SHAKE_TRAUMA = (SHAKE_TRAUMA - delta_time() * 2.0).max(0.0); }\n}\n\nfn get_shake_offset() -> (f32, f32) {\n    unsafe {\n        let shake = SHAKE_TRAUMA * SHAKE_TRAUMA * 10.0;\n        ((random_f32() - 0.5) * shake, (random_f32() - 0.5) * shake)\n    }\n}\n```\n\n## Dead Zone\n\nPrevents jitter when target is near camera center:\n\n```rust\nfn update_with_dead_zone(tx: f32, tz: f32) {\n    let dx = tx - CAM_X;\n    let dz = tz - (CAM_Z - OFFSET_Z);\n    let dist = (dx*dx + dz*dz).sqrt();\n    if dist > 2.0 {  // DEAD_ZONE\n        let t = ((dist - 2.0) / dist) * 0.1;\n        CAM_X += dx * t;\n        CAM_Z += dz * t;\n    }\n}\n```\n",
        "zx/skills/rendering/references/effects.md": "# ZX Rendering Effects\n\n## Stencil Constants\n\n**Depth/Stencil Compare:**\n| Constant | Value | Use |\n|----------|-------|-----|\n| `NEVER` | 1 | Never pass |\n| `LESS` | 2 | Standard depth |\n| `EQUAL` | 3 | Match exactly |\n| `ALWAYS` | 8 | Always pass |\n\n**Stencil Operations:**\n| Constant | Value | Effect |\n|----------|-------|--------|\n| `KEEP` | 0 | Keep current |\n| `REPLACE` | 2 | Set to ref |\n\n## Scope Effect\n\n```rust\nfn render_scoped_view() {\n    // Create circular mask\n    begin_pass_stencil_write(1, 0);\n    draw_circle(SCREEN_CX, SCREEN_CY, 200.0);\n\n    // World only visible inside circle\n    begin_pass_stencil_test(1, 0);\n    camera_set(cam_x, cam_y, cam_z, tx, ty, tz);\n    draw_env();\n    draw_mesh(WORLD_MESH);\n\n    // Return to normal, draw scope overlay\n    begin_pass(0);\n    texture_bind(SCOPE_OVERLAY);\n    draw_sprite(0.0, 0.0, 960.0, 540.0);\n}\n```\n\n## Portal Effect\n\n```rust\nfn render_portal() {\n    // Draw main world\n    camera_set(main_cam...);\n    draw_mesh(MAIN_WORLD);\n\n    // Create portal mask\n    begin_pass_stencil_write(1, 0);\n    push_translate(portal_x, portal_y, portal_z);\n    draw_mesh(PORTAL_FRAME);\n    push_identity();\n\n    // Other world inside portal (clear_depth=1)\n    begin_pass_stencil_test(1, 1);\n    camera_set(other_cam...);\n    draw_mesh(OTHER_WORLD);\n\n    begin_pass(0);\n}\n```\n\n## FPS Viewmodel\n\n```rust\nfn render_fps() {\n    // Draw world\n    camera_set(player_x, player_y, player_z, look_x, look_y, look_z);\n    draw_env();\n    draw_mesh(LEVEL);\n\n    // New pass with depth clear - viewmodel always on top\n    begin_pass(1);\n    push_translate(0.3, -0.2, 0.5);\n    push_rotate_y(sway_angle);\n    draw_mesh(GUN);\n    push_identity();\n}\n```\n\n## Particle Effect Recipes\n\n**Smoke:** `vy = 1-2`, `life = 1-3s`, `color = 0x888888FF`\n**Fire:** `vy = 2-3`, `life = 0.3-0.7s`, `colors = 0xFFFF88/FF8800`\n**Sparks:** `velocity = ±5`, `life = 0.2-0.5s`, `size = 0.1`\n\n## Performance Tips\n\n| Particles | Impact |\n|-----------|--------|\n| 0-100 | Excellent |\n| 100-500 | Good |\n| 500-1000 | Moderate |\n| 1000+ | Optimize |\n\nPool particles, use LOD at distance, texture atlas.\n"
      },
      "plugins": [
        {
          "name": "nethercore",
          "description": "Platform tooling for Nethercore game development - build, test, optimize, publish",
          "version": "1.0.0",
          "author": {
            "name": "Nethercore Systems"
          },
          "source": "./nethercore",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add nethercore-systems/nethercore-ai-plugins",
            "/plugin install nethercore@nethercore-ai-plugins"
          ]
        },
        {
          "name": "zx",
          "description": "ZX fantasy console FFI reference and specifications",
          "version": "1.0.0",
          "author": {
            "name": "Nethercore Systems"
          },
          "source": "./zx",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add nethercore-systems/nethercore-ai-plugins",
            "/plugin install zx@nethercore-ai-plugins"
          ]
        }
      ]
    }
  ]
}