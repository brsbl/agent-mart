{
  "author": {
    "id": "chuggies510",
    "display_name": "chuggies510",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/213517204?u=1f8ebeea66c5c3540c410781fb0f893d82329460&v=4",
    "url": "https://github.com/chuggies510",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 1,
      "total_skills": 0,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "feature-dev-harnessed",
      "version": "1.0.0",
      "description": "Feature development with multi-session harness for large features",
      "owner_info": {
        "name": "chuggies510"
      },
      "keywords": [],
      "repo_full_name": "chuggies510/feature-dev-harnessed",
      "repo_url": "https://github.com/chuggies510/feature-dev-harnessed",
      "repo_description": "Feature development with multi-session harness for large features",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-29T00:42:16Z",
        "created_at": "2025-11-30T05:06:13Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 625
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 269
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 15509
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/feature-dev.md",
          "type": "blob",
          "size": 23190
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"feature-dev-harnessed\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Feature development with multi-session harness for large features\",\n  \"owner\": {\n    \"name\": \"chuggies510\"\n  },\n  \"repository\": \"https://github.com/chuggies510/feature-dev-harnessed\",\n  \"license\": \"MIT\",\n  \"plugins\": [\n    {\n      \"name\": \"feature-dev-harnessed\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Feature development with integrated harness for multi-session execution. Fork of Anthropic's feature-dev with their long-running agent pattern.\",\n      \"author\": {\n        \"name\": \"chuggies510\"\n      },\n      \"source\": \"./\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"feature-dev-harnessed\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Feature development with integrated harness for multi-session execution. Fork of Anthropic's feature-dev with their long-running agent pattern.\",\n  \"author\": {\n    \"name\": \"chuggies510\"\n  }\n}\n",
        "README.md": "# feature-dev-harnessed\n\nFeature development with multi-session execution for large features.\n\nA fork of Anthropic's [feature-dev plugin](https://github.com/anthropics/claude-code/tree/main/plugins/feature-dev) that integrates their [harness pattern for long-running agents](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents).\n\n## The Problem\n\nAnthropic's feature-dev plugin provides a thorough 7-phase workflow for feature development. This works well for features that fit in one context window. For larger features, the exploration and architecture phases (1-4) consume significant context, leaving insufficient room for implementation.\n\n## The Solution\n\nThis fork keeps phases 1-4 (planning) and 6-7 (review) exactly as Anthropic designed them. It replaces phase 5 (implementation) with a multi-session harness pattern:\n\n- **Session 1**: Planning - Run phases 1-4, create `feature_list.json` with work items\n- **Sessions 2-N**: Implementation - Execute one item per session with verification\n- **Final Session**: Review - Run phases 6-7, complete the feature\n\nOne command that detects state and does the right thing across multiple sessions.\n\n## When to Use This Plugin\n\n### Use feature-dev-harnessed for:\n\n- **Large features** that require 3+ implementation sessions\n- **Complex features** where thorough exploration consumes significant context\n- **Multi-day features** where you'll return across multiple sessions\n- **Features with many components** that benefit from incremental verification\n\n### Use regular feature-dev for:\n\n- Features completable in a single session\n- Small to medium features with straightforward implementation\n- Quick iterations where multi-session overhead isn't worth it\n\n### Don't use either for:\n\n- Single-line bug fixes\n- Trivial changes\n- Urgent hotfixes\n\n## Workflow\n\n### Planning Session (Phases 1-4)\n\n#### Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\n```\nYou: /feature-dev-harnessed:feature-dev Add CSV export for cost reports\nClaude: Let me understand what you need...\n        - What data should be included in the CSV?\n        - Should users be able to select which columns to export?\n        - Any specific formatting requirements?\n```\n\n#### Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns\n\nLaunches 2-3 `code-explorer` agents in parallel to trace through:\n- Similar features and their implementation patterns\n- Architecture and abstractions in the relevant area\n- UI patterns and extension points\n\n```\nFound similar features:\n- PDF export (src/export/pdf.py): Uses ReportFormatter base class\n- Data filtering (src/reports/filters.py): Column selection pattern\n\nKey files to understand:\n- src/export/base.py:23 - ReportFormatter interface\n- src/reports/cost_report.py:45 - Cost report data structure\n- src/ui/export_button.py:12 - Export button component\n```\n\n#### Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve ambiguities before designing\n\n```\nBefore designing the architecture, I need to clarify:\n\n1. Column selection: Include all columns or let user choose?\n2. Formatting: How should currency values be formatted?\n3. File naming: Auto-generate filename or prompt user?\n4. Large reports: Any pagination or size limits?\n```\n\n#### Phase 4: Architecture Design\n\n**Goal**: Design multiple approaches with trade-offs\n\nLaunches 2-3 `code-architect` agents with different focuses:\n\n```\nI've designed 3 approaches:\n\nApproach 1: Minimal Changes\n- Add csv_export() method to existing CostReport class\n- Reuse PDF export button with format parameter\nPros: Fast, minimal code\nCons: Couples CSV logic to report class\n\nApproach 2: Clean Architecture\n- New CsvFormatter implementing ReportFormatter\n- Dedicated export service with format registry\nPros: Extensible, testable, follows existing patterns\nCons: More files, more abstraction\n\nApproach 3: Pragmatic Balance\n- New CsvFormatter class\n- Wire into existing export button component\nPros: Clean separation, minimal refactoring\nCons: Some duplication with PDF formatter\n\nRecommendation: Approach 3 - follows existing patterns without over-engineering.\n\nWhich approach would you like to use?\n```\n\nAfter user approves, creates `feature_list.json` with session-sized work items.\n\n### Implementation Sessions (Phase 5, multi-session)\n\nEach session:\n1. Run smoke tests on previously completed items\n2. Implement the next pending item\n3. Run verification command until it passes\n4. Update artifacts and commit\n\n```\nSession 3: Implementation\n\nSmoke tests: 001 PASS, 002 PASS\nWorking on: 003 - Wire export button to CSV formatter\nVerification: python3 -m pytest tests/test_csv_export.py -v\n\n[Implementation happens here]\n\nVerification PASSED\nReady to commit? Proceed?\n```\n\n### Review Session (Phases 6-7)\n\n#### Phase 6: Quality Review\n\nLaunches 3 `code-reviewer` agents to check:\n- Simplicity, DRY, elegance\n- Bugs and functional correctness\n- Project conventions and abstractions\n\n```\nCode Review Results:\n\nHigh Priority:\n1. Missing error handling for empty reports (src/export/csv.py:45)\n\nMedium Priority:\n1. Could extract common formatting logic from PDF and CSV exporters\n\nAll verification commands pass. Code follows project conventions.\n\nWhat would you like to do? (fix now / fix later / proceed as-is)\n```\n\n#### Phase 7: Summary\n\n```\nFeature Complete: CSV Export for Cost Reports\n\nWhat was built:\n- CsvFormatter class implementing ReportFormatter interface\n- Column selection UI integrated with export button\n- Automated tests for CSV export functionality\n\nKey decisions:\n- Used pragmatic approach with dedicated formatter\n- Reused existing export button component\n- Added column selection based on user feedback\n\nFiles modified:\n- src/export/csv.py (new)\n- src/ui/export_button.py\n- tests/test_csv_export.py (new)\n\nSessions: 5 (1 planning, 3 implementation, 1 review)\n```\n\n## Prerequisites\n\n- [Claude Code](https://claude.ai/code) installed and configured\n- The `feature-dev` plugin from Anthropic's claude-code-plugins marketplace (for agents)\n\n## Installation\n\n```bash\n# Add Anthropic's marketplace (if not already added)\nclaude plugin marketplace add anthropics/claude-code\n\n# Install feature-dev (provides the agents)\nclaude plugin install feature-dev@claude-code\n\n# Add feature-dev-harnessed marketplace\nclaude plugin marketplace add chuggies510/feature-dev-harnessed\n\n# Install this plugin (note: marketplace name is just the repo name)\nclaude plugin install feature-dev-harnessed@feature-dev-harnessed\n```\n\nOr install directly from GitHub:\n```bash\nclaude plugin install github:chuggies510/feature-dev-harnessed\n```\n\n## Usage\n\n```bash\n# Start a new feature (planning session)\n/feature-dev-harnessed:feature-dev \"Add CSV export for cost reports\"\n\n# Continue implementation (subsequent sessions)\n/feature-dev-harnessed:feature-dev\n```\n\n### State Detection\n\nThe command automatically detects what to do based on filesystem state:\n\n| Condition | State | Action |\n|-----------|-------|--------|\n| No `dev/features/active/feature_list.json` | New feature | Run phases 1-4, create artifacts |\n| `feature_list.json` exists with pending items | Mid-implementation | Run one item, verify, commit |\n| All items pass, not reviewed | Ready for review | Run phases 6-7 |\n| `claude-progress.txt` contains \"Feature complete\" | Complete | Archive and summarize |\n\n## Artifacts\n\nAll artifacts are stored in `dev/features/`:\n\n```\ndev/features/\n├── active/                              # Current feature (gitignored)\n│   ├── feature_list.json\n│   ├── claude-progress.txt\n│   └── init.sh\n└── completed/                           # Archived features (committed)\n    └── v3.2.0-csv-export/\n        ├── feature_list.json\n        └── claude-progress.txt\n```\n\n### feature_list.json\n\nMachine-readable work items with version tracking and verification commands.\n\n```json\n{\n  \"feature\": \"csv-export-for-cost-reports\",\n  \"created\": \"2025-11-29\",\n  \"current_version\": \"3.1.1\",\n  \"target_version\": \"3.2.0\",\n  \"version_files\": [\"pyproject.toml\", \".claude/VERSION\"],\n  \"architecture\": \"Pragmatic balance: Add CSV formatter utility...\",\n  \"init_script\": \"./init.sh\",\n  \"items\": [\n    {\n      \"id\": \"001\",\n      \"description\": \"Create CSV formatter utility\",\n      \"verification\": \"python3 -c 'from utils.csv_formatter import format_csv'\",\n      \"status\": \"pass\",\n      \"session_completed\": 2\n    }\n  ]\n}\n```\n\n### claude-progress.txt\n\nHuman-readable session log. Append-only. Helps Claude recover context between sessions.\n\n```\nFeature: csv-export-for-cost-reports\nVersion: 3.1.1 → 3.2.0\nCreated: 2025-11-29\n\nSession 1 (2025-11-29):\nPlanning session. Ran phases 1-4.\nArchitecture chosen: Pragmatic balance...\nNext: 001 (Create CSV formatter utility)\n\nSession 2 (2025-11-29):\nCompleted: 001 (Create CSV formatter utility)\nVerification: PASS\nNext: 002 (Add export button)\n```\n\n## Versioning\n\nThe plugin automatically detects and manages project versions:\n\n1. **Detection** (Phase 2): Searches for `pyproject.toml`, `package.json`, `VERSION`, etc.\n2. **Suggestion** (Phase 4): Recommends version bump based on feature scope:\n   - PATCH: Bug fixes\n   - MINOR: New features (default)\n   - MAJOR: Breaking changes\n3. **Bump** (Phase 7): Updates all version files and CHANGELOG.md\n4. **Archive**: Completed features archived to `dev/features/completed/{version}-{feature}/`\n\n## Starting a New Feature\n\nFeatures are archived automatically on completion. To start a new feature, simply run the command with a description:\n\n```bash\n/feature-dev-harnessed:feature-dev \"New feature description\"\n```\n\nPrevious features are preserved in `dev/features/completed/` for reference.\n\n## Handling Failures\n\n**Smoke test failure (regression)**: Claude stops all new work and fixes the regression until all smoke tests pass. No new items can be implemented until regressions are resolved.\n\n**Verification failure**: Claude will debug and retry until the verification passes. If stuck, you can manually intervene.\n\n**Init script failure**: If `init.sh` fails to start the development environment, Claude will debug and fix before proceeding.\n\n**Mid-feature abandonment**: Delete `feature_list.json` and `claude-progress.txt` to start over, or leave them to resume later.\n\n## Agents\n\nThree specialized agents handle different aspects of feature development. They run in parallel during their respective phases.\n\n### code-explorer\n\n**Purpose**: Deeply analyzes existing codebase by tracing execution paths\n\n**Focus areas**:\n- Entry points and call chains\n- Data flow and transformations\n- Architecture layers and patterns\n- Dependencies and integrations\n\n**Output**: Entry points with file:line references, execution flow, key components, and list of essential files to read.\n\n**When used**: Phase 2 (Codebase Exploration) - launches 2-3 in parallel with different focuses.\n\n### code-architect\n\n**Purpose**: Designs feature architectures and implementation blueprints\n\n**Focus areas**:\n- Codebase pattern analysis\n- Architecture decisions with rationale\n- Component design\n- Implementation roadmap\n\n**Output**: Patterns found, architecture decision, component design, implementation map with specific files, build sequence.\n\n**When used**: Phase 4 (Architecture Design) - launches 2-3 in parallel with different approaches (minimal, clean, pragmatic).\n\n### code-reviewer\n\n**Purpose**: Reviews code for bugs, quality issues, and project conventions\n\n**Focus areas**:\n- Project guideline compliance\n- Bug detection\n- Code quality and simplicity\n- Confidence-based filtering (only reports high-confidence issues)\n\n**Output**: Critical and important issues with file:line references and specific fixes.\n\n**When used**: Phase 6 (Quality Review) - launches 3 in parallel with different focuses (simplicity, correctness, conventions).\n\n## Best Practices\n\n### Writing Good Verification Commands\n\nVerification commands determine if an item is complete. They should:\n\n- **Return exit code 0 on success, non-zero on failure**\n- **Be specific to the item's deliverable**\n- **Be runnable from the project root**\n- **For web apps: prefer browser automation over unit tests**\n\nGood examples:\n```bash\n# Browser automation (preferred for web apps)\nnpx playwright test tests/csv-export.spec.ts\npython -m pytest tests/test_e2e.py --headed\n\n# Import check\npython3 -c 'from utils.csv_formatter import format_csv'\n\n# File existence\ngrep -q 'id=\"export-csv\"' templates/cost-report.html\n\n# Test suite\npython3 -m pytest tests/test_csv_export.py -v\n\n# Build check\nnpm run build && test -f dist/export.js\n```\n\nBad examples:\n```bash\n# Too vague - doesn't verify the specific deliverable\npython3 -c 'import utils'\n\n# Unit test when E2E would be better (for web features)\npython3 -c 'assert CsvFormatter().format([]) == \"\"'  # Doesn't verify UI works\n```\n\n### Manual Verification\n\nSome items can't be verified by a computer (visual checks, interactive testing). Use `manual:` prefix:\n\n```json\n{\n  \"verification\": \"manual: Run the launcher, navigate all menus, verify theme looks like SMB3\"\n}\n```\n\nClaude will prompt: *\"Manual verification required: Run the launcher, navigate all menus, verify theme looks like SMB3. Did it pass? (y/n)\"*\n\nManual items are skipped during smoke tests since they can't be automated.\n\n### Using init.sh\n\nFor projects that need environment setup, create an `init.sh` script:\n\n```bash\n#!/bin/bash\n# Start development server\nnpm run dev &\n\n# Wait for server to be ready\nsleep 3\n\n# Health check\ncurl -s http://localhost:3000/health || exit 1\n\necho \"Development environment ready\"\n```\n\nReference it in `feature_list.json`:\n```json\n{\n  \"init_script\": \"./init.sh\",\n  ...\n}\n```\n\nClaude will run this at the start of each implementation session.\n\n### Sizing Work Items\n\n**Aim for 10-20+ items for complex features.** Prefer too many small items over too few large ones. Small items reduce risk of half-implemented features breaking the next session.\n\nSigns an item is too large:\n- Touches more than 3-4 files\n- Requires multiple sub-tasks\n- Has complex verification logic\n- Would take more than ~30 minutes to implement\n\nSplit large items into smaller ones during planning.\n\n### Session Continuity\n\nBetween sessions, Claude recovers context by:\n1. Reading `feature_list.json` - what's done, what's next\n2. Reading `claude-progress.txt` - decisions made, context from previous sessions\n3. Reading recent git log (20 commits) - what changed since last session\n4. Running `init.sh` (if defined) - starting the development environment\n5. Running smoke tests - verifying all previous work still passes\n\nWrite clear progress entries to help future sessions understand context.\n\n### Tips\n\n- **Be specific in your feature request**: More detail in phase 1 = fewer clarifying questions\n- **Answer clarifying questions thoroughly**: Phase 3 prevents confusion during implementation\n- **Trust the architecture recommendation**: It's based on actual codebase analysis\n- **Review agent outputs**: Agents surface insights about your codebase you might not know\n- **Don't skip phases**: Each phase builds context for the next\n- **Never delete or modify existing tests**: Add new tests, never remove or weaken existing ones\n\n## Credits\n\n- [Anthropic's feature-dev plugin](https://github.com/anthropics/claude-code/tree/main/plugins/feature-dev) - Original 7-phase workflow\n- [Effective harnesses for long-running agents](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents) - Multi-session execution pattern\n",
        "commands/feature-dev.md": "---\ndescription: Feature development with multi-session harness for large features\nargument-hint: Optional feature description\nversion: 1.2.0\n---\n\n# Feature Development (Harnessed)\n\nYou are helping a developer implement a new feature using a multi-session harness pattern. This enables completing large features that don't fit in a single context window.\n\n## How This Works\n\nThis command detects state from the filesystem and executes the appropriate phase:\n- **No `dev/features/active/feature_list.json`**: Run planning phases (1-4), then create artifacts\n- **`feature_list.json` with pending items**: Run one implementation cycle\n- **All items complete, not reviewed**: Run quality review phases (6-7)\n- **Feature complete**: Archive and summarize\n\n---\n\n## State Detection\n\nBefore doing anything else, detect current state:\n\n1. Check if `dev/features/active/feature_list.json` exists\n2. If it exists, read it and check item statuses\n3. If `dev/features/active/claude-progress.txt` exists, check if it contains \"Feature complete\"\n\n**State determination:**\n- If `dev/features/active/feature_list.json` does NOT exist → Execute **Planning Session**\n- If `feature_list.json` exists AND has items with status \"pending\" → Execute **Implementation Session**\n- If `feature_list.json` exists AND all items have status \"pass\" AND `claude-progress.txt` does NOT contain \"Feature complete\" → Execute **Review Session**\n- If `claude-progress.txt` contains \"Feature complete\" → Execute **Complete State**\n\n**Artifact location:** All feature development artifacts are stored in `dev/features/active/` during development. On completion, they are archived to `dev/features/completed/{version}-{feature}/`.\n\n---\n\n## Core Principles\n\n- **All work will be reviewed**: Another AI agent will review your code. Shortcuts, simplifications, placeholders, and fallbacks waste time - you'll have to redo them. Write production-quality code from the start.\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n- **NEVER delete or modify tests**: It is unacceptable to remove or edit existing tests as this could lead to missing or buggy functionality. Add new tests, never remove or weaken existing ones.\n\n---\n\n# Planning Session\n\nExecute this section when `feature_list.json` does NOT exist.\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 3 code-explorer agents in parallel (reduce to 2 only if clearly unnecessary). Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n\n3. **Detect project version** (for version tracking):\n   - Search for version files: `pyproject.toml`, `package.json`, `VERSION`, `setup.py`, `Cargo.toml`, `.claude/VERSION`\n   - Extract current version number (e.g., \"3.1.1\" or \"1.0.0\")\n   - Note which files contain version info (may be multiple)\n   - If no version files found, note \"no version tracking detected\"\n   - Store findings for use in Phase 4\n\n4. Present comprehensive summary of findings and patterns discovered, including:\n   - Codebase architecture and patterns\n   - Current version: [version] (from [file])\n   - Version files found: [list]\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 3 code-architect agents in parallel (reduce to 2 only if clearly unnecessary) with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), and pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n5. **After architecture approval, suggest target version**:\n   - Use version detected in Phase 2\n   - Analyze feature scope to determine bump type:\n     - **PATCH** (x.y.Z → x.y.Z+1): Bug fixes, documentation, minor tweaks\n     - **MINOR** (x.Y.z → x.Y+1.0): New features, enhancements, backward-compatible changes\n     - **MAJOR** (X.y.z → X+1.0.0): Breaking changes, major rewrites, API changes\n   - Present suggestion: \"Current version is [version]. This is a [scope] change (new feature/bug fix/major rewrite). Recommend [target version]. Confirm?\"\n   - If no version files detected: \"No version tracking detected. Skip versioning, or create VERSION file starting at 1.0.0?\"\n   - Store user's confirmed target version for Phase 5\n\n---\n\n## Phase 5: Artifact Creation\n\n**Goal**: Convert approved architecture into multi-session execution artifacts\n\n**DO NOT START WITHOUT USER APPROVAL OF ARCHITECTURE AND VERSION**\n\n**Actions**:\n1. Wait for explicit user approval of architecture approach and target version\n2. Create `dev/features/active/` directory if it doesn't exist\n3. Create `dev/features/active/feature_list.json` with the following structure:\n   ```json\n   {\n     \"feature\": \"descriptive name of the feature\",\n     \"created\": \"YYYY-MM-DD\",\n     \"current_version\": \"version detected in Phase 2 (e.g., 3.1.1)\",\n     \"target_version\": \"user-approved version from Phase 4 (e.g., 3.2.0)\",\n     \"version_files\": [\n       \"pyproject.toml\",\n       \".claude/VERSION\"\n     ],\n     \"architecture\": \"brief description of chosen approach from phase 4\",\n     \"init_script\": \"optional - path to startup script (e.g., ./init.sh)\",\n     \"items\": [\n       {\n         \"id\": \"001\",\n         \"description\": \"what this item accomplishes, session-sized scope\",\n         \"verification\": \"shell command that returns exit code 0 on success\",\n         \"status\": \"pending\",\n         \"session_completed\": null\n       }\n     ]\n   }\n   ```\n4. Break implementation into **many small, granular items** (aim for 10-20+ items for complex features)\n   - Each item should be completable in one context window\n   - Prefer too many small items over too few large ones\n   - Small items reduce risk of half-implemented features breaking the next session\n5. Each item must have a verification command that returns exit code 0 for success\n   - For web apps: prefer browser automation (Playwright, Puppeteer) over unit tests\n   - Verify end-to-end user actions, not just code-level tests\n   - Example: `npx playwright test tests/csv-export.spec.ts` or `python -m pytest tests/test_e2e.py`\n6. Order items by dependency (items that depend on others come later)\n7. If the project needs a startup script, create `init.sh` with:\n   - Application startup commands\n   - Basic health checks\n   - Any environment setup\n   - Make it executable: `chmod +x init.sh`\n8. Create `dev/features/active/claude-progress.txt` with initial entry:\n   ```\n   Feature: [feature name]\n   Version: [current_version] → [target_version]\n   Created: [date]\n\n   Session 1 ([date]):\n   Planning session. Ran phases 1-4.\n   Architecture chosen: [approach description]\n   Created feature_list.json with [N] items.\n   Next: [first item id] ([first item description])\n   ```\n9. Ask user: \"Ready to commit artifacts? Proceed?\"\n10. If approved, git commit with message: `plan: create feature_list.json for [feature-name] (v[target_version])`\n\n**Planning session ends. Run this command again to start implementation.**\n\n---\n\n# Implementation Session\n\nExecute this section when `dev/features/active/feature_list.json` exists AND has items with status \"pending\".\n\n## Step 1: Read State and Initialize\n\n**Actions**:\n1. Read `dev/features/active/feature_list.json` to understand items and their status\n2. Read `dev/features/active/claude-progress.txt` to understand context and previous work\n3. Read recent git log (last 20 commits) to see changes since last session\n4. Determine current session number by counting \"Session N\" entries in `claude-progress.txt`\n5. Display: \"Session [N]: Implementation\"\n6. If `init_script` is defined in `feature_list.json`, run it to start the development environment\n   - If init script fails, debug and fix before proceeding\n\n---\n\n## Step 2: Smoke Tests\n\n**Goal**: Verify previously completed work still passes, fix any regressions\n\n**Prerequisite**: Init script (if defined) must have completed successfully in Step 1.\n\n**Actions**:\n1. For each item in `dev/features/active/feature_list.json` with status \"pass\":\n   - If verification starts with \"manual:\" → skip (manual items don't get smoke tested)\n   - If item has `interactive_verification` → run interactive verification using tmux-cli (see Step 5)\n   - Otherwise → run verification command and record result (PASS or FAIL)\n2. If ANY smoke test fails:\n   - Report: \"REGRESSION DETECTED: Item [id] verification failed\"\n   - Display the failed command and output\n   - **FIX THE REGRESSION BEFORE PROCEEDING**:\n     - Analyze what broke and why\n     - Fix the issue while preserving all existing functionality\n     - Re-run the failed verification until it passes\n     - Re-run ALL smoke tests to ensure fix didn't break something else\n   - Once all smoke tests pass, continue to next step\n3. If all smoke tests pass (or no items have status \"pass\" yet):\n   - Report: \"Smoke tests: [N] passed\" (or \"Smoke tests: N/A (first implementation session)\")\n   - Continue to next step\n\n---\n\n## Step 3: Select Next Item\n\n**Actions**:\n1. Find the first item in `feature_list.json` with status \"pending\"\n2. Display: \"Working on: [id] - [description]\"\n3. Display: \"Verification: [verification command]\"\n4. Create todo list for this item's implementation\n\n---\n\n## Step 4: Implement\n\n**Goal**: Implement the selected item\n\n**Actions**:\n1. Read `feature_list.json` to recall the architecture approach\n2. Read relevant source files needed for this item\n3. Implement the item following the documented architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Step 5: Verify\n\n**Goal**: Confirm the implementation works\n\n**Actions**:\n1. Check verification type:\n   - If verification starts with \"manual:\" → **Manual verification**\n     - Display: \"Manual verification required:\"\n     - Display the text after \"manual:\" (e.g., \"Run the launcher, check the menu looks correct\")\n     - Ask user: \"Did it pass? (y/n)\"\n     - If user says yes → treat as passed\n     - If user says no → ask what's wrong, fix it, ask again\n   - If item has `interactive_verification` object → **Interactive verification** (uses tmux-cli)\n     - Launch shell: `tmux-cli launch \"zsh\"`\n     - Navigate to project: `tmux-cli send --text=\"cd [project_path]\" --pane=[id]`\n     - Launch app: `tmux-cli send --text=\"[launch command]\" --pane=[id]`\n     - Wait: `tmux-cli wait_idle --pane=[id]`\n     - For each input in `inputs`: `tmux-cli send --text=\"[input]\" --pane=[id]`\n     - Capture: `tmux-cli capture --pane=[id]`\n     - Check that ALL patterns in `expect` appear in captured output\n     - Cleanup: `tmux-cli kill --pane=[id]`\n     - If any expect pattern missing → debug, fix, retry\n   - Otherwise → **Automated verification**\n     - Run the verification command\n     - If it fails:\n       - Analyze the failure\n       - Debug and fix\n       - Re-run verification\n       - Repeat until it passes\n2. When verification passes:\n   - Display: \"Verification PASSED\"\n   - Proceed to state update\n\n---\n\n## Step 6: Update State\n\n**Goal**: Record progress in artifacts\n\n**Actions**:\n1. Update `dev/features/active/feature_list.json`:\n   - Set item status to \"pass\"\n   - Set session_completed to current session number\n   - **Do not modify any other fields** (id, description, verification are immutable)\n2. Append to `dev/features/active/claude-progress.txt`:\n   ```\n   Session [N] ([date]):\n   Completed: [id] ([description])\n   Verification: PASS - [brief result description]\n   Smoke tests: [previous items' results, or \"N/A\" for first implementation session]\n   Next: [next pending item id and description, or \"All items complete. Ready for code review.\"]\n   ```\n3. Ask user: \"Ready to commit? Proceed?\"\n4. If approved, git commit with message: `feat: implement [id] - [brief description]`\n\n---\n\n## Step 7: Clean State\n\n**Goal**: Ensure codebase is in good state\n\n**Actions**:\n1. Ensure no broken code remains\n2. Ensure the project builds/runs without errors\n3. Display: \"Session complete. Run this command again to continue.\"\n\n**Implementation session ends.**\n\n---\n\n# Review Session\n\nExecute this section when `dev/features/active/feature_list.json` exists AND all items have status \"pass\" AND `dev/features/active/claude-progress.txt` does NOT contain \"Feature complete\".\n\n## Step 1: Confirm Completion\n\n**Actions**:\n1. Verify all items in `dev/features/active/feature_list.json` have status \"pass\"\n2. Run all verification commands one final time\n3. If any fail:\n   - Report: \"Item [id] verification failed\"\n   - Treat as implementation session - fix the item\n4. If all pass:\n   - Display: \"All [N] items verified. Proceeding to code review.\"\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary and Finalization\n\n**Goal**: Document what was accomplished, bump version, and archive artifacts\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n3. **Bump version in all version files**:\n   - Read `target_version` and `version_files` from `dev/features/active/feature_list.json`\n   - For each file in `version_files`, update version string to `target_version`:\n     - `pyproject.toml`: Update `version = \"X.Y.Z\"` line\n     - `package.json`: Update `\"version\": \"X.Y.Z\"` field\n     - `VERSION` or `.claude/VERSION`: Replace entire content with version\n     - `setup.py`: Update `version=\"X.Y.Z\"` in setup() call\n   - If a version file doesn't exist, skip it (warn user)\n\n4. **Update CHANGELOG.md**:\n   - If CHANGELOG.md doesn't exist, create it with Keep a Changelog header\n   - Prepend new version section at top:\n     ```markdown\n     ## [target_version] - YYYY-MM-DD\n\n     ### Added/Changed/Fixed\n     - [feature description]\n     - [list key items completed]\n\n     Architecture: [approach from feature_list.json]\n     ```\n\n5. Append to `dev/features/active/claude-progress.txt`:\n   ```\n   Session [N] ([date]):\n   Code review completed.\n   Issues found: [count]\n   [List issues and resolutions if any]\n   Version bumped: [current_version] → [target_version]\n   Feature complete.\n   ```\n\n6. **Archive feature artifacts**:\n   - Create `dev/features/completed/[target_version]-[feature-slug]/` directory\n   - Move `dev/features/active/feature_list.json` to archive\n   - Move `dev/features/active/claude-progress.txt` to archive\n   - Move `dev/features/active/init.sh` to archive (if exists)\n   - Remove `dev/features/active/` directory (now empty)\n\n7. Ask user: \"Ready to commit final state? Proceed?\"\n8. If approved:\n   - Stage all changes: version files, CHANGELOG.md, `dev/features/completed/`\n   - Git commit with message: `feat: complete [feature-name] v[target_version]`\n   - Suggest: \"Consider creating a git tag: `git tag v[target_version]`\"\n\n**Feature development complete.**\n\n---\n\n# Complete State\n\nExecute this section when `dev/features/active/claude-progress.txt` contains \"Feature complete\" OR when `dev/features/active/` is empty but `dev/features/completed/` has entries.\n\n**Actions**:\n1. Check for archived features in `dev/features/completed/`\n2. Display summary of most recent completed feature:\n   ```\n   Most Recent Feature: [name]\n   Version: [target_version]\n   Status: ARCHIVED\n   Location: dev/features/completed/[version]-[feature]/\n   ```\n3. Ask user: \"Would you like to:\"\n   - Start a new feature (run this command with a feature description)\n   - Review archived features (list `dev/features/completed/` contents)\n   - Exit\n\n---\n\n# Artifact Reference\n\n## Directory Structure\n\n```\ndev/features/\n├── active/                              # Current feature in progress\n│   ├── feature_list.json                # Machine-readable work items\n│   ├── claude-progress.txt              # Human-readable session log\n│   └── init.sh                          # Optional startup script\n└── completed/                           # Archived completed features\n    ├── v3.2.0-csv-export/\n    │   ├── feature_list.json\n    │   └── claude-progress.txt\n    └── v4.0.0-launcher-rewrite/\n        ├── feature_list.json\n        └── claude-progress.txt\n```\n\n- `dev/features/active/` is gitignored in consuming projects (work in progress)\n- `dev/features/completed/` is committed (documentation of completed features)\n\n## feature_list.json Schema\n\nLocation: `dev/features/active/feature_list.json`\n\n```json\n{\n  \"feature\": \"string - descriptive name of the feature\",\n  \"created\": \"string - ISO date (YYYY-MM-DD)\",\n  \"current_version\": \"string - version detected at start (e.g., 3.1.1)\",\n  \"target_version\": \"string - user-approved target version (e.g., 3.2.0)\",\n  \"version_files\": [\"array - files containing version (e.g., pyproject.toml, .claude/VERSION)\"],\n  \"architecture\": \"string - brief description of chosen approach\",\n  \"init_script\": \"string (optional) - path to startup script (e.g., ./init.sh)\",\n  \"items\": [\n    {\n      \"id\": \"string - sequential identifier (001, 002, etc.)\",\n      \"description\": \"string - what this item accomplishes\",\n      \"verification\": \"string - shell command returning exit code 0 on success\",\n      \"interactive_verification\": {\n        \"launch\": \"string (optional) - command to start interactive app\",\n        \"inputs\": [\"array (optional) - strings to send in order\"],\n        \"expect\": [\"array (optional) - patterns that must appear in output\"]\n      },\n      \"status\": \"string - 'pending' or 'pass'\",\n      \"session_completed\": \"number or null\"\n    }\n  ]\n}\n```\n\n**Rules**:\n- `id`, `description`, `verification`, `current_version`, `target_version`, `version_files` are IMMUTABLE after creation\n- Only `status` and `session_completed` may be modified during implementation\n- Aim for 10-20+ items for complex features; prefer too many small items over too few large ones\n- Items must be ordered by dependency\n- For web apps, prefer browser automation (Playwright, Puppeteer) verification over unit tests\n\n**Verification types**:\n- **Automated**: A shell command that returns exit code 0 on success (e.g., `python3 -m pytest tests/`)\n- **Manual**: Starts with `manual:` followed by instructions (e.g., `manual: Run the app, verify the menu looks correct`)\n  - Manual items prompt the user to confirm pass/fail\n  - Manual items are skipped during smoke tests (can't be automated)\n- **Interactive**: Optional `interactive_verification` object for terminal apps that need real TTY\n  - Uses tmux-cli to launch app in real terminal, send inputs, verify output\n  - Fields:\n    - `launch`: Command to start the interactive app (e.g., `python3 script.py`)\n    - `inputs`: Array of strings to send in order (e.g., `[\"q\"]` to quit)\n    - `expect`: Array of patterns that must appear in output (e.g., `[\"MENU\", \"QUIT\"]`)\n  - Example: Testing a TUI launcher that detects piped input as non-interactive\n  - Execution: `tmux-cli launch` → `tmux-cli send` for each input → `tmux-cli capture` → check expect patterns\n\n## Version Files Supported\n\n| File | Pattern | Example |\n|------|---------|---------|\n| `pyproject.toml` | `version = \"X.Y.Z\"` | Python (Poetry, uv) |\n| `package.json` | `\"version\": \"X.Y.Z\"` | JavaScript/Node |\n| `VERSION` | `X.Y.Z` or `vX.Y.Z` | Language-agnostic |\n| `.claude/VERSION` | `vX.Y.Z` | Claude Code projects |\n| `setup.py` | `version=\"X.Y.Z\"` | Python (setuptools) |\n| `Cargo.toml` | `version = \"X.Y.Z\"` | Rust |\n\n## claude-progress.txt Format\n\nLocation: `dev/features/active/claude-progress.txt`\n\nPlain text, human-readable, append-only. Each session entry includes:\n- Session number and date\n- What was completed\n- Verification results\n- Smoke test results (for implementation sessions)\n- What the next session should work on\n- Version info (current → target)\n\nThe phrase \"Feature complete\" in this file indicates the feature is done and triggers archival.\n\n---\n"
      },
      "plugins": [
        {
          "name": "feature-dev-harnessed",
          "version": "1.0.0",
          "description": "Feature development with integrated harness for multi-session execution. Fork of Anthropic's feature-dev with their long-running agent pattern.",
          "author": {
            "name": "chuggies510"
          },
          "source": "./",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add chuggies510/feature-dev-harnessed",
            "/plugin install feature-dev-harnessed@feature-dev-harnessed"
          ]
        }
      ]
    }
  ]
}