{
  "author": {
    "id": "Rahat-ch",
    "display_name": "Rahat Chowdhury",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/40510125?u=d3cf6f9df8e8810b3ac3361b36c259bac9f672b7&v=4",
    "url": "https://github.com/Rahat-ch",
    "bio": "Developer Relations Engineer",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 6,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "vibe-check",
      "version": null,
      "description": "Security audit for vibe coders. Scans for hardcoded secrets, Supabase RLS issues, missing auth, and more.",
      "owner_info": {
        "name": "Rahat Chowdhury",
        "email": "rahat.chowdhury@moveindustries.xyz"
      },
      "keywords": [],
      "repo_full_name": "Rahat-ch/vibe-check",
      "repo_url": "https://github.com/Rahat-ch/vibe-check",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-10T15:28:21Z",
        "created_at": "2026-01-10T15:14:19Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 624
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 456
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1715
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/auth.md",
          "type": "blob",
          "size": 3807
        },
        {
          "path": "commands/deps.md",
          "type": "blob",
          "size": 2615
        },
        {
          "path": "commands/rls.md",
          "type": "blob",
          "size": 3562
        },
        {
          "path": "commands/secrets.md",
          "type": "blob",
          "size": 2817
        },
        {
          "path": "commands/ship.md",
          "type": "blob",
          "size": 4219
        },
        {
          "path": "commands/vibe-check.md",
          "type": "blob",
          "size": 3496
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/vibe-auditor",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/vibe-auditor/SKILL.md",
          "type": "blob",
          "size": 3644
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"vibe-check\",\n  \"owner\": {\n    \"name\": \"Rahat Chowdhury\",\n    \"email\": \"rahat.chowdhury@moveindustries.xyz\"\n  },\n  \"metadata\": {\n    \"description\": \"Security audit for vibe coders. Scans for hardcoded secrets, Supabase RLS issues, missing auth, and more.\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"vibe-check\",\n      \"source\": \"./\",\n      \"description\": \"Security audit plugin for Next.js + Supabase projects - secrets, RLS, auth, dependencies\",\n      \"category\": \"security\",\n      \"tags\": [\"security\", \"audit\", \"vibe-coding\", \"nextjs\", \"supabase\", \"secrets\", \"rls\", \"devrel\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"vibe-check\",\n  \"description\": \"Security audit for vibe coders. Ship without the security nightmares.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Rahat Chowdhury\",\n    \"url\": \"https://github.com/Rahat-ch\"\n  },\n  \"homepage\": \"https://github.com/Rahat-ch/vibe-check\",\n  \"repository\": \"https://github.com/Rahat-ch/vibe-check\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"security\", \"audit\", \"vibe-coding\", \"nextjs\", \"supabase\", \"secrets\", \"rls\"]\n}\n",
        "README.md": "# Vibe Check\n\nSecurity audit plugin for vibe coders. Ship without the security nightmares.\n\n## Installation\n\nFirst, add the marketplace:\n```bash\n/plugin marketplace add Rahat-ch/vibe-check\n```\n\nThen install the plugin:\n```bash\n/plugin install vibe-check\n```\n\n## Commands\n\n### `/vibe-check:vibe-check`\nFull security audit - runs all checks and generates `VIBE_CHECK.md`.\n\n### `/vibe-check:secrets`\nScan for hardcoded API keys, exposed env vars, and .env files in git.\n\n### `/vibe-check:rls`\nAnalyze Supabase Row Level Security policies. Optionally verify via browser if Chrome extension is available.\n\n### `/vibe-check:auth`\nCheck API routes for missing authentication and authorization.\n\n### `/vibe-check:deps`\nRun npm audit and report vulnerable dependencies.\n\n### `/vibe-check:ship`\nPre-deploy checklist with ship-readiness score.\n\n## Auto-Trigger\n\nThe `vibe-auditor` skill automatically activates when you work with:\n- `.env` files\n- `supabase/` folder\n- API routes (`app/api/**`, `pages/api/**`)\n- Auth-related files\n\nIt provides quick security tips without interrupting your flow.\n\n## Ignore Patterns\n\n### Inline\n```typescript\nconst key = \"test-key\"; // vibe-ignore:secrets\n```\n\n### .vibeignore file\n```\n# Known safe files\nsrc/constants/public-keys.ts\n*.test.ts\n__mocks__/**\n```\n\n## Disclaimer\n\nThis tool provides educational guidance for common security pitfalls. It is NOT a replacement for professional security audits. You are solely responsible for your application's security.\n\n## Stack Support\n\nOptimized for:\n- Next.js (App Router & Pages Router)\n- Supabase\n- React\n\nWorks with other stacks but checks are most thorough for the above.\n\n## Requirements\n\n- Node.js 18+\n- Claude Code CLI\n\n## License\n\nMIT\n",
        "commands/auth.md": "---\ndescription: Check for missing authentication on API routes\n---\n\n# Auth Security Check\n\nScan API routes for missing authentication and authorization.\n\n**Usage:** `/vibe-check:auth`\n\n## Instructions\n\n### Step 1: Locate API Routes\n\n**Next.js App Router:**\n```\napp/api/**/route.ts\napp/api/**/route.js\n```\n\n**Next.js Pages Router:**\n```\npages/api/**/*.ts\npages/api/**/*.js\n```\n\n**Other Frameworks:**\n- `src/routes/**` (SvelteKit)\n- `server/api/**` (Nuxt)\n- `api/**` (generic)\n\n### Step 2: Detect Auth Patterns\n\n**Next-Auth (App Router):**\n```typescript\nimport { getServerSession } from \"next-auth\";\nimport { auth } from \"@/auth\";  // v5\nconst session = await getServerSession(authOptions);\nconst session = await auth();\n```\n\n**Next-Auth (Pages Router):**\n```typescript\nimport { getSession } from \"next-auth/react\";\nconst session = await getSession({ req });\n```\n\n**Supabase Auth:**\n```typescript\nimport { createRouteHandlerClient } from \"@supabase/auth-helpers-nextjs\";\nconst { data: { session } } = await supabase.auth.getSession();\n```\n\n**Clerk:**\n```typescript\nimport { auth } from \"@clerk/nextjs\";\nconst { userId } = auth();\n```\n\n**Custom Auth:**\n```typescript\nif (!req.headers.authorization)\nconst token = req.cookies.get(\"session\")\n```\n\n### Step 3: Flag Unprotected Routes\n\nFor each route handler (GET, POST, PUT, DELETE, PATCH):\n\n1. Check if any auth pattern exists\n2. Check if there's an early return for unauthorized\n3. Flag if route performs data mutation without auth\n\n**Severity:**\n- **CRITICAL**: POST/PUT/DELETE without auth on user data routes\n- **HIGH**: POST/PUT/DELETE without auth on any route\n- **MEDIUM**: GET without auth on user-specific data\n- **LOW**: GET without auth on public data\n\n### Step 4: Check Middleware\n\nLook for auth middleware:\n\n**Next.js middleware.ts:**\n```typescript\n// middleware.ts\nimport { withAuth } from \"next-auth/middleware\";\nexport default withAuth(...);\nexport const config = { matcher: [\"/api/:path*\"] };\n```\n\nIf middleware protects routes, reduce severity of findings.\n\n### Step 5: Authorization Checks\n\nBeyond authentication, check for authorization:\n\n**User accessing own data:**\n```typescript\n// Good\nconst user = await getUser(session.user.id);\nif (user.id !== session.user.id) return forbidden();\n\n// Bad - no ownership check\nconst user = await getUser(params.userId);\nreturn Response.json(user);\n```\n\n### Step 6: Check Server Actions\n\nFor Next.js 14+, check server actions:\n\n```typescript\n// app/actions.ts\n\"use server\"\n\nexport async function updateProfile(data: FormData) {\n  // Does this check auth?\n  const session = await auth();\n  if (!session) throw new Error(\"Unauthorized\");\n}\n```\n\n## Output Format\n\n```\n[HIGH] Unprotected API Route\nFile: app/api/users/[id]/route.ts:8\nHandler: DELETE\nIssue: No authentication check before deleting user\nRisk: Any client can delete any user account\n\nFix:\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\n\nexport async function DELETE(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  const session = await getServerSession(authOptions);\n\n  if (!session) {\n    return Response.json(\n      { error: \"Unauthorized\" },\n      { status: 401 }\n    );\n  }\n\n  // Also check authorization\n  if (session.user.id !== params.id) {\n    return Response.json(\n      { error: \"Forbidden\" },\n      { status: 403 }\n    );\n  }\n\n  // Now safe to delete\n  await deleteUser(params.id);\n  return Response.json({ success: true });\n}\n```\n\n## Auth Best Practices\n\n1. **Always check auth first** - Before any data operation\n2. **Check authorization too** - Auth != authz\n3. **Use middleware for broad protection** - Catch-all for API routes\n4. **Validate session on every request** - Don't trust client state\n5. **Return 401 for no auth, 403 for no authz** - Proper status codes\n",
        "commands/deps.md": "---\ndescription: Check for vulnerable dependencies via npm audit\n---\n\n# Dependency Security Check\n\nScan dependencies for known vulnerabilities.\n\n**Usage:** `/vibe-check:deps`\n\n## Instructions\n\n### Step 1: Run npm audit\n\n```bash\nnpm audit --json 2>/dev/null\n```\n\nIf pnpm:\n```bash\npnpm audit --json 2>/dev/null\n```\n\nIf yarn:\n```bash\nyarn audit --json 2>/dev/null\n```\n\n### Step 2: Parse Results\n\nnpm audit JSON structure:\n```json\n{\n  \"vulnerabilities\": {\n    \"package-name\": {\n      \"name\": \"package-name\",\n      \"severity\": \"high\",\n      \"via\": [...],\n      \"effects\": [...],\n      \"range\": \">=1.0.0 <1.2.3\",\n      \"fixAvailable\": true\n    }\n  },\n  \"metadata\": {\n    \"vulnerabilities\": {\n      \"critical\": 0,\n      \"high\": 2,\n      \"moderate\": 5,\n      \"low\": 1\n    }\n  }\n}\n```\n\n### Step 3: Categorize Findings\n\n| npm Severity | vibe-check Severity |\n|--------------|---------------------|\n| critical | CRITICAL |\n| high | HIGH |\n| moderate | MEDIUM |\n| low | LOW |\n\n### Step 4: Check for Fixable Issues\n\nFor each vulnerability, check `fixAvailable`:\n- If `true`: Include upgrade command\n- If `false`: Note as \"requires manual intervention\"\n\n### Step 5: Common Risky Packages\n\nFlag regardless of vulnerabilities:\n- **Outdated React** (<18) - Missing security fixes\n- **Old Next.js** (<13) - Known vulnerabilities\n- **Unmaintained packages** - No security updates\n\nCheck last publish date:\n```bash\nnpm view package-name time.modified\n```\n\n### Step 6: Lock File Analysis\n\nCheck for lock file presence:\n- `package-lock.json` (npm)\n- `pnpm-lock.yaml` (pnpm)\n- `yarn.lock` (yarn)\n\nMissing lock file = **MEDIUM** severity (inconsistent installs).\n\n## Output Format\n\n```\n[HIGH] Vulnerable Dependency: lodash\nPackage: lodash@4.17.20\nSeverity: High\nVulnerability: Prototype Pollution (CVE-2021-23337)\nAffected: lodash <4.17.21\n\nFix:\nnpm update lodash\n# or\nnpm install lodash@latest\n```\n\n```\n[CRITICAL] Critical Vulnerability: next\nPackage: next@12.3.0\nSeverity: Critical\nVulnerability: Server-Side Request Forgery\nAffected: next <13.4.6\n\nFix:\nnpm install next@latest\n\nNote: Major version upgrade - review breaking changes:\nhttps://nextjs.org/docs/upgrading\n```\n\n## Summary Output\n\n```\nDependency Audit Summary\n========================\nCritical: 1\nHigh: 2\nModerate: 5\nLow: 3\n\nFixable: 8/11\n\nRun to fix all:\nnpm audit fix\n\nRun for breaking changes:\nnpm audit fix --force\n```\n\n## Recommendations\n\n1. **Enable Dependabot** - Auto PRs for security updates\n2. **Use npm-check-updates** - `npx ncu -u` for bulk updates\n3. **Lock versions** - Avoid `^` for critical packages\n4. **Regular audits** - Run `npm audit` before each deploy\n",
        "commands/rls.md": "---\ndescription: Analyze Supabase Row Level Security policies\n---\n\n# RLS Security Check\n\nAnalyze Supabase Row Level Security policies for gaps and weaknesses.\n\n**Usage:** `/vibe-check:rls`\n\n## Instructions\n\n### Step 1: Locate Supabase Files\n\nCheck for Supabase project structure:\n```\nsupabase/\n├── config.toml\n├── migrations/\n│   ├── 20240101000000_init.sql\n│   └── ...\n└── seed.sql\n```\n\nIf no `supabase/` folder, check for:\n- `.sql` files in project root\n- `prisma/` folder (different approach needed)\n- Direct Supabase client usage without migrations\n\n### Step 2: Parse Migration Files\n\nRead all `.sql` files in `supabase/migrations/`.\n\nExtract:\n1. **CREATE TABLE statements** - list of tables\n2. **ALTER TABLE ... ENABLE ROW LEVEL SECURITY** - tables with RLS\n3. **CREATE POLICY statements** - policy definitions\n\n### Step 3: Identify RLS Gaps\n\n**Missing RLS (HIGH):**\nTables with CREATE TABLE but no corresponding:\n```sql\nALTER TABLE table_name ENABLE ROW LEVEL SECURITY;\n```\n\n**Overly Permissive Policies (HIGH):**\n```sql\nCREATE POLICY \"...\" ON table_name FOR ALL USING (true);\nCREATE POLICY \"...\" ON table_name FOR ALL WITH CHECK (true);\n```\n\n**Missing Operation Policies (MEDIUM):**\nTable has SELECT policy but missing INSERT/UPDATE/DELETE policies.\n\n**No User Scoping (MEDIUM):**\nPolicies that don't reference `auth.uid()`:\n```sql\nCREATE POLICY \"...\" USING (status = 'published');  -- No user check\n```\n\n### Step 4: Check config.toml\n\nRead `supabase/config.toml` for security settings:\n\n```toml\n[auth]\nenable_signup = true  # Should be false if invite-only\n```\n\nFlag if:\n- `enable_signup = true` in production configs\n- Missing rate limiting settings\n- Weak JWT expiry settings\n\n### Step 5: Offer Browser Verification\n\nAfter static analysis, use AskUserQuestion to offer:\n\n```\nWant me to verify RLS policies in your live Supabase dashboard?\nRequires: Claude Chrome extension + logged into Supabase\n\nOptions:\n- Yes, check via browser\n- No, skip (I'll check manually)\n```\n\nIf yes, use Claude Chrome extension:\n\n1. Get project URL from `supabase/.env` or ask user\n2. Navigate to `https://supabase.com/dashboard/project/[ref]/auth/policies`\n3. Use `read_page` to extract RLS status for each table\n4. Compare with migration expectations\n5. Report discrepancies\n\n### Step 6: Provide Manual Verification Guide\n\nAlways include:\n\n```\nManual RLS Verification:\n\n1. Go to Supabase Dashboard → Table Editor\n2. Click each table → \"View Policies\" (shield icon)\n3. Verify:\n   - RLS is \"Enabled\" (green badge)\n   - Policies exist for SELECT/INSERT/UPDATE/DELETE as needed\n   - Conditions reference auth.uid() appropriately\n\nSQL Query to check RLS status:\nSELECT schemaname, tablename, rowsecurity\nFROM pg_tables\nWHERE schemaname = 'public';\n```\n\n## Output Format\n\n```\n[HIGH] Missing RLS on table: profiles\nFile: supabase/migrations/001_init.sql:45\nIssue: Table created without Row Level Security\nRisk: Any authenticated user can read/write all rows\n\nFix:\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view own profile\"\n  ON profiles FOR SELECT\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update own profile\"\n  ON profiles FOR UPDATE\n  USING (auth.uid() = user_id);\n```\n\n## Common RLS Patterns\n\n**User-owned data:**\n```sql\nUSING (auth.uid() = user_id)\n```\n\n**Public read, owner write:**\n```sql\nFOR SELECT USING (true)\nFOR INSERT/UPDATE/DELETE USING (auth.uid() = user_id)\n```\n\n**Role-based:**\n```sql\nUSING (\n  auth.uid() IN (\n    SELECT user_id FROM user_roles WHERE role = 'admin'\n  )\n)\n```\n",
        "commands/secrets.md": "---\ndescription: Scan for hardcoded secrets and exposed environment variables\n---\n\n# Secrets Scan\n\nDetect hardcoded API keys, tokens, and exposed environment variables.\n\n**Usage:** `/vibe-check:secrets`\n\n## Instructions\n\n### Step 1: Pattern-Based Detection\n\nSearch codebase for known secret patterns using Grep:\n\n**API Keys & Tokens:**\n```regex\nSUPABASE_(ANON|SERVICE_ROLE)_KEY\\s*[:=]\\s*[\"'][^\"']+[\"']\nOPENAI_API_KEY\\s*[:=]\\s*[\"'][^\"']+[\"']\nAWS_(ACCESS_KEY_ID|SECRET_ACCESS_KEY)\\s*[:=]\\s*[\"'][^\"']+[\"']\nSTRIPE_(SECRET|PUBLISHABLE)_KEY\\s*[:=]\\s*[\"'][^\"']+[\"']\nANTHROPIC_API_KEY\\s*[:=]\\s*[\"'][^\"']+[\"']\n```\n\n**Direct Value Patterns:**\n```regex\nsk-[A-Za-z0-9]{48}           # OpenAI keys\nghp_[A-Za-z0-9]{36}          # GitHub PAT\ngho_[A-Za-z0-9]{36}          # GitHub OAuth\nghu_[A-Za-z0-9]{36}          # GitHub user token\nghs_[A-Za-z0-9]{36}          # GitHub server token\nghr_[A-Za-z0-9]{36}          # GitHub refresh token\n-----BEGIN.*PRIVATE KEY-----  # Private keys\neyJ[A-Za-z0-9_-]*\\.eyJ       # JWTs (base64 encoded)\n```\n\n**Database Credentials:**\n```regex\nDATABASE_URL\\s*[:=]\\s*[\"'][^\"']+[\"']\npostgres://[^:]+:[^@]+@\nmongodb(\\+srv)?://[^:]+:[^@]+@\n```\n\nExclude:\n- `node_modules/`\n- `*.test.*`, `*.spec.*`\n- Files matching `.vibeignore` patterns\n\n### Step 2: Check .env Files in Git\n\n```bash\ngit ls-files | grep -E '\\.env($|\\.local|\\.production|\\.development)'\n```\n\nIf any .env files are tracked, flag as **CRITICAL**.\n\nAlso check `.gitignore` includes:\n```\n.env\n.env.local\n.env.*.local\n```\n\n### Step 3: Frontend Environment Exposure\n\nIn Next.js projects, check for risky NEXT_PUBLIC_ usage:\n\n```bash\ngrep -r \"NEXT_PUBLIC_\" --include=\"*.ts\" --include=\"*.tsx\" --include=\"*.js\"\n```\n\nFlag if NEXT_PUBLIC_ contains:\n- `SECRET`\n- `PRIVATE`\n- `KEY` (except ANON_KEY which is safe for public)\n- `PASSWORD`\n- `TOKEN` (except refresh patterns)\n\n### Step 4: Entropy Analysis\n\nFor strings > 20 chars, calculate Shannon entropy. Flag if > 4.5 bits/char.\n\nFormula: `H = -Σ p(x) log2 p(x)` where p(x) is frequency of each character.\n\nHigh-entropy strings are likely secrets even without known patterns.\n\n### Step 5: Optional Gitleaks Integration\n\nCheck if gitleaks is installed:\n```bash\nwhich gitleaks\n```\n\nIf available, run:\n```bash\ngitleaks detect --source . --report-format json --report-path /tmp/gitleaks.json\n```\n\nParse and include results.\n\n## Output Format\n\nFor each finding:\n```\n[CRITICAL] Hardcoded Supabase Service Key\nFile: src/lib/supabase.ts:15\nFound: SUPABASE_SERVICE_ROLE_KEY = \"eyJ...\"\nRisk: Service key has full database access, bypasses RLS\n\nFix:\n1. Remove from source code immediately\n2. Add to .env.local (not committed)\n3. Rotate the key in Supabase dashboard\n4. Use NEXT_PUBLIC_SUPABASE_ANON_KEY for client-side\n```\n\n## Ignore Patterns\n\nRespect `// vibe-ignore:secrets` comments and `.vibeignore` file.\n",
        "commands/ship.md": "---\ndescription: Pre-deploy security checklist with ship-readiness score\n---\n\n# Ship Check - Pre-Deploy Audit\n\nFinal security validation before deployment.\n\n**Usage:** `/vibe-check:ship`\n\n## Instructions\n\nRun all vibe-check scans and generate deploy-readiness assessment.\n\n### Step 1: Run Full Audit\n\nExecute all checks:\n1. `/vibe-check:secrets` - Secrets scan\n2. `/vibe-check:rls` - RLS analysis\n3. `/vibe-check:auth` - Auth review\n4. `/vibe-check:deps` - Dependency audit\n\nCollect all findings.\n\n### Step 2: Calculate Readiness Score\n\n**Base Score: 100**\n\nDeductions:\n- Critical finding: -25 points each\n- High finding: -10 points each\n- Medium finding: -5 points each\n- Low finding: -2 points each\n\nMinimum score: 0\n\n### Step 3: Ship Decision\n\n| Score | Status | Action |\n|-------|--------|--------|\n| 90-100 | SHIP IT | Good to deploy |\n| 70-89 | CAUTION | Fix high/critical before prod |\n| 50-69 | RISKY | Address issues first |\n| 0-49 | BLOCKED | Do not deploy |\n\n**Blocking Conditions (regardless of score):**\n- Any CRITICAL finding = BLOCKED\n- .env file in git = BLOCKED\n- Exposed service keys = BLOCKED\n\n### Step 4: Pre-Deploy Checklist\n\nGenerate checklist with pass/fail:\n\n```markdown\n## Pre-Deploy Checklist\n\n### Secrets\n- [ ] No hardcoded API keys in source\n- [ ] .env files not tracked in git\n- [ ] .gitignore includes .env*\n- [ ] NEXT_PUBLIC_ vars are safe for public\n\n### Supabase RLS\n- [ ] RLS enabled on all tables\n- [ ] No overly permissive policies (USING true)\n- [ ] Policies reference auth.uid()\n\n### Authentication\n- [ ] API routes protected\n- [ ] Middleware configured for /api/*\n- [ ] Session validation on mutations\n\n### Dependencies\n- [ ] No critical vulnerabilities\n- [ ] No high vulnerabilities\n- [ ] Lock file present and committed\n\n### Environment\n- [ ] Production env vars set in hosting platform\n- [ ] Development secrets not in production\n- [ ] CORS configured correctly\n```\n\n### Step 5: Generate Report\n\nCreate `VIBE_CHECK.md` with full findings and checklist.\n\n### Step 6: Next Steps\n\nBased on status, provide actionable guidance:\n\n**SHIP IT:**\n```\nReady to deploy! Consider:\n- Enable Dependabot for ongoing security updates\n- Set up monitoring for auth failures\n- Schedule quarterly security reviews\n```\n\n**CAUTION:**\n```\nAddress these before production:\n1. [List high findings]\n\nCan deploy to staging/preview for testing.\n```\n\n**RISKY:**\n```\nFix these issues first:\n1. [List all findings by severity]\n\nDeploy only to isolated test environments.\n```\n\n**BLOCKED:**\n```\nSTOP - Do not deploy!\n\nCritical issues found:\n1. [List critical findings]\n\nThese must be fixed immediately.\nExposed secrets should be rotated NOW.\n```\n\n## Output Format\n\n```\n╔════════════════════════════════════════╗\n║           VIBE CHECK: SHIP             ║\n╠════════════════════════════════════════╣\n║                                        ║\n║   Deploy Readiness Score: 85/100       ║\n║   Status: CAUTION                      ║\n║                                        ║\n╠════════════════════════════════════════╣\n║  Findings:                             ║\n║  ├─ Critical: 0                        ║\n║  ├─ High: 2                            ║\n║  ├─ Medium: 3                          ║\n║  └─ Low: 1                             ║\n╠════════════════════════════════════════╣\n║                                        ║\n║  Fix 2 HIGH issues before prod deploy  ║\n║  See VIBE_CHECK.md for details     ║\n║                                        ║\n╚════════════════════════════════════════╝\n```\n\n## Quick Fix Mode\n\nIf user wants to address issues:\n\n```\nWould you like me to help fix these issues?\n- [Fix all auto-fixable] (npm audit fix, add .gitignore entries)\n- [Show fix for specific issue]\n- [Skip - I'll fix manually]\n```\n",
        "commands/vibe-check.md": "---\ndescription: Run a full security audit on your vibe-coded project\n---\n\n# Vibe Check - Full Security Audit\n\nScan your project for common security issues that plague vibe-coded projects.\n\n**Usage:** `/vibe-check`\n\n## First Run Disclaimer\n\nBefore running any checks, verify if `.vibecheck/acknowledged` file exists in project root.\n\nIf NOT exists, display this disclaimer and use AskUserQuestion:\n\n```\nDISCLAIMER\n\nVibe Check is a helpful guide for common security pitfalls - NOT a replacement for professional security audits.\n\nBy using this tool you acknowledge:\n- This is educational guidance, not a comprehensive security audit\n- Passing all checks does NOT guarantee your app is secure\n- You are solely responsible for your application's security\n- Vibe Check and its creators assume no liability\n\nFor production apps handling sensitive data, always get a professional security review.\n\nDo you understand and accept these terms?\n```\n\nOptions:\n- \"Yes, I understand - continue\"\n- \"No, I do not accept\"\n\nIf user accepts:\n- Create `.vibecheck/acknowledged` file with timestamp\n- Continue with audit\n\nIf user declines:\n- Do not run any checks\n- Suggest they revisit when ready to proceed\n\nFor subsequent runs, skip disclaimer if `.vibecheck/acknowledged` exists.\n\n---\n\n## What Gets Checked\n\n1. **Secrets** - Hardcoded API keys, exposed env vars, .env in git\n2. **Supabase RLS** - Missing or weak Row Level Security policies\n3. **Auth** - Unprotected API routes, missing session checks\n4. **Dependencies** - Known vulnerabilities via npm audit\n\n## Instructions\n\nRun all security checks in priority order:\n\n### Step 1: Secrets Scan\nUse Grep to search for hardcoded secrets:\n\n```\nPatterns to search:\n- SUPABASE_.*KEY\n- OPENAI_API_KEY\n- AWS_(ACCESS|SECRET)\n- STRIPE_(SECRET|PUBLISHABLE)_KEY\n- DATABASE_URL\n- PRIVATE_KEY\n- -----BEGIN.*PRIVATE KEY-----\n- gh[pousr]_[A-Za-z0-9]{36,}\n- sk-[A-Za-z0-9]{48}\n```\n\nCheck if .env files are tracked in git:\n```bash\ngit ls-files | grep -E '\\.env($|\\.)'\n```\n\nCheck for NEXT_PUBLIC_ vars that shouldn't be public.\n\n### Step 2: Supabase RLS Analysis\nIf `supabase/` folder exists:\n- Read migration files in `supabase/migrations/`\n- Look for CREATE TABLE without corresponding RLS policies\n- Flag policies using `USING (true)` or `WITH CHECK (true)`\n- Check `supabase/config.toml` for auth settings\n\nOffer browser check if Claude Chrome extension available.\n\n### Step 3: Auth Review\nScan API routes:\n- `app/api/**/route.ts` (App Router)\n- `pages/api/**/*.ts` (Pages Router)\n\nFlag routes missing:\n- `getServerSession` / `auth()` calls\n- `NextAuth` middleware\n- Custom auth checks\n\n### Step 4: Dependency Audit\nRun npm audit:\n```bash\nnpm audit --json 2>/dev/null\n```\n\nParse and categorize by severity.\n\n### Step 5: Generate Report\n\nCreate `VIBE_CHECK.md` at project root with:\n\n```markdown\n# Security Audit Report\nGenerated: [date] | vibe-check v1.0.0\n\n## Summary\n| Severity | Count |\n|----------|-------|\n| Critical | X |\n| High | X |\n| Medium | X |\n| Low | X |\n\n## Deploy Readiness: X/100\n\n## Findings\n[List each finding with severity, file, issue, risk, and fix]\n```\n\n## Severity Classification\n\n| Level | Criteria |\n|-------|----------|\n| **Critical** | Exposed prod secrets, no auth on sensitive endpoints |\n| **High** | Missing RLS, auth bypass possible |\n| **Medium** | Weak patterns, potential issues |\n| **Low** | Best practice violations |\n\n## Output\n\n- Console summary with color-coded findings\n- `VIBE_CHECK.md` report file\n- Suggested fixes for each issue\n",
        "skills/vibe-auditor/SKILL.md": "---\nname: vibe-auditor\ndescription: Security auditor for vibe-coded projects. Automatically triggered when working with security-sensitive files or detecting risky code patterns.\nallowed-tools: Read, Grep, Glob, Bash, AskUserQuestion\n---\n\n# Vibe Auditor - Proactive Security\n\nYou are a security-focused assistant that proactively identifies security issues in vibe-coded projects. Activate when you detect risky patterns or security-sensitive file changes.\n\n## Trigger Patterns\n\n### File Patterns - Activate when user works with:\n\n**Environment & Secrets:**\n- `.env*` files\n- `**/secrets/**`\n- `**/credentials/**`\n\n**Supabase:**\n- `supabase/**`\n- `**/supabase*.ts`\n- `**/supabase*.js`\n\n**API Routes:**\n- `app/api/**`\n- `pages/api/**`\n- `src/routes/**`\n\n**Auth:**\n- `**/auth/**`\n- `**/middleware.ts`\n- `**/middleware.js`\n- `**/*auth*.ts`\n- `**/*auth*.js`\n\n**Database:**\n- `prisma/schema.prisma`\n- `*.sql`\n- `drizzle/**`\n\n### Code Patterns - Flag immediately when you see:\n\n**Hardcoded Secrets:**\n```\nsk-[A-Za-z0-9]{48}          # OpenAI\neyJhbGciOiJ...              # JWT tokens\nghp_[A-Za-z0-9]{36}         # GitHub PAT\nSUPABASE_SERVICE_ROLE_KEY   # Supabase service key in source\n```\n\n**Dangerous Patterns:**\n```typescript\n// Direct DB access without auth\nawait supabase.from('users').select('*')  // No RLS context\n\n// Hardcoded credentials\nconst client = new Client({ password: \"actual_password\" })\n\n// SQL injection risk\nconst query = `SELECT * FROM users WHERE id = ${userId}`\n\n// Missing auth in API route\nexport async function POST(req) {\n  const data = await req.json()\n  await db.insert(data)  // No session check!\n}\n```\n\n## Response Behavior\n\nWhen triggered, provide a **brief, non-intrusive warning**:\n\n### For File Changes:\n```\nHeads up - you're editing [file type]. Quick security notes:\n- [1-2 relevant tips]\n- Run /vibe-check:[category] for full scan\n```\n\n### For Risky Code:\n```\nPotential security issue detected:\n[Brief description]\n\nSuggested fix:\n[Short code snippet]\n\nWant me to run /vibe-check:secrets for a full scan?\n```\n\n## Examples\n\n### Example 1: User creates .env file\n```\nCreating .env file - good practice for secrets!\n\nQuick checks:\n- Ensure .gitignore includes .env*\n- Use NEXT_PUBLIC_ prefix only for client-safe values\n- Never commit .env.local to git\n\nRun /vibe-check:secrets to verify nothing's exposed.\n```\n\n### Example 2: User writes API route without auth\n```\nThis API route doesn't appear to have authentication.\n\nIf this handles user data, add session check:\n\nconst session = await getServerSession(authOptions);\nif (!session) {\n  return Response.json({ error: \"Unauthorized\" }, { status: 401 });\n}\n\nRun /vibe-check:auth for full API route scan.\n```\n\n### Example 3: User creates Supabase table migration\n```\nNew table detected in migration.\n\nDon't forget RLS:\n\nALTER TABLE your_table ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can access own data\"\n  ON your_table\n  USING (auth.uid() = user_id);\n\nRun /vibe-check:rls to analyze all policies.\n```\n\n## Tone Guidelines\n\n- **Helpful, not preachy** - Quick tips, not lectures\n- **Concise** - 2-3 lines max for inline warnings\n- **Actionable** - Always include fix or next step\n- **Non-blocking** - Don't interrupt workflow, just inform\n- **Offer more** - Point to full /vibe-check commands for deep dives\n\n## Do NOT Trigger For\n\n- Test files (`*.test.*`, `*.spec.*`)\n- Mock data with obviously fake secrets\n- Documentation files\n- Node modules\n- Build output\n\n## Integration with /vibe-check\n\nWhen user runs any `/vibe-check` command, defer to that command's full instructions. This skill provides lightweight, proactive hints during regular development.\n"
      },
      "plugins": [
        {
          "name": "vibe-check",
          "source": "./",
          "description": "Security audit plugin for Next.js + Supabase projects - secrets, RLS, auth, dependencies",
          "category": "security",
          "tags": [
            "security",
            "audit",
            "vibe-coding",
            "nextjs",
            "supabase",
            "secrets",
            "rls",
            "devrel"
          ],
          "categories": [
            "audit",
            "devrel",
            "nextjs",
            "rls",
            "secrets",
            "security",
            "supabase",
            "vibe-coding"
          ],
          "install_commands": [
            "/plugin marketplace add Rahat-ch/vibe-check",
            "/plugin install vibe-check@vibe-check"
          ]
        }
      ]
    }
  ]
}