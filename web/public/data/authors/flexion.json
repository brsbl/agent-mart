{
  "author": {
    "id": "flexion",
    "display_name": "Flexion Inc.",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/2545311?v=4",
    "url": "https://github.com/flexion",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 14,
      "total_skills": 3,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "claude-domestique",
      "version": null,
      "description": "Session persistence - persist context across conversation resets with branch-based session tracking",
      "owner_info": {
        "name": "Flexion"
      },
      "keywords": [],
      "repo_full_name": "flexion/claude-domestique",
      "repo_url": "https://github.com/flexion/claude-domestique",
      "repo_description": "Claude Code plugin for strategic session workflow management - like a cycling domestique for your development process",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-27T20:59:16Z",
        "created_at": "2025-11-16T13:08:36Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 698
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 456
        },
        {
          "path": "mantra",
          "type": "tree",
          "size": null
        },
        {
          "path": "mantra/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "mantra/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 561
        },
        {
          "path": "mantra/README.md",
          "type": "blob",
          "size": 7741
        },
        {
          "path": "mantra/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "mantra/commands/assess.md",
          "type": "blob",
          "size": 3104
        },
        {
          "path": "mantra/commands/make-rule.md",
          "type": "blob",
          "size": 3758
        },
        {
          "path": "mantra/commands/troubleshoot.md",
          "type": "blob",
          "size": 4373
        },
        {
          "path": "mantra/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "mantra/hooks/__tests__",
          "type": "tree",
          "size": null
        },
        {
          "path": "mantra/hooks/__tests__/session-monitor.test.js",
          "type": "blob",
          "size": 2757
        },
        {
          "path": "mantra/hooks/hooks.json",
          "type": "blob",
          "size": 598
        },
        {
          "path": "mantra/hooks/session-monitor.js",
          "type": "blob",
          "size": 3858
        },
        {
          "path": "memento",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 546
        },
        {
          "path": "memento/README.md",
          "type": "blob",
          "size": 7187
        },
        {
          "path": "memento/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/commands/session.md",
          "type": "blob",
          "size": 2040
        },
        {
          "path": "memento/commands/start.md",
          "type": "blob",
          "size": 3761
        },
        {
          "path": "memento/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/hooks/__tests__",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/hooks/__tests__/checkpoint.test.js",
          "type": "blob",
          "size": 6254
        },
        {
          "path": "memento/hooks/__tests__/session-startup.test.js",
          "type": "blob",
          "size": 10478
        },
        {
          "path": "memento/hooks/checkpoint.js",
          "type": "blob",
          "size": 5647
        },
        {
          "path": "memento/hooks/hooks.json",
          "type": "blob",
          "size": 1113
        },
        {
          "path": "memento/hooks/session-startup.js",
          "type": "blob",
          "size": 13299
        },
        {
          "path": "memento/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/skills/resume",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/skills/resume/SKILL.md",
          "type": "blob",
          "size": 2128
        },
        {
          "path": "memento/skills/session-manager",
          "type": "tree",
          "size": null
        },
        {
          "path": "memento/skills/session-manager/SKILL.md",
          "type": "blob",
          "size": 1762
        },
        {
          "path": "memento/skills/session.md",
          "type": "blob",
          "size": 839
        },
        {
          "path": "onus",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 763
        },
        {
          "path": "onus/README.md",
          "type": "blob",
          "size": 7429
        },
        {
          "path": "onus/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/commands/close.md",
          "type": "blob",
          "size": 3790
        },
        {
          "path": "onus/commands/commit.md",
          "type": "blob",
          "size": 4124
        },
        {
          "path": "onus/commands/create.md",
          "type": "blob",
          "size": 3501
        },
        {
          "path": "onus/commands/fetch.md",
          "type": "blob",
          "size": 3714
        },
        {
          "path": "onus/commands/init.md",
          "type": "blob",
          "size": 3367
        },
        {
          "path": "onus/commands/pr.md",
          "type": "blob",
          "size": 5323
        },
        {
          "path": "onus/commands/status.md",
          "type": "blob",
          "size": 3564
        },
        {
          "path": "onus/commands/update.md",
          "type": "blob",
          "size": 3997
        },
        {
          "path": "onus/commands/validate-criteria.md",
          "type": "blob",
          "size": 3465
        },
        {
          "path": "onus/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/hooks/__tests__",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/hooks/__tests__/work-item.test.js",
          "type": "blob",
          "size": 11573
        },
        {
          "path": "onus/hooks/hooks.json",
          "type": "blob",
          "size": 571
        },
        {
          "path": "onus/hooks/work-item.js",
          "type": "blob",
          "size": 12207
        },
        {
          "path": "onus/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/skills/work-item-handler",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/skills/work-item-handler/SKILL.md",
          "type": "blob",
          "size": 2554
        },
        {
          "path": "onus/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/templates/config",
          "type": "tree",
          "size": null
        },
        {
          "path": "onus/templates/config/README.md",
          "type": "blob",
          "size": 1932
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-domestique\",\n  \"owner\": {\n    \"name\": \"Flexion\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"memento\",\n      \"source\": \"./memento\",\n      \"description\": \"Session persistence - persist context across conversation resets with branch-based session tracking\",\n      \"version\": \"0.3.8\"\n    },\n    {\n      \"name\": \"mantra\",\n      \"source\": \"./mantra\",\n      \"description\": \"Context refresh - periodic re-injection of behavioral guidance to prevent context drift\",\n      \"version\": \"0.4.2\"\n    },\n    {\n      \"name\": \"onus\",\n      \"source\": \"./onus\",\n      \"description\": \"Work-item automation - fetches issues, generates commits/PRs, syncs progress\",\n      \"version\": \"0.3.5\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"domestique\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Claude Domestique - Your strategic coding partner. Marketplace for memento, mantra, and onus plugins.\",\n  \"author\": {\n    \"name\": \"David Puglielli\"\n  },\n  \"repository\": \"https://github.com/flexion/claude-domestique\",\n  \"homepage\": \"https://github.com/flexion/claude-domestique\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"marketplace\", \"session\", \"context\", \"work-items\"],\n  \"marketplace\": true\n}\n",
        "mantra/.claude-plugin/plugin.json": "{\n  \"name\": \"mantra\",\n  \"version\": \"0.4.2\",\n  \"description\": \"Behavioral rules for Claude Code sessions - auto-injected via hooks, zero config\",\n  \"author\": {\n    \"name\": \"David Puglielli\"\n  },\n  \"repository\": \"https://github.com/flexion/claude-domestique\",\n  \"homepage\": \"https://github.com/flexion/claude-domestique/tree/main/mantra\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"context\",\n    \"refresh\",\n    \"guidance\",\n    \"drift-prevention\"\n  ],\n  \"commands\": [\n    \"./commands/make-rule.md\",\n    \"./commands/assess.md\",\n    \"./commands/troubleshoot.md\"\n  ]\n}\n",
        "mantra/README.md": "# mantra\n\n> I told you. You agreed. You forgot. Repeat.\n\nBehavioral rules plugin for Claude Code sessions.\n\nClaude is brilliant. Claude is helpful. Claude also has the memory of a goldfish in a context window. You've written the perfect CLAUDE.md. You've carefully documented your project conventions. Claude reads it. Claude agrees. Claude then proceeds to ignore half of it by turn 47.\n\n**mantra** solves this by providing curated behavioral rules that are automatically loaded via Claude Code's native `.claude/rules/` mechanism‚Äîensuring consistent behavior from turn 1 to turn 100.\n\n### Flexion Fundamentals\n\nmantra helps developers embody Flexion fundamentals throughout long sessions:\n\n- **Be skeptical and curious** ‚Äî Keeps Claude questioning assumptions and seeking evidence, not pattern-matching\n- **Never compromise on quality** ‚Äî Maintains consistent standards from turn 1 to turn 100\n- **Listen with humility** ‚Äî Enforces peer-not-subordinate stance, deferring to evidence over agreement\n\n## Features\n\n- **Zero config** - Rules injected automatically via hooks, no setup required\n- **Token efficient** - Compact YAML frontmatter (~89% token reduction vs prose)\n- **Status indicator** - Shows rules loaded and context freshness on every prompt\n- **Curated rules** - Ships with behavior, testing, git, and format conventions\n- **Periodic refresh** - Re-injects rules every 10 prompts to prevent drift\n- **Plugin family aware** - Automatically loads rules from sibling plugins (memento, onus)\n- **Easy customization** - Create your own rules with `/mantra:make-rule`\n- **On-demand details** - Companion files provide elaboration when needed\n\n## Installation\n\n```bash\n# Add the marketplace\n/plugin marketplace add flexion/claude-domestique\n\n# Install the plugin\n/plugin install mantra@claude-domestique\n```\n\nThat's it. Rules are injected automatically on every session start‚Äîno initialization required.\n\n## How It Works\n\nmantra uses Claude Code's hook system for automatic context injection:\n\n| Hook | When | What Happens |\n|------|------|--------------|\n| **SessionStart** | New conversation | Injects all rules + companion docs path |\n| **UserPromptSubmit** | Every prompt | Shows status line, refreshes context every 10 prompts |\n\n### What Gets Injected\n\nOn session start, mantra injects:\n\n| Rule | Purpose |\n|------|---------|\n| `behavior.md` | AI behavior (skeptical-first, evidence-based) |\n| `context-format.md` | Context module format spec |\n| `format-guide.md` | Compact YAML conventions |\n| `test.md` | Testing conventions (TDD workflow) |\n\nWhen sibling plugins are installed (memento, onus), their rules are also loaded:\n- `git.md` - Git workflow (from onus)\n- `sessions.md` - Session management (from memento)\n- `work-items.md` - Work item integration (from onus)\n\n### Status Line\n\nEvery prompt shows mantra status:\n\n```\nüìç Mantra: #3 ‚úì\n```\n\n**Components:**\n- **#N** - Prompt counter since session start\n- **‚úì** - Context injection successful\n\n**IDE Compatibility:**\n\n| Environment | Status Line |\n|-------------|-------------|\n| Terminal/CLI | Full support |\n| VS Code Integrated Terminal | Full support |\n| VS Code Extension (GUI panel) | Not supported |\n| JetBrains IDEs | Full support (uses CLI) |\n\nThe status line is a CLI feature. In VS Code, use Claude Code from the integrated terminal (`` Ctrl+` ``) to see the status line.\n\n### Commands\n\n| Command | Description |\n|---------|-------------|\n| `/mantra:make-rule` | Create compact frontmatter rule from verbose markdown |\n| `/mantra:assess` | Structured critical assessment (correctness, architecture, alternatives, risks) |\n| `/mantra:troubleshoot` | Evidence-based debugging (requires 3+ documented examples) |\n\n### Creating Custom Rules\n\nUse `/mantra:make-rule` to create your own rules:\n\n1. Write a verbose, human-readable markdown file (e.g., `docs/code-review.md`)\n2. Run `/mantra:make-rule docs/code-review.md`\n3. Claude converts it to token-efficient frontmatter\n4. Identify which rules are CRITICAL (used sparingly)\n5. Save compact version to `.claude/rules/code-review.md`\n\n**What happens to the source?** The original verbose file is preserved as a \"companion\" - the compact rule references it via `companion: docs/code-review.md`. Claude loads the compact rules automatically but can read the companion file on-demand for detailed examples or clarification.\n\n## Rule File Format\n\nEach rule file is a **frontmatter-only markdown file**:\n\n```markdown\n---\n# AI-managed context file - optimized for token efficiency\ncompanion: behavior.md\n\nMANDATORY-REREAD: before-implementation-proposal-response (use-thinking-block)\n\n## CRITICAL ASSESSMENT (BLOCKING REQUIREMENT)\nassess-first: correctness, architecture, alternatives, risks\nstance: skeptical-default, find-problems-not-agreement\nnever: eager-agreement, sycophantic-tone, yes-without-analysis\n\n## IMPLEMENTATION BEHAVIOR\nmode: discuss-approach-first (non-trivial), build-first (trivial)\nimplement: minimal-working, fix-actual-errors (not speculative-fixes)\n---\n```\n\nNo markdown body‚Äîjust frontmatter containing compact YAML rules.\n\n### Emphasis Markers\n\nUse sparingly for critical rules:\n\n| Marker | Use When |\n|--------|----------|\n| `MANDATORY-REREAD:` | Must re-read before specific actions |\n| `## SECTION (BLOCKING REQUIREMENT)` | Entire section is non-negotiable |\n| `required-before:` | Must happen before an action |\n| `never:` | Absolute prohibitions |\n| `enforcement:` | If‚Üíthen trigger rules |\n\n## Default Behavior Overrides\n\nMantra isn't just about remembering project conventions. It's about **overriding Claude's default tendencies** that make it less useful as a coding partner.\n\n### Anti-Sycophancy\n\n| Default Claude | Mantra Override |\n|----------------|-----------------|\n| Eager agreement (\"Great idea!\") | Skeptical assessment first |\n| Yes without analysis | Assess correctness, architecture, risks before agreeing |\n| Subordinate tone | Peer-not-subordinate stance |\n| Validate user's approach | Find problems, challenge assumptions |\n\n### Evidence-Based Troubleshooting\n\n| Default Claude | Mantra Override |\n|----------------|-----------------|\n| Pattern-match from training data | Evidence-based only, NO guessing |\n| Jump to common solutions | Require 3+ documented examples |\n| Single-source answers | Cross-reference multiple sources |\n| Fill gaps with speculation | Research until gaps filled |\n\n### Implementation Discipline\n\n| Default Claude | Mantra Override |\n|----------------|-----------------|\n| Dive into code immediately | Discuss approach first (non-trivial) |\n| Speculative fixes | Fix actual errors only |\n| Snippets without context | Complete blocks with imports |\n| Over-engineer | Minimal working implementation |\n\n**The core insight**: Claude's default mode is helpful-subordinate. Mantra retrains it to be skeptical-peer.\n\n## Development\n\n```bash\nnpm install\nnpm test    # Run Jest tests (28 specs)\n```\n\n## Why \"mantra\"?\n\nA mantra is a phrase repeated to focus the mind. Claude's mind wanders. This brings it back.\n\n## Plugin Family\n\nmantra is part of a plugin family that works together:\n\n| Plugin | Purpose | Layer |\n|--------|---------|-------|\n| **[memento](../memento)** | Session persistence | Persistence |\n| **[mantra](../mantra)** | Behavioral rules | Rules |\n| **[onus](../onus)** | Work-item automation | Integration |\n\n### How They Work Together\n\n```\nExternal (GitHub/JIRA/Azure DevOps)\n        ‚îÇ\n        ‚ñº fetch issue details\n    [onus]\n        ‚îÇ\n        ‚ñº populate session file\n    [memento] ‚Üê‚îÄ‚îÄ \"What's next?\" lookup\n        ‚îÇ\n        ‚ñº read session context\n    [mantra] ‚îÄ‚îÄ‚ñ∫ rules injected via hooks\n```\n\nEach plugin works standalone but gains enhanced behavior when used together.\n\n## License\n\nMIT\n",
        "mantra/commands/assess.md": "---\ndescription: Perform structured critical assessment of a proposal or approach\nargument-hint: [proposal or context]\n---\n\n# Critical Assessment\n\nPerform a structured evaluation of a proposal, approach, or solution before implementation.\n\n## Task\n\n**IMPORTANT: This skill implements the CRITICAL ASSESSMENT rule from behavior.md**\n\nWhen the user presents a proposal, solution, or asks for agreement on an approach, you MUST assess before agreeing.\n\n### Assessment Framework\n\nEvaluate these dimensions in order:\n\n1. **Correctness**\n   - Does this solve the stated problem?\n   - Are there logical errors or misconceptions?\n   - Are the assumptions valid?\n\n2. **Architecture**\n   - Does this fit the existing codebase patterns?\n   - Are there separation of concerns issues?\n   - Will this scale appropriately?\n\n3. **Alternatives**\n   - What other approaches could work?\n   - Why might they be better or worse?\n   - Are we missing a simpler solution?\n\n4. **Risks**\n   - What could go wrong?\n   - What edge cases aren't handled?\n   - Security, performance, maintainability concerns?\n\n### Assessment Stance\n\n- **Skeptical by default**: Find problems, not agreement\n- **Peer, not subordinate**: Challenge politely but directly\n- **Honest over agreeable**: Truth serves better than validation\n\n### Output Format\n\nStructure your response as:\n\n```\n## Assessment: [proposal summary]\n\n### Correctness\n[findings]\n\n### Architecture\n[findings]\n\n### Alternatives\n[findings]\n\n### Risks\n[findings]\n\n### Recommendation\n[approve/revise/reject with reasoning]\n```\n\n## Example\n\n```\nUser: /mantra:assess I think we should add a caching layer using Redis for all API responses\n\nClaude: ## Assessment: Add Redis caching for all API responses\n\n### Correctness\nThe goal of improving response times is valid, but \"all API responses\" is too broad. Some endpoints (user profile, real-time data) shouldn't be cached.\n\n### Architecture\nAdding Redis creates a new infrastructure dependency. Current architecture uses in-memory caching for specific endpoints. Mixing approaches may create inconsistency.\n\n### Alternatives\n1. **Expand existing in-memory caching** - simpler, no new deps\n2. **CDN edge caching** - better for static/semi-static responses\n3. **Selective Redis** - only for specific expensive queries\n\n### Risks\n- Cache invalidation complexity\n- Redis availability becomes critical path\n- Memory costs for unused cached data\n- Cold start problems after Redis restart\n\n### Recommendation\n**Revise**: Start with selective caching for identified slow endpoints. Measure before adding infrastructure complexity. Consider: which specific endpoints are slow? What's the current p99 latency?\n```\n\n## When to Use\n\nInvoke this skill when:\n- You're about to agree with a proposal without analysis\n- The user asks \"what do you think of this approach?\"\n- Before implementing a non-trivial change\n- When the user presents multiple options\n\n## Anti-Patterns\n\n- Saying \"that sounds good\" without analysis\n- Agreeing to avoid conflict\n- Skipping assessment because the user seems confident\n- Rubber-stamping decisions from authority figures\n",
        "mantra/commands/make-rule.md": "---\ndescription: Create a compact frontmatter rule from verbose markdown\nargument-hint: <source-file.md>\n---\n\n# Make Rule: Convert Markdown to Frontmatter Rule\n\nConvert a verbose, human-readable markdown file into a token-efficient frontmatter-only rule file.\n\n## Workflow\n\n### Step 1: Identify Source File\n\nIf no argument provided, ask the user:\n\n> What is the path to the verbose markdown file you want to compact?\n\nRead the source file to understand its content.\n\n### Step 2: Analyze and Convert\n\nTransform the verbose markdown into compact YAML frontmatter:\n\n**Conversion Rules:**\n- Remove prose, explanations, complete sentences\n- Use key:value pairs with minimal words\n- Apply operators: `‚Üí` (flow), `>` (priority), `|` (alternatives)\n- Use comma-separated lists instead of bullet points\n- Remove articles (a, an, the), filler words\n- Use parens for inline examples: `pattern (example: value)`\n- Use negation prefixes: `no:`, `skip:`, `never:`\n- Target 5-30 lines (89% token reduction)\n\n**Output Format:**\n```markdown\n---\n# {Title} - Compact Reference\ncompanion: {source-filename}\n\n## {Section Header}\nkey: value, value, value\nanother-key: flow ‚Üí sequence ‚Üí result\n---\n```\n\n### Step 3: Identify Critical Rules\n\nAfter creating the compact version, ask the user:\n\n> Are any of these rules CRITICAL - meaning Claude must absolutely follow them without exception?\n>\n> If yes, describe which rules are critical and why.\n\n### Step 4: Mark Critical Rules\n\nWhen the user identifies critical rules, apply emphasis markers:\n\n**Emphasis Levels (use sparingly):**\n\n| Marker | Use When | Example |\n|--------|----------|---------|\n| `MANDATORY-REREAD:` | Must re-read before specific actions | `MANDATORY-REREAD: before-commit (use-thinking-block)` |\n| `## SECTION (BLOCKING REQUIREMENT)` | Entire section is non-negotiable | `## ASSESSMENT (BLOCKING REQUIREMENT)` |\n| `required-before:` | Must happen before an action | `required-before: git-operations, implementation` |\n| `must-verify:` | Must explicitly check | `must-verify: format-requirements` |\n| `enforcement:` | Trigger conditions | `enforcement: if user says X ‚Üí do Y` |\n| `never:` | Absolute prohibitions | `never: skip-tests, guess-values` |\n\n**Guidelines for CRITICAL markers:**\n- Use SPARINGLY - overuse dilutes impact\n- Reserve `MANDATORY-REREAD:` for top-level blocking behaviors\n- Reserve `(BLOCKING REQUIREMENT)` for section headers only\n- Use `enforcement:` for if‚Üíthen trigger rules\n- Combine with `(use-thinking-block)` for verification requirements\n\n### Step 5: Output\n\nPresent the final compact rule file to the user:\n\n1. Show the complete frontmatter-only file\n2. Explain which parts were marked as critical and why\n3. Suggest saving to `.claude/rules/{name}.md`\n4. Remind user to run `/mantra:init --force` if updating existing rule\n\n## Example Transformation\n\n**Before (verbose):**\n```markdown\n# Code Review Guidelines\n\nWhen reviewing code, always check for security vulnerabilities first.\nThis is extremely important and should never be skipped.\n\n## Style Checks\n- Check for consistent naming\n- Verify imports are organized\n- Look for unused variables\n```\n\n**After (compact with critical marker):**\n```markdown\n---\n# Code Review - Compact Reference\ncompanion: code-review.md\n\nMANDATORY-REREAD: before-code-review (use-thinking-block)\n\n## SECURITY (BLOCKING REQUIREMENT)\ncheck-first: vulnerabilities (never-skip)\nverify: injection, auth, data-exposure\n\n## Style\ncheck: naming-consistency, import-organization, unused-variables\n---\n```\n\n## Notes\n\n- The companion file should be the original verbose markdown\n- Compact files are for Claude (machine-optimized)\n- Keep original verbose file for human reference\n- Critical markers make Claude pay special attention in thinking blocks\n",
        "mantra/commands/troubleshoot.md": "---\ndescription: Evidence-based debugging workflow for errors and bugs\nargument-hint: [error message or bug description]\n---\n\n# Troubleshoot\n\nPerform evidence-based debugging using documented examples rather than guessing.\n\n## Task\n\n**IMPORTANT: This skill implements the TROUBLESHOOTING & DEBUGGING rule from behavior.md**\n\nWhen the user reports an error, bug, or unexpected behavior, you MUST find documented evidence before proposing fixes. No guessing.\n\n### Evidence-Based Workflow\n\n1. **Gather Context**\n   - Get full error message and stack trace\n   - Identify version numbers (runtime, libraries, tools)\n   - Understand what the user was trying to do\n\n2. **Research First**\n   Use these sources in order:\n   - **GitHub Issues**: Search the project's issue tracker\n   - **Web Search**: Find real documented cases\n   - **Official Docs**: Check changelogs, known issues, migration guides\n\n3. **Cross-Reference Requirement**\n   - Find minimum 3 documented examples of the same or similar error\n   - Sources must be authoritative (issue trackers, release notes, official docs)\n   - Do NOT rely on a single Stack Overflow answer\n\n4. **Pattern Matching**\n   Only after finding documented evidence:\n   - Identify common causes across examples\n   - Note what solutions worked in each case\n   - Determine if user's context matches\n\n5. **Propose Solution**\n   - Reference the documented examples\n   - Explain why this solution applies to user's case\n   - Provide verification steps\n\n### What NOT to Do\n\n- Jump to \"common solutions\" from training data\n- Pattern-match without verification\n- Shotgun debugging (try random fixes)\n- Fill knowledge gaps with speculation\n- Propose fixes without citing sources\n\n### Output Format\n\n```\n## Troubleshooting: [error summary]\n\n### Context Gathered\n- Error: [full message]\n- Environment: [versions, platform]\n- Action: [what user was doing]\n\n### Research Findings\n\n**Source 1**: [link or reference]\n- Cause: [identified cause]\n- Solution: [what worked]\n\n**Source 2**: [link or reference]\n- Cause: [identified cause]\n- Solution: [what worked]\n\n**Source 3**: [link or reference]\n- Cause: [identified cause]\n- Solution: [what worked]\n\n### Analysis\n[Common patterns across sources, applicability to user's case]\n\n### Recommended Fix\n[Solution with steps]\n\n### Verification\n[How to confirm the fix worked]\n```\n\n## Example\n\n```\nUser: /mantra:troubleshoot TypeError: Cannot read properties of undefined (reading 'map')\n\nClaude: ## Troubleshooting: TypeError on .map()\n\n### Context Gathered\nLet me get more details:\n- Where does this error occur? (file:line)\n- What data are you mapping over?\n- Did this work before? What changed recently?\n\n[After user provides context]\n\n### Research Findings\n\n**Source 1**: React GitHub Issue #14920\n- Cause: API response returning undefined before data loads\n- Solution: Add loading state or optional chaining\n\n**Source 2**: Stack Overflow - verified answer with 200+ votes\n- Cause: Component renders before async data arrives\n- Solution: Initialize state with empty array, not undefined\n\n**Source 3**: React Docs - Conditional Rendering\n- Cause: Race condition between render and data fetch\n- Solution: Guard clause or early return when data unavailable\n\n### Analysis\nAll three sources point to the same root cause: trying to call .map() on data that hasn't loaded yet. Your fetch likely returns undefined on error or hasn't completed.\n\n### Recommended Fix\n```javascript\n// Before\n{items.map(item => ...)}\n\n// After - Option 1: Optional chaining\n{items?.map(item => ...) ?? null}\n\n// After - Option 2: Guard clause\n{items && items.length > 0 && items.map(item => ...)}\n\n// After - Option 3: Loading state (preferred)\nif (!items) return <Loading />;\nreturn items.map(item => ...);\n```\n\n### Verification\n- Error should not occur when component first renders\n- Check Network tab to confirm API response shape\n- Add console.log before .map() to verify data structure\n```\n\n## When to Use\n\nInvoke this skill when:\n- User reports an error message\n- Something \"stopped working\"\n- Unexpected behavior occurs\n- User asks \"why is this happening?\"\n\n## When Stuck\n\nIf you can't find 3 documented examples:\n- Ask user for more context (exact error, reproduction steps)\n- Search with different keywords\n- Check if this is a new/unreported issue\n- Do NOT guess - say \"I couldn't find documented cases for this specific issue\"\n",
        "mantra/hooks/__tests__/session-monitor.test.js": "const fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Test only plugin-specific logic, not shared module functionality\n\ndescribe('mantra session-monitor hook', () => {\n  let tmpDir;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mantra-test-'));\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  describe('hasProjectRules', () => {\n    // Import after setup\n    let hook;\n    beforeEach(() => {\n      jest.resetModules();\n      hook = require('../session-monitor.js');\n    });\n\n    it('returns false when .claude/rules does not exist', () => {\n      expect(hook.hasProjectRules(tmpDir)).toBe(false);\n    });\n\n    it('returns false when .claude/rules is empty', () => {\n      fs.mkdirSync(path.join(tmpDir, '.claude', 'rules'), { recursive: true });\n      expect(hook.hasProjectRules(tmpDir)).toBe(false);\n    });\n\n    it('returns true when .claude/rules has md files', () => {\n      const rulesDir = path.join(tmpDir, '.claude', 'rules');\n      fs.mkdirSync(rulesDir, { recursive: true });\n      fs.writeFileSync(path.join(rulesDir, 'test.md'), '---\\ntest: rule\\n---');\n      expect(hook.hasProjectRules(tmpDir)).toBe(true);\n    });\n\n    it('returns false when .claude/rules has only non-md files', () => {\n      const rulesDir = path.join(tmpDir, '.claude', 'rules');\n      fs.mkdirSync(rulesDir, { recursive: true });\n      fs.writeFileSync(path.join(rulesDir, 'test.txt'), 'not a rule');\n      expect(hook.hasProjectRules(tmpDir)).toBe(false);\n    });\n  });\n\n  describe('getContextPercentage', () => {\n    let hook;\n    beforeEach(() => {\n      jest.resetModules();\n      hook = require('../session-monitor.js');\n    });\n\n    it('returns null when no context_window data', () => {\n      expect(hook.getContextPercentage({})).toBe(null);\n    });\n\n    it('returns null when missing current_usage', () => {\n      expect(hook.getContextPercentage({\n        context_window: { context_window_size: 200000 }\n      })).toBe(null);\n    });\n\n    it('calculates percentage correctly', () => {\n      expect(hook.getContextPercentage({\n        context_window: {\n          context_window_size: 200000,\n          current_usage: {\n            input_tokens: 20000,\n            cache_creation_input_tokens: 0,\n            cache_read_input_tokens: 0\n          }\n        }\n      })).toBe(10);\n    });\n\n    it('includes cache tokens in calculation', () => {\n      expect(hook.getContextPercentage({\n        context_window: {\n          context_window_size: 200000,\n          current_usage: {\n            input_tokens: 10000,\n            cache_creation_input_tokens: 5000,\n            cache_read_input_tokens: 5000\n          }\n        }\n      })).toBe(10);\n    });\n  });\n});\n",
        "mantra/hooks/hooks.json": "{\n  \"description\": \"Mantra session monitor - shows rules loaded (SessionStart) and context freshness (UserPromptSubmit)\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-monitor.js\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-monitor.js\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "mantra/hooks/session-monitor.js": "#!/usr/bin/env node\n/**\n * mantra hook - delegates to shared handler with custom status line augmentation\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\nlet shared;\ntry {\n  shared = require('../lib/shared');\n} catch {\n  shared = require('../../shared');\n}\n\nconst PLUGIN_ROOT = path.join(__dirname, '..');\n\n// ============================================================================\n// Context Window Analysis\n// ============================================================================\n\nfunction getContextPercentage(input) {\n  const ctxWindow = input.context_window;\n  if (!ctxWindow?.context_window_size || !ctxWindow?.current_usage) return null;\n\n  const used = ctxWindow.current_usage.input_tokens +\n    (ctxWindow.current_usage.cache_creation_input_tokens || 0) +\n    (ctxWindow.current_usage.cache_read_input_tokens || 0);\n  const total = ctxWindow.context_window_size;\n  return Math.round((used / total) * 100);\n}\n\n// ============================================================================\n// Project Rules Detection\n// ============================================================================\n\nfunction hasProjectRules(cwd) {\n  const projectRulesDir = path.join(cwd, '.claude', 'rules');\n  if (!fs.existsSync(projectRulesDir)) return false;\n  try {\n    const files = fs.readdirSync(projectRulesDir);\n    return files.some(f => f.endsWith('.md'));\n  } catch { return false; }\n}\n\n// ============================================================================\n// Hook Callbacks\n// ============================================================================\n\nfunction onSessionStart(input, base) {\n  const cwd = input.cwd || process.cwd();\n  const source = input.source || 'startup';\n  const hasProjectRulesResult = hasProjectRules(cwd);\n\n  // Build status line with context info\n  let statusLine = base.statusLine;\n\n  // Add source indicator\n  if (source === 'compact') {\n    statusLine = statusLine.replace(/ \\(reloaded\\)$/, '') + ' (reloaded after compaction)';\n  }\n\n  // Context percentage analysis\n  const contextPercentage = getContextPercentage(input);\n  let startupBloat = false;\n\n  if (contextPercentage !== null) {\n    // Add context percentage to status line\n    if (!statusLine.includes('@')) {\n      statusLine += ` @ ${contextPercentage}%`;\n    }\n\n    // Warn about high initial context on startup only\n    if (source === 'startup' && contextPercentage > 35) {\n      startupBloat = true;\n      statusLine += ` | High initial context (${contextPercentage}%)`;\n    }\n  }\n\n  return {\n    statusLine,\n    additionalContext: base.additionalContext,\n    extra: {\n      source,\n      rulesLoaded: base.files.length > 0,\n      injectedFromPlugin: !hasProjectRulesResult,\n      ruleCount: base.files.length,\n      contextPercentage,\n      startupBloat\n    }\n  };\n}\n\nfunction onUserPromptSubmit(input, base) {\n  const cwd = input.cwd || process.cwd();\n  const hasProjectRulesResult = hasProjectRules(cwd);\n\n  return {\n    additionalContext: base.additionalContext,\n    extra: {\n      rulesLoaded: true\n    }\n  };\n}\n\n// ============================================================================\n// Main Entry Point\n// ============================================================================\n\nif (require.main === module) {\n  shared.runHook({\n    pluginName: 'Mantra',\n    pluginRoot: PLUGIN_ROOT,\n    onSessionStart,\n    onUserPromptSubmit\n  });\n}\n\n// ============================================================================\n// Exports (for testing)\n// ============================================================================\n\nfunction processHook(input) {\n  const config = {\n    pluginName: 'Mantra',\n    pluginRoot: PLUGIN_ROOT,\n    onSessionStart,\n    onUserPromptSubmit\n  };\n  return shared.processHook(config, input);\n}\n\nmodule.exports = {\n  processHook,\n  hasProjectRules,\n  getContextPercentage\n};\n",
        "memento/.claude-plugin/plugin.json": "{\n  \"name\": \"memento\",\n  \"version\": \"0.3.8\",\n  \"description\": \"Session management for Claude Code - auto-injected via hooks, zero config\",\n  \"author\": {\n    \"name\": \"David Puglielli\"\n  },\n  \"repository\": \"https://github.com/flexion/claude-domestique\",\n  \"homepage\": \"https://github.com/flexion/claude-domestique/tree/main/memento\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"session\",\n    \"persistence\",\n    \"context\",\n    \"branch-tracking\"\n  ],\n  \"commands\": [\n    \"./commands/session.md\",\n    \"./commands/start.md\"\n  ],\n  \"skills\": \"./skills/\"\n}\n",
        "memento/README.md": "# memento\n\n> \"Remember Sammy Jankis.\"\n\nLike Leonard in *Memento*, Claude can't form long-term memories. memento gives Claude its tattoos‚Äîsession files that persist decisions, progress, and context across conversation resets.\n\n### Flexion Fundamentals\n\nmemento helps developers embody Flexion fundamentals across conversation boundaries:\n\n- **Design as you go** ‚Äî Session files are **living design documents** that evolve from requirements through implementation\n- **Lead by example** ‚Äî Persists decisions and design rationale so nothing is lost to \"fixed bug\" amnesia\n- **Empower customers to adapt** ‚Äî Enables team handoffs with full design context and history\n\n## The Problem\n\nIn Christopher Nolan's *Memento* (2000), Leonard Shelby suffers from anterograde amnesia‚Äîhe can't form new memories. Every few minutes, his slate wipes clean. To function, he tattoos critical facts on his body and leaves himself Polaroids and notes.\n\nClaude has the same problem. Context window fills up, conversation resets, and everything learned‚Äîdecisions made, approaches tried, dead ends discovered‚Äîvanishes.\n\n## The Solution\n\nmemento is Leonard's system for Claude: persistent session files that survive the reset, letting Claude wake up, read its own notes, and pick up exactly where it left off.\n\n## Key Concepts\n\n- **1 Session = 1 Issue = 1 Branch** - Clean mapping between work units\n- **Atomic commits** - Session file versions WITH the code it describes\n- **Progress checkpointing** - Update throughout work, not just at the end\n\n## Features\n\n- **Branch metadata files** - Compact lookup to find session from current branch\n- **Session templates** - Standardized structure for feature vs chore sessions\n- **Automatic context restoration** - Branch ‚Üí session ‚Üí next steps lookup\n- **Branch switch detection** - Detects when you switch branches mid-conversation and guides session handling\n- **Start work command** - Interactive `/memento:start` to create branch + session together\n- **Session population triggers** - Automatic reminders when todos change, plans approved, or context filling up\n- **Misnamed file handling** - Detects sessions that reference wrong branch and offers rename\n- **Session log** - Chronological record of what was done, when, and why\n- **Key decisions documentation** - Captures WHY, not just WHAT\n- **Learnings capture** - What surprised you, what would you do differently\n- **Files changed tracking** - Inventory of modified files for handoff\n- **Blockers documentation** - Capture what's blocking before stepping away\n\n## Use Cases\n\n- **Survives conversation resets** - Context window fills up, start new chat, read session, continue\n- **Survives context compaction** - When Claude summarizes, session file has the real details\n- **Team handoffs** - Teammate checks out branch, reads session, has full context\n\n## Plugin Family\n\nmemento is part of a plugin family that works together:\n\n| Plugin | Purpose | Layer |\n|--------|---------|-------|\n| **[memento](../memento)** | Session persistence | Persistence |\n| **[mantra](../mantra)** | Context refresh | Injection |\n| **[onus](../onus)** | Work-item automation | Integration |\n\n### How They Work Together\n\n```\nExternal (GitHub/JIRA/Azure DevOps)\n        ‚îÇ\n        ‚ñº fetch issue details\n    [onus]\n        ‚îÇ\n        ‚ñº populate session file\n    [memento] ‚Üê‚îÄ‚îÄ \"What's next?\" lookup\n        ‚îÇ\n        ‚ñº read session context\n    [mantra] ‚îÄ‚îÄ‚ñ∫ rules injected via hooks\n```\n\n### Shared Naming Convention\n\nAll three plugins agree on this mapping:\n\n```\nIssue #42 (tracker)\n    ‚Üì\nBranch: issue/feature-42/description\n    ‚Üì\nMetadata: .claude/branches/issue-feature-42-description\n    ‚Üì\nSession: .claude/sessions/issue-feature-42-description.md\n```\n\n### Interoperability\n\n- **onus ‚Üí memento**: Onus fetches issue details and populates the session file that memento manages\n- **memento ‚Üí mantra**: Session files live alongside context files; mantra can refresh session-aware context\n- **mantra ‚Üí memento**: Mantra keeps behavioral rules fresh; memento persists the actual work state\n\nEach plugin works standalone but gains enhanced behavior when used together.\n\n## Installation\n\n```bash\n# Add the marketplace\n/plugin marketplace add flexion/claude-domestique\n\n# Install the plugin\n/plugin install memento@claude-domestique\n```\n\nThat's it. Session management works automatically‚Äîno initialization required.\n\n## How It Works\n\nmemento uses Claude Code's hook system for automatic session management:\n\n| Hook | When | What Happens |\n|------|------|--------------|\n| **SessionStart** | New conversation | Creates session file for feature branches, injects session context |\n| **UserPromptSubmit** | Every prompt | Detects branch switches, session triggers, shows status |\n\n### Automatic Session Creation\n\nWhen you start a conversation on a feature branch like `issue/feature-42/add-auth`:\n1. memento detects the branch name\n2. Creates `.claude/sessions/issue-feature-42-add-auth.md` if it doesn't exist\n3. Injects session file path into Claude's context\n4. Claude reads the session and picks up where you left off\n\n### Branch Switch Detection\n\nWhen you switch branches mid-conversation:\n1. memento detects the branch changed on next prompt\n2. Looks for existing session for the new branch\n3. If no exact match, finds possible sessions by scoring issue number and description\n4. Guides Claude to read existing session, rename mismatched file, or create new\n\n### Session Population Triggers\n\nmemento detects events that warrant session updates:\n- **Todos changed** - Reminds to update Session Log and Next Steps\n- **Plan approved** - Prompts immediate update of Approach section\n- **Context checkpoint** - Warns when context > 80% full, prompts state save\n\n## Usage\n\n### Start Working (Recommended)\n\nUse the start command to create branch and session together:\n\n```bash\n/memento:start\n```\n\nClaude will:\n1. Ask if this is an issue or chore\n2. Help find the issue number (if needed)\n3. Create the branch with correct format\n4. Create session file primed with issue details\n\n### Start Working (Manual)\n\n```bash\n# Create a branch for your work\ngit checkout -b issue/feature-42/add-auth\n\n# Start Claude Code - session is created automatically\nclaude\n```\n\n### Status Line\n\nEvery prompt shows session status:\n\n```\nüìÇ Memento: #3 ‚úì\nüìÇ Session: /path/to/.claude/sessions/issue-feature-42-add-auth.md\n```\n\n### Check Session Status\n\n```\n/memento:session\n```\n\nShows current session details:\n```\nSession: issue-feature-42-add-auth.md\nBranch: issue/feature-42/add-auth\nType: feature\nIssue: #42\nStatus: in-progress\n\nNext Steps:\n1. First pending task\n2. Second pending task\n```\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/memento:start` | Start new work - creates branch and session together |\n| `/memento:session` | Show current session status or create new session |\n\n## Skills\n\nSkills are proactively invoked by Claude when context matches:\n\n| Skill | Triggers |\n|-------|----------|\n| `resume` | \"what's next?\", \"where was I?\", resuming work after break |\n\n## Requirements\n\n- Node.js (required by Claude CLI)\n- All tools written in JavaScript\n\n## License\n\nMIT\n",
        "memento/commands/session.md": "---\ndescription: Show current session status or create a new session\nargument-hint: [create]\n---\n\n# Session Management\n\nShow or manage the current session.\n\n## Task\n\nBased on the argument provided:\n\n### No argument (default): Show session status\n1. Get current branch: `git branch --show-current`\n2. Sanitize branch name (replace `/` with `-`) to find metadata file\n3. Check if `.claude/branches/<sanitized-branch>` exists\n4. If metadata exists, read it to find session file path\n5. Read `.claude/sessions/<session>.md` and display:\n   - Branch and session file path\n   - Current status\n   - Next steps section\n   - Recent log entries (last 2-3)\n6. If no session found:\n   - Show current branch\n   - Suggest: \"Run `/session create` to create a session for this branch\"\n\n### \"create\": Create session for current branch\n1. Get current branch: `git branch --show-current`\n2. Refuse if on main/master branch\n3. Parse branch name to extract:\n   - Type (feature, fix, chore)\n   - Issue ID if present (e.g., #123, PROJ-456)\n   - Description slug\n4. Create `.claude/sessions/` and `.claude/branches/` directories if needed\n5. Generate session filename: `<issue>-<desc>.md` or `<type>-<desc>.md`\n6. Sanitize branch name for metadata: replace `/` with `-`\n7. Create branch metadata file at `.claude/branches/<sanitized-branch>`:\n   ```\n   session: <session-filename>\n   status: in-progress\n   ```\n8. Create session file at `.claude/sessions/<session-filename>` with template:\n   ```markdown\n   # Session: <description>\n\n   **Issue**: <issue-id or N/A>\n   **Branch**: <branch-name>\n   **Type**: <type>\n   **Created**: <today's date>\n   **Status**: in-progress\n\n   ## Goal\n   [Describe the objective]\n\n   ## Approach\n   [Describe the implementation approach]\n\n   ## Session Log\n   - <date>: Session created\n\n   ## Key Decisions\n   - None yet\n\n   ## Learnings\n   - None yet\n\n   ## Files Changed\n   - None yet\n\n   ## Next Steps\n   - [ ] Define goal and approach\n   ```\n9. Display the new session file\n10. Remind user to update Goal and Approach sections\n",
        "memento/commands/start.md": "---\ndescription: Start new work with branch and session creation\nargument-hint: [issue|chore]\n---\n\n# Start New Work\n\nInteractive workflow to begin new work with proper branch and session setup.\n\n## Task\n\n### Step 1: Determine work type\n\nIf no argument provided, ask the user:\n\"What type of work are you starting?\n1. **issue** - Work tied to a tracked issue (GitHub, JIRA, Azure DevOps)\n2. **chore** - Maintenance work without an issue number\"\n\n### If \"issue\" (work item):\n\n1. Ask for the issue identifier (e.g., #42, PROJ-123)\n\n2. If user doesn't know the ID, help them find it:\n   ```bash\n   # GitHub - list recent open issues\n   gh issue list --state open --limit 10\n\n   # Or search by keywords\n   gh issue list --search \"keyword\"\n   ```\n\n3. Fetch issue details:\n   ```bash\n   gh issue view <number> --json number,title,body,state,labels\n   ```\n\n4. Extract from issue:\n   - Title ‚Üí goal\n   - Description ‚Üí context\n   - Labels ‚Üí determine type (feature, bug, fix)\n   - Acceptance criteria (checkboxes in body)\n\n5. Generate branch name:\n   - Format: `issue/<type>-<number>/<slug>`\n   - Slug: lowercase, hyphens, max 30 chars\n   - Example: `issue/feature-42/user-authentication`\n\n6. Create branch and session:\n   ```bash\n   git fetch origin\n   git checkout -b issue/<type>-<number>/<slug> origin/main\n   ```\n\n7. Create session file primed with issue data:\n   - **Issue**: #<number>\n   - **Goal**: <issue title>\n   - **Acceptance Criteria**: (from issue body checkboxes)\n   - **Session Log**: Session created from issue #<number>\n\n### If \"chore\" (maintenance work):\n\n1. Ask for a short description (1-5 words):\n   \"What are you working on? (e.g., 'update dependencies', 'fix linting')\"\n\n2. Optionally ask for goal:\n   \"What's the objective? (press Enter to skip)\"\n\n3. Generate branch name:\n   - Format: `chore/<slug>`\n   - Example: `chore/update-dependencies`\n\n4. Create branch and session:\n   ```bash\n   git fetch origin\n   git checkout -b chore/<slug> origin/main\n   ```\n\n5. Create session file with chore template:\n   - **Type**: chore\n   - **Goal**: <user description or \"Maintenance work\">\n   - **Session Log**: Session created for chore\n\n### Step 2: Confirm setup\n\nDisplay the created session file and confirm:\n- Branch name created\n- Session file path\n- Goal and acceptance criteria (if available)\n\nAsk: \"Does this look correct? Update the session file if you need to refine the goal or approach.\"\n\n## Examples\n\n**Starting from an issue:**\n```\nUser: /memento:start issue\nClaude: What's the issue number?\nUser: 42\nClaude: Fetching issue #42... \"Add user authentication\"\n        Creating branch: issue/feature-42/user-authentication\n        Session file: .claude/sessions/42-user-authentication.md\n\n        Goal: Add user authentication\n        Acceptance Criteria:\n        - [ ] Login form with email/password\n        - [ ] Form validation\n        - [ ] Secure token storage\n```\n\n**Starting a chore:**\n```\nUser: /memento:start chore\nClaude: What are you working on?\nUser: update npm dependencies\nClaude: Creating branch: chore/update-npm-dependencies\n        Session file: .claude/sessions/chore-update-npm-dependencies.md\n```\n\n## Templates\n\nTemplates are checked in this order (first found wins):\n1. `.claude/templates/` - Project-level overrides\n2. `memento/templates/` - Plugin defaults\n\nAvailable templates:\n- `feature.md` - For feature issues (enhancements, new functionality)\n- `fix.md` - For bug fixes\n- `chore.md` - For maintenance work without an issue\n\nTo customize templates for your project, copy the defaults to `.claude/templates/` and modify.\n\n## Integration with onus\n\nIf onus plugin is installed, issue details may already be cached at:\n`~/.claude/onus/work-item-cache.json`\n\nCheck cache before fetching to avoid redundant API calls.\n",
        "memento/hooks/__tests__/checkpoint.test.js": "const fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Mock child_process before requiring the module\nconst mockExecSync = jest.fn();\njest.mock('child_process', () => ({\n  execSync: mockExecSync\n}));\n\ndescribe('checkpoint.js', () => {\n  let hook;\n  let tmpDir;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'checkpoint-test-'));\n    jest.resetModules();\n    jest.doMock('child_process', () => ({\n      execSync: mockExecSync\n    }));\n    hook = require('../checkpoint.js');\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  describe('validateSessionFile', () => {\n    it('returns missing when file does not exist', () => {\n      const result = hook.validateSessionFile('/nonexistent/path.md');\n      expect(result).toEqual({ valid: false, issue: 'missing' });\n    });\n\n    it('returns missing when path is null', () => {\n      const result = hook.validateSessionFile(null);\n      expect(result).toEqual({ valid: false, issue: 'missing' });\n    });\n\n    it('detects [Describe the objective placeholder', () => {\n      const sessionPath = path.join(tmpDir, 'session.md');\n      fs.writeFileSync(sessionPath, `# Session\n\n## Goal\n[Describe the objective here]\n\n## Next Steps\n1. First task\n`);\n      const result = hook.validateSessionFile(sessionPath);\n      expect(result.valid).toBe(false);\n      expect(result.issue).toBe('placeholders');\n      expect(result.pattern).toContain('[Describe the objective');\n    });\n\n    it('detects [First task placeholder', () => {\n      const sessionPath = path.join(tmpDir, 'session.md');\n      fs.writeFileSync(sessionPath, `# Session\n\n## Goal\nImplement feature X\n\n## Next Steps\n1. [First task here]\n2. Second task\n`);\n      const result = hook.validateSessionFile(sessionPath);\n      expect(result.valid).toBe(false);\n      expect(result.issue).toBe('placeholders');\n      expect(result.pattern).toContain('[First task');\n    });\n\n    it('detects Goal followed by bracket placeholder', () => {\n      const sessionPath = path.join(tmpDir, 'session.md');\n      fs.writeFileSync(sessionPath, `# Session\n\n## Goal\n\n[Something here]\n\n## Next Steps\n1. Do the thing\n`);\n      const result = hook.validateSessionFile(sessionPath);\n      expect(result.valid).toBe(false);\n      expect(result.issue).toBe('placeholders');\n    });\n\n    it('returns valid for properly filled session', () => {\n      const sessionPath = path.join(tmpDir, 'session.md');\n      fs.writeFileSync(sessionPath, `# Session: chore/my-feature\n\n**Branch:** chore/my-feature\n**Type:** Chore\n**Status:** in-progress\n\n## Goal\n\nImplement the session validation feature.\n\n## Session Log\n\n- Started work on the feature\n- Added validateSessionFile function\n\n## Next Steps\n\n1. Add tests\n2. Run test suite\n3. Create PR\n`);\n      const result = hook.validateSessionFile(sessionPath);\n      expect(result).toEqual({ valid: true });\n    });\n\n    it('detects [Record key architectural placeholder', () => {\n      const sessionPath = path.join(tmpDir, 'session.md');\n      fs.writeFileSync(sessionPath, `# Session\n\n## Key Decisions\n[Record key architectural decisions here]\n\n## Goal\nDo something\n`);\n      const result = hook.validateSessionFile(sessionPath);\n      expect(result.valid).toBe(false);\n      expect(result.pattern).toContain('[Record key architectural');\n    });\n  });\n\n  describe('buildCheckpointReminder for git commit', () => {\n    beforeEach(() => {\n      // Setup git mocks\n      mockExecSync.mockImplementation((cmd) => {\n        if (cmd.includes('rev-parse --show-toplevel')) return tmpDir + '\\n';\n        if (cmd.includes('rev-parse --abbrev-ref')) return 'feature/test\\n';\n        throw new Error('Unknown command');\n      });\n    });\n\n    it('warns when no session file exists', () => {\n      const input = {\n        tool_name: 'Bash',\n        hook_event_name: 'PreToolUse',\n        tool_input: { command: 'git commit -m \"test\"' },\n        cwd: tmpDir\n      };\n\n      const result = hook.buildCheckpointReminder(input);\n      expect(result).toContain('STOP');\n      expect(result).toContain('No session file found');\n    });\n\n    it('warns when session has placeholders', () => {\n      // Create session with placeholders\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      fs.writeFileSync(\n        path.join(sessionsDir, 'feature-test.md'),\n        '## Goal\\n[Describe the objective here]'\n      );\n\n      const input = {\n        tool_name: 'Bash',\n        hook_event_name: 'PreToolUse',\n        tool_input: { command: 'git commit -m \"test\"' },\n        cwd: tmpDir\n      };\n\n      const result = hook.buildCheckpointReminder(input);\n      expect(result).toContain('STOP');\n      expect(result).toContain('placeholder text');\n      expect(result).toContain('[Describe the objective');\n    });\n\n    it('provides normal reminder when session is valid', () => {\n      // Create properly filled session\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      fs.writeFileSync(\n        path.join(sessionsDir, 'feature-test.md'),\n        '## Goal\\nImplement feature X\\n\\n## Next Steps\\n1. First step'\n      );\n\n      const input = {\n        tool_name: 'Bash',\n        hook_event_name: 'PreToolUse',\n        tool_input: { command: 'git commit -m \"test\"' },\n        cwd: tmpDir\n      };\n\n      const result = hook.buildCheckpointReminder(input);\n      expect(result).toContain('Pre-Commit');\n      expect(result).toContain('Session exists');\n      expect(result).not.toContain('STOP');\n    });\n\n    it('returns null when on main branch', () => {\n      mockExecSync.mockImplementation((cmd) => {\n        if (cmd.includes('rev-parse --show-toplevel')) return tmpDir + '\\n';\n        if (cmd.includes('rev-parse --abbrev-ref')) return 'main\\n';\n        throw new Error('Unknown command');\n      });\n\n      const input = {\n        tool_name: 'Bash',\n        hook_event_name: 'PreToolUse',\n        tool_input: { command: 'git commit -m \"test\"' },\n        cwd: tmpDir\n      };\n\n      const result = hook.buildCheckpointReminder(input);\n      expect(result).toBe(null);\n    });\n  });\n});\n",
        "memento/hooks/__tests__/session-startup.test.js": "const fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Mock child_process before requiring the module\nconst mockExecSync = jest.fn();\njest.mock('child_process', () => ({\n  execSync: mockExecSync\n}));\n\n// Test only plugin-specific logic, not shared module functionality\n\ndescribe('memento session-startup hook', () => {\n  let hook;\n  let tmpDir;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'memento-test-'));\n    // Re-require the module to get fresh instance with mocks\n    jest.resetModules();\n    // Re-mock after reset\n    jest.doMock('child_process', () => ({\n      execSync: mockExecSync\n    }));\n    hook = require('../session-startup.js');\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  describe('getBranch', () => {\n    it('returns branch name', () => {\n      mockExecSync.mockReturnValue('feature/test\\n');\n      expect(hook.getBranch('/test')).toBe('feature/test');\n    });\n\n    it('returns null on error', () => {\n      mockExecSync.mockImplementation(() => { throw new Error(); });\n      expect(hook.getBranch('/test')).toBe(null);\n    });\n  });\n\n  describe('getGitRoot', () => {\n    it('returns git root path', () => {\n      mockExecSync.mockReturnValue('/project\\n');\n      expect(hook.getGitRoot('/project/sub')).toBe('/project');\n    });\n\n    it('returns null on error', () => {\n      mockExecSync.mockImplementation(() => { throw new Error(); });\n      expect(hook.getGitRoot('/test')).toBe(null);\n    });\n  });\n\n  describe('getSessionPath', () => {\n    it('sanitizes branch name by replacing slashes with dashes', () => {\n      expect(hook.getSessionPath('/p', 'a/b/c')).toBe('/p/.claude/sessions/a-b-c.md');\n    });\n\n    it('handles simple branch names', () => {\n      expect(hook.getSessionPath('/p', 'main')).toBe('/p/.claude/sessions/main.md');\n    });\n  });\n\n  describe('createSession', () => {\n    it('creates directory and file', () => {\n      const sessionPath = path.join(tmpDir, '.claude', 'sessions', 'test.md');\n      hook.createSession(sessionPath, 'feature/test');\n      expect(fs.existsSync(sessionPath)).toBe(true);\n    });\n\n    it('includes branch type in template', () => {\n      const sessionPath = path.join(tmpDir, '.claude', 'sessions', 'test.md');\n      hook.createSession(sessionPath, 'fix/bug');\n      const content = fs.readFileSync(sessionPath, 'utf8');\n      expect(content).toContain('**Type**: fix');\n    });\n\n    it('handles chore type', () => {\n      const sessionPath = path.join(tmpDir, '.claude', 'sessions', 'test.md');\n      hook.createSession(sessionPath, 'chore/update');\n      const content = fs.readFileSync(sessionPath, 'utf8');\n      expect(content).toContain('**Type**: chore');\n    });\n\n    it('handles unknown type', () => {\n      const sessionPath = path.join(tmpDir, '.claude', 'sessions', 'test.md');\n      hook.createSession(sessionPath, 'random/branch');\n      const content = fs.readFileSync(sessionPath, 'utf8');\n      expect(content).toContain('**Type**: unknown');\n    });\n\n    it('includes branch name in template', () => {\n      const sessionPath = path.join(tmpDir, '.claude', 'sessions', 'test.md');\n      hook.createSession(sessionPath, 'feature/my-feature');\n      const content = fs.readFileSync(sessionPath, 'utf8');\n      expect(content).toContain('**Branch**: feature/my-feature');\n    });\n  });\n\n  describe('findPossibleSessions', () => {\n    it('returns empty array when sessions directory does not exist', () => {\n      const result = hook.findPossibleSessions(tmpDir, 'issue/feature-42/test');\n      expect(result).toEqual([]);\n    });\n\n    it('finds sessions matching issue number', () => {\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      fs.writeFileSync(path.join(sessionsDir, '42-old-name.md'), '# test');\n      fs.writeFileSync(path.join(sessionsDir, 'unrelated.md'), '# other');\n\n      const result = hook.findPossibleSessions(tmpDir, 'issue/feature-42/new-name');\n      expect(result.length).toBe(1);\n      expect(result[0].file).toBe('42-old-name.md');\n      expect(result[0].score).toBeGreaterThan(0);\n    });\n\n    it('finds sessions matching description words', () => {\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      fs.writeFileSync(path.join(sessionsDir, 'auth-feature.md'), '# test');\n\n      const result = hook.findPossibleSessions(tmpDir, 'issue/feature-99/authentication');\n      // 'authentication' contains 'auth' - should match\n      expect(result.some(r => r.file === 'auth-feature.md')).toBe(true);\n    });\n\n    it('returns max 3 results sorted by score', () => {\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      fs.writeFileSync(path.join(sessionsDir, '42-a.md'), '');\n      fs.writeFileSync(path.join(sessionsDir, '42-b.md'), '');\n      fs.writeFileSync(path.join(sessionsDir, '42-c.md'), '');\n      fs.writeFileSync(path.join(sessionsDir, '42-d.md'), '');\n\n      const result = hook.findPossibleSessions(tmpDir, 'issue/feature-42/test');\n      expect(result.length).toBe(3);\n    });\n  });\n\n  describe('detectMismatch', () => {\n    it('returns null when exact session exists', () => {\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      const sessionPath = path.join(sessionsDir, 'issue-feature-42-test.md');\n      fs.writeFileSync(sessionPath, '# test');\n\n      const result = hook.detectMismatch(tmpDir, 'issue/feature-42/test', sessionPath);\n      expect(result).toBe(null);\n    });\n\n    it('detects misnamed session that references the branch', () => {\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      // Session with wrong name but correct branch reference\n      fs.writeFileSync(\n        path.join(sessionsDir, 'old-name.md'),\n        '# Session\\n**Branch**: issue/feature-42/test\\n'\n      );\n\n      const sessionPath = path.join(sessionsDir, 'issue-feature-42-test.md');\n      const result = hook.detectMismatch(tmpDir, 'issue/feature-42/test', sessionPath);\n\n      expect(result).not.toBe(null);\n      expect(result.currentName).toBe('old-name.md');\n      expect(result.expectedName).toBe('issue-feature-42-test.md');\n    });\n\n    it('returns null when no session references the branch', () => {\n      const sessionsDir = path.join(tmpDir, '.claude', 'sessions');\n      fs.mkdirSync(sessionsDir, { recursive: true });\n      fs.writeFileSync(\n        path.join(sessionsDir, 'other.md'),\n        '# Session\\n**Branch**: different/branch\\n'\n      );\n\n      const sessionPath = path.join(sessionsDir, 'issue-feature-42-test.md');\n      const result = hook.detectMismatch(tmpDir, 'issue/feature-42/test', sessionPath);\n      expect(result).toBe(null);\n    });\n  });\n\n  describe('buildSwitchContext', () => {\n    it('builds context for existing session', () => {\n      const context = hook.buildSwitchContext('/path/session.md', true, [], 'feature/test');\n      expect(context).toContain('Branch Switch Detected');\n      expect(context).toContain('Session found');\n    });\n\n    it('builds context for mismatch', () => {\n      const mismatch = { currentName: 'old.md', expectedName: 'new.md', path: '/path/old.md' };\n      const context = hook.buildSwitchContext('/path/new.md', false, [], 'feature/test', mismatch);\n      expect(context).toContain('Mismatch Detected');\n      expect(context).toContain('old.md');\n      expect(context).toContain('new.md');\n    });\n\n    it('builds context for possible sessions', () => {\n      const possibles = [{ file: 'maybe.md', score: 5 }];\n      const context = hook.buildSwitchContext('/path/session.md', false, possibles, 'feature/test');\n      expect(context).toContain('maybe.md');\n      expect(context).toContain('Possible matches');\n    });\n\n    it('builds context when no session found', () => {\n      const context = hook.buildSwitchContext('/path/session.md', false, [], 'feature/test');\n      expect(context).toContain('No session found');\n      expect(context).toContain('create a new session');\n    });\n  });\n\n  describe('detectSessionTriggers', () => {\n    it('detects todo changes', () => {\n      const triggers = hook.detectSessionTriggers({ toolsUsed: ['TodoWrite'] });\n      expect(triggers).toContainEqual({ type: 'todos_changed' });\n    });\n\n    it('detects plan approved', () => {\n      const triggers = hook.detectSessionTriggers({ toolsUsed: ['ExitPlanMode'] });\n      expect(triggers).toContainEqual({ type: 'plan_approved' });\n    });\n\n    it('detects context checkpoint', () => {\n      const triggers = hook.detectSessionTriggers({ contextUsage: 0.85 });\n      expect(triggers).toContainEqual({ type: 'context_checkpoint', usage: 85 });\n    });\n\n    it('returns empty array when no triggers', () => {\n      const triggers = hook.detectSessionTriggers({});\n      expect(triggers).toEqual([]);\n    });\n\n    it('detects multiple triggers', () => {\n      const triggers = hook.detectSessionTriggers({\n        toolsUsed: ['TodoWrite', 'ExitPlanMode'],\n        contextUsage: 0.9\n      });\n      expect(triggers.length).toBe(3);\n    });\n  });\n\n  describe('buildTriggerContext', () => {\n    it('returns empty string when no triggers', () => {\n      const context = hook.buildTriggerContext([], '/path/session.md');\n      expect(context).toBe('');\n    });\n\n    it('builds context for todos changed', () => {\n      const triggers = [{ type: 'todos_changed' }];\n      const context = hook.buildTriggerContext(triggers, '/path/session.md');\n      expect(context).toContain('Todos changed');\n      expect(context).toContain('Session Log');\n    });\n\n    it('builds context for plan approved', () => {\n      const triggers = [{ type: 'plan_approved' }];\n      const context = hook.buildTriggerContext(triggers, '/path/session.md');\n      expect(context).toContain('Plan approved');\n      expect(context).toContain('IMMEDIATELY');\n      expect(context).toContain('Approach');\n    });\n\n    it('builds context for context checkpoint', () => {\n      const triggers = [{ type: 'context_checkpoint', usage: 85 }];\n      const context = hook.buildTriggerContext(triggers, '/path/session.md');\n      expect(context).toContain('85%');\n      expect(context).toContain('compaction');\n    });\n  });\n});\n",
        "memento/hooks/checkpoint.js": "#!/usr/bin/env node\n/**\n * memento: Checkpoint hook\n *\n * Triggers session update reminders on key events:\n * - PostToolUse: ExitPlanMode, EnterPlanMode, Task, TodoWrite\n * - PreToolUse: git commit\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// ============================================================================\n// Git Helpers\n// ============================================================================\n\nfunction getGitRoot(cwd) {\n  try {\n    return execSync('git rev-parse --show-toplevel', {\n      cwd, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe']\n    }).trim();\n  } catch { return null; }\n}\n\nfunction getCurrentBranch(cwd) {\n  try {\n    return execSync('git rev-parse --abbrev-ref HEAD', {\n      cwd, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe']\n    }).trim();\n  } catch { return null; }\n}\n\n// ============================================================================\n// Session Helpers\n// ============================================================================\n\nfunction getSessionPath(gitRoot, branch) {\n  if (!gitRoot || !branch) return null;\n  const sanitized = branch.replace(/\\//g, '-');\n  return path.join(gitRoot, '.claude', 'sessions', `${sanitized}.md`);\n}\n\nfunction sessionExists(sessionPath) {\n  return sessionPath && fs.existsSync(sessionPath);\n}\n\nfunction validateSessionFile(sessionPath) {\n  if (!sessionPath || !fs.existsSync(sessionPath)) {\n    return { valid: false, issue: 'missing' };\n  }\n\n  const content = fs.readFileSync(sessionPath, 'utf8');\n\n  // Common placeholder patterns from session templates\n  const placeholders = [\n    '[Describe the objective',\n    '[First task',\n    '[Record key architectural',\n    '[What did you learn',\n    'Goal\\n\\n[',\n    'Next Steps\\n\\n1. ['\n  ];\n\n  for (const pattern of placeholders) {\n    if (content.includes(pattern)) {\n      return { valid: false, issue: 'placeholders', pattern };\n    }\n  }\n\n  return { valid: true };\n}\n\n// ============================================================================\n// Checkpoint Logic\n// ============================================================================\n\nfunction buildCheckpointReminder(input) {\n  const toolName = input.tool_name;\n  const hookEvent = input.hook_event_name;\n  const cwd = input.cwd || process.cwd();\n\n  const gitRoot = getGitRoot(cwd);\n  const branch = getCurrentBranch(cwd);\n  const sessionPath = getSessionPath(gitRoot, branch);\n  const hasSession = sessionExists(sessionPath);\n\n  // Skip if on main/master (no session expected)\n  if (branch === 'main' || branch === 'master') {\n    return null;\n  }\n\n  let reminder = null;\n\n  switch (toolName) {\n    case 'ExitPlanMode':\n      // Pre-implementation checkpoint\n      reminder = hasSession\n        ? 'üìù **Pre-Implementation Checkpoint**: Update session Approach section with the approved plan before coding.'\n        : '‚ö†Ô∏è **No session file found**. Create session before implementation.';\n      break;\n\n    case 'EnterPlanMode':\n      // Track planning started\n      reminder = 'üìù Planning mode started. Session will capture the plan when approved.';\n      break;\n\n    case 'Task':\n      // Check if significant subagent\n      const subagentType = input.tool_input?.subagent_type || '';\n      const significantAgents = ['Plan', 'Explore'];\n      const isSignificant = significantAgents.some(a =>\n        subagentType.toLowerCase().includes(a.toLowerCase())\n      );\n\n      if (isSignificant && hasSession) {\n        reminder = `üìù ${subagentType} agent completed. Consider updating session with findings.`;\n      }\n      break;\n\n    case 'TodoWrite':\n      // Sync reminder\n      if (hasSession) {\n        reminder = 'üìù Todos updated. Keep session Next Steps in sync.';\n      }\n      break;\n\n    case 'Bash':\n      // Pre-commit checkpoint (PreToolUse)\n      if (hookEvent === 'PreToolUse') {\n        const command = input.tool_input?.command || '';\n        if (command.includes('git commit')) {\n          if (!hasSession) {\n            reminder = '‚ö†Ô∏è **STOP**: No session file found. Create session before commit.';\n          } else {\n            const validation = validateSessionFile(sessionPath);\n            if (!validation.valid && validation.issue === 'placeholders') {\n              reminder = `‚ö†Ô∏è **STOP**: Session file has placeholder text: \"${validation.pattern}...\"\\n\\nUpdate session BEFORE committing. Consult sessions.md rule.`;\n            } else {\n              reminder = 'üìù **Pre-Commit**: Session exists. Verify it\\'s updated, then commit session + code together.';\n            }\n          }\n        }\n      }\n      break;\n  }\n\n  return reminder;\n}\n\n// ============================================================================\n// Main\n// ============================================================================\n\nfunction main() {\n  let inputData = '';\n\n  process.stdin.setEncoding('utf8');\n  process.stdin.on('data', chunk => { inputData += chunk; });\n  process.stdin.on('end', () => {\n    try {\n      const input = JSON.parse(inputData);\n      const reminder = buildCheckpointReminder(input);\n\n      const response = {};\n      if (reminder) {\n        response.additionalContext = `\\n${reminder}`;\n      }\n\n      console.log(JSON.stringify(response));\n    } catch (err) {\n      // Silent failure - don't break the hook chain\n      console.log(JSON.stringify({}));\n    }\n  });\n}\n\n// Run if executed directly\nif (require.main === module) {\n  main();\n}\n\n// Export for testing\nmodule.exports = {\n  validateSessionFile,\n  buildCheckpointReminder,\n  getGitRoot,\n  getCurrentBranch,\n  getSessionPath,\n  sessionExists\n};\n",
        "memento/hooks/hooks.json": "{\n  \"description\": \"Session management - auto-create on startup, checkpoint on key events\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-startup.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-startup.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"ExitPlanMode|EnterPlanMode|Task|TodoWrite\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/checkpoint.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash(git commit*)\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/checkpoint.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "memento/hooks/session-startup.js": "#!/usr/bin/env node\n/**\n * memento: Session persistence hook\n *\n * Delegates to shared hook handler with custom session file management.\n * Context injection via hooks - zero configuration required.\n */\n\nconst { execSync } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\n\n// Use bundled shared module (for installed plugins) or workspace module (for development)\nlet shared;\ntry {\n  shared = require('../lib/shared');\n} catch {\n  shared = require('../../shared');\n}\n\nconst PLUGIN_ROOT = path.join(__dirname, '..');\n\n// ============================================================================\n// Git Helpers\n// ============================================================================\n\nfunction getBranch(cwd) {\n  try {\n    return execSync('git rev-parse --abbrev-ref HEAD', {\n      encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'], cwd\n    }).trim();\n  } catch { return null; }\n}\n\nfunction getGitRoot(cwd) {\n  try {\n    return execSync('git rev-parse --show-toplevel', {\n      encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'], cwd\n    }).trim();\n  } catch { return null; }\n}\n\n// ============================================================================\n// Session Management\n// ============================================================================\n\nfunction getSessionPath(gitRoot, branch) {\n  return path.join(gitRoot, '.claude', 'sessions', `${branch.replace(/\\//g, '-')}.md`);\n}\n\nfunction getSessionsDir(gitRoot) {\n  return path.join(gitRoot, '.claude', 'sessions');\n}\n\n/**\n * Find possible session files that might match the current branch.\n * Scores by matching issue number and description words.\n */\nfunction findPossibleSessions(gitRoot, branch) {\n  const sessionsDir = getSessionsDir(gitRoot);\n  if (!fs.existsSync(sessionsDir)) return [];\n\n  // Extract issue number and description words from branch\n  const issueMatch = branch.match(/(\\d+)/);\n  const issueNumber = issueMatch?.[1];\n  const descWords = branch.split(/[-\\/]/).filter(w => w.length > 3 && !/^\\d+$/.test(w));\n\n  const sessions = fs.readdirSync(sessionsDir).filter(f => f.endsWith('.md'));\n\n  return sessions\n    .map(file => {\n      let score = 0;\n      const lowerFile = file.toLowerCase();\n\n      // Strong match: issue number in filename\n      if (issueNumber && lowerFile.includes(issueNumber)) score += 10;\n\n      // Weak match: description words in filename\n      for (const word of descWords) {\n        if (lowerFile.includes(word.toLowerCase())) score += 2;\n      }\n\n      return { file, score };\n    })\n    .filter(s => s.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 3);\n}\n\n/**\n * Detect session files that reference the current branch but have wrong filename.\n * This helps when sessions were manually renamed or created with different naming.\n */\nfunction detectMismatch(gitRoot, branch, sessionPath) {\n  // If exact match exists, no mismatch\n  if (fs.existsSync(sessionPath)) return null;\n\n  const sessionsDir = getSessionsDir(gitRoot);\n  if (!fs.existsSync(sessionsDir)) return null;\n\n  const expectedName = path.basename(sessionPath);\n  const sessions = fs.readdirSync(sessionsDir).filter(f => f.endsWith('.md'));\n\n  for (const session of sessions) {\n    if (session === expectedName) continue; // Skip exact match\n\n    const sessionFullPath = path.join(sessionsDir, session);\n    try {\n      const content = fs.readFileSync(sessionFullPath, 'utf8');\n      // Check if session file references this branch\n      if (content.includes(`**Branch**: ${branch}`) || content.includes(`Branch: ${branch}`)) {\n        return {\n          currentName: session,\n          expectedName: expectedName,\n          path: sessionFullPath\n        };\n      }\n    } catch {\n      // Skip unreadable files\n    }\n  }\n\n  return null;\n}\n\n/**\n * Build context message for branch switch scenario.\n */\nfunction buildSwitchContext(sessionPath, sessionExists, possibleSessions, branch, mismatch = null) {\n  let context = `\\n### Branch Switch Detected\\n`;\n  context += `New branch: \\`${branch}\\`\\n`;\n\n  if (sessionExists) {\n    context += `\\nSession found: ${sessionPath}\\n`;\n    context += 'Read the session file to restore context.\\n';\n  } else if (mismatch) {\n    // Found a session that references this branch but has wrong filename\n    context += '\\n**Session File Mismatch Detected**\\n';\n    context += `Current filename: \\`${mismatch.currentName}\\`\\n`;\n    context += `Expected filename: \\`${mismatch.expectedName}\\`\\n`;\n    context += `Path: ${mismatch.path}\\n`;\n    context += '\\nOptions:\\n';\n    context += '1. **Rename** the file to match branch naming convention (recommended)\\n';\n    context += '2. **Keep** current name and use as-is\\n';\n    context += '3. **Create new** session (archive the old one)\\n';\n  } else if (possibleSessions.length > 0) {\n    context += '\\nNo exact session match. Possible matches:\\n';\n    for (const s of possibleSessions) {\n      context += `  - ${s.file} (score: ${s.score})\\n`;\n    }\n    context += '\\nAsk user: use an existing file, rename it to match, or create new?\\n';\n  } else {\n    context += '\\nNo session found for this branch.\\n';\n    context += 'Offer to create a new session.\\n';\n  }\n\n  return context;\n}\n\n/**\n * Detect events that warrant session updates.\n * Returns array of trigger objects with type and details.\n */\nfunction detectSessionTriggers(input) {\n  const triggers = [];\n\n  // Check for todo changes (via input metadata if available)\n  if (input.toolsUsed?.includes('TodoWrite')) {\n    triggers.push({ type: 'todos_changed' });\n  }\n\n  // Check for plan mode exit (session should capture the approved plan)\n  if (input.toolsUsed?.includes('ExitPlanMode')) {\n    triggers.push({ type: 'plan_approved' });\n  }\n\n  // Check for context approaching compaction threshold\n  // contextUsage is a 0-1 ratio of context window used\n  if (input.contextUsage && input.contextUsage > 0.8) {\n    triggers.push({\n      type: 'context_checkpoint',\n      usage: Math.round(input.contextUsage * 100)\n    });\n  }\n\n  return triggers;\n}\n\n/**\n * Build context reminder based on detected triggers.\n */\nfunction buildTriggerContext(triggers, sessionPath) {\n  if (triggers.length === 0) return '';\n\n  let context = '\\n### Session Update Suggested\\n';\n\n  for (const trigger of triggers) {\n    switch (trigger.type) {\n      case 'todos_changed':\n        context += '- Todos changed - update **Session Log** and **Next Steps**\\n';\n        break;\n      case 'plan_approved':\n        context += '- Plan approved - **IMMEDIATELY update session Approach section with the plan**\\n';\n        context += '  1. Read the plan file\\n';\n        context += '  2. Copy plan summary to session **Approach** section\\n';\n        context += '  3. Update **Next Steps** with implementation phases\\n';\n        break;\n      case 'context_checkpoint':\n        context += `- Context at ${trigger.usage}% - **save state to session before compaction**\\n`;\n        context += '  Document current progress, decisions, and next steps\\n';\n        break;\n    }\n  }\n\n  context += `\\nSession: ${sessionPath}\\n`;\n  return context;\n}\n\nfunction loadState() {\n  return shared.loadState(shared.getStateFile('Memento'), {});\n}\n\nfunction saveState(state) {\n  shared.saveState(shared.getStateFile('Memento'), state);\n}\n\nfunction createSession(sessionPath, branch) {\n  const dir = path.dirname(sessionPath);\n  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n\n  const type = branch.match(/^(?:issue\\/)?(feature|fix|chore)/)?.[1] || 'unknown';\n  const desc = branch.replace(/^(?:issue\\/)?(feature|fix|chore)[-\\/]/, '').replace(/^\\d+[-\\/]/, '');\n  const today = new Date().toISOString().split('T')[0];\n\n  fs.writeFileSync(sessionPath, `# Session: ${desc}\n\n## Details\n- **Branch**: ${branch}\n- **Type**: ${type}\n- **Created**: ${today}\n- **Status**: in-progress\n\n## Goal\n[Describe the objective]\n\n## Session Log\n- ${today}: Session created\n\n## Next Steps\n1. [First task]\n`);\n}\n\n// ============================================================================\n// Hook Callbacks\n// ============================================================================\n\nfunction onSessionStart(input, base) {\n  const cwd = input.cwd || process.cwd();\n  const gitRoot = getGitRoot(cwd);\n  const branch = getBranch(cwd);\n\n  if (!gitRoot || !branch) {\n    return {\n      statusLine: 'üìç Memento: No session (not a git repo)',\n      additionalContext: base.additionalContext\n    };\n  }\n\n  if (branch === 'main' || branch === 'master') {\n    return {\n      statusLine: `üìç Memento: No session (${branch})`,\n      additionalContext: base.additionalContext\n    };\n  }\n\n  const sessionPath = getSessionPath(gitRoot, branch);\n  const sessionName = path.basename(sessionPath);\n  const isNew = !fs.existsSync(sessionPath);\n\n  // Create session if missing\n  if (isNew) createSession(sessionPath, branch);\n\n  // Save current branch\n  saveState({ branch });\n\n  // Build status line\n  let statusLine;\n  if (isNew) {\n    statusLine = `üìç Memento: NEW ‚Üí ${sessionName}`;\n  } else {\n    statusLine = `üìç Memento: ${sessionName}`;\n  }\n\n  // Build context\n  let context = base.additionalContext || '';\n  context += `\\nüìÇ Session: ${sessionPath}`;\n  if (isNew) {\n    context += '\\nNew session created. Update Goal and Next Steps.';\n  } else {\n    context += '\\nFor resumption: Read session file FIRST.';\n  }\n  context += '\\nAfter responding: assess if work warrants session update (milestones, decisions, blockers).';\n\n  return {\n    statusLine,\n    additionalContext: context,\n    extra: { sessionPath, isNew }\n  };\n}\n\nfunction onUserPromptSubmit(input, base) {\n  const cwd = input.cwd || process.cwd();\n  const gitRoot = getGitRoot(cwd);\n  const branch = getBranch(cwd);\n\n  if (!gitRoot || !branch || branch === 'main' || branch === 'master') {\n    return null; // Use base behavior\n  }\n\n  // Load state to detect branch switch\n  const state = loadState();\n  const previousBranch = state.branch;\n  const branchChanged = previousBranch && previousBranch !== branch;\n\n  const sessionPath = getSessionPath(gitRoot, branch);\n  const sessionExists = fs.existsSync(sessionPath);\n\n  // Build context\n  let context = base.additionalContext || '';\n\n  if (branchChanged) {\n    // Branch switch detected - update state\n    saveState({ branch });\n\n    // Check for misnamed session (references branch but wrong filename)\n    const mismatch = sessionExists ? null : detectMismatch(gitRoot, branch, sessionPath);\n\n    // Find possible sessions if no exact match and no mismatch\n    const possibleSessions = (sessionExists || mismatch) ? [] : findPossibleSessions(gitRoot, branch);\n\n    // Inject switch guidance\n    context += buildSwitchContext(sessionPath, sessionExists, possibleSessions, branch, mismatch);\n\n    return {\n      additionalContext: context,\n      extra: {\n        sessionPath,\n        branchChanged: true,\n        previousBranch,\n        sessionExists,\n        mismatch,\n        possibleSessions\n      }\n    };\n  }\n\n  // Detect session update triggers\n  const triggers = detectSessionTriggers(input);\n\n  // Normal prompt - standard session reminder\n  context += `\\nüìÇ Session: ${sessionPath}`;\n  if (!sessionExists) {\n    context += '\\nNo session file found. Consider creating one with `/memento:session create`.';\n  } else {\n    context += '\\nFor resumption: Read session file FIRST.';\n  }\n\n  // Add trigger-based reminders if any detected\n  if (triggers.length > 0) {\n    context += buildTriggerContext(triggers, sessionPath);\n  } else {\n    // Periodic reminder every 5 prompts to assess session state\n    const promptCount = base.promptCount || 0;\n    const SESSION_REMINDER_INTERVAL = 5;\n    if (promptCount > 0 && promptCount % SESSION_REMINDER_INTERVAL === 0) {\n      context += '\\n\\nüìù **Session Check**: Has anything happened worth recording? Key decisions, requirements, design changes, or blockers should be captured in the session file.';\n    } else {\n      context += '\\nAfter responding: assess if work warrants session update (milestones, decisions, blockers).';\n    }\n  }\n\n  return {\n    additionalContext: context,\n    extra: { sessionPath, sessionExists, triggers }\n  };\n}\n\n// ============================================================================\n// Direct Processing (for testing)\n// ============================================================================\n\nfunction processHook(input) {\n  const config = {\n    pluginName: 'Memento',\n    pluginRoot: PLUGIN_ROOT,\n    onSessionStart,\n    onUserPromptSubmit\n  };\n  return shared.processHook(config, input);\n}\n\n// ============================================================================\n// Main Entry Point\n// ============================================================================\n\nif (require.main === module) {\n  shared.runHook({\n    pluginName: 'Memento',\n    pluginRoot: PLUGIN_ROOT,\n    onSessionStart,\n    onUserPromptSubmit\n  });\n}\n\n// ============================================================================\n// Exports (for testing)\n// ============================================================================\n\nmodule.exports = {\n  processHook,\n  getBranch,\n  getGitRoot,\n  getSessionPath,\n  getSessionsDir,\n  createSession,\n  loadState,\n  saveState,\n  findPossibleSessions,\n  detectMismatch,\n  buildSwitchContext,\n  detectSessionTriggers,\n  buildTriggerContext\n};\n",
        "memento/skills/resume/SKILL.md": "---\nname: resume\ndescription: |\n  Resume work from the current session. Use this skill when:\n  - User asks \"what's next?\" or \"where was I?\"\n  - User starts a new conversation on a feature branch\n  - User returns after a break and needs context\n  - User asks about current work status\n---\n\n# Resume Work\n\nLoad and display session context to resume work after a break or new conversation.\n\n## When to Use This Skill\n\nProactively invoke when user:\n- Asks \"what's next?\", \"where was I?\", \"what was I working on?\"\n- Starts a conversation on a non-main branch without context\n- Returns from a break and seems to need orientation\n- Asks about current task, issue, or progress\n\n## Context Files (Auto-Injected)\n\n- **rules/sessions.md**: Rules for session workflow\n- **context/sessions.md**: Session file structure and patterns\n\nRead these files for complete session management guidance.\n\n## Quick Reference\n\n### Load Session\n\n1. Get current branch:\n   ```bash\n   git branch --show-current\n   ```\n\n2. Sanitize branch name (replace `/` with `-`)\n\n3. Read session file:\n   ```\n   .claude/sessions/<sanitized-branch>.md\n   ```\n\n### Display Context\n\nShow the user:\n1. **Goal** - What we're trying to accomplish\n2. **Approach** - How we planned to do it\n3. **Next Steps** - What's remaining (focus here)\n4. **Recent Session Log** - Last 2-3 entries for context\n\n### Example Output\n\n```\nResuming session for issue/feature-42/auth\n\nGoal: Add user authentication to the application\n\nApproach: JWT-based auth with httpOnly cookies\n\nNext Steps:\n- [ ] Add logout endpoint\n- [ ] Implement token refresh\n- [x] Create login form\n\nRecent activity:\n- 2024-01-15: Implemented login form and JWT handling\n- 2024-01-14: Set up auth middleware\n```\n\n## What This Skill Does NOT Do\n\n- Create new sessions (use `/memento:session create`)\n- Update session content (edit directly or use hooks)\n- Handle branch switching (handled by session-manager)\n\n## Key Rules (from rules/sessions.md)\n\n1. **Never guess branch** - always `git branch --show-current`\n2. **Session = Branch = Issue** - 1:1:1 mapping\n3. **Read session FIRST** on resume - before any other action\n",
        "memento/skills/session-manager/SKILL.md": "---\nname: session-manager\ndescription: |\n  Manage Claude Code sessions for the current branch. Use this skill when:\n  - User asks \"what's next?\" or \"where was I?\"\n  - User starts work on a new branch without a session\n  - Before committing (to update session log)\n  - When resuming work after a break\n---\n\n# Session Manager\n\nManage work sessions that persist context across conversation resets.\n\n## When to Use This Skill\n\nProactively invoke when user:\n- Asks about current work context\n- Switches branches and needs session context\n- Wants to create or update a session\n- Is resuming work or asking \"what's next?\"\n\n## Context Files (Auto-Injected)\n\n- **rules/sessions.md**: Rules for session workflow (BLOCKING requirements)\n- **context/sessions.md**: Detailed examples and patterns\n\nRead these files for complete guidance. This skill provides quick reference only.\n\n## Quick Reference\n\n### Check Session Status\n```bash\ngit branch --show-current\n# Sanitize: replace / with -\n# Read: .claude/branches/<sanitized>\n# Read: .claude/sessions/<session>.md ‚Üí focus on Next Steps\n```\n\n### Create Session\nUse `/memento:session create` command.\n\n### Update Session\nEdit session file directly. Update triggers:\n- Beginning work\n- After milestone\n- Before pause\n- Before commit (atomic with code)\n\n## Key Rules (from rules/sessions.md)\n\n1. **Never guess current branch** ‚Äî always `git branch --show-current`\n2. **Session = Branch = Issue** (1:1:1 mapping)\n3. **Atomic commits** ‚Äî session + code together\n4. **BLOCKING**: No source edits without active session\n\n## What This Skill Does NOT Do\n\n- Define session file format (see context/sessions.md)\n- Define workflow patterns (see rules/sessions.md)\n- Handle git operations (see rules/git.md, context/git.md via onus)\n",
        "memento/skills/session.md": "# Session Management\n\nManage the current session file.\n\n## Arguments\n\n- **(none)**: Show session status\n- **create**: Create session (auto-created by hook, rarely needed)\n- **update**: Update session with recent progress\n- **complete**: Mark session as complete\n\n## Actions\n\n### No argument: Show status\n1. Get branch: `git branch --show-current`\n2. Find session: `.claude/sessions/<branch-sanitized>.md`\n3. Display: status, next steps, recent log\n\n### update: Log progress\n1. Read the session file\n2. Update these sections:\n   - **Session Log**: Add today's date and what was accomplished\n   - **Files Changed**: List any new files modified\n   - **Next Steps**: Update based on current state\n3. Write the updated file\n\n### complete: Mark done\n1. Change **Status** to `complete`\n2. Add final log entry\n3. Clear Next Steps or mark all done\n",
        "onus/.claude-plugin/plugin.json": "{\n  \"name\": \"onus\",\n  \"version\": \"0.3.5\",\n  \"description\": \"Work item automation for Claude Code - auto-injected via hooks, zero config\",\n  \"author\": {\n    \"name\": \"David Puglielli\"\n  },\n  \"repository\": \"https://github.com/flexion/claude-domestique\",\n  \"homepage\": \"https://github.com/flexion/claude-domestique/tree/main/onus\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"issues\",\n    \"work-items\",\n    \"commits\",\n    \"pull-requests\",\n    \"github\",\n    \"jira\"\n  ],\n  \"commands\": [\n    \"./commands/init.md\",\n    \"./commands/fetch.md\",\n    \"./commands/create.md\",\n    \"./commands/update.md\",\n    \"./commands/close.md\",\n    \"./commands/commit.md\",\n    \"./commands/pr.md\",\n    \"./commands/status.md\",\n    \"./commands/validate-criteria.md\"\n  ],\n  \"skills\": \"./skills/\"\n}\n",
        "onus/README.md": "# onus\n\n> \"The burden is mine now.\"\n\nThe awful-but-important work that developers hate: JIRA tickets, Azure DevOps work items, commit messages, PR descriptions. Someone has to carry this load. Now Claude does.\n\n### Flexion Fundamentals\n\nonus helps developers embody Flexion fundamentals while staying in flow:\n\n- **Never compromise on quality** ‚Äî Ensures proper commit messages, ticket updates, and PR descriptions\n- **Lead by example** ‚Äî Handles PM accountability work so it actually gets done\n- **Empower customers to adapt** ‚Äî Keeps stakeholders informed via trackers without breaking developer focus\n\n## The Problem\n\nYou're in flow. You've just solved an elegant problem. Now you need to:\n\n1. Update the JIRA ticket with what you did\n2. Write a commit message that references the ticket\n3. Create a PR description that satisfies the template\n4. Link it all together so PMs can track progress\n\nYou groan. The context switch kills your momentum. You write \"fixed bug\" and move on. The PM asks for details. Rinse, repeat.\n\n## The Solution\n\nonus handles the project management bureaucracy:\n\n- **Fetches work items** from GitHub Issues, JIRA, Azure DevOps\n- **Auto-populates sessions** with issue details (integrates with [memento](../memento))\n- **Generates commit messages** that reference tickets properly\n- **Creates PR descriptions** from your session and work item\n- **Updates work items** with progress (bidirectional sync)\n\nYou code. Claude carries the burden.\n\n## Features\n\n- **Multi-platform support** - GitHub Issues, JIRA, Azure DevOps\n- **Issue-to-session bridge** - Fetches requirements, acceptance criteria, links\n- **Commit message formatting** - `#123 - verb description` with proper linking\n- **PR description generation** - Pulls from session log, maps to acceptance criteria\n- **Work item updates** - Push status, comments, links back to the tracker\n- **Branch naming** - Suggests `issue/feature-N/description` from work item\n\n## Plugin Family\n\nonus is part of a plugin family that works together:\n\n| Plugin | Purpose | Layer |\n|--------|---------|-------|\n| **[memento](../memento)** | Session persistence | Persistence |\n| **[mantra](../mantra)** | Context refresh | Injection |\n| **[onus](../onus)** | Work-item automation | Integration |\n\n### How They Work Together\n\n```\nExternal (GitHub/JIRA/Azure DevOps)\n        ‚îÇ\n        ‚ñº fetch issue details\n    [onus]\n        ‚îÇ\n        ‚ñº populate session file\n    [memento] ‚Üê‚îÄ‚îÄ \"What's next?\" lookup\n        ‚îÇ\n        ‚ñº read session context\n    [mantra] ‚îÄ‚îÄ‚ñ∫ rules injected via hooks\n```\n\n### Shared Naming Convention\n\nAll three plugins agree on this mapping:\n\n```\nIssue #42 (tracker)\n    ‚Üì\nBranch: issue/feature-42/description\n    ‚Üì\nMetadata: .claude/branches/issue-feature-42-description\n    ‚Üì\nSession: .claude/sessions/issue-feature-42-description.md\n```\n\n### Interoperability\n\n- **onus ‚Üí memento**: Onus fetches issue details and populates the session file that memento manages\n- **memento ‚Üí mantra**: Session files live alongside context files; mantra can refresh session-aware context\n- **mantra ‚Üí memento**: Mantra keeps behavioral rules fresh; memento persists the actual work state\n\nEach plugin works standalone but gains enhanced behavior when used together.\n\n## Companion Plugins\n\nThese external plugins complement onus workflows:\n\n| Plugin | Purpose | When to Use |\n|--------|---------|-------------|\n| **[pr-review-toolkit](https://github.com/anthropics/claude-code/tree/main/plugins/pr-review-toolkit)** | Code quality review | Before creating PRs |\n\n### pr-review-toolkit\n\nOfficial Anthropic plugin with 6 specialized review agents (comment accuracy, test coverage, error handling, type design, code review, simplification). Install it for thorough code review before PR creation:\n\n```bash\n/plugins\n# Search for \"pr-review-toolkit\" and install\n```\n\nWhen onus generates a PR, consider running a review first:\n```\n# Review before PR\n/pr-review-toolkit:review-pr\n\n# Then create PR with onus\n```\n\n## Installation\n\n```bash\n# Add the marketplace\n/plugin marketplace add flexion/claude-domestique\n\n# Install the plugin\n/plugin install onus@claude-domestique\n```\n\nThat's it. Work item detection works automatically‚Äîno initialization required.\n\n## Configuration\n\nonus works zero-config by default (GitHub Issues). Use `/onus:init` to create configuration:\n\n```bash\n/onus:init                    # Auto-detect from git remote\n/onus:init --platform jira    # Use JIRA\n/onus:init --force            # Overwrite existing config\n```\n\nThe init command:\n1. Analyzes recent commits to detect existing patterns\n2. Creates `.claude/config.json` with detected or default formats\n3. Auto-detects GitHub owner/repo from git remote\n\n### Generated Config\n\n```json\n{\n  \"onus\": {\n    \"platform\": \"github\",\n    \"github\": {\n      \"owner\": \"your-org\",\n      \"repo\": \"your-repo\"\n    },\n    \"commitFormat\": {\n      \"issue\": \"{number} - {verb} {description}\",\n      \"chore\": \"chore - {description}\"\n    },\n    \"branchFormat\": {\n      \"issue\": \"issue/{type}-{number}/{slug}\",\n      \"chore\": \"chore/{slug}\"\n    }\n  }\n}\n```\n\n### Supported Platforms\n\n| Platform | Config Key | Required Fields |\n|----------|------------|-----------------|\n| GitHub Issues | `github` | `owner`, `repo` (auto-detected from git remote) |\n| JIRA | `jira` | `host`, `project` |\n| Azure DevOps | `azure` | `org`, `project` |\n\n### Programmatic Configuration\n\nFor scripts or automation, use the init module:\n\n```javascript\nconst { init, detectGitRemote, buildDefaultConfig } = require('@claude-domestique/onus');\n\n// Auto-detect from git remote (defaults to GitHub Issues)\ninit(projectPath);\n\n// Explicit platform\ninit(projectPath, {\n  platform: 'jira',\n  overrides: { jiraHost: 'company.atlassian.net', jiraProject: 'PROJ' }\n});\n\n// Force overwrite existing config\ninit(projectPath, { platform: 'azure', force: true });\n```\n\n## How It Works\n\nonus uses Claude Code's hook system for automatic work item detection:\n\n| Hook | When | What Happens |\n|------|------|--------------|\n| **SessionStart** | New conversation | Detects issue number from branch, injects work item context |\n| **UserPromptSubmit** | Every prompt | Shows issue number in status line |\n\n### Automatic Issue Detection\n\nWhen you're on a branch like `issue/feature-42/add-auth`:\n1. onus extracts issue number `42` from the branch name\n2. Shows `üìã Issue: 42` in status line\n3. Use `/onus:fetch 42` to load full issue details\n\n### Status Line\n\nEvery prompt shows issue status:\n\n```\nüìã Onus: #3 ‚úì\nüìã Issue: 42\n```\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/onus:init` | Initialize project config (detects commit patterns) |\n| `/onus:fetch` | Fetch issue details from tracker |\n| `/onus:create` | Create new work item |\n| `/onus:update` | Update work item (comment, status, fields) |\n| `/onus:close` | Close a work item |\n| `/onus:commit` | Create a commit with validation and format guidance |\n| `/onus:pr` | Create a pull request with validation and format guidance |\n| `/onus:status` | Show work item dashboard (issue, session, git state) |\n| `/onus:validate-criteria` | Check acceptance criteria completion before commit/PR |\n\n## Why \"onus\"?\n\n*Onus* (Latin): a burden, duty, or responsibility.\n\n\"The onus is on you to update the ticket.\"\n\"The onus of keeping JIRA in sync falls on someone.\"\n\nIt's the weight you carry. Now Claude carries it for you.\n\n## License\n\nMIT\n",
        "onus/commands/close.md": "---\ndescription: Close a work item\nargument-hint: <issue-number> [reason]\n---\n\n# Close Work Item\n\nClose an issue/work item on your configured platform.\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to work items, issues, or the specific platform (match by filename, e.g. `work-items.md`, `jira.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/work-items.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\nBefore closing, verify:\n\n1. **Acceptance criteria met** - Check all criteria are addressed\n2. **PR merged** - If code changes were involved\n3. **Reason** - Completed, Won't Fix, Duplicate, etc.\n\n## Platform Commands\n\n### GitHub Issues\n\n**Close as completed:**\n```bash\ngh issue close 42 --reason completed\n```\n\n**Close as not planned:**\n```bash\ngh issue close 42 --reason \"not planned\"\n```\n\n**Close with comment:**\n```bash\ngh issue close 42 --comment \"Completed in PR #55\"\n```\n\n### JIRA\n\nTransition to Done/Closed status:\n- Method: POST\n- URL: `https://{host}/rest/api/3/issue/PROJ-123/transitions`\n- Body: `{ \"transition\": { \"id\": \"done-transition-id\" } }`\n\nTo find transition IDs:\n- GET `https://{host}/rest/api/3/issue/PROJ-123/transitions`\n\n### Azure DevOps\n\nUpdate state to Closed/Done:\n- Method: PATCH\n- URL: `https://dev.azure.com/{org}/{project}/_apis/wit/workitems/42?api-version=7.0`\n- Body:\n```json\n[\n  { \"op\": \"add\", \"path\": \"/fields/System.State\", \"value\": \"Closed\" }\n]\n```\n\n## Close Reasons\n\n| Reason | When to Use |\n|--------|-------------|\n| **Completed** | Work is done, acceptance criteria met |\n| **Duplicate** | Same as another issue (link to original) |\n| **Won't Fix** | Valid issue but won't be addressed |\n| **Invalid** | Not a real issue or works as designed |\n| **Stale** | No activity, no longer relevant |\n\n## Example Interactions\n\n### Close completed issue\n```\nUser: /onus:close 42\n\nClaude: Before closing #42, let me verify:\n- PR #55 merged: Yes\n- Acceptance criteria:\n  - [x] User login works\n  - [x] Error messages display\n  - [x] Token stored securely\n\nAll criteria met. Closing as completed...\n[Runs: gh issue close 42 --reason completed --comment \"Completed in PR #55\"]\n\nIssue #42 closed.\n```\n\n### Close as duplicate\n```\nUser: /onus:close 42 duplicate\n\nClaude: Which issue is this a duplicate of?\n\nUser: #38\n\nClaude: Closing as duplicate of #38...\n[Runs: gh issue close 42 --comment \"Duplicate of #38\"]\n\nIssue #42 closed as duplicate.\n```\n\n### Close won't fix\n```\nUser: /onus:close 42 wontfix\n\nClaude: Please provide a reason for not fixing:\n\nUser: Out of scope for current release\n\nClaude: Closing as not planned...\n[Runs: gh issue close 42 --reason \"not planned\" --comment \"Out of scope for current release\"]\n\nIssue #42 closed as not planned.\n```\n\n## Verification Checklist\n\nBefore closing, Claude should verify:\n\n- [ ] All acceptance criteria addressed (or explicitly descoped)\n- [ ] Related PR merged (if applicable)\n- [ ] No blocking issues remain\n- [ ] Closing reason documented\n\n## Reopening\n\nIf closed in error:\n\n**GitHub:**\n```bash\ngh issue reopen 42\n```\n\n**JIRA/Azure:** Use transition/state change to reopen.\n\n## Troubleshooting\n\n**Can't close?**\n- Check you have write permissions\n- JIRA: Verify the \"Close\" transition is available from current state\n- Some workflows require fields to be set before closing\n",
        "onus/commands/commit.md": "---\ndescription: Create a commit with validation and format guidance\nargument-hint: [message]\n---\n\n# Commit Changes\n\nCreate a git commit following project conventions with validation.\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to git, commits, PRs, or branches (match by filename, e.g. `git.md`, `commits.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/git.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\n**IMPORTANT: Consult the COMMIT CHECKLIST from git.md before proceeding.**\n\n### Pre-Commit Validation\n\nBefore creating the commit, verify:\n\n1. **Check current branch**\n   ```bash\n   git branch --show-current\n   ```\n   - If on `main` or `master`: STOP and ask user\n   - Options: create a branch first, or confirm direct commit is intentional\n\n2. **Run tests** (if applicable)\n   ```bash\n   npm test\n   ```\n\n3. **Check for session file**\n   - Read `.claude/sessions/<branch>.md`\n   - If missing: create session file using `/memento:session create`\n   - Update Session Log, Files Changed sections if needed\n   - Session file should be committed atomically with code\n\n4. **Session completion check** (if this is the final commit)\n   - Ask: \"Is this the final commit for this work? Mark session complete?\"\n   - If yes:\n     - Change status: `in-progress` ‚Üí `complete`\n     - Mark acceptance criteria as done: `- [ ]` ‚Üí `- [x]`\n     - Add final Session Log entry\n   - This ensures clean working directory after PR creation\n\n5. **Check staged changes**\n   ```bash\n   git status\n   git diff --staged\n   ```\n\n### Determine Commit Type\n\nAsk user if not clear from context:\n- **Issue commit**: `#N - verb description` (linked to GitHub issue)\n- **Chore commit**: `chore - description` (no issue number)\n\nNever guess issue numbers - ask if unclear.\n\n### Generate Commit Message\n\n**Format Requirements:**\n- Lowercase description (except proper nouns)\n- Present tense verb: add, fix, update, remove, refactor\n- No emojis\n- No attribution, no co-authored-by\n- Use HEREDOC for multi-line messages\n\n**Single-line commit:**\n```bash\ngit commit -m \"#42 - add user authentication\"\n```\n\n**Multi-line commit with bullets:**\n```bash\ngit commit -m \"$(cat <<'EOF'\n#42 - add user authentication\n\n- Implement login form with email/password\n- Add JWT token handling\n- Create auth middleware\nEOF\n)\"\n```\n\n**Chore format:**\n```bash\ngit commit -m \"chore - update dependencies\"\n```\n\n### After Commit\n\n1. Verify commit was created:\n   ```bash\n   git log -1 --oneline\n   ```\n\n2. Show next steps:\n   - Push to remote: `git push -u origin <branch>`\n   - Create PR: `/onus:pr`\n\n## Example Interaction\n\n```\nUser: /onus:commit\n\nClaude: I'll help you create a commit. Let me check the staged changes.\n\n[Runs git status, git diff --staged]\n\nYou have changes in:\n- src/auth/login.ts\n- src/auth/middleware.ts\n\nIs this for an issue or a chore?\n\nUser: Issue #42\n\nClaude: I'll update the session file and create the commit.\n\n[Updates session file, then commits]\n\ngit commit -m \"$(cat <<'EOF'\n#42 - add user authentication\n\n- Implement login form with email/password\n- Add JWT token handling\nEOF\n)\"\n\nCommitted: #42 - add user authentication\nNext: `git push -u origin issue/feature-42/auth` or `/onus:pr`\n```\n\n## Troubleshooting\n\n**Pre-commit hook failed?**\n- Fix the issues reported by the hook\n- Stage the fixes: `git add .`\n- Try commit again (do NOT use --no-verify)\n\n**Nothing to commit?**\n- Check `git status` for unstaged changes\n- Stage changes: `git add <files>` or `git add -p`\n\n**Wrong message format?**\n- Use `git commit --amend` only if commit hasn't been pushed\n- Otherwise, make a new commit with correct format\n",
        "onus/commands/create.md": "---\ndescription: Create a new work item on issue tracker\nargument-hint: [title]\n---\n\n# Create Work Item\n\nCreate a new issue/work item on your configured platform (GitHub, JIRA, or Azure DevOps).\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to work items, issues, or the specific platform (match by filename, e.g. `work-items.md`, `jira.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/work-items.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\n**IMPORTANT: Gather information before creating.**\n\nBefore creating the work item, ask the user for:\n\n### 1. Title (required)\nA concise summary of the issue/feature/task.\n\n### 2. Type (optional)\n- **feature** - New functionality\n- **bug** - Something isn't working\n- **task** - General work item\n- **chore** - Maintenance/cleanup\n\n### 3. Description (optional)\nDetailed description of the work item. Ask if they want to include:\n- Problem statement\n- Acceptance criteria\n- Technical notes\n\n### 4. Labels (optional)\nTags to categorize the work item.\n\n## Platform Commands\n\n### GitHub Issues\n\n```bash\ngh issue create --title \"Title here\" --body \"Description here\" --label \"bug,priority:high\"\n```\n\nTo create interactively:\n```bash\ngh issue create\n```\n\n### JIRA\n\nUse WebFetch with the JIRA REST API:\n- Method: POST\n- URL: `https://{host}/rest/api/3/issue`\n- Headers: `Authorization: Basic {JIRA_TOKEN}`, `Content-Type: application/json`\n- Body:\n```json\n{\n  \"fields\": {\n    \"project\": { \"key\": \"PROJ\" },\n    \"summary\": \"Title here\",\n    \"description\": { \"type\": \"doc\", \"version\": 1, \"content\": [...] },\n    \"issuetype\": { \"name\": \"Task\" }\n  }\n}\n```\n\n### Azure DevOps\n\nUse WebFetch with the Azure DevOps API:\n- Method: POST\n- URL: `https://dev.azure.com/{org}/{project}/_apis/wit/workitems/$Task?api-version=7.0`\n- Headers: `Authorization: Basic {AZURE_DEVOPS_TOKEN}`, `Content-Type: application/json-patch+json`\n- Body: JSON Patch format\n\n## After Creation\n\n1. Note the new issue number/key\n2. Suggest creating a branch: `git checkout -b issue/feature-{N}/{slug}`\n3. Offer to fetch the full issue details: `/onus:fetch {N}`\n\n## Example Interaction\n\n```\nUser: /onus:create\n\nClaude: I'll help you create a new work item. What's the title?\n\nUser: Add dark mode support\n\nClaude: Got it. What type of work item is this?\n- feature (new functionality)\n- bug (something broken)\n- task (general work)\n\nUser: feature\n\nClaude: Would you like to add a description or acceptance criteria?\n\nUser: Yes - should support system preference detection\n\nClaude: Creating the issue now...\n[Creates issue via gh issue create]\n\nCreated issue #87: Add dark mode support\nSuggested branch: git checkout -b issue/feature-87/add-dark-mode-support\n```\n\n## Troubleshooting\n\n**Permission denied?**\n- GitHub: Ensure `GITHUB_TOKEN` has `repo` scope\n- JIRA: Ensure token has project write access\n- Azure: Ensure PAT has Work Items (Read, Write) scope\n\n**Wrong project?**\n- Check `.claude/config.json` for platform configuration\n- Run `/onus:init` to reconfigure\n",
        "onus/commands/fetch.md": "---\ndescription: Fetch work item details from issue tracker\nargument-hint: <issue-number>\n---\n\n# Fetch Work Item Details\n\nFetch issue/work item details from your configured platform (GitHub, JIRA, or Azure DevOps).\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to work items, issues, or the specific platform (match by filename, e.g. `work-items.md`, `jira.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/work-items.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\nTo fetch issue details, use the appropriate command based on your platform:\n\n### GitHub Issues\n\nUse the GitHub CLI (recommended):\n```bash\ngh issue view 42 --json number,title,body,state,labels,assignees\n```\n\n### JIRA\n\nUse WebFetch with the JIRA REST API:\n- URL: `https://{host}/rest/api/3/issue/PROJ-123`\n- Headers: `Authorization: Basic {JIRA_TOKEN}`\n\nExtract title, description, status, and acceptance criteria from the response.\n\n### Azure DevOps\n\nUse WebFetch with the Azure DevOps API:\n- URL: `https://dev.azure.com/{org}/{project}/_apis/wit/workitems/42?api-version=7.0`\n- Headers: `Authorization: Basic {AZURE_DEVOPS_TOKEN}`\n\nExtract title, description, state, and work item type from the response.\n\n## What to Extract\n\nWhen fetching an issue, capture:\n\n1. **Key/Number**: Issue identifier\n2. **Title**: Summary of the issue\n3. **Description**: Full description (may contain acceptance criteria)\n4. **Status**: Current state (Open, In Progress, etc.)\n5. **Type**: Bug, Feature, Task, etc.\n6. **Labels/Tags**: Classification\n7. **Assignee**: Who's working on it\n8. **Acceptance Criteria**: Checkboxes or definition of done\n\n## Caching\n\nAfter fetching, the issue details are cached locally in `~/.claude/onus/work-item-cache.json`.\n\nThe cache:\n- Persists across sessions\n- Auto-expires after 1 hour\n- Can be refreshed with `/fetch` at any time\n\n## Example Response\n\n```yaml\nIssue #42\nTitle: Implement user authentication\nType: feature\nStatus: In Progress\nLabels: auth, security, priority:high\n\nDescription:\nAdd email/password authentication to the application.\n\nAcceptance Criteria:\n- [ ] Login form with email and password fields\n- [ ] Form validation with error messages\n- [ ] Secure token storage (httpOnly cookies)\n- [ ] Auto-logout on token expiry\n- [ ] \"Remember me\" functionality\n\nCommit format: #42 - {verb} {description}\n```\n\n## Integration with Session\n\nAfter fetching, the issue context is:\n1. Cached locally for quick access\n2. Injected on session start\n3. Available for commit message suggestions\n4. Used for PR description generation\n\n## Troubleshooting\n\n**Issue not found?**\n- Check the issue number is correct\n- Verify platform configuration in `.claude/config.json`\n- Ensure authentication token is set\n\n**Authentication failed?**\n- GitHub: `export GITHUB_TOKEN=ghp_...` ([Create PAT](https://github.com/settings/tokens))\n- JIRA: `export JIRA_TOKEN=$(echo -n \"email:api_token\" | base64)` ([Get API token](https://id.atlassian.com/manage-profile/security/api-tokens))\n- Azure: `export AZURE_DEVOPS_TOKEN=$(echo -n \":pat\" | base64)` ([Create PAT](https://dev.azure.com/_usersSettings/tokens))\n\n**Stale data?**\n- Run `/fetch` again to refresh the cache\n- Cache expires after 1 hour automatically\n",
        "onus/commands/init.md": "---\ndescription: Initialize onus configuration for a project\nargument-hint: \"[--platform github|jira|azure] [--force]\"\n---\n\n# Initialize Onus Configuration\n\nSet up `.claude/config.json` with onus configuration for work item tracking.\n\n## Task\n\n### Step 1: Detect Existing Commit Patterns\n\nBefore creating config, analyze recent commits to detect existing conventions:\n\n```bash\ngit log --oneline -30\n```\n\nLook for these common patterns:\n\n| Pattern | Example | Format String |\n|---------|---------|---------------|\n| Issue number prefix | `#42 - add feature` | `{number} - {description}` |\n| Conventional commits | `feat(auth): add login` | `{type}({scope}): {description}` |\n| JIRA style | `[PROJ-123] fix bug` | `[{project}-{number}] {description}` |\n| Semantic | `fix: resolve issue` | `{type}: {description}` |\n| Chore prefix | `chore - update deps` | `chore - {description}` |\n\nIf a clear pattern emerges (>50% of commits), note it for Step 3.\n\n### Step 2: Run Init Script\n\nRun the init script to create base configuration:\n\n```bash\nnode \"$(node -p \"require(process.env.HOME + '/.claude/plugins/installed_plugins.json').plugins['onus@claude-domestique'][0].installPath\")/scripts/init.js\"\n```\n\nThe script auto-detects GitHub owner/repo from the git remote.\n\n## Platforms\n\nSpecify the work item platform (defaults to `github`):\n\n- **github** - GitHub Issues (auto-detected from git remote)\n- **jira** - JIRA (requires manual host/project configuration)\n- **azure** - Azure DevOps (requires manual org/project configuration)\n\n## What It Does\n\n1. Detects GitHub owner/repo from git remote URL\n2. Creates `.claude/config.json` with onus section\n3. Sets default commit/branch formats\n4. Preserves existing config sections (merges, doesn't overwrite)\n\n## Generated Config\n\n```json\n{\n  \"onus\": {\n    \"platform\": \"github\",\n    \"github\": {\n      \"owner\": \"<detected>\",\n      \"repo\": \"<detected>\"\n    },\n    \"commitFormat\": {\n      \"issue\": \"{number} - {verb} {description}\",\n      \"chore\": \"chore - {description}\"\n    },\n    \"branchFormat\": {\n      \"issue\": \"issue/{type}-{number}/{slug}\",\n      \"chore\": \"chore/{slug}\"\n    }\n  }\n}\n```\n\n### Step 3: Update Config with Detected Patterns\n\nIf Step 1 detected a different commit pattern, update `.claude/config.json`:\n\n**Conventional Commits detected:**\n```json\n\"commitFormat\": {\n  \"issue\": \"{type}({scope}): {description} (#{number})\",\n  \"chore\": \"chore: {description}\"\n}\n```\n\n**JIRA style detected:**\n```json\n\"commitFormat\": {\n  \"issue\": \"[{project}-{number}] {description}\",\n  \"chore\": \"chore: {description}\"\n}\n```\n\n**No clear pattern:** Keep the defaults - they follow common GitHub conventions.\n\n## Options\n\n- `--force` - Overwrite existing onus config\n- `--platform <name>` - Set work item platform (github, jira, azure)\n\n## After Initialization\n\nFor JIRA or Azure DevOps, manually edit `.claude/config.json` to add:\n\n**JIRA:**\n```json\n\"jira\": {\n  \"host\": \"your-company.atlassian.net\",\n  \"project\": \"PROJ\"\n}\n```\n\n**Azure DevOps:**\n```json\n\"azure\": {\n  \"org\": \"your-org\",\n  \"project\": \"your-project\"\n}\n```\n\n## Troubleshooting\n\n**\"Configuration already exists\"**\n- Use `--force` to overwrite\n- Or manually edit `.claude/config.json`\n\n**Owner/repo not detected**\n- Ensure you're in a git repository\n- Check that `git remote get-url origin` returns a valid URL\n- For non-GitHub VCS, manually set the github section after init\n",
        "onus/commands/pr.md": "---\ndescription: Create a pull request with validation and format guidance\nargument-hint: [title]\n---\n\n# Create Pull Request\n\nCreate a GitHub pull request following project conventions with validation.\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to git, commits, PRs, or branches (match by filename, e.g. `git.md`, `commits.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/git.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\n**IMPORTANT: Consult the PR CHECKLIST from git.md before proceeding.**\n\n### Pre-PR Validation\n\nBefore creating the PR, verify:\n\n1. **Run tests** (if applicable)\n   ```bash\n   npm test\n   ```\n\n2. **Check current branch and commits**\n   ```bash\n   git branch --show-current\n   git log main..HEAD --oneline\n   git diff main...HEAD --stat\n   ```\n\n3. **Ensure changes are pushed**\n   ```bash\n   git push -u origin $(git branch --show-current)\n   ```\n\n4. **Check session file** for summary content\n   - Read `.claude/sessions/<branch>.md`\n   - Verify session status is `complete` (should be marked before final commit)\n   - Use Goal, Approach, Session Log for PR body\n\n### Determine PR Title Format\n\n**Format Requirements:**\n- Must match commit format exactly\n- `#N - lowercase description` (for issues)\n- `chore - lowercase description` (for chores)\n- No emojis, no attribution\n\n### Locate PR Template\n\nBefore generating PR body, check for project templates:\n\n1. **Check for PR templates**\n   ```bash\n   ls .github/pull_request_template.md .github/PULL_REQUEST_TEMPLATE.md .github/PULL_REQUEST_TEMPLATE/*.md 2>/dev/null\n   ```\n\n2. **Handle results**\n   - **Single template found**: Use it as the PR body structure\n   - **Multiple templates found**:\n     - Parse branch name using `branchFormat` from `.claude/config.json` to determine type\n     - Match type to template name (e.g., `feature` ‚Üí `feature.md`)\n     - Ask user if still ambiguous\n   - **No templates found**: Use generic format (see fallback below)\n\n3. **State the source used**\n   - \"Using project template: .github/PULL_REQUEST_TEMPLATE/feature.md\"\n   - \"No project PR template found, using generic format\"\n\n### Generate PR Body\n\n**If project template was found:**\n- Read the template file\n- Fill in template sections using session file content\n- Preserve all template sections (don't skip any)\n- Map session data: Goal ‚Üí Summary, Approach ‚Üí Details, Session Log ‚Üí Changes\n\n**If no project template (fallback):**\n\nUse session file content to build the body:\n\n```markdown\n## Summary\n<2-3 bullets from Session Log or Approach>\n\n## Test Plan\n<How to verify the changes work>\n\n## Acceptance Criteria\n<From issue, if applicable>\n- [ ] Criterion 1\n- [ ] Criterion 2\n```\n\n**IMPORTANT:**\n- No attribution (no \"Generated with Claude\", no co-authored-by)\n- No emojis\n- No AI mentions\n\n### Create the PR\n\n```bash\ngh pr create --title \"#42 - add user authentication\" --body \"$(cat <<'EOF'\n## Summary\n- Implement login form with email/password fields\n- Add JWT token handling with httpOnly cookies\n- Create auth middleware for protected routes\n\n## Test Plan\n- Run `npm test` to verify unit tests pass\n- Manually test login flow at /login\n\n## Acceptance Criteria\n- [x] Login form with email and password fields\n- [x] Secure token storage\n- [ ] Auto-logout on token expiry (follow-up)\nEOF\n)\"\n```\n\n### After Creation\n\n1. Display the PR URL\n2. Working directory should be **clean** (no uncommitted changes)\n3. Suggest next steps:\n   - Review the PR in browser\n   - Request reviewers if needed\n\n**Note**: Do NOT update the session file after PR creation. The PR number is discoverable via `gh pr view`‚Äîno need to store it in the session.\n\n## Example Interaction\n\n```\nUser: /onus:pr\n\nClaude: I'll help you create a PR. Let me check the branch and commits.\n\n[Runs git branch, git log, reads session file]\n\nBranch: issue/feature-42/auth\nCommits: 3 commits ahead of main\nSession: Goal is \"Add user authentication\"\n\nChecking for PR templates...\nFound: .github/PULL_REQUEST_TEMPLATE/feature.md\nUsing project template for PR body.\n\nCreating PR with title matching your commits...\n\ngh pr create --title \"#42 - add user authentication\" --body \"...\"\n\nCreated: https://github.com/org/repo/pull/87\n\nNext steps:\n- Review at the link above\n- Request reviewers if needed\n```\n\n**Example without project template:**\n```\nChecking for PR templates...\nNo project PR template found, using generic format.\n```\n\n## Troubleshooting\n\n**\"Pull request already exists\"?**\n- Check existing PRs: `gh pr list`\n- View existing PR: `gh pr view`\n\n**Wrong base branch?**\n- Specify base: `gh pr create --base main`\n\n**Need to update PR after creation?**\n- Edit title: `gh pr edit --title \"new title\"`\n- Edit body: `gh pr edit --body \"new body\"`\n\n**Authentication failed?**\n- Ensure `gh auth status` shows logged in\n- Check token has `repo` scope\n",
        "onus/commands/status.md": "---\ndescription: Show current work item status and session overview\nargument-hint:\n---\n\n# Work Item Status\n\nDisplay a dashboard view of the current work item, session, and git state.\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to git, commits, work items, issues, or session management (match by filename, e.g. `git.md`, `work-items.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/git.md` / `extends: onus/work-items.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\nShow a consolidated view of:\n1. Current work item (from branch/cache)\n2. Session file status (from memento)\n3. Git state (branch, staged changes, commits)\n\n### Workflow\n\n1. **Detect Current Context**\n   ```bash\n   git branch --show-current\n   git status --short\n   ```\n\n2. **Load Work Item**\n   - Check onus state file: `~/.claude/onus/state.json`\n   - Load cached details: `~/.claude/onus/work-item-cache.json`\n   - If not cached, show placeholder with fetch suggestion\n\n3. **Load Session**\n   - Check `.claude/sessions/<branch>.md`\n   - Extract key sections: Goal, Status, Next Steps\n\n4. **Show Git Status**\n   - Uncommitted changes\n   - Commits ahead/behind remote\n   - Staged files\n\n### Output Format\n\n```\n## Work Item Dashboard\n\n### Current Work Item\n- **Issue**: #[number] - [title]\n- **Type**: [feature/bug/chore]\n- **Status**: [open/in-progress/in-review]\n- **URL**: [link if available]\n\n### Session\n- **File**: .claude/sessions/[filename].md\n- **Status**: [in-progress/complete]\n- **Last Updated**: [timestamp or \"unknown\"]\n\n### Acceptance Criteria\n- [ ] [criterion 1]\n- [x] [criterion 2 - completed]\n- [ ] [criterion 3]\n\n### Git State\n- **Branch**: [branch name]\n- **Remote**: [ahead/behind status]\n- **Staged**: [number of files or \"none\"]\n- **Modified**: [number of files or \"none\"]\n\n### Quick Actions\n- `/onus:fetch` - Refresh issue details\n- `/onus:commit` - Commit staged changes\n- `/onus:pr` - Create pull request\n- `/onus:validate-criteria` - Check criteria completion\n```\n\n## Example\n\n```\nUser: /onus:status\n\nClaude: ## Work Item Dashboard\n\n### Current Work Item\n- **Issue**: #42 - Add user authentication\n- **Type**: feature\n- **Status**: open\n- **URL**: https://github.com/org/repo/issues/42\n\n### Session\n- **File**: .claude/sessions/issue-feature-42-auth.md\n- **Status**: in-progress\n- **Last Updated**: 2024-01-15\n\n### Acceptance Criteria\n- [x] Login form with email/password\n- [x] JWT token handling\n- [ ] Remember me checkbox\n- [ ] Password reset flow\n\n### Git State\n- **Branch**: issue/feature-42/auth\n- **Remote**: 2 commits ahead\n- **Staged**: none\n- **Modified**: 3 files\n\n### Quick Actions\n- `/onus:commit` - Commit your changes\n- `/onus:validate-criteria` - 2 of 4 criteria remaining\n```\n\n## When to Use\n\nInvoke this skill:\n- At the start of a work session\n- When resuming work after a break\n- When unsure of current state\n- Before creating a commit or PR\n\n## Notes\n\n- If no work item is detected, shows guidance for starting work\n- Stale cache data is marked with a warning\n- Session file absence suggests running `/memento:start`\n",
        "onus/commands/update.md": "---\ndescription: Update work item (add comment, change status, edit fields)\nargument-hint: <issue-number> [action]\n---\n\n# Update Work Item\n\nUpdate an existing issue/work item on your configured platform.\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to work items, issues, or the specific platform (match by filename, e.g. `work-items.md`, `jira.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/work-items.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\nDetermine what the user wants to update:\n\n### Actions\n\n1. **Add comment** - Post a progress update or note\n2. **Change status** - Move to different state (In Progress, Done, etc.)\n3. **Edit fields** - Update title, description, labels, assignee\n4. **Check off criteria** - Mark acceptance criteria as done\n\n## Platform Commands\n\n### GitHub Issues\n\n**Add comment:**\n```bash\ngh issue comment 42 --body \"Comment text here\"\n```\n\n**Change status (close/reopen):**\n```bash\ngh issue close 42\ngh issue reopen 42\n```\n\n**Edit fields:**\n```bash\ngh issue edit 42 --title \"New title\"\ngh issue edit 42 --body \"New description\"\ngh issue edit 42 --add-label \"in-progress\"\ngh issue edit 42 --remove-label \"needs-triage\"\ngh issue edit 42 --add-assignee \"@me\"\n```\n\n### JIRA\n\n**Add comment:**\n- Method: POST\n- URL: `https://{host}/rest/api/3/issue/PROJ-123/comment`\n- Body: `{ \"body\": { \"type\": \"doc\", \"version\": 1, \"content\": [...] } }`\n\n**Change status (transition):**\n- Method: POST\n- URL: `https://{host}/rest/api/3/issue/PROJ-123/transitions`\n- Body: `{ \"transition\": { \"id\": \"31\" } }`\n\n**Edit fields:**\n- Method: PUT\n- URL: `https://{host}/rest/api/3/issue/PROJ-123`\n- Body: `{ \"fields\": { \"summary\": \"New title\" } }`\n\n### Azure DevOps\n\n**Add comment:**\n- Method: POST\n- URL: `https://dev.azure.com/{org}/{project}/_apis/wit/workitems/42/comments?api-version=7.0-preview.3`\n- Body: `{ \"text\": \"Comment here\" }`\n\n**Update fields:**\n- Method: PATCH\n- URL: `https://dev.azure.com/{org}/{project}/_apis/wit/workitems/42?api-version=7.0`\n- Body: JSON Patch operations\n\n## Example Interactions\n\n### Adding a comment\n```\nUser: /onus:update 42 comment\n\nClaude: What would you like to comment on issue #42?\n\nUser: Completed the API integration, moving to frontend work\n\nClaude: Adding comment...\n[Runs: gh issue comment 42 --body \"...\"]\n\nComment added to #42.\n```\n\n### Changing status\n```\nUser: /onus:update 42 status\n\nClaude: What status should I set for #42?\nCurrent: Open\nOptions: In Progress, Done, Won't Fix\n\nUser: In Progress\n\nClaude: For GitHub Issues, I'll add a label. Adding 'in-progress' label...\n[Runs: gh issue edit 42 --add-label \"in-progress\"]\n```\n\n### Checking off acceptance criteria\n```\nUser: /onus:update 42 criteria\n\nClaude: Which acceptance criteria have been completed?\nCurrent criteria for #42:\n- [ ] User can log in with email/password\n- [ ] Form validates input\n- [ ] Token stored securely\n\nUser: The first two are done\n\nClaude: I'll add a comment documenting progress...\n[Runs: gh issue comment 42 --body \"Progress update: ...\"]\n```\n\n## Bulk Updates\n\nTo update multiple issues:\n```bash\n# Close all issues with a label\ngh issue list --label \"duplicate\" --json number -q '.[].number' | xargs -I {} gh issue close {}\n```\n\n## Troubleshooting\n\n**Can't transition issue (JIRA)?**\n- Check available transitions: GET `/rest/api/3/issue/PROJ-123/transitions`\n- Ensure you have permission for that transition\n\n**Comment failed?**\n- Verify issue exists and you have write access\n- Check authentication token is valid\n",
        "onus/commands/validate-criteria.md": "---\ndescription: Check acceptance criteria completion before commit/PR\nargument-hint: [issue number or session file path]\n---\n\n# Validate Acceptance Criteria\n\nCheck whether all acceptance criteria from the issue have been addressed before creating a commit or PR.\n\n## Task\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to work items, issues, acceptance criteria, or validation (match by filename, e.g. `work-items.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/work-items.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\n**IMPORTANT: This skill implements the ACCEPTANCE CRITERIA rule from work-items.md**\n\nBefore committing or creating a PR, verify that all acceptance criteria have been met.\n\n### Workflow\n\n1. **Locate Criteria**\n   Find acceptance criteria from one of these sources (in priority order):\n   - Session file: `.claude/sessions/<branch>.md`\n   - Cached work item: use `/onus:fetch` if needed\n   - GitHub issue directly: `gh issue view <number>`\n\n2. **Review Each Criterion**\n   For each acceptance criterion:\n   - Check if implementation addresses it\n   - Look at relevant code changes\n   - Verify tests exist if applicable\n\n3. **Report Status**\n   Present findings with clear status for each criterion\n\n### Output Format\n\n```\n## Acceptance Criteria Validation\n\n**Issue**: #[number] - [title]\n**Branch**: [current branch]\n\n### Criteria Status\n\n| Status | Criterion | Evidence |\n|--------|-----------|----------|\n| ‚úÖ | [criterion text] | [file:line or description] |\n| ‚ö†Ô∏è | [criterion text] | [partial implementation note] |\n| ‚ùå | [criterion text] | [not found or missing] |\n\n### Summary\n- Completed: X of Y\n- [proceed/address issues before commit]\n\n### Next Steps\n[what needs to be done for incomplete items]\n```\n\n## Example\n\n```\nUser: /onus:validate-criteria\n\nClaude: ## Acceptance Criteria Validation\n\n**Issue**: #42 - Add user authentication\n**Branch**: issue/feature-42/auth\n\n### Criteria Status\n\n| Status | Criterion | Evidence |\n|--------|-----------|----------|\n| ‚úÖ | Login form with email/password | src/components/LoginForm.tsx:15-80 |\n| ‚úÖ | JWT token handling | src/lib/auth.ts:20-45 |\n| ‚úÖ | Error messages for invalid credentials | src/components/LoginForm.tsx:35-50 |\n| ‚ö†Ô∏è | Remember me checkbox | Implemented but not tested |\n| ‚ùå | Password reset flow | Not started |\n\n### Summary\n- Completed: 3 of 5 (1 partial, 1 missing)\n- Address issues before commit\n\n### Next Steps\n1. Add tests for \"Remember me\" functionality\n2. Implement password reset flow or remove from scope\n3. Update issue if scope changed\n```\n\n## When to Use\n\nInvoke this skill:\n- Before running `/onus:commit`\n- Before running `/onus:pr`\n- When unsure if work is complete\n- During code review\n\n## Notes\n\n- Incomplete criteria doesn't always mean \"don't commit\"\n- Partial implementations might be intentional (phased delivery)\n- If scope changed, update the issue first\n- Session file criteria and issue criteria should match\n",
        "onus/hooks/__tests__/work-item.test.js": "/**\n * Tests for onus work-item hook - plugin-specific logic only\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\nconst {\n  loadState,\n  saveState,\n  loadProjectConfig,\n  loadWorkItemCache,\n  saveWorkItemCache,\n  extractIssueFromBranch,\n  detectPlatform,\n  getCommitFormat,\n  getCachedWorkItem,\n  createPlaceholderWorkItem,\n  formatWorkItemContext,\n  DEFAULT_CONFIG,\n  PLATFORM_CONFIG\n} = require('../work-item.js');\n\ndescribe('onus work-item hook', () => {\n  let tmpDir;\n  let stateFile;\n  let cacheFile;\n\n  beforeEach(() => {\n    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'onus-test-'));\n    stateFile = path.join(tmpDir, 'state.json');\n    cacheFile = path.join(tmpDir, 'cache.json');\n  });\n\n  afterEach(() => {\n    fs.rmSync(tmpDir, { recursive: true, force: true });\n  });\n\n  describe('extractIssueFromBranch', () => {\n    const patterns = DEFAULT_CONFIG.branchPatterns;\n\n    it('extracts issue from issue/feature-N/description format', () => {\n      expect(extractIssueFromBranch('issue/feature-42/user-login', patterns)).toBe('42');\n      expect(extractIssueFromBranch('issue/bug-123/fix-crash', patterns)).toBe('123');\n      expect(extractIssueFromBranch('issue/fix-99/hotfix', patterns)).toBe('99');\n    });\n\n    it('extracts issue from feature/N-description format', () => {\n      expect(extractIssueFromBranch('feature/42-user-login', patterns)).toBe('42');\n      expect(extractIssueFromBranch('bug/123-fix-crash', patterns)).toBe('123');\n    });\n\n    it('extracts issue from N-description format', () => {\n      expect(extractIssueFromBranch('42-user-login', patterns)).toBe('42');\n      expect(extractIssueFromBranch('123-fix-crash', patterns)).toBe('123');\n    });\n\n    it('extracts JIRA-style keys', () => {\n      expect(extractIssueFromBranch('PROJ-123-description', patterns)).toBe('PROJ-123');\n      expect(extractIssueFromBranch('ABC-1-short', patterns)).toBe('ABC-1');\n    });\n\n    it('extracts from #N references', () => {\n      expect(extractIssueFromBranch('feature-with-#42-ref', patterns)).toBe('42');\n    });\n\n    it('returns null for branches without issue reference', () => {\n      expect(extractIssueFromBranch('main', patterns)).toBeNull();\n      expect(extractIssueFromBranch('develop', patterns)).toBeNull();\n      expect(extractIssueFromBranch('feature/no-number', patterns)).toBeNull();\n    });\n\n    it('returns null for null/undefined input', () => {\n      expect(extractIssueFromBranch(null, patterns)).toBeNull();\n      expect(extractIssueFromBranch(undefined, patterns)).toBeNull();\n    });\n  });\n\n  describe('detectPlatform', () => {\n    it('detects JIRA from key format', () => {\n      expect(detectPlatform('PROJ-123')).toBe('jira');\n      expect(detectPlatform('ABC-1')).toBe('jira');\n      expect(detectPlatform('LONGPROJ-99999')).toBe('jira');\n    });\n\n    it('detects GitHub from numeric format', () => {\n      expect(detectPlatform('42')).toBe('github');\n      expect(detectPlatform('123')).toBe('github');\n      expect(detectPlatform('99999')).toBe('github');\n    });\n\n    it('defaults to GitHub for unknown formats', () => {\n      expect(detectPlatform('unknown')).toBe('github');\n      expect(detectPlatform('')).toBe('github');\n    });\n\n    it('returns github for null/undefined', () => {\n      expect(detectPlatform(null)).toBe('github');\n      expect(detectPlatform(undefined)).toBe('github');\n    });\n  });\n\n  describe('getCommitFormat', () => {\n    it('returns string format as-is', () => {\n      expect(getCommitFormat('{number} - {description}')).toBe('{number} - {description}');\n    });\n\n    it('extracts issue format from object', () => {\n      const objFormat = {\n        issue: '{number} - {verb} {description}',\n        chore: 'chore - {description}'\n      };\n      expect(getCommitFormat(objFormat, 'issue')).toBe('{number} - {verb} {description}');\n      expect(getCommitFormat(objFormat, 'chore')).toBe('chore - {description}');\n    });\n\n    it('defaults to issue format when type not specified', () => {\n      const objFormat = {\n        issue: 'issue format',\n        chore: 'chore format'\n      };\n      expect(getCommitFormat(objFormat)).toBe('issue format');\n    });\n\n    it('falls back to issue format when type not found in object', () => {\n      const objFormat = { issue: 'issue format' };\n      expect(getCommitFormat(objFormat, 'unknown')).toBe('issue format');\n    });\n\n    it('returns default format for null/undefined', () => {\n      expect(getCommitFormat(null)).toBe('{number} - {verb} {description}');\n      expect(getCommitFormat(undefined)).toBe('{number} - {verb} {description}');\n    });\n  });\n\n  describe('loadState and saveState', () => {\n    it('returns default state when file does not exist', () => {\n      const state = loadState(stateFile);\n      expect(state).toEqual({ currentIssue: null, currentBranch: null });\n    });\n\n    it('saves and loads state correctly', () => {\n      const testState = {\n        currentIssue: '42',\n        currentBranch: 'feature/42-test',\n        sessionStart: '2024-01-01T00:00:00Z'\n      };\n\n      saveState(stateFile, testState);\n      const loaded = loadState(stateFile);\n      expect(loaded).toEqual(testState);\n    });\n\n    it('handles corrupted state file gracefully', () => {\n      fs.writeFileSync(stateFile, 'not json');\n      const state = loadState(stateFile);\n      expect(state).toEqual({ currentIssue: null, currentBranch: null });\n    });\n  });\n\n  describe('loadWorkItemCache and saveWorkItemCache', () => {\n    it('returns empty cache when file does not exist', () => {\n      const cache = loadWorkItemCache(cacheFile);\n      expect(cache).toEqual({ items: {}, lastUpdated: null });\n    });\n\n    it('saves and loads cache correctly', () => {\n      const testCache = {\n        items: {\n          'github:42': {\n            key: '42',\n            title: 'Test issue',\n            cachedAt: Date.now()\n          }\n        },\n        lastUpdated: Date.now()\n      };\n\n      saveWorkItemCache(cacheFile, testCache);\n      const loaded = loadWorkItemCache(cacheFile);\n      expect(loaded).toEqual(testCache);\n    });\n  });\n\n  describe('getCachedWorkItem', () => {\n    it('returns null when item not in cache', () => {\n      const cache = { items: {} };\n      expect(getCachedWorkItem(cache, '42', 'github')).toBeNull();\n    });\n\n    it('returns item when in cache and fresh', () => {\n      const cache = {\n        items: {\n          'github:42': {\n            key: '42',\n            title: 'Test',\n            cachedAt: Date.now()\n          }\n        }\n      };\n      const item = getCachedWorkItem(cache, '42', 'github');\n      expect(item.key).toBe('42');\n      expect(item.stale).toBeUndefined();\n    });\n\n    it('marks item as stale when old', () => {\n      const cache = {\n        items: {\n          'github:42': {\n            key: '42',\n            title: 'Test',\n            cachedAt: Date.now() - 2 * 60 * 60 * 1000 // 2 hours ago\n          }\n        }\n      };\n      const item = getCachedWorkItem(cache, '42', 'github');\n      expect(item.stale).toBe(true);\n    });\n  });\n\n  describe('createPlaceholderWorkItem', () => {\n    it('creates placeholder with correct structure', () => {\n      const item = createPlaceholderWorkItem('42', 'github');\n      expect(item.key).toBe('42');\n      expect(item.platform).toBe('github');\n      expect(item.placeholder).toBe(true);\n      expect(item.title).toBe('Issue 42');\n      expect(item.cachedAt).toBeDefined();\n    });\n\n    it('works for JIRA keys', () => {\n      const item = createPlaceholderWorkItem('PROJ-123', 'jira');\n      expect(item.key).toBe('PROJ-123');\n      expect(item.platform).toBe('jira');\n      expect(item.title).toBe('Issue PROJ-123');\n    });\n  });\n\n  describe('formatWorkItemContext', () => {\n    const cfg = DEFAULT_CONFIG;\n\n    it('returns null for null work item', () => {\n      expect(formatWorkItemContext(null, cfg)).toBeNull();\n    });\n\n    it('formats placeholder correctly', () => {\n      const item = createPlaceholderWorkItem('42', 'github');\n      const formatted = formatWorkItemContext(item, cfg);\n      expect(formatted).toContain('Issue details not yet fetched');\n      expect(formatted).toContain('/fetch 42');\n      expect(formatted).toContain('Commit format');\n    });\n\n    it('formats full work item correctly', () => {\n      const item = {\n        key: '42',\n        title: 'User login feature',\n        type: 'feature',\n        status: 'In Progress',\n        description: 'Implement user login',\n        acceptanceCriteria: ['Login form', 'Validation'],\n        labels: ['auth', 'priority:high'],\n        url: 'https://github.com/org/repo/issues/42'\n      };\n      const formatted = formatWorkItemContext(item, cfg);\n      expect(formatted).toContain('42');\n      expect(formatted).toContain('User login feature');\n      expect(formatted).toContain('feature');\n      expect(formatted).toContain('In Progress');\n      expect(formatted).toContain('Login form');\n      expect(formatted).toContain('auth, priority:high');\n    });\n\n    it('truncates long descriptions', () => {\n      const item = {\n        key: '42',\n        title: 'Test',\n        description: 'a'.repeat(600)\n      };\n      const formatted = formatWorkItemContext(item, cfg);\n      expect(formatted).toContain('...');\n      expect(formatted.length).toBeLessThan(1000);\n    });\n\n    it('handles object-style commitFormat', () => {\n      const objectCfg = {\n        ...cfg,\n        commitFormat: {\n          issue: '{number} - {verb} {description}',\n          chore: 'chore - {description}'\n        }\n      };\n      const item = createPlaceholderWorkItem('42', 'github');\n      const formatted = formatWorkItemContext(item, objectCfg);\n      expect(formatted).toContain('42 - {verb} {description}');\n    });\n  });\n\n  describe('loadProjectConfig', () => {\n    it('returns empty object when config does not exist', () => {\n      const config = loadProjectConfig(tmpDir, '.claude/config.json');\n      expect(config).toEqual({});\n    });\n\n    it('loads onus config from file', () => {\n      const claudeDir = path.join(tmpDir, '.claude');\n      fs.mkdirSync(claudeDir, { recursive: true });\n      fs.writeFileSync(\n        path.join(claudeDir, 'config.json'),\n        JSON.stringify({\n          onus: {\n            platform: 'jira',\n            commitFormat: 'custom format'\n          }\n        })\n      );\n\n      const config = loadProjectConfig(tmpDir, '.claude/config.json');\n      expect(config.platform).toBe('jira');\n      expect(config.commitFormat).toBe('custom format');\n    });\n\n    it('handles corrupted config gracefully', () => {\n      const claudeDir = path.join(tmpDir, '.claude');\n      fs.mkdirSync(claudeDir, { recursive: true });\n      fs.writeFileSync(path.join(claudeDir, 'config.json'), 'not json');\n\n      const config = loadProjectConfig(tmpDir, '.claude/config.json');\n      expect(config).toEqual({});\n    });\n  });\n\n  describe('DEFAULT_CONFIG', () => {\n    it('has required fields', () => {\n      expect(DEFAULT_CONFIG.stateFile).toBeDefined();\n      expect(DEFAULT_CONFIG.cacheFile).toBeDefined();\n      expect(DEFAULT_CONFIG.configFile).toBeDefined();\n      expect(DEFAULT_CONFIG.branchPatterns).toBeInstanceOf(Array);\n      expect(DEFAULT_CONFIG.commitFormat).toBeDefined();\n      expect(DEFAULT_CONFIG.branchFormat).toBeDefined();\n    });\n  });\n\n  describe('PLATFORM_CONFIG', () => {\n    it('has configuration for all platforms', () => {\n      expect(PLATFORM_CONFIG.github).toBeDefined();\n      expect(PLATFORM_CONFIG.jira).toBeDefined();\n      expect(PLATFORM_CONFIG.azure).toBeDefined();\n    });\n  });\n});\n",
        "onus/hooks/hooks.json": "{\n  \"description\": \"Work item automation - injects issue context on session start, tracks work progress\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/work-item.js\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/work-item.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "onus/hooks/work-item.js": "#!/usr/bin/env node\n/**\n * onus: Work item automation hook\n *\n * Delegates to shared hook handler with custom work item tracking.\n * Context injection via hooks - zero configuration required.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// Use bundled shared module (for installed plugins) or workspace module (for development)\nlet shared;\ntry {\n  shared = require('../lib/shared');\n} catch {\n  shared = require('../../shared');\n}\n\nconst PLUGIN_ROOT = path.resolve(__dirname, '..');\n\n// State and cache locations\nconst STATE_DIR = path.join(process.env.HOME || '/tmp', '.claude', 'onus');\nconst WORK_ITEM_CACHE_FILE = path.join(STATE_DIR, 'work-item-cache.json');\nconst STATE_FILE = path.join(STATE_DIR, 'state.json');\n\n// Default configuration\nconst DEFAULT_CONFIG = {\n  stateFile: STATE_FILE,\n  cacheFile: WORK_ITEM_CACHE_FILE,\n  configFile: '.claude/config.json',\n  branchPatterns: [\n    /^issue\\/(?:feature|bug|fix|chore)-(\\d+)/,\n    /^(?:feature|bug|fix|hotfix)\\/(\\d+)/,\n    /^(\\d+)-/,\n    /^([A-Z]+-\\d+)/,\n    /#(\\d+)/\n  ],\n  commitFormat: '{number} - {verb} {description}',\n  branchFormat: 'issue/feature-{number}/{slug}'\n};\n\n// Platform configurations\nconst PLATFORM_CONFIG = {\n  github: { name: 'GitHub Issues' },\n  jira: { name: 'JIRA' },\n  azure: { name: 'Azure DevOps' }\n};\n\n// ============================================================================\n// Git Helpers\n// ============================================================================\n\nfunction getCurrentBranch(cwd) {\n  try {\n    return execSync('git rev-parse --abbrev-ref HEAD', {\n      cwd, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe']\n    }).trim();\n  } catch { return null; }\n}\n\nfunction getGitRoot(cwd) {\n  try {\n    return execSync('git rev-parse --show-toplevel', {\n      cwd, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe']\n    }).trim();\n  } catch { return null; }\n}\n\nfunction hasStagedChanges(cwd) {\n  try {\n    const result = execSync('git diff --cached --name-only', {\n      cwd, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe']\n    }).trim();\n    return result.length > 0;\n  } catch { return false; }\n}\n\n// ============================================================================\n// Issue Detection\n// ============================================================================\n\nfunction extractIssueFromBranch(branch, patterns) {\n  if (!branch) return null;\n  for (const pattern of patterns) {\n    const match = branch.match(pattern);\n    if (match && match[1]) return match[1];\n  }\n  return null;\n}\n\nfunction detectPlatform(issueKey) {\n  if (!issueKey) return 'github';\n  if (/^[A-Z]+-\\d+$/.test(issueKey)) return 'jira';\n  return 'github';\n}\n\n/**\n * Get the commit format string, handling both legacy string format\n * and new object format with {issue, chore} keys.\n */\nfunction getCommitFormat(commitFormat, type = 'issue') {\n  if (typeof commitFormat === 'string') {\n    return commitFormat;\n  }\n  if (typeof commitFormat === 'object' && commitFormat !== null) {\n    return commitFormat[type] || commitFormat.issue || '{number} - {verb} {description}';\n  }\n  return '{number} - {verb} {description}';\n}\n\n// ============================================================================\n// Work Item Cache\n// ============================================================================\n\nfunction ensureStateDir() {\n  shared.ensureDir(STATE_DIR);\n}\n\nfunction loadWorkItemCache(cacheFile) {\n  try {\n    if (fs.existsSync(cacheFile)) {\n      return JSON.parse(fs.readFileSync(cacheFile, 'utf8'));\n    }\n  } catch { /* ignore */ }\n  return { items: {}, lastUpdated: null };\n}\n\nfunction saveWorkItemCache(cacheFile, cache) {\n  try {\n    ensureStateDir();\n    fs.writeFileSync(cacheFile, JSON.stringify(cache, null, 2));\n  } catch { /* ignore */ }\n}\n\nfunction loadState(stateFile) {\n  try {\n    if (fs.existsSync(stateFile)) {\n      return JSON.parse(fs.readFileSync(stateFile, 'utf8'));\n    }\n  } catch { /* ignore */ }\n  return { currentIssue: null, currentBranch: null };\n}\n\nfunction saveState(stateFile, state) {\n  try {\n    ensureStateDir();\n    fs.writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch { /* ignore */ }\n}\n\nfunction getCachedWorkItem(cache, issueKey, platform) {\n  const cacheKey = `${platform}:${issueKey}`;\n  const item = cache.items[cacheKey];\n  if (!item) return null;\n\n  const cacheAge = Date.now() - (item.cachedAt || 0);\n  const maxAge = 60 * 60 * 1000; // 1 hour\n  if (cacheAge > maxAge) return { ...item, stale: true };\n  return item;\n}\n\nfunction createPlaceholderWorkItem(issueKey, platform) {\n  return {\n    key: issueKey,\n    platform,\n    title: `Issue ${issueKey}`,\n    placeholder: true,\n    cachedAt: Date.now()\n  };\n}\n\n// ============================================================================\n// Project Config\n// ============================================================================\n\nfunction loadProjectConfig(cwd, configFile) {\n  const configPath = path.join(cwd, configFile);\n  try {\n    if (fs.existsSync(configPath)) {\n      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));\n      return config.onus || config.workItem || {};\n    }\n  } catch { /* ignore */ }\n  return {};\n}\n\n// ============================================================================\n// Context Formatting\n// ============================================================================\n\nfunction formatWorkItemContext(workItem, cfg) {\n  if (!workItem) return null;\n\n  const parts = [`## Current Work Item: ${workItem.key}`];\n\n  if (workItem.placeholder) {\n    parts.push(`‚ö†Ô∏è Issue details not yet fetched. Use \\`/fetch ${workItem.key}\\` to load details.`);\n    parts.push('');\n    parts.push('**Commit format reminder:**');\n    parts.push(`\\`${getCommitFormat(cfg.commitFormat).replace('{number}', workItem.key)}\\``);\n    return parts.join('\\n');\n  }\n\n  if (workItem.title) parts.push(`**Title:** ${workItem.title}`);\n  if (workItem.type && workItem.type !== 'unknown') parts.push(`**Type:** ${workItem.type}`);\n  if (workItem.status && workItem.status !== 'unknown') parts.push(`**Status:** ${workItem.status}`);\n  if (workItem.url) parts.push(`**URL:** ${workItem.url}`);\n\n  if (workItem.description) {\n    parts.push('');\n    parts.push('**Description:**');\n    const desc = workItem.description.length > 500\n      ? workItem.description.substring(0, 500) + '...'\n      : workItem.description;\n    parts.push(desc);\n  }\n\n  if (workItem.acceptanceCriteria?.length > 0) {\n    parts.push('');\n    parts.push('**Acceptance Criteria:**');\n    for (const criterion of workItem.acceptanceCriteria) {\n      parts.push(`- [ ] ${criterion}`);\n    }\n  }\n\n  if (workItem.labels?.length > 0) {\n    parts.push('');\n    parts.push(`**Labels:** ${workItem.labels.join(', ')}`);\n  }\n\n  parts.push('');\n  parts.push('**Commit format:**');\n  parts.push(`\\`${getCommitFormat(cfg.commitFormat).replace('{number}', workItem.key)}\\``);\n\n  if (workItem.stale) {\n    parts.push('');\n    parts.push('‚ö†Ô∏è Cached data may be stale. Use `/fetch` to refresh.');\n  }\n\n  return parts.join('\\n');\n}\n\n// ============================================================================\n// Hook Callbacks\n// ============================================================================\n\nfunction onSessionStart(input, base) {\n  const cwd = input.cwd || process.cwd();\n  const projectConfig = loadProjectConfig(cwd, DEFAULT_CONFIG.configFile);\n  const cfg = { ...DEFAULT_CONFIG, ...projectConfig };\n  const source = input.source || 'startup';\n\n  ensureStateDir();\n\n  const branch = getCurrentBranch(cwd);\n  const issueKey = extractIssueFromBranch(branch, cfg.branchPatterns);\n  const platform = detectPlatform(issueKey);\n\n  // Load cache and get/create work item\n  const cache = loadWorkItemCache(cfg.cacheFile);\n  let workItem = null;\n  let isNewIssue = false;\n\n  if (issueKey) {\n    workItem = getCachedWorkItem(cache, issueKey, platform);\n    if (!workItem) {\n      workItem = createPlaceholderWorkItem(issueKey, platform);\n      isNewIssue = true;\n      const cacheKey = `${platform}:${issueKey}`;\n      cache.items[cacheKey] = workItem;\n      saveWorkItemCache(cfg.cacheFile, cache);\n    }\n  }\n\n  // Update state\n  saveState(cfg.stateFile, {\n    currentIssue: issueKey,\n    currentBranch: branch,\n    platform,\n    sessionStart: new Date().toISOString()\n  });\n\n  // Build status line\n  let statusLine;\n  if (!issueKey) {\n    statusLine = 'üìç Onus: no issue';\n  } else {\n    const issueRef = workItem && !workItem.placeholder\n      ? `#${workItem.key} - ${workItem.title || 'Untitled'}`\n      : `#${issueKey}`;\n    statusLine = isNewIssue\n      ? `üìç Onus: NEW ‚Üí ${issueRef}`\n      : `üìç Onus: ${issueRef}`;\n  }\n\n  // Build context - append work item info to base context\n  let context = base.additionalContext || '';\n  if (workItem) {\n    const workItemContext = formatWorkItemContext(workItem, cfg);\n    if (workItemContext) {\n      context += `\\n\\n${workItemContext}`;\n    }\n  }\n\n  return {\n    statusLine,\n    additionalContext: context,\n    extra: { currentIssue: issueKey, platform, source }\n  };\n}\n\nfunction onUserPromptSubmit(input, base) {\n  const cwd = input.cwd || process.cwd();\n  const projectConfig = loadProjectConfig(cwd, DEFAULT_CONFIG.configFile);\n  const cfg = { ...DEFAULT_CONFIG, ...projectConfig };\n\n  const state = loadState(cfg.stateFile);\n  const currentBranch = getCurrentBranch(cwd);\n\n  // Detect branch change\n  let branchChanged = false;\n  if (currentBranch !== state.currentBranch) {\n    branchChanged = true;\n    const issueKey = extractIssueFromBranch(currentBranch, cfg.branchPatterns);\n    const platform = detectPlatform(issueKey);\n    state.currentBranch = currentBranch;\n    state.currentIssue = issueKey;\n    state.platform = platform;\n    saveState(cfg.stateFile, state);\n  }\n\n  const staged = hasStagedChanges(cwd);\n\n  // Get cached work item\n  let workItem = null;\n  if (state.currentIssue) {\n    const cache = loadWorkItemCache(cfg.cacheFile);\n    workItem = getCachedWorkItem(cache, state.currentIssue, state.platform || 'github');\n  }\n\n  // Build minimal context\n  let context = base.additionalContext || '';\n  if (state.currentIssue) {\n    context += `\\nüìã Issue: ${state.currentIssue}`;\n  }\n  if (staged) {\n    context += `\\nüí° Staged changes detected. Commit format: \\`${getCommitFormat(cfg.commitFormat).replace('{number}', state.currentIssue || 'N')}\\``;\n  }\n\n  return {\n    additionalContext: context,\n    extra: { currentIssue: state.currentIssue, branchChanged, staged }\n  };\n}\n\n// ============================================================================\n// Direct Processing (for testing)\n// ============================================================================\n\nfunction processHook(input, config = {}) {\n  const hookConfig = {\n    pluginName: 'Onus',\n    pluginRoot: PLUGIN_ROOT,\n    onSessionStart,\n    onUserPromptSubmit,\n    ...config\n  };\n  return shared.processHook(hookConfig, input);\n}\n\nfunction processSessionStart(input, config = {}) {\n  return processHook({ ...input, hook_event_name: 'SessionStart' }, config);\n}\n\nfunction processUserPromptSubmit(input, config = {}) {\n  return processHook({ ...input, hook_event_name: 'UserPromptSubmit' }, config);\n}\n\n// ============================================================================\n// Main Entry Point\n// ============================================================================\n\nif (require.main === module) {\n  shared.runHook({\n    pluginName: 'Onus',\n    pluginRoot: PLUGIN_ROOT,\n    onSessionStart,\n    onUserPromptSubmit\n  });\n}\n\n// ============================================================================\n// Exports (for testing)\n// ============================================================================\n\nmodule.exports = {\n  processHook,\n  processSessionStart,\n  processUserPromptSubmit,\n  loadState,\n  saveState,\n  loadProjectConfig,\n  loadWorkItemCache,\n  saveWorkItemCache,\n  getCurrentBranch,\n  getGitRoot,\n  hasStagedChanges,\n  extractIssueFromBranch,\n  detectPlatform,\n  getCommitFormat,\n  getCachedWorkItem,\n  createPlaceholderWorkItem,\n  formatWorkItemContext,\n  ensureStateDir,\n  DEFAULT_CONFIG,\n  PLATFORM_CONFIG,\n  PLUGIN_ROOT,\n  STATE_DIR\n};\n",
        "onus/skills/work-item-handler/SKILL.md": "---\nname: work-item-handler\ndescription: |\n  Fetch and manage work items from issue trackers. Use this skill when:\n  - User references an issue number (#42, PROJ-123)\n  - User asks about requirements or acceptance criteria\n  - User needs to understand current task scope\n---\n\n# Work Item Handler\n\nIntegrate with issue trackers (GitHub, JIRA, Azure DevOps) for context-aware assistance.\n\n## When to Use This Skill\n\nProactively invoke when user:\n- Mentions an issue number\n- Asks about requirements or \"what needs to be done\"\n- Needs to fetch/refresh issue details\n- Is unclear about task scope\n\n## Context Files (Auto-Injected)\n\n- **rules/git.md**: Commit and PR format rules (SINGLE SOURCE OF TRUTH)\n- **context/git.md**: Detailed commit/PR examples\n- **rules/work-items.md**: Work item lifecycle\n- **context/work-items.md**: Multi-platform patterns and examples\n\nRead these files for complete guidance. This skill provides quick reference only.\n\n### Load Project Rules\n\nBefore proceeding, check for project-level rules that may override onus defaults:\n\n1. **Scan for project rules**\n   ```bash\n   find .claude/rules -name '*.md' 2>/dev/null\n   ```\n\n2. **If files found**, read any that relate to work items, issues, or the specific platform (match by filename, e.g. `work-items.md`, `jira.md`, by frontmatter `domain:` / `type:` fields, or by `extends: onus/work-items.md`)\n\n3. **Check for companion context** ‚Äî if a rule file's frontmatter contains a `companion:` field, also read that file from `.claude/context/`\n\n4. **State the source**\n   - \"Using project rules from .claude/rules/{filename}\" OR\n   - \"No project rules found, using onus defaults\"\n\n5. **Apply precedence**: project rules override plugin defaults\n\n## Quick Reference\n\n### Fetch Issue (GitHub)\n```bash\ngh issue view <number> --json number,title,body,state,labels\n```\n\n### Use /onus:fetch Command\nFor full fetch with caching:\n```\n/onus:fetch 42\n```\n\n### Caching\n- Location: `~/.claude/onus/work-item-cache.json`\n- Expires: 1 hour\n- Refresh: `/onus:fetch <number>`\n\n## Key Rules\n\n1. **Don't define commit/PR formats here** ‚Äî that's rules/git.md's job\n2. **Don't guess issue numbers** ‚Äî verify with user or parse from branch\n3. **Track acceptance criteria** ‚Äî warn before PR if unaddressed\n\n## What This Skill Does NOT Do\n\n- Define commit message format (see rules/git.md, context/git.md)\n- Define PR format (see rules/git.md, context/git.md)\n- Define work item lifecycle (see rules/work-items.md)\n- Provide detailed fetch examples (see context/work-items.md, commands/fetch.md)\n",
        "onus/templates/config/README.md": "# Configuration Templates\n\nThis directory contains template configuration files for onus.\n\n## config.json.example\n\nTemplate for `.claude/config.json` that configures work item integration.\n\n### Usage\n\nCopy to your project and customize:\n\n```bash\ncp config.json.example /path/to/project/.claude/config.json\n```\n\nOr run the init command which auto-detects settings:\n\n```bash\nnode scripts/init.js /path/to/project\n```\n\n### Platform Configuration\n\n#### GitHub Issues\n\n```json\n{\n  \"onus\": {\n    \"platform\": \"github\",\n    \"github\": {\n      \"owner\": \"your-org\",\n      \"repo\": \"your-repo\"\n    }\n  }\n}\n```\n\nSet `GITHUB_TOKEN` environment variable for API access.\n\n#### JIRA\n\n```json\n{\n  \"onus\": {\n    \"platform\": \"jira\",\n    \"jira\": {\n      \"host\": \"your-company.atlassian.net\",\n      \"project\": \"PROJ\"\n    }\n  }\n}\n```\n\nSet `JIRA_TOKEN` environment variable (base64 encoded `email:api_token`).\n\n#### Azure DevOps\n\n```json\n{\n  \"onus\": {\n    \"platform\": \"azure\",\n    \"azure\": {\n      \"org\": \"your-org\",\n      \"project\": \"your-project\"\n    }\n  }\n}\n```\n\nSet `AZURE_DEVOPS_TOKEN` environment variable (base64 encoded `:pat_token`).\n\n### Customizing Formats\n\n#### Commit Message Format\n\nDefault: `{number} - {verb} {description}`\n\nPlaceholders:\n- `{number}` - Issue number\n- `{verb}` - Action verb (add, fix, update, etc.)\n- `{description}` - Brief description\n\nExamples:\n- `{number} - {verb} {description}` ‚Üí `#42 - add user login form`\n- `[{number}] {verb}: {description}` ‚Üí `[42] add: user login form`\n- `{verb}({number}): {description}` ‚Üí `add(42): user login form`\n\n#### Branch Name Format\n\nDefault: `issue/{type}-{number}/{slug}`\n\nPlaceholders:\n- `{type}` - Issue type (feature, bug, fix, chore)\n- `{number}` - Issue number\n- `{slug}` - URL-friendly description\n\nExamples:\n- `issue/{type}-{number}/{slug}` ‚Üí `issue/feature-42/user-login`\n- `{type}/{number}-{slug}` ‚Üí `feature/42-user-login`\n- `{number}/{slug}` ‚Üí `42/user-login`\n"
      },
      "plugins": [
        {
          "name": "memento",
          "source": "./memento",
          "description": "Session persistence - persist context across conversation resets with branch-based session tracking",
          "version": "0.3.8",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add flexion/claude-domestique",
            "/plugin install memento@claude-domestique"
          ]
        },
        {
          "name": "mantra",
          "source": "./mantra",
          "description": "Context refresh - periodic re-injection of behavioral guidance to prevent context drift",
          "version": "0.4.2",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add flexion/claude-domestique",
            "/plugin install mantra@claude-domestique"
          ]
        },
        {
          "name": "onus",
          "source": "./onus",
          "description": "Work-item automation - fetches issues, generates commits/PRs, syncs progress",
          "version": "0.3.5",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add flexion/claude-domestique",
            "/plugin install onus@claude-domestique"
          ]
        }
      ]
    }
  ]
}