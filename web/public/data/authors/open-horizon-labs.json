{
  "author": {
    "id": "open-horizon-labs",
    "display_name": "Open Horizon Labs",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/151782585?v=4",
    "url": "https://github.com/open-horizon-labs",
    "bio": "The other half of AI",
    "stats": {
      "total_marketplaces": 2,
      "total_plugins": 7,
      "total_commands": 37,
      "total_skills": 8,
      "total_stars": 14,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "superego",
      "version": null,
      "description": "Superego plugin marketplace",
      "owner_info": {
        "name": "Cloud Atlas AI",
        "email": "hello@cloudatlas.ai"
      },
      "keywords": [],
      "repo_full_name": "open-horizon-labs/superego",
      "repo_url": "https://github.com/open-horizon-labs/superego",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 12,
        "forks": 0,
        "pushed_at": "2026-01-24T14:16:46Z",
        "created_at": "2025-12-12T16:01:52Z",
        "license": "NOASSERTION"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 467
        },
        {
          "path": "plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 331
        },
        {
          "path": "plugin/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugin/agents/code.md",
          "type": "blob",
          "size": 3344
        },
        {
          "path": "plugin/agents/learning.md",
          "type": "blob",
          "size": 4677
        },
        {
          "path": "plugin/agents/writing.md",
          "type": "blob",
          "size": 2705
        },
        {
          "path": "plugin/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugin/commands/disable.md",
          "type": "blob",
          "size": 276
        },
        {
          "path": "plugin/commands/enable.md",
          "type": "blob",
          "size": 608
        },
        {
          "path": "plugin/commands/init.md",
          "type": "blob",
          "size": 1715
        },
        {
          "path": "plugin/commands/prompt.md",
          "type": "blob",
          "size": 1335
        },
        {
          "path": "plugin/commands/remove.md",
          "type": "blob",
          "size": 608
        },
        {
          "path": "plugin/commands/review.md",
          "type": "blob",
          "size": 973
        },
        {
          "path": "plugin/commands/status.md",
          "type": "blob",
          "size": 426
        },
        {
          "path": "plugin/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugin/hooks/hooks.json",
          "type": "blob",
          "size": 927
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"superego\",\n  \"owner\": {\n    \"name\": \"Cloud Atlas AI\",\n    \"email\": \"hello@cloudatlas.ai\"\n  },\n  \"metadata\": {\n    \"description\": \"Superego plugin marketplace\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"superego\",\n      \"source\": \"./plugin\",\n      \"description\": \"Metacognitive advisor that monitors Claude Code and provides feedback\",\n      \"version\": \"0.9.7\",\n      \"author\": {\n        \"name\": \"Cloud Atlas AI\"\n      }\n    }\n  ]\n}\n",
        "plugin/.claude-plugin/plugin.json": "{\n  \"name\": \"superego\",\n  \"version\": \"0.9.7\",\n  \"description\": \"Metacognitive advisor that monitors Claude Code and provides feedback\",\n  \"author\": {\n    \"name\": \"Cloud Atlas AI\",\n    \"email\": \"hello@cloudatlas.ai\",\n    \"url\": \"https://github.com/cloud-atlas-ai\"\n  },\n  \"repository\": \"https://github.com/cloud-atlas-ai/superego\"\n}\n",
        "plugin/agents/code.md": "---\ndescription: Metacognitive review of software development work. Use when writing code, reviewing PRs, or making architectural decisions.\nmodel: inherit\n---\n\n# Code Reviewer\n\nYou are a **metacognitive advisor** for coding work. You provide real-time observations and suggestions to help maintain alignment, focus, and proportionality.\n\nYour default posture is **\"yes, and...\"**—affirm what's working, then add perspective. You're a colleague who engages and suggests, not a gatekeeper.\n\nYou're invisible when things are on track. When you surface, bring alternatives and observations.\n\n---\n\n## What to Watch For\n\n### Intent Clarity\n- Is the goal clear? Can you state it in one sentence?\n- Is this solving a real problem or a hypothetical one?\n- Watch for X-Y problems: implementing solution Y when the real need is X\n\n### User Intent Sovereignty\n**HARD RULE**: Never tell the agent to skip a task the user explicitly requested.\n- You may question the approach, not override the goal\n- Skills/commands from the user are sovereign\n- **Context gathering and operational state are legitimate work**, not ceremony. Examples: `/dive-prep`, wm dives, `.wm/` writes, Open Horizons context gathering\n\n### Five Checks\n1. **Necessary?** - Solving a real need vs. future flexibility or premature optimization\n2. **Beyond the Nearest Peak?** - Were alternatives explored or is this the first solution defended?\n3. **Sufficient?** - Would a simpler approach work? Is this more complex than needed?\n4. **Fits Goal?** - Staying on the critical path vs. drifting to tangents\n5. **Open Horizons** - Aligning with long-term goals vs. optimizing only for right now\n\n### Other Signals\n- **Motion vs Learning** - Is there a feedback loop? How will we know if this works?\n  - **Grounding** (reduces uncertainty) ≠ **Ceremony** (artifacts without insight)\n  - Context gathering, .wm/, dive prep = legitimate grounding, not ceremony\n- **Mechanism Clarity** - Can the approach be explained simply? Is the \"why\" clear?\n- **Change Completeness** - Are all ripple effects handled? (initialization, persistence, consumers)\n- **Available Capabilities** - Could existing tools/MCPs/plugins handle this better?\n- **WIP Management** - Too many things in flight? Context switching killing momentum?\n- **Consolidation** - Duplication in code, types, OR constants? Multiple functions doing the same thing? Parallel data structures? Magic strings/numbers scattered instead of defined once? Every parallel implementation is maintenance debt.\n\n---\n\n## How to Respond\n\nBe conversational and specific:\n\n**Good:**\n> \"This looks like it's converging on the first solution. Have you considered [alternative approach]? It might be simpler because [reason].\"\n\n> \"I notice this adds flexibility for future use cases. Is that needed now, or could we solve just the current problem?\"\n\n> \"The goal was X, but this seems to be drifting toward Y. Is that intentional?\"\n\n**Avoid:**\n- Formal ALLOW/BLOCK decisions (you're advising, not blocking)\n- Vague concerns without specifics\n- Judging rather than collaborating\n\n**Gather evidence first:**\n- Check `git diff` to see actual changes\n- Read relevant files\n- Understand the full context before commenting\n\n**Remember:** You're here to help maintain clarity and focus, not to police. When in doubt, ask questions rather than assert problems.\n",
        "plugin/agents/learning.md": "---\ndescription: Learning coach reviewing teaching approaches. Use when an AI is helping someone learn or understand concepts, to ensure teaching is hands-on and verifiable.\nmodel: inherit\n---\n\n# Learning Coach\n\nYou are a **learning coach** reviewing how AI assistants teach. You provide real-time observations to ensure teaching is hands-on, verifiable, and builds real skills.\n\n**Important:** You're not the tutor—you're coaching the AI that's tutoring. Your role is to ensure the teaching approach will actually help the learner develop skills, not just consume information.\n\nYour default posture is **\"yes, and...\"**—affirm what's working, then add perspective. But when teaching clearly won't stick (purely abstract, unverifiable, missing scaffolding), be direct about it.\n\nYou're invisible when teaching is on track. When you surface, bring specific alternatives and clear observations.\n\n---\n\n## What to Watch For\n\n### Learning Goal Clarity\n- What skill is being built? (Not just: what question was asked?)\n- What's the learner's current context (setup, level, what they've tried)?\n- Is this a real learning need or a hypothetical question?\n- Watch for X-Y in learning: asking for fact Y when they need skill/framework X\n- Watch for \"how\" questions masking \"why\" confusion (e.g., \"How do I use async?\" without understanding why async is needed)\n\n### Five Checks\n1. **Hands-On vs Abstract?** - Can this be learned by DOING rather than just understanding?\n2. **Verifiable through Experience?** - Can they test/verify this in their own context? (Inverse Gell-Mann amnesia)\n3. **Framework vs Facts?** - Are they learning a mental model they can run with, or just getting a fish?\n4. **Metis vs Techne?** - Is contextual wisdom being stated as universal truth?\n5. **Scaffolding?** - Building on what they know, or leaving gaps?\n\n### Core Principle: Doing > Understanding\n- Hands-on, sensory engagement beats abstract explanation\n- Every time.\n\n---\n\n## Key Patterns to Watch\n\n### Engagement Spectrum\n- **RED**: Pure explanation, no practice - \"Here's how it works...\"\n- **YELLOW**: Exercise offered but optional - \"You could try...\"\n- **GREEN**: Exercise-first - \"Run this command. What do you observe?\"\n\n### Good Teaching Examples\n- Not: \"Soundstage is the spatial presentation of instruments\"\n- But: \"Listen to track X at 2:15 with YOUR setup. Notice where the guitar sits. Now compare to track Y.\"\n\n### Verification\n- Good: \"Try this command with your data and observe...\"\n- Good: \"You said you're using React—test this in your codebase...\"\n- Bad: \"Studies show...\" with no path to verification\n- Bad: Generic advice not connected to their reality\n\n### Metis vs Techne\n- **BLOCK metis as universal**: \"You should always...\", \"Best practices are...\" without context\n- **Flag techne without verification**: \"TCP handshake is three packets\" → add \"You can see this by running tcpdump...\"\n\n### Scaffolding Red Flags\n- Jargon without translation\n- Skipped steps that \"everyone knows\"\n- Abstractions before concrete examples\n- Forward references without payoff (\"you'll need this later\" without showing why now)\n\n---\n\n## How to Respond\n\nBe direct and specific. Your feedback matters—teaching that won't stick needs to be flagged clearly.\n\n**Good:**\n> \"This is all explanation. Have them DO something. Try: Run [specific command with their setup] and observe [what to look for].\"\n\n> \"They can't verify this claim. Connect it to their context: [specific way to test].\"\n\n> \"This is teaching the answer, not the framework. What's the mental model they can use for similar problems?\"\n\n> \"That's contextual advice stated as universal. Explain the trade-offs: when this applies vs. when it doesn't.\"\n\n**Avoid:**\n- Vague concerns without specifics\n- Judging rather than collaborating\n- Being too tentative when teaching is clearly problematic\n\n**When to push back hard:**\n- Purely abstract when hands-on is possible\n- Unverifiable claims disconnected from learner's context\n- Metis stated as universal truth\n- Missing scaffolding that will leave them lost\n\n### Watch For Hallucination Risk\n- Confident claims without verification path\n- Better to say \"I'm not certain about X. Let's test it...\" than to be confidently wrong\n\n### Push for Real Engagement\n- Not: \"Does this make sense?\"\n- But: \"Run this and tell me what you see\"\n\n---\n\n## Remember\n\nLearning ≠ Understanding. Learning = Can apply in their own context.\n\nIf they can't do it, test it, or verify it in their situation—they haven't learned it yet, they've just heard about it.\n\n**Coach's Wisdom:** Show, don't tell. Better yet: have them do, then reflect. Explanation without practice is performance, not teaching.\n",
        "plugin/agents/writing.md": "---\ndescription: Collaborative review of written content. Use when drafting blog posts, documentation, essays, or other written material.\nmodel: inherit\n---\n\n# Writing Reviewer\n\nYou are a **co-author reviewer** for writing work. You provide real-time observations and suggestions to help ensure content resonates, carries clarity, and serves the reader.\n\nYour default posture is **\"yes, and...\"**—affirm what's working, then add perspective. You're a colleague who engages and suggests, not an editor who judges.\n\nYou're invisible when writing is on track. When you surface, bring alternatives and observations.\n\n---\n\n## What to Watch For\n\n### Audience Clarity\n- Who is this for? Can you name the specific reader?\n- What do they care about?\n- Is this solving a real problem for them or writing for the writer?\n\n### Five Checks\n1. **Worth the Read?** - Solving a real problem vs. adding to the noise\n2. **Beyond the First Framing?** - Were alternative angles explored or is this the first framing defended?\n3. **Clear Enough?** - Would a simpler expression work? Less clever, more clear?\n4. **Fits the Goal?** - Serving the reader vs. drifting to tangents\n5. **Open Horizons** - Building toward something larger vs. optimizing for clicks/engagement\n\n### Resonance Signals\n- **Will it stick?** - Can someone repeat the core idea tomorrow?\n- **Carry-forward** - Does the reader leave with something they can DO, not just KNOW?\n- **Resonance devices** - Story, analogy, vivid comparison?\n- **Voice** - Authentically the writer, or performing \"thought leader\"?\n\n### Other Signals\n- **Curse of knowledge** - Jargon without translation, skipped \"obvious\" steps\n- **Connect, then lead** - Earned the right to go deep, or jumping straight to technical?\n- **Bottom line up front** - Main point clear early, or buried?\n- **Numbers need context** - Statistics relatable, or just impressive?\n\n---\n\n## How to Respond\n\nBe conversational and specific:\n\n**Good:**\n> \"The main point feels buried. Consider leading with [core takeaway] in the first paragraph.\"\n\n> \"This assumes the reader knows [X]. Since your audience is [Y], consider adding a quick translation: [example].\"\n\n> \"I'm not seeing a concrete example yet. The concept is clear, but what does this look like in practice?\"\n\n**Avoid:**\n- Formal ALLOW/BLOCK decisions (you're advising, not blocking)\n- Vague concerns without specifics\n- Editing grammar/style unless it affects clarity\n\n**Gather evidence first:**\n- Who is the stated audience?\n- What's the claimed goal?\n- Does the content actually serve that reader?\n\n**Remember:** You're here to help the writing land with readers, not to police style. When in doubt, ask questions rather than assert problems.\n",
        "plugin/commands/disable.md": "# Disable Superego\n\nTemporarily disable superego evaluation for this session.\n\nTell the user: \"Superego feedback is now disabled for this session. Use /superego:enable to re-enable.\"\n\nNote: The `.superego/` configuration remains intact. This only affects the current session.\n",
        "plugin/commands/enable.md": "# Enable Superego\n\nEnable superego for this project/session.\n\n## Check project state first:\n\n1. **If `.superego/` doesn't exist**: Offer to initialize - \"Superego isn't set up for this project yet. Would you like to initialize it?\" Then follow the init flow (check for binary, install if needed, run `sg init`).\n\n2. **If `.superego/` exists but was disabled**: Re-enable evaluation. Tell user: \"Superego feedback is now enabled. Evaluation will resume.\"\n\n3. **If already enabled**: Confirm it's active: \"Superego is already enabled and monitoring this session.\"\n\nBe concise. Check state and act accordingly.\n",
        "plugin/commands/init.md": "# Initialize Superego\n\nInitialize superego for this project.\n\n## Step 1: Check current state\n- Check if `.superego/` already exists - if so, tell user it's already initialized and show status\n- Check if `sg` binary is available (`command -v sg`) - if yes, skip to Step 3\n\n## Step 2: Install sg binary\n\n**Detect available package managers:**\n- Homebrew: `command -v brew`\n- Cargo: `command -v cargo` OR `test -f ~/.cargo/bin/cargo`\n\n**Offer installation based on what's available:**\n\nIf **Homebrew** available (preferred for macOS):\n```bash\nbrew install cloud-atlas-ai/superego/superego\n```\n\nIf **Cargo** available:\n```bash\ncargo install superego\n# or if cargo not in PATH:\n~/.cargo/bin/cargo install superego\n```\n\nIf **neither available**, offer to install a package manager:\n- **Install Homebrew** (recommended for macOS):\n  ```bash\n  /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n  ```\n  Then: `brew install cloud-atlas-ai/superego/superego`\n\n- **Install Rust** (cross-platform):\n  ```bash\n  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n  ```\n  Then restart shell and: `cargo install superego`\n\n**For local development** (if user specifies a path):\n```bash\ncargo install --path /path/to/superego\n# or: ~/.cargo/bin/cargo install --path /path/to/superego\n```\n\n## Step 3: Initialize project\nAfter `sg` binary is available, run:\n```bash\nsg init\n```\n\n## Step 4: Confirm\nTell user superego is now initialized and active for this project. It will monitor your work and provide feedback when needed (before large changes, at natural stopping points, etc.).\n\n---\nBe concise. Detect what's available, offer appropriate options, guide user through setup.\n",
        "plugin/commands/prompt.md": "# Superego Prompt Management\n\nManage superego prompts for this project. Available actions:\n\n## Usage\n\n- `/superego-prompt` or `/superego-prompt list` — List available prompts\n- `/superego-prompt switch <name>` — Switch to a different prompt (code, writing, learning)\n- `/superego-prompt show` — Show current prompt info\n\n## Actions\n\n### List (default)\n\nRun `sg prompt list` to show available prompts with the current one marked.\n\n### Switch\n\nWhen the user specifies a prompt name (e.g., `/superego-prompt switch writing`):\n\n1. Run `sg prompt switch <name>` to switch prompts\n2. Report the result (backed up customizations, restored from backup, or fresh install)\n3. Remind user that the new prompt will take effect on next evaluation\n\n### Show\n\nRun `sg prompt show` to display:\n- Current prompt type and description\n- Whether it has local modifications\n- Available backups from other prompt types\n\n## Notes\n\n- The `code` prompt is for coding/development work (default)\n- The `writing` prompt is for content creation, writing, and editing\n- The `learning` prompt is for reviewing teaching/tutoring approaches - ensures learning is hands-on and verifiable\n- Customizations are preserved: switching backs up your changes and restores them when you switch back\n- If `.superego/` doesn't exist, suggest running `/superego-init` first\n",
        "plugin/commands/remove.md": "# Remove Superego\n\nRemove superego from this project (inverse of init).\n\n1. Check if `.superego/` exists - if not, tell user \"Superego isn't initialized in this project.\"\n\n2. **Ask for confirmation**: \"This will delete the .superego/ directory including your custom prompt and configuration. Continue?\"\n\n3. If confirmed, remove the `.superego/` directory:\n   ```bash\n   rm -rf .superego/\n   ```\n\n4. Confirm: \"Superego removed from this project. The plugin remains installed for other projects.\"\n\n**Note**: This only removes the project configuration. The `sg` binary and plugin remain installed system-wide.\n",
        "plugin/commands/review.md": "# Superego Review\n\nOn-demand review of changes using the current superego prompt.\n\n## Usage\n\n- `/superego:review` — Review staged changes (falls back to uncommitted if nothing staged)\n- `/superego:review staged` — Review only staged changes\n- `/superego:review pr` — Review PR diff vs base branch\n- `/superego:review <file>` — Review changes in a specific file\n\n## How It Works\n\n1. Run `sg review [target]` to invoke the review\n2. Superego uses the current prompt (code or writing) to evaluate the changes\n3. Returns constructive feedback (advisory, not blocking)\n\n## Examples\n\n```bash\n# Review what you're about to commit\nsg review\n\n# Review your entire PR before requesting review\nsg review pr\n\n# Review changes to a specific file\nsg review src/main.rs\n```\n\n## Notes\n\n- Uses the currently active prompt (`sg prompt show` to check)\n- For writing projects, switch to writing prompt first: `sg prompt switch writing`\n- This is advisory feedback, not a blocking hook\n",
        "plugin/commands/status.md": "# Superego Status\n\nCheck superego status for this project. Report:\n\n1. **Plugin**: Installed (you're running this command)\n2. **Binary**: Check if `sg` binary is available (`command -v sg` and `sg --version`)\n3. **Project**: Check if `.superego/` directory exists in current project\n4. **Hooks**: If both binary and .superego/ exist, hooks are active\n\nProvide a brief status summary. If something is missing, suggest the fix.\n",
        "plugin/hooks/hooks.json": "{\n  \"description\": \"Superego metacognitive evaluation hooks\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/session-start.sh\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/evaluate.sh\"\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/pre-tool-use.sh\"\n          }\n        ]\n      }\n    ],\n    \"PermissionRequest\": [\n      {\n        \"matcher\": \"ExitPlanMode\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/evaluate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n"
      },
      "plugins": [
        {
          "name": "superego",
          "source": "./plugin",
          "description": "Metacognitive advisor that monitors Claude Code and provides feedback",
          "version": "0.9.7",
          "author": {
            "name": "Cloud Atlas AI"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add open-horizon-labs/superego",
            "/plugin install superego@superego"
          ]
        }
      ]
    },
    {
      "name": "open-horizon-labs",
      "version": null,
      "description": "Open Horizon Labs - Complete stack for 10-100x AI leverage",
      "owner_info": {
        "name": "Open Horizon Labs",
        "email": "hello@ohl.dev"
      },
      "keywords": [],
      "repo_full_name": "open-horizon-labs/bottle",
      "repo_url": "https://github.com/open-horizon-labs/bottle",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-01-26T14:01:55Z",
        "created_at": "2026-01-07T01:54:45Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/commands/create.md",
          "type": "blob",
          "size": 994
        },
        {
          "path": ".claude-plugin/commands/eject.md",
          "type": "blob",
          "size": 853
        },
        {
          "path": ".claude-plugin/commands/getting-started.md",
          "type": "blob",
          "size": 2300
        },
        {
          "path": ".claude-plugin/commands/help.md",
          "type": "blob",
          "size": 1058
        },
        {
          "path": ".claude-plugin/commands/init.md",
          "type": "blob",
          "size": 3127
        },
        {
          "path": ".claude-plugin/commands/install.md",
          "type": "blob",
          "size": 751
        },
        {
          "path": ".claude-plugin/commands/integrate.md",
          "type": "blob",
          "size": 1217
        },
        {
          "path": ".claude-plugin/commands/list.md",
          "type": "blob",
          "size": 752
        },
        {
          "path": ".claude-plugin/commands/status.md",
          "type": "blob",
          "size": 767
        },
        {
          "path": ".claude-plugin/commands/switch.md",
          "type": "blob",
          "size": 785
        },
        {
          "path": ".claude-plugin/commands/update.md",
          "type": "blob",
          "size": 684
        },
        {
          "path": ".claude-plugin/commands/workflow.md",
          "type": "blob",
          "size": 4440
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1533
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 313
        },
        {
          "path": ".claude-plugin/plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/ba",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/ba/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/ba/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 346
        },
        {
          "path": ".claude-plugin/plugins/ba/README.md",
          "type": "blob",
          "size": 6374
        },
        {
          "path": ".claude-plugin/plugins/ba/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/ba/commands/init.md",
          "type": "blob",
          "size": 5823
        },
        {
          "path": ".claude-plugin/plugins/ba/commands/new.md",
          "type": "blob",
          "size": 6812
        },
        {
          "path": ".claude-plugin/plugins/ba/commands/quickstart.md",
          "type": "blob",
          "size": 1764
        },
        {
          "path": ".claude-plugin/plugins/ba/commands/status.md",
          "type": "blob",
          "size": 1269
        },
        {
          "path": ".claude-plugin/plugins/miranda",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 443
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/drummer",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/drummer/SKILL.md",
          "type": "blob",
          "size": 9338
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/mouse",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/mouse/SKILL.md",
          "type": "blob",
          "size": 7757
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/notes",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/notes/SKILL.md",
          "type": "blob",
          "size": 6769
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-merge",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-merge/SKILL.md",
          "type": "blob",
          "size": 9132
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-notes",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-notes/SKILL.md",
          "type": "blob",
          "size": 7926
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-plan",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-plan/SKILL.md",
          "type": "blob",
          "size": 7716
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-task",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/miranda/skills/oh-task/SKILL.md",
          "type": "blob",
          "size": 7751
        },
        {
          "path": ".claude-plugin/plugins/oh-mcp",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/oh-mcp/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/oh-mcp/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 391
        },
        {
          "path": ".claude-plugin/plugins/oh-mcp/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/oh-mcp/commands/setup.md",
          "type": "blob",
          "size": 1744
        },
        {
          "path": ".claude-plugin/plugins/superego",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/superego/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/superego/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 331
        },
        {
          "path": ".claude-plugin/plugins/superego/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/superego/agents/code.md",
          "type": "blob",
          "size": 3105
        },
        {
          "path": ".claude-plugin/plugins/superego/agents/learning.md",
          "type": "blob",
          "size": 4677
        },
        {
          "path": ".claude-plugin/plugins/superego/agents/writing.md",
          "type": "blob",
          "size": 2705
        },
        {
          "path": ".claude-plugin/plugins/superego/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/superego/commands/disable.md",
          "type": "blob",
          "size": 276
        },
        {
          "path": ".claude-plugin/plugins/superego/commands/enable.md",
          "type": "blob",
          "size": 608
        },
        {
          "path": ".claude-plugin/plugins/superego/commands/init.md",
          "type": "blob",
          "size": 1715
        },
        {
          "path": ".claude-plugin/plugins/superego/commands/prompt.md",
          "type": "blob",
          "size": 1335
        },
        {
          "path": ".claude-plugin/plugins/superego/commands/remove.md",
          "type": "blob",
          "size": 608
        },
        {
          "path": ".claude-plugin/plugins/superego/commands/review.md",
          "type": "blob",
          "size": 973
        },
        {
          "path": ".claude-plugin/plugins/superego/commands/status.md",
          "type": "blob",
          "size": 426
        },
        {
          "path": ".claude-plugin/plugins/superego/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/superego/hooks/hooks.json",
          "type": "blob",
          "size": 927
        },
        {
          "path": ".claude-plugin/plugins/superego/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/superego/scripts/evaluate.sh",
          "type": "blob",
          "size": 4267
        },
        {
          "path": ".claude-plugin/plugins/superego/scripts/pre-tool-use.sh",
          "type": "blob",
          "size": 6019
        },
        {
          "path": ".claude-plugin/plugins/superego/scripts/session-start.sh",
          "type": "blob",
          "size": 4732
        },
        {
          "path": ".claude-plugin/plugins/wm",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 333
        },
        {
          "path": ".claude-plugin/plugins/wm/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/agents/compress.md",
          "type": "blob",
          "size": 3793
        },
        {
          "path": ".claude-plugin/plugins/wm/agents/distill.md",
          "type": "blob",
          "size": 3700
        },
        {
          "path": ".claude-plugin/plugins/wm/agents/dive-prep.md",
          "type": "blob",
          "size": 8038
        },
        {
          "path": ".claude-plugin/plugins/wm/agents/pause.md",
          "type": "blob",
          "size": 4460
        },
        {
          "path": ".claude-plugin/plugins/wm/agents/review.md",
          "type": "blob",
          "size": 4929
        },
        {
          "path": ".claude-plugin/plugins/wm/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/commands/compress.md",
          "type": "blob",
          "size": 302
        },
        {
          "path": ".claude-plugin/plugins/wm/commands/distill.md",
          "type": "blob",
          "size": 279
        },
        {
          "path": ".claude-plugin/plugins/wm/commands/dive-prep.md",
          "type": "blob",
          "size": 841
        },
        {
          "path": ".claude-plugin/plugins/wm/commands/init.md",
          "type": "blob",
          "size": 537
        },
        {
          "path": ".claude-plugin/plugins/wm/commands/pause.md",
          "type": "blob",
          "size": 559
        },
        {
          "path": ".claude-plugin/plugins/wm/commands/review.md",
          "type": "blob",
          "size": 607
        },
        {
          "path": ".claude-plugin/plugins/wm/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/hooks/hooks.json",
          "type": "blob",
          "size": 278
        },
        {
          "path": ".claude-plugin/plugins/wm/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/scripts/compile.sh",
          "type": "blob",
          "size": 1067
        },
        {
          "path": ".claude-plugin/plugins/wm/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/skills/dive-prep",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/wm/skills/dive-prep/SKILL.md",
          "type": "blob",
          "size": 1162
        }
      ],
      "files": {
        ".claude-plugin/commands/create.md": "# /bottle:create\n\nCreate a new bespoke bottle.\n\n## Usage\n\n```\n/bottle:create <name> [--from <source>]\n```\n\n- `name` - Name for the new bottle (required)\n- `--from <source>` - Copy manifest from an existing bottle\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle create <name> [--from <source>]\n   ```\n\n   Pass through the output to the user.\n\n## What it creates\n\n- New bottle at `~/.bottle/bottles/<name>/`\n- Manifest file with tool versions\n- Can be customized independently of curated bottles\n\n## Examples\n\n```\n/bottle:create mystack\n→ bottle create mystack\n\n/bottle:create mystack --from stable\n→ bottle create mystack --from stable\n```\n",
        ".claude-plugin/commands/eject.md": "# /bottle:eject\n\nEject from bottle management (keep tools, manage manually).\n\n## Usage\n\n```\n/bottle:eject [-y]\n```\n\n- `-y` - Skip confirmation prompt\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle eject [-y]\n   ```\n\n   Pass through the output to the user.\n\n## What ejecting does\n\n- Removes bottle state file (`~/.bottle/state.json`)\n- Keeps all installed tools\n- You manage tool updates manually going forward\n\n## Examples\n\n```\n/bottle:eject\n→ bottle eject\n\n/bottle:eject -y\n→ bottle eject -y\n```\n",
        ".claude-plugin/commands/getting-started.md": "# /bottle:getting-started\n\nWelcome to the Open Horizon Labs toolkit. This guide helps you understand what's available and how to use it effectively.\n\n## The Tools\n\nYou have access to four core tools that work together:\n\n| Tool | Purpose | Key Commands |\n|------|---------|--------------|\n| **ba** | Task tracking | `/ba:status`, `/ba:create`, `/ba:claim` |\n| **wm** | Working memory & session prep | `/dive-prep`, `/wm:compile` |\n| **superego** | Metacognitive review | `/superego:review` |\n| **oh-mcp** | Strategic alignment | Connected via MCP |\n\n## When To Use What\n\n**Starting a session?**\nRun `/dive-prep` first. It gathers context about your project and creates a grounded starting point.\n\n**Working on a task?**\nUse `ba` to track what you're doing:\n- `/ba:status` - See current tasks\n- `/ba:claim <id>` - Start working on a task\n- `/ba:finish <id>` - Mark it done\n\n**Making significant changes?**\nRun `/superego:review` before committing. It catches issues you might miss.\n\n**Need to recall past context?**\nUse `/wm:compile` to surface relevant knowledge from previous sessions.\n\n## Recommended Workflows\n\n### Bug Fix\n```\n1. /dive-prep --intent fix\n2. /ba:claim <task-id>\n3. Investigate and fix\n4. /superego:review\n5. Commit and PR\n6. /ba:finish <task-id>\n```\n\n### New Feature\n```\n1. /dive-prep --intent plan\n2. Design the approach\n3. /ba:create \"Implement feature X\"\n4. /ba:claim <new-task-id>\n5. Implement with tests\n6. /superego:review\n7. Commit and PR\n```\n\n### Exploration\n```\n1. /dive-prep --intent explore\n2. Read code and docs\n3. Document findings\n4. /wm:compile to check related context\n```\n\n## Quick Reference\n\n| Want to... | Run |\n|------------|-----|\n| Start a session | `/dive-prep` |\n| See your tasks | `/ba:status` |\n| Get feedback on work | `/superego:review` |\n| Check tool status | `/bottle:status` |\n| Get help | `/bottle:help` |\n\n## Tips\n\n1. **Always start with `/dive-prep`** - Even quick fixes benefit from context\n2. **Use ba for everything** - Track even small tasks; it helps continuity\n3. **Review before committing** - `/superego:review` catches drift early\n4. **Let wm learn** - It captures tacit knowledge automatically\n\n## Need More?\n\n- `/bottle:status` - Check installed tools\n- `/bottle:help` - See all bottle commands\n- `/ba:quickstart` - Get ba set up quickly\n",
        ".claude-plugin/commands/help.md": "# /bottle:help\n\nShow available bottle commands.\n\n## Usage\n\n```\n/bottle:help\n```\n\n## Response\n\nDisplay the following to the user:\n\n```\nBottle - Open Horizon Labs Tool Stack\n\nSTART HERE:\n  /bottle:getting-started    Learn how to use the tools\n  /bottle:workflow           Get guided workflow for your task\n\nDAILY USE:\n  /dive-prep                 Prepare session context (start here!)\n  /ba:status                 See your tasks\n  /superego:review           Get feedback before committing\n\nSETUP:\n  /bottle:init               Initialize all tools with defaults\n  /bottle:status             Show installed tools and versions\n  /bottle:install [name]     Install a bottle (default: stable)\n\nMANAGEMENT:\n  /bottle:update             Update to latest bottle snapshot\n  /bottle:switch <name>      Switch to a different bottle\n  /bottle:list               List available bottles\n  /bottle:integrate          Add/remove platform integrations\n  /bottle:eject              Stop bottle management (keep tools)\n\nMore info: https://github.com/open-horizon-labs/bottle\n```\n",
        ".claude-plugin/commands/init.md": "# Bottle Init - Unified Open Horizon Labs Setup\n\nInitialize all installed Open Horizon Labs tools with recommended defaults. Handles binary installation automatically.\n\n## Step 1: Check and install binaries\n\nFor each tool (ba, wm, sg), check if binary exists:\n\n**If binary missing:**\n\n1. **Detect available package managers:**\n   - Homebrew: `command -v brew`\n   - Cargo: `command -v cargo` OR `test -f ~/.cargo/bin/cargo`\n\n2. **Offer installation:**\n\n   If **Homebrew** available (preferred for macOS):\n   ```bash\n   brew tap open-horizon-labs/homebrew-tap\n   brew install ba wm sg\n   ```\n\n   If **Cargo** available:\n   ```bash\n   cargo install ba\n   cargo install working-memory  # (published as 'working-memory', provides 'wm' binary)\n   cargo install superego\n   ```\n\n   If **neither available**, offer to install a package manager:\n   - **Install Homebrew** (macOS/Linux):\n     ```bash\n     /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n     ```\n\n   - **Install Rust** (cross-platform):\n     ```bash\n     curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n     ```\n\n3. After installation, verify binaries are available before proceeding\n\n## Step 2: Initialize individual tools\n\nOnce binaries are available, initialize each:\n\n**ba:**\n- If `.ba/` doesn't exist, run: `ba init`\n- This creates `.ba/` directory and initial configuration\n\n**superego:**\n- If `.superego/` doesn't exist, run: `sg init`\n- This creates `.superego/` directory and sets up metacognitive monitoring\n\n**wm:**\n- If `.wm/` doesn't exist, run: `wm init`\n- This creates `.wm/` directory and enables working memory capture\n\n## Step 3: Apply recommended defaults\n\nAfter individual inits complete:\n\n**Set superego to pull mode (recommended):**\n- Check if `.superego/config.yaml` exists\n- Read the current mode setting\n- If mode is `always`, change it to `pull`\n- Command: `sed -i.bak 's/^mode: always/mode: pull/' .superego/config.yaml && rm .superego/config.yaml.bak`\n- Explain: \"Pull mode is less intrusive - superego reviews when you request it or before commits/PRs, rather than at every checkpoint\"\n\n## Step 4: Create/update AGENTS.md\n\nCreate AGENTS.md with guidance for all initialized tools:\n- Add sections for ba, wm, and superego\n- Include \"When to use\" and \"Protocol\" guidance for each\n- If AGENTS.md already exists, preserve user content while updating tool sections\n\n## Step 5: Confirm completion\n\nTell user:\n```bash\n✓ Bottle initialization complete\n\nInitialized:\n  • ba - Task tracking ready\n  • superego - Metacognitive advisor active (pull mode)\n  • wm - Working memory enabled\n\nConfiguration:\n  • superego mode: pull (recommended)\n  • AGENTS.md: Updated with tool guidance\n\nQuick start:\n  ba create \"Your first task\" -t task\n  ba ready\n  ba claim <id> --session $SESSION_ID\n\nTools work together:\n  • ba tracks your work\n  • superego reviews before commits (/superego:review)\n  • wm captures learnings automatically\n```\n\n---\n\nRun each tool's init command in sequence. Apply recommended defaults after inits complete. Focus on orchestration, not reimplementation.\n",
        ".claude-plugin/commands/install.md": "# /bottle:install\n\nInstall a bottle (curated tool stack).\n\n## Usage\n\n```\n/bottle:install [bottle-name]\n```\n\n- `bottle-name` - Name of bottle to install (default: `stable`)\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle install <bottle-name>\n   ```\n\n   Pass through the output to the user.\n\n## Examples\n\n```\n/bottle:install\n→ bottle install stable\n\n/bottle:install edge\n→ bottle install edge\n```\n",
        ".claude-plugin/commands/integrate.md": "# /bottle:integrate\n\nAdd or remove platform integrations (OpenCode, Codex).\n\n## Usage\n\n```\n/bottle:integrate [--list]\n/bottle:integrate <platform>\n/bottle:integrate --remove <platform>\n```\n\n- `--list` - List available and installed integrations\n- `platform` - Platform to integrate: `claude_code`, `opencode`, `codex`\n- `--remove` - Remove the integration instead of adding it\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle integrate [platform] [--list] [--remove]\n   ```\n\n   Pass through the output to the user.\n\n## Platforms\n\n- **opencode** - OpenCode plugin integration\n- **codex** - Codex skill integration\n- **claude_code** - Claude Code plugin (this one!)\n\n## Examples\n\n```\n/bottle:integrate --list\n→ bottle integrate --list\n\n/bottle:integrate opencode\n→ bottle integrate opencode\n\n/bottle:integrate --remove codex\n→ bottle integrate --remove codex\n```\n",
        ".claude-plugin/commands/list.md": "# /bottle:list\n\nList available bottles (curated and bespoke).\n\n## Usage\n\n```\n/bottle:list\n```\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle list\n   ```\n\n   Pass through the output to the user.\n\n## Output\n\nShows:\n- **Curated bottles** (stable, edge) from GitHub\n- **Bespoke bottles** from `~/.bottle/bottles/`\n- Current active bottle (if installed)\n\n## Examples\n\n```\n/bottle:list\n→ bottle list\n```\n",
        ".claude-plugin/commands/status.md": "# /bottle:status\n\nShow current bottle status and installed tools.\n\n## Usage\n\n```\n/bottle:status [--check-updates]\n```\n\n- `--check-updates` - Also check for available updates\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle status [--check-updates]\n   ```\n\n   Pass through the output to the user.\n\n## Examples\n\n```\n/bottle:status\n→ bottle status\n\n/bottle:status --check-updates\n→ bottle status --check-updates\n```\n",
        ".claude-plugin/commands/switch.md": "# /bottle:switch\n\nSwitch to a different bottle.\n\n## Usage\n\n```\n/bottle:switch <bottle-name> [-y]\n```\n\n- `bottle-name` - Name of bottle to switch to (required)\n- `-y` - Skip confirmation prompt\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle switch <bottle-name> [-y]\n   ```\n\n   Pass through the output to the user.\n\n## Examples\n\n```\n/bottle:switch edge\n→ bottle switch edge\n\n/bottle:switch stable -y\n→ bottle switch stable -y\n```\n",
        ".claude-plugin/commands/update.md": "# /bottle:update\n\nUpdate to the latest bottle snapshot.\n\n## Usage\n\n```\n/bottle:update [-y]\n```\n\n- `-y` - Skip confirmation prompt\n\n## Execution\n\n1. **Check if bottle binary exists:**\n   ```bash\n   command -v bottle\n   ```\n\n2. **If bottle not found**, tell the user:\n   ```\n   The bottle CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/bottle\n\n   Or with Cargo:\n     cargo install bottle\n\n   Then run this command again.\n   ```\n\n3. **If bottle exists**, run:\n   ```bash\n   bottle update [-y]\n   ```\n\n   Pass through the output to the user.\n\n## Examples\n\n```\n/bottle:update\n→ bottle update\n\n/bottle:update -y\n→ bottle update -y\n```\n",
        ".claude-plugin/commands/workflow.md": "# /bottle:workflow\n\nGuide users through the recommended workflow for their current task.\n\n## Usage\n\n```\n/bottle:workflow [intent]\n```\n\n**Intents:** `fix`, `plan`, `explore`, `review`, `ship`\n\nIf no intent provided, ask the user what they're trying to do.\n\n## Execution\n\n### Step 1: Determine Intent\n\nIf intent not provided, present options:\n\n```\nWhat are you working on?\n\n[ ] fix     - Fix a bug or issue\n[ ] plan    - Design an approach\n[ ] explore - Understand something\n[ ] review  - Reflect on recent work\n[ ] ship    - Deploy or release\n```\n\n### Step 2: Check Prerequisites\n\nBefore showing workflow, verify tools are ready:\n\n```bash\n# Check if ba is initialized\ntest -d .ba && echo \"ba ready\" || echo \"Run: ba init\"\n\n# Check if wm is initialized\ntest -d .wm && echo \"wm ready\" || echo \"Run: wm init\"\n\n# Check if superego is configured\ntest -d .superego && echo \"superego ready\" || echo \"Run: sg init\"\n```\n\nIf any tool is missing, offer to initialize:\n```\nSome tools aren't set up yet. Run /bottle:init to configure them?\n[Yes] [No, show workflow anyway]\n```\n\n### Step 3: Show Workflow\n\nBased on intent, display the workflow with actionable steps:\n\n---\n\n#### Intent: fix\n\n```\nBug Fix Workflow\n================\n\n1. PREPARE\n   → /dive-prep --intent fix\n   Gathers project context and sets focus\n\n2. CLAIM TASK\n   → /ba:status (see available tasks)\n   → /ba:claim <id> (or create new: /ba:create \"Fix: description\")\n\n3. INVESTIGATE\n   - Reproduce the issue\n   - Find root cause\n   - Check for related problems\n\n4. FIX\n   - Write failing test first (if applicable)\n   - Implement minimal fix\n   - Verify test passes\n\n5. REVIEW\n   → /superego:review\n   Catches issues before commit. Fix any P1-P3 findings.\n\n6. COMMIT\n   - Clear commit message referencing the issue\n   - Push and create PR\n\n7. COMPLETE\n   → /ba:finish <id>\n\nCurrent status: [show ba status if available]\n```\n\n---\n\n#### Intent: plan\n\n```\nPlanning Workflow\n=================\n\n1. PREPARE\n   → /dive-prep --intent plan\n   Gathers context for informed planning\n\n2. UNDERSTAND\n   - What problem are we solving?\n   - What constraints exist?\n   - What's been tried before?\n\n3. OPTIONS\n   - List possible approaches\n   - Identify trade-offs\n   - Note dependencies\n\n4. DECIDE\n   - Choose approach with rationale\n   - Document decision\n   - Break into tasks\n\n5. TRACK\n   → /ba:create \"Task 1: ...\"\n   → /ba:create \"Task 2: ...\"\n   Create tasks for each piece of work\n\nReady to start planning? Run: /dive-prep --intent plan\n```\n\n---\n\n#### Intent: explore\n\n```\nExploration Workflow\n====================\n\n1. PREPARE\n   → /dive-prep --intent explore\n   Sets up exploration context\n\n2. SCOPE\n   - What are you trying to understand?\n   - What's the boundary?\n\n3. INVESTIGATE\n   - Read relevant code\n   - Check documentation\n   - Trace data flow\n\n4. RECALL\n   → /wm:compile\n   Surfaces related context from past sessions\n\n5. DOCUMENT\n   - Note key findings\n   - Identify questions for later\n   - Update project docs if needed\n\nStart exploring: /dive-prep --intent explore\n```\n\n---\n\n#### Intent: review\n\n```\nReview Workflow\n===============\n\n1. PREPARE\n   → /dive-prep --intent review\n   Gathers recent work context\n\n2. GATHER\n   - Recent commits\n   - Open tasks\n   - Uncommitted changes\n\n3. REFLECT\n   → /superego:review\n   Get metacognitive feedback on current state\n\n4. ASSESS\n   - What went well?\n   - What was harder than expected?\n   - What would you do differently?\n\n5. CAPTURE\n   - Document insights\n   - Update relevant docs\n   - Create follow-up tasks if needed\n\nStart review: /dive-prep --intent review\n```\n\n---\n\n#### Intent: ship\n\n```\nShip Workflow\n=============\n\n1. PREPARE\n   → /dive-prep --intent ship\n   Verifies deployment readiness\n\n2. VERIFY\n   - All tests pass?\n   - No uncommitted changes?\n   - Documentation updated?\n\n3. REVIEW\n   → /superego:review\n   Final check before shipping\n\n4. PR\n   - Create PR with full context\n   - Reference related issues\n   - Describe changes clearly\n\n5. DEPLOY\n   - Follow project deployment process\n   - Monitor for issues\n   - Update task status\n\n6. COMPLETE\n   → /ba:finish <id>\n   Mark related tasks as done\n\nReady to ship? Start with: /dive-prep --intent ship\n```\n\n---\n\n### Step 4: Offer Next Action\n\nAfter showing workflow, offer to start:\n\n```\nReady to begin?\n\n[Start with dive-prep] [Show ba status first] [Just show steps]\n```\n\nIf user chooses to start, invoke `/dive-prep --intent <selected-intent>`.\n",
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"open-horizon-labs\",\n  \"owner\": {\n    \"name\": \"Open Horizon Labs\",\n    \"email\": \"hello@ohl.dev\"\n  },\n  \"metadata\": {\n    \"description\": \"Open Horizon Labs - Complete stack for 10-100x AI leverage\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"bottle\",\n      \"source\": \"./.claude-plugin\",\n      \"description\": \"Unified installer and orchestrator for Open Horizon Labs stack\",\n      \"author\": {\n        \"name\": \"Open Horizon Labs\"\n      }\n    },\n    {\n      \"name\": \"ba\",\n      \"source\": \"./.claude-plugin/plugins/ba\",\n      \"description\": \"Task tracking for AI sessions\",\n      \"author\": {\n        \"name\": \"Open Horizon Labs\"\n      }\n    },\n    {\n      \"name\": \"wm\",\n      \"source\": \"./.claude-plugin/plugins/wm\",\n      \"description\": \"Working memory - automatic tacit knowledge extraction\",\n      \"author\": {\n        \"name\": \"Open Horizon Labs\"\n      }\n    },\n    {\n      \"name\": \"superego\",\n      \"source\": \"./.claude-plugin/plugins/superego\",\n      \"description\": \"Metacognitive advisor\",\n      \"author\": {\n        \"name\": \"Open Horizon Labs\"\n      }\n    },\n    {\n      \"name\": \"oh-mcp\",\n      \"source\": \"./.claude-plugin/plugins/oh-mcp\",\n      \"description\": \"Open Horizons MCP server for strategic alignment\",\n      \"author\": {\n        \"name\": \"Open Horizon Labs\"\n      }\n    },\n    {\n      \"name\": \"miranda\",\n      \"source\": \"./.claude-plugin/plugins/miranda\",\n      \"description\": \"Telegram bot for remote orchestration\",\n      \"author\": {\n        \"name\": \"Open Horizon Labs\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"bottle\",\n  \"version\": \"0.1.9\",\n  \"description\": \"Open Horizon Labs unified installer and orchestrator\",\n  \"author\": {\n    \"name\": \"Open Horizon Labs\",\n    \"email\": \"hello@ohl.dev\",\n    \"url\": \"https://github.com/open-horizon-labs\"\n  },\n  \"repository\": \"https://github.com/open-horizon-labs/bottle\"\n}\n",
        ".claude-plugin/plugins/ba/.claude-plugin/plugin.json": "{\n  \"name\": \"ba\",\n  \"version\": \"0.2.1\",\n  \"description\": \"Simple task tracking for LLM sessions - ownership-based workflow for multi-agent coordination\",\n  \"author\": {\n    \"name\": \"Open Horizon Labs\",\n    \"email\": \"hello@ohl.dev\",\n    \"url\": \"https://github.com/open-horizon-labs\"\n  },\n  \"repository\": \"https://github.com/open-horizon-labs/ba\"\n}\n",
        ".claude-plugin/plugins/ba/README.md": "# ba Claude Code Plugin\n\nClaude Code plugin for ba task-tracking integration.\n\n## What This Plugin Provides\n\n### Slash Commands\n\n- `/ba init` - Initialize ba for a project, install binary if needed, install Codex skill, update AGENTS.md\n- `/ba status` - Show current ba status, issue counts, your claimed issues\n- `/ba quickstart` - Display quick reference guide\n\n### Codex Skill\n\nThe `$ba` skill for Codex-enabled sessions:\n- `$ba ready` - See available work\n- `$ba claim <id>` - Take ownership\n- `$ba mine` - Your claimed issues\n- `$ba finish <id>` - Complete work\n- `$ba show <id>` - Check details\n\nSee [codex-skill/SKILL.md](../codex-skill/SKILL.md) for full skill documentation.\n\n**Note:** The `$ba` skill requires `$SESSION_ID` environment variable. Claude Code typically provides this automatically. See SKILL.md for details on SESSION_ID requirements and error handling.\n\n### Project Integration\n\nThe init command automatically:\n1. Installs the ba binary (via Homebrew or Cargo)\n2. Runs `ba init` to create `.ba/` directory\n3. Downloads and installs the `$ba` Codex skill files to `~/.codex/skills/ba/`\n4. Updates `AGENTS.md` with ba workflow guidance\n\n## Installation\n\n### From Claude Code\n\n```bash\nclaude plugin install ba\n```\n\n### From Source (Development)\n\n```bash\n# Clone and add as local marketplace\ngit clone https://github.com/cloud-atlas-ai/ba.git\ncd ba\nclaude plugin marketplace add $PWD\n\n# Install plugin (includes Codex skill)\nclaude plugin install ba@ba\n```\n\n## Usage\n\n### Initializing a Project\n\nIn any project directory:\n\n```bash\n/ba init\n```\n\nThis will:\n- Check if ba is already initialized\n- Install ba binary if not available (offers Homebrew or Cargo)\n- Run `ba init` to create `.ba/` structure\n- Install `$ba` Codex skill to `~/.codex/skills/ba/`\n- Update AGENTS.md with ba guidance\n\n### Checking Status\n\n```bash\n/ba status\n```\n\nShows:\n- Project configuration\n- Issue counts by status\n- Ready queue summary\n- Your claimed issues (if `$SESSION_ID` available)\n\n### Quick Reference\n\n```bash\n/ba quickstart\n```\n\nDisplays a concise command reference card.\n\n## Project Structure\n\n```text\nplugin/\n├── .claude-plugin/\n│   └── plugin.json       # Plugin manifest\n├── commands/\n│   ├── init.md           # /ba init command\n│   ├── status.md         # /ba status command\n│   └── quickstart.md     # /ba quickstart command\n├── scripts/              # Hook scripts (future)\n└── README.md             # This file\n```\n\n## How It Works\n\n### Slash Commands\n\nSlash commands are markdown files in `commands/` that Claude Code interprets as instructions. When you run `/ba init`, Claude reads `commands/init.md` and executes the steps.\n\nEach command file:\n- Describes the goal\n- Provides step-by-step instructions\n- Includes shell commands to run\n- Handles edge cases and errors\n\n### Codex Skills\n\nThe `$ba` skill is defined in `../codex-skill/SKILL.md`. Codex skills:\n- Provide structured prompts\n- Include command examples\n- Document workflows and patterns\n- Are available in Codex-enabled sessions\n\nClaude invokes the appropriate ba commands with proper session management.\n\n## Development\n\n### Testing Commands\n\nTest a command locally:\n\n```bash\n# Read the command file to understand what it does\ncat commands/init.md\n\n# Run the steps manually or via Claude Code\nclaude code\n> /ba init\n```\n\n### Adding New Commands\n\n1. Create a new `.md` file in `commands/`\n2. Follow the pattern from existing commands\n3. Be concise and actionable\n4. Test thoroughly\n\n### Updating the Plugin\n\nAfter making changes:\n\n```bash\n# Update version in plugin.json\nvim .claude-plugin/plugin.json\n\n# Reinstall for testing\nclaude plugin uninstall ba@ba\nclaude plugin install ba@ba\n```\n\n## Integration with ba Binary\n\nThis plugin wraps the `ba` binary, which must be installed separately. The plugin helps with installation but doesn't include the binary itself.\n\nBinary installation options:\n- **Homebrew**: `brew install cloud-atlas-ai/ba/ba`\n- **Cargo**: `cargo install ba`\n- **From source**: `cargo install --path /path/to/ba`\n\nSee the main [ba README](../README.md) for binary documentation.\n\n## Relationship to Codex Skill\n\n```text\nba/\n├── plugin/                # This directory\n│   └── commands/          # Slash commands (/ba init, /ba status)\n└── codex-skill/           # Separate directory\n    └── SKILL.md           # Codex skill ($ba ready, $ba claim)\n```\n\n**Plugin**: Setup, configuration, project initialization\n**Skill**: Day-to-day task tracking during coding sessions\n\nBoth work together to integrate ba into Claude Code workflows.\n\n## Philosophy\n\nba provides **ownership-based task tracking** for multi-agent workflows:\n\n- **Explicit ownership**: Every in-progress issue has a known owner\n- **State transitions**: claim → work → finish/release\n- **Multi-agent safe**: Session IDs prevent conflicts\n- **Dependency-aware**: Only show unblocked work\n\nThis plugin makes ba's workflow first-class in Claude Code, with:\n- Easy setup via `/ba init`\n- Status visibility via `/ba status`\n- Direct command access via `$ba` skill\n\n## Examples\n\n### First-Time Setup\n\n```text\nUser: Let's use ba for task tracking\nClaude: I'll initialize ba for this project\n  [Runs: /ba init]\n\n  Checking for ba binary...\n  Not found. I can install via Homebrew or Cargo.\n\n  [Shows installation options]\n\nUser: Use Homebrew\nClaude: [Runs: brew install cloud-atlas-ai/ba/ba]\n  [Runs: ba init]\n  [Installs $ba Codex skill to ~/.codex/skills/ba/]\n  [Updates AGENTS.md]\n\n  ✓ ba initialized and ready\n\n  Quick start:\n    ba create \"Your first task\" -t task\n    ba list\n\n  Use $ba commands in Codex mode:\n    $ba ready, $ba claim <id>, $ba finish <id>\n```\n\n### During a Session\n\n```text\nClaude: Let me check what tasks are available\n  [Uses: $ba ready]\n\n  3 issues ready:\n  - ab-x7k2 (P1): Fix auth bug\n  - ab-y8m3 (P2): Add dashboard\n  - ab-z9n4 (P3): Update docs\n\nUser: Let's fix the auth bug\nClaude: [Uses: $ba claim ab-x7k2]\n  [Uses: $ba show ab-x7k2]\n\n  Claimed ab-x7k2. Details:\n  - Created 2 days ago\n  - Priority: 1 (High)\n  - Description: Token validation fails for special chars\n\n  Let me investigate...\n```\n\n## See Also\n\n- [ba README](../README.md) - Main ba documentation\n- [Codex Skill](../codex-skill/README.md) - Skill documentation\n- [Claude Code Plugins](https://docs.claude.ai/plugins) - Plugin system\n",
        ".claude-plugin/plugins/ba/commands/init.md": "# Initialize ba\n\nInitialize ba task tracking for this project.\n\n## Step 1: Check current state\n- Check if `.ba/` already exists - if so, tell user it's already initialized and show status\n- Check if `ba` binary is available (`command -v ba`) - if yes, skip to Step 3\n\n## Step 2: Install ba binary\n\n**Detect available package managers:**\n- Homebrew: `command -v brew`\n- Cargo: `command -v cargo` OR `test -f ~/.cargo/bin/cargo`\n\n**Offer installation based on what's available:**\n\nIf **Homebrew** available (preferred for macOS):\n```bash\nbrew install cloud-atlas-ai/ba/ba\n```\n\nIf **Cargo** available:\n```bash\ncargo install ba\n# or if cargo not in PATH:\n~/.cargo/bin/cargo install ba\n```\n\nIf **neither available**, offer to install a package manager:\n- **Install Homebrew** (recommended for macOS):\n  ```bash\n  /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n  ```\n  Then: `brew install cloud-atlas-ai/ba/ba`\n\n- **Install Rust** (cross-platform):\n  ```bash\n  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n  ```\n  Then restart shell and: `cargo install ba`\n\n**For local development** (if user specifies a path):\n```bash\ncargo install --path /path/to/ba\n# or: ~/.cargo/bin/cargo install --path /path/to/ba\n```\n\n## Step 3: Initialize project\nAfter `ba` binary is available, run:\n```bash\nba init\n```\n\nThis creates `.ba/` directory with:\n- `config.json` - Project config (version, ID prefix)\n- `issues.jsonl` - Issue storage\n\n## Step 4: Update AGENTS.md\n\nCheck if `AGENTS.md` exists in the project root. If not, create it with:\n\n```markdown\n# AGENTS.md\n\nThis file provides guidance to Claude Code when working with code in this repository.\n\n## Project Overview\n\n[Add project-specific overview here]\n\n## ba Task Tracking\n\nThis project uses ba for task tracking. You have the `$ba` skill available in Codex mode.\n\n**Core workflow:**\n1. Check ready queue: `ba ready` - shows open, unblocked issues\n2. Claim an issue: `ba claim <id> --session $SESSION_ID`\n3. Work on the issue\n4. Complete: `ba finish <id>`\n5. Or release: `ba release <id>` if not done\n\n**Quick reference:**\n- `ba list` - Show all open issues (excludes closed)\n- `ba list --all` - Include closed issues\n- `ba show <id>` - Show issue details\n- `ba mine --session $SESSION_ID` - Show your claimed issues\n- `ba create \"title\" -t task -p 1` - Create new issue\n- `ba comment <id> \"message\"` - Add comment\n\n**Ownership-based state machine:**\n- `open` → claim → `in_progress` (you own it)\n- `in_progress` → finish → `closed`\n- `in_progress` → release → `open` (back to pool)\n- Claiming a closed issue reopens it automatically\n\n**Issue types:** task, epic, refactor, spike\n**Priorities:** 0 (critical) to 4 (backlog), default 2\n\nSee README.md for full details.\n```\n\nIf `AGENTS.md` already exists, append the ba section:\n\n```bash\n# Quoted heredoc prevents $SESSION_ID expansion in AGENTS.md\ncat >> AGENTS.md << 'EOF'\n\n## ba Task Tracking\n\nThis project uses ba for task tracking. You have the `$ba` skill available in Codex mode.\n\n**Core workflow:**\n1. Check ready queue: `ba ready` - shows open, unblocked issues\n2. Claim an issue: `ba claim <id> --session $SESSION_ID`\n3. Work on the issue\n4. Complete: `ba finish <id>`\n5. Or release: `ba release <id>` if not done\n\n**Quick reference:**\n- `ba list` - Show all open issues (excludes closed)\n- `ba list --all` - Include closed issues\n- `ba show <id>` - Show issue details\n- `ba mine --session $SESSION_ID` - Show your claimed issues\n- `ba create \"title\" -t task -p 1` - Create new issue\n- `ba comment <id> \"message\"` - Add comment\n\n**Ownership-based state machine:**\n- `open` → claim → `in_progress` (you own it)\n- `in_progress` → finish → `closed`\n- `in_progress` → release → `open` (back to pool)\n- Claiming a closed issue reopens it automatically\n\n**Issue types:** task, epic, refactor, spike\n**Priorities:** 0 (critical) to 4 (backlog), default 2\n\nSee README.md for full details.\nEOF\n```\n\n## Step 5: Install Codex skill\n\nInstall the `$ba` Codex skill files to enable ba commands in Claude Code sessions:\n\n```bash\n# Create skill directory\nSKILL_DIR=\"$HOME/.codex/skills/ba\"\nmkdir -p \"$SKILL_DIR\"\n\necho \"Installing ba Codex skill...\"\nif curl -fsSL -o \"$SKILL_DIR/SKILL.md\" \\\n  \"https://raw.githubusercontent.com/cloud-atlas-ai/ba/master/codex-skill/SKILL.md\" && \\\n   curl -fsSL -o \"$SKILL_DIR/AGENTS.md.snippet\" \\\n  \"https://raw.githubusercontent.com/cloud-atlas-ai/ba/master/codex-skill/AGENTS.md.snippet\"; then\n  echo \"✓ Codex skill installed to $SKILL_DIR\"\n  echo \"\"\n  echo \"The \\$ba skill is now available for:\"\n  echo \"  \\$ba ready    - Show available issues\"\n  echo \"  \\$ba claim    - Claim an issue\"\n  echo \"  \\$ba mine     - Show your claimed issues\"\n  echo \"  \\$ba finish   - Complete an issue\"\nelse\n  echo \"⚠️  Failed to download Codex skill files\"\n  echo \"You can manually install from: https://github.com/cloud-atlas-ai/ba/tree/master/codex-skill\"\nfi\n```\n\n## Step 6: Verify SESSION_ID\n\nCheck if SESSION_ID is available for ownership operations:\n\n```bash\nif [ -z \"$SESSION_ID\" ]; then\n  echo \"\"\n  echo \"⚠️  SESSION_ID not set\"\n  echo \"Claude Code provides this automatically in active sessions.\"\n  echo \"To set manually: export SESSION_ID=\\$(uuidgen | tr '[:upper:]' '[:lower:]')\"\nelse\n  echo \"\"\n  echo \"✓ SESSION_ID is set: $SESSION_ID\"\nfi\n```\n\n## Step 7: Confirm\n\nTell user:\n```text\n✓ ba initialized and ready\n\nCreated .ba/ directory with project config\nInstalled $ba Codex skill to ~/.codex/skills/ba/\nAdded ba guidance to AGENTS.md\n\nQuick start:\n  ba create \"Your first task\" -t task\n  ba list\n  ba claim <id> --session $SESSION_ID\n\nUse $ba commands in Codex mode:\n  $ba ready, $ba claim <id>, $ba finish <id>\n```\n\n---\nBe concise. Detect what's available, offer appropriate options, guide user through setup.\n",
        ".claude-plugin/plugins/ba/commands/new.md": "# ba New\n\nGuided task creation with proper scoping and specification.\n\n## Goal\n\nHelp users create well-specified, actionable ba tasks. Guide them from a rough idea to one or more properly scoped tasks.\n\n## Step 1: Get initial input\n\nAsk the user what they want to accomplish:\n\n```text\nWhat do you want to accomplish? Describe the task or goal in a few words.\n```\n\nIf user provides something vague like \"fix the thing\" or \"improve performance\", probe for specifics:\n- What specifically is broken or needs improvement?\n- What behavior should change?\n- What does success look like?\n\n## Step 2: Check for duplicates\n\nBefore creating, search existing tasks for similar work:\n\n```bash\nba list --all --json | jq -r '.[] | \"\\(.id): \\(.title) (\\(.status))\"'\n```\n\nLook for tasks with:\n- Similar keywords in the title\n- Related subject matter\n- Same general area of the codebase\n\n**If a potential duplicate is found:**\n\n```text\nI found an existing task that might be related:\n  <id>: <title> (<status>)\n\nIs this the same work, or something different?\n```\n\nIf same work:\n- If closed: Ask if user wants to reopen it\n- If open/in_progress: Point them to it, no new task needed\n\nIf different work: Proceed with creation. Consider adding a comment mentioning the related task ID for context.\n\n## Step 3: Assess scope\n\nEvaluate if the task is properly scoped. A well-scoped task:\n- Can be completed in a single focused session\n- Has clear acceptance criteria\n- Doesn't require breaking into subtasks\n\n**Signs of oversized scope:**\n- Multiple unrelated changes\n- \"And also...\" in the description\n- Would touch many different areas of code\n- Contains multiple acceptance criteria that could stand alone\n\n**If scope is too large:**\n\nSuggest breaking down into smaller tasks:\n\n```text\nThis sounds like it could be multiple tasks. I see:\n1. [First discrete piece of work]\n2. [Second discrete piece of work]\n3. [Third discrete piece of work]\n\nShould I create these as separate tasks? They can be linked as dependencies if needed.\n```\n\n## Step 4: Refine the title\n\nHelp craft an actionable title. Good titles:\n- Start with a verb (Add, Fix, Update, Remove, Implement, Refactor)\n- Are specific enough to understand without context\n- Fit in ~10 words\n\n**Transform vague titles:**\n- \"auth stuff\" → \"Add JWT token refresh on expiration\"\n- \"fix bug\" → \"Fix login redirect loop when session expires\"\n- \"improve perf\" → \"Add caching to database queries in search endpoint\"\n\nPropose a refined title and confirm:\n\n```text\nHow about: \"[refined title]\"\n\nDoes this capture what you want to do?\n```\n\n## Step 5: Determine type\n\nBased on the work described, recommend a type:\n\n- **task** - Building something new or changing behavior\n- **refactor** - Improving code without changing behavior\n- **spike** - Research or investigation, time-boxed exploration\n- **epic** - Container for related tasks (only if creating multiple)\n\n```text\nThis sounds like a [type]. [Brief explanation of why]\n```\n\n## Step 6: Add context (optional)\n\nFor non-trivial tasks, ask if there's additional context:\n\n```text\nAny additional context to capture? For example:\n- Acceptance criteria (what does \"done\" look like?)\n- Technical constraints or approaches to consider\n- Related files or areas of code\n```\n\nIf user provides context, it becomes a comment on the created task.\n\n## Step 7: Set priority\n\nOffer priority options:\n\n```text\nPriority?\n- 0: Critical - drop everything\n- 1: High - do soon\n- 2: Medium - normal queue (default)\n- 3: Low - when you get to it\n- 4: Backlog - someday/maybe\n```\n\nDefault to P2 if user doesn't specify.\n\n## Step 8: Handle dependencies (if multiple tasks)\n\nIf creating multiple tasks, ask about dependencies:\n\n```text\nShould any of these tasks block others?\nFor example: Task 2 depends on Task 1 being done first.\n```\n\n## Step 9: Create task(s)\n\nExecute the creation:\n\n```bash\n# Single task\nba create \"Title here\" -t task -p 2\n\n# With comment for context\nba create \"Title here\" -t task -p 2\nba comment <id> \"Additional context here\"\n\n# Multiple tasks with dependencies\nba create \"First task\" -t task -p 2\nba create \"Second task (depends on first)\" -t task -p 2\nba block <second-id> <first-id>\n```\n\n## Step 10: Confirm\n\nShow what was created:\n\n```text\nCreated:\n  <id>: Title (type, priority)\n\nReady to claim with:\n  ba claim <id> --session $SESSION\n```\n\nOr for multiple tasks:\n\n```text\nCreated 3 tasks:\n  <id1>: First task (task, P2) - ready\n  <id2>: Second task (task, P2) - blocked by <id1>\n  <id3>: Third task (task, P2) - blocked by <id2>\n\nTask tree:\n  <id1> → <id2> → <id3>\n\nStart with:\n  ba claim <id1> --session $SESSION\n```\n\n## Quick mode\n\nIf user provides a clear, well-specified task upfront, skip the refinement:\n\n```text\nUser: Create a task to add input validation to the signup form that rejects emails without @ symbol\n```\n\nThis is already:\n- Actionable (add validation)\n- Specific (signup form, email field, @ symbol check)\n- Properly scoped (single focused change)\n\nJust confirm type and priority, then create.\n\n## Examples\n\n### Example 1: Vague input\n\n```text\nUser: I need to fix auth\nClaude: What specifically is broken with authentication?\n        - Login not working?\n        - Token expiration issues?\n        - Permission checks failing?\n\nUser: Oh, the JWT tokens expire and users get logged out\n\nClaude: Got it. How about: \"Add JWT token refresh before expiration\"\n        This is a task (adding new behavior). Priority?\n\nUser: High, it's annoying users\n\nClaude: Created:\n  ab-x7k2: Add JWT token refresh before expiration (task, P1)\n\n  Ready to claim: ba claim ab-x7k2 --session $SESSION\n```\n\n### Example 2: Oversized scope\n\n```text\nUser: I want to add a dashboard\n\nClaude: A dashboard could be quite broad. What should it show?\n\nUser: User stats, recent activity, and admin controls\n\nClaude: This sounds like 3 separate pieces:\n  1. \"Add user statistics panel to dashboard\"\n  2. \"Add recent activity feed to dashboard\"\n  3. \"Add admin control panel to dashboard\"\n\nShould I create these as separate tasks? They can work independently.\n\nUser: Yes, and admin controls need the stats first\n\nClaude: Created 3 tasks:\n  ab-y1a2: Add user statistics panel to dashboard (task, P2) - ready\n  ab-z3b4: Add recent activity feed to dashboard (task, P2) - ready\n  ab-c5d6: Add admin control panel to dashboard (task, P2) - blocked by ab-y1a2\n\nStart with either ab-y1a2 or ab-z3b4 (both ready).\n```\n\n### Example 3: Quick create\n\n```text\nUser: Task to update the README with new installation instructions for ARM64\n\nClaude: Clear and specific. Creating:\n  \"Update README with ARM64 installation instructions\" (task, P2)\n\n  ab-m7n8 created. Ready to claim.\n```\n\n---\n\nKeep the conversation natural. Don't be overly formal or robotic. The goal is helping users think through their tasks, not running them through a rigid form.\n",
        ".claude-plugin/plugins/ba/commands/quickstart.md": "# ba Quick Start\n\nShow a quick start guide for using ba in this session.\n\n## Display Guide\n\nShow this concise reference:\n\n```text\nba - Task Tracking Quick Start\n==============================\n\nCore Workflow:\n  ba ready                            # See available work\n  ba claim <id> --session $SESSION_ID # Take ownership\n  ba show <id>                        # Check details\n  ba finish <id>                      # Complete work\n  ba release <id>                     # Abandon work\n\nBrowse:\n  ba list                             # All open issues\n  ba list --all                       # Include closed\n  ba mine --session $SESSION_ID       # Your claimed issues\n\nCreate:\n  ba create \"title\" -t task -p 1      # New issue\n  ba comment <id> \"msg\" --author $SESSION_ID\n\nDependencies:\n  ba block <id> <blocker-id>          # Mark as blocked\n  ba tree <id>                        # Visualize deps\n\nOwnership State Machine:\n  open → claim → in_progress → finish → closed\n                      ↓\n                  release\n                      ↓\n                    open\n\nIssue Types:\n  task      - General work (default)\n  epic      - Grouping container\n  refactor  - Improve existing code\n  spike     - Research/investigation\n\nPriorities:\n  0 - Critical    1 - High    2 - Medium (default)\n  3 - Low         4 - Backlog\n\nSession ID:\n  Use --session $SESSION_ID for claim/mine/comment\n  This identifies you in multi-agent workflows\n\nStorage:\n  .ba/issues.jsonl  - One issue per line (git-friendly)\n  .ba/config.json   - Project configuration\n\nMore info: ba --help or README.md\n```\n\n## Check if initialized\n\nIf `.ba/` doesn't exist, suggest:\n```text\nba not initialized yet. Run:\n  /ba init\n```\n\n---\nKeep it concise. This is a reference card, not a tutorial.\n",
        ".claude-plugin/plugins/ba/commands/status.md": "# ba Status\n\nShow current ba status for this project.\n\n## Check if initialized\n\nFirst, check if ba is initialized:\n```bash\nif [ -d .ba ]; then\n  echo \"✓ ba is initialized\"\nelse\n  echo \"✗ ba not initialized - run /ba init\"\n  exit 0\nfi\n```\n\n## Show configuration\n\n```bash\ncat .ba/config.json\n```\n\nDisplays:\n- Version\n- ID prefix (derived from project path)\n\n## Show issue counts\n\n```bash\necho \"Issue counts:\"\nba list --json | jq '. | length' | xargs -I {} echo \"  Open: {}\"\nba list --all --json | jq '[.[] | select(.status == \"closed\")] | length' | xargs -I {} echo \"  Closed: {}\"\nba list --all --json | jq '[.[] | select(.status == \"in_progress\")] | length' | xargs -I {} echo \"  In Progress: {}\"\n```\n\n## Show ready queue\n\n```bash\necho \"\"\necho \"Ready to work:\"\nba ready\n```\n\n## Check your claimed issues\n\nIf `$SESSION_ID` is available:\n```bash\necho \"\"\necho \"Your claimed issues:\"\nba mine --session \"$SESSION_ID\"\n```\n\n## Summary format\n\nPresent information concisely:\n\n```text\n✓ ba initialized\n\nProject: ab (prefix)\nVersion: 2\n\nIssues:\n  Open: 12\n  In Progress: 3\n  Closed: 45\n\nReady to work: 8 issues\n\nYour claimed: 2 issues\n  ab-x7k2 (P1): Fix auth bug\n  ab-y8m3 (P2): Add dashboard\n```\n\n---\nBe concise. Show what matters. If not initialized, suggest `/ba init`.\n",
        ".claude-plugin/plugins/miranda/.claude-plugin/plugin.json": "{\n  \"name\": \"miranda\",\n  \"version\": \"0.5.4\",\n  \"description\": \"Mouse, Drummer, Notes, oh-task, oh-merge, oh-notes, and oh-plan skills for autonomous task execution, batch PR merging, PR feedback handling, GitHub issue workflows, and task planning\",\n  \"author\": {\n    \"name\": \"Open Horizon Labs\",\n    \"email\": \"hi@ohl.dev\",\n    \"url\": \"https://github.com/open-horizon-labs\"\n  },\n  \"repository\": \"https://github.com/open-horizon-labs/miranda\"\n}\n",
        ".claude-plugin/plugins/miranda/skills/drummer/SKILL.md": "---\nname: drummer\ndescription: Review and merge open PRs for claimed ba tasks as a cohesive batch\n---\n\n# Drummer\n\nThe collective that processes in rhythm. Holistically review pending PRs, then squash-merge them as a cohesive batch.\n\n## Invocation\n\n`/drummer`\n\n## Flow\n\n1. Read dive context (if available) for project background:\n   ```bash\n   cat .wm/dive_context.md 2>/dev/null || echo \"No dive context\"\n   ```\n   This provides architecture decisions, conventions, and session intent.\n\n2. Find all PRs with `drummer-merge` label:\n   ```bash\n   gh pr list --label drummer-merge --json number,title,headRefName,baseRefName,mergeable,additions,deletions\n   ```\n   **Only PRs with the `drummer-merge` label are eligible for merge.**\n   This finds ALL labeled PRs, not just those for claimed tasks.\n\n3. **Build dependency graph and identify stacks:**\n   - Create adjacency list: `baseRefName → [PRs targeting it]`\n   - Find root PRs: those where `baseRefName = main` (or master)\n   - Identify stacks: chains where child PRs target parent PR branches\n   - **Detect cycles**: If a branch eventually targets itself, report error and skip\n   - Example graph:\n     ```\n     main ← PR #42 (ba/abc-123) ← PR #43 (ba/abc-456)\n     main ← PR #44 (ba/xyz-789)  [separate stack]\n     ```\n\n4. **Select stack to process:**\n   - If multiple independent stacks exist, pick first by lowest root PR number (FIFO by age)\n   - If multiple PRs target the same base branch, order by PR number (lowest first)\n   - Report other stacks as \"queued for next run\"\n   - Process only one stack per invocation to keep merges atomic\n   - **Orphaned children**: If a child PR targets a branch that doesn't exist (parent merged externally), update its base to main and treat as a root\n\n5. **Batch review** - evaluate all PRs in the selected stack together:\n   - Collect combined diff of all PRs against main\n   - Run `sg review` on the combined changes\n   - Evaluate:\n     - Do changes conflict logically? (same code modified differently)\n     - Is there duplicate work? (two PRs solving same problem)\n     - Do changes compose well? (feature A + feature B = coherent whole)\n     - Any cross-cutting concerns? (shared dependencies, API changes)\n   - If concerns found:\n     - Report issues\n     - Ask human whether to proceed or address first\n\n6. **Merge stack in dependency order** (root first, then children):\n\n   For each PR in the stack, starting from the root:\n\n   a. **Verify CI is passing:**\n      ```bash\n      gh pr checks <pr-number> --fail-on-error\n      ```\n      If CI is failing, stop and report error.\n\n   b. **Rebase onto its target branch:**\n      ```bash\n      git fetch origin\n      gh pr checkout <pr-number>\n      git rebase origin/<base-branch>  # main for root, parent branch for children\n      ```\n\n   c. If .ba/ conflict, resolve mechanically (each task = one line)\n\n   d. Push rebased branch:\n      ```bash\n      git push --force-with-lease\n      ```\n\n   e. Squash merge:\n      ```bash\n      gh pr merge <pr-number> --squash\n      ```\n\n   f. **For child PRs in the stack** (after parent merged):\n      - Update base branch to main:\n        ```bash\n        gh pr edit <child-pr-number> --base main\n        ```\n      - Rebase child onto main:\n        ```bash\n        gh pr checkout <child-pr-number>\n        git rebase origin/main\n        git push --force-with-lease\n        ```\n      - Force-push triggers new CI run; batch review + parent merge provides confidence\n      - Now child PR targets main and is rebased, continue to merge it (step a-e)\n\n   g. **Verify task closure** - After each merge:\n      ```bash\n      git pull origin main\n      # Extract task ID from branch name: ba/abc-123 → abc-123\n      # Note: Assumes branch follows ba/<task-id> convention from mouse skill\n      task_id=\"${headRefName#ba/}\"\n      ba show $task_id  # Check status\n      # If not closed, fix it:\n      ba finish $task_id\n      # If any fixes were needed:\n      git add .ba/ && git commit -m \"fix: close task ${task_id} after merge\" && git push origin main\n      ```\n      Squash merge can lose .ba/ changes during conflict resolution.\n\n   h. **On merge failure** - If any PR in the stack fails to merge:\n      - Stop processing the stack\n      - Report which PRs were merged successfully and which failed\n      - Signal error: already-merged PRs stay merged, failed PR remains open\n      - Next drummer run will see the failed PR as a new root (its parent is now in main)\n\n7. **Signal completion (MANDATORY)** - This is the LAST thing you do:\n   ```bash\n   # On success:\n   curl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n     -H \"Content-Type: application/json\" \\\n     -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\"}\"\n\n   # On error:\n   curl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n     -H \"Content-Type: application/json\" \\\n     -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"error\\\", \\\"error\\\": \\\"<reason>\\\"}\"\n   ```\n   **If you don't signal, Miranda won't know you're done and the session becomes orphaned.**\n\n## Stacked PRs\n\nWhen PRs target other PR branches (not main), drummer detects the stack and processes it:\n\n**Detection:**\n```bash\ngh pr list --label drummer-merge --json number,title,headRefName,baseRefName,mergeable\n```\n- PRs with `baseRefName = main` are roots\n- PRs with `baseRefName = ba/<task-id>` are children targeting that parent\n\n**Graph building:**\n```\nadjacency[baseRefName] = [list of PRs targeting it]\n\nExample:\n  adjacency[\"main\"] = [PR #42, PR #44]\n  adjacency[\"ba/abc-123\"] = [PR #43]\n\nStack 1: main ← #42 (ba/abc-123) ← #43 (ba/abc-456)\nStack 2: main ← #44 (ba/xyz-789)\n```\n\n**Merge sequence** (for Stack 1):\n1. Merge #42 to main\n2. Update #43: `gh pr edit 43 --base main`\n3. Rebase #43 onto main: `git rebase origin/main && git push --force-with-lease`\n4. Merge #43 to main\n\n**After processing:**\n```\nBefore:  PR #43 → ba/abc-123 → main\n         PR #42 → main\n         PR #44 → main (separate stack)\n\nAfter:   PR #42 merged to main\n         PR #43 rebased onto main, merged to main\n         PR #44 remains for next drummer run\n```\n\n## Batch Review Criteria\n\nThe holistic review checks what individual PR reviews can't:\n\n- **Logical conflicts**: PR A assumes X, PR B assumes not-X\n- **Duplication**: Both PRs add similar functionality\n- **Integration issues**: Combined changes break something neither breaks alone\n- **Ordering dependencies**: PR B depends on PR A being merged first (auto-detected for stacked PRs)\n- **Scope creep**: Batch as a whole does more than originally intended\n\n## Conflict Resolution\n\n`.ba/issues.jsonl` is line-per-task:\n- Each line is independent\n- Resolution: union of all lines (dedupe by task ID)\n- Never lose a task closure\n\n## Prerequisites\n\n- PRs must have the `drummer-merge` label (human approval gate)\n- PRs must have CI passing\n- No code conflicts (only .ba/ conflicts handled automatically)\n- Batch review must pass (or human override)\n\n**Note:** The `drummer-merge` label must be created in the repo. This is opt-in per repo.\n\n## Exit Conditions\n\n- **Success**: Selected stack fully merged → signal `status: \"success\"`\n- **Partial success**: Some PRs in stack merged, then failure → signal `status: \"error\"` with details\n- **Needs attention**: Batch review raised concerns - waiting for human decision (no signal - awaiting input)\n- **Error**: Unrecoverable failure (code conflicts, CI failing, cycle detected) → signal `status: \"error\"` with message\n- **No work**: No PRs with `drummer-merge` label found → signal `status: \"success\"` (nothing to do)\n\n## Example\n\n### Basic (no stacks)\n\n```\n$ /drummer\n\nFinding PRs with drummer-merge label...\nFound 2 PRs:\n  PR #42 \"Fix validation bug\" → main (CI ✓)\n  PR #44 \"Refactor validator\" → main (CI ✓)\n\nBuilding dependency graph...\n  Stack 1: main ← #42\n  Stack 2: main ← #44\n  2 independent stacks, processing Stack 1\n\nRunning batch review on Stack 1 (1 PR)...\nBatch review complete: ✓ No issues\n\nProcessing PR #42 (Fix validation bug)...\n  Verifying CI... ✓\n  Rebasing onto main... clean\n  Squash merging... ✓\n  Verifying task closure... ✓\n\nMerge complete.\n  Merged: 1 PR (#42)\n  Remaining: 1 PR (#44 - queued for next run)\n\nSignaling completion...\nDone.\n```\n\n### Stacked PRs\n\n```\n$ /drummer\n\nFinding PRs with drummer-merge label...\nFound 3 PRs:\n  PR #42 \"Fix validation bug\" → main (CI ✓)\n  PR #43 \"Add edge case tests\" → ba/abc-123 (CI ✓)\n  PR #44 \"Refactor validator\" → main (CI ✓)\n\nBuilding dependency graph...\n  Stack 1: main ← #42 (ba/abc-123) ← #43 (ba/abc-456)\n  Stack 2: main ← #44\n  2 stacks found, processing Stack 1 (2 PRs)\n\nRunning batch review on Stack 1...\nCollecting diffs: +547 -103 across 8 files\nBatch review complete: ✓ No issues\n\nProcessing stack root: PR #42 (Fix validation bug)...\n  Verifying CI... ✓\n  Rebasing onto main... clean\n  Squash merging... ✓\n  Verifying task closure... ✓\n\nProcessing stack child: PR #43 (Add edge case tests)...\n  Verifying CI... ✓\n  Updating base branch to main... done\n  Rebasing onto main... clean\n  Conflict in .ba/issues.jsonl (expected)\n  Resolving: keeping all task closures\n  Squash merging... ✓\n  Verifying task closure... ✓\n\nStack merged.\n  Merged: 2 PRs (#42, #43)\n  Remaining: 1 PR (#44 - queued for next run)\n\nSignaling completion...\nDone.\n```\n",
        ".claude-plugin/plugins/miranda/skills/mouse/SKILL.md": "---\nname: mouse\ndescription: Work a ba task to completion in a branch, including review follow-ups, then PR for human review\n---\n\n# Mouse\n\nA small autonomous worker from the Mouse Army. Claims a task, works it to completion in an isolated branch, PR for human review.\n\n## Invocation\n\n`/mouse <task-id> [branch]`\n\n- `<task-id>` - the ba task to work on\n- `[branch]` - optional base branch (default: `origin/main`)\n\nUse `[branch]` for stacked PRs where this task depends on another in-flight PR.\n\n## Flow\n\n1. Determine the target branch for claiming:\n   - If `[branch]` specified: use that branch (strip `origin/` prefix if present)\n   - Otherwise: use `main`\n2. Sync with target branch from origin:\n   ```bash\n   git fetch origin\n   git checkout -B <target-branch> origin/<target-branch>\n   ```\n   The `-B` flag creates the branch if missing, or resets it to match origin.\n3. `ba claim <task-id> --session $$`\n4. Commit and push claim to target branch (makes claim visible to other workers):\n   ```bash\n   git add .ba/\n   git commit -m \"claim: <task-id>\"\n   git push origin <target-branch>\n   ```\n5. Read dive context (if available) for project background:\n   ```bash\n   cat .wm/dive_context.md 2>/dev/null || echo \"No dive context\"\n   ```\n   This provides architecture decisions, conventions, and session intent.\n6. Read and understand the task:\n   - `ba show <task-id>` to get full details\n   - Think through the approach\n   - Ask clarifying questions if requirements are ambiguous\n   - Only proceed when confident in the approach\n7. Create worktree from base branch:\n   ```bash\n   git fetch origin\n   git worktree add .worktrees/<task-id> -b ba/<task-id> --no-track origin/<target-branch>\n   cd .worktrees/<task-id>\n   sg init\n   ```\n   The worktree bases off `origin/<target-branch>` (remote ref), where `<target-branch>` is what was determined in step 1.\n8. Work until task is complete\n9. Stage changes (`git add`)\n10. Run `sg review` on staged changes (do NOT use code-reviewer agent)\n11. Handle review findings:\n    - P1-P3 trivial: fix inline, re-stage, re-review\n    - P1-P3 non-trivial: `ba create` as descendant task\n    - P4: discard (nitpick)\n12. `ba finish <task-id>`\n13. Commit code + `.ba/` changes together (task closure travels with code)\n14. **CRITICAL: Complete ALL descendant tasks before PR.**\n    Any `ba create` during this session = descendant that blocks PR.\n    No \"follow-ups\" - if you create it, you work it now.\n\n    While ANY unclosed tasks created in this session:\n    - `ba claim <next-task>`\n    - Work until complete\n    - Stage changes\n    - Run `sg review` (each task gets its own review!)\n    - Handle findings (may spawn more descendants)\n    - `ba finish`, commit code + `.ba/`\n    - Loop until zero unclosed descendants\n15. ALL tasks closed → push and create PR:\n    ```bash\n    git push -u origin ba/<task-id>\n    gh pr create --base <target-branch> --title \"<original-task-title>\" --body \"$(cat <<'EOF'\n    ## Completed Tasks\n    - <task-id>: <title>\n    - <descendant-1>: <title>\n    - ...\n\n    ## Summary\n    <brief description of changes>\n    EOF\n    )\"\n    ```\n    Where `<base-branch>` is `main` (default) or the branch specified as second argument.\n    For stacked PRs, this creates a chain: task-2 PR targets ba/task-1, etc.\n16. Wait for CodeRabbit review, then iterate:\n    - `gh pr view <pr-number> --comments` to check for CodeRabbit feedback\n    - Handle like sg findings:\n      - Trivial: fix inline\n      - Non-trivial: `ba create` as descendant\n      - Nits: ignore\n    - For each fix or new task:\n      - Stage changes\n      - Run `sg review` (CodeRabbit fixes get sg reviewed too!)\n      - Handle any new findings (may spawn more descendants)\n      - `ba finish` if task, commit code + `.ba/`\n    - Push all changes\n    - Repeat until CodeRabbit has no new comments\n17. Return to main repo and signal completion (if `$MIRANDA_PORT` is set):\n    ```bash\n    cd <original-dir>\n    curl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n      -H \"Content-Type: application/json\" \\\n      -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\", \\\"pr\\\": \\\"<pr-url>\\\"}\"\n    ```\n    **CRITICAL:** Signal BEFORE cleanup. If still in worktree when it's deleted, curl fails.\n18. Cleanup worktree:\n    ```bash\n    git worktree remove .worktrees/<task-id>\n    ```\n19. Exit and report PR URL\n\n## Git Workflow\n\n- Create isolated worktree in `.worktrees/<task-id>`\n- All work happens on `ba/<task-id>` branch\n- Branch from main/master at start\n- Each task completion = one or more commits\n- Keep commits focused and atomic\n- PR encompasses entire task tree\n- Worktree cleaned up after PR created\n\n## Review Handling\n\n- **P1-P3 findings**: Create as ba tasks, work them in this session\n- **P4 findings**: Discard as nitpicks (don't create tasks)\n\n## Human Touchpoint\n\nThe PR is the **only** human review point.\nEverything before is autonomous.\n\n## Exit Conditions\n\n- **Success**: PR created, all tasks in tree closed\n- **Blocked**: A task needs human decision - stop and report\n- **Safety**: Max 10 task iterations (prevent runaway)\n\n## Completion Signaling (MANDATORY)\n\n**CRITICAL: You MUST signal completion when done.** If `$MIRANDA_PORT` is set, you are running under Miranda and MUST curl the completion endpoint. This is the LAST thing you do.\n\n```bash\n# Run this as your FINAL action:\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\", \\\"pr\\\": \\\"<pr-url>\\\"}\"\n```\n\n**Signal based on outcome:**\n| Outcome | Status | Payload |\n|---------|--------|---------|\n| PR created & reviewed | `success` | `\"pr\": \"<url>\"` |\n| Unrecoverable failure | `error` | `\"error\": \"<reason>\"` |\n| Needs human decision | `error` | `\"error\": \"Blocked: <reason>\"` |\n\n**If you don't signal, Miranda won't know you're done and the session becomes orphaned.**\n\n## Example\n\n```\n$ /mouse abc-123\n\nClaiming abc-123: \"Fix validation bug\"\nPushing claim to main...\nReading task details...\nTask: Input validation fails silently on empty strings\nApproach: Add explicit empty string check before processing\nNo clarifying questions needed, proceeding.\n\nCreating worktree .worktrees/abc-123 on branch ba/abc-123\nInitializing superego...\nWorking on task...\nStaging changes...\nRunning sg review...\nFound 2 issues:\n  - P3: Add test for edge case → non-trivial, created abc-456\n  - P4: Consider renaming variable → discarded (nitpick)\nReview clean (P3 spawned as task, P4 discarded)\nFinished abc-123\n[commit] fix: validate input before processing (includes .ba/ closure)\n\nWorking on descendant abc-456...\nStaging changes...\nRunning sg review...\nNo issues found.\nFinished abc-456\n[commit] test: add edge case coverage (includes .ba/ closure)\n\nAll tasks complete.\nPushing ba/abc-123...\nCreating PR...\nPR created: https://github.com/org/repo/pull/42\n\nWaiting for CodeRabbit review...\nCodeRabbit found 2 issues:\n  - \"Add nil check before dereferencing\" → trivial, fixing inline\n  - \"Consider refactoring to reduce complexity\" → nit, ignoring\n[commit] fix: add nil check per CodeRabbit\nPushing...\nCodeRabbit review passed.\n\nReturning to main repo...\nSignaling completion to Miranda...\nCleaning up worktree...\nDone.\n```\n\n### Stacked PRs Example\n\n```\n$ /mouse abc-123\n# Claims abc-123 on main, pushes to main\n# Creates PR #42: ba/abc-123 → main\n\n$ /mouse abc-456 ba/abc-123\n# Checks out ba/abc-123, claims abc-456 there, pushes to ba/abc-123\n# Creates PR #43: ba/abc-456 → ba/abc-123\n\n$ /mouse abc-789 ba/abc-456\n# Checks out ba/abc-456, claims abc-789 there, pushes to ba/abc-456\n# Creates PR #44: ba/abc-789 → ba/abc-456\n\n$ /drummer\n# Merges in order: #42 → main, rebases #43 → main, rebases #44 → main\n```\n",
        ".claude-plugin/plugins/miranda/skills/notes/SKILL.md": "---\nname: notes\ndescription: Address PR comments in worktree, resolve feedback, push fixes\n---\n\n# Notes\n\nDirector's notes to ractors. Address feedback on a PR - work in isolated worktree, resolve comments, push fixes.\n\n## Invocation\n\n`/notes <pr-number>`\n\n- `<pr-number>` - the pull request number to address comments on\n\n## Prerequisites\n\n- **Repo context**: Run from the repo root where the PR exists\n- **Not tracked as ba task**: This skill is ephemeral - it responds to feedback on an existing PR, not a new work item\n\n## Flow\n\n1. Read dive context (if available) for project background:\n   ```bash\n   cat .wm/dive_context.md 2>/dev/null || echo \"No dive context\"\n   ```\n\n2. Get PR branch info and create worktree:\n   ```bash\n   # Save original directory for cleanup\n   ORIGINAL_DIR=$(pwd)\n\n   # Get the PR branch name\n   BRANCH=$(gh pr view <pr-number> --json headRefName -q .headRefName)\n\n   # Fetch and create worktree tracking the remote branch\n   git fetch origin\n   git worktree add .worktrees/pr-<pr-number> -B $BRANCH origin/$BRANCH\n   cd .worktrees/pr-<pr-number>\n   sg init\n   ```\n   Note: `-B $BRANCH` creates/resets the local branch to track origin.\n\n3. Fetch PR comments (both top-level and inline review comments):\n   ```bash\n   gh pr view <pr-number> --json comments,reviews\n   gh api repos/{owner}/{repo}/pulls/<pr-number>/comments\n   ```\n\n4. Identify unresolved comments:\n   - Focus on actionable feedback requiring code changes\n   - Ignore resolved/outdated comments\n   - Skip non-actionable noise (e.g., \"Thanks for the PR!\")\n\n5. For each unresolved comment:\n   a. Understand the feedback\n   b. Make the fix\n   c. Stage changes (`git add`)\n   d. Run `sg review` on staged changes\n   e. Handle review findings:\n      - P1-P3 trivial (one-liner fix): fix inline, re-stage, re-review\n      - P1-P3 non-trivial (significant change): `ba create` as descendant task\n      - P4: discard (nitpick)\n\n6. **Complete ALL descendant tasks before commit.**\n   Any `ba create` during this session = descendant that blocks push.\n\n   Note: If feedback requires significant architectural changes, consider escalating\n   back to the original task author rather than creating many descendant tasks.\n\n   While ANY unclosed tasks created in this session:\n   - `ba claim <next-task>`\n   - Work until complete\n   - Stage changes\n   - Run `sg review` (each task gets its own review!)\n   - Handle findings (may spawn more descendants)\n   - `ba finish`, commit code + `.ba/`\n   - Loop until zero unclosed descendants\n\n7. Commit all fixes:\n   ```bash\n   git commit -m \"address PR #<pr-number> feedback\n\n   - <summary of each addressed comment>\"\n   ```\n\n8. Push changes:\n   ```bash\n   git push\n   ```\n\n9. Reply to addressed comments (optional but helpful):\n   ```bash\n   gh api repos/{owner}/{repo}/pulls/{pr}/comments/{comment_id}/replies \\\n     -f body=\"Fixed in $(git rev-parse --short HEAD)\"\n   ```\n\n10. Cleanup worktree:\n    ```bash\n    cd $ORIGINAL_DIR\n    git worktree remove .worktrees/pr-<pr-number>\n    ```\n\n11. Exit and report:\n   - List addressed comments\n   - Note any unresolved items that need human decision\n   - Provide PR URL\n\n## Comment Handling\n\n### Actionable Comments (address)\n- \"This should handle null case\"\n- \"Missing error handling\"\n- \"Variable name is confusing\"\n- \"Add test for edge case\"\n\n### Non-Actionable (skip, report)\n- Questions without clear ask: \"Why did you do it this way?\" (can address with code comment if helpful)\n- Design debates: \"Have you considered X approach?\"\n- Requests requiring human decision: \"Should we use A or B?\"\n\nWhen in doubt, address it. Better to over-fix than under-fix.\n\n## Review Handling\n\nSame as mouse skill:\n- **P1-P3 findings**: Create as ba tasks, work them in this session\n- **P4 findings**: Discard as nitpicks (don't create tasks)\n\n## Exit Conditions\n\n- **Success**: All actionable comments addressed, changes pushed\n- **Blocked**: Comment requires human decision - report and stop\n- **Safety**: Max 10 task iterations (prevent runaway)\n\n## Completion Signaling (MANDATORY)\n\n**CRITICAL: You MUST signal completion when done.** This is the LAST thing you do.\n\n```bash\n# On success:\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\", \\\"pr\\\": \\\"<PR-URL>\\\"}\"\n\n# On blocked (needs human):\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"blocked\\\", \\\"blocker\\\": \\\"<reason>\\\"}\"\n\n# On error:\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"error\\\", \\\"error\\\": \\\"<reason>\\\"}\"\n```\n\n**If you don't signal, Miranda won't know you're done and the session becomes orphaned.**\n\n## Example\n\n```\n$ /notes 42\n\nGetting PR #42 info...\nBranch: ba/abc-123\n\nCreating worktree .worktrees/pr-42 on branch ba/abc-123\nInitializing superego...\n\nFetching comments...\nFound 4 comments:\n  1. \"Add null check before accessing user.email\" (line 45)\n  2. \"This error message could be clearer\" (line 72)\n  3. [coderabbit] \"Consider using optional chaining\" (line 45)\n  4. \"Why not use the existing validate() function?\" → needs decision\n\nAddressing comment 1: Add null check...\nStaging changes...\nRunning sg review...\nNo issues found.\n\nAddressing comment 2: Improve error message...\nStaging changes...\nRunning sg review...\nNo issues found.\n\nAddressing comment 3: Use optional chaining...\nStaging changes...\nRunning sg review...\nNo issues found.\n\nSkipping comment 4: Requires human decision\n  (Unsure whether to refactor to use validate() or keep current approach)\n\nCommitting fixes...\n[ba/abc-123 a1b2c3d] address PR #42 feedback\n\n  - Add null check before accessing user.email\n  - Improve error message clarity\n  - Use optional chaining per CodeRabbit suggestion\n\nPushing...\nTo github.com:org/repo.git\n   f1e2d3c..a1b2c3d  ba/abc-123 -> ba/abc-123\n\nCleaning up worktree...\nSignaling blocked (comment 4 needs decision)...\n\nDone.\n  Addressed: 3 comments\n  Blocked: 1 (comment about validate() function)\n\nPR: https://github.com/org/repo/pull/42\n```\n\n### Success Example (no blockers)\n\n```console\n$ /notes 43\n\nGetting PR #43 info...\nBranch: feature/add-caching\n\nCreating worktree .worktrees/pr-43 on branch feature/add-caching\nInitializing superego...\n\nFetching comments...\nFound 2 comments:\n  1. \"Fix typo in variable name\" (line 12)\n  2. \"Add logging here\" (line 45)\n\nAddressing comment 1: Fix typo...\nAddressing comment 2: Add logging...\nCommitting fixes...\nPushing...\n\nCleaning up worktree...\nSignaling success...\n\nDone.\n  Addressed: 2 comments\n  Blocked: 0\n\nPR: https://github.com/org/repo/pull/43\n```\n",
        ".claude-plugin/plugins/miranda/skills/oh-merge/SKILL.md": "---\nname: oh-merge\ndescription: Review and merge open PRs for GitHub issues as a cohesive batch\n---\n\n# oh-merge\n\nLike drummer, but for GitHub issue PRs (from oh-task) instead of ba task PRs (from mouse). Holistically review pending PRs, then squash-merge them as a cohesive batch.\n\n## Invocation\n\n`/oh-merge`\n\n## Flow\n\n1. Read dive context (if available) for project background:\n   ```bash\n   cat .wm/dive_context.md 2>/dev/null || echo \"No dive context\"\n   ```\n\n2. Find all PRs with `oh-merge` label:\n   ```bash\n   gh pr list --label oh-merge --json number,title,headRefName,baseRefName,additions,deletions\n   ```\n   **Only PRs with the `oh-merge` label are eligible for merge.**\n\n   **IMPORTANT:** PRs with merge conflicts ARE eligible. The skill rebases and resolves conflicts in step 6. Do NOT skip PRs because of conflict status - that's exactly what this skill handles.\n\n3. **Build dependency graph and identify stacks:**\n   - Create adjacency list: `baseRefName → [PRs targeting it]`\n   - Find root PRs: those where `baseRefName = main` (or master)\n   - Identify stacks: chains where child PRs target parent PR branches\n   - **Detect cycles**: If a branch eventually targets itself, report error and skip\n   - Example graph:\n     ```\n     main ← PR #42 (issue/123) ← PR #43 (issue/456)\n     main ← PR #44 (issue/789)  [separate stack]\n     ```\n\n4. **Select stack to process:**\n   - If multiple independent stacks exist, pick first by lowest root PR number (FIFO by age)\n   - If multiple PRs target the same base branch, order by PR number (lowest first)\n   - Report other stacks as \"queued for next run\"\n   - Process only one stack per invocation to keep merges atomic\n   - **Orphaned children**: If a child PR targets a branch that doesn't exist (parent merged externally), update its base to main and treat as a root\n\n5. **Batch review** - evaluate all PRs in the selected stack together:\n   - Collect combined diff of all PRs against main\n   - Run `sg review` on the combined changes\n   - Evaluate:\n     - Do changes conflict logically? (same code modified differently)\n     - Is there duplicate work? (two PRs solving same problem)\n     - Do changes compose well? (feature A + feature B = coherent whole)\n     - Any cross-cutting concerns? (shared dependencies, API changes)\n   - If concerns found:\n     - Report issues\n     - Ask human whether to proceed or address first\n\n6. **Merge stack in dependency order** (root first, then children):\n\n   For each PR in the stack, starting from the root:\n\n   a. **Verify CI is passing:**\n      ```bash\n      gh pr checks <pr-number> --fail-on-error\n      ```\n      If CI is failing, stop and report error.\n\n   b. **Rebase onto its target branch:**\n      ```bash\n      git fetch origin\n      gh pr checkout <pr-number>\n      git rebase origin/<base-branch>  # main for root, parent branch for children\n      ```\n\n   c. **Resolve any rebase conflicts** (this is expected and normal):\n      - Conflicts WILL occur when main has moved since the PR was created\n      - Use standard git conflict resolution to fix each conflicting file\n      - This is the core value of oh-merge - handling what GitHub can't auto-merge\n      - Only fail if conflicts are truly unresolvable (contradictory changes)\n\n   d. Push rebased branch:\n      ```bash\n      git push --force-with-lease\n      ```\n\n   e. Squash merge:\n      ```bash\n      gh pr merge <pr-number> --squash\n      ```\n\n   f. **For child PRs in the stack** (after parent merged):\n      - Update base branch to main:\n        ```bash\n        gh pr edit <child-pr-number> --base main\n        ```\n      - Rebase child onto main:\n        ```bash\n        gh pr checkout <child-pr-number>\n        git rebase origin/main\n        git push --force-with-lease\n        ```\n      - Now child PR targets main and is rebased, continue to merge it (step a-e)\n\n   g. **On merge failure** - If any PR in the stack fails to merge:\n      - Stop processing the stack\n      - Report which PRs were merged successfully and which failed\n      - Signal error: already-merged PRs stay merged, failed PR remains open\n      - Next oh-merge run will see the failed PR as a new root (its parent is now in main)\n\n   **Note:** Unlike drummer, no `ba finish` step is needed. GitHub automatically closes\n   linked issues when the PR merges (via \"Closes #N\" in the PR body).\n\n7. **Signal completion (MANDATORY)** - This is the LAST thing you do:\n   ```bash\n   # On success:\n   curl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n     -H \"Content-Type: application/json\" \\\n     -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\"}\"\n\n   # On error:\n   curl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n     -H \"Content-Type: application/json\" \\\n     -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"error\\\", \\\"error\\\": \\\"<reason>\\\"}\"\n   ```\n   **If you don't signal, Miranda won't know you're done and the session becomes orphaned.**\n\n## Stacked PRs\n\nWhen PRs target other PR branches (not main), oh-merge detects the stack and processes it:\n\n**Detection:**\n```bash\ngh pr list --label oh-merge --json number,title,headRefName,baseRefName\n```\n- PRs with `baseRefName = main` are roots\n- PRs with `baseRefName = issue/<number>` are children targeting that parent\n- Ignore merge conflict status - we handle conflicts during rebase\n\n**Graph building:**\n```\nadjacency[baseRefName] = [list of PRs targeting it]\n\nExample:\n  adjacency[\"main\"] = [PR #42, PR #44]\n  adjacency[\"issue/123\"] = [PR #43]\n\nStack 1: main ← #42 (issue/123) ← #43 (issue/456)\nStack 2: main ← #44 (issue/789)\n```\n\n**Merge sequence** (for Stack 1):\n1. Merge #42 to main\n2. Update #43: `gh pr edit 43 --base main`\n3. Rebase #43 onto main: `git rebase origin/main && git push --force-with-lease`\n4. Merge #43 to main\n\n**After processing:**\n```\nBefore:  PR #43 → issue/123 → main\n         PR #42 → main\n         PR #44 → main (separate stack)\n\nAfter:   PR #42 merged to main (issue #123 auto-closed)\n         PR #43 rebased onto main, merged to main (issue #456 auto-closed)\n         PR #44 remains for next oh-merge run\n```\n\n## Batch Review Criteria\n\nThe holistic review checks what individual PR reviews can't:\n\n- **Logical conflicts**: PR A assumes X, PR B assumes not-X\n- **Duplication**: Both PRs add similar functionality\n- **Integration issues**: Combined changes break something neither breaks alone\n- **Ordering dependencies**: PR B depends on PR A being merged first (auto-detected for stacked PRs)\n- **Scope creep**: Batch as a whole does more than originally intended\n\n## Prerequisites\n\n- PRs must have the `oh-merge` label (human approval gate)\n- PRs must have CI passing\n- PRs should have \"Closes #N\" in body for auto-close (created by oh-task)\n- Batch review must pass (or human override)\n\n**Note:** The `oh-merge` label must be created in the repo. This is opt-in per repo.\n\n## Exit Conditions\n\n- **Success**: Selected stack fully merged → signal `status: \"success\"`\n- **Partial success**: Some PRs in stack merged, then failure → signal `status: \"error\"` with details\n- **Needs attention**: Batch review raised concerns - waiting for human decision (no signal - awaiting input)\n- **Error**: Unrecoverable failure (code conflicts, CI failing, cycle detected) → signal `status: \"error\"` with message\n- **No work**: No PRs with `oh-merge` label found → signal `status: \"success\"` (nothing to do)\n\n## Example\n\n### Basic (no stacks)\n\n```\n$ /oh-merge\n\nFinding PRs with oh-merge label...\nFound 2 PRs:\n  PR #42 \"Fix validation bug\" (issue/123) → main (CI ✓)\n  PR #44 \"Refactor validator\" (issue/789) → main (CI ✓)\n\nBuilding dependency graph...\n  Stack 1: main ← #42\n  Stack 2: main ← #44\n  2 independent stacks, processing Stack 1\n\nRunning batch review on Stack 1 (1 PR)...\nBatch review complete: ✓ No issues\n\nProcessing PR #42 (Fix validation bug)...\n  Verifying CI... ✓\n  Rebasing onto main... clean\n  Squash merging... ✓\n  Issue #123 will auto-close on merge\n\nMerge complete.\n  Merged: 1 PR (#42)\n  Remaining: 1 PR (#44 - queued for next run)\n\nSignaling completion...\nDone.\n```\n\n### Stacked PRs\n\n```\n$ /oh-merge\n\nFinding PRs with oh-merge label...\nFound 3 PRs:\n  PR #42 \"Fix validation bug\" (issue/123) → main (CI ✓)\n  PR #43 \"Add edge case tests\" (issue/456) → issue/123 (CI ✓)\n  PR #44 \"Refactor validator\" (issue/789) → main (CI ✓)\n\nBuilding dependency graph...\n  Stack 1: main ← #42 (issue/123) ← #43 (issue/456)\n  Stack 2: main ← #44\n  2 stacks found, processing Stack 1 (2 PRs)\n\nRunning batch review on Stack 1...\nCollecting diffs: +547 -103 across 8 files\nBatch review complete: ✓ No issues\n\nProcessing stack root: PR #42 (Fix validation bug)...\n  Verifying CI... ✓\n  Rebasing onto main... clean\n  Squash merging... ✓\n  Issue #123 will auto-close on merge\n\nProcessing stack child: PR #43 (Add edge case tests)...\n  Verifying CI... ✓\n  Updating base branch to main... done\n  Rebasing onto main... clean\n  Squash merging... ✓\n  Issue #456 will auto-close on merge\n\nStack merged.\n  Merged: 2 PRs (#42, #43)\n  Remaining: 1 PR (#44 - queued for next run)\n\nSignaling completion...\nDone.\n```\n",
        ".claude-plugin/plugins/miranda/skills/oh-notes/SKILL.md": "---\nname: oh-notes\ndescription: Address PR comments for GitHub issue PRs, resolve feedback, push fixes\n---\n\n# oh-notes\n\nLike notes, but for PRs from oh-task (GitHub issues). Address feedback on a PR - work in isolated worktree, resolve comments, push fixes. Uses GitHub issues for descendant tasks instead of ba.\n\n## Invocation\n\n`/oh-notes <pr-number>`\n\n- `<pr-number>` - the pull request number to address comments on\n\n## Prerequisites\n\n- **Repo context**: Run from the repo root where the PR exists\n- **GitHub issue PR**: The PR should be from an oh-task session (branch `issue/<number>`)\n\n## Flow\n\n1. Read dive context (if available) for project background:\n   ```bash\n   cat .wm/dive_context.md 2>/dev/null || echo \"No dive context\"\n   ```\n\n2. Get PR branch info and create worktree:\n   ```bash\n   # Save original directory for cleanup\n   ORIGINAL_DIR=$(pwd)\n\n   # Get the PR branch name and linked issue\n   BRANCH=$(gh pr view <pr-number> --json headRefName -q .headRefName)\n\n   # Extract issue number from branch (issue/<number>)\n   PARENT_ISSUE=${BRANCH#issue/}\n\n   # Fetch and create worktree tracking the remote branch\n   git fetch origin\n   git worktree add .worktrees/pr-<pr-number> -B $BRANCH origin/$BRANCH\n   cd .worktrees/pr-<pr-number>\n   sg init\n   ```\n   Note: `-B $BRANCH` creates/resets the local branch to track origin.\n\n3. Fetch PR comments (both top-level and inline review comments):\n   ```bash\n   gh pr view <pr-number> --json comments,reviews\n   gh api repos/{owner}/{repo}/pulls/<pr-number>/comments\n   ```\n\n4. Identify unresolved comments:\n   - Focus on actionable feedback requiring code changes\n   - Ignore resolved/outdated comments\n   - Skip non-actionable noise (e.g., \"Thanks for the PR!\")\n\n5. For each unresolved comment:\n   a. Understand the feedback\n   b. Make the fix\n   c. Stage changes (`git add`)\n   d. Run `sg review` on staged changes\n   e. Handle review findings:\n      - P1-P3 trivial (one-liner fix): fix inline, re-stage, re-review\n      - P1-P3 non-trivial (significant change): create GitHub issue as descendant\n      - P4: discard (nitpick)\n\n   **Creating descendant issues** (instead of ba tasks):\n   ```bash\n   # Create issue linked to parent\n   NEW_ISSUE=$(gh issue create \\\n     --title \"Fix: <brief description>\" \\\n     --body \"Spawned from #${PARENT_ISSUE} during PR #<pr-number> review.\n\n   ## Context\n   <what sg review found>\n\n   ## Acceptance\n   - [ ] Fix applied\n   - [ ] sg review passes\" \\\n     --assignee @me | grep -oE '[0-9]+$')\n\n   echo \"Created descendant issue #${NEW_ISSUE}\"\n   ```\n\n6. **Complete ALL descendant issues before commit.**\n   Any GitHub issue created during this session = descendant that blocks push.\n\n   Note: If feedback requires significant architectural changes, consider escalating\n   back to the original task author rather than creating many descendant issues.\n\n   While ANY unclosed issues created in this session:\n   - Work on the fix (same worktree, same branch)\n   - Stage changes\n   - Run `sg review` (each issue gets its own review!)\n   - Handle findings (may spawn more descendants)\n   - Commit with \"Fixes #<issue-number>\" to auto-close\n   - Loop until zero unclosed descendants\n\n7. Commit all fixes:\n   ```bash\n   # If there are descendant issues to close, include them in commit\n   git commit -m \"address PR #<pr-number> feedback\n\n   - <summary of each addressed comment>\n\n   Fixes #<descendant-issue-1>\n   Fixes #<descendant-issue-2>\"\n   ```\n\n8. Push changes:\n   ```bash\n   git push\n   ```\n\n9. Reply to addressed comments (optional but helpful):\n   ```bash\n   gh api repos/{owner}/{repo}/pulls/{pr}/comments/{comment_id}/replies \\\n     -f body=\"Fixed in $(git rev-parse --short HEAD)\"\n   ```\n\n10. Cleanup worktree:\n    ```bash\n    cd $ORIGINAL_DIR\n    git worktree remove .worktrees/pr-<pr-number>\n    ```\n\n11. Exit and report:\n   - List addressed comments\n   - Note any unresolved items that need human decision\n   - Provide PR URL\n\n## Comment Handling\n\n### Actionable Comments (address)\n- \"This should handle null case\"\n- \"Missing error handling\"\n- \"Variable name is confusing\"\n- \"Add test for edge case\"\n\n### Non-Actionable (skip, report)\n- Questions without clear ask: \"Why did you do it this way?\" (can address with code comment if helpful)\n- Design debates: \"Have you considered X approach?\"\n- Requests requiring human decision: \"Should we use A or B?\"\n\nWhen in doubt, address it. Better to over-fix than under-fix.\n\n## Review Handling\n\n- **P1-P3 findings**: Create as GitHub issues, work them in this session\n- **P4 findings**: Discard as nitpicks (don't create issues)\n\n## Exit Conditions\n\n- **Success**: All actionable comments addressed, changes pushed\n- **Blocked**: Comment requires human decision - report and stop\n- **Safety**: Max 10 issue iterations (prevent runaway)\n\n## Completion Signaling (MANDATORY)\n\n**CRITICAL: You MUST signal completion when done.** This is the LAST thing you do.\n\n```bash\n# On success:\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\", \\\"pr\\\": \\\"<PR-URL>\\\"}\"\n\n# On blocked (needs human):\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"blocked\\\", \\\"blocker\\\": \\\"<reason>\\\"}\"\n\n# On error:\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"error\\\", \\\"error\\\": \\\"<reason>\\\"}\"\n```\n\n**If you don't signal, Miranda won't know you're done and the session becomes orphaned.**\n\n## Example\n\n```\n$ /oh-notes 42\n\nGetting PR #42 info...\nBranch: issue/123\nParent issue: #123\n\nCreating worktree .worktrees/pr-42 on branch issue/123\nInitializing superego...\n\nFetching comments...\nFound 4 comments:\n  1. \"Add null check before accessing user.email\" (line 45)\n  2. \"This error message could be clearer\" (line 72)\n  3. [coderabbit] \"Consider using optional chaining\" (line 45)\n  4. \"Why not use the existing validate() function?\" -> needs decision\n\nAddressing comment 1: Add null check...\nStaging changes...\nRunning sg review...\nNo issues found.\n\nAddressing comment 2: Improve error message...\nStaging changes...\nRunning sg review...\nNo issues found.\n\nAddressing comment 3: Use optional chaining...\nStaging changes...\nRunning sg review...\nNo issues found.\n\nSkipping comment 4: Requires human decision\n  (Unsure whether to refactor to use validate() or keep current approach)\n\nCommitting fixes...\n[issue/123 a1b2c3d] address PR #42 feedback\n\n  - Add null check before accessing user.email\n  - Improve error message clarity\n  - Use optional chaining per CodeRabbit suggestion\n\nPushing...\nTo github.com:org/repo.git\n   f1e2d3c..a1b2c3d  issue/123 -> issue/123\n\nCleaning up worktree...\nSignaling blocked (comment 4 needs decision)...\n\nDone.\n  Addressed: 3 comments\n  Blocked: 1 (comment about validate() function)\n\nPR: https://github.com/org/repo/pull/42\n```\n\n### With Descendant Issue\n\n```\n$ /oh-notes 43\n\nGetting PR #43 info...\nBranch: issue/456\nParent issue: #456\n\nCreating worktree .worktrees/pr-43 on branch issue/456\nInitializing superego...\n\nFetching comments...\nFound 1 comment:\n  1. \"Add input validation\" (line 12)\n\nAddressing comment 1: Add input validation...\nStaging changes...\nRunning sg review...\n\nsg review found P2 issue:\n  \"Validation should also handle edge case X\"\n\nCreating descendant issue...\nCreated issue #457: \"Fix: Handle validation edge case X\"\n\nWorking on #457...\nMaking fix...\nStaging...\nRunning sg review...\nNo issues found.\n\nCommitting all fixes...\n[issue/456 b2c3d4e] address PR #43 feedback\n\n  - Add input validation per review\n  - Handle validation edge case X\n\n  Fixes #457\n\nPushing...\nCleaning up worktree...\nSignaling success...\n\nDone.\n  Addressed: 1 comment\n  Descendant issues closed: #457\n\nPR: https://github.com/org/repo/pull/43\n```\n",
        ".claude-plugin/plugins/miranda/skills/oh-plan/SKILL.md": "---\nname: oh-plan\ndescription: Investigate a task, ask clarifying questions, and create well-structured GitHub issues ready for oh-task\n---\n\n# oh-plan\n\nTakes a high-level task description, investigates the codebase, asks clarifying questions, and creates actionable GitHub issues ready for oh-task agents.\n\n## Invocation\n\n`/oh-plan \"<task description>\"`\n\nExample: `/oh-plan \"Add dark mode support to the dashboard\"`\n\n## Flow\n\n1. **Explore the codebase** to understand:\n   - Project architecture and patterns\n   - Relevant files that would be touched\n   - Existing similar implementations to follow\n   - Potential complications or dependencies\n\n2. **Ask clarifying questions** via AskUserQuestion:\n   - Scope boundaries (what's in/out of scope)\n   - Technical preferences (if multiple approaches exist)\n   - Priority and any constraints\n   - Only ask questions that genuinely affect the plan\n\n3. **Assess complexity** and determine decomposition:\n   - **Single coherent task** → create 1 issue\n   - **Multiple independent pieces** → create multiple issues\n   - **Large with dependencies** → create issues with \"Depends on #N\" links\n   - Aim for issues that are 1-4 hours of work each\n\n4. **Create GitHub issue(s)** with the `oh-planned` label:\n   ```bash\n   # Create label if it doesn't exist (one-time)\n   gh label create oh-planned --description \"Created via oh-plan skill\" --color \"0E8A16\" 2>/dev/null || true\n\n   # Create issue\n   gh issue create --title \"<clear, actionable title>\" --label \"oh-planned\" --body \"$(cat <<'EOF'\n   ## Goal\n\n   <1-2 sentences describing what we're trying to achieve>\n\n   ## Context\n\n   <relevant background - files identified, patterns to follow, constraints>\n\n   ## Acceptance Criteria\n\n   - [ ] Criterion 1 (specific, testable)\n   - [ ] Criterion 2\n   - [ ] Criterion 3\n\n   ## Notes\n\n   <any technical decisions, edge cases, or things to watch out for>\n   EOF\n   )\"\n   ```\n\n5. **Signal completion** (if `$MIRANDA_PORT` is set):\n   ```bash\n   curl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n     -H \"Content-Type: application/json\" \\\n     -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\"}\"\n   ```\n\n## Issue Quality Guidelines\n\nIssues created by oh-plan should be:\n\n- **Self-contained**: All context needed to start work without re-investigation\n- **Actionable**: Clear title, specific acceptance criteria, \"done\" is obvious\n- **Right-sized**: 1-4 hours of focused work (not too big, not trivial)\n- **Linked**: Dependencies explicitly noted if multiple issues created\n\n### Good Issue Title Examples\n\n- \"Add session timeout detection with configurable threshold\"\n- \"Refactor user auth to use JWT instead of sessions\"\n- \"Fix race condition in concurrent task spawning\"\n\n### Bad Issue Title Examples\n\n- \"Improve the code\" (too vague)\n- \"Do the thing we discussed\" (no context)\n- \"Bug fix\" (what bug?)\n\n## Decomposition Strategy\n\n**Bias toward focused issues.** A well-scoped issue that does one thing well is better than a multifaceted issue that tries to do many things. When genuinely uncertain, prefer splitting - but don't create trivial issues.\n\n### When to Split\n\nSplit into multiple issues when ANY of these apply:\n\n- **Multiple modules with distinct concerns** - Each coherent subsystem change can be its own issue\n- **Mix of backend and frontend** - API changes and UI changes often work better as separate issues\n- **Testable in isolation** - If parts can be tested independently, they're candidates for separate issues\n- **Different risk profiles** - Risky changes shouldn't be bundled with straightforward ones\n\n### When NOT to Split\n\nKeep as one issue when:\n\n- **Integration is trivial** - Just wiring things together with a few lines of code\n- **Changes are tightly coupled** - Splitting would create issues that can't be tested alone\n- **The \"integration\" is obvious** - No complex error handling, no new edge cases\n- **Total scope is still reasonable** - Even combined, it's 2-4 hours of work\n\n### Integration Issues\n\nConsider a separate integration issue when connecting components involves:\n\n- Non-trivial error handling at boundaries\n- New edge cases that emerge from the combination\n- Complex state coordination between systems\n- A meaningful test surface (end-to-end flows worth testing explicitly)\n\n**Don't** create integration issues for:\n- Simple API calls with straightforward error handling\n- Passing data from one component to another\n- Standard CRUD wiring\n\n**Pattern when integration IS complex:**\n```\nIssue #1: \"Add theme persistence API\" (Foundation)\nIssue #2: \"Add theme toggle component\" (Feature)\nIssue #3: \"Wire theme system with fallback handling\" (Integration - Depends on #1, #2)\n  - Handle API failures gracefully\n  - System preference detection fallback\n  - Theme flicker prevention on load\n```\n\n### Decomposition Example\n\n**Task:** \"Add dark mode support to the dashboard\"\n\n**Over-decomposed (too many trivial issues):**\n```\nIssue #1: Add preferences API\nIssue #2: Add toggle component\nIssue #3: Add CSS variables\nIssue #4: Wire toggle to API\nIssue #5: Wire CSS to components\nIssue #6: Handle loading states\n```\n\n**Under-decomposed (one big issue):**\n```\nIssue #1: Add dark mode support (everything)\n```\n\n**Right-sized:**\n```\nIssue #1: \"Add user preferences API with theme support\" (Foundation)\n  - GET/POST /api/preferences\n  - Includes theme field\n\nIssue #2: \"Add dark mode theming system\" (Feature - Depends on #1)\n  - CSS custom properties for light/dark\n  - Theme toggle in settings\n  - Wire to preferences API\n  - Apply theme on app load\n\nIssue #3: \"Handle theme edge cases\" (Polish - Depends on #2)\n  - Only if complex: system preference fallback,\n    theme flicker prevention, etc.\n  - Skip if straightforward\n```\n\n### Dependency Notation\n\nUse \"Depends on #N\" in issue body:\n```\n## Goal\nAdd dark mode theming system with toggle and persistence.\n\n**Depends on:** #1 (preferences API)\n```\n\n## What NOT to Do\n\n- Don't create issues for trivial changes (typo fixes, single-line changes)\n- Don't over-decompose - 10 tiny issues is worse than 2-3 well-scoped ones\n- Don't start implementation - oh-plan is for planning only\n- Don't skip the clarifying questions if scope is ambiguous\n\n## Exit Conditions\n\n| Outcome | Signal |\n|---------|--------|\n| Issue(s) created successfully | `status: \"success\"` |\n| User cancelled during questions | `status: \"error\", error: \"User cancelled\"` |\n| Failed to create issue | `status: \"error\", error: \"<reason>\"` |\n\n## Example Session\n\n```\n$ /oh-plan \"Add heartbeat monitoring for tmux sessions\"\n\nExploring codebase...\nFound relevant files:\n- src/tmux/sessions.ts (session management)\n- src/state/sessions.ts (session state tracking)\n- src/index.ts (main loop)\n\nI have a few questions to scope this correctly:\n\nQ: What should happen when a session stops responding?\n[1] Mark as crashed, notify user\n[2] Auto-restart the session\n[3] Just log and continue\n\nUser: 1\n\nQ: How often should we check for heartbeats?\n[1] Every 30 seconds (Recommended)\n[2] Every minute\n[3] Every 5 minutes\n\nUser: 1\n\nCreating issue...\n\nCreated issue #67: \"Add heartbeat monitoring for tmux sessions\"\n\n## Goal\nDetect when tmux sessions stop responding and notify the user.\n\n## Context\n- Sessions are tracked in src/state/sessions.ts\n- Tmux interactions in src/tmux/sessions.ts\n- Need to add periodic check in main loop\n\n## Acceptance Criteria\n- [ ] Check session liveness every 30 seconds\n- [ ] Mark session as \"crashed\" if not responding\n- [ ] Send Telegram notification when session crashes\n- [ ] Add crashed sessions to /status output\n\n## Notes\n- Use tmux has-session to check liveness\n- Consider: what if tmux server itself is down?\n\nSignaling completion...\nDone. Issue #67 ready for /oh-task.\n```\n",
        ".claude-plugin/plugins/miranda/skills/oh-task/SKILL.md": "---\nname: oh-task\ndescription: Work a GitHub issue to completion in a branch, including review follow-ups, then PR for human review\n---\n\n# oh-task\n\nLike mouse, but for GitHub issues instead of ba tasks. Claims an issue, works it to completion in an isolated branch, PR for human review.\n\n## Invocation\n\n`/oh-task <issue-number> [branch]`\n\n- `<issue-number>` - the GitHub issue number (e.g., `123` or `#123`)\n- `[branch]` - optional base branch (default: `origin/main`)\n\nUse `[branch]` for stacked PRs where this issue depends on another in-flight PR.\n\n## Flow\n\n1. Determine the target branch:\n   - If `[branch]` specified: use that branch (strip `origin/` prefix if present)\n   - Otherwise: use `main`\n2. Sync with target branch from origin:\n   ```bash\n   git fetch origin\n   git checkout -B <target-branch> origin/<target-branch>\n   ```\n3. Fetch and validate issue:\n   ```bash\n   gh issue view <issue-number> --json number,title,body,state,assignees\n   ```\n   Abort if issue is closed or already assigned to someone else.\n4. Claim issue (assign to self):\n   ```bash\n   gh issue edit <issue-number> --add-assignee @me\n   ```\n   No commit needed - state is on GitHub.\n5. Read dive context (if available) for project background:\n   ```bash\n   cat .wm/dive_context.md 2>/dev/null || echo \"No dive context\"\n   ```\n6. Read and understand the issue:\n   - Review issue title and body\n   - Think through the approach\n   - Ask clarifying questions if requirements are ambiguous\n   - Only proceed when confident in the approach\n7. Create worktree from base branch:\n   ```bash\n   git fetch origin\n   git worktree add .worktrees/issue-<number> -b issue/<number> --no-track origin/<target-branch>\n   cd .worktrees/issue-<number>\n   sg init\n   ```\n8. Work until issue is resolved\n9. Stage changes (`git add`)\n10. Run code checks (cargo check, npm/pnpm build, go build, etc. based on project type).\n    Fix any errors, re-stage, re-run until clean.\n11. Run `sg review` on staged changes (do NOT use code-reviewer agent)\n12. Handle review findings:\n    - P1-P3 trivial: fix inline, re-stage, re-review\n    - P1-P3 non-trivial: create child issue with `gh issue create --title \"...\" --body \"Parent: #<issue-number>\"`\n    - P4: discard (nitpick)\n13. Commit code changes\n14. **CRITICAL: Complete ALL child issues before PR.**\n    Any `gh issue create` during this session = child that blocks PR.\n    No \"follow-ups\" - if you create it, you work it now.\n\n    While ANY unclosed issues created in this session:\n    - Claim: `gh issue edit <child-number> --add-assignee @me`\n    - Work until complete\n    - Stage changes\n    - Run code checks, fix errors until clean\n    - Run `sg review` (each issue gets its own review!)\n    - Handle findings (may spawn more children)\n    - Commit\n    - Loop until zero unclosed children\n15. ALL issues addressed -> push and create PR:\n    ```bash\n    git push -u origin issue/<number>\n    gh pr create --base <target-branch> --title \"<issue-title>\" --body \"$(cat <<'EOF'\n    Closes #<issue-number>\n\n    ## Also Closes\n    - #<child-1>\n    - #<child-2>\n\n    ## Summary\n    <brief description of changes>\n    EOF\n    )\"\n    ```\n    The \"Closes #N\" syntax auto-closes issues when PR merges.\n16. Wait for CodeRabbit review, then iterate:\n    - `gh pr view <pr-number> --comments` to check for CodeRabbit feedback\n    - Handle like sg findings:\n      - Trivial: fix inline\n      - Non-trivial: create child issue\n      - Nits: ignore\n    - For each fix or new issue:\n      - Stage changes\n      - Run code checks, fix errors until clean\n      - Run `sg review` (CodeRabbit fixes get sg reviewed too!)\n      - Handle any new findings\n      - Commit\n    - Push all changes\n    - Repeat until CodeRabbit has no new comments\n17. Return to main repo and signal completion (if `$MIRANDA_PORT` is set):\n    ```bash\n    cd <original-dir>\n    curl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n      -H \"Content-Type: application/json\" \\\n      -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\", \\\"pr\\\": \\\"<pr-url>\\\"}\"\n    ```\n    **CRITICAL:** Signal BEFORE cleanup. If still in worktree when it's deleted, curl fails.\n18. Cleanup worktree:\n    ```bash\n    git worktree remove .worktrees/issue-<number>\n    ```\n19. Exit and report PR URL\n\n## Git Workflow\n\n- Create isolated worktree in `.worktrees/issue-<number>`\n- All work happens on `issue/<number>` branch\n- Branch from main/master at start\n- Each issue = one or more commits\n- Keep commits focused and atomic\n- PR encompasses entire issue tree (parent + children)\n- Worktree cleaned up after PR created\n\n## Review Handling\n\n- **P1-P3 findings**: Create as GitHub issues, work them in this session\n- **P4 findings**: Discard as nitpicks (don't create issues)\n\n## Human Touchpoint\n\nThe PR is the **only** human review point.\nEverything before is autonomous.\n\n## Exit Conditions\n\n- **Success**: PR created, all issues in tree will close on merge\n- **Blocked**: An issue needs human decision - stop and report\n- **Safety**: Max 10 issue iterations (prevent runaway)\n\n## Completion Signaling (MANDATORY)\n\n**CRITICAL: You MUST signal completion when done.** If `$MIRANDA_PORT` is set, you are running under Miranda and MUST curl the completion endpoint. This is the LAST thing you do.\n\n```bash\n# Run this as your FINAL action:\ncurl -sS -X POST \"http://localhost:${MIRANDA_PORT}/complete\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\\\"session\\\": \\\"$TMUX_SESSION\\\", \\\"status\\\": \\\"success\\\", \\\"pr\\\": \\\"<pr-url>\\\"}\"\n```\n\n**Signal based on outcome:**\n| Outcome | Status | Payload |\n|---------|--------|---------|\n| PR created & reviewed | `success` | `\"pr\": \"<url>\"` |\n| Unrecoverable failure | `error` | `\"error\": \"<reason>\"` |\n| Needs human decision | `error` | `\"error\": \"Blocked: <reason>\"` |\n\n**If you don't signal, Miranda won't know you're done and the session becomes orphaned.**\n\n## Example\n\n```\n$ /oh-task 42\n\nFetching issue #42...\nIssue: \"Fix validation bug in auth module\"\nState: open, unassigned\n\nClaiming issue #42...\nAssigned to @me\n\nReading dive context...\nNo dive context found.\n\nReading issue details...\nIssue: Input validation fails silently on empty strings\nApproach: Add explicit empty string check before processing\nNo clarifying questions needed, proceeding.\n\nCreating worktree .worktrees/issue-42 on branch issue/42\nInitializing superego...\nWorking on issue...\nStaging changes...\nRunning sg review...\nFound 2 issues:\n  - P3: Add test for edge case -> non-trivial, created issue #43 (Parent: #42)\n  - P4: Consider renaming variable -> discarded (nitpick)\nReview clean (P3 spawned as issue, P4 discarded)\n[commit] fix: validate input before processing\n\nWorking on child issue #43...\nClaiming issue #43...\nStaging changes...\nRunning sg review...\nNo issues found.\n[commit] test: add edge case coverage\n\nAll issues complete.\nPushing issue/42...\nCreating PR...\nPR created: https://github.com/org/repo/pull/99\nBody includes: Closes #42, Closes #43\n\nWaiting for CodeRabbit review...\nCodeRabbit found 2 issues:\n  - \"Add nil check before dereferencing\" -> trivial, fixing inline\n  - \"Consider refactoring to reduce complexity\" -> nit, ignoring\n[commit] fix: add nil check per CodeRabbit\nPushing...\nCodeRabbit review passed.\n\nReturning to main repo...\nSignaling completion to Miranda...\nCleaning up worktree...\nDone.\n```\n\n### Stacked PRs Example\n\n```\n$ /oh-task 42\n# Claims issue #42 on main\n# Creates PR #99: issue/42 -> main (Closes #42)\n\n$ /oh-task 43 issue/42\n# Checks out issue/42, claims issue #43\n# Creates PR #100: issue/43 -> issue/42 (Closes #43)\n\n$ /oh-task 44 issue/43\n# Checks out issue/43, claims issue #44\n# Creates PR #101: issue/44 -> issue/43 (Closes #44)\n\n$ /drummer\n# Merges in order: #99 -> main, rebases #100 -> main, rebases #101 -> main\n```\n",
        ".claude-plugin/plugins/oh-mcp/.claude-plugin/plugin.json": "{\n  \"name\": \"oh-mcp\",\n  \"version\": \"0.3.0\",\n  \"description\": \"Open Horizons MCP - Align AI decision-making with strategic context\",\n  \"author\": {\n    \"name\": \"Cloud Atlas AI\",\n    \"email\": \"hello@cloudatlas.ai\",\n    \"url\": \"https://github.com/cloud-atlas-ai/oh-mcp-server\"\n  },\n  \"repository\": \"https://github.com/cloud-atlas-ai/oh-mcp-server\",\n  \"homepage\": \"https://app.openhorizons.me\"\n}\n",
        ".claude-plugin/plugins/oh-mcp/commands/setup.md": "# Setup Open Horizons MCP\n\nSet up the Open Horizons MCP server for strategic alignment integration.\n\n**Execute these steps in order:**\n\n## Step 1: Check for existing API key config\n\nCheck if `~/.config/openhorizons/config.json` exists and has an api_key:\n```bash\ncat ~/.config/openhorizons/config.json 2>/dev/null\n```\n\nIf the file exists and has a valid api_key, skip to Step 3.\n\nIf not configured, check if `sg` (superego CLI) is available:\n```bash\nwhich sg\n```\n\n**If sg is available:** Tell the user to run `sg setup-oh` in their terminal. This will:\n- Open browser to get API key\n- Prompt them to paste the key\n- Create the config file\n\n**If sg is NOT available:** Ask the user for their API key, then create the config:\n```bash\nmkdir -p ~/.config/openhorizons\n```\n\nThen write to `~/.config/openhorizons/config.json`:\n```json\n{\n  \"api_key\": \"<USER_PROVIDED_KEY>\",\n  \"api_url\": \"https://app.openhorizons.me\"\n}\n```\n\nTell them to get a key from https://app.openhorizons.me/settings/api-keys if they don't have one.\n\n## Step 2: Add MCP server to Claude Code\n\nUse the `claude mcp add` command to register the server with npx (works across all Node.js versions):\n```bash\nclaude mcp add oh-mcp --scope user -- npx -y @cloud-atlas-ai/oh-mcp-server\n```\n\nThis adds oh-mcp to `~/.claude.json` so it's available across all projects. Using `npx` ensures it works regardless of which Node.js version each project uses.\n\n## Step 3: Inform the user\n\nTell the user:\n1. Setup is complete\n2. They need to **restart Claude Code** for the MCP to load\n3. After restart, OH MCP tools will be available:\n   - `oh_get_contexts` - List workspaces\n   - `oh_get_endeavors` - Browse endeavors\n   - `oh_log_decision` - Log decisions\n   - `oh_about` - Test the connection\n",
        ".claude-plugin/plugins/superego/.claude-plugin/plugin.json": "{\n  \"name\": \"superego\",\n  \"version\": \"0.9.1\",\n  \"description\": \"Metacognitive advisor that monitors Claude Code and provides feedback\",\n  \"author\": {\n    \"name\": \"Cloud Atlas AI\",\n    \"email\": \"hello@cloudatlas.ai\",\n    \"url\": \"https://github.com/cloud-atlas-ai\"\n  },\n  \"repository\": \"https://github.com/cloud-atlas-ai/superego\"\n}\n",
        ".claude-plugin/plugins/superego/agents/code.md": "---\ndescription: Metacognitive review of software development work. Use when writing code, reviewing PRs, or making architectural decisions.\nmodel: inherit\n---\n\n# Code Reviewer\n\nYou are a **metacognitive advisor** for coding work. You provide real-time observations and suggestions to help maintain alignment, focus, and proportionality.\n\nYour default posture is **\"yes, and...\"**—affirm what's working, then add perspective. You're a colleague who engages and suggests, not a gatekeeper.\n\nYou're invisible when things are on track. When you surface, bring alternatives and observations.\n\n---\n\n## What to Watch For\n\n### Intent Clarity\n- Is the goal clear? Can you state it in one sentence?\n- Is this solving a real problem or a hypothetical one?\n- Watch for X-Y problems: implementing solution Y when the real need is X\n\n### User Intent Sovereignty\n**HARD RULE**: Never tell the agent to skip a task the user explicitly requested.\n- You may question the approach, not override the goal\n- Skills/commands from the user are sovereign\n- **Context gathering and operational state are legitimate work**, not ceremony. Examples: `/dive-prep`, wm dives, `.wm/` writes, Open Horizons context gathering\n\n### Five Checks\n1. **Necessary?** - Solving a real need vs. future flexibility or premature optimization\n2. **Beyond the Nearest Peak?** - Were alternatives explored or is this the first solution defended?\n3. **Sufficient?** - Would a simpler approach work? Is this more complex than needed?\n4. **Fits Goal?** - Staying on the critical path vs. drifting to tangents\n5. **Open Horizons** - Aligning with long-term goals vs. optimizing only for right now\n\n### Other Signals\n- **Motion vs Learning** - Is there a feedback loop? How will we know if this works?\n  - **Grounding** (reduces uncertainty) ≠ **Ceremony** (artifacts without insight)\n  - Context gathering, .wm/, dive prep = legitimate grounding, not ceremony\n- **Mechanism Clarity** - Can the approach be explained simply? Is the \"why\" clear?\n- **Change Completeness** - Are all ripple effects handled? (initialization, persistence, consumers)\n- **Available Capabilities** - Could existing tools/MCPs/plugins handle this better?\n- **WIP Management** - Too many things in flight? Context switching killing momentum?\n\n---\n\n## How to Respond\n\nBe conversational and specific:\n\n**Good:**\n> \"This looks like it's converging on the first solution. Have you considered [alternative approach]? It might be simpler because [reason].\"\n\n> \"I notice this adds flexibility for future use cases. Is that needed now, or could we solve just the current problem?\"\n\n> \"The goal was X, but this seems to be drifting toward Y. Is that intentional?\"\n\n**Avoid:**\n- Formal ALLOW/BLOCK decisions (you're advising, not blocking)\n- Vague concerns without specifics\n- Judging rather than collaborating\n\n**Gather evidence first:**\n- Check `git diff` to see actual changes\n- Read relevant files\n- Understand the full context before commenting\n\n**Remember:** You're here to help maintain clarity and focus, not to police. When in doubt, ask questions rather than assert problems.\n",
        ".claude-plugin/plugins/superego/agents/learning.md": "---\ndescription: Learning coach reviewing teaching approaches. Use when an AI is helping someone learn or understand concepts, to ensure teaching is hands-on and verifiable.\nmodel: inherit\n---\n\n# Learning Coach\n\nYou are a **learning coach** reviewing how AI assistants teach. You provide real-time observations to ensure teaching is hands-on, verifiable, and builds real skills.\n\n**Important:** You're not the tutor—you're coaching the AI that's tutoring. Your role is to ensure the teaching approach will actually help the learner develop skills, not just consume information.\n\nYour default posture is **\"yes, and...\"**—affirm what's working, then add perspective. But when teaching clearly won't stick (purely abstract, unverifiable, missing scaffolding), be direct about it.\n\nYou're invisible when teaching is on track. When you surface, bring specific alternatives and clear observations.\n\n---\n\n## What to Watch For\n\n### Learning Goal Clarity\n- What skill is being built? (Not just: what question was asked?)\n- What's the learner's current context (setup, level, what they've tried)?\n- Is this a real learning need or a hypothetical question?\n- Watch for X-Y in learning: asking for fact Y when they need skill/framework X\n- Watch for \"how\" questions masking \"why\" confusion (e.g., \"How do I use async?\" without understanding why async is needed)\n\n### Five Checks\n1. **Hands-On vs Abstract?** - Can this be learned by DOING rather than just understanding?\n2. **Verifiable through Experience?** - Can they test/verify this in their own context? (Inverse Gell-Mann amnesia)\n3. **Framework vs Facts?** - Are they learning a mental model they can run with, or just getting a fish?\n4. **Metis vs Techne?** - Is contextual wisdom being stated as universal truth?\n5. **Scaffolding?** - Building on what they know, or leaving gaps?\n\n### Core Principle: Doing > Understanding\n- Hands-on, sensory engagement beats abstract explanation\n- Every time.\n\n---\n\n## Key Patterns to Watch\n\n### Engagement Spectrum\n- **RED**: Pure explanation, no practice - \"Here's how it works...\"\n- **YELLOW**: Exercise offered but optional - \"You could try...\"\n- **GREEN**: Exercise-first - \"Run this command. What do you observe?\"\n\n### Good Teaching Examples\n- Not: \"Soundstage is the spatial presentation of instruments\"\n- But: \"Listen to track X at 2:15 with YOUR setup. Notice where the guitar sits. Now compare to track Y.\"\n\n### Verification\n- Good: \"Try this command with your data and observe...\"\n- Good: \"You said you're using React—test this in your codebase...\"\n- Bad: \"Studies show...\" with no path to verification\n- Bad: Generic advice not connected to their reality\n\n### Metis vs Techne\n- **BLOCK metis as universal**: \"You should always...\", \"Best practices are...\" without context\n- **Flag techne without verification**: \"TCP handshake is three packets\" → add \"You can see this by running tcpdump...\"\n\n### Scaffolding Red Flags\n- Jargon without translation\n- Skipped steps that \"everyone knows\"\n- Abstractions before concrete examples\n- Forward references without payoff (\"you'll need this later\" without showing why now)\n\n---\n\n## How to Respond\n\nBe direct and specific. Your feedback matters—teaching that won't stick needs to be flagged clearly.\n\n**Good:**\n> \"This is all explanation. Have them DO something. Try: Run [specific command with their setup] and observe [what to look for].\"\n\n> \"They can't verify this claim. Connect it to their context: [specific way to test].\"\n\n> \"This is teaching the answer, not the framework. What's the mental model they can use for similar problems?\"\n\n> \"That's contextual advice stated as universal. Explain the trade-offs: when this applies vs. when it doesn't.\"\n\n**Avoid:**\n- Vague concerns without specifics\n- Judging rather than collaborating\n- Being too tentative when teaching is clearly problematic\n\n**When to push back hard:**\n- Purely abstract when hands-on is possible\n- Unverifiable claims disconnected from learner's context\n- Metis stated as universal truth\n- Missing scaffolding that will leave them lost\n\n### Watch For Hallucination Risk\n- Confident claims without verification path\n- Better to say \"I'm not certain about X. Let's test it...\" than to be confidently wrong\n\n### Push for Real Engagement\n- Not: \"Does this make sense?\"\n- But: \"Run this and tell me what you see\"\n\n---\n\n## Remember\n\nLearning ≠ Understanding. Learning = Can apply in their own context.\n\nIf they can't do it, test it, or verify it in their situation—they haven't learned it yet, they've just heard about it.\n\n**Coach's Wisdom:** Show, don't tell. Better yet: have them do, then reflect. Explanation without practice is performance, not teaching.\n",
        ".claude-plugin/plugins/superego/agents/writing.md": "---\ndescription: Collaborative review of written content. Use when drafting blog posts, documentation, essays, or other written material.\nmodel: inherit\n---\n\n# Writing Reviewer\n\nYou are a **co-author reviewer** for writing work. You provide real-time observations and suggestions to help ensure content resonates, carries clarity, and serves the reader.\n\nYour default posture is **\"yes, and...\"**—affirm what's working, then add perspective. You're a colleague who engages and suggests, not an editor who judges.\n\nYou're invisible when writing is on track. When you surface, bring alternatives and observations.\n\n---\n\n## What to Watch For\n\n### Audience Clarity\n- Who is this for? Can you name the specific reader?\n- What do they care about?\n- Is this solving a real problem for them or writing for the writer?\n\n### Five Checks\n1. **Worth the Read?** - Solving a real problem vs. adding to the noise\n2. **Beyond the First Framing?** - Were alternative angles explored or is this the first framing defended?\n3. **Clear Enough?** - Would a simpler expression work? Less clever, more clear?\n4. **Fits the Goal?** - Serving the reader vs. drifting to tangents\n5. **Open Horizons** - Building toward something larger vs. optimizing for clicks/engagement\n\n### Resonance Signals\n- **Will it stick?** - Can someone repeat the core idea tomorrow?\n- **Carry-forward** - Does the reader leave with something they can DO, not just KNOW?\n- **Resonance devices** - Story, analogy, vivid comparison?\n- **Voice** - Authentically the writer, or performing \"thought leader\"?\n\n### Other Signals\n- **Curse of knowledge** - Jargon without translation, skipped \"obvious\" steps\n- **Connect, then lead** - Earned the right to go deep, or jumping straight to technical?\n- **Bottom line up front** - Main point clear early, or buried?\n- **Numbers need context** - Statistics relatable, or just impressive?\n\n---\n\n## How to Respond\n\nBe conversational and specific:\n\n**Good:**\n> \"The main point feels buried. Consider leading with [core takeaway] in the first paragraph.\"\n\n> \"This assumes the reader knows [X]. Since your audience is [Y], consider adding a quick translation: [example].\"\n\n> \"I'm not seeing a concrete example yet. The concept is clear, but what does this look like in practice?\"\n\n**Avoid:**\n- Formal ALLOW/BLOCK decisions (you're advising, not blocking)\n- Vague concerns without specifics\n- Editing grammar/style unless it affects clarity\n\n**Gather evidence first:**\n- Who is the stated audience?\n- What's the claimed goal?\n- Does the content actually serve that reader?\n\n**Remember:** You're here to help the writing land with readers, not to police style. When in doubt, ask questions rather than assert problems.\n",
        ".claude-plugin/plugins/superego/commands/disable.md": "# Disable Superego\n\nTemporarily disable superego evaluation for this session.\n\nTell the user: \"Superego feedback is now disabled for this session. Use /superego:enable to re-enable.\"\n\nNote: The `.superego/` configuration remains intact. This only affects the current session.\n",
        ".claude-plugin/plugins/superego/commands/enable.md": "# Enable Superego\n\nEnable superego for this project/session.\n\n## Check project state first:\n\n1. **If `.superego/` doesn't exist**: Offer to initialize - \"Superego isn't set up for this project yet. Would you like to initialize it?\" Then follow the init flow (check for binary, install if needed, run `sg init`).\n\n2. **If `.superego/` exists but was disabled**: Re-enable evaluation. Tell user: \"Superego feedback is now enabled. Evaluation will resume.\"\n\n3. **If already enabled**: Confirm it's active: \"Superego is already enabled and monitoring this session.\"\n\nBe concise. Check state and act accordingly.\n",
        ".claude-plugin/plugins/superego/commands/init.md": "# Initialize Superego\n\nInitialize superego for this project.\n\n## Step 1: Check current state\n- Check if `.superego/` already exists - if so, tell user it's already initialized and show status\n- Check if `sg` binary is available (`command -v sg`) - if yes, skip to Step 3\n\n## Step 2: Install sg binary\n\n**Detect available package managers:**\n- Homebrew: `command -v brew`\n- Cargo: `command -v cargo` OR `test -f ~/.cargo/bin/cargo`\n\n**Offer installation based on what's available:**\n\nIf **Homebrew** available (preferred for macOS):\n```bash\nbrew install cloud-atlas-ai/superego/superego\n```\n\nIf **Cargo** available:\n```bash\ncargo install superego\n# or if cargo not in PATH:\n~/.cargo/bin/cargo install superego\n```\n\nIf **neither available**, offer to install a package manager:\n- **Install Homebrew** (recommended for macOS):\n  ```bash\n  /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n  ```\n  Then: `brew install cloud-atlas-ai/superego/superego`\n\n- **Install Rust** (cross-platform):\n  ```bash\n  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n  ```\n  Then restart shell and: `cargo install superego`\n\n**For local development** (if user specifies a path):\n```bash\ncargo install --path /path/to/superego\n# or: ~/.cargo/bin/cargo install --path /path/to/superego\n```\n\n## Step 3: Initialize project\nAfter `sg` binary is available, run:\n```bash\nsg init\n```\n\n## Step 4: Confirm\nTell user superego is now initialized and active for this project. It will monitor your work and provide feedback when needed (before large changes, at natural stopping points, etc.).\n\n---\nBe concise. Detect what's available, offer appropriate options, guide user through setup.\n",
        ".claude-plugin/plugins/superego/commands/prompt.md": "# Superego Prompt Management\n\nManage superego prompts for this project. Available actions:\n\n## Usage\n\n- `/superego-prompt` or `/superego-prompt list` — List available prompts\n- `/superego-prompt switch <name>` — Switch to a different prompt (code, writing, learning)\n- `/superego-prompt show` — Show current prompt info\n\n## Actions\n\n### List (default)\n\nRun `sg prompt list` to show available prompts with the current one marked.\n\n### Switch\n\nWhen the user specifies a prompt name (e.g., `/superego-prompt switch writing`):\n\n1. Run `sg prompt switch <name>` to switch prompts\n2. Report the result (backed up customizations, restored from backup, or fresh install)\n3. Remind user that the new prompt will take effect on next evaluation\n\n### Show\n\nRun `sg prompt show` to display:\n- Current prompt type and description\n- Whether it has local modifications\n- Available backups from other prompt types\n\n## Notes\n\n- The `code` prompt is for coding/development work (default)\n- The `writing` prompt is for content creation, writing, and editing\n- The `learning` prompt is for reviewing teaching/tutoring approaches - ensures learning is hands-on and verifiable\n- Customizations are preserved: switching backs up your changes and restores them when you switch back\n- If `.superego/` doesn't exist, suggest running `/superego-init` first\n",
        ".claude-plugin/plugins/superego/commands/remove.md": "# Remove Superego\n\nRemove superego from this project (inverse of init).\n\n1. Check if `.superego/` exists - if not, tell user \"Superego isn't initialized in this project.\"\n\n2. **Ask for confirmation**: \"This will delete the .superego/ directory including your custom prompt and configuration. Continue?\"\n\n3. If confirmed, remove the `.superego/` directory:\n   ```bash\n   rm -rf .superego/\n   ```\n\n4. Confirm: \"Superego removed from this project. The plugin remains installed for other projects.\"\n\n**Note**: This only removes the project configuration. The `sg` binary and plugin remain installed system-wide.\n",
        ".claude-plugin/plugins/superego/commands/review.md": "# Superego Review\n\nOn-demand review of changes using the current superego prompt.\n\n## Usage\n\n- `/superego:review` — Review staged changes (falls back to uncommitted if nothing staged)\n- `/superego:review staged` — Review only staged changes\n- `/superego:review pr` — Review PR diff vs base branch\n- `/superego:review <file>` — Review changes in a specific file\n\n## How It Works\n\n1. Run `sg review [target]` to invoke the review\n2. Superego uses the current prompt (code or writing) to evaluate the changes\n3. Returns constructive feedback (advisory, not blocking)\n\n## Examples\n\n```bash\n# Review what you're about to commit\nsg review\n\n# Review your entire PR before requesting review\nsg review pr\n\n# Review changes to a specific file\nsg review src/main.rs\n```\n\n## Notes\n\n- Uses the currently active prompt (`sg prompt show` to check)\n- For writing projects, switch to writing prompt first: `sg prompt switch writing`\n- This is advisory feedback, not a blocking hook\n",
        ".claude-plugin/plugins/superego/commands/status.md": "# Superego Status\n\nCheck superego status for this project. Report:\n\n1. **Plugin**: Installed (you're running this command)\n2. **Binary**: Check if `sg` binary is available (`command -v sg` and `sg --version`)\n3. **Project**: Check if `.superego/` directory exists in current project\n4. **Hooks**: If both binary and .superego/ exist, hooks are active\n\nProvide a brief status summary. If something is missing, suggest the fix.\n",
        ".claude-plugin/plugins/superego/hooks/hooks.json": "{\n  \"description\": \"Superego metacognitive evaluation hooks\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/session-start.sh\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/evaluate.sh\"\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/pre-tool-use.sh\"\n          }\n        ]\n      }\n    ],\n    \"PermissionRequest\": [\n      {\n        \"matcher\": \"ExitPlanMode\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/evaluate.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        ".claude-plugin/plugins/superego/scripts/evaluate.sh": "#!/bin/bash\n# Superego evaluation hook\n# Used by: Stop (after response), ExitPlanMode permission request\n#\n# AIDEV-NOTE: For Stop hooks, if concerns found and not already blocked once,\n# returns {\"decision\":\"block\",\"reason\":\"...\"} so Claude sees feedback and continues.\n\n# Check for sg binary\nif ! command -v sg &> /dev/null; then\n    echo \"sg binary not found. Install: cargo install superego\" >&2\n    exit 0\nfi\n\n# Use CLAUDE_PROJECT_DIR if available, otherwise current directory\nPROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-.}\"\n\n# Debug log function\nlog() {\n    echo \"[$(date '+%H:%M:%S')] [evaluate] $1\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>/dev/null\n}\n\n# Read hook input from stdin\nINPUT=$(cat)\n\n# Skip if superego is disabled\nif [ \"$SUPEREGO_DISABLED\" = \"1\" ]; then\n    log \"SKIP: SUPEREGO_DISABLED=1\"\n    exit 0\nfi\n\n# Check if superego is initialized\nif [ ! -d \"$PROJECT_DIR/.superego\" ]; then\n    exit 0  # No log - .superego doesn't exist\nfi\n\n# Skip if in pull mode (user calls sg review manually)\nMODE=$(sg mode 2>/dev/null || echo \"always\")\nif [ \"$MODE\" = \"pull\" ]; then\n    log \"SKIP: pull mode (use sg review manually)\"\n    exit 0\nfi\n\nlog \"Hook fired\"\n\n# Check if stop hook already active (prevent infinite loop)\nSTOP_HOOK_ACTIVE=$(echo \"$INPUT\" | jq -r '.stop_hook_active // false')\nif [ \"$STOP_HOOK_ACTIVE\" = \"true\" ]; then\n    log \"SKIP: stop_hook_active=true (already blocked once)\"\n    exit 0\nfi\n\n# Extract transcript path and session ID from hook input\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path // .transcriptPath // \"\"')\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id // \"\"')\n\n# Skip if no transcript path\nif [ -z \"$TRANSCRIPT_PATH\" ] || [ \"$TRANSCRIPT_PATH\" = \"null\" ]; then\n    log \"SKIP: No transcript path\"\n    exit 0\nfi\n\n# Build session-namespaced paths\nif [ -n \"$SESSION_ID\" ] && [ \"$SESSION_ID\" != \"null\" ]; then\n    SESSION_DIR=\"$PROJECT_DIR/.superego/sessions/$SESSION_ID\"\n    mkdir -p \"$SESSION_DIR\"\n    FEEDBACK_PATH=\"$SESSION_DIR/feedback\"\nelse\n    FEEDBACK_PATH=\"$PROJECT_DIR/.superego/feedback\"\nfi\n\n# Skip if this is superego's own transcript (recursion prevention)\nif [[ \"$TRANSCRIPT_PATH\" == *\"/.superego/\"* ]] || [[ \"$TRANSCRIPT_PATH\" == \".superego/\"* ]]; then\n    log \"SKIP: Superego transcript (recursion prevention)\"\n    exit 0\nfi\n\n# Run LLM evaluation (redirect all output to log)\n# Atomic lock to prevent duplicate evaluations\nif [ -n \"$SESSION_ID\" ] && [ \"$SESSION_ID\" != \"null\" ]; then\n    LOCK_FILE=\"$SESSION_DIR/eval.lock\"\nelse\n    LOCK_FILE=\"$PROJECT_DIR/.superego/eval.lock\"\nfi\n\nif mkdir \"$LOCK_FILE\" 2>/dev/null; then\n    # Got lock, run evaluation\n    trap 'rmdir \"$LOCK_FILE\" 2>/dev/null' EXIT\n    if [ -n \"$SESSION_ID\" ] && [ \"$SESSION_ID\" != \"null\" ]; then\n        log \"Running: sg evaluate-llm --session-id $SESSION_ID\"\n        sg evaluate-llm --transcript-path \"$TRANSCRIPT_PATH\" --session-id \"$SESSION_ID\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>&1\n    else\n        log \"Running: sg evaluate-llm (no session_id)\"\n        sg evaluate-llm --transcript-path \"$TRANSCRIPT_PATH\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>&1\n    fi\n    EXIT_CODE=$?\n    rmdir \"$LOCK_FILE\" 2>/dev/null\nelse\n    log \"Eval already in progress, skipping\"\n    exit 0\nfi\n\nif [ $EXIT_CODE -ne 0 ]; then\n    log \"ERROR: sg evaluate-llm failed with code $EXIT_CODE\"\n    exit 0\nfi\n\nlog \"Evaluation complete\"\n\n# Check if there's feedback to deliver (file exists and non-empty)\n# Use atomic move to prevent race conditions with concurrent hooks\nif [ -s \"$FEEDBACK_PATH\" ]; then\n    TEMP_FEEDBACK=\"$FEEDBACK_PATH.$$\"\n    if ! mv \"$FEEDBACK_PATH\" \"$TEMP_FEEDBACK\" 2>/dev/null; then\n        log \"Feedback already claimed by another hook\"\n        exit 0\n    fi\n    FEEDBACK=$(cat \"$TEMP_FEEDBACK\")\n    log \"Blocking with feedback: ${FEEDBACK:0:100}...\"\n    rm -f \"$TEMP_FEEDBACK\"\n\n    # Build properly escaped JSON using jq\n    REASON=\"SUPEREGO FEEDBACK: Please critically evaluate this feedback. If you agree, incorporate it. If you disagree on non-trivial points, escalate to the user.\n\n$FEEDBACK\"\n\n    # Output block decision - Claude will see the reason and continue\n    OUTPUT=$(jq -n --arg reason \"$REASON\" '{\"decision\":\"block\",\"reason\":$reason}')\n    log \"Outputting: $OUTPUT\"\n    echo \"$OUTPUT\"\n    exit 1\nfi\n\n# No concerns, allow\nexit 0\n",
        ".claude-plugin/plugins/superego/scripts/pre-tool-use.sh": "#!/bin/bash\n# PreToolUse hook for superego\n#\n# TRIGGERS EVALUATION ON:\n# - LARGE EDIT/WRITE - Edit/Write >= threshold lines (default: 20)\n#\n# This hook only fires on significant code changes, not arbitrary intervals.\n# For pull-based evaluation, use `sg review` at decision points instead.\n\n# Check for sg binary\nif ! command -v sg &> /dev/null; then\n    echo \"sg binary not found. Install: cargo install superego\" >&2\n    exit 0\nfi\n\n# Use CLAUDE_PROJECT_DIR if available, otherwise current directory\nPROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-.}\"\n\n# Log function\nlog() {\n    echo \"[$(date '+%H:%M:%S')] [pre-tool] $1\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>/dev/null\n}\n\n# Read hook input from stdin\nINPUT=$(cat)\n\n# Skip if superego is disabled\nif [ \"$SUPEREGO_DISABLED\" = \"1\" ]; then\n    exit 0\nfi\n\n# Check if superego is initialized\nif [ ! -d \"$PROJECT_DIR/.superego\" ]; then\n    exit 0\nfi\n\n# Extract common fields\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name // \"\"')\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id // \"\"')\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path // .transcriptPath // \"\"')\n\n# Build session-namespaced paths\nif [ -n \"$SESSION_ID\" ] && [ \"$SESSION_ID\" != \"null\" ]; then\n    SESSION_DIR=\"$PROJECT_DIR/.superego/sessions/$SESSION_ID\"\n    mkdir -p \"$SESSION_DIR\"\nelse\n    SESSION_DIR=\"$PROJECT_DIR/.superego\"\n    SESSION_ID=\"\"\nfi\nFEEDBACK_PATH=\"$SESSION_DIR/feedback\"\nPENDING_CHANGE_PATH=\"$SESSION_DIR/pending_change.txt\"\nLOCK_FILE=\"$SESSION_DIR/eval.lock\"\n\n# Skip if no transcript\nif [ -z \"$TRANSCRIPT_PATH\" ] || [ \"$TRANSCRIPT_PATH\" = \"null\" ]; then\n    exit 0\nfi\n\n# Skip if in pull mode (user calls sg review manually)\nMODE=$(sg mode 2>/dev/null || echo \"always\")\nif [ \"$MODE\" = \"pull\" ]; then\n    exit 0\nfi\n\n# ===========================================================================\n# HELPER: Run evaluation and handle feedback\n# ===========================================================================\nrun_eval() {\n    local trigger_reason=\"$1\"\n\n    # Atomic lock to prevent duplicate evaluations\n    if ! mkdir \"$LOCK_FILE\" 2>/dev/null; then\n        log \"Eval already in progress, skipping\"\n        exit 0\n    fi\n    trap 'rmdir \"$LOCK_FILE\" 2>/dev/null' EXIT\n\n    log \"Running eval (trigger: $trigger_reason)\"\n    if [ -n \"$SESSION_ID\" ]; then\n        sg evaluate-llm --transcript-path \"$TRANSCRIPT_PATH\" --session-id \"$SESSION_ID\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>&1\n    else\n        sg evaluate-llm --transcript-path \"$TRANSCRIPT_PATH\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>&1\n    fi\n    local exit_code=$?\n    rmdir \"$LOCK_FILE\" 2>/dev/null\n    trap - EXIT\n\n    # Cleanup pending change\n    rm -f \"$PENDING_CHANGE_PATH\"\n\n    if [ $exit_code -ne 0 ]; then\n        log \"ERROR: sg evaluate-llm failed with code $exit_code\"\n        exit 0\n    fi\n\n    log \"Evaluation complete\"\n\n    # Check for feedback (atomic move)\n    if [ -s \"$FEEDBACK_PATH\" ]; then\n        local temp_feedback=\"$FEEDBACK_PATH.$$\"\n        if mv \"$FEEDBACK_PATH\" \"$temp_feedback\" 2>/dev/null; then\n            local feedback\n            feedback=$(cat \"$temp_feedback\")\n            rm -f \"$temp_feedback\"\n            log \"Blocking with feedback: ${feedback:0:100}...\"\n\n            local reason=\"SUPEREGO FEEDBACK ($trigger_reason):\n\n$feedback\n\nPlease reconsider or explain why it's appropriate.\"\n\n            jq -n --arg reason \"$reason\" '{\"decision\":\"block\",\"reason\":$reason}'\n            exit 1\n        fi\n    fi\n\n    # No concerns - allow\n    exit 0\n}\n\n# ===========================================================================\n# HELPER: Build pending change context for Edit/Write\n# ===========================================================================\nbuild_pending_change() {\n    local file_path\n    file_path=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // \"\"')\n\n    if [ \"$TOOL_NAME\" = \"Edit\" ]; then\n        local old_string new_string old_lines new_lines\n        old_string=$(echo \"$INPUT\" | jq -r '.tool_input.old_string // \"\"')\n        new_string=$(echo \"$INPUT\" | jq -r '.tool_input.new_string // \"\"')\n        old_lines=$(echo \"$old_string\" | wc -l | tr -d ' ')\n        new_lines=$(echo \"$new_string\" | wc -l | tr -d ' ')\n\n        echo \"PROPOSED EDIT to $file_path:\n--- OLD ($old_lines lines) ---\n$old_string\n--- NEW ($new_lines lines) ---\n$new_string\"\n    elif [ \"$TOOL_NAME\" = \"Write\" ]; then\n        local content content_lines\n        content=$(echo \"$INPUT\" | jq -r '.tool_input.content // \"\"')\n        content_lines=$(echo \"$content\" | wc -l | tr -d ' ')\n\n        if [ \"$content_lines\" -gt 100 ]; then\n            local preview\n            preview=$(echo \"$content\" | head -100)\n            echo \"PROPOSED WRITE to $file_path ($content_lines lines, first 100 shown):\n$preview\n...\"\n        else\n            echo \"PROPOSED WRITE to $file_path:\n$content\"\n        fi\n    fi\n}\n\n# ===========================================================================\n# LARGE EDIT/WRITE CHECK (size >= threshold)\n# ===========================================================================\nif [ \"$TOOL_NAME\" = \"Edit\" ] || [ \"$TOOL_NAME\" = \"Write\" ]; then\n    # Calculate change size\n    if [ \"$TOOL_NAME\" = \"Edit\" ]; then\n        OLD_LINES=$(echo \"$INPUT\" | jq -r '.tool_input.old_string // \"\"' | wc -l | tr -d ' ')\n        NEW_LINES=$(echo \"$INPUT\" | jq -r '.tool_input.new_string // \"\"' | wc -l | tr -d ' ')\n        CHANGE_SIZE=$((NEW_LINES > OLD_LINES ? NEW_LINES : OLD_LINES))\n    else\n        CHANGE_SIZE=$(echo \"$INPUT\" | jq -r '.tool_input.content // \"\"' | wc -l | tr -d ' ')\n    fi\n\n    THRESHOLD=${SUPEREGO_CHANGE_THRESHOLD:-20}\n\n    if [ \"$CHANGE_SIZE\" -ge \"$THRESHOLD\" ]; then\n        log \"Large $TOOL_NAME ($CHANGE_SIZE >= $THRESHOLD lines)\"\n        build_pending_change > \"$PENDING_CHANGE_PATH\"\n        run_eval \"large $TOOL_NAME\"\n        # run_eval exits, won't reach here\n    fi\nfi\n\n# ===========================================================================\n# NOT A LARGE CHANGE - ALLOW\n# ===========================================================================\nexit 0\n",
        ".claude-plugin/plugins/superego/scripts/session-start.sh": "#!/bin/bash\nset -u  # Exit on undefined variables\n# SessionStart hook for superego\n# Handles three scenarios:\n# 1. .superego/ exists + binary present → inject full contract\n# 2. .superego/ exists + binary missing → offer to install binary\n# 3. .superego/ doesn't exist → offer to initialize superego\n#\n# AIDEV-NOTE: Uses additionalContext to inject context into Claude's session.\n\n# Skip entirely if superego is disabled\nif [ \"${SUPEREGO_DISABLED:-}\" = \"1\" ]; then\n    exit 0\nfi\n\n# Use CLAUDE_PROJECT_DIR if available, otherwise current directory\nPROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-.}\"\n\n# Validate PROJECT_DIR exists and is a directory\nif [ ! -d \"$PROJECT_DIR\" ]; then\n    exit 0\nfi\n\n# SCENARIO 3: .superego/ doesn't exist - offer to initialize\nif [ ! -d \"$PROJECT_DIR/.superego\" ]; then\n    cat << 'EOFINNER'\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"SUPEREGO AVAILABLE: The superego plugin is installed but not initialized for this project. Superego is a metacognitive advisor that monitors your work and provides feedback before you finish. To enable it, ask the user if they want to initialize superego. If yes, create a .superego/ directory with: mkdir -p .superego && printf '# Superego Prompt\\\\n\\\\nEvaluate the conversation for scope drift, missing error handling, incomplete implementations, or approaches that don\\\\'t align with project conventions.\\\\n' > .superego/prompt.md && echo '{}' > .superego/state.json\"\n  }\n}\nEOFINNER\n    exit 0\nfi\n\n# Fetch latest prompt from GitHub (silent, non-blocking)\n# Updates .superego/prompt.md if fetch succeeds, otherwise keeps existing\nPROMPT_URL=\"https://raw.githubusercontent.com/cloud-atlas-ai/superego/main/default_prompt.md\"\nPROMPT_PATH=\"$PROJECT_DIR/.superego/prompt.md\"\ncurl -sS --max-time 5 \"$PROMPT_URL\" -o \"$PROMPT_PATH.tmp\" 2>/dev/null && \\\n    mv \"$PROMPT_PATH.tmp\" \"$PROMPT_PATH\" 2>/dev/null || \\\n    rm -f \"$PROMPT_PATH.tmp\" 2>/dev/null\n\n# .superego/ exists - log session start\necho \"[$(date '+%H:%M:%S')] [session] Session started\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>/dev/null\n\n# Clean up stale pending_change.txt files from previous sessions\n# These can persist if a session crashes mid-evaluation, causing \"phantom edit\" warnings\nrm -f \"$PROJECT_DIR/.superego/pending_change.txt\" 2>/dev/null\nfind \"$PROJECT_DIR/.superego/sessions\" -name \"pending_change.txt\" -delete 2>/dev/null\n\n# SCENARIO 2: .superego/ exists but binary missing - offer to install\nif ! command -v sg &> /dev/null; then\n    echo \"[$(date '+%H:%M:%S')] [session] sg binary not found - requesting install\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>/dev/null\n    cat << 'EOFINNER'\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"SUPEREGO SETUP REQUIRED: The superego plugin is active (.superego/ exists) but the 'sg' binary is missing. The binary is needed for LLM-based evaluation. Install options: 'brew install cloud-atlas-ai/superego/superego' (macOS, ~10s) or 'cargo install superego' (cross-platform, ~30s, requires Rust). Ask the user which they prefer, or if they want to skip superego this session.\"\n  }\n}\nEOFINNER\n    exit 0\nfi\n\n# SCENARIO 1: Everything present - check mode and inject appropriate context\nMODE=$(sg mode 2>/dev/null || echo \"always\")\necho \"[$(date '+%H:%M:%S')] [session] Mode: $MODE\" >> \"$PROJECT_DIR/.superego/hook.log\" 2>/dev/null\n\nif [ \"$MODE\" = \"pull\" ]; then\n    # Pull mode: Claude decides when to evaluate using `sg review`\n    cat << 'EOFINNER'\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"SUPEREGO AVAILABLE (pull mode): This project has superego for metacognitive oversight. Use `sg review` at decision points:\\n- Before committing to a plan or approach\\n- When choosing between alternatives\\n- Before non-trivial implementations\\n- When the task feels complex or uncertain\\n- Before claiming work is done\\n\\nSuperego catches strategic mistakes (wrong approach, over-engineering, scope creep). Call it when you need a second opinion, not automatically.\"\n  }\n}\nEOFINNER\nelse\n    # Always mode: automatic evaluation at checkpoints\n    cat << 'EOFINNER'\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"SUPEREGO ACTIVE: This project uses superego, a metacognitive advisor that monitors your work. When you receive SUPEREGO FEEDBACK, critically evaluate it: if you agree, incorporate it into your approach; if you disagree on non-trivial feedback, escalate to the user explaining both perspectives. Superego feedback reflects concerns about your reasoning, approach, or alignment with the user's goals - it deserves serious consideration, not just acknowledgment.\"\n  }\n}\nEOFINNER\nfi\n",
        ".claude-plugin/plugins/wm/.claude-plugin/plugin.json": "{\n  \"name\": \"wm\",\n  \"version\": \"0.3.3\",\n  \"description\": \"Working memory for AI coding assistants - surfaces relevant context based on intent\",\n  \"author\": {\n    \"name\": \"Cloud Atlas AI\",\n    \"email\": \"hello@cloudatlas.ai\",\n    \"url\": \"https://github.com/cloud-atlas-ai\"\n  },\n  \"repository\": \"https://github.com/cloud-atlas-ai/wm\"\n}\n",
        ".claude-plugin/plugins/wm/agents/compress.md": "---\ndescription: Compress and synthesize state.md by abstracting to higher-level patterns\nmodel: inherit\n---\n\n# Compress Knowledge\n\nSynthesize accumulated knowledge in `state.md` to higher-level abstractions, reducing size while preserving critical insights.\n\n**Platform Support:**\n- ✅ **Claude Code** - Full support\n- ✅ **Codex** - Full support (platform-independent)\n\n## When to Use\n\n- **State.md is growing unwieldy** — Too many specific items, hard to navigate\n- **After distillation** — Batch extraction added many items that need synthesis\n- **Periodic maintenance** — Every few weeks/months as knowledge accumulates\n- **Before sharing** — Clean up state before committing to repo or sharing with team\n\n## What It Does\n\n1. **Reads state.md** — Analyzes all accumulated knowledge\n2. **Identifies patterns** — Finds related items that can be merged\n3. **Abstracts specifics** — Converts concrete instances into general principles\n4. **Removes obsolete items** — Discards superseded or no-longer-relevant knowledge\n5. **Preserves critical constraints** — Keeps important guardrails and preferences\n6. **Creates backup** — Saves original to `.wm/state.md.backup` before modifying\n\n## Usage\n\n```bash\n# Compress state.md\nwm compress\n\n# Example output:\n# Compressed: 42 → 18 lines (57% reduction)\n# Backup saved to .wm/state.md.backup\n```\n\n## Compression Strategies\n\nThe LLM applies these strategies when compressing:\n\n### 1. Merge Related Items\n**Before:**\n```markdown\n- Prefer `Result<T, E>` for recoverable errors in Rust\n- Use `Option<T>` for nullable values in Rust\n- Return early with `?` operator in Rust\n```\n\n**After:**\n```markdown\n- Rust error handling: Use `Result<T, E>` for recoverable errors, `Option<T>` for nullables, early return with `?` operator\n```\n\n### 2. Abstract to Principles\n**Before:**\n```markdown\n- Don't use `unwrap()` in production code\n- Don't use `expect()` without clear reason\n- Don't ignore error cases\n```\n\n**After:**\n```markdown\n- Error handling principle: Always handle errors explicitly; never panic in production\n```\n\n### 3. Remove Obsolete\n**Before:**\n```markdown\n- Use old API version 1.x (deprecated)\n- Migrate to API version 2.x (in progress)\n- API 3.x is now stable and preferred\n```\n\n**After:**\n```markdown\n- Use API version 3.x (current stable)\n```\n\n### 4. Preserve Critical Constraints\nThese are NEVER compressed away:\n- Security constraints (e.g., \"never log passwords\")\n- Architecture decisions (e.g., \"use event sourcing for audit trail\")\n- User preferences (e.g., \"prefer functional style over OOP\")\n\n## Integration with Distill\n\nCompress works well after distillation:\n\n```bash\n# 1. Batch extract from all sessions\nwm distill\n\n# 2. Review raw extractions\ncat .wm/distill/raw_extractions.md\n\n# 3. Compress both raw extractions and state.md\nwm compress\n\n# Result: synthesized knowledge in state.md\n```\n\n## Recovery\n\nIf compression removes something important:\n\n```bash\n# Restore from backup\ncp .wm/state.md.backup .wm/state.md\n\n# Or manually cherry-pick from backup\ncat .wm/state.md.backup  # Review what was removed\n```\n\nBackups are timestamped, so multiple compressions create multiple backups.\n\n## Best Practices\n\n- **Review after compression**: Check that critical knowledge wasn't lost\n- **Run periodically**: Don't wait until state.md is massive (harder to compress effectively)\n- **Manual curation first**: Remove obviously obsolete items manually before compressing\n- **Backup awareness**: Know that `.wm/state.md.backup` exists for recovery\n\n## When NOT to Use\n\n- **State.md is small** — No need to compress if it's under ~30-40 lines\n- **Just started wm** — Let knowledge accumulate first before compressing\n- **Uncertain about contents** — Review state.md manually before running automated compression\n",
        ".claude-plugin/plugins/wm/agents/distill.md": "---\ndescription: Batch extract tacit knowledge from all sessions in this project\nmodel: inherit\n---\n\n# Distill Knowledge\n\nExtract tacit knowledge from all sessions at once, instead of relying on per-turn extraction.\n\n**Platform Support:**\n- ✅ **Claude Code** - Full support (auto-discovers sessions)\n- ⚠️ **Codex** - Manual mode only (requires explicit transcript paths)\n\nIn Codex, you'll need to provide transcript paths manually since auto-discovery isn't yet implemented.\n\n## When to Use\n\n- **Project onboarding**: Extract knowledge from existing sessions when first setting up wm\n- **Catchup after pause**: Process sessions that weren't extracted due to pause or missing hooks\n- **Audit existing knowledge**: Review what patterns exist across all past work\n- **Migration**: Moving from another system and want to bootstrap knowledge\n\n## What It Does\n\n**In Claude Code:**\n1. **Discovers sessions** — Finds all transcripts in `~/.claude/projects/<project>/`\n2. **Extracts incrementally** — Uses cache to only process new/changed sessions\n3. **Accumulates knowledge** — Writes raw extractions to `.wm/distill/raw_extractions.md`\n4. **Preserves existing state** — Doesn't overwrite `.wm/state.md` automatically\n\n**In Codex (manual mode):**\n1. Guide user to find transcripts in `~/.codex/sessions/YYYY/MM/DD/`\n2. Extract from specific transcript: `wm extract --transcript <path>`\n3. Repeat for multiple sessions\n4. Review `.wm/distill/raw_extractions.md`\n\n## Usage\n\n**Claude Code (automatic):**\n```bash\n# Standard distillation (process new/changed sessions only)\nwm distill\n\n# Preview what would be processed\nwm distill --dry-run\n\n# Re-extract everything (ignores cache)\nwm distill --force\n```\n\n**Codex (manual):**\n```bash\n# Find transcripts\nls ~/.codex/sessions/2026/01/*/rollout-*.jsonl\n\n# Extract from specific sessions\nwm extract --transcript ~/.codex/sessions/2026/01/06/rollout-2026-01-06T10-30-00-<uuid>.jsonl\nwm extract --transcript ~/.codex/sessions/2026/01/05/rollout-2026-01-05T14-15-00-<uuid>.jsonl\n\n# Review accumulated extractions\ncat .wm/state.md\n```\n\n## Output Structure\n\n```\n.wm/distill/\n├── raw_extractions.md    # All extracted knowledge (chronological)\n├── cache.json            # Extraction cache (session ID → last processed)\n└── errors.log            # Any extraction failures\n```\n\n## After Distillation\n\nReview the raw extractions and decide what to do:\n\n1. **Review raw_extractions.md** — See what knowledge was found\n2. **Curate to state.md** — Manually copy relevant items to `.wm/state.md`, or run `wm compress` to auto-synthesize\n3. **Compress if needed** — If state.md grows large, run `wm compress` to synthesize to higher abstractions\n\n## Integration Notes\n\n- **Complementary to per-turn extraction**: Distill catches what hooks missed, but hooks are still the primary mechanism\n- **Idempotent**: Running multiple times is safe (uses cache)\n- **Session isolation**: Each session's extraction is independent\n\n## Example Workflow\n\n```bash\n# 1. Initialize wm in existing project\ncd /your/project\nwm init\n\n# 2. Run distillation\nwm distill\n\n# 3. Review what was found\ncat .wm/distill/raw_extractions.md\n\n# 4. Check if anything worth adding to state\nwm show state\n\n# 5. If raw extractions have value, manually curate or compress\n# Manual: copy relevant items from raw_extractions.md → state.md\n# Auto: wm compress (synthesizes both files)\n```\n\n## When NOT to Use\n\n- **Active sessions**: Distill is for batch processing, not real-time extraction\n- **Every session**: Only run when you need catchup or audit—not after every conversation\n- **As primary mechanism**: Hooks provide better per-turn extraction; distill is backup/catchup\n",
        ".claude-plugin/plugins/wm/agents/dive-prep.md": "---\ndescription: Prepare a grounded dive session with context from multiple sources\nmodel: inherit\n---\n\n# Dive Prep\n\nCompile a session grounding manifest from available context sources, keyed by intent.\n\n**Platform Support:**\n- ✅ **Claude Code** - Full support\n- ✅ **Codex** - Full support (platform-independent context gathering)\n\n## Named Dive Preps\n\nWM supports multiple named dive preps (like git branches). Use the CLI to manage them:\n\n```bash\nwm dive list              # List all preps (* marks current)\nwm dive new <name>        # Create new prep\nwm dive switch <name>     # Switch to a prep\nwm dive delete <name>     # Delete a prep\nwm dive save <name>       # Save current dive_context.md as named prep\nwm dive current           # Show current prep name\nwm dive show [name]       # Show prep content\n```\n\nWhen `/dive-prep` creates a manifest, you can save it as a named prep:\n1. Run `/dive-prep` to generate context\n2. Run `wm dive save my-feature` to save and activate it\n\nNamed preps are stored in `.wm/dives/{name}.md` and the current prep is tracked in `config.toml`.\n\n## Invocation\n\n`/dive-prep [--intent <type>] [options]`\n\n**Intent types:** `fix`, `plan`, `review`, `explore`, `ship` (default: `explore`)\n\n**Options:**\n- `--oh <endeavor-id>` - Include Open Horizons context for this endeavor\n- `--issue <id>` - Include issue/ticket context (GitHub, Linear, etc.)\n- `--files <glob>` - Include specific files as context\n- `--no-local` - Skip local context detection\n\n## Context Sources\n\nA dive can pull grounding context from multiple sources:\n\n| Source | What it provides | When used |\n|--------|------------------|-----------|\n| **Local** | CLAUDE.md, .superego/, cwd structure | Always (auto-detected) |\n| **Git** | Branch, recent commits, changed files | Always (auto-detected) |\n| **OH** | Endeavors, guardrails, metis, mission context | **Preferred** when connected |\n| **Issue** | Ticket details, acceptance criteria | If --issue provided |\n| **Files** | Specific code/docs for focus | If --files provided |\n\n**OH is the preferred source** when available because it's purpose-built for strategic alignment. It provides the \"why\" (mission context), the \"don't\" (guardrails), and the \"learned\" (metis) that local context alone can't provide.\n\n## Flow\n\n### Step 0: Detect OH Connection\n\nCheck if OH MCP is available by testing `oh_get_contexts`:\n\n- **If connected**: OH becomes the preferred context source\n- **If not connected**: Continue with local-only flow\n\nWhen OH is available but no `--oh` flag provided, prompt:\n```\nOH connected. Link to an endeavor for strategic context?\n[Select endeavor] [Skip - local only]\n```\n\nThis encourages OH usage when available since it's purpose-built for strategic alignment.\n\n### Step 1: Determine Intent\n\nIf not provided via `--intent`, ask:\n\n```\nWhat's your intent for this session?\n[ ] fix - Fix a bug or issue\n[ ] plan - Design an approach\n[ ] review - Reflect on recent work\n[ ] explore - Understand something\n[ ] ship - Get something deployed\n```\n\n### Step 2: Gather Local Context\n\nAlways gather from current directory:\n\n1. **CLAUDE.md** - Project instructions and patterns\n2. **.superego/** - Metacognitive config if present\n3. **Git state** - Current branch, uncommitted changes, recent commits\n4. **Directory structure** - Top-level layout for orientation\n\n### Step 3: Gather Optional Sources\n\n**If OH connected and --oh provided:**\n```\noh_suggest_dive_pack({\n  endeavor_id: \"<endeavor-id>\",\n  intent_type: \"<intent>\"\n})\n```\nReturns: mission context, guardrails, metis, related endeavors\n\n**If --issue provided:**\n- Fetch issue details from configured tracker\n- Extract: title, description, acceptance criteria, labels\n\n**If --files provided:**\n- Read specified files\n- Summarize key sections for context\n\n### Step 4: Present for Curation\n\nShow gathered context, let user confirm in <30s:\n\n```\nDive Context Summary\n====================\n\nIntent: fix\n\nLocal:\n  ✓ CLAUDE.md (project instructions)\n  ✓ .superego/ (metacognitive config)\n  ✓ Branch: feature/dive-packs (3 uncommitted files)\n\nOH Context (optional):\n  ✓ Endeavor: Dive Prep feature\n  ✓ Mission: Open Horizons System\n  ✓ Guardrails: 2 active\n  [ ] Include metis: \"Contracts prevent drift\"\n  [ ] Include sibling: MetisCandidate capture\n\nWorkflow: fix-workflow\n  Stage → sg review → handle findings → commit → PR\n\n[Accept] [Edit] [Cancel]\n```\n\n### Step 5: Build Workflow\n\nBased on intent, include appropriate workflow:\n\n**fix:**\n```\n1. Understand the issue\n2. Write failing test (if applicable)\n3. Implement fix\n4. Stage changes\n5. Run `sg review` - handle findings (P1-P3 fix, P4 discard)\n6. Commit with clear message\n7. PR → CodeRabbit review → iterate\n8. Done when PR approved\n```\n\n**plan:**\n```\n1. Review available context (local docs, OH mission if available)\n2. Identify options and trade-offs\n3. Draft plan with concrete steps (no time estimates)\n4. Surface risks and dependencies\n5. Document decision rationale\n6. Log findings (to OH if connected, else local)\n```\n\n**review:**\n```\n1. Gather recent work artifacts (commits, logs)\n2. Identify patterns, learnings, surprises\n3. Surface insights worth capturing\n4. Document review findings\n```\n\n**explore:**\n```\n1. Understand the problem space\n2. Read relevant code/docs\n3. Ask clarifying questions\n4. Document findings\n5. Identify next steps or blockers\n```\n\n**ship:**\n```\n1. Verify all tests pass\n2. Check constraints and guardrails\n3. Review changes for completeness\n4. Create PR with full context\n5. Address review feedback\n6. Deploy when approved\n```\n\n### Step 6: Write Session Manifest\n\nWrite `.wm/dive_context.md` with curated grounding:\n\n```markdown\n# Dive Session\n\n**Intent:** fix\n**Started:** 2026-01-03T10:30:00Z\n\n## Context\n\n### Project\n[From CLAUDE.md - key instructions]\n\n### Focus\n[What we're working on - from OH endeavor, issue, or user input]\n\n### Constraints\n[From OH guardrails, .superego/, or user input]\n\n### Relevant Knowledge\n[From OH metis, or key patterns noted]\n\n## Workflow\n[Selected workflow steps]\n\n## Sources\n- Local: CLAUDE.md, .superego/\n- Git: feature/dive-packs branch\n- OH: endeavor bd9d6ace (if connected)\n```\n\n### Step 7: Confirm\n\n```\n✓ Dive session prepared\n\nContext loaded to .wm/dive_context.md\nIntent: fix\nWorkflow: fix-workflow\n\nReady to work. Start with: [first workflow step]\n```\n\n## Without OH\n\nIf OH is not configured:\n\n1. Ask: \"What are you working on?\" (free text)\n2. Ask: \"What's your intent?\" (if not provided)\n3. Ask: \"Any constraints to keep in mind?\"\n4. Build manifest from local context + user answers\n5. Write `.wm/dive_context.md`\n6. **Suggest OH setup**: \"For richer strategic context (missions, guardrails, learnings), set up Open Horizons: `claude mcp add oh-mcp -- npx -y @cloud-atlas-ai/oh-mcp-server`\"\n\nThis still provides value: explicit intent, workflow guidance, and documented constraints. But OH adds the strategic layer that makes dives more grounded.\n\n## Exit Conditions\n\n- **Success**: Manifest written, user sees confirmation\n- **Cancel**: User cancels, no changes\n- **Error**: Report issue, suggest manual context setup\n\n## Examples\n\n**With OH context:**\n```\n$ /dive-prep --intent fix --oh bd9d6ace\n\nGathering context...\n  ✓ Local: CLAUDE.md, .superego/\n  ✓ Git: feature/dive-packs (3 uncommitted)\n  ✓ OH: Dive Prep feature → Open Horizons System\n\n[Shows curation UI]\n\n✓ Dive session prepared\n  .wm/dive_context.md written\n  Intent: fix\n  Ready to work.\n```\n\n**Local only:**\n```\n$ /dive-prep --intent explore\n\nGathering context...\n  ✓ Local: CLAUDE.md\n  ✓ Git: main (clean)\n\nWhat are you exploring?\n> How the authentication flow works\n\n✓ Dive session prepared\n  .wm/dive_context.md written\n  Intent: explore\n  Focus: How the authentication flow works\n```\n\n**With issue:**\n```\n$ /dive-prep --intent fix --issue GH-123\n\nGathering context...\n  ✓ Local: CLAUDE.md\n  ✓ Git: fix/auth-bug\n  ✓ Issue: GH-123 \"Login fails with special characters\"\n\n✓ Dive session prepared\n  Intent: fix\n  Focus: Login fails with special characters (GH-123)\n```\n",
        ".claude-plugin/plugins/wm/agents/pause.md": "---\ndescription: Pause or resume wm operations (extract, compile, or both)\nmodel: inherit\n---\n\n# Pause and Resume\n\nTemporarily disable wm operations without uninstalling or removing configuration.\n\n**Platform Support:**\n- ✅ **Claude Code** - Full support (hooks respect pause state)\n- ✅ **Codex** - Full support (manual extractions respect pause state)\n\n## When to Use\n\n### Pause Extract\n- **Sensitive work**: Working on confidential code that shouldn't be extracted\n- **Personal debugging**: Troubleshooting without knowledge capture\n- **Temporary privacy**: Preventing certain conversations from being recorded\n\n### Pause Compile\n- **Simple tasks**: Skip context injection for trivial work (faster, lower cost)\n- **Testing isolation**: Want to work without historical context\n- **Debugging wm**: Isolate issues by disabling injection\n\n### Pause Both\n- **Extended break**: Disabling wm entirely for a period\n- **Project handoff**: Pausing before transferring to someone else\n- **Performance testing**: Measuring impact of wm on session speed/cost\n\n## Usage\n\n```bash\n# Pause both operations\nwm pause\n\n# Pause only extraction\nwm pause extract\n\n# Pause only compilation\nwm pause compile\n\n# Resume both operations\nwm resume\n\n# Resume only extraction\nwm resume extract\n\n# Resume only compilation\nwm resume compile\n\n# Check current status\nwm status\n```\n\n## How It Works\n\nPause/resume modifies `.wm/pause_state.json`:\n\n```json\n{\n  \"extract_paused\": false,\n  \"compile_paused\": false\n}\n```\n\n**Hook behavior when paused:**\n- **Extract paused**: Stop hook gracefully exits without extraction\n- **Compile paused**: UserPromptSubmit hook returns empty context\n\nNo configuration files are modified. No data is lost. Just a flag.\n\n## Status Check\n\n```bash\nwm status\n```\n\n**Active (normal):**\n```\nWorking Memory Status\n=====================\n\nExtract:  active\nCompile:  active\n\nAll operations running normally.\n```\n\n**Paused:**\n```\nWorking Memory Status\n=====================\n\nExtract:  PAUSED\nCompile:  active\n\nExtract is paused. Run 'wm resume extract' to re-enable.\n```\n\n## Common Scenarios\n\n### Scenario 1: Sensitive Code Review\n\n```bash\n# Working on security-critical code\nwm pause extract\n\n# Work on sensitive changes\n# ... conversation happens ...\n\n# Done with sensitive work\nwm resume extract\n```\n\n### Scenario 2: Quick Fix Without Context\n\n```bash\n# Need fast fix, don't need historical context\nwm pause compile\n\n# Make quick change\n# ... conversation is faster, no context injected ...\n\n# Resume normal operation\nwm resume compile\n```\n\n### Scenario 3: Complete Pause\n\n```bash\n# Taking break from project\nwm pause\n\n# ... time passes ...\n\n# Resuming project work\nwm resume\n```\n\n## Integration with Other Operations\n\n### Pause + Distill\n\nIf you paused extract for a while and missed knowledge capture:\n\n```bash\n# Check status\nwm status\n# Extract: PAUSED (for last 2 weeks)\n\n# Resume\nwm resume extract\n\n# Catch up with batch extraction\nwm distill\n```\n\n### Pause + Dive Prep\n\nDive prep works even if compile is paused:\n\n```bash\n# Compile is paused\nwm status\n# Compile: PAUSED\n\n# Dive prep still gathers context\n/dive-prep --intent fix\n\n# Creates .wm/dive_context.md (independent of pause state)\n```\n\n## State Persistence\n\nPause state persists across:\n- Sessions (stays paused in new Claude Code sessions)\n- Restarts (survives Claude Code restart)\n- Directory changes (tied to project `.wm/` directory)\n\nTo fully reset:\n```bash\nrm .wm/pause_state.json\n# Operations resume automatically\n```\n\n## Best Practices\n\n- **Default to active**: Only pause when you have a specific reason\n- **Resume after sensitive work**: Don't forget to resume when done\n- **Check status regularly**: Run `wm status` if unsure\n- **Document reasons**: If pausing long-term, note why (in .wm/README or similar)\n\n## Agent Usage\n\nAs an agent, you might invoke pause/resume when:\n- User mentions working on sensitive/confidential code → suggest `wm pause extract`\n- User asks for faster responses on trivial task → suggest `wm pause compile`\n- User is debugging wm behavior → suggest isolating with pause\n- User finished sensitive work → remind to `wm resume`\n\n**Example dialogue:**\n\nUser: \"I need to work on some confidential API keys, don't want this captured\"\n\nAgent: \"I'll pause wm extraction so this session isn't recorded.\"\n```bash\nwm pause extract\n```\n\n[... work on sensitive code ...]\n\nAgent: \"Done with the confidential work. Resuming wm extraction.\"\n```bash\nwm resume extract\n```\n",
        ".claude-plugin/plugins/wm/agents/review.md": "---\ndescription: Review current working memory state and context\nmodel: inherit\n---\n\n# Review Working Memory\n\nUnderstand what knowledge wm has captured and what context is currently active.\n\n**Platform Support:**\n- ✅ **Claude Code** - Full support (session discovery works)\n- ✅ **Codex** - Partial support (state/working set work, session listing limited)\n\n## When to Use\n\n- **Session start** — Review what patterns and constraints wm knows about this project\n- **Before major changes** — Check if existing knowledge suggests an approach\n- **Debugging unexpected behavior** — See if wm is injecting context that's affecting decisions\n- **After distillation** — Verify what knowledge was extracted\n- **Planning work** — Understand project patterns before designing solution\n\n## What to Review\n\n### 1. Current State (`wm show state`)\n\nView all accumulated tacit knowledge:\n\n```bash\nwm show state\n```\n\n**What you'll see:**\n- Rationale behind past decisions\n- Constraints discovered through work\n- Preferences revealed by corrections\n- Patterns followed in this project\n- Paths rejected and why\n\nThis is the \"long-term memory\" — knowledge accumulated across all sessions.\n\n### 2. Active Context (`wm show working`)\n\nView what context was last injected:\n\n```bash\nwm show working                      # Global working set\nwm show working --session-id <id>   # Session-specific working set\n```\n\n**What you'll see:**\n- Filtered subset of state.md relevant to last intent\n- What context Claude received on last turn\n- Useful for debugging: \"Why is Claude suggesting X?\"\n\nThis is the \"short-term memory\" — what's active in current context.\n\n### 3. All Sessions (`wm show sessions`)\n\n**Claude Code only:**\n\nList all sessions for this project:\n\n```bash\nwm show sessions\n```\n\n**What you'll see:**\n- Session IDs and timestamps\n- Transcript locations\n- Useful for running distillation or reviewing history\n\n**Note:** In Codex, session listing requires manual discovery:\n```bash\nls ~/.codex/sessions/2026/01/*/rollout-*.jsonl\n```\n\n### 4. Dive Context (`wm dive show`)\n\nView current dive session context (if active):\n\n```bash\nwm dive show\n```\n\n**What you'll see:**\n- Intent (fix, plan, explore, review, ship)\n- Focus (what specifically you're working on)\n- Constraints from guardrails or .superego/\n- Workflow steps for this intent\n- Context sources (local, git, OH, etc.)\n\n## Example Workflow\n\n```bash\n# Starting new work - review what wm knows\nwm show state\n\n# Output shows:\n# - \"Prefer functional composition over inheritance\"\n# - \"API calls require retry logic (flaky network)\"\n# - \"Use snake_case for file names in this project\"\n\n# Now you understand the project patterns before coding\n```\n\n## Integration with Other Commands\n\n### Review → Distill\n```bash\n# Check current state\nwm show state\n\n# Seems sparse - run distillation\nwm distill\n\n# Review again\nwm show state\n```\n\n### Review → Compress\n```bash\n# Check state size\nwm show state | wc -l\n# Output: 87 lines\n\n# Too large - compress\nwm compress\n\n# Review result\nwm show state | wc -l\n# Output: 34 lines\n```\n\n### Review → Dive Prep\n```bash\n# Review project knowledge\nwm show state\n\n# Now prepare focused dive with that context in mind\n/dive-prep --intent fix\n```\n\n## Understanding State vs Working Set\n\n**State.md** (Long-term Memory):\n- All accumulated knowledge\n- May contain items not relevant to current task\n- Read with: `wm show state`\n\n**Working Set** (Short-term Memory):\n- Filtered for current intent\n- Only relevant items injected to Claude\n- Read with: `wm show working`\n\n**Example:**\n\nIf `state.md` contains:\n```markdown\n- Prefer functional style over OOP\n- API calls need retry logic\n- Use PostgreSQL for persistence\n- Frontend uses React hooks pattern\n```\n\nAnd your intent is \"implement API retry logic\", then `working_set.md` might contain:\n```markdown\n- API calls need retry logic\n- Prefer functional style over OOP\n```\n\nThe PostgreSQL and React items weren't relevant to the intent, so they weren't injected.\n\n## Pause Status\n\nCheck if wm operations are paused:\n\n```bash\nwm status\n```\n\n**Output:**\n```\nWorking Memory Status\n=====================\n\nExtract:  active\nCompile:  active\n\nAll operations running normally.\n```\n\nOr if paused:\n```\nExtract:  PAUSED\nCompile:  active\n\nExtract is paused. Run 'wm resume extract' to re-enable.\n```\n\n## When to Use Each Command\n\n| Command | When to Use |\n|---------|-------------|\n| `wm show state` | Understand accumulated project knowledge |\n| `wm show working` | Debug what context was injected |\n| `wm show sessions` | Find sessions for distillation or audit |\n| `wm dive show` | Review current dive context |\n| `wm status` | Check if operations are paused |\n\n## Agent Usage\n\nAs an agent, invoke this skill when you need to:\n- Understand project patterns before suggesting approach\n- Debug why certain context is appearing\n- Verify knowledge was captured after distillation\n- Check if dive context is active\n",
        ".claude-plugin/plugins/wm/commands/compress.md": "# /wm:compress\n\nCompress and synthesize working memory state.\n\n## Usage\n\n```\n/wm:compress\n```\n\n## Execution\n\nRun the wm compress command:\n\n```bash\nwm compress\n```\n\nPass through the output. This abstracts accumulated knowledge to higher-level patterns, reducing size while preserving critical insights.\n",
        ".claude-plugin/plugins/wm/commands/distill.md": "# /wm:distill\n\nExtract tacit knowledge from recent work into working memory.\n\n## Usage\n\n```\n/wm:distill\n```\n\n## Execution\n\nRun the wm distill command:\n\n```bash\nwm distill\n```\n\nPass through the output. This extracts learnings from recent sessions and adds them to `.wm/state.md`.\n",
        ".claude-plugin/plugins/wm/commands/dive-prep.md": "# /wm:dive-prep\n\nPrepare working memory context for a focused session.\n\n## Usage\n\n```\n/wm:dive-prep [intent or context]\n```\n\n## Execution\n\nThis command uses the `wm:dive-prep` Task agent to gather context from multiple sources and write `.wm/dive_context.md`.\n\n**Do NOT run a CLI command.** Instead, invoke the Task tool:\n\n```\nTask(subagent_type: \"wm:dive-prep\", prompt: \"<user's intent or context>\")\n```\n\nIf the user provides a GitHub issue URL, include it in the prompt:\n```\nTask(subagent_type: \"wm:dive-prep\", prompt: \"Prepare dive for https://github.com/org/repo/issues/123\")\n```\n\nThe agent will:\n1. Detect OH connection and suggest linking endeavors\n2. Gather local context (CLAUDE.md, git state, etc.)\n3. Fetch OH context if available\n4. Write `.wm/dive_context.md` with curated grounding\n\nPass through the agent's output to the user.\n",
        ".claude-plugin/plugins/wm/commands/init.md": "# /wm:init\n\nInitialize working memory in the current project.\n\n## Usage\n\n```\n/wm:init\n```\n\n## Execution\n\n1. Check if wm binary exists:\n   ```bash\n   command -v wm\n   ```\n\n2. If wm not found, tell the user to install it:\n   ```\n   The wm CLI is not installed.\n\n   Install with Homebrew:\n     brew install open-horizon-labs/homebrew-tap/wm\n\n   Or with Cargo:\n     cargo install working-memory\n\n   Then run this command again.\n   ```\n\n3. If wm exists, run:\n   ```bash\n   wm init\n   ```\n\n   This creates `.wm/` directory with initial state.\n",
        ".claude-plugin/plugins/wm/commands/pause.md": "# /wm:pause\n\nPause wm operations (extract, compile, or both).\n\n## Usage\n\n```\n/wm:pause [extract|compile]\n```\n\n## Execution\n\nRun the wm pause command:\n\n```bash\nwm pause              # Pause both extract and compile\nwm pause extract      # Pause only extract\nwm pause compile      # Pause only compile\n```\n\nTo resume operations later:\n\n```bash\nwm resume             # Resume both\nwm resume extract     # Resume only extract\nwm resume compile     # Resume only compile\n```\n\nCheck current status with:\n\n```bash\nwm status\n```\n\nPass through the output to the user.\n",
        ".claude-plugin/plugins/wm/commands/review.md": "# /wm:review\n\nReview current working memory state and context.\n\n## Usage\n\n```\n/wm:review [state|working|sessions]\n```\n\n## Execution\n\nUse the `wm show` command to display working memory contents:\n\n```bash\nwm show state      # Show .wm/state.md\nwm show working    # Show compiled working set\nwm show sessions   # List available sessions\n```\n\nWithout arguments, show the state:\n\n```bash\nwm show\n```\n\nFor a comprehensive review, you can also:\n1. Show distilled knowledge: `cat .wm/distill/guardrails.md .wm/distill/metis.md`\n2. Show dive context: `cat .wm/dive_context.md`\n\nPass through the output to the user.\n",
        ".claude-plugin/plugins/wm/hooks/hooks.json": "{\n  \"description\": \"Working memory context injection hooks\",\n  \"hooks\": {\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/compile.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        ".claude-plugin/plugins/wm/scripts/compile.sh": "#!/bin/bash\n# UserPromptSubmit hook for wm\n# Surfaces relevant working memory context for the current intent\n#\n# AIDEV-NOTE: Uses additionalContext to inject relevant knowledge into Claude's context.\n# Never blocks - returns empty response on any failure.\n\n# Skip if wm is disabled\nif [ \"${WM_DISABLED:-}\" = \"1\" ]; then\n    exit 0\nfi\n\n# Use CLAUDE_PROJECT_DIR if available, otherwise current directory\nPROJECT_DIR=\"${CLAUDE_PROJECT_DIR:-.}\"\n\n# Skip if not initialized (no .wm directory)\nif [ ! -d \"$PROJECT_DIR/.wm\" ]; then\n    exit 0\nfi\n\n# Skip if wm binary not available\nif ! command -v wm &> /dev/null; then\n    exit 0\nfi\n\n# Capture stdin (JSON from Claude Code)\nINPUT=$(cat)\n\n# Extract session_id from hook input\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id // \"\"')\n\n# session_id is required\nif [ -z \"$SESSION_ID\" ]; then\n    exit 0\nfi\n\n# Change to project directory for wm to find .wm/\ncd \"$PROJECT_DIR\" || exit 0\n\n# Run wm hook compile with session_id, piping stdin for intent\necho \"$INPUT\" | wm hook compile --session-id \"$SESSION_ID\" 2>/dev/null || exit 0\n",
        ".claude-plugin/plugins/wm/skills/dive-prep/SKILL.md": "---\nname: dive-prep\ndescription: Prepare a grounded dive session with context from multiple sources\n---\n\n# Dive Prep\n\nPrepare working memory context for a focused session by gathering context from multiple sources.\n\n## Invocation\n\n`/wm:dive-prep [intent or context]`\n\n## Execution\n\n**DO NOT run any bash command.** This skill requires an AI agent.\n\nUse the Task tool to spawn the wm:dive-prep agent:\n\n```\nTask(subagent_type: \"wm:dive-prep\", prompt: \"<user's intent or context>\")\n```\n\nIf the user provides a GitHub issue URL, include it in the prompt:\n```\nTask(subagent_type: \"wm:dive-prep\", prompt: \"Prepare dive for https://github.com/org/repo/issues/123\")\n```\n\n## What the Agent Does\n\n1. Detect OH connection and suggest linking endeavors\n2. Gather local context (CLAUDE.md, git state, etc.)\n3. Fetch OH context if available\n4. Write `.wm/dive_context.md` with curated grounding\n\n## Output\n\nPass through the agent's output to the user. The dive context will be saved to `.wm/dive_context.md`.\n\n## Example\n\n```\nUser: /wm:dive-prep fix the auth bug in the login flow\n\nAction: Task(subagent_type: \"wm:dive-prep\", prompt: \"fix the auth bug in the login flow\")\n```\n"
      },
      "plugins": [
        {
          "name": "bottle",
          "source": "./.claude-plugin",
          "description": "Unified installer and orchestrator for Open Horizon Labs stack",
          "author": {
            "name": "Open Horizon Labs"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add open-horizon-labs/bottle",
            "/plugin install bottle@open-horizon-labs"
          ]
        },
        {
          "name": "ba",
          "source": "./.claude-plugin/plugins/ba",
          "description": "Task tracking for AI sessions",
          "author": {
            "name": "Open Horizon Labs"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add open-horizon-labs/bottle",
            "/plugin install ba@open-horizon-labs"
          ]
        },
        {
          "name": "wm",
          "source": "./.claude-plugin/plugins/wm",
          "description": "Working memory - automatic tacit knowledge extraction",
          "author": {
            "name": "Open Horizon Labs"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add open-horizon-labs/bottle",
            "/plugin install wm@open-horizon-labs"
          ]
        },
        {
          "name": "superego",
          "source": "./.claude-plugin/plugins/superego",
          "description": "Metacognitive advisor",
          "author": {
            "name": "Open Horizon Labs"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add open-horizon-labs/bottle",
            "/plugin install superego@open-horizon-labs"
          ]
        },
        {
          "name": "oh-mcp",
          "source": "./.claude-plugin/plugins/oh-mcp",
          "description": "Open Horizons MCP server for strategic alignment",
          "author": {
            "name": "Open Horizon Labs"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add open-horizon-labs/bottle",
            "/plugin install oh-mcp@open-horizon-labs"
          ]
        },
        {
          "name": "miranda",
          "source": "./.claude-plugin/plugins/miranda",
          "description": "Telegram bot for remote orchestration",
          "author": {
            "name": "Open Horizon Labs"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add open-horizon-labs/bottle",
            "/plugin install miranda@open-horizon-labs"
          ]
        }
      ]
    }
  ]
}