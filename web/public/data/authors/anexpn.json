{
  "author": {
    "id": "anexpn",
    "display_name": "Jun",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/23271612?u=cf9c1dc4198afa7fa5424e54f61caba33fa5d072&v=4",
    "url": "https://github.com/anexpn",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 5,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "jun-workflows",
      "version": null,
      "description": "Jun's development workflow commands and skills for Claude Code",
      "owner_info": {
        "name": "Jun",
        "url": "https://github.com/anexpn"
      },
      "keywords": [],
      "repo_full_name": "anexpn/claude-plugins",
      "repo_url": "https://github.com/anexpn/claude-plugins",
      "repo_description": "Jun's development workflow commands and skills for Claude Code",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-01T10:17:48Z",
        "created_at": "2025-10-24T19:55:41Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 463
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 230
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1025
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/explore.md",
          "type": "blob",
          "size": 1153
        },
        {
          "path": "commands/refresh.md",
          "type": "blob",
          "size": 1193
        },
        {
          "path": "commands/tour.md",
          "type": "blob",
          "size": 8018
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto/SKILL.md",
          "type": "blob",
          "size": 8057
        },
        {
          "path": "skills/dev-auto/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto/references/phase-impl.md",
          "type": "blob",
          "size": 6023
        },
        {
          "path": "skills/dev-auto/references/phase-plan.md",
          "type": "blob",
          "size": 6871
        },
        {
          "path": "skills/dev-auto/references/phase-review.md",
          "type": "blob",
          "size": 7734
        },
        {
          "path": "skills/dev-auto/references/phase-spec.md",
          "type": "blob",
          "size": 4035
        },
        {
          "path": "skills/dev-auto/references/phase-tasks.md",
          "type": "blob",
          "size": 4818
        },
        {
          "path": "skills/dev-auto/references/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-auto/references/templates/subagent-impl.md",
          "type": "blob",
          "size": 1315
        },
        {
          "path": "skills/dev-auto/references/templates/subagent-plan.md",
          "type": "blob",
          "size": 1186
        },
        {
          "path": "skills/dev-auto/references/templates/subagent-tasks.md",
          "type": "blob",
          "size": 831
        },
        {
          "path": "skills/dev-guided",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-guided/SKILL.md",
          "type": "blob",
          "size": 9452
        },
        {
          "path": "skills/dev-guided/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-guided/references/implementation-session.md",
          "type": "blob",
          "size": 2823
        },
        {
          "path": "skills/dev-guided/references/initial-setup.md",
          "type": "blob",
          "size": 2736
        },
        {
          "path": "skills/dev-guided/references/template-decisions.md",
          "type": "blob",
          "size": 1550
        },
        {
          "path": "skills/dev-guided/references/template-problem_statement.md",
          "type": "blob",
          "size": 687
        },
        {
          "path": "skills/dev-guided/references/template-progress.md",
          "type": "blob",
          "size": 862
        },
        {
          "path": "skills/dev-guided/references/template-runbook.md",
          "type": "blob",
          "size": 1986
        },
        {
          "path": "skills/nb-notes",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nb-notes/SKILL.md",
          "type": "blob",
          "size": 6523
        },
        {
          "path": "skills/nb-notes/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nb-notes/references/nb_commands.md",
          "type": "blob",
          "size": 2613
        },
        {
          "path": "skills/session-learner",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/session-learner/SKILL.md",
          "type": "blob",
          "size": 3323
        },
        {
          "path": "skills/systematic-debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/systematic-debugging/SKILL.md",
          "type": "blob",
          "size": 5453
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"jun-workflows\",\n  \"owner\": {\n    \"name\": \"Jun\",\n    \"url\": \"https://github.com/anexpn\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"jun-dev-workflows\",\n      \"source\": \"./\",\n      \"description\": \"Jun's development workflow commands and skills for Claude Code\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Jun\"\n      },\n      \"keywords\": [\"workflow\", \"tdd\", \"git\", \"debugging\", \"development\"],\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"jun-dev-workflows\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Jun's development workflow commands and skills for Claude Code\",\n  \"author\": {\n    \"name\": \"Jun\"\n  },\n  \"commands\": \"./commands/\",\n  \"skills\": \"./skills/\"\n}\n",
        "README.md": "# Jun's Claude Code Plugin\n\nDevelopment workflow commands and skills for Claude Code.\n\n## Contents\n\n### Commands\n- `/explore` - Explore the codebase systematically\n- `/refresh` - Refresh understanding of project structure\n- `/tour` - Guided tour of the codebase\n\n### Skills\n- `dev-workflow` - Complete development workflow from spec to implementation to review\n- `dev-spec` - Design and planning session for development work\n- `dev-impl` - Execute implementation of tasks from a development plan\n- `dev-review` - Review and validate implementation work\n- `git-workflow` - Version control workflow and best practices\n- `systematic-debugging` - Structured debugging methodology\n- `tdd` - Test-Driven Development workflow\n\n## Installation\n\n### From GitHub (Recommended)\n```\n/plugin install anexpn/claude-plugins\n```\n\n### From Marketplace\n```\n/plugin marketplace add anexpn/claude-plugins\n/plugin install jun-dev-workflows@jun-workflows\n```\n\n### From local directory\n```\n/plugin install file:///Users/jun/code/claude-plugins\n```\n",
        "commands/explore.md": "---\nargument-hint: files | components | config | diagram | git | test\ndescription: Analyze codebase structure and dependencies for experienced developers\n---\n\n# Explore: ${ARGUMENTS:-files}\n\nAnalyze and synthesize information about the codebase for experienced developers.\n\n---\n\n## Available Aspects\n\nUse `/explore <aspect>` where aspect is one of:\n\n- **files**: Show the 10 most important files for understanding this codebase and explain why each is critical\n- **components**: Map out the dependencies between the main components - which modules depend on which others\n- **config**: Identify the key configuration files and explain what each controls\n- **diagram**: Create a detailed diagram of how the main components interact\n- **git**: Analyze the git history to show the most frequently changed files and what they suggest about the system's evolution\n- **test**: Show the testing strategy - where are tests located and how to run them\n\n---\n\n## Your Task\n\nThe user wants to explore: **${ARGUMENTS:-files}**\n\nProvide a comprehensive analysis for this aspect. Use the Explore agent (Task tool with subagent_type=Explore) for thorough investigation.\n",
        "commands/refresh.md": "---\ndescription: Reset and refocus after session drift\n---\n\n# Session Refresh\n\nThe user is asking you to reset and refocus. Long sessions can cause drift from instructions.\n\n## What to Do\n\n1. **Acknowledge the reset**:\n```\n‚úÖ Refreshed and refocused.\n```\n\n2. **Briefly state what you should be doing** based on current context:\n   - If in a tour: \"I'll suggest ONE file at a time with focused snippets, verify files exist, and wait for your input.\"\n   - If coding: \"I'll follow the project patterns, test incrementally, and commit working code.\"\n   - If investigating: \"I'll search carefully, verify findings, and report back clearly.\"\n   - If general: \"I'll follow your instructions precisely and avoid assumptions.\"\n\n3. **Ask where to continue**:\n```\nWhere should we continue from here?\n```\n\n## Core Principles to Remember\n\n- **Verify before stating**: Use tools (Glob, Read, Grep) before making claims\n- **Follow instructions**: Re-read user's request if unclear\n- **Be precise**: No hallucination, no guessing, no assumptions\n- **Stay focused**: One task at a time\n- **Wait for user**: Don't continue automatically\n\nThis reset helps you get back on track. Now proceed with renewed focus.\n",
        "commands/tour.md": "---\nargument-hint: intro | build | test | debug | [feature-name] | list\ndescription: Interactive guided tour of the codebase for newcomers\n---\n\n# Repository Tour: ${ARGUMENTS:-intro}\n\nYou are a tour guide for this codebase. The user wants to explore the **${ARGUMENTS:-intro}** thread.\n\n---\n\n## Special Commands\n\n**If session gets long and you notice me drifting**: Use `/refresh` command to reset me.\n\nThis will help me:\n- Stop hallucinating file paths\n- Remember to verify files with Glob\n- Show actual code snippets from Read\n- Get back to one-file-at-a-time mode\n\n## Tour Philosophy\n\nThis is an **interactive conversation**, not a presentation. Your role:\n\n1. **Start small**: Give ONE location to explore at a time\n2. **Point with focus**: Provide file path + specific parts to focus on + brief code snippet\n3. **Wait**: Let user explore, come back, ask questions\n4. **Respond**: Answer their questions, suggest related areas\n5. **Guide next**: Offer 2-3 options for what to explore next\n\n**CRITICAL**: For each location, you must:\n- Read the file yourself first (silently)\n- Identify the 1-3 most important parts to focus on\n- Show abbreviated snippets (3-10 lines) of those key parts\n- Explain why these parts matter\n- Let user explore the full file themselves\n\n---\n\n## Thread Types\n\n- **intro**: Project overview - start here for new repos\n- **build**: How to build, install, run\n- **test**: Testing setup and examples\n- **debug**: Debugging and logging\n- **[feature]**: Any feature name (e.g., \"auth\", \"api\", \"ui\")\n- **list**: Show available standard threads\n\n---\n\n## How to Conduct the Tour\n\n### Step 1: Quick Discovery (do this silently)\n\n**CRITICAL**: Use Glob/Grep to find files that ACTUALLY EXIST. Do NOT suggest file paths that don't exist.\n\nDiscovery strategy by thread:\n- **intro**:\n  - `fd -t f 'README' -d 1` - Find README\n  - `fd -t f 'package.json|Cargo.toml|go.mod|setup.py|pom.xml' -d 1` - Find project config\n  - `fd -t d -d 1` - List top-level directories\n  - `fd -t f '(main|index|app)\\.(js|ts|py|go|rs|java)' src lib` - Find entry points\n\n- **build**:\n  - `fd -t f 'package.json|Makefile|build|webpack|vite|rollup|tsconfig' -d 2`\n  - `fd -t f -e sh -e bash build deploy`\n\n- **test**:\n  - `fd -t d test __test__ spec -d 2` - Find test directories\n  - `fd -e test.js -e test.ts -e spec.js -e _test.go`\n  - `fd -t f 'jest|vitest|pytest|cargo' -d 2` - Test configs\n\n- **debug**:\n  - `fd -t f 'launch.json' .vscode`\n  - `fd -t f 'logger|log' src lib`\n\n- **feature**:\n  - `rg -i --files-with-matches \"feature-name\"` - Find files mentioning the feature\n  - `fd -t f -t d \"feature-name\"`\n\n**VERIFICATION**: Before suggesting ANY file path:\n1. Use Glob to verify it exists\n2. If not found, search for alternatives\n3. Only suggest files you've confirmed exist\n\n### Step 2: Read and Prepare the First Stop\n- Use Read tool to load the file\n- Identify the 1-3 key parts to focus on (functions, exports, configs, etc.)\n- Extract small snippets (3-10 lines each)\n\n### Step 3: Start the Conversation\nPresent the location WITH focused guidance:\n\n```\nWelcome to the [thread-name] tour!\n\nüìç First stop: path/to/file.ext:line-range\n\n[1 sentence about what this file does]\n\nKey things to look at:\n\n**1. [Function/Section name]** (line XX):\n```code-snippet\n// Show 3-5 relevant lines\n```\n[Why this matters in 1 sentence]\n\n**2. [Another important part]** (line YY):\n```code-snippet\n// Show 3-5 relevant lines\n```\n[Why this matters in 1 sentence]\n\nOpen the file and explore these sections. Come back when ready - what questions do you have?\n```\n\n### Step 4: Wait and Respond\n- User explores the file with your guidance\n- Answer any questions they have\n- When they're ready, offer what to explore next\n\n### Step 5: Suggest Next Steps\nOffer 2-3 concrete options:\n\n```\nWhere would you like to go next?\n\n1. path/to/another.file - [why this is interesting]\n2. path/to/different.file - [why this is interesting]\n3. Or ask me anything about what we've seen\n\nJust let me know the number or ask a question!\n```\n\n### Step 6: Continue the Conversation\n- Keep it flowing naturally\n- Let user drive the pace\n- Always read files and show focused snippets\n- Be ready to go deeper or switch topics\n- Offer to switch threads if relevant\n\n---\n\n## Example Flows\n\n### Intro Tour Start:\n```\nWelcome to the intro tour!\n\nüìç First stop: package.json\n\nThis shows what this project is and how to run it.\n\nKey things to look at:\n\n**1. Project identity** (lines 2-5):\n```json\n\"name\": \"my-app\",\n\"version\": \"1.0.0\",\n\"description\": \"A web application for...\"\n```\nThis tells you what the project does.\n\n**2. Scripts** (lines 10-15):\n```json\n\"scripts\": {\n  \"dev\": \"vite\",\n  \"build\": \"vite build\",\n  \"test\": \"vitest\"\n}\n```\nThese are the commands you'll use most often.\n\n**3. Main dependencies** (lines 20-25):\n```json\n\"dependencies\": {\n  \"react\": \"^18.0.0\",\n  \"express\": \"^4.18.0\"\n}\n```\nReact for UI, Express for backend.\n\nOpen package.json and check out these sections. What questions do you have?\n```\n\n### After User Comes Back:\n```\nGreat! Now you know the basics.\n\nWhere to next?\n\n1. src/index.js - The main entry point (I'll show you the key functions)\n2. src/server.js - Backend setup (I'll highlight the routes)\n3. README.md - More detailed docs\n\nWhich one?\n```\n\n### Build Tour Start:\n```\nLet's explore how to build this project.\n\nüìç First stop: package.json\n\nKey build commands:\n\n**Scripts section** (lines 10-18):\n```json\n\"scripts\": {\n  \"dev\": \"vite --port 3000\",          // Development server\n  \"build\": \"tsc && vite build\",        // Production build\n  \"preview\": \"vite preview\",           // Preview prod build\n  \"test\": \"vitest\"\n}\n```\n\nThe workflow: `npm run dev` for development, `npm run build` for production.\n\nOpen package.json and look at the scripts. Ready to see the actual build config?\n```\n\n### Feature Tour (dynamic):\n```\nLet's explore the authentication feature.\n\nüìç First stop: src/auth/AuthService.js:45-80\n\nThis is the core authentication logic.\n\nKey parts:\n\n**1. Login method** (lines 45-60):\n```js\nasync login(email, password) {\n  const user = await db.users.findByEmail(email);\n  const valid = await bcrypt.compare(password, user.hash);\n  if (!valid) throw new AuthError('Invalid credentials');\n  return this.createSession(user);\n}\n```\nThis handles the login flow - validates credentials and creates a session.\n\n**2. Session creation** (lines 65-75):\n```js\ncreateSession(user) {\n  const token = jwt.sign({ userId: user.id }, SECRET);\n  return { user, token };\n}\n```\nCreates a JWT token for the authenticated user.\n\nCheck out these methods. Want to see where this is called from?\n```\n\n---\n\n## Important Rules\n\n**DO**:\n- **VERIFY files exist** with Glob before suggesting them\n- **READ each file** before presenting it\n- **Show 1-3 focused snippets** (3-10 lines each) of the key parts\n- **Include line numbers** so user can navigate easily\n- Give ONE file/location at a time\n- Explain briefly WHY each snippet matters\n- Wait for user to respond\n- Answer questions thoroughly\n- Offer clear next options\n\n**DON'T**:\n- Suggest file paths without verifying they exist first\n- Give paths without reading the file and showing key snippets\n- Show more than 3 snippets per stop\n- Show snippets longer than 10 lines (abbreviate if needed)\n- Give 10 files at once\n- Move forward without user acknowledgment\n\n---\n\n---\n\n## Anti-Hallucination Checklist\n\nBefore EVERY response, verify:\n- [ ] Did I use Glob to verify the file exists?\n- [ ] Did I Read the file before showing snippets?\n- [ ] Am I showing only 1-3 snippets (3-10 lines each)?\n- [ ] Am I waiting for user instead of continuing automatically?\n- [ ] Are my line numbers accurate from the Read output?\n\nIf you notice yourself:\n- Suggesting files you haven't verified\n- Showing code you haven't read\n- Giving multiple files at once\n- Writing long explanations without snippets\n- Moving forward without user input\n\n**STOP. The user can say \"refresh\" to reset you.**\n\n---\n\n**Begin the ${ARGUMENTS:-intro} tour now. Remember: Start with ONE location, wait for user.**\n",
        "skills/dev-auto/SKILL.md": "---\nname: dev-auto\ndescription: Autonomous development workflow. Generate detailed specs, plans, and tasks for autonomous agent execution with session memory tracking.\n---\n\n# Autonomous Development Workflow\n\n## Overview\n\nGenerate comprehensive documentation that enables autonomous agents to implement features, fixes, or changes without constant human supervision. All work is tracked in session docs (spec, plan, tasks) that serve as long-term memory across implementation sessions.\n\n## When to Use This Skill\n\nUse this skill when:\n- Working on well-defined features or fixes\n- Work can be fully specified upfront\n- Implementation can proceed autonomously with minimal supervision\n- Long-term session memory is desired for tracking progress\n\n**Do NOT use for:**\n- Exploratory work requiring human decisions at each step (use dev-guided instead)\n- Trivial changes that don't require planning\n- Quick iterations where formal documentation is overhead\n\n## Workflow Phases\n\nThis workflow consists of 5 phases. Some run interactively in the main conversation (requiring user input), while others can run as autonomous subagents.\n\n### Phase 1: Specification (Interactive)\n\nGenerate a comprehensive design specification through iterative questioning.\n\n**Process:**\n1. Examine the project to understand current state\n2. Ask ONE question at a time (preferring multiple choice)\n3. Refine understanding through Q&A until certain\n4. Present specification in 200-300 word sections\n5. Get approval for each section before proceeding\n6. Write final spec to `docs/development/NNN-<name>/spec.md`\n\n**Reference:** See `references/phase-spec.md` for detailed guidance\n\n**User involvement:** Answer questions, approve spec sections\n\n### Phase 2: Planning (Interactive or Subagent)\n\nCreate detailed implementation plan assuming implementer has minimal context.\n\n**Approach:**\n1. **Tech stack selection** (when needed) - Research and document library/framework choices\n2. **File/module mapping** - Exact paths for new/modified code\n3. **Dependency order** - Build sequence so later pieces have foundations\n4. **Integration points** - How new code connects to existing code\n5. **Risk flags** - Potentially tricky parts\n6. **Testing guidance** - What to test, where tests go\n\n**CRITICAL:** No code in the plan. Describe what needs to be built, not how to code it.\n\n**Reference:** See `references/phase-plan.md` for detailed requirements\n\n**For subagent implementation:** See `references/templates/subagent-plan.md` for prompt template\n\n**Output:** `docs/development/NNN-<name>/plan.md`\n\n**User involvement:** Review and approve the plan\n\n### Phase 3: Task Extraction (Interactive or Subagent)\n\nBreak down the plan into trackable tasks.\n\n**Task format:**\n```markdown\n- [ ] Task description (Plan lines: XX-YY)\n```\n\n**Task granularity:** Each task should deliver coherent, testable functionality. NOT file operations or single-line changes.\n\n**Reference:** See `references/phase-tasks.md` for extraction rules\n\n**For subagent implementation:** See `references/templates/subagent-tasks.md` for prompt template\n\n**Output:** `docs/development/NNN-<name>/tasks.md`\n\n**User involvement:** Review task list\n\n### Phase 4: Implementation (Autonomous - Subagent or External Agent)\n\nImplement tasks one at a time in isolated sessions.\n\n**Implementation Options:**\n\n**Option A: Claude Subagent**\n- Spawn fresh subagent for each task\n- Embed full context in prompt (spec sections, plan section, project context)\n- Subagent implements according to plan (NO deviation)\n- Follows TDD/DRY/YAGNI\n- Reports completion but does NOT mark complete or commit yet\n\n**Reference:** See `references/phase-impl.md` for implementation constraints\n\n**For subagent implementation:** See `references/templates/subagent-impl.md` for prompt template\n\n**Option B: External Coding Agent**\n- Provide agent with task list, spec, plan file paths\n- Provide agent with `references/phase-impl.md` instructions\n- Agent implements next uncompleted task\n- Agent reports completion (does NOT mark complete or commit)\n\n**Option C: Human Implementation**\n- Read next task from tasks.md\n- Read corresponding spec and plan sections\n- Implement according to plan\n- Report completion for review\n\n**User involvement:** Choose implementation method, trigger each task\n\n### Phase 5: Review (Interactive)\n\nReview completed work before marking complete.\n\n**Process:**\n1. Read the spec, plan section, and implementation\n2. Check against requirements, code quality, tests\n3. Provide specific feedback OR sign-off\n4. Route feedback to implementer if issues found\n5. After sign-off, authorize task completion and commit\n\n**Reference:** See `references/phase-review.md` for review checklist\n\n**User involvement:**\n- Trigger review after implementation completes\n- Authorize task completion and commit after sign-off\n\n## Session Memory\n\nAll artifacts in `docs/development/NNN-<name>/` serve as long-term memory:\n\n```\ndocs/development/NNN-<name>/\n‚îú‚îÄ‚îÄ spec.md       # What we're building (design specification)\n‚îú‚îÄ‚îÄ plan.md       # How we're building it (implementation plan)\n‚îî‚îÄ‚îÄ tasks.md      # Implementation checklist with progress tracking\n```\n\nThese files enable:\n- Resuming work after interruption (check tasks.md for progress)\n- Context for autonomous agents (read spec + plan + task)\n- Historical record of implementation decisions\n- Progress tracking across multiple sessions\n\n## Using This Skill\n\n### Full Workflow\n\nInvoke this skill and say:\n> \"I want to implement [feature/fix description]\"\n\nThe skill will guide through all 5 phases.\n\n### Individual Phases\n\nInvoke specific phases when needed:\n- **\"Start spec phase\"** - Begin specification\n- **\"Generate plan from spec\"** - Create plan (provide spec path)\n- **\"Extract tasks from plan\"** - Create task list (provide plan path)\n- **\"Implement next task\"** - Implement next uncompleted task (provide task list path)\n- **\"Review implementation\"** - Review completed work (provide task number)\n\n### Resuming After Interruption\n\nIf interrupted mid-workflow:\n1. Read `docs/development/NNN-<name>/tasks.md` to see completed tasks\n2. Continue with next uncompleted task\n3. The autonomous agent will pick up from current progress\n\n### Modifying the Plan\n\nIf plan needs adjustment during implementation:\n1. Edit `docs/development/NNN-<name>/plan.md`\n2. Update affected tasks in `tasks.md`\n3. Continue implementation with updated plan\n\n## For Autonomous Agents\n\nWhen implementing tasks autonomously (subagents or external agents), follow this critical principle:\n\n**Subagents start with NO context.** They cannot discover information on their own. For reliable results, embed all necessary content directly in the prompt:\n\n1. Full content of relevant reference files (not just paths)\n2. Full content of spec sections (not just the file path)\n3. Specific plan sections extracted by line number\n4. Project context (test commands, file locations, patterns)\n\n**Templates:** Use the prompt templates in `references/templates/` which show exactly what content to embed for each phase.\n\n## Key Principles\n\n1. **Separation of concerns** - Design, implementation, and review are distinct phases\n2. **Plan adherence** - Autonomous implementers follow the plan strictly\n3. **Rich context for agents** - Embed content in prompts, not just file paths\n4. **Incremental commits** - Each task gets its own commit after review sign-off\n5. **Session memory** - All artifacts persist for long-term tracking\n6. **Quality gates** - Nothing marked complete without review sign-off\n\n## Resources\n\nDetailed phase instructions in `references/`:\n- `phase-spec.md` - Specification generation guidance\n- `phase-plan.md` - Planning requirements and format\n- `phase-tasks.md` - Task extraction rules\n- `phase-impl.md` - Implementation constraints\n- `phase-review.md` - Review checklist\n\nSubagent prompt templates in `references/templates/`:\n- `subagent-plan.md` - Planning subagent template\n- `subagent-tasks.md` - Task extraction subagent template\n- `subagent-impl.md` - Implementation subagent template\n",
        "skills/dev-auto/references/phase-impl.md": "# Implementation Phase Instructions\n\nYou are an implementation agent executing a single task from a development plan.\n\n> **Note:** These instructions are agent-agnostic. Whether you are a Claude subagent, an external coding agent (Cursor, Windsurf, Aider, etc.), or a human developer, follow these instructions exactly.\n\n## Your Mission\n\nImplement ONE task according to the detailed plan. Your session has isolated context to avoid pollution. Follow the plan exactly - do not deviate.\n\n## Core Principle\n\n**DO NOT DEVIATE FROM THE PLAN.**\n\nThe planning phase has already determined the approach. Your job is execution, not strategy.\n\n## Process\n\n### Step 1: Identify Your Task\n\n1. Ask the user for the task list path (if not provided)\n2. Read `docs/development/NNN-<name>/tasks.md`\n3. Find the first uncompleted task (first `- [ ]` item)\n4. Note the plan line numbers for this task\n\n**Output:**\n```\nI will implement: Task [N]: [description]\nPlan reference: lines XX-YY\n```\n\n### Step 2: Load Minimal Context\n\nRead ONLY what you need:\n\n1. **Task list** - To identify the task (already read)\n2. **Spec file** - To understand the overall goal (path in task list)\n3. **Plan section** - For detailed instructions (specific lines only)\n\n**DO NOT:**\n- Read unrelated code\n- Explore beyond what the plan specifies\n- Load unnecessary context\n- \"Get familiar\" with the codebase\n\nKeep your context focused and minimal.\n\n### Step 3: Implement Following TDD\n\nUse Test-Driven Development:\n\n1. **Red** - Write a failing test first\n   - Test what the plan specifies\n   - Use real data, not mocks (especially for E2E)\n   - Follow test structure from the plan\n\n2. **Green** - Implement the minimal code to pass\n   - Follow file structure from the plan\n   - Use patterns specified in the plan\n   - Touch only files mentioned in the plan\n\n3. **Refactor** - Clean up if needed\n   - Eliminate duplication (DRY)\n   - But only within scope of this task\n   - Don't refactor beyond what the plan specifies\n\n4. **Repeat** - For each requirement in this task\n\n### Step 4: Follow Key Principles\n\nThroughout implementation:\n\n- **DRY** - Don't repeat yourself (within this task's scope)\n- **YAGNI** - Only implement what's in the plan, nothing more\n- **TDD** - Tests first, always\n- **Small changes** - Incremental progress\n- **Plan adherence** - The plan is your guide\n\n### Step 5: Self-Review\n\nBefore declaring complete:\n\n1. ‚úÖ All requirements from the plan section are met\n2. ‚úÖ Tests are written and passing\n3. ‚úÖ Code follows project conventions\n4. ‚úÖ No errors or warnings\n5. ‚úÖ Implementation matches plan's intent\n\nRun the tests:\n```bash\n[Use test command from plan]\n```\n\n### Step 6: Report Completion\n\nWhen done:\n\n```\nTask [N] implementation complete.\n\nChanges made:\n- [File 1]: [what changed]\n- [File 2]: [what changed]\n\nTests: [N] passing\n\nReady for review.\n```\n\n**DO NOT:**\n- Mark the task as complete in tasks.md (reviewer does this after sign-off)\n- Commit (happens after sign-off)\n- Proceed to the next task\n\n### Step 7: Handle Review Feedback\n\nAfter the user runs dev-review:\n\n**If reviewer has issues:**\n- User will provide specific feedback\n- Address the feedback\n- Return to Step 5 (self-review)\n- Report completion again\n\n**If reviewer signs off:**\n- User will confirm sign-off\n- Proceed to Step 8\n\n### Step 8: Mark Complete and Commit\n\nOnly after explicit sign-off:\n\n1. **Update task list:**\n   - Change `- [ ]` to `- [x]` for this task\n   - Update progress counts\n   - Save the file\n\n2. **Create commit:**\n   ```bash\n   git add [files]\n   git commit -m \"$(cat <<'EOF'\n   Implement [task description]\n\n   - [Summary of what was done]\n   - [Key changes made]\n\n   Related to: docs/development/NNN-<name>/tasks.md\n   Task: [N]\n   EOF\n   )\"\n   ```\n\n3. **Confirm:**\n   ```\n   Task [N] marked complete and committed.\n   [Commit hash]\n   ```\n\n## Handling Problems\n\n**Plan is unclear:**\n- Stop and ask the user for clarification\n- May need to update the plan\n\n**Plan approach doesn't work:**\n- Stop and inform the user with specifics\n- Explain what's not working and why\n- May need to update the plan\n- DO NOT improvise a solution\n\n**Tests are failing:**\n- This is your responsibility\n- Debug and fix before completing\n- Don't blame the plan - make it work\n\n**Unexpected conflicts or issues:**\n- Stop and ask for guidance\n- Describe the specific problem\n- Wait for direction\n\n## What NOT to Do\n\n‚ùå **Don't implement features not in the plan** - Even if they seem like good ideas\n\n‚ùå **Don't refactor beyond the task** - Stick to the scope\n\n‚ùå **Don't skip tests** - TDD is mandatory\n\n‚ùå **Don't mark complete without sign-off** - Review is required\n\n‚ùå **Don't proceed to next task** - One task per session\n\n‚ùå **Don't mock in E2E tests** - Use real data and APIs\n\n‚ùå **Don't deviate from the plan** - Follow it exactly\n\n## Example Implementation Flow\n\n```\nUser: \"Implement the next task\"\n\nAgent: [Reads task list]\n\"I will implement Task 1: Create User model with validation\nPlan reference: lines 15-34\"\n\nAgent: [Reads spec and plan lines 15-34]\n\"Starting TDD implementation...\"\n\nAgent: [Writes test]\n\"Test written for User model validation. Running tests... FAIL (expected)\"\n\nAgent: [Implements User model]\n\"User model implemented. Running tests... PASS\"\n\nAgent: [Self-reviews]\n\"Task 1 implementation complete.\n\nChanges made:\n- src/models/User.ts: Created User model with Zod schema\n- tests/models/User.test.ts: Added validation tests (8 test cases)\n\nTests: 8 passing\n\nReady for review.\"\n\n[User runs review in separate session]\n\nUser: \"Reviewer signed off\"\n\nAgent: [Updates task list, commits]\n\"Task 1 marked complete and committed.\nCommit: abc123f\"\n```\n\n## Context Awareness\n\nYou are part of a larger workflow:\n- **Spec phase** created the design\n- **Plan phase** created your instructions\n- **Task phase** created your task list\n- **Implementation phase (YOU)** executes one task\n- **Review phase** validates your work\n\nYour role is deliberately constrained. Strategic decisions were made during planning. Execute faithfully.\n",
        "skills/dev-auto/references/phase-plan.md": "# Planning Phase Instructions\n\nYou are a planning agent creating a comprehensive implementation plan from an approved specification.\n\n## Your Mission\n\nTransform the specification into an actionable implementation plan that answers: **\"In what order do I build this and where does each piece go?\"**\n\nThe spec defines WHAT to build. The plan defines HOW to build it structurally‚Äînot the code itself.\n\n## CRITICAL: No Code in the Plan\n\n**DO NOT write any code in the plan phase.** This includes:\n- ‚ùå Code snippets or examples\n- ‚ùå Pseudocode\n- ‚ùå Implementation sketches\n- ‚ùå Function signatures with bodies\n- ‚ùå \"Code structure outlines\"\n\nCode belongs in dev-impl where it can be written, tested, and iterated immediately. Code in plans becomes stale artifacts that mislead implementers.\n\n**DO include:**\n- ‚úÖ File paths and module names\n- ‚úÖ Function/class names that need to exist\n- ‚úÖ Data structures (as descriptions, not code)\n- ‚úÖ API contracts (as descriptions)\n\n## Key Assumptions About the Implementer\n\nThe engineer who will follow this plan:\n- ‚úÖ Is a skilled developer\n- ‚ùå Has zero context about this codebase\n- ‚ùå Has questionable taste\n- ‚ùå Doesn't know your toolset well\n- ‚ùå Doesn't understand good test design\n\nTherefore, your plan must be **extremely detailed and explicit**‚Äîbut in prose, not code.\n\n## Process\n\n### Step 1: Analyze the Specification\n\nRead and understand:\n- What needs to be built\n- Why it's needed\n- Success criteria\n- Constraints and requirements\n\n### Step 2: Explore the Codebase\n\nUnderstand:\n- Where this functionality should live\n- Existing patterns to follow\n- Related code to modify or reference\n- Testing infrastructure available\n- Dependencies and imports needed\n\n### Step 3: Tech Stack Selection (When Needed)\n\nIf the feature requires new libraries, frameworks, or tools not already in the project:\n\n1. **Identify what's needed** - What capabilities does this feature require?\n2. **Research options** - What libraries/tools could provide this?\n3. **Evaluate against criteria:**\n   - Maintenance status and community health\n   - Bundle size / performance impact\n   - API ergonomics and learning curve\n   - Compatibility with existing stack\n4. **Make a recommendation** - Document the choice and rationale\n5. **Get approval** - Tech stack decisions should be confirmed before planning proceeds\n\n**Document in plan:**\n- What's being added and why\n- Alternatives considered\n- Any configuration or setup required\n\nSkip this step if the feature uses only existing project dependencies.\n\n### Step 4: Create the Plan\n\nWrite a comprehensive plan with these sections:\n\n#### Overview\n- Brief summary of what will be implemented\n- High-level approach\n\n#### Prerequisites\n- Dependencies to install\n- Configuration needed\n- Knowledge to review first\n\n#### Implementation Tasks\n\nFor EACH task, provide:\n\n**Task Number and Title**\n- Clear, specific title that describes the outcome\n\n**Files to Touch**\n- Exact file paths\n- What will be added/modified in each (in prose)\n\n**Dependency Order**\n- What must exist before this task can start\n- What this task enables for later tasks\n\n**Integration Points**\n- Where new code connects to existing code\n- Existing patterns or interfaces to follow\n\n**Testing Approach**\n- What tests to write FIRST (TDD)\n- Test file location\n- What scenarios to cover (described, not coded)\n\n**Verification**\n- Commands to run\n- Expected outcomes\n\n**Risk Flags**\n- Parts that might be tricky\n- Areas needing investigation\n- Potential blockers\n\n### Step 5: Apply Key Principles\n\nEmphasize throughout the plan:\n\n- **TDD (Test-Driven Development)** - Write tests first\n- **DRY (Don't Repeat Yourself)** - Avoid duplication\n- **YAGNI (You Aren't Gonna Need It)** - Only build what's specified\n- **Frequent commits** - Commit after each task\n- **Small changes** - Break work into minimal increments\n\n### Step 5: Test Guidance\n\nBecause the implementer doesn't know good test design, be explicit:\n\n- **What to test** - Specific functionality and edge cases\n- **What NOT to test** - Don't test mocks; test real behavior\n- **Test structure** - Arrange/Act/Assert pattern\n- **Test data** - Use real data, not mocks in E2E tests\n- **Coverage** - What level of coverage is appropriate\n\n## Plan Quality Standards\n\nA good plan:\n- **Self-contained** - No external context needed\n- **Specific** - Exact files, clear steps\n- **Sequenced** - Tasks in logical order\n- **Testable** - Each task has clear verification\n- **Realistic** - Tasks are achievable units of work\n\n## Output Format\n\nWrite plan to `docs/development/NNN-<name>/plan.md`:\n\n```markdown\n# Implementation Plan: [Feature/Fix Name]\n\n**Spec:** docs/development/NNN-<name>/spec.md\n**Created:** [Date]\n\n## Overview\n\n[Summary of implementation approach - what we're building and the high-level strategy]\n\n## Tech Stack (if applicable)\n\n**New dependencies:**\n- [library-name] - [why needed, alternatives considered]\n\n**Setup required:**\n- [Any configuration or installation steps]\n\n## Task 1: [Title]\n\n**Files:**\n- `path/to/file1.ts` - Add function to handle X\n- `path/to/file2.ts` - Modify existing Y to support Z\n\n**Depends on:** Nothing (first task) / Task N\n**Enables:** Task M, Task P\n\n**Integration points:**\n- Connects to existing FooService via the process() method\n- Follows the pattern established in `path/to/similar.ts`\n\n**Testing:**\n- Test file: `path/to/test.ts`\n- Scenarios: successful case, error handling, edge case X\n\n**Verification:** Run `npm test -- --grep \"feature name\"`\n\n**Risks:** The FooService API may need extension - investigate first\n\n---\n\n## Task 2: [Title]\n\n[Same structure...]\n\n---\n\n## Final Integration\n\n[How all tasks come together - what the implementer should verify at the end]\n```\n\n## Tone and Style\n\n- **Imperative** - \"Create X\", not \"You should create X\"\n- **Specific** - Exact paths and names\n- **Explanatory** - WHY things are done this way\n- **Encouraging** - Assume competence but provide guidance\n\n## Common Mistakes to Avoid\n\n- ‚ùå **Writing code** - No snippets, pseudocode, or implementation sketches\n- ‚ùå **Vague instructions** - \"Update the handler\" without specifying which handler or what change\n- ‚ùå **Assuming knowledge** - Expecting familiarity with project conventions\n- ‚ùå **Tasks too large** - Each task should be completable in one focused session\n- ‚ùå **Tasks too granular** - \"Create directory\", \"Create file\", \"Add import\" are implementation details, not tasks. A task delivers a coherent piece of functionality.\n- ‚ùå **Missing file paths** - Every file to touch must be explicitly named\n- ‚ùå **No verification steps** - Every task needs a way to confirm it's done\n- ‚ùå **Ignoring dependencies** - Tasks must be ordered so foundations exist before dependent work\n\n## Handoff\n\nAfter writing the plan, inform the orchestrator that the planning phase is complete and the path to the plan file.\n",
        "skills/dev-auto/references/phase-review.md": "# Review Phase Instructions\n\nYou are a review agent validating completed implementation work.\n\n## Your Mission\n\nReview implementation work with fresh eyes to ensure it meets the specification and plan requirements before sign-off.\n\n## Review Types\n\n### Task-Level Review\nReview a single completed task before it gets marked complete and committed.\n\n**When:** After an implementer completes one task\n\n### Final Review\nReview all completed work at the end of the development session.\n\n**When:** After all tasks in the task list are complete\n\n## Process\n\n### Step 1: Understand Review Type\n\nAsk the user:\n- \"Is this a task-level review (single task) or final review (all work)?\"\n\nOr infer from context if clear.\n\n### Step 2: Load Context\n\n**For task-level review:**\n1. Read task list: `docs/development/NNN-<name>/tasks.md`\n2. Identify which task was just completed\n3. Read spec file (path at top of task list)\n4. Read plan section for this task (line numbers in task list)\n5. Examine the implementation (files modified)\n\n**For final review:**\n1. Read complete spec: `docs/development/NNN-<name>/spec.md`\n2. Read complete plan: `docs/development/NNN-<name>/plan.md`\n3. Read task list: `docs/development/NNN-<name>/tasks.md`\n4. Examine all implementation work\n\n### Step 3: Check Requirements\n\nVerify the implementation:\n\n#### Meets the Spec\n- ‚úÖ Does it implement what was designed?\n- ‚úÖ Does behavior match specification?\n- ‚úÖ Are all specified features present?\n\n#### Follows the Plan\n- ‚úÖ Does it follow the specified approach?\n- ‚úÖ Are correct files modified?\n- ‚úÖ Are patterns from the plan used?\n\n#### Has Proper Tests\n- ‚úÖ Are tests present?\n- ‚úÖ Do all tests pass?\n- ‚úÖ Is coverage adequate?\n- ‚úÖ Are tests testing real logic (not mocks)?\n- ‚úÖ Do E2E tests use real data?\n\n#### Follows Conventions\n- ‚úÖ Does it match project code style?\n- ‚úÖ Are naming conventions followed?\n- ‚úÖ Is file organization correct?\n\n#### Is Complete\n- ‚úÖ Are there any missing pieces?\n- ‚úÖ Is error handling present?\n- ‚úÖ Are edge cases handled?\n\n#### Works Correctly\n- ‚úÖ Run the tests yourself\n- ‚úÖ Check functionality if possible\n- ‚úÖ Verify expected behavior\n\n### Step 4: Check Code Quality\n\nLook for issues:\n\n#### DRY Violations\n- Is there unnecessary code duplication?\n- Could common logic be extracted?\n\n#### YAGNI Violations\n- Are there features not in the spec/plan?\n- Is anything over-engineered?\n\n#### Poor Test Design\n- Are tests just testing mocks?\n- Is test logic missing?\n- Are tests too shallow?\n\n#### Missing Edge Cases\n- Are null/undefined handled?\n- Are error cases covered?\n- Are boundary conditions tested?\n\n#### Error Handling\n- Are errors caught appropriately?\n- Are error messages helpful?\n- Is error handling tested?\n\n#### Documentation\n- Are complex parts documented?\n- Are public APIs documented?\n- Is the README updated if needed?\n\n### Step 5: Provide Feedback\n\n**If issues are found:**\n\nProvide specific, actionable feedback:\n\n```markdown\n## Review Feedback: Task [N]\n\n### Issues Found\n\n#### [Issue Category]\n\n**Location:** `path/to/file.ts:42-48`\n\n**Problem:**\n[Clear description of the issue]\n\n**Why it matters:**\n[Explanation of impact]\n\n**Required change:**\n[Specific fix needed]\n\n---\n\n[Repeat for each issue]\n\n### Priority\n\n- üî¥ Blocking: [N] issues must be fixed\n- üü° Important: [N] issues should be fixed\n- üü¢ Nice-to-have: [N] suggestions\n```\n\nBe specific:\n- ‚úÖ \"Line 42: `getUserData()` should handle null case when user not found\"\n- ‚ùå \"Error handling looks wrong\"\n\n**If no issues found:**\n\nProvide sign-off:\n\n```markdown\n## Review Sign-Off: Task [N]\n\n‚úÖ All requirements from spec met\n‚úÖ Implementation follows plan\n‚úÖ Tests present and passing ([N] tests)\n‚úÖ Code quality acceptable\n‚úÖ No blocking issues found\n\n**Approved for completion.**\n\nThe implementer may now:\n1. Mark task [N] complete in tasks.md\n2. Create commit\n```\n\n### Step 6: Follow-Up\n\n**For task-level review with issues:**\n1. User will copy feedback to implementer session\n2. Implementer will fix issues\n3. User will request re-review\n4. Repeat from Step 3\n\n**For task-level review with sign-off:**\n1. Implementer marks task complete\n2. Implementer creates commit\n3. Ready for next task\n\n**For final review with issues:**\n1. User spawns new implementer to address issues\n2. Iterate until clean\n\n**For final review with sign-off:**\n1. Generate final report (see below)\n2. Workflow complete\n\n## Final Review Report Format\n\nFor final reviews that pass:\n\n```markdown\n# Final Review Report: [Feature/Fix Name]\n\n**Date:** [Date]\n**Reviewer:** Development Review Agent\n**Spec:** docs/development/NNN-<name>/spec.md\n**Plan:** docs/development/NNN-<name>/plan.md\n**Tasks:** docs/development/NNN-<name>/tasks.md\n\n## Summary\n\n[2-3 sentence overview of what was implemented]\n\n## Review Results\n\n‚úÖ All requirements from spec met\n‚úÖ Implementation follows plan\n‚úÖ Tests present and passing\n‚úÖ Code quality acceptable\n‚úÖ All [N] tasks completed\n\n## Test Coverage\n\n- Unit tests: [N] passing\n- Integration tests: [N] passing\n- E2E tests: [N] passing\n- Total: [N] tests passing\n\n## Deliverables\n\n### Files Created\n- `path/to/new/file1.ts`\n- `path/to/new/file2.ts`\n\n### Files Modified\n- `path/to/existing/file1.ts` - [brief description of changes]\n- `path/to/existing/file2.ts` - [brief description of changes]\n\n### Documentation Updated\n- [Any docs that were updated]\n\n## Commits\n\n[N] commits made:\n- [commit hash]: Implement [task 1]\n- [commit hash]: Implement [task 2]\n- ...\n\n## Sign-Off\n\nImplementation complete and meets all requirements.\nReady for integration.\n\n---\n\n**Review completed:** [Timestamp]\n```\n\n## Review Principles\n\n1. **Fresh perspective** - No assumptions about what should be there\n2. **Spec is truth** - The spec defines success\n3. **Plan is guidance** - The plan defines the approach\n4. **Be thorough** - Actually check, don't skim\n5. **Be specific** - Vague feedback wastes time\n6. **Be fair** - Don't ask for changes beyond spec/plan without good reason\n7. **Be honest** - Quality matters more than feelings\n\n## What NOT to Do\n\n‚ùå **Don't accept insufficient work** - If it doesn't meet requirements, don't sign off\n\n‚ùå **Don't scope creep** - Don't ask for features not in spec unless there's a genuine issue\n\n‚ùå **Don't skip testing** - Always verify tests exist and pass\n\n‚ùå **Don't assume** - Read the code; don't trust claims\n\n‚ùå **Don't be vague** - Give specific locations and changes needed\n\n‚ùå **Don't be blocked by style** - Focus on correctness, not formatting preferences\n\n‚ùå **Don't approve tests that test mocks** - Tests should validate real behavior\n\n## Common Issues to Watch For\n\n### Test Issues\n- Tests that only verify mocked behavior\n- Missing edge case tests\n- E2E tests using mocks instead of real data\n- Passing tests that don't actually validate requirements\n\n### Implementation Issues\n- Missing error handling\n- Unhandled null/undefined cases\n- Code duplication (DRY violations)\n- Over-engineering (YAGNI violations)\n- Deviation from the plan\n\n### Completeness Issues\n- Missing files from the plan\n- Partial implementations\n- Incomplete error cases\n- Missing documentation\n\n## Running Tests\n\nAlways run tests yourself:\n\n```bash\n# Use the test command from the plan\nnpm test          # or\npytest            # or\ncargo test        # or\n[project-specific command]\n```\n\nVerify they actually pass. Don't trust claims without verification.\n\n## Context Awareness\n\nYou are part of a larger workflow:\n- **Spec phase** defined requirements\n- **Plan phase** defined approach\n- **Implementation phase** executed the work\n- **Review phase (YOU)** validate quality\n\nYour role is quality gatekeeper. Be thorough, be fair, be honest. The goal is shipping correct, maintainable code.\n",
        "skills/dev-auto/references/phase-spec.md": "# Specification Phase Instructions\n\nYou are a specification agent helping to turn a user's idea into a fully-formed design specification.\n\n## Your Mission\n\nGather requirements through careful questioning, then document a comprehensive design specification that will guide implementation.\n\n## Process\n\n### Step 1: Understand Current State\n\nExamine the project in the working directory to understand:\n- Project structure and technologies\n- Existing patterns and conventions\n- Related code that might be affected\n- Current capabilities\n\n### Step 2: Gather Requirements (Interactive)\n\nAsk clarifying questions to refine the user's idea. **CRITICAL RULES:**\n\n1. **ONE question per message** - Never ask multiple questions at once\n2. **Prefer multiple choice** - Give the user options when possible\n3. **Open-ended when needed** - Use for short answers when multiple choice doesn't fit\n4. **Continue until certain** - Keep asking until you fully understand\n\nExample good questions:\n- \"Should this feature work for all users or just admins? (A) All users (B) Just admins (C) Configurable\"\n- \"Where should this data be stored? (A) Database (B) File system (C) Memory cache\"\n- \"What should happen if the API call fails?\"\n\n### Step 3: Present Specification\n\nOnce you understand the requirements:\n\n1. **Section by section** - Present the spec in 200-300 word sections\n2. **Wait for approval** - After EACH section, ask \"Does this look right so far?\"\n3. **Iterate if needed** - If the user has changes, revise and re-present that section\n4. **Continue when approved** - Only move to the next section after approval\n\nSpecification sections typically include:\n- **Overview** - What is being built and why\n- **User Experience** - How users will interact with it\n- **Data Model** - What data structures are needed\n- **API / Interface** - How components communicate\n- **Error Handling** - How errors are managed\n- **Testing Strategy** - How this will be tested\n- **Edge Cases** - Special scenarios to handle\n\n### Step 4: Write Specification File\n\nAfter all sections are approved:\n\n1. Determine the directory name:\n   - Ask user for the number (NNN) or check existing docs/development/ for next number\n   - Ask user for feature/fix name\n   - Format: `docs/development/NNN-<name>/`\n\n2. Create the directory if needed\n\n3. Write complete spec to `docs/development/NNN-<name>/spec.md`\n\n## Specification Quality Standards\n\nA good specification:\n- **Clear** - No ambiguity about what needs to be built\n- **Complete** - Addresses all aspects of the feature\n- **Concrete** - Includes specific examples and scenarios\n- **Testable** - Clear criteria for what \"done\" means\n- **Scoped** - Focused on the agreed requirements (no scope creep)\n\n## Initial Prompt to User\n\nWhen starting, use this approach:\n\n> \"I'll help you create a design specification. Let me start by understanding the current project state, then I'll ask you questions one at a time to refine your idea. Once I understand what we're building, I'll present the design specification section by section for your approval.\"\n\nThen examine the project and begin questioning.\n\n## Output Format\n\nThe final spec.md should follow this structure:\n\n```markdown\n# [Feature/Fix Name]\n\n**Created:** [Date]\n**Status:** Approved\n\n## Overview\n\n[High-level description of what is being built and why]\n\n## [Additional Sections as Appropriate]\n\n[Detailed sections covering all aspects of the design]\n\n## Success Criteria\n\n- [Specific criteria for what constitutes successful implementation]\n```\n\n## Key Constraints\n\n- **No implementation details** - Focus on WHAT to build, not HOW\n- **No tech stack decisions** - Library/framework choices belong in the planning phase\n- **User-centric** - Describe behavior from user's perspective\n- **Technology-agnostic** - Describe capabilities needed, not specific tools\n- **One question at a time** - This is critical for good user experience\n\n## Handoff\n\nAfter completing the spec, inform the orchestrator that the specification phase is complete and the path to the spec file.\n",
        "skills/dev-auto/references/phase-tasks.md": "# Task Extraction Phase Instructions\n\nYou are a task extraction agent creating a trackable task list from an implementation plan.\n\n## Your Mission\n\nExtract discrete, trackable tasks from the implementation plan and create a structured task list with references to the plan.\n\n## Process\n\n### Step 1: Read the Plan\n\nUnderstand:\n- All implementation tasks\n- The sequence of work\n- Dependencies between tasks\n- Where each task is documented in the plan\n\n### Step 2: Extract Tasks\n\nFor each task in the plan:\n\n1. **Identify the task** - Clear, one-line description\n2. **Note line numbers** - Where this task is detailed in plan.md\n3. **Preserve order** - Maintain the sequence from the plan\n4. **Right-size tasks** - Each task represents a meaningful outcome, not a single operation\n\n**Task granularity matters.** A task should:\n- Deliver a coherent piece of functionality\n- Be testable on its own\n- Make sense to a human reviewer\n\n**Tasks are NOT:**\n- File operations (\"create directory\", \"create file\", \"add import\")\n- Single-line changes (\"add property to config\")\n- Setup mechanics (\"install dependencies\", \"configure environment\")\n\n### Step 3: Create Task List File\n\nWrite to `docs/development/NNN-<name>/tasks.md`:\n\n```markdown\n# Task List: [Feature/Fix Name]\n\n**Spec:** docs/development/NNN-<name>/spec.md\n**Plan:** docs/development/NNN-<name>/plan.md\n**Created:** [Date]\n\n## Progress\n\n- Total tasks: [N]\n- Completed: [0]\n- Remaining: [N]\n\n## Tasks\n\n- [ ] Task 1: [One-line description] (Plan lines: XX-YY)\n- [ ] Task 2: [One-line description] (Plan lines: ZZ-AA)\n- [ ] Task 3: [One-line description] (Plan lines: BB-CC)\n- [ ] Task 4: [One-line description] (Plan lines: DD-EE)\n\n## Instructions for Implementer\n\n### Before Starting\n1. Read this task list to identify the next uncompleted task\n2. Read the spec file to understand the overall goal\n3. Read the plan section (line numbers above) for detailed instructions\n\n### During Implementation\n1. Implement ONE task at a time\n2. Follow the plan exactly - DO NOT DEVIATE\n3. Write tests first (TDD)\n4. Make small, focused changes\n5. Run tests to verify\n\n### After Implementation\n1. Inform the user that the task is complete\n2. DO NOT mark the task complete yet\n3. Wait for review using the dev-review phase\n4. Only after reviewer sign-off:\n   - Mark task complete: change `- [ ]` to `- [x]`\n   - Update progress counts\n   - Create git commit\n\n### Commit Format\n```\nImplement [task description]\n\n- Brief summary of changes\n- What was added/modified\n\nRelated to: docs/development/NNN-<name>/tasks.md\nTask: [N]\n```\n\n## Important Rules\n\n- **One task at a time** - Never proceed to the next task automatically\n- **No skipping review** - Every task must be reviewed before marking complete\n- **Commit after sign-off** - Each completed task gets its own commit\n- **Update progress** - Keep the progress counts current\n```\n\n## Task Description Guidelines\n\nGood task descriptions:\n- ‚úÖ \"Create User model with validation\" (Clear, specific)\n- ‚úÖ \"Add authentication middleware to API routes\" (Action-oriented)\n- ‚úÖ \"Write E2E tests for login flow\" (Concrete)\n\nBad task descriptions:\n- ‚ùå \"Do the user stuff\" (Too vague)\n- ‚ùå \"Make it work\" (No specifics)\n- ‚ùå \"Implement everything in Task 1\" (Too large)\n\nToo granular (combine into one task):\n- ‚ùå \"Create src/models directory\"\n- ‚ùå \"Create User.ts file\"\n- ‚ùå \"Add User class\"\n- ‚ùå \"Add validation to User\"\n\nShould be: \"Create User model with validation\"\n\n## Line Number References\n\nUse the `cat -n` format from reading the plan file:\n- Count actual content lines (what you see in the Read tool output)\n- Format: `(Plan lines: 23-67)` for a task spanning lines 23 to 67\n- Be accurate - implementers will use these to find instructions\n\n## Example Task List\n\n```markdown\n# Task List: User Authentication Feature\n\n**Spec:** docs/development/001-user-auth/spec.md\n**Plan:** docs/development/001-user-auth/plan.md\n**Created:** 2025-01-15\n\n## Progress\n\n- Total tasks: 5\n- Completed: 0\n- Remaining: 5\n\n## Tasks\n\n- [ ] Task 1: Create User model with Zod validation schema (Plan lines: 15-34)\n- [ ] Task 2: Implement password hashing utilities (Plan lines: 35-52)\n- [ ] Task 3: Add authentication middleware (Plan lines: 53-78)\n- [ ] Task 4: Create login/logout API endpoints (Plan lines: 79-112)\n- [ ] Task 5: Write E2E tests for auth flow (Plan lines: 113-145)\n\n## Instructions for Implementer\n\n[Standard instructions as above]\n```\n\n## Quality Checks\n\nBefore finalizing:\n- ‚úÖ All plan tasks are represented\n- ‚úÖ Line numbers are accurate\n- ‚úÖ Tasks are in logical order\n- ‚úÖ Each task is atomic and clear\n- ‚úÖ Progress tracking is initialized\n- ‚úÖ Instructions are complete\n\n## Handoff\n\nAfter creating the task list, inform the orchestrator that the task extraction phase is complete and the path to the tasks file.\n",
        "skills/dev-auto/references/templates/subagent-impl.md": "# Implementation Subagent Prompt Template\n\nUse this template when spawning a subagent to implement a single task from the task list.\n\n```\nYou are an implementation agent. Implement ONE task exactly as specified.\n\n## Instructions\n[Paste full content of references/phase-impl.md]\n\n## Your Task\nTask [N]: [description]\n\n## Relevant Specification\n[Paste relevant sections from spec.md]\n\n## Plan Section for This Task\n[Paste lines XX-YY from plan.md]\n\n## Project Context\n- Test command: [command]\n- Files to modify: [list from plan]\n- Patterns to follow: [describe]\n\n## Constraints\n- DO NOT DEVIATE FROM THE PLAN\n- Implement this ONE task only\n- Report completion but do NOT mark complete or commit\n```\n\n## Why This Template\n\n**Subagents start with NO context.** For reliable results, embed all necessary content directly in the subagent prompt.\n\n## Usage\n\n1. Read `references/phase-impl.md` and paste its entire content into the Instructions section\n2. Identify the task from the task list (task number and description)\n3. Extract relevant sections from the spec (usually 1-3 paragraphs)\n4. Extract the specific plan section for this task using the line numbers from the task list\n5. Fill in Project Context with test commands, file paths, and patterns from the codebase\n6. Spawn the subagent with this complete prompt\n",
        "skills/dev-auto/references/templates/subagent-plan.md": "# Planning Subagent Prompt Template\n\nUse this template when spawning a subagent to create an implementation plan from an approved specification.\n\n```\nYou are a planning agent. Create a comprehensive implementation plan.\n\n## Instructions\n[Paste full content of references/phase-plan.md]\n\n## Approved Specification\n[Paste full content of docs/development/NNN-<name>/spec.md]\n\n## Project Context\n- Technologies: [list]\n- Key directories: [list with descriptions]\n- Relevant patterns: [describe existing patterns to follow]\n- Test command: [command]\n\n## Output\nWrite the plan to: docs/development/NNN-<name>/plan.md\n```\n\n## Why This Template\n\n**Subagents start with NO context.** They cannot read files unless you tell them to, and even then they may not find the right information. For reliable results, embed all necessary content directly in the subagent prompt.\n\n## Usage\n\n1. Read `references/phase-plan.md` and paste its entire content into the Instructions section\n2. Read the approved spec file and paste its entire content into the Approved Specification section\n3. Fill in the Project Context with relevant details from the codebase\n4. Spawn the subagent with this complete prompt\n",
        "skills/dev-auto/references/templates/subagent-tasks.md": "# Task Extraction Subagent Prompt Template\n\nUse this template when spawning a subagent to extract a task list from an implementation plan.\n\n```\nYou are a task extraction agent. Break down the plan into trackable tasks.\n\n## Instructions\n[Paste full content of references/phase-tasks.md]\n\n## Implementation Plan\n[Paste full content of docs/development/NNN-<name>/plan.md]\n\n## Output\nWrite the task list to: docs/development/NNN-<name>/tasks.md\n```\n\n## Why This Template\n\n**Subagents start with NO context.** For reliable results, embed all necessary content directly in the subagent prompt.\n\n## Usage\n\n1. Read `references/phase-tasks.md` and paste its entire content into the Instructions section\n2. Read the plan file and paste its entire content into the Implementation Plan section\n3. Spawn the subagent with this complete prompt\n",
        "skills/dev-guided/SKILL.md": "---\nname: dev-guided\ndescription: Human-in-the-loop iterative development. Use when requirements will emerge during implementation, decisions need human approval at each step, or work will span multiple sessions with frequent feedback loops. Creates problem statement, decisions log, runbook, and progress tracking.\n---\n\n# Guided Development\n\n## Overview\n\nGuided development is a workflow designed for iterative, human-in-the-loop software development. Unlike traditional planning approaches that create detailed upfront plans, this workflow establishes problem boundaries, captures explicit human decisions, and enables incremental implementation with continuous feedback.\n\n**Use this skill when:**\n- The problem is exploratory and not fully understood upfront\n- Human input is needed for key technical decisions\n- Development will proceed iteratively across multiple sessions\n- The human wants to maintain control rather than delegate to autonomous execution\n\n## Workflow Decision Tree\n\nWhen the skill is invoked, determine which phase to enter:\n\n```\nDoes docs/development/NNN-<name>/ exist with materials?\n‚îú‚îÄ NO  ‚Üí Initial Setup Phase (create problem_statement, decisions, runbook, progress)\n‚îî‚îÄ YES ‚Üí Implementation Session Phase (load context, plan, implement, update progress)\n```\n\n## Initial Setup Phase\n\nWhen no materials exist, guide the human through creating foundational documents via structured Q&A.\n\n### Process\n\n1. **Determine folder location**\n   - Check for existing development session folders: `docs/development/`\n   - Determine next number: `NNN` (e.g., 001, 002, etc.)\n   - Ask human for feature name\n   - Create folder: `docs/development/NNN-<name>/`\n\n2. **Create problem_statement.md**\n   - Load the template from `references/template-problem_statement.md`\n   - Ask questions to understand the problem:\n     - \"What problem are you trying to solve?\"\n     - \"What is the scope of this work? What's explicitly out of scope?\"\n     - \"What does success look like?\"\n     - \"Are there any constraints or requirements?\"\n   - Fill in the template with responses\n   - Save as `problem_statement.md`\n\n3. **Create decisions.md**\n   - Load the template from `references/template-decisions.md`\n   - **CRITICAL RULE:** MUST ask about every unclear aspect. MUST NOT assume \"sensible defaults\" or \"de facto standards\"\n   - Probe for decisions on:\n     - Language/framework choices\n     - Library/dependency choices\n     - Architectural patterns\n     - Data storage approaches\n     - Testing strategies\n     - Error handling approaches\n     - Security considerations\n   - For each unclear aspect:\n     - Explain why a decision is needed\n     - Present options if helpful (without bias)\n     - Ask for the human's choice\n     - Record the decision with rationale\n   - Save as `decisions.md`\n\n4. **Create runbook.md**\n   - Load the template from `references/template-runbook.md`\n   - Ask questions:\n     - \"How should this code be built/compiled?\"\n     - \"How should this code be run/tested?\"\n     - \"Are there any other validation steps?\"\n     - \"At what points during implementation should I pause and ask for your feedback?\"\n   - Fill in build, test, run, and validation instructions\n   - Create structured feedback points\n   - Save as `runbook.md`\n\n5. **Create empty progress.md**\n   - Load the template from `references/template-progress.md`\n   - Create empty file (will be populated after first implementation session)\n   - Save as `progress.md`\n\n6. **Complete setup**\n   - Inform human that setup is complete\n   - Ask if they want to start the first implementation session now or later\n   - If now, proceed to Implementation Session Phase\n\n### Reference Materials\n\nFor detailed guidance on the initial setup phase, read `references/initial-setup.md`.\n\n## Implementation Session Phase\n\nWhen materials already exist, start an implementation session to continue development work.\n\n### Process\n\n1. **Load context**\n   - Read `problem_statement.md` to understand the problem scope\n   - Read `decisions.md` to understand what choices have been made\n   - Read `runbook.md` to understand validation and feedback points\n   - Read `progress.md` to understand what's been done and what's outstanding\n   - Check for existing `plan-N.md` files to understand previous approaches\n\n2. **Determine session number**\n   - List existing `plan-N.md` files\n   - Next session number = max(N) + 1\n   - If no plan files exist, this is session 1\n\n3. **Enter plan mode**\n   - Based on loaded context, create a plan for this session\n   - Plan should include:\n     - What will be accomplished\n     - Specific steps to take\n     - Dependencies between steps\n     - Expected validation points from runbook\n     - Outstanding questions or uncertainties\n   - Present plan to human for approval\n\n4. **Save approved plan**\n   - After human approves the plan, save as `plan-N.md` where N is the session number\n   - Proceed with implementation\n\n5. **Implement according to plan**\n   - Follow the approved plan\n   - **Respect feedback points:** When reaching a feedback point in runbook.md, MUST pause and ask for human input\n   - **Document new decisions:** If new unclear aspects arise, update decisions.md and ask for human input\n   - **Update runbook if needed:** If build/test/validation steps change, update runbook.md\n   - **Follow existing decisions:** Use the choices recorded in decisions.md\n   - Perform validation steps from runbook.md\n   - Ensure all tests pass\n\n6. **Update progress.md**\n   - Add a new session entry using this format:\n   ```markdown\n   ## Session N (YYYY-MM-DD)\n\n   ### Accomplished\n   - [What was implemented/completed]\n   - [Tests that now pass]\n   - [Issues that were resolved]\n\n   ### Outstanding\n   - [What still needs to be done]\n   - [Known issues or blockers]\n\n   ### Questions\n   - [New unclear aspects that need decisions]\n   - [Uncertainties or concerns]\n   ```\n\n7. **Session completion**\n   - Verify all changes are recorded in progress.md\n   - Verify any new decisions are in decisions.md\n   - Verify runbook.md is current\n   - Inform human that session is complete\n   - Summarize what was accomplished and what's next\n\n### Reference Materials\n\nFor detailed guidance on implementation sessions, read `references/implementation-session.md`.\n\n## Key Principles\n\n### Workflow Principles\n\n1. **No Assumptions**: Never assume \"sensible defaults\" or \"de facto standards\". Always ask for explicit human decisions.\n\n2. **Respect Feedback Points**: Feedback points in runbook.md are mandatory pause points. Never skip them.\n\n3. **Living Documents**: decisions.md, runbook.md, and progress.md are living documents that evolve throughout the development session.\n\n4. **Session-Scoped Plans**: Each implementation session gets its own plan file. Plans are ephemeral and session-specific, not long-term roadmaps.\n\n5. **Problem-Focused**: problem_statement.md defines the problem and scope, not the solution. It provides boundaries, not prescriptions.\n\n### Engineering Principles\n\n1. **Test Driven Development (TDD)**: For every new feature or bugfix, you MUST:\n   - Write a failing test that correctly validates the desired functionality\n   - Run the test to confirm it fails as expected\n   - Write ONLY enough code to make the failing test pass\n   - Run the test to confirm success\n   - Refactor if needed while keeping tests green\n\n2. **YAGNI (You Aren't Gonna Need It)**: The best code is no code. Don't add features we don't need right now. When it doesn't conflict with YAGNI, architect for extensibility and flexibility.\n\n3. **DRY (Don't Repeat Yourself)**: Work hard to reduce code duplication, even if the refactoring takes extra effort.\n\n4. **Minimal Changes**: Make the SMALLEST reasonable changes to achieve the desired outcome. Prefer simple, clean, maintainable solutions over clever or complex ones.\n\n5. **Fix Broken Things Immediately**: All test failures are your responsibility, even if they're not your fault. Fix broken things immediately when you find them.\n\n6. **Never Skip Tests**: Never delete a test because it's failing. Never write tests that \"test\" mocked behavior. Test output must be pristine to pass.\n\n## Example Usage\n\n**Starting new work:**\n```\nHuman: \"I want to add OAuth authentication to the app\"\nAgent: [Invokes dev-guided skill]\nAgent: [Creates docs/development/001-oauth-auth/ folder]\nAgent: [Guides through creating problem_statement, decisions, runbook, progress]\nAgent: \"Setup complete. Ready to start first implementation session?\"\n```\n\n**Continuing existing work:**\n```\nHuman: \"Continue working on OAuth\" [in directory with existing materials]\nAgent: [Invokes dev-guided skill]\nAgent: [Loads problem_statement, decisions, runbook, progress]\nAgent: [Enters plan mode]\nAgent: \"Based on progress, I plan to implement token storage. Here's my plan...\"\nAgent: [After approval, saves as plan-2.md and implements]\nAgent: [Updates progress.md with session 2 summary]\n```\n\n## Resources\n\nThis skill includes reference materials with detailed phase guidance and templates:\n\n### references/\n- `initial-setup.md` - Detailed guidance for the initial setup phase\n- `implementation-session.md` - Detailed guidance for implementation sessions\n- `template-problem_statement.md` - Template for problem statements\n- `template-decisions.md` - Template for decisions with examples\n- `template-runbook.md` - Template for runbook with feedback point examples\n- `template-progress.md` - Template for progress tracking\n",
        "skills/dev-guided/references/implementation-session.md": "# Implementation Session Phase\n\nWhen materials already exist in the docs folder, start an implementation session to continue the development work.\n\n## Session Flow\n\n1. Load context from existing materials\n2. Enter plan mode and create session plan\n3. Implement according to plan\n4. Update progress and other materials\n\n## 1. Load Context\n\nRead all existing materials in order:\n\n1. **problem_statement.md** - Understand the problem scope\n2. **decisions.md** - Understand what choices have been made\n3. **runbook.md** - Understand how to validate work and when to get feedback\n4. **progress.md** - Understand what has been done and what's outstanding\n\nAdditionally, check for existing plan files (plan-1.md, plan-2.md, etc.) to understand previous approaches.\n\n## 2. Create Session Plan\n\nEnter plan mode and create a plan for this implementation session:\n\n**Plan should include:**\n- What will be accomplished in this session\n- Specific steps to take\n- Dependencies between steps\n- Expected validation points from runbook.md\n- Outstanding questions or uncertainties\n\n**Determine session number:**\n- Count existing plan-N.md files\n- Next session number = max(N) + 1\n- If no plan files exist, this is session 1\n\n**After plan is approved by human:**\n- Save plan as `plan-N.md` where N is the session number\n- Proceed with implementation\n\n## 3. Implement According to Plan\n\nFollow the plan created in step 2.\n\n**During implementation:**\n\n- **Respect feedback points:** When reaching a feedback point defined in runbook.md, MUST pause and ask for human input\n- **Document new decisions:** If new unclear aspects arise, update decisions.md and ask for human input\n- **Update runbook if needed:** If build/test/validation steps change, update runbook.md\n- **Follow existing decisions:** Use the choices recorded in decisions.md\n\n**Testing and validation:**\n- Follow the build/test instructions in runbook.md\n- Perform validation steps defined in runbook.md\n- Ensure all tests pass before completing session\n\n## 4. Update Progress\n\nAt the end of the session, update progress.md with a new entry:\n\n**Entry format:**\n```markdown\n## Session N (YYYY-MM-DD)\n\n### Accomplished\n- [What was implemented/completed]\n- [Tests that now pass]\n- [Issues that were resolved]\n\n### Outstanding\n- [What still needs to be done]\n- [Known issues or blockers]\n\n### Questions\n- [New unclear aspects that need decisions]\n- [Uncertainties or concerns]\n```\n\n**Also update if needed:**\n- **decisions.md** - If new decisions were made\n- **runbook.md** - If validation steps changed\n\n## Session Completion\n\nAfter updating all materials:\n1. Verify all changes are recorded in progress.md\n2. Verify any new decisions are in decisions.md\n3. Verify runbook.md is current\n4. Inform human that the session is complete\n5. Summarize what was accomplished and what's next\n",
        "skills/dev-guided/references/initial-setup.md": "# Initial Setup Phase\n\nWhen starting a new development session (no materials exist in the docs folder), guide the human through creating the foundational documents through structured Q&A.\n\n## Phase Flow\n\n1. Create problem_statement.md\n2. Create decisions.md\n3. Create runbook.md\n4. Create empty progress.md\n\n## 1. Problem Statement Creation\n\n**Purpose:** Define what problem is being solved, providing scope without prescribing solution.\n\n**Questions to ask:**\n- \"What problem are you trying to solve?\"\n- \"What is the scope of this work? What's explicitly out of scope?\"\n- \"What does success look like for this work?\"\n- \"Are there any constraints or requirements I should know about?\"\n\n**Format:** Use the template in `template-problem_statement.md`\n\n**Key principle:** Focus on the WHAT and WHY, not the HOW.\n\n## 2. Decisions Creation\n\n**Purpose:** Explicitly capture human choices on unclear aspects. NO assumptions or defaults.\n\n**Critical rule:** MUST ask about every unclear aspect. MUST NOT assume \"sensible defaults\" or \"de facto standards.\"\n\n**Areas to probe:**\n- Language/framework choices\n- Library/dependency choices\n- Architectural patterns\n- Data storage approaches\n- Testing strategies\n- Error handling approaches\n- Security considerations\n\n**Questions format:**\n- \"Which [language/library/pattern] should be used for X?\"\n- \"How should Y be handled?\"\n- \"What approach should be taken for Z?\"\n\n**For each unclear aspect:**\n1. Explain why a decision is needed\n2. Present options if helpful (but don't bias toward one)\n3. Ask for the human's choice\n4. Record the decision and rationale in decisions.md\n\n**Format:** Use the template in `template-decisions.md`\n\n**Key principle:** Capture explicit human choices, not assumptions.\n\n## 3. Runbook Creation\n\n**Purpose:** Document how to validate work and when to get feedback during implementation.\n\n**Questions to ask:**\n- \"How should this code be built/compiled?\"\n- \"How should this code be run/tested?\"\n- \"Are there any other validation steps I should perform?\"\n- \"At what points during implementation should I pause and ask for your feedback?\"\n\n**Format:** Use the template in `template-runbook.md`\n\n**Key sections:**\n- Build instructions\n- Test instructions\n- Feedback points (structured list of when to pause for human input)\n- Other validation steps\n\n**Key principle:** Establish clear validation and feedback loops.\n\n## 4. Progress Initialization\n\nCreate an empty progress.md file using the template in `template-progress.md`. This will be populated after the first implementation session.\n\n## Completing Initial Setup\n\nAfter creating all four files, inform the human that the setup is complete and ask if they want to start the first implementation session now or later.\n",
        "skills/dev-guided/references/template-decisions.md": "# Decisions\n\nThis document captures explicit human choices on unclear aspects of the implementation. Each decision includes the context, options considered, and the chosen approach with rationale.\n\n## Decision Template\n\nUse this format for each decision:\n\n```markdown\n## [Decision Topic]\n\n**Context:** [Why does this decision need to be made?]\n\n**Options Considered:**\n1. [Option A] - [Brief description]\n2. [Option B] - [Brief description]\n\n**Decision:** [Chosen option]\n\n**Rationale:** [Why this choice was made]\n\n**Date:** YYYY-MM-DD\n```\n\n---\n\n## Example Decisions\n\n### Language Choice\n\n**Context:** Need to choose implementation language for the new service.\n\n**Options Considered:**\n1. Python - Good for rapid development, rich ecosystem\n2. Go - Better performance, strong concurrency support\n3. Rust - Maximum performance and safety\n\n**Decision:** Python\n\n**Rationale:** Team is most familiar with Python, and performance requirements don't justify the learning curve of Go or Rust. We can optimize later if needed.\n\n**Date:** 2025-11-24\n\n---\n\n### Database Storage\n\n**Context:** Need to store user session data.\n\n**Options Considered:**\n1. PostgreSQL - Relational, ACID guarantees\n2. Redis - In-memory, fast but volatile\n3. DynamoDB - Managed NoSQL, scalable\n\n**Decision:** Redis with PostgreSQL backup\n\n**Rationale:** Redis for fast session access, PostgreSQL for persistence. Hybrid approach gives us speed and durability.\n\n**Date:** 2025-11-24\n\n---\n\n## Current Decisions\n\n[Add decisions here as they are made during the development session]\n",
        "skills/dev-guided/references/template-problem_statement.md": "# Problem Statement\n\n## Problem\n\n[Describe the problem being solved in 2-4 sentences. Focus on WHAT needs to be accomplished and WHY, not HOW it will be done.]\n\n## Scope\n\n### In Scope\n- [What is included in this work]\n- [Specific features or capabilities to be added]\n\n### Out of Scope\n- [What is explicitly not included]\n- [Future work or related features that won't be addressed]\n\n## Success Criteria\n\n[What does success look like? How will you know this is complete?]\n\n- [Measurable outcome 1]\n- [Measurable outcome 2]\n\n## Constraints\n\n[Any constraints or requirements that must be respected]\n\n- [Technical constraints]\n- [Time or resource constraints]\n- [Compatibility requirements]\n",
        "skills/dev-guided/references/template-progress.md": "# Progress\n\nThis document tracks the progress of implementation sessions. Each session adds a new entry describing what was accomplished, what's outstanding, and any questions that arose.\n\n---\n\n## Session 1 (YYYY-MM-DD)\n\n### Accomplished\n- [What was implemented or completed]\n- [Tests that now pass]\n- [Issues that were resolved]\n\n### Outstanding\n- [What still needs to be done]\n- [Known issues or blockers]\n\n### Questions\n- [New unclear aspects that need decisions]\n- [Uncertainties or concerns]\n\n---\n\n## Session 2 (YYYY-MM-DD)\n\n### Accomplished\n- [What was implemented or completed]\n- [Tests that now pass]\n- [Issues that were resolved]\n\n### Outstanding\n- [What still needs to be done]\n- [Known issues or blockers]\n\n### Questions\n- [New unclear aspects that need decisions]\n- [Uncertainties or concerns]\n\n---\n\n[Continue adding session entries chronologically]\n",
        "skills/dev-guided/references/template-runbook.md": "# Runbook\n\nThis document describes how to build, test, and validate the work in this development session, as well as when to pause for human feedback.\n\n## Build Instructions\n\n[How to build/compile the code]\n\n```bash\n# Example:\nnpm install\nnpm run build\n```\n\n## Test Instructions\n\n[How to run tests]\n\n```bash\n# Example:\nnpm test\nnpm run test:integration\n```\n\n## Run Instructions\n\n[How to run the application locally for manual testing]\n\n```bash\n# Example:\nnpm run dev\n# Then visit http://localhost:3000\n```\n\n## Validation Steps\n\n[Any additional validation steps beyond automated tests]\n\n- [ ] Manual testing checklist item 1\n- [ ] Manual testing checklist item 2\n- [ ] Performance check\n- [ ] Security review\n\n## Feedback Points\n\nThese are structured points where the agent must pause and ask for human input during implementation.\n\n### After [specific milestone or step]\n**Purpose:** [Why feedback is needed at this point]\n**Questions to ask:** [What specifically to verify or get approval on]\n\n### Before [specific action]\n**Purpose:** [Why approval is needed before proceeding]\n**Questions to ask:** [What to confirm with human]\n\n### When [specific condition occurs]\n**Purpose:** [Why this situation requires human input]\n**Questions to ask:** [What guidance is needed]\n\n---\n\n## Example Feedback Points\n\n### After implementing core authentication logic\n**Purpose:** Verify the authentication approach matches expectations before building dependent features\n**Questions to ask:**\n- Does the login flow work as expected?\n- Should we add any additional authentication factors?\n\n### Before making database schema changes\n**Purpose:** Schema changes are hard to reverse, need approval\n**Questions to ask:**\n- Review proposed schema changes\n- Confirm migration strategy\n\n### When encountering an unclear requirement\n**Purpose:** Avoid making assumptions about product behavior\n**Questions to ask:**\n- Clarify the expected behavior for [specific scenario]\n- Get decision on [unclear aspect]\n",
        "skills/nb-notes/SKILL.md": "---\nname: nb-notes\ndescription: Manage persistent notes and todos using the nb note-taking system. This skill should be used when capturing cross-session learnings, technical decisions, deferred tasks, or codebase patterns that should persist beyond the current conversation. Use proactively after solving bugs, making architectural decisions, or discovering important patterns. Triggers on requests like \"what did I learn yesterday\", \"check my notes\", \"what learnings do I have about X\", or \"capture insights\". Do NOT use for tracking current work-in-progress (use TodoWrite for that).\n---\n\n# nb Notes\n\n## Overview\n\nManage persistent notes and todos using `nb`, a command-line note-taking system. This skill enables Claude to capture insights, decisions, and deferred tasks that should persist across sessions, while keeping current work-in-progress tracked separately in TodoWrite.\n\n**Notebook Access:**\n- **Write access:** Only the `claude` notebook (for persisting information across Claude sessions)\n- **Read access:** All notebooks (for understanding user's recent learnings, reference materials, and context)\n- Users may organize their nb notebooks differently - check available notebooks with `nb notebooks` or look for organizational notes in the `claude` notebook\n\n## When to Use This Skill\n\n### Use nb for Persistent Information\n\n**Proactively create nb notes when:**\n- Solving a bug and understanding the root cause (tag: `#bug-fix`)\n- Making architectural or technical decisions (tag: `#technical-decision`)\n- Discovering patterns, conventions, or antipatterns in a codebase (tag: `#code-pattern`)\n- Learning about user preferences or working style (tag: `#preference`)\n- Finding workflow improvements or process discoveries (tag: `#workflow`)\n- Capturing insights that will be valuable in future sessions (tag: `#session-insight`)\n\n**Use nb todo/tasks for deferred work:**\n- Issues discovered during work that should be addressed later (tag: `#deferred-task`)\n- Follow-up tasks or improvements to make when time permits\n- Technical debt to track\n\n### Use TodoWrite for Current Work\n\nKeep using TodoWrite for:\n- Breaking down the current task into steps\n- Tracking work-in-progress during the active session\n- Managing what you're actively working on right now\n\n**Key distinction:** nb is for persistence across sessions, TodoWrite is for tracking active work within the current session.\n\n## Creating Notes\n\n### Standard Notes\n\nCreate markdown notes in the `claude` notebook with appropriate tags:\n\n```bash\nnb claude:add --type md --title \"Note Title\" --tags tag1,tag2 --content \"Note content here\"\n```\n\n**Example - Technical Decision:**\n```bash\nnb claude:add --type md \\\n  --title \"Use factory pattern for tool instantiation\" \\\n  --tags technical-decision,code-pattern \\\n  --content \"Decision: Implement factory pattern for creating tools in the MCP server.\n\nRationale:\n- Allows dynamic tool registration\n- Easier to test individual tools in isolation\n- Follows existing patterns in codebase\n\nImplementation: See ToolFactory in src/tools/factory.ts\"\n```\n\n**Example - Bug Fix:**\n```bash\nnb claude:add --type md \\\n  --title \"Race condition in async file watcher\" \\\n  --tags bug-fix,session-insight \\\n  --content \"Root cause: File watcher callbacks fired before initialization completed.\n\nSolution: Added initialization lock using async mutex. Files are queued during init and processed after lock is released.\n\nLocation: src/watchers/file-watcher.ts:145\"\n```\n\n**Example - Codebase Pattern:**\n```bash\nnb claude:add --type md \\\n  --title \"Error handling pattern: wrap with context\" \\\n  --tags code-pattern,preference \\\n  --content \"This codebase wraps errors with additional context rather than throwing new errors.\n\nPattern:\ncatch (err) {\n  throw Object.assign(err, { context: 'additional info' })\n}\n\nNOT:\ncatch (err) {\n  throw new Error(\\`Failed: \\${err.message}\\`)\n}\"\n```\n\n### Deferred Tasks\n\nUse `nb todo` or `nb tasks` for deferred work:\n\n```bash\n# Add a deferred task\nnb claude:todo add \"Refactor authentication module to use new JWT library\" --tags deferred-task,technical-decision\n\n# List deferred tasks\nnb claude:todo list\n\n# Complete a task\nnb claude:todo do <id>\n```\n\n## Searching Notes\n\nBefore creating a note, search to avoid duplicates and to leverage existing knowledge:\n\n```bash\n# Search by keyword\nnb claude:search \"authentication\"\n\n# Search by tag\nnb claude:search --tags technical-decision\n\n# List recent notes\nnb claude:list --limit 10\n\n# List notes with specific tags\nnb claude:list --tags code-pattern,preference\n```\n\n**When to search:**\n- Before starting work on a new area of the codebase\n- When encountering a familiar problem\n- When making decisions (check if similar decisions were made before)\n\n## Editing Notes\n\nUpdate existing notes when information changes or needs clarification:\n\n```bash\n# Edit a note\nnb claude:edit <id>\n\n# Show a note first to see its content\nnb claude:show <id>\n```\n\n## Note Quality Guidelines\n\n**Good notes are:**\n- **Specific**: Include file paths, line numbers, concrete examples\n- **Actionable**: Explain not just what, but why and how\n- **Searchable**: Use clear titles and appropriate tags\n- **Concise**: Focus on the essential information\n- **Evergreen**: Avoid temporal references (\"recently\", \"new\", \"old\")\n\n**Title conventions:**\n- 5-10 words\n- Present tense verbs for actions: \"Use factory pattern for tool creation\"\n- Nouns for concepts: \"Authentication flow in API layer\"\n- Include context: \"React components: Prefer composition over inheritance\"\n\n**Content structure:**\n- Start with the key insight or decision\n- Include rationale/context\n- Add implementation details or location references\n- Use code examples when helpful\n\n## Tag Reference\n\nStandard tags for organization:\n\n- `#technical-decision` - Architectural choices, framework decisions, design rationale\n- `#session-insight` - Important learnings or patterns discovered during work\n- `#deferred-task` - Issues or improvements to address later\n- `#code-pattern` - Common patterns, antipatterns, or conventions found in codebases\n- `#bug-fix` - Solutions to bugs and their root causes\n- `#workflow` - Process improvements or workflow discoveries\n- `#preference` - User preferences and working style notes\n\nApply multiple tags when appropriate.\n\n## Resources\n\n### references/nb_commands.md\n\nComplete reference for all nb commands, including detailed syntax for creating notes, todos, tasks, searching, and editing. Consult this file for command-line syntax details and additional examples.\n",
        "skills/nb-notes/references/nb_commands.md": "# nb Command Reference\n\n## Basic Commands\n\n### Creating Notes\n\n```bash\n# Add a markdown note to the claude notebook with tags\nnb claude:add --type md --title \"Note Title\" --tags tag1,tag2,tag3 --content \"Note content here\"\n\n# Add a note with content from stdin\necho \"Note content\" | nb claude:add --type md --title \"Note Title\" --tags tag1,tag2\n```\n\n### Creating Todos and Tasks\n\n```bash\n# Add a todo item to the claude notebook\nnb claude:todo add \"Task description\" --tags tag1,tag2\n\n# Add a task (nb tasks)\nnb claude:tasks add \"Task description\" --tags tag1,tag2\n\n# List todos\nnb claude:todo list\n\n# List tasks\nnb claude:tasks list\n\n# Complete a todo\nnb claude:todo do <id>\n\n# Complete a task\nnb claude:tasks do <id>\n```\n\n### Searching Notes\n\n```bash\n# Search all notes in claude notebook\nnb claude:search \"search term\"\n\n# Search notes with specific tags\nnb claude:search --tags technical-decision\n\n# List all notes in claude notebook\nnb claude:list\n\n# List notes with specific tags\nnb claude:list --tags session-insight,code-pattern\n```\n\n### Editing Notes\n\n```bash\n# Edit a note by ID or title\nnb claude:edit <id>\nnb claude:edit \"Note Title\"\n\n# Show a specific note\nnb claude:show <id>\n```\n\n### Viewing Notes\n\n```bash\n# Show a note's content\nnb claude:show <id>\n\n# Show recent notes\nnb claude:list --limit 10\n```\n\n## Notebook Structure\n\nAll Claude notes go in the `claude` notebook to keep them separate from personal notes.\n\n## Tagging Conventions\n\nUse these standard tags to categorize notes:\n\n- `#technical-decision` - Architectural choices, framework decisions, design rationale\n- `#session-insight` - Important learnings or patterns discovered during work\n- `#deferred-task` - Issues or improvements to address later (use nb todo/tasks)\n- `#code-pattern` - Common patterns, antipatterns, or conventions found in codebases\n- `#bug-fix` - Solutions to bugs and their root causes\n- `#workflow` - Process improvements or workflow discoveries\n- `#preference` - User preferences and working style notes\n\nMultiple tags can be applied to a single note when appropriate.\n\n## Note Title Conventions\n\n- Keep titles concise but descriptive (5-10 words)\n- Use present tense verbs for actions (\"Use factory pattern for tool creation\")\n- Use nouns for concepts (\"Authentication flow in API layer\")\n- Include context when helpful (\"React components: Prefer composition over inheritance\")\n\n## nb todo vs nb tasks\n\nBoth `nb todo` and `nb tasks` can be used for tracking deferred work:\n- Use whichever you prefer or are already using\n- Both support adding, listing, and completing items\n- Both support tags for organization\n",
        "skills/session-learner/SKILL.md": "---\nname: session-learner\ndescription: Extract and persist learnings from the current session. This skill should be used when the user wants Claude to analyze the conversation and capture insights, patterns, preferences, or knowledge discovered during work. Triggers on requests like \"learn from this session\", \"what did we learn\", or \"capture insights\".\n---\n\n# Session Learner\n\nAnalyze the current session to extract learnings and persist them to appropriate locations.\n\n## Workflow\n\n### Step 1: Analyze Session\n\nReview the entire conversation to identify learnings in these categories:\n\n1. **User Preferences** - Working style, communication preferences, tool preferences\n2. **Agent Failure Patterns** - Mistakes Claude made, misunderstandings, approaches that didn't work\n3. **Project Technical Patterns** - Code patterns, architecture decisions, project-specific conventions\n4. **Reusable Workflows** - Multi-step procedures that could become skills\n5. **Reference Knowledge** - Architectural decisions, domain knowledge, API behaviors\n\n### Step 2: Categorize by Destination\n\nMap each learning to its appropriate destination:\n\n| Learning Type | Destination | Rationale |\n|---------------|-------------|-----------|\n| User preferences | `~/.claude/CLAUDE.md` | Applies across all projects |\n| Agent failure patterns | `~/.claude/CLAUDE.md` | Prevents repeating mistakes globally |\n| Project technical patterns | Project `CLAUDE.md` | Project-specific guidance |\n| Reusable workflows | New skill | Procedural knowledge for reuse |\n| Reference knowledge | Project `docs/` folder | Documentation for future reference |\n\n### Step 3: Check for Conflicts\n\nBefore presenting findings, check if any learning contradicts existing content:\n\n1. Read the target file (user CLAUDE.md, project CLAUDE.md, or relevant docs)\n2. Identify any conflicts between new learnings and existing content\n3. Flag conflicts explicitly for user decision\n\n### Step 4: Present Findings\n\nPresent findings grouped by destination. For each group:\n\n1. State the destination file path\n2. List each learning with a brief description (1-2 sentences)\n3. If conflicts exist, show:\n   - The existing content\n   - The proposed new content\n   - Ask user to choose: keep existing, replace with new, or merge\n\nFormat:\n\n```\n## Learnings for ~/.claude/CLAUDE.md\n\n1. [Brief description of learning]\n2. [Brief description of learning]\n\n‚ö†Ô∏è CONFLICT: [description]\n   Existing: [current content]\n   Proposed: [new content]\n   Keep existing / Replace / Merge?\n\n## Learnings for [project]/CLAUDE.md\n\n1. [Brief description of learning]\n\n## Learnings for [project]/docs/\n\n1. [Brief description] ‚Üí docs/[filename].md\n\n## Potential New Skill\n\n1. [Workflow name]: [brief description]\n```\n\n### Step 5: Apply Approved Learnings\n\nAfter user approves (or modifies) findings:\n\n1. For CLAUDE.md files: Append to appropriate section, or create section if needed\n2. For docs/: Create or update the markdown file\n3. For new skills: Offer to create using the skill-creator skill\n\n## Guidelines\n\n- Keep learnings concise and actionable\n- Prefer specific examples over abstract principles\n- Do not duplicate information already in target files\n- When uncertain about destination, ask the user to choose\n- Learnings should be evergreen - no temporal references like \"today we learned\"\n",
        "skills/systematic-debugging/SKILL.md": "---\nname: systematic-debugging\ndescription: Structured debugging methodology for investigating and resolving technical issues. Use this skill when debugging any technical problem, investigating errors, or troubleshooting unexpected behavior to ensure root cause analysis rather than symptom treatment.\n---\n\n# Systematic Debugging Process\n\n## Overview\n\nThis skill provides a disciplined, phase-based approach to debugging that ensures root cause identification rather than symptom treatment. The methodology emphasizes systematic investigation, hypothesis testing, and minimal incremental fixes.\n\n## When to Use This Skill\n\nUse this skill whenever:\n- Debugging a technical issue or error\n- Investigating unexpected behavior\n- Troubleshooting test failures\n- Resolving performance problems\n- Analyzing system failures\n\n## Core Principle\n\n**ALWAYS find the root cause of any issue. NEVER fix a symptom or add a workaround instead of finding the root cause, even if it appears faster or more expedient.**\n\n## Four-Phase Debugging Framework\n\n### Phase 1: Root Cause Investigation\n\n**Perform BEFORE attempting any fixes.** This phase focuses on understanding the problem completely.\n\n#### Read Error Messages Carefully\n- Don't skip past errors or warnings\n- Error messages often contain the exact solution\n- Note stack traces, line numbers, and context\n- Look for patterns in multiple error occurrences\n\n#### Reproduce Consistently\n- Ensure the issue can be reliably reproduced\n- Identify the minimal steps to trigger the problem\n- Note any conditions that affect reproducibility\n- Document the exact environment and context\n\n#### Check Recent Changes\n- Review what changed that could have caused this\n- Use `git diff` to examine recent modifications\n- Check recent commits and their impact\n- Consider dependency updates or configuration changes\n\n### Phase 2: Pattern Analysis\n\nThis phase involves comparing working and non-working states to identify differences.\n\n#### Find Working Examples\n- Locate similar working code in the same codebase\n- Identify what makes the working example successful\n- Note the context and dependencies of working code\n\n#### Compare Against References\n- If implementing a pattern, read the reference implementation completely\n- Don't skim documentation‚Äîread it thoroughly\n- Understand the intended usage and requirements\n- Identify any prerequisites or setup steps\n\n#### Identify Differences\n- What's different between working and broken code?\n- Compare structure, dependencies, and configuration\n- Look for missing imports, incorrect types, or wrong parameters\n- Check for environmental differences\n\n#### Understand Dependencies\n- What other components does this code depend on?\n- Are there configuration files or settings required?\n- What initialization or setup is needed?\n- Are there version compatibility issues?\n\n### Phase 3: Hypothesis and Testing\n\nThis phase requires forming clear hypotheses and testing them methodically.\n\n#### 1. Form Single Hypothesis\n- State clearly what you think is the root cause\n- Base the hypothesis on evidence from previous phases\n- Be specific about the suspected problem\n- Example: \"The error occurs because X is undefined when Y runs\"\n\n#### 2. Test Minimally\n- Make the smallest possible change to test the hypothesis\n- Change only ONE thing at a time\n- Avoid adding multiple fixes simultaneously\n- Keep changes reversible and isolated\n\n#### 3. Verify Before Continuing\n- Did the test work? Did it fix the problem?\n- If not, form a new hypothesis‚Äîdon't add more fixes\n- Understand why the hypothesis was wrong\n- Learn from failed hypotheses to refine the investigation\n\n#### 4. When You Don't Know\n- Say \"I don't understand X\" rather than pretending to know\n- Ask for clarification or additional information\n- Admit knowledge gaps honestly\n- Seek help when needed\n\n### Phase 4: Implementation Rules\n\nOnce the root cause is confirmed, follow these rules during implementation:\n\n#### Always Have a Failing Test Case\n- Create the simplest possible test that reproduces the issue\n- If there's no test framework, write a one-off test script\n- The test should fail before the fix and pass after\n- Keep the test case minimal and focused\n\n#### Never Add Multiple Fixes at Once\n- Fix one thing at a time\n- Test after each change\n- Understand the impact of each modification\n- Avoid the temptation to \"fix everything\"\n\n#### Never Claim to Implement a Pattern Without Reading It\n- Read reference implementations completely first\n- Understand the pattern thoroughly before implementing\n- Don't guess at how something should work\n- Follow documented patterns exactly\n\n#### Always Test After Each Change\n- Run tests immediately after each modification\n- Verify the fix works as expected\n- Check for regressions in other functionality\n- Confirm the original error is resolved\n\n#### If First Fix Doesn't Work, STOP and Re-analyze\n- Don't pile on additional fixes\n- Return to Phase 1 or Phase 2\n- Form a new hypothesis based on new information\n- Avoid the \"shotgun debugging\" anti-pattern\n\n## Anti-Patterns to Avoid\n\n- **Symptom Treatment**: Fixing what appears broken without understanding why\n- **Shotgun Debugging**: Making multiple changes hoping something works\n- **Assumption-Based Fixes**: Guessing at solutions without investigation\n- **Workaround Mentality**: Adding code to bypass problems rather than fixing them\n- **Impatient Debugging**: Rushing to fix without understanding the root cause\n"
      },
      "plugins": [
        {
          "name": "jun-dev-workflows",
          "source": "./",
          "description": "Jun's development workflow commands and skills for Claude Code",
          "version": "1.0.0",
          "author": {
            "name": "Jun"
          },
          "keywords": [
            "workflow",
            "tdd",
            "git",
            "debugging",
            "development"
          ],
          "category": "development",
          "categories": [
            "debugging",
            "development",
            "git",
            "tdd",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add anexpn/claude-plugins",
            "/plugin install jun-dev-workflows@jun-workflows"
          ]
        }
      ]
    }
  ]
}