{
  "author": {
    "id": "vercel",
    "display_name": "Vercel",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/14985020?v=4",
    "url": "https://github.com/vercel",
    "bio": "Develop. Preview. Ship. Creators of Next.js.",
    "stats": {
      "total_marketplaces": 2,
      "total_plugins": 2,
      "total_commands": 3,
      "total_skills": 4,
      "total_stars": 137400,
      "total_forks": 30360
    }
  },
  "marketplaces": [
    {
      "name": "nextjs",
      "version": null,
      "description": "Expert guidance for Next.js Cache Components and Partial Prerendering (PPR). Proactively activates in projects with cacheComponents enabled.",
      "owner_info": {
        "name": "Vercel",
        "url": "https://vercel.com"
      },
      "keywords": [],
      "repo_full_name": "vercel/next.js",
      "repo_url": "https://github.com/vercel/next.js",
      "repo_description": "The React Framework",
      "homepage": "https://nextjs.org",
      "signals": {
        "stars": 137395,
        "forks": 30360,
        "pushed_at": "2026-01-29T23:07:43Z",
        "created_at": "2016-10-05T23:32:51Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 455
        },
        {
          "path": ".claude-plugin/plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/README.md",
          "type": "blob",
          "size": 2724
        },
        {
          "path": ".claude-plugin/plugins/cache-components",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/cache-components/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/cache-components/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 707
        },
        {
          "path": ".claude-plugin/plugins/cache-components/README.md",
          "type": "blob",
          "size": 3240
        },
        {
          "path": ".claude-plugin/plugins/cache-components/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/cache-components/skills/cache-components",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/cache-components/skills/cache-components/PATTERNS.md",
          "type": "blob",
          "size": 19855
        },
        {
          "path": ".claude-plugin/plugins/cache-components/skills/cache-components/REFERENCE.md",
          "type": "blob",
          "size": 30693
        },
        {
          "path": ".claude-plugin/plugins/cache-components/skills/cache-components/SKILL.md",
          "type": "blob",
          "size": 16338
        },
        {
          "path": ".claude-plugin/plugins/cache-components/skills/cache-components/TROUBLESHOOTING.md",
          "type": "blob",
          "size": 16601
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"nextjs\",\n  \"owner\": {\n    \"name\": \"Vercel\",\n    \"url\": \"https://vercel.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"cache-components\",\n      \"source\": \"./plugins/cache-components\",\n      \"description\": \"Expert guidance for Next.js Cache Components and Partial Prerendering (PPR). Proactively activates in projects with cacheComponents enabled.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Next.js Team\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugins/README.md": "# Next.js Claude Code Plugins\n\nThis directory contains Claude Code plugins for Next.js development.\n\n## Using the Next.js Plugin Marketplace\n\nThe Next.js repository serves as a Claude Code plugin marketplace. Team members and contributors can install plugins directly from this repo.\n\n### Quick Start\n\n```bash\n# Add the Next.js marketplace\n/plugin marketplace add vercel/next.js\n\n# List available plugins\n/plugin list\n\n# Install a plugin\n/plugin install cache-components@nextjs\n```\n\n### Available Plugins\n\n| Plugin | Description |\n|--------|-------------|\n| `cache-components` | Expert guidance for Cache Components and PPR |\n\n## For Team Members\n\nTo auto-enable plugins for everyone working in a Next.js project, add to `.claude/settings.json`:\n\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"nextjs\": {\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"vercel/next.js\"\n      }\n    }\n  },\n  \"enabledPlugins\": {\n    \"cache-components@nextjs\": true\n  }\n}\n```\n\n## Creating New Plugins\n\nTo add a new plugin to the marketplace:\n\n### 1. Create Plugin Directory\n\n```bash\nmkdir -p .claude-plugin/plugins/my-plugin/.claude-plugin\nmkdir -p .claude-plugin/plugins/my-plugin/skills/my-skill\n```\n\n### 2. Create Plugin Manifest\n\n**File**: `.claude-plugin/plugins/my-plugin/.claude-plugin/plugin.json`\n\n```json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"description\": \"What the plugin does\",\n  \"author\": {\n    \"name\": \"Next.js Team\"\n  }\n}\n```\n\n### 3. Create Skill\n\n**File**: `.claude-plugin/plugins/my-plugin/skills/my-skill/SKILL.md`\n\n```yaml\n---\nname: my-skill\ndescription: When to use this skill\n---\n\n# My Skill\n\nInstructions for Claude...\n```\n\n### 4. Register in Marketplace\n\nAdd to `.claude-plugin/marketplace.json`:\n\n```json\n{\n  \"plugins\": [\n    {\n      \"name\": \"my-plugin\",\n      \"source\": \"./plugins/my-plugin\",\n      \"description\": \"What it does\"\n    }\n  ]\n}\n```\n\n### 5. Test Locally\n\n```bash\nclaude --plugin-dir .claude-plugin/plugins/my-plugin\n```\n\n## Plugin Structure\n\n```\n.claude-plugin/\n├── marketplace.json                       ← Marketplace catalog\n└── plugins/\n    ├── README.md                          ← This file\n    └── cache-components/\n        ├── .claude-plugin/\n        │   └── plugin.json                ← Plugin manifest\n        ├── skills/\n        │   └── cache-components/\n        │       ├── SKILL.md               ← Main skill file\n        │       ├── REFERENCE.md           ← API reference\n        │       ├── PATTERNS.md            ← Usage patterns\n        │       └── TROUBLESHOOTING.md     ← Debugging guide\n        └── README.md                      ← Plugin documentation\n```\n",
        ".claude-plugin/plugins/cache-components/.claude-plugin/plugin.json": "{\n  \"name\": \"cache-components\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Expert guidance for Next.js Cache Components and Partial Prerendering (PPR). Proactively activates in projects with cacheComponents: true, providing patterns for 'use cache' directive, cacheLife(), cacheTag(), cache invalidation, and parameter permutation rendering.\",\n  \"author\": {\n    \"name\": \"Next.js Team\",\n    \"url\": \"https://nextjs.org\"\n  },\n  \"homepage\": \"https://nextjs.org/docs/app/building-your-application/caching\",\n  \"repository\": \"https://github.com/vercel/next.js\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"nextjs\",\n    \"cache\",\n    \"ppr\",\n    \"partial-prerendering\",\n    \"react-server-components\",\n    \"use-cache\"\n  ]\n}\n",
        ".claude-plugin/plugins/cache-components/README.md": "# Cache Components Plugin for Claude Code\n\nExpert guidance for Next.js Cache Components and Partial Prerendering (PPR).\n\n## Features\n\nThis plugin provides a comprehensive skill that:\n\n- **Proactively activates** in projects with `cacheComponents: true`\n- Teaches the `'use cache'` directive, `cacheLife()`, `cacheTag()`, and invalidation APIs\n- Explains **parameter permutation rendering** and subshell generation\n- Covers migration from deprecated `revalidate`/`dynamic` segment configs\n- Provides build-time error solutions and debugging guidance\n\n## Installation\n\n### Step 1: Add the Next.js Marketplace\n\n```\n/plugin marketplace add vercel/next.js\n```\n\n### Step 2: Install the Plugin\n\n```\n/plugin install cache-components@nextjs\n```\n\nOr install via CLI:\n\n```bash\nclaude plugin install cache-components@nextjs\n```\n\n### Step 3 (Optional): Enable for Your Team\n\nAdd to your project's `.claude/settings.json` to auto-enable for all team members:\n\n```json\n{\n  \"enabledPlugins\": {\n    \"cache-components@nextjs\": true\n  }\n}\n```\n\n## What's Included\n\n| File | Description |\n|------|-------------|\n| `SKILL.md` | Core concepts, APIs, and proactive application guidelines |\n| `REFERENCE.md` | Complete API reference, generateStaticParams, deprecated configs |\n| `PATTERNS.md` | 12 production patterns including subshell composition |\n| `TROUBLESHOOTING.md` | Build errors, debugging techniques, common issues |\n\n## Usage\n\nOnce installed, the skill automatically activates when:\n\n1. You're working in a Next.js project with `cacheComponents: true`\n2. You ask about caching, PPR, or the `'use cache'` directive\n3. You're writing React Server Components or Server Actions\n\n### Example Triggers\n\n- \"How do I cache this data fetching function?\"\n- \"What's the difference between updateTag and revalidateTag?\"\n- \"I'm getting a build error about uncached data outside Suspense\"\n- \"Help me set up generateStaticParams for my product pages\"\n\n## Key Concepts Covered\n\n### Parameter Permutation Rendering\n\nWhen you provide `generateStaticParams`, Next.js renders ALL permutations:\n\n```\ngenerateStaticParams returns:\n  [{ category: 'jackets', slug: 'bomber' }]\n\nNext.js renders:\n  /products/jackets/bomber     ← Complete page\n  /products/jackets/[slug]     ← Category subshell (reusable!)\n  /products/[category]/[slug]  ← Fallback shell\n```\n\n### Deprecated Segment Configs\n\n| Old (Deprecated) | New (Cache Components) |\n|------------------|------------------------|\n| `export const revalidate = 3600` | `cacheLife('hours')` inside `'use cache'` |\n| `export const dynamic = 'force-static'` | Use `'use cache'` + Suspense |\n\n## Contributing\n\nThis plugin lives in the Next.js repository at `.claude-plugin/plugins/cache-components/`.\n\nTo contribute improvements:\n\n1. Edit files in `.claude-plugin/plugins/cache-components/skills/cache-components/`\n2. Test locally with `claude --plugin-dir .claude-plugin/plugins/cache-components`\n3. Submit a PR to the Next.js repository\n\n## Version History\n\n### 1.0.0\n\n- Initial release\n- Covers `'use cache'`, `cacheLife()`, `cacheTag()`, `updateTag()`, `revalidateTag()`\n- Parameter permutation rendering and subshell generation\n- Migration guide from deprecated segment configs\n- Build-time feedback and troubleshooting\n",
        ".claude-plugin/plugins/cache-components/skills/cache-components/PATTERNS.md": "# Cache Components Patterns & Recipes\n\nCommon patterns for implementing Cache Components effectively.\n\n## Pattern 1: Static + Cached + Dynamic Page\n\nThe foundational pattern for Partial Prerendering:\n\n```tsx\nimport { Suspense } from 'react'\nimport { cacheLife } from 'next/cache'\n\n// Static - no special handling needed\nfunction Header() {\n  return <header>My Blog</header>\n}\n\n// Cached - included in static shell\nasync function FeaturedPosts() {\n  'use cache'\n  cacheLife('hours')\n\n  const posts = await db.posts.findMany({\n    where: { featured: true },\n    take: 5,\n  })\n\n  return (\n    <section>\n      {posts.map((post) => (\n        <PostCard key={post.id} post={post} />\n      ))}\n    </section>\n  )\n}\n\n// Dynamic - streams at request time\nasync function PersonalizedFeed() {\n  const session = await getSession()\n  const feed = await db.posts.findMany({\n    where: { authorId: { in: session.following } },\n  })\n\n  return <FeedList posts={feed} />\n}\n\n// Page composition\nexport default async function HomePage() {\n  return (\n    <>\n      <Header />\n      <FeaturedPosts />\n      <Suspense fallback={<FeedSkeleton />}>\n        <PersonalizedFeed />\n      </Suspense>\n    </>\n  )\n}\n```\n\n---\n\n## Pattern 2: Read-Your-Own-Writes with Server Actions\n\nEnsure users see their changes immediately:\n\n```tsx\n// components/posts.tsx\nimport { cacheTag, cacheLife } from 'next/cache'\n\nasync function PostsList() {\n  'use cache'\n  cacheTag('posts')\n  cacheLife('hours')\n\n  const posts = await db.posts.findMany({ orderBy: { createdAt: 'desc' } })\n  return (\n    <ul>\n      {posts.map((p) => (\n        <PostItem key={p.id} post={p} />\n      ))}\n    </ul>\n  )\n}\n\n// actions/posts.ts\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  const post = await db.posts.create({\n    data: {\n      title: formData.get('title') as string,\n      content: formData.get('content') as string,\n    },\n  })\n\n  // Immediate invalidation - user sees new post right away\n  updateTag('posts')\n\n  return { success: true, postId: post.id }\n}\n\n// components/create-post-form.tsx\n'use client'\nimport { useTransition } from 'react'\nimport { createPost } from '@/actions/posts'\n\nexport function CreatePostForm() {\n  const [isPending, startTransition] = useTransition()\n\n  return (\n    <form\n      action={(formData) => {\n        startTransition(() => createPost(formData))\n      }}\n    >\n      <input name=\"title\" required />\n      <textarea name=\"content\" required />\n      <button disabled={isPending}>\n        {isPending ? 'Creating...' : 'Create Post'}\n      </button>\n    </form>\n  )\n}\n```\n\n---\n\n## Pattern 3: Granular Cache Invalidation\n\nTag caches at multiple levels for precise invalidation:\n\n```tsx\n// Cached with multiple tags\nasync function BlogPost({ postId }: { postId: string }) {\n  'use cache'\n  cacheTag('posts', `post-${postId}`)\n  cacheLife('days')\n\n  const post = await db.posts.findUnique({\n    where: { id: postId },\n    include: { author: true, comments: true },\n  })\n\n  return <Article post={post} />\n}\n\nasync function AuthorPosts({ authorId }: { authorId: string }) {\n  'use cache'\n  cacheTag('posts', `author-${authorId}`)\n  cacheLife('hours')\n\n  const posts = await db.posts.findMany({\n    where: { authorId },\n  })\n\n  return <PostGrid posts={posts} />\n}\n\n// Server actions with targeted invalidation\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function updatePost(postId: string, data: FormData) {\n  const post = await db.posts.update({\n    where: { id: postId },\n    data: { title: data.get('title'), content: data.get('content') },\n  })\n\n  // Invalidate specific post only\n  updateTag(`post-${postId}`)\n}\n\nexport async function deleteAuthorPosts(authorId: string) {\n  await db.posts.deleteMany({ where: { authorId } })\n\n  // Invalidate all author's posts\n  updateTag(`author-${authorId}`)\n}\n\nexport async function clearAllPosts() {\n  await db.posts.deleteMany()\n\n  // Nuclear option - invalidate everything tagged 'posts'\n  updateTag('posts')\n}\n```\n\n---\n\n## Pattern 4: Cached Data Fetching Functions\n\nCreate reusable cached data fetchers:\n\n```tsx\n// lib/data.ts\nimport { cacheTag, cacheLife } from 'next/cache'\n\nexport async function getUser(userId: string) {\n  'use cache'\n  cacheTag('users', `user-${userId}`)\n  cacheLife('hours')\n\n  return db.users.findUnique({ where: { id: userId } })\n}\n\nexport async function getPostsByCategory(category: string) {\n  'use cache'\n  cacheTag('posts', `category-${category}`)\n  cacheLife('minutes')\n\n  return db.posts.findMany({\n    where: { category },\n    orderBy: { createdAt: 'desc' },\n  })\n}\n\nexport async function getPopularProducts() {\n  'use cache'\n  cacheTag('products', 'popular')\n  cacheLife('hours')\n\n  return db.products.findMany({\n    orderBy: { salesCount: 'desc' },\n    take: 10,\n  })\n}\n\n// Usage in components\nasync function Sidebar() {\n  const popular = await getPopularProducts()\n  return <ProductList products={popular} />\n}\n```\n\n---\n\n## Pattern 5: Stale-While-Revalidate for Background Updates\n\nUse `revalidateTag` for non-critical updates:\n\n```tsx\n// For background analytics or non-user-facing updates\n'use server'\nimport { revalidateTag } from 'next/cache'\n\nexport async function trackView(postId: string) {\n  await db.posts.update({\n    where: { id: postId },\n    data: { views: { increment: 1 } },\n  })\n\n  // Background revalidation - old count shown while updating\n  revalidateTag(`post-${postId}`, 'max')\n}\n\n// For user-facing mutations, use updateTag instead\nexport async function likePost(postId: string) {\n  await db.likes.create({ data: { postId, userId: getCurrentUserId() } })\n\n  // Immediate - user sees their like right away\n  updateTag(`post-${postId}`)\n}\n```\n\n---\n\n## Pattern 6: Conditional Caching Based on Content\n\nCache based on content characteristics:\n\n```tsx\nasync function ContentBlock({ id }: { id: string }) {\n  'use cache'\n\n  const content = await db.content.findUnique({ where: { id } })\n\n  // Adjust cache life based on content type\n  if (content.type === 'static') {\n    cacheLife('max')\n    cacheTag('static-content')\n  } else if (content.type === 'news') {\n    cacheLife('minutes')\n    cacheTag('news', `news-${id}`)\n  } else {\n    cacheLife('default')\n    cacheTag('content', `content-${id}`)\n  }\n\n  return <ContentRenderer content={content} />\n}\n```\n\n---\n\n## Pattern 7: Nested Cached Components\n\nCompose cached components for fine-grained caching:\n\n```tsx\n// Each component caches independently\nasync function Header() {\n  'use cache'\n  cacheTag('layout', 'header')\n  cacheLife('days')\n\n  const nav = await db.navigation.findFirst()\n  return <Nav items={nav.items} />\n}\n\nasync function Footer() {\n  'use cache'\n  cacheTag('layout', 'footer')\n  cacheLife('days')\n\n  const footer = await db.footer.findFirst()\n  return <FooterContent data={footer} />\n}\n\nasync function Sidebar({ category }: { category: string }) {\n  'use cache'\n  cacheTag('sidebar', `category-${category}`)\n  cacheLife('hours')\n\n  const related = await db.posts.findMany({\n    where: { category },\n    take: 5,\n  })\n  return <RelatedPosts posts={related} />\n}\n\n// Page composes cached components\nexport default async function BlogLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: { category: string }\n}) {\n  return (\n    <>\n      <Header />\n      <main>\n        {children}\n        <Sidebar category={params.category} />\n      </main>\n      <Footer />\n    </>\n  )\n}\n```\n\n---\n\n## Pattern 8: E-commerce Product Page\n\nComplete example for e-commerce:\n\n```tsx\n// app/products/[id]/page.tsx\nimport { Suspense } from 'react'\nimport { cacheTag, cacheLife } from 'next/cache'\n\n// Cached product details (changes rarely)\nasync function ProductDetails({ productId }: { productId: string }) {\n  'use cache'\n  cacheTag('products', `product-${productId}`)\n  cacheLife('hours')\n\n  const product = await db.products.findUnique({\n    where: { id: productId },\n    include: { images: true, specifications: true },\n  })\n\n  return (\n    <div>\n      <ProductGallery images={product.images} />\n      <ProductInfo product={product} />\n      <Specifications specs={product.specifications} />\n    </div>\n  )\n}\n\n// Cached reviews (moderate change frequency)\nasync function ProductReviews({ productId }: { productId: string }) {\n  'use cache'\n  cacheTag(`product-${productId}-reviews`)\n  cacheLife('minutes')\n\n  const reviews = await db.reviews.findMany({\n    where: { productId },\n    orderBy: { createdAt: 'desc' },\n    take: 10,\n  })\n\n  return <ReviewsList reviews={reviews} />\n}\n\n// Dynamic inventory (real-time)\nasync function InventoryStatus({ productId }: { productId: string }) {\n  // No cache - always fresh\n  const inventory = await db.inventory.findUnique({\n    where: { productId },\n  })\n\n  return (\n    <div>\n      {inventory.quantity > 0 ? (\n        <span className=\"text-green-600\">In Stock ({inventory.quantity})</span>\n      ) : (\n        <span className=\"text-red-600\">Out of Stock</span>\n      )}\n    </div>\n  )\n}\n\n// Page composition\nexport default async function ProductPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n\n  return (\n    <>\n      <ProductDetails productId={id} />\n\n      <Suspense fallback={<InventorySkeleton />}>\n        <InventoryStatus productId={id} />\n      </Suspense>\n\n      {/* Suspense around cached components:\n          - At BUILD TIME (PPR): Cached content is pre-rendered into the static shell,\n            so the fallback is never shown for initial page loads.\n          - At RUNTIME (cache miss/expiration): When the cache expires or on cold start,\n            Suspense shows the fallback while fresh data loads.\n          - For long-lived caches ('minutes', 'hours', 'days'), Suspense is optional\n            but improves UX during the rare cache miss. */}\n      <Suspense fallback={<ReviewsSkeleton />}>\n        <ProductReviews productId={id} />\n      </Suspense>\n    </>\n  )\n}\n```\n\n---\n\n## Pattern 9: Multi-tenant SaaS Application\n\nHandle tenant-specific caching:\n\n```tsx\n// lib/tenant.ts\nexport async function getTenantId() {\n  const host = (await headers()).get('host')\n  return host?.split('.')[0] // subdomain as tenant ID\n}\n\n// Tenant-scoped cached data\nasync function TenantDashboard({ tenantId }: { tenantId: string }) {\n  'use cache'\n  cacheTag(`tenant-${tenantId}`, 'dashboards')\n  cacheLife('minutes')\n\n  const data = await db.dashboards.findFirst({\n    where: { tenantId },\n  })\n\n  return <Dashboard data={data} />\n}\n\n// Page with tenant context\nexport default function DashboardPage() {\n  return (\n    <Suspense fallback={<DashboardSkeleton />}>\n      <DashboardLoader />\n    </Suspense>\n  )\n}\n\nasync function DashboardLoader() {\n  const tenantId = await getTenantId()\n  return <TenantDashboard tenantId={tenantId} />\n}\n\n// Tenant-specific invalidation\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function updateTenantSettings(data: FormData) {\n  const tenantId = await getTenantId()\n\n  await db.settings.update({\n    where: { tenantId },\n    data: {\n      /* ... */\n    },\n  })\n\n  // Only invalidate this tenant's cache\n  updateTag(`tenant-${tenantId}`)\n}\n```\n\n---\n\n## Pattern 10: Subshell Composition with generateStaticParams\n\nLeverage parameter permutations to create reusable subshells:\n\n```tsx\n// app/products/[category]/[slug]/page.tsx\nimport { Suspense } from 'react'\nimport { cacheLife, cacheTag } from 'next/cache'\n\n// Product details - uses both params\nasync function ProductDetails({\n  category,\n  slug,\n}: {\n  category: string\n  slug: string\n}) {\n  'use cache'\n  cacheTag('products', `product-${slug}`)\n  cacheLife('hours')\n\n  const product = await db.products.findUnique({\n    where: { category, slug },\n  })\n\n  return <ProductCard product={product} />\n}\n\nexport default async function ProductPage({\n  params,\n}: {\n  params: Promise<{ category: string; slug: string }>\n}) {\n  const { category, slug } = await params\n\n  return <ProductDetails category={category} slug={slug} />\n}\n\n// Provide params to enable subshell generation\nexport async function generateStaticParams() {\n  const products = await db.products.findMany({\n    select: { category: true, slug: true },\n    take: 100,\n  })\n  return products.map(({ category, slug }) => ({ category, slug }))\n}\n```\n\n```tsx\n// app/products/[category]/layout.tsx\nimport { Suspense } from 'react'\nimport { cacheLife, cacheTag } from 'next/cache'\n\n// Category header - uses only category param\nasync function CategoryHeader({ category }: { category: string }) {\n  'use cache'\n  cacheTag('categories', `category-${category}`)\n  cacheLife('days')\n\n  const cat = await db.categories.findUnique({ where: { slug: category } })\n  return (\n    <header>\n      <h1>{cat.name}</h1>\n      <p>{cat.description}</p>\n    </header>\n  )\n}\n\nexport default async function CategoryLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise<{ category: string }>\n}) {\n  const { category } = await params\n\n  return (\n    <>\n      <CategoryHeader category={category} />\n      {/* Suspense enables subshell generation */}\n      <Suspense fallback={<ProductSkeleton />}>{children}</Suspense>\n    </>\n  )\n}\n```\n\n**Result**: When users navigate to `/products/jackets/unknown-jacket`:\n\n1. Category subshell (`/products/jackets/[slug]`) served instantly\n2. Product details stream in as they load\n3. Future visits to any jacket product reuse the category shell\n\n---\n\n## Pattern 11: Hierarchical Params for Deep Routes\n\nFor deeply nested routes, structure layouts to maximize subshell reuse:\n\n```tsx\n// Route: /store/[region]/[category]/[productId]\n\n// app/store/[region]/layout.tsx\nexport default async function RegionLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise<{ region: string }>\n}) {\n  const { region } = await params\n\n  return (\n    <>\n      <RegionHeader region={region} /> {/* Cached */}\n      <RegionPromos region={region} /> {/* Cached */}\n      <Suspense>{children}</Suspense> {/* Subshell boundary */}\n    </>\n  )\n}\n\n// app/store/[region]/[category]/layout.tsx\nexport default async function CategoryLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise<{ region: string; category: string }>\n}) {\n  const { region, category } = await params\n\n  return (\n    <>\n      <CategoryNav region={region} category={category} /> {/* Cached */}\n      <Suspense>{children}</Suspense> {/* Subshell boundary */}\n    </>\n  )\n}\n\n// app/store/[region]/[category]/[productId]/page.tsx\nexport default async function ProductPage({\n  params,\n}: {\n  params: Promise<{ region: string; category: string; productId: string }>\n}) {\n  const { region, category, productId } = await params\n\n  return <ProductDetails region={region} productId={productId} />\n}\n\nexport async function generateStaticParams() {\n  // Return popular products - subshells generated for all unique region/category combos\n  return [\n    { region: 'us', category: 'electronics', productId: 'iphone-16' },\n    { region: 'us', category: 'electronics', productId: 'macbook-pro' },\n    { region: 'us', category: 'clothing', productId: 'hoodie-xl' },\n    { region: 'eu', category: 'electronics', productId: 'iphone-16' },\n  ]\n}\n```\n\n**Generated subshells:**\n\n- `/store/us/[category]/[productId]` - US region shell\n- `/store/eu/[category]/[productId]` - EU region shell\n- `/store/us/electronics/[productId]` - US Electronics shell\n- `/store/us/clothing/[productId]` - US Clothing shell\n- `/store/eu/electronics/[productId]` - EU Electronics shell\n\n---\n\n## When to Use Suspense with Cached Components\n\nUnderstanding when Suspense is required vs. optional for cached components:\n\n### Dynamic Components (no cache) → Suspense Required\n\n```tsx\n// Dynamic content MUST have Suspense for streaming\nasync function PersonalizedFeed() {\n  const session = await getSession() // Dynamic - reads cookies\n  const feed = await fetchFeed(session.userId)\n  return <Feed posts={feed} />\n}\n\nexport default function Page() {\n  return (\n    <Suspense fallback={<FeedSkeleton />}>\n      <PersonalizedFeed />\n    </Suspense>\n  )\n}\n```\n\n### Cached Components → Suspense Optional (but recommended)\n\n```tsx\n// Cached content: Suspense is optional but improves UX\nasync function ProductReviews({ productId }: { productId: string }) {\n  'use cache'\n  cacheLife('minutes')\n  const reviews = await fetchReviews(productId)\n  return <ReviewsList reviews={reviews} />\n}\n\n// ✅ With Suspense - handles cache miss gracefully\n<Suspense fallback={<ReviewsSkeleton />}>\n  <ProductReviews productId={id} />\n</Suspense>\n\n// ✅ Without Suspense - also valid for long-lived caches\n<ProductReviews productId={id} />\n```\n\n### Why Cached Components Don't Always Need Suspense\n\n| Scenario | What Happens | Suspense Needed? |\n|----------|--------------|------------------|\n| **Build time (PPR enabled)** | Content pre-rendered into static shell | No - fallback never shown |\n| **Runtime - cache hit** | Cached result returned immediately | No - no suspension |\n| **Runtime - cache miss** | Async function executes, component suspends | Yes - for better UX |\n\n### Recommendations by Cache Lifetime\n\n| Cache Lifetime | Suspense Recommendation | Reasoning |\n|----------------|------------------------|-----------|\n| `'seconds'` | **Recommended** | Frequent cache misses |\n| `'minutes'` | Optional | ~5 min expiry, occasional misses |\n| `'hours'` / `'days'` | Optional | Rare cache misses |\n| `'max'` | Not needed | Essentially static |\n\n### The Trade-off\n\n**Without Suspense**: On cache miss, the page waits for data before rendering anything downstream. For long-lived caches, this is rare and brief.\n\n**With Suspense**: On cache miss, users see the skeleton immediately while data loads. Better perceived performance, slightly more code.\n\n**Rule of thumb**: When in doubt, add Suspense. It never hurts and handles edge cases gracefully.\n\n---\n\n## Anti-Patterns to Avoid\n\n### ❌ Caching user-specific data without parameters\n\n```tsx\n// BAD: Same cache for all users\nasync function UserProfile() {\n  'use cache'\n  const user = await getCurrentUser() // Different per user!\n  return <Profile user={user} />\n}\n\n// GOOD: User ID as parameter (becomes cache key)\nasync function UserProfile({ userId }: { userId: string }) {\n  'use cache'\n  cacheTag(`user-${userId}`)\n  const user = await db.users.findUnique({ where: { id: userId } })\n  return <Profile user={user} />\n}\n```\n\n### ❌ Over-caching volatile data\n\n```tsx\n// BAD: Caching real-time data\nasync function StockPrice({ symbol }: { symbol: string }) {\n  'use cache'\n  cacheLife('hours') // Stale prices!\n  return await fetchStockPrice(symbol)\n}\n\n// GOOD: Don't cache, or use very short cache\nasync function StockPrice({ symbol }: { symbol: string }) {\n  'use cache'\n  cacheLife('seconds') // 1 second max\n  return await fetchStockPrice(symbol)\n}\n\n// BETTER: No cache for truly real-time\nasync function StockPrice({ symbol }: { symbol: string }) {\n  return await fetchStockPrice(symbol)\n}\n```\n\n### ❌ Forgetting Suspense for dynamic content\n\n```tsx\n// BAD: No fallback for DYNAMIC content - breaks streaming\nexport default async function Page() {\n  return (\n    <>\n      <CachedHeader />\n      <DynamicContent /> {/* Dynamic - NEEDS Suspense */}\n    </>\n  )\n}\n\n// GOOD: Proper Suspense boundary for dynamic content\nexport default async function Page() {\n  return (\n    <>\n      <CachedHeader />\n      <Suspense fallback={<ContentSkeleton />}>\n        <DynamicContent />\n      </Suspense>\n    </>\n  )\n}\n\n// ALSO GOOD: Cached content without Suspense (optional for long-lived caches)\nexport default async function Page() {\n  return (\n    <>\n      <CachedHeader />       {/* 'use cache' - no Suspense needed */}\n      <CachedSidebar />      {/* 'use cache' - no Suspense needed */}\n      <Suspense fallback={<ContentSkeleton />}>\n        <DynamicContent />   {/* Dynamic - Suspense required */}\n      </Suspense>\n    </>\n  )\n}\n```\n",
        ".claude-plugin/plugins/cache-components/skills/cache-components/REFERENCE.md": "# Cache Components API Reference\n\nComplete API reference for Next.js Cache Components.\n\n## Directive: `'use cache'`\n\nMarks a function or file as cacheable. The cached output is included in the static shell during Partial Prerendering.\n\n### Syntax\n\n```tsx\n// File-level (applies to all exports)\n'use cache'\n\nexport async function getData() {\n  /* ... */\n}\n\n// Function-level\nasync function Component() {\n  'use cache'\n  // ...\n}\n```\n\n### Variants\n\n| Directive             | Description              | Cache Storage            |\n| --------------------- | ------------------------ | ------------------------ |\n| `'use cache'`         | Standard cache (default) | Default handler + Remote |\n| `'use cache: remote'` | Platform remote cache    | Remote handler only      |\n\n### `'use cache: remote'`\n\nUses platform-specific remote cache handler. Requires network roundtrip.\n\n```tsx\nasync function HeavyComputation() {\n  'use cache: remote'\n  cacheLife('days')\n\n  return await expensiveCalculation()\n}\n```\n\n### Understanding Cache Handlers\n\nNext.js uses **cache handlers** to store and retrieve cached data. The directive variant determines which handlers are used:\n\n| Handler   | Description                                                                 |\n| --------- | --------------------------------------------------------------------------- |\n| `default` | Local in-memory cache with optional persistence. Fast, single-server scope |\n| `remote`  | Platform-specific distributed cache. Network roundtrip, multi-server scope |\n\n**How variants map to handlers:**\n\n- `'use cache'` → Uses **both** default and remote handlers. Data is cached locally for fast access and remotely for sharing across instances\n- `'use cache: remote'` → Uses **only** the remote handler. Skips local cache, always fetches from distributed cache\n\n**When to use each:**\n\n| Use Case                              | Recommended Variant   |\n| ------------------------------------- | --------------------- |\n| Most cached data                      | `'use cache'`         |\n| Heavy computations to share globally  | `'use cache: remote'` |\n| Data that must be consistent globally | `'use cache: remote'` |\n\n### Rules\n\n1. **Must be async** - All cached functions must return a Promise\n2. **First statement** - `'use cache'` must be the first statement in the function body\n3. **No runtime APIs** - Cannot call `cookies()`, `headers()`, `searchParams` directly\n4. **Serializable arguments** - All arguments must be serializable (no functions, class instances)\n5. **Serializable return values** - Cached functions must return serializable data (no functions, class instances)\n\n---\n\n## Function: `cacheLife()`\n\nConfigures cache duration and revalidation behavior.\n\n### Import\n\n```tsx\nimport { cacheLife } from 'next/cache'\n```\n\n### Signature\n\n```tsx\nfunction cacheLife(profile: string): void\nfunction cacheLife(options: CacheLifeOptions): void\n\ninterface CacheLifeOptions {\n  stale?: number // Client cache duration (seconds)\n  revalidate?: number // Background revalidation window (seconds)\n  expire?: number // Absolute expiration (seconds)\n}\n```\n\n### Parameters\n\n| Parameter    | Description                                             | Constraint            |\n| ------------ | ------------------------------------------------------- | --------------------- |\n| `stale`      | How long the client can cache without server validation | None                  |\n| `revalidate` | When to start background refresh                        | `revalidate ≤ expire` |\n| `expire`     | Absolute expiration; deopts to dynamic if exceeded      | Must be largest       |\n\n### Predefined Profiles\n\n| Profile     | stale | revalidate    | expire         |\n| ----------- | ----- | ------------- | -------------- |\n| `'default'` | 300\\* | 900 (15min)   | ∞ (INFINITE)   |\n| `'seconds'` | 30    | 1             | 60             |\n| `'minutes'` | 300   | 60 (1min)     | 3600 (1hr)     |\n| `'hours'`   | 300   | 3600 (1hr)    | 86400 (1day)   |\n| `'days'`    | 300   | 86400 (1day)  | 604800 (1wk)   |\n| `'weeks'`   | 300   | 604800 (1wk)  | 2592000 (30d)  |\n| `'max'`     | 300   | 2592000 (30d) | 31536000 (1yr) |\n\n\\* Default `stale` falls back to `experimental.staleTimes.static` (300 seconds)\n\n> **Important:** Profiles with `expire < 300` seconds (like `'seconds'`) are treated as **dynamic** and won't be included in the static shell during Partial Prerendering. See [Dynamic Threshold](#dynamic-threshold) below.\n\n### Custom Profiles\n\nDefine custom profiles in `next.config.ts`:\n\n```typescript\nconst nextConfig: NextConfig = {\n  cacheLife: {\n    // Custom profile\n    'blog-posts': {\n      stale: 300, // 5 minutes\n      revalidate: 3600, // 1 hour\n      expire: 86400, // 1 day\n    },\n    // Override default\n    default: {\n      stale: 60,\n      revalidate: 600,\n      expire: 3600,\n    },\n  },\n}\n```\n\n### Usage\n\n```tsx\nasync function BlogPosts() {\n  'use cache'\n  cacheLife('blog-posts') // Custom profile\n\n  return await db.posts.findMany()\n}\n```\n\n### HTTP Cache-Control Mapping\n\n```\nstale     → max-age\nrevalidate → s-maxage\nexpire - revalidate → stale-while-revalidate\n\nExample: stale=60, revalidate=3600, expire=86400\n→ Cache-Control: max-age=60, s-maxage=3600, stale-while-revalidate=82800\n```\n\n### Dynamic Threshold\n\nCache entries with short expiration times are treated as **dynamic holes** during Partial Prerendering:\n\n| Condition               | Behavior                                 |\n| ----------------------- | ---------------------------------------- |\n| `expire < 300` seconds  | Treated as dynamic (not in static shell) |\n| `revalidate === 0`      | Treated as dynamic (not in static shell) |\n| `expire >= 300` seconds | Included in static shell                 |\n\n**Why `expire`, not `stale`?**\n\nThe threshold uses `expire` (absolute expiration) because:\n\n- `expire` defines the **maximum lifetime** of the cache entry\n- If `expire` is very short, the cached content would immediately become invalid in the static shell\n- `stale` only affects **client-side freshness perception** - how long before the browser revalidates\n- Including short-lived content in the static shell would serve guaranteed-stale data\n\n**Practical implications:**\n\n- `cacheLife('seconds')` (expire=60) → **Dynamic** - streams at request time\n- `cacheLife('minutes')` (expire=3600) → **Static** - included in PPR shell\n- Custom `cacheLife({ expire: 120 })` → **Dynamic** - below 300s threshold\n\nThis 300-second threshold ensures that very short-lived caches don't pollute the static shell with immediately-stale content.\n\n```tsx\n// This cache is DYNAMIC (expire=60 < 300)\nasync function RealtimePrice() {\n  'use cache'\n  cacheLife('seconds') // expire=60, below threshold\n  return await fetchPrice()\n}\n\n// This cache is STATIC (expire=3600 >= 300)\nasync function ProductDetails() {\n  'use cache'\n  cacheLife('minutes') // expire=3600, above threshold\n  return await fetchProduct()\n}\n```\n\n---\n\n## Function: `cacheTag()`\n\nTags cached data for targeted invalidation.\n\n### Import\n\n```tsx\nimport { cacheTag } from 'next/cache'\n```\n\n### Signature\n\n```tsx\nfunction cacheTag(...tags: string[]): void\n```\n\n### Usage\n\n```tsx\nasync function UserProfile({ userId }: { userId: string }) {\n  'use cache'\n  cacheTag('users', `user-${userId}`) // Multiple tags\n  cacheLife('hours')\n\n  return await db.users.findUnique({ where: { id: userId } })\n}\n```\n\n### Tagging Strategies\n\n**Entity-based tagging**:\n\n```tsx\ncacheTag('posts') // All posts\ncacheTag(`post-${postId}`) // Specific post\ncacheTag(`user-${userId}-posts`) // User's posts\n```\n\n**Feature-based tagging**:\n\n```tsx\ncacheTag('homepage')\ncacheTag('dashboard')\ncacheTag('admin')\n```\n\n**Combined approach**:\n\n```tsx\ncacheTag('posts', `post-${id}`, `author-${authorId}`)\n```\n\n### Tag Constraints\n\nTags have enforced limits:\n\n| Limit          | Value          | Behavior if exceeded           |\n| -------------- | -------------- | ------------------------------ |\n| Max tag length | 256 characters | Warning logged, tag ignored    |\n| Max total tags | 128 tags       | Warning logged, excess ignored |\n\n```tsx\n// ❌ Tag too long (>256 chars) - will be ignored with warning\ncacheTag('a'.repeat(300))\n\n// ❌ Too many tags (>128) - excess will be ignored with warning\ncacheTag(...Array(200).fill('tag'))\n\n// ✅ Valid usage\ncacheTag('products', `product-${id}`, `category-${category}`)\n```\n\n### Implicit Tags (Automatic)\n\nIn addition to explicit `cacheTag()` calls, Next.js automatically applies **implicit tags** based on the route hierarchy. This means `revalidatePath()` works without any explicit `cacheTag()` calls:\n\n```tsx\n'use server'\nimport { revalidatePath } from 'next/cache'\n\nexport async function publishBlogPost() {\n  await db.posts.create({\n    /* ... */\n  })\n\n  // Works without explicit cacheTag() - uses implicit route-based tags\n  revalidatePath('/blog', 'layout') // Invalidates all /blog/* routes\n}\n```\n\n**How it works:**\n\n- Each route segment (layout, page) automatically receives an internal tag\n- `revalidatePath('/blog', 'layout')` invalidates the `/blog` layout and all nested routes\n- `revalidatePath('/blog/my-post')` invalidates only that specific page\n\n**Choosing between implicit and explicit tags**:\n\n| Use Case                                 | Approach                            |\n| ---------------------------------------- | ----------------------------------- |\n| Invalidate all cached data under a route | `revalidatePath()` (uses implicit)  |\n| Invalidate specific entity across routes | `cacheTag()` + `updateTag()`        |\n| User needs to see their change (eager)   | `updateTag()` with explicit tag     |\n| Background update, eventual OK (lazy)    | `revalidateTag()` with explicit tag |\n\n---\n\n## Understanding Cache Scope\n\n### What Creates a New Cache Entry?\n\nA new cache entry is created when ANY of these differ:\n\n| Factor                | Example                                 |\n| --------------------- | --------------------------------------- |\n| **Function identity** | Different functions = different entries |\n| **Arguments**         | `getUser(\"123\")` vs `getUser(\"456\")`    |\n| **File path**         | Same function name in different files   |\n\n### Cache Key Composition\n\nCache keys are composed of multiple parts:\n\n```\n[buildId, functionId, serializedArgs, (hmrRefreshHash)]\n```\n\n| Part             | Description                                                     |\n| ---------------- | --------------------------------------------------------------- |\n| `buildId`        | Unique build identifier (prevents cross-deployment cache reuse) |\n| `functionId`     | Server reference ID for the cached function                     |\n| `serializedArgs` | React Flight-encoded function arguments                         |\n| `hmrRefreshHash` | (Dev only) Invalidates cache on file changes                    |\n\n```tsx\n// These create TWO separate cache entries (third call is a cache hit):\nasync function getProduct(id: string) {\n  'use cache'\n  return db.products.findUnique({ where: { id } })\n}\n\nawait getProduct('prod-1') // Cache entry 1: [buildId, getProduct, \"prod-1\"]\nawait getProduct('prod-2') // Cache entry 2: [buildId, getProduct, \"prod-2\"]\nawait getProduct('prod-1') // Cache HIT on entry 1\n```\n\n### Object Arguments and Cache Keys\n\nArguments are serialized using React's `encodeReply()`, which performs **structural serialization**:\n\n```tsx\nasync function getData(options: { limit: number }) {\n  'use cache'\n  return fetch(`/api?limit=${options.limit}`)\n}\n\n// Objects with identical structure produce the same cache key\ngetData({ limit: 10 }) // Cache key includes serialized { limit: 10 }\ngetData({ limit: 10 }) // HIT! Same structural content\n\n// Different values = different cache keys\ngetData({ limit: 20 }) // MISS - different content\n```\n\n**Best practice:** While objects work correctly, primitives are simpler to reason about:\n\n```tsx\n// ✅ Clear and explicit\nasync function getData(limit: number) {\n  'use cache'\n  return fetch(`/api?limit=${limit}`)\n}\n```\n\n> **Note:** Non-serializable values (functions, class instances, Symbols) cannot be used as arguments to cached functions and will cause errors.\n\n---\n\n## Function: `updateTag()`\n\nImmediately invalidates cache entries and ensures read-your-own-writes.\n\n### Import\n\n```tsx\nimport { updateTag } from 'next/cache'\n```\n\n### Signature\n\n```tsx\nfunction updateTag(tag: string): void\n```\n\n### Usage\n\n```tsx\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  const post = await db.posts.create({ data: formData })\n\n  updateTag('posts') // Update all cache entries tagged with 'posts'\n  updateTag(`user-${userId}`) // Update all cache entries tagged with this user\n\n  // Client immediately sees fresh data\n}\n```\n\n### Behavior\n\n- **Immediate**: Cache invalidated synchronously\n- **Read-your-own-writes**: Subsequent reads return fresh data\n- **Server Actions only**: Must be called from Server Actions\n\n---\n\n## Function: `revalidateTag()`\n\nMarks cache entries as stale for background revalidation.\n\n### Import\n\n```tsx\nimport { revalidateTag } from 'next/cache'\n```\n\n### Signature\n\n```tsx\nfunction revalidateTag(tag: string, profile: string | { expire?: number }): void\n```\n\n### Parameters\n\n| Parameter | Type                            | Description                                                    |\n| --------- | ------------------------------- | -------------------------------------------------------------- |\n| `tag`     | `string`                        | The cache tag to invalidate                                    |\n| `profile` | `string \\| { expire?: number }` | Cache profile name or object with expire time (seconds)        |\n\n> **Note:** Unlike `cacheLife()` which accepts `stale`, `revalidate`, and `expire`, the `revalidateTag()` object form only accepts `expire`. Use a predefined profile name (like `'hours'`) for full control over stale-while-revalidate behavior.\n\n### Usage\n\n```tsx\n'use server'\nimport { revalidateTag } from 'next/cache'\n\nexport async function updateSettings(data: FormData) {\n  await db.settings.update({ data })\n\n  // With predefined profile (recommended)\n  revalidateTag('settings', 'hours')\n\n  // With custom expiration\n  revalidateTag('settings', { expire: 3600 })\n}\n```\n\n### Behavior\n\n- **Stale-while-revalidate**: Serves cached content while refreshing in background\n- **Background refresh**: Cache entry is refreshed in the background after the next visit\n- **Broader context**: Can be called from Route Handlers and Server Actions\n\n---\n\n## updateTag() vs revalidateTag(): When to Use Each\n\nThe key distinction is **eager vs lazy** invalidation:\n\n- **`updateTag()`** - Eager invalidation. Cache is immediately invalidated, and the next read fetches fresh data synchronously. Use when the user who triggered the action needs to see the result.\n- **`revalidateTag()`** - Lazy (SWR-style) invalidation. Stale data may be served while fresh data is fetched in the background. Use when eventual consistency is acceptable.\n\nHere's a decision guide:\n\n| Scenario                   | Use               | Why                                        |\n| -------------------------- | ----------------- | ------------------------------------------ |\n| User creates a post        | `updateTag()`     | User expects to see their post immediately |\n| User updates their profile | `updateTag()`     | Read-your-own-writes semantics             |\n| Admin publishes content    | `revalidateTag()` | Other users can see stale briefly          |\n| Analytics/view counts      | `revalidateTag()` | Freshness less critical                    |\n| Background sync job        | `revalidateTag()` | No user waiting for result                 |\n| E-commerce cart update     | `updateTag()`     | User needs accurate cart state             |\n\n### E-commerce Example\n\n```tsx\n'use server'\nimport { updateTag, revalidateTag } from 'next/cache'\n\n// When USER adds to cart → updateTag (they need accurate count)\nexport async function addToCart(productId: string, userId: string) {\n  await db.cart.add({ productId, userId })\n  updateTag(`cart-${userId}`) // Immediate - user sees their cart\n}\n\n// When INVENTORY changes from warehouse sync → revalidateTag\nexport async function syncInventory(products: Product[]) {\n  await db.inventory.bulkUpdate(products)\n  revalidateTag('inventory', 'max') // Background - eventual consistency OK\n}\n\n// When USER completes purchase → updateTag for buyer, revalidateTag for product\nexport async function completePurchase(orderId: string) {\n  const order = await processOrder(orderId)\n\n  updateTag(`order-${orderId}`) // Buyer sees confirmation immediately\n  updateTag(`cart-${order.userId}`) // Buyer's cart clears immediately\n  revalidateTag(`product-${order.productId}`, 'max') // Others see updated stock eventually\n}\n```\n\n### The Rule of Thumb\n\n> **updateTag**: \"The person who triggered this action is waiting to see the result\"\n>\n> **revalidateTag**: \"This update affects others, but they don't know to wait for it\"\n\n---\n\n## Function: `revalidatePath()`\n\nRevalidates all cache entries associated with a path.\n\n### Import\n\n```tsx\nimport { revalidatePath } from 'next/cache'\n```\n\n### Signature\n\n```tsx\nfunction revalidatePath(path: string, type?: 'page' | 'layout'): void\n```\n\n### Usage\n\n```tsx\n'use server'\nimport { revalidatePath } from 'next/cache'\n\nexport async function updateBlog() {\n  await db.posts.update({\n    /* ... */\n  })\n\n  revalidatePath('/blog') // Specific path\n  revalidatePath('/blog', 'layout') // Layout and all children\n  revalidatePath('/', 'layout') // Entire app\n}\n```\n\n---\n\n## Configuration: `next.config.ts`\n\n### Enable Cache Components\n\n```typescript\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n\nexport default nextConfig\n```\n\n### Configure Cache Handlers\n\n```typescript\nconst nextConfig: NextConfig = {\n  cacheHandlers: {\n    default: {\n      maxMemorySize: 52428800, // 50MB\n    },\n    // Platform-specific remote handler\n    remote: CustomRemoteHandler,\n  },\n}\n```\n\n### Define Cache Profiles\n\n```typescript\nconst nextConfig: NextConfig = {\n  cacheLife: {\n    default: {\n      stale: 60,\n      revalidate: 3600,\n      expire: 86400,\n    },\n    posts: {\n      stale: 300,\n      revalidate: 3600,\n      expire: 604800,\n    },\n  },\n}\n```\n\n---\n\n## `generateStaticParams` with Cache Components\n\nWhen Cache Components is enabled, `generateStaticParams` behavior changes significantly.\n\n### Parameter Permutation Rendering\n\nNext.js renders ALL permutations of provided parameters to create reusable subshells:\n\n```tsx\n// app/products/[category]/[slug]/page.tsx\nexport async function generateStaticParams() {\n  return [\n    { category: 'jackets', slug: 'bomber' },\n    { category: 'jackets', slug: 'parka' },\n    { category: 'shoes', slug: 'sneakers' },\n  ]\n}\n```\n\n**Rendered routes:**\n\n| Route                         | Params Known       | Shell Type        |\n| ----------------------------- | ------------------ | ----------------- |\n| `/products/jackets/bomber`    | category ✓, slug ✓ | Complete page     |\n| `/products/jackets/parka`     | category ✓, slug ✓ | Complete page     |\n| `/products/shoes/sneakers`    | category ✓, slug ✓ | Complete page     |\n| `/products/jackets/[slug]`    | category ✓, slug ✗ | Category subshell |\n| `/products/shoes/[slug]`      | category ✓, slug ✗ | Category subshell |\n| `/products/[category]/[slug]` | category ✗, slug ✗ | Fallback shell    |\n\n### Requirements\n\n1. **Must return at least one parameter set** - Empty arrays cause build errors\n2. **Params validate static safety** - Next.js uses provided params to verify no dynamic APIs are accessed\n3. **Subshells require Suspense** - If accessing unknown params without Suspense, no subshell is generated\n\n```tsx\n// ❌ BUILD ERROR: Empty array not allowed\nexport function generateStaticParams() {\n  return []\n}\n\n// ✅ CORRECT: Provide at least one param set\nexport async function generateStaticParams() {\n  const products = await getProducts({ limit: 100 })\n  return products.map((p) => ({ category: p.category, slug: p.slug }))\n}\n```\n\n### Subshell Generation with Layouts\n\nCreate category-level subshells by adding Suspense in layouts:\n\n```tsx\n// app/products/[category]/layout.tsx\nexport default async function CategoryLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise<{ category: string }>\n}) {\n  const { category } = await params\n\n  return (\n    <>\n      <h2>{category}</h2>\n      <Suspense>{children}</Suspense> {/* Creates subshell boundary */}\n    </>\n  )\n}\n```\n\nNow `/products/jackets/[slug]` generates a reusable shell with the category header, streaming product details when visited.\n\n### Why Subshells Matter\n\nWithout `generateStaticParams`, visiting `/products/jackets/unknown-product`:\n\n- **Before**: Full dynamic render, user waits for everything\n- **After**: Cached category subshell served instantly, product details stream in\n\n---\n\n## Deprecated Segment Configurations\n\nThese exports are **deprecated** when `cacheComponents: true`:\n\n### `export const revalidate` (Deprecated)\n\n**Before:**\n\n```tsx\n// app/products/page.tsx\nexport const revalidate = 3600 // 1 hour\n\nexport default async function ProductsPage() {\n  const products = await db.products.findMany()\n  return <ProductList products={products} />\n}\n```\n\n**Problems with this approach:**\n\n- Revalidation time lived at segment level, not with the data\n- Couldn't vary revalidation based on fetched data\n- No control over client-side caching (`stale`) or expiration\n\n**After (Cache Components):**\n\n```tsx\n// app/products/page.tsx\nimport { cacheLife } from 'next/cache'\n\nasync function getProducts() {\n  'use cache'\n  cacheLife('hours') // Co-located with the data\n\n  return await db.products.findMany()\n}\n\nexport default async function ProductsPage() {\n  const products = await getProducts()\n  return <ProductList products={products} />\n}\n```\n\n**Benefits:**\n\n- Cache lifetime co-located with data fetching\n- Granular control: `stale`, `revalidate`, and `expire`\n- Different functions can have different lifetimes\n- Can conditionally set cache life based on data\n\n### `export const dynamic` (Deprecated)\n\n**Before:**\n\n```tsx\n// app/products/page.tsx\nexport const dynamic = 'force-static'\n\nexport default async function ProductsPage() {\n  // Headers would return empty, silently breaking components\n  const headers = await getHeaders()\n  return <ProductList />\n}\n```\n\n**Problems:**\n\n- All-or-nothing approach\n- `force-static` silently broke dynamic APIs (cookies, headers return empty)\n- `force-dynamic` prevented any static optimization\n- Hidden bugs when dynamic components received empty data\n\n**After (Cache Components):**\n\n```tsx\n// app/products/page.tsx\nexport default async function ProductsPage() {\n  return (\n    <>\n      <CachedProductList /> {/* Static via 'use cache' */}\n      <Suspense fallback={<Skeleton />}>\n        <DynamicUserRecommendations /> {/* Dynamic via Suspense */}\n      </Suspense>\n    </>\n  )\n}\n```\n\n**Benefits:**\n\n- No silent API failures\n- Granular static/dynamic at component level\n- Build errors guide you to correct patterns\n- Pages can be BOTH static AND dynamic\n\n### Migration Guide\n\n| Old Pattern                              | New Pattern                                            |\n| ---------------------------------------- | ------------------------------------------------------ |\n| `export const revalidate = 60`           | `cacheLife({ revalidate: 60 })` inside `'use cache'`   |\n| `export const revalidate = 0`            | Remove cache or use `cacheLife('seconds')`             |\n| `export const revalidate = false`        | `cacheLife('max')` for long-term caching               |\n| `export const dynamic = 'force-static'`  | Use `'use cache'` on data fetching                     |\n| `export const dynamic = 'force-dynamic'` | Wrap in `<Suspense>` without cache                     |\n| `export const dynamic = 'auto'`          | Default behavior - not needed                          |\n| `export const dynamic = 'error'`         | Default with Cache Components (build errors guide you) |\n\n---\n\n## Migration Scenarios\n\n### Scenario 1: Page with `revalidate` Export\n\n**Before:**\n\n```tsx\n// app/products/page.tsx\nexport const revalidate = 3600\n\nexport default async function ProductsPage() {\n  const products = await db.products.findMany()\n  return <ProductGrid products={products} />\n}\n```\n\n**After:**\n\n```tsx\n// app/products/page.tsx\nimport { cacheLife } from 'next/cache'\n\nasync function getProducts() {\n  'use cache'\n  cacheLife('hours') // Roughly equivalent to revalidate = 3600\n\n  return db.products.findMany()\n}\n\nexport default async function ProductsPage() {\n  const products = await getProducts()\n  return <ProductGrid products={products} />\n}\n```\n\n### Scenario 2: Page with `dynamic = 'force-dynamic'`\n\n**Before:**\n\n```tsx\n// app/dashboard/page.tsx\nexport const dynamic = 'force-dynamic'\n\nexport default async function Dashboard() {\n  const user = await getCurrentUser()\n  const stats = await getStats()\n  const notifications = await getNotifications(user.id)\n\n  return (\n    <div>\n      <UserHeader user={user} />\n      <Stats data={stats} />\n      <Notifications items={notifications} />\n    </div>\n  )\n}\n```\n\n**After:**\n\n```tsx\n// app/dashboard/page.tsx\nimport { Suspense } from 'react'\n\n// All data is dynamic - fetches user-specific content\nasync function DashboardContent() {\n  const user = await getCurrentUser()\n  const stats = await getStats()\n  const notifications = await getNotifications(user.id)\n\n  return (\n    <>\n      <UserHeader user={user} />\n      <Stats data={stats} />\n      <Notifications items={notifications} />\n    </>\n  )\n}\n\nexport default function Dashboard() {\n  return (\n    <div>\n      <Suspense fallback={<DashboardSkeleton />}>\n        <DashboardContent /> {/* Streams dynamically */}\n      </Suspense>\n    </div>\n  )\n}\n```\n\n**Key difference:** No `export const dynamic` needed. Components are dynamic by default - just wrap in Suspense to enable streaming.\n\n### Scenario 3: ISR with `revalidate` + On-Demand Revalidation\n\n**Before:**\n\n```tsx\n// app/blog/[slug]/page.tsx\nexport const revalidate = 3600\n\nexport async function generateStaticParams() {\n  const posts = await getAllPosts()\n  return posts.map((post) => ({ slug: post.slug }))\n}\n\nexport default async function BlogPost({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const post = await getPost(slug)\n  return <Article post={post} />\n}\n\n// api/revalidate/route.ts\nexport async function POST(request: Request) {\n  const { slug } = await request.json()\n  revalidatePath(`/blog/${slug}`)\n  return Response.json({ revalidated: true })\n}\n```\n\n**After:**\n\n```tsx\n// lib/posts.ts\nimport { cacheTag, cacheLife } from 'next/cache'\n\nexport async function getPost(slug: string) {\n  'use cache'\n  cacheTag('posts', `post-${slug}`)\n  cacheLife('hours')\n\n  return db.posts.findUnique({ where: { slug } })\n}\n\n// app/blog/[slug]/page.tsx\nexport default async function BlogPost({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const post = await getPost(slug)\n  return <Article post={post} />\n}\n\n// app/api/revalidate/route.ts\nimport { revalidatePath } from 'next/cache'\n\nexport async function POST(request: Request) {\n  const { slug } = await request.json()\n  revalidatePath(`/blog/${slug}`)\n  return Response.json({ revalidated: true })\n}\n```\n\n**Key improvements:**\n\n- Cache configuration co-located with data fetching via `'use cache'`\n- Explicit cache tags enable targeted invalidation\n- Route Handler pattern preserved for external webhook integration\n\n---\n\n## Runtime Behaviors\n\n### Draft Mode\n\nWhen [Draft Mode](https://nextjs.org/docs/app/building-your-application/configuring/draft-mode) is enabled, cache entries are **not saved**:\n\n```tsx\nimport { draftMode } from 'next/headers'\n\nexport default async function PreviewPage() {\n  const { isEnabled } = await draftMode()\n\n  // When isEnabled is true:\n  // - 'use cache' functions still execute\n  // - But results are NOT stored in cache\n  // - Ensures preview content is always fresh\n}\n```\n\nThis prevents stale preview content from being cached and served to production users.\n\n### Cache Bypass Conditions\n\nCache is bypassed (not read from) when:\n\n| Condition              | Description                                        |\n| ---------------------- | -------------------------------------------------- |\n| Draft Mode enabled     | `draftMode().isEnabled === true`                   |\n| On-demand revalidation | `revalidateTag()` or `revalidatePath()` was called |\n| Dev mode + no-cache    | Request includes `Cache-Control: no-cache` header  |\n\n### Prerender Timeout\n\nDuring static prerendering (build time), cached functions have a **50-second timeout**:\n\n- If a cached function doesn't complete within 50 seconds, it becomes a dynamic hole\n- At request time, there is **no timeout** - background revalidation can take as long as needed\n- Timeout errors throw `UseCacheTimeoutError` with code `'USE_CACHE_TIMEOUT'`\n\n```tsx\n// If this takes >50s during build, it becomes dynamic\nasync function SlowData() {\n  'use cache'\n  return await verySlowApiCall() // May timeout during prerender\n}\n```\n\n### Development Mode: HMR Cache Invalidation\n\nIn development, cache keys include an **HMR refresh hash**:\n\n- When you edit a file containing a cached function, the cache automatically invalidates\n- No manual cache clearing needed during development\n- This hash is not included in production builds\n\n### Cache Propagation (Nested Caches)\n\nWhen cached functions call other cached functions, cache metadata propagates **upward**:\n\n```tsx\nasync function Inner() {\n  'use cache'\n  cacheLife('seconds') // expire=60\n  cacheTag('inner')\n  return await fetchData()\n}\n\nasync function Outer() {\n  'use cache'\n  cacheLife('hours') // expire=86400\n  cacheTag('outer')\n\n  const data = await Inner() // Calls inner cached function\n  return process(data)\n}\n\n// Outer's effective cache:\n// - expire = min(86400, 60) = 60 (inherits Inner's shorter expiration)\n// - tags = ['outer', 'inner'] (tags merge)\n```\n\nThis ensures parent caches don't outlive their dependencies.\n\n---\n\n## Type Definitions\n\n### CacheLife\n\n```typescript\ntype CacheLife = {\n  stale?: number // Default: 300 (from staleTimes.static)\n  revalidate?: number // Default: profile-dependent\n  expire?: number // Default: profile-dependent\n}\n```\n\n### CacheLifeProfile\n\n```typescript\ntype CacheLifeProfile =\n  | 'default'\n  | 'seconds'\n  | 'minutes'\n  | 'hours'\n  | 'days'\n  | 'weeks'\n  | 'max'\n  | string // Custom profiles\n```\n",
        ".claude-plugin/plugins/cache-components/skills/cache-components/SKILL.md": "---\nname: cache-components\ndescription: |\n  Expert guidance for Next.js Cache Components and Partial Prerendering (PPR).\n\n  **PROACTIVE ACTIVATION**: Use this skill automatically when working in Next.js projects that have `cacheComponents: true` in their next.config.ts/next.config.js. When this config is detected, proactively apply Cache Components patterns and best practices to all React Server Component implementations.\n\n  **DETECTION**: At the start of a session in a Next.js project, check for `cacheComponents: true` in next.config. If enabled, this skill's patterns should guide all component authoring, data fetching, and caching decisions.\n\n  **USE CASES**: Implementing 'use cache' directive, configuring cache lifetimes with cacheLife(), tagging cached data with cacheTag(), invalidating caches with updateTag()/revalidateTag(), optimizing static vs dynamic content boundaries, debugging cache issues, and reviewing Cache Component implementations.\n---\n\n# Next.js Cache Components\n\n> **Auto-activation**: This skill activates automatically in projects with `cacheComponents: true` in next.config.\n\n## Project Detection\n\nWhen starting work in a Next.js project, check if Cache Components are enabled:\n\n```bash\n# Check next.config.ts or next.config.js for cacheComponents\ngrep -r \"cacheComponents\" next.config.* 2>/dev/null\n```\n\nIf `cacheComponents: true` is found, apply this skill's patterns proactively when:\n\n- Writing React Server Components\n- Implementing data fetching\n- Creating Server Actions with mutations\n- Optimizing page performance\n- Reviewing existing component code\n\nCache Components enable **Partial Prerendering (PPR)** - mixing static HTML shells with dynamic streaming content for optimal performance.\n\n## Philosophy: Code Over Configuration\n\nCache Components represents a shift from **segment configuration** to **compositional code**:\n\n| Before (Deprecated)                     | After (Cache Components)                  |\n| --------------------------------------- | ----------------------------------------- |\n| `export const revalidate = 3600`        | `cacheLife('hours')` inside `'use cache'` |\n| `export const dynamic = 'force-static'` | Use `'use cache'` and Suspense boundaries |\n| All-or-nothing static/dynamic           | Granular: static shell + cached + dynamic |\n\n**Key Principle**: Components co-locate their caching, not just their data. Next.js provides build-time feedback to guide you toward optimal patterns.\n\n## Core Concept\n\n```\n┌─────────────────────────────────────────────────────┐\n│                   Static Shell                       │\n│  (Sent immediately to browser)                       │\n│                                                      │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │\n│  │   Header    │  │  Cached     │  │  Suspense   │  │\n│  │  (static)   │  │  Content    │  │  Fallback   │  │\n│  └─────────────┘  └─────────────┘  └──────┬──────┘  │\n│                                           │         │\n│                                    ┌──────▼──────┐  │\n│                                    │  Dynamic    │  │\n│                                    │  (streams)  │  │\n│                                    └─────────────┘  │\n└─────────────────────────────────────────────────────┘\n```\n\n## Mental Model: The Caching Decision Tree\n\nWhen writing a React Server Component, ask these questions in order:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│ Does this component fetch data or perform I/O?          │\n└─────────────────────┬───────────────────────────────────┘\n                      │\n           ┌──────────▼──────────┐\n           │   YES               │ NO → Pure component, no action needed\n           └──────────┬──────────┘\n                      │\n    ┌─────────────────▼─────────────────┐\n    │ Does it depend on request context? │\n    │ (cookies, headers, searchParams)   │\n    └─────────────────┬─────────────────┘\n                      │\n         ┌────────────┴────────────┐\n         │                         │\n    ┌────▼────┐              ┌─────▼─────┐\n    │   YES   │              │    NO     │\n    └────┬────┘              └─────┬─────┘\n         │                         │\n         │                   ┌─────▼─────────────────┐\n         │                   │ Can this be cached?   │\n         │                   │ (same for all users?) │\n         │                   └─────┬─────────────────┘\n         │                         │\n         │              ┌──────────┴──────────┐\n         │              │                     │\n         │         ┌────▼────┐          ┌─────▼─────┐\n         │         │   YES   │          │    NO     │\n         │         └────┬────┘          └─────┬─────┘\n         │              │                     │\n         │              ▼                     │\n         │         'use cache'                │\n         │         + cacheTag()               │\n         │         + cacheLife()              │\n         │                                    │\n         └──────────────┬─────────────────────┘\n                        │\n                        ▼\n              Wrap in <Suspense>\n              (dynamic streaming)\n```\n\n**Key insight**: The `'use cache'` directive is for data that's the _same across users_. User-specific data stays dynamic with Suspense.\n\n## Quick Start\n\n### Enable Cache Components\n\n```typescript\n// next.config.ts\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n\nexport default nextConfig\n```\n\n### Basic Usage\n\n```tsx\n// Cached component - output included in static shell\nasync function CachedPosts() {\n  'use cache'\n  const posts = await db.posts.findMany()\n  return <PostList posts={posts} />\n}\n\n// Page with static + cached + dynamic content\nexport default async function BlogPage() {\n  return (\n    <>\n      <Header /> {/* Static */}\n      <CachedPosts /> {/* Cached */}\n      <Suspense fallback={<Skeleton />}>\n        <DynamicComments /> {/* Dynamic - streams */}\n      </Suspense>\n    </>\n  )\n}\n```\n\n## Core APIs\n\n### 1. `'use cache'` Directive\n\nMarks code as cacheable. Can be applied at three levels:\n\n```tsx\n// File-level: All exports are cached\n'use cache'\nexport async function getData() {\n  /* ... */\n}\nexport async function Component() {\n  /* ... */\n}\n\n// Component-level\nasync function UserCard({ id }: { id: string }) {\n  'use cache'\n  const user = await fetchUser(id)\n  return <Card>{user.name}</Card>\n}\n\n// Function-level\nasync function fetchWithCache(url: string) {\n  'use cache'\n  return fetch(url).then((r) => r.json())\n}\n```\n\n**Important**: All cached functions must be `async`.\n\n### 2. `cacheLife()` - Control Cache Duration\n\n```tsx\nimport { cacheLife } from 'next/cache'\n\nasync function Posts() {\n  'use cache'\n  cacheLife('hours') // Use a predefined profile\n\n  // Or custom configuration:\n  cacheLife({\n    stale: 60, // 1 min - client cache validity\n    revalidate: 3600, // 1 hr - start background refresh\n    expire: 86400, // 1 day - absolute expiration\n  })\n\n  return await db.posts.findMany()\n}\n```\n\n**Predefined profiles**: `'default'`, `'seconds'`, `'minutes'`, `'hours'`, `'days'`, `'weeks'`, `'max'`\n\n### 3. `cacheTag()` - Tag for Invalidation\n\n```tsx\nimport { cacheTag } from 'next/cache'\n\nasync function BlogPosts() {\n  'use cache'\n  cacheTag('posts')\n  cacheLife('days')\n\n  return await db.posts.findMany()\n}\n\nasync function UserProfile({ userId }: { userId: string }) {\n  'use cache'\n  cacheTag('users', `user-${userId}`) // Multiple tags\n\n  return await db.users.findUnique({ where: { id: userId } })\n}\n```\n\n### 4. `updateTag()` - Immediate Invalidation\n\nFor **read-your-own-writes** semantics:\n\n```tsx\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  await db.posts.create({ data: formData })\n\n  updateTag('posts') // Client immediately sees fresh data\n}\n```\n\n### 5. `revalidateTag()` - Background Revalidation\n\nFor stale-while-revalidate pattern:\n\n```tsx\n'use server'\nimport { revalidateTag } from 'next/cache'\n\nexport async function updatePost(id: string, data: FormData) {\n  await db.posts.update({ where: { id }, data })\n\n  revalidateTag('posts', 'max') // Serve stale, refresh in background\n}\n```\n\n## When to Use Each Pattern\n\n| Content Type | API                 | Behavior                              |\n| ------------ | ------------------- | ------------------------------------- |\n| **Static**   | No directive        | Rendered at build time                |\n| **Cached**   | `'use cache'`       | Included in static shell, revalidates |\n| **Dynamic**  | Inside `<Suspense>` | Streams at request time               |\n\n## Parameter Permutations & Subshells\n\n**Critical Concept**: With Cache Components, Next.js renders ALL permutations of provided parameters to create reusable subshells.\n\n```tsx\n// app/products/[category]/[slug]/page.tsx\nexport async function generateStaticParams() {\n  return [\n    { category: 'jackets', slug: 'classic-bomber' },\n    { category: 'jackets', slug: 'essential-windbreaker' },\n    { category: 'accessories', slug: 'thermal-fleece-gloves' },\n  ]\n}\n```\n\nNext.js renders these routes:\n\n```\n/products/jackets/classic-bomber        ← Full params (complete page)\n/products/jackets/essential-windbreaker ← Full params (complete page)\n/products/accessories/thermal-fleece-gloves ← Full params (complete page)\n/products/jackets/[slug]                ← Partial params (category subshell)\n/products/accessories/[slug]            ← Partial params (category subshell)\n/products/[category]/[slug]             ← No params (fallback shell)\n```\n\n**Why this matters**: The category subshell (`/products/jackets/[slug]`) can be reused for ANY jacket product, even ones not in `generateStaticParams`. Users navigating to an unlisted jacket get the cached category shell immediately, with product details streaming in.\n\n### `generateStaticParams` Requirements\n\nWith Cache Components enabled:\n\n1. **Must provide at least one parameter** - Empty arrays now cause build errors (prevents silent production failures)\n2. **Params prove static safety** - Providing params lets Next.js verify no dynamic APIs are called\n3. **Partial params create subshells** - Each unique permutation generates a reusable shell\n\n```tsx\n// ❌ ERROR with Cache Components\nexport function generateStaticParams() {\n  return [] // Build error: must provide at least one param\n}\n\n// ✅ CORRECT: Provide real params\nexport async function generateStaticParams() {\n  const products = await getPopularProducts()\n  return products.map(({ category, slug }) => ({ category, slug }))\n}\n```\n\n## Cache Key = Arguments\n\nArguments become part of the cache key:\n\n```tsx\n// Different userId = different cache entry\nasync function UserData({ userId }: { userId: string }) {\n  'use cache'\n  cacheTag(`user-${userId}`)\n\n  return await fetchUser(userId)\n}\n```\n\n## Build-Time Feedback\n\nCache Components provides early feedback during development. These build errors **guide you toward optimal patterns**:\n\n### Error: Dynamic data outside Suspense\n\n```\nError: Accessing cookies/headers/searchParams outside a Suspense boundary\n```\n\n**Solution**: Wrap dynamic components in `<Suspense>`:\n\n```tsx\n<Suspense fallback={<Skeleton />}>\n  <ComponentThatUsesCookies />\n</Suspense>\n```\n\n### Error: Uncached data outside Suspense\n\n```\nError: Accessing uncached data outside Suspense\n```\n\n**Solution**: Either cache the data or wrap in Suspense:\n\n```tsx\n// Option 1: Cache it\nasync function ProductData({ id }: { id: string }) {\n  'use cache'\n  return await db.products.findUnique({ where: { id } })\n}\n\n// Option 2: Make it dynamic with Suspense\n;<Suspense fallback={<Loading />}>\n  <DynamicProductData id={id} />\n</Suspense>\n```\n\n### Error: Request data inside cache\n\n```\nError: Cannot access cookies/headers inside 'use cache'\n```\n\n**Solution**: Extract runtime data outside cache boundary (see \"Handling Runtime Data\" above).\n\n## Additional Resources\n\n- For complete API reference, see [REFERENCE.md](REFERENCE.md)\n- For common patterns and recipes, see [PATTERNS.md](PATTERNS.md)\n- For debugging and troubleshooting, see [TROUBLESHOOTING.md](TROUBLESHOOTING.md)\n\n## Code Generation Guidelines\n\nWhen generating Cache Component code:\n\n1. **Always use `async`** - All cached functions must be async\n2. **Place `'use cache'` first** - Must be first statement in function body\n3. **Call `cacheLife()` early** - Should follow `'use cache'` directive\n4. **Tag meaningfully** - Use semantic tags that match your invalidation needs\n5. **Extract runtime data** - Move `cookies()`/`headers()` outside cached scope\n6. **Wrap dynamic content** - Use `<Suspense>` for non-cached async components\n\n---\n\n## Proactive Application (When Cache Components Enabled)\n\nWhen `cacheComponents: true` is detected in the project, **automatically apply these patterns**:\n\n### When Writing Data Fetching Components\n\nAsk yourself: \"Can this data be cached?\" If yes, add `'use cache'`:\n\n```tsx\n// Before: Uncached fetch\nasync function ProductList() {\n  const products = await db.products.findMany()\n  return <Grid products={products} />\n}\n\n// After: With caching\nasync function ProductList() {\n  'use cache'\n  cacheTag('products')\n  cacheLife('hours')\n\n  const products = await db.products.findMany()\n  return <Grid products={products} />\n}\n```\n\n### When Writing Server Actions\n\nAlways invalidate relevant caches after mutations:\n\n```tsx\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function createProduct(data: FormData) {\n  await db.products.create({ data })\n  updateTag('products') // Don't forget!\n}\n```\n\n### When Composing Pages\n\nStructure with static shell + cached content + dynamic streaming:\n\n```tsx\nexport default async function Page() {\n  return (\n    <>\n      <StaticHeader /> {/* No cache needed */}\n      <CachedContent /> {/* 'use cache' */}\n      <Suspense fallback={<Skeleton />}>\n        <DynamicUserContent /> {/* Streams at runtime */}\n      </Suspense>\n    </>\n  )\n}\n```\n\n### When Reviewing Code\n\nFlag these issues in Cache Components projects:\n\n- [ ] Data fetching without `'use cache'` where caching would benefit\n- [ ] Missing `cacheTag()` calls (makes invalidation impossible)\n- [ ] Missing `cacheLife()` (relies on defaults which may not be appropriate)\n- [ ] Server Actions without `updateTag()`/`revalidateTag()` after mutations\n- [ ] `cookies()`/`headers()` called inside `'use cache'` scope\n- [ ] Dynamic components without `<Suspense>` boundaries\n- [ ] **DEPRECATED**: `export const revalidate` - replace with `cacheLife()` in `'use cache'`\n- [ ] **DEPRECATED**: `export const dynamic` - replace with Suspense + cache boundaries\n- [ ] Empty `generateStaticParams()` return - must provide at least one param\n",
        ".claude-plugin/plugins/cache-components/skills/cache-components/TROUBLESHOOTING.md": "# Cache Components Troubleshooting\n\nCommon issues, debugging techniques, and solutions for Cache Components.\n\n## Build-Time Feedback Philosophy\n\nCache Components introduces **early feedback** during development. Unlike before where errors might only appear in production, Cache Components produces build errors that **guide you toward optimal patterns**.\n\nKey principle: **If it builds, it's correct.** The build process validates that:\n\n- Dynamic data isn't accessed outside Suspense boundaries\n- Cached data doesn't depend on request-specific APIs\n- `generateStaticParams` provides valid parameters to test rendering\n\n---\n\n## Quick Debugging Checklist\n\nCopy this checklist when debugging cache issues:\n\n### Cache Not Working\n\n- [ ] `cacheComponents: true` in next.config?\n- [ ] Function is `async`?\n- [ ] `'use cache'` is FIRST statement in function body?\n- [ ] All arguments are serializable (no functions, class instances)?\n- [ ] Not accessing `cookies()`/`headers()` inside cache?\n\n### Stale Data After Mutation\n\n- [ ] Called `updateTag()` or `revalidateTag()` after mutation?\n- [ ] Tag in invalidation matches tag in `cacheTag()`?\n- [ ] Using `updateTag()` (not `revalidateTag()`) for immediate updates?\n\n### Build Errors\n\n- [ ] Dynamic data wrapped in `<Suspense>`?\n- [ ] `generateStaticParams` returns at least one param?\n- [ ] Not mixing `'use cache'` with `cookies()`/`headers()`?\n\n### Performance Issues\n\n- [ ] Cache granularity appropriate? (not too coarse/fine)\n- [ ] `cacheLife` set appropriately for data volatility?\n- [ ] Using hierarchical tags for targeted invalidation?\n\n---\n\n## Error: UseCacheTimeoutError\n\n### Symptoms\n\n```\nError: A component used 'use cache' but didn't complete within 50 seconds.\n```\n\n### Cause\n\nThe cached function is accessing request-specific data (cookies, headers, searchParams) or making requests that depend on runtime context.\n\n### Solution\n\nUser-specific content that depends on runtime data (cookies, headers, searchParams) should **not be cached**. Instead, stream it dynamically:\n\n```tsx\n// ❌ WRONG: Trying to cache user-specific content\nasync function UserContent() {\n  'use cache'\n  const session = await cookies() // Causes timeout!\n  return await fetchContent(session.userId)\n}\n\n// ✅ CORRECT: Don't cache user-specific content, stream it instead\nasync function UserContent() {\n  const session = await cookies()\n  return await fetchContent(session.get('userId')?.value)\n}\n\nexport default function Page() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <UserContent /> {/* No 'use cache' - streams dynamically */}\n    </Suspense>\n  )\n}\n```\n\n**Key insight**: Cache Components are for content that can be shared across users (e.g., product details, blog posts). User-specific content should stream at request time.\n\n---\n\n## Error: Cannot use 'use cache' with sync function\n\n### Symptoms\n\n```\nError: 'use cache' can only be used in async functions\n```\n\n### Cause\n\nCache Components require async functions because cached outputs are streamed.\n\n### Solution\n\n```tsx\n// ❌ WRONG: Synchronous function\nfunction CachedComponent() {\n  'use cache'\n  return <div>Hello</div>\n}\n\n// ✅ CORRECT: Async function\nasync function CachedComponent() {\n  'use cache'\n  return <div>Hello</div>\n}\n```\n\n---\n\n## Error: Dynamic Data Outside Suspense\n\n### Symptoms\n\n```\nError: Accessing cookies/headers/searchParams outside a Suspense boundary\n```\n\n### Cause\n\nWith Cache Components, accessing request-specific APIs (cookies, headers, searchParams, connection) requires a Suspense boundary so Next.js can provide a static fallback.\n\n### Why This Changed\n\n**Before Cache Components**: The page silently became fully dynamic - no static content served.\n\n**After Cache Components**: Build error ensures you explicitly handle the dynamic boundary.\n\n### Solution\n\nWrap dynamic content in Suspense:\n\n```tsx\n// ❌ ERROR: No Suspense boundary\nexport default async function Page() {\n  return (\n    <>\n      <Header />\n      <UserDeals /> {/* Uses cookies() */}\n    </>\n  )\n}\n\n// ✅ CORRECT: Suspense provides static fallback\nexport default async function Page() {\n  return (\n    <>\n      <Header />\n      <Suspense fallback={<DealsSkeleton />}>\n        <UserDeals />\n      </Suspense>\n    </>\n  )\n}\n```\n\n> **See also**: Pattern 1 (Static + Cached + Dynamic Page) in PATTERNS.md shows the foundational Suspense boundary pattern.\n\n---\n\n## Error: Uncached Data Outside Suspense\n\n### Symptoms\n\n```\nError: Accessing uncached data outside Suspense\n```\n\n### Cause\n\nWith Cache Components, ALL **async** I/O is considered dynamic by default. Database queries, fetch calls, and file reads must either be cached or wrapped in Suspense.\n\n> **Note on synchronous databases**: Libraries with synchronous APIs (e.g., `better-sqlite3`) don't trigger this error because they don't involve async I/O. Synchronous operations complete during render and are included in the static shell. However, this also means they block the render thread - use judiciously for small, fast queries only.\n\n### Solution\n\nEither cache the data or wrap in Suspense:\n\n```tsx\n// ❌ ERROR: Uncached database query without Suspense\nexport default async function ProductPage({ params }) {\n  const product = await db.products.findUnique({ where: { id: params.id } })\n  return <ProductCard product={product} />\n}\n\n// ✅ OPTION 1: Cache the data\nasync function getProduct(id: string) {\n  'use cache'\n  cacheTag(`product-${id}`)\n  cacheLife('hours')\n\n  return await db.products.findUnique({ where: { id } })\n}\n\nexport default async function ProductPage({ params }) {\n  const product = await getProduct(params.id)\n  return <ProductCard product={product} />\n}\n\n// ✅ OPTION 2: Wrap in Suspense (streams dynamically)\nexport default async function ProductPage({ params }) {\n  return (\n    <Suspense fallback={<ProductSkeleton />}>\n      <ProductContent id={params.id} />\n    </Suspense>\n  )\n}\n```\n\n> **See also**: Pattern 5 (Cached Data Fetching Functions) in PATTERNS.md shows reusable cached data fetcher patterns.\n\n---\n\n## Error: Empty generateStaticParams\n\n### Symptoms\n\n```\nError: generateStaticParams must return at least one parameter set\n```\n\n### Cause\n\nWith Cache Components, empty `generateStaticParams` is no longer allowed. This prevents a class of bugs where dynamic API usage in components would only error in production.\n\n### Why This Changed\n\n**Before**: Empty array = \"trust me, this is static\". Dynamic API usage in production caused runtime errors.\n\n**After**: Must provide at least one param set so Next.js can validate the page actually renders statically.\n\n### Solution\n\n```tsx\n// ❌ ERROR: Empty array\nexport function generateStaticParams() {\n  return []\n}\n\n// ✅ CORRECT: Provide at least one param\nexport async function generateStaticParams() {\n  const products = await getPopularProducts()\n  return products.map(({ category, slug }) => ({ category, slug }))\n}\n\n// ✅ ALSO CORRECT: Hardcoded for known routes\nexport function generateStaticParams() {\n  return [{ slug: 'about' }, { slug: 'contact' }, { slug: 'pricing' }]\n}\n```\n\n---\n\n## Error: Request Data Inside Cache\n\n### Symptoms\n\n```\nError: Cannot access cookies/headers inside 'use cache'\n```\n\n### Cause\n\nCache contexts cannot depend on request-specific data because the cached result would be shared across all users.\n\n### Solution\n\nUser-specific content should **not be cached**. Remove `'use cache'` and stream the content dynamically:\n\n```tsx\n// ❌ ERROR: Cookies inside cache\nasync function UserDashboard() {\n  'use cache'\n  const session = await cookies() // Error!\n  return await fetchDashboard(session.get('userId'))\n}\n\n// ✅ CORRECT: Don't cache user-specific content\nasync function UserDashboard() {\n  const session = await cookies()\n  return await fetchDashboard(session.get('userId')?.value)\n}\n\nexport default function Page() {\n  return (\n    <Suspense fallback={<DashboardSkeleton />}>\n      <UserDashboard /> {/* Streams at request time */}\n    </Suspense>\n  )\n}\n```\n\n**Key insight**: Cache Components are for content that can be shared across users. User-specific dashboards should stream dynamically.\n\n---\n\n## Issue: Cache Not Being Used\n\n### Symptoms\n\n- Data always fresh on every request\n- No caching behavior observed\n- Build logs don't show cached routes\n\n### Checklist\n\n**1. Is `cacheComponents` enabled?**\n\n```typescript\n// next.config.ts\nconst nextConfig: NextConfig = {\n  cacheComponents: true, // Required!\n}\n```\n\n**2. Is the function async?**\n\n```tsx\n// Must be async\nasync function CachedData() {\n  'use cache'\n  return await fetchData()\n}\n```\n\n**3. Is `'use cache'` the first statement?**\n\n```tsx\n// ❌ WRONG: Directive not first\nasync function CachedData() {\n  const x = 1 // Something before 'use cache'\n  ;('use cache')\n  return await fetchData()\n}\n\n// ✅ CORRECT: Directive first\nasync function CachedData() {\n  'use cache'\n  const x = 1\n  return await fetchData()\n}\n```\n\n**4. Are arguments serializable?**\n\n```tsx\n// ❌ WRONG: Function as argument (not serializable)\nasync function CachedData({ transform }: { transform: (x: any) => any }) {\n  'use cache'\n  const data = await fetchData()\n  return transform(data)\n}\n\n// ✅ CORRECT: Only serializable arguments\nasync function CachedData({ transformType }: { transformType: string }) {\n  'use cache'\n  const data = await fetchData()\n  return applyTransform(data, transformType)\n}\n```\n\n---\n\n## Issue: Stale Data After Mutation\n\n### Symptoms\n\n- Created/updated data doesn't appear immediately\n- Need to refresh page to see changes\n\n### Cause\n\nCache not invalidated after mutation.\n\n### Solutions\n\n**1. Use `updateTag()` for immediate consistency:**\n\n```tsx\n'use server'\nimport { updateTag } from 'next/cache'\n\nexport async function createPost(data: FormData) {\n  await db.posts.create({ data })\n  updateTag('posts') // Immediate invalidation\n}\n```\n\n**2. Ensure tags match:**\n\n```tsx\n// Cache uses this tag\nasync function Posts() {\n  'use cache'\n  cacheTag('posts') // Must match invalidation tag\n  return await db.posts.findMany()\n}\n\n// Invalidation must use same tag\nexport async function createPost(data: FormData) {\n  await db.posts.create({ data })\n  updateTag('posts') // Same tag!\n}\n```\n\n**3. Invalidate all relevant tags:**\n\n```tsx\nexport async function updatePost(postId: string, data: FormData) {\n  const post = await db.posts.update({\n    where: { id: postId },\n    data,\n  })\n\n  // Invalidate all affected caches\n  updateTag('posts') // All posts list\n  updateTag(`post-${postId}`) // Specific post\n  updateTag(`author-${post.authorId}`) // Author's posts\n}\n```\n\n---\n\n## Issue: Different Cache Values for Same Key\n\n### Symptoms\n\n- Cache returns different values for what should be the same query\n- Inconsistent behavior across requests\n\n### Cause\n\nArguments are part of cache key. Different argument values = different cache entries.\n\n### Solution\n\nNormalize arguments:\n\n```tsx\n// ❌ Problem: Object reference differs\nasync function CachedData({ options }: { options: { limit: number } }) {\n  'use cache'\n  return await fetchData(options)\n}\n\n// Each call creates new object = new cache key\n<CachedData options={{ limit: 10 }} />\n<CachedData options={{ limit: 10 }} /> // Different cache entry!\n\n// ✅ Solution: Use primitives or stable references\nasync function CachedData({ limit }: { limit: number }) {\n  'use cache'\n  return await fetchData({ limit })\n}\n\n<CachedData limit={10} />\n<CachedData limit={10} /> // Same cache entry!\n```\n\n---\n\n## Issue: Cache Too Aggressive (Stale Data)\n\n### Symptoms\n\n- Data doesn't update when expected\n- Users see outdated content\n\n### Solutions\n\n**1. Reduce cache lifetime:**\n\n```tsx\nasync function FrequentlyUpdatedData() {\n  'use cache'\n  cacheLife('seconds') // Short cache\n\n  // Or custom short duration\n  cacheLife({\n    stale: 0,\n    revalidate: 30,\n    expire: 60,\n  })\n\n  return await fetchData()\n}\n```\n\n**2. Don't cache volatile data:**\n\n```tsx\n// For truly real-time data, skip caching\nasync function LiveData() {\n  // No 'use cache'\n  return await fetchLiveData()\n}\n\nexport default function Page() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <LiveData />\n    </Suspense>\n  )\n}\n```\n\n---\n\n## Issue: Build Takes Too Long\n\n### Symptoms\n\n- Build hangs during prerendering\n- Timeout errors during `next build`\n\n### Cause\n\nCached functions making slow network requests or accessing unavailable services during build.\n\n### Solutions\n\n**1. Use fallback data for build:**\n\n```tsx\nasync function CachedData() {\n  'use cache'\n\n  try {\n    return await fetchFromAPI()\n  } catch (error) {\n    // Return fallback during build if API unavailable\n    return getFallbackData()\n  }\n}\n```\n\n**2. Limit static generation scope:**\n\n```tsx\n// app/[slug]/page.tsx\nexport function generateStaticParams() {\n  // Only prerender most important pages at build time\n  // Other pages will be generated on-demand at request time\n  return [{ slug: 'home' }, { slug: 'about' }]\n}\n```\n\n**3. Use Suspense for truly dynamic content:**\n\n```tsx\n// app/[slug]/page.tsx\nimport { Suspense } from 'react'\n\nexport default function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  return (\n    <Suspense fallback={<PageSkeleton />}>\n      <DynamicContent params={params} />\n    </Suspense>\n  )\n}\n```\n\n> **Note:** Avoid using `export const dynamic = 'force-dynamic'` as this segment config is deprecated with Cache Components. Use Suspense boundaries and `'use cache'` for granular control instead.\n\n---\n\n## Debugging Techniques\n\n### 1. Check Cache Headers\n\nIn development, inspect response headers:\n\n```bash\ncurl -I http://localhost:3000/your-page\n```\n\nLook for:\n\n- `x-nextjs-cache: HIT` - Served from cache\n- `x-nextjs-cache: MISS` - Cache miss, recomputed\n- `x-nextjs-cache: STALE` - Stale content, revalidating\n\n### 2. Enable Verbose Logging\n\n```bash\n# Environment variable for cache debugging\nNEXT_PRIVATE_DEBUG_CACHE=1 npm run dev\n```\n\n### 3. Check Build Output\n\n```bash\nnpm run build\n\n# Look for:\n# ○ (Static) - Fully static\n# ◐ (Partial) - Partial prerender with cache\n# λ (Dynamic) - Server-rendered\n```\n\n### 4. Inspect Cache Tags\n\nAdd logging to verify tags:\n\n```tsx\nasync function CachedData({ id }: { id: string }) {\n  'use cache'\n\n  const tags = ['data', `item-${id}`]\n  console.log('Cache tags:', tags) // Check during build\n\n  tags.forEach((tag) => cacheTag(tag))\n  cacheLife('hours')\n\n  return await fetchData(id)\n}\n```\n\n---\n\n## Common Mistakes Checklist\n\n| Mistake                            | Symptom            | Fix                   |\n| ---------------------------------- | ------------------ | --------------------- |\n| Missing `cacheComponents: true`    | No caching         | Add to next.config.ts |\n| Sync function with `'use cache'`   | Build error        | Make function async   |\n| `'use cache'` not first statement  | Cache ignored      | Move to first line    |\n| Accessing cookies/headers in cache | Timeout error      | Extract to wrapper    |\n| Non-serializable arguments         | Inconsistent cache | Use primitives        |\n| Missing Suspense for dynamic       | Streaming broken   | Wrap in Suspense      |\n| Wrong tag in invalidation          | Stale data         | Match cache tags      |\n| Over-caching volatile data         | Stale data         | Reduce cacheLife      |\n\n---\n\n## Performance Optimization Tips\n\n### 1. Profile Cache Hit Rates\n\nMonitor cache effectiveness:\n\n```tsx\nasync function CachedData() {\n  'use cache'\n\n  const start = performance.now()\n  const data = await fetchData()\n  const duration = performance.now() - start\n\n  // Log for analysis\n  console.log(`Cache execution: ${duration}ms`)\n\n  return data\n}\n```\n\n### 2. Optimize Cache Granularity\n\n```tsx\n// ❌ Coarse: One big cached component\nasync function PageContent() {\n  'use cache'\n  const header = await fetchHeader()\n  const posts = await fetchPosts()\n  const sidebar = await fetchSidebar()\n  return <>{/* everything */}</>\n}\n\n// ✅ Fine-grained: Independent cached components\nasync function Header() {\n  'use cache'\n  cacheLife('days')\n  return await fetchHeader()\n}\n\nasync function Posts() {\n  'use cache'\n  cacheLife('hours')\n  return await fetchPosts()\n}\n\nasync function Sidebar() {\n  'use cache'\n  cacheLife('minutes')\n  return await fetchSidebar()\n}\n```\n\n### 3. Strategic Tag Design\n\n```tsx\n// Hierarchical tags for targeted invalidation\ncacheTag(\n  'posts', // All posts\n  `category-${category}`, // Posts in category\n  `post-${id}`, // Specific post\n  `author-${authorId}` // Author's posts\n)\n\n// Invalidate at appropriate level\nupdateTag(`post-${id}`) // Single post changed\nupdateTag(`author-${author}`) // Author updated all posts\nupdateTag('posts') // Nuclear option\n```\n"
      },
      "plugins": [
        {
          "name": "cache-components",
          "source": "./plugins/cache-components",
          "description": "Expert guidance for Next.js Cache Components and Partial Prerendering (PPR). Proactively activates in projects with cacheComponents enabled.",
          "version": "1.0.0",
          "author": {
            "name": "Next.js Team"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add vercel/next.js",
            "/plugin install cache-components@nextjs"
          ]
        }
      ]
    },
    {
      "name": "vercel-plugins",
      "version": null,
      "description": "Official Vercel plugins for Claude Code",
      "owner_info": {
        "name": "Vercel"
      },
      "keywords": [],
      "repo_full_name": "vercel/vercel-deploy-claude-code-plugin",
      "repo_url": "https://github.com/vercel/vercel-deploy-claude-code-plugin",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 5,
        "forks": 0,
        "pushed_at": "2025-12-18T00:09:01Z",
        "created_at": "2025-12-17T22:57:24Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 638
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 430
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 720
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/deploy.md",
          "type": "blob",
          "size": 256
        },
        {
          "path": "commands/logs.md",
          "type": "blob",
          "size": 256
        },
        {
          "path": "commands/setup.md",
          "type": "blob",
          "size": 260
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/deploy",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/deploy/SKILL.md",
          "type": "blob",
          "size": 551
        },
        {
          "path": "skills/logs",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/logs/SKILL.md",
          "type": "blob",
          "size": 473
        },
        {
          "path": "skills/setup",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/setup/SKILL.md",
          "type": "blob",
          "size": 471
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"vercel-plugins\",\n  \"owner\": {\n    \"name\": \"Vercel\"\n  },\n  \"metadata\": {\n    \"description\": \"Official Vercel plugins for Claude Code\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"vercel\",\n      \"source\": \"./\",\n      \"description\": \"Deploy applications to Vercel with deployment monitoring, log analysis, and error detection\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Vercel\"\n      },\n      \"repository\": \"https://github.com/vercel/vercel-deploy-claude-code-plugin\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"vercel\", \"deployment\", \"hosting\", \"ci-cd\", \"web\", \"serverless\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"vercel\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Deploy applications to Vercel with deployment monitoring, log analysis, and error detection\",\n  \"author\": {\n    \"name\": \"Vercel\"\n  },\n  \"repository\": \"https://github.com/vercel/vercel-deploy-claude-code-plugin\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"vercel\", \"deployment\", \"hosting\", \"ci-cd\", \"web\", \"serverless\"],\n  \"skills\": \"./skills/\",\n  \"commands\": \"./commands/\"\n}\n",
        "README.md": "# Vercel Deploy Plugin for Claude Code\n\nDeploy to Vercel directly from Claude Code.\n\n## Installation\n\n```bash\n/plugin install vercel@claude-plugins-official\n```\n\n## Prerequisites\n\n- [Vercel CLI](https://vercel.com/docs/cli) (`npm install -g vercel`)\n- Vercel account (`vercel login`)\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/deploy` | Deploy to production |\n| `/vercel-logs` | View deployment logs |\n| `/vercel-setup` | Set up Vercel CLI and project |\n\n## Skills\n\nSkills are auto-invoked based on context:\n\n- **deploy** - \"deploy my app\", \"push to production\"\n- **vercel-logs** - \"show logs\", \"check deployment logs\"\n- **vercel-setup** - \"set up Vercel\", \"configure Vercel\"\n\n## License\n\nMIT\n",
        "commands/deploy.md": "---\ndescription: Deploy the current project to Vercel\n---\n\n# Deploy to Vercel\n\n1. Check prerequisites (`vercel --version`, `vercel whoami`)\n2. If not set up, run `vercel login`\n3. Run `vercel --prod` for production deployment\n4. Display the deployment URL\n",
        "commands/logs.md": "---\ndescription: View deployment logs from Vercel\n---\n\n# View Vercel Logs\n\n1. Run `vercel ls` to list recent deployments\n2. Fetch logs with `vercel logs <deployment-url>`\n3. Use `--follow` to stream logs in real-time\n4. Analyze and report any errors found\n",
        "commands/setup.md": "---\ndescription: Set up Vercel CLI and configure the project\n---\n\n# Vercel Setup\n\n1. Check/install Vercel CLI (`npm install -g vercel`)\n2. Authenticate with `vercel login`\n3. Link project with `vercel link`\n4. Review environment variables with `vercel env ls`\n",
        "skills/deploy/SKILL.md": "---\nname: deploy\ndescription: Deploy applications to Vercel. Use when the user says \"deploy\", \"deploy to Vercel\", \"push to production\", \"deploy my app\", or \"go live\".\n---\n\n# Deploy to Vercel\n\n## Prerequisites Check\n\n```bash\nvercel --version\nvercel whoami\n```\n\nIf not installed: `npm install -g vercel`\nIf not logged in: `vercel login`\n\n## Deployment\n\n**Production:**\n```bash\nvercel --prod\n```\n\n**Preview:**\n```bash\nvercel\n```\n\n## After Deployment\n\n- Display the deployment URL\n- Show build status\n- Mention `vercel logs <url>` for debugging if needed\n",
        "skills/logs/SKILL.md": "---\nname: logs\ndescription: View Vercel deployment logs. Use when the user says \"show logs\", \"check logs\", \"vercel logs\", or \"what went wrong with the deployment\".\n---\n\n# Vercel Logs\n\n## List Deployments\n\n```bash\nvercel ls\n```\n\n## View Logs\n\n```bash\nvercel logs <deployment-url>\n```\n\n**Follow logs in real-time:**\n```bash\nvercel logs <deployment-url> --follow\n```\n\n## Analyze\n\n- Look for errors or warnings\n- Check for failed function invocations\n- Identify build failures\n",
        "skills/setup/SKILL.md": "---\nname: setup\ndescription: Set up Vercel CLI and project configuration. Use when the user says \"set up Vercel\", \"configure Vercel\", \"link to Vercel\", or \"vercel init\".\n---\n\n# Vercel Setup\n\n## Install CLI\n\n```bash\nnpm install -g vercel\n```\n\n## Authenticate\n\n```bash\nvercel login\n```\n\n## Link Project\n\n```bash\nvercel link\n```\n\n## Environment Variables\n\n```bash\nvercel env ls\nvercel env add <NAME>\n```\n\n## Configuration\n\nCheck for `vercel.json` and `.vercelignore` files.\n"
      },
      "plugins": [
        {
          "name": "vercel",
          "source": "./",
          "description": "Deploy applications to Vercel with deployment monitoring, log analysis, and error detection",
          "version": "1.0.0",
          "author": {
            "name": "Vercel"
          },
          "repository": "https://github.com/vercel/vercel-deploy-claude-code-plugin",
          "license": "MIT",
          "keywords": [
            "vercel",
            "deployment",
            "hosting",
            "ci-cd",
            "web",
            "serverless"
          ],
          "categories": [
            "ci-cd",
            "deployment",
            "hosting",
            "serverless",
            "vercel",
            "web"
          ],
          "install_commands": [
            "/plugin marketplace add vercel/vercel-deploy-claude-code-plugin",
            "/plugin install vercel@vercel-plugins"
          ]
        }
      ]
    }
  ]
}