{
  "author": {
    "id": "haboshi",
    "display_name": "haboshi",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/4361863?v=4",
    "url": "https://github.com/haboshi",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 2,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "haboshi-skills",
      "version": null,
      "description": "Claude Code用スキルコレクション",
      "owner_info": {
        "name": "haboshi",
        "email": "haboshi@allambitious.co.jp"
      },
      "keywords": [],
      "repo_full_name": "haboshi/claude-code-skills",
      "repo_url": "https://github.com/haboshi/claude-code-skills",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-28T22:57:35Z",
        "created_at": "2026-01-28T06:41:38Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 2005
        },
        {
          "path": "image-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "image-creator/SKILL.md",
          "type": "blob",
          "size": 10976
        },
        {
          "path": "pdf-creator-jp",
          "type": "tree",
          "size": null
        },
        {
          "path": "pdf-creator-jp/SKILL.md",
          "type": "blob",
          "size": 4575
        },
        {
          "path": "task-planner",
          "type": "tree",
          "size": null
        },
        {
          "path": "task-planner/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "task-planner/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 329
        },
        {
          "path": "task-planner/README.md",
          "type": "blob",
          "size": 2301
        },
        {
          "path": "task-planner/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "task-planner/commands/decompose.md",
          "type": "blob",
          "size": 6826
        },
        {
          "path": "task-planner/commands/plan.md",
          "type": "blob",
          "size": 11531
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"haboshi-skills\",\n  \"owner\": {\n    \"name\": \"haboshi\",\n    \"email\": \"haboshi@allambitious.co.jp\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code用スキルコレクション\",\n    \"version\": \"0.3.0\",\n    \"homepage\": \"https://github.com/haboshi/claude-code-skills\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"pdf-creator-jp\",\n      \"description\": \"MarkdownファイルをPDFに変換（日本語フォント対応）。weasyprintを使用し、ヒラギノ/游書体で美しい日本語ドキュメントを生成。「PDFに変換」「PDF生成」「レポートをPDFで」「ドキュメントを印刷用に」「資料をPDF化」「マークダウンをPDFに」などのリクエストで使用される。\",\n      \"source\": \"./pdf-creator-jp\",\n      \"strict\": false,\n      \"version\": \"1.0.0\",\n      \"category\": \"document-generation\",\n      \"keywords\": [\"pdf\", \"markdown\", \"japanese\", \"document\", \"weasyprint\", \"日本語\"],\n      \"skills\": [\"./\"]\n    },\n    {\n      \"name\": \"image-creator\",\n      \"description\": \"Google GeminiまたはOpenAI GPT Imageの画像生成モデルで画像を生成・編集。「画像を生成して」「イラストを作って」「この画像を編集して」などの指示で自動的に使用される。ステッカーシート生成・分割にも対応。\",\n      \"source\": \"./image-creator\",\n      \"strict\": false,\n      \"version\": \"1.0.0\",\n      \"category\": \"image-generation\",\n      \"keywords\": [\"image\", \"ai\", \"gemini\", \"openai\", \"generate\", \"画像生成\", \"イラスト\"],\n      \"skills\": [\"./\"]\n    },\n    {\n      \"name\": \"task-planner\",\n      \"description\": \"実装計画とタスク分解のプラグイン。コードベース探索→要件明確化→計画策定→タスク分解→検証。タスク規模に応じて自動的に深度を調整。\",\n      \"author\": {\n        \"name\": \"haboshi\",\n        \"email\": \"haboshi@allambitious.co.jp\"\n      },\n      \"source\": \"./task-planner\",\n      \"category\": \"planning\"\n    }\n  ]\n}\n",
        "image-creator/SKILL.md": "---\nname: image-creator\ndescription: Google GeminiまたはOpenAI GPT Imageの画像生成モデルで画像を生成・編集。「画像を生成して」「イラストを作って」「この画像を編集して」などの指示で自動的に使用される。「ステッカーを何個か作って」「複数のアイコンを生成して分割」などステッカーシート生成・分割にも対応。GeminiとOpenAIの2つのプロバイダーから選択可能。\nallowed-tools: Bash, Read, Write, AskUserQuestion\n---\n\n# Image Creator - AI画像生成スキル\n\nGoogle Gemini または OpenAI GPT Image を使用して画像を生成・編集するスキル。\n\n---\n\n## 生成前の確認フロー\n\n**重要**: 画像生成を開始する前に、必ず `AskUserQuestion` ツールで以下を確認すること。\n\n### 確認項目\n\n**共通（常に確認）:**\n| 項目 | 選択肢 | 説明 |\n|------|--------|------|\n| **プロバイダー** | `gemini` / `openai` | 使用するAIプロバイダー |\n| **モデル** | Gemini: `pro`/`flash`、OpenAI: `1.5`/`1`/`mini` | 詳細は下記参照 |\n| **参照画像** | あり / なし | スタイルをコピーする元画像があるか |\n| **背景除去** | Vision API / マゼンタ除去 / OpenAI透過 / 不要 | 方法は下記参照 |\n\n**複数画像生成の場合のみ追加で確認:**\n| 項目 | 選択肢 | 説明 |\n|------|--------|------|\n| **生成方式** | シート→split / 並列生成 | シート→split推奨（効率的） |\n\n### プロバイダー別の特徴\n\n| プロバイダー | 強み | APIキー環境変数 |\n|-------------|------|----------------|\n| **Gemini** | 日本語プロンプト、参照画像のスタイルコピー | `GEMINI_API_KEY` |\n| **OpenAI** | 高品質、ネイティブ透過背景対応、複数枚同時生成 | `OPENAI_API_KEY` |\n\n### モデル比較\n\n**Gemini:**\n| モデル | ID | 特徴 |\n|-------|-----|------|\n| Flash | `gemini-2.5-flash-image` | 高速、コスト効率 |\n| Pro | `gemini-3-pro-image-preview` | 高品質、複雑な指示に対応 |\n\n**OpenAI:**\n| モデル | ID | 特徴 |\n|-------|-----|------|\n| GPT Image 1.5 | `gpt-image-1.5` | 最新・最高品質（推奨） |\n| GPT Image 1 | `gpt-image-1` | 標準モデル |\n| GPT Image Mini | `gpt-image-1-mini` | 軽量・高速・低コスト |\n\n### 背景除去方法の選び方\n\n| 方法 | 適したケース | プロバイダー |\n|------|-------------|-------------|\n| **OpenAI透過** | OpenAI使用時は`--background transparent`で直接透過生成 | OpenAI専用 |\n| **Vision API** | 実写画像、写真風、複雑な背景、グラデーション背景 | Gemini |\n| **マゼンタ除去** | イラスト、シンプルな図形、線画、フラットデザイン | Gemini |\n\n### 推奨設定\n\n| ケース | プロバイダー | モデル | 背景除去 |\n|--------|-------------|--------|----------|\n| 透過アイコン・ステッカー | OpenAI | 1.5 | `--background transparent` |\n| 参照画像のスタイルコピー | Gemini | pro | Vision API |\n| シンプルなイラスト | Gemini | flash | マゼンタ除去 |\n| 高品質イラスト | OpenAI | 1.5 | 不要 or transparent |\n| プロトタイプ・テスト | OpenAI | mini | 不要 |\n\n---\n\n## ツール一覧\n\n| ツール | 説明 |\n|-------|------|\n| `generate.py` | Gemini画像生成 |\n| `generate_openai.py` | OpenAI画像生成 |\n| `remove-bg-magenta.py` | マゼンタ背景除去（1px収縮含む） |\n| `remove-bg-vision.py` | Vision API背景除去 |\n| `erode.py` | 透過画像エッジ収縮 |\n| `split_transparent.py` | 透過画像を個別オブジェクトに分割 |\n\n## 前提条件\n\n1. **uv**: `curl -LsSf https://astral.sh/uv/install.sh | sh` でインストール\n2. **Gemini使用時**: 環境変数 `GEMINI_API_KEY` を設定\n3. **OpenAI使用時**: 環境変数 `OPENAI_API_KEY` を設定\n4. **Vision API**: macOS 14.0 (Sonoma) 以降が必要\n\n---\n\n## 1. generate.py - Gemini画像生成\n\n```bash\nuv run --with google-genai --with pillow scripts/generate.py \"プロンプト\" [オプション]\n```\n\n### オプション\n\n| オプション | 説明 | デフォルト |\n|-----------|------|-----------|\n| `-o`, `--output` | 出力ファイルパス | `generated_image.png` |\n| `-a`, `--aspect-ratio` | アスペクト比 (`1:1`, `16:9`, `9:16`, `4:3`, `3:4`) | `1:1` |\n| `-m`, `--model` | モデル (`flash`, `pro`) | `pro` |\n| `--magenta-bg` | マゼンタ背景で生成 | なし |\n| `-r`, `--reference` | 参照画像のパス | なし |\n\n### 例\n\n```bash\n# シンプルな生成\nuv run --with google-genai --with pillow scripts/generate.py \"かわいい猫のイラスト\"\n\n# 参照画像のスタイルをコピー\nuv run --with google-genai --with pillow scripts/generate.py \"Same exact style as this image. Object: coffee cup. NO text.\" -r reference.png -o coffee.png\n\n# マゼンタ背景で生成（後で透過処理用）\nuv run --with google-genai --with pillow scripts/generate.py \"シンプルな星のアイコン\" --magenta-bg -o star.png\n```\n\n---\n\n## 2. generate_openai.py - OpenAI画像生成\n\n```bash\nuv run --with openai --with pillow scripts/generate_openai.py \"プロンプト\" [オプション]\n```\n\n### オプション\n\n| オプション | 説明 | デフォルト |\n|-----------|------|-----------|\n| `-o`, `--output` | 出力ファイルパス | `generated_image.png` |\n| `-s`, `--size` | サイズ (`1024x1024`, `1536x1024`, `1024x1536`, `auto`) | `1024x1024` |\n| `-m`, `--model` | モデル (`gpt-image-1`, `gpt-image-1-mini`, `gpt-image-1.5`) | `gpt-image-1.5` |\n| `-q`, `--quality` | 品質 (`low`, `medium`, `high`) | `medium` |\n| `-b`, `--background` | 背景 (`transparent`, `opaque`, `auto`) | `auto` |\n| `-f`, `--format` | 出力形式 (`png`, `jpeg`, `webp`) | `png` |\n| `-r`, `--reference` | 編集する画像のパス | なし |\n| `-n`, `--number` | 生成枚数 (1-10) | `1` |\n\n### 例\n\n```bash\n# シンプルな生成\nuv run --with openai --with pillow scripts/generate_openai.py \"かわいい猫のイラスト\"\n\n# 透過背景で生成（背景除去不要）\nuv run --with openai --with pillow scripts/generate_openai.py \"シンプルな星のアイコン\" -b transparent -o star.png\n\n# 高品質・横長で生成\nuv run --with openai --with pillow scripts/generate_openai.py \"夕焼けの風景\" -s 1536x1024 -q high -o sunset.png\n\n# 複数枚同時生成\nuv run --with openai --with pillow scripts/generate_openai.py \"かわいい動物のアイコン\" -n 5 -b transparent -o animals.png\n\n# 画像編集\nuv run --with openai --with pillow scripts/generate_openai.py \"背景を夜空に変更\" -r input.png -o edited.png\n```\n\n---\n\n## 3. remove-bg-magenta.py - マゼンタ背景除去\n\nマゼンタ/ピンク背景を色ベースで透過にする。\n\n```bash\nuv run --with pillow --with numpy --with scipy scripts/remove-bg-magenta.py 入力画像 [-o 出力画像]\n```\n\n### 仕組み\n- R>180, G<100, B>100 の色を透過\n- 1px収縮でエッジのピンク残りを除去\n\n---\n\n## 4. remove-bg-vision.py - Vision API背景除去\n\nmacOS Vision APIで背景を自動検出して透過にする。\n\n```bash\npython3 scripts/remove-bg-vision.py 入力画像 [-o 出力画像]\n```\n\n> Note: このスクリプトは内部で`remove-bg.swift`を呼び出すため、追加依存なしで動作。\n\n### 特徴\n- 前景を自動検出\n- 参照画像のスタイル（背景含む）を維持した画像に最適\n- macOS 14.0以降が必要\n\n---\n\n## 5. erode.py - エッジ収縮\n\n透過画像のエッジを任意のピクセル数だけ収縮する。\n\n```bash\nuv run --with pillow --with numpy --with scipy scripts/erode.py 入力画像 [-o 出力画像] [-i 収縮量]\n```\n\n| オプション | 説明 | デフォルト |\n|-----------|------|-----------|\n| `-o`, `--output` | 出力画像パス | 入力を上書き |\n| `-i`, `--iterations` | 収縮量（ピクセル数） | `1` |\n\n---\n\n## 6. split_transparent.py - 透過画像分割\n\n透過PNGを個別オブジェクトに分割（ステッカーシート用）。\n\n```bash\nuv run --with opencv-python --with numpy scripts/split_transparent.py 入力画像 [出力ディレクトリ]\n```\n\n### 仕組み\n- アルファチャンネル（透明部分）で境界を検出\n- 連結成分ごとに切り出し\n- 左上→右下の順で番号付け\n\n---\n\n## ワークフロー例\n\n### OpenAI: 透過アイコン生成（推奨・最も簡単）\n\n```bash\n# 1ステップで透過PNG生成\nuv run --with openai --with pillow scripts/generate_openai.py \"シンプルな星のアイコン\" -b transparent -o star.png\n```\n\n### OpenAI: 複数アイコン同時生成\n\n```bash\n# 5枚同時に透過PNG生成\nuv run --with openai --with pillow scripts/generate_openai.py \"かわいい動物のアイコン、1つの動物\" -n 5 -b transparent -o animal.png\n# → animal_01.png, animal_02.png, ... が生成される\n```\n\n### Gemini: 透過ステッカー生成（単純なオブジェクト）\n\n```bash\n# 1. マゼンタ背景で生成\nuv run --with google-genai --with pillow scripts/generate.py \"シンプルな星のアイコン\" --magenta-bg -o star.png\n\n# 2. マゼンタ除去\nuv run --with pillow --with numpy --with scipy scripts/remove-bg-magenta.py star.png\n```\n\n### Gemini: 参照画像スタイルコピー + 透過\n\n```bash\n# 1. 参照画像のスタイルで生成（スタイル維持のためマゼンタ指定なし）\nuv run --with google-genai --with pillow scripts/generate.py \"Same exact style as this image. Object: coffee cup. NO text.\" -r reference.png -o coffee.png\n\n# 2. Vision APIで背景除去\npython3 scripts/remove-bg-vision.py coffee.png\n```\n\n### Gemini: ステッカーシート生成 → 分割\n\n```bash\n# 1. マゼンタ背景で複数ステッカー生成\nuv run --with google-genai --with pillow scripts/generate.py \\\n  \"Multiple separate kawaii stickers with LARGE gaps: coffee cup, donut, cat, star. Arranged in 2x2 grid, well separated.\" \\\n  --magenta-bg -o sheet.png\n\n# 2. 背景透過\nuv run --with pillow --with numpy --with scipy scripts/remove-bg-magenta.py sheet.png\n\n# 3. 個別分割\nuv run --with opencv-python --with numpy scripts/split_transparent.py sheet.png ./stickers/\n```\n\n**プロンプトのコツ:**\n- `LARGE gaps between them` - 間隔を広く\n- `well separated` - 重ならないように\n- `Arranged in XxY grid` - グリッド配置指定\n\n---\n\n## ファイル構成\n\n```\nimage-creator/\n├── SKILL.md               # このドキュメント\n└── scripts/\n    ├── generate.py            # Gemini画像生成\n    ├── generate_openai.py     # OpenAI画像生成\n    ├── remove-bg-magenta.py   # マゼンタ背景除去（1px収縮含む）\n    ├── remove-bg-vision.py    # Vision API背景除去\n    ├── remove-bg.swift        # Vision API実装（Swift）\n    ├── erode.py               # エッジ収縮（単体）\n    └── split_transparent.py   # 透過画像分割\n```\n",
        "pdf-creator-jp/SKILL.md": "---\nname: pdf-creator-jp\ndescription: MarkdownファイルをPDFに変換（日本語フォント対応）。weasyprintを使用し、ヒラギノ/游書体で美しい日本語ドキュメントを生成。「PDFに変換」「PDF生成」「レポートをPDFで」「ドキュメントを印刷用に」「資料をPDF化」「マークダウンをPDFに」などのリクエストで使用される。\n---\n\n# PDF Creator (日本語版)\n\nMarkdownファイルを日本語フォント対応の高品質PDFに変換します。\n\n## 機能\n\n- ✅ **日本語フォント対応**: ヒラギノ明朝/角ゴシック、游書体フォールバック\n- ✅ **ページ番号**: 「1 / N」形式で自動挿入（最初のページは除外）\n- ✅ **目次自動生成**: `--toc` オプションでH2/H3見出しから自動生成\n- ✅ **3種類のスタイル**: business / technical / minimal\n- ✅ **コードブロック折り返し**: 長いコードも自動折り返し\n- ✅ **表のヘッダー繰り返し**: 複数ページにまたがる表でヘッダー継続\n- ✅ **環境自動設定**: macOS Homebrew環境変数を自動検出\n\n## クイックスタート\n\n```bash\n# 基本変換\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py input.md output.pdf\n\n# 目次付き\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py input.md --toc\n\n# 技術文書スタイル\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py input.md --style technical\n\n# フルオプション\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py input.md output.pdf --toc --style business\n```\n\n## CLIオプション\n\n| オプション | 説明 | デフォルト |\n|-----------|------|-----------|\n| `input` | 入力Markdownファイル（必須） | - |\n| `output` | 出力PDFファイル | 入力ファイル名.pdf |\n| `--toc` | 目次を生成 | なし |\n| `--style`, `-s` | スタイルプリセット | business |\n| `--no-page-numbers` | ページ番号を非表示 | ページ番号あり |\n\n## スタイルプリセット\n\n### `business`（デフォルト）\n- **用途**: ビジネスレポート、提案書、分析資料\n- **特徴**:\n  - 見出し: ダークブルー(#0A2C4A) + 下線装飾\n  - H1: 中央揃え、二重線\n  - H3: 左側に縦線アクセント\n  - フォーマル感のあるデザイン\n\n### `technical`\n- **用途**: 技術文書、仕様書、マニュアル\n- **特徴**:\n  - 見出し: シンプルな黒\n  - H1: 左揃え、単線\n  - コードブロック: ダークテーマ（VS Code風）\n  - コード重視のレイアウト\n\n### `minimal`\n- **用途**: シンプルな文書、メモ、軽量PDF\n- **特徴**:\n  - 最小限の装飾\n  - 見出し: 太字のみ\n  - 表: 枠線なし、下線のみ\n  - 軽量で読みやすい\n\n## 出力仕様\n\n| 項目 | 値 |\n|------|-----|\n| 用紙サイズ | A4 |\n| 余白 | 上下2.5cm/3cm、左右2cm |\n| 本文 | 11pt、行間1.8 |\n| 見出し | ヒラギノ角ゴシック |\n| 本文 | ヒラギノ明朝 |\n| ページ番号 | 「1 / N」形式（フッター中央） |\n\n## フォント設定\n\n| 用途 | 優先フォント | フォールバック |\n|------|-------------|---------------|\n| 本文 | Hiragino Mincho ProN | YuMincho, Noto Serif CJK JP |\n| 見出し | Hiragino Kaku Gothic ProN | YuGothic, Noto Sans CJK JP |\n| コード | SF Mono | Monaco, Menlo, Source Code Pro |\n\n## 使用例\n\n```bash\n# レポートをPDFに（基本）\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py report.md\n\n# 目次付きビジネスレポート\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py report.md ~/Downloads/report.pdf --toc\n\n# 技術仕様書（ダークテーマコード）\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py spec.md --style technical --toc\n\n# シンプルなメモ（ページ番号なし）\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py memo.md --style minimal --no-page-numbers\n```\n\n## トラブルシューティング\n\n### 日本語が文字化けする\nシステムにヒラギノまたは游書体がインストールされていることを確認してください。macOSでは標準搭載されています。\n\n### `weasyprint` インポートエラー\n```bash\nuv run --with weasyprint --with markdown scripts/md_to_pdf.py ...\n```\nで依存関係を含めて実行してください。\n\n### ライブラリエラー（macOS）\n通常は自動設定されますが、問題が発生する場合:\n```bash\nexport DYLD_LIBRARY_PATH=\"/opt/homebrew/lib:$DYLD_LIBRARY_PATH\"\n```\n",
        "task-planner/.claude-plugin/plugin.json": "{\n  \"name\": \"task-planner\",\n  \"description\": \"実装計画とタスク分解のプラグイン。コードベース探索→要件明確化→計画策定→タスク分解→検証。タスク規模に応じて自動的に深度を調整。\",\n  \"author\": {\n    \"name\": \"haboshi\",\n    \"email\": \"haboshi@allambitious.co.jp\"\n  }\n}\n",
        "task-planner/README.md": "# Task Planner Plugin\n\n実装計画とタスク分解を行う Claude Code プラグイン。\n\n## 特徴\n\n| 機能 | 説明 |\n|------|------|\n| **適応型プロセス** | タスク規模に応じて計画の深度を自動調整 |\n| **リッチタスク記述** | What/Where/How/Why/Verify 形式 |\n| **インタビュー駆動** | 不明点は推測せず確認 |\n| **リスク評価** | Medium/Large タスクで自動実行 |\n| **再帰的検証** | ギャップ発見時に自動で再計画 |\n| **承認待ち** | 明示的確認までコード生成しない |\n\n## コマンド\n\n| コマンド | 用途 |\n|---------|------|\n| `/task-planner:plan` | 完全な実装計画を策定 |\n| `/task-planner:decompose` | 既存計画のタスク分解のみ |\n\n## インストール\n\n### マーケットプレイスからインストール\n\n```bash\n/plugin marketplace add haboshi/claude-code-skills\n/plugin install task-planner@haboshi/claude-code-skills\n```\n\n## ディレクトリ構造\n\n```\ntask-planner/\n├── .claude-plugin/\n│   └── plugin.json       # プラグイン定義\n├── commands/\n│   ├── plan.md           # /task-planner:plan コマンド\n│   └── decompose.md      # /task-planner:decompose コマンド\n├── SKILL.md              # プラグイン概要\n└── README.md             # このファイル\n```\n\n## プロセス\n\n### /task-planner:plan（規模に応じて自動調整）\n\n```\nSmall:  EXPLORE → CLARIFY → DECOMPOSE → VALIDATE\nMedium: EXPLORE → CLARIFY → PLAN(簡易) → DECOMPOSE → VALIDATE\nLarge:  EXPLORE → CLARIFY → PLAN(完全) → DECOMPOSE → VALIDATE\n```\n\n### /task-planner:decompose\n\n```\nEXPLORE → INTERVIEW → DECOMPOSE → VALIDATE\n```\n\n## タスク記述フォーマット\n\n```markdown\n### Task [N]: [タスクタイトル]\n\n**What**: [具体的なアクション]\n**Where**: [ファイルパス、関数名]\n**How**: [実装アプローチ]\n**Why**: [目的]\n**Verify**: [検証手順]\n```\n\n## モデル\n\n**Claude Opus 4.5** を使用（計画には最高の推論能力が必要）。\n\n## 関連コマンド\n\n計画承認後に使用:\n\n- `/tdd` - テスト駆動開発で実装\n- `/build-fix` - ビルドエラー発生時\n- `/code-review` - 実装完了後のレビュー\n\n## ライセンス\n\nMIT\n",
        "task-planner/commands/decompose.md": "---\ndescription: 既存の計画や要件を詳細な実行可能タスクに分解。各タスクはWhat/Where/How/Why/Verify形式のリッチ記述で、説明だけで実行可能。\n---\n\n# Decompose Command\n\nあなたはタスク分解の専門家です。複雑なタスクを、説明だけで独立実行可能な単位に分解します。\n\n## Core Principle\n\n**分解されたタスクは、その記述だけを読んで実行できなければならない。**\n\n曖昧な「認証を実装する」ではなく、ファイルパス・関数名・テストコマンドまで含める。\n\n## Process\n\n```\nEXPLORE → INTERVIEW → DECOMPOSE → VALIDATE\n                        ↑            │\n                        └── ギャップ ─┘\n```\n\n---\n\n## Step 1: EXPLORE\n\n分解対象のコンテキストを把握する。**探索していないコードに基づくタスクを作らない。**\n\n<explore_checklist>\n- 分解対象の計画/要件\n- CLAUDE.md / README.md（あれば）\n- 影響を受けるファイル群\n- 既存の実装パターン（命名、構造、テスト規約）\n- 依存関係\n</explore_checklist>\n\n### 遷移条件\n\n変更対象のファイルと既存パターンを把握できたら Step 2 へ。\n\n---\n\n## Step 2: INTERVIEW\n\n分解に影響する不明点を確認する。\n\n<interview_rules>\n- AskUserQuestion で 2〜4問/ラウンド\n- 各質問に 2〜4 の具体的選択肢（Pros/Cons 付き）\n- 明らかな答えは聞かない -- 難しい判断を掘り出す\n- 「その他」は自動追加されるため含めない\n</interview_rules>\n\n質問すべき判断:\n- **スコープ**: 今回に含めるか、別タスクか\n- **粒度**: 1 タスクか、サブタスクに分割か\n- **順序**: 依存関係は? 並列可能か?\n- **完了基準**: 何をもって「完了」とするか\n\n<interview_anti_patterns>\n絶対にやらない:\n- 「どうしますか?」（選択肢なし）\n- 「〜でいいですか?」（Yes/No 誘導）\n- 「テストは必要ですか?」（当然 Yes）\n\nやるべき: ユーザーが考えていなかった難しい判断を掘り出す\n</interview_anti_patterns>\n\n### 遷移条件\n\n不明点がゼロになったら Step 3 へ。\n\n---\n\n## Step 3: DECOMPOSE\n\nタスクを実行可能な単位に分解する。\n\n<task_requirements>\n**Specific** -- アクション動詞で始まる。正確なファイルパス・関数名を明記。\n**Achievable** -- 外部ブロッカーなしで完了可能。必要情報がすべて含まれる。\n**Small** -- 5〜30分で完了。単一責任。独立検証可能。\n</task_requirements>\n\n### タスク記述フォーマット\n\n```markdown\n### Task [N]: [アクション動詞] + [対象]\n\n**What**: [具体的に何をするか]\n**Where**: [ファイルパス、関数名、行範囲]\n**How**: [実装アプローチ -- 既存パターンを参照]\n**Why**: [目的、全体との関係]\n**Verify**: [テストコマンド or 手動確認手順]\n```\n\n分解したタスクは TaskCreate ツールで登録する。\n\n### 遷移条件\n\n元の要件がすべてタスクでカバーされていること。\n\n---\n\n## Step 4: VALIDATE\n\n分解の完全性を検証する。\n\n<validation_checklist>\n- [ ] 元の要件がすべてタスクでカバーされている\n- [ ] 各タスクが独立して実行可能\n- [ ] 各タスクに具体的な検証ステップがある\n- [ ] 5〜30分で完了可能な粒度\n- [ ] タスク間の依存関係が正しい\n- [ ] エラーハンドリングが考慮されている\n</validation_checklist>\n\nギャップ発見時: Step 2-3 に戻って再実行 → 再検証。\n\n---\n\n## Output Format\n\n```markdown\n## タスク分解結果\n\n### 元のタスク\n[分解対象の要約]\n\n### 分解されたタスク\n\n#### Task 1: [タイトル]\n**What**: ...\n**Where**: ...\n**How**: ...\n**Why**: ...\n**Verify**: ...\n\n#### Task 2: [タイトル]\n...\n\n### 依存関係\n- Task 1 → Task 2（[理由]）\n\n### サマリー\n- 総タスク数: N\n- 複雑度: Low / Medium / High\n```\n\n---\n\n## 実行例: 認証機能の Phase 2 分解\n\n入力: `/decompose 認証機能の Phase 2（認証ロジック）を分解して`\n\n### EXPLORE 結果\n\n```\nPhase 1 完了済み: User モデル + マイグレーション済み\nsrc/utils/token.ts に JWT ユーティリティのパターンあり\nsrc/middleware/error.ts にミドルウェアパターンあり\nテスト: Jest + supertest\n```\n\n### 分解結果\n\n#### Task 1: パスワードハッシュユーティリティを実装\n\n**What**: hashPassword() と verifyPassword() 関数を作成\n**Where**: `src/utils/password.ts`（新規）\n**How**: bcrypt, saltRounds=12。`src/utils/token.ts` のエクスポートパターンに従う\n**Why**: register と login でパスワードの安全な処理に使用\n**Verify**: `npm test -- --testPathPattern=password` → hash 生成 + 照合テスト通過\n\n#### Task 2: JWT 生成・検証ユーティリティを実装\n\n**What**: generateToken() と verifyToken() 関数を作成\n**Where**: `src/utils/auth-token.ts`（新規）\n**How**: jsonwebtoken 使用。秘密鍵は環境変数 JWT_SECRET。有効期限 24h\n**Why**: ログイン成功時のトークン発行と、ミドルウェアでの検証に使用\n**Verify**: `npm test -- --testPathPattern=auth-token` → 生成/検証/期限切れの 3 パターン\n\n#### Task 3: 認証ミドルウェアを作成\n\n**What**: authenticateToken ミドルウェアを作成。req.user にデコード結果を設定\n**Where**: `src/middleware/auth.ts`（新規）\n**How**: Authorization ヘッダーから Bearer トークン取得 → verifyToken → 失敗時 401\n**Why**: 保護エンドポイントへのアクセス制御\n**Verify**: supertest で有効/無効/トークンなしの 3 パターン確認\n\n### 依存関係\n\n- Task 1, Task 2: 並列実行可能\n- Task 3: Task 2 完了後に着手\n\n### サマリー\n\n- 総タスク数: 3\n- 複雑度: Medium\n\n---\n\n## Critical Rules\n\n<rules>\n1. **コードを書かない** -- 分解のみ、実装はしない\n2. **探索を省略しない** -- 実コードを読んでから分解する\n3. **推測しない** -- 不明点はインタビューで確認\n4. **粒度を落とさない** -- 各タスクは 30 分以内で完了可能\n5. **検証を省略しない** -- 各タスクに具体的な確認方法を\n6. **実コードを参照** -- ファイルパス・関数名は実在のものを使う\n</rules>\n\n## Anti-Patterns\n\n<anti_patterns>\n- テンプレートのプレースホルダーが残った出力\n- すべてのタスクに「テストが通る」としか書かない検証ステップ\n- 探索せずにファイルパスを推測する\n- 1 タスクに複数の責任を詰め込む\n- タスク間の依存関係を無視した順序\n</anti_patterns>\n",
        "task-planner/commands/plan.md": "---\ndescription: 実装計画を作成。コードベース探索→要件明確化→計画策定→タスク分解→検証。タスク規模に応じて自動的に深度を調整。ユーザー確認まで一切コードを書かない。\n---\n\n# Plan Command\n\nあなたは実装計画の専門家です。コードベースの実態に基づき、実行可能で完全な計画を作成します。\n\n## Core Principles\n\n- **探索なき計画は空論** -- コードを読まずに計画を立てない\n- **確認なき計画は独善** -- 推測で進めず、不明点はユーザーに確認する\n- **検証なき計画は不完全** -- 計画完了後にギャップチェックし、不足があれば戻る\n- **承認なき実装は暴走** -- 最終出力後、ユーザーの明示的承認を待つ\n\n## Process\n\n```\nEXPLORE → CLARIFY → PLAN → DECOMPOSE → VALIDATE → WAIT FOR APPROVAL\n                     ↑                      │\n                     └──── ギャップ発見時 ───┘\n```\n\nタスク規模の判定（EXPLORE 完了後に自動判断）:\n\n| 規模 | 条件 | PLAN の深度 |\n|------|------|------------|\n| Small | 単一ファイル変更、明確な要件 | スキップ → 直接 DECOMPOSE |\n| Medium | 複数ファイル、一部設計判断あり | 簡易リスクスキャン + フェーズ概要 |\n| Large | アーキテクチャ変更、多数の依存 | 完全リスク分析 + フェーズ設計 + ロールバック計画 |\n\n---\n\n## Step 1: EXPLORE\n\nコードベースの実態を把握する。**探索していないものを計画に含めない。**\n\n<explore_checklist>\n- プロジェクト構造（ディレクトリ、主要モジュール）\n- CLAUDE.md / README.md（あれば）\n- 依存関係（package.json, requirements.txt 等）\n- 影響を受けるファイル群\n- 類似機能の既存実装パターン\n- テスト構造と規約\n</explore_checklist>\n\n### 遷移条件\n\n以下をすべて特定できたら Step 2 へ:\n- 技術スタック\n- 変更が必要なファイルの候補\n- 参考にすべき既存パターン\n\n---\n\n## Step 2: CLARIFY\n\n要件を自分の言葉で再構成し、不明点をインタビューで解消する。\n\n### 要件の再構成\n\n```markdown\n**目的**: [このタスクが解決する問題]\n**スコープ**: [含む / 含まない を明示]\n**成功基準**: [完了とみなす条件]\n```\n\n### インタビュー（AskUserQuestion）\n\n<interview_rules>\n- 2〜4問/ラウンド\n- 各質問に 2〜4 の具体的選択肢（Pros/Cons 付き）\n- 「その他」は自動追加されるため含めない\n- 不明点がすべて解消されるまで複数ラウンド可\n</interview_rules>\n\n質問すべき判断:\n- **スコープ**: 今回含めるか、別タスクか\n- **アプローチ**: 既存修正か、新規作成か\n- **トレードオフ**: 速度重視か、拡張性重視か\n- **リスク**: 不確実な領域にスパイク（調査タスク）を入れるか\n\n<interview_anti_patterns>\n絶対にやらない:\n- 「どうしますか？」（選択肢なし -- 丸投げ）\n- 「〜でいいですか？」（Yes/No 誘導 -- 判断を放棄）\n- 「要件を教えてください」（丸投げ -- 探索した情報から質問を構成する）\n- 明らかな答えを聞く（「テストは必要ですか？」など）\n\nやるべき: ユーザーが考えていなかった難しい判断を掘り出す\n</interview_anti_patterns>\n\n### 遷移条件\n\n不明点がゼロになったら Step 3 へ。\n\n---\n\n## Step 3: PLAN（規模に応じて調整）\n\n### Small → スキップして Step 4 へ\n\n### Medium\n\n```markdown\n## リスクスキャン\n- [リスク1]: [重要度] → [緩和策]\n- [リスク2]: [重要度] → [緩和策]\n\n## フェーズ概要\n1. [フェーズ1]: [目的] -- 検証: [確認方法]\n2. [フェーズ2]: [目的] -- 検証: [確認方法]\n```\n\n### Large（上記に加えて）\n\n```markdown\n## リスク詳細分析\n\n重要度判定: 影響(高)×確率(高)=CRITICAL / 影響(高)×確率(中)=HIGH / 影響(中)×確率(中)=MEDIUM\n\n### [リスク名]\n- 重要度: CRITICAL / HIGH / MEDIUM\n- 影響: [発生した場合の具体的影響]\n- 緩和策: [事前対策]\n- 発生時対応: [起きた場合の対処]\n\n## ロールバック計画\n- Phase N 失敗時: [復旧手順]\n\n## チェックポイント\n- Phase N 完了条件: [具体的基準]\n- Phase N+1 開始条件: [前提条件]\n```\n\n### 遷移条件\n\n- HIGH 以上のリスクに緩和策があること\n- フェーズ分割が明確であること\n\n---\n\n## Step 4: DECOMPOSE\n\n各フェーズを実行可能なタスクに分解する。\n\n<task_requirements>\n**Specific** -- アクション動詞で始まる。ファイルパス・関数名を明記。\n**Achievable** -- 外部ブロッカーなしで完了可能。必要情報がすべて含まれる。\n**Small** -- 5〜30分で完了。単一責任。独立検証可能。\n</task_requirements>\n\n### タスク記述フォーマット\n\n```markdown\n### Task [N]: [アクション動詞] + [対象]\n\n**What**: [具体的に何をするか]\n**Where**: [ファイルパス、関数名、行範囲]\n**How**: [実装アプローチ -- 既存パターンを参照]\n**Why**: [目的、全体との関係]\n**Verify**: [テストコマンド or 手動確認手順]\n```\n\nタスクは TaskCreate ツールで登録する（subject にタイトル、description にリッチ記述）。\n\n### 遷移条件\n\n元の要件がすべてタスクでカバーされていること。\n\n---\n\n## Step 5: VALIDATE\n\n計画の完全性を検証する。\n\n<validation_checklist>\n### カバレッジ\n- [ ] 元の要件がすべてタスクでカバーされている\n- [ ] エラーハンドリングが考慮されている\n- [ ] エッジケースが特定されている\n- [ ] テスト戦略が含まれている\n\n### 実行可能性\n- [ ] 各タスクが独立して実行可能\n- [ ] 各タスクに具体的な検証ステップがある\n- [ ] 不明点がすべて解消されている\n\n### 一貫性\n- [ ] タスク間の依存関係が正しい\n- [ ] 実行順序が論理的\n</validation_checklist>\n\nギャップ発見時: 該当ステップに戻って再実行 → 再検証。\n\n---\n\n## Final Output\n\n```markdown\n# 実装計画: [タスク名]\n\n## 要件サマリー\n[確定した要件の要約]\n\n## リスクと緩和策（Medium/Large のみ）\n| リスク | 重要度 | 緩和策 |\n|--------|--------|--------|\n\n## 実装フェーズ\n\n### Phase 1: [名前]\n- Task 1: [リッチ記述]\n- Task 2: [リッチ記述]\n- Checkpoint: [完了基準]\n\n### Phase 2: [名前]\n...\n\n## 依存関係\n- Task A → Task B\n\n## サマリー\n- 総タスク数: N\n- 複雑度: Low / Medium / High\n\n---\nこの計画で進めてよろしいですか？\n- `yes` → 実装開始\n- `modify: [内容]` → 計画修正\n- `no` → 計画破棄\n```\n\n---\n\n## 実行例: ユーザー認証の追加\n\n以下は `/plan ユーザー認証を追加したい` を実行した場合の具体例です。\n\n### EXPLORE 結果\n\n```\nプロジェクト: Express.js + TypeScript / Prisma ORM\nsrc/routes/ に既存ルートパターン（posts.ts, comments.ts）\nsrc/middleware/error.ts にミドルウェアパターン\njsonwebtoken が package.json に存在（未使用）\nテスト: Jest + supertest\n```\n\n### CLARIFY 結果\n\n```\nQ1: 認証方式 → JWT（package.json に存在、ステートレス、API向き）\nQ2: ソーシャルログイン → 今回はメール/パスワードのみ\nスコープ: 登録 + ログイン + 認証ミドルウェア + 保護エンドポイント\n除外: パスワードリセット、メール認証\n```\n\n### PLAN 結果（Medium 規模と判定）\n\n```\nリスク:\n- パスワード平文保存: HIGH → bcrypt で緩和\n- JWT 秘密鍵の管理: MEDIUM → 環境変数 + .env.example に記載\n\nフェーズ:\n  Phase 1: データ層（User モデル、マイグレーション）\n  Phase 2: 認証ロジック（ハッシュ、JWT、ミドルウェア）\n  Phase 3: ルート（register, login, 保護エンドポイント）\n```\n\n### DECOMPOSE 結果\n\n#### Task 1: User モデルを作成\n\n**What**: id, email, passwordHash, createdAt フィールドを持つ User モデルを追加\n**Where**: `prisma/schema.prisma`, `src/types/user.ts`\n**How**: 既存の Post モデルのパターンに従い、Prisma スキーマと TypeScript 型を定義\n**Why**: 認証の基盤としてユーザー情報を保存\n**Verify**: `npx prisma migrate dev --name add-user` 成功 → `npx prisma studio` でテーブル確認\n\n#### Task 2: パスワードハッシュユーティリティを実装\n\n**What**: hashPassword() と verifyPassword() 関数を作成\n**Where**: `src/utils/password.ts`（新規）、`src/utils/token.ts` のパターンを参照\n**How**: bcrypt, saltRounds=12。入力バリデーション付き\n**Why**: パスワードの安全な保存。register と login で使用\n**Verify**: `npm test -- --testPathPattern=password` → hash 生成テスト + 照合テスト通過\n\n#### Task 3: JWT ユーティリティを実装\n\n**What**: generateToken() と verifyToken() 関数を作成\n**Where**: `src/utils/auth-token.ts`（新規）\n**How**: jsonwebtoken 使用。秘密鍵は環境変数 JWT_SECRET。有効期限 24h\n**Why**: ログイン成功時のトークン発行とミドルウェアでの検証\n**Verify**: `npm test -- --testPathPattern=auth-token` → 生成/検証/期限切れの 3 パターン\n\n#### Task 4: 認証ミドルウェアを作成\n\n**What**: authenticateToken ミドルウェアを作成し、req.user にデコード結果を設定\n**Where**: `src/middleware/auth.ts`（新規）、`src/middleware/error.ts` のパターンを参照\n**How**: Authorization ヘッダーから Bearer トークン取得 → verifyToken → 失敗時 401\n**Why**: 保護エンドポイントへのアクセス制御\n**Verify**: supertest で有効/無効/トークンなしの 3 パターン確認\n\n#### Task 5: 登録・ログインエンドポイントを追加\n\n**What**: POST /api/auth/register と POST /api/auth/login を作成\n**Where**: `src/routes/auth.ts`（新規）、`src/routes/index.ts` にルート登録\n**How**: Zod でバリデーション → ハッシュ/検証 → JWT 生成 → レスポンス\n**Why**: ユーザー登録とログイン機能の提供\n**Verify**: `curl -X POST localhost:3000/api/auth/register -H \"Content-Type: application/json\" -d '{\"email\":\"test@example.com\",\"password\":\"SecurePass123\"}'` → 201 + JWT\n\n---\n\n## Critical Rules\n\n<rules>\n1. **コードを書かない** -- ユーザーが明示的に承認するまで\n2. **探索を省略しない** -- 実態を知らずに計画しない\n3. **推測しない** -- 不明点はインタビューで確認\n4. **粒度を落とさない** -- 各タスクは 30 分以内で完了可能に\n5. **検証を省略しない** -- 各タスクに具体的な確認方法を\n6. **実コードを参照** -- ファイルパス・関数名は実在のものを使う\n</rules>\n\n## Anti-Patterns\n\n<anti_patterns>\n- テンプレートをそのまま出力する（プレースホルダーが残っている）\n- Phase を機械的に通過する（各 Step で十分に探索・思考していない）\n- 全タスクに同じ検証方法を書く（「テストが通る」は具体的ではない）\n- 探索せずにファイルパスを推測する\n- ユーザーの言葉をそのまま繰り返すだけの要件再構成\n</anti_patterns>\n"
      },
      "plugins": [
        {
          "name": "pdf-creator-jp",
          "description": "MarkdownファイルをPDFに変換（日本語フォント対応）。weasyprintを使用し、ヒラギノ/游書体で美しい日本語ドキュメントを生成。「PDFに変換」「PDF生成」「レポートをPDFで」「ドキュメントを印刷用に」「資料をPDF化」「マークダウンをPDFに」などのリクエストで使用される。",
          "source": "./pdf-creator-jp",
          "strict": false,
          "version": "1.0.0",
          "category": "document-generation",
          "keywords": [
            "pdf",
            "markdown",
            "japanese",
            "document",
            "weasyprint",
            "日本語"
          ],
          "skills": [
            "./"
          ],
          "categories": [
            "document",
            "document-generation",
            "japanese",
            "markdown",
            "pdf",
            "weasyprint",
            "日本語"
          ],
          "install_commands": [
            "/plugin marketplace add haboshi/claude-code-skills",
            "/plugin install pdf-creator-jp@haboshi-skills"
          ]
        },
        {
          "name": "image-creator",
          "description": "Google GeminiまたはOpenAI GPT Imageの画像生成モデルで画像を生成・編集。「画像を生成して」「イラストを作って」「この画像を編集して」などの指示で自動的に使用される。ステッカーシート生成・分割にも対応。",
          "source": "./image-creator",
          "strict": false,
          "version": "1.0.0",
          "category": "image-generation",
          "keywords": [
            "image",
            "ai",
            "gemini",
            "openai",
            "generate",
            "画像生成",
            "イラスト"
          ],
          "skills": [
            "./"
          ],
          "categories": [
            "ai",
            "gemini",
            "generate",
            "image",
            "image-generation",
            "openai",
            "イラスト",
            "画像生成"
          ],
          "install_commands": [
            "/plugin marketplace add haboshi/claude-code-skills",
            "/plugin install image-creator@haboshi-skills"
          ]
        },
        {
          "name": "task-planner",
          "description": "実装計画とタスク分解のプラグイン。コードベース探索→要件明確化→計画策定→タスク分解→検証。タスク規模に応じて自動的に深度を調整。",
          "author": {
            "name": "haboshi",
            "email": "haboshi@allambitious.co.jp"
          },
          "source": "./task-planner",
          "category": "planning",
          "categories": [
            "planning"
          ],
          "install_commands": [
            "/plugin marketplace add haboshi/claude-code-skills",
            "/plugin install task-planner@haboshi-skills"
          ]
        }
      ]
    }
  ]
}