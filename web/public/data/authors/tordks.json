{
  "author": {
    "id": "tordks",
    "display_name": "tordks",
    "avatar_url": "https://avatars.githubusercontent.com/u/10962463?v=4"
  },
  "marketplaces": [
    {
      "name": "claude-workflow",
      "version": null,
      "description": "Plan-driven development workflow for Claude Code with phase-based implementation",
      "repo_full_name": "tordks/claude-workflow",
      "repo_url": "https://github.com/tordks/claude-workflow",
      "repo_description": "Exploration into plan-driven development for Claude Code",
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-02-14T20:03:58Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-workflow\",\n  \"owner\": {\n    \"name\": \"tordks\",\n    \"email\": \"tordks@users.noreply.github.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"cwf\",\n      \"version\": \"0.2.2\",\n      \"source\": \"./plugins/cwf\",\n      \"description\": \"Plan-driven development workflow for Claude Code with phase-based implementation\"\n    }\n  ]\n}\n",
        "README.md": "# Claude Workflow\n\n[![Version](https://img.shields.io/badge/version-0.2.2-blue.svg)](https://github.com/tordks/claude-workflow/releases)\n[![Claude Code](https://img.shields.io/badge/Claude%20Code-Plugin-purple.svg)](https://claude.com/claude-code)\n\nClaude Workflow (CWF) defines a plan-driven development workflow for Claude Code with phase-based implementation.\n\n## What Problem Does CWF Solve?\n\nWhen work spans multiple sessions or outgrows a single context window, AI-assisted development breaks down in two ways:\n\n1. **The agent loses context.** Architectural decisions, refined requirements, and implementation progress disappear when context is compacted or a session ends. The next session starts from scratch, and the agent re-derives what was already decided, or worse, decides differently.\n\n2. **The developer loses ownership.** Without a plan to review upfront, the agent makes design decisions implicitly as it codes. Problems compound across files before anyone notices, and the codebase drifts from the developer's intent.\n\nBoth stem from the same gap: nothing captures what was decided, what was built, and what remains. CWF fills this gap with plan and tasklist documents, and structures implementation around them:\n\n- **Persistent plan documents** give every session the full picture of architectural decisions, design rationale, and progress so far.\n- **Phase-based implementation** breaks work into sequential phases with concrete deliverables, so scope and sequencing are decided before coding starts.\n- **Automated checkpoints** run code quality, complexity, and test checks at phase boundaries, catching issues before they accumulate.\n- **Scheduled human review** between phases keeps the developer in control, not just informed.\n\n## When to Use CWF\n\nThe workflow should match the complexity of the work. CWF is designed for features that involve architectural decisions, touch multiple components, or span multiple sessions. For quick fixes or single-session work, chat mode or plan mode is more efficient.\n\n**Chat mode** — no upfront planning:\n\n- Fix a null pointer exception\n- Add one or more logging statements\n- Explore or explain unfamiliar code\n\n**Plan mode** — plan first, then implement in one session:\n\n- Add form validation to the signup page\n- Refactor a module to use dependency injection\n\n**CWF** — persistent plan, multi-session with review checkpoints:\n\n- Build user authentication with OAuth, sessions, and role-based access\n- Add a payment integration that touches API, database, and frontend\n- Bootstrap and set up an initial version of a greenfield project\n- Implement a new feature that requires design decisions and will take multiple sessions to complete\n\n## The Workflow\n\nBased on an input context (specification, design discussion, or brainstorm), CWF produces a plan and tasklist that break down the work into phases with runnable deliverables. The agent implements phase-by-phase, running quality checkpoints and pausing for human review before proceeding to the next phase.\n\nEach phase is started manually with `/implement-plan`, which continues from the next incomplete task and accepts free-form instructions to control scope. This allows you to pause and resume implementation across sessions without losing context or progress.\n\n```text\n       input context (plan draft, design discussion, specification file)\n               │\n               ├── /brainstorm (optional: structured exploration\n               │                to extract requirements and\n               │                design decisions)\n               ↓\n           /write-plan\n               ↓\n         Review plan + tasklist\n               ↓\n        /implement-plan ←──────┐\n               ↓               │\n        Execute phase tasks    │ repeat\n               ↓               │ per\n        Run checkpoints        │ phase\n               ↓               │\n        Human review           │\n               ↓               │\n            /clear ────────────┘\n               ↓ (all phases done)\n         Feature complete\n\n    /amend-plan: update documents when requirements change\n```\n\n## Getting Started\n\nInstall as plugin in Claude Code:\n\n1. `/plugin marketplace add tordks/claude-workflow` - adds repository to your marketplace\n2. `/plugin install cwf@claude-workflow` - installs the plugin\n\nTo uninstall: `/plugin uninstall cwf@claude-workflow`\n\n### Example Use\n\n```text\n/brainstorm Build OAuth login with session management\n# → guided conversation exploring requirements and design decisions\n\n/write-plan user-auth\n# → creates plan + tasklist in .cwf/user-auth/\n# review the plan before implementing\n\n/implement-plan user-auth       # runs phase 1, checkpoints, stops for review\n\n/clear\n\n/implement-plan user-auth       # picks up at phase 2, checkpoints, stops for review\n\n/clear\n\n/amend-plan user-auth add refresh token rotation\n# → updates plan and tasklist to include refresh token rotation\n\n/clear\n\n/implement-plan user-auth       # picks up at phase 3\n```\n\n## Usage Guide\n\nCWF provides four slash commands that orchestrate the workflow. Commands automatically load the `claude-workflow` skill, which provides planning structure, task format, and amendment rules.\n\n### Command Reference\n\n| Command | When to Use | What It Does |\n|---------|-------------|--------------|\n| `/brainstorm [initial context]` | During planning | Guided conversation to explore requirements, alternatives, and design decisions |\n| `/write-plan <feature-name> [instructions]` | After planning | Writes planning documents |\n| `/implement-plan <feature-name> [instructions]` | Start/Resume implementation | Executes tasks phase-by-phase with quality checkpoints |\n| `/amend-plan <feature-name> [instructions]` | Requirements changed or gaps identified | Updates plan/tasklist safely |\n\nArguments: `<feature-name>` is required for all commands except `/brainstorm`. `[instructions]` are optional free-form text for additional context or constraints.\n\n### Planning\n\nThe planning phase is about solidifying requirements before implementation. You can have an informal discussion with the agent, use `/brainstorm` for structured exploration, or provide a written specification file.\n\nRun `/write-plan` to create the planning documents in `.cwf/{feature-name}/` at your project root:\n\n- **Plan** `.cwf/{feature-name}/{feature-name}-plan.md`: Captures WHY/WHAT—architectural decisions, design rationale, alternatives considered\n- **Tasklist** `.cwf/{feature-name}/{feature-name}-tasklist.md`: Defines WHEN/HOW—sequential phases with checkbox tracking `[x]`\n- **Mockup** `.cwf/{feature-name}/{feature-name}-mockup.html` (optional): Visual reference for UI/frontend features\n\n**Tips:**\n\n- Provide concrete context. Specify technologies, scope boundaries and constraints. Avoid vague goals, the more specific your input, the more useful the plan.\n- Before writing the plan, ask the agent to generate diagrams (SVG, HTML or Mermaid). Especially useful for database schemas, or system architecture diagrams.\n- For UI/frontend features, request an HTML mockup to verify layout understanding before implementation. The agent will create a single HTML file with inline CSS that you can open in a browser.\n- For multi-session planning, ask the agent to write a summary of the discussion to a file (e.g., `.cwf/feature/notes.md`), then reference that file when resuming in a new session.\n- You can focus on specific parts of a discussion/spec and provide file inputs: `/write-plan user-auth only make a plan for the authentication layer described in my-spec-file.md`\n\n### Implementation\n\nRun `/implement-plan` to start implementing the feature. The agent continues from the next incomplete task in the tasklist, allowing you to resume with clear context.\n\nAt the end of each phase, the agent runs **checkpoints**—validation operations that ensure code quality before proceeding:\n\n- **Self-review:** Agent reviews implementation against phase deliverable\n- **Code quality checks:** Linting, formatting, type checking—runs whatever tools the project already uses (e.g., eslint, prettier, mypy, ruff)\n- **Complexity checks:** Code complexity analysis—runs if project has complexity tools configured\n\nThese checkpoints catch issues early before they accumulate (ie. ever-increasing function- or file size). After checkpoints pass, implementation stops for human review before proceeding to the next phase.\n\n**Tips:**\n\n- At phase boundaries, verify deliverables match the tasklist, test the feature, and check edge cases before proceeding.\n- If context allows, write \"continue to next phase\" instead of clearing to reuse exploration.\n- You can add instructions to `/implement-plan`: `/implement-plan user-auth phase 1, 2 and 3, then stop`\n- Use `/amend-plan` when requirements change or you discover gaps in the plan during implementation.\n- Add CLAUDE.md files sub-directories to provide navigation guidance for the agent when exploring the codebase during implementation\n- You can use subagents to run independent phases or tasks in parallel, or to preserve main instance context. ie. `/implement-plan user-auth use subagents to implement phase 1 and 2 in parallel`.\n\n\n### Amending Plans\n\nIf requirements change during implementation or you discover a gap in the plan, use `/amend-plan` to update the plan and tasklist safely.\n\n**Tips:**\n\n- For complex amendments, `/clear` and discuss changes first, you might even want to use `/brainstorm <initial-description-of-change>`\n- Add change description for amendments that might not need discussion: `/amend-plan my-cli-tool the cli needs an --output option`\n- **Warning:** Changing implementation, or deviating from the plan, without amending the plan or adding a changelog causes confusion after `/clear`. The agent treats the plan as its source of truth and will likely undo or conflict with unamended changes.\n\n### Project Rules (Optional)\n\nFor coding principles and standards that apply across your repository, Claude Code supports modular rules in `.claude/rules/`. This pairs well with CWF — the agent uses your rules during implementation. See the [Claude Code docs](https://code.claude.com/docs/en/memory#modular-rules-with-claude/rules/) and `claude-rules-example/` in this repository for examples.\n\n## Alternatives & Resources\n\nCWF is one approach to agent development workflows. Other frameworks vary in rigor and documentation requirements, but most share the core concept of persisting specifications to maintain context between sessions. Below are some related projects and resources in the Claude Code ecosystem.\n\n### Plan-Driven Development\n\n- [superpowers](https://github.com/obra/superpowers) - Comprehensive skills library with techniques and patterns that auto-activate through Claude Code's plugin system\n- [spec-kit](https://github.com/github/spec-kit) - GitHub's Spec-Driven Development toolkit where specifications become executable artifacts that generate implementations\n- [GSD (Get Shit Done)](https://github.com/gsd-build/get-shit-done) - Spec-driven development system with specialized agents, programmatic tooling, and state management\n- [BMAD-method](https://github.com/bmad-code-org/BMAD-METHOD) - Human-AI collaboration framework with specialized agents for software development, creativity, and problem-solving\n- [SuperClaude](https://github.com/SuperClaude-Org/SuperClaude_Framework) - Configuration framework with specialized slash commands, cognitive personas, and behavioral modes\n- [spec-workflow-mcp](https://github.com/Pimzino/spec-workflow-mcp) - MCP server for structured spec-driven development with real-time dashboard, VSCode extension, and session caching\n- [Claude Pilot](https://github.com/maxritter/claude-pilot) - Development framework with spec-driven workflows, TDD enforcement, persistent memory, and continuous quality checks via hooks\n\n### Multi-Agent Orchestration\n\n- [Claude Code Agent Teams](https://code.claude.com/docs/en/agent-teams) - Official Anthropic feature: coordinated Claude Code instances with a team lead, shared task list, and dependency tracking\n- [Gas Town](https://github.com/steveyegge/gastown) - Workspace manager using git-backed \"beads\" for persistent state across a fleet of AI agents\n- [CLI Agent Orchestrator (AWS)](https://github.com/awslabs/cli-agent-orchestrator) - AWS-backed hierarchical orchestration with supervisor agent coordinating workers in isolated sessions\n- [babysitter](https://github.com/a5c-ai/babysitter) - Event-sourced orchestration with quality convergence, human-in-the-loop breakpoints, and pause/resume/recovery\n"
      },
      "plugins": [
        {
          "name": "cwf",
          "version": "0.2.2",
          "source": "./plugins/cwf",
          "description": "Plan-driven development workflow for Claude Code with phase-based implementation",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add tordks/claude-workflow",
            "/plugin install cwf@claude-workflow"
          ]
        }
      ]
    }
  ]
}