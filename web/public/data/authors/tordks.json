{
  "author": {
    "id": "tordks",
    "display_name": "tordks",
    "avatar_url": "https://avatars.githubusercontent.com/u/10962463?v=4"
  },
  "marketplaces": [
    {
      "name": "claude-workflow",
      "version": null,
      "description": "Plan-driven development workflow for Claude Code with phase-based implementation",
      "repo_full_name": "tordks/claude-workflow",
      "repo_url": "https://github.com/tordks/claude-workflow",
      "repo_description": "Exploration into plan-driven development for Claude Code",
      "signals": {
        "stars": 3,
        "forks": 0,
        "pushed_at": "2026-02-17T18:08:16Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-workflow\",\n  \"owner\": {\n    \"name\": \"tordks\",\n    \"email\": \"tordks@users.noreply.github.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"cwf\",\n      \"version\": \"0.2.2\",\n      \"source\": \"./plugins/cwf\",\n      \"description\": \"Plan-driven development workflow for Claude Code with phase-based implementation\"\n    }\n  ]\n}\n",
        "README.md": "# Claude Workflow\n\n[![Version](https://img.shields.io/badge/version-0.2.2-blue.svg)](https://github.com/tordks/claude-workflow/releases)\n[![Claude Code](https://img.shields.io/badge/Claude%20Code-Plugin-purple.svg)](https://claude.com/claude-code)\n\nClaude Workflow (CWF) defines a plan-driven development workflow for Claude Code with phase-based implementation.\n\n## What Problem Does CWF Solve?\n\nWhen work spans multiple sessions or outgrows a single context window, AI-assisted development breaks down in two ways:\n\n1. **The agent loses context.** Architectural decisions, refined requirements, and implementation progress disappear when context is compacted or a session ends. The next session starts from scratch, and the agent re-derives what was already decided, or worse, decides differently.\n\n2. **The developer loses ownership.** Without a plan to review upfront, the agent makes design decisions implicitly as it codes. Problems compound across files before anyone notices, and the codebase drifts from the developer's intent.\n\nBoth stem from the same gap: nothing captures what was decided, what was built, and what remains. CWF fills this gap with plan and tasklist documents, and structures implementation around them:\n\n- **Persistent plan documents** give every session the full picture of architectural decisions, design rationale, and progress so far.\n- **Phase-based implementation** breaks work into sequential phases with concrete deliverables, so scope and sequencing are decided before coding starts.\n- **Automated checkpoints** run code quality, complexity, and test checks at phase boundaries, catching issues before they accumulate.\n- **Scheduled human review** between phases keeps the developer in control, not just informed.\n\n## When to Use CWF\n\nThe workflow should match the complexity of the work. CWF is designed for features that involve architectural decisions, touch multiple components, or span multiple sessions. For quick fixes or single-session work, chat mode or plan mode is more efficient.\n\n**Chat mode** — no upfront planning:\n\n- Fix a null pointer exception\n- Add one or more logging statements\n- Explore or explain unfamiliar code\n\n**Plan mode** — plan first, then implement in one session:\n\n- Add form validation to the signup page\n- Refactor a module to use dependency injection\n\n**CWF** — persistent plan, multi-session with review checkpoints:\n\n- Build user authentication with OAuth, sessions, and role-based access\n- Add a payment integration that touches API, database, and frontend\n- Bootstrap and set up an initial version of a greenfield project\n- Implement a new feature that requires design decisions and will take multiple sessions to complete\n\n## The Workflow\n\nBased on an input context (specification, design discussion, or exploration), CWF produces a plan and tasklist that break down the work into phases with runnable deliverables. The agent implements phase-by-phase, running quality checkpoints and pausing for human review before proceeding to the next phase.\n\nEach phase is started manually with `/implement-plan`, which continues from the next incomplete task and accepts free-form instructions to control scope. This allows you to pause and resume implementation across sessions without losing context or progress.\n\n```text\n       input context (plan draft, design discussion, specification file)\n               │\n               ├── /explore (optional: iterative discovery\n               │             to converge on design before\n               │             planning)\n               ↓\n           /write-plan\n               ↓\n         Review plan + tasklist\n               ↓\n        /implement-plan ←──────┐\n               ↓               │\n        Execute phase tasks    │ repeat\n               ↓               │ per\n        Run checkpoints        │ phase\n               ↓               │\n        Human review           │\n               ↓               │\n            /clear ────────────┘\n               ↓ (all phases done)\n         Feature complete\n\n    /amend-plan: update documents when requirements change\n```\n\n## Getting Started\n\nInstall as plugin in Claude Code:\n\n1. `/plugin marketplace add tordks/claude-workflow` - adds repository to your marketplace\n2. `/plugin install cwf@claude-workflow` - installs the plugin\n\nTo uninstall: `/plugin uninstall cwf@claude-workflow`\n\n### Example usage\n\n```text\n# discuss the feature in chat, then create the plan from the conversation\n/write-plan redis-queue\n\n# or reference a spec or draft directly\n/write-plan redis-queue docs/redis-queue-draft.md\n\n# → creates plan + tasklist in .cwf/redis-queue/\n# review the plan before implementing\n\n/implement-plan redis-queue     # phase 1: Redis infra + config\n\n/clear\n\n/implement-plan redis-queue     # phase 2: poller + worker + API rewire\n\n/clear\n\n/amend-plan redis-queue add stale job detection for crashed workers\n# → updates plan and tasklist to include stale job recovery\n\n/clear\n\n/implement-plan redis-queue     # continues where we left off\n```\n\nSee [docs/examples/](docs/examples/) for example plan and tasklist made by `/write-plan`.\n\n## Usage Guide\n\nCWF provides four slash commands that orchestrate the workflow.\n\n### Command Reference\n\n| Command | When to Use | What It Does |\n|---------|-------------|--------------|\n| `/explore [initial context]` | During planning | Iterative discovery that converges on a design summary |\n| `/write-plan [feature-name] [planning context]` | After planning | Creates plan and tasklist from input context |\n| `/implement-plan [feature-name] [instructions]` | Start/Resume implementation | Executes tasks phase-by-phase with quality checkpoints |\n| `/amend-plan [feature-name] [amendment description]` | Requirements changed or gaps identified | Updates plan/tasklist safely |\n\n`[feature-name]` is optional for `/write-plan`, `/implement-plan`, and `/amend-plan`. `/implement-plan` and `/amend-plan` auto-detect when only one plan exists, otherwise prompt for selection. `/write-plan` suggests a name from conversation context. All additional arguments are optional free-form text.\n\n### Planning\n\n`/write-plan` creates the planning documents in `.cwf/{feature-name}/` at your project root:\n\n- **Plan** `.cwf/{feature-name}/{feature-name}-plan.md`: Captures WHY/WHAT—architectural decisions, design rationale, alternatives considered\n- **Tasklist** `.cwf/{feature-name}/{feature-name}-tasklist.md`: Defines WHEN/HOW—sequential phases with checkbox tracking `[x]`\n- **Mockup** `.cwf/{feature-name}/{feature-name}-mockup.html` (optional): Visual reference for UI/frontend features\n\nExample plan and tasklist can be found in [`docs/examples/`](docs/examples/).\n\n**Tips:**\n\n- `/write-plan` works from any input (conversation, spec file, or draft): `/write-plan user-auth auth-spec.md`.\n- Be specific. \"OAuth2 with Google, PostgreSQL sessions, admin/user roles\" beats \"build auth\".\n- You can scope to part of a written spec: `/write-plan user-auth only the auth layer from auth-spec.md`.\n- Discuss the feature or draft in chat first. Ask for diagrams (SVG, Mermaid) for schemas or architecture to ensure the agent understands before planning.\n- For UI features, request an HTML mockup to verify layout before implementation.\n- For multi-session planning, save a summary and reference it when resuming.\n\n### Implementation\n\nRun `/implement-plan` to start implementing the feature. The agent continues from the next incomplete task in the tasklist, allowing you to resume with clear context.\n\nAt the end of each phase, the agent runs **checkpoints** to validate quality before proceeding. `/write-plan` picks up on configured tooling and tailors checkpoints to the project. These can for example include:\n\n- **Self-review:** Agent reviews implementation against phase deliverable\n- **Code quality:** Linting, formatting, type checking\n- **Code complexity:** Function size, branching depth, and cyclomatic complexity\n- **Dead code:** Verify removed functionality don't leave orphans\n\nCheckpoints catch issues early before they accumulate (e.g., ever-increasing function size or deep nesting). After checkpoints pass, implementation stops for human review before proceeding to the next phase.\n\n**Tips:**\n\n- Pass instructions to scope a run. `/implement-plan user-auth phase 1, 2 and 3` will run phase 1-3 without stopping for review.\n- If the session has room, skip `/clear` and write \"continue to next phase\" to reuse context.\n- Run independent phases in parallel with subagents: `/implement-plan user-auth use subagents for phase 1 and 2 in parallel`.\n\n### Amending Plans\n\nIf requirements change during implementation or you discover a gap in the plan, use `/amend-plan` to update the plan and tasklist safely.\n\n> **Warning:** Changing implementation without amending the plan causes confusion after `/clear`. The agent treats the plan as its source of truth and will undo or conflict with unamended changes. Always `/amend-plan` before (or immediately after) deviating.\n\n**Tips:**\n\n- For simple changes: `/amend-plan my-cli-tool add --output option`.\n- For complex amendments, clear context and discuss amendments before amending.\n- If the change invalidates the overall approach, re-plan with `/write-plan` instead.\n\n## Alternatives & Resources\n\nCWF is one approach to agent development workflows. Other frameworks vary in rigor and documentation requirements, but most share the core concept of persisting specifications to maintain context between sessions. Below are some related projects and resources in the Claude Code ecosystem.\n\n### Plan-Driven Development\n\n- [superpowers](https://github.com/obra/superpowers) - Comprehensive skills library with techniques and patterns that auto-activate through Claude Code's plugin system\n- [spec-kit](https://github.com/github/spec-kit) - GitHub's Spec-Driven Development toolkit where specifications become executable artifacts that generate implementations\n- [GSD (Get Shit Done)](https://github.com/gsd-build/get-shit-done) - Spec-driven development system with specialized agents, programmatic tooling, and state management\n- [BMAD-method](https://github.com/bmad-code-org/BMAD-METHOD) - Human-AI collaboration framework with specialized agents for software development, creativity, and problem-solving\n- [SuperClaude](https://github.com/SuperClaude-Org/SuperClaude_Framework) - Configuration framework with specialized slash commands, cognitive personas, and behavioral modes\n- [spec-workflow-mcp](https://github.com/Pimzino/spec-workflow-mcp) - MCP server for structured spec-driven development with real-time dashboard, VSCode extension, and session caching\n- [Claude Pilot](https://github.com/maxritter/claude-pilot) - Development framework with spec-driven workflows, TDD enforcement, persistent memory, and continuous quality checks via hooks\n\n### Multi-Agent Orchestration\n\n- [Claude Code Agent Teams](https://code.claude.com/docs/en/agent-teams) - Official Anthropic feature: coordinated Claude Code instances with a team lead, shared task list, and dependency tracking\n- [Gas Town](https://github.com/steveyegge/gastown) - Workspace manager using git-backed \"beads\" for persistent state across a fleet of AI agents\n- [CLI Agent Orchestrator (AWS)](https://github.com/awslabs/cli-agent-orchestrator) - AWS-backed hierarchical orchestration with supervisor agent coordinating workers in isolated sessions\n- [babysitter](https://github.com/a5c-ai/babysitter) - Event-sourced orchestration with quality convergence, human-in-the-loop breakpoints, and pause/resume/recovery\n"
      },
      "plugins": [
        {
          "name": "cwf",
          "version": "0.2.2",
          "source": "./plugins/cwf",
          "description": "Plan-driven development workflow for Claude Code with phase-based implementation",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add tordks/claude-workflow",
            "/plugin install cwf@claude-workflow"
          ]
        }
      ]
    }
  ]
}