{
  "author": {
    "id": "gigs-slc",
    "display_name": "Premier 99 Software LLC",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/62651348?v=4",
    "url": "https://github.com/gigs-slc",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 10,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "react-native-expo-skills",
      "version": null,
      "description": "Complete React Native, Expo, and React skills for AI coding assistants. Combines Callstack, Expo, and Vercel best practices.",
      "owner_info": {
        "name": "Premier 99 Software",
        "email": "griffin@premier99software.com",
        "url": "https://github.com/gigs-slc"
      },
      "keywords": [],
      "repo_full_name": "gigs-slc/react-native-skills",
      "repo_url": "https://github.com/gigs-slc/react-native-skills",
      "repo_description": "Complete React Native, Expo & React skills for Claude Code - 130+ rules from Callstack, Vercel & Expo",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-28T17:47:22Z",
        "created_at": "2026-01-28T16:21:11Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1263
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6922
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/architect",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/architect/AGENT.md",
          "type": "blob",
          "size": 5509
        },
        {
          "path": "agents/bugfix",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/bugfix/AGENT.md",
          "type": "blob",
          "size": 6217
        },
        {
          "path": "agents/code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/code-review/AGENT.md",
          "type": "blob",
          "size": 5356
        },
        {
          "path": "agents/implementation",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/implementation/AGENT.md",
          "type": "blob",
          "size": 6192
        },
        {
          "path": "agents/navigation",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/navigation/AGENT.md",
          "type": "blob",
          "size": 6266
        },
        {
          "path": "agents/orchestrator",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/orchestrator/AGENT.md",
          "type": "blob",
          "size": 7886
        },
        {
          "path": "agents/performance",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/performance/AGENT.md",
          "type": "blob",
          "size": 6774
        },
        {
          "path": "agents/release-gate",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/release-gate/AGENT.md",
          "type": "blob",
          "size": 6512
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/api-routes",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/api-routes/SKILL.md",
          "type": "blob",
          "size": 8699
        },
        {
          "path": "skills/building-ui",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/building-ui/SKILL.md",
          "type": "blob",
          "size": 10232
        },
        {
          "path": "skills/building-ui/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/building-ui/references/animations.md",
          "type": "blob",
          "size": 4747
        },
        {
          "path": "skills/building-ui/references/controls.md",
          "type": "blob",
          "size": 5055
        },
        {
          "path": "skills/building-ui/references/form-sheet.md",
          "type": "blob",
          "size": 5573
        },
        {
          "path": "skills/building-ui/references/gradients.md",
          "type": "blob",
          "size": 2717
        },
        {
          "path": "skills/building-ui/references/icons.md",
          "type": "blob",
          "size": 4771
        },
        {
          "path": "skills/building-ui/references/media.md",
          "type": "blob",
          "size": 6196
        },
        {
          "path": "skills/building-ui/references/route-structure.md",
          "type": "blob",
          "size": 5106
        },
        {
          "path": "skills/building-ui/references/search.md",
          "type": "blob",
          "size": 5193
        },
        {
          "path": "skills/building-ui/references/storage.md",
          "type": "blob",
          "size": 2935
        },
        {
          "path": "skills/building-ui/references/tabs.md",
          "type": "blob",
          "size": 7981
        },
        {
          "path": "skills/building-ui/references/visual-effects.md",
          "type": "blob",
          "size": 4335
        },
        {
          "path": "skills/building-ui/references/webgpu-three.md",
          "type": "blob",
          "size": 14466
        },
        {
          "path": "skills/composition-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/composition-patterns/AGENTS.md",
          "type": "blob",
          "size": 21327
        },
        {
          "path": "skills/composition-patterns/README.md",
          "type": "blob",
          "size": 2140
        },
        {
          "path": "skills/composition-patterns/SKILL.md",
          "type": "blob",
          "size": 2587
        },
        {
          "path": "skills/composition-patterns/rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/composition-patterns/rules/_sections.md",
          "type": "blob",
          "size": 680
        },
        {
          "path": "skills/composition-patterns/rules/_template.md",
          "type": "blob",
          "size": 329
        },
        {
          "path": "skills/composition-patterns/rules/architecture-avoid-boolean-props.md",
          "type": "blob",
          "size": 2267
        },
        {
          "path": "skills/composition-patterns/rules/architecture-compound-components.md",
          "type": "blob",
          "size": 2600
        },
        {
          "path": "skills/composition-patterns/rules/patterns-children-over-render-props.md",
          "type": "blob",
          "size": 1886
        },
        {
          "path": "skills/composition-patterns/rules/patterns-explicit-variants.md",
          "type": "blob",
          "size": 2395
        },
        {
          "path": "skills/composition-patterns/rules/state-context-interface.md",
          "type": "blob",
          "size": 4974
        },
        {
          "path": "skills/composition-patterns/rules/state-decouple-implementation.md",
          "type": "blob",
          "size": 2699
        },
        {
          "path": "skills/composition-patterns/rules/state-lift-state.md",
          "type": "blob",
          "size": 3224
        },
        {
          "path": "skills/data-fetching",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/data-fetching/SKILL.md",
          "type": "blob",
          "size": 11084
        },
        {
          "path": "skills/dev-client",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dev-client/SKILL.md",
          "type": "blob",
          "size": 3510
        },
        {
          "path": "skills/react-best-practices",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/react-best-practices/AGENTS.md",
          "type": "blob",
          "size": 81716
        },
        {
          "path": "skills/react-best-practices/README.md",
          "type": "blob",
          "size": 3360
        },
        {
          "path": "skills/react-best-practices/SKILL.md",
          "type": "blob",
          "size": 6165
        },
        {
          "path": "skills/react-best-practices/rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/react-best-practices/rules/_sections.md",
          "type": "blob",
          "size": 1554
        },
        {
          "path": "skills/react-best-practices/rules/_template.md",
          "type": "blob",
          "size": 631
        },
        {
          "path": "skills/react-best-practices/rules/advanced-event-handler-refs.md",
          "type": "blob",
          "size": 1483
        },
        {
          "path": "skills/react-best-practices/rules/advanced-init-once.md",
          "type": "blob",
          "size": 958
        },
        {
          "path": "skills/react-best-practices/rules/advanced-use-latest.md",
          "type": "blob",
          "size": 1072
        },
        {
          "path": "skills/react-best-practices/rules/async-api-routes.md",
          "type": "blob",
          "size": 1125
        },
        {
          "path": "skills/react-best-practices/rules/async-defer-await.md",
          "type": "blob",
          "size": 2028
        },
        {
          "path": "skills/react-best-practices/rules/async-dependencies.md",
          "type": "blob",
          "size": 1293
        },
        {
          "path": "skills/react-best-practices/rules/async-parallel.md",
          "type": "blob",
          "size": 654
        },
        {
          "path": "skills/react-best-practices/rules/async-suspense-boundaries.md",
          "type": "blob",
          "size": 2510
        },
        {
          "path": "skills/react-best-practices/rules/bundle-barrel-imports.md",
          "type": "blob",
          "size": 2370
        },
        {
          "path": "skills/react-best-practices/rules/bundle-conditional.md",
          "type": "blob",
          "size": 949
        },
        {
          "path": "skills/react-best-practices/rules/bundle-defer-third-party.md",
          "type": "blob",
          "size": 920
        },
        {
          "path": "skills/react-best-practices/rules/bundle-dynamic-imports.md",
          "type": "blob",
          "size": 791
        },
        {
          "path": "skills/react-best-practices/rules/bundle-preload.md",
          "type": "blob",
          "size": 1149
        },
        {
          "path": "skills/react-best-practices/rules/client-event-listeners.md",
          "type": "blob",
          "size": 1969
        },
        {
          "path": "skills/react-best-practices/rules/client-localstorage-schema.md",
          "type": "blob",
          "size": 1950
        },
        {
          "path": "skills/react-best-practices/rules/client-passive-event-listeners.md",
          "type": "blob",
          "size": 1644
        },
        {
          "path": "skills/react-best-practices/rules/client-swr-dedup.md",
          "type": "blob",
          "size": 1159
        },
        {
          "path": "skills/react-best-practices/rules/js-batch-dom-css.md",
          "type": "blob",
          "size": 3266
        },
        {
          "path": "skills/react-best-practices/rules/js-cache-function-results.md",
          "type": "blob",
          "size": 1949
        },
        {
          "path": "skills/react-best-practices/rules/js-cache-property-access.md",
          "type": "blob",
          "size": 532
        },
        {
          "path": "skills/react-best-practices/rules/js-cache-storage.md",
          "type": "blob",
          "size": 1651
        },
        {
          "path": "skills/react-best-practices/rules/js-combine-iterations.md",
          "type": "blob",
          "size": 753
        },
        {
          "path": "skills/react-best-practices/rules/js-early-exit.md",
          "type": "blob",
          "size": 1133
        },
        {
          "path": "skills/react-best-practices/rules/js-hoist-regexp.md",
          "type": "blob",
          "size": 1028
        },
        {
          "path": "skills/react-best-practices/rules/js-index-maps.md",
          "type": "blob",
          "size": 837
        },
        {
          "path": "skills/react-best-practices/rules/js-length-check-first.md",
          "type": "blob",
          "size": 1747
        },
        {
          "path": "skills/react-best-practices/rules/js-min-max-loop.md",
          "type": "blob",
          "size": 2290
        },
        {
          "path": "skills/react-best-practices/rules/js-set-map-lookups.md",
          "type": "blob",
          "size": 532
        },
        {
          "path": "skills/react-best-practices/rules/js-tosorted-immutable.md",
          "type": "blob",
          "size": 1782
        },
        {
          "path": "skills/react-best-practices/rules/rendering-activity.md",
          "type": "blob",
          "size": 564
        },
        {
          "path": "skills/react-best-practices/rules/rendering-animate-svg-wrapper.md",
          "type": "blob",
          "size": 1185
        },
        {
          "path": "skills/react-best-practices/rules/rendering-conditional-render.md",
          "type": "blob",
          "size": 980
        },
        {
          "path": "skills/react-best-practices/rules/rendering-content-visibility.md",
          "type": "blob",
          "size": 815
        },
        {
          "path": "skills/react-best-practices/rules/rendering-hoist-jsx.md",
          "type": "blob",
          "size": 1039
        },
        {
          "path": "skills/react-best-practices/rules/rendering-hydration-no-flicker.md",
          "type": "blob",
          "size": 2308
        },
        {
          "path": "skills/react-best-practices/rules/rendering-hydration-suppress-warning.md",
          "type": "blob",
          "size": 872
        },
        {
          "path": "skills/react-best-practices/rules/rendering-svg-precision.md",
          "type": "blob",
          "size": 588
        },
        {
          "path": "skills/react-best-practices/rules/rendering-usetransition-loading.md",
          "type": "blob",
          "size": 2074
        },
        {
          "path": "skills/react-best-practices/rules/rerender-defer-reads.md",
          "type": "blob",
          "size": 973
        },
        {
          "path": "skills/react-best-practices/rules/rerender-dependencies.md",
          "type": "blob",
          "size": 824
        },
        {
          "path": "skills/react-best-practices/rules/rerender-derived-state-no-effect.md",
          "type": "blob",
          "size": 1201
        },
        {
          "path": "skills/react-best-practices/rules/rerender-derived-state.md",
          "type": "blob",
          "size": 728
        },
        {
          "path": "skills/react-best-practices/rules/rerender-functional-setstate.md",
          "type": "blob",
          "size": 2968
        },
        {
          "path": "skills/react-best-practices/rules/rerender-lazy-state-init.md",
          "type": "blob",
          "size": 2016
        },
        {
          "path": "skills/react-best-practices/rules/rerender-memo-with-default-value.md",
          "type": "blob",
          "size": 1173
        },
        {
          "path": "skills/react-best-practices/rules/rerender-memo.md",
          "type": "blob",
          "size": 1148
        },
        {
          "path": "skills/react-best-practices/rules/rerender-move-effect-to-event.md",
          "type": "blob",
          "size": 1268
        },
        {
          "path": "skills/react-best-practices/rules/rerender-simple-expression-in-memo.md",
          "type": "blob",
          "size": 1018
        },
        {
          "path": "skills/react-best-practices/rules/rerender-transitions.md",
          "type": "blob",
          "size": 1055
        },
        {
          "path": "skills/react-best-practices/rules/rerender-use-ref-transient-values.md",
          "type": "blob",
          "size": 1742
        },
        {
          "path": "skills/react-best-practices/rules/server-after-nonblocking.md",
          "type": "blob",
          "size": 2012
        },
        {
          "path": "skills/react-best-practices/rules/server-auth-actions.md",
          "type": "blob",
          "size": 2649
        },
        {
          "path": "skills/react-best-practices/rules/server-cache-lru.md",
          "type": "blob",
          "size": 1353
        },
        {
          "path": "skills/react-best-practices/rules/server-cache-react.md",
          "type": "blob",
          "size": 2228
        },
        {
          "path": "skills/react-best-practices/rules/server-dedup-props.md",
          "type": "blob",
          "size": 2060
        },
        {
          "path": "skills/react-best-practices/rules/server-parallel-fetching.md",
          "type": "blob",
          "size": 1554
        },
        {
          "path": "skills/react-best-practices/rules/server-serialization.md",
          "type": "blob",
          "size": 996
        },
        {
          "path": "skills/react-native",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/react-native/AGENTS.md",
          "type": "blob",
          "size": 73771
        },
        {
          "path": "skills/react-native/SKILL.md",
          "type": "blob",
          "size": 7312
        },
        {
          "path": "skills/react-native/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/react-native/references/bundle-analyze-app.md",
          "type": "blob",
          "size": 5311
        },
        {
          "path": "skills/react-native/references/bundle-analyze-js.md",
          "type": "blob",
          "size": 6412
        },
        {
          "path": "skills/react-native/references/bundle-barrel-exports.md",
          "type": "blob",
          "size": 5033
        },
        {
          "path": "skills/react-native/references/bundle-code-splitting.md",
          "type": "blob",
          "size": 4982
        },
        {
          "path": "skills/react-native/references/bundle-hermes-mmap.md",
          "type": "blob",
          "size": 3865
        },
        {
          "path": "skills/react-native/references/bundle-library-size.md",
          "type": "blob",
          "size": 4303
        },
        {
          "path": "skills/react-native/references/bundle-native-assets.md",
          "type": "blob",
          "size": 4399
        },
        {
          "path": "skills/react-native/references/bundle-r8-android.md",
          "type": "blob",
          "size": 4627
        },
        {
          "path": "skills/react-native/references/bundle-tree-shaking.md",
          "type": "blob",
          "size": 5522
        },
        {
          "path": "skills/react-native/references/js-animations-reanimated.md",
          "type": "blob",
          "size": 8635
        },
        {
          "path": "skills/react-native/references/js-atomic-state.md",
          "type": "blob",
          "size": 6040
        },
        {
          "path": "skills/react-native/references/js-concurrent-react.md",
          "type": "blob",
          "size": 6340
        },
        {
          "path": "skills/react-native/references/js-lists-flatlist-flashlist.md",
          "type": "blob",
          "size": 5153
        },
        {
          "path": "skills/react-native/references/js-measure-fps.md",
          "type": "blob",
          "size": 4768
        },
        {
          "path": "skills/react-native/references/js-memory-leaks.md",
          "type": "blob",
          "size": 5177
        },
        {
          "path": "skills/react-native/references/js-profile-react.md",
          "type": "blob",
          "size": 4793
        },
        {
          "path": "skills/react-native/references/js-react-compiler.md",
          "type": "blob",
          "size": 8990
        },
        {
          "path": "skills/react-native/references/js-uncontrolled-components.md",
          "type": "blob",
          "size": 5153
        },
        {
          "path": "skills/react-native/references/native-measure-tti.md",
          "type": "blob",
          "size": 6850
        },
        {
          "path": "skills/react-native/references/native-memory-leaks.md",
          "type": "blob",
          "size": 5608
        },
        {
          "path": "skills/react-native/references/native-memory-patterns.md",
          "type": "blob",
          "size": 6301
        },
        {
          "path": "skills/react-native/references/native-platform-setup.md",
          "type": "blob",
          "size": 5212
        },
        {
          "path": "skills/react-native/references/native-profiling.md",
          "type": "blob",
          "size": 4843
        },
        {
          "path": "skills/react-native/references/native-sdks-over-polyfills.md",
          "type": "blob",
          "size": 5489
        },
        {
          "path": "skills/react-native/references/native-threading-model.md",
          "type": "blob",
          "size": 5691
        },
        {
          "path": "skills/react-native/references/native-turbo-modules.md",
          "type": "blob",
          "size": 6593
        },
        {
          "path": "skills/react-native/references/native-view-flattening.md",
          "type": "blob",
          "size": 5154
        },
        {
          "path": "skills/react-native/rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/react-native/rules/_sections.md",
          "type": "blob",
          "size": 2228
        },
        {
          "path": "skills/react-native/rules/_template.md",
          "type": "blob",
          "size": 631
        },
        {
          "path": "skills/react-native/rules/animation-derived-value.md",
          "type": "blob",
          "size": 1373
        },
        {
          "path": "skills/react-native/rules/animation-gesture-detector-press.md",
          "type": "blob",
          "size": 2559
        },
        {
          "path": "skills/react-native/rules/animation-gpu-properties.md",
          "type": "blob",
          "size": 2059
        },
        {
          "path": "skills/react-native/rules/design-system-compound-components.md",
          "type": "blob",
          "size": 1625
        },
        {
          "path": "skills/react-native/rules/fonts-config-plugin.md",
          "type": "blob",
          "size": 1393
        },
        {
          "path": "skills/react-native/rules/imports-design-system-folder.md",
          "type": "blob",
          "size": 1418
        },
        {
          "path": "skills/react-native/rules/js-hoist-intl.md",
          "type": "blob",
          "size": 1645
        },
        {
          "path": "skills/react-native/rules/list-performance-callbacks.md",
          "type": "blob",
          "size": 1059
        },
        {
          "path": "skills/react-native/rules/list-performance-function-references.md",
          "type": "blob",
          "size": 4133
        },
        {
          "path": "skills/react-native/rules/list-performance-images.md",
          "type": "blob",
          "size": 1417
        },
        {
          "path": "skills/react-native/rules/list-performance-inline-objects.md",
          "type": "blob",
          "size": 2308
        },
        {
          "path": "skills/react-native/rules/list-performance-item-expensive.md",
          "type": "blob",
          "size": 2466
        },
        {
          "path": "skills/react-native/rules/list-performance-item-memo.md",
          "type": "blob",
          "size": 2250
        },
        {
          "path": "skills/react-native/rules/list-performance-item-types.md",
          "type": "blob",
          "size": 2749
        },
        {
          "path": "skills/react-native/rules/list-performance-virtualize.md",
          "type": "blob",
          "size": 1742
        },
        {
          "path": "skills/react-native/rules/monorepo-native-deps-in-app.md",
          "type": "blob",
          "size": 1091
        },
        {
          "path": "skills/react-native/rules/monorepo-single-dependency-versions.md",
          "type": "blob",
          "size": 1351
        },
        {
          "path": "skills/react-native/rules/navigation-native-navigators.md",
          "type": "blob",
          "size": 4941
        },
        {
          "path": "skills/react-native/rules/react-compiler-destructure-functions.md",
          "type": "blob",
          "size": 1274
        },
        {
          "path": "skills/react-native/rules/react-compiler-reanimated-shared-values.md",
          "type": "blob",
          "size": 1268
        },
        {
          "path": "skills/react-native/rules/react-state-dispatcher.md",
          "type": "blob",
          "size": 2255
        },
        {
          "path": "skills/react-native/rules/react-state-fallback.md",
          "type": "blob",
          "size": 1735
        },
        {
          "path": "skills/react-native/rules/react-state-minimize.md",
          "type": "blob",
          "size": 1740
        },
        {
          "path": "skills/react-native/rules/rendering-no-falsy-and.md",
          "type": "blob",
          "size": 1812
        },
        {
          "path": "skills/react-native/rules/rendering-text-in-text-component.md",
          "type": "blob",
          "size": 697
        },
        {
          "path": "skills/react-native/rules/scroll-position-no-state.md",
          "type": "blob",
          "size": 1936
        },
        {
          "path": "skills/react-native/rules/state-ground-truth.md",
          "type": "blob",
          "size": 2172
        },
        {
          "path": "skills/react-native/rules/ui-expo-image.md",
          "type": "blob",
          "size": 1648
        },
        {
          "path": "skills/react-native/rules/ui-image-gallery.md",
          "type": "blob",
          "size": 2546
        },
        {
          "path": "skills/react-native/rules/ui-measure-views.md",
          "type": "blob",
          "size": 2232
        },
        {
          "path": "skills/react-native/rules/ui-menus.md",
          "type": "blob",
          "size": 4598
        },
        {
          "path": "skills/react-native/rules/ui-native-modals.md",
          "type": "blob",
          "size": 1859
        },
        {
          "path": "skills/react-native/rules/ui-pressable.md",
          "type": "blob",
          "size": 1534
        },
        {
          "path": "skills/react-native/rules/ui-safe-area-scroll.md",
          "type": "blob",
          "size": 1579
        },
        {
          "path": "skills/react-native/rules/ui-scrollview-content-inset.md",
          "type": "blob",
          "size": 1317
        },
        {
          "path": "skills/react-native/rules/ui-styling.md",
          "type": "blob",
          "size": 2212
        },
        {
          "path": "skills/tailwind-setup",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/tailwind-setup/SKILL.md",
          "type": "blob",
          "size": 11909
        },
        {
          "path": "skills/upgrading-expo",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/upgrading-expo/SKILL.md",
          "type": "blob",
          "size": 3701
        },
        {
          "path": "skills/upgrading-expo/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/upgrading-expo/references/new-architecture.md",
          "type": "blob",
          "size": 2177
        },
        {
          "path": "skills/upgrading-expo/references/react-19.md",
          "type": "blob",
          "size": 1875
        },
        {
          "path": "skills/upgrading-expo/references/react-compiler.md",
          "type": "blob",
          "size": 1645
        },
        {
          "path": "skills/use-dom",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/use-dom/SKILL.md",
          "type": "blob",
          "size": 9707
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"react-native-expo-skills\",\n  \"owner\": {\n    \"name\": \"Premier 99 Software\",\n    \"email\": \"griffin@premier99software.com\",\n    \"url\": \"https://github.com/gigs-slc\"\n  },\n  \"metadata\": {\n    \"description\": \"Complete React Native, Expo, and React skills for AI coding assistants. Combines Callstack, Expo, and Vercel best practices.\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"react-native-expo-complete\",\n      \"description\": \"Complete React Native, Expo, and React optimization guide with 130+ rules covering performance, patterns, UI, animations, state management, and more.\",\n      \"source\": \"./\",\n      \"skills\": [\n        \"./skills/react-native\",\n        \"./skills/react-best-practices\",\n        \"./skills/composition-patterns\",\n        \"./skills/building-ui\",\n        \"./skills/data-fetching\",\n        \"./skills/api-routes\",\n        \"./skills/dev-client\",\n        \"./skills/tailwind-setup\",\n        \"./skills/upgrading-expo\",\n        \"./skills/use-dom\",\n        \"./agents/orchestrator\",\n        \"./agents/architect\",\n        \"./agents/implementation\",\n        \"./agents/code-review\",\n        \"./agents/bugfix\",\n        \"./agents/performance\",\n        \"./agents/navigation\",\n        \"./agents/release-gate\"\n      ]\n    }\n  ]\n}\n",
        "README.md": "# React Native & Expo Complete Skills\n\nThe most comprehensive React Native, Expo, and React optimization skills for Claude Code. Combines **130+ rules** from Callstack, Expo, and Vercel best practices.\n\n## Installation\n\nIn Claude Code, run:\n\n```\n/plugin marketplace add gigs-slc/react-native-skills\n/plugin install react-native-expo-complete@react-native-expo-skills\n```\n\nThen restart Claude Code to load the skills.\n\n## What's Included\n\n### 10 Skills + 8 Agents + Templates\n\n#### Skills\n\n| Skill | Source | Content | Description |\n|-------|--------|---------|-------------|\n| `react-native` | **Callstack + Vercel** | 65 files | **THE ULTIMATE RN SKILL** - Combined profiling + patterns |\n| `react-best-practices` | Vercel | 62 files | React patterns, hooks, performance, architecture |\n| `composition-patterns` | Vercel | 12 files | Component composition, compound components |\n| `building-ui` | Expo | 14 files | UI components, styling, animations, navigation |\n| `data-fetching` | Expo | 1 file | fetch, axios, React Query, SWR, caching |\n| `api-routes` | Expo | 1 file | API routes with Expo Router + EAS Hosting |\n| `dev-client` | Expo | 1 file | Development client builds, TestFlight |\n| `tailwind-setup` | Expo | 1 file | Tailwind CSS v4 + NativeWind v5 setup |\n| `upgrading-expo` | Expo | 4 files | SDK upgrades, React 19, New Architecture |\n| `use-dom` | Expo | 1 file | DOM components, web-to-native migration |\n\n#### Agents\n\n| Agent | Use When | Description |\n|-------|----------|-------------|\n| `orchestrator` | Coordinating multi-agent workflows | Master coordinator that enforces constraints and delegates to sub-agents |\n| `react-native-expo-architect` | BEFORE implementation | Designs features, makes architectural decisions, creates implementation plans |\n| `react-native-expo-implementation` | AFTER architecture plan exists | Writes production code following the approved plan |\n| `react-native-expo-code-review` | AFTER code is written | Reviews diffs, validates scope, checks for bugs and constraint violations |\n| `react-native-expo-bugfix` | Investigating runtime errors | Diagnoses crashes, bugs, and errors without implementing fixes |\n| `performance-re-render` | Performance matters | Identifies re-renders, memory leaks, JS thread issues |\n| `navigation-expo-router` | Navigation behavior involved | Validates routes, params, deep links, platform parity |\n| `mobile-release-gate` | Before merging/shipping | Final production-readiness check - SHIP or NO SHIP decision |\n\n### Agent Workflow\n\nThe Orchestrator is the **central hub** - every sub-agent reports back before the next step:\n\n```\nUser Request\n    ↓\n[Orchestrator] ─── Reads constraints, analyzes task\n    ↓\n    ├──→ [Architect] ─── Designs the solution\n    ↓\n[Orchestrator] ─── Reviews & approves plan\n    ↓\n    ├──→ [Implementation] ─── Writes the code\n    ↓\n[Orchestrator] ─── Verifies implementation matches plan\n    ↓\n    ├──→ [Code Review] ─── Validates the changes\n    ↓\n[Orchestrator] ─── Confirms review passed\n    ↓\n    ├──→ [Performance] ─── Checks performance (if needed)\n    ↓\n[Orchestrator] ─── Confirms no performance issues\n    ↓\n    ├──→ [Release Gate] ─── Final ship/no-ship decision\n    ↓\n[Orchestrator] ─── Updates AI_PROGRESS.md, reports to user\n```\n\n**Key principle**: No sub-agent hands off directly to another. The Orchestrator approves every transition.\n\n### Orchestrator Agent\n\nThe **Orchestrator Agent** is the master coordinator. It:\n- Reads `AI_CONSTRAINTS.md` before any work begins\n- Tracks progress in `AI_PROGRESS.md`\n- Delegates to specialized agents based on task type\n- Ensures proper agent sequencing\n- Never violates constraints\n\n### Project Governance Templates\n\nThe Orchestrator and sub-agents require these governance files. Download and customize for your project:\n\n| Template | Purpose | Download |\n|----------|---------|----------|\n| `AI_CONSTRAINTS.md` | Define non-negotiable rules for all AI agents | [Download](https://raw.githubusercontent.com/gigs-slc/react-native-skills/main/templates/AI_CONSTRAINTS.md) |\n| `AI_PROGRESS.md` | Track work status, decisions, and blockers | [Download](https://raw.githubusercontent.com/gigs-slc/react-native-skills/main/templates/AI_PROGRESS.md) |\n\n**Setup:**\n```bash\n# Download templates to your project\nmkdir -p docs\ncurl -o docs/AI_CONSTRAINTS.md https://raw.githubusercontent.com/gigs-slc/react-native-skills/main/templates/AI_CONSTRAINTS.md\ncurl -o docs/AI_PROGRESS.md https://raw.githubusercontent.com/gigs-slc/react-native-skills/main/templates/AI_PROGRESS.md\n```\n\nThen:\n1. Customize `AI_CONSTRAINTS.md` for your codebase rules\n2. Update `AI_PROGRESS.md` as work progresses\n3. Reference both in your `CLAUDE.md` or project instructions\n\n### The Unified `react-native` Skill\n\nThe crown jewel - combines **Callstack profiling** with **Vercel code patterns**:\n\n```\nskills/react-native/\n├── SKILL.md              # Combined quick reference\n├── AGENTS.md             # Full 74KB Vercel compiled guide\n├── rules/                # 36 Vercel rule files\n│   ├── list-performance-*.md\n│   ├── animation-*.md\n│   ├── ui-*.md\n│   ├── react-state-*.md\n│   └── ...\n└── references/           # 27 Callstack reference files\n    ├── js-*.md           # FPS, re-renders, memory, animations\n    ├── native-*.md       # TTI, profiling, Turbo Modules\n    ├── bundle-*.md       # Size analysis, tree shaking, R8\n    └── images/\n```\n\n### Coverage Areas\n\n**Performance (Callstack)**\n- FPS measurement & re-render profiling\n- Bundle size analysis & tree shaking\n- TTI optimization & native profiling\n- Memory leak detection (JS & native)\n- Hermes optimization, R8, compression\n\n**Code Patterns (Vercel)**\n- List virtualization (FlashList, LegendList)\n- Animation best practices (Reanimated)\n- React state patterns & architecture\n- React Compiler compatibility\n- UI components (native menus, modals, images)\n\n**Expo & React (Expo + Vercel)**\n- Expo Router navigation\n- Data fetching strategies\n- Tailwind/NativeWind styling\n- SDK upgrades & migrations\n- React hooks & composition patterns\n\n## Usage\n\nAfter installation, invoke skills in Claude Code:\n\n```\n/react-native              # THE BIG ONE - Callstack + Vercel combined\n/react-best-practices      # General React patterns\n/composition-patterns      # Component architecture\n/building-ui               # Expo UI patterns\n/data-fetching             # API & caching\n```\n\n## Attribution\n\nThis collection combines skills from:\n- **Callstack** - \"The Ultimate Guide to React Native Optimization\"\n- **Vercel** - React Native Skills, React Best Practices, Composition Patterns\n- **Expo** - Official Expo skills for app development\n\n## License\n\nMIT - See individual skill directories for original licenses.\n",
        "agents/architect/AGENT.md": "---\nname: react-native-expo-architect\ndescription: Software architect agent for designing React Native/Expo implementation plans. Use BEFORE any implementation begins for features, architectural decisions, and planning.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: architecture, planning, react-native, expo, design\n---\n\n# React Native Expo Architect Agent\n\nYou are the **ARCHITECT AGENT** - responsible for designing implementation plans BEFORE any code is written.\n\n## Your Role\n\nYou design, you don't implement. You:\n- Analyze requirements and constraints\n- Design component architecture\n- Plan state management approach\n- Evaluate navigation structure\n- Assess tradeoffs (performance, OTA safety, DX)\n- Create step-by-step implementation plans\n\n## When to Use This Agent\n\nInvoke this agent when:\n- Designing a new feature or screen\n- Making architectural or state-management decisions\n- Evaluating navigation structure or data flow\n- Assessing tradeoffs (performance, OTA safety, DX)\n- Planning refactors or non-trivial changes\n- Clarifying scope, constraints, and risks\n\n## Mandatory First Steps\n\nBefore ANY design work:\n\n1. **Read AI_CONSTRAINTS.md** - Understand what patterns are required/forbidden\n2. **Read AI_PROGRESS.md** - Check for related work or decisions\n3. **Load the skills** - Reference ALL best practices for your designs:\n   - `/react-native` - Callstack + Vercel optimization (65 files) - **THE BIG ONE**\n   - `/react-best-practices` - React patterns and architecture (62 files)\n   - `/composition-patterns` - Component composition patterns (12 files)\n   - `/building-ui` - Expo UI, styling, animations (14 files)\n   - `/data-fetching` - Data fetching strategies\n   - `/api-routes` - API route architecture\n   - `/tailwind-setup` - Styling with Tailwind/NativeWind\n   - `/use-dom` - DOM component patterns\n   - `/upgrading-expo` - Migration considerations\n4. **Explore the codebase** - Understand existing patterns before proposing new ones\n\n## Required Skills Knowledge\n\nYour architectural decisions MUST align with these skill guidelines:\n\n### From `/react-native` Skill\nReference `skills/react-native/SKILL.md` and `skills/react-native/rules/` for:\n- **List architecture**: FlashList over FlatList, item types for heterogeneous lists\n- **State patterns**: Atomic state (Jotai/Zustand), minimize re-renders\n- **Animation approach**: Reanimated worklets, GPU-only properties (transform, opacity)\n- **Navigation structure**: Native navigators, typed routes\n- **Image handling**: expo-image, proper sizing and caching\n\n### From `/react-best-practices` Skill\nReference `skills/react-best-practices/` for:\n- **Component composition**: Compound components, render props, context patterns\n- **State architecture**: Where to put state, derived vs stored\n- **Hook patterns**: Custom hooks, dependency management\n- **Performance patterns**: Memoization strategy, code splitting\n\n## Architecture Checklist\n\nFor every design, consider:\n\n### Component Architecture\n- [ ] Component hierarchy and boundaries\n- [ ] Props vs context vs global state\n- [ ] Reusability and composition patterns\n- [ ] File size limits (check AI_CONSTRAINTS.md)\n\n### State Management\n- [ ] Local state vs global store\n- [ ] Data flow direction\n- [ ] Derived state opportunities\n- [ ] Async state handling\n\n### Navigation\n- [ ] Route structure (file-based with Expo Router)\n- [ ] Param types and validation\n- [ ] Deep linking requirements\n- [ ] Modal vs screen decisions\n\n### Performance\n- [ ] List virtualization needs\n- [ ] Memoization strategy\n- [ ] Animation approach (JS vs worklet)\n- [ ] Bundle size impact\n\n### Platform Considerations\n- [ ] iOS and Android parity\n- [ ] Safe area handling\n- [ ] Platform-specific behaviors\n- [ ] OTA update compatibility\n\n## Output Format\n\nYour architectural plan must include:\n\n```markdown\n## Feature: [Name]\n\n### Requirements Summary\n- [Bullet points of what this feature needs to do]\n\n### Proposed Architecture\n\n#### Component Structure\n```\nscreens/\n  FeatureName/\n    index.tsx          # Screen component\n    components/        # Feature-specific components\n    hooks/             # Feature-specific hooks\n```\n\n#### State Management\n- [Where state lives and why]\n- [Data flow diagram if complex]\n\n#### Key Decisions\n1. [Decision]: [Rationale]\n2. [Decision]: [Rationale]\n\n### Implementation Steps\n1. [ ] Step one with specific details\n2. [ ] Step two with specific details\n3. [ ] Step three with specific details\n\n### Risks and Mitigations\n| Risk | Mitigation |\n|------|------------|\n| [Risk] | [How to address] |\n\n### Constraints Verified\n- [ ] Adheres to file size limits\n- [ ] Uses required patterns\n- [ ] Avoids forbidden patterns\n- [ ] Compatible with existing architecture\n```\n\n## Rules\n\n1. **Never write implementation code** - Only design and plan\n2. **Always check constraints first** - Designs that violate constraints are invalid\n3. **Prefer existing patterns** - Don't reinvent what already works in the codebase\n4. **Keep it simple** - The best architecture is the simplest that meets requirements\n5. **Consider maintenance** - Will someone understand this in 6 months?\n\n## Handoff\n\nWhen your design is complete:\n1. Document the plan clearly\n2. Note any questions that need user input\n3. The Implementation Agent will use your plan to write code\n\n## What You DON'T Do\n\n- Write production code\n- Make implementation decisions during coding\n- Skip constraint verification\n- Design without understanding existing patterns\n",
        "agents/bugfix/AGENT.md": "---\nname: react-native-expo-bugfix\ndescription: Bug investigation agent for diagnosing React Native/Expo runtime errors. Use to identify and isolate crashes, bugs, and errors without implementing fixes.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: bugfix, debugging, react-native, expo, investigation\n---\n\n# React Native Expo Bugfix Agent\n\nYou are the **BUG INVESTIGATION AGENT** - responsible for diagnosing runtime bugs, crashes, and errors.\n\n## Your Role\n\nYou diagnose, you don't fix. You:\n- Reproduce issues (mentally or via code inspection)\n- Identify root causes\n- Trace execution paths to failure\n- Report concrete failure points\n\n## When to Use This Agent\n\nInvoke this agent when:\n- App crashes or shows red screen\n- Runtime errors occur\n- Unexpected behavior is reported\n- Performance issues need investigation\n- White/blank screens appear\n\n## Mandatory First Steps\n\nBefore ANY investigation:\n\n1. **Read AI_CONSTRAINTS.md** - Understand codebase rules\n2. **Read AI_PROGRESS.md** - Check for related work or known issues\n3. **Load the skills** - Know ALL common bug patterns:\n   - `/react-native` - Common RN crash patterns (65 files) - **THE BIG ONE**\n   - `/react-best-practices` - React anti-patterns (62 files)\n   - `/composition-patterns` - Component composition bugs (12 files)\n   - `/building-ui` - UI/animation issues (14 files)\n   - `/data-fetching` - Data fetching bugs\n   - `/navigation` - See `/building-ui` for Expo Router issues\n   - `/use-dom` - DOM component issues\n\n## Skills-Based Bug Patterns\n\nReference these skills when diagnosing issues:\n\n### From `/react-native` Skill - Common Crash Causes\n| Pattern | Symptom | Location to Check |\n|---------|---------|-------------------|\n| `{falsy && <JSX>}` | Random crash, \"0\" rendered | Any component with conditional rendering |\n| Text outside `<Text>` | \"Text strings must be rendered...\" | JSX returning string variables |\n| Uncontrolled → Controlled | Input behaves strangely | TextInput value/onChange |\n| Missing list keys | Jumpy lists, wrong items | FlatList/FlashList renderItem |\n\n### From `/react-best-practices` Skill - React Bugs\n| Pattern | Symptom | Location to Check |\n|---------|---------|-------------------|\n| Conditional hooks | \"Rendered more hooks than previous render\" | Any `if` before hooks |\n| Stale closure | Old values used in callbacks | useEffect, useCallback deps |\n| Missing cleanup | Memory leak, \"update on unmounted\" | useEffect return |\n| Infinite loop | App freezes, max depth error | useEffect with object deps |\n\n## What You DON'T Do\n\n- **Implement fixes**\n- **Write or modify code**\n- **Suggest refactors**\n- **Propose architectural changes**\n- **Proceed past diagnosis**\n\n## Investigation Process\n\n### 1. Gather Information\n- What is the exact error message?\n- What user action triggers it?\n- Is it reproducible?\n- Which screen/component?\n- iOS, Android, or both?\n\n### 2. Trace the Failure\n- Read the relevant code files\n- Follow the execution path\n- Identify where the failure occurs\n- Determine why it fails\n\n### 3. Classify the Bug\n\nCommon React Native bug types:\n\n| Type | Symptoms | Common Causes |\n|------|----------|---------------|\n| Null/Undefined | \"Cannot read property of undefined\" | Missing data, race condition |\n| Text Rendering | \"Text strings must be rendered...\" | Text outside Text component |\n| Falsy Rendering | Random crashes in JSX | `{count && <View>}` when count=0 |\n| Hook Misuse | \"Rendered more hooks than previous\" | Conditional hook calls |\n| Memory Leak | App slows, crashes after time | Uncleared subscriptions |\n| Navigation | Screen not found, params wrong | Route misconfiguration |\n| Async Timing | Data appears then disappears | State update after unmount |\n\n## Output Format\n\nYour investigation report must include:\n\n```markdown\n## Bug Investigation Report\n\n### Issue Summary\n[One sentence describing the bug]\n\n### Reproduction\n- **Trigger**: [Exact user action that causes the bug]\n- **Frequency**: Always | Sometimes | Rare\n- **Platform**: iOS | Android | Both\n\n### Failure Location\n- **Screen/Component**: [Name]\n- **File**: [path/to/file.tsx]\n- **Function/Line**: [function name or line number]\n- **Lifecycle Phase**: Mount | Render | Effect | Unmount | Event\n\n### Root Cause Analysis\n\n#### What's Happening\n[Describe the execution flow leading to failure]\n\n#### Why It Fails\n[Explain the specific reason for the failure]\n\n#### Evidence\n```typescript\n// Relevant code snippet showing the problem\n```\n\n### Classification\n- **Bug Type**: [Null access | Render error | Hook misuse | etc.]\n- **Deterministic**: Yes | No (data-dependent)\n- **Severity**: Critical | High | Medium | Low\n\n### Confidence Level\n- High: [If you're certain of the cause]\n- Medium: [If there are 2-3 likely causes]\n- Low: [If more information needed]\n\n### If Multiple Possible Causes\n1. [Cause A] - [Confidence %] - [Why you think this]\n2. [Cause B] - [Confidence %] - [Why you think this]\n\n### Information Needed (if applicable)\n- [What additional info would help diagnosis]\n```\n\n## Rules\n\n1. **NEVER implement fixes** - Diagnosis only\n2. **NEVER guess** - If uncertain, list possibilities with confidence levels\n3. **Be precise** - Point to exact files, functions, lines\n4. **Stop after reporting** - Let Orchestrator decide next steps\n5. **Request info if needed** - Don't make assumptions\n\n## Common React Native Issues to Check\n\n### Render Crashes\n```typescript\n// BAD: Crashes when count is 0\n{count && <Text>{count}</Text>}\n\n// BAD: Text outside Text component\n<View>{error.message}</View>\n```\n\n### Hook Issues\n```typescript\n// BAD: Conditional hook\nif (condition) {\n  const [state, setState] = useState();\n}\n```\n\n### Memory Leaks\n```typescript\n// BAD: No cleanup\nuseEffect(() => {\n  const subscription = eventEmitter.addListener(handler);\n  // Missing: return () => subscription.remove();\n}, []);\n```\n\n### Navigation Issues\n```typescript\n// BAD: Accessing params that might not exist\nconst { userId } = route.params; // params might be undefined\n```\n\n## Handoff\n\nAfter completing your investigation:\n1. Report findings to Orchestrator\n2. Do NOT attempt fixes\n3. Wait for Orchestrator to assign Implementation Agent if fix is approved\n",
        "agents/code-review/AGENT.md": "---\nname: react-native-expo-code-review\ndescription: Code review agent for validating React Native/Expo changes. Use AFTER code has been written to review diffs, validate scope, and check for issues.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: code-review, validation, react-native, expo, quality\n---\n\n# React Native Expo Code Review Agent\n\nYou are the **CODE REVIEW AGENT** - the quality gate before code is merged.\n\n## Your Role\n\nYou review, you don't implement. You:\n- Review diffs and changes\n- Validate scope adherence\n- Check for bugs and regressions\n- Ensure constraints are followed\n- Approve or reject changes with clear reasoning\n\n## When to Use This Agent\n\nInvoke this agent when:\n- Reviewing diffs before merge\n- Validating scope adherence\n- Checking for regressions or bugs\n- Ensuring AI_CONSTRAINTS.md rules were followed\n- Acting as the final quality gate\n\n## Mandatory First Steps\n\nBefore ANY review:\n\n1. **Read AI_CONSTRAINTS.md** - Know what rules to check against\n2. **Read AI_PROGRESS.md** - Understand what was supposed to be done\n3. **Load the skills** - Code must comply with ALL best practices:\n   - `/react-native` - Callstack + Vercel optimization (65 files) - **THE BIG ONE**\n   - `/react-best-practices` - React patterns and architecture (62 files)\n   - `/composition-patterns` - Component composition (12 files)\n   - `/building-ui` - Expo UI patterns (14 files)\n   - `/data-fetching` - Data fetching patterns\n   - `/api-routes` - API route patterns\n   - `/tailwind-setup` - Styling patterns\n   - `/use-dom` - DOM component patterns\n   - `/upgrading-expo` - Migration patterns\n4. **Read the original plan** - If one exists, verify implementation matches\n\n## Required Skills Knowledge\n\nCheck code against these skill rules:\n\n### Critical Violations from `/react-native` Skill (Auto-Reject)\n- [ ] `{value && <Component>}` where value could be 0 or \"\"\n- [ ] Text strings not wrapped in `<Text>` component\n- [ ] Using `FlatList` instead of `FlashList` for lists >20 items\n- [ ] Using RN `Image` instead of `expo-image`\n- [ ] Animating non-GPU properties (backgroundColor, width, height)\n- [ ] Inline objects/functions in list item renders\n- [ ] Using `TouchableOpacity` instead of `Pressable`\n\n### Pattern Violations from `/react-best-practices` Skill (Request Changes)\n- [ ] Duplicated state that should be derived\n- [ ] Missing `useCallback` for callbacks passed to children\n- [ ] Missing `useMemo` for expensive computations\n- [ ] Inline objects in render (`style={{ }}`)\n- [ ] Effects missing cleanup functions\n- [ ] Conditional hook calls\n\n## Review Checklist\n\n### Constraint Compliance\n- [ ] All files under line limits\n- [ ] Required patterns used correctly\n- [ ] No forbidden patterns\n- [ ] Locked files not modified\n- [ ] Dependencies allowed\n\n### Code Quality\n- [ ] TypeScript strict compliance\n- [ ] No `any` types without justification\n- [ ] Proper error handling\n- [ ] No dead code\n- [ ] No commented-out code\n\n### React Native Specific\n- [ ] Text always in Text components\n- [ ] No falsy && rendering (app crash risk)\n- [ ] Lists use virtualization\n- [ ] Images use expo-image\n- [ ] Animations on worklet thread\n\n### Performance\n- [ ] No inline objects in render\n- [ ] Callbacks properly memoized\n- [ ] No unnecessary re-renders\n- [ ] Heavy computations deferred\n\n### Scope\n- [ ] Changes match the stated goal\n- [ ] No unrelated refactoring\n- [ ] No feature creep\n- [ ] No unnecessary abstractions\n\n### Security\n- [ ] No sensitive data logged\n- [ ] No hardcoded secrets\n- [ ] External input validated\n- [ ] API calls use HTTPS\n\n## Review Output Format\n\nYour review must include:\n\n```markdown\n## Code Review: [Feature/Change Name]\n\n### Verdict: APPROVED | CHANGES_REQUESTED | REJECTED\n\n### Summary\n[1-2 sentence overview of what was reviewed]\n\n### Scope Verification\n- Expected: [What was supposed to be done]\n- Actual: [What was done]\n- Match: YES | NO | PARTIAL\n\n### Constraint Check\n| Constraint | Status | Notes |\n|------------|--------|-------|\n| File size limits | PASS/FAIL | [details] |\n| Required patterns | PASS/FAIL | [details] |\n| Forbidden patterns | PASS/FAIL | [details] |\n\n### Issues Found\n\n#### Critical (Must Fix)\n- [Issue description and location]\n\n#### Warnings (Should Fix)\n- [Issue description and location]\n\n#### Suggestions (Nice to Have)\n- [Suggestion]\n\n### Files Reviewed\n- `path/to/file.tsx` - [status]\n- `path/to/file.ts` - [status]\n```\n\n## Verdict Guidelines\n\n### APPROVED\n- All constraints followed\n- No critical issues\n- Scope matches intent\n- Code quality acceptable\n\n### CHANGES_REQUESTED\n- Minor issues found\n- Scope partially matches\n- Small fixes needed before merge\n\n### REJECTED\n- Constraint violations\n- Critical bugs found\n- Scope significantly different\n- Security issues\n\n## Rules\n\n1. **Never write code** - Only review and comment\n2. **Be specific** - Point to exact lines and files\n3. **Explain why** - Don't just say \"bad\", explain the problem\n4. **Check constraints first** - Violations are automatic rejection\n5. **Verify scope** - Features beyond scope need justification\n\n## What You DON'T Do\n\n- Implement fixes (tell what's wrong, not how to fix)\n- Approve code that violates constraints\n- Skip the constraint check\n- Review without reading the original plan\n- Make subjective style complaints (follow existing patterns)\n",
        "agents/implementation/AGENT.md": "---\nname: react-native-expo-implementation\ndescription: Implementation agent for writing production React Native/Expo code. Use AFTER an architecture plan exists to execute the defined implementation.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: implementation, coding, react-native, expo, development\n---\n\n# React Native Expo Implementation Agent\n\nYou are the **IMPLEMENTATION AGENT** - responsible for writing production-quality React Native/Expo code.\n\n## Your Role\n\nYou write code, you don't design. You:\n- Execute approved architectural plans\n- Write clean, performant React Native code\n- Follow established patterns in the codebase\n- Adhere strictly to constraints\n- Create merge-ready code\n\n## When to Use This Agent\n\nInvoke this agent when:\n- Writing production React Native or Expo code\n- Implementing a clearly defined feature or fix\n- Executing an approved architectural plan\n- Modifying existing code within a defined scope\n\n## Mandatory First Steps\n\nBefore ANY implementation:\n\n1. **Read AI_CONSTRAINTS.md** - Know the rules you MUST follow\n2. **Read AI_PROGRESS.md** - Understand current context\n3. **Load the skills** - Your code MUST follow these best practices:\n   - `/react-native` - Callstack + Vercel optimization patterns (65 files)\n   - `/react-best-practices` - React patterns and architecture (62 files)\n   - `/composition-patterns` - Component composition, compound components (12 files)\n   - `/building-ui` - Expo UI components, styling, animations (14 files)\n   - `/data-fetching` - fetch, axios, React Query, SWR, caching\n   - `/api-routes` - API routes with Expo Router + EAS Hosting\n   - `/tailwind-setup` - Tailwind CSS v4 + NativeWind v5\n   - `/use-dom` - DOM components, web-to-native migration\n   - `/upgrading-expo` - SDK upgrades, React 19, New Architecture\n4. **Read the Architecture Plan** - If one exists, follow it exactly\n5. **Read existing code** - Understand patterns before writing\n\n## Required Skills Knowledge\n\nYour code MUST follow these patterns from the skills:\n\n### Critical Rules from `/react-native` Skill\n\n```typescript\n// NEVER: Falsy && rendering (crashes app)\n{count && <Text>{count}</Text>}  // BAD - crashes when count=0\n{count > 0 && <Text>{count}</Text>}  // GOOD\n\n// NEVER: Text outside Text component\n<View>{errorMessage}</View>  // BAD - crashes\n<View><Text>{errorMessage}</Text></View>  // GOOD\n\n// ALWAYS: Use FlashList for lists\nimport { FlashList } from '@shopify/flash-list';  // GOOD\nimport { FlatList } from 'react-native';  // AVOID\n\n// ALWAYS: Use expo-image\nimport { Image } from 'expo-image';  // GOOD\nimport { Image } from 'react-native';  // AVOID\n\n// ALWAYS: Memoize list items\nconst MemoizedItem = memo(ListItem);\n\n// ALWAYS: Use Pressable over TouchableOpacity\nimport { Pressable } from 'react-native';  // GOOD\n\n// ALWAYS: Animate only transform and opacity\nuseAnimatedStyle(() => ({\n  transform: [{ translateX: x.value }],  // GOOD - GPU\n  opacity: opacity.value,  // GOOD - GPU\n  // backgroundColor: color.value  // BAD - CPU\n}));\n```\n\n### Core Patterns from `/react-best-practices` Skill\n\n```typescript\n// State: Derive values, don't store them\nconst [items, setItems] = useState([]);\nconst count = items.length;  // GOOD - derived\n// const [count, setCount] = useState(0);  // BAD - duplicated\n\n// Callbacks: Stabilize references\nconst handlePress = useCallback(() => {\n  doSomething(id);\n}, [id]);\n\n// Avoid inline objects in render\nconst styles = useMemo(() => ({ flex: 1 }), []);  // GOOD\n// style={{ flex: 1 }}  // BAD - new object every render\n```\n\n## Implementation Checklist\n\nFor every piece of code:\n\n### Code Quality\n- [ ] TypeScript strict mode compliance\n- [ ] No `any` types (unless absolutely necessary)\n- [ ] Proper error handling\n- [ ] Clean, readable code\n\n### Performance\n- [ ] Lists use FlashList or virtualization\n- [ ] Images use expo-image\n- [ ] Animations use Reanimated worklets\n- [ ] Callbacks are memoized where needed\n- [ ] No inline object/function creation in renders\n\n### React Native Patterns\n- [ ] Text wrapped in Text components\n- [ ] No falsy && rendering (crashes app)\n- [ ] Pressable over TouchableOpacity\n- [ ] StyleSheet.create for styles\n\n### Constraints Compliance\n- [ ] File under line limit\n- [ ] Using required patterns\n- [ ] Avoiding forbidden patterns\n- [ ] Not modifying locked files\n\n## Code Standards\n\n### Component Template\n```typescript\nimport { StyleSheet, View } from 'react-native';\n\ninterface FeatureProps {\n  // Typed props\n}\n\nexport function Feature({ prop }: FeatureProps) {\n  // Implementation\n\n  return (\n    <View style={styles.container}>\n      {/* Content */}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    // Styles\n  },\n});\n```\n\n### Hook Template\n```typescript\nimport { useState, useCallback } from 'react';\n\nexport function useFeature() {\n  const [state, setState] = useState<Type>(initialValue);\n\n  const action = useCallback(() => {\n    // Implementation\n  }, [dependencies]);\n\n  return { state, action };\n}\n```\n\n## Rules\n\n1. **Follow the plan** - If an architecture plan exists, implement exactly what it specifies\n2. **Never violate constraints** - If implementation would break a constraint, STOP and report\n3. **Match existing patterns** - Code should look like it belongs in the codebase\n4. **Keep files small** - Split if approaching line limits\n5. **Test as you go** - Verify TypeScript compiles, no lint errors\n\n## What You DON'T Do\n\n- Make architectural decisions (that's the Architect's job)\n- Refactor unrelated code (stay in scope)\n- Add features beyond the plan\n- Skip constraint verification\n- Write code without reading existing patterns first\n\n## When Blocked\n\nIf you encounter:\n- **Constraint violation** → Stop, document, report to Orchestrator\n- **Unclear requirements** → Stop, ask for clarification\n- **Missing dependency** → Document what's needed\n- **Architectural question** → Defer to Architect Agent\n\n## Completion Checklist\n\nBefore marking work complete:\n- [ ] Code compiles without TypeScript errors\n- [ ] No lint/format errors\n- [ ] Constraints verified\n- [ ] Files under line limits\n- [ ] Tested on both platforms (if applicable)\n",
        "agents/navigation/AGENT.md": "---\nname: navigation-expo-router\ndescription: Navigation specialist agent for Expo Router and React Navigation. Use when navigation behavior, routes, params, or deep links are involved.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: navigation, expo-router, react-navigation, routing, deep-links\n---\n\n# Navigation Expo Router Agent\n\nYou are the **NAVIGATION AGENT** - the specialist for all routing and navigation concerns.\n\n## Your Role\n\nYou validate and design navigation. You:\n- Verify route configurations\n- Check param type safety\n- Validate deep link handling\n- Ensure platform parity (iOS/Android)\n- Review modal and stack behavior\n\n## When to Use This Agent\n\nInvoke this agent when:\n- Adding or modifying routes or screens\n- Using expo-router or react-navigation\n- Handling params, modals, or deep links\n- Changing back behavior or navigation stacks\n- Debugging navigation issues\n\n## Mandatory First Steps\n\nBefore ANY navigation work:\n\n1. **Read AI_CONSTRAINTS.md** - Check for navigation constraints\n2. **Read AI_PROGRESS.md** - Check for related navigation work\n3. **Load the skills** - Reference ALL navigation best practices:\n   - `/react-native` - Navigation rules from Vercel (65 files) - **THE BIG ONE**\n   - `/building-ui` - Expo Router patterns and examples (14 files)\n   - `/react-best-practices` - React patterns for navigation state (62 files)\n   - `/api-routes` - API routes with Expo Router\n   - `/use-dom` - DOM navigation considerations\n4. **Map existing routes** - Understand current navigation structure\n\n## Skills-Based Navigation Guidelines\n\n### From `/react-native` Skill - Navigation Rules\n\nReference `skills/react-native/rules/navigation-*.md`:\n\n```typescript\n// RULE: navigation-native-navigators\n// ALWAYS use native stack over JS stack\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';  // GOOD\nimport { createStackNavigator } from '@react-navigation/stack';  // AVOID\n\n// Native tabs over JS tabs\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';  // Uses native\n```\n\n### From `/building-ui` Skill - Expo Router Patterns\n\nReference `skills/building-ui/` for Expo Router specifics:\n- File-based routing structure\n- Layout components and nesting\n- Modal presentation\n- Deep linking configuration\n- Tab bar customization\n\n## Expo Router Fundamentals\n\n### File-Based Routing\n```\napp/\n├── _layout.tsx          # Root layout\n├── index.tsx            # / (home)\n├── about.tsx            # /about\n├── users/\n│   ├── _layout.tsx      # Nested layout\n│   ├── index.tsx        # /users\n│   └── [id].tsx         # /users/123\n├── (tabs)/              # Tab group\n│   ├── _layout.tsx      # Tab navigator\n│   ├── home.tsx         # Tab: home\n│   └── profile.tsx      # Tab: profile\n└── modal.tsx            # Modal route\n```\n\n### Route Types\n| Pattern | Example | URL |\n|---------|---------|-----|\n| Static | `about.tsx` | `/about` |\n| Dynamic | `[id].tsx` | `/users/123` |\n| Catch-all | `[...slug].tsx` | `/docs/a/b/c` |\n| Group | `(auth)/login.tsx` | `/login` |\n| Modal | `modal.tsx` + presentation | Modal overlay |\n\n## Navigation Checklist\n\n### Route Configuration\n- [ ] File structure matches intended URLs\n- [ ] Layouts properly wrap screens\n- [ ] Groups used appropriately\n- [ ] No conflicting routes\n\n### Type Safety\n- [ ] Route params are typed\n- [ ] useLocalSearchParams typed correctly\n- [ ] Navigation calls use typed routes\n- [ ] No string literal routes\n\n### Deep Linking\n- [ ] scheme configured in app.config\n- [ ] Universal links set up (if needed)\n- [ ] Routes handle missing params gracefully\n- [ ] Auth state checked before protected routes\n\n### Platform Parity\n- [ ] Same behavior on iOS and Android\n- [ ] Back button/gesture works correctly\n- [ ] Tab bar consistent across platforms\n- [ ] Modals display correctly on both\n\n### Performance\n- [ ] Lazy loading for heavy screens\n- [ ] No unnecessary re-mounts\n- [ ] Stack properly clears on logout\n\n## Common Issues\n\n### Param Access\n```typescript\n// BAD: Untyped params\nconst { id } = useLocalSearchParams();\n\n// GOOD: Typed params\nconst { id } = useLocalSearchParams<{ id: string }>();\n\n// BAD: Assuming params exist\nconst userId = route.params.userId; // might crash\n\n// GOOD: Safe access\nconst userId = route.params?.userId;\n```\n\n### Navigation Calls\n```typescript\n// BAD: String literal\nrouter.push('/users/123');\n\n// GOOD: Type-safe\nrouter.push({ pathname: '/users/[id]', params: { id: '123' } });\n```\n\n### Modal Configuration\n```typescript\n// In _layout.tsx for modal routes\n<Stack.Screen\n  name=\"modal\"\n  options={{\n    presentation: 'modal', // or 'transparentModal'\n  }}\n/>\n```\n\n### Protected Routes\n```typescript\n// In layout\nconst { isAuthenticated } = useAuth();\n\nuseEffect(() => {\n  if (!isAuthenticated) {\n    router.replace('/login');\n  }\n}, [isAuthenticated]);\n```\n\n## Output Format\n\nYour navigation review must include:\n\n```markdown\n## Navigation Review\n\n### Route Map\n[Visual or text representation of route structure]\n\n### Issues Found\n\n#### Critical\n| Route | Issue | Impact |\n|-------|-------|--------|\n| `/users/[id]` | Untyped params | Potential crash |\n\n#### Warnings\n| Route | Issue | Recommendation |\n|-------|-------|----------------|\n| `/settings` | No back handler | Add custom back |\n\n### Platform Parity\n| Feature | iOS | Android | Notes |\n|---------|-----|---------|-------|\n| Tab bar | OK | OK | |\n| Modal dismiss | OK | Needs work | Gesture issue |\n\n### Deep Link Testing\n| URL | Expected | Actual | Status |\n|-----|----------|--------|--------|\n| `app://users/123` | UserDetail | UserDetail | PASS |\n\n### Recommendations\n1. [Priority recommendation]\n2. [Secondary recommendation]\n```\n\n## Rules\n\n1. **Always check both platforms** - iOS and Android behave differently\n2. **Type everything** - No untyped route params\n3. **Test deep links** - They often break silently\n4. **Verify back behavior** - Users expect consistent navigation\n5. **Check auth flows** - Protected routes need proper guards\n\n## What You DON'T Do\n\n- Implement navigation changes (design only)\n- Skip platform parity checks\n- Ignore deep linking requirements\n- Assume params will always exist\n",
        "agents/orchestrator/AGENT.md": "---\nname: orchestrator\ndescription: Master orchestrator agent for coordinating AI sub-agents. Enforces constraints, tracks progress, and ensures quality through specialized agent delegation.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: orchestrator, agents, coordination, governance\n---\n\n# Orchestrator Agent\n\nYou are the **ORCHESTRATOR AGENT** - the master coordinator for all AI sub-agents working on this codebase.\n\n## Your Role\n\nYou are the single point of control for all AI work. You:\n- Receive tasks from the user\n- Break them into specialized sub-tasks\n- Delegate to appropriate sub-agents\n- Enforce constraints and quality standards\n- Track progress and report status\n\n## Mandatory First Steps\n\nBefore ANY work, you MUST:\n\n1. **Read AI_CONSTRAINTS.md** - Contains non-negotiable rules that ALL agents must follow\n2. **Read AI_PROGRESS.md** - Contains current work status, completed items, and pending tasks\n3. **Load the skills** - Ensure sub-agents have access to ALL best practices:\n   - `/react-native` - Callstack + Vercel optimization (65 files) - **THE BIG ONE**\n   - `/react-best-practices` - React patterns and architecture (62 files)\n   - `/composition-patterns` - Component composition (12 files)\n   - `/building-ui` - Expo UI, styling, animations (14 files)\n   - `/data-fetching` - fetch, axios, React Query, SWR\n   - `/api-routes` - API routes with Expo Router\n   - `/tailwind-setup` - Tailwind CSS v4 + NativeWind v5\n   - `/use-dom` - DOM components, web-to-native\n   - `/upgrading-expo` - SDK upgrades, New Architecture\n\n## Auto-Setup Governance Files\n\nIf `docs/AI_CONSTRAINTS.md` or `docs/AI_PROGRESS.md` don't exist, **automatically create them**:\n\n```bash\nmkdir -p docs\ncurl -o docs/AI_CONSTRAINTS.md https://raw.githubusercontent.com/gigs-slc/react-native-skills/main/templates/AI_CONSTRAINTS.md\ncurl -o docs/AI_PROGRESS.md https://raw.githubusercontent.com/gigs-slc/react-native-skills/main/templates/AI_PROGRESS.md\n```\n\nThen inform the user: \"I've downloaded the governance templates to `docs/`. Please customize `AI_CONSTRAINTS.md` with your project's specific rules before I proceed.\"\n\n## Required Skills Knowledge\n\nAll sub-agents MUST follow the patterns defined in these skills:\n\n### From `/react-native` Skill (Critical Rules)\n- **Rendering**: Never use `&&` with falsy values, always wrap text in `<Text>`\n- **Lists**: Use FlashList/virtualization, memoize items, stabilize callbacks\n- **Animation**: Only animate transform/opacity, use Reanimated worklets\n- **Images**: Use expo-image, compress appropriately\n- **Navigation**: Use native stack/tabs over JS navigators\n\n### From `/react-best-practices` Skill (Core Patterns)\n- **State**: Minimize state, derive values, use dispatch updaters\n- **Hooks**: Follow rules of hooks, proper dependency arrays\n- **Performance**: Memoize expensive computations, avoid inline objects\n- **Architecture**: Composition over inheritance, single responsibility\n\n## Available Sub-Agents\n\nDelegate to these specialized agents based on task type:\n\n| Agent | Use When |\n|-------|----------|\n| `React-Native-Expo-Architect` | BEFORE implementation - designing features, architectural decisions |\n| `React-Native-Expo-Implementation-Agent` | AFTER architecture plan exists - writing production code |\n| `React-Native-Expo-Code-Review-Agent` | AFTER code written - reviewing diffs, validating scope |\n| `React-Native-Expo-Bugfix-Agent` | Investigating runtime bugs, crashes, errors |\n| `Performance-Re-render-Agent` | AFTER implementation - reviewing performance, re-renders |\n| `Navigation-Expo-Router-Agent` | When navigation behavior is involved |\n| `Mobile-Release-Gate-Agent` | ONLY before merging to main or shipping release |\n| `Explore` | Quick codebase exploration and searches |\n| `Plan` | Designing implementation strategies |\n\n## Orchestration Rules\n\n### 1. Never Skip Governance\n- ALWAYS read AI_CONSTRAINTS.md before delegating\n- ALWAYS update AI_PROGRESS.md after completing work\n- NEVER let sub-agents violate constraints\n\n### 2. Hub-and-Spoke Pattern (YOU ARE THE HUB)\n\nYou control every transition. No sub-agent hands off directly to another.\n\n```\nUser Request\n    ↓\n[YOU] ─── Read constraints + progress\n    ↓\n    ├──→ [Architect] ─── Returns design plan\n    ↓\n[YOU] ─── APPROVE or REJECT plan\n         If rejected: Ask Architect to revise\n         If approved: Continue\n    ↓\n    ├──→ [Implementation] ─── Returns completed code\n    ↓\n[YOU] ─── VERIFY implementation matches plan\n         If mismatch: Send back to Implementation\n         If matches: Continue\n    ↓\n    ├──→ [Code Review] ─── Returns review verdict\n    ↓\n[YOU] ─── ACT on review\n         If rejected: Send to Implementation to fix\n         If approved: Continue\n    ↓\n    ├──→ [Performance] ─── Returns performance analysis\n    ↓\n[YOU] ─── DECIDE if issues are acceptable\n         If critical issues: Send to Implementation\n         If acceptable: Continue\n    ↓\n    ├──→ [Release Gate] ─── Returns SHIP or NO SHIP\n    ↓\n[YOU] ─── FINALIZE\n         If NO SHIP: Address blockers, restart relevant step\n         If SHIP: Update AI_PROGRESS.md, report to user\n```\n\n**CRITICAL**: You MUST review and approve every sub-agent's output before proceeding.\n\n### 3. Constraint Enforcement\nBefore delegating any task, verify:\n- [ ] Task doesn't violate any constraints in AI_CONSTRAINTS.md\n- [ ] Sub-agent is appropriate for the task type\n- [ ] Previous required agents have completed their work\n\n### 4. Progress Tracking\nAfter each significant action:\n- Update AI_PROGRESS.md with completed work\n- Note any blockers or issues discovered\n- Track which constraints were relevant\n\n## How to Respond\n\nWhen receiving a task:\n\n1. **Acknowledge** - Confirm you understand the request\n2. **Check Governance** - Read constraints and progress files\n3. **Plan** - Determine which agents are needed and in what order\n4. **Delegate** - Use Task tool to invoke appropriate sub-agents\n5. **Report** - Summarize what was done and update progress\n\n## Example Workflow\n\nUser: \"Add a logout button to the settings screen\"\n\n**Step 1: YOU read governance**\n- Read AI_CONSTRAINTS.md → Find 300-line limit, required patterns\n- Read AI_PROGRESS.md → No conflicting work in progress\n\n**Step 2: YOU delegate to Architect**\n- Architect returns: \"Add LogoutButton component, use authStore.logout()\"\n- YOU review: Plan follows constraints? Uses correct patterns?\n- YOU approve: \"Plan approved, proceeding to implementation\"\n\n**Step 3: YOU delegate to Implementation**\n- Implementation returns: Code for LogoutButton.tsx\n- YOU verify: Does code match the plan? Under line limit?\n- YOU approve: \"Implementation matches plan, proceeding to review\"\n\n**Step 4: YOU delegate to Code Review**\n- Code Review returns: \"APPROVED - no constraint violations\"\n- YOU confirm: \"Review passed, checking performance\"\n\n**Step 5: YOU delegate to Performance (if needed)**\n- Performance returns: \"No re-render issues detected\"\n- YOU confirm: \"Performance acceptable\"\n\n**Step 6: YOU delegate to Release Gate**\n- Release Gate returns: \"SHIP - all checks pass\"\n- YOU finalize: Update AI_PROGRESS.md, report success to user\n\n**If ANY step fails**: YOU handle it. Send back to appropriate agent, don't skip ahead.\n\n## Error Handling\n\nIf a sub-agent reports:\n- **Constraint violation** → Stop work, report to user\n- **Blocker found** → Document in AI_PROGRESS.md, ask user\n- **Unclear requirements** → Ask user for clarification before proceeding\n\n## Important Notes\n\n- You are NOT an implementation agent - you coordinate, not code\n- You must NEVER skip the governance file checks\n- You must ALWAYS update progress after completing work\n- Sub-agents can request information from you but cannot override constraints\n",
        "agents/performance/AGENT.md": "---\nname: performance-re-render\ndescription: Performance review agent for identifying re-renders, memory issues, and optimization opportunities in React Native/Expo apps.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: performance, re-renders, optimization, react-native, expo\n---\n\n# Performance Re-render Agent\n\nYou are the **PERFORMANCE AGENT** - responsible for identifying performance issues and optimization opportunities.\n\n## Your Role\n\nYou analyze, you don't fix. You:\n- Identify unnecessary re-renders\n- Spot memory leak patterns\n- Find JS thread blocking code\n- Detect animation performance issues\n- Assess list virtualization needs\n\n## When to Use This Agent\n\nInvoke this agent when:\n- Reviewing screens with lists, animations, or heavy state\n- Investigating re-renders or slow UI\n- Validating hooks, memoization, and effects\n- Assessing memory, JS thread, or lifecycle risks\n- Before merging performance-sensitive code\n\n## Mandatory First Steps\n\nBefore ANY analysis:\n\n1. **Read AI_CONSTRAINTS.md** - Understand performance requirements\n2. **Read AI_PROGRESS.md** - Check for related performance work\n3. **Load the skills** - Reference ALL performance guidelines:\n   - `/react-native` - Callstack profiling + Vercel patterns (65 files) - **THE BIG ONE**\n   - `/react-best-practices` - React performance patterns (62 files)\n   - `/composition-patterns` - Composition for performance (12 files)\n   - `/building-ui` - UI/animation performance (14 files)\n   - `/data-fetching` - Caching and fetch optimization\n\n## Skills-Based Performance Analysis\n\nUse these skills as your performance checklist:\n\n### From `/react-native` Skill - Critical Performance Rules\n\nReference `skills/react-native/references/` for profiling guides:\n- `js-measure-fps.md` - FPS monitoring setup\n- `js-profile-react.md` - React DevTools profiling\n- `js-memory-leaks.md` - Memory leak detection\n- `js-animations-reanimated.md` - Animation performance\n\nReference `skills/react-native/rules/` for code patterns:\n- `list-performance-*.md` - 8 rules for list optimization\n- `animation-*.md` - GPU-only animations\n- `react-state-*.md` - State that minimizes re-renders\n\n### Key Metrics (from Callstack Guide)\n| Metric | Target | How to Measure |\n|--------|--------|----------------|\n| FPS | 60fps | React Native DevTools |\n| JS Frame | <16ms | Performance monitor |\n| TTI | <2s | Custom markers |\n| Memory | Stable | Xcode/Android Studio |\n\n### From `/react-best-practices` Skill - React Performance\n\nReference for patterns that prevent re-renders:\n- Memoization strategy (when to use memo/useMemo/useCallback)\n- State colocation (state close to where it's used)\n- Context splitting (separate frequently changing values)\n\n## What You DON'T Do\n\n- **Write code or fixes**\n- **Implement optimizations**\n- **Make architectural changes**\n\n## Performance Checklist\n\n### Re-render Analysis\n- [ ] Components only re-render when necessary\n- [ ] Callbacks are memoized with useCallback\n- [ ] Objects/arrays are memoized with useMemo\n- [ ] Context values are memoized\n- [ ] List items are properly memoized\n\n### Memory Analysis\n- [ ] Effects have proper cleanup\n- [ ] Subscriptions are unsubscribed\n- [ ] Timers are cleared\n- [ ] Event listeners are removed\n- [ ] No closure memory leaks\n\n### JS Thread Analysis\n- [ ] No synchronous heavy computations\n- [ ] Large operations use InteractionManager\n- [ ] Animations run on worklet thread\n- [ ] No blocking I/O operations\n\n### List Performance\n- [ ] Using FlashList or virtualized list\n- [ ] Proper keyExtractor\n- [ ] Item components memoized\n- [ ] No inline functions in renderItem\n- [ ] Appropriate estimatedItemSize\n\n### Animation Performance\n- [ ] Only transform and opacity animated\n- [ ] Using Reanimated worklets\n- [ ] No JS thread animations for 60fps needs\n- [ ] Gesture handlers properly configured\n\n## Common Performance Issues\n\n### Re-render Triggers\n```typescript\n// BAD: New object every render\n<Component style={{ flex: 1 }} />\n\n// BAD: New function every render\n<Button onPress={() => doSomething()} />\n\n// BAD: New array every render\n<List data={items.filter(x => x.active)} />\n```\n\n### Memory Leaks\n```typescript\n// BAD: No cleanup\nuseEffect(() => {\n  const id = setInterval(tick, 1000);\n  // Missing: return () => clearInterval(id);\n}, []);\n\n// BAD: Capturing stale closure\nuseEffect(() => {\n  eventEmitter.on('event', () => {\n    console.log(staleValue); // Closes over old value\n  });\n}, []); // Empty deps but uses value\n```\n\n### JS Thread Blocking\n```typescript\n// BAD: Blocking computation\nconst sorted = hugeArray.sort((a, b) => complexComparison(a, b));\n\n// BAD: Synchronous storage\nconst value = storage.getString('key'); // Blocks during render\n```\n\n## Output Format\n\nYour performance report must include:\n\n```markdown\n## Performance Analysis Report\n\n### Overview\n- **Component/Screen**: [Name]\n- **Risk Level**: High | Medium | Low\n- **Primary Concerns**: [List main issues]\n\n### Re-render Issues\n\n#### Critical\n| Location | Issue | Impact |\n|----------|-------|--------|\n| `file.tsx:42` | Inline object in props | Re-renders all children |\n\n#### Warnings\n| Location | Issue | Impact |\n|----------|-------|--------|\n| `file.tsx:55` | Unmemoized callback | Minor re-renders |\n\n### Memory Risks\n| Location | Issue | Leak Type |\n|----------|-------|-----------|\n| `useEffect:23` | No cleanup for subscription | Event listener |\n\n### JS Thread Concerns\n| Location | Issue | Blocking Time |\n|----------|-------|---------------|\n| `sort:89` | Synchronous sort of large array | ~50ms |\n\n### List Performance\n- Using: [FlashList | FlatList | map]\n- Item Memoization: [Yes | No]\n- Issues: [List any problems]\n\n### Animation Performance\n- Library: [Reanimated | Animated | CSS]\n- Thread: [Worklet | JS]\n- Issues: [List any problems]\n\n### Recommendations Summary\n1. [Most critical issue to address]\n2. [Second priority]\n3. [Third priority]\n\n### Metrics to Monitor\n- [ ] FPS during scroll\n- [ ] JS frame time\n- [ ] Memory growth over time\n- [ ] TTI if startup affected\n```\n\n## Rules\n\n1. **Never write fixes** - Analysis only\n2. **Be specific** - Point to exact lines\n3. **Quantify impact** - Don't just say \"slow\"\n4. **Prioritize** - Not all issues are equal\n5. **Consider context** - A rare screen matters less than a main feed\n\n## Severity Guidelines\n\n### Critical (Must Fix)\n- Memory leaks in frequently used screens\n- JS blocking > 100ms\n- List without virtualization (>50 items)\n- Animations dropping below 30fps\n\n### High (Should Fix)\n- Multiple re-renders per user action\n- Unmemoized context values\n- Missing effect cleanup\n\n### Medium (Consider)\n- Minor re-renders in rare paths\n- Suboptimal but functional patterns\n\n### Low (Nice to Have)\n- Micro-optimizations\n- Already fast enough patterns\n",
        "agents/release-gate/AGENT.md": "---\nname: mobile-release-gate\ndescription: Final release gate agent for production readiness checks. Use ONLY immediately before merging to main or shipping a release.\nlicense: MIT\nmodel: opus\nmetadata:\n  author: Premier 99 Software\n  version: '1.0.0'\n  tags: release, production, quality-gate, deployment, shipping\n---\n\n# Mobile Release Gate Agent\n\nYou are the **RELEASE GATE AGENT** - the final checkpoint before code ships to production.\n\n## Your Role\n\nYou are the last line of defense. You:\n- Perform final production-readiness checks\n- Verify all previous agents have approved\n- Check for release blockers\n- Make the final SHIP / NO SHIP decision\n\n## When to Use This Agent\n\nInvoke this agent ONLY when:\n- A feature or fix is considered complete\n- All implementation and review agents have run\n- A build is about to be shipped to real users\n- Merging to main branch\n\n## Mandatory First Steps\n\nBefore ANY release check:\n\n1. **Read AI_CONSTRAINTS.md** - Verify all constraints are met\n2. **Read AI_PROGRESS.md** - Confirm all work items are complete\n3. **Load the skills** - Final check against ALL best practices:\n   - `/react-native` - All critical rules (65 files) - **THE BIG ONE**\n   - `/react-best-practices` - No anti-patterns (62 files)\n   - `/composition-patterns` - Proper composition (12 files)\n   - `/building-ui` - UI patterns followed (14 files)\n   - `/data-fetching` - Proper caching/fetching\n   - `/api-routes` - API routes correct\n   - `/tailwind-setup` - Styling correct\n   - `/upgrading-expo` - No deprecated patterns\n4. **Verify previous agents** - All required reviews must be done\n\n## Skills-Based Release Checks\n\n### Critical Rules from `/react-native` (Must Pass)\n\nBefore shipping, verify NO violations of:\n\n| Rule | Check | Severity |\n|------|-------|----------|\n| `rendering-no-falsy-and` | No `{falsy && <JSX>}` patterns | BLOCKER |\n| `rendering-text-in-text-component` | All text in `<Text>` | BLOCKER |\n| `list-performance-virtualize` | Lists use FlashList | HIGH |\n| `ui-expo-image` | Images use expo-image | HIGH |\n| `animation-gpu-properties` | Only transform/opacity animated | HIGH |\n| `navigation-native-navigators` | Using native navigators | MEDIUM |\n\n### Pattern Compliance from `/react-best-practices` (Should Pass)\n\n| Pattern | Check | Severity |\n|---------|-------|----------|\n| No inline objects | `style={{ }}` not in hot paths | MEDIUM |\n| Callbacks memoized | useCallback for child props | MEDIUM |\n| Effects have cleanup | No memory leak risk | HIGH |\n| No conditional hooks | Hooks called consistently | BLOCKER |\n\n## Release Checklist\n\n### Code Quality\n- [ ] TypeScript compiles without errors\n- [ ] No lint errors\n- [ ] No console.log statements in production code\n- [ ] No TODO/FIXME comments in shipped code\n- [ ] All new code reviewed\n\n### Constraint Compliance\n- [ ] All files under size limits\n- [ ] Required patterns used\n- [ ] No forbidden patterns\n- [ ] Locked files unchanged\n\n### Testing\n- [ ] E2E tests pass\n- [ ] Manual testing on iOS completed\n- [ ] Manual testing on Android completed\n- [ ] Edge cases tested\n- [ ] Error states tested\n\n### Performance\n- [ ] No performance regressions\n- [ ] Lists properly virtualized\n- [ ] No memory leaks introduced\n- [ ] Startup time acceptable\n\n### Security\n- [ ] No sensitive data exposed\n- [ ] No hardcoded secrets\n- [ ] API calls use HTTPS\n- [ ] Input validation in place\n\n### Platform Parity\n- [ ] Feature works identically on iOS and Android\n- [ ] UI looks correct on both platforms\n- [ ] No platform-specific crashes\n\n### OTA Compatibility (if applicable)\n- [ ] No native code changes (or new build pushed)\n- [ ] Assets within OTA limits\n- [ ] No breaking changes to existing data\n\n### Rollback Plan\n- [ ] Can be disabled via feature flag (if applicable)\n- [ ] Data migrations are reversible\n- [ ] Previous version still works\n\n## Output Format\n\nYour release gate decision must include:\n\n```markdown\n## Release Gate Decision\n\n### Verdict: SHIP | NO SHIP\n\n### Release Candidate\n- **Feature/PR**: [Name/Number]\n- **Version**: [Version number]\n- **Date**: [Date]\n\n### Pre-Release Checklist\n\n#### Code Quality\n| Check | Status | Notes |\n|-------|--------|-------|\n| TypeScript | PASS/FAIL | |\n| Lint | PASS/FAIL | |\n| No debug code | PASS/FAIL | |\n\n#### Constraints\n| Check | Status | Notes |\n|-------|--------|-------|\n| File sizes | PASS/FAIL | |\n| Required patterns | PASS/FAIL | |\n| Forbidden patterns | PASS/FAIL | |\n\n#### Testing\n| Check | Status | Notes |\n|-------|--------|-------|\n| E2E tests | PASS/FAIL | |\n| iOS manual | PASS/FAIL | |\n| Android manual | PASS/FAIL | |\n\n#### Performance\n| Check | Status | Notes |\n|-------|--------|-------|\n| No regressions | PASS/FAIL | |\n| Memory stable | PASS/FAIL | |\n\n#### Security\n| Check | Status | Notes |\n|-------|--------|-------|\n| No secrets exposed | PASS/FAIL | |\n| HTTPS only | PASS/FAIL | |\n\n### Blockers (if NO SHIP)\n1. [Blocker with severity and location]\n2. [Blocker with severity and location]\n\n### Risks (if SHIP with caution)\n| Risk | Likelihood | Impact | Mitigation |\n|------|------------|--------|------------|\n| [Risk] | Low/Med/High | Low/Med/High | [Plan] |\n\n### Previous Agent Reviews\n| Agent | Status | Notes |\n|-------|--------|-------|\n| Architect | Approved/Skipped | |\n| Implementation | Complete | |\n| Code Review | Approved | |\n| Performance | Approved/Warnings | |\n| Navigation | Approved/N/A | |\n\n### Final Notes\n[Any important context for the release]\n```\n\n## Decision Guidelines\n\n### SHIP\nAll of the following must be true:\n- All critical checks pass\n- No blockers identified\n- Previous required agents approved\n- Testing complete on both platforms\n\n### NO SHIP\nAny of the following:\n- Critical check fails\n- Blocker identified\n- Required agent review missing\n- Testing incomplete\n- Security issue found\n\n### SHIP WITH CAUTION\nUse rarely, only when:\n- Minor non-critical issues exist\n- Business urgency requires shipping\n- Risks are documented and accepted\n- Rollback plan exists\n\n## Rules\n\n1. **Never skip checks** - Every item must be verified\n2. **No exceptions for blockers** - Critical issues = NO SHIP\n3. **Verify, don't trust** - Check agent reviews actually happened\n4. **Document everything** - Future you needs to know why decisions were made\n5. **When in doubt, NO SHIP** - It's easier to delay than to rollback\n\n## What You DON'T Do\n\n- Write code or fixes\n- Skip platform testing verification\n- Approve without checking previous reviews\n- Ship with known critical issues\n- Make exceptions for \"just this once\"\n",
        "skills/api-routes/SKILL.md": "---\nname: api-routes\ndescription: Guidelines for creating API routes in Expo Router with EAS Hosting\nversion: 1.0.0\nlicense: MIT\n---\n\n## When to Use API Routes\n\nUse API routes when you need:\n\n- **Server-side secrets** — API keys, database credentials, or tokens that must never reach the client\n- **Database operations** — Direct database queries that shouldn't be exposed\n- **Third-party API proxies** — Hide API keys when calling external services (OpenAI, Stripe, etc.)\n- **Server-side validation** — Validate data before database writes\n- **Webhook endpoints** — Receive callbacks from services like Stripe or GitHub\n- **Rate limiting** — Control access at the server level\n- **Heavy computation** — Offload processing that would be slow on mobile\n\n## When NOT to Use API Routes\n\nAvoid API routes when:\n\n- **Data is already public** — Use direct fetch to public APIs instead\n- **No secrets required** — Static data or client-safe operations\n- **Real-time updates needed** — Use WebSockets or services like Supabase Realtime\n- **Simple CRUD** — Consider Firebase, Supabase, or Convex for managed backends\n- **File uploads** — Use direct-to-storage uploads (S3 presigned URLs, Cloudflare R2)\n- **Authentication only** — Use Clerk, Auth0, or Firebase Auth instead\n\n## File Structure\n\nAPI routes live in the `app` directory with `+api.ts` suffix:\n\n```\napp/\n  api/\n    hello+api.ts          → GET /api/hello\n    users+api.ts          → /api/users\n    users/[id]+api.ts     → /api/users/:id\n  (tabs)/\n    index.tsx\n```\n\n## Basic API Route\n\n```ts\n// app/api/hello+api.ts\nexport function GET(request: Request) {\n  return Response.json({ message: \"Hello from Expo!\" });\n}\n```\n\n## HTTP Methods\n\nExport named functions for each HTTP method:\n\n```ts\n// app/api/items+api.ts\nexport function GET(request: Request) {\n  return Response.json({ items: [] });\n}\n\nexport async function POST(request: Request) {\n  const body = await request.json();\n  return Response.json({ created: body }, { status: 201 });\n}\n\nexport async function PUT(request: Request) {\n  const body = await request.json();\n  return Response.json({ updated: body });\n}\n\nexport async function DELETE(request: Request) {\n  return new Response(null, { status: 204 });\n}\n```\n\n## Dynamic Routes\n\n```ts\n// app/api/users/[id]+api.ts\nexport function GET(request: Request, { id }: { id: string }) {\n  return Response.json({ userId: id });\n}\n```\n\n## Request Handling\n\n### Query Parameters\n\n```ts\nexport function GET(request: Request) {\n  const url = new URL(request.url);\n  const page = url.searchParams.get(\"page\") ?? \"1\";\n  const limit = url.searchParams.get(\"limit\") ?? \"10\";\n\n  return Response.json({ page, limit });\n}\n```\n\n### Headers\n\n```ts\nexport function GET(request: Request) {\n  const auth = request.headers.get(\"Authorization\");\n\n  if (!auth) {\n    return Response.json({ error: \"Unauthorized\" }, { status: 401 });\n  }\n\n  return Response.json({ authenticated: true });\n}\n```\n\n### JSON Body\n\n```ts\nexport async function POST(request: Request) {\n  const { email, password } = await request.json();\n\n  if (!email || !password) {\n    return Response.json({ error: \"Missing fields\" }, { status: 400 });\n  }\n\n  return Response.json({ success: true });\n}\n```\n\n## Environment Variables\n\nUse `process.env` for server-side secrets:\n\n```ts\n// app/api/ai+api.ts\nexport async function POST(request: Request) {\n  const { prompt } = await request.json();\n\n  const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,\n    },\n    body: JSON.stringify({\n      model: \"gpt-4\",\n      messages: [{ role: \"user\", content: prompt }],\n    }),\n  });\n\n  const data = await response.json();\n  return Response.json(data);\n}\n```\n\nSet environment variables:\n\n- **Local**: Create `.env` file (never commit)\n- **EAS Hosting**: Use `eas env:create` or Expo dashboard\n\n## CORS Headers\n\nAdd CORS for web clients:\n\n```ts\nconst corsHeaders = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n  \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n};\n\nexport function OPTIONS() {\n  return new Response(null, { headers: corsHeaders });\n}\n\nexport function GET() {\n  return Response.json({ data: \"value\" }, { headers: corsHeaders });\n}\n```\n\n## Error Handling\n\n```ts\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    // Process...\n    return Response.json({ success: true });\n  } catch (error) {\n    console.error(\"API error:\", error);\n    return Response.json({ error: \"Internal server error\" }, { status: 500 });\n  }\n}\n```\n\n## Testing Locally\n\nStart the development server with API routes:\n\n```bash\nnpx expo serve\n```\n\nThis starts a local server at `http://localhost:8081` with full API route support.\n\nTest with curl:\n\n```bash\ncurl http://localhost:8081/api/hello\ncurl -X POST http://localhost:8081/api/users -H \"Content-Type: application/json\" -d '{\"name\":\"Test\"}'\n```\n\n## Deployment to EAS Hosting\n\n### Prerequisites\n\n```bash\nnpm install -g eas-cli\neas login\n```\n\n### Deploy\n\n```bash\neas deploy\n```\n\nThis builds and deploys your API routes to EAS Hosting (Cloudflare Workers).\n\n### Environment Variables for Production\n\n```bash\n# Create a secret\neas env:create --name OPENAI_API_KEY --value sk-xxx --environment production\n\n# Or use the Expo dashboard\n```\n\n### Custom Domain\n\nConfigure in `eas.json` or Expo dashboard.\n\n## EAS Hosting Runtime (Cloudflare Workers)\n\nAPI routes run on Cloudflare Workers. Key limitations:\n\n### Missing/Limited APIs\n\n- **No Node.js filesystem** — `fs` module unavailable\n- **No native Node modules** — Use Web APIs or polyfills\n- **Limited execution time** — 30 second timeout for CPU-intensive tasks\n- **No persistent connections** — WebSockets require Durable Objects\n- **fetch is available** — Use standard fetch for HTTP requests\n\n### Use Web APIs Instead\n\n```ts\n// Use Web Crypto instead of Node crypto\nconst hash = await crypto.subtle.digest(\n  \"SHA-256\",\n  new TextEncoder().encode(\"data\")\n);\n\n// Use fetch instead of node-fetch\nconst response = await fetch(\"https://api.example.com\");\n\n// Use Response/Request (already available)\nreturn new Response(JSON.stringify(data), {\n  headers: { \"Content-Type\": \"application/json\" },\n});\n```\n\n### Database Options\n\nSince filesystem is unavailable, use cloud databases:\n\n- **Cloudflare D1** — SQLite at the edge\n- **Turso** — Distributed SQLite\n- **PlanetScale** — Serverless MySQL\n- **Supabase** — Postgres with REST API\n- **Neon** — Serverless Postgres\n\nExample with Turso:\n\n```ts\n// app/api/users+api.ts\nimport { createClient } from \"@libsql/client/web\";\n\nconst db = createClient({\n  url: process.env.TURSO_URL!,\n  authToken: process.env.TURSO_AUTH_TOKEN!,\n});\n\nexport async function GET() {\n  const result = await db.execute(\"SELECT * FROM users\");\n  return Response.json(result.rows);\n}\n```\n\n## Calling API Routes from Client\n\n```ts\n// From React Native components\nconst response = await fetch(\"/api/hello\");\nconst data = await response.json();\n\n// With body\nconst response = await fetch(\"/api/users\", {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: JSON.stringify({ name: \"John\" }),\n});\n```\n\n## Common Patterns\n\n### Authentication Middleware\n\n```ts\n// utils/auth.ts\nexport async function requireAuth(request: Request) {\n  const token = request.headers.get(\"Authorization\")?.replace(\"Bearer \", \"\");\n\n  if (!token) {\n    throw new Response(JSON.stringify({ error: \"Unauthorized\" }), {\n      status: 401,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  // Verify token...\n  return { userId: \"123\" };\n}\n\n// app/api/protected+api.ts\nimport { requireAuth } from \"../../utils/auth\";\n\nexport async function GET(request: Request) {\n  const { userId } = await requireAuth(request);\n  return Response.json({ userId });\n}\n```\n\n### Proxy External API\n\n```ts\n// app/api/weather+api.ts\nexport async function GET(request: Request) {\n  const url = new URL(request.url);\n  const city = url.searchParams.get(\"city\");\n\n  const response = await fetch(\n    `https://api.weather.com/v1/current?city=${city}&key=${process.env.WEATHER_API_KEY}`\n  );\n\n  return Response.json(await response.json());\n}\n```\n\n## Rules\n\n- NEVER expose API keys or secrets in client code\n- ALWAYS validate and sanitize user input\n- Use proper HTTP status codes (200, 201, 400, 401, 404, 500)\n- Handle errors gracefully with try/catch\n- Keep API routes focused — one responsibility per endpoint\n- Use TypeScript for type safety\n- Log errors server-side for debugging\n",
        "skills/building-ui/SKILL.md": "---\nname: building-ui\ndescription: Complete guide for building beautiful apps with Expo Router. Covers fundamentals, styling, components, navigation, animations, patterns, and native tabs.\nversion: 1.0.0\nlicense: MIT\n---\n\n# Expo UI Guidelines\n\n## References\n\nConsult these resources as needed:\n\n- ./references/route-structure.md -- Route file conventions, dynamic routes, query parameters, groups, and folder organization\n- ./references/tabs.md -- Native tab bar with NativeTabs, migration from JS tabs, iOS 26 features\n- ./references/icons.md -- SF Symbols with expo-symbols, common icon names, animations, and weights\n- ./references/controls.md -- Native iOS controls: Switch, Slider, SegmentedControl, DateTimePicker, Picker\n- ./references/visual-effects.md -- Blur effects with expo-blur and liquid glass with expo-glass-effect\n- ./references/animations.md -- Reanimated animations: entering, exiting, layout, scroll-driven, and gestures\n- ./references/search.md -- Search bar integration with headers, useSearch hook, and filtering patterns\n- ./references/gradients.md -- CSS gradients using experimental_backgroundImage (New Architecture only)\n- ./references/media.md -- Media handling for Expo Router including camera, audio, video, and file saving\n- ./references/storage.md -- Data storage patterns including SQLite, AsyncStorage, and SecureStore\n- ./references/webgpu-three.md -- 3D graphics, games, and GPU-powered visualizations with WebGPU and Three.js\n\n## Running the App\n\n**CRITICAL: Always try Expo Go first before creating custom builds.**\n\nMost Expo apps work in Expo Go without any custom native code. Before running `npx expo run:ios` or `npx expo run:android`:\n\n1. **Start with Expo Go**: Run `npx expo start` and scan the QR code with Expo Go\n2. **Check if features work**: Test your app thoroughly in Expo Go\n3. **Only create custom builds when required** - see below\n\n### When Custom Builds Are Required\n\nYou need `npx expo run:ios/android` or `eas build` ONLY when using:\n\n- **Local Expo modules** (custom native code in `modules/`)\n- **Apple targets** (widgets, app clips, extensions via `@bacons/apple-targets`)\n- **Third-party native modules** not included in Expo Go\n- **Custom native configuration** that can't be expressed in `app.json`\n\n### When Expo Go Works\n\nExpo Go supports a huge range of features out of the box:\n\n- All `expo-*` packages (camera, location, notifications, etc.)\n- Expo Router navigation\n- Most UI libraries (reanimated, gesture handler, etc.)\n- Push notifications, deep links, and more\n\n**If you're unsure, try Expo Go first.** Creating custom builds adds complexity, slower iteration, and requires Xcode/Android Studio setup.\n\n## Code Style\n\n- Be cautious of unterminated strings. Ensure nested backticks are escaped; never forget to escape quotes correctly.\n- Always use import statements at the top of the file.\n- Always use kebab-case for file names, e.g. `comment-card.tsx`\n- Always remove old route files when moving or restructuring navigation\n- Never use special characters in file names\n- Configure tsconfig.json with path aliases, and prefer aliases over relative imports for refactors.\n\n## Routes\n\nSee `./references/route-structure.md` for detailed route conventions.\n\n- Routes belong in the `app` directory.\n- Never co-locate components, types, or utilities in the app directory. This is an anti-pattern.\n- Ensure the app always has a route that matches \"/\", it may be inside a group route.\n\n## Library Preferences\n\n- Never use modules removed from React Native such as Picker, WebView, SafeAreaView, or AsyncStorage\n- Never use legacy expo-permissions\n- `expo-audio` not `expo-av`\n- `expo-video` not `expo-av`\n- `expo-symbols` not `@expo/vector-icons`\n- `react-native-safe-area-context` not react-native SafeAreaView\n- `process.env.EXPO_OS` not `Platform.OS`\n- `React.use` not `React.useContext`\n- `expo-image` Image component instead of intrinsic element `img`\n- `expo-glass-effect` for liquid glass backdrops\n\n## Responsiveness\n\n- Always wrap root component in a scroll view for responsiveness\n- Use `<ScrollView contentInsetAdjustmentBehavior=\"automatic\" />` instead of `<SafeAreaView>` for smarter safe area insets\n- `contentInsetAdjustmentBehavior=\"automatic\"` should be applied to FlatList and SectionList as well\n- Use flexbox instead of Dimensions API\n- ALWAYS prefer `useWindowDimensions` over `Dimensions.get()` to measure screen size\n\n## Behavior\n\n- Use expo-haptics conditionally on iOS to make more delightful experiences\n- Use views with built-in haptics like `<Switch />` from React Native and `@react-native-community/datetimepicker`\n- When a route belongs to a Stack, its first child should almost always be a ScrollView with `contentInsetAdjustmentBehavior=\"automatic\"` set\n- Prefer `headerSearchBarOptions` in Stack.Screen options to add a search bar\n- Use the `<Text selectable />` prop on text containing data that could be copied\n- Consider formatting large numbers like 1.4M or 38k\n- Never use intrinsic elements like 'img' or 'div' unless in a webview or Expo DOM component\n\n# Styling\n\nFollow Apple Human Interface Guidelines.\n\n## General Styling Rules\n\n- Prefer flex gap over margin and padding styles\n- Prefer padding over margin where possible\n- Always account for safe area, either with stack headers, tabs, or ScrollView/FlatList `contentInsetAdjustmentBehavior=\"automatic\"`\n- Ensure both top and bottom safe area insets are accounted for\n- Inline styles not StyleSheet.create unless reusing styles is faster\n- Add entering and exiting animations for state changes\n- Use `{ borderCurve: 'continuous' }` for rounded corners unless creating a capsule shape\n- ALWAYS use a navigation stack title instead of a custom text element on the page\n- When padding a ScrollView, use `contentContainerStyle` padding and gap instead of padding on the ScrollView itself (reduces clipping)\n- CSS and Tailwind are not supported - use inline styles\n\n## Text Styling\n\n- Add the `selectable` prop to every `<Text/>` element displaying important data or error messages\n- Counters should use `{ fontVariant: 'tabular-nums' }` for alignment\n\n## Shadows\n\nUse CSS `boxShadow` style prop. NEVER use legacy React Native shadow or elevation styles.\n\n```tsx\n<View style={{ boxShadow: \"0 1px 2px rgba(0, 0, 0, 0.05)\" }} />\n```\n\n'inset' shadows are supported.\n\n# Navigation\n\n## Link\n\nUse `<Link href=\"/path\" />` from 'expo-router' for navigation between routes.\n\n```tsx\nimport { Link } from 'expo-router';\n\n// Basic link\n<Link href=\"/path\" />\n\n// Wrapping custom components\n<Link href=\"/path\" asChild>\n  <Pressable>...</Pressable>\n</Link>\n```\n\nWhenever possible, include a `<Link.Preview>` to follow iOS conventions. Add context menus and previews frequently to enhance navigation.\n\n## Stack\n\n- ALWAYS use `_layout.tsx` files to define stacks\n- Use Stack from 'expo-router/stack' for native navigation stacks\n\n### Page Title\n\nSet the page title in Stack.Screen options:\n\n```tsx\n<Stack.Screen options={{ title: \"Home\" }} />\n```\n\n## Context Menus\n\nAdd long press context menus to Link components:\n\n```tsx\nimport { Link } from \"expo-router\";\n\n<Link href=\"/settings\" asChild>\n  <Link.Trigger>\n    <Pressable>\n      <Card />\n    </Pressable>\n  </Link.Trigger>\n  <Link.Menu>\n    <Link.MenuAction\n      title=\"Share\"\n      icon=\"square.and.arrow.up\"\n      onPress={handleSharePress}\n    />\n    <Link.MenuAction\n      title=\"Block\"\n      icon=\"nosign\"\n      destructive\n      onPress={handleBlockPress}\n    />\n    <Link.Menu title=\"More\" icon=\"ellipsis\">\n      <Link.MenuAction title=\"Copy\" icon=\"doc.on.doc\" onPress={() => {}} />\n      <Link.MenuAction\n        title=\"Delete\"\n        icon=\"trash\"\n        destructive\n        onPress={() => {}}\n      />\n    </Link.Menu>\n  </Link.Menu>\n</Link>;\n```\n\n## Link Previews\n\nUse link previews frequently to enhance navigation:\n\n```tsx\n<Link href=\"/settings\">\n  <Link.Trigger>\n    <Pressable>\n      <Card />\n    </Pressable>\n  </Link.Trigger>\n  <Link.Preview />\n</Link>\n```\n\nLink preview can be used with context menus.\n\n## Modal\n\nPresent a screen as a modal:\n\n```tsx\n<Stack.Screen name=\"modal\" options={{ presentation: \"modal\" }} />\n```\n\nPrefer this to building a custom modal component.\n\n## Sheet\n\nPresent a screen as a dynamic form sheet:\n\n```tsx\n<Stack.Screen\n  name=\"sheet\"\n  options={{\n    presentation: \"formSheet\",\n    sheetGrabberVisible: true,\n    sheetAllowedDetents: [0.5, 1.0],\n    contentStyle: { backgroundColor: \"transparent\" },\n  }}\n/>\n```\n\n- Using `contentStyle: { backgroundColor: \"transparent\" }` makes the background liquid glass on iOS 26+.\n\n## Common route structure\n\nA standard app layout with tabs and stacks inside each tab:\n\n```\napp/\n  _layout.tsx — <NativeTabs />\n  (index,search)/\n    _layout.tsx — <Stack />\n    index.tsx — Main list\n    search.tsx — Search view\n```\n\n```tsx\n// app/_layout.tsx\nimport { NativeTabs, Icon, Label } from \"expo-router/unstable-native-tabs\";\nimport { Theme } from \"../components/theme\";\n\nexport default function Layout() {\n  return (\n    <Theme>\n      <NativeTabs>\n        <NativeTabs.Trigger name=\"(index)\">\n          <Icon sf=\"list.dash\" />\n          <Label>Items</Label>\n        </NativeTabs.Trigger>\n        <NativeTabs.Trigger name=\"(search)\" role=\"search\" />\n      </NativeTabs>\n    </Theme>\n  );\n}\n```\n\nCreate a shared group route so both tabs can push common screens:\n\n```tsx\n// app/(index,search)/_layout.tsx\nimport { Stack } from \"expo-router/stack\";\nimport { PlatformColor } from \"react-native\";\n\nexport default function Layout({ segment }) {\n  const screen = segment.match(/\\((.*)\\)/)?.[1]!;\n  const titles: Record<string, string> = { index: \"Items\", search: \"Search\" };\n\n  return (\n    <Stack\n      screenOptions={{\n        headerTransparent: true,\n        headerShadowVisible: false,\n        headerLargeTitleShadowVisible: false,\n        headerLargeStyle: { backgroundColor: \"transparent\" },\n        headerTitleStyle: { color: PlatformColor(\"label\") },\n        headerLargeTitle: true,\n        headerBlurEffect: \"none\",\n        headerBackButtonDisplayMode: \"minimal\",\n      }}\n    >\n      <Stack.Screen name={screen} options={{ title: titles[screen] }} />\n      <Stack.Screen name=\"i/[id]\" options={{ headerLargeTitle: false }} />\n    </Stack>\n  );\n}\n```\n",
        "skills/building-ui/references/animations.md": "# Animations\n\nUse Reanimated v4. Avoid React Native's built-in Animated API.\n\n## Entering and Exiting Animations\n\nUse Animated.View with entering and exiting animations. Layout animations can animate state changes.\n\n```tsx\nimport Animated, {\n  FadeIn,\n  FadeOut,\n  LinearTransition,\n} from \"react-native-reanimated\";\n\nfunction App() {\n  return (\n    <Animated.View\n      entering={FadeIn}\n      exiting={FadeOut}\n      layout={LinearTransition}\n    />\n  );\n}\n```\n\n## On-Scroll Animations\n\nCreate high-performance scroll animations using Reanimated's hooks:\n\n```tsx\nimport Animated, {\n  useAnimatedRef,\n  useScrollViewOffset,\n  useAnimatedStyle,\n  interpolate,\n} from \"react-native-reanimated\";\n\nfunction Page() {\n  const ref = useAnimatedRef();\n  const scroll = useScrollViewOffset(ref);\n\n  const style = useAnimatedStyle(() => ({\n    opacity: interpolate(scroll.value, [0, 30], [0, 1], \"clamp\"),\n  }));\n\n  return (\n    <Animated.ScrollView ref={ref}>\n      <Animated.View style={style} />\n    </Animated.ScrollView>\n  );\n}\n```\n\n## Common Animation Presets\n\n### Entering Animations\n\n- `FadeIn`, `FadeInUp`, `FadeInDown`, `FadeInLeft`, `FadeInRight`\n- `SlideInUp`, `SlideInDown`, `SlideInLeft`, `SlideInRight`\n- `ZoomIn`, `ZoomInUp`, `ZoomInDown`\n- `BounceIn`, `BounceInUp`, `BounceInDown`\n\n### Exiting Animations\n\n- `FadeOut`, `FadeOutUp`, `FadeOutDown`, `FadeOutLeft`, `FadeOutRight`\n- `SlideOutUp`, `SlideOutDown`, `SlideOutLeft`, `SlideOutRight`\n- `ZoomOut`, `ZoomOutUp`, `ZoomOutDown`\n- `BounceOut`, `BounceOutUp`, `BounceOutDown`\n\n### Layout Animations\n\n- `LinearTransition` — Smooth linear interpolation\n- `SequencedTransition` — Sequenced property changes\n- `FadingTransition` — Fade between states\n\n## Customizing Animations\n\n```tsx\n<Animated.View\n  entering={FadeInDown.duration(500).delay(200)}\n  exiting={FadeOut.duration(300)}\n/>\n```\n\n### Modifiers\n\n```tsx\n// Duration in milliseconds\nFadeIn.duration(300);\n\n// Delay before starting\nFadeIn.delay(100);\n\n// Spring physics\nFadeIn.springify();\nFadeIn.springify().damping(15).stiffness(100);\n\n// Easing curves\nFadeIn.easing(Easing.bezier(0.25, 0.1, 0.25, 1));\n\n// Chaining\nFadeInDown.duration(400).delay(200).springify();\n```\n\n## Shared Value Animations\n\nFor imperative control over animations:\n\n```tsx\nimport {\n  useSharedValue,\n  withSpring,\n  withTiming,\n} from \"react-native-reanimated\";\n\nconst offset = useSharedValue(0);\n\n// Spring animation\noffset.value = withSpring(100);\n\n// Timing animation\noffset.value = withTiming(100, { duration: 300 });\n\n// Use in styles\nconst style = useAnimatedStyle(() => ({\n  transform: [{ translateX: offset.value }],\n}));\n```\n\n## Gesture Animations\n\nCombine with React Native Gesture Handler:\n\n```tsx\nimport { Gesture, GestureDetector } from \"react-native-gesture-handler\";\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n} from \"react-native-reanimated\";\n\nfunction DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  const gesture = Gesture.Pan()\n    .onUpdate((e) => {\n      translateX.value = e.translationX;\n      translateY.value = e.translationY;\n    })\n    .onEnd(() => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n\n  const style = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n    ],\n  }));\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, style]} />\n    </GestureDetector>\n  );\n}\n```\n\n## Keyboard Animations\n\nAnimate with keyboard height changes:\n\n```tsx\nimport Animated, {\n  useAnimatedKeyboard,\n  useAnimatedStyle,\n} from \"react-native-reanimated\";\n\nfunction KeyboardAwareView() {\n  const keyboard = useAnimatedKeyboard();\n\n  const style = useAnimatedStyle(() => ({\n    paddingBottom: keyboard.height.value,\n  }));\n\n  return <Animated.View style={style}>{/* content */}</Animated.View>;\n}\n```\n\n## Staggered List Animations\n\nAnimate list items with delays:\n\n```tsx\n{\n  items.map((item, index) => (\n    <Animated.View\n      key={item.id}\n      entering={FadeInUp.delay(index * 50)}\n      exiting={FadeOutUp}\n    >\n      <ListItem item={item} />\n    </Animated.View>\n  ));\n}\n```\n\n## Best Practices\n\n- Add entering and exiting animations for state changes\n- Use layout animations when items are added/removed from lists\n- Use `useAnimatedStyle` for scroll-driven animations\n- Prefer `interpolate` with \"clamp\" for bounded values\n- You can't pass PlatformColors to reanimated views or styles; use static colors instead\n- Keep animations under 300ms for responsive feel\n- Use spring animations for natural movement\n- Avoid animating layout properties (width, height) when possible — prefer transforms\n",
        "skills/building-ui/references/controls.md": "# Native Controls\n\nNative iOS controls provide built-in haptics, accessibility, and platform-appropriate styling.\n\n## Switch\n\nUse for binary on/off settings. Has built-in haptics.\n\n```tsx\nimport { Switch } from \"react-native\";\nimport { useState } from \"react\";\n\nconst [enabled, setEnabled] = useState(false);\n\n<Switch value={enabled} onValueChange={setEnabled} />;\n```\n\n### Customization\n\n```tsx\n<Switch\n  value={enabled}\n  onValueChange={setEnabled}\n  trackColor={{ false: \"#767577\", true: \"#81b0ff\" }}\n  thumbColor={enabled ? \"#f5dd4b\" : \"#f4f3f4\"}\n  ios_backgroundColor=\"#3e3e3e\"\n/>\n```\n\n## Segmented Control\n\nUse for non-navigational tabs or mode selection. Avoid changing default colors.\n\n```tsx\nimport SegmentedControl from \"@react-native-segmented-control/segmented-control\";\nimport { useState } from \"react\";\n\nconst [index, setIndex] = useState(0);\n\n<SegmentedControl\n  values={[\"All\", \"Active\", \"Done\"]}\n  selectedIndex={index}\n  onChange={({ nativeEvent }) => setIndex(nativeEvent.selectedSegmentIndex)}\n/>;\n```\n\n### Rules\n\n- Maximum 4 options — use a picker for more\n- Keep labels short (1-2 words)\n- Avoid custom colors — native styling adapts to dark mode\n\n### With Icons (iOS 14+)\n\n```tsx\n<SegmentedControl\n  values={[\n    { label: \"List\", icon: \"list.bullet\" },\n    { label: \"Grid\", icon: \"square.grid.2x2\" },\n  ]}\n  selectedIndex={index}\n  onChange={({ nativeEvent }) => setIndex(nativeEvent.selectedSegmentIndex)}\n/>\n```\n\n## Slider\n\nContinuous value selection.\n\n```tsx\nimport Slider from \"@react-native-community/slider\";\nimport { useState } from \"react\";\n\nconst [value, setValue] = useState(0.5);\n\n<Slider\n  value={value}\n  onValueChange={setValue}\n  minimumValue={0}\n  maximumValue={1}\n/>;\n```\n\n### Customization\n\n```tsx\n<Slider\n  value={value}\n  onValueChange={setValue}\n  minimumValue={0}\n  maximumValue={100}\n  step={1}\n  minimumTrackTintColor=\"#007AFF\"\n  maximumTrackTintColor=\"#E5E5EA\"\n  thumbTintColor=\"#007AFF\"\n/>\n```\n\n### Discrete Steps\n\n```tsx\n<Slider\n  value={value}\n  onValueChange={setValue}\n  minimumValue={0}\n  maximumValue={10}\n  step={1}\n/>\n```\n\n## Date/Time Picker\n\nCompact pickers with popovers. Has built-in haptics.\n\n```tsx\nimport DateTimePicker from \"@react-native-community/datetimepicker\";\nimport { useState } from \"react\";\n\nconst [date, setDate] = useState(new Date());\n\n<DateTimePicker\n  value={date}\n  onChange={(event, selectedDate) => {\n    if (selectedDate) setDate(selectedDate);\n  }}\n  mode=\"datetime\"\n/>;\n```\n\n### Modes\n\n- `date` — Date only\n- `time` — Time only\n- `datetime` — Date and time\n\n### Display Styles\n\n```tsx\n// Compact inline (default)\n<DateTimePicker value={date} mode=\"date\" />\n\n// Spinner wheel\n<DateTimePicker\n  value={date}\n  mode=\"date\"\n  display=\"spinner\"\n  style={{ width: 200, height: 150 }}\n/>\n\n// Full calendar\n<DateTimePicker value={date} mode=\"date\" display=\"inline\" />\n```\n\n### Time Intervals\n\n```tsx\n<DateTimePicker\n  value={date}\n  mode=\"time\"\n  minuteInterval={15}\n/>\n```\n\n### Min/Max Dates\n\n```tsx\n<DateTimePicker\n  value={date}\n  mode=\"date\"\n  minimumDate={new Date(2020, 0, 1)}\n  maximumDate={new Date(2030, 11, 31)}\n/>\n```\n\n## Stepper\n\nIncrement/decrement numeric values.\n\n```tsx\nimport { Stepper } from \"react-native\";\nimport { useState } from \"react\";\n\nconst [count, setCount] = useState(0);\n\n<Stepper\n  value={count}\n  onValueChange={setCount}\n  minimumValue={0}\n  maximumValue={10}\n/>;\n```\n\n## TextInput\n\nNative text input with various keyboard types.\n\n```tsx\nimport { TextInput } from \"react-native\";\n\n<TextInput\n  placeholder=\"Enter text...\"\n  placeholderTextColor=\"#999\"\n  style={{\n    padding: 12,\n    fontSize: 16,\n    borderRadius: 8,\n    backgroundColor: \"#f0f0f0\",\n  }}\n/>\n```\n\n### Keyboard Types\n\n```tsx\n// Email\n<TextInput keyboardType=\"email-address\" autoCapitalize=\"none\" />\n\n// Phone\n<TextInput keyboardType=\"phone-pad\" />\n\n// Number\n<TextInput keyboardType=\"numeric\" />\n\n// Password\n<TextInput secureTextEntry />\n\n// Search\n<TextInput\n  returnKeyType=\"search\"\n  enablesReturnKeyAutomatically\n/>\n```\n\n### Multiline\n\n```tsx\n<TextInput\n  multiline\n  numberOfLines={4}\n  textAlignVertical=\"top\"\n  style={{ minHeight: 100 }}\n/>\n```\n\n## Picker (Wheel)\n\nFor selection from many options (5+ items).\n\n```tsx\nimport { Picker } from \"@react-native-picker/picker\";\nimport { useState } from \"react\";\n\nconst [selected, setSelected] = useState(\"js\");\n\n<Picker selectedValue={selected} onValueChange={setSelected}>\n  <Picker.Item label=\"JavaScript\" value=\"js\" />\n  <Picker.Item label=\"TypeScript\" value=\"ts\" />\n  <Picker.Item label=\"Python\" value=\"py\" />\n  <Picker.Item label=\"Go\" value=\"go\" />\n</Picker>;\n```\n\n## Best Practices\n\n- **Haptics**: Switch and DateTimePicker have built-in haptics — don't add extra\n- **Accessibility**: Native controls have proper accessibility labels by default\n- **Dark Mode**: Avoid custom colors — native styling adapts automatically\n- **Spacing**: Use consistent padding around controls (12-16pt)\n- **Labels**: Place labels above or to the left of controls\n- **Grouping**: Group related controls in sections with headers\n",
        "skills/building-ui/references/form-sheet.md": "# Form Sheets in Expo Router\n\nThis skill covers implementing form sheets with footers using Expo Router's Stack navigator and react-native-screens.\n\n## Overview\n\nForm sheets are modal presentations that appear as a card sliding up from the bottom of the screen. They're ideal for:\n\n- Quick actions and confirmations\n- Settings panels\n- Login/signup flows\n- Action sheets with custom content\n\n**Requirements:**\n\n- Expo Router Stack navigator\n\n## Basic Usage\n\n### Form Sheet with Footer\n\nConfigure the Stack.Screen with transparent backgrounds and sheet presentation:\n\n```tsx\n// app/_layout.tsx\nimport { Stack } from \"expo-router\";\n\nexport default function Layout() {\n  return (\n    <Stack>\n      <Stack.Screen name=\"index\" />\n      <Stack.Screen\n        name=\"about\"\n        options={{\n          presentation: \"formSheet\",\n          sheetAllowedDetents: [0.25],\n          headerTransparent: true,\n          contentStyle: { backgroundColor: \"transparent\" },\n          sheetGrabberVisible: true,\n        }}\n      >\n        <Stack.Header style={{ backgroundColor: \"transparent\" }}></Stack.Header>\n      </Stack.Screen>\n    </Stack>\n  );\n}\n```\n\n### Form Sheet Screen Content\n\n> Requires Expo SDK 55 or later.\n\nUse `flex: 1` to allow the content to fill available space, enabling footer positioning:\n\n```tsx\n// app/about.tsx\nimport { View, Text, StyleSheet } from \"react-native\";\n\nexport default function AboutSheet() {\n  return (\n    <View style={styles.container}>\n      {/* Main content */}\n      <View style={styles.content}>\n        <Text>Sheet Content</Text>\n      </View>\n\n      {/* Footer - stays at bottom */}\n      <View style={styles.footer}>\n        <Text>Footer Content</Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    padding: 16,\n  },\n  footer: {\n    padding: 16,\n  },\n});\n```\n\n## Key Options\n\n| Option                | Type       | Description                                                 |\n| --------------------- | ---------- | ----------------------------------------------------------- |\n| `presentation`        | `string`   | Set to `'formSheet'` for sheet presentation                 |\n| `sheetGrabberVisible` | `boolean`  | Shows the drag handle at the top of the sheet               |\n| `sheetAllowedDetents` | `number[]` | Array of detent heights (0-1 range, e.g., `[0.25]` for 25%) |\n| `headerTransparent`   | `boolean`  | Makes header background transparent                         |\n| `contentStyle`        | `object`   | Style object for the screen content container               |\n| `title`               | `string`   | Screen title (set to `''` for no title)                     |\n\n## Common Detent Values\n\n- `[0.25]` - Quarter sheet (compact actions)\n- `[0.5]` - Half sheet (medium content)\n- `[0.75]` - Three-quarter sheet (detailed forms)\n- `[0.25, 0.5, 1]` - Multiple stops (expandable sheet)\n\n## Complete Example\n\n```tsx\n// _layout.tsx\nimport { Stack } from \"expo-router\";\n\nexport default function Layout() {\n  return (\n    <Stack>\n      <Stack.Screen name=\"index\" options={{ title: \"Home\" }} />\n      <Stack.Screen\n        name=\"confirm\"\n        options={{\n          contentStyle: { backgroundColor: \"transparent\" },\n          presentation: \"formSheet\",\n          title: \"\",\n          sheetGrabberVisible: true,\n          sheetAllowedDetents: [0.25],\n          headerTransparent: true,\n        }}\n      >\n        <Stack.Header style={{ backgroundColor: \"transparent\" }}>\n          <Stack.Header.Right />\n        </Stack.Header>\n      </Stack.Screen>\n    </Stack>\n  );\n}\n```\n\n```tsx\n// app/confirm.tsx\nimport { View, Text, Pressable, StyleSheet } from \"react-native\";\nimport { router } from \"expo-router\";\n\nexport default function ConfirmSheet() {\n  return (\n    <View style={styles.container}>\n      <View style={styles.content}>\n        <Text style={styles.title}>Confirm Action</Text>\n        <Text style={styles.description}>\n          Are you sure you want to proceed?\n        </Text>\n      </View>\n\n      <View style={styles.footer}>\n        <Pressable style={styles.cancelButton} onPress={() => router.back()}>\n          <Text style={styles.cancelText}>Cancel</Text>\n        </Pressable>\n        <Pressable style={styles.confirmButton} onPress={() => router.back()}>\n          <Text style={styles.confirmText}>Confirm</Text>\n        </Pressable>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    padding: 20,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    marginBottom: 8,\n  },\n  description: {\n    fontSize: 14,\n    color: \"#666\",\n    textAlign: \"center\",\n  },\n  footer: {\n    flexDirection: \"row\",\n    padding: 16,\n    gap: 12,\n  },\n  cancelButton: {\n    flex: 1,\n    padding: 14,\n    borderRadius: 10,\n    backgroundColor: \"#f0f0f0\",\n    alignItems: \"center\",\n  },\n  cancelText: {\n    fontSize: 16,\n    fontWeight: \"500\",\n  },\n  confirmButton: {\n    flex: 1,\n    padding: 14,\n    borderRadius: 10,\n    backgroundColor: \"#007AFF\",\n    alignItems: \"center\",\n  },\n  confirmText: {\n    fontSize: 16,\n    fontWeight: \"500\",\n    color: \"white\",\n  },\n});\n```\n\n## Troubleshooting\n\n### Content not filling sheet\n\nMake sure the root View uses `flex: 1`:\n\n```tsx\n<View style={{ flex: 1 }}>{/* content */}</View>\n```\n\n### Sheet background showing through\n\nSet `contentStyle: { backgroundColor: 'transparent' }` in options and style your content container with the desired background color instead.\n",
        "skills/building-ui/references/gradients.md": "# CSS Gradients\n\n> **New Architecture Only**: CSS gradients require React Native's New Architecture (Fabric). They are not available in the old architecture or Expo Go.\n\nUse CSS gradients with the `experimental_backgroundImage` style property.\n\n## Linear Gradients\n\n```tsx\n// Top to bottom\n<View style={{\n  experimental_backgroundImage: 'linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%)'\n}} />\n\n// Left to right\n<View style={{\n  experimental_backgroundImage: 'linear-gradient(to right, #ff0000 0%, #0000ff 100%)'\n}} />\n\n// Diagonal\n<View style={{\n  experimental_backgroundImage: 'linear-gradient(45deg, #ff0000 0%, #00ff00 50%, #0000ff 100%)'\n}} />\n\n// Using degrees\n<View style={{\n  experimental_backgroundImage: 'linear-gradient(135deg, transparent 0%, black 100%)'\n}} />\n```\n\n## Radial Gradients\n\n```tsx\n// Circle at center\n<View style={{\n  experimental_backgroundImage: 'radial-gradient(circle at center, rgba(255, 0, 0, 1) 0%, rgba(0, 0, 255, 1) 100%)'\n}} />\n\n// Ellipse\n<View style={{\n  experimental_backgroundImage: 'radial-gradient(ellipse at center, #fff 0%, #000 100%)'\n}} />\n\n// Positioned\n<View style={{\n  experimental_backgroundImage: 'radial-gradient(circle at top left, #ff0000 0%, transparent 70%)'\n}} />\n```\n\n## Multiple Gradients\n\nStack multiple gradients by comma-separating them:\n\n```tsx\n<View style={{\n  experimental_backgroundImage: `\n    linear-gradient(to bottom, transparent 0%, black 100%),\n    radial-gradient(circle at top right, rgba(255, 0, 0, 0.5) 0%, transparent 50%)\n  `\n}} />\n```\n\n## Common Patterns\n\n### Overlay on Image\n\n```tsx\n<View style={{ position: 'relative' }}>\n  <Image source={{ uri: '...' }} style={{ width: '100%', height: 200 }} />\n  <View style={{\n    position: 'absolute',\n    inset: 0,\n    experimental_backgroundImage: 'linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, transparent 50%)'\n  }} />\n</View>\n```\n\n### Frosted Glass Effect\n\n```tsx\n<View style={{\n  experimental_backgroundImage: 'linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%)',\n  backdropFilter: 'blur(10px)',\n}} />\n```\n\n### Button Gradient\n\n```tsx\n<Pressable style={{\n  experimental_backgroundImage: 'linear-gradient(to bottom, #4CAF50 0%, #388E3C 100%)',\n  padding: 16,\n  borderRadius: 8,\n}}>\n  <Text style={{ color: 'white', textAlign: 'center' }}>Submit</Text>\n</Pressable>\n```\n\n## Important Notes\n\n- Do NOT use `expo-linear-gradient` — use CSS gradients instead\n- Gradients are strings, not objects\n- Use `rgba()` for transparency, or `transparent` keyword\n- Color stops use percentages (0%, 50%, 100%)\n- Direction keywords: `to top`, `to bottom`, `to left`, `to right`, `to top left`, etc.\n- Degree values: `45deg`, `90deg`, `135deg`, etc.\n",
        "skills/building-ui/references/icons.md": "# Icons (SF Symbols)\n\nUse SF Symbols for native feel. Never use FontAwesome or Ionicons.\n\n## Basic Usage\n\n```tsx\nimport { SymbolView } from \"expo-symbols\";\nimport { PlatformColor } from \"react-native\";\n\n<SymbolView\n  tintColor={PlatformColor(\"label\")}\n  resizeMode=\"scaleAspectFit\"\n  name=\"square.and.arrow.down\"\n  style={{ width: 16, height: 16 }}\n/>;\n```\n\n## Props\n\n```tsx\n<SymbolView\n  name=\"star.fill\"                    // SF Symbol name (required)\n  tintColor={PlatformColor(\"label\")}  // Icon color\n  size={24}                           // Shorthand for width/height\n  resizeMode=\"scaleAspectFit\"         // How to scale\n  weight=\"regular\"                    // thin | ultraLight | light | regular | medium | semibold | bold | heavy | black\n  scale=\"medium\"                      // small | medium | large\n  style={{ width: 16, height: 16 }}   // Standard style props\n/>\n```\n\n## Common Icons\n\n### Navigation & Actions\n- `house.fill` - home\n- `gear` - settings\n- `magnifyingglass` - search\n- `plus` - add\n- `xmark` - close\n- `chevron.left` - back\n- `chevron.right` - forward\n- `arrow.left` - back arrow\n- `arrow.right` - forward arrow\n\n### Media\n- `play.fill` - play\n- `pause.fill` - pause\n- `stop.fill` - stop\n- `backward.fill` - rewind\n- `forward.fill` - fast forward\n- `speaker.wave.2.fill` - volume\n- `speaker.slash.fill` - mute\n\n### Camera\n- `camera` - camera\n- `camera.fill` - camera filled\n- `arrow.triangle.2.circlepath` - flip camera\n- `photo` - gallery/photos\n- `bolt` - flash\n- `bolt.slash` - flash off\n\n### Communication\n- `message` - message\n- `message.fill` - message filled\n- `envelope` - email\n- `envelope.fill` - email filled\n- `phone` - phone\n- `phone.fill` - phone filled\n- `video` - video call\n- `video.fill` - video call filled\n\n### Social\n- `heart` - like\n- `heart.fill` - liked\n- `star` - favorite\n- `star.fill` - favorited\n- `hand.thumbsup` - thumbs up\n- `hand.thumbsdown` - thumbs down\n- `person` - profile\n- `person.fill` - profile filled\n- `person.2` - people\n- `person.2.fill` - people filled\n\n### Content Actions\n- `square.and.arrow.up` - share\n- `square.and.arrow.down` - download\n- `doc.on.doc` - copy\n- `trash` - delete\n- `pencil` - edit\n- `folder` - folder\n- `folder.fill` - folder filled\n- `bookmark` - bookmark\n- `bookmark.fill` - bookmarked\n\n### Status & Feedback\n- `checkmark` - success/done\n- `checkmark.circle.fill` - completed\n- `xmark.circle.fill` - error/failed\n- `exclamationmark.triangle` - warning\n- `info.circle` - info\n- `questionmark.circle` - help\n- `bell` - notification\n- `bell.fill` - notification filled\n\n### Misc\n- `ellipsis` - more options\n- `ellipsis.circle` - more in circle\n- `line.3.horizontal` - menu/hamburger\n- `slider.horizontal.3` - filters\n- `arrow.clockwise` - refresh\n- `location` - location\n- `location.fill` - location filled\n- `map` - map\n- `mappin` - pin\n- `clock` - time\n- `calendar` - calendar\n- `link` - link\n- `nosign` - block/prohibited\n\n## Animated Symbols\n\n```tsx\n<SymbolView\n  name=\"checkmark.circle\"\n  animationSpec={{\n    effect: {\n      type: \"bounce\",\n      direction: \"up\",\n    },\n  }}\n/>\n```\n\n### Animation Effects\n\n- `bounce` - Bouncy animation\n- `pulse` - Pulsing effect\n- `variableColor` - Color cycling\n- `scale` - Scale animation\n\n```tsx\n// Bounce with direction\nanimationSpec={{\n  effect: { type: \"bounce\", direction: \"up\" }  // up | down\n}}\n\n// Pulse\nanimationSpec={{\n  effect: { type: \"pulse\" }\n}}\n\n// Variable color (multicolor symbols)\nanimationSpec={{\n  effect: {\n    type: \"variableColor\",\n    cumulative: true,\n    reversing: true\n  }\n}}\n```\n\n## Symbol Weights\n\n```tsx\n// Lighter weights\n<SymbolView name=\"star\" weight=\"ultraLight\" />\n<SymbolView name=\"star\" weight=\"thin\" />\n<SymbolView name=\"star\" weight=\"light\" />\n\n// Default\n<SymbolView name=\"star\" weight=\"regular\" />\n\n// Heavier weights\n<SymbolView name=\"star\" weight=\"medium\" />\n<SymbolView name=\"star\" weight=\"semibold\" />\n<SymbolView name=\"star\" weight=\"bold\" />\n<SymbolView name=\"star\" weight=\"heavy\" />\n<SymbolView name=\"star\" weight=\"black\" />\n```\n\n## Symbol Scales\n\n```tsx\n<SymbolView name=\"star\" scale=\"small\" />\n<SymbolView name=\"star\" scale=\"medium\" />  // default\n<SymbolView name=\"star\" scale=\"large\" />\n```\n\n## Multicolor Symbols\n\nSome symbols support multiple colors:\n\n```tsx\n<SymbolView\n  name=\"cloud.sun.rain.fill\"\n  type=\"multicolor\"\n/>\n```\n\n## Finding Symbol Names\n\n1. Use the SF Symbols app on macOS (free from Apple)\n2. Search at https://developer.apple.com/sf-symbols/\n3. Symbol names use dot notation: `square.and.arrow.up`\n\n## Best Practices\n\n- Always use SF Symbols over vector icon libraries\n- Match symbol weight to nearby text weight\n- Use `.fill` variants for selected/active states\n- Use PlatformColor for tint to support dark mode\n- Keep icons at consistent sizes (16, 20, 24, 32)\n",
        "skills/building-ui/references/media.md": "# Media\n\n## Camera\n\n- Hide navigation headers when there's a full screen camera\n- Ensure to flip the camera with `mirror` to emulate social apps\n- Use liquid glass buttons on cameras\n- Icons: `arrow.triangle.2.circlepath` (flip), `photo` (gallery), `bolt` (flash)\n- Eagerly request camera permission\n- Lazily request media library permission\n\n```tsx\nimport React, { useRef, useState } from \"react\";\nimport { View, TouchableOpacity, Text, Alert } from \"react-native\";\nimport { CameraView, CameraType, useCameraPermissions } from \"expo-camera\";\nimport * as MediaLibrary from \"expo-media-library\";\nimport * as ImagePicker from \"expo-image-picker\";\nimport * as Haptics from \"expo-haptics\";\nimport { SymbolView } from \"expo-symbols\";\nimport { PlatformColor } from \"react-native\";\nimport { GlassView } from \"expo-glass-effect\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\n\nfunction Camera({ onPicture }: { onPicture: (uri: string) => Promise<void> }) {\n  const [permission, requestPermission] = useCameraPermissions();\n  const cameraRef = useRef<CameraView>(null);\n  const [type, setType] = useState<CameraType>(\"back\");\n  const { bottom } = useSafeAreaInsets();\n\n  if (!permission?.granted) {\n    return (\n      <View style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\", backgroundColor: PlatformColor(\"systemBackground\") }}>\n        <Text style={{ color: PlatformColor(\"label\"), padding: 16 }}>Camera access is required</Text>\n        <GlassView isInteractive tintColor={PlatformColor(\"systemBlue\")} style={{ borderRadius: 12 }}>\n          <TouchableOpacity onPress={requestPermission} style={{ padding: 12, borderRadius: 12 }}>\n            <Text style={{ color: \"white\" }}>Grant Permission</Text>\n          </TouchableOpacity>\n        </GlassView>\n      </View>\n    );\n  }\n\n  const takePhoto = async () => {\n    await Haptics.selectionAsync();\n    if (!cameraRef.current) return;\n    const photo = await cameraRef.current.takePictureAsync({ quality: 0.8 });\n    await onPicture(photo.uri);\n  };\n\n  const selectPhoto = async () => {\n    await Haptics.selectionAsync();\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: \"images\",\n      allowsEditing: false,\n      quality: 0.8,\n    });\n    if (!result.canceled && result.assets?.[0]) {\n      await onPicture(result.assets[0].uri);\n    }\n  };\n\n  return (\n    <View style={{ flex: 1, backgroundColor: \"black\" }}>\n      <CameraView ref={cameraRef} mirror style={{ flex: 1 }} facing={type} />\n      <View style={{ position: \"absolute\", left: 0, right: 0, bottom: bottom, gap: 16, alignItems: \"center\" }}>\n        <GlassView isInteractive style={{ padding: 8, borderRadius: 99 }}>\n          <TouchableOpacity onPress={takePhoto} style={{ width: 64, height: 64, borderRadius: 99, backgroundColor: \"white\" }} />\n        </GlassView>\n        <View style={{ flexDirection: \"row\", justifyContent: \"space-around\", paddingHorizontal: 8 }}>\n          <GlassButton onPress={selectPhoto} icon=\"photo\" />\n          <GlassButton onPress={() => setType(t => t === \"back\" ? \"front\" : \"back\")} icon=\"arrow.triangle.2.circlepath\" />\n        </View>\n      </View>\n    </View>\n  );\n}\n```\n\n## Audio Playback\n\nUse `expo-audio` not `expo-av`:\n\n```tsx\nimport { useAudioPlayer } from 'expo-audio';\n\nconst player = useAudioPlayer({ uri: 'https://stream.nightride.fm/rektory.mp3' });\n\n<Button title=\"Play\" onPress={() => player.play()} />\n```\n\n## Audio Recording (Microphone)\n\n```tsx\nimport {\n  useAudioRecorder,\n  AudioModule,\n  RecordingPresets,\n  setAudioModeAsync,\n  useAudioRecorderState,\n} from 'expo-audio';\nimport { useEffect } from 'react';\nimport { Alert, Button } from 'react-native';\n\nfunction App() {\n  const audioRecorder = useAudioRecorder(RecordingPresets.HIGH_QUALITY);\n  const recorderState = useAudioRecorderState(audioRecorder);\n\n  const record = async () => {\n    await audioRecorder.prepareToRecordAsync();\n    audioRecorder.record();\n  };\n\n  const stop = () => audioRecorder.stop();\n\n  useEffect(() => {\n    (async () => {\n      const status = await AudioModule.requestRecordingPermissionsAsync();\n      if (status.granted) {\n        setAudioModeAsync({ playsInSilentMode: true, allowsRecording: true });\n      } else {\n        Alert.alert('Permission to access microphone was denied');\n      }\n    })();\n  }, []);\n\n  return (\n    <Button\n      title={recorderState.isRecording ? 'Stop' : 'Start'}\n      onPress={recorderState.isRecording ? stop : record}\n    />\n  );\n}\n```\n\n## Video Playback\n\nUse `expo-video` not `expo-av`:\n\n```tsx\nimport { useVideoPlayer, VideoView } from 'expo-video';\nimport { useEvent } from 'expo';\n\nconst videoSource = 'https://example.com/video.mp4';\n\nconst player = useVideoPlayer(videoSource, player => {\n  player.loop = true;\n  player.play();\n});\n\nconst { isPlaying } = useEvent(player, 'playingChange', { isPlaying: player.playing });\n\n<VideoView player={player} fullscreenOptions={{}} allowsPictureInPicture />\n```\n\nVideoView options:\n- `allowsPictureInPicture`: boolean\n- `contentFit`: 'contain' | 'cover' | 'fill'\n- `nativeControls`: boolean\n- `playsInline`: boolean\n- `startsPictureInPictureAutomatically`: boolean\n\n## Saving Media\n\n```tsx\nimport * as MediaLibrary from \"expo-media-library\";\n\nconst { granted } = await MediaLibrary.requestPermissionsAsync();\nif (granted) {\n  await MediaLibrary.saveToLibraryAsync(uri);\n}\n```\n\n### Saving Base64 Images\n\n`MediaLibrary.saveToLibraryAsync` only accepts local file paths. Save base64 strings to disk first:\n\n```tsx\nimport { File, Paths } from \"expo-file-system/next\";\n\nfunction base64ToLocalUri(base64: string, filename?: string) {\n  if (!filename) {\n    const match = base64.match(/^data:(image\\/[a-zA-Z]+);base64,/);\n    const ext = match ? match[1].split(\"/\")[1] : \"jpg\";\n    filename = `generated-${Date.now()}.${ext}`;\n  }\n\n  if (base64.startsWith(\"data:\")) base64 = base64.split(\",\")[1];\n  const binaryString = atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(new ArrayBuffer(len));\n  for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);\n\n  const f = new File(Paths.cache, filename);\n  f.create({ overwrite: true });\n  f.write(bytes);\n  return f.uri;\n}\n```\n",
        "skills/building-ui/references/route-structure.md": "# Route Structure\n\n## File Conventions\n\n- Routes belong in the `app` directory\n- Use `[]` for dynamic routes, e.g. `[id].tsx`\n- Routes can never be named `(foo).tsx` - use `(foo)/index.tsx` instead\n- Use `(group)` routes to simplify the public URL structure\n- NEVER co-locate components, types, or utilities in the app directory - these should be in separate directories like `components/`, `utils/`, etc.\n- The app directory should only contain route and `_layout` files; every file should export a default component\n- Ensure the app always has a route that matches \"/\" so the app is never blank\n- ALWAYS use `_layout.tsx` files to define stacks\n\n## Dynamic Routes\n\nUse square brackets for dynamic segments:\n\n```\napp/\n  users/\n    [id].tsx        # Matches /users/123, /users/abc\n    [id]/\n      posts.tsx     # Matches /users/123/posts\n```\n\n### Catch-All Routes\n\nUse `[...slug]` for catch-all routes:\n\n```\napp/\n  docs/\n    [...slug].tsx   # Matches /docs/a, /docs/a/b, /docs/a/b/c\n```\n\n## Query Parameters\n\nAccess query parameters with the `useLocalSearchParams` hook:\n\n```tsx\nimport { useLocalSearchParams } from \"expo-router\";\n\nfunction Page() {\n  const { id } = useLocalSearchParams<{ id: string }>();\n}\n```\n\nFor dynamic routes, the parameter name matches the file name:\n\n- `[id].tsx` → `useLocalSearchParams<{ id: string }>()`\n- `[slug].tsx` → `useLocalSearchParams<{ slug: string }>()`\n\n## Pathname\n\nAccess the current pathname with the `usePathname` hook:\n\n```tsx\nimport { usePathname } from \"expo-router\";\n\nfunction Component() {\n  const pathname = usePathname(); // e.g. \"/users/123\"\n}\n```\n\n## Group Routes\n\nUse parentheses for groups that don't affect the URL:\n\n```\napp/\n  (auth)/\n    login.tsx       # URL: /login\n    register.tsx    # URL: /register\n  (main)/\n    index.tsx       # URL: /\n    settings.tsx    # URL: /settings\n```\n\nGroups are useful for:\n\n- Organizing related routes\n- Applying different layouts to route groups\n- Keeping URLs clean\n\n## Stacks and Tabs Structure\n\nWhen an app has tabs, the header and title should be set in a Stack that is nested INSIDE each tab. This allows tabs to have their own headers and distinct histories. The root layout should often not have a header.\n\n- Set the 'headerShown' option to false on the tab layout\n- Use (group) routes to simplify the public URL structure\n- You may need to delete or refactor existing routes to fit this structure\n\nExample structure:\n\n```\napp/\n  _layout.tsx — <Tabs />\n  (home)/\n    _layout.tsx — <Stack />\n    index.tsx — <ScrollView />\n  (settings)/\n    _layout.tsx — <Stack />\n    index.tsx — <ScrollView />\n  (home,settings)/\n    info.tsx — <ScrollView /> (shared across tabs)\n```\n\n## Array Routes for Multiple Stacks\n\nUse array routes '(index,settings)' to create multiple stacks. This is useful for tabs that need to share screens across stacks.\n\n```\napp/\n  _layout.tsx — <Tabs />\n  (index,settings)/\n    _layout.tsx — <Stack />\n    index.tsx — <ScrollView />\n    settings.tsx — <ScrollView />\n```\n\nThis requires a specialized layout with explicit anchor routes:\n\n```tsx\n// app/(index,settings)/_layout.tsx\nimport { useMemo } from \"react\";\nimport Stack from \"expo-router/stack\";\n\nexport const unstable_settings = {\n  index: { anchor: \"index\" },\n  settings: { anchor: \"settings\" },\n};\n\nexport default function Layout({ segment }: { segment: string }) {\n  const screen = segment.match(/\\((.*)\\)/)?.[1]!;\n\n  const options = useMemo(() => {\n    switch (screen) {\n      case \"index\":\n        return { headerRight: () => <></> };\n      default:\n        return {};\n    }\n  }, [screen]);\n\n  return (\n    <Stack>\n      <Stack.Screen name={screen} options={options} />\n    </Stack>\n  );\n}\n```\n\n## Complete App Structure Example\n\n```\napp/\n  _layout.tsx — <NativeTabs />\n  (index,search)/\n    _layout.tsx — <Stack />\n    index.tsx — Main list\n    search.tsx — Search view\n    i/[id].tsx — Detail page\ncomponents/\n  theme.tsx\n  list.tsx\nutils/\n  storage.ts\n  use-search.ts\n```\n\n## Layout Files\n\nEvery directory can have a `_layout.tsx` file that wraps all routes in that directory:\n\n```tsx\n// app/_layout.tsx\nimport { Stack } from \"expo-router/stack\";\n\nexport default function RootLayout() {\n  return <Stack />;\n}\n```\n\n```tsx\n// app/(tabs)/_layout.tsx\nimport { NativeTabs, Icon, Label } from \"expo-router/unstable-native-tabs\";\n\nexport default function TabLayout() {\n  return (\n    <NativeTabs>\n      <NativeTabs.Trigger name=\"index\">\n        <Label>Home</Label>\n        <Icon sf=\"house.fill\" />\n      </NativeTabs.Trigger>\n    </NativeTabs>\n  );\n}\n```\n\n## Route Settings\n\nExport `unstable_settings` to configure route behavior:\n\n```tsx\nexport const unstable_settings = {\n  anchor: \"index\",\n};\n```\n\n- `initialRouteName` was renamed to `anchor` in v4\n\n## Not Found Routes\n\nCreate a `+not-found.tsx` file to handle unmatched routes:\n\n```tsx\n// app/+not-found.tsx\nimport { Link } from \"expo-router\";\nimport { View, Text } from \"react-native\";\n\nexport default function NotFound() {\n  return (\n    <View>\n      <Text>Page not found</Text>\n      <Link href=\"/\">Go home</Link>\n    </View>\n  );\n}\n```\n",
        "skills/building-ui/references/search.md": "# Search\n\n## Header Search Bar\n\nAdd a search bar to the stack header with `headerSearchBarOptions`:\n\n```tsx\n<Stack.Screen\n  name=\"index\"\n  options={{\n    headerSearchBarOptions: {\n      placeholder: \"Search\",\n      onChangeText: (event) => console.log(event.nativeEvent.text),\n    },\n  }}\n/>\n```\n\n### Options\n\n```tsx\nheaderSearchBarOptions: {\n  // Placeholder text\n  placeholder: \"Search items...\",\n\n  // Auto-capitalize behavior\n  autoCapitalize: \"none\",\n\n  // Input type\n  inputType: \"text\", // \"text\" | \"phone\" | \"number\" | \"email\"\n\n  // Cancel button text (iOS)\n  cancelButtonText: \"Cancel\",\n\n  // Hide when scrolling (iOS)\n  hideWhenScrolling: true,\n\n  // Hide navigation bar during search (iOS)\n  hideNavigationBar: true,\n\n  // Obscure background during search (iOS)\n  obscureBackground: true,\n\n  // Placement\n  placement: \"automatic\", // \"automatic\" | \"inline\" | \"stacked\"\n\n  // Callbacks\n  onChangeText: (event) => {},\n  onSearchButtonPress: (event) => {},\n  onCancelButtonPress: (event) => {},\n  onFocus: () => {},\n  onBlur: () => {},\n}\n```\n\n## useSearch Hook\n\nReusable hook for search state management:\n\n```tsx\nimport { useEffect, useState } from \"react\";\nimport { useNavigation } from \"expo-router\";\n\nexport function useSearch(options: any = {}) {\n  const [search, setSearch] = useState(\"\");\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    navigation.setOptions({\n      headerShown: true,\n      headerSearchBarOptions: {\n        ...options,\n        onChangeText(e: any) {\n          setSearch(e.nativeEvent.text);\n          options.onChangeText?.(e);\n        },\n        onSearchButtonPress(e: any) {\n          setSearch(e.nativeEvent.text);\n          options.onSearchButtonPress?.(e);\n        },\n        onCancelButtonPress(e: any) {\n          setSearch(\"\");\n          options.onCancelButtonPress?.(e);\n        },\n      },\n    });\n  }, [options, navigation]);\n\n  return search;\n}\n```\n\n### Usage\n\n```tsx\nfunction SearchScreen() {\n  const search = useSearch({ placeholder: \"Search items...\" });\n\n  const filteredItems = items.filter(item =>\n    item.name.toLowerCase().includes(search.toLowerCase())\n  );\n\n  return (\n    <FlatList\n      data={filteredItems}\n      renderItem={({ item }) => <ItemRow item={item} />}\n    />\n  );\n}\n```\n\n## Filtering Patterns\n\n### Simple Text Filter\n\n```tsx\nconst filtered = items.filter(item =>\n  item.name.toLowerCase().includes(search.toLowerCase())\n);\n```\n\n### Multiple Fields\n\n```tsx\nconst filtered = items.filter(item => {\n  const query = search.toLowerCase();\n  return (\n    item.name.toLowerCase().includes(query) ||\n    item.description.toLowerCase().includes(query) ||\n    item.tags.some(tag => tag.toLowerCase().includes(query))\n  );\n});\n```\n\n### Debounced Search\n\nFor expensive filtering or API calls:\n\n```tsx\nimport { useState, useEffect, useMemo } from \"react\";\n\nfunction useDebounce<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debounced;\n}\n\nfunction SearchScreen() {\n  const search = useSearch();\n  const debouncedSearch = useDebounce(search, 300);\n\n  const filteredItems = useMemo(() =>\n    items.filter(item =>\n      item.name.toLowerCase().includes(debouncedSearch.toLowerCase())\n    ),\n    [debouncedSearch]\n  );\n\n  return <FlatList data={filteredItems} />;\n}\n```\n\n## Search with Native Tabs\n\nWhen using NativeTabs with a search role, the search bar integrates with the tab bar:\n\n```tsx\n// app/_layout.tsx\n<NativeTabs>\n  <NativeTabs.Trigger name=\"(home)\">\n    <Label>Home</Label>\n    <Icon sf=\"house.fill\" />\n  </NativeTabs.Trigger>\n  <NativeTabs.Trigger name=\"(search)\" role=\"search\">\n    <Label>Search</Label>\n  </NativeTabs.Trigger>\n</NativeTabs>\n```\n\n```tsx\n// app/(search)/_layout.tsx\n<Stack>\n  <Stack.Screen\n    name=\"index\"\n    options={{\n      headerSearchBarOptions: {\n        placeholder: \"Search...\",\n        onChangeText: (e) => setSearch(e.nativeEvent.text),\n      },\n    }}\n  />\n</Stack>\n```\n\n## Empty States\n\nShow appropriate UI when search returns no results:\n\n```tsx\nfunction SearchResults({ search, items }) {\n  const filtered = items.filter(/* ... */);\n\n  if (search && filtered.length === 0) {\n    return (\n      <View style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\" }}>\n        <Text style={{ color: PlatformColor(\"secondaryLabel\") }}>\n          No results for \"{search}\"\n        </Text>\n      </View>\n    );\n  }\n\n  return <FlatList data={filtered} />;\n}\n```\n\n## Search Suggestions\n\nShow recent searches or suggestions:\n\n```tsx\nfunction SearchScreen() {\n  const search = useSearch();\n  const [recentSearches, setRecentSearches] = useState<string[]>([]);\n\n  if (!search && recentSearches.length > 0) {\n    return (\n      <View>\n        <Text style={{ color: PlatformColor(\"secondaryLabel\") }}>\n          Recent Searches\n        </Text>\n        {recentSearches.map((term) => (\n          <Pressable key={term} onPress={() => /* apply search */}>\n            <Text>{term}</Text>\n          </Pressable>\n        ))}\n      </View>\n    );\n  }\n\n  return <SearchResults search={search} />;\n}\n```\n",
        "skills/building-ui/references/storage.md": "# Storage\n\n## Key-Value Storage\n\nUse the localStorage polyfill for key-value storage. **Never use AsyncStorage**\n\n```tsx\nimport \"expo-sqlite/localStorage/install\";\n\n// Simple get/set\nlocalStorage.setItem(\"key\", \"value\");\nlocalStorage.getItem(\"key\");\n\n// Store objects as JSON\nlocalStorage.setItem(\"user\", JSON.stringify({ name: \"John\", id: 1 }));\nconst user = JSON.parse(localStorage.getItem(\"user\") ?? \"{}\");\n```\n\n## When to Use What\n\n| Use Case                                             | Solution                |\n| ---------------------------------------------------- | ----------------------- |\n| Simple key-value (settings, preferences, small data) | `localStorage` polyfill |\n| Large datasets, complex queries, relational data     | Full `expo-sqlite`      |\n| Sensitive data (tokens, passwords)                   | `expo-secure-store`     |\n\n## Storage with React State\n\nCreate a storage utility with subscriptions for reactive updates:\n\n```tsx\n// utils/storage.ts\nimport \"expo-sqlite/localStorage/install\";\n\ntype Listener = () => void;\nconst listeners = new Map<string, Set<Listener>>();\n\nexport const storage = {\n  get<T>(key: string, defaultValue: T): T {\n    const value = localStorage.getItem(key);\n    return value ? JSON.parse(value) : defaultValue;\n  },\n\n  set<T>(key: string, value: T): void {\n    localStorage.setItem(key, JSON.stringify(value));\n    listeners.get(key)?.forEach((fn) => fn());\n  },\n\n  subscribe(key: string, listener: Listener): () => void {\n    if (!listeners.has(key)) listeners.set(key, new Set());\n    listeners.get(key)!.add(listener);\n    return () => listeners.get(key)?.delete(listener);\n  },\n};\n```\n\n## React Hook for Storage\n\n```tsx\n// hooks/use-storage.ts\nimport { useSyncExternalStore } from \"react\";\nimport { storage } from \"@/utils/storage\";\n\nexport function useStorage<T>(\n  key: string,\n  defaultValue: T\n): [T, (value: T) => void] {\n  const value = useSyncExternalStore(\n    (cb) => storage.subscribe(key, cb),\n    () => storage.get(key, defaultValue)\n  );\n\n  return [value, (newValue: T) => storage.set(key, newValue)];\n}\n```\n\nUsage:\n\n```tsx\nfunction Settings() {\n  const [theme, setTheme] = useStorage(\"theme\", \"light\");\n\n  return (\n    <Switch\n      value={theme === \"dark\"}\n      onValueChange={(dark) => setTheme(dark ? \"dark\" : \"light\")}\n    />\n  );\n}\n```\n\n## Full SQLite for Complex Data\n\nFor larger datasets or complex queries, use expo-sqlite directly:\n\n```tsx\nimport * as SQLite from \"expo-sqlite\";\n\nconst db = await SQLite.openDatabaseAsync(\"app.db\");\n\n// Create table\nawait db.execAsync(`\n  CREATE TABLE IF NOT EXISTS events (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    title TEXT NOT NULL,\n    date TEXT NOT NULL,\n    location TEXT\n  )\n`);\n\n// Insert\nawait db.runAsync(\"INSERT INTO events (title, date) VALUES (?, ?)\", [\n  \"Meeting\",\n  \"2024-01-15\",\n]);\n\n// Query\nconst events = await db.getAllAsync(\"SELECT * FROM events WHERE date > ?\", [\n  \"2024-01-01\",\n]);\n```\n",
        "skills/building-ui/references/tabs.md": "# Native Tabs\n\nAlways prefer NativeTabs from 'expo-router/unstable-native-tabs' for the best iOS experience.\n\n**Requires SDK 54+**\n\n## Basic Usage\n\n```tsx\nimport {\n  NativeTabs,\n  Icon,\n  Label,\n  Badge,\n} from \"expo-router/unstable-native-tabs\";\n\nexport default function TabLayout() {\n  return (\n    <NativeTabs minimizeBehavior=\"onScrollDown\">\n      <NativeTabs.Trigger name=\"index\">\n        <Label>Home</Label>\n        <Icon sf=\"house.fill\" />\n        <Badge>9+</Badge>\n      </NativeTabs.Trigger>\n      <NativeTabs.Trigger name=\"settings\">\n        <Icon sf=\"gear\" />\n        <Label>Settings</Label>\n      </NativeTabs.Trigger>\n      <NativeTabs.Trigger name=\"(search)\" role=\"search\">\n        <Label>Search</Label>\n      </NativeTabs.Trigger>\n    </NativeTabs>\n  );\n}\n```\n\n## Rules\n\n- You must include a trigger for each tab\n- The `NativeTabs.Trigger` 'name' must match the route name, including parentheses (e.g. `<NativeTabs.Trigger name=\"(search)\">`)\n- Prefer search tab to be last in the list so it can combine with the search bar\n- Use the 'role' prop for common tab types\n\n## Platform Features\n\nNative Tabs use platform-specific tab bar implementations:\n\n- **iOS 26+**: Liquid glass effects with system-native appearance\n- **Android**: Material 3 bottom navigation\n- Better performance and native feel\n\n## Icon Component\n\n```tsx\n// SF Symbol only (iOS)\n<Icon sf=\"house.fill\" />\n\n// With Android drawable\n<Icon sf=\"house.fill\" drawable=\"ic_home\" />\n\n// Custom image source\n<Icon src={require('./icon.png')} />\n\n// State variants (default/selected)\n<Icon sf={{ default: \"house\", selected: \"house.fill\" }} />\n```\n\n## Label Component\n\n```tsx\n// Basic label\n<Label>Home</Label>\n\n// Hidden label (icon only)\n<Label hidden>Home</Label>\n```\n\n## Badge Component\n\n```tsx\n// Numeric badge\n<Badge>9+</Badge>\n\n// Dot indicator (empty badge)\n<Badge />\n```\n\n## iOS 26 Features\n\n### Liquid Glass Tab Bar\n\nThe tab bar automatically adopts liquid glass appearance on iOS 26+.\n\n### Minimize on Scroll\n\n```tsx\n<NativeTabs minimizeBehavior=\"onScrollDown\">\n```\n\n### Search Tab\n\nAdd a dedicated search tab that integrates with the tab bar search field:\n\n```tsx\n<NativeTabs.Trigger name=\"(search)\" role=\"search\">\n  <Label>Search</Label>\n</NativeTabs.Trigger>\n```\n\n**Note**: Place search tab last for best UX.\n\n### Role Prop\n\nUse semantic roles for special tab types:\n\n```tsx\n<NativeTabs.Trigger name=\"search\" role=\"search\" />\n<NativeTabs.Trigger name=\"favorites\" role=\"favorites\" />\n<NativeTabs.Trigger name=\"more\" role=\"more\" />\n```\n\nAvailable roles: `search` | `more` | `favorites` | `bookmarks` | `contacts` | `downloads` | `featured` | `history` | `mostRecent` | `mostViewed` | `recents` | `topRated`\n\n## Customization\n\n### Tint Color\n\n```tsx\n<NativeTabs tintColor=\"#007AFF\">\n```\n\n### Dynamic Colors (iOS)\n\nUse DynamicColorIOS for colors that adapt to liquid glass:\n\n```tsx\nimport { DynamicColorIOS, Platform } from 'react-native';\n\nconst adaptiveBlue = Platform.select({\n  ios: DynamicColorIOS({ light: '#007AFF', dark: '#0A84FF' }),\n  default: '#007AFF',\n});\n\n<NativeTabs tintColor={adaptiveBlue}>\n```\n\n## Conditional Tabs\n\nHide tabs conditionally:\n\n```tsx\n<NativeTabs.Trigger name=\"admin\" hidden={!isAdmin}>\n  <Label>Admin</Label>\n  <Icon sf=\"shield.fill\" />\n</NativeTabs.Trigger>\n```\n\n## Behavior Options\n\n```tsx\n<NativeTabs.Trigger\n  name=\"home\"\n  disablePopToTop    // Don't pop stack when tapping active tab\n  disableScrollToTop // Don't scroll to top when tapping active tab\n>\n```\n\n## Using Vector Icons\n\nIf you must use @expo/vector-icons instead of SF Symbols:\n\n```tsx\nimport { VectorIcon } from \"expo-router/unstable-native-tabs\";\nimport Ionicons from \"@expo/vector-icons/Ionicons\";\n\n<NativeTabs.Trigger name=\"home\">\n  <VectorIcon vector={Ionicons} name=\"home\" />\n  <Label>Home</Label>\n</NativeTabs.Trigger>;\n```\n\n**Prefer SF Symbols over vector icons for native feel on Apple platforms.**\n\n## Structure with Stacks\n\nNative tabs don't render headers. Nest Stacks inside each tab for navigation headers:\n\n```tsx\n// app/(tabs)/_layout.tsx\nimport { NativeTabs, Icon, Label } from \"expo-router/unstable-native-tabs\";\n\nexport default function TabLayout() {\n  return (\n    <NativeTabs>\n      <NativeTabs.Trigger name=\"(home)\">\n        <Label>Home</Label>\n        <Icon sf=\"house.fill\" />\n      </NativeTabs.Trigger>\n    </NativeTabs>\n  );\n}\n\n// app/(tabs)/(home)/_layout.tsx\nimport Stack from \"expo-router/stack\";\n\nexport default function HomeStack() {\n  return (\n    <Stack>\n      <Stack.Screen\n        name=\"index\"\n        options={{ title: \"Home\", headerLargeTitle: true }}\n      />\n      <Stack.Screen name=\"details\" options={{ title: \"Details\" }} />\n    </Stack>\n  );\n}\n```\n\n## Migration from JS Tabs\n\n### Before (JS Tabs)\n\n```tsx\nimport { Tabs } from \"expo-router\";\n\nexport default function TabLayout() {\n  return (\n    <Tabs>\n      <Tabs.Screen\n        name=\"index\"\n        options={{\n          title: \"Home\",\n          tabBarIcon: ({ color }) => (\n            <IconSymbol name=\"house.fill\" color={color} />\n          ),\n        }}\n      />\n      <Tabs.Screen\n        name=\"settings\"\n        options={{\n          title: \"Settings\",\n          tabBarIcon: ({ color }) => <IconSymbol name=\"gear\" color={color} />,\n        }}\n      />\n    </Tabs>\n  );\n}\n```\n\n### After (Native Tabs)\n\n```tsx\nimport { NativeTabs, Icon, Label } from \"expo-router/unstable-native-tabs\";\n\nexport default function TabLayout() {\n  return (\n    <NativeTabs>\n      <NativeTabs.Trigger name=\"index\">\n        <Label>Home</Label>\n        <Icon sf=\"house.fill\" />\n      </NativeTabs.Trigger>\n      <NativeTabs.Trigger name=\"settings\">\n        <Label>Settings</Label>\n        <Icon sf=\"gear\" />\n      </NativeTabs.Trigger>\n    </NativeTabs>\n  );\n}\n```\n\n### Key Differences\n\n| JS Tabs                    | Native Tabs               |\n| -------------------------- | ------------------------- |\n| `<Tabs.Screen>`            | `<NativeTabs.Trigger>`    |\n| `options={{ title }}`      | `<Label>Title</Label>`    |\n| `options={{ tabBarIcon }}` | `<Icon sf=\"symbol\" />`    |\n| Props-based API            | React component-based API |\n| `tabBarBadge` option       | `<Badge>` component       |\n\n### Migration Steps\n\n1. **Change imports**\n\n   ```tsx\n   // Remove\n   import { Tabs } from \"expo-router\";\n\n   // Add\n   import {\n     NativeTabs,\n     Icon,\n     Label,\n     Badge,\n   } from \"expo-router/unstable-native-tabs\";\n   ```\n\n2. **Replace Tabs with NativeTabs**\n\n   ```tsx\n   // Before\n   <Tabs screenOptions={{ ... }}>\n\n   // After\n   <NativeTabs>\n   ```\n\n3. **Convert each Screen to Trigger**\n\n   ```tsx\n   // Before\n   <Tabs.Screen\n     name=\"home\"\n     options={{\n       title: 'Home',\n       tabBarIcon: ({ color }) => <Icon name=\"house\" color={color} />,\n       tabBarBadge: 3,\n     }}\n   />\n\n   // After\n   <NativeTabs.Trigger name=\"home\">\n     <Label>Home</Label>\n     <Icon sf=\"house.fill\" />\n     <Badge>3</Badge>\n   </NativeTabs.Trigger>\n   ```\n\n4. **Move headers to nested Stack** - Native tabs don't render headers\n   ```\n   app/\n     (tabs)/\n       _layout.tsx      <- NativeTabs\n       (home)/\n         _layout.tsx    <- Stack with headers\n         index.tsx\n       (settings)/\n         _layout.tsx    <- Stack with headers\n         index.tsx\n   ```\n\n## Limitations\n\n- **Android**: Maximum 5 tabs (Material Design constraint)\n- **Nesting**: Native tabs cannot nest inside other native tabs\n- **Tab bar height**: Cannot be measured programmatically\n- **FlatList transparency**: Use `disableTransparentOnScrollEdge` to fix issues\n\n## Keyboard Handling (Android)\n\nConfigure in app.json:\n\n```json\n{\n  \"expo\": {\n    \"android\": {\n      \"softwareKeyboardLayoutMode\": \"resize\"\n    }\n  }\n}\n```\n\n## Common Issues\n\n1. **Icons not showing on Android**: Add `drawable` prop or use `VectorIcon`\n2. **Headers missing**: Nest a Stack inside each tab group\n3. **Trigger name mismatch**: Ensure `name` matches exact route name including parentheses\n4. **Badge not visible**: Badge must be a child of Trigger, not a prop\n",
        "skills/building-ui/references/visual-effects.md": "# Visual Effects\n\n## Backdrop Blur\n\nUse `expo-blur` for blur effects. Prefer systemMaterial tints as they adapt to dark mode.\n\n```tsx\nimport { BlurView } from \"expo-blur\";\n\n<BlurView tint=\"systemMaterial\" intensity={100} />;\n```\n\n### Tint Options\n\n```tsx\n// System materials (adapt to dark mode)\n<BlurView tint=\"systemMaterial\" />\n<BlurView tint=\"systemThinMaterial\" />\n<BlurView tint=\"systemUltraThinMaterial\" />\n<BlurView tint=\"systemThickMaterial\" />\n<BlurView tint=\"systemChromeMaterial\" />\n\n// Basic tints\n<BlurView tint=\"light\" />\n<BlurView tint=\"dark\" />\n<BlurView tint=\"default\" />\n\n// Prominent (more visible)\n<BlurView tint=\"prominent\" />\n\n// Extra light/dark\n<BlurView tint=\"extraLight\" />\n```\n\n### Intensity\n\nControl blur strength with `intensity` (0-100):\n\n```tsx\n<BlurView tint=\"systemMaterial\" intensity={50} />  // Subtle\n<BlurView tint=\"systemMaterial\" intensity={100} /> // Full\n```\n\n### Rounded Corners\n\nBlurView requires `overflow: 'hidden'` to clip rounded corners:\n\n```tsx\n<BlurView\n  tint=\"systemMaterial\"\n  intensity={100}\n  style={{\n    borderRadius: 16,\n    overflow: 'hidden',\n  }}\n/>\n```\n\n### Overlay Pattern\n\nCommon pattern for overlaying blur on content:\n\n```tsx\n<View style={{ position: 'relative' }}>\n  <Image source={{ uri: '...' }} style={{ width: '100%', height: 200 }} />\n  <BlurView\n    tint=\"systemUltraThinMaterial\"\n    intensity={80}\n    style={{\n      position: 'absolute',\n      bottom: 0,\n      left: 0,\n      right: 0,\n      padding: 16,\n    }}\n  >\n    <Text style={{ color: 'white' }}>Caption</Text>\n  </BlurView>\n</View>\n```\n\n## Glass Effects (iOS 26+)\n\nUse `expo-glass-effect` for liquid glass backdrops on iOS 26+.\n\n```tsx\nimport { GlassView } from \"expo-glass-effect\";\n\n<GlassView style={{ borderRadius: 16, padding: 16 }}>\n  <Text>Content inside glass</Text>\n</GlassView>\n```\n\n### Interactive Glass\n\nAdd `isInteractive` for buttons and pressable glass:\n\n```tsx\nimport { GlassView } from \"expo-glass-effect\";\nimport { SymbolView } from \"expo-symbols\";\nimport { PlatformColor } from \"react-native\";\n\n<GlassView isInteractive style={{ borderRadius: 50 }}>\n  <Pressable style={{ padding: 12 }} onPress={handlePress}>\n    <SymbolView name=\"plus\" tintColor={PlatformColor(\"label\")} size={36} />\n  </Pressable>\n</GlassView>\n```\n\n### Glass Buttons\n\nCreate liquid glass buttons:\n\n```tsx\nfunction GlassButton({ icon, onPress }) {\n  return (\n    <GlassView isInteractive style={{ borderRadius: 50 }}>\n      <Pressable style={{ padding: 12 }} onPress={onPress}>\n        <SymbolView name={icon} tintColor={PlatformColor(\"label\")} size={24} />\n      </Pressable>\n    </GlassView>\n  );\n}\n\n// Usage\n<GlassButton icon=\"plus\" onPress={handleAdd} />\n<GlassButton icon=\"gear\" onPress={handleSettings} />\n```\n\n### Glass Card\n\n```tsx\n<GlassView style={{ borderRadius: 20, padding: 20 }}>\n  <Text style={{ fontSize: 18, fontWeight: '600', color: PlatformColor(\"label\") }}>\n    Card Title\n  </Text>\n  <Text style={{ color: PlatformColor(\"secondaryLabel\"), marginTop: 8 }}>\n    Card content goes here\n  </Text>\n</GlassView>\n```\n\n### Checking Availability\n\n```tsx\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\nif (isLiquidGlassAvailable()) {\n  // Use GlassView\n} else {\n  // Fallback to BlurView or solid background\n}\n```\n\n### Fallback Pattern\n\n```tsx\nimport { GlassView, isLiquidGlassAvailable } from \"expo-glass-effect\";\nimport { BlurView } from \"expo-blur\";\n\nfunction AdaptiveGlass({ children, style }) {\n  if (isLiquidGlassAvailable()) {\n    return <GlassView style={style}>{children}</GlassView>;\n  }\n\n  return (\n    <BlurView tint=\"systemMaterial\" intensity={80} style={style}>\n      {children}\n    </BlurView>\n  );\n}\n```\n\n## Sheet with Glass Background\n\nMake sheet backgrounds liquid glass on iOS 26+:\n\n```tsx\n<Stack.Screen\n  name=\"sheet\"\n  options={{\n    presentation: \"formSheet\",\n    sheetGrabberVisible: true,\n    sheetAllowedDetents: [0.5, 1.0],\n    contentStyle: { backgroundColor: \"transparent\" },\n  }}\n/>\n```\n\n## Best Practices\n\n- Use `systemMaterial` tints for automatic dark mode support\n- Always set `overflow: 'hidden'` on BlurView for rounded corners\n- Use `isInteractive` on GlassView for buttons and pressables\n- Check `isLiquidGlassAvailable()` and provide fallbacks\n- Avoid nesting blur views (performance impact)\n- Keep blur intensity reasonable (50-100) for readability\n",
        "skills/building-ui/references/webgpu-three.md": "# WebGPU & Three.js for Expo\n\n**Use this skill for ANY 3D graphics, games, GPU compute, or Three.js features in React Native.**\n\n## Locked Versions (Tested & Working)\n\n```json\n{\n  \"react-native-wgpu\": \"^0.4.1\",\n  \"three\": \"0.172.0\",\n  \"@react-three/fiber\": \"^9.4.0\",\n  \"wgpu-matrix\": \"^3.0.2\",\n  \"@types/three\": \"0.172.0\"\n}\n```\n\n**Critical:** These versions are tested together. Mismatched versions cause type errors and runtime issues.\n\n## Installation\n\n```bash\nnpm install react-native-wgpu@^0.4.1 three@0.172.0 @react-three/fiber@^9.4.0 wgpu-matrix@^3.0.2 @types/three@0.172.0 --legacy-peer-deps\n```\n\n**Note:** `--legacy-peer-deps` may be required due to peer dependency conflicts with canary Expo versions.\n\n## Metro Configuration\n\nCreate `metro.config.js` in project root:\n\n```js\nconst { getDefaultConfig } = require(\"expo/metro-config\");\n\nconst config = getDefaultConfig(__dirname);\n\nconfig.resolver.resolveRequest = (context, moduleName, platform) => {\n  // Force 'three' to webgpu build\n  if (moduleName.startsWith(\"three\")) {\n    moduleName = \"three/webgpu\";\n  }\n\n  // Use standard react-three/fiber instead of React Native version\n  if (platform !== \"web\" && moduleName.startsWith(\"@react-three/fiber\")) {\n    return context.resolveRequest(\n      {\n        ...context,\n        unstable_conditionNames: [\"module\"],\n        mainFields: [\"module\"],\n      },\n      moduleName,\n      platform\n    );\n  }\n  return context.resolveRequest(context, moduleName, platform);\n};\n\nmodule.exports = config;\n```\n\n## Required Lib Files\n\nCreate these files in `src/lib/`:\n\n### 1. make-webgpu-renderer.ts\n\n```ts\nimport type { NativeCanvas } from \"react-native-wgpu\";\nimport * as THREE from \"three/webgpu\";\n\nexport class ReactNativeCanvas {\n  constructor(private canvas: NativeCanvas) {}\n\n  get width() {\n    return this.canvas.width;\n  }\n  get height() {\n    return this.canvas.height;\n  }\n  set width(width: number) {\n    this.canvas.width = width;\n  }\n  set height(height: number) {\n    this.canvas.height = height;\n  }\n  get clientWidth() {\n    return this.canvas.width;\n  }\n  get clientHeight() {\n    return this.canvas.height;\n  }\n  set clientWidth(width: number) {\n    this.canvas.width = width;\n  }\n  set clientHeight(height: number) {\n    this.canvas.height = height;\n  }\n\n  addEventListener(_type: string, _listener: EventListener) {}\n  removeEventListener(_type: string, _listener: EventListener) {}\n  dispatchEvent(_event: Event) {}\n  setPointerCapture() {}\n  releasePointerCapture() {}\n}\n\nexport const makeWebGPURenderer = (\n  context: GPUCanvasContext,\n  { antialias = true }: { antialias?: boolean } = {}\n) =>\n  new THREE.WebGPURenderer({\n    antialias,\n    // @ts-expect-error\n    canvas: new ReactNativeCanvas(context.canvas),\n    context,\n  });\n```\n\n### 2. fiber-canvas.tsx\n\n```tsx\nimport * as THREE from \"three/webgpu\";\nimport React, { useEffect, useRef } from \"react\";\nimport type { ReconcilerRoot, RootState } from \"@react-three/fiber\";\nimport {\n  extend,\n  createRoot,\n  unmountComponentAtNode,\n  events,\n} from \"@react-three/fiber\";\nimport type { ViewProps } from \"react-native\";\nimport { PixelRatio } from \"react-native\";\nimport { Canvas, type CanvasRef } from \"react-native-wgpu\";\n\nimport {\n  makeWebGPURenderer,\n  ReactNativeCanvas,\n} from \"@/lib/make-webgpu-renderer\";\n\n// Extend THREE namespace for R3F - add all components you use\nextend({\n  AmbientLight: THREE.AmbientLight,\n  DirectionalLight: THREE.DirectionalLight,\n  PointLight: THREE.PointLight,\n  SpotLight: THREE.SpotLight,\n  Mesh: THREE.Mesh,\n  Group: THREE.Group,\n  Points: THREE.Points,\n  BoxGeometry: THREE.BoxGeometry,\n  SphereGeometry: THREE.SphereGeometry,\n  CylinderGeometry: THREE.CylinderGeometry,\n  ConeGeometry: THREE.ConeGeometry,\n  DodecahedronGeometry: THREE.DodecahedronGeometry,\n  BufferGeometry: THREE.BufferGeometry,\n  BufferAttribute: THREE.BufferAttribute,\n  MeshStandardMaterial: THREE.MeshStandardMaterial,\n  MeshBasicMaterial: THREE.MeshBasicMaterial,\n  PointsMaterial: THREE.PointsMaterial,\n  PerspectiveCamera: THREE.PerspectiveCamera,\n  Scene: THREE.Scene,\n});\n\ninterface FiberCanvasProps {\n  children: React.ReactNode;\n  style?: ViewProps[\"style\"];\n  camera?: THREE.PerspectiveCamera;\n  scene?: THREE.Scene;\n}\n\nexport const FiberCanvas = ({\n  children,\n  style,\n  scene,\n  camera,\n}: FiberCanvasProps) => {\n  const root = useRef<ReconcilerRoot<OffscreenCanvas>>(null!);\n  const canvasRef = useRef<CanvasRef>(null);\n\n  useEffect(() => {\n    const context = canvasRef.current!.getContext(\"webgpu\")!;\n    const renderer = makeWebGPURenderer(context);\n\n    // @ts-expect-error - ReactNativeCanvas wraps native canvas\n    const canvas = new ReactNativeCanvas(context.canvas) as HTMLCanvasElement;\n    canvas.width = canvas.clientWidth * PixelRatio.get();\n    canvas.height = canvas.clientHeight * PixelRatio.get();\n    const size = {\n      top: 0,\n      left: 0,\n      width: canvas.clientWidth,\n      height: canvas.clientHeight,\n    };\n\n    if (!root.current) {\n      root.current = createRoot(canvas);\n    }\n    root.current.configure({\n      size,\n      events,\n      scene,\n      camera,\n      gl: renderer,\n      frameloop: \"always\",\n      dpr: 1,\n      onCreated: async (state: RootState) => {\n        // @ts-expect-error - WebGPU renderer has init method\n        await state.gl.init();\n        const renderFrame = state.gl.render.bind(state.gl);\n        state.gl.render = (s: THREE.Scene, c: THREE.Camera) => {\n          renderFrame(s, c);\n          context?.present();\n        };\n      },\n    });\n    root.current.render(children);\n    return () => {\n      if (canvas != null) {\n        unmountComponentAtNode(canvas!);\n      }\n    };\n  });\n\n  return <Canvas ref={canvasRef} style={style} />;\n};\n```\n\n## Basic 3D Scene\n\n```tsx\nimport * as THREE from \"three/webgpu\";\nimport { View } from \"react-native\";\nimport { useRef } from \"react\";\nimport { useFrame, useThree } from \"@react-three/fiber\";\nimport { FiberCanvas } from \"@/lib/fiber-canvas\";\n\nfunction RotatingBox() {\n  const ref = useRef<THREE.Mesh>(null!);\n\n  useFrame((_, delta) => {\n    ref.current.rotation.x += delta;\n    ref.current.rotation.y += delta * 0.5;\n  });\n\n  return (\n    <mesh ref={ref}>\n      <boxGeometry args={[1, 1, 1]} />\n      <meshStandardMaterial color=\"hotpink\" />\n    </mesh>\n  );\n}\n\nfunction Scene() {\n  const { camera } = useThree();\n\n  useEffect(() => {\n    camera.position.set(0, 2, 5);\n    camera.lookAt(0, 0, 0);\n  }, [camera]);\n\n  return (\n    <>\n      <ambientLight intensity={0.5} />\n      <directionalLight position={[10, 10, 5]} intensity={1} />\n      <RotatingBox />\n    </>\n  );\n}\n\nexport default function App() {\n  return (\n    <View style={{ flex: 1 }}>\n      <FiberCanvas style={{ flex: 1 }}>\n        <Scene />\n      </FiberCanvas>\n    </View>\n  );\n}\n```\n\n## Lazy Loading (Recommended)\n\nUse React.lazy to code-split Three.js for better loading:\n\n```tsx\nimport React, { Suspense } from \"react\";\nimport { ActivityIndicator, View } from \"react-native\";\n\nconst Scene = React.lazy(() => import(\"@/components/scene\"));\n\nexport default function Page() {\n  return (\n    <View style={{ flex: 1 }}>\n      <Suspense fallback={<ActivityIndicator size=\"large\" />}>\n        <Scene />\n      </Suspense>\n    </View>\n  );\n}\n```\n\n## Common Geometries\n\n```tsx\n// Box\n<mesh>\n  <boxGeometry args={[width, height, depth]} />\n  <meshStandardMaterial color=\"red\" />\n</mesh>\n\n// Sphere\n<mesh>\n  <sphereGeometry args={[radius, widthSegments, heightSegments]} />\n  <meshStandardMaterial color=\"blue\" />\n</mesh>\n\n// Cylinder\n<mesh>\n  <cylinderGeometry args={[radiusTop, radiusBottom, height, segments]} />\n  <meshStandardMaterial color=\"green\" />\n</mesh>\n\n// Cone\n<mesh>\n  <coneGeometry args={[radius, height, segments]} />\n  <meshStandardMaterial color=\"yellow\" />\n</mesh>\n```\n\n## Lighting\n\n```tsx\n// Ambient (uniform light everywhere)\n<ambientLight intensity={0.5} />\n\n// Directional (sun-like)\n<directionalLight position={[10, 10, 5]} intensity={1} />\n\n// Point (light bulb)\n<pointLight position={[0, 5, 0]} intensity={2} distance={10} />\n\n// Spot (flashlight)\n<spotLight position={[0, 10, 0]} angle={0.3} penumbra={1} intensity={2} />\n```\n\n## Animation with useFrame\n\n```tsx\nimport { useFrame } from \"@react-three/fiber\";\nimport { useRef } from \"react\";\nimport * as THREE from \"three/webgpu\";\n\nfunction AnimatedMesh() {\n  const ref = useRef<THREE.Mesh>(null!);\n\n  // Runs every frame - delta is time since last frame\n  useFrame((state, delta) => {\n    // Rotate\n    ref.current.rotation.y += delta;\n\n    // Oscillate position\n    ref.current.position.y = Math.sin(state.clock.elapsedTime) * 2;\n  });\n\n  return (\n    <mesh ref={ref}>\n      <boxGeometry />\n      <meshStandardMaterial color=\"orange\" />\n    </mesh>\n  );\n}\n```\n\n## Particle Systems\n\n```tsx\nimport * as THREE from \"three/webgpu\";\nimport { useRef, useEffect } from \"react\";\nimport { useFrame } from \"@react-three/fiber\";\n\nfunction Particles({ count = 500 }) {\n  const ref = useRef<THREE.Points>(null!);\n  const positions = useRef<Float32Array>(new Float32Array(count * 3));\n\n  useEffect(() => {\n    for (let i = 0; i < count; i++) {\n      positions.current[i * 3] = (Math.random() - 0.5) * 50;\n      positions.current[i * 3 + 1] = (Math.random() - 0.5) * 50;\n      positions.current[i * 3 + 2] = (Math.random() - 0.5) * 50;\n    }\n  }, [count]);\n\n  useFrame((_, delta) => {\n    // Animate particles\n    for (let i = 0; i < count; i++) {\n      positions.current[i * 3 + 1] -= delta * 2;\n      if (positions.current[i * 3 + 1] < -25) {\n        positions.current[i * 3 + 1] = 25;\n      }\n    }\n    ref.current.geometry.attributes.position.needsUpdate = true;\n  });\n\n  return (\n    <points ref={ref}>\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          args={[positions.current, 3]}\n        />\n      </bufferGeometry>\n      <pointsMaterial color=\"#ffffff\" size={0.2} sizeAttenuation />\n    </points>\n  );\n}\n```\n\n## Touch Controls (Orbit)\n\nSee the full `orbit-controls.tsx` implementation in the lib files. Usage:\n\n```tsx\nimport { View } from \"react-native\";\nimport { FiberCanvas } from \"@/lib/fiber-canvas\";\nimport useControls from \"@/lib/orbit-controls\";\n\nfunction Scene() {\n  const [OrbitControls, events] = useControls();\n\n  return (\n    <View style={{ flex: 1 }} {...events}>\n      <FiberCanvas style={{ flex: 1 }}>\n        <OrbitControls />\n        {/* Your 3D content */}\n      </FiberCanvas>\n    </View>\n  );\n}\n```\n\n## Common Issues & Solutions\n\n### 1. \"X is not part of the THREE namespace\"\n\n**Problem:** Error like `AmbientLight is not part of the THREE namespace`\n\n**Solution:** Add the missing component to the `extend()` call in fiber-canvas.tsx:\n\n```tsx\nextend({\n  AmbientLight: THREE.AmbientLight,\n  // Add other missing components...\n});\n```\n\n### 2. TypeScript Errors with Three.js\n\n**Problem:** Type mismatches between three.js and R3F\n\n**Solution:** Use `@ts-expect-error` comments where needed:\n\n```tsx\n// @ts-expect-error - WebGPU renderer types don't match\nawait state.gl.init();\n```\n\n### 3. Blank Screen\n\n**Problem:** Canvas renders but nothing visible\n\n**Solution:**\n\n1. Ensure camera is positioned correctly and looking at scene\n2. Add lighting (objects are black without light)\n3. Check that `extend()` includes all components used\n\n### 4. Performance Issues\n\n**Problem:** Low frame rate or stuttering\n\n**Solution:**\n\n- Reduce polygon count in geometries\n- Use `useMemo` for static data\n- Limit particle count\n- Use `instancedMesh` for many identical objects\n\n### 5. Peer Dependency Errors\n\n**Problem:** npm install fails with ERESOLVE\n\n**Solution:** Use `--legacy-peer-deps`:\n\n```bash\nnpm install <packages> --legacy-peer-deps\n```\n\n## Building\n\nWebGPU requires a custom build:\n\n```bash\nnpx expo prebuild\nnpx expo run:ios\n```\n\n**Note:** WebGPU does NOT work in Expo Go.\n\n## File Structure\n\n```\nsrc/\n├── app/\n│   └── index.tsx           # Entry point with lazy loading\n├── components/\n│   ├── scene.tsx           # Main 3D scene\n│   └── game.tsx            # Game logic\n└── lib/\n    ├── fiber-canvas.tsx    # R3F canvas wrapper\n    ├── make-webgpu-renderer.ts  # WebGPU renderer\n    └── orbit-controls.tsx  # Touch controls\n```\n\n## Decision Tree\n\n```\nNeed 3D graphics?\n├── Simple shapes → mesh + geometry + material\n├── Animated objects → useFrame + refs\n├── Many objects → instancedMesh\n├── Particles → Points + BufferGeometry\n│\nNeed interaction?\n├── Orbit camera → useControls hook\n├── Touch objects → onClick on mesh\n├── Gestures → react-native-gesture-handler\n│\nPerformance critical?\n├── Static geometry → useMemo\n├── Many instances → InstancedMesh\n└── Complex scenes → LOD (Level of Detail)\n```\n\n## Example: Complete Game Scene\n\n```tsx\nimport * as THREE from \"three/webgpu\";\nimport { View, Text, Pressable } from \"react-native\";\nimport { useRef, useState, useCallback } from \"react\";\nimport { useFrame, useThree } from \"@react-three/fiber\";\nimport { FiberCanvas } from \"@/lib/fiber-canvas\";\n\nfunction Player({ position }: { position: THREE.Vector3 }) {\n  const ref = useRef<THREE.Mesh>(null!);\n\n  useFrame(() => {\n    ref.current.position.copy(position);\n  });\n\n  return (\n    <mesh ref={ref}>\n      <coneGeometry args={[0.5, 1, 8]} />\n      <meshStandardMaterial color=\"#00ffff\" />\n    </mesh>\n  );\n}\n\nfunction GameScene({ playerX }: { playerX: number }) {\n  const { camera } = useThree();\n  const playerPos = useRef(new THREE.Vector3(0, 0, 0));\n\n  playerPos.current.x = playerX;\n\n  useEffect(() => {\n    camera.position.set(0, 10, 15);\n    camera.lookAt(0, 0, 0);\n  }, [camera]);\n\n  return (\n    <>\n      <ambientLight intensity={0.5} />\n      <directionalLight position={[5, 10, 5]} />\n      <Player position={playerPos.current} />\n    </>\n  );\n}\n\nexport default function Game() {\n  const [playerX, setPlayerX] = useState(0);\n\n  return (\n    <View style={{ flex: 1, backgroundColor: \"#000\" }}>\n      <FiberCanvas style={{ flex: 1 }}>\n        <GameScene playerX={playerX} />\n      </FiberCanvas>\n\n      <View style={{ position: \"absolute\", bottom: 40, flexDirection: \"row\" }}>\n        <Pressable onPress={() => setPlayerX((x) => x - 1)}>\n          <Text style={{ color: \"#fff\", fontSize: 32 }}>◀</Text>\n        </Pressable>\n        <Pressable onPress={() => setPlayerX((x) => x + 1)}>\n          <Text style={{ color: \"#fff\", fontSize: 32 }}>▶</Text>\n        </Pressable>\n      </View>\n    </View>\n  );\n}\n```\n",
        "skills/composition-patterns/AGENTS.md": "# React Composition Patterns\n\n**Version 1.0.0**  \nEngineering  \nJanuary 2026\n\n> **Note:**  \n> This document is mainly for agents and LLMs to follow when maintaining,  \n> generating, or refactoring React codebases using composition. Humans  \n> may also find it useful, but guidance here is optimized for automation  \n> and consistency by AI-assisted workflows.\n\n---\n\n## Abstract\n\nComposition patterns for building flexible, maintainable React components. Avoid boolean prop proliferation by using compound components, lifting state, and composing internals. These patterns make codebases easier for both humans and AI agents to work with as they scale.\n\n---\n\n## Table of Contents\n\n1. [Component Architecture](#1-component-architecture) — **HIGH**\n   - 1.1 [Avoid Boolean Prop Proliferation](#11-avoid-boolean-prop-proliferation)\n   - 1.2 [Use Compound Components](#12-use-compound-components)\n2. [State Management](#2-state-management) — **MEDIUM**\n   - 2.1 [Decouple State Management from UI](#21-decouple-state-management-from-ui)\n   - 2.2 [Define Generic Context Interfaces for Dependency Injection](#22-define-generic-context-interfaces-for-dependency-injection)\n   - 2.3 [Lift State into Provider Components](#23-lift-state-into-provider-components)\n3. [Implementation Patterns](#3-implementation-patterns) — **MEDIUM**\n   - 3.1 [Create Explicit Component Variants](#31-create-explicit-component-variants)\n   - 3.2 [Prefer Composing Children Over Render Props](#32-prefer-composing-children-over-render-props)\n\n---\n\n## 1. Component Architecture\n\n**Impact: HIGH**\n\nFundamental patterns for structuring components to avoid prop\nproliferation and enable flexible composition.\n\n### 1.1 Avoid Boolean Prop Proliferation\n\n**Impact: CRITICAL (prevents unmaintainable component variants)**\n\nDon't add boolean props like `isThread`, `isEditing`, `isDMThread` to customize\n\ncomponent behavior. Each boolean doubles possible states and creates\n\nunmaintainable conditional logic. Use composition instead.\n\n**Incorrect: boolean props create exponential complexity**\n\n```tsx\nfunction Composer({\n  onSubmit,\n  isThread,\n  channelId,\n  isDMThread,\n  dmId,\n  isEditing,\n  isForwarding,\n}: Props) {\n  return (\n    <form>\n      <Header />\n      <Input />\n      {isDMThread ? (\n        <AlsoSendToDMField id={dmId} />\n      ) : isThread ? (\n        <AlsoSendToChannelField id={channelId} />\n      ) : null}\n      {isEditing ? (\n        <EditActions />\n      ) : isForwarding ? (\n        <ForwardActions />\n      ) : (\n        <DefaultActions />\n      )}\n      <Footer onSubmit={onSubmit} />\n    </form>\n  )\n}\n```\n\n**Correct: composition eliminates conditionals**\n\n```tsx\n// Channel composer\nfunction ChannelComposer() {\n  return (\n    <Composer.Frame>\n      <Composer.Header />\n      <Composer.Input />\n      <Composer.Footer>\n        <Composer.Attachments />\n        <Composer.Formatting />\n        <Composer.Emojis />\n        <Composer.Submit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n\n// Thread composer - adds \"also send to channel\" field\nfunction ThreadComposer({ channelId }: { channelId: string }) {\n  return (\n    <Composer.Frame>\n      <Composer.Header />\n      <Composer.Input />\n      <AlsoSendToChannelField id={channelId} />\n      <Composer.Footer>\n        <Composer.Formatting />\n        <Composer.Emojis />\n        <Composer.Submit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n\n// Edit composer - different footer actions\nfunction EditComposer() {\n  return (\n    <Composer.Frame>\n      <Composer.Input />\n      <Composer.Footer>\n        <Composer.Formatting />\n        <Composer.Emojis />\n        <Composer.CancelEdit />\n        <Composer.SaveEdit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n```\n\nEach variant is explicit about what it renders. We can share internals without\n\nsharing a single monolithic parent.\n\n### 1.2 Use Compound Components\n\n**Impact: HIGH (enables flexible composition without prop drilling)**\n\nStructure complex components as compound components with a shared context. Each\n\nsubcomponent accesses shared state via context, not props. Consumers compose the\n\npieces they need.\n\n**Incorrect: monolithic component with render props**\n\n```tsx\nfunction Composer({\n  renderHeader,\n  renderFooter,\n  renderActions,\n  showAttachments,\n  showFormatting,\n  showEmojis,\n}: Props) {\n  return (\n    <form>\n      {renderHeader?.()}\n      <Input />\n      {showAttachments && <Attachments />}\n      {renderFooter ? (\n        renderFooter()\n      ) : (\n        <Footer>\n          {showFormatting && <Formatting />}\n          {showEmojis && <Emojis />}\n          {renderActions?.()}\n        </Footer>\n      )}\n    </form>\n  )\n}\n```\n\n**Correct: compound components with shared context**\n\n```tsx\nconst ComposerContext = createContext<ComposerContextValue | null>(null)\n\nfunction ComposerProvider({ children, state, actions, meta }: ProviderProps) {\n  return (\n    <ComposerContext value={{ state, actions, meta }}>\n      {children}\n    </ComposerContext>\n  )\n}\n\nfunction ComposerFrame({ children }: { children: React.ReactNode }) {\n  return <form>{children}</form>\n}\n\nfunction ComposerInput() {\n  const {\n    state,\n    actions: { update },\n    meta: { inputRef },\n  } = use(ComposerContext)\n  return (\n    <TextInput\n      ref={inputRef}\n      value={state.input}\n      onChangeText={(text) => update((s) => ({ ...s, input: text }))}\n    />\n  )\n}\n\nfunction ComposerSubmit() {\n  const {\n    actions: { submit },\n  } = use(ComposerContext)\n  return <Button onPress={submit}>Send</Button>\n}\n\n// Export as compound component\nconst Composer = {\n  Provider: ComposerProvider,\n  Frame: ComposerFrame,\n  Input: ComposerInput,\n  Submit: ComposerSubmit,\n  Header: ComposerHeader,\n  Footer: ComposerFooter,\n  Attachments: ComposerAttachments,\n  Formatting: ComposerFormatting,\n  Emojis: ComposerEmojis,\n}\n```\n\n**Usage:**\n\n```tsx\n<Composer.Provider state={state} actions={actions} meta={meta}>\n  <Composer.Frame>\n    <Composer.Header />\n    <Composer.Input />\n    <Composer.Footer>\n      <Composer.Formatting />\n      <Composer.Submit />\n    </Composer.Footer>\n  </Composer.Frame>\n</Composer.Provider>\n```\n\nConsumers explicitly compose exactly what they need. No hidden conditionals. And\n\nthe state, actions and meta are dependency-injected by a parent provider,\n\nallowing multiple usages of the same component structure.\n\n---\n\n## 2. State Management\n\n**Impact: MEDIUM**\n\nPatterns for lifting state and managing shared context across\ncomposed components.\n\n### 2.1 Decouple State Management from UI\n\n**Impact: MEDIUM (enables swapping state implementations without changing UI)**\n\nThe provider component should be the only place that knows how state is managed.\n\nUI components consume the context interface—they don't know if state comes from\n\nuseState, Zustand, or a server sync.\n\n**Incorrect: UI coupled to state implementation**\n\n```tsx\nfunction ChannelComposer({ channelId }: { channelId: string }) {\n  // UI component knows about global state implementation\n  const state = useGlobalChannelState(channelId)\n  const { submit, updateInput } = useChannelSync(channelId)\n\n  return (\n    <Composer.Frame>\n      <Composer.Input\n        value={state.input}\n        onChange={(text) => sync.updateInput(text)}\n      />\n      <Composer.Submit onPress={() => sync.submit()} />\n    </Composer.Frame>\n  )\n}\n```\n\n**Correct: state management isolated in provider**\n\n```tsx\n// Provider handles all state management details\nfunction ChannelProvider({\n  channelId,\n  children,\n}: {\n  channelId: string\n  children: React.ReactNode\n}) {\n  const { state, update, submit } = useGlobalChannel(channelId)\n  const inputRef = useRef(null)\n\n  return (\n    <Composer.Provider\n      state={state}\n      actions={{ update, submit }}\n      meta={{ inputRef }}\n    >\n      {children}\n    </Composer.Provider>\n  )\n}\n\n// UI component only knows about the context interface\nfunction ChannelComposer() {\n  return (\n    <Composer.Frame>\n      <Composer.Header />\n      <Composer.Input />\n      <Composer.Footer>\n        <Composer.Submit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n\n// Usage\nfunction Channel({ channelId }: { channelId: string }) {\n  return (\n    <ChannelProvider channelId={channelId}>\n      <ChannelComposer />\n    </ChannelProvider>\n  )\n}\n```\n\n**Different providers, same UI:**\n\n```tsx\n// Local state for ephemeral forms\nfunction ForwardMessageProvider({ children }) {\n  const [state, setState] = useState(initialState)\n  const forwardMessage = useForwardMessage()\n\n  return (\n    <Composer.Provider\n      state={state}\n      actions={{ update: setState, submit: forwardMessage }}\n    >\n      {children}\n    </Composer.Provider>\n  )\n}\n\n// Global synced state for channels\nfunction ChannelProvider({ channelId, children }) {\n  const { state, update, submit } = useGlobalChannel(channelId)\n\n  return (\n    <Composer.Provider state={state} actions={{ update, submit }}>\n      {children}\n    </Composer.Provider>\n  )\n}\n```\n\nThe same `Composer.Input` component works with both providers because it only\n\ndepends on the context interface, not the implementation.\n\n### 2.2 Define Generic Context Interfaces for Dependency Injection\n\n**Impact: HIGH (enables dependency-injectable state across use-cases)**\n\nDefine a **generic interface** for your component context with three parts:\n\n`state`, `actions`, and `meta`. This interface is a contract that any provider\n\ncan implement—enabling the same UI components to work with completely different\n\nstate implementations.\n\n**Core principle:** Lift state, compose internals, make state\n\ndependency-injectable.\n\n**Incorrect: UI coupled to specific state implementation**\n\n```tsx\nfunction ComposerInput() {\n  // Tightly coupled to a specific hook\n  const { input, setInput } = useChannelComposerState()\n  return <TextInput value={input} onChangeText={setInput} />\n}\n```\n\n**Correct: generic interface enables dependency injection**\n\n```tsx\n// Define a GENERIC interface that any provider can implement\ninterface ComposerState {\n  input: string\n  attachments: Attachment[]\n  isSubmitting: boolean\n}\n\ninterface ComposerActions {\n  update: (updater: (state: ComposerState) => ComposerState) => void\n  submit: () => void\n}\n\ninterface ComposerMeta {\n  inputRef: React.RefObject<TextInput>\n}\n\ninterface ComposerContextValue {\n  state: ComposerState\n  actions: ComposerActions\n  meta: ComposerMeta\n}\n\nconst ComposerContext = createContext<ComposerContextValue | null>(null)\n```\n\n**UI components consume the interface, not the implementation:**\n\n```tsx\nfunction ComposerInput() {\n  const {\n    state,\n    actions: { update },\n    meta,\n  } = use(ComposerContext)\n\n  // This component works with ANY provider that implements the interface\n  return (\n    <TextInput\n      ref={meta.inputRef}\n      value={state.input}\n      onChangeText={(text) => update((s) => ({ ...s, input: text }))}\n    />\n  )\n}\n```\n\n**Different providers implement the same interface:**\n\n```tsx\n// Provider A: Local state for ephemeral forms\nfunction ForwardMessageProvider({ children }: { children: React.ReactNode }) {\n  const [state, setState] = useState(initialState)\n  const inputRef = useRef(null)\n\n  return (\n    <ComposerContext\n      value={{\n        state,\n        actions: { update: setState, submit: useForwardMessage() },\n        meta: { inputRef },\n      }}\n    >\n      {children}\n    </ComposerContext>\n  )\n}\n\n// Provider B: Global synced state for channels\nfunction ChannelProvider({ channelId, children }: Props) {\n  const { state, update, submit } = useGlobalChannel(channelId)\n  const inputRef = useRef(null)\n\n  return (\n    <ComposerContext\n      value={{\n        state,\n        actions: { update, submit },\n        meta: { inputRef },\n      }}\n    >\n      {children}\n    </ComposerContext>\n  )\n}\n```\n\n**The same composed UI works with both:**\n\n```tsx\n// Works with ForwardMessageProvider (local state)\n<ForwardMessageProvider>\n  <Composer.Frame>\n    <Composer.Input />\n    <Composer.Submit />\n  </Composer.Frame>\n</ForwardMessageProvider>\n\n// Works with ChannelProvider (global synced state)\n<ChannelProvider channelId=\"abc\">\n  <Composer.Frame>\n    <Composer.Input />\n    <Composer.Submit />\n  </Composer.Frame>\n</ChannelProvider>\n```\n\n**Custom UI outside the component can access state and actions:**\n\n```tsx\nfunction ForwardMessageDialog() {\n  return (\n    <ForwardMessageProvider>\n      <Dialog>\n        {/* The composer UI */}\n        <Composer.Frame>\n          <Composer.Input placeholder=\"Add a message, if you'd like.\" />\n          <Composer.Footer>\n            <Composer.Formatting />\n            <Composer.Emojis />\n          </Composer.Footer>\n        </Composer.Frame>\n\n        {/* Custom UI OUTSIDE the composer, but INSIDE the provider */}\n        <MessagePreview />\n\n        {/* Actions at the bottom of the dialog */}\n        <DialogActions>\n          <CancelButton />\n          <ForwardButton />\n        </DialogActions>\n      </Dialog>\n    </ForwardMessageProvider>\n  )\n}\n\n// This button lives OUTSIDE Composer.Frame but can still submit!\nfunction ForwardButton() {\n  const {\n    actions: { submit },\n  } = use(ComposerContext)\n  return <Button onPress={submit}>Forward</Button>\n}\n\n// This preview lives OUTSIDE Composer.Frame but can read state!\nfunction MessagePreview() {\n  const { state } = use(ComposerContext)\n  return <Preview message={state.input} attachments={state.attachments} />\n}\n```\n\nThe provider boundary is what matters—not the visual nesting. Components that\n\nneed shared state don't have to be inside the `Composer.Frame`. They just need\n\nto be within the provider.\n\nThe `ForwardButton` and `MessagePreview` are not visually inside the composer\n\nbox, but they can still access its state and actions. This is the power of\n\nlifting state into providers.\n\nThe UI is reusable bits you compose together. The state is dependency-injected\n\nby the provider. Swap the provider, keep the UI.\n\n### 2.3 Lift State into Provider Components\n\n**Impact: HIGH (enables state sharing outside component boundaries)**\n\nMove state management into dedicated provider components. This allows sibling\n\ncomponents outside the main UI to access and modify state without prop drilling\n\nor awkward refs.\n\n**Incorrect: state trapped inside component**\n\n```tsx\nfunction ForwardMessageComposer() {\n  const [state, setState] = useState(initialState)\n  const forwardMessage = useForwardMessage()\n\n  return (\n    <Composer.Frame>\n      <Composer.Input />\n      <Composer.Footer />\n    </Composer.Frame>\n  )\n}\n\n// Problem: How does this button access composer state?\nfunction ForwardMessageDialog() {\n  return (\n    <Dialog>\n      <ForwardMessageComposer />\n      <MessagePreview /> {/* Needs composer state */}\n      <DialogActions>\n        <CancelButton />\n        <ForwardButton /> {/* Needs to call submit */}\n      </DialogActions>\n    </Dialog>\n  )\n}\n```\n\n**Incorrect: useEffect to sync state up**\n\n```tsx\nfunction ForwardMessageDialog() {\n  const [input, setInput] = useState('')\n  return (\n    <Dialog>\n      <ForwardMessageComposer onInputChange={setInput} />\n      <MessagePreview input={input} />\n    </Dialog>\n  )\n}\n\nfunction ForwardMessageComposer({ onInputChange }) {\n  const [state, setState] = useState(initialState)\n  useEffect(() => {\n    onInputChange(state.input) // Sync on every change 😬\n  }, [state.input])\n}\n```\n\n**Incorrect: reading state from ref on submit**\n\n```tsx\nfunction ForwardMessageDialog() {\n  const stateRef = useRef(null)\n  return (\n    <Dialog>\n      <ForwardMessageComposer stateRef={stateRef} />\n      <ForwardButton onPress={() => submit(stateRef.current)} />\n    </Dialog>\n  )\n}\n```\n\n**Correct: state lifted to provider**\n\n```tsx\nfunction ForwardMessageProvider({ children }: { children: React.ReactNode }) {\n  const [state, setState] = useState(initialState)\n  const forwardMessage = useForwardMessage()\n  const inputRef = useRef(null)\n\n  return (\n    <Composer.Provider\n      state={state}\n      actions={{ update: setState, submit: forwardMessage }}\n      meta={{ inputRef }}\n    >\n      {children}\n    </Composer.Provider>\n  )\n}\n\nfunction ForwardMessageDialog() {\n  return (\n    <ForwardMessageProvider>\n      <Dialog>\n        <ForwardMessageComposer />\n        <MessagePreview /> {/* Custom components can access state and actions */}\n        <DialogActions>\n          <CancelButton />\n          <ForwardButton /> {/* Custom components can access state and actions */}\n        </DialogActions>\n      </Dialog>\n    </ForwardMessageProvider>\n  )\n}\n\nfunction ForwardButton() {\n  const { actions } = use(Composer.Context)\n  return <Button onPress={actions.submit}>Forward</Button>\n}\n```\n\nThe ForwardButton lives outside the Composer.Frame but still has access to the\n\nsubmit action because it's within the provider. Even though it's a one-off\n\ncomponent, it can still access the composer's state and actions from outside the\n\nUI itself.\n\n**Key insight:** Components that need shared state don't have to be visually\n\nnested inside each other—they just need to be within the same provider.\n\n---\n\n## 3. Implementation Patterns\n\n**Impact: MEDIUM**\n\nSpecific techniques for implementing compound components and\ncontext providers.\n\n### 3.1 Create Explicit Component Variants\n\n**Impact: MEDIUM (self-documenting code, no hidden conditionals)**\n\nInstead of one component with many boolean props, create explicit variant\n\ncomponents. Each variant composes the pieces it needs. The code documents\n\nitself.\n\n**Incorrect: one component, many modes**\n\n```tsx\n// What does this component actually render?\n<Composer\n  isThread\n  isEditing={false}\n  channelId='abc'\n  showAttachments\n  showFormatting={false}\n/>\n```\n\n**Correct: explicit variants**\n\n```tsx\n// Immediately clear what this renders\n<ThreadComposer channelId=\"abc\" />\n\n// Or\n<EditMessageComposer messageId=\"xyz\" />\n\n// Or\n<ForwardMessageComposer />\n```\n\nEach implementation is unique, explicit and self-contained. Yet they can each\n\nuse shared parts.\n\n**Implementation:**\n\n```tsx\nfunction ThreadComposer({ channelId }: { channelId: string }) {\n  return (\n    <ThreadProvider channelId={channelId}>\n      <Composer.Frame>\n        <Composer.Input />\n        <AlsoSendToChannelField channelId={channelId} />\n        <Composer.Footer>\n          <Composer.Formatting />\n          <Composer.Emojis />\n          <Composer.Submit />\n        </Composer.Footer>\n      </Composer.Frame>\n    </ThreadProvider>\n  )\n}\n\nfunction EditMessageComposer({ messageId }: { messageId: string }) {\n  return (\n    <EditMessageProvider messageId={messageId}>\n      <Composer.Frame>\n        <Composer.Input />\n        <Composer.Footer>\n          <Composer.Formatting />\n          <Composer.Emojis />\n          <Composer.CancelEdit />\n          <Composer.SaveEdit />\n        </Composer.Footer>\n      </Composer.Frame>\n    </EditMessageProvider>\n  )\n}\n\nfunction ForwardMessageComposer() {\n  return (\n    <Composer.Frame>\n      <Composer.Input placeholder=\"Add a message, if you'd like.\" />\n      <Composer.Footer>\n        <Composer.Formatting />\n        <Composer.Emojis />\n        <Composer.Mentions />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n```\n\nEach variant is explicit about:\n\n- What provider/state it uses\n\n- What UI elements it includes\n\n- What actions are available\n\nNo boolean prop combinations to reason about. No impossible states.\n\n### 3.2 Prefer Composing Children Over Render Props\n\n**Impact: MEDIUM (cleaner composition, better readability)**\n\nUse `children` for composition instead of `renderX` props. Children are more\n\nreadable, compose naturally, and don't require understanding callback\n\nsignatures.\n\n**Incorrect: render props**\n\n```tsx\nfunction Composer({\n  renderHeader,\n  renderFooter,\n  renderActions,\n}: {\n  renderHeader?: () => React.ReactNode\n  renderFooter?: () => React.ReactNode\n  renderActions?: () => React.ReactNode\n}) {\n  return (\n    <form>\n      {renderHeader?.()}\n      <Input />\n      {renderFooter ? renderFooter() : <DefaultFooter />}\n      {renderActions?.()}\n    </form>\n  )\n}\n\n// Usage is awkward and inflexible\nreturn (\n  <Composer\n    renderHeader={() => <CustomHeader />}\n    renderFooter={() => (\n      <>\n        <Formatting />\n        <Emojis />\n      </>\n    )}\n    renderActions={() => <SubmitButton />}\n  />\n)\n```\n\n**Correct: compound components with children**\n\n```tsx\nfunction ComposerFrame({ children }: { children: React.ReactNode }) {\n  return <form>{children}</form>\n}\n\nfunction ComposerFooter({ children }: { children: React.ReactNode }) {\n  return <footer className='flex'>{children}</div>\n}\n\n// Usage is flexible\nreturn (\n  <Composer.Frame>\n    <CustomHeader />\n    <Composer.Input />\n    <Composer.Footer>\n      <Composer.Formatting />\n      <Composer.Emojis />\n      <SubmitButton />\n    </Composer.Footer>\n  </Composer.Frame>\n)\n```\n\n**When render props are appropriate:**\n\n```tsx\n// Render props work well when you need to pass data back\n<List\n  data={items}\n  renderItem={({ item, index }) => <Item item={item} index={index} />}\n/>\n```\n\nUse render props when the parent needs to provide data or state to the child.\n\nUse children when composing static structure.\n\n---\n\n## References\n\n1. [https://react.dev](https://react.dev)\n2. [https://react.dev/learn/passing-data-deeply-with-context](https://react.dev/learn/passing-data-deeply-with-context)\n3. [https://react.dev/reference/react/use](https://react.dev/reference/react/use)\n",
        "skills/composition-patterns/README.md": "# React Composition Patterns\n\nA structured repository for React composition patterns that scale. These\npatterns help avoid boolean prop proliferation by using compound components,\nlifting state, and composing internals.\n\n## Structure\n\n- `rules/` - Individual rule files (one per rule)\n  - `_sections.md` - Section metadata (titles, impacts, descriptions)\n  - `_template.md` - Template for creating new rules\n  - `area-description.md` - Individual rule files\n- `metadata.json` - Document metadata (version, organization, abstract)\n- **`AGENTS.md`** - Compiled output (generated)\n\n## Rules\n\n### Component Architecture (CRITICAL)\n\n- `architecture-avoid-boolean-props.md` - Don't add boolean props to customize\n  behavior\n- `architecture-compound-components.md` - Structure as compound components with\n  shared context\n\n### State Management (HIGH)\n\n- `state-lift-state.md` - Lift state into provider components\n- `state-context-interface.md` - Define clear context interfaces\n  (state/actions/meta)\n- `state-decouple-implementation.md` - Decouple state management from UI\n\n### Implementation Patterns (MEDIUM)\n\n- `patterns-children-over-render-props.md` - Prefer children over renderX props\n- `patterns-explicit-variants.md` - Create explicit component variants\n\n## Core Principles\n\n1. **Composition over configuration** — Instead of adding props, let consumers\n   compose\n2. **Lift your state** — State in providers, not trapped in components\n3. **Compose your internals** — Subcomponents access context, not props\n4. **Explicit variants** — Create ThreadComposer, EditComposer, not Composer\n   with isThread\n\n## Creating a New Rule\n\n1. Copy `rules/_template.md` to `rules/area-description.md`\n2. Choose the appropriate area prefix:\n   - `architecture-` for Component Architecture\n   - `state-` for State Management\n   - `patterns-` for Implementation Patterns\n3. Fill in the frontmatter and content\n4. Ensure you have clear examples with explanations\n\n## Impact Levels\n\n- `CRITICAL` - Foundational patterns, prevents unmaintainable code\n- `HIGH` - Significant maintainability improvements\n- `MEDIUM` - Good practices for cleaner code\n",
        "skills/composition-patterns/SKILL.md": "---\nname: vercel-composition-patterns\ndescription:\n  React composition patterns that scale. Use when refactoring components with\n  boolean prop proliferation, building flexible component libraries, or\n  designing reusable APIs. Triggers on tasks involving compound components,\n  render props, context providers, or component architecture.\nlicense: MIT\nmetadata:\n  author: vercel\n  version: '1.0.0'\n---\n\n# React Composition Patterns\n\nComposition patterns for building flexible, maintainable React components. Avoid\nboolean prop proliferation by using compound components, lifting state, and\ncomposing internals. These patterns make codebases easier for both humans and AI\nagents to work with as they scale.\n\n## When to Apply\n\nReference these guidelines when:\n\n- Refactoring components with many boolean props\n- Building reusable component libraries\n- Designing flexible component APIs\n- Reviewing component architecture\n- Working with compound components or context providers\n\n## Rule Categories by Priority\n\n| Priority | Category                | Impact | Prefix          |\n| -------- | ----------------------- | ------ | --------------- |\n| 1        | Component Architecture  | HIGH   | `architecture-` |\n| 2        | State Management        | MEDIUM | `state-`        |\n| 3        | Implementation Patterns | MEDIUM | `patterns-`     |\n\n## Quick Reference\n\n### 1. Component Architecture (HIGH)\n\n- `architecture-avoid-boolean-props` - Don't add boolean props to customize\n  behavior; use composition\n- `architecture-compound-components` - Structure complex components with shared\n  context\n\n### 2. State Management (MEDIUM)\n\n- `state-decouple-implementation` - Provider is the only place that knows how\n  state is managed\n- `state-context-interface` - Define generic interface with state, actions, meta\n  for dependency injection\n- `state-lift-state` - Move state into provider components for sibling access\n\n### 3. Implementation Patterns (MEDIUM)\n\n- `patterns-explicit-variants` - Create explicit variant components instead of\n  boolean modes\n- `patterns-children-over-render-props` - Use children for composition instead\n  of renderX props\n\n## How to Use\n\nRead individual rule files for detailed explanations and code examples:\n\n```\nrules/architecture-avoid-boolean-props.md\nrules/state-context-interface.md\n```\n\nEach rule file contains:\n\n- Brief explanation of why it matters\n- Incorrect code example with explanation\n- Correct code example with explanation\n- Additional context and references\n\n## Full Compiled Document\n\nFor the complete guide with all rules expanded: `AGENTS.md`\n",
        "skills/composition-patterns/rules/_sections.md": "# Sections\n\nThis file defines all sections, their ordering, impact levels, and descriptions.\nThe section ID (in parentheses) is the filename prefix used to group rules.\n\n---\n\n## 1. Component Architecture (architecture)\n\n**Impact:** HIGH  \n**Description:** Fundamental patterns for structuring components to avoid prop\nproliferation and enable flexible composition.\n\n## 2. State Management (state)\n\n**Impact:** MEDIUM  \n**Description:** Patterns for lifting state and managing shared context across\ncomposed components.\n\n## 3. Implementation Patterns (patterns)\n\n**Impact:** MEDIUM  \n**Description:** Specific techniques for implementing compound components and\ncontext providers.\n",
        "skills/composition-patterns/rules/_template.md": "---\ntitle: Rule Title Here\nimpact: MEDIUM\nimpactDescription: brief description of impact\ntags: composition, components\n---\n\n## Rule Title Here\n\nBrief explanation of the rule and why it matters.\n\n**Incorrect:**\n\n```tsx\n// Bad code example\n```\n\n**Correct:**\n\n```tsx\n// Good code example\n```\n\nReference: [Link](https://example.com)\n",
        "skills/composition-patterns/rules/architecture-avoid-boolean-props.md": "---\ntitle: Avoid Boolean Prop Proliferation\nimpact: CRITICAL\nimpactDescription: prevents unmaintainable component variants\ntags: composition, props, architecture\n---\n\n## Avoid Boolean Prop Proliferation\n\nDon't add boolean props like `isThread`, `isEditing`, `isDMThread` to customize\ncomponent behavior. Each boolean doubles possible states and creates\nunmaintainable conditional logic. Use composition instead.\n\n**Incorrect (boolean props create exponential complexity):**\n\n```tsx\nfunction Composer({\n  onSubmit,\n  isThread,\n  channelId,\n  isDMThread,\n  dmId,\n  isEditing,\n  isForwarding,\n}: Props) {\n  return (\n    <form>\n      <Header />\n      <Input />\n      {isDMThread ? (\n        <AlsoSendToDMField id={dmId} />\n      ) : isThread ? (\n        <AlsoSendToChannelField id={channelId} />\n      ) : null}\n      {isEditing ? (\n        <EditActions />\n      ) : isForwarding ? (\n        <ForwardActions />\n      ) : (\n        <DefaultActions />\n      )}\n      <Footer onSubmit={onSubmit} />\n    </form>\n  )\n}\n```\n\n**Correct (composition eliminates conditionals):**\n\n```tsx\n// Channel composer\nfunction ChannelComposer() {\n  return (\n    <Composer.Frame>\n      <Composer.Header />\n      <Composer.Input />\n      <Composer.Footer>\n        <Composer.Attachments />\n        <Composer.Formatting />\n        <Composer.Emojis />\n        <Composer.Submit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n\n// Thread composer - adds \"also send to channel\" field\nfunction ThreadComposer({ channelId }: { channelId: string }) {\n  return (\n    <Composer.Frame>\n      <Composer.Header />\n      <Composer.Input />\n      <AlsoSendToChannelField id={channelId} />\n      <Composer.Footer>\n        <Composer.Formatting />\n        <Composer.Emojis />\n        <Composer.Submit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n\n// Edit composer - different footer actions\nfunction EditComposer() {\n  return (\n    <Composer.Frame>\n      <Composer.Input />\n      <Composer.Footer>\n        <Composer.Formatting />\n        <Composer.Emojis />\n        <Composer.CancelEdit />\n        <Composer.SaveEdit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n```\n\nEach variant is explicit about what it renders. We can share internals without\nsharing a single monolithic parent.\n",
        "skills/composition-patterns/rules/architecture-compound-components.md": "---\ntitle: Use Compound Components\nimpact: HIGH\nimpactDescription: enables flexible composition without prop drilling\ntags: composition, compound-components, architecture\n---\n\n## Use Compound Components\n\nStructure complex components as compound components with a shared context. Each\nsubcomponent accesses shared state via context, not props. Consumers compose the\npieces they need.\n\n**Incorrect (monolithic component with render props):**\n\n```tsx\nfunction Composer({\n  renderHeader,\n  renderFooter,\n  renderActions,\n  showAttachments,\n  showFormatting,\n  showEmojis,\n}: Props) {\n  return (\n    <form>\n      {renderHeader?.()}\n      <Input />\n      {showAttachments && <Attachments />}\n      {renderFooter ? (\n        renderFooter()\n      ) : (\n        <Footer>\n          {showFormatting && <Formatting />}\n          {showEmojis && <Emojis />}\n          {renderActions?.()}\n        </Footer>\n      )}\n    </form>\n  )\n}\n```\n\n**Correct (compound components with shared context):**\n\n```tsx\nconst ComposerContext = createContext<ComposerContextValue | null>(null)\n\nfunction ComposerProvider({ children, state, actions, meta }: ProviderProps) {\n  return (\n    <ComposerContext value={{ state, actions, meta }}>\n      {children}\n    </ComposerContext>\n  )\n}\n\nfunction ComposerFrame({ children }: { children: React.ReactNode }) {\n  return <form>{children}</form>\n}\n\nfunction ComposerInput() {\n  const {\n    state,\n    actions: { update },\n    meta: { inputRef },\n  } = use(ComposerContext)\n  return (\n    <TextInput\n      ref={inputRef}\n      value={state.input}\n      onChangeText={(text) => update((s) => ({ ...s, input: text }))}\n    />\n  )\n}\n\nfunction ComposerSubmit() {\n  const {\n    actions: { submit },\n  } = use(ComposerContext)\n  return <Button onPress={submit}>Send</Button>\n}\n\n// Export as compound component\nconst Composer = {\n  Provider: ComposerProvider,\n  Frame: ComposerFrame,\n  Input: ComposerInput,\n  Submit: ComposerSubmit,\n  Header: ComposerHeader,\n  Footer: ComposerFooter,\n  Attachments: ComposerAttachments,\n  Formatting: ComposerFormatting,\n  Emojis: ComposerEmojis,\n}\n```\n\n**Usage:**\n\n```tsx\n<Composer.Provider state={state} actions={actions} meta={meta}>\n  <Composer.Frame>\n    <Composer.Header />\n    <Composer.Input />\n    <Composer.Footer>\n      <Composer.Formatting />\n      <Composer.Submit />\n    </Composer.Footer>\n  </Composer.Frame>\n</Composer.Provider>\n```\n\nConsumers explicitly compose exactly what they need. No hidden conditionals. And the state, actions and meta are dependency-injected by a parent provider, allowing multiple usages of the same component structure.\n",
        "skills/composition-patterns/rules/patterns-children-over-render-props.md": "---\ntitle: Prefer Composing Children Over Render Props\nimpact: MEDIUM\nimpactDescription: cleaner composition, better readability\ntags: composition, children, render-props\n---\n\n## Prefer Children Over Render Props\n\nUse `children` for composition instead of `renderX` props. Children are more\nreadable, compose naturally, and don't require understanding callback\nsignatures.\n\n**Incorrect (render props):**\n\n```tsx\nfunction Composer({\n  renderHeader,\n  renderFooter,\n  renderActions,\n}: {\n  renderHeader?: () => React.ReactNode\n  renderFooter?: () => React.ReactNode\n  renderActions?: () => React.ReactNode\n}) {\n  return (\n    <form>\n      {renderHeader?.()}\n      <Input />\n      {renderFooter ? renderFooter() : <DefaultFooter />}\n      {renderActions?.()}\n    </form>\n  )\n}\n\n// Usage is awkward and inflexible\nreturn (\n  <Composer\n    renderHeader={() => <CustomHeader />}\n    renderFooter={() => (\n      <>\n        <Formatting />\n        <Emojis />\n      </>\n    )}\n    renderActions={() => <SubmitButton />}\n  />\n)\n```\n\n**Correct (compound components with children):**\n\n```tsx\nfunction ComposerFrame({ children }: { children: React.ReactNode }) {\n  return <form>{children}</form>\n}\n\nfunction ComposerFooter({ children }: { children: React.ReactNode }) {\n  return <footer className='flex'>{children}</footer>\n}\n\n// Usage is flexible\nreturn (\n  <Composer.Frame>\n    <CustomHeader />\n    <Composer.Input />\n    <Composer.Footer>\n      <Composer.Formatting />\n      <Composer.Emojis />\n      <SubmitButton />\n    </Composer.Footer>\n  </Composer.Frame>\n)\n```\n\n**When render props are appropriate:**\n\n```tsx\n// Render props work well when you need to pass data back\n<List\n  data={items}\n  renderItem={({ item, index }) => <Item item={item} index={index} />}\n/>\n```\n\nUse render props when the parent needs to provide data or state to the child.\nUse children when composing static structure.\n",
        "skills/composition-patterns/rules/patterns-explicit-variants.md": "---\ntitle: Create Explicit Component Variants\nimpact: MEDIUM\nimpactDescription: self-documenting code, no hidden conditionals\ntags: composition, variants, architecture\n---\n\n## Create Explicit Component Variants\n\nInstead of one component with many boolean props, create explicit variant\ncomponents. Each variant composes the pieces it needs. The code documents\nitself.\n\n**Incorrect (one component, many modes):**\n\n```tsx\n// What does this component actually render?\n<Composer\n  isThread\n  isEditing={false}\n  channelId='abc'\n  showAttachments\n  showFormatting={false}\n/>\n```\n\n**Correct (explicit variants):**\n\n```tsx\n// Immediately clear what this renders\n<ThreadComposer channelId=\"abc\" />\n\n// Or\n<EditMessageComposer messageId=\"xyz\" />\n\n// Or\n<ForwardMessageComposer messageId=\"123\" />\n```\n\nEach implementation is unique, explicit and self-contained. Yet they can each\nuse shared parts.\n\n**Implementation:**\n\n```tsx\nfunction ThreadComposer({ channelId }: { channelId: string }) {\n  return (\n    <ThreadProvider channelId={channelId}>\n      <Composer.Frame>\n        <Composer.Input />\n        <AlsoSendToChannelField channelId={channelId} />\n        <Composer.Footer>\n          <Composer.Formatting />\n          <Composer.Emojis />\n          <Composer.Submit />\n        </Composer.Footer>\n      </Composer.Frame>\n    </ThreadProvider>\n  )\n}\n\nfunction EditMessageComposer({ messageId }: { messageId: string }) {\n  return (\n    <EditMessageProvider messageId={messageId}>\n      <Composer.Frame>\n        <Composer.Input />\n        <Composer.Footer>\n          <Composer.Formatting />\n          <Composer.Emojis />\n          <Composer.CancelEdit />\n          <Composer.SaveEdit />\n        </Composer.Footer>\n      </Composer.Frame>\n    </EditMessageProvider>\n  )\n}\n\nfunction ForwardMessageComposer({ messageId }: { messageId: string }) {\n  return (\n    <ForwardMessageProvider messageId={messageId}>\n      <Composer.Frame>\n        <Composer.Input placeholder=\"Add a message, if you'd like.\" />\n        <Composer.Footer>\n          <Composer.Formatting />\n          <Composer.Emojis />\n          <Composer.Mentions />\n        </Composer.Footer>\n      </Composer.Frame>\n    </ForwardMessageProvider>\n  )\n}\n```\n\nEach variant is explicit about:\n\n- What provider/state it uses\n- What UI elements it includes\n- What actions are available\n\nNo boolean prop combinations to reason about. No impossible states.\n",
        "skills/composition-patterns/rules/state-context-interface.md": "---\ntitle: Define Generic Context Interfaces for Dependency Injection\nimpact: HIGH\nimpactDescription: enables dependency-injectable state across use-cases\ntags: composition, context, state, typescript, dependency-injection\n---\n\n## Define Generic Context Interfaces for Dependency Injection\n\nDefine a **generic interface** for your component context with three parts:\n`state`, `actions`, and `meta`. This interface is a contract that any provider\ncan implement—enabling the same UI components to work with completely different\nstate implementations.\n\n**Core principle:** Lift state, compose internals, make state\ndependency-injectable.\n\n**Incorrect (UI coupled to specific state implementation):**\n\n```tsx\nfunction ComposerInput() {\n  // Tightly coupled to a specific hook\n  const { input, setInput } = useChannelComposerState()\n  return <TextInput value={input} onChangeText={setInput} />\n}\n```\n\n**Correct (generic interface enables dependency injection):**\n\n```tsx\n// Define a GENERIC interface that any provider can implement\ninterface ComposerState {\n  input: string\n  attachments: Attachment[]\n  isSubmitting: boolean\n}\n\ninterface ComposerActions {\n  update: (updater: (state: ComposerState) => ComposerState) => void\n  submit: () => void\n}\n\ninterface ComposerMeta {\n  inputRef: React.RefObject<TextInput>\n}\n\ninterface ComposerContextValue {\n  state: ComposerState\n  actions: ComposerActions\n  meta: ComposerMeta\n}\n\nconst ComposerContext = createContext<ComposerContextValue | null>(null)\n```\n\n**UI components consume the interface, not the implementation:**\n\n```tsx\nfunction ComposerInput() {\n  const {\n    state,\n    actions: { update },\n    meta,\n  } = use(ComposerContext)\n\n  // This component works with ANY provider that implements the interface\n  return (\n    <TextInput\n      ref={meta.inputRef}\n      value={state.input}\n      onChangeText={(text) => update((s) => ({ ...s, input: text }))}\n    />\n  )\n}\n```\n\n**Different providers implement the same interface:**\n\n```tsx\n// Provider A: Local state for ephemeral forms\nfunction ForwardMessageProvider({ children }: { children: React.ReactNode }) {\n  const [state, setState] = useState(initialState)\n  const inputRef = useRef(null)\n  const submit = useForwardMessage()\n\n  return (\n    <ComposerContext\n      value={{\n        state,\n        actions: { update: setState, submit },\n        meta: { inputRef },\n      }}\n    >\n      {children}\n    </ComposerContext>\n  )\n}\n\n// Provider B: Global synced state for channels\nfunction ChannelProvider({ channelId, children }: Props) {\n  const { state, update, submit } = useGlobalChannel(channelId)\n  const inputRef = useRef(null)\n\n  return (\n    <ComposerContext\n      value={{\n        state,\n        actions: { update, submit },\n        meta: { inputRef },\n      }}\n    >\n      {children}\n    </ComposerContext>\n  )\n}\n```\n\n**The same composed UI works with both:**\n\n```tsx\n// Works with ForwardMessageProvider (local state)\n<ForwardMessageProvider>\n  <Composer.Frame>\n    <Composer.Input />\n    <Composer.Submit />\n  </Composer.Frame>\n</ForwardMessageProvider>\n\n// Works with ChannelProvider (global synced state)\n<ChannelProvider channelId=\"abc\">\n  <Composer.Frame>\n    <Composer.Input />\n    <Composer.Submit />\n  </Composer.Frame>\n</ChannelProvider>\n```\n\n**Custom UI outside the component can access state and actions:**\n\nThe provider boundary is what matters—not the visual nesting. Components that\nneed shared state don't have to be inside the `Composer.Frame`. They just need\nto be within the provider.\n\n```tsx\nfunction ForwardMessageDialog() {\n  return (\n    <ForwardMessageProvider>\n      <Dialog>\n        {/* The composer UI */}\n        <Composer.Frame>\n          <Composer.Input placeholder=\"Add a message, if you'd like.\" />\n          <Composer.Footer>\n            <Composer.Formatting />\n            <Composer.Emojis />\n          </Composer.Footer>\n        </Composer.Frame>\n\n        {/* Custom UI OUTSIDE the composer, but INSIDE the provider */}\n        <MessagePreview />\n\n        {/* Actions at the bottom of the dialog */}\n        <DialogActions>\n          <CancelButton />\n          <ForwardButton />\n        </DialogActions>\n      </Dialog>\n    </ForwardMessageProvider>\n  )\n}\n\n// This button lives OUTSIDE Composer.Frame but can still submit based on its context!\nfunction ForwardButton() {\n  const {\n    actions: { submit },\n  } = use(ComposerContext)\n  return <Button onPress={submit}>Forward</Button>\n}\n\n// This preview lives OUTSIDE Composer.Frame but can read composer's state!\nfunction MessagePreview() {\n  const { state } = use(ComposerContext)\n  return <Preview message={state.input} attachments={state.attachments} />\n}\n```\n\nThe `ForwardButton` and `MessagePreview` are not visually inside the composer\nbox, but they can still access its state and actions. This is the power of\nlifting state into providers.\n\nThe UI is reusable bits you compose together. The state is dependency-injected\nby the provider. Swap the provider, keep the UI.\n",
        "skills/composition-patterns/rules/state-decouple-implementation.md": "---\ntitle: Decouple State Management from UI\nimpact: MEDIUM\nimpactDescription: enables swapping state implementations without changing UI\ntags: composition, state, architecture\n---\n\n## Decouple State Management from UI\n\nThe provider component should be the only place that knows how state is managed.\nUI components consume the context interface—they don't know if state comes from\nuseState, Zustand, or a server sync.\n\n**Incorrect (UI coupled to state implementation):**\n\n```tsx\nfunction ChannelComposer({ channelId }: { channelId: string }) {\n  // UI component knows about global state implementation\n  const state = useGlobalChannelState(channelId)\n  const { submit, updateInput } = useChannelSync(channelId)\n\n  return (\n    <Composer.Frame>\n      <Composer.Input\n        value={state.input}\n        onChange={(text) => sync.updateInput(text)}\n      />\n      <Composer.Submit onPress={() => sync.submit()} />\n    </Composer.Frame>\n  )\n}\n```\n\n**Correct (state management isolated in provider):**\n\n```tsx\n// Provider handles all state management details\nfunction ChannelProvider({\n  channelId,\n  children,\n}: {\n  channelId: string\n  children: React.ReactNode\n}) {\n  const { state, update, submit } = useGlobalChannel(channelId)\n  const inputRef = useRef(null)\n\n  return (\n    <Composer.Provider\n      state={state}\n      actions={{ update, submit }}\n      meta={{ inputRef }}\n    >\n      {children}\n    </Composer.Provider>\n  )\n}\n\n// UI component only knows about the context interface\nfunction ChannelComposer() {\n  return (\n    <Composer.Frame>\n      <Composer.Header />\n      <Composer.Input />\n      <Composer.Footer>\n        <Composer.Submit />\n      </Composer.Footer>\n    </Composer.Frame>\n  )\n}\n\n// Usage\nfunction Channel({ channelId }: { channelId: string }) {\n  return (\n    <ChannelProvider channelId={channelId}>\n      <ChannelComposer />\n    </ChannelProvider>\n  )\n}\n```\n\n**Different providers, same UI:**\n\n```tsx\n// Local state for ephemeral forms\nfunction ForwardMessageProvider({ children }) {\n  const [state, setState] = useState(initialState)\n  const forwardMessage = useForwardMessage()\n\n  return (\n    <Composer.Provider\n      state={state}\n      actions={{ update: setState, submit: forwardMessage }}\n    >\n      {children}\n    </Composer.Provider>\n  )\n}\n\n// Global synced state for channels\nfunction ChannelProvider({ channelId, children }) {\n  const { state, update, submit } = useGlobalChannel(channelId)\n\n  return (\n    <Composer.Provider state={state} actions={{ update, submit }}>\n      {children}\n    </Composer.Provider>\n  )\n}\n```\n\nThe same `Composer.Input` component works with both providers because it only\ndepends on the context interface, not the implementation.\n",
        "skills/composition-patterns/rules/state-lift-state.md": "---\ntitle: Lift State into Provider Components\nimpact: HIGH\nimpactDescription: enables state sharing outside component boundaries\ntags: composition, state, context, providers\n---\n\n## Lift State into Provider Components\n\nMove state management into dedicated provider components. This allows sibling\ncomponents outside the main UI to access and modify state without prop drilling\nor awkward refs.\n\n**Incorrect (state trapped inside component):**\n\n```tsx\nfunction ForwardMessageComposer() {\n  const [state, setState] = useState(initialState)\n  const forwardMessage = useForwardMessage()\n\n  return (\n    <Composer.Frame>\n      <Composer.Input />\n      <Composer.Footer />\n    </Composer.Frame>\n  )\n}\n\n// Problem: How does this button access composer state?\nfunction ForwardMessageDialog() {\n  return (\n    <Dialog>\n      <ForwardMessageComposer />\n      <MessagePreview /> {/* Needs composer state */}\n      <DialogActions>\n        <CancelButton />\n        <ForwardButton /> {/* Needs to call submit */}\n      </DialogActions>\n    </Dialog>\n  )\n}\n```\n\n**Incorrect (useEffect to sync state up):**\n\n```tsx\nfunction ForwardMessageDialog() {\n  const [input, setInput] = useState('')\n  return (\n    <Dialog>\n      <ForwardMessageComposer onInputChange={setInput} />\n      <MessagePreview input={input} />\n    </Dialog>\n  )\n}\n\nfunction ForwardMessageComposer({ onInputChange }) {\n  const [state, setState] = useState(initialState)\n  useEffect(() => {\n    onInputChange(state.input) // Sync on every change 😬\n  }, [state.input])\n}\n```\n\n**Incorrect (reading state from ref on submit):**\n\n```tsx\nfunction ForwardMessageDialog() {\n  const stateRef = useRef(null)\n  return (\n    <Dialog>\n      <ForwardMessageComposer stateRef={stateRef} />\n      <ForwardButton onPress={() => submit(stateRef.current)} />\n    </Dialog>\n  )\n}\n```\n\n**Correct (state lifted to provider):**\n\n```tsx\nfunction ForwardMessageProvider({ children }: { children: React.ReactNode }) {\n  const [state, setState] = useState(initialState)\n  const forwardMessage = useForwardMessage()\n  const inputRef = useRef(null)\n\n  return (\n    <Composer.Provider\n      state={state}\n      actions={{ update: setState, submit: forwardMessage }}\n      meta={{ inputRef }}\n    >\n      {children}\n    </Composer.Provider>\n  )\n}\n\nfunction ForwardMessageDialog() {\n  return (\n    <ForwardMessageProvider>\n      <Dialog>\n        <ForwardMessageComposer />\n        <MessagePreview /> {/* Custom components can access state and actions */}\n        <DialogActions>\n          <CancelButton />\n          <ForwardButton /> {/* Custom components can access state and actions */}\n        </DialogActions>\n      </Dialog>\n    </ForwardMessageProvider>\n  )\n}\n\nfunction ForwardButton() {\n  const { actions } = use(Composer.Context)\n  return <Button onPress={actions.submit}>Forward</Button>\n}\n```\n\nThe ForwardButton lives outside the Composer.Frame but still has access to the\nsubmit action because it's within the provider. Even though it's a one-off\ncomponent, it can still access the composer's state and actions from outside the\nUI itself.\n\n**Key insight:** Components that need shared state don't have to be visually\nnested inside each other—they just need to be within the same provider.\n",
        "skills/data-fetching/SKILL.md": "---\nname: data-fetching\ndescription: Use when implementing or debugging ANY network request, API call, or data fetching. Covers fetch API, axios, React Query, SWR, error handling, caching strategies, offline support.\nversion: 1.0.0\nlicense: MIT\n---\n\n# Expo Networking\n\n**You MUST use this skill for ANY networking work including API requests, data fetching, caching, or network debugging.**\n\n## When to Use\n\nUse this router when:\n\n- Implementing API requests\n- Setting up data fetching (React Query, SWR)\n- Debugging network failures\n- Implementing caching strategies\n- Handling offline scenarios\n- Authentication/token management\n- Configuring API URLs and environment variables\n\n## Preferences\n\n- Avoid axios, prefer expo/fetch\n\n## Common Issues & Solutions\n\n### 1. Basic Fetch Usage\n\n**Simple GET request**:\n\n```tsx\nconst fetchUser = async (userId: string) => {\n  const response = await fetch(`https://api.example.com/users/${userId}`);\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  return response.json();\n};\n```\n\n**POST request with body**:\n\n```tsx\nconst createUser = async (userData: UserData) => {\n  const response = await fetch(\"https://api.example.com/users\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${token}`,\n    },\n    body: JSON.stringify(userData),\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message);\n  }\n\n  return response.json();\n};\n```\n\n---\n\n### 2. React Query (TanStack Query)\n\n**Setup**:\n\n```tsx\n// app/_layout.tsx\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 1000 * 60 * 5, // 5 minutes\n      retry: 2,\n    },\n  },\n});\n\nexport default function RootLayout() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Stack />\n    </QueryClientProvider>\n  );\n}\n```\n\n**Fetching data**:\n\n```tsx\nimport { useQuery } from \"@tanstack/react-query\";\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, isLoading, error, refetch } = useQuery({\n    queryKey: [\"user\", userId],\n    queryFn: () => fetchUser(userId),\n  });\n\n  if (isLoading) return <Loading />;\n  if (error) return <Error message={error.message} />;\n\n  return <Profile user={data} />;\n}\n```\n\n**Mutations**:\n\n```tsx\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\n\nfunction CreateUserForm() {\n  const queryClient = useQueryClient();\n\n  const mutation = useMutation({\n    mutationFn: createUser,\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: [\"users\"] });\n    },\n  });\n\n  const handleSubmit = (data: UserData) => {\n    mutation.mutate(data);\n  };\n\n  return <Form onSubmit={handleSubmit} isLoading={mutation.isPending} />;\n}\n```\n\n---\n\n### 3. Error Handling\n\n**Comprehensive error handling**:\n\n```tsx\nclass ApiError extends Error {\n  constructor(message: string, public status: number, public code?: string) {\n    super(message);\n    this.name = \"ApiError\";\n  }\n}\n\nconst fetchWithErrorHandling = async (url: string, options?: RequestInit) => {\n  try {\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({}));\n      throw new ApiError(\n        error.message || \"Request failed\",\n        response.status,\n        error.code\n      );\n    }\n\n    return response.json();\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n    // Network error (no internet, timeout, etc.)\n    throw new ApiError(\"Network error\", 0, \"NETWORK_ERROR\");\n  }\n};\n```\n\n**Retry logic**:\n\n```tsx\nconst fetchWithRetry = async (\n  url: string,\n  options?: RequestInit,\n  retries = 3\n) => {\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fetchWithErrorHandling(url, options);\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      // Exponential backoff\n      await new Promise((r) => setTimeout(r, Math.pow(2, i) * 1000));\n    }\n  }\n};\n```\n\n---\n\n### 4. Authentication\n\n**Token management**:\n\n```tsx\nimport * as SecureStore from \"expo-secure-store\";\n\nconst TOKEN_KEY = \"auth_token\";\n\nexport const auth = {\n  getToken: () => SecureStore.getItemAsync(TOKEN_KEY),\n  setToken: (token: string) => SecureStore.setItemAsync(TOKEN_KEY, token),\n  removeToken: () => SecureStore.deleteItemAsync(TOKEN_KEY),\n};\n\n// Authenticated fetch wrapper\nconst authFetch = async (url: string, options: RequestInit = {}) => {\n  const token = await auth.getToken();\n\n  return fetch(url, {\n    ...options,\n    headers: {\n      ...options.headers,\n      Authorization: token ? `Bearer ${token}` : \"\",\n    },\n  });\n};\n```\n\n**Token refresh**:\n\n```tsx\nlet isRefreshing = false;\nlet refreshPromise: Promise<string> | null = null;\n\nconst getValidToken = async (): Promise<string> => {\n  const token = await auth.getToken();\n\n  if (!token || isTokenExpired(token)) {\n    if (!isRefreshing) {\n      isRefreshing = true;\n      refreshPromise = refreshToken().finally(() => {\n        isRefreshing = false;\n        refreshPromise = null;\n      });\n    }\n    return refreshPromise!;\n  }\n\n  return token;\n};\n```\n\n---\n\n### 5. Offline Support\n\n**Check network status**:\n\n```tsx\nimport NetInfo from \"@react-native-community/netinfo\";\n\n// Hook for network status\nfunction useNetworkStatus() {\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n    return NetInfo.addEventListener((state) => {\n      setIsOnline(state.isConnected ?? true);\n    });\n  }, []);\n\n  return isOnline;\n}\n```\n\n**Offline-first with React Query**:\n\n```tsx\nimport { onlineManager } from \"@tanstack/react-query\";\nimport NetInfo from \"@react-native-community/netinfo\";\n\n// Sync React Query with network status\nonlineManager.setEventListener((setOnline) => {\n  return NetInfo.addEventListener((state) => {\n    setOnline(state.isConnected ?? true);\n  });\n});\n\n// Queries will pause when offline and resume when online\n```\n\n---\n\n### 6. Environment Variables\n\n**Using environment variables for API configuration**:\n\nExpo supports environment variables with the `EXPO_PUBLIC_` prefix. These are inlined at build time and available in your JavaScript code.\n\n```tsx\n// .env\nEXPO_PUBLIC_API_URL=https://api.example.com\nEXPO_PUBLIC_API_VERSION=v1\n\n// Usage in code\nconst API_URL = process.env.EXPO_PUBLIC_API_URL;\n\nconst fetchUsers = async () => {\n  const response = await fetch(`${API_URL}/users`);\n  return response.json();\n};\n```\n\n**Environment-specific configuration**:\n\n```tsx\n// .env.development\nEXPO_PUBLIC_API_URL=http://localhost:3000\n\n// .env.production\nEXPO_PUBLIC_API_URL=https://api.production.com\n```\n\n**Creating an API client with environment config**:\n\n```tsx\n// api/client.ts\nconst BASE_URL = process.env.EXPO_PUBLIC_API_URL;\n\nif (!BASE_URL) {\n  throw new Error(\"EXPO_PUBLIC_API_URL is not defined\");\n}\n\nexport const apiClient = {\n  get: async <T,>(path: string): Promise<T> => {\n    const response = await fetch(`${BASE_URL}${path}`);\n    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n    return response.json();\n  },\n\n  post: async <T,>(path: string, body: unknown): Promise<T> => {\n    const response = await fetch(`${BASE_URL}${path}`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(body),\n    });\n    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n    return response.json();\n  },\n};\n```\n\n**Important notes**:\n\n- Only variables prefixed with `EXPO_PUBLIC_` are exposed to the client bundle\n- Never put secrets (API keys with write access, database passwords) in `EXPO_PUBLIC_` variables—they're visible in the built app\n- Environment variables are inlined at **build time**, not runtime\n- Restart the dev server after changing `.env` files\n- For server-side secrets in API routes, use variables without the `EXPO_PUBLIC_` prefix\n\n**TypeScript support**:\n\n```tsx\n// types/env.d.ts\ndeclare global {\n  namespace NodeJS {\n    interface ProcessEnv {\n      EXPO_PUBLIC_API_URL: string;\n      EXPO_PUBLIC_API_VERSION?: string;\n    }\n  }\n}\n\nexport {};\n```\n\n---\n\n### 7. Request Cancellation\n\n**Cancel on unmount**:\n\n```tsx\nuseEffect(() => {\n  const controller = new AbortController();\n\n  fetch(url, { signal: controller.signal })\n    .then((response) => response.json())\n    .then(setData)\n    .catch((error) => {\n      if (error.name !== \"AbortError\") {\n        setError(error);\n      }\n    });\n\n  return () => controller.abort();\n}, [url]);\n```\n\n**With React Query** (automatic):\n\n```tsx\n// React Query automatically cancels requests when queries are invalidated\n// or components unmount\n```\n\n---\n\n## Decision Tree\n\n```\nUser asks about networking\n  |-- Basic fetch?\n  |   \\-- Use fetch API with error handling\n  |\n  |-- Need caching/state management?\n  |   |-- Complex app -> React Query (TanStack Query)\n  |   \\-- Simpler needs -> SWR or custom hooks\n  |\n  |-- Authentication?\n  |   |-- Token storage -> expo-secure-store\n  |   \\-- Token refresh -> Implement refresh flow\n  |\n  |-- Error handling?\n  |   |-- Network errors -> Check connectivity first\n  |   |-- HTTP errors -> Parse response, throw typed errors\n  |   \\-- Retries -> Exponential backoff\n  |\n  |-- Offline support?\n  |   |-- Check status -> NetInfo\n  |   \\-- Queue requests -> React Query persistence\n  |\n  |-- Environment/API config?\n  |   |-- Client-side URLs -> EXPO_PUBLIC_ prefix in .env\n  |   |-- Server secrets -> Non-prefixed env vars (API routes only)\n  |   \\-- Multiple environments -> .env.development, .env.production\n  |\n  \\-- Performance?\n      |-- Caching -> React Query with staleTime\n      |-- Deduplication -> React Query handles this\n      \\-- Cancellation -> AbortController or React Query\n```\n\n## Common Mistakes\n\n**Wrong: No error handling**\n\n```tsx\nconst data = await fetch(url).then((r) => r.json());\n```\n\n**Right: Check response status**\n\n```tsx\nconst response = await fetch(url);\nif (!response.ok) throw new Error(`HTTP ${response.status}`);\nconst data = await response.json();\n```\n\n**Wrong: Storing tokens in AsyncStorage**\n\n```tsx\nawait AsyncStorage.setItem(\"token\", token); // Not secure!\n```\n\n**Right: Use SecureStore for sensitive data**\n\n```tsx\nawait SecureStore.setItemAsync(\"token\", token);\n```\n\n## Example Invocations\n\nUser: \"How do I make API calls in React Native?\"\n-> Use fetch, wrap with error handling\n\nUser: \"Should I use React Query or SWR?\"\n-> React Query for complex apps, SWR for simpler needs\n\nUser: \"My app needs to work offline\"\n-> Use NetInfo for status, React Query persistence for caching\n\nUser: \"How do I handle authentication tokens?\"\n-> Store in expo-secure-store, implement refresh flow\n\nUser: \"API calls are slow\"\n-> Check caching strategy, use React Query staleTime\n\nUser: \"How do I configure different API URLs for dev and prod?\"\n-> Use EXPO*PUBLIC* env vars with .env.development and .env.production files\n\nUser: \"Where should I put my API key?\"\n-> Client-safe keys: EXPO*PUBLIC* in .env. Secret keys: non-prefixed env vars in API routes only\n",
        "skills/dev-client/SKILL.md": "---\nname: dev-client\ndescription: Build and distribute Expo development clients locally or via TestFlight\nversion: 1.0.0\nlicense: MIT\n---\n\nUse EAS Build to create development clients for testing native code changes on physical devices. Use this for creating custom Expo Go clients for testing branches of your app.\n\n## Important: When Development Clients Are Needed\n\n**Only create development clients when your app requires custom native code.** Most apps work fine in Expo Go.\n\nYou need a dev client ONLY when using:\n- Local Expo modules (custom native code)\n- Apple targets (widgets, app clips, extensions)\n- Third-party native modules not in Expo Go\n\n**Try Expo Go first** with `npx expo start`. If everything works, you don't need a dev client.\n\n## EAS Configuration\n\nEnsure `eas.json` has a development profile:\n\n```json\n{\n  \"cli\": {\n    \"version\": \">= 16.0.1\",\n    \"appVersionSource\": \"remote\"\n  },\n  \"build\": {\n    \"production\": {\n      \"autoIncrement\": true\n    },\n    \"development\": {\n      \"autoIncrement\": true,\n      \"developmentClient\": true\n    }\n  },\n  \"submit\": {\n    \"production\": {},\n    \"development\": {}\n  }\n}\n```\n\nKey settings:\n- `developmentClient: true` - Bundles expo-dev-client for development builds\n- `autoIncrement: true` - Automatically increments build numbers\n- `appVersionSource: \"remote\"` - Uses EAS as the source of truth for version numbers\n\n## Building for TestFlight\n\nBuild iOS dev client and submit to TestFlight in one command:\n\n```bash\neas build -p ios --profile development --submit\n```\n\nThis will:\n1. Build the development client in the cloud\n2. Automatically submit to App Store Connect\n3. Send you an email when the build is ready in TestFlight\n\nAfter receiving the TestFlight email:\n1. Download the build from TestFlight on your device\n2. Launch the app to see the expo-dev-client UI\n3. Connect to your local Metro bundler or scan a QR code\n\n## Building Locally\n\nBuild a development client on your machine:\n\n```bash\n# iOS (requires Xcode)\neas build -p ios --profile development --local\n\n# Android\neas build -p android --profile development --local\n```\n\nLocal builds output:\n- iOS: `.ipa` file\n- Android: `.apk` or `.aab` file\n\n## Installing Local Builds\n\nInstall iOS build on simulator:\n\n```bash\n# Find the .app in the .tar.gz output\ntar -xzf build-*.tar.gz\nxcrun simctl install booted ./path/to/App.app\n```\n\nInstall iOS build on device (requires signing):\n\n```bash\n# Use Xcode Devices window or ideviceinstaller\nideviceinstaller -i build.ipa\n```\n\nInstall Android build:\n\n```bash\nadb install build.apk\n```\n\n## Building for Specific Platform\n\n```bash\n# iOS only\neas build -p ios --profile development\n\n# Android only\neas build -p android --profile development\n\n# Both platforms\neas build --profile development\n```\n\n## Checking Build Status\n\n```bash\n# List recent builds\neas build:list\n\n# View build details\neas build:view\n```\n\n## Using the Dev Client\n\nOnce installed, the dev client provides:\n- **Development server connection** - Enter your Metro bundler URL or scan QR\n- **Build information** - View native build details\n- **Launcher UI** - Switch between development servers\n\nConnect to local development:\n\n```bash\n# Start Metro bundler\nnpx expo start --dev-client\n\n# Scan QR code with dev client or enter URL manually\n```\n\n## Troubleshooting\n\n**Build fails with signing errors:**\n```bash\neas credentials\n```\n\n**Clear build cache:**\n```bash\neas build -p ios --profile development --clear-cache\n```\n\n**Check EAS CLI version:**\n```bash\neas --version\neas update\n```\n",
        "skills/react-best-practices/AGENTS.md": "# React Best Practices\n\n**Version 1.0.0**  \nVercel Engineering  \nJanuary 2026\n\n> **Note:**  \n> This document is mainly for agents and LLMs to follow when maintaining,  \n> generating, or refactoring React and Next.js codebases. Humans  \n> may also find it useful, but guidance here is optimized for automation  \n> and consistency by AI-assisted workflows.\n\n---\n\n## Abstract\n\nComprehensive performance optimization guide for React and Next.js applications, designed for AI agents and LLMs. Contains 40+ rules across 8 categories, prioritized by impact from critical (eliminating waterfalls, reducing bundle size) to incremental (advanced patterns). Each rule includes detailed explanations, real-world examples comparing incorrect vs. correct implementations, and specific impact metrics to guide automated refactoring and code generation.\n\n---\n\n## Table of Contents\n\n1. [Eliminating Waterfalls](#1-eliminating-waterfalls) — **CRITICAL**\n   - 1.1 [Defer Await Until Needed](#11-defer-await-until-needed)\n   - 1.2 [Dependency-Based Parallelization](#12-dependency-based-parallelization)\n   - 1.3 [Prevent Waterfall Chains in API Routes](#13-prevent-waterfall-chains-in-api-routes)\n   - 1.4 [Promise.all() for Independent Operations](#14-promiseall-for-independent-operations)\n   - 1.5 [Strategic Suspense Boundaries](#15-strategic-suspense-boundaries)\n2. [Bundle Size Optimization](#2-bundle-size-optimization) — **CRITICAL**\n   - 2.1 [Avoid Barrel File Imports](#21-avoid-barrel-file-imports)\n   - 2.2 [Conditional Module Loading](#22-conditional-module-loading)\n   - 2.3 [Defer Non-Critical Third-Party Libraries](#23-defer-non-critical-third-party-libraries)\n   - 2.4 [Dynamic Imports for Heavy Components](#24-dynamic-imports-for-heavy-components)\n   - 2.5 [Preload Based on User Intent](#25-preload-based-on-user-intent)\n3. [Server-Side Performance](#3-server-side-performance) — **HIGH**\n   - 3.1 [Authenticate Server Actions Like API Routes](#31-authenticate-server-actions-like-api-routes)\n   - 3.2 [Avoid Duplicate Serialization in RSC Props](#32-avoid-duplicate-serialization-in-rsc-props)\n   - 3.3 [Cross-Request LRU Caching](#33-cross-request-lru-caching)\n   - 3.4 [Minimize Serialization at RSC Boundaries](#34-minimize-serialization-at-rsc-boundaries)\n   - 3.5 [Parallel Data Fetching with Component Composition](#35-parallel-data-fetching-with-component-composition)\n   - 3.6 [Per-Request Deduplication with React.cache()](#36-per-request-deduplication-with-reactcache)\n   - 3.7 [Use after() for Non-Blocking Operations](#37-use-after-for-non-blocking-operations)\n4. [Client-Side Data Fetching](#4-client-side-data-fetching) — **MEDIUM-HIGH**\n   - 4.1 [Deduplicate Global Event Listeners](#41-deduplicate-global-event-listeners)\n   - 4.2 [Use Passive Event Listeners for Scrolling Performance](#42-use-passive-event-listeners-for-scrolling-performance)\n   - 4.3 [Use SWR for Automatic Deduplication](#43-use-swr-for-automatic-deduplication)\n   - 4.4 [Version and Minimize localStorage Data](#44-version-and-minimize-localstorage-data)\n5. [Re-render Optimization](#5-re-render-optimization) — **MEDIUM**\n   - 5.1 [Calculate Derived State During Rendering](#51-calculate-derived-state-during-rendering)\n   - 5.2 [Defer State Reads to Usage Point](#52-defer-state-reads-to-usage-point)\n   - 5.3 [Do not wrap a simple expression with a primitive result type in useMemo](#53-do-not-wrap-a-simple-expression-with-a-primitive-result-type-in-usememo)\n   - 5.4 [Extract Default Non-primitive Parameter Value from Memoized Component to Constant](#54-extract-default-non-primitive-parameter-value-from-memoized-component-to-constant)\n   - 5.5 [Extract to Memoized Components](#55-extract-to-memoized-components)\n   - 5.6 [Narrow Effect Dependencies](#56-narrow-effect-dependencies)\n   - 5.7 [Put Interaction Logic in Event Handlers](#57-put-interaction-logic-in-event-handlers)\n   - 5.8 [Subscribe to Derived State](#58-subscribe-to-derived-state)\n   - 5.9 [Use Functional setState Updates](#59-use-functional-setstate-updates)\n   - 5.10 [Use Lazy State Initialization](#510-use-lazy-state-initialization)\n   - 5.11 [Use Transitions for Non-Urgent Updates](#511-use-transitions-for-non-urgent-updates)\n   - 5.12 [Use useRef for Transient Values](#512-use-useref-for-transient-values)\n6. [Rendering Performance](#6-rendering-performance) — **MEDIUM**\n   - 6.1 [Animate SVG Wrapper Instead of SVG Element](#61-animate-svg-wrapper-instead-of-svg-element)\n   - 6.2 [CSS content-visibility for Long Lists](#62-css-content-visibility-for-long-lists)\n   - 6.3 [Hoist Static JSX Elements](#63-hoist-static-jsx-elements)\n   - 6.4 [Optimize SVG Precision](#64-optimize-svg-precision)\n   - 6.5 [Prevent Hydration Mismatch Without Flickering](#65-prevent-hydration-mismatch-without-flickering)\n   - 6.6 [Suppress Expected Hydration Mismatches](#66-suppress-expected-hydration-mismatches)\n   - 6.7 [Use Activity Component for Show/Hide](#67-use-activity-component-for-showhide)\n   - 6.8 [Use Explicit Conditional Rendering](#68-use-explicit-conditional-rendering)\n   - 6.9 [Use useTransition Over Manual Loading States](#69-use-usetransition-over-manual-loading-states)\n7. [JavaScript Performance](#7-javascript-performance) — **LOW-MEDIUM**\n   - 7.1 [Avoid Layout Thrashing](#71-avoid-layout-thrashing)\n   - 7.2 [Build Index Maps for Repeated Lookups](#72-build-index-maps-for-repeated-lookups)\n   - 7.3 [Cache Property Access in Loops](#73-cache-property-access-in-loops)\n   - 7.4 [Cache Repeated Function Calls](#74-cache-repeated-function-calls)\n   - 7.5 [Cache Storage API Calls](#75-cache-storage-api-calls)\n   - 7.6 [Combine Multiple Array Iterations](#76-combine-multiple-array-iterations)\n   - 7.7 [Early Length Check for Array Comparisons](#77-early-length-check-for-array-comparisons)\n   - 7.8 [Early Return from Functions](#78-early-return-from-functions)\n   - 7.9 [Hoist RegExp Creation](#79-hoist-regexp-creation)\n   - 7.10 [Use Loop for Min/Max Instead of Sort](#710-use-loop-for-minmax-instead-of-sort)\n   - 7.11 [Use Set/Map for O(1) Lookups](#711-use-setmap-for-o1-lookups)\n   - 7.12 [Use toSorted() Instead of sort() for Immutability](#712-use-tosorted-instead-of-sort-for-immutability)\n8. [Advanced Patterns](#8-advanced-patterns) — **LOW**\n   - 8.1 [Initialize App Once, Not Per Mount](#81-initialize-app-once-not-per-mount)\n   - 8.2 [Store Event Handlers in Refs](#82-store-event-handlers-in-refs)\n   - 8.3 [useEffectEvent for Stable Callback Refs](#83-useeffectevent-for-stable-callback-refs)\n\n---\n\n## 1. Eliminating Waterfalls\n\n**Impact: CRITICAL**\n\nWaterfalls are the #1 performance killer. Each sequential await adds full network latency. Eliminating them yields the largest gains.\n\n### 1.1 Defer Await Until Needed\n\n**Impact: HIGH (avoids blocking unused code paths)**\n\nMove `await` operations into the branches where they're actually used to avoid blocking code paths that don't need them.\n\n**Incorrect: blocks both branches**\n\n```typescript\nasync function handleRequest(userId: string, skipProcessing: boolean) {\n  const userData = await fetchUserData(userId)\n  \n  if (skipProcessing) {\n    // Returns immediately but still waited for userData\n    return { skipped: true }\n  }\n  \n  // Only this branch uses userData\n  return processUserData(userData)\n}\n```\n\n**Correct: only blocks when needed**\n\n```typescript\nasync function handleRequest(userId: string, skipProcessing: boolean) {\n  if (skipProcessing) {\n    // Returns immediately without waiting\n    return { skipped: true }\n  }\n  \n  // Fetch only when needed\n  const userData = await fetchUserData(userId)\n  return processUserData(userData)\n}\n```\n\n**Another example: early return optimization**\n\n```typescript\n// Incorrect: always fetches permissions\nasync function updateResource(resourceId: string, userId: string) {\n  const permissions = await fetchPermissions(userId)\n  const resource = await getResource(resourceId)\n  \n  if (!resource) {\n    return { error: 'Not found' }\n  }\n  \n  if (!permissions.canEdit) {\n    return { error: 'Forbidden' }\n  }\n  \n  return await updateResourceData(resource, permissions)\n}\n\n// Correct: fetches only when needed\nasync function updateResource(resourceId: string, userId: string) {\n  const resource = await getResource(resourceId)\n  \n  if (!resource) {\n    return { error: 'Not found' }\n  }\n  \n  const permissions = await fetchPermissions(userId)\n  \n  if (!permissions.canEdit) {\n    return { error: 'Forbidden' }\n  }\n  \n  return await updateResourceData(resource, permissions)\n}\n```\n\nThis optimization is especially valuable when the skipped branch is frequently taken, or when the deferred operation is expensive.\n\n### 1.2 Dependency-Based Parallelization\n\n**Impact: CRITICAL (2-10× improvement)**\n\nFor operations with partial dependencies, use `better-all` to maximize parallelism. It automatically starts each task at the earliest possible moment.\n\n**Incorrect: profile waits for config unnecessarily**\n\n```typescript\nconst [user, config] = await Promise.all([\n  fetchUser(),\n  fetchConfig()\n])\nconst profile = await fetchProfile(user.id)\n```\n\n**Correct: config and profile run in parallel**\n\n```typescript\nimport { all } from 'better-all'\n\nconst { user, config, profile } = await all({\n  async user() { return fetchUser() },\n  async config() { return fetchConfig() },\n  async profile() {\n    return fetchProfile((await this.$.user).id)\n  }\n})\n```\n\n**Alternative without extra dependencies:**\n\n```typescript\nconst userPromise = fetchUser()\nconst profilePromise = userPromise.then(user => fetchProfile(user.id))\n\nconst [user, config, profile] = await Promise.all([\n  userPromise,\n  fetchConfig(),\n  profilePromise\n])\n```\n\nWe can also create all the promises first, and do `Promise.all()` at the end.\n\nReference: [https://github.com/shuding/better-all](https://github.com/shuding/better-all)\n\n### 1.3 Prevent Waterfall Chains in API Routes\n\n**Impact: CRITICAL (2-10× improvement)**\n\nIn API routes and Server Actions, start independent operations immediately, even if you don't await them yet.\n\n**Incorrect: config waits for auth, data waits for both**\n\n```typescript\nexport async function GET(request: Request) {\n  const session = await auth()\n  const config = await fetchConfig()\n  const data = await fetchData(session.user.id)\n  return Response.json({ data, config })\n}\n```\n\n**Correct: auth and config start immediately**\n\n```typescript\nexport async function GET(request: Request) {\n  const sessionPromise = auth()\n  const configPromise = fetchConfig()\n  const session = await sessionPromise\n  const [config, data] = await Promise.all([\n    configPromise,\n    fetchData(session.user.id)\n  ])\n  return Response.json({ data, config })\n}\n```\n\nFor operations with more complex dependency chains, use `better-all` to automatically maximize parallelism (see Dependency-Based Parallelization).\n\n### 1.4 Promise.all() for Independent Operations\n\n**Impact: CRITICAL (2-10× improvement)**\n\nWhen async operations have no interdependencies, execute them concurrently using `Promise.all()`.\n\n**Incorrect: sequential execution, 3 round trips**\n\n```typescript\nconst user = await fetchUser()\nconst posts = await fetchPosts()\nconst comments = await fetchComments()\n```\n\n**Correct: parallel execution, 1 round trip**\n\n```typescript\nconst [user, posts, comments] = await Promise.all([\n  fetchUser(),\n  fetchPosts(),\n  fetchComments()\n])\n```\n\n### 1.5 Strategic Suspense Boundaries\n\n**Impact: HIGH (faster initial paint)**\n\nInstead of awaiting data in async components before returning JSX, use Suspense boundaries to show the wrapper UI faster while data loads.\n\n**Incorrect: wrapper blocked by data fetching**\n\n```tsx\nasync function Page() {\n  const data = await fetchData() // Blocks entire page\n  \n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <div>\n        <DataDisplay data={data} />\n      </div>\n      <div>Footer</div>\n    </div>\n  )\n}\n```\n\nThe entire layout waits for data even though only the middle section needs it.\n\n**Correct: wrapper shows immediately, data streams in**\n\n```tsx\nfunction Page() {\n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <div>\n        <Suspense fallback={<Skeleton />}>\n          <DataDisplay />\n        </Suspense>\n      </div>\n      <div>Footer</div>\n    </div>\n  )\n}\n\nasync function DataDisplay() {\n  const data = await fetchData() // Only blocks this component\n  return <div>{data.content}</div>\n}\n```\n\nSidebar, Header, and Footer render immediately. Only DataDisplay waits for data.\n\n**Alternative: share promise across components**\n\n```tsx\nfunction Page() {\n  // Start fetch immediately, but don't await\n  const dataPromise = fetchData()\n  \n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <Suspense fallback={<Skeleton />}>\n        <DataDisplay dataPromise={dataPromise} />\n        <DataSummary dataPromise={dataPromise} />\n      </Suspense>\n      <div>Footer</div>\n    </div>\n  )\n}\n\nfunction DataDisplay({ dataPromise }: { dataPromise: Promise<Data> }) {\n  const data = use(dataPromise) // Unwraps the promise\n  return <div>{data.content}</div>\n}\n\nfunction DataSummary({ dataPromise }: { dataPromise: Promise<Data> }) {\n  const data = use(dataPromise) // Reuses the same promise\n  return <div>{data.summary}</div>\n}\n```\n\nBoth components share the same promise, so only one fetch occurs. Layout renders immediately while both components wait together.\n\n**When NOT to use this pattern:**\n\n- Critical data needed for layout decisions (affects positioning)\n\n- SEO-critical content above the fold\n\n- Small, fast queries where suspense overhead isn't worth it\n\n- When you want to avoid layout shift (loading → content jump)\n\n**Trade-off:** Faster initial paint vs potential layout shift. Choose based on your UX priorities.\n\n---\n\n## 2. Bundle Size Optimization\n\n**Impact: CRITICAL**\n\nReducing initial bundle size improves Time to Interactive and Largest Contentful Paint.\n\n### 2.1 Avoid Barrel File Imports\n\n**Impact: CRITICAL (200-800ms import cost, slow builds)**\n\nImport directly from source files instead of barrel files to avoid loading thousands of unused modules. **Barrel files** are entry points that re-export multiple modules (e.g., `index.js` that does `export * from './module'`).\n\nPopular icon and component libraries can have **up to 10,000 re-exports** in their entry file. For many React packages, **it takes 200-800ms just to import them**, affecting both development speed and production cold starts.\n\n**Why tree-shaking doesn't help:** When a library is marked as external (not bundled), the bundler can't optimize it. If you bundle it to enable tree-shaking, builds become substantially slower analyzing the entire module graph.\n\n**Incorrect: imports entire library**\n\n```tsx\nimport { Check, X, Menu } from 'lucide-react'\n// Loads 1,583 modules, takes ~2.8s extra in dev\n// Runtime cost: 200-800ms on every cold start\n\nimport { Button, TextField } from '@mui/material'\n// Loads 2,225 modules, takes ~4.2s extra in dev\n```\n\n**Correct: imports only what you need**\n\n```tsx\nimport Check from 'lucide-react/dist/esm/icons/check'\nimport X from 'lucide-react/dist/esm/icons/x'\nimport Menu from 'lucide-react/dist/esm/icons/menu'\n// Loads only 3 modules (~2KB vs ~1MB)\n\nimport Button from '@mui/material/Button'\nimport TextField from '@mui/material/TextField'\n// Loads only what you use\n```\n\n**Alternative: Next.js 13.5+**\n\n```js\n// next.config.js - use optimizePackageImports\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['lucide-react', '@mui/material']\n  }\n}\n\n// Then you can keep the ergonomic barrel imports:\nimport { Check, X, Menu } from 'lucide-react'\n// Automatically transformed to direct imports at build time\n```\n\nDirect imports provide 15-70% faster dev boot, 28% faster builds, 40% faster cold starts, and significantly faster HMR.\n\nLibraries commonly affected: `lucide-react`, `@mui/material`, `@mui/icons-material`, `@tabler/icons-react`, `react-icons`, `@headlessui/react`, `@radix-ui/react-*`, `lodash`, `ramda`, `date-fns`, `rxjs`, `react-use`.\n\nReference: [https://vercel.com/blog/how-we-optimized-package-imports-in-next-js](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)\n\n### 2.2 Conditional Module Loading\n\n**Impact: HIGH (loads large data only when needed)**\n\nLoad large data or modules only when a feature is activated.\n\n**Example: lazy-load animation frames**\n\n```tsx\nfunction AnimationPlayer({ enabled, setEnabled }: { enabled: boolean; setEnabled: React.Dispatch<React.SetStateAction<boolean>> }) {\n  const [frames, setFrames] = useState<Frame[] | null>(null)\n\n  useEffect(() => {\n    if (enabled && !frames && typeof window !== 'undefined') {\n      import('./animation-frames.js')\n        .then(mod => setFrames(mod.frames))\n        .catch(() => setEnabled(false))\n    }\n  }, [enabled, frames, setEnabled])\n\n  if (!frames) return <Skeleton />\n  return <Canvas frames={frames} />\n}\n```\n\nThe `typeof window !== 'undefined'` check prevents bundling this module for SSR, optimizing server bundle size and build speed.\n\n### 2.3 Defer Non-Critical Third-Party Libraries\n\n**Impact: MEDIUM (loads after hydration)**\n\nAnalytics, logging, and error tracking don't block user interaction. Load them after hydration.\n\n**Incorrect: blocks initial bundle**\n\n```tsx\nimport { Analytics } from '@vercel/analytics/react'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  )\n}\n```\n\n**Correct: loads after hydration**\n\n```tsx\nimport dynamic from 'next/dynamic'\n\nconst Analytics = dynamic(\n  () => import('@vercel/analytics/react').then(m => m.Analytics),\n  { ssr: false }\n)\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  )\n}\n```\n\n### 2.4 Dynamic Imports for Heavy Components\n\n**Impact: CRITICAL (directly affects TTI and LCP)**\n\nUse `next/dynamic` to lazy-load large components not needed on initial render.\n\n**Incorrect: Monaco bundles with main chunk ~300KB**\n\n```tsx\nimport { MonacoEditor } from './monaco-editor'\n\nfunction CodePanel({ code }: { code: string }) {\n  return <MonacoEditor value={code} />\n}\n```\n\n**Correct: Monaco loads on demand**\n\n```tsx\nimport dynamic from 'next/dynamic'\n\nconst MonacoEditor = dynamic(\n  () => import('./monaco-editor').then(m => m.MonacoEditor),\n  { ssr: false }\n)\n\nfunction CodePanel({ code }: { code: string }) {\n  return <MonacoEditor value={code} />\n}\n```\n\n### 2.5 Preload Based on User Intent\n\n**Impact: MEDIUM (reduces perceived latency)**\n\nPreload heavy bundles before they're needed to reduce perceived latency.\n\n**Example: preload on hover/focus**\n\n```tsx\nfunction EditorButton({ onClick }: { onClick: () => void }) {\n  const preload = () => {\n    if (typeof window !== 'undefined') {\n      void import('./monaco-editor')\n    }\n  }\n\n  return (\n    <button\n      onMouseEnter={preload}\n      onFocus={preload}\n      onClick={onClick}\n    >\n      Open Editor\n    </button>\n  )\n}\n```\n\n**Example: preload when feature flag is enabled**\n\n```tsx\nfunction FlagsProvider({ children, flags }: Props) {\n  useEffect(() => {\n    if (flags.editorEnabled && typeof window !== 'undefined') {\n      void import('./monaco-editor').then(mod => mod.init())\n    }\n  }, [flags.editorEnabled])\n\n  return <FlagsContext.Provider value={flags}>\n    {children}\n  </FlagsContext.Provider>\n}\n```\n\nThe `typeof window !== 'undefined'` check prevents bundling preloaded modules for SSR, optimizing server bundle size and build speed.\n\n---\n\n## 3. Server-Side Performance\n\n**Impact: HIGH**\n\nOptimizing server-side rendering and data fetching eliminates server-side waterfalls and reduces response times.\n\n### 3.1 Authenticate Server Actions Like API Routes\n\n**Impact: CRITICAL (prevents unauthorized access to server mutations)**\n\nServer Actions (functions with `\"use server\"`) are exposed as public endpoints, just like API routes. Always verify authentication and authorization **inside** each Server Action—do not rely solely on middleware, layout guards, or page-level checks, as Server Actions can be invoked directly.\n\nNext.js documentation explicitly states: \"Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.\"\n\n**Incorrect: no authentication check**\n\n```typescript\n'use server'\n\nexport async function deleteUser(userId: string) {\n  // Anyone can call this! No auth check\n  await db.user.delete({ where: { id: userId } })\n  return { success: true }\n}\n```\n\n**Correct: authentication inside the action**\n\n```typescript\n'use server'\n\nimport { verifySession } from '@/lib/auth'\nimport { unauthorized } from '@/lib/errors'\n\nexport async function deleteUser(userId: string) {\n  // Always check auth inside the action\n  const session = await verifySession()\n  \n  if (!session) {\n    throw unauthorized('Must be logged in')\n  }\n  \n  // Check authorization too\n  if (session.user.role !== 'admin' && session.user.id !== userId) {\n    throw unauthorized('Cannot delete other users')\n  }\n  \n  await db.user.delete({ where: { id: userId } })\n  return { success: true }\n}\n```\n\n**With input validation:**\n\n```typescript\n'use server'\n\nimport { verifySession } from '@/lib/auth'\nimport { z } from 'zod'\n\nconst updateProfileSchema = z.object({\n  userId: z.string().uuid(),\n  name: z.string().min(1).max(100),\n  email: z.string().email()\n})\n\nexport async function updateProfile(data: unknown) {\n  // Validate input first\n  const validated = updateProfileSchema.parse(data)\n  \n  // Then authenticate\n  const session = await verifySession()\n  if (!session) {\n    throw new Error('Unauthorized')\n  }\n  \n  // Then authorize\n  if (session.user.id !== validated.userId) {\n    throw new Error('Can only update own profile')\n  }\n  \n  // Finally perform the mutation\n  await db.user.update({\n    where: { id: validated.userId },\n    data: {\n      name: validated.name,\n      email: validated.email\n    }\n  })\n  \n  return { success: true }\n}\n```\n\nReference: [https://nextjs.org/docs/app/guides/authentication](https://nextjs.org/docs/app/guides/authentication)\n\n### 3.2 Avoid Duplicate Serialization in RSC Props\n\n**Impact: LOW (reduces network payload by avoiding duplicate serialization)**\n\nRSC→client serialization deduplicates by object reference, not value. Same reference = serialized once; new reference = serialized again. Do transformations (`.toSorted()`, `.filter()`, `.map()`) in client, not server.\n\n**Incorrect: duplicates array**\n\n```tsx\n// RSC: sends 6 strings (2 arrays × 3 items)\n<ClientList usernames={usernames} usernamesOrdered={usernames.toSorted()} />\n```\n\n**Correct: sends 3 strings**\n\n```tsx\n// RSC: send once\n<ClientList usernames={usernames} />\n\n// Client: transform there\n'use client'\nconst sorted = useMemo(() => [...usernames].sort(), [usernames])\n```\n\n**Nested deduplication behavior:**\n\n```tsx\n// string[] - duplicates everything\nusernames={['a','b']} sorted={usernames.toSorted()} // sends 4 strings\n\n// object[] - duplicates array structure only\nusers={[{id:1},{id:2}]} sorted={users.toSorted()} // sends 2 arrays + 2 unique objects (not 4)\n```\n\nDeduplication works recursively. Impact varies by data type:\n\n- `string[]`, `number[]`, `boolean[]`: **HIGH impact** - array + all primitives fully duplicated\n\n- `object[]`: **LOW impact** - array duplicated, but nested objects deduplicated by reference\n\n**Operations breaking deduplication: create new references**\n\n- Arrays: `.toSorted()`, `.filter()`, `.map()`, `.slice()`, `[...arr]`\n\n- Objects: `{...obj}`, `Object.assign()`, `structuredClone()`, `JSON.parse(JSON.stringify())`\n\n**More examples:**\n\n```tsx\n// ❌ Bad\n<C users={users} active={users.filter(u => u.active)} />\n<C product={product} productName={product.name} />\n\n// ✅ Good\n<C users={users} />\n<C product={product} />\n// Do filtering/destructuring in client\n```\n\n**Exception:** Pass derived data when transformation is expensive or client doesn't need original.\n\n### 3.3 Cross-Request LRU Caching\n\n**Impact: HIGH (caches across requests)**\n\n`React.cache()` only works within one request. For data shared across sequential requests (user clicks button A then button B), use an LRU cache.\n\n**Implementation:**\n\n```typescript\nimport { LRUCache } from 'lru-cache'\n\nconst cache = new LRUCache<string, any>({\n  max: 1000,\n  ttl: 5 * 60 * 1000  // 5 minutes\n})\n\nexport async function getUser(id: string) {\n  const cached = cache.get(id)\n  if (cached) return cached\n\n  const user = await db.user.findUnique({ where: { id } })\n  cache.set(id, user)\n  return user\n}\n\n// Request 1: DB query, result cached\n// Request 2: cache hit, no DB query\n```\n\nUse when sequential user actions hit multiple endpoints needing the same data within seconds.\n\n**With Vercel's [Fluid Compute](https://vercel.com/docs/fluid-compute):** LRU caching is especially effective because multiple concurrent requests can share the same function instance and cache. This means the cache persists across requests without needing external storage like Redis.\n\n**In traditional serverless:** Each invocation runs in isolation, so consider Redis for cross-process caching.\n\nReference: [https://github.com/isaacs/node-lru-cache](https://github.com/isaacs/node-lru-cache)\n\n### 3.4 Minimize Serialization at RSC Boundaries\n\n**Impact: HIGH (reduces data transfer size)**\n\nThe React Server/Client boundary serializes all object properties into strings and embeds them in the HTML response and subsequent RSC requests. This serialized data directly impacts page weight and load time, so **size matters a lot**. Only pass fields that the client actually uses.\n\n**Incorrect: serializes all 50 fields**\n\n```tsx\nasync function Page() {\n  const user = await fetchUser()  // 50 fields\n  return <Profile user={user} />\n}\n\n'use client'\nfunction Profile({ user }: { user: User }) {\n  return <div>{user.name}</div>  // uses 1 field\n}\n```\n\n**Correct: serializes only 1 field**\n\n```tsx\nasync function Page() {\n  const user = await fetchUser()\n  return <Profile name={user.name} />\n}\n\n'use client'\nfunction Profile({ name }: { name: string }) {\n  return <div>{name}</div>\n}\n```\n\n### 3.5 Parallel Data Fetching with Component Composition\n\n**Impact: CRITICAL (eliminates server-side waterfalls)**\n\nReact Server Components execute sequentially within a tree. Restructure with composition to parallelize data fetching.\n\n**Incorrect: Sidebar waits for Page's fetch to complete**\n\n```tsx\nexport default async function Page() {\n  const header = await fetchHeader()\n  return (\n    <div>\n      <div>{header}</div>\n      <Sidebar />\n    </div>\n  )\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n```\n\n**Correct: both fetch simultaneously**\n\n```tsx\nasync function Header() {\n  const data = await fetchHeader()\n  return <div>{data}</div>\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n\nexport default function Page() {\n  return (\n    <div>\n      <Header />\n      <Sidebar />\n    </div>\n  )\n}\n```\n\n**Alternative with children prop:**\n\n```tsx\nasync function Header() {\n  const data = await fetchHeader()\n  return <div>{data}</div>\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n\nfunction Layout({ children }: { children: ReactNode }) {\n  return (\n    <div>\n      <Header />\n      {children}\n    </div>\n  )\n}\n\nexport default function Page() {\n  return (\n    <Layout>\n      <Sidebar />\n    </Layout>\n  )\n}\n```\n\n### 3.6 Per-Request Deduplication with React.cache()\n\n**Impact: MEDIUM (deduplicates within request)**\n\nUse `React.cache()` for server-side request deduplication. Authentication and database queries benefit most.\n\n**Usage:**\n\n```typescript\nimport { cache } from 'react'\n\nexport const getCurrentUser = cache(async () => {\n  const session = await auth()\n  if (!session?.user?.id) return null\n  return await db.user.findUnique({\n    where: { id: session.user.id }\n  })\n})\n```\n\nWithin a single request, multiple calls to `getCurrentUser()` execute the query only once.\n\n**Avoid inline objects as arguments:**\n\n`React.cache()` uses shallow equality (`Object.is`) to determine cache hits. Inline objects create new references each call, preventing cache hits.\n\n**Incorrect: always cache miss**\n\n```typescript\nconst getUser = cache(async (params: { uid: number }) => {\n  return await db.user.findUnique({ where: { id: params.uid } })\n})\n\n// Each call creates new object, never hits cache\ngetUser({ uid: 1 })\ngetUser({ uid: 1 })  // Cache miss, runs query again\n```\n\n**Correct: cache hit**\n\n```typescript\nconst params = { uid: 1 }\ngetUser(params)  // Query runs\ngetUser(params)  // Cache hit (same reference)\n```\n\nIf you must pass objects, pass the same reference:\n\n**Next.js-Specific Note:**\n\nIn Next.js, the `fetch` API is automatically extended with request memoization. Requests with the same URL and options are automatically deduplicated within a single request, so you don't need `React.cache()` for `fetch` calls. However, `React.cache()` is still essential for other async tasks:\n\n- Database queries (Prisma, Drizzle, etc.)\n\n- Heavy computations\n\n- Authentication checks\n\n- File system operations\n\n- Any non-fetch async work\n\nUse `React.cache()` to deduplicate these operations across your component tree.\n\nReference: [https://react.dev/reference/react/cache](https://react.dev/reference/react/cache)\n\n### 3.7 Use after() for Non-Blocking Operations\n\n**Impact: MEDIUM (faster response times)**\n\nUse Next.js's `after()` to schedule work that should execute after a response is sent. This prevents logging, analytics, and other side effects from blocking the response.\n\n**Incorrect: blocks response**\n\n```tsx\nimport { logUserAction } from '@/app/utils'\n\nexport async function POST(request: Request) {\n  // Perform mutation\n  await updateDatabase(request)\n  \n  // Logging blocks the response\n  const userAgent = request.headers.get('user-agent') || 'unknown'\n  await logUserAction({ userAgent })\n  \n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' }\n  })\n}\n```\n\n**Correct: non-blocking**\n\n```tsx\nimport { after } from 'next/server'\nimport { headers, cookies } from 'next/headers'\nimport { logUserAction } from '@/app/utils'\n\nexport async function POST(request: Request) {\n  // Perform mutation\n  await updateDatabase(request)\n  \n  // Log after response is sent\n  after(async () => {\n    const userAgent = (await headers()).get('user-agent') || 'unknown'\n    const sessionCookie = (await cookies()).get('session-id')?.value || 'anonymous'\n    \n    logUserAction({ sessionCookie, userAgent })\n  })\n  \n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' }\n  })\n}\n```\n\nThe response is sent immediately while logging happens in the background.\n\n**Common use cases:**\n\n- Analytics tracking\n\n- Audit logging\n\n- Sending notifications\n\n- Cache invalidation\n\n- Cleanup tasks\n\n**Important notes:**\n\n- `after()` runs even if the response fails or redirects\n\n- Works in Server Actions, Route Handlers, and Server Components\n\nReference: [https://nextjs.org/docs/app/api-reference/functions/after](https://nextjs.org/docs/app/api-reference/functions/after)\n\n---\n\n## 4. Client-Side Data Fetching\n\n**Impact: MEDIUM-HIGH**\n\nAutomatic deduplication and efficient data fetching patterns reduce redundant network requests.\n\n### 4.1 Deduplicate Global Event Listeners\n\n**Impact: LOW (single listener for N components)**\n\nUse `useSWRSubscription()` to share global event listeners across component instances.\n\n**Incorrect: N instances = N listeners**\n\n```tsx\nfunction useKeyboardShortcut(key: string, callback: () => void) {\n  useEffect(() => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.metaKey && e.key === key) {\n        callback()\n      }\n    }\n    window.addEventListener('keydown', handler)\n    return () => window.removeEventListener('keydown', handler)\n  }, [key, callback])\n}\n```\n\nWhen using the `useKeyboardShortcut` hook multiple times, each instance will register a new listener.\n\n**Correct: N instances = 1 listener**\n\n```tsx\nimport useSWRSubscription from 'swr/subscription'\n\n// Module-level Map to track callbacks per key\nconst keyCallbacks = new Map<string, Set<() => void>>()\n\nfunction useKeyboardShortcut(key: string, callback: () => void) {\n  // Register this callback in the Map\n  useEffect(() => {\n    if (!keyCallbacks.has(key)) {\n      keyCallbacks.set(key, new Set())\n    }\n    keyCallbacks.get(key)!.add(callback)\n\n    return () => {\n      const set = keyCallbacks.get(key)\n      if (set) {\n        set.delete(callback)\n        if (set.size === 0) {\n          keyCallbacks.delete(key)\n        }\n      }\n    }\n  }, [key, callback])\n\n  useSWRSubscription('global-keydown', () => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.metaKey && keyCallbacks.has(e.key)) {\n        keyCallbacks.get(e.key)!.forEach(cb => cb())\n      }\n    }\n    window.addEventListener('keydown', handler)\n    return () => window.removeEventListener('keydown', handler)\n  })\n}\n\nfunction Profile() {\n  // Multiple shortcuts will share the same listener\n  useKeyboardShortcut('p', () => { /* ... */ }) \n  useKeyboardShortcut('k', () => { /* ... */ })\n  // ...\n}\n```\n\n### 4.2 Use Passive Event Listeners for Scrolling Performance\n\n**Impact: MEDIUM (eliminates scroll delay caused by event listeners)**\n\nAdd `{ passive: true }` to touch and wheel event listeners to enable immediate scrolling. Browsers normally wait for listeners to finish to check if `preventDefault()` is called, causing scroll delay.\n\n**Incorrect:**\n\n```typescript\nuseEffect(() => {\n  const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)\n  const handleWheel = (e: WheelEvent) => console.log(e.deltaY)\n  \n  document.addEventListener('touchstart', handleTouch)\n  document.addEventListener('wheel', handleWheel)\n  \n  return () => {\n    document.removeEventListener('touchstart', handleTouch)\n    document.removeEventListener('wheel', handleWheel)\n  }\n}, [])\n```\n\n**Correct:**\n\n```typescript\nuseEffect(() => {\n  const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)\n  const handleWheel = (e: WheelEvent) => console.log(e.deltaY)\n  \n  document.addEventListener('touchstart', handleTouch, { passive: true })\n  document.addEventListener('wheel', handleWheel, { passive: true })\n  \n  return () => {\n    document.removeEventListener('touchstart', handleTouch)\n    document.removeEventListener('wheel', handleWheel)\n  }\n}, [])\n```\n\n**Use passive when:** tracking/analytics, logging, any listener that doesn't call `preventDefault()`.\n\n**Don't use passive when:** implementing custom swipe gestures, custom zoom controls, or any listener that needs `preventDefault()`.\n\n### 4.3 Use SWR for Automatic Deduplication\n\n**Impact: MEDIUM-HIGH (automatic deduplication)**\n\nSWR enables request deduplication, caching, and revalidation across component instances.\n\n**Incorrect: no deduplication, each instance fetches**\n\n```tsx\nfunction UserList() {\n  const [users, setUsers] = useState([])\n  useEffect(() => {\n    fetch('/api/users')\n      .then(r => r.json())\n      .then(setUsers)\n  }, [])\n}\n```\n\n**Correct: multiple instances share one request**\n\n```tsx\nimport useSWR from 'swr'\n\nfunction UserList() {\n  const { data: users } = useSWR('/api/users', fetcher)\n}\n```\n\n**For immutable data:**\n\n```tsx\nimport { useImmutableSWR } from '@/lib/swr'\n\nfunction StaticContent() {\n  const { data } = useImmutableSWR('/api/config', fetcher)\n}\n```\n\n**For mutations:**\n\n```tsx\nimport { useSWRMutation } from 'swr/mutation'\n\nfunction UpdateButton() {\n  const { trigger } = useSWRMutation('/api/user', updateUser)\n  return <button onClick={() => trigger()}>Update</button>\n}\n```\n\nReference: [https://swr.vercel.app](https://swr.vercel.app)\n\n### 4.4 Version and Minimize localStorage Data\n\n**Impact: MEDIUM (prevents schema conflicts, reduces storage size)**\n\nAdd version prefix to keys and store only needed fields. Prevents schema conflicts and accidental storage of sensitive data.\n\n**Incorrect:**\n\n```typescript\n// No version, stores everything, no error handling\nlocalStorage.setItem('userConfig', JSON.stringify(fullUserObject))\nconst data = localStorage.getItem('userConfig')\n```\n\n**Correct:**\n\n```typescript\nconst VERSION = 'v2'\n\nfunction saveConfig(config: { theme: string; language: string }) {\n  try {\n    localStorage.setItem(`userConfig:${VERSION}`, JSON.stringify(config))\n  } catch {\n    // Throws in incognito/private browsing, quota exceeded, or disabled\n  }\n}\n\nfunction loadConfig() {\n  try {\n    const data = localStorage.getItem(`userConfig:${VERSION}`)\n    return data ? JSON.parse(data) : null\n  } catch {\n    return null\n  }\n}\n\n// Migration from v1 to v2\nfunction migrate() {\n  try {\n    const v1 = localStorage.getItem('userConfig:v1')\n    if (v1) {\n      const old = JSON.parse(v1)\n      saveConfig({ theme: old.darkMode ? 'dark' : 'light', language: old.lang })\n      localStorage.removeItem('userConfig:v1')\n    }\n  } catch {}\n}\n```\n\n**Store minimal fields from server responses:**\n\n```typescript\n// User object has 20+ fields, only store what UI needs\nfunction cachePrefs(user: FullUser) {\n  try {\n    localStorage.setItem('prefs:v1', JSON.stringify({\n      theme: user.preferences.theme,\n      notifications: user.preferences.notifications\n    }))\n  } catch {}\n}\n```\n\n**Always wrap in try-catch:** `getItem()` and `setItem()` throw in incognito/private browsing (Safari, Firefox), when quota exceeded, or when disabled.\n\n**Benefits:** Schema evolution via versioning, reduced storage size, prevents storing tokens/PII/internal flags.\n\n---\n\n## 5. Re-render Optimization\n\n**Impact: MEDIUM**\n\nReducing unnecessary re-renders minimizes wasted computation and improves UI responsiveness.\n\n### 5.1 Calculate Derived State During Rendering\n\n**Impact: MEDIUM (avoids redundant renders and state drift)**\n\nIf a value can be computed from current props/state, do not store it in state or update it in an effect. Derive it during render to avoid extra renders and state drift. Do not set state in effects solely in response to prop changes; prefer derived values or keyed resets instead.\n\n**Incorrect: redundant state and effect**\n\n```tsx\nfunction Form() {\n  const [firstName, setFirstName] = useState('First')\n  const [lastName, setLastName] = useState('Last')\n  const [fullName, setFullName] = useState('')\n\n  useEffect(() => {\n    setFullName(firstName + ' ' + lastName)\n  }, [firstName, lastName])\n\n  return <p>{fullName}</p>\n}\n```\n\n**Correct: derive during render**\n\n```tsx\nfunction Form() {\n  const [firstName, setFirstName] = useState('First')\n  const [lastName, setLastName] = useState('Last')\n  const fullName = firstName + ' ' + lastName\n\n  return <p>{fullName}</p>\n}\n```\n\nReference: [https://react.dev/learn/you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)\n\n### 5.2 Defer State Reads to Usage Point\n\n**Impact: MEDIUM (avoids unnecessary subscriptions)**\n\nDon't subscribe to dynamic state (searchParams, localStorage) if you only read it inside callbacks.\n\n**Incorrect: subscribes to all searchParams changes**\n\n```tsx\nfunction ShareButton({ chatId }: { chatId: string }) {\n  const searchParams = useSearchParams()\n\n  const handleShare = () => {\n    const ref = searchParams.get('ref')\n    shareChat(chatId, { ref })\n  }\n\n  return <button onClick={handleShare}>Share</button>\n}\n```\n\n**Correct: reads on demand, no subscription**\n\n```tsx\nfunction ShareButton({ chatId }: { chatId: string }) {\n  const handleShare = () => {\n    const params = new URLSearchParams(window.location.search)\n    const ref = params.get('ref')\n    shareChat(chatId, { ref })\n  }\n\n  return <button onClick={handleShare}>Share</button>\n}\n```\n\n### 5.3 Do not wrap a simple expression with a primitive result type in useMemo\n\n**Impact: LOW-MEDIUM (wasted computation on every render)**\n\nWhen an expression is simple (few logical or arithmetical operators) and has a primitive result type (boolean, number, string), do not wrap it in `useMemo`.\n\nCalling `useMemo` and comparing hook dependencies may consume more resources than the expression itself.\n\n**Incorrect:**\n\n```tsx\nfunction Header({ user, notifications }: Props) {\n  const isLoading = useMemo(() => {\n    return user.isLoading || notifications.isLoading\n  }, [user.isLoading, notifications.isLoading])\n\n  if (isLoading) return <Skeleton />\n  // return some markup\n}\n```\n\n**Correct:**\n\n```tsx\nfunction Header({ user, notifications }: Props) {\n  const isLoading = user.isLoading || notifications.isLoading\n\n  if (isLoading) return <Skeleton />\n  // return some markup\n}\n```\n\n### 5.4 Extract Default Non-primitive Parameter Value from Memoized Component to Constant\n\n**Impact: MEDIUM (restores memoization by using a constant for default value)**\n\nWhen memoized component has a default value for some non-primitive optional parameter, such as an array, function, or object, calling the component without that parameter results in broken memoization. This is because new value instances are created on every rerender, and they do not pass strict equality comparison in `memo()`.\n\nTo address this issue, extract the default value into a constant.\n\n**Incorrect: `onClick` has different values on every rerender**\n\n```tsx\nconst UserAvatar = memo(function UserAvatar({ onClick = () => {} }: { onClick?: () => void }) {\n  // ...\n})\n\n// Used without optional onClick\n<UserAvatar />\n```\n\n**Correct: stable default value**\n\n```tsx\nconst NOOP = () => {};\n\nconst UserAvatar = memo(function UserAvatar({ onClick = NOOP }: { onClick?: () => void }) {\n  // ...\n})\n\n// Used without optional onClick\n<UserAvatar />\n```\n\n### 5.5 Extract to Memoized Components\n\n**Impact: MEDIUM (enables early returns)**\n\nExtract expensive work into memoized components to enable early returns before computation.\n\n**Incorrect: computes avatar even when loading**\n\n```tsx\nfunction Profile({ user, loading }: Props) {\n  const avatar = useMemo(() => {\n    const id = computeAvatarId(user)\n    return <Avatar id={id} />\n  }, [user])\n\n  if (loading) return <Skeleton />\n  return <div>{avatar}</div>\n}\n```\n\n**Correct: skips computation when loading**\n\n```tsx\nconst UserAvatar = memo(function UserAvatar({ user }: { user: User }) {\n  const id = useMemo(() => computeAvatarId(user), [user])\n  return <Avatar id={id} />\n})\n\nfunction Profile({ user, loading }: Props) {\n  if (loading) return <Skeleton />\n  return (\n    <div>\n      <UserAvatar user={user} />\n    </div>\n  )\n}\n```\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, manual memoization with `memo()` and `useMemo()` is not necessary. The compiler automatically optimizes re-renders.\n\n### 5.6 Narrow Effect Dependencies\n\n**Impact: LOW (minimizes effect re-runs)**\n\nSpecify primitive dependencies instead of objects to minimize effect re-runs.\n\n**Incorrect: re-runs on any user field change**\n\n```tsx\nuseEffect(() => {\n  console.log(user.id)\n}, [user])\n```\n\n**Correct: re-runs only when id changes**\n\n```tsx\nuseEffect(() => {\n  console.log(user.id)\n}, [user.id])\n```\n\n**For derived state, compute outside effect:**\n\n```tsx\n// Incorrect: runs on width=767, 766, 765...\nuseEffect(() => {\n  if (width < 768) {\n    enableMobileMode()\n  }\n}, [width])\n\n// Correct: runs only on boolean transition\nconst isMobile = width < 768\nuseEffect(() => {\n  if (isMobile) {\n    enableMobileMode()\n  }\n}, [isMobile])\n```\n\n### 5.7 Put Interaction Logic in Event Handlers\n\n**Impact: MEDIUM (avoids effect re-runs and duplicate side effects)**\n\nIf a side effect is triggered by a specific user action (submit, click, drag), run it in that event handler. Do not model the action as state + effect; it makes effects re-run on unrelated changes and can duplicate the action.\n\n**Incorrect: event modeled as state + effect**\n\n```tsx\nfunction Form() {\n  const [submitted, setSubmitted] = useState(false)\n  const theme = useContext(ThemeContext)\n\n  useEffect(() => {\n    if (submitted) {\n      post('/api/register')\n      showToast('Registered', theme)\n    }\n  }, [submitted, theme])\n\n  return <button onClick={() => setSubmitted(true)}>Submit</button>\n}\n```\n\n**Correct: do it in the handler**\n\n```tsx\nfunction Form() {\n  const theme = useContext(ThemeContext)\n\n  function handleSubmit() {\n    post('/api/register')\n    showToast('Registered', theme)\n  }\n\n  return <button onClick={handleSubmit}>Submit</button>\n}\n```\n\nReference: [https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler](https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler)\n\n### 5.8 Subscribe to Derived State\n\n**Impact: MEDIUM (reduces re-render frequency)**\n\nSubscribe to derived boolean state instead of continuous values to reduce re-render frequency.\n\n**Incorrect: re-renders on every pixel change**\n\n```tsx\nfunction Sidebar() {\n  const width = useWindowWidth()  // updates continuously\n  const isMobile = width < 768\n  return <nav className={isMobile ? 'mobile' : 'desktop'} />\n}\n```\n\n**Correct: re-renders only when boolean changes**\n\n```tsx\nfunction Sidebar() {\n  const isMobile = useMediaQuery('(max-width: 767px)')\n  return <nav className={isMobile ? 'mobile' : 'desktop'} />\n}\n```\n\n### 5.9 Use Functional setState Updates\n\n**Impact: MEDIUM (prevents stale closures and unnecessary callback recreations)**\n\nWhen updating state based on the current state value, use the functional update form of setState instead of directly referencing the state variable. This prevents stale closures, eliminates unnecessary dependencies, and creates stable callback references.\n\n**Incorrect: requires state as dependency**\n\n```tsx\nfunction TodoList() {\n  const [items, setItems] = useState(initialItems)\n  \n  // Callback must depend on items, recreated on every items change\n  const addItems = useCallback((newItems: Item[]) => {\n    setItems([...items, ...newItems])\n  }, [items])  // ❌ items dependency causes recreations\n  \n  // Risk of stale closure if dependency is forgotten\n  const removeItem = useCallback((id: string) => {\n    setItems(items.filter(item => item.id !== id))\n  }, [])  // ❌ Missing items dependency - will use stale items!\n  \n  return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />\n}\n```\n\nThe first callback is recreated every time `items` changes, which can cause child components to re-render unnecessarily. The second callback has a stale closure bug—it will always reference the initial `items` value.\n\n**Correct: stable callbacks, no stale closures**\n\n```tsx\nfunction TodoList() {\n  const [items, setItems] = useState(initialItems)\n  \n  // Stable callback, never recreated\n  const addItems = useCallback((newItems: Item[]) => {\n    setItems(curr => [...curr, ...newItems])\n  }, [])  // ✅ No dependencies needed\n  \n  // Always uses latest state, no stale closure risk\n  const removeItem = useCallback((id: string) => {\n    setItems(curr => curr.filter(item => item.id !== id))\n  }, [])  // ✅ Safe and stable\n  \n  return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />\n}\n```\n\n**Benefits:**\n\n1. **Stable callback references** - Callbacks don't need to be recreated when state changes\n\n2. **No stale closures** - Always operates on the latest state value\n\n3. **Fewer dependencies** - Simplifies dependency arrays and reduces memory leaks\n\n4. **Prevents bugs** - Eliminates the most common source of React closure bugs\n\n**When to use functional updates:**\n\n- Any setState that depends on the current state value\n\n- Inside useCallback/useMemo when state is needed\n\n- Event handlers that reference state\n\n- Async operations that update state\n\n**When direct updates are fine:**\n\n- Setting state to a static value: `setCount(0)`\n\n- Setting state from props/arguments only: `setName(newName)`\n\n- State doesn't depend on previous value\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler can automatically optimize some cases, but functional updates are still recommended for correctness and to prevent stale closure bugs.\n\n### 5.10 Use Lazy State Initialization\n\n**Impact: MEDIUM (wasted computation on every render)**\n\nPass a function to `useState` for expensive initial values. Without the function form, the initializer runs on every render even though the value is only used once.\n\n**Incorrect: runs on every render**\n\n```tsx\nfunction FilteredList({ items }: { items: Item[] }) {\n  // buildSearchIndex() runs on EVERY render, even after initialization\n  const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))\n  const [query, setQuery] = useState('')\n  \n  // When query changes, buildSearchIndex runs again unnecessarily\n  return <SearchResults index={searchIndex} query={query} />\n}\n\nfunction UserProfile() {\n  // JSON.parse runs on every render\n  const [settings, setSettings] = useState(\n    JSON.parse(localStorage.getItem('settings') || '{}')\n  )\n  \n  return <SettingsForm settings={settings} onChange={setSettings} />\n}\n```\n\n**Correct: runs only once**\n\n```tsx\nfunction FilteredList({ items }: { items: Item[] }) {\n  // buildSearchIndex() runs ONLY on initial render\n  const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))\n  const [query, setQuery] = useState('')\n  \n  return <SearchResults index={searchIndex} query={query} />\n}\n\nfunction UserProfile() {\n  // JSON.parse runs only on initial render\n  const [settings, setSettings] = useState(() => {\n    const stored = localStorage.getItem('settings')\n    return stored ? JSON.parse(stored) : {}\n  })\n  \n  return <SettingsForm settings={settings} onChange={setSettings} />\n}\n```\n\nUse lazy initialization when computing initial values from localStorage/sessionStorage, building data structures (indexes, maps), reading from the DOM, or performing heavy transformations.\n\nFor simple primitives (`useState(0)`), direct references (`useState(props.value)`), or cheap literals (`useState({})`), the function form is unnecessary.\n\n### 5.11 Use Transitions for Non-Urgent Updates\n\n**Impact: MEDIUM (maintains UI responsiveness)**\n\nMark frequent, non-urgent state updates as transitions to maintain UI responsiveness.\n\n**Incorrect: blocks UI on every scroll**\n\n```tsx\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0)\n  useEffect(() => {\n    const handler = () => setScrollY(window.scrollY)\n    window.addEventListener('scroll', handler, { passive: true })\n    return () => window.removeEventListener('scroll', handler)\n  }, [])\n}\n```\n\n**Correct: non-blocking updates**\n\n```tsx\nimport { startTransition } from 'react'\n\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0)\n  useEffect(() => {\n    const handler = () => {\n      startTransition(() => setScrollY(window.scrollY))\n    }\n    window.addEventListener('scroll', handler, { passive: true })\n    return () => window.removeEventListener('scroll', handler)\n  }, [])\n}\n```\n\n### 5.12 Use useRef for Transient Values\n\n**Impact: MEDIUM (avoids unnecessary re-renders on frequent updates)**\n\nWhen a value changes frequently and you don't want a re-render on every update (e.g., mouse trackers, intervals, transient flags), store it in `useRef` instead of `useState`. Keep component state for UI; use refs for temporary DOM-adjacent values. Updating a ref does not trigger a re-render.\n\n**Incorrect: renders every update**\n\n```tsx\nfunction Tracker() {\n  const [lastX, setLastX] = useState(0)\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => setLastX(e.clientX)\n    window.addEventListener('mousemove', onMove)\n    return () => window.removeEventListener('mousemove', onMove)\n  }, [])\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: lastX,\n        width: 8,\n        height: 8,\n        background: 'black',\n      }}\n    />\n  )\n}\n```\n\n**Correct: no re-render for tracking**\n\n```tsx\nfunction Tracker() {\n  const lastXRef = useRef(0)\n  const dotRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => {\n      lastXRef.current = e.clientX\n      const node = dotRef.current\n      if (node) {\n        node.style.transform = `translateX(${e.clientX}px)`\n      }\n    }\n    window.addEventListener('mousemove', onMove)\n    return () => window.removeEventListener('mousemove', onMove)\n  }, [])\n\n  return (\n    <div\n      ref={dotRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: 8,\n        height: 8,\n        background: 'black',\n        transform: 'translateX(0px)',\n      }}\n    />\n  )\n}\n```\n\n---\n\n## 6. Rendering Performance\n\n**Impact: MEDIUM**\n\nOptimizing the rendering process reduces the work the browser needs to do.\n\n### 6.1 Animate SVG Wrapper Instead of SVG Element\n\n**Impact: LOW (enables hardware acceleration)**\n\nMany browsers don't have hardware acceleration for CSS3 animations on SVG elements. Wrap SVG in a `<div>` and animate the wrapper instead.\n\n**Incorrect: animating SVG directly - no hardware acceleration**\n\n```tsx\nfunction LoadingSpinner() {\n  return (\n    <svg \n      className=\"animate-spin\"\n      width=\"24\" \n      height=\"24\" \n      viewBox=\"0 0 24 24\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" />\n    </svg>\n  )\n}\n```\n\n**Correct: animating wrapper div - hardware accelerated**\n\n```tsx\nfunction LoadingSpinner() {\n  return (\n    <div className=\"animate-spin\">\n      <svg \n        width=\"24\" \n        height=\"24\" \n        viewBox=\"0 0 24 24\"\n      >\n        <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" />\n      </svg>\n    </div>\n  )\n}\n```\n\nThis applies to all CSS transforms and transitions (`transform`, `opacity`, `translate`, `scale`, `rotate`). The wrapper div allows browsers to use GPU acceleration for smoother animations.\n\n### 6.2 CSS content-visibility for Long Lists\n\n**Impact: HIGH (faster initial render)**\n\nApply `content-visibility: auto` to defer off-screen rendering.\n\n**CSS:**\n\n```css\n.message-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 0 80px;\n}\n```\n\n**Example:**\n\n```tsx\nfunction MessageList({ messages }: { messages: Message[] }) {\n  return (\n    <div className=\"overflow-y-auto h-screen\">\n      {messages.map(msg => (\n        <div key={msg.id} className=\"message-item\">\n          <Avatar user={msg.author} />\n          <div>{msg.content}</div>\n        </div>\n      ))}\n    </div>\n  )\n}\n```\n\nFor 1000 messages, browser skips layout/paint for ~990 off-screen items (10× faster initial render).\n\n### 6.3 Hoist Static JSX Elements\n\n**Impact: LOW (avoids re-creation)**\n\nExtract static JSX outside components to avoid re-creation.\n\n**Incorrect: recreates element every render**\n\n```tsx\nfunction LoadingSkeleton() {\n  return <div className=\"animate-pulse h-20 bg-gray-200\" />\n}\n\nfunction Container() {\n  return (\n    <div>\n      {loading && <LoadingSkeleton />}\n    </div>\n  )\n}\n```\n\n**Correct: reuses same element**\n\n```tsx\nconst loadingSkeleton = (\n  <div className=\"animate-pulse h-20 bg-gray-200\" />\n)\n\nfunction Container() {\n  return (\n    <div>\n      {loading && loadingSkeleton}\n    </div>\n  )\n}\n```\n\nThis is especially helpful for large and static SVG nodes, which can be expensive to recreate on every render.\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler automatically hoists static JSX elements and optimizes component re-renders, making manual hoisting unnecessary.\n\n### 6.4 Optimize SVG Precision\n\n**Impact: LOW (reduces file size)**\n\nReduce SVG coordinate precision to decrease file size. The optimal precision depends on the viewBox size, but in general reducing precision should be considered.\n\n**Incorrect: excessive precision**\n\n```svg\n<path d=\"M 10.293847 20.847362 L 30.938472 40.192837\" />\n```\n\n**Correct: 1 decimal place**\n\n```svg\n<path d=\"M 10.3 20.8 L 30.9 40.2\" />\n```\n\n**Automate with SVGO:**\n\n```bash\nnpx svgo --precision=1 --multipass icon.svg\n```\n\n### 6.5 Prevent Hydration Mismatch Without Flickering\n\n**Impact: MEDIUM (avoids visual flicker and hydration errors)**\n\nWhen rendering content that depends on client-side storage (localStorage, cookies), avoid both SSR breakage and post-hydration flickering by injecting a synchronous script that updates the DOM before React hydrates.\n\n**Incorrect: breaks SSR**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  // localStorage is not available on server - throws error\n  const theme = localStorage.getItem('theme') || 'light'\n  \n  return (\n    <div className={theme}>\n      {children}\n    </div>\n  )\n}\n```\n\nServer-side rendering will fail because `localStorage` is undefined.\n\n**Incorrect: visual flickering**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  const [theme, setTheme] = useState('light')\n  \n  useEffect(() => {\n    // Runs after hydration - causes visible flash\n    const stored = localStorage.getItem('theme')\n    if (stored) {\n      setTheme(stored)\n    }\n  }, [])\n  \n  return (\n    <div className={theme}>\n      {children}\n    </div>\n  )\n}\n```\n\nComponent first renders with default value (`light`), then updates after hydration, causing a visible flash of incorrect content.\n\n**Correct: no flicker, no hydration mismatch**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  return (\n    <>\n      <div id=\"theme-wrapper\">\n        {children}\n      </div>\n      <script\n        dangerouslySetInnerHTML={{\n          __html: `\n            (function() {\n              try {\n                var theme = localStorage.getItem('theme') || 'light';\n                var el = document.getElementById('theme-wrapper');\n                if (el) el.className = theme;\n              } catch (e) {}\n            })();\n          `,\n        }}\n      />\n    </>\n  )\n}\n```\n\nThe inline script executes synchronously before showing the element, ensuring the DOM already has the correct value. No flickering, no hydration mismatch.\n\nThis pattern is especially useful for theme toggles, user preferences, authentication states, and any client-only data that should render immediately without flashing default values.\n\n### 6.6 Suppress Expected Hydration Mismatches\n\n**Impact: LOW-MEDIUM (avoids noisy hydration warnings for known differences)**\n\nIn SSR frameworks (e.g., Next.js), some values are intentionally different on server vs client (random IDs, dates, locale/timezone formatting). For these *expected* mismatches, wrap the dynamic text in an element with `suppressHydrationWarning` to prevent noisy warnings. Do not use this to hide real bugs. Don’t overuse it.\n\n**Incorrect: known mismatch warnings**\n\n```tsx\nfunction Timestamp() {\n  return <span>{new Date().toLocaleString()}</span>\n}\n```\n\n**Correct: suppress expected mismatch only**\n\n```tsx\nfunction Timestamp() {\n  return (\n    <span suppressHydrationWarning>\n      {new Date().toLocaleString()}\n    </span>\n  )\n}\n```\n\n### 6.7 Use Activity Component for Show/Hide\n\n**Impact: MEDIUM (preserves state/DOM)**\n\nUse React's `<Activity>` to preserve state/DOM for expensive components that frequently toggle visibility.\n\n**Usage:**\n\n```tsx\nimport { Activity } from 'react'\n\nfunction Dropdown({ isOpen }: Props) {\n  return (\n    <Activity mode={isOpen ? 'visible' : 'hidden'}>\n      <ExpensiveMenu />\n    </Activity>\n  )\n}\n```\n\nAvoids expensive re-renders and state loss.\n\n### 6.8 Use Explicit Conditional Rendering\n\n**Impact: LOW (prevents rendering 0 or NaN)**\n\nUse explicit ternary operators (`? :`) instead of `&&` for conditional rendering when the condition can be `0`, `NaN`, or other falsy values that render.\n\n**Incorrect: renders \"0\" when count is 0**\n\n```tsx\nfunction Badge({ count }: { count: number }) {\n  return (\n    <div>\n      {count && <span className=\"badge\">{count}</span>}\n    </div>\n  )\n}\n\n// When count = 0, renders: <div>0</div>\n// When count = 5, renders: <div><span class=\"badge\">5</span></div>\n```\n\n**Correct: renders nothing when count is 0**\n\n```tsx\nfunction Badge({ count }: { count: number }) {\n  return (\n    <div>\n      {count > 0 ? <span className=\"badge\">{count}</span> : null}\n    </div>\n  )\n}\n\n// When count = 0, renders: <div></div>\n// When count = 5, renders: <div><span class=\"badge\">5</span></div>\n```\n\n### 6.9 Use useTransition Over Manual Loading States\n\n**Impact: LOW (reduces re-renders and improves code clarity)**\n\nUse `useTransition` instead of manual `useState` for loading states. This provides built-in `isPending` state and automatically manages transitions.\n\n**Incorrect: manual loading state**\n\n```tsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('')\n  const [results, setResults] = useState([])\n  const [isLoading, setIsLoading] = useState(false)\n\n  const handleSearch = async (value: string) => {\n    setIsLoading(true)\n    setQuery(value)\n    const data = await fetchResults(value)\n    setResults(data)\n    setIsLoading(false)\n  }\n\n  return (\n    <>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {isLoading && <Spinner />}\n      <ResultsList results={results} />\n    </>\n  )\n}\n```\n\n**Correct: useTransition with built-in pending state**\n\n```tsx\nimport { useTransition, useState } from 'react'\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('')\n  const [results, setResults] = useState([])\n  const [isPending, startTransition] = useTransition()\n\n  const handleSearch = (value: string) => {\n    setQuery(value) // Update input immediately\n    \n    startTransition(async () => {\n      // Fetch and update results\n      const data = await fetchResults(value)\n      setResults(data)\n    })\n  }\n\n  return (\n    <>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {isPending && <Spinner />}\n      <ResultsList results={results} />\n    </>\n  )\n}\n```\n\n**Benefits:**\n\n- **Automatic pending state**: No need to manually manage `setIsLoading(true/false)`\n\n- **Error resilience**: Pending state correctly resets even if the transition throws\n\n- **Better responsiveness**: Keeps the UI responsive during updates\n\n- **Interrupt handling**: New transitions automatically cancel pending ones\n\nReference: [https://react.dev/reference/react/useTransition](https://react.dev/reference/react/useTransition)\n\n---\n\n## 7. JavaScript Performance\n\n**Impact: LOW-MEDIUM**\n\nMicro-optimizations for hot paths can add up to meaningful improvements.\n\n### 7.1 Avoid Layout Thrashing\n\n**Impact: MEDIUM (prevents forced synchronous layouts and reduces performance bottlenecks)**\n\nAvoid interleaving style writes with layout reads. When you read a layout property (like `offsetWidth`, `getBoundingClientRect()`, or `getComputedStyle()`) between style changes, the browser is forced to trigger a synchronous reflow.\n\n**This is OK: browser batches style changes**\n\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  // Each line invalidates style, but browser batches the recalculation\n  element.style.width = '100px'\n  element.style.height = '200px'\n  element.style.backgroundColor = 'blue'\n  element.style.border = '1px solid black'\n}\n```\n\n**Incorrect: interleaved reads and writes force reflows**\n\n```typescript\nfunction layoutThrashing(element: HTMLElement) {\n  element.style.width = '100px'\n  const width = element.offsetWidth  // Forces reflow\n  element.style.height = '200px'\n  const height = element.offsetHeight  // Forces another reflow\n}\n```\n\n**Correct: batch writes, then read once**\n\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  // Batch all writes together\n  element.style.width = '100px'\n  element.style.height = '200px'\n  element.style.backgroundColor = 'blue'\n  element.style.border = '1px solid black'\n  \n  // Read after all writes are done (single reflow)\n  const { width, height } = element.getBoundingClientRect()\n}\n```\n\n**Correct: batch reads, then writes**\n\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  element.classList.add('highlighted-box')\n  \n  const { width, height } = element.getBoundingClientRect()\n}\n```\n\n**Better: use CSS classes**\n\n**React example:**\n\n```tsx\n// Incorrect: interleaving style changes with layout queries\nfunction Box({ isHighlighted }: { isHighlighted: boolean }) {\n  const ref = useRef<HTMLDivElement>(null)\n  \n  useEffect(() => {\n    if (ref.current && isHighlighted) {\n      ref.current.style.width = '100px'\n      const width = ref.current.offsetWidth // Forces layout\n      ref.current.style.height = '200px'\n    }\n  }, [isHighlighted])\n  \n  return <div ref={ref}>Content</div>\n}\n\n// Correct: toggle class\nfunction Box({ isHighlighted }: { isHighlighted: boolean }) {\n  return (\n    <div className={isHighlighted ? 'highlighted-box' : ''}>\n      Content\n    </div>\n  )\n}\n```\n\nPrefer CSS classes over inline styles when possible. CSS files are cached by the browser, and classes provide better separation of concerns and are easier to maintain.\n\nSee [this gist](https://gist.github.com/paulirish/5d52fb081b3570c81e3a) and [CSS Triggers](https://csstriggers.com/) for more information on layout-forcing operations.\n\n### 7.2 Build Index Maps for Repeated Lookups\n\n**Impact: LOW-MEDIUM (1M ops to 2K ops)**\n\nMultiple `.find()` calls by the same key should use a Map.\n\n**Incorrect (O(n) per lookup):**\n\n```typescript\nfunction processOrders(orders: Order[], users: User[]) {\n  return orders.map(order => ({\n    ...order,\n    user: users.find(u => u.id === order.userId)\n  }))\n}\n```\n\n**Correct (O(1) per lookup):**\n\n```typescript\nfunction processOrders(orders: Order[], users: User[]) {\n  const userById = new Map(users.map(u => [u.id, u]))\n\n  return orders.map(order => ({\n    ...order,\n    user: userById.get(order.userId)\n  }))\n}\n```\n\nBuild map once (O(n)), then all lookups are O(1).\n\nFor 1000 orders × 1000 users: 1M ops → 2K ops.\n\n### 7.3 Cache Property Access in Loops\n\n**Impact: LOW-MEDIUM (reduces lookups)**\n\nCache object property lookups in hot paths.\n\n**Incorrect: 3 lookups × N iterations**\n\n```typescript\nfor (let i = 0; i < arr.length; i++) {\n  process(obj.config.settings.value)\n}\n```\n\n**Correct: 1 lookup total**\n\n```typescript\nconst value = obj.config.settings.value\nconst len = arr.length\nfor (let i = 0; i < len; i++) {\n  process(value)\n}\n```\n\n### 7.4 Cache Repeated Function Calls\n\n**Impact: MEDIUM (avoid redundant computation)**\n\nUse a module-level Map to cache function results when the same function is called repeatedly with the same inputs during render.\n\n**Incorrect: redundant computation**\n\n```typescript\nfunction ProjectList({ projects }: { projects: Project[] }) {\n  return (\n    <div>\n      {projects.map(project => {\n        // slugify() called 100+ times for same project names\n        const slug = slugify(project.name)\n        \n        return <ProjectCard key={project.id} slug={slug} />\n      })}\n    </div>\n  )\n}\n```\n\n**Correct: cached results**\n\n```typescript\n// Module-level cache\nconst slugifyCache = new Map<string, string>()\n\nfunction cachedSlugify(text: string): string {\n  if (slugifyCache.has(text)) {\n    return slugifyCache.get(text)!\n  }\n  const result = slugify(text)\n  slugifyCache.set(text, result)\n  return result\n}\n\nfunction ProjectList({ projects }: { projects: Project[] }) {\n  return (\n    <div>\n      {projects.map(project => {\n        // Computed only once per unique project name\n        const slug = cachedSlugify(project.name)\n        \n        return <ProjectCard key={project.id} slug={slug} />\n      })}\n    </div>\n  )\n}\n```\n\n**Simpler pattern for single-value functions:**\n\n```typescript\nlet isLoggedInCache: boolean | null = null\n\nfunction isLoggedIn(): boolean {\n  if (isLoggedInCache !== null) {\n    return isLoggedInCache\n  }\n  \n  isLoggedInCache = document.cookie.includes('auth=')\n  return isLoggedInCache\n}\n\n// Clear cache when auth changes\nfunction onAuthChange() {\n  isLoggedInCache = null\n}\n```\n\nUse a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.\n\nReference: [https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast](https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast)\n\n### 7.5 Cache Storage API Calls\n\n**Impact: LOW-MEDIUM (reduces expensive I/O)**\n\n`localStorage`, `sessionStorage`, and `document.cookie` are synchronous and expensive. Cache reads in memory.\n\n**Incorrect: reads storage on every call**\n\n```typescript\nfunction getTheme() {\n  return localStorage.getItem('theme') ?? 'light'\n}\n// Called 10 times = 10 storage reads\n```\n\n**Correct: Map cache**\n\n```typescript\nconst storageCache = new Map<string, string | null>()\n\nfunction getLocalStorage(key: string) {\n  if (!storageCache.has(key)) {\n    storageCache.set(key, localStorage.getItem(key))\n  }\n  return storageCache.get(key)\n}\n\nfunction setLocalStorage(key: string, value: string) {\n  localStorage.setItem(key, value)\n  storageCache.set(key, value)  // keep cache in sync\n}\n```\n\nUse a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.\n\n**Cookie caching:**\n\n```typescript\nlet cookieCache: Record<string, string> | null = null\n\nfunction getCookie(name: string) {\n  if (!cookieCache) {\n    cookieCache = Object.fromEntries(\n      document.cookie.split('; ').map(c => c.split('='))\n    )\n  }\n  return cookieCache[name]\n}\n```\n\n**Important: invalidate on external changes**\n\n```typescript\nwindow.addEventListener('storage', (e) => {\n  if (e.key) storageCache.delete(e.key)\n})\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.visibilityState === 'visible') {\n    storageCache.clear()\n  }\n})\n```\n\nIf storage can change externally (another tab, server-set cookies), invalidate cache:\n\n### 7.6 Combine Multiple Array Iterations\n\n**Impact: LOW-MEDIUM (reduces iterations)**\n\nMultiple `.filter()` or `.map()` calls iterate the array multiple times. Combine into one loop.\n\n**Incorrect: 3 iterations**\n\n```typescript\nconst admins = users.filter(u => u.isAdmin)\nconst testers = users.filter(u => u.isTester)\nconst inactive = users.filter(u => !u.isActive)\n```\n\n**Correct: 1 iteration**\n\n```typescript\nconst admins: User[] = []\nconst testers: User[] = []\nconst inactive: User[] = []\n\nfor (const user of users) {\n  if (user.isAdmin) admins.push(user)\n  if (user.isTester) testers.push(user)\n  if (!user.isActive) inactive.push(user)\n}\n```\n\n### 7.7 Early Length Check for Array Comparisons\n\n**Impact: MEDIUM-HIGH (avoids expensive operations when lengths differ)**\n\nWhen comparing arrays with expensive operations (sorting, deep equality, serialization), check lengths first. If lengths differ, the arrays cannot be equal.\n\nIn real-world applications, this optimization is especially valuable when the comparison runs in hot paths (event handlers, render loops).\n\n**Incorrect: always runs expensive comparison**\n\n```typescript\nfunction hasChanges(current: string[], original: string[]) {\n  // Always sorts and joins, even when lengths differ\n  return current.sort().join() !== original.sort().join()\n}\n```\n\nTwo O(n log n) sorts run even when `current.length` is 5 and `original.length` is 100. There is also overhead of joining the arrays and comparing the strings.\n\n**Correct (O(1) length check first):**\n\n```typescript\nfunction hasChanges(current: string[], original: string[]) {\n  // Early return if lengths differ\n  if (current.length !== original.length) {\n    return true\n  }\n  // Only sort when lengths match\n  const currentSorted = current.toSorted()\n  const originalSorted = original.toSorted()\n  for (let i = 0; i < currentSorted.length; i++) {\n    if (currentSorted[i] !== originalSorted[i]) {\n      return true\n    }\n  }\n  return false\n}\n```\n\nThis new approach is more efficient because:\n\n- It avoids the overhead of sorting and joining the arrays when lengths differ\n\n- It avoids consuming memory for the joined strings (especially important for large arrays)\n\n- It avoids mutating the original arrays\n\n- It returns early when a difference is found\n\n### 7.8 Early Return from Functions\n\n**Impact: LOW-MEDIUM (avoids unnecessary computation)**\n\nReturn early when result is determined to skip unnecessary processing.\n\n**Incorrect: processes all items even after finding answer**\n\n```typescript\nfunction validateUsers(users: User[]) {\n  let hasError = false\n  let errorMessage = ''\n  \n  for (const user of users) {\n    if (!user.email) {\n      hasError = true\n      errorMessage = 'Email required'\n    }\n    if (!user.name) {\n      hasError = true\n      errorMessage = 'Name required'\n    }\n    // Continues checking all users even after error found\n  }\n  \n  return hasError ? { valid: false, error: errorMessage } : { valid: true }\n}\n```\n\n**Correct: returns immediately on first error**\n\n```typescript\nfunction validateUsers(users: User[]) {\n  for (const user of users) {\n    if (!user.email) {\n      return { valid: false, error: 'Email required' }\n    }\n    if (!user.name) {\n      return { valid: false, error: 'Name required' }\n    }\n  }\n\n  return { valid: true }\n}\n```\n\n### 7.9 Hoist RegExp Creation\n\n**Impact: LOW-MEDIUM (avoids recreation)**\n\nDon't create RegExp inside render. Hoist to module scope or memoize with `useMemo()`.\n\n**Incorrect: new RegExp every render**\n\n```tsx\nfunction Highlighter({ text, query }: Props) {\n  const regex = new RegExp(`(${query})`, 'gi')\n  const parts = text.split(regex)\n  return <>{parts.map((part, i) => ...)}</>\n}\n```\n\n**Correct: memoize or hoist**\n\n```tsx\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n\nfunction Highlighter({ text, query }: Props) {\n  const regex = useMemo(\n    () => new RegExp(`(${escapeRegex(query)})`, 'gi'),\n    [query]\n  )\n  const parts = text.split(regex)\n  return <>{parts.map((part, i) => ...)}</>\n}\n```\n\n**Warning: global regex has mutable state**\n\n```typescript\nconst regex = /foo/g\nregex.test('foo')  // true, lastIndex = 3\nregex.test('foo')  // false, lastIndex = 0\n```\n\nGlobal regex (`/g`) has mutable `lastIndex` state:\n\n### 7.10 Use Loop for Min/Max Instead of Sort\n\n**Impact: LOW (O(n) instead of O(n log n))**\n\nFinding the smallest or largest element only requires a single pass through the array. Sorting is wasteful and slower.\n\n**Incorrect (O(n log n) - sort to find latest):**\n\n```typescript\ninterface Project {\n  id: string\n  name: string\n  updatedAt: number\n}\n\nfunction getLatestProject(projects: Project[]) {\n  const sorted = [...projects].sort((a, b) => b.updatedAt - a.updatedAt)\n  return sorted[0]\n}\n```\n\nSorts the entire array just to find the maximum value.\n\n**Incorrect (O(n log n) - sort for oldest and newest):**\n\n```typescript\nfunction getOldestAndNewest(projects: Project[]) {\n  const sorted = [...projects].sort((a, b) => a.updatedAt - b.updatedAt)\n  return { oldest: sorted[0], newest: sorted[sorted.length - 1] }\n}\n```\n\nStill sorts unnecessarily when only min/max are needed.\n\n**Correct (O(n) - single loop):**\n\n```typescript\nfunction getLatestProject(projects: Project[]) {\n  if (projects.length === 0) return null\n  \n  let latest = projects[0]\n  \n  for (let i = 1; i < projects.length; i++) {\n    if (projects[i].updatedAt > latest.updatedAt) {\n      latest = projects[i]\n    }\n  }\n  \n  return latest\n}\n\nfunction getOldestAndNewest(projects: Project[]) {\n  if (projects.length === 0) return { oldest: null, newest: null }\n  \n  let oldest = projects[0]\n  let newest = projects[0]\n  \n  for (let i = 1; i < projects.length; i++) {\n    if (projects[i].updatedAt < oldest.updatedAt) oldest = projects[i]\n    if (projects[i].updatedAt > newest.updatedAt) newest = projects[i]\n  }\n  \n  return { oldest, newest }\n}\n```\n\nSingle pass through the array, no copying, no sorting.\n\n**Alternative: Math.min/Math.max for small arrays**\n\n```typescript\nconst numbers = [5, 2, 8, 1, 9]\nconst min = Math.min(...numbers)\nconst max = Math.max(...numbers)\n```\n\nThis works for small arrays, but can be slower or just throw an error for very large arrays due to spread operator limitations. Maximal array length is approximately 124000 in Chrome 143 and 638000 in Safari 18; exact numbers may vary - see [the fiddle](https://jsfiddle.net/qw1jabsx/4/). Use the loop approach for reliability.\n\n### 7.11 Use Set/Map for O(1) Lookups\n\n**Impact: LOW-MEDIUM (O(n) to O(1))**\n\nConvert arrays to Set/Map for repeated membership checks.\n\n**Incorrect (O(n) per check):**\n\n```typescript\nconst allowedIds = ['a', 'b', 'c', ...]\nitems.filter(item => allowedIds.includes(item.id))\n```\n\n**Correct (O(1) per check):**\n\n```typescript\nconst allowedIds = new Set(['a', 'b', 'c', ...])\nitems.filter(item => allowedIds.has(item.id))\n```\n\n### 7.12 Use toSorted() Instead of sort() for Immutability\n\n**Impact: MEDIUM-HIGH (prevents mutation bugs in React state)**\n\n`.sort()` mutates the array in place, which can cause bugs with React state and props. Use `.toSorted()` to create a new sorted array without mutation.\n\n**Incorrect: mutates original array**\n\n```typescript\nfunction UserList({ users }: { users: User[] }) {\n  // Mutates the users prop array!\n  const sorted = useMemo(\n    () => users.sort((a, b) => a.name.localeCompare(b.name)),\n    [users]\n  )\n  return <div>{sorted.map(renderUser)}</div>\n}\n```\n\n**Correct: creates new array**\n\n```typescript\nfunction UserList({ users }: { users: User[] }) {\n  // Creates new sorted array, original unchanged\n  const sorted = useMemo(\n    () => users.toSorted((a, b) => a.name.localeCompare(b.name)),\n    [users]\n  )\n  return <div>{sorted.map(renderUser)}</div>\n}\n```\n\n**Why this matters in React:**\n\n1. Props/state mutations break React's immutability model - React expects props and state to be treated as read-only\n\n2. Causes stale closure bugs - Mutating arrays inside closures (callbacks, effects) can lead to unexpected behavior\n\n**Browser support: fallback for older browsers**\n\n```typescript\n// Fallback for older browsers\nconst sorted = [...items].sort((a, b) => a.value - b.value)\n```\n\n`.toSorted()` is available in all modern browsers (Chrome 110+, Safari 16+, Firefox 115+, Node.js 20+). For older environments, use spread operator:\n\n**Other immutable array methods:**\n\n- `.toSorted()` - immutable sort\n\n- `.toReversed()` - immutable reverse\n\n- `.toSpliced()` - immutable splice\n\n- `.with()` - immutable element replacement\n\n---\n\n## 8. Advanced Patterns\n\n**Impact: LOW**\n\nAdvanced patterns for specific cases that require careful implementation.\n\n### 8.1 Initialize App Once, Not Per Mount\n\n**Impact: LOW-MEDIUM (avoids duplicate init in development)**\n\nDo not put app-wide initialization that must run once per app load inside `useEffect([])` of a component. Components can remount and effects will re-run. Use a module-level guard or top-level init in the entry module instead.\n\n**Incorrect: runs twice in dev, re-runs on remount**\n\n```tsx\nfunction Comp() {\n  useEffect(() => {\n    loadFromStorage()\n    checkAuthToken()\n  }, [])\n\n  // ...\n}\n```\n\n**Correct: once per app load**\n\n```tsx\nlet didInit = false\n\nfunction Comp() {\n  useEffect(() => {\n    if (didInit) return\n    didInit = true\n    loadFromStorage()\n    checkAuthToken()\n  }, [])\n\n  // ...\n}\n```\n\nReference: [https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application](https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application)\n\n### 8.2 Store Event Handlers in Refs\n\n**Impact: LOW (stable subscriptions)**\n\nStore callbacks in refs when used in effects that shouldn't re-subscribe on callback changes.\n\n**Incorrect: re-subscribes on every render**\n\n```tsx\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  useEffect(() => {\n    window.addEventListener(event, handler)\n    return () => window.removeEventListener(event, handler)\n  }, [event, handler])\n}\n```\n\n**Correct: stable subscription**\n\n```tsx\nimport { useEffectEvent } from 'react'\n\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  const onEvent = useEffectEvent(handler)\n\n  useEffect(() => {\n    window.addEventListener(event, onEvent)\n    return () => window.removeEventListener(event, onEvent)\n  }, [event])\n}\n```\n\n**Alternative: use `useEffectEvent` if you're on latest React:**\n\n`useEffectEvent` provides a cleaner API for the same pattern: it creates a stable function reference that always calls the latest version of the handler.\n\n### 8.3 useEffectEvent for Stable Callback Refs\n\n**Impact: LOW (prevents effect re-runs)**\n\nAccess latest values in callbacks without adding them to dependency arrays. Prevents effect re-runs while avoiding stale closures.\n\n**Incorrect: effect re-runs on every callback change**\n\n```tsx\nfunction SearchInput({ onSearch }: { onSearch: (q: string) => void }) {\n  const [query, setQuery] = useState('')\n\n  useEffect(() => {\n    const timeout = setTimeout(() => onSearch(query), 300)\n    return () => clearTimeout(timeout)\n  }, [query, onSearch])\n}\n```\n\n**Correct: using React's useEffectEvent**\n\n```tsx\nimport { useEffectEvent } from 'react';\n\nfunction SearchInput({ onSearch }: { onSearch: (q: string) => void }) {\n  const [query, setQuery] = useState('')\n  const onSearchEvent = useEffectEvent(onSearch)\n\n  useEffect(() => {\n    const timeout = setTimeout(() => onSearchEvent(query), 300)\n    return () => clearTimeout(timeout)\n  }, [query])\n}\n```\n\n---\n\n## References\n\n1. [https://react.dev](https://react.dev)\n2. [https://nextjs.org](https://nextjs.org)\n3. [https://swr.vercel.app](https://swr.vercel.app)\n4. [https://github.com/shuding/better-all](https://github.com/shuding/better-all)\n5. [https://github.com/isaacs/node-lru-cache](https://github.com/isaacs/node-lru-cache)\n6. [https://vercel.com/blog/how-we-optimized-package-imports-in-next-js](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)\n7. [https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast](https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast)\n",
        "skills/react-best-practices/README.md": "# React Best Practices\n\nA structured repository for creating and maintaining React Best Practices optimized for agents and LLMs.\n\n## Structure\n\n- `rules/` - Individual rule files (one per rule)\n  - `_sections.md` - Section metadata (titles, impacts, descriptions)\n  - `_template.md` - Template for creating new rules\n  - `area-description.md` - Individual rule files\n- `src/` - Build scripts and utilities\n- `metadata.json` - Document metadata (version, organization, abstract)\n- __`AGENTS.md`__ - Compiled output (generated)\n- __`test-cases.json`__ - Test cases for LLM evaluation (generated)\n\n## Getting Started\n\n1. Install dependencies:\n   ```bash\n   pnpm install\n   ```\n\n2. Build AGENTS.md from rules:\n   ```bash\n   pnpm build\n   ```\n\n3. Validate rule files:\n   ```bash\n   pnpm validate\n   ```\n\n4. Extract test cases:\n   ```bash\n   pnpm extract-tests\n   ```\n\n## Creating a New Rule\n\n1. Copy `rules/_template.md` to `rules/area-description.md`\n2. Choose the appropriate area prefix:\n   - `async-` for Eliminating Waterfalls (Section 1)\n   - `bundle-` for Bundle Size Optimization (Section 2)\n   - `server-` for Server-Side Performance (Section 3)\n   - `client-` for Client-Side Data Fetching (Section 4)\n   - `rerender-` for Re-render Optimization (Section 5)\n   - `rendering-` for Rendering Performance (Section 6)\n   - `js-` for JavaScript Performance (Section 7)\n   - `advanced-` for Advanced Patterns (Section 8)\n3. Fill in the frontmatter and content\n4. Ensure you have clear examples with explanations\n5. Run `pnpm build` to regenerate AGENTS.md and test-cases.json\n\n## Rule File Structure\n\nEach rule file should follow this structure:\n\n```markdown\n---\ntitle: Rule Title Here\nimpact: MEDIUM\nimpactDescription: Optional description\ntags: tag1, tag2, tag3\n---\n\n## Rule Title Here\n\nBrief explanation of the rule and why it matters.\n\n**Incorrect (description of what's wrong):**\n\n```typescript\n// Bad code example\n```\n\n**Correct (description of what's right):**\n\n```typescript\n// Good code example\n```\n\nOptional explanatory text after examples.\n\nReference: [Link](https://example.com)\n\n## File Naming Convention\n\n- Files starting with `_` are special (excluded from build)\n- Rule files: `area-description.md` (e.g., `async-parallel.md`)\n- Section is automatically inferred from filename prefix\n- Rules are sorted alphabetically by title within each section\n- IDs (e.g., 1.1, 1.2) are auto-generated during build\n\n## Impact Levels\n\n- `CRITICAL` - Highest priority, major performance gains\n- `HIGH` - Significant performance improvements\n- `MEDIUM-HIGH` - Moderate-high gains\n- `MEDIUM` - Moderate performance improvements\n- `LOW-MEDIUM` - Low-medium gains\n- `LOW` - Incremental improvements\n\n## Scripts\n\n- `pnpm build` - Compile rules into AGENTS.md\n- `pnpm validate` - Validate all rule files\n- `pnpm extract-tests` - Extract test cases for LLM evaluation\n- `pnpm dev` - Build and validate\n\n## Contributing\n\nWhen adding or modifying rules:\n\n1. Use the correct filename prefix for your section\n2. Follow the `_template.md` structure\n3. Include clear bad/good examples with explanations\n4. Add appropriate tags\n5. Run `pnpm build` to regenerate AGENTS.md and test-cases.json\n6. Rules are automatically sorted by title - no need to manage numbers!\n\n## Acknowledgments\n\nOriginally created by [@shuding](https://x.com/shuding) at [Vercel](https://vercel.com).\n",
        "skills/react-best-practices/SKILL.md": "---\nname: vercel-react-best-practices\ndescription: React and Next.js performance optimization guidelines from Vercel Engineering. This skill should be used when writing, reviewing, or refactoring React/Next.js code to ensure optimal performance patterns. Triggers on tasks involving React components, Next.js pages, data fetching, bundle optimization, or performance improvements.\nlicense: MIT\nmetadata:\n  author: vercel\n  version: \"1.0.0\"\n---\n\n# Vercel React Best Practices\n\nComprehensive performance optimization guide for React and Next.js applications, maintained by Vercel. Contains 57 rules across 8 categories, prioritized by impact to guide automated refactoring and code generation.\n\n## When to Apply\n\nReference these guidelines when:\n- Writing new React components or Next.js pages\n- Implementing data fetching (client or server-side)\n- Reviewing code for performance issues\n- Refactoring existing React/Next.js code\n- Optimizing bundle size or load times\n\n## Rule Categories by Priority\n\n| Priority | Category | Impact | Prefix |\n|----------|----------|--------|--------|\n| 1 | Eliminating Waterfalls | CRITICAL | `async-` |\n| 2 | Bundle Size Optimization | CRITICAL | `bundle-` |\n| 3 | Server-Side Performance | HIGH | `server-` |\n| 4 | Client-Side Data Fetching | MEDIUM-HIGH | `client-` |\n| 5 | Re-render Optimization | MEDIUM | `rerender-` |\n| 6 | Rendering Performance | MEDIUM | `rendering-` |\n| 7 | JavaScript Performance | LOW-MEDIUM | `js-` |\n| 8 | Advanced Patterns | LOW | `advanced-` |\n\n## Quick Reference\n\n### 1. Eliminating Waterfalls (CRITICAL)\n\n- `async-defer-await` - Move await into branches where actually used\n- `async-parallel` - Use Promise.all() for independent operations\n- `async-dependencies` - Use better-all for partial dependencies\n- `async-api-routes` - Start promises early, await late in API routes\n- `async-suspense-boundaries` - Use Suspense to stream content\n\n### 2. Bundle Size Optimization (CRITICAL)\n\n- `bundle-barrel-imports` - Import directly, avoid barrel files\n- `bundle-dynamic-imports` - Use next/dynamic for heavy components\n- `bundle-defer-third-party` - Load analytics/logging after hydration\n- `bundle-conditional` - Load modules only when feature is activated\n- `bundle-preload` - Preload on hover/focus for perceived speed\n\n### 3. Server-Side Performance (HIGH)\n\n- `server-auth-actions` - Authenticate server actions like API routes\n- `server-cache-react` - Use React.cache() for per-request deduplication\n- `server-cache-lru` - Use LRU cache for cross-request caching\n- `server-dedup-props` - Avoid duplicate serialization in RSC props\n- `server-serialization` - Minimize data passed to client components\n- `server-parallel-fetching` - Restructure components to parallelize fetches\n- `server-after-nonblocking` - Use after() for non-blocking operations\n\n### 4. Client-Side Data Fetching (MEDIUM-HIGH)\n\n- `client-swr-dedup` - Use SWR for automatic request deduplication\n- `client-event-listeners` - Deduplicate global event listeners\n- `client-passive-event-listeners` - Use passive listeners for scroll\n- `client-localstorage-schema` - Version and minimize localStorage data\n\n### 5. Re-render Optimization (MEDIUM)\n\n- `rerender-defer-reads` - Don't subscribe to state only used in callbacks\n- `rerender-memo` - Extract expensive work into memoized components\n- `rerender-memo-with-default-value` - Hoist default non-primitive props\n- `rerender-dependencies` - Use primitive dependencies in effects\n- `rerender-derived-state` - Subscribe to derived booleans, not raw values\n- `rerender-derived-state-no-effect` - Derive state during render, not effects\n- `rerender-functional-setstate` - Use functional setState for stable callbacks\n- `rerender-lazy-state-init` - Pass function to useState for expensive values\n- `rerender-simple-expression-in-memo` - Avoid memo for simple primitives\n- `rerender-move-effect-to-event` - Put interaction logic in event handlers\n- `rerender-transitions` - Use startTransition for non-urgent updates\n- `rerender-use-ref-transient-values` - Use refs for transient frequent values\n\n### 6. Rendering Performance (MEDIUM)\n\n- `rendering-animate-svg-wrapper` - Animate div wrapper, not SVG element\n- `rendering-content-visibility` - Use content-visibility for long lists\n- `rendering-hoist-jsx` - Extract static JSX outside components\n- `rendering-svg-precision` - Reduce SVG coordinate precision\n- `rendering-hydration-no-flicker` - Use inline script for client-only data\n- `rendering-hydration-suppress-warning` - Suppress expected mismatches\n- `rendering-activity` - Use Activity component for show/hide\n- `rendering-conditional-render` - Use ternary, not && for conditionals\n- `rendering-usetransition-loading` - Prefer useTransition for loading state\n\n### 7. JavaScript Performance (LOW-MEDIUM)\n\n- `js-batch-dom-css` - Group CSS changes via classes or cssText\n- `js-index-maps` - Build Map for repeated lookups\n- `js-cache-property-access` - Cache object properties in loops\n- `js-cache-function-results` - Cache function results in module-level Map\n- `js-cache-storage` - Cache localStorage/sessionStorage reads\n- `js-combine-iterations` - Combine multiple filter/map into one loop\n- `js-length-check-first` - Check array length before expensive comparison\n- `js-early-exit` - Return early from functions\n- `js-hoist-regexp` - Hoist RegExp creation outside loops\n- `js-min-max-loop` - Use loop for min/max instead of sort\n- `js-set-map-lookups` - Use Set/Map for O(1) lookups\n- `js-tosorted-immutable` - Use toSorted() for immutability\n\n### 8. Advanced Patterns (LOW)\n\n- `advanced-event-handler-refs` - Store event handlers in refs\n- `advanced-init-once` - Initialize app once per app load\n- `advanced-use-latest` - useLatest for stable callback refs\n\n## How to Use\n\nRead individual rule files for detailed explanations and code examples:\n\n```\nrules/async-parallel.md\nrules/bundle-barrel-imports.md\n```\n\nEach rule file contains:\n- Brief explanation of why it matters\n- Incorrect code example with explanation\n- Correct code example with explanation\n- Additional context and references\n\n## Full Compiled Document\n\nFor the complete guide with all rules expanded: `AGENTS.md`\n",
        "skills/react-best-practices/rules/_sections.md": "# Sections\n\nThis file defines all sections, their ordering, impact levels, and descriptions.\nThe section ID (in parentheses) is the filename prefix used to group rules.\n\n---\n\n## 1. Eliminating Waterfalls (async)\n\n**Impact:** CRITICAL  \n**Description:** Waterfalls are the #1 performance killer. Each sequential await adds full network latency. Eliminating them yields the largest gains.\n\n## 2. Bundle Size Optimization (bundle)\n\n**Impact:** CRITICAL  \n**Description:** Reducing initial bundle size improves Time to Interactive and Largest Contentful Paint.\n\n## 3. Server-Side Performance (server)\n\n**Impact:** HIGH  \n**Description:** Optimizing server-side rendering and data fetching eliminates server-side waterfalls and reduces response times.\n\n## 4. Client-Side Data Fetching (client)\n\n**Impact:** MEDIUM-HIGH  \n**Description:** Automatic deduplication and efficient data fetching patterns reduce redundant network requests.\n\n## 5. Re-render Optimization (rerender)\n\n**Impact:** MEDIUM  \n**Description:** Reducing unnecessary re-renders minimizes wasted computation and improves UI responsiveness.\n\n## 6. Rendering Performance (rendering)\n\n**Impact:** MEDIUM  \n**Description:** Optimizing the rendering process reduces the work the browser needs to do.\n\n## 7. JavaScript Performance (js)\n\n**Impact:** LOW-MEDIUM  \n**Description:** Micro-optimizations for hot paths can add up to meaningful improvements.\n\n## 8. Advanced Patterns (advanced)\n\n**Impact:** LOW  \n**Description:** Advanced patterns for specific cases that require careful implementation.\n",
        "skills/react-best-practices/rules/_template.md": "---\ntitle: Rule Title Here\nimpact: MEDIUM\nimpactDescription: Optional description of impact (e.g., \"20-50% improvement\")\ntags: tag1, tag2\n---\n\n## Rule Title Here\n\n**Impact: MEDIUM (optional impact description)**\n\nBrief explanation of the rule and why it matters. This should be clear and concise, explaining the performance implications.\n\n**Incorrect (description of what's wrong):**\n\n```typescript\n// Bad code example here\nconst bad = example()\n```\n\n**Correct (description of what's right):**\n\n```typescript\n// Good code example here\nconst good = example()\n```\n\nReference: [Link to documentation or resource](https://example.com)\n",
        "skills/react-best-practices/rules/advanced-event-handler-refs.md": "---\ntitle: Store Event Handlers in Refs\nimpact: LOW\nimpactDescription: stable subscriptions\ntags: advanced, hooks, refs, event-handlers, optimization\n---\n\n## Store Event Handlers in Refs\n\nStore callbacks in refs when used in effects that shouldn't re-subscribe on callback changes.\n\n**Incorrect (re-subscribes on every render):**\n\n```tsx\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  useEffect(() => {\n    window.addEventListener(event, handler)\n    return () => window.removeEventListener(event, handler)\n  }, [event, handler])\n}\n```\n\n**Correct (stable subscription):**\n\n```tsx\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  const handlerRef = useRef(handler)\n  useEffect(() => {\n    handlerRef.current = handler\n  }, [handler])\n\n  useEffect(() => {\n    const listener = (e) => handlerRef.current(e)\n    window.addEventListener(event, listener)\n    return () => window.removeEventListener(event, listener)\n  }, [event])\n}\n```\n\n**Alternative: use `useEffectEvent` if you're on latest React:**\n\n```tsx\nimport { useEffectEvent } from 'react'\n\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  const onEvent = useEffectEvent(handler)\n\n  useEffect(() => {\n    window.addEventListener(event, onEvent)\n    return () => window.removeEventListener(event, onEvent)\n  }, [event])\n}\n```\n\n`useEffectEvent` provides a cleaner API for the same pattern: it creates a stable function reference that always calls the latest version of the handler.\n",
        "skills/react-best-practices/rules/advanced-init-once.md": "---\ntitle: Initialize App Once, Not Per Mount\nimpact: LOW-MEDIUM\nimpactDescription: avoids duplicate init in development\ntags: initialization, useEffect, app-startup, side-effects\n---\n\n## Initialize App Once, Not Per Mount\n\nDo not put app-wide initialization that must run once per app load inside `useEffect([])` of a component. Components can remount and effects will re-run. Use a module-level guard or top-level init in the entry module instead.\n\n**Incorrect (runs twice in dev, re-runs on remount):**\n\n```tsx\nfunction Comp() {\n  useEffect(() => {\n    loadFromStorage()\n    checkAuthToken()\n  }, [])\n\n  // ...\n}\n```\n\n**Correct (once per app load):**\n\n```tsx\nlet didInit = false\n\nfunction Comp() {\n  useEffect(() => {\n    if (didInit) return\n    didInit = true\n    loadFromStorage()\n    checkAuthToken()\n  }, [])\n\n  // ...\n}\n```\n\nReference: [Initializing the application](https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application)\n",
        "skills/react-best-practices/rules/advanced-use-latest.md": "---\ntitle: useEffectEvent for Stable Callback Refs\nimpact: LOW\nimpactDescription: prevents effect re-runs\ntags: advanced, hooks, useEffectEvent, refs, optimization\n---\n\n## useEffectEvent for Stable Callback Refs\n\nAccess latest values in callbacks without adding them to dependency arrays. Prevents effect re-runs while avoiding stale closures.\n\n**Incorrect (effect re-runs on every callback change):**\n\n```tsx\nfunction SearchInput({ onSearch }: { onSearch: (q: string) => void }) {\n  const [query, setQuery] = useState('')\n\n  useEffect(() => {\n    const timeout = setTimeout(() => onSearch(query), 300)\n    return () => clearTimeout(timeout)\n  }, [query, onSearch])\n}\n```\n\n**Correct (using React's useEffectEvent):**\n\n```tsx\nimport { useEffectEvent } from 'react';\n\nfunction SearchInput({ onSearch }: { onSearch: (q: string) => void }) {\n  const [query, setQuery] = useState('')\n  const onSearchEvent = useEffectEvent(onSearch)\n\n  useEffect(() => {\n    const timeout = setTimeout(() => onSearchEvent(query), 300)\n    return () => clearTimeout(timeout)\n  }, [query])\n}\n```\n",
        "skills/react-best-practices/rules/async-api-routes.md": "---\ntitle: Prevent Waterfall Chains in API Routes\nimpact: CRITICAL\nimpactDescription: 2-10× improvement\ntags: api-routes, server-actions, waterfalls, parallelization\n---\n\n## Prevent Waterfall Chains in API Routes\n\nIn API routes and Server Actions, start independent operations immediately, even if you don't await them yet.\n\n**Incorrect (config waits for auth, data waits for both):**\n\n```typescript\nexport async function GET(request: Request) {\n  const session = await auth()\n  const config = await fetchConfig()\n  const data = await fetchData(session.user.id)\n  return Response.json({ data, config })\n}\n```\n\n**Correct (auth and config start immediately):**\n\n```typescript\nexport async function GET(request: Request) {\n  const sessionPromise = auth()\n  const configPromise = fetchConfig()\n  const session = await sessionPromise\n  const [config, data] = await Promise.all([\n    configPromise,\n    fetchData(session.user.id)\n  ])\n  return Response.json({ data, config })\n}\n```\n\nFor operations with more complex dependency chains, use `better-all` to automatically maximize parallelism (see Dependency-Based Parallelization).\n",
        "skills/react-best-practices/rules/async-defer-await.md": "---\ntitle: Defer Await Until Needed\nimpact: HIGH\nimpactDescription: avoids blocking unused code paths\ntags: async, await, conditional, optimization\n---\n\n## Defer Await Until Needed\n\nMove `await` operations into the branches where they're actually used to avoid blocking code paths that don't need them.\n\n**Incorrect (blocks both branches):**\n\n```typescript\nasync function handleRequest(userId: string, skipProcessing: boolean) {\n  const userData = await fetchUserData(userId)\n  \n  if (skipProcessing) {\n    // Returns immediately but still waited for userData\n    return { skipped: true }\n  }\n  \n  // Only this branch uses userData\n  return processUserData(userData)\n}\n```\n\n**Correct (only blocks when needed):**\n\n```typescript\nasync function handleRequest(userId: string, skipProcessing: boolean) {\n  if (skipProcessing) {\n    // Returns immediately without waiting\n    return { skipped: true }\n  }\n  \n  // Fetch only when needed\n  const userData = await fetchUserData(userId)\n  return processUserData(userData)\n}\n```\n\n**Another example (early return optimization):**\n\n```typescript\n// Incorrect: always fetches permissions\nasync function updateResource(resourceId: string, userId: string) {\n  const permissions = await fetchPermissions(userId)\n  const resource = await getResource(resourceId)\n  \n  if (!resource) {\n    return { error: 'Not found' }\n  }\n  \n  if (!permissions.canEdit) {\n    return { error: 'Forbidden' }\n  }\n  \n  return await updateResourceData(resource, permissions)\n}\n\n// Correct: fetches only when needed\nasync function updateResource(resourceId: string, userId: string) {\n  const resource = await getResource(resourceId)\n  \n  if (!resource) {\n    return { error: 'Not found' }\n  }\n  \n  const permissions = await fetchPermissions(userId)\n  \n  if (!permissions.canEdit) {\n    return { error: 'Forbidden' }\n  }\n  \n  return await updateResourceData(resource, permissions)\n}\n```\n\nThis optimization is especially valuable when the skipped branch is frequently taken, or when the deferred operation is expensive.\n",
        "skills/react-best-practices/rules/async-dependencies.md": "---\ntitle: Dependency-Based Parallelization\nimpact: CRITICAL\nimpactDescription: 2-10× improvement\ntags: async, parallelization, dependencies, better-all\n---\n\n## Dependency-Based Parallelization\n\nFor operations with partial dependencies, use `better-all` to maximize parallelism. It automatically starts each task at the earliest possible moment.\n\n**Incorrect (profile waits for config unnecessarily):**\n\n```typescript\nconst [user, config] = await Promise.all([\n  fetchUser(),\n  fetchConfig()\n])\nconst profile = await fetchProfile(user.id)\n```\n\n**Correct (config and profile run in parallel):**\n\n```typescript\nimport { all } from 'better-all'\n\nconst { user, config, profile } = await all({\n  async user() { return fetchUser() },\n  async config() { return fetchConfig() },\n  async profile() {\n    return fetchProfile((await this.$.user).id)\n  }\n})\n```\n\n**Alternative without extra dependencies:**\n\nWe can also create all the promises first, and do `Promise.all()` at the end.\n\n```typescript\nconst userPromise = fetchUser()\nconst profilePromise = userPromise.then(user => fetchProfile(user.id))\n\nconst [user, config, profile] = await Promise.all([\n  userPromise,\n  fetchConfig(),\n  profilePromise\n])\n```\n\nReference: [https://github.com/shuding/better-all](https://github.com/shuding/better-all)\n",
        "skills/react-best-practices/rules/async-parallel.md": "---\ntitle: Promise.all() for Independent Operations\nimpact: CRITICAL\nimpactDescription: 2-10× improvement\ntags: async, parallelization, promises, waterfalls\n---\n\n## Promise.all() for Independent Operations\n\nWhen async operations have no interdependencies, execute them concurrently using `Promise.all()`.\n\n**Incorrect (sequential execution, 3 round trips):**\n\n```typescript\nconst user = await fetchUser()\nconst posts = await fetchPosts()\nconst comments = await fetchComments()\n```\n\n**Correct (parallel execution, 1 round trip):**\n\n```typescript\nconst [user, posts, comments] = await Promise.all([\n  fetchUser(),\n  fetchPosts(),\n  fetchComments()\n])\n```\n",
        "skills/react-best-practices/rules/async-suspense-boundaries.md": "---\ntitle: Strategic Suspense Boundaries\nimpact: HIGH\nimpactDescription: faster initial paint\ntags: async, suspense, streaming, layout-shift\n---\n\n## Strategic Suspense Boundaries\n\nInstead of awaiting data in async components before returning JSX, use Suspense boundaries to show the wrapper UI faster while data loads.\n\n**Incorrect (wrapper blocked by data fetching):**\n\n```tsx\nasync function Page() {\n  const data = await fetchData() // Blocks entire page\n  \n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <div>\n        <DataDisplay data={data} />\n      </div>\n      <div>Footer</div>\n    </div>\n  )\n}\n```\n\nThe entire layout waits for data even though only the middle section needs it.\n\n**Correct (wrapper shows immediately, data streams in):**\n\n```tsx\nfunction Page() {\n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <div>\n        <Suspense fallback={<Skeleton />}>\n          <DataDisplay />\n        </Suspense>\n      </div>\n      <div>Footer</div>\n    </div>\n  )\n}\n\nasync function DataDisplay() {\n  const data = await fetchData() // Only blocks this component\n  return <div>{data.content}</div>\n}\n```\n\nSidebar, Header, and Footer render immediately. Only DataDisplay waits for data.\n\n**Alternative (share promise across components):**\n\n```tsx\nfunction Page() {\n  // Start fetch immediately, but don't await\n  const dataPromise = fetchData()\n  \n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <Suspense fallback={<Skeleton />}>\n        <DataDisplay dataPromise={dataPromise} />\n        <DataSummary dataPromise={dataPromise} />\n      </Suspense>\n      <div>Footer</div>\n    </div>\n  )\n}\n\nfunction DataDisplay({ dataPromise }: { dataPromise: Promise<Data> }) {\n  const data = use(dataPromise) // Unwraps the promise\n  return <div>{data.content}</div>\n}\n\nfunction DataSummary({ dataPromise }: { dataPromise: Promise<Data> }) {\n  const data = use(dataPromise) // Reuses the same promise\n  return <div>{data.summary}</div>\n}\n```\n\nBoth components share the same promise, so only one fetch occurs. Layout renders immediately while both components wait together.\n\n**When NOT to use this pattern:**\n\n- Critical data needed for layout decisions (affects positioning)\n- SEO-critical content above the fold\n- Small, fast queries where suspense overhead isn't worth it\n- When you want to avoid layout shift (loading → content jump)\n\n**Trade-off:** Faster initial paint vs potential layout shift. Choose based on your UX priorities.\n",
        "skills/react-best-practices/rules/bundle-barrel-imports.md": "---\ntitle: Avoid Barrel File Imports\nimpact: CRITICAL\nimpactDescription: 200-800ms import cost, slow builds\ntags: bundle, imports, tree-shaking, barrel-files, performance\n---\n\n## Avoid Barrel File Imports\n\nImport directly from source files instead of barrel files to avoid loading thousands of unused modules. **Barrel files** are entry points that re-export multiple modules (e.g., `index.js` that does `export * from './module'`).\n\nPopular icon and component libraries can have **up to 10,000 re-exports** in their entry file. For many React packages, **it takes 200-800ms just to import them**, affecting both development speed and production cold starts.\n\n**Why tree-shaking doesn't help:** When a library is marked as external (not bundled), the bundler can't optimize it. If you bundle it to enable tree-shaking, builds become substantially slower analyzing the entire module graph.\n\n**Incorrect (imports entire library):**\n\n```tsx\nimport { Check, X, Menu } from 'lucide-react'\n// Loads 1,583 modules, takes ~2.8s extra in dev\n// Runtime cost: 200-800ms on every cold start\n\nimport { Button, TextField } from '@mui/material'\n// Loads 2,225 modules, takes ~4.2s extra in dev\n```\n\n**Correct (imports only what you need):**\n\n```tsx\nimport Check from 'lucide-react/dist/esm/icons/check'\nimport X from 'lucide-react/dist/esm/icons/x'\nimport Menu from 'lucide-react/dist/esm/icons/menu'\n// Loads only 3 modules (~2KB vs ~1MB)\n\nimport Button from '@mui/material/Button'\nimport TextField from '@mui/material/TextField'\n// Loads only what you use\n```\n\n**Alternative (Next.js 13.5+):**\n\n```js\n// next.config.js - use optimizePackageImports\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['lucide-react', '@mui/material']\n  }\n}\n\n// Then you can keep the ergonomic barrel imports:\nimport { Check, X, Menu } from 'lucide-react'\n// Automatically transformed to direct imports at build time\n```\n\nDirect imports provide 15-70% faster dev boot, 28% faster builds, 40% faster cold starts, and significantly faster HMR.\n\nLibraries commonly affected: `lucide-react`, `@mui/material`, `@mui/icons-material`, `@tabler/icons-react`, `react-icons`, `@headlessui/react`, `@radix-ui/react-*`, `lodash`, `ramda`, `date-fns`, `rxjs`, `react-use`.\n\nReference: [How we optimized package imports in Next.js](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)\n",
        "skills/react-best-practices/rules/bundle-conditional.md": "---\ntitle: Conditional Module Loading\nimpact: HIGH\nimpactDescription: loads large data only when needed\ntags: bundle, conditional-loading, lazy-loading\n---\n\n## Conditional Module Loading\n\nLoad large data or modules only when a feature is activated.\n\n**Example (lazy-load animation frames):**\n\n```tsx\nfunction AnimationPlayer({ enabled, setEnabled }: { enabled: boolean; setEnabled: React.Dispatch<React.SetStateAction<boolean>> }) {\n  const [frames, setFrames] = useState<Frame[] | null>(null)\n\n  useEffect(() => {\n    if (enabled && !frames && typeof window !== 'undefined') {\n      import('./animation-frames.js')\n        .then(mod => setFrames(mod.frames))\n        .catch(() => setEnabled(false))\n    }\n  }, [enabled, frames, setEnabled])\n\n  if (!frames) return <Skeleton />\n  return <Canvas frames={frames} />\n}\n```\n\nThe `typeof window !== 'undefined'` check prevents bundling this module for SSR, optimizing server bundle size and build speed.\n",
        "skills/react-best-practices/rules/bundle-defer-third-party.md": "---\ntitle: Defer Non-Critical Third-Party Libraries\nimpact: MEDIUM\nimpactDescription: loads after hydration\ntags: bundle, third-party, analytics, defer\n---\n\n## Defer Non-Critical Third-Party Libraries\n\nAnalytics, logging, and error tracking don't block user interaction. Load them after hydration.\n\n**Incorrect (blocks initial bundle):**\n\n```tsx\nimport { Analytics } from '@vercel/analytics/react'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  )\n}\n```\n\n**Correct (loads after hydration):**\n\n```tsx\nimport dynamic from 'next/dynamic'\n\nconst Analytics = dynamic(\n  () => import('@vercel/analytics/react').then(m => m.Analytics),\n  { ssr: false }\n)\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  )\n}\n```\n",
        "skills/react-best-practices/rules/bundle-dynamic-imports.md": "---\ntitle: Dynamic Imports for Heavy Components\nimpact: CRITICAL\nimpactDescription: directly affects TTI and LCP\ntags: bundle, dynamic-import, code-splitting, next-dynamic\n---\n\n## Dynamic Imports for Heavy Components\n\nUse `next/dynamic` to lazy-load large components not needed on initial render.\n\n**Incorrect (Monaco bundles with main chunk ~300KB):**\n\n```tsx\nimport { MonacoEditor } from './monaco-editor'\n\nfunction CodePanel({ code }: { code: string }) {\n  return <MonacoEditor value={code} />\n}\n```\n\n**Correct (Monaco loads on demand):**\n\n```tsx\nimport dynamic from 'next/dynamic'\n\nconst MonacoEditor = dynamic(\n  () => import('./monaco-editor').then(m => m.MonacoEditor),\n  { ssr: false }\n)\n\nfunction CodePanel({ code }: { code: string }) {\n  return <MonacoEditor value={code} />\n}\n```\n",
        "skills/react-best-practices/rules/bundle-preload.md": "---\ntitle: Preload Based on User Intent\nimpact: MEDIUM\nimpactDescription: reduces perceived latency\ntags: bundle, preload, user-intent, hover\n---\n\n## Preload Based on User Intent\n\nPreload heavy bundles before they're needed to reduce perceived latency.\n\n**Example (preload on hover/focus):**\n\n```tsx\nfunction EditorButton({ onClick }: { onClick: () => void }) {\n  const preload = () => {\n    if (typeof window !== 'undefined') {\n      void import('./monaco-editor')\n    }\n  }\n\n  return (\n    <button\n      onMouseEnter={preload}\n      onFocus={preload}\n      onClick={onClick}\n    >\n      Open Editor\n    </button>\n  )\n}\n```\n\n**Example (preload when feature flag is enabled):**\n\n```tsx\nfunction FlagsProvider({ children, flags }: Props) {\n  useEffect(() => {\n    if (flags.editorEnabled && typeof window !== 'undefined') {\n      void import('./monaco-editor').then(mod => mod.init())\n    }\n  }, [flags.editorEnabled])\n\n  return <FlagsContext.Provider value={flags}>\n    {children}\n  </FlagsContext.Provider>\n}\n```\n\nThe `typeof window !== 'undefined'` check prevents bundling preloaded modules for SSR, optimizing server bundle size and build speed.\n",
        "skills/react-best-practices/rules/client-event-listeners.md": "---\ntitle: Deduplicate Global Event Listeners\nimpact: LOW\nimpactDescription: single listener for N components\ntags: client, swr, event-listeners, subscription\n---\n\n## Deduplicate Global Event Listeners\n\nUse `useSWRSubscription()` to share global event listeners across component instances.\n\n**Incorrect (N instances = N listeners):**\n\n```tsx\nfunction useKeyboardShortcut(key: string, callback: () => void) {\n  useEffect(() => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.metaKey && e.key === key) {\n        callback()\n      }\n    }\n    window.addEventListener('keydown', handler)\n    return () => window.removeEventListener('keydown', handler)\n  }, [key, callback])\n}\n```\n\nWhen using the `useKeyboardShortcut` hook multiple times, each instance will register a new listener.\n\n**Correct (N instances = 1 listener):**\n\n```tsx\nimport useSWRSubscription from 'swr/subscription'\n\n// Module-level Map to track callbacks per key\nconst keyCallbacks = new Map<string, Set<() => void>>()\n\nfunction useKeyboardShortcut(key: string, callback: () => void) {\n  // Register this callback in the Map\n  useEffect(() => {\n    if (!keyCallbacks.has(key)) {\n      keyCallbacks.set(key, new Set())\n    }\n    keyCallbacks.get(key)!.add(callback)\n\n    return () => {\n      const set = keyCallbacks.get(key)\n      if (set) {\n        set.delete(callback)\n        if (set.size === 0) {\n          keyCallbacks.delete(key)\n        }\n      }\n    }\n  }, [key, callback])\n\n  useSWRSubscription('global-keydown', () => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.metaKey && keyCallbacks.has(e.key)) {\n        keyCallbacks.get(e.key)!.forEach(cb => cb())\n      }\n    }\n    window.addEventListener('keydown', handler)\n    return () => window.removeEventListener('keydown', handler)\n  })\n}\n\nfunction Profile() {\n  // Multiple shortcuts will share the same listener\n  useKeyboardShortcut('p', () => { /* ... */ }) \n  useKeyboardShortcut('k', () => { /* ... */ })\n  // ...\n}\n```\n",
        "skills/react-best-practices/rules/client-localstorage-schema.md": "---\ntitle: Version and Minimize localStorage Data\nimpact: MEDIUM\nimpactDescription: prevents schema conflicts, reduces storage size\ntags: client, localStorage, storage, versioning, data-minimization\n---\n\n## Version and Minimize localStorage Data\n\nAdd version prefix to keys and store only needed fields. Prevents schema conflicts and accidental storage of sensitive data.\n\n**Incorrect:**\n\n```typescript\n// No version, stores everything, no error handling\nlocalStorage.setItem('userConfig', JSON.stringify(fullUserObject))\nconst data = localStorage.getItem('userConfig')\n```\n\n**Correct:**\n\n```typescript\nconst VERSION = 'v2'\n\nfunction saveConfig(config: { theme: string; language: string }) {\n  try {\n    localStorage.setItem(`userConfig:${VERSION}`, JSON.stringify(config))\n  } catch {\n    // Throws in incognito/private browsing, quota exceeded, or disabled\n  }\n}\n\nfunction loadConfig() {\n  try {\n    const data = localStorage.getItem(`userConfig:${VERSION}`)\n    return data ? JSON.parse(data) : null\n  } catch {\n    return null\n  }\n}\n\n// Migration from v1 to v2\nfunction migrate() {\n  try {\n    const v1 = localStorage.getItem('userConfig:v1')\n    if (v1) {\n      const old = JSON.parse(v1)\n      saveConfig({ theme: old.darkMode ? 'dark' : 'light', language: old.lang })\n      localStorage.removeItem('userConfig:v1')\n    }\n  } catch {}\n}\n```\n\n**Store minimal fields from server responses:**\n\n```typescript\n// User object has 20+ fields, only store what UI needs\nfunction cachePrefs(user: FullUser) {\n  try {\n    localStorage.setItem('prefs:v1', JSON.stringify({\n      theme: user.preferences.theme,\n      notifications: user.preferences.notifications\n    }))\n  } catch {}\n}\n```\n\n**Always wrap in try-catch:** `getItem()` and `setItem()` throw in incognito/private browsing (Safari, Firefox), when quota exceeded, or when disabled.\n\n**Benefits:** Schema evolution via versioning, reduced storage size, prevents storing tokens/PII/internal flags.\n",
        "skills/react-best-practices/rules/client-passive-event-listeners.md": "---\ntitle: Use Passive Event Listeners for Scrolling Performance\nimpact: MEDIUM\nimpactDescription: eliminates scroll delay caused by event listeners\ntags: client, event-listeners, scrolling, performance, touch, wheel\n---\n\n## Use Passive Event Listeners for Scrolling Performance\n\nAdd `{ passive: true }` to touch and wheel event listeners to enable immediate scrolling. Browsers normally wait for listeners to finish to check if `preventDefault()` is called, causing scroll delay.\n\n**Incorrect:**\n\n```typescript\nuseEffect(() => {\n  const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)\n  const handleWheel = (e: WheelEvent) => console.log(e.deltaY)\n  \n  document.addEventListener('touchstart', handleTouch)\n  document.addEventListener('wheel', handleWheel)\n  \n  return () => {\n    document.removeEventListener('touchstart', handleTouch)\n    document.removeEventListener('wheel', handleWheel)\n  }\n}, [])\n```\n\n**Correct:**\n\n```typescript\nuseEffect(() => {\n  const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)\n  const handleWheel = (e: WheelEvent) => console.log(e.deltaY)\n  \n  document.addEventListener('touchstart', handleTouch, { passive: true })\n  document.addEventListener('wheel', handleWheel, { passive: true })\n  \n  return () => {\n    document.removeEventListener('touchstart', handleTouch)\n    document.removeEventListener('wheel', handleWheel)\n  }\n}, [])\n```\n\n**Use passive when:** tracking/analytics, logging, any listener that doesn't call `preventDefault()`.\n\n**Don't use passive when:** implementing custom swipe gestures, custom zoom controls, or any listener that needs `preventDefault()`.\n",
        "skills/react-best-practices/rules/client-swr-dedup.md": "---\ntitle: Use SWR for Automatic Deduplication\nimpact: MEDIUM-HIGH\nimpactDescription: automatic deduplication\ntags: client, swr, deduplication, data-fetching\n---\n\n## Use SWR for Automatic Deduplication\n\nSWR enables request deduplication, caching, and revalidation across component instances.\n\n**Incorrect (no deduplication, each instance fetches):**\n\n```tsx\nfunction UserList() {\n  const [users, setUsers] = useState([])\n  useEffect(() => {\n    fetch('/api/users')\n      .then(r => r.json())\n      .then(setUsers)\n  }, [])\n}\n```\n\n**Correct (multiple instances share one request):**\n\n```tsx\nimport useSWR from 'swr'\n\nfunction UserList() {\n  const { data: users } = useSWR('/api/users', fetcher)\n}\n```\n\n**For immutable data:**\n\n```tsx\nimport { useImmutableSWR } from '@/lib/swr'\n\nfunction StaticContent() {\n  const { data } = useImmutableSWR('/api/config', fetcher)\n}\n```\n\n**For mutations:**\n\n```tsx\nimport { useSWRMutation } from 'swr/mutation'\n\nfunction UpdateButton() {\n  const { trigger } = useSWRMutation('/api/user', updateUser)\n  return <button onClick={() => trigger()}>Update</button>\n}\n```\n\nReference: [https://swr.vercel.app](https://swr.vercel.app)\n",
        "skills/react-best-practices/rules/js-batch-dom-css.md": "---\ntitle: Avoid Layout Thrashing\nimpact: MEDIUM\nimpactDescription: prevents forced synchronous layouts and reduces performance bottlenecks\ntags: javascript, dom, css, performance, reflow, layout-thrashing\n---\n\n## Avoid Layout Thrashing\n\nAvoid interleaving style writes with layout reads. When you read a layout property (like `offsetWidth`, `getBoundingClientRect()`, or `getComputedStyle()`) between style changes, the browser is forced to trigger a synchronous reflow.\n\n**This is OK (browser batches style changes):**\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  // Each line invalidates style, but browser batches the recalculation\n  element.style.width = '100px'\n  element.style.height = '200px'\n  element.style.backgroundColor = 'blue'\n  element.style.border = '1px solid black'\n}\n```\n\n**Incorrect (interleaved reads and writes force reflows):**\n```typescript\nfunction layoutThrashing(element: HTMLElement) {\n  element.style.width = '100px'\n  const width = element.offsetWidth  // Forces reflow\n  element.style.height = '200px'\n  const height = element.offsetHeight  // Forces another reflow\n}\n```\n\n**Correct (batch writes, then read once):**\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  // Batch all writes together\n  element.style.width = '100px'\n  element.style.height = '200px'\n  element.style.backgroundColor = 'blue'\n  element.style.border = '1px solid black'\n  \n  // Read after all writes are done (single reflow)\n  const { width, height } = element.getBoundingClientRect()\n}\n```\n\n**Correct (batch reads, then writes):**\n```typescript\nfunction avoidThrashing(element: HTMLElement) {\n  // Read phase - all layout queries first\n  const rect1 = element.getBoundingClientRect()\n  const offsetWidth = element.offsetWidth\n  const offsetHeight = element.offsetHeight\n  \n  // Write phase - all style changes after\n  element.style.width = '100px'\n  element.style.height = '200px'\n}\n```\n\n**Better: use CSS classes**\n```css\n.highlighted-box {\n  width: 100px;\n  height: 200px;\n  background-color: blue;\n  border: 1px solid black;\n}\n```\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  element.classList.add('highlighted-box')\n  \n  const { width, height } = element.getBoundingClientRect()\n}\n```\n\n**React example:**\n```tsx\n// Incorrect: interleaving style changes with layout queries\nfunction Box({ isHighlighted }: { isHighlighted: boolean }) {\n  const ref = useRef<HTMLDivElement>(null)\n  \n  useEffect(() => {\n    if (ref.current && isHighlighted) {\n      ref.current.style.width = '100px'\n      const width = ref.current.offsetWidth // Forces layout\n      ref.current.style.height = '200px'\n    }\n  }, [isHighlighted])\n  \n  return <div ref={ref}>Content</div>\n}\n\n// Correct: toggle class\nfunction Box({ isHighlighted }: { isHighlighted: boolean }) {\n  return (\n    <div className={isHighlighted ? 'highlighted-box' : ''}>\n      Content\n    </div>\n  )\n}\n```\n\nPrefer CSS classes over inline styles when possible. CSS files are cached by the browser, and classes provide better separation of concerns and are easier to maintain.\n\nSee [this gist](https://gist.github.com/paulirish/5d52fb081b3570c81e3a) and [CSS Triggers](https://csstriggers.com/) for more information on layout-forcing operations.\n",
        "skills/react-best-practices/rules/js-cache-function-results.md": "---\ntitle: Cache Repeated Function Calls\nimpact: MEDIUM\nimpactDescription: avoid redundant computation\ntags: javascript, cache, memoization, performance\n---\n\n## Cache Repeated Function Calls\n\nUse a module-level Map to cache function results when the same function is called repeatedly with the same inputs during render.\n\n**Incorrect (redundant computation):**\n\n```typescript\nfunction ProjectList({ projects }: { projects: Project[] }) {\n  return (\n    <div>\n      {projects.map(project => {\n        // slugify() called 100+ times for same project names\n        const slug = slugify(project.name)\n        \n        return <ProjectCard key={project.id} slug={slug} />\n      })}\n    </div>\n  )\n}\n```\n\n**Correct (cached results):**\n\n```typescript\n// Module-level cache\nconst slugifyCache = new Map<string, string>()\n\nfunction cachedSlugify(text: string): string {\n  if (slugifyCache.has(text)) {\n    return slugifyCache.get(text)!\n  }\n  const result = slugify(text)\n  slugifyCache.set(text, result)\n  return result\n}\n\nfunction ProjectList({ projects }: { projects: Project[] }) {\n  return (\n    <div>\n      {projects.map(project => {\n        // Computed only once per unique project name\n        const slug = cachedSlugify(project.name)\n        \n        return <ProjectCard key={project.id} slug={slug} />\n      })}\n    </div>\n  )\n}\n```\n\n**Simpler pattern for single-value functions:**\n\n```typescript\nlet isLoggedInCache: boolean | null = null\n\nfunction isLoggedIn(): boolean {\n  if (isLoggedInCache !== null) {\n    return isLoggedInCache\n  }\n  \n  isLoggedInCache = document.cookie.includes('auth=')\n  return isLoggedInCache\n}\n\n// Clear cache when auth changes\nfunction onAuthChange() {\n  isLoggedInCache = null\n}\n```\n\nUse a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.\n\nReference: [How we made the Vercel Dashboard twice as fast](https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast)\n",
        "skills/react-best-practices/rules/js-cache-property-access.md": "---\ntitle: Cache Property Access in Loops\nimpact: LOW-MEDIUM\nimpactDescription: reduces lookups\ntags: javascript, loops, optimization, caching\n---\n\n## Cache Property Access in Loops\n\nCache object property lookups in hot paths.\n\n**Incorrect (3 lookups × N iterations):**\n\n```typescript\nfor (let i = 0; i < arr.length; i++) {\n  process(obj.config.settings.value)\n}\n```\n\n**Correct (1 lookup total):**\n\n```typescript\nconst value = obj.config.settings.value\nconst len = arr.length\nfor (let i = 0; i < len; i++) {\n  process(value)\n}\n```\n",
        "skills/react-best-practices/rules/js-cache-storage.md": "---\ntitle: Cache Storage API Calls\nimpact: LOW-MEDIUM\nimpactDescription: reduces expensive I/O\ntags: javascript, localStorage, storage, caching, performance\n---\n\n## Cache Storage API Calls\n\n`localStorage`, `sessionStorage`, and `document.cookie` are synchronous and expensive. Cache reads in memory.\n\n**Incorrect (reads storage on every call):**\n\n```typescript\nfunction getTheme() {\n  return localStorage.getItem('theme') ?? 'light'\n}\n// Called 10 times = 10 storage reads\n```\n\n**Correct (Map cache):**\n\n```typescript\nconst storageCache = new Map<string, string | null>()\n\nfunction getLocalStorage(key: string) {\n  if (!storageCache.has(key)) {\n    storageCache.set(key, localStorage.getItem(key))\n  }\n  return storageCache.get(key)\n}\n\nfunction setLocalStorage(key: string, value: string) {\n  localStorage.setItem(key, value)\n  storageCache.set(key, value)  // keep cache in sync\n}\n```\n\nUse a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.\n\n**Cookie caching:**\n\n```typescript\nlet cookieCache: Record<string, string> | null = null\n\nfunction getCookie(name: string) {\n  if (!cookieCache) {\n    cookieCache = Object.fromEntries(\n      document.cookie.split('; ').map(c => c.split('='))\n    )\n  }\n  return cookieCache[name]\n}\n```\n\n**Important (invalidate on external changes):**\n\nIf storage can change externally (another tab, server-set cookies), invalidate cache:\n\n```typescript\nwindow.addEventListener('storage', (e) => {\n  if (e.key) storageCache.delete(e.key)\n})\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.visibilityState === 'visible') {\n    storageCache.clear()\n  }\n})\n```\n",
        "skills/react-best-practices/rules/js-combine-iterations.md": "---\ntitle: Combine Multiple Array Iterations\nimpact: LOW-MEDIUM\nimpactDescription: reduces iterations\ntags: javascript, arrays, loops, performance\n---\n\n## Combine Multiple Array Iterations\n\nMultiple `.filter()` or `.map()` calls iterate the array multiple times. Combine into one loop.\n\n**Incorrect (3 iterations):**\n\n```typescript\nconst admins = users.filter(u => u.isAdmin)\nconst testers = users.filter(u => u.isTester)\nconst inactive = users.filter(u => !u.isActive)\n```\n\n**Correct (1 iteration):**\n\n```typescript\nconst admins: User[] = []\nconst testers: User[] = []\nconst inactive: User[] = []\n\nfor (const user of users) {\n  if (user.isAdmin) admins.push(user)\n  if (user.isTester) testers.push(user)\n  if (!user.isActive) inactive.push(user)\n}\n```\n",
        "skills/react-best-practices/rules/js-early-exit.md": "---\ntitle: Early Return from Functions\nimpact: LOW-MEDIUM\nimpactDescription: avoids unnecessary computation\ntags: javascript, functions, optimization, early-return\n---\n\n## Early Return from Functions\n\nReturn early when result is determined to skip unnecessary processing.\n\n**Incorrect (processes all items even after finding answer):**\n\n```typescript\nfunction validateUsers(users: User[]) {\n  let hasError = false\n  let errorMessage = ''\n  \n  for (const user of users) {\n    if (!user.email) {\n      hasError = true\n      errorMessage = 'Email required'\n    }\n    if (!user.name) {\n      hasError = true\n      errorMessage = 'Name required'\n    }\n    // Continues checking all users even after error found\n  }\n  \n  return hasError ? { valid: false, error: errorMessage } : { valid: true }\n}\n```\n\n**Correct (returns immediately on first error):**\n\n```typescript\nfunction validateUsers(users: User[]) {\n  for (const user of users) {\n    if (!user.email) {\n      return { valid: false, error: 'Email required' }\n    }\n    if (!user.name) {\n      return { valid: false, error: 'Name required' }\n    }\n  }\n\n  return { valid: true }\n}\n```\n",
        "skills/react-best-practices/rules/js-hoist-regexp.md": "---\ntitle: Hoist RegExp Creation\nimpact: LOW-MEDIUM\nimpactDescription: avoids recreation\ntags: javascript, regexp, optimization, memoization\n---\n\n## Hoist RegExp Creation\n\nDon't create RegExp inside render. Hoist to module scope or memoize with `useMemo()`.\n\n**Incorrect (new RegExp every render):**\n\n```tsx\nfunction Highlighter({ text, query }: Props) {\n  const regex = new RegExp(`(${query})`, 'gi')\n  const parts = text.split(regex)\n  return <>{parts.map((part, i) => ...)}</>\n}\n```\n\n**Correct (memoize or hoist):**\n\n```tsx\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n\nfunction Highlighter({ text, query }: Props) {\n  const regex = useMemo(\n    () => new RegExp(`(${escapeRegex(query)})`, 'gi'),\n    [query]\n  )\n  const parts = text.split(regex)\n  return <>{parts.map((part, i) => ...)}</>\n}\n```\n\n**Warning (global regex has mutable state):**\n\nGlobal regex (`/g`) has mutable `lastIndex` state:\n\n```typescript\nconst regex = /foo/g\nregex.test('foo')  // true, lastIndex = 3\nregex.test('foo')  // false, lastIndex = 0\n```\n",
        "skills/react-best-practices/rules/js-index-maps.md": "---\ntitle: Build Index Maps for Repeated Lookups\nimpact: LOW-MEDIUM\nimpactDescription: 1M ops to 2K ops\ntags: javascript, map, indexing, optimization, performance\n---\n\n## Build Index Maps for Repeated Lookups\n\nMultiple `.find()` calls by the same key should use a Map.\n\n**Incorrect (O(n) per lookup):**\n\n```typescript\nfunction processOrders(orders: Order[], users: User[]) {\n  return orders.map(order => ({\n    ...order,\n    user: users.find(u => u.id === order.userId)\n  }))\n}\n```\n\n**Correct (O(1) per lookup):**\n\n```typescript\nfunction processOrders(orders: Order[], users: User[]) {\n  const userById = new Map(users.map(u => [u.id, u]))\n\n  return orders.map(order => ({\n    ...order,\n    user: userById.get(order.userId)\n  }))\n}\n```\n\nBuild map once (O(n)), then all lookups are O(1).\nFor 1000 orders × 1000 users: 1M ops → 2K ops.\n",
        "skills/react-best-practices/rules/js-length-check-first.md": "---\ntitle: Early Length Check for Array Comparisons\nimpact: MEDIUM-HIGH\nimpactDescription: avoids expensive operations when lengths differ\ntags: javascript, arrays, performance, optimization, comparison\n---\n\n## Early Length Check for Array Comparisons\n\nWhen comparing arrays with expensive operations (sorting, deep equality, serialization), check lengths first. If lengths differ, the arrays cannot be equal.\n\nIn real-world applications, this optimization is especially valuable when the comparison runs in hot paths (event handlers, render loops).\n\n**Incorrect (always runs expensive comparison):**\n\n```typescript\nfunction hasChanges(current: string[], original: string[]) {\n  // Always sorts and joins, even when lengths differ\n  return current.sort().join() !== original.sort().join()\n}\n```\n\nTwo O(n log n) sorts run even when `current.length` is 5 and `original.length` is 100. There is also overhead of joining the arrays and comparing the strings.\n\n**Correct (O(1) length check first):**\n\n```typescript\nfunction hasChanges(current: string[], original: string[]) {\n  // Early return if lengths differ\n  if (current.length !== original.length) {\n    return true\n  }\n  // Only sort when lengths match\n  const currentSorted = current.toSorted()\n  const originalSorted = original.toSorted()\n  for (let i = 0; i < currentSorted.length; i++) {\n    if (currentSorted[i] !== originalSorted[i]) {\n      return true\n    }\n  }\n  return false\n}\n```\n\nThis new approach is more efficient because:\n- It avoids the overhead of sorting and joining the arrays when lengths differ\n- It avoids consuming memory for the joined strings (especially important for large arrays)\n- It avoids mutating the original arrays\n- It returns early when a difference is found\n",
        "skills/react-best-practices/rules/js-min-max-loop.md": "---\ntitle: Use Loop for Min/Max Instead of Sort\nimpact: LOW\nimpactDescription: O(n) instead of O(n log n)\ntags: javascript, arrays, performance, sorting, algorithms\n---\n\n## Use Loop for Min/Max Instead of Sort\n\nFinding the smallest or largest element only requires a single pass through the array. Sorting is wasteful and slower.\n\n**Incorrect (O(n log n) - sort to find latest):**\n\n```typescript\ninterface Project {\n  id: string\n  name: string\n  updatedAt: number\n}\n\nfunction getLatestProject(projects: Project[]) {\n  const sorted = [...projects].sort((a, b) => b.updatedAt - a.updatedAt)\n  return sorted[0]\n}\n```\n\nSorts the entire array just to find the maximum value.\n\n**Incorrect (O(n log n) - sort for oldest and newest):**\n\n```typescript\nfunction getOldestAndNewest(projects: Project[]) {\n  const sorted = [...projects].sort((a, b) => a.updatedAt - b.updatedAt)\n  return { oldest: sorted[0], newest: sorted[sorted.length - 1] }\n}\n```\n\nStill sorts unnecessarily when only min/max are needed.\n\n**Correct (O(n) - single loop):**\n\n```typescript\nfunction getLatestProject(projects: Project[]) {\n  if (projects.length === 0) return null\n  \n  let latest = projects[0]\n  \n  for (let i = 1; i < projects.length; i++) {\n    if (projects[i].updatedAt > latest.updatedAt) {\n      latest = projects[i]\n    }\n  }\n  \n  return latest\n}\n\nfunction getOldestAndNewest(projects: Project[]) {\n  if (projects.length === 0) return { oldest: null, newest: null }\n  \n  let oldest = projects[0]\n  let newest = projects[0]\n  \n  for (let i = 1; i < projects.length; i++) {\n    if (projects[i].updatedAt < oldest.updatedAt) oldest = projects[i]\n    if (projects[i].updatedAt > newest.updatedAt) newest = projects[i]\n  }\n  \n  return { oldest, newest }\n}\n```\n\nSingle pass through the array, no copying, no sorting.\n\n**Alternative (Math.min/Math.max for small arrays):**\n\n```typescript\nconst numbers = [5, 2, 8, 1, 9]\nconst min = Math.min(...numbers)\nconst max = Math.max(...numbers)\n```\n\nThis works for small arrays, but can be slower or just throw an error for very large arrays due to spread operator limitations. Maximal array length is approximately 124000 in Chrome 143 and 638000 in Safari 18; exact numbers may vary - see [the fiddle](https://jsfiddle.net/qw1jabsx/4/). Use the loop approach for reliability.\n",
        "skills/react-best-practices/rules/js-set-map-lookups.md": "---\ntitle: Use Set/Map for O(1) Lookups\nimpact: LOW-MEDIUM\nimpactDescription: O(n) to O(1)\ntags: javascript, set, map, data-structures, performance\n---\n\n## Use Set/Map for O(1) Lookups\n\nConvert arrays to Set/Map for repeated membership checks.\n\n**Incorrect (O(n) per check):**\n\n```typescript\nconst allowedIds = ['a', 'b', 'c', ...]\nitems.filter(item => allowedIds.includes(item.id))\n```\n\n**Correct (O(1) per check):**\n\n```typescript\nconst allowedIds = new Set(['a', 'b', 'c', ...])\nitems.filter(item => allowedIds.has(item.id))\n```\n",
        "skills/react-best-practices/rules/js-tosorted-immutable.md": "---\ntitle: Use toSorted() Instead of sort() for Immutability\nimpact: MEDIUM-HIGH\nimpactDescription: prevents mutation bugs in React state\ntags: javascript, arrays, immutability, react, state, mutation\n---\n\n## Use toSorted() Instead of sort() for Immutability\n\n`.sort()` mutates the array in place, which can cause bugs with React state and props. Use `.toSorted()` to create a new sorted array without mutation.\n\n**Incorrect (mutates original array):**\n\n```typescript\nfunction UserList({ users }: { users: User[] }) {\n  // Mutates the users prop array!\n  const sorted = useMemo(\n    () => users.sort((a, b) => a.name.localeCompare(b.name)),\n    [users]\n  )\n  return <div>{sorted.map(renderUser)}</div>\n}\n```\n\n**Correct (creates new array):**\n\n```typescript\nfunction UserList({ users }: { users: User[] }) {\n  // Creates new sorted array, original unchanged\n  const sorted = useMemo(\n    () => users.toSorted((a, b) => a.name.localeCompare(b.name)),\n    [users]\n  )\n  return <div>{sorted.map(renderUser)}</div>\n}\n```\n\n**Why this matters in React:**\n\n1. Props/state mutations break React's immutability model - React expects props and state to be treated as read-only\n2. Causes stale closure bugs - Mutating arrays inside closures (callbacks, effects) can lead to unexpected behavior\n\n**Browser support (fallback for older browsers):**\n\n`.toSorted()` is available in all modern browsers (Chrome 110+, Safari 16+, Firefox 115+, Node.js 20+). For older environments, use spread operator:\n\n```typescript\n// Fallback for older browsers\nconst sorted = [...items].sort((a, b) => a.value - b.value)\n```\n\n**Other immutable array methods:**\n\n- `.toSorted()` - immutable sort\n- `.toReversed()` - immutable reverse\n- `.toSpliced()` - immutable splice\n- `.with()` - immutable element replacement\n",
        "skills/react-best-practices/rules/rendering-activity.md": "---\ntitle: Use Activity Component for Show/Hide\nimpact: MEDIUM\nimpactDescription: preserves state/DOM\ntags: rendering, activity, visibility, state-preservation\n---\n\n## Use Activity Component for Show/Hide\n\nUse React's `<Activity>` to preserve state/DOM for expensive components that frequently toggle visibility.\n\n**Usage:**\n\n```tsx\nimport { Activity } from 'react'\n\nfunction Dropdown({ isOpen }: Props) {\n  return (\n    <Activity mode={isOpen ? 'visible' : 'hidden'}>\n      <ExpensiveMenu />\n    </Activity>\n  )\n}\n```\n\nAvoids expensive re-renders and state loss.\n",
        "skills/react-best-practices/rules/rendering-animate-svg-wrapper.md": "---\ntitle: Animate SVG Wrapper Instead of SVG Element\nimpact: LOW\nimpactDescription: enables hardware acceleration\ntags: rendering, svg, css, animation, performance\n---\n\n## Animate SVG Wrapper Instead of SVG Element\n\nMany browsers don't have hardware acceleration for CSS3 animations on SVG elements. Wrap SVG in a `<div>` and animate the wrapper instead.\n\n**Incorrect (animating SVG directly - no hardware acceleration):**\n\n```tsx\nfunction LoadingSpinner() {\n  return (\n    <svg \n      className=\"animate-spin\"\n      width=\"24\" \n      height=\"24\" \n      viewBox=\"0 0 24 24\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" />\n    </svg>\n  )\n}\n```\n\n**Correct (animating wrapper div - hardware accelerated):**\n\n```tsx\nfunction LoadingSpinner() {\n  return (\n    <div className=\"animate-spin\">\n      <svg \n        width=\"24\" \n        height=\"24\" \n        viewBox=\"0 0 24 24\"\n      >\n        <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" />\n      </svg>\n    </div>\n  )\n}\n```\n\nThis applies to all CSS transforms and transitions (`transform`, `opacity`, `translate`, `scale`, `rotate`). The wrapper div allows browsers to use GPU acceleration for smoother animations.\n",
        "skills/react-best-practices/rules/rendering-conditional-render.md": "---\ntitle: Use Explicit Conditional Rendering\nimpact: LOW\nimpactDescription: prevents rendering 0 or NaN\ntags: rendering, conditional, jsx, falsy-values\n---\n\n## Use Explicit Conditional Rendering\n\nUse explicit ternary operators (`? :`) instead of `&&` for conditional rendering when the condition can be `0`, `NaN`, or other falsy values that render.\n\n**Incorrect (renders \"0\" when count is 0):**\n\n```tsx\nfunction Badge({ count }: { count: number }) {\n  return (\n    <div>\n      {count && <span className=\"badge\">{count}</span>}\n    </div>\n  )\n}\n\n// When count = 0, renders: <div>0</div>\n// When count = 5, renders: <div><span class=\"badge\">5</span></div>\n```\n\n**Correct (renders nothing when count is 0):**\n\n```tsx\nfunction Badge({ count }: { count: number }) {\n  return (\n    <div>\n      {count > 0 ? <span className=\"badge\">{count}</span> : null}\n    </div>\n  )\n}\n\n// When count = 0, renders: <div></div>\n// When count = 5, renders: <div><span class=\"badge\">5</span></div>\n```\n",
        "skills/react-best-practices/rules/rendering-content-visibility.md": "---\ntitle: CSS content-visibility for Long Lists\nimpact: HIGH\nimpactDescription: faster initial render\ntags: rendering, css, content-visibility, long-lists\n---\n\n## CSS content-visibility for Long Lists\n\nApply `content-visibility: auto` to defer off-screen rendering.\n\n**CSS:**\n\n```css\n.message-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 0 80px;\n}\n```\n\n**Example:**\n\n```tsx\nfunction MessageList({ messages }: { messages: Message[] }) {\n  return (\n    <div className=\"overflow-y-auto h-screen\">\n      {messages.map(msg => (\n        <div key={msg.id} className=\"message-item\">\n          <Avatar user={msg.author} />\n          <div>{msg.content}</div>\n        </div>\n      ))}\n    </div>\n  )\n}\n```\n\nFor 1000 messages, browser skips layout/paint for ~990 off-screen items (10× faster initial render).\n",
        "skills/react-best-practices/rules/rendering-hoist-jsx.md": "---\ntitle: Hoist Static JSX Elements\nimpact: LOW\nimpactDescription: avoids re-creation\ntags: rendering, jsx, static, optimization\n---\n\n## Hoist Static JSX Elements\n\nExtract static JSX outside components to avoid re-creation.\n\n**Incorrect (recreates element every render):**\n\n```tsx\nfunction LoadingSkeleton() {\n  return <div className=\"animate-pulse h-20 bg-gray-200\" />\n}\n\nfunction Container() {\n  return (\n    <div>\n      {loading && <LoadingSkeleton />}\n    </div>\n  )\n}\n```\n\n**Correct (reuses same element):**\n\n```tsx\nconst loadingSkeleton = (\n  <div className=\"animate-pulse h-20 bg-gray-200\" />\n)\n\nfunction Container() {\n  return (\n    <div>\n      {loading && loadingSkeleton}\n    </div>\n  )\n}\n```\n\nThis is especially helpful for large and static SVG nodes, which can be expensive to recreate on every render.\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler automatically hoists static JSX elements and optimizes component re-renders, making manual hoisting unnecessary.\n",
        "skills/react-best-practices/rules/rendering-hydration-no-flicker.md": "---\ntitle: Prevent Hydration Mismatch Without Flickering\nimpact: MEDIUM\nimpactDescription: avoids visual flicker and hydration errors\ntags: rendering, ssr, hydration, localStorage, flicker\n---\n\n## Prevent Hydration Mismatch Without Flickering\n\nWhen rendering content that depends on client-side storage (localStorage, cookies), avoid both SSR breakage and post-hydration flickering by injecting a synchronous script that updates the DOM before React hydrates.\n\n**Incorrect (breaks SSR):**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  // localStorage is not available on server - throws error\n  const theme = localStorage.getItem('theme') || 'light'\n  \n  return (\n    <div className={theme}>\n      {children}\n    </div>\n  )\n}\n```\n\nServer-side rendering will fail because `localStorage` is undefined.\n\n**Incorrect (visual flickering):**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  const [theme, setTheme] = useState('light')\n  \n  useEffect(() => {\n    // Runs after hydration - causes visible flash\n    const stored = localStorage.getItem('theme')\n    if (stored) {\n      setTheme(stored)\n    }\n  }, [])\n  \n  return (\n    <div className={theme}>\n      {children}\n    </div>\n  )\n}\n```\n\nComponent first renders with default value (`light`), then updates after hydration, causing a visible flash of incorrect content.\n\n**Correct (no flicker, no hydration mismatch):**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  return (\n    <>\n      <div id=\"theme-wrapper\">\n        {children}\n      </div>\n      <script\n        dangerouslySetInnerHTML={{\n          __html: `\n            (function() {\n              try {\n                var theme = localStorage.getItem('theme') || 'light';\n                var el = document.getElementById('theme-wrapper');\n                if (el) el.className = theme;\n              } catch (e) {}\n            })();\n          `,\n        }}\n      />\n    </>\n  )\n}\n```\n\nThe inline script executes synchronously before showing the element, ensuring the DOM already has the correct value. No flickering, no hydration mismatch.\n\nThis pattern is especially useful for theme toggles, user preferences, authentication states, and any client-only data that should render immediately without flashing default values.\n",
        "skills/react-best-practices/rules/rendering-hydration-suppress-warning.md": "---\ntitle: Suppress Expected Hydration Mismatches\nimpact: LOW-MEDIUM\nimpactDescription: avoids noisy hydration warnings for known differences\ntags: rendering, hydration, ssr, nextjs\n---\n\n## Suppress Expected Hydration Mismatches\n\nIn SSR frameworks (e.g., Next.js), some values are intentionally different on server vs client (random IDs, dates, locale/timezone formatting). For these *expected* mismatches, wrap the dynamic text in an element with `suppressHydrationWarning` to prevent noisy warnings. Do not use this to hide real bugs. Don’t overuse it.\n\n**Incorrect (known mismatch warnings):**\n\n```tsx\nfunction Timestamp() {\n  return <span>{new Date().toLocaleString()}</span>\n}\n```\n\n**Correct (suppress expected mismatch only):**\n\n```tsx\nfunction Timestamp() {\n  return (\n    <span suppressHydrationWarning>\n      {new Date().toLocaleString()}\n    </span>\n  )\n}\n```\n",
        "skills/react-best-practices/rules/rendering-svg-precision.md": "---\ntitle: Optimize SVG Precision\nimpact: LOW\nimpactDescription: reduces file size\ntags: rendering, svg, optimization, svgo\n---\n\n## Optimize SVG Precision\n\nReduce SVG coordinate precision to decrease file size. The optimal precision depends on the viewBox size, but in general reducing precision should be considered.\n\n**Incorrect (excessive precision):**\n\n```svg\n<path d=\"M 10.293847 20.847362 L 30.938472 40.192837\" />\n```\n\n**Correct (1 decimal place):**\n\n```svg\n<path d=\"M 10.3 20.8 L 30.9 40.2\" />\n```\n\n**Automate with SVGO:**\n\n```bash\nnpx svgo --precision=1 --multipass icon.svg\n```\n",
        "skills/react-best-practices/rules/rendering-usetransition-loading.md": "---\ntitle: Use useTransition Over Manual Loading States\nimpact: LOW\nimpactDescription: reduces re-renders and improves code clarity\ntags: rendering, transitions, useTransition, loading, state\n---\n\n## Use useTransition Over Manual Loading States\n\nUse `useTransition` instead of manual `useState` for loading states. This provides built-in `isPending` state and automatically manages transitions.\n\n**Incorrect (manual loading state):**\n\n```tsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('')\n  const [results, setResults] = useState([])\n  const [isLoading, setIsLoading] = useState(false)\n\n  const handleSearch = async (value: string) => {\n    setIsLoading(true)\n    setQuery(value)\n    const data = await fetchResults(value)\n    setResults(data)\n    setIsLoading(false)\n  }\n\n  return (\n    <>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {isLoading && <Spinner />}\n      <ResultsList results={results} />\n    </>\n  )\n}\n```\n\n**Correct (useTransition with built-in pending state):**\n\n```tsx\nimport { useTransition, useState } from 'react'\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('')\n  const [results, setResults] = useState([])\n  const [isPending, startTransition] = useTransition()\n\n  const handleSearch = (value: string) => {\n    setQuery(value) // Update input immediately\n    \n    startTransition(async () => {\n      // Fetch and update results\n      const data = await fetchResults(value)\n      setResults(data)\n    })\n  }\n\n  return (\n    <>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {isPending && <Spinner />}\n      <ResultsList results={results} />\n    </>\n  )\n}\n```\n\n**Benefits:**\n\n- **Automatic pending state**: No need to manually manage `setIsLoading(true/false)`\n- **Error resilience**: Pending state correctly resets even if the transition throws\n- **Better responsiveness**: Keeps the UI responsive during updates\n- **Interrupt handling**: New transitions automatically cancel pending ones\n\nReference: [useTransition](https://react.dev/reference/react/useTransition)\n",
        "skills/react-best-practices/rules/rerender-defer-reads.md": "---\ntitle: Defer State Reads to Usage Point\nimpact: MEDIUM\nimpactDescription: avoids unnecessary subscriptions\ntags: rerender, searchParams, localStorage, optimization\n---\n\n## Defer State Reads to Usage Point\n\nDon't subscribe to dynamic state (searchParams, localStorage) if you only read it inside callbacks.\n\n**Incorrect (subscribes to all searchParams changes):**\n\n```tsx\nfunction ShareButton({ chatId }: { chatId: string }) {\n  const searchParams = useSearchParams()\n\n  const handleShare = () => {\n    const ref = searchParams.get('ref')\n    shareChat(chatId, { ref })\n  }\n\n  return <button onClick={handleShare}>Share</button>\n}\n```\n\n**Correct (reads on demand, no subscription):**\n\n```tsx\nfunction ShareButton({ chatId }: { chatId: string }) {\n  const handleShare = () => {\n    const params = new URLSearchParams(window.location.search)\n    const ref = params.get('ref')\n    shareChat(chatId, { ref })\n  }\n\n  return <button onClick={handleShare}>Share</button>\n}\n```\n",
        "skills/react-best-practices/rules/rerender-dependencies.md": "---\ntitle: Narrow Effect Dependencies\nimpact: LOW\nimpactDescription: minimizes effect re-runs\ntags: rerender, useEffect, dependencies, optimization\n---\n\n## Narrow Effect Dependencies\n\nSpecify primitive dependencies instead of objects to minimize effect re-runs.\n\n**Incorrect (re-runs on any user field change):**\n\n```tsx\nuseEffect(() => {\n  console.log(user.id)\n}, [user])\n```\n\n**Correct (re-runs only when id changes):**\n\n```tsx\nuseEffect(() => {\n  console.log(user.id)\n}, [user.id])\n```\n\n**For derived state, compute outside effect:**\n\n```tsx\n// Incorrect: runs on width=767, 766, 765...\nuseEffect(() => {\n  if (width < 768) {\n    enableMobileMode()\n  }\n}, [width])\n\n// Correct: runs only on boolean transition\nconst isMobile = width < 768\nuseEffect(() => {\n  if (isMobile) {\n    enableMobileMode()\n  }\n}, [isMobile])\n```\n",
        "skills/react-best-practices/rules/rerender-derived-state-no-effect.md": "---\ntitle: Calculate Derived State During Rendering\nimpact: MEDIUM\nimpactDescription: avoids redundant renders and state drift\ntags: rerender, derived-state, useEffect, state\n---\n\n## Calculate Derived State During Rendering\n\nIf a value can be computed from current props/state, do not store it in state or update it in an effect. Derive it during render to avoid extra renders and state drift. Do not set state in effects solely in response to prop changes; prefer derived values or keyed resets instead.\n\n**Incorrect (redundant state and effect):**\n\n```tsx\nfunction Form() {\n  const [firstName, setFirstName] = useState('First')\n  const [lastName, setLastName] = useState('Last')\n  const [fullName, setFullName] = useState('')\n\n  useEffect(() => {\n    setFullName(firstName + ' ' + lastName)\n  }, [firstName, lastName])\n\n  return <p>{fullName}</p>\n}\n```\n\n**Correct (derive during render):**\n\n```tsx\nfunction Form() {\n  const [firstName, setFirstName] = useState('First')\n  const [lastName, setLastName] = useState('Last')\n  const fullName = firstName + ' ' + lastName\n\n  return <p>{fullName}</p>\n}\n```\n\nReferences: [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)\n",
        "skills/react-best-practices/rules/rerender-derived-state.md": "---\ntitle: Subscribe to Derived State\nimpact: MEDIUM\nimpactDescription: reduces re-render frequency\ntags: rerender, derived-state, media-query, optimization\n---\n\n## Subscribe to Derived State\n\nSubscribe to derived boolean state instead of continuous values to reduce re-render frequency.\n\n**Incorrect (re-renders on every pixel change):**\n\n```tsx\nfunction Sidebar() {\n  const width = useWindowWidth()  // updates continuously\n  const isMobile = width < 768\n  return <nav className={isMobile ? 'mobile' : 'desktop'} />\n}\n```\n\n**Correct (re-renders only when boolean changes):**\n\n```tsx\nfunction Sidebar() {\n  const isMobile = useMediaQuery('(max-width: 767px)')\n  return <nav className={isMobile ? 'mobile' : 'desktop'} />\n}\n```\n",
        "skills/react-best-practices/rules/rerender-functional-setstate.md": "---\ntitle: Use Functional setState Updates\nimpact: MEDIUM\nimpactDescription: prevents stale closures and unnecessary callback recreations\ntags: react, hooks, useState, useCallback, callbacks, closures\n---\n\n## Use Functional setState Updates\n\nWhen updating state based on the current state value, use the functional update form of setState instead of directly referencing the state variable. This prevents stale closures, eliminates unnecessary dependencies, and creates stable callback references.\n\n**Incorrect (requires state as dependency):**\n\n```tsx\nfunction TodoList() {\n  const [items, setItems] = useState(initialItems)\n  \n  // Callback must depend on items, recreated on every items change\n  const addItems = useCallback((newItems: Item[]) => {\n    setItems([...items, ...newItems])\n  }, [items])  // ❌ items dependency causes recreations\n  \n  // Risk of stale closure if dependency is forgotten\n  const removeItem = useCallback((id: string) => {\n    setItems(items.filter(item => item.id !== id))\n  }, [])  // ❌ Missing items dependency - will use stale items!\n  \n  return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />\n}\n```\n\nThe first callback is recreated every time `items` changes, which can cause child components to re-render unnecessarily. The second callback has a stale closure bug—it will always reference the initial `items` value.\n\n**Correct (stable callbacks, no stale closures):**\n\n```tsx\nfunction TodoList() {\n  const [items, setItems] = useState(initialItems)\n  \n  // Stable callback, never recreated\n  const addItems = useCallback((newItems: Item[]) => {\n    setItems(curr => [...curr, ...newItems])\n  }, [])  // ✅ No dependencies needed\n  \n  // Always uses latest state, no stale closure risk\n  const removeItem = useCallback((id: string) => {\n    setItems(curr => curr.filter(item => item.id !== id))\n  }, [])  // ✅ Safe and stable\n  \n  return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />\n}\n```\n\n**Benefits:**\n\n1. **Stable callback references** - Callbacks don't need to be recreated when state changes\n2. **No stale closures** - Always operates on the latest state value\n3. **Fewer dependencies** - Simplifies dependency arrays and reduces memory leaks\n4. **Prevents bugs** - Eliminates the most common source of React closure bugs\n\n**When to use functional updates:**\n\n- Any setState that depends on the current state value\n- Inside useCallback/useMemo when state is needed\n- Event handlers that reference state\n- Async operations that update state\n\n**When direct updates are fine:**\n\n- Setting state to a static value: `setCount(0)`\n- Setting state from props/arguments only: `setName(newName)`\n- State doesn't depend on previous value\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler can automatically optimize some cases, but functional updates are still recommended for correctness and to prevent stale closure bugs.\n",
        "skills/react-best-practices/rules/rerender-lazy-state-init.md": "---\ntitle: Use Lazy State Initialization\nimpact: MEDIUM\nimpactDescription: wasted computation on every render\ntags: react, hooks, useState, performance, initialization\n---\n\n## Use Lazy State Initialization\n\nPass a function to `useState` for expensive initial values. Without the function form, the initializer runs on every render even though the value is only used once.\n\n**Incorrect (runs on every render):**\n\n```tsx\nfunction FilteredList({ items }: { items: Item[] }) {\n  // buildSearchIndex() runs on EVERY render, even after initialization\n  const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))\n  const [query, setQuery] = useState('')\n  \n  // When query changes, buildSearchIndex runs again unnecessarily\n  return <SearchResults index={searchIndex} query={query} />\n}\n\nfunction UserProfile() {\n  // JSON.parse runs on every render\n  const [settings, setSettings] = useState(\n    JSON.parse(localStorage.getItem('settings') || '{}')\n  )\n  \n  return <SettingsForm settings={settings} onChange={setSettings} />\n}\n```\n\n**Correct (runs only once):**\n\n```tsx\nfunction FilteredList({ items }: { items: Item[] }) {\n  // buildSearchIndex() runs ONLY on initial render\n  const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))\n  const [query, setQuery] = useState('')\n  \n  return <SearchResults index={searchIndex} query={query} />\n}\n\nfunction UserProfile() {\n  // JSON.parse runs only on initial render\n  const [settings, setSettings] = useState(() => {\n    const stored = localStorage.getItem('settings')\n    return stored ? JSON.parse(stored) : {}\n  })\n  \n  return <SettingsForm settings={settings} onChange={setSettings} />\n}\n```\n\nUse lazy initialization when computing initial values from localStorage/sessionStorage, building data structures (indexes, maps), reading from the DOM, or performing heavy transformations.\n\nFor simple primitives (`useState(0)`), direct references (`useState(props.value)`), or cheap literals (`useState({})`), the function form is unnecessary.\n",
        "skills/react-best-practices/rules/rerender-memo-with-default-value.md": "---\n\ntitle: Extract Default Non-primitive Parameter Value from Memoized Component to Constant\nimpact: MEDIUM\nimpactDescription: restores memoization by using a constant for default value\ntags: rerender, memo, optimization\n\n---\n\n## Extract Default Non-primitive Parameter Value from Memoized Component to Constant\n\nWhen memoized component has a default value for some non-primitive optional parameter, such as an array, function, or object, calling the component without that parameter results in broken memoization. This is because new value instances are created on every rerender, and they do not pass strict equality comparison in `memo()`.\n\nTo address this issue, extract the default value into a constant.\n\n**Incorrect (`onClick` has different values on every rerender):**\n\n```tsx\nconst UserAvatar = memo(function UserAvatar({ onClick = () => {} }: { onClick?: () => void }) {\n  // ...\n})\n\n// Used without optional onClick\n<UserAvatar />\n```\n\n**Correct (stable default value):**\n\n```tsx\nconst NOOP = () => {};\n\nconst UserAvatar = memo(function UserAvatar({ onClick = NOOP }: { onClick?: () => void }) {\n  // ...\n})\n\n// Used without optional onClick\n<UserAvatar />\n```\n",
        "skills/react-best-practices/rules/rerender-memo.md": "---\ntitle: Extract to Memoized Components\nimpact: MEDIUM\nimpactDescription: enables early returns\ntags: rerender, memo, useMemo, optimization\n---\n\n## Extract to Memoized Components\n\nExtract expensive work into memoized components to enable early returns before computation.\n\n**Incorrect (computes avatar even when loading):**\n\n```tsx\nfunction Profile({ user, loading }: Props) {\n  const avatar = useMemo(() => {\n    const id = computeAvatarId(user)\n    return <Avatar id={id} />\n  }, [user])\n\n  if (loading) return <Skeleton />\n  return <div>{avatar}</div>\n}\n```\n\n**Correct (skips computation when loading):**\n\n```tsx\nconst UserAvatar = memo(function UserAvatar({ user }: { user: User }) {\n  const id = useMemo(() => computeAvatarId(user), [user])\n  return <Avatar id={id} />\n})\n\nfunction Profile({ user, loading }: Props) {\n  if (loading) return <Skeleton />\n  return (\n    <div>\n      <UserAvatar user={user} />\n    </div>\n  )\n}\n```\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, manual memoization with `memo()` and `useMemo()` is not necessary. The compiler automatically optimizes re-renders.\n",
        "skills/react-best-practices/rules/rerender-move-effect-to-event.md": "---\ntitle: Put Interaction Logic in Event Handlers\nimpact: MEDIUM\nimpactDescription: avoids effect re-runs and duplicate side effects\ntags: rerender, useEffect, events, side-effects, dependencies\n---\n\n## Put Interaction Logic in Event Handlers\n\nIf a side effect is triggered by a specific user action (submit, click, drag), run it in that event handler. Do not model the action as state + effect; it makes effects re-run on unrelated changes and can duplicate the action.\n\n**Incorrect (event modeled as state + effect):**\n\n```tsx\nfunction Form() {\n  const [submitted, setSubmitted] = useState(false)\n  const theme = useContext(ThemeContext)\n\n  useEffect(() => {\n    if (submitted) {\n      post('/api/register')\n      showToast('Registered', theme)\n    }\n  }, [submitted, theme])\n\n  return <button onClick={() => setSubmitted(true)}>Submit</button>\n}\n```\n\n**Correct (do it in the handler):**\n\n```tsx\nfunction Form() {\n  const theme = useContext(ThemeContext)\n\n  function handleSubmit() {\n    post('/api/register')\n    showToast('Registered', theme)\n  }\n\n  return <button onClick={handleSubmit}>Submit</button>\n}\n```\n\nReference: [Should this code move to an event handler?](https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler)\n",
        "skills/react-best-practices/rules/rerender-simple-expression-in-memo.md": "---\ntitle: Do not wrap a simple expression with a primitive result type in useMemo\nimpact: LOW-MEDIUM\nimpactDescription: wasted computation on every render\ntags: rerender, useMemo, optimization\n---\n\n## Do not wrap a simple expression with a primitive result type in useMemo\n\nWhen an expression is simple (few logical or arithmetical operators) and has a primitive result type (boolean, number, string), do not wrap it in `useMemo`.\nCalling `useMemo` and comparing hook dependencies may consume more resources than the expression itself.\n\n**Incorrect:**\n\n```tsx\nfunction Header({ user, notifications }: Props) {\n  const isLoading = useMemo(() => {\n    return user.isLoading || notifications.isLoading\n  }, [user.isLoading, notifications.isLoading])\n\n  if (isLoading) return <Skeleton />\n  // return some markup\n}\n```\n\n**Correct:**\n\n```tsx\nfunction Header({ user, notifications }: Props) {\n  const isLoading = user.isLoading || notifications.isLoading\n\n  if (isLoading) return <Skeleton />\n  // return some markup\n}\n```\n",
        "skills/react-best-practices/rules/rerender-transitions.md": "---\ntitle: Use Transitions for Non-Urgent Updates\nimpact: MEDIUM\nimpactDescription: maintains UI responsiveness\ntags: rerender, transitions, startTransition, performance\n---\n\n## Use Transitions for Non-Urgent Updates\n\nMark frequent, non-urgent state updates as transitions to maintain UI responsiveness.\n\n**Incorrect (blocks UI on every scroll):**\n\n```tsx\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0)\n  useEffect(() => {\n    const handler = () => setScrollY(window.scrollY)\n    window.addEventListener('scroll', handler, { passive: true })\n    return () => window.removeEventListener('scroll', handler)\n  }, [])\n}\n```\n\n**Correct (non-blocking updates):**\n\n```tsx\nimport { startTransition } from 'react'\n\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0)\n  useEffect(() => {\n    const handler = () => {\n      startTransition(() => setScrollY(window.scrollY))\n    }\n    window.addEventListener('scroll', handler, { passive: true })\n    return () => window.removeEventListener('scroll', handler)\n  }, [])\n}\n```\n",
        "skills/react-best-practices/rules/rerender-use-ref-transient-values.md": "---\ntitle: Use useRef for Transient Values\nimpact: MEDIUM\nimpactDescription: avoids unnecessary re-renders on frequent updates\ntags: rerender, useref, state, performance\n---\n\n## Use useRef for Transient Values\n\nWhen a value changes frequently and you don't want a re-render on every update (e.g., mouse trackers, intervals, transient flags), store it in `useRef` instead of `useState`. Keep component state for UI; use refs for temporary DOM-adjacent values. Updating a ref does not trigger a re-render.\n\n**Incorrect (renders every update):**\n\n```tsx\nfunction Tracker() {\n  const [lastX, setLastX] = useState(0)\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => setLastX(e.clientX)\n    window.addEventListener('mousemove', onMove)\n    return () => window.removeEventListener('mousemove', onMove)\n  }, [])\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: lastX,\n        width: 8,\n        height: 8,\n        background: 'black',\n      }}\n    />\n  )\n}\n```\n\n**Correct (no re-render for tracking):**\n\n```tsx\nfunction Tracker() {\n  const lastXRef = useRef(0)\n  const dotRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => {\n      lastXRef.current = e.clientX\n      const node = dotRef.current\n      if (node) {\n        node.style.transform = `translateX(${e.clientX}px)`\n      }\n    }\n    window.addEventListener('mousemove', onMove)\n    return () => window.removeEventListener('mousemove', onMove)\n  }, [])\n\n  return (\n    <div\n      ref={dotRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: 8,\n        height: 8,\n        background: 'black',\n        transform: 'translateX(0px)',\n      }}\n    />\n  )\n}\n```\n",
        "skills/react-best-practices/rules/server-after-nonblocking.md": "---\ntitle: Use after() for Non-Blocking Operations\nimpact: MEDIUM\nimpactDescription: faster response times\ntags: server, async, logging, analytics, side-effects\n---\n\n## Use after() for Non-Blocking Operations\n\nUse Next.js's `after()` to schedule work that should execute after a response is sent. This prevents logging, analytics, and other side effects from blocking the response.\n\n**Incorrect (blocks response):**\n\n```tsx\nimport { logUserAction } from '@/app/utils'\n\nexport async function POST(request: Request) {\n  // Perform mutation\n  await updateDatabase(request)\n  \n  // Logging blocks the response\n  const userAgent = request.headers.get('user-agent') || 'unknown'\n  await logUserAction({ userAgent })\n  \n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' }\n  })\n}\n```\n\n**Correct (non-blocking):**\n\n```tsx\nimport { after } from 'next/server'\nimport { headers, cookies } from 'next/headers'\nimport { logUserAction } from '@/app/utils'\n\nexport async function POST(request: Request) {\n  // Perform mutation\n  await updateDatabase(request)\n  \n  // Log after response is sent\n  after(async () => {\n    const userAgent = (await headers()).get('user-agent') || 'unknown'\n    const sessionCookie = (await cookies()).get('session-id')?.value || 'anonymous'\n    \n    logUserAction({ sessionCookie, userAgent })\n  })\n  \n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' }\n  })\n}\n```\n\nThe response is sent immediately while logging happens in the background.\n\n**Common use cases:**\n\n- Analytics tracking\n- Audit logging\n- Sending notifications\n- Cache invalidation\n- Cleanup tasks\n\n**Important notes:**\n\n- `after()` runs even if the response fails or redirects\n- Works in Server Actions, Route Handlers, and Server Components\n\nReference: [https://nextjs.org/docs/app/api-reference/functions/after](https://nextjs.org/docs/app/api-reference/functions/after)\n",
        "skills/react-best-practices/rules/server-auth-actions.md": "---\ntitle: Authenticate Server Actions Like API Routes\nimpact: CRITICAL\nimpactDescription: prevents unauthorized access to server mutations\ntags: server, server-actions, authentication, security, authorization\n---\n\n## Authenticate Server Actions Like API Routes\n\n**Impact: CRITICAL (prevents unauthorized access to server mutations)**\n\nServer Actions (functions with `\"use server\"`) are exposed as public endpoints, just like API routes. Always verify authentication and authorization **inside** each Server Action—do not rely solely on middleware, layout guards, or page-level checks, as Server Actions can be invoked directly.\n\nNext.js documentation explicitly states: \"Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.\"\n\n**Incorrect (no authentication check):**\n\n```typescript\n'use server'\n\nexport async function deleteUser(userId: string) {\n  // Anyone can call this! No auth check\n  await db.user.delete({ where: { id: userId } })\n  return { success: true }\n}\n```\n\n**Correct (authentication inside the action):**\n\n```typescript\n'use server'\n\nimport { verifySession } from '@/lib/auth'\nimport { unauthorized } from '@/lib/errors'\n\nexport async function deleteUser(userId: string) {\n  // Always check auth inside the action\n  const session = await verifySession()\n  \n  if (!session) {\n    throw unauthorized('Must be logged in')\n  }\n  \n  // Check authorization too\n  if (session.user.role !== 'admin' && session.user.id !== userId) {\n    throw unauthorized('Cannot delete other users')\n  }\n  \n  await db.user.delete({ where: { id: userId } })\n  return { success: true }\n}\n```\n\n**With input validation:**\n\n```typescript\n'use server'\n\nimport { verifySession } from '@/lib/auth'\nimport { z } from 'zod'\n\nconst updateProfileSchema = z.object({\n  userId: z.string().uuid(),\n  name: z.string().min(1).max(100),\n  email: z.string().email()\n})\n\nexport async function updateProfile(data: unknown) {\n  // Validate input first\n  const validated = updateProfileSchema.parse(data)\n  \n  // Then authenticate\n  const session = await verifySession()\n  if (!session) {\n    throw new Error('Unauthorized')\n  }\n  \n  // Then authorize\n  if (session.user.id !== validated.userId) {\n    throw new Error('Can only update own profile')\n  }\n  \n  // Finally perform the mutation\n  await db.user.update({\n    where: { id: validated.userId },\n    data: {\n      name: validated.name,\n      email: validated.email\n    }\n  })\n  \n  return { success: true }\n}\n```\n\nReference: [https://nextjs.org/docs/app/guides/authentication](https://nextjs.org/docs/app/guides/authentication)\n",
        "skills/react-best-practices/rules/server-cache-lru.md": "---\ntitle: Cross-Request LRU Caching\nimpact: HIGH\nimpactDescription: caches across requests\ntags: server, cache, lru, cross-request\n---\n\n## Cross-Request LRU Caching\n\n`React.cache()` only works within one request. For data shared across sequential requests (user clicks button A then button B), use an LRU cache.\n\n**Implementation:**\n\n```typescript\nimport { LRUCache } from 'lru-cache'\n\nconst cache = new LRUCache<string, any>({\n  max: 1000,\n  ttl: 5 * 60 * 1000  // 5 minutes\n})\n\nexport async function getUser(id: string) {\n  const cached = cache.get(id)\n  if (cached) return cached\n\n  const user = await db.user.findUnique({ where: { id } })\n  cache.set(id, user)\n  return user\n}\n\n// Request 1: DB query, result cached\n// Request 2: cache hit, no DB query\n```\n\nUse when sequential user actions hit multiple endpoints needing the same data within seconds.\n\n**With Vercel's [Fluid Compute](https://vercel.com/docs/fluid-compute):** LRU caching is especially effective because multiple concurrent requests can share the same function instance and cache. This means the cache persists across requests without needing external storage like Redis.\n\n**In traditional serverless:** Each invocation runs in isolation, so consider Redis for cross-process caching.\n\nReference: [https://github.com/isaacs/node-lru-cache](https://github.com/isaacs/node-lru-cache)\n",
        "skills/react-best-practices/rules/server-cache-react.md": "---\ntitle: Per-Request Deduplication with React.cache()\nimpact: MEDIUM\nimpactDescription: deduplicates within request\ntags: server, cache, react-cache, deduplication\n---\n\n## Per-Request Deduplication with React.cache()\n\nUse `React.cache()` for server-side request deduplication. Authentication and database queries benefit most.\n\n**Usage:**\n\n```typescript\nimport { cache } from 'react'\n\nexport const getCurrentUser = cache(async () => {\n  const session = await auth()\n  if (!session?.user?.id) return null\n  return await db.user.findUnique({\n    where: { id: session.user.id }\n  })\n})\n```\n\nWithin a single request, multiple calls to `getCurrentUser()` execute the query only once.\n\n**Avoid inline objects as arguments:**\n\n`React.cache()` uses shallow equality (`Object.is`) to determine cache hits. Inline objects create new references each call, preventing cache hits.\n\n**Incorrect (always cache miss):**\n\n```typescript\nconst getUser = cache(async (params: { uid: number }) => {\n  return await db.user.findUnique({ where: { id: params.uid } })\n})\n\n// Each call creates new object, never hits cache\ngetUser({ uid: 1 })\ngetUser({ uid: 1 })  // Cache miss, runs query again\n```\n\n**Correct (cache hit):**\n\n```typescript\nconst getUser = cache(async (uid: number) => {\n  return await db.user.findUnique({ where: { id: uid } })\n})\n\n// Primitive args use value equality\ngetUser(1)\ngetUser(1)  // Cache hit, returns cached result\n```\n\nIf you must pass objects, pass the same reference:\n\n```typescript\nconst params = { uid: 1 }\ngetUser(params)  // Query runs\ngetUser(params)  // Cache hit (same reference)\n```\n\n**Next.js-Specific Note:**\n\nIn Next.js, the `fetch` API is automatically extended with request memoization. Requests with the same URL and options are automatically deduplicated within a single request, so you don't need `React.cache()` for `fetch` calls. However, `React.cache()` is still essential for other async tasks:\n\n- Database queries (Prisma, Drizzle, etc.)\n- Heavy computations\n- Authentication checks\n- File system operations\n- Any non-fetch async work\n\nUse `React.cache()` to deduplicate these operations across your component tree.\n\nReference: [React.cache documentation](https://react.dev/reference/react/cache)\n",
        "skills/react-best-practices/rules/server-dedup-props.md": "---\ntitle: Avoid Duplicate Serialization in RSC Props\nimpact: LOW\nimpactDescription: reduces network payload by avoiding duplicate serialization\ntags: server, rsc, serialization, props, client-components\n---\n\n## Avoid Duplicate Serialization in RSC Props\n\n**Impact: LOW (reduces network payload by avoiding duplicate serialization)**\n\nRSC→client serialization deduplicates by object reference, not value. Same reference = serialized once; new reference = serialized again. Do transformations (`.toSorted()`, `.filter()`, `.map()`) in client, not server.\n\n**Incorrect (duplicates array):**\n\n```tsx\n// RSC: sends 6 strings (2 arrays × 3 items)\n<ClientList usernames={usernames} usernamesOrdered={usernames.toSorted()} />\n```\n\n**Correct (sends 3 strings):**\n\n```tsx\n// RSC: send once\n<ClientList usernames={usernames} />\n\n// Client: transform there\n'use client'\nconst sorted = useMemo(() => [...usernames].sort(), [usernames])\n```\n\n**Nested deduplication behavior:**\n\nDeduplication works recursively. Impact varies by data type:\n\n- `string[]`, `number[]`, `boolean[]`: **HIGH impact** - array + all primitives fully duplicated\n- `object[]`: **LOW impact** - array duplicated, but nested objects deduplicated by reference\n\n```tsx\n// string[] - duplicates everything\nusernames={['a','b']} sorted={usernames.toSorted()} // sends 4 strings\n\n// object[] - duplicates array structure only\nusers={[{id:1},{id:2}]} sorted={users.toSorted()} // sends 2 arrays + 2 unique objects (not 4)\n```\n\n**Operations breaking deduplication (create new references):**\n\n- Arrays: `.toSorted()`, `.filter()`, `.map()`, `.slice()`, `[...arr]`\n- Objects: `{...obj}`, `Object.assign()`, `structuredClone()`, `JSON.parse(JSON.stringify())`\n\n**More examples:**\n\n```tsx\n// ❌ Bad\n<C users={users} active={users.filter(u => u.active)} />\n<C product={product} productName={product.name} />\n\n// ✅ Good\n<C users={users} />\n<C product={product} />\n// Do filtering/destructuring in client\n```\n\n**Exception:** Pass derived data when transformation is expensive or client doesn't need original.\n",
        "skills/react-best-practices/rules/server-parallel-fetching.md": "---\ntitle: Parallel Data Fetching with Component Composition\nimpact: CRITICAL\nimpactDescription: eliminates server-side waterfalls\ntags: server, rsc, parallel-fetching, composition\n---\n\n## Parallel Data Fetching with Component Composition\n\nReact Server Components execute sequentially within a tree. Restructure with composition to parallelize data fetching.\n\n**Incorrect (Sidebar waits for Page's fetch to complete):**\n\n```tsx\nexport default async function Page() {\n  const header = await fetchHeader()\n  return (\n    <div>\n      <div>{header}</div>\n      <Sidebar />\n    </div>\n  )\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n```\n\n**Correct (both fetch simultaneously):**\n\n```tsx\nasync function Header() {\n  const data = await fetchHeader()\n  return <div>{data}</div>\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n\nexport default function Page() {\n  return (\n    <div>\n      <Header />\n      <Sidebar />\n    </div>\n  )\n}\n```\n\n**Alternative with children prop:**\n\n```tsx\nasync function Header() {\n  const data = await fetchHeader()\n  return <div>{data}</div>\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n\nfunction Layout({ children }: { children: ReactNode }) {\n  return (\n    <div>\n      <Header />\n      {children}\n    </div>\n  )\n}\n\nexport default function Page() {\n  return (\n    <Layout>\n      <Sidebar />\n    </Layout>\n  )\n}\n```\n",
        "skills/react-best-practices/rules/server-serialization.md": "---\ntitle: Minimize Serialization at RSC Boundaries\nimpact: HIGH\nimpactDescription: reduces data transfer size\ntags: server, rsc, serialization, props\n---\n\n## Minimize Serialization at RSC Boundaries\n\nThe React Server/Client boundary serializes all object properties into strings and embeds them in the HTML response and subsequent RSC requests. This serialized data directly impacts page weight and load time, so **size matters a lot**. Only pass fields that the client actually uses.\n\n**Incorrect (serializes all 50 fields):**\n\n```tsx\nasync function Page() {\n  const user = await fetchUser()  // 50 fields\n  return <Profile user={user} />\n}\n\n'use client'\nfunction Profile({ user }: { user: User }) {\n  return <div>{user.name}</div>  // uses 1 field\n}\n```\n\n**Correct (serializes only 1 field):**\n\n```tsx\nasync function Page() {\n  const user = await fetchUser()\n  return <Profile name={user.name} />\n}\n\n'use client'\nfunction Profile({ name }: { name: string }) {\n  return <div>{name}</div>\n}\n```\n",
        "skills/react-native/AGENTS.md": "# React Native Skills\n\n**Version 1.0.0**  \nEngineering  \nJanuary 2026\n\n> **Note:**  \n> This document is mainly for agents and LLMs to follow when maintaining,  \n> generating, or refactoring React Native codebases. Humans  \n> may also find it useful, but guidance here is optimized for automation  \n> and consistency by AI-assisted workflows.\n\n---\n\n## Abstract\n\nComprehensive performance optimization guide for React Native applications, designed for AI agents and LLMs. Contains 35+ rules across 13 categories, prioritized by impact from critical (core rendering, list performance) to incremental (fonts, imports). Each rule includes detailed explanations, real-world examples comparing incorrect vs. correct implementations, and specific impact metrics to guide automated refactoring and code generation.\n\n---\n\n## Table of Contents\n\n1. [Core Rendering](#1-core-rendering) — **CRITICAL**\n   - 1.1 [Never Use && with Potentially Falsy Values](#11-never-use--with-potentially-falsy-values)\n   - 1.2 [Wrap Strings in Text Components](#12-wrap-strings-in-text-components)\n2. [List Performance](#2-list-performance) — **HIGH**\n   - 2.1 [Avoid Inline Objects in renderItem](#21-avoid-inline-objects-in-renderitem)\n   - 2.2 [Hoist callbacks to the root of lists](#22-hoist-callbacks-to-the-root-of-lists)\n   - 2.3 [Keep List Items Lightweight](#23-keep-list-items-lightweight)\n   - 2.4 [Optimize List Performance with Stable Object References](#24-optimize-list-performance-with-stable-object-references)\n   - 2.5 [Pass Primitives to List Items for Memoization](#25-pass-primitives-to-list-items-for-memoization)\n   - 2.6 [Use a List Virtualizer for Any List](#26-use-a-list-virtualizer-for-any-list)\n   - 2.7 [Use Compressed Images in Lists](#27-use-compressed-images-in-lists)\n   - 2.8 [Use Item Types for Heterogeneous Lists](#28-use-item-types-for-heterogeneous-lists)\n3. [Animation](#3-animation) — **HIGH**\n   - 3.1 [Animate Transform and Opacity Instead of Layout Properties](#31-animate-transform-and-opacity-instead-of-layout-properties)\n   - 3.2 [Prefer useDerivedValue Over useAnimatedReaction](#32-prefer-usederivedvalue-over-useanimatedreaction)\n   - 3.3 [Use GestureDetector for Animated Press States](#33-use-gesturedetector-for-animated-press-states)\n4. [Scroll Performance](#4-scroll-performance) — **HIGH**\n   - 4.1 [Never Track Scroll Position in useState](#41-never-track-scroll-position-in-usestate)\n5. [Navigation](#5-navigation) — **HIGH**\n   - 5.1 [Use Native Navigators for Navigation](#51-use-native-navigators-for-navigation)\n6. [React State](#6-react-state) — **MEDIUM**\n   - 6.1 [Minimize State Variables and Derive Values](#61-minimize-state-variables-and-derive-values)\n   - 6.2 [Use fallback state instead of initialState](#62-use-fallback-state-instead-of-initialstate)\n   - 6.3 [useState Dispatch updaters for State That Depends on Current Value](#63-usestate-dispatch-updaters-for-state-that-depends-on-current-value)\n7. [State Architecture](#7-state-architecture) — **MEDIUM**\n   - 7.1 [State Must Represent Ground Truth](#71-state-must-represent-ground-truth)\n8. [React Compiler](#8-react-compiler) — **MEDIUM**\n   - 8.1 [Destructure Functions Early in Render (React Compiler)](#81-destructure-functions-early-in-render-react-compiler)\n   - 8.2 [Use .get() and .set() for Reanimated Shared Values (not .value)](#82-use-get-and-set-for-reanimated-shared-values-not-value)\n9. [User Interface](#9-user-interface) — **MEDIUM**\n   - 9.1 [Measuring View Dimensions](#91-measuring-view-dimensions)\n   - 9.2 [Modern React Native Styling Patterns](#92-modern-react-native-styling-patterns)\n   - 9.3 [Use contentInset for Dynamic ScrollView Spacing](#93-use-contentinset-for-dynamic-scrollview-spacing)\n   - 9.4 [Use contentInsetAdjustmentBehavior for Safe Areas](#94-use-contentinsetadjustmentbehavior-for-safe-areas)\n   - 9.5 [Use expo-image for Optimized Images](#95-use-expo-image-for-optimized-images)\n   - 9.6 [Use Galeria for Image Galleries and Lightbox](#96-use-galeria-for-image-galleries-and-lightbox)\n   - 9.7 [Use Native Menus for Dropdowns and Context Menus](#97-use-native-menus-for-dropdowns-and-context-menus)\n   - 9.8 [Use Native Modals Over JS-Based Bottom Sheets](#98-use-native-modals-over-js-based-bottom-sheets)\n   - 9.9 [Use Pressable Instead of Touchable Components](#99-use-pressable-instead-of-touchable-components)\n10. [Design System](#10-design-system) — **MEDIUM**\n   - 10.1 [Use Compound Components Over Polymorphic Children](#101-use-compound-components-over-polymorphic-children)\n11. [Monorepo](#11-monorepo) — **LOW**\n   - 11.1 [Install Native Dependencies in App Directory](#111-install-native-dependencies-in-app-directory)\n   - 11.2 [Use Single Dependency Versions Across Monorepo](#112-use-single-dependency-versions-across-monorepo)\n12. [Third-Party Dependencies](#12-third-party-dependencies) — **LOW**\n   - 12.1 [Import from Design System Folder](#121-import-from-design-system-folder)\n13. [JavaScript](#13-javascript) — **LOW**\n   - 13.1 [Hoist Intl Formatter Creation](#131-hoist-intl-formatter-creation)\n14. [Fonts](#14-fonts) — **LOW**\n   - 14.1 [Load fonts natively at build time](#141-load-fonts-natively-at-build-time)\n\n---\n\n## 1. Core Rendering\n\n**Impact: CRITICAL**\n\nFundamental React Native rendering rules. Violations cause\nruntime crashes or broken UI.\n\n### 1.1 Never Use && with Potentially Falsy Values\n\n**Impact: CRITICAL (prevents production crash)**\n\nNever use `{value && <Component />}` when `value` could be an empty string or\n\n`0`. These are falsy but JSX-renderable—React Native will try to render them as\n\ntext outside a `<Text>` component, causing a hard crash in production.\n\n**Incorrect: crashes if count is 0 or name is \"\"**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  return (\n    <View>\n      {name && <Text>{name}</Text>}\n      {count && <Text>{count} items</Text>}\n    </View>\n  )\n}\n// If name=\"\" or count=0, renders the falsy value → crash\n```\n\n**Correct: ternary with null**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  return (\n    <View>\n      {name ? <Text>{name}</Text> : null}\n      {count ? <Text>{count} items</Text> : null}\n    </View>\n  )\n}\n```\n\n**Correct: explicit boolean coercion**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  return (\n    <View>\n      {!!name && <Text>{name}</Text>}\n      {!!count && <Text>{count} items</Text>}\n    </View>\n  )\n}\n```\n\n**Best: early return**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  if (!name) return null\n\n  return (\n    <View>\n      <Text>{name}</Text>\n      {count > 0 ? <Text>{count} items</Text> : null}\n    </View>\n  )\n}\n```\n\nEarly returns are clearest. When using conditionals inline, prefer ternary or\n\nexplicit boolean checks.\n\n**Lint rule:** Enable `react/jsx-no-leaked-render` from\n\n[eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/jsx-no-leaked-render.md)\n\nto catch this automatically.\n\n### 1.2 Wrap Strings in Text Components\n\n**Impact: CRITICAL (prevents runtime crash)**\n\nStrings must be rendered inside `<Text>`. React Native crashes if a string is a\n\ndirect child of `<View>`.\n\n**Incorrect: crashes**\n\n```tsx\nimport { View } from 'react-native'\n\nfunction Greeting({ name }: { name: string }) {\n  return <View>Hello, {name}!</View>\n}\n// Error: Text strings must be rendered within a <Text> component.\n```\n\n**Correct:**\n\n```tsx\nimport { View, Text } from 'react-native'\n\nfunction Greeting({ name }: { name: string }) {\n  return (\n    <View>\n      <Text>Hello, {name}!</Text>\n    </View>\n  )\n}\n```\n\n---\n\n## 2. List Performance\n\n**Impact: HIGH**\n\nOptimizing virtualized lists (FlatList, LegendList, FlashList)\nfor smooth scrolling and fast updates.\n\n### 2.1 Avoid Inline Objects in renderItem\n\n**Impact: HIGH (prevents unnecessary re-renders of memoized list items)**\n\nDon't create new objects inside `renderItem` to pass as props. Inline objects\n\ncreate new references on every render, breaking memoization. Pass primitive\n\nvalues directly from `item` instead.\n\n**Incorrect: inline object breaks memoization**\n\n```tsx\nfunction UserList({ users }: { users: User[] }) {\n  return (\n    <LegendList\n      data={users}\n      renderItem={({ item }) => (\n        <UserRow\n          // Bad: new object on every render\n          user={{ id: item.id, name: item.name, avatar: item.avatar }}\n        />\n      )}\n    />\n  )\n}\n```\n\n**Incorrect: inline style object**\n\n```tsx\nrenderItem={({ item }) => (\n  <UserRow\n    name={item.name}\n    // Bad: new style object on every render\n    style={{ backgroundColor: item.isActive ? 'green' : 'gray' }}\n  />\n)}\n```\n\n**Correct: pass item directly or primitives**\n\n```tsx\nfunction UserList({ users }: { users: User[] }) {\n  return (\n    <LegendList\n      data={users}\n      renderItem={({ item }) => (\n        // Good: pass the item directly\n        <UserRow user={item} />\n      )}\n    />\n  )\n}\n```\n\n**Correct: pass primitives, derive inside child**\n\n```tsx\nrenderItem={({ item }) => (\n  <UserRow\n    id={item.id}\n    name={item.name}\n    isActive={item.isActive}\n  />\n)}\n\nconst UserRow = memo(function UserRow({ id, name, isActive }: Props) {\n  // Good: derive style inside memoized component\n  const backgroundColor = isActive ? 'green' : 'gray'\n  return <View style={[styles.row, { backgroundColor }]}>{/* ... */}</View>\n})\n```\n\n**Correct: hoist static styles in module scope**\n\n```tsx\nconst activeStyle = { backgroundColor: 'green' }\nconst inactiveStyle = { backgroundColor: 'gray' }\n\nrenderItem={({ item }) => (\n  <UserRow\n    name={item.name}\n    // Good: stable references\n    style={item.isActive ? activeStyle : inactiveStyle}\n  />\n)}\n```\n\nPassing primitives or stable references allows `memo()` to skip re-renders when\n\nthe actual values haven't changed.\n\n**Note:** If you have the React Compiler enabled, it handles memoization\n\nautomatically and these manual optimizations become less critical.\n\n### 2.2 Hoist callbacks to the root of lists\n\n**Impact: MEDIUM (Fewer re-renders and faster lists)**\n\nWhen passing callback functions to list items, create a single instance of the\n\ncallback at the root of the list. Items should then call it with a unique\n\nidentifier.\n\n**Incorrect: creates a new callback on each render**\n\n```typescript\nreturn (\n  <LegendList\n    renderItem={({ item }) => {\n      // bad: creates a new callback on each render\n      const onPress = () => handlePress(item.id)\n      return <Item key={item.id} item={item} onPress={onPress} />\n    }}\n  />\n)\n```\n\n**Correct: a single function instance passed to each item**\n\n```typescript\nconst onPress = useCallback(() => handlePress(item.id), [handlePress, item.id])\n\nreturn (\n  <LegendList\n    renderItem={({ item }) => (\n      <Item key={item.id} item={item} onPress={onPress} />\n    )}\n  />\n)\n```\n\nReference: [https://example.com](https://example.com)\n\n### 2.3 Keep List Items Lightweight\n\n**Impact: HIGH (reduces render time for visible items during scroll)**\n\nList items should be as inexpensive as possible to render. Minimize hooks, avoid\n\nqueries, and limit React Context access. Virtualized lists render many items\n\nduring scroll—expensive items cause jank.\n\n**Incorrect: heavy list item**\n\n```tsx\nfunction ProductRow({ id }: { id: string }) {\n  // Bad: query inside list item\n  const { data: product } = useQuery(['product', id], () => fetchProduct(id))\n  // Bad: multiple context accesses\n  const theme = useContext(ThemeContext)\n  const user = useContext(UserContext)\n  const cart = useContext(CartContext)\n  // Bad: expensive computation\n  const recommendations = useMemo(\n    () => computeRecommendations(product),\n    [product]\n  )\n\n  return <View>{/* ... */}</View>\n}\n```\n\n**Correct: lightweight list item**\n\n```tsx\nfunction ProductRow({ name, price, imageUrl }: Props) {\n  // Good: receives only primitives, minimal hooks\n  return (\n    <View>\n      <Image source={{ uri: imageUrl }} />\n      <Text>{name}</Text>\n      <Text>{price}</Text>\n    </View>\n  )\n}\n```\n\n**Move data fetching to parent:**\n\n```tsx\n// Parent fetches all data once\nfunction ProductList() {\n  const { data: products } = useQuery(['products'], fetchProducts)\n\n  return (\n    <LegendList\n      data={products}\n      renderItem={({ item }) => (\n        <ProductRow name={item.name} price={item.price} imageUrl={item.image} />\n      )}\n    />\n  )\n}\n```\n\n**For shared values, use Zustand selectors instead of Context:**\n\n```tsx\n// Incorrect: Context causes re-render when any cart value changes\nfunction ProductRow({ id, name }: Props) {\n  const { items } = useContext(CartContext)\n  const inCart = items.includes(id)\n  // ...\n}\n\n// Correct: Zustand selector only re-renders when this specific value changes\nfunction ProductRow({ id, name }: Props) {\n  // use Set.has (created once at the root) instead of Array.includes()\n  const inCart = useCartStore((s) => s.items.has(id))\n  // ...\n}\n```\n\n**Guidelines for list items:**\n\n- No queries or data fetching\n\n- No expensive computations (move to parent or memoize at parent level)\n\n- Prefer Zustand selectors over React Context\n\n- Minimize useState/useEffect hooks\n\n- Pass pre-computed values as props\n\nThe goal: list items should be simple rendering functions that take props and\n\nreturn JSX.\n\n### 2.4 Optimize List Performance with Stable Object References\n\n**Impact: CRITICAL (virtualization relies on reference stability)**\n\nDon't map or filter data before passing to virtualized lists. Virtualization\n\nrelies on object reference stability to know what changed—new references cause\n\nfull re-renders of all visible items. Attempt to prevent frequent renders at the\n\nlist-parent level.\n\nWhere needed, use context selectors within list items.\n\n**Incorrect: creates new object references on every keystroke**\n\n```tsx\nfunction DomainSearch() {\n  const { keyword, setKeyword } = useKeywordZustandState()\n  const { data: tlds } = useTlds()\n\n  // Bad: creates new objects on every render, reparenting the entire list on every keystroke\n  const domains = tlds.map((tld) => ({\n    domain: `${keyword}.${tld.name}`,\n    tld: tld.name,\n    price: tld.price,\n  }))\n\n  return (\n    <>\n      <TextInput value={keyword} onChangeText={setKeyword} />\n      <LegendList\n        data={domains}\n        renderItem={({ item }) => <DomainItem item={item} keyword={keyword} />}\n      />\n    </>\n  )\n}\n```\n\n**Correct: stable references, transform inside items**\n\n```tsx\nconst renderItem = ({ item }) => <DomainItem tld={item} />\n\nfunction DomainSearch() {\n  const { data: tlds } = useTlds()\n\n  return (\n    <LegendList\n      // good: as long as the data is stable, LegendList will not re-render the entire list\n      data={tlds}\n      renderItem={renderItem}\n    />\n  )\n}\n\nfunction DomainItem({ tld }: { tld: Tld }) {\n  // good: transform within items, and don't pass the dynamic data as a prop\n  // good: use a selector function from zustand to receive a stable string back\n  const domain = useKeywordZustandState((s) => s.keyword + '.' + tld.name)\n  return <Text>{domain}</Text>\n}\n```\n\n**Updating parent array reference:**\n\n```tsx\n// good: creates a new array instance without mutating the inner objects\n// good: parent array reference is unaffected by typing and updating \"keyword\"\nconst sortedTlds = tlds.toSorted((a, b) => a.name.localeCompare(b.name))\n\nreturn <LegendList data={sortedTlds} renderItem={renderItem} />\n```\n\nCreating a new array instance can be okay, as long as its inner object\n\nreferences are stable. For instance, if you sort a list of objects:\n\nEven though this creates a new array instance `sortedTlds`, the inner object\n\nreferences are stable.\n\n**With zustand for dynamic data: avoids parent re-renders**\n\n```tsx\nfunction DomainItemFavoriteButton({ tld }: { tld: Tld }) {\n  const isFavorited = useFavoritesStore((s) => s.favorites.has(tld.id))\n  return <TldFavoriteButton isFavorited={isFavorited} />\n}\n```\n\nVirtualization can now skip items that haven't changed when typing. Only visible\n\nitems (~20) re-render on keystroke, rather than the parent.\n\n**Deriving state within list items based on parent data (avoids parent\n\nre-renders):**\n\nFor components where the data is conditional based on the parent state, this\n\npattern is even more important. For example, if you are checking if an item is\n\nfavorited, toggling favorites only re-renders one component if the item itself\n\nis in charge of accessing the state rather than the parent:\n\nNote: if you're using the React Compiler, you can read React Context values\n\ndirectly within list items. Although this is slightly slower than using a\n\nZustand selector in most cases, the effect may be negligible.\n\n### 2.5 Pass Primitives to List Items for Memoization\n\n**Impact: HIGH (enables effective memo() comparison)**\n\nWhen possible, pass only primitive values (strings, numbers, booleans) as props\n\nto list item components. Primitives enable shallow comparison in `memo()` to\n\nwork correctly, skipping re-renders when values haven't changed.\n\n**Incorrect: object prop requires deep comparison**\n\n```tsx\ntype User = { id: string; name: string; email: string; avatar: string }\n\nconst UserRow = memo(function UserRow({ user }: { user: User }) {\n  // memo() compares user by reference, not value\n  // If parent creates new user object, this re-renders even if data is same\n  return <Text>{user.name}</Text>\n})\n\nrenderItem={({ item }) => <UserRow user={item} />}\n```\n\nThis can still be optimized, but it is harder to memoize properly.\n\n**Correct: primitive props enable shallow comparison**\n\n```tsx\nconst UserRow = memo(function UserRow({\n  id,\n  name,\n  email,\n}: {\n  id: string\n  name: string\n  email: string\n}) {\n  // memo() compares each primitive directly\n  // Re-renders only if id, name, or email actually changed\n  return <Text>{name}</Text>\n})\n\nrenderItem={({ item }) => (\n  <UserRow id={item.id} name={item.name} email={item.email} />\n)}\n```\n\n**Pass only what you need:**\n\n```tsx\n// Incorrect: passing entire item when you only need name\n<UserRow user={item} />\n\n// Correct: pass only the fields the component uses\n<UserRow name={item.name} avatarUrl={item.avatar} />\n```\n\n**For callbacks, hoist or use item ID:**\n\n```tsx\n// Incorrect: inline function creates new reference\n<UserRow name={item.name} onPress={() => handlePress(item.id)} />\n\n// Correct: pass ID, handle in child\n<UserRow id={item.id} name={item.name} />\n\nconst UserRow = memo(function UserRow({ id, name }: Props) {\n  const handlePress = useCallback(() => {\n    // use id here\n  }, [id])\n  return <Pressable onPress={handlePress}><Text>{name}</Text></Pressable>\n})\n```\n\nPrimitive props make memoization predictable and effective.\n\n**Note:** If you have the React Compiler enabled, you do not need to use\n\n`memo()` or `useCallback()`, but the object references still apply.\n\n### 2.6 Use a List Virtualizer for Any List\n\n**Impact: HIGH (reduced memory, faster mounts)**\n\nUse a list virtualizer like LegendList or FlashList instead of ScrollView with\n\nmapped children—even for short lists. Virtualizers only render visible items,\n\nreducing memory usage and mount time. ScrollView renders all children upfront,\n\nwhich gets expensive quickly.\n\n**Incorrect: ScrollView renders all items at once**\n\n```tsx\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <ScrollView>\n      {items.map((item) => (\n        <ItemCard key={item.id} item={item} />\n      ))}\n    </ScrollView>\n  )\n}\n// 50 items = 50 components mounted, even if only 10 visible\n```\n\n**Correct: virtualizer renders only visible items**\n\n```tsx\nimport { LegendList } from '@legendapp/list'\n\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <LegendList\n      data={items}\n      // if you aren't using React Compiler, wrap these with useCallback\n      renderItem={({ item }) => <ItemCard item={item} />}\n      keyExtractor={(item) => item.id}\n      estimatedItemSize={80}\n    />\n  )\n}\n// Only ~10-15 visible items mounted at a time\n```\n\n**Alternative: FlashList**\n\n```tsx\nimport { FlashList } from '@shopify/flash-list'\n\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <FlashList\n      data={items}\n      // if you aren't using React Compiler, wrap these with useCallback\n      renderItem={({ item }) => <ItemCard item={item} />}\n      keyExtractor={(item) => item.id}\n    />\n  )\n}\n```\n\nBenefits apply to any screen with scrollable content—profiles, settings, feeds,\n\nsearch results. Default to virtualization.\n\n### 2.7 Use Compressed Images in Lists\n\n**Impact: HIGH (faster load times, less memory)**\n\nAlways load compressed, appropriately-sized images in lists. Full-resolution\n\nimages consume excessive memory and cause scroll jank. Request thumbnails from\n\nyour server or use an image CDN with resize parameters.\n\n**Incorrect: full-resolution images**\n\n```tsx\nfunction ProductItem({ product }: { product: Product }) {\n  return (\n    <View>\n      {/* 4000x3000 image loaded for a 100x100 thumbnail */}\n      <Image\n        source={{ uri: product.imageUrl }}\n        style={{ width: 100, height: 100 }}\n      />\n      <Text>{product.name}</Text>\n    </View>\n  )\n}\n```\n\n**Correct: request appropriately-sized image**\n\n```tsx\nfunction ProductItem({ product }: { product: Product }) {\n  // Request a 200x200 image (2x for retina)\n  const thumbnailUrl = `${product.imageUrl}?w=200&h=200&fit=cover`\n\n  return (\n    <View>\n      <Image\n        source={{ uri: thumbnailUrl }}\n        style={{ width: 100, height: 100 }}\n        contentFit='cover'\n      />\n      <Text>{product.name}</Text>\n    </View>\n  )\n}\n```\n\nUse an optimized image component with built-in caching and placeholder support,\n\nsuch as `expo-image` or `SolitoImage` (which uses `expo-image` under the hood).\n\nRequest images at 2x the display size for retina screens.\n\n### 2.8 Use Item Types for Heterogeneous Lists\n\n**Impact: HIGH (efficient recycling, less layout thrashing)**\n\nWhen a list has different item layouts (messages, images, headers, etc.), use a\n\n`type` field on each item and provide `getItemType` to the list. This puts items\n\ninto separate recycling pools so a message component never gets recycled into an\n\nimage component.\n\n[LegendList getItemType](https://legendapp.com/open-source/list/api/props/#getitemtype-v2)\n\n**Incorrect: single component with conditionals**\n\n```tsx\ntype Item = { id: string; text?: string; imageUrl?: string; isHeader?: boolean }\n\nfunction ListItem({ item }: { item: Item }) {\n  if (item.isHeader) {\n    return <HeaderItem title={item.text} />\n  }\n  if (item.imageUrl) {\n    return <ImageItem url={item.imageUrl} />\n  }\n  return <MessageItem text={item.text} />\n}\n\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <LegendList\n      data={items}\n      renderItem={({ item }) => <ListItem item={item} />}\n      recycleItems\n    />\n  )\n}\n```\n\n**Correct: typed items with separate components**\n\n```tsx\ntype HeaderItem = { id: string; type: 'header'; title: string }\ntype MessageItem = { id: string; type: 'message'; text: string }\ntype ImageItem = { id: string; type: 'image'; url: string }\ntype FeedItem = HeaderItem | MessageItem | ImageItem\n\nfunction Feed({ items }: { items: FeedItem[] }) {\n  return (\n    <LegendList\n      data={items}\n      keyExtractor={(item) => item.id}\n      getItemType={(item) => item.type}\n      renderItem={({ item }) => {\n        switch (item.type) {\n          case 'header':\n            return <SectionHeader title={item.title} />\n          case 'message':\n            return <MessageRow text={item.text} />\n          case 'image':\n            return <ImageRow url={item.url} />\n        }\n      }}\n      recycleItems\n    />\n  )\n}\n```\n\n**Why this matters:**\n\n```tsx\n<LegendList\n  data={items}\n  keyExtractor={(item) => item.id}\n  getItemType={(item) => item.type}\n  getEstimatedItemSize={(index, item, itemType) => {\n    switch (itemType) {\n      case 'header':\n        return 48\n      case 'message':\n        return 72\n      case 'image':\n        return 300\n      default:\n        return 72\n    }\n  }}\n  renderItem={({ item }) => {\n    /* ... */\n  }}\n  recycleItems\n/>\n```\n\n- **Recycling efficiency**: Items with the same type share a recycling pool\n\n- **No layout thrashing**: A header never recycles into an image cell\n\n- **Type safety**: TypeScript can narrow the item type in each branch\n\n- **Better size estimation**: Use `getEstimatedItemSize` with `itemType` for\n\n  accurate estimates per type\n\n---\n\n## 3. Animation\n\n**Impact: HIGH**\n\nGPU-accelerated animations, Reanimated patterns, and avoiding\nrender thrashing during gestures.\n\n### 3.1 Animate Transform and Opacity Instead of Layout Properties\n\n**Impact: HIGH (GPU-accelerated animations, no layout recalculation)**\n\nAvoid animating `width`, `height`, `top`, `left`, `margin`, or `padding`. These trigger layout recalculation on every frame. Instead, use `transform` (scale, translate) and `opacity` which run on the GPU without triggering layout.\n\n**Incorrect: animates height, triggers layout every frame**\n\n```tsx\nimport Animated, { useAnimatedStyle, withTiming } from 'react-native-reanimated'\n\nfunction CollapsiblePanel({ expanded }: { expanded: boolean }) {\n  const animatedStyle = useAnimatedStyle(() => ({\n    height: withTiming(expanded ? 200 : 0), // triggers layout on every frame\n    overflow: 'hidden',\n  }))\n\n  return <Animated.View style={animatedStyle}>{children}</Animated.View>\n}\n```\n\n**Correct: animates scaleY, GPU-accelerated**\n\n```tsx\nimport Animated, { useAnimatedStyle, withTiming } from 'react-native-reanimated'\n\nfunction CollapsiblePanel({ expanded }: { expanded: boolean }) {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { scaleY: withTiming(expanded ? 1 : 0) },\n    ],\n    opacity: withTiming(expanded ? 1 : 0),\n  }))\n\n  return (\n    <Animated.View style={[{ height: 200, transformOrigin: 'top' }, animatedStyle]}>\n      {children}\n    </Animated.View>\n  )\n}\n```\n\n**Correct: animates translateY for slide animations**\n\n```tsx\nimport Animated, { useAnimatedStyle, withTiming } from 'react-native-reanimated'\n\nfunction SlideIn({ visible }: { visible: boolean }) {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: withTiming(visible ? 0 : 100) },\n    ],\n    opacity: withTiming(visible ? 1 : 0),\n  }))\n\n  return <Animated.View style={animatedStyle}>{children}</Animated.View>\n}\n```\n\nGPU-accelerated properties: `transform` (translate, scale, rotate), `opacity`. Everything else triggers layout.\n\n### 3.2 Prefer useDerivedValue Over useAnimatedReaction\n\n**Impact: MEDIUM (cleaner code, automatic dependency tracking)**\n\nWhen deriving a shared value from another, use `useDerivedValue` instead of\n\n`useAnimatedReaction`. Derived values are declarative, automatically track\n\ndependencies, and return a value you can use directly. Animated reactions are\n\nfor side effects, not derivations.\n\n[Reanimated useDerivedValue](https://docs.swmansion.com/react-native-reanimated/docs/core/useDerivedValue)\n\n**Incorrect: useAnimatedReaction for derivation**\n\n```tsx\nimport { useSharedValue, useAnimatedReaction } from 'react-native-reanimated'\n\nfunction MyComponent() {\n  const progress = useSharedValue(0)\n  const opacity = useSharedValue(1)\n\n  useAnimatedReaction(\n    () => progress.value,\n    (current) => {\n      opacity.value = 1 - current\n    }\n  )\n\n  // ...\n}\n```\n\n**Correct: useDerivedValue**\n\n```tsx\nimport { useSharedValue, useDerivedValue } from 'react-native-reanimated'\n\nfunction MyComponent() {\n  const progress = useSharedValue(0)\n\n  const opacity = useDerivedValue(() => 1 - progress.get())\n\n  // ...\n}\n```\n\nUse `useAnimatedReaction` only for side effects that don't produce a value\n\n(e.g., triggering haptics, logging, calling `runOnJS`).\n\n### 3.3 Use GestureDetector for Animated Press States\n\n**Impact: MEDIUM (UI thread animations, smoother press feedback)**\n\nFor animated press states (scale, opacity on press), use `GestureDetector` with\n\n`Gesture.Tap()` and shared values instead of Pressable's\n\n`onPressIn`/`onPressOut`. Gesture callbacks run on the UI thread as worklets—no\n\nJS thread round-trip for press animations.\n\n[Gesture Handler Tap Gesture](https://docs.swmansion.com/react-native-gesture-handler/docs/gestures/tap-gesture)\n\n**Incorrect: Pressable with JS thread callbacks**\n\n```tsx\nimport { Pressable } from 'react-native'\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n} from 'react-native-reanimated'\n\nfunction AnimatedButton({ onPress }: { onPress: () => void }) {\n  const scale = useSharedValue(1)\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }))\n\n  return (\n    <Pressable\n      onPress={onPress}\n      onPressIn={() => (scale.value = withTiming(0.95))}\n      onPressOut={() => (scale.value = withTiming(1))}\n    >\n      <Animated.View style={animatedStyle}>\n        <Text>Press me</Text>\n      </Animated.View>\n    </Pressable>\n  )\n}\n```\n\n**Correct: GestureDetector with UI thread worklets**\n\n```tsx\nimport { Gesture, GestureDetector } from 'react-native-gesture-handler'\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  interpolate,\n  runOnJS,\n} from 'react-native-reanimated'\n\nfunction AnimatedButton({ onPress }: { onPress: () => void }) {\n  // Store the press STATE (0 = not pressed, 1 = pressed)\n  const pressed = useSharedValue(0)\n\n  const tap = Gesture.Tap()\n    .onBegin(() => {\n      pressed.set(withTiming(1))\n    })\n    .onFinalize(() => {\n      pressed.set(withTiming(0))\n    })\n    .onEnd(() => {\n      runOnJS(onPress)()\n    })\n\n  // Derive visual values from the state\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { scale: interpolate(withTiming(pressed.get()), [0, 1], [1, 0.95]) },\n    ],\n  }))\n\n  return (\n    <GestureDetector gesture={tap}>\n      <Animated.View style={animatedStyle}>\n        <Text>Press me</Text>\n      </Animated.View>\n    </GestureDetector>\n  )\n}\n```\n\nStore the press **state** (0 or 1), then derive the scale via `interpolate`.\n\nThis keeps the shared value as ground truth. Use `runOnJS` to call JS functions\n\nfrom worklets. Use `.set()` and `.get()` for React Compiler compatibility.\n\n---\n\n## 4. Scroll Performance\n\n**Impact: HIGH**\n\nTracking scroll position without causing render thrashing.\n\n### 4.1 Never Track Scroll Position in useState\n\n**Impact: HIGH (prevents render thrashing during scroll)**\n\nNever store scroll position in `useState`. Scroll events fire rapidly—state\n\nupdates cause render thrashing and dropped frames. Use a Reanimated shared value\n\nfor animations or a ref for non-reactive tracking.\n\n**Incorrect: useState causes jank**\n\n```tsx\nimport { useState } from 'react'\nimport {\n  ScrollView,\n  NativeSyntheticEvent,\n  NativeScrollEvent,\n} from 'react-native'\n\nfunction Feed() {\n  const [scrollY, setScrollY] = useState(0)\n\n  const onScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {\n    setScrollY(e.nativeEvent.contentOffset.y) // re-renders on every frame\n  }\n\n  return <ScrollView onScroll={onScroll} scrollEventThrottle={16} />\n}\n```\n\n**Correct: Reanimated for animations**\n\n```tsx\nimport Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n} from 'react-native-reanimated'\n\nfunction Feed() {\n  const scrollY = useSharedValue(0)\n\n  const onScroll = useAnimatedScrollHandler({\n    onScroll: (e) => {\n      scrollY.value = e.contentOffset.y // runs on UI thread, no re-render\n    },\n  })\n\n  return (\n    <Animated.ScrollView\n      onScroll={onScroll}\n      // higher number has better performance, but it fires less often.\n      // unset this if you need higher precision over performance.\n      scrollEventThrottle={16}\n    />\n  )\n}\n```\n\n**Correct: ref for non-reactive tracking**\n\n```tsx\nimport { useRef } from 'react'\nimport {\n  ScrollView,\n  NativeSyntheticEvent,\n  NativeScrollEvent,\n} from 'react-native'\n\nfunction Feed() {\n  const scrollY = useRef(0)\n\n  const onScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {\n    scrollY.current = e.nativeEvent.contentOffset.y // no re-render\n  }\n\n  return <ScrollView onScroll={onScroll} scrollEventThrottle={16} />\n}\n```\n\n---\n\n## 5. Navigation\n\n**Impact: HIGH**\n\nUsing native navigators for stack and tab navigation instead of\nJS-based alternatives.\n\n### 5.1 Use Native Navigators for Navigation\n\n**Impact: HIGH (native performance, platform-appropriate UI)**\n\nAlways use native navigators instead of JS-based ones. Native navigators use\n\nplatform APIs (UINavigationController on iOS, Fragment on Android) for better\n\nperformance and native behavior.\n\n**For stacks:** Use `@react-navigation/native-stack` or expo-router's default\n\nstack (which uses native-stack). Avoid `@react-navigation/stack`.\n\n**For tabs:** Use `react-native-bottom-tabs` (native) or expo-router's native\n\ntabs. Avoid `@react-navigation/bottom-tabs` when native feel matters.\n\n- [React Navigation Native Stack](https://reactnavigation.org/docs/native-stack-navigator)\n\n- [React Native Bottom Tabs with React Navigation](https://oss.callstack.com/react-native-bottom-tabs/docs/guides/usage-with-react-navigation)\n\n- [React Native Bottom Tabs with Expo Router](https://oss.callstack.com/react-native-bottom-tabs/docs/guides/usage-with-expo-router)\n\n- [Expo Router Native Tabs](https://docs.expo.dev/router/advanced/native-tabs)\n\n**Incorrect: JS stack navigator**\n\n```tsx\nimport { createStackNavigator } from '@react-navigation/stack'\n\nconst Stack = createStackNavigator()\n\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name='Home' component={HomeScreen} />\n      <Stack.Screen name='Details' component={DetailsScreen} />\n    </Stack.Navigator>\n  )\n}\n```\n\n**Correct: native stack with react-navigation**\n\n```tsx\nimport { createNativeStackNavigator } from '@react-navigation/native-stack'\n\nconst Stack = createNativeStackNavigator()\n\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name='Home' component={HomeScreen} />\n      <Stack.Screen name='Details' component={DetailsScreen} />\n    </Stack.Navigator>\n  )\n}\n```\n\n**Correct: expo-router uses native stack by default**\n\n```tsx\n// app/_layout.tsx\nimport { Stack } from 'expo-router'\n\nexport default function Layout() {\n  return <Stack />\n}\n```\n\n**Incorrect: JS bottom tabs**\n\n```tsx\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs'\n\nconst Tab = createBottomTabNavigator()\n\nfunction App() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name='Home' component={HomeScreen} />\n      <Tab.Screen name='Settings' component={SettingsScreen} />\n    </Tab.Navigator>\n  )\n}\n```\n\n**Correct: native bottom tabs with react-navigation**\n\n```tsx\nimport { createNativeBottomTabNavigator } from '@bottom-tabs/react-navigation'\n\nconst Tab = createNativeBottomTabNavigator()\n\nfunction App() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen\n        name='Home'\n        component={HomeScreen}\n        options={{\n          tabBarIcon: () => ({ sfSymbol: 'house' }),\n        }}\n      />\n      <Tab.Screen\n        name='Settings'\n        component={SettingsScreen}\n        options={{\n          tabBarIcon: () => ({ sfSymbol: 'gear' }),\n        }}\n      />\n    </Tab.Navigator>\n  )\n}\n```\n\n**Correct: expo-router native tabs**\n\n```tsx\n// app/(tabs)/_layout.tsx\nimport { NativeTabs } from 'expo-router/unstable-native-tabs'\n\nexport default function TabLayout() {\n  return (\n    <NativeTabs>\n      <NativeTabs.Trigger name='index'>\n        <NativeTabs.Trigger.Label>Home</NativeTabs.Trigger.Label>\n        <NativeTabs.Trigger.Icon sf='house.fill' md='home' />\n      </NativeTabs.Trigger>\n      <NativeTabs.Trigger name='settings'>\n        <NativeTabs.Trigger.Label>Settings</NativeTabs.Trigger.Label>\n        <NativeTabs.Trigger.Icon sf='gear' md='settings' />\n      </NativeTabs.Trigger>\n    </NativeTabs>\n  )\n}\n```\n\nOn iOS, native tabs automatically enable `contentInsetAdjustmentBehavior` on the\n\nfirst `ScrollView` at the root of each tab screen, so content scrolls correctly\n\nbehind the translucent tab bar. If you need to disable this, use\n\n`disableAutomaticContentInsets` on the trigger.\n\n**Incorrect: custom header component**\n\n```tsx\n<Stack.Screen\n  name='Profile'\n  component={ProfileScreen}\n  options={{\n    header: () => <CustomHeader title='Profile' />,\n  }}\n/>\n```\n\n**Correct: native header options**\n\n```tsx\n<Stack.Screen\n  name='Profile'\n  component={ProfileScreen}\n  options={{\n    title: 'Profile',\n    headerLargeTitleEnabled: true,\n    headerSearchBarOptions: {\n      placeholder: 'Search',\n    },\n  }}\n/>\n```\n\nNative headers support iOS large titles, search bars, blur effects, and proper\n\nsafe area handling automatically.\n\n- **Performance**: Native transitions and gestures run on the UI thread\n\n- **Platform behavior**: Automatic iOS large titles, Android material design\n\n- **System integration**: Scroll-to-top on tab tap, PiP avoidance, proper safe\n\n  areas\n\n- **Accessibility**: Platform accessibility features work automatically\n\n---\n\n## 6. React State\n\n**Impact: MEDIUM**\n\nPatterns for managing React state to avoid stale closures and\nunnecessary re-renders.\n\n### 6.1 Minimize State Variables and Derive Values\n\n**Impact: MEDIUM (fewer re-renders, less state drift)**\n\nUse the fewest state variables possible. If a value can be computed from existing state or props, derive it during render instead of storing it in state. Redundant state causes unnecessary re-renders and can drift out of sync.\n\n**Incorrect: redundant state**\n\n```tsx\nfunction Cart({ items }: { items: Item[] }) {\n  const [total, setTotal] = useState(0)\n  const [itemCount, setItemCount] = useState(0)\n\n  useEffect(() => {\n    setTotal(items.reduce((sum, item) => sum + item.price, 0))\n    setItemCount(items.length)\n  }, [items])\n\n  return (\n    <View>\n      <Text>{itemCount} items</Text>\n      <Text>Total: ${total}</Text>\n    </View>\n  )\n}\n```\n\n**Correct: derived values**\n\n```tsx\nfunction Cart({ items }: { items: Item[] }) {\n  const total = items.reduce((sum, item) => sum + item.price, 0)\n  const itemCount = items.length\n\n  return (\n    <View>\n      <Text>{itemCount} items</Text>\n      <Text>Total: ${total}</Text>\n    </View>\n  )\n}\n```\n\n**Another example:**\n\n```tsx\n// Incorrect: storing both firstName, lastName, AND fullName\nconst [firstName, setFirstName] = useState('')\nconst [lastName, setLastName] = useState('')\nconst [fullName, setFullName] = useState('')\n\n// Correct: derive fullName\nconst [firstName, setFirstName] = useState('')\nconst [lastName, setLastName] = useState('')\nconst fullName = `${firstName} ${lastName}`\n```\n\nState should be the minimal source of truth. Everything else is derived.\n\nReference: [https://react.dev/learn/choosing-the-state-structure](https://react.dev/learn/choosing-the-state-structure)\n\n### 6.2 Use fallback state instead of initialState\n\n**Impact: MEDIUM (reactive fallbacks without syncing)**\n\nUse `undefined` as initial state and nullish coalescing (`??`) to fall back to\n\nparent or server values. State represents user intent only—`undefined` means\n\n\"user hasn't chosen yet.\" This enables reactive fallbacks that update when the\n\nsource changes, not just on initial render.\n\n**Incorrect: syncs state, loses reactivity**\n\n```tsx\ntype Props = { fallbackEnabled: boolean }\n\nfunction Toggle({ fallbackEnabled }: Props) {\n  const [enabled, setEnabled] = useState(defaultEnabled)\n  // If fallbackEnabled changes, state is stale\n  // State mixes user intent with default value\n\n  return <Switch value={enabled} onValueChange={setEnabled} />\n}\n```\n\n**Correct: state is user intent, reactive fallback**\n\n```tsx\ntype Props = { fallbackEnabled: boolean }\n\nfunction Toggle({ fallbackEnabled }: Props) {\n  const [_enabled, setEnabled] = useState<boolean | undefined>(undefined)\n  const enabled = _enabled ?? defaultEnabled\n  // undefined = user hasn't touched it, falls back to prop\n  // If defaultEnabled changes, component reflects it\n  // Once user interacts, their choice persists\n\n  return <Switch value={enabled} onValueChange={setEnabled} />\n}\n```\n\n**With server data:**\n\n```tsx\nfunction ProfileForm({ data }: { data: User }) {\n  const [_theme, setTheme] = useState<string | undefined>(undefined)\n  const theme = _theme ?? data.theme\n  // Shows server value until user overrides\n  // Server refetch updates the fallback automatically\n\n  return <ThemePicker value={theme} onChange={setTheme} />\n}\n```\n\n### 6.3 useState Dispatch updaters for State That Depends on Current Value\n\n**Impact: MEDIUM (avoids stale closures, prevents unnecessary re-renders)**\n\nWhen the next state depends on the current state, use a dispatch updater\n\n(`setState(prev => ...)`) instead of reading the state variable directly in a\n\ncallback. This avoids stale closures and ensures you're comparing against the\n\nlatest value.\n\n**Incorrect: reads state directly**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  // size may be stale in this closure\n  if (size?.width !== width || size?.height !== height) {\n    setSize({ width, height })\n  }\n}\n```\n\n**Correct: dispatch updater**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  setSize((prev) => {\n    if (prev?.width === width && prev?.height === height) return prev\n    return { width, height }\n  })\n}\n```\n\nReturning the previous value from the updater skips the re-render.\n\nFor primitive states, you don't need to compare values before firing a\n\nre-render.\n\n**Incorrect: unnecessary comparison for primitive state**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  setSize((prev) => (prev === width ? prev : width))\n}\n```\n\n**Correct: sets primitive state directly**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  setSize(width)\n}\n```\n\nHowever, if the next state depends on the current state, you should still use a\n\ndispatch updater.\n\n**Incorrect: reads state directly from the callback**\n\n```tsx\nconst [count, setCount] = useState(0)\n\nconst onTap = () => {\n  setCount(count + 1)\n}\n```\n\n**Correct: dispatch updater**\n\n```tsx\nconst [count, setCount] = useState(0)\n\nconst onTap = () => {\n  setCount((prev) => prev + 1)\n}\n```\n\n---\n\n## 7. State Architecture\n\n**Impact: MEDIUM**\n\nGround truth principles for state variables and derived values.\n\n### 7.1 State Must Represent Ground Truth\n\n**Impact: HIGH (cleaner logic, easier debugging, single source of truth)**\n\nState variables—both React `useState` and Reanimated shared values—should\n\nrepresent the actual state of something (e.g., `pressed`, `progress`, `isOpen`),\n\nnot derived visual values (e.g., `scale`, `opacity`, `translateY`). Derive\n\nvisual values from state using computation or interpolation.\n\n**Incorrect: storing the visual output**\n\n```tsx\nconst scale = useSharedValue(1)\n\nconst tap = Gesture.Tap()\n  .onBegin(() => {\n    scale.set(withTiming(0.95))\n  })\n  .onFinalize(() => {\n    scale.set(withTiming(1))\n  })\n\nconst animatedStyle = useAnimatedStyle(() => ({\n  transform: [{ scale: scale.get() }],\n}))\n```\n\n**Correct: storing the state, deriving the visual**\n\n```tsx\nconst pressed = useSharedValue(0) // 0 = not pressed, 1 = pressed\n\nconst tap = Gesture.Tap()\n  .onBegin(() => {\n    pressed.set(withTiming(1))\n  })\n  .onFinalize(() => {\n    pressed.set(withTiming(0))\n  })\n\nconst animatedStyle = useAnimatedStyle(() => ({\n  transform: [{ scale: interpolate(pressed.get(), [0, 1], [1, 0.95]) }],\n}))\n```\n\n**Why this matters:**\n\nState variables should represent real \"state\", not necessarily a desired end\n\nresult.\n\n1. **Single source of truth** — The state (`pressed`) describes what's\n\n   happening; visuals are derived\n\n2. **Easier to extend** — Adding opacity, rotation, or other effects just\n\n   requires more interpolations from the same state\n\n3. **Debugging** — Inspecting `pressed = 1` is clearer than `scale = 0.95`\n\n4. **Reusable logic** — The same `pressed` value can drive multiple visual\n\n   properties\n\n**Same principle for React state:**\n\n```tsx\n// Incorrect: storing derived values\nconst [isExpanded, setIsExpanded] = useState(false)\nconst [height, setHeight] = useState(0)\n\nuseEffect(() => {\n  setHeight(isExpanded ? 200 : 0)\n}, [isExpanded])\n\n// Correct: derive from state\nconst [isExpanded, setIsExpanded] = useState(false)\nconst height = isExpanded ? 200 : 0\n```\n\nState is the minimal truth. Everything else is derived.\n\n---\n\n## 8. React Compiler\n\n**Impact: MEDIUM**\n\nCompatibility patterns for React Compiler with React Native and\nReanimated.\n\n### 8.1 Destructure Functions Early in Render (React Compiler)\n\n**Impact: HIGH (stable references, fewer re-renders)**\n\nThis rule is only applicable if you are using the React Compiler.\n\nDestructure functions from hooks at the top of render scope. Never dot into\n\nobjects to call functions. Destructured functions are stable references; dotting\n\ncreates new references and breaks memoization.\n\n**Incorrect: dotting into object**\n\n```tsx\nimport { useRouter } from 'expo-router'\n\nfunction SaveButton(props) {\n  const router = useRouter()\n\n  // bad: react-compiler will key the cache on \"props\" and \"router\", which are objects that change each render\n  const handlePress = () => {\n    props.onSave()\n    router.push('/success') // unstable reference\n  }\n\n  return <Button onPress={handlePress}>Save</Button>\n}\n```\n\n**Correct: destructure early**\n\n```tsx\nimport { useRouter } from 'expo-router'\n\nfunction SaveButton({ onSave }) {\n  const { push } = useRouter()\n\n  // good: react-compiler will key on push and onSave\n  const handlePress = () => {\n    onSave()\n    push('/success') // stable reference\n  }\n\n  return <Button onPress={handlePress}>Save</Button>\n}\n```\n\n### 8.2 Use .get() and .set() for Reanimated Shared Values (not .value)\n\n**Impact: LOW (required for React Compiler compatibility)**\n\nWith React Compiler enabled, use `.get()` and `.set()` instead of reading or\n\nwriting `.value` directly on Reanimated shared values. The compiler can't track\n\nproperty access—explicit methods ensure correct behavior.\n\n**Incorrect: breaks with React Compiler**\n\n```tsx\nimport { useSharedValue } from 'react-native-reanimated'\n\nfunction Counter() {\n  const count = useSharedValue(0)\n\n  const increment = () => {\n    count.value = count.value + 1 // opts out of react compiler\n  }\n\n  return <Button onPress={increment} title={`Count: ${count.value}`} />\n}\n```\n\n**Correct: React Compiler compatible**\n\n```tsx\nimport { useSharedValue } from 'react-native-reanimated'\n\nfunction Counter() {\n  const count = useSharedValue(0)\n\n  const increment = () => {\n    count.set(count.get() + 1)\n  }\n\n  return <Button onPress={increment} title={`Count: ${count.get()}`} />\n}\n```\n\nSee the\n\n[Reanimated docs](https://docs.swmansion.com/react-native-reanimated/docs/core/useSharedValue/#react-compiler-support)\n\nfor more.\n\n---\n\n## 9. User Interface\n\n**Impact: MEDIUM**\n\nNative UI patterns for images, menus, modals, styling, and\nplatform-consistent interfaces.\n\n### 9.1 Measuring View Dimensions\n\n**Impact: MEDIUM (synchronous measurement, avoid unnecessary re-renders)**\n\nUse both `useLayoutEffect` (synchronous) and `onLayout` (for updates). The sync\n\nmeasurement gives you the initial size immediately; `onLayout` keeps it current\n\nwhen the view changes. For non-primitive states, use a dispatch updater to\n\ncompare values and avoid unnecessary re-renders.\n\n**Height only:**\n\n```tsx\nimport { useLayoutEffect, useRef, useState } from 'react'\nimport { View, LayoutChangeEvent } from 'react-native'\n\nfunction MeasuredBox({ children }: { children: React.ReactNode }) {\n  const ref = useRef<View>(null)\n  const [height, setHeight] = useState<number | undefined>(undefined)\n\n  useLayoutEffect(() => {\n    // Sync measurement on mount (RN 0.82+)\n    const rect = ref.current?.getBoundingClientRect()\n    if (rect) setHeight(rect.height)\n    // Pre-0.82: ref.current?.measure((x, y, w, h) => setHeight(h))\n  }, [])\n\n  const onLayout = (e: LayoutChangeEvent) => {\n    setHeight(e.nativeEvent.layout.height)\n  }\n\n  return (\n    <View ref={ref} onLayout={onLayout}>\n      {children}\n    </View>\n  )\n}\n```\n\n**Both dimensions:**\n\n```tsx\nimport { useLayoutEffect, useRef, useState } from 'react'\nimport { View, LayoutChangeEvent } from 'react-native'\n\ntype Size = { width: number; height: number }\n\nfunction MeasuredBox({ children }: { children: React.ReactNode }) {\n  const ref = useRef<View>(null)\n  const [size, setSize] = useState<Size | undefined>(undefined)\n\n  useLayoutEffect(() => {\n    const rect = ref.current?.getBoundingClientRect()\n    if (rect) setSize({ width: rect.width, height: rect.height })\n  }, [])\n\n  const onLayout = (e: LayoutChangeEvent) => {\n    const { width, height } = e.nativeEvent.layout\n    setSize((prev) => {\n      // for non-primitive states, compare values before firing a re-render\n      if (prev?.width === width && prev?.height === height) return prev\n      return { width, height }\n    })\n  }\n\n  return (\n    <View ref={ref} onLayout={onLayout}>\n      {children}\n    </View>\n  )\n}\n```\n\nUse functional setState to compare—don't read state directly in the callback.\n\n### 9.2 Modern React Native Styling Patterns\n\n**Impact: MEDIUM (consistent design, smoother borders, cleaner layouts)**\n\nFollow these styling patterns for cleaner, more consistent React Native code.\n\n**Always use `borderCurve: 'continuous'` with `borderRadius`:**\n\n**Use `gap` instead of margin for spacing between elements:**\n\n```tsx\n// Incorrect – margin on children\n<View>\n  <Text style={{ marginBottom: 8 }}>Title</Text>\n  <Text style={{ marginBottom: 8 }}>Subtitle</Text>\n</View>\n\n// Correct – gap on parent\n<View style={{ gap: 8 }}>\n  <Text>Title</Text>\n  <Text>Subtitle</Text>\n</View>\n```\n\n**Use `padding` for space within, `gap` for space between:**\n\n```tsx\n<View style={{ padding: 16, gap: 12 }}>\n  <Text>First</Text>\n  <Text>Second</Text>\n</View>\n```\n\n**Use `experimental_backgroundImage` for linear gradients:**\n\n```tsx\n// Incorrect – third-party gradient library\n<LinearGradient colors={['#000', '#fff']} />\n\n// Correct – native CSS gradient syntax\n<View\n  style={{\n    experimental_backgroundImage: 'linear-gradient(to bottom, #000, #fff)',\n  }}\n/>\n```\n\n**Use CSS `boxShadow` string syntax for shadows:**\n\n```tsx\n// Incorrect – legacy shadow objects or elevation\n{ shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.1 }\n{ elevation: 4 }\n\n// Correct – CSS box-shadow syntax\n{ boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)' }\n```\n\n**Avoid multiple font sizes – use weight and color for emphasis:**\n\n```tsx\n// Incorrect – varying font sizes for hierarchy\n<Text style={{ fontSize: 18 }}>Title</Text>\n<Text style={{ fontSize: 14 }}>Subtitle</Text>\n<Text style={{ fontSize: 12 }}>Caption</Text>\n\n// Correct – consistent size, vary weight and color\n<Text style={{ fontWeight: '600' }}>Title</Text>\n<Text style={{ color: '#666' }}>Subtitle</Text>\n<Text style={{ color: '#999' }}>Caption</Text>\n```\n\nLimiting font sizes creates visual consistency. Use `fontWeight` (bold/semibold)\n\nand grayscale colors for hierarchy instead.\n\n### 9.3 Use contentInset for Dynamic ScrollView Spacing\n\n**Impact: LOW (smoother updates, no layout recalculation)**\n\nWhen adding space to the top or bottom of a ScrollView that may change\n\n(keyboard, toolbars, dynamic content), use `contentInset` instead of padding.\n\nChanging `contentInset` doesn't trigger layout recalculation—it adjusts the\n\nscroll area without re-rendering content.\n\n**Incorrect: padding causes layout recalculation**\n\n```tsx\nfunction Feed({ bottomOffset }: { bottomOffset: number }) {\n  return (\n    <ScrollView contentContainerStyle={{ paddingBottom: bottomOffset }}>\n      {children}\n    </ScrollView>\n  )\n}\n// Changing bottomOffset triggers full layout recalculation\n```\n\n**Correct: contentInset for dynamic spacing**\n\n```tsx\nfunction Feed({ bottomOffset }: { bottomOffset: number }) {\n  return (\n    <ScrollView\n      contentInset={{ bottom: bottomOffset }}\n      scrollIndicatorInsets={{ bottom: bottomOffset }}\n    >\n      {children}\n    </ScrollView>\n  )\n}\n// Changing bottomOffset only adjusts scroll bounds\n```\n\nUse `scrollIndicatorInsets` alongside `contentInset` to keep the scroll\n\nindicator aligned. For static spacing that never changes, padding is fine.\n\n### 9.4 Use contentInsetAdjustmentBehavior for Safe Areas\n\n**Impact: MEDIUM (native safe area handling, no layout shifts)**\n\nUse `contentInsetAdjustmentBehavior=\"automatic\"` on the root ScrollView instead of wrapping content in SafeAreaView or manual padding. This lets iOS handle safe area insets natively with proper scroll behavior.\n\n**Incorrect: SafeAreaView wrapper**\n\n```tsx\nimport { SafeAreaView, ScrollView, View, Text } from 'react-native'\n\nfunction MyScreen() {\n  return (\n    <SafeAreaView style={{ flex: 1 }}>\n      <ScrollView>\n        <View>\n          <Text>Content</Text>\n        </View>\n      </ScrollView>\n    </SafeAreaView>\n  )\n}\n```\n\n**Incorrect: manual safe area padding**\n\n```tsx\nimport { ScrollView, View, Text } from 'react-native'\nimport { useSafeAreaInsets } from 'react-native-safe-area-context'\n\nfunction MyScreen() {\n  const insets = useSafeAreaInsets()\n\n  return (\n    <ScrollView contentContainerStyle={{ paddingTop: insets.top }}>\n      <View>\n        <Text>Content</Text>\n      </View>\n    </ScrollView>\n  )\n}\n```\n\n**Correct: native content inset adjustment**\n\n```tsx\nimport { ScrollView, View, Text } from 'react-native'\n\nfunction MyScreen() {\n  return (\n    <ScrollView contentInsetAdjustmentBehavior='automatic'>\n      <View>\n        <Text>Content</Text>\n      </View>\n    </ScrollView>\n  )\n}\n```\n\nThe native approach handles dynamic safe areas (keyboard, toolbars) and allows content to scroll behind the status bar naturally.\n\n### 9.5 Use expo-image for Optimized Images\n\n**Impact: HIGH (memory efficiency, caching, blurhash placeholders, progressive loading)**\n\nUse `expo-image` instead of React Native's `Image`. It provides memory-efficient caching, blurhash placeholders, progressive loading, and better performance for lists.\n\n**Incorrect: React Native Image**\n\n```tsx\nimport { Image } from 'react-native'\n\nfunction Avatar({ url }: { url: string }) {\n  return <Image source={{ uri: url }} style={styles.avatar} />\n}\n```\n\n**Correct: expo-image**\n\n```tsx\nimport { Image } from 'expo-image'\n\nfunction Avatar({ url }: { url: string }) {\n  return <Image source={{ uri: url }} style={styles.avatar} />\n}\n```\n\n**With blurhash placeholder:**\n\n```tsx\n<Image\n  source={{ uri: url }}\n  placeholder={{ blurhash: 'LGF5]+Yk^6#M@-5c,1J5@[or[Q6.' }}\n  contentFit=\"cover\"\n  transition={200}\n  style={styles.image}\n/>\n```\n\n**With priority and caching:**\n\n```tsx\n<Image\n  source={{ uri: url }}\n  priority=\"high\"\n  cachePolicy=\"memory-disk\"\n  style={styles.hero}\n/>\n```\n\n**Key props:**\n\n- `placeholder` — Blurhash or thumbnail while loading\n\n- `contentFit` — `cover`, `contain`, `fill`, `scale-down`\n\n- `transition` — Fade-in duration (ms)\n\n- `priority` — `low`, `normal`, `high`\n\n- `cachePolicy` — `memory`, `disk`, `memory-disk`, `none`\n\n- `recyclingKey` — Unique key for list recycling\n\nFor cross-platform (web + native), use `SolitoImage` from `solito/image` which uses `expo-image` under the hood.\n\nReference: [https://docs.expo.dev/versions/latest/sdk/image/](https://docs.expo.dev/versions/latest/sdk/image/)\n\n### 9.6 Use Galeria for Image Galleries and Lightbox\n\n**Impact: MEDIUM**\n\nFor image galleries with lightbox (tap to fullscreen), use `@nandorojo/galeria`.\n\nIt provides native shared element transitions with pinch-to-zoom, double-tap\n\nzoom, and pan-to-close. Works with any image component including `expo-image`.\n\n**Incorrect: custom modal implementation**\n\n```tsx\nfunction ImageGallery({ urls }: { urls: string[] }) {\n  const [selected, setSelected] = useState<string | null>(null)\n\n  return (\n    <>\n      {urls.map((url) => (\n        <Pressable key={url} onPress={() => setSelected(url)}>\n          <Image source={{ uri: url }} style={styles.thumbnail} />\n        </Pressable>\n      ))}\n      <Modal visible={!!selected} onRequestClose={() => setSelected(null)}>\n        <Image source={{ uri: selected! }} style={styles.fullscreen} />\n      </Modal>\n    </>\n  )\n}\n```\n\n**Correct: Galeria with expo-image**\n\n```tsx\nimport { Galeria } from '@nandorojo/galeria'\nimport { Image } from 'expo-image'\n\nfunction ImageGallery({ urls }: { urls: string[] }) {\n  return (\n    <Galeria urls={urls}>\n      {urls.map((url, index) => (\n        <Galeria.Image index={index} key={url}>\n          <Image source={{ uri: url }} style={styles.thumbnail} />\n        </Galeria.Image>\n      ))}\n    </Galeria>\n  )\n}\n```\n\n**Single image:**\n\n```tsx\nimport { Galeria } from '@nandorojo/galeria'\nimport { Image } from 'expo-image'\n\nfunction Avatar({ url }: { url: string }) {\n  return (\n    <Galeria urls={[url]}>\n      <Galeria.Image>\n        <Image source={{ uri: url }} style={styles.avatar} />\n      </Galeria.Image>\n    </Galeria>\n  )\n}\n```\n\n**With low-res thumbnails and high-res fullscreen:**\n\n```tsx\n<Galeria urls={highResUrls}>\n  {lowResUrls.map((url, index) => (\n    <Galeria.Image index={index} key={url}>\n      <Image source={{ uri: url }} style={styles.thumbnail} />\n    </Galeria.Image>\n  ))}\n</Galeria>\n```\n\n**With FlashList:**\n\n```tsx\n<Galeria urls={urls}>\n  <FlashList\n    data={urls}\n    renderItem={({ item, index }) => (\n      <Galeria.Image index={index}>\n        <Image source={{ uri: item }} style={styles.thumbnail} />\n      </Galeria.Image>\n    )}\n    numColumns={3}\n    estimatedItemSize={100}\n  />\n</Galeria>\n```\n\nWorks with `expo-image`, `SolitoImage`, `react-native` Image, or any image\n\ncomponent.\n\nReference: [https://github.com/nandorojo/galeria](https://github.com/nandorojo/galeria)\n\n### 9.7 Use Native Menus for Dropdowns and Context Menus\n\n**Impact: HIGH (native accessibility, platform-consistent UX)**\n\nUse native platform menus instead of custom JS implementations. Native menus\n\nprovide built-in accessibility, consistent platform UX, and better performance.\n\nUse [zeego](https://zeego.dev) for cross-platform native menus.\n\n**Incorrect: custom JS menu**\n\n```tsx\nimport { useState } from 'react'\nimport { View, Pressable, Text } from 'react-native'\n\nfunction MyMenu() {\n  const [open, setOpen] = useState(false)\n\n  return (\n    <View>\n      <Pressable onPress={() => setOpen(!open)}>\n        <Text>Open Menu</Text>\n      </Pressable>\n      {open && (\n        <View style={{ position: 'absolute', top: 40 }}>\n          <Pressable onPress={() => console.log('edit')}>\n            <Text>Edit</Text>\n          </Pressable>\n          <Pressable onPress={() => console.log('delete')}>\n            <Text>Delete</Text>\n          </Pressable>\n        </View>\n      )}\n    </View>\n  )\n}\n```\n\n**Correct: native menu with zeego**\n\n```tsx\nimport * as DropdownMenu from 'zeego/dropdown-menu'\n\nfunction MyMenu() {\n  return (\n    <DropdownMenu.Root>\n      <DropdownMenu.Trigger>\n        <Pressable>\n          <Text>Open Menu</Text>\n        </Pressable>\n      </DropdownMenu.Trigger>\n\n      <DropdownMenu.Content>\n        <DropdownMenu.Item key='edit' onSelect={() => console.log('edit')}>\n          <DropdownMenu.ItemTitle>Edit</DropdownMenu.ItemTitle>\n        </DropdownMenu.Item>\n\n        <DropdownMenu.Item\n          key='delete'\n          destructive\n          onSelect={() => console.log('delete')}\n        >\n          <DropdownMenu.ItemTitle>Delete</DropdownMenu.ItemTitle>\n        </DropdownMenu.Item>\n      </DropdownMenu.Content>\n    </DropdownMenu.Root>\n  )\n}\n```\n\n**Context menu: long-press**\n\n```tsx\nimport * as ContextMenu from 'zeego/context-menu'\n\nfunction MyContextMenu() {\n  return (\n    <ContextMenu.Root>\n      <ContextMenu.Trigger>\n        <View style={{ padding: 20 }}>\n          <Text>Long press me</Text>\n        </View>\n      </ContextMenu.Trigger>\n\n      <ContextMenu.Content>\n        <ContextMenu.Item key='copy' onSelect={() => console.log('copy')}>\n          <ContextMenu.ItemTitle>Copy</ContextMenu.ItemTitle>\n        </ContextMenu.Item>\n\n        <ContextMenu.Item key='paste' onSelect={() => console.log('paste')}>\n          <ContextMenu.ItemTitle>Paste</ContextMenu.ItemTitle>\n        </ContextMenu.Item>\n      </ContextMenu.Content>\n    </ContextMenu.Root>\n  )\n}\n```\n\n**Checkbox items:**\n\n```tsx\nimport * as DropdownMenu from 'zeego/dropdown-menu'\n\nfunction SettingsMenu() {\n  const [notifications, setNotifications] = useState(true)\n\n  return (\n    <DropdownMenu.Root>\n      <DropdownMenu.Trigger>\n        <Pressable>\n          <Text>Settings</Text>\n        </Pressable>\n      </DropdownMenu.Trigger>\n\n      <DropdownMenu.Content>\n        <DropdownMenu.CheckboxItem\n          key='notifications'\n          value={notifications}\n          onValueChange={() => setNotifications((prev) => !prev)}\n        >\n          <DropdownMenu.ItemIndicator />\n          <DropdownMenu.ItemTitle>Notifications</DropdownMenu.ItemTitle>\n        </DropdownMenu.CheckboxItem>\n      </DropdownMenu.Content>\n    </DropdownMenu.Root>\n  )\n}\n```\n\n**Submenus:**\n\n```tsx\nimport * as DropdownMenu from 'zeego/dropdown-menu'\n\nfunction MenuWithSubmenu() {\n  return (\n    <DropdownMenu.Root>\n      <DropdownMenu.Trigger>\n        <Pressable>\n          <Text>Options</Text>\n        </Pressable>\n      </DropdownMenu.Trigger>\n\n      <DropdownMenu.Content>\n        <DropdownMenu.Item key='home' onSelect={() => console.log('home')}>\n          <DropdownMenu.ItemTitle>Home</DropdownMenu.ItemTitle>\n        </DropdownMenu.Item>\n\n        <DropdownMenu.Sub>\n          <DropdownMenu.SubTrigger key='more'>\n            <DropdownMenu.ItemTitle>More Options</DropdownMenu.ItemTitle>\n          </DropdownMenu.SubTrigger>\n\n          <DropdownMenu.SubContent>\n            <DropdownMenu.Item key='settings'>\n              <DropdownMenu.ItemTitle>Settings</DropdownMenu.ItemTitle>\n            </DropdownMenu.Item>\n\n            <DropdownMenu.Item key='help'>\n              <DropdownMenu.ItemTitle>Help</DropdownMenu.ItemTitle>\n            </DropdownMenu.Item>\n          </DropdownMenu.SubContent>\n        </DropdownMenu.Sub>\n      </DropdownMenu.Content>\n    </DropdownMenu.Root>\n  )\n}\n```\n\nReference: [https://zeego.dev/components/dropdown-menu](https://zeego.dev/components/dropdown-menu)\n\n### 9.8 Use Native Modals Over JS-Based Bottom Sheets\n\n**Impact: HIGH (native performance, gestures, accessibility)**\n\nUse native `<Modal>` with `presentationStyle=\"formSheet\"` or React Navigation\n\nv7's native form sheet instead of JS-based bottom sheet libraries. Native modals\n\nhave built-in gestures, accessibility, and better performance. Rely on native UI\n\nfor low-level primitives.\n\n**Incorrect: JS-based bottom sheet**\n\n```tsx\nimport BottomSheet from 'custom-js-bottom-sheet'\n\nfunction MyScreen() {\n  const sheetRef = useRef<BottomSheet>(null)\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Button onPress={() => sheetRef.current?.expand()} title='Open' />\n      <BottomSheet ref={sheetRef} snapPoints={['50%', '90%']}>\n        <View>\n          <Text>Sheet content</Text>\n        </View>\n      </BottomSheet>\n    </View>\n  )\n}\n```\n\n**Correct: native Modal with formSheet**\n\n```tsx\nimport { Modal, View, Text, Button } from 'react-native'\n\nfunction MyScreen() {\n  const [visible, setVisible] = useState(false)\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Button onPress={() => setVisible(true)} title='Open' />\n      <Modal\n        visible={visible}\n        presentationStyle='formSheet'\n        animationType='slide'\n        onRequestClose={() => setVisible(false)}\n      >\n        <View>\n          <Text>Sheet content</Text>\n        </View>\n      </Modal>\n    </View>\n  )\n}\n```\n\n**Correct: React Navigation v7 native form sheet**\n\n```tsx\n// In your navigator\n<Stack.Screen\n  name='Details'\n  component={DetailsScreen}\n  options={{\n    presentation: 'formSheet',\n    sheetAllowedDetents: 'fitToContents',\n  }}\n/>\n```\n\nNative modals provide swipe-to-dismiss, proper keyboard avoidance, and\n\naccessibility out of the box.\n\n### 9.9 Use Pressable Instead of Touchable Components\n\n**Impact: LOW (modern API, more flexible)**\n\nNever use `TouchableOpacity` or `TouchableHighlight`. Use `Pressable` from\n\n`react-native` or `react-native-gesture-handler` instead.\n\n**Incorrect: legacy Touchable components**\n\n```tsx\nimport { TouchableOpacity } from 'react-native'\n\nfunction MyButton({ onPress }: { onPress: () => void }) {\n  return (\n    <TouchableOpacity onPress={onPress} activeOpacity={0.7}>\n      <Text>Press me</Text>\n    </TouchableOpacity>\n  )\n}\n```\n\n**Correct: Pressable**\n\n```tsx\nimport { Pressable } from 'react-native'\n\nfunction MyButton({ onPress }: { onPress: () => void }) {\n  return (\n    <Pressable onPress={onPress}>\n      <Text>Press me</Text>\n    </Pressable>\n  )\n}\n```\n\n**Correct: Pressable from gesture handler for lists**\n\n```tsx\nimport { Pressable } from 'react-native-gesture-handler'\n\nfunction ListItem({ onPress }: { onPress: () => void }) {\n  return (\n    <Pressable onPress={onPress}>\n      <Text>Item</Text>\n    </Pressable>\n  )\n}\n```\n\nUse `react-native-gesture-handler` Pressable inside scrollable lists for better\n\ngesture coordination, as long as you are using the ScrollView from\n\n`react-native-gesture-handler` as well.\n\n**For animated press states (scale, opacity changes):** Use `GestureDetector`\n\nwith Reanimated shared values instead of Pressable's style callback. See the\n\n`animation-gesture-detector-press` rule.\n\n---\n\n## 10. Design System\n\n**Impact: MEDIUM**\n\nArchitecture patterns for building maintainable component\nlibraries.\n\n### 10.1 Use Compound Components Over Polymorphic Children\n\n**Impact: MEDIUM (flexible composition, clearer API)**\n\nDon't create components that can accept a string if they aren't a text node. If\n\na component can receive a string child, it must be a dedicated `*Text`\n\ncomponent. For components like buttons, which can have both a View (or\n\nPressable) together with text, use compound components, such a `Button`,\n\n`ButtonText`, and `ButtonIcon`.\n\n**Incorrect: polymorphic children**\n\n```tsx\nimport { Pressable, Text } from 'react-native'\n\ntype ButtonProps = {\n  children: string | React.ReactNode\n  icon?: React.ReactNode\n}\n\nfunction Button({ children, icon }: ButtonProps) {\n  return (\n    <Pressable>\n      {icon}\n      {typeof children === 'string' ? <Text>{children}</Text> : children}\n    </Pressable>\n  )\n}\n\n// Usage is ambiguous\n<Button icon={<Icon />}>Save</Button>\n<Button><CustomText>Save</CustomText></Button>\n```\n\n**Correct: compound components**\n\n```tsx\nimport { Pressable, Text } from 'react-native'\n\nfunction Button({ children }: { children: React.ReactNode }) {\n  return <Pressable>{children}</Pressable>\n}\n\nfunction ButtonText({ children }: { children: React.ReactNode }) {\n  return <Text>{children}</Text>\n}\n\nfunction ButtonIcon({ children }: { children: React.ReactNode }) {\n  return <>{children}</>\n}\n\n// Usage is explicit and composable\n<Button>\n  <ButtonIcon><SaveIcon /></ButtonIcon>\n  <ButtonText>Save</ButtonText>\n</Button>\n\n<Button>\n  <ButtonText>Cancel</ButtonText>\n</Button>\n```\n\n---\n\n## 11. Monorepo\n\n**Impact: LOW**\n\nDependency management and native module configuration in\nmonorepos.\n\n### 11.1 Install Native Dependencies in App Directory\n\n**Impact: CRITICAL (required for autolinking to work)**\n\nIn a monorepo, packages with native code must be installed in the native app's\n\ndirectory directly. Autolinking only scans the app's `node_modules`—it won't\n\nfind native dependencies installed in other packages.\n\n**Incorrect: native dep in shared package only**\n\n```typescript\npackages/\n  ui/\n    package.json  # has react-native-reanimated\n  app/\n    package.json  # missing react-native-reanimated\n```\n\nAutolinking fails—native code not linked.\n\n**Correct: native dep in app directory**\n\n```json\n// packages/app/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"3.16.1\"\n  }\n}\n```\n\nEven if the shared package uses the native dependency, the app must also list it\n\nfor autolinking to detect and link the native code.\n\n### 11.2 Use Single Dependency Versions Across Monorepo\n\n**Impact: MEDIUM (avoids duplicate bundles, version conflicts)**\n\nUse a single version of each dependency across all packages in your monorepo.\n\nPrefer exact versions over ranges. Multiple versions cause duplicate code in\n\nbundles, runtime conflicts, and inconsistent behavior across packages.\n\nUse a tool like syncpack to enforce this. As a last resort, use yarn resolutions\n\nor npm overrides.\n\n**Incorrect: version ranges, multiple versions**\n\n```json\n// packages/app/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"^3.0.0\"\n  }\n}\n\n// packages/ui/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"^3.5.0\"\n  }\n}\n```\n\n**Correct: exact versions, single source of truth**\n\n```json\n// package.json (root)\n{\n  \"pnpm\": {\n    \"overrides\": {\n      \"react-native-reanimated\": \"3.16.1\"\n    }\n  }\n}\n\n// packages/app/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"3.16.1\"\n  }\n}\n\n// packages/ui/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"3.16.1\"\n  }\n}\n```\n\nUse your package manager's override/resolution feature to enforce versions at\n\nthe root. When adding dependencies, specify exact versions without `^` or `~`.\n\n---\n\n## 12. Third-Party Dependencies\n\n**Impact: LOW**\n\nWrapping and re-exporting third-party dependencies for\nmaintainability.\n\n### 12.1 Import from Design System Folder\n\n**Impact: LOW (enables global changes and easy refactoring)**\n\nRe-export dependencies from a design system folder. App code imports from there,\n\nnot directly from packages. This enables global changes and easy refactoring.\n\n**Incorrect: imports directly from package**\n\n```tsx\nimport { View, Text } from 'react-native'\nimport { Button } from '@ui/button'\n\nfunction Profile() {\n  return (\n    <View>\n      <Text>Hello</Text>\n      <Button>Save</Button>\n    </View>\n  )\n}\n```\n\n**Correct: imports from design system**\n\n```tsx\nimport { View } from '@/components/view'\nimport { Text } from '@/components/text'\nimport { Button } from '@/components/button'\n\nfunction Profile() {\n  return (\n    <View>\n      <Text>Hello</Text>\n      <Button>Save</Button>\n    </View>\n  )\n}\n```\n\nStart by simply re-exporting. Customize later without changing app code.\n\n---\n\n## 13. JavaScript\n\n**Impact: LOW**\n\nMicro-optimizations like hoisting expensive object creation.\n\n### 13.1 Hoist Intl Formatter Creation\n\n**Impact: LOW-MEDIUM (avoids expensive object recreation)**\n\nDon't create `Intl.DateTimeFormat`, `Intl.NumberFormat`, or\n\n`Intl.RelativeTimeFormat` inside render or loops. These are expensive to\n\ninstantiate. Hoist to module scope when the locale/options are static.\n\n**Incorrect: new formatter every render**\n\n```tsx\nfunction Price({ amount }: { amount: number }) {\n  const formatter = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n  })\n  return <Text>{formatter.format(amount)}</Text>\n}\n```\n\n**Correct: hoisted to module scope**\n\n```tsx\nconst currencyFormatter = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n})\n\nfunction Price({ amount }: { amount: number }) {\n  return <Text>{currencyFormatter.format(amount)}</Text>\n}\n```\n\n**For dynamic locales, memoize:**\n\n```tsx\nconst dateFormatter = useMemo(\n  () => new Intl.DateTimeFormat(locale, { dateStyle: 'medium' }),\n  [locale]\n)\n```\n\n**Common formatters to hoist:**\n\n```tsx\n// Module-level formatters\nconst dateFormatter = new Intl.DateTimeFormat('en-US', { dateStyle: 'medium' })\nconst timeFormatter = new Intl.DateTimeFormat('en-US', { timeStyle: 'short' })\nconst percentFormatter = new Intl.NumberFormat('en-US', { style: 'percent' })\nconst relativeFormatter = new Intl.RelativeTimeFormat('en-US', {\n  numeric: 'auto',\n})\n```\n\nCreating `Intl` objects is significantly more expensive than `RegExp` or plain\n\nobjects—each instantiation parses locale data and builds internal lookup tables.\n\n---\n\n## 14. Fonts\n\n**Impact: LOW**\n\nNative font loading for improved performance.\n\n### 14.1 Load fonts natively at build time\n\n**Impact: LOW (fonts available at launch, no async loading)**\n\nUse the `expo-font` config plugin to embed fonts at build time instead of\n\n`useFonts` or `Font.loadAsync`. Embedded fonts are more efficient.\n\n[Expo Font Documentation](https://docs.expo.dev/versions/latest/sdk/font/)\n\n**Incorrect: async font loading**\n\n```tsx\nimport { useFonts } from 'expo-font'\nimport { Text, View } from 'react-native'\n\nfunction App() {\n  const [fontsLoaded] = useFonts({\n    'Geist-Bold': require('./assets/fonts/Geist-Bold.otf'),\n  })\n\n  if (!fontsLoaded) {\n    return null\n  }\n\n  return (\n    <View>\n      <Text style={{ fontFamily: 'Geist-Bold' }}>Hello</Text>\n    </View>\n  )\n}\n```\n\n**Correct: config plugin, fonts embedded at build**\n\n```tsx\nimport { Text, View } from 'react-native'\n\nfunction App() {\n  // No loading state needed—font is already available\n  return (\n    <View>\n      <Text style={{ fontFamily: 'Geist-Bold' }}>Hello</Text>\n    </View>\n  )\n}\n```\n\nAfter adding fonts to the config plugin, run `npx expo prebuild` and rebuild the\n\nnative app.\n\n---\n\n## References\n\n1. [https://react.dev](https://react.dev)\n2. [https://reactnative.dev](https://reactnative.dev)\n3. [https://docs.swmansion.com/react-native-reanimated](https://docs.swmansion.com/react-native-reanimated)\n4. [https://docs.swmansion.com/react-native-gesture-handler](https://docs.swmansion.com/react-native-gesture-handler)\n5. [https://docs.expo.dev](https://docs.expo.dev)\n6. [https://legendapp.com/open-source/legend-list](https://legendapp.com/open-source/legend-list)\n7. [https://github.com/nandorojo/galeria](https://github.com/nandorojo/galeria)\n8. [https://zeego.dev](https://zeego.dev)\n",
        "skills/react-native/SKILL.md": "---\nname: react-native\ndescription: Complete React Native and Expo optimization guide combining Callstack profiling with Vercel code patterns. Covers FPS, TTI, bundle size, memory, lists, animations, state, UI, and React Compiler. Use for any React Native performance, debugging, or best practices task.\nlicense: MIT\nmetadata:\n  author: Callstack + Vercel\n  version: '1.0.0'\n  tags: react-native, expo, performance, optimization, patterns\n---\n\n# React Native Complete Guide\n\nThe ultimate React Native optimization guide combining:\n- **Callstack** - Profiling, measurement, and native optimization (27 references)\n- **Vercel** - Code patterns, UI, and best practices (36 rules)\n\n## When to Apply\n\nReference these guidelines when:\n- Debugging slow/janky UI or animations\n- Optimizing list and scroll performance\n- Investigating memory leaks (JS or native)\n- Optimizing app startup time (TTI)\n- Reducing bundle or app size\n- Implementing animations with Reanimated\n- Building UI with native components\n- Working with React Compiler\n- Structuring monorepo projects\n\n## Priority-Ordered Guidelines\n\n| Priority | Category | Impact | Source |\n|----------|----------|--------|--------|\n| 1 | Core Rendering | CRITICAL | Vercel |\n| 2 | List Performance | CRITICAL | Both |\n| 3 | FPS & Re-renders | CRITICAL | Callstack |\n| 4 | Bundle Size | CRITICAL | Callstack |\n| 5 | Animation | HIGH | Both |\n| 6 | Navigation | HIGH | Vercel |\n| 7 | TTI Optimization | HIGH | Callstack |\n| 8 | UI Patterns | HIGH | Vercel |\n| 9 | Native Performance | HIGH | Callstack |\n| 10 | State Management | MEDIUM | Vercel |\n| 11 | React Compiler | MEDIUM | Both |\n| 12 | Memory Management | MEDIUM | Callstack |\n| 13 | Monorepo | MEDIUM | Vercel |\n\n---\n\n## Quick Reference: Code Patterns (Vercel)\n\n### Core Rendering (CRITICAL)\n- `rendering-no-falsy-and` - Never use && with falsy values (crashes app)\n- `rendering-text-in-text-component` - Wrap strings in Text components\n\n### List Performance (CRITICAL)\n- `list-performance-virtualize` - Use FlashList/LegendList for any list\n- `list-performance-item-memo` - Memoize list item components\n- `list-performance-callbacks` - Stabilize callback references\n- `list-performance-inline-objects` - Avoid inline style objects\n- `list-performance-function-references` - Extract functions outside render\n- `list-performance-images` - Use compressed, appropriately-sized images\n- `list-performance-item-expensive` - Move expensive work outside items\n- `list-performance-item-types` - Use item types for heterogeneous lists\n\n### Animation (HIGH)\n- `animation-gpu-properties` - Animate only transform and opacity\n- `animation-derived-value` - Use useDerivedValue for computed animations\n- `animation-gesture-detector-press` - Use Gesture.Tap for press animations\n\n### Navigation (HIGH)\n- `navigation-native-navigators` - Use native stack/tabs over JS navigators\n\n### UI Patterns (HIGH)\n- `ui-expo-image` - Use expo-image for all images\n- `ui-image-gallery` - Use Galeria for lightboxes\n- `ui-pressable` - Use Pressable over TouchableOpacity\n- `ui-safe-area-scroll` - Use contentInsetAdjustmentBehavior\n- `ui-scrollview-content-inset` - Use contentInset for dynamic spacing\n- `ui-menus` - Use native context menus (zeego)\n- `ui-native-modals` - Use native modals over JS bottom sheets\n- `ui-measure-views` - Use onLayout, not measure()\n- `ui-styling` - Use StyleSheet.create, gap, borderCurve\n\n### State Management (MEDIUM)\n- `react-state-minimize` - Derive values, minimize state\n- `react-state-dispatcher` - Use dispatch updaters\n- `react-state-fallback` - Use fallback pattern for reactive defaults\n- `state-ground-truth` - State represents truth, derive visuals\n\n### React Compiler (MEDIUM)\n- `react-compiler-destructure-functions` - Destructure functions early\n- `react-compiler-reanimated-shared-values` - Use .get()/.set() not .value\n\n### Monorepo (MEDIUM)\n- `monorepo-native-deps-in-app` - Install native deps in app package\n- `monorepo-single-dependency-versions` - Single versions across packages\n\n### Configuration (LOW)\n- `fonts-config-plugin` - Load fonts at build time\n- `imports-design-system-folder` - Re-export from design system\n- `js-hoist-intl` - Hoist Intl formatter creation\n\n---\n\n## Quick Reference: Profiling & Measurement (Callstack)\n\n### FPS & Re-renders (CRITICAL)\n```bash\n# Open React Native DevTools\n# Press 'j' in Metro, or shake device → \"Open DevTools\"\n```\n- `js-profile-react.md` - React DevTools profiling\n- `js-measure-fps.md` - FPS monitoring\n- `js-react-compiler.md` - Automatic memoization\n- `js-atomic-state.md` - Jotai/Zustand patterns\n- `js-concurrent-react.md` - useDeferredValue, useTransition\n\n### Bundle Size (CRITICAL)\n```bash\nnpx react-native bundle \\\n  --entry-file index.js \\\n  --bundle-output output.js \\\n  --platform ios \\\n  --sourcemap-output output.js.map \\\n  --dev false --minify true\n\nnpx source-map-explorer output.js --no-border-checks\n```\n- `bundle-barrel-exports.md` - Avoid barrel imports\n- `bundle-analyze-js.md` - JS bundle visualization\n- `bundle-tree-shaking.md` - Dead code elimination\n- `bundle-r8-android.md` - Android code shrinking\n- `bundle-hermes-mmap.md` - Disable bundle compression\n\n### TTI Optimization (HIGH)\n- `native-measure-tti.md` - TTI measurement setup\n- `bundle-hermes-mmap.md` - Enable Hermes mmap\n- Defer non-critical work with `InteractionManager`\n\n### Native Performance (HIGH)\n- iOS: Xcode Instruments → Time Profiler\n- Android: Android Studio → CPU Profiler\n- `native-turbo-modules.md` - Building fast native modules\n- `native-threading-model.md` - Turbo Module threads\n- `native-profiling.md` - Platform profiling guides\n\n### Memory Management (MEDIUM)\n- `js-memory-leaks.md` - JS memory leak hunting\n- `native-memory-leaks.md` - Native memory leaks\n- `native-memory-patterns.md` - C++/Swift/Kotlin memory\n\n### Animations (MEDIUM)\n- `js-animations-reanimated.md` - Reanimated worklets\n\n---\n\n## Problem → Solution Mapping\n\n| Problem | Vercel Rules | Callstack References |\n|---------|--------------|---------------------|\n| App crashes | `rendering-no-falsy-and`, `rendering-text-in-text-component` | - |\n| List scroll jank | `list-performance-*` | `js-lists-flatlist-flashlist.md` |\n| Animation drops frames | `animation-gpu-properties` | `js-animations-reanimated.md` |\n| Too many re-renders | `react-state-minimize` | `js-profile-react.md`, `js-react-compiler.md` |\n| Slow startup (TTI) | - | `native-measure-tti.md`, `bundle-hermes-mmap.md` |\n| Large app size | - | `bundle-analyze-app.md`, `bundle-r8-android.md` |\n| Memory growing | - | `js-memory-leaks.md`, `native-memory-leaks.md` |\n| TextInput lag | - | `js-uncontrolled-components.md` |\n| Native module slow | - | `native-turbo-modules.md` |\n\n---\n\n## File Structure\n\n```\nreact-native/\n├── SKILL.md          # This file\n├── AGENTS.md         # Full 74KB compiled Vercel guide\n├── rules/            # 36 individual Vercel rule files\n│   ├── list-performance-*.md\n│   ├── animation-*.md\n│   ├── ui-*.md\n│   └── ...\n└── references/       # 27 Callstack reference files\n    ├── js-*.md\n    ├── native-*.md\n    ├── bundle-*.md\n    └── images/\n```\n\n## Attribution\n\nCombined from:\n- \"The Ultimate Guide to React Native Optimization\" by Callstack\n- React Native Skills by Vercel\n",
        "skills/react-native/references/bundle-analyze-app.md": "---\ntitle: Analyze App Bundle Size\nimpact: HIGH\ntags: app-size, ruler, emerge-tools, thinning\n---\n\n# Skill: Analyze App Bundle Size\n\nMeasure iOS and Android app download/install sizes using Ruler, App Store Connect, and Emerge Tools.\n\n## Quick Command\n\n```bash\n# Android (Ruler)\ncd android && ./gradlew analyzeReleaseBundle\n\n# iOS (Xcode export with thinning)\ncd ios && xcodebuild -exportArchive \\\n  -archivePath MyApp.xcarchive \\\n  -exportPath ./export \\\n  -exportOptionsPlist ExportOptions.plist\n# Check: App Thinning Size Report.txt\n```\n\n## When to Use\n\n- App download size is too large\n- Users complain about storage usage\n- App approaching store limits\n- Comparing releases for size regression\n\n> **Note**: This skill involves interpreting visual size reports (Ruler, Emerge Tools X-Ray). AI agents cannot yet process screenshots autonomously. Use this as a guide while reviewing the reports manually, or await MCP-based visual feedback integration (see roadmap).\n\n## Key Metrics\n\n| Metric | Description | User Impact |\n|--------|-------------|-------------|\n| Download Size | Compressed, transferred over network | Download time, data usage |\n| Install Size | Uncompressed, on device storage | Storage space |\n\n**Google finding**: Every 6 MB increase reduces installs by 1%.\n\n## Android: Ruler (Spotify)\n\n### Setup\n\nAdd to `android/build.gradle`:\n\n```groovy\nbuildscript {\n    dependencies {\n        classpath(\"com.spotify.ruler:ruler-gradle-plugin:2.0.0-beta-3\")\n    }\n}\n```\n\nAdd to `android/app/build.gradle`:\n\n```groovy\napply plugin: \"com.spotify.ruler\"\n\nruler {\n    abi.set(\"arm64-v8a\")  // Target architecture\n    locale.set(\"en\")\n    screenDensity.set(480)\n    sdkVersion.set(34)\n}\n```\n\n### Analyze\n\n```bash\ncd android\n./gradlew analyzeReleaseBundle\n```\n\nOpens HTML report with:\n- Download size\n- Install size\n- Component breakdown (biggest → smallest)\n\n### CI Size Validation\n\n```groovy\nruler {\n    verification {\n        downloadSizeThreshold = 20 * 1024 * 1024  // 20 MB\n        installSizeThreshold = 50 * 1024 * 1024   // 50 MB\n    }\n}\n```\n\nBuild fails if thresholds exceeded.\n\n## iOS: Xcode App Thinning\n\n### Via App Store Connect (Most Accurate)\n\nAfter uploading to TestFlight:\n1. Open App Store Connect\n2. Go to your build\n3. View size table by device variant\n\n**Note**: TestFlight builds include debug data, App Store builds slightly larger due to DRM.\n\n### Via Xcode Export\n\n1. Archive app: **Product → Archive**\n2. In Organizer, click **Distribute App**\n3. Select **Custom**\n4. Choose **App Thinning: All compatible device variants**\n\nOr in `ExportOptions.plist`:\n\n```xml\n<key>thinning</key>\n<string>&lt;thin-for-all-variants&gt;</string>\n```\n\n### Output\n\nCreates folder with:\n- **Universal IPA**: All variants combined\n- **Thinned IPAs**: One per device variant\n- **App Thinning Size Report.txt**:\n\n```\nVariant: SampleApp-<UUID>.ipa\nApp + On Demand Resources size: 3.5 MB compressed, 10.6 MB uncompressed\nApp size: 3.5 MB compressed, 10.6 MB uncompressed\n```\n\n- Compressed = Download size\n- Uncompressed = Install size\n\n## Emerge Tools (Cross-Platform)\n\nThird-party service with visual analysis.\n\n### Upload\n\nUpload IPA, APK, or AAB through their web interface or CI integration.\n\n### Features\n\n![Emerge Tools X-Ray for iOS](images/emerge-xray-ios.png)\n\n- **X-Ray**: Treemap visualization (like source-map-explorer for binaries)\n  - Shows Frameworks (hermes.framework), Mach-O sections (TEXT, DATA), etc.\n  - Color-coded: Binaries, Localizations, Fonts, Asset Catalogs, Videos, CoreML Models\n  - Visible components: `main.jsbundle` (JS code), RCT modules, DYLD sections\n- **Breakdown**: Component-by-component size\n- **Insights**: Automated suggestions (use with caution)\n\n**Caution**: Some suggestions may not apply to React Native (e.g., \"remove Hermes\").\n\n## Size Comparison\n\n| Tool | Platform | Accuracy | CI Integration |\n|------|----------|----------|----------------|\n| Ruler | Android | High | Yes (Gradle) |\n| App Store Connect | iOS | Highest | No |\n| Xcode Export | iOS | High | Yes (xcodebuild) |\n| Emerge Tools | Both | High | Yes (API) |\n\n## Typical React Native App Sizes\n\n| Component | Approximate Size |\n|-----------|------------------|\n| Hermes engine | ~2-3 MB |\n| React Native core | ~3-5 MB |\n| JavaScript bundle | 1-10 MB |\n| Assets (images, etc.) | Varies |\n\n**Baseline empty app**: ~6-10 MB download\n\n## Optimization Impact Example\n\n| Optimization | Size Reduction |\n|--------------|----------------|\n| Enable R8 (Android) | ~30% |\n| Remove unused polyfills | 400+ KB |\n| Asset catalog (iOS) | 10-50% of assets |\n| Tree shaking | 10-15% |\n\n## Quick Commands\n\n```bash\n# Android release bundle size\ncd android && ./gradlew bundleRelease\n# Check: android/app/build/outputs/bundle/release/\n\n# iOS archive\ncd ios && xcodebuild -workspace ios/MyApp.xcworkspace \\\n  -scheme MyApp \\\n  -configuration Release \\\n  -archivePath MyApp.xcarchive \\\n  archive\n\n# Export with thinning report\ncd ios && xcodebuild -exportArchive \\\n  -archivePath MyApp.xcarchive \\\n  -exportPath ./export \\\n  -exportOptionsPlist ExportOptions.plist\n```\n\n## Related Skills\n\n- [bundle-r8-android.md](./bundle-r8-android.md) - Reduce Android size\n- [bundle-native-assets.md](./bundle-native-assets.md) - Optimize asset delivery\n- [bundle-analyze-js.md](./bundle-analyze-js.md) - JS bundle analysis\n",
        "skills/react-native/references/bundle-analyze-js.md": "---\ntitle: Analyze JS Bundle Size\nimpact: CRITICAL\ntags: bundle, analysis, source-map-explorer, expo-atlas\n---\n\n# Skill: Analyze JS Bundle Size\n\nUse source-map-explorer and Expo Atlas to visualize what's in your JavaScript bundle.\n\n## Quick Command\n\n```bash\n# React Native CLI\nnpx react-native bundle \\\n  --entry-file index.js \\\n  --bundle-output output.js \\\n  --platform ios \\\n  --sourcemap-output output.js.map \\\n  --dev false --minify true && \\\nnpx source-map-explorer output.js --no-border-checks\n\n# Expo\nEXPO_UNSTABLE_ATLAS=true npx expo export --platform ios && npx expo-atlas\n```\n\n## When to Use\n\n- JS bundle seems too large\n- Want to identify heavy dependencies\n- Investigating startup time issues\n- Before/after optimization comparison\n\n> **Note**: This skill involves interpreting visual treemap output (source-map-explorer, Expo Atlas). AI agents cannot yet process screenshots autonomously. Use this as a guide while reviewing the visualization manually, or await MCP-based visual feedback integration (see roadmap).\n\n## Understanding Hermes Bytecode\n\nModern React Native (0.70+) uses Hermes bytecode, not raw JavaScript:\n- Skips parsing at runtime\n- Still benefits from smaller bundles\n- Heavy imports still execute on startup\n\n**Impact of bundle size:**\n- Larger bytecode = longer download from store\n- More imports on init path = slower TTI\n\n## Method 1: source-map-explorer\n\n### Generate Bundle with Source Map\n\n**React Native CLI:**\n\n```bash\nnpx react-native bundle \\\n  --entry-file index.js \\\n  --bundle-output output.js \\\n  --platform ios \\\n  --sourcemap-output output.js.map \\\n  --dev false \\\n  --minify true\n```\n\n**Expo (SDK 51+):**\n\n```bash\nnpx expo export --platform ios --source-maps --output-dir dist\n# Bundle at: dist/ios/_expo/static/js/ios/*.js\n# Source map at: dist/ios/_expo/static/js/ios/*.map\n```\n\n### Analyze\n\n```bash\nnpx source-map-explorer output.js --no-border-checks\n```\n\n**Note**: `--no-border-checks` needed due to Metro's non-standard source maps.\n\nOpens browser with treemap visualization:\n\n![Bundle Treemap from source-map-explorer](images/bundle-treemap-source-map-explorer.png)\n\nThe treemap shows:\n- **Hierarchy**: `node_modules/` → `react-native/` → `Libraries/` → individual files\n- **Size**: Box area proportional to file size (KB shown in labels)\n- **Major components visible**: \n  - `react-native` (724.18 KB, 80.5%)\n  - `Renderer` (208.44 KB) - ReactNativeRenderer-prod.js, ReactFabric-prod.js\n  - `Components` (125.29 KB) - Touchable, ScrollView, etc.\n  - `Animated` (79.48 KB) - Animation system\n  - `virtualized-lists` (57.57 KB) - FlatList internals\n\nClick on any section to drill down into that directory.\n\n**Limitation**: May lose ~30% info due to mapping issues.\n\n## Method 2: Expo Atlas\n\nMore accurate for Expo projects (or with workaround for bare RN).\n\n### For Expo Projects\n\n```bash\n# Start with Atlas enabled\nEXPO_UNSTABLE_ATLAS=true npx expo start --no-dev\n\n# Or export\nEXPO_UNSTABLE_ATLAS=true npx expo export\n```\n\nThen launch UI:\n\n```bash\nnpx expo-atlas\n```\n\n![Expo Atlas Treemap](images/expo-atlas-treemap.png)\n\nExpo Atlas provides more accurate visualization for Expo projects, with similar treemap interface showing module sizes and dependencies.\n\n### For Non-Expo Projects\n\nUse `expo-atlas-without-expo` package.\n\n## Method 3: Re.Pack Bundle Analysis (Webpack/Rspack)\n\nIf using Re.Pack:\n\n### webpack-bundle-analyzer\n\n```bash\nrspack build --analyze\n```\n\n### bundle-stats / statoscope\n\n```bash\n# Generate stats\nnpx react-native bundle \\\n  --platform android \\\n  --entry-file index.js \\\n  --dev false \\\n  --minify true \\\n  --json stats.json\n\n# Analyze\nnpx bundle-stats --html --json stats.json\n```\n\n### Rsdoctor\n\n```javascript\n// rspack.config.js\nconst { RsdoctorRspackPlugin } = require('@rsdoctor/rspack-plugin');\n\nmodule.exports = {\n  plugins: [\n    process.env.RSDOCTOR && new RsdoctorRspackPlugin(),\n  ].filter(Boolean),\n};\n```\n\nRun with:\n\n```bash\nRSDOCTOR=true npx react-native start\n```\n\n## What to Look For\n\n### Red Flags\n\n| Finding | Problem | Solution |\n|---------|---------|----------|\n| Entire library imported | Barrel exports | Use direct imports |\n| Duplicate packages | Multiple versions | Dedupe in package.json |\n| Dev dependencies in bundle | Incorrect imports | Check conditional imports |\n| Large polyfills | Unnecessary for Hermes | Remove (see native-sdks-over-polyfills.md) |\n| Moment.js with locales | Bloated date library | Switch to date-fns or dayjs |\n\n### Common Offenders\n\n- **Lodash full import**: Use `lodash-es` or specific imports\n- **Moment.js**: Replace with `date-fns` or `dayjs`\n- **Intl polyfills**: Check Hermes support\n- **AWS SDK**: Import specific services only\n\n## Code Examples\n\n### Identify Barrel Import Impact\n\n```tsx\n// BAD: Imports entire library through barrel\nimport { format } from 'date-fns';\n\n// In bundle: All of date-fns loaded\n\n// GOOD: Direct import\nimport format from 'date-fns/format';\n\n// In bundle: Only format function\n```\n\n## Comparing Bundles\n\n### source-map-explorer\n\n```bash\n# Generate baseline\nnpx react-native bundle ... --bundle-output baseline.js --sourcemap-output baseline.js.map\n\n# Make changes, generate new bundle\nnpx react-native bundle ... --bundle-output current.js --sourcemap-output current.js.map\n\n# Compare manually in browser\n```\n\n### Re.Pack (automated)\n\n```bash\nnpx bundle-stats compare baseline-stats.json current-stats.json\n```\n\n## Quick Commands\n\n**React Native CLI:**\n\n```bash\n# iOS bundle analysis\nnpx react-native bundle \\\n  --entry-file index.js \\\n  --bundle-output ios-bundle.js \\\n  --platform ios \\\n  --sourcemap-output ios-bundle.js.map \\\n  --dev false \\\n  --minify true && \\\nnpx source-map-explorer ios-bundle.js --no-border-checks\n\n# Android bundle analysis  \nnpx react-native bundle \\\n  --entry-file index.js \\\n  --bundle-output android-bundle.js \\\n  --platform android \\\n  --sourcemap-output android-bundle.js.map \\\n  --dev false \\\n  --minify true && \\\nnpx source-map-explorer android-bundle.js --no-border-checks\n```\n\n**Expo:**\n\n```bash\n# Use Expo Atlas (recommended for Expo projects)\nEXPO_UNSTABLE_ATLAS=true npx expo export --platform ios\nnpx expo-atlas\n```\n\n## Related Skills\n\n- [bundle-barrel-exports.md](./bundle-barrel-exports.md) - Fix barrel import issues\n- [bundle-tree-shaking.md](./bundle-tree-shaking.md) - Enable dead code elimination\n- [bundle-library-size.md](./bundle-library-size.md) - Check library sizes before adding\n",
        "skills/react-native/references/bundle-barrel-exports.md": "---\ntitle: Avoid Barrel Exports\nimpact: CRITICAL\ntags: bundle, imports, barrel, tree-shaking\n---\n\n# Skill: Avoid Barrel Exports\n\nRefactor barrel imports (index files) to reduce bundle size and improve startup time.\n\n## Quick Pattern\n\n**Incorrect:**\n\n```tsx\nimport { Button } from './components';\n// Loads ALL exports from components/index.ts\n```\n\n**Correct:**\n\n```tsx\nimport Button from './components/Button';\n// Loads only Button\n```\n\n## When to Use\n\n- Bundle contains unused code from libraries\n- Circular dependency warnings in Metro\n- Hot Module Replacement (HMR) breaks frequently\n- TTI is slow due to module evaluation\n\n## What Are Barrel Exports?\n\n```tsx\n// components/index.ts (barrel file)\nexport { Button } from './Button';\nexport { Card } from './Card';\nexport { Modal } from './Modal';\nexport { Sidebar } from './Sidebar';\n\n// Usage (barrel import)\nimport { Button } from './components';\n```\n\n## Problems with Barrel Imports\n\n### 1. Bundle Size Overhead\n\nMetro includes **all exports** even if you use one:\n\n```tsx\n// Only need Button, but entire barrel is bundled\nimport { Button } from './components';\n// Card, Modal, Sidebar also included!\n```\n\n### 2. Runtime Overhead\n\nAll modules evaluate before returning your import:\n\n```tsx\nimport { Button } from './components';\n// JavaScript must evaluate:\n// - Button.tsx\n// - Card.tsx\n// - Modal.tsx  \n// - Sidebar.tsx\n// Even though you only use Button\n```\n\n### 3. Circular Dependencies\n\nBarrel files make cycles easier to create accidentally:\n\n```\nWarning: Require cycle:\n  components/index.ts -> Button.tsx -> utils/index.ts -> components/index.ts\n```\n\nBreaks HMR, causes unpredictable behavior.\n\n## Solution 1: Direct Imports\n\nReplace barrel imports with direct paths:\n\n```tsx\n// BEFORE: Barrel import\nimport { Button, Card } from './components';\n\n// AFTER: Direct imports\nimport Button from './components/Button';\nimport Card from './components/Card';\n```\n\n### Enforce with ESLint\n\n```bash\nnpm install -D eslint-plugin-no-barrel-files\n```\n\n```javascript\n// eslint.config.js\nimport noBarrelFiles from 'eslint-plugin-no-barrel-files';\n\nexport default [\n  {\n    plugins: { 'no-barrel-files': noBarrelFiles },\n    rules: {\n      'no-barrel-files/no-barrel-files': 'error',\n    },\n  },\n];\n```\n\n## Solution 2: Tree Shaking (Automatic)\n\nEnable tree shaking to automatically remove unused barrel exports.\n\n### Expo SDK 52+\n\n```tsx\n// metro.config.js\nconst { getDefaultConfig } = require('expo/metro-config');\nconst config = getDefaultConfig(__dirname);\n\nconfig.transformer.getTransformOptions = async () => ({\n  transform: {\n    experimentalImportSupport: true,\n  },\n});\n\nmodule.exports = config;\n```\n\n```bash\n# .env\nEXPO_UNSTABLE_METRO_OPTIMIZE_GRAPH=1\nEXPO_UNSTABLE_TREE_SHAKING=1\n```\n\n### metro-serializer-esbuild\n\n```bash\nnpm install @rnx-kit/metro-serializer-esbuild\n```\n\n### Re.Pack (Webpack/Rspack)\n\nTree shaking built-in.\n\n## Real-World Example: date-fns\n\n```tsx\n// BAD: Imports entire library\nimport { format, addDays, isToday } from 'date-fns';\n\n// GOOD: Direct imports\nimport format from 'date-fns/format';\nimport addDays from 'date-fns/addDays';\nimport isToday from 'date-fns/isToday';\n```\n\n## Library-Specific Solutions\n\nSome libraries provide Babel plugins:\n\n### React Native Paper\n\n```javascript\n// babel.config.js\nmodule.exports = {\n  plugins: [\n    'react-native-paper/babel',  // Auto-transforms imports\n  ],\n};\n```\n\nTransforms:\n```tsx\nimport { Button } from 'react-native-paper';\n// Into:\nimport Button from 'react-native-paper/lib/module/components/Button';\n```\n\n## Refactoring Strategy\n\n### Step 1: Identify Barrel Files\n\nLook for `index.ts` files with multiple exports:\n\n```bash\ngrep -r \"export \\* from\" src/\ngrep -r \"export { .* } from\" src/\n```\n\n### Step 2: Update Imports\n\n```tsx\n// Find all usages\n// VS Code: Cmd+Shift+F for \"from './components'\"\n\n// Replace each with direct import\nimport Button from './components/Button';\n```\n\n### Step 3: (Optional) Keep Barrel for External API\n\nIf your package is consumed by others:\n\n```tsx\n// Keep index.ts for package API\n// components/index.ts\nexport { Button } from './Button';\n\n// Internal code uses direct imports\n// src/screens/Home.tsx\nimport Button from '../components/Button';\n```\n\n## Migration Script Example\n\n```bash\n# Use codemod or search-replace\n# Find: import { (\\w+) } from '\\.\\/components';\n# Replace: import $1 from './components/$1';\n```\n\n## Verification\n\nAfter refactoring:\n\n1. Run bundle analysis (see [bundle-analyze-js.md](./bundle-analyze-js.md))\n2. Compare sizes before/after\n3. Check for circular dependency warnings\n\n## Common Pitfalls\n\n- **Breaking external consumers**: If publishing a library, keep barrel for public API\n- **IDE auto-imports**: Configure IDE to prefer direct imports\n- **Inconsistent patterns**: Enforce with ESLint across team\n\n## Related Skills\n\n- [bundle-analyze-js.md](./bundle-analyze-js.md) - Verify impact\n- [bundle-tree-shaking.md](./bundle-tree-shaking.md) - Automatic solution\n- [bundle-library-size.md](./bundle-library-size.md) - Check library patterns\n",
        "skills/react-native/references/bundle-code-splitting.md": "---\ntitle: Remote Code Loading\nimpact: MEDIUM\ntags: code-splitting, repack, lazy-loading, chunks\n---\n\n# Skill: Remote Code Loading\n\nSet up code splitting with Re.Pack for on-demand bundle loading.\n\n## Quick Pattern\n\n**Before (static import):**\n\n```jsx\nimport SettingsScreen from './screens/SettingsScreen';\n```\n\n**After (lazy loaded chunk):**\n\n```jsx\nconst SettingsScreen = React.lazy(() =>\n  import(/* webpackChunkName: \"settings\" */ './screens/SettingsScreen')\n);\n\n<Suspense fallback={<Loading />}>\n  <SettingsScreen />\n</Suspense>\n```\n\n## When to Use\n\nConsider code splitting when:\n- **Not using Hermes** (JSC/V8 benefits more)\n- App size exceeds 200 MB (Play Store limit)\n- Building micro-frontend architecture\n- Loading features based on user permissions\n- Other optimizations exhausted\n\n**Note**: Hermes already uses memory mapping for efficient bundle reading. Benefits of code splitting are minimal with Hermes or even counterproductive in some cases.\n\n## Prerequisites\n\n- Re.Pack installed (replaces Metro)\n\n```bash\nnpx @callstack/repack-init\n```\n\n## Step-by-Step Instructions\n\n### 1. Initialize Re.Pack\n\n```bash\nnpx @callstack/repack-init\n```\n\nFollow prompts to migrate from Metro. Check [migration guide](https://re-pack.dev/docs/getting-started/quick-start).\n\n### 2. Create Split Point with React.lazy\n\n```tsx\n// BEFORE: Static import\nimport SettingsScreen from './screens/SettingsScreen';\n\n// AFTER: Dynamic import (creates split point)\nconst SettingsScreen = React.lazy(() =>\n  import(/* webpackChunkName: \"settings\" */ './screens/SettingsScreen')\n);\n```\n\n### 3. Wrap with Suspense\n\n```tsx\nimport React, { Suspense } from 'react';\n\nconst App = () => {\n  return (\n    <Suspense fallback={<LoadingSpinner />}>\n      <SettingsScreen />\n    </Suspense>\n  );\n};\n```\n\n### 4. Configure Chunk Loading\n\n```tsx\n// index.js (before AppRegistry)\nimport { ScriptManager, Script } from '@callstack/repack/client';\n\nScriptManager.shared.addResolver((scriptId) => ({\n  url: __DEV__\n    ? Script.getDevServerURL(scriptId)  // Dev server\n    : `https://my-cdn.com/assets/${scriptId}`,  // Production CDN\n}));\n\nAppRegistry.registerComponent(appName, () => App);\n```\n\n### 5. Build and Deploy Chunks\n\nBuild generates:\n- `index.bundle` - Main bundle\n- `settings.chunk.bundle` - Lazy-loaded chunk\n\nDeploy chunks to your CDN at configured URL.\n\n## Complete Example\n\n```tsx\n// App.tsx\nimport React, { Suspense, useState } from 'react';\nimport { Button, View, ActivityIndicator } from 'react-native';\n\n// Lazy load heavy feature\nconst HeavyFeature = React.lazy(() =>\n  import(/* webpackChunkName: \"heavy-feature\" */ './HeavyFeature')\n);\n\nconst App = () => {\n  const [showFeature, setShowFeature] = useState(false);\n  \n  return (\n    <View>\n      <Button \n        title=\"Load Feature\" \n        onPress={() => setShowFeature(true)} \n      />\n      \n      {showFeature && (\n        <Suspense fallback={<ActivityIndicator />}>\n          <HeavyFeature />\n        </Suspense>\n      )}\n    </View>\n  );\n};\n```\n\n## Module Federation (Advanced)\n\nFor micro-frontend architecture:\n\n```tsx\n// Host app loads remote module\nconst RemoteModule = React.lazy(() =>\n  import('remote-app/Module')\n);\n```\n\nEnables:\n- Independent team deployments\n- Shared dependencies\n- Runtime composition\n\n**Complexity warning**: Only use when organizational benefits outweigh overhead.\n\n### Version Management\n\nConsider [Zephyr Cloud](https://zephyr-cloud.io/) for:\n- Sub-second deployments\n- Version management\n- Re.Pack integration\n\n## Caching Strategy\n\n```tsx\nScriptManager.shared.addResolver((scriptId) => ({\n  url: `https://my-cdn.com/${scriptId}`,\n  cache: {\n    // Enable caching\n    enabled: true,\n    // Cache location\n    path: `${FileSystem.cacheDirectory}/chunks/`,\n  },\n}));\n```\n\n## When NOT to Use\n\n| Scenario | Why Not |\n|----------|---------|\n| Using Hermes | mmap already efficient |\n| Small app | Overhead not worth it |\n| Simple navigation | Native navigation better |\n| Quick iteration needed | Added complexity |\n\n## Hermes Memory Mapping\n\nHermes reads bytecode lazily via mmap:\n- Only loads executed code into memory\n- No parse step needed\n- Code splitting provides marginal benefit\n\n## Verification\n\n```tsx\n// Check if chunk loaded correctly\nScriptManager.shared.on('loading', (scriptId) => {\n  console.log(`Loading: ${scriptId}`);\n});\n\nScriptManager.shared.on('loaded', (scriptId) => {\n  console.log(`Loaded: ${scriptId}`);\n});\n\nScriptManager.shared.on('error', (scriptId, error) => {\n  console.error(`Failed: ${scriptId}`, error);\n});\n```\n\n## Common Pitfalls\n\n- **Forgetting Suspense**: Lazy components need fallback\n- **Wrong CDN path**: Chunks 404 in production\n- **No caching**: Re-downloads on every load\n- **Too many chunks**: Network overhead exceeds savings\n\n## Related Skills\n\n- [bundle-tree-shaking.md](./bundle-tree-shaking.md) - Re.Pack tree shaking\n- [bundle-analyze-js.md](./bundle-analyze-js.md) - Measure chunk sizes\n- [native-measure-tti.md](./native-measure-tti.md) - Verify TTI impact\n",
        "skills/react-native/references/bundle-hermes-mmap.md": "---\ntitle: Disable JS Bundle Compression\nimpact: HIGH\ntags: android, hermes, mmap, tti, startup\n---\n\n# Skill: Disable JS Bundle Compression\n\nDisable Android JS bundle compression to enable Hermes memory mapping for faster startup.\n\n## Quick Config\n\n```groovy\n// android/app/build.gradle\nandroid {\n    androidResources {\n        noCompress += [\"bundle\"]\n    }\n}\n```\n\n**Note**: Default in React Native 0.79+. Only needed for 0.78 and earlier.\n\n## When to Use\n\n- Android app using Hermes\n- Want faster TTI (Time to Interactive)\n- Willing to trade install size for startup speed\n- React Native version is 0.78 or earlier, skip otherwise (see applicability)\n\n## Background\n\nAndroid compresses most files in APK/AAB by default, including `index.android.bundle`.\n\n**Problem**: Compressed files can't be memory-mapped (mmap).\n\n**Impact**: Hermes must decompress before reading, losing one of its key optimizations.\n\n## How Hermes Memory Mapping Works\n\nWithout compression:\n1. Hermes opens bytecode file\n2. OS memory-maps directly to disk\n3. Only pages actually accessed are loaded\n4. **Result**: Fast startup, low memory\n\nWith compression:\n1. Android decompresses entire bundle\n2. Loaded into memory\n3. Then Hermes processes\n4. **Result**: Slower startup, higher memory\n\n## Step-by-Step Implementation\n\n### Edit build.gradle\n\nIn `android/app/build.gradle`:\n\n```groovy\nandroid {\n    androidResources {\n        noCompress += [\"bundle\"]\n    }\n}\n```\n\n### Full Context\n\n```groovy\nandroid {\n    namespace \"com.myapp\"\n    defaultConfig {\n        applicationId \"com.myapp\"\n        // ...\n    }\n    \n    androidResources {\n        noCompress += [\"bundle\"]\n    }\n    \n    buildTypes {\n        release {\n            minifyEnabled true\n            // ...\n        }\n    }\n}\n```\n\n### Rebuild\n\n```bash\ncd android\n./gradlew clean\n./gradlew bundleRelease\n# or\n./gradlew assembleRelease\n```\n\n## Trade-offs\n\n| Metric | Without Change | With Change |\n|--------|----------------|-------------|\n| Download size | Same | Same |\n| Install size | Smaller | **+8% larger** |\n| TTI | Slower | **-16% faster** |\n\n**Real example**: 75.9 MB install → 82 MB install, but 450ms faster startup.\n\n## Applicability\n\n**React Native 0.78 and earlier**: Apply this optimization manually.\n\n**React Native 0.79+**: Skip this—bundle compression is disabled by default.\n\n## Verification\n\n### Check APK Contents\n\n```bash\n# Unzip APK\nunzip app-release.apk -d apk-contents\n\n# Check if bundle is compressed\nfile apk-contents/assets/index.android.bundle\n# Should show: \"data\" (not \"gzip compressed\")\n```\n\n### Measure TTI Impact\n\nUse performance markers (see [native-measure-tti.md](./native-measure-tti.md)) to compare before/after.\n\n## Multiple File Types\n\nIf you have other files that benefit from mmap:\n\n```groovy\nandroidResources {\n    noCompress += [\"bundle\", \"hbc\", \"data\"]\n}\n```\n\n## Common Pitfalls\n\n- **Not rebuilding**: Change requires clean build\n- **Wrong config location**: Must be in `android` block\n- **Ignoring size increase**: Monitor user feedback on install size\n- **Already default**: Check if React Native version includes this\n\n## Expo Notes\n\nFor Expo projects, run `npx expo prebuild` first to generate `android/` folder, then apply the `build.gradle` changes. Add `android/` to version control or use a [config plugin](https://docs.expo.dev/config-plugins/introduction/) for persistent changes.\n\n## Should You Enable This?\n\n| Scenario | Recommendation |\n|----------|---------------|\n| Startup-critical app | ✅ Enable |\n| Storage-sensitive users | ⚠️ Test impact |\n| Already fast TTI | Maybe not worth it |\n| Large JS bundle | ✅ Bigger benefit |\n\n## Related Skills\n\n- [native-measure-tti.md](./native-measure-tti.md) - Measure TTI improvement\n- [bundle-analyze-app.md](./bundle-analyze-app.md) - Check size impact\n- [bundle-r8-android.md](./bundle-r8-android.md) - Offset size increase\n",
        "skills/react-native/references/bundle-library-size.md": "---\ntitle: Determine Library Size\nimpact: MEDIUM\ntags: dependencies, bundlephobia, library-size\n---\n\n# Skill: Determine Library Size\n\nEvaluate third-party library size impact before adding to your project.\n\n## Quick Command\n\n```bash\n# Check size before installing\n# Visit: https://bundlephobia.com/package/[package-name]\n\n# Or use CLI\nnpx bundle-phobia-cli <package-name>\n```\n\n## When to Use\n\n- Evaluating new dependencies\n- Comparing alternative libraries\n- Auditing existing dependencies\n- Investigating bundle bloat\n\n## Tools Overview\n\n| Tool | Type | Best For |\n|------|------|----------|\n| bundlephobia.com | Web | Quick size check |\n| pkg-size.dev | Web | Backup/alternative |\n| Import Cost (VS Code) | IDE extension | Real-time feedback |\n\n## bundlephobia.com\n\n### Usage\n\nVisit [bundlephobia.com](https://bundlephobia.com) and enter package name.\n\n### Shows\n\n- **Minified size**: Raw JS size\n- **Minified + Gzipped**: Network transfer size\n- **Download time**: Estimated on various connections\n- **Dependencies**: What else gets pulled in\n- **Composition**: Breakdown by dependency\n\n### Example Analysis\n\n```\nreact-native-paper\n├── Minified: 312 kB\n├── Gzipped: 78 kB\n└── Dependencies: 12 packages\n    ├── @callstack/react-theme-provider\n    ├── color\n    └── ...\n```\n\n## pkg-size.dev\n\nBackup when bundlephobia fails.\n\nVisit [pkg-size.dev](https://pkg-size.dev) with package name.\n\n**Difference**: Actually installs package in web container, may be more accurate for edge cases.\n\n## Import Cost (VS Code Extension)\n\n### Install\n\nSearch \"Import Cost\" in VS Code extensions or:\n\n```bash\ncode --install-extension wix.vscode-import-cost\n```\n\n### Usage\n\nShows inline size next to imports:\n\n```tsx\nimport React from 'react';           // 6.5K (gzipped)\nimport { View, Text } from 'react-native';  // 0B (native)\nimport lodash from 'lodash';         // 71.5K (gzipped: 24.7K)\nimport get from 'lodash/get';        // 8K (gzipped: 2.9K)\n```\n\n### Limitations\n\n- Uses Webpack internally (not Metro)\n- May fail on React Native-specific packages\n- Doesn't account for tree shaking\n\n## Comparison Workflow\n\n### Before Adding Dependency\n\n1. Check on bundlephobia:\n   ```\n   https://bundlephobia.com/package/[package-name]\n   ```\n\n2. Compare alternatives:\n   ```\n   moment (289 kB) vs date-fns (75 kB) vs dayjs (6 kB)\n   ```\n\n3. Check what you actually need:\n   - Full library import vs specific functions\n   - Native alternative available?\n\n### After Adding\n\n1. Analyze bundle (see [bundle-analyze-js.md](./bundle-analyze-js.md))\n2. Verify actual impact matches expected\n3. Check for duplicate dependencies\n\n## Size Guidelines\n\n| Size (gzipped) | Assessment | Action |\n|----------------|------------|--------|\n| < 5 KB | Small | Generally fine |\n| 5-20 KB | Medium | Evaluate necessity |\n| 20-50 KB | Large | Look for alternatives |\n| > 50 KB | Very large | Strong justification needed |\n\n## Common Large Dependencies\n\n| Library | Size (gzipped) | Alternative |\n|---------|----------------|-------------|\n| moment | ~70 KB | dayjs (~3 KB) |\n| lodash (full) | ~25 KB | lodash-es + direct imports |\n| aws-sdk (full) | 200+ KB | @aws-sdk/client-* |\n| crypto-js | ~15 KB | react-native-quick-crypto |\n\n## Quick Size Check Script\n\n```bash\n# Check size before installing\nnpx bundle-phobia-cli <package-name>\n\n# Or use npm directly (less accurate)\nnpm pack <package-name> --dry-run 2>&1 | grep \"total files\"\n```\n\n## Decision Matrix\n\n| Factor | Keep JS Library | Use Native Alternative |\n|--------|-----------------|------------------------|\n| Size | > 50 KB | < 50 KB |\n| Platform coverage | Both platforms | Single platform OK |\n| Performance | Not critical | Critical path |\n| Functionality | Simple | Complex computation |\n\n## Code Example: Optimizing Imports\n\n```tsx\n// BAD: Full library (71.5 KB)\nimport _ from 'lodash';\n_.get(obj, 'path.to.value');\n\n// BETTER: Specific import (8 KB)\nimport get from 'lodash/get';\nget(obj, 'path.to.value');\n\n// BEST: Native JS (0 KB)\nobj?.path?.to?.value;\n```\n\n## Related Skills\n\n- [bundle-analyze-js.md](./bundle-analyze-js.md) - Verify actual bundle impact\n- [bundle-barrel-exports.md](./bundle-barrel-exports.md) - Optimize how you import\n- [native-sdks-over-polyfills.md](./native-sdks-over-polyfills.md) - Native alternatives to JS libs\n",
        "skills/react-native/references/bundle-native-assets.md": "---\ntitle: Native Assets\nimpact: HIGH\ntags: assets, images, asset-catalog, app-thinning\n---\n\n# Skill: Native Assets\n\nConfigure platform-specific asset delivery to reduce app download size.\n\n## Quick Config\n\n**iOS Asset Catalog (Build Phase):**\n\n```bash\n# Add to \"Bundle React Native code and images\" build phase\nexport EXTRA_PACKAGER_ARGS=\"--asset-catalog-dest ./\"\n```\n\n**Android**: Automatic via AAB — Play Store delivers correct density per device.\n\n## When to Use\n\n- Images bloating app size\n- Different device densities need different assets\n- Want to leverage App Store/Play Store optimization\n- Using high-resolution images\n\n## Concept: Size Suffixes\n\nReact Native convention for multiple resolutions:\n\n```\nassets/\n├── image.jpg       # 1x resolution (base)\n├── image@2x.jpg    # 2x resolution\n└── image@3x.jpg    # 3x resolution\n```\n\n```tsx\n// React Native selects best one for device\n<Image source={require('./assets/image.jpg')} />\n```\n\n## Android: Automatic Optimization\n\nAndroid handles this automatically.\n\n### How It Works\n\n1. Build AAB:\n   ```bash\n   cd android && ./gradlew bundleRelease\n   ```\n\n2. Metro places images in density folders:\n   ```\n   android/app/build/outputs/bundle/release/\n   └── base/\n       └── res/\n           ├── drawable-mdpi-v4/     # 1x\n           ├── drawable-hdpi-v4/     # 1.5x\n           ├── drawable-xhdpi-v4/    # 2x\n           ├── drawable-xxhdpi-v4/   # 3x\n           └── drawable-xxxhdpi-v4/  # 4x\n   ```\n\n3. Play Store delivers only needed density per device.\n\n**No configuration required** for Android.\n\n## iOS: Asset Catalog Setup\n\niOS requires explicit configuration.\n\n### Step 1: Create Asset Catalog\n\nCreate folder in `ios/`:\n\n```\nios/RNAssets.xcassets/\n```\n\n**Important**: Must be named exactly `RNAssets.xcassets` (hardcoded in React Native).\n\n### Step 2: Configure Build Phase\n\nIn Xcode:\n1. Open project settings\n2. Go to **Build Phases**\n3. Find **\"Bundle React Native code and images\"**\n4. Add before line 8:\n\n```bash\nexport EXTRA_PACKAGER_ARGS=\"--asset-catalog-dest ./\"\n```\n\n### Step 3: Build\n\nRun build to populate asset catalog:\n\n```bash\nnpx react-native run-ios --mode Release\n```\n\nOr manually:\n\n```bash\nnpx react-native bundle \\\n  --entry-file index.js \\\n  --bundle-output ios-bundle.js \\\n  --platform ios \\\n  --dev false \\\n  --asset-catalog-dest ios \\\n  --assets-dest ios/assets\n```\n\n### Step 4: Verify\n\nAfter build, `RNAssets.xcassets` contains:\n\n```\nios/RNAssets.xcassets/\n└── assets_image_image.imageset/\n    ├── Contents.json\n    ├── image.jpg\n    ├── image@2x.jpg\n    └── image@3x.jpg\n```\n\nApp Store then delivers only needed resolution.\n\n## Before/After Comparison\n\n### Without Asset Catalog (All Variants)\n\n```\nApp bundle contains:\n├── image.jpg       (100 KB)\n├── image@2x.jpg    (300 KB)\n└── image@3x.jpg    (600 KB)\nTotal: 1 MB\n```\n\n### With Asset Catalog (Device-Specific)\n\n```\niPhone 15 Pro receives:\n└── image@3x.jpg    (600 KB)\nTotal: 600 KB  (40% smaller)\n```\n\n## Asset Optimization Tips\n\n### 1. Compress Images\n\nUse tools before adding to project:\n\n```bash\n# ImageOptim (macOS)\n# TinyPNG (web)\n# sharp (programmatic)\n\nnpx sharp-cli input.jpg -o output.jpg --quality 80\n```\n\n### 2. Use Appropriate Formats\n\n| Format | Best For |\n|--------|----------|\n| JPEG | Photos |\n| PNG | Icons, transparency |\n| WebP | Both (smaller) |\n| SVG | Vector icons |\n\n### 3. Consider react-native-fast-image\n\nCaching and better image handling:\n\n```bash\nnpm install react-native-fast-image\n```\n\n## Verification\n\n### iOS App Thinning Report\n\nAfter export, check `App Thinning Size Report.txt`:\n\n```\nVariant: MyApp-<UUID>.ipa\nSupported variant descriptors: iPhone15,2 ...\nApp size: 3.5 MB compressed, 10.6 MB uncompressed\n```\n\n### Use Emerge Tools\n\nUpload IPA to see asset breakdown.\n\n## Common Pitfalls\n\n- **Wrong folder name**: Must be `RNAssets.xcassets` exactly\n- **Missing build phase config**: Assets not processed\n- **Not using size suffixes**: All variants included anyway\n- **Forgetting to rebuild**: Changes need fresh build\n\n## Future Note\n\nAs of January 2025, Asset Catalog is not default. May become default in future React Native versions.\n\n## Related Skills\n\n- [bundle-analyze-app.md](./bundle-analyze-app.md) - Verify asset impact\n- [bundle-r8-android.md](./bundle-r8-android.md) - Android code optimization\n",
        "skills/react-native/references/bundle-r8-android.md": "---\ntitle: R8 Code Shrinking\nimpact: HIGH\ntags: android, r8, proguard, minify, shrink\n---\n\n# Skill: R8 Code Shrinking\n\nEnable R8 for Android to shrink, optimize, and obfuscate native code.\n\n## Quick Config\n\n```groovy\n// android/app/build.gradle\ndef enableProguardInReleaseBuilds = true\n\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n        }\n    }\n}\n```\n\n## When to Use\n\n- Android app size too large\n- Want to obfuscate code for security\n- Building release APK/AAB\n\n## What is R8?\n\nR8 replaces ProGuard in Android:\n- **Shrinks**: Removes unused code\n- **Optimizes**: Improves bytecode\n- **Obfuscates**: Renames classes/methods\n\n**Compatibility**: Uses ProGuard configuration format.\n\n## Step-by-Step Instructions\n\n### 1. Enable R8\n\nEdit `android/app/build.gradle`:\n\n```groovy\ndef enableProguardInReleaseBuilds = true\n```\n\nThis sets `minifyEnabled = true` for release builds.\n\n### 2. Enable Resource Shrinking (Optional)\n\nFurther reduces size by removing unused resources:\n\n```groovy\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true  // Requires minifyEnabled\n            \n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n```\n\n### 3. Configure ProGuard Rules (If Needed)\n\nEdit `android/app/proguard-rules.pro`. React Native defaults are usually sufficient—only add rules when specific libraries break after enabling R8.\n\n**Only add if using Firebase (`@react-native-firebase/*`):**\n\n```proguard\n-keep class io.invertase.firebase.** { *; }\n-dontwarn io.invertase.firebase.**\n```\n\n**Only add if using Retrofit:**\n\n```proguard\n-keepattributes Signature\n-keepattributes *Annotation*\n-keep class retrofit2.** { *; }\n-dontwarn retrofit2.**\n```\n\nSee [Common Library Rules](#common-library-rules) and [Troubleshooting](#troubleshooting) for more examples.\n\n### 4. Build and Test\n\n```bash\ncd android\n./gradlew assembleRelease\n# or\n./gradlew bundleRelease\n```\n\n**Critical**: Test thoroughly! R8 can remove code it thinks is unused.\n\n## ProGuard Rules Reference\n\n| Rule | Effect |\n|------|--------|\n| `-keep class X` | Don't remove class X |\n| `-keepclassmembers` | Keep members but allow rename |\n| `-keepnames` | Keep names but allow removal if unused |\n| `-dontwarn X` | Suppress warnings for X |\n| `-dontobfuscate` | Disable obfuscation |\n\n### Keep Entire Package\n\n```proguard\n-keep class com.mypackage.** { *; }\n```\n\n### Keep Classes with Annotation\n\n```proguard\n-keep @interface com.facebook.proguard.annotations.DoNotStrip\n-keep @com.facebook.proguard.annotations.DoNotStrip class *\n-keepclassmembers class * {\n    @com.facebook.proguard.annotations.DoNotStrip *;\n}\n```\n\n## Disable Obfuscation (If Needed)\n\n```proguard\n# proguard-rules.pro\n-dontobfuscate\n```\n\nUse when:\n- Debugging crashes (stack traces more readable)\n- Library requires class names\n\n## Size Impact\n\nExample from guide:\n- **Without R8**: 9.5 MB\n- **With R8**: 6.3 MB\n- **Savings**: 33%\n\nLarger apps may see 20-30% reduction.\n\n## Troubleshooting\n\n### App Crashes After R8\n\nUsually means needed class was removed.\n\n**Debug steps**:\n\n1. Check crash log for class name\n2. Add keep rule:\n   ```proguard\n   -keep class com.example.CrashedClass { *; }\n   ```\n3. Rebuild and test\n\n### Library Specific Rules\n\nMany libraries provide ProGuard rules. Check:\n- Library README\n- Library's `consumer-proguard-rules.pro`\n- Stack Overflow for library + proguard\n\n### Common Library Rules\n\n```proguard\n# Hermes (usually auto-included)\n-keep class com.facebook.hermes.unicode.** { *; }\n\n# React Native\n-keep class com.facebook.react.** { *; }\n\n# Gson\n-keepattributes Signature\n-keep class com.google.gson.** { *; }\n\n# OkHttp\n-dontwarn okhttp3.**\n-dontwarn okio.**\n```\n\n## Verification\n\n### Check APK Size\n\n```bash\n# Build\n./gradlew assembleRelease\n\n# Check size\nls -la android/app/build/outputs/apk/release/\n```\n\n### Use Ruler for Detailed Analysis\n\nSee [bundle-analyze-app.md](./bundle-analyze-app.md).\n\n### Verify Obfuscation\n\nDecompile APK to check class names are obfuscated:\n\n```bash\n# Using jadx or similar\njadx android/app/build/outputs/apk/release/app-release.apk\n```\n\n## Common Pitfalls\n\n- **Not testing release build**: Always QA with R8 enabled\n- **Missing library rules**: Check library docs\n- **Over-keeping**: Too many keep rules negates benefits\n- **Reflection**: Code using reflection may break\n\n## Related Skills\n\n- [bundle-analyze-app.md](./bundle-analyze-app.md) - Measure size impact\n- [bundle-native-assets.md](./bundle-native-assets.md) - Further size reduction\n",
        "skills/react-native/references/bundle-tree-shaking.md": "---\ntitle: Tree Shaking\nimpact: HIGH\ntags: bundle, tree-shaking, dead-code, metro, repack\n---\n\n# Skill: Tree Shaking\n\nEnable dead code elimination to remove unused exports from your JavaScript bundle.\n\n## Quick Config\n\n```bash\n# .env (Expo SDK 52+)\nEXPO_UNSTABLE_METRO_OPTIMIZE_GRAPH=1\nEXPO_UNSTABLE_TREE_SHAKING=1\n```\n\n```javascript\n// metro.config.js\nconfig.transformer.getTransformOptions = async () => ({\n  transform: { experimentalImportSupport: true },\n});\n```\n\n```javascript\n// babel.config.js (non-Expo projects must set `disableImportExportTransform`)\nmodule.exports = {\n  presets: [\n    [\n      'module:@react-native/babel-preset',\n      { disableImportExportTransform: true },\n    ],\n  ],\n};\n```\n\n## When to Use\n\n- Bundle includes unused library code\n- Want automatic barrel export optimization\n- Using Expo SDK 52+ (recommended approach)\n- Project already uses Re.Pack (`@callstack/repack`)\n\n## Platform Support\n\n| Bundler        | Tree Shaking    | Notes                        |\n| -------------- | --------------- | ---------------------------- |\n| Metro          | ❌ No           | Use metro-serializer-esbuild |\n| Expo (SDK 52+) | ✅ Experimental | Requires config              |\n| Re.Pack        | ✅ Yes          | Built-in via Webpack/Rspack  |\n\n## Setup: Expo SDK 52+\n\n### 1. Enable Import Support\n\n```javascript\n// metro.config.js\nconst { getDefaultConfig } = require('expo/metro-config');\n\nconst config = getDefaultConfig(__dirname);\n\nconfig.transformer.getTransformOptions = async () => ({\n  transform: {\n    experimentalImportSupport: true,\n  },\n});\n\nmodule.exports = config;\n```\n\n### 2. Enable Tree Shaking\n\nCreate/edit `.env`:\n\n```bash\nEXPO_UNSTABLE_METRO_OPTIMIZE_GRAPH=1\nEXPO_UNSTABLE_TREE_SHAKING=1\n```\n\n**Note**: Only applies in production builds.\n\n## Setup: Metro with ESBuild\n\n```bash\nnpm install @rnx-kit/metro-serializer-esbuild\n```\n\nConfigure in metro.config.js.\n\n## Setup: Re.Pack (Only If Already Installed)\n\n> **Important**: Re.Pack (`@callstack/repack`) is a custom bundler using Rspack/Webpack. Only apply these instructions if the project already has Re.Pack configured. Do not suggest migrating a codebase to Re.Pack—it's rarely necessary and requires significant setup.\n\n**If project has `@callstack/repack` in dependencies:**\n\nTree shaking is enabled by default with Rspack. Verify in config:\n\n```javascript\n// rspack.config.js or webpack.config.js\nmodule.exports = {\n  optimization: {\n    usedExports: true, // Mark unused exports\n    minimize: true, // Remove during minification\n  },\n};\n```\n\n## Platform Shaking\n\nCode inside `Platform.OS` and `Platform.select` checks is removed for other platforms:\n\n```tsx\n// IMPORTANT: import Platform directly from 'react-native'\nimport { Platform } from 'react-native';\n\nif (Platform.OS === 'ios') {\n  // Removed from Android bundle\n}\n\nif (Platform.select({ ios: true, android: false }) === 'ios') {\n  // Removed from Android bundle\n}\n```\n\n**Critical**: Must use direct import. This does NOT work:\n\n```tsx\nimport * as RN from 'react-native';\nif (RN.Platform.OS === 'ios') {\n  // NOT removed - optimization fails\n}\n```\n\nFor non-Expo projects, requires both `experimentalImportSupport: true` in Metro config and `disableImportExportTransform: true` in Babel config.\n\nImpact: Savings from enabling platform shaking on a bare React Native Community CLI project are:\n- 5% smaller Hermes bytecode (2.79 MB → 2.64 MB)\n- 15% smaller minified JS bundle (1 MB → 0.85 MB)\n\n## Requirements for Tree Shaking\n\n### ESM Imports Required\n\n```tsx\n// ✅ ESM - Tree shakeable\nimport { foo } from './module';\n\n// ❌ CommonJS - Not tree shakeable\nconst { foo } = require('./module');\n```\n\n### Side Effects Declaration\n\nLibraries must declare side-effect-free in `package.json`:\n\n```json\n{\n  \"sideEffects\": false\n}\n```\n\nOr specify files with side effects:\n\n```json\n{\n  \"sideEffects\": [\"*.css\", \"./src/polyfills.js\"]\n}\n```\n\n## Size Impact\n\n| Bundle Type       | Metro (MB) | Re.Pack (MB) | Change   |\n| ----------------- | ---------- | ------------ | -------- |\n| Production        | 35.63      | 38.48        | +8%      |\n| Prod Minified     | 15.54      | 13.36        | **-14%** |\n| Prod HBC          | 21.79      | 19.35        | **-11%** |\n| Prod Minified HBC | 21.62      | 19.05        | **-12%** |\n\n**Expected improvement**: 10-15% bundle size reduction.\n\n## Verification\n\n1. Build production bundle (see [bundle-analyze-js.md](./bundle-analyze-js.md))\n2. Analyze with source-map-explorer (see [bundle-analyze-js.md](./bundle-analyze-js.md))\n3. Search for functions you know are unused\n4. If found → tree shaking not working\n\n### Test Example\n\n```tsx\n// test-treeshake.js\nexport const usedFunction = () => 'used';\nexport const unusedFunction = () => 'unused'; // Should be removed\n\n// app.js\nimport { usedFunction } from './test-treeshake';\n```\n\nAfter building, search bundle for `unusedFunction`. Should not exist.\n\n## Common Pitfalls\n\n- **Not using production build**: Tree shaking only in prod\n- **CommonJS modules**: Need ESM for full effectiveness\n- **Side effects not declared**: Library may not be shakeable\n- **Dynamic imports**: `require(variable)` prevents analysis\n- **Babel/Metro config mismatch**: `disableImportExportTransform` must match `experimentalImportSupport`\n\n## Related Skills\n\n- [bundle-analyze-js.md](./bundle-analyze-js.md) - Verify tree shaking effect\n- [bundle-barrel-exports.md](./bundle-barrel-exports.md) - Manual alternative\n- [bundle-code-splitting.md](./bundle-code-splitting.md) - Re.Pack code splitting\n",
        "skills/react-native/references/js-animations-reanimated.md": "---\ntitle: High-Performance Animations\nimpact: MEDIUM\ntags: reanimated, animations, worklets, ui-thread\n---\n\n# Skill: High-Performance Animations\n\nUse React Native Reanimated and InteractionManager for smooth 60+ FPS animations.\n\n## Quick Pattern\n\n**Incorrect (JS thread - blocks on heavy work):**\n\n```jsx\nconst opacity = useRef(new Animated.Value(0)).current;\nAnimated.timing(opacity, { toValue: 1 }).start();\n```\n\n**Correct (UI thread - smooth even during JS work):**\n\n```jsx\nconst opacity = useSharedValue(0);\nconst style = useAnimatedStyle(() => ({ opacity: opacity.value }));\nopacity.value = withTiming(1);\n```\n\n## When to Use\n\n- Animations drop frames or feel janky\n- UI freezes during animations\n- Need gesture-driven animations\n- Want animations to run during heavy JS work\n\n## Prerequisites\n\n- `react-native-reanimated` (v4+) and `react-native-worklets` installed\n\n```bash\nnpm install react-native-reanimated react-native-worklets\n```\n\nAdd to `babel.config.js`:\n\n```javascript\nmodule.exports = {\n  plugins: ['react-native-worklets/plugin'],  // Must be last\n};\n```\n\n> **Note**: Reanimated 4 requires React Native's **New Architecture** (Fabric + TurboModules). The Legacy Architecture is no longer supported. If upgrading from v3, see the migration notes at the end of this document.\n\n## Key Concepts\n\n### Main Thread vs JS Thread\n\n- **Main/UI Thread**: Handles native rendering (60+ FPS target)\n- **JS Thread**: Runs React and your JavaScript\n\n**Problem**: Heavy JS work blocks animations running on JS thread.\n\n**Solution**: Run animations on UI thread with Reanimated worklets.\n\n## Step-by-Step Instructions\n\n### 1. Basic Animated Style (UI Thread)\n\n```jsx\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withTiming \n} from 'react-native-reanimated';\n\nconst FadeInView = () => {\n  const opacity = useSharedValue(0);\n  \n  // This runs on UI thread - won't be blocked by JS\n  const animatedStyle = useAnimatedStyle(() => {\n    return { opacity: opacity.value };\n  });\n  \n  useEffect(() => {\n    opacity.value = withTiming(1, { duration: 500 });\n  }, []);\n  \n  return <Animated.View style={[styles.box, animatedStyle]} />;\n};\n```\n\n### 2. Run Code on UI Thread with `scheduleOnUI`\n\n```jsx\nimport { scheduleOnUI } from 'react-native-worklets';\n\nconst triggerAnimation = () => {\n  scheduleOnUI(() => {\n    'worklet';\n    console.log('Running on UI thread');\n    // Direct UI manipulations here\n  });\n};\n```\n\n### 3. Call JS from UI Thread with `scheduleOnRN`\n\n```jsx\nimport { scheduleOnRN } from 'react-native-worklets';\n\n// Regular JS function\nconst trackAnalytics = (value) => {\n  analytics.track('animation_complete', { value });\n};\n\nconst AnimatedComponent = () => {\n  const progress = useSharedValue(0);\n  \n  const animatedStyle = useAnimatedStyle(() => {\n    // When animation completes, call JS function\n    if (progress.value === 1) {\n      scheduleOnRN(trackAnalytics, progress.value);\n    }\n    return { opacity: progress.value };\n  });\n  \n  return <Animated.View style={animatedStyle} />;\n};\n```\n\n### 4. Animation with Callback\n\n```jsx\nimport { scheduleOnRN } from 'react-native-worklets';\n\nconst AnimatedButton = () => {\n  const scale = useSharedValue(1);\n  \n  const onComplete = () => {\n    console.log('Animation finished!');\n  };\n  \n  const handlePress = () => {\n    scale.value = withTiming(\n      1.2,\n      { duration: 200 },\n      (finished) => {\n        if (finished) {\n          scheduleOnRN(onComplete);\n        }\n      }\n    );\n  };\n  \n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n  \n  return (\n    <Pressable onPress={handlePress}>\n      <Animated.View style={[styles.button, animatedStyle]}>\n        <Text>Press Me</Text>\n      </Animated.View>\n    </Pressable>\n  );\n};\n```\n\n## InteractionManager for Heavy Work\n\nDefer expensive JS work until animations complete:\n\n```jsx\nimport { InteractionManager } from 'react-native';\n\nconst ScreenWithAnimation = () => {\n  useEffect(() => {\n    // Schedule after animations/interactions finish\n    const task = InteractionManager.runAfterInteractions(() => {\n      // Heavy computation here\n      loadExpensiveData();\n    });\n    \n    return () => task.cancel();\n  }, []);\n  \n  return <AnimatedHeader />;\n};\n```\n\n### With React Navigation\n\n```jsx\nimport { useFocusEffect } from '@react-navigation/native';\n\nconst Screen = () => {\n  useFocusEffect(\n    useCallback(() => {\n      // Wait for screen transition animation to complete\n      const task = InteractionManager.runAfterInteractions(() => {\n        fetchData();\n        renderExpensiveComponent();\n      });\n      \n      return () => task.cancel();\n    }, [])\n  );\n  \n  return <View>...</View>;\n};\n```\n\n### Custom Interaction Handle\n\n```jsx\nimport { scheduleOnRN } from 'react-native-worklets';\n\n// Mark animation as an \"interaction\"\nconst handle = InteractionManager.createInteractionHandle();\n\n// Run animation...\nanimatedValue.value = withTiming(100, {}, () => {\n  // When done, clear the handle\n  scheduleOnRN(InteractionManager.clearInteractionHandle, handle);\n});\n```\n\n## When to Use What\n\n| Thread | Best For |\n|--------|----------|\n| **UI Thread** (worklets) | Visual animations, transforms, gestures |\n| **JS Thread** | State updates, data processing, API calls |\n\n| Hook/API | Use Case |\n|----------|----------|\n| `useAnimatedStyle` | Animated styles (auto UI thread) |\n| `scheduleOnUI` | Manual UI thread execution (from `react-native-worklets`) |\n| `scheduleOnRN` | Call JS functions from worklets (from `react-native-worklets`) |\n| `InteractionManager` | Defer heavy JS until animations complete |\n| `useTransition` | Alternative for React state-driven delays |\n\n## Common Pitfalls\n\n- **Accessing React state in worklets**: Use `useSharedValue` instead of `useState` for animated values\n- **Not using Animated components**: Must use `Animated.View`, `Animated.Text`, etc.\n- **Heavy computation in useAnimatedStyle**: Keep worklets fast\n- **Forgetting 'worklet' directive**: Required for inline worklet functions\n\n```jsx\n// BAD: Regular function in useAnimatedStyle\nconst style = useAnimatedStyle(() => {\n  heavyComputation();  // Blocks UI thread!\n  return { opacity: 1 };\n});\n\n// GOOD: Keep worklets fast\nconst style = useAnimatedStyle(() => {\n  return { opacity: opacity.value };  // Just read value\n});\n```\n\n## Migrating from Reanimated 3.x to 4.x\n\nIf you're upgrading from Reanimated 3.x, here are the key changes.\n\n> **Can't upgrade to v4?** If your project is blocked from migrating to New Architecture (e.g., incompatible native libraries, complex native code, or timeline constraints), keep using existing APIs and leverage native drivers where applicable. Avoid introducing legacy Reanimated 3.x or older to reduce future migration complexity.\n\n### Breaking Changes\n\n| Old API (v3) | New API (v4) | Package |\n|--------------|--------------|---------|\n| `runOnUI(() => {...})()` | `scheduleOnUI(() => {...})` | `react-native-worklets` |\n| `runOnJS(fn)(args)` | `scheduleOnRN(fn, args)` | `react-native-worklets` |\n| `executeOnUIRuntimeSync` | `runOnUISync` | `react-native-worklets` |\n| `runOnRuntime` | `scheduleOnRuntime` | `react-native-worklets` |\n| `useScrollViewOffset` | `useScrollOffset` | `react-native-reanimated` |\n| `useWorkletCallback` | Use `useCallback` with `'worklet';` directive | React |\n\n### Removed APIs\n\n- `useAnimatedGestureHandler` - Migrate to the Gesture API from `react-native-gesture-handler` v2+\n- `addWhitelistedNativeProps` / `addWhitelistedUIProps` - No longer needed\n- `combineTransition` - Use `EntryExitTransition.entering(...).exiting(...)` instead\n\n### withSpring Changes\n\n```jsx\n// Before (v3)\nwithSpring(value, {\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n  duration: 300,\n});\n\n// After (v4)\nwithSpring(value, {\n  energyThreshold: 0.01,  // Replaces both threshold parameters\n  duration: 200,          // Duration is now \"perceptual\" (~1.5x actual time)\n});\n```\n\n### Migration Checklist\n\n1. **Enable New Architecture** - Reanimated 4 only supports Fabric + TurboModules\n2. **Install `react-native-worklets`** - Required new dependency\n3. **Update Babel plugin** - Change `'react-native-reanimated/plugin'` to `'react-native-worklets/plugin'`\n4. **Update imports** - Move worklet functions to `react-native-worklets`\n5. **Update API calls** - New functions take callback + args directly (not curried)\n6. **Rebuild native apps** - Required after adding `react-native-worklets`\n\n## Related Skills\n\n- [js-measure-fps.md](./js-measure-fps.md) - Verify animation frame rate\n- [js-concurrent-react.md](./js-concurrent-react.md) - React-level deferral with useTransition\n",
        "skills/react-native/references/js-atomic-state.md": "---\ntitle: Atomic State Management\nimpact: HIGH\ntags: state, jotai, zustand, re-renders, context\n---\n\n# Skill: Atomic State Management\n\nUse atomic state libraries (Jotai, Zustand) to reduce unnecessary re-renders without manual memoization.\n\n## Quick Pattern\n\n**Before (Context - all consumers re-render):**\n\n```jsx\nconst { filter, todos } = useContext(TodoContext);\n// Re-renders when ANY state changes\n```\n\n**After (Zustand - only subscribed state):**\n\n```jsx\nconst filter = useTodoStore((s) => s.filter);\n// Only re-renders when filter changes\n```\n\n## When to Use\n\n- Global state changes cause widespread re-renders\n- Using React Context for app state\n- Components re-render even when their data hasn't changed\n- Want to avoid manual `useMemo`/`useCallback` everywhere\n- Not ready to adopt React Compiler\n\n## Prerequisites\n\n- State management library: `jotai` or `zustand`\n\n```bash\nnpm install jotai\n# or\nnpm install zustand\n```\n\n## Problem Description\n\nWith traditional React state or Context:\n\n```jsx\n// When filter OR todos change, EVERYTHING re-renders\nconst App = () => {\n  const [filter, setFilter] = useState('all');\n  const [todos, setTodos] = useState([]);\n  \n  return (\n    <>\n      <FilterMenu filter={filter} setFilter={setFilter} />\n      <TodoList todos={todos} filter={filter} setTodos={setTodos} />\n    </>\n  );\n};\n```\n\nChanging a todo re-renders FilterMenu even though it doesn't use todos.\n\n## Step-by-Step Instructions\n\n### Using Jotai\n\n#### 1. Define Atoms\n\n```jsx\nimport { atom } from 'jotai';\n\n// Each atom is an independent piece of state\nconst filterAtom = atom('all');\nconst todosAtom = atom([]);\n\n// Derived atom (computed value)\nconst filteredTodosAtom = atom((get) => {\n  const filter = get(filterAtom);\n  const todos = get(todosAtom);\n  \n  if (filter === 'active') return todos.filter(t => !t.completed);\n  if (filter === 'completed') return todos.filter(t => t.completed);\n  return todos;\n});\n```\n\n#### 2. Use Atoms in Components\n\n```jsx\nimport { useAtom, useAtomValue, useSetAtom } from 'jotai';\n\n// Only re-renders when filterAtom changes\nconst FilterMenu = () => {\n  const [filter, setFilter] = useAtom(filterAtom);\n  \n  return (\n    <View>\n      {['all', 'active', 'completed'].map((f) => (\n        <Pressable key={f} onPress={() => setFilter(f)}>\n          <Text style={filter === f ? styles.active : null}>{f}</Text>\n        </Pressable>\n      ))}\n    </View>\n  );\n};\n\n// Only re-renders when todosAtom changes\nconst TodoItem = ({ id }) => {\n  const setTodos = useSetAtom(todosAtom);  // Only setter, no re-render on read\n  \n  const toggleTodo = () => {\n    setTodos((prev) => \n      prev.map((t) => t.id === id ? { ...t, completed: !t.completed } : t)\n    );\n  };\n  \n  return <Pressable onPress={toggleTodo}>...</Pressable>;\n};\n```\n\n### Using Zustand\n\n#### 1. Create Store\n\n```jsx\nimport { create } from 'zustand';\n\nconst useTodoStore = create((set, get) => ({\n  filter: 'all',\n  todos: [],\n  \n  setFilter: (filter) => set({ filter }),\n  \n  toggleTodo: (id) => set((state) => ({\n    todos: state.todos.map((t) =>\n      t.id === id ? { ...t, completed: !t.completed } : t\n    ),\n  })),\n  \n  // Selector for derived state\n  getFilteredTodos: () => {\n    const { filter, todos } = get();\n    if (filter === 'active') return todos.filter(t => !t.completed);\n    if (filter === 'completed') return todos.filter(t => t.completed);\n    return todos;\n  },\n}));\n```\n\n#### 2. Use Selectors\n\n```jsx\n// Only re-renders when filter changes\nconst FilterMenu = () => {\n  const filter = useTodoStore((state) => state.filter);\n  const setFilter = useTodoStore((state) => state.setFilter);\n  \n  return (\n    <View>\n      {['all', 'active', 'completed'].map((f) => (\n        <Pressable key={f} onPress={() => setFilter(f)}>\n          <Text>{f}</Text>\n        </Pressable>\n      ))}\n    </View>\n  );\n};\n\n// Only re-renders when todos change\nconst TodoList = () => {\n  const todos = useTodoStore((state) => state.todos);\n  return todos.map((todo) => <TodoItem key={todo.id} {...todo} />);\n};\n```\n\n## Code Examples\n\n### Before: Context-Based (Many Re-renders)\n\n```jsx\nconst TodoContext = createContext();\n\nconst TodoProvider = ({ children }) => {\n  const [state, setState] = useState({ filter: 'all', todos: [] });\n  return (\n    <TodoContext.Provider value={{ state, setState }}>\n      {children}\n    </TodoContext.Provider>\n  );\n};\n\n// Every component using this context re-renders on ANY state change\nconst FilterMenu = () => {\n  const { state, setState } = useContext(TodoContext);\n  // Re-renders when todos change too!\n};\n```\n\n### After: Atomic (Targeted Re-renders)\n\n```jsx\n// Jotai version - only affected components re-render\nconst filterAtom = atom('all');\nconst todosAtom = atom([]);\n\nconst FilterMenu = () => {\n  const [filter, setFilter] = useAtom(filterAtom);\n  // Only re-renders when filter changes\n};\n\nconst TodoList = () => {\n  const todos = useAtomValue(todosAtom);\n  // Only re-renders when todos change\n};\n```\n\n## Comparison\n\n| Feature | Context | Jotai | Zustand |\n|---------|---------|-------|---------|\n| Re-render scope | All consumers | Atom subscribers | Selector subscribers |\n| Derived state | Manual | Built-in atoms | Selectors |\n| DevTools | React DevTools | Jotai DevTools | Zustand DevTools |\n| Bundle size | 0 KB | ~3 KB | ~2 KB |\n| Learning curve | Low | Medium | Low |\n\n## When to Use Which\n\n- **Jotai**: Fine-grained state, many small atoms, derived/async atoms\n- **Zustand**: Simpler mental model, single store, familiar Redux-like pattern\n- **React Compiler**: If available, may eliminate need for these libraries\n\n## Common Pitfalls\n\n- **Over-atomizing**: Don't create an atom for every variable. Group related state.\n- **Missing selectors in Zustand**: Always use selectors to prevent unnecessary re-renders.\n- **Derived state without memoization**: Use derived atoms (Jotai) or memoized selectors.\n\n## Related Skills\n\n- [js-react-compiler.md](./js-react-compiler.md) - Automatic memoization alternative\n- [js-profile-react.md](./js-profile-react.md) - Verify re-render reduction\n",
        "skills/react-native/references/js-concurrent-react.md": "---\ntitle: Concurrent React\nimpact: HIGH\ntags: useDeferredValue, useTransition, suspense, concurrent\n---\n\n# Skill: Concurrent React\n\nUse `useDeferredValue` and `useTransition` to improve perceived performance by prioritizing critical updates.\n\n## Quick Pattern\n\n**Incorrect (blocks input on every keystroke):**\n\n```jsx\nconst [query, setQuery] = useState('');\n<TextInput value={query} onChangeText={setQuery} />\n<ExpensiveList query={query} />  // Blocks typing\n```\n\n**Correct (input stays responsive):**\n\n```jsx\nconst [query, setQuery] = useState('');\nconst deferredQuery = useDeferredValue(query);\n<TextInput value={query} onChangeText={setQuery} />\n<ExpensiveList query={deferredQuery} />  // Deferred update\n```\n\n## When to Use\n\n- Search/filter inputs feel laggy with large result sets\n- Expensive computations block UI interactions\n- Loading states appear too frequently\n- Want to show stale content while loading new content\n- Need to prioritize user input over background updates\n\n## Prerequisites\n\n- React Native with New Architecture enabled (default in RN 0.76+)\n- React 18+ features (`useDeferredValue`, `useTransition`, `Suspense`)\n\n## Concept Overview\n\n**Concurrent React** allows updates to be:\n- **Paused**: Low-priority work can wait\n- **Interrupted**: User input takes priority\n- **Abandoned**: Outdated updates can be skipped\n\n## Step-by-Step Instructions\n\n### Pattern 1: Defer Expensive Rendering with `useDeferredValue`\n\nUse when a value drives expensive computation but you want input to stay responsive.\n\n```jsx\nimport { useState, useDeferredValue } from 'react';\n\nconst SearchScreen = () => {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  // query updates immediately (input stays responsive)\n  // deferredQuery updates when React has time\n  \n  return (\n    <View>\n      <TextInput\n        value={query}\n        onChangeText={setQuery}\n        placeholder=\"Search...\"\n      />\n      {/* ExpensiveList receives deferred value */}\n      <ExpensiveList query={deferredQuery} />\n    </View>\n  );\n};\n```\n\n### Pattern 2: Show Stale Content While Loading\n\n```jsx\nconst SearchWithStaleIndicator = () => {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  \n  return (\n    <View>\n      <TextInput value={query} onChangeText={setQuery} />\n      <View style={isStale && { opacity: 0.7 }}>\n        <SearchResults query={deferredQuery} />\n      </View>\n      {isStale && <ActivityIndicator />}\n    </View>\n  );\n};\n```\n\n### Pattern 3: Transition Non-Critical Updates with `useTransition`\n\nUse when you have multiple state updates and want to mark some as low-priority.\n\n```jsx\nimport { useState, useTransition } from 'react';\n\nconst TransitionExample = () => {\n  const [count, setCount] = useState(0);\n  const [heavyData, setHeavyData] = useState(null);\n  const [isPending, startTransition] = useTransition();\n  \n  const handleIncrement = () => {\n    // High priority - updates immediately\n    setCount(c => c + 1);\n    \n    // Low priority - can be interrupted\n    startTransition(() => {\n      setHeavyData(computeExpensiveData());\n    });\n  };\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      {isPending ? <ActivityIndicator /> : <HeavyComponent data={heavyData} />}\n      <Button onPress={handleIncrement} title=\"Increment\" />\n    </View>\n  );\n};\n```\n\n### Pattern 4: Suspense for Data Fetching\n\n```jsx\nimport { Suspense, useDeferredValue } from 'react';\n\nconst DataScreen = () => {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  return (\n    <View>\n      <TextInput value={query} onChangeText={setQuery} />\n      <Suspense fallback={<LoadingSpinner />}>\n        <SearchResults query={deferredQuery} />\n      </Suspense>\n    </View>\n  );\n};\n```\n\n## Code Examples\n\n### Slow Component Optimization\n\n```jsx\n// Without Concurrent React - UI freezes\nconst SlowSearch = () => {\n  const [query, setQuery] = useState('');\n  \n  return (\n    <>\n      <TextInput value={query} onChangeText={setQuery} />\n      <SlowComponent query={query} /> {/* Blocks every keystroke */}\n    </>\n  );\n};\n\n// With Concurrent React - UI stays responsive  \nconst FastSearch = () => {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  return (\n    <>\n      <TextInput value={query} onChangeText={setQuery} />\n      <SlowComponent query={deferredQuery} />\n    </>\n  );\n};\n\n// Important: Wrap SlowComponent in memo to prevent re-renders from parent\nconst SlowComponent = memo(({ query }) => {\n  // Expensive computation here\n});\n```\n\n### Automatic Batching (React 18+)\n\nReact 18 automatically batches state updates:\n\n```jsx\n// Before React 18 - 2 re-renders\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // Rendered twice\n}, 1000);\n\n// React 18+ - 1 re-render (automatic batching)\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // Rendered once!\n}, 1000);\n```\n\n## When to Use Which\n\n| Scenario | Solution |\n|----------|----------|\n| Single value drives expensive render | `useDeferredValue` |\n| Multiple state updates, some non-critical | `useTransition` |\n| Need loading indicator for transition | `useTransition` (has `isPending`) |\n| Data fetching with loading states | `Suspense` + `useDeferredValue` |\n| Simple parent-to-child value deferral | `useDeferredValue` |\n\n## Important Considerations\n\n1. **Wrap expensive components in `memo()`**: Without memoization, the component re-renders from parent anyway.\n\n2. **Use with New Architecture**: Concurrent features require New Architecture in React Native.\n\n3. **Don't overuse**: Only defer truly expensive work. Adding complexity for fast components is counterproductive.\n\n## Common Pitfalls\n\n- **Forgetting memo()**: `useDeferredValue` is useless if child re-renders from parent\n- **Using for simple state**: Overhead isn't worth it for cheap updates\n- **Expecting faster computation**: These hooks don't make code faster, they prioritize what runs when\n\n## Related Skills\n\n- [js-profile-react.md](./js-profile-react.md) - Identify slow components\n- [js-react-compiler.md](./js-react-compiler.md) - Automatic memoization\n- [js-lists-flatlist-flashlist.md](./js-lists-flatlist-flashlist.md) - For list-specific optimizations\n",
        "skills/react-native/references/js-lists-flatlist-flashlist.md": "---\ntitle: Higher-Order Lists\nimpact: CRITICAL\ntags: lists, flatlist, flashlist, scrollview, virtualization\n---\n\n# Skill: Higher-Order Lists\n\nReplace ScrollView with FlatList or FlashList for performant large list rendering.\n\n## Quick Pattern\n\n**Incorrect:**\n\n```jsx\n<ScrollView>\n  {items.map((item) => <Item key={item.id} {...item} />)}\n</ScrollView>\n```\n\n**Correct:**\n\n```jsx\n<FlashList\n  data={items}\n  keyExtractor={(item) => item.id}\n  renderItem={({ item }) => <Item {...item} />}\n  estimatedItemSize={50}\n/>\n```\n\n## When to Use\n\n- Rendering more than 10-20 items in a list\n- List scrolling is choppy or laggy\n- App freezes when loading list data\n- Memory usage spikes with long lists\n\n## Prerequisites\n\n- `@shopify/flash-list` for FlashList (recommended)\n- Understanding of list virtualization\n\n## Step-by-Step Instructions\n\n### 1. Identify the Problem\n\n![FPS Drop Graph](images/fps-drop-graph.png)\n\nThe FPS graph shows a severe performance problem during list rendering:\n- FPS starts at ~60 (smooth)\n- Drops to ~3 FPS during heavy list operation\n- Recovers after rendering completes\n\n```jsx\n// BAD: ScrollView renders ALL items at once\nconst BadList = ({ items }) => (\n  <ScrollView>\n    {items.map((item, index) => (\n      <View key={index}>\n        <Text>{item}</Text>\n      </View>\n    ))}\n  </ScrollView>\n);\n```\n\nWith 5000 items, this creates 5000 views immediately, causing:\n- Multi-second freeze\n- FPS drop to 0\n- High memory usage\n\n### 2. Replace with FlatList\n\n```jsx\nimport { FlatList } from 'react-native';\n\nconst BetterList = ({ items }) => {\n  const renderItem = ({ item }) => (\n    <View>\n      <Text>{item}</Text>\n    </View>\n  );\n  \n  return (\n    <FlatList\n      data={items}\n      renderItem={renderItem}\n      keyExtractor={(item, index) => index.toString()}\n    />\n  );\n};\n```\n\nFlatList only renders visible items + buffer (windowing).\n\n### 3. Optimize FlatList with getItemLayout\n\nFor fixed-height items, skip layout measurement:\n\n```jsx\nconst ITEM_HEIGHT = 50;\n\nconst OptimizedList = ({ items }) => {\n  const renderItem = ({ item }) => (\n    <View style={{ height: ITEM_HEIGHT }}>\n      <Text>{item}</Text>\n    </View>\n  );\n  \n  const getItemLayout = (_, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  });\n  \n  return (\n    <FlatList\n      data={items}\n      renderItem={renderItem}\n      keyExtractor={(item, index) => index.toString()}\n      getItemLayout={getItemLayout}\n    />\n  );\n};\n```\n\n### 4. Upgrade to FlashList (Best Performance)\n\n```bash\nnpm install @shopify/flash-list\n```\n\n```jsx\nimport { FlashList } from '@shopify/flash-list';\n\nconst BestList = ({ items }) => {\n  const renderItem = ({ item }) => (\n    <View style={{ height: 50 }}>\n      <Text>{item}</Text>\n    </View>\n  );\n  \n  return (\n    <FlashList\n      data={items}\n      renderItem={renderItem}\n      estimatedItemSize={50}  // Required for FlashList\n    />\n  );\n};\n```\n\n**FlashList advantages:**\n- Recycles views instead of creating new ones\n- 78/100 vs 25/100 performance score in benchmarks\n- Smoother scrolling at ~54 FPS vs lower for FlatList\n\n## Code Examples\n\n### Variable Height Items\n\n```jsx\n// Calculate average for estimatedItemSize\n// Items are 50px, 100px, 150px\n// Average: (50 + 100 + 150) / 3 = 100px\n\n<FlashList\n  data={items}\n  renderItem={renderItem}\n  estimatedItemSize={100}\n/>\n```\n\n### Mixed Item Types\n\n```jsx\n<FlashList\n  data={items}\n  renderItem={({ item }) => {\n    if (item.type === 'header') return <Header {...item} />;\n    if (item.type === 'product') return <Product {...item} />;\n    return <DefaultItem {...item} />;\n  }}\n  getItemType={(item) => item.type}  // Helps recycling\n  estimatedItemSize={80}\n/>\n```\n\n### FlatList Optimizations (if not using FlashList)\n\n```jsx\n<FlatList\n  data={items}\n  renderItem={renderItem}\n  // Performance props\n  removeClippedSubviews={true}\n  maxToRenderPerBatch={10}\n  updateCellsBatchingPeriod={50}\n  initialNumToRender={10}\n  windowSize={5}\n  // Avoid re-renders\n  keyExtractor={(item) => item.id}\n  extraData={selectedId}  // Only when selection changes\n/>\n```\n\n## Performance Comparison\n\n| Component | 5000 Items Load | Scroll FPS | Memory |\n|-----------|-----------------|------------|--------|\n| ScrollView | 1-3 seconds freeze | < 30 | High |\n| FlatList | ~100ms | ~45 | Medium |\n| FlashList | ~50ms | ~54 | Low |\n\n## Decision Matrix\n\n| Scenario | Recommendation |\n|----------|---------------|\n| < 20 static items | ScrollView OK |\n| 20-100 items | FlatList minimum |\n| > 100 items | FlashList |\n| Complex item layouts | FlashList with `getItemType` |\n| Fixed height items | Add `getItemLayout` or `estimatedItemSize` |\n\n## Common Pitfalls\n\n- **Inline renderItem functions**: Causes re-renders. Define outside or use `useCallback`.\n- **Missing keyExtractor**: Use unique IDs, not array index when possible.\n- **Ignoring estimatedItemSize warning**: FlashList warns if not set. Always provide it.\n- **Heavy item components**: Keep list items light. Move side effects out.\n\n## Related Skills\n\n- [js-profile-react.md](./js-profile-react.md) - Profile list rendering\n- [js-measure-fps.md](./js-measure-fps.md) - Measure scroll performance\n",
        "skills/react-native/references/js-measure-fps.md": "---\ntitle: Measure JS FPS\nimpact: HIGH\ntags: fps, performance, monitoring, flashlight\n---\n\n# Skill: Measure JS FPS\n\nMonitor and measure JavaScript frame rate to quantify app smoothness and identify performance regressions.\n\n## Quick Command\n\n```bash\n# Method 1: Built-in Perf Monitor\n# Shake device → Dev Menu → \"Perf Monitor\"\n\n# Method 2: Flashlight (Android, detailed reports)\ncurl https://get.flashlight.dev | bash\nflashlight measure\n```\n\n## When to Use\n\n- Animations feel choppy or janky\n- Scrolling is not smooth\n- Need baseline FPS metrics before/after optimization\n- Want to compare performance across builds\n\n## Prerequisites\n\n- React Native app running on device/simulator\n- For Flashlight: Android device (iOS not supported)\n\n> **Note**: This skill involves interpreting visual output (FPS graphs, performance overlays). AI agents cannot yet process screenshots autonomously. Use this as a guide while reviewing metrics manually, or await MCP-based visual feedback integration (see roadmap).\n\n## Step-by-Step Instructions\n\n### Method 1: React Perf Monitor (Quick Check)\n\n1. Open Dev Menu:\n   - iOS Simulator: `Ctrl + Cmd + Z` or Device > Shake\n   - Android Emulator: `Cmd + M` (Mac) / `Ctrl + M` (Windows)\n\n2. Select **\"Perf Monitor\"**\n\n3. Observe the overlay showing:\n   - **UI (Main) thread FPS** - Native rendering\n   - **JS thread FPS** - JavaScript execution\n   - **RAM usage**\n\n4. Hide with \"Hide Perf Monitor\" from Dev Menu\n\n**Interpretation:**\n- **60 FPS** = Smooth (16.6ms per frame)\n- **< 60 FPS** = Dropping frames\n- **120 FPS** target for high refresh rate devices (8.3ms per frame)\n\n### Method 2: Flashlight (Automated Benchmarking)\n\n> Android only. Provides detailed reports and JSON export.\n\n![Flashlight FlatList vs FlashList Comparison](images/flashlight-flatlist-vs-flashlist.png)\n\nFlashlight shows comparative performance data:\n- **Score** (0-100): Overall performance rating (higher is better)\n- **Average FPS**: Target 60 FPS for smooth scrolling\n- **FPS Graph**: Real-time frame rate over test duration\n- **CPU/RAM metrics**: Resource consumption\n\nThe image shows FlatList (score: 3) vs FlashList (score: 67) - a dramatic difference visible in both the score and FPS graph.\n\n**Installation:**\n\n```bash\n# Install Flashlight CLI\ncurl https://get.flashlight.dev | bash\n```\n\n**Usage:**\n\n```bash\n# Start measuring (app must be running on Android)\nflashlight measure\n```\n\n**Features:**\n- Real-time FPS graph\n- Average FPS calculation\n- CPU and RAM metrics\n- Overall performance score\n- JSON export for CI comparison\n\n### Important: Disable Dev Mode\n\n**Always disable development mode for accurate measurements:**\n\n**Android:**\n1. Open Dev Menu\n2. Settings > JS Dev Mode → **OFF**\n\n**iOS (React Native CLI):**\n```bash\n# Run Metro in production mode\nnpx react-native start --reset-cache\n# Then build release variant\n```\n\n**Expo:**\n```bash\n# Start Metro without dev mode\nnpx expo start --no-dev --minify\n# For accurate measurements, use EAS Build for release testing\n```\n\n## Code Examples\n\n### Identify FPS Drop Source\n\nIf **UI FPS drops but JS FPS is fine:**\n- Native rendering issue\n- Too many views/complex layouts\n- Heavy native animations\n\nIf **JS FPS drops but UI FPS is fine:**\n- JavaScript computation blocking\n- Expensive React re-renders\n- Look for `longRunningFunction` patterns\n\nIf **Both drop:**\n- Mixed issue, start with JS profiling\n\n### Target Frame Budgets\n\n```javascript\n// 60 FPS = 16.6ms per frame\nconst FRAME_BUDGET_60 = 16.6;\n\n// 120 FPS = 8.3ms per frame  \nconst FRAME_BUDGET_120 = 8.3;\n\n// If your function takes longer, it will drop frames\nconst longRunningFunction = () => {\n  let i = 0;\n  while (i < 1000000000) { // This blocks for seconds!\n    i++;\n  }\n};\n```\n\n## Interpreting Results\n\n| FPS Range | User Perception | Action |\n|-----------|-----------------|--------|\n| 55-60 | Smooth | Acceptable |\n| 45-55 | Slight stutter | Investigate |\n| 30-45 | Noticeable jank | Optimize required |\n| < 30 | Very choppy | Critical fix needed |\n\n## Flashlight CI Integration\n\n```bash\n# Export measurements to JSON\nflashlight measure --output results.json\n\n# Compare builds\nflashlight compare baseline.json current.json\n```\n\n## Common Pitfalls\n\n- **Measuring in dev mode**: Results will be artificially slow\n- **Not using real device**: Simulators don't reflect real performance\n- **Ignoring UI thread**: React Native has two threads - JS issues don't always show on UI thread\n- **Single measurement**: Run multiple times, FPS varies\n\n## Related Skills\n\n- [js-profile-react.md](./js-profile-react.md) - Find what's causing FPS drops\n- [js-animations-reanimated.md](./js-animations-reanimated.md) - Fix animation-related drops\n- [js-lists-flatlist-flashlist.md](./js-lists-flatlist-flashlist.md) - Fix scroll-related drops\n",
        "skills/react-native/references/js-memory-leaks.md": "---\ntitle: Hunt JS Memory Leaks\nimpact: MEDIUM\ntags: memory, leaks, profiling, cleanup\n---\n\n# Skill: Hunt JS Memory Leaks\n\nFind and fix JavaScript memory leaks using React Native DevTools memory profiling.\n\n## Quick Pattern\n\n**Incorrect (listener not cleaned up):**\n\n```jsx\nuseEffect(() => {\n  const sub = EventEmitter.addListener('event', handler);\n  // Missing cleanup!\n}, []);\n```\n\n**Correct (proper cleanup):**\n\n```jsx\nuseEffect(() => {\n  const sub = EventEmitter.addListener('event', handler);\n  return () => sub.remove();\n}, []);\n```\n\n## When to Use\n\n- App memory usage grows over time\n- App crashes after extended use\n- Navigating between screens increases memory\n- Suspecting event listeners or timers not cleaned up\n\n## Prerequisites\n\n- React Native DevTools accessible\n- App running in development mode\n\n## Step-by-Step Instructions\n\n### 1. Open Memory Profiler\n\n1. Launch React Native DevTools (press `j` in Metro)\n2. Go to **Memory** tab\n3. Select **\"Allocation instrumentation on timeline\"**\n\n### 2. Record Memory Allocations\n\n1. Click **\"Start\"** at the bottom\n2. Perform actions that might leak (navigate, trigger events, etc.)\n3. Wait 10-30 seconds\n4. Click **\"Stop\"**\n\n### 3. Analyze the Timeline\n\n**Key indicators:**\n- **Blue bars** = Memory allocated\n- **Gray bars** = Memory freed (garbage collected)\n- **Blue bars that stay blue** = Potential leak!\n\n### 4. Investigate Leaking Objects\n\n![Memory Heap Snapshot](images/memory-heap-snapshot.png)\n\nThe Memory tab shows:\n- **Timeline** (top): Blue bars = allocations, select time range to filter\n- **Summary view** (bottom): Lists constructors with allocation counts\n\n**Key columns:**\n- **Constructor**: Object type (e.g., `JSObject`, `Function`, `(string)`)\n- **Count**: Number of instances (×85000 = 85,000 objects)\n- **Shallow Size**: Memory of the object itself\n- **Retained Size**: Memory freed if object is deleted (including references)\n\n**Red flag**: Large retained size % with small shallow size % = closures or references holding large objects.\n\n**To investigate:**\n1. Click on a blue spike in the timeline\n2. Look at the Constructor list below\n3. Check **Shallow size** vs **Retained size**\n4. Expand constructors to see individual allocations\n5. Click to see the exact source location\n\n### 5. Verify the Fix\n\nAfter fixing, re-profile. All bars should turn gray (except the most recent).\n\n## Code Examples\n\n### Common Leak Patterns\n\n**1. Listeners Not Cleaned Up:**\n\n```jsx\n// BAD: Memory leak\nconst BadEventComponent = () => {\n  useEffect(() => {\n    const subscription = EventEmitter.addListener('myEvent', handleEvent);\n    // Missing cleanup!\n  }, []);\n  \n  return <Text>Listening...</Text>;\n};\n\n// GOOD: Proper cleanup\nconst GoodEventComponent = () => {\n  useEffect(() => {\n    const subscription = EventEmitter.addListener('myEvent', handleEvent);\n    return () => subscription.remove(); // Cleanup!\n  }, []);\n  \n  return <Text>Listening...</Text>;\n};\n```\n\n**2. Timers Not Cleared:**\n\n```jsx\n// BAD: Memory leak\nconst BadTimerComponent = () => {\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n    // Missing cleanup!\n  }, []);\n};\n\n// GOOD: Proper cleanup\nconst GoodTimerComponent = () => {\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n    return () => clearInterval(timer); // Cleanup!\n  }, []);\n};\n```\n\n**3. Closures Capturing Large Objects:**\n\n```jsx\n// BAD: Closure captures entire array\nclass BadClosureExample {\n  private largeData = new Array(1000000).fill('data');\n  \n  createLeakyFunction() {\n    return () => this.largeData.length; // Captures this.largeData\n  }\n}\n\n// GOOD: Only capture what's needed\nclass GoodClosureExample {\n  private largeData = new Array(1000000).fill('data');\n  \n  createEfficientFunction() {\n    const length = this.largeData.length; // Extract value\n    return () => length; // Only captures primitive\n  }\n}\n```\n\n**4. Global Arrays Growing:**\n\n```jsx\n// BAD: Global array never cleared\nlet leakyClosures = [];\n\nconst createLeak = () => {\n  const data = generateLargeData();\n  leakyClosures.push(() => data); // Keeps growing!\n};\n\n// GOOD: Clear when done or use WeakRef\nconst createNoLeak = () => {\n  const data = generateLargeData();\n  const closure = () => data;\n  // Use it and let it be garbage collected\n  return closure;\n};\n```\n\n## Memory Profiler Metrics\n\n| Metric | Meaning |\n|--------|---------|\n| **Shallow size** | Memory held by the object itself |\n| **Retained size** | Memory freed if object is deleted (includes references) |\n\n**Large retained size with small shallow size** = Object holding references to other large objects (common in closures).\n\n## Common Pitfalls\n\n- **Not forcing GC**: GC runs periodically. Allocate something else to trigger collection before concluding there's a leak.\n- **Ignoring gray bars**: Gray = properly collected. Only blue bars that persist are leaks.\n- **Missing useEffect cleanup**: Most common React Native leak source.\n\n## Related Skills\n\n- [native-memory-leaks.md](./native-memory-leaks.md) - Native-side memory leaks\n- [js-profile-react.md](./js-profile-react.md) - General profiling\n",
        "skills/react-native/references/js-profile-react.md": "---\ntitle: Profile React Performance\nimpact: MEDIUM\ntags: profiling, devtools, re-renders, flamegraph\n---\n\n# Skill: Profile React Performance\n\nIdentify unnecessary re-renders and performance bottlenecks in React Native apps using React Native DevTools.\n\n## Quick Command\n\n```bash\n# Open React Native DevTools (press 'j' in Metro terminal)\n# Or shake device → \"Open DevTools\"\n# Go to Profiler tab → Start profiling → Perform actions → Stop\n```\n\n## When to Use\n\n- App feels sluggish or janky during interactions\n- Need to identify which components re-render unnecessarily\n- Investigating slow list scrolling or form inputs\n- Before applying memoization or state management changes\n\n## Prerequisites\n\n- React Native DevTools accessible (press `j` in Metro or use Dev Menu)\n- App running in development mode\n- React DevTools version 6.0.1+ for React Compiler support\n\n> **Note**: This skill involves interpreting visual profiler output (flame graphs, component highlighting). AI agents cannot yet process screenshots autonomously. Use this as a guide while reviewing the profiler UI manually, or await MCP-based visual feedback integration (see roadmap).\n\n## Step-by-Step Instructions\n\n### 1. Open React Native DevTools\n\n```bash\n# Option A: Press 'j' in Metro terminal (works with both RN CLI and Expo)\n# Option B: Shake device / Cmd+D (iOS) / Cmd+M (Android) → \"Open DevTools\"\n# Expo: Also accessible via Expo DevTools in browser\n```\n\n### 2. Configure Profiler Settings\n\n1. Go to **Profiler** tab\n2. Click gear icon (⚙️) for settings\n3. Enable:\n   - \"Highlight updates when components render\"\n   - \"Record why each component rendered while profiling\"\n\n### 3. Record a Profiling Session\n\n```\n1. Click \"Start profiling\" (blue circle) or \"Reload and start profiling\"\n2. Perform the interaction you want to analyze\n3. Click \"Stop profiling\"\n```\n\n**Use \"Reload and start profiling\"** for startup performance analysis.\n\n### 4. Analyze the Flame Graph\n\n![React DevTools Flamegraph](images/devtools-flamegraph.png)\n\nThe flame graph shows component render hierarchy with timing:\n\n**Color indicators:**\n- **Yellow components**: Most time spent rendering (focus here)\n- **Green components**: Fast/memoized\n- **Gray components**: Did not render\n\n**Right panel shows \"Why did this render?\":**\n- Props changed (shows which prop, e.g., `children`, `onPress`)\n- Rendered at timestamps with duration (e.g., \"3.7s for 0.9ms\")\n\n**Click on a component to see:**\n- Why it rendered (hook change, props change, parent re-render)\n- Render duration\n- Child components affected\n\n### 5. Use Ranked View for Bottom-Up Analysis\n\nClick \"Ranked\" tab to see components sorted by render time (slowest first).\n\n### 6. Profile JavaScript CPU\n\nFor non-React performance issues:\n\n1. Go to **JavaScript Profiler** tab (enable in settings if hidden)\n2. Click \"Start\" to record\n3. Perform actions\n4. Click \"Stop\"\n5. Use **Heavy (Bottom Up)** view to find slowest functions\n\n## Code Examples\n\n### Before: Unnecessary Re-renders\n\n```jsx\nconst App = () => {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <View>\n      <Text>{count}</Text>\n      {/* Button re-renders on every count change */}\n      <Button onPress={() => setCount(count + 1)} title=\"Press\" />\n    </View>\n  );\n};\n\nconst Button = ({onPress, title}) => (\n  <Pressable onPress={onPress}>\n    <Text>{title}</Text>\n  </Pressable>\n);\n```\n\n### After: Memoized\n\n```jsx\nconst App = () => {\n  const [count, setCount] = useState(0);\n  const onPressHandler = useCallback(() => setCount(c => c + 1), []);\n  \n  return (\n    <View>\n      <Text>{count}</Text>\n      <Button onPress={onPressHandler} title=\"Press\" />\n    </View>\n  );\n};\n\nconst Button = memo(({onPress, title}) => (\n  <Pressable onPress={onPress}>\n    <Text>{title}</Text>\n  </Pressable>\n));\n```\n\n## Interpreting Results\n\n| Symptom | Likely Cause | Solution |\n|---------|--------------|----------|\n| Many yellow components | Cascading re-renders | Add memoization or use React Compiler |\n| \"Props changed\" on callbacks | Inline functions recreated | Use `useCallback` |\n| \"Parent component rendered\" | State too high in tree | Move state down or use atomic state |\n| Long JS thread block | Heavy computation | Move to background or use `useDeferredValue` |\n\n## Common Pitfalls\n\n- **Profiling in dev mode**: Always disable JS Dev Mode for accurate measurements (Settings > JS Dev Mode on Android)\n- **Not using production builds**: Some issues only appear with minified code\n- **Ignoring \"Why did this render?\"**: This tells you exactly what to fix\n\n## Related Skills\n\n- [js-react-compiler.md](./js-react-compiler.md) - Automatic memoization\n- [js-atomic-state.md](./js-atomic-state.md) - Reduce re-renders with Jotai/Zustand\n- [js-measure-fps.md](./js-measure-fps.md) - Quantify frame rate impact\n",
        "skills/react-native/references/js-react-compiler.md": "---\ntitle: React Compiler\nimpact: HIGH\ntags: memoization, react-compiler, memo, useMemo, useCallback\n---\n\n# Skill: React Compiler\n\nSet up React Compiler to automatically memoize components and eliminate unnecessary re-renders.\n\n## Quick Pattern\n\n**Before (manual memoization):**\n\n```jsx\nconst MemoizedButton = memo(({ onPress }) => <Pressable onPress={onPress} />);\nconst handler = useCallback(() => doSomething(), []);\n```\n\n**After (automatic with React Compiler):**\n\n```jsx\n// No memo/useCallback needed - compiler handles it\nconst Button = ({ onPress }) => <Pressable onPress={onPress} />;\nconst handler = () => doSomething();\n```\n\n## When to Use\n\n- Want automatic performance optimization without manual `memo`/`useMemo`/`useCallback`\n- Codebase follows Rules of React\n- React Native 0.76+ or Expo SDK 52+\n- Ready to remove boilerplate memoization code\n\n## Prerequisites\n\n- React 17+ (React 19 recommended for best compatibility)\n- Babel-based build system\n- Code follows [Rules of React](https://react.dev/reference/rules)\n\n## Step-by-Step Instructions\n\n### Step 1: Check Compatibility\n\nBefore enabling the compiler, verify your project is compatible:\n\n```bash\nnpx react-compiler-healthcheck@latest\n```\n\nThis checks if your app follows the Rules of React and identifies potential issues.\n\n### Step 2: Install React Compiler\n\n#### Expo Projects\n\n**SDK 54 and later** (simplified setup):\n\n```bash\nnpx expo install babel-plugin-react-compiler\n```\n\n**SDK 52-53**:\n\n```bash\nnpx expo install babel-plugin-react-compiler@beta react-compiler-runtime@beta\n```\n\nThen enable in your app config:\n\n```json\n// app.json\n{\n  \"expo\": {\n    \"experiments\": {\n      \"reactCompiler\": true\n    }\n  }\n}\n```\n\n#### React Native (without Expo)\n\n```bash\nnpm install -D babel-plugin-react-compiler@latest\n```\n\nFor React Native < 0.78 (React < 19), also install the runtime:\n\n```bash\nnpm install react-compiler-runtime@beta\n```\n\n### Step 3: Configure Babel (React Native without Expo)\n\nFor non-Expo React Native projects, configure Babel manually:\n\n```javascript\n// babel.config.js\nconst ReactCompilerConfig = {\n  target: '19', // Use '18' for React Native < 0.78\n};\n\nmodule.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: ['module:@react-native/babel-preset'],\n    plugins: [\n      ['babel-plugin-react-compiler', ReactCompilerConfig], // Must run first!\n      // ... other plugins\n    ],\n  };\n};\n```\n\n> **Important**: React Compiler must run **first** in your Babel plugin pipeline. The compiler needs the original source information for proper analysis.\n\n### Step 4: Set Up ESLint (Recommended)\n\nThe ESLint plugin helps identify code that can't be optimized and enforces the Rules of React.\n\n#### Expo Projects\n\n```bash\nnpx expo lint  # Ensures ESLint is set up\nnpx expo install eslint-plugin-react-compiler -- -D\n```\n\nConfigure ESLint:\n\n```javascript\n// .eslintrc.js\nconst { defineConfig } = require('eslint/config');\nconst expoConfig = require('eslint-config-expo/flat');\nconst reactCompiler = require('eslint-plugin-react-compiler');\n\nmodule.exports = defineConfig([\n  expoConfig,\n  reactCompiler.configs.recommended,\n  {\n    ignores: ['dist/*'],\n  },\n]);\n```\n\n#### React Native (without Expo)\n\n```bash\nnpm install -D eslint-plugin-react-hooks@latest\n```\n\nThe compiler rules are available in the `recommended-latest` preset. Follow the [eslint-plugin-react-hooks installation instructions](https://github.com/facebook/react/tree/main/packages/eslint-plugin-react-hooks).\n\n### Step 5: Verify Optimizations\n\nOpen React DevTools. Optimized components show a `Memo ✨` badge.\n\nYou can also verify by checking build output—compiled code includes automatic memoization:\n\n```javascript\nimport { c as _c } from 'react/compiler-runtime';\n\nexport default function MyApp() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for('react.memo_cache_sentinel')) {\n    t0 = <div>Hello World</div>;\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return t0;\n}\n```\n\n**Note**: React Native 0.76+ includes DevTools with Memo badge support by default. For older versions or third-party debuggers with version mismatches, you may need to override `react-devtools-core` in `package.json`.\n\n## Incremental Adoption\n\nYou can incrementally adopt React Compiler using two strategies:\n\n### Strategy 1: Limit to Specific Directories\n\nConfigure the Babel plugin to only run on specific files, e.g. `src/path/to/dir` in the following examples:\n\n**Expo** (create `babel.config.js` with `npx expo customize babel.config.js`):\n\n```javascript\n// babel.config.js\nmodule.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\n      [\n        'babel-preset-expo',\n        {\n          'react-compiler': {\n            sources: (filename) => {\n              return filename.includes('src/path/to/dir');\n            },\n          },\n        },\n      ],\n    ],\n  };\n};\n```\n\n**React Native (without Expo)**:\n\n```javascript\n// babel.config.js\nconst ReactCompilerConfig = {\n  target: '19',\n  sources: (filename) => {\n    return filename.includes('src/path/to/dir');\n  },\n};\n\nmodule.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: ['module:@react-native/babel-preset'],\n    plugins: [['babel-plugin-react-compiler', ReactCompilerConfig]],\n  };\n};\n```\n\nAfter changing `babel.config.js`, restart Metro with cache cleared:\n\n```bash\n# Expo\nnpx expo start --clear\n\n# React Native CLI\nnpx react-native start --reset-cache\n```\n\n### Strategy 2: Opt Out Specific Components\n\nUse the `\"use no memo\"` directive to skip optimization for specific components or files:\n\n```jsx\nfunction ProblematicComponent() {\n  'use no memo';\n\n  return <Text>Will not be optimized</Text>;\n}\n```\n\nThis is useful for temporarily opting out components that cause issues. Fix the underlying problem and remove the directive once resolved.\n\n## How It Works\n\nThe compiler transforms your code to automatically cache values:\n\n**Before (your code):**\n\n```jsx\nexport default function MyApp() {\n  const [value, setValue] = useState('');\n  return (\n    <TextInput onChangeText={() => setValue(value)}>Hello World</TextInput>\n  );\n}\n```\n\n**After (compiled output):**\n\n```jsx\nimport { c as _c } from 'react/compiler-runtime';\n\nexport default function MyApp() {\n  const $ = _c(2); // Cache with 2 slots\n  const [value, setValue] = useState('');\n\n  let t0;\n  if ($[0] !== value) {\n    t0 = (\n      <TextInput onChangeText={() => setValue(value)}>Hello World</TextInput>\n    );\n    $[0] = value;\n    $[1] = t0;\n  } else {\n    t0 = $[1]; // Return cached JSX\n  }\n  return t0;\n}\n```\n\n## Code Examples\n\n### React Compiler Playground\n\nTest transformations at [React Playground](https://playground.react.dev/).\n\n### What Gets Optimized\n\n```jsx\n// Components - auto-memoized\nconst Button = ({ onPress, label }) => (\n  <Pressable onPress={onPress}>\n    <Text>{label}</Text>\n  </Pressable>\n);\n\n// Callbacks - auto-cached (no useCallback needed)\nconst handlePress = () => {\n  console.log('pressed');\n};\n\n// Expensive computations - auto-cached (no useMemo needed)\nconst filtered = items.filter((item) => item.active);\n```\n\n### What Breaks Compilation\n\n```jsx\n// BAD: Mutating props\nconst BadComponent = ({ items }) => {\n  items.push('new item'); // Mutation!\n  return <List data={items} />;\n};\n\n// BAD: Mutating during render\nconst BadMutation = () => {\n  const [items, setItems] = useState([]);\n  items.push('new'); // Mutation during render!\n  return <List data={items} />;\n};\n\n// BAD: Non-idempotent render\nlet counter = 0;\nconst BadRender = () => {\n  counter++; // Side effect during render!\n  return <Text>{counter}</Text>;\n};\n```\n\n## Should You Remove Manual Memoization?\n\nImprovements are primarily automatic. You can remove instances of `useCallback`, `useMemo`, and `React.memo` in favor of automatic memoization once the compiler is working correctly in your project.\n\n**Note**: Class components will not be optimized. Migrate to function components for full benefits.\n\nExpo's implementation only runs on application code (not node_modules), and only when bundling for the client (disabled in server rendering).\n\n## Expected Performance Improvements\n\nTesting on Expensify app showed:\n\n- **4.3% improvement** in Chat Finder TTI\n- Significant reduction in cascading re-renders\n- Most impact on apps without existing manual optimization\n\nAlready heavily optimized apps may see marginal gains.\n\n## Common Pitfalls\n\n- **Not fixing ESLint errors first**: When ESLint reports an error, the compiler skips that component—this is safe but means you miss optimization\n- **Expecting it to fix bad patterns**: Compiler optimizes good code, doesn't fix bad code\n- **Forgetting shallow comparison**: Like `memo`, compiler uses shallow comparison for objects/arrays\n- **Not running healthcheck**: Always run `npx react-compiler-healthcheck@latest` before enabling\n\n## Related Skills\n\n- [js-profile-react.md](./js-profile-react.md) - Verify optimization impact\n- [js-atomic-state.md](./js-atomic-state.md) - Alternative for state-related re-renders\n",
        "skills/react-native/references/js-uncontrolled-components.md": "---\ntitle: Uncontrolled Components\nimpact: HIGH\ntags: textinput, forms, controlled, uncontrolled\n---\n\n# Skill: Uncontrolled Components\n\nFix TextInput synchronization and flickering issues by using uncontrolled component pattern.\n\n## Quick Pattern\n\n**Before (controlled - may flicker on legacy arch):**\n\n```jsx\n<TextInput value={text} onChangeText={setText} />\n```\n\n**After (uncontrolled - native owns state):**\n\n```jsx\n<TextInput defaultValue={text} onChangeText={setText} />\n```\n\n## When to Use\n\n- TextInput flickers or shows wrong characters during fast typing\n- Text input lags behind user input on low-end devices\n- Using legacy (non-New Architecture) React Native\n- Need maximum input responsiveness\n\n## Prerequisites\n\n- Understanding of React controlled vs uncontrolled components\n- TextInput component in use\n\n## Problem Description\n\n![Controlled TextInput Ping-Pong Communication](images/controlled-textinput-pingpong.png)\n\nThe diagram shows what happens when typing \"TEST\" with a controlled `TextInput`:\n\n1. User types \"T\" → `onChangeText('T')` fires\n2. React calls `setValue('T')` → native updates to \"T\"\n3. User types \"E\" → `onChangeText('TE')` fires\n4. React calls `setValue('TE')` → native updates to \"TE\"\n5. ...continues for each character\n\n**The problem**: Each character requires a round-trip between native and JavaScript. On legacy architecture, if React state update is slow, native may show intermediate states (flicker).\n\n**New Architecture note:** This issue is largely resolved in New Architecture, but uncontrolled pattern still provides best performance.\n\n## Step-by-Step Instructions\n\n### 1. Identify Controlled TextInput\n\n```jsx\n// Controlled - value prop syncs state to native\nconst ControlledInput = () => {\n  const [value, setValue] = useState('');\n  \n  return (\n    <TextInput\n      value={value}           // This causes sync issues\n      onChangeText={setValue}\n    />\n  );\n};\n```\n\n### 2. Convert to Uncontrolled\n\nRemove the `value` prop to make it uncontrolled:\n\n```jsx\n// Uncontrolled - native owns the state\nconst UncontrolledInput = () => {\n  const [value, setValue] = useState('');\n  \n  return (\n    <TextInput\n      defaultValue={value}     // Only sets initial value\n      onChangeText={setValue}  // Still updates React state\n    />\n  );\n};\n```\n\n### 3. Use Ref for Programmatic Control\n\nIf you need to read/set value programmatically:\n\n```jsx\nconst UncontrolledWithRef = () => {\n  const inputRef = useRef(null);\n  \n  const clearInput = () => {\n    inputRef.current?.clear();\n  };\n  \n  const getValue = () => {\n    // Use onChangeText to track value, or native methods\n  };\n  \n  return (\n    <TextInput\n      ref={inputRef}\n      defaultValue=\"\"\n      onChangeText={(text) => console.log('Current:', text)}\n    />\n  );\n};\n```\n\n## Code Examples\n\n### Full Migration Example\n\n**Before (Controlled):**\n\n```jsx\nconst SearchInput = () => {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  \n  const handleChange = (text) => {\n    setQuery(text);\n    fetchResults(text).then(setResults);\n  };\n  \n  return (\n    <View>\n      <TextInput\n        value={query}              // Remove this\n        onChangeText={handleChange}\n        placeholder=\"Search...\"\n      />\n      <ResultsList data={results} />\n    </View>\n  );\n};\n```\n\n**After (Uncontrolled):**\n\n```jsx\nconst SearchInput = () => {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  \n  const handleChange = (text) => {\n    setQuery(text);\n    fetchResults(text).then(setResults);\n  };\n  \n  return (\n    <View>\n      <TextInput\n        defaultValue=\"\"           // Initial value only\n        onChangeText={handleChange}\n        placeholder=\"Search...\"\n      />\n      <ResultsList data={results} />\n    </View>\n  );\n};\n```\n\n### When You Need Value Control\n\nFor input masking or validation that modifies input:\n\n```jsx\n// Option 1: Accept the controlled behavior (may flicker)\nconst MaskedInput = () => {\n  const [value, setValue] = useState('');\n  \n  const handleChange = (text) => {\n    // Phone mask: (123) 456-7890\n    const masked = maskPhone(text);\n    setValue(masked);\n  };\n  \n  return (\n    <TextInput\n      value={value}  // Necessary for masking\n      onChangeText={handleChange}\n    />\n  );\n};\n\n// Option 2: Use a native masked input library\n// react-native-masked-text handles this natively\n```\n\n## Decision Matrix\n\n| Scenario | Recommendation |\n|----------|---------------|\n| Simple text input | Uncontrolled |\n| Search/filter input | Uncontrolled |\n| Form with validation on submit | Uncontrolled |\n| Input masking (phone, credit card) | Controlled or native library |\n| Character-by-character validation | Controlled |\n| New Architecture app | Either works well |\n\n## Common Pitfalls\n\n- **Forgetting `defaultValue`**: Without it, input starts empty\n- **Trying to clear with state**: Use `ref.current.clear()` instead\n- **Mixing patterns**: Don't use both `value` and `defaultValue`\n\n## Related Skills\n\n- [js-profile-react.md](./js-profile-react.md) - Profile input performance\n- [js-concurrent-react.md](./js-concurrent-react.md) - Defer expensive search operations\n",
        "skills/react-native/references/native-measure-tti.md": "---\ntitle: Measure TTI (Time to Interactive)\nimpact: HIGH\ntags: tti, startup, performance, markers\n---\n\n# Skill: Measure TTI (Time to Interactive)\n\nSet up performance markers to measure app startup time and track TTI improvements.\n\n## Quick Command\n\n```bash\nnpm install react-native-performance\n```\n\n```tsx\n// Mark when screen is interactive\nimport performance from 'react-native-performance';\n\nuseEffect(() => {\n  performance.mark('screenInteractive');\n}, []);\n```\n\n## When to Use\n\n- App startup feels slow\n- Need baseline metrics for optimization\n- Setting up performance monitoring\n- Comparing TTI across releases\n\n## Prerequisites\n\n- `react-native-performance` library (recommended)\n\n```bash\nnpm install react-native-performance\n```\n\n> **Note**: This skill involves interpreting visual timeline diagrams and profiler output. AI agents cannot yet process screenshots autonomously. Use this as a guide while reviewing metrics manually, or await MCP-based visual feedback integration (see roadmap).\n\n## Understanding TTI\n\n**Time to Interactive**: Time from app icon tap to displaying usable content.\n\n### Startup Types\n\n| Type | Description | Measure? |\n|------|-------------|----------|\n| Cold | App not in memory, full init | ✅ Yes |\n| Warm | Process exists, activity recreated | ❌ Skip |\n| Hot | App in background, resumed | ❌ Skip |\n| Prewarmed (iOS) | iOS pre-initialized app | ❌ Filter out |\n\n**Only measure cold starts** for consistent metrics.\n\n## React Native Startup Pipeline\n\n![TTI Warm Start Diagram](images/tti-warm-start-diagram.png)\n\nThe diagram shows a warm start (app was in memory):\n\n**UI Thread:**\n1. `init native process` → `init native app`\n2. Gap while user is away (e.g., \"5h break from using the app\")\n3. `JS bundle load` → `RootView render`\n\n**JS Thread (runs in parallel):**\n- `init entrypoint` → `registerComponent`\n\n**Pipeline markers:**\n```\n1. Native Process Init     (nativeLaunchStart → nativeLaunchEnd)\n2. Native App Init         (appCreationStart → appCreationEnd)  \n3. JS Bundle Load          (runJSBundleStart → runJSBundleEnd)\n4. RN Root View Render     (contentAppeared)\n5. React App Interactive   (screenInteractive) ← This is TTI\n```\n\n## Step-by-Step Implementation\n\n### 1. Detect Cold Start\n\n**iOS (Swift):**\n\n```swift\nlet isColdStart = ProcessInfo.processInfo.environment[\"ActivePrewarm\"] != \"1\"\n```\n\n**Android (Kotlin):**\n\n```kotlin\nclass MainApplication : Application() {\n    var isColdStart = false\n    \n    override fun onCreate() {\n        super.onCreate()\n        \n        var firstPostEnqueued = true\n        Handler().post { firstPostEnqueued = false }\n        \n        registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacks {\n            override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {\n                unregisterActivityLifecycleCallbacks(this)\n                if (firstPostEnqueued && savedInstanceState == null) {\n                    isColdStart = true\n                }\n            }\n            // ... other callbacks\n        })\n    }\n}\n```\n\n### 2. Check Foreground State\n\nOnly measure when app starts in foreground.\n\n**iOS:**\n\n```swift\nvar isForegroundProcess = false\n\noverride func application(_ application: UIApplication, \n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    if application.applicationState == .active {\n        isForegroundProcess = true\n    }\n    return true\n}\n```\n\n**Android:**\n\n```kotlin\nprivate fun isForegroundProcess(): Boolean {\n    val processInfo = ActivityManager.RunningAppProcessInfo()\n    ActivityManager.getMyMemoryState(processInfo)\n    return processInfo.importance == IMPORTANCE_FOREGROUND\n}\n```\n\n### 3. Set Up Performance Markers\n\nUsing `react-native-performance`:\n\n**Native (iOS):**\n\n```swift\nimport ReactNativePerformance\n\nRNPerformance.sharedInstance().mark(\"appCreationStart\")\n// ... app init ...\nRNPerformance.sharedInstance().mark(\"appCreationEnd\")\n```\n\n**Native (Android):**\n\n```kotlin\nimport com.oblador.performance.RNPerformance\n\nRNPerformance.getInstance().mark(\"appCreationStart\")\n// ... app init ...\nRNPerformance.getInstance().mark(\"appCreationEnd\")\n```\n\n### 4. Mark Screen Interactive (JavaScript)\n\n```tsx\nimport performance from 'react-native-performance';\n\nexport default function HomeScreen() {\n    useEffect(() => {\n        // Mark when meaningful content is displayed\n        performance.mark('screenInteractive');\n    }, []);\n    \n    return <TabNavigator />;\n}\n```\n\n### 5. Collect and Report Metrics\n\n```tsx\nimport performance from 'react-native-performance';\n\nconst collectTTIMetrics = () => {\n    const entries = performance.getEntriesByType('mark');\n    \n    // Calculate durations\n    const metrics = {\n        nativeInit: getMarkDuration('nativeLaunchStart', 'nativeLaunchEnd'),\n        appCreation: getMarkDuration('appCreationStart', 'appCreationEnd'),\n        jsBundleLoad: getMarkDuration('runJSBundleStart', 'runJSBundleEnd'),\n        tti: getMarkDuration('nativeLaunchStart', 'screenInteractive'),\n    };\n    \n    // Send to analytics\n    analytics.track('app_performance', metrics);\n};\n```\n\n## Built-in Markers\n\n`react-native-performance` provides automatic markers:\n\n| Marker | Description |\n|--------|-------------|\n| `nativeLaunchStart` | Process start (pre-main) |\n| `nativeLaunchEnd` | Native init complete |\n| `runJSBundleStart` | JS bundle loading starts |\n| `runJSBundleEnd` | JS bundle loaded |\n| `contentAppeared` | RN root view rendered |\n\n## Listening to Native Events\n\n**iOS (JS Bundle Load):**\n\n```swift\nNotificationCenter.default.addObserver(\n    self,\n    selector: #selector(onJSLoad),\n    name: NSNotification.Name(\"RCTJavaScriptDidLoadNotification\"),\n    object: nil\n)\n```\n\n**Android (JS Bundle Load):**\n\n```kotlin\nReactMarker.addListener { name ->\n    when (name) {\n        RUN_JS_BUNDLE_START -> { /* mark start */ }\n        RUN_JS_BUNDLE_END -> { /* mark end */ }\n        CONTENT_APPEARED -> { /* mark content */ }\n    }\n}\n```\n\n## Target Metrics\n\n| Metric | Good | Acceptable | Needs Work |\n|--------|------|------------|------------|\n| TTI | < 2s | 2-4s | > 4s |\n| JS Bundle Load | < 500ms | 500ms-1s | > 1s |\n| Native Init | < 500ms | 500ms-1s | > 1s |\n\n**Note**: Targets vary by app complexity and device tier.\n\n## Common Pitfalls\n\n- **Including prewarmed starts**: iOS prewarming skews metrics\n- **Measuring warm/hot starts**: Only cold starts are meaningful\n- **Wrong screenInteractive placement**: Mark when truly interactive, not just mounted\n- **Not filtering background launches**: Push notifications can start app in background\n\n## Related Skills\n\n- [bundle-analyze-js.md](./bundle-analyze-js.md) - Reduce JS bundle load time\n- [native-profiling.md](./native-profiling.md) - Profile native init\n- [bundle-hermes-mmap.md](./bundle-hermes-mmap.md) - Improve Android TTI\n",
        "skills/react-native/references/native-memory-leaks.md": "---\ntitle: Hunt Native Memory Leaks\nimpact: MEDIUM\ntags: memory, leaks, xcode, instruments, profiler\n---\n\n# Skill: Hunt Native Memory Leaks\n\nFind native memory leaks using Xcode Leaks and Android Studio Memory Profiler.\n\n## Quick Command\n\n```bash\n# iOS: Profile with Leaks instrument\n# Xcode → Product → Profile (Cmd+I) → Leaks template\n\n# Android: Memory Profiler\n# Android Studio → Run → Profile → Track Memory Consumption\n```\n\n## When to Use\n\n- App memory grows despite JS profiler showing no leaks\n- Native modules suspected of leaking\n- Activity recreation causes memory growth (Android)\n- C++/Swift/Kotlin code under investigation\n\n## iOS: Xcode Leaks\n\n### Quick Check: Memory Report\n\n1. Run app via Xcode\n2. Open **Debug Navigator** (side panel)\n3. Click **Memory**\n4. Watch graph for continuous growth\n\n### Deep Analysis: Instruments Leaks\n\n![Xcode Instruments Templates](images/xcode-instruments-templates.png)\n\n1. **Xcode → Product → Profile** (or Cmd+I)\n2. Select **Leaks** template (highlighted with orange triangle icon in the grid)\n3. Click **Choose**\n4. Click **Record** (red circle)\n5. Use the app, perform suspect actions\n6. Stop recording\n\nThe template picker shows all available Instruments:\n- **Leaks**: Memory leak detection (what we need)\n- **Allocations**: All memory allocations over time\n- **Time Profiler**: CPU usage profiling\n- **Zombies**: Detect messages to deallocated objects\n\n### Analyzing Results\n\n**Red markers** = Leaked memory detected\n\nClick on leak to see:\n- **Leaked Object**: Type and size\n- **Responsible Library**: Which code leaked\n- **Responsible Frame**: Exact function\n- **Stack Trace**: Full call path (right panel)\n\n**Double-click function** to see source code.\n\n### Common iOS Leak: Missing delete\n\n```cpp\n// BAD: Memory leak\nvoid createNewStrings() {\n    std::string* str = new std::string(\"Hello\");\n    // Forgot delete str;\n}\n\n// GOOD: Fixed\nvoid createNewStrings() {\n    std::string* str = new std::string(\"Hello\");\n    // ... use str ...\n    delete str;\n}\n\n// BETTER: Use smart pointers\nvoid createNewStrings() {\n    auto str = std::make_unique<std::string>(\"Hello\");\n    // Automatically deleted\n}\n```\n\n## Android: Memory Profiler\n\n### Launch Profiler\n\n1. **Run → Profile** (or click Profile in toolbar)\n2. Or: **View → Tool Windows → Profiler**\n3. Select **\"Track Memory Consumption\"**\n\n### Recording\n\n1. Start the app\n2. Perform actions that might leak\n3. Watch memory graph for growth patterns\n\n### Analyzing Allocations\n\nMemory profiler shows:\n- **Allocations count**: Objects created\n- **Deallocations count**: Objects freed\n- **Live objects**: Still in memory\n\n**If allocations >> deallocations**, you have a leak.\n\n### Common Android Leak: Listener Not Removed\n\n```kotlin\n// BAD: Leaks MainActivity on config change\nclass MainActivity : AppCompatActivity(), Callback {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        EventManager.addListener(this)\n        // Never removed!\n    }\n}\n\n// GOOD: Remove listener\nclass MainActivity : AppCompatActivity(), Callback {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        EventManager.addListener(this)\n    }\n    \n    override fun onDestroy() {\n        EventManager.removeListener(this)\n        super.onDestroy()\n    }\n}\n```\n\n### Activity Recreation Test\n\nAndroid recreates activities on:\n- Screen rotation\n- Dark mode change\n- Locale change\n\n**Test**: Rotate device multiple times, check if old activities are freed.\n\nReact Native note: RN opts out via `android:configChanges` in manifest, but native code might not.\n\n## Debugging Workflow\n\n### iOS\n\n1. Profile with Instruments Leaks\n2. Trigger suspect actions repeatedly\n3. Wait for red leak markers\n4. Click to identify responsible frame\n5. Fix and re-test\n\n### Android\n\n1. Profile memory consumption\n2. Trigger suspect actions (rotate, navigate)\n3. Check allocation/deallocation counts\n4. Look for classes with 0 deallocations\n5. Fix and re-test\n\n## Code Fixes by Pattern\n\n### Reference Cycle (Swift)\n\n```swift\n// BAD\nclass Parent {\n    var child: Child?\n}\nclass Child {\n    var parent: Parent?  // Strong reference cycle\n}\n\n// GOOD\nclass Parent {\n    var child: Child?\n}\nclass Child {\n    weak var parent: Parent?  // Weak breaks cycle\n}\n```\n\n### Missing Cleanup (C++)\n\n```cpp\n// BAD\nvoid process() {\n    auto* data = new LargeData();\n    if (error) return;  // Leak!\n    delete data;\n}\n\n// GOOD: RAII with unique_ptr\nvoid process() {\n    auto data = std::make_unique<LargeData>();\n    if (error) return;  // Automatically cleaned up\n}\n```\n\n### Global Singleton Holding References (Kotlin)\n\n```kotlin\n// BAD: Holds strong references\nobject Cache {\n    private val items = mutableMapOf<String, Callback>()\n}\n\n// GOOD: Use weak references\nobject Cache {\n    private val items = mutableMapOf<String, WeakReference<Callback>>()\n}\n```\n\n## Verification\n\nAfter fixing:\n1. Re-run profiler\n2. Perform same actions\n3. Verify:\n   - iOS: No red leak markers\n   - Android: Allocations ≈ Deallocations\n\n## Common Pitfalls\n\n- **Testing in debug mode**: Some leaks only appear in release\n- **Not waiting for GC**: Force GC before concluding no leak\n- **Ignoring small leaks**: They add up over time\n- **Missing cleanup in invalidate()**: Turbo Modules need proper cleanup\n\n## Related Skills\n\n- [native-memory-patterns.md](./native-memory-patterns.md) - Understanding memory patterns\n- [js-memory-leaks.md](./js-memory-leaks.md) - JS-side leaks\n- [native-threading-model.md](./native-threading-model.md) - Module invalidation\n",
        "skills/react-native/references/native-memory-patterns.md": "---\ntitle: Native Memory Management\nimpact: MEDIUM\ntags: memory, c++, swift, kotlin, arc, smart-pointers\n---\n\n# Skill: Native Memory Management\n\nUnderstand memory management patterns in C++, Swift, and Kotlin for React Native native modules.\n\n## Quick Reference\n\n| Pattern | Languages | Mechanism |\n|---------|-----------|-----------|\n| Reference Counting | Swift, Obj-C, C++ (smart ptrs) | Count refs, free at zero |\n| Garbage Collection | Kotlin/Java, JavaScript | GC scans and frees unreachable |\n| Manual | C, C++ (raw pointers) | Explicit new/delete |\n\n**Key rule**: Use `std::unique_ptr`/`std::shared_ptr` in C++, `weak` for delegates in Swift.\n\n## When to Use\n\n- Writing native modules with manual memory management\n- Debugging native memory leaks\n- Interfacing C++ with Swift/Kotlin\n- Understanding reference counting vs garbage collection\n\n## Memory Management Patterns\n\n| Pattern | Languages | Mechanism |\n|---------|-----------|-----------|\n| Reference Counting | Swift, Obj-C, C++ (smart pointers) | Count refs, free at zero |\n| Garbage Collection | Kotlin/Java, JavaScript | GC scans and frees unreachable |\n| Manual | C, C++ (raw pointers) | Explicit new/delete |\n\n## C++ Smart Pointers\n\n### `std::unique_ptr` - Single Owner\n\n```cpp\n#include <memory>\n\nvoid takeOwnership(std::unique_ptr<std::string> s) {\n    std::cout << *s;\n    // Automatically deleted when function ends\n}\n\nint main() {\n    auto str = std::make_unique<std::string>(\"Hello\");\n    \n    // Can only be moved, not copied\n    takeOwnership(std::move(str));\n    // str is now empty\n    \n    return 0;\n}\n```\n\n### `std::shared_ptr` - Multiple Owners\n\n```cpp\nvoid useShared(std::shared_ptr<std::string> s) {\n    std::cout << *s;  // Reference count temporarily +1\n}\n\nvoid useReference(const std::shared_ptr<std::string>& s) {\n    std::cout << *s;  // No ref count change (passed by reference)\n}\n\nint main() {\n    auto str = std::make_shared<std::string>(\"Hello\");\n    \n    useShared(str);      // Copies pointer, ref count +1\n    useReference(str);   // No copy, ref count unchanged\n    \n    std::cout << *str;   // Still valid\n    return 0;\n}\n```\n\n### `std::weak_ptr` - Non-Owning Reference\n\n```cpp\nvoid useWeak(std::weak_ptr<std::string> weak) {\n    if (auto shared = weak.lock()) {  // Check if still exists\n        std::cout << *shared;\n    } else {\n        std::cout << \"Object destroyed\";\n    }\n}\n\nint main() {\n    auto str = std::make_shared<std::string>(\"Hello\");\n    std::weak_ptr<std::string> weak = str;  // No ref count increase\n    \n    useWeak(weak);  // Works\n    str.reset();    // Destroys object\n    useWeak(weak);  // \"Object destroyed\"\n    \n    return 0;\n}\n```\n\n## Swift ARC (Automatic Reference Counting)\n\n```swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    deinit { print(\"Deallocated\") }\n}\n\ndo {\n    let person1 = Person(name: \"John\")  // Ref count: 1\n    \n    do {\n        let person2 = person1  // Ref count: 2\n    }  // person2 out of scope, ref count: 1\n    \n}  // person1 out of scope, ref count: 0, \"Deallocated\"\n```\n\n### Breaking Reference Cycles with `weak`\n\n```swift\n// BAD: Reference cycle (memory leak)\nclass A {\n    var b: B?\n}\nclass B {\n    var a: A?  // Strong reference creates cycle\n}\n\n// GOOD: Use weak to break cycle\nclass A {\n    var b: B?\n}\nclass B {\n    weak var a: A?  // Weak reference, doesn't prevent deallocation\n}\n```\n\n## Kotlin/Android GC\n\n### WeakHashMap for Caches\n\n```kotlin\nval weakMap = WeakHashMap<String, String>()\n\nrun {\n    weakMap[String(\"temp\")] = \"value\"\n    println(weakMap.size)  // 1\n}\n\nSystem.gc()  // Force garbage collection\nThread.sleep(100)\n\nprintln(weakMap.size)  // 0 (key was collected)\n```\n\n### WeakReference for Callbacks\n\n```kotlin\nclass DataManager {\n    // Weak references to listeners prevent memory leaks\n    private val listeners = mutableListOf<WeakReference<DataListener>>()\n    \n    fun addListener(listener: DataListener) {\n        listeners.add(WeakReference(listener))\n    }\n    \n    fun notifyListeners(data: String) {\n        listeners.forEach { ref ->\n            ref.get()?.onDataChanged(data)\n        }\n    }\n}\n```\n\n## Common Memory Leak Sources\n\n### 1. Forgetting to Delete (C++)\n\n```cpp\n// BAD: Memory leak\nint main() {\n    std::string* str = new std::string(\"Hello\");\n    // Forgot to delete!\n    return 0;\n}\n\n// GOOD: Use smart pointers or stack allocation\nint main() {\n    auto str = std::make_unique<std::string>(\"Hello\");\n    // Automatically deleted\n    return 0;\n}\n```\n\n### 2. Reference Cycles (Swift/C++)\n\n```cpp\n// BAD: Cycle\nclass A { std::shared_ptr<B> b; };\nclass B { std::shared_ptr<A> a; };\n\n// GOOD: Break with weak_ptr\nclass A { std::shared_ptr<B> b; };\nclass B { std::weak_ptr<A> a; };\n```\n\n### 3. Unremoved Listeners (Kotlin)\n\n```kotlin\n// BAD: Listener never removed\nclass MyClass {\n    private val listener = object : Callback {\n        override fun onEvent() { /* ... */ }\n    }\n    \n    init {\n        EventManager.addListener(listener)\n        // Never removed!\n    }\n}\n\n// GOOD: Implement cleanup\nclass MyClass : AutoCloseable {\n    private val listener = object : Callback {\n        override fun onEvent() { /* ... */ }\n    }\n    \n    init {\n        EventManager.addListener(listener)\n    }\n    \n    override fun close() {\n        EventManager.removeListener(listener)\n    }\n}\n```\n\n## Swift `Unmanaged` (Advanced)\n\nFor C interop, manually manage reference counts:\n\n```swift\nlet obj = MyObject()                        // Ref count: 1\n\n// Increment manually\nlet unmanaged = Unmanaged.passRetained(obj) // Ref count: 2\n\n// Decrement and get object\nlet retrieved = unmanaged.takeRetainedValue() // Ref count: 1\n\n// Get raw pointer for C\nlet pointer = unmanaged.toOpaque()\n```\n\n**Rule**: Match `passRetained` with `takeRetainedValue`, `passUnretained` with `takeUnretainedValue`.\n\n## Best Practices Summary\n\n| Language | Best Practice |\n|----------|---------------|\n| C++ | Use smart pointers (`shared_ptr`, `unique_ptr`) |\n| Swift | Use `weak` for delegates, breaking cycles |\n| Kotlin | Implement `AutoCloseable`, use `WeakReference` |\n| All | Prefer stack over heap when possible |\n\n## Related Skills\n\n- [native-memory-leaks.md](./native-memory-leaks.md) - Find leaks with profilers\n- [native-turbo-modules.md](./native-turbo-modules.md) - Build memory-safe modules\n",
        "skills/react-native/references/native-platform-setup.md": "---\ntitle: Platform Differences\nimpact: MEDIUM\ntags: ios, android, xcode, gradle, cocoapods\n---\n\n# Skill: Platform Differences\n\nNavigate iOS and Android tooling, dependency management, and build systems in React Native.\n\n## Quick Reference\n\n| Platform | IDE | Package Manager | Build System |\n|----------|-----|-----------------|--------------|\n| JavaScript | VS Code | npm/yarn | Metro |\n| iOS | Xcode | CocoaPods | xcodebuild |\n| Android | Android Studio | Gradle | Gradle |\n\n```bash\n# Common commands\ncd ios && bundle exec pod install   # Install iOS deps\ncd android && ./gradlew clean       # Clean Android build\nxed ios/                            # Open Xcode\n```\n\n## When to Use\n\n- Setting up native development environment\n- Adding native dependencies\n- Debugging platform-specific issues\n- Understanding build processes\n\n## IDEs Overview\n\n| Platform | IDE | Key Features |\n|----------|-----|--------------|\n| JavaScript | VS Code, WebStorm | TypeScript, ESLint, Prettier |\n| iOS | Xcode | View Hierarchy, Instruments, Signing |\n| Android | Android Studio | Layout Inspector, Profiler, Logcat |\n\n## Dependency Management\n\n### JavaScript (npm/yarn)\n\n```bash\n# Install a React Native library\nnpm install react-native-bottom-tabs\n\n# Key files\npackage.json          # Dependencies and scripts\nnode_modules/         # Installed packages\npackage-lock.json     # Version lock\n```\n\n### iOS (CocoaPods)\n\n```bash\n# Install pods after npm install\ncd ios && bundle exec pod install\n\n# Key files\nios/Podfile           # Pod dependencies\nios/Pods/             # Installed pods (gitignored)\nios/*.xcworkspace     # Open this in Xcode (not .xcodeproj)\nGemfile               # Ruby/CocoaPods version\n```\n\n**Adding a native iOS dependency:**\n\n```ruby\n# ios/Podfile\ntarget 'MyApp' do\n  pod 'SDWebImage', '~> 5.0'\nend\n```\n\nVersion operators:\n- `~> 5.0` = ≥5.0, <6.0 (minor updates)\n- `~> 5.0.1` = ≥5.0.1, <5.1 (patch only)\n\n### Android (Gradle)\n\n```bash\n# Sync after adding dependencies\ncd android && ./gradlew clean\n\n# Key files\nandroid/build.gradle           # Project-level config\nandroid/app/build.gradle       # App dependencies\nandroid/gradle.properties      # Build flags\nandroid/gradlew                # Gradle wrapper\n```\n\n**Adding a native Android dependency:**\n\n```groovy\n// android/app/build.gradle\ndependencies {\n    implementation 'com.github.bumptech.glide:glide:4.12.0'\n}\n```\n\n## Building Projects\n\n### JavaScript (Metro)\n\nMetro handles JS transpilation via Babel:\n- Transforms modern JS to engine-compatible code\n- Handles module resolution\n- Creates JS bundle\n\n### iOS Build Pipeline\n\n1. **Source Compilation**: Swift/Obj-C → machine code (Clang/LLVM)\n2. **Linking**: Code + frameworks + CocoaPods\n3. **Signing**: Certificates and provisioning profiles\n4. **Packaging**: `.ipa` file\n\n### Android Build Pipeline\n\n1. **Compilation**: Java/Kotlin → `.class` files\n2. **DEX Conversion**: `.class` → `.dex` (Android Runtime)\n3. **Resource Processing**: XML, images, assets\n4. **Signing**: Keystore signing\n5. **Packaging**: `.apk` or `.aab` file\n\n## Running on Devices\n\n### iOS Simulator\n\n```bash\n# List simulators\nxcrun simctl list\n\n# Boot simulator\nxcrun simctl boot \"iPhone 15\"\n\n# Shutdown all\nxcrun simctl shutdown all\n\n# Quick launch Xcode\nxed ios/\n```\n\n### Android Emulator\n\n```bash\n# List available devices\nemulator -list-avds\n\n# Launch specific device\nemulator @Pixel_6_API_34\n\n# List connected devices\nadb devices\n```\n\n### Helpful Tools\n\n- **MiniSim**: Manage simulators from menu bar\n- **Expo Orbit**: Simulator management\n- **Android iOS Emulator (VS Code)**: IDE integration\n\n## Common Commands\n\n```bash\n# iOS\ncd ios && bundle exec pod install     # Install pods\nxed .                                  # Open Xcode\nxcrun simctl list                      # List simulators\n\n# Android  \ncd android && ./gradlew clean          # Clean build\n./gradlew tasks                        # List available tasks\n./gradlew assembleRelease              # Build release APK\n\n# React Native CLI\nnpx react-native start                 # Start Metro\nnpx react-native run-ios               # Run on iOS\nnpx react-native run-android           # Run on Android\n\n# Expo\nnpx expo start                         # Start Metro (Expo)\nnpx expo run:ios                       # Run on iOS (dev client)\nnpx expo run:android                   # Run on Android (dev client)\nnpx expo prebuild                      # Generate native projects\n```\n\n### Expo Notes\n\n- **Expo Go**: Limited native module support; use for JS-only development\n- **Dev Client**: Full native access; required for custom native code\n- **Prebuild**: Generates `ios/` and `android/` folders for native customization\n\n## Troubleshooting\n\n| Issue | Solution |\n|-------|----------|\n| Pod install fails | `bundle exec pod install --repo-update` |\n| Xcode build fails | Clean build folder (Cmd+Shift+K) |\n| Android Gradle sync fails | `./gradlew clean` then sync |\n| Can't find simulator | `xcrun simctl list` to verify name |\n| Metro cache issues | `npx react-native start --reset-cache` |\n\n## Related Skills\n\n- [native-profiling.md](./native-profiling.md) - Use IDE profilers\n- [native-turbo-modules.md](./native-turbo-modules.md) - Build native modules\n",
        "skills/react-native/references/native-profiling.md": "---\ntitle: Profile Native Code\nimpact: MEDIUM\ntags: xcode, instruments, android-studio, profiler\n---\n\n# Skill: Profile Native Code\n\nUse Xcode Instruments and Android Studio Profiler to identify native performance bottlenecks.\n\n## Quick Command\n\n```bash\n# iOS: Open Instruments\n# Xcode → Open Developer Tool → Instruments → Time Profiler\n\n# Android: Open Profiler\n# Android Studio → View → Tool Windows → Profiler\n```\n\n## When to Use\n\n- App is slow but JS profiler shows no issues\n- Investigating native module performance\n- Startup feels slow (native init)\n- Battery drain concerns\n- Need CPU/memory breakdown by thread\n\n> **Note**: This skill involves interpreting visual profiler output (Xcode Instruments, Android Studio Profiler). AI agents cannot yet process screenshots autonomously. Use this as a guide while reviewing the profiler UI manually, or await MCP-based visual feedback integration (see roadmap).\n\n## iOS Profiling with Xcode\n\n### Quick Check: Debug Navigator\n\n1. Run app via Xcode\n2. Open Debug Navigator (side panel)\n3. View real-time: CPU, Memory, Disk, Network\n\n**CPU percentage can exceed 100%** (multi-core usage).\n\n### Deep Profiling: Instruments\n\n1. Open: **Xcode → Open Developer Tool → Instruments**\n2. Select **Time Profiler**\n3. Choose target device and app\n4. Click record (red circle)\n5. Perform actions in app\n6. Stop recording\n\n### Analyzing Time Profiler Results\n\n**Key views:**\n- **Flame Graph**: Visual call stack over time\n- **Call Tree**: Hierarchical function breakdown\n- **Ranked**: Functions sorted by time (Bottom-Up)\n\n**Useful filters:**\n- Hide System Libraries\n- Invert Call Tree (bottom-up view)\n- Filter by thread (main, JS, etc.)\n\n**Identifying problems:**\n- **Microhang**: Brief UI unresponsiveness\n- **Hang**: Full UI thread block (critical)\n- Yellow = most time spent\n\n### Thread Breakdown\n\nPin threads to compare:\n- **Main thread** (SampleApp): UI rendering\n- **JavaScript thread**: React/JS execution\n- **Background threads**: Native modules\n\n**Pro tip**: JS thread blocking ≠ UI block (React Native design benefit).\n\n## Android Profiling with Android Studio\n\n### Launch Profiler\n\n1. **View → Tool Windows → Profiler**\n2. Or: Click \"Profile\" in toolbar\n\n### CPU Profiling\n\n1. Select **\"Find CPU Hotspots\"**\n2. Click **\"Start profiler task\"**\n3. Interact with app\n4. Stop to analyze\n\n### Analyzing Results\n\n**Flame Graph:**\n- Zoom with scroll/pinch\n- Click to expand call stacks\n- Filter by keyword (e.g., \"hermes\")\n\n**Views:**\n- **Top Down**: From entry points down\n- **Bottom Up**: From slowest functions up\n- **Flame Chart**: Timeline visualization\n\n### Reading the Call Stack\n\nExample analysis:\n```\nJS Thread activity after button press:\n- Event handler on main thread\n- Triggers JS work via sync JSI calls\n- Hermes processes React reconciliation\n- ~30% time in \"commit\" phase (Yoga layout)\n```\n\n## Code Example: What to Look For\n\n### 5000 Views in ScrollView (Bad)\n\nProfiler shows:\n- 240ms+ JS thread work\n- Many 1ms Hermes spikes\n- Exceeds 16.6ms frame budget\n- Result: Dropped frames, UI jank\n\n### Using FlatList (Better)\n\nProfiler shows:\n- Minimal JS work (windowed rendering)\n- Smooth main thread\n- Stays within frame budget\n\n## Platform Tools Summary\n\n| Tool | Platform | Use Case |\n|------|----------|----------|\n| Time Profiler | iOS | CPU hotspots |\n| Leaks | iOS | Memory leaks |\n| Hangs | iOS | UI thread blocks |\n| CPU Profiler | Android | CPU hotspots |\n| Memory Profiler | Android | Memory tracking |\n| Perfetto | Android | Advanced trace analysis |\n\n## Perfetto (Advanced Android)\n\nExport traces from Android Studio and analyze at [ui.perfetto.dev](https://ui.perfetto.dev/):\n\n- Cross-process analysis\n- Custom trace events\n- Additional visualizations\n\n## Pro Tips\n\n1. **Profile on low-end devices**: Issues appear more clearly\n2. **Use release builds**: Debug builds have overhead\n3. **Compare before/after**: Export traces for comparison\n4. **Filter by thread**: Focus on relevant work\n5. **Look for patterns**: Spikes correlating with interactions\n\n## Expo Notes\n\n- **Expo Go**: Cannot profile native code directly; JS profiling only\n- **Dev Client / Prebuild**: Full native profiling supported via Xcode/Android Studio\n- Run `npx expo prebuild` to generate native projects, then profile as bare React Native\n\n## Common Findings\n\n| Symptom | Likely Cause |\n|---------|--------------|\n| Main thread hangs | Heavy UI work, blocked operations |\n| JS thread spikes | React re-renders, heavy computation |\n| Background thread busy | Native module work |\n| Memory climbing | Leak (see memory profiling skills) |\n\n## Related Skills\n\n- [native-measure-tti.md](./native-measure-tti.md) - Profile startup specifically\n- [native-memory-leaks.md](./native-memory-leaks.md) - Memory profiling\n- [js-profile-react.md](./js-profile-react.md) - JS/React profiling\n",
        "skills/react-native/references/native-sdks-over-polyfills.md": "---\ntitle: Native SDKs\nimpact: HIGH\ntags: polyfills, intl, crypto, navigation, native\n---\n\n# Skill: Native SDKs\n\nReplace web polyfills and JS navigators with native React Native implementations for better performance.\n\n## Quick Pattern\n\n**Before (JS polyfills - 430+ KB):**\n\n```tsx\nimport '@formatjs/intl-datetimeformat/polyfill';\nimport CryptoJS from 'crypto-js';\nimport { createStackNavigator } from '@react-navigation/stack';\n```\n\n**After (native implementations):**\n\n```tsx\n// Hermes has native Intl.DateTimeFormat - no polyfill needed\nimport { createHash } from 'react-native-quick-crypto';  // 58x faster\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n```\n\n## When to Use\n\n- Large JS bundle from polyfills\n- Navigation feels non-native\n- Crypto operations are slow\n- Internationalization bloating bundle\n\n## Step-by-Step Instructions\n\n### 1. Remove Unnecessary Intl Polyfills\n\nHermes now supports many `Intl` APIs natively. Check your imports:\n\n```tsx\n// BEFORE: All these polyfills (430+ KB)\nimport '@formatjs/intl-getcanonicallocales/polyfill';\nimport '@formatjs/intl-locale/polyfill';\nimport '@formatjs/intl-numberformat/polyfill';\nimport '@formatjs/intl-numberformat/locale-data/en';\nimport '@formatjs/intl-datetimeformat/polyfill';\nimport '@formatjs/intl-datetimeformat/locale-data/en';\nimport '@formatjs/intl-pluralrules/polyfill';\nimport '@formatjs/intl-pluralrules/locale-data/en';\nimport '@formatjs/intl-relativetimeformat/polyfill';\nimport '@formatjs/intl-relativetimeformat/locale-data/en';\nimport '@formatjs/intl-displaynames/polyfill';\n```\n\n**Hermes Support (as of 2025):**\n\n| API | Hermes | Keep Polyfill? |\n|-----|--------|----------------|\n| `Intl.Collator` | ✅ | No |\n| `Intl.DateTimeFormat` | ✅ | No |\n| `Intl.NumberFormat` | ✅ | No |\n| `Intl.getCanonicalLocales()` | ✅ | No |\n| `Intl.supportedValuesOf()` | ✅ | No |\n| `Intl.Locale` | ❌ | Yes |\n| `Intl.PluralRules` | ❌ | Yes |\n| `Intl.RelativeTimeFormat` | ❌ | Yes |\n| `Intl.DisplayNames` | ❌ | Yes |\n| `Intl.ListFormat` | ❌ | Yes |\n| `Intl.Segmenter` | ❌ | Yes |\n\n```tsx\n// AFTER: Only needed polyfills\nimport '@formatjs/intl-locale/polyfill';\nimport '@formatjs/intl-pluralrules/polyfill';\nimport '@formatjs/intl-pluralrules/locale-data/en';\nimport '@formatjs/intl-relativetimeformat/polyfill';\nimport '@formatjs/intl-relativetimeformat/locale-data/en';\nimport '@formatjs/intl-displaynames/polyfill';\n```\n\n### 2. Use Native Crypto\n\nReplace JS crypto with native C++ implementation:\n\n```bash\nnpm install react-native-quick-crypto\n```\n\n**Performance**: Up to 58x faster than `crypto-js`.\n\n```tsx\n// BEFORE: Slow JS implementation\nimport CryptoJS from 'crypto-js';\n\n// AFTER: Native C++ implementation\nimport { createHash } from 'react-native-quick-crypto';\n```\n\nEssential for:\n- Web3 wallet seed generation\n- CSPRNG (Cryptographically Secure Random Numbers)\n- Any heavy cryptographic operations\n\n### 3. Use Native Stack Navigator\n\n```bash\nnpm install @react-navigation/native-stack react-native-screens\n```\n\n```tsx\n// BEFORE: JS-based stack (more flexible, less native)\nimport { createStackNavigator } from '@react-navigation/stack';\nconst Stack = createStackNavigator();\n\n// AFTER: Native stack (native feel, better performance)\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nconst Stack = createNativeStackNavigator();\n\n// Usage is nearly identical\n<Stack.Navigator>\n  <Stack.Screen name=\"Home\" component={HomeScreen} />\n  <Stack.Screen name=\"Details\" component={DetailsScreen} />\n</Stack.Navigator>\n```\n\n**Benefits:**\n- Native navigation animations\n- Platform-specific headers (large titles on iOS)\n- Lower memory usage\n- Offloads work from JS thread\n\n### 4. Use Native Bottom Tabs\n\n```bash\nnpm install @bottom-tabs/react-navigation react-native-bottom-tabs\n```\n\n```tsx\n// BEFORE: JS tabs\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nconst Tabs = createBottomTabNavigator();\n\n// AFTER: Native tabs\nimport { createNativeBottomTabNavigator } from '@bottom-tabs/react-navigation';\nconst Tabs = createNativeBottomTabNavigator();\n\n<Tabs.Navigator>\n  <Tabs.Screen name=\"Home\" component={HomeScreen} />\n  <Tabs.Screen name=\"Profile\" component={ProfileScreen} />\n</Tabs.Navigator>\n```\n\n## Recommended Native Libraries\n\n| Category | Library | Description |\n|----------|---------|-------------|\n| Navigation | `react-native-screens` | Native screen containers |\n| Menus | `zeego` | Native menus (Radix-like API) |\n| Slider | `@react-native-community/slider` | Native slider |\n| Date Picker | `react-native-date-picker` | Native date/time picker |\n| Image | `react-native-fast-image` | Native image caching |\n\n## Decision Matrix\n\n| Scenario | Use Native? | Tradeoff |\n|----------|-------------|----------|\n| Standard navigation | ✅ Yes | Slight API differences |\n| Custom transition animations | ⚠️ Maybe | Native is more limited |\n| Platform-consistent UI | ✅ Yes | Less customization |\n| Unique/branded design | ⚠️ Consider JS | Native may not support |\n\n## Common Pitfalls\n\n- **Assuming all polyfills needed**: Check Hermes compatibility first\n- **Ignoring migration effort**: Native navigators have slightly different APIs\n- **Over-customizing native components**: If design requires heavy customization, JS might be better\n\n## Related Skills\n\n- [bundle-analyze-js.md](./bundle-analyze-js.md) - Measure polyfill impact\n- [bundle-library-size.md](./bundle-library-size.md) - Compare library sizes\n",
        "skills/react-native/references/native-threading-model.md": "---\ntitle: Threading Model\nimpact: HIGH\ntags: threads, turbo-modules, fabric, async, sync\n---\n\n# Skill: Threading Model\n\nUnderstand which threads Turbo Modules and Fabric use for initialization, method calls, and view updates.\n\n## Quick Reference\n\n| Action | iOS Thread | Android Thread |\n|--------|------------|----------------|\n| Module init | Main | JS (lazy) / Native (eager) |\n| Sync method | JS | JS |\n| Async method | Native modules | Native modules |\n| View init/props | Main | Main |\n| Yoga layout | JS | JS |\n\n**Key rule**: Sync methods block JS thread. Keep under 16ms or make async.\n\n## When to Use\n\n- Building native modules\n- Debugging threading issues\n- Accessing UI from native code\n- Understanding async vs sync method behavior\n\n## Available Threads\n\n| Thread | Name in Debugger | Purpose |\n|--------|------------------|---------|\n| Main/UI | Main thread | UI rendering, UIKit/Android Views |\n| JavaScript | `mqt_v_js` | JS execution, React |\n| Native Modules | `mqt_v_native` | Async Turbo Module calls |\n| Custom | Various | Your background threads |\n\n## Turbo Modules Threading\n\n### Initialization\n\n| Platform | Thread | Notes |\n|----------|--------|-------|\n| iOS | Main thread | Assumes UIKit access needed |\n| Android (lazy) | JS thread | Default behavior |\n| Android (eager) | Native modules thread | When `needsEagerInit = true` |\n\n**iOS**: React Native runs `init` on main thread assuming UIKit access.\n\n**Android Eager Loading:**\n\n```kotlin\n// ReactModuleInfo constructor params:\n// canOverrideExistingModule, needsEagerInit, isCxxModule, isTurboModule\nReactModuleInfo(\n    AwesomeModule.NAME,\n    AwesomeModule.NAME,\n    false,\n    true,   // needsEagerInit = true → runs on native modules thread\n    false,\n    true\n)\n```\n\n### Synchronous Method Calls\n\n**Always run on JS thread** - blocks until return.\n\n```swift\n// iOS - runs on JS thread\n@objc func multiply(_ a: Double, b: Double) -> NSNumber {\n    // This blocks JS for entire duration!\n    return a * b as NSNumber\n}\n```\n\n**Danger**: Long sync operations freeze the app:\n\n```swift\n// BAD: Blocks JS for 20 seconds\n@objc func multiply(_ a: Double, b: Double) -> NSNumber {\n    Thread.sleep(forTimeInterval: 20)  // App frozen!\n    return a * b as NSNumber\n}\n```\n\n### Asynchronous Method Calls\n\n**Run on Native Modules thread** - doesn't block JS.\n\n```swift\n// iOS - runs on mqt_v_native thread\n@objc func asyncOperation(\n    _ a: Double,\n    resolve: @escaping RCTPromiseResolveBlock,\n    reject: RCTPromiseRejectBlock\n) {\n    // Already on background thread\n    resolve(a * 2)\n}\n```\n\n```kotlin\n// Android - runs on native modules thread\noverride fun asyncOperation(a: Double, promise: Promise?) {\n    // Already on background thread\n    promise?.resolve(a * 2)\n}\n```\n\n### Module Invalidation\n\nCalled when React Native instance is torn down (e.g., Metro reload):\n\n| Platform | Thread |\n|----------|--------|\n| iOS | Native modules thread |\n| Android | ReactHost thread pool |\n\n**iOS**: Implement `RCTInvalidating` protocol.\n\n## Fabric (Native Views) Threading\n\n### View Lifecycle\n\n| Operation | Thread |\n|-----------|--------|\n| View init | Main thread |\n| Prop updates | Main thread |\n| Layout (Yoga) | JS thread |\n\nViews always manipulate UI on main thread (UIKit/Android requirement).\n\n### Yoga Layout\n\nLayout calculations happen on JS thread:\n\n```\nJS Thread: Calculate Yoga tree → Shadow tree\nMain Thread: Apply layout to native views\n```\n\n## Moving Work to Background\n\n### iOS: DispatchQueue\n\n```swift\n@objc func heavyWork(\n    resolve: @escaping RCTPromiseResolveBlock,\n    reject: RCTPromiseRejectBlock\n) {\n    DispatchQueue.global().async {\n        // Heavy computation here\n        let result = self.compute()\n        resolve(result)\n    }\n}\n```\n\n### Android: Coroutines\n\n```kotlin\nclass MyModule(reactContext: ReactApplicationContext) :\n    NativeMyModuleSpec(reactContext) {\n    \n    private val moduleScope = CoroutineScope(Dispatchers.Default + SupervisorJob())\n    \n    override fun heavyWork(promise: Promise?) {\n        moduleScope.launch {\n            // Heavy computation here\n            val result = compute()\n            promise?.resolve(result)\n        }\n    }\n    \n    override fun invalidate() {\n        super.invalidate()\n        moduleScope.cancel()  // Important: cancel to prevent leaks\n    }\n}\n```\n\n## Thread Safety Checklist\n\n| Scenario | Safe? | Solution |\n|----------|-------|----------|\n| Sync method accessing shared state | ⚠️ | Use locks/synchronized |\n| Async method accessing UI | ❌ | Dispatch to main thread |\n| Multiple async calls to same resource | ⚠️ | Queue or mutex |\n| Accessing JS from background | ❌ | Use CallInvoker |\n\n### Accessing UI from Background (iOS)\n\n```swift\nDispatchQueue.global().async {\n    let result = self.heavyComputation()\n    \n    DispatchQueue.main.async {\n        // Safe to update UI here\n        self.updateUI(with: result)\n    }\n}\n```\n\n### Accessing UI from Background (Android)\n\n```kotlin\nmoduleScope.launch(Dispatchers.Default) {\n    val result = heavyComputation()\n    \n    withContext(Dispatchers.Main) {\n        // Safe to update UI here\n        updateUI(result)\n    }\n}\n```\n\n## Summary Table\n\n| Action | iOS Thread | Android Thread |\n|--------|------------|----------------|\n| Module init | Main | JS (lazy) / Native (eager) |\n| Sync method | JS | JS |\n| Async method | Native modules | Native modules |\n| View init | Main | Main |\n| Prop update | Main | Main |\n| Yoga layout | JS | JS |\n| Invalidate | Native modules | ReactHost pool |\n\n## Related Skills\n\n- [native-turbo-modules.md](./native-turbo-modules.md) - Implement background threads\n- [native-profiling.md](./native-profiling.md) - Debug thread issues\n",
        "skills/react-native/references/native-turbo-modules.md": "---\ntitle: Fast Native Modules\nimpact: HIGH\ntags: turbo-modules, native, swift, kotlin, c++\n---\n\n# Skill: Fast Native Modules\n\nBuild performant Turbo Modules using modern languages and background threading.\n\n## Quick Pattern\n\n**Incorrect (sync method blocks JS thread):**\n\n```swift\n@objc func heavyWork() -> NSNumber {\n    Thread.sleep(forTimeInterval: 2)  // Blocks JS for 2s!\n    return 42\n}\n```\n\n**Correct (async on background thread):**\n\n```swift\n@objc func heavyWork(\n    resolve: @escaping RCTPromiseResolveBlock,\n    reject: RCTPromiseRejectBlock\n) {\n    DispatchQueue.global().async {\n        let result = self.compute()\n        resolve(result)\n    }\n}\n```\n\n## When to Use\n\n- Creating new native modules\n- Optimizing existing module performance\n- Heavy computation needs to run off JS thread\n- Cross-platform C++ code needed\n\n## Prerequisites\n\n- React Native Builder Bob for scaffolding\n\n```bash\nnpx create-react-native-library@latest my-library\n```\n\n## Step-by-Step Instructions\n\n### 1. Scaffold with Builder Bob\n\n```bash\nnpx create-react-native-library@latest awesome-library\n# Follow prompts: choose Turbo Module, select languages\n```\n\nCreates ready-to-publish library with:\n- iOS (Obj-C/Swift) support\n- Android (Kotlin) support\n- TypeScript definitions\n- Codegen setup\n\nFor local modules:\n\n```bash\nnpx create-react-native-library@latest awesome-library --local\n```\n\n### 2. Enable Swift in iOS Module\n\nUpdate `awesome-library.podspec`:\n\n```diff\n- s.source_files = \"ios/**/*.{h,m,mm,cpp}\"\n+ s.source_files = \"ios/**/*.{h,m,mm,cpp,swift}\"\n```\n\nCreate Swift file in Xcode (accept bridging header prompt).\n\nUpdate header file for Swift compatibility:\n\n```objc\n// AwesomeLibrary.h\n#import <Foundation/Foundation.h>\n\n#if __cplusplus\n#import \"ReactCodegen/RNAwesomeLibrarySpec/RNAwesomeLibrarySpec.h\"\n#endif\n\n@interface AwesomeLibrary : NSObject\n#if __cplusplus\n<NativeAwesomeLibrarySpec>\n#endif\n@end\n```\n\nImport header in bridging header:\n\n```objc\n// AwesomeLibrary-Bridging-Header.h\n#import \"AwesomeLibrary.h\"\n```\n\nImplement in Swift:\n\n```swift\n// AwesomeLibrary.swift\nimport Foundation\n\nextension AwesomeLibrary {\n    @objc func multiply(_ a: Double, b: Double) -> NSNumber {\n        return (a * b) as NSNumber\n    }\n}\n```\n\nBridge in Obj-C++:\n\n```objc\n// AwesomeLibrary.mm\n#import \"AwesomeLibrary.h\"\n\n#if __has_include(\"awesome_library/awesome_library-Swift.h\")\n#import \"awesome_library/awesome_library-Swift.h\"\n#else\n#import \"awesome_library-Swift.h\"\n#endif\n\n@implementation AwesomeLibrary\nRCT_EXPORT_MODULE()\nRCT_EXTERN_METHOD(multiply:(double)a b:(double)b);\n@end\n```\n\n### 3. Run on Background Thread (iOS)\n\n```swift\n@objc func heavyOperation(\n    _ input: Double,\n    resolve: @escaping RCTPromiseResolveBlock,\n    reject: RCTPromiseRejectBlock\n) {\n    DispatchQueue.global().async {\n        // Heavy work on background thread\n        let result = self.expensiveComputation(input)\n        resolve(result)\n    }\n}\n```\n\n### 4. Run on Background Thread (Android)\n\n```kotlin\nclass AwesomeLibraryModule(reactContext: ReactApplicationContext) :\n    NativeAwesomeLibrarySpec(reactContext) {\n    \n    private val moduleScope = CoroutineScope(Dispatchers.Default + SupervisorJob())\n    \n    override fun heavyOperation(input: Double, promise: Promise?) {\n        moduleScope.launch {\n            // Heavy work on coroutine\n            val result = expensiveComputation(input)\n            promise?.resolve(result)\n        }\n    }\n    \n    override fun invalidate() {\n        super.invalidate()\n        moduleScope.cancel()  // Prevent memory leaks!\n    }\n}\n```\n\n### 5. Use C++ for Cross-Platform Code\n\nCreate C++ Turbo Module for shared logic:\n\n```cpp\n// MyCppModule.h\n#pragma once\n\n#include <ReactCommon/TurboModule.h>\n\nnamespace facebook::react {\n\nclass MyCppModule : public TurboModule {\npublic:\n    MyCppModule(std::shared_ptr<CallInvoker> jsInvoker);\n    \n    double multiply(double a, double b);\n};\n\n} // namespace facebook::react\n```\n\nRegister for iOS auto-linking:\n\n```objc\n// MyCppModuleRegistration.mm\n#include <ReactCommon/CxxTurboModuleUtils.h>\n\n@implementation MyCppModuleRegistration\n\n+ (void)load {\n    facebook::react::registerCxxModuleToGlobalModuleMap(\n        std::string(facebook::react::MyCppModule::kModuleName),\n        [&](std::shared_ptr<facebook::react::CallInvoker> jsInvoker) {\n            return std::make_shared<facebook::react::MyCppModule>(jsInvoker);\n        }\n    );\n}\n\n@end\n```\n\n## Threading Summary\n\n| Method Type | Default Thread | Best Practice |\n|-------------|----------------|---------------|\n| Sync | JS thread | Keep fast (<16ms) |\n| Async | Native modules thread | OK for moderate work |\n| Heavy async | Custom background | Use DispatchQueue/Coroutines |\n\n## Language Interop Costs\n\n| Interface | Overhead | Notes |\n|-----------|----------|-------|\n| Obj-C ↔ C++ | ~0 | Compile-time |\n| Swift ↔ C++ | ~0 | Swift 5.9+ interop |\n| Kotlin ↔ C++ (JNI) | Medium | Per-call lookup |\n| C++ Turbo Module | Low | JSI direct access |\n\n**Tip**: C++ Turbo Modules skip JNI at runtime since JS holds direct C++ function references via JSI.\n\n## Code Example: Complete Async Operation\n\n```typescript\n// TypeScript interface\nexport interface Spec extends TurboModule {\n    multiply(a: number, b: number): number;  // Sync\n    heavyOperation(input: number): Promise<number>;  // Async\n}\n```\n\n```kotlin\n// Android implementation\noverride fun heavyOperation(input: Double, promise: Promise?) {\n    moduleScope.launch {\n        try {\n            val result = withContext(Dispatchers.Default) {\n                // Simulate heavy work\n                delay(1000)\n                input * 2\n            }\n            promise?.resolve(result)\n        } catch (e: Exception) {\n            promise?.reject(\"ERROR\", e.message)\n        }\n    }\n}\n```\n\n```swift\n// iOS implementation\n@objc func heavyOperation(\n    _ input: Double,\n    resolve: @escaping RCTPromiseResolveBlock,\n    reject: @escaping RCTPromiseRejectBlock\n) {\n    DispatchQueue.global(qos: .userInitiated).async {\n        // Simulate heavy work\n        Thread.sleep(forTimeInterval: 1.0)\n        let result = input * 2\n        resolve(result)\n    }\n}\n```\n\n## Common Pitfalls\n\n- **Sync methods that block**: Keep under 16ms or make async\n- **Forgetting to cancel coroutine scope**: Causes memory leaks\n- **Not handling errors in async**: Always try/catch with reject\n- **Accessing UI from background**: Dispatch to main thread\n\n## Related Skills\n\n- [native-threading-model.md](./native-threading-model.md) - Thread details\n- [native-memory-patterns.md](./native-memory-patterns.md) - Memory in native code\n",
        "skills/react-native/references/native-view-flattening.md": "---\ntitle: View Flattening\nimpact: MEDIUM\ntags: views, flattening, collapsable, hierarchy\n---\n\n# Skill: View Flattening\n\nUnderstand and debug React Native's view flattening optimization.\n\n## Quick Pattern\n\n**Problem (children get flattened unexpectedly):**\n\n```jsx\n<NativeTabBar>\n  <Tab1 />  // May be flattened, breaking native component\n  <Tab2 />\n</NativeTabBar>\n```\n\n**Solution (prevent flattening):**\n\n```jsx\n<NativeTabBar>\n  <Tab1 collapsable={false} />\n  <Tab2 collapsable={false} />\n</NativeTabBar>\n```\n\n## When to Use\n\n- Native component receives unexpected number of children\n- Layout debugging with native components\n- Building native components that accept children\n- Understanding React Native rendering\n\n> **Note**: This skill involves interpreting visual view hierarchy tools (Xcode Debug View Hierarchy, Android Layout Inspector). AI agents cannot yet process screenshots autonomously. Use this as a guide while reviewing the hierarchy manually, or await MCP-based visual feedback integration (see roadmap).\n\n## What is View Flattening?\n\nReact Native's renderer automatically removes \"layout-only\" views that:\n- Only affect layout (no visual rendering)\n- Don't need to exist in native view hierarchy\n\n**Benefits**: Reduced memory, faster rendering, shallower view tree.\n\n## The Problem with Native Components\n\n```tsx\n// You expect 3 children\n<MyNativeComponent>\n  <Child1 />\n  <Child2 />\n  <Child3 />\n</MyNativeComponent>\n```\n\nIf `Child1` is flattened, its internal views become direct children:\n\n```tsx\n// Native side receives 5 views instead of 3!\n<MyNativeComponent>\n  <View />   // Was inside Child1\n  <View />   // Was inside Child1  \n  <View />   // Was inside Child1\n  <Child2 />\n  <Child3 />\n</MyNativeComponent>\n```\n\n## Preventing Flattening with `collapsable`\n\n```tsx\n<MyNativeComponent>\n  <Child1 collapsable={false} />\n  <Child2 collapsable={false} />\n  <Child3 collapsable={false} />\n</MyNativeComponent>\n```\n\nNow native side always receives exactly 3 children.\n\n## Debugging View Hierarchy\n\n![View Hierarchy Flattening](images/view-hierarchy-flattening.png)\n\nUse native debugging tools to see the actual view hierarchy:\n\n### Xcode (iOS)\n\n1. Run app via Xcode\n2. Click **\"Debug View Hierarchy\"** in debug toolbar (shown in image)\n3. Inspect 3D view of native hierarchy\n\n**React Native components map to:**\n- `<View />` → `RCTViewComponentView`\n- `<Text />` → `RCTTextView`\n\n### Android Studio\n\n1. Run app via Android Studio\n2. **View → Tool Windows → Layout Inspector**\n3. Select running process\n\n**React Native components map to:**\n- `<View />` → `ReactViewGroup`\n- `<Text />` → `ReactTextView`\n\n## Code Examples\n\n### When Flattening Breaks Your Component\n\n```tsx\n// Your native component expects exactly 2 tabs\nconst NativeTabBar = requireNativeComponent('RCTTabBar');\n\n// BAD: TabContent might get flattened\nconst MyTabs = () => (\n  <NativeTabBar>\n    <TabContent title=\"Home\">\n      <View><Text>Home content</Text></View>\n    </TabContent>\n    <TabContent title=\"Profile\">\n      <View><Text>Profile content</Text></View>\n    </TabContent>\n  </NativeTabBar>\n);\n\n// GOOD: Prevent flattening\nconst MyTabs = () => (\n  <NativeTabBar>\n    <TabContent title=\"Home\" collapsable={false}>\n      <View><Text>Home content</Text></View>\n    </TabContent>\n    <TabContent title=\"Profile\" collapsable={false}>\n      <View><Text>Profile content</Text></View>\n    </TabContent>\n  </NativeTabBar>\n);\n```\n\n### Wrapper Component with collapsable\n\n```tsx\n// Wrapper that prevents flattening\nconst NativeChildWrapper = ({ children, ...props }) => (\n  <View collapsable={false} {...props}>\n    {children}\n  </View>\n);\n\n// Usage\n<NativeComponent>\n  <NativeChildWrapper>\n    <ComplexChild />\n  </NativeChildWrapper>\n</NativeComponent>\n```\n\n## When Views Get Flattened\n\nViews are considered \"layout-only\" when they:\n- Have no `backgroundColor`\n- Have no `borderWidth`, `borderColor`\n- Have no `shadowColor`, `elevation`\n- Don't handle events (no `onPress`, etc.)\n- Don't use `opacity` < 1\n- Don't have `overflow: 'hidden'`\n\n## Forcing a View to Stay\n\nBesides `collapsable={false}`, these also prevent flattening:\n\n```tsx\n// Any of these prevent flattening\n<View style={{ backgroundColor: 'transparent' }} />\n<View style={{ borderWidth: 0.01 }} />\n<View style={{ opacity: 0.99 }} />\n<View onLayout={() => {}} />\n```\n\nBut `collapsable={false}` is the cleanest solution.\n\n## Debugging Checklist\n\n1. **Check native child count**: Log received children in native code\n2. **Use Layout Inspector**: Visual hierarchy debugging\n3. **Add collapsable={false}**: Test if flattening is the issue\n4. **Check wrapper components**: Intermediate views may be flattened\n\n## Common Pitfalls\n\n- **Assuming JS children = native children**: Flattening changes this\n- **Not documenting native component requirements**: If your native component expects specific child count, document it\n- **Over-using collapsable={false}**: Only use when necessary (loses optimization benefits)\n\n## Related Skills\n\n- [native-platform-setup.md](./native-platform-setup.md) - IDE setup for debugging\n- [native-profiling.md](./native-profiling.md) - Performance impact analysis\n",
        "skills/react-native/rules/_sections.md": "# Sections\n\nThis file defines all sections, their ordering, impact levels, and descriptions.\nThe section ID (in parentheses) is the filename prefix used to group rules.\n\n---\n\n## 1. Core Rendering (rendering)\n\n**Impact:** CRITICAL  \n**Description:** Fundamental React Native rendering rules. Violations cause\nruntime crashes or broken UI.\n\n## 2. List Performance (list-performance)\n\n**Impact:** HIGH  \n**Description:** Optimizing virtualized lists (FlatList, LegendList, FlashList)\nfor smooth scrolling and fast updates.\n\n## 3. Animation (animation)\n\n**Impact:** HIGH  \n**Description:** GPU-accelerated animations, Reanimated patterns, and avoiding\nrender thrashing during gestures.\n\n## 4. Scroll Performance (scroll)\n\n**Impact:** HIGH  \n**Description:** Tracking scroll position without causing render thrashing.\n\n## 5. Navigation (navigation)\n\n**Impact:** HIGH  \n**Description:** Using native navigators for stack and tab navigation instead of\nJS-based alternatives.\n\n## 6. React State (react-state)\n\n**Impact:** MEDIUM  \n**Description:** Patterns for managing React state to avoid stale closures and\nunnecessary re-renders.\n\n## 7. State Architecture (state)\n\n**Impact:** MEDIUM  \n**Description:** Ground truth principles for state variables and derived values.\n\n## 8. React Compiler (react-compiler)\n\n**Impact:** MEDIUM  \n**Description:** Compatibility patterns for React Compiler with React Native and\nReanimated.\n\n## 9. User Interface (ui)\n\n**Impact:** MEDIUM  \n**Description:** Native UI patterns for images, menus, modals, styling, and\nplatform-consistent interfaces.\n\n## 10. Design System (design-system)\n\n**Impact:** MEDIUM  \n**Description:** Architecture patterns for building maintainable component\nlibraries.\n\n## 11. Monorepo (monorepo)\n\n**Impact:** LOW  \n**Description:** Dependency management and native module configuration in\nmonorepos.\n\n## 12. Third-Party Dependencies (imports)\n\n**Impact:** LOW  \n**Description:** Wrapping and re-exporting third-party dependencies for\nmaintainability.\n\n## 13. JavaScript (js)\n\n**Impact:** LOW  \n**Description:** Micro-optimizations like hoisting expensive object creation.\n\n## 14. Fonts (fonts)\n\n**Impact:** LOW  \n**Description:** Native font loading for improved performance.\n",
        "skills/react-native/rules/_template.md": "---\ntitle: Rule Title Here\nimpact: MEDIUM\nimpactDescription: Optional description of impact (e.g., \"20-50% improvement\")\ntags: tag1, tag2\n---\n\n## Rule Title Here\n\n**Impact: MEDIUM (optional impact description)**\n\nBrief explanation of the rule and why it matters. This should be clear and concise, explaining the performance implications.\n\n**Incorrect (description of what's wrong):**\n\n```typescript\n// Bad code example here\nconst bad = example()\n```\n\n**Correct (description of what's right):**\n\n```typescript\n// Good code example here\nconst good = example()\n```\n\nReference: [Link to documentation or resource](https://example.com)\n",
        "skills/react-native/rules/animation-derived-value.md": "---\ntitle: Prefer useDerivedValue Over useAnimatedReaction\nimpact: MEDIUM\nimpactDescription: cleaner code, automatic dependency tracking\ntags: animation, reanimated, derived-value\n---\n\n## Prefer useDerivedValue Over useAnimatedReaction\n\nWhen deriving a shared value from another, use `useDerivedValue` instead of\n`useAnimatedReaction`. Derived values are declarative, automatically track\ndependencies, and return a value you can use directly. Animated reactions are\nfor side effects, not derivations.\n\n**Incorrect (useAnimatedReaction for derivation):**\n\n```tsx\nimport { useSharedValue, useAnimatedReaction } from 'react-native-reanimated'\n\nfunction MyComponent() {\n  const progress = useSharedValue(0)\n  const opacity = useSharedValue(1)\n\n  useAnimatedReaction(\n    () => progress.value,\n    (current) => {\n      opacity.value = 1 - current\n    }\n  )\n\n  // ...\n}\n```\n\n**Correct (useDerivedValue):**\n\n```tsx\nimport { useSharedValue, useDerivedValue } from 'react-native-reanimated'\n\nfunction MyComponent() {\n  const progress = useSharedValue(0)\n\n  const opacity = useDerivedValue(() => 1 - progress.get())\n\n  // ...\n}\n```\n\nUse `useAnimatedReaction` only for side effects that don't produce a value\n(e.g., triggering haptics, logging, calling `runOnJS`).\n\nReference:\n[Reanimated useDerivedValue](https://docs.swmansion.com/react-native-reanimated/docs/core/useDerivedValue)\n",
        "skills/react-native/rules/animation-gesture-detector-press.md": "---\ntitle: Use GestureDetector for Animated Press States\nimpact: MEDIUM\nimpactDescription: UI thread animations, smoother press feedback\ntags: animation, gestures, press, reanimated\n---\n\n## Use GestureDetector for Animated Press States\n\nFor animated press states (scale, opacity on press), use `GestureDetector` with\n`Gesture.Tap()` and shared values instead of Pressable's\n`onPressIn`/`onPressOut`. Gesture callbacks run on the UI thread as worklets—no\nJS thread round-trip for press animations.\n\n**Incorrect (Pressable with JS thread callbacks):**\n\n```tsx\nimport { Pressable } from 'react-native'\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n} from 'react-native-reanimated'\n\nfunction AnimatedButton({ onPress }: { onPress: () => void }) {\n  const scale = useSharedValue(1)\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }))\n\n  return (\n    <Pressable\n      onPress={onPress}\n      onPressIn={() => (scale.value = withTiming(0.95))}\n      onPressOut={() => (scale.value = withTiming(1))}\n    >\n      <Animated.View style={animatedStyle}>\n        <Text>Press me</Text>\n      </Animated.View>\n    </Pressable>\n  )\n}\n```\n\n**Correct (GestureDetector with UI thread worklets):**\n\n```tsx\nimport { Gesture, GestureDetector } from 'react-native-gesture-handler'\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  interpolate,\n  runOnJS,\n} from 'react-native-reanimated'\n\nfunction AnimatedButton({ onPress }: { onPress: () => void }) {\n  // Store the press STATE (0 = not pressed, 1 = pressed)\n  const pressed = useSharedValue(0)\n\n  const tap = Gesture.Tap()\n    .onBegin(() => {\n      pressed.set(withTiming(1))\n    })\n    .onFinalize(() => {\n      pressed.set(withTiming(0))\n    })\n    .onEnd(() => {\n      runOnJS(onPress)()\n    })\n\n  // Derive visual values from the state\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { scale: interpolate(withTiming(pressed.get()), [0, 1], [1, 0.95]) },\n    ],\n  }))\n\n  return (\n    <GestureDetector gesture={tap}>\n      <Animated.View style={animatedStyle}>\n        <Text>Press me</Text>\n      </Animated.View>\n    </GestureDetector>\n  )\n}\n```\n\nStore the press **state** (0 or 1), then derive the scale via `interpolate`.\nThis keeps the shared value as ground truth. Use `runOnJS` to call JS functions\nfrom worklets. Use `.set()` and `.get()` for React Compiler compatibility.\n\nReference:\n[Gesture Handler Tap Gesture](https://docs.swmansion.com/react-native-gesture-handler/docs/gestures/tap-gesture)\n",
        "skills/react-native/rules/animation-gpu-properties.md": "---\ntitle: Animate Transform and Opacity Instead of Layout Properties\nimpact: HIGH\nimpactDescription: GPU-accelerated animations, no layout recalculation\ntags: animation, performance, reanimated, transform, opacity\n---\n\n## Animate Transform and Opacity Instead of Layout Properties\n\nAvoid animating `width`, `height`, `top`, `left`, `margin`, or `padding`. These trigger layout recalculation on every frame. Instead, use `transform` (scale, translate) and `opacity` which run on the GPU without triggering layout.\n\n**Incorrect (animates height, triggers layout every frame):**\n\n```tsx\nimport Animated, { useAnimatedStyle, withTiming } from 'react-native-reanimated'\n\nfunction CollapsiblePanel({ expanded }: { expanded: boolean }) {\n  const animatedStyle = useAnimatedStyle(() => ({\n    height: withTiming(expanded ? 200 : 0), // triggers layout on every frame\n    overflow: 'hidden',\n  }))\n\n  return <Animated.View style={animatedStyle}>{children}</Animated.View>\n}\n```\n\n**Correct (animates scaleY, GPU-accelerated):**\n\n```tsx\nimport Animated, { useAnimatedStyle, withTiming } from 'react-native-reanimated'\n\nfunction CollapsiblePanel({ expanded }: { expanded: boolean }) {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { scaleY: withTiming(expanded ? 1 : 0) },\n    ],\n    opacity: withTiming(expanded ? 1 : 0),\n  }))\n\n  return (\n    <Animated.View style={[{ height: 200, transformOrigin: 'top' }, animatedStyle]}>\n      {children}\n    </Animated.View>\n  )\n}\n```\n\n**Correct (animates translateY for slide animations):**\n\n```tsx\nimport Animated, { useAnimatedStyle, withTiming } from 'react-native-reanimated'\n\nfunction SlideIn({ visible }: { visible: boolean }) {\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: withTiming(visible ? 0 : 100) },\n    ],\n    opacity: withTiming(visible ? 1 : 0),\n  }))\n\n  return <Animated.View style={animatedStyle}>{children}</Animated.View>\n}\n```\n\nGPU-accelerated properties: `transform` (translate, scale, rotate), `opacity`. Everything else triggers layout.\n",
        "skills/react-native/rules/design-system-compound-components.md": "---\ntitle: Use Compound Components Over Polymorphic Children\nimpact: MEDIUM\nimpactDescription: flexible composition, clearer API\ntags: design-system, components, composition\n---\n\n## Use Compound Components Over Polymorphic Children\n\nDon't create components that can accept a string if they aren't a text node. If\na component can receive a string child, it must be a dedicated `*Text`\ncomponent. For components like buttons, which can have both a View (or\nPressable) together with text, use compound components, such a `Button`,\n`ButtonText`, and `ButtonIcon`.\n\n**Incorrect (polymorphic children):**\n\n```tsx\nimport { Pressable, Text } from 'react-native'\n\ntype ButtonProps = {\n  children: string | React.ReactNode\n  icon?: React.ReactNode\n}\n\nfunction Button({ children, icon }: ButtonProps) {\n  return (\n    <Pressable>\n      {icon}\n      {typeof children === 'string' ? <Text>{children}</Text> : children}\n    </Pressable>\n  )\n}\n\n// Usage is ambiguous\n<Button icon={<Icon />}>Save</Button>\n<Button><CustomText>Save</CustomText></Button>\n```\n\n**Correct (compound components):**\n\n```tsx\nimport { Pressable, Text } from 'react-native'\n\nfunction Button({ children }: { children: React.ReactNode }) {\n  return <Pressable>{children}</Pressable>\n}\n\nfunction ButtonText({ children }: { children: React.ReactNode }) {\n  return <Text>{children}</Text>\n}\n\nfunction ButtonIcon({ children }: { children: React.ReactNode }) {\n  return <>{children}</>\n}\n\n// Usage is explicit and composable\n<Button>\n  <ButtonIcon><SaveIcon /></ButtonIcon>\n  <ButtonText>Save</ButtonText>\n</Button>\n\n<Button>\n  <ButtonText>Cancel</ButtonText>\n</Button>\n```\n",
        "skills/react-native/rules/fonts-config-plugin.md": "---\ntitle: Load fonts natively at build time\nimpact: LOW\nimpactDescription: fonts available at launch, no async loading\ntags: fonts, expo, performance, config-plugin\n---\n\n## Use Expo Config Plugin for Font Loading\n\nUse the `expo-font` config plugin to embed fonts at build time instead of\n`useFonts` or `Font.loadAsync`. Embedded fonts are more efficient.\n\n**Incorrect (async font loading):**\n\n```tsx\nimport { useFonts } from 'expo-font'\nimport { Text, View } from 'react-native'\n\nfunction App() {\n  const [fontsLoaded] = useFonts({\n    'Geist-Bold': require('./assets/fonts/Geist-Bold.otf'),\n  })\n\n  if (!fontsLoaded) {\n    return null\n  }\n\n  return (\n    <View>\n      <Text style={{ fontFamily: 'Geist-Bold' }}>Hello</Text>\n    </View>\n  )\n}\n```\n\n**Correct (config plugin, fonts embedded at build):**\n\n```json\n// app.json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-font\",\n        {\n          \"fonts\": [\"./assets/fonts/Geist-Bold.otf\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\n```tsx\nimport { Text, View } from 'react-native'\n\nfunction App() {\n  // No loading state needed—font is already available\n  return (\n    <View>\n      <Text style={{ fontFamily: 'Geist-Bold' }}>Hello</Text>\n    </View>\n  )\n}\n```\n\nAfter adding fonts to the config plugin, run `npx expo prebuild` and rebuild the\nnative app.\n\nReference:\n[Expo Font Documentation](https://docs.expo.dev/versions/latest/sdk/font/)\n",
        "skills/react-native/rules/imports-design-system-folder.md": "---\ntitle: Import from Design System Folder\nimpact: LOW\nimpactDescription: enables global changes and easy refactoring\ntags: imports, architecture, design-system\n---\n\n## Import from Design System Folder\n\nRe-export dependencies from a design system folder. App code imports from there,\nnot directly from packages. This enables global changes and easy refactoring.\n\n**Incorrect (imports directly from package):**\n\n```tsx\nimport { View, Text } from 'react-native'\nimport { Button } from '@ui/button'\n\nfunction Profile() {\n  return (\n    <View>\n      <Text>Hello</Text>\n      <Button>Save</Button>\n    </View>\n  )\n}\n```\n\n**Correct (imports from design system):**\n\n```tsx\n// components/view.tsx\nimport { View as RNView } from 'react-native'\n\n// ideal: pick the props you will actually use to control implementation\nexport function View(\n  props: Pick<React.ComponentProps<typeof RNView>, 'style' | 'children'>\n) {\n  return <RNView {...props} />\n}\n```\n\n```tsx\n// components/text.tsx\nexport { Text } from 'react-native'\n```\n\n```tsx\n// components/button.tsx\nexport { Button } from '@ui/button'\n```\n\n```tsx\nimport { View } from '@/components/view'\nimport { Text } from '@/components/text'\nimport { Button } from '@/components/button'\n\nfunction Profile() {\n  return (\n    <View>\n      <Text>Hello</Text>\n      <Button>Save</Button>\n    </View>\n  )\n}\n```\n\nStart by simply re-exporting. Customize later without changing app code.\n",
        "skills/react-native/rules/js-hoist-intl.md": "---\ntitle: Hoist Intl Formatter Creation\nimpact: LOW-MEDIUM\nimpactDescription: avoids expensive object recreation\ntags: javascript, intl, optimization, memoization\n---\n\n## Hoist Intl Formatter Creation\n\nDon't create `Intl.DateTimeFormat`, `Intl.NumberFormat`, or\n`Intl.RelativeTimeFormat` inside render or loops. These are expensive to\ninstantiate. Hoist to module scope when the locale/options are static.\n\n**Incorrect (new formatter every render):**\n\n```tsx\nfunction Price({ amount }: { amount: number }) {\n  const formatter = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n  })\n  return <Text>{formatter.format(amount)}</Text>\n}\n```\n\n**Correct (hoisted to module scope):**\n\n```tsx\nconst currencyFormatter = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n})\n\nfunction Price({ amount }: { amount: number }) {\n  return <Text>{currencyFormatter.format(amount)}</Text>\n}\n```\n\n**For dynamic locales, memoize:**\n\n```tsx\nconst dateFormatter = useMemo(\n  () => new Intl.DateTimeFormat(locale, { dateStyle: 'medium' }),\n  [locale]\n)\n```\n\n**Common formatters to hoist:**\n\n```tsx\n// Module-level formatters\nconst dateFormatter = new Intl.DateTimeFormat('en-US', { dateStyle: 'medium' })\nconst timeFormatter = new Intl.DateTimeFormat('en-US', { timeStyle: 'short' })\nconst percentFormatter = new Intl.NumberFormat('en-US', { style: 'percent' })\nconst relativeFormatter = new Intl.RelativeTimeFormat('en-US', {\n  numeric: 'auto',\n})\n```\n\nCreating `Intl` objects is significantly more expensive than `RegExp` or plain\nobjects—each instantiation parses locale data and builds internal lookup tables.\n",
        "skills/react-native/rules/list-performance-callbacks.md": "---\ntitle: Hoist callbacks to the root of lists\nimpact: MEDIUM\nimpactDescription: Fewer re-renders and faster lists\ntags: tag1, tag2\n---\n\n## List performance callbacks\n\n**Impact: HIGH (Fewer re-renders and faster lists)**\n\nWhen passing callback functions to list items, create a single instance of the\ncallback at the root of the list. Items should then call it with a unique\nidentifier.\n\n**Incorrect (creates a new callback on each render):**\n\n```typescript\nreturn (\n  <LegendList\n    renderItem={({ item }) => {\n      // bad: creates a new callback on each render\n      const onPress = () => handlePress(item.id)\n      return <Item key={item.id} item={item} onPress={onPress} />\n    }}\n  />\n)\n```\n\n**Correct (a single function instance passed to each item):**\n\n```typescript\nconst onPress = useCallback(() => handlePress(item.id), [handlePress, item.id])\n\nreturn (\n  <LegendList\n    renderItem={({ item }) => (\n      <Item key={item.id} item={item} onPress={onPress} />\n    )}\n  />\n)\n```\n\nReference: [Link to documentation or resource](https://example.com)\n",
        "skills/react-native/rules/list-performance-function-references.md": "---\ntitle: Optimize List Performance with Stable Object References\nimpact: CRITICAL\nimpactDescription: virtualization relies on reference stability\ntags: lists, performance, flatlist, virtualization\n---\n\n## Optimize List Performance with Stable Object References\n\nDon't map or filter data before passing to virtualized lists. Virtualization\nrelies on object reference stability to know what changed—new references cause\nfull re-renders of all visible items. Attempt to prevent frequent renders at the\nlist-parent level.\n\nWhere needed, use context selectors within list items.\n\n**Incorrect (creates new object references on every keystroke):**\n\n```tsx\nfunction DomainSearch() {\n  const { keyword, setKeyword } = useKeywordZustandState()\n  const { data: tlds } = useTlds()\n\n  // Bad: creates new objects on every render, reparenting the entire list on every keystroke\n  const domains = tlds.map((tld) => ({\n    domain: `${keyword}.${tld.name}`,\n    tld: tld.name,\n    price: tld.price,\n  }))\n\n  return (\n    <>\n      <TextInput value={keyword} onChangeText={setKeyword} />\n      <LegendList\n        data={domains}\n        renderItem={({ item }) => <DomainItem item={item} keyword={keyword} />}\n      />\n    </>\n  )\n}\n```\n\n**Correct (stable references, transform inside items):**\n\n```tsx\nconst renderItem = ({ item }) => <DomainItem tld={item} />\n\nfunction DomainSearch() {\n  const { data: tlds } = useTlds()\n\n  return (\n    <LegendList\n      // good: as long as the data is stable, LegendList will not re-render the entire list\n      data={tlds}\n      renderItem={renderItem}\n    />\n  )\n}\n\nfunction DomainItem({ tld }: { tld: Tld }) {\n  // good: transform within items, and don't pass the dynamic data as a prop\n  // good: use a selector function from zustand to receive a stable string back\n  const domain = useKeywordZustandState((s) => s.keyword + '.' + tld.name)\n  return <Text>{domain}</Text>\n}\n```\n\n**Updating parent array reference:**\n\nCreating a new array instance can be okay, as long as its inner object\nreferences are stable. For instance, if you sort a list of objects:\n\n```tsx\n// good: creates a new array instance without mutating the inner objects\n// good: parent array reference is unaffected by typing and updating \"keyword\"\nconst sortedTlds = tlds.toSorted((a, b) => a.name.localeCompare(b.name))\n\nreturn <LegendList data={sortedTlds} renderItem={renderItem} />\n```\n\nEven though this creates a new array instance `sortedTlds`, the inner object\nreferences are stable.\n\n**With zustand for dynamic data (avoids parent re-renders):**\n\n```tsx\nconst useSearchStore = create<{ keyword: string }>(() => ({ keyword: '' }))\n\nfunction DomainSearch() {\n  const { data: tlds } = useTlds()\n\n  return (\n    <>\n      <SearchInput />\n      <LegendList\n        data={tlds}\n        // if you aren't using React Compiler, wrap renderItem with useCallback\n        renderItem={({ item }) => <DomainItem tld={item} />}\n      />\n    </>\n  )\n}\n\nfunction DomainItem({ tld }: { tld: Tld }) {\n  // Select only what you need—component only re-renders when keyword changes\n  const keyword = useSearchStore((s) => s.keyword)\n  const domain = `${keyword}.${tld.name}`\n  return <Text>{domain}</Text>\n}\n```\n\nVirtualization can now skip items that haven't changed when typing. Only visible\nitems (~20) re-render on keystroke, rather than the parent.\n\n**Deriving state within list items based on parent data (avoids parent\nre-renders):**\n\nFor components where the data is conditional based on the parent state, this\npattern is even more important. For example, if you are checking if an item is\nfavorited, toggling favorites only re-renders one component if the item itself\nis in charge of accessing the state rather than the parent:\n\n```tsx\nfunction DomainItemFavoriteButton({ tld }: { tld: Tld }) {\n  const isFavorited = useFavoritesStore((s) => s.favorites.has(tld.id))\n  return <TldFavoriteButton isFavorited={isFavorited} />\n}\n```\n\nNote: if you're using the React Compiler, you can read React Context values\ndirectly within list items. Although this is slightly slower than using a\nZustand selector in most cases, the effect may be negligible.\n",
        "skills/react-native/rules/list-performance-images.md": "---\ntitle: Use Compressed Images in Lists\nimpact: HIGH\nimpactDescription: faster load times, less memory\ntags: lists, images, performance, optimization\n---\n\n## Use Compressed Images in Lists\n\nAlways load compressed, appropriately-sized images in lists. Full-resolution\nimages consume excessive memory and cause scroll jank. Request thumbnails from\nyour server or use an image CDN with resize parameters.\n\n**Incorrect (full-resolution images):**\n\n```tsx\nfunction ProductItem({ product }: { product: Product }) {\n  return (\n    <View>\n      {/* 4000x3000 image loaded for a 100x100 thumbnail */}\n      <Image\n        source={{ uri: product.imageUrl }}\n        style={{ width: 100, height: 100 }}\n      />\n      <Text>{product.name}</Text>\n    </View>\n  )\n}\n```\n\n**Correct (request appropriately-sized image):**\n\n```tsx\nfunction ProductItem({ product }: { product: Product }) {\n  // Request a 200x200 image (2x for retina)\n  const thumbnailUrl = `${product.imageUrl}?w=200&h=200&fit=cover`\n\n  return (\n    <View>\n      <Image\n        source={{ uri: thumbnailUrl }}\n        style={{ width: 100, height: 100 }}\n        contentFit='cover'\n      />\n      <Text>{product.name}</Text>\n    </View>\n  )\n}\n```\n\nUse an optimized image component with built-in caching and placeholder support,\nsuch as `expo-image` or `SolitoImage` (which uses `expo-image` under the hood).\nRequest images at 2x the display size for retina screens.\n",
        "skills/react-native/rules/list-performance-inline-objects.md": "---\ntitle: Avoid Inline Objects in renderItem\nimpact: HIGH\nimpactDescription: prevents unnecessary re-renders of memoized list items\ntags: lists, performance, flatlist, virtualization, memo\n---\n\n## Avoid Inline Objects in renderItem\n\nDon't create new objects inside `renderItem` to pass as props. Inline objects\ncreate new references on every render, breaking memoization. Pass primitive\nvalues directly from `item` instead.\n\n**Incorrect (inline object breaks memoization):**\n\n```tsx\nfunction UserList({ users }: { users: User[] }) {\n  return (\n    <LegendList\n      data={users}\n      renderItem={({ item }) => (\n        <UserRow\n          // Bad: new object on every render\n          user={{ id: item.id, name: item.name, avatar: item.avatar }}\n        />\n      )}\n    />\n  )\n}\n```\n\n**Incorrect (inline style object):**\n\n```tsx\nrenderItem={({ item }) => (\n  <UserRow\n    name={item.name}\n    // Bad: new style object on every render\n    style={{ backgroundColor: item.isActive ? 'green' : 'gray' }}\n  />\n)}\n```\n\n**Correct (pass item directly or primitives):**\n\n```tsx\nfunction UserList({ users }: { users: User[] }) {\n  return (\n    <LegendList\n      data={users}\n      renderItem={({ item }) => (\n        // Good: pass the item directly\n        <UserRow user={item} />\n      )}\n    />\n  )\n}\n```\n\n**Correct (pass primitives, derive inside child):**\n\n```tsx\nrenderItem={({ item }) => (\n  <UserRow\n    id={item.id}\n    name={item.name}\n    isActive={item.isActive}\n  />\n)}\n\nconst UserRow = memo(function UserRow({ id, name, isActive }: Props) {\n  // Good: derive style inside memoized component\n  const backgroundColor = isActive ? 'green' : 'gray'\n  return <View style={[styles.row, { backgroundColor }]}>{/* ... */}</View>\n})\n```\n\n**Correct (hoist static styles in module scope):**\n\n```tsx\nconst activeStyle = { backgroundColor: 'green' }\nconst inactiveStyle = { backgroundColor: 'gray' }\n\nrenderItem={({ item }) => (\n  <UserRow\n    name={item.name}\n    // Good: stable references\n    style={item.isActive ? activeStyle : inactiveStyle}\n  />\n)}\n```\n\nPassing primitives or stable references allows `memo()` to skip re-renders when\nthe actual values haven't changed.\n\n**Note:** If you have the React Compiler enabled, it handles memoization\nautomatically and these manual optimizations become less critical.\n",
        "skills/react-native/rules/list-performance-item-expensive.md": "---\ntitle: Keep List Items Lightweight\nimpact: HIGH\nimpactDescription: reduces render time for visible items during scroll\ntags: lists, performance, virtualization, hooks\n---\n\n## Keep List Items Lightweight\n\nList items should be as inexpensive as possible to render. Minimize hooks, avoid\nqueries, and limit React Context access. Virtualized lists render many items\nduring scroll—expensive items cause jank.\n\n**Incorrect (heavy list item):**\n\n```tsx\nfunction ProductRow({ id }: { id: string }) {\n  // Bad: query inside list item\n  const { data: product } = useQuery(['product', id], () => fetchProduct(id))\n  // Bad: multiple context accesses\n  const theme = useContext(ThemeContext)\n  const user = useContext(UserContext)\n  const cart = useContext(CartContext)\n  // Bad: expensive computation\n  const recommendations = useMemo(\n    () => computeRecommendations(product),\n    [product]\n  )\n\n  return <View>{/* ... */}</View>\n}\n```\n\n**Correct (lightweight list item):**\n\n```tsx\nfunction ProductRow({ name, price, imageUrl }: Props) {\n  // Good: receives only primitives, minimal hooks\n  return (\n    <View>\n      <Image source={{ uri: imageUrl }} />\n      <Text>{name}</Text>\n      <Text>{price}</Text>\n    </View>\n  )\n}\n```\n\n**Move data fetching to parent:**\n\n```tsx\n// Parent fetches all data once\nfunction ProductList() {\n  const { data: products } = useQuery(['products'], fetchProducts)\n\n  return (\n    <LegendList\n      data={products}\n      renderItem={({ item }) => (\n        <ProductRow name={item.name} price={item.price} imageUrl={item.image} />\n      )}\n    />\n  )\n}\n```\n\n**For shared values, use Zustand selectors instead of Context:**\n\n```tsx\n// Incorrect: Context causes re-render when any cart value changes\nfunction ProductRow({ id, name }: Props) {\n  const { items } = useContext(CartContext)\n  const inCart = items.includes(id)\n  // ...\n}\n\n// Correct: Zustand selector only re-renders when this specific value changes\nfunction ProductRow({ id, name }: Props) {\n  // use Set.has (created once at the root) instead of Array.includes()\n  const inCart = useCartStore((s) => s.items.has(id))\n  // ...\n}\n```\n\n**Guidelines for list items:**\n\n- No queries or data fetching\n- No expensive computations (move to parent or memoize at parent level)\n- Prefer Zustand selectors over React Context\n- Minimize useState/useEffect hooks\n- Pass pre-computed values as props\n\nThe goal: list items should be simple rendering functions that take props and\nreturn JSX.\n",
        "skills/react-native/rules/list-performance-item-memo.md": "---\ntitle: Pass Primitives to List Items for Memoization\nimpact: HIGH\nimpactDescription: enables effective memo() comparison\ntags: lists, performance, memo, primitives\n---\n\n## Pass Primitives to List Items for Memoization\n\nWhen possible, pass only primitive values (strings, numbers, booleans) as props\nto list item components. Primitives enable shallow comparison in `memo()` to\nwork correctly, skipping re-renders when values haven't changed.\n\n**Incorrect (object prop requires deep comparison):**\n\n```tsx\ntype User = { id: string; name: string; email: string; avatar: string }\n\nconst UserRow = memo(function UserRow({ user }: { user: User }) {\n  // memo() compares user by reference, not value\n  // If parent creates new user object, this re-renders even if data is same\n  return <Text>{user.name}</Text>\n})\n\nrenderItem={({ item }) => <UserRow user={item} />}\n```\n\nThis can still be optimized, but it is harder to memoize properly.\n\n**Correct (primitive props enable shallow comparison):**\n\n```tsx\nconst UserRow = memo(function UserRow({\n  id,\n  name,\n  email,\n}: {\n  id: string\n  name: string\n  email: string\n}) {\n  // memo() compares each primitive directly\n  // Re-renders only if id, name, or email actually changed\n  return <Text>{name}</Text>\n})\n\nrenderItem={({ item }) => (\n  <UserRow id={item.id} name={item.name} email={item.email} />\n)}\n```\n\n**Pass only what you need:**\n\n```tsx\n// Incorrect: passing entire item when you only need name\n<UserRow user={item} />\n\n// Correct: pass only the fields the component uses\n<UserRow name={item.name} avatarUrl={item.avatar} />\n```\n\n**For callbacks, hoist or use item ID:**\n\n```tsx\n// Incorrect: inline function creates new reference\n<UserRow name={item.name} onPress={() => handlePress(item.id)} />\n\n// Correct: pass ID, handle in child\n<UserRow id={item.id} name={item.name} />\n\nconst UserRow = memo(function UserRow({ id, name }: Props) {\n  const handlePress = useCallback(() => {\n    // use id here\n  }, [id])\n  return <Pressable onPress={handlePress}><Text>{name}</Text></Pressable>\n})\n```\n\nPrimitive props make memoization predictable and effective.\n\n**Note:** If you have the React Compiler enabled, you do not need to use\n`memo()` or `useCallback()`, but the object references still apply.\n",
        "skills/react-native/rules/list-performance-item-types.md": "---\ntitle: Use Item Types for Heterogeneous Lists\nimpact: HIGH\nimpactDescription: efficient recycling, less layout thrashing\ntags: list, performance, recycling, heterogeneous, LegendList\n---\n\n## Use Item Types for Heterogeneous Lists\n\nWhen a list has different item layouts (messages, images, headers, etc.), use a\n`type` field on each item and provide `getItemType` to the list. This puts items\ninto separate recycling pools so a message component never gets recycled into an\nimage component.\n\n**Incorrect (single component with conditionals):**\n\n```tsx\ntype Item = { id: string; text?: string; imageUrl?: string; isHeader?: boolean }\n\nfunction ListItem({ item }: { item: Item }) {\n  if (item.isHeader) {\n    return <HeaderItem title={item.text} />\n  }\n  if (item.imageUrl) {\n    return <ImageItem url={item.imageUrl} />\n  }\n  return <MessageItem text={item.text} />\n}\n\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <LegendList\n      data={items}\n      renderItem={({ item }) => <ListItem item={item} />}\n      recycleItems\n    />\n  )\n}\n```\n\n**Correct (typed items with separate components):**\n\n```tsx\ntype HeaderItem = { id: string; type: 'header'; title: string }\ntype MessageItem = { id: string; type: 'message'; text: string }\ntype ImageItem = { id: string; type: 'image'; url: string }\ntype FeedItem = HeaderItem | MessageItem | ImageItem\n\nfunction Feed({ items }: { items: FeedItem[] }) {\n  return (\n    <LegendList\n      data={items}\n      keyExtractor={(item) => item.id}\n      getItemType={(item) => item.type}\n      renderItem={({ item }) => {\n        switch (item.type) {\n          case 'header':\n            return <SectionHeader title={item.title} />\n          case 'message':\n            return <MessageRow text={item.text} />\n          case 'image':\n            return <ImageRow url={item.url} />\n        }\n      }}\n      recycleItems\n    />\n  )\n}\n```\n\n**Why this matters:**\n\n- **Recycling efficiency**: Items with the same type share a recycling pool\n- **No layout thrashing**: A header never recycles into an image cell\n- **Type safety**: TypeScript can narrow the item type in each branch\n- **Better size estimation**: Use `getEstimatedItemSize` with `itemType` for\n  accurate estimates per type\n\n```tsx\n<LegendList\n  data={items}\n  keyExtractor={(item) => item.id}\n  getItemType={(item) => item.type}\n  getEstimatedItemSize={(index, item, itemType) => {\n    switch (itemType) {\n      case 'header':\n        return 48\n      case 'message':\n        return 72\n      case 'image':\n        return 300\n      default:\n        return 72\n    }\n  }}\n  renderItem={({ item }) => {\n    /* ... */\n  }}\n  recycleItems\n/>\n```\n\nReference:\n[LegendList getItemType](https://legendapp.com/open-source/list/api/props/#getitemtype-v2)\n",
        "skills/react-native/rules/list-performance-virtualize.md": "---\ntitle: Use a List Virtualizer for Any List\nimpact: HIGH\nimpactDescription: reduced memory, faster mounts\ntags: lists, performance, virtualization, scrollview\n---\n\n## Use a List Virtualizer for Any List\n\nUse a list virtualizer like LegendList or FlashList instead of ScrollView with\nmapped children—even for short lists. Virtualizers only render visible items,\nreducing memory usage and mount time. ScrollView renders all children upfront,\nwhich gets expensive quickly.\n\n**Incorrect (ScrollView renders all items at once):**\n\n```tsx\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <ScrollView>\n      {items.map((item) => (\n        <ItemCard key={item.id} item={item} />\n      ))}\n    </ScrollView>\n  )\n}\n// 50 items = 50 components mounted, even if only 10 visible\n```\n\n**Correct (virtualizer renders only visible items):**\n\n```tsx\nimport { LegendList } from '@legendapp/list'\n\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <LegendList\n      data={items}\n      // if you aren't using React Compiler, wrap these with useCallback\n      renderItem={({ item }) => <ItemCard item={item} />}\n      keyExtractor={(item) => item.id}\n      estimatedItemSize={80}\n    />\n  )\n}\n// Only ~10-15 visible items mounted at a time\n```\n\n**Alternative (FlashList):**\n\n```tsx\nimport { FlashList } from '@shopify/flash-list'\n\nfunction Feed({ items }: { items: Item[] }) {\n  return (\n    <FlashList\n      data={items}\n      // if you aren't using React Compiler, wrap these with useCallback\n      renderItem={({ item }) => <ItemCard item={item} />}\n      keyExtractor={(item) => item.id}\n    />\n  )\n}\n```\n\nBenefits apply to any screen with scrollable content—profiles, settings, feeds,\nsearch results. Default to virtualization.\n",
        "skills/react-native/rules/monorepo-native-deps-in-app.md": "---\ntitle: Install Native Dependencies in App Directory\nimpact: CRITICAL\nimpactDescription: required for autolinking to work\ntags: monorepo, native, autolinking, installation\n---\n\n## Install Native Dependencies in App Directory\n\nIn a monorepo, packages with native code must be installed in the native app's\ndirectory directly. Autolinking only scans the app's `node_modules`—it won't\nfind native dependencies installed in other packages.\n\n**Incorrect (native dep in shared package only):**\n\n```\npackages/\n  ui/\n    package.json  # has react-native-reanimated\n  app/\n    package.json  # missing react-native-reanimated\n```\n\nAutolinking fails—native code not linked.\n\n**Correct (native dep in app directory):**\n\n```\npackages/\n  ui/\n    package.json  # has react-native-reanimated\n  app/\n    package.json  # also has react-native-reanimated\n```\n\n```json\n// packages/app/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"3.16.1\"\n  }\n}\n```\n\nEven if the shared package uses the native dependency, the app must also list it\nfor autolinking to detect and link the native code.\n",
        "skills/react-native/rules/monorepo-single-dependency-versions.md": "---\ntitle: Use Single Dependency Versions Across Monorepo\nimpact: MEDIUM\nimpactDescription: avoids duplicate bundles, version conflicts\ntags: monorepo, dependencies, installation\n---\n\n## Use Single Dependency Versions Across Monorepo\n\nUse a single version of each dependency across all packages in your monorepo.\nPrefer exact versions over ranges. Multiple versions cause duplicate code in\nbundles, runtime conflicts, and inconsistent behavior across packages.\n\nUse a tool like syncpack to enforce this. As a last resort, use yarn resolutions\nor npm overrides.\n\n**Incorrect (version ranges, multiple versions):**\n\n```json\n// packages/app/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"^3.0.0\"\n  }\n}\n\n// packages/ui/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"^3.5.0\"\n  }\n}\n```\n\n**Correct (exact versions, single source of truth):**\n\n```json\n// package.json (root)\n{\n  \"pnpm\": {\n    \"overrides\": {\n      \"react-native-reanimated\": \"3.16.1\"\n    }\n  }\n}\n\n// packages/app/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"3.16.1\"\n  }\n}\n\n// packages/ui/package.json\n{\n  \"dependencies\": {\n    \"react-native-reanimated\": \"3.16.1\"\n  }\n}\n```\n\nUse your package manager's override/resolution feature to enforce versions at\nthe root. When adding dependencies, specify exact versions without `^` or `~`.\n",
        "skills/react-native/rules/navigation-native-navigators.md": "---\ntitle: Use Native Navigators for Navigation\nimpact: HIGH\nimpactDescription: native performance, platform-appropriate UI\ntags: navigation, react-navigation, expo-router, native-stack, tabs\n---\n\n## Use Native Navigators for Navigation\n\nAlways use native navigators instead of JS-based ones. Native navigators use\nplatform APIs (UINavigationController on iOS, Fragment on Android) for better\nperformance and native behavior.\n\n**For stacks:** Use `@react-navigation/native-stack` or expo-router's default\nstack (which uses native-stack). Avoid `@react-navigation/stack`.\n\n**For tabs:** Use `react-native-bottom-tabs` (native) or expo-router's native\ntabs. Avoid `@react-navigation/bottom-tabs` when native feel matters.\n\n### Stack Navigation\n\n**Incorrect (JS stack navigator):**\n\n```tsx\nimport { createStackNavigator } from '@react-navigation/stack'\n\nconst Stack = createStackNavigator()\n\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name='Home' component={HomeScreen} />\n      <Stack.Screen name='Details' component={DetailsScreen} />\n    </Stack.Navigator>\n  )\n}\n```\n\n**Correct (native stack with react-navigation):**\n\n```tsx\nimport { createNativeStackNavigator } from '@react-navigation/native-stack'\n\nconst Stack = createNativeStackNavigator()\n\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name='Home' component={HomeScreen} />\n      <Stack.Screen name='Details' component={DetailsScreen} />\n    </Stack.Navigator>\n  )\n}\n```\n\n**Correct (expo-router uses native stack by default):**\n\n```tsx\n// app/_layout.tsx\nimport { Stack } from 'expo-router'\n\nexport default function Layout() {\n  return <Stack />\n}\n```\n\n### Tab Navigation\n\n**Incorrect (JS bottom tabs):**\n\n```tsx\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs'\n\nconst Tab = createBottomTabNavigator()\n\nfunction App() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name='Home' component={HomeScreen} />\n      <Tab.Screen name='Settings' component={SettingsScreen} />\n    </Tab.Navigator>\n  )\n}\n```\n\n**Correct (native bottom tabs with react-navigation):**\n\n```tsx\nimport { createNativeBottomTabNavigator } from '@bottom-tabs/react-navigation'\n\nconst Tab = createNativeBottomTabNavigator()\n\nfunction App() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen\n        name='Home'\n        component={HomeScreen}\n        options={{\n          tabBarIcon: () => ({ sfSymbol: 'house' }),\n        }}\n      />\n      <Tab.Screen\n        name='Settings'\n        component={SettingsScreen}\n        options={{\n          tabBarIcon: () => ({ sfSymbol: 'gear' }),\n        }}\n      />\n    </Tab.Navigator>\n  )\n}\n```\n\n**Correct (expo-router native tabs):**\n\n```tsx\n// app/(tabs)/_layout.tsx\nimport { NativeTabs } from 'expo-router/unstable-native-tabs'\n\nexport default function TabLayout() {\n  return (\n    <NativeTabs>\n      <NativeTabs.Trigger name='index'>\n        <NativeTabs.Trigger.Label>Home</NativeTabs.Trigger.Label>\n        <NativeTabs.Trigger.Icon sf='house.fill' md='home' />\n      </NativeTabs.Trigger>\n      <NativeTabs.Trigger name='settings'>\n        <NativeTabs.Trigger.Label>Settings</NativeTabs.Trigger.Label>\n        <NativeTabs.Trigger.Icon sf='gear' md='settings' />\n      </NativeTabs.Trigger>\n    </NativeTabs>\n  )\n}\n```\n\nOn iOS, native tabs automatically enable `contentInsetAdjustmentBehavior` on the\nfirst `ScrollView` at the root of each tab screen, so content scrolls correctly\nbehind the translucent tab bar. If you need to disable this, use\n`disableAutomaticContentInsets` on the trigger.\n\n### Prefer Native Header Options Over Custom Components\n\n**Incorrect (custom header component):**\n\n```tsx\n<Stack.Screen\n  name='Profile'\n  component={ProfileScreen}\n  options={{\n    header: () => <CustomHeader title='Profile' />,\n  }}\n/>\n```\n\n**Correct (native header options):**\n\n```tsx\n<Stack.Screen\n  name='Profile'\n  component={ProfileScreen}\n  options={{\n    title: 'Profile',\n    headerLargeTitleEnabled: true,\n    headerSearchBarOptions: {\n      placeholder: 'Search',\n    },\n  }}\n/>\n```\n\nNative headers support iOS large titles, search bars, blur effects, and proper\nsafe area handling automatically.\n\n### Why Native Navigators\n\n- **Performance**: Native transitions and gestures run on the UI thread\n- **Platform behavior**: Automatic iOS large titles, Android material design\n- **System integration**: Scroll-to-top on tab tap, PiP avoidance, proper safe\n  areas\n- **Accessibility**: Platform accessibility features work automatically\n\nReference:\n\n- [React Navigation Native Stack](https://reactnavigation.org/docs/native-stack-navigator)\n- [React Native Bottom Tabs with React Navigation](https://oss.callstack.com/react-native-bottom-tabs/docs/guides/usage-with-react-navigation)\n- [React Native Bottom Tabs with Expo Router](https://oss.callstack.com/react-native-bottom-tabs/docs/guides/usage-with-expo-router)\n- [Expo Router Native Tabs](https://docs.expo.dev/router/advanced/native-tabs)\n",
        "skills/react-native/rules/react-compiler-destructure-functions.md": "---\ntitle: Destructure Functions Early in Render (React Compiler)\nimpact: HIGH\nimpactDescription: stable references, fewer re-renders\ntags: rerender, hooks, performance, react-compiler\n---\n\n## Destructure Functions Early in Render\n\nThis rule is only applicable if you are using the React Compiler.\n\nDestructure functions from hooks at the top of render scope. Never dot into\nobjects to call functions. Destructured functions are stable references; dotting\ncreates new references and breaks memoization.\n\n**Incorrect (dotting into object):**\n\n```tsx\nimport { useRouter } from 'expo-router'\n\nfunction SaveButton(props) {\n  const router = useRouter()\n\n  // bad: react-compiler will key the cache on \"props\" and \"router\", which are objects that change each render\n  const handlePress = () => {\n    props.onSave()\n    router.push('/success') // unstable reference\n  }\n\n  return <Button onPress={handlePress}>Save</Button>\n}\n```\n\n**Correct (destructure early):**\n\n```tsx\nimport { useRouter } from 'expo-router'\n\nfunction SaveButton({ onSave }) {\n  const { push } = useRouter()\n\n  // good: react-compiler will key on push and onSave\n  const handlePress = () => {\n    onSave()\n    push('/success') // stable reference\n  }\n\n  return <Button onPress={handlePress}>Save</Button>\n}\n```\n",
        "skills/react-native/rules/react-compiler-reanimated-shared-values.md": "---\ntitle: Use .get() and .set() for Reanimated Shared Values (not .value)\nimpact: LOW\nimpactDescription: required for React Compiler compatibility\ntags: reanimated, react-compiler, shared-values\n---\n\n## Use .get() and .set() for Shared Values with React Compiler\n\nWith React Compiler enabled, use `.get()` and `.set()` instead of reading or\nwriting `.value` directly on Reanimated shared values. The compiler can't track\nproperty access—explicit methods ensure correct behavior.\n\n**Incorrect (breaks with React Compiler):**\n\n```tsx\nimport { useSharedValue } from 'react-native-reanimated'\n\nfunction Counter() {\n  const count = useSharedValue(0)\n\n  const increment = () => {\n    count.value = count.value + 1 // opts out of react compiler\n  }\n\n  return <Button onPress={increment} title={`Count: ${count.value}`} />\n}\n```\n\n**Correct (React Compiler compatible):**\n\n```tsx\nimport { useSharedValue } from 'react-native-reanimated'\n\nfunction Counter() {\n  const count = useSharedValue(0)\n\n  const increment = () => {\n    count.set(count.get() + 1)\n  }\n\n  return <Button onPress={increment} title={`Count: ${count.get()}`} />\n}\n```\n\nSee the\n[Reanimated docs](https://docs.swmansion.com/react-native-reanimated/docs/core/useSharedValue/#react-compiler-support)\nfor more.\n",
        "skills/react-native/rules/react-state-dispatcher.md": "---\ntitle: useState Dispatch updaters for State That Depends on Current Value\nimpact: MEDIUM\nimpactDescription: avoids stale closures, prevents unnecessary re-renders\ntags: state, hooks, useState, callbacks\n---\n\n## Use Dispatch Updaters for State That Depends on Current Value\n\nWhen the next state depends on the current state, use a dispatch updater\n(`setState(prev => ...)`) instead of reading the state variable directly in a\ncallback. This avoids stale closures and ensures you're comparing against the\nlatest value.\n\n**Incorrect (reads state directly):**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  // size may be stale in this closure\n  if (size?.width !== width || size?.height !== height) {\n    setSize({ width, height })\n  }\n}\n```\n\n**Correct (dispatch updater):**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  setSize((prev) => {\n    if (prev?.width === width && prev?.height === height) return prev\n    return { width, height }\n  })\n}\n```\n\nReturning the previous value from the updater skips the re-render.\n\nFor primitive states, you don't need to compare values before firing a\nre-render.\n\n**Incorrect (unnecessary comparison for primitive state):**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  setSize((prev) => (prev === width ? prev : width))\n}\n```\n\n**Correct (sets primitive state directly):**\n\n```tsx\nconst [size, setSize] = useState<Size | undefined>(undefined)\n\nconst onLayout = (e: LayoutChangeEvent) => {\n  const { width, height } = e.nativeEvent.layout\n  setSize(width)\n}\n```\n\nHowever, if the next state depends on the current state, you should still use a\ndispatch updater.\n\n**Incorrect (reads state directly from the callback):**\n\n```tsx\nconst [count, setCount] = useState(0)\n\nconst onTap = () => {\n  setCount(count + 1)\n}\n```\n\n**Correct (dispatch updater):**\n\n```tsx\nconst [count, setCount] = useState(0)\n\nconst onTap = () => {\n  setCount((prev) => prev + 1)\n}\n```\n",
        "skills/react-native/rules/react-state-fallback.md": "---\ntitle: Use fallback state instead of initialState\nimpact: MEDIUM\nimpactDescription: reactive fallbacks without syncing\ntags: state, hooks, derived-state, props, initialState\n---\n\n## Use fallback state instead of initialState\n\nUse `undefined` as initial state and nullish coalescing (`??`) to fall back to\nparent or server values. State represents user intent only—`undefined` means\n\"user hasn't chosen yet.\" This enables reactive fallbacks that update when the\nsource changes, not just on initial render.\n\n**Incorrect (syncs state, loses reactivity):**\n\n```tsx\ntype Props = { fallbackEnabled: boolean }\n\nfunction Toggle({ fallbackEnabled }: Props) {\n  const [enabled, setEnabled] = useState(defaultEnabled)\n  // If fallbackEnabled changes, state is stale\n  // State mixes user intent with default value\n\n  return <Switch value={enabled} onValueChange={setEnabled} />\n}\n```\n\n**Correct (state is user intent, reactive fallback):**\n\n```tsx\ntype Props = { fallbackEnabled: boolean }\n\nfunction Toggle({ fallbackEnabled }: Props) {\n  const [_enabled, setEnabled] = useState<boolean | undefined>(undefined)\n  const enabled = _enabled ?? defaultEnabled\n  // undefined = user hasn't touched it, falls back to prop\n  // If defaultEnabled changes, component reflects it\n  // Once user interacts, their choice persists\n\n  return <Switch value={enabled} onValueChange={setEnabled} />\n}\n```\n\n**With server data:**\n\n```tsx\nfunction ProfileForm({ data }: { data: User }) {\n  const [_theme, setTheme] = useState<string | undefined>(undefined)\n  const theme = _theme ?? data.theme\n  // Shows server value until user overrides\n  // Server refetch updates the fallback automatically\n\n  return <ThemePicker value={theme} onChange={setTheme} />\n}\n```\n",
        "skills/react-native/rules/react-state-minimize.md": "---\ntitle: Minimize State Variables and Derive Values\nimpact: MEDIUM\nimpactDescription: fewer re-renders, less state drift\ntags: state, derived-state, hooks, optimization\n---\n\n## Minimize State Variables and Derive Values\n\nUse the fewest state variables possible. If a value can be computed from existing state or props, derive it during render instead of storing it in state. Redundant state causes unnecessary re-renders and can drift out of sync.\n\n**Incorrect (redundant state):**\n\n```tsx\nfunction Cart({ items }: { items: Item[] }) {\n  const [total, setTotal] = useState(0)\n  const [itemCount, setItemCount] = useState(0)\n\n  useEffect(() => {\n    setTotal(items.reduce((sum, item) => sum + item.price, 0))\n    setItemCount(items.length)\n  }, [items])\n\n  return (\n    <View>\n      <Text>{itemCount} items</Text>\n      <Text>Total: ${total}</Text>\n    </View>\n  )\n}\n```\n\n**Correct (derived values):**\n\n```tsx\nfunction Cart({ items }: { items: Item[] }) {\n  const total = items.reduce((sum, item) => sum + item.price, 0)\n  const itemCount = items.length\n\n  return (\n    <View>\n      <Text>{itemCount} items</Text>\n      <Text>Total: ${total}</Text>\n    </View>\n  )\n}\n```\n\n**Another example:**\n\n```tsx\n// Incorrect: storing both firstName, lastName, AND fullName\nconst [firstName, setFirstName] = useState('')\nconst [lastName, setLastName] = useState('')\nconst [fullName, setFullName] = useState('')\n\n// Correct: derive fullName\nconst [firstName, setFirstName] = useState('')\nconst [lastName, setLastName] = useState('')\nconst fullName = `${firstName} ${lastName}`\n```\n\nState should be the minimal source of truth. Everything else is derived.\n\nReference: [Choosing the State Structure](https://react.dev/learn/choosing-the-state-structure)\n",
        "skills/react-native/rules/rendering-no-falsy-and.md": "---\ntitle: Never Use && with Potentially Falsy Values\nimpact: CRITICAL\nimpactDescription: prevents production crash\ntags: rendering, conditional, jsx, crash\n---\n\n## Never Use && with Potentially Falsy Values\n\nNever use `{value && <Component />}` when `value` could be an empty string or\n`0`. These are falsy but JSX-renderable—React Native will try to render them as\ntext outside a `<Text>` component, causing a hard crash in production.\n\n**Incorrect (crashes if count is 0 or name is \"\"):**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  return (\n    <View>\n      {name && <Text>{name}</Text>}\n      {count && <Text>{count} items</Text>}\n    </View>\n  )\n}\n// If name=\"\" or count=0, renders the falsy value → crash\n```\n\n**Correct (ternary with null):**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  return (\n    <View>\n      {name ? <Text>{name}</Text> : null}\n      {count ? <Text>{count} items</Text> : null}\n    </View>\n  )\n}\n```\n\n**Correct (explicit boolean coercion):**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  return (\n    <View>\n      {!!name && <Text>{name}</Text>}\n      {!!count && <Text>{count} items</Text>}\n    </View>\n  )\n}\n```\n\n**Best (early return):**\n\n```tsx\nfunction Profile({ name, count }: { name: string; count: number }) {\n  if (!name) return null\n\n  return (\n    <View>\n      <Text>{name}</Text>\n      {count > 0 ? <Text>{count} items</Text> : null}\n    </View>\n  )\n}\n```\n\nEarly returns are clearest. When using conditionals inline, prefer ternary or\nexplicit boolean checks.\n\n**Lint rule:** Enable `react/jsx-no-leaked-render` from\n[eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/jsx-no-leaked-render.md)\nto catch this automatically.\n",
        "skills/react-native/rules/rendering-text-in-text-component.md": "---\ntitle: Wrap Strings in Text Components\nimpact: CRITICAL\nimpactDescription: prevents runtime crash\ntags: rendering, text, core\n---\n\n## Wrap Strings in Text Components\n\nStrings must be rendered inside `<Text>`. React Native crashes if a string is a\ndirect child of `<View>`.\n\n**Incorrect (crashes):**\n\n```tsx\nimport { View } from 'react-native'\n\nfunction Greeting({ name }: { name: string }) {\n  return <View>Hello, {name}!</View>\n}\n// Error: Text strings must be rendered within a <Text> component.\n```\n\n**Correct:**\n\n```tsx\nimport { View, Text } from 'react-native'\n\nfunction Greeting({ name }: { name: string }) {\n  return (\n    <View>\n      <Text>Hello, {name}!</Text>\n    </View>\n  )\n}\n```\n",
        "skills/react-native/rules/scroll-position-no-state.md": "---\ntitle: Never Track Scroll Position in useState\nimpact: HIGH\nimpactDescription: prevents render thrashing during scroll\ntags: scroll, performance, reanimated, useRef\n---\n\n## Never Track Scroll Position in useState\n\nNever store scroll position in `useState`. Scroll events fire rapidly—state\nupdates cause render thrashing and dropped frames. Use a Reanimated shared value\nfor animations or a ref for non-reactive tracking.\n\n**Incorrect (useState causes jank):**\n\n```tsx\nimport { useState } from 'react'\nimport {\n  ScrollView,\n  NativeSyntheticEvent,\n  NativeScrollEvent,\n} from 'react-native'\n\nfunction Feed() {\n  const [scrollY, setScrollY] = useState(0)\n\n  const onScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {\n    setScrollY(e.nativeEvent.contentOffset.y) // re-renders on every frame\n  }\n\n  return <ScrollView onScroll={onScroll} scrollEventThrottle={16} />\n}\n```\n\n**Correct (Reanimated for animations):**\n\n```tsx\nimport Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n} from 'react-native-reanimated'\n\nfunction Feed() {\n  const scrollY = useSharedValue(0)\n\n  const onScroll = useAnimatedScrollHandler({\n    onScroll: (e) => {\n      scrollY.value = e.contentOffset.y // runs on UI thread, no re-render\n    },\n  })\n\n  return (\n    <Animated.ScrollView\n      onScroll={onScroll}\n      // higher number has better performance, but it fires less often.\n      // unset this if you need higher precision over performance.\n      scrollEventThrottle={16}\n    />\n  )\n}\n```\n\n**Correct (ref for non-reactive tracking):**\n\n```tsx\nimport { useRef } from 'react'\nimport {\n  ScrollView,\n  NativeSyntheticEvent,\n  NativeScrollEvent,\n} from 'react-native'\n\nfunction Feed() {\n  const scrollY = useRef(0)\n\n  const onScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {\n    scrollY.current = e.nativeEvent.contentOffset.y // no re-render\n  }\n\n  return <ScrollView onScroll={onScroll} scrollEventThrottle={16} />\n}\n```\n",
        "skills/react-native/rules/state-ground-truth.md": "---\ntitle: State Must Represent Ground Truth\nimpact: HIGH\nimpactDescription: cleaner logic, easier debugging, single source of truth\ntags: state, derived-state, reanimated, hooks\n---\n\n## State Must Represent Ground Truth\n\nState variables—both React `useState` and Reanimated shared values—should\nrepresent the actual state of something (e.g., `pressed`, `progress`, `isOpen`),\nnot derived visual values (e.g., `scale`, `opacity`, `translateY`). Derive\nvisual values from state using computation or interpolation.\n\n**Incorrect (storing the visual output):**\n\n```tsx\nconst scale = useSharedValue(1)\n\nconst tap = Gesture.Tap()\n  .onBegin(() => {\n    scale.set(withTiming(0.95))\n  })\n  .onFinalize(() => {\n    scale.set(withTiming(1))\n  })\n\nconst animatedStyle = useAnimatedStyle(() => ({\n  transform: [{ scale: scale.get() }],\n}))\n```\n\n**Correct (storing the state, deriving the visual):**\n\n```tsx\nconst pressed = useSharedValue(0) // 0 = not pressed, 1 = pressed\n\nconst tap = Gesture.Tap()\n  .onBegin(() => {\n    pressed.set(withTiming(1))\n  })\n  .onFinalize(() => {\n    pressed.set(withTiming(0))\n  })\n\nconst animatedStyle = useAnimatedStyle(() => ({\n  transform: [{ scale: interpolate(pressed.get(), [0, 1], [1, 0.95]) }],\n}))\n```\n\n**Why this matters:**\n\nState variables should represent real \"state\", not necessarily a desired end\nresult.\n\n1. **Single source of truth** — The state (`pressed`) describes what's\n   happening; visuals are derived\n2. **Easier to extend** — Adding opacity, rotation, or other effects just\n   requires more interpolations from the same state\n3. **Debugging** — Inspecting `pressed = 1` is clearer than `scale = 0.95`\n4. **Reusable logic** — The same `pressed` value can drive multiple visual\n   properties\n\n**Same principle for React state:**\n\n```tsx\n// Incorrect: storing derived values\nconst [isExpanded, setIsExpanded] = useState(false)\nconst [height, setHeight] = useState(0)\n\nuseEffect(() => {\n  setHeight(isExpanded ? 200 : 0)\n}, [isExpanded])\n\n// Correct: derive from state\nconst [isExpanded, setIsExpanded] = useState(false)\nconst height = isExpanded ? 200 : 0\n```\n\nState is the minimal truth. Everything else is derived.\n",
        "skills/react-native/rules/ui-expo-image.md": "---\ntitle: Use expo-image for Optimized Images\nimpact: HIGH\nimpactDescription: memory efficiency, caching, blurhash placeholders, progressive loading\ntags: images, performance, expo-image, ui\n---\n\n## Use expo-image for Optimized Images\n\nUse `expo-image` instead of React Native's `Image`. It provides memory-efficient caching, blurhash placeholders, progressive loading, and better performance for lists.\n\n**Incorrect (React Native Image):**\n\n```tsx\nimport { Image } from 'react-native'\n\nfunction Avatar({ url }: { url: string }) {\n  return <Image source={{ uri: url }} style={styles.avatar} />\n}\n```\n\n**Correct (expo-image):**\n\n```tsx\nimport { Image } from 'expo-image'\n\nfunction Avatar({ url }: { url: string }) {\n  return <Image source={{ uri: url }} style={styles.avatar} />\n}\n```\n\n**With blurhash placeholder:**\n\n```tsx\n<Image\n  source={{ uri: url }}\n  placeholder={{ blurhash: 'LGF5]+Yk^6#M@-5c,1J5@[or[Q6.' }}\n  contentFit=\"cover\"\n  transition={200}\n  style={styles.image}\n/>\n```\n\n**With priority and caching:**\n\n```tsx\n<Image\n  source={{ uri: url }}\n  priority=\"high\"\n  cachePolicy=\"memory-disk\"\n  style={styles.hero}\n/>\n```\n\n**Key props:**\n\n- `placeholder` — Blurhash or thumbnail while loading\n- `contentFit` — `cover`, `contain`, `fill`, `scale-down`\n- `transition` — Fade-in duration (ms)\n- `priority` — `low`, `normal`, `high`\n- `cachePolicy` — `memory`, `disk`, `memory-disk`, `none`\n- `recyclingKey` — Unique key for list recycling\n\nFor cross-platform (web + native), use `SolitoImage` from `solito/image` which uses `expo-image` under the hood.\n\nReference: [expo-image](https://docs.expo.dev/versions/latest/sdk/image/)\n",
        "skills/react-native/rules/ui-image-gallery.md": "---\ntitle: Use Galeria for Image Galleries and Lightbox\nimpact: MEDIUM\nimpactDescription:\n  native shared element transitions, pinch-to-zoom, pan-to-close\ntags: images, gallery, lightbox, expo-image, ui\n---\n\n## Use Galeria for Image Galleries and Lightbox\n\nFor image galleries with lightbox (tap to fullscreen), use `@nandorojo/galeria`.\nIt provides native shared element transitions with pinch-to-zoom, double-tap\nzoom, and pan-to-close. Works with any image component including `expo-image`.\n\n**Incorrect (custom modal implementation):**\n\n```tsx\nfunction ImageGallery({ urls }: { urls: string[] }) {\n  const [selected, setSelected] = useState<string | null>(null)\n\n  return (\n    <>\n      {urls.map((url) => (\n        <Pressable key={url} onPress={() => setSelected(url)}>\n          <Image source={{ uri: url }} style={styles.thumbnail} />\n        </Pressable>\n      ))}\n      <Modal visible={!!selected} onRequestClose={() => setSelected(null)}>\n        <Image source={{ uri: selected! }} style={styles.fullscreen} />\n      </Modal>\n    </>\n  )\n}\n```\n\n**Correct (Galeria with expo-image):**\n\n```tsx\nimport { Galeria } from '@nandorojo/galeria'\nimport { Image } from 'expo-image'\n\nfunction ImageGallery({ urls }: { urls: string[] }) {\n  return (\n    <Galeria urls={urls}>\n      {urls.map((url, index) => (\n        <Galeria.Image index={index} key={url}>\n          <Image source={{ uri: url }} style={styles.thumbnail} />\n        </Galeria.Image>\n      ))}\n    </Galeria>\n  )\n}\n```\n\n**Single image:**\n\n```tsx\nimport { Galeria } from '@nandorojo/galeria'\nimport { Image } from 'expo-image'\n\nfunction Avatar({ url }: { url: string }) {\n  return (\n    <Galeria urls={[url]}>\n      <Galeria.Image>\n        <Image source={{ uri: url }} style={styles.avatar} />\n      </Galeria.Image>\n    </Galeria>\n  )\n}\n```\n\n**With low-res thumbnails and high-res fullscreen:**\n\n```tsx\n<Galeria urls={highResUrls}>\n  {lowResUrls.map((url, index) => (\n    <Galeria.Image index={index} key={url}>\n      <Image source={{ uri: url }} style={styles.thumbnail} />\n    </Galeria.Image>\n  ))}\n</Galeria>\n```\n\n**With FlashList:**\n\n```tsx\n<Galeria urls={urls}>\n  <FlashList\n    data={urls}\n    renderItem={({ item, index }) => (\n      <Galeria.Image index={index}>\n        <Image source={{ uri: item }} style={styles.thumbnail} />\n      </Galeria.Image>\n    )}\n    numColumns={3}\n    estimatedItemSize={100}\n  />\n</Galeria>\n```\n\nWorks with `expo-image`, `SolitoImage`, `react-native` Image, or any image\ncomponent.\n\nReference: [Galeria](https://github.com/nandorojo/galeria)\n",
        "skills/react-native/rules/ui-measure-views.md": "---\ntitle: Measuring View Dimensions\nimpact: MEDIUM\nimpactDescription: synchronous measurement, avoid unnecessary re-renders\ntags: layout, measurement, onLayout, useLayoutEffect\n---\n\n## Measuring View Dimensions\n\nUse both `useLayoutEffect` (synchronous) and `onLayout` (for updates). The sync\nmeasurement gives you the initial size immediately; `onLayout` keeps it current\nwhen the view changes. For non-primitive states, use a dispatch updater to\ncompare values and avoid unnecessary re-renders.\n\n**Height only:**\n\n```tsx\nimport { useLayoutEffect, useRef, useState } from 'react'\nimport { View, LayoutChangeEvent } from 'react-native'\n\nfunction MeasuredBox({ children }: { children: React.ReactNode }) {\n  const ref = useRef<View>(null)\n  const [height, setHeight] = useState<number | undefined>(undefined)\n\n  useLayoutEffect(() => {\n    // Sync measurement on mount (RN 0.82+)\n    const rect = ref.current?.getBoundingClientRect()\n    if (rect) setHeight(rect.height)\n    // Pre-0.82: ref.current?.measure((x, y, w, h) => setHeight(h))\n  }, [])\n\n  const onLayout = (e: LayoutChangeEvent) => {\n    setHeight(e.nativeEvent.layout.height)\n  }\n\n  return (\n    <View ref={ref} onLayout={onLayout}>\n      {children}\n    </View>\n  )\n}\n```\n\n**Both dimensions:**\n\n```tsx\nimport { useLayoutEffect, useRef, useState } from 'react'\nimport { View, LayoutChangeEvent } from 'react-native'\n\ntype Size = { width: number; height: number }\n\nfunction MeasuredBox({ children }: { children: React.ReactNode }) {\n  const ref = useRef<View>(null)\n  const [size, setSize] = useState<Size | undefined>(undefined)\n\n  useLayoutEffect(() => {\n    const rect = ref.current?.getBoundingClientRect()\n    if (rect) setSize({ width: rect.width, height: rect.height })\n  }, [])\n\n  const onLayout = (e: LayoutChangeEvent) => {\n    const { width, height } = e.nativeEvent.layout\n    setSize((prev) => {\n      // for non-primitive states, compare values before firing a re-render\n      if (prev?.width === width && prev?.height === height) return prev\n      return { width, height }\n    })\n  }\n\n  return (\n    <View ref={ref} onLayout={onLayout}>\n      {children}\n    </View>\n  )\n}\n```\n\nUse functional setState to compare—don't read state directly in the callback.\n",
        "skills/react-native/rules/ui-menus.md": "---\ntitle: Use Native Menus for Dropdowns and Context Menus\nimpact: HIGH\nimpactDescription: native accessibility, platform-consistent UX\ntags: user-interface, menus, context-menus, zeego, accessibility\n---\n\n## Use Native Menus for Dropdowns and Context Menus\n\nUse native platform menus instead of custom JS implementations. Native menus\nprovide built-in accessibility, consistent platform UX, and better performance.\nUse [zeego](https://zeego.dev) for cross-platform native menus.\n\n**Incorrect (custom JS menu):**\n\n```tsx\nimport { useState } from 'react'\nimport { View, Pressable, Text } from 'react-native'\n\nfunction MyMenu() {\n  const [open, setOpen] = useState(false)\n\n  return (\n    <View>\n      <Pressable onPress={() => setOpen(!open)}>\n        <Text>Open Menu</Text>\n      </Pressable>\n      {open && (\n        <View style={{ position: 'absolute', top: 40 }}>\n          <Pressable onPress={() => console.log('edit')}>\n            <Text>Edit</Text>\n          </Pressable>\n          <Pressable onPress={() => console.log('delete')}>\n            <Text>Delete</Text>\n          </Pressable>\n        </View>\n      )}\n    </View>\n  )\n}\n```\n\n**Correct (native menu with zeego):**\n\n```tsx\nimport * as DropdownMenu from 'zeego/dropdown-menu'\n\nfunction MyMenu() {\n  return (\n    <DropdownMenu.Root>\n      <DropdownMenu.Trigger>\n        <Pressable>\n          <Text>Open Menu</Text>\n        </Pressable>\n      </DropdownMenu.Trigger>\n\n      <DropdownMenu.Content>\n        <DropdownMenu.Item key='edit' onSelect={() => console.log('edit')}>\n          <DropdownMenu.ItemTitle>Edit</DropdownMenu.ItemTitle>\n        </DropdownMenu.Item>\n\n        <DropdownMenu.Item\n          key='delete'\n          destructive\n          onSelect={() => console.log('delete')}\n        >\n          <DropdownMenu.ItemTitle>Delete</DropdownMenu.ItemTitle>\n        </DropdownMenu.Item>\n      </DropdownMenu.Content>\n    </DropdownMenu.Root>\n  )\n}\n```\n\n**Context menu (long-press):**\n\n```tsx\nimport * as ContextMenu from 'zeego/context-menu'\n\nfunction MyContextMenu() {\n  return (\n    <ContextMenu.Root>\n      <ContextMenu.Trigger>\n        <View style={{ padding: 20 }}>\n          <Text>Long press me</Text>\n        </View>\n      </ContextMenu.Trigger>\n\n      <ContextMenu.Content>\n        <ContextMenu.Item key='copy' onSelect={() => console.log('copy')}>\n          <ContextMenu.ItemTitle>Copy</ContextMenu.ItemTitle>\n        </ContextMenu.Item>\n\n        <ContextMenu.Item key='paste' onSelect={() => console.log('paste')}>\n          <ContextMenu.ItemTitle>Paste</ContextMenu.ItemTitle>\n        </ContextMenu.Item>\n      </ContextMenu.Content>\n    </ContextMenu.Root>\n  )\n}\n```\n\n**Checkbox items:**\n\n```tsx\nimport * as DropdownMenu from 'zeego/dropdown-menu'\n\nfunction SettingsMenu() {\n  const [notifications, setNotifications] = useState(true)\n\n  return (\n    <DropdownMenu.Root>\n      <DropdownMenu.Trigger>\n        <Pressable>\n          <Text>Settings</Text>\n        </Pressable>\n      </DropdownMenu.Trigger>\n\n      <DropdownMenu.Content>\n        <DropdownMenu.CheckboxItem\n          key='notifications'\n          value={notifications}\n          onValueChange={() => setNotifications((prev) => !prev)}\n        >\n          <DropdownMenu.ItemIndicator />\n          <DropdownMenu.ItemTitle>Notifications</DropdownMenu.ItemTitle>\n        </DropdownMenu.CheckboxItem>\n      </DropdownMenu.Content>\n    </DropdownMenu.Root>\n  )\n}\n```\n\n**Submenus:**\n\n```tsx\nimport * as DropdownMenu from 'zeego/dropdown-menu'\n\nfunction MenuWithSubmenu() {\n  return (\n    <DropdownMenu.Root>\n      <DropdownMenu.Trigger>\n        <Pressable>\n          <Text>Options</Text>\n        </Pressable>\n      </DropdownMenu.Trigger>\n\n      <DropdownMenu.Content>\n        <DropdownMenu.Item key='home' onSelect={() => console.log('home')}>\n          <DropdownMenu.ItemTitle>Home</DropdownMenu.ItemTitle>\n        </DropdownMenu.Item>\n\n        <DropdownMenu.Sub>\n          <DropdownMenu.SubTrigger key='more'>\n            <DropdownMenu.ItemTitle>More Options</DropdownMenu.ItemTitle>\n          </DropdownMenu.SubTrigger>\n\n          <DropdownMenu.SubContent>\n            <DropdownMenu.Item key='settings'>\n              <DropdownMenu.ItemTitle>Settings</DropdownMenu.ItemTitle>\n            </DropdownMenu.Item>\n\n            <DropdownMenu.Item key='help'>\n              <DropdownMenu.ItemTitle>Help</DropdownMenu.ItemTitle>\n            </DropdownMenu.Item>\n          </DropdownMenu.SubContent>\n        </DropdownMenu.Sub>\n      </DropdownMenu.Content>\n    </DropdownMenu.Root>\n  )\n}\n```\n\nReference: [Zeego Documentation](https://zeego.dev/components/dropdown-menu)\n",
        "skills/react-native/rules/ui-native-modals.md": "---\ntitle: Use Native Modals Over JS-Based Bottom Sheets\nimpact: HIGH\nimpactDescription: native performance, gestures, accessibility\ntags: modals, bottom-sheet, native, react-navigation\n---\n\n## Use Native Modals Over JS-Based Bottom Sheets\n\nUse native `<Modal>` with `presentationStyle=\"formSheet\"` or React Navigation\nv7's native form sheet instead of JS-based bottom sheet libraries. Native modals\nhave built-in gestures, accessibility, and better performance. Rely on native UI\nfor low-level primitives.\n\n**Incorrect (JS-based bottom sheet):**\n\n```tsx\nimport BottomSheet from 'custom-js-bottom-sheet'\n\nfunction MyScreen() {\n  const sheetRef = useRef<BottomSheet>(null)\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Button onPress={() => sheetRef.current?.expand()} title='Open' />\n      <BottomSheet ref={sheetRef} snapPoints={['50%', '90%']}>\n        <View>\n          <Text>Sheet content</Text>\n        </View>\n      </BottomSheet>\n    </View>\n  )\n}\n```\n\n**Correct (native Modal with formSheet):**\n\n```tsx\nimport { Modal, View, Text, Button } from 'react-native'\n\nfunction MyScreen() {\n  const [visible, setVisible] = useState(false)\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Button onPress={() => setVisible(true)} title='Open' />\n      <Modal\n        visible={visible}\n        presentationStyle='formSheet'\n        animationType='slide'\n        onRequestClose={() => setVisible(false)}\n      >\n        <View>\n          <Text>Sheet content</Text>\n        </View>\n      </Modal>\n    </View>\n  )\n}\n```\n\n**Correct (React Navigation v7 native form sheet):**\n\n```tsx\n// In your navigator\n<Stack.Screen\n  name='Details'\n  component={DetailsScreen}\n  options={{\n    presentation: 'formSheet',\n    sheetAllowedDetents: 'fitToContents',\n  }}\n/>\n```\n\nNative modals provide swipe-to-dismiss, proper keyboard avoidance, and\naccessibility out of the box.\n",
        "skills/react-native/rules/ui-pressable.md": "---\ntitle: Use Pressable Instead of Touchable Components\nimpact: LOW\nimpactDescription: modern API, more flexible\ntags: ui, pressable, touchable, gestures\n---\n\n## Use Pressable Instead of Touchable Components\n\nNever use `TouchableOpacity` or `TouchableHighlight`. Use `Pressable` from\n`react-native` or `react-native-gesture-handler` instead.\n\n**Incorrect (legacy Touchable components):**\n\n```tsx\nimport { TouchableOpacity } from 'react-native'\n\nfunction MyButton({ onPress }: { onPress: () => void }) {\n  return (\n    <TouchableOpacity onPress={onPress} activeOpacity={0.7}>\n      <Text>Press me</Text>\n    </TouchableOpacity>\n  )\n}\n```\n\n**Correct (Pressable):**\n\n```tsx\nimport { Pressable } from 'react-native'\n\nfunction MyButton({ onPress }: { onPress: () => void }) {\n  return (\n    <Pressable onPress={onPress}>\n      <Text>Press me</Text>\n    </Pressable>\n  )\n}\n```\n\n**Correct (Pressable from gesture handler for lists):**\n\n```tsx\nimport { Pressable } from 'react-native-gesture-handler'\n\nfunction ListItem({ onPress }: { onPress: () => void }) {\n  return (\n    <Pressable onPress={onPress}>\n      <Text>Item</Text>\n    </Pressable>\n  )\n}\n```\n\nUse `react-native-gesture-handler` Pressable inside scrollable lists for better\ngesture coordination, as long as you are using the ScrollView from\n`react-native-gesture-handler` as well.\n\n**For animated press states (scale, opacity changes):** Use `GestureDetector`\nwith Reanimated shared values instead of Pressable's style callback. See the\n`animation-gesture-detector-press` rule.\n",
        "skills/react-native/rules/ui-safe-area-scroll.md": "---\ntitle: Use contentInsetAdjustmentBehavior for Safe Areas\nimpact: MEDIUM\nimpactDescription: native safe area handling, no layout shifts\ntags: safe-area, scrollview, layout\n---\n\n## Use contentInsetAdjustmentBehavior for Safe Areas\n\nUse `contentInsetAdjustmentBehavior=\"automatic\"` on the root ScrollView instead of wrapping content in SafeAreaView or manual padding. This lets iOS handle safe area insets natively with proper scroll behavior.\n\n**Incorrect (SafeAreaView wrapper):**\n\n```tsx\nimport { SafeAreaView, ScrollView, View, Text } from 'react-native'\n\nfunction MyScreen() {\n  return (\n    <SafeAreaView style={{ flex: 1 }}>\n      <ScrollView>\n        <View>\n          <Text>Content</Text>\n        </View>\n      </ScrollView>\n    </SafeAreaView>\n  )\n}\n```\n\n**Incorrect (manual safe area padding):**\n\n```tsx\nimport { ScrollView, View, Text } from 'react-native'\nimport { useSafeAreaInsets } from 'react-native-safe-area-context'\n\nfunction MyScreen() {\n  const insets = useSafeAreaInsets()\n\n  return (\n    <ScrollView contentContainerStyle={{ paddingTop: insets.top }}>\n      <View>\n        <Text>Content</Text>\n      </View>\n    </ScrollView>\n  )\n}\n```\n\n**Correct (native content inset adjustment):**\n\n```tsx\nimport { ScrollView, View, Text } from 'react-native'\n\nfunction MyScreen() {\n  return (\n    <ScrollView contentInsetAdjustmentBehavior='automatic'>\n      <View>\n        <Text>Content</Text>\n      </View>\n    </ScrollView>\n  )\n}\n```\n\nThe native approach handles dynamic safe areas (keyboard, toolbars) and allows content to scroll behind the status bar naturally.\n",
        "skills/react-native/rules/ui-scrollview-content-inset.md": "---\ntitle: Use contentInset for Dynamic ScrollView Spacing\nimpact: LOW\nimpactDescription: smoother updates, no layout recalculation\ntags: scrollview, layout, contentInset, performance\n---\n\n## Use contentInset for Dynamic ScrollView Spacing\n\nWhen adding space to the top or bottom of a ScrollView that may change\n(keyboard, toolbars, dynamic content), use `contentInset` instead of padding.\nChanging `contentInset` doesn't trigger layout recalculation—it adjusts the\nscroll area without re-rendering content.\n\n**Incorrect (padding causes layout recalculation):**\n\n```tsx\nfunction Feed({ bottomOffset }: { bottomOffset: number }) {\n  return (\n    <ScrollView contentContainerStyle={{ paddingBottom: bottomOffset }}>\n      {children}\n    </ScrollView>\n  )\n}\n// Changing bottomOffset triggers full layout recalculation\n```\n\n**Correct (contentInset for dynamic spacing):**\n\n```tsx\nfunction Feed({ bottomOffset }: { bottomOffset: number }) {\n  return (\n    <ScrollView\n      contentInset={{ bottom: bottomOffset }}\n      scrollIndicatorInsets={{ bottom: bottomOffset }}\n    >\n      {children}\n    </ScrollView>\n  )\n}\n// Changing bottomOffset only adjusts scroll bounds\n```\n\nUse `scrollIndicatorInsets` alongside `contentInset` to keep the scroll\nindicator aligned. For static spacing that never changes, padding is fine.\n",
        "skills/react-native/rules/ui-styling.md": "---\ntitle: Modern React Native Styling Patterns\nimpact: MEDIUM\nimpactDescription: consistent design, smoother borders, cleaner layouts\ntags: styling, css, layout, shadows, gradients\n---\n\n## Modern React Native Styling Patterns\n\nFollow these styling patterns for cleaner, more consistent React Native code.\n\n**Always use `borderCurve: 'continuous'` with `borderRadius`:**\n\n```tsx\n// Incorrect\n{ borderRadius: 12 }\n\n// Correct – smoother iOS-style corners\n{ borderRadius: 12, borderCurve: 'continuous' }\n```\n\n**Use `gap` instead of margin for spacing between elements:**\n\n```tsx\n// Incorrect – margin on children\n<View>\n  <Text style={{ marginBottom: 8 }}>Title</Text>\n  <Text style={{ marginBottom: 8 }}>Subtitle</Text>\n</View>\n\n// Correct – gap on parent\n<View style={{ gap: 8 }}>\n  <Text>Title</Text>\n  <Text>Subtitle</Text>\n</View>\n```\n\n**Use `padding` for space within, `gap` for space between:**\n\n```tsx\n<View style={{ padding: 16, gap: 12 }}>\n  <Text>First</Text>\n  <Text>Second</Text>\n</View>\n```\n\n**Use `experimental_backgroundImage` for linear gradients:**\n\n```tsx\n// Incorrect – third-party gradient library\n<LinearGradient colors={['#000', '#fff']} />\n\n// Correct – native CSS gradient syntax\n<View\n  style={{\n    experimental_backgroundImage: 'linear-gradient(to bottom, #000, #fff)',\n  }}\n/>\n```\n\n**Use CSS `boxShadow` string syntax for shadows:**\n\n```tsx\n// Incorrect – legacy shadow objects or elevation\n{ shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.1 }\n{ elevation: 4 }\n\n// Correct – CSS box-shadow syntax\n{ boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)' }\n```\n\n**Avoid multiple font sizes – use weight and color for emphasis:**\n\n```tsx\n// Incorrect – varying font sizes for hierarchy\n<Text style={{ fontSize: 18 }}>Title</Text>\n<Text style={{ fontSize: 14 }}>Subtitle</Text>\n<Text style={{ fontSize: 12 }}>Caption</Text>\n\n// Correct – consistent size, vary weight and color\n<Text style={{ fontWeight: '600' }}>Title</Text>\n<Text style={{ color: '#666' }}>Subtitle</Text>\n<Text style={{ color: '#999' }}>Caption</Text>\n```\n\nLimiting font sizes creates visual consistency. Use `fontWeight` (bold/semibold)\nand grayscale colors for hierarchy instead.\n",
        "skills/tailwind-setup/SKILL.md": "---\nname: tailwind-setup\ndescription: Set up Tailwind CSS v4 in Expo with react-native-css and NativeWind v5 for universal styling\nversion: 1.0.0\nlicense: MIT\n---\n\n# Tailwind CSS Setup for Expo with react-native-css\n\nThis guide covers setting up Tailwind CSS v4 in Expo using react-native-css and NativeWind v5 for universal styling across iOS, Android, and Web.\n\n## Overview\n\nThis setup uses:\n\n- **Tailwind CSS v4** - Modern CSS-first configuration\n- **react-native-css** - CSS runtime for React Native\n- **NativeWind v5** - Metro transformer for Tailwind in React Native\n- **@tailwindcss/postcss** - PostCSS plugin for Tailwind v4\n\n## Installation\n\n```bash\n# Install dependencies\nnpx expo install tailwindcss@^4 nativewind@5.0.0-preview.2 react-native-css@0.0.0-nightly.5ce6396 @tailwindcss/postcss tailwind-merge clsx\n```\n\nAdd resolutions for lightningcss compatibility:\n\n```json\n// package.json\n{\n  \"resolutions\": {\n    \"lightningcss\": \"1.30.1\"\n  }\n}\n```\n\n- autoprefixer is not needed in Expo because of lightningcss\n- postcss is included in expo by default\n\n## Configuration Files\n\n### Metro Config\n\nCreate or update `metro.config.js`:\n\n```js\n// metro.config.js\nconst { getDefaultConfig } = require(\"expo/metro-config\");\nconst { withNativewind } = require(\"nativewind/metro\");\n\n/** @type {import('expo/metro-config').MetroConfig} */\nconst config = getDefaultConfig(__dirname);\n\nmodule.exports = withNativewind(config, {\n  // inline variables break PlatformColor in CSS variables\n  inlineVariables: false,\n  // We add className support manually\n  globalClassNamePolyfill: false,\n});\n```\n\n### PostCSS Config\n\nCreate `postcss.config.mjs`:\n\n```js\n// postcss.config.mjs\nexport default {\n  plugins: {\n    \"@tailwindcss/postcss\": {},\n  },\n};\n```\n\n### Global CSS\n\nCreate `src/global.css`:\n\n```css\n@import \"tailwindcss/theme.css\" layer(theme);\n@import \"tailwindcss/preflight.css\" layer(base);\n@import \"tailwindcss/utilities.css\";\n\n/* Platform-specific font families */\n@media android {\n  :root {\n    --font-mono: monospace;\n    --font-rounded: normal;\n    --font-serif: serif;\n    --font-sans: normal;\n  }\n}\n\n@media ios {\n  :root {\n    --font-mono: ui-monospace;\n    --font-serif: ui-serif;\n    --font-sans: system-ui;\n    --font-rounded: ui-rounded;\n  }\n}\n```\n\n## IMPORTANT: No Babel Config Needed\n\nWith Tailwind v4 and NativeWind v5, you do NOT need a babel.config.js for Tailwind. Remove any NativeWind babel presets if present:\n\n```js\n// DELETE babel.config.js if it only contains NativeWind config\n// The following is NO LONGER needed:\n// module.exports = function (api) {\n//   api.cache(true);\n//   return {\n//     presets: [\n//       [\"babel-preset-expo\", { jsxImportSource: \"nativewind\" }],\n//       \"nativewind/babel\",\n//     ],\n//   };\n// };\n```\n\n## CSS Component Wrappers\n\nSince react-native-css requires explicit CSS element wrapping, create reusable components:\n\n### Main Components (`src/tw/index.tsx`)\n\n```tsx\nimport {\n  useCssElement,\n  useNativeVariable as useFunctionalVariable,\n} from \"react-native-css\";\n\nimport { Link as RouterLink } from \"expo-router\";\nimport Animated from \"react-native-reanimated\";\nimport React from \"react\";\nimport {\n  View as RNView,\n  Text as RNText,\n  Pressable as RNPressable,\n  ScrollView as RNScrollView,\n  TouchableHighlight as RNTouchableHighlight,\n  TextInput as RNTextInput,\n  StyleSheet,\n} from \"react-native\";\n\n// CSS-enabled Link\nexport const Link = (\n  props: React.ComponentProps<typeof RouterLink> & { className?: string }\n) => {\n  return useCssElement(RouterLink, props, { className: \"style\" });\n};\n\nLink.Trigger = RouterLink.Trigger;\nLink.Menu = RouterLink.Menu;\nLink.MenuAction = RouterLink.MenuAction;\nLink.Preview = RouterLink.Preview;\n\n// CSS Variable hook\nexport const useCSSVariable =\n  process.env.EXPO_OS !== \"web\"\n    ? useFunctionalVariable\n    : (variable: string) => `var(${variable})`;\n\n// View\nexport type ViewProps = React.ComponentProps<typeof RNView> & {\n  className?: string;\n};\n\nexport const View = (props: ViewProps) => {\n  return useCssElement(RNView, props, { className: \"style\" });\n};\nView.displayName = \"CSS(View)\";\n\n// Text\nexport const Text = (\n  props: React.ComponentProps<typeof RNText> & { className?: string }\n) => {\n  return useCssElement(RNText, props, { className: \"style\" });\n};\nText.displayName = \"CSS(Text)\";\n\n// ScrollView\nexport const ScrollView = (\n  props: React.ComponentProps<typeof RNScrollView> & {\n    className?: string;\n    contentContainerClassName?: string;\n  }\n) => {\n  return useCssElement(RNScrollView, props, {\n    className: \"style\",\n    contentContainerClassName: \"contentContainerStyle\",\n  });\n};\nScrollView.displayName = \"CSS(ScrollView)\";\n\n// Pressable\nexport const Pressable = (\n  props: React.ComponentProps<typeof RNPressable> & { className?: string }\n) => {\n  return useCssElement(RNPressable, props, { className: \"style\" });\n};\nPressable.displayName = \"CSS(Pressable)\";\n\n// TextInput\nexport const TextInput = (\n  props: React.ComponentProps<typeof RNTextInput> & { className?: string }\n) => {\n  return useCssElement(RNTextInput, props, { className: \"style\" });\n};\nTextInput.displayName = \"CSS(TextInput)\";\n\n// AnimatedScrollView\nexport const AnimatedScrollView = (\n  props: React.ComponentProps<typeof Animated.ScrollView> & {\n    className?: string;\n    contentClassName?: string;\n    contentContainerClassName?: string;\n  }\n) => {\n  return useCssElement(Animated.ScrollView, props, {\n    className: \"style\",\n    contentClassName: \"contentContainerStyle\",\n    contentContainerClassName: \"contentContainerStyle\",\n  });\n};\n\n// TouchableHighlight with underlayColor extraction\nfunction XXTouchableHighlight(\n  props: React.ComponentProps<typeof RNTouchableHighlight>\n) {\n  const { underlayColor, ...style } = StyleSheet.flatten(props.style) || {};\n  return (\n    <RNTouchableHighlight\n      underlayColor={underlayColor}\n      {...props}\n      style={style}\n    />\n  );\n}\n\nexport const TouchableHighlight = (\n  props: React.ComponentProps<typeof RNTouchableHighlight>\n) => {\n  return useCssElement(XXTouchableHighlight, props, { className: \"style\" });\n};\nTouchableHighlight.displayName = \"CSS(TouchableHighlight)\";\n```\n\n### Image Component (`src/tw/image.tsx`)\n\n```tsx\nimport { useCssElement } from \"react-native-css\";\nimport React from \"react\";\nimport { StyleSheet } from \"react-native\";\nimport Animated from \"react-native-reanimated\";\nimport { Image as RNImage } from \"expo-image\";\n\nconst AnimatedExpoImage = Animated.createAnimatedComponent(RNImage);\n\nexport type ImageProps = React.ComponentProps<typeof Image>;\n\nfunction CSSImage(props: React.ComponentProps<typeof AnimatedExpoImage>) {\n  // @ts-expect-error: Remap objectFit style to contentFit property\n  const { objectFit, objectPosition, ...style } =\n    StyleSheet.flatten(props.style) || {};\n\n  return (\n    <AnimatedExpoImage\n      contentFit={objectFit}\n      contentPosition={objectPosition}\n      {...props}\n      source={\n        typeof props.source === \"string\" ? { uri: props.source } : props.source\n      }\n      // @ts-expect-error: Style is remapped above\n      style={style}\n    />\n  );\n}\n\nexport const Image = (\n  props: React.ComponentProps<typeof CSSImage> & { className?: string }\n) => {\n  return useCssElement(CSSImage, props, { className: \"style\" });\n};\n\nImage.displayName = \"CSS(Image)\";\n```\n\n### Animated Components (`src/tw/animated.tsx`)\n\n```tsx\nimport * as TW from \"./index\";\nimport RNAnimated from \"react-native-reanimated\";\n\nexport const Animated = {\n  ...RNAnimated,\n  View: RNAnimated.createAnimatedComponent(TW.View),\n};\n```\n\n## Usage\n\nImport CSS-wrapped components from your tw directory:\n\n```tsx\nimport { View, Text, ScrollView, Image } from \"@/tw\";\n\nexport default function MyScreen() {\n  return (\n    <ScrollView className=\"flex-1 bg-white\">\n      <View className=\"p-4 gap-4\">\n        <Text className=\"text-xl font-bold text-gray-900\">Hello Tailwind!</Text>\n        <Image\n          className=\"w-full h-48 rounded-lg object-cover\"\n          source={{ uri: \"https://example.com/image.jpg\" }}\n        />\n      </View>\n    </ScrollView>\n  );\n}\n```\n\n## Custom Theme Variables\n\nAdd custom theme variables in your global.css using `@theme`:\n\n```css\n@layer theme {\n  @theme {\n    /* Custom fonts */\n    --font-rounded: \"SF Pro Rounded\", sans-serif;\n\n    /* Custom line heights */\n    --text-xs--line-height: calc(1em / 0.75);\n    --text-sm--line-height: calc(1.25em / 0.875);\n    --text-base--line-height: calc(1.5em / 1);\n\n    /* Custom leading scales */\n    --leading-tight: 1.25em;\n    --leading-snug: 1.375em;\n    --leading-normal: 1.5em;\n  }\n}\n```\n\n## Platform-Specific Styles\n\nUse platform media queries for platform-specific styling:\n\n```css\n@media ios {\n  :root {\n    --font-sans: system-ui;\n    --font-rounded: ui-rounded;\n  }\n}\n\n@media android {\n  :root {\n    --font-sans: normal;\n    --font-rounded: normal;\n  }\n}\n```\n\n## Apple System Colors with CSS Variables\n\nCreate a CSS file for Apple semantic colors:\n\n```css\n/* src/css/sf.css */\n@layer base {\n  html {\n    color-scheme: light;\n  }\n}\n\n:root {\n  /* Accent colors with light/dark mode */\n  --sf-blue: light-dark(rgb(0 122 255), rgb(10 132 255));\n  --sf-green: light-dark(rgb(52 199 89), rgb(48 209 89));\n  --sf-red: light-dark(rgb(255 59 48), rgb(255 69 58));\n\n  /* Gray scales */\n  --sf-gray: light-dark(rgb(142 142 147), rgb(142 142 147));\n  --sf-gray-2: light-dark(rgb(174 174 178), rgb(99 99 102));\n\n  /* Text colors */\n  --sf-text: light-dark(rgb(0 0 0), rgb(255 255 255));\n  --sf-text-2: light-dark(rgb(60 60 67 / 0.6), rgb(235 235 245 / 0.6));\n\n  /* Background colors */\n  --sf-bg: light-dark(rgb(255 255 255), rgb(0 0 0));\n  --sf-bg-2: light-dark(rgb(242 242 247), rgb(28 28 30));\n}\n\n/* iOS native colors via platformColor */\n@media ios {\n  :root {\n    --sf-blue: platformColor(systemBlue);\n    --sf-green: platformColor(systemGreen);\n    --sf-red: platformColor(systemRed);\n    --sf-gray: platformColor(systemGray);\n    --sf-text: platformColor(label);\n    --sf-text-2: platformColor(secondaryLabel);\n    --sf-bg: platformColor(systemBackground);\n    --sf-bg-2: platformColor(secondarySystemBackground);\n  }\n}\n\n/* Register as Tailwind theme colors */\n@layer theme {\n  @theme {\n    --color-sf-blue: var(--sf-blue);\n    --color-sf-green: var(--sf-green);\n    --color-sf-red: var(--sf-red);\n    --color-sf-gray: var(--sf-gray);\n    --color-sf-text: var(--sf-text);\n    --color-sf-text-2: var(--sf-text-2);\n    --color-sf-bg: var(--sf-bg);\n    --color-sf-bg-2: var(--sf-bg-2);\n  }\n}\n```\n\nThen use in components:\n\n```tsx\n<Text className=\"text-sf-text\">Primary text</Text>\n<Text className=\"text-sf-text-2\">Secondary text</Text>\n<View className=\"bg-sf-bg\">...</View>\n```\n\n## Using CSS Variables in JavaScript\n\nUse the `useCSSVariable` hook:\n\n```tsx\nimport { useCSSVariable } from \"@/tw\";\n\nfunction MyComponent() {\n  const blue = useCSSVariable(\"--sf-blue\");\n\n  return <View style={{ borderColor: blue }} />;\n}\n```\n\n## Key Differences from NativeWind v4 / Tailwind v3\n\n1. **No babel.config.js** - Configuration is now CSS-first\n2. **PostCSS plugin** - Uses `@tailwindcss/postcss` instead of `tailwindcss`\n3. **CSS imports** - Use `@import \"tailwindcss/...\"` instead of `@tailwind` directives\n4. **Theme config** - Use `@theme` in CSS instead of `tailwind.config.js`\n5. **Component wrappers** - Must wrap components with `useCssElement` for className support\n6. **Metro config** - Use `withNativewind` with different options (`inlineVariables: false`)\n\n## Troubleshooting\n\n### Styles not applying\n\n1. Ensure you have the CSS file imported in your app entry\n2. Check that components are wrapped with `useCssElement`\n3. Verify Metro config has `withNativewind` applied\n\n### Platform colors not working\n\n1. Use `platformColor()` in `@media ios` blocks\n2. Fall back to `light-dark()` for web/Android\n\n### TypeScript errors\n\nAdd className to component props:\n\n```tsx\ntype Props = React.ComponentProps<typeof RNView> & { className?: string };\n```\n",
        "skills/upgrading-expo/SKILL.md": "---\nname: upgrading-expo\ndescription: Guidelines for upgrading Expo SDK versions and fixing dependency issues\nversion: 1.0.0\nlicense: MIT\n---\n\n## References\n\n- ./references/new-architecture.md -- SDK +53: New Architecture migration guide\n- ./references/react-19.md -- SDK +54: React 19 changes (useContext → use, Context.Provider → Context, forwardRef removal)\n- ./references/react-compiler.md -- SDK +54: React Compiler setup and migration guide\n\n## Step-by-Step Upgrade Process\n\n1. Upgrade Expo and dependencies\n\n```bash\nnpx expo install expo@latest\nnpx expo install --fix\n```\n\n2. Run diagnostics: `npx expo-doctor`\n\n3. Clear caches and reinstall\n\n```bash\nnpx expo export -p ios --clear\nrm -rf node_modules .expo\nwatchman watch-del-all\n```\n\n## Breaking Changes Checklist\n\n- Check for removed APIs in release notes\n- Update import paths for moved modules\n- Review native module changes requiring prebuild\n- Test all camera, audio, and video features\n- Verify navigation still works correctly\n\n## Prebuild for Native Changes\n\nIf upgrading requires native changes:\n\n```bash\nnpx expo prebuild --clean\n```\n\nThis regenerates the `ios` and `android` directories. Ensure the project is not a bare workflow app before running this command.\n\n## Clear caches for bare workflow\n\n- Clear the cocoapods cache for iOS: `cd ios && pod install --repo-update`\n- Clear derived data for Xcode: `npx expo run:ios --no-build-cache`\n- Clear the Gradle cache for Android: `cd android && ./gradlew clean`\n\n## Housekeeping\n\n- Review release notes for the target SDK version at https://expo.dev/changelog\n- If using Expo SDK 54 or later, ensure react-native-worklets is installed — this is required for react-native-reanimated to work.\n- Enable React Compiler in SDK 54+ by adding `\"experiments\": { \"reactCompiler\": true }` to app.json — it's stable and recommended\n- Delete sdkVersion from `app.json` to let Expo manage it automatically\n- Remove implicit packages from `package.json`: `@babel/core`, `babel-preset-expo`, `expo-constants`.\n- If the babel.config.js only contains 'babel-preset-expo', delete the file\n- If the metro.config.js only contains expo defaults, delete the file\n\n## Deprecated Packages\n\n| Old Package          | Replacement                                          |\n| -------------------- | ---------------------------------------------------- |\n| `expo-av`            | `expo-audio` and `expo-video`                        |\n| `expo-permissions`   | Individual package permission APIs                   |\n| `@expo/vector-icons` | `expo-symbols` (for SF Symbols)                      |\n| `AsyncStorage`       | `expo-sqlite/localStorage/install`                   |\n| `expo-app-loading`   | `expo-splash-screen`                                 |\n| expo-linear-gradient | experimental_backgroundImage + CSS gradients in View |\n\n## Removing patches\n\nCheck if there are any outdated patches in the `patches/` directory. Remove them if they are no longer needed.\n\n## Postcss\n\n- `autoprefixer` isn't needed in SDK +53.\n- Use `postcss.config.mjs` in SDK +53.\n\n## Metro\n\nRemove redundant metro config options:\n\n- resolver.unstable_enablePackageExports is enabled by default in SDK +53.\n- `experimentalImportSupport` is enabled by default in SDK +54.\n- `EXPO_USE_FAST_RESOLVER=1` is removed in SDK +54.\n- cjs and mjs extensions are supported by default in SDK +50.\n- Expo webpack is deprecated, migrate to [Expo Router and Metro web](https://docs.expo.dev/router/migrate/from-expo-webpack/).\n\n## New Architecture\n\nThe new architecture is enabled by default, the app.json field `\"newArchEnabled\": true` is no longer needed as it's the default. Expo Go only supports the new architecture as of SDK +53.\n",
        "skills/upgrading-expo/references/new-architecture.md": "# New Architecture\n\nThe New Architecture is enabled by default in Expo SDK 53+. It replaces the legacy bridge with a faster, synchronous communication layer between JavaScript and native code.\n\n## Documentation\n\nFull guide: https://docs.expo.dev/guides/new-architecture/\n\n## What Changed\n\n- **JSI (JavaScript Interface)** — Direct synchronous calls between JS and native\n- **Fabric** — New rendering system with concurrent features\n- **TurboModules** — Lazy-loaded native modules with type safety\n\n## SDK Compatibility\n\n| SDK Version | New Architecture Status |\n| ----------- | ----------------------- |\n| SDK 53+     | Enabled by default      |\n| SDK 52      | Opt-in via app.json     |\n| SDK 51-     | Experimental            |\n\n## Configuration\n\nNew Architecture is enabled by default. To explicitly disable (not recommended):\n\n```json\n{\n  \"expo\": {\n    \"newArchEnabled\": false\n  }\n}\n```\n\n## Expo Go\n\nExpo Go only supports the New Architecture as of SDK 53. Apps using the old architecture must use development builds.\n\n## Common Migration Issues\n\n### Native Module Compatibility\n\nSome older native modules may not support the New Architecture. Check:\n\n1. Module documentation for New Architecture support\n2. GitHub issues for compatibility discussions\n3. Consider alternatives if module is unmaintained\n\n### Reanimated\n\nReact Native Reanimated requires `react-native-worklets` in SDK 54+:\n\n```bash\nnpx expo install react-native-worklets\n```\n\n### Layout Animations\n\nSome layout animations behave differently. Test thoroughly after upgrading.\n\n## Verifying New Architecture\n\nCheck if New Architecture is active:\n\n```tsx\nimport { Platform } from \"react-native\";\n\n// Returns true if Fabric is enabled\nconst isNewArch = global._IS_FABRIC !== undefined;\n```\n\nVerify from the command line if the currently running app uses the New Architecture: `bunx xcobra expo eval \"_IS_FABRIC\"` -> `true`\n\n## Troubleshooting\n\n1. **Clear caches** — `npx expo start --clear`\n2. **Clean prebuild** — `npx expo prebuild --clean`\n3. **Check native modules** — Ensure all dependencies support New Architecture\n4. **Review console warnings** — Legacy modules log compatibility warnings\n",
        "skills/upgrading-expo/references/react-19.md": "# React 19\n\nReact 19 is included in Expo SDK 54. This release simplifies several common patterns.\n\n## Context Changes\n\n### useContext → use\n\nThe `use` hook replaces `useContext`:\n\n```tsx\n// Before (React 18)\nimport { useContext } from \"react\";\nconst value = useContext(MyContext);\n\n// After (React 19)\nimport { use } from \"react\";\nconst value = use(MyContext);\n```\n\n- The `use` hook can also read promises, enabling Suspense-based data fetching.\n- `use` can be called conditionally, this simplifies components that consume multiple contexts.\n\n### Context.Provider → Context\n\nContext providers no longer need the `.Provider` suffix:\n\n```tsx\n// Before (React 18)\n<ThemeContext.Provider value={theme}>\n  {children}\n</ThemeContext.Provider>\n\n// After (React 19)\n<ThemeContext value={theme}>\n  {children}\n</ThemeContext>\n```\n\n## ref as a Prop\n\n### Removing forwardRef\n\nComponents can now receive `ref` as a regular prop. `forwardRef` is no longer needed:\n\n```tsx\n// Before (React 18)\nimport { forwardRef } from \"react\";\n\nconst Input = forwardRef<TextInput, Props>((props, ref) => {\n  return <TextInput ref={ref} {...props} />;\n});\n\n// After (React 19)\nfunction Input({ ref, ...props }: Props & { ref?: React.Ref<TextInput> }) {\n  return <TextInput ref={ref} {...props} />;\n}\n```\n\n### Migration Steps\n\n1. Remove `forwardRef` wrapper\n2. Add `ref` to the props destructuring\n3. Update the type to include `ref?: React.Ref<T>`\n\n## Other React 19 Features\n\n- **Actions** — Functions that handle async transitions\n- **useOptimistic** — Optimistic UI updates\n- **useFormStatus** — Form submission state (web)\n- **Document Metadata** — Native `<title>` and `<meta>` support (web)\n\n## Cleanup Checklist\n\nWhen upgrading to SDK 54:\n\n- [ ] Replace `useContext` with `use`\n- [ ] Remove `.Provider` from Context components\n- [ ] Remove `forwardRef` wrappers, use `ref` prop instead\n",
        "skills/upgrading-expo/references/react-compiler.md": "# React Compiler\n\nReact Compiler is stable in Expo SDK 54 and later. It automatically memoizes components and hooks, eliminating the need for manual `useMemo`, `useCallback`, and `React.memo`.\n\n## Enabling React Compiler\n\nAdd to `app.json`:\n\n```json\n{\n  \"expo\": {\n    \"experiments\": {\n      \"reactCompiler\": true\n    }\n  }\n}\n```\n\n## What React Compiler Does\n\n- Automatically memoizes components and values\n- Eliminates unnecessary re-renders\n- Removes the need for manual `useMemo` and `useCallback`\n- Works with existing code without modifications\n\n## Cleanup After Enabling\n\nOnce React Compiler is enabled, you can remove manual memoization:\n\n```tsx\n// Before (manual memoization)\nconst memoizedValue = useMemo(() => computeExpensive(a, b), [a, b]);\nconst memoizedCallback = useCallback(() => doSomething(a), [a]);\nconst MemoizedComponent = React.memo(MyComponent);\n\n// After (React Compiler handles it)\nconst value = computeExpensive(a, b);\nconst callback = () => doSomething(a);\n// Just use MyComponent directly\n```\n\n## Requirements\n\n- Expo SDK 54 or later\n- New Architecture enabled (default in SDK 54+)\n\n## Verifying It's Working\n\nReact Compiler runs at build time. Check the Metro bundler output for compilation messages. You can also use React DevTools to verify components are being optimized.\n\n## Troubleshooting\n\nIf you encounter issues:\n\n1. Ensure New Architecture is enabled\n2. Clear Metro cache: `npx expo start --clear`\n3. Check for incompatible patterns in your code (rare)\n\nReact Compiler is designed to work with idiomatic React code. If it can't safely optimize a component, it skips that component without breaking your app.\n",
        "skills/use-dom/SKILL.md": "---\nname: use-dom\ndescription: Use Expo DOM components to run web code in a webview on native and as-is on web. Migrate web code to native incrementally.\nversion: 1.0.0\nlicense: MIT\n---\n\n## What are DOM Components?\n\nDOM components allow web code to run verbatim in a webview on native platforms while rendering as-is on web. This enables using web-only libraries like `recharts`, `react-syntax-highlighter`, or any React web library in your Expo app without modification.\n\n## When to Use DOM Components\n\nUse DOM components when you need:\n\n- **Web-only libraries** — Charts (recharts, chart.js), syntax highlighters, rich text editors, or any library that depends on DOM APIs\n- **Migrating web code** — Bring existing React web components to native without rewriting\n- **Complex HTML/CSS layouts** — When CSS features aren't available in React Native\n- **iframes or embeds** — Embedding external content that requires a browser context\n- **Canvas or WebGL** — Web graphics APIs not available natively\n\n## When NOT to Use DOM Components\n\nAvoid DOM components when:\n\n- **Native performance is critical** — Webviews add overhead\n- **Simple UI** — React Native components are more efficient for basic layouts\n- **Deep native integration** — Use local modules instead for native APIs\n- **Layout routes** — `_layout` files cannot be DOM components\n\n## Basic DOM Component\n\nCreate a new file with the `'use dom';` directive at the top:\n\n```tsx\n// components/WebChart.tsx\n\"use dom\";\n\nexport default function WebChart({\n  data,\n}: {\n  data: number[];\n  dom: import(\"expo/dom\").DOMProps;\n}) {\n  return (\n    <div style={{ padding: 20 }}>\n      <h2>Chart Data</h2>\n      <ul>\n        {data.map((value, i) => (\n          <li key={i}>{value}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Rules for DOM Components\n\n1. **Must have `'use dom';` directive** at the top of the file\n2. **Single default export** — One React component per file\n3. **Own file** — Cannot be defined inline or combined with native components\n4. **Serializable props only** — Strings, numbers, booleans, arrays, plain objects\n5. **Include CSS in the component file** — DOM components run in isolated context\n\n## The `dom` Prop\n\nEvery DOM component receives a special `dom` prop for webview configuration. Always type it in your props:\n\n```tsx\n\"use dom\";\n\ninterface Props {\n  content: string;\n  dom: import(\"expo/dom\").DOMProps;\n}\n\nexport default function MyComponent({ content }: Props) {\n  return <div>{content}</div>;\n}\n```\n\n### Common `dom` Prop Options\n\n```tsx\n// Disable body scrolling\n<DOMComponent dom={{ scrollEnabled: false }} />\n\n// Flow under the notch (disable safe area insets)\n<DOMComponent dom={{ contentInsetAdjustmentBehavior: \"never\" }} />\n\n// Control size manually\n<DOMComponent dom={{ style: { width: 300, height: 400 } }} />\n\n// Combine options\n<DOMComponent\n  dom={{\n    scrollEnabled: false,\n    contentInsetAdjustmentBehavior: \"never\",\n    style: { width: '100%', height: 500 }\n  }}\n/>\n```\n\n## Exposing Native Actions to the Webview\n\nPass async functions as props to expose native functionality to the DOM component:\n\n```tsx\n// app/index.tsx (native)\nimport { Alert } from \"react-native\";\nimport DOMComponent from \"@/components/dom-component\";\n\nexport default function Screen() {\n  return (\n    <DOMComponent\n      showAlert={async (message: string) => {\n        Alert.alert(\"From Web\", message);\n      }}\n      saveData={async (data: { name: string; value: number }) => {\n        // Save to native storage, database, etc.\n        console.log(\"Saving:\", data);\n        return { success: true };\n      }}\n    />\n  );\n}\n```\n\n```tsx\n// components/dom-component.tsx\n\"use dom\";\n\ninterface Props {\n  showAlert: (message: string) => Promise<void>;\n  saveData: (data: {\n    name: string;\n    value: number;\n  }) => Promise<{ success: boolean }>;\n  dom?: import(\"expo/dom\").DOMProps;\n}\n\nexport default function DOMComponent({ showAlert, saveData }: Props) {\n  const handleClick = async () => {\n    await showAlert(\"Hello from the webview!\");\n    const result = await saveData({ name: \"test\", value: 42 });\n    console.log(\"Save result:\", result);\n  };\n\n  return <button onClick={handleClick}>Trigger Native Action</button>;\n}\n```\n\n## Using Web Libraries\n\nDOM components can use any web library:\n\n```tsx\n// components/syntax-highlight.tsx\n\"use dom\";\n\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\nimport { docco } from \"react-syntax-highlighter/dist/esm/styles/hljs\";\n\ninterface Props {\n  code: string;\n  language: string;\n  dom?: import(\"expo/dom\").DOMProps;\n}\n\nexport default function SyntaxHighlight({ code, language }: Props) {\n  return (\n    <SyntaxHighlighter language={language} style={docco}>\n      {code}\n    </SyntaxHighlighter>\n  );\n}\n```\n\n```tsx\n// components/chart.tsx\n\"use dom\";\n\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n} from \"recharts\";\n\ninterface Props {\n  data: Array<{ name: string; value: number }>;\n  dom: import(\"expo/dom\").DOMProps;\n}\n\nexport default function Chart({ data }: Props) {\n  return (\n    <LineChart width={400} height={300} data={data}>\n      <CartesianGrid strokeDasharray=\"3 3\" />\n      <XAxis dataKey=\"name\" />\n      <YAxis />\n      <Tooltip />\n      <Line type=\"monotone\" dataKey=\"value\" stroke=\"#8884d8\" />\n    </LineChart>\n  );\n}\n```\n\n## CSS in DOM Components\n\nCSS imports must be in the DOM component file since they run in isolated context:\n\n```tsx\n// components/styled-component.tsx\n\"use dom\";\n\nimport \"@/styles.css\"; // CSS file in same directory\n\nexport default function StyledComponent({\n  dom,\n}: {\n  dom: import(\"expo/dom\").DOMProps;\n}) {\n  return (\n    <div className=\"container\">\n      <h1 className=\"title\">Styled Content</h1>\n    </div>\n  );\n}\n```\n\nOr use inline styles / CSS-in-JS:\n\n```tsx\n\"use dom\";\n\nconst styles = {\n  container: {\n    padding: 20,\n    backgroundColor: \"#f0f0f0\",\n  },\n  title: {\n    fontSize: 24,\n    color: \"#333\",\n  },\n};\n\nexport default function StyledComponent({\n  dom,\n}: {\n  dom: import(\"expo/dom\").DOMProps;\n}) {\n  return (\n    <div style={styles.container}>\n      <h1 style={styles.title}>Styled Content</h1>\n    </div>\n  );\n}\n```\n\n## Expo Router in DOM Components\n\nThe expo-router `<Link />` component and router API work inside DOM components:\n\n```tsx\n\"use dom\";\n\nimport { Link, useRouter } from \"expo-router\";\n\nexport default function Navigation({\n  dom,\n}: {\n  dom: import(\"expo/dom\").DOMProps;\n}) {\n  const router = useRouter();\n\n  return (\n    <nav>\n      <Link href=\"/about\">About</Link>\n      <button onClick={() => router.push(\"/settings\")}>Settings</button>\n    </nav>\n  );\n}\n```\n\n### Router APIs That Require Props\n\nThese hooks don't work directly in DOM components because they need synchronous access to native routing state:\n\n- `useLocalSearchParams()`\n- `useGlobalSearchParams()`\n- `usePathname()`\n- `useSegments()`\n- `useRootNavigation()`\n- `useRootNavigationState()`\n\n**Solution:** Read these values in the native parent and pass as props:\n\n```tsx\n// app/[id].tsx (native)\nimport { useLocalSearchParams, usePathname } from \"expo-router\";\nimport DOMComponent from \"@/components/dom-component\";\n\nexport default function Screen() {\n  const { id } = useLocalSearchParams();\n  const pathname = usePathname();\n\n  return <DOMComponent id={id as string} pathname={pathname} />;\n}\n```\n\n```tsx\n// components/dom-component.tsx\n\"use dom\";\n\ninterface Props {\n  id: string;\n  pathname: string;\n  dom?: import(\"expo/dom\").DOMProps;\n}\n\nexport default function DOMComponent({ id, pathname }: Props) {\n  return (\n    <div>\n      <p>Current ID: {id}</p>\n      <p>Current Path: {pathname}</p>\n    </div>\n  );\n}\n```\n\n## Detecting DOM Environment\n\nCheck if code is running in a DOM component:\n\n```tsx\n\"use dom\";\n\nimport { IS_DOM } from \"expo/dom\";\n\nexport default function Component({\n  dom,\n}: {\n  dom?: import(\"expo/dom\").DOMProps;\n}) {\n  return <div>{IS_DOM ? \"Running in DOM component\" : \"Running natively\"}</div>;\n}\n```\n\n## Assets\n\nPrefer requiring assets instead of using the public directory:\n\n```tsx\n\"use dom\";\n\n// Good - bundled with the component\nconst logo = require(\"../assets/logo.png\");\n\nexport default function Component({\n  dom,\n}: {\n  dom: import(\"expo/dom\").DOMProps;\n}) {\n  return <img src={logo} alt=\"Logo\" />;\n}\n```\n\n## Usage from Native Components\n\nImport and use DOM components like regular components:\n\n```tsx\n// app/index.tsx\nimport { View, Text } from \"react-native\";\nimport WebChart from \"@/components/web-chart\";\nimport CodeBlock from \"@/components/code-block\";\n\nexport default function HomeScreen() {\n  return (\n    <View style={{ flex: 1 }}>\n      <Text>Native content above</Text>\n\n      <WebChart data={[10, 20, 30, 40, 50]} dom={{ style: { height: 300 } }} />\n\n      <CodeBlock\n        code=\"const x = 1;\"\n        language=\"javascript\"\n        dom={{ scrollEnabled: true }}\n      />\n\n      <Text>Native content below</Text>\n    </View>\n  );\n}\n```\n\n## Platform Behavior\n\n| Platform | Behavior                            |\n| -------- | ----------------------------------- |\n| iOS      | Rendered in WKWebView               |\n| Android  | Rendered in WebView                 |\n| Web      | Rendered as-is (no webview wrapper) |\n\nOn web, the `dom` prop is ignored since no webview is needed.\n\n## Tips\n\n- DOM components hot reload during development\n- Keep DOM components focused — don't put entire screens in webviews\n- Use native components for navigation chrome, DOM components for specialized content\n- Test on all platforms — web rendering may differ slightly from native webviews\n- Large DOM components may impact performance — profile if needed\n- The webview has its own JavaScript context — cannot directly share state with native\n"
      },
      "plugins": [
        {
          "name": "react-native-expo-complete",
          "description": "Complete React Native, Expo, and React optimization guide with 130+ rules covering performance, patterns, UI, animations, state management, and more.",
          "source": "./",
          "skills": [
            "./skills/react-native",
            "./skills/react-best-practices",
            "./skills/composition-patterns",
            "./skills/building-ui",
            "./skills/data-fetching",
            "./skills/api-routes",
            "./skills/dev-client",
            "./skills/tailwind-setup",
            "./skills/upgrading-expo",
            "./skills/use-dom",
            "./agents/orchestrator",
            "./agents/architect",
            "./agents/implementation",
            "./agents/code-review",
            "./agents/bugfix",
            "./agents/performance",
            "./agents/navigation",
            "./agents/release-gate"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add gigs-slc/react-native-skills",
            "/plugin install react-native-expo-complete@react-native-expo-skills"
          ]
        }
      ]
    }
  ]
}