{
  "author": {
    "id": "jordanburke",
    "display_name": "Jordan",
    "avatar_url": "https://avatars.githubusercontent.com/u/67263?v=4"
  },
  "marketplaces": [
    {
      "name": "supabase-typed-query-skills",
      "version": null,
      "description": "Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns",
      "repo_full_name": "jordanburke/supabase-typed-query",
      "repo_url": "https://github.com/jordanburke/supabase-typed-query",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-11T21:35:36Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"supabase-typed-query-skills\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"supabase-typed-query\",\n      \"description\": \"Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/supabase-typed-query\"]\n    }\n  ]\n}\n",
        "README.md": "# supabase-typed-query\n\nType-safe query builder and entity pattern for Supabase with TypeScript.\n\n## Features\n\n- ðŸ”’ **Full TypeScript type safety** - Leverage your database types for compile-time safety\n- ðŸ”— **Chainable query API** - Build complex queries with OR conditions and functional operations\n- ðŸŽ¯ **Entity pattern** - Consistent CRUD operations across all tables\n- ðŸ‘ï¸ **View support** - Read-only ViewEntity for querying database views\n- ðŸš€ **Functional programming** - Built with functype for robust error handling\n- âš¡ **Zero runtime overhead** - All type checking happens at compile time\n- ðŸ”„ **Composable queries** - Mix and match conditions, filters, and transformations\n- ðŸ—‘ï¸ **Soft delete support** - Built-in soft delete filtering with per-query overrides\n- ðŸ¢ **Multi-tenancy ready** - Automatic partition key filtering for tenant isolation\n- ðŸ—„ï¸ **Custom schema support** - Query tables and views in any PostgreSQL schema\n\n## Installation\n\n```bash\nnpm install supabase-typed-query functype\n# or\npnpm add supabase-typed-query functype\n# or\nyarn add supabase-typed-query functype\n```\n\n### Compatibility\n\n| Dependency              | Version    | Notes                               |\n| ----------------------- | ---------- | ----------------------------------- |\n| `@supabase/supabase-js` | `^2.0.0`   | Tested with 2.86.x                  |\n| `functype`              | `>=0.20.1` | Required for error handling         |\n| TypeScript              | `>=5.0`    | Recommended for best type inference |\n| Node.js                 | `>=18`     | Required                            |\n\n## Quick Start\n\n### 1. Set up your database types\n\nFirst, generate your database types from Supabase:\n\n```bash\nnpx supabase gen types typescript --project-id your-project-id > database.types.ts\n```\n\n### 2. Create a typed client\n\n```typescript\nimport { createClient } from \"@supabase/supabase-js\"\nimport type { Database } from \"./database.types\"\n\nconst supabase = createClient<Database>(\"your-supabase-url\", \"your-anon-key\")\n```\n\n### 3. Use the Query Builder\n\n```typescript\nimport { query } from \"supabase-typed-query\"\n\n// Simple query\nconst user = await query(supabase, \"users\", { id: \"123\" }).one()\n\n// Query with OR conditions\nconst posts = await query(supabase, \"posts\", { status: \"published\" }).or({ status: \"draft\", author_id: userId }).many()\n\n// Query with functional operations\nconst titles = await query(supabase, \"posts\", { status: \"published\" })\n  .map((post) => post.title)\n  .filter((title) => title.length > 10)\n  .many()\n```\n\n### 4. Use the Entity Pattern\n\n```typescript\nimport { Entity } from \"supabase-typed-query\"\n\n// Create an entity for your table with configuration\nconst PostEntity = Entity(supabase, \"posts\", {\n  softDelete: true, // Automatically exclude soft-deleted items\n})\n\n// Get all posts\nconst posts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// Get a single post\nconst post = await PostEntity.getItem({\n  id: \"post-123\",\n  where: { status: \"published\" },\n}).one()\n\n// Add posts\nconst newPosts = await PostEntity.addItems({\n  items: [{ title: \"New Post\", content: \"Content here\", status: \"draft\" }],\n}).execute()\n\n// Update a post\nconst updated = await PostEntity.updateItem({\n  id: \"post-123\",\n  item: { status: \"published\" },\n}).execute()\n```\n\n## Advanced Usage\n\n### Comparison Operators\n\n```typescript\n// Greater than / Less than\nconst recentPosts = await query(supabase, \"posts\", {\n  created_at: { gte: new Date(\"2024-01-01\") },\n}).many()\n\n// Pattern matching\nconst searchResults = await query(supabase, \"posts\", {\n  title: { ilike: \"%typescript%\" },\n}).many()\n\n// IN queries\nconst selectedPosts = await query(supabase, \"posts\", {\n  id: { in: [\"id1\", \"id2\", \"id3\"] },\n}).many()\n\n// IS NULL checks\nconst drafts = await query(supabase, \"posts\", {\n  published_at: { is: null },\n}).many()\n\n// IS NOT NULL checks (using NOT operator)\nconst publishedPosts = await query(supabase, \"posts\", {\n  not: { is: { published_at: null } },\n}).many()\n\n// NOT IN queries\nconst activePosts = await query(supabase, \"posts\", {\n  not: { in: { status: [\"draft\", \"archived\"] } },\n}).many()\n```\n\n### NOT Operator\n\nThe `not` operator follows Supabase conventions for negating conditions:\n\n```typescript\n// IS NOT NULL - find posts with external_id set\nconst linkedPosts = await PostEntity.getItems({\n  not: { is: { external_id: null } },\n}).many()\n\n// IS NOT TRUE / IS NOT FALSE\nconst nonFeatured = await PostEntity.getItems({\n  not: { is: { featured: true } },\n}).many()\n\n// NOT IN - exclude specific statuses\nconst visiblePosts = await PostEntity.getItems({\n  not: { in: { status: [\"spam\", \"trash\", \"deleted\"] } },\n}).many()\n\n// Combine NOT with other conditions\nconst activeLinkedPosts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  not: { is: { external_id: null } },\n}).many()\n```\n\n> **Note**: `neq: null` is deprecated. Use `not: { is: { field: null } }` instead for IS NOT NULL checks.\n\n### Chaining OR Conditions\n\n```typescript\nconst results = await query(supabase, \"users\", { role: \"admin\" })\n  .or({ role: \"moderator\" })\n  .or({ role: \"editor\", active: true })\n  .many()\n```\n\n### Soft Deletes\n\nControl soft delete behavior at the Entity or Query level:\n\n```typescript\n// Entity with soft deletes enabled (excludes deleted by default)\nconst UserEntity = Entity(supabase, \"users\", {\n  softDelete: true, // Automatically filters out deleted items\n})\n\n// Override soft delete behavior per query\nconst allUsers = await UserEntity.getItems().includeDeleted().many()\nconst deletedOnly = await UserEntity.getItems().onlyDeleted().many()\nconst activeOnly = await UserEntity.getItems().excludeDeleted().many() // Redundant - already excluded\n\n// Entity without soft deletes (includes all items)\nconst AdminEntity = Entity(supabase, \"users\", {\n  softDelete: false, // No automatic filtering\n})\n```\n\n### Custom Schema Support\n\nQuery tables in any PostgreSQL schema (not just the default `public` schema):\n\n```typescript\nimport { Entity, PartitionedEntity, query } from \"supabase-typed-query\"\n\n// Entity with custom schema\nconst InventoryEntity = Entity(supabase, \"items\", {\n  softDelete: false,\n  schema: \"inventory\", // Uses client.schema(\"inventory\").from(\"items\")\n})\n\nconst items = await InventoryEntity.getItems({ where: { active: true } }).many()\n\n// PartitionedEntity with custom schema\nconst TenantItemsEntity = PartitionedEntity(supabase, \"items\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n  schema: \"tenant_data\",\n})\n\n// Query API with custom schema (7th parameter)\nconst results = await query(\n  supabase,\n  \"items\",\n  { active: true },\n  undefined, // is conditions\n  undefined, // wherein conditions\n  undefined, // order\n  \"inventory\", // schema\n).many()\n```\n\nWhen no schema is specified, queries use the default `public` schema via `client.from()`. When a schema is specified, queries use `client.schema(name).from(table)`.\n\n### View Entities (Read-Only)\n\nDatabase views in Supabase are read-only and only have a `Row` type (no `Insert` or `Update`). Use `ViewEntity` for type-safe querying of views:\n\n```typescript\nimport { ViewEntity, PartitionedViewEntity } from \"supabase-typed-query\"\n\n// Create a read-only view entity\nconst AuthUsersView = ViewEntity(supabase, \"auth_users_view\", {\n  schema: \"agent_gate\", // Optional: defaults to \"public\"\n})\n\n// Query the view - only getItem and getItems are available\nconst user = await AuthUsersView.getItem({ id: \"123\" }).one()\nconst activeUsers = await AuthUsersView.getItems({\n  where: { is_active: true },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// For multi-tenant views, use PartitionedViewEntity\nconst TenantStatsView = PartitionedViewEntity(supabase, \"tenant_stats_view\", {\n  partitionField: \"tenant_id\",\n})\n\n// All queries require partition key\nconst stats = await TenantStatsView.getItems(tenantId, {\n  where: { period: \"monthly\" },\n}).many()\n```\n\n**Key differences from Entity:**\n\n- Only `getItem()` and `getItems()` methods (no write operations)\n- No `softDelete` configuration (views are read-only snapshots)\n- Uses `ViewNames` and `ViewRow` types instead of `TableNames` and `TableRow`\n\n### Multi-Tenancy with Partition Keys\n\nUse partition keys to automatically scope queries to a tenant or partition:\n\n```typescript\n// Create a tenant-scoped entity\nconst TenantPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  partitionKey: { tenant_id: \"tenant-123\" }, // All queries automatically include this filter\n})\n\n// All queries are automatically scoped to the tenant\nconst tenantPosts = await TenantPostEntity.getItems({\n  where: { status: \"published\" },\n}).many()\n// Equivalent to: WHERE tenant_id = 'tenant-123' AND status = 'published' AND deleted IS NULL\n\n// Create a global/admin entity (no partition)\nconst GlobalPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  // No partitionKey - queries all tenants\n})\n\nconst allPosts = await GlobalPostEntity.getItems().many()\n// Equivalent to: WHERE deleted IS NULL\n```\n\n### Error Handling\n\nThe library uses functype's `TaskOutcome` for error handling:\n\n```typescript\n// Using TaskOutcome (recommended for explicit error handling)\nconst result = await query(supabase, \"users\", { id: userId }).one()\n\nif (result.isOk()) {\n  const maybeUser = result.getOrThrow()\n  if (maybeUser.isSome()) {\n    console.log(\"User found:\", maybeUser.getOrThrow())\n  }\n} else {\n  console.error(\"Query failed:\", result.error)\n}\n\n// Using OrThrow methods (simpler but throws errors)\ntry {\n  const user = await query(supabase, \"users\", { id: userId }).oneOrThrow()\n  console.log(\"User:\", user)\n} catch (error) {\n  console.error(\"Query failed:\", error)\n}\n```\n\n### Type Safety\n\nAll operations are fully type-safe based on your database schema:\n\n```typescript\n// TypeScript will enforce correct field names and types\nconst posts = await query(supabase, \"posts\", {\n  // âœ… TypeScript knows these fields exist and their types\n  title: \"My Post\",\n  published: true,\n  view_count: { gte: 100 },\n\n  // âŒ TypeScript error: property doesn't exist\n  nonexistent_field: \"value\",\n}).many()\n```\n\n## API Reference\n\n### Query Methods\n\n- `one()` - Execute query expecting exactly one result\n- `many()` - Execute query expecting zero or more results\n- `first()` - Execute query expecting first result from potentially multiple\n- `oneOrThrow()` - Like `one()` but throws if not found\n- `manyOrThrow()` - Like `many()` but throws on error\n- `firstOrThrow()` - Like `first()` but throws if not found\n\n### Query Composition\n\n- `or(conditions)` - Add OR conditions to the query\n- `map(fn)` - Transform results with a mapping function\n- `filter(fn)` - Filter results with a predicate\n- `limit(n)` - Limit the number of results\n- `offset(n)` - Skip the first n results\n- `includeDeleted()` - Include soft-deleted items in results\n- `excludeDeleted()` - Exclude soft-deleted items from results\n- `onlyDeleted()` - Return only soft-deleted items\n\n### Entity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n- `addItems({ items })` - Add multiple items\n- `updateItem({ id, item, where?, is?, wherein? })` - Update a single item\n- `updateItems({ items, identity?, where?, is?, wherein? })` - Update multiple items\n\n### Entity Configuration\n\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items; when `false`, includes them\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### ViewEntity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n\n> **Note:** ViewEntity only supports read operations. No `addItems`, `updateItem`, `deleteItem`, or soft delete methods.\n\n### ViewEntity Configuration\n\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedViewEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n## Requirements\n\n- TypeScript 5.0+\n- Supabase JS Client v2\n- functype 0.14+\n\n## License\n\nMIT\n\n## Development\n\n### Setup\n\n```bash\n# Clone the repository\ngit clone https://github.com/jordanburke/supabase-typed-query.git\ncd supabase-typed-query\n\n# Install dependencies\npnpm install\n\n# Run validation pipeline\npnpm validate\n```\n\n### Commands\n\n```bash\n# Development\npnpm validate          # Run full validation: format, lint, typecheck, test, build\npnpm test             # Run tests\npnpm test:watch       # Run tests in watch mode\npnpm test:coverage    # Run tests with coverage\npnpm build            # Build for production\npnpm build:dev:watch  # Build in watch mode for development\n\n# Code Quality\npnpm format           # Format code with Prettier\npnpm lint             # Fix ESLint issues\npnpm typecheck        # Type check with TypeScript\n```\n\n### CI/CD Pipeline\n\nThis project uses GitHub Actions for continuous integration and deployment:\n\n#### Continuous Integration\n\n- **Triggered on**: Push/PR to main/develop branches\n- **Test matrix**: Node.js 18.x, 20.x, 22.x\n- **Pipeline**: Format â†’ Lint â†’ Type Check â†’ Test â†’ Build\n\n#### Release Process\n\n1. Update version in `package.json`\n2. Create and push a version tag:\n   ```bash\n   git tag v1.0.0\n   git push origin v1.0.0\n   ```\n3. GitHub Actions automatically:\n   - Runs full validation pipeline\n   - Publishes to NPM registry\n   - Creates GitHub release\n\n#### Security\n\n- CodeQL analysis runs on all PRs and weekly scheduled scans\n- Dependency updates via Dependabot\n\n### Publishing\n\nThe package is automatically published to NPM when a version tag is pushed. Manual publishing:\n\n```bash\n# Ensure you're logged into NPM\nnpm login\n\n# Run validation and publish\npnpm build:publish\n```\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n### Development Guidelines\n\n1. **Type Safety**: Maintain strict TypeScript types, no `any`\n2. **Functional Style**: Use functional programming patterns with functype\n3. **Testing**: Add tests for new features\n4. **Documentation**: Update README for API changes\n5. **Commits**: Follow conventional commits format\n\n### Pull Request Process\n\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/amazing-feature`)\n3. Run `pnpm validate` to ensure all checks pass\n4. Commit your changes (`git commit -m 'feat: add amazing feature'`)\n5. Push to the branch (`git push origin feature/amazing-feature`)\n6. Open a Pull Request\n\nTests will automatically run via GitHub Actions on your PR.\n"
      },
      "plugins": [
        {
          "name": "supabase-typed-query",
          "description": "Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/supabase-typed-query"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/supabase-typed-query",
            "/plugin install supabase-typed-query@supabase-typed-query-skills"
          ]
        }
      ]
    },
    {
      "name": "typescript-standards",
      "version": null,
      "description": "Skills for creating TypeScript libraries using modern tooling and applying standardized build patterns",
      "repo_full_name": "jordanburke/typescript-library-template",
      "repo_url": "https://github.com/jordanburke/typescript-library-template",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-26T08:42:32Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"typescript-standards\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for creating TypeScript libraries using modern tooling and applying standardized build patterns\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"typescript-standards\",\n      \"description\": \"Guide for creating TypeScript libraries using the typescript-library-template pattern and applying its standards to existing projects. Use when setting up new npm packages, standardizing build scripts, configuring tooling (tsup, Vitest, ESLint, Prettier), or applying dual module format patterns.\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/typescript-standards\"]\n    }\n  ]\n}\n",
        "README.md": "## typescript-library-template\n\n[![Node.js CI](https://github.com/jordanburke/typescript-library-template/actions/workflows/node.js.yml/badge.svg)](https://github.com/jordanburke/typescript-library-template/actions/workflows/node.js.yml)\n[![CodeQL](https://github.com/jordanburke/typescript-library-template/actions/workflows/codeql.yml/badge.svg)](https://github.com/jordanburke/typescript-library-template/actions/workflows/codeql.yml)\n\nA modern TypeScript library template with standardized build scripts and tooling.\n\n## Features\n\n- **Modern Build System**: [ts-builds](https://github.com/jordanburke/ts-builds) + [tsdown](https://tsdown.dev/) for fast bundling\n- **Testing**: [Vitest](https://vitest.dev/) with coverage reporting\n- **Code Quality**: ESLint + Prettier with automatic formatting and fixing\n- **Dual Format**: Outputs both CommonJS and ES modules with proper TypeScript declarations\n- **Standardized Scripts**: Consistent commands via ts-builds across all projects\n\n## Quick Start\n\n1. **Use this template** to create a new repository\n2. **Clone your new repository**\n3. **Install dependencies**: `pnpm install`\n4. **Start developing**: `pnpm dev` (builds with watch mode)\n5. **Before committing**: `pnpm validate` (format + lint + test + build)\n\n## Development Commands\n\n### Pre-Checkin Command\n\n```bash\npnpm validate  # Main command: format, lint, test, and build everything\n```\n\n### Individual Commands\n\n```bash\n# Formatting\npnpm format        # Format code with Prettier\npnpm format:check  # Check formatting without writing\n\n# Linting\npnpm lint          # Fix ESLint issues\npnpm lint:check    # Check ESLint issues without fixing\n\n# Testing\npnpm test          # Run tests once\npnpm test:watch    # Run tests in watch mode\npnpm test:coverage # Run tests with coverage report\n\n# Building\npnpm build         # Production build\npnpm dev           # Development mode with watch\n\n# Type Checking\npnpm typecheck     # Check TypeScript types\n```\n\n## Publishing\n\nThe template automatically runs `pnpm validate` before publishing via the `prepublishOnly` script.\n\n```bash\nnpm version patch|minor|major\nnpm publish --access public\n```\n\n## Project Structure\n\n```\nsrc/\nâ”œâ”€â”€ index.ts          # Main library entry point\ntest/\nâ”œâ”€â”€ *.spec.ts         # Test files\ndist/                 # Built output (CommonJS + ES modules + types)\n```\n\n## Tooling\n\n- **Build**: [ts-builds](https://github.com/jordanburke/ts-builds) - Centralized TypeScript toolchain\n- **Bundler**: [tsdown](https://tsdown.dev/) - Fast TypeScript bundler (successor to tsup)\n- **Test**: [Vitest](https://vitest.dev/) - Fast unit test framework\n- **Lint**: [ESLint](https://eslint.org/) with TypeScript support\n- **Format**: [Prettier](https://prettier.io/) with ESLint integration\n- **Package Manager**: [pnpm](https://pnpm.io/) for fast, efficient installs\n\n## Claude Code Skill\n\nThis repository includes a Claude Code skill to help you apply these standards to other projects:\n\n**Location**: `.claude/skills/typescript-standards/`\n\n**Usage**: When using Claude Code, the skill automatically provides guidance for:\n\n- Creating new libraries from this template\n- Applying these standards to existing TypeScript projects\n- Configuring tooling (ts-builds, Vitest, ESLint, Prettier)\n- Setting up dual module format\n\n**Installation** (for use in other projects):\n\n```bash\n# Copy the skill to your Claude Code skills directory\ncp -r .claude/skills/typescript-standards ~/.claude/skills/\n```\n\n**References**:\n\n- [CLAUDE.md](./CLAUDE.md) - Development guidance for this project\n- [STANDARDIZATION_GUIDE.md](./STANDARDIZATION_GUIDE.md) - Guide for applying these patterns to existing projects\n- [.claude/skills/typescript-standards/](./.claude/skills/typescript-standards/) - Complete skill documentation\n\n---\n\n_This template is based on the earlier work of https://github.com/orabazu/tsup-library-template but updated with modern tooling and standardized scripts._\n"
      },
      "plugins": [
        {
          "name": "typescript-standards",
          "description": "Guide for creating TypeScript libraries using the typescript-library-template pattern and applying its standards to existing projects. Use when setting up new npm packages, standardizing build scripts, configuring tooling (tsup, Vitest, ESLint, Prettier), or applying dual module format patterns.",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/typescript-standards"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/typescript-library-template",
            "/plugin install typescript-standards@typescript-standards"
          ]
        }
      ]
    }
  ]
}