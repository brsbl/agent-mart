{
  "author": {
    "id": "jordanburke",
    "display_name": "Jordan",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/67263?v=4",
    "url": "https://github.com/jordanburke",
    "bio": null,
    "stats": {
      "total_marketplaces": 2,
      "total_plugins": 3,
      "total_commands": 0,
      "total_skills": 3,
      "total_stars": 8,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "functype-skills",
      "version": null,
      "description": "Skills for working with the functype functional programming library for TypeScript",
      "owner_info": {
        "name": "Jordan Burke",
        "email": "jordan.burke@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "jordanburke/functype",
      "repo_url": "https://github.com/jordanburke/functype",
      "repo_description": "A Functional Library for TypeScript based on Scala",
      "homepage": "https://functype.org/",
      "signals": {
        "stars": 7,
        "forks": 1,
        "pushed_at": "2026-01-26T15:54:39Z",
        "created_at": "2016-04-24T11:02:13Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 846
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/README.md",
          "type": "blob",
          "size": 6211
        },
        {
          "path": ".claude/skills/functype-developer",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/functype-developer/SKILL.md",
          "type": "blob",
          "size": 11298
        },
        {
          "path": ".claude/skills/functype-developer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/functype-developer/references/adding-types.md",
          "type": "blob",
          "size": 7810
        },
        {
          "path": ".claude/skills/functype-developer/references/architecture.md",
          "type": "blob",
          "size": 12216
        },
        {
          "path": ".claude/skills/functype-developer/references/testing-patterns.md",
          "type": "blob",
          "size": 7614
        },
        {
          "path": ".claude/skills/functype",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/functype/SKILL.md",
          "type": "blob",
          "size": 8949
        },
        {
          "path": ".claude/skills/functype/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/functype/references/common-patterns.md",
          "type": "blob",
          "size": 8689
        },
        {
          "path": ".claude/skills/functype/references/feature-matrix.md",
          "type": "blob",
          "size": 43
        },
        {
          "path": ".claude/skills/functype/references/quick-reference.md",
          "type": "blob",
          "size": 9109
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 27506
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/considerations",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/considerations/README.md",
          "type": "blob",
          "size": 2365
        },
        {
          "path": "landing",
          "type": "tree",
          "size": null
        },
        {
          "path": "landing/README.md",
          "type": "blob",
          "size": 1581
        },
        {
          "path": "src",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/branded",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/branded/README.md",
          "type": "blob",
          "size": 9233
        },
        {
          "path": "src/conditional",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/conditional/README.md",
          "type": "blob",
          "size": 3011
        },
        {
          "path": "src/functype",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/functype/README.md",
          "type": "blob",
          "size": 4827
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"functype-skills\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for working with the functype functional programming library for TypeScript\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"functype\",\n      \"description\": \"Help developers use functype patterns in their TypeScript projects - pattern conversion, API lookup, common use cases\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/functype\"]\n    },\n    {\n      \"name\": \"functype-developer\",\n      \"description\": \"Assist contributors developing the functype library - architecture patterns, creating new types, testing strategies\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/functype-developer\"]\n    }\n  ]\n}\n",
        ".claude/skills/README.md": "# Functype Skills\n\nThis directory contains Claude Code skills for working with the functype library.\n\n## Available Skills\n\n### 1. functype\n\n**Purpose**: Help developers use functype patterns in their TypeScript projects\n\n**Use when**:\n\n- Converting imperative/OOP code to functional patterns\n- Looking up functype APIs and methods\n- Handling nulls with Option\n- Managing errors with Either/Try\n- Working with immutable collections (List, Set)\n- Debugging functype code\n\n**Installation**:\n\n```bash\n# From the distributed zip\nclaude-code install dist/skills/functype.zip\n\n# Or copy directly to Claude's skills directory\ncp -r .claude/skills/functype ~/.claude/skills/\n```\n\n### 2. functype-developer\n\n**Purpose**: Assist contributors developing the functype library itself\n\n**Use when**:\n\n- Creating new data structures\n- Implementing functional interfaces (Functor, Monad, Foldable)\n- Adding tests\n- Understanding library architecture\n- Debugging functional type implementations\n- Following the Base pattern and Companion utilities\n\n**Installation**:\n\n```bash\n# From the distributed zip\nclaude-code install dist/skills/functype-developer.zip\n\n# Or copy directly to Claude's skills directory\ncp -r .claude/skills/functype-developer ~/.claude/skills/\n```\n\n## Skill Contents\n\n### functype\n\n```\nfunctype/\n├── SKILL.md                        # Main skill guide\n└── references/\n    ├── feature-matrix.md           # Interface and method reference (symlink)\n    ├── common-patterns.md          # Additional pattern examples\n    └── quick-reference.md          # Quick API lookup\n```\n\n**Key features**:\n\n- Pattern conversion examples (imperative → functional)\n- Common use cases (validation, error handling, collections)\n- API lookup by type\n- Debugging tips\n- CLI documentation access (`npx functype`)\n\n### functype-developer\n\n```\nfunctype-developer/\n├── SKILL.md                        # Main development guide\n├── scripts/\n│   ├── new-type-template.sh        # Generate boilerplate for new types\n│   └── validate.sh                 # Run full validation workflow\n└── references/\n    ├── architecture.md             # Architecture and design patterns\n    ├── adding-types.md             # Step-by-step guide for new types\n    └── testing-patterns.md         # Testing strategies\n```\n\n**Key features**:\n\n- Complete development workflow\n- Architecture patterns (Base, Companion, HKT)\n- Interface implementation guide\n- Testing patterns (unit, property-based, integration)\n- Code style guidelines\n- Debugging tips\n\n## Building Skills\n\nThe skills are created using the Anthropic skill-creator toolkit:\n\n```bash\n# Initialize new skill\npython3 ~/.claude/plugins/marketplaces/anthropic-agent-skills/skill-creator/scripts/init_skill.py skill-name --path .claude/skills\n\n# Package skill\npython3 ~/.claude/plugins/marketplaces/anthropic-agent-skills/skill-creator/scripts/package_skill.py .claude/skills/skill-name dist/skills\n```\n\n## Marketplace Distribution\n\nThe `.claude-plugin/marketplace.json` file enables marketplace distribution:\n\n```json\n{\n  \"name\": \"functype\",\n  \"skills\": [\n    {\n      \"id\": \"functype\",\n      \"name\": \"Functype User Guide\",\n      \"path\": \".claude/skills/functype\"\n    },\n    {\n      \"id\": \"functype-developer\",\n      \"name\": \"Functype Library Developer\",\n      \"path\": \".claude/skills/functype-developer\"\n    }\n  ]\n}\n```\n\n## Usage in Claude Code\n\nOnce installed, Claude Code will automatically suggest these skills when:\n\n**functype** triggers:\n\n- Code contains null checks, optional chaining, or try-catch\n- User asks about functype patterns or APIs\n- Working with Option, Either, Try, List types\n\n**functype-developer** triggers:\n\n- Creating new functype types\n- Implementing functional interfaces\n- Adding tests to functype\n- Working in the functype repository\n\n## Updating Skills\n\nTo update skills after making changes:\n\n1. Edit the skill files in `.claude/skills/`\n2. Repackage: `python3 ~/.claude/plugins/.../package_skill.py .claude/skills/skill-name dist/skills`\n3. Reinstall if needed\n\n## Contributing\n\nTo improve these skills:\n\n1. Edit files in `.claude/skills/functype/` or `.claude/skills/functype-developer/`\n2. Test the skill locally\n3. Repackage and verify\n4. Commit changes to the repository\n\n## Skill Validation Checklist\n\nBefore packaging or updating skills, verify the following to prevent errors:\n\n### Content Validation\n\n- [ ] **YAML frontmatter**: Properly formatted with `---` delimiters (no extra characters)\n- [ ] **Import statements**: All imports verified against `package.json` exports\n- [ ] **Code examples**: All code compiles and type-checks correctly\n- [ ] **File paths**: All referenced files exist in the repository\n- [ ] **URLs**: All links point to valid, accessible URLs\n- [ ] **Skill description**: Accurately describes when to trigger the skill\n\n### Import Verification Process\n\n1. Open `package.json` and review the `exports` section\n2. Compare all `import` statements in skill files against available exports\n3. Remove or update any imports that aren't exported\n4. For internal development examples (functype-developer), use `@/` imports\n5. For user-facing examples (functype), only use published package imports\n\n### Common Import Mistakes to Avoid\n\n- ❌ `import { Base } from \"functype/core/base\"` (internal paths not exported)\n- ❌ `import { Option } from \"functype/option\"` (subpath imports don't work)\n- ✅ `import { Option } from \"functype\"` (correct - use main bundle)\n- ✅ `import { Base } from \"@/core/base\"` (valid for functype-developer only)\n\n### Package Validation\n\n```bash\n# Validate before packaging\npython3 ~/.claude/plugins/marketplaces/anthropic-agent-skills/skill-creator/scripts/quick_validate.py .claude/skills/functype\n\n# Package after validation passes\npython3 ~/.claude/plugins/marketplaces/anthropic-agent-skills/skill-creator/scripts/package_skill.py .claude/skills/functype dist/skills\n```\n\n## Resources\n\n- **Skill Creator Docs**: See the skill-creator skill for guidelines\n- **Functype Docs**: https://jordanburke.github.io/functype/\n- **Feature Matrix**: `docs/FUNCTYPE_FEATURE_MATRIX.md`\n- **GitHub**: https://github.com/jordanburke/functype\n",
        ".claude/skills/functype-developer/SKILL.md": "---\nname: functype-developer\ndescription: Assist contributors working on the functype library codebase. Use this skill when creating new data structures, implementing functional interfaces (Functor, Monad, Foldable), adding tests, debugging library internals, or understanding functype's Scala-inspired architecture patterns including the Base pattern, HKT system, and Companion utilities.\n---\n\n# Functype Library Developer\n\n## Overview\n\nGuide for contributing to the functype TypeScript library. This skill provides architectural patterns, development workflows, and tooling for implementing new functional data structures following functype's Scala-inspired design.\n\n## When to Use This Skill\n\nTrigger this skill when:\n\n- Creating new data structures or types\n- Implementing functional interfaces (Functor, Monad, Foldable, etc.)\n- Adding or fixing tests\n- Understanding library architecture\n- Debugging functional type implementations\n- Following the Base pattern and type class system\n- Working with the Feature Matrix\n\n## Development Workflow\n\n### Prerequisites\n\n- **Node.js**: ≥ 18.0.0\n- **pnpm**: 10.12.1\n- **TypeScript**: Strict mode enabled\n\n### Essential Commands\n\n```bash\n# Install dependencies\npnpm install\n\n# Development (build with watch)\npnpm dev\n\n# Before committing (MUST PASS)\npnpm validate\n\n# Run tests\npnpm test\n\n# Run specific test file\npnpm vitest run test/specific.spec.ts\n\n# Check types without building\npnpm compile\n```\n\n### Pre-Commit Checklist\n\n**Always run before committing:**\n\n```bash\npnpm validate\n```\n\nThis runs:\n\n1. **Format**: Prettier formatting\n2. **Lint**: ESLint checks\n3. **Test**: All Vitest tests\n4. **Build**: Production build\n\n## Core Architecture\n\n### Scala-Inspired Constructor Pattern\n\nAll types follow this pattern:\n\n```typescript\n// Constructor function returns object with methods\nconst option = Option(value) // Constructor\noption.map((x) => x + 1) // Instance methods\nOption.none() // Companion methods\n```\n\n**NOT class-based:**\n\n```typescript\n// ❌ Don't do this\nclass Option<T> {\n  constructor(value: T) { ... }\n}\n\n// ✅ Do this\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  return value == null ? none() : some(value)\n}\n```\n\n### Base Pattern\n\nUse the `Base` function to add common functionality to all types:\n\n```typescript\nimport { Base } from \"@/core/base\"\n\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  if (value == null) {\n    return Base(\"None\", {\n      // methods here\n      map: <B>(f: (val: T) => B) => Option.none<B>(),\n      // ...\n    })\n  }\n\n  return Base(\"Some\", {\n    // methods here\n    map: <B>(f: (val: T) => B) => Option(f(value)),\n    // ...\n  })\n}\n```\n\n**Base provides:**\n\n- `Typeable` interface (type metadata)\n- Standard `toString()` method\n- Consistent object structure\n\n### Type System Foundation\n\n**Base constraint:**\n\n```typescript\nimport type { Type } from \"@/functor\"\n\n// Use Type instead of any\nfunction process<T extends Type>(value: T): void {\n  // ...\n}\n```\n\n**Never use `any`**:\n\n- Use `unknown` for uncertain types\n- Use `Type` for generic constraints\n- Use proper type definitions\n\n### Functional Interfaces\n\nEvery container type should implement these when applicable:\n\n**Core interfaces** (see `references/architecture.md` for details):\n\n- `Functor` - map over values\n- `Applicative` - apply wrapped functions\n- `Monad` - flatMap for sequencing\n- `Foldable` - extract via pattern matching\n- `Traversable` - collection operations\n- `Serializable` - JSON/YAML/binary serialization\n\n**Reference the Feature Matrix:**\nCheck `docs/FUNCTYPE_FEATURE_MATRIX.md` to see which interfaces each type implements and what methods are required.\n\n## Creating a New Data Structure\n\n### Step-by-Step Guide\n\n**1. Research existing patterns**\n\n```bash\n# Use the Explore agent to understand the codebase\n# Look at Option, Either, or Try as reference implementations\n```\n\n**2. Create module structure**\n\n```bash\nmkdir -p src/mynewtype\ntouch src/mynewtype/index.ts\ntouch test/mynewtype.spec.ts\n```\n\n**3. Use the template script**\n\n```bash\n# Run the new-type-template script\n./claude/skills/functype-developer/scripts/new-type-template.sh MyNewType\n```\n\nThis generates:\n\n- Basic type structure\n- Required interface implementations\n- Test file boilerplate\n\n**4. Implement the type**\n\nFollow the constructor pattern:\n\n```typescript\n// src/mynewtype/index.ts\nimport { Base } from \"@/core/base\"\nimport type { Functor } from \"@/functor\"\n\nexport type MyNewType<T> = Functor<T> & {\n  // Your methods here\n  getValue(): T\n}\n\nexport function MyNew<T>(value: T): MyNewType<T> {\n  return Base(\"MyNewType\", {\n    // Functor\n    map: <B>(f: (val: T) => B): MyNewType<B> => {\n      return MyNew(f(value))\n    },\n\n    // Your methods\n    getValue: () => value,\n\n    // Pipe for composition\n    pipe: () => ({\n      map: (f: (val: T) => any) => MyNew(value).map(f),\n    }),\n  })\n}\n\n// Companion methods\nMyNew.empty = <T>() => MyNew<T>(null as any)\n```\n\n**5. Add exports**\n\nUpdate `src/index.ts`:\n\n```typescript\nexport { MyNew } from \"./mynewtype\"\nexport type { MyNewType } from \"./mynewtype\"\n```\n\nUpdate `package.json` exports:\n\n```json\n{\n  \"exports\": {\n    \"./mynewtype\": {\n      \"import\": \"./dist/esm/mynewtype/index.js\",\n      \"require\": \"./dist/cjs/mynewtype/index.js\",\n      \"types\": \"./dist/types/mynewtype/index.d.ts\"\n    }\n  }\n}\n```\n\n**6. Write comprehensive tests**\n\n```typescript\n// test/mynewtype.spec.ts\nimport { describe, expect, it } from \"vitest\"\nimport { MyNew } from \"@/mynewtype\"\n\ndescribe(\"MyNewType\", () => {\n  describe(\"Construction\", () => {\n    it(\"should create from value\", () => {\n      const value = MyNew(5)\n      expect(value.getValue()).toBe(5)\n    })\n  })\n\n  describe(\"Functor\", () => {\n    it(\"should map over values\", () => {\n      const result = MyNew(5).map((x) => x * 2)\n      expect(result.getValue()).toBe(10)\n    })\n  })\n\n  // More tests...\n})\n```\n\n**7. Update Feature Matrix**\n\nAdd your type to `docs/FUNCTYPE_FEATURE_MATRIX.md` showing which interfaces it implements.\n\n**8. Validate**\n\n```bash\npnpm validate\n```\n\n### Interface Implementation Checklist\n\nWhen implementing interfaces, refer to this checklist:\n\n**Functor:**\n\n- [ ] `map<B>(f: (value: A) => B): Functor<B>`\n\n**Applicative (extends Functor):**\n\n- [ ] `ap<B>(ff: Applicative<(value: A) => B>): Applicative<B>`\n\n**Monad (extends Applicative):**\n\n- [ ] `flatMap<B>(f: (value: A) => Monad<B>): Monad<B>`\n\n**Foldable:**\n\n- [ ] `fold<B>(onEmpty: () => B, onValue: (value: A) => B): B`\n- [ ] `foldLeft<B>(z: B): (op: (b: B, a: A) => B) => B`\n- [ ] `foldRight<B>(z: B): (op: (a: A, b: B) => B) => B`\n\nSee `references/architecture.md` for complete interface definitions.\n\n## Testing Patterns\n\n### Test Structure\n\nUse Vitest with describe/it pattern:\n\n```typescript\ndescribe(\"TypeName\", () => {\n  describe(\"Feature Group\", () => {\n    it(\"should do specific thing\", () => {\n      // Arrange\n      const input = createInput()\n\n      // Act\n      const result = performOperation(input)\n\n      // Assert\n      expect(result).toBe(expected)\n    })\n  })\n})\n```\n\n### Property-Based Testing\n\nUse fast-check for property tests:\n\n```typescript\nimport { fc, test } from \"@fast-check/vitest\"\n\ntest.prop([fc.integer()])(\"should always return positive\", (n) => {\n  const result = Math.abs(n)\n  expect(result).toBeGreaterThanOrEqual(0)\n})\n```\n\n### Edge Cases to Test\n\nAlways test:\n\n- Empty/null/undefined inputs\n- Type inference correctness\n- Method chaining\n- Error cases\n- Immutability (original unchanged)\n\n## Code Style Guidelines\n\n### Imports\n\n```typescript\n// Type-only imports when possible\nimport type { Type } from \"@/functor\"\nimport { Option } from \"@/option\"\n\n// Organized with simple-import-sort (automatic)\n```\n\n### Types\n\n```typescript\n// ✅ Use Type for constraints\nfunction process<T extends Type>(value: T): void\n\n// ✅ Prefer types over interfaces\nexport type MyType<T> = {\n  value: T\n}\n\n// ✅ Explicit type annotations\nfunction transform<T>(input: T): MyType<T> {\n  return { value: input }\n}\n```\n\n### Naming\n\n```typescript\n// PascalCase for types\ntype OptionType<T> = { ... }\n\n// camelCase for functions/variables\nconst someValue = Option(5)\nfunction mapOption<T>(opt: OptionType<T>) { ... }\n\n// Constructor functions are PascalCase\nOption(value)\nEither(value)\n```\n\n### Functional Style\n\n```typescript\n// ✅ Immutability\nconst newList = list.append(item)\n\n// ❌ Mutation\nlist.push(item)\n\n// ✅ Pure functions\nfunction double(x: number): number {\n  return x * 2\n}\n\n// ❌ Side effects\nfunction double(x: number): number {\n  console.log(x) // side effect\n  return x * 2\n}\n```\n\n### Pattern Matching\n\n```typescript\n// ✅ Use Cond for conditionals\nimport { Cond } from \"@/cond\"\n\nCond.start<string>()\n  .case(x > 10, \"big\")\n  .case(x > 5, \"medium\")\n  .otherwise(\"small\")\n\n// ✅ Use Match for switches\nimport { Match } from \"@/match\"\n\nMatch(status)\n  .case(\"success\", () => handleSuccess())\n  .case(\"error\", () => handleError())\n  .done()\n\n// ❌ Avoid early returns\n// Use Cond or Option instead\n```\n\n## Common Development Tasks\n\n### Adding a Helper Method\n\n```typescript\n// Add to type definition\nexport type MyType<T> = {\n  // existing methods...\n\n  // New helper\n  isEmpty(): boolean\n}\n\n// Implement in constructor\nexport function MyType<T>(value: T): MyType<T> {\n  return Base(\"MyType\", {\n    // existing methods...\n\n    isEmpty: () => value == null,\n  })\n}\n```\n\n### Implementing Serialization\n\n```typescript\nimport { createSerializable } from \"@/core/serializable\"\n\nexport function MyType<T>(value: T): MyType<T> {\n  return Base(\"MyType\", {\n    // other methods...\n\n    serialize: () =>\n      createSerializable({\n        type: \"MyType\",\n        value: value,\n      }),\n  })\n}\n```\n\n### Adding Do-Notation Support\n\n```typescript\nexport const MyTypeCompanion = {\n  Do: <T>(gen: () => Generator<MyType<any>, T, any>): MyType<T> => {\n    // Implementation here\n    // See Option or Either for reference\n  },\n}\n\nexport const MyType = Object.assign(MyTypeConstructor, MyTypeCompanion)\n```\n\n## Debugging Tips\n\n### TypeScript Errors\n\n**\"Type instantiation is excessively deep\"**\n\n- Check for circular type references\n- Simplify nested generic types\n- Use type aliases to break up complex types\n\n**\"Property 'X' does not exist on type 'Y'\"**\n\n- Ensure all interfaces are properly implemented\n- Check that types are correctly exported\n- Verify Base pattern includes all required methods\n\n### Test Failures\n\n```bash\n# Run specific test with verbose output\npnpm vitest run test/mytype.spec.ts --reporter=verbose\n\n# Run tests in watch mode\npnpm test:watch\n\n# Check test coverage\npnpm test:coverage\n```\n\n### Build Issues\n\n```bash\n# Clean and rebuild\npnpm clean && pnpm build\n\n# Check TypeScript compilation only\npnpm compile\n\n# Analyze bundle size\npnpm analyze:size\n```\n\n## Resources\n\n### scripts/\n\n- `new-type-template.sh` - Generate boilerplate for new types\n- `validate.sh` - Run the full validation workflow\n\n### references/\n\n- `architecture.md` - Detailed architecture and patterns\n- `adding-types.md` - Complete guide for adding new data structures\n- `testing-patterns.md` - Testing strategies and examples\n\n### External Links\n\n- **GitHub**: https://github.com/jordanburke/functype\n- **Docs**: https://jordanburke.github.io/functype/\n- **Feature Matrix**: `docs/FUNCTYPE_FEATURE_MATRIX.md`\n",
        ".claude/skills/functype-developer/references/adding-types.md": "# Adding New Data Structures\n\nStep-by-step guide for adding new types to functype.\n\n## Complete Workflow\n\n### 1. Planning\n\nBefore coding, answer these questions:\n\n- **What problem does this type solve?**\n- **Which functional interfaces should it implement?** (Check Feature Matrix)\n- **What are the key operations?**\n- **Are there similar types to reference?** (Option, Either, List)\n\n### 2. Create Module Structure\n\n```bash\n# Create directories\nmkdir -p src/mynewtype\nmkdir -p test\n\n# Create files\ntouch src/mynewtype/index.ts\ntouch test/mynewtype.spec.ts\n```\n\n### 3. Define Type Interface\n\n```typescript\n// src/mynewtype/index.ts\nimport type { Functor } from \"@/functor\"\nimport type { Foldable } from \"@/foldable\"\n\nexport type MyNewType<T> = Functor<T> &\n  Foldable<T> & {\n    // Core operations\n    getValue(): T\n    isEmpty(): boolean\n\n    // Additional methods\n    filter(predicate: (value: T) => boolean): MyNewType<T>\n  }\n```\n\n### 4. Implement Constructor\n\n```typescript\nimport { Base } from \"@/core/base\"\n\nexport function MyNew<T>(value: T): MyNewType<T> {\n  return Base(\"MyNewType\", {\n    // Functor\n    map: <B>(f: (val: T) => B): MyNewType<B> => {\n      return MyNew(f(value))\n    },\n\n    // Foldable\n    fold: <B>(onEmpty: () => B, onValue: (val: T) => B): B => {\n      return value == null ? onEmpty() : onValue(value)\n    },\n\n    foldLeft:\n      <B>(z: B) =>\n      (op: (b: B, a: T) => B): B => {\n        return value == null ? z : op(z, value)\n      },\n\n    foldRight:\n      <B>(z: B) =>\n      (op: (a: T, b: B) => B): B => {\n        return value == null ? z : op(value, z)\n      },\n\n    // Custom methods\n    getValue: () => value,\n    isEmpty: () => value == null,\n    filter: (predicate: (val: T) => boolean) => {\n      return predicate(value) ? MyNew(value) : MyNew(null as any)\n    },\n\n    // Pipe for composition\n    pipe: () => ({\n      map: (f: (val: T) => any) => MyNew(value).map(f),\n      filter: (p: (val: T) => boolean) => MyNew(value).filter(p),\n    }),\n  })\n}\n```\n\n### 5. Add Companion Methods\n\n```typescript\n// Static factory methods\nMyNew.empty = <T>(): MyNewType<T> => MyNew<T>(null as any)\n\nMyNew.from = <T>(value: T | null | undefined): MyNewType<T> => {\n  return MyNew(value ?? (null as any))\n}\n\nMyNew.of = <T>(value: T): MyNewType<T> => MyNew(value)\n```\n\n### 6. Add Exports\n\n**Update `src/index.ts`:**\n\n```typescript\nexport { MyNew } from \"./mynewtype\"\nexport type { MyNewType } from \"./mynewtype\"\n```\n\n**Update `package.json` exports:**\n\n```json\n{\n  \"exports\": {\n    \"./mynewtype\": {\n      \"import\": \"./dist/esm/mynewtype/index.js\",\n      \"require\": \"./dist/cjs/mynewtype/index.js\",\n      \"types\": \"./dist/types/mynewtype/index.d.ts\"\n    }\n  }\n}\n```\n\n### 7. Write Tests\n\n```typescript\n// test/mynewtype.spec.ts\nimport { describe, expect, it } from \"vitest\"\nimport { MyNew } from \"@/mynewtype\"\n\ndescribe(\"MyNewType\", () => {\n  describe(\"Construction\", () => {\n    it(\"should create from value\", () => {\n      const value = MyNew(5)\n      expect(value.getValue()).toBe(5)\n      expect(value.isEmpty()).toBe(false)\n    })\n\n    it(\"should create empty\", () => {\n      const empty = MyNew.empty<number>()\n      expect(empty.isEmpty()).toBe(true)\n    })\n  })\n\n  describe(\"Functor\", () => {\n    it(\"should map over values\", () => {\n      const result = MyNew(5).map((x) => x * 2)\n      expect(result.getValue()).toBe(10)\n    })\n\n    it(\"should satisfy identity law\", () => {\n      const value = MyNew(5)\n      expect(value.map((x) => x)).toEqual(value)\n    })\n\n    it(\"should satisfy composition law\", () => {\n      const value = MyNew(5)\n      const f = (x: number) => x * 2\n      const g = (x: number) => x + 1\n\n      expect(value.map(f).map(g)).toEqual(value.map((x) => g(f(x))))\n    })\n  })\n\n  describe(\"Foldable\", () => {\n    it(\"should fold with value\", () => {\n      const result = MyNew(5).fold(\n        () => \"empty\",\n        (x) => `value: ${x}`,\n      )\n      expect(result).toBe(\"value: 5\")\n    })\n\n    it(\"should fold when empty\", () => {\n      const result = MyNew.empty<number>().fold(\n        () => \"empty\",\n        (x) => `value: ${x}`,\n      )\n      expect(result).toBe(\"empty\")\n    })\n  })\n\n  describe(\"Custom Methods\", () => {\n    it(\"should filter values\", () => {\n      const value = MyNew(5)\n      expect(value.filter((x) => x > 3).getValue()).toBe(5)\n      expect(value.filter((x) => x > 10).isEmpty()).toBe(true)\n    })\n  })\n\n  describe(\"Edge Cases\", () => {\n    it(\"should handle null\", () => {\n      const value = MyNew(null)\n      expect(value.isEmpty()).toBe(true)\n    })\n\n    it(\"should handle undefined\", () => {\n      const value = MyNew(undefined)\n      expect(value.isEmpty()).toBe(true)\n    })\n  })\n})\n```\n\n### 8. Update Documentation\n\n**Add to Feature Matrix (`docs/FUNCTYPE_FEATURE_MATRIX.md`):**\n\n```markdown\n| **MyNewType<T>** | ✓ | ✓ | ✓ | ... |\n```\n\n### 9. Validate\n\n```bash\npnpm validate\n```\n\nThis runs:\n\n- Format check\n- Lint check\n- All tests\n- Production build\n\n## Interface Implementation Guide\n\n### Implementing Monad\n\nIf your type should support `flatMap`:\n\n```typescript\nexport type MyNewType<T> = Functor<T> &\n  Monad<T> & {\n    // ...\n  }\n\nexport function MyNew<T>(value: T): MyNewType<T> {\n  return Base(\"MyNewType\", {\n    // ... other methods\n\n    flatMap: <B>(f: (val: T) => MyNewType<B>): MyNewType<B> => {\n      return value == null ? MyNew.empty<B>() : f(value)\n    },\n  })\n}\n```\n\n### Implementing Serializable\n\n```typescript\nimport { createSerializable } from \"@/core/serializable\"\n\nexport function MyNew<T>(value: T): MyNewType<T> {\n  return Base(\"MyNewType\", {\n    // ... other methods\n\n    serialize: () =>\n      createSerializable({\n        type: \"MyNewType\",\n        value: value,\n      }),\n  })\n}\n```\n\n### Implementing Traversable (for collections)\n\n```typescript\nexport function MyNewCollection<T>(items: T[]): MyNewCollectionType<T> {\n  return Base(\"MyNewCollection\", {\n    // ... other methods\n\n    size: items.length,\n    isEmpty: items.length === 0,\n    contains: (value: T) => items.includes(value),\n    reduce: <B>(f: (acc: B, val: T) => B, initial: B): B => {\n      return items.reduce(f, initial)\n    },\n  })\n}\n```\n\n## Common Patterns\n\n### Handling Multiple Cases\n\n```typescript\nexport function MyNew<T>(value: T): MyNewType<T> {\n  // Empty case\n  if (value == null) {\n    return Base(\"Empty\", {\n      map: <B>(_f: (val: T) => B) => MyNew.empty<B>(),\n      // ... empty implementations\n    })\n  }\n\n  // Value case\n  return Base(\"Value\", {\n    map: <B>(f: (val: T) => B) => MyNew(f(value)),\n    // ... value implementations\n  })\n}\n```\n\n### Adding Type Guards\n\n```typescript\nexport type MyNewType<T> = {\n  // ... other methods\n  isEmpty(): boolean\n  hasValue(): boolean\n}\n\nexport function MyNew<T>(value: T): MyNewType<T> {\n  return Base(\"MyNewType\", {\n    // ... other methods\n    isEmpty: () => value == null,\n    hasValue: () => value != null,\n  })\n}\n```\n\n### Companion Pattern with TypeScript\n\n```typescript\nimport { Companion } from \"@/core/companion\"\n\nfunction MyNewConstructor<T>(value: T): MyNewType<T> {\n  // ... implementation\n}\n\nconst MyNewCompanion = {\n  empty: <T>() => MyNewConstructor<T>(null as any),\n  of: <T>(value: T) => MyNewConstructor(value),\n  from: <T>(source: any) => MyNewConstructor<T>(/* convert source */),\n}\n\nexport const MyNew = Companion(MyNewConstructor, MyNewCompanion)\n```\n\n## Checklist\n\nBefore submitting:\n\n- [ ] Type interface defined with all required methods\n- [ ] Constructor implemented using Base pattern\n- [ ] All functional interfaces implemented correctly\n- [ ] Companion methods added (empty, from, of, etc.)\n- [ ] Exports added to src/index.ts\n- [ ] Package.json exports configured\n- [ ] Comprehensive tests written\n- [ ] Edge cases tested (null, undefined, empty)\n- [ ] Functor/Monad laws tested\n- [ ] Feature Matrix updated\n- [ ] `pnpm validate` passes\n",
        ".claude/skills/functype-developer/references/architecture.md": "# Functype Architecture\n\nComplete guide to functype's architectural patterns and design principles.\n\n## Design Philosophy\n\nFunctype follows Scala's functional programming model adapted for TypeScript:\n\n1. **Constructor functions** instead of classes\n2. **Immutable** data structures\n3. **Type-safe** operations with strict TypeScript\n4. **Composable** APIs via function chaining\n5. **Consistent** patterns across all types\n\n## Core Patterns\n\n### Constructor Pattern\n\nAll types use constructor functions that return objects with methods:\n\n```typescript\n// Pattern structure\nexport function TypeName<T>(value: T): TypeNameType<T> {\n  return Base(\"TypeName\", {\n    // Interface methods\n    map: <B>(f: (val: T) => B) => TypeName(f(value)),\n    flatMap: <B>(f: (val: T) => TypeNameType<B>) => f(value),\n\n    // Custom methods\n    getValue: () => value,\n\n    // Pipe for composition\n    pipe: () => ({\n      map: (f: (val: T) => any) => TypeName(value).map(f),\n    }),\n  })\n}\n\n// Companion methods\nTypeName.empty = <T>() => TypeName<T>(/* empty value */)\nTypeName.from = <T>(source: T[]) => TypeName<T>(/* construct */)\n```\n\n**Why not classes?**\n\n- Enables better tree-shaking\n- Simpler type inference\n- Aligns with functional programming principles\n- More flexible composition\n\n### Base Pattern\n\nThe `Base` function from `core/base` adds common functionality:\n\n```typescript\nimport { Base } from \"@/core/base\"\n\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  if (value == null) {\n    return Base(\"None\", {\n      map: <B>(_f: (val: T) => B) => Option.none<B>(),\n      // ... other methods\n    })\n  }\n\n  return Base(\"Some\", {\n    map: <B>(f: (val: T) => B) => Option(f(value)),\n    // ... other methods\n  })\n}\n```\n\n**Base provides:**\n\n- `Typeable` interface with type metadata\n- Standard `toString()` method\n- Consistent object structure\n- Type-safe access to internal state\n\n**Implementation:**\n\n```typescript\nexport function Base<T extends string, B extends Record<string, any>>(type: T, body: B): Typeable & B {\n  return {\n    ...body,\n    getType: () => type,\n    toString: () => `${type}(${JSON.stringify(body)})`,\n  }\n}\n```\n\n### Companion Pattern\n\nUse the `Companion` utility to create function-objects:\n\n```typescript\nimport { Companion } from \"@/core/companion\"\n\n// Define constructor\nfunction OptionConstructor<T>(value: T | null | undefined): OptionType<T> {\n  // ... implementation\n}\n\n// Define companion methods\nconst OptionCompanion = {\n  none: <T>() => OptionConstructor<T>(null),\n  some: <T>(value: T) => OptionConstructor(value),\n  from: <T>(value: T | null | undefined) => OptionConstructor(value),\n}\n\n// Combine constructor and companion\nexport const Option = Companion(OptionConstructor, OptionCompanion)\n```\n\n**Result:**\n\n```typescript\n// Constructor usage\nconst opt = Option(5)\n\n// Companion method usage\nconst none = Option.none()\nconst some = Option.some(10)\n```\n\n## Type System\n\n### Base Type Constraint\n\n```typescript\nimport type { Type } from \"@/functor\"\n\n// Use Type for generic constraints\nfunction process<T extends Type>(value: T): void {\n  // T can be any type\n}\n```\n\n**Never use `any`:**\n\n```typescript\n// ❌ Wrong\nfunction process(value: any): void\n\n// ✅ Correct\nfunction process<T extends Type>(value: T): void\n\n// ✅ Or for uncertain types\nfunction process(value: unknown): void\n```\n\n### Higher-Kinded Types (HKT)\n\nFunctype implements HKT to enable generic programming:\n\n```typescript\n// HKT allows abstracting over type constructors\ntype Functor<F, A> = {\n  map<B>(f: (a: A) => B): Functor<F, B>\n}\n\n// This allows writing generic functions that work with any Functor\nfunction double<F, A extends number>(fa: Functor<F, A>): Functor<F, A> {\n  return fa.map((a) => a * 2)\n}\n\n// Works with Option<number>, Either<E, number>, List<number>, etc.\n```\n\n### Branded Types\n\nUse the `Brand` module for nominal typing:\n\n```typescript\nimport { Brand } from \"@/brand\"\n\n// Create a branded type\ntype UserId = Brand<string, \"UserId\">\n\n// Constructor with validation\nconst UserId = Brand<string, \"UserId\">(\n  (value: string): Either<string, string> => (value.length > 0 ? Right(value) : Left(\"UserId cannot be empty\")),\n)\n\n// Usage\nconst userId = UserId.from(\"user-123\").fold(\n  (error) => console.error(error),\n  (id) => processUser(id), // id has type UserId, not string\n)\n```\n\n## Functional Interfaces\n\n### Functor\n\nMaps over contained values while preserving structure:\n\n```typescript\nexport interface Functor<T> {\n  map<B>(f: (value: T) => B): Functor<B>\n}\n\n// Example implementation\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  if (value == null) {\n    return Base(\"None\", {\n      map: <B>(_f: (val: T) => B) => Option.none<B>(),\n    })\n  }\n\n  return Base(\"Some\", {\n    map: <B>(f: (val: T) => B) => Option(f(value)),\n  })\n}\n```\n\n**Laws:**\n\n1. Identity: `fa.map(x => x) === fa`\n2. Composition: `fa.map(f).map(g) === fa.map(x => g(f(x)))`\n\n### Applicative\n\nApplies wrapped functions to wrapped values:\n\n```typescript\nexport interface Applicative<T> extends Functor<T> {\n  ap<B>(ff: Applicative<(value: T) => B>): Applicative<B>\n}\n\n// Example implementation\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  return Base(\"Option\", {\n    map: /* ... */,\n    ap: <B>(ff: OptionType<(value: T) => B>): OptionType<B> => {\n      return ff.flatMap(f => Option(value).map(f))\n    },\n  })\n}\n```\n\n**Laws:**\n\n1. Identity: `v.ap(pure(x => x)) === v`\n2. Homomorphism: `pure(x).ap(pure(f)) === pure(f(x))`\n3. Interchange: `u.ap(pure(y)) === pure(f => f(y)).ap(u)`\n\n### Monad\n\nSequences operations that return wrapped values:\n\n```typescript\nexport interface Monad<T> extends Applicative<T> {\n  flatMap<B>(f: (value: T) => Monad<B>): Monad<B>\n}\n\n// Example implementation\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  return Base(\"Option\", {\n    map: /* ... */,\n    ap: /* ... */,\n    flatMap: <B>(f: (val: T) => OptionType<B>): OptionType<B> => {\n      return value == null ? Option.none<B>() : f(value)\n    },\n  })\n}\n```\n\n**Laws:**\n\n1. Left identity: `pure(a).flatMap(f) === f(a)`\n2. Right identity: `m.flatMap(pure) === m`\n3. Associativity: `m.flatMap(f).flatMap(g) === m.flatMap(x => f(x).flatMap(g))`\n\n### Foldable\n\nExtracts values via pattern matching:\n\n```typescript\nexport interface Foldable<T> {\n  fold<B>(onEmpty: () => B, onValue: (value: T) => B): B\n  foldLeft<B>(z: B): (op: (b: B, a: T) => B) => B\n  foldRight<B>(z: B): (op: (a: T, b: B) => B) => B\n}\n\n// Example implementation\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  return Base(\"Option\", {\n    fold: <B>(onEmpty: () => B, onValue: (val: T) => B): B => {\n      return value == null ? onEmpty() : onValue(value)\n    },\n    foldLeft:\n      <B>(z: B) =>\n      (op: (b: B, a: T) => B): B => {\n        return value == null ? z : op(z, value)\n      },\n    foldRight:\n      <B>(z: B) =>\n      (op: (a: T, b: B) => B): B => {\n        return value == null ? z : op(value, z)\n      },\n  })\n}\n```\n\n### Traversable\n\nCollections with size, iteration, and reduction:\n\n```typescript\nexport interface Traversable<T> {\n  size: number\n  isEmpty: boolean\n  contains(value: T): boolean\n  reduce<B>(f: (acc: B, value: T) => B, initial: B): B\n  reduceRight<B>(f: (value: T, acc: B) => B, initial: B): B\n}\n\n// Example implementation\nexport function List<T>(items: T[]): ListType<T> {\n  return Base(\"List\", {\n    size: items.length,\n    isEmpty: items.length === 0,\n    contains: (value: T) => items.includes(value),\n    reduce: <B>(f: (acc: B, val: T) => B, initial: B): B => {\n      return items.reduce(f, initial)\n    },\n    reduceRight: <B>(f: (val: T, acc: B) => B, initial: B): B => {\n      return items.reduceRight((acc, val) => f(val, acc), initial)\n    },\n  })\n}\n```\n\n### Serializable\n\nJSON/YAML/binary serialization:\n\n```typescript\nexport interface Serializable {\n  serialize(): SerializationMethods<T>\n}\n\nexport interface SerializationMethods<T> {\n  toJSON(): string\n  toYAML(): string\n  toBinary(): Uint8Array\n}\n\n// Example implementation\nimport { createSerializable } from \"@/core/serializable\"\n\nexport function Option<T>(value: T | null | undefined): OptionType<T> {\n  return Base(\"Option\", {\n    serialize: () =>\n      createSerializable({\n        type: \"Option\",\n        value: value,\n      }),\n  })\n}\n```\n\n## Module Organization\n\n### Directory Structure\n\n```\nsrc/\n├── core/           # Base patterns and utilities\n│   ├── base.ts\n│   ├── companion.ts\n│   └── serializable.ts\n├── functor/        # Functor type class\n├── monad/          # Monad type class\n├── option/         # Option type\n│   └── index.ts\n├── either/         # Either type\n│   └── index.ts\n└── index.ts        # Main exports\n\ntest/\n├── option.spec.ts\n├── either.spec.ts\n└── ...\n```\n\n### Index Exports\n\nEach module has an `index.ts` that re-exports its main type:\n\n```typescript\n// src/option/index.ts\nexport { Option } from \"./option\"\nexport type { OptionType } from \"./option\"\n```\n\nMain index re-exports everything:\n\n```typescript\n// src/index.ts\nexport { Option } from \"./option\"\nexport type { OptionType } from \"./option\"\nexport { Either, Left, Right } from \"./either\"\nexport type { EitherType } from \"./either\"\n// ...\n```\n\n### Package Exports\n\n`package.json` supports selective imports:\n\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/esm/index.js\",\n      \"require\": \"./dist/cjs/index.js\",\n      \"types\": \"./dist/types/index.d.ts\"\n    },\n    \"./option\": {\n      \"import\": \"./dist/esm/option/index.js\",\n      \"require\": \"./dist/cjs/option/index.js\",\n      \"types\": \"./dist/types/option/index.d.ts\"\n    }\n  }\n}\n```\n\n**Usage:**\n\n```typescript\n// Import from main bundle\nimport { Option, Either } from \"functype\"\n```\n\n## Performance Considerations\n\n### Tree-Shaking\n\nFunctype is optimized for tree-shaking:\n\n```json\n{\n  \"sideEffects\": false\n}\n```\n\nThis means unused exports are eliminated during bundling.\n\n### Lazy Evaluation\n\nUse `Lazy` and `LazyList` for deferred computation:\n\n```typescript\nimport { Lazy } from \"functype\"\n\nconst expensive = Lazy(() => heavyComputation())\n// Not computed yet\n\nconst value = expensive.value() // Computed once\nconst value2 = expensive.value() // Cached\n```\n\n### Immutability Cost\n\nImmutable operations have overhead. For performance-critical code:\n\n```typescript\n// ❌ Slow for large lists\nlet result = List([])\nfor (let i = 0; i < 10000; i++) {\n  result = result.append(i) // Creates new list each time\n}\n\n// ✅ Fast with native array, then convert\nconst items = []\nfor (let i = 0; i < 10000; i++) {\n  items.push(i)\n}\nconst result = List(items) // Single conversion\n```\n\n## Error Handling\n\n### Error Patterns\n\n```typescript\n// ✅ Use Option for nullable values\nOption(value).orElse(default)\n\n// ✅ Use Either for errors with context\nvalidateEmail(email)\n  .fold(\n    error => console.error(error),\n    validEmail => send(validEmail)\n  )\n\n// ✅ Use Try for exceptions\nTry(() => JSON.parse(str))\n  .recover(error => defaultValue)\n\n// ✅ Use Throwable for unexpected errors\nthrow new Throwable(\"Unexpected error\", { context })\n```\n\n### ErrorFormatter\n\nUse for structured error output:\n\n```typescript\nimport { ErrorFormatter } from \"@/core/error\"\n\nconst error = new Error(\"Something went wrong\")\nconst formatted = ErrorFormatter.format(error)\n\nconsole.error(formatted.toString())\n// Error: Something went wrong\n//   at myFunction (file.ts:10:5)\n//   ...\n```\n\n## Testing Architecture\n\n### Test Organization\n\n```\ntest/\n├── option.spec.ts          # Option tests\n├── either.spec.ts          # Either tests\n├── integration/            # Integration tests\n│   └── composition.spec.ts\n└── property/               # Property-based tests\n    └── functor.spec.ts\n```\n\n### Test Patterns\n\n```typescript\ndescribe(\"Option\", () => {\n  describe(\"Construction\", () => {\n    it(\"should create Some from non-null value\", () => {\n      const opt = Option(5)\n      expect(opt.isSome()).toBe(true)\n    })\n  })\n\n  describe(\"Functor Laws\", () => {\n    it(\"should satisfy identity\", () => {\n      const opt = Option(5)\n      expect(opt.map((x) => x)).toEqual(opt)\n    })\n  })\n})\n```\n",
        ".claude/skills/functype-developer/references/testing-patterns.md": "# Testing Patterns\n\nComprehensive testing strategies for functype development.\n\n## Test Structure\n\n### Standard Pattern\n\n```typescript\nimport { describe, expect, it } from \"vitest\"\nimport { MyType } from \"@/mytype\"\n\ndescribe(\"MyType\", () => {\n  describe(\"Construction\", () => {\n    it(\"should create from value\", () => {\n      // Arrange\n      const value = 5\n\n      // Act\n      const result = MyType(value)\n\n      // Assert\n      expect(result.getValue()).toBe(5)\n    })\n  })\n\n  describe(\"Interface Implementation\", () => {\n    // Group tests by interface\n  })\n\n  describe(\"Custom Methods\", () => {\n    // Test type-specific methods\n  })\n\n  describe(\"Edge Cases\", () => {\n    // Test null, undefined, empty\n  })\n})\n```\n\n## Testing Functional Interfaces\n\n### Functor Laws\n\n```typescript\ndescribe(\"Functor Laws\", () => {\n  it(\"should satisfy identity law\", () => {\n    const fa = MyType(5)\n    const identity = (x: any) => x\n\n    expect(fa.map(identity)).toEqual(fa)\n  })\n\n  it(\"should satisfy composition law\", () => {\n    const fa = MyType(5)\n    const f = (x: number) => x * 2\n    const g = (x: number) => x + 1\n\n    const left = fa.map(f).map(g)\n    const right = fa.map((x) => g(f(x)))\n\n    expect(left).toEqual(right)\n  })\n})\n```\n\n### Monad Laws\n\n```typescript\ndescribe(\"Monad Laws\", () => {\n  it(\"should satisfy left identity\", () => {\n    const a = 5\n    const f = (x: number) => MyType(x * 2)\n\n    expect(MyType(a).flatMap(f)).toEqual(f(a))\n  })\n\n  it(\"should satisfy right identity\", () => {\n    const m = MyType(5)\n\n    expect(m.flatMap((x) => MyType(x))).toEqual(m)\n  })\n\n  it(\"should satisfy associativity\", () => {\n    const m = MyType(5)\n    const f = (x: number) => MyType(x * 2)\n    const g = (x: number) => MyType(x + 1)\n\n    const left = m.flatMap(f).flatMap(g)\n    const right = m.flatMap((x) => f(x).flatMap(g))\n\n    expect(left).toEqual(right)\n  })\n})\n```\n\n### Applicative Laws\n\n```typescript\ndescribe(\"Applicative Laws\", () => {\n  it(\"should satisfy identity\", () => {\n    const v = MyType(5)\n    const pure = MyType((x: number) => x)\n\n    expect(v.ap(pure)).toEqual(v)\n  })\n\n  it(\"should satisfy homomorphism\", () => {\n    const f = (x: number) => x * 2\n    const x = 5\n\n    const left = MyType(x).ap(MyType(f))\n    const right = MyType(f(x))\n\n    expect(left).toEqual(right)\n  })\n})\n```\n\n## Property-Based Testing\n\n### Using fast-check\n\n```typescript\nimport { fc, test } from \"@fast-check/vitest\"\n\ntest.prop([fc.integer()])(\"map preserves structure\", (n) => {\n  const opt = Option(n)\n  const result = opt.map((x) => x * 2)\n\n  if (opt.isSome()) {\n    expect(result.isSome()).toBe(true)\n  } else {\n    expect(result.isNone()).toBe(true)\n  }\n})\n\ntest.prop([fc.integer(), fc.integer()])(\"flatMap is associative\", (a, b) => {\n  const m = List([a, b])\n  const f = (x: number) => List([x, x * 2])\n  const g = (x: number) => List([x + 1])\n\n  const left = m.flatMap(f).flatMap(g)\n  const right = m.flatMap((x) => f(x).flatMap(g))\n\n  expect(left.toArray()).toEqual(right.toArray())\n})\n```\n\n### Custom Arbitraries\n\n```typescript\nimport { fc } from \"@fast-check/vitest\"\n\n// Generate Options\nconst optionArb = <T>(valueArb: fc.Arbitrary<T>): fc.Arbitrary<Option<T>> =>\n  fc.oneof(\n    fc.constant(Option.none()),\n    valueArb.map((v) => Option(v)),\n  )\n\n// Generate Lists\nconst listArb = <T>(valueArb: fc.Arbitrary<T>): fc.Arbitrary<List<T>> => fc.array(valueArb).map((arr) => List(arr))\n\n// Usage\ntest.prop([optionArb(fc.integer())])(\"option property\", (opt) => {\n  // Test with generated Options\n})\n```\n\n## Edge Case Testing\n\n### Null/Undefined\n\n```typescript\ndescribe(\"Edge Cases\", () => {\n  it(\"should handle null\", () => {\n    const value = Option(null)\n    expect(value.isNone()).toBe(true)\n  })\n\n  it(\"should handle undefined\", () => {\n    const value = Option(undefined)\n    expect(value.isNone()).toBe(true)\n  })\n\n  it(\"should handle zero\", () => {\n    const value = Option(0)\n    expect(value.isSome()).toBe(true)\n  })\n\n  it(\"should handle empty string\", () => {\n    const value = Option(\"\")\n    expect(value.isSome()).toBe(true)\n  })\n})\n```\n\n### Type Inference\n\n```typescript\ndescribe(\"Type Inference\", () => {\n  it(\"should infer correct types\", () => {\n    const num: Option<number> = Option(5)\n    const str: Option<string> = num.map((x) => x.toString())\n\n    // TypeScript should not error\n    const _check: string = str.orElse(\"\")\n  })\n})\n```\n\n### Immutability\n\n```typescript\ndescribe(\"Immutability\", () => {\n  it(\"should not mutate original\", () => {\n    const original = List([1, 2, 3])\n    const modified = original.append(4)\n\n    expect(original.toArray()).toEqual([1, 2, 3])\n    expect(modified.toArray()).toEqual([1, 2, 3, 4])\n  })\n})\n```\n\n## Integration Testing\n\n### Type Composition\n\n```typescript\ndescribe(\"Type Composition\", () => {\n  it(\"should compose Option and Either\", () => {\n    const validate = (x: number): Either<string, number> => (x > 0 ? Right(x) : Left(\"Must be positive\"))\n\n    const result = Option(5)\n      .map(validate)\n      .fold(\n        () => Left(\"No value\"),\n        (either) => either,\n      )\n\n    expect(result.isRight()).toBe(true)\n  })\n})\n```\n\n### Pipeline Testing\n\n```typescript\ndescribe(\"Pipelines\", () => {\n  it(\"should compose operations\", () => {\n    const result = List([1, 2, 3, 4, 5])\n      .filter((x) => x > 2)\n      .map((x) => x * 2)\n      .foldLeft(0)((sum, x) => sum + x)\n\n    expect(result).toBe(24) // (3 + 4 + 5) * 2 = 24\n  })\n})\n```\n\n## Performance Testing\n\n### Benchmarks\n\n```typescript\nimport { bench, describe } from \"vitest\"\n\ndescribe(\"Performance\", () => {\n  bench(\"Option creation\", () => {\n    for (let i = 0; i < 1000; i++) {\n      Option(i)\n    }\n  })\n\n  bench(\"List operations\", () => {\n    const list = List(Array.from({ length: 1000 }, (_, i) => i))\n    list.filter((x) => x % 2 === 0).map((x) => x * 2)\n  })\n})\n```\n\n## Test Organization\n\n### File Structure\n\n```\ntest/\n├── option.spec.ts              # Option tests\n├── either.spec.ts              # Either tests\n├── list.spec.ts                # List tests\n├── integration/                # Integration tests\n│   ├── composition.spec.ts\n│   └── pipelines.spec.ts\n└── property/                   # Property-based tests\n    ├── functor-laws.spec.ts\n    └── monad-laws.spec.ts\n```\n\n### Naming Conventions\n\n```typescript\n// ✅ Good test names\nit(\"should create Some from non-null value\")\nit(\"should return None when mapping over None\")\nit(\"should satisfy functor identity law\")\n\n// ❌ Poor test names\nit(\"works\")\nit(\"test1\")\nit(\"should work correctly\")\n```\n\n## Coverage\n\n### Running Coverage\n\n```bash\npnpm test:coverage\n```\n\n### Coverage Goals\n\n- **Line coverage**: >90%\n- **Branch coverage**: >85%\n- **Function coverage**: >90%\n\n### Uncovered Code\n\nSome code is intentionally not covered:\n\n- Error handling for impossible states\n- Debug utilities\n- Deprecated code\n\nMark with comments:\n\n```typescript\n/* istanbul ignore next */\nif (impossibleCondition) {\n  throw new Error(\"This should never happen\")\n}\n```\n\n## Continuous Testing\n\n### Watch Mode\n\n```bash\npnpm test:watch\n```\n\n### Pre-commit Hook\n\n```bash\n# .git/hooks/pre-commit\n#!/bin/sh\npnpm test || exit 1\n```\n\n## Debugging Tests\n\n### Verbose Output\n\n```bash\npnpm vitest run test/mytype.spec.ts --reporter=verbose\n```\n\n### Focused Tests\n\n```typescript\n// Run only this test\nit.only(\"should do something\", () => {\n  // ...\n})\n\n// Skip this test\nit.skip(\"should do something else\", () => {\n  // ...\n})\n```\n\n### Test Timeout\n\n```typescript\nit(\n  \"should handle slow operation\",\n  async () => {\n    // ...\n  },\n  { timeout: 10000 },\n) // 10 second timeout\n```\n",
        ".claude/skills/functype/SKILL.md": "---\nname: functype\ndescription: Help developers use functype functional programming patterns in their TypeScript projects. Use this skill when converting imperative/OOP code to functional patterns, looking up functype APIs and methods, handling nulls with Option, managing errors with Either/Try, or working with immutable collections like List and Set.\n---\n\n# Functype User Guide\n\n## Overview\n\nTransform TypeScript code to use functype - a Scala-inspired functional programming library providing type-safe alternatives to null checks, exceptions, and imperative patterns. This skill helps integrate Option, Either, Try, List, and other functional types into projects.\n\n## When to Use This Skill\n\nTrigger this skill when users:\n\n- Convert imperative code to functional patterns\n- Look up functype APIs or methods\n- Handle nullable values or optional chaining\n- Replace try-catch with functional error handling\n- Work with immutable collections\n- Debug functype code or understand error messages\n\n## Quick Start\n\n### Installation\n\n```bash\nnpm install functype\n# or\npnpm add functype\n```\n\n### Core Imports\n\n```typescript\n// Import from main bundle\nimport { Option, Either, Left, Right, Try, List } from \"functype\"\n```\n\n## Constructor vs Companion Methods\n\nFunctype collections provide multiple ways to create instances:\n\n| Method         | Use When                     | Example                |\n| -------------- | ---------------------------- | ---------------------- |\n| `List([...])`  | Creating from existing array | `List(existingArray)`  |\n| `List.of(...)` | Inline literal values        | `List.of(1, 2, 3)`     |\n| `List.empty()` | Empty collections (typed)    | `List.empty<number>()` |\n\n### Decision Guide\n\n**Use Constructor `List([...])` when:**\n\n- Converting existing arrays: `List(data.items)`\n- Spreading iterables: `List([...set])`\n- Variables holding arrays: `List(myArray)`\n\n**Use `List.of(...)` when:**\n\n- Inline literal values: `List.of(1, 2, 3)`\n- Cleaner for small fixed lists: `List.of(\"a\", \"b\", \"c\")`\n- No need to wrap in array brackets\n\n**Use `List.empty()` when:**\n\n- Starting with empty collection: `List.empty<User>()`\n- Type parameter needed but no initial values\n- Returns singleton (efficient for repeated calls)\n\n### Examples\n\n```typescript\n// Constructor - wrapping existing data\nconst users = List(fetchedUsers)\nconst items = List([...existingSet])\n\n// .of() - inline literals\nconst colors = List.of(\"red\", \"green\", \"blue\")\nconst primes = Set.of(2, 3, 5, 7, 11)\n\n// .empty() - typed empty collections\nconst errors = List.empty<string>()\nconst cache = Map.empty<string, User>()\n```\n\n## Pattern Conversion Guide\n\n### Null/Undefined Checks → Option\n\n**Before (Imperative):**\n\n```typescript\nif (value !== null && value !== undefined) {\n  return value.toUpperCase()\n}\nreturn \"\"\n```\n\n**After (Functype):**\n\n```typescript\nOption(value)\n  .map((v) => v.toUpperCase())\n  .orElse(\"\")\n```\n\n### Optional Chaining → Option Chain\n\n**Before:**\n\n```typescript\nconst url = user?.profile?.avatar?.url\n```\n\n**After:**\n\n```typescript\nconst url = Option(user)\n  .flatMap((u) => Option(u.profile))\n  .flatMap((p) => Option(p.avatar))\n  .map((a) => a.url)\n  .orElse(\"/default-avatar.png\")\n```\n\n### Try-Catch → Try or Either\n\n**Before:**\n\n```typescript\ntry {\n  return JSON.parse(str)\n} catch (e) {\n  return null\n}\n```\n\n**After (with Try):**\n\n```typescript\nTry(() => JSON.parse(str))\n  .toOption()\n  .orElse(null)\n```\n\n**After (with Either):**\n\n```typescript\nTry(() => JSON.parse(str))\n  .toEither()\n  .fold(\n    (error) => `Parse failed: ${error.message}`,\n    (data) => data,\n  )\n```\n\n### Array Operations → List\n\n**Before:**\n\n```typescript\narray.filter((x) => x > 0).map((x) => x * 2)\n```\n\n**After:**\n\n```typescript\nList(array)\n  .filter((x) => x > 0)\n  .map((x) => x * 2)\n  .toArray()\n```\n\n### If-Else Chains → Cond\n\n**Before:**\n\n```typescript\nif (x > 10) {\n  return \"big\"\n} else if (x > 5) {\n  return \"medium\"\n} else {\n  return \"small\"\n}\n```\n\n**After:**\n\n```typescript\nimport { Cond } from \"functype\"\n\nCond.start<string>()\n  .case(x > 10, \"big\")\n  .case(x > 5, \"medium\")\n  .otherwise(\"small\")\n```\n\n### Switch Statements → Match\n\n**Before:**\n\n```typescript\nswitch (status) {\n  case \"success\":\n    return data\n  case \"error\":\n    return null\n  default:\n    return undefined\n}\n```\n\n**After:**\n\n```typescript\nimport { Match } from \"functype\"\n\nMatch(status)\n  .case(\"success\", () => data)\n  .case(\"error\", () => null)\n  .done()\n```\n\n## Common Use Cases\n\n### Validation with Either\n\n```typescript\nimport { Either, Left, Right } from \"functype\"\n\nfunction validateEmail(email: string): Either<string, string> {\n  return email.includes(\"@\") ? Right(email) : Left(\"Invalid email format\")\n}\n\nfunction validateUser(user: any): Either<string, User> {\n  return validateEmail(user.email)\n    .map((email) => ({ ...user, email }))\n    .flatMap((u) => (u.age >= 18 ? Right(u) : Left(\"Must be 18 or older\")))\n}\n\nconst result = validateUser({ email: \"test@example.com\", age: 20 }).fold(\n  (error) => console.error(error),\n  (user) => console.log(\"Valid user:\", user),\n)\n```\n\n### Safe API Calls with Option\n\n```typescript\nimport { Option } from \"functype\"\n\ninterface User {\n  id: string\n  name: string\n  email?: string\n}\n\nfunction getUserEmail(userId: string): Option<string> {\n  return Option(fetchUser(userId))\n    .flatMap((user) => Option(user.email))\n    .filter((email) => email.includes(\"@\"))\n}\n\nconst email = getUserEmail(\"123\").orElse(\"no-reply@example.com\")\n```\n\n### Error Recovery with Try\n\n```typescript\nimport { Try } from \"functype\"\n\nconst parseConfig = Try(() => JSON.parse(configStr))\n  .recover((error) => {\n    console.warn(\"Using default config:\", error)\n    return defaultConfig\n  })\n  .map((config) => validateConfig(config))\n```\n\n### Collection Pipeline with List\n\n```typescript\nimport { List } from \"functype\"\n\nconst users = List([\n  { name: \"Alice\", hobbies: [\"reading\", \"coding\"] },\n  { name: \"Bob\", hobbies: [\"gaming\", \"music\"] },\n])\n\nconst allHobbies = users\n  .flatMap((user) => List(user.hobbies))\n  .toSet() // Remove duplicates\n  .toArray()\n```\n\n## Looking Up Functype APIs\n\n### Feature Matrix Reference\n\nFor a complete overview of which methods are available on each data structure, consult the **Feature Matrix** at:\n\n- `references/feature-matrix.md` (included with this skill)\n- Or in the functype repo: `docs/FUNCTYPE_FEATURE_MATRIX.md`\n\nThe matrix shows which interfaces (Functor, Monad, Foldable, etc.) each type implements and what methods are available.\n\n### Common Methods by Type\n\n**Option<T>**\n\n- `map`, `flatMap`, `filter`, `fold`\n- `orElse`, `or`, `orNull`, `orUndefined`, `orThrow`\n- `isSome`, `isNone`, `contains`\n\n**Either<L, R>**\n\n- `map`, `flatMap`, `fold`\n- `orElse`, `or`, `swap`\n- `isLeft`, `isRight`\n\n**Try<T>**\n\n- `map`, `flatMap`, `fold`\n- `recover`, `recoverWith`\n- `toOption`, `toEither`\n- `isSuccess`, `isFailure`\n\n**List<A>**\n\n- `map`, `flatMap`, `filter`, `reduce`\n- `foldLeft`, `foldRight`\n- `append`, `prepend`, `concat`\n- `head`, `tail`, `isEmpty`\n- `toArray`, `toSet`\n\n## Additional Resources\n\nFor pattern conversion help, examples, and API reference:\n\n- **Feature Matrix**: See `references/feature-matrix.md` for complete interface/method reference\n- **API Documentation**: https://jordanburke.github.io/functype/\n- **GitHub Repository**: https://github.com/jordanburke/functype\n- **CLI Documentation**: Run `npx functype` for LLM-optimized API reference\n\n## Debugging Tips\n\n### Understanding Error Messages\n\n**\"Type 'X' is not assignable to type 'Y'\"**\n\n- Ensure proper type parameters: `Option<string>` not `Option<any>`\n- Check that chains maintain type consistency\n\n**\"Cannot read property 'map' of undefined\"**\n\n- Remember to construct the type: `Option(value)` not just `value`\n- Some types require explicit constructors: `List([...])`, `Right(value)`\n\n### Common Pitfalls\n\n1. **Forgetting to extract values**\n\n   ```typescript\n   // Wrong - returns Option<string>\n   const name = Option(user).map((u) => u.name)\n\n   // Correct - returns string\n   const name = Option(user)\n     .map((u) => u.name)\n     .orElse(\"Unknown\")\n   ```\n\n2. **Using map instead of flatMap**\n\n   ```typescript\n   // Wrong - returns Option<Option<string>>\n   Option(user).map((u) => Option(u.email))\n\n   // Correct - returns Option<string>\n   Option(user).flatMap((u) => Option(u.email))\n   ```\n\n3. **Mutating instead of transforming**\n\n   ```typescript\n   // Wrong - mutates original array\n   const list = List([1, 2, 3])\n   list.toArray().push(4)\n\n   // Correct - creates new List\n   const newList = list.append(4)\n   ```\n\n## Resources\n\n### references/\n\n- `feature-matrix.md` - Complete interface and method reference\n- `common-patterns.md` - Additional pattern examples and recipes\n- `quick-reference.md` - Cheat sheet for functype APIs\n\nFor more examples and detailed documentation, visit:\n\n- **GitHub**: https://github.com/jordanburke/functype\n- **Docs**: https://jordanburke.github.io/functype/\n",
        ".claude/skills/functype/references/common-patterns.md": "# Common Functype Patterns\n\nThis document provides additional pattern examples and recipes for using functype in real-world scenarios.\n\n## Null Safety Patterns\n\n### Nested Optional Properties\n\n```typescript\nimport { Option } from \"functype\"\n\ninterface User {\n  profile?: {\n    settings?: {\n      theme?: string\n    }\n  }\n}\n\n// Instead of: user?.profile?.settings?.theme ?? 'light'\nconst theme = Option(user)\n  .flatMap((u) => Option(u.profile))\n  .flatMap((p) => Option(p.settings))\n  .flatMap((s) => Option(s.theme))\n  .orElse(\"light\")\n```\n\n### Optional Function Calls\n\n```typescript\nimport { Option } from \"functype\"\n\n// Instead of: callback?.()\nOption(callback).map((fn) => fn())\n\n// With arguments\nOption(callback).map((fn) => fn(arg1, arg2))\n```\n\n### Conditional Value Assignment\n\n```typescript\nimport { Option } from \"functype\"\n\n// Instead of: const value = condition ? compute() : null\nconst value = Option(condition ? compute() : null).orElse(defaultValue)\n\n// Or using filter\nconst value = Option(compute())\n  .filter(() => condition)\n  .orElse(defaultValue)\n```\n\n## Error Handling Patterns\n\n### Validation Chains\n\n```typescript\nimport { Either, Left, Right } from \"functype\"\n\ntype ValidationError = string\ntype User = { email: string; age: number; username: string }\n\nconst validateEmail = (email: string): Either<ValidationError, string> =>\n  email.includes(\"@\") && email.includes(\".\") ? Right(email) : Left(\"Invalid email format\")\n\nconst validateAge = (age: number): Either<ValidationError, number> =>\n  age >= 18 ? Right(age) : Left(\"Must be 18 or older\")\n\nconst validateUsername = (username: string): Either<ValidationError, string> =>\n  username.length >= 3 ? Right(username) : Left(\"Username must be at least 3 characters\")\n\nfunction createUser(email: string, age: number, username: string): Either<ValidationError, User> {\n  return validateEmail(email).flatMap((validEmail) =>\n    validateAge(age).flatMap((validAge) =>\n      validateUsername(username).map((validUsername) => ({\n        email: validEmail,\n        age: validAge,\n        username: validUsername,\n      })),\n    ),\n  )\n}\n\n// Usage\nconst result = createUser(\"test@example.com\", 25, \"alice\").fold(\n  (error) => console.error(\"Validation failed:\", error),\n  (user) => console.log(\"User created:\", user),\n)\n```\n\n### Multiple Error Types\n\n```typescript\nimport { Either, Left, Right } from \"functype\"\n\ntype NetworkError = { type: \"network\"; message: string }\ntype ParseError = { type: \"parse\"; details: string }\ntype ValidationError = { type: \"validation\"; field: string }\n\ntype AppError = NetworkError | ParseError | ValidationError\n\nfunction fetchAndValidate(url: string): Either<AppError, Data> {\n  return fetchData(url)\n    .mapLeft<AppError>((msg) => ({ type: \"network\", message: msg }))\n    .flatMap(parseData)\n    .flatMap(validateData)\n}\n```\n\n### Retry Logic with Try\n\n```typescript\nimport { Try } from \"functype\"\nimport { Option } from \"functype\"\n\nfunction retryOperation<T>(operation: () => T, maxAttempts: number = 3): Try<T> {\n  let lastError: Error | undefined\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    const result = Try(operation)\n\n    if (result.isSuccess()) {\n      return result\n    }\n\n    lastError = result.fold(\n      (error) => error,\n      () => new Error(\"Unknown error\"),\n    )\n  }\n\n  return Try(() => {\n    throw lastError ?? new Error(\"All retry attempts failed\")\n  })\n}\n\n// Usage\nconst data = retryOperation(() => fetchFromAPI(), 3).recover((error) => {\n  console.error(\"Failed after retries:\", error)\n  return cachedData\n})\n```\n\n## Collection Patterns\n\n### GroupBy Implementation\n\n```typescript\nimport { List } from \"functype\"\n\ninterface Item {\n  category: string\n  name: string\n}\n\nconst items: Item[] = [\n  { category: \"fruit\", name: \"apple\" },\n  { category: \"fruit\", name: \"banana\" },\n  { category: \"vegetable\", name: \"carrot\" },\n]\n\nconst grouped = List(items).foldLeft(new Map<string, Item[]>())((acc, item) => {\n  const existing = acc.get(item.category) ?? []\n  return new Map(acc).set(item.category, [...existing, item])\n})\n```\n\n### Partition by Predicate\n\n```typescript\nimport { List } from \"functype\"\n\nconst numbers = List([1, 2, 3, 4, 5, 6])\n\nconst [evens, odds] = numbers\n  .toArray()\n  .reduce(([e, o], n) => (n % 2 === 0 ? [[...e, n], o] : [e, [...o, n]]), [[] as number[], [] as number[]])\n\n// Or using filter\nconst evens = numbers.filter((n) => n % 2 === 0)\nconst odds = numbers.filter((n) => n % 2 !== 0)\n```\n\n### Safe Head/Tail Operations\n\n```typescript\nimport { List } from \"functype\"\nimport { Option } from \"functype\"\n\nconst list = List([1, 2, 3, 4, 5])\n\n// Safe head (first element)\nconst first = list\n  .headOption() // Option<number>\n  .orElse(0)\n\n// Safe operations on tail\nconst restSum = list.tail().foldLeft(0)((sum, n) => sum + n)\n```\n\n## Async Patterns\n\n### Promise to Either\n\n```typescript\nimport { Either, Left, Right } from \"functype\"\n\nasync function fetchUserSafe(id: string): Promise<Either<Error, User>> {\n  try {\n    const response = await fetch(`/api/users/${id}`)\n    const data = await response.json()\n    return Right(data)\n  } catch (error) {\n    return Left(error as Error)\n  }\n}\n\n// Usage\nconst result = await fetchUserSafe(\"123\")\nresult.fold(\n  (error) => console.error(\"Failed to fetch user:\", error),\n  (user) => console.log(\"User:\", user),\n)\n```\n\n### Sequential Async Operations\n\n```typescript\nimport { List } from \"functype\"\n\nasync function processInSequence<T, R>(items: T[], process: (item: T) => Promise<R>): Promise<R[]> {\n  const results: R[] = []\n\n  for (const item of items) {\n    const result = await process(item)\n    results.push(result)\n  }\n\n  return results\n}\n\n// Usage with functype\nconst userIds = List([\"1\", \"2\", \"3\"])\nconst users = await processInSequence(userIds.toArray(), async (id) => fetchUser(id))\n```\n\n## Combining Types\n\n### Option with Either\n\n```typescript\nimport { Option } from \"functype\"\nimport { Either, Left, Right } from \"functype\"\n\n// Convert Option to Either\nconst optionValue: Option<string> = Option(\"hello\")\nconst eitherValue: Either<string, string> = optionValue.fold(\n  () => Left(\"Value not found\"),\n  (value) => Right(value),\n)\n\n// Or using helper\nfunction optionToEither<E, T>(option: Option<T>, errorValue: E): Either<E, T> {\n  return option.fold(\n    () => Left(errorValue),\n    (value) => Right(value),\n  )\n}\n```\n\n### Try to Option\n\n```typescript\nimport { Try } from \"functype\"\nimport { Option } from \"functype\"\n\nconst result = Try(() => JSON.parse(jsonString))\n  .toOption() // Built-in conversion\n  .orElse(defaultObject)\n```\n\n## Performance Patterns\n\n### Lazy Evaluation\n\n```typescript\nimport { Lazy } from \"functype\"\n\n// Expensive computation only runs when needed\nconst expensive = Lazy(() => {\n  console.log(\"Computing...\")\n  return heavyComputation()\n})\n\n// Not computed yet...\nconsole.log(\"Before access\")\n\n// Now it computes (only once)\nconst value1 = expensive.value()\nconst value2 = expensive.value() // Uses cached value\n```\n\n### LazyList for Large Datasets\n\n```typescript\nimport { LazyList } from \"functype\"\n\n// Infinite sequence\nconst naturals = LazyList.from(0, (n) => n + 1)\n\n// Only computes what's needed\nconst firstTenEvens = naturals\n  .filter((n) => n % 2 === 0)\n  .take(10)\n  .toArray() // [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n```\n\n## Builder Patterns\n\n### Fluent Configuration\n\n```typescript\nimport { Option } from \"functype\"\n\nclass QueryBuilder {\n  private _select: string[] = []\n  private _where: string[] = []\n  private _limit?: number\n\n  select(...fields: string[]): this {\n    this._select.push(...fields)\n    return this\n  }\n\n  where(condition: string): this {\n    this._where.push(condition)\n    return this\n  }\n\n  limit(n: number): this {\n    this._limit = n\n    return this\n  }\n\n  build(): string {\n    const select = `SELECT ${this._select.join(\", \")}`\n    const where = this._where.length > 0 ? ` WHERE ${this._where.join(\" AND \")}` : \"\"\n    const limit = Option(this._limit)\n      .map((n) => ` LIMIT ${n}`)\n      .orElse(\"\")\n\n    return select + where + limit\n  }\n}\n\n// Usage\nconst query = new QueryBuilder().select(\"id\", \"name\", \"email\").where(\"active = true\").limit(10).build()\n```\n\n## Type Refinement\n\n### Branded Types with ValidatedBrand\n\n```typescript\nimport { ValidatedBrand, Either, Left, Right } from \"functype\"\n\n// Create branded types with validation\ntype Email = ValidatedBrand<string, \"Email\">\n\nconst Email = ValidatedBrand<string, \"Email\">(\n  (value): Either<string, string> => (value.includes(\"@\") ? Right(value) : Left(\"Invalid email format\")),\n)\n\n// Usage\nconst email = Email.from(\"test@example.com\").fold(\n  (error) => console.error(error),\n  (validEmail) => sendEmail(validEmail), // Type is Email, not string\n)\n```\n",
        ".claude/skills/functype/references/feature-matrix.md": "../../../../docs/FUNCTYPE_FEATURE_MATRIX.md",
        ".claude/skills/functype/references/quick-reference.md": "# Functype Quick Reference\n\nQuick lookup guide for common functype operations.\n\n## Construction\n\n| Type   | Constructor                               | Example                                         |\n| ------ | ----------------------------------------- | ----------------------------------------------- |\n| Option | `Option(value)`                           | `Option(\"hello\")`, `Option.none()`              |\n| Either | `Right(value)` or `Left(error)`           | `Right(42)`, `Left(\"error\")`                    |\n| Try    | `Try(() => expression)`                   | `Try(() => JSON.parse(str))`                    |\n| List   | `List(array)`, `.of()`, `.empty()`        | `List([1, 2])`, `List.of(1, 2)`, `List.empty()` |\n| Set    | `Set(array)`, `.of()`, `.empty()`         | `Set([1, 2])`, `Set.of(1, 2)`, `Set.empty()`    |\n| Map    | `Map([[k, v], ...])`, `.of()`, `.empty()` | `Map.of([\"a\", 1])`, `Map.empty()`               |\n| Lazy   | `Lazy(() => expression)`                  | `Lazy(() => expensiveComputation())`            |\n\n**Note**: Collections support multiple creation styles:\n\n- **Constructor `List([...])`**: Use for existing arrays/iterables\n- **`.of(...)`**: Use for inline literal values (cleaner syntax)\n- **`.empty()`**: Use for typed empty collections (returns singleton - efficient for repeated calls)\n\n## Transformation\n\n| Operation           | Method              | Example                                      |\n| ------------------- | ------------------- | -------------------------------------------- |\n| Transform value     | `map(fn)`           | `Option(5).map(x => x * 2)`                  |\n| Flatten nested      | `flatMap(fn)`       | `Option(user).flatMap(u => Option(u.email))` |\n| Filter by condition | `filter(predicate)` | `Option(value).filter(x => x > 0)`           |\n| Combine values      | `ap(wrappedFn)`     | `Option(5).ap(Option(x => x * 2))`           |\n\n## Extraction\n\n| Operation        | Method                   | Example                        | Returns          |\n| ---------------- | ------------------------ | ------------------------------ | ---------------- |\n| With default     | `orElse(default)`        | `option.orElse(\"N/A\")`         | `T`              |\n| With alternative | `or(alternative)`        | `option.or(Option(\"alt\"))`     | `Option<T>`      |\n| Or throw         | `orThrow(error?)`        | `option.orThrow()`             | `T` or throws    |\n| Or null          | `orNull()`               | `option.orNull()`              | `T \\| null`      |\n| Or undefined     | `orUndefined()`          | `option.orUndefined()`         | `T \\| undefined` |\n| Pattern match    | `fold(onEmpty, onValue)` | `option.fold(() => 0, x => x)` | `R`              |\n\n## Predicates\n\n| Check               | Method            | Returns   |\n| ------------------- | ----------------- | --------- |\n| Has value (Option)  | `isSome()`        | `boolean` |\n| Is empty (Option)   | `isNone()`        | `boolean` |\n| Is success (Either) | `isRight()`       | `boolean` |\n| Is error (Either)   | `isLeft()`        | `boolean` |\n| Is success (Try)    | `isSuccess()`     | `boolean` |\n| Is failure (Try)    | `isFailure()`     | `boolean` |\n| Contains value      | `contains(value)` | `boolean` |\n| Is empty (List)     | `isEmpty()`       | `boolean` |\n\n## Collection Operations\n\n| Operation       | Method                | Example                                  |\n| --------------- | --------------------- | ---------------------------------------- |\n| Add element     | `append(elem)`        | `list.append(4)`                         |\n| Add at start    | `prepend(elem)`       | `list.prepend(0)`                        |\n| Combine lists   | `concat(other)`       | `list.concat(otherList)`                 |\n| First element   | `head()`              | `list.head()`                            |\n| Rest of list    | `tail()`              | `list.tail()`                            |\n| First (safe)    | `headOption()`        | `list.headOption()`                      |\n| Reduce left     | `foldLeft(init)(fn)`  | `list.foldLeft(0)((sum, n) => sum + n)`  |\n| Reduce right    | `foldRight(init)(fn)` | `list.foldRight(0)((n, sum) => sum + n)` |\n| Standard reduce | `reduce(fn, init)`    | `list.reduce((acc, n) => acc + n, 0)`    |\n\n## Conversion\n\n| From   | To     | Method                                      |\n| ------ | ------ | ------------------------------------------- |\n| Option | Either | `fold(() => Left(error), v => Right(v))`    |\n| Option | Try    | N/A (not direct)                            |\n| Try    | Option | `toOption()`                                |\n| Try    | Either | `toEither()`                                |\n| Either | Option | `fold(() => Option.none(), v => Option(v))` |\n| List   | Array  | `toArray()`                                 |\n| List   | Set    | `toSet()`                                   |\n| Array  | List   | `List.from(array)` or `List(array)`         |\n| Set    | List   | `List.from(set)`                            |\n\n## Common Patterns Cheat Sheet\n\n### Null Safety\n\n```typescript\n// Before\nconst name = user?.name ?? \"Unknown\"\n\n// After\nconst name = Option(user)\n  .map((u) => u.name)\n  .orElse(\"Unknown\")\n```\n\n### Error Handling\n\n```typescript\n// Before\ntry {\n  return riskyOperation()\n} catch (e) {\n  return defaultValue\n}\n\n// After\nTry(() => riskyOperation()).orElse(defaultValue)\n```\n\n### Validation\n\n```typescript\n// Before\nfunction validate(email: string): string | null {\n  return email.includes(\"@\") ? email : null\n}\n\n// After\nfunction validate(email: string): Either<string, string> {\n  return email.includes(\"@\") ? Right(email) : Left(\"Invalid email\")\n}\n```\n\n### Array Processing\n\n```typescript\n// Before\nconst result = array.filter((x) => x > 0).map((x) => x * 2)\n\n// After (immutable)\nconst result = List(array)\n  .filter((x) => x > 0)\n  .map((x) => x * 2)\n  .toArray()\n```\n\n## Pipeline Composition\n\n### Option Pipeline\n\n```typescript\nOption(user)\n  .flatMap((u) => Option(u.profile))\n  .flatMap((p) => Option(p.settings))\n  .map((s) => s.theme)\n  .filter((theme) => validThemes.includes(theme))\n  .orElse(\"default\")\n```\n\n### Either Pipeline\n\n```typescript\nvalidateEmail(input)\n  .flatMap((email) => validateDomain(email))\n  .flatMap((email) => checkBlacklist(email))\n  .fold(\n    (error) => console.error(error),\n    (email) => sendWelcome(email),\n  )\n```\n\n### List Pipeline\n\n```typescript\nList(users)\n  .filter((u) => u.isActive)\n  .map((u) => u.email)\n  .filter((email) => email.includes(\"@\"))\n  .flatMap((email) => List(email.split(\"@\")))\n  .toSet()\n  .toArray()\n```\n\n## Do-Notation\n\nFor complex monadic workflows, some types support do-notation:\n\n```typescript\nimport { Option } from \"functype\"\n\n// Using do-notation for cleaner nested operations\nconst result = Option.Do(function* () {\n  const user = yield* Option(currentUser)\n  const profile = yield* Option(user.profile)\n  const settings = yield* Option(profile.settings)\n  return settings.theme\n}).orElse(\"light\")\n```\n\n## TypeScript Tips\n\n### Type Inference\n\n```typescript\n// Compiler infers Option<number>\nconst num = Option(5)\n\n// Explicit type when needed\nconst str: Option<string> = Option.none()\n\n// Generic constraint\nfunction process<T>(opt: Option<T>): T {\n  return opt.orThrow()\n}\n```\n\n### Type Guards\n\n```typescript\nconst value: Option<string> = Option(\"hello\")\n\nif (value.isSome()) {\n  // TypeScript still treats value as Option<string>\n  // Use orElse or fold to extract\n  const str = value.orElse(\"\")\n}\n```\n\n### Async Types\n\n```typescript\n// Promise with Option\nasync function fetchUser(id: string): Promise<Option<User>> {\n  const user = await api.getUser(id)\n  return Option(user)\n}\n\n// Promise with Either\nasync function fetchUserSafe(id: string): Promise<Either<Error, User>> {\n  try {\n    const user = await api.getUser(id)\n    return Right(user)\n  } catch (error) {\n    return Left(error as Error)\n  }\n}\n```\n\n## Common Mistakes\n\n| ❌ Wrong                                       | ✅ Correct                                   |\n| ---------------------------------------------- | -------------------------------------------- |\n| `Option(value).map(...)` without extraction    | `Option(value).map(...).orElse(default)`     |\n| `Option(user).map(u => Option(u.email))`       | `Option(user).flatMap(u => Option(u.email))` |\n| `Try(() => x).orThrow()` in non-error contexts | `Try(() => x).orElse(fallback)`              |\n| `list.toArray().push(item)` (mutates)          | `list.append(item).toArray()`                |\n| Using `any` type                               | Use proper type parameters: `Option<T>`      |\n\n## Performance Tips\n\n1. **Use Lazy for expensive computations**\n\n   ```typescript\n   const expensive = Lazy(() => heavyComputation())\n   // Only computed when accessed via .value()\n   ```\n\n2. **Use LazyList for large datasets**\n\n   ```typescript\n   LazyList.from(0, (n) => n + 1)\n     .filter((n) => n % 2 === 0)\n     .take(10)\n   ```\n\n3. **Memoize with Lazy**\n   ```typescript\n   const memoized = Lazy(() => computeOnce())\n   // Always returns same value after first computation\n   ```\n",
        "README.md": "# Functype\n\n![NPM Version](https://img.shields.io/npm/v/functype?link=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ffunctype)\n[![Node.js Build](https://github.com/jordanburke/functype/actions/workflows/pnpm-build.yml/badge.svg)](https://github.com/jordanburke/functype/actions/workflows/pnpm-build.yml)\n\n## A Functional Programming Library for TypeScript\n\nFunctype is a lightweight functional programming library for TypeScript, drawing inspiration from functional programming paradigms, the Scala Standard Library, and ZIO. It provides a comprehensive set of utilities and abstractions designed to facilitate functional programming within TypeScript applications.\n\n[API Documentation](https://jordanburke.github.io/functype/)\n\n### CLI Documentation\n\nGet LLM-optimized API reference directly in your terminal:\n\n```bash\nnpx functype              # Overview of all types\nnpx functype Option       # Detailed info for Option type\nnpx functype interfaces   # All interface definitions\nnpx functype --json       # JSON output for programmatic use\n```\n\n## Core Principles\n\n- **Immutability**: All data structures are immutable, promoting predictable and side-effect-free code\n- **Type Safety**: Leverages TypeScript's type system to ensure compile-time safety\n- **Composability**: Provides abstractions for building complex programs from simple components\n- **Functional Paradigms**: Embraces concepts like monads, functors, and type classes\n- **Unified Interface**: All data structures implement a common hierarchy of interfaces for consistency\n\n## Key Features\n\n- **Option Type**: Handle nullable values with `Some` and `None` types\n- **Either Type**: Express computation results with potential failures using `Left` and `Right`\n- **List, Set, Map**: Immutable collection types with functional operators\n- **Try Type**: Safely execute operations that might throw exceptions\n- **Do-notation**: Scala-like for-comprehensions with **optimized List performance** (up to 12x faster than traditional flatMap)\n- **Task**: Handle synchronous and asynchronous operations with error handling\n- **Lazy**: Deferred computation with memoization\n- **Tuple**: Type-safe fixed-length arrays\n- **Typeable**: Runtime type identification with compile-time safety\n- **Branded Types**: Nominal typing in TypeScript's structural type system\n- **Error Formatting**: Utilities for improved error visualization and logging\n- **Unified Type Classes**: Consistent interfaces across all data structures\n\n## Installation\n\n```bash\n# NPM\nnpm install functype\n\n# Yarn\nyarn add functype\n\n# PNPM\npnpm add functype\n\n# Bun\nbun add functype\n```\n\n### Bundle Size Optimization\n\nFunctype is optimized for tree-shaking and offers multiple import strategies to minimize bundle size:\n\n```typescript\n// Selective module imports (recommended for production)\nimport { Option } from \"functype/option\"\nimport { Either } from \"functype/either\"\n\n// Direct constructor imports (smallest bundle)\nimport { some, none } from \"functype/option\"\n```\n\nFor detailed optimization strategies, see the [Bundle Optimization Guide](docs/BUNDLE_OPTIMIZATION.md).\n\n## Usage Examples\n\n### Option\n\n{@includeCode test/docs/documentation-examples.spec.ts#readme-option-basic}\n\n### Either\n\n{@includeCode test/docs/documentation-examples.spec.ts#readme-either-basic}\n\n### List\n\n```typescript\nimport { List } from \"functype\"\n\nconst numbers = List([1, 2, 3, 4])\n\n// Transform\nconst doubled = numbers.map((x) => x * 2) // List([2, 4, 6, 8])\n\n// Filter\nconst evens = numbers.filter((x) => x % 2 === 0) // List([2, 4])\n\n// Reduce\nconst sum = numbers.foldLeft(0)((acc, x) => acc + x) // 10\n\n// Add/remove elements (immutably)\nconst withFive = numbers.add(5) // List([1, 2, 3, 4, 5])\nconst without3 = numbers.remove(3) // List([1, 2, 4])\n\n// Universal container operations\nconst hasEven = numbers.exists((x) => x % 2 === 0) // true\nconst firstEven = numbers.find((x) => x % 2 === 0) // Some(2)\nconst evenCount = numbers.count((x) => x % 2 === 0) // 2\n```\n\n### Try\n\n```typescript\nimport { Try } from \"functype\"\n\n// Safely execute code that might throw\nconst result = Try(() => {\n  // Potentially throwing operation\n  return JSON.parse('{\"name\": \"John\"}')\n})\n\n// Handle success/failure\nif (result.isSuccess()) {\n  console.log(\"Result:\", result.get())\n} else {\n  console.error(\"Error:\", result.error)\n}\n\n// Transform with map (only applies on Success)\nconst name = result.map((obj) => obj.name)\n\n// Convert to Either\nconst either = result.toEither()\n```\n\n### Lazy\n\n```typescript\nimport { Lazy } from \"functype\"\n\n// Create lazy computations\nconst expensive = Lazy(() => {\n  console.log(\"Computing...\")\n  return Math.random() * 1000\n})\n\n// Value is computed on first access and memoized\nconst value1 = expensive.get() // Logs \"Computing...\", returns number\nconst value2 = expensive.get() // Returns same number, no log\n\n// Transform lazy values\nconst doubled = expensive.map((x) => x * 2)\nconst formatted = doubled.map((x) => `Value: ${x}`)\n\n// Chain computations\nconst result = Lazy(() => 10)\n  .flatMap((x) => Lazy(() => x + 5))\n  .map((x) => x * 2)\n  .get() // 30\n```\n\n### Do-notation (High-Performance For-Comprehensions)\n\nFunctype provides generator-based Do-notation for monadic composition, similar to Scala's for-comprehensions, with **significant performance advantages for List operations**:\n\n```typescript\nimport { Do, DoAsync, $ } from \"functype\"\nimport { Option, Right, Left, List, Try } from \"functype\"\n\n// Chain multiple Option operations\nconst result = Do(function* () {\n  const x = yield* $(Option(5)) // Extract value from Option\n  const y = yield* $(Option(10)) // Extract value from another Option\n  const z = x + y // Regular computation\n  return z * 2 // Return final result\n})\n// result: Option<number> with value 30\n\n// Mix different monad types (with Reshapeable)\nconst mixed = Do(function* () {\n  const a = yield* $(Option(5)) // From Option\n  const b = yield* $(Right<string, number>(10)) // From Either\n  const c = yield* $(List([15])) // From List\n  const d = yield* $(Try(() => 20)) // From Try\n  return a + b + c + d\n})\n// Convert result to desired type\nconst asOption = mixed.toOption() // Option<number> with value 50\n\n// Error propagation - short-circuits on failure\nconst validation = Do(function* () {\n  const email = yield* $(validateEmail(\"user@example.com\")) // Returns Option\n  const user = yield* $(fetchUser(email)) // Returns Either\n  const profile = yield* $(loadProfile(user.id)) // Returns Try\n  return profile\n})\n// If any step fails, the entire computation short-circuits\n\n// List comprehensions - up to 12x FASTER than traditional flatMap!\nconst pairs = Do(function* () {\n  const x = yield* $(List([1, 2, 3]))\n  const y = yield* $(List([10, 20]))\n  return { x, y, product: x * y }\n})\n// pairs: List with 6 elements (all combinations)\n\n// Performance comparison:\n// Traditional: list.flatMap(x => list.flatMap(y => List([{x, y}]))) - slower\n// Do-notation: 2.5x to 12x faster for cartesian products!\n\n// Async operations with DoAsync\nconst asyncResult = await DoAsync(async function* () {\n  const user = yield* $(await fetchUserAsync(userId)) // Async Option\n  const score = yield* $(await getScoreAsync(user.id)) // Async Either\n  const bonus = yield* $(await calculateBonus(score)) // Async Try\n  return score + bonus\n})\n```\n\n**Performance Advantages:**\n\n- **List Comprehensions**: 2.5x to 12x faster than nested flatMap chains\n- **Optimized for Cartesian Products**: Efficient handling of multiple List yields\n- **Smart Caching**: Constructor lookups cached after first type detection\n- **Inline Helpers**: Reduced overhead from repeated type checks\n\n**When to Use Do-notation:**\n\n✅ **Best for:**\n\n- Complex List comprehensions (huge performance win!)\n- Cartesian products and filtered combinations\n- Mixed monad types (leveraging Reshapeable)\n- Improved readability for multi-step operations\n\n⚠️ **Consider alternatives for:**\n\n- Simple 2-3 step Option/Either chains (traditional flatMap is ~2x faster)\n- Performance-critical hot paths with simple monads\n- Early termination scenarios (flatMap auto-short-circuits more efficiently)\n\n**Key Differences from Scala:**\n\n- Uses `yield* $(monad)` instead of `x <- monad`\n- No native guard syntax (use conditions with early return)\n- Always returns the type of the first yielded monad\n- Mixed types supported via Reshapeable interface\n\n### Task\n\nTask v2 provides structured error handling with the **Ok/Err pattern**, returning `TaskOutcome<T>` for all operations:\n\n```typescript\nimport { Task, Ok, Err, type TaskOutcome } from \"functype\"\n\n// Task v2: All operations return TaskOutcome<T>\nconst syncResult = Task().Sync(() => \"success\")\n// Returns: TaskSuccess<string> (extends TaskOutcome<string>)\n\nconst asyncResult = await Task().Async(async () => \"value\")\n// Returns: TaskOutcome<string>\n\n// Explicit Ok/Err returns for precise control\nconst explicitResult = await Task().Async(async (): Promise<TaskOutcome<string>> => {\n  if (Math.random() > 0.5) {\n    return Ok(\"success\") // Explicit success\n  }\n  return Err<string>(\"failed\") // Explicit failure\n})\n\n// Auto-wrapping: raw values become Ok, thrown errors become Err\nconst autoWrapped = await Task().Async(async () => {\n  if (condition) {\n    return \"raw value\" // Auto-wrapped as Ok(\"raw value\")\n  }\n  throw new Error(\"failed\") // Auto-wrapped as Err(error)\n})\n\n// Error recovery: error handlers can return Ok\nconst recovered = await Task().Async(\n  async () => {\n    throw new Error(\"initial error\")\n  },\n  async (error) => Ok(\"recovered from error\"), // Recovery!\n)\n\n// Working with results\nif (asyncResult.isSuccess()) {\n  console.log(asyncResult.value) // Access the success value\n} else {\n  console.error(asyncResult.error) // Access the error (Throwable)\n}\n\n// Chaining with TaskOutcome\nconst chainedResult = await Task().Async(async () => {\n  const firstResult = await Task().Async(async () => \"first\")\n  if (firstResult.isFailure()) {\n    return firstResult // Propagate failure\n  }\n\n  const secondResult = await Task().Async(async () => \"second\")\n  if (secondResult.isFailure()) {\n    return secondResult\n  }\n\n  return Ok(`${firstResult.value} + ${secondResult.value}`)\n})\n\n// Converting promise-based functions to Task\nconst fetchUserAPI = (userId: string): Promise<User> => fetch(`/api/users/${userId}`).then((r) => r.json())\n\nconst fetchUser = Task.fromPromise(fetchUserAPI)\n// Returns: (userId: string) => Promise<TaskOutcome<User>>\n\nconst userResult = await fetchUser(\"user123\")\nif (userResult.isSuccess()) {\n  console.log(userResult.value) // User object\n}\n\n// Convert TaskOutcome back to Promise (for interop)\nconst promise = Task.toPromise(asyncResult)\n// Success → resolves with value\n// Failure → rejects with error\n```\n\n### Branded Types\n\n```typescript\nimport { Brand, ValidatedBrand } from \"functype/branded\"\n\n// Create branded types for stronger type safety\ntype UserId = Brand<\"UserId\", string>\ntype Email = Brand<\"Email\", string>\n\n// Simple branding - branded values ARE primitives!\nconst userId = Brand(\"UserId\", \"U123456\")\nconsole.log(userId) // \"U123456\" - it IS a string\nconsole.log(typeof userId) // \"string\"\nconsole.log(userId.toUpperCase()) // \"U123456\" - string methods work!\n\n// Runtime-validated branding for safer input handling\nconst EmailValidator = ValidatedBrand(\"Email\", (s: string) => /^[^@]+@[^@]+\\.[^@]+$/.test(s))\nconst UserIdValidator = ValidatedBrand(\"UserId\", (s: string) => /^U\\d{6}$/.test(s))\n\n// Safe creation with Option/Either return types\nconst email = EmailValidator.of(\"user@example.com\") // Some(Brand<\"Email\", string>)\nconst invalidEmail = EmailValidator.of(\"invalid\") // None\n\nconst userResult = UserIdValidator.from(\"U123456\") // Right(Brand<\"UserId\", string>)\nconst userError = UserIdValidator.from(\"invalid\") // Left(\"Invalid UserId: validation failed\")\n\n// Type safety in action\nfunction getUserByEmail(email: Email): User {\n  /* ... */\n}\n\n// These calls are type-safe\nconst userId = UserId(\"U123456\")\nconst email = Email(\"user@example.com\")\nconst user = getUserByEmail(email) // Works\n\n// These would be type errors\ngetUserByEmail(\"invalid\") // Type error: Argument of type 'string' is not assignable to parameter of type 'Email'\ngetUserByEmail(userId) // Type error: Argument of type 'UserId' is not assignable to parameter of type 'Email'\n```\n\n## Conditional Programming\n\nFunctype provides `Cond` and `Match` for functional conditional logic without early returns:\n\n### Cond\n\n```typescript\nimport { Cond } from \"functype\"\n\n// Replace if-else chains with Cond\nconst grade = Cond<number, string>()\n  .case((score) => score >= 90, \"A\")\n  .case((score) => score >= 80, \"B\")\n  .case((score) => score >= 70, \"C\")\n  .case((score) => score >= 60, \"D\")\n  .default(\"F\")\n\nconsole.log(grade(85)) // \"B\"\nconsole.log(grade(55)) // \"F\"\n\n// With transformation\nconst discount = Cond<number, number>()\n  .case(\n    (qty) => qty >= 100,\n    (qty) => qty * 0.2, // 20% off for 100+\n  )\n  .case(\n    (qty) => qty >= 50,\n    (qty) => qty * 0.1, // 10% off for 50+\n  )\n  .case(\n    (qty) => qty >= 10,\n    (qty) => qty * 0.05, // 5% off for 10+\n  )\n  .default(0)\n\nconsole.log(discount(150)) // 30 (20% of 150)\n```\n\n### Match\n\n```typescript\nimport { Match } from \"functype\"\n\n// Pattern matching with Match\ntype Status = \"pending\" | \"approved\" | \"rejected\" | \"cancelled\"\n\nconst statusMessage = Match<Status, string>()\n  .case(\"pending\", \"Your request is being processed\")\n  .case(\"approved\", \"Your request has been approved!\")\n  .case(\"rejected\", \"Sorry, your request was rejected\")\n  .case(\"cancelled\", \"Your request was cancelled\")\n  .exhaustive()\n\nconsole.log(statusMessage(\"approved\")) // \"Your request has been approved!\"\n\n// Match with predicates\nconst numberType = Match<number, string>()\n  .case(0, \"zero\")\n  .case((n) => n > 0, \"positive\")\n  .case((n) => n < 0, \"negative\")\n  .exhaustive()\n\nconsole.log(numberType(42)) // \"positive\"\nconsole.log(numberType(-5)) // \"negative\"\n```\n\n### Advanced Pattern Matching\n\nMatch supports exhaustive matching, nested patterns, and guards:\n\n```typescript\nimport { Match } from \"functype\"\n\n// Exhaustive matching with compile-time checking\ntype Status = \"idle\" | \"loading\" | \"success\" | \"error\"\nconst result = Match<Status, string>(\"success\")\n  .case(\"idle\", \"Waiting...\")\n  .case(\"loading\", \"Loading...\")\n  .case(\"success\", \"Done!\")\n  .case(\"error\", \"Failed!\")\n  .exhaustive() // Compile error if any case is missing\n\n// Nested pattern matching\ntype User = {\n  name: string\n  age: number\n  role: \"admin\" | \"user\"\n  preferences?: { theme: \"light\" | \"dark\" }\n}\n\nconst message = Match<User, string>(user)\n  .case({ role: \"admin\", age: (n) => n >= 18, preferences: { theme: \"dark\" } }, \"Adult admin with dark mode\")\n  .case({ role: \"user\" }, (u) => `Regular user: ${u.name}`)\n  .when((u) => u.age < 18, \"Minor user - restricted access\")\n  .default(\"Unknown user type\")\n\n// Reusable pattern matchers\nconst classifier = Match.builder<Animal, string>()\n  .when((a) => a.canFly, \"Flying creature\")\n  .case({ legs: 0 }, \"Legless\")\n  .case({ legs: 2 }, \"Biped\")\n  .case({ legs: 4 }, \"Quadruped\")\n  .default(\"Other\")\n  .build()\n```\n\n## Fold\n\nFunctype includes a powerful `fold` operation for pattern matching and extracting values:\n\n```typescript\nimport { Option, Either, Try, List } from \"functype\"\n\n// Option fold\nconst opt = Option(5)\nconst optResult = opt.fold(\n  () => \"None\",\n  (value) => `Some(${value})`,\n) // \"Some(5)\"\n\n// Either fold\nconst either = Right<string, number>(42)\nconst eitherResult = either.fold(\n  (left) => `Left(${left})`,\n  (right) => `Right(${right})`,\n) // \"Right(42)\"\n\n// Try fold\nconst tryValue = Try(() => 10)\nconst tryResult = tryValue.fold(\n  (error) => `Error: ${error.message}`,\n  (value) => `Success: ${value}`,\n) // \"Success: 10\"\n\n// List fold\nconst list = List([1, 2, 3])\nconst listResult = list.foldLeft(0)((acc, num) => acc + num) // 6\n```\n\n## Foldable\n\nFunctype includes a `Foldable` type class that all data structures implement:\n\n```typescript\nimport { FoldableUtils, Option, List, Try } from \"functype\"\n\n// All data structures implement the Foldable interface\nconst option = Option(5)\nconst list = List([1, 2, 3, 4, 5])\nconst tryVal = Try(() => 10)\n\n// Use fold to pattern-match on data structures\noption.fold(\n  () => console.log(\"Empty option\"),\n  (value) => console.log(`Option value: ${value}`),\n)\n\n// Use foldLeft for left-associative operations\nconst sum = list.foldLeft(0)((acc, value) => acc + value) // 15\n\n// Use foldRight for right-associative operations\nconst product = list.foldRight(1)((value, acc) => value * acc) // 120\n\n// Use FoldableUtils to work with any Foldable\nconst isEmpty = FoldableUtils.isEmpty(option) // false\nconst size = FoldableUtils.size(list) // 5\nconst convertedToList = FoldableUtils.toList(option) // List([5])\nconst convertedToEither = FoldableUtils.toEither(tryVal, \"Error\") // Right(10)\n```\n\n## Matchable\n\nFunctype includes a `Matchable` type class for enhanced pattern matching:\n\n```typescript\nimport { Option, Either, Try, List, MatchableUtils } from \"functype\"\n\n// Pattern matching on Option\nconst opt = Option(42)\nconst optResult = opt.match({\n  Some: (value) => `Found: ${value}`,\n  None: () => \"Not found\",\n}) // \"Found: 42\"\n\n// Pattern matching on Either\nconst either = Either.fromNullable(null, \"Missing value\")\nconst eitherResult = either.match({\n  Left: (error) => `Error: ${error}`,\n  Right: (value) => `Value: ${value}`,\n}) // \"Error: Missing value\"\n\n// Pattern matching on Try\nconst tryVal = Try(() => JSON.parse('{\"name\":\"John\"}'))\nconst tryResult = tryVal.match({\n  Success: (data) => `Name: ${data.name}`,\n  Failure: (error) => `Parse error: ${error.message}`,\n}) // \"Name: John\"\n\n// Pattern matching on List\nconst list = List([1, 2, 3])\nconst listResult = list.match({\n  NonEmpty: (values) => `Values: ${values.join(\", \")}`,\n  Empty: () => \"No values\",\n}) // \"Values: 1, 2, 3\"\n\n// Using MatchableUtils for advanced pattern matching\nconst isPositive = MatchableUtils.when(\n  (n: number) => n > 0,\n  (n) => `Positive: ${n}`,\n)\n\nconst defaultCase = MatchableUtils.default((n: number) => `Default: ${n}`)\n\n// Using pattern guards in custom matching logic\nconst num = 42\nconst result = isPositive(num) ?? defaultCase(num) // \"Positive: 42\"\n```\n\n## Interface Hierarchy\n\nAll data structures in Functype implement a unified hierarchy of interfaces, providing consistent behavior across the library:\n\n### Type Classes\n\nFunctype leverages type classes to provide common operations:\n\n- **Functor**: Supports `map` operation for transforming wrapped values\n- **Applicative**: Extends Functor with `ap` for applying wrapped functions\n- **Monad**: Extends Applicative with `flatMap` for chaining operations\n- **AsyncMonad**: Extends Monad with `flatMapAsync` for async operations\n- **ContainerOps**: Universal operations for all containers (single-value and collections)\n- **CollectionOps**: Operations specific to collections like List and Set\n\n### Unified Interfaces\n\nAll data structures implement the `Functype` hierarchy:\n\n```typescript\n// Base interface for all data structures\ninterface FunctypeBase<A, Tag>\n  extends AsyncMonad<A>, Traversable<A>, Serializable<A>, Foldable<A>, Typeable<Tag>, ContainerOps<A> {\n  readonly _tag: Tag\n}\n\n// For single-value containers (Option, Either, Try)\ninterface Functype<A, Tag> extends FunctypeBase<A, Tag>, Extractable<A>, Pipe<A>, Matchable<A, Tag> {\n  toValue(): { _tag: Tag; value: A }\n}\n\n// For collections (List, Set, Map)\ninterface FunctypeCollection<A, Tag>\n  extends FunctypeBase<A, Tag>, Iterable<A>, Pipe<A[]>, Collection<A>, CollectionOps<A, FunctypeCollection<A, Tag>> {\n  toValue(): { _tag: Tag; value: A[] }\n  // Collections work with Iterable instead of Monad\n  flatMap<B>(f: (value: A) => Iterable<B>): FunctypeCollection<B, Tag>\n}\n```\n\n### Container Operations\n\nAll containers (Option, Either, Try, List, Set) support these universal operations:\n\n```typescript\nimport { Option, List } from \"functype\"\n\nconst opt = Option(42)\nconst list = List([1, 2, 3, 4, 5])\n\n// Universal operations work on both single-value and collections\nopt.count((x) => x > 40) // 1\nlist.count((x) => x > 3) // 2\n\nopt.find((x) => x > 40) // Some(42)\nlist.find((x) => x > 3) // Some(4)\n\nopt.exists((x) => x === 42) // true\nlist.exists((x) => x === 3) // true\n\nopt.forEach(console.log) // Logs: 42\nlist.forEach(console.log) // Logs: 1, 2, 3, 4, 5\n```\n\n## Feature Matrix\n\nFor a comprehensive overview of which interfaces are supported by each data structure, see the [Functype Feature Matrix](docs/FUNCTYPE_FEATURE_MATRIX.md).\n\n## Type Safety\n\nFunctype leverages TypeScript's advanced type system to provide compile-time safety for functional patterns, ensuring that your code is both robust and maintainable.\n\n```typescript\n// Type inference works seamlessly\nconst option = Option(42)\n// Inferred as number\nconst mappedValue = option.map((x) => x.toString())\n// Inferred as string\n```\n\n## Error Formatting\n\nFunctype provides utilities for improved error visualization and logging:\n\n```typescript\nimport { formatError, createErrorSerializer } from \"functype/error\"\n\n// Create a nested task error\nconst innerTask = Task({ name: \"DbQuery\" }).Sync(() => {\n  throw new Error(\"Database connection failed\")\n})\n\nconst outerTask = Task({ name: \"UserFetch\" }).Sync(() => {\n  return innerTask.value\n})\n\n// Format the error for console display\nconsole.error(\n  formatError(outerTask.value as Error, {\n    includeTasks: true,\n    includeStackTrace: true,\n    colors: true,\n  }),\n)\n\n// Create a serializer for structured logging libraries like Pino\nconst errorSerializer = createErrorSerializer()\n\n// Use with Pino\nconst logger = pino({\n  serializers: { err: errorSerializer },\n})\n\n// Log the error with full context\nlogger.error(\n  {\n    err: outerTask.value,\n    requestId: \"req-123\",\n  },\n  \"Failed to fetch user data\",\n)\n```\n\nFor more details, see the [Error Formatting Guide](docs/error-formatting.md).\n\n## Roadmap / TODO\n\n### High Priority\n\n- [x] Complete LazyList Implementation\n  - ✓ Add Foldable interface (fold, foldLeft, foldRight)\n  - ✓ Add Pipe interface for composition\n  - ✓ Add Serializable for persistence\n  - ✓ Add Typeable support\n- [ ] Implement NonEmptyList<A>\n  - List guaranteed to have at least one element\n  - Prevents empty list errors at compile time\n  - Full standard interface implementation\n  - Methods like `head` return `A` instead of `Option<A>`\n\n### Medium Priority\n\n- [ ] Implement ValidatedNel<E, A> for validation with error accumulation\n  - Unlike Either, collects multiple errors\n  - Uses NonEmptyList for error collection\n  - Applicative instance combines errors\n- [x] Enhance Pattern Matching\n  - ✓ Add exhaustiveness checking at compile time\n  - ✓ Support nested pattern matching\n  - ✓ Add guard clauses (when conditions)\n  - ✓ Support destructuring patterns\n  - ✓ Consolidated into unified Match implementation\n- [x] Implement IO<R,E,A> effect type\n  - ✓ Lazy execution with typed errors\n  - ✓ Dependency injection (Tag, Context, Layer)\n  - ✓ Composable operations (map, flatMap, zip, race)\n  - ✓ Resource management (bracket/acquireRelease)\n  - ✓ Generator do-notation (IO.gen) and builder (IO.Do)\n\n### Low Priority\n\n- [x] Complete Tuple Implementation\n  - ✓ Add Foldable for tuple operations\n  - ✓ Add Pipe interface for composition\n  - ✓ Add Serializable for persistence\n  - ✓ Add Companion pattern with utility methods\n  - ✓ Added specialized pair() and triple() constructors\n- [ ] Implement Lens<S, A> for immutable updates\n  - Composable property access\n  - Type-safe nested updates\n  - Works with all functype data structures\n- [ ] Add Reader/State monads for dependency injection and state management\n\n### Completed Functionality\n\n- [x] Add lazy evaluation structures (LazyList implemented, needs interface completion)\n- [x] Add a proper Foldable type class interface\n- [x] Implement Matchable type class for pattern matching\n- [x] Implement Applicative and other functional type classes (for most types)\n\n### Performance Optimizations\n\n- [ ] Add memoization utilities\n- [ ] Improve recursive operations for large collections\n- [ ] Implement immutable data structures with structural sharing\n- [ ] Add performance benchmarks\n- [x] Optimize TreeShaking with sideEffects flag in package.json\n- [x] Support selective module imports for smaller bundles\n- [x] Add bundle size monitoring to CI/CD\n\n### API Consistency\n\n- [ ] Ensure all modules follow the Scala-inspired pattern:\n  - Constructor functions that return objects with methods\n  - Object methods for common operations\n  - Companion functions for additional utilities\n- [x] Align Task API with other monadic structures\n- [ ] Standardize import patterns (@ imports vs relative paths)\n- [x] Implement consistent error handling strategy for async operations\n\n### Testing and Documentation\n\n- [ ] Add observable test coverage metrics\n- [x] Implement property-based testing\n- [ ] Expand error handling tests\n- [ ] Add interoperability tests with other libraries\n\n### TypeScript Improvements\n\n- [x] Enable stricter TypeScript settings (noImplicitAny: true)\n- [x] Add noUncheckedIndexedAccess for safer array indexing\n- [ ] Improve support for higher-kinded types:\n  - Current type parameters work well for first-order types\n  - Expand to support type constructors as parameters (F<A> => F<B>)\n- [x] Add branded/nominal types for stronger type safety\n- [ ] Implement more type-level utilities (conditional types, template literals)\n- [ ] Leverage newer TypeScript features (const type parameters, tuple manipulation)\n\n## Claude Code Skills\n\nFunctype provides two specialized Claude Code skills to enhance your development experience:\n\n### Functype User Guide\n\nHelp for developers using functype in their projects:\n\n- Pattern conversion (imperative → functional)\n- API lookup and examples\n- Common use cases and debugging tips\n\n**Install**: Download from [dist/skills/functype-user.zip](./dist/skills/functype-user.zip)\n\n### Functype Library Developer\n\nGuide for contributors developing functype itself:\n\n- Architecture patterns and development workflow\n- Creating new data structures\n- Testing strategies and interface implementation\n\n**Install**: Download from [dist/skills/functype-developer.zip](./dist/skills/functype-developer.zip)\n\nSee [.claude/skills/README.md](./.claude/skills/README.md) for complete installation and usage instructions.\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## License\n\nMIT License\n\nCopyright (c) 2025 Jordan Burke\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
        "docs/considerations/README.md": "# Design Considerations\n\nThis directory contains architectural discussions, design alternatives, and trade-off analyses for functype library decisions.\n\n## Purpose\n\nThese documents preserve research and reasoning behind design choices to help:\n\n- Future maintainers understand why certain approaches were chosen\n- Contributors evaluate new feature proposals\n- Users understand library philosophy and constraints\n- Decision-makers compare alternatives systematically\n\n## Contents\n\n### [Native Type Naming Strategies](./native-type-naming.md)\n\nAnalysis of how to prevent confusion between functype's `Set`/`Map` and JavaScript's native types. Includes research from fp-ts, Immutable.js, Haskell, and other FP libraries.\n\n**Key Topics:**\n\n- Module aliasing patterns\n- ES prefix pattern (current approach)\n- Alternative naming strategies\n- Type system considerations\n\n### [Array-List Integration](./array-list-integration.md)\n\nExploration of approaches to make arrays work seamlessly with functype's `List` type, including prototype extension trade-offs and library safety concerns.\n\n**Key Topics:**\n\n- ListLike union types\n- Companion methods (`List.from()`, `List.of()`)\n- Prototype extension pros/cons\n- Library compatibility issues\n- Utility function patterns\n\n## Document Format\n\nEach consideration document follows this structure:\n\n1. **Problem Statement** - What design question are we answering?\n2. **Research** - What do other libraries/languages do?\n3. **Alternatives** - What approaches are possible?\n4. **Trade-offs** - Comparative analysis with tables\n5. **Recommendation** - What functype should do and why\n6. **References** - Links to issues, discussions, external resources\n\n## When to Add New Considerations\n\nCreate a new consideration document when:\n\n- Making significant architectural decisions\n- Comparing multiple implementation approaches\n- Researching how other libraries solve a problem\n- Documenting \"why we didn't do X\" for frequently requested features\n- Preserving context for future breaking changes\n\n## Related Documentation\n\n- [FUNCTYPE_FEATURE_MATRIX.md](../FUNCTYPE_FEATURE_MATRIX.md) - Feature implementation status\n- [BUNDLE_OPTIMIZATION.md](../BUNDLE_OPTIMIZATION.md) - Tree-shaking and bundle size\n- [quick-reference.md](../quick-reference.md) - Usage patterns\n- [CLAUDE.md](../../CLAUDE.md) - Project conventions for AI assistance\n",
        "landing/README.md": "# Astro Starter Kit: Minimal\n\n```sh\npnpm create astro@latest -- --template minimal\n```\n\n> 🧑‍🚀 **Seasoned astronaut?** Delete this file. Have fun!\n\n## 🚀 Project Structure\n\nInside of your Astro project, you'll see the following folders and files:\n\n```text\n/\n├── public/\n├── src/\n│   └── pages/\n│       └── index.astro\n└── package.json\n```\n\nAstro looks for `.astro` or `.md` files in the `src/pages/` directory. Each page is exposed as a route based on its file name.\n\nThere's nothing special about `src/components/`, but that's where we like to put any Astro/React/Vue/Svelte/Preact components.\n\nAny static assets, like images, can be placed in the `public/` directory.\n\n## 🧞 Commands\n\nAll commands are run from the root of the project, from a terminal:\n\n| Command                | Action                                           |\n| :--------------------- | :----------------------------------------------- |\n| `pnpm install`         | Installs dependencies                            |\n| `pnpm dev`             | Starts local dev server at `localhost:4321`      |\n| `pnpm build`           | Build your production site to `./dist/`          |\n| `pnpm preview`         | Preview your build locally, before deploying     |\n| `pnpm astro ...`       | Run CLI commands like `astro add`, `astro check` |\n| `pnpm astro -- --help` | Get help using the Astro CLI                     |\n\n## 👀 Want to learn more?\n\nFeel free to check [our documentation](https://docs.astro.build) or jump into our [Discord server](https://astro.build/chat).\n",
        "src/branded/README.md": "# Branded Types\n\nBranded types provide a way to create nominal typing in TypeScript, which is otherwise a structurally typed language. This allows you to create types that are structurally identical but treated as distinct by the type system.\n\n## What are Branded Types?\n\nIn TypeScript, two types with the same structure are considered compatible, which is called \"structural typing\". This can sometimes be problematic when you want to distinguish between types that have the same structure but represent different concepts.\n\nFor example, without branded types:\n\n```typescript\ntype UserId = string\ntype ProductId = string\n\nfunction getUserById(id: UserId) {\n  /* ... */\n}\n\n// This would be allowed even though semantically incorrect\nconst productId: ProductId = \"product-123\"\ngetUserById(productId) // TypeScript allows this!\n```\n\nBranded types solve this by adding a \"brand\" to the type using TypeScript's intersection types:\n\n```typescript\ntype UserId = Brand<\"UserId\", string>\ntype ProductId = Brand<\"ProductId\", string>\n\nfunction getUserById(id: UserId) {\n  /* ... */\n}\n\n// Now this won't work:\nconst productId = Brand(\"ProductId\", \"product-123\")\ngetUserById(productId) // TypeScript Error!\n```\n\n## Usage\n\n### Basic Usage\n\n```typescript\nimport { Brand } from \"@/branded\"\n\n// Define your branded types\ntype UserId = Brand<\"UserId\", string>\ntype ProductId = Brand<\"ProductId\", string>\ntype Quantity = Brand<\"Quantity\", number>\ntype Price = Brand<\"Price\", number>\n\n// Create branded values (they ARE the primitive values!)\nconst userId = Brand(\"UserId\", \"user-123\") as UserId\nconst productId = Brand(\"ProductId\", \"product-456\") as ProductId\nconst quantity = Brand(\"Quantity\", 5) as Quantity\nconst price = Brand(\"Price\", 99.99) as Price\n\n// Branded values ARE primitives - use them directly!\nconsole.log(userId) // \"user-123\"\nconsole.log(typeof userId) // \"string\"\nconsole.log(userId.toUpperCase()) // \"USER-123\" - string methods work!\nconsole.log(price + 10) // 109.99 - numeric operations work!\n\n// Function that only accepts UserId\nfunction getUserById(id: UserId): string {\n  return `User: ${id}` // id IS a string, use directly!\n}\n\n// This works\ngetUserById(userId)\n\n// These would cause TypeScript errors\n// getUserById(productId);\n// getUserById(\"user-789\");\n```\n\n### Using Branded Type Factories\n\n```typescript\nimport { BrandedString, BrandedNumber, BrandedBoolean } from \"@/branded\"\n\n// Create brand factories\nconst createUserId = BrandedString(\"UserId\")\nconst createPrice = BrandedNumber(\"Price\")\nconst createIsActive = BrandedBoolean(\"IsActive\")\n\n// Create branded values using the factories\nconst userId = createUserId(\"user-123\")\nconst price = createPrice(99.99)\nconst isActive = createIsActive(true)\n\n// Branded values ARE primitives - all operations work directly!\nconsole.log(userId.toUpperCase()) // \"USER-123\"\nconsole.log(price * 2) // 199.98\nconsole.log(isActive && true) // true\n\n// Standard toString() works as expected\nconsole.log(userId.toString()) // \"user-123\"\nconsole.log(price.toString()) // \"99.99\"\nconsole.log(String(isActive)) // \"true\"\n```\n\n### Creating Custom Branders\n\n```typescript\nimport { createBrander } from \"@/branded\"\n\ntype UserId = Brand<\"UserId\", string>\n\n// Create a custom brander\nconst UserIdBrander = createBrander<\"UserId\", string>(\"UserId\")\n\n// Use the brander to create branded values\nconst userId = UserIdBrander(\"user-123\")\n```\n\n### Working with Branded Values\n\n```typescript\nimport { unbrand } from \"@/branded\"\n\ntype UserId = Brand<\"UserId\", string>\nconst userId = Brand(\"UserId\", \"user-123\") as UserId\n\n// Branded values ARE their primitive types!\nconsole.log(userId) // \"user-123\"\nconsole.log(typeof userId) // \"string\"\n\n// Use directly in any context expecting a string\nconst uppercased = userId.toUpperCase() // \"USER-123\"\nconst interpolated = `ID: ${userId}` // \"ID: user-123\"\nconst length = userId.length // 8\n\n// The unbrand utility function exists for compatibility\nconst rawId = unbrand(userId) // Type is string\n// But it's rarely needed since userId IS already a string!\n```\n\n### Type Utilities\n\n```typescript\nimport { Brand, Unbrand, ExtractBrand } from \"@/branded\"\n\ntype UserId = Brand<\"UserId\", string>\n\n// Get the underlying type without the brand\ntype RawUserId = Unbrand<UserId> // string\n\n// Get the brand identifier\ntype UserIdBrand = ExtractBrand<UserId> // \"UserId\"\n```\n\n## ValidatedBrand\n\nFor cases where you need **runtime validation** in addition to compile-time safety, use `ValidatedBrand`:\n\n### Basic ValidatedBrand Usage\n\n```typescript\nimport { ValidatedBrand } from \"@/branded\"\n\n// Create a validated brand with runtime constraints\nconst Email = ValidatedBrand(\"Email\", (s: string) => /^[^@]+@[^@]+\\.[^@]+$/.test(s))\nconst PositiveNumber = ValidatedBrand(\"PositiveNumber\", (n: number) => n > 0)\n\n// Safe creation with Option return type\nconst email = Email.of(\"user@example.com\") // Some(Brand<\"Email\", string>)\nconst invalid = Email.of(\"not-an-email\") // None\n\n// Safe creation with Either return type for error details\nconst result = Email.from(\"user@example.com\") // Right(Brand<\"Email\", string>)\nconst error = Email.from(\"invalid\") // Left(\"Invalid Email: validation failed\")\n\n// Unsafe creation (throws on invalid input)\nconst validEmail = Email.unsafeOf(\"user@example.com\") // Brand<\"Email\", string>\n// Email.unsafeOf(\"invalid\")  // throws Error\n\n// Type guard\nif (Email.is(someValue)) {\n  // someValue is Brand<\"Email\", string>\n}\n```\n\n### Pre-built Validators\n\n```typescript\nimport {\n  PositiveNumber,\n  NonEmptyString,\n  EmailAddress,\n  UUID,\n  BoundedNumber,\n  BoundedString,\n  PatternString,\n} from \"@/branded\"\n\n// Use pre-built validators\nconst age = PositiveNumber.of(25) // Some(Brand<\"PositiveNumber\", number>)\nconst name = NonEmptyString.of(\"John\") // Some(Brand<\"NonEmptyString\", string>)\nconst email = EmailAddress.of(\"user@example.com\") // Some(Brand<\"EmailAddress\", string>)\nconst id = UUID.of(\"123e4567-e89b-12d3-a456-426614174000\") // Some(Brand<\"UUID\", string>)\n\n// Create custom bounded validators\nconst Percentage = BoundedNumber(\"Percentage\", 0, 100)\nconst Username = BoundedString(\"Username\", 3, 20)\nconst HexColor = PatternString(\"HexColor\", /^#[0-9a-f]{6}$/i)\n\nconst percent = Percentage.of(75) // Some(Brand<\"Percentage\", number>)\nconst user = Username.of(\"johndoe\") // Some(Brand<\"Username\", string>)\nconst color = HexColor.of(\"#ff0000\") // Some(Brand<\"HexColor\", string>)\n```\n\n### Refining Validators\n\n```typescript\n// Build more specific validators from existing ones\nconst SmallPositiveInteger = PositiveNumber.refine(\"SmallPositiveInteger\", (n) => {\n  // n IS already a number (phantom type)\n  return n < 100 && Number.isInteger(n)\n})\n\nconst result = SmallPositiveInteger.of(PositiveNumber.unsafeOf(50)) // Some(refined brand)\n```\n\n### Working with ValidatedBrand Values\n\nValidatedBrand creates phantom-typed primitives:\n\n```typescript\nconst email = EmailAddress.of(\"user@example.com\")\nif (!email.isEmpty) {\n  const branded = email.get()\n  console.log(branded) // \"user@example.com\" - it IS a string\n  console.log(typeof branded) // \"string\"\n  console.log(branded.includes(\"@\")) // true - string methods work!\n\n  // Use the ValidatedBrand.unwrap method if needed\n  const plain = EmailAddress.unwrap(branded) // \"user@example.com\"\n}\n```\n\n## Implementation Details\n\n### Brand Types (True Phantom Types)\n\nBranded types are now **true phantom types** - they exist only at compile-time:\n\n- **Zero Runtime Overhead**: Branded values ARE their primitive types\n- **Phantom Brand**: The `__brand` property exists only in TypeScript's type system\n- **Direct Usage**: No unwrapping needed - use branded values anywhere primitives are expected\n- **Type Safety**: Full compile-time type checking prevents mixing different brands\n\n### Why Phantom Types?\n\n```typescript\nconst userId = Brand(\"UserId\", \"user-123\")\n\n// At compile time: userId has type Brand<\"UserId\", string>\n// At runtime: userId IS the string \"user-123\"\n\nconsole.log(typeof userId) // \"string\"\nconsole.log(userId === \"user-123\") // true\n```\n\nThis approach provides:\n\n- **Better Performance**: No object allocation or wrapper overhead\n- **Seamless Integration**: Works with all JavaScript APIs expecting primitives\n- **Natural Behavior**: String interpolation, JSON serialization, equality checks all \"just work\"\n\n### ValidatedBrand Types\n\nValidatedBrand provides **runtime validation** with phantom types:\n\n- **Validation Function**: Custom predicate functions enforce constraints at runtime\n- **Safe Creation**: Methods return `Option` or `Either` types for error handling\n- **Type Guards**: Runtime type checking with `is()` method\n- **Refinement**: Build more specific validators from existing ones\n- **Phantom Results**: Validated values are still primitives, not objects\n\n### Working with External APIs\n\nSince branded values ARE primitives, they work seamlessly with external code:\n\n```typescript\nconst tenantId = TenantId.unsafeOf(\"tenant-123\")\nconst projectId = ProjectId.unsafeOf(\"proj-456\")\n\n// Direct usage with external APIs\nawait api.request({\n  tenantId, // No unwrap needed!\n  projectId, // It's already a string!\n})\n\n// JSON serialization works naturally\nJSON.stringify({ tenantId, projectId })\n// {\"tenantId\":\"tenant-123\",\"projectId\":\"proj-456\"}\n```\n",
        "src/conditional/README.md": "# Conditional Module\n\nThis module provides Scala-inspired conditional expressions that avoid early returns and enforce exhaustive pattern matching.\n\n## Cond - Conditional Expressions\n\nReplace traditional if/else chains with functional conditional expressions:\n\n```typescript\nimport { Cond } from \"@/conditional\"\n\n// Basic if/else\nconst result = Cond.of<string>()\n  .when(x > 10, \"large\")\n  .else(\"small\")\n\n// Multiple conditions\nconst grade = Cond.of<string>()\n  .when(score >= 90, \"A\")\n  .elseWhen(score >= 80, \"B\")\n  .elseWhen(score >= 70, \"C\")\n  .else(\"F\")\n\n// Lazy evaluation\nconst message = Cond.lazy<string>()\n  .when(\n    () => isError(),\n    () => computeErrorMessage(),\n  )\n  .else(() => \"Success\")\n```\n\n## Match - Pattern Matching\n\nType-safe pattern matching with exhaustiveness checking:\n\n```typescript\nimport { Match } from \"@/conditional\"\n\n// Basic matching\nconst result = Match(value)\n  .case((x) => x > 50, \"large\")\n  .case((x) => x > 25, \"medium\")\n  .default(\"small\")\n\n// Exhaustive matching for union types\ntype Status = \"pending\" | \"success\" | \"error\"\nconst message = Match.exhaustive<Status, string>({\n  pending: \"Waiting...\",\n  success: \"Done!\",\n  error: \"Failed!\",\n})(status)\n\n// Partial matching with default\nconst httpMessage = Match.partial<number, string>({\n  200: \"OK\",\n  404: \"Not Found\",\n  500: \"Server Error\",\n}).withDefault((code) => `Status: ${code}`)(statusCode)\n\n// Guard patterns\nconst category = Match.withGuards<number, string>([\n  [(n) => n < 13, \"Child\"],\n  [(n) => n < 20, \"Teenager\"],\n  [(n) => n < 60, \"Adult\"],\n]).withDefault(\"Senior\")(age)\n```\n\n## Integration with functype\n\nThese patterns work seamlessly with other functype constructs:\n\n```typescript\n// With Option\nconst maybeValue = Option(someValue).map((v) =>\n  Cond.of<string>()\n    .when(v > 10, \"large\")\n    .else(\"small\"),\n)\n\n// With Either\nconst result = Either.tryCatch(() => someOperation()).map((value) =>\n  Match(value).case(isValid, processValue).default(handleInvalid),\n)\n```\n\n## Extension Points\n\nThis module is designed to be minimal and focused on functype's patterns. For more advanced pattern matching needs:\n\n1. **ts-pattern**: Consider using [ts-pattern](https://github.com/gvergnaud/ts-pattern) for advanced pattern matching with wildcards, guards, and complex nested patterns.\n\n2. **Future TypeScript**: TypeScript may add native pattern matching in the future. Our API is designed to be easily migrated when that happens.\n\n3. **Custom Extensions**: The pattern can be extended with custom matchers:\n\n```typescript\n// Example extension point (not implemented)\nconst CustomMatch = {\n  ...Match,\n  shape:\n    <T>(pattern: Partial<T>) =>\n    (value: T) =>\n      boolean,\n}\n```\n\n## Design Philosophy\n\n- **No Early Returns**: All paths must return a value\n- **Type Safety**: Exhaustive checking for union types\n- **Functional**: Expressions, not statements\n- **Composable**: Works with pipes and other functional constructs\n- **Minimal**: Simple API for common cases, extensible for complex needs\n",
        "src/functype/README.md": "# Functype Interface\n\nThe `Functype` interface provides a unified contract for functional data structures in the functype library. It combines commonly implemented functional programming traits into a single interface, making it easier to create consistent and interoperable data structures.\n\n## Overview\n\nThe functype library implements multiple functional programming interfaces that data structures commonly implement together:\n\n- **AsyncMonad** - Functor, Applicative, Monad, and AsyncMonad operations\n- **Traversable** - Collection-like operations (size, isEmpty, contains, reduce)\n- **Extractable** - Safe value extraction methods\n- **Serializable** - JSON, YAML, and Binary serialization\n- **Pipe** - Function composition\n- **Foldable** - Pattern matching and folding operations\n- **Matchable** - Tagged union pattern matching\n\nThe `Functype` interface combines all of these into a single contract.\n\n## Interface Variants\n\n### Functype<A, Tag>\n\nThe complete interface for full-featured functional data structures:\n\n```typescript\nexport interface Functype<A, Tag extends string = string>\n  extends AsyncMonad<A>, Traversable<A>, Extractable<A>, Serializable<A>, Pipe<A>, Foldable<A>, Matchable<A, Tag> {\n  readonly _tag: Tag\n  toValue(): { _tag: Tag; value: A }\n}\n```\n\n### FunctypeMinimal<A, Tag>\n\nA minimal version for simpler data structures that don't need the full monadic interface:\n\n```typescript\nexport interface FunctypeMinimal<A, Tag extends string = string>\n  extends Serializable<A>, Pipe<A>, Foldable<A>, Matchable<A, Tag> {\n  readonly _tag: Tag\n  toValue(): { _tag: Tag; value: A }\n}\n```\n\n### FunctypeCollection<A, Tag>\n\nExtends Functype with iteration support for collection types:\n\n```typescript\nexport interface FunctypeCollection<A, Tag extends string = string> extends Functype<A, Tag>, Iterable<A> {}\n```\n\n## Usage\n\n### Existing Types\n\nMany functype data structures already implement the required interfaces and can be typed as Functype:\n\n```typescript\nimport { Option, Either, List } from \"functype\"\nimport type { Functype } from \"functype/functor\"\n\n// Option implements Functype\nconst opt: Functype<number, \"Some\" | \"None\"> = Option(42)\n\n// Either implements most of Functype (except Traversable size/isEmpty/contains)\nconst either: Either<string, number> = Right(42)\n\n// List implements FunctypeCollection\nconst list: FunctypeCollection<number, \"List\"> = List([1, 2, 3])\n```\n\n### Creating New Types\n\nTo create a new data structure that implements Functype:\n\n```typescript\nimport type { Functype, Type } from \"functype\"\n\ntype BoxTag = \"Empty\" | \"Full\"\n\nclass Box<T extends Type> implements Functype<T, BoxTag> {\n  constructor(\n    public readonly _tag: BoxTag,\n    private readonly _value?: T,\n  ) {}\n\n  // Implement all required methods...\n  map<U extends Type>(f: (value: T) => U): Box<U> {\n    return this._tag === \"Full\" && this._value !== undefined ? new Box<U>(\"Full\", f(this._value)) : new Box<U>(\"Empty\")\n  }\n\n  // ... other method implementations\n}\n```\n\nSee `functype-example.ts` for a complete implementation example.\n\n## Benefits\n\n1. **Consistency**: All data structures implementing Functype have the same rich set of operations\n2. **Interoperability**: Functions can work with any Functype without knowing the specific type\n3. **Type Safety**: The Tag parameter ensures pattern matching is exhaustive\n4. **Discoverability**: IDEs can show all available methods when working with Functype\n\n## Common Patterns\n\n### Generic Functions\n\nYou can write functions that work with any Functype:\n\n```typescript\nfunction processValue<A, Tag extends string>(functype: Functype<A, Tag>, processor: (value: A) => A): Functype<A, Tag> {\n  return functype.map(processor)\n}\n\n// Works with any Functype implementation\nconst result1 = processValue(Option(42), (x) => x * 2)\nconst result2 = processValue(List([1, 2, 3]), (x) => x * 2)\n```\n\n### Pattern Matching\n\nAll Functype implementations support pattern matching:\n\n```typescript\nfunction describe<A, Tag extends string>(functype: Functype<A, Tag>): string {\n  return functype.match({\n    // Pattern matching is type-safe based on the Tag\n    // Implementation must handle all possible tags\n  } as any) // Type assertion needed for generic matching\n}\n```\n\n## Migration Guide\n\nIf you have an existing data structure that implements most of these interfaces:\n\n1. Add the `Functype` import\n2. Update your type declaration to extend `Functype<YourType, YourTags>`\n3. Ensure you have `_tag` property and `toValue()` method\n4. The TypeScript compiler will guide you through any missing implementations\n\nExample:\n\n```typescript\n// Before\ntype MyType<T> = {\n  // ... properties\n} & Monad<T> &\n  Foldable<T> &\n  Serializable<T>\n\n// After\nimport type { Functype } from \"functype/functor\"\n\ntype MyType<T> = {\n  // ... properties\n} & Functype<T, \"Empty\" | \"Full\">\n```\n"
      },
      "plugins": [
        {
          "name": "functype",
          "description": "Help developers use functype patterns in their TypeScript projects - pattern conversion, API lookup, common use cases",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/functype"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/functype",
            "/plugin install functype@functype-skills"
          ]
        },
        {
          "name": "functype-developer",
          "description": "Assist contributors developing the functype library - architecture patterns, creating new types, testing strategies",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/functype-developer"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/functype",
            "/plugin install functype-developer@functype-skills"
          ]
        }
      ]
    },
    {
      "name": "supabase-typed-query-skills",
      "version": null,
      "description": "Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns",
      "owner_info": {
        "name": "Jordan Burke",
        "email": "jordan.burke@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "jordanburke/supabase-typed-query",
      "repo_url": "https://github.com/jordanburke/supabase-typed-query",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-11T21:35:36Z",
        "created_at": "2025-09-02T16:58:40Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 607
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/README.md",
          "type": "blob",
          "size": 1787
        },
        {
          "path": ".claude/skills/supabase-typed-query",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/supabase-typed-query/SKILL.md",
          "type": "blob",
          "size": 16408
        },
        {
          "path": ".claude/skills/supabase-typed-query/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/supabase-typed-query/references/common-patterns.md",
          "type": "blob",
          "size": 16114
        },
        {
          "path": ".claude/skills/supabase-typed-query/references/quick-reference.md",
          "type": "blob",
          "size": 10167
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 15075
        },
        {
          "path": "test",
          "type": "tree",
          "size": null
        },
        {
          "path": "test/integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "test/integration/README.md",
          "type": "blob",
          "size": 5633
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"supabase-typed-query-skills\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"supabase-typed-query\",\n      \"description\": \"Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/supabase-typed-query\"]\n    }\n  ]\n}\n",
        ".claude/skills/README.md": "# supabase-typed-query Skills\n\nThis directory contains Claude Code skills for working with the supabase-typed-query library.\n\n## Available Skills\n\n### supabase-typed-query\n\n**Purpose**: Help developers use supabase-typed-query for type-safe Supabase queries\n\n**Use when**:\n\n- Building queries with the Query API (`query()`, OR chaining, functional operations)\n- Working with Entity/PartitionedEntity patterns for CRUD operations\n- Handling `TaskOutcome` errors or using `OrThrow` methods\n- Implementing soft deletes and multi-tenancy\n- Looking up API methods or comparison operators\n- Debugging query issues\n\n**Installation**:\n\n```bash\n# Copy directly to Claude's skills directory\ncp -r .claude/skills/supabase-typed-query ~/.claude/skills/\n```\n\n## Skill Contents\n\n```\nsupabase-typed-query/\n├── SKILL.md                        # Main skill guide\n└── references/\n    ├── quick-reference.md          # API cheat sheet\n    └── common-patterns.md          # Usage patterns and examples\n```\n\n**Key features**:\n\n- Query API guide (chainable, functional queries)\n- Entity API guide (CRUD operations with soft deletes)\n- Type system documentation (comparison operators, database types)\n- Error handling patterns (TaskOutcome, OrThrow methods)\n- Multi-tenancy with PartitionedEntity\n- Debugging tips and common issues\n\n## Usage in Claude Code\n\nOnce installed, Claude Code will automatically suggest this skill when:\n\n- Working with Supabase queries\n- User asks about supabase-typed-query APIs\n- Code contains `query()`, `Entity()`, or `PartitionedEntity()` calls\n- Handling `TaskOutcome` or functype patterns in Supabase context\n\n## Resources\n\n- **GitHub**: https://github.com/jordanburke/supabase-typed-query\n- **NPM**: https://www.npmjs.com/package/supabase-typed-query\n",
        ".claude/skills/supabase-typed-query/SKILL.md": "---\nname: supabase-typed-query\ndescription: Help developers use supabase-typed-query for type-safe Supabase queries. Use this skill when building queries with the Query API, working with Entity/PartitionedEntity patterns, handling TaskOutcome errors, or implementing soft deletes and multi-tenancy.\n---\n\n# supabase-typed-query User Guide\n\n## Overview\n\nsupabase-typed-query is a type-safe query builder and entity pattern library for Supabase. It provides:\n\n- Fully typed queries leveraging your database schema\n- Two complementary APIs: Query API (functional, chainable) and Entity API (CRUD patterns)\n- Built on functype for robust error handling with `TaskOutcome`\n- Support for soft deletes, multi-tenancy, and complex queries with OR conditions\n\n## When to Use This Skill\n\nTrigger this skill when users:\n\n- Build queries using `query()` function\n- Work with `Entity()` or `PartitionedEntity()` patterns\n- Handle `TaskOutcome` or use `OrThrow` methods\n- Implement soft deletes or multi-tenancy\n- Look up comparison operators or API methods\n- Debug query issues\n\n## Quick Start\n\n### Installation\n\n```bash\nnpm install supabase-typed-query\n# or\npnpm add supabase-typed-query\n```\n\n### Generate Database Types\n\n```bash\nnpx supabase gen types typescript --project-id your-project-id > database.types.ts\n```\n\n### Core Imports\n\n```typescript\nimport { query, Entity, PartitionedEntity } from \"supabase-typed-query\"\nimport { createClient } from \"@supabase/supabase-js\"\nimport type { Database } from \"./database.types\"\n\nconst client = createClient<Database>(url, key)\n```\n\n## Query API\n\nThe Query API provides chainable, functional queries with OR support.\n\n### Basic Query\n\n```typescript\nimport { query } from \"supabase-typed-query\"\n\n// Simple query with type-safe conditions\nconst user = await query<\"users\", Database>(client, \"users\", { id: \"123\" }).oneOrThrow()\n\n// Query with comparison operators\nconst recentPosts = await query<\"posts\", Database>(client, \"posts\", {\n  created_at: { gte: new Date(\"2024-01-01\") },\n}).manyOrThrow()\n```\n\n### OR Chaining\n\n```typescript\n// Multiple OR conditions\nconst results = await query<\"users\", Database>(client, \"users\", { role: \"admin\" })\n  .or({ role: \"moderator\" })\n  .or({ role: \"editor\", active: true })\n  .manyOrThrow()\n// SQL: WHERE role = 'admin' OR role = 'moderator' OR (role = 'editor' AND active = true)\n```\n\n### Functional Operations\n\n```typescript\n// Map: transform each result\nconst titles = await query<\"posts\", Database>(client, \"posts\", { status: \"published\" })\n  .map((post) => post.title)\n  .manyOrThrow()\n\n// Filter: client-side filtering after fetch\nconst activeUsers = await query<\"users\", Database>(client, \"users\", {})\n  .filter((user) => user.active === true && user.age > 18)\n  .manyOrThrow()\n\n// Chain map + filter\nconst adultNames = await query<\"users\", Database>(client, \"users\", {})\n  .filter((user) => user.age >= 18)\n  .map((user) => user.name)\n  .manyOrThrow()\n```\n\n### Execution Methods\n\n| Method            | Returns                  | Description                  |\n| ----------------- | ------------------------ | ---------------------------- |\n| `.one()`          | `TaskOutcome<Option<T>>` | Expects 0-1 results          |\n| `.many()`         | `TaskOutcome<List<T>>`   | Expects 0+ results           |\n| `.first()`        | `TaskOutcome<Option<T>>` | Gets first if multiple       |\n| `.oneOrThrow()`   | `Promise<T>`             | Throws if not found or error |\n| `.manyOrThrow()`  | `Promise<List<T>>`       | Throws on error              |\n| `.firstOrThrow()` | `Promise<T>`             | Throws if not found or error |\n\n### Comparison Operators\n\n```typescript\ntype ComparisonOperators<V> = {\n  gte?: V // Greater than or equal\n  gt?: V // Greater than\n  lte?: V // Less than or equal\n  lt?: V // Less than\n  neq?: V // Not equal (use NOT operator for null)\n  like?: string // LIKE pattern\n  ilike?: string // Case-insensitive LIKE\n  in?: V[] // IN array\n  is?: null | boolean // IS NULL/TRUE/FALSE\n}\n\n// Examples\nconst results = await query<\"posts\", Database>(client, \"posts\", {\n  view_count: { gte: 100, lte: 1000 },\n  title: { ilike: \"%guide%\" },\n  tags: { in: [\"typescript\", \"supabase\"] },\n  published_at: { is: null }, // Find unpublished\n}).manyOrThrow()\n```\n\n### NOT Operator\n\nThe `not` operator follows Supabase conventions for negating IS and IN conditions:\n\n```typescript\n// IS NOT NULL - find posts with external_id set\nconst linkedPosts = await query<\"posts\", Database>(client, \"posts\", {\n  not: { is: { external_id: null } },\n}).manyOrThrow()\n\n// IS NOT TRUE / IS NOT FALSE\nconst nonFeatured = await query<\"posts\", Database>(client, \"posts\", {\n  not: { is: { featured: true } },\n}).manyOrThrow()\n\n// NOT IN - exclude specific values\nconst activePosts = await query<\"posts\", Database>(client, \"posts\", {\n  not: { in: { status: [\"draft\", \"archived\", \"spam\"] } },\n}).manyOrThrow()\n\n// Entity API supports NOT as well\nconst items = await PostEntity.getItems({\n  where: { status: \"published\" },\n  not: { is: { external_id: null } },\n}).manyOrThrow()\n```\n\n> **Note**: `neq: null` is deprecated. Use `not: { is: { field: null } }` instead for IS NOT NULL checks.\n\n## RPC (Stored Procedures)\n\nThe `rpc()` function provides type-safe invocation of PostgreSQL functions/stored procedures.\n\n### Basic RPC Call\n\n```typescript\nimport { rpc } from \"supabase-typed-query\"\n\n// Call a function that returns a single value\nconst stats = await rpc<\"get_user_stats\", Database>(client, \"get_user_stats\", {\n  user_id: \"123\",\n}).oneOrThrow()\n\n// Call a function that returns multiple rows\nconst results = await rpc<\"search_products\", Database>(client, \"search_products\", {\n  query: \"laptop\",\n  limit: 10,\n}).manyOrThrow()\n```\n\n### RPC Execution Methods\n\n| Method           | Returns                  | Description                   |\n| ---------------- | ------------------------ | ----------------------------- |\n| `.one()`         | `TaskOutcome<Option<T>>` | Expects single result or none |\n| `.many()`        | `TaskOutcome<List<T>>`   | Expects 0+ results as a list  |\n| `.oneOrThrow()`  | `Promise<T>`             | Throws if not found or error  |\n| `.manyOrThrow()` | `Promise<List<T>>`       | Throws on error               |\n\n### RPC with Options\n\n```typescript\n// With count option for pagination info\nconst results = await rpc<\"search_items\", Database>(\n  client,\n  \"search_items\",\n  { query: \"test\" },\n  { count: \"exact\" },\n).manyOrThrow()\n```\n\n### Type Safety\n\nRPC return types are inferred from your database schema. Your Database type should include Functions definitions:\n\n```typescript\ninterface Database {\n  public: {\n    Tables: {\n      /* ... */\n    }\n    Functions: {\n      get_user_stats: {\n        Args: { user_id: string }\n        Returns: { total: number; active: number }\n      }\n      search_products: {\n        Args: { query: string; limit?: number }\n        Returns: { id: string; name: string; price: number }[]\n      }\n    }\n  }\n}\n```\n\n### Error Handling with RPC\n\n```typescript\n// Using TaskOutcome\nconst result = await rpc<\"risky_function\", Database>(client, \"risky_function\", {}).one()\n\nif (result.isOk()) {\n  const maybeData = result.orThrow()\n  if (maybeData.isSome()) {\n    console.log(\"Data:\", maybeData.orElse(null))\n  }\n} else {\n  console.error(\"RPC failed:\", result.error)\n}\n\n// Using OrThrow\ntry {\n  const data = await rpc<\"risky_function\", Database>(client, \"risky_function\", {}).oneOrThrow()\n} catch (error) {\n  console.error(\"Error:\", error)\n}\n```\n\n## Entity API\n\nThe Entity API provides consistent CRUD patterns.\n\n### Standard Entity\n\n```typescript\nimport { Entity } from \"supabase-typed-query\"\n\nconst PostEntity = Entity<\"posts\", Database>(client, \"posts\", { softDelete: true })\n\n// Get single item\nconst post = await PostEntity.getItem({ id: \"123\" }).oneOrThrow()\n\n// Get multiple items\nconst posts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  order: [\"created_at\", { ascending: false }],\n}).manyOrThrow()\n\n// Add items\nconst created = await PostEntity.addItems({\n  items: [{ title: \"New Post\", status: \"draft\" }],\n}).executeOrThrow()\n\n// Update single item\nconst updated = await PostEntity.updateItem({\n  where: { id: \"123\" },\n  data: { status: \"published\" },\n}).executeOrThrow()\n\n// Update multiple items\nconst bulkUpdated = await PostEntity.updateItems({\n  where: { status: \"draft\" },\n  data: { status: \"archived\" },\n}).executeOrThrow()\n\n// Upsert items\nconst upserted = await PostEntity.upsertItems({\n  items: [{ id: \"123\", title: \"Updated Title\" }],\n  identity: \"id\",\n}).executeOrThrow()\n\n// Delete single item (soft delete when softDelete: true)\nconst deleted = await PostEntity.deleteItem({\n  where: { id: \"123\" },\n}).executeOrThrow()\n\n// Delete multiple items\nconst deletedMany = await PostEntity.deleteItems({\n  where: { status: \"archived\" },\n}).executeOrThrow()\n```\n\n**Note:** When `softDelete: true`, delete methods set the `deleted` timestamp instead of physically removing rows. When `softDelete: false`, rows are permanently removed.\n\n### PartitionedEntity (Multi-Tenancy)\n\n```typescript\nimport { PartitionedEntity } from \"supabase-typed-query\"\n\nconst TenantPostEntity = PartitionedEntity<\"posts\", string, Database>(client, \"posts\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n})\n\n// All queries automatically include partition filter\nconst tenantPosts = await TenantPostEntity.getItems(tenantId, {\n  where: { status: \"published\" },\n}).manyOrThrow()\n// SQL: WHERE tenant_id = 'tenantId' AND status = 'published' AND deleted IS NULL\n```\n\n### ViewEntity (Read-Only Views)\n\nDatabase views are read-only in Supabase and only have a `Row` type (no `Insert` or `Update`). Use `ViewEntity` for type-safe querying of views.\n\n```typescript\nimport { ViewEntity } from \"supabase-typed-query\"\n\n// Create a read-only view entity\nconst AuthUsersView = ViewEntity<\"auth_users_view\", Database, \"agent_gate\">(client, \"auth_users_view\", {\n  schema: \"agent_gate\",\n})\n\n// Query the view - only getItem and getItems are available\nconst user = await AuthUsersView.getItem({ id: \"123\" }).oneOrThrow()\nconst activeUsers = await AuthUsersView.getItems({\n  where: { is_active: true },\n  order: [\"created_at\", { ascending: false }],\n}).manyOrThrow()\n```\n\n**Key differences from Entity:**\n\n- Only `getItem()` and `getItems()` methods available (no write operations)\n- No `softDelete` configuration (views are read-only snapshots)\n- Uses `ViewNames` and `ViewRow` types instead of `TableNames` and `TableRow`\n\n### PartitionedViewEntity (Multi-Tenant Views)\n\nFor views that require partition-based access control:\n\n```typescript\nimport { PartitionedViewEntity } from \"supabase-typed-query\"\n\nconst TenantStatsView = PartitionedViewEntity<\"tenant_stats_view\", string, Database>(client, \"tenant_stats_view\", {\n  partitionField: \"tenant_id\",\n})\n\n// Partition key is required for all queries\nconst stats = await TenantStatsView.getItems(tenantId, {\n  where: { period: \"monthly\" },\n}).manyOrThrow()\n```\n\n## Error Handling\n\n### TaskOutcome Pattern (Explicit)\n\n```typescript\nimport { Ok, Err } from \"functype\"\n\nconst result = await query<\"users\", Database>(client, \"users\", { id: userId }).one()\n\nif (result.isOk()) {\n  const maybeUser = result.getOrThrow() // Option<User>\n  if (maybeUser.isSome()) {\n    const user = maybeUser.getOrThrow()\n    console.log(user)\n  }\n} else {\n  console.error(\"Query failed:\", result.error)\n}\n```\n\n### OrThrow Methods (Simple)\n\n```typescript\ntry {\n  const user = await query<\"users\", Database>(client, \"users\", { id: userId }).oneOrThrow()\n  console.log(\"User:\", user)\n} catch (error) {\n  if (error instanceof SupabaseError) {\n    console.log(error.code) // PostgreSQL error code\n    console.log(error.details) // Additional details\n    console.log(error.hint) // Hint for fixing\n  }\n}\n```\n\n## Custom Schema Support\n\nPostgreSQL supports multiple schemas beyond the default `public` schema. Both Entity and Query APIs support querying from custom schemas.\n\n### Entity with Custom Schema\n\n```typescript\n// Query from a custom schema (e.g., \"inventory\" schema)\nconst InventoryEntity = Entity<\"items\", Database>(client, \"items\", {\n  softDelete: false,\n  schema: \"inventory\", // Uses client.schema(\"inventory\").from(\"items\")\n})\n\n// All queries will target the \"inventory\" schema\nconst items = await InventoryEntity.getItems({ where: { active: true } }).manyOrThrow()\n```\n\n### PartitionedEntity with Custom Schema\n\n```typescript\n// Multi-tenant data in a custom schema\nconst TenantItemsEntity = PartitionedEntity<\"items\", string, Database>(client, \"items\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n  schema: \"tenant_data\", // Custom schema\n})\n\n// Queries target the custom schema with partition filter\nconst items = await TenantItemsEntity.getItems(tenantId).manyOrThrow()\n```\n\n### Query API with Custom Schema\n\n```typescript\nimport { query } from \"supabase-typed-query\"\n\n// Use the 7th parameter for schema\nconst results = await query<\"items\", Database>(\n  client,\n  \"items\",\n  { active: true },\n  undefined, // is conditions\n  undefined, // wherein conditions\n  undefined, // order\n  \"inventory\", // schema\n).manyOrThrow()\n```\n\n### Default Behavior\n\n- If no schema is specified, queries use the default `public` schema (via `client.from()`)\n- When a schema is specified, queries use `client.schema(name).from(table)`\n\n## Soft Delete\n\n### Configuration\n\nThe `softDelete` configuration affects both queries AND delete operations:\n\n```typescript\n// Entity with soft deletes enabled\nconst UserEntity = Entity<\"users\", Database>(client, \"users\", { softDelete: true })\n// - Queries automatically filter: WHERE deleted IS NULL\n// - deleteItem/deleteItems set deleted timestamp (soft delete)\n\n// Entity without soft deletes\nconst AllUsersEntity = Entity<\"users\", Database>(client, \"users\", { softDelete: false })\n// - Queries include all records (no automatic filtering)\n// - deleteItem/deleteItems permanently remove rows (hard delete)\n```\n\n### Per-Query Override\n\n```typescript\n// Override for specific queries\nconst allUsers = await UserEntity.getItems().includeDeleted().many()\nconst deletedOnly = await UserEntity.getItems().onlyDeleted().many()\nconst activeOnly = await UserEntity.getItems().excludeDeleted().many()\n\n// Works with query() too\nconst all = await query<\"users\", Database>(client, \"users\", {}).includeDeleted().many()\n```\n\n## Common Patterns\n\n### Safe Data Fetching\n\n```typescript\nimport { Option } from \"functype\"\n\nasync function getUserEmail(userId: string): Promise<Option<string>> {\n  const result = await query<\"users\", Database>(client, \"users\", { id: userId }).one()\n  return result.map((maybeUser) => maybeUser.flatMap((user) => Option(user.email))).orElse(Option.none())\n}\n```\n\n### Batch Operations\n\n```typescript\n// Add multiple items\nconst posts = await PostEntity.addItems({\n  items: [\n    { title: \"Post 1\", status: \"draft\" },\n    { title: \"Post 2\", status: \"draft\" },\n  ],\n}).executeOrThrow()\n\n// Update all matching items\nconst archived = await PostEntity.updateItems({\n  where: { status: \"draft\" },\n  data: { status: \"archived\" },\n}).executeOrThrow()\n```\n\n### Complex Queries\n\n```typescript\n// Combining operators\nconst results = await query<\"posts\", Database>(client, \"posts\", {\n  created_at: { gte: startDate, lte: endDate },\n  status: { in: [\"published\", \"featured\"] },\n  view_count: { gt: 100 },\n})\n  .or({ is_pinned: true })\n  .limit(20)\n  .manyOrThrow()\n```\n\n## Debugging Tips\n\n### Common Issues\n\n**\"Type 'X' is not assignable to type 'Y'\"**\n\n- Ensure you're passing the Database type as a generic: `query<\"users\", Database>(...)`\n- Check that your database types are up-to-date with `npx supabase gen types`\n\n**\"Property 'X' does not exist\"**\n\n- Verify table name matches your database schema\n- Regenerate types if you've added new columns\n\n**Empty results when expecting data**\n\n- Check soft delete configuration: `{ softDelete: true }` filters out deleted records\n- Use `.includeDeleted()` to see all records\n\n**OrThrow throwing unexpectedly**\n\n- Use explicit `TaskOutcome` methods (`.one()`, `.many()`) for debugging\n- Check `result.isOk()` and inspect `result.error` for details\n\n## Resources\n\n### references/\n\n- `quick-reference.md` - API cheat sheet\n- `common-patterns.md` - Usage patterns and recipes\n\n### External Links\n\n- **GitHub**: https://github.com/jordanburke/supabase-typed-query\n- **NPM**: https://www.npmjs.com/package/supabase-typed-query\n- **functype**: https://github.com/jordanburke/functype\n",
        ".claude/skills/supabase-typed-query/references/common-patterns.md": "# Common Patterns\n\n## Basic CRUD Operations\n\n### Read Operations\n\n```typescript\nimport { query, Entity } from \"supabase-typed-query\"\nimport type { Database } from \"./database.types\"\n\n// Get by ID\nconst user = await query<\"users\", Database>(client, \"users\", { id: userId }).oneOrThrow()\n\n// Get with conditions\nconst activeUsers = await query<\"users\", Database>(client, \"users\", {\n  status: \"active\",\n  role: { in: [\"admin\", \"editor\"] },\n}).manyOrThrow()\n\n// Get with ordering\nconst latestPosts = await query<\"posts\", Database>(client, \"posts\", {\n  status: \"published\",\n})\n  .limit(10)\n  .manyOrThrow()\n```\n\n### Create Operations\n\n```typescript\nconst PostEntity = Entity<\"posts\", Database>(client, \"posts\", { softDelete: true })\n\n// Single item\nconst [post] = await PostEntity.addItems({\n  items: [{ title: \"New Post\", author_id: userId, status: \"draft\" }],\n}).executeOrThrow()\n\n// Multiple items\nconst posts = await PostEntity.addItems({\n  items: [\n    { title: \"Post 1\", author_id: userId, status: \"draft\" },\n    { title: \"Post 2\", author_id: userId, status: \"draft\" },\n  ],\n}).executeOrThrow()\n```\n\n### Update Operations\n\n```typescript\n// Update single item by ID\nconst updated = await PostEntity.updateItem({\n  where: { id: postId },\n  data: { status: \"published\", published_at: new Date().toISOString() },\n}).executeOrThrow()\n\n// Update multiple items matching condition\nconst archived = await PostEntity.updateItems({\n  where: { status: \"draft\", created_at: { lt: cutoffDate } },\n  data: { status: \"archived\" },\n}).executeOrThrow()\n```\n\n### Upsert Operations\n\n```typescript\n// Upsert by ID (default identity)\nconst upserted = await PostEntity.upsertItems({\n  items: [\n    { id: \"existing-id\", title: \"Updated Title\" },\n    { id: \"new-id\", title: \"New Post\", author_id: userId },\n  ],\n}).executeOrThrow()\n\n// Upsert with custom identity column\nconst result = await PostEntity.upsertItems({\n  items: [{ external_id: \"ext-123\", title: \"Synced Post\" }],\n  identity: \"external_id\",\n}).executeOrThrow()\n```\n\n## OR Query Patterns\n\n### Multiple Values for Same Field\n\n```typescript\n// Find posts by multiple authors\nconst posts = await query<\"posts\", Database>(client, \"posts\", { author_id: author1 })\n  .or({ author_id: author2 })\n  .or({ author_id: author3 })\n  .manyOrThrow()\n```\n\n### Different Conditions\n\n```typescript\n// Find admins OR verified users\nconst users = await query<\"users\", Database>(client, \"users\", { role: \"admin\" }).or({ is_verified: true }).manyOrThrow()\n```\n\n### Combined AND/OR Logic\n\n```typescript\n// (role = 'admin') OR (role = 'editor' AND department = 'content')\nconst users = await query<\"users\", Database>(client, \"users\", { role: \"admin\" })\n  .or({ role: \"editor\", department: \"content\" })\n  .manyOrThrow()\n```\n\n## Functional Transformations\n\n### Map for Data Extraction\n\n```typescript\n// Extract specific fields\nconst emails = await query<\"users\", Database>(client, \"users\", { status: \"active\" })\n  .map((user) => user.email)\n  .manyOrThrow()\n\n// Transform to DTOs\ninterface UserDTO {\n  id: string\n  displayName: string\n}\n\nconst dtos = await query<\"users\", Database>(client, \"users\", {})\n  .map(\n    (user): UserDTO => ({\n      id: user.id,\n      displayName: `${user.first_name} ${user.last_name}`,\n    }),\n  )\n  .manyOrThrow()\n```\n\n### Filter for Client-Side Refinement\n\n```typescript\n// Additional filtering after database query\nconst premiumAdults = await query<\"users\", Database>(client, \"users\", { status: \"active\" })\n  .filter((user) => user.age >= 18)\n  .filter((user) => user.subscription_tier === \"premium\")\n  .manyOrThrow()\n```\n\n### Chained Transformations\n\n```typescript\n// Filter then map\nconst adultEmails = await query<\"users\", Database>(client, \"users\", { status: \"active\" })\n  .filter((user) => user.age >= 18)\n  .map((user) => user.email)\n  .manyOrThrow()\n```\n\n## Multi-Tenancy Patterns\n\n### Basic Tenant Isolation\n\n```typescript\nimport { PartitionedEntity } from \"supabase-typed-query\"\n\nconst TenantPostEntity = PartitionedEntity<\"posts\", string, Database>(client, \"posts\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n})\n\n// All operations automatically scoped to tenant\nconst tenantPosts = await TenantPostEntity.getItems(tenantId, {\n  where: { status: \"published\" },\n}).manyOrThrow()\n```\n\n### Type-Safe Tenant Keys\n\n```typescript\nimport { ValidatedBrand } from \"functype\"\n\n// Define branded tenant ID type\ntype TenantId = ValidatedBrand<string, \"TenantId\">\n\nconst TenantPostEntity = PartitionedEntity<\"posts\", TenantId, Database>(client, \"posts\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n})\n\n// Type-safe tenant key required\nconst tenantId = \"tenant-123\" as TenantId\nconst posts = await TenantPostEntity.getItems(tenantId, {}).manyOrThrow()\n```\n\n## Soft Delete Patterns\n\n### Default Behavior (Exclude Deleted)\n\n```typescript\nconst PostEntity = Entity<\"posts\", Database>(client, \"posts\", { softDelete: true })\n\n// Only returns non-deleted items by default\nconst activePosts = await PostEntity.getItems({}).manyOrThrow()\n```\n\n### Include All Records\n\n```typescript\n// For admin views or auditing\nconst allPosts = await PostEntity.getItems({}).includeDeleted().manyOrThrow()\n```\n\n### View Only Deleted\n\n```typescript\n// For trash/recovery views\nconst deletedPosts = await PostEntity.getItems({}).onlyDeleted().manyOrThrow()\n```\n\n### Soft Delete with deleteItem/deleteItems\n\n```typescript\n// When softDelete: true, deleteItem sets the deleted timestamp automatically\nconst PostEntity = Entity<\"posts\", Database>(client, \"posts\", { softDelete: true })\n\n// Soft delete a single item (sets deleted = timestamp)\nawait PostEntity.deleteItem({ where: { id: postId } }).executeOrThrow()\n\n// Soft delete multiple items\nawait PostEntity.deleteItems({ where: { status: \"archived\" } }).executeOrThrow()\n```\n\n### Hard Delete (Physical Removal)\n\n```typescript\n// When softDelete: false, deleteItem physically removes the row\nconst LogEntity = Entity<\"logs\", Database>(client, \"logs\", { softDelete: false })\n\n// Permanently delete a single item\nawait LogEntity.deleteItem({ where: { id: logId } }).executeOrThrow()\n\n// Permanently delete multiple items\nawait LogEntity.deleteItems({ where: { created_at: { lt: cutoffDate } } }).executeOrThrow()\n```\n\n### Restore Soft-Deleted Items\n\n```typescript\n// To restore, manually clear the deleted timestamp\nawait PostEntity.updateItem({\n  where: { id: postId },\n  data: { deleted: null },\n}).executeOrThrow()\n```\n\n## Error Handling Patterns\n\n### Explicit TaskOutcome Handling\n\n```typescript\nimport { Option } from \"functype\"\n\nasync function safeGetUser(userId: string): Promise<Option<User>> {\n  const result = await query<\"users\", Database>(client, \"users\", { id: userId }).one()\n\n  if (result.isOk()) {\n    return result.getOrThrow() // Returns Option<User>\n  }\n\n  // Log error, return None\n  console.error(\"Failed to fetch user:\", result.error)\n  return Option.none()\n}\n```\n\n### Error Recovery\n\n```typescript\nasync function getUserOrDefault(userId: string): Promise<User> {\n  try {\n    return await query<\"users\", Database>(client, \"users\", { id: userId }).oneOrThrow()\n  } catch (error) {\n    if (error instanceof SupabaseError && error.code === \"PGRST116\") {\n      // Not found - return default\n      return { id: userId, name: \"Unknown\", email: \"\" }\n    }\n    throw error\n  }\n}\n```\n\n### Validation Before Insert\n\n```typescript\nimport { Either, Left, Right } from \"functype\"\n\nasync function createUser(data: UserInput): Promise<Either<string, User>> {\n  // Validate\n  if (!data.email.includes(\"@\")) {\n    return Left(\"Invalid email format\")\n  }\n\n  try {\n    const [user] = await UserEntity.addItems({\n      items: [data],\n    }).executeOrThrow()\n    return Right(user)\n  } catch (error) {\n    if (error instanceof SupabaseError && error.code === \"23505\") {\n      return Left(\"Email already exists\")\n    }\n    return Left(\"Failed to create user\")\n  }\n}\n```\n\n## Pagination Patterns\n\n### Offset-Based Pagination\n\n```typescript\nasync function getPage(page: number, pageSize: number = 20) {\n  const offset = (page - 1) * pageSize\n\n  return await query<\"posts\", Database>(client, \"posts\", { status: \"published\" })\n    .limit(pageSize)\n    .offset(offset)\n    .manyOrThrow()\n}\n```\n\n### Cursor-Based Pagination\n\n```typescript\nasync function getPostsAfter(cursor: string | null, limit: number = 20) {\n  const baseQuery = query<\"posts\", Database>(\n    client,\n    \"posts\",\n    cursor ? { id: { gt: cursor }, status: \"published\" } : { status: \"published\" },\n  )\n\n  return await baseQuery.limit(limit).manyOrThrow()\n}\n```\n\n## Complex Query Examples\n\n### Date Range with Multiple Conditions\n\n```typescript\nconst thisWeeksPosts = await query<\"posts\", Database>(client, \"posts\", {\n  created_at: { gte: startOfWeek, lte: endOfWeek },\n  status: { in: [\"published\", \"featured\"] },\n  view_count: { gte: 100 },\n}).manyOrThrow()\n```\n\n### Search with Pattern Matching\n\n```typescript\nconst searchResults = await query<\"posts\", Database>(client, \"posts\", {\n  title: { ilike: `%${searchTerm}%` },\n})\n  .or({ content: { ilike: `%${searchTerm}%` } })\n  .limit(50)\n  .manyOrThrow()\n```\n\n### Null Checks\n\n```typescript\n// Find posts without published date (drafts) - IS NULL\nconst drafts = await query<\"posts\", Database>(client, \"posts\", {\n  published_at: { is: null },\n}).manyOrThrow()\n\n// Find posts with published date - IS NOT NULL (using NOT operator)\nconst published = await query<\"posts\", Database>(client, \"posts\", {\n  not: { is: { published_at: null } },\n}).manyOrThrow()\n\n// Find posts with external_id set\nconst linkedPosts = await query<\"posts\", Database>(client, \"posts\", {\n  status: \"published\",\n  not: { is: { external_id: null } },\n}).manyOrThrow()\n```\n\n### NOT IN Queries\n\n```typescript\n// Exclude specific statuses\nconst visiblePosts = await query<\"posts\", Database>(client, \"posts\", {\n  not: { in: { status: [\"draft\", \"archived\", \"spam\"] } },\n}).manyOrThrow()\n\n// Exclude multiple categories\nconst generalPosts = await query<\"posts\", Database>(client, \"posts\", {\n  status: \"published\",\n  not: { in: { category_id: [\"internal\", \"test\", \"admin\"] } },\n}).manyOrThrow()\n```\n\n### Combined NOT Conditions\n\n```typescript\n// Multiple NOT conditions in one query\nconst filteredPosts = await query<\"posts\", Database>(client, \"posts\", {\n  status: \"published\",\n  not: {\n    is: { deleted: null }, // IS NOT NULL (was soft deleted then restored)\n    in: { tag: [\"internal\", \"test\"] },\n  },\n}).manyOrThrow()\n\n// Entity API with NOT\nconst posts = await PostEntity.getItems({\n  where: { author_id: userId },\n  not: { is: { published_at: null } },\n}).manyOrThrow()\n```\n\n> **Note**: `neq: null` is deprecated. Use `not: { is: { field: null } }` for IS NOT NULL checks.\n\n## RPC (Stored Procedures) Patterns\n\n### Basic RPC Call\n\n```typescript\nimport { rpc } from \"supabase-typed-query\"\n\n// Call a function that returns aggregate data\nconst stats = await rpc<\"get_user_stats\", Database>(client, \"get_user_stats\", {\n  user_id: userId,\n}).oneOrThrow()\n\n// Call a function that returns multiple rows\nconst searchResults = await rpc<\"search_products\", Database>(client, \"search_products\", {\n  query: searchTerm,\n  limit: 20,\n}).manyOrThrow()\n```\n\n### RPC with Safe Error Handling\n\n```typescript\n// Using TaskOutcome for explicit error handling\nconst result = await rpc<\"calculate_totals\", Database>(client, \"calculate_totals\", {\n  order_id: orderId,\n}).one()\n\nif (result.isOk()) {\n  const maybeTotal = result.orThrow()\n  if (maybeTotal.isSome()) {\n    console.log(\"Total:\", maybeTotal.orElse(null))\n  } else {\n    console.log(\"No result returned\")\n  }\n} else {\n  console.error(\"RPC failed:\", result.error)\n}\n```\n\n### RPC for Bulk Operations\n\n```typescript\n// Functions that perform bulk operations\nconst migratedCount = await rpc<\"migrate_old_records\", Database>(client, \"migrate_old_records\", {\n  before_date: cutoffDate,\n  batch_size: 1000,\n}).oneOrThrow()\n\nconsole.log(`Migrated ${migratedCount} records`)\n```\n\n### RPC with No Arguments\n\n```typescript\n// Functions that take no arguments\nconst serverTime = await rpc<\"get_server_time\", Database>(client, \"get_server_time\").oneOrThrow()\n\nconst metrics = await rpc<\"get_system_metrics\", Database>(client, \"get_system_metrics\").manyOrThrow()\n```\n\n### RPC in Service Layer\n\n```typescript\nimport { Either, Left, Right } from \"functype\"\n\nasync function getUserDashboardData(userId: string): Promise<Either<string, DashboardData>> {\n  try {\n    const stats = await rpc<\"get_user_dashboard\", Database>(client, \"get_user_dashboard\", {\n      user_id: userId,\n    }).oneOrThrow()\n\n    return Right(stats)\n  } catch (error) {\n    if (error instanceof SupabaseError) {\n      return Left(`Database error: ${error.message}`)\n    }\n    return Left(\"Failed to load dashboard\")\n  }\n}\n```\n\n### Combining RPC with Queries\n\n```typescript\n// Get aggregate data via RPC, then query for details\nconst summary = await rpc<\"get_order_summary\", Database>(client, \"get_order_summary\", {\n  customer_id: customerId,\n}).oneOrThrow()\n\n// Use summary data to query related records\nconst recentOrders = await query<\"orders\", Database>(client, \"orders\", {\n  customer_id: customerId,\n  status: { in: [\"pending\", \"processing\"] },\n})\n  .limit(summary.pending_count)\n  .manyOrThrow()\n```\n\n## ViewEntity Patterns (Read-Only Views)\n\n### Basic View Queries\n\n```typescript\nimport { ViewEntity } from \"supabase-typed-query\"\n\n// Create a view entity (views are always read-only)\nconst AuthUsersView = ViewEntity<\"auth_users_view\", Database, \"agent_gate\">(client, \"auth_users_view\", {\n  schema: \"agent_gate\",\n})\n\n// Query the view\nconst user = await AuthUsersView.getItem({ id: userId }).oneOrThrow()\nconst activeUsers = await AuthUsersView.getItems({\n  where: { is_active: true },\n}).manyOrThrow()\n```\n\n### Aggregation Views\n\n```typescript\n// Views are perfect for pre-computed aggregations\nconst UserStatsView = ViewEntity<\"user_stats_view\", Database>(client, \"user_stats_view\")\n\n// Get stats for a user\nconst stats = await UserStatsView.getItem({ id: userId }).oneOrThrow()\nconsole.log(`Orders: ${stats.total_orders}, Spent: ${stats.total_spent}`)\n\n// Get top spenders\nconst topSpenders = await UserStatsView.getItems({\n  order: [\"total_spent\", { ascending: false }],\n}).manyOrThrow()\n```\n\n### Views with Custom Schema\n\n```typescript\n// Access views in non-public schemas\nconst AnalyticsView = ViewEntity<\"daily_metrics_view\", Database, \"analytics\">(client, \"daily_metrics_view\", {\n  schema: \"analytics\",\n})\n\nconst metrics = await AnalyticsView.getItems({\n  where: { date: { gte: startDate, lte: endDate } },\n}).manyOrThrow()\n```\n\n### Partitioned Views (Multi-Tenant)\n\n```typescript\nimport { PartitionedViewEntity } from \"supabase-typed-query\"\n\n// Tenant-scoped view for analytics\nconst TenantAnalyticsView = PartitionedViewEntity<\"tenant_metrics_view\", string, Database>(\n  client,\n  \"tenant_metrics_view\",\n  { partitionField: \"tenant_id\" },\n)\n\n// All queries automatically scoped to tenant\nconst metrics = await TenantAnalyticsView.getItems(tenantId, {\n  where: { period: \"monthly\" },\n  order: [\"date\", { ascending: false }],\n}).manyOrThrow()\n```\n\n### Type-Safe View with Branded Partition Key\n\n```typescript\nimport { ValidatedBrand } from \"functype\"\n\ntype TenantId = ValidatedBrand<string, \"TenantId\">\n\nconst TenantReportView = PartitionedViewEntity<\"tenant_reports_view\", TenantId, Database>(\n  client,\n  \"tenant_reports_view\",\n  { partitionField: \"tenant_id\", schema: \"reporting\" },\n)\n\n// Type-safe tenant key required\nconst tenantId = \"tenant-123\" as TenantId\nconst reports = await TenantReportView.getItems(tenantId, {\n  where: { status: \"completed\" },\n}).manyOrThrow()\n```\n\n### Views vs Tables: When to Use Each\n\n```typescript\n// Use ViewEntity when:\n// - Querying pre-computed aggregations\n// - Accessing data across schema boundaries (e.g., auth.users)\n// - Working with denormalized read-optimized views\n// - Data is naturally read-only\n\nconst AuthView = ViewEntity<\"auth_users_view\", Database>(client, \"auth_users_view\")\n\n// Use Entity when:\n// - You need CRUD operations\n// - Working with base tables\n// - Need soft delete functionality\n\nconst UserEntity = Entity<\"users\", Database>(client, \"users\", { softDelete: true })\n```\n",
        ".claude/skills/supabase-typed-query/references/quick-reference.md": "# Quick Reference\n\n## Query API\n\n### Creating Queries\n\n```typescript\nimport { query } from \"supabase-typed-query\"\n\nquery<TableName, Database>(client, \"table\", where?, is?, wherein?, order?, schema?)\n```\n\n### Query Methods\n\n| Method               | Returns            | Description                  |\n| -------------------- | ------------------ | ---------------------------- |\n| `.one()`             | `Task<Option<T>>`  | Expects 0-1 results          |\n| `.many()`            | `Task<List<T>>`    | Expects 0+ results           |\n| `.first()`           | `Task<Option<T>>`  | Gets first if multiple       |\n| `.oneOrThrow()`      | `Promise<T>`       | Throws if not found or error |\n| `.manyOrThrow()`     | `Promise<List<T>>` | Throws on error              |\n| `.firstOrThrow()`    | `Promise<T>`       | Throws if not found or error |\n| `.or(where, is?)`    | `Query<T>`         | Add OR condition             |\n| `.map(fn)`           | `MappedQuery<U>`   | Transform results            |\n| `.filter(predicate)` | `Query<T>`         | Filter results               |\n| `.limit(n)`          | `Query<T>`         | Limit results                |\n| `.offset(n)`         | `Query<T>`         | Skip first n results         |\n| `.includeDeleted()`  | `Query<T>`         | Include soft-deleted records |\n| `.excludeDeleted()`  | `Query<T>`         | Exclude soft-deleted records |\n| `.onlyDeleted()`     | `Query<T>`         | Only soft-deleted records    |\n\n### Comparison Operators\n\n```typescript\n{\n  gte: V        // >= (greater than or equal)\n  gt: V         // >  (greater than)\n  lte: V        // <= (less than or equal)\n  lt: V         // <  (less than)\n  neq: V        // != (not equal, use NOT for null)\n  like: string  // LIKE pattern (case-sensitive)\n  ilike: string // ILIKE pattern (case-insensitive)\n  in: V[]       // IN array\n  is: null | boolean  // IS NULL / IS TRUE / IS FALSE\n}\n```\n\n### NOT Operator\n\n```typescript\n{\n  not: {\n    is: { field: null | boolean }  // IS NOT NULL / IS NOT TRUE / IS NOT FALSE\n    in: { field: V[] }             // NOT IN array\n  }\n}\n```\n\n### Examples\n\n```typescript\n// Direct equality\n{ id: \"123\" }\n\n// Comparison operators\n{ created_at: { gte: startDate, lte: endDate } }\n\n// Pattern matching\n{ email: { ilike: \"%@example.com\" } }\n\n// IN clause\n{ status: { in: [\"active\", \"pending\"] } }\n\n// IS NULL\n{ deleted_at: { is: null } }\n\n// IS NOT NULL (using NOT operator)\n{ not: { is: { external_id: null } } }\n\n// NOT IN\n{ not: { in: { status: [\"draft\", \"spam\"] } } }\n```\n\n> **Note**: `neq: null` is deprecated. Use `not: { is: { field: null } }` for IS NOT NULL.\n\n## RPC API\n\n### Calling Stored Procedures\n\n```typescript\nimport { rpc } from \"supabase-typed-query\"\n\nrpc<FunctionName, Database>(client, \"function_name\", args?, options?)\n```\n\n### RPC Methods\n\n| Method           | Returns            | Description                   |\n| ---------------- | ------------------ | ----------------------------- |\n| `.one()`         | `Task<Option<T>>`  | Expects single result or none |\n| `.many()`        | `Task<List<T>>`    | Expects 0+ results as list    |\n| `.oneOrThrow()`  | `Promise<T>`       | Throws if not found or error  |\n| `.manyOrThrow()` | `Promise<List<T>>` | Throws on error               |\n\n### RPC Options\n\n```typescript\n{\n  schema?: string           // Database schema (defaults to \"public\")\n  count?: \"exact\" | \"planned\" | \"estimated\"  // Row count option\n}\n```\n\n### RPC Examples\n\n```typescript\n// Single result\nconst stats = await rpc<\"get_user_stats\", Database>(client, \"get_user_stats\", {\n  user_id: \"123\",\n}).oneOrThrow()\n\n// Multiple results\nconst products = await rpc<\"search_products\", Database>(client, \"search_products\", {\n  query: \"laptop\",\n  limit: 10,\n}).manyOrThrow()\n\n// No arguments\nconst count = await rpc<\"get_total_count\", Database>(client, \"get_total_count\").oneOrThrow()\n```\n\n### RPC Types\n\n```typescript\nimport type { FunctionNames, FunctionArgs, FunctionReturns, RpcExecution, RpcOptions } from \"supabase-typed-query\"\n\n// Get all function names from schema\ntype Functions = FunctionNames<Database>\n\n// Get function argument type\ntype Args = FunctionArgs<\"get_user_stats\", Database>\n\n// Get function return type\ntype Returns = FunctionReturns<\"get_user_stats\", Database>\n```\n\n## Entity API\n\n### Standard Entity\n\n```typescript\nimport { Entity } from \"supabase-typed-query\"\n\nconst MyEntity = Entity<\"table\", Database>(client, \"table\", {\n  softDelete: boolean,\n  schema?: string, // Optional: defaults to \"public\"\n})\n```\n\n| Method                               | Returns                      | Description                         |\n| ------------------------------------ | ---------------------------- | ----------------------------------- |\n| `.getItem({ id, ... })`              | `Query<T>`                   | Get single by ID                    |\n| `.getItems({ ... })`                 | `Query<T>`                   | Get multiple items                  |\n| `.addItems({ items })`               | `MutationMultiExecution<T>`  | Insert items                        |\n| `.updateItem({ where, data })`       | `MutationSingleExecution<T>` | Update single item                  |\n| `.updateItems({ where, data })`      | `MutationMultiExecution<T>`  | Update multiple items               |\n| `.upsertItems({ items, identity? })` | `MutationMultiExecution<T>`  | Upsert items                        |\n| `.deleteItem({ where })`             | `MutationSingleExecution<T>` | Delete single item (soft/hard)\\*    |\n| `.deleteItems({ where })`            | `MutationMultiExecution<T>`  | Delete multiple items (soft/hard)\\* |\n\n\\* When `softDelete: true`, delete methods set the `deleted` timestamp instead of removing rows.\n\n### PartitionedEntity\n\n```typescript\nimport { PartitionedEntity } from \"supabase-typed-query\"\n\nconst MyEntity = PartitionedEntity<\"table\", KeyType, Database>(client, \"table\", {\n  partitionField: \"tenant_id\",\n  softDelete: boolean,\n  schema?: string, // Optional: defaults to \"public\"\n})\n```\n\nAll methods take partition key as first argument:\n\n```typescript\nMyEntity.getItem(partitionKey, { id, ... })\nMyEntity.getItems(partitionKey, { ... })\nMyEntity.updateItem(partitionKey, { where, data })\nMyEntity.deleteItem(partitionKey, { where })  // soft/hard based on config\nMyEntity.deleteItems(partitionKey, { where }) // soft/hard based on config\n```\n\n### Parameter Types\n\n```typescript\n// GetItemParams\n{ id: string, where?: WhereConditions, is?: IsConditions }\n\n// GetItemsParams\n{ where?: WhereConditions, is?: IsConditions, wherein?: WhereinConditions, order?: OrderParams }\n\n// AddItemsParams\n{ items: TableInsert[] }\n\n// UpdateItemParams / UpdateItemsParams\n{ where: WhereConditions, data: TableUpdate, is?: IsConditions, wherein?: WhereinConditions }\n\n// UpsertItemsParams\n{ items: TableUpdate[], identity?: string | string[] }\n\n// DeleteItemParams / DeleteItemsParams\n{ where: WhereConditions, is?: IsConditions, wherein?: WhereinConditions }\n\n// OrderParams\n[columnName, { ascending?: boolean, nullsFirst?: boolean }]\n```\n\n### ViewEntity (Read-Only Views)\n\n```typescript\nimport { ViewEntity } from \"supabase-typed-query\"\n\nconst MyView = ViewEntity<\"view_name\", Database>(client, \"view_name\", {\n  schema?: string, // Optional: defaults to \"public\"\n})\n```\n\n| Method               | Returns    | Description        |\n| -------------------- | ---------- | ------------------ |\n| `.getItem({ id })`   | `Query<T>` | Get single by ID   |\n| `.getItems({ ... })` | `Query<T>` | Get multiple items |\n\n**Note:** Views are read-only. No `addItems`, `updateItem`, `deleteItem`, or `softDelete` methods.\n\n### PartitionedViewEntity\n\n```typescript\nimport { PartitionedViewEntity } from \"supabase-typed-query\"\n\nconst MyView = PartitionedViewEntity<\"view_name\", KeyType, Database>(client, \"view_name\", {\n  partitionField: \"tenant_id\",\n  schema?: string, // Optional: defaults to \"public\"\n})\n```\n\nAll methods take partition key as first argument:\n\n```typescript\nMyView.getItem(partitionKey, { id, ... })\nMyView.getItems(partitionKey, { ... })\n```\n\n## Type Utilities\n\n```typescript\nimport type {\n  TableNames,\n  TableRow,\n  TableInsert,\n  TableUpdate,\n  ViewNames,\n  ViewRow,\n  DatabaseSchema,\n  SchemaNames,\n  TypedDatabase,\n  ValidSchema,\n  DEFAULT_SCHEMA,\n} from \"supabase-typed-query\"\n\n// Get all schema names (excludes __InternalSupabase automatically)\ntype Schemas = SchemaNames<Database>\n\n// Get all table names (defaults to public schema)\ntype Tables = TableNames<Database>\n\n// Get table names from a specific schema\ntype InventoryTables = TableNames<Database, \"inventory\">\n\n// Get row type for a table (defaults to public schema)\ntype UserRow = TableRow<\"users\", Database>\n\n// Get row type from a custom schema\ntype ItemRow = TableRow<\"items\", Database, \"inventory\">\n\n// Get insert type for a table\ntype UserInsert = TableInsert<\"users\", Database>\n\n// Get update type for a table\ntype UserUpdate = TableUpdate<\"users\", Database>\n\n// Get all view names (defaults to public schema)\ntype Views = ViewNames<Database>\n\n// Get view names from a specific schema\ntype AnalyticsViews = ViewNames<Database, \"analytics\">\n\n// Get row type for a view (views are read-only, only have Row type)\ntype StatsRow = ViewRow<\"user_stats_view\", Database>\n\n// Get view row type from a custom schema\ntype DailyStatsRow = ViewRow<\"daily_stats_view\", Database, \"analytics\">\n\n// Strip __InternalSupabase from Database type (optional - SchemaNames handles this automatically)\ntype CleanDB = TypedDatabase<Database>\n\n// Type-safe schema access (returns never for invalid schemas)\ntype PublicSchema = ValidSchema<Database, \"public\">\n```\n\n## Re-exported from functype\n\n```typescript\nimport { IO, List, Option, Task } from \"supabase-typed-query\"\n```\n\n## Error Handling\n\n```typescript\nimport { SupabaseError, toError } from \"supabase-typed-query\"\n\n// SupabaseError properties\nerror.code // PostgreSQL error code\nerror.details // Additional details\nerror.hint // Hint for fixing\nerror.message // Error message\n```\n\n## Type Guards\n\n```typescript\nimport { isQuery, isMappedQuery } from \"supabase-typed-query\"\n\nif (isQuery(obj)) {\n  // obj is Query<T>\n}\n\nif (isMappedQuery(obj)) {\n  // obj is MappedQuery<U>\n}\n```\n",
        "README.md": "# supabase-typed-query\n\nType-safe query builder and entity pattern for Supabase with TypeScript.\n\n## Features\n\n- 🔒 **Full TypeScript type safety** - Leverage your database types for compile-time safety\n- 🔗 **Chainable query API** - Build complex queries with OR conditions and functional operations\n- 🎯 **Entity pattern** - Consistent CRUD operations across all tables\n- 👁️ **View support** - Read-only ViewEntity for querying database views\n- 🚀 **Functional programming** - Built with functype for robust error handling\n- ⚡ **Zero runtime overhead** - All type checking happens at compile time\n- 🔄 **Composable queries** - Mix and match conditions, filters, and transformations\n- 🗑️ **Soft delete support** - Built-in soft delete filtering with per-query overrides\n- 🏢 **Multi-tenancy ready** - Automatic partition key filtering for tenant isolation\n- 🗄️ **Custom schema support** - Query tables and views in any PostgreSQL schema\n\n## Installation\n\n```bash\nnpm install supabase-typed-query functype\n# or\npnpm add supabase-typed-query functype\n# or\nyarn add supabase-typed-query functype\n```\n\n### Compatibility\n\n| Dependency              | Version    | Notes                               |\n| ----------------------- | ---------- | ----------------------------------- |\n| `@supabase/supabase-js` | `^2.0.0`   | Tested with 2.86.x                  |\n| `functype`              | `>=0.20.1` | Required for error handling         |\n| TypeScript              | `>=5.0`    | Recommended for best type inference |\n| Node.js                 | `>=18`     | Required                            |\n\n## Quick Start\n\n### 1. Set up your database types\n\nFirst, generate your database types from Supabase:\n\n```bash\nnpx supabase gen types typescript --project-id your-project-id > database.types.ts\n```\n\n### 2. Create a typed client\n\n```typescript\nimport { createClient } from \"@supabase/supabase-js\"\nimport type { Database } from \"./database.types\"\n\nconst supabase = createClient<Database>(\"your-supabase-url\", \"your-anon-key\")\n```\n\n### 3. Use the Query Builder\n\n```typescript\nimport { query } from \"supabase-typed-query\"\n\n// Simple query\nconst user = await query(supabase, \"users\", { id: \"123\" }).one()\n\n// Query with OR conditions\nconst posts = await query(supabase, \"posts\", { status: \"published\" }).or({ status: \"draft\", author_id: userId }).many()\n\n// Query with functional operations\nconst titles = await query(supabase, \"posts\", { status: \"published\" })\n  .map((post) => post.title)\n  .filter((title) => title.length > 10)\n  .many()\n```\n\n### 4. Use the Entity Pattern\n\n```typescript\nimport { Entity } from \"supabase-typed-query\"\n\n// Create an entity for your table with configuration\nconst PostEntity = Entity(supabase, \"posts\", {\n  softDelete: true, // Automatically exclude soft-deleted items\n})\n\n// Get all posts\nconst posts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// Get a single post\nconst post = await PostEntity.getItem({\n  id: \"post-123\",\n  where: { status: \"published\" },\n}).one()\n\n// Add posts\nconst newPosts = await PostEntity.addItems({\n  items: [{ title: \"New Post\", content: \"Content here\", status: \"draft\" }],\n}).execute()\n\n// Update a post\nconst updated = await PostEntity.updateItem({\n  id: \"post-123\",\n  item: { status: \"published\" },\n}).execute()\n```\n\n## Advanced Usage\n\n### Comparison Operators\n\n```typescript\n// Greater than / Less than\nconst recentPosts = await query(supabase, \"posts\", {\n  created_at: { gte: new Date(\"2024-01-01\") },\n}).many()\n\n// Pattern matching\nconst searchResults = await query(supabase, \"posts\", {\n  title: { ilike: \"%typescript%\" },\n}).many()\n\n// IN queries\nconst selectedPosts = await query(supabase, \"posts\", {\n  id: { in: [\"id1\", \"id2\", \"id3\"] },\n}).many()\n\n// IS NULL checks\nconst drafts = await query(supabase, \"posts\", {\n  published_at: { is: null },\n}).many()\n\n// IS NOT NULL checks (using NOT operator)\nconst publishedPosts = await query(supabase, \"posts\", {\n  not: { is: { published_at: null } },\n}).many()\n\n// NOT IN queries\nconst activePosts = await query(supabase, \"posts\", {\n  not: { in: { status: [\"draft\", \"archived\"] } },\n}).many()\n```\n\n### NOT Operator\n\nThe `not` operator follows Supabase conventions for negating conditions:\n\n```typescript\n// IS NOT NULL - find posts with external_id set\nconst linkedPosts = await PostEntity.getItems({\n  not: { is: { external_id: null } },\n}).many()\n\n// IS NOT TRUE / IS NOT FALSE\nconst nonFeatured = await PostEntity.getItems({\n  not: { is: { featured: true } },\n}).many()\n\n// NOT IN - exclude specific statuses\nconst visiblePosts = await PostEntity.getItems({\n  not: { in: { status: [\"spam\", \"trash\", \"deleted\"] } },\n}).many()\n\n// Combine NOT with other conditions\nconst activeLinkedPosts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  not: { is: { external_id: null } },\n}).many()\n```\n\n> **Note**: `neq: null` is deprecated. Use `not: { is: { field: null } }` instead for IS NOT NULL checks.\n\n### Chaining OR Conditions\n\n```typescript\nconst results = await query(supabase, \"users\", { role: \"admin\" })\n  .or({ role: \"moderator\" })\n  .or({ role: \"editor\", active: true })\n  .many()\n```\n\n### Soft Deletes\n\nControl soft delete behavior at the Entity or Query level:\n\n```typescript\n// Entity with soft deletes enabled (excludes deleted by default)\nconst UserEntity = Entity(supabase, \"users\", {\n  softDelete: true, // Automatically filters out deleted items\n})\n\n// Override soft delete behavior per query\nconst allUsers = await UserEntity.getItems().includeDeleted().many()\nconst deletedOnly = await UserEntity.getItems().onlyDeleted().many()\nconst activeOnly = await UserEntity.getItems().excludeDeleted().many() // Redundant - already excluded\n\n// Entity without soft deletes (includes all items)\nconst AdminEntity = Entity(supabase, \"users\", {\n  softDelete: false, // No automatic filtering\n})\n```\n\n### Custom Schema Support\n\nQuery tables in any PostgreSQL schema (not just the default `public` schema):\n\n```typescript\nimport { Entity, PartitionedEntity, query } from \"supabase-typed-query\"\n\n// Entity with custom schema\nconst InventoryEntity = Entity(supabase, \"items\", {\n  softDelete: false,\n  schema: \"inventory\", // Uses client.schema(\"inventory\").from(\"items\")\n})\n\nconst items = await InventoryEntity.getItems({ where: { active: true } }).many()\n\n// PartitionedEntity with custom schema\nconst TenantItemsEntity = PartitionedEntity(supabase, \"items\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n  schema: \"tenant_data\",\n})\n\n// Query API with custom schema (7th parameter)\nconst results = await query(\n  supabase,\n  \"items\",\n  { active: true },\n  undefined, // is conditions\n  undefined, // wherein conditions\n  undefined, // order\n  \"inventory\", // schema\n).many()\n```\n\nWhen no schema is specified, queries use the default `public` schema via `client.from()`. When a schema is specified, queries use `client.schema(name).from(table)`.\n\n### View Entities (Read-Only)\n\nDatabase views in Supabase are read-only and only have a `Row` type (no `Insert` or `Update`). Use `ViewEntity` for type-safe querying of views:\n\n```typescript\nimport { ViewEntity, PartitionedViewEntity } from \"supabase-typed-query\"\n\n// Create a read-only view entity\nconst AuthUsersView = ViewEntity(supabase, \"auth_users_view\", {\n  schema: \"agent_gate\", // Optional: defaults to \"public\"\n})\n\n// Query the view - only getItem and getItems are available\nconst user = await AuthUsersView.getItem({ id: \"123\" }).one()\nconst activeUsers = await AuthUsersView.getItems({\n  where: { is_active: true },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// For multi-tenant views, use PartitionedViewEntity\nconst TenantStatsView = PartitionedViewEntity(supabase, \"tenant_stats_view\", {\n  partitionField: \"tenant_id\",\n})\n\n// All queries require partition key\nconst stats = await TenantStatsView.getItems(tenantId, {\n  where: { period: \"monthly\" },\n}).many()\n```\n\n**Key differences from Entity:**\n\n- Only `getItem()` and `getItems()` methods (no write operations)\n- No `softDelete` configuration (views are read-only snapshots)\n- Uses `ViewNames` and `ViewRow` types instead of `TableNames` and `TableRow`\n\n### Multi-Tenancy with Partition Keys\n\nUse partition keys to automatically scope queries to a tenant or partition:\n\n```typescript\n// Create a tenant-scoped entity\nconst TenantPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  partitionKey: { tenant_id: \"tenant-123\" }, // All queries automatically include this filter\n})\n\n// All queries are automatically scoped to the tenant\nconst tenantPosts = await TenantPostEntity.getItems({\n  where: { status: \"published\" },\n}).many()\n// Equivalent to: WHERE tenant_id = 'tenant-123' AND status = 'published' AND deleted IS NULL\n\n// Create a global/admin entity (no partition)\nconst GlobalPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  // No partitionKey - queries all tenants\n})\n\nconst allPosts = await GlobalPostEntity.getItems().many()\n// Equivalent to: WHERE deleted IS NULL\n```\n\n### Error Handling\n\nThe library uses functype's `TaskOutcome` for error handling:\n\n```typescript\n// Using TaskOutcome (recommended for explicit error handling)\nconst result = await query(supabase, \"users\", { id: userId }).one()\n\nif (result.isOk()) {\n  const maybeUser = result.getOrThrow()\n  if (maybeUser.isSome()) {\n    console.log(\"User found:\", maybeUser.getOrThrow())\n  }\n} else {\n  console.error(\"Query failed:\", result.error)\n}\n\n// Using OrThrow methods (simpler but throws errors)\ntry {\n  const user = await query(supabase, \"users\", { id: userId }).oneOrThrow()\n  console.log(\"User:\", user)\n} catch (error) {\n  console.error(\"Query failed:\", error)\n}\n```\n\n### Type Safety\n\nAll operations are fully type-safe based on your database schema:\n\n```typescript\n// TypeScript will enforce correct field names and types\nconst posts = await query(supabase, \"posts\", {\n  // ✅ TypeScript knows these fields exist and their types\n  title: \"My Post\",\n  published: true,\n  view_count: { gte: 100 },\n\n  // ❌ TypeScript error: property doesn't exist\n  nonexistent_field: \"value\",\n}).many()\n```\n\n## API Reference\n\n### Query Methods\n\n- `one()` - Execute query expecting exactly one result\n- `many()` - Execute query expecting zero or more results\n- `first()` - Execute query expecting first result from potentially multiple\n- `oneOrThrow()` - Like `one()` but throws if not found\n- `manyOrThrow()` - Like `many()` but throws on error\n- `firstOrThrow()` - Like `first()` but throws if not found\n\n### Query Composition\n\n- `or(conditions)` - Add OR conditions to the query\n- `map(fn)` - Transform results with a mapping function\n- `filter(fn)` - Filter results with a predicate\n- `limit(n)` - Limit the number of results\n- `offset(n)` - Skip the first n results\n- `includeDeleted()` - Include soft-deleted items in results\n- `excludeDeleted()` - Exclude soft-deleted items from results\n- `onlyDeleted()` - Return only soft-deleted items\n\n### Entity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n- `addItems({ items })` - Add multiple items\n- `updateItem({ id, item, where?, is?, wherein? })` - Update a single item\n- `updateItems({ items, identity?, where?, is?, wherein? })` - Update multiple items\n\n### Entity Configuration\n\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items; when `false`, includes them\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### ViewEntity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n\n> **Note:** ViewEntity only supports read operations. No `addItems`, `updateItem`, `deleteItem`, or soft delete methods.\n\n### ViewEntity Configuration\n\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedViewEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n## Requirements\n\n- TypeScript 5.0+\n- Supabase JS Client v2\n- functype 0.14+\n\n## License\n\nMIT\n\n## Development\n\n### Setup\n\n```bash\n# Clone the repository\ngit clone https://github.com/jordanburke/supabase-typed-query.git\ncd supabase-typed-query\n\n# Install dependencies\npnpm install\n\n# Run validation pipeline\npnpm validate\n```\n\n### Commands\n\n```bash\n# Development\npnpm validate          # Run full validation: format, lint, typecheck, test, build\npnpm test             # Run tests\npnpm test:watch       # Run tests in watch mode\npnpm test:coverage    # Run tests with coverage\npnpm build            # Build for production\npnpm build:dev:watch  # Build in watch mode for development\n\n# Code Quality\npnpm format           # Format code with Prettier\npnpm lint             # Fix ESLint issues\npnpm typecheck        # Type check with TypeScript\n```\n\n### CI/CD Pipeline\n\nThis project uses GitHub Actions for continuous integration and deployment:\n\n#### Continuous Integration\n\n- **Triggered on**: Push/PR to main/develop branches\n- **Test matrix**: Node.js 18.x, 20.x, 22.x\n- **Pipeline**: Format → Lint → Type Check → Test → Build\n\n#### Release Process\n\n1. Update version in `package.json`\n2. Create and push a version tag:\n   ```bash\n   git tag v1.0.0\n   git push origin v1.0.0\n   ```\n3. GitHub Actions automatically:\n   - Runs full validation pipeline\n   - Publishes to NPM registry\n   - Creates GitHub release\n\n#### Security\n\n- CodeQL analysis runs on all PRs and weekly scheduled scans\n- Dependency updates via Dependabot\n\n### Publishing\n\nThe package is automatically published to NPM when a version tag is pushed. Manual publishing:\n\n```bash\n# Ensure you're logged into NPM\nnpm login\n\n# Run validation and publish\npnpm build:publish\n```\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n### Development Guidelines\n\n1. **Type Safety**: Maintain strict TypeScript types, no `any`\n2. **Functional Style**: Use functional programming patterns with functype\n3. **Testing**: Add tests for new features\n4. **Documentation**: Update README for API changes\n5. **Commits**: Follow conventional commits format\n\n### Pull Request Process\n\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/amazing-feature`)\n3. Run `pnpm validate` to ensure all checks pass\n4. Commit your changes (`git commit -m 'feat: add amazing feature'`)\n5. Push to the branch (`git push origin feature/amazing-feature`)\n6. Open a Pull Request\n\nTests will automatically run via GitHub Actions on your PR.\n",
        "test/integration/README.md": "# Integration Tests Status\n\n## Current Status\n\nThe integration test infrastructure is **complete with Supabase CLI integration**. Tests use auto-generated types from the local Supabase database via `supabase gen types typescript`.\n\n### What's Working ✅\n\n1. **Supabase Local Development**\n   - ✅ Supabase CLI initialized (`supabase/` directory)\n   - ✅ Database migration from `schema.sql` → `supabase/migrations/20250127000000_initial_schema.sql`\n   - ✅ Auto-generated TypeScript types in `database.types.ts`\n   - ✅ Type augmentation file (`augment-database-types.ts`) for test schema\n\n2. **Test Infrastructure**\n   - ✅ SQL schema file with users, posts, comments tables\n   - ✅ Database setup helpers (`database-setup.ts`) with batch data creation\n   - ✅ Environment configuration (`setup.ts`) for Supabase/PostgREST\n   - ✅ npm scripts for Supabase operations\n\n3. **Test Files**\n   - ✅ `Database.integration.spec.ts` - 2 tests for basic connectivity\n   - ✅ `Query.integration.spec.ts` - 33 tests for Query API\n   - ✅ `QueryAdvanced.integration.spec.ts` - 19 tests for advanced scenarios\n   - ⚠️ `Entity.integration.spec.ts.disabled` - 20 tests (needs API rewrite)\n\n### Architecture Decision\n\n**Integration tests are excluded from TypeScript compilation and ESLint checks** (see `tsconfig.json` and `eslint.config.mjs`).\n\nThis is a pragmatic solution for the following reasons:\n\n1. **TypeScript Module Augmentation Limitation**: The library uses a global `Database` interface that users augment with their schema. TypeScript's declaration merging doesn't allow replacing the generic `Record<string, ...>` type with specific table definitions in tests.\n\n2. **Common Pattern**: It's common for integration tests to be excluded from strict type checking since they:\n   - Test runtime behavior against real databases\n   - May use test-specific type assertions\n   - Focus on functional correctness rather than compile-time safety\n\n3. **Unit Test Coverage**: The library has 131 passing unit tests that provide comprehensive type safety coverage with mocks.\n\n### Why Integration Tests Are Excluded ⚠️\n\n**TypeScript Module Augmentation Issue**\n\nThe library uses a global `Database` interface that users augment with their schema:\n\n```typescript\n// src/types.ts\nexport interface Database {\n  public: {\n    Tables: Record<string, { Row: ..., Insert: ..., Update: ... }>\n  }\n}\n```\n\nIntegration tests need to augment this with `TestDatabase`, but TypeScript's declaration merging doesn't allow replacing the `Tables` property type (from `Record<string, ...>` to specific table definitions).\n\n**Solutions Considered:**\n\n1. ❌ Module augmentation with `extends` - TypeScript type conflict\n2. ❌ Module augmentation with property replacement - Declaration merging error\n3. ❌ Generic parameter approach - Too invasive, requires rewriting entire API\n4. ✅ Exclude from typecheck - Pragmatic solution, tests still run\n\n### npm Scripts\n\nThe following npm scripts are available for Supabase operations:\n\n```bash\n# Start local Supabase (applies migrations automatically)\npnpm supabase:start\n\n# Stop local Supabase\npnpm supabase:stop\n\n# Check Supabase status and connection details\npnpm supabase:status\n\n# Regenerate TypeScript types from database\npnpm supabase:types\n```\n\n### Running Integration Tests\n\n**Quick Start with Supabase CLI (Recommended):**\n\n```bash\n# 1. Start local Supabase (migration auto-applies)\npnpm supabase:start\n\n# 2. Run integration tests (uses local Supabase automatically)\npnpm test:integration\n```\n\n**Manual Database Setup (Alternative):**\n\nIf you prefer to use an existing database instead of Supabase local:\n\n1. Create a `.env.integration` or `.env.test` file:\n\n   ```env\n   TEST_SUPABASE_URL=http://localhost:54321\n   TEST_SUPABASE_ANON_KEY=your-anon-key\n   # OR for PostgREST\n   TEST_POSTGREST_URL=http://localhost:3000\n   TEST_POSTGREST_ANON_KEY=your-key\n   ```\n\n2. Apply the schema:\n\n   ```bash\n   psql -d your_database -f supabase/migrations/20250127000000_initial_schema.sql\n   ```\n\n3. Run the tests:\n   ```bash\n   pnpm test:integration\n   ```\n\n### Regenerating Types After Schema Changes\n\nIf you modify the database schema:\n\n```bash\n# 1. Update the migration file\nvim supabase/migrations/20250127000000_initial_schema.sql\n\n# 2. Restart Supabase to apply changes\npnpm supabase:stop\npnpm supabase:start\n\n# 3. Regenerate TypeScript types\npnpm supabase:types\n\n# 4. Run tests to verify\npnpm test:integration\n```\n\n## Test Files Status\n\n| File                                | Status       | Tests | Notes                                     |\n| ----------------------------------- | ------------ | ----- | ----------------------------------------- |\n| `Database.integration.spec.ts`      | ✅ Working   | 2     | Basic connectivity tests                  |\n| `Query.integration.spec.ts`         | ✅ Working   | 33    | Full Query API coverage                   |\n| `QueryAdvanced.integration.spec.ts` | ✅ Working   | 19    | Advanced query scenarios                  |\n| `Entity.integration.spec.ts`        | ⚠️ Needs Fix | 20    | Wrong API - needs rewrite to match Entity |\n\n## Next Steps\n\n1. **Rewrite Entity tests** - Match actual Entity API (`getItems()`, `addItems()`, etc.)\n2. **Optional: Generic parameter** - If willing to make breaking API change for v2.0\n3. **Document patterns** - How users should write their own integration tests\n\n---\n\n**Note**: The 131 unit tests provide excellent coverage of all functionality. Integration tests are supplementary for catching database-specific edge cases and serve as examples for users implementing their own integration tests.\n"
      },
      "plugins": [
        {
          "name": "supabase-typed-query",
          "description": "Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/supabase-typed-query"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/supabase-typed-query",
            "/plugin install supabase-typed-query@supabase-typed-query-skills"
          ]
        }
      ]
    }
  ]
}