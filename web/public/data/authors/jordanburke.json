{
  "author": {
    "id": "jordanburke",
    "display_name": "Jordan",
    "avatar_url": "https://avatars.githubusercontent.com/u/67263?v=4"
  },
  "marketplaces": [
    {
      "name": "supabase-typed-query-skills",
      "version": null,
      "description": "Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns",
      "repo_full_name": "jordanburke/supabase-typed-query",
      "repo_url": "https://github.com/jordanburke/supabase-typed-query",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-11T21:35:36Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"supabase-typed-query-skills\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"supabase-typed-query\",\n      \"description\": \"Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/supabase-typed-query\"]\n    }\n  ]\n}\n",
        "README.md": "# supabase-typed-query\n\nType-safe query builder and entity pattern for Supabase with TypeScript.\n\n## Features\n\n- ðŸ”’ **Full TypeScript type safety** - Leverage your database types for compile-time safety\n- ðŸ”— **Chainable query API** - Build complex queries with OR conditions and functional operations\n- ðŸŽ¯ **Entity pattern** - Consistent CRUD operations across all tables\n- ðŸ‘ï¸ **View support** - Read-only ViewEntity for querying database views\n- ðŸš€ **Functional programming** - Built with functype for robust error handling\n- âš¡ **Zero runtime overhead** - All type checking happens at compile time\n- ðŸ”„ **Composable queries** - Mix and match conditions, filters, and transformations\n- ðŸ—‘ï¸ **Soft delete support** - Built-in soft delete filtering with per-query overrides\n- ðŸ¢ **Multi-tenancy ready** - Automatic partition key filtering for tenant isolation\n- ðŸ—„ï¸ **Custom schema support** - Query tables and views in any PostgreSQL schema\n\n## Installation\n\n```bash\nnpm install supabase-typed-query functype\n# or\npnpm add supabase-typed-query functype\n# or\nyarn add supabase-typed-query functype\n```\n\n### Compatibility\n\n| Dependency              | Version    | Notes                               |\n| ----------------------- | ---------- | ----------------------------------- |\n| `@supabase/supabase-js` | `^2.0.0`   | Tested with 2.86.x                  |\n| `functype`              | `>=0.20.1` | Required for error handling         |\n| TypeScript              | `>=5.0`    | Recommended for best type inference |\n| Node.js                 | `>=18`     | Required                            |\n\n## Quick Start\n\n### 1. Set up your database types\n\nFirst, generate your database types from Supabase:\n\n```bash\nnpx supabase gen types typescript --project-id your-project-id > database.types.ts\n```\n\n### 2. Create a typed client\n\n```typescript\nimport { createClient } from \"@supabase/supabase-js\"\nimport type { Database } from \"./database.types\"\n\nconst supabase = createClient<Database>(\"your-supabase-url\", \"your-anon-key\")\n```\n\n### 3. Use the Query Builder\n\n```typescript\nimport { query } from \"supabase-typed-query\"\n\n// Simple query\nconst user = await query(supabase, \"users\", { id: \"123\" }).one()\n\n// Query with OR conditions\nconst posts = await query(supabase, \"posts\", { status: \"published\" }).or({ status: \"draft\", author_id: userId }).many()\n\n// Query with functional operations\nconst titles = await query(supabase, \"posts\", { status: \"published\" })\n  .map((post) => post.title)\n  .filter((title) => title.length > 10)\n  .many()\n```\n\n### 4. Use the Entity Pattern\n\n```typescript\nimport { Entity } from \"supabase-typed-query\"\n\n// Create an entity for your table with configuration\nconst PostEntity = Entity(supabase, \"posts\", {\n  softDelete: true, // Automatically exclude soft-deleted items\n})\n\n// Get all posts\nconst posts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// Get a single post\nconst post = await PostEntity.getItem({\n  id: \"post-123\",\n  where: { status: \"published\" },\n}).one()\n\n// Add posts\nconst newPosts = await PostEntity.addItems({\n  items: [{ title: \"New Post\", content: \"Content here\", status: \"draft\" }],\n}).execute()\n\n// Update a post\nconst updated = await PostEntity.updateItem({\n  id: \"post-123\",\n  item: { status: \"published\" },\n}).execute()\n```\n\n## Advanced Usage\n\n### Comparison Operators\n\n```typescript\n// Greater than / Less than\nconst recentPosts = await query(supabase, \"posts\", {\n  created_at: { gte: new Date(\"2024-01-01\") },\n}).many()\n\n// Pattern matching\nconst searchResults = await query(supabase, \"posts\", {\n  title: { ilike: \"%typescript%\" },\n}).many()\n\n// IN queries\nconst selectedPosts = await query(supabase, \"posts\", {\n  id: { in: [\"id1\", \"id2\", \"id3\"] },\n}).many()\n\n// IS NULL checks\nconst drafts = await query(supabase, \"posts\", {\n  published_at: { is: null },\n}).many()\n\n// IS NOT NULL checks (using NOT operator)\nconst publishedPosts = await query(supabase, \"posts\", {\n  not: { is: { published_at: null } },\n}).many()\n\n// NOT IN queries\nconst activePosts = await query(supabase, \"posts\", {\n  not: { in: { status: [\"draft\", \"archived\"] } },\n}).many()\n```\n\n### NOT Operator\n\nThe `not` operator follows Supabase conventions for negating conditions:\n\n```typescript\n// IS NOT NULL - find posts with external_id set\nconst linkedPosts = await PostEntity.getItems({\n  not: { is: { external_id: null } },\n}).many()\n\n// IS NOT TRUE / IS NOT FALSE\nconst nonFeatured = await PostEntity.getItems({\n  not: { is: { featured: true } },\n}).many()\n\n// NOT IN - exclude specific statuses\nconst visiblePosts = await PostEntity.getItems({\n  not: { in: { status: [\"spam\", \"trash\", \"deleted\"] } },\n}).many()\n\n// Combine NOT with other conditions\nconst activeLinkedPosts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  not: { is: { external_id: null } },\n}).many()\n```\n\n> **Note**: `neq: null` is deprecated. Use `not: { is: { field: null } }` instead for IS NOT NULL checks.\n\n### Chaining OR Conditions\n\n```typescript\nconst results = await query(supabase, \"users\", { role: \"admin\" })\n  .or({ role: \"moderator\" })\n  .or({ role: \"editor\", active: true })\n  .many()\n```\n\n### Soft Deletes\n\nControl soft delete behavior at the Entity or Query level:\n\n```typescript\n// Entity with soft deletes enabled (excludes deleted by default)\nconst UserEntity = Entity(supabase, \"users\", {\n  softDelete: true, // Automatically filters out deleted items\n})\n\n// Override soft delete behavior per query\nconst allUsers = await UserEntity.getItems().includeDeleted().many()\nconst deletedOnly = await UserEntity.getItems().onlyDeleted().many()\nconst activeOnly = await UserEntity.getItems().excludeDeleted().many() // Redundant - already excluded\n\n// Entity without soft deletes (includes all items)\nconst AdminEntity = Entity(supabase, \"users\", {\n  softDelete: false, // No automatic filtering\n})\n```\n\n### Custom Schema Support\n\nQuery tables in any PostgreSQL schema (not just the default `public` schema):\n\n```typescript\nimport { Entity, PartitionedEntity, query } from \"supabase-typed-query\"\n\n// Entity with custom schema\nconst InventoryEntity = Entity(supabase, \"items\", {\n  softDelete: false,\n  schema: \"inventory\", // Uses client.schema(\"inventory\").from(\"items\")\n})\n\nconst items = await InventoryEntity.getItems({ where: { active: true } }).many()\n\n// PartitionedEntity with custom schema\nconst TenantItemsEntity = PartitionedEntity(supabase, \"items\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n  schema: \"tenant_data\",\n})\n\n// Query API with custom schema (7th parameter)\nconst results = await query(\n  supabase,\n  \"items\",\n  { active: true },\n  undefined, // is conditions\n  undefined, // wherein conditions\n  undefined, // order\n  \"inventory\", // schema\n).many()\n```\n\nWhen no schema is specified, queries use the default `public` schema via `client.from()`. When a schema is specified, queries use `client.schema(name).from(table)`.\n\n### View Entities (Read-Only)\n\nDatabase views in Supabase are read-only and only have a `Row` type (no `Insert` or `Update`). Use `ViewEntity` for type-safe querying of views:\n\n```typescript\nimport { ViewEntity, PartitionedViewEntity } from \"supabase-typed-query\"\n\n// Create a read-only view entity\nconst AuthUsersView = ViewEntity(supabase, \"auth_users_view\", {\n  schema: \"agent_gate\", // Optional: defaults to \"public\"\n})\n\n// Query the view - only getItem and getItems are available\nconst user = await AuthUsersView.getItem({ id: \"123\" }).one()\nconst activeUsers = await AuthUsersView.getItems({\n  where: { is_active: true },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// For multi-tenant views, use PartitionedViewEntity\nconst TenantStatsView = PartitionedViewEntity(supabase, \"tenant_stats_view\", {\n  partitionField: \"tenant_id\",\n})\n\n// All queries require partition key\nconst stats = await TenantStatsView.getItems(tenantId, {\n  where: { period: \"monthly\" },\n}).many()\n```\n\n**Key differences from Entity:**\n\n- Only `getItem()` and `getItems()` methods (no write operations)\n- No `softDelete` configuration (views are read-only snapshots)\n- Uses `ViewNames` and `ViewRow` types instead of `TableNames` and `TableRow`\n\n### Multi-Tenancy with Partition Keys\n\nUse partition keys to automatically scope queries to a tenant or partition:\n\n```typescript\n// Create a tenant-scoped entity\nconst TenantPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  partitionKey: { tenant_id: \"tenant-123\" }, // All queries automatically include this filter\n})\n\n// All queries are automatically scoped to the tenant\nconst tenantPosts = await TenantPostEntity.getItems({\n  where: { status: \"published\" },\n}).many()\n// Equivalent to: WHERE tenant_id = 'tenant-123' AND status = 'published' AND deleted IS NULL\n\n// Create a global/admin entity (no partition)\nconst GlobalPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  // No partitionKey - queries all tenants\n})\n\nconst allPosts = await GlobalPostEntity.getItems().many()\n// Equivalent to: WHERE deleted IS NULL\n```\n\n### Error Handling\n\nThe library uses functype's `TaskOutcome` for error handling:\n\n```typescript\n// Using TaskOutcome (recommended for explicit error handling)\nconst result = await query(supabase, \"users\", { id: userId }).one()\n\nif (result.isOk()) {\n  const maybeUser = result.getOrThrow()\n  if (maybeUser.isSome()) {\n    console.log(\"User found:\", maybeUser.getOrThrow())\n  }\n} else {\n  console.error(\"Query failed:\", result.error)\n}\n\n// Using OrThrow methods (simpler but throws errors)\ntry {\n  const user = await query(supabase, \"users\", { id: userId }).oneOrThrow()\n  console.log(\"User:\", user)\n} catch (error) {\n  console.error(\"Query failed:\", error)\n}\n```\n\n### Type Safety\n\nAll operations are fully type-safe based on your database schema:\n\n```typescript\n// TypeScript will enforce correct field names and types\nconst posts = await query(supabase, \"posts\", {\n  // âœ… TypeScript knows these fields exist and their types\n  title: \"My Post\",\n  published: true,\n  view_count: { gte: 100 },\n\n  // âŒ TypeScript error: property doesn't exist\n  nonexistent_field: \"value\",\n}).many()\n```\n\n## API Reference\n\n### Query Methods\n\n- `one()` - Execute query expecting exactly one result\n- `many()` - Execute query expecting zero or more results\n- `first()` - Execute query expecting first result from potentially multiple\n- `oneOrThrow()` - Like `one()` but throws if not found\n- `manyOrThrow()` - Like `many()` but throws on error\n- `firstOrThrow()` - Like `first()` but throws if not found\n\n### Query Composition\n\n- `or(conditions)` - Add OR conditions to the query\n- `map(fn)` - Transform results with a mapping function\n- `filter(fn)` - Filter results with a predicate\n- `limit(n)` - Limit the number of results\n- `offset(n)` - Skip the first n results\n- `includeDeleted()` - Include soft-deleted items in results\n- `excludeDeleted()` - Exclude soft-deleted items from results\n- `onlyDeleted()` - Return only soft-deleted items\n\n### Entity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n- `addItems({ items })` - Add multiple items\n- `updateItem({ id, item, where?, is?, wherein? })` - Update a single item\n- `updateItems({ items, identity?, where?, is?, wherein? })` - Update multiple items\n\n### Entity Configuration\n\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items; when `false`, includes them\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### ViewEntity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n\n> **Note:** ViewEntity only supports read operations. No `addItems`, `updateItem`, `deleteItem`, or soft delete methods.\n\n### ViewEntity Configuration\n\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedViewEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n## Requirements\n\n- TypeScript 5.0+\n- Supabase JS Client v2\n- functype 0.14+\n\n## License\n\nMIT\n\n## Development\n\n### Setup\n\n```bash\n# Clone the repository\ngit clone https://github.com/jordanburke/supabase-typed-query.git\ncd supabase-typed-query\n\n# Install dependencies\npnpm install\n\n# Run validation pipeline\npnpm validate\n```\n\n### Commands\n\n```bash\n# Development\npnpm validate          # Run full validation: format, lint, typecheck, test, build\npnpm test             # Run tests\npnpm test:watch       # Run tests in watch mode\npnpm test:coverage    # Run tests with coverage\npnpm build            # Build for production\npnpm build:dev:watch  # Build in watch mode for development\n\n# Code Quality\npnpm format           # Format code with Prettier\npnpm lint             # Fix ESLint issues\npnpm typecheck        # Type check with TypeScript\n```\n\n### CI/CD Pipeline\n\nThis project uses GitHub Actions for continuous integration and deployment:\n\n#### Continuous Integration\n\n- **Triggered on**: Push/PR to main/develop branches\n- **Test matrix**: Node.js 18.x, 20.x, 22.x\n- **Pipeline**: Format â†’ Lint â†’ Type Check â†’ Test â†’ Build\n\n#### Release Process\n\n1. Update version in `package.json`\n2. Create and push a version tag:\n   ```bash\n   git tag v1.0.0\n   git push origin v1.0.0\n   ```\n3. GitHub Actions automatically:\n   - Runs full validation pipeline\n   - Publishes to NPM registry\n   - Creates GitHub release\n\n#### Security\n\n- CodeQL analysis runs on all PRs and weekly scheduled scans\n- Dependency updates via Dependabot\n\n### Publishing\n\nThe package is automatically published to NPM when a version tag is pushed. Manual publishing:\n\n```bash\n# Ensure you're logged into NPM\nnpm login\n\n# Run validation and publish\npnpm build:publish\n```\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n### Development Guidelines\n\n1. **Type Safety**: Maintain strict TypeScript types, no `any`\n2. **Functional Style**: Use functional programming patterns with functype\n3. **Testing**: Add tests for new features\n4. **Documentation**: Update README for API changes\n5. **Commits**: Follow conventional commits format\n\n### Pull Request Process\n\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/amazing-feature`)\n3. Run `pnpm validate` to ensure all checks pass\n4. Commit your changes (`git commit -m 'feat: add amazing feature'`)\n5. Push to the branch (`git push origin feature/amazing-feature`)\n6. Open a Pull Request\n\nTests will automatically run via GitHub Actions on your PR.\n"
      },
      "plugins": [
        {
          "name": "supabase-typed-query",
          "description": "Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/supabase-typed-query"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/supabase-typed-query",
            "/plugin install supabase-typed-query@supabase-typed-query-skills"
          ]
        }
      ]
    }
  ]
}