{
  "author": {
    "id": "jordanburke",
    "display_name": "Jordan",
    "avatar_url": "https://avatars.githubusercontent.com/u/67263?v=4"
  },
  "marketplaces": [
    {
      "name": "functype-skills",
      "version": null,
      "description": "Skills for working with the functype functional programming library for TypeScript",
      "repo_full_name": "jordanburke/functype",
      "repo_url": "https://github.com/jordanburke/functype",
      "repo_description": "A Functional Library for TypeScript based on Scala",
      "signals": {
        "stars": 7,
        "forks": 1,
        "pushed_at": "2026-02-03T22:22:27Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"functype-skills\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for working with the functype functional programming library for TypeScript\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"functype\",\n      \"description\": \"Help developers use functype patterns in their TypeScript projects - pattern conversion, API lookup, common use cases\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/functype\"]\n    },\n    {\n      \"name\": \"functype-developer\",\n      \"description\": \"Assist contributors developing the functype library - architecture patterns, creating new types, testing strategies\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/functype-developer\"]\n    }\n  ]\n}\n",
        "README.md": "# Functype\n\n![NPM Version](https://img.shields.io/npm/v/functype?link=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ffunctype)\n[![Node.js Build](https://github.com/jordanburke/functype/actions/workflows/pnpm-build.yml/badge.svg)](https://github.com/jordanburke/functype/actions/workflows/pnpm-build.yml)\n\n## A Functional Programming Library for TypeScript\n\nFunctype is a lightweight functional programming library for TypeScript, drawing inspiration from functional programming paradigms, the Scala Standard Library, and ZIO. It provides a comprehensive set of utilities and abstractions designed to facilitate functional programming within TypeScript applications.\n\n[API Documentation](https://jordanburke.github.io/functype/)\n\n### CLI Documentation\n\nGet LLM-optimized API reference directly in your terminal:\n\n```bash\nnpx functype              # Overview of all types\nnpx functype Option       # Detailed info for Option type\nnpx functype interfaces   # All interface definitions\nnpx functype --json       # JSON output for programmatic use\n```\n\n## Core Principles\n\n- **Immutability**: All data structures are immutable, promoting predictable and side-effect-free code\n- **Type Safety**: Leverages TypeScript's type system to ensure compile-time safety\n- **Composability**: Provides abstractions for building complex programs from simple components\n- **Functional Paradigms**: Embraces concepts like monads, functors, and type classes\n- **Unified Interface**: All data structures implement a common hierarchy of interfaces for consistency\n\n## Key Features\n\n- **Option Type**: Handle nullable values with `Some` and `None` types\n- **Either Type**: Express computation results with potential failures using `Left` and `Right`\n- **List, Set, Map**: Immutable collection types with functional operators\n- **Try Type**: Safely execute operations that might throw exceptions\n- **Do-notation**: Scala-like for-comprehensions with **optimized List performance** (up to 12x faster than traditional flatMap)\n- **Task**: Handle synchronous and asynchronous operations with error handling\n- **Lazy**: Deferred computation with memoization\n- **Tuple**: Type-safe fixed-length arrays\n- **Typeable**: Runtime type identification with compile-time safety\n- **Branded Types**: Nominal typing in TypeScript's structural type system\n- **Error Formatting**: Utilities for improved error visualization and logging\n- **Unified Type Classes**: Consistent interfaces across all data structures\n\n## Installation\n\n```bash\n# NPM\nnpm install functype\n\n# Yarn\nyarn add functype\n\n# PNPM\npnpm add functype\n\n# Bun\nbun add functype\n```\n\n### Bundle Size Optimization\n\nFunctype is optimized for tree-shaking and offers multiple import strategies to minimize bundle size:\n\n```typescript\n// Selective module imports (recommended for production)\nimport { Option } from \"functype/option\"\nimport { Either } from \"functype/either\"\n\n// Direct constructor imports (smallest bundle)\nimport { some, none } from \"functype/option\"\n```\n\nFor detailed optimization strategies, see the [Bundle Optimization Guide](docs/BUNDLE_OPTIMIZATION.md).\n\n## Usage Examples\n\n### Option\n\n{@includeCode test/docs/documentation-examples.spec.ts#readme-option-basic}\n\n### Either\n\n{@includeCode test/docs/documentation-examples.spec.ts#readme-either-basic}\n\n### List\n\n```typescript\nimport { List } from \"functype\"\n\nconst numbers = List([1, 2, 3, 4])\n\n// Transform\nconst doubled = numbers.map((x) => x * 2) // List([2, 4, 6, 8])\n\n// Filter\nconst evens = numbers.filter((x) => x % 2 === 0) // List([2, 4])\n\n// Reduce\nconst sum = numbers.foldLeft(0)((acc, x) => acc + x) // 10\n\n// Add/remove elements (immutably)\nconst withFive = numbers.add(5) // List([1, 2, 3, 4, 5])\nconst without3 = numbers.remove(3) // List([1, 2, 4])\n\n// Universal container operations\nconst hasEven = numbers.exists((x) => x % 2 === 0) // true\nconst firstEven = numbers.find((x) => x % 2 === 0) // Some(2)\nconst evenCount = numbers.count((x) => x % 2 === 0) // 2\n```\n\n### Try\n\n```typescript\nimport { Try } from \"functype\"\n\n// Safely execute code that might throw\nconst result = Try(() => {\n  // Potentially throwing operation\n  return JSON.parse('{\"name\": \"John\"}')\n})\n\n// Handle success/failure\nif (result.isSuccess()) {\n  console.log(\"Result:\", result.get())\n} else {\n  console.error(\"Error:\", result.error)\n}\n\n// Transform with map (only applies on Success)\nconst name = result.map((obj) => obj.name)\n\n// Convert to Either\nconst either = result.toEither()\n```\n\n### Lazy\n\n```typescript\nimport { Lazy } from \"functype\"\n\n// Create lazy computations\nconst expensive = Lazy(() => {\n  console.log(\"Computing...\")\n  return Math.random() * 1000\n})\n\n// Value is computed on first access and memoized\nconst value1 = expensive.get() // Logs \"Computing...\", returns number\nconst value2 = expensive.get() // Returns same number, no log\n\n// Transform lazy values\nconst doubled = expensive.map((x) => x * 2)\nconst formatted = doubled.map((x) => `Value: ${x}`)\n\n// Chain computations\nconst result = Lazy(() => 10)\n  .flatMap((x) => Lazy(() => x + 5))\n  .map((x) => x * 2)\n  .get() // 30\n```\n\n### Do-notation (High-Performance For-Comprehensions)\n\nFunctype provides generator-based Do-notation for monadic composition, similar to Scala's for-comprehensions, with **significant performance advantages for List operations**:\n\n```typescript\nimport { Do, DoAsync, $ } from \"functype\"\nimport { Option, Right, Left, List, Try } from \"functype\"\n\n// Chain multiple Option operations\nconst result = Do(function* () {\n  const x = yield* $(Option(5)) // Extract value from Option\n  const y = yield* $(Option(10)) // Extract value from another Option\n  const z = x + y // Regular computation\n  return z * 2 // Return final result\n})\n// result: Option<number> with value 30\n\n// Mix different monad types (with Reshapeable)\nconst mixed = Do(function* () {\n  const a = yield* $(Option(5)) // From Option\n  const b = yield* $(Right<string, number>(10)) // From Either\n  const c = yield* $(List([15])) // From List\n  const d = yield* $(Try(() => 20)) // From Try\n  return a + b + c + d\n})\n// Convert result to desired type\nconst asOption = mixed.toOption() // Option<number> with value 50\n\n// Error propagation - short-circuits on failure\nconst validation = Do(function* () {\n  const email = yield* $(validateEmail(\"user@example.com\")) // Returns Option\n  const user = yield* $(fetchUser(email)) // Returns Either\n  const profile = yield* $(loadProfile(user.id)) // Returns Try\n  return profile\n})\n// If any step fails, the entire computation short-circuits\n\n// List comprehensions - up to 12x FASTER than traditional flatMap!\nconst pairs = Do(function* () {\n  const x = yield* $(List([1, 2, 3]))\n  const y = yield* $(List([10, 20]))\n  return { x, y, product: x * y }\n})\n// pairs: List with 6 elements (all combinations)\n\n// Performance comparison:\n// Traditional: list.flatMap(x => list.flatMap(y => List([{x, y}]))) - slower\n// Do-notation: 2.5x to 12x faster for cartesian products!\n\n// Async operations with DoAsync\nconst asyncResult = await DoAsync(async function* () {\n  const user = yield* $(await fetchUserAsync(userId)) // Async Option\n  const score = yield* $(await getScoreAsync(user.id)) // Async Either\n  const bonus = yield* $(await calculateBonus(score)) // Async Try\n  return score + bonus\n})\n```\n\n**Performance Advantages:**\n\n- **List Comprehensions**: 2.5x to 12x faster than nested flatMap chains\n- **Optimized for Cartesian Products**: Efficient handling of multiple List yields\n- **Smart Caching**: Constructor lookups cached after first type detection\n- **Inline Helpers**: Reduced overhead from repeated type checks\n\n**When to Use Do-notation:**\n\n‚úÖ **Best for:**\n\n- Complex List comprehensions (huge performance win!)\n- Cartesian products and filtered combinations\n- Mixed monad types (leveraging Reshapeable)\n- Improved readability for multi-step operations\n\n‚ö†Ô∏è **Consider alternatives for:**\n\n- Simple 2-3 step Option/Either chains (traditional flatMap is ~2x faster)\n- Performance-critical hot paths with simple monads\n- Early termination scenarios (flatMap auto-short-circuits more efficiently)\n\n**Key Differences from Scala:**\n\n- Uses `yield* $(monad)` instead of `x <- monad`\n- No native guard syntax (use conditions with early return)\n- Always returns the type of the first yielded monad\n- Mixed types supported via Reshapeable interface\n\n### Task\n\nTask v2 provides structured error handling with the **Ok/Err pattern**, returning `TaskOutcome<T>` for all operations:\n\n```typescript\nimport { Task, Ok, Err, type TaskOutcome } from \"functype\"\n\n// Task v2: All operations return TaskOutcome<T>\nconst syncResult = Task().Sync(() => \"success\")\n// Returns: TaskSuccess<string> (extends TaskOutcome<string>)\n\nconst asyncResult = await Task().Async(async () => \"value\")\n// Returns: TaskOutcome<string>\n\n// Explicit Ok/Err returns for precise control\nconst explicitResult = await Task().Async(async (): Promise<TaskOutcome<string>> => {\n  if (Math.random() > 0.5) {\n    return Ok(\"success\") // Explicit success\n  }\n  return Err<string>(\"failed\") // Explicit failure\n})\n\n// Auto-wrapping: raw values become Ok, thrown errors become Err\nconst autoWrapped = await Task().Async(async () => {\n  if (condition) {\n    return \"raw value\" // Auto-wrapped as Ok(\"raw value\")\n  }\n  throw new Error(\"failed\") // Auto-wrapped as Err(error)\n})\n\n// Error recovery: error handlers can return Ok\nconst recovered = await Task().Async(\n  async () => {\n    throw new Error(\"initial error\")\n  },\n  async (error) => Ok(\"recovered from error\"), // Recovery!\n)\n\n// Working with results\nif (asyncResult.isSuccess()) {\n  console.log(asyncResult.value) // Access the success value\n} else {\n  console.error(asyncResult.error) // Access the error (Throwable)\n}\n\n// Chaining with TaskOutcome\nconst chainedResult = await Task().Async(async () => {\n  const firstResult = await Task().Async(async () => \"first\")\n  if (firstResult.isFailure()) {\n    return firstResult // Propagate failure\n  }\n\n  const secondResult = await Task().Async(async () => \"second\")\n  if (secondResult.isFailure()) {\n    return secondResult\n  }\n\n  return Ok(`${firstResult.value} + ${secondResult.value}`)\n})\n\n// Converting promise-based functions to Task\nconst fetchUserAPI = (userId: string): Promise<User> => fetch(`/api/users/${userId}`).then((r) => r.json())\n\nconst fetchUser = Task.fromPromise(fetchUserAPI)\n// Returns: (userId: string) => Promise<TaskOutcome<User>>\n\nconst userResult = await fetchUser(\"user123\")\nif (userResult.isSuccess()) {\n  console.log(userResult.value) // User object\n}\n\n// Convert TaskOutcome back to Promise (for interop)\nconst promise = Task.toPromise(asyncResult)\n// Success ‚Üí resolves with value\n// Failure ‚Üí rejects with error\n```\n\n### Branded Types\n\n```typescript\nimport { Brand, ValidatedBrand } from \"functype/branded\"\n\n// Create branded types for stronger type safety\ntype UserId = Brand<\"UserId\", string>\ntype Email = Brand<\"Email\", string>\n\n// Simple branding - branded values ARE primitives!\nconst userId = Brand(\"UserId\", \"U123456\")\nconsole.log(userId) // \"U123456\" - it IS a string\nconsole.log(typeof userId) // \"string\"\nconsole.log(userId.toUpperCase()) // \"U123456\" - string methods work!\n\n// Runtime-validated branding for safer input handling\nconst EmailValidator = ValidatedBrand(\"Email\", (s: string) => /^[^@]+@[^@]+\\.[^@]+$/.test(s))\nconst UserIdValidator = ValidatedBrand(\"UserId\", (s: string) => /^U\\d{6}$/.test(s))\n\n// Safe creation with Option/Either return types\nconst email = EmailValidator.of(\"user@example.com\") // Some(Brand<\"Email\", string>)\nconst invalidEmail = EmailValidator.of(\"invalid\") // None\n\nconst userResult = UserIdValidator.from(\"U123456\") // Right(Brand<\"UserId\", string>)\nconst userError = UserIdValidator.from(\"invalid\") // Left(\"Invalid UserId: validation failed\")\n\n// Type safety in action\nfunction getUserByEmail(email: Email): User {\n  /* ... */\n}\n\n// These calls are type-safe\nconst userId = UserId(\"U123456\")\nconst email = Email(\"user@example.com\")\nconst user = getUserByEmail(email) // Works\n\n// These would be type errors\ngetUserByEmail(\"invalid\") // Type error: Argument of type 'string' is not assignable to parameter of type 'Email'\ngetUserByEmail(userId) // Type error: Argument of type 'UserId' is not assignable to parameter of type 'Email'\n```\n\n## Conditional Programming\n\nFunctype provides `Cond` and `Match` for functional conditional logic without early returns:\n\n### Cond\n\n```typescript\nimport { Cond } from \"functype\"\n\n// Replace if-else chains with Cond\nconst grade = Cond<number, string>()\n  .case((score) => score >= 90, \"A\")\n  .case((score) => score >= 80, \"B\")\n  .case((score) => score >= 70, \"C\")\n  .case((score) => score >= 60, \"D\")\n  .default(\"F\")\n\nconsole.log(grade(85)) // \"B\"\nconsole.log(grade(55)) // \"F\"\n\n// With transformation\nconst discount = Cond<number, number>()\n  .case(\n    (qty) => qty >= 100,\n    (qty) => qty * 0.2, // 20% off for 100+\n  )\n  .case(\n    (qty) => qty >= 50,\n    (qty) => qty * 0.1, // 10% off for 50+\n  )\n  .case(\n    (qty) => qty >= 10,\n    (qty) => qty * 0.05, // 5% off for 10+\n  )\n  .default(0)\n\nconsole.log(discount(150)) // 30 (20% of 150)\n```\n\n### Match\n\n```typescript\nimport { Match } from \"functype\"\n\n// Pattern matching with Match\ntype Status = \"pending\" | \"approved\" | \"rejected\" | \"cancelled\"\n\nconst statusMessage = Match<Status, string>()\n  .case(\"pending\", \"Your request is being processed\")\n  .case(\"approved\", \"Your request has been approved!\")\n  .case(\"rejected\", \"Sorry, your request was rejected\")\n  .case(\"cancelled\", \"Your request was cancelled\")\n  .exhaustive()\n\nconsole.log(statusMessage(\"approved\")) // \"Your request has been approved!\"\n\n// Match with predicates\nconst numberType = Match<number, string>()\n  .case(0, \"zero\")\n  .case((n) => n > 0, \"positive\")\n  .case((n) => n < 0, \"negative\")\n  .exhaustive()\n\nconsole.log(numberType(42)) // \"positive\"\nconsole.log(numberType(-5)) // \"negative\"\n```\n\n### Advanced Pattern Matching\n\nMatch supports exhaustive matching, nested patterns, and guards:\n\n```typescript\nimport { Match } from \"functype\"\n\n// Exhaustive matching with compile-time checking\ntype Status = \"idle\" | \"loading\" | \"success\" | \"error\"\nconst result = Match<Status, string>(\"success\")\n  .case(\"idle\", \"Waiting...\")\n  .case(\"loading\", \"Loading...\")\n  .case(\"success\", \"Done!\")\n  .case(\"error\", \"Failed!\")\n  .exhaustive() // Compile error if any case is missing\n\n// Nested pattern matching\ntype User = {\n  name: string\n  age: number\n  role: \"admin\" | \"user\"\n  preferences?: { theme: \"light\" | \"dark\" }\n}\n\nconst message = Match<User, string>(user)\n  .case({ role: \"admin\", age: (n) => n >= 18, preferences: { theme: \"dark\" } }, \"Adult admin with dark mode\")\n  .case({ role: \"user\" }, (u) => `Regular user: ${u.name}`)\n  .when((u) => u.age < 18, \"Minor user - restricted access\")\n  .default(\"Unknown user type\")\n\n// Reusable pattern matchers\nconst classifier = Match.builder<Animal, string>()\n  .when((a) => a.canFly, \"Flying creature\")\n  .case({ legs: 0 }, \"Legless\")\n  .case({ legs: 2 }, \"Biped\")\n  .case({ legs: 4 }, \"Quadruped\")\n  .default(\"Other\")\n  .build()\n```\n\n## Fold\n\nFunctype includes a powerful `fold` operation for pattern matching and extracting values:\n\n```typescript\nimport { Option, Either, Try, List } from \"functype\"\n\n// Option fold\nconst opt = Option(5)\nconst optResult = opt.fold(\n  () => \"None\",\n  (value) => `Some(${value})`,\n) // \"Some(5)\"\n\n// Either fold\nconst either = Right<string, number>(42)\nconst eitherResult = either.fold(\n  (left) => `Left(${left})`,\n  (right) => `Right(${right})`,\n) // \"Right(42)\"\n\n// Try fold\nconst tryValue = Try(() => 10)\nconst tryResult = tryValue.fold(\n  (error) => `Error: ${error.message}`,\n  (value) => `Success: ${value}`,\n) // \"Success: 10\"\n\n// List fold\nconst list = List([1, 2, 3])\nconst listResult = list.foldLeft(0)((acc, num) => acc + num) // 6\n```\n\n## Foldable\n\nFunctype includes a `Foldable` type class that all data structures implement:\n\n```typescript\nimport { FoldableUtils, Option, List, Try } from \"functype\"\n\n// All data structures implement the Foldable interface\nconst option = Option(5)\nconst list = List([1, 2, 3, 4, 5])\nconst tryVal = Try(() => 10)\n\n// Use fold to pattern-match on data structures\noption.fold(\n  () => console.log(\"Empty option\"),\n  (value) => console.log(`Option value: ${value}`),\n)\n\n// Use foldLeft for left-associative operations\nconst sum = list.foldLeft(0)((acc, value) => acc + value) // 15\n\n// Use foldRight for right-associative operations\nconst product = list.foldRight(1)((value, acc) => value * acc) // 120\n\n// Use FoldableUtils to work with any Foldable\nconst isEmpty = FoldableUtils.isEmpty(option) // false\nconst size = FoldableUtils.size(list) // 5\nconst convertedToList = FoldableUtils.toList(option) // List([5])\nconst convertedToEither = FoldableUtils.toEither(tryVal, \"Error\") // Right(10)\n```\n\n## Matchable\n\nFunctype includes a `Matchable` type class for enhanced pattern matching:\n\n```typescript\nimport { Option, Either, Try, List, MatchableUtils } from \"functype\"\n\n// Pattern matching on Option\nconst opt = Option(42)\nconst optResult = opt.match({\n  Some: (value) => `Found: ${value}`,\n  None: () => \"Not found\",\n}) // \"Found: 42\"\n\n// Pattern matching on Either\nconst either = Either.fromNullable(null, \"Missing value\")\nconst eitherResult = either.match({\n  Left: (error) => `Error: ${error}`,\n  Right: (value) => `Value: ${value}`,\n}) // \"Error: Missing value\"\n\n// Pattern matching on Try\nconst tryVal = Try(() => JSON.parse('{\"name\":\"John\"}'))\nconst tryResult = tryVal.match({\n  Success: (data) => `Name: ${data.name}`,\n  Failure: (error) => `Parse error: ${error.message}`,\n}) // \"Name: John\"\n\n// Pattern matching on List\nconst list = List([1, 2, 3])\nconst listResult = list.match({\n  NonEmpty: (values) => `Values: ${values.join(\", \")}`,\n  Empty: () => \"No values\",\n}) // \"Values: 1, 2, 3\"\n\n// Using MatchableUtils for advanced pattern matching\nconst isPositive = MatchableUtils.when(\n  (n: number) => n > 0,\n  (n) => `Positive: ${n}`,\n)\n\nconst defaultCase = MatchableUtils.default((n: number) => `Default: ${n}`)\n\n// Using pattern guards in custom matching logic\nconst num = 42\nconst result = isPositive(num) ?? defaultCase(num) // \"Positive: 42\"\n```\n\n## Interface Hierarchy\n\nAll data structures in Functype implement a unified hierarchy of interfaces, providing consistent behavior across the library:\n\n### Type Classes\n\nFunctype leverages type classes to provide common operations:\n\n- **Functor**: Supports `map` operation for transforming wrapped values\n- **Applicative**: Extends Functor with `ap` for applying wrapped functions\n- **Monad**: Extends Applicative with `flatMap` for chaining operations\n- **AsyncMonad**: Extends Monad with `flatMapAsync` for async operations\n- **ContainerOps**: Universal operations for all containers (single-value and collections)\n- **CollectionOps**: Operations specific to collections like List and Set\n\n### Unified Interfaces\n\nAll data structures implement the `Functype` hierarchy:\n\n```typescript\n// Base interface for all data structures\ninterface FunctypeBase<A, Tag>\n  extends AsyncMonad<A>, Traversable<A>, Serializable<A>, Foldable<A>, Typeable<Tag>, ContainerOps<A> {\n  readonly _tag: Tag\n}\n\n// For single-value containers (Option, Either, Try)\ninterface Functype<A, Tag> extends FunctypeBase<A, Tag>, Extractable<A>, Pipe<A>, Matchable<A, Tag> {\n  toValue(): { _tag: Tag; value: A }\n}\n\n// For collections (List, Set, Map)\ninterface FunctypeCollection<A, Tag>\n  extends FunctypeBase<A, Tag>, Iterable<A>, Pipe<A[]>, Collection<A>, CollectionOps<A, FunctypeCollection<A, Tag>> {\n  toValue(): { _tag: Tag; value: A[] }\n  // Collections work with Iterable instead of Monad\n  flatMap<B>(f: (value: A) => Iterable<B>): FunctypeCollection<B, Tag>\n}\n```\n\n### Container Operations\n\nAll containers (Option, Either, Try, List, Set) support these universal operations:\n\n```typescript\nimport { Option, List } from \"functype\"\n\nconst opt = Option(42)\nconst list = List([1, 2, 3, 4, 5])\n\n// Universal operations work on both single-value and collections\nopt.count((x) => x > 40) // 1\nlist.count((x) => x > 3) // 2\n\nopt.find((x) => x > 40) // Some(42)\nlist.find((x) => x > 3) // Some(4)\n\nopt.exists((x) => x === 42) // true\nlist.exists((x) => x === 3) // true\n\nopt.forEach(console.log) // Logs: 42\nlist.forEach(console.log) // Logs: 1, 2, 3, 4, 5\n```\n\n## Feature Matrix\n\nFor a comprehensive overview of which interfaces are supported by each data structure, see the [Functype Feature Matrix](docs/FUNCTYPE_FEATURE_MATRIX.md).\n\n## Type Safety\n\nFunctype leverages TypeScript's advanced type system to provide compile-time safety for functional patterns, ensuring that your code is both robust and maintainable.\n\n```typescript\n// Type inference works seamlessly\nconst option = Option(42)\n// Inferred as number\nconst mappedValue = option.map((x) => x.toString())\n// Inferred as string\n```\n\n## Error Formatting\n\nFunctype provides utilities for improved error visualization and logging:\n\n```typescript\nimport { formatError, createErrorSerializer } from \"functype/error\"\n\n// Create a nested task error\nconst innerTask = Task({ name: \"DbQuery\" }).Sync(() => {\n  throw new Error(\"Database connection failed\")\n})\n\nconst outerTask = Task({ name: \"UserFetch\" }).Sync(() => {\n  return innerTask.value\n})\n\n// Format the error for console display\nconsole.error(\n  formatError(outerTask.value as Error, {\n    includeTasks: true,\n    includeStackTrace: true,\n    colors: true,\n  }),\n)\n\n// Create a serializer for structured logging libraries like Pino\nconst errorSerializer = createErrorSerializer()\n\n// Use with Pino\nconst logger = pino({\n  serializers: { err: errorSerializer },\n})\n\n// Log the error with full context\nlogger.error(\n  {\n    err: outerTask.value,\n    requestId: \"req-123\",\n  },\n  \"Failed to fetch user data\",\n)\n```\n\nFor more details, see the [Error Formatting Guide](docs/error-formatting.md).\n\n## Roadmap / TODO\n\n### High Priority\n\n- [x] Complete LazyList Implementation\n  - ‚úì Add Foldable interface (fold, foldLeft, foldRight)\n  - ‚úì Add Pipe interface for composition\n  - ‚úì Add Serializable for persistence\n  - ‚úì Add Typeable support\n- [ ] Implement NonEmptyList<A>\n  - List guaranteed to have at least one element\n  - Prevents empty list errors at compile time\n  - Full standard interface implementation\n  - Methods like `head` return `A` instead of `Option<A>`\n\n### Medium Priority\n\n- [ ] Implement ValidatedNel<E, A> for validation with error accumulation\n  - Unlike Either, collects multiple errors\n  - Uses NonEmptyList for error collection\n  - Applicative instance combines errors\n- [x] Enhance Pattern Matching\n  - ‚úì Add exhaustiveness checking at compile time\n  - ‚úì Support nested pattern matching\n  - ‚úì Add guard clauses (when conditions)\n  - ‚úì Support destructuring patterns\n  - ‚úì Consolidated into unified Match implementation\n- [x] Implement IO<R,E,A> effect type\n  - ‚úì Lazy execution with typed errors\n  - ‚úì Dependency injection (Tag, Context, Layer)\n  - ‚úì Composable operations (map, flatMap, zip, race)\n  - ‚úì Resource management (bracket/acquireRelease)\n  - ‚úì Generator do-notation (IO.gen) and builder (IO.Do)\n\n### Low Priority\n\n- [x] Complete Tuple Implementation\n  - ‚úì Add Foldable for tuple operations\n  - ‚úì Add Pipe interface for composition\n  - ‚úì Add Serializable for persistence\n  - ‚úì Add Companion pattern with utility methods\n  - ‚úì Added specialized pair() and triple() constructors\n- [ ] Implement Lens<S, A> for immutable updates\n  - Composable property access\n  - Type-safe nested updates\n  - Works with all functype data structures\n- [ ] Add Reader/State monads for dependency injection and state management\n\n### Completed Functionality\n\n- [x] Add lazy evaluation structures (LazyList implemented, needs interface completion)\n- [x] Add a proper Foldable type class interface\n- [x] Implement Matchable type class for pattern matching\n- [x] Implement Applicative and other functional type classes (for most types)\n\n### Performance Optimizations\n\n- [ ] Add memoization utilities\n- [ ] Improve recursive operations for large collections\n- [ ] Implement immutable data structures with structural sharing\n- [ ] Add performance benchmarks\n- [x] Optimize TreeShaking with sideEffects flag in package.json\n- [x] Support selective module imports for smaller bundles\n- [x] Add bundle size monitoring to CI/CD\n\n### API Consistency\n\n- [ ] Ensure all modules follow the Scala-inspired pattern:\n  - Constructor functions that return objects with methods\n  - Object methods for common operations\n  - Companion functions for additional utilities\n- [x] Align Task API with other monadic structures\n- [ ] Standardize import patterns (@ imports vs relative paths)\n- [x] Implement consistent error handling strategy for async operations\n\n### Testing and Documentation\n\n- [ ] Add observable test coverage metrics\n- [x] Implement property-based testing\n- [ ] Expand error handling tests\n- [ ] Add interoperability tests with other libraries\n\n### TypeScript Improvements\n\n- [x] Enable stricter TypeScript settings (noImplicitAny: true)\n- [x] Add noUncheckedIndexedAccess for safer array indexing\n- [ ] Improve support for higher-kinded types:\n  - Current type parameters work well for first-order types\n  - Expand to support type constructors as parameters (F<A> => F<B>)\n- [x] Add branded/nominal types for stronger type safety\n- [ ] Implement more type-level utilities (conditional types, template literals)\n- [ ] Leverage newer TypeScript features (const type parameters, tuple manipulation)\n\n## Claude Code Skills\n\nFunctype provides two specialized Claude Code skills to enhance your development experience:\n\n### Functype User Guide\n\nHelp for developers using functype in their projects:\n\n- Pattern conversion (imperative ‚Üí functional)\n- API lookup and examples\n- Common use cases and debugging tips\n\n**Install**: Download from [dist/skills/functype-user.zip](./dist/skills/functype-user.zip)\n\n### Functype Library Developer\n\nGuide for contributors developing functype itself:\n\n- Architecture patterns and development workflow\n- Creating new data structures\n- Testing strategies and interface implementation\n\n**Install**: Download from [dist/skills/functype-developer.zip](./dist/skills/functype-developer.zip)\n\nSee [.claude/skills/README.md](./.claude/skills/README.md) for complete installation and usage instructions.\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## License\n\nMIT License\n\nCopyright (c) 2025 Jordan Burke\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "plugins": [
        {
          "name": "functype",
          "description": "Help developers use functype patterns in their TypeScript projects - pattern conversion, API lookup, common use cases",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/functype"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/functype",
            "/plugin install functype@functype-skills"
          ]
        },
        {
          "name": "functype-developer",
          "description": "Assist contributors developing the functype library - architecture patterns, creating new types, testing strategies",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/functype-developer"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/functype",
            "/plugin install functype-developer@functype-skills"
          ]
        }
      ]
    },
    {
      "name": "supabase-typed-query-skills",
      "version": null,
      "description": "Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns",
      "repo_full_name": "jordanburke/supabase-typed-query",
      "repo_url": "https://github.com/jordanburke/supabase-typed-query",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-11T21:35:36Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"supabase-typed-query-skills\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for working with supabase-typed-query - type-safe Supabase queries with functional patterns\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"supabase-typed-query\",\n      \"description\": \"Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/supabase-typed-query\"]\n    }\n  ]\n}\n",
        "README.md": "# supabase-typed-query\n\nType-safe query builder and entity pattern for Supabase with TypeScript.\n\n## Features\n\n- üîí **Full TypeScript type safety** - Leverage your database types for compile-time safety\n- üîó **Chainable query API** - Build complex queries with OR conditions and functional operations\n- üéØ **Entity pattern** - Consistent CRUD operations across all tables\n- üëÅÔ∏è **View support** - Read-only ViewEntity for querying database views\n- üöÄ **Functional programming** - Built with functype for robust error handling\n- ‚ö° **Zero runtime overhead** - All type checking happens at compile time\n- üîÑ **Composable queries** - Mix and match conditions, filters, and transformations\n- üóëÔ∏è **Soft delete support** - Built-in soft delete filtering with per-query overrides\n- üè¢ **Multi-tenancy ready** - Automatic partition key filtering for tenant isolation\n- üóÑÔ∏è **Custom schema support** - Query tables and views in any PostgreSQL schema\n\n## Installation\n\n```bash\nnpm install supabase-typed-query functype\n# or\npnpm add supabase-typed-query functype\n# or\nyarn add supabase-typed-query functype\n```\n\n### Compatibility\n\n| Dependency              | Version    | Notes                               |\n| ----------------------- | ---------- | ----------------------------------- |\n| `@supabase/supabase-js` | `^2.0.0`   | Tested with 2.86.x                  |\n| `functype`              | `>=0.20.1` | Required for error handling         |\n| TypeScript              | `>=5.0`    | Recommended for best type inference |\n| Node.js                 | `>=18`     | Required                            |\n\n## Quick Start\n\n### 1. Set up your database types\n\nFirst, generate your database types from Supabase:\n\n```bash\nnpx supabase gen types typescript --project-id your-project-id > database.types.ts\n```\n\n### 2. Create a typed client\n\n```typescript\nimport { createClient } from \"@supabase/supabase-js\"\nimport type { Database } from \"./database.types\"\n\nconst supabase = createClient<Database>(\"your-supabase-url\", \"your-anon-key\")\n```\n\n### 3. Use the Query Builder\n\n```typescript\nimport { query } from \"supabase-typed-query\"\n\n// Simple query\nconst user = await query(supabase, \"users\", { id: \"123\" }).one()\n\n// Query with OR conditions\nconst posts = await query(supabase, \"posts\", { status: \"published\" }).or({ status: \"draft\", author_id: userId }).many()\n\n// Query with functional operations\nconst titles = await query(supabase, \"posts\", { status: \"published\" })\n  .map((post) => post.title)\n  .filter((title) => title.length > 10)\n  .many()\n```\n\n### 4. Use the Entity Pattern\n\n```typescript\nimport { Entity } from \"supabase-typed-query\"\n\n// Create an entity for your table with configuration\nconst PostEntity = Entity(supabase, \"posts\", {\n  softDelete: true, // Automatically exclude soft-deleted items\n})\n\n// Get all posts\nconst posts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// Get a single post\nconst post = await PostEntity.getItem({\n  id: \"post-123\",\n  where: { status: \"published\" },\n}).one()\n\n// Add posts\nconst newPosts = await PostEntity.addItems({\n  items: [{ title: \"New Post\", content: \"Content here\", status: \"draft\" }],\n}).execute()\n\n// Update a post\nconst updated = await PostEntity.updateItem({\n  id: \"post-123\",\n  item: { status: \"published\" },\n}).execute()\n```\n\n## Advanced Usage\n\n### Comparison Operators\n\n```typescript\n// Greater than / Less than\nconst recentPosts = await query(supabase, \"posts\", {\n  created_at: { gte: new Date(\"2024-01-01\") },\n}).many()\n\n// Pattern matching\nconst searchResults = await query(supabase, \"posts\", {\n  title: { ilike: \"%typescript%\" },\n}).many()\n\n// IN queries\nconst selectedPosts = await query(supabase, \"posts\", {\n  id: { in: [\"id1\", \"id2\", \"id3\"] },\n}).many()\n\n// IS NULL checks\nconst drafts = await query(supabase, \"posts\", {\n  published_at: { is: null },\n}).many()\n\n// IS NOT NULL checks (using NOT operator)\nconst publishedPosts = await query(supabase, \"posts\", {\n  not: { is: { published_at: null } },\n}).many()\n\n// NOT IN queries\nconst activePosts = await query(supabase, \"posts\", {\n  not: { in: { status: [\"draft\", \"archived\"] } },\n}).many()\n```\n\n### NOT Operator\n\nThe `not` operator follows Supabase conventions for negating conditions:\n\n```typescript\n// IS NOT NULL - find posts with external_id set\nconst linkedPosts = await PostEntity.getItems({\n  not: { is: { external_id: null } },\n}).many()\n\n// IS NOT TRUE / IS NOT FALSE\nconst nonFeatured = await PostEntity.getItems({\n  not: { is: { featured: true } },\n}).many()\n\n// NOT IN - exclude specific statuses\nconst visiblePosts = await PostEntity.getItems({\n  not: { in: { status: [\"spam\", \"trash\", \"deleted\"] } },\n}).many()\n\n// Combine NOT with other conditions\nconst activeLinkedPosts = await PostEntity.getItems({\n  where: { status: \"published\" },\n  not: { is: { external_id: null } },\n}).many()\n```\n\n> **Note**: `neq: null` is deprecated. Use `not: { is: { field: null } }` instead for IS NOT NULL checks.\n\n### Chaining OR Conditions\n\n```typescript\nconst results = await query(supabase, \"users\", { role: \"admin\" })\n  .or({ role: \"moderator\" })\n  .or({ role: \"editor\", active: true })\n  .many()\n```\n\n### Soft Deletes\n\nControl soft delete behavior at the Entity or Query level:\n\n```typescript\n// Entity with soft deletes enabled (excludes deleted by default)\nconst UserEntity = Entity(supabase, \"users\", {\n  softDelete: true, // Automatically filters out deleted items\n})\n\n// Override soft delete behavior per query\nconst allUsers = await UserEntity.getItems().includeDeleted().many()\nconst deletedOnly = await UserEntity.getItems().onlyDeleted().many()\nconst activeOnly = await UserEntity.getItems().excludeDeleted().many() // Redundant - already excluded\n\n// Entity without soft deletes (includes all items)\nconst AdminEntity = Entity(supabase, \"users\", {\n  softDelete: false, // No automatic filtering\n})\n```\n\n### Custom Schema Support\n\nQuery tables in any PostgreSQL schema (not just the default `public` schema):\n\n```typescript\nimport { Entity, PartitionedEntity, query } from \"supabase-typed-query\"\n\n// Entity with custom schema\nconst InventoryEntity = Entity(supabase, \"items\", {\n  softDelete: false,\n  schema: \"inventory\", // Uses client.schema(\"inventory\").from(\"items\")\n})\n\nconst items = await InventoryEntity.getItems({ where: { active: true } }).many()\n\n// PartitionedEntity with custom schema\nconst TenantItemsEntity = PartitionedEntity(supabase, \"items\", {\n  partitionField: \"tenant_id\",\n  softDelete: true,\n  schema: \"tenant_data\",\n})\n\n// Query API with custom schema (7th parameter)\nconst results = await query(\n  supabase,\n  \"items\",\n  { active: true },\n  undefined, // is conditions\n  undefined, // wherein conditions\n  undefined, // order\n  \"inventory\", // schema\n).many()\n```\n\nWhen no schema is specified, queries use the default `public` schema via `client.from()`. When a schema is specified, queries use `client.schema(name).from(table)`.\n\n### View Entities (Read-Only)\n\nDatabase views in Supabase are read-only and only have a `Row` type (no `Insert` or `Update`). Use `ViewEntity` for type-safe querying of views:\n\n```typescript\nimport { ViewEntity, PartitionedViewEntity } from \"supabase-typed-query\"\n\n// Create a read-only view entity\nconst AuthUsersView = ViewEntity(supabase, \"auth_users_view\", {\n  schema: \"agent_gate\", // Optional: defaults to \"public\"\n})\n\n// Query the view - only getItem and getItems are available\nconst user = await AuthUsersView.getItem({ id: \"123\" }).one()\nconst activeUsers = await AuthUsersView.getItems({\n  where: { is_active: true },\n  order: [\"created_at\", { ascending: false }],\n}).many()\n\n// For multi-tenant views, use PartitionedViewEntity\nconst TenantStatsView = PartitionedViewEntity(supabase, \"tenant_stats_view\", {\n  partitionField: \"tenant_id\",\n})\n\n// All queries require partition key\nconst stats = await TenantStatsView.getItems(tenantId, {\n  where: { period: \"monthly\" },\n}).many()\n```\n\n**Key differences from Entity:**\n\n- Only `getItem()` and `getItems()` methods (no write operations)\n- No `softDelete` configuration (views are read-only snapshots)\n- Uses `ViewNames` and `ViewRow` types instead of `TableNames` and `TableRow`\n\n### Multi-Tenancy with Partition Keys\n\nUse partition keys to automatically scope queries to a tenant or partition:\n\n```typescript\n// Create a tenant-scoped entity\nconst TenantPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  partitionKey: { tenant_id: \"tenant-123\" }, // All queries automatically include this filter\n})\n\n// All queries are automatically scoped to the tenant\nconst tenantPosts = await TenantPostEntity.getItems({\n  where: { status: \"published\" },\n}).many()\n// Equivalent to: WHERE tenant_id = 'tenant-123' AND status = 'published' AND deleted IS NULL\n\n// Create a global/admin entity (no partition)\nconst GlobalPostEntity = Entity(supabase, \"posts\", {\n  softDelete: true,\n  // No partitionKey - queries all tenants\n})\n\nconst allPosts = await GlobalPostEntity.getItems().many()\n// Equivalent to: WHERE deleted IS NULL\n```\n\n### Error Handling\n\nThe library uses functype's `TaskOutcome` for error handling:\n\n```typescript\n// Using TaskOutcome (recommended for explicit error handling)\nconst result = await query(supabase, \"users\", { id: userId }).one()\n\nif (result.isOk()) {\n  const maybeUser = result.getOrThrow()\n  if (maybeUser.isSome()) {\n    console.log(\"User found:\", maybeUser.getOrThrow())\n  }\n} else {\n  console.error(\"Query failed:\", result.error)\n}\n\n// Using OrThrow methods (simpler but throws errors)\ntry {\n  const user = await query(supabase, \"users\", { id: userId }).oneOrThrow()\n  console.log(\"User:\", user)\n} catch (error) {\n  console.error(\"Query failed:\", error)\n}\n```\n\n### Type Safety\n\nAll operations are fully type-safe based on your database schema:\n\n```typescript\n// TypeScript will enforce correct field names and types\nconst posts = await query(supabase, \"posts\", {\n  // ‚úÖ TypeScript knows these fields exist and their types\n  title: \"My Post\",\n  published: true,\n  view_count: { gte: 100 },\n\n  // ‚ùå TypeScript error: property doesn't exist\n  nonexistent_field: \"value\",\n}).many()\n```\n\n## API Reference\n\n### Query Methods\n\n- `one()` - Execute query expecting exactly one result\n- `many()` - Execute query expecting zero or more results\n- `first()` - Execute query expecting first result from potentially multiple\n- `oneOrThrow()` - Like `one()` but throws if not found\n- `manyOrThrow()` - Like `many()` but throws on error\n- `firstOrThrow()` - Like `first()` but throws if not found\n\n### Query Composition\n\n- `or(conditions)` - Add OR conditions to the query\n- `map(fn)` - Transform results with a mapping function\n- `filter(fn)` - Filter results with a predicate\n- `limit(n)` - Limit the number of results\n- `offset(n)` - Skip the first n results\n- `includeDeleted()` - Include soft-deleted items in results\n- `excludeDeleted()` - Exclude soft-deleted items from results\n- `onlyDeleted()` - Return only soft-deleted items\n\n### Entity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n- `addItems({ items })` - Add multiple items\n- `updateItem({ id, item, where?, is?, wherein? })` - Update a single item\n- `updateItems({ items, identity?, where?, is?, wherein? })` - Update multiple items\n\n### Entity Configuration\n\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items; when `false`, includes them\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `softDelete: boolean` - (Required) When `true`, automatically excludes soft-deleted items\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### ViewEntity Methods\n\n- `getItem({ id, where?, is? })` - Get a single item by ID\n- `getItems({ where?, is?, wherein?, order? })` - Get filtered items\n\n> **Note:** ViewEntity only supports read operations. No `addItems`, `updateItem`, `deleteItem`, or soft delete methods.\n\n### ViewEntity Configuration\n\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n### PartitionedViewEntity Configuration\n\n- `partitionField: string` - (Required) Column name used for partition filtering (e.g., `\"tenant_id\"`)\n- `schema?: string` - (Optional) PostgreSQL schema to query from (defaults to `\"public\"`)\n\n## Requirements\n\n- TypeScript 5.0+\n- Supabase JS Client v2\n- functype 0.14+\n\n## License\n\nMIT\n\n## Development\n\n### Setup\n\n```bash\n# Clone the repository\ngit clone https://github.com/jordanburke/supabase-typed-query.git\ncd supabase-typed-query\n\n# Install dependencies\npnpm install\n\n# Run validation pipeline\npnpm validate\n```\n\n### Commands\n\n```bash\n# Development\npnpm validate          # Run full validation: format, lint, typecheck, test, build\npnpm test             # Run tests\npnpm test:watch       # Run tests in watch mode\npnpm test:coverage    # Run tests with coverage\npnpm build            # Build for production\npnpm build:dev:watch  # Build in watch mode for development\n\n# Code Quality\npnpm format           # Format code with Prettier\npnpm lint             # Fix ESLint issues\npnpm typecheck        # Type check with TypeScript\n```\n\n### CI/CD Pipeline\n\nThis project uses GitHub Actions for continuous integration and deployment:\n\n#### Continuous Integration\n\n- **Triggered on**: Push/PR to main/develop branches\n- **Test matrix**: Node.js 18.x, 20.x, 22.x\n- **Pipeline**: Format ‚Üí Lint ‚Üí Type Check ‚Üí Test ‚Üí Build\n\n#### Release Process\n\n1. Update version in `package.json`\n2. Create and push a version tag:\n   ```bash\n   git tag v1.0.0\n   git push origin v1.0.0\n   ```\n3. GitHub Actions automatically:\n   - Runs full validation pipeline\n   - Publishes to NPM registry\n   - Creates GitHub release\n\n#### Security\n\n- CodeQL analysis runs on all PRs and weekly scheduled scans\n- Dependency updates via Dependabot\n\n### Publishing\n\nThe package is automatically published to NPM when a version tag is pushed. Manual publishing:\n\n```bash\n# Ensure you're logged into NPM\nnpm login\n\n# Run validation and publish\npnpm build:publish\n```\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n### Development Guidelines\n\n1. **Type Safety**: Maintain strict TypeScript types, no `any`\n2. **Functional Style**: Use functional programming patterns with functype\n3. **Testing**: Add tests for new features\n4. **Documentation**: Update README for API changes\n5. **Commits**: Follow conventional commits format\n\n### Pull Request Process\n\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/amazing-feature`)\n3. Run `pnpm validate` to ensure all checks pass\n4. Commit your changes (`git commit -m 'feat: add amazing feature'`)\n5. Push to the branch (`git push origin feature/amazing-feature`)\n6. Open a Pull Request\n\nTests will automatically run via GitHub Actions on your PR.\n"
      },
      "plugins": [
        {
          "name": "supabase-typed-query",
          "description": "Help developers use supabase-typed-query for type-safe Supabase queries - Query API, Entity patterns, error handling",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/supabase-typed-query"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/supabase-typed-query",
            "/plugin install supabase-typed-query@supabase-typed-query-skills"
          ]
        }
      ]
    }
  ]
}