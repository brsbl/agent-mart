{
  "author": {
    "id": "jordanburke",
    "display_name": "Jordan",
    "avatar_url": "https://avatars.githubusercontent.com/u/67263?v=4"
  },
  "marketplaces": [
    {
      "name": "functype-skills",
      "version": null,
      "description": "Skills for working with the functype functional programming library for TypeScript",
      "repo_full_name": "jordanburke/functype",
      "repo_url": "https://github.com/jordanburke/functype",
      "repo_description": "A Functional Library for TypeScript based on Scala",
      "signals": {
        "stars": 7,
        "forks": 1,
        "pushed_at": "2026-01-26T15:54:39Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"functype-skills\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for working with the functype functional programming library for TypeScript\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"functype\",\n      \"description\": \"Help developers use functype patterns in their TypeScript projects - pattern conversion, API lookup, common use cases\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/functype\"]\n    },\n    {\n      \"name\": \"functype-developer\",\n      \"description\": \"Assist contributors developing the functype library - architecture patterns, creating new types, testing strategies\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/functype-developer\"]\n    }\n  ]\n}\n",
        "README.md": "# Functype\n\n![NPM Version](https://img.shields.io/npm/v/functype?link=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ffunctype)\n[![Node.js Build](https://github.com/jordanburke/functype/actions/workflows/pnpm-build.yml/badge.svg)](https://github.com/jordanburke/functype/actions/workflows/pnpm-build.yml)\n\n## A Functional Programming Library for TypeScript\n\nFunctype is a lightweight functional programming library for TypeScript, drawing inspiration from functional programming paradigms, the Scala Standard Library, and ZIO. It provides a comprehensive set of utilities and abstractions designed to facilitate functional programming within TypeScript applications.\n\n[API Documentation](https://jordanburke.github.io/functype/)\n\n### CLI Documentation\n\nGet LLM-optimized API reference directly in your terminal:\n\n```bash\nnpx functype              # Overview of all types\nnpx functype Option       # Detailed info for Option type\nnpx functype interfaces   # All interface definitions\nnpx functype --json       # JSON output for programmatic use\n```\n\n## Core Principles\n\n- **Immutability**: All data structures are immutable, promoting predictable and side-effect-free code\n- **Type Safety**: Leverages TypeScript's type system to ensure compile-time safety\n- **Composability**: Provides abstractions for building complex programs from simple components\n- **Functional Paradigms**: Embraces concepts like monads, functors, and type classes\n- **Unified Interface**: All data structures implement a common hierarchy of interfaces for consistency\n\n## Key Features\n\n- **Option Type**: Handle nullable values with `Some` and `None` types\n- **Either Type**: Express computation results with potential failures using `Left` and `Right`\n- **List, Set, Map**: Immutable collection types with functional operators\n- **Try Type**: Safely execute operations that might throw exceptions\n- **Do-notation**: Scala-like for-comprehensions with **optimized List performance** (up to 12x faster than traditional flatMap)\n- **Task**: Handle synchronous and asynchronous operations with error handling\n- **Lazy**: Deferred computation with memoization\n- **Tuple**: Type-safe fixed-length arrays\n- **Typeable**: Runtime type identification with compile-time safety\n- **Branded Types**: Nominal typing in TypeScript's structural type system\n- **Error Formatting**: Utilities for improved error visualization and logging\n- **Unified Type Classes**: Consistent interfaces across all data structures\n\n## Installation\n\n```bash\n# NPM\nnpm install functype\n\n# Yarn\nyarn add functype\n\n# PNPM\npnpm add functype\n\n# Bun\nbun add functype\n```\n\n### Bundle Size Optimization\n\nFunctype is optimized for tree-shaking and offers multiple import strategies to minimize bundle size:\n\n```typescript\n// Selective module imports (recommended for production)\nimport { Option } from \"functype/option\"\nimport { Either } from \"functype/either\"\n\n// Direct constructor imports (smallest bundle)\nimport { some, none } from \"functype/option\"\n```\n\nFor detailed optimization strategies, see the [Bundle Optimization Guide](docs/BUNDLE_OPTIMIZATION.md).\n\n## Usage Examples\n\n### Option\n\n{@includeCode test/docs/documentation-examples.spec.ts#readme-option-basic}\n\n### Either\n\n{@includeCode test/docs/documentation-examples.spec.ts#readme-either-basic}\n\n### List\n\n```typescript\nimport { List } from \"functype\"\n\nconst numbers = List([1, 2, 3, 4])\n\n// Transform\nconst doubled = numbers.map((x) => x * 2) // List([2, 4, 6, 8])\n\n// Filter\nconst evens = numbers.filter((x) => x % 2 === 0) // List([2, 4])\n\n// Reduce\nconst sum = numbers.foldLeft(0)((acc, x) => acc + x) // 10\n\n// Add/remove elements (immutably)\nconst withFive = numbers.add(5) // List([1, 2, 3, 4, 5])\nconst without3 = numbers.remove(3) // List([1, 2, 4])\n\n// Universal container operations\nconst hasEven = numbers.exists((x) => x % 2 === 0) // true\nconst firstEven = numbers.find((x) => x % 2 === 0) // Some(2)\nconst evenCount = numbers.count((x) => x % 2 === 0) // 2\n```\n\n### Try\n\n```typescript\nimport { Try } from \"functype\"\n\n// Safely execute code that might throw\nconst result = Try(() => {\n  // Potentially throwing operation\n  return JSON.parse('{\"name\": \"John\"}')\n})\n\n// Handle success/failure\nif (result.isSuccess()) {\n  console.log(\"Result:\", result.get())\n} else {\n  console.error(\"Error:\", result.error)\n}\n\n// Transform with map (only applies on Success)\nconst name = result.map((obj) => obj.name)\n\n// Convert to Either\nconst either = result.toEither()\n```\n\n### Lazy\n\n```typescript\nimport { Lazy } from \"functype\"\n\n// Create lazy computations\nconst expensive = Lazy(() => {\n  console.log(\"Computing...\")\n  return Math.random() * 1000\n})\n\n// Value is computed on first access and memoized\nconst value1 = expensive.get() // Logs \"Computing...\", returns number\nconst value2 = expensive.get() // Returns same number, no log\n\n// Transform lazy values\nconst doubled = expensive.map((x) => x * 2)\nconst formatted = doubled.map((x) => `Value: ${x}`)\n\n// Chain computations\nconst result = Lazy(() => 10)\n  .flatMap((x) => Lazy(() => x + 5))\n  .map((x) => x * 2)\n  .get() // 30\n```\n\n### Do-notation (High-Performance For-Comprehensions)\n\nFunctype provides generator-based Do-notation for monadic composition, similar to Scala's for-comprehensions, with **significant performance advantages for List operations**:\n\n```typescript\nimport { Do, DoAsync, $ } from \"functype\"\nimport { Option, Right, Left, List, Try } from \"functype\"\n\n// Chain multiple Option operations\nconst result = Do(function* () {\n  const x = yield* $(Option(5)) // Extract value from Option\n  const y = yield* $(Option(10)) // Extract value from another Option\n  const z = x + y // Regular computation\n  return z * 2 // Return final result\n})\n// result: Option<number> with value 30\n\n// Mix different monad types (with Reshapeable)\nconst mixed = Do(function* () {\n  const a = yield* $(Option(5)) // From Option\n  const b = yield* $(Right<string, number>(10)) // From Either\n  const c = yield* $(List([15])) // From List\n  const d = yield* $(Try(() => 20)) // From Try\n  return a + b + c + d\n})\n// Convert result to desired type\nconst asOption = mixed.toOption() // Option<number> with value 50\n\n// Error propagation - short-circuits on failure\nconst validation = Do(function* () {\n  const email = yield* $(validateEmail(\"user@example.com\")) // Returns Option\n  const user = yield* $(fetchUser(email)) // Returns Either\n  const profile = yield* $(loadProfile(user.id)) // Returns Try\n  return profile\n})\n// If any step fails, the entire computation short-circuits\n\n// List comprehensions - up to 12x FASTER than traditional flatMap!\nconst pairs = Do(function* () {\n  const x = yield* $(List([1, 2, 3]))\n  const y = yield* $(List([10, 20]))\n  return { x, y, product: x * y }\n})\n// pairs: List with 6 elements (all combinations)\n\n// Performance comparison:\n// Traditional: list.flatMap(x => list.flatMap(y => List([{x, y}]))) - slower\n// Do-notation: 2.5x to 12x faster for cartesian products!\n\n// Async operations with DoAsync\nconst asyncResult = await DoAsync(async function* () {\n  const user = yield* $(await fetchUserAsync(userId)) // Async Option\n  const score = yield* $(await getScoreAsync(user.id)) // Async Either\n  const bonus = yield* $(await calculateBonus(score)) // Async Try\n  return score + bonus\n})\n```\n\n**Performance Advantages:**\n\n- **List Comprehensions**: 2.5x to 12x faster than nested flatMap chains\n- **Optimized for Cartesian Products**: Efficient handling of multiple List yields\n- **Smart Caching**: Constructor lookups cached after first type detection\n- **Inline Helpers**: Reduced overhead from repeated type checks\n\n**When to Use Do-notation:**\n\n✅ **Best for:**\n\n- Complex List comprehensions (huge performance win!)\n- Cartesian products and filtered combinations\n- Mixed monad types (leveraging Reshapeable)\n- Improved readability for multi-step operations\n\n⚠️ **Consider alternatives for:**\n\n- Simple 2-3 step Option/Either chains (traditional flatMap is ~2x faster)\n- Performance-critical hot paths with simple monads\n- Early termination scenarios (flatMap auto-short-circuits more efficiently)\n\n**Key Differences from Scala:**\n\n- Uses `yield* $(monad)` instead of `x <- monad`\n- No native guard syntax (use conditions with early return)\n- Always returns the type of the first yielded monad\n- Mixed types supported via Reshapeable interface\n\n### Task\n\nTask v2 provides structured error handling with the **Ok/Err pattern**, returning `TaskOutcome<T>` for all operations:\n\n```typescript\nimport { Task, Ok, Err, type TaskOutcome } from \"functype\"\n\n// Task v2: All operations return TaskOutcome<T>\nconst syncResult = Task().Sync(() => \"success\")\n// Returns: TaskSuccess<string> (extends TaskOutcome<string>)\n\nconst asyncResult = await Task().Async(async () => \"value\")\n// Returns: TaskOutcome<string>\n\n// Explicit Ok/Err returns for precise control\nconst explicitResult = await Task().Async(async (): Promise<TaskOutcome<string>> => {\n  if (Math.random() > 0.5) {\n    return Ok(\"success\") // Explicit success\n  }\n  return Err<string>(\"failed\") // Explicit failure\n})\n\n// Auto-wrapping: raw values become Ok, thrown errors become Err\nconst autoWrapped = await Task().Async(async () => {\n  if (condition) {\n    return \"raw value\" // Auto-wrapped as Ok(\"raw value\")\n  }\n  throw new Error(\"failed\") // Auto-wrapped as Err(error)\n})\n\n// Error recovery: error handlers can return Ok\nconst recovered = await Task().Async(\n  async () => {\n    throw new Error(\"initial error\")\n  },\n  async (error) => Ok(\"recovered from error\"), // Recovery!\n)\n\n// Working with results\nif (asyncResult.isSuccess()) {\n  console.log(asyncResult.value) // Access the success value\n} else {\n  console.error(asyncResult.error) // Access the error (Throwable)\n}\n\n// Chaining with TaskOutcome\nconst chainedResult = await Task().Async(async () => {\n  const firstResult = await Task().Async(async () => \"first\")\n  if (firstResult.isFailure()) {\n    return firstResult // Propagate failure\n  }\n\n  const secondResult = await Task().Async(async () => \"second\")\n  if (secondResult.isFailure()) {\n    return secondResult\n  }\n\n  return Ok(`${firstResult.value} + ${secondResult.value}`)\n})\n\n// Converting promise-based functions to Task\nconst fetchUserAPI = (userId: string): Promise<User> => fetch(`/api/users/${userId}`).then((r) => r.json())\n\nconst fetchUser = Task.fromPromise(fetchUserAPI)\n// Returns: (userId: string) => Promise<TaskOutcome<User>>\n\nconst userResult = await fetchUser(\"user123\")\nif (userResult.isSuccess()) {\n  console.log(userResult.value) // User object\n}\n\n// Convert TaskOutcome back to Promise (for interop)\nconst promise = Task.toPromise(asyncResult)\n// Success → resolves with value\n// Failure → rejects with error\n```\n\n### Branded Types\n\n```typescript\nimport { Brand, ValidatedBrand } from \"functype/branded\"\n\n// Create branded types for stronger type safety\ntype UserId = Brand<\"UserId\", string>\ntype Email = Brand<\"Email\", string>\n\n// Simple branding - branded values ARE primitives!\nconst userId = Brand(\"UserId\", \"U123456\")\nconsole.log(userId) // \"U123456\" - it IS a string\nconsole.log(typeof userId) // \"string\"\nconsole.log(userId.toUpperCase()) // \"U123456\" - string methods work!\n\n// Runtime-validated branding for safer input handling\nconst EmailValidator = ValidatedBrand(\"Email\", (s: string) => /^[^@]+@[^@]+\\.[^@]+$/.test(s))\nconst UserIdValidator = ValidatedBrand(\"UserId\", (s: string) => /^U\\d{6}$/.test(s))\n\n// Safe creation with Option/Either return types\nconst email = EmailValidator.of(\"user@example.com\") // Some(Brand<\"Email\", string>)\nconst invalidEmail = EmailValidator.of(\"invalid\") // None\n\nconst userResult = UserIdValidator.from(\"U123456\") // Right(Brand<\"UserId\", string>)\nconst userError = UserIdValidator.from(\"invalid\") // Left(\"Invalid UserId: validation failed\")\n\n// Type safety in action\nfunction getUserByEmail(email: Email): User {\n  /* ... */\n}\n\n// These calls are type-safe\nconst userId = UserId(\"U123456\")\nconst email = Email(\"user@example.com\")\nconst user = getUserByEmail(email) // Works\n\n// These would be type errors\ngetUserByEmail(\"invalid\") // Type error: Argument of type 'string' is not assignable to parameter of type 'Email'\ngetUserByEmail(userId) // Type error: Argument of type 'UserId' is not assignable to parameter of type 'Email'\n```\n\n## Conditional Programming\n\nFunctype provides `Cond` and `Match` for functional conditional logic without early returns:\n\n### Cond\n\n```typescript\nimport { Cond } from \"functype\"\n\n// Replace if-else chains with Cond\nconst grade = Cond<number, string>()\n  .case((score) => score >= 90, \"A\")\n  .case((score) => score >= 80, \"B\")\n  .case((score) => score >= 70, \"C\")\n  .case((score) => score >= 60, \"D\")\n  .default(\"F\")\n\nconsole.log(grade(85)) // \"B\"\nconsole.log(grade(55)) // \"F\"\n\n// With transformation\nconst discount = Cond<number, number>()\n  .case(\n    (qty) => qty >= 100,\n    (qty) => qty * 0.2, // 20% off for 100+\n  )\n  .case(\n    (qty) => qty >= 50,\n    (qty) => qty * 0.1, // 10% off for 50+\n  )\n  .case(\n    (qty) => qty >= 10,\n    (qty) => qty * 0.05, // 5% off for 10+\n  )\n  .default(0)\n\nconsole.log(discount(150)) // 30 (20% of 150)\n```\n\n### Match\n\n```typescript\nimport { Match } from \"functype\"\n\n// Pattern matching with Match\ntype Status = \"pending\" | \"approved\" | \"rejected\" | \"cancelled\"\n\nconst statusMessage = Match<Status, string>()\n  .case(\"pending\", \"Your request is being processed\")\n  .case(\"approved\", \"Your request has been approved!\")\n  .case(\"rejected\", \"Sorry, your request was rejected\")\n  .case(\"cancelled\", \"Your request was cancelled\")\n  .exhaustive()\n\nconsole.log(statusMessage(\"approved\")) // \"Your request has been approved!\"\n\n// Match with predicates\nconst numberType = Match<number, string>()\n  .case(0, \"zero\")\n  .case((n) => n > 0, \"positive\")\n  .case((n) => n < 0, \"negative\")\n  .exhaustive()\n\nconsole.log(numberType(42)) // \"positive\"\nconsole.log(numberType(-5)) // \"negative\"\n```\n\n### Advanced Pattern Matching\n\nMatch supports exhaustive matching, nested patterns, and guards:\n\n```typescript\nimport { Match } from \"functype\"\n\n// Exhaustive matching with compile-time checking\ntype Status = \"idle\" | \"loading\" | \"success\" | \"error\"\nconst result = Match<Status, string>(\"success\")\n  .case(\"idle\", \"Waiting...\")\n  .case(\"loading\", \"Loading...\")\n  .case(\"success\", \"Done!\")\n  .case(\"error\", \"Failed!\")\n  .exhaustive() // Compile error if any case is missing\n\n// Nested pattern matching\ntype User = {\n  name: string\n  age: number\n  role: \"admin\" | \"user\"\n  preferences?: { theme: \"light\" | \"dark\" }\n}\n\nconst message = Match<User, string>(user)\n  .case({ role: \"admin\", age: (n) => n >= 18, preferences: { theme: \"dark\" } }, \"Adult admin with dark mode\")\n  .case({ role: \"user\" }, (u) => `Regular user: ${u.name}`)\n  .when((u) => u.age < 18, \"Minor user - restricted access\")\n  .default(\"Unknown user type\")\n\n// Reusable pattern matchers\nconst classifier = Match.builder<Animal, string>()\n  .when((a) => a.canFly, \"Flying creature\")\n  .case({ legs: 0 }, \"Legless\")\n  .case({ legs: 2 }, \"Biped\")\n  .case({ legs: 4 }, \"Quadruped\")\n  .default(\"Other\")\n  .build()\n```\n\n## Fold\n\nFunctype includes a powerful `fold` operation for pattern matching and extracting values:\n\n```typescript\nimport { Option, Either, Try, List } from \"functype\"\n\n// Option fold\nconst opt = Option(5)\nconst optResult = opt.fold(\n  () => \"None\",\n  (value) => `Some(${value})`,\n) // \"Some(5)\"\n\n// Either fold\nconst either = Right<string, number>(42)\nconst eitherResult = either.fold(\n  (left) => `Left(${left})`,\n  (right) => `Right(${right})`,\n) // \"Right(42)\"\n\n// Try fold\nconst tryValue = Try(() => 10)\nconst tryResult = tryValue.fold(\n  (error) => `Error: ${error.message}`,\n  (value) => `Success: ${value}`,\n) // \"Success: 10\"\n\n// List fold\nconst list = List([1, 2, 3])\nconst listResult = list.foldLeft(0)((acc, num) => acc + num) // 6\n```\n\n## Foldable\n\nFunctype includes a `Foldable` type class that all data structures implement:\n\n```typescript\nimport { FoldableUtils, Option, List, Try } from \"functype\"\n\n// All data structures implement the Foldable interface\nconst option = Option(5)\nconst list = List([1, 2, 3, 4, 5])\nconst tryVal = Try(() => 10)\n\n// Use fold to pattern-match on data structures\noption.fold(\n  () => console.log(\"Empty option\"),\n  (value) => console.log(`Option value: ${value}`),\n)\n\n// Use foldLeft for left-associative operations\nconst sum = list.foldLeft(0)((acc, value) => acc + value) // 15\n\n// Use foldRight for right-associative operations\nconst product = list.foldRight(1)((value, acc) => value * acc) // 120\n\n// Use FoldableUtils to work with any Foldable\nconst isEmpty = FoldableUtils.isEmpty(option) // false\nconst size = FoldableUtils.size(list) // 5\nconst convertedToList = FoldableUtils.toList(option) // List([5])\nconst convertedToEither = FoldableUtils.toEither(tryVal, \"Error\") // Right(10)\n```\n\n## Matchable\n\nFunctype includes a `Matchable` type class for enhanced pattern matching:\n\n```typescript\nimport { Option, Either, Try, List, MatchableUtils } from \"functype\"\n\n// Pattern matching on Option\nconst opt = Option(42)\nconst optResult = opt.match({\n  Some: (value) => `Found: ${value}`,\n  None: () => \"Not found\",\n}) // \"Found: 42\"\n\n// Pattern matching on Either\nconst either = Either.fromNullable(null, \"Missing value\")\nconst eitherResult = either.match({\n  Left: (error) => `Error: ${error}`,\n  Right: (value) => `Value: ${value}`,\n}) // \"Error: Missing value\"\n\n// Pattern matching on Try\nconst tryVal = Try(() => JSON.parse('{\"name\":\"John\"}'))\nconst tryResult = tryVal.match({\n  Success: (data) => `Name: ${data.name}`,\n  Failure: (error) => `Parse error: ${error.message}`,\n}) // \"Name: John\"\n\n// Pattern matching on List\nconst list = List([1, 2, 3])\nconst listResult = list.match({\n  NonEmpty: (values) => `Values: ${values.join(\", \")}`,\n  Empty: () => \"No values\",\n}) // \"Values: 1, 2, 3\"\n\n// Using MatchableUtils for advanced pattern matching\nconst isPositive = MatchableUtils.when(\n  (n: number) => n > 0,\n  (n) => `Positive: ${n}`,\n)\n\nconst defaultCase = MatchableUtils.default((n: number) => `Default: ${n}`)\n\n// Using pattern guards in custom matching logic\nconst num = 42\nconst result = isPositive(num) ?? defaultCase(num) // \"Positive: 42\"\n```\n\n## Interface Hierarchy\n\nAll data structures in Functype implement a unified hierarchy of interfaces, providing consistent behavior across the library:\n\n### Type Classes\n\nFunctype leverages type classes to provide common operations:\n\n- **Functor**: Supports `map` operation for transforming wrapped values\n- **Applicative**: Extends Functor with `ap` for applying wrapped functions\n- **Monad**: Extends Applicative with `flatMap` for chaining operations\n- **AsyncMonad**: Extends Monad with `flatMapAsync` for async operations\n- **ContainerOps**: Universal operations for all containers (single-value and collections)\n- **CollectionOps**: Operations specific to collections like List and Set\n\n### Unified Interfaces\n\nAll data structures implement the `Functype` hierarchy:\n\n```typescript\n// Base interface for all data structures\ninterface FunctypeBase<A, Tag>\n  extends AsyncMonad<A>, Traversable<A>, Serializable<A>, Foldable<A>, Typeable<Tag>, ContainerOps<A> {\n  readonly _tag: Tag\n}\n\n// For single-value containers (Option, Either, Try)\ninterface Functype<A, Tag> extends FunctypeBase<A, Tag>, Extractable<A>, Pipe<A>, Matchable<A, Tag> {\n  toValue(): { _tag: Tag; value: A }\n}\n\n// For collections (List, Set, Map)\ninterface FunctypeCollection<A, Tag>\n  extends FunctypeBase<A, Tag>, Iterable<A>, Pipe<A[]>, Collection<A>, CollectionOps<A, FunctypeCollection<A, Tag>> {\n  toValue(): { _tag: Tag; value: A[] }\n  // Collections work with Iterable instead of Monad\n  flatMap<B>(f: (value: A) => Iterable<B>): FunctypeCollection<B, Tag>\n}\n```\n\n### Container Operations\n\nAll containers (Option, Either, Try, List, Set) support these universal operations:\n\n```typescript\nimport { Option, List } from \"functype\"\n\nconst opt = Option(42)\nconst list = List([1, 2, 3, 4, 5])\n\n// Universal operations work on both single-value and collections\nopt.count((x) => x > 40) // 1\nlist.count((x) => x > 3) // 2\n\nopt.find((x) => x > 40) // Some(42)\nlist.find((x) => x > 3) // Some(4)\n\nopt.exists((x) => x === 42) // true\nlist.exists((x) => x === 3) // true\n\nopt.forEach(console.log) // Logs: 42\nlist.forEach(console.log) // Logs: 1, 2, 3, 4, 5\n```\n\n## Feature Matrix\n\nFor a comprehensive overview of which interfaces are supported by each data structure, see the [Functype Feature Matrix](docs/FUNCTYPE_FEATURE_MATRIX.md).\n\n## Type Safety\n\nFunctype leverages TypeScript's advanced type system to provide compile-time safety for functional patterns, ensuring that your code is both robust and maintainable.\n\n```typescript\n// Type inference works seamlessly\nconst option = Option(42)\n// Inferred as number\nconst mappedValue = option.map((x) => x.toString())\n// Inferred as string\n```\n\n## Error Formatting\n\nFunctype provides utilities for improved error visualization and logging:\n\n```typescript\nimport { formatError, createErrorSerializer } from \"functype/error\"\n\n// Create a nested task error\nconst innerTask = Task({ name: \"DbQuery\" }).Sync(() => {\n  throw new Error(\"Database connection failed\")\n})\n\nconst outerTask = Task({ name: \"UserFetch\" }).Sync(() => {\n  return innerTask.value\n})\n\n// Format the error for console display\nconsole.error(\n  formatError(outerTask.value as Error, {\n    includeTasks: true,\n    includeStackTrace: true,\n    colors: true,\n  }),\n)\n\n// Create a serializer for structured logging libraries like Pino\nconst errorSerializer = createErrorSerializer()\n\n// Use with Pino\nconst logger = pino({\n  serializers: { err: errorSerializer },\n})\n\n// Log the error with full context\nlogger.error(\n  {\n    err: outerTask.value,\n    requestId: \"req-123\",\n  },\n  \"Failed to fetch user data\",\n)\n```\n\nFor more details, see the [Error Formatting Guide](docs/error-formatting.md).\n\n## Roadmap / TODO\n\n### High Priority\n\n- [x] Complete LazyList Implementation\n  - ✓ Add Foldable interface (fold, foldLeft, foldRight)\n  - ✓ Add Pipe interface for composition\n  - ✓ Add Serializable for persistence\n  - ✓ Add Typeable support\n- [ ] Implement NonEmptyList<A>\n  - List guaranteed to have at least one element\n  - Prevents empty list errors at compile time\n  - Full standard interface implementation\n  - Methods like `head` return `A` instead of `Option<A>`\n\n### Medium Priority\n\n- [ ] Implement ValidatedNel<E, A> for validation with error accumulation\n  - Unlike Either, collects multiple errors\n  - Uses NonEmptyList for error collection\n  - Applicative instance combines errors\n- [x] Enhance Pattern Matching\n  - ✓ Add exhaustiveness checking at compile time\n  - ✓ Support nested pattern matching\n  - ✓ Add guard clauses (when conditions)\n  - ✓ Support destructuring patterns\n  - ✓ Consolidated into unified Match implementation\n- [x] Implement IO<R,E,A> effect type\n  - ✓ Lazy execution with typed errors\n  - ✓ Dependency injection (Tag, Context, Layer)\n  - ✓ Composable operations (map, flatMap, zip, race)\n  - ✓ Resource management (bracket/acquireRelease)\n  - ✓ Generator do-notation (IO.gen) and builder (IO.Do)\n\n### Low Priority\n\n- [x] Complete Tuple Implementation\n  - ✓ Add Foldable for tuple operations\n  - ✓ Add Pipe interface for composition\n  - ✓ Add Serializable for persistence\n  - ✓ Add Companion pattern with utility methods\n  - ✓ Added specialized pair() and triple() constructors\n- [ ] Implement Lens<S, A> for immutable updates\n  - Composable property access\n  - Type-safe nested updates\n  - Works with all functype data structures\n- [ ] Add Reader/State monads for dependency injection and state management\n\n### Completed Functionality\n\n- [x] Add lazy evaluation structures (LazyList implemented, needs interface completion)\n- [x] Add a proper Foldable type class interface\n- [x] Implement Matchable type class for pattern matching\n- [x] Implement Applicative and other functional type classes (for most types)\n\n### Performance Optimizations\n\n- [ ] Add memoization utilities\n- [ ] Improve recursive operations for large collections\n- [ ] Implement immutable data structures with structural sharing\n- [ ] Add performance benchmarks\n- [x] Optimize TreeShaking with sideEffects flag in package.json\n- [x] Support selective module imports for smaller bundles\n- [x] Add bundle size monitoring to CI/CD\n\n### API Consistency\n\n- [ ] Ensure all modules follow the Scala-inspired pattern:\n  - Constructor functions that return objects with methods\n  - Object methods for common operations\n  - Companion functions for additional utilities\n- [x] Align Task API with other monadic structures\n- [ ] Standardize import patterns (@ imports vs relative paths)\n- [x] Implement consistent error handling strategy for async operations\n\n### Testing and Documentation\n\n- [ ] Add observable test coverage metrics\n- [x] Implement property-based testing\n- [ ] Expand error handling tests\n- [ ] Add interoperability tests with other libraries\n\n### TypeScript Improvements\n\n- [x] Enable stricter TypeScript settings (noImplicitAny: true)\n- [x] Add noUncheckedIndexedAccess for safer array indexing\n- [ ] Improve support for higher-kinded types:\n  - Current type parameters work well for first-order types\n  - Expand to support type constructors as parameters (F<A> => F<B>)\n- [x] Add branded/nominal types for stronger type safety\n- [ ] Implement more type-level utilities (conditional types, template literals)\n- [ ] Leverage newer TypeScript features (const type parameters, tuple manipulation)\n\n## Claude Code Skills\n\nFunctype provides two specialized Claude Code skills to enhance your development experience:\n\n### Functype User Guide\n\nHelp for developers using functype in their projects:\n\n- Pattern conversion (imperative → functional)\n- API lookup and examples\n- Common use cases and debugging tips\n\n**Install**: Download from [dist/skills/functype-user.zip](./dist/skills/functype-user.zip)\n\n### Functype Library Developer\n\nGuide for contributors developing functype itself:\n\n- Architecture patterns and development workflow\n- Creating new data structures\n- Testing strategies and interface implementation\n\n**Install**: Download from [dist/skills/functype-developer.zip](./dist/skills/functype-developer.zip)\n\nSee [.claude/skills/README.md](./.claude/skills/README.md) for complete installation and usage instructions.\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## License\n\nMIT License\n\nCopyright (c) 2025 Jordan Burke\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
      },
      "plugins": [
        {
          "name": "functype",
          "description": "Help developers use functype patterns in their TypeScript projects - pattern conversion, API lookup, common use cases",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/functype"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/functype",
            "/plugin install functype@functype-skills"
          ]
        },
        {
          "name": "functype-developer",
          "description": "Assist contributors developing the functype library - architecture patterns, creating new types, testing strategies",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/functype-developer"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/functype",
            "/plugin install functype-developer@functype-skills"
          ]
        }
      ]
    },
    {
      "name": "typescript-standards",
      "version": null,
      "description": "Skills for creating TypeScript libraries using modern tooling and applying standardized build patterns",
      "repo_full_name": "jordanburke/typescript-library-template",
      "repo_url": "https://github.com/jordanburke/typescript-library-template",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-26T08:42:32Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"typescript-standards\",\n  \"owner\": {\n    \"name\": \"Jordan Burke\",\n    \"email\": \"jordan.burke@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills for creating TypeScript libraries using modern tooling and applying standardized build patterns\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"typescript-standards\",\n      \"description\": \"Guide for creating TypeScript libraries using the typescript-library-template pattern and applying its standards to existing projects. Use when setting up new npm packages, standardizing build scripts, configuring tooling (tsup, Vitest, ESLint, Prettier), or applying dual module format patterns.\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./.claude/skills/typescript-standards\"]\n    }\n  ]\n}\n",
        "README.md": "## typescript-library-template\n\n[![Node.js CI](https://github.com/jordanburke/typescript-library-template/actions/workflows/node.js.yml/badge.svg)](https://github.com/jordanburke/typescript-library-template/actions/workflows/node.js.yml)\n[![CodeQL](https://github.com/jordanburke/typescript-library-template/actions/workflows/codeql.yml/badge.svg)](https://github.com/jordanburke/typescript-library-template/actions/workflows/codeql.yml)\n\nA modern TypeScript library template with standardized build scripts and tooling.\n\n## Features\n\n- **Modern Build System**: [ts-builds](https://github.com/jordanburke/ts-builds) + [tsdown](https://tsdown.dev/) for fast bundling\n- **Testing**: [Vitest](https://vitest.dev/) with coverage reporting\n- **Code Quality**: ESLint + Prettier with automatic formatting and fixing\n- **Dual Format**: Outputs both CommonJS and ES modules with proper TypeScript declarations\n- **Standardized Scripts**: Consistent commands via ts-builds across all projects\n\n## Quick Start\n\n1. **Use this template** to create a new repository\n2. **Clone your new repository**\n3. **Install dependencies**: `pnpm install`\n4. **Start developing**: `pnpm dev` (builds with watch mode)\n5. **Before committing**: `pnpm validate` (format + lint + test + build)\n\n## Development Commands\n\n### Pre-Checkin Command\n\n```bash\npnpm validate  # Main command: format, lint, test, and build everything\n```\n\n### Individual Commands\n\n```bash\n# Formatting\npnpm format        # Format code with Prettier\npnpm format:check  # Check formatting without writing\n\n# Linting\npnpm lint          # Fix ESLint issues\npnpm lint:check    # Check ESLint issues without fixing\n\n# Testing\npnpm test          # Run tests once\npnpm test:watch    # Run tests in watch mode\npnpm test:coverage # Run tests with coverage report\n\n# Building\npnpm build         # Production build\npnpm dev           # Development mode with watch\n\n# Type Checking\npnpm typecheck     # Check TypeScript types\n```\n\n## Publishing\n\nThe template automatically runs `pnpm validate` before publishing via the `prepublishOnly` script.\n\n```bash\nnpm version patch|minor|major\nnpm publish --access public\n```\n\n## Project Structure\n\n```\nsrc/\n├── index.ts          # Main library entry point\ntest/\n├── *.spec.ts         # Test files\ndist/                 # Built output (CommonJS + ES modules + types)\n```\n\n## Tooling\n\n- **Build**: [ts-builds](https://github.com/jordanburke/ts-builds) - Centralized TypeScript toolchain\n- **Bundler**: [tsdown](https://tsdown.dev/) - Fast TypeScript bundler (successor to tsup)\n- **Test**: [Vitest](https://vitest.dev/) - Fast unit test framework\n- **Lint**: [ESLint](https://eslint.org/) with TypeScript support\n- **Format**: [Prettier](https://prettier.io/) with ESLint integration\n- **Package Manager**: [pnpm](https://pnpm.io/) for fast, efficient installs\n\n## Claude Code Skill\n\nThis repository includes a Claude Code skill to help you apply these standards to other projects:\n\n**Location**: `.claude/skills/typescript-standards/`\n\n**Usage**: When using Claude Code, the skill automatically provides guidance for:\n\n- Creating new libraries from this template\n- Applying these standards to existing TypeScript projects\n- Configuring tooling (ts-builds, Vitest, ESLint, Prettier)\n- Setting up dual module format\n\n**Installation** (for use in other projects):\n\n```bash\n# Copy the skill to your Claude Code skills directory\ncp -r .claude/skills/typescript-standards ~/.claude/skills/\n```\n\n**References**:\n\n- [CLAUDE.md](./CLAUDE.md) - Development guidance for this project\n- [STANDARDIZATION_GUIDE.md](./STANDARDIZATION_GUIDE.md) - Guide for applying these patterns to existing projects\n- [.claude/skills/typescript-standards/](./.claude/skills/typescript-standards/) - Complete skill documentation\n\n---\n\n_This template is based on the earlier work of https://github.com/orabazu/tsup-library-template but updated with modern tooling and standardized scripts._\n"
      },
      "plugins": [
        {
          "name": "typescript-standards",
          "description": "Guide for creating TypeScript libraries using the typescript-library-template pattern and applying its standards to existing projects. Use when setting up new npm packages, standardizing build scripts, configuring tooling (tsup, Vitest, ESLint, Prettier), or applying dual module format patterns.",
          "source": "./",
          "strict": false,
          "skills": [
            "./.claude/skills/typescript-standards"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add jordanburke/typescript-library-template",
            "/plugin install typescript-standards@typescript-standards"
          ]
        }
      ]
    }
  ]
}