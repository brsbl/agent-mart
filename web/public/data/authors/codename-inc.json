{
  "author": {
    "id": "Codename-Inc",
    "display_name": "Codename",
    "avatar_url": "https://avatars.githubusercontent.com/u/211721538?v=4"
  },
  "marketplaces": [
    {
      "name": "spectre",
      "version": "3.4.0",
      "description": "spectre - Structured agentic workflow for AI coding. Scope, Plan, Execute, Clean, Test, Rebase, Extract. A meta-prompting system where prompts invoke subagents that execute specialized prompts.",
      "repo_full_name": "Codename-Inc/spectre",
      "repo_url": "https://github.com/Codename-Inc/spectre",
      "repo_description": "SPECTRE is an agentic Coding Workflow - /Scope, /Plan, /Execute, /Clean, /Test, /Rebase, /Evaluate - that uses simply step by step product development workflow to generate high quality results from your AI Coding Agents.",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-12T19:48:30Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"spectre\",\n  \"version\": \"3.4.0\",\n  \"owner\": {\n    \"name\": \"Joe Fernandez\",\n    \"email\": \"joe@subspace.build\"\n  },\n  \"metadata\": {\n    \"description\": \"spectre - Structured agentic workflow for AI coding. Scope, Plan, Execute, Clean, Test, Rebase, Extract. A meta-prompting system where prompts invoke subagents that execute specialized prompts.\",\n    \"homepage\": \"https://github.com/Codename-Inc/spectre\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"spectre\",\n      \"source\": \"./plugins/spectre\",\n      \"description\": \"Agentic coding workflow with session memory. spectre guides you through Scope, Plan, Execute, Clean, Test, Rebase, and Extract phases. Includes cross-session memory via /spectre:handoff. Start with /spectre:scope.\",\n      \"author\": {\n        \"name\": \"Joe Fernandez\",\n        \"email\": \"joe@subspace.build\"\n      },\n      \"keywords\": [\n        \"workflow\",\n        \"tdd\",\n        \"planning\",\n        \"code-review\",\n        \"session\",\n        \"memory\",\n        \"handoff\"\n      ],\n      \"version\": \"3.4.0\"\n    }\n  ]\n}\n",
        "README.md": "# SPECTRE\n\n**S**cope ‚Üí **P**lan ‚Üí **E**xecute ‚Üí **C**lean ‚Üí **T**est ‚Üí **R**ebase ‚Üí **E**valuate\n\n**Get higher quality results from your coding agent, while they working autonomously for much longer, so 10-100x'ing your typical output feels easy.**\n\n![SPECTRE hero](./assets/images/spectre-hero.png)\n\n## ‚ö° Quick Start\n\n### Within Claude Code\n\n```bash\n# Add marketplace and install\n/plugin marketplace add Codename-Inc/spectre\n/plugin install SPECTRE@codename\n```\n\nThen start building:\n\n```plaintext\n/spectre:scope\n```\n\nThat's it. You just start with 1 command to build features.\n\n![SPECTRE scope command](./assets/images/spectre-scope.png)\n\n## üéØ Core SPECTRE Principles\n\n- Great Inputs -&gt; Great Outputs\n- Ambiguity is Death\n- One Workflow, Every Feature, Any Size, Any Codebase\n\n## üëª SPECTRE Purpose\n\nAI coding is changing product development, but why is it that Claude Code can still go off the rails? Why is it that some developers claim AI has 100x'd their output, while others still complain about the quality of the code it generates?\n\nLet me introduce you to a very simple concept that you need to drill into your head. With coding agents:\n\n> ### **AMBIGUITY IS DEATH.**\n\nWhen the scope, ux, and plan are ambiguous, you must rely on the LLM to fill in the blanks. And while sometimes you can get lucky - especially for smaller features - for any *real* technology or product work, ambiguity is how you end up with spaghetti code, conflicts, and AI slop.\n\nLLMs need specificity. And typically, providing the right level of specificity is a lot of work. Just think about the most detailed spec or technical design you‚Äôve ever written. Takes days and sometimes weeks.\n\nBUT --- you can use LLMs to make it EASY to provide that specificity. And that is exactly what SPECTRE does.\n\n### ‚úÖ Workflows = Easy Button\n\nPrompt based workflows are how you get the best, highest quality, and most consistent results from AI Coding Agents.\n\nThey provide the necessary context, detail, and structure for the agent to ask the right questions, investigate the right details, and generate the right requirements, plans, tasks, code, tests, and more.\n\nThe better your prompt based workflows, the lower the ambiguity, the more AI can take on, the longer AI can work autonomously, the more easily you can multi-task, and suddenly you are 100x'ing your output.\n\nThe path to 100x output is through **structured workflows**.\n\n### üíß So.... Waterfall?\n\nYeah basically Rapid Waterfall.\n\nSpecificity up front forces clarity, reduces ambiguity, and leads to better 1st pass results.\n\nTHEN -- you can iterate on the feature set, ux, architecture, etc. at lightning speed. AI coding agents are 10x better at working around *working* existing code. Its why they are so good at refactors. Because they are working with a working established baseline.\n\n**Worflows make it easier and faster to get to working code.**\n\nFrom there, you can iterate and adapt before you ship.\n\n## üìñ Background & Philosophy\n\n## About\n\nSPECTRE is the result of over 12 months of daily Claude Code use.\n\nThese are the *actual* prompts I use and iterate upon non stop every day to build products.\n\nWith SPECTRE, I built a React Native based AI Agent + GPS Rangefinder for Golfers (New June (in closed Alpha)) and a 250k line Tauri/Rust/React desktop application called Subspace (in open Beta - https://www.subspace.build).\n\n## üí° Why\n\nI created SPECTRE because I wanted:\n\n- a repeatable daily driver workflow that works on brand new projects, and large existing codebases.\n\n- a single workflow that works on both small & big features without being overwhelmed with process\n\n- a workflow that delivers robust engineering plans when needed, or a concise set of tasks if not\n\n- hands on planning but hands off execution\n\n- higher quality INPUT with LESS WORK so i can ensure the outputs are more aligned with my vision\n\n- a workflow that lets Agents learn my codebase, features, patterns, bugs, so I don't have to remember everything\n\n- ***stupid. simple. memory.*** agent sessions are aware of the ongoing thread of work (/spectre:handoff)\n\n### My Workflow Iteration Process\n\nI improve these prompts daily, and I didn't just prompt Claude Code to generate these prompts. I iterated over many months, adjusting the prompts based on both the user experience of using them, and the quality of results that I got.\n\nFor example:\n\n- I iterated on /spectre:scope until I felt like the types of questions actually help me get clear on what I'm building, without asking questions that it could easily get from codebase research\n- I iterated on the /spectre:execute workflow until it successfully delivered large tasks in a single context window using subagents that deliver completion reports to handoff to the next subagents, use TDD effectively, and autonomously adapt the tasks based on what was discovered DURING development instead of blindly\n- I iterated on the /spectre:clean and /spectre:test workflows until it felt automatic that we were sticking to our linting rules, every new feature was well tested/covered, the commits were grouped logically with the appropriate amount of detail.\n- I iterated on the /spectre:evaluate learning workflow until 1) the agent automatically reached for the skills generated at the start of every conversation, 2) captured the *right* details and insights, and 3) proactively updated relevant skills as we make changes and learn more.\n- I iterated on the /spectre:handoff workflow until the status update had the appropriate detail/context, and worked perfectly if I'm working across MANY sessions or just one.\n\nSPECTRE made products like New June and Subspace possible, and it is making it possible for me, an ex-Meta, ex-Amazon Technical Product Manager to build, ship, and iterate on products 100x the complexity of anything I've ever built in the past.\n\n## üîÑ The SPECTRE Workflow\n\nIf you start with /scope, your agent will guide you through the rest of the steps automatically.\n\n| Phase | Command | What It Does |\n| --- | --- | --- |\n| **S**cope | `/spectre:scope` | Define requirements, constraints, success criteria |\n| **P**lan | `/spectre:plan` | Research codebase, create implementation plan |\n| **E**xecute | `/spectre:execute` | Parallel implementation with wave-based delivery |\n| **C**lean | `/spectre:clean` | Remove dead code, lint, format |\n| **T**est | `/spectre:test` | Risk-aware test coverage |\n| **R**ebase | `/spectre:rebase` | Safe merge preparation with conflict handling |\n| **E**valuate | `/spectre:evaluate` | Architecture review + knowledge capture |\n\nEach command ends with \"Next Steps\" suggestions, so you always know what prompt to run next ‚Äî you don't have to remember what the prompts are, which is one thing that kills me about many other Spec Driven Development workflows.\n\nYou can use *any* of the commands in any sequence you want - they are good standalone too. More on my typical daily usage below.\n\n## üß† SPECTRE Session Memory\n\nSPECTRE maintains and accumulates context across sessions when you use the /spectre:handoff command. To get the most from SPECTRE's Session Memory, we recommend that you:\n\n1. turn off auto-compact in Claude Code /config settings, and\n\n2. run /spectre:handoff liberally when you are switching gears or the context window is getting north of 160k tokens.\n\n### How It Works\n\nWhen you run /spectre:handoff, a status report will get generated for that session, and automatically loaded into your context window for the next session. You'll see a nice summary of the status when you run /clear.\n\nIf you already had previous sessions, a subagent (@spectre:sync) will review the last 3 status updates and merge into a single continuous session memory.\n\nVoila -- trailing 3 session memory snapshots.\n\nIf you want to start fresh ‚Äî /spectre:forget archives the session_logs.\n\n```plaintext\n/spectre:handoff   # Save progress before session ends\n/spectre:forget    # Clear memory for fresh start\n```\n\n## üß¨ SPECTRE Evaluate\n\nThe more I used SPECTRE and the faster I could build, the more frequently I found myself wanting to reference past work. Debugging sessions, a new architectural pattern, or how a feature works/was built.\n\nSPECTRE Evaluate combines **architecture review** with **knowledge capture** ‚Äî reviewing what you built and learning from it in one step.\n\n### How It Works\n\n`/spectre:evaluate` runs two things in parallel:\n\n1. **Architecture review** ‚Äî dispatches an Opus 4.6 subagent in the background to produce a principal-level architecture review of your completed work\n2. **Learn** ‚Äî captures durable project knowledge (patterns, gotchas, decisions) into re-usable skills that **auto-load in future sessions**\n\n### The Hook + Skill Loop\n\nWhat is great about SPECTRE's learning system, is that Claude Code automatically loads skills that are relevant. We do this with a 'coercion' technique I borrowed from Jesse Vincent's great Superpowers skill.\n\n1. **SessionStart hook** ‚Äî every time you start a conversation, SPECTRE's hook reads your project's knowledge registry and injects it into context. Claude now *knows what it knows* before you type a single word.\n\n2. **Skill auto-loading** ‚Äî when your task matches a trigger word from the registry (e.g., you mention \"auth\" and there's a `feature-auth-flows` skill), Claude loads the full skill *before* searching the codebase. No wasted tool calls rediscovering what's already documented.\n\nThe result: knowledge compounds across sessions instead of resetting to zero. The more you learn, the faster and more accurate every future session becomes.\n\n### What Gets Captured\n\n| Category | Example |\n| --- | --- |\n| **Gotchas** | \"The websocket reconnect silently fails if...\" |\n| **Decisions** | \"We chose SQLite over Postgres because...\" |\n| **Features** | Architecture dossiers ‚Äî key files, flows, common tasks |\n| **Patterns** | Reusable solutions established across the codebase |\n| **Procedures** | Multi-step processes like deploy, release, migrate |\n\nYou can also run these independently:\n\n```plaintext\n/spectre:evaluate              # Architecture review + learn (the full evaluate step)\n/spectre:learn                 # Just capture knowledge from this session\n/spectre:architecture_review   # Just run the architecture review\n/spectre:recall auth           # Find and load existing knowledge about auth\n```\n\n## ü§ñ Subagents\n\nSPECTRE dispatches specialized subagents for different tasks:\n\nNOTE: You don't even need to know that these subagents exist. The prompts instruct Claude Code to call them automatically.\n\nAlthough I do sometimes use @spectre:web-research for web research. It's like mini deep-research.\n\n| Agent | Purpose |\n| --- | --- |\n| `@spectre:dev` | Implementation with MVP focus |\n| `@spectre:analyst` | Understand how code works |\n| `@spectre:finder` | Find where code lives |\n| `@spectre:patterns` | Find reusable patterns |\n| `@spectre:web-research` | Web research |\n| `@spectre:tester` | Test automation |\n| `@spectre:reviewer` | Independent code review |\n\n## üõ†Ô∏è How I Typically use SPECTRE\n\n99.9% of my day is spent using SPECTRE exactly like this.\n\n- start /spectre:scope to get crisp on what's in/out. this is non-negotiable unless the feature is a one line ask.\n\n- /spectre:plan to build out a well researched technical design or set of tasks\n\n  - once i have scope/plan/tasks, I typically run /spectre:handoff to get a fresh context window with awareness of what we're working on.\n\n- then run /spectre:execute to use parallel subagents to work through the tasks. Execute is a meta prompt that also calls /spectre:code_review and /spectre:validate.\n\n  - side note /spectre:validate is a killer prompt. It breaks down the original tasks and dispatches subagents to verify. find stuff missing all the time with this.\n\n  - when initial execution is complete, i run another /spectre:handoff to get the context window clean for fixes/touch ups.\n\n- From here ‚Äî I do a bunch of manual testing and fixing.\n\n  - I largely use Claude Code's built in /plan mode for fixes in this phase.\n\n  - If there is a bug that can't easily be solved, i use the /spectre:fix prompt for a more structured debugging approach.\n\n  - If something new comes up, or if the scope is not what I'd hoped, I run a new /scope cycle from within the project.\n\n  - I liberally use /spectre:handoff here to keep context windows clean as I work through issues, and keep the sessions on track with the progress we're making.\n\n- During the process of manual testing/fixing, I typically accumulate uncommitted changes. /spectre:sweep will get your changes committed, while\n\n  - running and addressing lint\n  - running tests and related tests on touched files\n  - finding obvious dead code/AI slop, and\n  - grouping changes logically with descriptive conventional commits\n\n- Once wrapping up, /spectre:clean is a much deeper cleanup that dispatches subagents to find dead code, duplicates, verifies, lint, commits any stragglers, etc.\n\n- Then /spectre:test does deep analysis and dispatches subagents to write tests based on a risk-adjusted framework focusing on behavior not implementation details.\n\n- Once cleaned/tested ‚Äî /spectre:rebase works great to rebase onto your parent branch, but obviously you do you with your release flow. From here I create PR/merge or directly merge depending on the task.\n\n- Finally, I run /spectre:evaluate to get an architecture review and capture any knowledge worth preserving ‚Äî patterns, gotchas, decisions. This builds institutional memory that loads automatically in future sessions.\n\n## üìã Slash Command Reference\n\n### Core Workflow\n\n| Command | Description |\n| --- | --- |\n| `/spectre:scope` | Interactive feature scoping |\n| `/spectre:plan` | Research codebase, create implementation plan |\n| `/spectre:execute` | Wave-based parallel execution with code review |\n| `/spectre:clean` | Code cleanup and quality gates |\n| `/spectre:test` | Risk-aware test coverage |\n| `/spectre:rebase` | Safe rebase with conflict handling |\n| `/spectre:evaluate` | Architecture review + knowledge capture |\n\n### Quick Start\n\n| Command | Description |\n| --- | --- |\n| `/spectre:quick_dev` | Scope + plan for small/medium tasks |\n\n### Discovery & Research\n\n| Command | Description |\n| --- | --- |\n| `/spectre:kickoff` | Deep research for high-ambiguity features |\n| `/spectre:research` | Parallel codebase research |\n\n### Session Memory\n\n| Command | Description |\n| --- | --- |\n| `/spectre:handoff` | Save session state snapshot |\n| `/spectre:forget` | Clear memory, archive logs |\n\n### Utilities\n\nThese are situational commands.\n\nI use /spectre:fix for pretty much all bugs I run into.\n\n| Command | Description |\n| --- | --- |\n| `/spectre:sweep` | Light cleanup pass ‚Äî lint, test, descriptive commits |\n| `/spectre:learn` | Capture knowledge for future sessions |\n| `/spectre:ux_spec` | UX specification for UI-heavy features |\n| `/spectre:fix` | Investigate bugs & implement fixes |\n\n## üìÅ Repository Structure\n\n```plaintext\nspectre/\n‚îú‚îÄ‚îÄ .claude-plugin/\n‚îÇ   ‚îî‚îÄ‚îÄ marketplace.json  # Marketplace registration\n‚îú‚îÄ‚îÄ plugins/\n‚îÇ   ‚îî‚îÄ‚îÄ spectre/\n‚îÇ       ‚îú‚îÄ‚îÄ .claude-plugin/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ plugin.json   # Plugin manifest\n‚îÇ       ‚îú‚îÄ‚îÄ commands/         # Slash commands\n‚îÇ       ‚îú‚îÄ‚îÄ agents/           # Subagent definitions\n‚îÇ       ‚îú‚îÄ‚îÄ hooks/            # Session memory hooks\n‚îÇ       ‚îî‚îÄ‚îÄ skills/           # Skills\n‚îú‚îÄ‚îÄ scripts/              # Release & utility scripts\n‚îî‚îÄ‚îÄ CLAUDE.md\n```\n\n## üìÑ License\n\nMIT"
      },
      "plugins": [
        {
          "name": "spectre",
          "source": "./plugins/spectre",
          "description": "Agentic coding workflow with session memory. spectre guides you through Scope, Plan, Execute, Clean, Test, Rebase, and Extract phases. Includes cross-session memory via /spectre:handoff. Start with /spectre:scope.",
          "author": {
            "name": "Joe Fernandez",
            "email": "joe@subspace.build"
          },
          "keywords": [
            "workflow",
            "tdd",
            "planning",
            "code-review",
            "session",
            "memory",
            "handoff"
          ],
          "version": "3.4.0",
          "categories": [
            "code-review",
            "handoff",
            "memory",
            "planning",
            "session",
            "tdd",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add Codename-Inc/spectre",
            "/plugin install spectre@spectre"
          ]
        }
      ]
    },
    {
      "name": "spectre-labs",
      "version": "3.6.0",
      "description": "Experimental features for SPECTRE workflow framework.",
      "repo_full_name": "Codename-Inc/spectre-labs",
      "repo_url": "https://github.com/Codename-Inc/spectre-labs",
      "repo_description": "Experimental features for SPECTRE workflow framework",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-08T14:45:07Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"spectre-labs\",\n  \"version\": \"3.6.0\",\n  \"owner\": {\n    \"name\": \"Joe Fernandez\",\n    \"email\": \"joe@subspace.build\"\n  },\n  \"metadata\": {\n    \"description\": \"Experimental features for SPECTRE workflow framework.\",\n    \"homepage\": \"https://github.com/Codename-Inc/spectre-labs\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"sparks\",\n      \"source\": \"./sparks\",\n      \"description\": \"Knowledge capture and recall. Use /learn to save learnings, they'll be automatically recalled when relevant.\",\n      \"version\": \"3.6.0\"\n    }\n  ]\n}\n",
        "README.md": "# SPECTRE Labs\n\nExperimental and power-user features for the [SPECTRE](https://github.com/Codename-Inc/spectre) workflow framework.\n\n## Build Loop\n\nAutomated task execution CLI that runs Claude Code (or Codex) in a loop, completing one parent task per iteration with built-in validation.\n\n### Install\n\n```bash\ncd build-loop\npipx install -e .\n```\n\n### Usage\n\n```bash\n# Interactive mode (prompts for inputs)\nspectre-build\n\n# Flag-based\nspectre-build --tasks tasks.md --context scope.md --max-iterations 10\n\n# With post-build validation\nspectre-build --tasks tasks.md --validate\n\n# From a manifest file (YAML frontmatter)\nspectre-build docs/tasks/feature-x/build.md\n\n# Resume interrupted session\nspectre-build resume\n\n# Start the web GUI\nspectre-build serve\n```\n\n### Features\n\n- **Multi-agent** ‚Äî Pluggable backends (Claude Code, Codex)\n- **Validation cycles** ‚Äî Post-build gap analysis with automatic remediation\n- **Manifest mode** ‚Äî Self-documenting builds via YAML frontmatter in `.md` files\n- **Pipeline mode** ‚Äî Stage-based execution from YAML definitions\n- **Session resume** ‚Äî Pick up where you left off after interruptions\n- **TDD integration** ‚Äî Loads `spectre-tdd` skill for test-driven execution\n- **Web GUI** ‚Äî FastAPI server with real-time WebSocket streaming\n\n### How It Works\n\nEach iteration follows a 6-step cycle:\n\n1. **Context Gathering** ‚Äî Read progress, context files, and task state\n2. **Task Planning** ‚Äî Select one incomplete parent task\n3. **Task Execution** ‚Äî Implement with TDD\n4. **Verification** ‚Äî Lint and test\n5. **Progress Update** ‚Äî Commit and write progress\n6. **Promise** ‚Äî Signal `TASK_COMPLETE` or `BUILD_COMPLETE`\n\nThe loop exits when all tasks are marked complete or max iterations is reached.\n\n## Why Separate?\n\nThese features are:\n- **Experimental** ‚Äî APIs may change\n- **Power-user oriented** ‚Äî Require more setup\n- **Not core to SPECTRE** ‚Äî You can use SPECTRE workflow without them\n\nThe main [SPECTRE](https://github.com/Codename-Inc/spectre) repo contains the stable workflow framework.\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "sparks",
          "source": "./sparks",
          "description": "Knowledge capture and recall. Use /learn to save learnings, they'll be automatically recalled when relevant.",
          "version": "3.6.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add Codename-Inc/spectre-labs",
            "/plugin install sparks@spectre-labs"
          ]
        }
      ]
    }
  ]
}