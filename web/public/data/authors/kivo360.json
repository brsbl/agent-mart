{
  "author": {
    "id": "kivo360",
    "display_name": "Kevin Hill",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/2403240?u=6dc50c315eb11d00cfe1646c6d9c43db2a736432&v=4",
    "url": "https://github.com/kivo360",
    "bio": "I code stuff. #finance",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 3,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "claude-toolbelt",
      "version": "1.0.0",
      "description": "A personal collection of professional Claude Code plugins for database development, automation, and productivity tools",
      "owner_info": {
        "name": "Kevin Hill",
        "email": "kevin.hill@example.com",
        "url": "https://github.com/kivo360"
      },
      "keywords": [
        "database",
        "sqlalchemy",
        "asyncpg",
        "fastapi",
        "supabase",
        "conversion",
        "productivity"
      ],
      "repo_full_name": "kivo360/claude-toolbelt",
      "repo_url": "https://github.com/kivo360/claude-toolbelt",
      "repo_description": "A personal collection of professional Claude Code plugins for database development, automation, and productivity tools",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-20T18:27:08Z",
        "created_at": "2025-11-20T18:25:36Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1844
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 738
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/README.md",
          "type": "blob",
          "size": 9874
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/agents/conversion-analyzer.md",
          "type": "blob",
          "size": 6036
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/agents/schema-reflector.md",
          "type": "blob",
          "size": 7912
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/convert-project.md",
          "type": "blob",
          "size": 2163
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/create-session.md",
          "type": "blob",
          "size": 2940
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/generate-models.md",
          "type": "blob",
          "size": 2621
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/commands/validate-conversion.md",
          "type": "blob",
          "size": 4373
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/hooks/hooks.json",
          "type": "blob",
          "size": 334
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/asyncpg-detection",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/asyncpg-detection/SKILL.md",
          "type": "blob",
          "size": 2790
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/sqlalchemy-conversion",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/sqlalchemy-conversion/SKILL.md",
          "type": "blob",
          "size": 4345
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/supabase-integration",
          "type": "tree",
          "size": null
        },
        {
          "path": "asyncpg-to-sqlalchemy-converter/skills/supabase-integration/SKILL.md",
          "type": "blob",
          "size": 16027
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-toolbelt\",\n  \"version\": \"1.0.0\",\n  \"owner\": {\n    \"name\": \"Kevin Hill\",\n    \"email\": \"kevin.hill@example.com\",\n    \"url\": \"https://github.com/kivo360\"\n  },\n  \"description\": \"A personal collection of professional Claude Code plugins for database development, automation, and productivity tools\",\n  \"keywords\": [\"database\", \"sqlalchemy\", \"asyncpg\", \"fastapi\", \"supabase\", \"conversion\", \"productivity\"],\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/kivo360/claude-toolbelt\",\n  \"plugins\": [\n    {\n      \"name\": \"asyncpg-to-sqlalchemy-converter\",\n      \"version\": \"1.0.0\",\n      \"source\": \"./asyncpg-to-sqlalchemy-converter\",\n      \"description\": \"Convert asyncpg code in FastAPI projects to SQLAlchemy 2.0+ with async support, optimized for Supabase integration\",\n      \"author\": \"Kevin Hill\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"asyncpg\", \"sqlalchemy\", \"fastapi\", \"database\", \"migration\", \"supabase\", \"conversion\"],\n      \"capabilities\": [\"skills\", \"commands\", \"agents\", \"hooks\"],\n      \"category\": \"database\",\n      \"dependencies\": [],\n      \"repository\": \"https://github.com/kivo360/claude-toolbelt/tree/main/plugins/asyncpg-to-sqlalchemy-converter\",\n      \"homepage\": \"https://github.com/kivo360/claude-toolbelt#asyncpg-to-sqlalchemy-converter\",\n      \"docs\": \"https://github.com/kivo360/claude-toolbelt/blob/main/plugins/asyncpg-to-sqlalchemy-converter/README.md\"\n    }\n  ],\n  \"categories\": {\n    \"database\": \"Database and ORM tools\",\n    \"productivity\": \"Productivity and automation\",\n    \"development\": \"Development workflow tools\"\n  },\n  \"installation\": {\n    \"commands\": [\n      \"/plugin marketplace add kivo360/claude-toolbelt\",\n      \"/plugin install asyncpg-to-sqlalchemy-converter\"\n    ],\n    \"requirements\": [\n      \"Claude Code 2.0.13+\",\n      \"Python 3.8+\",\n      \"SQLAlchemy 2.0+\"\n    ]\n  }\n}",
        "asyncpg-to-sqlalchemy-converter/.claude-plugin/plugin.json": "{\n  \"name\": \"asyncpg-to-sqlalchemy-converter\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Convert asyncpg code in FastAPI projects to SQLAlchemy with asyncpg engine, supporting Supabase integration and lazy loading\",\n  \"author\": {\n    \"name\": \"Claude Code Plugin Developer\",\n    \"email\": \"dev@example.com\"\n  },\n  \"homepage\": \"https://github.com/claude-code-plugins/asyncpg-to-sqlalchemy-converter\",\n  \"repository\": \"https://github.com/claude-code-plugins/asyncpg-to-sqlalchemy-converter\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"asyncpg\", \"sqlalchemy\", \"fastapi\", \"database\", \"migration\", \"supabase\", \"conversion\"],\n  \"commands\": \"./commands\",\n  \"agents\": \"./agents\",\n  \"skills\": \"./skills\",\n  \"hooks\": \"./hooks\",\n  \"mcpServers\": \"./.mcp.json\"\n}",
        "asyncpg-to-sqlalchemy-converter/README.md": "# asyncpg-to-sqlalchemy-converter\n\nA comprehensive Claude Code plugin for converting asyncpg database code in FastAPI projects to SQLAlchemy 2.0+ with async support, optimized for Supabase integration.\n\n## üöÄ Features\n\n### Core Conversion Capabilities\n- **Automatic Detection**: Scans FastAPI projects for asyncpg usage patterns\n- **Systematic Conversion**: Converts asyncpg code to SQLAlchemy async patterns\n- **Full Compatibility**: Maintains functionality while improving maintainability\n- **Rollback Support**: Backup and recovery for safe conversions\n\n### Supabase Integration\n- **Native Supabase Support**: Optimized for Supabase PostgreSQL databases\n- **RLS Integration**: Row Level Security context handling\n- **Auth Integration**: Seamless Supabase auth with SQLAlchemy sessions\n- **Performance Tuning**: Connection pooling optimized for Supabase\n\n### Advanced Features\n- **Lazy Loading**: Efficient handling of large database schemas\n- **Model Generation**: Automatic SQLAlchemy model creation from database schema\n- **Validation**: Comprehensive testing and validation of converted code\n- **Performance Analysis**: Benchmarking and optimization recommendations\n\n## üì¶ Installation\n\nThis is a Claude Code plugin. Install it using the Claude Code plugin manager:\n\n```bash\nclaude plugin install asyncpg-to-sqlalchemy-converter\n```\n\n## üõ†Ô∏è Quick Start\n\n### Convert Your Project\n\n1. **Detect asyncpg usage**:\n   ```\n   /convert-asyncpg-to-sqlalchemy --dry-run --path ./your-fastapi-project\n   ```\n\n2. **Perform conversion**:\n   ```\n   /convert-asyncpg-to-sqlalchemy --supabase --path ./your-fastapi-project\n   ```\n\n3. **Validate conversion**:\n   ```\n   /validate-sqlalchemy-conversion --connection-string $DATABASE_URL\n   ```\n\n### Generate Models from Database\n\n```bash\n# Generate from Supabase\n/generate-sqlalchemy-models --supabase-optimize --output ./models/\n\n# Generate from any PostgreSQL database\n/generate-sqlalchemy-models --url \"postgresql+asyncpg://user:pass@host:5432/db\"\n```\n\n### Create Session Management\n\n```bash\n# Create async session setup\n/create-async-session --supabase --testing --output ./src/database\n```\n\n## üéØ Skills\n\n### asyncpg-detection\nAutomatically detects asyncpg usage patterns in your FastAPI project:\n- Import detection (`import asyncpg`, `from asyncpg import`)\n- Connection pattern analysis (`asyncpg.connect`, `asyncpg.create_pool`)\n- Query method identification (`fetch`, `fetchrow`, `execute`)\n\n**Usage**: Use automatically with `/convert-asyncpg-to-sqlalchemy` or trigger with phrases like:\n- \"detect asyncpg usage\"\n- \"find asyncpg patterns\"\n- \"scan for asyncpg imports\"\n\n### sqlalchemy-conversion\nProvides systematic conversion guidance from asyncpg to SQLAlchemy:\n- Import replacement patterns\n- Query conversion (`fetch` ‚Üí `execute`, parameter binding)\n- Transaction handling updates\n- Error handling migration\n\n**Usage**: Trigger with phrases like:\n- \"convert asyncpg to SQLAlchemy\"\n- \"migrate asyncpg code\"\n- \"update database queries\"\n\n### supabase-integration\nSpecialized integration for Supabase databases:\n- Async engine configuration for Supabase\n- RLS and auth integration\n- Connection pooling optimization\n- Performance tuning\n\n**Usage**: Trigger with phrases like:\n- \"configure Supabase with SQLAlchemy\"\n- \"set up Supabase async engine\"\n- \"handle Supabase authentication\"\n\n## ü§ñ Agents\n\n### conversion-analyzer\nAnalyzes complex asyncpg patterns and determines optimal conversion strategies:\n- Complexity assessment and risk analysis\n- Performance impact evaluation\n- Manual intervention requirements\n- Conversion planning and prioritization\n\n### schema-reflector\nPerforms comprehensive database schema reflection and model generation:\n- Database structure analysis\n- Intelligent model generation with relationships\n- Performance optimization recommendations\n- Schema documentation\n\n## üìã Commands\n\n### /convert-asyncpg-to-sqlalchemy\nMain conversion command that analyzes and converts asyncpg code.\n\n**Options**:\n- `--path <directory>`: Project directory (default: current)\n- `--supabase`: Enable Supabase optimizations\n- `--dry-run`: Preview changes without modification\n- `--backup <directory>`: Backup location\n- `--interactive`: Prompt for confirmation\n\n**Examples**:\n```bash\n/convert-asyncpg-to-sqlalchemy --supabase --dry-run\n/convert-asyncpg-to-sqlalchemy --path ./src --backup ./original\n```\n\n### /generate-sqlalchemy-models\nGenerate SQLAlchemy models from database schema.\n\n**Options**:\n- `--url <connection_string>`: Database connection\n- `--schema <name>`: Schema to reflect (default: public)\n- `--output <file>`: Output file (default: models.py)\n- `--supabase-optimize`: Optimize for Supabase\n- `--lazy-load`: Enable lazy loading\n\n**Examples**:\n```bash\n/generate-sqlalchemy-models --supabase-optimize --output ./models/\n/generate-sqlalchemy-models --schema analytics --lazy-load\n```\n\n### /create-async-session\nCreate async session management setup for FastAPI.\n\n**Options**:\n- `--output <directory>`: Output directory (default: ./database)\n- `--supabase`: Include Supabase configurations\n- `--testing`: Include testing setup\n- `--migrations`: Include Alembic setup\n- `--pool-size <number>`: Connection pool size\n\n**Examples**:\n```bash\n/create-async-session --supabase --testing\n/create-async-session --output ./src/database --pool-size 20\n```\n\n### /validate-sqlalchemy-conversion\nValidate converted SQLAlchemy code and test functionality.\n\n**Options**:\n- `--path <directory>`: Project directory to validate\n- `--connection-string <url>`: Database for testing\n- `--supabase`: Include Supabase validations\n- `--performance`: Include benchmarks\n- `--fix-issues`: Auto-fix detected issues\n\n**Examples**:\n```bash\n/validate-sqlalchemy-conversion --supabase --performance\n/validate-sqlalchemy-conversion --connection-string $DATABASE_URL --fix-issues\n```\n\n## üîß Configuration\n\n### Environment Variables\n\n```bash\n# Supabase Configuration\nSUPABASE_URL=\"postgresql+asyncpg://postgres.project_id:password@aws-0-region.pooler.supabase.com:6543/postgres\"\nSUPABASE_KEY=\"your_supabase_anon_key\"\nSUPABASE_SERVICE_KEY=\"your_supabase_service_key\"\n\n# Database Configuration\nDATABASE_URL=\"your_database_connection_string\"\nDB_POOL_SIZE=20\nDB_MAX_OVERFLOW=5\n```\n\n### Plugin Configuration\n\nThe plugin includes customizable validation hooks and MCP servers:\n- **SQLAlchemy Validation**: Automatic pattern validation during file operations\n- **Supabase MCP Server**: Database introspection and validation capabilities\n\n## üìö Examples\n\n### Basic Conversion Example\n\n**Before (asyncpg)**:\n```python\nimport asyncpg\n\nasync def get_user(db_pool, user_id: int):\n    async with db_pool.acquire() as conn:\n        result = await conn.fetchrow(\n            \"SELECT * FROM users WHERE id = $1\",\n            user_id\n        )\n        return dict(result)\n```\n\n**After (SQLAlchemy)**:\n```python\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nasync def get_user(session: AsyncSession, user_id: int):\n    result = await session.execute(\n        select(User).where(User.id == user_id)\n    )\n    return result.scalar_one_or_none()\n```\n\n### Supabase Integration Example\n\n```python\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import async_sessionmaker\n\n# Supabase optimized engine\nengine = create_async_engine(\n    \"postgresql+asyncpg://postgres.project_id:password@aws-0-region.pooler.supabase.com:6543/postgres\",\n    pool_size=20,\n    pool_pre_ping=True,\n    connect_args={\n        \"server_settings\": {\n            \"application_name\": \"fastapi_supabase_app\",\n            \"search_path\": \"public, extensions\"\n        }\n    }\n)\n\nAsyncSessionFactory = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n```\n\n## üß™ Testing\n\nThe plugin includes comprehensive testing capabilities:\n\n1. **Validation Scripts**: Automatic pattern checking and syntax validation\n2. **Database Testing**: Functional testing with real database connections\n3. **Performance Benchmarks**: Comparison of before/after performance\n4. **Integration Tests**: FastAPI endpoint testing with converted code\n\n## üîÑ Workflow\n\n1. **Discovery**: Use asyncpg-detection skill to analyze your project\n2. **Analysis**: conversion-analyzer assesses complexity and risks\n3. **Conversion**: Apply systematic conversion with convert-project command\n4. **Validation**: Use validate-conversion to ensure success\n5. **Optimization**: Performance tuning and Supabase integration\n\n## üõ†Ô∏è Development\n\n### Project Structure\n```\nasyncpg-to-sqlalchemy-converter/\n‚îú‚îÄ‚îÄ .claude-plugin/          # Plugin configuration\n‚îú‚îÄ‚îÄ agents/                  # AI agents for analysis\n‚îú‚îÄ‚îÄ commands/                # CLI commands\n‚îú‚îÄ‚îÄ skills/                  # Detection and conversion skills\n‚îú‚îÄ‚îÄ scripts/                 # Validation and utility scripts\n‚îú‚îÄ‚îÄ hooks/                   # File operation hooks\n‚îî‚îÄ‚îÄ README.md               # This file\n```\n\n### Contributing\n\nThis plugin follows Claude Code plugin development best practices:\n- Modular component architecture\n- Progressive disclosure for skills\n- Comprehensive error handling\n- Extensive documentation and testing\n\n## üìÑ License\n\nThis plugin is part of the Claude Code ecosystem and follows the same licensing terms.\n\n## ü§ù Support\n\nFor issues, feature requests, or questions:\n1. Check the plugin documentation\n2. Use the validation commands for troubleshooting\n3. Report issues through the Claude Code issue tracker\n\n## üîó Related Resources\n\n- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)\n- [Supabase Documentation](https://supabase.com/docs)\n- [FastAPI Documentation](https://fastapi.tiangolo.com/)\n- [Claude Code Plugin Development Guide](https://code.claude.com/docs)\n\n---\n\n**Transform your asyncpg FastAPI projects to modern SQLAlchemy with confidence!** üöÄ",
        "asyncpg-to-sqlalchemy-converter/agents/conversion-analyzer.md": "# Conversion Analyzer Agent\n\nA specialized AI agent that analyzes asyncpg code patterns and determines optimal SQLAlchemy conversion strategies. This agent handles complex conversion scenarios, edge cases, and provides detailed migration planning.\n\n## Capabilities\n\n### Code Pattern Analysis\n- Detects complex asyncpg usage patterns beyond simple detection\n- Analyzes query performance implications\n- Identifies conversion complexity and potential issues\n- Evaluates dependency chains and import relationships\n\n### Conversion Strategy Planning\n- Creates detailed conversion plans with priorities\n- Identifies files that require manual intervention\n- Suggests optimal SQLAlchemy patterns for specific use cases\n- Plans testing and validation strategies\n\n### Risk Assessment\n- Evaluates potential breaking changes\n- Identifies performance bottlenecks in conversion\n- Assesses data loss risks during migration\n- Provides rollback strategies\n\n### Optimization Recommendations\n- Suggests performance improvements during conversion\n- Identifies opportunities for better async patterns\n- Recommends Supabase-specific optimizations\n- Evaluates connection pooling strategies\n\n## Usage Patterns\n\n### Complex Conversion Analysis\nWhen the detection phase identifies complex asyncpg patterns that require careful analysis:\n\n```bash\n# Analyze specific complex files\n/agent:conversion-analyzer analyze --file ./src/database.py --complexity high\n\n# Analyze entire project with detailed reporting\n/agent:conversion-analyzer analyze --path ./src --detailed-report\n```\n\n### Risk Assessment\nBefore performing large-scale conversions:\n\n```bash\n# Assess conversion risks\n/agent:conversion-analyzer risk-assessment --path ./src --report-format json\n\n# Generate rollback plan\n/agent:conversion-analyzer rollback-plan --backup-path ./backup\n```\n\n### Performance Impact Analysis\nFor performance-critical applications:\n\n```bash\n# Analyze performance impact of conversion\n/agent:conversion-analyzer performance-analysis --baseline ./current_code\n\n# Generate optimization recommendations\n/agent:conversion-analyzer optimize-recommendations --target-profile production\n```\n\n## Analysis Features\n\n### Deep Code Analysis\n- Understands asyncpg transaction patterns\n- Identifies custom connection pooling logic\n- Detects manual query building and optimization\n- Analyzes error handling and retry logic\n\n### Dependency Mapping\n- Maps asyncpg dependencies across modules\n- Identifies shared database connection patterns\n- Analyzes middleware and dependency injection\n- Evaluates testing code dependencies\n\n### Conversion Complexity Scoring\n- **Low Complexity**: Simple queries with standard patterns\n- **Medium Complexity**: Custom queries with moderate complexity\n- **High Complexity**: Advanced patterns, custom connection handling\n- **Critical**: Complex transaction logic, performance-critical code\n\n### Manual Intervention Requirements\n- Complex query optimization patterns\n- Custom asyncpg extensions or wrappers\n- Performance-critical database operations\n- Business logic embedded in database operations\n\n## Output Reports\n\n### Conversion Plan Report\n```json\n{\n  \"conversion_plan\": {\n    \"total_files\": 45,\n    \"complexity_breakdown\": {\n      \"low\": 32,\n      \"medium\": 10,\n      \"high\": 2,\n      \"critical\": 1\n    },\n    \"recommended_approach\": \"incremental\",\n    \"estimated_time\": \"4-6 hours\",\n    \"manual_intervention_files\": [\"src/database.py\", \"src/complex_queries.py\"]\n  }\n}\n```\n\n### Risk Assessment Report\n```json\n{\n  \"risk_assessment\": {\n    \"overall_risk\": \"medium\",\n    \"breaking_changes\": 3,\n    \"performance_impact\": \"minimal\",\n    \"data_loss_risk\": \"low\",\n    \"rollback_feasibility\": \"high\"\n  }\n}\n```\n\n### Performance Impact Report\n```json\n{\n  \"performance_analysis\": {\n    \"query_performance\": \"maintained_or_improved\",\n    \"connection_efficiency\": \"improved\",\n    \"memory_usage\": \"reduced\",\n    \"recommendations\": [\n      \"Implement connection pooling\",\n      \"Add query result caching\",\n      \"Optimize batch operations\"\n    ]\n  }\n}\n```\n\n## Integration with Other Components\n\n### Works with Detection Skill\n- Takes detection results as input for deeper analysis\n- Provides detailed conversion strategies for detected patterns\n- Prioritizes conversion order based on complexity and dependencies\n\n### Supports Conversion Skill\n- Provides detailed conversion guidance\n- Suggests optimal SQLAlchemy patterns\n- Identifies edge cases that require special handling\n\n### Enhances Validation Skill\n- Provides validation criteria for converted code\n- Identifies test scenarios based on original patterns\n- Suggests performance benchmarks\n\n## Advanced Features\n\n### Machine Learning Pattern Recognition\n- Learns from conversion patterns across multiple projects\n- Improves complexity scoring over time\n- Identifies common pitfalls and optimization opportunities\n- Provides pattern-based conversion recommendations\n\n### Multi-Project Analysis\n- Can analyze dependencies across multiple services\n- Coordinates conversions for microservices architectures\n- Manages database schema changes across services\n- Coordinates testing across service boundaries\n\n### Custom Rule Engine\n- Supports custom conversion rules for specific projects\n- Allows organization-specific patterns and conventions\n- Integrates with existing code quality tools\n- Supports compliance and security requirements\n\n## Best Practices\n\n### When to Use\n- Large codebases with complex asyncpg usage\n- Performance-critical applications requiring careful conversion\n- Projects with custom database logic and optimizations\n- Organizations with strict compliance requirements\n\n### Integration Workflow\n1. Run detection phase first to identify patterns\n2. Use conversion analyzer for complex patterns\n3. Follow recommended conversion plan\n4. Use validation to ensure successful conversion\n\n### Customization\n- Can be configured with project-specific rules\n- Supports custom complexity scoring criteria\n- Integrates with existing development workflows\n- Provides API for integration with CI/CD pipelines",
        "asyncpg-to-sqlalchemy-converter/agents/schema-reflector.md": "# Schema Reflector Agent\n\nA specialized AI agent that performs comprehensive database schema reflection, analyzes existing database structures, and generates optimized SQLAlchemy model definitions with proper relationships, constraints, and performance optimizations.\n\n## Capabilities\n\n### Database Schema Analysis\n- Connects to PostgreSQL/Supabase databases and reflects complete schema\n- Analyzes tables, columns, constraints, indexes, and relationships\n- Handles complex schemas including inheritance, partitions, and extensions\n- Supports multiple schemas and custom types\n\n### Intelligent Model Generation\n- Generates SQLAlchemy models with proper type mappings and constraints\n- Creates bi-directional relationships with optimal loading strategies\n- Handles Supabase-specific features (UUIDs, JSONB, RLS policies)\n- Optimizes for performance with lazy loading and efficient querying\n\n### Schema Documentation\n- Creates comprehensive documentation of database structure\n- Documents business logic embedded in schema constraints\n- Identifies potential issues and optimization opportunities\n- Generates visual schema diagrams and relationship maps\n\n### Performance Optimization\n- Analyzes query patterns and suggests optimal indexing\n- Identifies N+1 query problems and suggests solutions\n- Recommends connection pooling configurations\n- Suggests denormalization opportunities for performance\n\n## Usage Patterns\n\n### Complete Schema Reflection\nFor generating models from existing databases:\n\n```bash\n# Reflect entire database\n/agent:schema-reflector reflect --connection-string $DATABASE_URL --output ./models/\n\n# Reflect specific schema\n/agent:schema-reflector reflect --schema public --output ./models/base.py\n\n# Reflect with Supabase optimizations\n/agent:schema-reflector reflect --supabase --rls-aware --output ./models/supabase.py\n```\n\n### Incremental Schema Updates\nFor updating existing models when schema changes:\n\n```bash\n# Update existing models\n/agent:schema-reflector update --existing-models ./models/ --connection-string $DATABASE_URL\n\n# Generate migration scripts\n/agent:schema-reflector generate-migration --from-schema ./current_schema.json --to-schema ./new_schema.json\n```\n\n### Schema Analysis and Optimization\nFor performance tuning and optimization:\n\n```bash\n# Analyze performance issues\n/agent:schema-reflector analyze-performance --connection-string $DATABASE_URL --report\n\n# Suggest optimizations\n/agent:schema-reflector optimize --connection-string $DATABASE_URL --recommendations\n\n# Generate indexing strategy\n/agent:schema-reflector indexing-strategy --query-log ./slow_queries.log\n```\n\n## Advanced Features\n\n### Multi-Schema Support\n- Handles complex databases with multiple schemas\n- Maintains schema separation in generated models\n- Supports cross-schema relationships\n- Handles schema-specific configurations and permissions\n\n### Custom Type Handling\n- Maps PostgreSQL custom types to SQLAlchemy types\n- Handles enum types and domain constraints\n- Supports array types and JSONB operations\n- Creates custom type definitions when needed\n\n### Supabase Integration\n- Handles Supabase-specific table types and extensions\n- Integrates with Supabase auth tables\n- Understands Supabase RLS policy implications\n- Optimizes for Supabase connection pooling\n\n### Performance-Aware Generation\n- Generates models optimized for common query patterns\n- Implements efficient relationship loading strategies\n- Suggests optimal indexing strategies\n- Identifies potential performance bottlenecks\n\n## Output Formats\n\n### SQLAlchemy Models\n```python\n# Generated model with relationships\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    email = Column(String(255), unique=True, nullable=False, index=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n\n    # Optimized relationships\n    profiles = relationship(\"Profile\", back_populates=\"user\", lazy=\"selectin\")\n    posts = relationship(\"Post\", back_populates=\"author\", lazy=\"dynamic\")\n```\n\n### Schema Documentation\n```markdown\n## Database Schema Documentation\n\n### Users Table\n- **Purpose**: User authentication and profile management\n- **Primary Key**: UUID (auto-generated)\n- **Indexes**: Unique index on email, created_at for sorting\n- **Relationships**: One-to-many with profiles and posts\n- **Constraints**: Email must be valid email format\n- **Business Logic**: Users can have multiple profiles for different contexts\n```\n\n### Performance Analysis Report\n```json\n{\n  \"performance_analysis\": {\n    \"query_patterns\": {\n      \"frequent_queries\": [\n        \"SELECT * FROM users WHERE email = ?\",\n        \"SELECT users.*, profiles.* FROM users JOIN profiles ON users.id = profiles.user_id\"\n      ],\n      \"recommendations\": [\n        \"Add composite index on (email, created_at)\",\n        \"Implement query result caching for user lookups\"\n      ]\n    },\n    \"bottlenecks\": [\n      {\n        \"table\": \"posts\",\n        \"issue\": \"Missing index on author_id for frequent joins\",\n        \"solution\": \"Add index on posts.author_id\"\n      }\n    ]\n  }\n}\n```\n\n### Migration Scripts\n```python\n# Alembic migration script\ndef upgrade():\n    # Add new column\n    op.add_column('users', sa.Column('last_login', sa.DateTime(timezone=True), nullable=True))\n\n    # Create index for performance\n    op.create_index('ix_users_email_created', 'users', ['email', 'created_at'], unique=False)\n\ndef downgrade():\n    op.drop_index('ix_users_email_created', table_name='users')\n    op.drop_column('users', 'last_login')\n```\n\n## Integration with Other Components\n\n### Works with Model Generation Command\n- Provides core reflection functionality for model generation\n- Handles complex schema scenarios beyond basic reflection\n- Generates optimized models with performance considerations\n\n### Supports Validation Agent\n- Provides schema validation capabilities\n- Identifies inconsistencies between models and database\n- Validates relationships and constraints\n\n### Enhances Supabase Integration\n- Understands Supabase-specific schema patterns\n- Optimizes for Supabase performance characteristics\n- Handles Supabase auth and storage integration\n\n## Advanced Configuration\n\n### Custom Type Mappings\n```python\n# Custom type mapping configuration\nTYPE_MAPPINGS = {\n    \"custom_enum\": \"sqlalchemy.Enum\",\n    \"vector\": \"pgvector.Vector\",\n    \"tsvector\": \"sqlalchemy.dialects.postgresql.TSVECTOR\"\n}\n```\n\n### Relationship Loading Strategies\n```python\n# Configure optimal loading strategies\nRELATIONSHIP_CONFIG = {\n    \"selectin\": \"small_result_sets\",\n    \"joined\": \"always_needed\",\n    \"subquery\": \"large_result_sets\",\n    \"dynamic\": \"large_collections\"\n}\n```\n\n### Performance Optimization Rules\n```python\n# Custom optimization rules\nOPTIMIZATION_RULES = {\n    \"index_foreign_keys\": True,\n    \"add_composite_indexes\": True,\n    \"optimize_date_queries\": True,\n    \"cache_frequent_lookups\": True\n}\n```\n\n## Best Practices\n\n### When to Use\n- New projects starting from existing databases\n- Migrating projects with complex schemas\n- Performance optimization of existing SQLAlchemy models\n- Documentation and analysis of legacy databases\n\n### Integration Workflow\n1. Connect to database and analyze schema structure\n2. Generate initial models with basic relationships\n3. Analyze query patterns and optimize models\n4. Create migration scripts for schema changes\n5. Validate generated models against database\n\n### Performance Considerations\n- Use lazy loading strategies appropriate to data sizes\n- Implement proper indexing based on query patterns\n- Consider connection pooling for high-traffic applications\n- Monitor performance after deployment and optimize as needed\n\n### Schema Evolution\n- Handle schema changes gracefully with migrations\n- Maintain backward compatibility when possible\n- Test migrations thoroughly before deployment\n- Document schema changes and their implications",
        "asyncpg-to-sqlalchemy-converter/commands/convert-project.md": "Convert asyncpg FastAPI project to SQLAlchemy async patterns\n\nThis command analyzes a FastAPI project, detects all asyncpg usage patterns, and systematically converts them to SQLAlchemy 2.0+ with async support while maintaining full functionality.\n\n## Usage\n\n```bash\n/convert-asyncpg-to-sqlalchemy [options]\n```\n\n## Options\n\n- `--path <directory>`: Project directory to analyze (default: current directory)\n- `--backup <directory>`: Backup location before conversion (default: ./backup_asyncpg)\n- `--supabase`: Enable Supabase-specific optimizations and integrations\n- `--models-only`: Only convert models, skip utility functions\n- `--dry-run`: Preview changes without modifying files\n- `--interactive`: Prompt for confirmation on major changes\n\n## Process\n\n### Phase 1: Detection & Analysis\n1. Scan all Python files for asyncpg imports and usage patterns\n2. Analyze connection methods, query patterns, and transaction handling\n3. Generate detailed conversion report with complexity assessment\n\n### Phase 2: Backup Creation\n1. Create complete backup of original code\n2. Generate conversion log for rollback capabilities\n3. Document all detected patterns and planned changes\n\n### Phase 3: Systematic Conversion\n1. Update imports from asyncpg to SQLAlchemy\n2. Convert connection patterns to async session management\n3. Transform query syntax (fetch ‚Üí execute, parameter binding)\n4. Update transaction handling patterns\n5. Convert error handling to SQLAlchemy exceptions\n\n### Phase 4: Validation\n1. Syntax validation of converted code\n2. Import verification and dependency checking\n3. Basic functionality testing of converted patterns\n\n### Phase 5: Documentation\n1. Generate conversion summary report\n2. Create migration guide with before/after examples\n3. Document any manual intervention requirements\n\n## Examples\n\nConvert current directory with Supabase support:\n```bash\n/convert-asyncpg-to-sqlalchemy --supabase\n```\n\nDry run to preview changes:\n```bash\n/convert-asyncpg-to-sqlalchemy --dry-run --path ./my-fastapi-app\n```\n\nInteractive conversion with custom backup:\n```bash\n/convert-asyncpg-to-sqlalchemy --path ./src --backup ./original_code --interactive\n```",
        "asyncpg-to-sqlalchemy-converter/commands/create-session.md": "Create SQLAlchemy async session management setup\n\nThis command generates complete async session management configuration for FastAPI projects, including dependency injection, connection pooling, error handling, and Supabase integration patterns.\n\n## Usage\n\n```bash\n/create-async-session [options]\n```\n\n## Options\n\n- `--output <directory>`: Output directory for session files (default: ./database)\n- `--supabase`: Include Supabase-specific configurations\n- `--pool-size <number>`: Connection pool size (default: 10)\n- `--max-overflow <number>`: Maximum overflow connections (default: 0)\n- `--testing`: Include testing configuration and fixtures\n- `--migrations`: Include Alembic migration setup\n- `--docker`: Generate Docker Compose configuration\n\n## Generated Components\n\n### Core Session Management\n- Async engine configuration with proper connection pooling\n- Async session factory setup\n- FastAPI dependency injection patterns\n- Connection lifecycle management\n\n### Database Configuration\n- Environment-based configuration management\n- Connection string handling with security\n- Pool optimization for different deployment targets\n- Serverless environment optimizations\n\n### Error Handling & Monitoring\n- Database error handling patterns\n- Connection retry logic with exponential backoff\n- Health check endpoints for database connectivity\n- Logging and monitoring setup\n\n### Testing Support\n- In-memory database configuration for testing\n- Test fixtures and utilities\n- Transaction rollback testing patterns\n- Mock session providers\n\n### Supabase Integration (optional)\n- Supabase auth integration with RLS\n- Service key management\n- Row Level Security context handling\n- Supabase-specific connection optimizations\n\n## Examples\n\nCreate basic session setup:\n```bash\n/create-async-session --output ./src/database\n```\n\nCreate Supabase-enabled session management:\n```bash\n/create-async-session --supabase --pool-size 20 --testing\n```\n\nComplete setup with migrations and Docker:\n```bash\n/create-async-session --testing --migrations --docker --supabase\n```\n\n## Generated Files\n\n### Core Files\n- `database.py` - Main database configuration and session factory\n- `dependencies.py` - FastAPI dependency injection patterns\n- `config.py` - Environment-based configuration management\n- `exceptions.py` - Custom database exception handlers\n\n### Optional Files\n- `testing.py` - Testing configuration and fixtures\n- `migrations/` - Alembic migration setup\n- `docker-compose.yml` - Database container configuration\n- `supabase_integration.py` - Supabase-specific integration patterns\n\n### Features\n- Async session management with proper cleanup\n- Connection pooling optimized for different environments\n- Error handling with retry mechanisms\n- Testing utilities with in-memory database support\n- Supabase auth and RLS integration\n- Health check endpoints and monitoring\n- Docker development environment setup\n- Comprehensive logging and debugging support",
        "asyncpg-to-sqlalchemy-converter/commands/generate-models.md": "Generate SQLAlchemy models from database schema\n\nThis command connects to your database (PostgreSQL/Supabase), reflects the schema structure, and generates complete SQLAlchemy model definitions with proper relationships, constraints, and type mappings.\n\n## Usage\n\n```bash\n/generate-sqlalchemy-models [options]\n```\n\n## Options\n\n- `--url <connection_string>`: Database connection string (or uses SUPABASE_URL env var)\n- `--schema <name>`: Schema to reflect (default: public)\n- `--output <file>`: Output file for generated models (default: models.py)\n- `--base-class <name>`: Base class for all models (default: Base)\n- `--lazy-load`: Enable lazy loading for large schemas\n- `--include-extensions`: Include table relationships from database extensions\n- `--supabase-optimize`: Optimize for Supabase-specific features (RLS, UUIDs, etc.)\n\n## Schema Reflection Features\n\n### Automatic Type Detection\n- Maps PostgreSQL types to SQLAlchemy types\n- Handles Supabase-specific types (uuid_generate_v4(), jsonb, timestamptz)\n- Detects auto-incrementing primary keys and sequences\n\n### Relationship Generation\n- Automatically detects foreign key constraints\n- Creates bi-directional relationships with proper back_populates\n- Handles many-to-many relationships through junction tables\n\n### Constraint Mapping\n- Primary key constraints (composite keys supported)\n- Unique constraints and indexes\n- Check constraints and default values\n- NOT NULL constraints and nullable columns\n\n### Supabase Integration\n- Row Level Security (RLS) policy hints\n- Supabase auth user table relationships\n- Storage bucket integration patterns\n- Webhook table handling\n\n## Examples\n\nGenerate models from Supabase:\n```bash\n/generate-sqlalchemy-models --url \"postgresql+asyncpg://user:pass@host:5432/db\" --supabase-optimize\n```\n\nGenerate for specific schema with lazy loading:\n```bash\n/generate-sqlalchemy-models --schema analytics --output analytics_models.py --lazy-load\n```\n\nReflect all schemas with extensions:\n```bash\n/generate-sqlalchemy-models --include-extensions --base-class CustomBase\n```\n\n## Output Format\n\nThe command generates:\n- SQLAlchemy model classes with proper type hints\n- Column definitions with constraints and defaults\n- Relationship definitions with cascade options\n- Import statements and base class definition\n- Optional migration script for existing code\n\n## Generated Features\n\n- Type hints for all columns and relationships\n- Proper __repr__ methods for debugging\n- Validation methods for common use cases\n- Supabase-specific optimizations\n- Lazy loading support for large schemas\n- JSON serialization methods for API responses",
        "asyncpg-to-sqlalchemy-converter/commands/validate-conversion.md": "Validate SQLAlchemy conversion and test functionality\n\nThis command validates that the asyncpg to SQLAlchemy conversion was successful by running comprehensive tests, checking syntax validity, verifying database connectivity, and ensuring all functionality works as expected.\n\n## Usage\n\n```bash\n/validate-sqlalchemy-conversion [options]\n```\n\n## Options\n\n- `--path <directory>`: Project directory to validate (default: current directory)\n- `--connection-string <url>`: Database connection for testing (required)\n- `--test-data`: Run tests with sample data\n- `--performance`: Include performance benchmarks\n- `--supabase`: Include Supabase-specific validations\n- `--detailed`: Provide detailed validation report\n- `--fix-issues`: Attempt to automatically fix detected issues\n\n## Validation Categories\n\n### Syntax & Import Validation\n- Check all Python files for syntax errors\n- Verify SQLAlchemy imports are correct\n- Validate async/await usage patterns\n- Check for proper type hints and annotations\n\n### Database Connectivity\n- Test database connection establishment\n- Verify async session creation and cleanup\n- Test connection pooling functionality\n- Validate connection string parsing\n\n### Query Functionality Tests\n- Test basic CRUD operations (Create, Read, Update, Delete)\n- Validate parameter binding and escaping\n- Test complex queries with joins and aggregations\n- Verify transaction handling and rollback scenarios\n\n### Performance Benchmarks\n- Compare query performance between original and converted code\n- Test connection pooling efficiency\n- Memory usage analysis during database operations\n- Concurrent request handling validation\n\n### Supabase Integration Tests (optional)\n- Row Level Security (RLS) functionality\n- JWT token validation with database sessions\n- Supabase auth integration testing\n- Storage integration with database operations\n\n## Validation Process\n\n### Phase 1: Static Analysis\n1. Syntax validation of all Python files\n2. Import verification and dependency checking\n3. Async pattern validation and coroutine checking\n4. Type hint verification for better IDE support\n\n### Phase 2: Database Testing\n1. Connection establishment tests\n2. Session lifecycle validation\n3. Basic CRUD operation testing\n4. Error handling and recovery testing\n\n### Phase 3: Integration Testing\n1. FastAPI endpoint testing with database operations\n2. Dependency injection validation\n3. Concurrent request handling\n4. Memory leak detection\n\n### Phase 4: Performance Analysis\n1. Query execution time comparison\n2. Connection pool efficiency testing\n3. Memory usage profiling\n4. Scalability assessment\n\n## Examples\n\nBasic validation:\n```bash\n/validate-sqlalchemy-conversion --connection-string \"postgresql+asyncpg://user:pass@host:5432/db\"\n```\n\nComprehensive validation with Supabase support:\n```bash\n/validate-sqlalchemy-conversion --supabase --performance --test-data --detailed\n```\n\nValidate specific directory with auto-fix:\n```bash\n/validate-sqlalchemy-conversion --path ./src/api --connection-string $DATABASE_URL --fix-issues\n```\n\n## Output Reports\n\n### Summary Report\n- Overall validation status (PASS/FAIL/WARNING)\n- Number of issues found and fixed\n- Performance metrics comparison\n- Recommendations for improvements\n\n### Detailed Issues Report\n- File-by-file validation results\n- Specific syntax errors and fixes applied\n- Missing imports or incorrect patterns\n- Performance bottlenecks identified\n\n### Performance Analysis\n- Query execution time comparisons\n- Connection pool efficiency metrics\n- Memory usage patterns\n- Scalability test results\n\n### Recommendations\n- Code improvement suggestions\n- Performance optimization opportunities\n- Security considerations\n- Best practice recommendations\n\n## Auto-Fix Capabilities\n\nWhen `--fix-issues` is enabled, the command can automatically:\n\n- Fix common import errors and missing dependencies\n- Correct async/await usage patterns\n- Update type hints for better IDE support\n- Fix basic syntax errors\n- Optimize connection pooling configurations\n- Update error handling patterns\n- Fix parameter binding issues\n- Correct transaction handling patterns\n\n## Exit Codes\n\n- `0`: Validation successful - all tests passed\n- `1`: Validation failed - critical issues found\n- `2`: Validation failed with warnings - non-critical issues present\n- `3`: Validation error - unable to complete validation due to environment issues",
        "asyncpg-to-sqlalchemy-converter/hooks/hooks.json": "{\n  \"PreToolUse\": [{\n    \"matcher\": \"Write|Edit\",\n    \"hooks\": [{\n      \"type\": \"command\",\n      \"command\": \"bash /Users/kevinhill/.claude/plugins/marketplaces/claude-code-plugins/plugins/plugin-dev/scripts/validate-sqlalchemy.sh\",\n      \"timeout\": 30,\n      \"description\": \"Validate SQLAlchemy code patterns and syntax\"\n    }]\n  }]\n}",
        "asyncpg-to-sqlalchemy-converter/skills/asyncpg-detection/SKILL.md": "---\nname: asyncpg-detection\ndescription: This skill should be used when the user asks to \"detect asyncpg usage\", \"find asyncpg patterns\", \"scan for asyncpg imports\", or \"identify asyncpg database code in FastAPI projects\". It automatically scans Python files to identify asyncpg imports, connection patterns, and query execution methods that need conversion to SQLAlchemy.\nversion: 1.0.0\n---\n\n# AsyncPG Detection for FastAPI Projects\n\nThis skill provides comprehensive detection of asyncpg usage patterns in FastAPI applications, identifying all code that needs to be converted to SQLAlchemy with asyncpg engine support.\n\n## Detection Overview\n\nScan FastAPI projects for asyncpg patterns including imports, connection management, queries, transactions, and error handling. Generate detailed reports with line numbers and conversion recommendations.\n\n## Core Detection Patterns\n\n### Import Detection\nLook for these import statements:\n- `import asyncpg`\n- `from asyncpg import`\n- `import asyncpg as pg`\n- `from asyncpg import Connection, Pool`\n\n### Connection Patterns\nIdentify these asyncpg connection approaches:\n- `asyncpg.connect()` calls\n- `asyncpg.create_pool()` usage\n- Manual connection string parsing\n- Environment-based connection configuration\n\n### Query Patterns\nDetect these asyncpg execution methods:\n- `connection.fetch()` for SELECT queries\n- `connection.execute()` for INSERT/UPDATE/DELETE\n- `connection.fetchval()` for single values\n- `connection.fetchrow()` for single rows\n- `connection.iter()` for result iteration\n\n## Usage Instructions\n\nTo detect asyncpg usage in your FastAPI project:\n\n1. **Run comprehensive scan**: Use the `/convert-asyncpg-to-sqlalchemy` command to scan all Python files in the project\n2. **Analyze detection results**: Review the generated report for files containing asyncpg code\n3. **Prioritize conversion**: Focus on files with the most asyncpg usage first\n4. **Check for complex patterns**: Look for nested connections, transactions, and error handling that may require special attention\n\n## Reporting Format\n\nThe detection generates reports with:\n- **File list**: All files containing asyncpg imports\n- **Pattern analysis**: Specific asyncpg methods found\n- **Complexity assessment**: Files requiring manual intervention\n- **Conversion recommendations**: Suggested SQLAlchemy equivalents\n\n## Additional Resources\n\n### Reference Files\n- **`references/patterns-mapping.md`** - Complete asyncpg to SQLAlchemy pattern mapping\n- **`references/complex-cases.md`** - Handling of complex asyncpg scenarios\n- **`references/supabase-specific.md`** - Supabase-specific asyncpg patterns\n\n### Examples\n- **`examples/detection-report.md`** - Sample detection output\n- **`examples/fastapi-project-structure.md`** - Example FastAPI project with asyncpg usage",
        "asyncpg-to-sqlalchemy-converter/skills/sqlalchemy-conversion/SKILL.md": "---\nname: sqlalchemy-conversion\ndescription: This skill should be used when the user asks to \"convert asyncpg to SQLAlchemy\", \"convert database queries\", \"migrate asyncpg code\", \"transform asyncpg patterns to SQLAlchemy\", or \"update FastAPI database layer\". It provides systematic conversion of asyncpg code to SQLAlchemy async patterns with proper error handling and transaction management.\nversion: 1.0.0\n---\n\n# SQLAlchemy Conversion for AsyncPG Migration\n\nThis skill provides systematic conversion of asyncpg database code to SQLAlchemy 2.0+ with async support, maintaining async performance while providing ORM benefits.\n\n## Conversion Strategy\n\nConvert asyncpg procedural code to SQLAlchemy declarative patterns while preserving async functionality and improving maintainability.\n\n## Core Conversion Patterns\n\n### Import Replacement\nReplace asyncpg imports with SQLAlchemy:\n- `import asyncpg` ‚Üí `from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine`\n- `from asyncpg import Connection` ‚Üí `from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker`\n\n### Engine Configuration\nConvert connection setup:\n```python\n# Before (asyncpg)\nengine = await asyncpg.create_pool(dsn)\n\n# After (SQLAlchemy)\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,\n    poolclass=NullPool  # For asyncpg compatibility\n)\n```\n\n### Session Management\nReplace connection objects with async sessions:\n```python\n# Before (asyncpg)\nasync def get_user(db, user_id):\n    async with db.acquire() as conn:\n        result = await conn.fetchrow(\"SELECT * FROM users WHERE id = $1\", user_id)\n        return dict(result)\n\n# After (SQLAlchemy)\nasync def get_user(session: AsyncSession, user_id: int):\n    result = await session.execute(\n        select(User).where(User.id == user_id)\n    )\n    return result.scalar_one()\n```\n\n## Query Conversion Guidelines\n\n### SELECT Queries\nTransform fetch operations to SQLAlchemy Core/ORM:\n- `fetchall()` ‚Üí `execute().scalars().all()`\n- `fetchrow()` ‚Üí `execute().scalar_one()` or `execute().first()`\n- `fetchval()` ‚Üí `execute().scalar()`\n- `iter()` ‚Üí `execute().yield_per()`\n\n### INSERT Operations\nConvert execute patterns:\n```python\n# Before (asyncpg)\nawait conn.execute(\n    \"INSERT INTO users (name, email) VALUES ($1, $2)\",\n    name, email\n)\n\n# After (SQLAlchemy ORM)\nsession.add(User(name=name, email=email))\nawait session.commit()\n```\n\n### Transaction Handling\nUpdate transaction patterns:\n```python\n# Before (asyncpg)\nasync with conn.transaction():\n    await conn.execute(\"UPDATE users SET status = $1\", status)\n\n# After (SQLAlchemy)\nasync with session.begin():\n    await session.execute(\n        update(User).where(User.id == user_id).values(status=status)\n    )\n```\n\n## Usage Instructions\n\nTo convert asyncpg code:\n\n1. **Analyze detected patterns**: Use detection results to understand current codebase structure\n2. **Apply systematic conversion**: Follow the pattern mapping for each identified asyncpg usage\n3. **Handle edge cases**: Refer to complex cases documentation for advanced scenarios\n4. **Validate conversions**: Test converted code to ensure functionality is preserved\n\n## Error Handling Conversion\n\n### Exception Types\nUpdate exception handling:\n- `asyncpg.PostgresError` ‚Üí `sqlalchemy.exc.DBAPIError`\n- `asyncpg.InterfaceError` ‚Üí `sqlalchemy.exc.InterfaceError`\n- `asyncpg.exceptions` ‚Üí Use SQLAlchemy's built-in exceptions\n\n### Connection Errors\nImplement robust error handling:\n```python\n# Before\ntry:\n    conn = await asyncpg.connect(dsn)\nexcept asyncpg.PostgresError as e:\n    logger.error(f\"Database connection failed: {e}\")\n\n# After\ntry:\n    engine = create_async_engine(DATABASE_URL)\n    async with engine.begin() as conn:\n        pass\nexcept SQLAlchemyError as e:\n    logger.error(f\"Database setup failed: {e}\")\n```\n\n## Additional Resources\n\n### Reference Files\n- **`references/pattern-mapping.md`** - Comprehensive asyncpg to SQLAlchemy conversion mapping\n- **`references/async-patterns.md`** - Async SQLAlchemy best practices\n- **`references/error-handling.md`** - SQLAlchemy exception handling patterns\n\n### Examples\n- **`examples/conversion-comparison.md`** - Side-by-side asyncpg vs SQLAlchemy examples\n- **`examples/migration-scripts.py`** - Automated conversion utilities\n- **`examples/test-validation.py`** - Testing converted code patterns",
        "asyncpg-to-sqlalchemy-converter/skills/supabase-integration/SKILL.md": "---\nname: supabase-integration\ndescription: This skill should be used when the user asks to \"configure Supabase with SQLAlchemy\", \"set up Supabase async engine\", \"create Supabase models\", \"handle Supabase authentication with SQLAlchemy\", or \"integrate Supabase pooling with SQLAlchemy async patterns\". It provides complete Supabase integration patterns for SQLAlchemy with async support, authentication, and connection pooling optimizations.\nversion: 1.0.0\n---\n\n# Supabase Integration for SQLAlchemy Async Projects\n\nThis skill provides comprehensive integration patterns for using SQLAlchemy with Supabase, including async engine configuration, authentication setup, connection pooling, and performance optimizations.\n\n## Integration Overview\n\nConfigure SQLAlchemy to work seamlessly with Supabase PostgreSQL databases while maintaining async performance, proper authentication, and connection management optimizations for serverless environments.\n\n## Supabase Engine Configuration\n\n### Async Engine Setup\nConfigure SQLAlchemy async engine for Supabase:\n```python\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nimport os\n\n# Supabase connection string\nSUPABASE_URL = f\"postgresql+asyncpg://postgres.{SUPABASE_PROJECT_ID}:{SUPABASE_PASSWORD}@aws-0-{SUPABASE_REGION}.pooler.supabase.com:6543/postgres\"\n\n# Async engine optimized for Supabase\nengine = create_async_engine(\n    SUPABASE_URL,\n    echo=True,\n    pool_size=20,\n    max_overflow=0,\n    pool_pre_ping=True,\n    pool_recycle=300,\n    connect_args={\n        \"server_settings\": {\n            \"application_name\": \"fastapi_supabase_app\",\n            \"search_path\": \"public, extensions\"\n        }\n    }\n)\n\n# Async session factory\nAsyncSessionFactory = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n```\n\n### Environment-Based Configuration\nSet up flexible configuration for different environments:\n```python\n# config/database.py\nfrom pydantic_settings import BaseSettings\nfrom typing import Optional\n\nclass DatabaseSettings(BaseSettings):\n    supabase_url: str\n    supabase_key: str\n    supabase_service_key: Optional[str] = None\n    pool_size: int = 10\n    max_overflow: int = 0\n\n    class Config:\n        env_prefix = \"DB_\"\n        case_sensitive = False\n\n    @property\n    def async_url(self) -> str:\n        return self.supabase_url.replace(\"postgresql://\", \"postgresql+asyncpg://\")\n\n# Dependency injection for FastAPI\nasync def get_db_session() -> AsyncSession:\n    async with AsyncSessionFactory() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\n## Authentication Integration\n\n### Row Level Security (RLS) Integration\nHandle Supabase RLS with SQLAlchemy:\n```python\nfrom fastapi import Request, HTTPException\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\n\nsecurity = HTTPBearer()\n\nasync def get_supabase_user(request: Request) -> dict:\n    \"\"\"Extract and validate Supabase JWT token\"\"\"\n    authorization = request.headers.get(\"Authorization\")\n    if not authorization or not authorization.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Missing or invalid token\")\n\n    token = authorization.split(\" \")[1]\n    try:\n        # Decode Supabase JWT\n        payload = jwt.decode(\n            token,\n            SUPABASE_JWT_SECRET,\n            algorithms=[\"HS256\"],\n            options={\"verify_aud\": False}\n        )\n        return payload\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Token expired\")\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\nasync def get_db_with_auth(request: Request) -> AsyncSession:\n    \"\"\"Get database session with RLS context\"\"\"\n    session = AsyncSessionFactory()\n\n    # Set RLS user context\n    user = await get_supabase_user(request)\n    await session.execute(\n        text(\"SET request.jwt.claims.user_id = :user_id\"),\n        {\"user_id\": user.get(\"sub\")}\n    )\n\n    await session.execute(\n        text(\"SET request.jwt.claims.role = :role\"),\n        {\"role\": user.get(\"role\", \"authenticated\")}\n    )\n\n    return session\n```\n\n### Service Key Integration\nUse Supabase service key for admin operations:\n```python\nfrom supabase import create_client, Client\n\nclass SupabaseAdminClient:\n    def __init__(self, supabase_url: str, service_key: str):\n        self.supabase: Client = create_client(supabase_url, service_key)\n\n    async def upload_file(self, bucket: str, path: str, file_content: bytes) -> dict:\n        \"\"\"Upload file to Supabase Storage\"\"\"\n        return self.supabase.storage.from_(bucket).upload(path, file_content)\n\n    async def sign_url(self, bucket: str, path: str, expires_in: int = 3600) -> str:\n        \"\"\"Generate signed URL for file access\"\"\"\n        return self.supabase.storage.from_(bucket).create_signed_url(path, expires_in)\n\n# FastAPI dependency\nasync def get_supabase_admin() -> SupabaseAdminClient:\n    return SupabaseAdminClient(SUPABASE_URL, SUPABASE_SERVICE_KEY)\n```\n\n## Performance Optimization\n\n### Connection Pooling for Serverless\nOptimize for Supabase connection limits:\n```python\n# config/pooling.py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.pool import QueuePool\nimport asyncio\n\nclass SupabaseEngineManager:\n    def __init__(self, supabase_url: str, max_connections: int = 20):\n        self.engine = create_async_engine(\n            supabase_url,\n            poolclass=QueuePool,\n            pool_size=max_connections - 5,  # Leave room for admin connections\n            max_overflow=5,\n            pool_pre_ping=True,\n            pool_recycle=300,  # 5 minutes\n            pool_timeout=30,\n            connect_args={\n                \"command_timeout\": 10,\n                \"server_settings\": {\n                    \"application_name\": \"fastapi_supabase_app\",\n                    \"jit\": \"off\"  # Disable JIT for serverless\n                }\n            }\n        )\n        self._background_heartbeater = None\n\n    async def start_heartbeat(self):\n        \"\"\"Keep connections alive in serverless environments\"\"\"\n        async def heartbeat():\n            while True:\n                await asyncio.sleep(240)  # 4 minutes\n                async with self.engine.connect() as conn:\n                    await conn.execute(text(\"SELECT 1\"))\n\n        self._background_heartbeater = asyncio.create_task(heartbeat())\n\n    async def stop_heartbeat(self):\n        if self._background_heartbeater:\n            self._background_heartbeater.cancel()\n            try:\n                await self._background_heartbeater\n            except asyncio.CancelledError:\n                pass\n```\n\n### Lazy Loading Implementation\nImplement efficient lazy loading for large schemas:\n```python\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, text\nfrom typing import Type, TypeVar, Generic\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\nclass LazyLoader(Generic[T]):\n    def __init__(self, model: Type[T], session: AsyncSession):\n        self.model = model\n        self.session = session\n        self._loaded = None\n        self._query = None\n\n    def where(self, *criteria):\n        \"\"\"Add where conditions to query\"\"\"\n        self._query = select(self.model).where(*criteria)\n        return self\n\n    async def load(self) -> list[T]:\n        \"\"\"Execute the query and cache results\"\"\"\n        if self._loaded is None:\n            if self._query is None:\n                self._query = select(self.model)\n            result = await self.session.execute(self._query)\n            self._loaded = result.scalars().all()\n        return self._loaded\n\n    async def first(self) -> T | None:\n        \"\"\"Load first result only\"\"\"\n        if self._query is None:\n            self._query = select(self.model)\n        result = await self.session.execute(self._query.limit(1))\n        return result.scalar_one_or_none()\n\n# Usage in FastAPI endpoints\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, session: AsyncSession = Depends(get_db_session)):\n    lazy_users = LazyLoader(User, session)\n    user = await lazy_users.where(User.id == user_id).first()\n\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    return user\n```\n\n## Model Generation\n\n### Supabase Schema Reflection\nGenerate SQLAlchemy models from Supabase schema:\n```python\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy import inspect, text\nfrom sqlalchemy.orm import DeclarativeBase\nfrom typing import Dict, List\n\nasync def reflect_supabase_schema(engine: AsyncEngine, schema: str = \"public\") -> Dict[str, dict]:\n    \"\"\"Reflect Supabase database schema\"\"\"\n    async with engine.connect() as conn:\n        # Get table information\n        tables_query = text(\"\"\"\n            SELECT table_name, column_name, data_type, is_nullable, column_default\n            FROM information_schema.columns\n            WHERE table_schema = :schema\n            ORDER BY table_name, ordinal_position\n        \"\"\")\n\n        result = await conn.execute(tables_query, {\"schema\": schema})\n        columns = result.fetchall()\n\n        # Get foreign key constraints\n        fk_query = text(\"\"\"\n            SELECT\n                tc.table_name,\n                kcu.column_name,\n                ccu.table_name AS foreign_table_name,\n                ccu.column_name AS foreign_column_name\n            FROM information_schema.table_constraints tc\n            JOIN information_schema.key_column_usage kcu\n                ON tc.constraint_name = kcu.constraint_name\n            JOIN information_schema.constraint_column_usage ccu\n                ON ccu.constraint_name = tc.constraint_name\n            WHERE tc.constraint_type = 'FOREIGN KEY'\n                AND tc.table_schema = :schema\n        \"\"\")\n\n        fk_result = await conn.execute(fk_query, {\"schema\": schema})\n        foreign_keys = fk_result.fetchall()\n\n        # Process and return schema information\n        schema_info = {}\n        for table_name, column_name, data_type, is_nullable, column_default in columns:\n            if table_name not in schema_info:\n                schema_info[table_name] = {\n                    \"columns\": {},\n                    \"foreign_keys\": []\n                }\n\n            schema_info[table_name][\"columns\"][column_name] = {\n                \"type\": data_type,\n                \"nullable\": is_nullable == \"YES\",\n                \"default\": column_default\n            }\n\n        # Add foreign key information\n        for table_name, column_name, fk_table, fk_column in foreign_keys:\n            schema_info[table_name][\"foreign_keys\"].append({\n                \"column\": column_name,\n                \"references\": f\"{fk_table}.{fk_column}\"\n            })\n\n        return schema_info\n\n# Model generation\nasync def generate_sqlalchemy_models(schema_info: Dict[str, dict], base_class: DeclarativeBase) -> str:\n    \"\"\"Generate SQLAlchemy model classes from schema info\"\"\"\n    model_code = []\n\n    for table_name, table_info in schema_info.items():\n        class_name = \"\".join(word.capitalize() for word in table_name.split(\"_\"))\n\n        # Column definitions\n        columns = []\n        primary_key_columns = []\n\n        for column_name, column_info in table_info[\"columns\"]..items():\n            col_def = _generate_column_definition(column_name, column_info)\n            columns.append(col_def)\n\n            # Detect primary keys (common patterns in Supabase)\n            if column_name in [\"id\", f\"{table_name}_id\"] or column_info.get(\"default\", \"\").startswith(\"nextval\"):\n                primary_key_columns.append(column_name)\n\n        # Foreign key relationships\n        relationships = []\n        for fk in table_info[\"foreign_keys\"]:\n            fk_table, fk_column = fk[\"references\"].split(\".\")\n            fk_class_name = \"\".join(word.capitalize() for word in fk_table.split(\"_\"))\n            relationship_name = fk_table if fk_table.endswith(\"s\") else f\"{fk_table}s\"\n\n            if column_name.endswith(\"_id\"):\n                relationship_name = column_name[:-3] + (\"s\" if not column_name[:-3].endswith(\"s\") else \"\")\n\n            relationships.append(\n                f'    {relationship_name} = relationship(\"{fk_class_name}\", back_populates=\"{table_name}\")'\n            )\n\n        # Generate the complete class\n        model_class = f\"\"\"\nclass {class_name}({base_class.__name__}):\n    __tablename__ = \"{table_name}\"\n\n{chr(10).join(columns)}\n\"\"\"\n\n        if primary_key_columns:\n            pk_declaration = f\"    __table_args__ = (PrimaryKeyConstraint({', '.join(map(lambda c: f'\\\"{c}\\\"', primary_key_columns))}),)\"\n            model_class += pk_declaration + \"\\n\"\n\n        if relationships:\n            model_class += \"\\n\" + \"\\n\".join(relationships) + \"\\n\"\n\n        model_code.append(model_class)\n\n    return \"\\n\".join(model_code)\n\ndef _generate_column_definition(name: str, info: dict) -> str:\n    \"\"\"Generate SQLAlchemy column definition\"\"\"\n    type_mapping = {\n        \"text\": \"Text\",\n        \"varchar\": \"String\",\n        \"character varying\": \"String\",\n        \"integer\": \"Integer\",\n        \"bigint\": \"BigInteger\",\n        \"decimal\": \"Numeric\",\n        \"numeric\": \"Numeric\",\n        \"real\": \"Float\",\n        \"double precision\": \"Float\",\n        \"boolean\": \"Boolean\",\n        \"date\": \"Date\",\n        \"timestamp\": \"DateTime\",\n        \"timestamp with time zone\": \"DateTime(timezone=True)\",\n        \"uuid\": \"UUID\",\n        \"jsonb\": \"JSON\",\n        \"json\": \"JSON\"\n    }\n\n    sql_type = type_mapping.get(info[\"type\"].lower(), \"String\")\n\n    nullable_str = \"\" if info[\"nullable\"] else \", nullable=False\"\n    default_str = \"\"\n\n    if info[\"default\"]:\n        if info[\"default\"].startswith(\"nextval\"):\n            default_str = \", autoincrement=True\"\n        elif \"uuid_generate\" in info[\"default\"]:\n            default_str = \", server_default=text('uuid_generate_v4()')\"\n        elif \"now()\" in info[\"default\"]:\n            default_str = \", server_default=text('now()')\"\n\n    return f'    {name} = Column({sql_type}{nullable_str}{default_str})'\n```\n\n## Usage Instructions\n\nTo integrate Supabase with SQLAlchemy:\n\n1. **Configure async engine**: Set up SQLAlchemy async engine with Supabase connection string\n2. **Implement authentication**: Handle JWT tokens and RLS policies\n3. **Optimize connection pooling**: Configure for serverless environments\n4. **Generate models**: Use schema reflection to create SQLAlchemy models\n5. **Test integration**: Validate queries and authentication work correctly\n\n## Error Handling\n\n### Supabase-Specific Errors\nHandle Supabase-specific error scenarios:\n```python\nfrom sqlalchemy.exc import SQLAlchemyError, OperationalError, InterfaceError\n\nasync def handle_supabase_errors(func):\n    \"\"\"Decorator for handling Supabase-specific errors\"\"\"\n    async def wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)\n        except OperationalError as e:\n            if \"connection\" in str(e).lower():\n                # Retry connection errors\n                await asyncio.sleep(1)\n                return await func(*args, **kwargs)\n            raise\n        except SQLAlchemyError as e:\n            logger.error(f\"Supabase database error: {e}\")\n            raise\n    return wrapper\n```\n\n## Additional Resources\n\n### Reference Files\n- **`references/supabase-connection.md`** - Supabase connection configuration patterns\n- **`references/rls-integration.md`** - Row Level Security with SQLAlchemy\n- **`references/performance-optimization.md`** - Performance tuning for Supabase\n\n### Examples\n- **`examples/supabase-fastapi-setup.py`** - Complete FastAPI + Supabase + SQLAlchemy setup\n- **`examples/async-patterns.py`** - Async patterns for Supabase integration\n- **`examples/schema-generation.py`** - Automated model generation from Supabase schema"
      },
      "plugins": [
        {
          "name": "asyncpg-to-sqlalchemy-converter",
          "version": "1.0.0",
          "source": "./asyncpg-to-sqlalchemy-converter",
          "description": "Convert asyncpg code in FastAPI projects to SQLAlchemy 2.0+ with async support, optimized for Supabase integration",
          "author": "Kevin Hill",
          "license": "MIT",
          "keywords": [
            "asyncpg",
            "sqlalchemy",
            "fastapi",
            "database",
            "migration",
            "supabase",
            "conversion"
          ],
          "capabilities": [
            "skills",
            "commands",
            "agents",
            "hooks"
          ],
          "category": "database",
          "dependencies": [],
          "repository": "https://github.com/kivo360/claude-toolbelt/tree/main/plugins/asyncpg-to-sqlalchemy-converter",
          "homepage": "https://github.com/kivo360/claude-toolbelt#asyncpg-to-sqlalchemy-converter",
          "docs": "https://github.com/kivo360/claude-toolbelt/blob/main/plugins/asyncpg-to-sqlalchemy-converter/README.md",
          "categories": [
            "asyncpg",
            "conversion",
            "database",
            "fastapi",
            "migration",
            "sqlalchemy",
            "supabase"
          ],
          "install_commands": [
            "/plugin marketplace add kivo360/claude-toolbelt",
            "/plugin install asyncpg-to-sqlalchemy-converter@claude-toolbelt"
          ]
        }
      ]
    }
  ]
}