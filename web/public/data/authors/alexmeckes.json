{
  "author": {
    "id": "alexmeckes",
    "display_name": "Alex Meckes",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/1197736?v=4",
    "url": "https://github.com/alexmeckes",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 4,
      "total_stars": 2,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "godot-claude-skills",
      "version": null,
      "description": "Claude Code skills for Godot 4.x game development",
      "owner_info": {
        "name": "Alex Meckes",
        "email": ""
      },
      "keywords": [],
      "repo_full_name": "alexmeckes/godot-claude-skills",
      "repo_url": "https://github.com/alexmeckes/godot-claude-skills",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-01-17T15:20:49Z",
        "created_at": "2026-01-17T15:11:12Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 396
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 530
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2441
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/godot-code-gen",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/godot-code-gen/SKILL.md",
          "type": "blob",
          "size": 7691
        },
        {
          "path": "skills/godot-live-edit",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/godot-live-edit/SKILL.md",
          "type": "blob",
          "size": 5197
        },
        {
          "path": "skills/godot-scene-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/godot-scene-design/SKILL.md",
          "type": "blob",
          "size": 8710
        },
        {
          "path": "skills/godot-shader",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/godot-shader/SKILL.md",
          "type": "blob",
          "size": 10752
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"godot-claude-skills\",\n  \"description\": \"Claude Code skills for Godot 4.x game development\",\n  \"owner\": {\n    \"name\": \"Alex Meckes\",\n    \"email\": \"\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"godot-claude-skills\",\n      \"source\": \"./\",\n      \"description\": \"GDScript patterns, live editor control, scene design, and shader authoring for Godot 4.x\",\n      \"version\": \"1.0.0\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"godot-claude-skills\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude Code skills for Godot 4.x game development - GDScript patterns, live editor control, scene design, and shaders\",\n  \"author\": {\n    \"name\": \"Your Name\",\n    \"email\": \"your@email.com\"\n  },\n  \"repository\": \"https://github.com/alexmeckes/godot-claude-skills\",\n  \"homepage\": \"https://github.com/alexmeckes/godot-claude-skills\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"godot\", \"gamedev\", \"gdscript\", \"game-development\", \"shaders\"],\n  \"skills\": \"./skills/\"\n}\n",
        "README.md": "# Godot Claude Skills\n\nA Claude Code plugin for Godot 4.x game development. Provides specialized skills that enhance Claude's ability to work with Godot projects.\n\n> **ðŸŽ® Best used with [godot-mcp](https://github.com/alexmeckes/godot-mcp)**\n>\n> This plugin provides the *knowledge* (best practices, patterns, workflows), while **godot-mcp** provides the *tools* (reading/writing scenes, scripts, shaders, and live editor control). Install both for the full Godot + Claude experience.\n\n## Skills Included\n\n| Skill | Description |\n|-------|-------------|\n| `godot-code-gen` | GDScript best practices, type hints, signals, state machines |\n| `godot-live-edit` | Real-time Godot editor control via AI Bridge plugin |\n| `godot-scene-design` | Scene files (.tscn), node hierarchies, level layouts |\n| `godot-shader` | Shader authoring for 2D/3D effects and post-processing |\n\n## Installation\n\n### From GitHub (Recommended)\n\n```bash\n# Add the plugin marketplace\n/plugin marketplace add alexmeckes/godot-claude-skills\n\n# Install the plugin\n/plugin install godot-claude-skills\n```\n\n### Local Development\n\n```bash\n# Clone the repository\ngit clone https://github.com/alexmeckes/godot-claude-skills.git\n\n# Test locally with Claude Code\nclaude --plugin-dir ./godot-claude-skills\n```\n\n## Usage\n\nOnce installed, Claude will automatically use these skills when working on Godot projects. The skills provide context for:\n\n- **GDScript patterns** - Type hints, signals, state machines, async/await, tweens\n- **Live editing** - Control the Godot editor in real-time via the AI Bridge plugin\n- **Scene design** - Best practices for .tscn files, node hierarchies, collision layers\n- **Shaders** - 2D/3D shader patterns, uniforms, post-processing effects\n\n## Requirements\n\n- [Claude Code](https://claude.ai/code) with plugin support\n- [Godot 4.x](https://godotengine.org/)\n- **[godot-mcp](https://github.com/alexmeckes/godot-mcp)** - MCP server that gives Claude the ability to read/write Godot files and control the editor (highly recommended)\n\n## Plugin Structure\n\n```\ngodot-claude-skills/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json       # Plugin manifest\nâ”œâ”€â”€ skills/\nâ”‚   â”œâ”€â”€ godot-code-gen/   # GDScript best practices\nâ”‚   â”œâ”€â”€ godot-live-edit/  # Real-time editor control\nâ”‚   â”œâ”€â”€ godot-scene-design/ # Scene file patterns\nâ”‚   â””â”€â”€ godot-shader/     # Shader authoring\nâ””â”€â”€ README.md\n```\n\n## License\n\nMIT\n",
        "skills/godot-code-gen/SKILL.md": "# Godot Code Generation Skill\n\nYou are an expert Godot 4.x game developer. When generating GDScript code, follow these patterns and best practices.\n\n## GDScript 4.x Syntax\n\n### Type Hints (Always Use)\n```gdscript\nvar speed: float = 200.0\nvar health: int = 100\nvar player_name: String = \"Player\"\nvar items: Array[String] = []\nvar stats: Dictionary = {}\n\nfunc calculate_damage(base: int, multiplier: float) -> int:\n    return int(base * multiplier)\n```\n\n### Annotations\n```gdscript\n@export var speed: float = 200.0           # Visible in inspector\n@export_range(0, 100) var health: int = 50 # With range slider\n@export_enum(\"Easy\", \"Medium\", \"Hard\") var difficulty: int = 1\n@export_file(\"*.tscn\") var scene_path: String\n@export_node_path(\"Sprite2D\") var sprite_path: NodePath\n\n@onready var sprite: Sprite2D = $Sprite2D  # Initialized when ready\n@onready var collision: CollisionShape2D = $CollisionShape2D\n\n@tool  # Runs in editor\nclass_name MyClass  # Global class registration\n```\n\n### Signals (Godot 4.x Style)\n```gdscript\n# Declaration\nsignal health_changed(new_health: int)\nsignal died\nsignal item_collected(item_name: String, count: int)\n\n# Emission\nhealth_changed.emit(current_health)\ndied.emit()\n\n# Connection (prefer callable syntax)\nbutton.pressed.connect(_on_button_pressed)\nplayer.health_changed.connect(_on_player_health_changed)\n\n# With binds\ntimer.timeout.connect(_on_timeout.bind(extra_arg))\n\n# One-shot connection\nsignal_name.connect(callable, CONNECT_ONE_SHOT)\n```\n\n### Common Node Patterns\n\n#### CharacterBody2D Movement\n```gdscript\nextends CharacterBody2D\n\n@export var speed: float = 200.0\n@export var jump_force: float = 400.0\n\nvar gravity: float = ProjectSettings.get_setting(\"physics/2d/default_gravity\")\n\nfunc _physics_process(delta: float) -> void:\n    # Gravity\n    if not is_on_floor():\n        velocity.y += gravity * delta\n\n    # Jump\n    if Input.is_action_just_pressed(\"jump\") and is_on_floor():\n        velocity.y = -jump_force\n\n    # Horizontal movement\n    var direction := Input.get_axis(\"move_left\", \"move_right\")\n    velocity.x = direction * speed\n\n    move_and_slide()\n```\n\n#### CharacterBody3D Movement\n```gdscript\nextends CharacterBody3D\n\n@export var speed: float = 5.0\n@export var jump_velocity: float = 4.5\n\nvar gravity: float = ProjectSettings.get_setting(\"physics/3d/default_gravity\")\n\nfunc _physics_process(delta: float) -> void:\n    if not is_on_floor():\n        velocity.y -= gravity * delta\n\n    if Input.is_action_just_pressed(\"jump\") and is_on_floor():\n        velocity.y = jump_velocity\n\n    var input_dir := Input.get_vector(\"move_left\", \"move_right\", \"move_forward\", \"move_back\")\n    var direction := (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()\n\n    if direction:\n        velocity.x = direction.x * speed\n        velocity.z = direction.z * speed\n    else:\n        velocity.x = move_toward(velocity.x, 0, speed)\n        velocity.z = move_toward(velocity.z, 0, speed)\n\n    move_and_slide()\n```\n\n#### State Machine\n```gdscript\nextends Node\n\nenum State { IDLE, WALK, RUN, JUMP, FALL }\n\nvar current_state: State = State.IDLE\n\nfunc _physics_process(delta: float) -> void:\n    match current_state:\n        State.IDLE:\n            _process_idle(delta)\n        State.WALK:\n            _process_walk(delta)\n        State.JUMP:\n            _process_jump(delta)\n\nfunc change_state(new_state: State) -> void:\n    if new_state == current_state:\n        return\n\n    _exit_state(current_state)\n    current_state = new_state\n    _enter_state(new_state)\n\nfunc _enter_state(state: State) -> void:\n    match state:\n        State.IDLE:\n            animation_player.play(\"idle\")\n        State.WALK:\n            animation_player.play(\"walk\")\n\nfunc _exit_state(state: State) -> void:\n    pass\n```\n\n#### Resource Pattern\n```gdscript\n# item_data.gd\nclass_name ItemData\nextends Resource\n\n@export var name: String\n@export var description: String\n@export var icon: Texture2D\n@export var value: int\n@export var stackable: bool = true\n@export var max_stack: int = 99\n\n# Using resources\nvar sword: ItemData = preload(\"res://items/sword.tres\")\nprint(sword.name)\n```\n\n#### Autoload/Singleton\n```gdscript\n# game_manager.gd - Add to Project Settings > Autoload\nextends Node\n\nsignal game_paused\nsignal game_resumed\n\nvar score: int = 0\nvar is_paused: bool = false\n\nfunc pause() -> void:\n    is_paused = true\n    get_tree().paused = true\n    game_paused.emit()\n\nfunc resume() -> void:\n    is_paused = false\n    get_tree().paused = false\n    game_resumed.emit()\n\nfunc add_score(points: int) -> void:\n    score += points\n```\n\n### Async/Await (Replaces Yield)\n```gdscript\n# Wait for signal\nawait get_tree().create_timer(1.0).timeout\n\n# Wait for animation\nawait animation_player.animation_finished\n\n# Custom async function\nfunc load_level_async(path: String) -> void:\n    var loader := ResourceLoader.load_threaded_request(path)\n    while ResourceLoader.load_threaded_get_status(path) == ResourceLoader.THREAD_LOAD_IN_PROGRESS:\n        await get_tree().process_frame\n    var scene := ResourceLoader.load_threaded_get(path)\n    get_tree().change_scene_to_packed(scene)\n```\n\n### Tweens (Godot 4.x)\n```gdscript\n# Simple tween\nvar tween := create_tween()\ntween.tween_property(sprite, \"modulate:a\", 0.0, 1.0)\n\n# Chained tweens\nvar tween := create_tween()\ntween.tween_property(node, \"position\", Vector2(100, 100), 0.5)\ntween.tween_property(node, \"scale\", Vector2(2, 2), 0.3)\ntween.tween_callback(func(): print(\"Done!\"))\n\n# Parallel tweens\nvar tween := create_tween()\ntween.set_parallel(true)\ntween.tween_property(node, \"position:x\", 100, 0.5)\ntween.tween_property(node, \"rotation\", PI, 0.5)\n\n# Easing and transitions\ntween.set_trans(Tween.TRANS_BOUNCE)\ntween.set_ease(Tween.EASE_OUT)\n```\n\n### Scene Instantiation\n```gdscript\n# Preload (compile-time, preferred for frequently used scenes)\nconst EnemyScene := preload(\"res://scenes/enemy.tscn\")\nvar enemy := EnemyScene.instantiate()\nadd_child(enemy)\n\n# Load (runtime, for dynamic loading)\nvar scene := load(\"res://scenes/enemy.tscn\")\nvar enemy := scene.instantiate()\n\n# With type hints\nvar enemy: Enemy = EnemyScene.instantiate() as Enemy\n```\n\n### Input Handling\n```gdscript\nfunc _input(event: InputEvent) -> void:\n    if event.is_action_pressed(\"attack\"):\n        attack()\n\n    if event is InputEventMouseButton:\n        if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:\n            shoot()\n\nfunc _unhandled_input(event: InputEvent) -> void:\n    # Only receives events not handled by UI\n    if event.is_action_pressed(\"pause\"):\n        toggle_pause()\n\n# Polling in _process/_physics_process\nvar direction := Input.get_vector(\"left\", \"right\", \"up\", \"down\")\nvar is_jumping := Input.is_action_just_pressed(\"jump\")\nvar is_attacking := Input.is_action_pressed(\"attack\")\n```\n\n## Best Practices\n\n1. **Always use type hints** - Improves performance and catches errors early\n2. **Use @onready for node references** - Ensures nodes exist when accessed\n3. **Prefer signals over direct method calls** - Loose coupling\n4. **Use Resources for data** - Reusable, inspector-editable data containers\n5. **Group related functionality** - Use composition over inheritance\n6. **Name private variables with underscore** - `_health` not `health`\n7. **Use PascalCase for classes, snake_case for functions/variables**\n8. **Document with ## comments** - Creates in-editor documentation\n\n## Common Gotchas\n\n- `yield` is gone, use `await`\n- `connect(\"signal\", self, \"method\")` is gone, use `signal.connect(callable)`\n- `instance()` is now `instantiate()`\n- Physics layers start at 1, not 0\n- `export` keyword is now `@export` annotation\n- `onready` keyword is now `@onready` annotation\n- `tool` keyword is now `@tool` annotation\n",
        "skills/godot-live-edit/SKILL.md": "# Godot Live Edit Skill\n\nYou are an expert at using the Godot AI Bridge to control a running Godot editor in real-time. This skill guides you through live editing workflows.\n\n## Connection Workflow\n\n### Step 1: Connect to Godot\n```\nFirst, ensure:\n1. Godot 4.x is running with your project open\n2. The godot-ai-bridge plugin is installed and enabled\n3. The plugin shows \"AI Bridge listening on port 6550\" in output\n\nThen use: godot_connect\n```\n\n### Step 2: Verify Connection\n```\nUse: godot_connection_status\n\nExpected response:\n{\n  \"connected\": true,\n  \"port\": 6550,\n  \"projectPath\": \"/path/to/project\"\n}\n```\n\n### Step 3: Explore the Scene\n```\nUse: godot_editor_get_scene_tree\n\nThis shows all nodes in the current scene with their types and hierarchy.\n```\n\n## Common Live Edit Operations\n\n### Adding UI Elements\n```\nTo add a health bar:\n\n1. godot_editor_add_node\n   - parent: \"HUD\" (or \".\")\n   - name: \"HealthBar\"\n   - type: \"ProgressBar\"\n   - properties: { \"value\": 100, \"max_value\": 100 }\n\n2. godot_editor_modify_node\n   - nodePath: \"HUD/HealthBar\"\n   - properties: {\n       \"position\": {\"_type\": \"Vector2\", \"x\": 20, \"y\": 20},\n       \"size\": {\"_type\": \"Vector2\", \"x\": 200, \"y\": 30}\n     }\n```\n\n### Modifying Node Properties\n```\nTo reposition a player:\n\ngodot_editor_modify_node\n- nodePath: \"Player\"\n- properties: {\n    \"position\": {\"_type\": \"Vector2\", \"x\": 100, \"y\": 200},\n    \"scale\": {\"_type\": \"Vector2\", \"x\": 2, \"y\": 2}\n  }\n```\n\n### Inspecting Nodes\n```\nTo see all properties of a node:\n\ngodot_editor_get_node_properties\n- nodePath: \"Player\"\n- filter: \"exported\"  (or \"all\" for everything)\n```\n\n### Building Scene Hierarchies\n```\nTo create a character scene structure:\n\n1. Root: godot_editor_add_node (type: CharacterBody2D, name: Player)\n2. Sprite: godot_editor_add_node (parent: Player, type: Sprite2D)\n3. Collision: godot_editor_add_node (parent: Player, type: CollisionShape2D)\n4. Camera: godot_editor_add_node (parent: Player, type: Camera2D)\n```\n\n### Running and Testing\n```\nTest your changes:\n\n1. godot_editor_save_scene  - Save current work\n2. godot_editor_run_scene   - Run and test\n3. godot_editor_stop_scene  - Stop when done\n4. godot_editor_get_errors  - Check for issues\n```\n\n## Property Type Formatting\n\nWhen modifying properties via live editing, use these JSON formats:\n\n### Vector2\n```json\n{\n  \"_type\": \"Vector2\",\n  \"x\": 100.0,\n  \"y\": 200.0\n}\n```\n\n### Vector3\n```json\n{\n  \"_type\": \"Vector3\",\n  \"x\": 1.0,\n  \"y\": 2.0,\n  \"z\": 3.0\n}\n```\n\n### Color\n```json\n{\n  \"_type\": \"Color\",\n  \"r\": 1.0,\n  \"g\": 0.5,\n  \"b\": 0.0,\n  \"a\": 1.0\n}\n```\n\n### Simple Values\n```json\n{\n  \"visible\": true,\n  \"rotation\": 1.57,\n  \"speed\": 200.0,\n  \"text\": \"Hello World\"\n}\n```\n\n## Workflow Patterns\n\n### Iterative UI Design\n```\n1. Connect to editor\n2. Get current scene tree\n3. Add container nodes (VBoxContainer, HBoxContainer)\n4. Add UI elements (Label, Button, ProgressBar)\n5. Adjust positions/sizes with modify_node\n6. Run scene to preview\n7. Iterate until satisfied\n8. Save scene\n```\n\n### Level Building\n```\n1. Connect to editor\n2. Instantiate pre-made scenes (enemies, items, platforms)\n3. Position them with modify_node\n4. Duplicate nodes as needed\n5. Run to test gameplay\n6. Adjust and iterate\n```\n\n### Debugging\n```\n1. Connect to editor\n2. Run scene\n3. Use get_errors to check for problems\n4. Execute GDScript to inspect runtime state:\n   godot_editor_execute_gdscript\n   - code: \"return get_tree().current_scene.get_node('Player').position\"\n5. Stop scene\n6. Fix issues\n```\n\n## Best Practices\n\n1. **Always save before running** - `godot_editor_save_scene` first\n2. **Work incrementally** - Add one node, verify, then continue\n3. **Use descriptive names** - \"PlayerHealthBar\" not \"ProgressBar2\"\n4. **Check the scene tree** - Use `godot_editor_get_scene_tree` to verify structure\n5. **Inspect before modifying** - Use `godot_editor_get_node_properties` to see current values\n6. **Use undo if needed** - All operations support Ctrl+Z in the editor\n7. **Refresh filesystem** - After external file changes, use `godot_editor_refresh_filesystem`\n\n## Error Handling\n\nCommon issues:\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| \"Not connected\" | Plugin not running | Start Godot, enable plugin |\n| \"Node not found\" | Wrong path | Use get_scene_tree to find correct path |\n| \"No scene open\" | No scene loaded | Open a scene in Godot first |\n| \"Parent not found\" | Invalid parent path | Check parent exists in tree |\n| \"Failed to create node\" | Invalid node type | Verify type name (case-sensitive) |\n\n## Available Node Types\n\nUse `godot_editor_get_node_types` to list all instantiable node types:\n```\ngodot_editor_get_node_types\n- base_type: \"Control\"  // List all UI nodes\n- base_type: \"Node2D\"   // List all 2D nodes\n- base_type: \"Node3D\"   // List all 3D nodes\n```\n\n## Scene Management\n\n```\n# List all scenes in project\ngodot_editor_list_assets_by_type\n- type: \"scenes\"\n\n# Open a different scene\ngodot_editor_open_scene\n- scenePath: \"res://scenes/main_menu.tscn\"\n\n# Save as new scene\ngodot_editor_save_scene_as\n- path: \"res://scenes/level_2.tscn\"\n\n# Instantiate a scene as child\ngodot_editor_instantiate_scene\n- scene_path: \"res://scenes/enemy.tscn\"\n- parent: \"Enemies\"\n- name: \"Enemy1\"\n```\n",
        "skills/godot-scene-design/SKILL.md": "# Godot Scene Design Skill\n\nYou are an expert at designing and creating Godot 4.x scenes (.tscn files), node hierarchies, and level layouts.\n\n## Scene File Format (TSCN)\n\nGodot uses a text-based scene format that's highly readable and AI-friendly.\n\n### Basic Structure\n```ini\n[gd_scene load_steps=3 format=3 uid=\"uid://abc123\"]\n\n[ext_resource type=\"Script\" path=\"res://scripts/player.gd\" id=\"1_abc\"]\n[ext_resource type=\"Texture2D\" path=\"res://sprites/player.png\" id=\"2_def\"]\n\n[sub_resource type=\"CircleShape2D\" id=\"CircleShape2D_xyz\"]\nradius = 16.0\n\n[node name=\"Player\" type=\"CharacterBody2D\"]\nscript = ExtResource(\"1_abc\")\nspeed = 200.0\n\n[node name=\"Sprite2D\" type=\"Sprite2D\" parent=\".\"]\ntexture = ExtResource(\"2_def\")\n\n[node name=\"CollisionShape2D\" type=\"CollisionShape2D\" parent=\".\"]\nshape = SubResource(\"CircleShape2D_xyz\")\n\n[connection signal=\"body_entered\" from=\".\" to=\".\" method=\"_on_body_entered\"]\n```\n\n### Key Sections\n1. **Header**: `[gd_scene load_steps=N format=3]` - N is total resources + 1\n2. **External Resources**: References to other files (scripts, textures, scenes)\n3. **Sub-resources**: Inline resources (shapes, materials, curves)\n4. **Nodes**: Scene tree structure with parent references\n5. **Connections**: Signal connections between nodes\n\n## Common Scene Patterns\n\n### Player Character (2D Platformer)\n```\nPlayer (CharacterBody2D)\nâ”œâ”€â”€ Sprite2D\nâ”œâ”€â”€ CollisionShape2D\nâ”œâ”€â”€ AnimationPlayer\nâ”œâ”€â”€ Camera2D\nâ”‚   â””â”€â”€ (smooth follow settings)\nâ”œâ”€â”€ Hitbox (Area2D)\nâ”‚   â””â”€â”€ CollisionShape2D\nâ””â”€â”€ RayCast2D (ground detection)\n```\n\n### Player Character (3D)\n```\nPlayer (CharacterBody3D)\nâ”œâ”€â”€ CollisionShape3D\nâ”œâ”€â”€ MeshInstance3D (or imported model)\nâ”œâ”€â”€ AnimationTree\nâ”œâ”€â”€ Camera3D\nâ”‚   â””â”€â”€ SpringArm3D (for collision)\nâ””â”€â”€ Marker3D (weapon attachment points)\n```\n\n### Enemy (2D)\n```\nEnemy (CharacterBody2D)\nâ”œâ”€â”€ Sprite2D\nâ”œâ”€â”€ CollisionShape2D\nâ”œâ”€â”€ AnimationPlayer\nâ”œâ”€â”€ DetectionArea (Area2D)\nâ”‚   â””â”€â”€ CollisionShape2D\nâ”œâ”€â”€ Hitbox (Area2D)\nâ”‚   â””â”€â”€ CollisionShape2D\nâ”œâ”€â”€ NavigationAgent2D\nâ””â”€â”€ Timer (attack cooldown)\n```\n\n### UI Screen\n```\nUIScreen (Control)\nâ”œâ”€â”€ Background (TextureRect/ColorRect)\nâ”œâ”€â”€ VBoxContainer\nâ”‚   â”œâ”€â”€ Title (Label)\nâ”‚   â”œâ”€â”€ HSeparator\nâ”‚   â””â”€â”€ ButtonContainer (VBoxContainer)\nâ”‚       â”œâ”€â”€ StartButton (Button)\nâ”‚       â”œâ”€â”€ OptionsButton (Button)\nâ”‚       â””â”€â”€ QuitButton (Button)\nâ””â”€â”€ AnimationPlayer (transitions)\n```\n\n### HUD\n```\nHUD (CanvasLayer)\nâ””â”€â”€ Control\n    â”œâ”€â”€ MarginContainer\n    â”‚   â””â”€â”€ HBoxContainer\n    â”‚       â”œâ”€â”€ HealthBar (ProgressBar/TextureProgressBar)\n    â”‚       â””â”€â”€ ScoreLabel (Label)\n    â”œâ”€â”€ Minimap (SubViewportContainer)\n    â”‚   â””â”€â”€ SubViewport\n    â”‚       â””â”€â”€ Camera2D\n    â””â”€â”€ DialogBox (PanelContainer)\n        â””â”€â”€ VBoxContainer\n            â”œâ”€â”€ SpeakerLabel\n            â””â”€â”€ DialogText (RichTextLabel)\n```\n\n### Inventory Item\n```\nItem (Area2D)\nâ”œâ”€â”€ Sprite2D\nâ”œâ”€â”€ CollisionShape2D (pickup area)\nâ”œâ”€â”€ AnimationPlayer (bob/glow)\nâ””â”€â”€ AudioStreamPlayer2D (pickup sound)\n```\n\n### Level/World\n```\nLevel (Node2D)\nâ”œâ”€â”€ TileMapLayer (or TileMap for older)\nâ”œâ”€â”€ Entities (Node2D)\nâ”‚   â”œâ”€â”€ Player\nâ”‚   â”œâ”€â”€ Enemies (Node2D)\nâ”‚   â”‚   â”œâ”€â”€ Enemy1\nâ”‚   â”‚   â””â”€â”€ Enemy2\nâ”‚   â””â”€â”€ Items (Node2D)\nâ”œâ”€â”€ NavigationRegion2D\nâ”‚   â””â”€â”€ (navigation polygon)\nâ”œâ”€â”€ ParallaxBackground\nâ”‚   â””â”€â”€ ParallaxLayer\nâ”‚       â””â”€â”€ Sprite2D\nâ””â”€â”€ Camera2D (level bounds)\n```\n\n### Dialogue System\n```\nDialogueManager (Node)\nâ”œâ”€â”€ CanvasLayer\nâ”‚   â””â”€â”€ DialogueBox (Control)\nâ”‚       â”œâ”€â”€ Portrait (TextureRect)\nâ”‚       â”œâ”€â”€ NameLabel (Label)\nâ”‚       â”œâ”€â”€ TextLabel (RichTextLabel)\nâ”‚       â””â”€â”€ ChoicesContainer (VBoxContainer)\nâ”œâ”€â”€ Timer (text reveal)\nâ””â”€â”€ AudioStreamPlayer (voice/sfx)\n```\n\n## Node Selection Guide\n\n### Physics Bodies\n| Node | Use Case |\n|------|----------|\n| `CharacterBody2D/3D` | Player, enemies, NPCs with custom movement |\n| `RigidBody2D/3D` | Physics-driven objects (crates, balls) |\n| `StaticBody2D/3D` | Immovable collision (walls, floors) |\n| `Area2D/3D` | Triggers, detection zones, pickups |\n\n### Visual Nodes (2D)\n| Node | Use Case |\n|------|----------|\n| `Sprite2D` | Static images |\n| `AnimatedSprite2D` | Frame-based animations |\n| `TileMapLayer` | Level geometry, backgrounds |\n| `Line2D` | Trails, lasers, drawing |\n| `Polygon2D` | Custom shapes |\n| `CPUParticles2D` | Effects (compatible) |\n| `GPUParticles2D` | Effects (performant) |\n\n### Visual Nodes (3D)\n| Node | Use Case |\n|------|----------|\n| `MeshInstance3D` | 3D models |\n| `CSGBox3D/Sphere3D/etc` | Prototyping geometry |\n| `MultiMeshInstance3D` | Many identical objects |\n| `GPUParticles3D` | 3D particle effects |\n| `Decal` | Projected textures |\n\n### UI Nodes\n| Node | Use Case |\n|------|----------|\n| `Control` | Base container |\n| `Label/RichTextLabel` | Text display |\n| `Button/TextureButton` | Clickable elements |\n| `ProgressBar/TextureProgressBar` | Health bars, loading |\n| `HBoxContainer/VBoxContainer` | Auto-layout |\n| `MarginContainer` | Padding |\n| `PanelContainer` | Styled backgrounds |\n| `ScrollContainer` | Scrollable content |\n| `TabContainer` | Tabbed interfaces |\n\n### Audio Nodes\n| Node | Use Case |\n|------|----------|\n| `AudioStreamPlayer` | Global audio (music, UI) |\n| `AudioStreamPlayer2D` | Positional 2D audio |\n| `AudioStreamPlayer3D` | Positional 3D audio |\n\n### Utility Nodes\n| Node | Use Case |\n|------|----------|\n| `Timer` | Delayed actions, cooldowns |\n| `AnimationPlayer` | Property animations |\n| `AnimationTree` | Complex animation state machines |\n| `Tween` | Programmatic animations |\n| `RayCast2D/3D` | Line-of-sight, ground detection |\n| `ShapeCast2D/3D` | Swept collision detection |\n\n## Collision Layers Best Practice\n\n```\nLayer 1: World (static geometry)\nLayer 2: Player\nLayer 3: Enemies\nLayer 4: Player projectiles\nLayer 5: Enemy projectiles\nLayer 6: Pickups\nLayer 7: Triggers/areas\nLayer 8: Interactables\n```\n\nSet in scene:\n```ini\n[node name=\"Player\" type=\"CharacterBody2D\"]\ncollision_layer = 2\ncollision_mask = 1 | 3 | 6  # Collides with world, enemies, pickups\n```\n\n## Groups for Organization\n\nUse groups to organize and find nodes:\n```ini\n[node name=\"Enemy\" type=\"CharacterBody2D\" groups=[\"enemies\", \"damageable\"]]\n```\n\nCommon groups:\n- `enemies` - All enemy nodes\n- `damageable` - Anything that can take damage\n- `interactable` - Objects player can interact with\n- `persistent` - Nodes that persist between scenes\n- `pausable` - Nodes affected by pause\n\n## Scene Instancing\n\nReference external scenes:\n```ini\n[ext_resource type=\"PackedScene\" path=\"res://scenes/enemy.tscn\" id=\"enemy_scene\"]\n\n[node name=\"Enemy1\" parent=\"Enemies\" instance=ExtResource(\"enemy_scene\")]\nposition = Vector2(100, 200)\n\n[node name=\"Enemy2\" parent=\"Enemies\" instance=ExtResource(\"enemy_scene\")]\nposition = Vector2(300, 200)\n```\n\n## Property Overrides\n\nOverride instanced scene properties:\n```ini\n[node name=\"Enemy1\" parent=\"Enemies\" instance=ExtResource(\"enemy_scene\")]\nposition = Vector2(100, 200)\nspeed = 150.0  # Override exported property\n```\n\n## Animation Setup\n\n### AnimationPlayer in Scene\n```ini\n[sub_resource type=\"Animation\" id=\"Animation_idle\"]\nlength = 1.0\nloop_mode = 1\ntracks/0/type = \"value\"\ntracks/0/path = NodePath(\"Sprite2D:frame\")\ntracks/0/interp = 1\ntracks/0/keys = {\n\"times\": PackedFloat32Array(0, 0.25, 0.5, 0.75),\n\"values\": [0, 1, 2, 3]\n}\n\n[node name=\"AnimationPlayer\" type=\"AnimationPlayer\" parent=\".\"]\nlibraries = {\n\"\": SubResource(\"AnimationLibrary_abc\")\n}\n```\n\n## Tips for AI Scene Generation\n\n1. **Start with the root node type** - Choose based on the scene's purpose (CharacterBody2D for characters, Control for UI, Node2D for levels)\n\n2. **Build hierarchy logically** - Visual nodes as children of physics bodies, UI elements in containers\n\n3. **Use appropriate collision shapes** - RectangleShape2D for boxes, CapsuleShape2D for characters, circles for projectiles\n\n4. **Set up layers correctly** - Avoid \"everything collides with everything\"\n\n5. **Name nodes descriptively** - \"PlayerSprite\" not \"Sprite2D\", \"HealthBar\" not \"ProgressBar\"\n\n6. **Use groups for runtime queries** - `get_tree().get_nodes_in_group(\"enemies\")`\n\n7. **Instance reusable scenes** - Don't duplicate complex node trees\n\n8. **Consider processing order** - Parent nodes process before children\n\n9. **Z-index for 2D layering** - Background < World < Entities < Effects < UI\n\n10. **Use CanvasLayer for HUD** - Keeps UI separate from game camera\n",
        "skills/godot-shader/SKILL.md": "# Godot Shader Skill\n\nYou are an expert at writing Godot 4.x shaders (.gdshader files) for 2D effects, 3D materials, and post-processing.\n\n## Shader Types\n\n```glsl\nshader_type canvas_item;    // 2D sprites, UI, CanvasItem nodes\nshader_type spatial;        // 3D materials\nshader_type particles;      // GPU particle systems\nshader_type sky;            // Sky/environment\nshader_type fog;            // Volumetric fog\n```\n\n## Basic Shader Structure\n\n```glsl\nshader_type canvas_item;\n\n// Render modes (optional)\nrender_mode unshaded, blend_mix;\n\n// Uniforms (exposed to inspector)\nuniform vec4 tint_color : source_color = vec4(1.0);\nuniform float intensity : hint_range(0.0, 1.0) = 0.5;\nuniform sampler2D noise_texture : hint_default_white;\n\n// Varyings (pass data vertex -> fragment)\nvarying vec2 world_position;\n\nvoid vertex() {\n    // Modify vertex position\n    world_position = (MODEL_MATRIX * vec4(VERTEX, 0.0, 1.0)).xy;\n}\n\nvoid fragment() {\n    // Output color\n    vec4 tex_color = texture(TEXTURE, UV);\n    COLOR = tex_color * tint_color;\n}\n```\n\n## Uniform Hints\n\n```glsl\n// Color picker in inspector\nuniform vec4 color : source_color = vec4(1.0);\n\n// Slider with range\nuniform float value : hint_range(0.0, 1.0, 0.01) = 0.5;\n\n// Texture hints\nuniform sampler2D albedo_tex : source_color, filter_linear_mipmap;\nuniform sampler2D normal_tex : hint_normal;\nuniform sampler2D noise_tex : hint_default_white;\nuniform sampler2D mask_tex : hint_default_black;\n\n// Instance uniforms (per-instance values)\ninstance uniform vec4 instance_color : source_color = vec4(1.0);\n```\n\n## Built-in Variables\n\n### Canvas Item (2D)\n```glsl\n// Vertex shader\nVERTEX          // vec2 - vertex position\nUV              // vec2 - texture coordinates\nCOLOR           // vec4 - vertex color\nPOINT_SIZE      // float - point size\n\n// Fragment shader\nUV              // vec2 - interpolated UVs\nSCREEN_UV       // vec2 - screen space UVs\nFRAGCOORD       // vec4 - fragment coordinates\nCOLOR           // vec4 - output color\nNORMAL          // vec3 - normal for 2D lighting\nTEXTURE         // sampler2D - sprite texture\nTEXTURE_PIXEL_SIZE // vec2 - texel size\n\n// Both\nTIME            // float - shader time\nPI              // float - 3.14159...\nTAU             // float - 6.28318...\n```\n\n### Spatial (3D)\n```glsl\n// Vertex shader\nVERTEX          // vec3 - vertex position (local)\nNORMAL          // vec3 - vertex normal\nUV              // vec2 - primary UVs\nUV2             // vec2 - secondary UVs\nCOLOR           // vec4 - vertex color\nPOSITION        // vec4 - clip space position (output)\n\n// Fragment shader\nALBEDO          // vec3 - base color (output)\nALPHA           // float - transparency (output)\nMETALLIC        // float - metalness (output)\nROUGHNESS       // float - roughness (output)\nEMISSION        // vec3 - emissive color (output)\nNORMAL_MAP      // vec3 - normal map (output)\nNORMAL_MAP_DEPTH // float - normal map strength\nAO              // float - ambient occlusion (output)\nRIM             // float - rim lighting (output)\nRIM_TINT        // float - rim tint amount\n```\n\n## Common 2D Shader Patterns\n\n### Flash/Hit Effect\n```glsl\nshader_type canvas_item;\n\nuniform vec4 flash_color : source_color = vec4(1.0, 1.0, 1.0, 1.0);\nuniform float flash_amount : hint_range(0.0, 1.0) = 0.0;\n\nvoid fragment() {\n    vec4 tex_color = texture(TEXTURE, UV);\n    COLOR = mix(tex_color, flash_color, flash_amount);\n    COLOR.a = tex_color.a;\n}\n```\n\n### Outline\n```glsl\nshader_type canvas_item;\n\nuniform vec4 outline_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);\nuniform float outline_width : hint_range(0.0, 10.0) = 1.0;\n\nvoid fragment() {\n    vec2 size = TEXTURE_PIXEL_SIZE * outline_width;\n\n    float outline = texture(TEXTURE, UV + vec2(-size.x, 0)).a;\n    outline += texture(TEXTURE, UV + vec2(size.x, 0)).a;\n    outline += texture(TEXTURE, UV + vec2(0, -size.y)).a;\n    outline += texture(TEXTURE, UV + vec2(0, size.y)).a;\n    outline = min(outline, 1.0);\n\n    vec4 tex_color = texture(TEXTURE, UV);\n    COLOR = mix(outline_color * outline, tex_color, tex_color.a);\n}\n```\n\n### Dissolve Effect\n```glsl\nshader_type canvas_item;\n\nuniform sampler2D dissolve_texture : hint_default_white;\nuniform float dissolve_amount : hint_range(0.0, 1.0) = 0.0;\nuniform float edge_width : hint_range(0.0, 0.2) = 0.05;\nuniform vec4 edge_color : source_color = vec4(1.0, 0.5, 0.0, 1.0);\n\nvoid fragment() {\n    vec4 tex_color = texture(TEXTURE, UV);\n    float noise = texture(dissolve_texture, UV).r;\n\n    float edge = smoothstep(dissolve_amount, dissolve_amount + edge_width, noise);\n    float alpha = step(dissolve_amount, noise);\n\n    COLOR = mix(edge_color, tex_color, edge);\n    COLOR.a = tex_color.a * alpha;\n}\n```\n\n### Pixelate\n```glsl\nshader_type canvas_item;\n\nuniform float pixel_size : hint_range(1.0, 100.0) = 4.0;\n\nvoid fragment() {\n    vec2 grid_uv = round(UV * pixel_size) / pixel_size;\n    COLOR = texture(TEXTURE, grid_uv);\n}\n```\n\n### Wave/Distortion\n```glsl\nshader_type canvas_item;\n\nuniform float wave_amplitude : hint_range(0.0, 0.1) = 0.02;\nuniform float wave_frequency : hint_range(0.0, 50.0) = 10.0;\nuniform float wave_speed : hint_range(0.0, 10.0) = 2.0;\n\nvoid fragment() {\n    vec2 uv = UV;\n    uv.x += sin(uv.y * wave_frequency + TIME * wave_speed) * wave_amplitude;\n    COLOR = texture(TEXTURE, uv);\n}\n```\n\n### Gradient Map\n```glsl\nshader_type canvas_item;\n\nuniform sampler2D gradient : hint_default_white;\n\nvoid fragment() {\n    vec4 tex_color = texture(TEXTURE, UV);\n    float luminance = dot(tex_color.rgb, vec3(0.299, 0.587, 0.114));\n    vec3 mapped = texture(gradient, vec2(luminance, 0.0)).rgb;\n    COLOR = vec4(mapped, tex_color.a);\n}\n```\n\n### Screen-Space Chromatic Aberration\n```glsl\nshader_type canvas_item;\n\nuniform float offset : hint_range(0.0, 0.01) = 0.005;\n\nvoid fragment() {\n    vec2 dir = UV - vec2(0.5);\n    float r = texture(TEXTURE, UV + dir * offset).r;\n    float g = texture(TEXTURE, UV).g;\n    float b = texture(TEXTURE, UV - dir * offset).b;\n    float a = texture(TEXTURE, UV).a;\n    COLOR = vec4(r, g, b, a);\n}\n```\n\n## Common 3D Shader Patterns\n\n### Basic PBR Override\n```glsl\nshader_type spatial;\n\nuniform vec4 albedo_color : source_color = vec4(1.0);\nuniform sampler2D albedo_texture : source_color, hint_default_white;\nuniform float metallic : hint_range(0.0, 1.0) = 0.0;\nuniform float roughness : hint_range(0.0, 1.0) = 0.5;\n\nvoid fragment() {\n    vec4 tex = texture(albedo_texture, UV);\n    ALBEDO = tex.rgb * albedo_color.rgb;\n    METALLIC = metallic;\n    ROUGHNESS = roughness;\n    ALPHA = tex.a * albedo_color.a;\n}\n```\n\n### Fresnel/Rim Lighting\n```glsl\nshader_type spatial;\n\nuniform vec4 rim_color : source_color = vec4(1.0);\nuniform float rim_power : hint_range(0.0, 10.0) = 3.0;\n\nvoid fragment() {\n    float fresnel = pow(1.0 - dot(NORMAL, VIEW), rim_power);\n    EMISSION = rim_color.rgb * fresnel * rim_color.a;\n}\n```\n\n### Triplanar Mapping\n```glsl\nshader_type spatial;\n\nuniform sampler2D texture_albedo : source_color;\nuniform float blend_sharpness : hint_range(1.0, 10.0) = 3.0;\n\nvarying vec3 world_position;\nvarying vec3 world_normal;\n\nvoid vertex() {\n    world_position = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;\n    world_normal = (MODEL_MATRIX * vec4(NORMAL, 0.0)).xyz;\n}\n\nvoid fragment() {\n    vec3 blending = pow(abs(world_normal), vec3(blend_sharpness));\n    blending /= blending.x + blending.y + blending.z;\n\n    vec3 x_proj = texture(texture_albedo, world_position.yz).rgb;\n    vec3 y_proj = texture(texture_albedo, world_position.xz).rgb;\n    vec3 z_proj = texture(texture_albedo, world_position.xy).rgb;\n\n    ALBEDO = x_proj * blending.x + y_proj * blending.y + z_proj * blending.z;\n}\n```\n\n### Hologram Effect\n```glsl\nshader_type spatial;\nrender_mode cull_disabled, depth_draw_opaque;\n\nuniform vec4 hologram_color : source_color = vec4(0.0, 1.0, 1.0, 1.0);\nuniform float scan_speed : hint_range(0.0, 10.0) = 2.0;\nuniform float scan_line_count : hint_range(10.0, 200.0) = 50.0;\nuniform float flicker_speed : hint_range(0.0, 20.0) = 5.0;\n\nvoid fragment() {\n    float scan = sin((UV.y + TIME * scan_speed) * scan_line_count) * 0.5 + 0.5;\n    float flicker = sin(TIME * flicker_speed) * 0.1 + 0.9;\n    float fresnel = pow(1.0 - dot(NORMAL, VIEW), 2.0);\n\n    ALBEDO = hologram_color.rgb;\n    EMISSION = hologram_color.rgb * (scan * 0.5 + 0.5) * flicker;\n    ALPHA = (fresnel + 0.3) * scan * flicker * hologram_color.a;\n}\n```\n\n## Post-Processing (Screen Shaders)\n\nApply to ColorRect covering viewport:\n\n### Vignette\n```glsl\nshader_type canvas_item;\n\nuniform float vignette_intensity : hint_range(0.0, 1.0) = 0.4;\nuniform float vignette_opacity : hint_range(0.0, 1.0) = 0.5;\n\nvoid fragment() {\n    vec4 color = texture(TEXTURE, UV);\n\n    float vignette = UV.x * UV.y * (1.0 - UV.x) * (1.0 - UV.y);\n    vignette = clamp(pow(16.0 * vignette, vignette_intensity), 0.0, 1.0);\n\n    color.rgb = mix(color.rgb, color.rgb * vignette, vignette_opacity);\n    COLOR = color;\n}\n```\n\n### CRT Effect\n```glsl\nshader_type canvas_item;\n\nuniform float scanline_count : hint_range(0.0, 1000.0) = 400.0;\nuniform float scanline_intensity : hint_range(0.0, 1.0) = 0.1;\nuniform float curvature : hint_range(0.0, 0.1) = 0.02;\n\nvoid fragment() {\n    // Barrel distortion\n    vec2 uv = UV - 0.5;\n    float dist = dot(uv, uv);\n    uv *= 1.0 + dist * curvature;\n    uv += 0.5;\n\n    vec4 color = texture(TEXTURE, uv);\n\n    // Scanlines\n    float scanline = sin(uv.y * scanline_count * PI) * 0.5 + 0.5;\n    color.rgb -= scanline_intensity * scanline;\n\n    // Edge fade\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n        color = vec4(0.0);\n    }\n\n    COLOR = color;\n}\n```\n\n## Particle Shaders\n\n```glsl\nshader_type particles;\n\nuniform float spread : hint_range(0.0, 180.0) = 45.0;\nuniform float initial_speed : hint_range(0.0, 100.0) = 10.0;\n\nvoid start() {\n    float angle = radians(spread) * (RANDOM.x - 0.5);\n    vec3 direction = vec3(sin(angle), cos(angle), 0.0);\n    VELOCITY = direction * initial_speed;\n}\n\nvoid process() {\n    // Apply gravity\n    VELOCITY.y -= 9.8 * DELTA;\n\n    // Fade out\n    COLOR.a = 1.0 - LIFETIME;\n\n    // Scale down\n    TRANSFORM[0].x = 1.0 - LIFETIME * 0.5;\n    TRANSFORM[1].y = 1.0 - LIFETIME * 0.5;\n}\n```\n\n## Tips for AI Shader Generation\n\n1. **Start simple** - Begin with basic structure, add complexity iteratively\n2. **Use hints** - `hint_range`, `source_color` make shaders usable\n3. **Comment uniforms** - Explain what each parameter does\n4. **Provide defaults** - Always set sensible default values\n5. **Consider performance** - Avoid expensive operations in fragment shader when possible\n6. **Test edge cases** - UV boundaries, alpha handling, blend modes\n7. **Match shader type to use case** - canvas_item for 2D, spatial for 3D\n8. **Use built-ins** - TIME, UV, TEXTURE are optimized\n"
      },
      "plugins": [
        {
          "name": "godot-claude-skills",
          "source": "./",
          "description": "GDScript patterns, live editor control, scene design, and shader authoring for Godot 4.x",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add alexmeckes/godot-claude-skills",
            "/plugin install godot-claude-skills@godot-claude-skills"
          ]
        }
      ]
    }
  ]
}