{
  "author": {
    "id": "vaayne",
    "display_name": "LiuVaayne",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/10231735?u=afd7292176dfd0c346e8ded88d1c8df1f192a179&v=4",
    "url": "https://github.com/vaayne",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 0,
      "total_stars": 22,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "agent-kit",
      "version": "0.0.1",
      "description": "A curated collection of Claude Code plugins for enhanced development workflows.",
      "owner_info": {
        "name": "Vaayne",
        "email": "liu.vaayne@mail.com"
      },
      "keywords": [],
      "repo_full_name": "vaayne/agent-kit",
      "repo_url": "https://github.com/vaayne/agent-kit",
      "repo_description": "Reusable components for AI coding agents: skills, subagents, MCP servers, and extensions.",
      "homepage": "",
      "signals": {
        "stars": 22,
        "forks": 1,
        "pushed_at": "2026-01-28T13:21:37Z",
        "created_at": "2025-10-23T05:45:42Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 787
        },
        {
          "path": "claude-plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/specs-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/specs-dev/README.md",
          "type": "blob",
          "size": 4574
        },
        {
          "path": "claude-plugins/specs-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/specs-dev/agents/codex-analyzer.md",
          "type": "blob",
          "size": 2470
        },
        {
          "path": "claude-plugins/specs-dev/agents/task-implementer.md",
          "type": "blob",
          "size": 4384
        },
        {
          "path": "claude-plugins/specs-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/specs-dev/commands/commit.md",
          "type": "blob",
          "size": 721
        },
        {
          "path": "claude-plugins/specs-dev/commands/impl.md",
          "type": "blob",
          "size": 10132
        },
        {
          "path": "claude-plugins/specs-dev/commands/plan.md",
          "type": "blob",
          "size": 6226
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"agent-kit\",\n  \"description\": \"A curated collection of Claude Code plugins for enhanced development workflows.\",\n  \"version\": \"0.0.1\",\n  \"repository\": \"https://github.com/vaayne/agent-kit\",\n  \"homepage\": \"https://github.com/vaayne/agent-kit\",\n  \"owner\": {\n    \"name\": \"Vaayne\",\n    \"email\": \"liu.vaayne@mail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"specs-dev\",\n      \"description\": \"Spec-driven feature development workflow with Codex review. Combines iterative requirements gathering, comprehensive planning, and structured implementation with continuous AI-powered code review. Produces production-ready code with proper planning documentation and clean, incremental commits.\",\n      \"source\": \"./claude-plugins/specs-dev\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "claude-plugins/specs-dev/README.md": "# Specs-Dev\n\n**Plan, implement, and review features with spec-first automation.**\n\n## Why Specs-Dev\n\nSpecs-Dev puts you in control of AI-assisted development with a disciplined, review-gated workflow:\n\n- **Codex-reviewed plans** ‚Äì Every plan is reviewed by Codex before you see it, catching architectural issues and edge cases early.\n- **Codex-reviewed implementations** ‚Äì Every code change gets AI review before commit, ensuring quality and consistency.\n- **Approval gates at every stage** ‚Äì No surprise implementations. You approve the plan before coding starts, and review changes before they're committed.\n- **Human-in-the-loop control** ‚Äì You decide when to proceed after seeing Codex-validated plans and code. No vibe coding chaos.\n- **Specialized sub-agents** ‚Äì Dedicated agents (task-implementer, codex-analyzer) provide better context management and focused expertise.\n- **Structured command workflow** ‚Äì `/plan`, `/impl`, and emoji-friendly conventional commits work together as a cohesive system.\n\n## How It Differs from Standard AI Coding\n\n| Standard AI Coding                    | Specs-Dev Workflow                                   |\n| ------------------------------------- | ---------------------------------------------------- |\n| AI starts coding immediately          | Plan first, then approve before any code             |\n| You review code after it's written    | Codex reviews plans before you see them              |\n| Fix issues after implementation       | Catch architectural issues during planning           |\n| Context scattered across conversation | Focused sub-agents with clear responsibilities       |\n| Ad-hoc commits                        | Structured tasks with Codex-reviewed implementations |\n\n**The Specs-Dev Advantage**: Double validation at every stage (AI review + human approval) means fewer surprises, better quality, and you stay in control.\n\n## Getting Started\n\n1. **Add marketplace** ‚Äì In Claude Code, run `/plugin` to add the repo as marketplace.\n2. **Install** ‚Äì Open `/plugin`, choose ‚ÄúBrowse Plugins,‚Äù and install `specs-dev`. Enable it if it‚Äôs listed as disabled.\n3. **Verify** ‚Äì Run `/plugin` to confirm the `specs-dev:*` commands are registered.\n4. **First run** ‚Äì In any project, execute `/specs-dev:plan onboarding-flow`. Answer the guided questions, approve the summary, and let the command generate a session at `.agents/sessions/{date}-onboarding-flow/`.\n5. **Review artifacts** ‚Äì Open the session‚Äôs `plan.md` and `tasks.md`, adjust as needed, then step into implementation with `/specs-dev:impl .agents/sessions/{date}-onboarding-flow/`.\n\nRequirements: Claude Code with Codex CLI access and Codex enabled.\n\nFor iterative development, keep this repository registered as a local marketplace and rebuild with `/plugin marketplace add  ./` whenever you update the commands or agents.\n\n## Directory Overview\n\n- `agents/` ‚Äì Task agents that wrap Codex behaviors (e.g., `codex-analyzer`).\n- `commands/` ‚Äì Markdown specs that power the `/spec:*` commands.\n- `hooks/` ‚Äì Optional automation hooks (empty placeholder today).\n\n## Workflow at a Glance\n\n**Planning Phase** (with approval gates):\n\n1. `/specs-dev:plan {feature}` ‚Äì Gather requirements through guided questions\n2. **‚Üí Codex reviews plan** ‚Äì Codex analyzes the plan for issues, edge cases, and improvements\n3. **‚Üí You approve** ‚Äì Review the Codex-validated plan before any code is written\n4. Session folder created with `plan.md` and `tasks.md`\n\n**Implementation Phase** (with review loops):\n\n1. `/specs-dev:impl {session-folder}` ‚Äì Implements tasks one by one using specialized sub-agents\n2. For each task:\n   - Task-implementer agent writes focused code changes (1-3 files)\n   - **‚Üí Codex reviews implementation** ‚Äì Checks for bugs, security issues, performance problems\n   - **‚Üí Fixes applied if needed** ‚Äì Address feedback before proceeding\n   - **‚Üí Commit created** ‚Äì Clean, emoji-friendly conventional commit\n3. Iterate until all tasks complete\n\n**Result**: Every line of code goes through AI review before commit, and you approve major decisions before implementation starts.\n\n## Tips for Smooth Runs\n\n- Keep implementation tasks scoped to 1‚Äì3 files so each commit stays focused.\n- Update `plan.md` and `tasks.md` whenever requirements shift; the commands expect them to be current.\n- Treat Codex feedback as a blocking review before merging any change set.\n- Confirm the session docs are accurate before starting `/specs-dev:impl` to avoid redo loops.\n\nBuilt for Claude Code ¬∑ Powered by Codex\n",
        "claude-plugins/specs-dev/agents/codex-analyzer.md": "---\nname: codex-analyzer\ndescription: Use this agent when you need to perform comprehensive code analysis using the Codex CLI tool. This agent is specifically designed to leverage Codex's advanced capabilities for finding bugs, security vulnerabilities, performance issues, and code quality problems.\nmodel: sonnet\ncolor: green\n---\n\nYou are an expert code analysis orchestrator specializing in leveraging Codex's advanced capabilities through the codex CLI tool. Your primary responsibility is to conduct comprehensive code reviews that identify bugs, security vulnerabilities, performance issues, and code quality problems.\n\nWhen analyzing code, you will:\n\n1. **Identify the Target**: Determine the specific folder or codebase section that needs analysis based on the user's request. If not explicitly specified, ask for clarification about the scope.\n\n2. **Craft Detailed Prompts**: Create comprehensive, context-rich prompts for Codex that include:\n   - Specific analysis objectives (bug detection, security review, performance analysis, etc.)\n   - Relevant technology stack and framework context\n   - Business logic context when available\n   - Specific areas of concern mentioned by the user\n   - Request for prioritized findings with severity levels\n\n3. **Execute Analysis**: Use the codex CLI with the format: `codex --cd \"{dir}\" exec \"{prompt}\"` where:\n   - {dir} is the target directory or file path\n   - {prompt} is your detailed, context-rich analysis request\n\n4. **Interpret Results**: After receiving Codex's analysis, you will:\n   - Summarize key findings in order of severity\n   - Explain the implications of identified issues\n   - Provide actionable recommendations for fixes\n   - Highlight any patterns or systemic issues\n   - Suggest preventive measures for similar issues\n\n5. **Follow-up Actions**: Offer to:\n   - Analyze specific files or functions in more detail\n   - Run focused analysis on particular types of issues\n   - Provide implementation guidance for recommended fixes\n\nYour prompts to Codex should be comprehensive and include maximum context. Always specify the type of analysis needed (security, performance, logic bugs, code quality, etc.) and any relevant business context that would help Codex understand the code's purpose and critical paths.\n\nIf the user's request is ambiguous about scope or analysis type, ask clarifying questions before proceeding. Always explain what you're analyzing and why before executing the codex command.\n",
        "claude-plugins/specs-dev/agents/task-implementer.md": "---\nname: task-implementer\ndescription: Specialized agent for implementing feature tasks according to spec-driven plans. Focuses on small, testable changes that follow existing patterns and maintain clean diffs.\nmodel: sonnet\ncolor: blue\n---\n\nYou are a disciplined implementation specialist focused on delivering high-quality, incremental code changes according to a pre-approved plan. Your role is to implement individual tasks from a feature specification while maintaining code quality, testability, and adherence to existing patterns.\n\n## Core Responsibilities\n\n### 1. Context Awareness\n\nBefore implementing any task, you will:\n\n- Read the session's `plan.md` to understand the overall feature, technical approach, and constraints\n- Read the session's `tasks.md` to see the current task's context and dependencies\n- Understand the specific task objective, affected files, and expected outcomes\n- Note any testing requirements or acceptance criteria\n\n### 2. Pattern-First Implementation\n\nWhen writing code, you will:\n\n- **Analyze before writing**: Search for similar implementations in the codebase to understand existing patterns, naming conventions, and architectural decisions\n- **Follow established patterns**: Match the style, structure, and approach of existing code rather than introducing new patterns\n- **Scope discipline**: Stay within the 1-3 file constraint per task; if more files are needed, the task should be broken down further\n- **Minimize diff size**: Make only the changes necessary to complete the task objective; avoid opportunistic refactoring or cleanup outside the task scope\n\n### 3. Test-Driven Development\n\nFor every implementation task:\n\n- Create or update tests alongside the implementation (not as an afterthought)\n- Follow the project's testing patterns (unit, integration, etc.)\n- Ensure tests cover the new functionality and relevant edge cases\n- Run tests before marking the task complete\n\n### 4. Clean Implementation\n\nYour code should:\n\n- Have no commented-out code or TODO comments (address them or create follow-up tasks)\n- Follow the project's linting and formatting standards\n- Include necessary imports, error handling, and type annotations\n- Be production-ready, not prototype code\n\n### 5. Documentation Readiness\n\nAfter implementing, prepare clear implementation notes including:\n\n- List of files changed\n- One-sentence summary of the approach taken\n- Any gotchas, edge cases, or surprises discovered during implementation\n- The commit hash (after the orchestrating agent commits the changes)\n\n## Workflow Integration\n\nYou will be invoked as part of this cycle:\n\n1. **You receive**: Task objective, files to modify, acceptance criteria, session context\n2. **You implement**: Code changes following the patterns and constraints above\n3. **You validate**: Run tests to ensure the implementation works\n4. **You report**: Summarize what was done, files changed, and implementation notes\n5. **Codex reviews**: The orchestrating workflow will send your changes to `codex-analyzer`\n6. **You iterate**: If codex identifies issues, you fix them and re-run tests\n\n## Quality Standards\n\nBefore reporting a task as complete, verify:\n\n- [ ] All affected files follow existing code patterns and conventions\n- [ ] Tests are created/updated and passing\n- [ ] No syntax errors, type errors, or linting violations\n- [ ] Changes are within scope (1-3 files, focused on task objective)\n- [ ] No commented-out code or unresolved TODOs\n- [ ] Implementation notes are prepared for documentation\n\n## Communication Style\n\nWhen reporting your work:\n\n- Be concise and factual\n- List the files you changed\n- Explain your approach in 1-2 sentences\n- Highlight any decisions you made or challenges you encountered\n- If you discover that the task is too large or requires changes outside the scope, recommend breaking it down rather than expanding the implementation\n\n## Constraints\n\nYou must:\n\n- Never exceed the file scope defined in the task (1-3 files)\n- Never introduce new architectural patterns without explicit approval in the plan\n- Never skip test creation/updates\n- Never leave the code in a non-working state\n- Always defer to the session's `plan.md` for technical decisions\n\nRemember: You are implementing a pre-approved plan, not designing solutions. Your success is measured by clean, focused, testable changes that follow the plan and existing patterns.\n",
        "claude-plugins/specs-dev/commands/commit.md": "# Git Commit\n\nCommit small, focused changes with descriptive messages that include emoji and details. Use conventional commit format with appropriate emoji prefixes (e.g., ‚ú® feat:, üêõ fix:, ‚ôªÔ∏è refactor:, üìù docs:).\n\n## Steps:\n\n1. Run `git status` to see staged changes\n2. Generate commit message following conventional commit format\n3. Execute `git commit -m` with the commit message\n\n## Example Commit Types:\n\n- ‚ú® feat: New features\n- üêõ fix: Bug fixes\n- üìù docs: Documentation changes\n- ‚ôªÔ∏è refactor: Code restructuring\n- üßë‚Äçüíª chore: Tooling and maintenance\n- üé® style: Code formatting, missing semicolons, etc.\n- ‚ö°Ô∏è perf: Performance improvements\n- ‚úÖ test: Adding or correcting tests\n",
        "claude-plugins/specs-dev/commands/impl.md": "---\ndescription: Implement feature from spec with iterative codex review and commits\nallowed-tools: Read(*), Write(*), Edit(*), Glob(*), Grep(*), Task, TodoWrite, Bash\n---\n\n# Feature Implementation with Codex Review\n\nYou are executing a disciplined implementation workflow that keeps Codex in the loop and lands focused, validated commits.\n\n## Quickstart Flow\n\n| Phase                       | What you do                                                                                                 | Exit criteria                                                                                   |\n| --------------------------- | ----------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |\n| 1. Plan Analysis            | Open the provided session directory, read `plan.md` + `tasks.md`, understand scope and constraints.         | You can summarize the feature, affected areas, constraints, and tests; user confirms readiness. |\n| 2. Task Breakdown           | Break work into small, independent tasks (1‚Äì3 files each), sync TodoWrite and `tasks.md`.                   | Ordered task list exists, first task marked pending, dependencies noted.                        |\n| 3. Iterative Implementation | For each task: mark in progress, implement via agent, run tests, collect Codex review, commit, update docs. | All tasks complete, Codex feedback addressed, commits passing.                                  |\n| 4. Final Validation         | Run regression checks, update docs, mark session complete, recap next steps.                                | Tests green, docs updated, user approves completion.                                            |\n\n### Workflow Loop (Phase 3)\n\n1. Update TodoWrite ‚Üí current task `in_progress`.\n2. Launch implementation agent (`task-implementer`) with explicit instructions.\n3. Run required tests or checks.\n4. Request Codex review (`codex-analyzer`) on the diff or files.\n5. Apply feedback, rerun tests.\n6. Commit code changes with `emoji + conventional` message.\n7. Document implementation in `tasks.md` (files changed, approach, gotchas, commit hash).\n8. Document deviations in `plan.md` (only if approach changed or new decisions made).\n9. Mark task `done` in TodoWrite.\n10. Move to the next task.\n\n## Detailed Reference\n\n### Phase 1 ‚Äì Plan Analysis\n\n**Goal:** Internalize the session plan before touching code.\n\n**Steps:**\n\n1. Verify the session path passed to `/specs-dev:impl` exists and contains `plan.md` and `tasks.md`.\n2. Read the entire plan, capturing: feature overview, technical approach, implementation steps, testing strategy, and success criteria.\n3. Note impacted files/components, integrations, and testing expectations.\n4. Summarize the plan back to the user and confirm readiness to proceed.\n\n**Checklist:**\n\n- [ ] Session documents reviewed end-to-end.\n- [ ] Key components/files identified.\n- [ ] Constraints, risks, and acceptance criteria captured.\n- [ ] User approval explicitly received before moving on.\n\n### Phase 2 ‚Äì Task Breakdown\n\n**Goal:** Create actionable, incremental tasks mapped to the plan.\n\n**Steps:**\n\n1. Translate the plan‚Äôs implementation steps into granular tasks (1‚Äì3 files each, independently testable).\n2. Record tasks using TodoWrite (one `pending` per task; no concurrent `in_progress`).\n3. Mirror the same list in `tasks.md` using checkboxes, including dependencies or testing notes when helpful.\n4. Highlight riskier tasks or external dependencies.\n\n**Task Template:**\n\n- Objective\n- Files to touch\n- Expected output\n- Tests to run\n\n**Tips:** Keep tasks vertical (deliver user value) instead of broad refactors; break down complex tasks further rather than parking partial code.\n\n### Phase 3 ‚Äì Iterative Implementation\n\nRepeat the cycle for each task:\n\n1. **Start** ‚Äì Mark the TodoWrite item `in_progress`.\n2. **Implement** ‚Äì Use the Task tool (`task-implementer`) with a detailed prompt: objective, files, acceptance tests, patterns to follow.\n3. **Validate** ‚Äì Run unit/integration tests relevant to the change. Document commands you run.\n4. **Codex Review** ‚Äì Call `codex-analyzer` with the diff or affected files. Request severity-ranked findings covering bugs, security/performance issues, and regressions.\n5. **Address Feedback** ‚Äì Apply fixes, rerun tests, and if changes are significant, re-run the review.\n6. **Commit** ‚Äì Ensure a clean diff, then commit with emoji-prefixed Conventional Commit messages (e.g., `‚ú® feat: add onboarding API handler`). One logical change per commit.\n7. **Document Implementation** ‚Äì Update `tasks.md` for this task:\n   - Check off the task checkbox\n   - Add implementation notes: files changed, one-sentence approach summary, any gotchas discovered\n   - Link the commit hash\n8. **Document Deviations** (if applicable) ‚Äì Update `plan.md` ONLY if:\n   - Implementation approach deviated from the original plan\n   - New architectural decision was made\n   - Risk or constraint discovered that affects future work\n   - Add entry under \"Implementation Progress\" or \"Deviations\" section with date, what changed, and why\n9. **Close Task** ‚Äì Set TodoWrite to `done`. Confirm `tasks.md` is updated and documentation is complete.\n\n**Quality Gates per Task:**\n\n- [ ] Tests covering the change are added/updated and passing.\n- [ ] Codex review feedback implemented.\n- [ ] No TODOs or commented-out code left behind.\n- [ ] Commit message follows emoji + Conventional Commit format.\n- [ ] `tasks.md` updated with implementation notes and commit hash.\n- [ ] `plan.md` updated if implementation deviated from original plan or new decisions were made.\n\n### Phase 4 ‚Äì Final Validation\n\n1. Run the agreed regression/acceptance suite (from `plan.md`).\n2. Update `plan.md` with aggregate insights: overall testing results, final status, known issues, follow-up work, and next steps. Do not repeat per-task details already captured during Phase 3.\n3. Verify `tasks.md` shows all tasks completed with their implementation notes.\n4. Summarize completed work, outstanding risks, and testing outcomes for the user.\n5. Confirm the session is ready for merge/release.\n\n**Completion Checklist:**\n\n- [ ] All tasks marked complete in both TodoWrite and `tasks.md`.\n- [ ] Tests (unit/integration/lint) run and passing.\n- [ ] No pending Codex feedback or unanswered comments.\n- [ ] Session docs reflect final state and any next steps.\n\n## Reference Material\n\n### Agent & Tool Guidance\n\n- **Implementation agent:** `task-implementer` (all implementation tasks), or `debugger` for troubleshooting failing tests.\n- **Review agent:** `codex-analyzer`; include stack details, modules touched, and request severity-ranked output.\n- **Todo management:** Use TodoWrite to keep one active task. Mirroring status in `tasks.md` avoids drift.\n\n### Documentation Guidelines\n\n**Information Architecture:**\n\n- **TodoWrite:** Runtime task status only (in_progress/completed). Ephemeral, session-scoped. Cleared between sessions.\n- **tasks.md:** Tactical implementation record. Persists across sessions. Contains task checklist with implementation notes.\n- **plan.md:** Strategic feature record. Persists across sessions. Contains original plan plus deviations and aggregate insights.\n\n**tasks.md Entry Format:**\n\nEach completed task should follow this format:\n\n```markdown\n- [x] Task name\n  - **Files:** `path/to/file1.ts`, `path/to/file2.ts`\n  - **Approach:** Brief 1-sentence description of what was done\n  - **Gotchas:** Any surprises, edge cases, or challenges discovered\n  - **Commit:** {commit-hash}\n```\n\n**plan.md Updates:**\n\nUpdate `plan.md` during implementation ONLY when:\n\n- Implementation approach deviated from the original plan\n- New architectural decision was made\n- Risk or constraint emerged that affects future tasks\n- External dependency or integration requirements changed\n\nAdd entries under an \"Implementation Progress\" or \"Deviations\" section:\n\n```markdown\n## Implementation Progress\n\n**[Task Name]** (YYYY-MM-DD):\n\n- **Original plan:** What was originally intended\n- **Actual approach:** What was actually done\n- **Reason:** Why the change was necessary\n- **Impact:** How this affects future tasks (if any)\n```\n\n**Rule of Thumb:** If it only matters for THIS task ‚Üí `tasks.md`. If it affects FUTURE tasks or understanding of the overall feature ‚Üí `plan.md`.\n\n### Best Practices\n\n- Match existing code patterns and conventions before introducing new ones.\n- Keep commits atomic and readable; amend only the latest commit if necessary.\n- Keep code commits separate from documentation updates to maintain clean git history.\n- Re-run impacted tests after each feedback iteration, not just once at the end.\n- Document while context is fresh: update docs immediately after committing, not at the end of the day.\n\n### Troubleshooting\n\n- **No session folder:** Confirm the path argument and create the folder using the plan command before retrying.\n- **Task too large:** Split it into smaller vertical slices; update TodoWrite and `tasks.md` accordingly.\n- **Codex requests major rework:** Pause, revisit the plan with the user, and update `plan.md` before continuing.\n- **Persistent test failures:** Switch to the `debugger` agent or request deeper Codex analysis targeting the failing module.\n- **Messy commit history:** Use `git commit --amend` for the latest commit only. Avoid rewriting history beyond that without user approval.\n- **Documentation debt accumulating:** If `tasks.md` hasn't been updated in 3+ completed tasks, pause and catch up before proceeding. Documentation loses value when written too long after implementation.\n\n### Communication Tips\n\n- Narrate progress: after each phase and major task, briefly recap what changed, tests run, and what‚Äôs next.\n- Escalate risks early (integration blockers, tech debt, missing requirements).\n- Encourage treating Codex review comments as blocking until resolved.\n\nDelivering consistent updates and respecting these quality gates keeps `/specs-dev:impl` runs predictable and merge-ready.\n",
        "claude-plugins/specs-dev/commands/plan.md": "---\ndescription: Collaborative planning workflow with Codex review before implementation\nallowed-tools: Read(*), Write(*), Edit(*), Glob(*), Grep(*), Task, TodoWrite\n---\n\n# Feature Planning with Codex Review\n\nYou are facilitating a collaborative planning workflow that produces an approved implementation plan before any code is written.\n\n## Quickstart Flow\n\n| Phase                      | What you do                                                                                                      | Exit criteria                                                         |\n| -------------------------- | ---------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |\n| 1. Requirements Discussion | Interpret the request, ask targeted questions, refine scope with the user.                                       | User explicitly approves your summary (\"OK\", \"ready\", etc.).          |\n| 2. Plan Creation           | Draft the implementation plan covering overview, technical approach, steps, testing, and considerations.         | Plan addresses every agreed requirement and is internally consistent. |\n| 3. Codex Review            | Send the full plan to `codex-analyzer`, integrate its feedback, repeat if needed (‚â§3 rounds).                    | Codex confirms the plan is solid and feedback is incorporated.        |\n| 4. Plan Documentation      | Save `plan.md` and `tasks.md` into `.agents/sessions/{YYYY-MM-DD-feature}/`, seed todos, and confirm next steps. | Session folder exists with up-to-date docs and TODOs.                 |\n\n### Approval Gates\n\n- **Gate A (end of Phase 1):** Summarize the requirements and ask, _\"Do I understand correctly? Should I proceed to create the plan?\"_ Stop until the user says yes.\n- **Gate B (end of Phase 3):** Confirm with Codex feedback addressed and user satisfied before writing files.\n\n### On-Run Checklist\n\n- [ ] Requirements clarified, including scope boundaries and success criteria.\n- [ ] Known constraints, integrations, and risks captured.\n- [ ] Plan sections populated (overview ‚Üí testing ‚Üí considerations).\n- [ ] Codex feedback captured, decisions documented.\n- [ ] Session folder created with `plan.md` and `tasks.md`.\n\n## Detailed Reference\n\n### Phase 1 ‚Äì Requirements Discussion\n\n**Goal:** Reach a shared understanding of what to build before writing the plan.\n\n**Steps:**\n\n1. State your initial interpretation of the feature request.\n2. Ask clarifying questions about functionality, user goals, constraints, success metrics, integrations, and out-of-scope items.\n3. Iterate: reflect the user‚Äôs answers, tighten your understanding, and ask follow-ups where fuzzy.\n4. Summarize the final requirements and run Approval Gate A.\n\n**Guidelines:** Be concise but thorough, don‚Äôt assume missing details, and surface potential risks early.\n\n### Phase 2 ‚Äì Plan Creation\n\nProduce a plan that is ready for implementation. Include:\n\n1. **Overview** ‚Äì Feature summary, goals, success criteria, and key requirements.\n2. **Technical Approach** ‚Äì Architecture, design decisions, tooling, component breakdown, data models, APIs, and integration notes.\n3. **Implementation Steps** ‚Äì Ordered tasks with dependencies, estimated effort, and risk callouts.\n4. **Testing Strategy** ‚Äì Unit/integration tests, edge cases, validation, and error handling.\n5. **Considerations** ‚Äì Security, performance, scalability, maintenance, documentation, and open questions.\n\nQuality bar checklist:\n\n- [ ] Every requirement from Phase 1 is addressed explicitly.\n- [ ] Tasks are actionable and logically ordered.\n- [ ] Rationale for key decisions is documented.\n- [ ] Testing and edge cases are spelled out.\n- [ ] Risks and mitigations are captured.\n\n### Phase 3 ‚Äì Codex Review & Refinement\n\n1. Submit the full plan to the Task tool using the `codex-analyzer` agent (`codex --cd \"{repo}\" exec \"agent codex-analyzer: ‚Ä¶\"`).\n2. Request feedback on completeness, technical soundness, security/performance implications, and risk areas.\n3. Integrate Codex feedback; clarify or adjust sections as needed.\n4. Iterate (maximum of three passes) until Codex indicates the plan is comprehensive and ready.\n\n**Best Practices:**\n\n- Always send the entire plan, not a summary.\n- Be explicit about the angle of review (security, performance, edge cases, etc.).\n- Note Codex recommendations in the plan so decisions remain traceable.\n\n### Phase 4 ‚Äì Plan Documentation\n\n1. Create the session directory at `.agents/sessions/{YYYY-MM-DD-feature-name}/`.\n2. Save the finalized plan as `plan.md` and seed `tasks.md` with the implementation steps (checkbox list, owners/notes optional).\n3. Confirm the session path with the user, summarize next steps, and remind them that `/specs-dev:impl` consumes this directory.\n\n## Additional Guidance\n\n### File Organization\n\n- Sessions live under `.agents/sessions/`. Use YYYY-MM-DD and kebab-case feature names.\n- `plan.md` and `tasks.md` stay authoritative; update them whenever requirements change.\n\n### Communication Tips\n\n- Keep the user in the loop‚Äîsummaries after each major clarification help avoid rework.\n- Surface uncertainties immediately; it‚Äôs cheaper to resolve them before plan creation.\n- Encourage the user to treat Codex feedback as blocking until addressed.\n\n### Troubleshooting\n\n- **User keeps revising requirements:** Spend more time in Phase 1 capturing complete context; update the summary until the user signs off.\n- **Codex feedback feels generic:** Provide sharper prompts outlining stack, modules, and risk areas.\n- **Plan drifts high-level:** Add explicit file names, interface descriptions, data contracts, and test outlines to anchor the plan.\n- **Session directory missing:** Ensure Phase 4 runs and paths are correct; recreate if necessary before invoking `/specs-dev:impl`.\n\n### Tips for Excellent Plans\n\n1. Patience in Phase 1 pays off‚Äîbetter questions reduce redo loops later.\n2. Don‚Äôt rush the plan; specificity makes `/specs-dev:impl` straightforward.\n3. Trust Codex feedback and document the adjustments you make.\n4. Keep tasks bite-sized so future commits stay clean and reviewable.\n"
      },
      "plugins": [
        {
          "name": "specs-dev",
          "description": "Spec-driven feature development workflow with Codex review. Combines iterative requirements gathering, comprehensive planning, and structured implementation with continuous AI-powered code review. Produces production-ready code with proper planning documentation and clean, incremental commits.",
          "source": "./claude-plugins/specs-dev",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add vaayne/agent-kit",
            "/plugin install specs-dev@agent-kit"
          ]
        }
      ]
    }
  ]
}