{
  "author": {
    "id": "lhybdv",
    "display_name": "lhybdv",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/44795607?u=e95723143b5252ef7dac1019e83d175bc14981ad&v=4",
    "url": "https://github.com/lhybdv",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 6,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "fengyun-claude-marketplace",
      "version": null,
      "description": "Tender writing workflow: init/extract/outline/draft/review/build",
      "owner_info": {
        "name": "Fengyun Tech"
      },
      "keywords": [],
      "repo_full_name": "lhybdv/fengyun-claude-marketplace",
      "repo_url": "https://github.com/lhybdv/fengyun-claude-marketplace",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-29T15:48:07Z",
        "created_at": "2026-01-29T11:44:01Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 262
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/tender",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/tender/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/tender/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 127
        },
        {
          "path": "plugins/tender/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/tender/commands/build.md",
          "type": "blob",
          "size": 825
        },
        {
          "path": "plugins/tender/commands/draft.md",
          "type": "blob",
          "size": 1840
        },
        {
          "path": "plugins/tender/commands/extract.md",
          "type": "blob",
          "size": 795
        },
        {
          "path": "plugins/tender/commands/init.md",
          "type": "blob",
          "size": 15616
        },
        {
          "path": "plugins/tender/commands/outline.md",
          "type": "blob",
          "size": 4121
        },
        {
          "path": "plugins/tender/commands/review.md",
          "type": "blob",
          "size": 3846
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"fengyun-claude-marketplace\",\n  \"owner\": { \"name\": \"Fengyun Tech\" },\n  \"plugins\": [\n    {\n      \"name\": \"tender\",\n      \"source\": \"./plugins/tender\",\n      \"description\": \"Tender writing workflow: init/extract/outline/draft/review/build\"\n    }\n  ]\n}\n",
        "plugins/tender/.claude-plugin/plugin.json": "{\n  \"name\": \"tender\",\n  \"description\": \"Step-by-step tender writing with saved artifacts + docx build\",\n  \"version\": \"0.1.0\"\n}\n",
        "plugins/tender/commands/build.md": "---\ndescription: Assemble final.docx using template and generated assets\nargument-hint: (no args)\nallowed-tools: [Read, Write, Bash]\n---\n\n不要使用 Web。\n\n## 前置条件\n- inputs/template.docx 中请预留一个占位符段落：{{TECH_SECTION_BODY}}\n  （占位符文字单独成段，方便脚本定位替换）\n- work/40_drafts/v1.md 已生成\n\n## 0) 运行装配脚本\n用 Bash 执行：\npython tools/tenderctl/tenderctl.py build-docx --draft-md work/40_drafts/v1.md --out-docx work/60_build/final.docx\n\n## 1) 生成 build_log\n写 work/60_build/build_log.md，说明：\n- 用了哪个占位符\n- 标题映射策略（Heading 1/2/3、Normal、List Bullet/Number）\n- 图片插入策略（如 work/50_figures/out/ 有图）\n- 目录/编号如需在 Word 内刷新，给出操作提示\n\n只写 work/60_build/ 下文件\n",
        "plugins/tender/commands/draft.md": "---\ndescription: Draft v1 incrementally by sections (repeatable, accumulates to target)\nargument-hint: (no args)\nallowed-tools: [Read, Write]\n---\n\n不要使用 Web。\n\n目标：以“增量方式”生成首版正文，允许多次运行本命令逐步累积到 target_words（±10%）。\n\n输入：\n- work/30_plan/outline.md\n- work/20_requirements/reqs.json\n- work/00_manifest.yml\n\n输出（只写 work/40_drafts/）：\n- work/40_drafts/v1_sections/<SECTION_ID>.md（每个小节一个文件）\n- work/40_drafts/v1.md（可选：每次运行后把已完成小节按顺序拼接成一个总文件）\n并更新 work/00_manifest.yml：\n- draft_cursor（推进到本次最后完成的小节 id）\n- drafted_words（累加本次新增字数的估算）\n- drafting_completed（当 drafted_words >= target_words*0.9 时置 true）\n\n硬规则：\n1) 必须严格按 outline.md 的标题结构写（# / ## / ###），但每次只写“尚未生成”的下一批 ### 小节。\n2) 每次运行的生成量不超过 manifest.draft_run_budget（默认 20000 字左右），达到预算就停止。\n3) 若发现某 ### 小节对应的文件已存在（work/40_drafts/v1_sections/<id>.md），则视为已完成，跳过。\n4) 对于 design_status: TBD 的子系统相关小节：只写高层方案 + 占位说明，不得编造具体模块名/接口字段等细节。\n5) 如果 manifest 存在 functional_design 且当前小节 id == functional_design.root_id：\n   - 必须读取 functional_design.catalog_path 的模块清单；若不存在或为空，只写占位提示，不得编造模块。\n6) 每个小节文件末尾必须写隐藏注记：<!-- words: N -->（N 为该小节本次写作的字数估算）。\n\n最后：把所有已完成的小节文件按章节 id 排序拼接为 work/40_drafts/v1.md（保持标题不乱）。\n\n开始执行。\n",
        "plugins/tender/commands/extract.md": "---\ndescription: Extract technical requirements into reqs.json + format_rules.json\nargument-hint: (no args)\nallowed-tools: [Read, Write]\n---\n\n从 inputs/ 的招标文件与标书模板中，抽取“技术相关要求”和“格式/编排要求”，写入：\n- work/20_requirements/reqs.json\n- work/20_requirements/format_rules.json\n\n要求：\n- 只基于本地文件内容，不使用 Web。\n- reqs.json 用结构化字段：id/category/requirement/acceptance/source/priority。\n- format_rules.json 记录字体、标题级别、编号、图表编号、页眉页脚等约束（能从模板/招标提到的就写）。\n- 产出后在 work/20_requirements/README.md 简述抽取方法与注意事项（避免原文照抄，尽量转述）。\n\n约束：只写 work/20_requirements/ 下文件。\n",
        "plugins/tender/commands/init.md": "---\ndescription: Initialize tender workflow (folders + manifest + python tools)\nargument-hint: [projectName]\nallowed-tools: [Read, Write, Bash]\n---\n\n不要使用 Web。目标：初始化一个“可逐步落盘、可 Git 管理”的标书写作工作区，并写入 Python 执行工具（tools/tenderctl）。\n\n请严格按步骤执行；不要做额外推断；不要修改 work/ 以外的目录（除了 inputs/ 和 tools/）。\n\n## 0) 约束\n- 不使用 Web。\n- 只允许创建/修改：inputs/、work/、tools/tenderctl/ 下的文件。\n- work/00_manifest.yml 与 work/README.md：如果已存在 **不覆盖**（避免用户手改丢失）。\n- tools/tenderctl/requirements.txt 与 tools/tenderctl/tenderctl.py：**覆盖写入**（工具由插件统一管理）。\n\n## 1) 创建目录结构（缺什么补什么）\n创建以下目录（如已存在则跳过）：\n- inputs/\n- work/10_source_extracted/\n- work/20_requirements/\n- work/30_plan/\n- work/40_drafts/\n- work/50_figures/src/\n- work/50_figures/out/\n- work/60_build/\n- tools/tenderctl/\n\n## 2) 生成 work/00_manifest.yml（若不存在才创建）\n路径：work/00_manifest.yml\n\n字段至少包含（YAML）：\n- project_name: 取 $ARGUMENTS；若为空则用 \"TenderProject\"\n- tender_input_path: \"inputs/tender.pdf\"（也允许用户改为 inputs/tender.docx）\n- template_docx_path: \"inputs/template.docx\"\n- section_title: \"\"\n- target_words: 0\n- writing_scope: \"技术部分\"\n- no_web: true\n- version_tag: \"v1\"\n- body_placeholder: \"{{TECH_SECTION_BODY}}\"\n\n如果 work/00_manifest.yml 已存在：不覆盖，只提示“已存在，跳过”。\n\n## 3) 生成 work/README.md（若不存在才创建）\n路径：work/README.md\n\n要求：把下面模板 **原样写入**（不要改写措辞、不要增删条目）。  \n如果 work/README.md 已存在：不覆盖，只提示“已存在，跳过”。\n\n=== WORK_README_TEMPLATE BEGIN ===\n# Tender 工作流\n\n本项目使用 Claude 插件命令按步骤产出可落盘、可 Git 管理的标书技术章节。\n\n## 输入\n- inputs/tender.pdf（或 inputs/tender.docx）\n- inputs/template.docx（模板中预留占位符段落：{{TECH_SECTION_BODY}}）\n\n## 命令与产物\n\n### 1) /tender:init\n- 生成 work/ 目录结构\n- 生成 work/00_manifest.yml\n- 生成 tools/tenderctl/（Python 执行工具）\n\n### 2) /tender:extract\n产物：\n- work/10_source_extracted/tender.txt\n- work/10_source_extracted/template_styles.json\n- work/20_requirements/reqs.json\n- work/20_requirements/format_rules.json\n\n### 3) /tender:outline [章节名] [字数]\n产物：\n- work/30_plan/outline.md\n- work/30_plan/compliance_matrix.md\n\n### 4) /tender:draft\n产物：\n- work/40_drafts/v1.md\n\n### 5) /tender:review\n产物：\n- work/40_drafts/v1.similarity.json\n- work/40_drafts/v1.review.md\n\n### 6) /tender:build\n产物：\n- work/60_build/final.docx\n- work/60_build/build_log.md\n=== WORK_README_TEMPLATE END ===\n\n## 4) 写入 tools/tenderctl/requirements.txt（覆盖写入）\n路径：tools/tenderctl/requirements.txt\n\n内容 **原样写入**：\npython-docx>=1.1.0\nPyMuPDF>=1.24.0\nPyYAML>=6.0.0\n\n## 5) 写入 tools/tenderctl/tenderctl.py（覆盖写入）\n路径：tools/tenderctl/tenderctl.py\n\n要求：把下面代码块 **原样写入**（不要改缩进，不要改引号，不要省略任何行）：\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\ntenderctl: deterministic helpers for tender writing workflow\n- ingest: extract tender text (pdf/docx) + template style summary\n- similarity: compare draft markdown vs tender text, flag near-copies\n- build-docx: assemble markdown into template.docx at a placeholder\n\"\"\"\n\nfrom __future__ import annotations\nimport argparse\nimport json\nimport re\nimport sys\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport yaml\nfrom docx import Document\nfrom docx.shared import Inches\n\ntry:\n    import fitz  # PyMuPDF\nexcept Exception:\n    fitz = None\n\n\ndef read_manifest(manifest_path: Path) -> dict:\n    if not manifest_path.exists():\n        raise FileNotFoundError(f\"Missing manifest: {manifest_path}\")\n    return yaml.safe_load(manifest_path.read_text(encoding=\"utf-8\")) or {}\n\n\ndef ensure_parent(p: Path) -> None:\n    p.parent.mkdir(parents=True, exist_ok=True)\n\n\ndef write_text(p: Path, s: str) -> None:\n    ensure_parent(p)\n    p.write_text(s, encoding=\"utf-8\")\n\n\ndef write_json(p: Path, obj) -> None:\n    ensure_parent(p)\n    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding=\"utf-8\")\n\n\ndef normalize_ws(s: str) -> str:\n    s = s.replace(\"\\u00a0\", \" \")\n    s = re.sub(r\"[ \\t]+\", \" \", s)\n    s = re.sub(r\"\\n{3,}\", \"\\n\\n\", s)\n    return s.strip()\n\n\n# -------------------------\n# Ingest\n# -------------------------\n\ndef extract_text_from_pdf(pdf_path: Path) -> str:\n    if fitz is None:\n        raise RuntimeError(\"PyMuPDF not installed. pip install PyMuPDF\")\n    doc = fitz.open(str(pdf_path))\n    parts = []\n    for i in range(doc.page_count):\n        page = doc.load_page(i)\n        parts.append(page.get_text(\"text\"))\n    return normalize_ws(\"\\n\".join(parts))\n\n\ndef extract_text_from_docx(docx_path: Path) -> str:\n    doc = Document(str(docx_path))\n    parts = []\n    for p in doc.paragraphs:\n        t = p.text.strip()\n        if t:\n            parts.append(t)\n    # tables (simple)\n    for table in doc.tables:\n        for row in table.rows:\n            cells = [c.text.strip() for c in row.cells]\n            line = \"\\t\".join([c for c in cells if c])\n            if line:\n                parts.append(line)\n    return normalize_ws(\"\\n\".join(parts))\n\n\ndef summarize_template_styles(template_path: Path) -> dict:\n    doc = Document(str(template_path))\n    style_names = []\n    for s in doc.styles:\n        try:\n            style_names.append({\"name\": s.name, \"type\": str(s.type)})\n        except Exception:\n            continue\n    # shallow summary (extend later if needed)\n    return {\n        \"template\": str(template_path),\n        \"styles_count\": len(style_names),\n        \"styles\": style_names[:200],\n        \"note\": \"Shallow style list; build-docx maps to Heading 1/2/3, Normal, List Bullet/Number by default.\"\n    }\n\n\ndef cmd_ingest(args) -> int:\n    m = read_manifest(Path(args.manifest))\n    tender_path = Path(m.get(\"tender_input_path\", \"inputs/tender.pdf\"))\n    template_path = Path(m.get(\"template_docx_path\", \"inputs/template.docx\"))\n\n    out_dir = Path(\"work/10_source_extracted\")\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    if not tender_path.exists():\n        raise FileNotFoundError(f\"Missing tender input: {tender_path}\")\n    if not template_path.exists():\n        raise FileNotFoundError(f\"Missing template docx: {template_path}\")\n\n    if tender_path.suffix.lower() == \".pdf\":\n        tender_txt = extract_text_from_pdf(tender_path)\n    elif tender_path.suffix.lower() == \".docx\":\n        tender_txt = extract_text_from_docx(tender_path)\n    else:\n        raise ValueError(f\"Unsupported tender file type: {tender_path.suffix}\")\n\n    write_text(out_dir / \"tender.txt\", tender_txt)\n\n    style_summary = summarize_template_styles(template_path)\n    write_json(out_dir / \"template_styles.json\", style_summary)\n\n    print(f\"[OK] wrote: {out_dir/'tender.txt'}\")\n    print(f\"[OK] wrote: {out_dir/'template_styles.json'}\")\n    return 0\n\n\n# -------------------------\n# Similarity\n# -------------------------\n\ndef shingles(s: str, k: int = 10) -> set:\n    s = re.sub(r\"\\s+\", \" \", s).strip()\n    if len(s) <= k:\n        return {s} if s else set()\n    return {s[i:i+k] for i in range(0, len(s)-k+1)}\n\n\ndef jaccard(a: set, b: set) -> float:\n    if not a and not b:\n        return 0.0\n    inter = len(a & b)\n    union = len(a | b)\n    return inter / union if union else 0.0\n\n\ndef load_text(p: Path) -> str:\n    return p.read_text(encoding=\"utf-8\", errors=\"ignore\") if p.exists() else \"\"\n\n\ndef md_to_plain(md: str) -> str:\n    # remove code fences/images/links/markdown symbols (rough)\n    md = re.sub(r\"```.*?```\", \" \", md, flags=re.S)\n    md = re.sub(r\"!\\[.*?\\]\\(.*?\\)\", \" \", md)\n    md = re.sub(r\"\\[([^\\]]+)\\]\\([^)]+\\)\", r\"\\1\", md)\n    md = re.sub(r\"[#>*`_\\-]+\", \" \", md)\n    md = re.sub(r\"\\s+\", \" \", md)\n    return md.strip()\n\n\ndef cmd_similarity(args) -> int:\n    tender_txt = load_text(Path(args.tender_txt))\n    draft_md = load_text(Path(args.draft_md))\n\n    plain_tender = tender_txt\n    plain_draft = md_to_plain(draft_md)\n\n    k = int(args.k)\n    sim = jaccard(shingles(plain_tender, k=k), shingles(plain_draft, k=k))\n\n    window = int(args.window)\n    step = int(args.step)\n    suspect = []\n    for i in range(0, max(len(plain_draft) - window, 0), step):\n        seg = plain_draft[i:i+window]\n        ssim = jaccard(shingles(plain_tender, k=k), shingles(seg, k=k))\n        if ssim >= float(args.threshold):\n            suspect.append({\"offset\": i, \"preview\": seg[:120], \"score\": round(ssim, 4)})\n\n    report = {\n        \"k\": k,\n        \"overall_similarity\": round(sim, 4),\n        \"threshold\": float(args.threshold),\n        \"suspect_spans\": suspect[:50],\n        \"note\": \"Checks similarity against the tender text to avoid copying wording. Not an internet plagiarism detector.\"\n    }\n    write_json(Path(args.out_json), report)\n    print(f\"[OK] wrote: {args.out_json}\")\n    return 0\n\n\n# -------------------------\n# Build DOCX from Markdown into a template\n# -------------------------\n\n@dataclass\nclass MdBlock:\n    kind: str  # heading, para, bullet, number, image\n    level: int = 0\n    text: str = \"\"\n    path: str = \"\"\n    caption: str = \"\"\n\n\ndef parse_md(md: str) -> List[MdBlock]:\n    lines = md.splitlines()\n    blocks: List[MdBlock] = []\n    buf: List[str] = []\n\n    def flush_para():\n        nonlocal buf\n        txt = \"\\n\".join(buf).strip()\n        if txt:\n            blocks.append(MdBlock(kind=\"para\", text=txt))\n        buf = []\n\n    img_re = re.compile(r\"!\\[(.*?)\\]\\((.*?)\\)\")\n\n    for line in lines:\n        m = img_re.search(line.strip())\n        if m:\n            flush_para()\n            cap = m.group(1).strip()\n            pth = m.group(2).strip()\n            blocks.append(MdBlock(kind=\"image\", path=pth, caption=cap))\n            continue\n\n        if line.startswith(\"#\"):\n            flush_para()\n            m = re.match(r\"^(#+)\\s+(.*)$\", line)\n            if m:\n                level = len(m.group(1))\n                text = m.group(2).strip()\n                blocks.append(MdBlock(kind=\"heading\", level=level, text=text))\n            continue\n\n        if re.match(r\"^\\s*-\\s+.+\", line):\n            flush_para()\n            text = re.sub(r\"^\\s*-\\s+\", \"\", line).strip()\n            blocks.append(MdBlock(kind=\"bullet\", text=text))\n            continue\n\n        if re.match(r\"^\\s*\\d+\\.\\s+.+\", line):\n            flush_para()\n            text = re.sub(r\"^\\s*\\d+\\.\\s+\", \"\", line).strip()\n            blocks.append(MdBlock(kind=\"number\", text=text))\n            continue\n\n        if not line.strip():\n            flush_para()\n            continue\n\n        buf.append(line)\n\n    flush_para()\n    return blocks\n\n\ndef find_placeholder_paragraph(doc: Document, placeholder: str):\n    for idx, p in enumerate(doc.paragraphs):\n        if placeholder in p.text:\n            return idx, p\n    return None, None\n\n\ndef insert_blocks_at(doc: Document, insert_index: int, blocks: List[MdBlock], figures_base: Optional[Path] = None):\n    anchor_p = doc.paragraphs[insert_index]\n    anchor_elm = anchor_p._p  # noqa\n\n    def add_para_with_style(text: str, style: str):\n        p = doc.add_paragraph(text)\n        try:\n            p.style = style\n        except Exception:\n            pass\n        anchor_elm.addprevious(p._p)  # move before anchor\n\n    fig_no = 1\n    for b in blocks:\n        if b.kind == \"heading\":\n            if b.level <= 1:\n                style = \"Heading 1\"\n            elif b.level == 2:\n                style = \"Heading 2\"\n            else:\n                style = \"Heading 3\"\n            add_para_with_style(b.text, style)\n\n        elif b.kind == \"para\":\n            add_para_with_style(b.text, \"Normal\")\n\n        elif b.kind == \"bullet\":\n            add_para_with_style(b.text, \"List Bullet\")\n\n        elif b.kind == \"number\":\n            add_para_with_style(b.text, \"List Number\")\n\n        elif b.kind == \"image\":\n            p = doc.add_paragraph(\"\")\n            anchor_elm.addprevious(p._p)\n            img_path = Path(b.path)\n            if figures_base and not img_path.is_absolute():\n                cand = figures_base / img_path\n                if cand.exists():\n                    img_path = cand\n            if img_path.exists():\n                run = p.add_run()\n                try:\n                    run.add_picture(str(img_path), width=Inches(6.5))\n                except Exception:\n                    run.add_picture(str(img_path))\n\n            cap = b.caption or img_path.stem\n            cap_text = f\"图{fig_no}  {cap}\"\n            fig_no += 1\n            add_para_with_style(cap_text, \"Caption\")\n\n\ndef remove_paragraph(p):\n    p._element.getparent().remove(p._element)\n    p._p = p._element = None\n\n\ndef cmd_build_docx(args) -> int:\n    m = read_manifest(Path(args.manifest))\n    template_path = Path(m.get(\"template_docx_path\", \"inputs/template.docx\"))\n    placeholder = m.get(\"body_placeholder\", \"{{TECH_SECTION_BODY}}\")\n    figures_out = Path(\"work/50_figures/out\")\n\n    draft_md_path = Path(args.draft_md)\n    if not template_path.exists():\n        raise FileNotFoundError(f\"Missing template docx: {template_path}\")\n    if not draft_md_path.exists():\n        raise FileNotFoundError(f\"Missing draft md: {draft_md_path}\")\n\n    doc = Document(str(template_path))\n    md = draft_md_path.read_text(encoding=\"utf-8\")\n    blocks = parse_md(md)\n\n    idx, p = find_placeholder_paragraph(doc, placeholder)\n    if p is None:\n        print(f\"[WARN] placeholder '{placeholder}' not found in template. Appending at end.\")\n        insert_index = len(doc.paragraphs) - 1 if doc.paragraphs else 0\n        insert_blocks_at(doc, insert_index, blocks, figures_base=figures_out)\n    else:\n        insert_blocks_at(doc, idx, blocks, figures_base=figures_out)\n        remove_paragraph(p)\n\n    out_path = Path(args.out_docx)\n    ensure_parent(out_path)\n    doc.save(str(out_path))\n    print(f\"[OK] wrote: {out_path}\")\n    return 0\n\n\n# -------------------------\n# CLI\n# -------------------------\n\ndef main(argv: List[str]) -> int:\n    ap = argparse.ArgumentParser(prog=\"tenderctl\")\n    sub = ap.add_subparsers(dest=\"cmd\", required=True)\n\n    sp = sub.add_parser(\"ingest\", help=\"Extract tender text and template style summary\")\n    sp.add_argument(\"--manifest\", default=\"work/00_manifest.yml\")\n    sp.set_defaults(func=cmd_ingest)\n\n    sp = sub.add_parser(\"similarity\", help=\"Similarity check draft md vs tender text\")\n    sp.add_argument(\"--tender-txt\", default=\"work/10_source_extracted/tender.txt\")\n    sp.add_argument(\"--draft-md\", default=\"work/40_drafts/v1.md\")\n    sp.add_argument(\"--out-json\", default=\"work/40_drafts/v1.similarity.json\")\n    sp.add_argument(\"--k\", default=\"10\")\n    sp.add_argument(\"--window\", default=\"400\")\n    sp.add_argument(\"--step\", default=\"80\")\n    sp.add_argument(\"--threshold\", default=\"0.15\")\n    sp.set_defaults(func=cmd_similarity)\n\n    sp = sub.add_parser(\"build-docx\", help=\"Assemble final.docx from template + markdown\")\n    sp.add_argument(\"--manifest\", default=\"work/00_manifest.yml\")\n    sp.add_argument(\"--draft-md\", default=\"work/40_drafts/v1.md\")\n    sp.add_argument(\"--out-docx\", default=\"work/60_build/final.docx\")\n    sp.set_defaults(func=cmd_build_docx)\n\n    args = ap.parse_args(argv)\n    return args.func(args)\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main(sys.argv[1:]))\n",
        "plugins/tender/commands/outline.md": "---\ndescription: Generate outline.md + compliance_matrix.md from manifest sections (schema-driven, no hardcoded chapter IDs)\nargument-hint: [targetWordsOptional]\nallowed-tools: [Read, Write]\n---\n\n不要使用 Web。\n\n你将根据：\n- work/20_requirements/reqs.json\n- work/00_manifest.yml（以其中的 sections 树为准）\n\n生成并写入：\n- work/30_plan/outline.md（严格标题层级：# ## ###；不得出现 #### 及更深层级）\n- work/30_plan/compliance_matrix.md（REQ-ID -> 覆盖到哪一节）\n并更新：\n- work/00_manifest.yml 中的 target_words（若用户传参则覆盖；否则保留现值）\n- work/00_manifest.yml 中的 planning_completed: true\n\n## 0) 参数规则\n- 用户参数 $ARGUMENTS 只用于可选的 targetWords（一个整数）。\n- 不要再要求/依赖 sectionTitle 参数；要写哪些章节，以 manifest.sections 为准。\n\n## 1) 大纲生成规则（通用）\n1) 必须遍历 manifest.sections 的整棵树，按 id 顺序生成大纲，不得只生成其中一个章节。\n2) 大纲标题格式：\n   - 一级：`# <id> <title>`\n   - 二级：`## <id> <title>`\n   - 三级：`### <id> <title>`\n   只允许到 ###（三级）。\n3) 如果 manifest 中存在四级及更深层级节点（例如 2.7.4.1.5.1.1.1）：\n   - 不得输出 ####\n   - 只能在对应 ### 节下，用正文条目列出该层级的“写作结构/要点/占位”（例如项目符号列出“功能概述/输入输出设计”等）。\n4) 每一节必须给出建议字数范围（例如“建议 800~1200 字”），并确保总和可覆盖 target_words。\n\n## 2) kind=subsystem 的通用处理（不依赖具体章节号）\n当某个章节节点包含 `kind: subsystem` 时：\n- 该节点视为“子系统实例”，需要产出清晰、可写满字数的子系统大纲结构。\n- 如果该节点在 manifest 中已经提供了 subsections：按 subsections 结构生成（不做猜测）。\n- 如果该节点未提供 subsections：\n  - 在该子系统章节下，至少生成以下标准子节（作为占位结构，便于后续填充）：\n    - 系统概述\n    - 系统组成\n    - 业务流程\n    - 接口设计（内部接口、外部接口）\n    - 功能设计（按模块）\n  - 注意：这些只是“结构占位”，不要编造具体模块名或接口清单。\n- 若该节点包含 `design_status: \"TBD\"`：\n  - 在 outline 对应部分标注“待设计稿/模块清单补齐后回填”\n  - 不得凭空编造模块/功能点/接口字段等具体内容\n\n## 3) 功能设计按模块（通用，不绑定章节号）\n如果 manifest 中存在 functional_design 字段：\n- 对任何章节节点：若其 id 等于 functional_design.root_id：\n  - 其大纲必须包含“模块化写作规则说明”，明确：\n    - 模块/功能点来源：functional_design.catalog_path 指定的 yml 文件\n    - 每个功能点固定子标题：functional_design.feature_children（例如：功能概述、输入输出设计）\n  - 不得把模板示例当成真实模块内容写入大纲\n  - 若 catalog_path 文件不存在或 modules 为空：在大纲中提示“需要补充模块清单后回填”，不要编造\n\n## 4) 覆盖矩阵规则（compliance_matrix.md）\n- 读取 reqs.json，矩阵必须覆盖所有 MUST/SHOULD（逐条列出，不得漏项）。\n- 每条 REQ-ID 映射到 outline 中的具体章节 id（优先映射到最具体的 id）。\n- 若某条需求当前只能“待设计补齐”（例如 design_status:TBD 的子系统组成/功能），矩阵中也必须标注：\n  - Covered Section(ID)\n  - Coverage Status: TBD\n  - Notes：需要哪个产物补齐（例如模块清单 yml/设计简稿）\n\n## 5) 禁止事项\n- 不使用 Web。\n- 不引用招标原文句子，必须转述。\n- 不得生成与 manifest.sections 无关的章节。\n\n## 6) 输出文件格式要求\n- outline.md：按章节顺序输出；每节最后用一行写“建议字数：X~Y 字”。\n- compliance_matrix.md：用表格，至少包含列：\n  - REQ-ID | Priority | Requirement(转述) | Covered Section(ID) | Coverage Status(OK/TBD) | Notes\n\n用户参数：$ARGUMENTS\n",
        "plugins/tender/commands/review.md": "---\ndescription: Review draft progress (word count, coverage gaps, TBD items) for incremental writing\nargument-hint: (no args)\nallowed-tools: [Read, Write]\n---\n\n不要使用 Web。\n\n目标：对增量写作产物进行检查与汇总，输出 review 报告与统计数据。\n\n输入：\n- work/00_manifest.yml\n- work/20_requirements/reqs.json\n- work/30_plan/outline.md\n- work/30_plan/compliance_matrix.md（若存在）\n- work/40_drafts/v1.md（若存在）\n- work/40_drafts/v1_sections/（若存在，优先）\n- work/40_drafts/v1.similarity.json（若存在，读取并汇总）\n\n输出（只写 work/40_drafts/）：\n- work/40_drafts/v1.review.md\n- work/40_drafts/v1.stats.json\n并更新 work/00_manifest.yml：\n- drafted_words（用本次统计值覆盖）\n- drafting_completed（若 drafted_words >= target_words*0.9 且无重大缺口，则置 true；否则 false）\n\n## 1) 字数统计规则（必须）\n- 优先统计 work/40_drafts/v1_sections/ 下所有 *.md 文件：\n  - 如果文件末尾存在 `<!-- words: N -->`，以 N 作为该节字数\n  - 否则用“纯文本字符数（去掉 markdown 符号与空白）”作为粗略字数估计\n- 若 v1_sections 不存在，则退化为统计 work/40_drafts/v1.md\n- 输出：\n  - 总字数 drafted_words\n  - 与 target_words 的差距（差多少，比例多少）\n  - TOP 10 最长小节、TOP 10 最短小节（按 id）\n\n## 2) 章节完成度（必须）\n- 读取 outline.md 中的所有 ### 小节，逐个判断：\n  - 若 v1_sections/<id>.md 存在：已完成\n  - 若不存在：未完成\n- 输出“未完成小节清单”（按 id 排序），并给出建议下一次 /tender:draft 应优先写哪些（优先：MUST 覆盖相关章节、以及字数缺口最大的部分）。\n\n## 3) TBD 与占位检查（必须）\n- 在现有草稿中搜索明显占位标记（例如 “待补齐”“TBD”“占位”“待回填”“需要补充模块清单”等）\n- 输出占位清单：包含章节 id、占位句子摘录（不超过 1-2 句）、建议补齐所需产物（例如 modules_yml / design_brief）\n- 若 manifest 中存在 design_status: \"TBD\" 的节点：必须在报告中单列这些节点，并提示它们目前应保持“高层设计+占位”，不得强行细化编造。\n\n## 4) 覆盖度检查（必须）\n- 以 reqs.json 为准，列出所有 MUST/SHOULD（逐条）。\n- 若 compliance_matrix.md 存在：\n  - 读取矩阵中 REQ-ID -> Covered Section(ID) 的映射（按表格解析，尽量鲁棒）\n  - 对每条 REQ-ID：\n    - 若映射的章节 id 已完成：Coverage=OK\n    - 若映射章节未完成或为 TBD 占位：Coverage=TBD\n    - 若矩阵中不存在该 REQ-ID：Coverage=Missing\n- 若 compliance_matrix.md 不存在：\n  - 在 v1.md / v1_sections 中按关键词粗略检索（仅作为弱提示），并将 Coverage 标为 “Unknown（no matrix）”\n- 输出覆盖汇总表：\n  - REQ-ID | Priority | Covered Section(ID) | Coverage Status(OK/TBD/Missing/Unknown) | Notes\n\n## 5) 相似度检查（可选）\n- 若 work/40_drafts/v1.similarity.json 存在：在报告中汇总 overall_similarity、suspect_spans 数量与最高分片段（预览不超过 120 字）。\n- 若不存在：在报告中提示可运行 tenderctl similarity 生成（仅提示，不要执行）。\n\n## 6) 写入输出\n- 写 work/40_drafts/v1.stats.json：包含 drafted_words、target_words、gap、per_section_word_counts（可只存已完成小节的 id->words）、missing_sections、tbd_sections、coverage_summary_counts。\n- 写 work/40_drafts/v1.review.md：用清晰的小标题输出：\n  1) 字数进度\n  2) 章节完成度\n  3) TBD/占位清单\n  4) 覆盖度（MUST/SHOULD）\n  5) 相似度（若有）\n  6) 下一步建议（给出 3~7 条具体可执行建议，例如“下一次 draft 优先写：2.7.3.6、2.7.3.8 …”）\n\n开始执行。\n"
      },
      "plugins": [
        {
          "name": "tender",
          "source": "./plugins/tender",
          "description": "Tender writing workflow: init/extract/outline/draft/review/build",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add lhybdv/fengyun-claude-marketplace",
            "/plugin install tender@fengyun-claude-marketplace"
          ]
        }
      ]
    }
  ]
}