{
  "author": {
    "id": "jellydn",
    "display_name": "Dung Duc Huynh (Kaka)",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/870029?u=cc065539910207b6661bbabba39a9e78294e251d&v=4",
    "url": "https://github.com/jellydn",
    "bio": "ðŸ“š Lifelong Learner \r\n#LearnInPublic #BuildInPublic #ITMan",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 10,
      "total_commands": 0,
      "total_skills": 10,
      "total_stars": 15,
      "total_forks": 4
    }
  },
  "marketplaces": [
    {
      "name": "my-ai-tools",
      "version": null,
      "description": "Marketplace for my-ai-tools plugins",
      "owner_info": {
        "name": "my-ai-tools",
        "email": "dung@productsway.com"
      },
      "keywords": [],
      "repo_full_name": "jellydn/my-ai-tools",
      "repo_url": "https://github.com/jellydn/my-ai-tools",
      "repo_description": "      Comprehensive configuration management for AI coding tools - Replicate my complete setup for Claude Code, OpenCode, Amp, Codex and CCS with custom configurations, MCP servers, plugins, and commands.",
      "homepage": "http://ai-tools.itman.fyi/",
      "signals": {
        "stars": 15,
        "forks": 4,
        "pushed_at": "2026-01-29T14:18:21Z",
        "created_at": "2026-01-08T23:37:20Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 4228
        },
        {
          "path": ".claude-plugin/plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/adr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/adr/SKILL.md",
          "type": "blob",
          "size": 2338
        },
        {
          "path": ".claude-plugin/plugins/adr/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/adr/templates/adr-template.md",
          "type": "blob",
          "size": 355
        },
        {
          "path": ".claude-plugin/plugins/codemap",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/codemap/SKILL.md",
          "type": "blob",
          "size": 8874
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates/ARCHITECTURE.md.template",
          "type": "blob",
          "size": 963
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates/CONCERNS.md.template",
          "type": "blob",
          "size": 1466
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates/CONVENTIONS.md.template",
          "type": "blob",
          "size": 888
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates/INTEGRATIONS.md.template",
          "type": "blob",
          "size": 934
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates/STACK.md.template",
          "type": "blob",
          "size": 835
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates/STRUCTURE.md.template",
          "type": "blob",
          "size": 939
        },
        {
          "path": ".claude-plugin/plugins/codemap/templates/TESTING.md.template",
          "type": "blob",
          "size": 1341
        },
        {
          "path": ".claude-plugin/plugins/handoffs",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/handoffs/SKILL.md",
          "type": "blob",
          "size": 5309
        },
        {
          "path": ".claude-plugin/plugins/pickup",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/pickup/SKILL.md",
          "type": "blob",
          "size": 920
        },
        {
          "path": ".claude-plugin/plugins/pr-review",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/pr-review/SKILL.md",
          "type": "blob",
          "size": 3382
        },
        {
          "path": ".claude-plugin/plugins/pr-review/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/pr-review/scripts/extract-pr-comments.js",
          "type": "blob",
          "size": 10759
        },
        {
          "path": ".claude-plugin/plugins/prd",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/prd/SKILL.md",
          "type": "blob",
          "size": 7366
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/SKILL.md",
          "type": "blob",
          "size": 7753
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/references/issues",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/references/issues/README.md",
          "type": "blob",
          "size": 535
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/references/learnings",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/references/learnings/README.md",
          "type": "blob",
          "size": 799
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/qmd-knowledge/scripts/record.sh",
          "type": "blob",
          "size": 9525
        },
        {
          "path": ".claude-plugin/plugins/ralph",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/ralph/SKILL.md",
          "type": "blob",
          "size": 7682
        },
        {
          "path": ".claude-plugin/plugins/slop",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/slop/SKILL.md",
          "type": "blob",
          "size": 4265
        },
        {
          "path": ".claude-plugin/plugins/tdd",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/tdd/SKILL.md",
          "type": "blob",
          "size": 3148
        },
        {
          "path": ".claude-plugin/plugins/tdd/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/tdd/templates/test-template.md",
          "type": "blob",
          "size": 473
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n\t\"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n\t\"name\": \"my-ai-tools\",\n\t\"description\": \"Marketplace for my-ai-tools plugins\",\n\t\"owner\": {\n\t\t\"name\": \"my-ai-tools\",\n\t\t\"email\": \"dung@productsway.com\"\n\t},\n\t\"plugins\": [\n\t\t{\n\t\t\t\"name\": \"prd\",\n\t\t\t\"description\": \"Generate Product Requirements Documents (PRD) for new features. Use when planning features, starting projects, or creating specifications.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/prd\",\n\t\t\t\"category\": \"productivity\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"ralph\",\n\t\t\t\"description\": \"Convert PRDs to prd.json format for the Ralph autonomous agent system. Converts markdown PRDs to Ralph's JSON format.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/ralph\",\n\t\t\t\"category\": \"productivity\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"qmd-knowledge\",\n\t\t\t\"description\": \"Project-specific knowledge management system using qmd MCP server. Captures learnings, issue notes, and conventions in a searchable knowledge base.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/qmd-knowledge\",\n\t\t\t\"category\": \"productivity\",\n\t\t\t\"homepage\": \"https://github.com/jellydn/my-ai-tools\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"codemap\",\n\t\t\t\"description\": \"Orchestrate parallel codebase analysis to produce 7 structured documents (STACK, INTEGRATIONS, ARCHITECTURE, STRUCTURE, CONVENTIONS, TESTING, CONCERNS) in .planning/codebase/.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/codemap\",\n\t\t\t\"category\": \"productivity\",\n\t\t\t\"homepage\": \"https://github.com/jellydn/my-ai-tools\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"adr\",\n\t\t\t\"description\": \"Manages Architecture Decision Records (ADR) for tracking important architectural decisions. Initialize, create, list, search, and view ADRs.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/adr\",\n\t\t\t\"category\": \"productivity\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"handoffs\",\n\t\t\t\"description\": \"Creates detailed handoff plans of conversations for continuing work in new sessions. Capture context, technical decisions, and pending tasks for seamless session continuation.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/handoffs\",\n\t\t\t\"category\": \"productivity\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"pickup\",\n\t\t\t\"description\": \"Resumes work from a previous handoff session stored in .claude/handoffs/. Load and continue from where you left off in prior sessions.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/pickup\",\n\t\t\t\"category\": \"productivity\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"pr-review\",\n\t\t\t\"description\": \"Fix PR review comments by implementing requested changes. Fetch review comments, implement fixes, run tests, and commit changes.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/pr-review\",\n\t\t\t\"category\": \"productivity\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"slop\",\n\t\t\t\"description\": \"Removes AI-generated code slop from git diffs to maintain code quality. Clean up extra comments, defensive checks, type casts, and inconsistent style.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/slop\",\n\t\t\t\"category\": \"productivity\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"tdd\",\n\t\t\t\"description\": \"Guides through the complete TDD workflow with Red-Green-Refactor cycle. Start features, write failing tests, implement minimal code, and refactor with confidence.\",\n\t\t\t\"version\": \"1.0.0\",\n\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dung Huynh Duc\",\n\t\t\t\t\"email\": \"dung@productsway.com\"\n\t\t\t},\n\t\t\t\"source\": \"./.claude-plugin/plugins/tdd\",\n\t\t\t\"category\": \"productivity\"\n\t\t}\n\t]\n}",
        ".claude-plugin/plugins/adr/SKILL.md": "---\nname: adr\ndescription: Manages Architecture Decision Records (ADR) for tracking important architectural decisions\nlicense: MIT\ncompatibility: claude, opencode, amp, codex, gemini\nhint: Use when managing architecture decisions, creating ADRs, or tracking architectural choices\nmetadata:\n  audience: all\n  workflow: documentation\n---\n\n# Architecture Decision Records (ADR)\n\nProvides a unified interface for managing Architecture Decision Records.\n\n## Usage\n\n`/adr <ACTION> [ARGUMENTS]`\n\n## Actions\n\n- **init [DIRECTORY]** - Initialize ADR directory structure\n- **new <TITLE>** - Create new ADR with given title\n- **supersede <NUMBER> <TITLE>** - Create ADR that supersedes existing one\n- **list** - List all ADRs in the project\n- **search <TERM>** - Search ADRs by content\n- **view <NUMBER>** - View specific ADR\n- **help** - Show this help\n\n## What are ADRs?\n\nArchitecture Decision Records (ADRs) are short documents that capture important architectural decisions made during project development. They help teams:\n\n- Record the context and reasoning behind decisions\n- Track the evolution of architectural choices\n- Onboard new team members\n- Avoid revisiting already-settled decisions\n\n## ADR Structure\n\nEach ADR typically contains:\n- **Title**: Brief description of the decision\n- **Status**: Proposed, Accepted, Deprecated, Superseded\n- **Context**: The situation requiring a decision\n- **Decision**: The chosen solution\n- **Consequences**: Positive and negative outcomes\n\n## ADR Template\n\nA template is available at `$SKILL_PATH/templates/adr-template.md`:\n\n```markdown\n# [NUMBER]. [TITLE]\n\nDate: [DATE]\n\n## Status\n\n[Proposed | Accepted | Deprecated | Superseded by [ADR-NUMBER]]\n\n## Context\n\n[Describe the context and problem statement]\n\n## Decision\n\n[Describe the decision and solution]\n\n## Consequences\n\n### Positive\n- [Positive outcome 1]\n- [Positive outcome 2]\n\n### Negative\n- [Negative outcome 1]\n- [Risk or trade-off]\n```\n\n## ADR Directory Detection\n\nCommon ADR locations to check:\n- `doc/adr/` (default)\n- `docs/adr/`\n- `docs/architecture/decisions/`\n- `architecture/decisions/`\n\n## Process Examples\n\n### Create new ADR:\n```bash\n/adr new \"Use PostgreSQL for primary database\"\n```\n\n### List all ADRs:\n```bash\n/adr list\n```\n\n### Search ADRs:\n```bash\n/adr search \"database\"\n```\n\n### View specific ADR:\n```bash\n/adr view 5\n```\n",
        ".claude-plugin/plugins/adr/templates/adr-template.md": "# [NUMBER]. [TITLE]\n\nDate: [DATE]\n\n## Status\n\n[Proposed | Accepted | Deprecated | Superseded by [ADR-NUMBER]]\n\n## Context\n\n[Describe the context and problem statement]\n\n## Decision\n\n[Describe the decision and solution]\n\n## Consequences\n\n### Positive\n- [Positive outcome 1]\n- [Positive outcome 2]\n\n### Negative\n- [Negative outcome 1]\n- [Risk or trade-off]\n",
        ".claude-plugin/plugins/codemap/SKILL.md": "---\nname: codemap\ndescription: Orchestrate parallel codebase analysis to produce 7 structured documents about the codebase in .planning/codebase/\nlicense: MIT\ncompatibility: opencode, claude, amp, codex, gemini\nhint: Use when mapping codebase structure, documenting architecture, or onboarding to a project\nmetadata:\n  audience: all\n  workflow: codebase-mapping\n---\n\n## What I do\n\nAnalyze your entire codebase and create 7 comprehensive documentation files in `.planning/codebase/`:\n\n- **STACK.md** - Technologies, dependencies, configuration\n- **INTEGRATIONS.md** - 3rd party providers, APIs, databases, auth providers\n- **ARCHITECTURE.md** - System patterns, layers, data flow\n- **STRUCTURE.md** - Directory layout, key locations, naming conventions\n- **CONVENTIONS.md** - Code style, patterns, error handling\n- **TESTING.md** - Framework, structure, mocking, coverage\n- **CONCERNS.md** - Tech debt, bugs, security, performance issues\n\n## When to use me\n\nUse this skill when you need to:\n\n- **Onboard** new developers to understand the codebase quickly\n- **Plan** new features with full context of existing patterns\n- **Understand** code conventions before making changes\n- **Identify** technical debt and areas of concern\n- **Document** the current state of the project\n\n## How it works\n\nThis skill orchestrates 4 parallel agents, each exploring a specific focus area:\n\n1. **Tech Agent** â†’ Analyzes stack and integrations â†’ STACK.md, INTEGRATIONS.md\n2. **Architecture Agent** â†’ Analyzes patterns and structure â†’ ARCHITECTURE.md, STRUCTURE.md\n3. **Quality Agent** â†’ Analyzes conventions and testing â†’ CONVENTIONS.md, TESTING.md\n4. **Concerns Agent** â†’ Identifies tech debt and issues â†’ CONCERNS.md\n\nEach agent:\n- Explores the codebase in a fresh context\n- Uses templates from `$SKILL_PATH/templates/`\n- Writes documents directly to `.planning/codebase/`\n- Returns only confirmation (not document contents)\n\nThe orchestrator:\n- Creates `.planning/codebase/` directory\n- Spawns 4 parallel agents with `run_in_background=true`\n- Collects confirmations\n- Verifies all documents created\n- Commits the codebase map (if configured)\n\n## Process\n\n### Step 1: Check Existing Map\n\nIf `.planning/codebase/` already exists, prompt:\n```\n.planning/codebase/ already exists. What's next?\n1. Refresh - Delete existing and remap codebase\n2. Update - Keep existing, only update specific documents\n3. Skip - Use existing codebase map as-is\n```\n\n### Step 2: Create Structure\n\nCreate the output directory:\n```bash\nmkdir -p .planning/codebase\n```\n\n### Step 3: Spawn Parallel Agents\n\nUse the `Task` tool with `agent_type=\"explore\"` and `run_in_background=true` for parallel execution.\n\n**Tech Agent:**\n```\nagent_type: explore\ndescription: Map codebase tech stack\nprompt: |\n\tFocus: tech\n\n\tAnalyze this codebase for technology stack and external integrations.\n\n\tWrite these documents to .planning/codebase/:\n\t- STACK.md - Languages, runtime, frameworks, dependencies, configuration\n\t- INTEGRATIONS.md - External APIs, databases, auth providers, webhooks\n\n\tUse the templates from map-codebase skill. Explore thoroughly.\n\tWrite documents directly. Return confirmation only.\n```\n\n**Architecture Agent:**\n```\nagent_type: explore\ndescription: Map codebase architecture\nprompt: |\n\tFocus: arch\n\n\tAnalyze this codebase architecture and directory structure.\n\n\tWrite these documents to .planning/codebase/:\n\t- ARCHITECTURE.md - Pattern, layers, data flow, abstractions, entry points\n\t- STRUCTURE.md - Directory layout, key locations, naming conventions\n\n\tUse the templates from map-codebase skill. Explore thoroughly.\n\tWrite documents directly. Return confirmation only.\n```\n\n**Quality Agent:**\n```\nagent_type: explore\ndescription: Map codebase conventions\nprompt: |\n\tFocus: quality\n\n\tAnalyze this codebase for coding conventions and testing patterns.\n\n\tWrite these documents to .planning/codebase/:\n\t- CONVENTIONS.md - Code style, naming, patterns, error handling\n\t- TESTING.md - Framework, structure, mocking, coverage\n\n\tUse the templates from map-codebase skill. Explore thoroughly.\n\tWrite documents directly. Return confirmation only.\n```\n\n**Concerns Agent:**\n```\nagent_type: explore\ndescription: Map codebase concerns\nprompt: |\n\tFocus: concerns\n\n\tAnalyze this codebase for technical debt, known issues, and areas of concern.\n\n\tWrite this document to .planning/codebase/:\n\t- CONCERNS.md - Tech debt, bugs, security, performance, fragile areas\n\n\tUse the templates from map-codebase skill. Explore thoroughly.\n\tWrite document directly. Return confirmation only.\n```\n\n### Step 4: Verify Output\n\nCheck that all documents were created:\n```bash\nls -la .planning/codebase/\nwc -l .planning/codebase/*.md\n```\n\n### Step 5: Commit (Optional)\n\nIf `.planning/` is not gitignored and the user wants to commit:\n```bash\ngit add .planning/codebase/*.md\ngit commit -m \"docs: map existing codebase\n\n- STACK.md - Technologies and dependencies\n- ARCHITECTURE.md - System design and patterns\n- STRUCTURE.md - Directory layout\n- CONVENTIONS.md - Code style and patterns\n- TESTING.md - Test structure\n- INTEGRATIONS.md - External services\n- CONCERNS.md - Technical debt and issues\"\n```\n\n### Step 6: Summary\n\nPresent completion summary:\n```\nCodebase mapping complete.\n\nCreated .planning/codebase/:\n- STACK.md ([N] lines) - Technologies and dependencies\n- ARCHITECTURE.md ([N] lines) - System design and patterns\n- STRUCTURE.md ([N] lines) - Directory layout and organization\n- CONVENTIONS.md ([N] lines) - Code style and patterns\n- TESTING.md ([N] lines) - Test structure and practices\n- INTEGRATIONS.md ([N] lines) - External services and APIs\n- CONCERNS.md ([N] lines) - Technical debt and issues\n\nNext steps:\n- Review documents: cat .planning/codebase/STACK.md\n- Use these as reference when planning features\n- Update as codebase evolves\n```\n\n## Templates\n\nTemplates are located in `$SKILL_PATH/templates/`:\n\n- `STACK.md.template` - Technology stack\n- `INTEGRATIONS.md.template` - External integrations\n- `ARCHITECTURE.md.template` - System architecture\n- `STRUCTURE.md.template` - Directory structure\n- `CONVENTIONS.md.template` - Coding conventions\n- `TESTING.md.template` - Testing patterns\n- `CONCERNS.md.template` - Technical concerns\n\nEach agent reads the appropriate template and fills it in based on codebase exploration.\n\n## Agent Guidelines\n\nWhen spawned as a mapper agent:\n\n### Exploration Commands\n\n**Helper: Use fd if available, fall back to find**\n```bash\n# Define finder helper (fd if available, otherwise find)\n_finder() { command -v fd >/dev/null 2>&1 && fd \"$@\" || find \"$@\"; }\n_rg() { command -v rg >/dev/null 2>&1 && rg \"$@\" || grep -r \"$@\"; }\n```\n\n**Tech Focus:**\n```bash\n# Package manifests\ncat package.json pyproject.toml Cargo.toml go.mod 2>/dev/null\n\n# Config files\nls -la *.config.* .env* tsconfig.json 2>/dev/null\n\n# Find SDK/API imports\n_rg \"import.*stripe|import.*supabase|import.*aws\" src/ 2>/dev/null | head -50\n```\n\n**Architecture Focus:**\n```bash\n# Directory structure (fd is faster and ignores node_modules/.git by default)\n_finder -t d . | head -50\n\n# Entry points\n_finder -t f \"index.*\" \"main.*\" \"app.*\" src/ app/ 2>/dev/null | head -20\n\n# Import patterns\n_rg \"^import\" src/ 2>/dev/null | head -100\n```\n\n**Quality Focus:**\n```bash\n# Linting/formatting config\ncat .eslintrc* .prettierrc* biome.json 2>/dev/null\n\n# Test files\n_finder -t f \"\\.test\\.\" \"\\.spec\\.\" 2>/dev/null | head -30\n```\n\n**Concerns Focus:**\n```bash\n# TODO/FIXME comments\n_rg \"TODO|FIXME|HACK|XXX\" src/ 2>/dev/null | head -50\n\n# Large files (potential complexity)\n_finder -t f \"\\.ts$\" -e \"\\.tsx$\" src/ 2>/dev/null | xargs wc -l 2>/dev/null | sort -rn | head -20\n```\n\n### Critical Rules\n\n1. **Write documents directly** - Use the Write tool, don't return contents\n2. **Always include file paths** - Every finding needs a file path in backticks\n3. **Use the templates** - Fill in the template structure exactly\n4. **Be thorough** - Read actual files, don't guess\n5. **Return only confirmation** - Response should be ~10 lines with file paths and line counts\n6. **Don't commit** - The orchestrator handles git operations\n\n## Benefits\n\n- **Fast**: Parallel exploration reduces total time\n- **Fresh context**: Each agent starts clean, no token contamination\n- **Minimal context transfer**: Agents write directly, orchestrator only receives confirmations\n- **Comprehensive**: 7 structured documents cover all aspects of the codebase\n- **Reusable**: Documents serve as reference for future planning and development\n\n## Inspiration\n\nThis skill is inspired by and adapted from [glittercowboy/get-shit-done](https://github.com/glittercowboy/get-shit-done), specifically their [map-codebase workflow](https://github.com/glittercowboy/get-shit-done/blob/main/get-shit-done/workflows/map-codebase.md) and [gsd-codebase-mapper agent](https://github.com/glittercowboy/get-shit-done/blob/main/agents/gsd-codebase-mapper.md).\n",
        ".claude-plugin/plugins/codemap/templates/ARCHITECTURE.md.template": "# Architecture\n\n**Analysis Date:** [YYYY-MM-DD]\n\n## Pattern Overview\n\n**Overall:** [Pattern name]\n\n**Key Characteristics:**\n- [Characteristic 1]\n- [Characteristic 2]\n- [Characteristic 3]\n\n## Layers\n\n**[Layer Name]:**\n- Purpose: [What this layer does]\n- Location: `[path]`\n- Contains: [Types of code]\n- Depends on: [What it uses]\n- Used by: [What uses it]\n\n## Data Flow\n\n**[Flow Name]:**\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n\n**State Management:**\n- [How state is handled]\n\n## Key Abstractions\n\n**[Abstraction Name]:**\n- Purpose: [What it represents]\n- Examples: `[file paths]`\n- Pattern: [Pattern used]\n\n## Entry Points\n\n**[Entry Point]:**\n- Location: `[path]`\n- Triggers: [What invokes it]\n- Responsibilities: [What it does]\n\n## Error Handling\n\n**Strategy:** [Approach]\n\n**Patterns:**\n- [Pattern 1]\n- [Pattern 2]\n\n## Cross-Cutting Concerns\n\n**Logging:** [Approach]\n\n**Validation:** [Approach]\n\n**Authentication:** [Approach]\n\n---\n\n*Architecture analysis: [date]*\n",
        ".claude-plugin/plugins/codemap/templates/CONCERNS.md.template": "# Codebase Concerns\n\n**Analysis Date:** [YYYY-MM-DD]\n\n## Tech Debt\n\n**[Area/Component]:**\n- Issue: [What's the shortcut/workaround]\n- Files: `[file paths]`\n- Impact: [What breaks or degrades]\n- Fix approach: [How to address it]\n\n## Known Bugs\n\n**[Bug description]:**\n- Symptoms: [What happens]\n- Files: `[file paths]`\n- Trigger: [How to reproduce]\n- Workaround: [If any]\n\n## Security Considerations\n\n**[Area]:**\n- Risk: [What could go wrong]\n- Files: `[file paths]`\n- Current mitigation: [What's in place]\n- Recommendations: [What should be added]\n\n## Performance Bottlenecks\n\n**[Slow operation]:**\n- Problem: [What's slow]\n- Files: `[file paths]`\n- Cause: [Why it's slow]\n- Improvement path: [How to speed up]\n\n## Fragile Areas\n\n**[Component/Module]:**\n- Files: `[file paths]`\n- Why fragile: [What makes it break easily]\n- Safe modification: [How to change safely]\n- Test coverage: [Gaps]\n\n## Scaling Limits\n\n**[Resource/System]:**\n- Current capacity: [Numbers]\n- Limit: [Where it breaks]\n- Scaling path: [How to increase]\n\n## Dependencies at Risk\n\n**[Package]:**\n- Risk: [What's wrong]\n- Impact: [What breaks]\n- Migration plan: [Alternative]\n\n## Missing Critical Features\n\n**[Feature gap]:**\n- Problem: [What's missing]\n- Blocks: [What can't be done]\n\n## Test Coverage Gaps\n\n**[Untested area]:**\n- What's not tested: [Specific functionality]\n- Files: `[file paths]`\n- Risk: [What could break unnoticed]\n- Priority: [High/Medium/Low]\n\n---\n\n*Concerns audit: [date]*\n",
        ".claude-plugin/plugins/codemap/templates/CONVENTIONS.md.template": "# Coding Conventions\n\n**Analysis Date:** [YYYY-MM-DD]\n\n## Naming Patterns\n\n**Files:**\n- [Pattern observed]\n\n**Functions:**\n- [Pattern observed]\n\n**Variables:**\n- [Pattern observed]\n\n**Types:**\n- [Pattern observed]\n\n## Code Style\n\n**Formatting:**\n- [Tool used]\n- [Key settings]\n\n**Linting:**\n- [Tool used]\n- [Key rules]\n\n## Import Organization\n\n**Order:**\n1. [First group]\n2. [Second group]\n3. [Third group]\n\n**Path Aliases:**\n- [Aliases used]\n\n## Error Handling\n\n**Patterns:**\n- [How errors are handled]\n\n## Logging\n\n**Framework:** [Tool or \"console\"]\n\n**Patterns:**\n- [When/how to log]\n\n## Comments\n\n**When to Comment:**\n- [Guidelines observed]\n\n**JSDoc/TSDoc:**\n- [Usage pattern]\n\n## Function Design\n\n**Size:** [Guidelines]\n\n**Parameters:** [Pattern]\n\n**Return Values:** [Pattern]\n\n## Module Design\n\n**Exports:** [Pattern]\n\n**Barrel Files:** [Usage]\n\n---\n\n*Convention analysis: [date]*\n",
        ".claude-plugin/plugins/codemap/templates/INTEGRATIONS.md.template": "# External Integrations\n\n**Analysis Date:** [YYYY-MM-DD]\n\n## APIs & External Services\n\n**[Category]:**\n- [Service] - [What it's used for]\n- SDK/Client: [package]\n- Auth: [env var name]\n\n## Data Storage\n\n**Databases:**\n- [Type/Provider]\n- Connection: [env var]\n- Client: [ORM/client]\n\n**File Storage:**\n- [Service or \"Local filesystem only\"]\n\n**Caching:**\n- [Service or \"None\"]\n\n## Authentication & Identity\n\n**Auth Provider:**\n- [Service or \"Custom\"]\n- Implementation: [approach]\n\n## Monitoring & Observability\n\n**Error Tracking:**\n- [Service or \"None\"]\n\n**Logs:**\n- [Approach]\n\n## CI/CD & Deployment\n\n**Hosting:**\n- [Platform]\n\n**CI Pipeline:**\n- [Service or \"None\"]\n\n## Environment Configuration\n\n**Required env vars:**\n- [List critical vars]\n\n**Secrets location:**\n- [Where secrets are stored]\n\n## Webhooks & Callbacks\n\n**Incoming:**\n- [Endpoints or \"None\"]\n\n**Outgoing:**\n- [Endpoints or \"None\"]\n\n---\n\n*Integration audit: [date]*\n",
        ".claude-plugin/plugins/codemap/templates/STACK.md.template": "# Technology Stack\n\n**Analysis Date:** [YYYY-MM-DD]\n\n## Languages\n\n**Primary:**\n- [Language] [Version] - [Where used]\n\n**Secondary:**\n- [Language] [Version] - [Where used]\n\n## Runtime\n\n**Environment:**\n- [Runtime] [Version]\n\n**Package Manager:**\n- [Manager] [Version]\n- Lockfile: [present/missing]\n\n## Frameworks\n\n**Core:**\n- [Framework] [Version] - [Purpose]\n\n**Testing:**\n- [Framework] [Version] - [Purpose]\n\n**Build/Dev:**\n- [Tool] [Version] - [Purpose]\n\n## Key Dependencies\n\n**Critical:**\n- [Package] [Version] - [Why it matters]\n\n**Infrastructure:**\n- [Package] [Version] - [Purpose]\n\n## Configuration\n\n**Environment:**\n- [How configured]\n- [Key configs required]\n\n**Build:**\n- [Build config files]\n\n## Platform Requirements\n\n**Development:**\n- [Requirements]\n\n**Production:**\n- [Deployment target]\n\n---\n\n*Stack analysis: [date]*\n",
        ".claude-plugin/plugins/codemap/templates/STRUCTURE.md.template": "# Codebase Structure\n\n**Analysis Date:** [YYYY-MM-DD]\n\n## Directory Layout\n\n```\n[project-root]/\nâ”œâ”€â”€ [dir]/ # [Purpose]\nâ”œâ”€â”€ [dir]/ # [Purpose]\nâ””â”€â”€ [file] # [Purpose]\n```\n\n## Directory Purposes\n\n**[Directory Name]:**\n- Purpose: [What lives here]\n- Contains: [Types of files]\n- Key files: `[important files]`\n\n## Key File Locations\n\n**Entry Points:**\n- `[path]`: [Purpose]\n\n**Configuration:**\n- `[path]`: [Purpose]\n\n**Core Logic:**\n- `[path]`: [Purpose]\n\n**Testing:**\n- `[path]`: [Purpose]\n\n## Naming Conventions\n\n**Files:**\n- [Pattern]: [Example]\n\n**Directories:**\n- [Pattern]: [Example]\n\n## Where to Add New Code\n\n**New Feature:**\n- Primary code: `[path]`\n- Tests: `[path]`\n\n**New Component/Module:**\n- Implementation: `[path]`\n\n**Utilities:**\n- Shared helpers: `[path]`\n\n## Special Directories\n\n**[Directory]:**\n- Purpose: [What it contains]\n- Generated: [Yes/No]\n- Committed: [Yes/No]\n\n---\n\n*Structure analysis: [date]*\n",
        ".claude-plugin/plugins/codemap/templates/TESTING.md.template": "# Testing Patterns\n\n**Analysis Date:** [YYYY-MM-DD]\n\n## Test Framework\n\n**Runner:**\n- [Framework] [Version]\n- Config: `[config file]`\n\n**Assertion Library:**\n- [Library]\n\n**Run Commands:**\n```bash\n[command]              # Run all tests\n[command]              # Watch mode\n[command]              # Coverage\n```\n\n## Test File Organization\n\n**Location:**\n- [Pattern: co-located or separate]\n\n**Naming:**\n- [Pattern]\n\n**Structure:**\n```\n[Directory pattern]\n```\n\n## Test Structure\n\n**Suite Organization:**\n```typescript\n[Show actual pattern from codebase]\n```\n\n**Patterns:**\n- [Setup pattern]\n- [Teardown pattern]\n- [Assertion pattern]\n\n## Mocking\n\n**Framework:** [Tool]\n\n**Patterns:**\n```typescript\n[Show actual mocking pattern from codebase]\n```\n\n**What to Mock:**\n- [Guidelines]\n\n**What NOT to Mock:**\n- [Guidelines]\n\n## Fixtures and Factories\n\n**Test Data:**\n```typescript\n[Show pattern from codebase]\n```\n\n**Location:**\n- [Where fixtures live]\n\n## Coverage\n\n**Requirements:** [Target or \"None enforced\"]\n\n**View Coverage:**\n```bash\n[command]\n```\n\n## Test Types\n\n**Unit Tests:**\n- [Scope and approach]\n\n**Integration Tests:**\n- [Scope and approach]\n\n**E2E Tests:**\n- [Framework or \"Not used\"]\n\n## Common Patterns\n\n**Async Testing:**\n```typescript\n[Pattern]\n```\n\n**Error Testing:**\n```typescript\n[Pattern]\n```\n\n---\n\n*Testing analysis: [date]*\n",
        ".claude-plugin/plugins/handoffs/SKILL.md": "---\nname: handoffs\ndescription: Creates detailed handoff plans of conversations for continuing work in new sessions\nlicense: MIT\ncompatibility: claude, opencode, codex, gemini\nhint: Use when ending a session and want to continue work later with full context\nmetadata:\n  audience: all\n  workflow: workflow\n---\n\n# Session Handoff Plan\n\nCreates a detailed handoff plan of the conversation for continuing the work in a new session.\n\nThe user specified purpose:\n\n<purpose>$ARGUMENTS</purpose>\n\nYou are creating a summary specifically so that it can be continued by another agent. For this to work you MUST have a purpose. If no specified purpose was provided in the `<purpose>...</purpose>` tag you must STOP IMMEDIATELY and ask the user what the purpose is.\n\nDo not continue before asking for the purpose as you will otherwise not understand the instructions and do not assume a purpose!\n\n## Goal\n\nCreate a detailed summary of the conversation so far, paying close attention to the user's explicit purpose for the next steps.\nThis handoff plan should be thorough in capturing technical details, code patterns, and architectural decisions that will be essential for continuing development work without losing context.\n\n## Process\n\nBefore providing your final plan, wrap your analysis in <analysis> tags to organize your thoughts and ensure you've covered all necessary points:\n\n1. Chronologically analyze each message and section of the conversation. For each section thoroughly identify:\n   - The user's explicit requests and intents\n   - Your approach to addressing the user's requests\n   - Key decisions, technical concepts and code patterns\n   - Specific details like file names, full code snippets, function signatures, file edits, etc\n2. Double-check for technical accuracy and completeness, addressing each required element thoroughly.\n\nYour plan should include the following sections:\n\n1. **Primary Request and Intent**: Capture all of the user's explicit requests and intents in detail\n2. **Key Technical Concepts**: List all important technical concepts, technologies, and frameworks discussed.\n3. **Files and Code Sections**: Enumerate specific files and code sections examined, modified, or created. Pay special attention to the most recent messages and include full code snippets where applicable and include a summary of why this file read or edit is important.\n4. **Problem Solving**: Document problems solved and any ongoing troubleshooting efforts.\n5. **Pending Tasks**: Outline any pending tasks that you have explicitly been asked to work on.\n6. **Current Work**: Describe in detail precisely what was being worked on immediately before this handoff request, paying special attention to the most recent messages from both user and assistant. Include file names and code snippets where applicable.\n7. **Next Step**: List the next step that you will take that is related to the most recent work you were doing. IMPORTANT: ensure that this step is DIRECTLY in line with the user's explicit requests, and the task you were working on immediately before this handoff request. If your last task was concluded, then only list next steps if they are explicitly in line with the users request. Do not start on tangential requests without confirming with the user first. Include this section only if there is an actionable next step.\n\nAdditionally create a \"slug\" for this handoff. The \"slug\" is how we will refer to it later in a few places. Examples:\n\n- current-user-api-handler\n- implement-auth\n- fix-issue-42\n\nTogether with the slug create a \"Readable Summary\". Examples:\n\n- Implement Current User API Handler\n- Implement Authentication\n- Fix Issue #42\n\n## Output Structure\n\nFirst, show your analysis to the user in `<analysis>` tags as part of your response.\n\nThen write the handoff file with this structure:\n\n```markdown\n# Session Handoff Plan\n\n## 1. Primary Request and Intent\n\n[Detailed description of all user requests and intents]\n\n## 2. Key Technical Concepts\n\n- [Concept 1]\n- [Concept 2]\n- [...]\n\n## 3. Files and Code Sections\n\n### [File Name 1]\n\n- **Why important**: [Summary of why this file is important]\n- **Changes made**: [Summary of the changes made to this file, if any]\n- **Code snippet**:\n\n\\`\\`\\`language\n[Important Code Snippet]\n\\`\\`\\`\n\n### [File Name 2]\n\n- **Code snippet**:\n\n\\`\\`\\`language\n[Important Code Snippet]\n\\`\\`\\`\n\n[...]\n\n## 4. Problem Solving\n\n[Description of solved problems and ongoing troubleshooting]\n\n## 5. Pending Tasks\n\n- [Task 1 that you have been explicitly asked to work on]\n- [Task 2 that you have been explicitly asked to work on]\n- [...]\n\n## 6. Current Work\n\n[Detailed description of what was being worked on immediately before this handoff, including file names and code snippets]\n\n## 7. Next Step\n\n[Next step to take, directly aligned with user's explicit handoff purpose. Only include if there is an actionable next step.]\n```\n\n## Final Step\n\nAfter providing your analysis and summary:\n\n1. Ensure the `.claude/handoffs/` directory exists (create it if needed)\n2. Write the handoff summary to a markdown file at `.claude/handoffs/[timestamp]-[slug].md` where [timestamp] is the current date in format YYYY-MM-DD and the slug is what we defined before\n3. Tell the user about this file and that they can use `/pickup $1` to continue where $1 is the filename\n",
        ".claude-plugin/plugins/pickup/SKILL.md": "---\nname: pickup\ndescription: Resumes work from a previous handoff session which are stored in `.claude/handoffs/`\nlicense: MIT\ncompatibility: claude, opencode, codex, gemini\nhint: Use when resuming work from a previous handoff session\nmetadata:\n  audience: all\n  workflow: workflow\n---\n\n# Pickup Handoff\n\nResumes work from a previous handoff session which are stored in `.claude/handoffs/`.\n\n## Usage\n\n`/pickup [HANDOFF_FILE]`\n\nIf no handoff file is specified, will show available handoffs and prompt for selection.\n\n## Process\n\n1. Find available handoffs in `.claude/handoffs/`\n2. Read the selected handoff file\n3. Present the handoff summary to the user\n4. Ask the user to confirm they want to continue\n5. If confirmed, proceed with the next step described in the handoff\n\n## Available Handoffs\n\nTo see available handoffs:\n\n```bash\nls -la .claude/handoffs/\n```\n\nHandoffs are named in format: `[YYYY-MM-DD]-[slug].md`\n",
        ".claude-plugin/plugins/pr-review/SKILL.md": "---\nname: pr-review\ndescription: Fix PR review comments by implementing requested changes\nlicense: MIT\ncompatibility: claude, opencode, amp, codex, gemini\nhint: Use when fixing PR review comments or addressing review feedback. Accepts PR URL, PR number, or auto-detects from current branch\nmetadata:\n  audience: all\n  workflow: code-quality\n---\n\n# Fix PR Review Comments\n\nFix PR review comments by implementing the requested changes.\n\n## Usage\n\n```bash\n/pr-review <PR_URL>      # Review PR by URL (expects full GitHub URL)\n/pr-review <PR_NUMBER>   # Review PR by number (expects number, e.g., 123)\n/pr-review               # Auto-detect PR from current branch\n```\n\n### ðŸ“‹ Argument Handling\n\nThe command accepts the PR identifier from `$ARGUMENTS`:\n\n1. **PR URL**: Full GitHub PR URL (e.g., `https://github.com/owner/repo/pull/123`)\n2. **PR Number**: Just the PR number (e.g., `123`)\n3. **No Arguments**: Auto-detect the PR associated with the current Git branch\n\nIf `$ARGUMENTS` is provided, use it as the PR identifier. Otherwise, auto-detect the current branch's PR using:\n```bash\ngh pr view --json number,url -q '.number'\n```\nThis extracts the PR number from the current branch's open PR for use in subsequent commands.\n\nIf no open PR is found for the current branch, show this error:\n```text\nError: No open pull request found for the current branch.\n\nTo review a specific PR:\n  /pr-review <PR_URL>\n  /pr-review <PR_NUMBER>\n\nOr create a PR first:\n  gh pr create\n```\n\n## Process\n\n1. Parse `$ARGUMENTS` to determine PR identifier (URL, number, or auto-detect)\n2. Fetch PR details and review comments using `gh` CLI\n3. Parse review comments to understand what needs to be changed\n4. For each comment, implement the fix\n5. Run tests to ensure nothing breaks\n6. Commit the changes\n\n## Available Scripts\n\n### Extract PR Comments\n\nThe `extract-pr-comments.js` script processes GitHub PR review comments and issue comments to create actionable TODO lists.\n\n```bash\n# Usage\nnode $SKILL_PATH/scripts/extract-pr-comments.js <review-comments-file> <issue-comments-file> [output-file]\n\n# Example\nnode $SKILL_PATH/scripts/extract-pr-comments.js \\\n  pr-4972-review-comments-raw.json \\\n  pr-4972-issue-comments-raw.json \\\n  pr-4972-comments.ndjson\n```\n\n**What it does:**\n- Filters out comments with replies (likely resolved)\n- Classifies comments by severity (critical, high, medium, low)\n- Categorizes comments (security, performance, maintainability, etc.)\n- Creates 3 output files:\n  - `.ndjson` - Structured comment data\n  - `-todo.md` - Prioritized TODO list\n  - `-summary.md` - Analysis summary with emojis\n\n**Severity classification:**\n- ðŸ”´ **Critical**: security, vulnerability, exploit\n- ðŸŸ  **High**: bug, error, breaking, crash, fail\n- ðŸŸ¡ **Medium**: performance, improvement, refactor, optimize\n- ðŸŸ¢ **Low**: everything else\n\n**Categories:**\n- ðŸ”’ Security\n- âš¡ Performance\n- ðŸ”§ Maintainability\n- â™¿ Accessibility\n- ðŸ§ª Testing\n- ðŸ“š Documentation\n- ðŸ·ï¸ Typing\n- ðŸŽ¨ Style\n- âœ¨ Code Quality\n\n## Examples\n\n```bash\n# Fix review comments for a PR using URL\n/pr-review https://github.com/owner/repo/pull/123\n\n# Fix review comments using PR number\n/pr-review 123\n\n# Auto-detect PR from current branch\n/pr-review\n\n# After extracting comments with the script, work through the TODO list\n# The TODO list is ordered by priority: Critical â†’ High â†’ Medium â†’ Low\n```\n",
        ".claude-plugin/plugins/pr-review/scripts/extract-pr-comments.js": "#!/usr/bin/env node\n\nconst fs = require(\"node:fs\");\n\nfunction extractPrComments(reviewCommentsFile, issueCommentsFile, outputFile) {\n  let allComments = [];\n\n  if (fs.existsSync(reviewCommentsFile)) {\n    const reviewData = fs.readFileSync(reviewCommentsFile, \"utf8\");\n    const reviewComments = JSON.parse(reviewData);\n    allComments = allComments.concat(\n      reviewComments.map((comment) => ({\n        ...comment,\n        comment_type: \"review\",\n      })),\n    );\n  }\n\n  if (fs.existsSync(issueCommentsFile)) {\n    const issueData = fs.readFileSync(issueCommentsFile, \"utf8\");\n    const issueComments = JSON.parse(issueData);\n    allComments = allComments.concat(\n      issueComments.map((comment) => ({\n        ...comment,\n        comment_type: \"issue\",\n      })),\n    );\n  }\n\n  const comments = allComments;\n  const commentIdsWithReplies = new Set(\n    comments\n      .filter((comment) => comment.in_reply_to_id)\n      .map((comment) => comment.in_reply_to_id),\n  );\n\n  const relevantComments = comments\n    .filter((comment) => {\n      if (comment.in_reply_to_id) return false;\n      if (commentIdsWithReplies.has(comment.id)) return false;\n      if (!comment.body || comment.body.trim() === \"\") return false;\n\n      const isBot =\n        comment.user?.type === \"Bot\" ||\n        comment.user?.login?.includes(\"[bot]\");\n      if (isBot) {\n        const body = comment.body.toLowerCase();\n        const hasActionableContent =\n          body.includes(\"issue\") ||\n          body.includes(\"fix\") ||\n          body.includes(\"error\") ||\n          body.includes(\"suggestion\") ||\n          body.includes(\"improvement\") ||\n          body.includes(\"bug\") ||\n          (body.includes(\"review\") &&\n            (body.includes(\"feedback\") || body.includes(\"found\")));\n        if (!hasActionableContent) return false;\n      }\n\n      return true;\n    })\n    .map((comment) => {\n      const classification = classifyComment(comment);\n      return {\n        id: comment.id,\n        body: comment.body,\n        diff_hunk: comment.diff_hunk,\n        commit_id: comment.commit_id,\n        path: comment.path,\n        user: comment.user?.login || \"unknown\",\n        comment_type: comment.comment_type,\n        html_url: comment.html_url,\n        severity: classification.severity,\n        categories: classification.categories,\n      };\n    });\n\n  const ndjsonOutput = formatAsNdjson(relevantComments);\n\n  fs.writeFileSync(outputFile, ndjsonOutput, \"utf8\");\n\n  const todoFile = outputFile.replace(\".ndjson\", \"-todo.md\");\n  const todoContent = createTodoFile(\n    relevantComments,\n    reviewCommentsFile || issueCommentsFile,\n  );\n  fs.writeFileSync(todoFile, todoContent, \"utf8\");\n\n  const summaryStats = generateSummaryStats(relevantComments);\n  const summaryFile = outputFile.replace(\".ndjson\", \"-summary.md\");\n  const summaryContent = createSummaryFile(\n    summaryStats,\n    relevantComments.length,\n    comments.length,\n  );\n  fs.writeFileSync(summaryFile, summaryContent, \"utf8\");\n\n  const resolvedCount = commentIdsWithReplies.size;\n  console.log(\n    `Extracted ${relevantComments.length} unresolved comments from ${comments.length} total comments`,\n  );\n  console.log(\n    `Skipped ${resolvedCount} comments with replies (likely resolved)`,\n  );\n  console.log(\n    `Severity breakdown: Critical: ${summaryStats.severity.critical}, High: ${summaryStats.severity.high}, Medium: ${summaryStats.severity.medium}, Low: ${summaryStats.severity.low}`,\n  );\n  console.log(`Output saved to: ${outputFile}`);\n  console.log(`Todo file created: ${todoFile}`);\n  console.log(`Summary file created: ${summaryFile}`);\n}\n\nfunction classifyComment(comment) {\n  const body = comment.body.toLowerCase();\n\n  let severity = \"low\";\n  if (\n    body.includes(\"security\") ||\n    body.includes(\"vulnerability\") ||\n    body.includes(\"critical\") ||\n    body.includes(\"exploit\")\n  ) {\n    severity = \"critical\";\n  } else if (\n    body.includes(\"bug\") ||\n    body.includes(\"error\") ||\n    body.includes(\"breaking\") ||\n    body.includes(\"crash\") ||\n    body.includes(\"fail\")\n  ) {\n    severity = \"high\";\n  } else if (\n    body.includes(\"performance\") ||\n    body.includes(\"improvement\") ||\n    body.includes(\"refactor\") ||\n    body.includes(\"optimize\") ||\n    body.includes(\"slow\")\n  ) {\n    severity = \"medium\";\n  }\n\n  const categories = [];\n  if (\n    body.includes(\"security\") ||\n    body.includes(\"vulnerability\") ||\n    body.includes(\"auth\") ||\n    body.includes(\"permission\")\n  ) {\n    categories.push(\"security\");\n  }\n  if (\n    body.includes(\"performance\") ||\n    body.includes(\"slow\") ||\n    body.includes(\"optimize\") ||\n    body.includes(\"memory\") ||\n    body.includes(\"speed\")\n  ) {\n    categories.push(\"performance\");\n  }\n  if (\n    body.includes(\"complex\") ||\n    body.includes(\"refactor\") ||\n    body.includes(\"maintainability\") ||\n    body.includes(\"clean\")\n  ) {\n    categories.push(\"maintainability\");\n  }\n  if (\n    body.includes(\"aria\") ||\n    body.includes(\"accessibility\") ||\n    body.includes(\"a11y\") ||\n    body.includes(\"screen reader\")\n  ) {\n    categories.push(\"accessibility\");\n  }\n  if (\n    body.includes(\"test\") ||\n    body.includes(\"coverage\") ||\n    body.includes(\"spec\") ||\n    body.includes(\"unit test\")\n  ) {\n    categories.push(\"testing\");\n  }\n  if (\n    body.includes(\"doc\") ||\n    body.includes(\"comment\") ||\n    body.includes(\"readme\") ||\n    body.includes(\"jsdoc\")\n  ) {\n    categories.push(\"documentation\");\n  }\n  if (\n    body.includes(\"type\") ||\n    body.includes(\"typescript\") ||\n    body.includes(\"interface\") ||\n    body.includes(\"generic\")\n  ) {\n    categories.push(\"typing\");\n  }\n  if (\n    body.includes(\"style\") ||\n    body.includes(\"format\") ||\n    body.includes(\"lint\") ||\n    body.includes(\"prettier\")\n  ) {\n    categories.push(\"style\");\n  }\n\n  if (categories.length === 0) {\n    categories.push(\"code-quality\");\n  }\n\n  return { severity, categories };\n}\n\nfunction formatAsNdjson(comments) {\n  return comments\n    .map((comment, index) => {\n      const commentObj = {\n        id: index + 1,\n        github_id: comment.id,\n        user: comment.user,\n        comment_type: comment.comment_type,\n        path: comment.path || \"\",\n        commit_id: comment.commit_id || \"\",\n        diff_hunk: comment.diff_hunk || \"\",\n        html_url: comment.html_url || \"\",\n        body: comment.body,\n        severity: comment.severity,\n        categories: comment.categories,\n      };\n      return JSON.stringify(commentObj);\n    })\n    .join(\"\\n\");\n}\n\nfunction generateSummaryStats(comments) {\n  const stats = {\n    severity: { critical: 0, high: 0, medium: 0, low: 0 },\n    categories: {},\n    total: comments.length,\n  };\n\n  comments.forEach((comment) => {\n    if (stats.severity[comment.severity] !== undefined) {\n      stats.severity[comment.severity]++;\n    }\n\n    comment.categories.forEach((category) => {\n      stats.categories[category] = (stats.categories[category] || 0) + 1;\n    });\n  });\n\n  return stats;\n}\n\nfunction createSummaryFile(stats, relevantCount, totalCount) {\n  const severityEmojis = {\n    critical: \"ðŸ”´\",\n    high: \"ðŸŸ \",\n    medium: \"ðŸŸ¡\",\n    low: \"ðŸŸ¢\",\n  };\n\n  const categoryEmojis = {\n    security: \"ðŸ”’\",\n    performance: \"âš¡\",\n    maintainability: \"ðŸ”§\",\n    accessibility: \"â™¿\",\n    testing: \"ðŸ§ª\",\n    documentation: \"ðŸ“š\",\n    typing: \"ðŸ·ï¸\",\n    style: \"ðŸŽ¨\",\n    \"code-quality\": \"âœ¨\",\n  };\n\n  let content = `# Comment Analysis Summary\\n\\n`;\n\n  content += `ðŸŽ¯ **Impact Analysis:**\\n`;\n  Object.entries(stats.severity).forEach(([severity, count]) => {\n    if (count > 0) {\n      content += `â€¢ ${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${severityEmojis[severity]} ${count} issue${count !== 1 ? \"s\" : \"\"}\\n`;\n    }\n  });\n\n  content += `\\nðŸ“Š **Total Comments:** ${relevantCount} actionable (${totalCount - relevantCount} resolved/skipped)\\n\\n`;\n\n  content += `ðŸ“‹ **Category Breakdown:**\\n`;\n  Object.entries(stats.categories)\n    .sort(([, a], [, b]) => b - a)\n    .forEach(([category, count]) => {\n      const emoji = categoryEmojis[category] || \"ðŸ“\";\n      content += `â€¢ ${emoji} ${category.charAt(0).toUpperCase() + category.slice(1).replace(\"-\", \" \")}: ${count}\\n`;\n    });\n\n  content += `\\n---\\n\\n*Use this analysis to prioritize your fixes by severity and category.*`;\n\n  return content;\n}\n\nfunction createTodoFile(comments, inputFile) {\n  const prNumber = inputFile.match(/pr-(\\d+)/)?.[1] || \"XXXX\";\n\n  const severityEmojis = {\n    critical: \"ðŸ”´\",\n    high: \"ðŸŸ \",\n    medium: \"ðŸŸ¡\",\n    low: \"ðŸŸ¢\",\n  };\n\n  const todoItems = comments\n    .sort((a, b) => {\n      const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n      return severityOrder[a.severity] - severityOrder[b.severity];\n    })\n    .map((comment, index) => {\n      const shortBody = comment.body\n        .split(\"\\n\")[0]\n        .replace(/[*_`]/g, \"\")\n        .substring(0, 60);\n      const filePath =\n        comment.path ||\n        (comment.comment_type === \"issue\"\n          ? \"General PR Discussion\"\n          : \"unknown\");\n      const commentId = index + 1;\n      const commentType = comment.comment_type === \"issue\" ? \"ðŸ’¬\" : \"ðŸ“\";\n      const severityIndicator = severityEmojis[comment.severity] || \"ðŸŸ¢\";\n      const categories = comment.categories.slice(0, 2).join(\", \");\n\n      return `- [ ] ${commentType} ${severityIndicator} **${comment.severity.toUpperCase()}** Comment #${commentId} - **${filePath}** - ${shortBody}${shortBody.length >= 60 ? \"...\" : \"\"} *(${categories})* - [View](${comment.html_url || \"#\"})`;\n    })\n    .join(\"\\n\");\n\n  return `# PR #${prNumber} Review Comments - TODO List\\n\\nðŸŽ¯ **Priority Order:** ðŸ”´ Critical â†’ ðŸŸ  High â†’ ðŸŸ¡ Medium â†’ ðŸŸ¢ Low\\n\\n${todoItems}`;\n}\n\nif (require.main === module) {\n  const args = process.argv.slice(2);\n\n  if (args.length < 2) {\n    console.log(\n      \"Usage: node extract-pr-comments.js <review-comments-file> <issue-comments-file> [output-file]\",\n    );\n    console.log(\n      \"Example: node .claude/extract-pr-comments.js pr-4972-review-comments-raw.json pr-4972-issue-comments-raw.json pr-4972-comments.ndjson\",\n    );\n    console.log(\"\");\n    console.log(\n      \"Note: This script processes both review comments (inline code comments) and issue comments (general PR discussion).\",\n    );\n    console.log(\n      \"It filters out comments with replies (likely resolved) and only shows top-level comments that need attention.\",\n    );\n    process.exit(1);\n  }\n\n  const reviewCommentsFile = args[0];\n  const issueCommentsFile = args[1];\n  const outputFile =\n    args[2] ||\n    reviewCommentsFile\n      .replace(\"-review-comments-raw.json\", \"-comments.ndjson\")\n      .replace(\".claude/\", \"\");\n\n  extractPrComments(reviewCommentsFile, issueCommentsFile, outputFile);\n}\n\nmodule.exports = { extractPrComments };\n",
        ".claude-plugin/plugins/prd/SKILL.md": "---\nname: prd\ndescription: \"Generate a Product Requirements Document (PRD) for a new feature. Use when planning a feature, starting a new project, or when asked to create a PRD. Triggers on: create a prd, write prd for, plan this feature, requirements for, spec out.\"\nlicense: MIT\ncompatibility: claude, opencode, amp, codex, gemini\nhint: Use when planning a feature, starting a new project, or creating PRD documents\nmetadata:\n  audience: all\n  workflow: product\n---\n\n# PRD Generator\n\nCreate detailed Product Requirements Documents that are clear, actionable, and suitable for implementation.\n\n---\n\n## The Job\n\n1. Receive a feature description from the user\n2. Ask 3-5 essential clarifying questions (with lettered options)\n3. Generate a structured PRD based on answers\n4. Save to `tasks/prd-[feature-name].md`\n\n**Important:** Do NOT start implementing. Just create the PRD.\n\n---\n\n## Step 1: Clarifying Questions\n\nAsk only critical questions where the initial prompt is ambiguous. Focus on:\n\n- **Problem/Goal:** What problem does this solve?\n- **Core Functionality:** What are the key actions?\n- **Scope/Boundaries:** What should it NOT do?\n- **Success Criteria:** How do we know it's done?\n\n### Format Questions Like This:\n\n```\n1. What is the primary goal of this feature?\n   A. Improve user onboarding experience\n   B. Increase user retention\n   C. Reduce support burden\n   D. Other: [please specify]\n\n2. Who is the target user?\n   A. New users only\n   B. Existing users only\n   C. All users\n   D. Admin users only\n\n3. What is the scope?\n   A. Minimal viable version\n   B. Full-featured implementation\n   C. Just the backend/API\n   D. Just the UI\n```\n\nThis lets users respond with \"1A, 2C, 3B\" for quick iteration.\n\n---\n\n## Step 2: PRD Structure\n\nGenerate the PRD with these sections:\n\n### 1. Introduction/Overview\nBrief description of the feature and the problem it solves.\n\n### 2. Goals\nSpecific, measurable objectives (bullet list).\n\n### 3. User Stories\nEach story needs:\n- **Title:** Short descriptive name\n- **Description:** \"As a [user], I want [feature] so that [benefit]\"\n- **Acceptance Criteria:** Verifiable checklist of what \"done\" means\n\nEach story should be small enough to implement in one focused session.\n\n**Format:**\n```markdown\n### US-001: [Title]\n**Description:** As a [user], I want [feature] so that [benefit].\n\n**Acceptance Criteria:**\n- [ ] Specific verifiable criterion\n- [ ] Another criterion\n- [ ] Typecheck/lint passes\n- [ ] **[UI stories only]** Verify in browser using dev-browser skill\n```\n\n**Important:** \n- Acceptance criteria must be verifiable, not vague. \"Works correctly\" is bad. \"Button shows confirmation dialog before deleting\" is good.\n- **For any story with UI changes:** Always include \"Verify in browser using dev-browser skill\" as acceptance criteria. This ensures visual verification of frontend work.\n\n### 4. Functional Requirements\nNumbered list of specific functionalities:\n- \"FR-1: The system must allow users to...\"\n- \"FR-2: When a user clicks X, the system must...\"\n\nBe explicit and unambiguous.\n\n### 5. Non-Goals (Out of Scope)\nWhat this feature will NOT include. Critical for managing scope.\n\n### 6. Design Considerations (Optional)\n- UI/UX requirements\n- Link to mockups if available\n- Relevant existing components to reuse\n\n### 7. Technical Considerations (Optional)\n- Known constraints or dependencies\n- Integration points with existing systems\n- Performance requirements\n\n### 8. Success Metrics\nHow will success be measured?\n- \"Reduce time to complete X by 50%\"\n- \"Increase conversion rate by 10%\"\n\n### 9. Open Questions\nRemaining questions or areas needing clarification.\n\n---\n\n## Writing for Junior Developers\n\nThe PRD reader may be a junior developer or AI agent. Therefore:\n\n- Be explicit and unambiguous\n- Avoid jargon or explain it\n- Provide enough detail to understand purpose and core logic\n- Number requirements for easy reference\n- Use concrete examples where helpful\n\n---\n\n## Output\n\n- **Format:** Markdown (`.md`)\n- **Location:** `tasks/`\n- **Filename:** `prd-[feature-name].md` (kebab-case)\n\n---\n\n## Example PRD\n\n```markdown\n# PRD: Task Priority System\n\n## Introduction\n\nAdd priority levels to tasks so users can focus on what matters most. Tasks can be marked as high, medium, or low priority, with visual indicators and filtering to help users manage their workload effectively.\n\n## Goals\n\n- Allow assigning priority (high/medium/low) to any task\n- Provide clear visual differentiation between priority levels\n- Enable filtering and sorting by priority\n- Default new tasks to medium priority\n\n## User Stories\n\n### US-001: Add priority field to database\n**Description:** As a developer, I need to store task priority so it persists across sessions.\n\n**Acceptance Criteria:**\n- [ ] Add priority column to tasks table: 'high' | 'medium' | 'low' (default 'medium')\n- [ ] Generate and run migration successfully\n- [ ] Typecheck passes\n\n### US-002: Display priority indicator on task cards\n**Description:** As a user, I want to see task priority at a glance so I know what needs attention first.\n\n**Acceptance Criteria:**\n- [ ] Each task card shows colored priority badge (red=high, yellow=medium, gray=low)\n- [ ] Priority visible without hovering or clicking\n- [ ] Typecheck passes\n- [ ] Verify in browser using dev-browser skill\n\n### US-003: Add priority selector to task edit\n**Description:** As a user, I want to change a task's priority when editing it.\n\n**Acceptance Criteria:**\n- [ ] Priority dropdown in task edit modal\n- [ ] Shows current priority as selected\n- [ ] Saves immediately on selection change\n- [ ] Typecheck passes\n- [ ] Verify in browser using dev-browser skill\n\n### US-004: Filter tasks by priority\n**Description:** As a user, I want to filter the task list to see only high-priority items when I'm focused.\n\n**Acceptance Criteria:**\n- [ ] Filter dropdown with options: All | High | Medium | Low\n- [ ] Filter persists in URL params\n- [ ] Empty state message when no tasks match filter\n- [ ] Typecheck passes\n- [ ] Verify in browser using dev-browser skill\n\n## Functional Requirements\n\n- FR-1: Add `priority` field to tasks table ('high' | 'medium' | 'low', default 'medium')\n- FR-2: Display colored priority badge on each task card\n- FR-3: Include priority selector in task edit modal\n- FR-4: Add priority filter dropdown to task list header\n- FR-5: Sort by priority within each status column (high to medium to low)\n\n## Non-Goals\n\n- No priority-based notifications or reminders\n- No automatic priority assignment based on due date\n- No priority inheritance for subtasks\n\n## Technical Considerations\n\n- Reuse existing badge component with color variants\n- Filter state managed via URL search params\n- Priority stored in database, not computed\n\n## Success Metrics\n\n- Users can change priority in under 2 clicks\n- High-priority tasks immediately visible at top of lists\n- No regression in task list performance\n\n## Open Questions\n\n- Should priority affect task ordering within a column?\n- Should we add keyboard shortcuts for priority changes?\n```\n\n---\n\n## Checklist\n\nBefore saving the PRD:\n\n- [ ] Asked clarifying questions with lettered options\n- [ ] Incorporated user's answers\n- [ ] User stories are small and specific\n- [ ] Functional requirements are numbered and unambiguous\n- [ ] Non-goals section defines clear boundaries\n- [ ] Saved to `tasks/prd-[feature-name].md`\n",
        ".claude-plugin/plugins/qmd-knowledge/SKILL.md": "---\nname: qmd-knowledge\ndescription: Project-specific knowledge management system using qmd MCP server. Captures learnings, issue notes, and conventions in a searchable knowledge base.\nlicense: MIT\ncompatibility: opencode, claude, amp, codex, gemini\nhint: Use when recording or retrieving project knowledge, learnings, and issue notes\nmetadata:\n  audience: all\n  workflow: knowledge-management\n---\n\n## What I do\n\n- Record and retrieve project learnings and insights\n- Capture issue-specific notes and resolutions\n- Build a growing, AI-searchable knowledge base\n- Provide context about project architecture and decisions\n\n## When to use me\n\nUse this skill when you need to:\n\n- **Record learnings**: Capture new insights, patterns, or best practices discovered during development\n- **Track issues**: Add notes to ongoing or resolved issues\n- **Query knowledge**: Search for previous decisions, learnings, or solutions\n- **Maintain context**: Build institutional memory for the project\n\n## How it works\n\nThis skill provides a unified knowledge management system. You install the skill once, and it manages knowledge across all your projects using qmd collections:\n\n```\n# The qmd-knowledge skill (installed to your AI tool's skills directory)\n# Location varies by tool: ~/.config/opencode/skill/, ~/.claude/skills/, or ~/.config/amp/skills/\nâ”œâ”€â”€ SKILL.md              # This file - the skill definition\nâ”œâ”€â”€ scripts/              # Executable scripts\nâ”‚   â””â”€â”€ record.sh         # Record learnings/issues/notes\nâ””â”€â”€ references/           # Example structure and READMEs\n\n# Project knowledge storage (managed by the skill)\n~/.ai-knowledges/\nâ”œâ”€â”€ <project-name>/       # Collection for your project\nâ”‚   â”œâ”€â”€ learnings/\nâ”‚   â””â”€â”€ issues/\nâ””â”€â”€ another-project/      # Collection for another project\n    â”œâ”€â”€ learnings/\n    â””â”€â”€ issues/\n```\n\nThe `qmd` MCP server provides AI-powered search across all stored knowledge, allowing your AI assistant to autonomously query and update the knowledge base.\n\n## Available scripts\n\n### Recording knowledge\n\n```bash\n# Record a learning (use the skill's script)\n$SKILL_PATH/scripts/record.sh learning \"qmd MCP integration\"\n\n# Add a note to an issue\n$SKILL_PATH/scripts/record.sh issue 123 \"Fixed by updating dependencies\"\n\n# Record a general note\n$SKILL_PATH/scripts/record.sh note \"Consider using agent skills for extensibility\"\n```\n\n### Querying knowledge\n\nUse the qmd MCP server tools directly from Claude or OpenCode:\n\n```bash\n# Fast keyword search\nqmd search \"MCP servers\" -c <project-name>\n\n# Semantic search with AI embeddings\nqmd vsearch \"how to configure MCP\"\n\n# Hybrid search with reranking (best quality)\nqmd query \"MCP server configuration\"\n\n# Get specific document\nqmd get \"references/learnings/2024-01-26-qmd-integration.md\"\n\n# Search with minimum score filter\nqmd search \"API\" --all --files --min-score 0.3 -c <project-name>\n```\n\n## Setup\n\n1. **Install qmd**:\n   ```bash\n   bun install -g https://github.com/tobi/qmd\n   ```\n\n2. **Install the skill**:\n   ```bash\n   # The skill is installed to your AI tool's skills directory:\n   # - OpenCode: ~/.config/opencode/skill/qmd-knowledge/\n   # - Claude Code: ~/.claude/skills/qmd-knowledge/\n   # - Amp: ~/.config/amp/skills/qmd-knowledge/\n   ```\n\n3. **Configure MCP server** (see installation docs for Claude/OpenCode/Amp)\n\n4. **Create a knowledge collection for your project**:\n   ```bash\n   # The skill's record.sh script will auto-detect the project name when executed.\n   # For manual setup, use your desired project name consistently in the commands below.\n   # Optional: export QMD_PROJECT=<project-name> to override auto-detection\n   \n   # Create storage directory for your project (replace <project-name> with your project)\n   mkdir -p ~/.ai-knowledges/<project-name>/learnings\n   mkdir -p ~/.ai-knowledges/<project-name>/issues\n   \n   # Add qmd collection\n   qmd collection add ~/.ai-knowledges/<project-name> --name <project-name>\n   qmd context add qmd://<project-name> \"Knowledge base for <project-name> project: learnings, issue notes, and conventions\"\n   \n   # Generate embeddings for AI-powered search\n   qmd embed\n   ```\n\n## Knowledge structure\n\n- `references/learnings/`: Time-stamped markdown files with project insights\n  - Format: `YYYY-MM-DD-topic-slug.md`\n  - Contains learnings, patterns, architectural decisions\n\n- `references/issues/`: Issue-specific notes and resolutions\n  - Format: `<issue-id>.md`\n  - Append-only log of notes related to specific issues\n\n## Integration with qmd MCP server\n\nThe qmd MCP server allows Claude to:\n\n- **Search knowledge**: Use natural language queries to find relevant context\n- **Auto-update index**: Automatically reindex after adding new knowledge\n- **Filter by project**: Use `--collection` flag to scope searches to specific projects\n\n## Example workflow\n\n1. **During development**, you discover something useful:\n   > \"I learned that qmd MCP server allows Claude to use tools autonomously.\"\n\n2. **Claude recognizes the skill and executes**:\n   ```bash\n   $SKILL_PATH/scripts/record.sh learning \"qmd MCP autonomous tool use\"\n   ```\n\n3. **Later, you ask**:\n   > \"What did I learn about MCP servers?\"\n\n4. **Claude queries the knowledge base** using qmd MCP tools:\n   ```bash\n   qmd query --collection <project-name> \"MCP servers\"\n   ```\n\n## Benefits over claude-mem\n\n- **Portable**: Standard markdown files in `~/.ai-knowledges/`\n- **Project-scoped**: Each project has its own isolated knowledge base\n- **AI-searchable**: Powered by qmd's embedding-based search\n- **Self-documenting**: Follows skills.md specification\n- **No repository pollution**: Knowledge stored outside project directories\n- **Version controllable**: Can optionally track knowledge in separate git repos\n\n## Project detection\n\nThe skill automatically detects your project name using the following priority:\n\n1. **QMD_PROJECT environment variable** (highest priority)\n   ```bash\n   export QMD_PROJECT=my-project-name\n   ```\n\n2. **Git remote URL** (most reliable - extracts repo name from origin URL)\n   - Example: `https://github.com/user/my-project.git` â†’ `my-project`\n   - Works even if the local folder has a different name\n\n3. **Git repository folder name** (fallback)\n   - Uses the name of the git repository root directory\n   - Works when you're anywhere inside a git repository\n   - Note: May not match the actual repo name if the folder was renamed\n\n4. **Current directory name** (last resort)\n   - Uses the name of your current working directory\n   - Used when not in a git repository\n\nThis means you can use the skill in any project without hardcoding project names. The knowledge base will be stored at `~/.ai-knowledges/<detected-project-name>/`.\n\n**Important**: The script prioritizes the git remote URL to ensure consistent project naming even if local folders are renamed or in non-standard locations (e.g., dated folders like `2026-01-08-my-ai-tools.qmd-skill`).\n\n## ðŸ“‹ Best Practices\n\n### ðŸŽ¨ Session Wrap-up\n\nAt the end of a work session, consider prompting the user about key learnings:\n\n> \"What were the main discoveries or decisions from this session? Would you like me to record any learnings?\"\n\n### ðŸŽ¨ Pattern Detection\n\nBe attentive to phrases that indicate valuable knowledge capture opportunities:\n\n- \"I discovered that...\"\n- \"I learned that...\"\n- \"The solution was...\"\n- \"The key insight is...\"\n- \"Don't forget to...\"\n- \"Make sure to...\"\n\nWhen you detect these patterns, suggest recording:\n> \"That sounds like a useful learning. Would you like me to record it?\"\n\n### ðŸŽ¨ Auto-Index Updates\n\nThe record script automatically runs `qmd embed` after each write, ensuring the knowledge base is searchable immediately. No manual re-indexing required.\n",
        ".claude-plugin/plugins/qmd-knowledge/references/issues/README.md": "# Issues\n\nThis directory contains issue-specific notes and resolutions.\n\n## Format\n\nFiles follow the naming convention: `<issue-id>.md`\n\nEach issue file is an append-only log with timestamped notes.\n\n## Example\n\n```markdown\n# Issue #123\n\n## Notes\n\n### 2024-01-26 10:00:00\n\nInitial investigation shows the problem is related to dependency versions.\n\n### 2024-01-26 14:30:00\n\nFixed by updating to latest version. Need to document the breaking changes.\n\n### 2024-01-27 09:00:00\n\nAdded migration guide in CHANGELOG.md. Issue resolved.\n```\n",
        ".claude-plugin/plugins/qmd-knowledge/references/learnings/README.md": "# Learnings\n\nThis directory contains project learnings and insights.\n\n## Format\n\nFiles follow the naming convention: `YYYY-MM-DD-topic-slug.md`\n\nEach learning should include:\n- Context about when/how it was discovered\n- The actual learning or insight\n- How it can be applied in the future\n\n## Example\n\n```markdown\n# Learning: qmd MCP Integration\n\n**Date:** 2024-01-26 12:00:00\n\n## Context\n\nWhile implementing knowledge management, discovered qmd has built-in MCP server support.\n\n## Learning\n\nThe qmd tool provides a native MCP server via `qmd mcp` command, allowing Claude to\nautonomously search and query markdown knowledge bases.\n\n## Application\n\nUse qmd MCP server for project-specific knowledge bases instead of claude-mem to avoid\nrepository pollution and gain better search capabilities.\n```\n",
        ".claude-plugin/plugins/qmd-knowledge/scripts/record.sh": "#!/bin/bash\n\n# qmd-knowledge record script\n# Records learnings, issues, and notes to the project knowledge base\n\nset -e\n\nTYPE=\"$1\"\nshift\n\n# Detect project name from environment, git repo, or current directory\n# Priority: QMD_PROJECT env var > git remote URL > git repo folder name > current directory name\nif [ -n \"$QMD_PROJECT\" ]; then\n    PROJECT_NAME=\"$QMD_PROJECT\"\nelif git rev-parse --is-inside-work-tree &>/dev/null; then\n    # Try to get project name from git remote URL (most reliable)\n    PROJECT_NAME=$(git remote get-url origin 2>/dev/null | xargs basename -s .git 2>/dev/null)\n    \n    # Fall back to git repo folder name if remote URL fails or returns invalid values\n    # Invalid: empty, \"origin\", or strings that look like URLs/paths\n    if [ -z \"$PROJECT_NAME\" ] || [ \"$PROJECT_NAME\" = \"origin\" ] || [[ \"$PROJECT_NAME\" =~ ^[./:] ]]; then\n        GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)\n        if [ -n \"$GIT_ROOT\" ]; then\n            PROJECT_NAME=$(basename \"$GIT_ROOT\")\n        else\n            PROJECT_NAME=$(basename \"$(pwd)\")\n        fi\n    fi\nelse\n    # Fall back to current directory name\n    PROJECT_NAME=$(basename \"$(pwd)\")\nfi\n\nKNOWLEDGE_BASE=\"$HOME/.ai-knowledges/$PROJECT_NAME\"\n\n# Colors for output\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nRED='\\033[0;31m'\nNC='\\033[0m'\n\n# Auto-setup knowledge base if needed\nsetup_knowledge_base() {\n    if ! command -v qmd &> /dev/null; then\n        echo -e \"${YELLOW}Warning: qmd not found. Install with: bun install -g https://github.com/tobi/qmd${NC}\"\n        return 1\n    fi\n    \n    # Create directory structure\n    mkdir -p \"$KNOWLEDGE_BASE/references/learnings\"\n    mkdir -p \"$KNOWLEDGE_BASE/references/issues\"\n    \n    # Add collection (suppress error if already exists)\n    local err_file=\"/tmp/qmd-collection-add-$$-err.txt\"\n    if qmd collection add \"$KNOWLEDGE_BASE\" --name \"$PROJECT_NAME\" 2>\"$err_file\"; then\n        echo -e \"${GREEN}âœ“ Collection '$PROJECT_NAME' added${NC}\"\n        rm -f \"$err_file\"\n    else\n        # Check if the error is because collection already exists\n        if grep -qi \"already exists\" \"$err_file\" 2>/dev/null; then\n            echo -e \"${GREEN}âœ“ Collection '$PROJECT_NAME' already exists${NC}\"\n            rm -f \"$err_file\"\n        elif qmd collection list 2>/dev/null | grep -q \"^$PROJECT_NAME$\"; then\n            echo -e \"${GREEN}âœ“ Collection '$PROJECT_NAME' already exists${NC}\"\n            rm -f \"$err_file\"\n        else\n            echo -e \"${YELLOW}Note: Could not add collection. Error:${NC}\"\n            cat \"$err_file\" 2>/dev/null || echo \"(Error details unavailable)\"\n            rm -f \"$err_file\"\n            echo -e \"${YELLOW}You may need to add it manually:${NC}\"\n            echo -e \"${YELLOW}  qmd collection add $KNOWLEDGE_BASE --name $PROJECT_NAME${NC}\"\n            return 1\n        fi\n    fi\n    \n    # Add context (suppress error if already exists)\n    qmd context add \"qmd://$PROJECT_NAME\" \"Knowledge base for $PROJECT_NAME project: learnings, issue notes, and conventions\" 2>/dev/null || true\n    \n    # Generate embeddings\n    qmd embed 2>/dev/null || true\n    \n    echo -e \"${GREEN}âœ“ Knowledge base ready: $KNOWLEDGE_BASE${NC}\"\n    return 0\n}\n\n# Ensure knowledge base exists\nif [ ! -d \"$KNOWLEDGE_BASE\" ]; then\n    echo -e \"${YELLOW}Knowledge base not found. Setting up automatically...${NC}\"\n    if ! setup_knowledge_base; then\n        echo -e \"${RED}Error: Failed to set up knowledge base at $KNOWLEDGE_BASE${NC}\"\n        echo \"\"\n        echo \"To set up manually, run:\"\n        echo \"  mkdir -p $KNOWLEDGE_BASE/{references/learnings,references/issues}\"\n        echo \"  qmd collection add $KNOWLEDGE_BASE --name $PROJECT_NAME\"\n        echo \"  qmd context add qmd://$PROJECT_NAME \\\"Knowledge base for $PROJECT_NAME project\\\"\"\n        echo \"  qmd embed\"\n        echo \"\"\n        echo \"See docs/qmd-knowledge-management.md for detailed setup instructions.\"\n        exit 1\n    fi\nfi\n\n# Function to slugify text\nslugify() {\n    local slug\n    slug=$(echo \"$1\" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\\+/-/g' | sed 's/^-\\|-$//g')\n    # Fallback to timestamp if slug is empty\n    if [ -z \"$slug\" ]; then\n        slug=\"note-$(date +%H%M%S)\"\n    fi\n    echo \"$slug\"\n}\n\n# Validate path stays within knowledge base (prevent path traversal)\nvalidate_safe_path() {\n    local dest_dir=\"$1\"\n    local filename=\"$2\"\n\n    # Get absolute paths for comparison\n    local abs_knowledge_base\n    local abs_dest_path\n    abs_knowledge_base=$(cd \"$KNOWLEDGE_BASE\" 2>/dev/null && pwd)\n    abs_dest_path=$(cd \"$KNOWLEDGE_BASE/$dest_dir\" 2>/dev/null && pwd)/\"$filename\"\n\n    if [ -z \"$abs_knowledge_base\" ]; then\n        echo -e \"${RED}Error: Knowledge base directory does not exist${NC}\" >&2\n        return 1\n    fi\n\n    # Check if destination path starts with knowledge base path\n    if [[ \"$abs_dest_path\" != \"$abs_knowledge_base\"* ]]; then\n        echo -e \"${RED}Error: Path traversal attempt detected: $filename${NC}\" >&2\n        return 1\n    fi\n\n    # Ensure no parent directory references\n    if [[ \"$filename\" == *\"..\"* ]]; then\n        echo -e \"${RED}Error: Invalid filename with parent directory reference: $filename${NC}\" >&2\n        return 1\n    fi\n\n    return 0\n}\n\n# Debounced index update - only runs if enough time has passed\nEMBED_COOLDOWN=30\nEMBED_MARKER=\"$KNOWLEDGE_BASE/.embed_pending\"\n\nupdate_index() {\n    if ! command -v qmd &> /dev/null; then\n        echo -e \"${YELLOW}Warning: qmd not found. Install with: bun install -g https://github.com/tobi/qmd${NC}\"\n        return\n    fi\n\n    local now\n    local last_embed\n    now=$(date +%s)\n\n    # Check for pending embedding marker\n    if [ -f \"$EMBED_MARKER\" ]; then\n        last_embed=$(cat \"$EMBED_MARKER\" 2>/dev/null || echo 0)\n        local elapsed=$((now - last_embed))\n\n        if [ $elapsed -lt $EMBED_COOLDOWN ]; then\n            echo -e \"${YELLOW}Debouncing qmd embed (last run ${elapsed}s ago, cooldown: ${EMBED_COOLDOWN}s)${NC}\"\n            return\n        fi\n    fi\n\n    echo -e \"${GREEN}Updating qmd embeddings...${NC}\"\n    if qmd embed 2>/dev/null; then\n        echo \"$now\" > \"$EMBED_MARKER\"\n    else\n        echo -e \"${YELLOW}Note: qmd embed failed. Ensure collection is added: qmd collection add $KNOWLEDGE_BASE --name $PROJECT_NAME${NC}\"\n    fi\n}\n\n# Helper: Create a knowledge file with validation and directory setup\n# Usage: create_knowledge_file \"subdir\" \"filename\" \"content\"\n# Returns: 0 on success, 1 on validation failure\ncreate_knowledge_file() {\n    local subdir=\"$1\"\n    local filename=\"$2\"\n    local content=\"$3\"\n\n    # Validate path stays within knowledge base\n    if ! validate_safe_path \"$subdir\" \"$filename\"; then\n        return 1\n    fi\n\n    # Create directory if needed\n    mkdir -p \"$KNOWLEDGE_BASE/$subdir\"\n\n    # Write file\n    echo \"$content\" > \"$KNOWLEDGE_BASE/$subdir/$filename\"\n    echo -e \"${GREEN}âœ“ Created: $KNOWLEDGE_BASE/$subdir/$filename${NC}\"\n    update_index\n}\n\ncase \"$TYPE\" in\n    learning)\n        TOPIC=\"$1\"\n        if [ -z \"$TOPIC\" ]; then\n            echo -e \"${RED}Error: Learning topic required${NC}\"\n            echo \"Usage: $0 learning \\\"topic description\\\"\"\n            exit 1\n        fi\n\n        SLUG=$(slugify \"$TOPIC\")\n        FILENAME=\"$(date +%Y-%m-%d)-${SLUG}.md\"\n\n        CONTENT=\"# Learning: $TOPIC\n\n**Date:** $(date +\"%Y-%m-%d %H:%M:%S\")\n\n## Context\n\n<!-- Add context about when/how this learning was discovered -->\n\n## Learning\n\n<!-- Describe what was learned -->\n\n## Application\n\n<!-- How can this learning be applied in the future? -->\n\n---\n\n*Recorded by qmd-knowledge skill*\"\n\n        create_knowledge_file \"references/learnings\" \"$FILENAME\" \"$CONTENT\"\n        echo \"Edit this file to add details.\"\n        ;;\n\n    issue)\n        ID=\"$1\"\n        NOTE=\"$2\"\n        if [ -z \"$ID\" ]; then\n            echo -e \"${RED}Error: Issue ID required${NC}\"\n            echo \"Usage: $0 issue <id> \\\"note text\\\"\"\n            exit 1\n        fi\n\n        SAFE_ID=$(slugify \"$ID\")\n        if [ -z \"$SAFE_ID\" ]; then\n            echo -e \"${RED}Error: Invalid issue ID '${ID}'${NC}\"\n            exit 1\n        fi\n\n        FILENAME=\"${SAFE_ID}.md\"\n        FILEPATH=\"$KNOWLEDGE_BASE/references/issues/$FILENAME\"\n\n        # Validate and create directory\n        if ! validate_safe_path \"references/issues\" \"$FILENAME\"; then\n            exit 1\n        fi\n        mkdir -p \"$KNOWLEDGE_BASE/references/issues\"\n\n        # Create or append to issue file\n        if [ ! -f \"$FILEPATH\" ]; then\n            echo \"# Issue #$SAFE_ID\n\n## Notes\n\n\" > \"$FILEPATH\"\n        fi\n\n        # Append the note\n        echo \"\n\n### $(date +\"%Y-%m-%d %H:%M:%S\")\n\n${NOTE:-<!-- Add note here -->}\n\n\" >> \"$FILEPATH\"\n\n        echo -e \"${GREEN}âœ“ Added note to issue #$SAFE_ID: $FILEPATH${NC}\"\n        update_index\n        ;;\n\n    note)\n        TEXT=\"$1\"\n        if [ -z \"$TEXT\" ]; then\n            echo -e \"${RED}Error: Note text required${NC}\"\n            echo \"Usage: $0 note \\\"note text\\\"\"\n            exit 1\n        fi\n\n        SLUG=$(slugify \"$TEXT\" | cut -c1-50)\n        FILENAME=\"$(date +%Y-%m-%d)-${SLUG}.md\"\n\n        CONTENT=\"# Note\n\n**Date:** $(date +\"%Y-%m-%d %H:%M:%S\")\n\n$TEXT\n\n---\n\n*Recorded by qmd-knowledge skill*\"\n\n        create_knowledge_file \"references/learnings\" \"$FILENAME\" \"$CONTENT\"\n        ;;\n\n    *)\n        echo -e \"${RED}Error: Unknown type '$TYPE'${NC}\"\n        echo \"\"\n        echo \"Usage:\"\n        echo \"  $0 learning \\\"topic description\\\"\"\n        echo \"  $0 issue <id> \\\"note text\\\"\"\n        echo \"  $0 note \\\"general note text\\\"\"\n        exit 1\n        ;;\nesac\n",
        ".claude-plugin/plugins/ralph/SKILL.md": "---\nname: ralph\ndescription: \"Convert PRDs to prd.json format for the Ralph autonomous agent system. Use when you have an existing PRD and need to convert it to Ralph's JSON format. Triggers on: convert this prd, turn this into ralph format, create prd.json from this, ralph json.\"\nlicense: MIT\ncompatibility: claude, opencode, amp, codex, gemini\nhint: Use when converting PRDs to prd.json format for Ralph autonomous agent system\nmetadata:\n  audience: all\n  workflow: product\n---\n\n# Ralph PRD Converter\n\nConverts existing PRDs to the prd.json format that Ralph uses for autonomous execution.\n\n---\n\n## The Job\n\nTake a PRD (markdown file or text) and convert it to `prd.json` in your ralph directory.\n\n---\n\n## Output Format\n\n```json\n{\n  \"project\": \"[Project Name]\",\n  \"branchName\": \"ralph/[feature-name-kebab-case]\",\n  \"description\": \"[Feature description from PRD title/intro]\",\n  \"userStories\": [\n    {\n      \"id\": \"US-001\",\n      \"title\": \"[Story title]\",\n      \"description\": \"As a [user], I want [feature] so that [benefit]\",\n      \"acceptanceCriteria\": [\n        \"Criterion 1\",\n        \"Criterion 2\",\n        \"Typecheck passes\"\n      ],\n      \"priority\": 1,\n      \"passes\": false,\n      \"notes\": \"\"\n    }\n  ]\n}\n```\n\n---\n\n## Story Size: The Number One Rule\n\n**Each story must be completable in ONE Ralph iteration (one context window).**\n\nRalph spawns a fresh Amp instance per iteration with no memory of previous work. If a story is too big, the LLM runs out of context before finishing and produces broken code.\n\n### Right-sized stories:\n- Add a database column and migration\n- Add a UI component to an existing page\n- Update a server action with new logic\n- Add a filter dropdown to a list\n\n### Too big (split these):\n- \"Build the entire dashboard\" - Split into: schema, queries, UI components, filters\n- \"Add authentication\" - Split into: schema, middleware, login UI, session handling\n- \"Refactor the API\" - Split into one story per endpoint or pattern\n\n**Rule of thumb:** If you cannot describe the change in 2-3 sentences, it is too big.\n\n---\n\n## Story Ordering: Dependencies First\n\nStories execute in priority order. Earlier stories must not depend on later ones.\n\n**Correct order:**\n1. Schema/database changes (migrations)\n2. Server actions / backend logic\n3. UI components that use the backend\n4. Dashboard/summary views that aggregate data\n\n**Wrong order:**\n1. UI component (depends on schema that does not exist yet)\n2. Schema change\n\n---\n\n## Acceptance Criteria: Must Be Verifiable\n\nEach criterion must be something Ralph can CHECK, not something vague.\n\n### Good criteria (verifiable):\n- \"Add `status` column to tasks table with default 'pending'\"\n- \"Filter dropdown has options: All, Active, Completed\"\n- \"Clicking delete shows confirmation dialog\"\n- \"Typecheck passes\"\n- \"Tests pass\"\n\n### Bad criteria (vague):\n- \"Works correctly\"\n- \"User can do X easily\"\n- \"Good UX\"\n- \"Handles edge cases\"\n\n### Always include as final criterion:\n```\n\"Typecheck passes\"\n```\n\nFor stories with testable logic, also include:\n```\n\"Tests pass\"\n```\n\n### For stories that change UI, also include:\n```\n\"Verify in browser using dev-browser skill\"\n```\n\nFrontend stories are NOT complete until visually verified. Ralph will use the dev-browser skill to navigate to the page, interact with the UI, and confirm changes work.\n\n---\n\n## Conversion Rules\n\n1. **Each user story becomes one JSON entry**\n2. **IDs**: Sequential (US-001, US-002, etc.)\n3. **Priority**: Based on dependency order, then document order\n4. **All stories**: `passes: false` and empty `notes`\n5. **branchName**: Derive from feature name, kebab-case, prefixed with `ralph/`\n6. **Always add**: \"Typecheck passes\" to every story's acceptance criteria\n\n---\n\n## Splitting Large PRDs\n\nIf a PRD has big features, split them:\n\n**Original:**\n> \"Add user notification system\"\n\n**Split into:**\n1. US-001: Add notifications table to database\n2. US-002: Create notification service for sending notifications\n3. US-003: Add notification bell icon to header\n4. US-004: Create notification dropdown panel\n5. US-005: Add mark-as-read functionality\n6. US-006: Add notification preferences page\n\nEach is one focused change that can be completed and verified independently.\n\n---\n\n## Example\n\n**Input PRD:**\n```markdown\n# Task Status Feature\n\nAdd ability to mark tasks with different statuses.\n\n## Requirements\n- Toggle between pending/in-progress/done on task list\n- Filter list by status\n- Show status badge on each task\n- Persist status in database\n```\n\n**Output prd.json:**\n```json\n{\n  \"project\": \"TaskApp\",\n  \"branchName\": \"ralph/task-status\",\n  \"description\": \"Task Status Feature - Track task progress with status indicators\",\n  \"userStories\": [\n    {\n      \"id\": \"US-001\",\n      \"title\": \"Add status field to tasks table\",\n      \"description\": \"As a developer, I need to store task status in the database.\",\n      \"acceptanceCriteria\": [\n        \"Add status column: 'pending' | 'in_progress' | 'done' (default 'pending')\",\n        \"Generate and run migration successfully\",\n        \"Typecheck passes\"\n      ],\n      \"priority\": 1,\n      \"passes\": false,\n      \"notes\": \"\"\n    },\n    {\n      \"id\": \"US-002\",\n      \"title\": \"Display status badge on task cards\",\n      \"description\": \"As a user, I want to see task status at a glance.\",\n      \"acceptanceCriteria\": [\n        \"Each task card shows colored status badge\",\n        \"Badge colors: gray=pending, blue=in_progress, green=done\",\n        \"Typecheck passes\",\n        \"Verify in browser using dev-browser skill\"\n      ],\n      \"priority\": 2,\n      \"passes\": false,\n      \"notes\": \"\"\n    },\n    {\n      \"id\": \"US-003\",\n      \"title\": \"Add status toggle to task list rows\",\n      \"description\": \"As a user, I want to change task status directly from the list.\",\n      \"acceptanceCriteria\": [\n        \"Each row has status dropdown or toggle\",\n        \"Changing status saves immediately\",\n        \"UI updates without page refresh\",\n        \"Typecheck passes\",\n        \"Verify in browser using dev-browser skill\"\n      ],\n      \"priority\": 3,\n      \"passes\": false,\n      \"notes\": \"\"\n    },\n    {\n      \"id\": \"US-004\",\n      \"title\": \"Filter tasks by status\",\n      \"description\": \"As a user, I want to filter the list to see only certain statuses.\",\n      \"acceptanceCriteria\": [\n        \"Filter dropdown: All | Pending | In Progress | Done\",\n        \"Filter persists in URL params\",\n        \"Typecheck passes\",\n        \"Verify in browser using dev-browser skill\"\n      ],\n      \"priority\": 4,\n      \"passes\": false,\n      \"notes\": \"\"\n    }\n  ]\n}\n```\n\n---\n\n## Archiving Previous Runs\n\n**Before writing a new prd.json, check if there is an existing one from a different feature:**\n\n1. Read the current `prd.json` if it exists\n2. Check if `branchName` differs from the new feature's branch name\n3. If different AND `progress.txt` has content beyond the header:\n   - Create archive folder: `archive/YYYY-MM-DD-feature-name/`\n   - Copy current `prd.json` and `progress.txt` to archive\n   - Reset `progress.txt` with fresh header\n\n**The ralph.sh script handles this automatically** when you run it, but if you are manually updating prd.json between runs, archive first.\n\n---\n\n## Checklist Before Saving\n\nBefore writing prd.json, verify:\n\n- [ ] **Previous run archived** (if prd.json exists with different branchName, archive it first)\n- [ ] Each story is completable in one iteration (small enough)\n- [ ] Stories are ordered by dependency (schema to backend to UI)\n- [ ] Every story has \"Typecheck passes\" as criterion\n- [ ] UI stories have \"Verify in browser using dev-browser skill\" as criterion\n- [ ] Acceptance criteria are verifiable (not vague)\n- [ ] No story depends on a later story\n",
        ".claude-plugin/plugins/slop/SKILL.md": "---\nname: slop\ndescription: Removes AI-generated code slop from git diffs to maintain code quality\nlicense: MIT\ncompatibility: claude, opencode, amp, codex, gemini\nhint: Use when cleaning up AI-generated code slop in git diffs\nmetadata:\n  audience: all\n  workflow: code-quality\n---\n\n# Remove AI Code Slop\n\nCheck the diff against a branch and remove all AI-generated slop introduced in this branch. Simplifies and refines code for clarity, consistency, and maintainability while preserving all functionality.\n\n## Usage\n\n`/slop [branch-name]`\n\n- If no branch is provided, compare against main: `/slop main`\n\n## What is AI Code Slop?\n\nThis includes:\n- Extra comments that a human wouldn't add or is inconsistent with the rest of the file\n- Extra defensive checks or try/catch blocks that are abnormal for that area of the codebase\n- Casts to `any` to get around type issues\n- Any other style that is inconsistent with the file\n\n## Core Principles\n\n### 1. Preserve Functionality\nNever change what the code does - only how it does it. All original features, outputs, and behaviors must remain intact.\n\n### 2. Apply Project Standards\nFollow the established coding standards from the project's CLAUDE.md or conventions:\n- Use proper import sorting and file organization\n- Follow language-specific patterns (ES modules, proper TypeScript types, etc.)\n- Maintain consistent naming conventions\n- Use proper error handling patterns\n\n### 3. Enhance Clarity\nSimplify code structure by:\n- Reducing unnecessary complexity and nesting\n- Eliminating redundant code and abstractions\n- Improving readability through clear variable and function names\n- Consolidating related logic\n- Removing unnecessary comments that describe obvious code\n- **IMPORTANT**: Avoid nested ternary operators - prefer switch statements or if/else chains\n- Choose clarity over brevity - explicit code is often better than overly compact code\n\n### 4. Maintain Balance\nAvoid over-simplification that could:\n- Reduce code clarity or maintainability\n- Create overly clever solutions that are hard to understand\n- Combine too many concerns into single functions\n- Remove helpful abstractions that improve code organization\n- Prioritize \"fewer lines\" over readability\n\n## Process\n\n### 1. Get the diff\n\n```bash\n# Compare against main branch\ngit diff main...HEAD --stat\n\n# Or against specific branch\ngit diff $1 --stat\n```\n\n### 2. Review each changed file\n\nFor each changed file:\n- Read the current content\n- Compare with original (before changes)\n- Identify AI-generated slop patterns\n- Check for opportunities to improve elegance and consistency\n\n### 3. Remove slop and refine\n\n- Remove unnecessary comments\n- Simplify overly defensive code\n- Remove `any` casts where possible\n- Restore natural code style\n- Apply project-specific best practices\n- Ensure all functionality remains unchanged\n\n### 4. Verify\n\n```bash\n# Show remaining changes\ngit diff --stat\n\n# Check tests still pass\nnpm test\n```\n\n## Common Slop Patterns\n\n1. **Over-commenting**: Comments explaining obvious code\n2. **Verbose error handling**: Try/catch blocks where not needed\n3. **Unnecessary type casts**: `x as any` to bypass TypeScript\n4. **Defensive programming**: Checks for already-validated inputs\n5. **Redundant validation**: Duplicate null/undefined checks\n6. **Nested ternaries**: Complex nested ternary operators\n7. **Overly compact code**: Dense one-liners that sacrifice readability\n\n## Refinement Guidelines\n\nWhen refining code:\n\n1. **Identify the modified sections** - Only refine code that changed in the diff\n2. **Analyze for improvement opportunities** - Look for ways to enhance elegance and consistency\n3. **Apply project standards** - Follow established conventions and patterns\n4. **Preserve functionality** - Ensure behavior remains unchanged\n5. **Verify improvements** - The refined code should be simpler and more maintainable\n6. **Document significant changes** - Only document changes that affect understanding\n\n### Code Style Preferences\n\n- Prefer explicit over compact - readable code beats clever code\n- Use descriptive names - clarity over brevity\n- Avoid deep nesting - flatten structure when possible\n- Remove redundant code - eliminate duplicates\n- Use language-appropriate patterns - follow idiomatic practices\n",
        ".claude-plugin/plugins/tdd/SKILL.md": "---\nname: tdd\ndescription: Guides through the complete TDD workflow with Red-Green-Refactor cycle\nlicense: MIT\ncompatibility: claude, opencode, amp, codex, gemini\nhint: Use when doing test-driven development with Red-Green-Refactor cycle\nmetadata:\n  audience: all\n  workflow: testing\n---\n\n# Test-Driven Development (TDD)\n\nGuides you through the complete TDD workflow with Red-Green-Refactor cycle.\n\n## Usage\n\n`/tdd <ACTION> [ARGUMENTS]`\n\n## Actions\n\n- **start <FEATURE>** - Initialize TDD session for a feature\n- **red <TEST_NAME>** - Create failing test (Red phase)\n- **green** - Run tests and implement code (Green phase)\n- **refactor** - Guide refactoring process (Refactor phase)\n- **cycle <FEATURE>** - Run complete Red-Green-Refactor cycle\n- **watch** - Start test watcher for continuous feedback\n- **status** - Show current test status and next steps\n- **help** - Show this help\n\n## TDD Principles\n\n### The Red-Green-Refactor Cycle\n\n1. **Red**: Write a failing test that defines desired behavior\n2. **Green**: Write minimal code to make the test pass\n3. **Refactor**: Improve code quality while keeping tests green\n\n### Best Practices\n\n- Write tests first - Tests define the interface and behavior\n- Small steps - Make tiny, incremental changes\n- Fast feedback - Run tests frequently for immediate validation\n- Clean code - Refactor regularly to maintain quality\n- One concept per test - Keep tests focused and atomic\n- AAA Pattern - Structure tests as Arrange, Act, Assert\n- Black-box testing - Test only public methods and behavior, not implementation details\n\n## Process\n\n### For \"start <FEATURE>\":\n\n1. Initialize TDD session for the feature\n2. Create or identify target source file\n3. Create corresponding test file if it doesn't exist\n4. Explain the feature requirements and acceptance criteria\n\n### For \"red <TEST_NAME>\":\n\n1. Create a failing test that describes the desired behavior\n2. Ensure test fails for the right reason (not syntax errors)\n3. Run tests to confirm red state\n4. Explain what the test is validating\n\n### For \"green\":\n\n1. Implement minimal code to make failing tests pass\n2. Focus on making tests pass, not perfect code\n3. Run tests to confirm green state\n4. Avoid over-engineering at this stage\n\n### For \"refactor\":\n\n1. Improve code quality while maintaining green tests\n2. Remove duplication and improve design\n3. Run tests continuously during refactoring\n4. Make one refactoring change at a time\n\n## Test Template\n\nA test template is available at `$SKILL_PATH/templates/test-template.md`:\n\n```typescript\nimport { describe, it, expect } from 'vitest'\nimport { functionName } from './module'\n\ndescribe('functionName', () => {\n  it('should return formatted output when given valid input', () => {\n    // Arrange - Setup test scenario\n    const input = 'test input'\n    const expectedOutput = 'expected output'\n\n    // Act - Execute the unit under test\n    const result = functionName(input)\n\n    // Assert - Verify expected outcome\n    expect(result).toBe(expectedOutput)\n  })\n})\n```\n\n## Common Commands\n\n- Run tests: `npm test` or `pnpm test`\n- Watch mode: `npm test --watch`\n- With coverage: `npm test --coverage`\n",
        ".claude-plugin/plugins/tdd/templates/test-template.md": "import { describe, it, expect } from 'vitest'\nimport { functionName } from './module'\n\ndescribe('functionName', () => {\n  it('should return formatted output when given valid input', () => {\n    // Arrange - Setup test scenario\n    const input = 'test input'\n    const expectedOutput = 'expected output'\n\n    // Act - Execute the unit under test\n    const result = functionName(input)\n\n    // Assert - Verify expected outcome\n    expect(result).toBe(expectedOutput)\n  })\n})\n"
      },
      "plugins": [
        {
          "name": "prd",
          "description": "Generate Product Requirements Documents (PRD) for new features. Use when planning features, starting projects, or creating specifications.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/prd",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install prd@my-ai-tools"
          ]
        },
        {
          "name": "ralph",
          "description": "Convert PRDs to prd.json format for the Ralph autonomous agent system. Converts markdown PRDs to Ralph's JSON format.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/ralph",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install ralph@my-ai-tools"
          ]
        },
        {
          "name": "qmd-knowledge",
          "description": "Project-specific knowledge management system using qmd MCP server. Captures learnings, issue notes, and conventions in a searchable knowledge base.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/qmd-knowledge",
          "category": "productivity",
          "homepage": "https://github.com/jellydn/my-ai-tools",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install qmd-knowledge@my-ai-tools"
          ]
        },
        {
          "name": "codemap",
          "description": "Orchestrate parallel codebase analysis to produce 7 structured documents (STACK, INTEGRATIONS, ARCHITECTURE, STRUCTURE, CONVENTIONS, TESTING, CONCERNS) in .planning/codebase/.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/codemap",
          "category": "productivity",
          "homepage": "https://github.com/jellydn/my-ai-tools",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install codemap@my-ai-tools"
          ]
        },
        {
          "name": "adr",
          "description": "Manages Architecture Decision Records (ADR) for tracking important architectural decisions. Initialize, create, list, search, and view ADRs.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/adr",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install adr@my-ai-tools"
          ]
        },
        {
          "name": "handoffs",
          "description": "Creates detailed handoff plans of conversations for continuing work in new sessions. Capture context, technical decisions, and pending tasks for seamless session continuation.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/handoffs",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install handoffs@my-ai-tools"
          ]
        },
        {
          "name": "pickup",
          "description": "Resumes work from a previous handoff session stored in .claude/handoffs/. Load and continue from where you left off in prior sessions.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/pickup",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install pickup@my-ai-tools"
          ]
        },
        {
          "name": "pr-review",
          "description": "Fix PR review comments by implementing requested changes. Fetch review comments, implement fixes, run tests, and commit changes.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/pr-review",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install pr-review@my-ai-tools"
          ]
        },
        {
          "name": "slop",
          "description": "Removes AI-generated code slop from git diffs to maintain code quality. Clean up extra comments, defensive checks, type casts, and inconsistent style.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/slop",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install slop@my-ai-tools"
          ]
        },
        {
          "name": "tdd",
          "description": "Guides through the complete TDD workflow with Red-Green-Refactor cycle. Start features, write failing tests, implement minimal code, and refactor with confidence.",
          "version": "1.0.0",
          "author": {
            "name": "Dung Huynh Duc",
            "email": "dung@productsway.com"
          },
          "source": "./.claude-plugin/plugins/tdd",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add jellydn/my-ai-tools",
            "/plugin install tdd@my-ai-tools"
          ]
        }
      ]
    }
  ]
}