{
  "author": {
    "id": "mattheworiordan",
    "display_name": "Matthew O'Riordan",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/43789?u=43ef26d2ca36b7bebb7fcbd4d2380444d0212e5e&v=4",
    "url": "https://github.com/mattheworiordan",
    "bio": "CEO & technical co-founder of @ably, a realtime data delivery platform",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 5,
      "total_skills": 0,
      "total_stars": 4,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "colony-plugins",
      "version": null,
      "description": "Task decomposition and parallel execution plugins for Claude Code",
      "owner_info": {
        "name": "Matthew O'Riordan",
        "email": "matthew@oriordan.org"
      },
      "keywords": [],
      "repo_full_name": "mattheworiordan/colony",
      "repo_url": "https://github.com/mattheworiordan/colony",
      "repo_description": "Parallel execution with independent verification for Claude Code - same speed, better quality, because AI shouldn't check its own homework",
      "homepage": "",
      "signals": {
        "stars": 4,
        "forks": 1,
        "pushed_at": "2026-01-21T15:01:50Z",
        "created_at": "2026-01-15T14:49:56Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 684
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 324
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 23781
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/inspector.md",
          "type": "blob",
          "size": 4220
        },
        {
          "path": "agents/summarizer.md",
          "type": "blob",
          "size": 2053
        },
        {
          "path": "agents/worker.md",
          "type": "blob",
          "size": 3374
        },
        {
          "path": "benchmarks",
          "type": "tree",
          "size": null
        },
        {
          "path": "benchmarks/README.md",
          "type": "blob",
          "size": 3738
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/colony-deploy.md",
          "type": "blob",
          "size": 25100
        },
        {
          "path": "commands/colony-mobilize.md",
          "type": "blob",
          "size": 24381
        },
        {
          "path": "commands/colony-projects.md",
          "type": "blob",
          "size": 2903
        },
        {
          "path": "commands/colony-quick.md",
          "type": "blob",
          "size": 5727
        },
        {
          "path": "commands/colony-status.md",
          "type": "blob",
          "size": 3163
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"colony-plugins\",\n  \"description\": \"Task decomposition and parallel execution plugins for Claude Code\",\n  \"owner\": {\n    \"name\": \"Matthew O'Riordan\",\n    \"email\": \"matthew@oriordan.org\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"colony\",\n      \"description\": \"Decompose complex tasks into parallel sub-tasks with independent verification\",\n      \"version\": \"1.1.0\",\n      \"author\": {\n        \"name\": \"Matthew O'Riordan\",\n        \"email\": \"matthew@oriordan.org\"\n      },\n      \"source\": \"./\",\n      \"category\": \"productivity\",\n      \"homepage\": \"https://github.com/mattheworiordan/colony\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"colony\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Decompose complex tasks into parallel sub-tasks with independent verification â€” like a colony of AI workers\",\n  \"author\": {\n    \"name\": \"Matthew O'Riordan\",\n    \"email\": \"matthew@oriordan.org\"\n  },\n  \"repository\": \"https://github.com/mattheworiordan/colony\"\n}\n",
        "README.md": "# Colony\n\n<img src=\"assets/colony-logo.jpg\" alt=\"Colony\" width=\"300\">\n\n**Your AI swarm for serious software engineering.**\n\nColony turns Claude Code into a parallel task execution engine with independent verification. Give it a complex task, and it spawns a colony of specialized workersâ€”each with fresh context, each verified by an independent inspector.\n\n> **Like Ralph, but built for real work.** Where Ralph iterates sequentially and checks its own homework, Colony intelligently parallelizes work with independent QA. Human-in-the-loop or fully autonomous. Git-aware. Production-ready.\n\n---\n\n## See It In Action\n\n<img src=\"assets/colony-deploy-animated.gif\" alt=\"Colony deploying tasks\" width=\"700\">\n\n**Smart Mobilization** â€” Colony analyzes your brief, identifies parallelization opportunities, and prepares tasks for execution:\n\n<img src=\"assets/colony-mobilizing.png\" alt=\"Colony mobilization phase\" width=\"700\">\n\n**Dependency-Aware Deployment** â€” Tasks deploy in parallel where safe, serialize where necessary:\n\n<img src=\"assets/colony-mobilized.png\" alt=\"Colony execution plan\" width=\"700\">\n\n**Simple Commands** â€” Everything accessible via `/colony-*` commands:\n\n<img src=\"assets/colony-commands.png\" alt=\"Colony commands\" width=\"700\">\n\n---\n\n## Why Colony Wins\n\n### v1.2.0: Same Speed, Dramatically Better Quality\n\nMeasured on the same task ([Kitty Keyboard Protocol](https://github.com/vadimdemedes/ink/issues/824) implementation), same codebase, same starting point:\n\n| Metric | Ralph | Colony v1.2 | Winner |\n|--------|-------|-------------|--------|\n| **Runtime** | 12m 39s | ~12 min | Tie |\n| **Lint Errors** | 419 | 0 | **Colony** |\n| **Lines of Code** | 537 | 165 | **Colony** (3.3x leaner) |\n| **PR Ready?** | No (needs cleanup) | Yes | **Colony** |\n\n**The real comparison:** Ralph's 12-minute run produces code needing ~1 hour of cleanup. Colony's 12-minute run produces code ready to merge.\n\n> ğŸ“Š **Reproducible benchmarks**: See [`benchmarks/`](./benchmarks/) for the test brief, methodology, and step-by-step reproduction instructions.\n\n### Feature Comparison\n\n| Capability | Traditional AI | Ralph | Colony |\n|------------|----------------|-------|--------|\n| **Context** | Drifts after 10+ exchanges | Full reset each iteration | Fresh context per task |\n| **Verification** | \"Done!\" (it wasn't) | Checks its own homework | Independent inspector |\n| **Code Quality** | Variable | 419 lint errors | **0 lint errors** |\n| **Speed** | One thing at a time | Single-threaded | Intelligent parallelization |\n| **Oversight** | All or nothing | Autonomous only | Human-in-loop or autonomous |\n| **Git workflow** | Manual | Manual | Automatic branch + commits |\n| **Recovery** | Start over | Coarse progress file | Task-level resume |\n| **Audit trail** | Nothing | Progress notes | Full execution logs |\n\n---\n\n## Colony + Claude Plan Mode\n\nColony is designed to **complement** Claude's native plan mode, not compete with it.\n\n### The Workflow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. PLAN (Claude Native)                                        â”‚\nâ”‚     claude --permission-mode plan                               â”‚\nâ”‚     â†’ Strategic thinking, requirements, approach                â”‚\nâ”‚     â†’ Output: ~/.claude/plans/your-plan.md                      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                              â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  2. MOBILIZE (Colony)                                           â”‚\nâ”‚     /colony-mobilize                                            â”‚\nâ”‚     â†’ Task decomposition, parallelization, dependencies         â”‚\nâ”‚     â†’ Output: .working/colony/{project}/tasks/                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                              â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  3. DEPLOY (Colony)                                             â”‚\nâ”‚     /colony-deploy                                              â”‚\nâ”‚     â†’ Parallel execution with independent verification          â”‚\nâ”‚     â†’ Output: Working code, logs, report                        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Why Not Just Use Claude's Execution?\n\nWhen you exit plan mode, Claude implements sequentially. Colony does it better:\n\n| Aspect | Native Execution | Colony Execution |\n|--------|------------------|------------------|\n| **Parallelization** | Sequential | Intelligent parallel |\n| **Verification** | Self-check | Independent inspector |\n| **Context** | Accumulates (drifts) | Fresh per task |\n| **Recovery** | Start over | Resume from exact task |\n| **Quality** | Variable | 0 lint errors (benchmarked) |\n\n**Use Claude plan mode for thinking. Use Colony for doing.**\n\n---\n\n## Key Features\n\n### Intelligent Parallelization\nColony doesn't just run things in parallelâ€”it *thinks* about what can safely parallelize:\n\n- **Dependency analysis** â€” Understands task dependencies and serializes when needed\n- **Resource awareness** â€” Knows when tasks touch the same files and avoids conflicts\n- **Asks when uncertain** â€” Won't guess on parallelization safety; asks you instead\n- **Dynamic adjustment** â€” Change concurrency mid-run: `\"set concurrency to 3\"`\n\n### Two Execution Modes\n\n**Human-in-the-Loop (default)**\n- Checkpoints between phases for review\n- Approve parallelization decisions\n- Intervene on failures before retrying\n\n**Fully Autonomous**\n- Run overnight without interruption\n- Safety limits prevent runaway failures (max retries, failure thresholds)\n- Complete report waiting for you in the morning\n\n```bash\n/colony-deploy              # Interactive mode\n/colony-deploy autonomous   # Autonomous mode\n```\n\n### Git-Aware Workflow\nColony understands your git workflow and integrates seamlessly:\n\n- **Branch strategy** â€” Creates feature branches or works on current branch\n- **Smart commits** â€” After each task, phase, or at project end (you choose)\n- **Conventional commits** â€” Proper commit messages with Co-Authored-By attribution\n- **Conflict prevention** â€” Won't parallelize tasks that touch the same files\n\n### Independent Verification\nEvery task completion is verified by a separate inspector agent:\n\n- **Fresh context** â€” Inspector has no knowledge of worker's struggles or workarounds\n- **Acceptance criteria** â€” Checks every criterion, not just \"does it compile\"\n- **Visual verification** â€” `VISUAL:` criteria trigger screenshot capture and validation\n- **No self-deception** â€” Worker can't mark itself complete; inspector decides\n\n### Full Recovery\nInterrupted? Pick up exactly where you left off:\n\n- **Structured state** â€” All progress saved to `state.json`\n- **Task-level granularity** â€” Resume from the exact task that was interrupted\n- **Execution logs** â€” Every task has detailed logs of what happened\n- **Artifact validation** â€” Screenshots and logs must exist before marking complete\n\n---\n\n## The Problem With AI Coding Today\n\nWhen tackling large, multi-step coding tasks, AI assistants struggle with:\n\n- **Context drift** â€” forgetting requirements after many interactions\n- **Verification gaps** â€” claiming completion without proper testing\n- **Sequential bottlenecks** â€” not leveraging concurrent execution\n- **Lost progress** â€” no recovery when interrupted\n- **Invisible work** â€” no summary of what was done\n\n**Colony solves all of this.** Specialized worker agents execute tasks in parallel. Independent inspector agents verify every completion. Everything logged, everything recoverable.\n\n## Installation\n\n### Option 1: Install from Marketplace (Recommended)\n\n```bash\n# In Claude Code, add the Colony marketplace and install\n/plugin marketplace add mattheworiordan/colony\n/plugin install colony\n```\n\n### Option 2: Manual Installation\n\n```bash\n# Clone the repository\ngit clone https://github.com/mattheworiordan/colony.git ~/.claude/plugins/colony\n```\n\nAfter cloning, the plugin is automatically available. Restart Claude Code if it's already running.\n\n### Option 3: Project-Local Installation\n\nTo use Colony in a specific project only:\n\n```bash\n# Clone into your project\ngit clone https://github.com/mattheworiordan/colony.git .claude-plugins/colony\n\n# Run Claude Code with the plugin directory\nclaude --plugin-dir .claude-plugins/colony\n```\n\n### Verify Installation\n\nAfter installation, run `/help` in Claude Code â€” you should see the `/colony-*` commands listed.\n\n**CLI Tool**\n\nColony includes a CLI tool (`bin/colony`) for state management. The plugin commands reference it via `${CLAUDE_PLUGIN_ROOT}/bin/colony`, so no PATH setup is needed - it works automatically.\n\nFor manual CLI usage outside of Claude Code, you can optionally add it to your PATH or create a symlink.\n\n**Community Registry**: Colony is also indexed at [claude-plugins.dev](https://claude-plugins.dev/), which automatically discovers Claude Code plugins on GitHub.\n\n### Working Directory Convention\n\nColony stores all project state in a `.working/colony/` directory within your project. This includes task files, execution logs, screenshots, and reports.\n\n**Recommendation**: Add `.working/` to your global gitignore to avoid committing Colony's working files:\n\n```bash\n# Add to your global gitignore\necho \".working/\" >> ~/.gitignore_global\ngit config --global core.excludesfile ~/.gitignore_global\n```\n\nAlternatively, add `.working/` to your project's `.gitignore` if you prefer per-project configuration.\n\n## Quick Start\n\n### Recommended: Start with Claude Plan Mode\n\nFor complex features, let Claude help you think through requirements first:\n\n```bash\n# 1. Use Claude's plan mode to define requirements\nclaude --permission-mode plan\n> I need to add OAuth2 authentication. Interview me about requirements.\n\n# 2. Claude creates a plan in ~/.claude/plans/\n# 3. Mobilize Colony with that plan\n/colony-mobilize\n\n# 4. Colony auto-detects the recent plan, or specify:\n/colony-mobilize ~/.claude/plans/gleaming-sniffing-bird.md\n\n# 5. Deploy\n/colony-deploy\n```\n\n### Option 1: Create a Brief File\n\n```bash\n# 1. Create a brief describing what you want to accomplish\ncat > .working/MY_FEATURE_BRIEF.md << 'EOF'\n# Add User Authentication\n\n## Goal\nAdd login/logout functionality with session management.\n\n## Requirements\n- [ ] Login form with email/password\n- [ ] Session storage in localStorage\n- [ ] Protected routes redirect to login\n- [ ] Logout clears session\nEOF\n\n# 2. Plan the tasks\n/colony-mobilize .working/MY_FEATURE_BRIEF.md\n\n# 3. Review the decomposition, then run\n/colony-deploy\n```\n\n### Option 2: Point to Any File\n\nYou can use any markdown file as a brief â€” it doesn't need to be in `.working/`:\n\n```bash\n# Use a file from docs/\n/colony-mobilize docs/FEATURE_SPEC.md\n\n# Use a file from anywhere\n/colony-mobilize ~/Desktop/my-project-plan.md\n```\n\n### Option 3: Describe Inline\n\nIf you don't have a brief file, just run `/colony-mobilize` and describe what you want:\n\n```bash\n/colony-mobilize\n# Colony will ask: \"I didn't find any brief files. You can:\n#   1. Tell me the path to your brief\n#   2. Paste the tasks directly here\n#   3. Describe what you want to accomplish\"\n```\n\n### Option 4: Quick Tasks\n\nFor simple, well-defined tasks, skip the planning phase entirely:\n\n```bash\n/colony-quick \"Add a loading spinner to the submit button\"\n```\n\n## Brief Discovery\n\nWhen you run `/colony-mobilize` without specifying a file, Colony searches for potential briefs in:\n\n1. **`~/.claude/plans/*.md`** - Recent Claude plans (last 48 hours), ranked by relevance to current project\n2. **`.working/*.md`** - The conventional location for working documents\n3. **`docs/*.md`** - Documentation folder\n4. **Root `.md` files** - Excluding README, CHANGELOG, LICENSE\n\nIf multiple candidates are found, Colony shows them ranked by relevance and asks which to use. If none are found, you can provide a path or describe your requirements directly.\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/colony-mobilize [brief]` | Prepare tasks from a brief or Claude plan |\n| `/colony-deploy [project]` | Deploy workers with verification |\n| `/colony-deploy autonomous` | Deploy without human checkpoints |\n| `/colony-status [project]` | Show detailed project status |\n| `/colony-projects` | List all colony projects |\n| `/colony-quick \"prompt\"` | Quick execution for simple tasks |\n\n## How It Works\n\n### 1. Mobilization Phase (`/colony-mobilize`)\n\n- Finds a brief file or Claude plan (auto-detects recent plans)\n- Analyzes the codebase for parallelization opportunities\n- Decomposes work into executable tasks\n- Identifies shared patterns to prevent duplication (DRY)\n- Detects project standards (linter, CLAUDE.md, etc.)\n- Sets up Git strategy (branch, commit frequency)\n\n### 2. Deployment Phase (`/colony-deploy`)\n\n- Spawns isolated **worker** agents for each task\n- Runs tasks in parallel where safe\n- Independent **inspector** agents verify each completion\n- Automatic retry on failure (up to 3 attempts)\n- Git commits at phase boundaries\n- Comprehensive report generation\n\n### 3. Key Features\n\n**Context Isolation**: Each worker runs in a fresh context with only the information it needs. No context drift from accumulated conversation history.\n\n**Independent Verification**: A separate inspector agent checks every \"DONE\" claim. Catches workarounds, missing criteria, and design intent violations.\n\n**Smart Parallelization**: Analyzes dependencies and resource constraints. Asks when uncertain. Serializes browser tests, database migrations, etc.\n\n**Artifact Validation**: Log files and screenshots must exist before marking complete. Never trusts agent claims without filesystem proof.\n\n**Recovery**: All state persisted to JSON. Pick up exactly where you left off if interrupted.\n\n**Autonomous Mode**: Run overnight without checkpoints. Safety limits prevent runaway failures.\n\n## Project Structure\n\nWhen you run `/colony-mobilize`, it creates:\n\n```\n.working/colony/{project-name}/\nâ”œâ”€â”€ context.md              # Project rules, tech stack, parallelization\nâ”œâ”€â”€ state.json              # Task status, Git config, execution log\nâ”œâ”€â”€ tasks/\nâ”‚   â”œâ”€â”€ T001.md            # Individual task files\nâ”‚   â”œâ”€â”€ T002.md\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ logs/\nâ”‚   â”œâ”€â”€ T001_LOG.md        # Execution + verification logs\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ screenshots/            # Visual verification evidence\nâ”œâ”€â”€ resources/\nâ”‚   â””â”€â”€ original-brief.md  # Copy of source brief\nâ””â”€â”€ REPORT.md              # Final execution report\n```\n\n## Colony vs Ralph\n\n[Ralph](https://www.cursor.com/blog/ralf) popularized autonomous AI coding with a clever while-loop approach. Colony takes it further.\n\n### The Key Insight\n\n**Ralph's weakness**: It checks its own homework. The same model that claims \"done\" also decides if it's really done. That's like asking a student to grade their own test.\n\n**Colony's answer**: Independent verification. A separate inspector agentâ€”with fresh context and no ego investmentâ€”verifies every completion. It catches workarounds, missing criteria, and \"works on my machine\" claims.\n\n### Head-to-Head (v1.2.0 Benchmarks)\n\nBoth approaches ran the same task: implement [Kitty Keyboard Protocol](https://github.com/vadimdemedes/ink/issues/824) for the [Ink](https://github.com/vadimdemedes/ink) React CLI framework.\n\n| Metric | Colony | Ralph |\n|--------|--------|-------|\n| **Runtime** | ~12 min | 12m 39s |\n| **Lint Errors** | **0** | 419 |\n| **Lines of Code** | **165** | 537 |\n| **Time to Merge** | **12 min** | ~72 min (with cleanup) |\n\n> See [`benchmarks/v1.2-results.md`](./benchmarks/v1.2-results.md) for detailed methodology and quality scoring.\n\n### Feature Comparison\n\n| Capability | Colony | Ralph |\n|------------|--------|------|\n| **Parallelization** | Intelligentâ€”analyzes dependencies, asks when uncertain | Single-threaded |\n| **Execution modes** | Human-in-the-loop or fully autonomous | Single mode |\n| **Verification** | Independent inspector agent | Self-check (same model) |\n| **Code Quality** | Linter integrated, 0 errors | No lint check, 419 errors |\n| **Context** | Fresh per-task | Full reset each iteration |\n| **Git workflow** | Branch strategy, smart commits, conflict prevention | Manual |\n| **Visual testing** | Built-in screenshot verification | Manual |\n| **Recovery** | Precise task-level resume | Coarse progress file |\n| **Audit trail** | Complete execution logs per task | Progress notes |\n\n### When to Use Each\n\n**Choose Colony when:**\n- You need production-ready code (0 lint errors)\n- Work can be parallelized (most real projects)\n- You need proof that tasks are actually complete\n- Multiple people need to understand what happened\n- You're building code that goes straight to PR\n\n**Choose Ralph when:**\n- Tasks are strictly sequential\n- You want zero setup (just a prompt pattern)\n- You're exploring/prototyping (quality doesn't matter yet)\n- You have time for manual cleanup afterward\n\n### The Bottom Line\n\nRalph proved autonomous AI coding works. Colony makes it production-ready.\n\n**Speed**: Same execution time (~12 min).\n**Quality**: 0 lint errors vs 419. 3.3x less code for same feature.\n**Trust**: Independent verification catches what self-assessment misses.\n**Time to merge**: Colony code is PR-ready. Ralph code needs cleanup.\n\n> ğŸ§ª **Try it yourself**: The [`benchmarks/`](./benchmarks/) folder contains everything you need to reproduce this comparison.\n\n## Configuration\n\nColony can be configured via `~/.colony/config.json`. This file is created automatically on first run with sensible defaults.\n\n### Config File\n\n```json\n{\n  \"working_dir\": \".working\",\n  \"models\": {\n    \"orchestrator\": \"default\",\n    \"worker\": \"default\",\n    \"inspector\": \"default\"\n  }\n}\n```\n\nUse `\"default\"` to follow Colony's recommended settings (may change in future versions).\nUse a specific model name to lock in your preference.\n\n### Model Roles\n\n| Role | What it does | Default | Recommendation |\n|------|--------------|---------|----------------|\n| `orchestrator` | Coordinates tasks, manages state, spawns workers/inspectors | `sonnet` | `sonnet` - must reliably follow complex prompts |\n| `worker` | Implements code, runs tests, creates files | `inherit` | `inherit` - needs full reasoning power |\n| `inspector` | Verifies task completion, checks criteria | `haiku` | `haiku` - verification is simpler |\n\n> **Note:** Haiku was tried for orchestrator in v1.2 but proved too weak to reliably spawn inspectors. Sonnet provides the right balance of speed and capability for orchestration.\n\n### Model Options\n\n- **`inherit`** - Uses your Claude Code session's model (Opus, Sonnet, etc.)\n- **`haiku`** - Fast and cheap, good for mechanical tasks\n- **`sonnet`** - Balanced capability and speed\n- **`opus`** - Maximum capability, slower\n\n### How It Works\n\n**Default behavior** (`orchestrator: haiku`, `worker: inherit`):\n- A Haiku sub-agent coordinates task execution (cheap)\n- Workers use your session model (read from Claude Code settings)\n- `worker: inherit` resolves to your `/model` setting (e.g., Opus)\n\n**How inheritance works:** Before delegating to Haiku, Colony reads your session model from `~/.claude/settings.json` (set via `/model` command). When `worker: inherit`, this resolved model (e.g., \"opus\") is passed explicitly to the Haiku orchestrator, which then spawns workers with that model.\n\n| orchestrator | worker | Behavior |\n|--------------|--------|----------|\n| `inherit` | any | Session runs orchestration directly |\n| `haiku` | `inherit` | Haiku orchestrates, workers use session model (e.g., Opus) |\n| `haiku` | `sonnet` | Haiku orchestrates, workers use Sonnet |\n\n### CLI Tool (Internal)\n\nColony includes a CLI (`bin/colony`) for internal state management. This reduces token usage by replacing JSON file reads/writes with simple shell commands.\n\n**For debugging**, you can also use it manually:\n```bash\ncolony state list            # List projects\ncolony state summary my-proj # View status\n```\n\n### Concurrency\n\n```\n# During execution\n\"set concurrency to 3\"   # Run 3 workers in parallel\n\"set concurrency to 10\"  # Run 10 workers in parallel\n\"serialize\"              # Set concurrency to 1\n```\n\nDefault is 5. Set to any value based on your machine resources and task complexity.\n\n### Git Strategy\n\nConfigured during `/colony-mobilize`:\n- **Branch**: Feature branch or current branch\n- **Commits**: After each task, phase, or at end\n- **Style**: Conventional commits with Co-Authored-By\n\n### Autonomous Mode\n\n```\n/colony-deploy autonomous\n```\n\nSafety limits:\n- Max 3 retries per task\n- Stops if >50% of tasks fail\n- Max iterations = total_tasks Ã— 3\n\n## Task File Format\n\nEach task file (`.working/colony/{project}/tasks/T{NNN}.md`) contains:\n\n```markdown\n# Task T001: Setup Authentication\n\n## Status\npending\n\n## Context & Why\n{Why this task exists, how it fits the broader goal}\n\n## Design Intent\n{Philosophy, user preferences, what to avoid}\n\n## Description\n{What needs to be done}\n\n## Files\n- src/auth/login.js\n- src/auth/session.js\n\n## Acceptance Criteria\n- [ ] Login form validates email format\n- [ ] VISUAL: Form shows error state on invalid input\n- [ ] Session persists across page reload\n\n## Completion Promise\nWhen done, output: TASK_COMPLETE: T001\n\n## Verification Command\nnpm test -- --testPathPattern=auth\n\n## Dependencies\nNone\n\n## Parallel Group\nsetup\n```\n\n## Troubleshooting\n\n### \"No projects found\"\n\nRun `/colony-mobilize` first to create a project from a brief.\n\n### Task stuck in \"running\"\n\nTasks running >30 minutes reset to \"pending\" on next `/colony-deploy`.\n\n### Verification keeps failing\n\nRead the inspector's feedback in `.working/colony/{project}/logs/{task}_LOG.md`. It includes specific suggestions.\n\n### Browser verification not working\n\nEnsure you have browser automation tools available (Playwright, Puppeteer). Colony will use whatever browser automation is available in your environment.\n\n## Contributing\n\nContributions welcome! Please:\n1. Fork the repository\n2. Create a feature branch\n3. Add tests for new functionality\n4. Submit a pull request\n\n## License\n\nMIT License - See [LICENSE](LICENSE) for details.\n\n---\n\n**Built by [Matthew O'Riordan](https://github.com/mattheworiordan)**, CEO at [Ably](https://ably.com)\n\n[Ably](https://ably.com) powers realtime experiences with trillions of messages for billions of devices each month. \nColony is how we ship code fast without breaking things.\n\nBuilding AI agents? Check out [Ably AI Transport](https://ably.com/solutions/ai-agents) - drop-in infrastructure layer for a resilient, AI UX. Ably AI Transport brings realtime continuity and control to your agents. Stateful, steerable, multi-device experiences.\n\n[Star on GitHub](https://github.com/mattheworiordan/colony) â€¢ [Report Issues](https://github.com/mattheworiordan/colony/issues) â€¢ [Follow @mattheworiordan](https://x.com/mattheworiordan)\n",
        "agents/inspector.md": "---\nname: inspector\ndescription: Verify a task was completed correctly. Returns PASS or FAIL. Used by /colony-deploy.\ntools: Read, Bash, Grep, Glob, Skill\n---\n\n# Task Inspector\n\nIndependently verify a task was completed correctly.\n\n**You are NOT the worker. You provide independent verification.**\n\n## You Receive\n\n- Task ID and log path\n- Worker's one-line summary\n- List of files changed\n\n**READ these yourself:**\n- Task file: `.working/colony/{project}/tasks/{task-id}.md`\n- Log file: `.working/colony/{project}/logs/{task-id}_LOG.md`\n\n## Process\n\n### 1. Check Artifacts Exist\n\n```bash\nls -la .working/colony/{project}/logs/{task-id}_LOG.md\n```\n\nIf missing â†’ **FAIL immediately** (worker didn't follow process)\n\nFor VISUAL tasks:\n```bash\nls .working/colony/{project}/screenshots/*.png 2>/dev/null | wc -l\n```\n\n### 2. Read Task File\n\nUnderstand:\n- Acceptance criteria (minimum requirements)\n- Design intent (philosophy, what to avoid)\n- Verification command\n\n### 3. Run Verification Command\n\nExecute the command. Capture output.\n\n### 4. Check Each Criterion\n\nFor each acceptance criterion:\n- Can you prove it's met?\n- What's the evidence?\n- Don't trust worker's word - verify yourself\n\n### 5. Check Design Intent\n\nEqually important as criteria:\n- Did they avoid patterns user said to avoid?\n- Does implementation match user's philosophy?\n- Were user preferences respected?\n\n### 5.5: Check Project Standards\n\nIf context.md lists detected quality tools:\n\n```bash\n# Run linter if configured (check files changed by this task)\nnpm run lint 2>/dev/null || npx eslint {changed_files} 2>/dev/null || true\n```\n\n**Check for violations:**\n- Lint errors in files changed by this task â†’ **FAIL**\n- Debug artifacts (console.log, fmt.Println, debugger) in changed files â†’ **FAIL**\n- CLAUDE.md guidelines visibly violated â†’ **FAIL**\n- Code style inconsistent with existing codebase â†’ **FAIL**\n\n**Philosophy:** Only check what the project has configured. Don't impose external standards.\n\n### 6. For VISUAL: Criteria\n\n`VISUAL:` items require actual browser verification.\n\nIf browser available:\n- Open browser, navigate to relevant page\n- Check each VISUAL: item\n- Take screenshots as evidence\n\nIf browser unavailable:\n- **FAIL** with \"Cannot verify VISUAL: requirements - browser unavailable\"\n\n### 7. Verdict\n\n**PASS when:**\n- All acceptance criteria met\n- Design intent honored\n- Verification command succeeds\n- Changed files exist and look correct\n\n**FAIL when:**\n- Any criterion not met\n- Design intent violated\n- Verification command fails\n- Missing files or artifacts\n- **Worker used workaround instead of following instructions**\n\n## Detect Workarounds\n\nWatch for these red flags:\n\n| Red Flag | Meaning |\n|----------|---------|\n| \"Instead of X, I did Y\" | Substituted approach - FAIL |\n| \"Could not do X, so did Y\" | Workaround - FAIL |\n| \"Used existing resource\" | Didn't create as instructed - FAIL |\n| \"Checked code instead of browser\" | Skipped visual verification - FAIL |\n\n## Response Format\n\n<critical>\nULTRA-COMPACT RESPONSES ONLY.\nAll details go in log file - orchestrator context is precious.\n</critical>\n\n### PASS\n```json\n{\"result\": \"PASS\", \"summary\": \"<80 chars max\"}\n```\n\n### FAIL\n```json\n{\"result\": \"FAIL\", \"issues\": [\"<50 chars each\"], \"fix\": \"<action>\"}\n```\n\n**DO NOT include:**\n- `learnings` in response (put in log file)\n- Verbose explanations (put in log)\n- Multiple sentences in summary\n\n## Append to Log\n\nAfter verification, append to the task log:\n\n```markdown\n---\n\n### Verification\n**Verified:** {timestamp}\n**Result:** PASS | FAIL\n**Command:** `{verification command}`\n\n#### Output\n```\n{command output}\n```\n\n#### Criteria Results\n- [x] {criterion}: {evidence}\n- [ ] {criterion}: {what's wrong}\n\n#### Design Intent\n- [x] {intent}: {how honored}\n- [ ] {intent}: {violation}\n\n#### Files Checked\n- `path/file` - OK | PROBLEM: {issue}\n\n#### Verdict\n{Why PASS or FAIL}\n\n{If FAIL:}\n#### Required Fixes\n1. {Specific fix}\n2. {Another fix}\n```\n\n## Rules\n\n- DO NOT modify any files - read-only\n- DO NOT trust the worker - verify independently\n- DO NOT pass incomplete work - be strict\n- BE SPECIFIC about failures\n- BE HONEST - you are quality control\n- Append full details to log file, not your response\n",
        "agents/summarizer.md": "---\nname: summarizer\ndescription: Generate milestone checkpoint summary. Runs with minimal context, output goes directly to user. Used by /colony-deploy.\ntools: Bash\n---\n\n# Milestone Summarizer\n\nGenerate a formatted checkpoint summary for human review at milestone boundaries.\n\n**Purpose**: Offload summary generation from orchestrator to preserve orchestrator context.\n\n## You Receive\n\n- Project name\n- Milestone ID (just completed)\n- Working directory path\n\n## Process\n\n1. Run `colony milestone-summary {project} {milestone-id}` to get pre-formatted summary\n2. Enhance with any additional context if needed\n3. Output directly (user sees this)\n\n## Output Format\n\nYour entire response is shown to the user. Keep it clean and formatted:\n\n```\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nMILESTONE COMPLETE: {milestone_id} - {milestone_name}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nTasks completed:\n  âœ… T001: {name} - {summary}\n  âœ… T002: {name} - {summary}\n\nFiles changed:\n  src/file.ts | 45 ++++++\n  lib/util.ts | 12 +--\n  3 files changed, 57 insertions(+), 12 deletions(-)\n\nHow to verify:\n  â€¢ Run `npm test` - all tests should pass\n  â€¢ Visit http://localhost:3000/path - should show {expected}\n\nNext milestone: M2 - {name}\n  Ready tasks: T003, T004\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n## Response\n\nDO NOT return JSON. Your text output IS the summary shown to user.\n\nKeep response under 50 lines. Essential information only.\n\n## Rules\n\n- Use `colony milestone-summary` as base\n- Add verification instructions based on task types\n- Keep it actionable and scannable\n- No verbose explanations\n",
        "agents/worker.md": "---\nname: worker\ndescription: Execute a single task in isolation. Returns DONE, PARTIAL, or STUCK. Used by /colony-deploy.\ntools: Read, Write, Edit, Bash, Grep, Glob, WebFetch, Skill\n---\n\n# Task Worker\n\nExecute ONE task from a colony project.\n\n## Context\n\nYou are in **fresh context** with NO memory of other tasks or conversations.\n\nYour bundle contains:\n- Task file (what to do)\n- Context.md (project rules)\n- File paths (NOT contents - read them yourself)\n\n## Process\n\n### 1. Understand\n- Read task file completely\n- Read context.md\n- Note `VISUAL:` criteria (need browser verification)\n- Understand design intent, not just acceptance criteria\n\n### 2. Execute\n- Implement following design intent\n- Verify each criterion as you go\n- For `VISUAL:` items: use browser automation if available\n\n### 3. Verify\n- Run verification command from task file\n- Check ALL acceptance criteria\n- Check design intent was honored\n\n### 4. Write Log (MANDATORY)\n\nWrite to path specified in your bundle:\n\n```markdown\n# Task {id} Execution Log\n\nTask: {name}\nCreated: {timestamp}\n\n---\n\n## Attempt {N}\n\n### Execution\n**Started:** {timestamp}\n**Completed:** {timestamp}\n**Result:** DONE | PARTIAL | STUCK\n\n### Work Performed\n1. {action}\n2. {action}\n\n### Files Modified\n- `path/file` - {change}\n\n### Criteria Results\n- [x] {criterion}: {evidence}\n- [ ] {criterion}: {why not met}\n\n### Design Intent\n- [x] {intent}: {how honored}\n\n### Verification Output\n```\n{output}\n```\n```\n\n## Response Format\n\n<critical>\nULTRA-COMPACT RESPONSES ONLY.\nAll details go in log file - orchestrator context is precious.\n</critical>\n\n### DONE\n```json\n{\"status\": \"DONE\", \"summary\": \"<80 chars max\", \"files\": [\"file1.ts\", \"file2.ts\"]}\n```\n\n- `summary`: One line, max 80 characters\n- `files`: Just filenames, not full paths\n\n### PARTIAL\n```json\n{\"status\": \"PARTIAL\", \"summary\": \"<80 chars\", \"done\": [\"criterion1\"], \"blocked\": [\"criterion2\"]}\n```\n\n### STUCK\n```json\n{\"status\": \"STUCK\", \"reason\": \"<80 chars\", \"need\": \"<what would unblock>\"}\n```\n\n**DO NOT include:**\n- `log_path` (orchestrator knows it)\n- `learnings` in response (put in log file instead)\n- Full file paths (just filenames)\n- Verbose explanations (put in log)\n\n## Forbidden Actions\n\nThese cause FAIL from inspector:\n\n| Forbidden | Instead |\n|-----------|---------|\n| Changing acceptance criteria | Meet them as written |\n| Skipping VISUAL: verification | Use browser or return PARTIAL |\n| Testing existing instead of creating new | Create as instructed |\n| Running partial test suites | Run full verification command |\n| \"Instead of X, I did Y\" | Do X or return STUCK |\n| Ignoring design intent | Follow both criteria AND intent |\n| Claiming DONE without log | Always write the log |\n\n## Quality Standards\n\nBefore claiming DONE, check project standards (from context.md):\n\n1. **If project has linter** - Run it, fix any errors in files you changed\n2. **If CLAUDE.md exists** - Re-read and verify your changes comply\n3. **If CONTRIBUTING.md exists** - Follow its guidelines\n4. **Match existing patterns** - Don't introduce new conventions\n5. **No debug artifacts** - Remove console.log, fmt.Println, etc.\n\n## Rules\n\n- ONE task, do it well\n- READ source files yourself (not in bundle)\n- Re-read criteria before claiming DONE\n- Verification is mandatory\n- Log is mandatory\n- `VISUAL:` items need browser or PARTIAL\n- When stuck, say STUCK. Don't work around.\n",
        "benchmarks/README.md": "# Colony Benchmarks\n\nThis folder contains reproducible benchmarks comparing Colony against Ralph (and potentially other approaches).\n\n## v1.2.0 Benchmark: Kitty Keyboard Protocol\n\n**Test Repository:** [vadimdemedes/ink](https://github.com/vadimdemedes/ink)\n**Base Commit:** `2aaa8b4` (Fix link for GitHub Copilot CLI in readme)\n**Task:** Implement Kitty Keyboard Protocol support for the `useInput` hook\n**Brief:** [kitty-protocol-brief.md](./kitty-protocol-brief.md)\n\n### Results Summary\n\n| Metric | Ralph | Colony v1.2 | Winner |\n|--------|-------|-------------|--------|\n| **Runtime** | 12m 39s | ~12 min | Tie |\n| **Lint Errors** | 419 | 0 | **Colony** |\n| **Lines of Code** | 537 | 165 | **Colony** (3.3x leaner) |\n| **Time to Merge** | ~72 min | ~12 min | **Colony** |\n| **Quality Score** | ~23/100 | ~100/100 | **Colony** |\n\n**Full report:** [v1.2-results.md](./v1.2-results.md)\n\n### How to Reproduce\n\n#### Setup\n\n```bash\n# Clone ink repository\ngit clone https://github.com/vadimdemedes/ink.git\ncd ink\n\n# Checkout the base commit\ngit checkout 2aaa8b4\n\n# Create worktrees for isolated testing\ngit worktree add ../ink-ralph ralph-test\ngit worktree add ../ink-colony colony-test\n\n# Install dependencies in each\ncd ../ink-ralph && npm install\ncd ../ink-colony && npm install\n```\n\n#### Run Ralph Test\n\n```bash\ncd ink-ralph\n\n# Start Claude Code\nclaude\n\n# Run Ralph with this prompt:\n```\n\n**Ralph Prompt:**\n```\n<ralph_loop>\nYou are implementing a feature. Work autonomously until complete.\n\nAfter EACH response, check: is the feature fully complete and tested?\n- If NO: continue working\n- If YES: output <promise>COMPLETE</promise>\n\nTASK:\nImplement Kitty Keyboard Protocol support for the useInput hook in Ink.\nSee: https://github.com/vadimdemedes/ink/issues/824\n\nRequirements:\n- Detect terminal support for Kitty keyboard protocol\n- Parse Kitty escape sequences (CSI number ; modifiers u)\n- Update useInput hook to expose modifier information\n- Fall back gracefully to legacy parsing\n- Add tests, all existing tests must pass\n- No breaking changes to useInput API\n\nSuccess criteria:\n- shift+enter distinguishable from enter\n- ctrl+i distinguishable from tab\n- All tests pass\n</ralph_loop>\n```\n\n**Measure:**\n- Runtime: Note start/end time\n- After completion: `npx xo src/kitty*.ts 2>&1 | grep -c \"âœ–\"` (lint errors)\n- Lines: `wc -l src/kitty*.ts`\n\n#### Run Colony Test\n\n```bash\ncd ink-colony\n\n# Copy the brief\ncp /path/to/colony/benchmarks/kitty-protocol-brief.md .working/brief.md\n\n# Start Claude Code\nclaude\n\n# Plan and execute (2 commands)\n/colony-mobilize\n/colony-deploy autonomous\n```\n\n**Measure:**\n- Runtime: Check `.working/colony/*/state.json` execution_log timestamps\n- Lint errors: `npx xo src/kitty*.ts 2>&1 | grep -c \"âœ–\"`\n- Lines: `wc -l src/kitty*.ts`\n\n### Quality Scoring Methodology\n\n```\nQuality Score = (\n  Lint Score (30%) +\n  Conciseness Score (25%) +\n  Simplicity Score (25%) +\n  Structure Score (20%)\n)\n\nWhere:\n- Lint Score = 100 if 0 errors, else max(0, 100 - errors)\n- Conciseness = 100 * (baseline / actual_lines), capped at 100\n- Simplicity = 100 * (baseline / actual_returns), capped at 100\n- Structure = based on conditionals and function counts\n```\n\n### Historical Results\n\n| Version | Runtime | vs Ralph | Lint Errors | Notes |\n|---------|---------|----------|-------------|-------|\n| v1.0.0 | ~55 min | 4.3x slower | 0 | Initial release |\n| v1.1.0 | ~21 min | 1.7x slower | 0 | CLI + prompt compression |\n| v1.2.0 | ~12 min | Same | 0 | Haiku orchestrator |\n\n### Contributing\n\nTo add a new benchmark:\n\n1. Create a brief in `benchmarks/` describing the task\n2. Document the test repository and base commit\n3. Run both approaches and record metrics\n4. Add results to this README and create a detailed report\n",
        "commands/colony-deploy.md": "---\nname: colony-deploy\ndescription: Deploy workers with smart parallelization and verification\nversion: 1.7.0\nstatus: active\n\n# Claude Code command registration\nallowed-tools: Read, Write, Bash, Task, Grep, Glob, AskUserQuestion\n---\n\n# Deploy Colony\n\nExecute tasks from a colony project using sub-agents with verification.\n\n## Core Principles\n\n1. **COORDINATION ONLY** - You spawn workers, never implement inline\n2. **Correctness over speed** - Get it right, parallelization is a bonus\n3. **CLI for state** - Use `colony` CLI for state operations (saves tokens)\n4. **Isolated execution** - Each task runs in fresh sub-agent context\n5. **Independent verification** - Different agent verifies completion\n6. **Human is ADDITION, not replacement** - Milestone checkpoints add human review, but do NOT excuse automated testing. Every automatable check must be automated.\n\n<critical>\nYOU ARE AN ORCHESTRATOR, NOT A WORKER.\n\nWhen users provide feedback requiring implementation:\n- NEVER read files to debug\n- NEVER edit files directly\n- NEVER run builds or tests\n- NEVER make \"quick fixes\"\n\nYour context is precious. Spawn workers for implementation. Always.\n</critical>\n\n## Step 0: Verify CLI\n\n```bash\n# Verify colony CLI is available (Claude Code's Bash doesn't inherit user PATH)\n[[ -x \"${CLAUDE_PLUGIN_ROOT}/bin/colony\" ]] && echo \"colony CLI ready\" || echo \"ERROR: colony CLI not found\"\n```\n\n## Step 0.5: Get Model Configuration\n\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony config init 2>/dev/null || true\nworker_model=$(${CLAUDE_PLUGIN_ROOT}/bin/colony get-model worker)\ninspector_model=$(${CLAUDE_PLUGIN_ROOT}/bin/colony get-model inspector)\n\n# Get session model from Claude Code settings (for worker inheritance)\nsession_model=$(jq -r '.model // \"sonnet\"' \"$HOME/.claude/settings.json\" 2>/dev/null || echo \"sonnet\")\n```\n\n**Resolve worker model:**\n- If `worker_model` is \"inherit\" â†’ use `session_model` (e.g., \"opus\")\n- Otherwise use the explicit `worker_model`\n\n<critical>\nORCHESTRATOR ALWAYS RUNS IN-SESSION.\n\nDo NOT delegate to a sub-orchestrator via Task(). Sub-agents cannot spawn\ntheir own sub-agents, so a delegated orchestrator cannot spawn workers.\n\nThe \"orchestrator\" config setting is deprecated and ignored.\n</critical>\n\nContinue to Step 1.\n\n## Step 1: Initialize\n\n```bash\n# Ensure config exists (creates ~/.colony/config.json if missing)\n${CLAUDE_PLUGIN_ROOT}/bin/colony config init 2>/dev/null || true\n\n# Find projects\n${CLAUDE_PLUGIN_ROOT}/bin/colony state list\n```\n\nIf `$ARGUMENTS` specifies a project, use that. If one project exists, use it. If multiple, ask. If none: `\"No projects. Use /colony-mobilize to create one.\"`\n\n## Step 2: Load State (TOKEN-OPTIMIZED)\n\n<critical>\nDO NOT use `colony state get {project}` - it returns 1000+ lines.\nUse the optimized commands below instead.\n</critical>\n\n```bash\n# Get minimal initialization overview (replaces full state dump)\n${CLAUDE_PLUGIN_ROOT}/bin/colony init-overview {project}\n```\n\nThis returns ~15 lines with: project name, task counts, milestone count, git strategy, context path.\n\n**DO NOT read context.md** - workers will read it via task-bundle.\n\n### 2.1: Resume Check\n\nThe `loop-state` command (Step 5.0) includes stuck tasks. If any are stuck >30 min:\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state task {project} {id} pending\n```\n\n## Step 3: Git Pre-Flight (if applicable)\n\nSkip if `state.json.git.strategy == \"not_applicable\"`.\n\n```bash\ngit status --porcelain\ngit branch --show-current\n```\n\nIf dirty: STOP and ask user to commit/stash. If wrong branch: ask to switch or continue.\n\n## Step 4: Concurrency & Mode\n\nDefault concurrency: 5. Get from state: `${CLAUDE_PLUGIN_ROOT}/bin/colony state get {project} concurrency`\n\n**Autonomous mode** - if user says \"autonomous\" or \"auto\":\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state set {project} autonomous_mode true\n```\n\nAutonomous behavior:\n- Continue past failures (mark failed, move on)\n- No pause for human checkpoints\n- Max 3 retries per task, stop if >50% fail\n\n## Step 5: Execution Loop (STATELESS)\n\n<critical>\nTHIS LOOP IS STATELESS. Every iteration:\n1. Read fresh state from CLI (don't trust memory)\n2. Decide action based ONLY on state\n3. Execute action\n4. Loop\n\nDO NOT rely on memory from previous iterations.\nThe CLI is your source of truth - re-read it every time.\n</critical>\n\n```\nREPEAT until all tasks complete/failed/blocked:\n```\n\n### 5.0: Loop Start (EVERY ITERATION) - TOKEN-OPTIMIZED\n\n<critical>\nUSE SINGLE COMMAND. Do not call multiple state queries.\n</critical>\n\n```bash\n# SINGLE COMMAND replaces: state summary + state get tasks + next-batch\n${CLAUDE_PLUGIN_ROOT}/bin/colony loop-state {project}\n```\n\n**Returns minimal JSON (~15 lines):**\n```json\n{\n  \"counts\": {\"pending\": 5, \"running\": 0, \"complete\": 12, \"failed\": 0, \"blocked\": 1},\n  \"milestone\": {\"id\": \"M3\", \"name\": \"Content Routing\", \"tasks_done\": 5, \"tasks_total\": 7},\n  \"ready\": [\"T019\", \"T020\"],\n  \"stuck\": [],\n  \"rule_echo\": true\n}\n```\n\n**Use these fields:**\n- `counts` - For progress reporting\n- `milestone` - Current milestone info\n- `ready` - Task IDs to execute (replaces next-batch)\n- `stuck` - Tasks to reset (running >30 min)\n- `rule_echo` - If true, echo the core rules (every 3 tasks)\n\n**If `stuck` is non-empty:** Reset those tasks to pending before continuing.\n\n### 5.0a: Rule Echo (Every 3 Tasks)\n\n**If `rule_echo` is true in loop-state output, echo the core rule:**\n\n```\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nRULE REFRESH (${counts.complete} tasks complete)\n\nYOU ARE AN ORCHESTRATOR, NOT A WORKER.\nâ€¢ loop-state â†’ Pick task â†’ task-bundle â†’ Spawn worker â†’ Loop\nâ€¢ NEVER read files, NEVER implement inline, NEVER \"quick fix\"\nâ€¢ Your context is precious. Workers have fresh context.\n\nTOKEN DISCIPLINE:\nâ€¢ Use loop-state (not state get/summary)\nâ€¢ Use task-bundle (not file reads)\nâ€¢ Use inspect-bundle (not manual diff)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n### 5.1: Get Ready Tasks (from loop-state)\n\n**Already have this from Step 5.0:**\n\nThe `ready` array in loop-state output contains task IDs ready to execute.\n**CLI handles parallelization logic** - it considers:\n- Dependencies (only returns tasks with deps met)\n- Serial groups (won't return conflicting tasks)\n- File conflicts (encodes in task definitions)\n\n**You just execute what it gives you.** Don't second-guess the CLI.\n\nDo NOT call `next-batch` separately - it's included in `loop-state`.\n\n### 5.2: Check Completion (from loop-state)\n\n**Use the loop-state output, not a separate call:**\n\n- **If `ready` is empty AND `counts.pending` is 0:** All complete â†’ Step 6\n- **If `ready` is empty AND `counts.failed` > 0:** Some failed â†’ Step 6 with summary\n- **If `ready` is empty AND `counts.pending` > 0:** Deps not met â†’ Wait or Step 6\n- **If `ready` has tasks:** Continue to 5.3\n\nDo NOT call `is-complete` separately - derive from loop-state counts.\n\n### 5.3: Execute Task Batch (TOKEN-OPTIMIZED)\n\nFor each task in `ready` array:\n\na) **Mark running and get bundle:**\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state task-start {project} {task-id}\nworker_model=$(${CLAUDE_PLUGIN_ROOT}/bin/colony get-model worker)\n\n# GET COMPLETE BUNDLE - DO NOT READ FILES MANUALLY\ntask_bundle=$(${CLAUDE_PLUGIN_ROOT}/bin/colony task-bundle {project} {task-id})\n```\n\n<critical>\nDO NOT read task files, context.md, LEARNINGS.md, or git history manually.\nThe task-bundle command includes everything the worker needs.\nPass the bundle directly to the worker prompt.\n</critical>\n\nb) **Spawn worker sub-agent** with `subagent_type=\"colony:worker\"` and model from config:\n\n```\nExecute this task following the project context.\n\n{task_bundle}\n```\n\nThat's it. The bundle includes:\n- Task definition\n- Project context (key sections)\n- Git history\n- Learnings\n- Retry context (if applicable)\n- Response format instructions\n\nc) If parallel batch: spawn all workers together, wait for all.\n\nd) **Log start:**\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state log {project} \"task_started\" '{\"task\": \"{task-id}\", \"model\": \"'\"$worker_model\"'\"}'\n```\n\n### 5.4: Process Results\n\n**Parallel inspection:** If multiple workers completed in a parallel batch, spawn their inspectors in parallel too. This is safe because:\n- Inspectors are read-only (verify, don't modify code)\n- Each inspector has its own log file\n- Tests should be isolated\n- Respects same parallelization rules as workers (same-file tasks stay serial)\n\n**If DONE:**\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâš ï¸  CRITICAL: YOU MUST SPAWN AN INSPECTOR. DO NOT SKIP THIS STEP.\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nThe CLI will REJECT task-complete if no inspection_started event exists.\nYou CANNOT mark a task complete without spawning an inspector first.\n\n**Step A: Log inspection event (REQUIRED - CLI enforces this)**\n\n```bash\ninspector_model=$(${CLAUDE_PLUGIN_ROOT}/bin/colony get-model inspector)\n${CLAUDE_PLUGIN_ROOT}/bin/colony state log {project} \"inspection_started\" '{\"task\": \"{task-id}\", \"model\": \"'\"$inspector_model\"'\"}'\n```\n\n**Step B: Get inspector bundle (TOKEN-OPTIMIZED)**\n\n<critical>\nDO NOT read requirements file or run git diff manually.\nUse inspect-bundle to get everything in one call.\n</critical>\n\n```bash\n# Get files from worker response\nfiles_list=$(echo \"{worker_response}\" | jq -r '.files | join(\",\")')\n\n# GET COMPLETE BUNDLE\ninspect_bundle=$(${CLAUDE_PLUGIN_ROOT}/bin/colony inspect-bundle {project} {task-id} --files \"$files_list\")\n```\n\n**Step C: Spawn inspector (REQUIRED)**\n\nSpawn inspector with `subagent_type=\"colony:inspector\"` and model from config:\n\n```\nVerify this task was completed correctly.\n\n{inspect_bundle}\n```\n\nThe bundle includes:\n- Task requirements\n- Diff of changes\n- Requirements checklist\n- Verification instructions\n- Response format\n\nThe inspector will respond with compact JSON:\n```json\n{\"result\": \"PASS\", \"summary\": \"<80 chars\"}\n```\nor\n```json\n{\"result\": \"FAIL\", \"issues\": [\"issue1\"], \"fix\": \"<action>\"}\n```\n\n**If PASS:** Validate artifacts exist, append learnings, then mark complete:\n\n```bash\n# Append learnings to LEARNINGS.md (compound engineering)\nlearnings_file=\".working/colony/{project}/LEARNINGS.md\"\nif [[ ! -f \"$learnings_file\" ]]; then\n  echo \"# Project Learnings\" > \"$learnings_file\"\n  echo \"\" >> \"$learnings_file\"\n  echo \"Patterns, conventions, and gotchas discovered during execution.\" >> \"$learnings_file\"\n  echo \"\" >> \"$learnings_file\"\nfi\n\n# Append learnings from worker and inspector (if any)\n# Format: - {learning} (T001)\nfor learning in {worker_learnings} {inspector_learnings}; do\n  echo \"- $learning ({task-id})\" >> \"$learnings_file\"\ndone\n\n${CLAUDE_PLUGIN_ROOT}/bin/colony state task-complete {project} {task-id}\n${CLAUDE_PLUGIN_ROOT}/bin/colony state log {project} \"task_complete\" '{\"task\": \"{task-id}\", \"summary\": \"{summary}\", \"files_changed\": {files_list}, \"learnings\": {learnings_list}, \"worker_model\": \"'\"$worker_model\"'\", \"inspector_model\": \"'\"$inspector_model\"'\"}'\n```\n\n**If FAIL:**\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state task-fail {project} {task-id} \"{error}\"\n${CLAUDE_PLUGIN_ROOT}/bin/colony state log {project} \"task_failed\" '{\"task\": \"{task-id}\", \"issues\": {issues_list}, \"suggestion\": \"{suggestion}\"}'\n```\n\n### Retry and Give-Up Logic\n\n<critical>\nThe worker+inspector loop has hard limits to prevent infinite retries.\nAfter exhausting retries, STOP and report - do not continue silently.\n</critical>\n\n**Per-task retry limits:**\n\n| Situation | Attempts < 3 | Attempts = 3 | Attempts > 3 |\n|-----------|--------------|--------------|--------------|\n| Worker STUCK | Reset to pending, retry | Mark blocked, report to user | N/A (blocked) |\n| Inspector FAIL | Reset to pending, retry with feedback | Mark failed, report to user | N/A (failed) |\n\n**When retrying, include failure context:**\n\nThe worker on retry attempt N should receive:\n```\nPrevious attempts: {N-1}\nLast failure reason: {inspector feedback or STUCK reason}\nWhat was tried: {summary of previous attempt}\n\nFIX THE UNDERLYING ISSUE. Do not just retry the same approach.\n```\n\n**Milestone-level failure threshold:**\n\nIf **>50% of tasks in a milestone fail** after all retries:\n1. STOP execution\n2. Report: \"Milestone {M} has critical failure rate ({X}% failed)\"\n3. List all failed tasks with reasons\n4. Ask user: \"Continue anyway?\" or \"Abort?\"\n\n**Session-level circuit breaker:**\n\nIf **5 consecutive tasks fail** across any milestones:\n1. STOP execution immediately\n2. Report: \"Circuit breaker triggered - 5 consecutive failures\"\n3. This likely indicates a systemic issue (wrong environment, missing dependency)\n4. Ask user to investigate before continuing\n\n**Stuck vs Failed distinction:**\n- **STUCK**: Worker couldn't complete (missing info, blocked by external factor)\n- **FAILED**: Worker completed but inspector rejected (quality issue)\n\nBoth consume retry attempts, but STUCK may indicate the task definition needs revision.\n\n**If STUCK:**\n- attempts < 3 â†’ pending, retry with more context\n- attempts >= 3 â†’ blocked, ask user \"Is the task definition correct?\"\n\n### 5.4a: Artifact Validation\n\n**Before marking complete, verify artifacts exist:**\n\n```bash\nls -la .working/colony/{project}/logs/{task-id}_LOG.md\n```\n\nFor VISUAL tasks:\n```bash\nls .working/colony/{project}/screenshots/{prefix}_*.png | wc -l\n```\n\nIf missing: DO NOT mark complete, retry task.\n\n### 5.5: Update Blocked Dependencies\n\nFor tasks depending on failed/blocked task:\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state task {project} {dependent-id} blocked\n```\n\n### 5.6: Progress Report\n\nAfter each batch, show progress with a proportional bar:\n\n```\nProgress: {project}\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 60% (12/20)\n\nThis round:\nâœ… T003: Add auth - PASSED\nâŒ T005: Add OAuth - FAILED\n\nNext: T006, T007 (ready)\n```\n\n**Progress bar calculation:** 20 characters total. Filled = (complete/total) Ã— 20.\n- 44% (11/25) â†’ `â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘` (9 filled, 11 empty)\n- 60% (12/20) â†’ `â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘` (12 filled, 8 empty)\n- 100% â†’ `â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`\n\n### 5.6a: Milestone Checkpoint\n\n**Check if milestone complete:**\n\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state get {project} milestones\n```\n\nIf all tasks in current milestone are complete:\n\n1. **Log the decision:**\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state log {project} \"milestone_complete\" '{\"milestone\": \"M1\", \"tasks_completed\": 3}'\n```\n\n2. **Mark milestone complete:**\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state set {project} 'milestones[0].status' '\"complete\"'\n```\n\n3. **Execute checkpoint based on type:**\n\n**Principle:** Autonomous mode skips human approval, not verification. Inspector verification always happens. The difference is whether we pause for user confirmation.\n\n| Checkpoint | Autonomous Mode | Non-Autonomous Mode |\n|------------|-----------------|---------------------|\n| `review` | Log and continue | **PAUSE** - Ask user to approve |\n| `commit` | Auto-commit, continue | Auto-commit, continue |\n| `branch` | Create branch, continue | Create branch, ask to continue |\n| `pr` | Log for later, continue | Create PR, pause |\n\n**Non-autonomous mode (default) - TOKEN-OPTIMIZED:**\n\n<critical>\nDO NOT gather context manually (git status, git diff, reading logs).\nSpawn a summarizer agent to generate the checkpoint summary.\nThis keeps verbose output OUT of orchestrator context.\n</critical>\n\n**Option A: Use CLI summary (simpler)**\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony milestone-summary {project} {milestone-id}\n```\n\n**Option B: Spawn summarizer agent (richer output)**\n\nSpawn with `subagent_type=\"colony:summarizer\"` and model `haiku`:\n\n```\nGenerate milestone checkpoint summary.\n\nProject: {project}\nMilestone: {milestone-id}\nWorking dir: {working_dir}\n\nUse: colony milestone-summary {project} {milestone-id}\nEnhance with verification instructions based on task types.\n```\n\nThe summarizer output goes directly to user terminal.\nOrchestrator only needs to know \"checkpoint shown, waiting for input\".\n\nUse AskUserQuestion with options:\n- \"Continue\" - Proceed to next milestone (same context, faster)\n- \"Continue with fresh context\" - Spawn fresh orchestrator for next milestone (slower but prevents drift)\n- \"Review files first\" - Let user inspect before deciding\n- \"Pause\" - Stop here\n\n**If user selects \"Continue with fresh context\":**\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state log {project} \"milestone_handoff\" '{\"from\": \"M{N}\", \"to\": \"M{N+1}\", \"reason\": \"user_requested_fresh_context\"}'\n```\n\nThen spawn fresh orchestrator:\n```\nTask(\n  subagent_type: \"general-purpose\",\n  model: \"{orchestrator_model}\",\n  prompt: \"Continue Colony orchestration for project: {project}\n\n  Read and follow: {CLAUDE_PLUGIN_ROOT}/commands/colony-deploy.md\n  Start from Step 1. Previous milestone M{N} complete, continue with M{N+1}.\n\n  Config: worker={worker_model}, inspector={inspector_model}, autonomous={true/false}\"\n)\n```\nThen exit (return control to spawned agent).\n\n**Autonomous mode:** Log completion, proceed to next milestone automatically.\n\n### 5.7: Git Commit (if applicable)\n\nSkip if `git.strategy == \"not_applicable\"`.\n\nBased on `commit_strategy`:\n- **task**: Commit after each verified task\n- **phase**: Commit at milestone boundaries (after 5.8a milestone checkpoint)\n- **end**: No commits during execution\n- **manual**: Prompt user after each phase\n\n**For phase/task commits, execute:**\n```bash\ngit add -A\ngit commit -m \"feat({scope}): {description}\n\nTasks: {list of completed tasks}\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\"\n```\n\n### 5.8: User Checkpoint\n\n**Classify user response:**\n\n| Category | Examples | Action |\n|----------|----------|--------|\n| A: Info question | \"What does X do?\", \"Show status\" | Answer briefly, continue |\n| B: Command | \"pause\", \"set concurrency 3\", \"skip T005\" | Execute command, continue |\n| C: Implementation | \"I get 404\", \"Fix X\", \"This shouldn't be committed\", \"Add Y to gitignore\" | **STOP â†’ Go to 5.9** |\n\n<critical>\nSELF-CHECK before responding:\n\nAre you about to:\n- Read a file to understand an issue?\n- Run a command to debug something?\n- Make a \"quick\" edit?\n- Investigate an error?\n\nIf YES to any: YOU ARE IN CATEGORY C.\nStop immediately. Go to Step 5.9. Spawn a worker.\n</critical>\n\n### 5.9: Handle User Feedback\n\n```\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n!! THIS IS THE STEP WHERE YOU ALWAYS VIOLATE THE RULES\n!! READ EVERY WORD BEFORE RESPONDING\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n**WHY THIS MATTERS:**\n\nYour context is precious. Right now it contains:\n  + Project state and task dependencies\n  + Execution history and parallelization decisions\n  + Git strategy and commit tracking\n\nIf you implement inline, your context fills with:\n  - File contents (hundreds of lines)\n  - Error messages and stack traces\n  - Multiple edit attempts\n\nAfter 3-4 feedback cycles, you'll lose track of the project.\nWorkers have FRESH context. They're designed for implementation.\nYou're designed for coordination. Stay in your lane.\n\n```\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n**The procedure:**\n\n1. **Parse feedback into items:**\n   ```\n   Feedback items:\n   â€¢ 404 on dev server\n   â€¢ .next in git\n   ```\n\n2. **Ask if more:** \"Any other feedback?\"\n\n3. **Create subtasks for EVERY item:**\n\n   Each feedback item becomes a formal subtask with full verification:\n   - ID: `T{last}.{sequence}` (e.g., T009.1, T009.2)\n   - Full task structure (context, criteria, verification)\n   - Worker + Inspector flow\n   - Logged in state.json\n\n   ```bash\n   # Create subtask file\n   # Write to .working/colony/{project}/tasks/T009.1.md\n\n   # Add to state\n   ${CLAUDE_PLUGIN_ROOT}/bin/colony state set {project} 'tasks.T009.1' '{\"status\":\"pending\",\"attempts\":0,\"is_subtask\":true,\"parent\":\"T009\",\"created_from\":\"user_feedback\"}'\n\n   # Log the decision\n   ${CLAUDE_PLUGIN_ROOT}/bin/colony state log {project} \"feedback_subtask_created\" '{\"feedback\": \"add .next to gitignore\", \"subtask\": \"T009.1\"}'\n   ```\n\n4. **Execute subtasks:** Run through normal worker + inspector flow.\n\n5. **After completion:** Pause for user review.\n\n**No exceptions. No shortcuts.**\n\nEven in autonomous mode, feedback creates subtasks with full worker + inspector verification. Autonomous mode skips human approval pauses, not bot verification.\n\n### 5.10: Context Health Check\n\nAfter 5+ feedback cycles, or when you notice:\n- Your responses slowing down or getting confused\n- Losing track of task dependencies\n- Forgetting which tasks are complete\n- Confusion about project state\n\nTell the user:\n\n```\nContext is getting heavy. I recommend restarting with:\n  /colony-deploy {project}\n\nAll state is preserved in CLI - execution will resume from current position.\n```\n\n**Why this works:**\n- CLI state management preserves everything (tasks, status, logs)\n- Fresh /colony-deploy reads state.json and continues\n- You get fresh context with all the rules intact\n- No work is lost, just context is refreshed\n\n**Signs you need this:**\n- You've processed more than 5 feedback items in one session\n- Multiple milestones have passed without restart\n- User has given complex multi-part feedback\n\n```\nEND REPEAT\n```\n\n## Step 6: Final Summary\n\n```\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nExecution Complete: {project}\n\nTotal: {n} | âœ… {complete} | âŒ {failed} | ğŸš« {blocked}\n\n{If git active:}\nBranch: {branch}\nCommits: {count}\n\n{List completed/failed tasks}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n## Step 7: Generate Report (MANDATORY)\n\nWrite to `.working/colony/{project}/REPORT.md`:\n\n```markdown\n# Colony Report: {project}\n\nGenerated: {timestamp}\nOutcome: {COMPLETE|PARTIAL|FAILED}\nTasks: {passed} passed, {failed} failed, {blocked} blocked\nMilestones: {completed}/{total}\n\n## Milestones\n| Milestone | Status | Tasks |\n|-----------|--------|-------|\n| M1: {name} | complete | T001-T003 |\n| M2: {name} | partial | T004-T007 |\n\n## Results by Task\n| Task | Status | Attempts |\n|------|--------|----------|\n...\n\n## Decisions Made\n{From execution_log, filtered for decision events}\n\n| Time | Type | Decision | Details |\n|------|------|----------|---------|\n| 14:30 | parallelization | T001+T002 parallel | No file conflicts |\n| 15:00 | feedback | Created T009.1 | User: \"add .next to gitignore\" |\n| 15:30 | milestone | M1 approved | User confirmed |\n\n## Feedback Addressed\n| Feedback | Subtask | Status |\n|----------|---------|--------|\n| \"add .next to gitignore\" | T009.1 | complete |\n| \"404 on dev server\" | T009.2 | complete |\n\n## Findings\n### Critical Issues\n### Recurring Patterns\n\n## Recommended Actions\n...\n```\n\n**Always generate the report, even for partial/failed runs.**\n\n## Recovery\n\nIf interrupted, re-run `/colony-deploy`. Tasks \"running\" >30 min reset to pending.\n\n## User Commands\n\n| Command | Effect |\n|---------|--------|\n| \"pause\" | Stop after current batch |\n| \"autonomous\" | Switch to autonomous mode |\n| \"set concurrency to N\" | Adjust parallel agents |\n| \"skip T005\" | Mark skipped, continue |\n| \"retry T005\" | Reset to pending |\n| \"commit now\" | Force commit |\n| {feedback} | Triggers 5.9 |\n\n## Rules Summary\n\n**STATELESS LOOP (Most Important):**\n1. **Re-read state EVERY iteration** - Don't trust memory, CLI is truth\n2. **Rule echo every 3 tasks** - Refresh core rules periodically\n3. **CLI decides parallelization** - Use `next-batch`, don't second-guess\n\n**Core Rules:**\n4. NEVER verify without inspector PASS\n5. NEVER mark complete without artifacts\n6. **NEVER implement inline** - spawn workers for ALL implementation\n7. **Feedback = subtask** - Every feedback item becomes a formal subtask\n8. **Milestone checkpoints** - Pause at boundaries (unless autonomous)\n9. **Log decisions** - All decisions logged to execution_log\n",
        "commands/colony-mobilize.md": "---\nname: colony-mobilize\ndescription: Prepare a brief for parallel execution - task decomposition and worker mobilization\nversion: 1.7.0\nstatus: active\n\n# Claude Code command registration\nallowed-tools: Read, Write, Bash, Grep, Glob, AskUserQuestion\n---\n\n# Mobilize Colony\n\nPrepare a colony project by decomposing a brief into executable tasks.\n\n**Note:** This command prepares tasks for execution - it does NOT do strategic planning. For strategic planning (requirements, approach, architecture), use Claude's native plan mode first (`claude --permission-mode plan`), then pass the resulting plan here.\n\n## Step 0: Verify CLI\n\n```bash\n# Verify colony CLI is available (Claude Code's Bash doesn't inherit user PATH)\n[[ -x \"${CLAUDE_PLUGIN_ROOT}/bin/colony\" ]] && echo \"colony CLI ready\" || echo \"ERROR: colony CLI not found\"\n```\n\n## Step 1: Find Brief or Plan\n\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony config init 2>/dev/null || true\n\n# Check Claude plans folder (recent, last 48 hours)\necho \"=== Recent Claude Plans ===\"\nfind ~/.claude/plans ~/.claude-personal/plans -name \"*.md\" -mtime -2 2>/dev/null | head -5 || true\n\n# Check conventional locations\necho \"=== .working/ (primary) ===\" && ls -1 .working/*.md 2>/dev/null || true\necho \"=== docs/ ===\" && ls -1 docs/*.md 2>/dev/null || true\necho \"=== root ===\" && ls -1 ./*.md 2>/dev/null | grep -v -E '^\\./(README|CHANGELOG|LICENSE)' || true\n```\n\n**Priority order:**\n1. `$ARGUMENTS` - if user specified a path, use it\n2. `~/.claude/plans/*.md` - recent Claude plans (last 48 hours)\n3. `.working/*.md` - conventional location for briefs\n4. `docs/*.md` - documentation folder\n5. Root `.md` files (excluding README, CHANGELOG, LICENSE)\n\n**For Claude plans, assess relevance:**\n- Read the plan content\n- Check if it mentions files/paths that exist in current project\n- Check if it mentions current directory name\n- More recent = higher relevance\n\n**Present to user:**\n```\nFound potential plans:\n\nClaude Plans (recent):\n  1. ~/.claude/plans/gleaming-sniffing-bird.md (2 hours ago)\n     â­ Likely relevant - mentions src/auth/, package.json\n\n  2. ~/.claude/plans/proud-dazzling-papert.md (1 day ago)\n     Different project paths\n\nProject Briefs:\n  3. .working/FEATURE_BRIEF.md\n  4. docs/OAUTH_SPEC.md\n\nWhich would you like to use? [1-4, or enter path]\n```\n\nIf none found: ask for path or suggest using Claude plan mode first.\n\n## Step 1.5: Assess Brief Quality\n\n**Skip this step if brief comes from `~/.claude/plans/`** (Claude plans are pre-validated).\n\nFor other briefs, check for weak brief indicators:\n- Very short (< 100 words)\n- No acceptance criteria (no `- [ ]` checkboxes)\n- No file paths mentioned\n- Vague language only (\"improve\", \"better\", \"fix\", \"enhance\")\n- No technical specifics\n\n**If 3+ indicators present, warn:**\n\n```\nâš ï¸ This appears to be a high-level goal rather than a detailed plan.\n\nColony is an execution engine - it works best with well-defined requirements.\nFor strategic planning, consider using Claude's plan mode first:\n\n  claude --permission-mode plan\n  > [describe your goal, let Claude interview you]\n\nThen pass the resulting plan to Colony:\n  /colony-mobilize ~/.claude/plans/[plan-name].md\n\nLearn more: https://github.com/mattheworiordan/colony#colony--claude-plan-mode\n\nContinue anyway? [y/N]\n```\n\nUse AskUserQuestion. If user declines, exit. If user continues, note in context.md that brief was flagged as potentially underspecified.\n\n## Step 2: Generate Project Name\n\nDerive from brief filename or H1 heading, slugified. Example: `INTEGRATION_BRIEF.md` â†’ `integration-brief`\n\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state list\n```\n\nIf project exists: ask to continue, create new version, or overwrite.\n\n## Step 3: Task Type Assessment\n\nDetermine if project needs Git tracking.\n\n**Needs Git when:**\n- Brief mentions: implement, build, create feature, fix bug, refactor\n- Tasks modify tracked source files\n- Brief mentions: PR, pull request, merge\n\n**No Git when:**\n- Research, analyze, investigate, document\n- All outputs go to `.working/`\n- Brief says \"no code changes\"\n\nIf uncertain, ask user.\n\n## Step 4: Git Strategy (if applicable)\n\nSkip if task type is research/documentation.\n\n```bash\ngit status --porcelain\ngit branch --show-current\n```\n\nIf dirty: STOP, ask user to commit/stash.\n\n**Configure:**\n- Branch: feature branch or current\n- Commits: phase/task/end/manual\n- Style: conventional commits\n\n## Step 5: Extract Hard Requirements\n\n<critical>\nThis step is MANDATORY. The brief is a CONTRACT, not a suggestion.\n\nEvery verification requirement in the brief MUST map to:\n- A task that implements it, OR\n- An acceptance criterion that checks it, OR\n- A verification command that runs it\n\nVERIFICATION MUST EXECUTE, NOT JUST EXIST:\n- If the brief says \"run X\", verification must ACTUALLY RUN X\n- If the brief says \"test Y passes\", verification must EXECUTE the test\n- Checking that code exists is NOT the same as running that code\n- Checking that a file was created is NOT the same as verifying it works\n\nNO SUBSTITUTING complex verification with simpler checks.\nNO DELEGATING verification to humans when automation is possible.\n</critical>\n\n**Scan the brief and extract:**\n\n1. **Explicit verification requirements:**\n   - \"must pass visual tests\" â†’ Task that runs visual tests\n   - \"0 pixel difference\" â†’ Verification command with pixelmatch\n   - \"must pass integration tests\" â†’ Task that runs integration tests\n   - \"API must return X\" â†’ Verification command that curls and checks response\n\n2. **Gate conditions (blockers):**\n   - \"DO NOT proceed until X\" â†’ X becomes a blocking verification\n   - \"MANDATORY\" anything â†’ Must be in acceptance criteria\n   - \"must/shall/required\" statements â†’ Hard requirements\n\n3. **Infrastructure requirements:**\n   - \"start servers\" â†’ Task includes server lifecycle\n   - \"run against production\" â†’ Task includes environment setup\n   - \"compare with baseline\" â†’ Task includes baseline capture\n\n**Output a requirements checklist:**\n\n```markdown\n## Extracted Requirements\n\n| # | Requirement | Type | Source |\n|---|-------------|------|--------|\n| R1 | Visual tests pass with 0 diff | verification | \"DO NOT proceed until visual tests pass\" |\n| R2 | Playwright test scripts created | deliverable | \"Create scripts/visual-test-phase4.ts\" |\n| R3 | Both servers running for comparison | infrastructure | \"Run Gatsby (8000) and Next.js (3001)\" |\n| R4 | TypeScript compiles | verification | Implicit for TS project |\n```\n\nWrite this to `.working/colony/{project}/resources/requirements-checklist.md`\n\n**If a requirement cannot be automated:** Flag it explicitly and ask user how to handle. Do NOT silently drop it.\n\n## Step 6: Assess Complexity\n\nAfter analyzing the brief, estimate task count before decomposition.\n\n<critical>\nThis step is MANDATORY. You must estimate task count and follow the decision tree below.\nSkipping this step leads to either over-decomposition (too many small tasks) or under-decomposition (tasks too large to parallelize).\n</critical>\n\n**If estimated tasks â‰¤ 6:** Proceed with quality-first approach (atomic tasks).\n\n**If estimated tasks > 6:** You MUST ask user about atomicity vs speed using AskUserQuestion:\n\n```\nThis brief is substantial. I estimate ~{N} tasks across {M} milestones.\n\nHow should I balance atomicity vs execution speed?\n\n1. **Quality-first** (recommended for production)\n   - Atomic tasks, each independently verified\n   - Easier debugging, better recovery from failures\n   - ~{N} tasks, ~{rounds} execution rounds\n\n2. **Balanced**\n   - Consolidate tightly-coupled tasks\n   - Good middle ground\n   - ~{N*0.7} tasks\n\n3. **Speed-first** (for prototyping/experiments)\n   - Maximize consolidation\n   - Faster but larger blast radius on failure\n   - ~{N*0.5} tasks\n```\n\nUse AskUserQuestion. Default to Quality-first if user doesn't respond.\n\n## Step 6.5: Identify Shared Patterns (DRY)\n\nBefore decomposing into tasks, scan the brief for patterns likely to be reused across multiple tasks.\n\n**Why this matters:** Workers execute in isolation. If multiple tasks need the same icon, utility, or component, each worker will create its own version - causing duplication.\n\n**Common shared patterns to detect:**\n- UI components (icons, buttons, modals, form elements)\n- Utility functions (formatters, validators, parsers)\n- Types/interfaces used across features\n- API client methods\n- Constants/configuration\n\n**Detection heuristics:**\n- Same noun appears in multiple requirements (e.g., \"user avatar\" mentioned 3 times)\n- Common UI elements mentioned (icons, spinners, tooltips)\n- Data structures referenced by multiple features\n\n**If shared patterns detected:**\n\nCreate infrastructure task(s) in Milestone 1:\n```\nT001: \"Create shared {pattern} components/utilities\"\n```\n\nThen ensure subsequent tasks depend on the shared infrastructure completing first.\n\n**Example:**\n```\nBrief mentions \"user avatar\" in:\n- Message display feature\n- Presence list feature\n- Profile popup feature\n\nâ†’ Create T001: \"Create shared UserAvatar component\"\nâ†’ T002, T003, T004 (features) all depend on T001\n```\n\nThis prevents duplicate implementations across parallel workers.\n\n## Step 7: Design Parallel Execution\n\n**Goal:** Minimize sequential chains, maximize concurrent execution.\n\n**Process:**\n1. Identify tasks with NO dependencies (Round 1 candidates)\n2. For each subsequent task, depend on minimum required predecessors\n3. Avoid unnecessary chains (T001 â†’ T002 â†’ T003 when T002/T003 are independent)\n4. Group tasks touching different files - they can parallelize\n\n**Output execution rounds estimate:**\n\n```\nExecution Rounds (concurrency=5):\nRound 1: T001, T003 (no deps, different modules)\nRound 2: T002, T004 (deps satisfied, different files)\nRound 3: T005, T006 (parallel integration)\nRound 4: T007\nRound 5: T008, T009 (tests + docs, independent)\n\nTotal: 5 rounds for 9 tasks\nSequential would be: 9 rounds\nParallelization benefit: 44% faster\n```\n\n**Anti-pattern to avoid:**\n```\n# BAD: Unnecessary chain\nT001 â†’ T002 â†’ T003 â†’ T004  (serial)\n\n# GOOD: Parallel where possible\nT001 â”€â”¬â†’ T002\n      â””â†’ T003 â†’ T004\n```\n\n## Step 8: Identify Milestones\n\nMilestones are natural review points where work can be paused, reviewed, and approved before continuing. They help break large projects into reviewable chunks.\n\n**Auto-detect milestones from:**\n- Phases explicitly mentioned in brief (\"Phase 1\", \"Stage 1\", \"Step 1\")\n- Logical boundaries (infrastructure â†’ implementation â†’ testing)\n- Git strategy hints (if brief mentions multiple PRs or branches)\n- Task dependencies that create natural groupings\n\n**Milestone structure:**\n```json\n{\n  \"id\": \"M1\",\n  \"name\": \"Infrastructure Setup\",\n  \"tasks\": [\"T001\", \"T002\", \"T003\"],\n  \"checkpoint\": \"review\"\n}\n```\n\n**Checkpoint types:**\n- `review` (default) - Pause for human approval before continuing\n- `commit` - Auto-commit at milestone boundary, then continue\n- `branch` - Create new branch for next milestone\n- `pr` - Create PR for completed milestone\n\n**Behavior:**\n- If milestones are obvious from brief: state them and proceed (user can challenge)\n- If milestones are unclear: suggest milestones and confirm\n- If brief is small (<10 tasks): single milestone is fine\n- Don't over-ask - let user challenge after if they disagree\n\n**Default checkpoint:** `review` (pause and ask for approval in non-autonomous mode)\n\n## Step 9: Create Project Directories\n\nCreate the directory structure (but NOT state.json yet - that comes in Step 12 with bulk import):\n\n```bash\nworking_dir=\"${CLAUDE_PLUGIN_ROOT}/../../../.working\"  # Or use colony working-dir\nmkdir -p .working/colony/{project-name}/{tasks,logs,resources,screenshots}\n```\n\nThis creates:\n```\n.working/colony/{project}/\nâ”œâ”€â”€ tasks/\nâ”œâ”€â”€ logs/\nâ”œâ”€â”€ resources/\nâ””â”€â”€ screenshots/\n```\n\n**Note:** state.json is created in Step 12 via `--from plan.json` with all tasks and milestones.\n\n## Step 9.5: Detect Project Standards\n\nScan for quality/standards files that workers must follow:\n\n```bash\necho \"=== Standards Detection ===\"\n[[ -f \"CLAUDE.md\" ]] && echo \"CLAUDE.md found\" || true\n[[ -f \".claude/CLAUDE.md\" ]] && echo \".claude/CLAUDE.md found\" || true\n[[ -f \"CONTRIBUTING.md\" ]] && echo \"CONTRIBUTING.md found\" || true\n[[ -f \".eslintrc*\" || -f \"eslint.config.*\" ]] && echo \"ESLint config found\" || true\n[[ -f \".prettierrc*\" || -f \"prettier.config.*\" ]] && echo \"Prettier config found\" || true\n[[ -f \"tsconfig.json\" ]] && echo \"TypeScript config found\" || true\n[[ -f \"pyproject.toml\" || -f \"setup.cfg\" ]] && echo \"Python config found\" || true\n[[ -f \"go.mod\" ]] && echo \"Go module found\" || true\n```\n\n**Include detected standards in context.md** (see Step 10).\n\n**Philosophy:** Detect what EXISTS, don't impose new standards. Workers should follow the project's established patterns, not Colony's opinions.\n\n## Step 10: Write Context File\n\nWrite `.working/colony/{project}/context.md`:\n\n```markdown\n# Project Context: {project-name}\n\nCaptured: {timestamp}\n\n## Task Type\n{implementation | research | documentation}\n\n## Git Strategy\n{Branch, commit frequency, or \"not applicable\"}\n\n## Verification Type\n{code-only | visual | mixed}\n\n## Milestones\n| ID | Name | Tasks | Checkpoint |\n|----|------|-------|------------|\n| M1 | {name} | T001-T003 | review |\n| M2 | {name} | T004-T007 | review |\n\n## Project Standards\n\n**Guidelines files detected:**\n{List CLAUDE.md, CONTRIBUTING.md if found}\n\n**Quality tools detected:**\n{List ESLint, Prettier, TypeScript, etc. if found}\n\n**Workers MUST:**\n- Follow patterns in existing codebase\n- Run lint/format if project has them configured\n- Adhere to CLAUDE.md guidelines if present\n- Match existing code style\n\n## Project Rules\n{From CLAUDE.md if exists, summarized}\n\n## Parallelization\n- Can parallelize: {list with reasoning}\n- Must serialize: {list with reasoning}\n\n## Tech Stack\n{From package.json, etc.}\n\n## Decisions Log\n{Orchestrator will append decisions here during execution}\n\n## Feedback History\n{Orchestrator will append user feedback and resulting subtasks here}\n```\n\n### Context Split Rule\n\nKeep context.md unified UNLESS both conditions are met:\n1. **Optional for â‰¥50% of tasks** - Extended content isn't needed by at least half the tasks\n2. **â‰¥30 lines** - Big enough to matter for token efficiency\n\nIf both met: Create `context-extended.md` and reference it from context.md.\n\n## Step 11: Decompose into Tasks\n\n<critical>\nEach task file must be SELF-CONTAINED. Workers have NO memory of:\n- The original brief\n- Other tasks\n- Your conversation history\n\nPRESERVE in each task:\n- User quotes showing preferences\n- Design philosophy and intent\n- What to AVOID\n- How task relates to broader goal\n\nCONDENSE (don't remove):\n- Lengthy background\n\nOMIT:\n- Information about other tasks\n</critical>\n\n### Task Sizing\n\n**Goal: Minimize task count while maintaining parallelization opportunities.**\n\n**Why this matters:**\n- Each task has fixed overhead: worker spawn (~30s), inspector verification (~30s), state management\n- 9 tasks vs 6 tasks = 50% more overhead before any real work happens\n- Granular tasks also increase failure surface area (more chances for lint errors, retry loops)\n- The benefit of splitting is parallelizationâ€”if tasks can't run in parallel, combining them is pure gain\n\n**Decomposition principles:**\n1. **One module = one task** - Don't split types/constants/utils into separate tasks\n2. **Split only for parallelization** - If two things can't run in parallel, combine them\n3. **Split for different expertise** - Tests vs implementation vs docs can be separate\n\n**Right-sizing test:** For each task, ask \"could this be combined with an adjacent task without losing parallelization?\" If yes, combine.\n\n**Examples:**\n- âœ… \"Create protocol module\" (includes types, constants, parser, utils)\n- âŒ \"Create types\" + \"Create constants\" + \"Create parser\" + \"Create utils\" (4 tasks for one module)\n\n- âœ… \"Migrate auth module to new framework\" (one coherent unit)\n- âŒ \"Update imports\" + \"Change function signatures\" + \"Update tests\" (if all in same files)\n\n### Task File Format\n\nWrite `.working/colony/{project}/tasks/T{NNN}.md`:\n\n```markdown\n# Task T{NNN}: {Short Name}\n\n## Status\npending\n\n## Why This Task\n{Specific reason this task exists - not project background}\n\n## What To Do\n{Concrete deliverable - be specific}\n\n## What To Avoid\n{Task-specific pitfalls, anti-patterns}\n\n## Files\n- {path/to/file1}\n\n## Acceptance Criteria\n- [ ] {Specific, verifiable}\n\n## Verification Command\n```bash\n{command - see guidelines below}\n```\n\n## Dependencies\n{T001 or \"None\"}\n```\n\n**OMIT from task files** (already in context.md which workers receive):\n- Tech stack details\n- Git strategy\n- Coding standards\n- General project background\n\n### Verification Command Guidelines\n\nVerification must be achievable when the task completes. Don't reference artifacts that don't exist yet.\n\n**Simple verification (code-only tasks):**\n\n| Task Type | Verification | Example |\n|-----------|--------------|---------|\n| New module | TypeScript compiles | `npx tsc --noEmit` |\n| New function | Module exports it | `node -e \"require('./src/mod').fn\"` |\n| Integration | Build succeeds | `npm run build` |\n| Integration | Existing tests pass | `npm test` |\n| Test creation | New tests pass | `npm test -- --grep \"pattern\"` |\n| Documentation | File has content | `test -s README.md` |\n\n**Complex verification (when brief requires it):**\n\n| Task Type | Verification | Example |\n|-----------|--------------|---------|\n| Visual comparison | Playwright + pixelmatch | See template below |\n| API endpoint | curl + jq | `curl -s localhost:3000/api/x \\| jq -e '.status == \"ok\"'` |\n| Browser behavior | Playwright script | `npx playwright test {script}` |\n| E2E flow | Full test suite | `npm run e2e` |\n| CLI output | Command + grep | `./cli --version \\| grep -q \"1.0\"` |\n\n**Visual/Browser verification template:**\n\n```bash\n#!/bin/bash\n# Start servers\nnpm run dev & PID1=$!\nnpm run dev:next -- --port 3001 & PID2=$!\n\n# Wait for servers (with timeout)\ntimeout 60 bash -c 'until curl -s http://localhost:8000 > /dev/null; do sleep 1; done'\ntimeout 60 bash -c 'until curl -s http://localhost:3001 > /dev/null; do sleep 1; done'\n\n# Run visual tests\nnpx playwright test scripts/visual-test.ts\nRESULT=$?\n\n# Cleanup\nkill $PID1 $PID2 2>/dev/null\n\nexit $RESULT\n```\n\n<critical>\nVERIFICATION MUST MATCH REQUIREMENT SEMANTICS:\n\nThe verification command must EXECUTE what the requirement describes.\nSimpler proxies are NOT acceptable substitutes:\n\n| Requirement | Wrong Verification | Right Verification |\n|-------------|-------------------|-------------------|\n| \"Tests pass\" | Check test file exists | Run the tests |\n| \"API returns 200\" | Check route exists | curl and check response |\n| \"Visual diff is 0\" | Check screenshot exists | Run comparison, check diff count |\n| \"Build succeeds\" | Check config exists | Run the build |\n\nIf the brief says \"run X\", verification must run X - not check that X could theoretically run.\n</critical>\n\n**Anti-pattern:** Don't reference tests that don't exist yet. If T001 creates a parser and T008 creates tests, T001's verification should be `npx tsc --noEmit`, not `npm test -- --grep parser`.\n\n## Step 12: Write Plan File and Initialize State\n\nWrite `.working/colony/{project}/plan.json` with all tasks, milestones, and config:\n\n```json\n{\n  \"total_tasks\": 9,\n  \"tasks\": {\n    \"T001\": {\"status\": \"pending\", \"attempts\": 0, \"milestone\": \"M1\"},\n    \"T002\": {\"status\": \"pending\", \"attempts\": 0, \"milestone\": \"M1\", \"depends_on\": [\"T001\"]},\n    \"T003\": {\"status\": \"pending\", \"attempts\": 0, \"milestone\": \"M2\"}\n  },\n  \"milestones\": [\n    {\"id\": \"M1\", \"name\": \"Infrastructure\", \"tasks\": [\"T001\", \"T002\"], \"checkpoint\": \"review\", \"status\": \"pending\"},\n    {\"id\": \"M2\", \"name\": \"Implementation\", \"tasks\": [\"T003\"], \"checkpoint\": \"review\", \"status\": \"pending\"}\n  ],\n  \"git\": {\n    \"strategy\": \"active\",\n    \"branch\": \"feature/my-feature\",\n    \"commit_strategy\": \"phase\"\n  }\n}\n```\n\nThen initialize with bulk import (one command instead of many):\n\n```bash\n${CLAUDE_PLUGIN_ROOT}/bin/colony state init {project} --from .working/colony/{project}/plan.json\n```\n\nThis is atomic - either all state is created or none. Reduces agent overhead and errors.\n\n## Step 13: Copy Brief\n\n```bash\ncp {brief-path} .working/colony/{project}/resources/original-brief.md\n```\n\n## Step 13.5: Validate Requirement Coverage (MANDATORY)\n\n<critical>\nThis validation step catches requirement drift BEFORE execution begins.\nIf validation fails, DO NOT proceed to Step 14. Fix the tasks first.\n\nCORE PRINCIPLE: Human review is ADDITION, not REPLACEMENT.\nMilestone checkpoints may include human review, but this does NOT excuse\nautomated testing. Every testable requirement must have automated verification.\n</critical>\n\n**Spawn a validation agent:**\n\n```\nTask(\n  subagent_type: \"general-purpose\",\n  model: \"sonnet\",  // Validation requires judgment about semantic equivalence\n  prompt: \"You are a requirements validator. Your job is to ensure every requirement\nfrom the brief has been translated into executable, automated tasks.\n\n## Inputs\n\n1. Original brief: .working/colony/{project}/resources/original-brief.md\n2. Requirements checklist: .working/colony/{project}/resources/requirements-checklist.md\n3. Task files: .working/colony/{project}/tasks/*.md\n\n## Core Principle\n\nHUMAN REVIEW IS ADDITION, NOT REPLACEMENT.\n\nMilestone checkpoints may pause for human approval - that's fine.\nBut human review does NOT excuse automated testing.\nEvery testable requirement must have automated verification.\n\n## Validation Process\n\n1. Read the original brief\n2. Read the requirements checklist\n3. Read ALL task files\n4. For EACH requirement in the checklist:\n   - Find the task(s) that address it\n   - Verify the verification command ACTUALLY EXECUTES the requirement\n   - Check for semantic equivalence, not just structural presence\n\n## Automatic Failures\n\nFlag as WEAK COVERAGE if verification:\n- Checks file existence instead of running tests\n- Checks code presence instead of executing code\n- Says 'manual verification required' for automatable checks\n- Substitutes simpler proxy checks for actual requirement\n\n## Output\n\nCreate `.working/colony/{project}/resources/validation-report.md`:\n\n```markdown\n# Requirement Coverage Report\n\n## Coverage Summary\n- Total requirements: {N}\n- Covered (automated): {X}\n- Missing: {Y}\n- Weak coverage: {Z}\n\n## Detailed Analysis\n\n### âœ… Covered Requirements\n| Req | Task | How Verified |\n|-----|------|--------------|\n| R1: Tests pass | T019 | Verification runs `npm test` |\n\n### âŒ Missing Requirements\n| Req | Issue | Suggested Fix |\n|-----|-------|---------------|\n| R2: API returns 200 | No task calls the endpoint | Add curl check to T015 |\n\n### âš ï¸ Weak Coverage (MUST FIX)\n| Req | Task | Issue |\n|-----|------|-------|\n| R3: Build succeeds | T016 | Verification checks config exists, doesn't run build |\n```\n\nIMPORTANT: Weak coverage is NOT acceptable. If verification doesn't\nEXECUTE the requirement, it's the same as missing coverage.\n\nRespond with:\n- 'PASS' if all requirements have AUTOMATED coverage\n- 'FAIL: {list of gaps}' if any missing or weak\"\n)\n```\n\n**Process the validation result:**\n\n**If PASS:** Proceed to Step 14.\n\n**If FAIL:**\n\n1. Review the gaps identified\n2. Either:\n   a. Update task files to add missing verification, OR\n   b. Create additional tasks for missing requirements\n3. Re-run validation until PASS\n\n**Do NOT skip this step.** The brief is a contract. If requirements aren't covered, execution will produce incomplete results.\n\n## Step 14: Summary\n\n```markdown\n## Project Created: {project-name}\n\nLocation: .working/colony/{project}/\nTasks: {count}\nMilestones: {milestone_count}\nType: {implementation | research}\n\n### Milestones\n| Milestone | Tasks | Checkpoint |\n|-----------|-------|------------|\n| M1: {name} | T001-T003 | review |\n| M2: {name} | T004-T007 | review |\n\n### Execution Plan\n\n```\nEstimated rounds (concurrency=5):\nRound 1: T001, T003 (parallel, no deps)\nRound 2: T002, T004 (parallel, deps satisfied)\n...\nTotal: {X} rounds for {Y} tasks ({Z}% parallelization benefit)\n```\n\n**M1 - {name}:**\n- T001: {name}\n- T002, T003 (parallel)\n\n**M2 - {name}:**\n- T004: {name}\n- T005, T006, T007 (parallel)\n\n### Next Steps\n1. Review tasks: `ls .working/colony/{project}/tasks/`\n2. Deploy: `/colony-deploy` (pauses at each milestone for review)\n3. Autonomous: `/colony-deploy autonomous` (no pauses)\n```\n",
        "commands/colony-projects.md": "---\nname: colony-projects\ndescription: List all colony projects with summary status\nversion: 1.7.0\nstatus: active\n\n# Claude Code command registration\nallowed-tools: Read, Bash, Glob\n---\n\n# Task Projects\n\nList all colony projects with their status.\n\n## Step 1: Find Projects\n\n```bash\nls -d .working/colony/*/ 2>/dev/null\n```\n\nIf no projects:\n```\nNo colony projects found.\n\nUse /colony-mobilize to create a project from a brief.\n```\n\n## Step 2: Load Each Project's State\n\nFor each project directory, read `state.json` and calculate:\n- Total tasks\n- Completed count\n- Failed count\n- Blocked count\n- Last activity timestamp\n\n## Step 3: Display Summary\n\n```markdown\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n## Colony Projects\n\n| Project | Progress | Status | Tasks | Last Activity |\n|---------|----------|--------|-------|---------------|\n| integration-brief | â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80% | ğŸ”„ Running | 16/20 | 2 min ago |\n| api-refactor | â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘ 40% | â¸ Paused | 8/20 | 3 days ago |\n| test-cleanup | â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100% | âœ… Complete | 5/5 | 1 week ago |\n| oauth-feature | â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 20% | âŒ Has Failures | 2/10 | 1 hour ago |\n\n### Quick Stats\n\n**Active:** 2 projects\n**Complete:** 1 project\n**With Failures:** 1 project\n\n### Project Details\n\n**integration-brief** (active)\n- Source: .working/INTEGRATION_BRIEF.md\n- Created: 2 hours ago\n- Concurrency: 5 agents\n- âœ… 16 complete, â³ 4 pending\n\n**api-refactor** (paused)\n- Source: docs/API_REFACTOR_PLAN.md\n- Created: 3 days ago\n- Concurrency: 3 agents\n- âœ… 8 complete, â³ 10 pending, âŒ 2 failed\n\n**oauth-feature** (has failures)\n- Source: .working/OAUTH_FEATURE.md\n- Created: 2 hours ago\n- Concurrency: 5 agents\n- âœ… 2 complete, â³ 5 pending, âŒ 1 failed, ğŸš« 2 blocked\n- **Blocking issue:** T003 failed - missing API credentials\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n### Commands\n\n| Command | Action |\n|---------|--------|\n| `/colony-status {project}` | Detailed status for a project |\n| `/colony-deploy {project}` | Start/resume execution |\n| `/colony-mobilize` | Create a new project |\n| \"delete {project}\" | Remove a project |\n| \"archive {project}\" | Move to .working/colony/archive/ |\n```\n\n## Step 4: Interactive Options\n\nAfter listing, user can:\n\n| Command | Action |\n|---------|--------|\n| \"show {project}\" | Same as /colony-status {project} |\n| \"run {project}\" | Same as /colony-deploy {project} |\n| \"delete {project}\" | Remove project directory |\n| \"archive {project}\" | Move to archive folder |\n| \"clean completed\" | Archive all 100% complete projects |\n",
        "commands/colony-quick.md": "---\nname: colony-quick\ndescription: Quick task execution from a simple prompt - auto-generates brief and tasks\nversion: 1.7.0\nstatus: experimental\n\n# Claude Code command registration\nallowed-tools: Read, Write, Bash, Task, Grep, Glob\n---\n\n# Quick Tasks\n\nExecute a task directly from a simple prompt without manual brief/task creation.\n\n**Use this for**: Well-defined, straightforward tasks where you trust the AI to decompose appropriately.\n\n**Don't use this for**: Complex tasks requiring nuanced context, design decisions, or user input during planning.\n\n## How It Works\n\n```\n/colony-quick \"Add dark mode toggle to settings page, persist preference to localStorage\"\n```\n\nThis will:\n1. Auto-generate a minimal brief from your prompt\n2. Decompose into 2-5 small tasks\n3. Run in autonomous mode\n4. Return when done or stuck\n\n## Step 1: Parse Prompt\n\nExtract from `$ARGUMENTS`:\n- The core request\n- Any explicit requirements mentioned\n- Implied acceptance criteria\n\n## Step 2: Validate Suitability\n\n**Check if this task is suitable for quick execution:**\n\n| Signal | Suitable | Not Suitable |\n|--------|----------|--------------|\n| Clear, specific request | Yes | Vague requirements |\n| Mechanical/well-defined | Yes | Requires design decisions |\n| Small scope (<5 tasks likely) | Yes | Large scope (>10 tasks) |\n| Has testable outcome | Yes | Subjective success criteria |\n| Standard patterns | Yes | Novel architecture |\n\n**If NOT suitable:**\n```\nThis task seems too complex for /colony-quick:\nâ€¢ {reason 1}\nâ€¢ {reason 2}\n\nSuggest using /colony-mobilize instead for:\nâ€¢ More control over task decomposition\nâ€¢ Ability to add context and design intent\nâ€¢ Interactive planning\n\nContinue anyway? [y/N]\n```\n\nIf user says no or doesn't respond, exit.\n\n## Step 3: Generate Brief\n\nCreate `.working/colony/{project-name}/resources/original-brief.md`:\n\n```markdown\n# Quick Task: {slugified-name}\n\nGenerated from: /colony-quick\nPrompt: \"{original prompt}\"\n\n## Goal\n{restate the goal clearly}\n\n## Acceptance Criteria\n- [ ] {derived criterion 1}\n- [ ] {derived criterion 2}\n- [ ] {derived criterion 3}\n\n## Constraints\n- Keep changes minimal and focused\n- Follow existing codebase patterns\n- All tests must pass after changes\n\n## Verification\n{how to verify success - tests, manual check, etc.}\n```\n\n## Step 4: Quick Decomposition\n\nCreate 2-5 tasks maximum. Each task should be:\n- Small (5-15 minutes)\n- Independently verifiable\n- Sequential by default (safe parallelization is hard to infer)\n\n### Task Format (Simplified)\n\n```markdown\n# Task T{N}: {name}\n\n## Status\npending\n\n## Description\n{what to do}\n\n## Files\n- {likely files to modify}\n\n## Acceptance Criteria\n- [ ] {criterion}\n\n## Completion Promise\nWhen done, output: TASK_COMPLETE: T{N}\n\n## Verification Command\n```bash\n{command}\n```\n\n## Dependencies\n{T{N-1} or \"None\"}\n```\n\n**Skip these sections** (no rich context for quick tasks):\n- Context & Why (implied from prompt)\n- Design Intent (not provided)\n- Considerations (keep it simple)\n\n## Step 5: Create Project Structure\n\n```bash\nmkdir -p .working/colony/{project-name}/tasks\nmkdir -p .working/colony/{project-name}/logs\nmkdir -p .working/colony/{project-name}/resources\n```\n\nCreate minimal `state.json`:\n\n```json\n{\n  \"project_name\": \"{project-name}\",\n  \"created_at\": \"{timestamp}\",\n  \"brief_source\": \"quick-task\",\n  \"total_tasks\": {count},\n  \"concurrency\": 1,\n  \"autonomous_mode\": true,\n  \"task_type\": \"implementation\",\n  \"git\": {\n    \"strategy\": \"not_applicable\"\n  },\n  \"tasks\": {\n    \"T001\": {\"status\": \"pending\", \"attempts\": 0}\n  }\n}\n```\n\n**Note**: Quick tasks default to:\n- `concurrency: 1` (serial execution, safer)\n- `autonomous_mode: true` (no checkpoints)\n- `git.strategy: \"not_applicable\"` (no branch/commits)\n\n## Step 6: Execute\n\nShow brief summary:\n```\nâš¡ Quick Task: {project-name}\n\nDecomposed into {N} tasks:\n1. T001: {name}\n2. T002: {name}\n...\n\nRunning in autonomous mode (serial)...\n```\n\nThen execute using the same loop as `/colony-deploy` but with:\n- Always autonomous mode\n- Always serial execution (concurrency: 1)\n- No Git operations\n- Simplified progress output\n\n## Step 7: Report Result\n\nOn completion:\n```\nâœ… Quick Task Complete: {project-name}\n\nTasks: {completed}/{total}\n{If any failed: \"âš ï¸ {N} task(s) failed - see logs\"}\n\nChanges made:\n- {file1} (modified)\n- {file2} (created)\n\nVerification:\n{test output or verification result}\n\nFull logs: .working/colony/{project-name}/logs/\n```\n\nOn failure:\n```\nâŒ Quick Task Failed: {project-name}\n\nCompleted: {N}/{total}\nFailed at: T{X} - {task name}\n\nError:\n{error summary}\n\nOptions:\nâ€¢ Fix the issue and run: /colony-deploy {project-name}\nâ€¢ See details: /colony-status {project-name}\nâ€¢ Abandon: rm -rf .working/colony/{project-name}\n```\n\n## Safety Rules\n\n1. **Max 5 tasks** - If decomposition yields >5 tasks, suggest /colony-mobilize\n2. **Serial execution only** - No parallelization inference\n3. **No Git operations** - Changes stay uncommitted\n4. **30 minute timeout** - Abort if taking too long\n5. **3 retries per task** - Then fail the whole quick task\n\n## Examples\n\n### Good Quick Tasks\n\n```bash\n# Clear, specific, testable\n/colony-quick \"Add a loading spinner to the submit button\"\n/colony-quick \"Fix the typo 'recieve' -> 'receive' across all files\"\n/colony-quick \"Add validation for email field - must be valid email format\"\n/colony-quick \"Extract the header component into its own file\"\n```\n\n### Bad Quick Tasks (Use /colony-mobilize Instead)\n\n```bash\n# Too vague\n/colony-quick \"Improve the UX\"\n\n# Too large\n/colony-quick \"Add user authentication with OAuth, email verification, and password reset\"\n\n# Requires decisions\n/colony-quick \"Refactor the data layer\"\n\n# Subjective outcome\n/colony-quick \"Make the homepage look better\"\n```\n",
        "commands/colony-status.md": "---\nname: colony-status\ndescription: Show detailed status of a colony project\nversion: 1.7.0\nstatus: active\n\n# Claude Code command registration\nallowed-tools: Read, Bash, Glob\n---\n\n# Task Status\n\nShow detailed status for a colony project.\n\n## Step 1: Find Project\n\nIf $ARGUMENTS specifies a project, use that.\n\nOtherwise, check for projects:\n```bash\nls -d .working/colony/*/ 2>/dev/null\n```\n\n- One project â†’ show that project's status\n- Multiple projects â†’ ask which one (or suggest `/colony-projects` for overview)\n- No projects â†’ \"No projects found. Use /colony-mobilize to create one.\"\n\n## Step 2: Load State\n\n```\nRead: .working/colony/{project}/state.json\n```\n\n## Step 3: Display Status\n\n```markdown\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n## {project-name}\n\n**Progress:** â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 60% ({completed}/{total})\n**Status:** {Running | Paused | Complete | Has Failures}\n**Mode:** {Interactive | Autonomous}\n**Concurrency:** {n} agents\n**Last Activity:** {relative time}\n\n### Task Overview\n\n| ID | Name | Status | Attempts | Time |\n|----|------|--------|----------|------|\n| T001 | Setup database | âœ… Complete | 1 | 2m |\n| T002 | Add user model | âœ… Complete | 1 | 5m |\n| T003 | Add auth | ğŸ”„ Running | 1 | - |\n| T004 | Add sessions | â³ Pending | 0 | - |\n| T005 | Add OAuth | âŒ Failed | 2 | - |\n| T006 | OAuth tests | ğŸš« Blocked | 0 | - |\n\n### By Status\n\n**âœ… Completed ({n}):** T001, T002\n**ğŸ”„ Running ({n}):** T003\n**â³ Pending ({n}):** T004, T007, T008\n**âŒ Failed ({n}):** T005\n**ğŸš« Blocked ({n}):** T006\n\n### Parallelization Groups\n\n| Group | Strategy | Tasks | Status |\n|-------|----------|-------|--------|\n| setup | Serial | T001 | âœ… Done |\n| features | Parallel (5) | T002-T005 | ğŸ”„ In Progress |\n| browser-tests | Serial | T006-T008 | â³ Waiting |\n\n### Failed Task Details\n\n**T005: Add OAuth**\n- Error: Missing OAUTH_CLIENT_ID environment variable\n- Attempts: 2\n- Last attempt: 5 minutes ago\n- Suggestion: Add OAuth credentials to .env\n\n### Recent Activity\n\n{Last 5 entries from execution_log}\n\n```\n10:30:15 T001 started\n10:32:45 T001 verified PASS\n10:32:46 T002, T003, T004 started (parallel)\n10:35:12 T002 verified PASS\n10:38:00 T003 verified PASS\n10:38:01 T004 verified FAIL - retrying\n```\n\n### Next Steps\n\n{If running: \"Execution in progress...\"}\n{If paused: \"Run /colony-deploy to continue\"}\n{If complete: \"All tasks complete!\"}\n{If failures: \"Fix T005 and run /colony-deploy to retry\"}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n## Step 4: Interactive Commands\n\nAfter showing status, user can:\n\n| Command | Action |\n|---------|--------|\n| \"show T005\" | Show full task details and error |\n| \"retry T005\" | Reset to pending for retry |\n| \"skip T005\" | Mark as skipped, unblock dependents |\n| \"details\" | Show all task files |\n| \"log\" | Show full execution log |\n"
      },
      "plugins": [
        {
          "name": "colony",
          "description": "Decompose complex tasks into parallel sub-tasks with independent verification",
          "version": "1.1.0",
          "author": {
            "name": "Matthew O'Riordan",
            "email": "matthew@oriordan.org"
          },
          "source": "./",
          "category": "productivity",
          "homepage": "https://github.com/mattheworiordan/colony",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add mattheworiordan/colony",
            "/plugin install colony@colony-plugins"
          ]
        }
      ]
    }
  ]
}