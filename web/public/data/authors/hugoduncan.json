{
  "author": {
    "id": "hugoduncan",
    "display_name": "Hugo Duncan",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/54043?v=4",
    "url": "https://github.com/hugoduncan",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 1221,
      "total_forks": 52
    }
  },
  "marketplaces": [
    {
      "name": "criterium",
      "version": null,
      "description": "Claude Code plugin for Clojure benchmarking with criterium",
      "owner_info": {
        "name": "Criterium Team"
      },
      "keywords": [],
      "repo_full_name": "hugoduncan/criterium",
      "repo_url": "https://github.com/hugoduncan/criterium",
      "repo_description": "Benchmarking library for clojure",
      "homepage": "http://hugoduncan.github.io/criterium",
      "signals": {
        "stars": 1221,
        "forks": 52,
        "pushed_at": "2026-01-28T23:51:59Z",
        "created_at": "2009-12-16T15:40:35Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 398
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 151
        },
        {
          "path": ".clj-kondo",
          "type": "tree",
          "size": null
        },
        {
          "path": ".clj-kondo/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".clj-kondo/hooks/impl.clj",
          "type": "blob",
          "size": 6364
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 4239
        },
        {
          "path": "bases",
          "type": "tree",
          "size": null
        },
        {
          "path": "bases/criterium",
          "type": "tree",
          "size": null
        },
        {
          "path": "bases/criterium/validation",
          "type": "tree",
          "size": null
        },
        {
          "path": "bases/criterium/validation/README.md",
          "type": "blob",
          "size": 2986
        },
        {
          "path": "dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "dev/README.md",
          "type": "blob",
          "size": 112
        },
        {
          "path": "projects",
          "type": "tree",
          "size": null
        },
        {
          "path": "projects/agent",
          "type": "tree",
          "size": null
        },
        {
          "path": "projects/agent/README.md",
          "type": "blob",
          "size": 7173
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/criterium",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/criterium/SKILL.md",
          "type": "blob",
          "size": 12465
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"criterium\",\n  \"metadata\": {\n    \"description\": \"Claude Code plugin for Clojure benchmarking with criterium\"\n  },\n  \"owner\": {\n    \"name\": \"Criterium Team\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"criterium\",\n      \"source\": \"./\",\n      \"description\": \"Benchmarking library for Clojure\",\n      \"version\": \"0.5.0\",\n      \"license\": \"EPL-1.0\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"criterium\",\n  \"description\": \"Skill for using criterium benchmarking library\",\n  \"version\": \"0.5.0\",\n  \"skills\": [\"./skills/criterium\"]\n}\n",
        ".clj-kondo/hooks/impl.clj": "(ns hooks.impl\n  \"Hooks for criterium implementation linting\"\n  (:require\n   [clj-kondo.hooks-api :as api]))\n\n(defn def-multi-view\n  \"Rewrite def-multi-view to define the funcrion and multi-method.\"\n  [{:keys [node]}]\n  (let [[_ n]    (:children node)\n        mm-n     (api/token-node (symbol (str (:string-value n) \"*\")))\n        new-node (api/list-node\n                  (list\n                   (api/token-node 'do)\n                   (api/list-node\n                    (list\n                     (api/token-node 'defmulti)\n                     mm-n\n                     (api/token-node 'identity)))\n                   (api/list-node\n                    (list\n                     (api/token-node 'defn) n\n                     (api/list-node\n                      (list (api/vector-node [])))\n                     (api/list-node\n                      (list\n                       (api/vector-node [(api/token-node 'arg)])\n                       (api/token-node 'arg)))))\n                   ;; use the multi-view\n                   (api/list-node\n                    (list n))))]\n    ;; un-comment below to debug changes\n    ;; (prn :def-multi-view (api/sexpr new-node))\n    {:node (with-meta new-node (meta node))}))\n\n(defn cond*\n  \"Hook for cond* macro that handles :let bindings.\n  Transforms cond* into nested let and if forms so clj-kondo can track bindings.\"\n  [{:keys [node]}]\n  (let [children (rest (:children node))] ; skip 'cond*\n    (letfn [(process-clauses [clauses]\n              (if (seq clauses)\n                (let [guard (first clauses)\n                      remaining (rest clauses)]\n                  (if (seq remaining)\n                    (let [body (first remaining)\n                          rest-clauses (rest remaining)]\n                      (if (= :let (api/sexpr guard))\n                        ;; :let clause - create a let form\n                        (api/list-node\n                         (list\n                          (api/token-node 'let)\n                          body\n                          (or (process-clauses rest-clauses)\n                              (api/token-node 'nil))))\n                        ;; regular cond clause - create if form\n                        (api/list-node\n                         (list\n                          (api/token-node 'if)\n                          guard\n                          body\n                          (or (process-clauses rest-clauses)\n                              (api/token-node 'nil))))))\n                    ;; odd number of clauses, error case\n                    (api/token-node 'nil)))\n                ;; no more clauses\n                nil))]\n      (let [new-node (or (process-clauses children)\n                         (api/token-node 'nil))]\n        ;; un-comment below to debug changes\n        ;; (prn :cond* :original (api/sexpr node))\n        ;; (prn :cond* :transformed (api/sexpr new-node))\n        {:node (with-meta new-node (meta node))}))))\n\n(defn invoke-dd\n  \"Hook for invoke-dd macro - transforms (invoke-dd f v) to (f v).\"\n  [{:keys [node]}]\n  (let [[_ f v] (:children node)\n        new-node (api/list-node (list f v))]\n    {:node (with-meta new-node (meta node))}))\n\n(defn defprim-wrappers\n  \"Hook for defprim-wrappers macro.\n  Transforms specs into defn forms for linting.\"\n  [{:keys [node]}]\n  (let [[_ prim-type arg-count & specs] (:children node)\n        type-sym   (api/sexpr prim-type)\n        prefix     (case type-sym double \"d\" long \"l\" \"\")\n        arity      (api/sexpr arg-count)\n        arg-vec    (if (= arity 2)\n                     (api/vector-node [(api/token-node 'a) (api/token-node 'b)])\n                     (api/vector-node [(api/token-node 'v)]))\n        defns      (for [spec specs]\n                     (let [[suffix docstring wrapped-fn] (:children spec)\n                           fn-name (symbol (str prefix (api/sexpr suffix)))]\n                       (api/list-node\n                        (list\n                         (api/token-node 'defn)\n                         (api/token-node fn-name)\n                         docstring\n                         arg-vec\n                         (if (= arity 2)\n                           (api/list-node\n                            (list wrapped-fn\n                                  (api/token-node 'a)\n                                  (api/token-node 'b)))\n                           (api/list-node\n                            (list wrapped-fn\n                                  (api/token-node 'v))))))))]\n    {:node (with-meta\n             (api/list-node (cons (api/token-node 'do) defns))\n             (meta node))}))\n\n(defn defpred-wrappers\n  \"Hook for defpred-wrappers macro.\n  Transforms specs into defn forms for linting.\"\n  [{:keys [node]}]\n  (let [[_ prim-type & specs] (:children node)\n        type-sym (api/sexpr prim-type)\n        prefix   (case type-sym double \"d\" long \"l\" \"\")\n        arg-vec  (api/vector-node [(api/token-node 'v)])\n        defns    (for [spec specs]\n                   (let [[suffix docstring wrapped-fn] (:children spec)\n                         fn-name (symbol (str prefix (api/sexpr suffix)))]\n                     (api/list-node\n                      (list\n                       (api/token-node 'defn)\n                       (api/token-node fn-name)\n                       docstring\n                       arg-vec\n                       (api/list-node\n                        (list wrapped-fn (api/token-node 'v)))))))]\n    {:node (with-meta\n             (api/list-node (cons (api/token-node 'do) defns))\n             (meta node))}))\n\n(defn definterface+\n  \"Hook for definterface+ macro.\n  Transforms (definterface+ IName [IExtends...] sigs...)\n  into (definterface IName sigs...) for linting purposes.\"\n  [{:keys [node]}]\n  (let [[_ name-node & forms] (:children node)\n        ;; If first form is a vector, it's the extends list (skip it)\n        sigs (if (and (seq forms)\n                      (= :vector (:tag (first forms))))\n               (rest forms)\n               forms)\n        new-node (api/list-node\n                  (concat\n                   (list (api/token-node 'definterface) name-node)\n                   sigs))]\n    ;; un-comment below to debug changes\n    ;; (prn :definterface+ :original (api/sexpr node))\n    ;; (prn :definterface+ :transformed (api/sexpr new-node))\n    {:node (with-meta new-node (meta node))}))\n",
        "README.md": "# Criterium\n\n\n## Alpha version\n\nMaster is now on 0.5.x, which should be considered ALPHA, subject to\nbreaking changes on new features.\n\nSee [ALPHA Readme](README.ALPHA.md)\n\nIf you try it, please give feedback on any breaking changes with 0.4.6.\n\n\n## Stable version 0.4.6\n\nCriterium measures the computation time of an expression.  It is\ndesigned to address some of the pitfalls of benchmarking, and benchmarking on\nthe JVM in particular.\n\nThis includes:\n\n  * statistical processing of multiple evaluations\n  * inclusion of a warm-up period, designed to allow the JIT compiler to\n    optimise its code\n  * purging of gc before testing, to isolate timings from GC state prior\n    to testing\n  * a final forced GC after testing to estimate impact of cleanup on the\n    timing results\n\n## Installation\n\n### Leiningen\n\nAdd the following to your `:dependencies`:\n\n```clj\n[criterium \"0.4.6\"]\n```\n\n### Maven\n\n```xml\n<dependency>\n  <groupId>criterium</groupId>\n  <artifactId>criterium</artifactId>\n  <version>0.4.6</version>\n</dependency>\n```\n\n## Usage\n\nThe top level interface is in `criterium.core`.\n\n    (use 'criterium.core)\n\nUse `bench` to run a benchmark in a simple manner.\n\n```\n(bench (Thread/sleep 1000))\n =>\n                   Execution time mean : 1.000803 sec\n          Execution time std-deviation : 328.501853 us\n         Execution time lower quantile : 1.000068 sec ( 2.5%)\n         Execution time upper quantile : 1.001186 sec (97.5%)\n```\n\nBy default bench is quiet about its progress.  Run `with-progress-reporting` to\nget progress information on `*out*`.\n\n```clj\n(with-progress-reporting (bench (Thread/sleep 1000) :verbose))\n(with-progress-reporting (quick-bench (Thread/sleep 1000) :verbose))\n```\n\nLower level functions are available, that separate benchmark statistic\ngeneration and reporting.\n\n```clj\n(report-result (benchmark (Thread/sleep 1000) {:verbose true}))\n(report-result (quick-benchmark (Thread/sleep 1000)))\n```\n\nNote that results are returned to the user to prevent JIT from recognising that\nthe results are not used.\n\n## Measurement Overhead Estimation\n\nCriterium will automatically estimate a time for its measurement\noverhead.  The estimate is normally made once per session, and is\navailable in the `criterium.core/estimated-overhead-cache` var.\n\nIf the estimation is made while there is a lot of other processing\ngoing on, then benchmarking quick functions may report small negative\ntimes.  You can force a recalculation of the overhead by calling\n`criterium.core/estimated-overhead!`.\n\nIf you want consistency across JVM processes, it might be prudent to\nexplicitly set `criterium.core/estimated-overhead!` to a constant\nvalue.\n\n## References\n\n[API Documentation](http://hugoduncan.github.io/criterium/0.4/api/)\n[Annotated Source](http://hugoduncan.github.io/criterium/0.4/uberdoc.html)\n\nSee [Elliptic Group](http://www.ellipticgroup.com/html/benchmarkingArticle.html)\nfor a Java benchmarking library.  The accompanying article describes many of the\nJVM benchmarking pitfalls.\n\nSee [Criterion](http://hackage.haskell.org/package/criterion) for a Haskell\nbenchmarking library that applies many of the same statistical techniques.\n\n## Todo\n\nSerial correlation detection.\nMultimodal distribution detection.\nUse kernel density estimators?\n\n## Non-Goals\n\nExpressions are evaluated inside a function call.  We deliberately do\nnot seek ultimate accuracy for very quick expressions where the\nfunction overhead may be significant.\n\n## Releasing\n\nTo release, run the `release.sh` script.  This requires that you have\ngit-flow enabled your git repository with `git flow init`, and that\nyou have configured your\n[credentials for clojars](https://github.com/technomancy/leiningen/blob/stable/doc/DEPLOY.md).\n\n## YourKit\n\nYourKit is kindly supporting open source projects with its full-featured Java\nProfiler.\n\nYourKit, LLC is the creator of innovative and intelligent tools for profiling\nJava and .NET applications. Take a look at YourKit's leading software products:\n\n* <a href=\"http://www.yourkit.com/java/profiler/index.jsp\">YourKit Java Profiler</a> and\n* <a href=\"http://www.yourkit.com/.net/profiler/index.jsp\">YourKit .NET Profiler</a>.\n\n## License\n\nLicensed under [EPL](http://www.eclipse.org/legal/epl-v10.html)\n",
        "bases/criterium/validation/README.md": "# Validation Tests\n\nThis directory contains validation tests that compare criterium's statistics\nimplementations against GNU R as a reference. These tests ensure numerical\naccuracy of the library's statistical algorithms.\n\n## Prerequisites\n\nValidation tests require R and the Rserve package. Tests skip gracefully when\nR is unavailable, so this setup is optional for development.\n\n### Installing R\n\n**macOS** (via Homebrew):\n```bash\nbrew install r\n```\n\n**Ubuntu/Debian**:\n```bash\nsudo apt-get install r-base\n```\n\n**Windows**: Download from https://cran.r-project.org/bin/windows/base/\n\n### Installing Rserve\n\nStart R and install the Rserve package:\n\n```r\ninstall.packages(\"Rserve\", repos = \"http://rforge.net\")\n```\n\n### Installing Required R Packages\n\nSome validation tests require additional R packages:\n\n```r\n# For silverman-test and ACR test validation\ninstall.packages(\"multimode\")\n```\n\n### Starting Rserve\n\nBefore running validation tests, start Rserve:\n\n```r\nlibrary(Rserve)\nRserve()\n```\n\nOr from the command line:\n\n```bash\nR -e \"library(Rserve); Rserve()\"\n```\n\nRserve runs as a background process on port 6311 by default.\n\n## Running Validation Tests\n\nFrom the project root:\n\n```bash\nclojure -M:validation\n```\n\nThis runs all validation tests in `bases/criterium/validation/`. Tests\nautomatically skip when R/Rserve is unavailable.\n\n## Test Coverage\n\nThe validation tests compare the following criterium functions against R:\n\n| Criterium Function | R Reference |\n|--------------------|-------------|\n| `criterium.stats.core/mean` | `mean()` |\n| `criterium.stats.core/variance` | `var()` |\n| `criterium.stats.core/median` | `median()` |\n| `criterium.stats.core/quantile` | `quantile(..., type=7)` |\n| `criterium.stats.core/linear-regression` | `lm()` |\n| `criterium.stats.bootstrap/bootstrap-estimate` | `boot::boot()` |\n| `criterium.stats.bootstrap/bca-ci` | `boot::boot.ci(..., type=\"bca\")` |\n| `criterium.stats.bootstrap/jackknife` | manual jackknife |\n| `criterium.stats.kde/silverman-bandwidth` | `bw.nrd0()` |\n| `criterium.stats.kde/gaussian-kde` | `density(..., kernel=\"gaussian\")` |\n| `criterium.stats.kde/silverman-test` | `multimode::modetest(..., method=\"SI\")` |\n| `criterium.stats.kde/acr-test` | `multimode::modetest(..., method=\"ACR\")` |\n| `criterium.stats.probability/normal-quantile` | `qnorm()` |\n| `criterium.stats.probability/normal-cdf` | `pnorm()` |\n\n## Tolerance Levels\n\n- Basic statistics (mean, variance, median, quantile): < 1e-10 relative error\n- Iterative algorithms (KDE, CDF): < 1e-6 relative error\n- Bootstrap-based tests: statistical comparison rather than exact matching\n\n## Troubleshooting\n\n**\"R/Rserve not available\"**: Ensure Rserve is running. Start it with\n`R -e \"library(Rserve); Rserve()\"`.\n\n**\"Failed to load clojisr\"**: The clojisr dependency may not be on the\nclasspath. Use the `:validation` alias: `clojure -M:validation`.\n\n**\"could not find function 'modetest'\"**: Install the multimode R package:\n`install.packages(\"multimode\")` in R.\n",
        "dev/README.md": "# dev project\n\nThis is a project that contains all source and tests, and can be used\nwhen developing criterium.\n",
        "projects/agent/README.md": "# Criterium Agent\n\nThe Criterium agent is a native JVM agent that provides enhanced allocation tracking capabilities for more accurate benchmarking.\n\n## Usage\n\nStarting with version 0.5.x, the agent is **bundled in the JAR** with pre-compiled binaries for supported platforms.\n\n### Loading the Agent\n\n**IMPORTANT**: Due to JVMTI limitations, the agent **must be loaded at JVM startup** using `-agentpath` for allocation tracking to work. Programmatic loading via `load-agent!` will fail because the required `can_generate_sampled_object_alloc_events` capability can only be requested during VM initialization.\n\n#### Recommended: JVM Startup Loading\n\n```bash\n# Start REPL with agent\nclojure -J-agentpath:/path/to/libcriterium.dylib -M:dev\n\n# Or use agent/jvm-opts to get the path\nclojure -Sdeps '{:deps {criterium/criterium {:mvn/version \"0.5.x\"}}}' \\\n  -e '(require '\"'\"'[criterium.agent :as agent]) (println (first (agent/jvm-opts)))'\n# Then restart with that path\n```\n\n#### Alternative: Let Criterium Configure JVM Options\n\nFor development, you can let Criterium handle the agent path:\n\n```clojure\n(require '[criterium.agent :as agent])\n\n;; Get JVM arguments for restarting with agent\n(agent/jvm-opts)\n;; => [\"-agentpath:/tmp/criterium-agent-macos-x64-abc123.dylib\"]\n\n;; Check if agent is loaded\n(agent/loaded?)\n;; => true (if started with -agentpath) or false\n```\n\n**Note**: Programmatic loading via `load-agent!` is not supported for allocation tracking. The agent must be loaded at JVM startup.\n\n### Spawning Subprocesses\n\nIf you need to spawn a subprocess with the agent enabled, use `jvm-opts`:\n\n```clojure\n(require '[criterium.agent :as agent])\n\n;; Get JVM arguments for subprocess\n(agent/jvm-opts)\n;; => [\"-agentpath:/tmp/criterium-agent-linux-x64-abc123.so\"] or []\n\n;; Example: spawning a Clojure subprocess\n(require '[clojure.java.shell :as shell])\n(let [opts (agent/jvm-opts)]\n  (apply shell/sh \"clojure\" (concat opts [\"-e\" \"(+ 1 2)\"])))\n```\n\nReturns an empty vector `[]` if the agent is unavailable or the platform is unsupported.\n\n## Platform Support\n\n### Supported Platforms\n\nThe following platforms include bundled agent binaries:\n\n- **linux-x64** - Linux on x86-64 (Intel/AMD 64-bit)\n- **macos-x64** - macOS on x86-64 (Intel Mac)\n- **macos-arm64** - macOS on ARM64 (Apple Silicon M1/M2/M3)\n\n### Future Platform Support\n\nAdditional platforms may be added in future releases:\n\n- **linux-aarch64** - Linux on ARM64\n\nPlatform support depends on CI infrastructure availability for building native binaries.\n\n## Graceful Degradation\n\nWhen the agent is unavailable (unsupported platform or missing binary), Criterium continues to work but with reduced capabilities:\n\n- Basic timing measurements continue to work normally\n- Allocation tracking returns empty results\n- A warning is logged on first attempt to use agent features\n- `(agent/loaded?)` returns `false`\n- `(agent/jvm-opts)` returns `[]`\n\n**Example behavior on unsupported platforms:**\n\n```clojure\n;; On unsupported platform\n(agent/loaded?)\n;; => false\n\n(agent/agent-path)\n;; => nil\n\n;; Benchmarks still work, but without allocation tracking\n(bench/bench (reduce + (range 1000)))\n;; => Results show timing but no allocation data\n```\n\nThis ensures your benchmarking code remains portable across all platforms.\n\n## Manual Agent Path (Advanced)\n\nFor custom builds or development, you can still use the traditional `-agentpath` JVM argument:\n\n```bash\n# Start REPL with custom-built agent\nclojure -J-agentpath:/path/to/custom/libcriterium.so -M:dev\n```\n\nThe agent APIs (`loaded?`, `attached?`) recognize both bundled and manually-loaded agents.\n\n## Development Workflow\n\n### Building the Agent Locally\n\nFor active development of the native agent:\n\n```bash\n# From the agent-cpp/ directory\nmake\n\n# Build with debug symbols\nmake DEBUG=1\n```\n\nThis produces `agent-cpp/libcriterium.dylib` (macOS) or `agent-cpp/libcriterium.so` (Linux).\n\n### Using Local Builds\n\nDevelopment aliases are provided to use locally-built agents:\n\n```bash\n# macOS\nclojure -M:dev:with-agent-mac\n\n# Linux  \nclojure -M:dev:with-agent-linux\n\n# Run tests with local agent\nclojure -M:kaocha:dev:test:with-agent-mac --reporter dots\n```\n\nThese aliases configure `-agentpath` to point to your local build, bypassing the bundled binary.\n\n## Contributor Guide\n\n### Updating Bundled Binaries\n\nWhen making changes to the native agent that should be released:\n\n1. **Wait for CI to build** - The GitHub Actions workflow builds binaries for all supported platforms\n2. **Download artifacts** - See [docs/contributor/building-agent.md](../../docs/contributor/building-agent.md) for detailed instructions\n3. **Place in resources** - Copy to `projects/agent/resources/native/{platform}/`\n4. **Update SHA256 hashes** - Generate `.sha256` files for version tracking\n5. **Commit and release** - Include binaries in the release commit\n\nFull process documentation: [Building the Agent](../../docs/contributor/building-agent.md)\n\n### Testing\n\n```bash\n# Run all tests\nclojure -M:kaocha:dev:test --reporter dots\n\n# Run integration tests (requires agent binary)\nclojure -M:kaocha:dev:test --focus :requires-agent\n```\n\nTests gracefully skip when agent binaries are unavailable.\n\n## Technical Details\n\n### Resource Layout\n\nAgent binaries are stored in the JAR at:\n\n```\nresources/native/linux-x64/libcriterium.so\nresources/native/macos-x64/libcriterium.dylib\nresources/native/macos-arm64/libcriterium.dylib\n```\n\nSHA256 hash files track binary versions:\n\n```\nresources/native/linux-x64/libcriterium.so.sha256\nresources/native/macos-x64/libcriterium.dylib.sha256\nresources/native/macos-arm64/libcriterium.dylib.sha256\n```\n\n### Extraction Strategy\n\nOn first use, the agent:\n\n1. Detects the current platform (OS + architecture)\n2. Locates the matching binary in JAR resources\n3. Extracts to temp directory with versioned filename: `criterium-agent-{platform}-{hash}.{ext}`\n4. Uses file locking to prevent concurrent extraction races\n5. Registers shutdown hook for cleanup\n\nExtracted agents are reused across JVM restarts if the hash matches.\n\n### API Reference\n\n**`criterium.agent` namespace:**\n\n- `(loaded?)` - Returns true if agent is currently loaded via `-agentpath` JVM argument\n- `(agent-path)` - Returns absolute path to extracted agent binary, or nil if unavailable\n- `(jvm-opts)` - Returns vector of JVM arguments for spawning subprocesses with agent (e.g., `[\"-agentpath:/tmp/...\"]`), or empty vector if unavailable\n\n**Deprecated:**\n\n- `(load-agent!)` - Programmatic loading does not work for allocation tracking due to JVMTI limitations. The `can_generate_sampled_object_alloc_events` capability must be requested at VM startup. Use `-agentpath` at JVM startup instead.\n\n**Low-level API (`criterium.agent.core`):**\n\n- `(attached?)` - Checks if agent was loaded via `-agentpath` JVM argument\n- `(pid)` - Returns current JVM process ID\n\n## References\n\n- [Building the Agent](../../docs/contributor/building-agent.md) - Contributor guide for building and updating binaries\n- [Root CLAUDE.md](../../.claude/CLAUDE.md) - Development commands and testing workflows\n- [jattach](https://github.com/apangin/jattach) - Alternative tool for attaching agents to running JVMs\n",
        "skills/criterium/SKILL.md": "---\nname: criterium\ndescription: Use this skill when users ask about benchmarking Clojure code, measuring performance, profiling execution time, or using the criterium library. Covers the 0.5.x API including bench macro, bench plans, viewers, domain analysis, and argument generation.\n---\n\n# Criterium\n\nStatistically rigorous benchmarking for Clojure that accounts for JVM warmup, garbage collection, and measurement overhead.\n\n## Overview\n\nCriterium is the standard benchmarking library for Clojure. Unlike naive timing approaches, it provides:\n\n- **JVM-aware measurement** - Handles JIT warmup and GC interference\n- **Statistical rigor** - Bootstrap confidence intervals, outlier detection\n- **Multiple output formats** - Text, structured data, interactive charts\n\n**Library:** `criterium/criterium`\n**Current Version:** 0.5.x (alpha)\n**License:** EPL-1.0\n\n**Note:** The 0.4.x API (`criterium.core/bench`) is deprecated. Use `criterium.bench/bench` for all new code.\n\n## Quick Start\n\n```clojure\n(require '[criterium.bench :as bench])\n\n(bench/bench (+ 1 1))\n```\n\nOutput:\n```\n      Elapsed Time: 2.15 ns  3σ [2.08 2.22]  min 2.07\nOutliers (outliers / samples): low-severe 0 (0.0%), low-mild 0 (0.0%), high-mild 3 (1.5%), high-severe 0 (0.0%)\nSample Scheme: 200 samples with batch-size 4651 (930200 evaluations)\n```\n\nThe output shows:\n- **Mean time** (2.15 ns) with 3-sigma confidence bounds\n- **Outlier counts** by category (low/high, mild/severe)\n- **Sample scheme** - how measurements were collected\n\n## Core Concepts\n\nCriterium uses a three-stage pipeline:\n\n```\nCollection → Analysis → View\n```\n\n1. **Collection** - Gather raw timing samples using collectors\n2. **Analysis** - Apply statistical computations (mean, bootstrap CI, outliers)\n3. **View** - Format and present results through viewers\n\n### The Measured Abstraction\n\nThe `bench` macro wraps your expression in a `measured` - a benchmarkable unit that:\n- Prevents constant folding by hoisting arguments\n- Supports batched evaluation for fast expressions\n- Provides zero-allocation measurement\n\nYou rarely interact with `measured` directly, but it enables advanced patterns like argument generation. See [Argument Generation](#argument-generation) for explicit usage with test.check generators.\n\n## Basic Benchmarking\n\n### The bench Macro\n\n```clojure\n(bench/bench expr & options)\n```\n\nReturns the expression's value. Benchmark data available via `(bench/last-bench)`.\n\n### Common Options\n\n```clojure\n;; Change output format\n(bench/bench (sort data) :viewer :pprint)\n\n;; Use a specific bench plan\n(bench/bench (sort data) :bench-plan criterium.bench-plans/distribution-analysis)\n\n;; Limit benchmark duration\n(bench/bench (sort data) :limit-time-s 5)\n\n;; Collect allocation data (requires native agent)\n(bench/bench (sort data) :with-allocation-trace true)\n```\n\n### Using Local Bindings\n\nThe `bench` macro captures local bindings from the enclosing scope:\n\n```clojure\n(let [data (vec (range 1000))]\n  (bench/bench (reduce + data)))\n```\n\n### Reading Output\n\nDefault output fields:\n\n| Field | Meaning |\n|-------|---------|\n| Elapsed Time | Mean with 3σ bounds and minimum |\n| Outliers | Count by category (low/high, mild/severe) |\n| Sample Scheme | Samples × batch-size = total evaluations |\n\n### Accessing Results Programmatically\n\n```clojure\n(bench/bench (reduce + (range 100)))\n\n;; Get full results\n(bench/last-bench)\n\n;; Extract specific values\n(require '[criterium.util.helpers :as util])\n(util/stats-value (:data (bench/last-bench)) :stats :elapsed-time :mean)\n```\n\n## Bench Plans\n\nBench plans configure what analysis and output criterium produces. The default plan handles most cases.\n\n### default\n\nUsed automatically. Provides:\n- JIT warmup phase\n- Bootstrap confidence intervals\n- Outlier detection\n- KDE density estimation (for multimodal warnings)\n\n### histogram\n\nNon-parametric distribution analysis with histogram visualization:\n\n```clojure\n(require '[criterium.bench-plans :as plans])\n\n(bench/bench (my-function)\n             :bench-plan plans/histogram)\n```\n\nIncludes:\n- Histogram with Knuth optimal binning\n- KDE density estimation\n- Mode detection for multimodal distributions\n\n### distribution-analysis\n\nParametric distribution fitting for understanding timing variability:\n\n```clojure\n(bench/bench (my-function)\n             :bench-plan plans/distribution-analysis)\n```\n\nAdds:\n- Distribution fitting (gamma, log-normal, Weibull)\n- Shape statistics (skewness, kurtosis)\n- Goodness-of-fit tests\n- Q-Q plots (with appropriate viewer)\n\n### Custom Plans\n\nPlans are maps with `:analyse` and `:view` vectors:\n\n```clojure\n{:collector-config {...}\n :analyse [:transform-log :outliers [:stats {}] :bootstrap-stats]\n :view [:stats :bootstrap-stats :outlier-counts]}\n```\n\n## Viewers\n\nViewers control output format. Set per-call or globally.\n\n### :print (Default)\n\nHuman-readable text to stdout:\n\n```clojure\n(bench/bench (+ 1 1))  ; uses :print\n```\n\n### :pprint\n\nStructured Clojure data, useful for programmatic access:\n\n```clojure\n(bench/bench (+ 1 1) :viewer :pprint)\n```\n\n### :portal\n\nInteractive charts and tables in Portal:\n\n```clojure\n;; Setup: connect Portal to tap>\n(require '[portal.api :as p])\n(def portal (p/open))\n(add-tap #'p/submit)\n\n;; Use portal viewer\n(bench/bench (+ 1 1) :viewer :portal)\n```\n\nProvides interactive histograms, KDE plots, and tabular data.\n\n### :kindly\n\nFor Clay/Clerk notebooks with Vega-Lite charts:\n\n```clojure\n(bench/set-default-viewer! :kindly)\n(bench/bench (+ 1 1))\n```\n\nOutputs Kindly-annotated data structures rendered as tables and charts.\n\n### Setting Default Viewer\n\n```clojure\n;; Set for all subsequent bench calls\n(bench/set-default-viewer! :kindly)\n\n;; Check current default\n(bench/default-viewer)\n```\n\n## Domain Analysis\n\nDomain analysis benchmarks across a parameter space rather than at a single point. Use it for:\n- Comparing implementations at multiple input sizes\n- Analyzing algorithmic complexity (O(n), O(n log n), etc.)\n- Understanding scaling behavior\n\n### Basic Usage\n\n```clojure\n(require '[criterium.domain :as domain]\n         '[criterium.domain.builder :as builder]\n         '[criterium.domain-plans :as domain-plans])\n\n;; Benchmark sorting across input sizes\n(domain/bench\n (domain/domain-expr\n  [n (builder/log-range 10 1000 5)]\n  (sort (vec (range n)))))\n```\n\nThe `domain-expr` macro defines axes (parameter ranges) and expressions to benchmark. The `bench` function runs benchmarks at each coordinate and analyzes results.\n\n### Comparing Implementations\n\nUse a map body in `domain-expr` to compare implementations:\n\n```clojure\n(domain/bench\n (domain/domain-expr\n  [n (builder/log-range 100 10000 5)]\n  {:sort    (sort (vec (range n)))\n   :sort-by (sort-by identity (vec (range n)))})\n :domain-plan domain-plans/implementation-comparison)\n```\n\nOutput shows the baseline (first implementation) in absolute values and others as relative factors.\n\n### Complexity Analysis\n\nFit O(log n), O(n), O(n log n), O(n²) models:\n\n```clojure\n(domain/bench\n (domain/domain-expr\n  [n (builder/n-log-n-range 10 10000 7)]\n  (sort (vec (range n))))\n :domain-plan domain-plans/complexity-analysis)\n```\n\nUse `n-log-n-range` for better sampling when expecting O(n log n) complexity.\n\n### Range Generators\n\n| Function | Use Case |\n|----------|----------|\n| `log-range` | Wide range coverage (10 to 10000) |\n| `linear-range` | Uniform sampling |\n| `n-log-n-range` | O(n log n) algorithms |\n| `powers-of-2` | Binary scaling patterns |\n\n### Domain Plans\n\n| Plan | Purpose |\n|------|---------|\n| `extract-metrics` | Default - shows all metrics |\n| `implementation-comparison` | Compare implementations with factors |\n| `complexity-analysis` | Fit complexity models |\n\n### Options\n\n```clojure\n(domain/bench\n (domain/domain-expr ...)\n :domain-plan domain-plans/complexity-analysis\n :reporter nil                        ; Silent (no progress dots)\n :bench-options {:limit-time-s 2})    ; Per-benchmark time limit\n```\n\n## Argument Generation\n\nGenerate diverse inputs for each benchmark iteration using test.check generators.\n\n**Dependency:** `criterium/arg-gen` (separate artifact)\n\n```clojure\n;; deps.edn\n{:deps {criterium/arg-gen {:mvn/version \"0.5.x\"}}}\n```\n\n### The measured Macro\n\n```clojure\n(require '[criterium.arg-gen :as arg-gen]\n         '[clojure.test.check.generators :as gen])\n\n;; Basic usage - each iteration gets fresh generated values\n(bench/bench-measured\n (bench/options->bench-plan)\n (arg-gen/measured\n  [n gen/small-integer]\n  (* n n)))\n```\n\n### Multiple Bindings\n\nBindings are processed left-to-right, with earlier bindings available to later generators. This enables dependent generation where one value determines another:\n\n```clojure\n(arg-gen/measured\n [n (gen/choose 10 100)                    ; n bound first\n  coll (gen/vector gen/small-integer n)]   ; n used to size the vector\n (reduce + coll))\n```\n\n### Options\n\n```clojure\n;; Control generator size (affects sized generators like gen/vector)\n(arg-gen/measured {:size 50}\n [coll (gen/vector gen/small-integer)]\n (sort coll))\n\n;; Reproducible generation with seed\n(arg-gen/measured {:seed 12345}\n [n gen/small-integer]\n (* n n))\n```\n\n### Common Patterns\n\n```clojure\n;; String processing\n(arg-gen/measured\n [s gen/string-alphanumeric]\n (clojure.string/upper-case s))\n\n;; Collection operations\n(arg-gen/measured {:size 100}\n [v (gen/vector gen/small-integer)]\n (sort v))\n\n;; Map operations\n(arg-gen/measured {:size 20}\n [m (gen/map gen/keyword gen/small-integer)]\n (vals m))\n```\n\n## Best Practices\n\n### JVM Warmup\n\nThe JIT compiler optimizes code during execution. Criterium handles warmup automatically, but be aware:\n\n- First benchmark in a session may be slower (class loading, JIT)\n- Run benchmarks multiple times if results seem inconsistent\n- The `default` plan includes warmup phases\n\n### Avoiding Measurement Pitfalls\n\n**Dead code elimination:** The JVM may optimize away computations with unused results. Criterium prevents this by consuming return values, but avoid:\n\n```clojure\n;; BAD - side-effect only, result discarded\n(bench/bench (do (sort data) nil))\n\n;; GOOD - return the result\n(bench/bench (sort data))\n```\n\n**Side effects:** Benchmarks with side effects (I/O, mutation) may not measure what you intend:\n\n```clojure\n;; BAD - file I/O dominates timing\n(bench/bench (spit \"test.txt\" (str data)))\n\n;; GOOD - separate I/O from computation\n(bench/bench (str data))\n```\n\n**Constant folding:** The compiler may evaluate constant expressions at compile time:\n\n```clojure\n;; BAD - may be optimized to constant\n(bench/bench (+ 1 2))\n\n;; BETTER - use local bindings\n(let [a 1 b 2]\n  (bench/bench (+ a b)))\n```\n\n### Interpreting Results\n\n**Outliers:** Some outliers are normal (GC, OS scheduling). Concern when:\n- High-severe outliers exceed 5% of samples\n- Results vary significantly between runs\n- Minimum time much lower than mean\n\n**Confidence intervals:** The 3σ bounds show where 99.7% of values fall. Wide bounds suggest high variance—consider longer benchmarks or investigating causes.\n\n### Choosing Bench Plans\n\n| Situation | Plan |\n|-----------|------|\n| Quick measurement | `default` |\n| Understanding distribution shape | `distribution-analysis` |\n| Comparing implementations | `implementation-comparison` (domain) |\n| Analyzing complexity | `complexity-analysis` (domain) |\n\n## Quick Reference\n\n### Single Expression\n\n```clojure\n(require '[criterium.bench :as bench])\n\n(bench/bench (my-function arg1 arg2))\n(bench/bench (my-function arg1 arg2) :viewer :pprint)\n(bench/last-bench)  ; Access results\n```\n\n### With Local Bindings\n\n```clojure\n(let [data (vec (range 1000))]\n  (bench/bench (reduce + data)))\n```\n\n### Compare Implementations\n\n```clojure\n(require '[criterium.domain :as domain]\n         '[criterium.domain.builder :as builder]\n         '[criterium.domain-plans :as domain-plans])\n\n(domain/bench\n (domain/domain-expr\n  [n (builder/log-range 100 10000 5)]\n  {:impl-a (sort (vec (range n)))\n   :impl-b (sort-by identity (vec (range n)))})\n :domain-plan domain-plans/implementation-comparison)\n```\n\n### Complexity Analysis\n\n```clojure\n(domain/bench\n (domain/domain-expr\n  [n (builder/log-range 10 10000 7)]\n  (my-algorithm n))\n :domain-plan domain-plans/complexity-analysis)\n```\n\n### Generated Arguments\n\n```clojure\n(require '[criterium.arg-gen :as arg-gen]\n         '[clojure.test.check.generators :as gen])\n\n(bench/bench-measured\n (bench/options->bench-plan)\n (arg-gen/measured {:size 100}\n  [coll (gen/vector gen/small-integer)]\n  (sort coll)))\n```\n\n"
      },
      "plugins": [
        {
          "name": "criterium",
          "source": "./",
          "description": "Benchmarking library for Clojure",
          "version": "0.5.0",
          "license": "EPL-1.0",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add hugoduncan/criterium",
            "/plugin install criterium@criterium"
          ]
        }
      ]
    }
  ]
}