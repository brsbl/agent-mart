{
  "author": {
    "id": "SSiertsema",
    "display_name": "sven-siertsema",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/9604824?v=4",
    "url": "https://github.com/SSiertsema",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 14,
      "total_commands": 12,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "svens-claude-plugins",
      "version": null,
      "description": "Collection of plugins for Claude Code",
      "owner_info": {
        "name": "Sven Siertsema"
      },
      "keywords": [],
      "repo_full_name": "SSiertsema/claude-code-plugins",
      "repo_url": "https://github.com/SSiertsema/claude-code-plugins",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-15T20:31:45Z",
        "created_at": "2025-11-29T16:44:48Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 3465
        },
        {
          "path": "agent-meeting-room",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-meeting-room/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-meeting-room/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 387
        },
        {
          "path": "agent-meeting-room/README.md",
          "type": "blob",
          "size": 2141
        },
        {
          "path": "agent-meeting-room/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-meeting-room/hooks/hooks.json",
          "type": "blob",
          "size": 1249
        },
        {
          "path": "agent-meeting-room/hooks/post-tool-use.sh",
          "type": "blob",
          "size": 1088
        },
        {
          "path": "agent-meeting-room/hooks/pre-compact.sh",
          "type": "blob",
          "size": 461
        },
        {
          "path": "agent-meeting-room/hooks/pre-tool-use.sh",
          "type": "blob",
          "size": 3295
        },
        {
          "path": "agent-meeting-room/hooks/session-end.sh",
          "type": "blob",
          "size": 524
        },
        {
          "path": "agent-meeting-room/hooks/session-start.sh",
          "type": "blob",
          "size": 953
        },
        {
          "path": "agent-meeting-room/hooks/stop.sh",
          "type": "blob",
          "size": 5405
        },
        {
          "path": "agent-meeting-room/hooks/subagent-stop.sh",
          "type": "blob",
          "size": 6548
        },
        {
          "path": "agent-meeting-room/hooks/user-prompt-required.sh",
          "type": "blob",
          "size": 1257
        },
        {
          "path": "agent-meeting-room/hooks/user-prompt-submit.sh",
          "type": "blob",
          "size": 3180
        },
        {
          "path": "documentation-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "documentation-generator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "documentation-generator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 409
        },
        {
          "path": "documentation-generator/README.md",
          "type": "blob",
          "size": 2492
        },
        {
          "path": "documentation-generator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "documentation-generator/commands/generate-docs.md",
          "type": "blob",
          "size": 4007
        },
        {
          "path": "functional-specifications",
          "type": "tree",
          "size": null
        },
        {
          "path": "functional-specifications/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "functional-specifications/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 491
        },
        {
          "path": "functional-specifications/README.md",
          "type": "blob",
          "size": 3993
        },
        {
          "path": "functional-specifications/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "functional-specifications/commands/generate-functional-specifications.md",
          "type": "blob",
          "size": 8675
        },
        {
          "path": "git-commit",
          "type": "tree",
          "size": null
        },
        {
          "path": "git-commit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "git-commit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 365
        },
        {
          "path": "git-commit/README.md",
          "type": "blob",
          "size": 1599
        },
        {
          "path": "git-commit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "git-commit/commands/commit.md",
          "type": "blob",
          "size": 2908
        },
        {
          "path": "js-refactor-logic",
          "type": "tree",
          "size": null
        },
        {
          "path": "js-refactor-logic/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "js-refactor-logic/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 402
        },
        {
          "path": "js-refactor-logic/README.md",
          "type": "blob",
          "size": 1542
        },
        {
          "path": "js-refactor-logic/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "js-refactor-logic/commands/refactor.md",
          "type": "blob",
          "size": 8420
        },
        {
          "path": "ncsc-security-audit",
          "type": "tree",
          "size": null
        },
        {
          "path": "ncsc-security-audit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ncsc-security-audit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 431
        },
        {
          "path": "ncsc-security-audit/README.md",
          "type": "blob",
          "size": 7162
        },
        {
          "path": "ncsc-security-audit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "ncsc-security-audit/commands/ncsc-security-audit.md",
          "type": "blob",
          "size": 7247
        },
        {
          "path": "owasp-security-audit",
          "type": "tree",
          "size": null
        },
        {
          "path": "owasp-security-audit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "owasp-security-audit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 401
        },
        {
          "path": "owasp-security-audit/README.md",
          "type": "blob",
          "size": 5095
        },
        {
          "path": "owasp-security-audit/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "owasp-security-audit/commands/owasp-security-audit.md",
          "type": "blob",
          "size": 12531
        },
        {
          "path": "persona-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "persona-generator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "persona-generator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 400
        },
        {
          "path": "persona-generator/README.md",
          "type": "blob",
          "size": 4534
        },
        {
          "path": "persona-generator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "persona-generator/commands/generate-personas.md",
          "type": "blob",
          "size": 11555
        },
        {
          "path": "technical-specifications",
          "type": "tree",
          "size": null
        },
        {
          "path": "technical-specifications/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "technical-specifications/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 421
        },
        {
          "path": "technical-specifications/README.md",
          "type": "blob",
          "size": 2274
        },
        {
          "path": "technical-specifications/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "technical-specifications/commands/refine-technical-specifications.md",
          "type": "blob",
          "size": 7086
        },
        {
          "path": "ts-refactor-logic",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-refactor-logic/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-refactor-logic/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 403
        },
        {
          "path": "ts-refactor-logic/README.md",
          "type": "blob",
          "size": 1868
        },
        {
          "path": "ts-refactor-logic/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "ts-refactor-logic/commands/refactor.md",
          "type": "blob",
          "size": 10285
        },
        {
          "path": "user-story-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "user-story-generator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "user-story-generator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 405
        },
        {
          "path": "user-story-generator/README.md",
          "type": "blob",
          "size": 3857
        },
        {
          "path": "user-story-generator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "user-story-generator/commands/generate-user-stories.md",
          "type": "blob",
          "size": 8905
        },
        {
          "path": "vue-development-skill",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 412
        },
        {
          "path": "vue-development-skill/README.md",
          "type": "blob",
          "size": 6915
        },
        {
          "path": "vue-development-skill/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/SKILL.md",
          "type": "blob",
          "size": 11461
        },
        {
          "path": "vue-development-skill/skills/vue-development/debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/debugging/common-issues.md",
          "type": "blob",
          "size": 8260
        },
        {
          "path": "vue-development-skill/skills/vue-development/e2e",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/e2e/acceptance-criteria.md",
          "type": "blob",
          "size": 7768
        },
        {
          "path": "vue-development-skill/skills/vue-development/e2e/playwright-patterns.md",
          "type": "blob",
          "size": 10169
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns/composition-api.md",
          "type": "blob",
          "size": 8424
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns/nuxt3.md",
          "type": "blob",
          "size": 8943
        },
        {
          "path": "vue-development-skill/skills/vue-development/patterns/typescript.md",
          "type": "blob",
          "size": 8435
        },
        {
          "path": "vue-development-skill/skills/vue-development/qa",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/qa/vue-checklist.md",
          "type": "blob",
          "size": 5356
        },
        {
          "path": "vue-development-skill/skills/vue-development/tdd",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-development-skill/skills/vue-development/tdd/testing-patterns.md",
          "type": "blob",
          "size": 8928
        },
        {
          "path": "vue-development-skill/skills/vue-development/tdd/workflow.md",
          "type": "blob",
          "size": 6586
        },
        {
          "path": "vue-refactor-logic",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-refactor-logic/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-refactor-logic/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 412
        },
        {
          "path": "vue-refactor-logic/README.md",
          "type": "blob",
          "size": 2536
        },
        {
          "path": "vue-refactor-logic/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-refactor-logic/commands/refactor.md",
          "type": "blob",
          "size": 11301
        },
        {
          "path": "vue-reorder",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-reorder/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-reorder/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 398
        },
        {
          "path": "vue-reorder/README.md",
          "type": "blob",
          "size": 2024
        },
        {
          "path": "vue-reorder/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "vue-reorder/commands/reorder.md",
          "type": "blob",
          "size": 6520
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"svens-claude-plugins\",\n  \"owner\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"metadata\": {\n    \"description\": \"Collection of plugins for Claude Code\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agent-meeting-room\",\n      \"source\": \"./agent-meeting-room\",\n      \"description\": \"Tracks Claude Code sessions and agent processes in the Agent Meeting Room system\",\n      \"category\": \"integration\"\n    },\n    {\n      \"name\": \"documentation-generator\",\n      \"source\": \"./documentation-generator\",\n      \"description\": \"Generate comprehensive project documentation through interactive dialog with templates\",\n      \"category\": \"productivity\"\n    },\n    {\n      \"name\": \"git-commit\",\n      \"source\": \"./git-commit\",\n      \"description\": \"Streamlined git commit and push with auto-generated commit messages\",\n      \"category\": \"productivity\"\n    },\n    {\n      \"name\": \"vue-reorder\",\n      \"source\": \"./vue-reorder\",\n      \"description\": \"Refactor Vue 3 SFCs for readability: reorder sections, organize script, improve naming\",\n      \"category\": \"vue\"\n    },\n    {\n      \"name\": \"js-refactor-logic\",\n      \"source\": \"./js-refactor-logic\",\n      \"description\": \"Refactor JavaScript logic: code splitting, design patterns, ES6+ modernization\",\n      \"category\": \"javascript\"\n    },\n    {\n      \"name\": \"ts-refactor-logic\",\n      \"source\": \"./ts-refactor-logic\",\n      \"description\": \"Refactor TypeScript logic: code splitting, type improvements, design patterns\",\n      \"category\": \"typescript\"\n    },\n    {\n      \"name\": \"vue-refactor-logic\",\n      \"source\": \"./vue-refactor-logic\",\n      \"description\": \"Refactor Vue 3 script logic: composables extraction, code splitting, Vue patterns\",\n      \"category\": \"vue\"\n    },\n    {\n      \"name\": \"vue-development-skill\",\n      \"source\": \"./vue-development-skill\",\n      \"description\": \"Vue 3/Nuxt 3 development skill with TDD workflow and QA-first approach. Produces JSON reports for agent handoff.\",\n      \"category\": \"vue\"\n    },\n    {\n      \"name\": \"owasp-security-audit\",\n      \"source\": \"./owasp-security-audit\",\n      \"description\": \"Multi-agent OWASP Top 10 security audit with technical and stakeholder reports\",\n      \"category\": \"security\"\n    },\n    {\n      \"name\": \"ncsc-security-audit\",\n      \"source\": \"./ncsc-security-audit\",\n      \"description\": \"Multi-agent NCSC ICT-beveiligingsrichtlijnen audit met technische en stakeholder rapporten\",\n      \"category\": \"security\"\n    },\n    {\n      \"name\": \"technical-specifications\",\n      \"source\": \"./technical-specifications\",\n      \"description\": \"Interactive agent for collecting and refining technical specifications through guided dialogue\",\n      \"category\": \"productivity\"\n    },\n    {\n      \"name\": \"user-story-generator\",\n      \"source\": \"./user-story-generator\",\n      \"description\": \"Generate INVEST-compliant user stories from functional specifications and personas with Gherkin acceptance criteria\",\n      \"category\": \"productivity\"\n    },\n    {\n      \"name\": \"persona-generator\",\n      \"source\": \"./persona-generator\",\n      \"description\": \"Create detailed user personas through interactive dialogue for user story development\",\n      \"category\": \"productivity\"\n    },\n    {\n      \"name\": \"functional-specifications\",\n      \"source\": \"./functional-specifications\",\n      \"description\": \"Generate functional specifications from business case and personas through interactive dialogue\",\n      \"category\": \"productivity\"\n    }\n  ]\n}\n",
        "agent-meeting-room/.claude-plugin/plugin.json": "{\n  \"name\": \"agent-meeting-room\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Tracks Claude Code sessions and agent processes in the Agent Meeting Room system\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"hooks\", \"tracking\", \"sessions\", \"agents\"],\n  \"hooks\": \"./hooks/hooks.json\"\n}\n",
        "agent-meeting-room/README.md": "# Agent Meeting Room Plugin\n\nA Claude Code plugin that tracks sessions and agent processes in the Agent Meeting Room system.\n\n## What it does\n\nThis plugin automatically tracks:\n\n- **Sessions** - When Claude Code starts and ends\n- **Processes** - Each user prompt creates a trackable process\n- **Subagents** - Task tool invocations are tracked as child processes\n- **Status changes** - Completion, interruption, and waiting-for-input states\n\nAll data is sent to the Agent Meeting Room backend at `agent-meeting-room.up.railway.app`.\n\n## Requirements\n\n- `curl` - For HTTP requests\n- `jq` - For JSON parsing\n- `uuidgen` or `/proc/sys/kernel/random/uuid` - For generating process IDs\n\n## Installation\n\n### Via Plugin Marketplace\n\n```bash\n# Add the marketplace\n/plugin marketplace add <github-user>/claude-code-plugins\n\n# Install the plugin\n/plugin install agent-meeting-room\n```\n\n### Manual Installation\n\n1. Clone or copy this plugin directory\n2. Run `/plugin install <path-to-plugin>`\n\n## Hooks\n\nThis plugin registers the following hooks:\n\n| Hook | Purpose |\n|------|---------|\n| `SessionStart` | Creates a session in the meeting room |\n| `SessionEnd` | Marks session as ended |\n| `UserPromptSubmit` | Creates a new process or resumes waiting process |\n| `PreToolUse` | Tracks Task tool invocations for subagent linking |\n| `PostToolUse` | Detects user interruptions |\n| `Stop` | Marks process as completed/interrupted/waiting |\n| `SubagentStop` | Links completed subagents to parent processes |\n| `PreCompact` | (Reserved for future use) |\n| `Notification` | Notifies when user input is required |\n\n## Environment Variables\n\n| Variable | Description |\n|----------|-------------|\n| `CLAUDE_HOOK_PROJECT_NAME` | Override the project name (defaults to CWD basename) |\n\n## Temporary Files\n\nThe hooks use `/tmp/` for state management:\n\n- `/tmp/claude-hooks.log` - Main log file\n- `/tmp/claude-hook-debug.log` - Debug logging\n- `/tmp/claude-current-process/` - Current process ID tracking\n- `/tmp/claude-agent-sessions/` - Task metadata mapping\n- `/tmp/claude-interrupted/` - Interrupt flags\n- `/tmp/claude-tool-executed/` - Tool execution tracking\n",
        "agent-meeting-room/hooks/hooks.json": "{\n  \"hooks\": {\n    \"UserPromptSubmit\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/user-prompt-submit.sh\"\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/pre-tool-use.sh\"\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/post-tool-use.sh\"\n      }\n    ],\n    \"Stop\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/stop.sh\"\n      }\n    ],\n    \"SubagentStop\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/subagent-stop.sh\"\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/pre-compact.sh\"\n      }\n    ],\n    \"SessionStart\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-start.sh\"\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-end.sh\"\n      }\n    ],\n    \"Notification\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/user-prompt-required.sh\"\n      }\n    ]\n  }\n}\n",
        "agent-meeting-room/hooks/post-tool-use.sh": "#!/bin/bash\n\necho \"Hook triggered: post-tool-use\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract hook data\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name')\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\nTOOL_RESPONSE=$(echo \"$INPUT\" | jq -r '.tool_response')\n\n# Get the current process ID for this session\nPROCESS_TRACKING_DIR=\"/tmp/claude-current-process\"\nCURRENT_PROCESS_ID=$(cat \"$PROCESS_TRACKING_DIR/$SESSION_ID\" 2>/dev/null)\n\n# Check if the tool was interrupted by the user\nif echo \"$TOOL_RESPONSE\" | grep -q \"\\[Request interrupted by user\"; then\n  # Mark this process as interrupted (use process ID, not session ID)\n  if [ -n \"$CURRENT_PROCESS_ID\" ]; then\n    INTERRUPT_DIR=\"/tmp/claude-interrupted\"\n    mkdir -p \"$INTERRUPT_DIR\"\n    echo \"interrupted\" > \"$INTERRUPT_DIR/$CURRENT_PROCESS_ID\"\n  fi\nfi\n\n# post-tool-use fires in the PARENT session context after a tool completes\n# For Task tools, the spawned agent is handled by subagent-stop hook\n# This hook could be used to track tool usage statistics or logging\n# For now, we don't need to send any webhooks here\n\nexit 0\n",
        "agent-meeting-room/hooks/pre-compact.sh": "#!/bin/bash\n\necho \"Hook triggered: pre-compact\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract hook data\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\n\n# The pre-compact hook fires before Claude Code compacts conversation history\n# This is an internal housekeeping operation\n# For agent session tracking, this event is not critical\n\n# Uncomment to log:\n# echo \"[$(date)] Pre-compact triggered - Session: $SESSION_ID\" >> /tmp/claude-hooks.log\n\nexit 0\n",
        "agent-meeting-room/hooks/pre-tool-use.sh": "#!/bin/bash\n\necho \"Hook triggered: pre-tool-use\"\n\n# Debug log file\nDEBUG_LOG=\"/tmp/claude-hook-debug.log\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract hook data\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name')\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\nTOOL_INPUT=$(echo \"$INPUT\" | jq -r '.tool_input')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd')\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\n\n# Log hook trigger\necho \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: Hook fired for tool '$TOOL_NAME' in session '$SESSION_ID'\" >> \"$DEBUG_LOG\"\n\n# Get the current process ID for this session\nPROCESS_TRACKING_DIR=\"/tmp/claude-current-process\"\nCURRENT_PROCESS_ID=$(cat \"$PROCESS_TRACKING_DIR/$SESSION_ID\" 2>/dev/null)\n\necho \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: Current process ID = '$CURRENT_PROCESS_ID'\" >> \"$DEBUG_LOG\"\n\n# Mark that at least one tool has been executed for this process\nTOOL_EXECUTION_DIR=\"/tmp/claude-tool-executed\"\nmkdir -p \"$TOOL_EXECUTION_DIR\"\necho \"1\" > \"$TOOL_EXECUTION_DIR/$CURRENT_PROCESS_ID\"\n\n# Only process Task tool invocations (agent spawning)\nif [ \"$TOOL_NAME\" = \"Task\" ]; then\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: Task tool detected! Processing agent spawn...\" >> \"$DEBUG_LOG\"\n\n  # Extract task details\n  DESCRIPTION=$(echo \"$TOOL_INPUT\" | jq -r '.description // \"Untitled Task\"')\n  PROMPT=$(echo \"$TOOL_INPUT\" | jq -r '.prompt // \"\"')\n\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: Task description = '$DESCRIPTION'\" >> \"$DEBUG_LOG\"\n\n  # Get project name from environment variable, fallback to CWD basename\n  PROJECT_NAME=\"${CLAUDE_HOOK_PROJECT_NAME:-}\"\n  if [ -z \"$PROJECT_NAME\" ] && [ -n \"$CWD\" ]; then\n    PROJECT_NAME=$(basename \"$CWD\")\n  fi\n\n  # Store parent process context for subagent-stop hook to use\n  # The subprocess will read this when it stops to link itself to the current process\n  MAPPING_DIR=\"/tmp/claude-agent-sessions\"\n  mkdir -p \"$MAPPING_DIR\"\n\n  # Use a timestamp-based key to handle multiple concurrent tasks\n  TASK_KEY=\"task-$(date +%s%N)\"\n\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: Creating metadata files with key '$TASK_KEY'\" >> \"$DEBUG_LOG\"\n\n  echo \"$CURRENT_PROCESS_ID\" > \"$MAPPING_DIR/${TASK_KEY}.parent\"\n  echo \"$SESSION_ID\" > \"$MAPPING_DIR/${TASK_KEY}.session\"\n  echo \"$DESCRIPTION\" > \"$MAPPING_DIR/${TASK_KEY}.description\"\n  echo \"$PROMPT\" > \"$MAPPING_DIR/${TASK_KEY}.prompt\"\n  echo \"$CWD\" > \"$MAPPING_DIR/${TASK_KEY}.cwd\"\n  echo \"$TRANSCRIPT_PATH\" > \"$MAPPING_DIR/${TASK_KEY}.transcript\"\n  echo \"$PROJECT_NAME\" > \"$MAPPING_DIR/${TASK_KEY}.project\"\n\n  # Verify files were created\n  if [ -f \"$MAPPING_DIR/${TASK_KEY}.parent\" ] && [ -f \"$MAPPING_DIR/${TASK_KEY}.session\" ]; then\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: SUCCESS - Metadata files created at '$MAPPING_DIR/${TASK_KEY}.*'\" >> \"$DEBUG_LOG\"\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: Files in directory: $(ls -1 $MAPPING_DIR | wc -l)\" >> \"$DEBUG_LOG\"\n  else\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: ERROR - Failed to create metadata files!\" >> \"$DEBUG_LOG\"\n  fi\nelse\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] PRE-TOOL-USE: Not a Task tool (tool='$TOOL_NAME'), skipping agent tracking\" >> \"$DEBUG_LOG\"\nfi\n\n# Exit 0 to allow the tool to proceed\nexit 0\n",
        "agent-meeting-room/hooks/session-end.sh": "#!/bin/bash\n\necho \"Hook triggered: session-end\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract hook data\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\nREASON=$(echo \"$INPUT\" | jq -r '.reason // \"unknown\"')\n\n# End the Claude Code session in the database\nTIMESTAMP=$(date +%s)\ncurl -X POST https://agent-meeting-room.up.railway.app/webhooks/session/end \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\n    \\\"session_id\\\": \\\"$SESSION_ID\\\",\n    \\\"timestamp\\\": $TIMESTAMP\n  }\" \\\n  --silent --output /dev/null\n\nexit 0\n",
        "agent-meeting-room/hooks/session-start.sh": "#!/bin/bash\n\necho \"Hook triggered: session-start\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract hook data\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\nSOURCE=$(echo \"$INPUT\" | jq -r '.source // \"unknown\"')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd // \"\"')\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path // \"\"')\n\n# Get project name from environment variable, fallback to CWD basename\nPROJECT_NAME=\"${CLAUDE_HOOK_PROJECT_NAME:-}\"\nif [ -z \"$PROJECT_NAME\" ] && [ -n \"$CWD\" ]; then\n  PROJECT_NAME=$(basename \"$CWD\")\nfi\n\n# Create the Claude Code session in the database\nTIMESTAMP=$(date +%s)\ncurl -X POST https://agent-meeting-room.up.railway.app/webhooks/session/start \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\n    \\\"session_id\\\": \\\"$SESSION_ID\\\",\n    \\\"timestamp\\\": $TIMESTAMP,\n    \\\"transcript_path\\\": \\\"$TRANSCRIPT_PATH\\\",\n    \\\"cwd\\\": \\\"$CWD\\\",\n    \\\"project_name\\\": \\\"$PROJECT_NAME\\\"\n  }\" \\\n  --silent --output /dev/null\n\nexit 0\n",
        "agent-meeting-room/hooks/stop.sh": "#!/bin/bash\n\necho \"Hook triggered: stop\"\n\n# Set up logging\nLOG_FILE=\"/tmp/claude-hooks.log\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Log that hook was triggered\necho \"[$(date '+%Y-%m-%d %H:%M:%S')] stop hook triggered\" >> \"$LOG_FILE\"\necho \"  Input: $INPUT\" >> \"$LOG_FILE\"\n\n# Extract hook data\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path // \"\"')\n\n# Get the current process ID that we created for this user prompt\nPROCESS_TRACKING_DIR=\"/tmp/claude-current-process\"\nCURRENT_PROCESS_ID=$(cat \"$PROCESS_TRACKING_DIR/$SESSION_ID\" 2>/dev/null)\n\n# Detect if the process was interrupted using multiple methods\nINTERRUPTED=false\nINTERRUPT_REASON=\"\"\n\n# Method 1: Check if a tool was interrupted (flag set by post-tool-use hook)\n# Now using process ID instead of session ID\nINTERRUPT_DIR=\"/tmp/claude-interrupted\"\nINTERRUPT_FLAG=\"$INTERRUPT_DIR/$CURRENT_PROCESS_ID\"\nif [ -f \"$INTERRUPT_FLAG\" ]; then\n  INTERRUPTED=true\n  INTERRUPT_REASON=\"Tool execution interrupted by user\"\n  rm -f \"$INTERRUPT_FLAG\"\nfi\n\n# Method 2: Parse transcript file for interruption markers\n# Only check the LAST 5 lines to avoid false positives from conversation history\nif [ \"$INTERRUPTED\" = false ] && [ -n \"$TRANSCRIPT_PATH\" ] && [ -f \"$TRANSCRIPT_PATH\" ]; then\n  # Check if the last few lines of transcript contain interruption text\n  if tail -5 \"$TRANSCRIPT_PATH\" 2>/dev/null | grep -q \"Request interrupted by user\"; then\n    INTERRUPTED=true\n    INTERRUPT_REASON=\"Process interrupted (detected in transcript)\"\n  fi\nfi\n\n# Method 3: Removed - Don't assume short processes without tools are interrupted\n# This was causing false positives for simple text responses\n\n# Check if Claude's last message is a question (waiting for user input)\nWAITING_FOR_INPUT=false\n\nif [ -n \"$TRANSCRIPT_PATH\" ] && [ -f \"$TRANSCRIPT_PATH\" ]; then\n  # Get the last assistant message from the transcript\n  LAST_ASSISTANT_MESSAGE=$(tac \"$TRANSCRIPT_PATH\" | grep -m1 '\"role\":\"assistant\"' | jq -r '.message.content[] | select(.type==\"text\") | .text' 2>/dev/null)\n\n  if [ -n \"$LAST_ASSISTANT_MESSAGE\" ]; then\n    echo \"  Last assistant message: ${LAST_ASSISTANT_MESSAGE:0:100}...\" >> \"$LOG_FILE\"\n\n    # Check if the message ends with a question mark or contains question patterns\n    if echo \"$LAST_ASSISTANT_MESSAGE\" | grep -qE '\\?[[:space:]]*$'; then\n      WAITING_FOR_INPUT=true\n      echo \"  Detected question (ends with ?)\" >> \"$LOG_FILE\"\n    fi\n  fi\nfi\n\n# The stop hook fires when Claude finishes responding to a user prompt\n# Mark the current process as completed or interrupted, or waiting for input\nif [ -n \"$CURRENT_PROCESS_ID\" ]; then\n  if [ \"$INTERRUPTED\" = true ]; then\n    STATUS=\"INTERRUPTED\"\n    RESULT=\"$INTERRUPT_REASON\"\n\n    echo \"  Process ID: $CURRENT_PROCESS_ID\" >> \"$LOG_FILE\"\n    echo \"  Status: $STATUS\" >> \"$LOG_FILE\"\n    echo \"  Result: $RESULT\" >> \"$LOG_FILE\"\n    echo \"\" >> \"$LOG_FILE\"\n\n    curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/complete \\\n      -H \"Content-Type: application/json\" \\\n      -d \"{\n        \\\"process_id\\\": \\\"$CURRENT_PROCESS_ID\\\",\n        \\\"status\\\": \\\"$STATUS\\\",\n        \\\"timestamp\\\": $(date +%s),\n        \\\"result\\\": \\\"$RESULT\\\"\n      }\" \\\n      --silent --output /dev/null\n\n    # Cleanup tracking files (using process ID)\n    TOOL_EXECUTION_DIR=\"/tmp/claude-tool-executed\"\n    PROCESS_TIME_DIR=\"/tmp/claude-process-times\"\n    rm -f \"$TOOL_EXECUTION_DIR/$CURRENT_PROCESS_ID\" 2>/dev/null\n    rm -f \"$PROCESS_TIME_DIR/$CURRENT_PROCESS_ID\" 2>/dev/null\n    rm -f \"$PROCESS_TRACKING_DIR/$SESSION_ID\" 2>/dev/null\n  elif [ \"$WAITING_FOR_INPUT\" = true ]; then\n    # Don't mark as completed - send a webhook to indicate waiting for input\n    echo \"  Status: WAITING_FOR_INPUT (question detected)\" >> \"$LOG_FILE\"\n    echo \"\" >> \"$LOG_FILE\"\n\n    curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/status \\\n      -H \"Content-Type: application/json\" \\\n      -d \"{\n        \\\"process_id\\\": \\\"$CURRENT_PROCESS_ID\\\",\n        \\\"status\\\": \\\"WAITING_FOR_INPUT\\\",\n        \\\"timestamp\\\": $(date +%s),\n        \\\"reason\\\": \\\"Agent asked a question\\\",\n        \\\"input_request\\\": {\n          \\\"prompt\\\": \\\"Agent is waiting for your input. Please check the conversation.\\\",\n          \\\"options\\\": []\n        }\n      }\" \\\n      --silent --output /dev/null\n\n    # Don't send process/complete webhook or cleanup tracking files yet\n    # The process is still active, waiting for user input\n  else\n    STATUS=\"COMPLETED\"\n    RESULT=\"Request completed successfully\"\n\n    echo \"  Process ID: $CURRENT_PROCESS_ID\" >> \"$LOG_FILE\"\n    echo \"  Status: $STATUS\" >> \"$LOG_FILE\"\n    echo \"  Result: $RESULT\" >> \"$LOG_FILE\"\n    echo \"\" >> \"$LOG_FILE\"\n\n    curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/complete \\\n      -H \"Content-Type: application/json\" \\\n      -d \"{\n        \\\"process_id\\\": \\\"$CURRENT_PROCESS_ID\\\",\n        \\\"status\\\": \\\"$STATUS\\\",\n        \\\"timestamp\\\": $(date +%s),\n        \\\"result\\\": \\\"$RESULT\\\"\n      }\" \\\n      --silent --output /dev/null\n\n    # Cleanup tracking files (using process ID)\n    TOOL_EXECUTION_DIR=\"/tmp/claude-tool-executed\"\n    PROCESS_TIME_DIR=\"/tmp/claude-process-times\"\n    rm -f \"$TOOL_EXECUTION_DIR/$CURRENT_PROCESS_ID\" 2>/dev/null\n    rm -f \"$PROCESS_TIME_DIR/$CURRENT_PROCESS_ID\" 2>/dev/null\n    rm -f \"$PROCESS_TRACKING_DIR/$SESSION_ID\" 2>/dev/null\n  fi\nfi\n\nexit 0\n",
        "agent-meeting-room/hooks/subagent-stop.sh": "#!/bin/bash\n\necho \"Hook triggered: subagent-stop\"\n\n# Debug log file\nDEBUG_LOG=\"/tmp/claude-hook-debug.log\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract hook data\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\n\necho \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Hook fired for session '$SESSION_ID'\" >> \"$DEBUG_LOG\"\n\n# Find the oldest task mapping (FIFO - first task that started is first to finish)\nMAPPING_DIR=\"/tmp/claude-agent-sessions\"\nLOCK_DIR=\"/tmp/claude-agent-sessions-locks\"\nmkdir -p \"$LOCK_DIR\"\n\nif [ -d \"$MAPPING_DIR\" ]; then\n  # Count files before processing\n  FILE_COUNT=$(ls -1 \"$MAPPING_DIR\"/*.parent 2>/dev/null | wc -l)\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Found $FILE_COUNT metadata files in $MAPPING_DIR\" >> \"$DEBUG_LOG\"\n\n  # Try to acquire a lock on the oldest available mapping file\n  OLDEST_MAPPING=\"\"\n  MAX_WAIT_MS=500\n  START_TIME=$(date +%s%N)\n\n  while [ -z \"$OLDEST_MAPPING\" ]; do\n    # Check if we've waited too long\n    CURRENT_TIME=$(date +%s%N)\n    ELAPSED_MS=$(( (CURRENT_TIME - START_TIME) / 1000000 ))\n    if [ $ELAPSED_MS -gt $MAX_WAIT_MS ]; then\n      echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Timeout waiting for available metadata file\" >> \"$DEBUG_LOG\"\n      break\n    fi\n\n    # Get all .parent files sorted by age (oldest first when using tail -1)\n    for CANDIDATE in $(ls -t \"$MAPPING_DIR\"/*.parent 2>/dev/null | tac); do\n      CANDIDATE_KEY=$(basename \"${CANDIDATE%.parent}\")\n      LOCK_FILE=\"$LOCK_DIR/$CANDIDATE_KEY.lock\"\n\n      # Try to create lock file atomically\n      if mkdir \"$LOCK_FILE\" 2>/dev/null; then\n        OLDEST_MAPPING=\"$CANDIDATE\"\n        echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Acquired lock for $CANDIDATE_KEY\" >> \"$DEBUG_LOG\"\n        break 2\n      fi\n    done\n\n    # If no file was available, sleep briefly and retry\n    if [ -z \"$OLDEST_MAPPING\" ]; then\n      sleep 0.01\n    fi\n  done\n\n  if [ -n \"$OLDEST_MAPPING\" ]; then\n    # Extract the base key (remove .parent extension)\n    BASE_KEY=\"${OLDEST_MAPPING%.parent}\"\n    TASK_KEY=$(basename \"$BASE_KEY\")\n\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Processing metadata file '$BASE_KEY'\" >> \"$DEBUG_LOG\"\n\n    # Read the mapping data\n    PARENT_PROCESS_ID=$(cat \"${BASE_KEY}.parent\" 2>/dev/null || echo \"\")\n    PARENT_SESSION_ID=$(cat \"${BASE_KEY}.session\" 2>/dev/null || echo \"\")\n    DESCRIPTION=$(cat \"${BASE_KEY}.description\" 2>/dev/null || echo \"Agent Task\")\n    PROMPT=$(cat \"${BASE_KEY}.prompt\" 2>/dev/null || echo \"\")\n    CWD=$(cat \"${BASE_KEY}.cwd\" 2>/dev/null || echo \"\")\n    TRANSCRIPT_PATH=$(cat \"${BASE_KEY}.transcript\" 2>/dev/null || echo \"\")\n    PROJECT_NAME=$(cat \"${BASE_KEY}.project\" 2>/dev/null || echo \"\")\n\n    # Generate unique child process ID from task key\n    CHILD_PROCESS_ID=\"$TASK_KEY\"\n\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Parent session ID = '$PARENT_SESSION_ID'\" >> \"$DEBUG_LOG\"\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Parent process ID = '$PARENT_PROCESS_ID'\" >> \"$DEBUG_LOG\"\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Child process ID (generated) = '$CHILD_PROCESS_ID'\" >> \"$DEBUG_LOG\"\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Task description = '$DESCRIPTION'\" >> \"$DEBUG_LOG\"\n\n    START_TIMESTAMP=$(date +%s)\n    COMPLETE_TIMESTAMP=$((START_TIMESTAMP + 1))\n\n    # Create the subprocess (agent) linked to the parent process\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Sending webhook to create child process (parent_session='$PARENT_SESSION_ID', child_process='$CHILD_PROCESS_ID')\" >> \"$DEBUG_LOG\"\n\n    # Escape special characters in JSON strings\n    DESCRIPTION_ESCAPED=$(echo \"$DESCRIPTION\" | jq -Rs .)\n    PROMPT_ESCAPED=$(echo \"$PROMPT\" | jq -Rs .)\n    TRANSCRIPT_PATH_ESCAPED=$(echo \"$TRANSCRIPT_PATH\" | jq -Rs .)\n    CWD_ESCAPED=$(echo \"$CWD\" | jq -Rs .)\n    PROJECT_NAME_ESCAPED=$(echo \"$PROJECT_NAME\" | jq -Rs .)\n\n    # Build JSON payload using jq for proper escaping\n    PAYLOAD=$(jq -n \\\n      --arg process_id \"$CHILD_PROCESS_ID\" \\\n      --arg session_id \"$PARENT_SESSION_ID\" \\\n      --arg parent_process_id \"$PARENT_PROCESS_ID\" \\\n      --arg agent_id \"claude-agent\" \\\n      --arg title \"$DESCRIPTION\" \\\n      --arg prompt \"$PROMPT\" \\\n      --arg tool_name \"Task\" \\\n      --argjson timestamp \"$START_TIMESTAMP\" \\\n      --arg transcript_path \"$TRANSCRIPT_PATH\" \\\n      --arg cwd \"$CWD\" \\\n      --arg project_name \"$PROJECT_NAME\" \\\n      '{\n        process_id: $process_id,\n        session_id: $session_id,\n        parent_process_id: $parent_process_id,\n        agent_id: $agent_id,\n        title: $title,\n        prompt: $prompt,\n        tool_name: $tool_name,\n        timestamp: $timestamp,\n        transcript_path: $transcript_path,\n        cwd: $cwd,\n        project_name: $project_name\n      }')\n\n    HTTP_STATUS=$(curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/start \\\n      -H \"Content-Type: application/json\" \\\n      -d \"$PAYLOAD\" \\\n      --silent --output /dev/null --write-out \"%{http_code}\")\n\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Webhook /process/start returned HTTP $HTTP_STATUS\" >> \"$DEBUG_LOG\"\n\n    # Immediately mark it as completed (use +1 second to avoid duplicate status change IDs)\n    COMPLETE_PAYLOAD=$(jq -n \\\n      --arg process_id \"$CHILD_PROCESS_ID\" \\\n      --arg status \"COMPLETED\" \\\n      --argjson timestamp \"$COMPLETE_TIMESTAMP\" \\\n      '{\n        process_id: $process_id,\n        status: $status,\n        timestamp: $timestamp\n      }')\n\n    HTTP_STATUS=$(curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/complete \\\n      -H \"Content-Type: application/json\" \\\n      -d \"$COMPLETE_PAYLOAD\" \\\n      --silent --output /dev/null --write-out \"%{http_code}\")\n\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Webhook /process/complete returned HTTP $HTTP_STATUS\" >> \"$DEBUG_LOG\"\n\n    # Clean up the mapping files and lock\n    rm -f \"${BASE_KEY}\".* 2>/dev/null\n    rmdir \"$LOCK_DIR/$TASK_KEY.lock\" 2>/dev/null\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: Cleaned up metadata files and lock for '$BASE_KEY'\" >> \"$DEBUG_LOG\"\n  else\n    # No unlocked mapping found\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: WARNING - No available metadata file (timeout or no files)\" >> \"$DEBUG_LOG\"\n    # Don't create orphan process - just exit silently\n    exit 0\n  fi\nelse\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S.%N')] SUBAGENT-STOP: ERROR - Mapping directory does not exist!\" >> \"$DEBUG_LOG\"\n  exit 0\nfi\n\nexit 0\n",
        "agent-meeting-room/hooks/user-prompt-required.sh": "#!/bin/bash\n\necho \"Hook triggered: user-prompt-required\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract hook data\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path')\n\n# Get the current process ID for this session\nPROCESS_TRACKING_DIR=\"/tmp/claude-current-process\"\nCURRENT_PROCESS_ID=$(cat \"$PROCESS_TRACKING_DIR/$SESSION_ID\" 2>/dev/null)\n\n# Only send webhook if we have a process ID\nif [ -n \"$CURRENT_PROCESS_ID\" ]; then\n  # Send webhook to update process status to WAITING_FOR_INPUT\n  # Note: The hook doesn't provide the specific prompt/question,\n  # so we use a generic message. For detailed input requests,\n  # agents should explicitly call the webhook with input_request details.\n\n  curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/status \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n      \\\"process_id\\\": \\\"$CURRENT_PROCESS_ID\\\",\n      \\\"status\\\": \\\"WAITING_FOR_INPUT\\\",\n      \\\"timestamp\\\": $(date +%s),\n      \\\"reason\\\": \\\"Agent requires user input\\\",\n      \\\"input_request\\\": {\n        \\\"prompt\\\": \\\"Agent is waiting for your input. Please check the conversation.\\\",\n        \\\"options\\\": []\n      }\n    }\" \\\n    --silent --output /dev/null\nfi\n\nexit 0\n",
        "agent-meeting-room/hooks/user-prompt-submit.sh": "#!/bin/bash\n\necho \"Hook triggered: user-prompt-submit\"\n\n# Set up logging\nLOG_FILE=\"/tmp/claude-hooks.log\"\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Log that hook was triggered\necho \"[$(date '+%Y-%m-%d %H:%M:%S')] user-prompt-submit hook triggered\" >> \"$LOG_FILE\"\n\n# Extract hook data\nSESSION_ID=$(echo \"$INPUT\" | jq -r '.session_id')\nPROMPT=$(echo \"$INPUT\" | jq -r '.prompt')\nTRANSCRIPT_PATH=$(echo \"$INPUT\" | jq -r '.transcript_path // \"\"')\nCWD=$(echo \"$INPUT\" | jq -r '.cwd // \"\"')\n\n# Get project name from environment variable, fallback to CWD basename\nPROJECT_NAME=\"${CLAUDE_HOOK_PROJECT_NAME:-}\"\nif [ -z \"$PROJECT_NAME\" ] && [ -n \"$CWD\" ]; then\n  PROJECT_NAME=$(basename \"$CWD\")\nfi\n\n# Log the extracted data\necho \"  Session ID: $SESSION_ID\" >> \"$LOG_FILE\"\necho \"  Prompt: $PROMPT\" >> \"$LOG_FILE\"\necho \"  CWD: $CWD\" >> \"$LOG_FILE\"\necho \"  Project Name: $PROJECT_NAME\" >> \"$LOG_FILE\"\n\n# Check if there's a process waiting for input in this session\nWAITING_PROCESS=$(curl -s \"https://agent-meeting-room.up.railway.app/api/sessions/$SESSION_ID/waiting-process\" | jq -r '.process')\n\nif [ \"$WAITING_PROCESS\" != \"null\" ] && [ -n \"$WAITING_PROCESS\" ]; then\n  # Resume the existing process\n  PROCESS_ID=$(echo \"$WAITING_PROCESS\" | jq -r '.id')\n  echo \"  Resuming existing process: $PROCESS_ID\" >> \"$LOG_FILE\"\n\n  # Update the process status back to RUNNING\n  RESPONSE=$(curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/status \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n      \\\"process_id\\\": \\\"$PROCESS_ID\\\",\n      \\\"status\\\": \\\"RUNNING\\\",\n      \\\"timestamp\\\": $(date +%s),\n      \\\"reason\\\": \\\"User provided input: $PROMPT\\\"\n    }\" \\\n    --silent -w \"\\nHTTP_CODE:%{http_code}\" 2>&1)\n\n  echo \"  Resume response: $RESPONSE\" >> \"$LOG_FILE\"\nelse\n  # Create a new process\n  PROCESS_ID=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid)\n  echo \"  Creating new process: $PROCESS_ID\" >> \"$LOG_FILE\"\n\n  # Create a unique process for each user request\n  # process_id = unique process ID, session_id = Claude Code terminal session\n  RESPONSE=$(curl -X POST https://agent-meeting-room.up.railway.app/webhooks/process/start \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n      \\\"process_id\\\": \\\"$PROCESS_ID\\\",\n      \\\"session_id\\\": \\\"$SESSION_ID\\\",\n      \\\"parent_process_id\\\": null,\n      \\\"agent_id\\\": \\\"claude\\\",\n      \\\"title\\\": \\\"$PROMPT\\\",\n      \\\"prompt\\\": \\\"$PROMPT\\\",\n      \\\"tool_name\\\": null,\n      \\\"timestamp\\\": $(date +%s),\n      \\\"transcript_path\\\": \\\"$TRANSCRIPT_PATH\\\",\n      \\\"cwd\\\": \\\"$CWD\\\",\n      \\\"project_name\\\": \\\"$PROJECT_NAME\\\"\n    }\" \\\n    --silent -w \"\\nHTTP_CODE:%{http_code}\" 2>&1)\n\n  echo \"  Create response: $RESPONSE\" >> \"$LOG_FILE\"\n\n  # Store process start time for interruption detection\n  PROCESS_TIME_DIR=\"/tmp/claude-process-times\"\n  mkdir -p \"$PROCESS_TIME_DIR\"\n  date +%s > \"$PROCESS_TIME_DIR/$PROCESS_ID\"\nfi\n\necho \"\" >> \"$LOG_FILE\"\n\n# Store the current process ID for other hooks to access\n# This allows pre-tool-use to know which process spawned an agent\nPROCESS_TRACKING_DIR=\"/tmp/claude-current-process\"\nmkdir -p \"$PROCESS_TRACKING_DIR\"\necho \"$PROCESS_ID\" > \"$PROCESS_TRACKING_DIR/$SESSION_ID\"\n\nexit 0\n",
        "documentation-generator/.claude-plugin/plugin.json": "{\n  \"name\": \"documentation-generator\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Generate comprehensive project documentation through interactive dialog with templates\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"documentation\", \"templates\", \"generator\", \"productivity\"],\n  \"commands\": \"./commands\"\n}\n",
        "documentation-generator/README.md": "# Documentation Generator Plugin\n\nA Claude Code plugin that generates comprehensive project documentation through an interactive dialog.\n\n## What it does\n\nThis plugin helps you create and maintain project documentation by:\n\n1. **Analyzing your codebase** to understand its structure and components\n2. **Proposing relevant documentation** based on what exists in your project\n3. **Interactive dialog** to refine which docs to generate\n4. **Template-guided generation** for consistent, thorough documentation\n5. **Smart merge** for updating existing docs without losing custom content\n\n## Usage\n\nRun the slash command:\n\n```\n/generate-docs\n```\n\nClaude will:\n1. Analyze your project structure\n2. Propose documentation files that make sense for your project\n3. Ask for your feedback and approval\n4. Generate the selected documentation in a `documentation/` folder\n\n## Available Documentation Types\n\n| Template | Generated when... |\n|----------|------------------|\n| `architecture.md` | Always recommended - system overview |\n| `api-reference.md` | API routes or endpoints detected |\n| `data-models.md` | Database, ORM, or data structures found |\n| `development-setup.md` | Always recommended - onboarding guide |\n| `testing.md` | Test files or test config found |\n| `deployment.md` | Dockerfile, CI/CD, or k8s config found |\n| `contributing.md` | Open source or team project |\n| `security.md` | Auth, sensitive data, or security config found |\n| `troubleshooting.md` | Complex project with potential issues |\n| `configuration.md` | Environment variables or config files found |\n| `changelog.md` | Version tracking needed |\n\n## Smart Merge\n\nWhen documentation already exists, the plugin will:\n\n- Preserve your custom sections\n- Add missing template sections\n- Flag potentially outdated content\n- Ask for confirmation before changes\n\n## Installation\n\n### Via Plugin Marketplace\n\n```bash\n/plugin marketplace add <github-user>/claude-code-plugins\n/plugin install documentation-generator\n```\n\n### Manual Installation\n\n1. Clone or copy this plugin directory\n2. Run `/plugin install <path-to-plugin>`\n\n## Output Structure\n\n```\nyour-project/\n documentation/\n     architecture.md\n     development-setup.md\n     api-reference.md\n     ... (selected docs)\n```\n\n## Customization\n\nThe templates in `templates/` directory contain section structures with guidance comments. These guide Claude on what to include but allow adaptation based on your project's specifics.\n",
        "documentation-generator/commands/generate-docs.md": "---\ndescription: Generate comprehensive project documentation through interactive dialog\n---\n\nYou are a documentation generator assistant. Your task is to help create comprehensive project documentation through an interactive dialog.\n\n## Phase 1: Project Analysis\n\nFirst, analyze the codebase to understand what exists:\n\n1. **Check for existing documentation**:\n   - Look for a `documentation/` folder\n   - Check for README.md, CONTRIBUTING.md, or other docs in the root\n   - Note what documentation already exists\n\n2. **Identify project type and structure**:\n   - Check package.json, Cargo.toml, go.mod, requirements.txt, etc. for project type\n   - Look for common patterns: src/, lib/, api/, tests/, etc.\n   - Identify the primary language and framework\n\n3. **Detect what components exist**:\n   - API routes (Express, FastAPI, etc.)\n   - Database/ORM (Prisma, TypeORM, SQLAlchemy, etc.)\n   - Deployment config (Dockerfile, kubernetes/, .github/workflows/)\n   - Test setup (jest.config, pytest.ini, etc.)\n   - Environment config (.env.example, config/)\n\n## Phase 2: Documentation Proposal\n\nBased on your analysis, propose which documentation files make sense for this project. Use the templates in `${CLAUDE_PLUGIN_ROOT}/templates/` as reference for available categories:\n\n| Template | Propose when... |\n|----------|----------------|\n| architecture.md | Always - every project benefits from architectural overview |\n| api-reference.md | Project has API routes, REST endpoints, or GraphQL |\n| data-models.md | Project has database, ORM, or significant data structures |\n| development-setup.md | Always - helps onboarding new developers |\n| testing.md | Project has test files or test configuration |\n| deployment.md | Project has Dockerfile, CI/CD, or deployment configs |\n| contributing.md | Open source project or team collaboration expected |\n| security.md | Project handles auth, sensitive data, or external APIs |\n| troubleshooting.md | Complex project with potential failure modes |\n| configuration.md | Project has environment variables or config files |\n| changelog.md | Project needs version tracking |\n\nPresent your proposal with reasoning:\n```\nBased on my analysis of your project, I recommend creating these documentation files:\n\n**Recommended:**\n- architecture.md - [reason based on what you found]\n- development-setup.md - [reason]\n- [other relevant docs]\n\n**Optional (you may want to consider):**\n- [docs that might be useful but aren't essential]\n\n**Not applicable:**\n- [docs that don't make sense for this project, e.g., \"api-reference.md - no API endpoints found\"]\n```\n\n## Phase 3: User Dialog\n\nAsk the user for feedback:\n- Do they want to add any documentation from the \"optional\" or \"not applicable\" lists?\n- Do they want to remove any from the recommended list?\n- Are there any specific aspects they want documented?\n\nContinue the dialog until the user approves the final list.\n\n## Phase 4: Documentation Generation\n\nFor each approved documentation file:\n\n1. **Read the template** from `${CLAUDE_PLUGIN_ROOT}/templates/[filename].md`\n2. **Analyze the codebase** to gather information for each section\n3. **Generate content** following the template structure\n4. **Handle existing docs** with smart merge:\n   - If the file exists in `documentation/`, read it first\n   - Preserve custom sections not in the template\n   - Update sections that appear outdated (reference removed files, old APIs, etc.)\n   - Add missing sections from the template\n   - Show the user what will change before writing\n\n5. **Write to `documentation/`** folder in the project root\n\n## Important Guidelines\n\n- Use the templates as structural guides, but adapt content to what actually exists\n- Be thorough in your codebase analysis - read key files to understand the architecture\n- When merging with existing docs, be conservative - preserve user content when in doubt\n- Ask clarifying questions if you're unsure about project specifics\n- Generate documentation that is specific and useful, not generic boilerplate\n",
        "functional-specifications/.claude-plugin/plugin.json": "{\n  \"name\": \"functional-specifications\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Generate functional specifications from business case and personas through interactive dialogue\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"functional-specifications\",\n    \"features\",\n    \"business-case\",\n    \"personas\",\n    \"requirements\",\n    \"productivity\"\n  ],\n  \"commands\": \"./commands\"\n}\n",
        "functional-specifications/README.md": "# Functional Specifications Generator\n\nGenerate functional specifications from your business case and user personas through an interactive dialogue.\n\n## Overview\n\nThis plugin helps you create comprehensive functional specifications by:\n\n1. **Analyzing** your existing business case documentation\n2. **Mapping** persona needs and pain points\n3. **Proposing** features that address real user needs\n4. **Refining** proposals through interactive dialogue\n5. **Generating** a structured specification document\n\n## Usage\n\n```\n/generate-functional-specifications\n```\n\n## Prerequisites\n\nFor best results, have these documents ready:\n\n- **Business Case**: Document describing the problem, goals, and scope\n- **Personas**: User persona documents (can be generated with `/generate-personas`)\n\nThe plugin will search for these in common documentation locations, or you can specify custom paths.\n\n## Workflow\n\n### Phase 1: Discovery\n- Locates existing business case and persona documents\n- Confirms sources with user\n\n### Phase 2: Business Case Analysis\n- Summarizes the business problem and goals\n- Validates understanding with user\n\n### Phase 3: Persona Needs Mapping\n- Extracts goals, pain points, and tasks from each persona\n- Validates persona understanding\n\n### Phase 4: Feature Proposal\n- Proposes features based on business case and persona needs\n- **User can always**:\n  - Accept, modify, or reject proposals\n  - Add their own feature ideas\n  - Prioritize features (MoSCoW method)\n\n### Phase 5: Specification Detailing\n- Documents each feature with full details\n- Identifies dependencies between features\n\n### Phase 6: Output Generation\n- Creates a single comprehensive specification document\n- Includes traceability matrix linking features to personas and business goals\n\n## Output\n\nThe plugin generates a single markdown document:\n\n```\ndocumentation/functional-specifications.md\n```\n\nThe document includes:\n- Executive summary\n- Business case summary\n- Persona overview\n- Feature specifications with:\n  - Description\n  - User and business benefit\n  - Personas served\n  - Dependencies\n  - Out of scope items\n- Traceability matrix\n- Open questions\n- Glossary and references\n\n## User Interaction\n\nThis plugin prioritizes user input at every step:\n\n- **Validate** - Confirms understanding before proceeding\n- **Propose** - Presents options, never dictates\n- **Invite** - Actively asks for your ideas and additions\n- **Refine** - Allows modifications at any point\n- **Backtrack** - Lets you revisit previous decisions\n\n## Integration with Other Plugins\n\nThis plugin fits into a documentation workflow:\n\n1. `/generate-personas` - Create user personas\n2. **`/generate-functional-specifications`** - Define features (this plugin)\n3. `/generate-user-stories` - Create user stories from features\n4. `/refine-technical-specifications` - Define technical requirements\n\n## Example Session\n\n```\nUser: /generate-functional-specifications\n\nClaude: I'll help you create functional specifications. Let me first search\n        for existing documentation...\n\n        I found:\n        - documentation/business/business-case.md\n        - documentation/business/personas/developer.md\n        - documentation/business/personas/manager.md\n\n        Are these the correct source documents?\n\nUser: Yes, those are correct\n\nClaude: Great! Based on the business case, here's my understanding:\n\n        **Problem Statement**: Teams struggle to track project progress...\n        **Business Goals**: Improve visibility, reduce manual reporting...\n\n        Does this accurately capture your business case?\n\nUser: Yes, but also add that we want to integrate with existing tools\n\nClaude: Noted! Now analyzing personas... Based on Developer and Manager\n        personas, I propose these features:\n\n        ## Core Features\n        - Feature: Progress Dashboard\n          Addresses: Manager need for visibility, Developer pain point...\n\n        Would you like to accept these, modify them, or add your own ideas?\n```\n\n## License\n\nMIT\n",
        "functional-specifications/commands/generate-functional-specifications.md": "---\ndescription: Generate functional specifications from business case and personas\n---\n\n# Functional Specifications Generator\n\nYou are an expert business analyst and product manager. Your task is to help the user create functional specifications by analyzing their business case and personas, then proposing features that address real user needs.\n\n**Core Principle**: The user should always have the opportunity to provide input, refine proposals, or add their own ideas at every step.\n\n## Phase 1: Discovery\n\n### Step 1.1: Locate Documentation\n\nUse the `Glob` tool to search for existing documentation:\n\n1. **Business Case Documents**: Search for files that might contain business case information:\n   - `**/business-case*.md`\n   - `**/business/*.md`\n   - `**/documentation/business/*.md`\n   - `**/requirements/*.md`\n   - `**/README.md` (project root)\n\n2. **Persona Documents**: Search for persona files:\n   - `**/personas/*.md`\n   - `**/documentation/business/personas/*.md`\n   - `**/persona-*.md`\n\n### Step 1.2: Confirm Sources\n\nUse `AskUserQuestion` to confirm the discovered files or ask for correct locations:\n\n**Question**: \"I found the following documentation. Please confirm or provide the correct locations.\"\n\nOptions:\n- \"These are correct\" - Proceed with found files\n- \"Let me specify paths\" - User provides custom paths\n- \"I don't have these yet\" - Guide user to create them or gather info interactively\n\n### Step 1.3: Read and Analyze\n\nUse the `Read` tool to analyze all confirmed documentation files. Create a mental model of:\n- The business problem being solved\n- Target users and their characteristics\n- Existing constraints or requirements\n- Success criteria\n\n## Phase 2: Business Case Analysis\n\n### Step 2.1: Summarize Understanding\n\nPresent a summary of the business case to the user:\n\n```\n## Business Case Summary\n\n**Problem Statement**: [What problem is being solved]\n**Target Market/Users**: [Who will use this]\n**Business Goals**: [What success looks like]\n**Constraints**: [Known limitations]\n```\n\n### Step 2.2: Validate and Enrich\n\nUse `AskUserQuestion` to validate your understanding:\n\n**Question**: \"Does this summary accurately capture your business case?\"\n\nOptions:\n- \"Yes, this is accurate\" - Proceed\n- \"Needs adjustments\" - User provides corrections\n- \"Add more context\" - User adds additional information\n\n**Always ask**: \"Is there anything about the business context I should know that isn't in the documentation?\"\n\n## Phase 3: Persona Needs Mapping\n\n### Step 3.1: Extract Persona Needs\n\nFor each persona found, extract and list:\n- Primary goals\n- Key pain points\n- Critical tasks they need to perform\n- Success criteria from their perspective\n\n### Step 3.2: Present Persona Analysis\n\nPresent the extracted needs in a structured format:\n\n```\n## Persona: [Name]\n\n**Role**: [Their role]\n**Primary Goals**:\n- Goal 1\n- Goal 2\n\n**Pain Points**:\n- Pain point 1\n- Pain point 2\n\n**Key Tasks**:\n- Task 1\n- Task 2\n```\n\n### Step 3.3: Validate Persona Understanding\n\nUse `AskUserQuestion`:\n\n**Question**: \"Have I correctly identified the key needs for each persona?\"\n\nOptions:\n- \"Yes, proceed with feature proposals\" - Continue to Phase 4\n- \"I want to adjust some needs\" - User refines\n- \"Add needs I haven't documented\" - User adds more context\n\n## Phase 4: Feature Proposal\n\n### Step 4.1: Generate Feature Proposals\n\nBased on business case analysis and persona needs, propose features. For each feature, provide:\n\n- **Feature Name**: Clear, descriptive name\n- **Description**: What this feature does (2-3 sentences)\n- **Addresses**: Which persona needs/pain points this solves\n- **Business Value**: How this supports business goals\n\nGroup features into logical categories (e.g., Core Features, User Management, Reporting, etc.)\n\n### Step 4.2: Present Proposals\n\nPresent features in a clear format:\n\n```\n## Proposed Features\n\n### Category: [Category Name]\n\n#### Feature: [Feature Name]\n**Description**: [What it does]\n**Addresses**:\n- [Persona 1]: [Need/pain point addressed]\n- [Persona 2]: [Need/pain point addressed]\n**Business Value**: [How it supports business goals]\n\n---\n```\n\n### Step 4.3: Interactive Refinement\n\nUse `AskUserQuestion` for each category or batch of features:\n\n**Question**: \"For the [Category] features, what would you like to do?\"\n\nOptions:\n- \"Accept all proposed features\" - Keep as-is\n- \"Accept with modifications\" - User specifies changes\n- \"Remove some features\" - User selects which to remove\n- \"Add more features to this category\" - User adds their own ideas\n\n**Critical**: Always include an option for the user to add their own feature ideas. Ask:\n\n\"Are there any features you have in mind that I haven't proposed? Feel free to describe them.\"\n\n### Step 4.4: Priority Discussion\n\nUse `AskUserQuestion`:\n\n**Question**: \"Would you like to prioritize these features?\"\n\nOptions:\n- \"Yes, let's prioritize\" - Guide through MoSCoW or similar\n- \"No, keep them as a flat list\" - Skip prioritization\n- \"I'll prioritize later\" - Note that prioritization is pending\n\nIf prioritizing, use MoSCoW method:\n- **Must Have**: Critical for launch\n- **Should Have**: Important but not critical\n- **Could Have**: Nice to have\n- **Won't Have (this time)**: Out of scope for now\n\n## Phase 5: Specification Detailing\n\n### Step 5.1: Feature Details\n\nFor each accepted feature, ensure the specification includes:\n\n1. **Feature Name**: Clear identifier\n2. **Description**: Detailed explanation of functionality\n3. **User Personas**: Which personas this serves\n4. **User Benefit**: The value users get from this feature\n5. **Business Benefit**: The value the business gets\n6. **Dependencies**: Other features or systems this depends on\n7. **Out of Scope**: What this feature explicitly does NOT include\n\n### Step 5.2: Cross-Feature Considerations\n\nIdentify and document:\n- Feature dependencies (which features depend on others)\n- Shared functionality across features\n- Potential conflicts between features\n\n### Step 5.3: Final User Review\n\nUse `AskUserQuestion`:\n\n**Question**: \"Before generating the final document, would you like to make any changes?\"\n\nOptions:\n- \"Generate the document\" - Proceed to output\n- \"Review specific features\" - Go back to specific sections\n- \"Add more details to some features\" - User specifies which\n- \"I have additional context to add\" - User provides more input\n\n## Phase 6: Output Generation\n\n### Step 6.1: Determine Output Location\n\nUse `AskUserQuestion`:\n\n**Question**: \"Where should I save the functional specifications?\"\n\nOptions:\n- \"`documentation/functional-specifications.md`\" - Default location\n- \"`docs/functional-specifications.md`\" - Alternative docs folder\n- \"Let me specify a custom path\" - User provides path\n\n### Step 6.2: Generate Document\n\nUse the `Write` tool to create the functional specifications document using the template at `${CLAUDE_PLUGIN_ROOT}/templates/functional-specifications-template.md`.\n\nInclude:\n1. Executive summary\n2. Business case summary\n3. Persona overview with needs\n4. Feature specifications (organized by category/priority)\n5. Traceability matrix (features to personas to business goals)\n6. Open questions or pending decisions\n\n### Step 6.3: Completion Summary\n\nProvide a summary:\n\n```\n## Functional Specifications Generated\n\n**Document**: [path to generated file]\n\n**Summary**:\n- Total features specified: [count]\n- Personas addressed: [list]\n- Categories: [list]\n\n**Next Steps**:\n1. Review the generated specifications with stakeholders\n2. Use `/generate-user-stories` to create user stories from these features\n3. Use `/refine-technical-specifications` to define technical requirements\n```\n\n## Guidelines\n\n### User Interaction Principles\n\n1. **Never assume** - Always validate understanding with the user\n2. **Offer choices** - Present options, don't dictate\n3. **Welcome additions** - Explicitly ask for user's own ideas\n4. **Allow backtracking** - Let users revisit previous decisions\n5. **Explain reasoning** - Share why you're proposing specific features\n\n### Quality Principles\n\n1. **Trace everything** - Every feature should trace to a persona need and business goal\n2. **Be specific** - Vague features lead to vague implementations\n3. **Consider scope** - Clearly state what's in and out of scope\n4. **Identify dependencies** - Note where features rely on each other\n\n### Using TodoWrite\n\nUse the `TodoWrite` tool to track progress through personas and features. This helps maintain context and shows progress to the user.\n\nExample:\n```\n- [x] Phase 1: Discovery\n- [x] Phase 2: Business Case Analysis\n- [ ] Phase 3: Persona Needs (3/5 personas analyzed)\n- [ ] Phase 4: Feature Proposal\n- [ ] Phase 5: Specification Detailing\n- [ ] Phase 6: Output Generation\n```\n",
        "git-commit/.claude-plugin/plugin.json": "{\n  \"name\": \"git-commit\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Streamlined git commit and push with auto-generated commit messages\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"git\", \"commit\", \"automation\", \"productivity\"],\n  \"commands\": \"./commands\"\n}\n",
        "git-commit/README.md": "# Git Commit Plugin\n\nA Claude Code plugin that streamlines committing and pushing changes with auto-generated commit messages.\n\n## Usage\n\n```\n/commit              # Auto mode: commit and push immediately\n/commit --safe       # Safe mode: interactive approval flow\n```\n\n## Modes\n\n### Auto Mode (default)\n\nCommits and pushes in one step:\n1. Analyzes your changes\n2. Generates a commit message (conventional commits or repo style)\n3. Commits and pushes\n4. Reports: ` Committed and pushed: abc1234 feat: Add new feature`\n\n### Safe Mode (`--safe`)\n\nInteractive flow with approval:\n1. Shows files to be committed\n2. Proposes a commit message\n3. Asks for your approval (or edits)\n4. After commit, asks before pushing\n\n## Configuration\n\nSet default mode via environment variable:\n\n```bash\nexport CLAUDE_COMMIT_MODE=auto   # Default behavior\nexport CLAUDE_COMMIT_MODE=safe   # Always use safe mode\n```\n\n## Safety Features\n\n- Never force pushes\n- Warns when pushing to main/master\n- Skips secret files (.env, credentials, keys)\n- Suggests `git pull --rebase` if push fails\n- Never amends commits unless explicitly asked\n\n## Commit Message Style\n\nThe plugin:\n1. Matches your repository's existing commit style\n2. Falls back to conventional commits (feat/fix/docs/refactor/test/chore)\n3. Keeps messages concise and descriptive\n4. Includes Claude Code footer\n\n## Installation\n\n### Via Plugin Marketplace\n\n```bash\n/plugin marketplace add <github-user>/claude-code-plugins\n/plugin install git-commit\n```\n\n### Manual Installation\n\n1. Clone or copy this plugin directory\n2. Run `/plugin install <path-to-plugin>`\n",
        "git-commit/commands/commit.md": "---\ndescription: Commit and push changes with auto-generated commit messages\n---\n\nYou are a git commit assistant. Your task is to commit and push changes efficiently.\n\n## Mode Detection\n\nCheck the command arguments:\n- No arguments or `--auto`: **Auto mode** (default) - commit and push immediately\n- `--safe`: **Safe mode** - interactive approval flow\n\nAlso check environment variable `CLAUDE_COMMIT_MODE` if no flag provided:\n- `auto` (default): Auto mode\n- `safe`: Safe mode\n\n## Step 1: Analyze Changes\n\nRun these commands to understand what will be committed:\n\n```bash\ngit status\ngit diff --staged\ngit diff\ngit log --oneline -5\n```\n\n## Step 2: Safety Checks\n\nBefore proceeding, verify:\n\n1. **No secrets**: Skip files that look like secrets:\n   - `.env`, `.env.*` (except `.env.example`)\n   - `*credentials*`, `*secrets*`, `*.pem`, `*.key`\n   - If found, warn the user and exclude from commit\n\n2. **Branch check**: Note if on `main` or `master` branch (will warn before push)\n\n3. **No changes**: If nothing to commit, inform user and stop\n\n## Step 3: Generate Commit Message\n\nAnalyze the changes and generate a commit message:\n\n1. Look at recent commits (`git log --oneline -5`) to match the repository's style\n2. If no clear style, use conventional commits format:\n   - `feat:` - New feature\n   - `fix:` - Bug fix\n   - `docs:` - Documentation changes\n   - `refactor:` - Code refactoring\n   - `test:` - Test changes\n   - `chore:` - Maintenance tasks\n\n3. Keep the message concise but descriptive (1-2 sentences)\n4. Focus on the \"why\" not just the \"what\"\n\n## Step 4: Execute Based on Mode\n\n### Auto Mode (default)\n\n1. Stage all changes:\n   ```bash\n   git add -A\n   ```\n\n2. Commit with generated message (include Claude Code footer):\n   ```bash\n   git commit -m \"$(cat <<'EOF'\n   [Your commit message here]\n\n    Generated with [Claude Code](https://claude.com/claude-code)\n\n   Co-Authored-By: Claude <noreply@anthropic.com>\n   EOF\n   )\"\n   ```\n\n3. Check if on main/master and warn briefly, then push:\n   ```bash\n   git push\n   ```\n\n4. Report success:\n   ```\n    Committed and pushed: [short hash] [message summary]\n   ```\n\n### Safe Mode (`--safe`)\n\n1. Show the user what will be committed:\n   ```\n   Files to be committed:\n   - modified: file1.ts\n   - new file: file2.ts\n   - deleted: file3.ts\n   ```\n\n2. Present the proposed commit message:\n   ```\n   Proposed commit message:\n\n   feat: Add user authentication flow\n\n   Would you like to commit with this message?\n   ```\n\n3. Use AskUserQuestion to get approval or edits\n\n4. After commit, ask: \"Push to remote?\" before pushing\n\n## Important Guidelines\n\n- **Never force push** (`git push --force` is forbidden)\n- **Never skip hooks** (no `--no-verify`)\n- **Never amend** unless explicitly asked\n- If push fails (e.g., remote has new commits), inform the user and suggest `git pull --rebase`\n- If there are merge conflicts, stop and explain the situation\n",
        "js-refactor-logic/.claude-plugin/plugin.json": "{\n  \"name\": \"js-refactor-logic\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Refactor JavaScript logic: code splitting, design patterns, ES6+ modernization\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"javascript\", \"refactor\", \"clean-code\", \"es6\", \"design-patterns\"],\n  \"commands\": \"./commands\"\n}\n",
        "js-refactor-logic/README.md": "# JS Refactor Logic Plugin\n\nAutonomously refactor JavaScript code for improved readability, maintainability, and modern best practices.\n\n## Usage\n\n```\n/js-refactor-logic:refactor\n```\n\nAutomatically detects the currently open `.js` or `.jsx` file and applies refactoring.\n\n## What It Does\n\n### Code Splitting\n- Extracts functions > 50 lines into smaller pieces\n- Reduces nesting > 3 levels with guard clauses\n- Converts > 4 parameters to object pattern\n- Extracts duplicate code to utilities\n\n### Pattern Application\n| Problem | Solution |\n|---------|----------|\n| Callback hell | Async/await |\n| Deep nesting | Guard clauses |\n| Long switch | Strategy/lookup |\n| Magic values | Named constants |\n\n### ES6+ Modernization\n- `var`  `const`/`let`\n- `.then()`  `async`/`await`\n- Arrow functions where appropriate\n- Destructuring and spread operators\n\n### Error Handling\n- Adds try/catch to unhandled async code\n- Proper error propagation\n\n## Example\n\n**Before:**\n```javascript\nvar data = null;\nfunction processData(a, b, c, d, e) {\n  if (a) {\n    if (b) {\n      if (c) {\n        return fetch(url).then(function(res) {\n          return res.json();\n        }).then(function(json) {\n          data = json;\n        });\n      }\n    }\n  }\n}\n```\n\n**After:**\n```javascript\nconst data = ref(null);\n\nasync function processData({ a, b, c, d, e }) {\n  if (!a || !b || !c) return;\n\n  const response = await fetch(url);\n  data.value = await response.json();\n}\n```\n\n## Verification\n\nEvery refactoring ends with a mandatory checklist showing what was done.\n",
        "js-refactor-logic/commands/refactor.md": "---\ndescription: Refactor JavaScript logic - code splitting, patterns, ES6+ modernization\n---\n\nYou are a JavaScript refactoring assistant. Your task is to autonomously refactor JavaScript code for improved readability, maintainability, and modern best practices.\n\n## Step 1: Identify Target File\n\n1. Check if a `.js` or `.jsx` file is currently open in the editor\n2. If yes, use that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file is JavaScript (`.js` or `.jsx`)\n\n## Step 2: Analyze Code\n\nAnalyze the entire file for:\n\n### Code Splitting Issues\n- Functions exceeding 50 lines\n- Cyclomatic complexity > 10 (many conditionals/branches)\n- Nesting depth > 3 levels\n- Functions with > 4 parameters\n- Duplicate code patterns (2+ occurrences)\n\n### Anti-Patterns\n- Magic numbers/strings (unnamed constants)\n- Missing error handling in async code\n- Callback hell / Promise chains that could use async/await\n- Deep nesting instead of guard clauses\n- Long switch statements without abstraction\n\n### Modernization Opportunities\n- `var` declarations (should be `const`/`let`)\n- `.then()/.catch()` chains (should be async/await)\n- Old-style functions where arrow functions fit better\n- Missing destructuring opportunities\n- Missing spread operator usage\n\n## Step 3: Plan Refactoring\n\nFor each issue found, apply the appropriate resolution technique:\n\n---\n\n### Resolving High Cyclomatic Complexity (> 10)\n\n**Technique A: Extract Conditional Logic to Lookup Object**\n```javascript\n// BEFORE: complexity = 12\nfunction process(data) {\n  if (data.type === 'A') { /* 20 lines */ }\n  else if (data.type === 'B') { /* 20 lines */ }\n  else if (data.type === 'C') { /* 20 lines */ }\n}\n\n// AFTER: complexity = 3 per function\nconst processors = {\n  A: processTypeA,\n  B: processTypeB,\n  C: processTypeC\n}\nfunction process(data) {\n  return processors[data.type]?.(data)\n}\n```\n\n**Technique B: Strategy Pattern for Conditionals**\n```javascript\n// BEFORE\nfunction calculatePrice(item) {\n  if (item.type === 'book') return item.price * 0.9\n  if (item.type === 'electronics') return item.price * 1.1\n}\n\n// AFTER\nconst pricingStrategies = {\n  book: (item) => item.price * 0.9,\n  electronics: (item) => item.price * 1.1\n}\nconst calculatePrice = (item) => pricingStrategies[item.type](item)\n```\n\n**Technique C: Decompose Boolean Expressions**\n```javascript\n// BEFORE\nif (user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0) {}\n\n// AFTER\nconst isEligibleDriver = (user) =>\n  user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0\n\nif (isEligibleDriver(user)) {}\n```\n\n---\n\n### Resolving Deep Nesting (> 3 levels)\n\n**Technique A: Guard Clauses (Early Returns)**\n```javascript\n// BEFORE: 4 levels deep\nfunction process(data) {\n  if (data) {\n    if (data.isValid) {\n      if (data.items.length > 0) {\n        if (data.status === 'active') {\n          // actual logic\n        }\n      }\n    }\n  }\n}\n\n// AFTER: 0 levels deep\nfunction process(data) {\n  if (!data) return\n  if (!data.isValid) return\n  if (data.items.length === 0) return\n  if (data.status !== 'active') return\n\n  // actual logic\n}\n```\n\n**Technique B: Extract Nested Blocks**\n```javascript\n// BEFORE\nfunction handleOrder(order) {\n  if (order.isPaid) {\n    if (order.items.length > 0) {\n      for (const item of order.items) {\n        if (item.inStock) { /* complex */ }\n      }\n    }\n  }\n}\n\n// AFTER\nfunction handleOrder(order) {\n  if (!order.isPaid || order.items.length === 0) return\n  order.items.filter(item => item.inStock).forEach(processItem)\n}\n```\n\n**Technique C: Use Array Methods**\n```javascript\n// BEFORE: nested loops\nfor (const user of users) {\n  for (const order of user.orders) {\n    if (order.status === 'pending') { /* process */ }\n  }\n}\n\n// AFTER: flat\nusers\n  .flatMap(user => user.orders)\n  .filter(order => order.status === 'pending')\n  .forEach(processOrder)\n```\n\n---\n\n### Resolving Long Functions (> 50 lines)\n\n**Technique A: Extract by Responsibility**\n```javascript\n// BEFORE: 100 line function\nfunction submitForm(data) {\n  // validation (20 lines)\n  // formatting (15 lines)\n  // API call (25 lines)\n  // UI update (20 lines)\n}\n\n// AFTER: focused functions\nfunction submitForm(data) {\n  const errors = validateFormData(data)\n  if (errors.length) return handleErrors(errors)\n\n  const formatted = formatFormData(data)\n  const result = await sendToApi(formatted)\n  updateUI(result)\n}\n```\n\n**Technique B: Extract Setup/Teardown**\n```javascript\n// AFTER\nfunction processData() {\n  const context = setupProcessing()\n  try {\n    return executeProcessing(context)\n  } finally {\n    cleanupProcessing(context)\n  }\n}\n```\n\n---\n\n### Resolving Too Many Parameters (> 4)\n\n**Technique: Object Parameter Pattern**\n```javascript\n// BEFORE\nfunction createUser(name, email, age, role, department, manager, startDate) {}\n\n// AFTER\nfunction createUser({ name, email, age, role, department, manager, startDate }) {}\n\ncreateUser({ name: 'John', email: 'john@example.com', role: 'developer' })\n```\n\n---\n\n### Resolving Duplicate Code\n\n**Technique: Extract and Parameterize**\n```javascript\n// BEFORE: duplicated\nfunction fetchUsers() {\n  setLoading(true)\n  const data = await api.get('/users')\n  setLoading(false)\n  return data\n}\nfunction fetchProducts() {\n  setLoading(true)\n  const data = await api.get('/products')\n  setLoading(false)\n  return data\n}\n\n// AFTER: parameterized\nasync function fetchData(endpoint) {\n  setLoading(true)\n  try { return await api.get(endpoint) }\n  finally { setLoading(false) }\n}\nconst fetchUsers = () => fetchData('/users')\nconst fetchProducts = () => fetchData('/products')\n```\n\n---\n\n### File Extraction\nWhen extracting to new files, analyze the project structure:\n- Look for existing `utils/`, `helpers/`, `lib/` folders\n- If none exist, propose creating in appropriate location\n- Keep related utilities together\n\n## Step 4: Apply Changes\n\nApply all refactoring changes:\n\n1. Extract long functions into smaller pieces\n2. Apply guard clauses to reduce nesting\n3. Convert var to const/let\n4. Convert Promise chains to async/await\n5. Extract magic values to named constants\n6. Add try/catch for unhandled async errors\n7. Create new utility files if needed\n8. Update imports as needed\n\n## Step 5: Report Completion\n\nReport all changes made:\n```\nRefactored: filename.js\n\nChanges applied:\n- Extracted 3 functions from processData (was 120 lines)\n- Converted 5 var declarations to const/let\n- Refactored 2 Promise chains to async/await\n- Added error handling to fetchUser()\n- Extracted magic numbers to constants: MAX_RETRIES, TIMEOUT_MS\n- Created utils/dataHelpers.js with 2 utility functions\n\nNew files created:\n- utils/dataHelpers.js\n```\n\n## Verification Checklist (MANDATORY)\n\n**You MUST complete and display this checklist. The refactoring is NOT complete until shown.**\n\n### Analysis\n- [ ] Target .js/.jsx file identified\n- [ ] Code analyzed for complexity metrics\n- [ ] Anti-patterns identified\n- [ ] Modernization opportunities found\n\n### Code Splitting\n- [ ] Functions > 50 lines: addressed or N/A\n- [ ] Nesting > 3 levels: addressed or N/A\n- [ ] Complexity > 10: addressed or N/A\n- [ ] Parameters > 4: addressed or N/A\n- [ ] Duplicate code: extracted or N/A\n\n### Patterns & Modernization\n- [ ] Guard clauses applied where beneficial\n- [ ] var converted to const/let\n- [ ] Promise chains converted to async/await\n- [ ] Magic values extracted to constants\n- [ ] Error handling added where needed\n\n### File Organization\n- [ ] New files created in appropriate locations\n- [ ] Imports updated correctly\n\n### Completion\n- [ ] All changes applied successfully\n- [ ] Summary reported\n- [ ] This checklist displayed with [x] marks\n\n**Example output:**\n```\nVerification Checklist:\n[x] Target file: src/utils/dataProcessor.js\n[x] Code analyzed\n[x] Anti-patterns found: 3\n[x] Functions > 50 lines: 2 extracted\n[x] Nesting > 3 levels: 1 fixed with guard clauses\n[ ] Complexity > 10: N/A (none found)\n[x] var  const/let: 8 converted\n[x] Promise  async/await: 2 converted\n[x] Error handling added: 1 function\n[x] Changes applied successfully\n```\n\n## Important Guidelines\n\n- **Preserve functionality**: Never change logic, only structure\n- **Preserve tests**: If tests exist, ensure they still pass\n- **Be conservative**: Only refactor clear improvements\n- **Naming matters**: Use descriptive function/variable names\n- **No over-engineering**: Don't add unnecessary abstractions\n",
        "ncsc-security-audit/.claude-plugin/plugin.json": "{\n  \"name\": \"ncsc-security-audit\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Multi-agent NCSC ICT-beveiligingsrichtlijnen voor webapplicaties audit met technische en stakeholder rapporten\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"security\", \"ncsc\", \"audit\", \"vulnerability\", \"multi-agent\"],\n  \"commands\": \"./commands\"\n}\n",
        "ncsc-security-audit/README.md": "# NCSC Security Audit Plugin\n\nMulti-agent NCSC ICT-beveiligingsrichtlijnen voor webapplicaties audit voor Claude Code. Produceert zowel technische als stakeholder-vriendelijke rapporten.\n\n## Features\n\n- **Multi-agent architectuur**: Drie gespecialiseerde agents werken samen voor uitgebreide analyse\n- **Solution-aware**: Bepaalt automatisch welke NCSC richtlijnen relevant zijn op basis van solutietype\n- **Dual reporting**: Genereert zowel technische ontwikkelaarsrapporten als niet-technische stakeholder samenvattingen\n- **Iteratieve validatie**: Elke richtlijn wordt geanalyseerd en kruisgevalideerd voordat naar de volgende wordt gegaan\n- **Nederlandse standaard**: Gebaseerd op de officile NCSC richtlijnen (Juli 2024)\n\n## Usage\n\n```\n/ncsc-security-audit\n```\n\nThe command will first ask you to select a report language. English is the default, but you can specify any language supported by the LLM (Dutch, German, French, Spanish, Japanese, etc.).\n\n## How It Works\n\n### Fase 1: Discovery\n\nDe **Discovery Agent** analyseert de codebase om te bepalen:\n- Solutietype (frontend, backend, full-stack, API, library)\n- Gebruikte technologien\n- Welke van de 26 NCSC richtlijnen relevant zijn\n\nBijvoorbeeld, een frontend-only applicatie wordt niet geaudit op SSRF (U/WA.07) omdat er geen server-side requests zijn.\n\n### Fase 2: Richtlijn Analyse\n\nVoor elke relevante richtlijn werken twee agents parallel:\n\n1. **Security Analyst Agent**: Diepgaande code-analyse op zoek naar kwetsbaarheden\n2. **Verification Agent**: Kruisvalidatie van bevindingen en controle op gemiste issues\n\nDe agents bouwen consensus over bevindingen voordat ze doorgaan naar de volgende richtlijn.\n\n### Fase 3: Rapport Generatie\n\nTwee rapporten worden gegenereerd in `security-reports/`:\n\n| Rapport | Doelgroep | Inhoud |\n|---------|-----------|--------|\n| `ncsc-audit-technical.md` | Ontwikkelaars | Code-locaties, remediatiestappen, PoC details |\n| `ncsc-audit-summary.md` | Stakeholders | Begrijpelijke taal, zakelijke impact, prioriteiten |\n\n## NCSC Richtlijnen Dekking\n\n### U/TV - Toegangsvoorzieningsmiddelen\n\n| ID | Richtlijn | Beschrijving |\n|----|-----------|--------------|\n| U/TV.01 | Authenticatie | Gebruikersauthenticatie en identiteitsvaststelling |\n\n### U/WA - Webapplicaties\n\n| ID | Richtlijn | Beschrijving |\n|----|-----------|--------------|\n| U/WA.01 | Sessiemanagement | Server-side sessiebeheer |\n| U/WA.02 | Invoervalidatie | Server-side validatie van alle invoer |\n| U/WA.03 | Uitvoerbeveiliging | XSS-preventie, CSP |\n| U/WA.04 | SQL/NoSQL-injectie | Parameterized queries |\n| U/WA.05 | OS command injection | Shell command beveiliging |\n| U/WA.06 | Path traversal | Bestandstoegang beveiliging |\n| U/WA.07 | SSRF | Server-side request forgery preventie |\n| U/WA.08 | CSRF | Cross-site request forgery bescherming |\n| U/WA.09 | API-beveiliging | API authenticatie en autorisatie |\n\n### U/PW - Platformen en Webservers\n\n| ID | Richtlijn | Beschrijving |\n|----|-----------|--------------|\n| U/PW.01 | HTTPS/TLS | TLS configuratie |\n| U/PW.02 | Security headers | HTTP security headers |\n| U/PW.03 | Foutafhandeling | Geen gevoelige info in errors |\n| U/PW.04 | Logging | Security event logging |\n| U/PW.05 | Server hardening | Server configuratie |\n| U/PW.06 | Bestandsbeheer | Veilige file uploads |\n| U/PW.07 | Dependencies | Dependency management |\n| U/PW.08 | Secrets management | Veilig secrets beheer |\n\n### U/NW - Netwerken\n\n| ID | Richtlijn | Beschrijving |\n|----|-----------|--------------|\n| U/NW.01 | Netwerksegmentatie | Scheiding van componenten |\n| U/NW.02 | WAF/Reverse proxy | Extra beschermingslaag |\n| U/NW.03 | DNS-beveiliging | DNSSEC, CAA records |\n| U/NW.04 | Ingress/Egress filtering | Verkeersfiltering |\n| U/NW.05 | Load balancing | Beschikbaarheid |\n| U/NW.06 | Service mesh | mTLS voor microservices |\n| U/NW.07 | API Gateway | Centrale security controls |\n| U/NW.08 | Container security | Container netwerkbeveiliging |\n\n## Solution Type Matrix\n\nNiet alle richtlijnen zijn van toepassing op alle solutietypes:\n\n| Richtlijn | Frontend | Backend | Full-Stack | Library |\n|-----------|----------|---------|------------|---------|\n| U/TV.01 | Partial | Full | Full | N/A |\n| U/WA.01-09 | Varies | Full | Full | Depends |\n| U/PW.01-08 | Limited | Full | Full | Partial |\n| U/NW.01-08 | N/A | Full | Full | N/A |\n\n## Prioriteit Levels\n\nDe NCSC richtlijnen kennen drie prioriteitsniveaus:\n\n| Prioriteit | Beschrijving | Actie |\n|------------|--------------|-------|\n| **Hoog** | Fundamentele beveiligingsmaatregel | Direct implementeren |\n| **Midden** | Belangrijke verbetering | Plannen binnen 30 dagen |\n| **Laag** | Best practice | Opnemen in roadmap |\n\n## Report Structure\n\n### Technisch Rapport\n\n```\n# NCSC ICT-Beveiligingsrichtlijnen Audit - Technisch Rapport\n\n## Executive Summary\n- Bevindingen per ernst\n\n## Quick Reference Matrix\n- Per-richtlijn status overzicht\n\n## Gedetailleerde Bevindingen\n- Per richtlijn:\n  - Bevinding details met code-locaties\n  - Aanvalsvectoren en PoC\n  - Remediation code voorbeelden\n  - Gemplementeerde controls\n\n## Prioriteringsmatrix Remediatie\n- Geprioriteerde fix lijst\n\n## Appendix\n- Geanalyseerde bestanden\n- Gebruikte zoekpatronen\n- Agent consensus notities\n- NCSC naar OWASP/ASVS mapping\n```\n\n### Stakeholder Rapport\n\n```\n# Beveiligingsbeoordeling Samenvatting\n\n## Overzicht\n- Begrijpelijke beoordeling status\n\n## Risico Samenvatting\n- Zakelijke impact per ernst\n\n## Compliance Overzicht\n- Richtlijn status met uitleg\n\n## Belangrijkste Bevindingen\n- Niet-technische uitleg\n- Zakelijke impact\n- Aanbevolen acties\n\n## Wat Goed Gaat\n- Positieve beveiligingspraktijken\n\n## Aanbevolen Acties\n- Direct / Korte termijn / Lange termijn\n\n## Volgende Stappen\n- Actieplan\n```\n\n## Requirements\n\n- Claude Code CLI\n- Toegang om projectbestanden te lezen\n\n## Installation\n\nVoeg deze plugin toe aan je Claude Code configuratie:\n\n```bash\nclaude plugins add ncsc-security-audit\n```\n\nOf refereer naar de marketplace:\n\n```bash\nclaude plugins add github:SSiertsema/claude-code-plugins/ncsc-security-audit\n```\n\n## Output Location\n\nRapporten worden gegenereerd in de `security-reports/` directory:\n\n```\nyour-project/\n security-reports/\n    ncsc-audit-technical.md\n    ncsc-audit-summary.md\n```\n\n## Customization\n\nDe plugin gebruikt templates in `templates/` die aangepast kunnen worden:\n\n- `ncsc-guidelines.md` - NCSC referentie en zoekpatronen\n- `technical-report.md` - Ontwikkelaar rapport template\n- `stakeholder-report.md` - Samenvatting rapport template\n\n## Cross-Standard Mapping\n\nDe NCSC richtlijnen zijn gekoppeld aan andere standaarden via OpenCRE:\n\n| NCSC | OWASP Top 10 | ASVS | ISO 27001 |\n|------|--------------|------|-----------|\n| U/TV.01 | A07 | V2, V3 | A.9 |\n| U/WA.02-05 | A03 | V5 | A.14 |\n| U/WA.07 | A10 | V11 | A.14 |\n| U/PW.01 | A02 | V9 | A.10 |\n| U/PW.07 | A06 | V14 | A.12 |\n\n## Compliance Context\n\nDeze plugin ondersteunt compliance met:\n\n- **AVG/GDPR** - Europese privacywetgeving\n- **BIO** - Baseline Informatiebeveiliging Overheid\n- **NIS2** - Europese cybersecurity richtlijn\n- **Wbni** - Wet beveiliging netwerk- en informatiesystemen\n\n## License\n\nMIT\n",
        "ncsc-security-audit/commands/ncsc-security-audit.md": "---\ndescription: Generate NCSC ICT-beveiligingsrichtlijnen security audit with technical and stakeholder reports\n---\n\n# NCSC ICT-Beveiligingsrichtlijnen Security Audit\n\nYou are initiating a multi-agent security audit based on the **NCSC ICT-beveiligingsrichtlijnen voor webapplicaties (Juli 2024)**. This audit will produce two reports: a technical report for developers and a non-technical summary for stakeholders.\n\n## Phase 0: Language Selection\n\n**IMPORTANT: Before starting the audit, ask the user which language they prefer for the reports.**\n\nUse the AskUserQuestion tool to ask:\n\n```\nQuestion: \"In which language should the security reports be generated?\"\nOptions:\n- English (default)\n- Other (please specify)\n```\n\nIf the user selects \"Other\", they can specify any language supported by the LLM (e.g., German, French, Spanish, Japanese, Chinese, etc.).\n\nStore the selected language and use it for:\n- All report content and headings\n- Finding descriptions and recommendations\n- Stakeholder-friendly explanations\n\n**Language Guidelines:**\n- Keep technical security terms in English (XSS, CSRF, SQL injection, SSRF, etc.) regardless of report language\n- Translate explanations, descriptions, and recommendations to the selected language\n- Reference NCSC guidelines with their original Dutch IDs (U/TV.01, U/WA.01, etc.) regardless of language\n- Adapt compliance references to the user's context where relevant\n\n## Reference Documents\n\nBefore proceeding, read the guidelines reference:\n- `templates/ncsc-guidelines.md` - Full NCSC guidelines with search patterns\n\n## Phase 1: Discovery\n\n> **Note:** From this point forward, all agent outputs and reports should be in the user's selected language.\n\n### Discovery Agent Task\n\nLaunch a **Discovery Agent** to analyze the solution and determine:\n\n1. **Solution Type Classification**\n   - Frontend-only (SPA, static site)\n   - Backend-only (API, microservice)\n   - Full-stack (frontend + backend)\n   - Library/Package\n\n2. **Technology Stack Detection**\n   - Programming languages\n   - Frameworks (Vue, React, Express, Django, etc.)\n   - Databases\n   - Authentication mechanisms\n   - External integrations\n\n3. **Guideline Relevance Matrix**\n\n   Based on solution type, determine which NCSC domains and guidelines apply:\n\n   | Domain | Description | Frontend | Backend | Full-Stack | Library |\n   |--------|-------------|----------|---------|------------|---------|\n   | U/TV | Toegangsvoorzieningsmiddelen | Partial | Full | Full | N/A |\n   | U/WA | Webapplicaties | Full | Full | Full | Partial |\n   | U/PW | Platformen en webservers | N/A | Full | Full | N/A |\n   | U/NW | Netwerken | N/A | Full | Full | N/A |\n\n**Output Required:**\n```markdown\n## Discovery Report\n\n### Solution Type: [TYPE]\n\n### Technologies Detected:\n- [LIST]\n\n### Applicable Guidelines:\n| ID | Guideline | Relevance | Reason |\n|----|-----------|-----------|--------|\n| U/TV.01 | ... | Full/Partial/N/A | ... |\n| U/WA.01 | ... | Full/Partial/N/A | ... |\n...\n```\n\n## Phase 2: Guideline-by-Guideline Analysis\n\nFor each applicable guideline, launch TWO agents in parallel:\n\n### Security Analyst Agent\n\nDeep-dive analysis for each guideline:\n\n1. **Search Phase**\n   - Use the search patterns from `templates/ncsc-guidelines.md`\n   - Identify all relevant code locations\n   - Document file paths and line numbers\n\n2. **Analysis Phase**\n   - Evaluate implementation against NCSC requirements\n   - Identify vulnerabilities or gaps\n   - Assess severity (Kritiek/Hoog/Midden/Laag)\n   - Document evidence with code snippets\n\n3. **Recommendation Phase**\n   - Provide specific remediation steps\n   - Include code examples where applicable\n   - Reference NCSC measure numbers\n\n### Verification Agent\n\nCross-validate the Security Analyst's findings:\n\n1. **Verification Phase**\n   - Review analyst findings for accuracy\n   - Check for false positives\n   - Identify any missed vulnerabilities\n\n2. **Consensus Building**\n   - Confirm or dispute each finding\n   - Add additional context if needed\n   - Agree on final severity rating\n\n### Iteration Protocol\n\nFor each guideline:\n\n1. Both agents analyze independently\n2. Compare findings\n3. Build consensus on:\n   - Confirmed vulnerabilities\n   - Severity ratings\n   - Remediation priorities\n4. Document consensus before proceeding to next guideline\n\n**Progress Tracking:**\n```markdown\n## Guideline Progress\n\n| ID | Analyst | Verifier | Consensus | Status |\n|----|---------|----------|-----------|--------|\n| U/TV.01 |  |  |  | Complete |\n| U/WA.01 |  |  | In Progress | ... |\n```\n\n## Phase 3: Report Generation\n\nAfter all applicable guidelines are analyzed, generate two reports:\n\n### Technical Report (`security-reports/ncsc-audit-technical.md`)\n\nUse template: `templates/technical-report.md`\n\nContent:\n1. Executive Summary with finding counts\n2. Quick Reference Matrix (all guidelines)\n3. Detailed Findings per guideline:\n   - Finding ID and severity\n   - Code location (file:line)\n   - Evidence (code snippets)\n   - Attack vector description\n   - Remediation code examples\n   - NCSC measure references\n4. Implemented Controls (positive findings)\n5. Remediation Priority Matrix\n6. Appendix with search patterns used\n\n### Stakeholder Report (`security-reports/ncsc-audit-summary.md`)\n\nUse template: `templates/stakeholder-report.md`\n\nContent:\n1. Plain language overview\n2. Risk summary (Critical/High/Medium/Low counts)\n3. Compliance status per security domain\n4. Key findings in non-technical language:\n   - What the issue means\n   - Business impact\n   - Recommended action\n5. What's working well (positive security practices)\n6. Prioritized action items:\n   - Immediate (this week)\n   - Short-term (30 days)\n   - Long-term (90 days)\n7. FAQ section\n\n## Execution Instructions\n\n1. **Start Discovery Phase**\n   ```\n   Launch Discovery Agent with prompt:\n   \"Analyze this codebase to determine solution type, technologies,\n   and which NCSC guidelines (U/TV, U/WA, U/PW, U/NW) are applicable.\n   Reference templates/ncsc-guidelines.md for the full guideline list.\"\n   ```\n\n2. **Execute Guideline Analysis**\n   For each applicable guideline, launch parallel agents:\n   ```\n   Security Analyst: \"Analyze [GUIDELINE_ID]: [GUIDELINE_NAME] using\n   search patterns from templates/ncsc-guidelines.md. Document all\n   findings with file:line locations and severity ratings.\"\n\n   Verification Agent: \"Verify findings for [GUIDELINE_ID]. Check for\n   false positives and missed vulnerabilities. Build consensus with\n   the Security Analyst.\"\n   ```\n\n3. **Generate Reports**\n   ```\n   Create security-reports/ directory if it doesn't exist.\n   Generate both reports using the templates.\n   ```\n\n## Quality Checklist\n\nBefore completing the audit:\n\n- [ ] All applicable guidelines analyzed\n- [ ] Consensus reached on all findings\n- [ ] Technical report includes code locations\n- [ ] Stakeholder report uses plain language\n- [ ] Both reports saved to security-reports/\n- [ ] Priority matrix is actionable\n\n## Notes\n\n- Focus on the NCSC priority levels: Hoog, Midden, Laag\n- Reference OpenCRE mappings where applicable for cross-standard alignment\n- Consider Dutch compliance context (AVG/GDPR, BIO)\n- The NCSC guidelines are specifically designed for Dutch government and critical infrastructure\n",
        "owasp-security-audit/.claude-plugin/plugin.json": "{\n  \"name\": \"owasp-security-audit\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Multi-agent OWASP Top 10 security audit with technical and stakeholder reports\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"security\", \"owasp\", \"audit\", \"vulnerability\", \"multi-agent\"],\n  \"commands\": \"./commands\"\n}\n",
        "owasp-security-audit/README.md": "# OWASP Security Audit Plugin\n\nMulti-agent OWASP Top 10 security audit for Claude Code that produces both technical and stakeholder-friendly reports.\n\n## Features\n\n- **Multi-agent architecture**: Three specialized agents collaborate for comprehensive analysis\n- **Solution-aware**: Automatically determines which OWASP guidelines are relevant based on your solution type\n- **Dual reporting**: Generates both technical developer reports and non-technical stakeholder summaries\n- **Iterative validation**: Each guideline is analyzed and cross-validated before proceeding\n\n## Usage\n\n```\n/owasp-security-audit\n```\n\nThe command will first ask you to select a report language. English is the default, but you can specify any language supported by the LLM (Dutch, German, French, Spanish, Japanese, etc.).\n\n## How It Works\n\n### Phase 1: Discovery\n\nThe **Discovery Agent** analyzes your codebase to determine:\n- Solution type (frontend, backend, full-stack, API, library)\n- Technologies in use\n- Which of the 10 OWASP guidelines are relevant\n\nFor example, a frontend-only application won't be audited for SSRF (A10) since there are no server-side requests.\n\n### Phase 2: Guideline Analysis\n\nFor each relevant guideline, two agents work in parallel:\n\n1. **Security Analyst Agent**: Deep-dives into code searching for vulnerabilities\n2. **Verification Agent**: Cross-validates findings and checks for missed issues\n\nThe agents build consensus on findings before proceeding to the next guideline.\n\n### Phase 3: Report Generation\n\nTwo reports are generated in `security-reports/`:\n\n| Report | Audience | Content |\n|--------|----------|---------|\n| `owasp-audit-technical.md` | Developers | Code locations, remediation steps, PoC details |\n| `owasp-audit-summary.md` | Stakeholders | Plain language explanations, business impact, priorities |\n\n## OWASP Top 10 Coverage\n\n| ID | Guideline | Description |\n|----|-----------|-------------|\n| A01 | Broken Access Control | Authorization bypass, IDOR, privilege escalation |\n| A02 | Cryptographic Failures | Weak encryption, exposed secrets, missing HTTPS |\n| A03 | Injection | SQL, NoSQL, XSS, command injection |\n| A04 | Insecure Design | Missing security controls, threat modeling gaps |\n| A05 | Security Misconfiguration | Debug enabled, default credentials, missing headers |\n| A06 | Vulnerable Components | Outdated dependencies, known CVEs |\n| A07 | Authentication Failures | Weak auth, session issues, credential stuffing |\n| A08 | Software/Data Integrity | Insecure CI/CD, unsigned updates, deserialization |\n| A09 | Logging Failures | Missing audit logs, no alerting |\n| A10 | SSRF | Server-side request forgery via user input |\n\n## Solution Type Matrix\n\nNot all guidelines apply to all solution types:\n\n| Guideline | Frontend | Backend | Full-Stack | API | Library |\n|-----------|----------|---------|------------|-----|---------|\n| A01 | Partial | Full | Full | Full | Partial |\n| A02 | Limited | Full | Full | Full | Depends |\n| A03 | XSS | Full | Full | Full | Depends |\n| A04 | Full | Full | Full | Full | Full |\n| A05 | Headers | Full | Full | Full | Build |\n| A06 | Full | Full | Full | Full | Full |\n| A07 | Tokens | Full | Full | Full | N/A |\n| A08 | CDN/SRI | Full | Full | Full | Full |\n| A09 | Client | Full | Full | Full | Limited |\n| A10 | N/A | Full | Full | Full | Depends |\n\n## Report Structure\n\n### Technical Report\n\n```\n# OWASP Top 10 Security Audit - Technical Report\n\n## Executive Summary\n- Finding counts by severity\n- Overall status\n\n## Quick Reference Matrix\n- Per-guideline status overview\n\n## Detailed Findings\n- Per guideline:\n  - Finding details with code locations\n  - Attack vectors and PoC\n  - Remediation code examples\n  - Implemented controls\n\n## Remediation Priority Matrix\n- Prioritized fix list\n\n## Appendix\n- Files analyzed\n- Search patterns used\n- Agent consensus notes\n```\n\n### Stakeholder Report\n\n```\n# Security Assessment Summary\n\n## Overview\n- Plain language assessment status\n\n## Risk Summary\n- Business impact per severity\n\n## Compliance Overview\n- Guideline status with explanations\n\n## Key Findings\n- Non-technical explanations\n- Business impact\n- Recommended actions\n\n## What's Working Well\n- Positive security practices\n\n## Recommended Actions\n- Immediate / Short-term / Long-term\n\n## Next Steps\n- Action plan\n```\n\n## Requirements\n\n- Claude Code CLI\n- Access to read project files\n\n## Installation\n\nAdd this plugin to your Claude Code configuration:\n\n```bash\nclaude plugins add owasp-security-audit\n```\n\nOr reference the marketplace:\n\n```bash\nclaude plugins add github:SSiertsema/claude-code-plugins/owasp-security-audit\n```\n\n## Output Location\n\nReports are generated in the `security-reports/` directory:\n\n```\nyour-project/\n security-reports/\n    owasp-audit-technical.md\n    owasp-audit-summary.md\n```\n\n## Customization\n\nThe plugin uses templates in `templates/` that can be customized:\n\n- `owasp-guidelines.md` - OWASP reference and search patterns\n- `technical-report.md` - Developer report template\n- `stakeholder-report.md` - Summary report template\n\n## License\n\nMIT\n",
        "owasp-security-audit/commands/owasp-security-audit.md": "---\ndescription: Generate OWASP Top 10 security audit report using multi-agent analysis\n---\n\n# OWASP Security Audit - Multi-Agent Workflow\n\nYou are orchestrating a comprehensive OWASP Top 10 security audit using three specialized agents working collaboratively. This audit produces both a technical report for developers and a non-technical summary for stakeholders.\n\n## Phase 0: Language Selection\n\n**IMPORTANT: Before starting the audit, ask the user which language they prefer for the reports.**\n\nUse the AskUserQuestion tool to ask:\n\n```\nQuestion: \"In which language should the security reports be generated?\"\nOptions:\n- English (default)\n- Other (please specify)\n```\n\nIf the user selects \"Other\", they can specify any language supported by the LLM (e.g., German, French, Spanish, Dutch, Japanese, Chinese, etc.).\n\nStore the selected language and use it for:\n- All report content and headings\n- Finding descriptions and recommendations\n- Stakeholder-friendly explanations\n\n**Language Guidelines:**\n- Keep technical security terms in English (XSS, CSRF, SQL injection, SSRF, etc.) regardless of report language\n- Translate explanations, descriptions, and recommendations to the selected language\n- Reference OWASP guidelines with their original IDs (A01, A02, etc.) regardless of language\n- Adapt compliance references to the user's context where relevant (e.g., GDPR, HIPAA, etc.)\n\n## Overview\n\nThis command triggers a 3-agent collaborative security audit:\n1. **Discovery Agent** - Analyzes solution type and determines relevant OWASP guidelines\n2. **Security Analyst Agent** - Deep-dives into code to identify vulnerabilities\n3. **Verification Agent** - Cross-validates findings and ensures completeness\n\nThe agents work iteratively, guideline by guideline, building consensus before proceeding.\n\n---\n\n## Phase 1: Solution Discovery\n\n> **Note:** From this point forward, all agent outputs and reports should be in the user's selected language.\n\n**Use the Task tool** to spawn the Discovery Agent with this prompt:\n\n```\nYou are the DISCOVERY AGENT for an OWASP security audit.\n\n## Your Mission\nAnalyze this codebase to determine:\n1. What type of solution is this? (frontend-only, backend-only, full-stack, API, CLI tool, library, etc.)\n2. What technologies/frameworks are used?\n3. What OWASP Top 10 guidelines are RELEVANT based on this solution type?\n\n## Solution Type Determination\n\nAnalyze the codebase to identify:\n- Package files (package.json, requirements.txt, go.mod, Cargo.toml, pom.xml, etc.)\n- Framework indicators (Next.js, Nuxt, Django, Express, FastAPI, Spring, etc.)\n- Architecture patterns (SPA, SSR, API-only, microservices, monolith)\n- Data handling (database connections, ORM usage, external APIs)\n- Authentication mechanisms\n- Deployment configuration\n\n## Relevance Matrix\n\nBased on solution type, determine which OWASP guidelines apply:\n\n| Guideline | Frontend-Only | Backend-Only | Full-Stack | API | Library |\n|-----------|---------------|--------------|------------|-----|---------|\n| A01: Broken Access Control | Partial | Full | Full | Full | Partial |\n| A02: Cryptographic Failures | Limited | Full | Full | Full | Depends |\n| A03: Injection | XSS focus | Full | Full | Full | Depends |\n| A04: Insecure Design | Full | Full | Full | Full | Full |\n| A05: Security Misconfiguration | Headers/CSP | Full | Full | Full | Build config |\n| A06: Vulnerable Components | Full | Full | Full | Full | Full |\n| A07: Authentication Failures | Token handling | Full | Full | Full | N/A |\n| A08: Software/Data Integrity | Build/CDN | Full | Full | Full | Full |\n| A09: Logging Failures | Client logs | Full | Full | Full | Limited |\n| A10: SSRF | N/A | Full | Full | Full | Depends |\n\n## Output Format\n\nReturn a JSON report:\n{\n  \"solution_type\": \"frontend-only | backend-only | full-stack | api | library | other\",\n  \"technologies\": {\n    \"languages\": [\"TypeScript\", \"Python\", etc.],\n    \"frameworks\": [\"Vue 3\", \"Nuxt 3\", \"Express\", etc.],\n    \"databases\": [\"PostgreSQL\", \"MongoDB\", etc.],\n    \"auth\": [\"Azure AD\", \"JWT\", \"OAuth\", etc.],\n    \"deployment\": [\"Docker\", \"Azure\", \"Vercel\", etc.]\n  },\n  \"relevant_guidelines\": [\n    {\n      \"id\": \"A01\",\n      \"name\": \"Broken Access Control\",\n      \"relevance\": \"full | partial | limited | n/a\",\n      \"reason\": \"Why this guideline applies or doesn't apply\",\n      \"focus_areas\": [\"specific areas to check for this solution type\"]\n    }\n  ],\n  \"excluded_guidelines\": [\n    {\n      \"id\": \"A10\",\n      \"name\": \"SSRF\",\n      \"reason\": \"Frontend-only solution does not make server-side requests\"\n    }\n  ],\n  \"key_files_to_analyze\": [\n    \"path/to/auth/handler.ts\",\n    \"path/to/api/routes.ts\"\n  ]\n}\n```\n\n**Wait for the Discovery Agent to complete and capture its output.**\n\n---\n\n## Phase 2: Guideline-by-Guideline Analysis\n\nFor each relevant guideline identified in Phase 1, spawn **two agents in parallel**:\n\n### Security Analyst Agent\n\n```\nYou are the SECURITY ANALYST AGENT auditing for OWASP [GUIDELINE_ID]: [GUIDELINE_NAME].\n\n## Context\nSolution type: [SOLUTION_TYPE]\nTechnologies: [TECHNOLOGIES]\nFocus areas: [FOCUS_AREAS from Discovery Agent]\n\n## Guideline Details\n[Insert relevant section from the OWASP guidelines reference]\n\n## Your Mission\n\nThoroughly analyze the codebase for vulnerabilities related to [GUIDELINE_NAME]:\n\n1. **Search for relevant code patterns**\n   - Use Grep to find security-sensitive patterns\n   - Read configuration files\n   - Analyze authentication/authorization code\n   - Check input validation\n   - Review data handling\n\n2. **Check against prevention measures**\n   For each prevention measure in the guideline:\n   - Is it implemented? (yes/no/partial/n/a)\n   - Where is it implemented? (file:line)\n   - Are there gaps or weaknesses?\n\n3. **Identify vulnerabilities**\n   - What could an attacker exploit?\n   - What is the severity? (Critical/High/Medium/Low/Info)\n   - What is the attack vector?\n\n## Output Format\n\n{\n  \"guideline_id\": \"[GUIDELINE_ID]\",\n  \"guideline_name\": \"[GUIDELINE_NAME]\",\n  \"status\": \"pass | fail | partial | needs_attention\",\n  \"findings\": [\n    {\n      \"id\": \"F001\",\n      \"title\": \"Brief description\",\n      \"severity\": \"critical | high | medium | low | info\",\n      \"location\": \"file/path.ts:123\",\n      \"description\": \"Detailed explanation of the issue\",\n      \"evidence\": \"Code snippet or configuration showing the issue\",\n      \"attack_vector\": \"How this could be exploited\",\n      \"recommendation\": \"How to fix this\",\n      \"effort\": \"low | medium | high\"\n    }\n  ],\n  \"implemented_controls\": [\n    {\n      \"control\": \"Prevention measure from guideline\",\n      \"status\": \"implemented | partial | missing\",\n      \"location\": \"file/path.ts:45\",\n      \"notes\": \"Additional context\"\n    }\n  ],\n  \"positive_observations\": [\n    \"Good security practices already in place\"\n  ]\n}\n```\n\n### Verification Agent\n\n```\nYou are the VERIFICATION AGENT cross-checking the security analysis for OWASP [GUIDELINE_ID]: [GUIDELINE_NAME].\n\n## Context\nSolution type: [SOLUTION_TYPE]\nTechnologies: [TECHNOLOGIES]\n\n## Your Mission\n\nIndependently verify security posture for [GUIDELINE_NAME]:\n\n1. **Alternative search patterns**\n   - Search for patterns the Security Analyst might have missed\n   - Check edge cases and less obvious code paths\n   - Look for security anti-patterns\n\n2. **False positive check**\n   - Verify that reported issues are actually exploitable\n   - Check if there are compensating controls\n\n3. **Coverage verification**\n   - Are all relevant files checked?\n   - Are all entry points analyzed?\n   - Are third-party integrations reviewed?\n\n## Output Format\n\n{\n  \"guideline_id\": \"[GUIDELINE_ID]\",\n  \"verification_status\": \"confirmed | disputed | extended\",\n  \"additional_findings\": [\n    {\n      \"id\": \"V001\",\n      \"title\": \"Additional finding not in initial analysis\",\n      \"severity\": \"critical | high | medium | low | info\",\n      \"location\": \"file/path.ts:456\",\n      \"description\": \"What was missed and why\"\n    }\n  ],\n  \"disputed_findings\": [\n    {\n      \"original_id\": \"F001\",\n      \"dispute_reason\": \"Why this might be a false positive\",\n      \"evidence\": \"Compensating control or safe implementation\"\n    }\n  ],\n  \"coverage_gaps\": [\n    \"Areas that need more analysis\"\n  ],\n  \"confidence_level\": \"high | medium | low\"\n}\n```\n\n### Consensus Building\n\nAfter both agents complete for a guideline:\n1. Compare findings\n2. Resolve disputes\n3. Merge additional findings\n4. Document consensus\n5. Proceed to next guideline\n\n---\n\n## Phase 3: Report Generation\n\nAfter all guidelines are analyzed, compile two reports:\n\n### Technical Report (for developers)\n\nCreate file: `security-reports/owasp-audit-technical.md`\n\nStructure:\n```markdown\n# OWASP Top 10 Security Audit - Technical Report\n\n**Generated:** [DATE]\n**Solution:** [SOLUTION_TYPE]\n**Scope:** [RELEVANT_GUIDELINES_COUNT] of 10 OWASP guidelines applicable\n\n## Executive Summary\n\n- **Critical Findings:** X\n- **High Findings:** X\n- **Medium Findings:** X\n- **Low Findings:** X\n- **Overall Status:** [PASS/FAIL/NEEDS_ATTENTION]\n\n## Quick Reference\n\n| Guideline | Status | Critical | High | Medium | Low |\n|-----------|--------|----------|------|--------|-----|\n| A01: Broken Access Control | PASS/FAIL | 0 | 1 | 2 | 0 |\n...\n\n## Detailed Findings\n\n### A01: Broken Access Control\n\n**Status:** [STATUS]\n\n#### Finding F001: [Title]\n\n- **Severity:** High\n- **Location:** `src/auth/handler.ts:123`\n- **Description:** [Detailed technical description]\n- **Evidence:**\n  ```typescript\n  // Vulnerable code\n  ```\n- **Attack Vector:** [How to exploit]\n- **Recommendation:** [How to fix with code example]\n- **Effort:** Medium\n\n#### Implemented Controls\n\n| Control | Status | Location |\n|---------|--------|----------|\n| Bearer token validation | Implemented | auth/middleware.ts:45 |\n\n...\n\n## Remediation Priority Matrix\n\n| Priority | Finding | Effort | Impact |\n|----------|---------|--------|--------|\n| 1 | F003: SQL Injection | Low | Critical |\n| 2 | F001: Missing RBAC | Medium | High |\n\n## Appendix: Files Analyzed\n\n- src/auth/*.ts\n- src/api/*.ts\n...\n```\n\n### Non-Technical Report (for stakeholders)\n\nCreate file: `security-reports/owasp-audit-summary.md`\n\nStructure:\n```markdown\n# Security Assessment Summary\n\n**Date:** [DATE]\n**Assessment Type:** OWASP Top 10 Security Audit\n\n## Overview\n\n[SOLUTION_NAME] has been assessed against the OWASP Top 10, the industry standard for web application security. This assessment identified [X] security concerns requiring attention.\n\n## Risk Summary\n\n| Risk Level | Count | Business Impact |\n|------------|-------|-----------------|\n| Critical | X | Immediate action required - potential data breach |\n| High | X | Address within 1 sprint - significant security risk |\n| Medium | X | Plan for remediation - moderate risk |\n| Low | X | Consider for future improvements |\n\n## Key Findings (Plain Language)\n\n### 1. [Finding Title] - Critical Risk\n\n**What this means:** [Non-technical explanation]\n\n**Business impact:** [What could happen if exploited]\n\n**Recommended action:** [High-level fix description]\n\n**Estimated effort:** [Time/cost indication]\n\n### 2. ...\n\n## What's Working Well\n\n- [Positive observation in plain language]\n- [Another good practice]\n\n## Recommendations\n\n### Immediate (This Week)\n1. [Action item]\n\n### Short-term (This Month)\n1. [Action item]\n\n### Long-term (This Quarter)\n1. [Action item]\n\n## Compliance Status\n\n| Standard | Relevant Guidelines | Status |\n|----------|---------------------|--------|\n| OWASP Top 10 | X of 10 applicable | X% compliant |\n\n## Next Steps\n\n1. Technical team to review detailed report\n2. Prioritize critical and high findings\n3. Schedule remediation work\n4. Plan re-assessment after fixes\n\n---\n\n*This assessment was performed using automated analysis tools and expert review.*\n```\n\n---\n\n## Execution Instructions\n\n1. **Start Phase 1**: Spawn Discovery Agent, wait for results\n2. **Parse relevant guidelines**: Extract the list of applicable OWASP guidelines\n3. **For each guideline**:\n   - Spawn Security Analyst and Verification agents **in parallel**\n   - Wait for both to complete\n   - Merge and reconcile findings\n   - Log progress: \"Completed [X] of [Y] guidelines\"\n4. **Generate reports**: Create both technical and non-technical reports\n5. **Summary**: Present findings overview to user\n\n## Progress Tracking\n\nUse TodoWrite to track:\n- [ ] Phase 1: Solution Discovery\n- [ ] Phase 2: Guideline Analysis (per guideline)\n- [ ] Phase 3: Technical Report Generation\n- [ ] Phase 3: Stakeholder Report Generation\n\nReport completion status after each guideline is processed.\n",
        "persona-generator/.claude-plugin/plugin.json": "{\n  \"name\": \"persona-generator\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Create detailed user personas through interactive dialogue for user story development\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"personas\", \"user-research\", \"dialogue\", \"productivity\"],\n  \"commands\": \"./commands\"\n}\n",
        "persona-generator/README.md": "# Persona Generator\n\nCreate detailed user personas through interactive dialogue for user story development.\n\n## Overview\n\nThis plugin guides you through a structured conversation to create realistic, actionable personas. Personas help teams understand their users and write better user stories.\n\n## Usage\n\n```\n/generate-personas\n```\n\nThe command will guide you through:\n\n1. **Discovery** - Check for existing documentation and personas\n2. **Identify User Types** - Discover the different users of your system\n3. **Deep Dive** - Answer questions about each persona's goals, pain points, tasks\n4. **Generate** - Create detailed persona documents from a template\n5. **Summary** - Review all personas and get user story mapping guidance\n\n## Interactive Questionnaire\n\nThe agent asks targeted questions across these areas:\n\n| Area | Questions About |\n|------|-----------------|\n| **Identity** | Role, department, experience level |\n| **Goals** | Primary objectives, motivations, success metrics |\n| **Pain Points** | Current frustrations, workarounds, impact |\n| **Technical Profile** | Proficiency, devices, usage frequency |\n| **Tasks** | Key activities, frequency, complexity |\n| **Environment** | Tools used, stakeholders, constraints |\n| **Mindset** | Representative quotes capturing their perspective |\n\n## Output\n\nPersonas are saved to `documentation/business/personas/`:\n\n```\ndocumentation/business/personas/\n sarah-sales-manager.md\n alex-system-admin.md\n jordan-end-user.md\n```\n\n### Persona Structure\n\nEach persona includes:\n\n- **Demographics** - Role, department, experience\n- **Goals & Motivations** - What they want to achieve\n- **Pain Points** - Current frustrations with impact ratings\n- **Behaviors** - Technical proficiency, usage patterns\n- **Key Tasks** - What they need to do, with frequency\n- **Environment** - Tools, stakeholders, constraints\n- **Quotes** - Representative mindset statements\n- **Scenarios** - Success and frustration examples\n- **User Story Mapping** - How to use this persona in stories\n\n## Example Persona Output\n\n```markdown\n# Persona: Sarah the Sales Manager\n\n**ID:** `sarah-sales-manager`\n\n## Overview\n\n> Mid-level sales manager responsible for a team of 8 reps, focused on hitting quarterly targets.\n\n## Goals & Motivations\n\n### Primary Goals\n1. Track team performance against quota in real-time\n2. Identify at-risk deals before they slip\n\n### Motivations\n- Save time on manual reporting (currently 4 hours/week)\n- Look prepared in leadership meetings\n- Help struggling reps improve faster\n\n## Pain Points\n\n| Pain Point | Impact | Workaround |\n|------------|--------|------------|\n| Manual data consolidation from multiple systems | High | Weekly spreadsheet ritual |\n| No early warning for at-risk deals | High | Gut feeling, often too late |\n| Can't see rep activity in real-time | Medium | Daily standups |\n\n## User Story Mapping\n\n- **\"As a...\"**: Sales Manager\n- **Goals inform**: \"I want to see real-time team performance...\"\n- **Pain Points inform**: \"...so that I don't waste hours on manual reports\"\n```\n\n## Using Personas for User Stories\n\nAfter creating personas, use them with the user-story-generator:\n\n```\n/generate-user-stories\n```\n\nThe user story generator will:\n1. Read your persona files\n2. Map personas to user stories\n3. Use pain points to inform \"So that...\" benefits\n\n## Workflow Integration\n\n```\n          \n  /generate-personas  /generate-user-       Development with   \n                              stories                 vue-development    \n  Create user                                         skill              \n  personas                  Generate stories                             \n                            from specs +              Implement with     \n                            personas                  TDD + E2E          \n          \n```\n\n## Installation\n\nAdd to your Claude Code plugins:\n\n```bash\nclaude plugins add claude-code-plugins/persona-generator\n```\n\n## License\n\nMIT\n",
        "persona-generator/commands/generate-personas.md": "---\ndescription: Create user personas through interactive dialogue\n---\n\n# Persona Generator\n\nYou are a UX research specialist helping create detailed user personas through an interactive dialogue. Personas are essential for user-centered design and writing effective user stories.\n\nYour goal is to guide the user through a structured conversation to define realistic, actionable personas that can be used for user story development.\n\n---\n\n## Phase 1: Discovery\n\nBefore creating new personas, understand the project context.\n\n### Step 1.1: Check for Existing Documentation\n\nSearch for existing documentation:\n\n1. Use Glob to find relevant files:\n   - `documentation/personas/**/*.md`\n   - `docs/personas/**/*.md`\n   - `personas/**/*.md`\n   - `README.md`\n   - `documentation/functional-*.md`\n   - `documentation/requirements*.md`\n\n2. Read any relevant documentation to understand:\n   - What the project/product does\n   - Who the target users might be\n   - Any existing user research\n\n3. Summarize what you learned and share with the user.\n\n### Step 1.2: Check for Existing Personas\n\nCheck if personas already exist in the output location.\n\nIf personas exist, use AskUserQuestion:\n\n```\nQuestion: \"I found existing personas. How would you like to proceed?\"\nOptions:\n- Add new: Create additional personas alongside existing ones\n- Replace: Create new personas to replace existing ones\n- Update: Modify existing personas based on new information\n```\n\n### Step 1.3: Output Location\n\nPersonas will be saved to `documentation/business/personas/`.\n\nCreate this directory if it doesn't exist.\n\n---\n\n## Phase 2: Identify User Types\n\nDiscover the different types of users for the system.\n\n### Step 2.1: Project Context\n\nUse AskUserQuestion to understand the project:\n\n```\nQuestion: \"Briefly describe what your product/system does and who uses it.\"\n```\n\n### Step 2.2: Identify User Categories\n\nBased on the project description, propose user categories.\n\nUse AskUserQuestion:\n\n```\nQuestion: \"Based on your description, I've identified these potential user types. Which ones should we create personas for?\"\n\nOptions (multi-select):\n- {Identified type 1} - {brief description}\n- {Identified type 2} - {brief description}\n- {Identified type 3} - {brief description}\n- Other user types (I'll describe)\n```\n\nCommon user type patterns to look for:\n- **End Users**: Primary users who perform core tasks\n- **Administrators**: Users who configure and manage the system\n- **Managers/Supervisors**: Users who oversee others' work\n- **Power Users**: Advanced users with complex needs\n- **Occasional Users**: Infrequent users with simple needs\n- **External Users**: Customers, partners, or public users\n- **API Consumers**: Developers integrating with the system\n\n### Step 2.3: Prioritize\n\nIf multiple user types selected, use AskUserQuestion:\n\n```\nQuestion: \"Which persona should we create first? (We'll create them one at a time)\"\nOptions:\n- {Type 1}\n- {Type 2}\n- {Type 3}\n```\n\n---\n\n## Phase 3: Deep Dive - Persona Creation\n\nFor each selected user type, guide through a detailed questionnaire.\n\n### Step 3.1: Identity & Role\n\nAsk about who this persona is:\n\n**Question Set 1 - Basic Identity:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What is this persona's job title or role?\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What department or team do they belong to?\"\nOptions:\n- Engineering/Development\n- Sales/Business Development\n- Marketing\n- Operations\n- Customer Support\n- Finance/Accounting\n- HR/People\n- Executive/Leadership\n- External/Customer\n- Other (please specify)\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How experienced are they in this role?\"\nOptions:\n- New (< 1 year)\n- Junior (1-3 years)\n- Mid-level (3-5 years)\n- Senior (5-10 years)\n- Expert (10+ years)\n```\n\n### Step 3.2: Goals & Motivations\n\nAsk about what drives this persona:\n\n**Question Set 2 - Goals:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What is this persona's PRIMARY goal when using the system? (The main outcome they want to achieve)\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What MOTIVATES them to achieve this goal?\"\nOptions (multi-select):\n- Save time / Increase efficiency\n- Reduce errors / Improve accuracy\n- Meet deadlines / Stay on schedule\n- Impress stakeholders / Look good\n- Make better decisions\n- Collaborate more effectively\n- Learn and grow professionally\n- Reduce stress / Simplify work\n- Other (please specify)\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How do they measure success? What metrics matter to them?\"\n```\n\n### Step 3.3: Pain Points\n\nAsk about current frustrations:\n\n**Question Set 3 - Pain Points:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What are the TOP 3 frustrations this persona experiences with their current process or tools?\"\n```\n\nFor each pain point mentioned, ask:\n\nUse AskUserQuestion:\n```\nQuestion: \"For the pain point '{pain point}', how do they currently work around it?\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How significant is this pain point to their daily work?\"\nOptions:\n- Critical - Blocks their work regularly\n- High - Causes significant delays or frustration\n- Medium - Annoying but manageable\n- Low - Minor inconvenience\n```\n\n### Step 3.4: Technical Profile\n\nAsk about their technical characteristics:\n\n**Question Set 4 - Technical:**\n\nUse AskUserQuestion:\n```\nQuestion: \"How technically proficient is this persona?\"\nOptions:\n- Non-technical - Needs simple, guided interfaces\n- Basic - Comfortable with standard applications\n- Intermediate - Can handle moderate complexity, learns quickly\n- Advanced - Comfortable with complex features, customization\n- Technical - Developer-level, prefers powerful tools over simplicity\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What devices do they primarily use?\"\nOptions (multi-select):\n- Desktop/Laptop\n- Mobile phone\n- Tablet\n- Multiple devices throughout the day\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How often will they use the system?\"\nOptions:\n- Multiple times per day (power user)\n- Daily\n- Several times per week\n- Weekly\n- Monthly or less (occasional user)\n```\n\n### Step 3.5: Tasks & Workflows\n\nAsk about what they need to do:\n\n**Question Set 5 - Tasks:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What are the TOP 3 tasks this persona needs to accomplish in the system?\"\n```\n\nFor each task, ask:\n\nUse AskUserQuestion:\n```\nQuestion: \"How often do they perform '{task}'?\"\nOptions:\n- Multiple times per day\n- Daily\n- Weekly\n- Monthly\n- Occasionally\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"How complex is this task for them?\"\nOptions:\n- Simple - Quick, straightforward action\n- Moderate - Requires some steps or decisions\n- Complex - Multi-step process, needs concentration\n```\n\n### Step 3.6: Environment & Context\n\nAsk about their working context:\n\n**Question Set 6 - Environment:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What other tools or systems does this persona regularly use? (This helps understand integration needs)\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"Who does this persona primarily interact with?\"\nOptions (multi-select):\n- Team members/peers\n- Direct reports\n- Manager/supervisor\n- Customers/clients\n- External partners/vendors\n- Cross-functional teams\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What constraints affect how they work?\"\nOptions (multi-select):\n- Time pressure / tight deadlines\n- Limited budget\n- Compliance/regulatory requirements\n- Remote/distributed work\n- Multiple competing priorities\n- Limited training/onboarding time\n- Other (please specify)\n```\n\n### Step 3.7: Mindset & Quotes\n\nAsk for representative quotes:\n\n**Question Set 7 - Mindset:**\n\nUse AskUserQuestion:\n```\nQuestion: \"What would this persona say about their main goal? Complete the sentence: 'I need to...'\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What would they say about their biggest frustration? Complete the sentence: 'I hate when...'\"\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"What would they say about success? Complete the sentence: 'I feel successful when...'\"\n```\n\n---\n\n## Phase 4: Persona Name & Summary\n\nCreate a memorable identity for the persona.\n\n### Step 4.1: Generate Name\n\nPropose a persona name following the pattern \"{First Name} the {Role}\":\n\nUse AskUserQuestion:\n```\nQuestion: \"I suggest naming this persona '{Suggested Name}'. Would you like to use this name or choose a different one?\"\nOptions:\n- Use suggested name\n- Choose a different name (I'll provide one)\n```\n\n### Step 4.2: Confirm Summary\n\nPresent a brief summary of the persona before generating:\n\n```\n## Persona Summary: {Name}\n\n**Role:** {Job title}\n**Primary Goal:** {Main goal}\n**Key Pain Point:** {Biggest frustration}\n**Technical Level:** {Proficiency}\n**Usage:** {Frequency}\n\nDoes this summary accurately capture this persona?\n```\n\nUse AskUserQuestion:\n```\nQuestion: \"Does this summary look correct?\"\nOptions:\n- Yes, generate the full persona\n- No, I'd like to adjust some details\n```\n\n---\n\n## Phase 5: Generate Persona Document\n\nCreate the persona document using the template.\n\n### Step 5.1: Read Template\n\nRead the template from `${CLAUDE_PLUGIN_ROOT}/templates/persona-template.md`\n\n### Step 5.2: Fill Template\n\nFill in all sections of the template based on the gathered information:\n\n- Be specific and use the exact information provided\n- Include realistic scenarios based on the context\n- Map goals, pain points, and tasks to user story elements\n- Add the creation date\n\n### Step 5.3: Write Persona File\n\nWrite the persona to the output location:\n\n**Filename:** `{persona-id}.md` (e.g., `sarah-sales-manager.md`)\n\n**Location:** `{output-folder}/{persona-id}.md`\n\n### Step 5.4: Present Result\n\nShow the user where the persona was saved and ask about next steps:\n\nUse AskUserQuestion:\n```\nQuestion: \"Persona '{Name}' has been created at {path}. What would you like to do next?\"\nOptions:\n- Create another persona\n- Review/edit this persona\n- I'm done creating personas\n```\n\nIf \"Create another persona\", return to Phase 3 with the next user type.\n\n---\n\n## Phase 6: Summary\n\nWhen all personas are complete, provide a summary.\n\n### Step 6.1: Personas Created\n\nList all personas created:\n\n```\n## Personas Created\n\n| Persona | Role | Primary Goal | File |\n|---------|------|--------------|------|\n| {Name 1} | {Role} | {Goal} | {path} |\n| {Name 2} | {Role} | {Goal} | {path} |\n```\n\n### Step 6.2: User Story Mapping Reference\n\nExplain how to use the personas:\n\n```\n## Using These Personas\n\nWhen writing user stories, reference these personas:\n\n- **\"As a {Role}...\"** - Use the persona's role/title\n- **\"I want...\"** - Derive from persona's goals and tasks\n- **\"So that...\"** - Connect to pain points being solved\n\nExample for {First Persona Name}:\n> As a {Role},\n> I want {derived from task},\n> So that {derived from pain point/goal}.\n```\n\n### Step 6.3: Next Steps\n\nSuggest next steps:\n\n```\n## Suggested Next Steps\n\n1. Review the generated personas with stakeholders\n2. Validate personas against real user research if available\n3. Use personas when writing user stories with /generate-user-stories\n4. Update personas as you learn more about your users\n```\n\n---\n\n## Guidelines\n\n- **Be conversational:** This is a dialogue, not a form. Acknowledge responses and build on them.\n- **Be specific:** Capture concrete details, not vague generalizations.\n- **Be realistic:** Personas should feel like real people, not stereotypes.\n- **Stay focused:** One persona at a time for depth over breadth.\n- **Use multi-select wisely:** Allow multiple selections where it makes sense.\n- **Track progress:** Use TodoWrite to track which personas have been created.\n- **Adapt questions:** Skip or modify questions based on context and previous answers.\n",
        "technical-specifications/.claude-plugin/plugin.json": "{\n  \"name\": \"technical-specifications\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Interactive agent for collecting and refining technical specifications through guided dialogue\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"specifications\", \"requirements\", \"dialogue\", \"productivity\"],\n  \"commands\": \"./commands\"\n}\n",
        "technical-specifications/README.md": "# Technical Specifications Plugin\n\nAn interactive Claude Code plugin that guides you through collecting and refining technical specifications for your project through dialogue.\n\n## Features\n\n- **Top-down approach**: Starts with big picture questions, then drills into architectural layers\n- **Context-aware**: Reads existing documentation to avoid redundant questions\n- **Technology proposals**: Suggests technologies based on your requirements and preferences\n- **Structured output**: Generates a comprehensive specification document\n\n## Usage\n\n```\n/refine-technical-specifications\n```\n\nThe agent will guide you through:\n\n1. **Discovery** - Checks for existing documentation in your project\n2. **Big Picture** - Project goals, target users, scale expectations\n3. **Architectural Layers** - Presentation, Data, and Infrastructure needs\n4. **Non-Functional Requirements** - Performance, security, availability\n5. **Technology Proposals** - Recommends technologies based on gathered requirements\n6. **Output Generation** - Creates `/documentation/technical-specifications.md`\n\n## What Gets Captured\n\nThe plugin focuses on **technical infrastructure needs**, not business logic:\n\n**Captured:**\n- \"Need blob storage for file uploads\"\n- \"Require relational database for user data\"\n- \"Must integrate with Azure AD for authentication\"\n- \"Need caching layer for session management\"\n\n**Not captured:**\n- Business rules about file validation\n- User permission logic details\n- Workflow state machines\n\n## Output\n\nThe plugin generates `/documentation/technical-specifications.md` with sections for:\n\n- Project Overview\n- Functional Capabilities (high-level)\n- Architectural Layers (presentation, data, infrastructure)\n- Technology Stack with rationale\n- Non-Functional Requirements (performance, security, availability)\n- External Dependencies\n- Open Questions\n\n## Handling Existing Specifications\n\nIf a `technical-specifications.md` already exists, you'll be asked whether to:\n- **Merge**: Update and extend the existing document\n- **Overwrite**: Replace with new specifications\n- **New version**: Create a versioned copy alongside the original\n\n## Installation\n\nAdd to your Claude Code plugins:\n\n```bash\nclaude plugins add github:sven/claude-code-plugins/technical-specifications\n```\n",
        "technical-specifications/commands/refine-technical-specifications.md": "---\ndescription: Collect and refine technical specifications through interactive dialogue\n---\n\n# Technical Specifications Collector\n\nYou are a technical specifications expert. Your task is to guide the user through an interactive dialogue to collect and refine technical specifications for their project. You gather requirements top-down: starting with the big picture, then drilling into architectural layers.\n\n**Important:** Focus on technical needs and infrastructure requirements, NOT business logic. For example, capture \"Need blob storage for file uploads\" but not the business rules about what files are allowed.\n\n---\n\n## Phase 1: Discovery\n\nBefore asking questions, gather context from existing documentation.\n\n### Step 1.1: Check for Existing Documentation\n\nSearch for existing documentation in the project:\n\n1. Use Glob to find documentation files:\n   - `documentation/**/*.md`\n   - `docs/**/*.md`\n   - `README.md`\n   - `ARCHITECTURE.md`\n   - `*.spec.md`\n\n2. Read any relevant documentation found to understand what's already documented.\n\n3. Summarize what you learned from existing docs (if any) and let the user know you've incorporated this context.\n\n### Step 1.2: Check for Existing Technical Specifications\n\nCheck if `/documentation/technical-specifications.md` already exists.\n\nIf it exists, use AskUserQuestion to ask:\n\n```\nQuestion: \"A technical specifications file already exists. How would you like to proceed?\"\nOptions:\n- Merge: Update existing sections, add new information, preserve custom content\n- Overwrite: Replace the entire file with new specifications\n- New version: Create technical-specifications-v2.md alongside the existing file\n```\n\n---\n\n## Phase 2: Big Picture Questions\n\nStart with high-level questions to understand the project scope.\n\nUse AskUserQuestion for each topic, adapting based on what you learned from existing documentation. Skip questions that are already well-documented.\n\n### 2.1 Problem & Purpose\n\nAsk about:\n- What problem does this solution solve?\n- Who are the primary users or consumers of this system?\n- What is the scope of this project? (MVP, full product, proof of concept)\n\n### 2.2 Functional Capabilities (High-Level)\n\nAsk about:\n- What are the main capabilities this system needs to provide?\n- Are there specific workflows or processes it must support?\n\n**Remember:** Capture WHAT the system needs to do at a high level, not HOW the business logic works.\n\n### 2.3 Scale & Growth\n\nAsk about:\n- Expected number of users (initial and projected)\n- Expected data volume\n- Traffic patterns (steady, spiky, batch processing)\n- Growth expectations\n\n---\n\n## Phase 3: Layer-by-Layer Questions\n\nDrill into each architectural layer progressively.\n\n### 3.1 Presentation Layer\n\nAsk about:\n- What interfaces are needed? (web application, mobile app, CLI, API for external consumers, admin dashboard)\n- What platforms/browsers must be supported?\n- Any accessibility requirements (WCAG compliance)?\n- Internationalization needs? (multiple languages, RTL support)\n- Offline capabilities needed?\n\n### 3.2 Data Layer\n\nAsk about:\n- What types of data need to be stored?\n  - Structured data (users, orders, etc.)\n  - Files/blobs (uploads, documents, images)\n  - Time-series data\n  - Cache/session data\n- External data sources to integrate?\n- Data volume and retention requirements?\n- Backup and recovery requirements?\n\nBased on answers, identify storage needs like:\n- \"Relational database needed for structured user data\"\n- \"Blob storage needed for file uploads\"\n- \"Cache layer needed for session management\"\n- \"Search index needed for full-text search\"\n\n### 3.3 Infrastructure Layer\n\nAsk about:\n- Deployment target? (cloud provider, on-premises, hybrid)\n- Containerization requirements? (Docker, Kubernetes)\n- CI/CD requirements?\n- Environment needs? (dev, staging, production)\n\nAsk about external integrations:\n- What third-party services will be integrated? (payment processors, email services, analytics)\n- What external APIs need to be consumed?\n- What internal systems need connections? (legacy systems, other microservices)\n- Authentication providers? (Azure AD, Auth0, custom)\n\n---\n\n## Phase 4: Non-Functional Requirements\n\nAsk about quality attributes:\n\n### 4.1 Performance\n- Expected response times for critical operations?\n- Throughput requirements? (requests/second, transactions/minute)\n- Any batch processing needs?\n\n### 4.2 Scalability\n- Horizontal scaling needed?\n- Auto-scaling requirements?\n- Geographic distribution? (multi-region)\n\n### 4.3 Security\n- Authentication requirements?\n- Authorization model? (RBAC, ABAC, simple permissions)\n- Data encryption requirements? (at rest, in transit)\n- Compliance requirements? (GDPR, HIPAA, SOC2)\n- Audit logging needs?\n\n### 4.4 Availability & Reliability\n- Uptime requirements? (99.9%, 99.99%)\n- Disaster recovery requirements?\n- Failover strategy needed?\n\n---\n\n## Phase 5: Technology Proposals\n\nBased on gathered requirements, propose technologies.\n\n### 5.1 Ask for Preferences First\n\nUse AskUserQuestion to ask:\n- Do you have existing technology preferences or constraints?\n- Are there technologies you want to use or avoid?\n- Is there an existing tech stack this should integrate with?\n\n### 5.2 Propose Technologies\n\nBased on requirements AND user preferences, propose specific technologies for each layer:\n\n**Presentation Layer:**\n- Framework recommendation with rationale\n- UI component library if applicable\n\n**Data Layer:**\n- Database recommendations with rationale\n- Storage solutions for different data types\n\n**Infrastructure Layer:**\n- Cloud services recommendations\n- CI/CD tooling\n- Monitoring/observability tools\n\nPresent proposals and allow user to:\n- Accept as-is\n- Modify specific choices\n- Request alternatives\n\n---\n\n## Phase 6: Output Generation\n\nGenerate the technical specifications document.\n\n### 6.1 Read the Template\n\nRead the template from `${CLAUDE_PLUGIN_ROOT}/templates/technical-specifications-template.md`\n\n### 6.2 Generate Content\n\nFill in each section of the template based on the gathered information:\n- Be specific and actionable\n- Include rationale for technology choices\n- List any open questions or decisions still needed\n- Keep it concise but complete\n\n### 6.3 Write the Document\n\nWrite the completed specification to `/documentation/technical-specifications.md`\n\nIf the documentation folder doesn't exist, create it first.\n\n### 6.4 Summary\n\nPresent a summary to the user:\n- What was documented\n- Key technology decisions\n- Any open questions that need further discussion\n- Suggested next steps\n\n---\n\n## Guidelines\n\n- **Be conversational:** This is a dialogue, not an interrogation. Acknowledge answers and build on them.\n- **Skip what's documented:** If existing docs already answer a question, don't ask again.\n- **Stay technical:** Focus on infrastructure and technical needs, not business rules.\n- **Be specific:** Capture concrete requirements, not vague wishes.\n- **Propose, don't prescribe:** Always ask for preferences before making technology recommendations.\n- **Track progress:** Use TodoWrite to track which phases you've completed.\n",
        "ts-refactor-logic/.claude-plugin/plugin.json": "{\n  \"name\": \"ts-refactor-logic\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Refactor TypeScript logic: code splitting, type improvements, design patterns\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"typescript\", \"refactor\", \"clean-code\", \"types\", \"design-patterns\"],\n  \"commands\": \"./commands\"\n}\n",
        "ts-refactor-logic/README.md": "# TS Refactor Logic Plugin\n\nAutonomously refactor TypeScript code for improved readability, maintainability, type safety, and best practices.\n\n## Usage\n\n```\n/ts-refactor-logic:refactor\n```\n\nAutomatically detects the currently open `.ts` or `.tsx` file and applies refactoring.\n\n## What It Does\n\n### Code Splitting\n- Extracts functions > 50 lines into smaller pieces\n- Reduces nesting > 3 levels with guard clauses\n- Converts > 4 parameters to typed object pattern\n- Extracts duplicate code to utilities\n\n### Type Improvements\n| Issue | Solution |\n|-------|----------|\n| `any` type | Specific type or `unknown` |\n| Inline objects | Interface |\n| Repeated types | Shared interface |\n| String literals | Enum or union |\n| Missing generics | Type parameters |\n\n### Pattern Application\n| Problem | Solution |\n|---------|----------|\n| Callback hell | Async/await |\n| Deep nesting | Guard clauses |\n| Long switch | Strategy/lookup |\n| Magic values | Typed constants/enums |\n\n### Error Handling\n- Adds try/catch to unhandled async code\n- Proper typed error propagation\n\n## Example\n\n**Before:**\n```typescript\nfunction processUser(data: any) {\n  if (data) {\n    if (data.status === 'active') {\n      if (data.role === 'admin') {\n        return fetch(url).then(res => res.json());\n      }\n    }\n  }\n}\n```\n\n**After:**\n```typescript\ninterface UserData {\n  status: UserStatus;\n  role: UserRole;\n}\n\nenum UserStatus {\n  Active = 'active',\n  Inactive = 'inactive'\n}\n\nenum UserRole {\n  Admin = 'admin',\n  User = 'user'\n}\n\nasync function processUser(data: UserData): Promise<ApiResponse | null> {\n  if (!data) return null;\n  if (data.status !== UserStatus.Active) return null;\n  if (data.role !== UserRole.Admin) return null;\n\n  const response = await fetch(url);\n  return response.json();\n}\n```\n\n## Verification\n\nEvery refactoring ends with a mandatory checklist showing what was done.\n",
        "ts-refactor-logic/commands/refactor.md": "---\ndescription: Refactor TypeScript logic - code splitting, type improvements, design patterns\n---\n\nYou are a TypeScript refactoring assistant. Your task is to autonomously refactor TypeScript code for improved readability, maintainability, type safety, and best practices.\n\n## Step 1: Identify Target File\n\n1. Check if a `.ts` or `.tsx` file is currently open in the editor\n2. If yes, use that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file is TypeScript (`.ts` or `.tsx`)\n\n## Step 2: Analyze Code\n\nAnalyze the entire file for:\n\n### Code Splitting Issues\n- Functions exceeding 50 lines\n- Cyclomatic complexity > 10 (many conditionals/branches)\n- Nesting depth > 3 levels\n- Functions with > 4 parameters\n- Duplicate code patterns (2+ occurrences)\n\n### Anti-Patterns\n- Magic numbers/strings (unnamed constants)\n- Missing error handling in async code\n- Callback hell / Promise chains that could use async/await\n- Deep nesting instead of guard clauses\n- Long switch statements without abstraction\n\n### Type Issues\n- Use of `any` type\n- Missing return type annotations\n- Missing parameter type annotations\n- Inline object types that should be interfaces\n- Repeated type definitions (should be shared)\n- String literals that should be enums or union types\n- Missing generic types where applicable\n\n## Step 3: Plan Refactoring\n\nFor each issue found, apply the appropriate resolution technique:\n\n---\n\n### Resolving High Cyclomatic Complexity (> 10)\n\n**Technique A: Extract Conditional Logic to Typed Lookup Object**\n```typescript\n// BEFORE: complexity = 12\nfunction process(data: Data): Result {\n  if (data.type === 'A') { /* 20 lines */ }\n  else if (data.type === 'B') { /* 20 lines */ }\n  else if (data.type === 'C') { /* 20 lines */ }\n}\n\n// AFTER: complexity = 3 per function\ntype ProcessorMap = Record<DataType, (data: Data) => Result>\n\nconst processors: ProcessorMap = {\n  A: processTypeA,\n  B: processTypeB,\n  C: processTypeC\n}\n\nfunction process(data: Data): Result | undefined {\n  return processors[data.type]?.(data)\n}\n```\n\n**Technique B: Strategy Pattern with Type Safety**\n```typescript\n// BEFORE\nfunction calculatePrice(item: Item): number {\n  if (item.type === 'book') return item.price * 0.9\n  if (item.type === 'electronics') return item.price * 1.1\n}\n\n// AFTER\ntype PricingStrategy = (item: Item) => number\n\nconst pricingStrategies: Record<ItemType, PricingStrategy> = {\n  book: (item) => item.price * 0.9,\n  electronics: (item) => item.price * 1.1\n}\n\nconst calculatePrice = (item: Item): number => pricingStrategies[item.type](item)\n```\n\n**Technique C: Decompose Boolean Expressions**\n```typescript\n// BEFORE\nif (user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0) {}\n\n// AFTER\nconst isEligibleDriver = (user: User): boolean =>\n  user.age > 18 && user.hasLicense && !user.isSuspended && user.balance > 0\n\nif (isEligibleDriver(user)) {}\n```\n\n---\n\n### Resolving Deep Nesting (> 3 levels)\n\n**Technique A: Guard Clauses (Early Returns)**\n```typescript\n// BEFORE: 4 levels deep\nfunction process(data: Data | null): Result | null {\n  if (data) {\n    if (data.isValid) {\n      if (data.items.length > 0) {\n        if (data.status === 'active') {\n          // actual logic\n        }\n      }\n    }\n  }\n}\n\n// AFTER: 0 levels deep\nfunction process(data: Data | null): Result | null {\n  if (!data) return null\n  if (!data.isValid) return null\n  if (data.items.length === 0) return null\n  if (data.status !== 'active') return null\n\n  // actual logic\n}\n```\n\n**Technique B: Extract Nested Blocks**\n```typescript\n// BEFORE\nfunction handleOrder(order: Order): void {\n  if (order.isPaid) {\n    if (order.items.length > 0) {\n      for (const item of order.items) {\n        if (item.inStock) { /* complex */ }\n      }\n    }\n  }\n}\n\n// AFTER\nfunction handleOrder(order: Order): void {\n  if (!order.isPaid || order.items.length === 0) return\n  order.items.filter(item => item.inStock).forEach(processItem)\n}\n\nfunction processItem(item: OrderItem): void {\n  // complex processing - now at top level\n}\n```\n\n**Technique C: Use Array Methods**\n```typescript\n// BEFORE: nested loops\nfor (const user of users) {\n  for (const order of user.orders) {\n    if (order.status === 'pending') { /* process */ }\n  }\n}\n\n// AFTER: flat\nusers\n  .flatMap(user => user.orders)\n  .filter(order => order.status === 'pending')\n  .forEach(processOrder)\n```\n\n---\n\n### Resolving Long Functions (> 50 lines)\n\n**Technique A: Extract by Responsibility**\n```typescript\n// BEFORE: 100 line function\nasync function submitForm(data: FormData): Promise<void> {\n  // validation (20 lines)\n  // formatting (15 lines)\n  // API call (25 lines)\n  // UI update (20 lines)\n}\n\n// AFTER: focused functions\nasync function submitForm(data: FormData): Promise<void> {\n  const errors = validateFormData(data)\n  if (errors.length) return handleErrors(errors)\n\n  const formatted = formatFormData(data)\n  const result = await sendToApi(formatted)\n  updateUI(result)\n}\n```\n\n**Technique B: Extract Setup/Teardown**\n```typescript\n// AFTER\nfunction processData<T>(input: T): Result {\n  const context = setupProcessing(input)\n  try {\n    return executeProcessing(context)\n  } finally {\n    cleanupProcessing(context)\n  }\n}\n```\n\n---\n\n### Resolving Too Many Parameters (> 4)\n\n**Technique: Object Parameter Pattern with Interface**\n```typescript\n// BEFORE\nfunction createUser(name: string, email: string, age: number, role: string, department: string): User {}\n\n// AFTER\ninterface CreateUserParams {\n  name: string\n  email: string\n  age: number\n  role: UserRole\n  department?: string\n}\n\nfunction createUser({ name, email, age, role, department }: CreateUserParams): User {}\n\ncreateUser({ name: 'John', email: 'john@example.com', age: 30, role: 'developer' })\n```\n\n---\n\n### Resolving Duplicate Code\n\n**Technique: Extract and Parameterize with Generics**\n```typescript\n// BEFORE: duplicated\nasync function fetchUsers(): Promise<User[]> {\n  setLoading(true)\n  const data = await api.get('/users')\n  setLoading(false)\n  return data\n}\nasync function fetchProducts(): Promise<Product[]> {\n  setLoading(true)\n  const data = await api.get('/products')\n  setLoading(false)\n  return data\n}\n\n// AFTER: generic parameterized function\nasync function fetchData<T>(endpoint: string): Promise<T> {\n  setLoading(true)\n  try {\n    return await api.get<T>(endpoint)\n  } finally {\n    setLoading(false)\n  }\n}\n\nconst fetchUsers = () => fetchData<User[]>('/users')\nconst fetchProducts = () => fetchData<Product[]>('/products')\n```\n\n---\n\n### Type Improvements\n| Issue | Solution |\n|-------|----------|\n| `any` type | Specific type or `unknown` |\n| Inline object | Interface or type alias |\n| Repeated types | Shared interface/type |\n| String literals | Enum or union type |\n| Missing generics | Add type parameters |\n\n### File Extraction\nWhen extracting to new files, analyze the project structure:\n- Look for existing `utils/`, `helpers/`, `lib/`, `types/` folders\n- If none exist, propose creating in appropriate location\n- Keep related utilities together\n- Create `types.ts` for shared interfaces\n\n## Step 4: Apply Changes\n\nApply all refactoring changes:\n\n1. Extract long functions into smaller pieces\n2. Apply guard clauses to reduce nesting\n3. Replace `any` with specific types\n4. Add missing type annotations\n5. Create interfaces for object types\n6. Convert string literals to enums/unions\n7. Add generics where beneficial\n8. Convert Promise chains to async/await\n9. Extract magic values to typed constants\n10. Add try/catch for unhandled async errors\n11. Create new utility/type files if needed\n12. Update imports as needed\n\n## Step 5: Report Completion\n\nReport all changes made:\n```\nRefactored: filename.ts\n\nChanges applied:\n- Extracted 3 functions from processData (was 120 lines)\n- Replaced 5 `any` types with specific types\n- Created interface UserData for repeated object shape\n- Converted Status string literals to enum\n- Added generics to fetchData<T>()\n- Refactored 2 Promise chains to async/await\n- Added error handling to fetchUser()\n\nNew files created:\n- types/user.ts (UserData, UserStatus interfaces)\n- utils/dataHelpers.ts\n```\n\n## Verification Checklist (MANDATORY)\n\n**You MUST complete and display this checklist. The refactoring is NOT complete until shown.**\n\n### Analysis\n- [ ] Target .ts/.tsx file identified\n- [ ] Code analyzed for complexity metrics\n- [ ] Anti-patterns identified\n- [ ] Type issues identified\n\n### Code Splitting\n- [ ] Functions > 50 lines: addressed or N/A\n- [ ] Nesting > 3 levels: addressed or N/A\n- [ ] Complexity > 10: addressed or N/A\n- [ ] Parameters > 4: addressed or N/A\n- [ ] Duplicate code: extracted or N/A\n\n### Type Improvements\n- [ ] `any` types: replaced or justified\n- [ ] Missing annotations: added\n- [ ] Inline objects: interfaces created\n- [ ] String literals: enums/unions where appropriate\n- [ ] Generics: added where beneficial\n\n### Patterns & Fixes\n- [ ] Guard clauses applied where beneficial\n- [ ] Promise chains converted to async/await\n- [ ] Magic values extracted to constants/enums\n- [ ] Error handling added where needed\n\n### File Organization\n- [ ] New files created in appropriate locations\n- [ ] Types in dedicated files if shared\n- [ ] Imports updated correctly\n\n### Completion\n- [ ] All changes applied successfully\n- [ ] Summary reported\n- [ ] This checklist displayed with [x] marks\n\n**Example output:**\n```\nVerification Checklist:\n[x] Target file: src/services/userService.ts\n[x] Code analyzed\n[x] Type issues found: 8\n[x] Functions > 50 lines: 1 extracted\n[x] any types: 5 replaced with specific types\n[x] Interfaces created: UserData, ApiResponse\n[x] Enum created: UserStatus\n[x] Generics added: fetchData<T>\n[x] Promise  async/await: 3 converted\n[x] New file: types/user.ts\n[x] Changes applied successfully\n```\n\n## Important Guidelines\n\n- **Preserve functionality**: Never change logic, only structure and types\n- **Preserve tests**: If tests exist, ensure they still pass\n- **Be conservative with types**: Don't over-constrain; use `unknown` over `any`\n- **Naming matters**: Use descriptive names for types, interfaces, and functions\n- **No over-engineering**: Don't add unnecessary type complexity\n- **Prefer interfaces**: Use interfaces over type aliases for object shapes (better error messages, extensibility)\n",
        "user-story-generator/.claude-plugin/plugin.json": "{\n  \"name\": \"user-story-generator\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Generate INVEST-compliant user stories from functional specifications and personas\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"user-stories\", \"invest\", \"gherkin\", \"agile\", \"productivity\"],\n  \"commands\": \"./commands\"\n}\n",
        "user-story-generator/README.md": "# User Story Generator\n\nGenerate INVEST-compliant user stories from functional specifications and personas.\n\n## Features\n\n- Transforms functional specifications into structured user stories\n- Supports persona-driven story writing\n- Generates Gherkin acceptance criteria (Given/When/Then)\n- Organizes stories by Epic  Feature  Story hierarchy\n- Tracks dependencies between stories\n- Provides implementation order recommendations\n\n## Usage\n\n```\n/generate-user-stories\n```\n\nThe command will guide you through:\n\n1. **Configuration** - Specify your specs folder, personas folder (optional), and output location\n2. **Discovery** - Analyzes your specifications and personas\n3. **Organization** - Proposes epics and features for your approval\n4. **Generation** - Creates INVEST-compliant user stories with Gherkin acceptance criteria\n5. **Dependencies** - Maps relationships and suggests implementation order\n6. **Review** - Presents summary and quality checklist\n\n## Input\n\n### Functional Specifications\n\nPlace your functional specification documents in a folder (e.g., `docs/specifications/`). Supported formats:\n- Markdown (`.md`)\n- Text files (`.txt`)\n\nThe plugin handles various specification styles:\n- Requirements lists (REQ-001, etc.)\n- Feature descriptions\n- Use cases\n- User flows\n- Narrative prose\n\n### Personas (Optional)\n\nPlace persona documents in a separate folder (e.g., `docs/personas/`). Include:\n- Role/job title\n- Goals and motivations\n- Pain points\n- Technical proficiency\n- Key tasks\n\nIf no personas are provided, the plugin will identify user types from your specifications.\n\n## Output\n\nGenerated user stories are organized as:\n\n```\nuser-stories/\n README.md              # Overview and index\n epics/\n    {epic}.md          # Epic overviews\n features/\n    {feature}/\n        _index.md      # Feature overview\n        US-001-*.md    # Individual stories\n dependencies.md        # Dependency map\n```\n\n### User Story Format\n\nEach story includes:\n- **User Story**: \"As a [persona], I want [goal], So that [benefit]\"\n- **Acceptance Criteria**: Gherkin scenarios (Given/When/Then)\n- **Dependencies**: Hard and soft dependencies on other stories\n- **INVEST Checklist**: Verification of story quality\n- **Traceability**: Links back to source specifications\n\n### Example Story\n\n```markdown\n## US-001: User Registration\n\n> **As a** new visitor,\n> **I want** to create an account with my email and password,\n> **So that** I can access personalized features.\n\n### Acceptance Criteria\n\n#### AC1: Successful Registration\n```gherkin\nGiven I am on the registration page\nWhen I enter a valid email and password\nAnd I click \"Create Account\"\nThen my account is created\nAnd I see a confirmation message\n```\n\n#### AC2: Duplicate Email\n```gherkin\nGiven an account exists with \"user@example.com\"\nWhen I try to register with \"user@example.com\"\nThen I see \"Email already exists\" error\n```\n```\n\n## Best Practices Applied\n\n### INVEST Criteria\n\nEvery generated story is verified against:\n- **I**ndependent - Can be developed in any order\n- **N**egotiable - Open to discussion\n- **V**aluable - Delivers user value\n- **E**stimable - Effort can be estimated\n- **S**mall - Fits in a sprint\n- **T**estable - Has verifiable acceptance criteria\n\n### Gherkin Acceptance Criteria\n\nAll acceptance criteria use Given/When/Then format:\n- Directly translatable to automated tests\n- Unambiguous success criteria\n- Readable by non-technical stakeholders\n\n### Dependency Tracking\n\nStories include:\n- **Hard dependencies**: Must be completed first\n- **Soft dependencies**: Easier if done in order\n- **Implementation phases**: Suggested development sequence\n\n## Installation\n\nAdd to your Claude Code plugins:\n\n```bash\nclaude plugins add claude-code-plugins/user-story-generator\n```\n\n## License\n\nMIT\n",
        "user-story-generator/commands/generate-user-stories.md": "---\ndescription: Generate user stories from functional specifications and personas\n---\n\n# User Story Generator\n\nYou are a user story specialist helping transform functional specifications into well-structured, INVEST-compliant user stories. You generate comprehensive backlog items with Gherkin acceptance criteria and dependency tracking.\n\n---\n\n## Phase 0: Configuration\n\nBefore starting, gather the required inputs from the user.\n\n### Step 0.1: Specification Source\n\nAsk the user:\n> Where are your functional specifications located? (e.g., `docs/specifications/`, `requirements/`)\n\nUse Glob to verify the folder exists and contains files.\n\n### Step 0.2: Persona Source (Optional)\n\nAsk the user:\n> Do you have persona documents? If yes, where are they located? (e.g., `docs/personas/`)\n> If no personas exist, I'll help you define user types based on the specifications.\n\n### Step 0.3: Output Location\n\nAsk the user:\n> Where should the generated user stories be saved? (default: `user-stories/`)\n\n---\n\n## Phase 1: Discovery\n\nAnalyze the source documents to understand the project context.\n\n### Step 1.1: Read Functional Specifications\n\n1. Use Glob to find all specification files in the provided folder (`**/*.md`, `**/*.txt`)\n2. Read each specification file and extract:\n   - Feature descriptions\n   - Functional requirements\n   - Business rules\n   - System behaviors\n   - Integration points\n\n3. Build a mental **Feature Map** noting:\n   - Feature name and description\n   - Source file location\n   - Related requirements\n   - Connected features\n\n### Step 1.2: Read Persona Documents\n\nIf persona documents exist, read each and extract using the guide at `${CLAUDE_PLUGIN_ROOT}/templates/persona-extraction.md`:\n\n- Persona ID and name\n- Role description\n- Goals and motivations\n- Pain points\n- Technical proficiency\n- Key tasks they perform\n\nIf no personas exist, identify user types from the specifications:\n- Look for mentions of \"user\", \"admin\", \"customer\", \"manager\", etc.\n- Create minimal persona definitions based on context\n- Confirm with the user before proceeding\n\n### Step 1.3: Check Existing User Stories\n\nLook for existing user stories in the output location:\n- If found, ask how to proceed: merge, overwrite, or create new version\n- Extract existing story IDs to avoid conflicts\n\n---\n\n## Phase 2: Epic & Feature Organization\n\nGroup requirements into a hierarchical structure.\n\n### Step 2.1: Identify Epics\n\nAn Epic is a large body of work grouping related features. Identify epics by:\n\n1. Looking for major functional areas in specifications\n2. Grouping related features together\n3. Identifying cross-cutting concerns\n\nPresent proposed epics to user for approval:\n```\nBased on your specifications, I've identified these epics:\n\n1. **[Epic Name]** - [Brief description]\n2. **[Epic Name]** - [Brief description]\n...\n\nWould you like to modify this structure?\n```\n\n### Step 2.2: Feature Decomposition\n\nFor each epic, identify features (smaller functional groupings):\n\n```\nEpic: [Name]\n Feature: [Name]\n Feature: [Name]\n Feature: [Name]\n```\n\n### Step 2.3: Story Mapping\n\nEach feature should decompose into 3-8 user stories following the \"Small\" principle of INVEST.\n\nCreate a story map showing:\n```\nEpic  Feature  User Stories\n```\n\n---\n\n## Phase 3: User Story Generation\n\nGenerate stories applying INVEST principles and Gherkin acceptance criteria.\n\n### INVEST Criteria\n\nFor each story, ensure it is:\n- **I**ndependent: Can be developed in any order\n- **N**egotiable: Open to discussion, not a rigid contract\n- **V**aluable: Delivers value to the user\n- **E**stimable: Team can estimate effort\n- **S**mall: Fits in a single sprint\n- **T**estable: Has clear, verifiable acceptance criteria\n\n### Step 3.1: Generate Stories by Feature\n\nFor each feature, generate user stories:\n\n1. **Identify the persona** most relevant to this feature\n2. **Define the goal** - what the user wants to accomplish\n3. **Articulate the benefit** - why this matters to them\n4. **Write acceptance criteria** as Gherkin scenarios\n5. **Identify dependencies** on other stories\n\nUse the template at `${CLAUDE_PLUGIN_ROOT}/templates/user-story.md`.\n\n### Step 3.2: Story Writing Rules\n\nApply these rules:\n\n1. **One action per story**: \"User can register AND login\" becomes two stories\n2. **User-centric language**: Focus on what user does, not system internals\n3. **No implementation details**: Avoid technical specifics like \"using REST API\"\n4. **Measurable outcomes**: Each story must have verifiable completion\n\n### Step 3.3: Acceptance Criteria as Gherkin\n\nWrite acceptance criteria in Given/When/Then format:\n\n```gherkin\nGiven [precondition/context]\nWhen [action/trigger]\nThen [expected outcome]\nAnd [additional outcomes]\n```\n\nEach story should have multiple acceptance criteria covering:\n- **Happy path**: Main success scenario\n- **Edge cases**: Boundary conditions\n- **Error scenarios**: What happens when things go wrong\n\nExample for a registration story:\n\n```gherkin\n# AC1: Successful registration\nGiven I am on the registration page\nWhen I enter a valid email and password\nAnd I click \"Create Account\"\nThen my account is created\nAnd I see a confirmation message\n\n# AC2: Duplicate email\nGiven an account exists with \"user@example.com\"\nWhen I try to register with \"user@example.com\"\nThen I see \"Email already exists\" error\n\n# AC3: Invalid password\nGiven I am on the registration page\nWhen I enter a password shorter than 8 characters\nThen I see password requirements message\n```\n\n---\n\n## Phase 4: Dependency Analysis\n\nMap dependencies between stories.\n\n### Step 4.1: Identify Dependencies\n\nFor each story, determine:\n\n1. **Hard dependencies**: Stories that MUST be completed first\n   - Example: \"View Profile\" depends on \"User Registration\"\n\n2. **Soft dependencies**: Stories that are EASIER if done in order\n   - Example: \"Advanced Search\" easier after \"Basic Search\"\n\n### Step 4.2: Validate Dependencies\n\nCheck for:\n- Circular dependencies (error - must resolve)\n- Orphan stories (no dependencies - may be foundation stories)\n- Over-dependent stories (may need decomposition)\n\n### Step 4.3: Implementation Order\n\nGenerate a recommended sequence:\n\n```\nPhase 1 (Foundation):\n- US-001: [Story] - No dependencies\n- US-002: [Story] - No dependencies\n\nPhase 2 (Core):\n- US-003: [Story] - Depends on US-001\n- US-004: [Story] - Depends on US-001, US-002\n\nPhase 3 (Enhanced):\n- US-005: [Story] - Depends on US-003\n...\n```\n\n---\n\n## Phase 5: Output Generation\n\nGenerate the user story documentation.\n\n### Step 5.1: Directory Structure\n\nCreate this structure in the output folder:\n\n```\n{output-folder}/\n README.md                    # Overview and story index\n epics/\n    {epic-slug}.md          # Epic overview files\n features/\n    {feature-slug}/\n        _index.md           # Feature overview\n        {story-id}.md       # Individual story files\n dependencies.md              # Dependency map\n```\n\n### Step 5.2: Generate Files\n\nUse templates from `${CLAUDE_PLUGIN_ROOT}/templates/`:\n\n1. **README.md**: Index with statistics, epic links, and quick navigation\n2. **Epic files**: Use `epic.md` template - overview with feature list\n3. **Feature _index.md**: Feature details with story list\n4. **Story files**: Use `user-story.md` template - full story details\n5. **dependencies.md**: Visual dependency map with implementation phases\n\n### Step 5.3: Story ID Convention\n\nUse consistent IDs:\n- Stories: `US-001`, `US-002`, etc. (sequential)\n- Epics: `EPIC-01`, `EPIC-02`, etc.\n- File names: `US-001-short-description.md`\n\n---\n\n## Phase 6: Review & Summary\n\nPresent results for user review.\n\n### Step 6.1: Summary Report\n\n```\n## Generation Complete\n\n**Statistics:**\n- Epics: [n]\n- Features: [n]\n- User Stories: [n]\n\n**Coverage:**\n- Specifications analyzed: [n] files\n- Personas used: [n]\n\n**Stories by Epic:**\n| Epic | Features | Stories |\n|------|----------|---------|\n| [Name] | [n] | [n] |\n\n**Dependency Highlights:**\n- [n] foundation stories (no dependencies)\n- [n] stories with 3+ dependencies (review recommended)\n```\n\n### Step 6.2: Quality Checklist\n\nVerify:\n- [ ] All specifications covered\n- [ ] All personas represented\n- [ ] No orphan stories without context\n- [ ] All stories have acceptance criteria\n- [ ] Dependencies documented\n\n### Step 6.3: Next Steps\n\nSuggest:\n1. Review generated stories with stakeholders\n2. Refine acceptance criteria based on feedback\n3. Import into project management tool if needed\n\n---\n\n## Guidelines\n\n- **Be thorough**: Cover all requirements from specifications\n- **Be consistent**: Use consistent naming and ID schemes\n- **Be specific**: Vague stories are not testable\n- **Ask when uncertain**: If a requirement is ambiguous, ask the user\n- **Use TodoWrite**: Track generation progress through phases\n- **Preserve traceability**: Link stories back to source specifications\n",
        "vue-development-skill/.claude-plugin/plugin.json": "{\n  \"name\": \"vue-development-skill\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Vue 3/Nuxt 3 development skill with TDD workflow and QA-first approach. Produces JSON reports for agent handoff.\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"vue\", \"nuxt\", \"tdd\", \"testing\", \"skill\"],\n  \"skills\": \"./skills\"\n}\n",
        "vue-development-skill/README.md": "# Vue Development Skill\n\nA Claude Code skill for Vue 3 and Nuxt 3 development with **test-driven development (TDD)**, **QA gates**, and **E2E validation against Gherkin acceptance criteria**.\n\n## Overview\n\nThis skill enforces quality-driven development by:\n\n1. **Writing tests before implementation** (TDD)\n2. **Validating against a Vue-specific QA checklist**\n3. **Executing E2E tests via Playwright MCP** to validate Gherkin acceptance criteria\n4. **Producing JSON reports** with complete validation results\n\n## Self-Validating Workflow\n\nAgents using this skill can **autonomously complete user stories** by implementing and validating their own work:\n\n```\nUser Story (with Gherkin AC)\n    \n\n  Vue Development Agent (this skill)                     \n                                                         \n  1. Parse user story + acceptance criteria              \n  2. Write unit tests first (TDD)                        \n  3. Implement minimal code                              \n  4. Run unit tests (Vitest)                             \n  5. Validate QA checklist                               \n  6. Execute E2E via Playwright MCP   Self-validation   \n  7. Generate completion report                          \n\n    \n Self-validated completion (all AC pass)\n```\n\n## Input: User Stories with Gherkin\n\nThe skill accepts user stories with Gherkin acceptance criteria:\n\n```markdown\n## US-001: User Login\n\n> **As a** registered user,\n> **I want** to login with my credentials,\n> **So that** I can access my account.\n\n### Acceptance Criteria\n\n#### AC1: Successful login\n\n```gherkin\nGiven I am on the login page\nWhen I fill \"email\" with \"user@example.com\"\nAnd I fill \"password\" with \"password123\"\nAnd I click \"Login\"\nThen I am redirected to the dashboard\nAnd I see \"Welcome back\"\n```\n\n#### AC2: Invalid password\n\n```gherkin\nGiven I am on the login page\nWhen I fill \"email\" with \"user@example.com\"\nAnd I fill \"password\" with \"wrong\"\nAnd I click \"Login\"\nThen I see \"Invalid credentials\"\n```\n```\n\n## E2E Test Generation\n\nThe skill generates **persistent Playwright test files** from Gherkin acceptance criteria:\n\n**Output:** `tests/e2e/{story-id}-{feature-slug}.spec.ts`\n\n| Gherkin | Playwright Code |\n|---------|-----------------|\n| `Given I am on \"{url}\"` | `await page.goto('{url}')` |\n| `When I click \"{text}\"` | `await page.click('text={text}')` |\n| `When I fill \"{field}\" with \"{value}\"` | `await page.fill('[name=\"{field}\"]', '{value}')` |\n| `Then I see \"{text}\"` | `await expect(page.locator('text={text}')).toBeVisible()` |\n\n**Benefits:**\n- Tests are **version-controlled** and persistent\n- Can be **re-run** during CI/CD\n- Other developers can **review and extend** them\n- Builds a **regression test suite** over time\n\nSee `e2e/playwright-patterns.md` for the complete mapping reference.\n\n## Installation\n\nAdd this plugin to your Claude Code configuration:\n\n```json\n{\n  \"plugins\": [\n    \"https://github.com/your-org/claude-code-plugins/vue-development-skill\"\n  ]\n}\n```\n\n## Complete Workflow\n\n```\n1. UNDERSTAND   Parse user story + Gherkin acceptance criteria\n2. TEST FIRST   Write failing unit tests (Vitest + Vue Test Utils)\n3. IMPLEMENT    Write minimal code to pass tests\n4. REFACTOR     Clean up while keeping tests green\n5. QA CHECK     Validate against Vue checklist\n6. E2E WRITE    Generate Playwright test files from Gherkin AC\n7. E2E RUN      Execute tests and verify all AC pass\n8. REPORT       Generate JSON report with all results\n```\n\n## QA Checklist Categories\n\nThe skill validates code against these Vue-specific criteria:\n\n| Category | Items | Focus |\n|----------|-------|-------|\n| Component Quality | 5 | Props, emits, single responsibility |\n| Reactivity | 4 | ref/reactive, computed, no prop mutation |\n| Composables | 4 | Structure, return types, cleanup |\n| Nuxt-Specific | 4 | useFetch, auto-imports, SEO |\n| TypeScript | 4 | No any, interfaces, generics |\n| Unit Tests | 6 | Coverage, TDD compliance |\n\n## Completion Report\n\nAfter completing work, Claude generates a JSON report with all validation results:\n\n**Location:** `.qa-reports/{uuid}.vue-development-skill.json`\n\n```json\n{\n  \"id\": \"uuid-v4\",\n  \"skill\": \"vue-development\",\n  \"timestamp\": \"2025-12-01T10:30:00Z\",\n  \"task_description\": \"Implemented user login feature\",\n\n  \"user_story\": {\n    \"id\": \"US-001\",\n    \"title\": \"User Login\",\n    \"persona\": \"registered user\"\n  },\n\n  \"tdd\": {\n    \"tests_written_first\": true,\n    \"tests_passing\": true\n  },\n\n  \"qa\": {\n    \"score\": 9.0,\n    \"status\": \"PASS\"\n  },\n\n  \"e2e_validation\": {\n    \"test_file\": \"tests/e2e/us-001-user-login.spec.ts\",\n    \"test_command\": \"npx playwright test tests/e2e/us-001-user-login.spec.ts\",\n    \"executed\": true,\n    \"acceptance_criteria\": [\n      {\n        \"id\": \"AC1\",\n        \"title\": \"Successful login\",\n        \"status\": \"PASS\"\n      },\n      {\n        \"id\": \"AC2\",\n        \"title\": \"Invalid password\",\n        \"status\": \"PASS\"\n      }\n    ],\n    \"passed\": 2,\n    \"failed\": 0,\n    \"status\": \"PASS\"\n  },\n\n  \"completion\": {\n    \"unit_tests\": \"PASS\",\n    \"qa_checklist\": \"PASS\",\n    \"e2e_validation\": \"PASS\",\n    \"overall\": \"COMPLETE\"\n  }\n}\n```\n\n## Included Documentation\n\n### E2E Testing\n- `e2e/playwright-patterns.md` - Gherkin to Playwright MCP mapping\n- `e2e/acceptance-criteria.md` - Parsing user stories and AC\n\n### Patterns\n- `patterns/composition-api.md` - Vue 3 Composition API best practices\n- `patterns/nuxt3.md` - Nuxt 3 specific patterns\n- `patterns/typescript.md` - TypeScript with Vue\n\n### Testing\n- `tdd/workflow.md` - Complete TDD process\n- `tdd/testing-patterns.md` - Vitest and Vue Test Utils examples\n\n### Quality\n- `qa/vue-checklist.md` - Full QA checklist\n- `qa/report-template.json` - JSON schema for reports\n\n### Debugging\n- `debugging/common-issues.md` - Troubleshooting guide\n\n## Quality Thresholds\n\n| Score | Status | Meaning |\n|-------|--------|---------|\n| 9-10 | PASS | All validations passed |\n| 7-8 | ACCEPTABLE | Minor issues noted |\n| 0-6 | NEEDS_WORK | Must fix before completion |\n\n## Completion Requirements\n\nFor `overall: \"COMPLETE\"`, all gates must pass:\n\n-  Unit tests passing\n-  QA checklist score  7\n-  All acceptance criteria validated via Playwright\n\n## Tech Stack\n\nThis skill assumes:\n\n- **Vue 3** with Composition API and `<script setup>`\n- **Nuxt 3** (optional, patterns included)\n- **TypeScript** (required, no JavaScript)\n- **Vitest** for unit testing\n- **Vue Test Utils** for component testing\n- **Playwright MCP** for E2E validation\n\n## License\n\nMIT\n",
        "vue-development-skill/skills/vue-development/SKILL.md": "---\nname: vue-development\ndescription: Vue 3 and Nuxt 3 development with TDD workflow, QA gates, and E2E test generation. Enforces unit testing before implementation, generates Playwright E2E tests from Gherkin acceptance criteria, and produces JSON reports.\n---\n\n# Vue Development Skill\n\nThis skill guides development of Vue 3 and Nuxt 3 applications using a **test-driven development** approach with **quality assurance gates** and **E2E test generation from acceptance criteria**.\n\n## When This Skill Activates\n\nUse this skill when:\n- Creating or modifying `.vue` files\n- Writing composables (`use*.ts`)\n- Working with Nuxt-specific files (`pages/`, `layouts/`, `middleware/`, `composables/`)\n- User mentions Vue, Nuxt, or component development\n- Building reactive UI components\n- **Implementing user stories with Gherkin acceptance criteria**\n\n## Core Workflow: TDD + QA + E2E\n\n**ALWAYS follow this workflow:**\n\n```\n1. UNDERSTAND   Parse user story + Gherkin acceptance criteria\n2. TEST FIRST   Write failing unit tests (Vitest + Vue Test Utils)\n3. IMPLEMENT    Write minimal code to pass tests\n4. REFACTOR     Clean up while keeping tests green\n5. QA CHECK     Validate against Vue checklist (see qa/vue-checklist.md)\n6. E2E WRITE    Generate Playwright test files from Gherkin AC\n7. E2E RUN      Execute tests and verify all AC pass\n8. REPORT       Generate JSON report with E2E results\n```\n\n---\n\n## Input: User Story Format\n\nThis skill accepts user stories with Gherkin acceptance criteria:\n\n```markdown\n## US-001: {Story Title}\n\n> **As a** {persona},\n> **I want** {goal},\n> **So that** {benefit}.\n\n### Acceptance Criteria\n\n#### AC1: {Happy Path}\n\n```gherkin\nGiven {precondition}\nWhen {action}\nThen {expected result}\n```\n\n#### AC2: {Error Scenario}\n\n```gherkin\nGiven {precondition}\nWhen {invalid action}\nThen {error handling}\n```\n```\n\n**See:** `e2e/acceptance-criteria.md` for detailed parsing guide.\n\n## Step-by-Step Instructions\n\n### Step 1: Understand Requirements\n\nBefore writing any code:\n- **Parse the user story** to understand persona, goal, and benefit\n- **Extract acceptance criteria** (Gherkin Given/When/Then)\n- Identify props, emits, and slots needed\n- Determine reactive state requirements\n- Map acceptance criteria to testable behaviors\n\n### Step 2: Write Tests First\n\n**Create test file BEFORE implementation:**\n\n```typescript\n// src/components/__tests__/MyComponent.spec.ts\nimport { describe, it, expect } from 'vitest'\nimport { mount } from '@vue/test-utils'\nimport MyComponent from '../MyComponent.vue'\n\ndescribe('MyComponent', () => {\n  it('renders with default props', () => {\n    const wrapper = mount(MyComponent)\n    expect(wrapper.exists()).toBe(true)\n  })\n\n  it('displays label prop correctly', () => {\n    const wrapper = mount(MyComponent, {\n      props: { label: 'Click me' }\n    })\n    expect(wrapper.text()).toContain('Click me')\n  })\n\n  it('emits click event when clicked', async () => {\n    const wrapper = mount(MyComponent)\n    await wrapper.trigger('click')\n    expect(wrapper.emitted('click')).toBeTruthy()\n  })\n})\n```\n\n**Run tests to confirm they fail:**\n```bash\nnpm run test -- MyComponent.spec.ts\n```\n\n### Step 3: Implement Component\n\nWrite the **minimal code** to make tests pass:\n\n```vue\n<script setup lang=\"ts\">\ninterface Props {\n  label?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  label: 'Button'\n})\n\nconst emit = defineEmits<{\n  click: []\n}>()\n\nfunction handleClick() {\n  emit('click')\n}\n</script>\n\n<template>\n  <button @click=\"handleClick\">\n    {{ label }}\n  </button>\n</template>\n```\n\n### Step 4: Verify Tests Pass\n\n```bash\nnpm run test -- MyComponent.spec.ts\n```\n\nAll tests must be green before proceeding.\n\n### Step 5: QA Validation\n\nGo through the **Vue QA Checklist** (see `qa/vue-checklist.md`):\n\n- [ ] Props typed with TypeScript\n- [ ] Emits typed with `defineEmits<{...}>()`\n- [ ] No `any` types\n- [ ] Computed for derived state\n- [ ] Single responsibility\n- [ ] Tests cover all behaviors\n\n### Step 6: Write E2E Test Files\n\n**Generate Playwright test files from Gherkin acceptance criteria.**\n\nFor each user story, create a test file:\n\n**Location:** `tests/e2e/{feature-slug}.spec.ts`\n\n#### Test File Structure\n\n```typescript\n// tests/e2e/user-login.spec.ts\nimport { test, expect } from '@playwright/test'\n\n/**\n * US-001: User Login\n * As a registered user, I want to login with my credentials,\n * so that I can access my account.\n */\ntest.describe('US-001: User Login', () => {\n\n  test('AC1: Successful login', async ({ page }) => {\n    // Given I am on the login page\n    await page.goto('/login')\n\n    // When I fill \"email\" with \"user@example.com\"\n    await page.fill('[name=\"email\"]', 'user@example.com')\n\n    // And I fill \"password\" with \"password123\"\n    await page.fill('[name=\"password\"]', 'password123')\n\n    // And I click \"Login\"\n    await page.click('button:has-text(\"Login\")')\n\n    // Then I am redirected to the dashboard\n    await expect(page).toHaveURL(/dashboard/)\n\n    // And I see \"Welcome back\"\n    await expect(page.locator('text=Welcome back')).toBeVisible()\n  })\n\n  test('AC2: Invalid password', async ({ page }) => {\n    // Given I am on the login page\n    await page.goto('/login')\n\n    // When I fill \"email\" with \"user@example.com\"\n    await page.fill('[name=\"email\"]', 'user@example.com')\n\n    // And I fill \"password\" with \"wrong\"\n    await page.fill('[name=\"password\"]', 'wrong')\n\n    // And I click \"Login\"\n    await page.click('button:has-text(\"Login\")')\n\n    // Then I see \"Invalid credentials\"\n    await expect(page.locator('text=Invalid credentials')).toBeVisible()\n  })\n\n})\n```\n\n#### Gherkin to Playwright Mapping\n\n| Gherkin | Playwright Code |\n|---------|-----------------|\n| `Given I am on \"{url}\"` | `await page.goto('{url}')` |\n| `When I click \"{text}\"` | `await page.click('text={text}')` |\n| `When I click the \"{selector}\" button` | `await page.click('{selector}')` |\n| `When I fill \"{field}\" with \"{value}\"` | `await page.fill('[name=\"{field}\"]', '{value}')` |\n| `When I select \"{option}\" from \"{field}\"` | `await page.selectOption('[name=\"{field}\"]', '{option}')` |\n| `When I press \"{key}\"` | `await page.keyboard.press('{key}')` |\n| `Then I see \"{text}\"` | `await expect(page.locator('text={text}')).toBeVisible()` |\n| `Then I am redirected to \"{url}\"` | `await expect(page).toHaveURL(/{url}/)` |\n| `Then the \"{element}\" is visible` | `await expect(page.locator('{element}')).toBeVisible()` |\n| `Then the \"{element}\" is not visible` | `await expect(page.locator('{element}')).not.toBeVisible()` |\n\n#### File Naming Convention\n\n- Story ID in filename: `{story-id}-{feature-slug}.spec.ts`\n- Examples:\n  - `us-001-user-login.spec.ts`\n  - `us-042-password-reset.spec.ts`\n  - `us-103-checkout-flow.spec.ts`\n\n**See:** `e2e/playwright-patterns.md` for complete mapping reference.\n\n### Step 7: Run E2E Tests\n\n**Execute the generated Playwright tests to validate acceptance criteria.**\n\n#### Run Tests\n\n```bash\n# Run specific test file\nnpx playwright test tests/e2e/user-login.spec.ts\n\n# Run all E2E tests\nnpx playwright test tests/e2e/\n\n# Run with UI mode for debugging\nnpx playwright test tests/e2e/user-login.spec.ts --ui\n```\n\n#### Verify Results\n\nAll acceptance criteria must pass:\n\n```\nRunning 2 tests using 1 worker\n\n   US-001: User Login  AC1: Successful login (2.1s)\n   US-001: User Login  AC2: Invalid password (1.8s)\n\n  2 passed (4.2s)\n```\n\n#### Handle Failures\n\nIf tests fail:\n\n1. **Review the error** - Check which AC failed and why\n2. **Fix the implementation** - Update component/page code\n3. **Re-run tests** - Verify fix works\n4. **Do NOT modify the test** unless the AC was wrong\n\n```\nIf AC fails  Fix implementation, NOT the test\nIf AC is wrong  Update user story first, then regenerate test\n```\n\n### Step 8: Generate Report\n\n**REQUIRED:** Create a JSON report with E2E validation results.\n\n**Location:** `.qa-reports/{uuid}.vue-development-skill.json`\n\nGenerate a UUID and write the report:\n\n```json\n{\n  \"id\": \"generated-uuid-here\",\n  \"skill\": \"vue-development\",\n  \"timestamp\": \"2025-12-01T10:30:00Z\",\n  \"task_description\": \"Created MyComponent button with click handling\",\n\n  \"user_story\": {\n    \"id\": \"US-001\",\n    \"title\": \"User Login\",\n    \"persona\": \"registered user\",\n    \"goal\": \"to login with my credentials\",\n    \"benefit\": \"I can access my account\"\n  },\n\n  \"files\": {\n    \"created\": [\"src/components/MyComponent.vue\"],\n    \"modified\": [],\n    \"test_files\": [\"src/components/__tests__/MyComponent.spec.ts\"],\n    \"e2e_test_files\": [\"tests/e2e/us-001-user-login.spec.ts\"]\n  },\n\n  \"tdd\": {\n    \"tests_written_first\": true,\n    \"test_command\": \"npm run test -- MyComponent.spec.ts\",\n    \"tests_passing\": true,\n    \"coverage_estimate\": \"high\"\n  },\n\n  \"qa\": {\n    \"score\": 9.0,\n    \"status\": \"PASS\",\n    \"checklist\": {\n      \"component_quality\": { \"passed\": 5, \"total\": 5, \"issues\": [] },\n      \"reactivity\": { \"passed\": 4, \"total\": 4, \"issues\": [] },\n      \"composables\": { \"passed\": 0, \"total\": 0, \"issues\": [\"N/A\"] },\n      \"nuxt_specific\": { \"passed\": 0, \"total\": 0, \"issues\": [\"N/A - plain Vue\"] },\n      \"typescript\": { \"passed\": 4, \"total\": 4, \"issues\": [] },\n      \"unit_tests\": { \"passed\": 6, \"total\": 6, \"issues\": [] }\n    }\n  },\n\n  \"e2e_validation\": {\n    \"test_file\": \"tests/e2e/us-001-user-login.spec.ts\",\n    \"test_command\": \"npx playwright test tests/e2e/us-001-user-login.spec.ts\",\n    \"executed\": true,\n    \"acceptance_criteria\": [\n      {\n        \"id\": \"AC1\",\n        \"title\": \"Successful login\",\n        \"gherkin\": \"Given I am on login page\\nWhen I fill credentials\\nThen I see dashboard\",\n        \"status\": \"PASS\"\n      },\n      {\n        \"id\": \"AC2\",\n        \"title\": \"Invalid password\",\n        \"gherkin\": \"Given I am on login page\\nWhen I enter wrong password\\nThen I see error\",\n        \"status\": \"PASS\"\n      }\n    ],\n    \"passed\": 2,\n    \"failed\": 0,\n    \"status\": \"PASS\"\n  },\n\n  \"completion\": {\n    \"unit_tests\": \"PASS\",\n    \"qa_checklist\": \"PASS\",\n    \"e2e_validation\": \"PASS\",\n    \"overall\": \"COMPLETE\"\n  }\n}\n```\n\n## Quality Thresholds\n\n| Score | Status | Action |\n|-------|--------|--------|\n| 9-10 | PASS | Ready for E2E validation |\n| 7-8 | ACCEPTABLE | Ready, but note issues |\n| 0-6 | NEEDS_WORK | Fix issues before handoff |\n\n**Formula:** `score = (checks_passed / total_applicable_checks)  10`\n\n## File References\n\n- **QA Checklist:** See `qa/vue-checklist.md` for full criteria\n- **Report Schema:** See `qa/report-template.json` for JSON structure\n- **TDD Guide:** See `tdd/workflow.md` for detailed process\n- **Testing Patterns:** See `tdd/testing-patterns.md` for Vitest examples\n- **Vue Patterns:** See `patterns/composition-api.md`\n- **Nuxt Patterns:** See `patterns/nuxt3.md`\n- **TypeScript:** See `patterns/typescript.md`\n- **Debugging:** See `debugging/common-issues.md`\n- **E2E Patterns:** See `e2e/playwright-patterns.md` for Gherkin-to-Playwright mapping\n- **Acceptance Criteria:** See `e2e/acceptance-criteria.md` for parsing user stories\n\n## Important Rules\n\n1. **NEVER skip tests** - Write tests before implementation\n2. **NEVER skip E2E validation** - Validate all acceptance criteria with Playwright\n3. **NEVER skip the report** - Include E2E results in report\n4. **NEVER leave tests failing** - All unit tests AND E2E must pass\n5. **ALWAYS use TypeScript** - No JavaScript, no `any`\n6. **ALWAYS follow Composition API** - No Options API\n7. **ALWAYS validate against Gherkin AC** - If user story provided, all AC must pass\n",
        "vue-development-skill/skills/vue-development/debugging/common-issues.md": "# Common Vue/Nuxt Issues & Debugging\n\nThis guide covers frequent issues and how to debug them effectively.\n\n## Reactivity Issues\n\n### Problem: Changes Not Reflecting in UI\n\n**Symptom:** You update a value but the template doesn't update.\n\n**Common Causes:**\n\n1. **Replacing reactive object instead of modifying:**\n```typescript\n// Bad - loses reactivity\nlet user = reactive({ name: 'John' })\nuser = { name: 'Jane' }  // Broken!\n\n// Good - modify properties\nconst user = reactive({ name: 'John' })\nuser.name = 'Jane'\n\n// Or use ref for reassignment\nconst user = ref({ name: 'John' })\nuser.value = { name: 'Jane' }  // Works!\n```\n\n2. **Adding new properties to reactive object:**\n```typescript\n// Bad - new property not reactive in some cases\nconst state = reactive({ count: 0 })\nstate.newProp = 'value'  // May not be reactive\n\n// Good - define all properties upfront\nconst state = reactive({\n  count: 0,\n  newProp: ''\n})\n```\n\n3. **Destructuring reactive objects:**\n```typescript\n// Bad - loses reactivity\nconst { count } = reactive({ count: 0 })\n\n// Good - use toRefs\nconst state = reactive({ count: 0 })\nconst { count } = toRefs(state)\n\n// Or use computed\nconst count = computed(() => state.count)\n```\n\n### Problem: Infinite Update Loop\n\n**Symptom:** Console shows \"Maximum recursive updates exceeded\"\n\n**Common Causes:**\n\n1. **Modifying reactive state in watch without guard:**\n```typescript\n// Bad - infinite loop\nwatch(count, () => {\n  count.value++  // Triggers watch again!\n})\n\n// Good - add condition\nwatch(count, (newVal, oldVal) => {\n  if (newVal < 100) {\n    count.value++\n  }\n})\n```\n\n2. **Computed with side effects:**\n```typescript\n// Bad - don't modify state in computed\nconst doubled = computed(() => {\n  count.value = count.value * 2  // Side effect!\n  return count.value\n})\n\n// Good - pure computed\nconst doubled = computed(() => count.value * 2)\n```\n\n---\n\n## Props Issues\n\n### Problem: Prop Not Updating\n\n**Symptom:** Parent changes prop but child doesn't reflect change.\n\n**Common Causes:**\n\n1. **Caching prop in local state:**\n```typescript\n// Bad - only captures initial value\nconst props = defineProps<{ value: string }>()\nconst localValue = ref(props.value)  // Not reactive to prop changes!\n\n// Good - use computed\nconst localValue = computed(() => props.value)\n\n// Or watch for updates\nwatch(() => props.value, (newVal) => {\n  localValue.value = newVal\n})\n```\n\n2. **Object/Array prop mutation:**\n```typescript\n// Bad - mutating prop\nprops.items.push(newItem)\n\n// Good - emit to parent\nemit('update:items', [...props.items, newItem])\n```\n\n### Problem: Default Props Not Working\n\n```typescript\n// Wrong - defaults don't work with interface-only props\nconst props = defineProps<{ count?: number }>()\n// props.count is undefined, not 0\n\n// Correct - use withDefaults\nconst props = withDefaults(defineProps<{ count?: number }>(), {\n  count: 0\n})\n```\n\n---\n\n## Lifecycle Issues\n\n### Problem: DOM Element is Null\n\n**Symptom:** `ref.value` is null when trying to access DOM element.\n\n**Cause:** Accessing before component is mounted.\n\n```typescript\n// Bad - runs before mount\nconst inputRef = ref<HTMLInputElement | null>(null)\ninputRef.value?.focus()  // null!\n\n// Good - wait for mount\nonMounted(() => {\n  inputRef.value?.focus()\n})\n```\n\n### Problem: Event Listeners Not Removed\n\n**Symptom:** Memory leaks, duplicate handlers.\n\n```typescript\n// Bad - listener never removed\nonMounted(() => {\n  window.addEventListener('resize', handleResize)\n})\n\n// Good - cleanup on unmount\nonMounted(() => {\n  window.addEventListener('resize', handleResize)\n})\n\nonUnmounted(() => {\n  window.removeEventListener('resize', handleResize)\n})\n\n// Best - use composable\nfunction useWindowResize(callback: () => void) {\n  onMounted(() => window.addEventListener('resize', callback))\n  onUnmounted(() => window.removeEventListener('resize', callback))\n}\n```\n\n---\n\n## Nuxt-Specific Issues\n\n### Problem: Hydration Mismatch\n\n**Symptom:** Console warning about hydration mismatch.\n\n**Common Causes:**\n\n1. **Using browser-only APIs during SSR:**\n```typescript\n// Bad - window doesn't exist on server\nconst width = ref(window.innerWidth)\n\n// Good - check for client\nconst width = ref(0)\nonMounted(() => {\n  width.value = window.innerWidth\n})\n\n// Or use process.client\nif (process.client) {\n  width.value = window.innerWidth\n}\n```\n\n2. **Random values differing server/client:**\n```typescript\n// Bad - different on server and client\nconst id = ref(Math.random())\n\n// Good - generate on client only\nconst id = ref('')\nonMounted(() => {\n  id.value = crypto.randomUUID()\n})\n```\n\n3. **Date formatting:**\n```typescript\n// Bad - timezone differences\nconst formatted = new Date().toLocaleString()\n\n// Good - consistent formatting or client-only\nconst formatted = ref('')\nonMounted(() => {\n  formatted.value = new Date().toLocaleString()\n})\n```\n\n### Problem: useFetch Not Triggering\n\n**Symptom:** Data not fetching or not updating.\n\n```typescript\n// Issue: Using static URL with dynamic value\nconst id = ref(1)\nconst { data } = await useFetch(`/api/users/${id.value}`)  // Only fetches once!\n\n// Solution 1: Use computed URL\nconst { data } = await useFetch(() => `/api/users/${id.value}`)\n\n// Solution 2: Use watch option\nconst { data } = await useFetch(`/api/users/${id.value}`, {\n  watch: [id]\n})\n```\n\n### Problem: Nuxt Auto-Import Not Working\n\n**Symptom:** \"X is not defined\" error.\n\n**Check:**\n1. File is in correct directory (`composables/`, `utils/`)\n2. File is named correctly (index files need re-export)\n3. Restart dev server after adding new composables\n\n```bash\n# Restart dev server\nnpm run dev\n```\n\n---\n\n## TypeScript Issues\n\n### Problem: Type 'X' is Not Assignable\n\n**Common in Vue:**\n\n```typescript\n// Issue: ref type inference\nconst count = ref(null)  // Ref<null>\ncount.value = 5  // Error!\n\n// Fix: explicit type\nconst count = ref<number | null>(null)\ncount.value = 5  // OK\n```\n\n### Problem: Property Does Not Exist on Type\n\n```typescript\n// Issue: accessing possibly undefined\nconst { data } = await useFetch<User>('/api/user')\nconsole.log(data.value.name)  // Error: possibly undefined\n\n// Fix: optional chaining or guard\nconsole.log(data.value?.name)\n\n// Or type assertion when sure\nif (data.value) {\n  console.log(data.value.name)\n}\n```\n\n---\n\n## Performance Issues\n\n### Problem: Slow Rendering\n\n**Debugging Steps:**\n\n1. **Check Vue DevTools Performance tab**\n2. **Look for unnecessary re-renders:**\n```typescript\n// Bad - creates new function each render\n<button @click=\"() => handleClick(item)\">\n\n// Good - bind in advance\nconst handlers = computed(() =>\n  items.value.map(item => () => handleClick(item))\n)\n```\n\n3. **Use `v-once` for static content:**\n```vue\n<div v-once>{{ staticContent }}</div>\n```\n\n4. **Use `v-memo` for expensive lists:**\n```vue\n<div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id]\">\n  <ExpensiveComponent :item=\"item\" />\n</div>\n```\n\n### Problem: Large Bundle Size\n\n**Debugging:**\n\n```bash\n# Analyze bundle\nnpx nuxi analyze\n```\n\n**Solutions:**\n\n1. **Lazy load components:**\n```typescript\nconst HeavyComponent = defineAsyncComponent(() =>\n  import('./HeavyComponent.vue')\n)\n```\n\n2. **Dynamic imports:**\n```typescript\nconst { heavyFunction } = await import('./heavy-utils')\n```\n\n---\n\n## Debugging Tools\n\n### Vue DevTools\n\n- **Components Tab:** Inspect component hierarchy and state\n- **Timeline Tab:** Track events and state changes\n- **Performance Tab:** Profile render performance\n\n### Console Logging\n\n```typescript\n// Debug reactive state\nconsole.log(toRaw(reactiveObject))\n\n// Debug computed\nwatchEffect(() => {\n  console.log('Value changed:', someRef.value)\n})\n```\n\n### Nuxt DevTools\n\n```bash\n# Enable in nuxt.config.ts\nexport default defineNuxtConfig({\n  devtools: { enabled: true }\n})\n```\n\nFeatures:\n- Component inspector\n- Route visualization\n- API playground\n- State management overview\n\n---\n\n## Quick Checklist for Debugging\n\n1. [ ] Check browser console for errors\n2. [ ] Check Vue DevTools for component state\n3. [ ] Verify reactivity (use `console.log(toRaw(state))`)\n4. [ ] Check if issue is SSR-related (disable SSR temporarily)\n5. [ ] Verify types match expected values\n6. [ ] Check lifecycle timing (mounted vs immediate)\n7. [ ] Look for hydration warnings in console\n8. [ ] Restart dev server after config changes\n",
        "vue-development-skill/skills/vue-development/e2e/acceptance-criteria.md": "# Acceptance Criteria Parsing Guide\n\nThis guide explains how to extract and validate Gherkin acceptance criteria from user stories.\n\n## User Story Input Format\n\nThe skill expects user stories in this format:\n\n```markdown\n## {STORY_ID}: {Story Title}\n\n> **As a** {persona},\n> **I want** {goal},\n> **So that** {benefit}.\n\n### Acceptance Criteria\n\n#### AC1: {Criterion Title}\n\n```gherkin\nGiven {precondition}\nWhen {action}\nThen {expected result}\n```\n\n#### AC2: {Criterion Title}\n\n```gherkin\nGiven {precondition}\nWhen {action}\nAnd {additional action}\nThen {expected result}\nAnd {additional result}\n```\n```\n\n---\n\n## Parsing Steps\n\n### Step 1: Extract Story Metadata\n\nFrom the user story header, extract:\n\n| Field | Pattern | Example |\n|-------|---------|---------|\n| Story ID | `## {ID}:` | `US-001` |\n| Title | `## {ID}: {Title}` | `User Login` |\n| Persona | `As a {persona}` | `registered user` |\n| Goal | `I want {goal}` | `to login with my credentials` |\n| Benefit | `So that {benefit}` | `I can access my account` |\n\n### Step 2: Extract Acceptance Criteria\n\nFor each `#### AC{n}:` section:\n\n1. **ID**: Extract `AC1`, `AC2`, etc.\n2. **Title**: Text after the colon\n3. **Gherkin**: Content within ` ```gherkin ` block\n\n### Step 3: Parse Gherkin Statements\n\nEach Gherkin block contains:\n\n| Keyword | Purpose | Example |\n|---------|---------|---------|\n| `Given` | Precondition/setup | `Given I am on the login page` |\n| `When` | Action/trigger | `When I click \"Login\"` |\n| `And` | Additional Given/When/Then | `And I fill \"email\" with \"x\"` |\n| `Then` | Expected outcome | `Then I see \"Welcome\"` |\n\n**Parse into structured format:**\n\n```json\n{\n  \"id\": \"AC1\",\n  \"title\": \"Successful login\",\n  \"steps\": [\n    { \"keyword\": \"Given\", \"text\": \"I am on the login page\" },\n    { \"keyword\": \"When\", \"text\": \"I fill \\\"email\\\" with \\\"user@example.com\\\"\" },\n    { \"keyword\": \"And\", \"text\": \"I fill \\\"password\\\" with \\\"password123\\\"\" },\n    { \"keyword\": \"And\", \"text\": \"I click \\\"Login\\\"\" },\n    { \"keyword\": \"Then\", \"text\": \"I am redirected to the dashboard\" },\n    { \"keyword\": \"And\", \"text\": \"I see \\\"Welcome back\\\"\" }\n  ]\n}\n```\n\n---\n\n## Mapping AC to Tests\n\n### Unit Tests (Vitest)\n\nAcceptance criteria inform what unit tests to write:\n\n| Gherkin | Unit Test Focus |\n|---------|-----------------|\n| `Given form is empty` | Test initial state |\n| `When I click submit` | Test emit/handler |\n| `Then error is shown` | Test conditional rendering |\n| `Then field is disabled` | Test computed/reactive state |\n\n**Example mapping:**\n\n```gherkin\nGiven I am on the login form\nWhen I enter invalid email \"not-an-email\"\nAnd I click \"Login\"\nThen I see \"Please enter a valid email\"\n```\n\n**Unit test:**\n```typescript\nit('shows validation error for invalid email', async () => {\n  const wrapper = mount(LoginForm)\n  await wrapper.find('[name=\"email\"]').setValue('not-an-email')\n  await wrapper.find('button').trigger('click')\n  expect(wrapper.text()).toContain('Please enter a valid email')\n})\n```\n\n### E2E Tests (Playwright MCP)\n\nAcceptance criteria execute directly via Playwright:\n\n```gherkin\nGiven I am on the login page\nWhen I fill \"email\" with \"user@example.com\"\nAnd I click \"Login\"\nThen I am redirected to the dashboard\n```\n\n**Playwright execution:**\n```\n1. mcp__playwright__browser_navigate  /login\n2. mcp__playwright__browser_fill  email field\n3. mcp__playwright__browser_click  Login button\n4. mcp__playwright__browser_snapshot  verify /dashboard URL\n```\n\n---\n\n## AC Categories\n\n### Happy Path (Required)\n\nEvery story needs at least one happy path AC:\n\n```gherkin\n# AC1: Successful completion\nGiven {valid preconditions}\nWhen {correct user action}\nThen {successful outcome}\n```\n\n### Validation/Error (Recommended)\n\nTest invalid inputs and error states:\n\n```gherkin\n# AC2: Invalid input handling\nGiven {preconditions}\nWhen {invalid user action}\nThen {appropriate error message}\nAnd {user can retry}\n```\n\n### Edge Cases (As Needed)\n\nTest boundary conditions:\n\n```gherkin\n# AC3: Empty state\nGiven {no data exists}\nWhen {user views the page}\nThen {empty state message shown}\n\n# AC4: Maximum limit\nGiven {data at max capacity}\nWhen {user tries to add more}\nThen {limit message shown}\n```\n\n### Accessibility (Recommended)\n\nTest keyboard and screen reader support:\n\n```gherkin\n# AC5: Keyboard navigation\nGiven I am on the form\nWhen I press Tab\nThen focus moves to next field\nAnd focus indicator is visible\n```\n\n---\n\n## Validation Checklist\n\nBefore executing E2E tests, verify:\n\n- [ ] All `Given` steps have corresponding setup\n- [ ] All `When` steps map to Playwright actions\n- [ ] All `Then` steps have measurable assertions\n- [ ] Happy path AC exists\n- [ ] Error scenarios covered\n- [ ] Test data is available (users, etc.)\n\n---\n\n## Complete Example\n\n### Input: User Story\n\n```markdown\n## US-042: Password Reset\n\n> **As a** registered user,\n> **I want** to reset my forgotten password,\n> **So that** I can regain access to my account.\n\n### Acceptance Criteria\n\n#### AC1: Request password reset\n\n```gherkin\nGiven I am on the login page\nWhen I click \"Forgot password?\"\nThen I see the password reset form\nAnd I see an email input field\n```\n\n#### AC2: Submit reset request\n\n```gherkin\nGiven I am on the password reset form\nWhen I fill \"email\" with \"user@example.com\"\nAnd I click \"Send reset link\"\nThen I see \"Check your email for reset instructions\"\n```\n\n#### AC3: Invalid email\n\n```gherkin\nGiven I am on the password reset form\nWhen I fill \"email\" with \"not-registered@example.com\"\nAnd I click \"Send reset link\"\nThen I see \"No account found with this email\"\n```\n```\n\n### Parsed Structure\n\n```json\n{\n  \"story\": {\n    \"id\": \"US-042\",\n    \"title\": \"Password Reset\",\n    \"persona\": \"registered user\",\n    \"goal\": \"to reset my forgotten password\",\n    \"benefit\": \"I can regain access to my account\"\n  },\n  \"acceptance_criteria\": [\n    {\n      \"id\": \"AC1\",\n      \"title\": \"Request password reset\",\n      \"type\": \"happy_path\",\n      \"steps\": [\n        { \"keyword\": \"Given\", \"text\": \"I am on the login page\" },\n        { \"keyword\": \"When\", \"text\": \"I click \\\"Forgot password?\\\"\" },\n        { \"keyword\": \"Then\", \"text\": \"I see the password reset form\" },\n        { \"keyword\": \"And\", \"text\": \"I see an email input field\" }\n      ]\n    },\n    {\n      \"id\": \"AC2\",\n      \"title\": \"Submit reset request\",\n      \"type\": \"happy_path\",\n      \"steps\": [\n        { \"keyword\": \"Given\", \"text\": \"I am on the password reset form\" },\n        { \"keyword\": \"When\", \"text\": \"I fill \\\"email\\\" with \\\"user@example.com\\\"\" },\n        { \"keyword\": \"And\", \"text\": \"I click \\\"Send reset link\\\"\" },\n        { \"keyword\": \"Then\", \"text\": \"I see \\\"Check your email for reset instructions\\\"\" }\n      ]\n    },\n    {\n      \"id\": \"AC3\",\n      \"title\": \"Invalid email\",\n      \"type\": \"error\",\n      \"steps\": [\n        { \"keyword\": \"Given\", \"text\": \"I am on the password reset form\" },\n        { \"keyword\": \"When\", \"text\": \"I fill \\\"email\\\" with \\\"not-registered@example.com\\\"\" },\n        { \"keyword\": \"And\", \"text\": \"I click \\\"Send reset link\\\"\" },\n        { \"keyword\": \"Then\", \"text\": \"I see \\\"No account found with this email\\\"\" }\n      ]\n    }\n  ]\n}\n```\n\n### E2E Execution Plan\n\n```\nAC1: Request password reset\n  1. Navigate to /login\n  2. Click \"Forgot password?\" link\n  3. Snapshot: verify reset form visible\n  4. Snapshot: verify email input exists\n  Result: PASS/FAIL\n\nAC2: Submit reset request\n  1. Navigate to /forgot-password (or continue from AC1)\n  2. Fill email with \"user@example.com\"\n  3. Click \"Send reset link\"\n  4. Snapshot: verify success message\n  Result: PASS/FAIL\n\nAC3: Invalid email\n  1. Navigate to /forgot-password\n  2. Fill email with \"not-registered@example.com\"\n  3. Click \"Send reset link\"\n  4. Snapshot: verify error message\n  Result: PASS/FAIL\n\nOverall: 3/3 PASS  E2E Validation PASS\n```\n",
        "vue-development-skill/skills/vue-development/e2e/playwright-patterns.md": "# Gherkin to Playwright Test File Generation\n\nThis guide shows how to generate Playwright test files from Gherkin acceptance criteria.\n\n## Output Location\n\nE2E test files are written to: `tests/e2e/{story-id}-{feature-slug}.spec.ts`\n\nExamples:\n- `tests/e2e/us-001-user-login.spec.ts`\n- `tests/e2e/us-042-password-reset.spec.ts`\n- `tests/e2e/us-103-checkout-flow.spec.ts`\n\n---\n\n## Quick Reference\n\n| Gherkin Pattern | Playwright Code |\n|-----------------|-----------------|\n| `Given I am on \"{url}\"` | `await page.goto('{url}')` |\n| `When I click \"{text}\"` | `await page.click('text={text}')` |\n| `When I click the \"{selector}\" button` | `await page.click('{selector}')` |\n| `When I fill \"{field}\" with \"{value}\"` | `await page.fill('[name=\"{field}\"]', '{value}')` |\n| `When I select \"{option}\" from \"{field}\"` | `await page.selectOption('[name=\"{field}\"]', '{option}')` |\n| `When I press \"{key}\"` | `await page.keyboard.press('{key}')` |\n| `Then I see \"{text}\"` | `await expect(page.locator('text={text}')).toBeVisible()` |\n| `Then I am redirected to \"{url}\"` | `await expect(page).toHaveURL(/{url}/)` |\n| `Then the \"{element}\" is visible` | `await expect(page.locator('{element}')).toBeVisible()` |\n| `Then the \"{element}\" is not visible` | `await expect(page.locator('{element}')).not.toBeVisible()` |\n\n---\n\n## Test File Structure\n\n### Template\n\n```typescript\n// tests/e2e/{story-id}-{feature-slug}.spec.ts\nimport { test, expect } from '@playwright/test'\n\n/**\n * {STORY_ID}: {Story Title}\n * As a {persona}, I want {goal}, so that {benefit}.\n */\ntest.describe('{STORY_ID}: {Story Title}', () => {\n\n  test('{AC_ID}: {AC Title}', async ({ page }) => {\n    // Given {precondition}\n    // Playwright code...\n\n    // When {action}\n    // Playwright code...\n\n    // Then {expected result}\n    // Playwright code...\n  })\n\n})\n```\n\n### Complete Example\n\n**Input: User Story**\n\n```markdown\n## US-001: User Login\n\n> **As a** registered user,\n> **I want** to login with my credentials,\n> **So that** I can access my account.\n\n### Acceptance Criteria\n\n#### AC1: Successful login\n\n```gherkin\nGiven I am on the login page\nWhen I fill \"email\" with \"user@example.com\"\nAnd I fill \"password\" with \"password123\"\nAnd I click \"Login\"\nThen I am redirected to the dashboard\nAnd I see \"Welcome back\"\n```\n\n#### AC2: Invalid password\n\n```gherkin\nGiven I am on the login page\nWhen I fill \"email\" with \"user@example.com\"\nAnd I fill \"password\" with \"wrong\"\nAnd I click \"Login\"\nThen I see \"Invalid credentials\"\n```\n```\n\n**Output: Test File**\n\n```typescript\n// tests/e2e/us-001-user-login.spec.ts\nimport { test, expect } from '@playwright/test'\n\n/**\n * US-001: User Login\n * As a registered user, I want to login with my credentials,\n * so that I can access my account.\n */\ntest.describe('US-001: User Login', () => {\n\n  test('AC1: Successful login', async ({ page }) => {\n    // Given I am on the login page\n    await page.goto('/login')\n\n    // When I fill \"email\" with \"user@example.com\"\n    await page.fill('[name=\"email\"]', 'user@example.com')\n\n    // And I fill \"password\" with \"password123\"\n    await page.fill('[name=\"password\"]', 'password123')\n\n    // And I click \"Login\"\n    await page.click('button:has-text(\"Login\")')\n\n    // Then I am redirected to the dashboard\n    await expect(page).toHaveURL(/dashboard/)\n\n    // And I see \"Welcome back\"\n    await expect(page.locator('text=Welcome back')).toBeVisible()\n  })\n\n  test('AC2: Invalid password', async ({ page }) => {\n    // Given I am on the login page\n    await page.goto('/login')\n\n    // When I fill \"email\" with \"user@example.com\"\n    await page.fill('[name=\"email\"]', 'user@example.com')\n\n    // And I fill \"password\" with \"wrong\"\n    await page.fill('[name=\"password\"]', 'wrong')\n\n    // And I click \"Login\"\n    await page.click('button:has-text(\"Login\")')\n\n    // Then I see \"Invalid credentials\"\n    await expect(page.locator('text=Invalid credentials')).toBeVisible()\n  })\n\n})\n```\n\n---\n\n## Gherkin to Playwright Mappings\n\n### Navigation\n\n```gherkin\nGiven I am on the login page\nGiven I am on \"/dashboard\"\nGiven I am on the home page\n```\n\n```typescript\nawait page.goto('/login')\nawait page.goto('/dashboard')\nawait page.goto('/')\n```\n\n### Click Actions\n\n```gherkin\nWhen I click \"Submit\"\nWhen I click the login button\nWhen I click on \"Save Changes\"\nWhen I click the \".cancel-btn\" button\n```\n\n```typescript\nawait page.click('text=Submit')\nawait page.click('button:has-text(\"Login\")')\nawait page.click('text=Save Changes')\nawait page.click('.cancel-btn')\n```\n\n### Form Input\n\n```gherkin\nWhen I fill \"email\" with \"user@example.com\"\nWhen I enter \"password123\" in the password field\nWhen I type \"search query\" in the search box\nWhen I clear the \"username\" field\n```\n\n```typescript\nawait page.fill('[name=\"email\"]', 'user@example.com')\nawait page.fill('#password', 'password123')\nawait page.fill('[placeholder=\"Search\"]', 'search query')\nawait page.fill('[name=\"username\"]', '')\n```\n\n### Select/Dropdown\n\n```gherkin\nWhen I select \"United States\" from \"country\"\nWhen I choose \"Large\" from the size dropdown\n```\n\n```typescript\nawait page.selectOption('[name=\"country\"]', 'United States')\nawait page.selectOption('#size', 'Large')\n```\n\n### Keyboard Actions\n\n```gherkin\nWhen I press Enter\nWhen I press Tab\nWhen I press Escape\n```\n\n```typescript\nawait page.keyboard.press('Enter')\nawait page.keyboard.press('Tab')\nawait page.keyboard.press('Escape')\n```\n\n### Checkbox/Radio\n\n```gherkin\nWhen I check \"remember me\"\nWhen I uncheck \"subscribe to newsletter\"\nWhen I select the \"express\" shipping option\n```\n\n```typescript\nawait page.check('[name=\"remember\"]')\nawait page.uncheck('[name=\"subscribe\"]')\nawait page.check('input[value=\"express\"]')\n```\n\n### Text Assertions\n\n```gherkin\nThen I see \"Welcome back\"\nThen I see the message \"Login successful\"\nThen the error \"Invalid password\" is displayed\n```\n\n```typescript\nawait expect(page.locator('text=Welcome back')).toBeVisible()\nawait expect(page.locator('text=Login successful')).toBeVisible()\nawait expect(page.locator('text=Invalid password')).toBeVisible()\n```\n\n### URL Assertions\n\n```gherkin\nThen I am redirected to the dashboard\nThen I am redirected to \"/profile\"\nThen I remain on the login page\n```\n\n```typescript\nawait expect(page).toHaveURL(/dashboard/)\nawait expect(page).toHaveURL('/profile')\nawait expect(page).toHaveURL(/login/)\n```\n\n### Element State Assertions\n\n```gherkin\nThen the submit button is disabled\nThen the loading spinner is visible\nThen the error message is not visible\nThen the \"email\" field is empty\n```\n\n```typescript\nawait expect(page.locator('button[type=\"submit\"]')).toBeDisabled()\nawait expect(page.locator('.loading-spinner')).toBeVisible()\nawait expect(page.locator('.error-message')).not.toBeVisible()\nawait expect(page.locator('[name=\"email\"]')).toHaveValue('')\n```\n\n### Form Value Assertions\n\n```gherkin\nThen the email field contains \"user@example.com\"\nThen the checkbox is checked\nThen the dropdown shows \"Option A\"\n```\n\n```typescript\nawait expect(page.locator('[name=\"email\"]')).toHaveValue('user@example.com')\nawait expect(page.locator('[name=\"remember\"]')).toBeChecked()\nawait expect(page.locator('select')).toHaveValue('Option A')\n```\n\n### Count Assertions\n\n```gherkin\nThen I see 3 items in the list\nThen there are no error messages\nThen I see at least 1 result\n```\n\n```typescript\nawait expect(page.locator('.list-item')).toHaveCount(3)\nawait expect(page.locator('.error')).toHaveCount(0)\nexpect(await page.locator('.result').count()).toBeGreaterThanOrEqual(1)\n```\n\n---\n\n## Element Selectors\n\nUse these selector strategies in order of preference:\n\n### 1. Test IDs (Preferred)\n\n```vue\n<button data-testid=\"submit-login\">Login</button>\n```\n```typescript\nawait page.click('[data-testid=\"submit-login\"]')\n```\n\n### 2. Role + Text\n\n```vue\n<button>Submit</button>\n```\n```typescript\nawait page.click('button:has-text(\"Submit\")')\n```\n\n### 3. Name Attribute\n\n```vue\n<input name=\"email\" />\n```\n```typescript\nawait page.fill('[name=\"email\"]', 'value')\n```\n\n### 4. Placeholder\n\n```vue\n<input placeholder=\"Enter email\" />\n```\n```typescript\nawait page.fill('[placeholder=\"Enter email\"]', 'value')\n```\n\n### 5. ID\n\n```vue\n<input id=\"email\" />\n```\n```typescript\nawait page.fill('#email', 'value')\n```\n\n### 6. Text Content\n\n```vue\n<a>Click here</a>\n```\n```typescript\nawait page.click('text=Click here')\n```\n\n---\n\n## Waiting Patterns\n\n### Implicit Waits\n\nPlaywright auto-waits for elements. These are usually sufficient:\n\n```typescript\nawait page.click('button')  // Waits for button to be clickable\nawait expect(page.locator('text=Success')).toBeVisible()  // Waits up to timeout\n```\n\n### Explicit Waits\n\nFor specific scenarios:\n\n```typescript\n// Wait for navigation\nawait page.waitForURL(/dashboard/)\n\n// Wait for element\nawait page.waitForSelector('.modal')\n\n// Wait for network idle\nawait page.waitForLoadState('networkidle')\n\n// Wait for specific response\nawait page.waitForResponse(response => response.url().includes('/api/login'))\n```\n\n---\n\n## Running Tests\n\n### Commands\n\n```bash\n# Run specific test file\nnpx playwright test tests/e2e/us-001-user-login.spec.ts\n\n# Run all E2E tests\nnpx playwright test tests/e2e/\n\n# Run with headed browser (visible)\nnpx playwright test tests/e2e/us-001-user-login.spec.ts --headed\n\n# Run with UI mode for debugging\nnpx playwright test tests/e2e/us-001-user-login.spec.ts --ui\n\n# Run specific test by name\nnpx playwright test -g \"AC1: Successful login\"\n```\n\n### Expected Output\n\n```\nRunning 2 tests using 1 worker\n\n   US-001: User Login  AC1: Successful login (2.1s)\n   US-001: User Login  AC2: Invalid password (1.8s)\n\n  2 passed (4.2s)\n```\n\n---\n\n## Tips for Reliable Tests\n\n1. **Keep Gherkin as comments**: Preserve the original Gherkin in comments for traceability\n2. **Use data-testid**: Add `data-testid` attributes to components for stable selectors\n3. **One AC = One test**: Each acceptance criterion becomes exactly one test\n4. **Preserve assertion order**: Match Then assertions to Gherkin Then statements in order\n5. **Handle async operations**: Use Playwright's built-in waiting or explicit waits for async UI\n6. **Avoid hardcoded waits**: Never use `page.waitForTimeout()` - use proper assertions instead\n",
        "vue-development-skill/skills/vue-development/patterns/composition-api.md": "# Vue 3 Composition API Patterns\n\nThis guide covers best practices and patterns for the Vue 3 Composition API with `<script setup>`.\n\n## Basic Component Structure\n\n### Standard Template\n\n```vue\n<script setup lang=\"ts\">\n// 1. Type imports\nimport type { User } from '@/types'\n\n// 2. Component imports\nimport UserAvatar from './UserAvatar.vue'\n\n// 3. Composable imports\nimport { useUser } from '@/composables/useUser'\n\n// 4. Props definition\ninterface Props {\n  userId: number\n  showActions?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  showActions: true\n})\n\n// 5. Emits definition\nconst emit = defineEmits<{\n  select: [user: User]\n  delete: [userId: number]\n}>()\n\n// 6. Composables\nconst { user, loading, error } = useUser(props.userId)\n\n// 7. Reactive state\nconst isEditing = ref(false)\n\n// 8. Computed properties\nconst displayName = computed(() => user.value?.name ?? 'Unknown')\n\n// 9. Methods\nfunction handleSelect() {\n  if (user.value) {\n    emit('select', user.value)\n  }\n}\n\n// 10. Lifecycle hooks\nonMounted(() => {\n  console.log('Component mounted')\n})\n</script>\n\n<template>\n  <div class=\"user-card\">\n    <!-- Template content -->\n  </div>\n</template>\n\n<style scoped>\n/* Scoped styles */\n</style>\n```\n\n---\n\n## Props Patterns\n\n### Typed Props with Defaults\n\n```typescript\ninterface Props {\n  // Required prop\n  title: string\n\n  // Optional with type\n  subtitle?: string\n\n  // Union types\n  variant: 'primary' | 'secondary' | 'danger'\n\n  // Complex types\n  items: Item[]\n\n  // Optional with default handled by withDefaults\n  disabled?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  subtitle: '',\n  variant: 'primary',\n  items: () => [],  // Use factory for arrays/objects\n  disabled: false\n})\n```\n\n### Props Validation with Runtime Checks\n\n```typescript\n// When you need runtime validation beyond types\nconst props = defineProps({\n  age: {\n    type: Number,\n    required: true,\n    validator: (value: number) => value >= 0 && value <= 150\n  }\n})\n```\n\n---\n\n## Emits Patterns\n\n### Typed Emits\n\n```typescript\n// Simple events\nconst emit = defineEmits<{\n  click: []\n  change: [value: string]\n}>()\n\n// Complex payloads\nconst emit = defineEmits<{\n  submit: [data: FormData]\n  error: [error: Error, context: string]\n  update: [field: string, value: unknown]\n}>()\n\n// Usage\nemit('submit', formData)\nemit('error', new Error('Failed'), 'validation')\n```\n\n### v-model Support\n\n```typescript\n// Single v-model\nconst props = defineProps<{\n  modelValue: string\n}>()\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string]\n}>()\n\n// Multiple v-models\nconst props = defineProps<{\n  modelValue: string\n  title: string\n}>()\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string]\n  'update:title': [value: string]\n}>()\n```\n\n---\n\n## Reactive State Patterns\n\n### ref vs reactive\n\n```typescript\n// Use ref for primitives\nconst count = ref(0)\nconst isLoading = ref(false)\nconst name = ref('')\n\n// Use reactive for objects (when you don't need to reassign)\nconst form = reactive({\n  username: '',\n  email: '',\n  password: ''\n})\n\n// Use ref for objects when you need to reassign\nconst user = ref<User | null>(null)\nuser.value = await fetchUser()  // Can reassign\n```\n\n### Computed Properties\n\n```typescript\n// Basic computed\nconst fullName = computed(() => `${firstName.value} ${lastName.value}`)\n\n// Writable computed\nconst fullName = computed({\n  get: () => `${firstName.value} ${lastName.value}`,\n  set: (value: string) => {\n    const [first, last] = value.split(' ')\n    firstName.value = first\n    lastName.value = last\n  }\n})\n```\n\n### Watchers\n\n```typescript\n// Watch single ref\nwatch(searchQuery, (newValue, oldValue) => {\n  performSearch(newValue)\n})\n\n// Watch with options\nwatch(searchQuery, (value) => {\n  performSearch(value)\n}, { immediate: true, deep: false })\n\n// Watch multiple sources\nwatch([firstName, lastName], ([newFirst, newLast]) => {\n  updateFullName(newFirst, newLast)\n})\n\n// Watch reactive object\nwatch(\n  () => form.username,\n  (newUsername) => {\n    validateUsername(newUsername)\n  }\n)\n\n// watchEffect - runs immediately and tracks dependencies\nwatchEffect(() => {\n  console.log(`Count is: ${count.value}`)\n})\n```\n\n---\n\n## Composables\n\n### Basic Composable Structure\n\n```typescript\n// composables/useCounter.ts\nimport { ref, computed } from 'vue'\n\nexport function useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n\n  const doubleCount = computed(() => count.value * 2)\n\n  function increment() {\n    count.value++\n  }\n\n  function decrement() {\n    count.value--\n  }\n\n  function reset() {\n    count.value = initialValue\n  }\n\n  return {\n    count: readonly(count),  // Expose as readonly\n    doubleCount,\n    increment,\n    decrement,\n    reset\n  }\n}\n```\n\n### Composable with Async Data\n\n```typescript\n// composables/useUser.ts\nexport function useUser(userId: MaybeRef<number>) {\n  const user = ref<User | null>(null)\n  const loading = ref(false)\n  const error = ref<Error | null>(null)\n\n  async function fetchUser() {\n    loading.value = true\n    error.value = null\n\n    try {\n      const id = unref(userId)\n      user.value = await api.getUser(id)\n    } catch (e) {\n      error.value = e as Error\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Watch for userId changes\n  watch(() => unref(userId), fetchUser, { immediate: true })\n\n  return {\n    user: readonly(user),\n    loading: readonly(loading),\n    error: readonly(error),\n    refetch: fetchUser\n  }\n}\n```\n\n### Composable with Cleanup\n\n```typescript\n// composables/useEventListener.ts\nexport function useEventListener<K extends keyof WindowEventMap>(\n  event: K,\n  handler: (e: WindowEventMap[K]) => void\n) {\n  onMounted(() => {\n    window.addEventListener(event, handler)\n  })\n\n  onUnmounted(() => {\n    window.removeEventListener(event, handler)\n  })\n}\n\n// composables/useInterval.ts\nexport function useInterval(callback: () => void, ms: number) {\n  const intervalId = ref<number | null>(null)\n\n  function start() {\n    stop()\n    intervalId.value = window.setInterval(callback, ms)\n  }\n\n  function stop() {\n    if (intervalId.value !== null) {\n      clearInterval(intervalId.value)\n      intervalId.value = null\n    }\n  }\n\n  onMounted(start)\n  onUnmounted(stop)\n\n  return { start, stop }\n}\n```\n\n---\n\n## Lifecycle Hooks\n\n```typescript\nimport {\n  onMounted,\n  onUpdated,\n  onUnmounted,\n  onBeforeMount,\n  onBeforeUpdate,\n  onBeforeUnmount\n} from 'vue'\n\n// Most common\nonMounted(() => {\n  // DOM is ready, fetch data, setup listeners\n})\n\nonUnmounted(() => {\n  // Cleanup: remove listeners, cancel requests\n})\n\n// Less common but useful\nonBeforeUnmount(() => {\n  // Save state before component is removed\n})\n```\n\n---\n\n## Template Refs\n\n```typescript\n// Single element ref\nconst inputRef = ref<HTMLInputElement | null>(null)\n\nonMounted(() => {\n  inputRef.value?.focus()\n})\n\n// Component ref\nconst childRef = ref<InstanceType<typeof ChildComponent> | null>(null)\n\nonMounted(() => {\n  childRef.value?.someMethod()\n})\n\n// Multiple refs with v-for\nconst itemRefs = ref<HTMLElement[]>([])\n\n// In template: :ref=\"(el) => itemRefs[index] = el\"\n```\n\n---\n\n## Provide/Inject\n\n```typescript\n// Parent component\nimport { provide } from 'vue'\nimport type { InjectionKey } from 'vue'\n\n// Type-safe injection key\nconst ThemeKey: InjectionKey<Ref<'light' | 'dark'>> = Symbol('theme')\n\nconst theme = ref<'light' | 'dark'>('light')\nprovide(ThemeKey, theme)\n\n// Child component (any depth)\nimport { inject } from 'vue'\n\nconst theme = inject(ThemeKey)\n// theme is Ref<'light' | 'dark'> | undefined\n\n// With default value\nconst theme = inject(ThemeKey, ref('light'))\n```\n\n---\n\n## Slots\n\n### Accessing Slots\n\n```typescript\nimport { useSlots } from 'vue'\n\nconst slots = useSlots()\n\nconst hasHeader = computed(() => !!slots.header)\nconst hasFooter = computed(() => !!slots.footer)\n```\n\n### Dynamic Slot Names\n\n```vue\n<template>\n  <div>\n    <slot :name=\"slotName\" :data=\"slotData\" />\n  </div>\n</template>\n```\n\n---\n\n## Performance Patterns\n\n### Avoiding Unnecessary Re-renders\n\n```typescript\n// Bad: Creates new object every render\nconst style = { color: 'red' }\n\n// Good: Memoize with computed\nconst style = computed(() => ({\n  color: isError.value ? 'red' : 'black'\n}))\n\n// Good: Static object outside component\nconst staticStyle = { color: 'red' }\n```\n\n### Lazy Computed\n\n```typescript\n// For expensive computations\nconst expensiveResult = computed(() => {\n  return heavyCalculation(items.value)\n})\n```\n",
        "vue-development-skill/skills/vue-development/patterns/nuxt3.md": "# Nuxt 3 Patterns\n\nThis guide covers Nuxt 3-specific patterns and best practices.\n\n## Auto-Imports\n\nNuxt 3 auto-imports Vue APIs, composables, and utilities. **Do not manually import these:**\n\n```typescript\n// No need to import these - they're auto-imported\nconst route = useRoute()\nconst router = useRouter()\nconst config = useRuntimeConfig()\nconst count = ref(0)\nconst doubled = computed(() => count.value * 2)\n```\n\n### What's Auto-Imported\n\n- **Vue**: `ref`, `reactive`, `computed`, `watch`, `onMounted`, etc.\n- **Nuxt**: `useRoute`, `useRouter`, `useFetch`, `useAsyncData`, `useState`, etc.\n- **Your composables**: Files in `composables/` directory\n- **Your utilities**: Files in `utils/` directory\n\n---\n\n## Data Fetching\n\n### useFetch - Simple API Calls\n\n```typescript\n// Basic usage\nconst { data, pending, error, refresh } = await useFetch('/api/users')\n\n// With TypeScript\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst { data: users } = await useFetch<User[]>('/api/users')\n\n// With options\nconst { data } = await useFetch('/api/users', {\n  method: 'POST',\n  body: { name: 'John' },\n  headers: {\n    'Authorization': `Bearer ${token}`\n  }\n})\n```\n\n### useFetch with Query Parameters\n\n```typescript\nconst page = ref(1)\nconst search = ref('')\n\nconst { data: users, refresh } = await useFetch('/api/users', {\n  query: {\n    page,\n    search,\n    limit: 10\n  },\n  watch: [page, search]  // Auto-refetch when these change\n})\n```\n\n### useAsyncData - Custom Async Operations\n\n```typescript\n// When you need more control\nconst { data, pending, error } = await useAsyncData(\n  'unique-key',\n  () => $fetch('/api/users')\n)\n\n// With transform\nconst { data: userNames } = await useAsyncData(\n  'user-names',\n  () => $fetch<User[]>('/api/users'),\n  {\n    transform: (users) => users.map(u => u.name)\n  }\n)\n```\n\n### Handling Fetch Errors\n\n```typescript\nconst { data, error } = await useFetch('/api/users')\n\n// In template\n<template>\n  <div v-if=\"error\">\n    <p class=\"error\">{{ error.message }}</p>\n    <button @click=\"refresh\">Retry</button>\n  </div>\n  <div v-else-if=\"pending\">Loading...</div>\n  <div v-else>\n    <UserList :users=\"data\" />\n  </div>\n</template>\n```\n\n### Lazy Fetching\n\n```typescript\n// Don't block navigation - fetch in background\nconst { data, pending } = useLazyFetch('/api/users')\n\n// Or with useAsyncData\nconst { data } = useLazyAsyncData('key', () => fetchData())\n```\n\n---\n\n## State Management\n\n### useState - Shared State\n\n```typescript\n// composables/useUser.ts\nexport const useCurrentUser = () => useState<User | null>('user', () => null)\n\n// In any component\nconst user = useCurrentUser()\nuser.value = { id: 1, name: 'John' }  // Shared across components\n```\n\n### Pinia with Nuxt\n\n```typescript\n// stores/user.ts\nexport const useUserStore = defineStore('user', () => {\n  const user = ref<User | null>(null)\n  const isLoggedIn = computed(() => user.value !== null)\n\n  async function login(credentials: Credentials) {\n    user.value = await $fetch('/api/login', {\n      method: 'POST',\n      body: credentials\n    })\n  }\n\n  function logout() {\n    user.value = null\n    navigateTo('/login')\n  }\n\n  return {\n    user,\n    isLoggedIn,\n    login,\n    logout\n  }\n})\n```\n\n---\n\n## Pages & Routing\n\n### Page Meta\n\n```vue\n<script setup lang=\"ts\">\ndefinePageMeta({\n  layout: 'admin',\n  middleware: ['auth'],\n  title: 'Dashboard'\n})\n</script>\n```\n\n### Dynamic Routes\n\n```\npages/\n users/\n    index.vue        # /users\n    [id].vue         # /users/123\n    [id]/\n        edit.vue     # /users/123/edit\n```\n\n```vue\n<!-- pages/users/[id].vue -->\n<script setup lang=\"ts\">\nconst route = useRoute()\nconst userId = computed(() => Number(route.params.id))\n\nconst { data: user } = await useFetch(`/api/users/${userId.value}`)\n</script>\n```\n\n### Navigation\n\n```typescript\n// Programmatic navigation\nconst router = useRouter()\nrouter.push('/users')\nrouter.push({ name: 'users-id', params: { id: 123 } })\n\n// Or use navigateTo\nnavigateTo('/users')\nnavigateTo({ path: '/users', query: { page: 1 } })\n```\n\n---\n\n## Middleware\n\n### Route Middleware\n\n```typescript\n// middleware/auth.ts\nexport default defineNuxtRouteMiddleware((to, from) => {\n  const user = useCurrentUser()\n\n  if (!user.value) {\n    return navigateTo('/login')\n  }\n})\n\n// middleware/admin.ts\nexport default defineNuxtRouteMiddleware((to) => {\n  const user = useCurrentUser()\n\n  if (user.value?.role !== 'admin') {\n    return abortNavigation()\n  }\n})\n```\n\n### Global Middleware\n\n```typescript\n// middleware/analytics.global.ts\nexport default defineNuxtRouteMiddleware((to) => {\n  // Runs on every route change\n  trackPageView(to.path)\n})\n```\n\n---\n\n## SEO & Meta\n\n### useSeoMeta\n\n```typescript\nuseSeoMeta({\n  title: 'My Page Title',\n  description: 'Page description for SEO',\n  ogTitle: 'My Page Title',\n  ogDescription: 'Page description for social sharing',\n  ogImage: 'https://example.com/image.png',\n  twitterCard: 'summary_large_image'\n})\n```\n\n### Dynamic Meta\n\n```typescript\nconst { data: article } = await useFetch('/api/articles/1')\n\nuseSeoMeta({\n  title: () => article.value?.title ?? 'Loading...',\n  description: () => article.value?.excerpt ?? ''\n})\n```\n\n### useHead\n\n```typescript\nuseHead({\n  title: 'My Page',\n  meta: [\n    { name: 'description', content: 'Page description' }\n  ],\n  link: [\n    { rel: 'canonical', href: 'https://example.com/page' }\n  ],\n  script: [\n    { src: 'https://example.com/script.js', defer: true }\n  ]\n})\n```\n\n---\n\n## Server Routes (API)\n\n### Basic API Route\n\n```typescript\n// server/api/users.ts\nexport default defineEventHandler(async (event) => {\n  const users = await db.users.findMany()\n  return users\n})\n```\n\n### With Parameters\n\n```typescript\n// server/api/users/[id].ts\nexport default defineEventHandler(async (event) => {\n  const id = getRouterParam(event, 'id')\n  const user = await db.users.findUnique({ where: { id: Number(id) } })\n\n  if (!user) {\n    throw createError({\n      statusCode: 404,\n      message: 'User not found'\n    })\n  }\n\n  return user\n})\n```\n\n### POST/PUT/DELETE\n\n```typescript\n// server/api/users.post.ts\nexport default defineEventHandler(async (event) => {\n  const body = await readBody(event)\n\n  const user = await db.users.create({\n    data: body\n  })\n\n  return user\n})\n\n// server/api/users/[id].delete.ts\nexport default defineEventHandler(async (event) => {\n  const id = getRouterParam(event, 'id')\n  await db.users.delete({ where: { id: Number(id) } })\n  return { success: true }\n})\n```\n\n---\n\n## Error Handling\n\n### Error Page\n\n```vue\n<!-- error.vue -->\n<script setup lang=\"ts\">\nconst props = defineProps<{\n  error: {\n    statusCode: number\n    message: string\n  }\n}>()\n\nconst handleError = () => clearError({ redirect: '/' })\n</script>\n\n<template>\n  <div class=\"error-page\">\n    <h1>{{ error.statusCode }}</h1>\n    <p>{{ error.message }}</p>\n    <button @click=\"handleError\">Go Home</button>\n  </div>\n</template>\n```\n\n### Throwing Errors\n\n```typescript\n// In API routes\nthrow createError({\n  statusCode: 400,\n  message: 'Invalid request'\n})\n\n// In pages/components\nshowError({\n  statusCode: 404,\n  message: 'Page not found'\n})\n```\n\n---\n\n## Layouts\n\n### Default Layout\n\n```vue\n<!-- layouts/default.vue -->\n<template>\n  <div>\n    <AppHeader />\n    <main>\n      <slot />\n    </main>\n    <AppFooter />\n  </div>\n</template>\n```\n\n### Custom Layouts\n\n```vue\n<!-- layouts/admin.vue -->\n<template>\n  <div class=\"admin-layout\">\n    <AdminSidebar />\n    <div class=\"admin-content\">\n      <slot />\n    </div>\n  </div>\n</template>\n\n<!-- pages/admin/dashboard.vue -->\n<script setup>\ndefinePageMeta({\n  layout: 'admin'\n})\n</script>\n```\n\n---\n\n## Runtime Config\n\n### nuxt.config.ts\n\n```typescript\nexport default defineNuxtConfig({\n  runtimeConfig: {\n    // Private keys (server-only)\n    apiSecret: process.env.API_SECRET,\n\n    // Public keys (exposed to client)\n    public: {\n      apiBase: process.env.API_BASE || 'https://api.example.com'\n    }\n  }\n})\n```\n\n### Using Config\n\n```typescript\n// In composables, pages, components\nconst config = useRuntimeConfig()\nconst apiBase = config.public.apiBase\n\n// In server routes\nexport default defineEventHandler((event) => {\n  const config = useRuntimeConfig()\n  const secret = config.apiSecret  // Server-only\n})\n```\n\n---\n\n## Plugins\n\n### Client-Only Plugin\n\n```typescript\n// plugins/analytics.client.ts\nexport default defineNuxtPlugin(() => {\n  // Only runs on client\n  initAnalytics()\n})\n```\n\n### Server-Only Plugin\n\n```typescript\n// plugins/db.server.ts\nexport default defineNuxtPlugin(() => {\n  // Only runs on server\n  initDatabase()\n})\n```\n\n### Providing Helpers\n\n```typescript\n// plugins/api.ts\nexport default defineNuxtPlugin(() => {\n  const api = {\n    get: (url: string) => $fetch(url),\n    post: (url: string, body: unknown) => $fetch(url, { method: 'POST', body })\n  }\n\n  return {\n    provide: {\n      api\n    }\n  }\n})\n\n// Usage\nconst { $api } = useNuxtApp()\nawait $api.get('/users')\n```\n",
        "vue-development-skill/skills/vue-development/patterns/typescript.md": "# TypeScript Patterns for Vue\n\nThis guide covers TypeScript best practices specifically for Vue 3 and Nuxt 3 development.\n\n## Type-Safe Props\n\n### Basic Props\n\n```typescript\ninterface Props {\n  // Required\n  title: string\n\n  // Optional\n  subtitle?: string\n\n  // With specific values\n  variant: 'primary' | 'secondary' | 'danger'\n\n  // Complex types\n  user: User\n\n  // Arrays\n  items: Item[]\n\n  // Functions\n  onSelect?: (item: Item) => void\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  subtitle: '',\n  variant: 'primary',\n  items: () => []\n})\n```\n\n### Generic Props\n\n```typescript\n// Generic component for lists\ninterface Props<T> {\n  items: T[]\n  keyField: keyof T\n}\n\nconst props = defineProps<Props<Item>>()\n```\n\n---\n\n## Type-Safe Emits\n\n### Simple Events\n\n```typescript\nconst emit = defineEmits<{\n  // No payload\n  close: []\n\n  // Single payload\n  select: [item: Item]\n\n  // Multiple payloads\n  update: [field: string, value: unknown]\n}>()\n\n// Usage\nemit('close')\nemit('select', selectedItem)\nemit('update', 'name', 'John')\n```\n\n### v-model Events\n\n```typescript\nconst props = defineProps<{\n  modelValue: string\n}>()\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string]\n}>()\n\n// In template or script\nemit('update:modelValue', newValue)\n```\n\n---\n\n## Type-Safe Composables\n\n### Return Type\n\n```typescript\ninterface UseCounterReturn {\n  count: Readonly<Ref<number>>\n  increment: () => void\n  decrement: () => void\n  reset: () => void\n}\n\nexport function useCounter(initial = 0): UseCounterReturn {\n  const count = ref(initial)\n\n  return {\n    count: readonly(count),\n    increment: () => count.value++,\n    decrement: () => count.value--,\n    reset: () => count.value = initial\n  }\n}\n```\n\n### Generic Composables\n\n```typescript\ninterface UseFetchReturn<T> {\n  data: Ref<T | null>\n  loading: Ref<boolean>\n  error: Ref<Error | null>\n  refetch: () => Promise<void>\n}\n\nexport function useFetchData<T>(url: string): UseFetchReturn<T> {\n  const data = ref<T | null>(null) as Ref<T | null>\n  const loading = ref(false)\n  const error = ref<Error | null>(null)\n\n  async function refetch() {\n    loading.value = true\n    error.value = null\n    try {\n      data.value = await $fetch<T>(url)\n    } catch (e) {\n      error.value = e as Error\n    } finally {\n      loading.value = false\n    }\n  }\n\n  refetch()\n\n  return { data, loading, error, refetch }\n}\n```\n\n### MaybeRef Pattern\n\n```typescript\nimport { unref, type MaybeRef } from 'vue'\n\nexport function useUser(userId: MaybeRef<number>) {\n  // Works with both ref and plain value\n  const id = computed(() => unref(userId))\n\n  // ...\n}\n\n// Usage\nuseUser(123)           // Plain number\nuseUser(ref(123))      // Ref<number>\nuseUser(userId)        // Can be either\n```\n\n---\n\n## Type-Safe Refs\n\n### Template Refs\n\n```typescript\n// Single element\nconst inputRef = ref<HTMLInputElement | null>(null)\n\n// Component ref\nconst modalRef = ref<InstanceType<typeof Modal> | null>(null)\n\n// Access after mount\nonMounted(() => {\n  inputRef.value?.focus()\n  modalRef.value?.open()\n})\n```\n\n### Typed Reactive\n\n```typescript\ninterface FormState {\n  username: string\n  email: string\n  age: number\n}\n\nconst form = reactive<FormState>({\n  username: '',\n  email: '',\n  age: 0\n})\n```\n\n---\n\n## Type-Safe API Calls\n\n### Response Types\n\n```typescript\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ninterface ApiResponse<T> {\n  data: T\n  meta: {\n    total: number\n    page: number\n  }\n}\n\n// In Nuxt\nconst { data } = await useFetch<ApiResponse<User[]>>('/api/users')\n\n// Type-safe access\nconst users = data.value?.data ?? []\nconst total = data.value?.meta.total ?? 0\n```\n\n### Error Types\n\n```typescript\ninterface ApiError {\n  statusCode: number\n  message: string\n  errors?: Record<string, string[]>\n}\n\nconst { error } = await useFetch('/api/users')\n\nif (error.value) {\n  const apiError = error.value.data as ApiError\n  console.log(apiError.message)\n}\n```\n\n---\n\n## Type-Safe Pinia Stores\n\n```typescript\ninterface User {\n  id: number\n  name: string\n  email: string\n  role: 'user' | 'admin'\n}\n\ninterface UserState {\n  user: User | null\n  loading: boolean\n}\n\nexport const useUserStore = defineStore('user', () => {\n  const user = ref<User | null>(null)\n  const loading = ref(false)\n\n  const isAdmin = computed(() => user.value?.role === 'admin')\n  const isLoggedIn = computed(() => user.value !== null)\n\n  async function login(email: string, password: string): Promise<boolean> {\n    loading.value = true\n    try {\n      user.value = await $fetch<User>('/api/login', {\n        method: 'POST',\n        body: { email, password }\n      })\n      return true\n    } catch {\n      return false\n    } finally {\n      loading.value = false\n    }\n  }\n\n  function logout(): void {\n    user.value = null\n  }\n\n  return {\n    user: readonly(user),\n    loading: readonly(loading),\n    isAdmin,\n    isLoggedIn,\n    login,\n    logout\n  }\n})\n```\n\n---\n\n## Type-Safe Provide/Inject\n\n```typescript\nimport type { InjectionKey, Ref } from 'vue'\n\n// Define typed key\ninterface ThemeContext {\n  theme: Ref<'light' | 'dark'>\n  toggle: () => void\n}\n\nexport const ThemeKey: InjectionKey<ThemeContext> = Symbol('theme')\n\n// Provider\nconst theme = ref<'light' | 'dark'>('light')\nconst toggle = () => {\n  theme.value = theme.value === 'light' ? 'dark' : 'light'\n}\nprovide(ThemeKey, { theme, toggle })\n\n// Consumer\nconst themeContext = inject(ThemeKey)\nif (themeContext) {\n  themeContext.toggle()\n}\n\n// With default\nconst themeContext = inject(ThemeKey, {\n  theme: ref('light'),\n  toggle: () => {}\n})\n```\n\n---\n\n## Utility Types\n\n### Common Patterns\n\n```typescript\n// Make all properties optional\ntype PartialUser = Partial<User>\n\n// Make all properties required\ntype RequiredUser = Required<User>\n\n// Pick specific properties\ntype UserCredentials = Pick<User, 'email' | 'password'>\n\n// Omit specific properties\ntype PublicUser = Omit<User, 'password'>\n\n// Extract function return type\ntype FetchResult = ReturnType<typeof useFetch>\n\n// Extract component props\ntype ButtonProps = InstanceType<typeof Button>['$props']\n```\n\n### Mapped Types for Forms\n\n```typescript\ninterface User {\n  name: string\n  email: string\n  age: number\n}\n\n// Form errors: each field has string[] of errors\ntype FormErrors<T> = {\n  [K in keyof T]?: string[]\n}\n\nconst errors: FormErrors<User> = {\n  email: ['Invalid email format'],\n  age: ['Must be 18 or older']\n}\n\n// Form touched state\ntype FormTouched<T> = {\n  [K in keyof T]?: boolean\n}\n\nconst touched: FormTouched<User> = {\n  email: true,\n  name: false\n}\n```\n\n---\n\n## Type Guards\n\n```typescript\ninterface User {\n  type: 'user'\n  name: string\n}\n\ninterface Admin {\n  type: 'admin'\n  name: string\n  permissions: string[]\n}\n\ntype Person = User | Admin\n\n// Type guard function\nfunction isAdmin(person: Person): person is Admin {\n  return person.type === 'admin'\n}\n\n// Usage\nfunction getPermissions(person: Person): string[] {\n  if (isAdmin(person)) {\n    return person.permissions  // TypeScript knows it's Admin\n  }\n  return []\n}\n```\n\n---\n\n## Avoid These Anti-Patterns\n\n### Never Use `any`\n\n```typescript\n// Bad\nconst data: any = await fetchData()\n\n// Good\ninterface Data {\n  items: Item[]\n}\nconst data: Data = await fetchData()\n\n// When truly unknown\nconst data: unknown = await fetchData()\nif (isValidData(data)) {\n  // Now typed\n}\n```\n\n### Always Type Function Parameters\n\n```typescript\n// Bad\nfunction processUser(user) {\n  return user.name\n}\n\n// Good\nfunction processUser(user: User): string {\n  return user.name\n}\n```\n\n### Type Event Handlers\n\n```typescript\n// Bad\nfunction handleClick(e) {\n  console.log(e.target.value)\n}\n\n// Good\nfunction handleClick(e: MouseEvent) {\n  const target = e.target as HTMLButtonElement\n  console.log(target.value)\n}\n\nfunction handleInput(e: Event) {\n  const target = e.target as HTMLInputElement\n  console.log(target.value)\n}\n```\n\n---\n\n## Type Declaration Files\n\n### Global Types\n\n```typescript\n// types/global.d.ts\ndeclare global {\n  interface User {\n    id: number\n    name: string\n    email: string\n  }\n\n  interface ApiResponse<T> {\n    data: T\n    success: boolean\n  }\n}\n\nexport {}  // Make this a module\n```\n\n### Module Augmentation\n\n```typescript\n// types/vue-shim.d.ts\ndeclare module '*.vue' {\n  import type { DefineComponent } from 'vue'\n  const component: DefineComponent<{}, {}, any>\n  export default component\n}\n\n// Augment Nuxt\ndeclare module '#app' {\n  interface NuxtApp {\n    $api: {\n      get: <T>(url: string) => Promise<T>\n    }\n  }\n}\n```\n",
        "vue-development-skill/skills/vue-development/qa/vue-checklist.md": "# Vue/Nuxt QA Checklist\n\nThis checklist is specifically designed for Vue 3 and Nuxt 3 development. All items must be validated before generating the handoff report.\n\n---\n\n## 1. Component Quality (5 items)\n\n- [ ] **Props typed**: All props have TypeScript types via `defineProps<Props>()`\n- [ ] **Props validated**: Required props marked, defaults provided where appropriate\n- [ ] **Emits typed**: All emits defined with `defineEmits<{...}>()`\n- [ ] **Single responsibility**: Component does ONE thing well\n- [ ] **Template simplicity**: No complex logic in template (use computed/methods)\n\n### Examples\n\n**Good - Typed props:**\n```typescript\ninterface Props {\n  label: string\n  disabled?: boolean\n  variant?: 'primary' | 'secondary'\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  disabled: false,\n  variant: 'primary'\n})\n```\n\n**Bad - Untyped props:**\n```typescript\nconst props = defineProps(['label', 'disabled']) // No types!\n```\n\n---\n\n## 2. Reactivity (4 items)\n\n- [ ] **Correct ref usage**: `ref()` for primitives, `reactive()` for objects\n- [ ] **Computed for derived state**: Not methods or inline calculations\n- [ ] **No prop mutation**: Never modify props directly, emit instead\n- [ ] **Cleanup on unmount**: Watchers/listeners cleaned up in `onUnmounted`\n\n### Examples\n\n**Good - Computed for derived state:**\n```typescript\nconst items = ref<Item[]>([])\nconst itemCount = computed(() => items.value.length)\nconst hasItems = computed(() => itemCount.value > 0)\n```\n\n**Bad - Method for derived state:**\n```typescript\nfunction getItemCount() {\n  return items.value.length // Recalculates every render!\n}\n```\n\n---\n\n## 3. Composables (4 items)\n\n*Mark N/A if no composables are created*\n\n- [ ] **Extracted reusable logic**: Shared logic in `use*.ts` files\n- [ ] **Returns reactive refs**: Not raw values\n- [ ] **Typed return**: Explicit TypeScript return type\n- [ ] **Side effects cleaned**: Intervals, listeners cleaned on unmount\n\n### Examples\n\n**Good - Composable structure:**\n```typescript\n// composables/useCounter.ts\nexport function useCounter(initial = 0) {\n  const count = ref(initial)\n\n  function increment() {\n    count.value++\n  }\n\n  function decrement() {\n    count.value--\n  }\n\n  return {\n    count: readonly(count),\n    increment,\n    decrement\n  }\n}\n```\n\n---\n\n## 4. Nuxt-Specific (4 items)\n\n*Mark N/A if not using Nuxt*\n\n- [ ] **Auto-imports used**: Using Nuxt auto-imports correctly (no manual imports for composables)\n- [ ] **Data fetching**: Using `useFetch` or `useAsyncData` (not raw fetch)\n- [ ] **Error handling**: Handling `.error` ref from data fetching\n- [ ] **SEO configured**: `useSeoMeta` or `useHead` for meta tags on pages\n\n### Examples\n\n**Good - Nuxt data fetching:**\n```typescript\nconst { data: users, pending, error } = await useFetch('/api/users')\n\nif (error.value) {\n  // Handle error\n}\n```\n\n**Bad - Raw fetch in Nuxt:**\n```typescript\nconst users = ref([])\nonMounted(async () => {\n  users.value = await fetch('/api/users').then(r => r.json())\n})\n```\n\n---\n\n## 5. TypeScript (4 items)\n\n- [ ] **No `any` types**: Use specific types or `unknown`\n- [ ] **Interfaces defined**: Props, emits, and data shapes have interfaces\n- [ ] **Generics used**: Where reusability benefits (composables, utilities)\n- [ ] **Explicit return types**: Functions have return type annotations\n\n### Examples\n\n**Good - Typed function:**\n```typescript\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`)\n  return response.json()\n}\n```\n\n**Bad - Untyped:**\n```typescript\nasync function fetchUser(id: any) { // any! No return type!\n  return await fetch(`/api/users/${id}`).then(r => r.json())\n}\n```\n\n---\n\n## 6. Unit Tests (6 items)\n\n- [ ] **Tests written first**: Tests existed before implementation (TDD)\n- [ ] **Component renders**: Basic render test passes\n- [ ] **Props tested**: Props affect output as expected\n- [ ] **Emits tested**: Events fire correctly with correct payloads\n- [ ] **Edge cases covered**: Empty states, error states, boundaries\n- [ ] **All tests passing**: No failing tests\n\n### Examples\n\n**Good - Comprehensive tests:**\n```typescript\ndescribe('UserCard', () => {\n  it('renders user name', () => {\n    const wrapper = mount(UserCard, {\n      props: { user: { name: 'John' } }\n    })\n    expect(wrapper.text()).toContain('John')\n  })\n\n  it('emits select event on click', async () => {\n    const wrapper = mount(UserCard, {\n      props: { user: { id: 1, name: 'John' } }\n    })\n    await wrapper.trigger('click')\n    expect(wrapper.emitted('select')).toEqual([[{ id: 1, name: 'John' }]])\n  })\n\n  it('shows placeholder for missing avatar', () => {\n    const wrapper = mount(UserCard, {\n      props: { user: { name: 'John' } } // No avatar\n    })\n    expect(wrapper.find('.avatar-placeholder').exists()).toBe(true)\n  })\n})\n```\n\n---\n\n## Scoring\n\n**Calculate score:**\n```\nscore = (items_passed / total_applicable_items)  10\n```\n\n**Thresholds:**\n\n| Score | Status | Meaning |\n|-------|--------|---------|\n| 9-10 | PASS | Excellent quality, ready for E2E |\n| 7-8 | ACCEPTABLE | Good quality, minor issues noted |\n| 0-6 | NEEDS_WORK | Must fix issues before handoff |\n\n**Note:** Mark categories as N/A if not applicable (e.g., \"Nuxt-Specific\" for plain Vue projects). N/A items don't count toward the total.\n",
        "vue-development-skill/skills/vue-development/tdd/testing-patterns.md": "# Vue Testing Patterns with Vitest\n\nThis guide covers common testing patterns for Vue 3 components using Vitest and Vue Test Utils.\n\n## Setup\n\n### Dependencies\n\n```bash\nnpm install -D vitest @vue/test-utils @vitejs/plugin-vue happy-dom\n```\n\n### Vitest Config\n\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [vue()],\n  test: {\n    environment: 'happy-dom',\n    globals: true,\n  },\n})\n```\n\n---\n\n## Basic Component Testing\n\n### Mounting Components\n\n```typescript\nimport { mount, shallowMount } from '@vue/test-utils'\nimport MyComponent from '../MyComponent.vue'\n\n// Full mount - renders child components\nconst wrapper = mount(MyComponent)\n\n// Shallow mount - stubs child components\nconst shallow = shallowMount(MyComponent)\n```\n\n### Testing Props\n\n```typescript\ndescribe('Button', () => {\n  it('renders label prop', () => {\n    const wrapper = mount(Button, {\n      props: { label: 'Click me' }\n    })\n    expect(wrapper.text()).toBe('Click me')\n  })\n\n  it('applies variant class', () => {\n    const wrapper = mount(Button, {\n      props: { variant: 'primary' }\n    })\n    expect(wrapper.classes()).toContain('btn-primary')\n  })\n\n  it('is disabled when disabled prop is true', () => {\n    const wrapper = mount(Button, {\n      props: { disabled: true }\n    })\n    expect(wrapper.attributes('disabled')).toBeDefined()\n  })\n})\n```\n\n### Testing Emits\n\n```typescript\ndescribe('Button', () => {\n  it('emits click event', async () => {\n    const wrapper = mount(Button)\n\n    await wrapper.trigger('click')\n\n    expect(wrapper.emitted('click')).toBeTruthy()\n    expect(wrapper.emitted('click')).toHaveLength(1)\n  })\n\n  it('emits with payload', async () => {\n    const wrapper = mount(ItemCard, {\n      props: { item: { id: 1, name: 'Test' } }\n    })\n\n    await wrapper.trigger('click')\n\n    expect(wrapper.emitted('select')?.[0]).toEqual([{ id: 1, name: 'Test' }])\n  })\n\n  it('does not emit when disabled', async () => {\n    const wrapper = mount(Button, {\n      props: { disabled: true }\n    })\n\n    await wrapper.trigger('click')\n\n    expect(wrapper.emitted('click')).toBeFalsy()\n  })\n})\n```\n\n---\n\n## Testing Reactivity\n\n### Testing Computed Properties\n\n```typescript\ndescribe('CartTotal', () => {\n  it('calculates total correctly', async () => {\n    const wrapper = mount(CartTotal, {\n      props: {\n        items: [\n          { price: 10, quantity: 2 },\n          { price: 5, quantity: 3 }\n        ]\n      }\n    })\n\n    // Total = (10 * 2) + (5 * 3) = 35\n    expect(wrapper.text()).toContain('$35')\n  })\n\n  it('updates when items change', async () => {\n    const wrapper = mount(CartTotal, {\n      props: {\n        items: [{ price: 10, quantity: 1 }]\n      }\n    })\n\n    expect(wrapper.text()).toContain('$10')\n\n    await wrapper.setProps({\n      items: [{ price: 10, quantity: 2 }]\n    })\n\n    expect(wrapper.text()).toContain('$20')\n  })\n})\n```\n\n### Testing v-model\n\n```typescript\ndescribe('TextInput', () => {\n  it('updates modelValue on input', async () => {\n    const wrapper = mount(TextInput, {\n      props: { modelValue: '' }\n    })\n\n    await wrapper.find('input').setValue('Hello')\n\n    expect(wrapper.emitted('update:modelValue')?.[0]).toEqual(['Hello'])\n  })\n\n  it('displays modelValue', () => {\n    const wrapper = mount(TextInput, {\n      props: { modelValue: 'Initial' }\n    })\n\n    expect(wrapper.find('input').element.value).toBe('Initial')\n  })\n})\n```\n\n---\n\n## Testing Async Operations\n\n### Using flushPromises\n\n```typescript\nimport { flushPromises } from '@vue/test-utils'\n\ndescribe('UserList', () => {\n  it('loads users on mount', async () => {\n    const wrapper = mount(UserList)\n\n    // Wait for all promises to resolve\n    await flushPromises()\n\n    expect(wrapper.findAll('.user-item')).toHaveLength(3)\n  })\n})\n```\n\n### Mocking API Calls\n\n```typescript\nimport { vi } from 'vitest'\n\n// Mock the API module\nvi.mock('@/api/users', () => ({\n  fetchUsers: vi.fn(() => Promise.resolve([\n    { id: 1, name: 'John' },\n    { id: 2, name: 'Jane' }\n  ]))\n}))\n\ndescribe('UserList', () => {\n  it('displays fetched users', async () => {\n    const wrapper = mount(UserList)\n    await flushPromises()\n\n    expect(wrapper.text()).toContain('John')\n    expect(wrapper.text()).toContain('Jane')\n  })\n})\n```\n\n### Testing Loading States\n\n```typescript\ndescribe('DataLoader', () => {\n  it('shows loading state initially', () => {\n    const wrapper = mount(DataLoader)\n\n    expect(wrapper.find('.loading').exists()).toBe(true)\n    expect(wrapper.find('.content').exists()).toBe(false)\n  })\n\n  it('shows content after loading', async () => {\n    const wrapper = mount(DataLoader)\n\n    await flushPromises()\n\n    expect(wrapper.find('.loading').exists()).toBe(false)\n    expect(wrapper.find('.content').exists()).toBe(true)\n  })\n})\n```\n\n---\n\n## Testing with Pinia\n\n### Setup\n\n```typescript\nimport { setActivePinia, createPinia } from 'pinia'\nimport { useUserStore } from '@/stores/user'\n\ndescribe('UserProfile', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia())\n  })\n\n  it('displays user from store', () => {\n    const store = useUserStore()\n    store.user = { id: 1, name: 'John' }\n\n    const wrapper = mount(UserProfile)\n\n    expect(wrapper.text()).toContain('John')\n  })\n\n  it('calls store action on button click', async () => {\n    const store = useUserStore()\n    const logoutSpy = vi.spyOn(store, 'logout')\n\n    const wrapper = mount(UserProfile)\n    await wrapper.find('.logout-btn').trigger('click')\n\n    expect(logoutSpy).toHaveBeenCalled()\n  })\n})\n```\n\n---\n\n## Testing Slots\n\n### Default Slot\n\n```typescript\ndescribe('Card', () => {\n  it('renders default slot content', () => {\n    const wrapper = mount(Card, {\n      slots: {\n        default: '<p>Card content</p>'\n      }\n    })\n\n    expect(wrapper.html()).toContain('<p>Card content</p>')\n  })\n})\n```\n\n### Named Slots\n\n```typescript\ndescribe('Layout', () => {\n  it('renders header and footer slots', () => {\n    const wrapper = mount(Layout, {\n      slots: {\n        header: '<h1>Title</h1>',\n        default: '<main>Content</main>',\n        footer: '<footer>Footer</footer>'\n      }\n    })\n\n    expect(wrapper.find('h1').text()).toBe('Title')\n    expect(wrapper.find('main').text()).toBe('Content')\n    expect(wrapper.find('footer').text()).toBe('Footer')\n  })\n})\n```\n\n### Scoped Slots\n\n```typescript\ndescribe('List', () => {\n  it('passes item to scoped slot', () => {\n    const wrapper = mount(List, {\n      props: {\n        items: [{ id: 1, name: 'Item 1' }]\n      },\n      slots: {\n        item: `<template #item=\"{ item }\">\n          <span class=\"item-name\">{{ item.name }}</span>\n        </template>`\n      }\n    })\n\n    expect(wrapper.find('.item-name').text()).toBe('Item 1')\n  })\n})\n```\n\n---\n\n## Testing Composables\n\n```typescript\n// composables/useCounter.ts\nexport function useCounter(initial = 0) {\n  const count = ref(initial)\n  const increment = () => count.value++\n  const decrement = () => count.value--\n  return { count, increment, decrement }\n}\n\n// composables/__tests__/useCounter.spec.ts\nimport { useCounter } from '../useCounter'\n\ndescribe('useCounter', () => {\n  it('starts with initial value', () => {\n    const { count } = useCounter(5)\n    expect(count.value).toBe(5)\n  })\n\n  it('increments count', () => {\n    const { count, increment } = useCounter()\n    increment()\n    expect(count.value).toBe(1)\n  })\n\n  it('decrements count', () => {\n    const { count, decrement } = useCounter(5)\n    decrement()\n    expect(count.value).toBe(4)\n  })\n})\n```\n\n---\n\n## Testing Error States\n\n```typescript\ndescribe('ErrorBoundary', () => {\n  it('shows error message on fetch failure', async () => {\n    vi.mock('@/api', () => ({\n      fetchData: vi.fn(() => Promise.reject(new Error('Network error')))\n    }))\n\n    const wrapper = mount(DataComponent)\n    await flushPromises()\n\n    expect(wrapper.find('.error').exists()).toBe(true)\n    expect(wrapper.text()).toContain('Network error')\n  })\n})\n```\n\n---\n\n## Test Organization Best Practices\n\n### File Structure\n\n```\nsrc/\n components/\n    Button.vue\n    __tests__/\n        Button.spec.ts\n composables/\n    useCounter.ts\n    __tests__/\n        useCounter.spec.ts\n```\n\n### Describe Blocks\n\n```typescript\ndescribe('Button', () => {\n  describe('rendering', () => {\n    it('renders label')\n    it('applies variant class')\n  })\n\n  describe('interactions', () => {\n    it('emits click on click')\n    it('does not emit when disabled')\n  })\n\n  describe('accessibility', () => {\n    it('has correct aria attributes')\n    it('is keyboard accessible')\n  })\n})\n```\n\n### Helpers\n\n```typescript\n// test/helpers.ts\nexport function mountButton(props = {}) {\n  return mount(Button, {\n    props: {\n      label: 'Default',\n      ...props\n    }\n  })\n}\n\n// Usage\nconst wrapper = mountButton({ variant: 'primary' })\n```\n",
        "vue-development-skill/skills/vue-development/tdd/workflow.md": "# TDD Workflow for Vue Components\n\nTest-Driven Development ensures quality by writing tests before implementation. This document outlines the exact process for Vue 3 and Nuxt 3 development.\n\n## The TDD Cycle\n\n```\n\n   RED         Write a failing test\n\n       \n       \n\n   GREEN       Write minimal code to pass\n\n       \n       \n\n  REFACTOR     Clean up, keep tests green\n\n       \n        Repeat\n```\n\n## Step 1: RED - Write Failing Tests\n\n### Before any Vue code exists, create the test file:\n\n```typescript\n// src/components/__tests__/UserProfile.spec.ts\nimport { describe, it, expect } from 'vitest'\nimport { mount } from '@vue/test-utils'\nimport UserProfile from '../UserProfile.vue'\n\ndescribe('UserProfile', () => {\n  // Test 1: Basic rendering\n  it('renders user name', () => {\n    const wrapper = mount(UserProfile, {\n      props: {\n        user: { id: 1, name: 'John Doe', email: 'john@example.com' }\n      }\n    })\n    expect(wrapper.text()).toContain('John Doe')\n  })\n\n  // Test 2: Props affect output\n  it('displays user email', () => {\n    const wrapper = mount(UserProfile, {\n      props: {\n        user: { id: 1, name: 'John', email: 'john@example.com' }\n      }\n    })\n    expect(wrapper.text()).toContain('john@example.com')\n  })\n\n  // Test 3: Event emission\n  it('emits edit event when edit button clicked', async () => {\n    const user = { id: 1, name: 'John', email: 'john@example.com' }\n    const wrapper = mount(UserProfile, {\n      props: { user }\n    })\n\n    await wrapper.find('button.edit-btn').trigger('click')\n\n    expect(wrapper.emitted('edit')).toBeTruthy()\n    expect(wrapper.emitted('edit')?.[0]).toEqual([user])\n  })\n\n  // Test 4: Edge case - loading state\n  it('shows loading indicator when loading prop is true', () => {\n    const wrapper = mount(UserProfile, {\n      props: {\n        user: { id: 1, name: 'John', email: 'john@example.com' },\n        loading: true\n      }\n    })\n    expect(wrapper.find('.loading-spinner').exists()).toBe(true)\n  })\n})\n```\n\n### Run tests - they should FAIL:\n\n```bash\nnpm run test -- UserProfile.spec.ts\n```\n\nExpected output: All tests fail (component doesn't exist yet).\n\n## Step 2: GREEN - Minimal Implementation\n\nNow write the component with **just enough code** to pass tests:\n\n```vue\n<!-- src/components/UserProfile.vue -->\n<script setup lang=\"ts\">\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ninterface Props {\n  user: User\n  loading?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  loading: false\n})\n\nconst emit = defineEmits<{\n  edit: [user: User]\n}>()\n\nfunction handleEdit() {\n  emit('edit', props.user)\n}\n</script>\n\n<template>\n  <div class=\"user-profile\">\n    <div v-if=\"loading\" class=\"loading-spinner\">Loading...</div>\n    <template v-else>\n      <h2>{{ user.name }}</h2>\n      <p>{{ user.email }}</p>\n      <button class=\"edit-btn\" @click=\"handleEdit\">Edit</button>\n    </template>\n  </div>\n</template>\n```\n\n### Run tests - they should PASS:\n\n```bash\nnpm run test -- UserProfile.spec.ts\n```\n\nExpected output: All 4 tests pass.\n\n## Step 3: REFACTOR - Improve Quality\n\nWith green tests as your safety net, improve the code:\n\n```vue\n<script setup lang=\"ts\">\ninterface User {\n  id: number\n  name: string\n  email: string\n  avatar?: string\n}\n\ninterface Props {\n  user: User\n  loading?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  loading: false\n})\n\nconst emit = defineEmits<{\n  edit: [user: User]\n}>()\n\n// Computed for derived state\nconst displayName = computed(() => props.user.name || 'Unknown User')\nconst hasAvatar = computed(() => Boolean(props.user.avatar))\n\nfunction handleEdit() {\n  emit('edit', props.user)\n}\n</script>\n\n<template>\n  <div class=\"user-profile\">\n    <div v-if=\"loading\" class=\"loading-spinner\" aria-busy=\"true\">\n      Loading...\n    </div>\n    <template v-else>\n      <img\n        v-if=\"hasAvatar\"\n        :src=\"user.avatar\"\n        :alt=\"`${displayName}'s avatar`\"\n        class=\"avatar\"\n      />\n      <div v-else class=\"avatar-placeholder\" />\n\n      <h2>{{ displayName }}</h2>\n      <p>{{ user.email }}</p>\n\n      <button\n        class=\"edit-btn\"\n        type=\"button\"\n        @click=\"handleEdit\"\n      >\n        Edit\n      </button>\n    </template>\n  </div>\n</template>\n```\n\n### Run tests after refactoring:\n\n```bash\nnpm run test -- UserProfile.spec.ts\n```\n\nTests must still pass. If any fail, you broke something - fix it!\n\n## Step 4: Add More Tests (Repeat Cycle)\n\nNow add tests for the new functionality:\n\n```typescript\nit('shows avatar when provided', () => {\n  const wrapper = mount(UserProfile, {\n    props: {\n      user: {\n        id: 1,\n        name: 'John',\n        email: 'john@example.com',\n        avatar: 'https://example.com/avatar.jpg'\n      }\n    }\n  })\n  expect(wrapper.find('.avatar').exists()).toBe(true)\n  expect(wrapper.find('.avatar-placeholder').exists()).toBe(false)\n})\n\nit('shows placeholder when no avatar', () => {\n  const wrapper = mount(UserProfile, {\n    props: {\n      user: { id: 1, name: 'John', email: 'john@example.com' }\n    }\n  })\n  expect(wrapper.find('.avatar-placeholder').exists()).toBe(true)\n})\n```\n\n## Common Test Patterns\n\n### Testing async operations:\n\n```typescript\nit('fetches data on mount', async () => {\n  const wrapper = mount(UserList)\n\n  // Wait for async operations\n  await flushPromises()\n\n  expect(wrapper.findAll('.user-item')).toHaveLength(3)\n})\n```\n\n### Testing with Pinia stores:\n\n```typescript\nimport { setActivePinia, createPinia } from 'pinia'\n\nbeforeEach(() => {\n  setActivePinia(createPinia())\n})\n\nit('updates store on action', async () => {\n  const wrapper = mount(Counter)\n  const store = useCounterStore()\n\n  await wrapper.find('button.increment').trigger('click')\n\n  expect(store.count).toBe(1)\n})\n```\n\n### Testing slots:\n\n```typescript\nit('renders slot content', () => {\n  const wrapper = mount(Card, {\n    slots: {\n      default: '<p>Card content</p>',\n      header: '<h1>Title</h1>'\n    }\n  })\n\n  expect(wrapper.text()).toContain('Card content')\n  expect(wrapper.text()).toContain('Title')\n})\n```\n\n## Checklist Before Moving On\n\n- [ ] All tests written BEFORE implementation\n- [ ] All tests passing\n- [ ] No skipped tests (`.skip`)\n- [ ] Edge cases covered (empty, error, loading states)\n- [ ] Tests are readable and maintainable\n",
        "vue-refactor-logic/.claude-plugin/plugin.json": "{\n  \"name\": \"vue-refactor-logic\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Refactor Vue 3 script logic: composables extraction, code splitting, Vue patterns\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"vue\", \"refactor\", \"composables\", \"composition-api\", \"design-patterns\"],\n  \"commands\": \"./commands\"\n}\n",
        "vue-refactor-logic/README.md": "# Vue Refactor Logic Plugin\n\nAutonomously refactor Vue 3 component script logic for improved readability, maintainability, and Vue best practices.\n\n## Usage\n\n```\n/vue-refactor-logic:refactor\n```\n\nAutomatically detects the currently open `.vue` file and refactors the `<script setup>` section.\n\n**Note:** For full SFC restructuring (section order, script organization), use `vue-reorder` plugin instead.\n\n## What It Does\n\n### Composable Extraction\nExtracts reusable stateful logic to `composables/useX.ts`:\n- Reactive state (ref, reactive)\n- Computed properties\n- Watchers\n- Lifecycle hooks\n- Related methods\n\n### Utility Extraction\nExtracts pure functions to `utils/`:\n- Formatting functions\n- Validation helpers\n- Framework-agnostic logic\n\n### Vue Anti-Pattern Fixes\n| Anti-Pattern | Fix |\n|--------------|-----|\n| Direct prop mutation | Emit pattern |\n| Side effects in computed | Move to watchers |\n| v-if + v-for together | Computed filter |\n| Missing cleanup | onUnmounted |\n| Unhandled async | Try/catch |\n\n### Code Splitting\n- Functions > 50 lines  smaller functions\n- Nesting > 3 levels  guard clauses\n- Parameters > 4  object pattern\n- Duplicate code  utilities\n\n## Example\n\n**Before:**\n```vue\n<script setup>\nconst props = defineProps(['userId'])\n\nconst user = ref(null)\nconst posts = ref([])\nconst isLoading = ref(false)\n\nonMounted(async () => {\n  isLoading.value = true\n  user.value = await fetchUser(props.userId)\n  posts.value = await fetchPosts(props.userId)\n  isLoading.value = false\n  window.addEventListener('resize', handleResize)\n})\n\n// Missing cleanup!\n</script>\n```\n\n**After:**\n```vue\n<script setup>\nimport { useUserData } from '@/composables/useUserData'\n\nconst props = defineProps(['userId'])\nconst { user, posts, isLoading } = useUserData(props.userId)\n</script>\n```\n\n```typescript\n// composables/useUserData.ts\nexport function useUserData(userId: Ref<string> | string) {\n  const user = ref(null)\n  const posts = ref([])\n  const isLoading = ref(false)\n\n  const loadData = async () => {\n    isLoading.value = true\n    try {\n      const id = unref(userId)\n      user.value = await fetchUser(id)\n      posts.value = await fetchPosts(id)\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  onMounted(() => {\n    loadData()\n    window.addEventListener('resize', handleResize)\n  })\n\n  onUnmounted(() => {\n    window.removeEventListener('resize', handleResize)\n  })\n\n  return { user, posts, isLoading }\n}\n```\n\n## Verification\n\nEvery refactoring ends with a mandatory checklist showing what was done.\n",
        "vue-refactor-logic/commands/refactor.md": "---\ndescription: Refactor Vue 3 script logic - composables extraction, code splitting, Vue patterns\n---\n\nYou are a Vue 3 refactoring assistant. Your task is to autonomously refactor Vue component script logic for improved readability, maintainability, and Vue best practices. This focuses on the `<script setup>` section only (use vue-reorder for full SFC restructuring).\n\n## Step 1: Identify Target File\n\n1. Check if a `.vue` file is currently open in the editor\n2. If yes, use that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file is Vue (`.vue`) with Composition API (`<script setup>`)\n5. If Options API detected, inform user this command supports Composition API only\n\n## Step 2: Analyze Script Logic\n\nAnalyze the `<script setup>` section for:\n\n### Code Splitting Issues\n- Functions exceeding 50 lines\n- Cyclomatic complexity > 10 (many conditionals/branches)\n- Nesting depth > 3 levels\n- Functions with > 4 parameters\n- Duplicate code patterns (2+ occurrences)\n\n### Vue Anti-Patterns\n- Direct prop mutation (should emit)\n- Side effects in computed properties (should use watchers)\n- `v-if` and `v-for` on same element (should use computed filter)\n- Missing lifecycle cleanup (onUnmounted)\n- Unhandled async errors in lifecycle hooks\n\n### Extraction Opportunities\n- Reusable stateful logic  Extract to composable\n- Pure utility functions  Extract to utils file\n- Shared state patterns  Suggest Pinia store\n- Complex reactive logic  Extract to composable\n\n### General Issues\n- Magic numbers/strings\n- Missing error handling\n- Callback chains instead of async/await\n\n## Step 3: Plan Refactoring\n\nFor each issue found, apply the appropriate resolution technique:\n\n---\n\n### Resolving High Cyclomatic Complexity (> 10)\n\n**Technique A: Extract Conditional Logic to Composable**\n```typescript\n// BEFORE: complex component logic\n<script setup>\nconst handleAction = (type: string) => {\n  if (type === 'create') { /* 15 lines */ }\n  else if (type === 'update') { /* 15 lines */ }\n  else if (type === 'delete') { /* 15 lines */ }\n}\n</script>\n\n// AFTER: extracted to composable with lookup\n// composables/useActions.ts\nexport function useActions() {\n  const actions = {\n    create: handleCreate,\n    update: handleUpdate,\n    delete: handleDelete\n  }\n\n  const handleAction = (type: ActionType) => actions[type]?.()\n\n  return { handleAction }\n}\n```\n\n**Technique B: Decompose Boolean Expressions**\n```typescript\n// BEFORE\nconst canSubmit = computed(() =>\n  form.name && form.email && !isLoading.value && !hasError.value && isValid.value\n)\n\n// AFTER\nconst hasRequiredFields = computed(() => form.name && form.email)\nconst isReady = computed(() => !isLoading.value && !hasError.value)\nconst canSubmit = computed(() => hasRequiredFields.value && isReady.value && isValid.value)\n```\n\n---\n\n### Resolving Deep Nesting (> 3 levels)\n\n**Technique A: Guard Clauses (Early Returns)**\n```typescript\n// BEFORE: 4 levels deep\nconst processData = (data) => {\n  if (data) {\n    if (data.isValid) {\n      if (data.items.length > 0) {\n        // actual logic\n      }\n    }\n  }\n}\n\n// AFTER: flat with guards\nconst processData = (data) => {\n  if (!data) return\n  if (!data.isValid) return\n  if (data.items.length === 0) return\n\n  // actual logic\n}\n```\n\n**Technique B: Extract to Composable**\n```typescript\n// BEFORE: nested in component\n<script setup>\nonMounted(async () => {\n  if (props.userId) {\n    try {\n      const user = await fetchUser(props.userId)\n      if (user.posts) {\n        for (const post of user.posts) {\n          // process posts\n        }\n      }\n    } catch (e) { /* ... */ }\n  }\n})\n</script>\n\n// AFTER: clean component + composable\n<script setup>\nconst { user, posts, isLoading, error } = useUserData(props.userId)\n</script>\n\n// composables/useUserData.ts - handles complexity internally\n```\n\n**Technique C: Use Array Methods**\n```typescript\n// BEFORE: nested loops in setup\nfor (const category of categories.value) {\n  for (const item of category.items) {\n    if (item.isActive) { /* process */ }\n  }\n}\n\n// AFTER: flat\nconst activeItems = computed(() =>\n  categories.value\n    .flatMap(cat => cat.items)\n    .filter(item => item.isActive)\n)\n```\n\n---\n\n### Resolving Long Functions (> 50 lines)\n\n**Technique A: Extract to Composable by Feature**\n```typescript\n// BEFORE: 100+ line setup\n<script setup>\n// user data logic (30 lines)\n// form validation logic (25 lines)\n// submission logic (25 lines)\n// error handling (20 lines)\n</script>\n\n// AFTER: composed from focused composables\n<script setup>\nconst { user, isLoading } = useUserData(props.userId)\nconst { errors, validate } = useFormValidation(formRules)\nconst { submit, isSubmitting } = useFormSubmission(apiEndpoint)\n</script>\n```\n\n**Technique B: Extract Setup/Teardown Pattern**\n```typescript\n// composables/useEventListener.ts\nexport function useEventListener(target, event, handler) {\n  onMounted(() => target.addEventListener(event, handler))\n  onUnmounted(() => target.removeEventListener(event, handler))\n}\n\n// Usage - clean and reusable\nuseEventListener(window, 'resize', handleResize)\nuseEventListener(document, 'keydown', handleKeydown)\n```\n\n---\n\n### Resolving Too Many Parameters (> 4)\n\n**Technique: Options Object Pattern**\n```typescript\n// BEFORE\nfunction useDataFetcher(url, method, headers, body, timeout, retries) {}\n\n// AFTER\ninterface FetcherOptions {\n  url: string\n  method?: 'GET' | 'POST'\n  headers?: Record<string, string>\n  body?: unknown\n  timeout?: number\n  retries?: number\n}\n\nfunction useDataFetcher(options: FetcherOptions) {\n  const { url, method = 'GET', timeout = 5000 } = options\n  // ...\n}\n```\n\n---\n\n### Resolving Duplicate Code\n\n**Technique: Extract to Composable**\n```typescript\n// BEFORE: duplicated in multiple components\n// ComponentA.vue\nconst isLoading = ref(false)\nconst error = ref(null)\nconst data = ref(null)\nonMounted(async () => {\n  isLoading.value = true\n  try { data.value = await fetchUsers() }\n  catch (e) { error.value = e }\n  finally { isLoading.value = false }\n})\n\n// ComponentB.vue - same pattern for products\n\n// AFTER: single composable\n// composables/useFetch.ts\nexport function useFetch<T>(fetcher: () => Promise<T>) {\n  const isLoading = ref(false)\n  const error = ref<Error | null>(null)\n  const data = ref<T | null>(null)\n\n  const execute = async () => {\n    isLoading.value = true\n    error.value = null\n    try { data.value = await fetcher() }\n    catch (e) { error.value = e as Error }\n    finally { isLoading.value = false }\n  }\n\n  onMounted(execute)\n\n  return { data, isLoading, error, refetch: execute }\n}\n\n// Usage\nconst { data: users, isLoading } = useFetch(fetchUsers)\nconst { data: products } = useFetch(fetchProducts)\n```\n\n---\n\n### Composable Extraction Guidelines\n\nExtract to composable (`composables/useX.ts`) when logic:\n- Uses Vue reactivity (ref, reactive, computed)\n- Uses lifecycle hooks (onMounted, onUnmounted)\n- Uses watchers (watch, watchEffect)\n- Is reusable across components\n- Groups related functionality\n\n**Composable structure:**\n```typescript\n// composables/useExample.ts\nexport function useExample(props) {\n  // Reactive state\n  const data = ref(null)\n\n  // Computed\n  const computed = computed(() => /* ... */)\n\n  // Methods\n  const doSomething = () => { /* ... */ }\n\n  // Lifecycle\n  onMounted(() => { /* ... */ })\n  onUnmounted(() => { /* cleanup */ })\n\n  // Return refs (not values) to maintain reactivity\n  return { data, computed, doSomething }\n}\n```\n\n### Utility Extraction\nExtract to utils (`utils/helpers.ts`) when:\n- Pure function (input  output, no side effects)\n- No Vue reactivity needed\n- Framework-agnostic logic\n\n### Vue Anti-Pattern Fixes\n\n| Anti-Pattern | Fix |\n|--------------|-----|\n| `props.x = value` | `emit('update:x', value)` |\n| Side effect in computed | Move to `watch()` or `watchEffect()` |\n| v-if + v-for together | Use computed to filter first |\n| No cleanup | Add `onUnmounted()` for listeners/timers |\n| Async without catch | Add try/catch with error state |\n\n### File Location\nWhen creating new files, analyze project structure:\n- Look for existing `composables/`, `utils/`, `hooks/` folders\n- Follow existing naming conventions\n- If no convention exists, use `src/composables/` and `src/utils/`\n\n## Step 4: Apply Changes\n\nApply all refactoring changes:\n\n1. Extract reusable logic to composables\n2. Extract pure utilities to utils files\n3. Fix prop mutations  emit pattern\n4. Move computed side effects  watchers\n5. Add lifecycle cleanup (onUnmounted)\n6. Add error handling to async operations\n7. Apply guard clauses for deep nesting\n8. Extract magic values to constants\n9. Update component to use new composables/utils\n10. Update imports\n\n## Step 5: Report Completion\n\nReport all changes made:\n```\nRefactored: ComponentName.vue\n\nChanges applied:\n- Extracted useUserData composable (state + fetch logic)\n- Extracted useFormValidation composable\n- Fixed prop mutation: emit('update:selectedId') instead of direct assignment\n- Moved API call side effect from computed to watchEffect\n- Added onUnmounted cleanup for event listeners\n- Created utils/formatters.ts for pure formatting functions\n\nNew files created:\n- composables/useUserData.ts\n- composables/useFormValidation.ts\n- utils/formatters.ts\n```\n\n## Verification Checklist (MANDATORY)\n\n**You MUST complete and display this checklist. The refactoring is NOT complete until shown.**\n\n### Analysis\n- [ ] Target .vue file identified\n- [ ] Script uses Composition API (`<script setup>`)\n- [ ] Code analyzed for complexity metrics\n- [ ] Vue anti-patterns identified\n- [ ] Extraction opportunities found\n\n### Code Splitting\n- [ ] Functions > 50 lines: addressed or N/A\n- [ ] Nesting > 3 levels: addressed or N/A\n- [ ] Complexity > 10: addressed or N/A\n- [ ] Duplicate code: extracted or N/A\n\n### Vue-Specific Fixes\n- [ ] Prop mutations: fixed or N/A\n- [ ] Computed side effects: moved to watchers or N/A\n- [ ] Lifecycle cleanup: added or N/A\n- [ ] Async error handling: added or N/A\n\n### Extractions\n- [ ] Composables created for reusable stateful logic\n- [ ] Utils created for pure functions\n- [ ] Files in appropriate locations\n- [ ] Imports updated correctly\n\n### Completion\n- [ ] All changes applied successfully\n- [ ] Summary reported\n- [ ] This checklist displayed with [x] marks\n\n**Example output:**\n```\nVerification Checklist:\n[x] Target file: src/components/UserDashboard.vue\n[x] Composition API confirmed\n[x] Code analyzed\n[x] Vue anti-patterns found: 2\n[x] Functions > 50 lines: 1 extracted to composable\n[x] Prop mutation fixed: emit pattern\n[x] Lifecycle cleanup added: onUnmounted for resize listener\n[x] Composable created: useUserData\n[x] Utils created: formatters.ts\n[x] Changes applied successfully\n```\n\n## Important Guidelines\n\n- **Preserve functionality**: Never change logic, only structure\n- **Preserve template**: This command does not modify `<template>` section\n- **Return refs from composables**: Maintain reactivity\n- **Naming conventions**:\n  - Composables: `useXxx` (e.g., `useUserData`, `useFetch`)\n  - Boolean refs: `isXxx`, `hasXxx` (e.g., `isLoading`, `hasError`)\n  - Event handlers: `handleXxx`, `onXxx` (e.g., `handleSubmit`)\n- **No over-extraction**: Don't create composables for single-use logic\n- **Test composables**: Extracted composables should be independently testable\n",
        "vue-reorder/.claude-plugin/plugin.json": "{\n  \"name\": \"vue-reorder\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Refactor Vue 3 SFCs for readability: reorder sections, organize script, improve naming\",\n  \"author\": {\n    \"name\": \"Sven Siertsema\"\n  },\n  \"repository\": \"https://github.com/SSiertsema/claude-code-plugins\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"vue\", \"refactor\", \"readability\", \"sfc\", \"composition-api\"],\n  \"commands\": \"./commands\"\n}\n",
        "vue-reorder/README.md": "# Vue Reorder Plugin\n\nRefactor Vue 3 Single File Components (SFCs) for optimal readability and maintainability.\n\n## Usage\n\n```\n/vue-reorder\n```\n\nThe command automatically detects the currently open `.vue` file and proposes refactoring changes.\n\n## What It Does\n\n### 1. Reorders SFC Sections\n\nEnforces the recommended order:\n```vue\n<template>...</template>\n<script setup>...</script>\n<style scoped>...</style>\n```\n\n### 2. Reorganizes Script Content\n\nApplies Composition API ordering convention:\n\n1. Imports (external first, then internal)\n2. Props & Emits (`defineProps`, `defineEmits`, `defineModel`)\n3. Injections (`inject`, composables like `useRouter`)\n4. Reactive State (`ref`, `reactive`)\n5. Computed (`computed`)\n6. Functions (helpers, event handlers)\n7. Watchers (`watch`, `watchEffect`)\n8. Lifecycle (`onMounted`, `onUnmounted`, etc.)\n\n### 3. Improves Naming\n\n| Type | Convention | Example |\n|------|------------|---------|\n| Files | PascalCase | `UserProfile.vue` |\n| Variables | camelCase | `userData`, `selectedItem` |\n| Booleans | is/has/can prefix | `isLoading`, `hasError` |\n| Event handlers | handle/on prefix | `handleClick`, `onSubmit` |\n| Data fetching | fetch/load/get prefix | `fetchUsers`, `loadData` |\n| Constants | UPPER_SNAKE_CASE | `MAX_ITEMS`, `API_URL` |\n\n## Requirements\n\n- Vue 3 Composition API (`<script setup>`)\n- Options API is not supported\n\n## Example\n\n**Before:**\n```vue\n<script setup>\nimport { onMounted, ref } from 'vue'\nimport api from '@/api'\n\nconst x = ref([])\nconst load = async () => { /* ... */ }\nconst y = ref(false)\n\nonMounted(() => load())\n</script>\n\n<style>.container { }</style>\n\n<template>\n  <div class=\"container\">...</div>\n</template>\n```\n\n**After:**\n```vue\n<template>\n  <div class=\"container\">...</div>\n</template>\n\n<script setup>\nimport { onMounted, ref } from 'vue'\nimport api from '@/api'\n\nconst items = ref([])\nconst isLoading = ref(false)\n\nasync function fetchItems() { /* ... */ }\n\nonMounted(() => fetchItems())\n</script>\n\n<style scoped>\n.container { }\n</style>\n```\n",
        "vue-reorder/commands/reorder.md": "---\ndescription: Refactor Vue 3 SFC for readability - reorder sections, organize script, improve naming\n---\n\nYou are a Vue.js refactoring assistant. Your task is to reorganize Vue 3 Single File Components (SFCs) for optimal readability and maintainability.\n\n## Step 1: Identify Target File\n\n1. Check if a `.vue` file is currently open in the editor\n2. If yes, propose to refactor that file\n3. If no file is open or user provides a path argument, use that instead\n4. Validate the file:\n   - Must be a `.vue` file\n   - Must use Composition API (`<script setup>`)\n   - If Options API detected, inform user this command only supports Composition API\n\n## Step 2: Read and Analyze\n\nRead the file and analyze:\n- Current order of SFC sections (template/script/style)\n- Script content organization\n- Variable and function naming\n- File name vs component purpose\n\n## Step 3: Plan Refactoring\n\n### Section Order (enforce this order):\n1. `<template>`\n2. `<script setup>` (add `lang=\"ts\"` if TypeScript is used)\n3. `<style scoped>` (add `scoped` if not present)\n\n### Script Organization (enforce this order):\n1. **Imports** - External packages first (vue, vue-router, pinia), then internal (@/, ../)\n2. **Props & Emits** - `defineProps()`, `defineEmits()`, `defineModel()`, `defineExpose()`\n3. **Injections** - `inject()`, composables (`useRouter()`, `useStore()`, custom `use*`)\n4. **Reactive State** - `ref()`, `reactive()`, `shallowRef()`, `shallowReactive()`\n5. **Computed** - `computed()` properties\n6. **Functions** - Helper functions and event handlers\n7. **Watchers** - `watch()`, `watchEffect()`, `watchPostEffect()`\n8. **Lifecycle** - `onBeforeMount()`, `onMounted()`, `onBeforeUpdate()`, `onUpdated()`, `onBeforeUnmount()`, `onUnmounted()`\n\n### Naming Conventions:\n- **File name**: PascalCase matching component purpose (e.g., `UserProfile.vue`)\n- **Variables/refs**: camelCase, descriptive (e.g., `userData`, `selectedItem`)\n- **Boolean refs**: prefix with is/has/can/should (e.g., `isLoading`, `hasError`, `canSubmit`)\n- **Functions**: camelCase with verb prefix:\n  - Event handlers: `handle*` or `on*` (e.g., `handleClick`, `onSubmit`)\n  - Data fetching: `fetch*`, `load*`, `get*` (e.g., `fetchUsers`, `loadData`)\n  - State changes: `set*`, `update*`, `toggle*` (e.g., `setActive`, `toggleMenu`)\n  - Async operations: consider `async` prefix clarity (e.g., `async function fetchData()`)\n- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_ITEMS`, `API_BASE_URL`)\n- **Composables**: `use*` prefix (e.g., `useAuth`, `useFormValidation`)\n\n### Comments:\n- Do NOT add routine section comments like \"// Imports\" or \"// State\"\n- Only add comments when:\n  - Logic is complex and not self-evident\n  - Something important needs highlighting\n  - Functions/variables are exported for use by others\n\n## Step 4: Present Changes\n\nShow the user:\n\n1. **Issues Found** - List what needs improvement:\n   ```\n   Issues found:\n   - Section order: script before template (should be template  script  style)\n   - Variable 'x' has unclear name (suggest: 'items' or more descriptive)\n   - Function 'load' should have verb prefix (suggest: 'fetchData' or 'loadItems')\n   - Style tag missing 'scoped' attribute\n   ```\n\n2. **Proposed Changes** - Show the refactored code or a diff\n\n3. **File Rename** - If applicable:\n   ```\n   Suggested file rename: myComponent.vue  UserDashboard.vue\n   (to match PascalCase convention and component purpose)\n   ```\n\n## Step 5: Apply Changes\n\nApply all changes automatically:\n1. Reorder SFC sections (template  script  style)\n2. Reorganize script content according to the ordering convention\n3. Apply naming improvements\n4. Rename file if needed (ensure imports in other files are updated if possible)\n\n## Step 6: Report Completion\n\nAfter applying changes, report:\n```\n Refactored: ComponentName.vue\n  - Reordered sections: template  script  style\n  - Reorganized script content\n  - Renamed 3 variables, 2 functions\n  - File renamed: oldName.vue  NewName.vue (if applicable)\n```\n\n## Important Guidelines\n\n- **Preserve functionality** - Never change logic, only organization and naming\n- **Preserve comments** - Keep existing meaningful comments, move them with their code\n- **Preserve formatting** - Match existing indentation style (spaces/tabs)\n- **Be conservative with naming** - Only suggest renames for clearly problematic names\n- **Don't over-engineer** - If the file is already well-organized, say so and suggest minor improvements only\n\n## Verification Checklist (MANDATORY)\n\n**IMPORTANT: You MUST complete this checklist before finishing. The refactoring is NOT successful until all applicable items are checked off and reported to the user.**\n\nBefore completing, verify each item has been addressed:\n\n### File & Validation\n- [ ] Target `.vue` file identified (open file or user-specified path)\n- [ ] File uses Composition API (`<script setup>`) - not Options API\n- [ ] File has been read and analyzed\n\n### Section Order\n- [ ] `<template>` is first section\n- [ ] `<script setup>` is second section\n- [ ] `<style>` is last section\n- [ ] `scoped` attribute added to `<style>` if missing\n\n### Script Organization\n- [ ] Imports are at the top (external before internal)\n- [ ] Props/Emits (`defineProps`, `defineEmits`, `defineModel`) follow imports\n- [ ] Composables and injections follow props/emits\n- [ ] Reactive state (`ref`, `reactive`) follows injections\n- [ ] Computed properties follow reactive state\n- [ ] Functions follow computed\n- [ ] Watchers follow functions\n- [ ] Lifecycle hooks are at the end\n\n### Naming Conventions\n- [ ] File name is PascalCase (or rename suggested)\n- [ ] Variables use camelCase\n- [ ] Boolean refs have is/has/can/should prefix\n- [ ] Functions have appropriate verb prefix (handle/fetch/toggle/etc.)\n- [ ] Constants use UPPER_SNAKE_CASE\n\n### Completion\n- [ ] Changes applied successfully\n- [ ] Summary of changes reported\n- [ ] Completed checklist shown\n\n**You MUST show the completed checklist to the user with [x] for completed items and [ ] for skipped items (with explanation).**\n\nExample output:\n```\nVerification Checklist:\n[x] Target file identified: UserList.vue\n[x] Composition API confirmed\n[x] File analyzed\n[x] Template is first section\n[x] Script is second section\n[x] Style is last section\n[x] Scoped attribute added\n[x] Imports organized\n[x] Props/Emits in correct position\n[ ] No composables/injections present (skipped)\n[x] Reactive state organized\n...\n```\n\nThe refactoring is only complete when this checklist is shown to the user.\n"
      },
      "plugins": [
        {
          "name": "agent-meeting-room",
          "source": "./agent-meeting-room",
          "description": "Tracks Claude Code sessions and agent processes in the Agent Meeting Room system",
          "category": "integration",
          "categories": [
            "integration"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install agent-meeting-room@svens-claude-plugins"
          ]
        },
        {
          "name": "documentation-generator",
          "source": "./documentation-generator",
          "description": "Generate comprehensive project documentation through interactive dialog with templates",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install documentation-generator@svens-claude-plugins"
          ]
        },
        {
          "name": "git-commit",
          "source": "./git-commit",
          "description": "Streamlined git commit and push with auto-generated commit messages",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install git-commit@svens-claude-plugins"
          ]
        },
        {
          "name": "vue-reorder",
          "source": "./vue-reorder",
          "description": "Refactor Vue 3 SFCs for readability: reorder sections, organize script, improve naming",
          "category": "vue",
          "categories": [
            "vue"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install vue-reorder@svens-claude-plugins"
          ]
        },
        {
          "name": "js-refactor-logic",
          "source": "./js-refactor-logic",
          "description": "Refactor JavaScript logic: code splitting, design patterns, ES6+ modernization",
          "category": "javascript",
          "categories": [
            "javascript"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install js-refactor-logic@svens-claude-plugins"
          ]
        },
        {
          "name": "ts-refactor-logic",
          "source": "./ts-refactor-logic",
          "description": "Refactor TypeScript logic: code splitting, type improvements, design patterns",
          "category": "typescript",
          "categories": [
            "typescript"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install ts-refactor-logic@svens-claude-plugins"
          ]
        },
        {
          "name": "vue-refactor-logic",
          "source": "./vue-refactor-logic",
          "description": "Refactor Vue 3 script logic: composables extraction, code splitting, Vue patterns",
          "category": "vue",
          "categories": [
            "vue"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install vue-refactor-logic@svens-claude-plugins"
          ]
        },
        {
          "name": "vue-development-skill",
          "source": "./vue-development-skill",
          "description": "Vue 3/Nuxt 3 development skill with TDD workflow and QA-first approach. Produces JSON reports for agent handoff.",
          "category": "vue",
          "categories": [
            "vue"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install vue-development-skill@svens-claude-plugins"
          ]
        },
        {
          "name": "owasp-security-audit",
          "source": "./owasp-security-audit",
          "description": "Multi-agent OWASP Top 10 security audit with technical and stakeholder reports",
          "category": "security",
          "categories": [
            "security"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install owasp-security-audit@svens-claude-plugins"
          ]
        },
        {
          "name": "ncsc-security-audit",
          "source": "./ncsc-security-audit",
          "description": "Multi-agent NCSC ICT-beveiligingsrichtlijnen audit met technische en stakeholder rapporten",
          "category": "security",
          "categories": [
            "security"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install ncsc-security-audit@svens-claude-plugins"
          ]
        },
        {
          "name": "technical-specifications",
          "source": "./technical-specifications",
          "description": "Interactive agent for collecting and refining technical specifications through guided dialogue",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install technical-specifications@svens-claude-plugins"
          ]
        },
        {
          "name": "user-story-generator",
          "source": "./user-story-generator",
          "description": "Generate INVEST-compliant user stories from functional specifications and personas with Gherkin acceptance criteria",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install user-story-generator@svens-claude-plugins"
          ]
        },
        {
          "name": "persona-generator",
          "source": "./persona-generator",
          "description": "Create detailed user personas through interactive dialogue for user story development",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install persona-generator@svens-claude-plugins"
          ]
        },
        {
          "name": "functional-specifications",
          "source": "./functional-specifications",
          "description": "Generate functional specifications from business case and personas through interactive dialogue",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add SSiertsema/claude-code-plugins",
            "/plugin install functional-specifications@svens-claude-plugins"
          ]
        }
      ]
    }
  ]
}