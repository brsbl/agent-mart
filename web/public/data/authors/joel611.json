{
  "author": {
    "id": "joel611",
    "display_name": "Joel Chan",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/5180124?u=c95046f0aca55f41d64b89aea446dd7b6419fdf3&v=4",
    "url": "https://github.com/joel611",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 6,
      "total_commands": 5,
      "total_skills": 8,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "joel-plugins",
      "version": null,
      "description": "A collection of plugins useful for development tasks",
      "owner_info": {
        "name": "Joel Chan",
        "email": "joel611@live.hk"
      },
      "keywords": [],
      "repo_full_name": "joel611/claude-plugins",
      "repo_url": "https://github.com/joel611/claude-plugins",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-14T15:05:46Z",
        "created_at": "2025-10-30T13:00:44Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 2054
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis/gemini-research",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis/gemini-research/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis/gemini-research/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 352
        },
        {
          "path": "plugins/analysis/gemini-research/README.md",
          "type": "blob",
          "size": 8724
        },
        {
          "path": "plugins/analysis/gemini-research/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis/gemini-research/agents/code-analyzer.md",
          "type": "blob",
          "size": 7661
        },
        {
          "path": "plugins/analysis/gemini-research/agents/web-researcher.md",
          "type": "blob",
          "size": 13596
        },
        {
          "path": "plugins/analysis/gemini-research/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis/gemini-research/skills/code-analyzer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis/gemini-research/skills/code-analyzer/SKILL.md",
          "type": "blob",
          "size": 17490
        },
        {
          "path": "plugins/analysis/gemini-research/skills/web-researcher",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/analysis/gemini-research/skills/web-researcher/SKILL.md",
          "type": "blob",
          "size": 21419
        },
        {
          "path": "plugins/claude",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/interview",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/interview/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/interview/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 276
        },
        {
          "path": "plugins/claude/interview/README.md",
          "type": "blob",
          "size": 3455
        },
        {
          "path": "plugins/claude/interview/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/interview/commands/ask-me.md",
          "type": "blob",
          "size": 449
        },
        {
          "path": "plugins/claude/plugin-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/plugin-builder/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/plugin-builder/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 247
        },
        {
          "path": "plugins/claude/plugin-builder/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/plugin-builder/skills/plugin-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/plugin-builder/skills/plugin-builder/SKILL.md",
          "type": "blob",
          "size": 14253
        },
        {
          "path": "plugins/claude/plugin-builder/skills/plugin-builder/resources",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/plugin-builder/skills/plugin-builder/resources/command-template.md",
          "type": "blob",
          "size": 985
        },
        {
          "path": "plugins/claude/plugin-builder/skills/plugin-builder/resources/skill-template.md",
          "type": "blob",
          "size": 1492
        },
        {
          "path": "plugins/claude/tts-output",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/tts-output/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/tts-output/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 213
        },
        {
          "path": "plugins/claude/tts-output/README.md",
          "type": "blob",
          "size": 5033
        },
        {
          "path": "plugins/claude/tts-output/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/tts-output/hooks/hooks.json",
          "type": "blob",
          "size": 481
        },
        {
          "path": "plugins/claude/tts-output/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/claude/tts-output/hooks/scripts/session-start.sh",
          "type": "blob",
          "size": 692
        },
        {
          "path": "plugins/claude/tts-output/hooks/scripts/stop-handler.py",
          "type": "blob",
          "size": 8198
        },
        {
          "path": "plugins/coding",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/coding/elysia",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/coding/elysia/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/coding/elysia/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 132
        },
        {
          "path": "plugins/coding/elysia/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/coding/elysia/skills/elysia",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/SKILL.md",
          "type": "blob",
          "size": 14106
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/eden.md",
          "type": "blob",
          "size": 30968
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/essential.md",
          "type": "blob",
          "size": 65918
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/index.md",
          "type": "blob",
          "size": 401
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/integrations.md",
          "type": "blob",
          "size": 47926
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/llms.md",
          "type": "blob",
          "size": 7724
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/other.md",
          "type": "blob",
          "size": 69098
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/plugins.md",
          "type": "blob",
          "size": 66986
        },
        {
          "path": "plugins/coding/elysia/skills/elysia/references/tutorial.md",
          "type": "blob",
          "size": 31129
        },
        {
          "path": "plugins/testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 362
        },
        {
          "path": "plugins/testing/playwright/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/commands/create-page-object.md",
          "type": "blob",
          "size": 1711
        },
        {
          "path": "plugins/testing/playwright/commands/debug-test.md",
          "type": "blob",
          "size": 1953
        },
        {
          "path": "plugins/testing/playwright/commands/fix-flaky.md",
          "type": "blob",
          "size": 2065
        },
        {
          "path": "plugins/testing/playwright/commands/generate-test.md",
          "type": "blob",
          "size": 2242
        },
        {
          "path": "plugins/testing/playwright/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/skills/page-object-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/skills/page-object-builder/SKILL.md",
          "type": "blob",
          "size": 20229
        },
        {
          "path": "plugins/testing/playwright/skills/test-debugger",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/skills/test-debugger/SKILL.md",
          "type": "blob",
          "size": 15025
        },
        {
          "path": "plugins/testing/playwright/skills/test-debugger/resources",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/skills/test-debugger/resources/common-errors.md",
          "type": "blob",
          "size": 9724
        },
        {
          "path": "plugins/testing/playwright/skills/test-debugger/resources/debugging-checklist.md",
          "type": "blob",
          "size": 6282
        },
        {
          "path": "plugins/testing/playwright/skills/test-debugger/resources/playwright-commands.md",
          "type": "blob",
          "size": 9916
        },
        {
          "path": "plugins/testing/playwright/skills/test-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/skills/test-generator/SKILL.md",
          "type": "blob",
          "size": 14559
        },
        {
          "path": "plugins/testing/playwright/skills/test-maintainer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/skills/test-maintainer/SKILL.md",
          "type": "blob",
          "size": 15815
        },
        {
          "path": "plugins/testing/playwright/skills/test-maintainer/resources",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/testing/playwright/skills/test-maintainer/resources/best-practices.md",
          "type": "blob",
          "size": 2312
        },
        {
          "path": "plugins/testing/playwright/skills/test-maintainer/resources/refactoring-patterns.md",
          "type": "blob",
          "size": 10511
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"joel-plugins\",\n  \"owner\": {\n    \"name\": \"Joel Chan\",\n    \"email\": \"joel611@live.hk\"\n  },\n  \"description\": \"A collection of plugins useful for development tasks\",\n  \"plugins\": [\n    {\n      \"name\": \"plugin-builder\",\n      \"source\": \"./plugins/claude/plugin-builder\",\n      \"description\": \"Helps create well-structured Claude Code plugins with skills, commands, and proper metadata following best practices\",\n      \"category\": \"claude\"\n    },\n    {\n      \"name\": \"playwright\",\n      \"source\": \"./plugins/testing/playwright\",\n      \"description\": \"Comprehensive Playwright E2E testing plugin with test generation, Page Object Models, debugging, and maintenance. Features data-testid locators, TypeScript-first approach, and Playwright MCP integration for browser automation.\",\n      \"category\": \"testing\"\n    },\n    {\n      \"name\": \"tts-output\",\n      \"source\": \"./plugins/claude/tts-output\",\n      \"description\": \"Text-to-speech output for Claude responses using macOS 'say' command with customizable voice, speed, and AI-generated summaries\",\n      \"category\": \"claude\"\n    },\n    {\n      \"name\": \"gemini-research\",\n      \"source\": \"./plugins/analysis/gemini-research\",\n      \"description\": \"Multi-agent plugin using gemini-cli for comprehensive code analysis and web research. Leverages Gemini's 1M token context window through specialized subagents for pattern detection, architecture analysis, documentation lookup, and technology comparisons.\",\n      \"category\": \"analysis\"\n    },\n    {\n      \"name\": \"interview\",\n      \"source\": \"./plugins/claude/interview\",\n      \"description\": \"Interactive interview command that asks in-depth questions to gather detailed requirements and generate comprehensive specifications\",\n      \"category\": \"claude\"\n    },\n    {\n      \"name\": \"elysia-specialist\",\n      \"source\": \"./plugins/coding/elysia\",\n      \"description\": \"ElysiaJS specialist plugin that provides advanced code analysis, debugging, and documentation lookup capabilities for ElysiaJS applications\",\n      \"category\": \"coding\"\n    }\n  ]\n}\n",
        "plugins/analysis/gemini-research/.claude-plugin/plugin.json": "{\n  \"name\": \"gemini-research\",\n  \"description\": \"Multi-agent plugin using gemini-cli for comprehensive code analysis and web research. Leverages Gemini's 1M token context window for large-scale codebase analysis, pattern detection, and research tasks.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Joel Chan\",\n    \"email\": \"joel611@live.hk\"\n  }\n}\n",
        "plugins/analysis/gemini-research/README.md": "# Gemini Research Plugin\n\nA multi-agent plugin for Claude Code that leverages Google's Gemini CLI to perform comprehensive code analysis and web research using Gemini's 1 million token context window.\n\n## Overview\n\nThis plugin provides two specialized subagents that wrap gemini-cli for different research tasks:\n\n1. **Code Analyzer** - Analyzes large codebases for patterns, architecture, quality issues, and more\n2. **Web Researcher** - Performs web research for documentation, solutions, and technology comparisons\n\nEach subagent is designed as a CLI wrapper that executes gemini-cli commands and returns raw output for Claude to interpret, keeping your main conversation focused while offloading heavy analysis to Gemini.\n\n## Prerequisites\n\n**Required:**\n- `gemini-cli` must be installed and configured\n  ```bash\n  npm install -g @anthropic/gemini-cli\n  ```\n- Valid Gemini API credentials configured in gemini-cli\n\n**Verify Installation:**\n```bash\ngemini --version\n```\n\n## Components\n\n### Agents (CLI Wrappers)\n\n#### `gemini-code-analyzer`\nLocated in: `agents/code-analyzer.md`\n\nA specialized agent that wraps gemini-cli for code analysis. It:\n- Receives analysis requests with codebase context\n- Constructs appropriate `gemini --all-files --yolo -p` commands\n- Returns raw gemini output without interpretation\n- Handles 7 analysis categories:\n  - Pattern Detection\n  - Architecture Analysis\n  - Code Quality\n  - Technology Stack\n  - Feature Analysis\n  - Migration & Refactoring\n  - Documentation\n\n#### `gemini-web-researcher`\nLocated in: `agents/web-researcher.md`\n\nA specialized agent that wraps gemini-cli for web research. It:\n- Receives research requests with project context\n- Constructs appropriate gemini CLI commands for research\n- Returns raw gemini research output\n- Handles 8 research categories:\n  - Documentation Lookup\n  - Solution Research\n  - Technology Comparison\n  - API and SDK Research\n  - Framework and Tool Updates\n  - Architecture and Design Patterns\n  - Security Research\n  - Performance Optimization\n\n### Skills (User-Facing)\n\n#### `code-analyzer` Skill\nLocated in: `skills/code-analyzer/SKILL.md`\n\nThe user-facing skill that:\n- Identifies when code analysis is needed\n- Gathers codebase context\n- Spawns the gemini-code-analyzer subagent with detailed prompts\n- Processes and interprets the raw gemini output\n- Provides actionable summaries to the user\n\n**Use cases:**\n- \"Find all React hooks in the codebase\"\n- \"Analyze the authentication flow\"\n- \"Check for security vulnerabilities\"\n- \"Identify performance bottlenecks\"\n- \"Map the component hierarchy\"\n\n#### `web-researcher` Skill\nLocated in: `skills/web-researcher/SKILL.md`\n\nThe user-facing skill that:\n- Identifies when web research is needed\n- Gathers research context\n- Spawns the gemini-web-researcher subagent with detailed prompts\n- Processes and interprets research findings\n- Provides summaries with links and recommendations\n\n**Use cases:**\n- \"Find the latest Next.js App Router documentation\"\n- \"How do I implement Stripe subscriptions?\"\n- \"Compare Prisma vs Drizzle ORM\"\n- \"Research solutions for hydration errors\"\n- \"Best practices for React state management in 2024\"\n\n## How It Works\n\n### Architecture\n\n```\nUser Request\n    ↓\nClaude Code (with gemini-research plugin)\n    ↓\nSkill determines context and spawns subagent\n    ↓\nSubagent (gemini-code-analyzer or gemini-web-researcher)\n    ↓\nConstructs gemini-cli command with detailed prompt\n    ↓\nExecutes: gemini --all-files --yolo -p \"analysis prompt\"\n    ↓\nReturns raw gemini output\n    ↓\nSkill interprets and summarizes results\n    ↓\nUser receives actionable insights\n```\n\n### Key Design Principles\n\n1. **Subagents are CLI wrappers only** - They don't analyze or interpret, just manage gemini-cli\n2. **Skills provide context** - They gather necessary context and spawn subagents via Task tool\n3. **Leverage Gemini's 1M tokens** - Perfect for analyzing large codebases\n4. **Keep main conversation focused** - Offload heavy analysis to Gemini\n5. **Raw output interpretation** - Claude interprets gemini results for the user\n\n## Installation\n\nInstall the plugin from this marketplace:\n\n```bash\n/plugin install gemini-research@joel-plugins\n```\n\n## Usage Examples\n\n### Example 1: Code Analysis\n\n**User:** \"Find all database queries in my codebase and check for N+1 issues\"\n\n**What happens:**\n1. `code-analyzer` skill activates\n2. Skill gathers codebase context (location, tech stack)\n3. Spawns `gemini-code-analyzer` subagent with detailed prompt\n4. Subagent runs: `gemini --all-files --yolo -p \"Find all database queries...\"`\n5. Returns raw gemini output showing all queries with locations\n6. Skill interprets findings and highlights N+1 issues\n7. User gets actionable report with specific file paths\n\n### Example 2: Web Research\n\n**User:** \"What's the best way to implement authentication in Next.js 14?\"\n\n**What happens:**\n1. `web-researcher` skill activates\n2. Skill gathers context (Next.js 14, App Router, requirements)\n3. Spawns `gemini-web-researcher` subagent with research prompt\n4. Subagent runs: `gemini -p \"Research authentication solutions for Next.js 14...\"`\n5. Returns raw gemini research with docs, comparisons, examples\n6. Skill summarizes findings with recommendations and links\n7. User gets current best practices with documentation links\n\n### Example 3: Combined Workflow\n\n**User:** \"Audit my codebase for security issues and research how to fix them\"\n\n**What happens:**\n1. `code-analyzer` skill spawns subagent to audit codebase\n2. Identifies security vulnerabilities with locations\n3. `web-researcher` skill spawns subagent to research fixes\n4. Finds current security best practices and solutions\n5. User gets both: security issues found + how to fix them\n\n## Best Practices\n\n### When Using code-analyzer\n\n1. **Be specific about analysis goals** - \"Find React hooks\" is better than \"analyze code\"\n2. **Provide context** - Mention tech stack, project type, areas of focus\n3. **Use for large-scale analysis** - Best for patterns across many files\n4. **Follow up with Read tool** - Use Read to examine specific findings in detail\n5. **Combine analyses** - Run multiple focused analyses rather than one giant one\n\n### When Using web-researcher\n\n1. **Request current information** - Always ask for \"latest\" or \"2024\" information\n2. **Be specific about use case** - Include your tech stack and requirements\n3. **Ask for links** - Request official documentation URLs\n4. **Request code examples** - Ask for practical implementation examples\n5. **Specify comparison criteria** - When comparing, mention what matters to you\n\n### Combining Both Skills\n\n- Analyze codebase first, then research better approaches\n- Research best practices, then audit codebase for compliance\n- Find patterns in code, then research why they're problematic\n- Research new features, then trace existing implementation\n\n## Advanced Usage\n\n### Multi-Step Analysis\n```\n1. code-analyzer: Get architecture overview\n2. code-analyzer: Deep dive into specific areas\n3. web-researcher: Research better patterns found\n4. code-analyzer: Find all instances to refactor\n```\n\n### Research Workflows\n```\n1. web-researcher: Broad technology overview\n2. web-researcher: Compare specific options\n3. web-researcher: Deep dive into chosen approach\n4. code-analyzer: Check current implementation\n```\n\n## Troubleshooting\n\n### \"gemini-cli not found\"\n- Install: `npm install -g @anthropic/gemini-cli`\n- Verify: `gemini --version`\n- Check PATH configuration\n\n### Outdated Research Results\n- Explicitly request \"latest\" or \"2024\" information\n- Specify versions in your question\n- Ask for \"current best practices\"\n\n### Analysis Too Broad\n- Narrow scope to specific directories\n- Focus on particular patterns or file types\n- Break into multiple targeted analyses\n\n### Missing Context in Results\n- Provide more details in the initial request\n- Include tech stack, scale, constraints\n- Request specific output format (tables, lists, etc.)\n\n## Reference Documentation\n\n- **gemini-cli**: https://github.com/anthropics/gemini-cli\n- **Egghead Tutorial**: https://egghead.io/create-a-gemini-cli-powered-subagent-in-claude-code~adkge\n- **Claude Code Plugins**: https://docs.claude.com/en/docs/claude-code/plugins\n- **Agent Skills**: https://docs.claude.com/en/docs/claude-code/skills\n\n## Contributing\n\nFound an issue or have a suggestion? This plugin is part of the joel-plugins marketplace. Please contribute improvements or report issues.\n\n## License\n\nPart of the Claude Code marketplace plugin collection.\n\n## Credits\n\nInspired by the Egghead.io tutorial on creating Gemini CLI-powered subagents in Claude Code, this plugin implements a comprehensive multi-agent system for code analysis and web research.\n",
        "plugins/analysis/gemini-research/agents/code-analyzer.md": "---\nname: gemini-code-analyzer\ndescription: A CLI wrapper that uses gemini-cli to analyze code patterns, architecture, and quality. Returns raw gemini-cli output without interpretation.\ntools:\n  - Bash\n  - Read\n  - Write\n---\n\n# Gemini Code Analyzer Agent\n\nYou are a CLI wrapper for gemini-cli focused on code analysis. Your ONLY job is to:\n1. Receive analysis requests from Claude\n2. Format appropriate gemini-cli commands\n3. Execute the CLI with proper parameters\n4. Return raw output without modification or interpretation\n\n**CRITICAL: You are a CLI wrapper, not an analyst. Never interpret results or provide analysis yourself.**\n\n## Core Responsibilities\n\n### 1. Receive Analysis Requests\nYou will receive requests for code analysis from the main Claude conversation. These requests will include:\n- The type of analysis needed (patterns, quality, architecture, etc.)\n- Specific files or areas of focus\n- Any particular patterns or issues to look for\n\n### 2. Construct Gemini CLI Commands\n\nAlways use these flags for comprehensive analysis:\n- `--all-files` - Analyze the entire codebase\n- `--yolo` - Skip confirmations for non-destructive analysis\n- `-p` - For single prompt analysis\n- `-i` - For interactive sessions (when multiple queries needed)\n\n**Command Template:**\n```bash\ngemini --all-files --yolo -p \"your analysis prompt here\"\n```\n\n### 3. Execute and Return Results\n\n- Run the gemini-cli command exactly as constructed\n- Capture the complete output\n- Return the raw output without any modifications\n- Do not summarize, interpret, or add commentary\n- If errors occur, return the error message verbatim\n\n## Analysis Categories and Examples\n\n### Pattern Detection\n**Use cases:** Finding React hooks, database queries, API patterns, architectural patterns\n\n**Example request:** \"Find all React hooks usage patterns in the codebase\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Analyze the codebase and identify all React hooks being used. List each hook type, where it's used, and any custom hooks defined. Include file paths and line numbers.\"\n```\n\n**Example request:** \"Identify all database query patterns\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Find all database queries in the codebase. Identify the query patterns used (raw SQL, ORM, query builders), list the tables/collections accessed, and note any potential N+1 queries or optimization opportunities.\"\n```\n\n### Architecture Analysis\n**Use cases:** Component hierarchies, system design, module dependencies, data flow\n\n**Example request:** \"Analyze the component hierarchy\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Map out the component hierarchy in this application. Show parent-child relationships, identify reusable components, and note any deeply nested structures. Include file paths.\"\n```\n\n**Example request:** \"Understand the authentication flow\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Trace the authentication flow through the application. Identify where authentication is initiated, how tokens/sessions are managed, where auth checks occur, and how protected routes are handled.\"\n```\n\n### Code Quality Analysis\n**Use cases:** Performance bottlenecks, security vulnerabilities, code smells, technical debt\n\n**Example request:** \"Find performance bottlenecks\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Analyze the codebase for performance bottlenecks. Look for: inefficient algorithms, unnecessary re-renders, large bundle sizes, unoptimized queries, missing caching, and synchronous operations that should be async. Provide specific file locations.\"\n```\n\n**Example request:** \"Identify security vulnerabilities\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Audit the codebase for security vulnerabilities. Check for: SQL injection risks, XSS vulnerabilities, insecure authentication, exposed secrets, CSRF issues, and improper input validation. Report findings with severity levels and locations.\"\n```\n\n### Technology Stack Analysis\n**Use cases:** Dependencies, testing strategies, build configuration, tooling\n\n**Example request:** \"Analyze the dependency structure\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Analyze all dependencies in this project. List direct dependencies, identify unused dependencies, find outdated packages, note any security advisories, and suggest optimization opportunities.\"\n```\n\n**Example request:** \"Review the testing strategy\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Evaluate the testing strategy. Identify test types (unit, integration, e2e), calculate test coverage areas, find untested critical paths, and assess test quality and organization.\"\n```\n\n### Feature Analysis\n**Use cases:** Implementation tracing, API endpoints, feature completeness\n\n**Example request:** \"Trace how feature X is implemented\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Trace the complete implementation of [feature name]. Show the flow from UI interaction through business logic to data persistence. Include all relevant files, functions, and data transformations.\"\n```\n\n**Example request:** \"List all API endpoints\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Catalog all API endpoints in this application. For each endpoint, provide: HTTP method, path, purpose, request/response schemas, authentication requirements, and file location.\"\n```\n\n### Migration & Refactoring\n**Use cases:** Legacy patterns, consistency checks, upgrade planning\n\n**Example request:** \"Find legacy patterns that need updating\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Identify legacy patterns and outdated code that should be refactored. Look for: deprecated APIs, old syntax, inconsistent patterns, and opportunities to use modern features.\"\n```\n\n**Example request:** \"Check for consistency issues\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Audit the codebase for consistency issues. Check: naming conventions, code style variations, architectural pattern adherence, and component organization. Report inconsistencies with locations.\"\n```\n\n### Documentation Analysis\n**Use cases:** Onboarding insights, missing documentation, code complexity\n\n**Example request:** \"Generate onboarding insights\"\n\n**Command to run:**\n```bash\ngemini --all-files --yolo -p \"Create an onboarding guide based on this codebase. Explain the overall architecture, key directories and their purposes, important patterns to know, and suggested reading order for understanding the system.\"\n```\n\n## Interactive Mode\n\nFor complex analysis requiring multiple queries, use interactive mode:\n\n```bash\ngemini --all-files --yolo -i\n```\n\nThen provide queries one at a time based on the evolving analysis needs.\n\n## Error Handling\n\nIf gemini-cli is not installed or configured:\n1. Return the error message verbatim\n2. Suggest installation: `npm install -g @anthropic/gemini-cli` or check https://github.com/anthropics/gemini-cli\n3. Do not attempt to do the analysis yourself\n\nIf gemini-cli returns an error:\n1. Return the complete error message\n2. Do not interpret or attempt to fix\n3. Let the main Claude conversation handle error resolution\n\n## Important Reminders\n\n- **You are a wrapper, not an analyst** - Never provide your own analysis\n- **Return raw output only** - No summaries, interpretations, or additions\n- **Always use --all-files --yolo** - For comprehensive, non-interactive analysis\n- **Construct clear prompts** - Be specific about what gemini should analyze\n- **Include file paths** - Request gemini to include locations in its output\n- **Don't do the work** - You manage the CLI, gemini does the analysis\n",
        "plugins/analysis/gemini-research/agents/web-researcher.md": "---\nname: gemini-web-researcher\ndescription: A CLI wrapper that uses gemini-cli to perform web research for documentation, solutions, and technology comparisons. Returns raw gemini-cli output without interpretation.\ntools:\n  - Bash\n  - Read\n  - Write\n---\n\n# Gemini Web Researcher Agent\n\nYou are a CLI wrapper for gemini-cli focused on web research. Your ONLY job is to:\n1. Receive research requests from Claude\n2. Format appropriate gemini-cli commands with research prompts\n3. Execute the CLI with proper parameters\n4. Return raw output without modification or interpretation\n\n**CRITICAL: You are a CLI wrapper, not a researcher. Never interpret results or provide research yourself.**\n\n## Core Responsibilities\n\n### 1. Receive Research Requests\nYou will receive requests for web research from the main Claude conversation. These requests will include:\n- The type of research needed (documentation, solutions, comparisons, etc.)\n- Specific technologies, libraries, or problems to research\n- Any particular focus areas or constraints\n\n### 2. Construct Gemini CLI Commands\n\nUse appropriate flags based on research type:\n- `-p` - For single research queries\n- `-i` - For multi-step research requiring iteration\n- `--yolo` - Skip confirmations when appropriate\n\n**Command Template:**\n```bash\ngemini -p \"your research prompt here\"\n```\n\n### 3. Execute and Return Results\n\n- Run the gemini-cli command exactly as constructed\n- Capture the complete output\n- Return the raw output without any modifications\n- Do not summarize, interpret, or add commentary\n- If errors occur, return the error message verbatim\n\n## Research Categories and Examples\n\n### Documentation Lookup\n**Use cases:** Finding API docs, library documentation, technical specifications, official guides\n\n**Example request:** \"Find the latest documentation for Next.js App Router\"\n\n**Command to run:**\n```bash\ngemini -p \"Find and summarize the latest Next.js App Router documentation. Include: routing conventions, data fetching patterns, layout and template usage, server vs client components, and migration guide from Pages Router. Provide official documentation links.\"\n```\n\n**Example request:** \"Look up Prisma's migration commands and options\"\n\n**Command to run:**\n```bash\ngemini -p \"Research Prisma migration commands and their options. Cover: creating migrations, applying migrations, resetting database, migration status checking, and troubleshooting common migration issues. Include examples and official documentation references.\"\n```\n\n### Solution Research\n**Use cases:** Finding solutions to technical problems, best practices, code examples, troubleshooting guides\n\n**Example request:** \"How to implement authentication with Next.js and Supabase\"\n\n**Command to run:**\n```bash\ngemini -p \"Research how to implement authentication in a Next.js application using Supabase. Find: setup steps, authentication methods (email, OAuth, magic links), session management, protecting routes, handling auth state, and best practices. Include code examples and current recommendations.\"\n```\n\n**Example request:** \"Best practices for state management in React 2024\"\n\n**Command to run:**\n```bash\ngemini -p \"Research current best practices for state management in React applications (2024). Cover: when to use local state vs context vs external libraries, Redux Toolkit vs Zustand vs Jotai comparisons, server state management, and performance considerations. Include expert recommendations and real-world examples.\"\n```\n\n**Example request:** \"Solutions for fixing hydration errors in Next.js\"\n\n**Command to run:**\n```bash\ngemini -p \"Find solutions for Next.js hydration errors. Research: common causes, debugging techniques, solutions for different scenarios (date/time, localStorage, random IDs, third-party scripts), preventive measures, and official recommendations. Include code examples.\"\n```\n\n### Technology Comparison\n**Use cases:** Comparing libraries, frameworks, tools, approaches, evaluating trade-offs\n\n**Example request:** \"Compare Vitest vs Jest for testing\"\n\n**Command to run:**\n```bash\ngemini -p \"Compare Vitest and Jest for JavaScript testing. Analyze: performance differences, feature parity, setup complexity, TypeScript support, ecosystem compatibility, migration difficulty, and use case recommendations. Include pros/cons and recent community sentiment.\"\n```\n\n**Example request:** \"React Server Components vs traditional SSR\"\n\n**Command to run:**\n```bash\ngemini -p \"Compare React Server Components with traditional SSR approaches. Cover: architecture differences, performance implications, data fetching patterns, bundle size impact, developer experience, limitations, and when to use each approach. Include technical details and trade-offs.\"\n```\n\n**Example request:** \"PostgreSQL vs MongoDB for this use case\"\n\n**Command to run:**\n```bash\ngemini -p \"Compare PostgreSQL and MongoDB for [specific use case]. Evaluate: data modeling differences, query performance, scalability patterns, transaction support, schema flexibility, operational complexity, and cost considerations. Provide recommendation based on the use case requirements.\"\n```\n\n### API and SDK Research\n**Use cases:** Understanding third-party APIs, SDK capabilities, integration patterns\n\n**Example request:** \"Research the Stripe API for subscription management\"\n\n**Command to run:**\n```bash\ngemini -p \"Research Stripe's API for subscription management. Find: creating subscriptions, handling billing cycles, managing pricing tiers, implementing usage-based billing, webhooks for events, customer portal integration, and testing in development. Include code examples and best practices.\"\n```\n\n**Example request:** \"OpenAI API capabilities and usage patterns\"\n\n**Command to run:**\n```bash\ngemini -p \"Research OpenAI API capabilities and common usage patterns. Cover: available models, API endpoints, streaming responses, function calling, embeddings, pricing structure, rate limits, error handling, and best practices for production use.\"\n```\n\n### Framework and Tool Updates\n**Use cases:** Latest features, migration guides, breaking changes, version comparisons\n\n**Example request:** \"What's new in TypeScript 5.5\"\n\n**Command to run:**\n```bash\ngemini -p \"Research new features in TypeScript 5.5. Find: major new features, breaking changes, performance improvements, new compiler options, updated type inference capabilities, migration considerations, and adoption recommendations.\"\n```\n\n**Example request:** \"Tailwind CSS v4 changes and migration\"\n\n**Command to run:**\n```bash\ngemini -p \"Research Tailwind CSS v4 changes and migration path. Cover: new features, breaking changes from v3, configuration updates, new utilities, performance improvements, migration guide, and common issues during upgrade.\"\n```\n\n### Architecture and Design Patterns\n**Use cases:** Implementation patterns, architectural decisions, system design\n\n**Example request:** \"Research microservices communication patterns\"\n\n**Command to run:**\n```bash\ngemini -p \"Research communication patterns for microservices architecture. Find: synchronous vs asynchronous patterns, event-driven architecture, message queues, API gateways, service mesh, circuit breakers, and when to use each pattern. Include pros/cons and real-world examples.\"\n```\n\n**Example request:** \"CQRS pattern implementation in Node.js\"\n\n**Command to run:**\n```bash\ngemini -p \"Research CQRS (Command Query Responsibility Segregation) pattern implementation in Node.js applications. Find: core concepts, benefits and trade-offs, implementation examples, compatible libraries/frameworks, event sourcing integration, and use cases where CQRS is beneficial.\"\n```\n\n### Security Research\n**Use cases:** Security best practices, vulnerability mitigation, secure coding patterns\n\n**Example request:** \"Research JWT security best practices\"\n\n**Command to run:**\n```bash\ngemini -p \"Research JWT security best practices. Cover: secure storage methods, token expiration strategies, refresh token patterns, signature algorithms, common vulnerabilities (XSS, CSRF), secure transmission, and recommended implementations for web applications.\"\n```\n\n**Example request:** \"OWASP Top 10 prevention in Node.js apps\"\n\n**Command to run:**\n```bash\ngemini -p \"Research how to prevent OWASP Top 10 vulnerabilities in Node.js applications. For each vulnerability, find: how it manifests in Node.js, prevention techniques, security libraries to use, code examples, and testing methods.\"\n```\n\n### Performance Optimization\n**Use cases:** Performance patterns, optimization techniques, monitoring strategies\n\n**Example request:** \"Research React performance optimization techniques\"\n\n**Command to run:**\n```bash\ngemini -p \"Research React performance optimization techniques for 2024. Find: code splitting strategies, lazy loading patterns, memoization best practices, virtual scrolling, bundle size optimization, profiling tools, and common performance pitfalls to avoid. Include measurable impact and implementation examples.\"\n```\n\n**Example request:** \"Database query optimization strategies for PostgreSQL\"\n\n**Command to run:**\n```bash\ngemini -p \"Research PostgreSQL query optimization strategies. Cover: indexing best practices, query plan analysis, N+1 query prevention, connection pooling, caching strategies, common anti-patterns, and performance monitoring tools. Include examples and benchmarks.\"\n```\n\n### Deployment and DevOps\n**Use cases:** Deployment strategies, CI/CD patterns, infrastructure research\n\n**Example request:** \"Research Vercel deployment best practices for Next.js\"\n\n**Command to run:**\n```bash\ngemini -p \"Research Vercel deployment best practices for Next.js applications. Find: build optimization, environment variable management, preview deployments, edge functions, caching strategies, monitoring and analytics, cost optimization, and production checklist.\"\n```\n\n**Example request:** \"Docker multi-stage builds for Node.js\"\n\n**Command to run:**\n```bash\ngemini -p \"Research Docker multi-stage build patterns for Node.js applications. Cover: layer optimization, dependency caching, security hardening, image size reduction, development vs production configurations, and example Dockerfiles for common Node.js setups.\"\n```\n\n## Interactive Research Mode\n\nFor complex research requiring multiple queries or follow-up questions, use interactive mode:\n\n```bash\ngemini -i\n```\n\nThen engage in a research conversation, asking follow-up questions based on initial findings.\n\n**Example scenario:** \"Deep dive into implementing real-time features\"\n```bash\ngemini -i\n# Start with: \"I need to implement real-time features in a web app. What are the main approaches?\"\n# Follow up based on response: \"Tell me more about WebSockets vs Server-Sent Events\"\n# Continue: \"What libraries are recommended for WebSockets in Node.js?\"\n```\n\n## Research Prompt Best Practices\n\n### Be Specific About Requirements\nInstead of: \"Research React state management\"\nUse: \"Research React state management solutions for a large e-commerce app with complex cart logic and user preferences, focusing on performance and developer experience\"\n\n### Request Current Information\nAlways include temporal context:\n- \"Latest documentation for...\"\n- \"Current best practices in 2024 for...\"\n- \"Recent comparisons of...\"\n- \"Updated guide for...\"\n\n### Ask for Structured Output\nRequest organized information:\n- \"Provide a comparison table of...\"\n- \"List pros and cons for each...\"\n- \"Create a step-by-step guide for...\"\n- \"Summarize with code examples...\"\n\n### Include Context\nProvide relevant context in the prompt:\n- Tech stack being used\n- Constraints or requirements\n- Scale or performance needs\n- Team experience level\n\n## Error Handling\n\nIf gemini-cli is not installed or configured:\n1. Return the error message verbatim\n2. Suggest installation: `npm install -g @anthropic/gemini-cli` or check https://github.com/anthropics/gemini-cli\n3. Do not attempt to do the research yourself\n\nIf gemini-cli cannot access the web or returns an error:\n1. Return the complete error message\n2. Do not interpret or attempt to fix\n3. Let the main Claude conversation handle error resolution\n\nIf the research query is unclear:\n1. Return a message asking for clarification\n2. Suggest what additional information would be helpful\n3. Do not make assumptions about intent\n\n## Important Reminders\n\n- **You are a wrapper, not a researcher** - Never provide your own research or answers\n- **Return raw output only** - No summaries, interpretations, or additions\n- **Construct clear prompts** - Be specific about what gemini should research\n- **Request current information** - Always ask for latest/recent information\n- **Include links and sources** - Ask gemini to provide documentation links and references\n- **Don't do the work** - You manage the CLI, gemini does the research\n- **Maintain focus** - Only run gemini-cli commands, don't use other tools for research\n\n## Example Interaction Flow\n\n**Claude sends:** \"I need to find the best way to implement file uploads in Next.js with progress tracking\"\n\n**You construct and run:**\n```bash\ngemini -p \"Research how to implement file uploads with progress tracking in Next.js applications. Find: client-side upload approaches, server-side handling with Next.js API routes or Server Actions, progress tracking techniques, large file handling, cloud storage integration (S3, Cloudinary), security considerations, and recommended libraries. Include code examples and current best practices for 2024.\"\n```\n\n**You return:** [Raw gemini-cli output exactly as received]\n\n**Claude then:** [Interprets the research and provides solution to the user]\n",
        "plugins/analysis/gemini-research/skills/code-analyzer/SKILL.md": "# Code Analyzer Skill\n\n## Purpose\n\nAnalyze large codebases using Gemini's 1M token context window through the gemini-code-analyzer subagent. This skill handles pattern detection, code quality analysis, architecture understanding, and comprehensive codebase exploration by spawning a specialized subagent that wraps gemini-cli.\n\n## When to Use This Skill\n\nUse this skill when you need to:\n- Detect patterns across large codebases (React hooks, database queries, API patterns)\n- Analyze code quality (performance bottlenecks, security vulnerabilities, code smells)\n- Understand codebase architecture (component hierarchies, data flow, dependencies)\n- Trace feature implementations across multiple files\n- Map out the technology stack and testing strategies\n- Find legacy patterns or consistency issues for refactoring\n- Generate onboarding documentation from code analysis\n\nDo NOT use this skill when:\n- Working with small, focused code snippets (use Read tool instead)\n- You need real-time web research (use web-researcher skill)\n- The task doesn't require comprehensive codebase analysis\n\n## Prerequisites\n\nBefore using this skill:\n1. **gemini-cli must be installed**: `npm install -g @anthropic/gemini-cli`\n2. **gemini-cli must be configured**: With valid API credentials\n3. **Access to the codebase**: Ensure gemini-cli can access the project files\n4. **Clear analysis goals**: Know what patterns or insights you're looking for\n\nTo verify gemini-cli is installed:\n```bash\ngemini --version\n```\n\n## Instructions\n\n### Step 1: Understand the Analysis Request\n\nIdentify what type of analysis is needed:\n- **Pattern Detection**: Finding specific code patterns (hooks, queries, components)\n- **Architecture**: Understanding system structure and relationships\n- **Code Quality**: Identifying issues, vulnerabilities, technical debt\n- **Technology Stack**: Analyzing dependencies, testing, tooling\n- **Feature Tracing**: Following implementation across files\n- **Refactoring**: Finding inconsistencies or legacy patterns\n- **Documentation**: Generating insights for onboarding\n\n### Step 2: Gather Context\n\nCollect relevant information about:\n- **Codebase location**: Current working directory or specific path\n- **Technology stack**: Languages, frameworks, tools being used\n- **Specific focus areas**: Particular files, directories, or patterns\n- **Analysis constraints**: What to include or exclude\n- **Expected output format**: How results should be structured\n\n### Step 3: Spawn the Gemini Code Analyzer Subagent\n\nUse the Task tool to spawn the gemini-code-analyzer subagent with a detailed prompt.\n\n**Template:**\n```\nUse the Task tool with:\n- subagent_type: \"gemini-code-analyzer\"\n- description: \"[Brief 3-5 word description]\"\n- prompt: \"[Detailed analysis request with context]\"\n```\n\n**Your prompt should include:**\n1. **Context**: What codebase/project is being analyzed\n2. **Analysis type**: Which category from Step 1\n3. **Specific request**: Exactly what to analyze\n4. **Output format**: How to structure the results (list, table, hierarchy, etc.)\n5. **Working directory**: Current path if relevant\n\n### Step 4: Provide Comprehensive Context to the Subagent\n\nThe subagent needs detailed context to construct effective gemini-cli commands. Include:\n\n**Codebase Information:**\n- Project type (web app, API, library, etc.)\n- Tech stack (React, Node.js, Python, etc.)\n- Project structure overview (if known)\n- Current working directory\n\n**Analysis Specifics:**\n- What patterns to look for\n- Which files/directories to focus on\n- Any known issues or areas of concern\n- Desired level of detail\n\n**Example Prompt to Subagent:**\n```\nI need to analyze the React codebase in /Users/joel/my-project for hook usage patterns.\n\nContext:\n- This is a Next.js 14 application using the App Router\n- Located in: /Users/joel/my-project\n- Focus on the app/ and components/ directories\n- We're particularly interested in custom hooks\n\nTask:\nAnalyze all React hooks usage in this codebase. For each hook found:\n1. List the hook type (useState, useEffect, custom hooks, etc.)\n2. Show where it's used (file paths and approximate line numbers)\n3. Identify any custom hooks and their purpose\n4. Note any potential issues (missing dependencies, excessive re-renders)\n\nRun gemini-cli with appropriate flags and return the raw output.\n```\n\n### Step 5: Process Subagent Results\n\nOnce the subagent returns gemini-cli output:\n\n1. **Review the raw results**: The subagent returns uninterpreted gemini output\n2. **Interpret findings**: Analyze what gemini found\n3. **Summarize for the user**: Create a clear, actionable summary\n4. **Provide specific file references**: Include file paths and line numbers\n5. **Suggest next steps**: Recommend actions based on findings\n\n### Step 6: Follow Up If Needed\n\nIf the initial analysis needs refinement:\n- Spawn the subagent again with a more focused request\n- Ask for deeper analysis of specific areas\n- Request additional context from gemini\n- Cross-reference findings with code reads\n\n## Examples\n\n### Example 1: Finding React Hooks Patterns\n\n**User Request:** \"Find all React hooks in the codebase and identify any issues\"\n\n**Step 1 - Identify**: Pattern Detection analysis\n\n**Step 2 - Gather Context:**\n- Codebase: React/Next.js application\n- Location: /Users/joel/my-app\n- Focus: All .tsx and .jsx files\n- Looking for: hooks usage and potential issues\n\n**Step 3 - Spawn Subagent:**\n\n```\nTask tool with subagent_type: \"gemini-code-analyzer\"\n\nPrompt:\n\"Analyze the React codebase at /Users/joel/my-app for hooks usage patterns.\n\nContext:\n- Next.js 14 application with App Router\n- TypeScript-based React components\n- Focus on all .tsx files in app/ and components/ directories\n\nAnalysis Request:\nFind all React hooks usage in this codebase and analyze them:\n\n1. Built-in hooks (useState, useEffect, useContext, etc.):\n   - Count usage of each hook type\n   - Identify the most commonly used hooks\n\n2. Custom hooks:\n   - List all custom hooks defined\n   - Show where each custom hook is used\n   - Describe each custom hook's purpose\n\n3. Potential issues:\n   - Missing dependencies in useEffect\n   - Hooks called conditionally or in loops\n   - Excessive re-renders from state updates\n   - Complex hook chains that could be simplified\n\nOutput format:\nProvide a structured report with file paths and approximate line numbers for each finding.\n\nRun: gemini --all-files --yolo -p with the above analysis prompt\nReturn the raw gemini output.\"\n```\n\n**Step 5 - Process Results:**\n```\nBased on gemini's analysis, here's what I found:\n\n## Hooks Usage Summary\n\n### Built-in Hooks\n- useState: 47 instances across 23 components\n- useEffect: 31 instances across 18 components\n- useContext: 12 instances (AuthContext, ThemeContext)\n- useCallback: 8 instances\n- useMemo: 5 instances\n\n### Custom Hooks (4 found)\n1. `useAuth` (hooks/useAuth.ts:12) - Used in 8 components\n2. `useLocalStorage` (hooks/useLocalStorage.ts:8) - Used in 3 components\n3. `useDebounce` (hooks/useDebounce.ts:5) - Used in 2 components\n4. `useFetch` (hooks/useFetch.ts:15) - Used in 6 components\n\n### Issues Identified\n⚠️ Missing dependencies in components/Dashboard.tsx:45\n⚠️ Conditional hook call in components/UserProfile.tsx:78\n⚠️ Potential re-render issue in components/ProductList.tsx:92\n\nNext steps:\n1. Fix the missing dependencies in Dashboard component\n2. Refactor conditional hook usage in UserProfile\n3. Consider memoization in ProductList to reduce re-renders\n```\n\n### Example 2: Architecture Analysis\n\n**User Request:** \"I need to understand the authentication flow in this application\"\n\n**Spawn Subagent:**\n```\nTask tool with subagent_type: \"gemini-code-analyzer\"\n\nPrompt:\n\"Analyze the authentication flow in the codebase at /Users/joel/my-app.\n\nContext:\n- Next.js application with API routes\n- Using JWT for authentication\n- Has both client and server-side auth checks\n\nAnalysis Request:\nTrace the complete authentication flow through this application:\n\n1. Authentication Entry Points:\n   - Where does login/signup happen? (UI components, API routes)\n   - What authentication methods are supported?\n\n2. Token Management:\n   - How are JWT tokens created?\n   - Where are tokens stored? (cookies, localStorage, etc.)\n   - How are tokens validated?\n\n3. Protected Routes:\n   - Which routes require authentication?\n   - How are auth checks implemented (middleware, HOCs, etc.)?\n   - Where are unauthorized users redirected?\n\n4. Session Management:\n   - How are sessions maintained?\n   - What's the token refresh mechanism?\n   - How does logout work?\n\n5. Data Flow:\n   - Map the complete flow from login button click to authenticated state\n   - Show all components and functions involved\n   - Include file paths for each step\n\nRun: gemini --all-files --yolo -p with the above prompt\nReturn the raw output.\"\n```\n\n### Example 3: Security Vulnerability Scan\n\n**User Request:** \"Check the codebase for security vulnerabilities\"\n\n**Spawn Subagent:**\n```\nTask tool with subagent_type: \"gemini-code-analyzer\"\n\nPrompt:\n\"Perform a security audit on the codebase at /Users/joel/my-app.\n\nContext:\n- Node.js/Express API backend\n- React frontend\n- PostgreSQL database\n- Handles user data and payments\n\nSecurity Analysis:\nAudit the codebase for common security vulnerabilities:\n\n1. Injection Vulnerabilities:\n   - SQL injection risks (raw queries, dynamic SQL)\n   - NoSQL injection risks\n   - Command injection possibilities\n\n2. XSS (Cross-Site Scripting):\n   - Unsanitized user input rendering\n   - Dangerous use of dangerouslySetInnerHTML\n   - Unsafe DOM manipulation\n\n3. Authentication & Authorization:\n   - Weak password policies\n   - Insecure token storage\n   - Missing authorization checks\n   - Session management issues\n\n4. Sensitive Data Exposure:\n   - Hardcoded secrets or API keys\n   - Logging sensitive information\n   - Unencrypted data transmission\n\n5. API Security:\n   - Missing rate limiting\n   - CORS misconfigurations\n   - Unvalidated input\n   - Missing CSRF protection\n\nFor each finding:\n- Severity level (Critical, High, Medium, Low)\n- File path and location\n- Description of the vulnerability\n- Potential impact\n- Recommended fix\n\nRun: gemini --all-files --yolo -p with security analysis\nReturn raw output.\"\n```\n\n### Example 4: Performance Bottleneck Detection\n\n**User Request:** \"Find performance issues in the React application\"\n\n**Spawn Subagent:**\n```\nTask tool with subagent_type: \"gemini-code-analyzer\"\n\nPrompt:\n\"Analyze performance bottlenecks in the React application at /Users/joel/my-app.\n\nContext:\n- React 18 with Next.js 14\n- Large component tree (~100 components)\n- User reports slow rendering\n\nPerformance Analysis:\nIdentify performance bottlenecks in this application:\n\n1. Re-render Issues:\n   - Components that re-render unnecessarily\n   - Missing React.memo optimizations\n   - Inefficient state updates\n   - Context API performance issues\n\n2. Bundle Size:\n   - Large imported libraries\n   - Unused dependencies\n   - Missing code splitting\n   - Opportunities for lazy loading\n\n3. Data Fetching:\n   - Sequential API calls that could be parallel\n   - Missing caching strategies\n   - Over-fetching data\n   - N+1 query patterns\n\n4. Expensive Operations:\n   - Complex calculations in render\n   - Missing useMemo/useCallback\n   - Large list rendering without virtualization\n   - Unoptimized images\n\n5. Next.js Specific:\n   - Improper use of Server/Client Components\n   - Missing static generation opportunities\n   - Inefficient data fetching patterns\n\nFor each issue found:\n- File path and location\n- Description of the problem\n- Performance impact (estimated)\n- Recommended optimization\n- Code example if applicable\n\nRun: gemini --all-files --yolo -p with performance analysis\nReturn raw output.\"\n```\n\n## Best Practices\n\n### Providing Context\n1. **Be specific about the codebase**: Include tech stack, project type, and location\n2. **Define clear analysis goals**: Tell gemini exactly what to look for\n3. **Request structured output**: Ask for organized results (tables, lists, hierarchies)\n4. **Include file path requests**: Always ask gemini to include locations\n5. **Set scope appropriately**: Focus on relevant directories when possible\n\n### Working with Subagent Results\n1. **Trust the subagent**: It's designed to use gemini-cli correctly\n2. **Interpret raw output**: The subagent returns unprocessed gemini results\n3. **Validate findings**: Cross-check important findings with code reads\n4. **Provide summaries**: Translate gemini's analysis into actionable insights\n5. **Iterate as needed**: Don't hesitate to spawn the subagent again for deeper analysis\n\n### Optimizing Analysis\n1. **Use --all-files**: For comprehensive analysis across the entire codebase\n2. **Be specific in prompts**: Clear prompts yield better gemini results\n3. **Request examples**: Ask gemini to provide code examples in findings\n4. **Ask for severity levels**: For issues, request prioritization\n5. **Combine with code reads**: Use Read tool for detailed examination of specific findings\n\n### Handling Large Codebases\n1. **Leverage Gemini's 1M tokens**: Perfect for analyzing large projects\n2. **Start broad, then narrow**: Get overview first, then deep dive\n3. **Focus on patterns**: Look for patterns rather than individual instances\n4. **Use interactive mode**: For complex multi-step analysis\n5. **Save token budget**: Use gemini for broad analysis, Read for specific files\n\n## Common Issues and Solutions\n\n### Issue 1: Subagent Returns \"gemini-cli not found\"\n**Problem:** gemini-cli is not installed or not in PATH\n\n**Solutions:**\n- Install gemini-cli: `npm install -g @anthropic/gemini-cli`\n- Verify installation: `gemini --version`\n- Check PATH configuration\n- Provide installation instructions to user\n\n### Issue 2: Analysis Too Broad/Vague\n**Problem:** Gemini returns generic or unfocused results\n\n**Solutions:**\n- Provide more specific context in the prompt\n- Narrow the scope to specific directories or file types\n- Ask for concrete examples rather than general descriptions\n- Include specific patterns or issues to look for\n- Request structured output format\n\n### Issue 3: Missing File Paths in Results\n**Problem:** Gemini's analysis doesn't include file locations\n\n**Solutions:**\n- Explicitly request file paths in the prompt\n- Ask for line numbers or code snippets\n- Request \"specific locations\" for each finding\n- Use phrasing like \"include file paths for all findings\"\n\n### Issue 4: Analysis Takes Too Long\n**Problem:** gemini-cli takes a very long time to respond\n\n**Solutions:**\n- Reduce scope to specific directories\n- Focus on particular file types (e.g., only .tsx files)\n- Break analysis into smaller chunks\n- Use multiple targeted prompts instead of one comprehensive request\n- Check if --all-files is necessary for the specific task\n\n### Issue 5: Subagent Misunderstands Request\n**Problem:** Results don't match what was requested\n\n**Solutions:**\n- Review the prompt for clarity\n- Add more context about the codebase\n- Be explicit about desired output format\n- Provide examples of what you're looking for\n- Break complex requests into simpler sub-requests\n- Spawn subagent again with refined prompt\n\n### Issue 6: Need to Combine Multiple Analysis Types\n**Problem:** Request requires multiple types of analysis\n\n**Solutions:**\n- Spawn subagent multiple times for different analysis types\n- Create comprehensive prompts that combine related analyses\n- Use interactive mode for multi-step analysis\n- Prioritize analyses and run sequentially\n- Aggregate results from multiple subagent runs\n\n## Advanced Usage\n\n### Multi-Step Analysis\nFor complex analysis requiring multiple phases:\n\n1. **Phase 1 - Discovery**: Spawn subagent to find relevant areas\n2. **Phase 2 - Deep Dive**: Spawn again focusing on findings from Phase 1\n3. **Phase 3 - Validation**: Use Read tool to verify specific findings\n4. **Phase 4 - Summary**: Compile results into actionable report\n\n### Combining with Other Tools\n- Use **Read** to examine specific files from gemini findings\n- Use **Grep** to find additional instances of patterns discovered\n- Use **Bash** to run tests or linters on identified issues\n- Use **web-researcher skill** to find solutions for identified problems\n\n### Custom Analysis Workflows\nCreate specialized analysis workflows:\n\n**Security Audit Workflow:**\n1. Spawn code-analyzer for vulnerability scan\n2. Prioritize findings by severity\n3. Read specific vulnerable files\n4. Spawn web-researcher for fix recommendations\n5. Apply fixes and validate\n\n**Performance Optimization Workflow:**\n1. Spawn code-analyzer for bottleneck detection\n2. Measure current performance (Bash for benchmarks)\n3. Read problem areas in detail\n4. Research optimization techniques (web-researcher)\n5. Implement optimizations\n6. Re-analyze for improvements\n\n**Refactoring Planning Workflow:**\n1. Spawn code-analyzer for legacy pattern detection\n2. Map out affected areas\n3. Research modern alternatives (web-researcher)\n4. Plan refactoring in phases\n5. Validate with targeted re-analysis\n\n## Resources\n\nThe code-analyzer skill uses the gemini-code-analyzer agent, which:\n- Wraps gemini-cli for code analysis\n- Uses --all-files --yolo flags for comprehensive analysis\n- Returns raw gemini output without interpretation\n- Supports all analysis categories listed in this skill\n\nFor more information:\n- gemini-cli documentation: https://github.com/anthropics/gemini-cli\n- Agent definition: `plugins/analysis/gemini-research/agents/code-analyzer.md`\n- Related skill: web-researcher for finding solutions and documentation\n",
        "plugins/analysis/gemini-research/skills/web-researcher/SKILL.md": "# Web Researcher Skill\n\n## Purpose\n\nPerform comprehensive web research for technical documentation, solutions, and technology comparisons using Gemini's web access capabilities through the gemini-web-researcher subagent. This skill finds current documentation, researches best practices, compares technologies, and gathers technical information by spawning a specialized subagent that wraps gemini-cli.\n\n## When to Use This Skill\n\nUse this skill when you need to:\n- Find latest documentation for libraries, frameworks, or APIs\n- Research solutions to technical problems and troubleshooting\n- Compare technologies, libraries, frameworks, or approaches\n- Look up best practices and current recommendations\n- Understand third-party APIs and SDKs\n- Research security patterns and vulnerability mitigations\n- Find performance optimization techniques\n- Stay updated on framework/tool changes and migrations\n\nDo NOT use this skill when:\n- Information is already in the codebase (use Read tool or code-analyzer skill)\n- You need to analyze code patterns (use code-analyzer skill)\n- The question can be answered from your training data\n- Real-time information isn't necessary\n\n## Prerequisites\n\nBefore using this skill:\n1. **gemini-cli must be installed**: `npm install -g @anthropic/gemini-cli`\n2. **gemini-cli must be configured**: With valid API credentials and web access\n3. **Clear research goals**: Know what information you're looking for\n4. **Context about the problem**: Understand why this research is needed\n\nTo verify gemini-cli is installed:\n```bash\ngemini --version\n```\n\n## Instructions\n\n### Step 1: Understand the Research Request\n\nIdentify what type of research is needed:\n- **Documentation Lookup**: Finding official docs, API references, guides\n- **Solution Research**: Finding fixes, workarounds, best practices\n- **Technology Comparison**: Evaluating different options and trade-offs\n- **API/SDK Research**: Understanding third-party integrations\n- **Updates & Migrations**: Learning about new features and changes\n- **Architecture Patterns**: Researching design patterns and approaches\n- **Security Research**: Finding security best practices and mitigations\n- **Performance**: Researching optimization techniques\n\n### Step 2: Gather Context\n\nCollect relevant information:\n- **Current tech stack**: What technologies are being used\n- **Specific problem**: What issue needs solving or information needed\n- **Constraints**: Version requirements, compatibility needs, limitations\n- **Use case**: How the information will be applied\n- **Urgency**: Whether latest/cutting-edge info is needed\n\n### Step 3: Spawn the Gemini Web Researcher Subagent\n\nUse the Task tool to spawn the gemini-web-researcher subagent with a detailed research request.\n\n**Template:**\n```\nUse the Task tool with:\n- subagent_type: \"gemini-web-researcher\"\n- description: \"[Brief 3-5 word description]\"\n- prompt: \"[Detailed research request with context]\"\n```\n\n**Your prompt should include:**\n1. **Context**: What project/problem this research is for\n2. **Research type**: Which category from Step 1\n3. **Specific question**: Exactly what to research\n4. **Information needed**: What details are important\n5. **Current year/relevance**: Request current/recent information\n6. **Output format**: How to structure the results\n\n### Step 4: Provide Comprehensive Context to the Subagent\n\nThe subagent needs detailed context to construct effective research prompts. Include:\n\n**Project Context:**\n- Technology stack being used\n- Current implementation or approach\n- Version numbers if relevant\n- Scale or complexity of the project\n\n**Research Specifics:**\n- Exact question or problem to research\n- Why this information is needed\n- How it will be applied\n- Any specific requirements or constraints\n\n**Desired Output:**\n- Links to official documentation\n- Code examples if applicable\n- Comparison tables for evaluations\n- Step-by-step guides for implementations\n- Current best practices and recommendations\n\n**Example Prompt to Subagent:**\n```\nI need to research authentication solutions for a Next.js 14 application.\n\nContext:\n- Next.js 14 App Router application\n- Need user authentication with email/password and OAuth\n- Planning to use PostgreSQL for user data\n- Must support session management and protected routes\n\nResearch Request:\nFind current best practices and solutions for implementing authentication in Next.js 14 applications. Specifically research:\n\n1. Authentication Libraries:\n   - Compare NextAuth.js, Clerk, Supabase Auth, and Lucia\n   - Pros and cons of each\n   - Which works best with Next.js 14 App Router\n\n2. Implementation Patterns:\n   - How to protect routes in App Router\n   - Session management approaches\n   - Token storage best practices\n\n3. OAuth Integration:\n   - Setting up Google and GitHub OAuth\n   - Recommended providers\n\n4. Security Considerations:\n   - CSRF protection\n   - Secure token handling\n   - Best practices for 2024\n\nPlease include:\n- Links to official documentation\n- Code examples where relevant\n- Current recommendations (2024)\n- Migration guides if applicable\n\nRun gemini-cli with appropriate research prompt and return the raw output.\n```\n\n### Step 5: Process Subagent Results\n\nOnce the subagent returns gemini research results:\n\n1. **Review the raw findings**: The subagent returns uninterpreted gemini output\n2. **Extract key information**: Pull out relevant documentation, solutions, comparisons\n3. **Summarize for the user**: Create a clear, actionable summary\n4. **Provide links**: Include all documentation links found\n5. **Make recommendations**: Suggest best approaches based on research\n6. **Identify next steps**: What should be done with this information\n\n### Step 6: Follow Up If Needed\n\nIf the initial research needs more detail:\n- Spawn the subagent again with a more focused request\n- Research specific aspects in more depth\n- Compare specific options more thoroughly\n- Find additional examples or use cases\n\n## Examples\n\n### Example 1: Documentation Lookup\n\n**User Request:** \"How do I use React Server Components in Next.js 14?\"\n\n**Step 1 - Identify**: Documentation Lookup\n\n**Step 2 - Gather Context:**\n- Tech: Next.js 14 with React\n- Need: Understanding Server Components\n- Use case: Building new features correctly\n\n**Step 3 - Spawn Subagent:**\n\n```\nTask tool with subagent_type: \"gemini-web-researcher\"\n\nPrompt:\n\"Research React Server Components in Next.js 14.\n\nContext:\n- Next.js 14 application using App Router\n- Need to understand Server Components vs Client Components\n- Want to use this for building new features\n\nResearch Request:\nFind the latest Next.js 14 documentation on React Server Components. Include:\n\n1. Core Concepts:\n   - What are Server Components?\n   - Server vs Client Components differences\n   - When to use each type\n\n2. Implementation:\n   - How to create Server Components\n   - How to mark Client Components ('use client')\n   - Data fetching in Server Components\n   - Passing props between Server and Client Components\n\n3. Best Practices:\n   - Component composition patterns\n   - Common pitfalls to avoid\n   - Performance considerations\n\n4. Examples:\n   - Code examples of Server Components\n   - Common patterns (layouts, data fetching, etc.)\n   - Real-world use cases\n\nPlease provide:\n- Links to official Next.js documentation\n- Code examples\n- Best practices for 2024\n- Any recent updates or changes\n\nRun: gemini -p with this research request\nReturn the raw gemini output.\"\n```\n\n**Step 5 - Process Results:**\n```\nBased on gemini's research, here's what I found:\n\n## React Server Components in Next.js 14\n\n### Official Documentation\n- Next.js Server Components: https://nextjs.org/docs/app/building-your-application/rendering/server-components\n- React Server Components RFC: https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md\n\n### Key Concepts\n\n**Server Components (Default in App Router):**\n- Run on the server only\n- Can directly access backend resources (databases, file system)\n- Don't send JavaScript to the client\n- Cannot use hooks or browser APIs\n\n**Client Components ('use client'):**\n- Run on both server (for SSR) and client\n- Can use hooks and browser APIs\n- Required for interactivity\n- Add JavaScript bundle to client\n\n### When to Use Each\n\nUse Server Components for:\n✓ Data fetching from databases/APIs\n✓ Accessing backend resources\n✓ Keeping sensitive data on server\n✓ Reducing client-side JavaScript\n\nUse Client Components for:\n✓ Interactive elements (onClick, onChange)\n✓ Using React hooks (useState, useEffect)\n✓ Browser APIs (localStorage, geolocation)\n✓ Third-party libraries requiring browser\n\n### Implementation Example\n\nServer Component (default):\n\\`\\`\\`tsx\n// app/products/page.tsx\nasync function ProductsPage() {\n  // Direct database access - runs on server\n  const products = await db.products.findMany();\n\n  return (\n    <div>\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  );\n}\n\\`\\`\\`\n\nClient Component:\n\\`\\`\\`tsx\n// components/AddToCart.tsx\n'use client';\n\nimport { useState } from 'react';\n\nexport function AddToCart({ productId }: { productId: string }) {\n  const [loading, setLoading] = useState(false);\n\n  const handleClick = async () => {\n    setLoading(true);\n    await addToCart(productId);\n    setLoading(false);\n  };\n\n  return (\n    <button onClick={handleClick} disabled={loading}>\n      Add to Cart\n    </button>\n  );\n}\n\\`\\`\\`\n\n### Best Practices\n1. **Default to Server**: Use Server Components by default, only use 'use client' when needed\n2. **Push Client Components down**: Keep interactivity at leaf nodes\n3. **Fetch data where needed**: Server Components can fetch their own data\n4. **Compose carefully**: Server Components can import Client Components, but not vice versa\n5. **Avoid prop drilling**: Fetch data close to where it's used\n\nNext step: Start using Server Components for data fetching and reserve Client Components for interactive elements.\n```\n\n### Example 2: Solution Research\n\n**User Request:** \"How can I fix hydration errors in my Next.js app?\"\n\n**Spawn Subagent:**\n```\nTask tool with subagent_type: \"gemini-web-researcher\"\n\nPrompt:\n\"Research solutions for Next.js hydration errors.\n\nContext:\n- Next.js 14 application\n- Getting hydration mismatch errors in production\n- Need to understand causes and solutions\n\nResearch Request:\nFind comprehensive information about fixing hydration errors in Next.js:\n\n1. Common Causes:\n   - What causes hydration mismatches?\n   - Typical scenarios (dates, IDs, localStorage, etc.)\n   - Why they happen\n\n2. Debugging:\n   - How to identify the source of hydration errors\n   - Tools and techniques for debugging\n   - Reading error messages\n\n3. Solutions:\n   - Fixes for date/time hydration issues\n   - Handling localStorage and browser-only code\n   - Fixing random ID generation\n   - Third-party script issues\n   - Conditional rendering problems\n\n4. Prevention:\n   - Best practices to avoid hydration errors\n   - Patterns to use\n   - Testing strategies\n\n5. Next.js Specific:\n   - suppressHydrationWarning usage\n   - useEffect patterns\n   - Dynamic imports with { ssr: false }\n\nInclude:\n- Official Next.js documentation links\n- Stack Overflow solutions\n- Code examples for each scenario\n- Current best practices (2024)\n\nRun: gemini -p with this research\nReturn raw output.\"\n```\n\n### Example 3: Technology Comparison\n\n**User Request:** \"Should I use Prisma or Drizzle ORM for my new project?\"\n\n**Spawn Subagent:**\n```\nTask tool with subagent_type: \"gemini-web-researcher\"\n\nPrompt:\n\"Compare Prisma and Drizzle ORM for a new TypeScript project.\n\nContext:\n- Building a new Next.js application\n- PostgreSQL database\n- TypeScript-first development\n- Team of 3 developers with varying SQL experience\n\nResearch Request:\nProvide a comprehensive comparison of Prisma vs Drizzle ORM:\n\n1. Features:\n   - Type safety capabilities\n   - Schema definition approaches\n   - Migration systems\n   - Query builders\n   - Relation handling\n\n2. Performance:\n   - Query performance benchmarks\n   - Bundle size impact\n   - Cold start times (serverless)\n   - Caching mechanisms\n\n3. Developer Experience:\n   - Learning curve\n   - Documentation quality\n   - IDE support\n   - Debugging experience\n   - Community and ecosystem\n\n4. Use Cases:\n   - When to use Prisma\n   - When to use Drizzle\n   - Hybrid approaches\n\n5. Trade-offs:\n   - Pros and cons of each\n   - Deal breakers or limitations\n   - Migration difficulty if switching later\n\n6. Current State (2024):\n   - Maturity and stability\n   - Active development\n   - Community adoption trends\n   - Recent updates\n\nPlease include:\n- Links to official documentation\n- Benchmark comparisons if available\n- Real-world use case examples\n- Expert recommendations\n- Community sentiment\n\nCreate a comparison table and provide a recommendation based on the context.\n\nRun: gemini -p with comparison research\nReturn raw output.\"\n```\n\n### Example 4: API Integration Research\n\n**User Request:** \"How do I integrate Stripe subscriptions into my app?\"\n\n**Spawn Subagent:**\n```\nTask tool with subagent_type: \"gemini-web-researcher\"\n\nPrompt:\n\"Research Stripe subscription integration for a Next.js application.\n\nContext:\n- Next.js 14 with App Router\n- Need to implement subscription billing\n- SaaS application with multiple pricing tiers\n- PostgreSQL database for user data\n\nResearch Request:\nFind comprehensive information about implementing Stripe subscriptions:\n\n1. Setup and Configuration:\n   - Stripe account setup\n   - API keys management\n   - Webhook configuration\n   - Test mode vs production\n\n2. Subscription Creation:\n   - Creating subscription products and prices\n   - Implementing checkout flow\n   - Payment method collection\n   - Customer creation\n\n3. Subscription Management:\n   - Handling billing cycles\n   - Managing pricing tiers\n   - Upgrades and downgrades\n   - Cancellations and pauses\n\n4. Webhooks:\n   - Essential webhooks for subscriptions\n   - Webhook signature verification\n   - Handling subscription events\n   - Error handling and retries\n\n5. Customer Portal:\n   - Implementing customer billing portal\n   - Self-service subscription management\n   - Invoice access\n\n6. Next.js Integration:\n   - Recommended libraries (@stripe/stripe-js)\n   - API route implementation\n   - Server Actions for Stripe operations\n   - Security best practices\n\n7. Testing:\n   - Test cards and scenarios\n   - Testing webhooks locally\n   - Stripe CLI usage\n\nInclude:\n- Official Stripe documentation links\n- Next.js integration examples\n- Complete code snippets\n- Best practices for production\n- Common pitfalls to avoid\n\nRun: gemini -p with Stripe research\nReturn raw output.\"\n```\n\n## Best Practices\n\n### Crafting Research Requests\n1. **Be specific about tech stack**: Include versions, frameworks, languages\n2. **Request current information**: Always ask for latest/2024 information\n3. **Ask for links**: Request official documentation URLs\n4. **Include context**: Explain the use case and constraints\n5. **Specify output format**: Ask for tables, lists, examples as needed\n\n### Working with Subagent Results\n1. **Trust the subagent**: It's designed to use gemini-cli for research correctly\n2. **Interpret findings**: The subagent returns raw gemini research output\n3. **Verify critical info**: Double-check important technical details\n4. **Provide summaries**: Distill research into actionable information\n5. **Include links**: Always pass through documentation URLs to the user\n\n### Optimizing Research\n1. **Focus the question**: Narrow scope for better results\n2. **Request examples**: Ask for code examples and use cases\n3. **Ask for comparisons**: When evaluating options, request comparison tables\n4. **Seek current info**: Emphasize need for recent/updated information\n5. **Follow up intelligently**: Use initial research to inform follow-up questions\n\n### Combining with Other Skills\n1. **Research then implement**: Use web-researcher to find approaches, then code\n2. **Research then analyze**: Find best practices, then use code-analyzer to audit codebase\n3. **Iterative research**: Research broadly, then deeply on specific findings\n4. **Validate with docs**: Cross-reference research results with official docs\n\n## Common Issues and Solutions\n\n### Issue 1: Subagent Returns \"gemini-cli not found\"\n**Problem:** gemini-cli is not installed or not in PATH\n\n**Solutions:**\n- Install gemini-cli: `npm install -g @anthropic/gemini-cli`\n- Verify installation: `gemini --version`\n- Check PATH configuration\n- Provide installation instructions to user\n\n### Issue 2: Research Results Are Outdated\n**Problem:** Gemini returns old information or deprecated approaches\n\n**Solutions:**\n- Explicitly request \"latest\" or \"2024\" information in prompt\n- Ask for \"current best practices\"\n- Request recent documentation\n- Specify framework/library versions in the question\n- Follow up with more specific date constraints\n\n### Issue 3: Too Much General Information\n**Problem:** Results are too broad or not actionable\n\n**Solutions:**\n- Make the research question more specific\n- Include more context about the use case\n- Request specific format (e.g., \"step-by-step guide\")\n- Ask for code examples\n- Narrow the scope to one aspect at a time\n\n### Issue 4: Missing Code Examples\n**Problem:** Research provides concepts but no practical examples\n\n**Solutions:**\n- Explicitly request \"code examples\" in the prompt\n- Ask for \"implementation examples\"\n- Request \"working code snippets\"\n- Specify the language/framework for examples\n- Ask for \"real-world use cases with code\"\n\n### Issue 5: Comparison Doesn't Address Specific Needs\n**Problem:** Technology comparison is generic, not tailored to use case\n\n**Solutions:**\n- Provide more detailed context about requirements\n- Specify constraints (team size, experience, scale, budget)\n- Ask for comparison on specific criteria\n- Request \"recommendation based on [specific context]\"\n- Include deal-breakers or must-have features\n\n### Issue 6: Documentation Links Are Broken or Missing\n**Problem:** No links provided or links don't work\n\n**Solutions:**\n- Explicitly request \"official documentation links\"\n- Ask for \"source URLs\"\n- Request \"references to official docs\"\n- Follow up with specific request for links\n- Search for official docs yourself as backup\n\n## Advanced Usage\n\n### Multi-Step Research\nFor complex research requiring multiple phases:\n\n1. **Phase 1 - Broad Overview**: Research the general approach or technology\n2. **Phase 2 - Specific Solutions**: Deep dive into chosen approach\n3. **Phase 3 - Implementation Details**: Research specific integration steps\n4. **Phase 4 - Best Practices**: Find optimization and production considerations\n\n### Research Workflows\n\n**New Technology Evaluation:**\n1. Research what the technology is and its purpose\n2. Compare with alternatives\n3. Research integration steps\n4. Find best practices and gotchas\n5. Look for community sentiment and adoption\n\n**Problem Solving Workflow:**\n1. Research the problem/error message\n2. Find common causes\n3. Research solutions and workarounds\n4. Find best practices to prevent recurrence\n5. Look for related issues and edge cases\n\n**API Integration Workflow:**\n1. Research API documentation and capabilities\n2. Find authentication and setup steps\n3. Research common integration patterns\n4. Find SDK/library recommendations\n5. Research testing and debugging approaches\n\n**Migration Planning Workflow:**\n1. Research what's changed in new version\n2. Find official migration guides\n3. Research breaking changes and gotchas\n4. Find community migration experiences\n5. Research tools and helpers for migration\n\n### Combining Research and Analysis\n\nUse both skills together for comprehensive understanding:\n\n**Audit and Improve Workflow:**\n1. **code-analyzer**: Analyze current implementation\n2. **web-researcher**: Research better approaches\n3. **code-analyzer**: Find all places needing updates\n4. **web-researcher**: Research specific migration steps\n5. Implement improvements based on combined insights\n\n**Learning Codebase Workflow:**\n1. **code-analyzer**: Map out architecture and patterns\n2. **web-researcher**: Research unfamiliar patterns found\n3. **code-analyzer**: Find examples of pattern usage in codebase\n4. **web-researcher**: Research best practices for those patterns\n5. Document learnings for team\n\n## Interactive Research Mode\n\nFor complex topics requiring iterative exploration, the subagent can use gemini's interactive mode:\n\n**Example - Deep Technology Evaluation:**\n```\nPrompt to subagent:\n\"Use interactive mode (gemini -i) to research GraphQL vs REST for my use case.\n\nStart by asking gemini about the high-level differences, then based on the response, ask follow-up questions about:\n- Performance implications for my scale (1000 req/sec)\n- Client complexity differences\n- Caching strategies\n- Real-time data handling\n\nConduct this as an interactive research session and return the complete conversation.\"\n```\n\n## Resources\n\nThe web-researcher skill uses the gemini-web-researcher agent, which:\n- Wraps gemini-cli for web research\n- Has access to current web information\n- Returns raw gemini output without interpretation\n- Supports all research categories listed in this skill\n\nFor more information:\n- gemini-cli documentation: https://github.com/anthropics/gemini-cli\n- Agent definition: `plugins/analysis/gemini-research/agents/web-researcher.md`\n- Related skill: code-analyzer for analyzing codebases and patterns\n",
        "plugins/claude/interview/.claude-plugin/plugin.json": "{\n  \"name\": \"interview\",\n  \"description\": \"Interactive interview command that asks in-depth questions to gather detailed requirements and generate comprehensive specifications\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Joel Chan\",\n    \"email\": \"joel611@live.hk\"\n  }\n}\n",
        "plugins/claude/interview/README.md": "# Ask Me Command\n\n## Description\n\nConduct an in-depth interactive interview to gather detailed requirements and specifications. Uses iterative questioning to explore technical implementation, UI/UX considerations, concerns, tradeoffs, and edge cases before generating a comprehensive specification document.\n\n## Usage\n\n```\n/ask-me [topic or feature description]\n```\n\n## Parameters\n\n- `topic or feature description` - The feature, system, or topic you want to be interviewed about (required)\n\n## Examples\n\n```\n/ask-me build a login system using better-auth\n```\n\n```\n/ask-me create a real-time chat feature\n```\n\n```\n/ask-me implement a file upload system with image processing\n```\n\n## Instructions for Claude\n\nWhen this command is invoked:\n\nRead this: #$ARGUMENTS\n\nInterview me in detail using the AskUserQuestion tool about literally anything: technical implementation, UI & UX, concerns, tradeoffs, etc. but make sure the questions are not obvious.\n\nBe very in-depth and continue interviewing me continually until it's complete, then write the spec to the file.\n\n### Interview Process\n\n1. **Understand the Context**\n   - Read and analyze the topic/feature provided in arguments\n   - Identify key areas that need clarification\n\n2. **Ask Non-Obvious Questions**\n   - Focus on technical implementation details\n   - Explore UI/UX implications and user flows\n   - Investigate edge cases and error scenarios\n   - Discuss security and performance considerations\n   - Examine data models and architecture decisions\n   - Consider scalability and future extensibility\n   - Understand integration points and dependencies\n\n3. **Iterative Deep Dive**\n   - Use AskUserQuestion tool for each round of questions\n   - Build upon previous answers to ask deeper questions\n   - Continue until all critical aspects are covered\n   - Don't stop at surface-level answers\n\n4. **Generate Comprehensive Spec**\n   - Once interview is complete, write a detailed specification\n   - Include all gathered requirements and decisions\n   - Document technical choices and rationale\n   - Specify UI/UX flows and components\n   - List edge cases and error handling\n   - Save to a markdown file with appropriate naming\n\n### Question Categories to Cover\n\n- **Technical Architecture**: Framework choices, patterns, data flow, state management\n- **Data Models**: Schemas, relationships, validation rules, constraints\n- **User Experience**: Flows, interactions, feedback, accessibility\n- **Security**: Authentication, authorization, data protection, input validation\n- **Performance**: Optimization strategies, caching, lazy loading\n- **Error Handling**: Validation, error states, user feedback, recovery\n- **Integration**: APIs, third-party services, existing systems\n- **Testing**: Strategy, coverage, test types\n- **Deployment**: Environment considerations, configuration, monitoring\n\n### Output Format\n\nSave the final specification as `spec-[feature-name].md` with sections:\n\n- Overview\n- Requirements\n- Technical Architecture\n- Data Models\n- User Flows\n- UI/UX Specifications\n- Security Considerations\n- Error Handling\n- Testing Strategy\n- Future Considerations\n\n## Notes\n\n- Questions should be specific and thought-provoking, not generic\n- Avoid obvious questions that could be assumed\n- Build a complete mental model before writing the spec\n- The goal is to uncover all critical decisions and considerations upfront\n\ncredit to thariq x post:\n<https://x.com/trq212/status/2005315275026260309>\n",
        "plugins/claude/interview/commands/ask-me.md": "---\ndescription: Conduct an in-depth interactive interview to gather detailed requirements and specifications.\n---\n\n# Ask me\n\nRead this: #$ARGUMENTS\n\nInterview me in detail using the AskUserQuestion tool about literally anything: technical implementation, UI & UX, concerns, tradeoffs, etc. but make sure the questions are not obvious.\n\nBe very in-depth and continue interviewing me continually until it's complete, then write the spec to the file.\n",
        "plugins/claude/plugin-builder/.claude-plugin/plugin.json": "{\n  \"name\": \"plugin-builder\",\n  \"description\": \"Helps create well-structured Claude Code plugins with skills, commands, and proper metadata following best practices\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Claude Code Marketplace\"\n  }\n}\n",
        "plugins/claude/plugin-builder/skills/plugin-builder/SKILL.md": "# Plugin Builder Skill\n\n## Purpose\n\nThis skill guides you through creating well-structured Claude Code plugins with all necessary components, following best practices for discoverability, maintainability, and user experience.\n\n## When to Use\n\nUse this skill when:\n- Creating a new Claude Code plugin from scratch\n- Adding components (skills, commands, agents, hooks) to existing plugins\n- Generating properly structured SKILL.md files\n- Setting up marketplace plugin registration\n- Validating plugin metadata and structure\n\n## Prerequisites\n\n- Access to a Claude Code marketplace repository\n- Understanding of the plugin's intended functionality\n- Basic knowledge of JSON and Markdown formats\n- Location of the marketplace root directory\n\n## Plugin Architecture Overview\n\nA Claude Code plugin follows this structure:\n\n```\nplugin-name/\n├── .claude-plugin/\n│   └── plugin.json       # Required: Plugin metadata\n├── skills/               # Optional: Agent Skills\n│   └── skill-name/\n│       ├── SKILL.md      # Skill instructions\n│       ├── scripts/      # Optional: Executable code\n│       └── resources/    # Optional: Templates, data\n├── commands/             # Optional: Custom slash commands\n│   └── command-name.md\n├── agents/               # Optional: Custom agent definitions\n├── hooks/                # Optional: Event handlers\n│   └── hooks.json\n└── .mcp.json            # Optional: MCP server configuration\n```\n\n## Instructions\n\n### Step 1: Plan the Plugin\n\nBefore creating files, clarify:\n1. **Plugin name** (use kebab-case: `my-plugin-name`)\n2. **Purpose** (what problem does it solve?)\n3. **Components needed** (skills, commands, agents, hooks?)\n4. **Target users** (who will use this plugin?)\n\n### Step 2: Create Plugin Directory Structure\n\n1. Navigate to the marketplace `plugins/` directory\n2. Create the plugin directory: `plugins/category/plugin-name/`\n3. Create required subdirectories:\n   ```bash\n   mkdir -p plugins/category/plugin-name/.claude-plugin\n   mkdir -p plugins/category/plugin-name/skills\n   mkdir -p plugins/category/plugin-name/commands  # if needed\n   ```\n\n### Step 3: Generate plugin.json\n\nCreate `.claude-plugin/plugin.json` with this structure:\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"description\": \"Clear, concise description of plugin functionality (1-2 sentences)\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"author@example.com\"\n  }\n}\n```\n\n**Required fields:**\n- `name`: Plugin identifier (kebab-case, no spaces)\n- `description`: User-facing description (be specific about what it does)\n- `version`: Semantic version (major.minor.patch)\n- `author.name`: Author's name\n\n**Version Guidelines:**\n- Start with `1.0.0` for initial release\n- Increment patch (1.0.1) for bug fixes\n- Increment minor (1.1.0) for new features (backward compatible)\n- Increment major (2.0.0) for breaking changes\n\n### Step 4: Create Skills (if applicable)\n\nFor each skill in the plugin:\n\n1. **Create skill directory:**\n   ```bash\n   mkdir -p plugins/category/plugin-name/skills/skill-name\n   ```\n\n2. **Create SKILL.md** using progressive disclosure format:\n\n```markdown\n# Skill Name\n\n## Purpose\n[1-2 sentences: What this skill does and its main value]\n\n## When to Use\n[Bullet list of specific scenarios where this skill applies]\n- Creating X\n- Automating Y\n- Solving Z problem\n\n## Prerequisites\n[What's needed before using this skill]\n- Required tools or libraries\n- Necessary permissions or access\n- Context or information needed\n\n## Instructions\n\n### Task 1: [First Major Step]\n[Detailed step-by-step instructions]\n1. Do this first\n2. Then do this\n3. Finally do this\n\n### Task 2: [Second Major Step]\n[More detailed instructions]\n\n[Continue with all major tasks...]\n\n## Examples\n\n### Example 1: [Concrete Use Case]\n[Show complete example with actual code/commands]\n\n\\`\\`\\`language\n[actual code]\n\\`\\`\\`\n\n### Example 2: [Another Use Case]\n[Another complete example]\n\n## Best Practices\n- [Specific practice 1]\n- [Specific practice 2]\n- [Specific practice 3]\n\n## Common Issues\n- **Problem:** [Description]\n  **Solution:** [How to fix]\n- **Problem:** [Description]\n  **Solution:** [How to fix]\n```\n\n3. **Add optional resources:**\n   ```bash\n   mkdir -p plugins/category/plugin-name/skills/skill-name/resources\n   mkdir -p plugins/category/plugin-name/skills/skill-name/scripts\n   ```\n\n**Skill Best Practices:**\n- **Focus:** Each skill should do ONE thing well\n- **Discoverability:** Use clear, searchable names and descriptions\n- **Progressive disclosure:** Start with overview, then details, then examples\n- **Actionable:** Provide concrete steps, not generic advice\n- **Examples:** Include real, working examples users can adapt\n- **Error handling:** Document common issues and solutions\n\n### Step 5: Create Commands (if applicable)\n\nFor custom slash commands:\n\n1. **Create command file:**\n   ```bash\n   touch plugins/category/plugin-name/commands/command-name.md\n   ```\n\n2. **Write command markdown:**\n\n```markdown\n# Command Name\n\n[Description of what this command does]\n\n## Usage\n/command-name [arguments]\n\n## Examples\n/command-name example-arg\n\n## Parameters\n- `arg1`: Description of first argument\n- `arg2`: Description of second argument (optional)\n\n## Instructions for Claude\n[Detailed instructions for what Claude should do when this command is invoked]\n\n1. Step 1\n2. Step 2\n3. Step 3\n```\n\n### Step 6: Update Marketplace Registry\n\n1. **Open marketplace.json:**\n   Located at `.claude-plugin/marketplace.json` in the repository root\n\n2. **Add plugin entry:**\n   ```json\n   {\n     \"name\": \"marketplace-name\",\n     \"plugins\": [\n       {\n         \"name\": \"plugin-name\",\n         \"source\": \"./plugins/category/plugin-name\",\n         \"description\": \"Plugin description\"\n       }\n     ]\n   }\n   ```\n\n   **Important:** For local plugins, the `source` field must start with `./` to specify a relative path from the marketplace root.\n\n### Step 7: Validate Plugin\n\n**Checklist:**\n- [ ] plugin.json exists and has all required fields\n- [ ] Plugin name uses kebab-case (no spaces, lowercase with hyphens)\n- [ ] Description is clear and specific\n- [ ] Version follows semantic versioning (major.minor.patch)\n- [ ] All SKILL.md files follow progressive disclosure format\n- [ ] Examples are included in all SKILL.md files\n- [ ] Commands have clear usage instructions\n- [ ] Plugin is registered in marketplace.json\n- [ ] File paths are correct and accessible\n\n### Step 8: Test Locally\n\n1. **Install the plugin locally:**\n   - User runs: `/plugin install plugin-name@marketplace-name`\n\n2. **Test skill invocation:**\n   - Verify skills are discoverable\n   - Test with relevant prompts\n   - Check that instructions are clear\n\n3. **Test commands:**\n   - Run each slash command\n   - Verify behavior matches documentation\n\n4. **Iterate:**\n   - Fix any issues found\n   - Update documentation as needed\n   - Increment version number for changes\n\n## Complete Examples\n\n### Example 1: Creating a Data Validation Plugin\n\n**Scenario:** Create a plugin that validates JSON schemas\n\n**Step-by-step:**\n\n1. **Create structure:**\n   ```bash\n   mkdir -p plugins/data/json-validator/.claude-plugin\n   mkdir -p plugins/data/json-validator/skills/json-validator\n   ```\n\n2. **Create plugin.json:**\n   ```json\n   {\n     \"name\": \"json-validator\",\n     \"description\": \"Validates JSON data against schemas with detailed error reporting\",\n     \"version\": \"1.0.0\",\n     \"author\": {\n       \"name\": \"Data Team\"\n     }\n   }\n   ```\n\n3. **Create SKILL.md:**\n   ```markdown\n   # JSON Validator Skill\n\n   ## Purpose\n   Validates JSON data against JSON Schema specifications and provides detailed error reports.\n\n   ## When to Use\n   - Validating API request/response payloads\n   - Checking configuration files\n   - Ensuring data structure compliance\n\n   ## Prerequisites\n   - JSON data to validate\n   - JSON Schema definition\n   - Understanding of JSON Schema syntax\n\n   ## Instructions\n\n   ### Validate JSON Data\n   1. Receive or locate the JSON data to validate\n   2. Receive or locate the JSON Schema\n   3. Parse both JSON data and schema\n   4. Validate data against schema\n   5. Report validation results with specific errors\n   6. Suggest fixes for validation errors\n\n   ## Examples\n\n   ### Example 1: Validate User Object\n   Schema:\n   \\`\\`\\`json\n   {\n     \"type\": \"object\",\n     \"properties\": {\n       \"name\": {\"type\": \"string\"},\n       \"age\": {\"type\": \"number\"}\n     },\n     \"required\": [\"name\"]\n   }\n   \\`\\`\\`\n\n   Valid data:\n   \\`\\`\\`json\n   {\"name\": \"Alice\", \"age\": 30}\n   \\`\\`\\`\n\n   Invalid data:\n   \\`\\`\\`json\n   {\"age\": 30}\n   \\`\\`\\`\n   Error: Missing required property 'name'\n\n   ## Best Practices\n   - Always show the full error path for nested objects\n   - Suggest corrected JSON when possible\n   - Validate schema itself before using it\n   - Handle common schema mistakes gracefully\n\n   ## Common Issues\n   - **Problem:** Schema reference ($ref) not resolved\n     **Solution:** Ensure all referenced schemas are accessible\n   - **Problem:** Type coercion confusion\n     **Solution:** Be explicit about type expectations\n   ```\n\n4. **Update marketplace.json:**\n   ```json\n   {\n     \"plugins\": [\n       {\n         \"name\": \"json-validator\",\n         \"source\": \"./plugins/data/json-validator\",\n         \"description\": \"Validates JSON data against schemas\"\n       }\n     ]\n   }\n   ```\n\n### Example 2: Adding a Skill to Existing Plugin\n\n**Scenario:** Add a new skill to the json-validator plugin\n\n1. **Create new skill directory:**\n   ```bash\n   mkdir -p plugins/data/json-validator/skills/schema-generator\n   ```\n\n2. **Create SKILL.md:**\n   ```markdown\n   # Schema Generator Skill\n\n   ## Purpose\n   Generates JSON Schema definitions from example JSON data.\n\n   ## When to Use\n   - Creating schemas from existing data\n   - Documenting API data structures\n   - Reverse engineering schemas\n\n   [... rest of SKILL.md ...]\n   ```\n\n3. **Update plugin version:**\n   Edit `plugin.json`:\n   ```json\n   {\n     \"version\": \"1.1.0\"\n   }\n   ```\n   (Minor version increment for new feature)\n\n## Naming Conventions\n\n**Plugins:**\n- Use kebab-case: `my-plugin-name`\n- Be descriptive but concise\n- Avoid generic names like \"helper\" or \"utility\"\n- Good: `json-validator`, `code-formatter`, `api-tester`\n- Bad: `helper`, `utils`, `my_plugin`\n\n**Skills:**\n- Use clear, action-oriented names\n- Match the skill's primary function\n- Good: `json-validator`, `schema-generator`, `data-transformer`\n- Bad: `skill1`, `helper`, `misc`\n\n**Commands:**\n- Start with verb when possible\n- Be specific about action\n- Good: `validate-json`, `generate-schema`, `format-code`\n- Bad: `do-thing`, `run`, `help`\n\n## Best Practices Summary\n\n### Plugin Design\n- **Single responsibility:** Each plugin should have a clear, focused purpose\n- **Composability:** Plugins should work well together\n- **Discoverability:** Names and descriptions should make purpose obvious\n- **Documentation:** Include examples for all features\n- **Versioning:** Follow semantic versioning strictly\n\n### Skill Design\n- **Progressive disclosure:** Overview → Instructions → Examples\n- **Concrete examples:** Show real code, not pseudocode\n- **Error handling:** Document common issues and solutions\n- **Prerequisites:** List what's needed upfront\n- **Modularity:** Keep skills focused on specific tasks\n\n### Testing\n- **Local testing:** Always test before committing\n- **User perspective:** Test as if you've never seen it before\n- **Documentation:** Verify all examples work\n- **Edge cases:** Test with unusual inputs\n- **Integration:** Test with other plugins\n\n### Maintenance\n- **Version bump:** Update version for any changes\n- **Changelog:** Document what changed and why\n- **Backward compatibility:** Don't break existing users\n- **Deprecation:** Warn before removing features\n- **Updates:** Keep dependencies and references current\n\n## Common Issues and Solutions\n\n### Issue 1: Skill Not Being Discovered\n**Problem:** Claude doesn't load the skill when relevant\n\n**Solutions:**\n- Check SKILL.md filename is exactly `SKILL.md` (case-sensitive)\n- Verify skill directory path: `plugins/category/plugin/skills/skill-name/SKILL.md`\n- Ensure plugin is registered in marketplace.json\n- Check that skill name and description are descriptive\n- Verify plugin is installed: `/plugin list`\n\n### Issue 2: Invalid Plugin Metadata\n**Problem:** Plugin fails to install or load\n\n**Solutions:**\n- Validate JSON syntax in plugin.json (no trailing commas, proper quotes)\n- Ensure all required fields present: name, description, version, author.name\n- Check name uses kebab-case with no spaces\n- Verify version follows semantic versioning (X.Y.Z)\n- Ensure file is named exactly `plugin.json`\n\n### Issue 3: Command Not Working\n**Problem:** Slash command doesn't execute\n\n**Solutions:**\n- Verify command file is in `commands/` directory\n- Check filename matches command name\n- Ensure markdown formatting is correct\n- Verify plugin is installed and loaded\n- Check command syntax matches documentation\n\n### Issue 4: Marketplace Registration Failed\n**Problem:** Plugin not showing in marketplace\n\n**Solutions:**\n- Verify marketplace.json syntax is valid\n- Check plugin source path is correct relative to marketplace root\n- Ensure plugin name in marketplace.json matches plugin.json\n- Verify marketplace.json is in `.claude-plugin/` at repo root\n\n### Issue 5: Version Conflicts\n**Problem:** Multiple versions causing issues\n\n**Solutions:**\n- Use semantic versioning consistently\n- Document breaking changes clearly\n- Test compatibility with existing plugins\n- Update marketplace.json with correct version\n- Consider version deprecation strategy\n\n## Resources\n\nThe plugin-builder includes templates in `skills/plugin-builder/resources/`:\n- `plugin-template.json`: Starter plugin.json\n- `skill-template.md`: SKILL.md boilerplate\n- `command-template.md`: Command file structure\n- `marketplace-entry.json`: Marketplace registration example\n\n## Support\n\nFor plugin system documentation, see:\n- Claude Code Plugins: https://docs.claude.com/en/docs/claude-code/plugins\n- Agent Skills: https://docs.claude.com/en/docs/claude-code/skills\n- Skills Best Practices: https://docs.anthropic.com/en/docs/agents-and-tools/agent-skills/best-practices\n",
        "plugins/claude/plugin-builder/skills/plugin-builder/resources/command-template.md": "# Command Name\n\n[Brief description of what this command does - 1-2 sentences]\n\n## Usage\n\n```\n/command-name [required-arg] [optional-arg]\n```\n\n## Parameters\n\n- `required-arg`: Description of the required argument and what it should be\n- `optional-arg`: Description of optional argument (if any)\n\n## Examples\n\n### Example 1: Basic Usage\n```\n/command-name example-value\n```\n[Description of what happens]\n\n### Example 2: Advanced Usage\n```\n/command-name example-value optional-value\n```\n[Description of what happens with optional argument]\n\n## Instructions for Claude\n\nWhen this command is invoked, you should:\n\n1. [First action to take]\n2. [Second action]\n3. [Third action]\n4. [Final action]\n\n### Validation\n\nBefore executing:\n- [Check this condition]\n- [Verify that requirement]\n\n### Error Handling\n\nIf [error condition]:\n- [How to handle it]\n\nIf [another error]:\n- [Resolution steps]\n\n## Notes\n\n- [Important note about usage]\n- [Limitation or constraint]\n- [Related commands or skills]\n",
        "plugins/claude/plugin-builder/skills/plugin-builder/resources/skill-template.md": "# Skill Name\n\n## Purpose\n\n[1-2 sentences describing what this skill does and its main value proposition]\n\n## When to Use\n\nUse this skill when:\n- [Specific scenario 1]\n- [Specific scenario 2]\n- [Specific scenario 3]\n\n## Prerequisites\n\n- [Required tool, library, or dependency]\n- [Necessary permission or access]\n- [Context or information needed]\n\n## Instructions\n\n### Step 1: [First Major Task]\n\n[Detailed step-by-step instructions for the first major task]\n\n1. [Specific action]\n2. [Next action]\n3. [Final action]\n\n### Step 2: [Second Major Task]\n\n[Detailed instructions for the second task]\n\n1. [Action]\n2. [Action]\n\n[Continue with additional steps as needed...]\n\n## Examples\n\n### Example 1: [Concrete Use Case Name]\n\n**Scenario:** [Brief description of the scenario]\n\n**Input:**\n```\n[Example input data/code]\n```\n\n**Steps:**\n1. [What to do]\n2. [Next step]\n\n**Output:**\n```\n[Expected output]\n```\n\n### Example 2: [Another Use Case]\n\n[Another complete example showing different aspect of the skill]\n\n## Best Practices\n\n- [Specific practice related to this skill]\n- [Another important practice]\n- [Third practice]\n- [Fourth practice]\n\n## Common Issues\n\n### Issue 1: [Problem Description]\n**Problem:** [Detailed description of the issue]\n\n**Solution:** [How to resolve it]\n\n### Issue 2: [Another Problem]\n**Problem:** [Description]\n\n**Solution:** [Resolution steps]\n\n## Additional Resources\n\n- [Link to related documentation]\n- [Reference to related skills]\n- [External resources if applicable]\n",
        "plugins/claude/tts-output/.claude-plugin/plugin.json": "{\n  \"name\": \"tts-output\",\n  \"description\": \"Text-to-speech output for Claude responses using macOS 'say' command\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Joel Chan\",\n    \"email\": \"joel611@live.hk\"\n  }\n}\n",
        "plugins/claude/tts-output/README.md": "# TTS Output Plugin\n\nA Claude Code plugin that provides text-to-speech output for Claude's responses using macOS `say` command.\n\n## Features\n\n- 🔊 Automatic text-to-speech for Claude's final responses\n- 📝 AI-generated summaries optimized for speech\n- 🎚️ Customizable voice, speed, and enable/disable controls\n- 🍎 Native macOS integration using the `say` command\n- 🔇 Silent fallback on non-macOS systems\n\n## Installation\n\nInstall from the marketplace:\n\n```bash\n/plugin install tts-output@claude-marketplace\n```\n\nThe plugin will automatically:\n- Register `SessionStart` hook to request TTS summaries from Claude\n- Register `Stop` hook to speak responses when Claude finishes\n\n## How It Works\n\n1. **Session Start**: When Claude Code starts, a system prompt is injected asking Claude to include a brief summary at the end of responses in an HTML comment:\n   ```html\n   <!-- TTS-SUMMARY: Brief 1-2 sentence summary -->\n   ```\n\n2. **Stop Hook**: When Claude finishes responding, the plugin:\n   - Extracts the TTS summary from the response\n   - Falls back to first 2 sentences if no summary present\n   - Speaks the summary using macOS `say` command (if enabled)\n\n3. **Smart Summaries**: Claude generates concise, speakable summaries that capture the key points without technical jargon.\n\n## Configuration\n\nThe plugin is configured using environment variables. You can set these in your shell profile or Claude Code settings.\n\n### Environment Variables\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `TTS_ENABLED` | `true` | Enable/disable TTS output (`true`, `false`, `1`, `0`, `yes`, `no`) |\n| `TTS_VOICE` | `Samantha` | Voice name for macOS `say` command |\n| `TTS_SPEED` | `200` | Speech rate in words per minute (180-220 is typical) |\n| `TTS_DEBUG` | `false` | Enable debug logging to file |\n| `TTS_DEBUG_LOG` | `{plugin}/hooks/scripts/tts-debug.log` | Path to debug log file |\n\n### Setting Environment Variables\n\n**In your shell profile** (e.g., `~/.zshrc` or `~/.bash_profile`):\n```bash\nexport TTS_ENABLED=true\nexport TTS_VOICE=Alex\nexport TTS_SPEED=190\nexport TTS_DEBUG=false\n```\n\n**For Claude Code** (in settings or before launching):\n```bash\nTTS_VOICE=Victoria TTS_SPEED=210 claude\n```\n\n### Available Voices\n\n**Popular voices:**\n- Samantha (default) - Natural female voice\n- Alex - Clear male voice\n- Victoria - British female voice\n- Fiona - Scottish female voice\n- Daniel - British male voice\n\nRun `say -v ?` in Terminal to see all available voices.\n\n### Debug Mode\n\nEnable debug mode to troubleshoot TTS issues:\n\n```bash\nexport TTS_DEBUG=true\n```\n\nBy default, the debug log is written to `tts-debug.log` in the plugin's `hooks/scripts/` directory. You can customize the location:\n\n```bash\nexport TTS_DEBUG_LOG=/custom/path/tts-debug.log\n```\n\nView the debug log:\n```bash\n# Default location (in plugin directory)\ntail -f ~/.claude/plugins/tts-output/hooks/scripts/tts-debug.log\n\n# Or custom location\ntail -f $TTS_DEBUG_LOG\n```\n\nThe debug log shows:\n- Timestamp of each TTS event\n- Voice and speed settings used\n- Exact text being spoken\n\n## Requirements\n\n- **macOS**: The plugin uses the macOS `say` command\n- **Python 3**: Required for the Stop hook handler\n- **Claude Code**: Plugin system with hook support\n\nOn non-macOS systems, the plugin will fail silently without disrupting Claude Code.\n\n## Project Structure\n\n```\ntts-output/\n├── .claude-plugin/\n│   └── plugin.json                # Plugin metadata\n├── hooks/\n│   ├── hooks.json                 # Hook configuration (auto-registered)\n│   └── scripts/\n│       ├── session-start.sh       # SessionStart hook (inject prompt)\n│       ├── stop-handler.py        # Stop hook (speak response)\n│       └── tts-debug.log          # Debug log (created when TTS_DEBUG=true)\n└── README.md                      # This file\n```\n\n## Troubleshooting\n\n### TTS not working\n- **Enable debug mode** to see what's happening: `export TTS_DEBUG=true`\n- Check the debug log: `tail -f ~/.claude/plugins/tts-output/hooks/scripts/tts-debug.log`\n- Check macOS `say` command works: `say \"test\"` in Terminal\n- Verify Python 3 is installed: `python3 --version`\n- Check plugin is installed: `/plugin list`\n- Verify TTS is enabled: `echo $TTS_ENABLED` (should be empty or `true`)\n\n### No audio output\n- Check system volume and audio output device\n- Test with Terminal: `say -v Samantha \"test\"`\n- Enable debug mode to verify text is being extracted correctly\n\n### Voice not found\n- List available voices: `say -v ?`\n- Some voices require download from System Settings > Accessibility > Spoken Content > Voices\n- Check debug log to see which voice is being used\n\n## Privacy & Performance\n\n- All processing happens locally on your machine\n- No data is sent to external services\n- The `say` command is a native macOS utility\n- Minimal performance impact (runs after Claude finishes)\n\n## License\n\nPart of the claude-marketplace repository.\n\n## Author\n\nJoel Chan (joel611@live.hk)\n\n## Version\n\n1.0.0\n",
        "plugins/claude/tts-output/hooks/hooks.json": "{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/session-start.sh\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/stop-handler.py\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "plugins/claude/tts-output/hooks/scripts/session-start.sh": "#!/bin/bash\n\n# SessionStart hook for TTS output plugin\n# This script injects a system prompt to request TTS summaries\n\ncat <<'EOF'\nIMPORTANT: The TTS output plugin is active. At the end of each final response, include an HTML comment with a brief summary for text-to-speech output:\n\n<!-- TTS-SUMMARY: 1-2 sentence summary of your response -->\n\nThe summary should:\n- Be concise (1-2 sentences maximum)\n- Capture the key point or result of your response\n- Be natural and speakable (avoid technical jargon when possible)\n- Focus on what you accomplished or the main takeaway\n\nExample:\n<!-- TTS-SUMMARY: I've successfully implemented the authentication feature and all tests are passing. -->\nEOF\n",
        "plugins/claude/tts-output/hooks/scripts/stop-handler.py": "#!/usr/bin/env python3\n\"\"\"\nStop hook handler for TTS output plugin.\nSpeaks Claude's response summary using macOS 'say' command.\n\"\"\"\n\nimport sys\nimport json\nimport subprocess\nimport re\nimport os\nfrom pathlib import Path\n\n\ndef load_config():\n    \"\"\"Load TTS configuration from environment variables.\"\"\"\n    # Default debug log location: same directory as this script\n    script_dir = Path(__file__).parent\n    default_log_path = str(script_dir / \"tts-debug.log\")\n\n    return {\n        \"enabled\": os.environ.get(\"TTS_ENABLED\", \"true\").lower() in (\"true\", \"1\", \"yes\"),\n        \"voice\": os.environ.get(\"TTS_VOICE\", \"Samantha\"),\n        \"speed\": int(os.environ.get(\"TTS_SPEED\", \"200\")),\n        \"debug\": os.environ.get(\"TTS_DEBUG\", \"false\").lower() in (\"true\", \"1\", \"yes\"),\n        \"debug_log\": os.environ.get(\"TTS_DEBUG_LOG\", default_log_path)\n    }\n\n\ndef log_debug(message, log_file):\n    \"\"\"Write debug message to log file with timestamp.\"\"\"\n    try:\n        from datetime import datetime\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        with open(log_file, 'a') as f:\n            f.write(f\"[{timestamp}] {message}\\n\")\n    except Exception:\n        # Fail silently - don't disrupt the hook\n        pass\n\n\ndef extract_tts_summary(text):\n    \"\"\"Extract TTS summary from HTML comment in text.\"\"\"\n    # Look for <!-- TTS-SUMMARY: ... -->\n    pattern = r'<!--\\s*TTS-SUMMARY:\\s*(.+?)\\s*-->'\n    match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n\n    if match:\n        return match.group(1).strip()\n\n    return None\n\n\ndef extract_fallback_summary(text, max_sentences=2):\n    \"\"\"Extract first N sentences as fallback summary.\"\"\"\n    # Remove HTML comments\n    text = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL)\n\n    # Remove markdown code blocks\n    text = re.sub(r'```.*?```', '', text, flags=re.DOTALL)\n\n    # Remove inline code\n    text = re.sub(r'`[^`]+`', '', text)\n\n    # Split into sentences (simple approach)\n    sentences = re.split(r'(?<=[.!?])\\s+', text.strip())\n\n    # Take first N non-empty sentences\n    summary_sentences = [s for s in sentences[:max_sentences] if s.strip()]\n\n    if summary_sentences:\n        return ' '.join(summary_sentences)\n\n    return None\n\n\ndef read_last_assistant_message(transcript_path):\n    \"\"\"\n    Read the JSONL transcript file and extract the last assistant message's text content.\n\n    Returns:\n        tuple: (text_content, message_count) where text_content is the combined text\n               from all text blocks in the last assistant message, or None if not found.\n    \"\"\"\n    try:\n        # Expand user path if needed\n        transcript_path = os.path.expanduser(transcript_path)\n\n        if not os.path.exists(transcript_path):\n            return None, 0\n\n        last_assistant_text = None\n        message_count = 0\n\n        # Read JSONL file line by line\n        with open(transcript_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if not line:\n                    continue\n\n                try:\n                    data = json.loads(line)\n                    message_count += 1\n\n                    # Check if this is an assistant message\n                    if 'message' in data and data['message'].get('role') == 'assistant':\n                        content = data['message'].get('content', [])\n\n                        # Extract all text blocks\n                        text_blocks = [\n                            block.get('text', '')\n                            for block in content\n                            if block.get('type') == 'text'\n                        ]\n\n                        # Join text blocks\n                        if text_blocks:\n                            last_assistant_text = '\\n'.join(text_blocks)\n\n                except json.JSONDecodeError:\n                    # Skip malformed lines\n                    continue\n\n        return last_assistant_text, message_count\n\n    except Exception as e:\n        print(f\"TTS Error reading transcript: {e}\", file=sys.stderr)\n        return None, 0\n\n\ndef speak_text(text, voice, speed):\n    \"\"\"Speak text using macOS 'say' command.\"\"\"\n    try:\n        # Check if 'say' command exists (macOS only)\n        result = subprocess.run(\n            ['which', 'say'],\n            capture_output=True,\n            text=True\n        )\n\n        if result.returncode != 0:\n            print(\"TTS: 'say' command not available (non-macOS system)\", file=sys.stderr)\n            return False\n\n        # Call 'say' command\n        subprocess.run(\n            ['say', '-v', voice, '-r', str(speed), text],\n            check=True\n        )\n        return True\n\n    except subprocess.CalledProcessError as e:\n        print(f\"TTS Error: Failed to speak text: {e}\", file=sys.stderr)\n        return False\n    except Exception as e:\n        print(f\"TTS Error: {e}\", file=sys.stderr)\n        return False\n\n\ndef main():\n    \"\"\"Main handler for Stop hook.\"\"\"\n    try:\n        # Load configuration\n        config = load_config()\n\n        # Check if TTS is enabled\n        if not config.get(\"enabled\", True):\n            return\n\n        # Read JSON input from stdin\n        input_data = sys.stdin.read()\n\n        # If no input, nothing to process\n        if not input_data.strip():\n            return\n\n        # Try to parse as JSON\n        try:\n            hook_data = json.loads(input_data)\n        except json.JSONDecodeError:\n            # Not valid JSON - skip execution\n            if config.get(\"debug\", False):\n                debug_log = config.get(\"debug_log\", \"/tmp/tts-output-debug.log\")\n                log_debug(\"TTS-DEBUG: Invalid JSON input, skipping execution\", debug_log)\n            return\n\n        # Only process if this is Stop hook data with transcript_path\n        if not isinstance(hook_data, dict) or 'transcript_path' not in hook_data:\n            if config.get(\"debug\", False):\n                debug_log = config.get(\"debug_log\", \"/tmp/tts-output-debug.log\")\n                log_debug(\"TTS-DEBUG: No transcript_path in input, skipping execution\", debug_log)\n            return\n\n        transcript_path = hook_data['transcript_path']\n\n        # Debug log transcript processing\n        if config.get(\"debug\", False):\n            debug_log = config.get(\"debug_log\", \"/tmp/tts-output-debug.log\")\n            log_debug(f\"TTS-DEBUG: Reading transcript from: {transcript_path}\", debug_log)\n\n        # Read the last assistant message from transcript\n        response_text, message_count = read_last_assistant_message(transcript_path)\n\n        # Debug log results\n        if config.get(\"debug\", False):\n            debug_log = config.get(\"debug_log\", \"/tmp/tts-output-debug.log\")\n            if response_text:\n                log_debug(\n                    f\"TTS-DEBUG: Found {message_count} messages in transcript, \"\n                    f\"extracted {len(response_text)} chars from last assistant message\",\n                    debug_log\n                )\n            else:\n                log_debug(\n                    f\"TTS-DEBUG: No assistant message found in transcript ({message_count} total messages)\",\n                    debug_log\n                )\n\n        # If no text found, skip execution\n        if not response_text:\n            return\n\n        # Extract TTS summary\n        summary = extract_tts_summary(response_text)\n\n        # Fallback to first sentences if no summary comment found\n        if not summary:\n            summary = extract_fallback_summary(response_text)\n\n        # If we have something to speak, do it\n        if summary:\n            voice = config.get(\"voice\", \"Samantha\")\n            speed = config.get(\"speed\", 200)\n\n            # Debug logging if enabled\n            if config.get(\"debug\", False):\n                debug_log = config.get(\"debug_log\", \"/tmp/tts-output-debug.log\")\n                log_debug(\n                    f\"TTS-DEBUG: Speaking with voice='{voice}' speed={speed}: \\\"{summary}\\\"\",\n                    debug_log\n                )\n\n            speak_text(summary, voice, speed)\n\n    except Exception as e:\n        # Fail silently - don't disrupt Claude Code\n        print(f\"TTS Plugin Error: {e}\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "plugins/coding/elysia/.claude-plugin/plugin.json": "{\n  \"name\": \"elysia-skill\",\n  \"description\": \"Elysia specialist\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"joel.chan\"\n  }\n}\n",
        "plugins/coding/elysia/skills/elysia/SKILL.md": "---\nname: elysia\ndescription: Expert knowledge for building type-safe web applications with ElysiaJS, including validation, lifecycle hooks, Eden end-to-end type safety, and integrations\n---\n\n# Elysia Skill\n\nExpert knowledge for building high-performance, type-safe web applications with **ElysiaJS** - a fast, ergonomic Bun web framework with end-to-end type safety.\n\nThis skill synthesizes knowledge from official Elysia documentation covering core concepts, patterns, plugins, and integrations.\n\n## When to Use This Skill\n\nThis skill should be triggered when you are:\n\n**Building Web APIs:**\n- Creating RESTful APIs with Elysia\n- Setting up HTTP routes (GET, POST, PUT, DELETE, etc.)\n- Implementing request/response handlers\n- Working with route parameters, query strings, or request bodies\n\n**Type Safety & Validation:**\n- Adding schema validation with Elysia.t (TypeBox)\n- Using Standard Schema validators (Zod, Valibot, ArkType, etc.)\n- Validating request bodies, queries, params, headers, or cookies\n- Generating OpenAPI documentation from schemas\n\n**Lifecycle Hooks & Middleware:**\n- Implementing authentication/authorization checks\n- Adding logging, error handling, or request preprocessing\n- Using lifecycle hooks (beforeHandle, afterResponse, onError, etc.)\n- Creating reusable route options with Macros\n\n**End-to-End Type Safety:**\n- Setting up Eden Treaty for type-safe client-server communication\n- Exporting server types for frontend consumption\n- Creating type-safe API clients (similar to tRPC)\n- Testing with end-to-end type safety\n\n**Framework Integrations:**\n- Integrating Elysia with Next.js, Nuxt, SvelteKit, Astro, or Expo\n- Setting up Drizzle ORM with Elysia\n- Using AI SDK with Elysia for streaming responses\n- Deploying to Netlify Edge Functions or other platforms\n\n**Plugin Development:**\n- Creating custom Elysia plugins\n- Using official plugins (@elysiajs/*)\n- Implementing OpenTelemetry for observability\n- Working with HTML, CORS, JWT, GraphQL, or other plugins\n\n## Key Concepts\n\n### Method Chaining\nElysia uses method chaining extensively. Each method returns a new instance with updated types:\n\n```typescript\nnew Elysia()\n  .state('version', 1)\n  .get('/', ({ store }) => store.version)\n  .listen(3000)\n```\n\n**Important:** Always use method chaining - it's required for proper type inference, especially with Eden.\n\n### Schema Validation\nElysia provides `t` (TypeBox) for runtime and compile-time type safety. Schemas automatically generate TypeScript types and OpenAPI documentation:\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n  .post('/user', ({ body }) => body, {\n    body: t.Object({\n      name: t.String(),\n      age: t.Number()\n    })\n  })\n```\n\n### Lifecycle Hooks\nHooks execute at specific points in the request-response cycle:\n\n- **request** - when request is received\n- **beforeHandle** - before executing handler (e.g., auth checks)\n- **afterHandle** - after handler, before response\n- **afterResponse** - after response is sent\n- **onError** - when errors occur\n\nHooks can be **local** (specific route) or **interceptor** (all routes after registration).\n\n### Eden Treaty\nEden provides end-to-end type safety between server and client, similar to tRPC but using Elysia's type system:\n\n```typescript\n// server.ts\nconst app = new Elysia()\n  .get('/user/:id', ({ params: { id } }) => ({ id, name: 'John' }))\nexport type App = typeof app\n\n// client.ts\nimport { treaty } from '@elysiajs/eden'\nconst api = treaty<App>('localhost:3000')\nconst { data } = await api.user({ id: '1' }).get()\n// data is fully typed!\n```\n\n## Quick Reference\n\n### 1. Basic Server Setup\n\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n  .get('/', () => 'Hello Elysia')\n  .listen(3000)\n\nconsole.log('🦊 Elysia is running at http://localhost:3000')\n```\n\n### 2. Route with Validation\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n  .post('/user', ({ body }) => body, {\n    body: t.Object({\n      name: t.String(),\n      email: t.String({ format: 'email' })\n    })\n  })\n  .listen(3000)\n```\n\n### 3. Path Parameters & Query Strings\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n  .get('/id/:id', ({ params: { id }, query }) => {\n    return { id, query }\n  }, {\n    params: t.Object({\n      id: t.Number() // Automatically coerced from string\n    }),\n    query: t.Object({\n      name: t.String()\n    })\n  })\n  .listen(3000)\n```\n\n### 4. Authentication with beforeHandle Hook\n\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n  .onBeforeHandle(({ query: { name }, status }) => {\n    if (!name) return status(401)\n  })\n  .get('/protected', ({ query: { name } }) => {\n    return `Welcome ${name}!`\n  })\n  .listen(3000)\n```\n\n### 5. Local Hook for Specific Route\n\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n  .get('/public', () => 'Public route')\n  .get('/auth', () => 'Authenticated!', {\n    beforeHandle({ request, status }) {\n      if (Math.random() <= 0.5) return status(418)\n    }\n  })\n  .listen(3000)\n```\n\n### 6. Guard for Multiple Routes\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n  .get('/none', () => 'No validation')\n  .guard({\n    query: t.Object({\n      name: t.String()\n    })\n  })\n  .get('/query', ({ query: { name } }) => name)\n  .get('/query2', ({ query: { name } }) => `Hello ${name}`)\n  .listen(3000)\n```\n\n### 7. State Management\n\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n  .state('count', 0)\n  .get('/', ({ store }) => {\n    store.count++\n    return store.count\n  })\n  .listen(3000)\n```\n\n### 8. Custom Status & Redirect\n\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n  .get('/teapot', ({ status }) => status(418, \"I'm a teapot\"))\n  .get('/home', ({ redirect }) => redirect('https://elysiajs.com'))\n  .listen(3000)\n```\n\n### 9. Reusable Macro\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n  .macro('auth', {\n    cookie: t.Object({\n      session: t.String()\n    }),\n    beforeHandle({ cookie: { session }, status }) {\n      if (!session.value) return status(401)\n    }\n  })\n  .post('/user', ({ body }) => body, {\n    auth: true // Applies auth macro\n  })\n  .listen(3000)\n```\n\n### 10. Eden Setup (End-to-End Type Safety)\n\n**Server:**\n```typescript\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n  .get('/', () => 'Hi Elysia')\n  .get('/id/:id', ({ params: { id } }) => id)\n  .post('/mirror', ({ body }) => body, {\n    body: t.Object({\n      id: t.Number(),\n      name: t.String()\n    })\n  })\n  .listen(3000)\n\nexport type App = typeof app\n```\n\n**Client:**\n```bash\nbun add @elysiajs/eden\nbun add -d elysia\n```\n\n```typescript\n// client.ts\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst api = treaty<App>('localhost:3000')\n\nconst { data, error } = await api.mirror.post({\n  id: 1,\n  name: 'Elysia'\n})\n\nif (error) console.error(error.value)\nelse console.log(data) // Fully typed!\n```\n\n### 11. Error Handling\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n  .get('/:id', ({ params: { id } }) => id, {\n    params: t.Object({\n      id: t.Number({\n        error: 'id must be a number'\n      })\n    })\n  })\n  .onError(({ code, error, status }) => {\n    if (code === 'VALIDATION')\n      return status(400, error.message)\n\n    return status(500, 'Internal Server Error')\n  })\n  .listen(3000)\n```\n\n### 12. Standard Schema (Zod Example)\n\n```typescript\nimport { Elysia } from 'elysia'\nimport { z } from 'zod'\n\nnew Elysia()\n  .post('/user', ({ body }) => body, {\n    body: z.object({\n      name: z.string(),\n      age: z.number()\n    })\n  })\n  .listen(3000)\n```\n\n### 13. Drizzle ORM Integration\n\n```bash\nbun add drizzle-orm drizzle-typebox\n```\n\n```typescript\nimport { Elysia } from 'elysia'\nimport { drizzle } from 'drizzle-orm/bun-sqlite'\nimport { createInsertSchema } from 'drizzle-typebox'\nimport { users } from './schema'\n\nconst db = drizzle(/* ... */)\nconst insertUserSchema = createInsertSchema(users)\n\nnew Elysia()\n  .post('/user', async ({ body }) => {\n    const user = await db.insert(users).values(body)\n    return user\n  }, {\n    body: insertUserSchema\n  })\n  .listen(3000)\n```\n\n### 14. File Upload\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n  .post('/upload', async ({ body: { file } }) => {\n    return `Uploaded: ${file.name}`\n  }, {\n    body: t.Object({\n      file: t.File()\n    })\n  })\n  .listen(3000)\n```\n\n### 15. Plugin Creation\n\n```typescript\nimport { Elysia } from 'elysia'\n\nconst myPlugin = new Elysia({ name: 'my-plugin' })\n  .state('pluginVersion', '1.0.0')\n  .get('/plugin', ({ store }) => store.pluginVersion)\n\nnew Elysia()\n  .use(myPlugin)\n  .listen(3000)\n```\n\n## Reference Files\n\nThis skill includes comprehensive documentation extracted from official Elysia sources. All examples and information come from **official documentation** (medium-high confidence).\n\n### `references/essential.md` (6 pages)\nCore Elysia concepts including:\n- **Validation** - TypeBox schemas, Standard Schema support (Zod, Valibot, etc.)\n- **Lifecycle** - Request-response cycle, hooks, and middleware\n- **Body/Query/Params** - Request data validation\n- **Guard** - Apply schemas to multiple routes\n\n### `references/eden.md` (11 pages)\nEnd-to-end type safety with Eden:\n- **Installation** - Setup Eden Treaty on frontend\n- **Type Inference** - Gotchas and troubleshooting\n- **Testing** - Unit testing with Eden\n- **Treaty API** - Tree-like syntax, dynamic paths, responses\n\n### `references/tutorial.md` (14 pages)\nStep-by-step guides including:\n- **Getting Started** - Basic server setup\n- **Lifecycle Hooks** - Local vs interceptor hooks\n- **Mount** - Composing multiple Elysia instances\n- **Features** - Advanced patterns and techniques\n\n### `references/patterns.md` (21 pages)\nAdvanced patterns including:\n- **Macro** - Reusable route options\n- **Error Handling** - Custom errors, validation messages\n- **Configuration** - Server configuration options\n- **OpenTelemetry** - Observability integration\n\n### `references/plugins.md` (13 pages)\nOfficial plugins documentation:\n- **OpenTelemetry** - Distributed tracing\n- **HTML** - Server-side rendering\n- **CORS** - Cross-origin resource sharing\n- **JWT** - JSON Web Token authentication\n- **GraphQL** - GraphQL integration\n\n### `references/integrations.md` (17 pages)\nFramework integrations:\n- **Drizzle ORM** - Database integration with type safety\n- **Next.js** - Integration with Next.js App Router\n- **Nuxt** - Integration with Nuxt 3\n- **SvelteKit** - Integration with SvelteKit\n- **Expo** - React Native integration\n- **Astro** - Integration with Astro\n- **AI SDK** - Streaming AI responses\n\n### `references/other.md`\nAdditional topics and utilities.\n\n## Working with This Skill\n\n### For Beginners\n\n1. **Start with basics** - Read `references/tutorial.md` for getting started guides\n2. **Learn validation** - Check `references/essential.md` for schema validation\n3. **Try examples** - Use the Quick Reference examples above to build your first server\n4. **Understand hooks** - Learn lifecycle hooks for middleware and authentication\n\n### For Intermediate Users\n\n1. **Master Guards** - Apply schemas to multiple routes efficiently\n2. **Use Macros** - Create reusable route options for common patterns\n3. **Add Eden** - Implement end-to-end type safety with Eden Treaty\n4. **Error handling** - Implement robust error handling with custom errors\n\n### For Advanced Users\n\n1. **Create plugins** - Build reusable Elysia plugins for your organization\n2. **Integrate frameworks** - Connect Elysia with Next.js, Nuxt, or other frameworks\n3. **Add observability** - Implement OpenTelemetry for distributed tracing\n4. **Optimize performance** - Use Elysia's ahead-of-time compilation features\n\n### Navigation Tips\n\n- **Need validation help?** → `references/essential.md`\n- **Setting up Eden?** → `references/eden.md`\n- **Framework integration?** → `references/integrations.md`\n- **Creating plugins?** → `references/plugins.md`\n- **Advanced patterns?** → `references/patterns.md`\n- **Learning the basics?** → `references/tutorial.md`\n\n## Important Notes\n\n### TypeScript Requirements\n- **Minimum TypeScript version:** 5.0+\n- **Enable strict mode** in `tsconfig.json`\n- Method chaining is required for proper type inference\n\n### Eden Gotchas\n- Server and client must have **matching Elysia versions**\n- Use `method chaining` - required for type inference\n- Pin `@sinclair/typebox` version if using Drizzle\n- Path aliases in monorepos need careful configuration\n\n### Validation Best Practices\n- Use `t.File()` for file uploads (sets content-type automatically)\n- Validation details are hidden in production by default\n- Custom error messages can be set per field\n- Standard Schema (Zod, Valibot, etc.) is fully supported\n\n### Performance Tips\n- Elysia runs on Bun for maximum performance\n- Ahead-of-time compilation optimizes route handlers\n- Use guards to apply validation to multiple routes efficiently\n- State is instance-scoped, not request-scoped\n\n## Source Information\n\n**All content synthesized from official Elysia documentation:**\n- Source Type: Official Documentation\n- Confidence: Medium-High\n- Documentation URL: https://elysiajs.com\n\nNo conflicts detected between sources. All examples and patterns come directly from official Elysia documentation and are considered authoritative.\n\n## Additional Resources\n\n### Installation\n```bash\nbun add elysia\n```\n\n### Common Plugins\n```bash\n# Eden (type-safe client)\nbun add @elysiajs/eden\n\n# HTML rendering\nbun add @elysiajs/html\n\n# CORS\nbun add @elysiajs/cors\n\n# JWT\nbun add @elysiajs/jwt\n\n# GraphQL\nbun add @elysiajs/graphql-yoga\n\n# OpenTelemetry\nbun add @elysiajs/opentelemetry\n```\n\n### Community\n- Official Website: https://elysiajs.com\n- GitHub: https://github.com/elysiajs/elysia\n- Discord: Join the Elysia community for support\n\n## Updating\n\nThis skill was automatically generated from official Elysia documentation. To refresh:\n1. Re-run the documentation scraper with the same configuration\n2. The skill will be rebuilt with the latest information\n3. All reference files will be updated with new examples and patterns\n",
        "plugins/coding/elysia/skills/elysia/references/eden.md": "# Elysia - Eden\n\n**Pages:** 11\n\n---\n\n## Eden Installation\n\n**URL:** https://elysiajs.com/eden/installation.md\n\n**Contents:**\n- Gotcha\n  - Type Strict\n  - Unmatch Elysia version\n  - TypeScript version\n  - Method Chaining\n  - Type Definitions\n  - Path alias (monorepo)\n    - Namespace\n\n---\nurl: 'https://elysiajs.com/eden/installation.md'\n---\n\nStart by installing Eden on your frontend:\n\n::: tip\nEden needs Elysia to infer utilities type.\n\nMake sure to install Elysia with the version matching on the server.\n:::\n\nFirst, export your existing Elysia server type:\n\nThen consume the Elysia API on client side:\n\nSometimes, Eden may not infer types from Elysia correctly, the following are the most common workarounds to fix Eden type inference.\n\nMake sure to enable strict mode in **tsconfig.json**\n\nEden depends on Elysia class to import Elysia instance and infer types correctly.\n\nMake sure that both client and server have the matching Elysia version.\n\nYou can check it with [`npm why`](https://docs.npmjs.com/cli/v10/commands/npm-explain) command:\n\nAnd output should contain only one elysia version on top-level:\n\nElysia uses newer features and syntax of TypeScript to infer types in the most performant way. Features like Const Generic and Template Literal are heavily used.\n\nMake sure your client has a **minimum TypeScript version if >= 5.0**\n\nTo make Eden work, Elysia must use **method chaining**\n\nElysia's type system is complex, methods usually introduce a new type to the instance.\n\nUsing method chaining will help save that new type reference.\n\nUsing this, **state** now returns a new **ElysiaInstance** type, introducing **build** into store replacing the current one.\n\nWithout method chaining, Elysia doesn't save the new type when introduced, leading to no type inference.\n\nIf you are using a Bun specific feature, like `Bun.file` or similar API and return it from a handler, you may need to install Bun type definitions to the client as well.\n\nIf you are using path alias in your monorepo, make sure that frontend is able to resolve the path as same as backend.\n\n::: tip\nSetting up path alias in monorepo is a bit tricky, you can fork our example template: [Kozeki Template](https://github.com/SaltyAom/kozeki-template) and modify it to your needs.\n:::\n\nFor example, if you have the following path alias for your backend in **tsconfig.json**:\n\nAnd your backend code is like this:\n\nYou **must** make sure that your frontend code is able to resolve the same path alias. Otherwise, type inference will be resolved as any.\n\nTo fix this, you must make sure that path alias is resolved to the same file in both frontend and backend.\n\nSo, you must change the path alias in **tsconfig.json** to:\n\nIf configured correctly, you should be able to resolve the same module in both frontend and backend.\n\nWe recommended adding a **namespace** prefix for each module in your monorepo to avoid any confusion and conflict that may happen.\n\nThen, you can import the module like this:\n\nWe recommend creating a **single tsconfig.json** that defines a `baseUrl` as the root of your repo, provide a path according to the module location, and create a **tsconfig.json** for each module that inherits the root **tsconfig.json** which has the path alias.\n\nYou may find a working example of in this [path alias example repo](https://github.com/SaltyAom/elysia-monorepo-path-alias) or [Kozeki Template](https://github.com/SaltyAom/kozeki-template).\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/eden\nbun add -d elysia\n```\n\nExample 2 (typescript):\n```typescript\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app // [!code ++]\n```\n\nExample 3 (unknown):\n```unknown\n## Gotcha\n\nSometimes, Eden may not infer types from Elysia correctly, the following are the most common workarounds to fix Eden type inference.\n\n### Type Strict\n\nMake sure to enable strict mode in **tsconfig.json**\n```\n\nExample 4 (unknown):\n```unknown\n### Unmatch Elysia version\n\nEden depends on Elysia class to import Elysia instance and infer types correctly.\n\nMake sure that both client and server have the matching Elysia version.\n\nYou can check it with [`npm why`](https://docs.npmjs.com/cli/v10/commands/npm-explain) command:\n```\n\n---\n\n## Eden Test\n\n**URL:** https://elysiajs.com/eden/test.md\n\n**Contents:**\n- Setup\n\n---\nurl: 'https://elysiajs.com/eden/test.md'\n---\n\nUsing Eden, we can create an integration test with end-to-end type safety and auto-completion.\n\nWe can use [Bun test](https://bun.sh/guides/test/watch-mode) to create tests.\n\nCreate **test/index.test.ts** in the root of project directory with the following:\n\nThen we can perform tests by running **bun test**\n\nThis allows us to perform integration tests programmatically instead of manual fetch while supporting type checking automatically.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\n// test/index.test.ts\nimport { describe, expect, it } from 'bun:test'\n\nimport { edenTreaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/', () => 'hi')\n    .listen(3000)\n\nconst api = edenTreaty<typeof app>('http://localhost:3000')\n\ndescribe('Elysia', () => {\n    it('return a response', async () => {\n        const { data } = await api.get()\n\n        expect(data).toBe('hi')\n    })\n})\n```\n\n---\n\n## Eden Treaty\n\n**URL:** https://elysiajs.com/eden/treaty/overview.md\n\n**Contents:**\n- Tree like syntax\n- Dynamic path\n\n---\nurl: 'https://elysiajs.com/eden/treaty/overview.md'\n---\n\nEden Treaty is an object representation to interact with a server and features type safety, auto-completion, and error handling.\n\nTo use Eden Treaty, first export your existing Elysia server type:\n\nThen import the server type and consume the Elysia API on the client:\n\nHTTP Path is a resource indicator for a file system tree.\n\nFile system consists of multiple levels of folders, for example:\n\n* /documents/elysia\n* /documents/kalpas\n* /documents/kelvin\n\nEach level is separated by **/** (slash) and a name.\n\nHowever in JavaScript, instead of using **\"/\"** (slash) we use **\".\"** (dot) to access deeper resources.\n\nEden Treaty turns an Elysia server into a tree-like file system that can be accessed in the JavaScript frontend instead.\n\n| Path         | Treaty       |\n| ------------ | ------------ |\n| /            |              |\n| /hi          | .hi          |\n| /deep/nested | .deep.nested |\n\nCombined with the HTTP method, we can interact with the Elysia server.\n\n| Path         | Method | Treaty              |\n| ------------ | ------ | ------------------- |\n| /            | GET    | .get()              |\n| /hi          | GET    | .hi.get()           |\n| /deep/nested | GET    | .deep.nested.get()  |\n| /deep/nested | POST   | .deep.nested.post() |\n\nHowever, dynamic path parameters cannot be expressed using notation. If they are fully replaced, we don't know what the parameter name is supposed to be.\n\nTo handle this, we can specify a dynamic path using a function to provide a key value instead.\n\n| Path            | Treaty                           |\n| --------------- | -------------------------------- |\n| /item           | .item                            |\n| /item/:name     | .item({ name: 'Skadi' })         |\n| /item/:name/id  | .item({ name: 'Skadi' }).id      |\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/hi', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app // [!code ++]\n```\n\nExample 2 (unknown):\n```unknown\n## Tree like syntax\n\nHTTP Path is a resource indicator for a file system tree.\n\nFile system consists of multiple levels of folders, for example:\n\n* /documents/elysia\n* /documents/kalpas\n* /documents/kelvin\n\nEach level is separated by **/** (slash) and a name.\n\nHowever in JavaScript, instead of using **\"/\"** (slash) we use **\".\"** (dot) to access deeper resources.\n\nEden Treaty turns an Elysia server into a tree-like file system that can be accessed in the JavaScript frontend instead.\n\n| Path         | Treaty       |\n| ------------ | ------------ |\n| /            |              |\n| /hi          | .hi          |\n| /deep/nested | .deep.nested |\n\nCombined with the HTTP method, we can interact with the Elysia server.\n\n| Path         | Method | Treaty              |\n| ------------ | ------ | ------------------- |\n| /            | GET    | .get()              |\n| /hi          | GET    | .hi.get()           |\n| /deep/nested | GET    | .deep.nested.get()  |\n| /deep/nested | POST   | .deep.nested.post() |\n\n## Dynamic path\n\nHowever, dynamic path parameters cannot be expressed using notation. If they are fully replaced, we don't know what the parameter name is supposed to be.\n```\n\nExample 3 (unknown):\n```unknown\nTo handle this, we can specify a dynamic path using a function to provide a key value instead.\n```\n\n---\n\n## Response\n\n**URL:** https://elysiajs.com/eden/treaty/response.md\n\n**Contents:**\n- Stream response\n- Utility type\n\n---\nurl: 'https://elysiajs.com/eden/treaty/response.md'\n---\n\nOnce the fetch method is called, Eden Treaty returns a `Promise` containing an object with the following properties:\n\n* data - returned value of the response (2xx)\n* error - returned value from the response (>= 3xx)\n* response `Response` - Web Standard Response class\n* status `number` - HTTP status code\n* headers `FetchRequestInit['headers']` - response headers\n\nOnce returned, you must provide error handling to ensure that the response data value is unwrapped, otherwise the value will be nullable. Elysia provides a `error()` helper function to handle the error, and Eden will provide type narrowing for the error value.\n\nBy default, Elysia infers `error` and `response` types to TypeScript automatically, and Eden will be providing auto-completion and type narrowing for accurate behavior.\n\n::: tip\nIf the server responds with an HTTP status >= 300, then the value will always be `null`, and `error` will have a returned value instead.\n\nOtherwise, response will be passed to `data`.\n:::\n\nEden will interpret a stream response or [Server-Sent Events](/essential/handler.html#server-sent-events-sse) as `AsyncGenerator` allowing us to use `for await` loop to consume the stream.\n\nEden Treaty provides a utility type `Treaty.Data<T>` and `Treaty.Error<T>` to extract the `data` and `error` type from the response.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .post('/user', ({ body: { name }, status }) => {\n        if(name === 'Otto') return status(400)\n\n        return name\n    }, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\nconst submit = async (name: string) => {\n    const { data, error } = await api.user.post({\n        name\n    })\n\n    // type: string | null\n    console.log(data)\n\n    if (error)\n        switch(error.status) {\n            case 400:\n                // Error type will be narrow down\n                throw error.value\n\n            default:\n                throw error.value\n        }\n\n    // Once the error is handled, type will be unwrapped\n    // type: string\n    return data\n}\n```\n\nExample 2 (unknown):\n```unknown\n:::\n\n## Utility type\n\nEden Treaty provides a utility type `Treaty.Data<T>` and `Treaty.Error<T>` to extract the `data` and `error` type from the response.\n```\n\n---\n\n## Parameters\n\n**URL:** https://elysiajs.com/eden/treaty/parameters.md\n\n**Contents:**\n- Empty body\n- Fetch parameters\n- File Upload\n\n---\nurl: 'https://elysiajs.com/eden/treaty/parameters.md'\n---\n\nWe need to send a payload to server eventually.\n\nTo handle this, Eden Treaty's methods accept 2 parameters to send data to server.\n\nBoth parameters are type safe and will be guided by TypeScript automatically:\n\n1. body\n2. additional parameters\n   * query\n   * headers\n   * fetch\n\nUnless if the method doesn't accept body, then body will be omitted and left with single parameter only.\n\nIf the method **\"GET\"** or **\"HEAD\"**:\n\n1. Additional parameters\n   * query\n   * headers\n   * fetch\n\nIf body is optional or not need but query or headers is required, you may pass the body as `null` or `undefined` instead.\n\nEden Treaty is a fetch wrapper, we may add any valid [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) parameters to Eden by passing it to `$fetch`:\n\nWe may either pass one of the following to attach file(s):\n\n* **File**\n* **File\\[]**\n* **FileList**\n* **Blob**\n\nAttaching a file will results **content-type** to be **multipart/form-data**\n\nSuppose we have the server as the following:\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .post('/user', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\n// ✅ works\napi.user.post({\n    name: 'Elysia'\n})\n\n// ✅ also works\napi.user.post({\n    name: 'Elysia'\n}, {\n    // This is optional as not specified in schema\n    headers: {\n        authorization: 'Bearer 12345'\n    },\n    query: {\n        id: 2\n    }\n})\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/hello', () => 'hi')\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\n// ✅ works\napi.hello.get({\n    // This is optional as not specified in schema\n    headers: {\n        hello: 'world'\n    }\n})\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .post('/user', () => 'hi', {\n        query: t.Object({\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\napi.user.post(null, {\n    query: {\n        name: 'Ely'\n    }\n})\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/hello', () => 'hi')\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\nconst controller = new AbortController()\n\nconst cancelRequest = setTimeout(() => {\n    controller.abort()\n}, 5000)\n\nawait api.hello.get({\n    fetch: {\n        signal: controller.signal\n    }\n})\n\nclearTimeout(cancelRequest)\n```\n\n---\n\n## Eden Fetch\n\n**URL:** https://elysiajs.com/eden/fetch.md\n\n**Contents:**\n- Error Handling\n- When should I use Eden Fetch over Eden Treaty\n\n---\nurl: 'https://elysiajs.com/eden/fetch.md'\n---\n\nA fetch-like alternative to Eden Treaty.\n\nWith Eden Fetch, you can interact with Elysia server in a type-safe manner using Fetch API.\n\nFirst export your existing Elysia server type:\n\nThen import the server type, and consume the Elysia API on client:\n\nYou can handle errors the same way as Eden Treaty:\n\nUnlike Elysia < 1.0, Eden Fetch is not faster than Eden Treaty anymore.\n\nThe preference is base on you and your team agreement, however we recommend to use [Eden Treaty](/eden/treaty/overview) instead.\n\nUsing Eden Treaty requires a lot of down-level iteration to map all possible types in a single go, while in contrast, Eden Fetch can be lazily executed until you pick a route.\n\nWith complex types and a lot of server routes, using Eden Treaty on a low-end development device can lead to slow type inference and auto-completion.\n\nBut as Elysia has tweaked and optimized a lot of types and inference, Eden Treaty can perform very well in the considerable amount of routes.\n\nIf your single process contains **more than 500 routes**, and you need to consume all of the routes **in a single frontend codebase**, then you might want to use Eden Fetch as it has a significantly better TypeScript performance than Eden Treaty.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/hi', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app\n```\n\nExample 2 (typescript):\n```typescript\nimport { edenFetch } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst fetch = edenFetch<App>('http://localhost:3000')\n\n// response type: 'Hi Elysia'\nconst pong = await fetch('/hi', {})\n\n// response type: 1895\nconst id = await fetch('/id/:id', {\n    params: {\n        id: '1895'\n    }\n})\n\n// response type: { id: 1895, name: 'Skadi' }\nconst nendoroid = await fetch('/mirror', {\n    method: 'POST',\n    body: {\n        id: 1895,\n        name: 'Skadi'\n    }\n})\n```\n\nExample 3 (typescript):\n```typescript\nimport { edenFetch } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst fetch = edenFetch<App>('http://localhost:3000')\n\n// response type: { id: 1895, name: 'Skadi' }\nconst { data: nendoroid, error } = await fetch('/mirror', {\n    method: 'POST',\n    body: {\n        id: 1895,\n        name: 'Skadi'\n    }\n})\n\nif(error) {\n    switch(error.status) {\n        case 400:\n        case 401:\n            throw error.value\n            break\n\n        case 500:\n        case 502:\n            throw error.value\n            break\n\n        default:\n            throw error.value\n            break\n    }\n}\n\nconst { id, name } = nendoroid\n```\n\n---\n\n## Unit Test\n\n**URL:** https://elysiajs.com/eden/treaty/unit-test.md\n\n**Contents:**\n- Type safety test\n\n---\nurl: 'https://elysiajs.com/eden/treaty/unit-test.md'\n---\n\nAccording to [Eden Treaty config](/eden/treaty/config.html#urlorinstance) and [Unit Test](/patterns/unit-test), we may pass an Elysia instance to Eden Treaty directly to interact with Elysia server directly without sending a network request.\n\nWe may use this pattern to create a unit test with end-to-end type safety and type-level test all at once.\n\nTo perform a type safety test, simply run **tsc** on test folders.\n\nThis is useful to ensure type integrity for both client and server, especially during migrations.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n## Type safety test\n\nTo perform a type safety test, simply run **tsc** on test folders.\n```\n\n---\n\n## End-to-End Type Safety&#x20;\n\n**URL:** https://elysiajs.com/eden/overview.md\n\n**Contents:**\n- Eden\n- Eden Treaty (Recommended)\n- Eden Fetch\n\n---\nurl: 'https://elysiajs.com/eden/overview.md'\n---\n\nImagine you have a toy train set.\n\nEach piece of the train track has to fit perfectly with the next one, like puzzle pieces.\n\nEnd-to-end type safety is like making sure all the pieces of the track match up correctly so the train doesn't fall off or get stuck.\n\nFor a framework to have end-to-end type safety means you can connect client and server in a type-safe manner.\n\nElysia provides end-to-end type safety **without code generation** out of the box with an RPC-like connector, **Eden**\n\nOther frameworks that support e2e type safety:\n\n* tRPC\n* Remix\n* SvelteKit\n* Nuxt\n* TS-Rest\n\nElysia allows you to change the type on the server and it will be instantly reflected on the client, helping with auto-completion and type-enforcement.\n\nEden is an RPC-like client to connect Elysia with **end-to-end type safety** using only TypeScript's type inference instead of code generation.\n\nIt allows you to sync client and server types effortlessly, weighing less than 2KB.\n\nEden consists of 2 modules:\n\n1. Eden Treaty **(recommended)**: an improved RPC version of Eden Treaty\n2. Eden Fetch: Fetch-like client with type safety\n\nBelow is an overview, use-case and comparison for each module.\n\nEden Treaty is an object-like representation of an Elysia server providing end-to-end type safety and a significantly improved developer experience.\n\nWith Eden Treaty we can interact with an Elysia server with full-type support and auto-completion, error handling with type narrowing, and create type-safe unit tests.\n\nExample usage of Eden Treaty:\n\nA fetch-like alternative to Eden Treaty for developers that prefers fetch syntax.\n\n::: tip NOTE\nUnlike Eden Treaty, Eden Fetch doesn't provide Web Socket implementation for Elysia server.\n:::\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n## Eden Fetch\n\nA fetch-like alternative to Eden Treaty for developers that prefers fetch syntax.\n```\n\n---\n\n## Eden Treaty Legacy\n\n**URL:** https://elysiajs.com/eden/treaty/legacy.md\n\n**Contents:**\n- Anatomy\n  - Path\n  - Path parameters\n  - Query\n  - Fetch\n- Error Handling\n  - Error type based on status\n- WebSocket\n- File Upload\n\n---\nurl: 'https://elysiajs.com/eden/treaty/legacy.md'\n---\n\n::: tip NOTE\nThis is a documentation for Eden Treaty 1 or (edenTreaty)\n\nFor a new project, we recommended starting with Eden Treaty 2 (treaty) instead.\n:::\n\nEden Treaty is an object-like representation of an Elysia server.\n\nProviding accessor like a normal object with type directly from the server, helping us to move faster, and make sure that nothing break\n\nTo use Eden Treaty, first export your existing Elysia server type:\n\nThen import the server type, and consume the Elysia API on client:\n\n::: tip\nEden Treaty is fully type-safe with auto-completion support.\n:::\n\nEden Treaty will transform all existing paths to object-like representation, that can be described as:\n\nEden will transform `/` into `.` which can be called with a registered `method`, for example:\n\n* **/path** -> .path\n* **/nested/path** -> .nested.path\n\nPath parameters will be mapped automatically by their name in the URL.\n\n* **/id/:id** -> .id.`<anyThing>`\n* eg: .id.hi\n* eg: .id\\['123']\n\n::: tip\nIf a path doesn't support path parameters, TypeScript will show an error.\n:::\n\nYou can append queries to path with `$query`:\n\nEden Treaty is a fetch wrapper, you can add any valid [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) parameters to Eden by passing it to `$fetch`:\n\nEden Treaty will return a value of `data` and `error` as a result, both fully typed.\n\nBoth **data**, and **error** will be typed as nullable until you can confirm their statuses with a type guard.\n\nTo put it simply, if fetch is successful, data will have a value and error will be null, and vice-versa.\n\n::: tip\nError is wrapped with an `Error` with its value return from the server can be retrieve from `Error.value`\n:::\n\nBoth Eden Treaty and Eden Fetch can narrow down an error type based on status code if you explicitly provided an error type in the Elysia server.\n\nAn on the client side:\n\nEden supports WebSocket using the same API as a normal route.\n\nTo start listening to real-time data, call the `.subscribe` method:\n\nWe can use [schema](/integrations/cheat-sheet#schema) to enforce type-safety on WebSockets, just like a normal route.\n\n**Eden.subscribe** returns **EdenWebSocket** which extends the [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket) class with type-safety. The syntax is identical with the WebSocket\n\nIf more control is need, **EdenWebSocket.raw** can be accessed to interact with the native WebSocket API.\n\nYou may either pass one of the following to the field to attach file:\n\n* **File**\n* **FileList**\n* **Blob**\n\nAttaching a file will results **content-type** to be **multipart/form-data**\n\nSuppose we have the server as the following:\n\nWe may use the client as follows:\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app // [!code ++]\n```\n\nExample 2 (typescript):\n```typescript\n// client.ts\nimport { edenTreaty } from '@elysiajs/eden'\nimport type { App } from './server' // [!code ++]\n\nconst app = edenTreaty<App>('http://localhost:')\n\n// response type: 'Hi Elysia'\nconst { data: pong, error } = app.get()\n\n// response type: 1895\nconst { data: id, error } = app.id['1895'].get()\n\n// response type: { id: 1895, name: 'Skadi' }\nconst { data: nendoroid, error } = app.mirror.post({\n    id: 1895,\n    name: 'Skadi'\n})\n```\n\nExample 3 (typescript):\n```typescript\nEdenTreaty.<1>.<2>.<n>.<method>({\n    ...body,\n    $query?: {},\n    $fetch?: RequestInit\n})\n```\n\nExample 4 (typescript):\n```typescript\napp.get({\n    $query: {\n        name: 'Eden',\n        code: 'Gold'\n    }\n})\n```\n\n---\n\n## WebSocket\n\n**URL:** https://elysiajs.com/eden/treaty/websocket.md\n\n**Contents:**\n- Response\n\n---\nurl: 'https://elysiajs.com/eden/treaty/websocket.md'\n---\n\nEden Treaty supports WebSocket using `subscribe` method.\n\n**.subscribe** accepts the same parameter as `get` and `head`.\n\n**Eden.subscribe** returns **EdenWS** which extends the [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket) results in identical syntax.\n\nIf more control is need, **EdenWebSocket.raw** can be accessed to interact with the native WebSocket API.\n\n---\n\n## Config\n\n**URL:** https://elysiajs.com/eden/treaty/config.md\n\n**Contents:**\n- urlOrInstance\n  - URL Endpoint (string)\n  - Elysia Instance\n- Options\n- Fetch\n- Headers\n  - Headers Object\n  - Function\n  - Array\n- Headers Priority\n\n---\nurl: 'https://elysiajs.com/eden/treaty/config.md'\n---\n\nEden Treaty accepts 2 parameters:\n\n* **urlOrInstance** - URL endpoint or Elysia instance\n* **options** (optional) - Customize fetch behavior\n\nAccept either URL endpoint as string or a literal Elysia instance.\n\nEden will change the behavior based on type as follows:\n\nIf URL endpoint is passed, Eden Treaty will use `fetch` or `config.fetcher` to create a network request to an Elysia instance.\n\nYou may or may not specify a protocol for URL endpoint.\n\nElysia will append the endpoints automatically as follows:\n\n1. If protocol is specified, use the URL directly\n2. If the URL is localhost and ENV is not production, use http\n3. Otherwise use https\n\nThis also applies to Web Socket as well for determining between **ws://** or **wss://**.\n\nIf Elysia instance is passed, Eden Treaty will create a `Request` class and pass to `Elysia.handle` directly without creating a network request.\n\nThis allows us to interact with Elysia server directly without request overhead, or the need to start a server.\n\nIf an instance is passed, generic is not needed to be passed as Eden Treaty can infer the type from a parameter directly.\n\nThis pattern is recommended for performing unit tests, or creating a type-safe reverse proxy server or micro-services.\n\n2nd optional parameter for Eden Treaty to customize fetch behavior, accepting parameters as follows:\n\n* [fetch](#fetch) - add default parameters to fetch initialization (RequestInit)\n* [headers](#headers) - define default headers\n* [fetcher](#fetcher) - custom fetch function eg. Axios, unfetch\n* [onRequest](#onrequest) - Intercept and modify fetch request before firing\n* [onResponse](#onresponse) - Intercept and modify fetch's response\n\nDefault parameters append to 2nd parameters of fetch extends type of **Fetch.RequestInit**.\n\nAll parameters that are passed to fetch will be passed to fetcher, which is equivalent to:\n\nProvide an additional default headers to fetch, a shorthand of `options.fetch.headers`.\n\nAll parameters that passed to fetch, will be passed to fetcher, which is an equivalent to:\n\nheaders may accept the following as parameters:\n\nIf object is passed, then it will be passed to fetch directly\n\nYou may specify headers as a function to return custom headers based on condition\n\nYou may return object to append its value to fetch headers.\n\nheaders function accepts 2 parameters:\n\n* path `string` - path which will be sent to parameter\n  * note: hostname will be **exclude** eg. (/user/griseo)\n* options `RequestInit`: Parameters that passed through 2nd parameter of fetch\n\nYou may define a headers function as an array if multiple conditions are needed.\n\nEden Treaty will **run all functions** even if the value is already returned.\n\nEden Treaty will prioritize the order headers if duplicated as follows:\n\n1. Inline method - Passed in method function directly\n2. headers - Passed in `config.headers`\n\n* If `config.headers` is array, parameters that come after will be prioritized\n\n3. fetch - Passed in `config.fetch.headers`\n\nFor example, for the following example:\n\nIf inline function doesn't specified headers, then the result will be \"**Bearer Aponia**\" instead.\n\nProvide a custom fetcher function instead of using an environment's default fetch.\n\nIt's recommended to replace fetch if you want to use other client other than fetch, eg. Axios, unfetch.\n\nIntercept and modify fetch request before firing.\n\nYou may return object to append the value to **RequestInit**.\n\nIf value is returned, Eden Treaty will perform a **shallow merge** for returned value and `value.headers`.\n\n**onRequest** accepts 2 parameters:\n\n* path `string` - path which will be sent to parameter\n  * note: hostname will be **exclude** eg. (/user/griseo)\n* options `RequestInit`: Parameters that passed through 2nd parameter of fetch\n\nYou may define an onRequest function as an array if multiples conditions are need.\n\nEden Treaty will **run all functions** even if the value is already returned.\n\nIntercept and modify fetch's response or return a new value.\n\n**onRequest** accepts 1 parameter:\n\n* response `Response` - Web Standard Response normally returned from `fetch`\n\nYou may define an onResponse function as an array if multiple conditions are need.\n\nUnlike [headers](#headers) and [onRequest](#onrequest), Eden Treaty will loop through functions until a returned value is found or error thrown, the returned value will be use as a new response.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst api = treaty<App>('localhost:3000')\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/hi', 'Hi Elysia')\n    .listen(3000)\n\nconst api = treaty(app)\n```\n\nExample 3 (typescript):\n```typescript\nexport type App = typeof app // [!code ++]\nimport { treaty } from '@elysiajs/eden'\n// ---cut---\ntreaty<App>('localhost:3000', {\n    fetch: {\n        credentials: 'include'\n    }\n})\n```\n\nExample 4 (typescript):\n```typescript\nfetch('http://localhost:3000', {\n    credentials: 'include'\n})\n```\n\n---\n",
        "plugins/coding/elysia/skills/elysia/references/essential.md": "# Elysia - Essential\n\n**Pages:** 6\n\n---\n\n## Validation&#x20;\n\n**URL:** https://elysiajs.com/essential/validation.md\n\n**Contents:**\n  - TypeBox\n  - Standard Schema\n- Schema type\n- Guard\n  - Guard Schema Type\n  - **override (default)**\n  - **standalone**&#x20;\n- Body\n    - Specs\n  - File\n\n---\nurl: 'https://elysiajs.com/essential/validation.md'\n---\n\nElysia provides a schema to validate data out of the box to ensure that the data is in the correct format.\n\n**Elysia.t** is a schema builder based on [TypeBox](https://github.com/sinclairzx81/typebox) that provides type-safety at runtime, compile-time, and OpenAPI schema generation from a single source of truth.\n\nElysia tailor TypeBox for server-side validation for a seamless experience.\n\nElysia also support [Standard Schema](https://github.com/standard-schema/standard-schema), allowing you to use your favorite validation library:\n\n* Zod\n* Valibot\n* ArkType\n* Effect Schema\n* Yup\n* Joi\n* [and more](https://github.com/standard-schema/standard-schema)\n\nTo use Standard Schema, simply import the schema and provide it to the route handler.\n\nYou can use any validator together in the same handler without any issue.\n\nElysia supports declarative schemas with the following types:\n\nThese properties should be provided as the third argument of the route handler to validate the incoming request.\n\nThe response should be as follows:\n| URL | Query | Params |\n| --- | --------- | ------------ |\n| /id/a | ❌ | ❌ |\n| /id/1?name=Elysia | ✅ | ✅ |\n| /id/1?alias=Elysia | ❌ | ✅ |\n| /id/a?name=Elysia | ✅ | ❌ |\n| /id/a?alias=Elysia | ❌ | ❌ |\n\nWhen a schema is provided, the type will be inferred from the schema automatically and an OpenAPI type will be generated for an API documentation, eliminating the redundant task of providing the type manually.\n\nGuard can be used to apply a schema to multiple handlers.\n\nThis code ensures that the query must have **name** with a string value for every handler after it. The response should be listed as follows:\n\nThe response should be listed as follows:\n\n| Path          | Response |\n| ------------- | -------- |\n| /none         | hi       |\n| /none?name=a  | hi       |\n| /query        | error    |\n| /query?name=a | a        |\n\nIf multiple global schemas are defined for the same property, the latest one will take precedence. If both local and global schemas are defined, the local one will take precedence.\n\nGuard supports 2 types to define a validation.\n\nOverride schema if schema is collide with each others.\n\n![Elysia run with default override guard showing schema gets override](/blog/elysia-13/schema-override.webp)\n\nSeparate collided schema, and runs both independently resulting in both being validated.\n\n![Elysia run with standalone merging multiple guard together](/blog/elysia-13/schema-standalone.webp)\n\nTo define schema type of guard with `schema`:\n\nAn incoming [HTTP Message](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages) is the data sent to the server. It can be in the form of JSON, form-data, or any other format.\n\nThe validation should be as follows:\n| Body | Validation |\n| --- | --------- |\n| { name: 'Elysia' } | ✅ |\n| { name: 1 } | ❌ |\n| { alias: 'Elysia' } | ❌ |\n| `undefined` | ❌ |\n\nElysia disables body-parser for **GET** and **HEAD** messages by default, following the specs of HTTP/1.1 [RFC2616](https://www.rfc-editor.org/rfc/rfc2616#section-4.3)\n\n> If the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.\n\nMost browsers disable the attachment of the body by default for **GET** and **HEAD** methods.\n\nValidate an incoming [HTTP Message](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages) (or body).\n\nThese messages are additional messages for the web server to process.\n\nThe body is provided in the same way as the `body` in `fetch` API. The content type should be set accordingly to the defined body.\n\nFile is a special type of body that can be used to upload files.\n\nBy providing a file type, Elysia will automatically assume that the content-type is `multipart/form-data`.\n\nIf you're using Standard Schema, it's important that Elysia will not be able to validate content type automatically similar to `t.File`.\n\nBut Elysia export a `fileType` that can be used to validate file type by using magic number.\n\nIt's very important that you **should use** `fileType` to validate the file type as **most validator doesn't actually validate the file** correctly, like checking the content type the value of it which can lead to security vulnerability.\n\nQuery is the data sent through the URL. It can be in the form of `?key=value`.\n\nQuery must be provided in the form of an object.\n\nThe validation should be as follows:\n| Query | Validation |\n| ---- | --------- |\n| /?name=Elysia | ✅ |\n| /?name=1 | ✅ |\n| /?alias=Elysia | ❌ |\n| /?name=ElysiaJS\\&alias=Elysia | ✅ |\n| / | ❌ |\n\nA query string is a part of the URL that starts with **?** and can contain one or more query parameters, which are key-value pairs used to convey additional information to the server, usually for customized behavior like filtering or searching.\n\n![URL Object](/essential/url-object.svg)\n\nQuery is provided after the **?** in Fetch API.\n\nWhen specifying query parameters, it's crucial to understand that all query parameter values must be represented as strings. This is due to how they are encoded and appended to the URL.\n\nElysia will coerce applicable schema on `query` to respective type automatically.\n\nSee [Elysia behavior](/patterns/type#elysia-behavior) for more information.\n\nBy default, Elysia treat query parameters as a single string even if specified multiple time.\n\nTo use array, we need to explicitly declare it as an array.\n\nOnce Elysia detect that a property is assignable to array, Elysia will coerce it to an array of the specified type.\n\nBy default, Elysia format query array with the following format:\n\nThis format is used by [nuqs](https://nuqs.47ng.com).\n\nBy using **,** as a delimiter, a property will be treated as array.\n\nIf a key is assigned multiple time, the key will be treated as an array.\n\nThis is similar to HTML form format when an input with the same name is specified multiple times.\n\nParams or path parameters are the data sent through the URL path.\n\nThey can be in the form of `/key`.\n\nParams must be provided in the form of an object.\n\nThe validation should be as follows:\n| URL | Validation |\n| --- | --------- |\n| /id/1 | ✅ |\n| /id/a | ❌ |\n\nPath parameter (not to be confused with query string or query parameter).\n\n**This field is usually not needed as Elysia can infer types from path parameters automatically**, unless there is a need for a specific value pattern, such as a numeric value or template literal pattern.\n\nIf a params schema is not provided, Elysia will automatically infer the type as a string.\n\nHeaders are the data sent through the request's header.\n\nUnlike other types, headers have `additionalProperties` set to `true` by default.\n\nThis means that headers can have any key-value pair, but the value must match the schema.\n\nHTTP headers let the client and the server pass additional information with an HTTP request or response, usually treated as metadata.\n\nThis field is usually used to enforce some specific header fields, for example, `Authorization`.\n\nHeaders are provided in the same way as the `body` in `fetch` API.\n\n::: tip\nElysia will parse headers as lower-case keys only.\n\nPlease make sure that you are using lower-case field names when using header validation.\n:::\n\nCookie is the data sent through the request's cookie.\n\nCookies must be provided in the form of `t.Cookie` or `t.Object`.\n\nSame as `headers`, cookies have `additionalProperties` set to `true` by default.\n\nAn HTTP cookie is a small piece of data that a server sends to the client. It's data that is sent with every visit to the same web server to let the server remember client information.\n\nIn simpler terms, it's a stringified state that is sent with every request.\n\nThis field is usually used to enforce some specific cookie fields.\n\nA cookie is a special header field that the Fetch API doesn't accept a custom value for but is managed by the browser. To send a cookie, you must use a `credentials` field instead:\n\n`t.Cookie` is a special type that is equivalent to `t.Object` but allows to set cookie-specific options.\n\nResponse is the data returned from the handler.\n\nResponses can be set per status code.\n\nThis is an Elysia-specific feature, allowing us to make a field optional.\n\nThere are two ways to provide a custom error message when the validation fails:\n\n1. Inline `status` property\n2. Using [onError](/essential/life-cycle.html#on-error) event\n\nElysia offers an additional **error** property, allowing us to return a custom error message if the field is invalid.\n\nThe following is an example of using the error property on various types:\n\nTypeBox offers an additional \"**error**\" property, allowing us to return a custom error message if the field is invalid.\n\nIn addition to a string, Elysia type's error can also accept a function to programmatically return a custom error for each property.\n\nThe error function accepts the same arguments as `ValidationError`\n\n::: tip\nHover over the `error` to see the type.\n:::\n\nPlease note that the error function will only be called if the field is invalid.\n\nPlease consider the following table:\n\nWe can customize the behavior of validation based on the [onError](/essential/life-cycle.html#on-error) event by narrowing down the error code to \"**VALIDATION**\".\n\nThe narrowed-down error type will be typed as `ValidationError` imported from **elysia/error**.\n\n**ValidationError** exposes a property named **validator**, typed as [TypeCheck](https://github.com/sinclairzx81/typebox#typecheck), allowing us to interact with TypeBox functionality out of the box.\n\n**ValidationError** provides a method `ValidatorError.all`, allowing us to list all of the error causes.\n\nFor more information about TypeBox's validator, see [TypeCheck](https://github.com/sinclairzx81/typebox#typecheck).\n\nSometimes you might find yourself declaring duplicate models or re-using the same model multiple times.\n\nWith a reference model, we can name our model and reuse it by referencing the name.\n\nLet's start with a simple scenario.\n\nSuppose we have a controller that handles sign-in with the same model.\n\nWe can refactor the code by extracting the model as a variable and referencing it.\n\nThis method of separating concerns is an effective approach, but we might find ourselves reusing multiple models with different controllers as the app gets more complex.\n\nWe can resolve that by creating a \"reference model\", allowing us to name the model and use auto-completion to reference it directly in `schema` by registering the models with `model`.\n\nWhen we want to access the model's group, we can separate a `model` into a plugin, which when registered will provide a set of models instead of multiple imports.\n\nThen in an instance file:\n\nThis approach not only allows us to separate concerns but also enables us to reuse the model in multiple places while integrating the model into OpenAPI documentation.\n\n`model` accepts an object with the key as a model name and the value as the model definition. Multiple models are supported by default.\n\nDuplicate model names will cause Elysia to throw an error. To prevent declaring duplicate model names, we can use the following naming convention.\n\nLet's say that we have all models stored at `models/<name>.ts` and declare the prefix of the model as a namespace.\n\nThis can prevent naming duplication to some extent, but ultimately, it's best to let your team decide on the naming convention.\n\nElysia provides an opinionated option to help prevent decision fatigue.\n\nWe can get type definitions of every Elysia/TypeBox's type by accessing the `static` property as follows:\n\nThis allows Elysia to infer and provide type automatically, reducing the need to declare duplicate schema\n\nA single Elysia/TypeBox schema can be used for:\n\n* Runtime validation\n* Data coercion\n* TypeScript type\n* OpenAPI schema\n\nThis allows us to make a schema as a **single source of truth**.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n### TypeBox\n\n**Elysia.t** is a schema builder based on [TypeBox](https://github.com/sinclairzx81/typebox) that provides type-safety at runtime, compile-time, and OpenAPI schema generation from a single source of truth.\n\nElysia tailor TypeBox for server-side validation for a seamless experience.\n\n### Standard Schema\n\nElysia also support [Standard Schema](https://github.com/standard-schema/standard-schema), allowing you to use your favorite validation library:\n\n* Zod\n* Valibot\n* ArkType\n* Effect Schema\n* Yup\n* Joi\n* [and more](https://github.com/standard-schema/standard-schema)\n\nTo use Standard Schema, simply import the schema and provide it to the route handler.\n```\n\nExample 2 (unknown):\n```unknown\nYou can use any validator together in the same handler without any issue.\n\n## Schema type\n\nElysia supports declarative schemas with the following types:\n\n***\n\nThese properties should be provided as the third argument of the route handler to validate the incoming request.\n```\n\nExample 3 (unknown):\n```unknown\nThe response should be as follows:\n| URL | Query | Params |\n| --- | --------- | ------------ |\n| /id/a | ❌ | ❌ |\n| /id/1?name=Elysia | ✅ | ✅ |\n| /id/1?alias=Elysia | ❌ | ✅ |\n| /id/a?name=Elysia | ✅ | ❌ |\n| /id/a?alias=Elysia | ❌ | ❌ |\n\nWhen a schema is provided, the type will be inferred from the schema automatically and an OpenAPI type will be generated for an API documentation, eliminating the redundant task of providing the type manually.\n\n## Guard\n\nGuard can be used to apply a schema to multiple handlers.\n```\n\nExample 4 (unknown):\n```unknown\nThis code ensures that the query must have **name** with a string value for every handler after it. The response should be listed as follows:\n\nThe response should be listed as follows:\n\n| Path          | Response |\n| ------------- | -------- |\n| /none         | hi       |\n| /none?name=a  | hi       |\n| /query        | error    |\n| /query?name=a | a        |\n\nIf multiple global schemas are defined for the same property, the latest one will take precedence. If both local and global schemas are defined, the local one will take precedence.\n\n### Guard Schema Type\n\nGuard supports 2 types to define a validation.\n\n### **override (default)**\n\nOverride schema if schema is collide with each others.\n\n![Elysia run with default override guard showing schema gets override](/blog/elysia-13/schema-override.webp)\n\n### **standalone**&#x20;\n\nSeparate collided schema, and runs both independently resulting in both being validated.\n\n![Elysia run with standalone merging multiple guard together](/blog/elysia-13/schema-standalone.webp)\n\nTo define schema type of guard with `schema`:\n```\n\n---\n\n## Lifecycle&#x20;\n\n**URL:** https://elysiajs.com/essential/life-cycle.md\n\n**Contents:**\n- Why\n- Hook\n- Local Hook\n- Interceptor Hook\n- Order of code\n- Request\n    - Example\n  - Pre Context\n- Parse\n    - Example\n\n---\nurl: 'https://elysiajs.com/essential/life-cycle.md'\n---\n\nInstead of a sequential process, Elysia's request handling is divided into multiple stages called **lifecycle events**.\n\nIt's designed to separate the process into distinct phases based on their responsibility without interfering with each others.\n\nHere are the order of lifecycle events in order:\n\nElysia's lifecycle can be illustrated as the following.\n![Elysia Life Cycle Graph](/assets/lifecycle-chart.svg)\n\n> Click on image to enlarge\n\nLet’s say we want to send back some HTML.\n\nNormally, we’d set the **\"Content-Type\"** header to **\"text/html\"** so the browser can render it.\n\nBut manually setting one for each route is tedious.\n\nInstead, what if the framework could detect when a response is HTML and automatically set the header for you? That’s where the idea of a lifecycle comes in.\n\nEach function that intercepts the **lifecycle event** as **\"hook\"**.\n\n(as the function **\"hooks\"** into the lifecycle event)\n\nHooks can be categorized into 2 types:\n\n1. [Local Hook](#local-hook): Execute on a specific route\n2. [Interceptor Hook](#interceptor-hook): Execute on every route **after the hook is registered**\n\n::: tip\nThe hook will accept the same Context as a handler; you can imagine adding a route handler but at a specific point.\n:::\n\nA local hook is executed on a specific route.\n\nTo use a local hook, you can inline hook into a route handler:\n\nThe response should be listed as follows:\n\n| Path | Content-Type             |\n| ---- | ------------------------ |\n| /    | text/html; charset=utf8  |\n| /hi  | text/plain; charset=utf8 |\n\nRegister hook into every handler **of the current instance** that came after.\n\nTo add an interceptor hook, you can use `.on` followed by a lifecycle event in camelCase:\n\nThe response should be listed as follows:\n\n| Path  | Content-Type             |\n| ----- | ------------------------ |\n| /none | text/**plain**; charset=utf8 |\n| /     | text/**html**; charset=utf8  |\n| /hi   | text/**html**; charset=utf8  |\n\nEvents from other plugins are also applied to the route, so the order of code is important.\n\nEvent will only apply to routes **after** it is registered.\n\nIf you put the `onError` before plugin, plugin will not inherit the `onError` event.\n\nConsole should log the following:\n\nNotice that it doesn't log **2**, because the event is registered after the route so it is not applied to the route.\n\nThis also applies to the plugin.\n\nIn this example, only **1** will be logged because the event is registered after the plugin.\n\nEvery events will follows the same rule except is `onRequest`.\nBecause onRequest happens on request, it doesn't know which route to applied to so it's a global event\n\nThe first lifecycle event to get executed for every new request is received.\n\nAs `onRequest` is designed to provide only the most crucial context to reduce overhead, it is recommended to use in the following scenarios:\n\n* Caching\n* Rate Limiter / IP/Region Lock\n* Analytic\n* Provide custom header, eg. CORS\n\nBelow is a pseudocode to enforce rate-limits on a certain IP address.\n\nIf a value is returned from `onRequest`, it will be used as the response and the rest of the lifecycle will be skipped.\n\nContext's `onRequest` is typed as `PreContext`, a minimal representation of `Context` with the attribute on the following:\nrequest: `Request`\n\n* set: `Set`\n* store\n* decorators\n\nContext doesn't provide `derived` value because derive is based on `onTransform` event.\n\nParse is an equivalent of **body parser** in Express.\n\nA function to parse body, the return value will be append to `Context.body`, if not, Elysia will continue iterating through additional parser functions assigned by `onParse` until either body is assigned or all parsers have been executed.\n\nBy default, Elysia will parse the body with content-type of:\n\n* `text/plain`\n* `application/json`\n* `multipart/form-data`\n* `application/x-www-form-urlencoded`\n\nIt's recommended to use the `onParse` event to provide a custom body parser that Elysia doesn't provide.\n\nBelow is an example code to retrieve value based on custom headers.\n\nThe returned value will be assigned to `Context.body`. If not, Elysia will continue iterating through additional parser functions from **onParse** stack until either body is assigned or all parsers have been executed.\n\n`onParse` Context is extends from `Context` with additional properties of the following:\n\n* contentType: Content-Type header of the request\n\nAll of the context is based on normal context and can be used like normal context in route handler.\n\nBy default, Elysia will try to determine body parsing function ahead of time and pick the most suitable function to speed up the process.\n\nElysia is able to determine that body function by reading `body`.\n\nTake a look at this example:\n\nElysia read the body schema and found that, the type is entirely an object, so it's likely that the body will be JSON. Elysia then picks the JSON body parser function ahead of time and tries to parse the body.\n\nHere's a criteria that Elysia uses to pick up type of body parser\n\n* `application/json`: body typed as `t.Object`\n* `multipart/form-data`: body typed as `t.Object`, and is 1 level deep with `t.File`\n* `application/x-www-form-urlencoded`: body typed as `t.URLEncoded`\n* `text/plain`: other primitive type\n\nThis allows Elysia to optimize body parser ahead of time, and reduce overhead in compile time.\n\nHowever, in some scenario if Elysia fails to pick the correct body parser function, we can explicitly tell Elysia to use a certain function by specifying `type`.\n\nThis allows us to control Elysia behavior for picking body parser function to fit our needs in a complex scenario.\n\n`type` may be one of the following:\n\nWhen you need to integrate a third-party library with HTTP handler like `trpc`, `orpc`, and it throw `Body is already used`.\n\nThis is because Web Standard Request can be parsed only once.\n\nBoth Elysia and the third-party library both has its own body parser, so you can skip body parsing on Elysia side by specifying `parse: 'none'`\n\nYou can provide register a custom parser with `parser`:\n\nExecuted just before **Validation** process, designed to mutate context to conform with the validation or appending new value.\n\nIt's recommended to use transform for the following:\n\n* Mutate existing context to conform with validation.\n* `derive` is based on `onTransform` with support for providing type.\n\nBelow is an example of using transform to mutate params to be numeric values.\n\nAppend new value to context directly **before validation**. It's stored in the same stack as **transform**.\n\nUnlike **state** and **decorate** that assigned value before the server started. **derive** assigns a property when each request happens. This allows us to extract a piece of information into a property instead.\n\nBecause **derive** is assigned once a new request starts, **derive** can access Request properties like **headers**, **query**, **body** where **store**, and **decorate** can't.\n\nUnlike **state**, and **decorate**. Properties which assigned by **derive** is unique and not shared with another request.\n\n::: tip\nYou might want to use [resolve](#resolve) instead of derive in most cases.\n\nResolve is similar to derive but execute after validation. This make resolve more secure as we can validate the incoming data before using it to derive new properties.\n:::\n\n`derive` and `transform` are stored in the same queue.\n\nThe console should log as the following:\n\nExecute after validation and before the main route handler.\n\nDesigned to provide a custom validation to provide a specific requirement before running the main handler.\n\nIf a value is returned, the route handler will be skipped.\n\nIt's recommended to use Before Handle in the following situations:\n\n* Restricted access check: authorization, user sign-in\n* Custom request requirement over data structure\n\nBelow is an example of using the before handle to check for user sign-in.\n\nThe response should be listed as follows:\n\n| Is signed in | Response     |\n| ------------ | ------------ |\n| ❌           | Unauthorized |\n| ✅           | Hi           |\n\nWhen we need to apply the same before handle to multiple routes, we can use `guard` to apply the same before handle to multiple routes.\n\nAppend new value to context **after validation**. It's stored in the same stack as **beforeHandle**.\n\nResolve syntax is identical to [derive](#derive), below is an example of retrieving a bearer header from the Authorization plugin.\n\nUsing `resolve` and `onBeforeHandle` is stored in the same queue.\n\nThe console should log as the following:\n\nSame as **derive**, properties which assigned by **resolve** is unique and not shared with another request.\n\nAs resolve is not available in local hook, it's recommended to use guard to encapsulate the **resolve** event.\n\nExecute after the main handler, for mapping a returned value of **before handle** and **route handler** into a proper response.\n\nIt's recommended to use After Handle in the following situations:\n\n* Transform requests into a new value, eg. Compression, Event Stream\n* Add custom headers based on the response value, eg. **Content-Type**\n\nBelow is an example of using the after handle to add HTML content type to response headers.\n\nThe response should be listed as follows:\n\n| Path | Content-Type             |\n| ---- | ------------------------ |\n| /    | text/html; charset=utf8  |\n| /hi  | text/plain; charset=utf8 |\n\nIf a value is returned After Handle will use a return value as a new response value unless the value is **undefined**\n\nThe above example could be rewritten as the following:\n\nUnlike **beforeHandle**, after a value is returned from **afterHandle**, the iteration of afterHandle **will **NOT** be skipped.**\n\n`onAfterHandle` context extends from `Context` with the additional property of `response`, which is the response to return to the client.\n\nThe `onAfterHandle` context is based on the normal context and can be used like the normal context in route handlers.\n\nExecuted just after **\"afterHandle\"**, designed to provide custom response mapping.\n\nIt's recommended to use transform for the following:\n\n* Compression\n* Map value into a Web Standard Response\n\nBelow is an example of using mapResponse to provide Response compression.\n\nLike **parse** and **beforeHandle**, after a value is returned, the next iteration of **mapResponse** will be skipped.\n\nElysia will handle the merging process of **set.headers** from **mapResponse** automatically. We don't need to worry about appending **set.headers** to Response manually.\n\nDesigned for error handling. It will be executed when an error is thrown in any lifecycle.\n\nIt's recommended to use on Error in the following situations:\n\n* providing a custom error message\n* fail-safe handling, an error handler, or retrying a request\n* logging and analytics\n\nElysia catches all the errors thrown in the handler, classifies the error code, and pipes them to `onError` middleware.\n\nWith `onError` we can catch and transform the error into a custom error message.\n\n::: tip\nIt's important that `onError` must be called before the handler we want to apply it to.\n:::\n\nFor example, returning custom 404 messages:\n\n`onError` Context is extends from `Context` with additional properties of the following:\n\n* **error**: A value that was thrown\n* **code**: *Error Code*\n\nElysia error code consists of:\n\n* **NOT\\_FOUND**\n* **PARSE**\n* **VALIDATION**\n* **INTERNAL\\_SERVER\\_ERROR**\n* **INVALID\\_COOKIE\\_SIGNATURE**\n* **INVALID\\_FILE\\_TYPE**\n* **UNKNOWN**\n* **number** (based on HTTP Status)\n\nBy default, the thrown error code is `UNKNOWN`.\n\n::: tip\nIf no error response is returned, the error will be returned using `error.name`.\n:::\n\nSame as others life-cycle, we provide an error into an [scope](/essential/plugin.html#scope) using guard:\n\nExecuted after the response sent to the client.\n\nIt's recommended to use **After Response** in the following situations:\n\n* Clean up response\n* Logging and analytics\n\nBelow is an example of using the response handle to check for user sign-in.\n\nConsole should log as the following:\n\nSimilar to [Map Response](#map-resonse), `afterResponse` also accept a `responseValue` value.\n\n`response` from `onAfterResponse`, is not a Web-Standard's `Response` but is a value that is returned from the handler.\n\nTo get a headers, and status returned from the handler, we can access `set` from the context.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { isHtml } from '@elysiajs/html'\n\nnew Elysia()\n    .get('/', () => '<h1>Hello World</h1>', {\n        afterHandle({ responseValue, set }) {\n            if (isHtml(responseValue))\n                set.headers['Content-Type'] = 'text/html; charset=utf8'\n        }\n    })\n    .get('/hi', () => '<h1>Hello World</h1>')\n    .listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { isHtml } from '@elysiajs/html'\n\nnew Elysia()\n    .get('/none', () => '<h1>Hello World</h1>')\n    .onAfterHandle(({ responseValue, set }) => {\n        if (isHtml(responseValue))\n            set.headers['Content-Type'] = 'text/html; charset=utf8'\n    })\n    .get('/', () => '<h1>Hello World</h1>')\n    .get('/hi', () => '<h1>Hello World</h1>')\n    .listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n \t.onBeforeHandle(() => {\n        console.log('1')\n    })\n\t.get('/', () => 'hi')\n    .onBeforeHandle(() => {\n        console.log('2')\n    })\n    .listen(3000)\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.onBeforeHandle(() => {\n\t\tconsole.log('1')\n\t})\n\t.use(someRouter)\n\t.onBeforeHandle(() => {\n\t\tconsole.log('2')\n\t})\n\t.listen(3000)\n```\n\n---\n\n## Routing&#x20;\n\n**URL:** https://elysiajs.com/essential/route.md\n\n**Contents:**\n- Path type\n- Static Path\n- Dynamic path\n  - Multiple path parameters\n- Optional path parameters\n- Wildcards\n- Path priority\n- HTTP Verb\n  - GET\n  - POST\n\n---\nurl: 'https://elysiajs.com/essential/route.md'\n---\n\nWeb servers use the request's **path and method** to look up the correct resource, known as **\"routing\"**.\n\nWe can define a route with **HTTP verb method**, a path and a function to execute when matched.\n\nWe can access the web server by going to **http://localhost:3000**\n\nBy default, web browsers will send a GET method when visiting a page.\n\n::: tip\nUsing the interactive browser above, hover on the blue highlight area to see different results between each path.\n:::\n\nPath in Elysia can be grouped into 3 types:\n\n* **static paths** - static string to locate the resource\n* **dynamic paths** - segment can be any value\n* **wildcards** - path until a specific point can be anything\n\nYou can use all of the path types together to compose a behavior for your web server.\n\nStatic path is a hardcoded string to locate the resource on the server.\n\nDynamic paths match some part and capture the value to extract extra information.\n\nTo define a dynamic path, we can use a colon `:` followed by a name.\n\nHere, a dynamic path is created with `/id/:id`. Which tells Elysia to capture the value `:id` segment with value like **/id/1**, **/id/123**, **/id/anything**.\n\nWhen requested, the server should return the response as follows:\n\n| Path                   | Response  |\n| ---------------------- | --------- |\n| /id/1                  | 1         |\n| /id/123                | 123       |\n| /id/anything           | anything  |\n| /id/anything?name=salt | anything  |\n| /id                    | Not Found |\n| /id/anything/rest      | Not Found |\n\nDynamic paths are great to include things like IDs that can be used later.\n\nWe refer to the named variable path as **path parameter** or **params** for short.\n\nYou can have as many path parameters as you like, which will then be stored into a `params` object.\n\nThe server will respond as follows:\n\n| Path                   | Response      |\n| ---------------------- | ------------- |\n| /id/1                  | 1             |\n| /id/123                | 123           |\n| /id/anything           | anything      |\n| /id/anything?name=salt | anything      |\n| /id                    | Not Found     |\n| /id/anything/rest      | anything rest |\n\nSometime we might want a static and dynamic path to resolve the same handler.\n\nWe can make a path parameter optional by adding a question mark `?` after the parameter name.\n\nDynamic paths allow capturing a single segment while wildcards allow capturing the rest of the path.\n\nTo define a wildcard, we can use an asterisk `*`.\n\nElysia has a path priorities as follows:\n\n1. static paths\n2. dynamic paths\n3. wildcards\n\nIf the path is resolved as the static wild dynamic path is presented, Elysia will resolve the static path rather than the dynamic path\n\nHTTP defines a set of request methods to indicate the desired action to be performed for a given resource\n\nThere are several HTTP verbs, but the most common ones are:\n\nRequests using GET should only retrieve data.\n\nSubmits a payload to the specified resource, often causing state change or side effect.\n\nReplaces all current representations of the target resource using the request's payload.\n\nApplies partial modifications to a resource.\n\nDeletes the specified resource.\n\nTo handle each of the different verbs, Elysia has a built-in API for several HTTP verbs by default, similar to `Elysia.get`\n\nElysia HTTP methods accepts the following parameters:\n\n* **path**: Pathname\n* **function**: Function to respond to the client\n* **hook**: Additional metadata\n\nYou can read more about the HTTP methods on [HTTP Request Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods).\n\nWe can accept custom HTTP Methods with `Elysia.route`.\n\n**Elysia.route** accepts the following:\n\n* **method**: HTTP Verb\n* **path**: Pathname\n* **function**: Function to response to the client\n* **hook**: Additional metadata\n\n::: tip\nBased on [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-4.1), HTTP Verb is case-sensitive.\n\nIt's recommended to use the UPPERCASE convention for defining a custom HTTP Verb with Elysia.\n:::\n\nElysia provides an `Elysia.all` for handling any HTTP method for a specified path using the same API like **Elysia.get** and **Elysia.post**\n\nAny HTTP method that matches the path, will be handled as follows:\n| Path | Method | Result |\n| ---- | -------- | ------ |\n| / | GET | hi |\n| / | POST | hi |\n| / | DELETE | hi |\n\nMost developers use REST clients like Postman, Insomnia or Hoppscotch to test their API.\n\nHowever, Elysia can be programmatically test using `Elysia.handle`.\n\n**Elysia.handle** is a function to process an actual request sent to the server.\n\n::: tip\nUnlike unit test's mock, **you can expect it to behave like an actual request** sent to the server.\n\nBut also useful for simulating or creating unit tests.\n:::\n\nWhen creating a web server, you would often have multiple routes sharing the same prefix:\n\nThis can be improved with `Elysia.group`, allowing us to apply prefixes to multiple routes at the same time by grouping them together:\n\nThis code behaves the same as our first example and should be structured as follows:\n\n| Path          | Result  |\n| ------------- | ------- |\n| /user/sign-in | Sign in |\n| /user/sign-up | Sign up |\n| /user/profile | Profile |\n\n`.group()` can also accept an optional guard parameter to reduce boilerplate of using groups and guards together:\n\nYou may find more information about grouped guards in [scope](/essential/plugin.html#scope).\n\nWe can separate a group into a separate plugin instance to reduce nesting by providing a **prefix** to the constructor.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', 'hello')\n    .get('/hi', 'hi')\n    .listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/1', 'static path')\n    .get('/id/:id', 'dynamic path')\n    .get('/id/*', 'wildcard path')\n    .listen(3000)\n```\n\nExample 3 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/hello', 'hello')\n\t.get('/hi', 'hi')\n\t.listen(3000)\n```\n\nExample 4 (unknown):\n```unknown\nHere, a dynamic path is created with `/id/:id`. Which tells Elysia to capture the value `:id` segment with value like **/id/1**, **/id/123**, **/id/anything**.\n\nWhen requested, the server should return the response as follows:\n\n| Path                   | Response  |\n| ---------------------- | --------- |\n| /id/1                  | 1         |\n| /id/123                | 123       |\n| /id/anything           | anything  |\n| /id/anything?name=salt | anything  |\n| /id                    | Not Found |\n| /id/anything/rest      | Not Found |\n\nDynamic paths are great to include things like IDs that can be used later.\n\nWe refer to the named variable path as **path parameter** or **params** for short.\n\n### Multiple path parameters\n\nYou can have as many path parameters as you like, which will then be stored into a `params` object.\n```\n\n---\n\n## Plugin&#x20;\n\n**URL:** https://elysiajs.com/essential/plugin.md\n\n**Contents:**\n- Dependency&#x20;\n  - Deduplication&#x20;\n  - Global vs Explicit Dependency\n- Scope &#x20;\n  - Scope level\n  - Descendant\n- Config\n  - Functional callback\n- Guard&#x20;\n  - Grouped Guard\n\n---\nurl: 'https://elysiajs.com/essential/plugin.md'\n---\n\nA plugin is a part that is **decoupled** from the main instance into a smaller part.\n\nEvery Elysia instance can run independently or use as a part of another instance.\n\nWe can use the plugin by passing an instance to **Elysia.use**.\n\nThe plugin will inherit all properties of the plugin instance like `state`, `decorate` but **WILL NOT inherit plugin [lifecycle](/essential/life-cycle)** as it's [isolated by default](#scope) (mentioned in the next section ↓).\n\nElysia will also handle the type inference automatically as well.\n\n::: tip\nIt's highly recommended that you have read [Key Concept: Dependency](/key-concept.html#dependency) before continuing.\n:::\n\nElysia by design, is compose of multiple mini Elysia apps which can run **independently** like a microservice that communicate with each other.\n\nEach Elysia instance is independent and **can run as a standalone server**.\n\nWhen an instance need to use another instance's service, you **must explicitly declare the dependency**.\n\nThis is similar to **Dependency Injection** where each instance must declare its dependencies.\n\nThis approach force you to be explicit about dependencies allowing better tracking, modularity.\n\nBy default, each plugin will be re-executed **every time** applying to another instance.\n\nTo prevent this, Elysia can deduplicate [lifecycle](/essential/life-cycle) with **an unique identifier** using `name` and optional `seed` property.\n\nAdding the `name` and optional `seed` to the instance will make it a unique identifier prevent it from being called multiple times.\n\nLearn more about this in [plugin deduplication](/essential/plugin.html#plugin-deduplication).\n\nThere are some case that global dependency make more sense than an explicit one.\n\n**Global** plugin example:\n\n* **Plugin that doesn't add types** - eg. cors, compress, helmet\n* Plugin that add global [lifecycle](/essential/life-cycle) that no instance should have control over - eg. tracing, logging\n\n* OpenAPI/Open - Global document\n* OpenTelemetry - Global tracer\n* Logging - Global logger\n\nIn case like this, it make more sense to create it as global dependency instead of applying it to every instance.\n\nHowever, if your dependency doesn't fit into these categories, it's recommended to use **explicit dependency** instead.\n\n**Explicit dependency** example:\n\n* **Plugin that add types** - eg. macro, state, model\n* Plugin that add business logic that instance can interact with - eg. Auth, Database\n\n* State management - eg. Store, Session\n* Data modeling - eg. ORM, ODM\n* Business logic - eg. Auth, Database\n* Feature module - eg. Chat, Notification\n\nElysia [lifecycle](/essential/life-cycle) methods are **encapsulated** to its own instance only.\n\nWhich means if you create a new instance, it will not share the lifecycle methods with others.\n\nIn this example, the `isSignIn` check will only apply to `profile` but not `app`.\n\n> Try changing the path in the URL bar to **/rename** and see the result\n\n**Elysia isolate [lifecycle](/essential/life-cycle) by default** unless explicitly stated. This is similar to **export** in JavaScript, where you need to export the function to make it available outside the module.\n\nTo **\"export\"** the lifecycle to other instances, you must add specify the scope.\n\nCasting lifecycle to **\"global\"** will export lifecycle to **every instance**.\n\nElysia has 3 levels of scope as the following:\n\nScope type are as the following:\n\n1. **local** (default) - apply to only current instance and descendant only\n2. **scoped** - apply to parent, current instance and descendants\n3. **global** - apply to all instance that apply the plugin (all parents, current, and descendants)\n\nLet's review what each scope type does by using the following example:\n\nBy changing the `type` value, the result should be as follows:\n\n| type       | child | current | parent | main |\n| ---------- | ----- | ------- | ------ | ---- |\n| local      | ✅    | ✅      | ❌      | ❌   |\n| scoped     | ✅    | ✅      | ✅      | ❌   |\n| global     | ✅    | ✅      | ✅      | ✅   |\n\nBy default plugin will **apply hook to itself and descendants** only.\n\nIf the hook is registered in a plugin, instances that inherit the plugin will **NOT** inherit hooks and schema.\n\nTo apply hook to globally, we need to specify hook as global.\n\nTo make the plugin more useful, allowing customization via config is recommended.\n\nYou can create a function that accepts parameters that may change the behavior of the plugin to make it more reusable.\n\nIt's recommended to define a new plugin instance instead of using a function callback.\n\nFunctional callback allows us to access the existing property of the main instance. For example, checking if specific routes or stores existed but harder to handle encapsulation and scope correctly.\n\nTo define a functional callback, create a function that accepts Elysia as a parameter.\n\nOnce passed to `Elysia.use`, functional callback behaves as a normal plugin except the property is assigned directly to the main instance.\n\n::: tip\nYou shall not worry about the performance difference between a functional callback and creating an instance.\n\nElysia can create 10k instances in a matter of milliseconds, the new Elysia instance has even better type inference performance than the functional callback.\n:::\n\nGuard allows us to apply hook and schema into multiple routes all at once.\n\nThis code applies validation for `body` to both '/sign-in' and '/sign-up' instead of inlining the schema one by one but applies not to '/'.\n\nWe can summarize the route validation as the following:\n| Path | Has validation |\n| ------- | ------------- |\n| /sign-up | ✅ |\n| /sign-in | ✅ |\n| / | ❌ |\n\nGuard accepts the same parameter as inline hook, the only difference is that you can apply hook to multiple routes in the scope.\n\nThis means that the code above is translated into:\n\nWe can use a group with prefixes by providing 3 parameters to the group.\n\n1. Prefix - Route prefix\n2. Guard - Schema\n3. Scope - Elysia app callback\n\nWith the same API as guard apply to the 2nd parameter, instead of nesting group and guard together.\n\nConsider the following example:\n\nFrom nested groupped guard, we may merge group and guard together by providing guard scope to 2nd parameter of group:\n\nWhich results in the follows syntax:\n\nTo apply hook to parent may use one of the following:\n\n1. [inline as](#inline-as) apply only to a single hook\n2. [guard as](#guard-as) apply to all hook in a guard\n3. [instance as](#instance-as) apply to all hook in an instance\n\nEvery event listener will accept `as` parameter to specify the scope of the hook.\n\nHowever, this method is apply to only a single hook, and may not be suitable for multiple hooks.\n\nEvery event listener will accept `as` parameter to specify the scope of the hook.\n\nGuard alllowing us to apply `schema` and `hook` to multiple routes all at once while specifying the scope.\n\nHowever, it doesn't support `derive` and `resolve` method.\n\n`as` will read all hooks and schema scope of the current instance, modify.\n\nSometimes we want to reapply plugin to parent instance as well but as it's limited by `scoped` mechanism, it's limited to 1 parent only.\n\nTo apply to the parent instance, we need to **lift the scope up** to the parent instance, and `as` is the perfect method to do so.\n\nWhich means if you have `local` scope, and want to apply it to the parent instance, you can use `as('scoped')` to lift it up.\n\nModules are eagerly loaded by default.\n\nElysia will make sure that all modules are registered before the server starts.\n\nHowever, some modules may be computationally heavy or blocking, making the server startup slow.\n\nTo solve this, Elysia allows you to provide an async plugin that will not block the server startup.\n\nThe deferred module is an async plugin that can be registered after the server is started.\n\nAnd in the main file:\n\nSame as the async plugin, the lazy-load module will be registered after the server is started.\n\nA lazy-load module can be both sync or async function, as long as the module is used with `import` the module will be lazy-loaded.\n\nUsing module lazy-loading is recommended when the module is computationally heavy and/or blocking.\n\nTo ensure module registration before the server starts, we can use `await` on the deferred module.\n\nIn a test environment, we can use `await app.modules` to wait for deferred and lazy-loading modules.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\nWe can use the plugin by passing an instance to **Elysia.use**.\n\nThe plugin will inherit all properties of the plugin instance like `state`, `decorate` but **WILL NOT inherit plugin [lifecycle](/essential/life-cycle)** as it's [isolated by default](#scope) (mentioned in the next section ↓).\n\nElysia will also handle the type inference automatically as well.\n\n::: tip\nIt's highly recommended that you have read [Key Concept: Dependency](/key-concept.html#dependency) before continuing.\n:::\n\n## Dependency&#x20;\n\nElysia by design, is compose of multiple mini Elysia apps which can run **independently** like a microservice that communicate with each other.\n\nEach Elysia instance is independent and **can run as a standalone server**.\n\nWhen an instance need to use another instance's service, you **must explicitly declare the dependency**.\n```\n\nExample 2 (unknown):\n```unknown\nThis is similar to **Dependency Injection** where each instance must declare its dependencies.\n\nThis approach force you to be explicit about dependencies allowing better tracking, modularity.\n\n### Deduplication&#x20;\n\nBy default, each plugin will be re-executed **every time** applying to another instance.\n\nTo prevent this, Elysia can deduplicate [lifecycle](/essential/life-cycle) with **an unique identifier** using `name` and optional `seed` property.\n```\n\nExample 3 (unknown):\n```unknown\nAdding the `name` and optional `seed` to the instance will make it a unique identifier prevent it from being called multiple times.\n\nLearn more about this in [plugin deduplication](/essential/plugin.html#plugin-deduplication).\n\n### Global vs Explicit Dependency\n\nThere are some case that global dependency make more sense than an explicit one.\n\n**Global** plugin example:\n\n* **Plugin that doesn't add types** - eg. cors, compress, helmet\n* Plugin that add global [lifecycle](/essential/life-cycle) that no instance should have control over - eg. tracing, logging\n\nExample use cases:\n\n* OpenAPI/Open - Global document\n* OpenTelemetry - Global tracer\n* Logging - Global logger\n\nIn case like this, it make more sense to create it as global dependency instead of applying it to every instance.\n\nHowever, if your dependency doesn't fit into these categories, it's recommended to use **explicit dependency** instead.\n\n**Explicit dependency** example:\n\n* **Plugin that add types** - eg. macro, state, model\n* Plugin that add business logic that instance can interact with - eg. Auth, Database\n\nExample use cases:\n\n* State management - eg. Store, Session\n* Data modeling - eg. ORM, ODM\n* Business logic - eg. Auth, Database\n* Feature module - eg. Chat, Notification\n\n## Scope &#x20;\n\nElysia [lifecycle](/essential/life-cycle) methods are **encapsulated** to its own instance only.\n\nWhich means if you create a new instance, it will not share the lifecycle methods with others.\n```\n\nExample 4 (unknown):\n```unknown\nIn this example, the `isSignIn` check will only apply to `profile` but not `app`.\n\n> Try changing the path in the URL bar to **/rename** and see the result\n\n**Elysia isolate [lifecycle](/essential/life-cycle) by default** unless explicitly stated. This is similar to **export** in JavaScript, where you need to export the function to make it available outside the module.\n\nTo **\"export\"** the lifecycle to other instances, you must add specify the scope.\n```\n\n---\n\n## Best Practice\n\n**URL:** https://elysiajs.com/essential/best-practice.md\n\n**Contents:**\n- Folder Structure\n- Controller\n  - 1. Elysia instance as a controller\n  - 2. Controller without HTTP request\n  - ❌ Don't: Pass entire `Context` to a controller\n  - Testing\n- Service\n  - 1. Abstract away Non-request dependent service\n  - 2. Request dependent service as Elysia instance\n  - ✅ Do: Decorate only request dependent property\n\n---\nurl: 'https://elysiajs.com/essential/best-practice.md'\n---\n\nElysia is a pattern-agnostic framework, leaving the decision of which coding patterns to use up to you and your team.\n\nHowever, there are several concerns when trying to adapt an MVC pattern [(Model-View-Controller)](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) with Elysia, and we found it hard to decouple and handle types.\n\nThis page is a guide on how to follow Elysia structure best practices combined with the MVC pattern, but it can be adapted to any coding pattern you prefer.\n\nElysia is unopinionated about folder structure, leaving you to **decide** how to organize your code yourself.\n\nHowever, **if you don't have a specific structure in mind**, we recommend a feature-based folder structure where each feature has its own folder containing controllers, services, and models.\n\nThis structure allows you to easily find and manage your code and keep related code together.\n\nHere's an example code of how to distribute your code into a feature-based folder structure:\n\nEach file has its own responsibility as follows:\n\n* **Controller**: Handle HTTP routing, request validation, and cookie.\n* **Service**: Handle business logic, decoupled from Elysia controller if possible.\n* **Model**: Define the data structure and validation for the request and response.\n\nFeel free to adapt this structure to your needs and use any coding pattern you prefer.\n\nDue to type soundness of Elysia, it's not recommended to use a traditional controller class that is tightly coupled with Elysia's `Context` because:\n\n1. **Elysia type is complex** and heavily depends on plugin and multiple level of chaining.\n2. **Hard to type**, Elysia type could change at anytime, especially with decorators, and store\n3. **Loss of type integrity**, and inconsistency between types and runtime code.\n\nWe recommended one of the following approach to implement a controller in Elysia.\n\n1. Use Elysia instance as a controller itself\n2. Create a controller that is not tied with HTTP request or Elysia.\n\n> 1 Elysia instance = 1 controller\n\nTreat an Elysia instance as a controller, and define your routes directly on the Elysia instance.\n\nThis approach allows Elysia to infer the `Context` type automatically, ensuring type integrity and consistency between types and runtime code.\n\nThis approach makes it hard to type `Context` properly, and may lead to loss of type integrity.\n\nIf you want to create a controller class, we recommend creating a class that is not tied to HTTP request or Elysia at all.\n\nThis approach allows you to decouple the controller from Elysia, making it easier to test, reuse, and even swap a framework while still follows the MVC pattern.\n\nTying the controller to Elysia Context may lead to:\n\n1. Loss of type integrity\n2. Make it harder to test and reuse\n3. Lead to vendor lock-in\n\nWe recommended to keep the controller decoupled from Elysia as much as possible.\n\n**Context is a highly dynamic type** that can be inferred from Elysia instance.\n\nDo not pass an entire `Context` to a controller, instead use object destructuring to extract what you need and pass it to the controller.\n\nThis approach makes it hard to type `Context` properly, and may lead to loss of type integrity.\n\nIf you're using Elysia as a controller, you can test your controller using `handle` to directly call a function (and it's lifecycle)\n\nYou may find more information about testing in [Unit Test](/patterns/unit-test.html).\n\nService is a set of utility/helper functions decoupled as a business logic to use in a module/controller, in our case, an Elysia instance.\n\nAny technical logic that can be decoupled from controller may live inside a **Service**.\n\nThere are 2 types of service in Elysia:\n\n1. Non-request dependent service\n2. Request dependent service\n\nWe recommend abstracting a service class/function away from Elysia.\n\nIf the service or function isn't tied to an HTTP request or doesn't access a `Context`, it's recommended to implement it as a static class or function.\n\nIf your service doesn't need to store a property, you may use `abstract class` and `static` instead to avoid allocating class instance.\n\n**If the service is a request-dependent service** or needs to process HTTP requests, we recommend abstracting it as an Elysia instance to ensure type integrity and inference:\n\n::: tip\nElysia handles [plugin deduplication](/essential/plugin.html#plugin-deduplication) by default, so you don't have to worry about performance, as it will be a singleton if you specify a **\"name\"** property.\n:::\n\nIt's recommended to `decorate` only request-dependent properties, such as `requestIP`, `requestTime`, or `session`.\n\nOverusing decorators may tie your code to Elysia, making it harder to test and reuse.\n\nModel or [DTO (Data Transfer Object)](https://en.wikipedia.org/wiki/Data_transfer_object) is handle by [Elysia.t (Validation)](/essential/validation.html#elysia-type).\n\nElysia has a validation system built-in which can infers type from your code and validate it at runtime.\n\nElysia strength is prioritizing a single source of truth for both type and runtime validation.\n\nInstead of declaring an interface, reuse validation's model instead:\n\nWe can get type of model by using `typeof` with `.static` property from the model.\n\nThen you can use the `CustomBody` type to infer the type of the request body.\n\nDo not declare a class instance as a model:\n\nDo not declare a type separate from the model, instead use `typeof` with `.static` property to get the type of the model.\n\nYou can group multiple models into a single object to make it more organized.\n\nThough this is optional, if you are strictly following MVC pattern, you may want to inject like a service into a controller. We recommended using [Elysia reference model](/essential/validation#reference-model)\n\nUsing Elysia's model reference\n\nThis approach provide several benefits:\n\n1. Allow us to name a model and provide auto-completion.\n2. Modify schema for later usage, or perform a [remap](/essential/handler.html#remap).\n3. Show up as \"models\" in OpenAPI compliance client, eg. OpenAPI.\n4. Improve TypeScript inference speed as model type will be cached during registration.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n| src\n  | modules\n\t| auth\n\t  | index.ts (Elysia controller)\n\t  | service.ts (service)\n\t  | model.ts (model)\n\t| user\n\t  | index.ts (Elysia controller)\n\t  | service.ts (service)\n\t  | model.ts (model)\n  | utils\n\t| a\n\t  | index.ts\n\t| b\n\t  | index.ts\n```\n\nExample 2 (unknown):\n```unknown\n:::\n\nEach file has its own responsibility as follows:\n\n* **Controller**: Handle HTTP routing, request validation, and cookie.\n* **Service**: Handle business logic, decoupled from Elysia controller if possible.\n* **Model**: Define the data structure and validation for the request and response.\n\nFeel free to adapt this structure to your needs and use any coding pattern you prefer.\n\n## Controller\n\nDue to type soundness of Elysia, it's not recommended to use a traditional controller class that is tightly coupled with Elysia's `Context` because:\n\n1. **Elysia type is complex** and heavily depends on plugin and multiple level of chaining.\n2. **Hard to type**, Elysia type could change at anytime, especially with decorators, and store\n3. **Loss of type integrity**, and inconsistency between types and runtime code.\n\nWe recommended one of the following approach to implement a controller in Elysia.\n\n1. Use Elysia instance as a controller itself\n2. Create a controller that is not tied with HTTP request or Elysia.\n\n***\n\n### 1. Elysia instance as a controller\n\n> 1 Elysia instance = 1 controller\n\nTreat an Elysia instance as a controller, and define your routes directly on the Elysia instance.\n```\n\nExample 3 (unknown):\n```unknown\nThis approach allows Elysia to infer the `Context` type automatically, ensuring type integrity and consistency between types and runtime code.\n```\n\nExample 4 (unknown):\n```unknown\nThis approach makes it hard to type `Context` properly, and may lead to loss of type integrity.\n\n### 2. Controller without HTTP request\n\nIf you want to create a controller class, we recommend creating a class that is not tied to HTTP request or Elysia at all.\n\nThis approach allows you to decouple the controller from Elysia, making it easier to test, reuse, and even swap a framework while still follows the MVC pattern.\n```\n\n---\n\n## Handler&#x20;\n\n**URL:** https://elysiajs.com/essential/handler.md\n\n**Contents:**\n- Context\n    - Property\n    - Utility Function\n    - Additional Property\n- status&#x20;\n- Set\n  - set.headers\n- Cookie\n- Redirect\n- Formdata\n\n---\nurl: 'https://elysiajs.com/essential/handler.md'\n---\n\n**Handler** - a function that accept an HTTP request, and return a response.\n\nA handler may be a literal value, and can be inlined.\n\nUsing an **inline value** always returns the same value which is useful to optimize performance for static resources like files.\n\nThis allows Elysia to compile the response ahead of time to optimize performance.\n\n::: tip\nProviding an inline value is not a cache.\n\nStatic resource values, headers and status can be mutated dynamically using lifecycle.\n:::\n\n**Context** contains request information which is unique for each request, and is not shared except for `store` (global mutable state).\n\n**Context** can only be retrieved in a route handler. It consists of:\n\n* [**body**](/essential/validation.html#body) - [HTTP message](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages), form or file upload.\n* [**query**](/essential/validation.html#query) - [Query String](https://en.wikipedia.org/wiki/Query_string), include additional parameters for search query as JavaScript Object. (Query is extracted from a value after pathname starting from '?' question mark sign)\n* [**params**](/essential/validation.html#params) - Elysia's path parameters parsed as JavaScript object\n* [**headers**](/essential/validation.html#headers) - [HTTP Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers), additional information about the request like User-Agent, Content-Type, Cache Hint.\n* [**cookie**](#cookie) - A global mutable signal store for interacting with Cookie (including get/set)\n* [**store**](#state) - A global mutable store for Elysia instance\n\n* [**redirect**](#redirect) - A function to redirect a response\n* [**status**](#status) - A function to return custom status code\n* [**set**](#set) - Property to apply to Response:\n  * [**headers**](#set.headers) - Response headers\n\n* [**request**](#request) - [Web Standard Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n* [**server**](#server-bun-only) - Bun server instance\n* **path** - Pathname of the request\n\nA function to return a custom status code with type narrowing.\n\nIt's recommended use **never-throw** approach to return **status** instead of throw as it:\n\n* allows TypeScript to check if a return value is correctly type to response schema\n* autocompletion for type narrowing based on status code\n* type narrowing for error handling using End-to-end type safety ([Eden](/eden/overview))\n\n**set** is a mutable property that form a response accessible via `Context.set`.\n\nAllowing us to append or delete response headers represented as an Object.\n\n::: tip\nElysia provide an auto-completion for lowercase for case-sensitivity consistency, eg. use `set-cookie` rather than `Set-Cookie`.\n:::\n\nRedirect a request to another resource.\n\nWhen using redirect, returned value is not required and will be ignored. As response will be from another resource.\n\nSet a default status code if not provided.\n\nIt's recommended to use this in a plugin that only needs to return a specific status code while allowing the user to return a custom value. For example, HTTP 201/206 or 403/405, etc.\n\nUnlike `status` function, `set.status` cannot infer the return value type, therefore it can't check if the return value is correctly type to response schema.\n\n::: tip\nHTTP Status indicates the type of response. If the route handler is executed successfully without error, Elysia will return the status code 200.\n:::\n\nYou can also set a status code using the common name of the status code instead of using a number.\n\nElysia provides a mutable signal for interacting with Cookie.\n\nThere's no get/set, you can extract the cookie name and retrieve or update its value directly.\n\nSee [Patterns: Cookie](/essentials/cookie) for more information.\n\nRedirect a request to another resource.\n\nWhen using redirect, returned value is not required and will be ignored. As response will be from another resource.\n\nWe may return a `FormData` by using returning `form` utility directly from the handler.\n\nThis pattern is useful if even need to return a file or multipart form data.\n\nOr alternatively, you can return a single file by returning `file` directly without `form`.\n\nTo return a response streaming out of the box by using a generator function with `yield` keyword.\n\nThis this example, we may stream a response by using `yield` keyword.\n\nElysia supports [Server Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) by providing a `sse` utility function.\n\nWhen a value is wrapped in `sse`, Elysia will automatically set the response headers to `text/event-stream` and format the data as an SSE event.\n\nHeaders can only be set before the first chunk is yielded.\n\nOnce the first chunk is yielded, Elysia will send the headers to the client, therefore mutating headers after the first chunk is yielded will do nothing.\n\nIf the response is returned without yield, Elysia will automatically convert stream to normal response instead.\n\nThis allows us to conditionally stream a response or return a normal response if necessary.\n\nBefore response streaming is completed, if the user cancels the request, Elysia will automatically stop the generator function.\n\n[Eden](/eden/overview) will interpret a stream response as `AsyncGenerator` allowing us to use `for await` loop to consume the stream.\n\nElysia is built on top of [Web Standard Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) which is shared between multiple runtime like Node, Bun, Deno, Cloudflare Worker, Vercel Edge Function, and more.\n\nAllowing you to access low-level request information if necessary.\n\nServer instance is a Bun server instance, allowing us to access server information like port number or request IP.\n\nServer will only be available when HTTP server is running with `listen`.\n\nWe can get request IP by using `server.requestIP` method\n\nElysia provides a minimal Context by default, allowing us to extend Context for our specific need using state, decorate, derive, and resolve.\n\nSee [Extends Context](/patterns/extends-context) for more information on how to extend a Context.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    // the function `() => 'hello world'` is a handler\n    .get('/', () => 'hello world')\n    .listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n    .get('/', 'Hello Elysia')\n    .get('/video', file('kyuukurarin.mp4'))\n    .listen(3000)\n```\n\nExample 3 (unknown):\n```unknown\n**Context** can only be retrieved in a route handler. It consists of:\n\n#### Property\n\n* [**body**](/essential/validation.html#body) - [HTTP message](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages), form or file upload.\n* [**query**](/essential/validation.html#query) - [Query String](https://en.wikipedia.org/wiki/Query_string), include additional parameters for search query as JavaScript Object. (Query is extracted from a value after pathname starting from '?' question mark sign)\n* [**params**](/essential/validation.html#params) - Elysia's path parameters parsed as JavaScript object\n* [**headers**](/essential/validation.html#headers) - [HTTP Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers), additional information about the request like User-Agent, Content-Type, Cache Hint.\n* [**cookie**](#cookie) - A global mutable signal store for interacting with Cookie (including get/set)\n* [**store**](#state) - A global mutable store for Elysia instance\n\n#### Utility Function\n\n* [**redirect**](#redirect) - A function to redirect a response\n* [**status**](#status) - A function to return custom status code\n* [**set**](#set) - Property to apply to Response:\n  * [**headers**](#set.headers) - Response headers\n\n#### Additional Property\n\n* [**request**](#request) - [Web Standard Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n* [**server**](#server-bun-only) - Bun server instance\n* **path** - Pathname of the request\n\n## status&#x20;\n\nA function to return a custom status code with type narrowing.\n```\n\nExample 4 (unknown):\n```unknown\nIt's recommended use **never-throw** approach to return **status** instead of throw as it:\n\n* allows TypeScript to check if a return value is correctly type to response schema\n* autocompletion for type narrowing based on status code\n* type narrowing for error handling using End-to-end type safety ([Eden](/eden/overview))\n\n## Set\n\n**set** is a mutable property that form a response accessible via `Context.set`.\n```\n\n---\n",
        "plugins/coding/elysia/skills/elysia/references/index.md": "# Elysia Documentation Index\n\n## Categories\n\n### Eden\n**File:** `eden.md`\n**Pages:** 11\n\n### Essential\n**File:** `essential.md`\n**Pages:** 6\n\n### Integrations\n**File:** `integrations.md`\n**Pages:** 17\n\n### Other\n**File:** `other.md`\n**Pages:** 10\n\n### Patterns\n**File:** `patterns.md`\n**Pages:** 21\n\n### Plugins\n**File:** `plugins.md`\n**Pages:** 13\n\n### Tutorial\n**File:** `tutorial.md`\n**Pages:** 14\n",
        "plugins/coding/elysia/skills/elysia/references/integrations.md": "# Elysia - Integrations\n\n**Pages:** 17\n\n---\n\n## Drizzle\n\n**URL:** https://elysiajs.com/integrations/drizzle.md\n\n**Contents:**\n  - Drizzle Typebox\n  - Here's how it works:\n- Installation\n- Drizzle schema\n- drizzle-typebox\n- Type instantiation is possibly infinite\n- Utility\n  - Table Singleton\n  - Refinement\n\n---\nurl: 'https://elysiajs.com/integrations/drizzle.md'\n---\n\nDrizzle ORM is a headless TypeScript ORM with a focus on type safety and developer experience.\n\nWe may convert Drizzle schema to Elysia validation models using `drizzle-typebox`\n\n[Elysia.t](/essential/validation.html#elysia-type) is a fork of TypeBox, allowing us to use any TypeBox type in Elysia directly.\n\nWe can convert Drizzle schema into TypeBox schema using [\"drizzle-typebox\"](https://npmjs.org/package/drizzle-typebox), and use it directly on Elysia's schema validation.\n\n1. Define your database schema in Drizzle.\n2. Convert Drizzle schema into Elysia validation models using `drizzle-typebox`.\n3. Use the converted Elysia validation models to ensure type validation.\n4. OpenAPI schema is generated from Elysia validation models.\n5. Add [Eden Treaty](/eden/overview) to add type-safety to your frontend.\n\nTo install Drizzle, run the following command:\n\nThen you need to pin `@sinclair/typebox` as there might be a mismatch version between `drizzle-typebox` and `Elysia`, this may cause conflict of Symbols between two versions.\n\nWe recommend pinning the version of `@sinclair/typebox` to the **minimum version** used by `elysia` by using:\n\nWe may use `overrides` field in `package.json` to pin the version of `@sinclair/typebox`:\n\nAssuming we have a `user` table in our codebase as follows:\n\nWe may convert the `user` table into TypeBox models by using `drizzle-typebox`:\n\nThis allows us to reuse the database schema in Elysia validation models\n\nIf you got an error like **Type instantiation is possibly infinite** this is because of the circular reference between `drizzle-typebox` and `Elysia`.\n\nIf we nested a type from drizzle-typebox into Elysia schema, it will cause an infinite loop of type instantiation.\n\nTo prevent this, we need to **explicitly define a type between `drizzle-typebox` and `Elysia`** schema:\n\nAlways declare a variable for `drizzle-typebox` and reference it if you want to use Elysia type\n\nAs we are likely going to use `t.Pick` and `t.Omit` to exclude or include certain fields, it may be cumbersome to repeat the process:\n\nWe recommend using these utility functions **(copy as-is)** to simplify the process:\n\nThis utility function will convert Drizzle schema into a plain object, which can pick by property name as plain object:\n\nWe recommend using a singleton pattern to store the table schema, this will allow us to access the table schema from anywhere in the codebase:\n\nThis will allow us to access the table schema from anywhere in the codebase:\n\nIf type refinement is needed, you may use `createInsertSchema` and `createSelectSchema` to refine the schema directly.\n\nIn the code above, we refine a `user.email` schema to include a `format` property\n\nThe `spread` utility function will skip a refined schema, so you can use it as is.\n\nFor more information, please refer to the [Drizzle ORM](https://orm.drizzle.team) and [Drizzle TypeBox](https://orm.drizzle.team/docs/typebox) documentation.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n* ——————————————— *\n                                                    |                 |\n                                               | -> |  Documentation  |\n* ————————— *             * ———————— * OpenAPI |    |                 |\n|           |   drizzle-  |          | ——————— |    * ——————————————— *\n|  Drizzle  | —————————-> |  Elysia  |\n|           |  -typebox   |          | ——————— |    * ——————————————— *\n* ————————— *             * ———————— *   Eden  |    |                 |\n                                               | -> |  Frontend Code  |\n\t\t\t\t\t\t\t\t\t\t\t\t    |                 |\n\t\t\t\t\t\t\t\t\t\t\t\t    * ——————————————— *\n```\n\nExample 2 (bash):\n```bash\nbun add drizzle-orm drizzle-typebox\n```\n\nExample 3 (bash):\n```bash\ngrep \"@sinclair/typebox\" node_modules/elysia/package.json\n```\n\nExample 4 (json):\n```json\n{\n  \"overrides\": {\n  \t\"@sinclair/typebox\": \"0.32.4\"\n  }\n}\n```\n\n---\n\n## Integration with Expo\n\n**URL:** https://elysiajs.com/integrations/expo.md\n\n**Contents:**\n  - pnpm\n- Prefix\n- Eden\n- Deployment\n\n---\nurl: 'https://elysiajs.com/integrations/expo.md'\n---\n\nStarting from Expo SDK 50, and App Router v3, Expo allows us to create API route directly in an Expo app.\n\n1. Create **app/\\[...slugs]+api.ts**\n2. Define an Elysia server\n3. Export **Elysia.fetch** name of HTTP methods you want to use\n\nYou can treat the Elysia server as if normal Expo API route.\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nIf you place an Elysia server not in the root directory of the app router, you need to annotate the prefix to the Elysia server.\n\nFor example, if you place Elysia server in **app/api/\\[...slugs]+api.ts**, you need to annotate prefix as **/api** to Elysia server.\n\nThis will ensure that Elysia routing will work properly in any location you place it in.\n\nWe can add [Eden](/eden/overview) for **end-to-end type safety** similar to tRPC.\n\n1. Export `type` from the Elysia server\n\n2. Create a Treaty client\n\n3. Use the client in both server and client components\n\nYou can either directly use API route using Elysia and deploy as normal Elysia app normally if need or using [experimental Expo server runtime](https://docs.expo.dev/router/reference/api-routes/#deployment).\n\nIf you are using Expo server runtime, you may use `expo export` command to create optimized build for your expo app, this will include an Expo function which is using Elysia at **dist/server/\\_expo/functions/\\[...slugs]+api.js**\n\n::: tip\nPlease note that Expo Functions are treated as Edge functions instead of normal server, so running the Edge function directly will not allocate any port.\n:::\n\nYou may use the Expo function adapter provided by Expo to deploy your Edge Function.\n\nCurrently Expo support the following adapter:\n\n* [Express](https://docs.expo.dev/router/reference/api-routes/#express)\n* [Netlify](https://docs.expo.dev/router/reference/api-routes/#netlify)\n* [Vercel](https://docs.expo.dev/router/reference/api-routes/#vercel)\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\nYou can treat the Elysia server as if normal Expo API route.\n\n### pnpm\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n```\n\nExample 2 (unknown):\n```unknown\n## Prefix\n\nIf you place an Elysia server not in the root directory of the app router, you need to annotate the prefix to the Elysia server.\n\nFor example, if you place Elysia server in **app/api/\\[...slugs]+api.ts**, you need to annotate prefix as **/api** to Elysia server.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\nThis will ensure that Elysia routing will work properly in any location you place it in.\n\n## Eden\n\nWe can add [Eden](/eden/overview) for **end-to-end type safety** similar to tRPC.\n\n1. Export `type` from the Elysia server\n\n::: code-group\n```\n\nExample 4 (unknown):\n```unknown\n:::\n\n2. Create a Treaty client\n\n::: code-group\n```\n\n---\n\n## Integration with AI SDK\n\n**URL:** https://elysiajs.com/integrations/ai-sdk.md\n\n**Contents:**\n- Response Streaming\n- Server Sent Event\n- As Response\n- Manual Streaming\n- Fetch\n\n---\nurl: 'https://elysiajs.com/integrations/ai-sdk.md'\n---\n\nElysia provides a support for response streaming with ease, allowing you to integrate with [Vercel AI SDKs](https://vercel.com/docs/ai) seamlessly.\n\nElysia support continous streaming of a `ReadableStream` and `Response` allowing you to return stream directly from the AI SDKs.\n\nElysia will handle the stream automatically, allowing you to use it in various ways.\n\nElysia also supports Server Sent Event for streaming response by simply wrap a `ReadableStream` with `sse` function.\n\nIf you don't need a type-safety of the stream for further usage with [Eden](/eden/overview), you can return the stream directly as a response.\n\nIf you want to have more control over the streaming, you can use a generator function to yield the chunks manually.\n\nIf AI SDK doesn't support model you're using, you can still use the `fetch` function to make requests to the AI SDKs and stream the response directly.\n\nElysia will proxy fetch response with streaming support automatically.\n\nFor additional information, please refer to [AI SDK documentation](https://ai-sdk.dev/docs/introduction)\n\n**Examples:**\n\nExample 1 (ts):\n```ts\nimport { Elysia } from 'elysia'\nimport { streamText } from 'ai'\nimport { openai } from '@ai-sdk/openai'\n\nnew Elysia().get('/', () => {\n    const stream = streamText({\n        model: openai('gpt-5'),\n        system: 'You are Yae Miko from Genshin Impact',\n        prompt: 'Hi! How are you doing?'\n    })\n\n    // Just return a ReadableStream\n    return stream.textStream // [!code ++]\n\n    // UI Message Stream is also supported\n    return stream.toUIMessageStream() // [!code ++]\n})\n```\n\nExample 2 (ts):\n```ts\nimport { Elysia, sse } from 'elysia' // [!code ++]\nimport { streamText } from 'ai'\nimport { openai } from '@ai-sdk/openai'\n\nnew Elysia().get('/', () => {\n    const stream = streamText({\n        model: openai('gpt-5'),\n        system: 'You are Yae Miko from Genshin Impact',\n        prompt: 'Hi! How are you doing?'\n    })\n\n    // Each chunk will be sent as a Server Sent Event\n    return sse(stream.textStream) // [!code ++]\n\n    // UI Message Stream is also supported\n    return sse(stream.toUIMessageStream()) // [!code ++]\n})\n```\n\nExample 3 (ts):\n```ts\nimport { Elysia } from 'elysia'\nimport { ai } from 'ai'\nimport { openai } from '@ai-sdk/openai'\n\nnew Elysia().get('/', () => {\n    const stream = streamText({\n        model: openai('gpt-5'),\n        system: 'You are Yae Miko from Genshin Impact',\n        prompt: 'Hi! How are you doing?'\n    })\n\n    return stream.toTextStreamResponse() // [!code ++]\n\n    // UI Message Stream Response will use SSE\n    return stream.toUIMessageStreamResponse() // [!code ++]\n})\n```\n\nExample 4 (ts):\n```ts\nimport { Elysia, sse } from 'elysia'\nimport { ai } from 'ai'\nimport { openai } from '@ai-sdk/openai'\n\nnew Elysia().get('/', async function* () {\n    const stream = streamText({\n        model: openai('gpt-5'),\n        system: 'You are Yae Miko from Genshin Impact',\n        prompt: 'Hi! How are you doing?'\n    })\n\n    for await (const data of stream.textStream) // [!code ++]\n        yield sse({ // [!code ++]\n            data, // [!code ++]\n            event: 'message' // [!code ++]\n        }) // [!code ++]\n\n    yield sse({\n        event: 'done'\n    })\n})\n```\n\n---\n\n## Integration with Nuxt\n\n**URL:** https://elysiajs.com/integrations/nuxt.md\n\n**Contents:**\n  - pnpm\n- Prefix\n\n---\nurl: 'https://elysiajs.com/integrations/nuxt.md'\n---\n\nWe can use [nuxt-elysia](https://github.com/tkesgar/nuxt-elysia), a community plugin for Nuxt, to setup Elysia on Nuxt API route with Eden Treaty.\n\n1. Install the plugin with the following command:\n\n2. Add `nuxt-elysia` to your Nuxt config:\n\n3. Create `api.ts` in the project root:\n\n4. Use Eden Treaty in your Nuxt app:\n\nThis will automatically setup Elysia to run on Nuxt API route automatically.\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nBy default, Elysia will be mounted on **/\\_api** but we can customize it with `nuxt-elysia` config.\n\nThis will mount Elysia on **/api** instead of **/\\_api**.\n\nFor more configuration, please refer to [nuxt-elysia](https://github.com/tkesgar/nuxt-elysia)\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add elysia @elysiajs/eden\nbun add -d nuxt-elysia\n```\n\nExample 2 (ts):\n```ts\nexport default defineNuxtConfig({\n    modules: [ // [!code ++]\n        'nuxt-elysia' // [!code ++]\n    ] // [!code ++]\n})\n```\n\nExample 3 (unknown):\n```unknown\n4. Use Eden Treaty in your Nuxt app:\n```\n\nExample 4 (unknown):\n```unknown\nThis will automatically setup Elysia to run on Nuxt API route automatically.\n\n### pnpm\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n```\n\n---\n\n## Integration with Astro\n\n**URL:** https://elysiajs.com/integrations/astro.md\n\n**Contents:**\n  - pnpm\n- Prefix\n\n---\nurl: 'https://elysiajs.com/integrations/astro.md'\n---\n\nWith [Astro Endpoint](https://docs.astro.build/en/core-concepts/endpoints/), we can run Elysia on Astro directly.\n\n1. Set **output** to **server** in **astro.config.mjs**\n\n2. Create **pages/\\[...slugs].ts**\n3. Create or import an existing Elysia server in **\\[...slugs].ts**\n4. Export the handler with the name of method you want to expose\n\nElysia will work normally as expected because of WinterCG compliance.\n\nWe recommend running [Astro on Bun](https://docs.astro.build/en/recipes/bun) as Elysia is designed to be run on Bun.\n\n::: tip\nYou can run Elysia server without running Astro on Bun thanks to WinterCG support.\n:::\n\nWith this approach, you can have co-location of both frontend and backend in a single repository and have End-to-end type-safety with Eden.\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nIf you place an Elysia server not in the root directory of the app router, you need to annotate the prefix to the Elysia server.\n\nFor example, if you place Elysia server in **pages/api/\\[...slugs].ts**, you need to annotate prefix as **/api** to Elysia server.\n\nThis will ensure that Elysia routing will work properly in any location you place it.\n\nPlease refer to [Astro Endpoint](https://docs.astro.build/en/core-concepts/endpoints/) for more information.\n\n**Examples:**\n\nExample 1 (javascript):\n```javascript\n// astro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n// https://astro.build/config\nexport default defineConfig({\n    output: 'server' // [!code ++]\n})\n```\n\nExample 2 (typescript):\n```typescript\n// pages/[...slugs].ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/api', () => 'hi')\n    .post('/api', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nconst handle = ({ request }: { request: Request }) => app.handle(request) // [!code ++]\n\nexport const GET = handle // [!code ++]\nexport const POST = handle // [!code ++]\n```\n\nExample 3 (bash):\n```bash\npnpm add @sinclair/typebox openapi-types\n```\n\nExample 4 (typescript):\n```typescript\n// pages/api/[...slugs].ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia({ prefix: '/api' }) // [!code ++]\n    .get('/', () => 'hi')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nconst handle = ({ request }: { request: Request }) => app.handle(request) // [!code ++]\n\nexport const GET = handle // [!code ++]\nexport const POST = handle // [!code ++]\n```\n\n---\n\n## Integration with SvelteKit\n\n**URL:** https://elysiajs.com/integrations/sveltekit.md\n\n**Contents:**\n  - pnpm\n- Prefix\n\n---\nurl: 'https://elysiajs.com/integrations/sveltekit.md'\n---\n\nWith SvelteKit, you can run Elysia on server routes.\n\n1. Create **src/routes/\\[...slugs]/+server.ts**.\n2. Define an Elysia server.\n3. Export a **fallback** function that calls `app.handle`.\n\nYou can treat the Elysia server as a normal SvelteKit server route.\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nIf you place an Elysia server not in the root directory of the app router, you need to annotate the prefix to the Elysia server.\n\nFor example, if you place Elysia server in **src/routes/api/\\[...slugs]/+server.ts**, you need to annotate prefix as **/api** to Elysia server.\n\nThis will ensure that Elysia routing will work properly in any location you place it.\n\nPlease refer to [SvelteKit Routing](https://kit.svelte.dev/docs/routing#server) for more information.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\n// src/routes/[...slugs]/+server.ts\nimport { Elysia, t } from 'elysia';\n\nconst app = new Elysia()\n    .get('/', 'hello SvelteKit')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\ninterface WithRequest {\n\trequest: Request\n}\n\nexport const fallback = ({ request }: WithRequest) => app.handle(request) // [!code ++]\n```\n\nExample 2 (bash):\n```bash\npnpm add @sinclair/typebox openapi-types\n```\n\n---\n\n## Integration with Netlify Edge Function\n\n**URL:** https://elysiajs.com/integrations/netlify.md\n\n**Contents:**\n  - Running locally\n  - pnpm\n\n---\nurl: 'https://elysiajs.com/integrations/netlify.md'\n---\n\n[Netlify Edge Function](https://docs.netlify.com/build/edge-functions/overview/) is run on [Deno](/integrations/deno) which is one of Elysia support runtime, as Elysia is built on top of Web Standard.\n\nNetlify Edge Functions requires a special directory to run a function, the default is **\\<directory>/netlify/edge-functions**.\n\nTo create a function at **/hello**, you would need to create file at `netlify/edge-functions/hello.ts`, then simply `export default` an Elysia instance.\n\nTo test your Elysia server on Netlify Edge Function locally, you can install [Netlify CLI](https://docs.netlify.com/build/edge-functions/get-started/#test-locally) to simluate function invokation.\n\nTo install Netlify CLI:\n\nTo run the development environment:\n\nFor an additional information, please refers to [Netlify Edge Function documentation](https://docs.netlify.com/build/edge-functions).\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\n### Running locally\n\nTo test your Elysia server on Netlify Edge Function locally, you can install [Netlify CLI](https://docs.netlify.com/build/edge-functions/get-started/#test-locally) to simluate function invokation.\n\nTo install Netlify CLI:\n```\n\nExample 2 (unknown):\n```unknown\nTo run the development environment:\n```\n\nExample 3 (unknown):\n```unknown\nFor an additional information, please refers to [Netlify Edge Function documentation](https://docs.netlify.com/build/edge-functions).\n\n### pnpm\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n```\n\n---\n\n## Better Auth\n\n**URL:** https://elysiajs.com/integrations/better-auth.md\n\n**Contents:**\n- Handler\n  - Custom endpoint\n- OpenAPI\n- CORS\n- Macro\n\n---\nurl: 'https://elysiajs.com/integrations/better-auth.md'\n---\n\nBetter Auth is framework-agnostic authentication (and authorization) framework for TypeScript.\n\nIt provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.\n\nWe recommend going through the [Better Auth basic setup](https://www.better-auth.com/docs/installation) before going through this page.\n\nOur basic setup will look like this:\n\nAfter setting up Better Auth instance, we can mount to Elysia via [mount](/patterns/mount.html).\n\nWe need to mount the handler to Elysia endpoint.\n\nThen we can access Better Auth with `http://localhost:3000/api/auth`.\n\nWe recommend setting a prefix path when using [mount](/patterns/mount.html).\n\nThen we can access Better Auth with `http://localhost:3000/auth/api/auth`.\n\nBut the URL looks redundant, we can customize the `/api/auth` prefix to something else in Better Auth instance.\n\nThen we can access Better Auth with `http://localhost:3000/auth/api`.\n\nUnfortunately, we can't set `basePath` of a Better Auth instance to be empty or `/`.\n\nBetter Auth support `openapi` with `better-auth/plugins`.\n\nHowever if we are using [@elysiajs/openapi](/plugins/openapi), you might want to extract the documentation from Better Auth instance.\n\nWe may do that with the following code:\n\nThen in our Elysia instance that use `@elysiajs/openapi`.\n\nTo configure cors, you can use the `cors` plugin from `@elysiajs/cors`.\n\nYou can use [macro](https://elysiajs.com/patterns/macro.html#macro) with [resolve](https://elysiajs.com/essential/handler.html#resolve) to provide session and user information before pass to view.\n\nThis will allow you to access the `user` and `session` object in all of your routes.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n## Handler\n\nAfter setting up Better Auth instance, we can mount to Elysia via [mount](/patterns/mount.html).\n\nWe need to mount the handler to Elysia endpoint.\n```\n\nExample 2 (unknown):\n```unknown\nThen we can access Better Auth with `http://localhost:3000/api/auth`.\n\n### Custom endpoint\n\nWe recommend setting a prefix path when using [mount](/patterns/mount.html).\n```\n\nExample 3 (unknown):\n```unknown\nThen we can access Better Auth with `http://localhost:3000/auth/api/auth`.\n\nBut the URL looks redundant, we can customize the `/api/auth` prefix to something else in Better Auth instance.\n```\n\nExample 4 (unknown):\n```unknown\nThen we can access Better Auth with `http://localhost:3000/auth/api`.\n\nUnfortunately, we can't set `basePath` of a Better Auth instance to be empty or `/`.\n\n## OpenAPI\n\nBetter Auth support `openapi` with `better-auth/plugins`.\n\nHowever if we are using [@elysiajs/openapi](/plugins/openapi), you might want to extract the documentation from Better Auth instance.\n\nWe may do that with the following code:\n```\n\n---\n\n## Integration with Node.js\n\n**URL:** https://elysiajs.com/integrations/node.md\n\n**Contents:**\n  - Additional Setup (optional)\n  - pnpm\n\n---\nurl: 'https://elysiajs.com/integrations/node.md'\n---\n\nElysia provide a runtime adapter to run Elysia on multiple runtime, including Node.js.\n\nTo run Elysia on Node.js, simply install Node adapter.\n\nThen apply node adapter to your main Elysia instance.\n\nThis is all you need to run Elysia on Node.js.\n\nFor the best experience, we recommended installing `tsx` or `ts-node` with `nodemon`.\n\n`tsx` is a CLI that transpiles TypeScript to JavaScript with hot-reload and several more feature you expected from a modern development environment.\n\nThen open your `package.json` file and add the following scripts:\n\nThese scripts refer to the different stages of developing an application:\n\n* **dev** - Start Elysia in development mode with auto-reload on code change.\n* **build** - Build the application for production usage.\n* **start** - Start an Elysia production server.\n\nMake sure to create `tsconfig.json`\n\nDon't forget to update `tsconfig.json` to include `compilerOptions.strict` to `true`:\n\nThis will give the hot reload, JSX support to run Elysia with the similar experience as `bun dev`\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\nThen apply node adapter to your main Elysia instance.\n```\n\nExample 2 (unknown):\n```unknown\nThis is all you need to run Elysia on Node.js.\n\n### Additional Setup (optional)\n\nFor the best experience, we recommended installing `tsx` or `ts-node` with `nodemon`.\n\n`tsx` is a CLI that transpiles TypeScript to JavaScript with hot-reload and several more feature you expected from a modern development environment.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\nThen open your `package.json` file and add the following scripts:\n```\n\nExample 4 (unknown):\n```unknown\nThese scripts refer to the different stages of developing an application:\n\n* **dev** - Start Elysia in development mode with auto-reload on code change.\n* **build** - Build the application for production usage.\n* **start** - Start an Elysia production server.\n\nMake sure to create `tsconfig.json`\n```\n\n---\n\n## Integration with Tanstack Start\n\n**URL:** https://elysiajs.com/integrations/tanstack-start.md\n\n**Contents:**\n  - pnpm\n- Eden\n- Loader Data\n- React Query\n\n---\nurl: 'https://elysiajs.com/integrations/tanstack-start.md'\n---\n\nElysia can runs inside Tanstack Start server routes.\n\n1. Create **src/routes/api.$.ts**\n2. Define an Elysia server\n3. Export Elysia handler in **server.handlers**\n\nElysia should now be running on **/api**.\n\nWe may add additional methods to **server.handlers** to support other HTTP methods as need.\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nWe can add [Eden](/eden/overview.html) for **end-to-end type safety** similar to tRPC.\n\nNotice that we use **createIsomorphicFn** to create a separate Eden Treaty instance for both server and client.\n\n1. On server, Elysia is called directly without HTTP overhead.\n2. On client, we call Elysia server through HTTP.\n\nOn React component, we can use `getTreaty` to call Elysia server with type safety.\n\nTanstack Start support **Loader** to fetch data before rendering the component.\n\nCalling Elysia is a loader will be executed on server side during SSR, and doesn't have HTTP overhead.\n\nEden Treaty will ensure type safety on both server and client.\n\nWe can also use React Query to interact with Elysia server on client.\n\nThis can works with any React Query features like caching, pagination, infinite query, etc.\n\nPlease visit [Tanstack Start Documentation](https://tanstack.com/start) for more information about Tanstack Start.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\nElysia should now be running on **/api**.\n\nWe may add additional methods to **server.handlers** to support other HTTP methods as need.\n\n### pnpm\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n```\n\nExample 2 (unknown):\n```unknown\n## Eden\n\nWe can add [Eden](/eden/overview.html) for **end-to-end type safety** similar to tRPC.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\nNotice that we use **createIsomorphicFn** to create a separate Eden Treaty instance for both server and client.\n\n1. On server, Elysia is called directly without HTTP overhead.\n2. On client, we call Elysia server through HTTP.\n\nOn React component, we can use `getTreaty` to call Elysia server with type safety.\n\n## Loader Data\n\nTanstack Start support **Loader** to fetch data before rendering the component.\n\n::: code-group\n```\n\nExample 4 (unknown):\n```unknown\n:::\n\nCalling Elysia is a loader will be executed on server side during SSR, and doesn't have HTTP overhead.\n\nEden Treaty will ensure type safety on both server and client.\n\n## React Query\n\nWe can also use React Query to interact with Elysia server on client.\n\n::: code-group\n```\n\n---\n\n## React Email\n\n**URL:** https://elysiajs.com/integrations/react-email.md\n\n**Contents:**\n- Installation\n  - TypeScript\n- Your first email\n- Preview your email\n- Sending email\n\n---\nurl: 'https://elysiajs.com/integrations/react-email.md'\n---\n\nReact Email is a library that allows you to use React components to create emails.\n\nAs Elysia is using Bun as runtime environment, we can directly write a React Email component and import the JSX directly to our code to send emails.\n\nTo install React Email, run the following command:\n\nThen add this script to `package.json`:\n\nWe recommend adding email templates into the `src/emails` directory as we can directly import the JSX files.\n\nIf you are using TypeScript, you may need to add the following to your `tsconfig.json`:\n\nCreate file `src/emails/otp.tsx` with the following code:\n\nYou may notice that we are using `@react-email/components` to create the email template.\n\nThis library provides a set of components including **styling with Tailwind** that are compatible with email clients like Gmail, Outlook, etc.\n\nWe also added a `PreviewProps` to the `OTPEmail` function. This is only apply when previewing the email on our playground.\n\nTo preview your email, run the following command:\n\nThis will open a browser window with the preview of your email.\n\n![React Email playground showing an OTP email we have just written](/recipe/react-email/email-preview.webp)\n\nTo send an email, we can use `react-dom/server` to render the the email then submit using a preferred provider:\n\n::: tip\nNotice that we can directly import the email component out of the box thanks to Bun\n:::\n\nYou may see all of the available integration with React Email in the [React Email Integration](https://react.email/docs/integrations/overview), and learn more about React Email in [React Email documentation](https://react.email/docs)\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add -d react-email\nbun add @react-email/components react react-dom\n```\n\nExample 2 (json):\n```json\n{\n  \"scripts\": {\n    \"email\": \"email dev --dir src/emails\"\n  }\n}\n```\n\nExample 3 (json):\n```json\n{\n  \"compilerOptions\": {\n\t\"jsx\": \"react\"\n  }\n}\n```\n\nExample 4 (tsx):\n```tsx\nimport * as React from 'react'\nimport { Tailwind, Section, Text } from '@react-email/components'\n\nexport default function OTPEmail({ otp }: { otp: number }) {\n    return (\n        <Tailwind>\n            <Section className=\"flex justify-center items-center w-full min-h-screen font-sans\">\n                <Section className=\"flex flex-col items-center w-76 rounded-2xl px-6 py-1 bg-gray-50\">\n                    <Text className=\"text-xs font-medium text-violet-500\">\n                        Verify your Email Address\n                    </Text>\n                    <Text className=\"text-gray-500 my-0\">\n                        Use the following code to verify your email address\n                    </Text>\n                    <Text className=\"text-5xl font-bold pt-2\">{otp}</Text>\n                    <Text className=\"text-gray-400 font-light text-xs pb-4\">\n                        This code is valid for 10 minutes\n                    </Text>\n                    <Text className=\"text-gray-600 text-xs\">\n                        Thank you for joining us\n                    </Text>\n                </Section>\n            </Section>\n        </Tailwind>\n    )\n}\n\nOTPEmail.PreviewProps = {\n    otp: 123456\n}\n```\n\n---\n\n## Prisma\n\n**URL:** https://elysiajs.com/integrations/prisma.md\n\n**Contents:**\n  - Prismabox\n  - How it works:\n- Installation\n- Prisma schema\n- Using generated models\n\n---\nurl: 'https://elysiajs.com/integrations/prisma.md'\n---\n\n[Prisma](https://prisma.io) is an ORM that allows us to interact with databases in a type-safe manner.\n\nIt provides a way to define your database schema using a Prisma schema file, and then generates TypeScript types based on that schema.\n\n[Prismabox](https://github.com/m1212e/prismabox) is a library that generate TypeBox or Elysia validation models from Prisma schema.\n\nWe can use Prismabox to convert Prisma schema into Elysia validation models, which can then be used to ensure type validation in Elysia.\n\n1. Define your database schema in Prisma Schema.\n2. Add `prismabox` generator to generate Elysia schema.\n3. Use the converted Elysia validation models to ensure type validation.\n4. OpenAPI schema is generated from Elysia validation models.\n5. Add [Eden Treaty](/eden/overview) to add type-safety to your frontend.\n\nTo install Prisma, run the following command:\n\nAssuming you already have a `prisma/schema.prisma`.\n\nWe can add a `prismabox` generator to the Prisma schema file as follows:\n\nThis will generate Elysia validation models in the `generated/prismabox` directory.\n\nEach model will have its own file, and the models will be named based on the Prisma model names.\n\n* `User` model will be generated to `generated/prismabox/User.ts`\n* `Post` model will be generated to `generated/prismabox/Post.ts`\n\nThen we can import the generated models in our Elysia application:\n\nThis allows us to reuse the database schema in Elysia validation models.\n\nFor more information, please refer to the [Prisma](https://prisma.io), and [Prismabox](https://github.com/m1212e/prismabox) documentation.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n* ——————————————— *\n                                                    |                 |\n                                               | -> |  Documentation  |\n* ————————— *             * ———————— * OpenAPI |    |                 |\n|           |  prismabox  |          | ——————— |    * ——————————————— *\n|  Prisma   | —————————-> |  Elysia  |\n|           |             |          | ——————— |    * ——————————————— *\n* ————————— *             * ———————— *   Eden  |    |                 |\n                                               | -> |  Frontend Code  |\n\t\t\t\t\t\t\t\t\t\t\t\t    |                 |\n\t\t\t\t\t\t\t\t\t\t\t\t    * ——————————————— *\n```\n\nExample 2 (bash):\n```bash\nbun add @prisma/client prismabox && \\\nbun add -d prisma\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\nThis will generate Elysia validation models in the `generated/prismabox` directory.\n\nEach model will have its own file, and the models will be named based on the Prisma model names.\n\nFor example:\n\n* `User` model will be generated to `generated/prismabox/User.ts`\n* `Post` model will be generated to `generated/prismabox/Post.ts`\n\n## Using generated models\n\nThen we can import the generated models in our Elysia application:\n\n::: code-group\n```\n\n---\n\n## Cloudflare Worker Experimental\n\n**URL:** https://elysiajs.com/integrations/cloudflare-worker.md\n\n**Contents:**\n  - pnpm\n- Limitations\n- Static File\n- Binding\n- AoT compilation\n\n---\nurl: 'https://elysiajs.com/integrations/cloudflare-worker.md'\n---\n\nElysia now supports Cloudflare Worker with an **experimental** Cloudflare Worker Adapter.\n\n1. You will need [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update) to setup, and start a development server.\n\n2. Then add Cloudflare Adapter to your Elysia app, and make sure to call `.compile()` before exporting the app.\n\n3. Make sure to have `compatibility_date` set to at least `2025-06-01` in your wrangler config\n\n4. Now you can start the development server with:\n\nThis should start a development server at `http://localhost:8787`\n\nYou don't need a `nodejs_compat` flag as Elysia doesn't use any Node.js built-in modules (or the ones we use don't support Cloudflare Worker yet).\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nHere are some known limitations of using Elysia on Cloudflare Worker:\n\n1. `Elysia.file`, and [Static Plugin](/plugins/static) doesn't work [due to the lack of `fs` module](https://developers.cloudflare.com/workers/runtime-apis/nodejs/#supported-nodejs-apis), see [static file](#static-file) section for alternative\n2. [OpenAPI Type Gen](/blog/openapi-type-gen) doesn't work [due to the lack of `fs` module](https://developers.cloudflare.com/workers/runtime-apis/nodejs/#supported-nodejs-apis)\n3. You can't define [**Response** before server start](https://x.com/saltyAom/status/1966602691754553832) or use plugin that does so\n4. You can't inline a value due to 3.\n\n[Static Plugin](/plugins/static) doesn't work, but you can still serve static files with [Cloudflare's built-in static file serving](https://developers.cloudflare.com/workers/static-assets/).\n\nAdd the following to your wrangler config:\n\nCreate a `public` folder and place your static files in it.\n\nFor example, if you have a folder structure like this:\n\nThen you should be able to access your static file from the following path:\n\n* **http://localhost:8787/kyuukurarin.mp4**\n* **http://localhost:8787/static/mika.webp**\n\nYou can use a Cloudflare Workers binding by importing env from `cloudflare:workers`.\n\nSee [Cloudflare Workers: Binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/#importing-env-as-a-global) for more information about binding.\n\nPreviously, to use Elysia on Cloudflare Worker, you have to pass `aot: false` to the Elysia constructor.\n\nThis is no longer necessary as [Cloudflare now supports Function compilation during startup](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#enable-eval-during-startup).\n\nAs of Elysia 1.4.7, you can now use Ahead of Time Compilation with Cloudflare Worker, and drop the `aot: false` flag.\n\nOtherwise, you can still use `aot: false` if you don't want Ahead of Time Compilation but we recommend you to use it for better performance, and accurate plugin encapsulation.\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nwrangler init elysia-on-cloudflare\n```\n\nExample 2 (ts):\n```ts\nimport { Elysia } from 'elysia'\nimport { CloudflareAdapter } from 'elysia/adapter/cloudflare-worker' // [!code ++]\n\nexport default new Elysia({\n\tadapter: CloudflareAdapter // [!code ++]\n})\n\t.get('/', () => 'Hello Cloudflare Worker!')\n\t// This is required to make Elysia work on Cloudflare Worker\n\t.compile() // [!code ++]\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\n4. Now you can start the development server with:\n```\n\nExample 4 (unknown):\n```unknown\nThis should start a development server at `http://localhost:8787`\n\nYou don't need a `nodejs_compat` flag as Elysia doesn't use any Node.js built-in modules (or the ones we use don't support Cloudflare Worker yet).\n\n### pnpm\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n```\n\n---\n\n## Integration with Next.js\n\n**URL:** https://elysiajs.com/integrations/nextjs.md\n\n**Contents:**\n  - pnpm\n- Prefix\n- Eden\n- React Query\n\n---\nurl: 'https://elysiajs.com/integrations/nextjs.md'\n---\n\nWith Next.js App Router, we can run Elysia on Next.js routes.\n\n1. Create **app/api/\\[\\[...slugs]]/route.ts**\n2. define an Elysia server\n3. Export **Elysia.fetch** name of HTTP methods you want to use\n\nElysia will work normally because of WinterTC compliance.\n\nYou can treat the Elysia server as a normal Next.js API route.\n\nWith this approach, you can have co-location of both frontend and backend in a single repository and have [End-to-end type safety with Eden](/eden/overview) with both client-side and server action\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nBecause our Elysia server is not in the root directory of the app router, you need to annotate the prefix to the Elysia server.\n\nFor example, if you place Elysia server in **app/user/\\[\\[...slugs]]/route.ts**, you need to annotate prefix as **/user** to Elysia server.\n\nThis will ensure that Elysia routing will work properly in any location you place it.\n\nWe can add [Eden](/eden/overview) for **end-to-end type safety** similar to tRPC.\n\nIn this approach, we will use isomorphic fetch pattern to allow Elysia to:\n\n1. On Server: directly calls Elysia without going through the network layer\n2. On Client: calls Elysia through the network layer\n\nTo start, we need to do the following steps:\n\n1. Export Elysia instance\n\n2. Create a Treaty client with isomorphic approach\n\nIt's important that you should use `typeof process` instead of `typeof window` because `window` is not defined during build time, causing hydration error.\n\n3. Use the client in both server and client components\n\nThis allows you to have type safety from the frontend to the backend with minimal effort and works with both server, client components and with Incremental Static Regeneration (ISR).\n\nWe can also use React Query to interact with Elysia server on client.\n\nThis can works with any React Query features like caching, pagination, infinite query, etc.\n\nPlease refer to [Next.js Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#static-route-handlers) for more information.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\nElysia will work normally because of WinterTC compliance.\n\nYou can treat the Elysia server as a normal Next.js API route.\n\nWith this approach, you can have co-location of both frontend and backend in a single repository and have [End-to-end type safety with Eden](/eden/overview) with both client-side and server action\n\n### pnpm\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n```\n\nExample 2 (unknown):\n```unknown\n## Prefix\n\nBecause our Elysia server is not in the root directory of the app router, you need to annotate the prefix to the Elysia server.\n\nFor example, if you place Elysia server in **app/user/\\[\\[...slugs]]/route.ts**, you need to annotate prefix as **/user** to Elysia server.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\nThis will ensure that Elysia routing will work properly in any location you place it.\n\n## Eden\n\nWe can add [Eden](/eden/overview) for **end-to-end type safety** similar to tRPC.\n\nIn this approach, we will use isomorphic fetch pattern to allow Elysia to:\n\n1. On Server: directly calls Elysia without going through the network layer\n2. On Client: calls Elysia through the network layer\n\nTo start, we need to do the following steps:\n\n1. Export Elysia instance\n\n::: code-group\n```\n\nExample 4 (unknown):\n```unknown\n:::\n\n2. Create a Treaty client with isomorphic approach\n\n::: code-group\n```\n\n---\n\n## Deploy Elysia on Vercel\n\n**URL:** https://elysiajs.com/integrations/vercel.md\n\n**Contents:**\n  - pnpm\n  - Using Node.js\n  - Using Bun\n- If this doesn't work\n\n---\nurl: 'https://elysiajs.com/integrations/vercel.md'\n---\n\nElysia can deploys on Vercel with zero configuration using either Bun or Node runtime.\n\n1. In **src/index.ts**, create or import an existing Elysia server\n2. Export the Elysia server as default export\n\n3. Develop locally with Vercel CLI\n\nThat's it. Your Elysia app is now running on Vercel.\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\nTo deploy with Node.js, make sure to set `type: module` in your `package.json`\n\nTo deploy with Bun, make sure to set the runtime to Bun in your `vercel.json`\n\nVercel has zero configuration for Elysia, for additional configuration, please refers to [Vercel documentation](https://vercel.com/docs/frameworks/backend/elysia)\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\n\nexport default new Elysia() // [!code ++]\n    .get('/', () => 'Hello Vercel Function')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n```\n\nExample 2 (bash):\n```bash\npnpm add @sinclair/typebox openapi-types\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\n### Using Bun\n\nTo deploy with Bun, make sure to set the runtime to Bun in your `vercel.json`\n\n::: code-group\n```\n\n---\n\n## Cheat Sheet\n\n**URL:** https://elysiajs.com/integrations/cheat-sheet.md\n\n**Contents:**\n- Hello World\n- Custom HTTP Method\n- Path Parameter\n- Return JSON\n- Return a file\n- Header and status\n- Group\n- Schema\n- File upload\n- Lifecycle Hook\n\n---\nurl: 'https://elysiajs.com/integrations/cheat-sheet.md'\n---\n\nHere are a quick overview for a common Elysia patterns\n\nDefine route using custom HTTP methods/verbs\n\nSee [Route](/essential/route.html#custom-method)\n\nUsing dynamic path parameter\n\nSee [Path](/essential/route.html#path-type)\n\nElysia converts response to JSON automatically\n\nSee [Handler](/essential/handler.html)\n\nA file can be return in as formdata response\n\nThe response must be a 1-level deep object\n\nSet a custom header and a status code\n\nSee [Handler](/essential/handler.html)\n\nDefine a prefix once for sub routes\n\nSee [Group](/essential/route.html#group)\n\nEnforce a data type of a route\n\nSee [Validation](/essential/validation)\n\nSee [Validation#file](/essential/validation#file)\n\nIntercept an Elysia event in order\n\nSee [Lifecycle](/essential/life-cycle.html)\n\nEnforce a data type of sub routes\n\nSee [Scope](/essential/plugin.html#scope)\n\nAdd custom variable to route context\n\nSee [Context](/essential/handler.html#context)\n\nSee [Handler](/essential/handler.html#redirect)\n\nCreate a separate instance\n\nSee [Plugin](/essential/plugin)\n\nCreate a realtime connection using Web Socket\n\nSee [Web Socket](/patterns/websocket)\n\nCreate interactive documentation using Scalar (or optionally Swagger)\n\nSee [openapi](/plugins/openapi.html)\n\nWrite a unit test of your Elysia app\n\nSee [Unit Test](/patterns/unit-test)\n\nCreate custom logic for parsing body\n\nSee [Parse](/essential/life-cycle.html#parse)\n\nCreate a custom GraphQL server using GraphQL Yoga or Apollo\n\nSee [GraphQL Yoga](/plugins/graphql-yoga)\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', () => 'Hello World')\n    .listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/hi', () => 'Hi')\n    .post('/hi', () => 'From Post')\n    .put('/hi', () => 'From Put')\n    .route('M-SEARCH', '/hi', () => 'Custom Method')\n    .listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/:id', ({ params: { id } }) => id)\n    .get('/rest/*', () => 'Rest')\n    .listen(3000)\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/json', () => {\n        return {\n            hello: 'Elysia'\n        }\n    })\n    .listen(3000)\n```\n\n---\n\n## Integration with Deno\n\n**URL:** https://elysiajs.com/integrations/deno.md\n\n**Contents:**\n  - Change Port Number\n  - pnpm\n\n---\nurl: 'https://elysiajs.com/integrations/deno.md'\n---\n\nElysia is built on top of Web Standard Request/Response, allowing us to run Elysia with Deno.serve directly.\n\nTo run Elysia on Deno, wrap `Elysia.fetch` in `Deno.serve`\n\nThen you can run the server with `deno serve`:\n\nThis is all you need to run Elysia on Deno.\n\nYou can specify the port number in `Deno.serve`.\n\nIf you use pnpm, [pnpm doesn't auto install peer dependencies by default](https://github.com/orgs/pnpm/discussions/3995#discussioncomment-1893230) forcing you to install additional dependencies manually.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.get('/', () => 'Hello Elysia')\n\t.listen(3000) // [!code --]\n\nDeno.serve(app.fetch) // [!code ++]\n```\n\nExample 2 (bash):\n```bash\ndeno serve --watch src/index.ts\n```\n\nExample 3 (ts):\n```ts\nDeno.serve(app.fetch) // [!code --]\nDeno.serve({ port:8787 }, app.fetch) // [!code ++]\n```\n\nExample 4 (bash):\n```bash\npnpm add @sinclair/typebox openapi-types\n```\n\n---\n",
        "plugins/coding/elysia/skills/elysia/references/llms.md": "# Elysia - Ergonomic Framework for Humans\n\n> Ergonomic Framework for Humans\n\nErgonomic Framework for Humans. TypeScript framework supercharged by Bun with End - to - End Type Safety, unified type system and outstanding developer experience\n\n## Table of Contents\n\n### Getting Started\n\n- [At glance - ElysiaJS](https://elysiajs.com/at-glance.md)\n- [Quick Start - ElysiaJS](https://elysiajs.com/quick-start.md)\n- [Key Concept - ElysiaJS](https://elysiajs.com/key-concept.md)\n\n### Essential\n\n- [Route - ElysiaJS](https://elysiajs.com/essential/route.md)\n- [Handler - ElysiaJS](https://elysiajs.com/essential/handler.md)\n- [Plugin - ElysiaJS](https://elysiajs.com/essential/plugin.md)\n- [Lifecycle - ElysiaJS](https://elysiajs.com/essential/life-cycle.md)\n- [Validation - ElysiaJS](https://elysiajs.com/essential/validation.md)\n- [Best Practice - ElysiaJS](https://elysiajs.com/essential/best-practice.md)\n\n### Patterns\n\n- [Config - ElysiaJS](https://elysiajs.com/patterns/configuration.md)\n- [Reactive Cookie - ElysiaJS](https://elysiajs.com/patterns/cookie.md)\n- [Deploy to Production - ElysiaJS](https://elysiajs.com/patterns/deploy.md)\n- [Error Handling - ElysiaJS](https://elysiajs.com/patterns/error-handling.md)\n- [Extends Context - ElysiaJS](https://elysiajs.com/patterns/extends-context.md)\n- [Fullstack Dev Server - ElysiaJS](https://elysiajs.com/patterns/fullstack-dev-server.md)\n- [Macro - ElysiaJS](https://elysiajs.com/patterns/macro.md)\n- [Mount - ElysiaJS](https://elysiajs.com/patterns/mount.md)\n- [OpenAPI - ElysiaJS](https://elysiajs.com/patterns/openapi.md)\n- [OpenTelemetry Plugin - ElysiaJS](https://elysiajs.com/patterns/opentelemetry.md)\n- [Trace - ElysiaJS](https://elysiajs.com/patterns/trace.md)\n- [TypeBox (Elysia.t) - ElysiaJS](https://elysiajs.com/patterns/typebox.md)\n- [TypeScript - ElysiaJS](https://elysiajs.com/patterns/typescript.md)\n- [Testing - ElysiaJS](https://elysiajs.com/patterns/unit-test.md)\n- [WebSocket - ElysiaJS](https://elysiajs.com/patterns/websocket.md)\n\n### Eden\n\n- [End-to-End Type Safety - ElysiaJS](https://elysiajs.com/eden/overview.md)\n- [Eden Installation - ElysiaJS](https://elysiajs.com/eden/installation.md)\n- [Eden Fetch - ElysiaJS](https://elysiajs.com/eden/fetch.md)\n\n#### Eden Treaty\n\n- [Overview - ElysiaJS](https://elysiajs.com/eden/treaty/overview.md)\n- [Eden Treaty Parameters - ElysiaJS](https://elysiajs.com/eden/treaty/parameters.md)\n- [Eden Treaty Response - ElysiaJS](https://elysiajs.com/eden/treaty/response.md)\n- [Eden Treaty Web Socket - ElysiaJS](https://elysiajs.com/eden/treaty/websocket.md)\n- [Eden Treaty Config - ElysiaJS](https://elysiajs.com/eden/treaty/config.md)\n- [Eden Treaty Unit Test - ElysiaJS](https://elysiajs.com/eden/treaty/unit-test.md)\n- [Eden Treaty Legacy - ElysiaJS](https://elysiajs.com/eden/treaty/legacy.md)\n\n### Plugins\n\n- [Plugin Overview - ElysiaJS](https://elysiajs.com/plugins/overview.md)\n- [Bearer Plugin - ElysiaJS](https://elysiajs.com/plugins/bearer.md)\n- [CORS Plugin - ElysiaJS](https://elysiajs.com/plugins/cors.md)\n- [Cron Plugin - ElysiaJS](https://elysiajs.com/plugins/cron.md)\n- [Apollo GraphQL Plugin - ElysiaJS](https://elysiajs.com/plugins/graphql-apollo.md)\n- [GraphQL Yoga Plugin - ElysiaJS](https://elysiajs.com/plugins/graphql-yoga.md)\n- [HTML Plugin - ElysiaJS](https://elysiajs.com/plugins/html.md)\n- [JWT Plugin - ElysiaJS](https://elysiajs.com/plugins/jwt.md)\n- [OpenAPI Plugin - ElysiaJS](https://elysiajs.com/plugins/openapi.md)\n- [OpenTelemetry Plugin - ElysiaJS](https://elysiajs.com/plugins/opentelemetry.md)\n- [Server Timing Plugin - ElysiaJS](https://elysiajs.com/plugins/server-timing.md)\n- [Static Plugin - ElysiaJS](https://elysiajs.com/plugins/static.md)\n\n### Comparison\n\n- [Migrate from Express - ElysiaJS](https://elysiajs.com/migrate/from-express.md)\n- [Migrate from Fastify - ElysiaJS](https://elysiajs.com/migrate/from-fastify.md)\n- [Migrate from Hono - ElysiaJS](https://elysiajs.com/migrate/from-hono.md)\n- [Migrate from tRPC - ElysiaJS](https://elysiajs.com/migrate/from-trpc.md)\n\n### Integration\n\n- [Integration with AI SDK - ElysiaJS](https://elysiajs.com/integrations/ai-sdk.md)\n- [Integration with Astro - ElysiaJS](https://elysiajs.com/integrations/astro.md)\n- [Better Auth - ElysiaJS](https://elysiajs.com/integrations/better-auth.md)\n- [Integration with Cloudflare Worker - ElysiaJS](https://elysiajs.com/integrations/cloudflare-worker.md)\n- [Integration with Deno - ElysiaJS](https://elysiajs.com/integrations/deno.md)\n- [Integration with Drizzle - ElysiaJS](https://elysiajs.com/integrations/drizzle.md)\n- [Integration with Expo - ElysiaJS](https://elysiajs.com/integrations/expo.md)\n- [Integration with Netlify Edge Function - ElysiaJS](https://elysiajs.com/integrations/netlify.md)\n- [Integration with Nextjs - ElysiaJS](https://elysiajs.com/integrations/nextjs.md)\n- [Integration with Node.js - ElysiaJS](https://elysiajs.com/integrations/node.md)\n- [Integration with Nuxt - ElysiaJS](https://elysiajs.com/integrations/nuxt.md)\n- [Integration with Prisma - ElysiaJS](https://elysiajs.com/integrations/prisma.md)\n- [React Email - ElysiaJS](https://elysiajs.com/integrations/react-email.md)\n- [Integration with SvelteKit - ElysiaJS](https://elysiajs.com/integrations/sveltekit.md)\n- [Integration with Tanstack Start - ElysiaJS](https://elysiajs.com/integrations/tanstack-start.md)\n- [Deploy Elysia on Vercel - ElysiaJS](https://elysiajs.com/integrations/vercel.md)\n\n### Other\n\n- [Cheat Sheet (Elysia by example) - ElysiaJS](https://elysiajs.com/integrations/cheat-sheet.md)\n- [Comparison with Other Frameworks](https://elysiajs.com/migrate.md)\n- [Cookie - Elysia Tutorial](https://elysiajs.com/tutorial/patterns/cookie.md)\n- [Eden Test - ElysiaJS](https://elysiajs.com/eden/test.md)\n- [Elysia Blog](https://elysiajs.com/illust.md)\n- [Encapsulation - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/encapsulation.md)\n- [End-to-End Type Safety - Elysia Tutorial](https://elysiajs.com/tutorial/features/end-to-end-type-safety.md)\n- [Error Handling - Elysia Tutorial](https://elysiajs.com/tutorial/patterns/error-handling.md)\n- [Extends Context - Elysia Tutorial](https://elysiajs.com/tutorial/patterns/extends-context.md)\n- [Guard - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/guard.md)\n- [Handler and Context - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/handler-and-context.md)\n- [Introduction - Elysia Tutorial](https://elysiajs.com/tutorial.md)\n- [Life Cycle - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/life-cycle.md)\n- [Macro - Elysia Tutorial](https://elysiajs.com/tutorial/patterns/macro.md)\n- [Mount - Elysia Tutorial](https://elysiajs.com/tutorial/features/mount.md)\n- [OpenAPI - Elysia Tutorial](https://elysiajs.com/tutorial/features/openapi.md)\n- [Playground](https://elysiajs.com/playground.md)\n- [Plugin - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/plugin.md)\n- [Preview](https://elysiajs.com/playground/preview.md)\n- [Standalone Schema - Elysia Tutorial](https://elysiajs.com/tutorial/patterns/standalone-schema.md)\n- [Status and Headers - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/status-and-headers.md)\n- [Swagger Plugin - ElysiaJS](https://elysiajs.com/plugins/swagger.md)\n- [Unit Test - Elysia Tutorial](https://elysiajs.com/tutorial/features/unit-test.md)\n- [Validation - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/validation.md)\n- [Validation Error - Elysia Tutorial](https://elysiajs.com/tutorial/patterns/validation-error.md)\n- [What's Next - Elysia Tutorial](https://elysiajs.com/tutorial/whats-next.md)\n- [Your First Route - Elysia Tutorial](https://elysiajs.com/tutorial/getting-started/your-first-route.md)\n",
        "plugins/coding/elysia/skills/elysia/references/other.md": "# Elysia - Other\n\n**Pages:** 10\n\n---\n\n## Key Concept&#x20;\n\n**URL:** https://elysiajs.com/key-concept.md\n\n**Contents:**\n- Encapsulation&#x20;\n- Method Chaining&#x20;\n  - Without method chaining\n- Dependency&#x20;\n  - Deduplication&#x20;\n  - Global vs Explicit Dependency\n- Order of code&#x20;\n- Type Inference\n  - TypeScript\n\n---\nurl: 'https://elysiajs.com/key-concept.md'\n---\n\nElysia has a every important concepts that you need to understand to use.\n\nThis page covers most concepts that you should know before getting started.\n\nElysia lifecycle methods are **encapsulated** to its own instance only.\n\nWhich means if you create a new instance, it will not share the lifecycle methods with others.\n\nIn this example, the `isSignIn` check will only apply to `profile` but not `app`.\n\n> Try changing the path in the URL bar to **/rename** and see the result\n\n**Elysia isolate lifecycle by default** unless explicitly stated. This is similar to **export** in JavaScript, where you need to export the function to make it available outside the module.\n\nTo **\"export\"** the lifecycle to other instances, you must add specify the scope.\n\nCasting lifecycle to **\"global\"** will export lifecycle to **every instance**.\n\nLearn more about this in [scope](/essential/plugin.html#scope-level).\n\nElysia code should **ALWAYS** use method chaining.\n\nThis is **important to ensure type safety**.\n\nIn the code above, **state** returns a new **ElysiaInstance** type, adding a typed `build` property.\n\nAs Elysia type system is complex, every method in Elysia returns a new type reference.\n\nWithout using method chaining, Elysia doesn't save these new types, leading to no type inference.\n\nWe recommend to **always use method chaining** to provide an accurate type inference.\n\nElysia by design, is compose of multiple mini Elysia apps which can run **independently** like a microservice that communicate with each other.\n\nEach Elysia instance is independent and **can run as a standalone server**.\n\nWhen an instance need to use another instance's service, you **must explicitly declare the dependency**.\n\nThis is similar to **Dependency Injection** where each instance must declare its dependencies.\n\nThis approach force you to be explicit about dependencies allowing better tracking, modularity.\n\nBy default, each plugin will be re-executed **every time** applying to another instance.\n\nTo prevent this, Elysia can deduplicate lifecycle with **an unique identifier** using `name` and optional `seed` property.\n\nAdding the `name` and optional `seed` to the instance will make it a unique identifier prevent it from being called multiple times.\n\nLearn more about this in [plugin deduplication](/essential/plugin.html#plugin-deduplication).\n\nThere are some case that global dependency make more sense than an explicit one.\n\n**Global** plugin example:\n\n* **Plugin that doesn't add types** - eg. cors, compress, helmet\n* Plugin that add global lifecycle that no instance should have control over - eg. tracing, logging\n\n* OpenAPI/Open - Global document\n* OpenTelemetry - Global tracer\n* Logging - Global logger\n\nIn case like this, it make more sense to create it as global dependency instead of applying it to every instance.\n\nHowever, if your dependency doesn't fit into these categories, it's recommended to use **explicit dependency** instead.\n\n**Explicit dependency** example:\n\n* **Plugin that add types** - eg. macro, state, model\n* Plugin that add business logic that instance can interact with - eg. Auth, Database\n\n* State management - eg. Store, Session\n* Data modeling - eg. ORM, ODM\n* Business logic - eg. Auth, Database\n* Feature module - eg. Chat, Notification\n\nThe order of Elysia's life-cycle code is very important.\n\nBecause event will only apply to routes **after** it is registered.\n\nIf you put the onError before plugin, plugin will not inherit the onError event.\n\nConsole should log the following:\n\nNotice that it doesn't log **2**, because the event is registered after the route so it is not applied to the route.\n\nLearn more about this in [order of code](/essential/life-cycle.html#order-of-code).\n\nElysia has a complex type system that allows you to infer types from the instance.\n\nYou should **always use an inline function** to provide an accurate type inference.\n\nIf you need to apply a separate function, eg. MVC's controller pattern, it's recommended to destructure properties from inline function to prevent unnecessary type inference as follows:\n\nSee [Best practice: MVC Controller](/essential/best-practice.html#controller).\n\nWe can get a type definitions of every Elysia/TypeBox's type by accessing `static` property as follows:\n\nThis allows Elysia to infer and provide type automatically, reducing the need to declare duplicate schema\n\nA single Elysia/TypeBox schema can be used for:\n\n* Runtime validation\n* Data coercion\n* TypeScript type\n* OpenAPI schema\n\nThis allows us to make a schema as a **single source of truth**.\n\n**Examples:**\n\nExample 1 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nconst profile = new Elysia()\n\t.onBeforeHandle(({ cookie }) => {\n\t\tthrowIfNotSignIn(cookie)\n\t})\n\t.get('/profile', () => 'Hi there!')\n\nconst app = new Elysia()\n\t.use(profile)\n\t// ⚠️ This will NOT have sign in check\n\t.patch('/rename', ({ body }) => updateProfile(body))\n```\n\nExample 2 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nconst profile = new Elysia()\n\t.onBeforeHandle(\n\t\t{ as: 'global' }, // [!code ++]\n\t\t({ cookie }) => {\n\t\t\tthrowIfNotSignIn(cookie)\n\t\t}\n\t)\n\t.get('/profile', () => 'Hi there!')\n\nconst app = new Elysia()\n\t.use(profile)\n\t// This has sign in check\n\t.patch('/rename', ({ body }) => updateProfile(body))\n```\n\nExample 3 (unknown):\n```unknown\nIn the code above, **state** returns a new **ElysiaInstance** type, adding a typed `build` property.\n\n### Without method chaining\n\nAs Elysia type system is complex, every method in Elysia returns a new type reference.\n\nWithout using method chaining, Elysia doesn't save these new types, leading to no type inference.\n```\n\nExample 4 (unknown):\n```unknown\nWe recommend to **always use method chaining** to provide an accurate type inference.\n\n## Dependency&#x20;\n\nElysia by design, is compose of multiple mini Elysia apps which can run **independently** like a microservice that communicate with each other.\n\nEach Elysia instance is independent and **can run as a standalone server**.\n\nWhen an instance need to use another instance's service, you **must explicitly declare the dependency**.\n```\n\n---\n\n## \n\n**URL:** https://elysiajs.com/playground/preview.md\n\n---\nurl: 'https://elysiajs.com/playground/preview.md'\n---\n\n---\n\n## At a glance\n\n**URL:** https://elysiajs.com/at-glance.md\n\n**Contents:**\n- Performance\n- TypeScript\n- Type Integrity\n- Standard Schema\n- OpenAPI\n- OpenAPI from types\n- End-to-end Type Safety\n- Type Soundness\n- Platform Agnostic\n- Our Community\n\n---\nurl: 'https://elysiajs.com/at-glance.md'\n---\n\nElysia is an ergonomic web framework for building backend servers with Bun.\n\nDesigned with simplicity and type-safety in mind, Elysia offers a familiar API with extensive support for TypeScript and is optimized for Bun.\n\nHere's a simple hello world in Elysia.\n\nNavigate to [localhost:3000](http://localhost:3000/) and you should see 'Hello Elysia' as the result.\n\n::: tip\nHover over the code snippet to see the type definition.\n\nIn the mock browser, click on the path highlighted in blue to change paths and preview the response.\n\nElysia can run in the browser, and the results you see are actually executed using Elysia.\n:::\n\nBuilding on Bun and extensive optimization like static code analysis allows Elysia to generate optimized code on the fly.\n\nElysia can outperform most web frameworks available today\\[1], and even match the performance of Golang and Rust frameworks\\[2].\n\n| Framework     | Runtime | Average     | Plain Text | Dynamic Parameters | JSON Body  |\n| ------------- | ------- | ----------- | ---------- | ------------------ | ---------- |\n| bun           | bun     | 262,660.433 | 326,375.76 | 237,083.18         | 224,522.36 |\n| elysia        | bun     | 255,574.717 | 313,073.64 | 241,891.57         | 211,758.94 |\n| hyper-express | node    | 234,395.837 | 311,775.43 | 249,675            | 141,737.08 |\n| hono          | bun     | 203,937.883 | 239,229.82 | 201,663.43         | 170,920.4  |\n| h3            | node    | 96,515.027  | 114,971.87 | 87,935.94          | 86,637.27  |\n| oak           | deno    | 46,569.853  | 55,174.24  | 48,260.36          | 36,274.96  |\n| fastify       | bun     | 65,897.043  | 92,856.71  | 81,604.66          | 23,229.76  |\n| fastify       | node    | 60,322.413  | 71,150.57  | 62,060.26          | 47,756.41  |\n| koa           | node    | 39,594.14   | 46,219.64  | 40,961.72          | 31,601.06  |\n| express       | bun     | 29,715.537  | 39,455.46  | 34,700.85          | 14,990.3   |\n| express       | node    | 15,913.153  | 17,736.92  | 17,128.7           | 12,873.84  |\n\nElysia is designed to help you write less TypeScript.\n\nElysia's Type System is fine-tuned to infer types from your code automatically, without needing to write explicit TypeScript, while providing type-safety at both runtime and compile time for the most ergonomic developer experience.\n\nTake a look at this example:\n\nThe above code creates a path parameter **\"id\"**. The value that replaces `:id` will be passed to `params.id` both at runtime and in types, without manual type declaration.\n\nElysia's goal is to help you write less TypeScript and focus more on business logic. Let the framework handle the complex types.\n\nTypeScript is not required to use Elysia, but it's recommended.\n\nTo take it a step further, Elysia provides **Elysia.t**, a schema builder to validate types and values at both runtime and compile time, creating a single source of truth for your data types.\n\nLet's modify the previous code to accept only a number value instead of a string.\n\nThis code ensures that our path parameter **id** will always be a number at both runtime and compile time (type-level).\n\n::: tip\nHover over \"id\" in the above code snippet to see a type definition.\n:::\n\nWith Elysia's schema builder, we can ensure type safety like a strongly typed language with a single source of truth.\n\nElysia supports [Standard Schema](https://github.com/standard-schema/standard-schema), allowing you to use your favorite validation library:\n\n* Zod\n* Valibot\n* ArkType\n* Effect Schema\n* Yup\n* Joi\n* [and more](https://github.com/standard-schema/standard-schema)\n\nElysia will infer the types from the schema automatically, allowing you to use your favorite validation library while still maintaining type safety.\n\nElysia adopts many standards by default, like OpenAPI, WinterTC compliance, and Standard Schema. Allowing you to integrate with most of the industry standard tools or at least easily integrate with tools you are familiar with.\n\nFor instance, because Elysia adopts OpenAPI by default, generating API documentation is as easy as adding a one-liner:\n\nWith the OpenAPI plugin, you can seamlessly generate an API documentation page without additional code or specific configuration and share it with your team effortlessly.\n\nElysia also supports OpenAPI schema generation with **1 line directly from types**.\n\nThis is a **unique feature** of Elysia, allowing you to have complete and accurate API documentation directly from your code without any manual annotation.\n\nThis is equivalent to **FastAPI**'s automatic OpenAPI generation from types but in TypeScript.\n\nWith Elysia, type safety is not limited to server-side.\n\nWith Elysia, you can synchronize your types with your frontend team automatically, similar to tRPC, using Elysia's client library, \"Eden\".\n\nAnd on your client-side:\n\nWith Eden, you can use the existing Elysia types to query an Elysia server **without code generation** and synchronize types for both frontend and backend automatically.\n\nElysia is not only about helping you create a confident backend but for all that is beautiful in this world.\n\nMost frameworks with end-to-end type safety usually assume only a happy part, leaving error handling and edge cases out of the type system.\n\nHowever, Elysia can infers all of the possible outcomes of your API, from lifecycle events/macro from any part of your codebase.\n\nThis is one of the **unfair advantages** that Elysia has from years of investment in type system.\n\nElysia is optimized for Bun with native feature but **not limited to Bun**.\n\nBeing [WinterTC compliant](https://wintertc.org/) allows you to deploy Elysia servers on:\n\n* Bun\n* [Node.js](/integrations/node)\n* [Deno](/integrations/deno)\n* [Cloudflare Worker](/integrations/cloudflare-worker)\n* [Vercel](/integrations/vercel)\n* [Expo](/integrations/expo) via API routes\n* [Nextjs](/integrations/nextjs) via API routes\n* [Astro](/integrations/astro) via API routes\n\nand several more! Checkout `integration` section on sidebar for more support runtime.\n\nWe want to create a friendly and welcoming community for everyone with cute and playful design including our anime mascot, Elysia chan.\n\nWe believe that technology can be cute and fun instead of being serious all the time, to brings joy to people's lives.\n\nBut even that, we take Elysia very seriously to make sure it's reliable and production ready high-performance framework that can be trusted for your next project.\n\nElysia is **used in production by many companies and projects worldwide**, including [X](https://x.com/shlomiatar/status/1822381556142362734), [Bank for Agriculture and Agricultural Co-operatives](https://github.com/elysiajs/elysia/discussions/1312#discussioncomment-13924470), [Cluely](https://github.com/elysiajs/elysia/discussions/1312#discussioncomment-14420139), [CS.Money](https://github.com/elysiajs/elysia/discussions/1312#discussioncomment-13913513), [Abacate Pay](https://github.com/elysiajs/elysia/discussions/1312#discussioncomment-13922081) and used by [over 10,000 (open source) projects on GitHub.](https://github.com/elysiajs/elysia/network/dependents) and has been actively developed and maintained since 2022 with many regular contributors from our community.\n\nElysia is a reliable choice and production ready for building your next backend server.\n\nHere's on of our community resources to get you started:\n\n1\\. Measured in requests/second. The benchmark for parsing query, path parameter and set response header on Debian 11, Intel i7-13700K tested on Bun 0.7.2 on 6 Aug 2023. See the benchmark condition [here](https://github.com/SaltyAom/bun-http-framework-benchmark/tree/c7e26fe3f1bfee7ffbd721dbade10ad72a0a14ab#results).\n\n2\\. Based on [TechEmpower Benchmark round 22](https://www.techempower.com/benchmarks/#section=data-r22\\&hw=ph\\&test=composite).\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\nNavigate to [localhost:3000](http://localhost:3000/) and you should see 'Hello Elysia' as the result.\n\n::: tip\nHover over the code snippet to see the type definition.\n\nIn the mock browser, click on the path highlighted in blue to change paths and preview the response.\n\nElysia can run in the browser, and the results you see are actually executed using Elysia.\n:::\n\n## Performance\n\nBuilding on Bun and extensive optimization like static code analysis allows Elysia to generate optimized code on the fly.\n\nElysia can outperform most web frameworks available today\\[1], and even match the performance of Golang and Rust frameworks\\[2].\n\n| Framework     | Runtime | Average     | Plain Text | Dynamic Parameters | JSON Body  |\n| ------------- | ------- | ----------- | ---------- | ------------------ | ---------- |\n| bun           | bun     | 262,660.433 | 326,375.76 | 237,083.18         | 224,522.36 |\n| elysia        | bun     | 255,574.717 | 313,073.64 | 241,891.57         | 211,758.94 |\n| hyper-express | node    | 234,395.837 | 311,775.43 | 249,675            | 141,737.08 |\n| hono          | bun     | 203,937.883 | 239,229.82 | 201,663.43         | 170,920.4  |\n| h3            | node    | 96,515.027  | 114,971.87 | 87,935.94          | 86,637.27  |\n| oak           | deno    | 46,569.853  | 55,174.24  | 48,260.36          | 36,274.96  |\n| fastify       | bun     | 65,897.043  | 92,856.71  | 81,604.66          | 23,229.76  |\n| fastify       | node    | 60,322.413  | 71,150.57  | 62,060.26          | 47,756.41  |\n| koa           | node    | 39,594.14   | 46,219.64  | 40,961.72          | 31,601.06  |\n| express       | bun     | 29,715.537  | 39,455.46  | 34,700.85          | 14,990.3   |\n| express       | node    | 15,913.153  | 17,736.92  | 17,128.7           | 12,873.84  |\n\n## TypeScript\n\nElysia is designed to help you write less TypeScript.\n\nElysia's Type System is fine-tuned to infer types from your code automatically, without needing to write explicit TypeScript, while providing type-safety at both runtime and compile time for the most ergonomic developer experience.\n\nTake a look at this example:\n```\n\nExample 2 (unknown):\n```unknown\nThe above code creates a path parameter **\"id\"**. The value that replaces `:id` will be passed to `params.id` both at runtime and in types, without manual type declaration.\n\nElysia's goal is to help you write less TypeScript and focus more on business logic. Let the framework handle the complex types.\n\nTypeScript is not required to use Elysia, but it's recommended.\n\n## Type Integrity\n\nTo take it a step further, Elysia provides **Elysia.t**, a schema builder to validate types and values at both runtime and compile time, creating a single source of truth for your data types.\n\nLet's modify the previous code to accept only a number value instead of a string.\n```\n\nExample 3 (unknown):\n```unknown\nThis code ensures that our path parameter **id** will always be a number at both runtime and compile time (type-level).\n\n::: tip\nHover over \"id\" in the above code snippet to see a type definition.\n:::\n\nWith Elysia's schema builder, we can ensure type safety like a strongly typed language with a single source of truth.\n\n## Standard Schema\n\nElysia supports [Standard Schema](https://github.com/standard-schema/standard-schema), allowing you to use your favorite validation library:\n\n* Zod\n* Valibot\n* ArkType\n* Effect Schema\n* Yup\n* Joi\n* [and more](https://github.com/standard-schema/standard-schema)\n```\n\nExample 4 (unknown):\n```unknown\nElysia will infer the types from the schema automatically, allowing you to use your favorite validation library while still maintaining type safety.\n\n## OpenAPI\n\nElysia adopts many standards by default, like OpenAPI, WinterTC compliance, and Standard Schema. Allowing you to integrate with most of the industry standard tools or at least easily integrate with tools you are familiar with.\n\nFor instance, because Elysia adopts OpenAPI by default, generating API documentation is as easy as adding a one-liner:\n```\n\n---\n\n## From Fastify to Elysia\n\n**URL:** https://elysiajs.com/migrate/from-fastify.md\n\n**Contents:**\n- Performance\n- Routing\n- Handler\n- Subrouter\n- Validation\n- File upload\n- Lifecycle Event\n  - Elysia Lifecycle\n  - Fastify Lifecycle\n- Sounds type safety\n\n---\nurl: 'https://elysiajs.com/migrate/from-fastify.md'\n---\n\nThis guide is for Fastify users who want to see a differences from Fastify including syntax, and how to migrate your application from Fastify to Elysia by example.\n\n**Fastify** is a fast and low overhead web framework for Node.js, designed to be simple and easy to use. It is built on top of the HTTP module and provides a set of features that make it easy to build web applications.\n\n**Elysia** is an ergonomic web framework for Bun, Node.js, and runtime that supports Web Standard API. Designed to be ergonomic and developer-friendly with a focus on **sound type safety** and performance.\n\nElysia has significant performance improvements over Fastify thanks to native Bun implementation, and static code analysis.\n\nFastify and Elysia has similar routing syntax, using `app.get()` and `app.post()` methods to define routes and similar path parameters syntax.\n\n> Fastify use `request` and `reply` as request and response objects\n\n> Elysia use a single `context` and returns the response directly\n\nThere is a slight different in style guide, Elysia recommends usage of method chaining and object destructuring.\n\nElysia also supports an inline value for the response if you don't need to use the context.\n\nBoth has a simliar property for accessing input parameters like `headers`, `query`, `params`, and `body`, and automatically parse the request body to JSON, URL-encoded data, and formdata.\n\n> Fastify parse data and put it into `request` object\n\n> Elysia parse data and put it into `context` object\n\nFastify use a function callback to define a subrouter while Elysia treats every instances as a component that can be plug and play together.\n\n> Fastify use a function callback to declare a sub router\n\n> Elysia treat every instances as a component\n\nWhile Elysia set the prefix in the constructor, Fastify requires you to set the prefix in the options.\n\nElysia has a built-in support for request validation with sounds type safety out of the box using **TypeBox** while Fastify use JSON Schema for declaring schema, and **ajv** for validation.\n\nHowever, doesn't infer type automatically, and you need to use a type provider like `@fastify/type-provider-json-schema-to-ts` to infer type.\n\n> Fastify use JSON Schema for validation\n\n> Elysia use TypeBox for validation, and coerce type automatically. While supporting various validation library like Zod, Valibot with the same syntax as well.\n\nAlternatively, Fastify can also use **TypeBox** or **Zod** for validation using `@fastify/type-provider-typebox` to infer type automatically.\n\nWhile Elysia **prefers TypeBox** for validation, Elysia also support for Standard Schema allowing you to use library like Zod, Valibot, ArkType, Effect Schema and so on out of the box.\n\nFastify use a `fastify-multipart` to handle file upload which use `Busboy` under the hood while Elysia use Web Standard API for handling formdata, mimetype valiation using declarative API.\n\nHowever, Fastify doesn't offers a straight forward way for file validation, eg. file size and mimetype, and required some workarounds to validate the file.\n\n> Fastift use `fastify-multipart` to handle file upload, and fake `type: object` to allow Buffer\n\n> Elysia handle file, and mimetype validation using `t.File`\n\nAs **multer** doesn't validate mimetype, you need to validate the mimetype manually using **file-type** or similar library.\n\nWhile Elysia, validate file upload, and use **file-type** to validate mimetype automatically.\n\nBoth Fastify and Elysia has some what similar lifecycle event using event-based approach.\n\nElysia's Life Cycle event can be illustrated as the following.\n![Elysia Life Cycle Graph](/assets/lifecycle-chart.svg)\n\n> Click on image to enlarge\n\nFastify Life Cycle event also use an event-based approach similar to Elysia.\n\nBoth also has somewhat similar syntax for intercepting the request and response lifecycle events, however Elysia doesn't require you to call `done` to continue the lifecycle event.\n\n> Fastify use `addHook` to register a middleware, and requires you to call `done` to continue the lifecycle event\n\n> Elysia detects the lifecycle event automatically, and doesn't require you to call `done` to continue the lifecycle event\n\nElysia is designed to be sounds type safety.\n\nFor example, you can customize context in a **type safe** manner using [derive](/essential/life-cycle.html#derive) and [resolve](/essential/life-cycle.html#resolve) while Fastify doesn't.\n\n> Fastify use `decorateRequest` but doesn't offers sounds type safety\n\n> Elysia use `decorate` to extend the context, and `resolve` to add custom properties to the context\n\nWhile Fastify can, use `declare module` to extend the `FastifyRequest` interface, it is globally available and doesn't have sounds type safety, and doesn't garantee that the property is available in all request handlers.\n\n> This is required for the above Fastify example to work, which doesn't offers sounds type safety\n\nFastify use a function to return Fastify plugin to define a named middleware, while Elysia use [macro](/patterns/macro) to define a custom hook.\n\n> Fastify use a function callback to accept custom argument for middleware\n\n> Elysia use macro to pass custom argument to custom middleware\n\nWhile Fastify use a function callback, it needs to return a function to be placed in an event handler or an object represented as a hook which can be hard to handle when there are need for multiple custom functions as you need to reconcile them into a single object.\n\nBoth Fastify and Elysia offers a lifecycle event to handle error.\n\n> Fastify use `setErrorHandler` for global error handler, and `errorHandler` for route-specific error handler\n\n> Elysia offers a custom error code, a shorthand for status and `toResponse` for mapping error to a response.\n\nWhile Both offers error handling using lifecycle event, Elysia also provide:\n\n1. Custom error code\n2. Shorthand for mapping HTTP status and `toResponse` for mapping error to a response\n\nThe error code is useful for logging and debugging, and is important when differentiating between different error types extending the same class.\n\nElysia provides all of this with type safety while Fastify doesn't.\n\nFastify encapsulate plugin side-effect, while Elysia give you a control over side-effect of a plugin via explicit scoping mechanism, and order-of-code.\n\n> Fastify encapsulate side-effect of a plugin\n\n> Elysia encapsulate side-effect of a plugin unless explicitly stated\n\nBoth has a encapsulate mechanism of a plugin to prevent side-effect.\n\nHowever, Elysia can explicitly stated which plugin should have side-effect by declaring a scoped while Fastify always encapsulate it.\n\nElysia offers 3 type of scoping mechanism:\n\n1. **local** - Apply to current instance only, no side-effect (default)\n2. **scoped** - Scoped side-effect to the parent instance but not beyond\n3. **global** - Affects every instances\n\nAs Fastify doesn't offers a scoping mechanism, we need to either:\n\n1. Create a function for each hooks and append them manually\n2. Use higher-order-function, and apply it to instance that need the effect\n\nHowever, this can caused a duplicated side-effect if not handled carefully.\n\nIn this scenario, Elysia offers a plugin deduplication mechanism to prevent duplicated side-effect.\n\nBy using a unique `name`, Elysia will apply the plugin only once, and will not cause duplicated side-effect.\n\nFastify use `@fastify/cookie` to parse cookies, while Elysia has a built-in support for cookie and use a signal-based approach to handle cookies.\n\n> Fastify use `unsignCookie` to verify the cookie signature, and `setCookie` to set the cookie\n\n> Elysia use a signal-based approach to handle cookies, and signature verification is handle automatically\n\nBoth offers OpenAPI documentation using Swagger, however Elysia default to Scalar UI which is a more modern and user-friendly interface for OpenAPI documentation.\n\n> Fastify use `@fastify/swagger` for OpenAPI documentation using Swagger\n\n> Elysia use `@elysiajs/swagger` for OpenAPI documentation using Scalar by default, or optionally Swagger\n\nBoth offers model reference using `$ref` for OpenAPI documentation, however Fastify doesn't offers type-safety, and auto-completion for specifying model name while Elysia does.\n\nFastify has a built-in support for testing using `fastify.inject()` to **simulate** network request while Elysia use a Web Standard API to do an **actual** request.\n\n> Fastify use `fastify.inject()` to simulate network request\n\n> Elysia use Web Standard API to handle **actual** request\n\nAlternatively, Elysia also offers a helper library called [Eden](/eden/overview) for End-to-end type safety, allowing us to test with auto-completion, and full type safety.\n\nElysia offers a built-in support for **end-to-end type safety** without code generation using [Eden](/eden/overview), while Fastify doesn't offers one.\n\nIf end-to-end type safety is important for you then Elysia is the right choice.\n\nElysia offers a more ergonomic and developer-friendly experience with a focus on performance, type safety, and simplicity while Fastify is one of the established framework for Node.js, but doesn't have **sounds type safety** and **end-to-end type safety** offered by next generation framework.\n\nIf you are looking for a framework that is easy to use, has a great developer experience, and is built on top of Web Standard API, Elysia is the right choice for you.\n\nAlternatively, if you are coming from a different framework, you can check out:\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\n\n> Fastify use `request` and `reply` as request and response objects\n\n::: code-group\n```\n\nExample 2 (unknown):\n```unknown\n:::\n\n\n> Elysia use a single `context` and returns the response directly\n\nThere is a slight different in style guide, Elysia recommends usage of method chaining and object destructuring.\n\nElysia also supports an inline value for the response if you don't need to use the context.\n\n## Handler\n\nBoth has a simliar property for accessing input parameters like `headers`, `query`, `params`, and `body`, and automatically parse the request body to JSON, URL-encoded data, and formdata.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\n\n> Fastify parse data and put it into `request` object\n\n::: code-group\n```\n\nExample 4 (unknown):\n```unknown\n:::\n\n\n> Elysia parse data and put it into `context` object\n\n## Subrouter\n\nFastify use a function callback to define a subrouter while Elysia treats every instances as a component that can be plug and play together.\n\n::: code-group\n```\n\n---\n\n## From Express to Elysia\n\n**URL:** https://elysiajs.com/migrate/from-express.md\n\n**Contents:**\n- Performance\n- Routing\n- Handler\n- Subrouter\n- Validation\n- File upload\n- Middleware\n- Sounds type safety\n- Middleware parameter\n- Error handling\n\n---\nurl: 'https://elysiajs.com/migrate/from-express.md'\n---\n\nThis guide is for Express users who want to see the differences from Express including syntax, and how to migrate your application from Express to Elysia by example.\n\n**Express** is a popular web framework for Node.js, and widely used for building web applications and APIs. It is known for its simplicity and flexibility.\n\n**Elysia** is an ergonomic web framework for Bun, Node.js, and runtimes that support Web Standard API. Designed to be ergonomic and developer-friendly with a focus on **sound type safety** and performance.\n\nElysia has significant performance improvements over Express thanks to native Bun implementation, and static code analysis.\n\nExpress and Elysia have similar routing syntax, using `app.get()` and `app.post()` methods to define routes and similar path parameter syntax.\n\n> Express use `req` and `res` as request and response objects\n\n> Elysia use a single `context` and returns the response directly\n\nThere is a slight different in style guide, Elysia recommends usage of method chaining and object destructuring.\n\nElysia also supports an inline value for the response if you don't need to use the context.\n\nBoth has a simliar property for accessing input parameters like `headers`, `query`, `params`, and `body`.\n\n> Express needs `express.json()` middleware to parse JSON body\n\n> Elysia parse JSON, URL-encoded data, and formdata by default\n\nExpress use a dedicated `express.Router()` for declaring a sub router while Elysia treats every instances as a component that can be plug and play together.\n\n> Express use `express.Router()` to create a sub router\n\n> Elysia treat every instances as a component\n\nElysia has a built-in support for request validation using TypeBox sounds type safety, and support for Standard Schema out of the box allowing you to use your favorite library like Zod, Valibot, ArkType, Effect Schema and so on. While Express doesn't offers a built-in validation, and require a manual type declaration based on each validation library.\n\n> Express require external validation library like `zod` or `joi` to validate request body\n\n> Elysia use TypeBox for validation, and coerce type automatically. While supporting various validation library like Zod, Valibot with the same syntax as well.\n\nExpress use an external library `multer` to handle file upload, while Elysia has a built-in support for file and formdata, mimetype valiation using declarative API.\n\n> Express needs `express.json()` middleware to parse JSON body\n\n> Elysia handle file, and mimetype validation declaratively\n\nAs **multer** doesn't validate mimetype, you need to validate the mimetype manually using **file-type** or similar library.\n\nElysia validate file upload, and use **file-type** to validate mimetype automatically.\n\nExpress middleware use a single queue-based order while Elysia give you a more granular control using an **event-based** lifecycle.\n\nElysia's Life Cycle event can be illustrated as the following.\n![Elysia Life Cycle Graph](/assets/lifecycle-chart.svg)\n\n> Click on image to enlarge\n\nWhile Express has a single flow for request pipeline in order, Elysia can intercept each event in a request pipeline.\n\n> Express use a single queue-based order for middleware which execute in order\n\n> Elysia use a specific event interceptor for each point in the request pipeline\n\nWhile Express has a `next` function to call the next middleware, Elysia does not has one.\n\nElysia is designed to be sounds type safety.\n\nFor example, you can customize context in a **type safe** manner using [derive](/essential/life-cycle.html#derive) and [resolve](/essential/life-cycle.html#resolve) while Express doesn't.\n\n> Express use a single queue-based order for middleware which execute in order\n\n> Elysia use a specific event interceptor for each point in the request pipeline\n\nWhile Express can, use `declare module` to extend the `Request` interface, it is globally available and doesn't have sounds type safety, and doesn't garantee that the property is available in all request handlers.\n\n> This is required for the above Express example to work, which doesn't offers sounds type safety\n\nExpress use a function to return a plugin to define a reusable route-specific middleware, while Elysia use [macro](/patterns/macro) to define a custom hook.\n\n> Express use a function callback to accept custom argument for middleware\n\n> Elysia use macro to pass custom argument to custom middleware\n\nExpress use a single error handler for all routes, while Elysia provides a more granular control over error handling.\n\n> Express use middleware to handle error, a single error handler for all routes\n\n> Elysia provide more granular control over error handling, and scoping mechanism\n\nWhile Express offers error handling using middleware, Elysia provide:\n\n1. Both global and route specific error handler\n2. Shorthand for mapping HTTP status and `toResponse` for mapping error to a response\n3. Provide a custom error code for each error\n\nThe error code is useful for logging and debugging, and is important when differentiating between different error types extending the same class.\n\nElysia provides all of this with type safety while Express doesn't.\n\nExpress middleware is registered globally, while Elysia give you a control over side-effect of a plugin via explicit scoping mechanism, and order-of-code.\n\n> Express doesn't handle side-effect of middleware, and requires a prefix to separate the side-effect\n\n> Elysia encapsulate a side-effect into a plugin\n\nBy default, Elysia will encapsulate lifecycle events and context to the instance that is used, so that the side-effect of a plugin will not affect parent instance unless explicitly stated.\n\nElysia offers 3 type of scoping mechanism:\n\n1. **local** - Apply to current instance only, no side-effect (default)\n2. **scoped** - Scoped side-effect to the parent instance but not beyond\n3. **global** - Affects every instances\n\nWhile Express can scope the middleware side-effect by adding a prefix, it isn't a true encapsulation. The side-effect is still there but separated to any routes starts with said prefix, adding a mental overhead to the developer to memorize which prefix has side-effect.\n\nWhich you can do the following:\n\n1. Move order of code from but only if there are a single instance with side-effects.\n2. Add a prefix, but the side-effects are still there. If other instance has the same prefix, then it has the side-effects.\n\nThis can leads to a nightmarish scenario to debug as Express doesn't offers true encapsulation.\n\nExpress use an external library `cookie-parser` to parse cookies, while Elysia has a built-in support for cookie and use a signal-based approach to handle cookies.\n\n> Express use `cookie-parser` to parse cookies\n\n> Elysia use signal-based approach to handle cookies\n\nExpress require a separate configuration for OpenAPI, validation, and type safety while Elysia has a built-in support for OpenAPI using schema as a **single source of truth**.\n\n> Express requires a separate configuration for OpenAPI, validation, and type safety\n\n> Elysia use a schema as a single source of truth\n\nElysia will generate OpenAPI specification based on the schema you provided, and validate the request and response based on the schema, and infer type automatically.\n\nElysia also appends the schema registered in `model` to the OpenAPI spec, allowing you to reference the model in a dedicated section in Swagger or Scalar UI.\n\nExpress use a single `supertest` library to test the application, while Elysia is built on top of Web Standard API allowing it be used with any testing library.\n\n> Express use `supertest` library to test the application\n\n> Elysia use Web Standard API to handle request and response\n\nAlternatively, Elysia also offers a helper library called [Eden](/eden/overview) for End-to-end type safety, allowing us to test with auto-completion, and full type safety.\n\nElysia offers a built-in support for **end-to-end type safety** without code generation using [Eden](/eden/overview), Express doesn't offers one.\n\nIf end-to-end type safety is important for you then Elysia is the right choice.\n\nElysia offers a more ergonomic and developer-friendly experience with a focus on performance, type safety, and simplicity while Express is a popular web framework for Node.js, but it has some limitations when it comes to performance and simplicity.\n\nIf you are looking for a framework that is easy to use, has a great developer experience, and is built on top of Web Standard API, Elysia is the right choice for you.\n\nAlternatively, if you are coming from a different framework, you can check out:\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\n\n> Express use `req` and `res` as request and response objects\n\n::: code-group\n```\n\nExample 2 (unknown):\n```unknown\n:::\n\n\n> Elysia use a single `context` and returns the response directly\n\nThere is a slight different in style guide, Elysia recommends usage of method chaining and object destructuring.\n\nElysia also supports an inline value for the response if you don't need to use the context.\n\n## Handler\n\nBoth has a simliar property for accessing input parameters like `headers`, `query`, `params`, and `body`.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\n\n> Express needs `express.json()` middleware to parse JSON body\n\n::: code-group\n```\n\nExample 4 (unknown):\n```unknown\n:::\n\n\n> Elysia parse JSON, URL-encoded data, and formdata by default\n\n## Subrouter\n\nExpress use a dedicated `express.Router()` for declaring a sub router while Elysia treats every instances as a component that can be plug and play together.\n\n::: code-group\n```\n\n---\n\n## Welcome to ElysiaJS\n\n**URL:** https://elysiajs.com/playground.md\n\n---\nurl: 'https://elysiajs.com/playground.md'\n---\n\nIt's great to have you here! This playground is designed to help you get started with ElysiaJS quickly and easily.\n\nUnlike traditional backend framework, Elysia can also run in a browser! Allowing you to write, and try out Elysia directly in your browser! making it a perfect environment for learning and experimentation.\n\nElysia is an ergonomic web framework for humans.\n\n---\n\n## From tRPC to Elysia\n\n**URL:** https://elysiajs.com/migrate/from-trpc.md\n\n**Contents:**\n- Overview\n- Routing\n- Handler\n- Subrouter\n- Validation\n- File upload\n- Middleware\n- Sounds type safety\n- Middleware parameter\n- Error handling\n\n---\nurl: 'https://elysiajs.com/migrate/from-trpc.md'\n---\n\nThis guide is for tRPC users who want to see a differences from Elysia including syntax, and how to migrate your application from tRPC to Elysia by example.\n\n**tRPC** is a typesafe RPC framework for building APIs using TypeScript. It provides a way to create end-to-end type-safe APIs with type-safe contract between frontend and backend.\n\n**Elysia** is an ergonomic web framework. Designed to be ergonomic and developer-friendly with a focus on **sound type safety** and performance.\n\ntRPC is primarily designed as RPC communication with proprietary abstraction over RESTful API, while Elysia is focused on RESTful API.\n\nMain feature of tRPC is end-to-end type safety contract between frontend and backend which Elysia also offers via [Eden](/eden/overview).\n\nMaking Elysia a better fit for building a universal API with RESTful standard that developers already know instead of learning a new proprietary abstraction while having the end-to-end type safety that tRPC offers.\n\nElysia use a syntax similar to Express, and Hono like `app.get()` and `app.post()` methods to define routes and similar path parameters syntax.\n\nWhile tRPC use a nested router approach to define routes.\n\n> tRPC use nested router and procedure to define routes\n\n> Elysia use HTTP method, and path parameters to define routes\n\nWhile tRPC use proprietary abstraction over RESTful API with procedure and router, Elysia use a syntax similar to Express, and Hono like `app.get()` and `app.post()` methods to define routes and similar path parameters syntax.\n\ntRPC handler is called `procedure` which can be either `query` or `mutation`, while Elysia use HTTP method like `get`, `post`, `put`, `delete` and so on.\n\ntRPC is doesn't have a concept of HTTP property like query, headers, status code, and so on, only `input` and `output`.\n\n> tRPC use single `input` for all properties\n\n> Elysia use specific property for each HTTP property\n\nElysia use **static code analysis** to determine what to parse, and only parse the required properties.\n\nThis is useful for performance and type safety.\n\ntRPC use nested router to define subrouter, while Elysia use `.use()` method to define a subrouter.\n\n> tRPC use nested router to define subrouter\n\n> Elysia use a `.use()` method to define a subrouter\n\nWhile you can inline the subrouter in tRPC, Elysia use `.use()` method to define a subrouter.\n\nBoth support Standard Schema for validation. Allowing you to use various validation library like Zod, Yup, Valibot, and so on.\n\n> tRPC use `input` to define validation schema\n\n> Elysia use specific property to define validation schema\n\nBoth offers type inference from schema to context automatically.\n\ntRPC doesn't support file upload out-of-the-box and require you to use `base64` string as input which is inefficient, and doesn't support mimetype validation.\n\nWhile Elysia has built-in support for file upload using Web Standard API.\n\n> Elysia handle file, and mimetype validation declaratively\n\nAs doesn't validate mimetype out-of-the-box, you need to use a third-party library like `file-type` to validate an actual type.\n\ntRPC middleware use a single queue-based order with `next` similar to Express, while Elysia give you a more granular control using an **event-based** lifecycle.\n\nElysia's Life Cycle event can be illustrated as the following.\n![Elysia Life Cycle Graph](/assets/lifecycle-chart.svg)\n\n> Click on image to enlarge\n\nWhile tRPC has a single flow for request pipeline in order, Elysia can intercept each event in a request pipeline.\n\n> tRPC use a single middleware queue defined as a procedure\n\n> Elysia use a specific event interceptor for each point in the request pipeline\n\nWhile tRPC has a `next` function to call the next middleware in the queue, Elysia use specific event interceptor for each point in the request pipeline.\n\nElysia is designed to be sounds type safety.\n\nFor example, you can customize context in a **type safe** manner using [derive](/essential/life-cycle.html#derive) and [resolve](/essential/life-cycle.html#resolve) while tRPC offers one by using `context` by type case which is doesn't ensure 100% type safety, making it unsounds.\n\n> tRPC use `context` to extend context but doesn't have sounds type safety\n\n> Elysia use a specific event interceptor for each point in the request pipeline\n\nBoth support custom middleware, but Elysia use macro to pass custom argument to custom middleware while tRPC use higher-order-function which is not type safe.\n\n> tRPC use higher-order-function to pass custom argument to custom middleware\n\n> Elysia use macro to pass custom argument to custom middleware\n\ntRPC use middleware-like to handle error, while Elysia provide custom error with type safety, and error interceptor for both global and route specific error handler.\n\n> tRPC use middleware-like to handle error\n\n> Elysia provide more granular control over error handling, and scoping mechanism\n\nWhile tRPC offers error handling using middleware-like, Elysia provide:\n\n1. Both global and route specific error handler\n2. Shorthand for mapping HTTP status and `toResponse` for mapping error to a response\n3. Provide a custom error code for each error\n\nThe error code is useful for logging and debugging, and is important when differentiating between different error types extending the same class.\n\nElysia provides all of this with type safety while tRPC doesn't.\n\ntRPC encapsulate side-effect of a by procedure or router making it always isolated, while Elysia give you a control over side-effect of a plugin via explicit scoping mechanism, and order-of-code.\n\n> tRPC encapsulate side-effect of a plugin into the procedure or router\n\n> Elysia encapsulate side-effect of a plugin unless explicitly stated\n\nBoth has a encapsulate mechanism of a plugin to prevent side-effect.\n\nHowever, Elysia can explicitly stated which plugin should have side-effect by declaring a scoped while Fastify always encapsulate it.\n\nElysia offers 3 type of scoping mechanism:\n\n1. **local** - Apply to current instance only, no side-effect (default)\n2. **scoped** - Scoped side-effect to the parent instance but not beyond\n3. **global** - Affects every instances\n\ntRPC doesn't offers OpenAPI first party, and relying on third-party library like `trpc-to-openapi` which is not a streamlined solution.\n\nWhile Elysia has built-in support for OpenAPI using [@elysiajs/openapi](/plugins/openapi) from a single line of code.\n\n> tRPC rely on third-party library to generate OpenAPI spec\n\n> Elysia seamlessly integrate the specification into the schema\n\ntRPC rely on third-party library to generate OpenAPI spec, and **MUST** require you to define a correct path name and HTTP method in the metadata which is force you to be **consistently aware** of how you place a router, and procedure.\n\nWhile Elysia use schema you provide to generate the OpenAPI specification, and validate the request/response, and infer type automatically all from a **single source of truth**.\n\nElysia also appends the schema registered in `model` to the OpenAPI spec, allowing you to reference the model in a dedicated section in Swagger or Scalar UI while this is missing on tRPC inline the schema to the route.\n\nElysia use Web Standard API to handle request and response while tRPC require a lot of ceremony to run the request using `createCallerFactory`.\n\n> tRPC require `createCallerFactory`, and a lot of ceremony to run the request\n\n> Elysia use Web Standard API to handle request and response\n\nAlternatively, Elysia also offers a helper library called [Eden](/eden/overview) for End-to-end type safety which is similar to `tRPC.createCallerFactory`, allowing us to test with auto-completion, and full type safety like tRPC without the ceremony.\n\nBoth offers end-to-end type safety for client-server communication.\n\n> tRPC use `createTRPCProxyClient` to create a client with end-to-end type safety\n\n> Elysia use `treaty` to run the request, and offers end-to-end type safety\n\nWhile both offers end-to-end type safety, tRPC only handle **happy path** where the request is successful, and doesn't have a type soundness of error handling, making it unsound.\n\nIf type soundness is important for you, then Elysia is the right choice.\n\nWhile tRPC is a great framework for building type-safe APIs, it has its limitations in terms of RESTful compliance, and type soundness.\n\nElysia is designed to be ergonomic and developer-friendly with a focus on developer experience, and **type soundness** complying with RESTful, OpenAPI, and WinterTC Standard making it a better fit for building a universal API.\n\nAlternatively, if you are coming from a different framework, you can check out:\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\n\n> tRPC use nested router and procedure to define routes\n\n::: code-group\n```\n\nExample 2 (unknown):\n```unknown\n:::\n\n\n> Elysia use HTTP method, and path parameters to define routes\n\nWhile tRPC use proprietary abstraction over RESTful API with procedure and router, Elysia use a syntax similar to Express, and Hono like `app.get()` and `app.post()` methods to define routes and similar path parameters syntax.\n\n## Handler\n\ntRPC handler is called `procedure` which can be either `query` or `mutation`, while Elysia use HTTP method like `get`, `post`, `put`, `delete` and so on.\n\ntRPC is doesn't have a concept of HTTP property like query, headers, status code, and so on, only `input` and `output`.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\n\n> tRPC use single `input` for all properties\n\n::: code-group\n```\n\nExample 4 (unknown):\n```unknown\n:::\n\n\n> Elysia use specific property for each HTTP property\n\nElysia use **static code analysis** to determine what to parse, and only parse the required properties.\n\nThis is useful for performance and type safety.\n\n## Subrouter\n\ntRPC use nested router to define subrouter, while Elysia use `.use()` method to define a subrouter.\n\n::: code-group\n```\n\n---\n\n## Quick Start\n\n**URL:** https://elysiajs.com/quick-start.md\n\n**Contents:**\n- Setup\n  - Not on the list?\n\n---\nurl: 'https://elysiajs.com/quick-start.md'\n---\n\nElysia is a TypeScript backend framework with multiple runtime support but optimized for Bun.\n\nHowever, you can use Elysia with other runtimes like Node.js.\n\n\\<Tab\nid=\"quickstart\"\n:names=\"\\['Bun', 'Node.js', 'Web Standard']\"\n:tabs=\"\\['bun', 'node', 'web-standard']\"\n\nElysia is optimized for Bun which is a JavaScript runtime that aims to be a drop-in replacement for Node.js.\n\nYou can install Bun with the command below:\n\n\\<Tab\nid=\"quickstart\"\n:names=\"\\['Auto Installation', 'Manual Installation']\"\n:tabs=\"\\['auto', 'manual']\"\n\nWe recommend starting a new Elysia server using `bun create elysia`, which sets up everything automatically.\n\nOnce done, you should see the folder name `app` in your directory.\n\nStart a development server by:\n\nNavigate to [localhost:3000](http://localhost:3000) should greet you with \"Hello Elysia\".\n\n::: tip\nElysia ships you with `dev` command to automatically reload your server on file change.\n:::\n\nTo manually create a new Elysia app, install Elysia as a package:\n\nThis will install Elysia and Bun type definitions.\n\nCreate a new file `src/index.ts` and add the following code:\n\nOpen your `package.json` file and add the following scripts:\n\nThese scripts refer to the different stages of developing an application:\n\n* **dev** - Start Elysia in development mode with auto-reload on code change.\n* **build** - Build the application for production usage.\n* **start** - Start an Elysia production server.\n\nIf you are using TypeScript, make sure to create, and update `tsconfig.json` to include `compilerOptions.strict` to `true`:\n\nNode.js is a JavaScript runtime for server-side applications, the most popular runtime for JavaScript which Elysia supports.\n\nYou can install Node.js with the command below:\n\nWe recommend using TypeScript for your Node.js project.\n\n\\<Tab\nid=\"language\"\n:names=\"\\['TypeScript', 'JavaScript']\"\n:tabs=\"\\['ts', 'js']\"\n\nTo create a new Elysia app with TypeScript, we recommend installing Elysia with `tsx`:\n\nThis will install Elysia, TypeScript, and `tsx`.\n\n`tsx` is a CLI that transpiles TypeScript to JavaScript with hot-reload and several more feature you expected from a modern development environment.\n\nCreate a new file `src/index.ts` and add the following code:\n\nOpen your `package.json` file and add the following scripts:\n\nThese scripts refer to the different stages of developing an application:\n\n* **dev** - Start Elysia in development mode with auto-reload on code change.\n* **build** - Build the application for production usage.\n* **start** - Start an Elysia production server.\n\nMake sure to create `tsconfig.json`\n\nDon't forget to update `tsconfig.json` to include `compilerOptions.strict` to `true`:\n\n::: warning\nIf you use Elysia without TypeScript you may miss out on some features like auto-completion, advanced type checking and end-to-end type safety, which are the core features of Elysia.\n:::\n\nTo create a new Elysia app with JavaScript, starts by installing Elysia:\n\nThis will install Elysia, TypeScript, and `tsx`.\n\n`tsx` is a CLI that transpiles TypeScript to JavaScript with hot-reload and several more feature you expected from a modern development environment.\n\nCreate a new file `src/index.ts` and add the following code:\n\nOpen your `package.json` file and add the following scripts:\n\nThese scripts refer to the different stages of developing an application:\n\n* **dev** - Start Elysia in development mode with auto-reload on code change.\n* **start** - Start an Elysia production server.\n\nMake sure to create `tsconfig.json`\n\nDon't forget to update `tsconfig.json` to include `compilerOptions.strict` to `true`:\n\nElysia is a WinterCG compliance library, which means if a framework or runtime supports Web Standard Request/Response, it can run Elysia.\n\nFirst, install Elysia with the command below:\n\nNext, select a runtime that supports Web Standard Request/Response.\n\nWe have a few recommendations:\n\nIf you are using a custom runtime, you may access `app.fetch` to handle the request and response manually.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\n\\<Tab\nid=\"quickstart\"\n:names=\"\\['Auto Installation', 'Manual Installation']\"\n:tabs=\"\\['auto', 'manual']\"\n\n>\n\nWe recommend starting a new Elysia server using `bun create elysia`, which sets up everything automatically.\n```\n\nExample 2 (unknown):\n```unknown\nOnce done, you should see the folder name `app` in your directory.\n```\n\nExample 3 (unknown):\n```unknown\nStart a development server by:\n```\n\nExample 4 (unknown):\n```unknown\nNavigate to [localhost:3000](http://localhost:3000) should greet you with \"Hello Elysia\".\n\n::: tip\nElysia ships you with `dev` command to automatically reload your server on file change.\n:::\n\nTo manually create a new Elysia app, install Elysia as a package:\n```\n\n---\n\n## From Hono to Elysia\n\n**URL:** https://elysiajs.com/migrate/from-hono.md\n\n**Contents:**\n- When to use\n- Performance\n- Routing\n- Handler\n- Subrouter\n- Validation\n- File upload\n- Middleware\n- Sounds type safety\n- Middleware parameter\n\n---\nurl: 'https://elysiajs.com/migrate/from-hono.md'\n---\n\nThis guide is for Hono users who want to see a differences from Elysia including syntax, and how to migrate your application from Hono to Elysia by example.\n\n**Hono** is a fast and lightweight web framework built on Web Standard. It has broad compatibility with multiple runtimes like Deno, Bun, Cloudflare Workers, and Node.js.\n\n**Elysia** is an ergonomic web framework. Designed for developer experience with a focus on **sound type safety** and performance. Not limited to Bun, Elysia also supports multiple runtimes like Node.js, and Cloudflare Workers.\n\nHere's a TLDR comparison between Hono and Elysia to help you decide:\n\n* **Originally built for Cloudflare Workers**, more integrated with Cloudflare ecosystem\n* Support multiple runtime with Web Standard, including **Node.js** and **Bun**\n* Lightweight and minimalistic, suitable for edge environment\n* Support OpenAPI but require additional effort to describe the specification\n* Prefers simple, linear middleware-based approach\n* Type safety is better than most frameworks, but not sound in some areas\n* Somewhat similar to Express, Koa in terms of middleware, plugin style\n\n* **Originally built for native Bun**, use most of Bun features to the fullest extent\n* Support multiple runtime with Web Standard, including **Node.sjs** and **Cloudflare Worker**\n* **Better performance**. Leans to long running server via JIT.\n* **Better OpenAPI supports** with seamless experience, especially with [OpenAPI Type Gen](/patterns/openapi#openapi-from-types)\n* Prefers event-based lifecycle approach for better control over request pipeline\n* Sounds type safety across the board, including middleware, and error handling\n* Somewhat similar to Fastify in terms of middleware, encapsulation, and plugin style\n\nThere is a huge **different between being compatible and specifically built for** something.\n\nIf you decide to use Elysia on Cloudflare Workers, you might miss some of the Cloudflare specific features that Hono provides out of the box. Similarly, if you use Hono on Bun, you might not get the best performance possible compared to using Elysia.\n\nElysia has significant performance improvements over Hono thanks to static code analysis.\n\nHono and Elysia has similar routing syntax, using `app.get()` and `app.post()` methods to define routes and similar path parameters syntax.\n\nBoth use a single `Context` parameters to handle request and response, and return a response directly.\n\n> Hono use helper `c.text`, `c.json` to return a response\n\n> Elysia use a single `context` and returns the response directly\n\nWhile Hono use a `c.text`, and `c.json` to warp a response, Elysia map a value to a response automatically.\n\nThere is a slight different in style guide, Elysia recommends usage of method chaining and object destructuring.\n\nHono port allocation is depends on runtime, and adapter while Elysia use a single `listen` method to start the server.\n\nHono use a function to parse query, header, and body manually while Elysia automatically parse properties.\n\n> Hono parse body automatically but it doesn't apply to query and headers\n\n> Elysia use static code analysis to analyze what to parse\n\nElysia use **static code analysis** to determine what to parse, and only parse the required properties.\n\nThis is useful for performance and type safety.\n\nBoth can inherits another instance as a router, but Elysia treat every instances as a component which can be used as a subrouter.\n\n> Hono **require** a prefix to separate the subrouter\n\n> Elysia use optional prefix constructor to define one\n\nWhile Hono requires a prefix to separate the subrouter, Elysia doesn't require a prefix to separate the subrouter.\n\nWhile Hono supports for various validator via external package, Elysia has a built-in validation using **TypeBox**, and support for Standard Schema out of the box allowing you to use your favorite library like Zod, Valibot, ArkType, Effect Schema and so on without additional library. Elysia also offers seamless integration with OpenAPI, and type inference behind the scene.\n\n> Hono use pipe based\n\n> Elysia use TypeBox for validation, and coerce type automatically. While supporting various validation library like Zod, Valibot with the same syntax as well.\n\nBoth offers type inference from schema to context automatically.\n\nBoth Hono, and Elysia use Web Standard API to handle file upload, but Elysia has a built-in declarative support for file validation using **file-type** to validate mimetype.\n\n> Hono needs a separate `file-type` library to validate mimetype\n\n> Elysia handle file, and mimetype validation declaratively\n\nAs Web Standard API doesn't validate mimetype, it is a security risk to trust `content-type` provided by the client so external library is required for Hono, while Elysia use `file-type` to validate mimetype automatically.\n\nHono middleware use a single queue-based order similar to Express while Elysia give you a more granular control using an **event-based** lifecycle.\n\nElysia's Life Cycle event can be illustrated as the following.\n![Elysia Life Cycle Graph](/assets/lifecycle-chart.svg)\n\n> Click on image to enlarge\n\nWhile Hono has a single flow for request pipeline in order, Elysia can intercept each event in a request pipeline.\n\n> Hono use a single queue-based order for middleware which execute in order\n\n> Elysia use a specific event interceptor for each point in the request pipeline\n\nWhile Hono has a `next` function to call the next middleware, Elysia does not has one.\n\nElysia is designed to be sounds type safety.\n\nFor example, you can customize context in a **type safe** manner using [derive](/essential/life-cycle.html#derive) and [resolve](/essential/life-cycle.html#resolve) while Hono doesn't.\n\n> Hono use a middleware to extend the context, but is not type safe\n\n> Elysia use a specific event interceptor for each point in the request pipeline\n\nWhile Hono can, use `declare module` to extend the `ContextVariableMap` interface, it is globally available and doesn't have sounds type safety, and doesn't garantee that the property is available in all request handlers.\n\n> This is required for the above Hono example to work, which doesn't offers sounds type safety\n\nHono use a callback function to define a reusable route-specific middleware, while Elysia use [macro](/patterns/macro) to define a custom hook.\n\n> Hono use callback to return `createMiddleware` to create a reusable middleware, but is not type safe\n\n> Elysia use macro to pass custom argument to custom middleware\n\nHono provide a `onError` function which apply to all routes while Elysia provides a more granular control over error handling.\n\n> Hono use `onError` funcition to handle error, a single error handler for all routes\n\n> Elysia provide more granular control over error handling, and scoping mechanism\n\nWhile Hono offers error handling using middleware-like, Elysia provide:\n\n1. Both global and route specific error handler\n2. Shorthand for mapping HTTP status and `toResponse` for mapping error to a response\n3. Provide a custom error code for each error\n\nThe error code is useful for logging and debugging, and is important when differentiating between different error types extending the same class.\n\nElysia provides all of this with type safety while Hono doesn't.\n\nHono encapsulate plugin side-effect, while Elysia give you a control over side-effect of a plugin via explicit scoping mechanism, and order-of-code.\n\n> Hono encapsulate side-effect of a plugin\n\n> Elysia encapsulate side-effect of a plugin unless explicitly stated\n\nBoth has a encapsulate mechanism of a plugin to prevent side-effect.\n\nHowever, Elysia can explicitly stated which plugin should have side-effect by declaring a scoped while Hono always encapsulate it.\n\nElysia offers 3 type of scoping mechanism:\n\n1. **local** - Apply to current instance only, no side-effect (default)\n2. **scoped** - Scoped side-effect to the parent instance but not beyond\n3. **global** - Affects every instances\n\nAs Hono doesn't offers a scoping mechanism, we need to either:\n\n1. Create a function for each hooks and append them manually\n2. Use higher-order-function, and apply it to instance that need the effect\n\nHowever, this can caused a duplicated side-effect if not handled carefully.\n\nIn this scenario, Elysia offers a plugin deduplication mechanism to prevent duplicated side-effect.\n\nBy using a unique `name`, Elysia will apply the plugin only once, and will not cause duplicated side-effect.\n\nHono has a built-in cookie utility functions under `hono/cookie`, while Elysia use a signal-based approach to handle cookies.\n\n> Hono use utility functions to handle cookies\n\n> Elysia use signal-based approach to handle cookies\n\nHono require additional effort to describe the specification, while Elysia seamless integrate the specification into the schema.\n\n> Hono require additional effort to describe the specification\n\n> Elysia seamlessly integrate the specification into the schema\n\nHono has separate function to describe route specification, validation, and require some effort to setup properly.\n\nElysia use schema you provide to generate the OpenAPI specification, and validate the request/response, and infer type automatically all from a **single source of truth**.\n\nElysia also appends the schema registered in `model` to the OpenAPI spec, allowing you to reference the model in a dedicated section in Swagger or Scalar UI while Hono inline the schema to the route.\n\nBoth is built on top of Web Standard API allowing it be used with any testing library.\n\n> Hono has a built-in `request` method to run the request\n\n> Elysia use Web Standard API to handle request and response\n\nAlternatively, Elysia also offers a helper library called [Eden](/eden/overview) for End-to-end type safety, allowing us to test with auto-completion, and full type safety.\n\nBoth offers end-to-end type safety, however Hono doesn't seems to offers type-safe error handling based on status code.\n\n> Hono use `hc` to run the request, and offers end-to-end type safety\n\n> Elysia use `treaty` to run the request, and offers end-to-end type safety\n\nWhile both offers end-to-end type safety, Elysia offers a more type-safe error handling based on status code while Hono doesn't.\n\nUsing the same purpose code for each framework to measure type inference speed, Elysia is 2.3x faster than Hono for type checking.\n\n![Elysia eden type inference performance](/migrate/elysia-type-infer.webp)\n\n> Elysia take 536ms to infer both Elysia, and Eden (click to enlarge)\n\n![Hono HC type inference performance](/migrate/hono-type-infer.webp)\n\n> Hono take 1.27s to infer both Hono, and HC with error (aborted) (click to enlarge)\n\nThe 1.27 seconds doesn't reflect the entire duration of the inference, but a duration from start to aborted by error **\"Type instantiation is excessively deep and possibly infinite.\"** which happens when there are too large schema.\n\n![Hono HC code showing excessively deep error](/migrate/hono-hc-infer.webp)\n\n> Hono HC showing excessively deep error\n\nThis is caused by the large schema, and Hono doesn't support over a 100 routes with complex body, and response validation while Elysia doesn't have this issue.\n\n![Elysia Eden code showing type inference without error](/migrate/elysia-eden-infer.webp)\n\n> Elysia Eden code showing type inference without error\n\nElysia has a faster type inference performance, and doesn't have **\"Type instantiation is excessively deep and possibly infinite.\"** *at least* up to 2,000 routes with complex body, and response validation.\n\nIf end-to-end type safety is important for you then Elysia is the right choice.\n\nBoth are the next generation web framework built on top of Web Standard API with slight differences.\n\nElysia is designed to be ergonomic and developer-friendly with a focus on **sounds type safety**, and has better performance than Hono.\n\nWhile Hono offers a broad compatibility with multiple runtimes, especially with Cloudflare Workers, and a larger user base.\n\nAlternatively, if you are coming from a different framework, you can check out:\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n:::\n\n\n> Hono use helper `c.text`, `c.json` to return a response\n\n::: code-group\n```\n\nExample 2 (unknown):\n```unknown\n:::\n\n\n> Elysia use a single `context` and returns the response directly\n\nWhile Hono use a `c.text`, and `c.json` to warp a response, Elysia map a value to a response automatically.\n\nThere is a slight different in style guide, Elysia recommends usage of method chaining and object destructuring.\n\nHono port allocation is depends on runtime, and adapter while Elysia use a single `listen` method to start the server.\n\n## Handler\n\nHono use a function to parse query, header, and body manually while Elysia automatically parse properties.\n\n::: code-group\n```\n\nExample 3 (unknown):\n```unknown\n:::\n\n\n> Hono parse body automatically but it doesn't apply to query and headers\n\n::: code-group\n```\n\nExample 4 (unknown):\n```unknown\n:::\n\n\n> Elysia use static code analysis to analyze what to parse\n\nElysia use **static code analysis** to determine what to parse, and only parse the required properties.\n\nThis is useful for performance and type safety.\n\n## Subrouter\n\nBoth can inherits another instance as a router, but Elysia treat every instances as a component which can be used as a subrouter.\n\n::: code-group\n```\n\n---\n\n## Comparison with Other Frameworks\n\n**URL:** https://elysiajs.com/migrate.md\n\n---\nurl: 'https://elysiajs.com/migrate.md'\n---\n# Comparison with Other Frameworks\n\nElysia is designed to be intuitive and easy to use, especially for those familiar with other web frameworks.\n\nIf you have used other popular frameworks like Express, Fastify, or Hono, you will find Elysia right at home with just a few differences.\n\n---\n",
        "plugins/coding/elysia/skills/elysia/references/plugins.md": "# Elysia - Plugins\n\n**Pages:** 13\n\n---\n\n## OpenTelemetry\n\n**URL:** https://elysiajs.com/plugins/opentelemetry.md\n\n**Contents:**\n- Usage\n- Config\n  - autoDetectResources - boolean\n  - contextManager - ContextManager\n  - textMapPropagator - TextMapPropagator\n  - metricReader - MetricReader\n  - views - View\\[]\n  - instrumentations - (Instrumentation | Instrumentation\\[])\\[]\n  - resource - IResource\n  - resourceDetectors - Array\\<Detector | DetectorSync>\n\n---\nurl: 'https://elysiajs.com/plugins/opentelemetry.md'\n---\n\n::: tip\nThis page is a **config reference** for **OpenTelemetry**, if you're looking to setup and integrate with OpenTelemetry, we recommended taking a look at [Integrate with OpenTelemetry](/patterns/opentelemetry) instead.\n:::\n\nTo start using OpenTelemetry, install `@elysiajs/opentelemetry` and apply plugin to any instance.\n\n![jaeger showing collected trace automatically](/blog/elysia-11/jaeger.webp)\n\nElysia OpenTelemetry is will **collect span of any library compatible OpenTelemetry standard**, and will apply parent and child span automatically.\n\nSee [opentelemetry](/patterns/opentelemetry) for usage and utilities\n\nThis plugin extends OpenTelemetry SDK parameters options.\n\nBelow is a config which is accepted by the plugin\n\nDetect resources automatically from the environment using the default resource detectors.\n\nUse a custom context manager.\n\ndefault: `AsyncHooksContextManager`\n\nUse a custom propagator.\n\ndefault: `CompositePropagator` using W3C Trace Context and Baggage\n\nAdd a MetricReader that will be passed to the MeterProvider.\n\nA list of views to be passed to the MeterProvider.\n\nAccepts an array of View-instances. This parameter can be used to configure explicit bucket sizes of histogram metrics.\n\nConfigure instrumentations.\n\nBy default `getNodeAutoInstrumentations` is enabled, if you want to enable them you can use either metapackage or configure each instrumentation individually.\n\ndefault: `getNodeAutoInstrumentations()`\n\nConfigure a resource.\n\nResources may also be detected by using the autoDetectResources method of the SDK.\n\nConfigure resource detectors. By default, the resource detectors are \\[envDetector, processDetector, hostDetector]. NOTE: In order to enable the detection, the parameter autoDetectResources has to be true.\n\nIf resourceDetectors was not set, you can also use the environment variable OTEL\\_NODE\\_RESOURCE\\_DETECTORS to enable only certain detectors, or completely disable them:\n\n* env\n* host\n* os\n* process\n* serviceinstance (experimental)\n* all - enable all resource detectors above\n* none - disable resource detection\n\nFor example, to enable only the env, host detectors:\n\nConfigure a custom sampler. By default, all traces will be sampled.\n\nNamespace to be identify as.\n\nAn array of span processors to register to the tracer provider.\n\nConfigure a trace exporter. If an exporter is configured, it will be used with a `BatchSpanProcessor`.\n\nIf an exporter OR span processor is not configured programmatically, this package will auto setup the default otlp exporter with http/protobuf protocol with a BatchSpanProcessor.\n\nConfigure tracing parameters. These are the same trace parameters used to configure a tracer.\n\n**Examples:**\n\nExample 1 (unknown):\n```unknown\n![jaeger showing collected trace automatically](/blog/elysia-11/jaeger.webp)\n\nElysia OpenTelemetry is will **collect span of any library compatible OpenTelemetry standard**, and will apply parent and child span automatically.\n\n## Usage\n\nSee [opentelemetry](/patterns/opentelemetry) for usage and utilities\n\n## Config\n\nThis plugin extends OpenTelemetry SDK parameters options.\n\nBelow is a config which is accepted by the plugin\n\n### autoDetectResources - boolean\n\nDetect resources automatically from the environment using the default resource detectors.\n\ndefault: `true`\n\n### contextManager - ContextManager\n\nUse a custom context manager.\n\ndefault: `AsyncHooksContextManager`\n\n### textMapPropagator - TextMapPropagator\n\nUse a custom propagator.\n\ndefault: `CompositePropagator` using W3C Trace Context and Baggage\n\n### metricReader - MetricReader\n\nAdd a MetricReader that will be passed to the MeterProvider.\n\n### views - View\\[]\n\nA list of views to be passed to the MeterProvider.\n\nAccepts an array of View-instances. This parameter can be used to configure explicit bucket sizes of histogram metrics.\n\n### instrumentations - (Instrumentation | Instrumentation\\[])\\[]\n\nConfigure instrumentations.\n\nBy default `getNodeAutoInstrumentations` is enabled, if you want to enable them you can use either metapackage or configure each instrumentation individually.\n\ndefault: `getNodeAutoInstrumentations()`\n\n### resource - IResource\n\nConfigure a resource.\n\nResources may also be detected by using the autoDetectResources method of the SDK.\n\n### resourceDetectors - Array\\<Detector | DetectorSync>\n\nConfigure resource detectors. By default, the resource detectors are \\[envDetector, processDetector, hostDetector]. NOTE: In order to enable the detection, the parameter autoDetectResources has to be true.\n\nIf resourceDetectors was not set, you can also use the environment variable OTEL\\_NODE\\_RESOURCE\\_DETECTORS to enable only certain detectors, or completely disable them:\n\n* env\n* host\n* os\n* process\n* serviceinstance (experimental)\n* all - enable all resource detectors above\n* none - disable resource detection\n\nFor example, to enable only the env, host detectors:\n```\n\n---\n\n## Overview\n\n**URL:** https://elysiajs.com/plugins/overview.md\n\n**Contents:**\n- Official plugins\n- Community plugins\n- Complementary projects:\n\n---\nurl: 'https://elysiajs.com/plugins/overview.md'\n---\n\nElysia is designed to be modular and lightweight.\n\nFollowing the same idea as Arch Linux (btw, I use Arch):\n\n> Design decisions are made on a case-by-case basis through developer consensus\n\nThis is to ensure developers end up with a performant web server they intend to create. By extension, Elysia includes pre-built common pattern plugins for convenient developer usage:\n\nHere are some of the official plugins maintained by the Elysia team:\n\n* [Bearer](/plugins/bearer) - retrieve [Bearer](https://swagger.io/docs/specification/authentication/bearer-authentication/) token automatically\n* [CORS](/plugins/cors) - set up [Cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)\n* [Cron](/plugins/cron) - set up [cron](https://en.wikipedia.org/wiki/Cron) job\n* [Eden](/eden/overview) - end-to-end type safety client for Elysia\n* [GraphQL Apollo](/plugins/graphql-apollo) - run [Apollo GraphQL](https://www.apollographql.com/) on Elysia\n* [GraphQL Yoga](/plugins/graphql-yoga) - run [GraphQL Yoga](https://github.com/dotansimha/graphql-yoga) on Elysia\n* [HTML](/plugins/html) - handle HTML responses\n* [JWT](/plugins/jwt) - authenticate with [JWTs](https://jwt.io/)\n* [OpenAPI](/plugins/openapi) - generate an [OpenAPI](https://swagger.io/specification/) documentation\n* [OpenTelemetry](/plugins/opentelemetry) - add support for OpenTelemetry\n* [Server Timing](/plugins/server-timing) - audit performance bottlenecks with the [Server-Timing API](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing)\n* [Static](/plugins/static) - serve static files/folders\n\n* [Create ElysiaJS](https://github.com/kravetsone/create-elysiajs) - scaffold your Elysia project with the environment easily (help with ORM, Linters and Plugins)!\n* [Lucia Auth](https://github.com/pilcrowOnPaper/lucia) - authentication, simple and clean\n* [Elysia Clerk](https://github.com/wobsoriano/elysia-clerk) - unofficial Clerk authentication plugin\n* [Elysia Polyfills](https://github.com/bogeychan/elysia-polyfills) - run Elysia ecosystem on Node.js and Deno\n* [Vite server](https://github.com/kravetsone/elysia-vite-server) - plugin which starts and decorates [`vite`](https://vitejs.dev/) dev server in `development` and in `production` mode serves static files (if needed)\n* [Vite](https://github.com/timnghg/elysia-vite) - serve entry HTML file with Vite's scripts injected\n* [Nuxt](https://github.com/trylovetom/elysiajs-nuxt) - easily integrate Elysia with Nuxt!\n* [Remix](https://github.com/kravetsone/elysia-remix) - use [Remix](https://remix.run/) with `HMR` support (powered by [`vite`](https://vitejs.dev/))! Close a really long-standing plugin request [#12](https://github.com/elysiajs/elysia/issues/12)\n* [Sync](https://github.com/johnny-woodtke/elysiajs-sync) - a lightweight offline-first data synchronization framework powered by [Dexie.js](https://dexie.org/)\n* [Connect middleware](https://github.com/kravetsone/elysia-connect-middleware) - plugin which allows you to use [`express`](https://www.npmjs.com/package/express)/[`connect`](https://www.npmjs.com/package/connect) middleware directly in Elysia!\n* [Elysia HTTP Exception](https://github.com/codev911/elysia-http-exception) - Elysia plugin for HTTP 4xx/5xx error handling with structured exception classes\n* [Elysia Helmet](https://github.com/DevTobias/elysia-helmet) - secure Elysia apps with various HTTP headers\n* [Vite Plugin SSR](https://github.com/timnghg/elysia-vite-plugin-ssr) - Vite SSR plugin using Elysia server\n* [OAuth 2.0](https://github.com/kravetsone/elysia-oauth2) - a plugin for [OAuth 2.0](https://en.wikipedia.org/wiki/OAuth) Authorization Flow with more than **42** providers and **type-safety**!\n* [OAuth2](https://github.com/bogeychan/elysia-oauth2) - handle OAuth 2.0 authorization code flow\n* [OAuth2 Resource Server](https://github.com/ap-1/elysia-oauth2-resource-server) - a plugin for validating JWT tokens from OAuth2 providers against JWKS endpoints with support for issuer, audience, and scope verification\n* [Elysia OpenID Client](https://github.com/macropygia/elysia-openid-client) - OpenID client based on [openid-client](https://github.com/panva/node-openid-client)\n* [Rate Limit](https://github.com/rayriffy/elysia-rate-limit) - simple, lightweight rate limiter\n* [Logysia](https://github.com/tristanisham/logysia) - classic logging middleware\n* [Logestic](https://github.com/cybercoder-naj/logestic) - an advanced and customisable logging library for ElysiaJS\n* [Logger](https://github.com/bogeychan/elysia-logger) - [pino](https://github.com/pinojs/pino)-based logging middleware\n* [Elysia Line](https://github.com/KrataiB/elysia-line) - LINE Messaging API and LINE Login integration for Elysia (wrapper around the official [@line/bot-sdk](https://github.com/line/line-bot-sdk-nodejs))\n* [Elylog](https://github.com/eajr/elylog) - simple stdout logging library with some customization\n* [Logify for Elysia.js](https://github.com/0xrasla/logify) - a beautiful, fast, and type-safe logging middleware for Elysia.js applications\n* [Nice Logger](https://github.com/tanishqmanuja/nice-logger) - not the nicest, but a pretty nice and sweet logger for Elysia.\n* [Sentry](https://github.com/johnny-woodtke/elysiajs-sentry) - capture traces and errors with this [Sentry](https://docs.sentry.io/) plugin\n* [Elysia Lambda](https://github.com/TotalTechGeek/elysia-lambda) - deploy on AWS Lambda\n* [Decorators](https://github.com/gaurishhs/elysia-decorators) - use TypeScript decorators\n* [Autoload](https://github.com/kravetsone/elysia-autoload) - filesystem router based on a directory structure that generates types for [Eden](/eden/overview) with [`Bun.build`](https://github.com/kravetsone/elysia-autoload?tab=readme-ov-file#bun-build-usage) support\n* [Msgpack](https://github.com/kravetsone/elysia-msgpack) - allows you to work with [MessagePack](https://msgpack.org)\n* [XML](https://github.com/kravetsone/elysia-xml) - allows you to work with XML\n* [Autoroutes](https://github.com/wobsoriano/elysia-autoroutes) - filesystem routes\n* [Group Router](https://github.com/itsyoboieltr/elysia-group-router) - filesystem and folder-based router for groups\n* [Basic Auth](https://github.com/itsyoboieltr/elysia-basic-auth) - basic HTTP authentication\n* [ETag](https://github.com/bogeychan/elysia-etag) - automatic HTTP [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) generation\n* [CDN Cache](https://github.com/johnny-woodtke/elysiajs-cdn-cache) - Cache-Control plugin for Elysia - no more manually setting HTTP headers\n* [Basic Auth](https://github.com/eelkevdbos/elysia-basic-auth) - basic HTTP authentication (using `request` event)\n* [i18n](https://github.com/eelkevdbos/elysia-i18next) - [i18n](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/i18n) wrapper based on [i18next](https://www.i18next.com/)\n* [Intlify](https://github.com/intlify/srvmid/blob/main/packages/elysia/README.md) - Internationalization server middleware & utilities\n* [Elysia Request ID](https://github.com/gtramontina/elysia-requestid) - add/forward request IDs (`X-Request-ID` or custom)\n* [Elysia HTMX](https://github.com/gtramontina/elysia-htmx) - context helpers for [HTMX](https://htmx.org/)\n* [Elysia HMR HTML](https://github.com/gtrabanco/elysia-hmr-html) - reload HTML files when changing any file in a directory\n* [Elysia Inject HTML](https://github.com/gtrabanco/elysia-inject-html) - inject HTML code in HTML files\n* [Elysia HTTP Error](https://github.com/yfrans/elysia-http-error) - return HTTP errors from Elysia handlers\n* [Elysia Http Status Code](https://github.com/sylvain12/elysia-http-status-code) - integrate HTTP status codes\n* [NoCache](https://github.com/gaurishhs/elysia-nocache) - disable caching\n* [Elysia Tailwind](https://github.com/gtramontina/elysia-tailwind) - compile [Tailwindcss](https://tailwindcss.com/) in a plugin.\n* [Elysia Compression](https://github.com/gusb3ll/elysia-compression) - compress response\n* [Elysia IP](https://github.com/gaurishhs/elysia-ip) - get the IP Address\n* [OAuth2 Server](https://github.com/myazarc/elysia-oauth2-server) - developing an OAuth2 Server with Elysia\n* [Elysia Flash Messages](https://github.com/gtramontina/elysia-flash-messages) - enable flash messages\n* [Elysia AuthKit](https://github.com/gtramontina/elysia-authkit) - unnoficial [WorkOS' AuthKit](https://www.authkit.com/) authentication\n* [Elysia Error Handler](https://github.com/gtramontina/elysia-error-handler) - simpler error handling\n* [Elysia env](https://github.com/yolk-oss/elysia-env) - typesafe environment variables with typebox\n* [Elysia Drizzle Schema](https://github.com/Edsol/elysia-drizzle-schema) - helps to use Drizzle ORM schema inside Elysia OpenAPI model.\n* [Unify-Elysia](https://github.com/qlaffont/unify-elysia) - unify error code for Elysia\n* [Unify-Elysia-GQL](https://github.com/qlaffont/unify-elysia-gql) - unify error code for Elysia GraphQL Server (Yoga & Apollo)\n* [Elysia Auth Drizzle](https://github.com/qlaffont/elysia-auth-drizzle) - library who handle authentification with JWT (Header/Cookie/QueryParam).\n* [graceful-server-elysia](https://github.com/qlaffont/graceful-server-elysia) - library inspired by [graceful-server](https://github.com/gquittet/graceful-server).\n* [Logixlysia](https://github.com/PunGrumpy/logixlysia) - a beautiful and simple logging middleware for ElysiaJS with colors and timestamps.\n* [Elysia Fault](https://github.com/vitorpldev/elysia-fault) - a simple and customizable error handling middleware with the possibility of creating your own HTTP errors\n* [Elysia Compress](https://github.com/vermaysha/elysia-compress) - ElysiaJS plugin to compress responses inspired by [@fastify/compress](https://github.com/fastify/fastify-compress)\n* [@labzzhq/compressor](https://github.com/labzzhq/compressor/) - Compact Brilliance, Expansive Results: HTTP Compressor for Elysia and Bunnyhop with gzip, deflate and brotli support.\n* [Elysia Accepts](https://github.com/morigs/elysia-accepts) - Elysia plugin for accept headers parsing and content negotiation\n* [Elysia Compression](https://github.com/chneau/elysia-compression) - Elysia plugin for compressing responses\n* [Elysia Logger](https://github.com/chneau/elysia-logger) - Elysia plugin for logging HTTP requests and responses inspired by [hono/logger](https://hono.dev/docs/middleware/builtin/logger)\n* [Elysia CQRS](https://github.com/jassix/elysia-cqrs) - Elysia plugin for CQRS pattern\n* [Elysia Supabase](https://github.com/mastermakrela/elysia-supabase) - Seamlessly integrate [Supabase](https://supabase.com/) authentication and database functionality into Elysia, allowing easy access to authenticated user data and Supabase client instance. Especially useful for [Edge Functions](https://supabase.com/docs/guides/functions).\n* [Elysia XSS](https://www.npmjs.com/package/elysia-xss) - a plugin for Elysia.js that provides XSS (Cross-Site Scripting) protection by sanitizing request body data.\n* [Elysiajs Helmet](https://www.npmjs.com/package/elysiajs-helmet) - a comprehensive security middleware for Elysia.js applications that helps secure your apps by setting various HTTP headers.\n* [Decorators for Elysia.js](https://github.com/Ateeb-Khan-97/better-elysia) - seamlessly develop and integrate APIs, Websocket and Streaming APIs with this small library.\n* [Elysia Protobuf](https://github.com/ilyhalight/elysia-protobuf) - support protobuf for Elysia.\n* [Elysia Prometheus](https://github.com/m1handr/elysia-prometheus) - Elysia plugin for exposing HTTP metrics for Prometheus.\n* [Elysia Remote DTS](https://github.com/rayriffy/elysia-remote-dts) - A plugin that provide .d.ts types remotely for Eden Treaty to consume.\n* [Cap Checkpoint plugin for Elysia](https://capjs.js.org/guide/middleware/elysia.html) - Cloudflare-like middleware for Cap, a lightweight, modern open-source CAPTCHA alternative designed using SHA-256 PoW.\n* [Elysia Background](https://github.com/staciax/elysia-background) - A background task processing plugin for Elysia.js\n* [@fedify/elysia](https://github.com/fedify-dev/fedify/tree/main/packages/elysia) - A plugin that provides seamless integration with [Fedify](https://fedify.dev/), the ActivityPub server framework.\n* [elysia-healthcheck](https://github.com/iam-medvedev/elysia-healthcheck) - Healthcheck plugin for Elysia.js\n* [elysia-csrf](https://github.com/lauhon/elysia-csrf) - A CSRF plugin, ported from [express-csrf](https://github.com/expressjs/csurf)\n* [elysia-local-https](https://github.com/mrtcmn/elysia-local-https) - Automatic local HTTPS for Elysia — certs generated, managed, and refreshed in one line.\n* [Eden TanStack Query](https://github.com/xkelxmc/eden-tanstack-query) - type-safe TanStack Query integration for Eden, like\n  @trpc/react-query but for Elysia\n\n* [prismabox](https://github.com/m1212e/prismabox) - Generator for typebox schemes based on your database models, works well with elysia\n\nIf you have a plugin written for Elysia, feel free to add your plugin to the list by **clicking Edit this page on GitHub** below 👇\n\n---\n\n## HTML Plugin\n\n**URL:** https://elysiajs.com/plugins/html.md\n\n**Contents:**\n- JSX\n- XSS\n- Options\n  - contentType\n  - autoDetect\n  - autoDoctype\n  - isHtml\n\n---\nurl: 'https://elysiajs.com/plugins/html.md'\n---\n\nAllows you to use [JSX](#jsx) and HTML with proper headers and support.\n\nThis plugin will automatically add `Content-Type: text/html; charset=utf8` header to the response, add `<!doctype html>`, and convert it into a Response object.\n\nElysia HTML is based on [@kitajs/html](https://github.com/kitajs/html) allowing us to define JSX to string in compile time to achieve high performance.\n\nName your file that needs to use JSX to end with affix **\"x\"**:\n\n* .js -> .jsx\n* .ts -> .tsx\n\nTo register the TypeScript type, please append the following to **tsconfig.json**:\n\nThat's it, now you can use JSX as your template engine:\n\nIf the error `Cannot find name 'Html'. Did you mean 'html'?` occurs, this import must be added to the JSX template:\n\nIt is important that it is written in uppercase.\n\nElysia HTML is based use of the Kita HTML plugin to detect possible XSS attacks in compile time.\n\nYou can use a dedicated `safe` attribute to sanitize user value to prevent XSS vulnerability.\n\nHowever, when are building a large-scale app, it's best to have a type reminder to detect possible XSS vulnerabilities in your codebase.\n\nTo add a type-safe reminder, please install:\n\nThen appends the following **tsconfig.json**\n\n* Type: `string`\n* Default: `'text/html; charset=utf8'`\n\nThe content-type of the response.\n\n* Type: `boolean`\n* Default: `true`\n\nWhether to automatically detect HTML content and set the content-type.\n\n* Type: `boolean | 'full'`\n* Default: `true`\n\nWhether to automatically add `<!doctype html>` to a response starting with `<html>`, if not found.\n\nUse `full` to also automatically add doctypes on responses returned without this plugin\n\n* Type: `(value: string) => boolean`\n* Default: `isHtml` (exported function)\n\nThe function is used to detect if a string is a html or not. Default implementation if length is greater than 7, starts with `<` and ends with `>`.\n\nKeep in mind there's no real way to validate HTML, so the default implementation is a best guess.\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/html\n```\n\nExample 2 (unknown):\n```unknown\nThis plugin will automatically add `Content-Type: text/html; charset=utf8` header to the response, add `<!doctype html>`, and convert it into a Response object.\n\n## JSX\n\nElysia HTML is based on [@kitajs/html](https://github.com/kitajs/html) allowing us to define JSX to string in compile time to achieve high performance.\n\nName your file that needs to use JSX to end with affix **\"x\"**:\n\n* .js -> .jsx\n* .ts -> .tsx\n\nTo register the TypeScript type, please append the following to **tsconfig.json**:\n```\n\nExample 3 (unknown):\n```unknown\nThat's it, now you can use JSX as your template engine:\n```\n\nExample 4 (unknown):\n```unknown\nIf the error `Cannot find name 'Html'. Did you mean 'html'?` occurs, this import must be added to the JSX template:\n```\n\n---\n\n## Swagger Plugin\n\n**URL:** https://elysiajs.com/plugins/swagger.md\n\n**Contents:**\n- Config\n  - provider\n  - scalar\n  - swagger\n  - excludeStaticFile\n  - path\n  - exclude\n- Pattern\n- Change Swagger Endpoint\n- Customize Swagger info\n\n---\nurl: 'https://elysiajs.com/plugins/swagger.md'\n---\n\n::: warning\nSwagger plugin is deprecated and is no longer be maintained. Please use [OpenAPI plugin](/plugins/openapi) instead.\n:::\n\nThis plugin generates a Swagger endpoint for an Elysia server\n\nAccessing `/swagger` would show you a Scalar UI with the generated endpoint documentation from the Elysia server. You can also access the raw OpenAPI spec at `/swagger/json`.\n\nBelow is a config which is accepted by the plugin\n\nUI Provider for documentation. Default to Scalar.\n\nConfiguration for customizing Scalar.\n\nPlease refer to the [Scalar config](https://github.com/scalar/scalar/blob/main/documentation/configuration.md)\n\nConfiguration for customizing Swagger.\n\nPlease refer to the [Swagger specification](https://swagger.io/specification/v2/).\n\nDetermine if Swagger should exclude static files.\n\nEndpoint to expose Swagger\n\nPaths to exclude from Swagger documentation.\n\nValue can be one of the following:\n\n* **string**\n* **RegExp**\n* **Array\\<string | RegExp>**\n\nBelow you can find the common patterns to use the plugin.\n\nYou can change the swagger endpoint by setting [path](#path) in the plugin config.\n\nElysia can separate the endpoints into groups by using the Swaggers tag system\n\nFirstly define the available tags in the swagger config object\n\nThen use the details property of the endpoint configuration section to assign that endpoint to the group\n\nWhich will produce a swagger page like the following\n\nTo secure your API endpoints, you can define security schemes in the Swagger configuration. The example below demonstrates how to use Bearer Authentication (JWT) to protect your endpoints:\n\nThis configuration ensures that all endpoints under the `/address` prefix require a valid JWT token for access.\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/swagger\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(swagger())\n    .get('/', () => 'hi')\n    .post('/hello', () => 'world')\n    .listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(\n        swagger({\n            path: '/v2/swagger'\n        })\n    )\n    .listen(3000)\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(\n        swagger({\n            documentation: {\n                info: {\n                    title: 'Elysia Documentation',\n                    version: '1.0.0'\n                }\n            }\n        })\n    )\n    .listen(3000)\n```\n\n---\n\n## CORS Plugin\n\n**URL:** https://elysiajs.com/plugins/cors.md\n\n**Contents:**\n- Config\n  - origin\n  - methods\n  - allowedHeaders\n  - exposeHeaders\n  - credentials\n  - maxAge\n  - preflight\n- Pattern\n- Allow CORS by top-level domain\n\n---\nurl: 'https://elysiajs.com/plugins/cors.md'\n---\n\nThis plugin adds support for customizing [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) behavior.\n\nThis will set Elysia to accept requests from any origin.\n\nBelow is a config which is accepted by the plugin\n\nIndicates whether the response can be shared with the requesting code from the given origins.\n\nValue can be one of the following:\n\n* **string** - Name of origin which will directly assign to [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) header.\n* **boolean** - If set to true, [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) will be set to `*` (any origins)\n* **RegExp** - Pattern to match request's URL, allowed if matched.\n* **Function** - Custom logic to allow resource sharing, allow if `true` is returned.\n  * Expected to have the type of:\n  \n* **Array\\<string | RegExp | Function>** - iterate through all cases above in order, allowed if any of the values are `true`.\n\nAllowed methods for cross-origin requests.\n\nAssign [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) header.\n\nValue can be one of the following:\n\n* **undefined | null | ''** - Ignore all methods.\n* **\\*** - Allows all methods.\n* **string** - Expects either a single method or a comma-delimited string\n  * (eg: `'GET, PUT, POST'`)\n* **string\\[]** - Allow multiple HTTP methods.\n  * eg: `['GET', 'PUT', 'POST']`\n\nAllowed headers for an incoming request.\n\nAssign [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) header.\n\nValue can be one of the following:\n\n* **string** - Expects either a single header or a comma-delimited string\n  * eg: `'Content-Type, Authorization'`.\n* **string\\[]** - Allow multiple HTTP headers.\n  * eg: `['Content-Type', 'Authorization']`\n\nResponse CORS with specified headers.\n\nAssign [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) header.\n\nValue can be one of the following:\n\n* **string** - Expects either a single header or a comma-delimited string.\n  * eg: `'Content-Type, X-Powered-By'`.\n* **string\\[]** - Allow multiple HTTP headers.\n  * eg: `['Content-Type', 'X-Powered-By']`\n\nThe Access-Control-Allow-Credentials response header tells browsers whether to expose the response to the frontend JavaScript code when the request's credentials mode [Request.credentials](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials) is `include`.\n\nWhen a request's credentials mode [Request.credentials](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials) is `include`, browsers will only expose the response to the frontend JavaScript code if the Access-Control-Allow-Credentials value is true.\n\nCredentials are cookies, authorization headers, or TLS client certificates.\n\nAssign [Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) header.\n\nIndicates how long the results of a [preflight request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request) (that is the information contained in the [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) and [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) headers) can be cached.\n\nAssign [Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age) header.\n\nThe preflight request is a request sent to check if the CORS protocol is understood and if a server is aware of using specific methods and headers.\n\nResponse with **OPTIONS** request with 3 HTTP request headers:\n\n* **Access-Control-Request-Method**\n* **Access-Control-Request-Headers**\n* **Origin**\n\nThis config indicates if the server should respond to preflight requests.\n\nBelow you can find the common patterns to use the plugin.\n\nThis will allow requests from top-level domains with `saltyaom.com`\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/cors\n```\n\nExample 2 (unknown):\n```unknown\nThis will set Elysia to accept requests from any origin.\n\n## Config\n\nBelow is a config which is accepted by the plugin\n\n### origin\n\n@default `true`\n\nIndicates whether the response can be shared with the requesting code from the given origins.\n\nValue can be one of the following:\n\n* **string** - Name of origin which will directly assign to [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) header.\n* **boolean** - If set to true, [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) will be set to `*` (any origins)\n* **RegExp** - Pattern to match request's URL, allowed if matched.\n* **Function** - Custom logic to allow resource sharing, allow if `true` is returned.\n  * Expected to have the type of:\n```\n\nExample 3 (unknown):\n```unknown\n* **Array\\<string | RegExp | Function>** - iterate through all cases above in order, allowed if any of the values are `true`.\n\n***\n\n### methods\n\n@default `*`\n\nAllowed methods for cross-origin requests.\n\nAssign [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) header.\n\nValue can be one of the following:\n\n* **undefined | null | ''** - Ignore all methods.\n* **\\*** - Allows all methods.\n* **string** - Expects either a single method or a comma-delimited string\n  * (eg: `'GET, PUT, POST'`)\n* **string\\[]** - Allow multiple HTTP methods.\n  * eg: `['GET', 'PUT', 'POST']`\n\n***\n\n### allowedHeaders\n\n@default `*`\n\nAllowed headers for an incoming request.\n\nAssign [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) header.\n\nValue can be one of the following:\n\n* **string** - Expects either a single header or a comma-delimited string\n  * eg: `'Content-Type, Authorization'`.\n* **string\\[]** - Allow multiple HTTP headers.\n  * eg: `['Content-Type', 'Authorization']`\n\n***\n\n### exposeHeaders\n\n@default `*`\n\nResponse CORS with specified headers.\n\nAssign [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) header.\n\nValue can be one of the following:\n\n* **string** - Expects either a single header or a comma-delimited string.\n  * eg: `'Content-Type, X-Powered-By'`.\n* **string\\[]** - Allow multiple HTTP headers.\n  * eg: `['Content-Type', 'X-Powered-By']`\n\n***\n\n### credentials\n\n@default `true`\n\nThe Access-Control-Allow-Credentials response header tells browsers whether to expose the response to the frontend JavaScript code when the request's credentials mode [Request.credentials](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials) is `include`.\n\nWhen a request's credentials mode [Request.credentials](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials) is `include`, browsers will only expose the response to the frontend JavaScript code if the Access-Control-Allow-Credentials value is true.\n\nCredentials are cookies, authorization headers, or TLS client certificates.\n\nAssign [Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) header.\n\n***\n\n### maxAge\n\n@default `5`\n\nIndicates how long the results of a [preflight request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request) (that is the information contained in the [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) and [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) headers) can be cached.\n\nAssign [Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age) header.\n\n***\n\n### preflight\n\nThe preflight request is a request sent to check if the CORS protocol is understood and if a server is aware of using specific methods and headers.\n\nResponse with **OPTIONS** request with 3 HTTP request headers:\n\n* **Access-Control-Request-Method**\n* **Access-Control-Request-Headers**\n* **Origin**\n\nThis config indicates if the server should respond to preflight requests.\n\n## Pattern\n\nBelow you can find the common patterns to use the plugin.\n\n## Allow CORS by top-level domain\n```\n\n---\n\n## JWT Plugin\n\n**URL:** https://elysiajs.com/plugins/jwt.md\n\n**Contents:**\n- Config\n  - name\n  - secret\n  - schema\n  - alg\n  - iss\n  - sub\n  - aud\n  - jti\n  - nbf\n\n---\nurl: 'https://elysiajs.com/plugins/jwt.md'\n---\n\nThis plugin adds support for using JWT in Elysia handlers.\n\nThis plugin extends config from [jose](https://github.com/panva/jose).\n\nBelow is a config that is accepted by the plugin.\n\nName to register `jwt` function as.\n\nFor example, `jwt` function will be registered with a custom name.\n\nBecause some might need to use multiple `jwt` with different configs in a single server, explicitly registering the JWT function with a different name is needed.\n\nThe private key to sign JWT payload with.\n\nType strict validation for JWT payload.\n\nBelow is a config that extends from [cookie](https://npmjs.com/package/cookie)\n\nSigning Algorithm to sign JWT payload with.\n\nPossible properties for jose are:\nHS256\nHS384\nHS512\nPS256\nPS384\nPS512\nRS256\nRS384\nRS512\nES256\nES256K\nES384\nES512\nEdDSA\n\nThe issuer claim identifies the principal that issued the JWT as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.1)\n\nTLDR; is usually (the domain) name of the signer.\n\nThe subject claim identifies the principal that is the subject of the JWT.\n\nThe claims in a JWT are normally statements about the subject as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.2)\n\nThe audience claim identifies the recipients that the JWT is intended for.\n\nEach principal intended to process the JWT MUST identify itself with a value in the audience claim as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.3)\n\nJWT ID claim provides a unique identifier for the JWT as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.7)\n\nThe \"not before\" claim identifies the time before which the JWT must not be accepted for processing as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.5)\n\nThe expiration time claim identifies the expiration time on or after which the JWT MUST NOT be accepted for processing as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.4)\n\nThe \"issued at\" claim identifies the time at which the JWT was issued.\n\nThis claim can be used to determine the age of the JWT as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.6)\n\nThis JWS Extension Header Parameter modifies the JWS Payload representation and the JWS Signing input computation as per [RFC7797](https://www.rfc-editor.org/rfc/rfc7797).\n\nA hint indicating which key was used to secure the JWS.\n\nThis parameter allows originators to explicitly signal a change of key to recipients as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.4)\n\n(X.509 certificate SHA-1 thumbprint) header parameter is a base64url-encoded SHA-1 digest of the DER encoding of the X.509 certificate [RFC5280](https://www.rfc-editor.org/rfc/rfc5280) corresponding to the key used to digitally sign the JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.7)\n\n(X.509 certificate chain) header parameter contains the X.509 public key certificate or certificate chain [RFC5280](https://www.rfc-editor.org/rfc/rfc5280) corresponding to the key used to digitally sign the JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.6)\n\n(X.509 URL) header parameter is a URI [RFC3986](https://www.rfc-editor.org/rfc/rfc3986) that refers to a resource for the X.509 public key certificate or certificate chain \\[RFC5280] corresponding to the key used to digitally sign the JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.5)\n\nThe \"jku\" (JWK Set URL) Header Parameter is a URI \\[RFC3986] that refers to a resource for a set of JSON-encoded public keys, one of which corresponds to the key used to digitally sign the JWS.\n\nThe keys MUST be encoded as a JWK Set \\[JWK] as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.2)\n\nThe `typ` (type) Header Parameter is used by JWS applications to declare the media type \\[IANA.MediaTypes] of this complete JWS.\n\nThis is intended for use by the application when more than one kind of object could be present in an application data structure that can contain a JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.9)\n\nContent-Type parameter is used by JWS applications to declare the media type \\[IANA.MediaTypes] of the secured content (the payload).\n\nThis is intended for use by the application when more than one kind of object could be present in the JWS Payload as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.9)\n\nBelow are the value added to the handler.\n\nA dynamic object of collection related to use with JWT registered by the JWT plugin.\n\n`JWTPayloadSpec` accepts the same value as [JWT config](#config)\n\nVerify payload with the provided JWT config\n\n`JWTPayloadSpec` accepts the same value as [JWT config](#config)\n\nBelow you can find the common patterns to use the plugin.\n\nBy default, the config is passed to `setCookie` and inherits its value.\n\nThis will sign JWT with an expiration date of the next 7 days.\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/jwt\n```\n\nExample 2 (unknown):\n```unknown\n:::\n\n## Config\n\nThis plugin extends config from [jose](https://github.com/panva/jose).\n\nBelow is a config that is accepted by the plugin.\n\n### name\n\nName to register `jwt` function as.\n\nFor example, `jwt` function will be registered with a custom name.\n```\n\nExample 3 (unknown):\n```unknown\nBecause some might need to use multiple `jwt` with different configs in a single server, explicitly registering the JWT function with a different name is needed.\n\n### secret\n\nThe private key to sign JWT payload with.\n\n### schema\n\nType strict validation for JWT payload.\n\n***\n\nBelow is a config that extends from [cookie](https://npmjs.com/package/cookie)\n\n### alg\n\n@default `HS256`\n\nSigning Algorithm to sign JWT payload with.\n\nPossible properties for jose are:\nHS256\nHS384\nHS512\nPS256\nPS384\nPS512\nRS256\nRS384\nRS512\nES256\nES256K\nES384\nES512\nEdDSA\n\n### iss\n\nThe issuer claim identifies the principal that issued the JWT as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.1)\n\nTLDR; is usually (the domain) name of the signer.\n\n### sub\n\nThe subject claim identifies the principal that is the subject of the JWT.\n\nThe claims in a JWT are normally statements about the subject as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.2)\n\n### aud\n\nThe audience claim identifies the recipients that the JWT is intended for.\n\nEach principal intended to process the JWT MUST identify itself with a value in the audience claim as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.3)\n\n### jti\n\nJWT ID claim provides a unique identifier for the JWT as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.7)\n\n### nbf\n\nThe \"not before\" claim identifies the time before which the JWT must not be accepted for processing as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.5)\n\n### exp\n\nThe expiration time claim identifies the expiration time on or after which the JWT MUST NOT be accepted for processing as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.4)\n\n### iat\n\nThe \"issued at\" claim identifies the time at which the JWT was issued.\n\nThis claim can be used to determine the age of the JWT as per [RFC7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1.6)\n\n### b64\n\nThis JWS Extension Header Parameter modifies the JWS Payload representation and the JWS Signing input computation as per [RFC7797](https://www.rfc-editor.org/rfc/rfc7797).\n\n### kid\n\nA hint indicating which key was used to secure the JWS.\n\nThis parameter allows originators to explicitly signal a change of key to recipients as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.4)\n\n### x5t\n\n(X.509 certificate SHA-1 thumbprint) header parameter is a base64url-encoded SHA-1 digest of the DER encoding of the X.509 certificate [RFC5280](https://www.rfc-editor.org/rfc/rfc5280) corresponding to the key used to digitally sign the JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.7)\n\n### x5c\n\n(X.509 certificate chain) header parameter contains the X.509 public key certificate or certificate chain [RFC5280](https://www.rfc-editor.org/rfc/rfc5280) corresponding to the key used to digitally sign the JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.6)\n\n### x5u\n\n(X.509 URL) header parameter is a URI [RFC3986](https://www.rfc-editor.org/rfc/rfc3986) that refers to a resource for the X.509 public key certificate or certificate chain \\[RFC5280] corresponding to the key used to digitally sign the JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.5)\n\n### jwk\n\nThe \"jku\" (JWK Set URL) Header Parameter is a URI \\[RFC3986] that refers to a resource for a set of JSON-encoded public keys, one of which corresponds to the key used to digitally sign the JWS.\n\nThe keys MUST be encoded as a JWK Set \\[JWK] as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.2)\n\n### typ\n\nThe `typ` (type) Header Parameter is used by JWS applications to declare the media type \\[IANA.MediaTypes] of this complete JWS.\n\nThis is intended for use by the application when more than one kind of object could be present in an application data structure that can contain a JWS as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.9)\n\n### ctr\n\nContent-Type parameter is used by JWS applications to declare the media type \\[IANA.MediaTypes] of the secured content (the payload).\n\nThis is intended for use by the application when more than one kind of object could be present in the JWS Payload as per [RFC7515](https://www.rfc-editor.org/rfc/rfc7515#section-4.1.9)\n\n## Handler\n\nBelow are the value added to the handler.\n\n### jwt.sign\n\nA dynamic object of collection related to use with JWT registered by the JWT plugin.\n\nType:\n```\n\nExample 4 (unknown):\n```unknown\n`JWTPayloadSpec` accepts the same value as [JWT config](#config)\n\n### jwt.verify\n\nVerify payload with the provided JWT config\n\nType:\n```\n\n---\n\n## Bearer Plugin\n\n**URL:** https://elysiajs.com/plugins/bearer.md\n\n---\nurl: 'https://elysiajs.com/plugins/bearer.md'\n---\n\nPlugin for [elysia](https://github.com/elysiajs/elysia) for retrieving the Bearer token.\n\nThis plugin is for retrieving a Bearer token specified in [RFC6750](https://www.rfc-editor.org/rfc/rfc6750#section-2).\n\nThis plugin DOES NOT handle authentication validation for your server. Instead, the plugin leaves the decision to developers to apply logic for handling validation check themselves.\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/bearer\n```\n\n---\n\n## OpenAPI Plugin&#x20;\n\n**URL:** https://elysiajs.com/plugins/openapi.md\n\n**Contents:**\n- Detail\n- detail.hide\n  - detail.deprecated\n  - detail.description\n  - detail.summary\n- Config\n- enabled\n- documentation\n- exclude\n- exclude.methods\n\n---\nurl: 'https://elysiajs.com/plugins/openapi.md'\n---\n\nPlugin for [elysia](https://github.com/elysiajs/elysia) to auto-generate API documentation page.\n\nAccessing `/openapi` would show you a Scalar UI with the generated endpoint documentation from the Elysia server. You can also access the raw OpenAPI spec at `/openapi/json`.\n\n::: tip\nThis page is the plugin configuration reference.\n\nIf you're looking for a common patterns or an advanced usage of OpenAPI, check out [Patterns: OpenAPI](/patterns/openapi)\n:::\n\n`detail` extends the [OpenAPI Operation Object](https://spec.openapis.org/oas/v3.0.3.html#operation-object)\n\nThe detail field is an object that can be used to describe information about the route for API documentation.\n\nIt may contain the following fields:\n\nYou can hide the route from the Swagger page by setting `detail.hide` to `true`\n\nDeclares this operation to be deprecated. Consumers SHOULD refrain from usage of the declared operation. Default value is `false`.\n\nA verbose explanation of the operation behavior.\n\nA short summary of what the operation does.\n\nBelow is a config which is accepted by the plugin\n\n@default true\nEnable/Disable the plugin\n\nOpenAPI documentation information\n\n@see https://spec.openapis.org/oas/v3.0.3.html\n\nConfiguration to exclude paths or methods from documentation\n\nList of methods to exclude from documentation\n\nList of paths to exclude from documentation\n\nExclude static file routes from documentation\n\nList of tags to exclude from documentation\n\nA custom mapping function from Standard schema to OpenAPI schema\n\nThe endpoint to expose OpenAPI documentation frontend\n\nOpenAPI documentation frontend between:\n\n* [Scalar](https://github.com/scalar/scalar)\n* [SwaggerUI](https://github.com/swagger-api/swagger-ui)\n* null: disable frontend\n\nAdditional OpenAPI reference for each endpoint\n\nScalar configuration, refers to [Scalar config](https://github.com/scalar/scalar/blob/main/documentation/configuration.md)\n\n@default '/${path}/json'\n\nThe endpoint to expose OpenAPI specification in JSON format\n\nSwagger config, refers to [Swagger config](https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/)\n\nBelow you can find the common patterns to use the plugin.\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/openapi\n```\n\nExample 2 (unknown):\n```unknown\nAccessing `/openapi` would show you a Scalar UI with the generated endpoint documentation from the Elysia server. You can also access the raw OpenAPI spec at `/openapi/json`.\n\n::: tip\nThis page is the plugin configuration reference.\n\nIf you're looking for a common patterns or an advanced usage of OpenAPI, check out [Patterns: OpenAPI](/patterns/openapi)\n:::\n\n## Detail\n\n`detail` extends the [OpenAPI Operation Object](https://spec.openapis.org/oas/v3.0.3.html#operation-object)\n\nThe detail field is an object that can be used to describe information about the route for API documentation.\n\nIt may contain the following fields:\n\n## detail.hide\n\nYou can hide the route from the Swagger page by setting `detail.hide` to `true`\n```\n\nExample 3 (unknown):\n```unknown\n### detail.deprecated\n\nDeclares this operation to be deprecated. Consumers SHOULD refrain from usage of the declared operation. Default value is `false`.\n\n### detail.description\n\nA verbose explanation of the operation behavior.\n\n### detail.summary\n\nA short summary of what the operation does.\n\n## Config\n\nBelow is a config which is accepted by the plugin\n\n## enabled\n\n@default true\nEnable/Disable the plugin\n\n## documentation\n\nOpenAPI documentation information\n\n@see https://spec.openapis.org/oas/v3.0.3.html\n\n## exclude\n\nConfiguration to exclude paths or methods from documentation\n\n## exclude.methods\n\nList of methods to exclude from documentation\n\n## exclude.paths\n\nList of paths to exclude from documentation\n\n## exclude.staticFile\n\n@default true\n\nExclude static file routes from documentation\n\n## exclude.tags\n\nList of tags to exclude from documentation\n\n## mapJsonSchema\n\nA custom mapping function from Standard schema to OpenAPI schema\n\n### Example\n```\n\n---\n\n## Static Plugin\n\n**URL:** https://elysiajs.com/plugins/static.md\n\n**Contents:**\n- Config\n  - assets\n  - prefix\n  - ignorePatterns\n  - staticLimit\n  - alwaysStatic\n  - headers\n  - indexHTML\n- Pattern\n- Single file\n\n---\nurl: 'https://elysiajs.com/plugins/static.md'\n---\n\nThis plugin can serve static files/folders for Elysia Server\n\nBy default, the static plugin default folder is `public`, and registered with `/public` prefix.\n\nSuppose your project structure is:\n\nThe available path will become:\n\n* /public/takodachi.png\n* /public/nested/takodachi.png\n\nBelow is a config which is accepted by the plugin\n\nPath to the folder to expose as static\n\nPath prefix to register public files\n\nList of files to ignore from serving as static files\n\nBy default, the static plugin will register paths to the Router with a static name, if the limits are exceeded, paths will be lazily added to the Router to reduce memory usage.\nTradeoff memory with performance.\n\nIf set to true, static files path will be registered to Router skipping the `staticLimits`.\n\nSet response headers of files\n\nIf set to true, the `index.html` file from the static directory will be served for any request that is matching neither a route nor any existing static file.\n\nBelow you can find the common patterns to use the plugin.\n\n* [Single File](#single-file)\n\nSuppose you want to return just a single file, you can use `file` instead of using the static plugin\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/static\n```\n\nExample 2 (unknown):\n```unknown\nBy default, the static plugin default folder is `public`, and registered with `/public` prefix.\n\nSuppose your project structure is:\n```\n\nExample 3 (unknown):\n```unknown\nThe available path will become:\n\n* /public/takodachi.png\n* /public/nested/takodachi.png\n\n## Config\n\nBelow is a config which is accepted by the plugin\n\n### assets\n\n@default `\"public\"`\n\nPath to the folder to expose as static\n\n### prefix\n\n@default `\"/public\"`\n\nPath prefix to register public files\n\n### ignorePatterns\n\n@default `[]`\n\nList of files to ignore from serving as static files\n\n### staticLimit\n\n@default `1024`\n\nBy default, the static plugin will register paths to the Router with a static name, if the limits are exceeded, paths will be lazily added to the Router to reduce memory usage.\nTradeoff memory with performance.\n\n### alwaysStatic\n\n@default `false`\n\nIf set to true, static files path will be registered to Router skipping the `staticLimits`.\n\n### headers\n\n@default `{}`\n\nSet response headers of files\n\n### indexHTML\n\n@default `false`\n\nIf set to true, the `index.html` file from the static directory will be served for any request that is matching neither a route nor any existing static file.\n\n## Pattern\n\nBelow you can find the common patterns to use the plugin.\n\n* [Single File](#single-file)\n\n## Single file\n\nSuppose you want to return just a single file, you can use `file` instead of using the static plugin\n```\n\n---\n\n## Server Timing Plugin\n\n**URL:** https://elysiajs.com/plugins/server-timing.md\n\n**Contents:**\n- Config\n  - enabled\n  - allow\n  - trace\n- Pattern\n- Allow Condition\n\n---\nurl: 'https://elysiajs.com/plugins/server-timing.md'\n---\n\nThis plugin adds support for auditing performance bottlenecks with Server Timing API\n\nServer Timing then will append header 'Server-Timing' with log duration, function name, and detail for each life-cycle function.\n\nTo inspect, open browser developer tools > Network > \\[Request made through Elysia server] > Timing.\n\n![Developer tools showing Server Timing screenshot](/assets/server-timing.webp)\n\nNow you can effortlessly audit the performance bottleneck of your server.\n\nBelow is a config which is accepted by the plugin\n\n@default `NODE_ENV !== 'production'`\n\nDetermine whether or not Server Timing should be enabled\n\nA condition whether server timing should be log\n\nAllow Server Timing to log specified life-cycle events:\n\nTrace accepts objects of the following:\n\n* request: capture duration from request\n* parse: capture duration from parse\n* transform: capture duration from transform\n* beforeHandle: capture duration from beforeHandle\n* handle: capture duration from the handle\n* afterHandle: capture duration from afterHandle\n* total: capture total duration from start to finish\n\nBelow you can find the common patterns to use the plugin.\n\n* [Allow Condition](#allow-condition)\n\nYou may disable Server Timing on specific routes via `allow` property\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/server-timing\n```\n\nExample 2 (unknown):\n```unknown\nServer Timing then will append header 'Server-Timing' with log duration, function name, and detail for each life-cycle function.\n\nTo inspect, open browser developer tools > Network > \\[Request made through Elysia server] > Timing.\n\n![Developer tools showing Server Timing screenshot](/assets/server-timing.webp)\n\nNow you can effortlessly audit the performance bottleneck of your server.\n\n## Config\n\nBelow is a config which is accepted by the plugin\n\n### enabled\n\n@default `NODE_ENV !== 'production'`\n\nDetermine whether or not Server Timing should be enabled\n\n### allow\n\n@default `undefined`\n\nA condition whether server timing should be log\n\n### trace\n\n@default `undefined`\n\nAllow Server Timing to log specified life-cycle events:\n\nTrace accepts objects of the following:\n\n* request: capture duration from request\n* parse: capture duration from parse\n* transform: capture duration from transform\n* beforeHandle: capture duration from beforeHandle\n* handle: capture duration from the handle\n* afterHandle: capture duration from afterHandle\n* total: capture total duration from start to finish\n\n## Pattern\n\nBelow you can find the common patterns to use the plugin.\n\n* [Allow Condition](#allow-condition)\n\n## Allow Condition\n\nYou may disable Server Timing on specific routes via `allow` property\n```\n\n---\n\n## GraphQL Yoga Plugin\n\n**URL:** https://elysiajs.com/plugins/graphql-yoga.md\n\n**Contents:**\n- Resolver\n- Context\n- Config\n  - path\n\n---\nurl: 'https://elysiajs.com/plugins/graphql-yoga.md'\n---\n\nThis plugin integrates GraphQL yoga with Elysia\n\nAccessing `/graphql` in the browser (GET request) would show you a GraphiQL instance for the GraphQL-enabled Elysia server.\n\noptional: you can install a custom version of optional peer dependencies as well:\n\nElysia uses [Mobius](https://github.com/saltyaom/mobius) to infer type from **typeDefs** field automatically, allowing you to get full type-safety and auto-complete when typing **resolver** types.\n\nYou can add custom context to the resolver function by adding **context**\n\nThis plugin extends [GraphQL Yoga's createYoga options, please refer to the GraphQL Yoga documentation](https://the-guild.dev/graphql/yoga-server/docs) with inlining `schema` config to root.\n\nBelow is a config which is accepted by the plugin\n\nEndpoint to expose GraphQL handler\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/graphql-yoga\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { yoga } from '@elysiajs/graphql-yoga'\n\nconst app = new Elysia()\n\t.use(\n\t\tyoga({\n\t\t\ttypeDefs: /* GraphQL */ `\n\t\t\t\ttype Query {\n\t\t\t\t\thi: String\n\t\t\t\t}\n\t\t\t`,\n\t\t\tresolvers: {\n\t\t\t\tQuery: {\n\t\t\t\t\thi: () => 'Hello from Elysia'\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\nExample 3 (bash):\n```bash\nbun add graphql graphql-yoga\n```\n\nExample 4 (ts):\n```ts\nimport { Elysia } from 'elysia'\nimport { yoga } from '@elysiajs/graphql-yoga'\n\nconst app = new Elysia()\n\t.use(\n\t\tyoga({\n\t\t\ttypeDefs: /* GraphQL */ `\n\t\t\t\ttype Query {\n\t\t\t\t\thi: String\n\t\t\t\t}\n\t\t\t`,\n\t\t\tcontext: {\n\t\t\t\tname: 'Mobius'\n\t\t\t},\n\t\t\t// If context is a function on this doesn't present\n\t\t\t// for some reason it won't infer context type\n\t\t\tuseContext(_) {},\n\t\t\tresolvers: {\n\t\t\t\tQuery: {\n\t\t\t\t\thi: async (parent, args, context) => context.name\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\n---\n\n## GraphQL Apollo Plugin\n\n**URL:** https://elysiajs.com/plugins/graphql-apollo.md\n\n**Contents:**\n- Context\n- Config\n  - path\n  - enablePlayground\n\n---\nurl: 'https://elysiajs.com/plugins/graphql-apollo.md'\n---\n\nPlugin for [elysia](https://github.com/elysiajs/elysia) for using GraphQL Apollo.\n\nAccessing `/graphql` should show Apollo GraphQL playground work with.\n\nBecause Elysia is based on Web Standard Request and Response which is different from Node's `HttpRequest` and `HttpResponse` that Express uses, results in `req, res` being undefined in context.\n\nBecause of this, Elysia replaces both with `context` like route parameters.\n\nThis plugin extends Apollo's [ServerRegistration](https://www.apollographql.com/docs/apollo-server/api/apollo-server/#options) (which is `ApolloServer`'s' constructor parameter).\n\nBelow are the extended parameters for configuring Apollo Server with Elysia.\n\n@default `\"/graphql\"`\n\nPath to expose Apollo Server.\n\n@default `process.env.ENV !== 'production'`\n\nDetermine whether should Apollo should provide Apollo Playground.\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add graphql @elysiajs/apollo @apollo/server\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { apollo, gql } from '@elysiajs/apollo'\n\nconst app = new Elysia()\n\t.use(\n\t\tapollo({\n\t\t\ttypeDefs: gql`\n\t\t\t\ttype Book {\n\t\t\t\t\ttitle: String\n\t\t\t\t\tauthor: String\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tbooks: [Book]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tresolvers: {\n\t\t\t\tQuery: {\n\t\t\t\t\tbooks: () => {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttitle: 'Elysia',\n\t\t\t\t\t\t\t\tauthor: 'saltyAom'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nconst app = new Elysia()\n\t.use(\n\t\tapollo({\n\t\t\ttypeDefs,\n\t\t\tresolvers,\n\t\t\tcontext: async ({ request }) => {\n\t\t\t\tconst authorization = request.headers.get('Authorization')\n\n\t\t\t\treturn {\n\t\t\t\t\tauthorization\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\n---\n\n## Cron Plugin\n\n**URL:** https://elysiajs.com/plugins/cron.md\n\n**Contents:**\n- cron\n  - name\n  - pattern\n  - timezone\n  - startAt\n  - stopAt\n  - maxRuns\n  - catch\n  - interval\n- Pattern\n\n---\nurl: 'https://elysiajs.com/plugins/cron.md'\n---\n\nThis plugin adds support for running cronjobs in the Elysia server.\n\nThe above code will log `heartbeat` every 10 seconds.\n\nCreate a cronjob for the Elysia server.\n\n`CronConfig` accepts the parameters specified below:\n\nJob name to register to `store`.\n\nThis will register the cron instance to `store` with a specified name, which can be used to reference in later processes eg. stop the job.\n\nTime to run the job as specified by [cron syntax](https://en.wikipedia.org/wiki/Cron) specified as below:\n\nThis can be generated by tools like [Crontab Guru](https://crontab.guru/)\n\nThis plugin extends the cron method to Elysia using [cronner](https://github.com/hexagon/croner).\n\nBelow are the configs accepted by cronner.\n\nTime zone in Europe/Stockholm format\n\nSchedule start time for the job\n\nSchedule stop time for the job\n\nMaximum number of executions\n\nContinue execution even if an unhandled error is thrown by a triggered function.\n\nThe minimum interval between executions, in seconds.\n\nBelow you can find the common patterns to use the plugin.\n\nYou can stop cronjob manually by accessing the cronjob name registered to `store`.\n\nYou can use predefined patterns from `@elysiajs/cron/schedule`\n\n| Function                                 | Description                                           |\n| ---------------------------------------- | ----------------------------------------------------- |\n| `.everySeconds(2)`                       | Run the task every 2 seconds                          |\n| `.everyMinutes(5)`                       | Run the task every 5 minutes                          |\n| `.everyHours(3)`                         | Run the task every 3 hours                            |\n| `.everyHoursAt(3, 15)`                   | Run the task every 3 hours at 15 minutes              |\n| `.everyDayAt('04:19')`                   | Run the task every day at 04:19                       |\n| `.everyWeekOn(Patterns.MONDAY, '19:30')` | Run the task every Monday at 19:30                    |\n| `.everyWeekdayAt('17:00')`               | Run the task every day from Monday to Friday at 17:00 |\n| `.everyWeekendAt('11:00')`               | Run the task on Saturday and Sunday at 11:00          |\n\n| Function          | Constant                           |\n| ----------------- | ---------------------------------- |\n| `.everySecond()`  | EVERY\\_SECOND                       |\n| `.everyMinute()`  | EVERY\\_MINUTE                       |\n| `.hourly()`       | EVERY\\_HOUR                         |\n| `.daily()`        | EVERY\\_DAY\\_AT\\_MIDNIGHT              |\n| `.everyWeekday()` | EVERY\\_WEEKDAY                      |\n| `.everyWeekend()` | EVERY\\_WEEKEND                      |\n| `.weekly()`       | EVERY\\_WEEK                         |\n| `.monthly()`      | EVERY\\_1ST\\_DAY\\_OF\\_MONTH\\_AT\\_MIDNIGHT |\n| `.everyQuarter()` | EVERY\\_QUARTER                      |\n| `.yearly()`       | EVERY\\_YEAR                         |\n\n| Constant                                 | Pattern              |\n| ---------------------------------------- | -------------------- |\n| `.EVERY_SECOND`                          | `* * * * * *`        |\n| `.EVERY_5_SECONDS`                       | `*/5 * * * * *`      |\n| `.EVERY_10_SECONDS`                      | `*/10 * * * * *`     |\n| `.EVERY_30_SECONDS`                      | `*/30 * * * * *`     |\n| `.EVERY_MINUTE`                          | `*/1 * * * *`        |\n| `.EVERY_5_MINUTES`                       | `0 */5 * * * *`      |\n| `.EVERY_10_MINUTES`                      | `0 */10 * * * *`     |\n| `.EVERY_30_MINUTES`                      | `0 */30 * * * *`     |\n| `.EVERY_HOUR`                            | `0 0-23/1 * * *`     |\n| `.EVERY_2_HOURS`                         | `0 0-23/2 * * *`     |\n| `.EVERY_3_HOURS`                         | `0 0-23/3 * * *`     |\n| `.EVERY_4_HOURS`                         | `0 0-23/4 * * *`     |\n| `.EVERY_5_HOURS`                         | `0 0-23/5 * * *`     |\n| `.EVERY_6_HOURS`                         | `0 0-23/6 * * *`     |\n| `.EVERY_7_HOURS`                         | `0 0-23/7 * * *`     |\n| `.EVERY_8_HOURS`                         | `0 0-23/8 * * *`     |\n| `.EVERY_9_HOURS`                         | `0 0-23/9 * * *`     |\n| `.EVERY_10_HOURS`                        | `0 0-23/10 * * *`    |\n| `.EVERY_11_HOURS`                        | `0 0-23/11 * * *`    |\n| `.EVERY_12_HOURS`                        | `0 0-23/12 * * *`    |\n| `.EVERY_DAY_AT_1AM`                      | `0 01 * * *`         |\n| `.EVERY_DAY_AT_2AM`                      | `0 02 * * *`         |\n| `.EVERY_DAY_AT_3AM`                      | `0 03 * * *`         |\n| `.EVERY_DAY_AT_4AM`                      | `0 04 * * *`         |\n| `.EVERY_DAY_AT_5AM`                      | `0 05 * * *`         |\n| `.EVERY_DAY_AT_6AM`                      | `0 06 * * *`         |\n| `.EVERY_DAY_AT_7AM`                      | `0 07 * * *`         |\n| `.EVERY_DAY_AT_8AM`                      | `0 08 * * *`         |\n| `.EVERY_DAY_AT_9AM`                      | `0 09 * * *`         |\n| `.EVERY_DAY_AT_10AM`                     | `0 10 * * *`         |\n| `.EVERY_DAY_AT_11AM`                     | `0 11 * * *`         |\n| `.EVERY_DAY_AT_NOON`                     | `0 12 * * *`         |\n| `.EVERY_DAY_AT_1PM`                      | `0 13 * * *`         |\n| `.EVERY_DAY_AT_2PM`                      | `0 14 * * *`         |\n| `.EVERY_DAY_AT_3PM`                      | `0 15 * * *`         |\n| `.EVERY_DAY_AT_4PM`                      | `0 16 * * *`         |\n| `.EVERY_DAY_AT_5PM`                      | `0 17 * * *`         |\n| `.EVERY_DAY_AT_6PM`                      | `0 18 * * *`         |\n| `.EVERY_DAY_AT_7PM`                      | `0 19 * * *`         |\n| `.EVERY_DAY_AT_8PM`                      | `0 20 * * *`         |\n| `.EVERY_DAY_AT_9PM`                      | `0 21 * * *`         |\n| `.EVERY_DAY_AT_10PM`                     | `0 22 * * *`         |\n| `.EVERY_DAY_AT_11PM`                     | `0 23 * * *`         |\n| `.EVERY_DAY_AT_MIDNIGHT`                 | `0 0 * * *`          |\n| `.EVERY_WEEK`                            | `0 0 * * 0`          |\n| `.EVERY_WEEKDAY`                         | `0 0 * * 1-5`        |\n| `.EVERY_WEEKEND`                         | `0 0 * * 6,0`        |\n| `.EVERY_1ST_DAY_OF_MONTH_AT_MIDNIGHT`    | `0 0 1 * *`          |\n| `.EVERY_1ST_DAY_OF_MONTH_AT_NOON`        | `0 12 1 * *`         |\n| `.EVERY_2ND_HOUR`                        | `0 */2 * * *`        |\n| `.EVERY_2ND_HOUR_FROM_1AM_THROUGH_11PM`  | `0 1-23/2 * * *`     |\n| `.EVERY_2ND_MONTH`                       | `0 0 1 */2 *`        |\n| `.EVERY_QUARTER`                         | `0 0 1 */3 *`        |\n| `.EVERY_6_MONTHS`                        | `0 0 1 */6 *`        |\n| `.EVERY_YEAR`                            | `0 0 1 1 *`          |\n| `.EVERY_30_MINUTES_BETWEEN_9AM_AND_5PM`  | `0 */30 9-17 * * *`  |\n| `.EVERY_30_MINUTES_BETWEEN_9AM_AND_6PM`  | `0 */30 9-18 * * *`  |\n| `.EVERY_30_MINUTES_BETWEEN_10AM_AND_7PM` | `0 */30 10-19 * * *` |\n\n**Examples:**\n\nExample 1 (bash):\n```bash\nbun add @elysiajs/cron\n```\n\nExample 2 (unknown):\n```unknown\nThe above code will log `heartbeat` every 10 seconds.\n\n## cron\n\nCreate a cronjob for the Elysia server.\n\ntype:\n```\n\nExample 3 (unknown):\n```unknown\n`CronConfig` accepts the parameters specified below:\n\n### name\n\nJob name to register to `store`.\n\nThis will register the cron instance to `store` with a specified name, which can be used to reference in later processes eg. stop the job.\n\n### pattern\n\nTime to run the job as specified by [cron syntax](https://en.wikipedia.org/wiki/Cron) specified as below:\n```\n\nExample 4 (unknown):\n```unknown\nThis can be generated by tools like [Crontab Guru](https://crontab.guru/)\n\n***\n\nThis plugin extends the cron method to Elysia using [cronner](https://github.com/hexagon/croner).\n\nBelow are the configs accepted by cronner.\n\n### timezone\n\nTime zone in Europe/Stockholm format\n\n### startAt\n\nSchedule start time for the job\n\n### stopAt\n\nSchedule stop time for the job\n\n### maxRuns\n\nMaximum number of executions\n\n### catch\n\nContinue execution even if an unhandled error is thrown by a triggered function.\n\n### interval\n\nThe minimum interval between executions, in seconds.\n\n## Pattern\n\nBelow you can find the common patterns to use the plugin.\n\n## Stop cronjob\n\nYou can stop cronjob manually by accessing the cronjob name registered to `store`.\n```\n\n---\n",
        "plugins/coding/elysia/skills/elysia/references/tutorial.md": "# Elysia - Tutorial\n\n**Pages:** 14\n\n---\n\n## Lifecycle\n\n**URL:** https://elysiajs.com/tutorial/getting-started/life-cycle.md\n\n**Contents:**\n- Hook\n- Local Hook\n- Interceptor Hook\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/life-cycle.md'\n---\n\nLifecycle **hook** is function that executed on a specific event during the request-response cycle.\n\nThey allow you to run custom logic at the certain point\n\n* request - when a request is received\n* beforeHandle - before executing a handler\n* afterResponse - after a response is sent, etc.\n* error - when an error occurs\n\nThis can be useful for tasks like logging, authentication, etc.\n\nTo register a lifecycle hook, you can pass it to 3rd argument of a route method:\n\nWhen `beforeHandle` returns a value, it will skip the handler and return the value instead.\n\nThis is useful for things like authentication, where you want to return a `401 Unauthorized` response if the user is not authenticated.\n\nSee Life Cycle, Before Handle for a more detailed explanation.\n\nA function that intercepts the **lifecycle event**. because a function **\"hooks\"** into the lifecycle event\n\nHook can be categorized into 2 types:\n\n1. Local Hook - execute on a specific route\n2. Interceptor Hook - execute on every route **after the hook is registered**\n\nA local hook is executed on a specific route.\n\nTo use a local hook, you can inline hook into a route handler:\n\nRegister hook into every **handler that came after the hook is called** for the current instance only.\n\nTo add an interceptor hook, you can use `.on` followed by a lifecycle event:\n\nUnlike Local Hook, Interceptor Hook will add the hook to every route that came after the hook is registered.\n\nLet's put 2 types of hooks into practice.\n\nWe can use `beforeHandle` to intercept the request before it reaches the handler, and return a response with `status` method.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/1', () => 'Hello Elysia!')\n\t.get('/auth', () => {\n\t\tconsole.log('This is executed after \"beforeHandle\"')\n\n\t\treturn 'Oh you are lucky!'\n\t}, {\n\t\tbeforeHandle({ request, status }) {\n\t\t\tconsole.log('This is executed before handler')\n\n\t\t\tif(Math.random() <= 0.5)\n\t\t\t\treturn status(418)\n\t\t}\n\t})\n\t.get('/2', () => 'Hello Elysia!')\n```\n\nExample 2 (typescript):\n```typescript\n// Similar to previous code snippet\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/1', () => 'Hello Elysia!')\n\t.get('/auth', () => {\n\t\tconsole.log('Run after \"beforeHandle\"')\n\n\t\treturn 'Oh you are lucky!'\n\t}, {\n\t\t// This is a Local Hook\n\t\tbeforeHandle({ request, status }) {\n\t\t\tconsole.log('Run before handler')\n\n\t\t\tif(Math.random() <= 0.5)\n\t\t\t\treturn status(418)\n\t\t}\n\t})\n\t.get('/2', () => 'Hello Elysia!')\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/1', () => 'Hello Elysia!')\n\t.onBeforeHandle(({ request, status }) => {\n\t\tconsole.log('This is executed before handler')\n\n\t\tif(Math.random() <= 0.5)\n\t\t\treturn status(418)\n\t})\n\t// \"beforeHandle\" is applied\n\t.get('/auth', () => {\n\t\tconsole.log('This is executed after \"beforeHandle\"')\n\n\t\treturn 'Oh you are lucky!'\n\t})\n\t// \"beforeHandle\" is also applied\n\t.get('/2', () => 'Hello Elysia!')\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.onBeforeHandle(({ query: { name }, status }) => {\n\t\tif(!name) return status(401)\n\t})\n\t.get('/auth', ({ query: { name = 'anon' } }) => {\n\t\treturn `Hello ${name}!`\n\t})\n\t.get('/profile', ({ query: { name = 'anon' } }) => {\n\t\treturn `Hello ${name}!`\n\t})\n\t.listen(3000)\n```\n\n---\n\n## Mount\n\n**URL:** https://elysiajs.com/tutorial/features/mount.md\n\n**Contents:**\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/features/mount.md'\n---\n\nElysia provides a Elysia.mount to interlop between backend frameworks that is built on Web Standard like Hono, H3, etc.\n\nThis allows us to gradually migrate our application to Elysia, or use multiple frameworks in a single application.\n\nLet's use the preview to **GET '/hono'** to see if our Hono route is working.\n\nTry to modify the code and see how it changes!\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { Hono } from 'hono'\n\nconst hono = new Hono()\n\t.get('/', (c) => c.text('Hello from Hono')\n\nnew Elysia()\n\t.get('/', 'Hello from Elysia')\n\t.mount('/hono', hono.fetch)\n\t.listen(3000)\n```\n\n---\n\n## Status\n\n**URL:** https://elysiajs.com/tutorial/getting-started/status-and-headers.md\n\n**Contents:**\n- Redirect\n- Headers\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/status-and-headers.md'\n---\n\nStatus code is an indicator of how the server handles the request.\n\nYou must have heard of the infamous **404 Not Found** when you visit a non-existing page.\n\nThat's a **status code**.\n\nBy default, Elysia will return **200 OK** for a successful request.\n\nElysia also returns many other status codes depending on the situation like:\n\n* 400 Bad Request\n* 422 Unprocessable Entity\n* 500 Internal Server Error\n\nYou can also return a status code by returning your response using a `status` function.\n\nSimilarly, you can also redirect the request to another URL by returning a `redirect` function.\n\nUnlike status code and redirect, which you can return directly, you might need to set headers multiple times in your application.\n\nThat's why instead of returning a `headers` function, Elysia provides a `set.headers` object to set headers.\n\nBecause `headers` represents **request headers**, Elysia distinguishes between request headers and response headers by prefixing **set.headers** for response.\n\nLet's exercise what we have learned.\n\n1. To set status code to `418 I'm a teapot`, we can use `status` function.\n2. To redirect `/docs` to `https://elysiajs.com`, we can use `redirect` function.\n3. To set a custom header `x-powered-by` to `Elysia`, we can use `set.headers` object.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', ({ status }) => status(418, \"I'm a teapot'\"))\n\t.listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', ({ redirect }) => redirect('https://elysiajs.com'))\n\t.listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', ({ set }) => {\n\t\tset.headers['x-powered-by'] = 'Elysia'\n\n\t\treturn 'Hello World'\n\t})\n\t.listen(3000)\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', ({ status, set }) => {\n\t\tset.headers['x-powered-by'] = 'Elysia'\n\n\t\treturn status(418, 'Hello Elysia!')\n\t})\n\t.get('/docs', ({ redirect }) => redirect('https://elysiajs.com'))\n\t.listen(3000)\n```\n\n---\n\n## Unit Test\n\n**URL:** https://elysiajs.com/tutorial/features/unit-test.md\n\n**Contents:**\n  - Test\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/features/unit-test.md'\n---\n\nElysia provides a **Elysia.fetch** function to easily test your application.\n\n**Elysia.fetch** takes a Web Standard Request, and returns a Response similar to the browser's fetch API.\n\nThis will run a request like an **actual request** (not simulated).\n\nThis allows us to easily test our application without running a server.\n\nLet's tab the  icon in the preview to see how's the request is logged.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.get('/', 'Hello World')\n\napp.fetch(new Request('http://localhost/'))\n\t.then((res) => res.text())\n\t.then(console.log)\n```\n\n---\n\n## End-to-End Type Safety\n\n**URL:** https://elysiajs.com/tutorial/features/end-to-end-type-safety.md\n\n**Contents:**\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/features/end-to-end-type-safety.md'\n---\n\nElysia provides an end-to-end type safety between backend and frontend **without code generation** similar to tRPC, using Eden.\n\nThis works by inferring the types from the Elysia instance, and use type hints to provide type safety for the client.\n\nLet's tab the  icon in the preview to see how's the request is logged.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\n// Backend\nexport const app = new Elysia()\n\t.get('/', 'Hello Elysia!')\n\t.listen(3000)\n\n// Frontend\nconst client = treaty<typeof app>('localhost:3000')\n\nconst { data, error } = await client.get()\n\nconsole.log(data) // Hello World\n```\n\n---\n\n## OpenAPI\n\n**URL:** https://elysiajs.com/tutorial/features/openapi.md\n\n**Contents:**\n- Detail\n- Reference Model\n- Type Gen\n  - Browser Environment\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/features/openapi.md'\n---\n\nElysia is built around OpenAPI, and support OpenAPI documentation out of the box.\n\nWe can use OpenAPI plugin to show an API documentation.\n\nOnce added, we can access our API documentation at **/openapi**.\n\nWe can provide document API by with a `detail` field which follows OpenAPI 3.0 specification (with auto-completion):\n\nWe can also define reusable schema with Reference Model:\n\nWhen we defined a reference model, it will be shown in the **Components** section of the OpenAPI documentation.\n\nOpenAPI Type Gen can document your API **without manual annotation** infers directly from TypeScript type. No Zod, TypeBox, manual interface declaraiont, etc.\n\n**This features is unique to Elysia**, and is not available in other JavaScript frameworks.\n\nFor example, if you use Drizzle ORM or Prisma, Elysia can infer the schema directly from the query directly.\n\n![Drizzle](/blog/openapi-type-gen/drizzle-typegen.webp)\n\n> Returning Drizzle query from Elysia route handler will be automatically inferred into OpenAPI schema.\n\nTo use OpenAPI Type Gen, simply add apply `fromTypes` plugin before `openapi` plugin.\n\nUnfortunately, this feature require a **fs** module to read your source code, and is not available this web playground. As Elysia is running directly in your browser (not a separated server).\n\nYou can try this feature locally with Type Gen Example repository:\n\nLet's use the preview to **GET '/openapi'**, and see how our API documentation looks like.\n\nThis API documentation is reflected from your code.\n\nTry to modify the code and see how the documentation changes!\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { openapi } from '@elysiajs/openapi' // [!code ++]\n\nnew Elysia()\n\t.use(openapi()) // [!code ++]\n\t.post(\n\t\t'/',\n\t\t({ body }) => body,\n\t\t{\n\t\t\tbody: t.Object({\n\t\t\t\tage: t.Number()\n\t\t\t})\n\t\t}\n\t)\n\t.listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { openapi } from '@elysiajs/openapi'\n\nnew Elysia()\n\t.use(openapi())\n\t.post(\n\t\t'/',\n\t\t({ body }) => body,\n\t\t{\n\t\t\tbody: t.Object({\n\t\t\t\tage: t.Number()\n\t\t\t}),\n\t\t\tdetail: { // [!code ++]\n\t\t\t\tsummary: 'Create a user', // [!code ++]\n\t\t\t\tdescription: 'Create a user with age', // [!code ++]\n\t\t\t\ttags: ['User'], // [!code ++]\n\t\t\t} // [!code ++]\n\t\t}\n\t)\n\t.listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { openapi } from '@elysiajs/openapi'\n\nnew Elysia()\n\t.use(openapi())\n\t.model({\n\t\tage: t.Object({ // [!code ++]\n\t\t\tage: t.Number() // [!code ++]\n\t\t}) // [!code ++]\n\t})\n\t.post(\n\t\t'/',\n\t\t({ body }) => body,\n\t\t{\n\t\t\tage: t.Object({ // [!code --]\n\t\t\t\tage: t.Number() // [!code --]\n\t\t\t}), // [!code --]\n\t\t\tbody: 'age',  // [!code ++]\n\t\t\tdetail: {\n\t\t\t\tsummary: 'Create a user',\n\t\t\t\tdescription: 'Create a user with age',\n\t\t\t\ttags: ['User'],\n\t\t\t}\n\t\t}\n\t)\n\t.listen(3000)\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nimport { openapi, fromTypes } from '@elysiajs/openapi' // [!code ++]\n\nnew Elysia()\n\t.use(openapi({\n\t\treferences: fromTypes() // [!code ++]\n\t}))\n\t.get('/', { hello: 'world' })\n\t.listen(3000)\n```\n\n---\n\n## Plugin\n\n**URL:** https://elysiajs.com/tutorial/getting-started/plugin.md\n\n**Contents:**\n  - Plugin Config\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/plugin.md'\n---\n\nEvery Elysia instance can be plug-and-play with other instances by `use` method.\n\nOnce applied, all routes from `user` instance will be available in `app` instance.\n\nYou can also create a plugin that takes argument, and returns an Elysia instance to make a more dynamic plugin.\n\nIt's also recommended that you should also read about [Key Concept: Dependency](/key-concept#dependency) to understand how Elysia handles dependencies between plugins.\n\nLet's apply the `user` instance to the `app` instance.\n\nSimilar to the above example, we can use the `use` method to plug the `user` instance into the `app` instance.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nconst user = new Elysia()\n\t.get('/profile', 'User Profile')\n\t.get('/settings', 'User Settings')\n\nnew Elysia()\n\t.use(user) // [!code ++]\n\t.get('/', 'Home')\n\t.listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nconst user = ({ log = false }) => new Elysia() // [!code ++]\n\t.onBeforeHandle(({ request }) => {\n\t\tif (log) console.log(request)\n\t})\n\t.get('/profile', 'User Profile')\n\t.get('/settings', 'User Settings')\n\nnew Elysia()\n\t.use(user({ log: true })) // [!code ++]\n\t.get('/', 'Home')\n\t.listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nconst user = new Elysia()\n\t.get('/profile', 'User Profile')\n\t.get('/settings', 'User Settings')\n\nconst app = new Elysia()\n\t.use(user) // [!code ++]\n\t.get('/', 'Home')\n\t.listen(3000)\n```\n\n---\n\n## Encapsulation\n\n**URL:** https://elysiajs.com/tutorial/getting-started/encapsulation.md\n\n**Contents:**\n  - Scope\n- Guard\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/encapsulation.md'\n---\n\nElysia hooks are **encapsulated** to its own instance only.\n\nIf you create a new instance, it will not share hook with other instances.\n\n> Try changing the path in the URL bar to **/rename** and see the result\n\n**Elysia isolate lifecycle** unless explicitly stated.\n\nThis is similar to **export** in JavaScript, where you need to export the function to make it available outside the module.\n\nTo **\"export\"** the lifecycle to other instances, you must add specify the scope.\n\nThere are 3 scopes available:\n\n1. **local** (default) - apply to only current instance and descendant only\n2. **scoped** - apply to parent, current instance and descendants\n3. **global** - apply to all instance that apply the plugin (all parents, current, and descendants)\n\nIn our case, we want to apply the sign-in check to the `app` which is a direct parent, so we can use either **scoped** or **global**.\n\nCasting lifecycle to **\"scoped\"** will export lifecycle to **parent instance**.\nWhile **\"global\"** will export lifecycle to **all instances** that has a plugin.\n\nLearn more about this in scope.\n\nSimilar to lifecycle, **schema** is also encapsulated to its own instance.\n\nWe can specify guard scope similar to lifecycle.\n\nIt's very important to note that every hook will affect all routes **after** its declaration.\n\nSee Scope for more information.\n\nLet's define a scope for `nameCheck`, and `ageCheck` to make our app works.\n\nWe can modify scope as follows:\n\n1. modify `nameCheck` scope to **scope**\n2. modify `ageCheck` scope to **global**\n\n**Examples:**\n\nExample 1 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nconst profile = new Elysia()\n\t.onBeforeHandle(\n\t\t({ query: { name }, status }) => {\n\t\t\tif(!name)\n\t\t\t\treturn status(401)\n\t\t}\n\t)\n\t.get('/profile', () => 'Hi!')\n\nnew Elysia()\n\t.use(profile)\n\t.patch('/rename', () => 'Ok! XD')\n\t.listen(3000)\n```\n\nExample 2 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nconst profile = new Elysia()\n\t.onBeforeHandle(\n\t\t{ as: 'scoped' }, // [!code ++]\n\t\t({ cookie }) => {\n\t\t\tthrowIfNotSignIn(cookie)\n\t\t}\n\t)\n\t.get('/profile', () => 'Hi there!')\n\nconst app = new Elysia()\n\t.use(profile)\n\t// This has sign in check\n\t.patch('/rename', ({ body }) => updateProfile(body))\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nconst user = new Elysia()\n\t.guard({\n\t\tas: 'scoped', // [!code ++]\n\t\tquery: t.Object({\n\t\t\tage: t.Number(),\n\t\t\tname: t.Optional(t.String())\n\t\t}),\n\t\tbeforeHandle({ query: { age }, status }) {\n\t\t\tif(age < 18) return status(403)\n\t\t}\n\t})\n\t.get('/profile', () => 'Hi!')\n\t.get('/settings', () => 'Settings')\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\n\nconst nameCheck = new Elysia()\n\t.onBeforeHandle(\n\t\t{ as: 'scoped' }, // [!code ++]\n\t\t({ query: { name }, status }) => {\n\t\t\tif(!name) return status(401)\n\t\t}\n\t)\n\nconst ageCheck = new Elysia()\n\t.guard({\n\t\tas: 'global', // [!code ++]\n\t\tquery: t.Object({\n\t\t\tage: t.Number(),\n\t\t\tname: t.Optional(t.String())\n\t\t}),\n\t\tbeforeHandle({ query: { age }, status }) {\n\t\t\tif(age < 18) return status(403)\n\t\t}\n\t})\n\nconst name = new Elysia()\n\t.use(nameCheck)\n\t.patch('/rename', () => 'Ok! XD')\n\nconst profile = new Elysia()\n\t.use(ageCheck)\n\t.use(name)\n\t.get('/profile', () => 'Hi!')\n\nnew Elysia()\n\t.use(profile)\n\t.listen(3000)\n```\n\n---\n\n## Handler and Context\n\n**URL:** https://elysiajs.com/tutorial/getting-started/handler-and-context.md\n\n**Contents:**\n- Context\n- Preview\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/handler-and-context.md'\n---\n\n**Handler** - a resource or a route function to send data back to client.\n\nA handler can also be a literal value, see Handler\n\nUsing an inline value can be useful for static resource like **file**.\n\nContains information about each request. It is passed as the only argument of a handler.\n\n**Context** stores information about the request like:\n\n* body - data sent by client to server like form data, JSON payload.\n* query - query string as an object. (Query is extracted from a value after pathname starting from '?' question mark sign)\n* params - Path parameters parsed as object\n* headers - HTTP Header, additional information about the request like \"Content-Type\".\n\nYou can preview the result by looking under the **editor** section.\n\nThere should be a tiny navigator on the **top left** of the preview window.\n\nYou can use it to switch between path and method to see the response.\n\nYou can also click  to edit body, and headers.\n\nLet's try extracting context parameters:\n\n1. We can extract `body`, `query`, and `headers` from the first value of a callback function.\n2. We can then return them like `{ body, query, headers }`.\n\n**Examples:**\n\nExample 1 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    // `() => 'hello world'` is a handler\n    .get('/', () => 'hello world')\n    .listen(3000)\n```\n\nExample 2 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    // `'hello world'` is a handler\n    .get('/', 'hello world')\n    .listen(3000)\n```\n\nExample 3 (unknown):\n```unknown\n**Context** stores information about the request like:\n\n* body - data sent by client to server like form data, JSON payload.\n* query - query string as an object. (Query is extracted from a value after pathname starting from '?' question mark sign)\n* params - Path parameters parsed as object\n* headers - HTTP Header, additional information about the request like \"Content-Type\".\n\nSee Context.\n\n## Preview\n\nYou can preview the result by looking under the **editor** section.\n\nThere should be a tiny navigator on the **top left** of the preview window.\n\nYou can use it to switch between path and method to see the response.\n\nYou can also click  to edit body, and headers.\n\n## Assignment\n\nLet's try extracting context parameters:\n\n\\<template #answer>\n\n1. We can extract `body`, `query`, and `headers` from the first value of a callback function.\n2. We can then return them like `{ body, query, headers }`.\n```\n\n---\n\n## Guard\n\n**URL:** https://elysiajs.com/tutorial/getting-started/guard.md\n\n**Contents:**\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/guard.md'\n---\n\nWhen you need to apply multiple hook to your application, instead of repeating hook multiple time, you can use `guard` to bulk add hooks to your application.\n\nNot only that, you can also apply **schema** to multiple routes using `guard`.\n\nThis will apply hooks and schema to every routes **after .guard** is called in the same instance.\n\nSee Guard for more information.\n\nLet's put 2 types of hooks into practice.\n\nWe can use `beforeHandle` to intercept the request before it reaches the handler, and return a response with `status` method.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.onBeforeHandle(({ query: { name }, status }) => { // [!code --]\n\t\tif(!name) return status(401) // [!code --]\n\t}) // [!code --]\n\t.onBeforeHandle(({ query: { name } }) => { // [!code --]\n\t\tconsole.log(name) // [!code --]\n\t}) // [!code --]\n\t.onAfterResponse(({ responseValue }) => { // [!code --]\n\t\tconsole.log(responseValue) // [!code --]\n\t}) // [!code --]\n\t.guard({ // [!code ++]\n\t\tbeforeHandle: [ // [!code ++]\n\t\t\t({ query: { name }, status }) => { // [!code ++]\n\t\t\t\tif(!name) return status(401) // [!code ++]\n\t\t\t}, // [!code ++]\n\t\t\t({ query: { name } }) => { // [!code ++]\n\t\t\t\tconsole.log(name) // [!code ++]\n\t\t\t} // [!code ++]\n\t\t], // [!code ++]\n\t\tafterResponse({ responseValue }) { // [!code ++]\n\t\t\tconsole.log(responseValue) // [!code ++]\n\t\t} // [!code ++]\n\t}) // [!code ++]\n\t.get(\n\t\t'/auth',\n\t\t({ query: { name = 'anon' } }) => `Hello ${name}!`,\n\t\t{\n\t\t\tquery: t.Object({\n\t\t\t\tname: t.String()\n\t\t\t})\n\t\t}\n\t)\n\t.get(\n\t\t'/profile',\n\t\t({ query: { name = 'anon' } }) => `Hello ${name}!`,\n\t\t{\n\t\t\tquery: t.Object({\n\t\t\t\tname: t.String()\n\t\t\t})\n\t\t}\n\t)\n\t.listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.guard({\n\t\tbeforeHandle: [\n\t\t\t({ query: { name }, status }) => {\n\t\t\t\tif(!name) return status(401)\n\t\t\t},\n\t\t\t({ query: { name } }) => {\n\t\t\t\tconsole.log(name)\n\t\t\t}\n\t\t],\n\t\tafterResponse({ responseValue }) {\n\t\t\tconsole.log(responseValue)\n\t\t},\n\t\tquery: t.Object({ // [!code ++]\n\t\t\tname: t.String() // [!code ++]\n\t\t}) // [!code ++]\n\t})\n\t.get(\n\t\t'/auth',\n\t\t({ query: { name = 'anon' } }) => `Hello ${name}!`,\n\t\t{ // [!code --]\n\t\t\tquery: t.Object({ // [!code --]\n\t\t\t\tname: t.String() // [!code --]\n\t\t\t}) // [!code --]\n\t\t} // [!code --]\n\t)\n\t.get(\n\t\t'/profile',\n\t\t({ query: { name = 'anon' } }) => `Hello ${name}!`,\n\t\t{ // [!code --]\n\t\t\tquery: t.Object({ // [!code --]\n\t\t\t\tname: t.String() // [!code --]\n\t\t\t}) // [!code --]\n\t\t} // [!code --]\n\t)\n\t.listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.onBeforeHandle(({ query: { name }, status }) => {\n\t\tif(!name) return status(401)\n\t})\n\t.get('/auth', ({ query: { name = 'anon' } }) => {\n\t\treturn `Hello ${name}!`\n\t})\n\t.get('/profile', ({ query: { name = 'anon' } }) => {\n\t\treturn `Hello ${name}!`\n\t})\n\t.listen(3000)\n```\n\n---\n\n## Validation\n\n**URL:** https://elysiajs.com/tutorial/getting-started/validation.md\n\n**Contents:**\n  - Bring your own\n- Validation Type\n- Response Validation\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/validation.md'\n---\n\nElysia offers data validation out of the box.\n\nYou can use `Elysia.t` to define a schema.\n\nWhen you define a schema, Elysia will ensure the data is in a correct shape.\n\nIf the data doesn't match the schema, Elysia will return a **422 Unprocessable Entity** error.\n\nAlternatively, Elysia support **Standard Schema**, allowing you to use a library of your choice like **zod**, **yup** or **valibot**.\n\nSee Standard Schema for all compatible schema.\n\nYou can validate the following property:\n\n* `body`\n* `query`\n* `params`\n* `headers`\n* `cookie`\n* `response`\n\nOnce schema is defined, Elysia will infers type for you so You don't have to define a separate schema in TypeScript.\n\nSee Schema Type for each type.\n\nWhen you define a validation schema for `response`, Elysia will validate the response before sending it to the client, and type check the response for you.\n\nYou can also specify which status code to validate:\n\nSee Response Validation.\n\nLet's exercise what we have learned.\n\nWe can define a schema by using `t.Object` provide to `body` property.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.post(\n\t\t'/user',\n\t\t({ body: { name } }) => `Hello ${name}!`,\n\t\t{\n\t\t\tbody: t.Object({\n\t\t\t\tname: t.String(),\n\t\t\t\tage: t.Number()\n\t\t\t})\n\t\t}\n\t)\n\t.listen(3000)\n```\n\nExample 2 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\nimport { z } from 'zod'\n\nnew Elysia()\n\t.post(\n\t\t'/user',\n\t\t({ body: { name } }) => `Hello ${name}!`,\n\t\t{\n\t\t\tbody: z.object({\n\t\t\t\tname: z.string(),\n\t\t\t\tage: z.number()\n\t\t\t})\n\t\t}\n\t)\n\t.listen(3000)\n```\n\nExample 3 (typescript):\n```typescript\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.get(\n\t\t'/user',\n\t\t() => `Hello Elysia!`,\n\t\t{\n\t\t\tresponse: {\n\t\t\t\t200: t.Literal('Hello Elysia!'),\n\t\t\t\t418: t.Object({\n\t\t\t\t\tmessage: t.Literal(\"I'm a teapot\")\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t)\n\t.listen(3000)\n```\n\nExample 4 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', ({ status, set }) => {\n\t\tset.headers['x-powered-by'] = 'Elysia'\n\n\t\treturn status(418, 'Hello Elysia!')\n\t})\n\t.get('/docs', ({ redirect }) => redirect('https://elysiajs.com'))\n\t.listen(3000)\n```\n\n---\n\n## Congratulations!\n\n**URL:** https://elysiajs.com/tutorial/whats-next.md\n\n**Contents:**\n- First up\n  - llms.txt\n  - If you are stuck\n- From other Framework?\n- Essential Chapter\n- More Patterns\n- Integration with Meta Framework\n- Integration with your favorite tool\n\n---\nurl: 'https://elysiajs.com/tutorial/whats-next.md'\n---\n\nYou have completed the tutorial.\n\nNow you're ready to build your own application with Elysia!\n\nWe highly recommended you to check out these 2 pages first before getting started with Elysia:\n\nAlternatively, you can download llms.txt or llms-full.txt and feed it to your favorite LLMs like ChatGPT, Claude or Gemini to get a more interactive experience.\n\nFeel free to ask our community on GitHub Discussions, Discord, and Twitter.\n\nIf you have used other popular frameworks like Express, Fastify, or Hono, you will find Elysia right at home with just a few differences.\n\nHere are the foundation of Elysia, we highly recommended you to go through these pages before jumping to other topics:\n\nIf you feels like exploring more Elysia feature, check out:\n\nWe can also use Elysia with Meta Framework like Nextjs, Nuxt, Astro, etc.\n\nWe have some integration with popular tools:\n\nWe hope you will love Elysia as much as we do!\n\n---\n\n## Your First Route\n\n**URL:** https://elysiajs.com/tutorial/getting-started/your-first-route.md\n\n**Contents:**\n- Routing\n- Static Path\n- Dynamic path\n  - Optional path parameters\n- Wildcards\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial/getting-started/your-first-route.md'\n---\n\nWhen we enter a website, it takes\n\n1. **path** like `/`, `/about`, or `/contact`\n2. **method** like `GET`, `POST`, or `DELETE`\n\nTo determine what a resource to show, simply called **\"route\"**.\n\nIn Elysia, we can define a route by:\n\n1. Call method named after HTTP method\n2. Path being the first argument\n3. Handler being the second argument\n\nPath in Elysia can be grouped into 3 types:\n\n1. static paths - static string to locate the resource\n2. dynamic paths - segment can be any value\n3. wildcards - path until a specific point can be anything\n\nStatic path is a hardcoded string to locate the resource on the server.\n\nDynamic paths match some part and capture the value to extract extra information.\n\nTo define a dynamic path, we can use a colon `:` followed by a name.\n\nHere, a dynamic path is created with `/id/:id`. Which tells Elysia to capture the value `:id` segment with value like **/id/1**, **/id/123**, **/id/anything**.\n\nWe can make a path parameter optional by adding a question mark `?` after the parameter name.\n\nSee Optional Path Parameters.\n\nDynamic paths allow capturing a single segment while wildcards allow capturing the rest of the path.\n\nTo define a wildcard, we can use an asterisk `*`.\n\nLet's recap, and create 3 paths with different types:\n\n1. Static path `/elysia` that responds with `\"Hello Elysia!\"`\n2. Dynamic path `/friends/:name?` that responds with `\"Hello {name}!\"`\n3. Wildcard path `/flame-chasers/*` that responds with the rest of the path.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', 'Hello World!')\n\t.listen(3000)\n```\n\nExample 2 (ts):\n```ts\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/hello', 'hello')\n\t.get('/hi', 'hi')\n\t.listen(3000)\n```\n\nExample 3 (unknown):\n```unknown\nHere, a dynamic path is created with `/id/:id`. Which tells Elysia to capture the value `:id` segment with value like **/id/1**, **/id/123**, **/id/anything**.\n\nSee Dynamic Path.\n\n### Optional path parameters\n\nWe can make a path parameter optional by adding a question mark `?` after the parameter name.\n```\n\nExample 4 (unknown):\n```unknown\nSee Optional Path Parameters.\n\n## Wildcards\n\nDynamic paths allow capturing a single segment while wildcards allow capturing the rest of the path.\n\nTo define a wildcard, we can use an asterisk `*`.\n```\n\n---\n\n## Welcome to Elysia\n\n**URL:** https://elysiajs.com/tutorial.md\n\n**Contents:**\n- What is Elysia\n- How to use this playground\n- Assignment\n\n---\nurl: 'https://elysiajs.com/tutorial.md'\n---\n\nIt's great to have you here! This playground is will help you get started with Elysia interactively.\n\nUnlike traditional backend framework, **Elysia can also run in a browser** as well! Although it doesn't support all features, it's a perfect environment for learning and experimentation.\n\nYou can check out the API docs by clicking  on the left sidebar.\n\nElysia is an ergonomic framework for humans.\n\nOk, seriously, Elysia is a backend TypeScript framework that focuses on developer experience and performance.\n\nWhat makes Elysia different from other frameworks is that:\n\n1. Spectacular performance comparable to Golang.\n2. Extraordinary TypeScript support with **type soundness**.\n3. Built around OpenAPI from the ground up.\n4. Offers End-to-end Type Safety like tRPC.\n5. Use Web Standard, allows you to run your code anywhere like Cloudflare Workers, Deno, Bun, Node.js and more.\n6. It is, of course, **designed for humans** first.\n\nAlthough Elysia has some important concept but once get the hang of it, many people find it very enjoyable, and intuative to work with.\n\nPlayground is divided into 3 sections:\n\n1. Documentation and task on the left side (you're reading).\n2. Code editor in the top right\n3. Preview, output, and console in the bottom right\n\nAs for the first assignment, let's modify the code to make the server respond with `\"Hello Elysia!\"` instead of `\"Hello World!\"`.\n\nFeels free to look around the code editor and preview section to get familiar with the environment.\n\nYou can change the response by changing the content inside the `.get` method from `'Hello World!'` to `'Hello Elysia!'`.\n\nThis would make Elysia response with `\"Hello Elysia!\"` when you access `/`.\n\n**Examples:**\n\nExample 1 (typescript):\n```typescript\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', 'Hello World!') // [!code --]\n\t.get('/', 'Hello Elysia!') // [!code ++]\n\t.listen(3000)\n```\n\n---\n",
        "plugins/testing/playwright/.claude-plugin/plugin.json": "{\n  \"name\": \"playwright\",\n  \"description\": \"Comprehensive Playwright-based E2E testing plugin with test generation, Page Object Models, debugging, and maintenance capabilities. Follows best practices including data-testid locators and TypeScript-first approach.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Joel Chan\",\n    \"email\": \"joel611@live.hk\"\n  }\n}\n",
        "plugins/testing/playwright/commands/create-page-object.md": "# Create Page Object Command\n\n## Description\n\nCreate a Page Object Model (POM) for a specific page or component. Generates a TypeScript class with locators and methods following the Page Object pattern with data-testid locators.\n\n## Usage\n\n```\n/create-page-object [page-name]\n```\n\n## Parameters\n\n- `page-name` - Name of the page or component (required)\n\n## Examples\n\n```\n/create-page-object LoginPage\n```\n\n```\n/create-page-object ProductDetailsPage\n```\n\n```\n/create-page-object CheckoutForm\n```\n\n## Instructions for Claude\n\nWhen this command is invoked:\n\n1. **Invoke the page-object-builder skill** to handle the Page Object creation\n\n2. **Gather information**:\n   - Page name and URL\n   - Key elements on the page\n   - Common user actions\n   - data-testid values for elements\n\n3. **Generate Page Object class**:\n   - TypeScript class with proper types\n   - Readonly locators using data-testid\n   - Constructor accepting Page object\n   - goto() method for navigation\n   - Action methods (async)\n   - Getter methods for assertions\n\n4. **Provide usage example**:\n   - Show how to use the Page Object in tests\n   - Demonstrate common actions\n   - Show assertion patterns\n\n5. **List required data-testid values**:\n   - Document all testid values needed in the UI\n   - Provide semantic naming suggestions\n\n## Error Handling\n\n- If page name is missing, prompt for it\n- If insufficient information, ask for page details\n- Suggest data-testid names if not provided\n- Warn if Page Object seems too large (consider splitting)\n\n## Notes\n\n- All locators must use data-testid\n- Page Objects should not contain assertions\n- Use getters for elements that need assertions\n- Keep Page Objects focused on a single page/component\n",
        "plugins/testing/playwright/commands/debug-test.md": "# Debug Test Command\n\n## Description\n\nDebug a failing Playwright test by analyzing error messages, screenshots, and traces. Provides actionable solutions for common test failures including timeouts, selector issues, and race conditions.\n\n## Usage\n\n```\n/debug-test [test-name-or-error]\n```\n\n## Parameters\n\n- `test-name-or-error` - Test name, file path, or error message (optional)\n\n## Examples\n\n```\n/debug-test login.spec.ts\n```\n\n```\n/debug-test TimeoutError: waiting for selector\n```\n\n```\n/debug-test Test \"user dashboard loads\" is flaky\n```\n\n## Instructions for Claude\n\nWhen this command is invoked:\n\n1. **Invoke the test-debugger skill** to handle debugging\n\n2. **Gather failure information**:\n   - Error message and stack trace\n   - Test file location\n   - Expected vs actual behavior\n   - Screenshots/traces if available\n   - Failure frequency (always or intermittent)\n\n3. **Analyze the error**:\n   - Identify error type (timeout, selector, assertion, etc.)\n   - Determine root cause\n   - Check for common issues (missing waits, wrong testid, race conditions)\n\n4. **Optionally use Playwright MCP**:\n   - Navigate to the page if needed\n   - Inspect element state\n   - Test locator strategies\n   - Verify data-testid values\n\n5. **Provide solution**:\n   - Explain what's wrong\n   - Show the fix with code examples\n   - Explain how to prevent in future\n   - Provide verification steps\n\n6. **Apply the fix if requested**:\n   - Update the test code\n   - Add missing waits\n   - Fix locators\n   - Improve test stability\n\n## Error Handling\n\n- If insufficient information, ask for error details\n- If test file not found, ask for correct path\n- If error is unclear, use MCP to investigate\n- If multiple issues, prioritize and fix one at a time\n\n## Notes\n\n- Most test failures are timing-related\n- Always verify data-testid values are correct\n- Use explicit waits, not hardcoded timeouts\n- Check test isolation if flaky\n- Run tests multiple times to verify fix\n",
        "plugins/testing/playwright/commands/fix-flaky.md": "# Fix Flaky Test Command\n\n## Description\n\nAnalyze and fix flaky (intermittently failing) Playwright tests. Identifies race conditions, improves waiting strategies, and ensures test stability.\n\n## Usage\n\n```\n/fix-flaky [test-name]\n```\n\n## Parameters\n\n- `test-name` - Name or path of the flaky test (required)\n\n## Examples\n\n```\n/fix-flaky dashboard.spec.ts\n```\n\n```\n/fix-flaky \"should load user profile\"\n```\n\n```\n/fix-flaky tests/checkout.spec.ts:42\n```\n\n## Instructions for Claude\n\nWhen this command is invoked:\n\n1. **Invoke the test-debugger and test-maintainer skills** for analysis\n\n2. **Gather information**:\n   - Test file and name\n   - Failure pattern (how often it fails)\n   - Error messages when it fails\n   - Environment (local vs CI)\n   - Which step usually fails\n\n3. **Identify flakiness causes**:\n   - Race conditions\n   - Missing waits\n   - Hardcoded timeouts\n   - Network dependencies\n   - Test isolation issues\n   - Environment differences\n\n4. **Common fixes**:\n   - Add explicit waits before interactions\n   - Replace waitForTimeout() with proper waits\n   - Wait for network to settle\n   - Wait for specific API responses\n   - Increase timeouts for slow operations\n   - Improve test isolation\n   - Add retry configuration\n\n5. **Apply improvements**:\n   - Update test code\n   - Add proper waits\n   - Fix race conditions\n   - Ensure test isolation\n   - Configure retries if needed\n\n6. **Verify stability**:\n   - Run test multiple times (10+ times)\n   - Test in different environments\n   - Check in CI environment\n   - Monitor for continued flakiness\n\n## Error Handling\n\n- If test not found, ask for correct path\n- If can't reproduce failure, ask for more details\n- If multiple issues, fix most impactful first\n- Warn if test design is fundamentally flaky\n\n## Notes\n\n- Flakiness is usually caused by timing issues\n- Never use waitForTimeout() - use explicit waits\n- Wait for network/animations to complete\n- Ensure tests are isolated and don't share state\n- Run tests 10+ times to verify fix\n- Consider enabling retries for legitimately slow operations\n",
        "plugins/testing/playwright/commands/generate-test.md": "# Generate Test Command\n\n## Description\n\nGenerate a production-ready Playwright E2E test from a natural language description. Creates TypeScript test files following best practices including data-testid locators, AAA pattern, and proper async/await usage.\n\n## Usage\n\n```\n/generate-test [description]\n```\n\n## Parameters\n\n- `description` - Natural language description of the test scenario (required)\n\n## Examples\n\n```\n/generate-test Login flow with valid credentials\n```\n\n```\n/generate-test Add item to cart and complete checkout\n```\n\n```\n/generate-test Form validation for empty email field\n```\n\n## Instructions for Claude\n\nWhen this command is invoked:\n\n1. **Invoke the test-generator skill** to handle the test generation\n2. **Gather requirements** from the user:\n   - Feature/functionality to test\n   - User flow or scenario\n   - Expected outcomes\n   - Page URLs involved\n   - data-testid values (or suggest them)\n\n3. **Generate the test file** following these requirements:\n   - TypeScript file with `.spec.ts` extension\n   - Use only data-testid locators\n   - Follow AAA pattern (Arrange-Act-Assert)\n   - Include proper async/await\n   - Add explicit waits (no hardcoded timeouts)\n   - Include meaningful assertions\n   - Add comments for clarity\n\n4. **Create supporting files if needed**:\n   - `playwright.config.ts` if first test\n   - Custom fixtures if needed\n   - Utility functions if reusable\n\n5. **Provide usage instructions**:\n   - How to run the test\n   - What data-testid values need to be added to UI\n   - How to debug if it fails\n\n6. **Validate the generated test**:\n   - Ensure only data-testid locators\n   - Check for proper waits\n   - Verify AAA structure\n   - Confirm TypeScript types\n\n## Error Handling\n\n- If description is too vague, ask clarifying questions\n- If missing required information (URLs, element names), prompt user\n- If data-testid values aren't provided, suggest semantic names\n- Warn if the test scenario seems too complex for a single test\n\n## Notes\n\n- Tests should be focused and test one specific behavior\n- Always use data-testid for locators (MANDATORY)\n- Include explicit waits, never use waitForTimeout()\n- Follow Playwright and TypeScript best practices\n- Ensure tests are maintainable and readable\n",
        "plugins/testing/playwright/skills/page-object-builder/SKILL.md": "---\nname: playwright-page-object-builder\ndescription: Create maintainable and reusable Page Object Models (POMs) for Playwright tests. Generates TypeScript classes that encapsulate page-specific locators and actions, following the Page Object Model design pattern with data-testid locators exclusively.\n---\n\n## When to Use This Skill\n\nUse this skill when you need to:\n\n- Create a Page Object Model for a specific page or component\n- Refactor tests to use the POM pattern\n- Build reusable page classes for complex applications\n- Encapsulate page-specific logic and locators\n- Improve test maintainability and reduce duplication\n\nDo NOT use this skill when:\n\n- Writing simple one-off tests (use test-generator skill)\n- Debugging existing tests (use test-debugger skill)\n- Refactoring existing POMs (use test-maintainer skill)\n\n## Prerequisites\n\nBefore using this skill:\n\n1. Understanding of the page structure and elements\n2. Knowledge of user interactions on the page\n3. List of data-testid values for page elements (or ability to suggest them)\n4. Playwright installed in the project\n5. Basic understanding of TypeScript classes\n\n## Instructions\n\n### Step 1: Identify Page Information\n\nGather from the user:\n\n- **Page name** or component name\n- **Page URL** or route\n- **Key elements** on the page (buttons, inputs, text, etc.)\n- **Common actions** users perform on the page\n- **data-testid values** for all elements (or help define them)\n\n### Step 2: Plan Page Object Structure\n\nDetermine:\n\n- **Class name** (e.g., `LoginPage`, `DashboardPage`, `CheckoutPage`)\n- **Properties**: Locators for all page elements\n- **Methods**: Actions users can perform (login, addToCart, etc.)\n- **Getters**: Read-only properties for assertions\n- **Navigation**: How to reach this page\n\n### Step 3: Create Page Object Class\n\nGenerate a TypeScript class with:\n\n**Structure:**\n\n```typescript\nimport { Page, Locator } from \"@playwright/test\";\n\nexport class PageName {\n  readonly page: Page;\n\n  // Locators\n  readonly elementName: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.elementName = page.locator('[data-testid=\"element-name\"]');\n  }\n\n  // Navigation\n  async goto() {\n    await this.page.goto(\"/page-url\");\n  }\n\n  // Actions\n  async performAction() {\n    await this.elementName.click();\n  }\n\n  // Getters for assertions\n  getElement() {\n    return this.elementName;\n  }\n}\n```\n\n**Key Requirements:**\n\n1. All locators use data-testid (MANDATORY)\n2. Locators are readonly properties\n3. Constructor accepts Page object\n4. Include goto() method for navigation\n5. Action methods are async and return Promise<void>\n6. Getter methods for elements that need assertions\n7. Use TypeScript types\n8. Add JSDoc comments for complex methods\n\n### Step 4: Define Locators\n\nFor each element:\n\n```typescript\nreadonly elementName: Locator;\n\nconstructor(page: Page) {\n  this.page = page;\n  this.elementName = page.locator('[data-testid=\"element-name\"]');\n}\n```\n\n**Naming Convention:**\n\n- Use camelCase for properties\n- Descriptive names (e.g., `submitButton`, `emailInput`, `errorMessage`)\n- Suffix with element type when helpful (Button, Input, Message, Link)\n\n### Step 5: Implement Action Methods\n\nFor each user action:\n\n```typescript\n/**\n * Descriptive action name\n * @param param - Parameter description if needed\n */\nasync actionName(param?: string): Promise<void> {\n  // Wait for element if needed\n  await this.element.waitFor({ state: 'visible' });\n\n  // Perform action\n  await this.element.click();\n  // or\n  await this.element.fill(param);\n}\n```\n\n**Common Actions:**\n\n- Form filling: `async fillForm(data: FormData)`\n- Button clicks: `async clickButton()`\n- Navigation: `async navigateTo(section: string)`\n- Complex workflows: `async completeCheckout(details: CheckoutDetails)`\n\n### Step 6: Add Getter Methods\n\nFor elements that tests will assert against:\n\n```typescript\ngetElementName(): Locator {\n  return this.elementName;\n}\n\nasync getTextContent(): Promise<string> {\n  return await this.element.textContent() || '';\n}\n\nasync isElementVisible(): Promise<boolean> {\n  return await this.element.isVisible();\n}\n```\n\n### Step 7: Validate Page Object\n\nEnsure the Page Object includes:\n\n- [ ] All locators use data-testid\n- [ ] Locators are readonly\n- [ ] All methods are async\n- [ ] Constructor accepts Page\n- [ ] goto() method for navigation\n- [ ] JSDoc comments for public methods\n- [ ] TypeScript types for parameters\n- [ ] Meaningful method names\n- [ ] No test assertions in POM (only actions and getters)\n\n### Step 8: Provide Usage Example\n\nShow how to use the Page Object in tests:\n\n```typescript\nimport { test, expect } from \"@playwright/test\";\nimport { PageName } from \"./page-objects/PageName\";\n\ntest(\"test description\", async ({ page }) => {\n  const pageName = new PageName(page);\n\n  await pageName.goto();\n  await pageName.performAction();\n  await expect(pageName.getElement()).toBeVisible();\n});\n```\n\n## Examples\n\n### Example 1: Login Page Object\n\n**Input:**\n\"Create a Page Object for the login page with username, password fields, login button, and error message.\"\n\n**Output:**\n\n```typescript\nimport { Page, Locator } from \"@playwright/test\";\n\n/**\n * Page Object Model for the Login Page\n *\n * Handles user authentication flow including:\n * - Filling login credentials\n * - Submitting the form\n * - Accessing error messages\n */\nexport class LoginPage {\n  readonly page: Page;\n\n  // Locators\n  readonly usernameInput: Locator;\n  readonly passwordInput: Locator;\n  readonly loginButton: Locator;\n  readonly errorMessage: Locator;\n  readonly forgotPasswordLink: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.usernameInput = page.locator('[data-testid=\"username-input\"]');\n    this.passwordInput = page.locator('[data-testid=\"password-input\"]');\n    this.loginButton = page.locator('[data-testid=\"login-button\"]');\n    this.errorMessage = page.locator('[data-testid=\"error-message\"]');\n    this.forgotPasswordLink = page.locator(\n      '[data-testid=\"forgot-password-link\"]',\n    );\n  }\n\n  /**\n   * Navigate to the login page\n   */\n  async goto(): Promise<void> {\n    await this.page.goto(\"/login\");\n    await this.page.waitForLoadState(\"domcontentloaded\");\n  }\n\n  /**\n   * Perform login with credentials\n   * @param username - User's username or email\n   * @param password - User's password\n   */\n  async login(username: string, password: string): Promise<void> {\n    await this.usernameInput.waitFor({ state: \"visible\" });\n    await this.usernameInput.fill(username);\n    await this.passwordInput.fill(password);\n    await this.loginButton.click();\n  }\n\n  /**\n   * Fill only the username field\n   */\n  async fillUsername(username: string): Promise<void> {\n    await this.usernameInput.fill(username);\n  }\n\n  /**\n   * Fill only the password field\n   */\n  async fillPassword(password: string): Promise<void> {\n    await this.passwordInput.fill(password);\n  }\n\n  /**\n   * Click the login button\n   */\n  async clickLogin(): Promise<void> {\n    await this.loginButton.click();\n  }\n\n  /**\n   * Click forgot password link\n   */\n  async clickForgotPassword(): Promise<void> {\n    await this.forgotPasswordLink.click();\n  }\n\n  /**\n   * Get the error message element for assertions\n   */\n  getErrorMessage(): Locator {\n    return this.errorMessage;\n  }\n\n  /**\n   * Check if error message is visible\n   */\n  async hasError(): Promise<boolean> {\n    try {\n      await this.errorMessage.waitFor({ state: \"visible\", timeout: 2000 });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get the text content of the error message\n   */\n  async getErrorText(): Promise<string> {\n    const text = await this.errorMessage.textContent();\n    return text?.trim() || \"\";\n  }\n}\n```\n\n**Usage:**\n\n```typescript\nimport { test, expect } from \"@playwright/test\";\nimport { LoginPage } from \"./page-objects/LoginPage\";\n\ntest.describe(\"Login Flow\", () => {\n  test(\"should login successfully with valid credentials\", async ({ page }) => {\n    const loginPage = new LoginPage(page);\n\n    await loginPage.goto();\n    await loginPage.login(\"user@example.com\", \"SecurePass123\");\n\n    // Assert navigation to dashboard\n    await page.waitForURL(\"/dashboard\");\n  });\n\n  test(\"should show error with invalid credentials\", async ({ page }) => {\n    const loginPage = new LoginPage(page);\n\n    await loginPage.goto();\n    await loginPage.login(\"invalid@example.com\", \"wrongpass\");\n\n    // Assert error message\n    await expect(loginPage.getErrorMessage()).toBeVisible();\n    await expect(loginPage.getErrorMessage()).toContainText(\n      \"Invalid credentials\",\n    );\n  });\n});\n```\n\n### Example 2: Product Page Object\n\n**Input:**\n\"Create a Page Object for a product details page with product name, price, description, quantity selector, add to cart button, and reviews section.\"\n\n**Output:**\n\n```typescript\nimport { Page, Locator } from \"@playwright/test\";\n\n/**\n * Page Object Model for Product Details Page\n *\n * Handles product viewing and purchasing actions including:\n * - Viewing product details\n * - Selecting quantity\n * - Adding to cart\n * - Reading reviews\n */\nexport class ProductPage {\n  readonly page: Page;\n\n  // Product Information Locators\n  readonly productName: Locator;\n  readonly productPrice: Locator;\n  readonly productDescription: Locator;\n  readonly productImage: Locator;\n\n  // Purchase Locators\n  readonly quantityInput: Locator;\n  readonly addToCartButton: Locator;\n  readonly buyNowButton: Locator;\n\n  // Reviews Locators\n  readonly reviewsSection: Locator;\n  readonly reviewItems: Locator;\n  readonly averageRating: Locator;\n\n  // Additional Actions\n  readonly wishlistButton: Locator;\n  readonly shareButton: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n\n    // Product information\n    this.productName = page.locator('[data-testid=\"product-name\"]');\n    this.productPrice = page.locator('[data-testid=\"product-price\"]');\n    this.productDescription = page.locator(\n      '[data-testid=\"product-description\"]',\n    );\n    this.productImage = page.locator('[data-testid=\"product-image\"]');\n\n    // Purchase\n    this.quantityInput = page.locator('[data-testid=\"quantity-input\"]');\n    this.addToCartButton = page.locator('[data-testid=\"add-to-cart-button\"]');\n    this.buyNowButton = page.locator('[data-testid=\"buy-now-button\"]');\n\n    // Reviews\n    this.reviewsSection = page.locator('[data-testid=\"reviews-section\"]');\n    this.reviewItems = page.locator('[data-testid=\"review-item\"]');\n    this.averageRating = page.locator('[data-testid=\"average-rating\"]');\n\n    // Actions\n    this.wishlistButton = page.locator('[data-testid=\"wishlist-button\"]');\n    this.shareButton = page.locator('[data-testid=\"share-button\"]');\n  }\n\n  /**\n   * Navigate to a product page by ID\n   */\n  async goto(productId: string): Promise<void> {\n    await this.page.goto(`/products/${productId}`);\n    await this.page.waitForLoadState(\"domcontentloaded\");\n  }\n\n  /**\n   * Set the quantity for purchase\n   */\n  async setQuantity(quantity: number): Promise<void> {\n    await this.quantityInput.waitFor({ state: \"visible\" });\n    await this.quantityInput.clear();\n    await this.quantityInput.fill(quantity.toString());\n  }\n\n  /**\n   * Add product to cart with specified quantity\n   */\n  async addToCart(quantity = 1): Promise<void> {\n    if (quantity > 1) {\n      await this.setQuantity(quantity);\n    }\n    await this.addToCartButton.waitFor({ state: \"enabled\" });\n    await this.addToCartButton.click();\n  }\n\n  /**\n   * Click Buy Now button\n   */\n  async buyNow(): Promise<void> {\n    await this.buyNowButton.click();\n  }\n\n  /**\n   * Add product to wishlist\n   */\n  async addToWishlist(): Promise<void> {\n    await this.wishlistButton.click();\n  }\n\n  /**\n   * Click share button\n   */\n  async shareProduct(): Promise<void> {\n    await this.shareButton.click();\n  }\n\n  /**\n   * Get product name text\n   */\n  async getProductName(): Promise<string> {\n    const text = await this.productName.textContent();\n    return text?.trim() || \"\";\n  }\n\n  /**\n   * Get product price text\n   */\n  async getProductPrice(): Promise<string> {\n    const text = await this.productPrice.textContent();\n    return text?.trim() || \"\";\n  }\n\n  /**\n   * Get number of reviews\n   */\n  async getReviewCount(): Promise<number> {\n    return await this.reviewItems.count();\n  }\n\n  /**\n   * Get average rating text\n   */\n  async getAverageRating(): Promise<string> {\n    const text = await this.averageRating.textContent();\n    return text?.trim() || \"\";\n  }\n\n  // Getters for assertions\n  getProductNameElement(): Locator {\n    return this.productName;\n  }\n\n  getProductPriceElement(): Locator {\n    return this.productPrice;\n  }\n\n  getAddToCartButton(): Locator {\n    return this.addToCartButton;\n  }\n\n  getReviewsSection(): Locator {\n    return this.reviewsSection;\n  }\n}\n```\n\n### Example 3: Dashboard Page with Multiple Sections\n\n**Input:**\n\"Create a Page Object for a dashboard with header, sidebar navigation, main content area, and user profile dropdown.\"\n\n**Output:**\n\n```typescript\nimport { Page, Locator } from \"@playwright/test\";\n\n/**\n * Page Object Model for Dashboard Page\n *\n * Handles dashboard navigation and interactions including:\n * - Sidebar navigation\n * - User profile actions\n * - Dashboard content\n */\nexport class DashboardPage {\n  readonly page: Page;\n\n  // Header Locators\n  readonly header: Locator;\n  readonly logo: Locator;\n  readonly searchBar: Locator;\n  readonly notificationIcon: Locator;\n  readonly userProfileDropdown: Locator;\n\n  // Sidebar Locators\n  readonly sidebar: Locator;\n  readonly homeLink: Locator;\n  readonly projectsLink: Locator;\n  readonly settingsLink: Locator;\n  readonly logoutButton: Locator;\n\n  // Main Content Locators\n  readonly mainContent: Locator;\n  readonly dashboardTitle: Locator;\n  readonly statsCards: Locator;\n\n  // Profile Dropdown Locators\n  readonly profileMenu: Locator;\n  readonly profileLink: Locator;\n  readonly accountSettingsLink: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n\n    // Header\n    this.header = page.locator('[data-testid=\"dashboard-header\"]');\n    this.logo = page.locator('[data-testid=\"logo\"]');\n    this.searchBar = page.locator('[data-testid=\"search-bar\"]');\n    this.notificationIcon = page.locator('[data-testid=\"notification-icon\"]');\n    this.userProfileDropdown = page.locator(\n      '[data-testid=\"user-profile-dropdown\"]',\n    );\n\n    // Sidebar\n    this.sidebar = page.locator('[data-testid=\"sidebar\"]');\n    this.homeLink = page.locator('[data-testid=\"nav-home\"]');\n    this.projectsLink = page.locator('[data-testid=\"nav-projects\"]');\n    this.settingsLink = page.locator('[data-testid=\"nav-settings\"]');\n    this.logoutButton = page.locator('[data-testid=\"logout-button\"]');\n\n    // Main Content\n    this.mainContent = page.locator('[data-testid=\"main-content\"]');\n    this.dashboardTitle = page.locator('[data-testid=\"dashboard-title\"]');\n    this.statsCards = page.locator('[data-testid=\"stat-card\"]');\n\n    // Profile Dropdown\n    this.profileMenu = page.locator('[data-testid=\"profile-menu\"]');\n    this.profileLink = page.locator('[data-testid=\"profile-link\"]');\n    this.accountSettingsLink = page.locator(\n      '[data-testid=\"account-settings-link\"]',\n    );\n  }\n\n  async goto(): Promise<void> {\n    await this.page.goto(\"/dashboard\");\n    await this.page.waitForLoadState(\"domcontentloaded\");\n  }\n\n  /**\n   * Navigate using sidebar\n   */\n  async navigateToHome(): Promise<void> {\n    await this.homeLink.click();\n  }\n\n  async navigateToProjects(): Promise<void> {\n    await this.projectsLink.click();\n  }\n\n  async navigateToSettings(): Promise<void> {\n    await this.settingsLink.click();\n  }\n\n  /**\n   * Search functionality\n   */\n  async search(query: string): Promise<void> {\n    await this.searchBar.fill(query);\n    await this.page.keyboard.press(\"Enter\");\n  }\n\n  /**\n   * Profile dropdown actions\n   */\n  async openProfileDropdown(): Promise<void> {\n    await this.userProfileDropdown.click();\n    await this.profileMenu.waitFor({ state: \"visible\" });\n  }\n\n  async navigateToProfile(): Promise<void> {\n    await this.openProfileDropdown();\n    await this.profileLink.click();\n  }\n\n  async navigateToAccountSettings(): Promise<void> {\n    await this.openProfileDropdown();\n    await this.accountSettingsLink.click();\n  }\n\n  async logout(): Promise<void> {\n    await this.logoutButton.click();\n  }\n\n  /**\n   * Get stats count\n   */\n  async getStatsCount(): Promise<number> {\n    return await this.statsCards.count();\n  }\n\n  // Getters for assertions\n  getHeader(): Locator {\n    return this.header;\n  }\n\n  getSidebar(): Locator {\n    return this.sidebar;\n  }\n\n  getMainContent(): Locator {\n    return this.mainContent;\n  }\n\n  getDashboardTitle(): Locator {\n    return this.dashboardTitle;\n  }\n}\n```\n\n## Best Practices\n\n### Page Object Design\n\n1. **Single Responsibility**: Each POM represents one page or component\n2. **No Assertions**: POMs should not contain test assertions (use getters instead)\n3. **Encapsulation**: Hide implementation details, expose high-level actions\n4. **Reusability**: Design methods to be reused across multiple tests\n5. **Clear Naming**: Use descriptive names for classes, properties, and methods\n\n### Locator Management\n\n1. **data-testid Only**: All locators must use data-testid attribute\n2. **Readonly**: Declare all locators as readonly\n3. **Initialize in Constructor**: All locators defined in constructor\n4. **Descriptive Names**: Use meaningful names that describe the element\n5. **Group Related**: Group related locators together (e.g., all form fields)\n\n### Method Design\n\n1. **Async Methods**: All action methods should be async\n2. **Return Types**: Action methods return Promise<void>, getters return data\n3. **Parameters**: Use TypeScript types for all parameters\n4. **Documentation**: Add JSDoc comments for complex methods\n5. **Atomic Actions**: Methods should perform single, focused actions\n\n### Organization\n\n1. **File Location**: Store POMs in `page-objects/` or `pages/` directory\n2. **One Class Per File**: Each POM in its own file\n3. **Export Class**: Export the class as default or named export\n4. **Index File**: Consider creating index.ts for easier imports\n5. **Naming Convention**: Use PascalCase with \"Page\" suffix\n\n## Common Issues and Solutions\n\n### Issue 1: Too Many Locators\n\n**Problem:** Page Object has 30+ locators making it hard to maintain\n\n**Solutions:**\n\n- Break down into smaller component-based POMs\n- Group related elements into sub-objects\n- Consider component composition pattern\n- Focus on elements actually used in tests\n- Create separate POMs for complex sections\n\n### Issue 2: Tests Still Break When UI Changes\n\n**Problem:** Tests fail despite using POMs\n\n**Solutions:**\n\n- Ensure ONLY data-testid locators are used (not CSS/XPath)\n- Coordinate with developers to keep data-testid stable\n- Use semantic testid names that reflect purpose, not implementation\n- Document all required data-testid values for developers\n- Update POM centrally when testid changes\n\n### Issue 3: Duplicate Code Across POMs\n\n**Problem:** Same logic repeated in multiple Page Objects\n\n**Solutions:**\n\n- Extract common actions to utility functions\n- Create base Page class with shared methods\n- Use composition over inheritance when possible\n- Create reusable components for common UI elements\n- Consider creating a ComponentPage for shared components\n\n### Issue 4: Methods Too Complex\n\n**Problem:** Action methods contain complex logic and are hard to test\n\n**Solutions:**\n\n- Break down into smaller, atomic methods\n- Extract complex logic to private helper methods\n- Keep public methods simple and focused\n- Use composition of smaller actions\n- Add clear comments for multi-step workflows\n\n### Issue 5: Hard to Test Page Objects\n\n**Problem:** Can't verify Page Object behavior without full tests\n\n**Solutions:**\n\n- Keep POMs simple (locators + actions only)\n- Avoid business logic in POMs\n- Use type-safe interfaces\n- Create example usage in comments\n- Focus on thin wrappers over Playwright API\n\n## Resources\n\nThe `resources/` directory contains templates for common patterns:\n\n- `page-template.ts` - Basic Page Object structure\n- `component-template.ts` - Component-based Page Object\n- `base-page.ts` - Base class with common functionality\n",
        "plugins/testing/playwright/skills/test-debugger/SKILL.md": "---\nname: playwright-test-debugger\ndescription: Debug failing Playwright E2E tests by analyzing error messages, stack traces, screenshots, and Playwright traces. Provides actionable solutions for common test failures including timeouts, selector issues, race conditions, and unexpected behaviors. Optionally uses Playwright MCP for live debugging.\n---\n\n## When to Use This Skill\n\nUse this skill when you need to:\n\n- Fix failing or flaky Playwright tests\n- Understand why a test is timing out\n- Debug element selector issues\n- Analyze test traces and screenshots\n- Resolve race conditions\n- Investigate unexpected test behavior\n- Use Playwright MCP to inspect live browser state\n\nDo NOT use this skill when:\n\n- Creating new tests (use test-generator skill)\n- Building Page Objects (use page-object-builder skill)\n- Refactoring test code (use test-maintainer skill)\n\n## Prerequisites\n\nBefore using this skill:\n\n1. Failing test file or error message\n2. Test execution output or logs\n3. Optional: Screenshots from test failure\n4. Optional: Playwright trace file\n5. Optional: Playwright MCP access for live debugging\n\n## Instructions\n\n### Step 1: Gather Failure Information\n\nAsk the user for:\n\n- **Error message** and stack trace\n- **Test file** location and test name\n- **Expected vs actual** behavior\n- **Screenshots** (if available)\n- **Trace file** path (if available)\n- **Frequency**: Does it fail always or intermittently (flaky)?\n- **Environment**: Local, CI, specific browser?\n\n### Step 2: Analyze the Error\n\nIdentify the error type:\n\n**Timeout Errors:**\n\n- `Timeout 30000ms exceeded`\n- `waiting for selector`\n- `waiting for navigation`\n\n**Selector Errors:**\n\n- `Element not found`\n- `strict mode violation`\n- `No node found`\n\n**Assertion Errors:**\n\n- `Expected ... but received ...`\n- `toBe`, `toContain`, `toBeVisible` failures\n\n**Navigation Errors:**\n\n- `Target closed`\n- `Navigation failed`\n- `ERR_CONNECTION_REFUSED`\n\n**Race Conditions:**\n\n- Intermittent failures\n- Works locally but fails in CI\n- Different results on different runs\n\n### Step 3: Use Playwright MCP (Optional)\n\nIf Playwright MCP is available and needed:\n\n- Use MCP tools to inspect browser state\n- Navigate to the problematic page\n- Check element visibility and attributes\n- Verify data-testid values exist\n- Test locator strategies\n- Capture screenshots\n\n### Step 4: Identify Root Cause\n\nCommon root causes:\n\n**1. Missing or Wrong data-testid:**\n\n- Element has different testid than expected\n- testid doesn't exist in HTML\n- Multiple elements with same testid\n\n**2. Timing Issues:**\n\n- Element not yet loaded when accessed\n- No explicit wait before interaction\n- Network requests still pending\n- Animations or transitions in progress\n\n**3. Element State:**\n\n- Element exists but not visible\n- Element disabled or not clickable\n- Element covered by another element\n- Element in different frame/iframe\n\n**4. Test Isolation:**\n\n- Tests depend on each other\n- Shared state between tests\n- Cleanup not performed\n- Browser context pollution\n\n**5. Environment Differences:**\n\n- Different viewport sizes\n- Different network speeds\n- CI vs local differences\n- Browser-specific issues\n\n### Step 5: Provide Solution\n\nFor each root cause, provide:\n\n1. **Explanation**: What's wrong\n2. **Fix**: Code changes needed\n3. **Prevention**: How to avoid in future\n4. **Verification**: How to confirm it's fixed\n\n### Step 6: Apply the Fix\n\n**For Selector Issues:**\n\n```typescript\n// ❌ Before\nawait page.locator('[data-testid=\"wrong-id\"]').click();\n\n// ✅ After\nawait page.locator('[data-testid=\"correct-id\"]').click();\n```\n\n**For Timeout Issues:**\n\n```typescript\n// ❌ Before\nawait page.locator('[data-testid=\"submit\"]').click();\n\n// ✅ After\nawait page.locator('[data-testid=\"submit\"]').waitFor({ state: \"visible\" });\nawait page.locator('[data-testid=\"submit\"]').click();\n```\n\n**For Race Conditions:**\n\n```typescript\n// ❌ Before\nawait page.locator('[data-testid=\"submit\"]').click();\nawait expect(page.locator('[data-testid=\"result\"]')).toBeVisible();\n\n// ✅ After\nawait page.locator('[data-testid=\"submit\"]').click();\nawait page.waitForLoadState(\"networkidle\");\nawait expect(page.locator('[data-testid=\"result\"]')).toBeVisible();\n```\n\n### Step 7: Verify the Fix\n\nGuide the user to:\n\n1. Run the test locally multiple times (3-5 times)\n2. Check if error is resolved\n3. Verify test passes consistently\n4. Run related tests to ensure no regression\n5. Consider running in CI if flakiness was CI-specific\n\n## Examples\n\n### Example 1: Timeout Error\n\n**Input:**\n\n```\nTest failed with error:\nTimeoutError: Timeout 30000ms exceeded.\n=========================== logs ===========================\nwaiting for locator('[data-testid=\"submit-button\"]')\n```\n\n**Analysis:**\n\n- Timeout error waiting for element\n- Element may not be loading\n- Selector may be incorrect\n\n**Solution:**\n\n```typescript\n// Check if the data-testid is correct in the HTML\n// Add explicit wait with better error message\nawait page.locator('[data-testid=\"submit-button\"]').waitFor({\n  state: \"visible\",\n  timeout: 30000,\n});\n\n// If still failing, verify element exists in DOM\nconst exists = await page.locator('[data-testid=\"submit-button\"]').count();\nconsole.log(`Submit button count: ${exists}`); // Should be 1\n\n// Check if page has loaded\nawait page.waitForLoadState(\"domcontentloaded\");\n\n// Final solution\nawait page.waitForLoadState(\"domcontentloaded\");\nawait page\n  .locator('[data-testid=\"submit-button\"]')\n  .waitFor({ state: \"visible\" });\nawait page.locator('[data-testid=\"submit-button\"]').click();\n```\n\n**Prevention:**\n\n- Always add explicit waits before interactions\n- Verify data-testid values in HTML\n- Use `waitForLoadState` after navigation\n\n### Example 2: Element Not Found\n\n**Input:**\n\n```\nError: Element not found\nlocator.click: Target closed\n  locator('[data-testid=\"user-menu\"]')\n```\n\n**Analysis:**\n\n- Element may not exist in current page state\n- Possible strict mode violation (multiple elements)\n- Element may be in a different frame\n\n**Solution:**\n\n```typescript\n// Step 1: Verify element exists\nconst count = await page.locator('[data-testid=\"user-menu\"]').count();\nconsole.log(`Found ${count} elements`);\n\n// If count = 0: Element doesn't exist, check data-testid in HTML\n// If count > 1: Multiple elements, need to be more specific\n\n// Step 2: If multiple elements, use .first() or filter\nawait page.locator('[data-testid=\"user-menu\"]').first().click();\n\n// Step 3: If in iframe, switch to frame first\nconst frame = page.frameLocator('[data-testid=\"app-frame\"]');\nawait frame.locator('[data-testid=\"user-menu\"]').click();\n\n// Step 4: Add proper wait\nawait page.locator('[data-testid=\"user-menu\"]').waitFor({ state: \"attached\" });\nawait page.locator('[data-testid=\"user-menu\"]').click();\n```\n\n**Prevention:**\n\n- Ensure data-testid values are unique on the page\n- Check for elements in frames/iframes\n- Add waits before interaction\n\n### Example 3: Flaky Test (Passes Sometimes)\n\n**Input:**\n\n```\nTest fails intermittently:\n- Passes 70% of the time locally\n- Fails 90% of the time in CI\nError: expect(received).toContainText(expected)\nExpected substring: \"Success\"\nReceived string: \"\"\n```\n\n**Analysis:**\n\n- Classic race condition\n- Element loads but content not yet populated\n- Likely caused by async data fetching\n- CI is slower so more likely to fail\n\n**Solution:**\n\n```typescript\n// ❌ Before: No wait for content\nawait page.locator('[data-testid=\"submit\"]').click();\nawait expect(page.locator('[data-testid=\"message\"]')).toContainText(\"Success\");\n\n// ✅ After: Wait for specific condition\nawait page.locator('[data-testid=\"submit\"]').click();\n\n// Option 1: Wait for network to settle\nawait page.waitForLoadState(\"networkidle\");\nawait expect(page.locator('[data-testid=\"message\"]')).toContainText(\"Success\");\n\n// Option 2: Wait for specific API call\nawait Promise.all([\n  page.waitForResponse(\"**/api/submit\"),\n  page.locator('[data-testid=\"submit\"]').click(),\n]);\nawait expect(page.locator('[data-testid=\"message\"]')).toContainText(\"Success\");\n\n// Option 3: Use Playwright's auto-waiting in assertion\nawait page.locator('[data-testid=\"submit\"]').click();\nawait expect(page.locator('[data-testid=\"message\"]')).toContainText(\"Success\", {\n  timeout: 10000, // Explicit timeout for slow operations\n});\n```\n\n**Prevention:**\n\n- Wait for network requests to complete\n- Use explicit timeouts for slow operations\n- Run tests multiple times to catch flakiness\n- Enable retries in playwright.config.ts\n\n### Example 4: Assertion Failure\n\n**Input:**\n\n```\nError: expect(received).toBeVisible()\n  locator('[data-testid=\"success-message\"]')\n  Expected: visible\n  Received: hidden\n```\n\n**Analysis:**\n\n- Element exists but is hidden\n- May need to wait for element to appear\n- Check if element has conditional visibility\n- Verify test logic is correct\n\n**Solution:**\n\n```typescript\n// Step 1: Verify element exists\nconst exists = await page.locator('[data-testid=\"success-message\"]').count();\nconsole.log(`Element count: ${exists}`);\n\n// Step 2: Check element state\nconst isVisible = await page\n  .locator('[data-testid=\"success-message\"]')\n  .isVisible();\nconsole.log(`Is visible: ${isVisible}`);\n\n// Step 3: Wait for visibility with timeout\nawait page.locator('[data-testid=\"success-message\"]').waitFor({\n  state: \"visible\",\n  timeout: 10000,\n});\n\n// Step 4: If still not visible, check CSS\nconst display = await page\n  .locator('[data-testid=\"success-message\"]')\n  .evaluate((el) => window.getComputedStyle(el).display);\nconsole.log(`Display property: ${display}`);\n\n// Step 5: Final solution\nawait page.locator('[data-testid=\"submit\"]').click();\nawait page.waitForLoadState(\"networkidle\");\nawait expect(page.locator('[data-testid=\"success-message\"]')).toBeVisible({\n  timeout: 10000,\n});\n```\n\n**Prevention:**\n\n- Add explicit waits for elements that appear after actions\n- Verify success conditions in the application logic\n- Use appropriate timeout values\n\n### Example 5: Using Playwright MCP for Debugging\n\n**Input:**\n\"My test is failing but I can't figure out why. The error says element not found but I see it in the screenshot.\"\n\n**Solution (Using MCP):**\n\n```\n1. Use Playwright MCP to navigate to the page:\n   - Navigate to the page where test fails\n   - Take screenshot to verify page state\n\n2. Use MCP to check if element exists:\n   - Use MCP to find elements by data-testid\n   - Check how many elements match\n   - Inspect element attributes\n\n3. Use MCP to test the locator:\n   - Try different locator strategies\n   - Check element visibility\n   - Verify element is in correct frame\n\n4. Based on MCP findings, update the test:\n   - If element has different testid: Update locator\n   - If element in iframe: Add frame handling\n   - If multiple matches: Make locator more specific\n```\n\n## Best Practices\n\n### Debugging Process\n\n1. **Read error carefully**: Error messages are usually accurate\n2. **Check test in isolation**: Run the single failing test\n3. **Use debugging tools**: Screenshots, traces, MCP\n4. **Add console logs**: Temporary logs to understand state\n5. **Verify assumptions**: Check that data-testid values are correct\n6. **Test incrementally**: Fix one issue at a time\n\n### Common Debugging Techniques\n\n1. **Add explicit waits**: Most failures are timing-related\n2. **Check element count**: Verify unique selectors\n3. **Use page.pause()**: Interactive debugging mode\n4. **Enable headed mode**: See what's happening visually\n5. **Slow motion**: Add `slowMo` in config to slow down actions\n6. **Check traces**: Use Playwright trace viewer\n\n### Preventing Future Issues\n\n1. **Always use data-testid**: Stable locators\n2. **Add explicit waits**: Don't rely on auto-waiting alone\n3. **Test isolation**: Each test should be independent\n4. **Proper cleanup**: Reset state between tests\n5. **Handle async**: Wait for network/animations\n6. **Run multiple times**: Catch flaky tests early\n\n## Common Issues and Solutions\n\n### Issue 1: Test Passes Locally but Fails in CI\n\n**Problem:** Test works on developer machine but fails in CI environment\n\n**Solutions:**\n\n- **Viewport difference**: CI may use different screen size\n\n  ```typescript\n  await page.setViewportSize({ width: 1920, height: 1080 });\n  ```\n\n- **Slower CI**: Increase timeouts for CI\n\n  ```typescript\n  timeout: process.env.CI ? 60000 : 30000;\n  ```\n\n- **Headless issues**: Test in headless mode locally\n\n  ```bash\n  npx playwright test --headed=false\n  ```\n\n- **Network speed**: Add retries in config for CI\n\n### Issue 2: Cannot Find Element with Correct data-testid\n\n**Problem:** Selector looks correct but element not found\n\n**Solutions:**\n\n- Check element is in main page, not iframe\n- Verify element is not dynamically loaded later\n- Check for typos in data-testid value\n- Use Playwright MCP to inspect actual HTML\n- Add wait for element to be added to DOM\n\n  ```typescript\n  await page.waitForSelector('[data-testid=\"element\"]');\n  ```\n\n### Issue 3: Test Works First Time but Fails on Reruns\n\n**Problem:** First run passes, subsequent runs fail\n\n**Solutions:**\n\n- **State leaking**: Tests aren't isolated\n  - Use `test.beforeEach` to reset state\n  - Use fixtures for clean context\n- **Storage persistence**: Clear local storage/cookies\n\n  ```typescript\n  await page.context().clearCookies();\n  await page.evaluate(() => localStorage.clear());\n  ```\n\n- **Database state**: Reset test database between runs\n\n### Issue 4: Element Found but Click Doesn't Work\n\n**Problem:** `element.click()` doesn't do anything or throws error\n\n**Solutions:**\n\n- **Element covered**: Another element is covering it\n\n  ```typescript\n  await page.locator('[data-testid=\"modal-close\"]').click({ force: true });\n  ```\n\n- **Element disabled**: Check if element is enabled\n\n  ```typescript\n  await expect(page.locator('[data-testid=\"submit\"]')).toBeEnabled();\n  ```\n\n- **Wrong element**: Multiple elements match, clicking wrong one\n\n  ```typescript\n  await page.locator('[data-testid=\"item\"]').first().click();\n  ```\n\n- **Animation in progress**: Wait for animations to complete\n\n  ```typescript\n  await page.waitForTimeout(500); // Avoid this\n  // Better: Wait for element to be stable\n  await page.locator('[data-testid=\"element\"]').waitFor({ state: \"visible\" });\n  await page.waitForLoadState(\"networkidle\");\n  ```\n\n### Issue 5: Assertion Timing Out\n\n**Problem:** `expect()` assertion times out after 5 seconds\n\n**Solutions:**\n\n- **Increase timeout**: For slow operations\n\n  ```typescript\n  await expect(locator).toBeVisible({ timeout: 15000 });\n  ```\n\n- **Wait for condition**: Add wait before assertion\n\n  ```typescript\n  await page.waitForLoadState(\"networkidle\");\n  await expect(locator).toBeVisible();\n  ```\n\n- **Wrong expectation**: Verify what you're asserting is correct\n  - Check expected text/value in application\n  - Verify element actually appears on success\n\n## Resources\n\nThe `resources/` directory contains helpful references:\n\n- `debugging-checklist.md` - Step-by-step debugging guide\n- `common-errors.md` - List of common errors and quick fixes\n- `playwright-commands.md` - Useful Playwright debugging commands\n",
        "plugins/testing/playwright/skills/test-debugger/resources/common-errors.md": "# Common Playwright Errors and Quick Fixes\n\n## Timeout Errors\n\n### Error: \"Timeout 30000ms exceeded waiting for selector\"\n\n**Cause:** Element not found within timeout period\n\n**Quick Fixes:**\n```typescript\n// 1. Add explicit wait\nawait page.waitForSelector('[data-testid=\"element\"]', { state: 'visible' });\n\n// 2. Verify data-testid is correct\nconst count = await page.locator('[data-testid=\"element\"]').count();\nconsole.log('Found', count, 'elements');\n\n// 3. Wait for page to load first\nawait page.waitForLoadState('domcontentloaded');\n\n// 4. Increase timeout if legitimately slow\nawait page.locator('[data-testid=\"element\"]').waitFor({\n  state: 'visible',\n  timeout: 60000\n});\n```\n\n### Error: \"Timeout 30000ms exceeded waiting for navigation\"\n\n**Cause:** Page navigation taking too long or not happening\n\n**Quick Fixes:**\n```typescript\n// 1. Wait for specific URL\nawait page.waitForURL('/expected-path', { timeout: 45000 });\n\n// 2. Wait for load state\nawait page.waitForLoadState('networkidle');\n\n// 3. Check if navigation actually occurs\nconsole.log('Current URL:', page.url());\n```\n\n## Selector Errors\n\n### Error: \"strict mode violation: locator resolved to X elements\"\n\n**Cause:** Multiple elements match the selector\n\n**Quick Fixes:**\n```typescript\n// 1. Use .first() or .last()\nawait page.locator('[data-testid=\"item\"]').first().click();\n\n// 2. Use .nth() for specific element\nawait page.locator('[data-testid=\"item\"]').nth(2).click();\n\n// 3. Make selector more specific (avoid if possible)\nawait page.locator('[data-testid=\"item\"][aria-selected=\"true\"]').click();\n\n// 4. Filter locators\nawait page.locator('[data-testid=\"item\"]').filter({ hasText: 'Active' }).click();\n```\n\n### Error: \"Element not found\"\n\n**Cause:** Element doesn't exist or wrong selector\n\n**Quick Fixes:**\n```typescript\n// 1. Verify element exists\nconst exists = await page.locator('[data-testid=\"element\"]').count() > 0;\nconsole.log('Element exists:', exists);\n\n// 2. Check for typos in data-testid\n// Verify in HTML: <button data-testid=\"correct-id\">\n\n// 3. Wait for element to be added to DOM\nawait page.locator('[data-testid=\"element\"]').waitFor({ state: 'attached' });\n\n// 4. Check if in iframe\nconst frame = page.frameLocator('[data-testid=\"app-frame\"]');\nawait frame.locator('[data-testid=\"element\"]').click();\n```\n\n## Assertion Errors\n\n### Error: \"expect(received).toBeVisible() - Expected visible but received hidden\"\n\n**Cause:** Element exists but is not visible\n\n**Quick Fixes:**\n```typescript\n// 1. Wait for element to become visible\nawait page.locator('[data-testid=\"element\"]').waitFor({ state: 'visible' });\nawait expect(page.locator('[data-testid=\"element\"]')).toBeVisible();\n\n// 2. Check visibility with timeout\nawait expect(page.locator('[data-testid=\"element\"]')).toBeVisible({\n  timeout: 10000\n});\n\n// 3. Debug visibility\nconst isVisible = await page.locator('[data-testid=\"element\"]').isVisible();\nconsole.log('Is visible:', isVisible);\n```\n\n### Error: \"expect(received).toContainText() - Expected substring not found\"\n\n**Cause:** Element doesn't contain expected text or not loaded yet\n\n**Quick Fixes:**\n```typescript\n// 1. Wait for text to appear\nawait expect(page.locator('[data-testid=\"element\"]')).toContainText('Expected', {\n  timeout: 10000\n});\n\n// 2. Wait for network before checking\nawait page.waitForLoadState('networkidle');\nawait expect(page.locator('[data-testid=\"element\"]')).toContainText('Expected');\n\n// 3. Check actual text content\nconst text = await page.locator('[data-testid=\"element\"]').textContent();\nconsole.log('Actual text:', text);\n```\n\n## Click Errors\n\n### Error: \"locator.click: Target closed\"\n\n**Cause:** Element or page disappeared before click completed\n\n**Quick Fixes:**\n```typescript\n// 1. Wait for element to be stable\nawait page.locator('[data-testid=\"element\"]').waitFor({ state: 'visible' });\nawait page.waitForTimeout(100); // Allow animations to settle\nawait page.locator('[data-testid=\"element\"]').click();\n\n// 2. Use force click if element is covered\nawait page.locator('[data-testid=\"element\"]').click({ force: true });\n\n// 3. Check if element is being removed\nconst count = await page.locator('[data-testid=\"element\"]').count();\nconsole.log('Element count before click:', count);\n```\n\n### Error: \"Element is not clickable\"\n\n**Cause:** Element is disabled, covered, or not in viewport\n\n**Quick Fixes:**\n```typescript\n// 1. Check if element is enabled\nawait expect(page.locator('[data-testid=\"button\"]')).toBeEnabled();\nawait page.locator('[data-testid=\"button\"]').click();\n\n// 2. Scroll into view\nawait page.locator('[data-testid=\"element\"]').scrollIntoViewIfNeeded();\nawait page.locator('[data-testid=\"element\"]').click();\n\n// 3. Wait for element to be clickable\nawait page.locator('[data-testid=\"element\"]').waitFor({ state: 'visible' });\nawait expect(page.locator('[data-testid=\"element\"]')).toBeEnabled();\nawait page.locator('[data-testid=\"element\"]').click();\n```\n\n## Network Errors\n\n### Error: \"net::ERR_CONNECTION_REFUSED\"\n\n**Cause:** Server is not running or wrong URL\n\n**Quick Fixes:**\n```typescript\n// 1. Verify server is running\n// Check if dev server is started: npm run dev\n\n// 2. Check baseURL in playwright.config.ts\nuse: {\n  baseURL: 'http://localhost:3000', // Correct port?\n}\n\n// 3. Use full URL if baseURL not set\nawait page.goto('http://localhost:3000/path');\n```\n\n### Error: \"Navigation failed because page was closed\"\n\n**Cause:** Page closed prematurely during navigation\n\n**Quick Fixes:**\n```typescript\n// 1. Don't close page too early\n// Remove premature page.close() calls\n\n// 2. Wait for navigation to complete\nawait page.goto('/path');\nawait page.waitForLoadState('domcontentloaded');\n\n// 3. Check for popup blockers or redirects\n```\n\n## Fill/Type Errors\n\n### Error: \"Cannot type into a non-editable element\"\n\n**Cause:** Trying to fill a non-input element\n\n**Quick Fixes:**\n```typescript\n// 1. Verify element is an input/textarea\nconst tagName = await page.locator('[data-testid=\"element\"]').evaluate(\n  el => el.tagName\n);\nconsole.log('Tag name:', tagName); // Should be INPUT or TEXTAREA\n\n// 2. Check if element is contenteditable\nconst isEditable = await page.locator('[data-testid=\"element\"]').evaluate(\n  el => el.contentEditable\n);\n\n// 3. Use correct element selector\n// Ensure data-testid is on the input, not its container\n```\n\n### Error: \"Element is disabled\"\n\n**Cause:** Trying to interact with disabled element\n\n**Quick Fixes:**\n```typescript\n// 1. Wait for element to be enabled\nawait expect(page.locator('[data-testid=\"input\"]')).toBeEnabled();\nawait page.locator('[data-testid=\"input\"]').fill('value');\n\n// 2. Check why element is disabled\nconst isDisabled = await page.locator('[data-testid=\"input\"]').isDisabled();\nconsole.log('Is disabled:', isDisabled);\n\n// 3. Ensure prerequisites are met (e.g., terms accepted)\nawait page.locator('[data-testid=\"terms-checkbox\"]').check();\nawait page.locator('[data-testid=\"submit\"]').click();\n```\n\n## Frame/Iframe Errors\n\n### Error: \"Frame was detached\"\n\n**Cause:** Interacting with iframe that was removed\n\n**Quick Fixes:**\n```typescript\n// 1. Re-acquire frame reference\nconst frame = page.frameLocator('[data-testid=\"app-frame\"]');\nawait frame.locator('[data-testid=\"element\"]').click();\n\n// 2. Wait for frame to be ready\nawait page.frameLocator('[data-testid=\"app-frame\"]').locator('body').waitFor();\n\n// 3. Check if frame exists\nconst frameCount = await page.frames().length;\nconsole.log('Frame count:', frameCount);\n```\n\n## Race Condition Errors\n\n### Error: Test passes sometimes, fails other times\n\n**Cause:** Race condition / flaky test\n\n**Quick Fixes:**\n```typescript\n// 1. Wait for network to settle\nawait page.waitForLoadState('networkidle');\n\n// 2. Wait for specific API calls\nawait page.waitForResponse('**/api/data');\n\n// 3. Add explicit waits\nawait page.locator('[data-testid=\"element\"]').waitFor({ state: 'visible' });\n\n// 4. Increase timeouts\nawait expect(page.locator('[data-testid=\"result\"]')).toBeVisible({\n  timeout: 15000\n});\n\n// 5. Enable retries in playwright.config.ts\nretries: 2,\n```\n\n## Context/State Errors\n\n### Error: \"localStorage is not defined\"\n\n**Cause:** Accessing localStorage before page is loaded\n\n**Quick Fixes:**\n```typescript\n// 1. Navigate to page first\nawait page.goto('/');\nawait page.evaluate(() => localStorage.setItem('key', 'value'));\n\n// 2. Use context.addInitScript for early setup\nawait context.addInitScript(() => {\n  localStorage.setItem('key', 'value');\n});\n```\n\n### Error: \"Test passes in isolation but fails in suite\"\n\n**Cause:** Test pollution / shared state\n\n**Quick Fixes:**\n```typescript\n// 1. Clear state in beforeEach\ntest.beforeEach(async ({ page }) => {\n  await page.context().clearCookies();\n  await page.evaluate(() => {\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n});\n\n// 2. Use test.describe.serial for dependent tests\ntest.describe.serial('Login flow', () => {\n  // Tests run in order\n});\n\n// 3. Create fresh context for each test\ntest.use({ storageState: undefined });\n```\n\n## Configuration Errors\n\n### Error: \"Cannot find module '@playwright/test'\"\n\n**Cause:** Playwright not installed\n\n**Quick Fixes:**\n```bash\n# Install Playwright\nnpm install -D @playwright/test\n\n# Install browsers\nnpx playwright install\n```\n\n### Error: \"No tests found\"\n\n**Cause:** Test files not matching pattern\n\n**Quick Fixes:**\n```typescript\n// In playwright.config.ts\ntestDir: './tests',\ntestMatch: '**/*.spec.ts', // Or *.test.ts\n```\n\n## Debugging Commands\n\n```bash\n# Run with UI mode\nnpx playwright test --ui\n\n# Run in headed mode\nnpx playwright test --headed\n\n# Debug specific test\nnpx playwright test --debug test-file.spec.ts\n\n# Show trace\nnpx playwright show-trace trace.zip\n\n# Generate code\nnpx playwright codegen localhost:3000\n```\n",
        "plugins/testing/playwright/skills/test-debugger/resources/debugging-checklist.md": "# Playwright Test Debugging Checklist\n\n## Initial Assessment\n\n- [ ] Read the error message carefully\n- [ ] Note the failing test name and location\n- [ ] Check if test fails consistently or intermittently\n- [ ] Identify which browser(s) are failing\n- [ ] Check if failure is local only or also in CI\n\n## Error Type Identification\n\n### Timeout Errors\n- [ ] Check if element exists with correct data-testid\n- [ ] Verify page has loaded completely\n- [ ] Add explicit wait before interaction\n- [ ] Check if network requests are pending\n- [ ] Increase timeout if operation is legitimately slow\n\n### Selector Errors\n- [ ] Verify data-testid in HTML matches test code\n- [ ] Check if multiple elements have the same testid\n- [ ] Ensure element is not in an iframe\n- [ ] Confirm element is added to DOM (not removed)\n- [ ] Use Playwright Inspector to test selector\n\n### Assertion Errors\n- [ ] Verify expected value is correct\n- [ ] Check if element exists and is visible\n- [ ] Add wait before assertion\n- [ ] Check if content is populated asynchronously\n- [ ] Increase assertion timeout if needed\n\n### Navigation Errors\n- [ ] Check if URL is correct\n- [ ] Verify server is running\n- [ ] Check for network issues\n- [ ] Ensure proper wait after navigation\n- [ ] Look for redirects or authentication requirements\n\n## Element Investigation\n\n- [ ] Count elements matching selector (should be 1)\n  ```typescript\n  const count = await page.locator('[data-testid=\"element\"]').count();\n  console.log('Element count:', count);\n  ```\n\n- [ ] Check element visibility\n  ```typescript\n  const isVisible = await page.locator('[data-testid=\"element\"]').isVisible();\n  console.log('Is visible:', isVisible);\n  ```\n\n- [ ] Check element state\n  ```typescript\n  const isEnabled = await page.locator('[data-testid=\"element\"]').isEnabled();\n  console.log('Is enabled:', isEnabled);\n  ```\n\n- [ ] Get element attributes\n  ```typescript\n  const testId = await page.locator('[data-testid=\"element\"]').getAttribute('data-testid');\n  console.log('data-testid:', testId);\n  ```\n\n## Timing Investigation\n\n- [ ] Add waits before interactions\n  ```typescript\n  await page.locator('[data-testid=\"element\"]').waitFor({ state: 'visible' });\n  ```\n\n- [ ] Wait for page load\n  ```typescript\n  await page.waitForLoadState('domcontentloaded');\n  await page.waitForLoadState('networkidle');\n  ```\n\n- [ ] Wait for specific API calls\n  ```typescript\n  await page.waitForResponse('**/api/endpoint');\n  ```\n\n- [ ] Check if animations/transitions are in progress\n  ```typescript\n  await page.waitForTimeout(500); // Only for testing, remove later\n  ```\n\n## Interactive Debugging\n\n- [ ] Run test in headed mode\n  ```bash\n  npx playwright test --headed\n  ```\n\n- [ ] Use debug mode\n  ```bash\n  npx playwright test --debug\n  ```\n\n- [ ] Add `page.pause()` in test\n  ```typescript\n  await page.pause(); // Pauses execution for manual inspection\n  ```\n\n- [ ] Enable slow motion\n  ```typescript\n  // In playwright.config.ts\n  use: {\n    launchOptions: {\n      slowMo: 1000, // Slow down by 1 second\n    },\n  }\n  ```\n\n- [ ] Take screenshots for inspection\n  ```typescript\n  await page.screenshot({ path: 'debug-screenshot.png', fullPage: true });\n  ```\n\n## Trace Analysis\n\n- [ ] Enable trace recording\n  ```typescript\n  // In playwright.config.ts\n  use: {\n    trace: 'on-first-retry',\n  }\n  ```\n\n- [ ] Open trace viewer\n  ```bash\n  npx playwright show-trace trace.zip\n  ```\n\n- [ ] Check trace for:\n  - Network requests\n  - Console logs\n  - Screenshots at each step\n  - DOM snapshots\n  - Action timeline\n\n## Test Isolation Check\n\n- [ ] Run test in isolation (comment out other tests)\n- [ ] Check if test passes when run alone\n- [ ] Verify no shared state between tests\n- [ ] Ensure proper cleanup in `afterEach`\n- [ ] Check for global state mutations\n\n## Environment Differences\n\n### Local vs CI\n- [ ] Run test in headless mode locally\n  ```bash\n  npx playwright test --headed=false\n  ```\n\n- [ ] Check viewport size matches CI\n  ```typescript\n  await page.setViewportSize({ width: 1920, height: 1080 });\n  ```\n\n- [ ] Compare timeouts (CI may need longer)\n- [ ] Check if CI has different environment variables\n\n### Browser Differences\n- [ ] Test in all configured browsers\n  ```bash\n  npx playwright test --project=chromium\n  npx playwright test --project=firefox\n  npx playwright test --project=webkit\n  ```\n\n- [ ] Check for browser-specific issues\n- [ ] Verify CSS compatibility\n- [ ] Test JavaScript feature support\n\n## Common Quick Fixes\n\n### Fix #1: Add Explicit Wait\n```typescript\n// Before\nawait page.locator('[data-testid=\"element\"]').click();\n\n// After\nawait page.locator('[data-testid=\"element\"]').waitFor({ state: 'visible' });\nawait page.locator('[data-testid=\"element\"]').click();\n```\n\n### Fix #2: Wait for Network\n```typescript\n// Before\nawait page.locator('[data-testid=\"submit\"]').click();\nawait expect(page.locator('[data-testid=\"result\"]')).toBeVisible();\n\n// After\nawait page.locator('[data-testid=\"submit\"]').click();\nawait page.waitForLoadState('networkidle');\nawait expect(page.locator('[data-testid=\"result\"]')).toBeVisible();\n```\n\n### Fix #3: Handle Multiple Elements\n```typescript\n// Before\nawait page.locator('[data-testid=\"item\"]').click(); // Error if multiple\n\n// After\nawait page.locator('[data-testid=\"item\"]').first().click();\n```\n\n### Fix #4: Increase Timeout\n```typescript\n// Before\nawait expect(page.locator('[data-testid=\"slow-element\"]')).toBeVisible();\n\n// After\nawait expect(page.locator('[data-testid=\"slow-element\"]')).toBeVisible({\n  timeout: 15000\n});\n```\n\n### Fix #5: Check Element State\n```typescript\n// Before\nawait page.locator('[data-testid=\"button\"]').click();\n\n// After\nawait expect(page.locator('[data-testid=\"button\"]')).toBeEnabled();\nawait page.locator('[data-testid=\"button\"]').click();\n```\n\n## Verification\n\n- [ ] Run test 5+ times to verify consistency\n- [ ] Test in all browsers\n- [ ] Run full test suite to check for regressions\n- [ ] Test in CI environment\n- [ ] Document the fix for future reference\n\n## Prevention\n\n- [ ] Add explicit waits where needed\n- [ ] Use only data-testid locators\n- [ ] Ensure test isolation\n- [ ] Add retry logic in config\n- [ ] Review and refactor flaky tests regularly\n- [ ] Keep tests simple and focused\n- [ ] Maintain good test hygiene (cleanup, fixtures)\n",
        "plugins/testing/playwright/skills/test-debugger/resources/playwright-commands.md": "# Useful Playwright Debugging Commands\n\n## Running Tests\n\n```bash\n# Run all tests\nnpx playwright test\n\n# Run specific test file\nnpx playwright test login.spec.ts\n\n# Run tests matching pattern\nnpx playwright test --grep \"login\"\n\n# Run tests in specific browser\nnpx playwright test --project=chromium\nnpx playwright test --project=firefox\nnpx playwright test --project=webkit\n\n# Run tests in headed mode (see browser)\nnpx playwright test --headed\n\n# Run specific test by line number\nnpx playwright test login.spec.ts:42\n\n# Run tests in parallel\nnpx playwright test --workers=4\n\n# Run tests sequentially\nnpx playwright test --workers=1\n```\n\n## Debugging\n\n```bash\n# Debug mode (opens inspector)\nnpx playwright test --debug\n\n# Debug specific test\nnpx playwright test login.spec.ts --debug\n\n# UI Mode (interactive)\nnpx playwright test --ui\n\n# Step through tests\nnpx playwright test --debug --headed\n\n# Playwright Inspector\nPWDEBUG=1 npx playwright test\n```\n\n## Code Generation\n\n```bash\n# Generate test code by recording actions\nnpx playwright codegen\n\n# Generate code for specific URL\nnpx playwright codegen https://example.com\n\n# Generate with specific device\nnpx playwright codegen --device=\"iPhone 12\"\n\n# Generate with authentication\nnpx playwright codegen --save-storage=auth.json\n```\n\n## Trace Viewing\n\n```bash\n# Show trace file\nnpx playwright show-trace trace.zip\n\n# Open trace from test results\nnpx playwright show-trace test-results/login-test/trace.zip\n\n# View trace with network data\nnpx playwright show-trace trace.zip --network\n```\n\n## Report Viewing\n\n```bash\n# Open HTML report\nnpx playwright show-report\n\n# Open specific report\nnpx playwright show-report ./playwright-report\n```\n\n## Installation & Setup\n\n```bash\n# Install Playwright\nnpm init playwright@latest\n\n# Install Playwright Test\nnpm install -D @playwright/test\n\n# Install browsers\nnpx playwright install\n\n# Install specific browser\nnpx playwright install chromium\nnpx playwright install firefox\nnpx playwright install webkit\n\n# Install with dependencies (Linux)\nnpx playwright install --with-deps\n\n# Update Playwright\nnpm install -D @playwright/test@latest\nnpx playwright install\n```\n\n## Configuration\n\n```bash\n# Run with custom config\nnpx playwright test --config=custom.config.ts\n\n# List all projects\nnpx playwright test --list\n\n# Show configuration\nnpx playwright show-config\n```\n\n## Useful Test Options\n\n```bash\n# Run tests with retries\nnpx playwright test --retries=3\n\n# Set timeout\nnpx playwright test --timeout=60000\n\n# Run tests with maximum failures\nnpx playwright test --max-failures=5\n\n# Run only failed tests\nnpx playwright test --last-failed\n\n# Update snapshots\nnpx playwright test --update-snapshots\n\n# Ignore snapshots\nnpx playwright test --ignore-snapshots\n```\n\n## Environment Variables\n\n```bash\n# Enable debug logs\nDEBUG=pw:api npx playwright test\n\n# Enable verbose logging\nDEBUG=* npx playwright test\n\n# Set browser\nBROWSER=firefox npx playwright test\n\n# Set headed mode\nHEADED=1 npx playwright test\n\n# Disable parallel execution\nPWTEST_PARALLEL=0 npx playwright test\n```\n\n## In-Test Debugging Commands\n\n### Console Logging\n\n```typescript\n// Log to console\nconsole.log('Debug message:', value);\n\n// Log page URL\nconsole.log('Current URL:', page.url());\n\n// Log element count\nconst count = await page.locator('[data-testid=\"item\"]').count();\nconsole.log('Element count:', count);\n\n// Log element text\nconst text = await page.locator('[data-testid=\"element\"]').textContent();\nconsole.log('Element text:', text);\n\n// Log all text contents\nconst allText = await page.locator('[data-testid=\"item\"]').allTextContents();\nconsole.log('All texts:', allText);\n```\n\n### Page Pause\n\n```typescript\n// Pause test execution (opens inspector)\nawait page.pause();\n\n// Pause on specific condition\nif (someCondition) {\n  await page.pause();\n}\n```\n\n### Screenshots\n\n```typescript\n// Take screenshot\nawait page.screenshot({ path: 'screenshot.png' });\n\n// Full page screenshot\nawait page.screenshot({ path: 'screenshot.png', fullPage: true });\n\n// Element screenshot\nawait page.locator('[data-testid=\"element\"]').screenshot({ path: 'element.png' });\n\n// Screenshot with timestamp\nconst timestamp = Date.now();\nawait page.screenshot({ path: `debug-${timestamp}.png` });\n```\n\n### Video Recording\n\n```typescript\n// In playwright.config.ts\nuse: {\n  video: 'on', // or 'retain-on-failure'\n}\n\n// In test\nconst path = await page.video()?.path();\nconsole.log('Video saved at:', path);\n```\n\n### Trace Recording\n\n```typescript\n// Start tracing\nawait context.tracing.start({ screenshots: true, snapshots: true });\n\n// Stop tracing and save\nawait context.tracing.stop({ path: 'trace.zip' });\n\n// Or in playwright.config.ts\nuse: {\n  trace: 'on-first-retry', // or 'on' for all tests\n}\n```\n\n### Evaluate JavaScript\n\n```typescript\n// Execute JavaScript in page context\nconst result = await page.evaluate(() => {\n  return document.title;\n});\nconsole.log('Page title:', result);\n\n// With parameters\nconst result = await page.evaluate((text) => {\n  return document.body.textContent?.includes(text);\n}, 'search term');\n\n// Get element properties\nconst value = await page.locator('[data-testid=\"input\"]').evaluate(\n  (el: HTMLInputElement) => el.value\n);\n```\n\n### Wait Commands\n\n```typescript\n// Wait for timeout (avoid in production)\nawait page.waitForTimeout(1000);\n\n// Wait for selector\nawait page.waitForSelector('[data-testid=\"element\"]');\n\n// Wait for URL\nawait page.waitForURL('/dashboard');\nawait page.waitForURL(/\\/user\\/\\d+/);\n\n// Wait for load state\nawait page.waitForLoadState('load');\nawait page.waitForLoadState('domcontentloaded');\nawait page.waitForLoadState('networkidle');\n\n// Wait for response\nawait page.waitForResponse('**/api/data');\nawait page.waitForResponse(response =>\n  response.url().includes('/api/') && response.status() === 200\n);\n\n// Wait for request\nawait page.waitForRequest('**/api/users');\n\n// Wait for function\nawait page.waitForFunction(() => document.querySelectorAll('.item').length > 5);\n\n// Wait for event\nawait page.waitForEvent('response');\nawait page.waitForEvent('request');\n```\n\n### Network Debugging\n\n```typescript\n// Listen to all requests\npage.on('request', request =>\n  console.log('>>', request.method(), request.url())\n);\n\n// Listen to all responses\npage.on('response', response =>\n  console.log('<<', response.status(), response.url())\n);\n\n// Listen to console messages\npage.on('console', msg => console.log('PAGE LOG:', msg.text()));\n\n// Listen to page errors\npage.on('pageerror', error => console.log('PAGE ERROR:', error));\n\n// Intercept and log requests\nawait page.route('**/api/**', route => {\n  console.log('API Request:', route.request().url());\n  route.continue();\n});\n```\n\n### State Inspection\n\n```typescript\n// Get all cookies\nconst cookies = await context.cookies();\nconsole.log('Cookies:', cookies);\n\n// Get localStorage\nconst localStorage = await page.evaluate(() => {\n  return JSON.stringify(window.localStorage);\n});\nconsole.log('LocalStorage:', localStorage);\n\n// Get sessionStorage\nconst sessionStorage = await page.evaluate(() => {\n  return JSON.stringify(window.sessionStorage);\n});\nconsole.log('SessionStorage:', sessionStorage);\n\n// Get viewport size\nconst viewport = page.viewportSize();\nconsole.log('Viewport:', viewport);\n```\n\n### Element State Checks\n\n```typescript\n// Check visibility\nconst isVisible = await page.locator('[data-testid=\"element\"]').isVisible();\nconsole.log('Is visible:', isVisible);\n\n// Check if enabled\nconst isEnabled = await page.locator('[data-testid=\"button\"]').isEnabled();\nconsole.log('Is enabled:', isEnabled);\n\n// Check if checked\nconst isChecked = await page.locator('[data-testid=\"checkbox\"]').isChecked();\nconsole.log('Is checked:', isChecked);\n\n// Get bounding box\nconst box = await page.locator('[data-testid=\"element\"]').boundingBox();\nconsole.log('Bounding box:', box);\n\n// Get attribute\nconst value = await page.locator('[data-testid=\"input\"]').getAttribute('value');\nconsole.log('Value:', value);\n\n// Get inner text\nconst text = await page.locator('[data-testid=\"element\"]').innerText();\nconsole.log('Inner text:', text);\n\n// Get input value\nconst inputValue = await page.locator('[data-testid=\"input\"]').inputValue();\nconsole.log('Input value:', inputValue);\n```\n\n## Performance Testing\n\n```bash\n# Run with tracing\nnpx playwright test --trace=on\n\n# Run with video\nnpx playwright test --video=on\n\n# Slow down execution\nnpx playwright test --slow-mo=1000\n```\n\n## CI/CD Commands\n\n```bash\n# Run in CI mode\nCI=1 npx playwright test\n\n# Run with JUnit reporter\nnpx playwright test --reporter=junit\n\n# Run with multiple reporters\nnpx playwright test --reporter=html,json,junit\n\n# Run with sharding\nnpx playwright test --shard=1/3\nnpx playwright test --shard=2/3\nnpx playwright test --shard=3/3\n```\n\n## Test Filtering\n\n```bash\n# Run tests with specific tag\nnpx playwright test --grep @smoke\n\n# Skip tests with tag\nnpx playwright test --grep-invert @skip\n\n# Run tests in specific describe block\nnpx playwright test --grep \"Login tests\"\n\n# Run only tests marked with test.only\n# (Automatically done if test.only exists)\n```\n\n## Maintenance Commands\n\n```bash\n# Clean test output\nrm -rf test-results/\nrm -rf playwright-report/\n\n# List installed browsers\nnpx playwright --version\n\n# Check for browser updates\nnpx playwright install --dry-run\n\n# Uninstall browsers\nnpx playwright uninstall\n\n# Clear browser cache\nnpx playwright install --force\n```\n\n## Tips\n\n1. **Use `--headed` for visual debugging**\n   ```bash\n   npx playwright test --headed --project=chromium\n   ```\n\n2. **Use `--debug` to step through test**\n   ```bash\n   npx playwright test login.spec.ts --debug\n   ```\n\n3. **Use `--ui` for interactive mode**\n   ```bash\n   npx playwright test --ui\n   ```\n\n4. **Use `show-trace` to analyze failures**\n   ```bash\n   npx playwright show-trace trace.zip\n   ```\n\n5. **Use `codegen` to learn selectors**\n   ```bash\n   npx playwright codegen http://localhost:3000\n   ```\n",
        "plugins/testing/playwright/skills/test-generator/SKILL.md": "---\nname: playwright-test-generator\ndescription: Generate production-ready Playwright E2E tests from natural language specifications or requirements. Creates TypeScript test files following best practices including data-testid locators, proper async/await usage, test isolation, and the AAA (Arrange-Act-Assert) pattern.\n---\n\n## When to Use This Skill\n\nUse this skill when you need to:\n\n- Create new E2E tests from user stories or requirements\n- Generate test files for new features or pages\n- Convert manual test cases into automated tests\n- Scaffold a complete test suite for a new application\n- Create tests with proper fixtures and configuration\n\nDo NOT use this skill when:\n\n- You need to debug existing tests (use test-debugger skill)\n- You want to refactor or maintain existing tests (use test-maintainer skill)\n- You need to create Page Object Models (use page-object-builder skill)\n\n## Prerequisites\n\nBefore using this skill:\n\n1. Playwright should be installed in the project (`npm install -D @playwright/test`)\n2. Basic understanding of the application under test (URLs, main flows)\n3. Knowledge of what functionality needs to be tested\n4. Access to the application's UI or design documentation\n\n## Instructions\n\n### Step 1: Gather Test Requirements\n\nAsk the user for:\n\n- **Feature/functionality** to test\n- **User flow** or scenario description\n- **Expected outcomes** (what should happen)\n- **Test data** requirements (if any)\n- **Page URL(s)** involved in the test\n- **Data-testid values** (or offer to suggest them based on element purpose)\n\n### Step 2: Analyze and Plan\n\nReview the requirements and:\n\n- Break down the user flow into discrete steps\n- Identify all page elements that need interaction\n- Determine what assertions are needed\n- Plan the test structure (setup, actions, verifications)\n- Identify any fixtures or utilities needed\n\n### Step 3: Generate Test File\n\nCreate a TypeScript test file with:\n\n**File Structure:**\n\n```typescript\nimport { test, expect } from \"@playwright/test\";\n\ntest.describe(\"Feature Name\", () => {\n  test(\"should <specific behavior>\", async ({ page }) => {\n    // Arrange: Setup\n    // Act: Perform actions\n    // Assert: Verify results\n  });\n});\n```\n\n**Required Elements:**\n\n- Descriptive test names (what behavior is tested)\n- Proper async/await usage\n- data-testid locators ONLY\n- Explicit waits (waitForSelector, waitForLoadState)\n- Clear assertions with expect()\n- Comments for AAA sections\n- TypeScript types\n\n**Locator Strategy (MANDATORY):**\n\n```typescript\n// ✅ CORRECT: Always use data-testid\nawait page.locator('[data-testid=\"submit-button\"]').click();\nawait expect(page.locator('[data-testid=\"success-message\"]')).toBeVisible();\n\n// ❌ WRONG: Never use CSS selectors, XPath, or text selectors\nawait page.locator(\".submit-btn\").click(); // NO\nawait page.locator('//button[@type=\"submit\"]').click(); // NO\nawait page.getByRole(\"button\", { name: \"Submit\" }).click(); // NO\n```\n\n### Step 4: Add Configuration (if needed)\n\nIf this is the first test, generate `playwright.config.ts`:\n\n- Base URL configuration\n- Timeout settings (30s default)\n- Retry logic (2 retries for flaky tests)\n- Screenshot on failure\n- Trace on first retry\n- Parallel execution settings\n\n### Step 5: Include Fixtures (if needed)\n\nFor complex setups, create custom fixtures:\n\n```typescript\nimport { test as base } from \"@playwright/test\";\n\ntype MyFixtures = {\n  authenticatedPage: Page;\n};\n\nexport const test = base.extend<MyFixtures>({\n  authenticatedPage: async ({ page }, use) => {\n    // Setup: login\n    await page.goto(\"/login\");\n    await page.locator('[data-testid=\"username\"]').fill(\"testuser\");\n    await page.locator('[data-testid=\"password\"]').fill(\"password\");\n    await page.locator('[data-testid=\"login-button\"]').click();\n    await page.waitForURL(\"/dashboard\");\n\n    await use(page);\n\n    // Teardown (if needed)\n  },\n});\n```\n\n### Step 6: Validate Generated Test\n\nEnsure the test includes:\n\n- [ ] Descriptive test name\n- [ ] Proper test.describe grouping\n- [ ] Only data-testid locators\n- [ ] No hardcoded waits (no page.waitForTimeout())\n- [ ] Explicit waits for elements\n- [ ] Clear AAA structure\n- [ ] TypeScript types\n- [ ] Meaningful assertions\n- [ ] Comments for complex logic\n\n### Step 7: Provide Usage Instructions\n\nTell the user:\n\n- Where the test file was created\n- How to run the test: `npx playwright test <filename>`\n- How to run in debug mode: `npx playwright test --debug <filename>`\n- How to view traces: `npx playwright show-trace trace.zip`\n- What data-testid values need to be added to the UI (if suggesting new ones)\n\n## Examples\n\n### Example 1: Simple Login Test\n\n**Input:**\n\"Create a test for the login flow. User enters username and password, clicks login button, and should see the dashboard.\"\n\n**Output:**\n\n```typescript\nimport { test, expect } from \"@playwright/test\";\n\ntest.describe(\"Authentication\", () => {\n  test(\"should successfully login with valid credentials\", async ({ page }) => {\n    // Arrange: Navigate to login page\n    await page.goto(\"/login\");\n    await expect(page.locator('[data-testid=\"login-form\"]')).toBeVisible();\n\n    // Act: Enter credentials and submit\n    await page\n      .locator('[data-testid=\"username-input\"]')\n      .fill(\"testuser@example.com\");\n    await page.locator('[data-testid=\"password-input\"]').fill(\"SecurePass123\");\n    await page.locator('[data-testid=\"login-button\"]').click();\n\n    // Assert: Verify successful login\n    await page.waitForURL(\"/dashboard\");\n    await expect(\n      page.locator('[data-testid=\"dashboard-header\"]'),\n    ).toBeVisible();\n    await expect(page.locator('[data-testid=\"user-welcome\"]')).toContainText(\n      \"Welcome\",\n    );\n  });\n});\n```\n\n**Required data-testid values:**\n\n- `login-form` - The login form container\n- `username-input` - Username/email input field\n- `password-input` - Password input field\n- `login-button` - Submit button\n- `dashboard-header` - Dashboard page header\n- `user-welcome` - Welcome message element\n\n### Example 2: E-commerce Product Purchase\n\n**Input:**\n\"Test the product purchase flow: search for 'laptop', select first result, add to cart, checkout, and verify order confirmation.\"\n\n**Output:**\n\n```typescript\nimport { test, expect } from \"@playwright/test\";\n\ntest.describe(\"E-commerce Purchase Flow\", () => {\n  test(\"should complete product purchase from search to confirmation\", async ({\n    page,\n  }) => {\n    // Arrange: Navigate to homepage\n    await page.goto(\"/\");\n    await expect(page.locator('[data-testid=\"search-bar\"]')).toBeVisible();\n\n    // Act: Search for product\n    await page.locator('[data-testid=\"search-input\"]').fill(\"laptop\");\n    await page.locator('[data-testid=\"search-button\"]').click();\n    await page.waitForLoadState(\"networkidle\");\n\n    // Act: Select first product\n    await expect(\n      page.locator('[data-testid=\"product-card\"]').first(),\n    ).toBeVisible();\n    await page.locator('[data-testid=\"product-card\"]').first().click();\n\n    // Act: Add to cart\n    await expect(\n      page.locator('[data-testid=\"add-to-cart-button\"]'),\n    ).toBeEnabled();\n    await page.locator('[data-testid=\"add-to-cart-button\"]').click();\n    await expect(page.locator('[data-testid=\"cart-count\"]')).toContainText(\"1\");\n\n    // Act: Proceed to checkout\n    await page.locator('[data-testid=\"cart-icon\"]').click();\n    await page.locator('[data-testid=\"checkout-button\"]').click();\n\n    // Act: Fill checkout form\n    await page.locator('[data-testid=\"shipping-name\"]').fill(\"John Doe\");\n    await page.locator('[data-testid=\"shipping-address\"]').fill(\"123 Main St\");\n    await page.locator('[data-testid=\"shipping-city\"]').fill(\"New York\");\n    await page.locator('[data-testid=\"shipping-zip\"]').fill(\"10001\");\n    await page.locator('[data-testid=\"payment-card\"]').fill(\"4242424242424242\");\n    await page.locator('[data-testid=\"payment-expiry\"]').fill(\"12/25\");\n    await page.locator('[data-testid=\"payment-cvc\"]').fill(\"123\");\n    await page.locator('[data-testid=\"place-order-button\"]').click();\n\n    // Assert: Verify order confirmation\n    await page.waitForURL(/\\/order\\/confirmation/);\n    await expect(\n      page.locator('[data-testid=\"order-success-message\"]'),\n    ).toBeVisible();\n    await expect(page.locator('[data-testid=\"order-number\"]')).toContainText(\n      /ORD-\\d+/,\n    );\n  });\n});\n```\n\n### Example 3: Form Validation Test\n\n**Input:**\n\"Create a test for contact form validation. Test that empty fields show error messages.\"\n\n**Output:**\n\n```typescript\nimport { test, expect } from \"@playwright/test\";\n\ntest.describe(\"Contact Form Validation\", () => {\n  test(\"should display validation errors for empty required fields\", async ({\n    page,\n  }) => {\n    // Arrange: Navigate to contact page\n    await page.goto(\"/contact\");\n    await expect(page.locator('[data-testid=\"contact-form\"]')).toBeVisible();\n\n    // Act: Submit form without filling any fields\n    await page.locator('[data-testid=\"submit-button\"]').click();\n\n    // Assert: Verify error messages appear\n    await expect(page.locator('[data-testid=\"name-error\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"name-error\"]')).toContainText(\n      \"Name is required\",\n    );\n\n    await expect(page.locator('[data-testid=\"email-error\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"email-error\"]')).toContainText(\n      \"Email is required\",\n    );\n\n    await expect(page.locator('[data-testid=\"message-error\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"message-error\"]')).toContainText(\n      \"Message is required\",\n    );\n\n    // Act: Fill fields correctly\n    await page.locator('[data-testid=\"name-input\"]').fill(\"John Doe\");\n    await page.locator('[data-testid=\"email-input\"]').fill(\"john@example.com\");\n    await page\n      .locator('[data-testid=\"message-input\"]')\n      .fill(\"Hello, this is a test message.\");\n\n    // Assert: Verify errors disappear\n    await expect(page.locator('[data-testid=\"name-error\"]')).not.toBeVisible();\n    await expect(page.locator('[data-testid=\"email-error\"]')).not.toBeVisible();\n    await expect(\n      page.locator('[data-testid=\"message-error\"]'),\n    ).not.toBeVisible();\n\n    // Act: Submit form\n    await page.locator('[data-testid=\"submit-button\"]').click();\n\n    // Assert: Verify success\n    await expect(page.locator('[data-testid=\"success-message\"]')).toBeVisible();\n  });\n});\n```\n\n## Best Practices\n\n### Test Structure\n\n1. **One scenario per test**: Each test should verify one specific behavior\n2. **Descriptive names**: Use \"should [expected behavior]\" format\n3. **AAA pattern**: Always follow Arrange-Act-Assert structure\n4. **Independent tests**: Tests should not depend on each other\n5. **Clean state**: Each test should start with a clean state (use fixtures)\n\n### Locators\n\n1. **data-testid ONLY**: Never use CSS selectors, XPath, or text-based locators\n2. **Semantic naming**: Use descriptive testid names (e.g., \"submit-button\" not \"btn1\")\n3. **Stable locators**: data-testid values should not change with UI updates\n4. **Unique identifiers**: Each testid should be unique on the page\n\n### Async/Await\n\n1. **Always await**: Every Playwright action should be awaited\n2. **No hardcoded waits**: Use `waitForSelector`, `waitForLoadState`, not `waitForTimeout`\n3. **Wait for elements**: Explicitly wait for elements before interaction\n4. **Wait for navigation**: Use `waitForURL` after actions that navigate\n\n### Assertions\n\n1. **Explicit expectations**: Use `expect()` with specific matchers\n2. **Wait for conditions**: Assertions automatically wait (default 5s)\n3. **Multiple assertions**: It's OK to have multiple assertions per test\n4. **Negative assertions**: Use `.not.toBeVisible()` for negative cases\n\n### Error Handling\n\n1. **Screenshot on failure**: Configure in playwright.config.ts\n2. **Trace on retry**: Enable trace recording for debugging\n3. **Meaningful errors**: Assertions should provide clear error messages\n4. **Timeout configuration**: Set appropriate timeouts (30s default)\n\n## Common Issues and Solutions\n\n### Issue 1: Test Times Out\n\n**Problem:** Test fails with \"Timeout 30000ms exceeded\" error\n\n**Solutions:**\n\n- Add explicit waits before interactions: `await page.waitForSelector('[data-testid=\"element\"]')`\n- Increase timeout for slow operations: `{ timeout: 60000 }`\n- Wait for network to be idle: `await page.waitForLoadState('networkidle')`\n- Check if element is actually present in the page\n- Verify the data-testid value is correct\n\n### Issue 2: Element Not Found\n\n**Problem:** \"Element not found\" or \"locator.click: Target closed\" errors\n\n**Solutions:**\n\n- Verify the data-testid value matches the HTML attribute\n- Add wait before interaction: `await expect(locator).toBeVisible()`\n- Check if element is in a frame/iframe (requires frame handling)\n- Ensure page has loaded: `await page.waitForLoadState('domcontentloaded')`\n- Verify element isn't dynamically loaded (wait for it explicitly)\n\n### Issue 3: Flaky Tests\n\n**Problem:** Test passes sometimes but fails randomly\n\n**Solutions:**\n\n- Remove all `page.waitForTimeout()` calls (use explicit waits instead)\n- Wait for specific conditions, not arbitrary time periods\n- Use `waitForLoadState('networkidle')` for AJAX-heavy pages\n- Enable retries in config (2 retries recommended)\n- Check for race conditions (multiple elements with same testid)\n- Ensure test isolation (clean state between tests)\n\n### Issue 4: Wrong Locator Strategy\n\n**Problem:** Generated test uses CSS selectors or XPath\n\n**Solutions:**\n\n- **ALWAYS** use `page.locator('[data-testid=\"element-name\"]')` format\n- Never use `page.locator('.class-name')` or `page.locator('#id')`\n- Never use `page.getByRole()`, `page.getByText()`, or `page.getByLabel()`\n- If data-testid doesn't exist, suggest adding it to the UI code\n- Document all required data-testid values for developers\n\n### Issue 5: Test Doesn't Match Requirements\n\n**Problem:** Generated test doesn't fully cover the specified scenario\n\n**Solutions:**\n\n- Re-read the requirements carefully\n- Break down complex flows into smaller steps\n- Verify all user actions are included\n- Ensure all expected outcomes have assertions\n- Ask user for clarification if requirements are ambiguous\n- Add comments explaining each step of the test\n\n## Resources\n\nThe `resources/` directory contains templates for common patterns:\n\n- `test-template.ts` - Basic test file structure\n- `playwright.config.ts` - Recommended Playwright configuration\n- `fixtures.ts` - Custom fixture examples (authentication, data setup)\n- `utils.ts` - Helper functions for common operations\n",
        "plugins/testing/playwright/skills/test-maintainer/SKILL.md": "---\nname: playwright-test-maintainer\ndescription: Maintain, refactor, and improve existing Playwright E2E tests. Handles tasks like updating locators across test suites, extracting reusable utilities, improving test stability, removing code duplication, and enforcing best practices throughout the test codebase.\n---\n\n## When to Use This Skill\n\nUse this skill when you need to:\n\n- Update data-testid locators across multiple tests\n- Refactor duplicate code into utilities or Page Objects\n- Improve flaky or unstable tests\n- Extract common test patterns into reusable fixtures\n- Update tests after UI changes\n- Migrate tests to use Page Object Model\n- Consolidate similar tests\n- Improve test readability and maintainability\n\nDo NOT use this skill when:\n\n- Creating new tests from scratch (use test-generator skill)\n- Building new Page Objects (use page-object-builder skill)\n- Debugging test failures (use test-debugger skill)\n\n## Prerequisites\n\nBefore using this skill:\n\n1. Access to existing test files\n2. Understanding of what changes are needed\n3. Knowledge of the current test structure\n4. Optional: Test execution results to identify flaky tests\n\n## Instructions\n\n### Step 1: Assess Current State\n\nGather information about:\n\n- **Test files** requiring maintenance\n- **Type of maintenance** needed (refactor, update locators, fix flakiness)\n- **Scope** of changes (single file, multiple files, entire suite)\n- **Current issues** (duplication, poor practices, flakiness)\n- **Desired end state** (what should the tests look like after)\n\n### Step 2: Identify Maintenance Type\n\nDetermine the maintenance task:\n\n**Locator Updates:**\n\n- Changing data-testid values\n- Updating selectors after UI changes\n- Migrating from CSS/XPath to data-testid\n\n**Code Refactoring:**\n\n- Extracting duplicate code to utilities\n- Creating Page Objects from inline selectors\n- Consolidating similar tests\n- Improving test structure\n\n**Stability Improvements:**\n\n- Adding explicit waits\n- Fixing race conditions\n- Removing hardcoded waits\n- Improving assertions\n\n**Best Practices:**\n\n- Enforcing data-testid usage\n- Implementing AAA pattern\n- Adding proper TypeScript types\n- Improving test isolation\n\n### Step 3: Plan the Changes\n\nBefore making changes:\n\n1. **Identify all affected files**\n2. **Backup or commit current state** (git commit)\n3. **Create checklist** of changes to make\n4. **Plan refactoring strategy** (bottom-up or top-down)\n5. **Consider impact** on other tests\n\n### Step 4: Apply Maintenance\n\nExecute the maintenance based on type:\n\n#### Locator Updates\n\n```typescript\n// Task: Update data-testid from \"btn-submit\" to \"submit-button\"\n\n// Before (multiple files)\nawait page.locator('[data-testid=\"btn-submit\"]').click();\n\n// After (updated in all files)\nawait page.locator('[data-testid=\"submit-button\"]').click();\n\n// Use search and replace across files\n// Find: '[data-testid=\"btn-submit\"]'\n// Replace: '[data-testid=\"submit-button\"]'\n```\n\n#### Extract Utilities\n\n```typescript\n// Before: Duplicate login code in multiple tests\ntest(\"test 1\", async ({ page }) => {\n  await page.goto(\"/login\");\n  await page.locator('[data-testid=\"email\"]').fill(\"user@example.com\");\n  await page.locator('[data-testid=\"password\"]').fill(\"password\");\n  await page.locator('[data-testid=\"login-button\"]').click();\n  await page.waitForURL(\"/dashboard\");\n  // ... test continues\n});\n\n// After: Extract to utility function\n// In utils/auth.ts\nexport async function login(page: Page, email: string, password: string) {\n  await page.goto(\"/login\");\n  await page.locator('[data-testid=\"email\"]').fill(email);\n  await page.locator('[data-testid=\"password\"]').fill(password);\n  await page.locator('[data-testid=\"login-button\"]').click();\n  await page.waitForURL(\"/dashboard\");\n}\n\n// In tests\ntest(\"test 1\", async ({ page }) => {\n  await login(page, \"user@example.com\", \"password\");\n  // ... test continues\n});\n```\n\n#### Migrate to Page Objects\n\n```typescript\n// Before: Inline selectors throughout tests\ntest(\"update profile\", async ({ page }) => {\n  await page.goto(\"/profile\");\n  await page.locator('[data-testid=\"name-input\"]').fill(\"John Doe\");\n  await page.locator('[data-testid=\"email-input\"]').fill(\"john@example.com\");\n  await page.locator('[data-testid=\"save-button\"]').click();\n  await expect(page.locator('[data-testid=\"success-message\"]')).toBeVisible();\n});\n\n// After: Using Page Object\n// Create ProfilePage.ts (see page-object-builder skill)\n\ntest(\"update profile\", async ({ page }) => {\n  const profilePage = new ProfilePage(page);\n  await profilePage.goto();\n  await profilePage.updateProfile({\n    name: \"John Doe\",\n    email: \"john@example.com\",\n  });\n  await expect(profilePage.getSuccessMessage()).toBeVisible();\n});\n```\n\n#### Fix Flaky Tests\n\n```typescript\n// Before: Flaky due to race condition\nawait page.locator('[data-testid=\"submit\"]').click();\nawait expect(page.locator('[data-testid=\"result\"]')).toContainText(\"Success\");\n\n// After: Add proper waits\nawait page.locator('[data-testid=\"submit\"]').click();\nawait page.waitForLoadState(\"networkidle\");\nawait expect(page.locator('[data-testid=\"result\"]')).toContainText(\"Success\", {\n  timeout: 10000,\n});\n```\n\n### Step 5: Ensure Consistency\n\nAfter changes:\n\n- [ ] All tests use data-testid locators\n- [ ] Consistent naming conventions\n- [ ] Follow AAA pattern\n- [ ] Proper TypeScript types\n- [ ] No code duplication\n- [ ] Tests are isolated\n- [ ] Proper waits (no hardcoded timeouts)\n\n### Step 6: Verify Changes\n\nRun tests to ensure:\n\n1. **All tests pass** after refactoring\n2. **No regressions** introduced\n3. **Improved stability** (run multiple times)\n4. **Better readability** and maintainability\n5. **Reduced code duplication**\n\n## Examples\n\n### Example 1: Update Locators Across Test Suite\n\n**Input:**\n\"The development team changed all button data-testids from format 'btn-action' to 'action-button'. Update all tests.\"\n\n**Changes:**\n\n```typescript\n// Create mapping of old to new testids\nconst locatorUpdates = {\n  \"btn-submit\": \"submit-button\",\n  \"btn-cancel\": \"cancel-button\",\n  \"btn-delete\": \"delete-button\",\n  \"btn-edit\": \"edit-button\",\n  \"btn-save\": \"save-button\",\n};\n\n// Apply to all test files:\n// Find all instances in: tests/**/*.spec.ts\n\n// Example in login.spec.ts:\n// Before\nawait page.locator('[data-testid=\"btn-submit\"]').click();\n\n// After\nawait page.locator('[data-testid=\"submit-button\"]').click();\n\n// Use global find and replace for each mapping\n```\n\n**Verification:**\n\n```bash\n# Search for old pattern to ensure all updated\ngrep -r \"btn-\" tests/\n\n# Run all tests\nnpx playwright test\n\n# Check for any failures\n```\n\n### Example 2: Extract Common Test Utilities\n\n**Input:**\n\"Multiple tests have duplicate code for filling forms. Extract to reusable utilities.\"\n\n**Solution:**\n\n```typescript\n// Identify duplicate pattern across tests:\n// Pattern 1: Form filling\nawait page.locator('[data-testid=\"field1\"]').fill(value1);\nawait page.locator('[data-testid=\"field2\"]').fill(value2);\nawait page.locator('[data-testid=\"field3\"]').fill(value3);\n\n// Create utils/form-helpers.ts:\nimport { Page } from \"@playwright/test\";\n\nexport async function fillForm(\n  page: Page,\n  fields: Record<string, string>,\n): Promise<void> {\n  for (const [testId, value] of Object.entries(fields)) {\n    await page.locator(`[data-testid=\"${testId}\"]`).fill(value);\n  }\n}\n\nexport async function submitForm(\n  page: Page,\n  submitButtonTestId: string,\n): Promise<void> {\n  await page\n    .locator(`[data-testid=\"${submitButtonTestId}\"]`)\n    .waitFor({ state: \"visible\" });\n  await page.locator(`[data-testid=\"${submitButtonTestId}\"]`).click();\n}\n\n// Update all tests to use utilities:\nimport { fillForm, submitForm } from \"../utils/form-helpers\";\n\ntest(\"contact form submission\", async ({ page }) => {\n  await page.goto(\"/contact\");\n\n  await fillForm(page, {\n    \"name-input\": \"John Doe\",\n    \"email-input\": \"john@example.com\",\n    \"message-input\": \"Hello!\",\n  });\n\n  await submitForm(page, \"submit-button\");\n  await expect(page.locator('[data-testid=\"success\"]')).toBeVisible();\n});\n```\n\n### Example 3: Consolidate Similar Tests\n\n**Input:**\n\"We have 5 tests that test form validation with different invalid inputs. Consolidate using test.each.\"\n\n**Before:**\n\n```typescript\ntest(\"should show error for empty email\", async ({ page }) => {\n  await page.goto(\"/register\");\n  await page.locator('[data-testid=\"email\"]').fill(\"\");\n  await page.locator('[data-testid=\"submit\"]').click();\n  await expect(page.locator('[data-testid=\"email-error\"]')).toBeVisible();\n});\n\ntest(\"should show error for invalid email\", async ({ page }) => {\n  await page.goto(\"/register\");\n  await page.locator('[data-testid=\"email\"]').fill(\"invalid\");\n  await page.locator('[data-testid=\"submit\"]').click();\n  await expect(page.locator('[data-testid=\"email-error\"]')).toBeVisible();\n});\n\n// ... 3 more similar tests\n```\n\n**After:**\n\n```typescript\nconst invalidEmails = [\n  { email: \"\", description: \"empty email\" },\n  { email: \"invalid\", description: \"invalid format\" },\n  { email: \"@example.com\", description: \"missing local part\" },\n  { email: \"user@\", description: \"missing domain\" },\n  { email: \"user @example.com\", description: \"space in email\" },\n];\n\ntest.describe(\"Email validation\", () => {\n  for (const { email, description } of invalidEmails) {\n    test(`should show error for ${description}`, async ({ page }) => {\n      await page.goto(\"/register\");\n      await page.locator('[data-testid=\"email\"]').fill(email);\n      await page.locator('[data-testid=\"submit\"]').click();\n      await expect(page.locator('[data-testid=\"email-error\"]')).toBeVisible();\n    });\n  }\n});\n```\n\n### Example 4: Improve Flaky Test\n\n**Input:**\n\"Test 'user dashboard loads' fails intermittently with 'element not found' error.\"\n\n**Analysis:**\n\n```typescript\n// Current test (flaky):\ntest(\"user dashboard loads\", async ({ page }) => {\n  await page.goto(\"/dashboard\");\n  await expect(page.locator('[data-testid=\"welcome-message\"]')).toBeVisible();\n  await expect(page.locator('[data-testid=\"stats-card\"]')).toHaveCount(4);\n});\n\n// Issue: Not waiting for data to load\n```\n\n**Solution:**\n\n```typescript\ntest(\"user dashboard loads\", async ({ page }) => {\n  await page.goto(\"/dashboard\");\n\n  // Wait for page to fully load\n  await page.waitForLoadState(\"networkidle\");\n\n  // Wait for API call to complete\n  await page.waitForResponse(\"**/api/dashboard\");\n\n  // Now check elements\n  await expect(page.locator('[data-testid=\"welcome-message\"]')).toBeVisible({\n    timeout: 10000,\n  });\n\n  // Wait for all stats cards to load\n  await page\n    .locator('[data-testid=\"stats-card\"]')\n    .first()\n    .waitFor({ state: \"visible\" });\n  await expect(page.locator('[data-testid=\"stats-card\"]')).toHaveCount(4);\n});\n```\n\n### Example 5: Migrate Test to Use Fixtures\n\n**Input:**\n\"Tests require authentication but each test logs in manually. Create fixture for authenticated state.\"\n\n**Solution:**\n\n```typescript\n// Create fixtures/auth.ts:\nimport { test as base, Page } from \"@playwright/test\";\n\ntype AuthFixtures = {\n  authenticatedPage: Page;\n};\n\nexport const test = base.extend<AuthFixtures>({\n  authenticatedPage: async ({ page }, use) => {\n    // Login once\n    await page.goto(\"/login\");\n    await page.locator('[data-testid=\"email\"]').fill(\"test@example.com\");\n    await page.locator('[data-testid=\"password\"]').fill(\"password\");\n    await page.locator('[data-testid=\"login-button\"]').click();\n    await page.waitForURL(\"/dashboard\");\n\n    await use(page);\n\n    // Cleanup if needed\n  },\n});\n\nexport { expect } from \"@playwright/test\";\n\n// Update tests:\n// Before\nimport { test, expect } from \"@playwright/test\";\n\ntest(\"view profile\", async ({ page }) => {\n  // Login code...\n  await page.goto(\"/login\");\n  // ... more login code\n\n  // Actual test\n  await page.goto(\"/profile\");\n  // ...\n});\n\n// After\nimport { test, expect } from \"../fixtures/auth\";\n\ntest(\"view profile\", async ({ authenticatedPage: page }) => {\n  // Already logged in!\n  await page.goto(\"/profile\");\n  // ... test continues\n});\n```\n\n## Best Practices\n\n### Refactoring Strategy\n\n1. **Small incremental changes**: Refactor one thing at a time\n2. **Run tests frequently**: After each change, verify tests still pass\n3. **Use version control**: Commit after each successful refactoring\n4. **Keep tests passing**: Never leave tests broken during refactoring\n5. **Update related tests together**: Maintain consistency across suite\n\n### Code Quality\n\n1. **DRY principle**: Don't Repeat Yourself - extract common code\n2. **Single Responsibility**: Each test tests one thing\n3. **Clear naming**: Tests should describe what they verify\n4. **Proper structure**: Follow AAA pattern consistently\n5. **Type safety**: Use TypeScript types throughout\n\n### Maintenance Patterns\n\n1. **Centralize selectors**: Use Page Objects or constants\n2. **Extract utilities**: Common actions go in helper functions\n3. **Use fixtures**: Shared setup goes in fixtures\n4. **Consistent waits**: Standardize waiting strategies\n5. **Error handling**: Consistent approach to expected errors\n\n## Common Issues and Solutions\n\n### Issue 1: Large-Scale Locator Changes\n\n**Problem:** Need to update hundreds of locators across many files\n\n**Solutions:**\n\n- Use IDE find and replace with regex\n- Create a migration script\n- Update and test incrementally (file by file)\n- Use git to track changes and rollback if needed\n\n```bash\n# Example: Update all instances in all test files\nfind tests -name \"*.spec.ts\" -exec sed -i 's/btn-submit/submit-button/g' {} +\n\n# Verify changes\ngit diff\n\n# Run tests\nnpx playwright test\n```\n\n### Issue 2: Breaking Tests During Refactoring\n\n**Problem:** Tests fail after refactoring\n\n**Solutions:**\n\n- Refactor smaller sections at a time\n- Keep one version working while refactoring\n- Use feature flags for gradual migration\n- Maintain backward compatibility during transition\n\n### Issue 3: Inconsistent Patterns Across Tests\n\n**Problem:** Different tests use different approaches\n\n**Solutions:**\n\n- Document standard patterns in team guidelines\n- Create templates for common test scenarios\n- Use linting rules to enforce consistency\n- Conduct code reviews to maintain standards\n- Gradually migrate old tests to new patterns\n\n### Issue 4: Difficult to Extract Common Code\n\n**Problem:** Tests are similar but not identical\n\n**Solutions:**\n\n- Identify the varying parts and parameterize them\n- Use fixtures with parameters\n- Create flexible utility functions\n- Consider builder pattern for complex setups\n\n```typescript\n// Flexible utility with options\nasync function performLogin(\n  page: Page,\n  options: {\n    email?: string;\n    password?: string;\n    rememberMe?: boolean;\n    expectSuccess?: boolean;\n  } = {},\n) {\n  const {\n    email = \"default@example.com\",\n    password = \"password\",\n    rememberMe = false,\n    expectSuccess = true,\n  } = options;\n\n  await page.goto(\"/login\");\n  await page.locator('[data-testid=\"email\"]').fill(email);\n  await page.locator('[data-testid=\"password\"]').fill(password);\n\n  if (rememberMe) {\n    await page.locator('[data-testid=\"remember-me\"]').check();\n  }\n\n  await page.locator('[data-testid=\"login-button\"]').click();\n\n  if (expectSuccess) {\n    await page.waitForURL(\"/dashboard\");\n  }\n}\n```\n\n### Issue 5: Tests Become Over-Abstracted\n\n**Problem:** Too many layers of abstraction make tests hard to understand\n\n**Solutions:**\n\n- Balance DRY with readability\n- Keep tests readable - it's OK to have some duplication\n- Don't abstract everything - abstract common patterns\n- Inline simple operations rather than creating tiny utilities\n- Document complex abstractions\n\n## Resources\n\nThe `resources/` directory contains helpful references:\n\n- `refactoring-patterns.md` - Common refactoring patterns for tests\n- `migration-guide.md` - Guide for migrating tests to new patterns\n- `best-practices.md` - Testing best practices checklist\n",
        "plugins/testing/playwright/skills/test-maintainer/resources/best-practices.md": "# Playwright Testing Best Practices Checklist\n\n## Test Structure\n\n- [ ] Tests follow AAA pattern (Arrange-Act-Assert)\n- [ ] One assertion per test (or closely related assertions)\n- [ ] Tests are independent and can run in any order\n- [ ] Clear, descriptive test names using \"should\" format\n- [ ] Proper use of test.describe for grouping related tests\n\n## Locators\n\n- [ ] **ONLY** data-testid locators used (no CSS/XPath)\n- [ ] data-testid values are semantic and descriptive\n- [ ] No brittle selectors (class names, IDs, XPath)\n- [ ] Locators are unique on the page\n- [ ] Use .first() or .nth() for intentional multiple elements\n\n## Waiting & Timing\n\n- [ ] Explicit waits before interactions\n- [ ] NO hardcoded waits (page.waitForTimeout())\n- [ ] Use waitForLoadState() after navigation\n- [ ] Wait for network requests when needed\n- [ ] Proper timeouts for slow operations\n\n## Code Organization\n\n- [ ] No code duplication - extract to utilities/Page Objects\n- [ ] Use Page Object Model for complex pages\n- [ ] Common setup in fixtures\n- [ ] Utilities for repeated actions\n- [ ] Clear file and folder structure\n\n## TypeScript\n\n- [ ] All functions have proper types\n- [ ] No `any` types (use specific types)\n- [ ] Interfaces for complex data structures\n- [ ] Async/await used correctly\n- [ ] Proper error handling\n\n## Test Isolation\n\n- [ ] Tests don't depend on each other\n- [ ] Clean state before each test\n- [ ] Proper cleanup in afterEach/afterAll\n- [ ] No shared mutable state\n- [ ] Each test creates its own data\n\n## Assertions\n\n- [ ] Use appropriate matchers (toBeVisible, toContainText, etc.)\n- [ ] Assertions have proper error messages\n- [ ] Wait for conditions before asserting\n- [ ] Check both positive and negative cases\n- [ ] Use expect() consistently\n\n## Configuration\n\n- [ ] Proper timeout settings\n- [ ] Retries enabled for flaky tests\n- [ ] Screenshot on failure\n- [ ] Trace on first retry\n- [ ] Parallel execution configured\n\n## Documentation\n\n- [ ] Complex test logic has comments\n- [ ] Page Objects are documented\n- [ ] Utilities have JSDoc comments\n- [ ] README explains test structure\n- [ ] Known issues documented\n\n## Maintenance\n\n- [ ] Regular review of flaky tests\n- [ ] Remove obsolete tests\n- [ ] Update tests when UI changes\n- [ ] Refactor duplicate code\n- [ ] Keep dependencies updated\n",
        "plugins/testing/playwright/skills/test-maintainer/resources/refactoring-patterns.md": "# Test Refactoring Patterns\n\n## Pattern 1: Extract Method\n\n**When:** Duplicate code appears in multiple tests\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  await page.locator('[data-testid=\"email\"]').fill('user@example.com');\n  await page.locator('[data-testid=\"password\"]').fill('password');\n  await page.locator('[data-testid=\"login\"]').click();\n  await page.waitForURL('/dashboard');\n  // test continues...\n});\n\ntest('test 2', async ({ page }) => {\n  await page.locator('[data-testid=\"email\"]').fill('user@example.com');\n  await page.locator('[data-testid=\"password\"]').fill('password');\n  await page.locator('[data-testid=\"login\"]').click();\n  await page.waitForURL('/dashboard');\n  // different test logic...\n});\n```\n\n**After:**\n```typescript\n// utils/auth.ts\nexport async function login(page: Page, email = 'user@example.com', password = 'password') {\n  await page.locator('[data-testid=\"email\"]').fill(email);\n  await page.locator('[data-testid=\"password\"]').fill(password);\n  await page.locator('[data-testid=\"login\"]').click();\n  await page.waitForURL('/dashboard');\n}\n\n// In tests\ntest('test 1', async ({ page }) => {\n  await login(page);\n  // test continues...\n});\n\ntest('test 2', async ({ page }) => {\n  await login(page);\n  // different test logic...\n});\n```\n\n## Pattern 2: Extract to Fixture\n\n**When:** Setup code needed for multiple tests\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  await page.goto('/login');\n  await page.locator('[data-testid=\"email\"]').fill('test@example.com');\n  await page.locator('[data-testid=\"password\"]').fill('password');\n  await page.locator('[data-testid=\"login\"]').click();\n  await page.waitForURL('/dashboard');\n  // test logic...\n});\n```\n\n**After:**\n```typescript\n// fixtures/auth.ts\nexport const test = base.extend<{ authenticatedPage: Page }>({\n  authenticatedPage: async ({ page }, use) => {\n    await page.goto('/login');\n    await page.locator('[data-testid=\"email\"]').fill('test@example.com');\n    await page.locator('[data-testid=\"password\"]').fill('password');\n    await page.locator('[data-testid=\"login\"]').click();\n    await page.waitForURL('/dashboard');\n    await use(page);\n  },\n});\n\n// In tests\ntest('test 1', async ({ authenticatedPage: page }) => {\n  // Already logged in\n  // test logic...\n});\n```\n\n## Pattern 3: Extract to Page Object\n\n**When:** Many tests interact with the same page\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  await page.goto('/profile');\n  await page.locator('[data-testid=\"name\"]').fill('John');\n  await page.locator('[data-testid=\"save\"]').click();\n  await expect(page.locator('[data-testid=\"success\"]')).toBeVisible();\n});\n\ntest('test 2', async ({ page }) => {\n  await page.goto('/profile');\n  await page.locator('[data-testid=\"email\"]').fill('john@example.com');\n  await page.locator('[data-testid=\"save\"]').click();\n  await expect(page.locator('[data-testid=\"success\"]')).toBeVisible();\n});\n```\n\n**After:**\n```typescript\n// page-objects/ProfilePage.ts\nexport class ProfilePage {\n  constructor(readonly page: Page) {}\n\n  async goto() {\n    await this.page.goto('/profile');\n  }\n\n  async updateName(name: string) {\n    await this.page.locator('[data-testid=\"name\"]').fill(name);\n  }\n\n  async updateEmail(email: string) {\n    await this.page.locator('[data-testid=\"email\"]').fill(email);\n  }\n\n  async save() {\n    await this.page.locator('[data-testid=\"save\"]').click();\n  }\n\n  getSuccessMessage() {\n    return this.page.locator('[data-testid=\"success\"]');\n  }\n}\n\n// In tests\ntest('test 1', async ({ page }) => {\n  const profilePage = new ProfilePage(page);\n  await profilePage.goto();\n  await profilePage.updateName('John');\n  await profilePage.save();\n  await expect(profilePage.getSuccessMessage()).toBeVisible();\n});\n```\n\n## Pattern 4: Parameterized Tests\n\n**When:** Same test logic with different inputs\n\n**Before:**\n```typescript\ntest('validates email 1', async ({ page }) => {\n  await page.locator('[data-testid=\"email\"]').fill('invalid');\n  await page.locator('[data-testid=\"submit\"]').click();\n  await expect(page.locator('[data-testid=\"error\"]')).toBeVisible();\n});\n\ntest('validates email 2', async ({ page }) => {\n  await page.locator('[data-testid=\"email\"]').fill('@example.com');\n  await page.locator('[data-testid=\"submit\"]').click();\n  await expect(page.locator('[data-testid=\"error\"]')).toBeVisible();\n});\n```\n\n**After:**\n```typescript\nconst invalidEmails = [\n  'invalid',\n  '@example.com',\n  'user@',\n  '',\n  'user @example.com',\n];\n\nfor (const email of invalidEmails) {\n  test(`validates email: ${email}`, async ({ page }) => {\n    await page.locator('[data-testid=\"email\"]').fill(email);\n    await page.locator('[data-testid=\"submit\"]').click();\n    await expect(page.locator('[data-testid=\"error\"]')).toBeVisible();\n  });\n}\n```\n\n## Pattern 5: Builder Pattern for Complex Setup\n\n**When:** Tests need complex object creation\n\n**Before:**\n```typescript\ntest('create user', async ({ page }) => {\n  await page.locator('[data-testid=\"name\"]').fill('John');\n  await page.locator('[data-testid=\"email\"]').fill('john@example.com');\n  await page.locator('[data-testid=\"age\"]').fill('30');\n  await page.locator('[data-testid=\"country\"]').selectOption('USA');\n  await page.locator('[data-testid=\"bio\"]').fill('Software engineer');\n  // ... many more fields\n});\n```\n\n**After:**\n```typescript\n// utils/UserBuilder.ts\nexport class UserBuilder {\n  private data: Record<string, string> = {\n    name: 'Default Name',\n    email: 'default@example.com',\n    age: '25',\n    country: 'USA',\n  };\n\n  withName(name: string) {\n    this.data.name = name;\n    return this;\n  }\n\n  withEmail(email: string) {\n    this.data.email = email;\n    return this;\n  }\n\n  async fillForm(page: Page) {\n    for (const [field, value] of Object.entries(this.data)) {\n      await page.locator(`[data-testid=\"${field}\"]`).fill(value);\n    }\n  }\n}\n\n// In test\ntest('create user', async ({ page }) => {\n  await new UserBuilder()\n    .withName('John')\n    .withEmail('john@example.com')\n    .fillForm(page);\n});\n```\n\n## Pattern 6: Test Data Factory\n\n**When:** Need consistent test data across tests\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  const user = {\n    email: 'test@example.com',\n    password: 'password123',\n    name: 'Test User',\n  };\n  // use user...\n});\n\ntest('test 2', async ({ page }) => {\n  const user = {\n    email: 'test2@example.com',\n    password: 'password123',\n    name: 'Test User 2',\n  };\n  // use user...\n});\n```\n\n**After:**\n```typescript\n// utils/factories.ts\nexport const createUser = (overrides = {}) => ({\n  email: 'test@example.com',\n  password: 'password123',\n  name: 'Test User',\n  ...overrides,\n});\n\n// In tests\ntest('test 1', async ({ page }) => {\n  const user = createUser();\n  // use user...\n});\n\ntest('test 2', async ({ page }) => {\n  const user = createUser({ email: 'test2@example.com', name: 'Test User 2' });\n  // use user...\n});\n```\n\n## Pattern 7: Extract Wait Strategy\n\n**When:** Consistent waiting needed across tests\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  await page.locator('[data-testid=\"submit\"]').click();\n  await page.waitForLoadState('networkidle');\n  await expect(page.locator('[data-testid=\"result\"]')).toBeVisible({ timeout: 10000 });\n});\n\ntest('test 2', async ({ page }) => {\n  await page.locator('[data-testid=\"save\"]').click();\n  await page.waitForLoadState('networkidle');\n  await expect(page.locator('[data-testid=\"success\"]')).toBeVisible({ timeout: 10000 });\n});\n```\n\n**After:**\n```typescript\n// utils/wait-helpers.ts\nexport async function waitForActionComplete(page: Page, resultTestId: string) {\n  await page.waitForLoadState('networkidle');\n  await page.locator(`[data-testid=\"${resultTestId}\"]`).waitFor({\n    state: 'visible',\n    timeout: 10000,\n  });\n}\n\n// In tests\ntest('test 1', async ({ page }) => {\n  await page.locator('[data-testid=\"submit\"]').click();\n  await waitForActionComplete(page, 'result');\n});\n```\n\n## Pattern 8: Consolidate Assertions\n\n**When:** Similar assertions repeated across tests\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  // ... actions\n  await expect(page.locator('[data-testid=\"success\"]')).toBeVisible();\n  await expect(page.locator('[data-testid=\"success\"]')).toContainText('Success');\n  await expect(page.locator('[data-testid=\"error\"]')).not.toBeVisible();\n});\n```\n\n**After:**\n```typescript\n// utils/assertions.ts\nexport async function assertSuccess(page: Page) {\n  await expect(page.locator('[data-testid=\"success\"]')).toBeVisible();\n  await expect(page.locator('[data-testid=\"success\"]')).toContainText('Success');\n  await expect(page.locator('[data-testid=\"error\"]')).not.toBeVisible();\n}\n\n// In tests\ntest('test 1', async ({ page }) => {\n  // ... actions\n  await assertSuccess(page);\n});\n```\n\n## Pattern 9: Extract Navigation Logic\n\n**When:** Complex navigation patterns repeated\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  await page.goto('/');\n  await page.locator('[data-testid=\"menu\"]').click();\n  await page.locator('[data-testid=\"settings\"]').click();\n  await page.locator('[data-testid=\"profile\"]').click();\n  // test logic...\n});\n```\n\n**After:**\n```typescript\n// utils/navigation.ts\nexport async function navigateToProfile(page: Page) {\n  await page.goto('/');\n  await page.locator('[data-testid=\"menu\"]').click();\n  await page.locator('[data-testid=\"settings\"]').click();\n  await page.locator('[data-testid=\"profile\"]').click();\n  await page.waitForLoadState('domcontentloaded');\n}\n\n// In tests\ntest('test 1', async ({ page }) => {\n  await navigateToProfile(page);\n  // test logic...\n});\n```\n\n## Pattern 10: Replace Magic Strings with Constants\n\n**When:** Same strings/values used in multiple places\n\n**Before:**\n```typescript\ntest('test 1', async ({ page }) => {\n  await page.locator('[data-testid=\"submit-button\"]').click();\n});\n\ntest('test 2', async ({ page }) => {\n  await expect(page.locator('[data-testid=\"submit-button\"]')).toBeEnabled();\n});\n```\n\n**After:**\n```typescript\n// constants/testids.ts\nexport const TESTIDS = {\n  SUBMIT_BUTTON: 'submit-button',\n  CANCEL_BUTTON: 'cancel-button',\n  // ... more testids\n};\n\n// In tests\ntest('test 1', async ({ page }) => {\n  await page.locator(`[data-testid=\"${TESTIDS.SUBMIT_BUTTON}\"]`).click();\n});\n\n// Or create a helper\nfunction getByTestId(page: Page, testId: string) {\n  return page.locator(`[data-testid=\"${testId}\"]`);\n}\n\ntest('test 1', async ({ page }) => {\n  await getByTestId(page, TESTIDS.SUBMIT_BUTTON).click();\n});\n```\n"
      },
      "plugins": [
        {
          "name": "plugin-builder",
          "source": "./plugins/claude/plugin-builder",
          "description": "Helps create well-structured Claude Code plugins with skills, commands, and proper metadata following best practices",
          "category": "claude",
          "categories": [
            "claude"
          ],
          "install_commands": [
            "/plugin marketplace add joel611/claude-plugins",
            "/plugin install plugin-builder@joel-plugins"
          ]
        },
        {
          "name": "playwright",
          "source": "./plugins/testing/playwright",
          "description": "Comprehensive Playwright E2E testing plugin with test generation, Page Object Models, debugging, and maintenance. Features data-testid locators, TypeScript-first approach, and Playwright MCP integration for browser automation.",
          "category": "testing",
          "categories": [
            "testing"
          ],
          "install_commands": [
            "/plugin marketplace add joel611/claude-plugins",
            "/plugin install playwright@joel-plugins"
          ]
        },
        {
          "name": "tts-output",
          "source": "./plugins/claude/tts-output",
          "description": "Text-to-speech output for Claude responses using macOS 'say' command with customizable voice, speed, and AI-generated summaries",
          "category": "claude",
          "categories": [
            "claude"
          ],
          "install_commands": [
            "/plugin marketplace add joel611/claude-plugins",
            "/plugin install tts-output@joel-plugins"
          ]
        },
        {
          "name": "gemini-research",
          "source": "./plugins/analysis/gemini-research",
          "description": "Multi-agent plugin using gemini-cli for comprehensive code analysis and web research. Leverages Gemini's 1M token context window through specialized subagents for pattern detection, architecture analysis, documentation lookup, and technology comparisons.",
          "category": "analysis",
          "categories": [
            "analysis"
          ],
          "install_commands": [
            "/plugin marketplace add joel611/claude-plugins",
            "/plugin install gemini-research@joel-plugins"
          ]
        },
        {
          "name": "interview",
          "source": "./plugins/claude/interview",
          "description": "Interactive interview command that asks in-depth questions to gather detailed requirements and generate comprehensive specifications",
          "category": "claude",
          "categories": [
            "claude"
          ],
          "install_commands": [
            "/plugin marketplace add joel611/claude-plugins",
            "/plugin install interview@joel-plugins"
          ]
        },
        {
          "name": "elysia-specialist",
          "source": "./plugins/coding/elysia",
          "description": "ElysiaJS specialist plugin that provides advanced code analysis, debugging, and documentation lookup capabilities for ElysiaJS applications",
          "category": "coding",
          "categories": [
            "coding"
          ],
          "install_commands": [
            "/plugin marketplace add joel611/claude-plugins",
            "/plugin install elysia-specialist@joel-plugins"
          ]
        }
      ]
    }
  ]
}