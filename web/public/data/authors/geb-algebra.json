{
  "author": {
    "id": "Geb-algebra",
    "display_name": "Geb",
    "avatar_url": "https://avatars.githubusercontent.com/u/77182026?u=80b4eb5c8a3e630baab19609f0046d3c5f9ddfa2&v=4"
  },
  "marketplaces": [
    {
      "name": "stationery",
      "version": null,
      "description": "A Markdown-based workflow for collaborating with AI that uses the implementation as the single source of truth, enabling spec-like, iterative development without relying on separate or fragile documentation.",
      "repo_full_name": "Geb-algebra/stationery",
      "repo_url": "https://github.com/Geb-algebra/stationery",
      "repo_description": "A lightweight toolkit for AI-assisted coding — small, flexible tools you can use at any stage of development, and walk away from anytime",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-14T02:29:12Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"stationery\",\n  \"owner\": {\n    \"name\": \"Geb-algebra\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"pad\",\n      \"source\": \"./pad\",\n      \"description\": \"A Markdown-based workflow for collaborating with AI that uses the implementation as the single source of truth, enabling spec-like, iterative development without relying on separate or fragile documentation.\"\n    },\n    {\n      \"name\": \"notebook\",\n      \"source\": \"./notebook\",\n      \"description\": \"(WIP) Lightweight, persistent memory for AI agents. Records minimal, durable knowledge discovered through implementation.\"\n    }\n  ]\n}",
        "README.md": "# Stationery\n\nStationery is a lightweight toolkit for AI-assisted coding.  \nEach tool is small, simple, and flexible — you can start using it anytime,  \nand step away just as easily.\n\nFrom early prototyping to large-scale enterprise development,  \nStationery supports your workflow without taking control.  \nIt adapts to *your* way of building.\n\n## Motivation\n\n**Stationery** is a toolkit that brings together the best of both worlds —\nthe *ease of vibe-coding* and the *steadiness of Spec-Driven Development*.\n\nVibe-coding — talking with AI and writing code as ideas come — makes it easy to turn inspiration into shape.\nBut that ease doesn’t last forever. As your project grows, intentions blur, specs drift, and maintenance slowly becomes impossible.\n\nSpec-Driven Development was born to solve that problem — a way to collaborate with AI while keeping your project structured and stable.\nTools like **Spec Kit** and **OpenSpec** show how powerful this approach can be.\n\nYet, after using them for real projects, they can sometimes feel a bit heavy. For example:\n\n* **They lock your project in.**\n  Once you start, your entire spec format depends on the tool — moving away becomes nearly impossible.\n* **They enforce a single process.**\n  Each tool defines how you should develop, leaving little room for your own team’s style.\n* **They’re almost impossible to introduce mid-project.**\n  You can’t use them effectively without specs for every part of your codebase — preparing those takes enormous time and effort.\n* **They require constant maintenance.**\n  Natural language is always more ambiguous than code. As development continues, mismatches and contradictions easily appear between specs.\n  To keep things working, you must keep checking and updating by hand.\n\n**Stationery** was created out of a wish to keep the reliability of Spec-Driven Development,\nwhile leaving behind that heaviness — a lighter, gentler way to work with AI.\n\n---\n\n**No lock-in.**\nStationery tools don’t depend on any part of your project.\nYou decide which resources to connect, and how.\n\n**No need to follow the tool’s way.**\nStationery doesn’t prescribe a workflow.\nUse only the tools that fit you, and leave the rest.\nYou don’t adapt to the tool — the tool adapts to you.\n\n**Start instantly.**\nNo setup, no commands, no preparation needed.\nJust take one file you like from this repository, and drop it into yours.\n\n**When you’re done, just put it away.**\nStationery tools — and whatever they generate — can be removed at any time.\nKeep what helps, and let go of what doesn’t.\n\n---\n\nStationery isn’t a framework or a system.\nIt’s a small collection of tools — calm, simple, and always by your side,\nlike the stationery on your desk.\n",
        "pad/README.md": "# Pad\n\nPad is a markdown file that enforces your collabolation with AI.\n\nThe development process using Pad is similar to spec-driven development: instruct, make specifications, design, plan, break down tasks, and then implement.\n\nHowever, there is one decisive difference — the single source of truth is the implementation, not the documentation.\nPad relies on your implementation, not on a specification produced by a particular tool.\n\nYou may have no docs, but you always have an implementation.\nThis allows you to start using Pad at any time.\n\nDocs can lie, but implementations do not.\nAs long as the implementation is consistent (which can be easily verified with linters, type checks, tests, etc.), Pad will function correctly.\nYou don’t need to meticulously manage a specification tailored to a particular tool.\n\n## Usage\n\nAt the first time you use Pad in your repo, place and rename `impl-pad.md` and `write-pad.md` so that your coding agent can use them as custom commands.\nIf you like the Pad, It is recommended to place the command globally to use it all of your repo.\n\n| Agent          | filename                                 | place (workspace)             | place (global)      |\n| -------------- | ---------------------------------------- | ----------------------------- | ------------------- |\n| GitHub Copilot | impl-pad.prompt.md / write-pad.prompt.md | {repo root}/.github/prompts/  |                     |\n| Cursor         | no changes required                      | {repo root}/.cursor/commands/ | ~/.cursor/commands/ |\n| Claude Code    | no changes required                      | {repo root}/.claude/commands/ | ~/.claude/commands/ |\n| Codex          | no changes required                      |                               | ~/.codex/prompts/   |\n\nEvery time you start new work:\n\n### 1. Instruct\n\n**Option A: Create pad.md with inline instructions**\n- Run `/write-pad {your instructions}` directly\n- AI will create `pad.md` with your instructions in the Instruction section\n\n**Option B: Create pad.md manually**\n- Create an empty `pad.md` anywhere in your repository (where your AI agent can see)\n- Write your instructions directly in the file (no need for section structure)\n- Run `/write-pad`\n- AI will create the section structure and move your instructions to the Instruction section\n\n### 2. Investigate Current Implementation\n\n1. Run `/write-pad` to fill in the \"Current\" section\n2. Review the \"Current\" section:\n   - Verify it correctly describes the current implementation\n   - Confirm it covers all related code with file paths and line numbers\n   - Check the gap analysis against requirements\n3. If revisions needed, provide feedback and AI will update the Current section\n4. **Important**: Do NOT tell AI to proceed to the next section. Run `/write-pad` again when ready.\n\n### 3. Design New Implementation\n\n1. Run `/write-pad` to fill in the \"New\" section (recommended to refresh the session)\n2. Review the \"New\" section:\n   - Verify behaviors describe only the outermost interface (no internal implementation details)\n   - Confirm key entities are conceptual (no file/class names)\n   - Check implementation plan is specific enough that there's only one way to implement\n   - Ensure no ambiguous terms like \"or\", \"probably\", \"might\"\n3. If revisions needed, provide feedback and AI will update the New section\n4. **Important**: Do NOT tell AI to proceed to the next section. Run `/write-pad` again when ready.\n\n### 4. Break Down Tasks\n\n1. Run `/write-pad` to fill in the \"Tasks\" section (recommended to refresh the session)\n2. Review the \"Tasks\" section and provide feedback if needed\n\n### 5. Implement\n\n1. Run `/impl-pad` to implement following the Pad (recommended to refresh the session)\n2. AI will:\n   - Implement all tasks in the pad.md\n   - Verify all behaviors in the \"New\" section are satisfied\n   - Prioritize automated tests (will offer to set up testing framework if none exists)\n   - Fix and re-verify until all behaviors pass\n3. Review the implementation and provide feedback if needed\n\nAfter the implementation, you can delete your Pad completely.\n",
        "notebook/README.md": "# Notebook\n\nNotebook is a lightweight, persistent memory for AI agents.\nIt records **minimal, durable knowledge discovered through the implementation**, so the AI does not repeat past reasoning.\n\nNotebook does not describe the system in detail.\nThe implementation is the only source of truth.\n\n---\n\n## Core principle: implementation over documentation\n\nThis tool is built on a strict rule:\n\n**Never duplicate information that already exists elsewhere.**\n\n* Implementations are authoritative.\n* Comments, specifications, and other documents may exist, but they are not truth.\n* Notebook must never restate or paraphrase existing descriptions.\n\nNotebook stores **pointers**, not copies.\n\n---\n\n## What goes into Notebook\n\nEvery entry in Notebook follows the same rule:\n\n> Write only the minimum summary needed to guide future decisions,\n> and attach references to the authoritative source.\n\nNotebook entries must be:\n\n* Short and compressed\n* Focused on *why* something matters\n* Linked to where the truth lives\n\nExamples of valid entries:\n\n* A one-line explanation of a domain concept, with references to code locations\n* A brief note that a rule exists, with links to the implementation enforcing it\n* A short explanation of a design constraint, with pointers to code or guidelines\n\nIf the same information exists in:\n\n* The implementation\n* Code comments\n* Other documentation\n\nThen it must **not** be rewritten in Notebook.\n\n---\n\n## Deduplication rule\n\nNotebook must remain non-redundant.\n\nIf information written in Notebook is later found in:\n\n* Source code\n* Code comments\n* Other project documents\n\nThen the Notebook entry must be **removed** and replaced with:\n\n* A short summary (if still necessary)\n* One or more references to the authoritative source\n\nNotebook favors deletion over expansion.\n\n---\n\n## How references work\n\nReferences are mandatory.\n\nA reference may point to:\n\n* Source files and line ranges\n* Specific modules or directories\n* External documentation or specifications\n\nNotebook entries without references are considered incomplete.\n\n---\n\n## File structure\n\n```\nnotebook\n |- domain.md    ← domain notes and language pointers\n |- tech.md      ← technical decisions and constraints\n |- behavior.md  ← AI behavior and decision rules\n```\n\nNotebook files are always read together.\nNone of them override the implementation.\n\n---\n\n## File-specific guidelines\n\n### `domain.md`\n\nStores short domain notes that cannot live naturally in code.\n\n* Use the smallest possible description\n* Prefer links over explanations\n* Capture context, not behavior\n\nTypical content:\n\n* Domain terms with brief meaning and references\n* User intent summaries with links to relevant flows or logic\n* High-level relationships with pointers to code\n\n---\n\n### `tech.md`\n\nStores technical constraints and decisions that affect future changes.\n\n* State the constraint briefly\n* Explain *why* it exists in one or two lines\n* Reference the enforcing code or guideline\n\nAvoid:\n\n* Re-describing architecture\n* Listing implementation details\n\n---\n\n### `behavior.md`\n\nDefines how the AI should act.\n\n* Keep rules short and explicit\n* Prefer prohibitions and priorities\n* Do not explain behavior already encoded in tooling or configuration\n\nThis file exists to constrain action, not to justify it.\n\n---\n\n## Maintenance rules\n\nNotebook is intentionally hard to grow.\n\n* Shorter notes are better than complete ones\n* Deletion is preferred to revision\n* References age better than prose\n\nIf maintaining Notebook becomes burdensome, it is being misused.\n\n---\n\n## Design philosophy\n\nDocumentation rots.\nImplementations change.\n\nNotebook survives by being:\n\n* Minimal\n* Referential\n* Subordinate to code\n\nIts job is not to explain the system,\nbut to help the AI **find the truth faster** next time.\n"
      },
      "plugins": [
        {
          "name": "pad",
          "source": "./pad",
          "description": "A Markdown-based workflow for collaborating with AI that uses the implementation as the single source of truth, enabling spec-like, iterative development without relying on separate or fragile documentation.",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add Geb-algebra/stationery",
            "/plugin install pad@stationery"
          ]
        },
        {
          "name": "notebook",
          "source": "./notebook",
          "description": "(WIP) Lightweight, persistent memory for AI agents. Records minimal, durable knowledge discovered through implementation.",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add Geb-algebra/stationery",
            "/plugin install notebook@stationery"
          ]
        }
      ]
    }
  ]
}