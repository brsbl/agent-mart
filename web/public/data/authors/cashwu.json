{
  "author": {
    "id": "cashwu",
    "display_name": "Cash Wu",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/4278751?u=813a01ddd1884c0f84445f1fc0a4884a2d0110ac&v=4",
    "url": "https://github.com/cashwu",
    "bio": "my coding, my life",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 11,
      "total_skills": 0,
      "total_stars": 2,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "tdd-methodologies",
      "version": null,
      "description": "Two complementary Test-Driven Development approaches: Kent Beck's organic TDD and structured Test-First TDD",
      "owner_info": {
        "name": "cash"
      },
      "keywords": [],
      "repo_full_name": "cashwu/claude-code-tdd-marketplace",
      "repo_url": "https://github.com/cashwu/claude-code-tdd-marketplace",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 1,
        "pushed_at": "2025-11-02T06:12:14Z",
        "created_at": "2025-11-02T05:48:17Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 628
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/kent-beck-tdd",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/kent-beck-tdd/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/kent-beck-tdd/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 200
        },
        {
          "path": "plugins/kent-beck-tdd/README.md",
          "type": "blob",
          "size": 4933
        },
        {
          "path": "plugins/kent-beck-tdd/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/kent-beck-tdd/commands/kb-green.md",
          "type": "blob",
          "size": 7251
        },
        {
          "path": "plugins/kent-beck-tdd/commands/kb-red.md",
          "type": "blob",
          "size": 5197
        },
        {
          "path": "plugins/kent-beck-tdd/commands/kb-refactor.md",
          "type": "blob",
          "size": 7782
        },
        {
          "path": "plugins/kent-beck-tdd/commands/kb-review.md",
          "type": "blob",
          "size": 6588
        },
        {
          "path": "plugins/kent-beck-tdd/commands/kb-start.md",
          "type": "blob",
          "size": 2459
        },
        {
          "path": "plugins/test-first-tdd",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/test-first-tdd/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/test-first-tdd/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 209
        },
        {
          "path": "plugins/test-first-tdd/README.md",
          "type": "blob",
          "size": 7239
        },
        {
          "path": "plugins/test-first-tdd/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/test-first-tdd/commands/tf-green.md",
          "type": "blob",
          "size": 3572
        },
        {
          "path": "plugins/test-first-tdd/commands/tf-red.md",
          "type": "blob",
          "size": 3900
        },
        {
          "path": "plugins/test-first-tdd/commands/tf-refactor.md",
          "type": "blob",
          "size": 5624
        },
        {
          "path": "plugins/test-first-tdd/commands/tf-requirements.md",
          "type": "blob",
          "size": 1903
        },
        {
          "path": "plugins/test-first-tdd/commands/tf-testcases.md",
          "type": "blob",
          "size": 3034
        },
        {
          "path": "plugins/test-first-tdd/commands/tf-verify.md",
          "type": "blob",
          "size": 4205
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"tdd-methodologies\",\n  \"description\": \"Two complementary Test-Driven Development approaches: Kent Beck's organic TDD and structured Test-First TDD\",\n  \"owner\": {\n    \"name\": \"cash\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"kent-beck-tdd\",\n      \"source\": \"./plugins/kent-beck-tdd\",\n      \"description\": \"Kent Beck's organic TDD: Let design emerge naturally through small, iterative test cycles\"\n    },\n    {\n      \"name\": \"test-first-tdd\",\n      \"source\": \"./plugins/test-first-tdd\",\n      \"description\": \"Structured Test-First TDD: Plan-driven approach with comprehensive documentation and verification\"\n    }\n  ]\n}\n",
        "plugins/kent-beck-tdd/.claude-plugin/plugin.json": "{\n  \"name\": \"kent-beck-tdd\",\n  \"description\": \"Kent Beck's organic TDD: Let design emerge naturally through small, iterative test cycles\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"cash\"\n  }\n}\n",
        "plugins/kent-beck-tdd/README.md": "# Kent Beck TDD Plugin\n\n純粹的測試驅動開發方法，基於 Kent Beck 的經典著作《Test-Driven Development: By Example》。\n\n## 理念\n\n這個 plugin 實現了 Kent Beck 的有機 TDD 方法：\n\n- **從測試開始，不從計劃開始**：不寫詳細的需求文件，從第一個簡單的測試開始\n- **讓設計自然演進**：通過測試驅動，讓設計逐步浮現\n- **小步快跑**：快速的 Red-Green-Refactor 循環，每輪幾分鐘\n- **擁抱簡單**：用最簡單的方式讓測試通過，包括硬編碼\n- **信心驅動節奏**：根據自己的信心調整步伐大小\n\n## 核心原則\n\n### 1. 三種實作策略\n- **Fake It（假實作）**：先硬編碼返回值，用下一個測試逼出真實作\n- **Obvious Implementation（明顯實作）**：當實作很明顯時，直接寫出來\n- **Triangulation（三角測量）**：用多個測試從不同角度推導出正確實作\n\n### 2. 消除重複\n重構的核心是消除三種重複：\n- 程式碼重複\n- 測試和實作之間的重複（如硬編碼）\n- 概念上的重複（如魔術數字）\n\n### 3. 持續演進\n- 下一步不是計劃出來的，而是從經驗中浮現\n- 每個測試都教會你一些東西\n- 信任這個過程，設計會自然出現\n\n## 命令\n\n### `/kb-start` - 啟動 TDD 會話\n開始一個新的 TDD 開發會話。建立 `journey.md` 來記錄開發旅程（不是計劃）。\n\n**特點**：\n- 不寫需求文件\n- 不規劃測試案例\n- 只想第一個最簡單的測試\n\n### `/kb-red` - 寫測試（Red）\n寫下一個小測試，看它失敗。\n\n**特點**：\n- 一次只寫一個測試\n- 測試大小根據信心調整\n- 支持心理 To-Do List\n\n### `/kb-green` - 讓測試通過（Green）\n用最簡單的方式讓測試通過，可以硬編碼、作弊。\n\n**特點**：\n- 接受醜陋的程式碼\n- 速度優先（幾分鐘內完成）\n- 三種策略自由選擇\n\n### `/kb-refactor` - 重構（Refactor）\n在測試保護下，消除重複，改善設計。\n\n**特點**：\n- 小步重構，頻繁測試\n- 重構核心是消除重複\n- 測試失敗立即回退\n\n### `/kb-review` - 回顧與規劃\n完成一輪循環後，回顧學習，決定下一步。\n\n**選項**：\n- 繼續寫下一個測試\n- 暫停休息\n- 結束會話\n\n## 工作流程\n\n```\n/kb-start    ← 開始會話\n    ↓\n/kb-red      ← 寫測試 (Red)\n    ↓\n/kb-green    ← 實作 (Green)\n    ↓\n/kb-refactor ← 重構 (Refactor)\n    ↓\n/kb-review   ← 回顧\n    ↓\n循環回 /kb-red 或結束\n```\n\n## 適用場景\n\n### 適合使用 Kent Beck TDD 的情況\n\n✅ **探索性開發**\n- 問題領域不熟悉\n- 需求還不明確\n- 想通過測試探索設計\n\n✅ **學習 TDD**\n- 理解 TDD 的本質\n- 體驗測試驅動設計\n- 培養 TDD 思維\n\n✅ **個人開發**\n- 不需要大量文檔\n- 靈活調整方向\n- 快速迭代\n\n✅ **追求簡單**\n- 不想過度設計\n- 讓設計自然演進\n- YAGNI 原則\n\n### 不太適合的情況\n\n❌ **需要詳細文檔**：團隊或組織要求完整的需求和測試計劃文檔\n\n❌ **需求非常明確**：所有測試案例都很清楚，用 Test-First TDD 可能更高效\n\n❌ **合規要求**：需要追蹤需求到測試的完整性驗證\n\n## 生成的文檔\n\n在 `docs/tdd/{feature_name}/` 目錄下：\n\n- **journey.md**：TDD 開發旅程記錄\n  - 每一輪的想法、測試、實作、重構\n  - 學習和反思\n  - 非正式的心理 To-Do List\n\n## 哲學\n\nKent Beck TDD 的核心是：\n\n> \"TDD 的目的不是測試，而是思考。\"\n\n這個方法強調：\n- 🧪 測試是思考工具，不是驗證工具\n- 🌱 設計是演進的，不是規劃的\n- 🎯 簡單優先，不要過度設計\n- 💚 快速反饋，保持綠燈\n- 🔄 持續重構，消除重複\n\n## 開始使用\n\n```bash\n/kb-start\n```\n\n輸入你的功能想法，開始你的 TDD 旅程！\n\n## 實際專案範例\n\n想看看這個方法的實際應用嗎？\n\n### 🎾 Tennis Kata 範例\n**Repository**: [ai-tdd-tennis](https://github.com/cashwu/ai-tdd-tennis)\n\n這是一個使用 Kent Beck TDD 方法開發的完整 Tennis Kata 實作，展示：\n\n- ✅ **有機演進**：從最簡單的測試開始，讓設計自然浮現\n- ✅ **開發旅程**：完整的 `journey.md` 記錄每一輪的思考過程\n- ✅ **小步快跑**：可以看到 Red-Green-Refactor 的實際循環\n- ✅ **真實思考**：記錄了開發過程中的猶豫、決策和學習\n\n**適合學習**：\n- 如何從第一個測試開始\n- 如何讓設計演進而不是預先設計\n- 如何在不確定時用更小的步伐\n- 真實的 TDD 思維過程\n\n這個專案是按照本 plugin 的方法論開發的實際範例，可以直接參考！\n\n## 參考資料\n\n- Kent Beck 的書：*Test-Driven Development: By Example*\n- 核心概念：Red-Green-Refactor 循環\n- 三種策略：Fake It, Obvious Implementation, Triangulation\n\n## 授權\n\nMIT License - 詳見 [LICENSE](../../LICENSE) 文件\n\nCopyright (c) 2025 cash\n",
        "plugins/kent-beck-tdd/commands/kb-green.md": "---\ndescription: 讓測試通過（Green 階段）。用最簡單、甚至是\"錯誤\"的方式快速讓測試變綠。\n---\n\n# TDD Green - 讓測試通過（Green）\n\n用最簡單的方式讓測試通過。可以作弊、可以硬編碼、可以\"錯誤\"。\n\n**【功能名】**：{{feature_name}}\n\n## Kent Beck 的 Green 階段理念\n\n> \"快速讓測試通過，用任何手段。\"\n> \"乾淨的程式碼是目標，但先讓它能動。\"\n\n### 三種讓測試通過的策略\n\nKent Beck 在書中提出的三種策略：\n\n#### 策略 1：Fake It（假實作）\n\n**最快速的方式：回傳常數**\n\n```javascript\n// 測試\ntest('5 * 2 = 10', () => {\n  expect(multiply(5, 2)).toBe(10);\n});\n\n// 假實作：直接回傳 10！\nfunction multiply(a, b) {\n  return 10;\n}\n```\n\n**為什麼這樣做？**\n- 快速得到綠燈\n- 心理上的安全感\n- 用下一個測試來逼出真正的實作\n\n#### 策略 2：Obvious Implementation（明顯實作）\n\n**當實作很明顯時，直接寫出來**\n\n```javascript\n// 測試\ntest('加法運算', () => {\n  expect(add(2, 3)).toBe(5);\n});\n\n// 明顯實作：加法很簡單\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n**何時使用？**\n- 實作非常簡單\n- 你很有信心\n- 不需要三角測量\n\n#### 策略 3：Triangulation（三角測量）\n\n**用多個測試來推導正確實作**\n\n```javascript\n// 第 1 個測試\ntest('1 + 1 = 2', () => {\n  expect(add(1, 1)).toBe(2);\n});\n\n// 假實作\nfunction add(a, b) {\n  return 2;\n}\n\n// 第 2 個測試（三角測量）\ntest('2 + 3 = 5', () => {\n  expect(add(2, 3)).toBe(5);\n});\n\n// 被逼出真正的實作\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n**何時使用？**\n- 不確定正確的實作方式\n- 想從多個角度驗證\n- 設計還不清楚\n\n## 實作步驟\n\n### 1. 選擇策略\n\n根據你的信心程度：\n\n```\n信心很低 → Fake It（假實作）\n信心中等 → Triangulation（三角測量）\n信心很高 → Obvious Implementation（明顯實作）\n```\n\n### 2. 寫最少的程式碼\n\n**重點：最少**\n\n```javascript\n// 測試需要一個類別\ntest('Dollar 乘法', () => {\n  const five = new Dollar(5);\n  const product = five.times(2);\n  expect(product.amount).toBe(10);\n});\n\n// 最少的實作\nclass Dollar {\n  constructor(amount) {\n    this.amount = amount;\n  }\n\n  times(multiplier) {\n    return new Dollar(10); // 假實作！\n  }\n}\n```\n\n### 3. 執行測試\n\n```bash\nnpm test\n```\n\n**看到綠燈！** 🟢\n\n### 4. 更新 journey.md\n\n```markdown\n#### 🟢 Green - 讓測試通過\n\n策略：{Fake It / Obvious / Triangulation}\n\n實作說明：\n{簡述你做了什麼}\n\n程式碼位置：{檔案路徑}\n\n測試結果：✅ 通過\n\n#### 🤔 反思\n- 這個實作明顯是假的/硬編碼的嗎？\n- 需要下一個測試來逼出真正的實作嗎？\n- 有沒有重複的程式碼？\n\n#### 📝 下一步\n執行 /kb-refactor 重構\n```\n\n## Fake It 的威力\n\n### 範例：Money 的演進\n\n**第 1 輪：完全假實作**\n\n```javascript\ntest('5 * 2 = 10', () => {\n  const five = new Dollar(5);\n  expect(five.times(2).amount).toBe(10);\n});\n\nclass Dollar {\n  constructor(amount) {\n    this.amount = amount;\n  }\n  times(multiplier) {\n    return new Dollar(10); // 硬編碼！\n  }\n}\n```\n\n**第 2 輪：三角測量逼出真實作**\n\n```javascript\ntest('5 * 3 = 15', () => {\n  const five = new Dollar(5);\n  expect(five.times(3).amount).toBe(15);\n});\n\nclass Dollar {\n  times(multiplier) {\n    return new Dollar(this.amount * multiplier); // 真實作！\n  }\n}\n```\n\n## 常見的\"作弊\"技巧\n\n### 技巧 1：回傳常數\n\n```javascript\nfunction getWelcomeMessage() {\n  return \"Hello, World!\"; // 先硬編碼\n}\n```\n\n### 技巧 2：複製測試資料\n\n```javascript\n// 測試\nexpect(processData(input)).toEqual({\n  status: 'success',\n  count: 5\n});\n\n// 實作：直接回傳期待值\nfunction processData(input) {\n  return { status: 'success', count: 5 };\n}\n```\n\n### 技巧 3：最簡單的 if\n\n```javascript\n// 測試 1\ntest('even number', () => {\n  expect(classify(2)).toBe('even');\n});\n\n// 假實作\nfunction classify(n) {\n  if (n === 2) return 'even';\n}\n\n// 測試 2 會逼出真實作\ntest('another even number', () => {\n  expect(classify(4)).toBe('even');\n});\n\nfunction classify(n) {\n  return n % 2 === 0 ? 'even' : 'odd';\n}\n```\n\n## 實作的禁忌\n\nKent Beck 說明在 Green 階段應該避免的：\n\n### ❌ 不要過度設計\n\n```javascript\n// ❌ 不要這樣（太複雜）\nclass Dollar {\n  constructor(amount, currency = 'USD') {\n    this.amount = amount;\n    this.currency = currency;\n  }\n\n  times(multiplier) {\n    // 處理多幣別、匯率轉換...\n  }\n\n  // 一堆還不需要的方法\n  add() {}\n  subtract() {}\n  convert() {}\n}\n\n// ✅ 要這樣（夠用就好）\nclass Dollar {\n  constructor(amount) {\n    this.amount = amount;\n  }\n\n  times(multiplier) {\n    return new Dollar(this.amount * multiplier);\n  }\n}\n```\n\n### ❌ 不要一次實作多個測試\n\n```javascript\n// 目前只有一個測試需要 times()\n// 不要順便實作 add(), subtract()\n// 等有測試需要時再加\n```\n\n### ❌ 不要重構\n\n```javascript\n// ❌ Green 階段不要重構\n// 先讓測試通過\n// 重構留給下一步\n\n// ✅ 先這樣\nfunction calculate(x) {\n  return x * 2;\n}\n\n// 不要在這裡就改成\nconst MULTIPLIER = 2;\nfunction calculate(x) {\n  return x * MULTIPLIER;\n}\n// 重構留給 /kb-refactor\n```\n\n## 心態：接受\"醜陋\"的程式碼\n\nKent Beck 強調的心態轉變：\n\n```\n階段 1：讓它能動 (Make it work) ← 現在在這裡\n    ↓\n階段 2：讓它正確 (Make it right)\n    ↓\n階段 3：讓它快速 (Make it fast)\n```\n\n**Green 階段只追求\"能動\"**\n- 硬編碼？沒關係\n- 重複？沒關係\n- 醜陋？沒關係\n\n**下一步會改善**\n\n## 範例完整流程\n\n### 測試（失敗）\n\n```javascript\ntest('購物車初始總價為 0', () => {\n  const cart = new ShoppingCart();\n  expect(cart.getTotal()).toBe(0);\n});\n```\n\n### 實作策略選擇\n\n**信心評估**：這個很簡單，用 Obvious Implementation\n\n### 實作程式碼\n\n```javascript\n// src/shopping-cart.js\n\nclass ShoppingCart {\n  getTotal() {\n    return 0; // 最簡單的實作\n  }\n}\n\nmodule.exports = ShoppingCart;\n```\n\n### 執行測試\n\n```bash\nnpm test\n# ✅ 通過！\n```\n\n### 記錄到 journey.md\n\n```markdown\n#### 🟢 Green - 讓測試通過\n\n策略：Obvious Implementation\n\n實作說明：\n建立 ShoppingCart 類別，getTotal() 回傳 0。\n雖然是硬編碼，但足以通過目前的測試。\n\n程式碼位置：src/shopping-cart.js\n\n測試結果：✅ 通過\n\n#### 🤔 反思\n- 實作很簡單，是硬編碼\n- 下一個測試：加入商品後總價應該改變\n- 目前沒有明顯重複\n\n#### 📝 下一步\n執行 /kb-refactor 檢查是否需要重構\n```\n\n## 速度的重要性\n\nKent Beck：**Green 階段要快**\n\n**目標**：\n- 幾秒鐘到幾分鐘\n- 不要花太久時間\n- 快速得到綠燈的心理回饋\n\n**如果卡住**：\n- 寫更小的測試\n- 用更假的實作\n- 回退重來\n\n## 下一步\n\n測試通過了？執行：\n```\n/kb-refactor\n```\n\n檢查是否有重複，進行重構！\n\n## 記住 Kent Beck 的話\n\n> \"讓測試通過的技巧是暫時降低對程式碼品質的標準。\"\n> \"骯髒的程式碼是通往乾淨程式碼的墊腳石。\"\n> \"當你看到綠燈時，那是重構的信號。\"\n",
        "plugins/kent-beck-tdd/commands/kb-red.md": "---\ndescription: 寫下一個測試（Red 階段）。一次只寫一個最小的測試，讓它失敗。\n---\n\n# TDD Red - 寫下一個測試（Red）\n\n寫下一個小測試，看它失敗。\n\n**【功能名】**：{{feature_name}}\n\n## Kent Beck 的 Red 階段理念\n\n> \"寫一個小測試。讓它失敗。\"\n\n### 一次一個測試的原則\n\n**為什麼一次只寫一個？**\n- 保持專注\n- 快速反饋\n- 小步前進\n- 容易回退\n\n### 如何選擇下一個測試？\n\nKent Beck 的建議：\n\n1. **從 To-Do List 選**（心理 To-Do，不是文件）\n   - 腦中想到什麼測試，記下來\n   - 選最簡單的開始\n\n2. **從上一個測試的經驗**\n   - 上一個測試通過了，下一步自然浮現\n   - \"如果這樣，那會怎樣？\"\n\n3. **三角測量**\n   - 如果不確定實作，寫第二個類似的測試\n   - 從多個角度逼近正確實作\n\n## 寫測試的步驟\n\n### 1. 更新 journey.md\n\n```markdown\n### 第 N 輪 - {日期時間}\n\n#### 🤔 想法\n{為什麼要寫這個測試？從上一輪學到什麼？}\n\n#### 🔴 Red - 寫測試\n測試名稱：{測試名稱}\n```\n\n### 2. 寫測試程式碼\n\n**測試結構：Given-When-Then**\n\n```javascript\ntest('簡短描述測試意圖', () => {\n  // Given - 準備\n  // 【準備】：{為什麼需要這些資料？}\n  const input = testData;\n\n  // When - 執行\n  // 【執行】：{測試什麼行為？}\n  const result = functionUnderTest(input);\n\n  // Then - 驗證\n  // 【驗證】：{為什麼期待這個結果？}\n  expect(result).toBe(expected);\n});\n```\n\n### 3. 執行測試，確認失敗\n\n```bash\nnpm test\n```\n\n**必須看到失敗！**\n- 如果沒失敗，測試可能有問題\n- 失敗訊息要清楚\n\n### 4. 記錄失敗訊息\n\n在 journey.md 中：\n```markdown\n#### 失敗訊息\n```\n{實際的錯誤訊息}\n```\n\n#### 📝 下一步\n執行 /kb-green 讓測試通過\n```\n\n## 測試大小的藝術\n\n### 測試要多小？\n\nKent Beck 的答案：**取決於你的信心**\n\n**信心低（不確定）**：\n- 寫更小的測試\n- 更頻繁的反饋\n\n**信心高（很確定）**：\n- 可以寫大一點的測試\n- 跨越明顯的步驟\n\n### 範例：小測試 vs 大測試\n\n**小測試（信心低時）**：\n```javascript\n// 第 1 個測試：最基本的\ntest('5 元乘以 2 等於 10 元', () => {\n  const five = new Dollar(5);\n  const product = five.times(2);\n  expect(product.amount).toBe(10);\n});\n\n// 第 2 個測試：檢查副作用\ntest('乘法不改變原物件', () => {\n  const five = new Dollar(5);\n  five.times(2);\n  expect(five.amount).toBe(5); // 原值不變\n});\n```\n\n**大測試（信心高時）**：\n```javascript\n// 直接測試完整行為\ntest('Dollar 乘法運算', () => {\n  const five = new Dollar(5);\n  const ten = five.times(2);\n  expect(ten.amount).toBe(10);\n  expect(five.amount).toBe(5); // 也檢查副作用\n});\n```\n\n## 三角測量的時機\n\n當你不確定實作時，用三角測量：\n\n```javascript\n// 第 1 個測試\ntest('1 + 1 = 2', () => {\n  expect(add(1, 1)).toBe(2);\n});\n\n// 最簡單的假實作\nfunction add(a, b) {\n  return 2; // 硬編碼\n}\n\n// 第 2 個測試（三角測量）\ntest('2 + 3 = 5', () => {\n  expect(add(2, 3)).toBe(5);\n});\n\n// 現在必須寫真正的實作\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n## To-Do List 技巧\n\nKent Beck 建議在測試程式碼中寫註解：\n\n```javascript\ndescribe('Dollar', () => {\n  // TODO: 測試加法\n  // TODO: 測試負數\n  // TODO: 測試相等性\n\n  test('乘法', () => {\n    // 目前的測試\n  });\n});\n```\n\n或在 journey.md 中：\n\n```markdown\n## 心理 To-Do List\n- [x] 基本乘法\n- [ ] 乘法副作用\n- [ ] 加法運算\n- [ ] 負數處理\n```\n\n## 常見問題\n\n### Q: 要不要測試所有邊界情況？\n\nKent Beck：**不用一開始就全測**\n- 先從明顯的案例開始\n- 邊界情況在需要時再加入\n- 讓測試自然演進\n\n### Q: 測試名稱要多詳細？\n\nKent Beck：**描述意圖，不是實作**\n```javascript\n// ✅ 好的測試名稱\ntest('購物車加入商品後，總價增加')\n\n// ❌ 不好的測試名稱\ntest('testAddItem')\n```\n\n### Q: 要寫測試到什麼程度？\n\nKent Beck：**寫到你有信心為止**\n- 如果還不確定，再寫一個測試\n- 如果已經確定，可以跳到實作\n\n## 範例：Money 第一個測試\n\n```javascript\n// __tests__/money.test.js\n\ndescribe('Dollar', () => {\n  test('乘法運算', () => {\n    // 【準備】：建立 5 元的 Dollar 物件\n    const five = new Dollar(5);\n\n    // 【執行】：乘以 2\n    const product = five.times(2);\n\n    // 【驗證】：結果應該是 10 元\n    expect(product.amount).toBe(10);\n  });\n});\n```\n\n執行測試：\n```bash\nnpm test\n\n# 結果：失敗！\n# Error: Dollar is not defined\n```\n\n在 journey.md 記錄：\n```markdown\n### 第 1 輪\n\n#### 🔴 Red - 寫測試\n測試名稱：Dollar 乘法運算\n\n#### 失敗訊息\n```\nError: Dollar is not defined\n```\n\n#### 📝 下一步\n執行 /kb-green 建立 Dollar 類別\n```\n\n## 下一步\n\n測試寫好且失敗了？執行：\n```\n/kb-green\n```\n\n用最簡單的方式讓測試通過！\n\n## 記住\n\n> \"測試不是目的，而是思考的工具。\"\n> \"失敗的測試是進步的開始。\"\n> \"一次一小步，但要持續前進。\"\n",
        "plugins/kent-beck-tdd/commands/kb-refactor.md": "---\ndescription: 重構消除重複（Refactor 階段）。在綠燈的保護下，改善程式碼品質。\n---\n\n# TDD Refactor - 重構消除重複（Refactor）\n\n在測試通過後，消除重複、改善設計。測試是你的安全網。\n\n**【功能名】**：{{feature_name}}\n\n## Kent Beck 的 Refactor 理念\n\n> \"重構的核心是消除重複。\"\n> \"測試通過後，就是重構的時機。\"\n\n### 什麼是重複？\n\nKent Beck 定義的重複包括：\n\n#### 1. 明顯的程式碼重複\n\n```javascript\n// ❌ 重複\nfunction processOrderA(order) {\n  if (!order) throw new Error('Invalid order');\n  return order.total * 1.1;\n}\n\nfunction processOrderB(order) {\n  if (!order) throw new Error('Invalid order');\n  return order.total * 0.9;\n}\n\n// ✅ 消除重複\nfunction validateOrder(order) {\n  if (!order) throw new Error('Invalid order');\n}\n\nfunction processOrderA(order) {\n  validateOrder(order);\n  return order.total * 1.1;\n}\n```\n\n#### 2. 測試和實作之間的重複\n\n```javascript\n// 測試\ntest('5 * 2 = 10', () => {\n  expect(multiply(5, 2)).toBe(10);\n});\n\n// ❌ 實作中的重複（硬編碼）\nfunction multiply(a, b) {\n  return 10; // 和測試中的 10 重複！\n}\n\n// ✅ 消除重複（真正的實作）\nfunction multiply(a, b) {\n  return a * b;\n}\n```\n\n#### 3. 概念上的重複\n\n```javascript\n// ❌ 概念重複（魔術數字）\nfunction applyDiscount(price) {\n  return price * 0.9;\n}\n\nfunction calculateTax(price) {\n  return price * 0.1;\n}\n\n// ✅ 消除重複（提取常數）\nconst DISCOUNT_RATE = 0.9;\nconst TAX_RATE = 0.1;\n\nfunction applyDiscount(price) {\n  return price * DISCOUNT_RATE;\n}\n\nfunction calculateTax(price) {\n  return price * TAX_RATE;\n}\n```\n\n## 重構步驟\n\n### 1. 確認測試通過\n\n```bash\nnpm test\n# 必須是綠燈！🟢\n```\n\n**如果是紅燈**：\n- 不要重構\n- 先讓測試通過\n\n### 2. 識別重複或異味\n\n問自己：\n- 有重複的程式碼嗎？\n- 有硬編碼的值嗎？\n- 有不清楚的命名嗎？\n- 有太長的函式嗎？\n- 有不必要的複雜度嗎？\n\n### 3. 小步重構\n\n**一次只改一個地方**\n\n```\n改一小步 → 執行測試 → 通過\n    ↓\n改下一步 → 執行測試 → 通過\n    ↓\n...\n```\n\n### 4. 每次都執行測試\n\n**頻率**：每改一個地方就測試一次\n\n```bash\n# 改善命名\nnpm test\n\n# 提取函式\nnpm test\n\n# 提取常數\nnpm test\n```\n\n### 5. 如果測試失敗，立即回退\n\n```bash\n# 紅燈！\ngit checkout .  # 回退\n# 或手動 Undo\n```\n\n## 常見重構技巧\n\n### 技巧 1：消除硬編碼\n\n**Before**\n```javascript\nclass Dollar {\n  times(multiplier) {\n    return new Dollar(10); // 硬編碼\n  }\n}\n```\n\n**After**\n```javascript\nclass Dollar {\n  times(multiplier) {\n    return new Dollar(this.amount * multiplier);\n  }\n}\n```\n\n### 技巧 2：提取函式\n\n**Before**\n```javascript\nfunction processOrder(order) {\n  // 驗證\n  if (!order.items || order.items.length === 0) {\n    throw new Error('No items');\n  }\n\n  // 計算\n  let total = 0;\n  for (const item of order.items) {\n    total += item.price * item.quantity;\n  }\n\n  return total;\n}\n```\n\n**After**\n```javascript\nfunction processOrder(order) {\n  validateOrder(order);\n  return calculateTotal(order.items);\n}\n\nfunction validateOrder(order) {\n  if (!order.items || order.items.length === 0) {\n    throw new Error('No items');\n  }\n}\n\nfunction calculateTotal(items) {\n  let total = 0;\n  for (const item of items) {\n    total += item.price * item.quantity;\n  }\n  return total;\n}\n```\n\n### 技巧 3：提取常數\n\n**Before**\n```javascript\nfunction calculateShipping(weight) {\n  if (weight > 1000) return 100;\n  return 50;\n}\n```\n\n**After**\n```javascript\nconst HEAVY_WEIGHT_THRESHOLD = 1000;\nconst SHIPPING_HEAVY = 100;\nconst SHIPPING_STANDARD = 50;\n\nfunction calculateShipping(weight) {\n  if (weight > HEAVY_WEIGHT_THRESHOLD) {\n    return SHIPPING_HEAVY;\n  }\n  return SHIPPING_STANDARD;\n}\n```\n\n### 技巧 4：改善命名\n\n**Before**\n```javascript\nfunction calc(x) {\n  return x * 0.9;\n}\n```\n\n**After**\n```javascript\nfunction applyDiscount(price) {\n  const DISCOUNT_RATE = 0.9;\n  return price * DISCOUNT_RATE;\n}\n```\n\n### 技巧 5：簡化條件\n\n**Before**\n```javascript\nfunction canPurchase(user, product) {\n  if (user.age >= 18) {\n    if (user.balance >= product.price) {\n      if (product.stock > 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n```\n\n**After**\n```javascript\nfunction canPurchase(user, product) {\n  return user.age >= 18\n    && user.balance >= product.price\n    && product.stock > 0;\n}\n```\n\n## 何時停止重構？\n\nKent Beck 的判斷標準：\n\n### 停止的信號\n\n✅ **可以停止了**：\n- 沒有明顯的重複\n- 程式碼清楚易懂\n- 命名恰當\n- 函式簡短\n\n✅ **也可以停止**：\n- 想不到明顯的改善\n- 繼續重構的收益不大\n- 想寫下一個測試了\n\n### 不要過度重構\n\n```javascript\n// ✅ 夠好了\nfunction calculateTotal(items) {\n  let total = 0;\n  for (const item of items) {\n    total += item.price * item.quantity;\n  }\n  return total;\n}\n\n// ❌ 過度了（除非真的需要）\nclass TotalCalculator {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(items) {\n    return this.strategy.compute(items);\n  }\n}\n\nclass StandardCalculationStrategy {\n  compute(items) {\n    return items.reduce((sum, item) =>\n      sum + this.calculateItemTotal(item), 0);\n  }\n\n  calculateItemTotal(item) {\n    return new Money(item.price)\n      .multiply(item.quantity)\n      .getAmount();\n  }\n}\n// ... 太複雜了！\n```\n\n## 重構的節奏\n\nKent Beck 建議的節奏：\n\n```\n快速寫測試（幾分鐘）\n    ↓\n快速讓測試通過（幾分鐘）\n    ↓\n快速重構（幾分鐘）← 現在在這裡\n    ↓\n回到寫測試\n```\n\n**每個階段都要快**\n- 不要花太久在重構\n- 幾分鐘就好\n- 保持節奏\n\n## 更新 journey.md\n\n```markdown\n#### 🔵 Refactor - 重構\n\n重構內容：\n1. {改善項目 1}\n   - 重構前：{簡述}\n   - 重構後：{簡述}\n   - 原因：{為什麼}\n\n2. {改善項目 2}\n   ...\n\n測試狀態：✅ 持續通過\n\n#### 📝 下一步\n執行 /kb-review 回顧下一步\n```\n\n## 範例：Money 的重構\n\n### 重構前\n\n```javascript\nclass Dollar {\n  constructor(amount) {\n    this.amount = amount;\n  }\n\n  times(multiplier) {\n    return new Dollar(this.amount * multiplier);\n  }\n}\n\nclass Franc {\n  constructor(amount) {\n    this.amount = amount;\n  }\n\n  times(multiplier) {\n    return new Franc(this.amount * multiplier);\n  }\n}\n```\n\n**發現重複**：Dollar 和 Franc 幾乎一樣！\n\n### 重構步驟\n\n**Step 1：提取父類別**\n```javascript\nclass Money {\n  constructor(amount) {\n    this.amount = amount;\n  }\n}\n\nclass Dollar extends Money {\n  times(multiplier) {\n    return new Dollar(this.amount * multiplier);\n  }\n}\n\nclass Franc extends Money {\n  times(multiplier) {\n    return new Franc(this.amount * multiplier);\n  }\n}\n```\n\n測試：✅ 通過\n\n**Step 2：將 times 提升到父類別**\n```javascript\nclass Money {\n  constructor(amount) {\n    this.amount = amount;\n  }\n\n  times(multiplier) {\n    return new Money(this.amount * multiplier);\n  }\n}\n\nclass Dollar extends Money {}\nclass Franc extends Money {}\n```\n\n測試：✅ 通過\n\n**消除了重複！**\n\n## 重構的勇氣來自哪裡？\n\nKent Beck：**測試給你重構的勇氣**\n\n```\n沒有測試：\n😰 不敢改程式碼\n😰 怕改壞東西\n😰 程式碼越來越爛\n\n有測試：\n😎 隨時可以重構\n😎 測試會告訴你有沒有改壞\n😎 程式碼越來越好\n```\n\n## 下一步\n\n重構完成？執行：\n```\n/kb-review\n```\n\n回顧這一輪，計劃下一步！\n\n## 記住 Kent Beck 的話\n\n> \"重構的時機是在測試通過之後。\"\n> \"重複是設計的敵人。\"\n> \"小步重構，頻繁測試，永遠保持綠燈。\"\n> \"測試讓你有勇氣重構，重構讓程式碼保持清潔。\"\n",
        "plugins/kent-beck-tdd/commands/kb-review.md": "---\ndescription: 回顧這一輪 TDD，決定下一步。遵循 Kent Beck 的持續演進理念。\n---\n\n# TDD Review - 回顧與規劃下一步\n\n完成一輪 Red-Green-Refactor 後，停下來思考。\n\n**【功能名】**：{{feature_name}}\n\n## Kent Beck 的回顧理念\n\n> \"每完成一個測試，都要問自己：我學到了什麼？\"\n> \"下一個測試不是計劃出來的，而是從經驗中浮現的。\"\n\n## 回顧步驟\n\n### 1. 回顧這一輪\n\n在 journey.md 中更新：\n\n```markdown\n### 第 N 輪完成 - {日期時間}\n\n#### 💭 回顧與學習\n\n**這一輪做了什麼**\n{簡述這輪的測試和實作}\n\n**學到了什麼**\n- {發現 1}\n- {發現 2}\n- {驚喜或意外}\n\n**設計如何演進**\n{設計有什麼改變？}\n\n**目前的進度感覺**\n{覺得進度如何？順利還是卡住？}\n```\n\n### 2. 回顧問題清單\n\nKent Beck 建議問自己：\n\n#### 關於測試\n- ✅ 這個測試真的需要嗎？\n- ✅ 測試太大了嗎？\n- ✅ 測試太小了嗎？\n- ✅ 測試名稱清楚嗎？\n\n#### 關於實作\n- ✅ 實作還是假的嗎？\n- ✅ 需要三角測量嗎？\n- ✅ 有沒有過度設計？\n- ✅ 程式碼清楚嗎？\n\n#### 關於重構\n- ✅ 還有重複嗎？\n- ✅ 命名恰當嗎？\n- ✅ 結構清晰嗎？\n- ✅ 需要更多重構嗎？\n\n#### 關於節奏\n- ✅ 步伐太大還是太小？\n- ✅ 速度合適嗎？\n- ✅ 感覺順暢嗎？\n\n### 3. 決定下一步\n\nKent Beck：有三個選擇\n\n#### 選項 1：繼續測試（最常見）\n\n**何時選擇**：\n- 還有明顯的功能未實作\n- 想到下一個測試案例\n- 設計還在演進中\n\n**下一步**：\n```\n/kb-red\n```\n\n**在 journey.md 記錄**：\n```markdown\n#### 🎯 下一步計劃\n\n**下一個測試想法**\n{為什麼要寫這個測試？}\n\n**預期會發生什麼**\n{這個測試會逼出什麼實作？}\n\n執行 /kb-red\n```\n\n#### 選項 2：暫停休息\n\n**何時選擇**：\n- 累了\n- 卡住了\n- 需要思考\n\n**暫停建議**：\n- 寫下目前的想法\n- 記錄卡住的地方\n- 休息一下再回來\n\n**在 journey.md 記錄**：\n```markdown\n#### ⏸️ 暫停點\n\n**目前狀態**\n{進行到哪裡了}\n\n**下次回來要做什麼**\n{下一步的提示}\n\n**卡住的問題**（如果有）\n{什麼地方不確定}\n```\n\n#### 選項 3：結束這個會話\n\n**何時選擇**：\n- 目前的目標達成了\n- 找到自然的停止點\n- 功能暫時夠用了\n\n**在 journey.md 記錄**：\n```markdown\n#### 🎉 會話結束\n\n**達成的成果**\n{列出完成的功能}\n\n**目前的狀態**\n- 測試數量：{數量}\n- 測試通過率：100%\n- 程式碼品質：{評估}\n\n**未來可能的方向**\n- {可能的擴展 1}\n- {可能的擴展 2}\n```\n\n## 心理 To-Do List\n\nKent Beck 建議維護一個簡單的 To-Do List：\n\n### 在 journey.md 中\n\n```markdown\n## 心理 To-Do List\n\n### 已完成\n- [x] 基本乘法運算\n- [x] 處理負數\n\n### 下一步可能的測試\n- [ ] 加法運算\n- [ ] 相等性比較\n- [ ] 不同幣別\n\n### 設計想法\n- [ ] 考慮提取 Money 父類別\n- [ ] 可能需要 Currency 概念\n```\n\n**特點**：\n- 非正式的\n- 隨時可以改\n- 不是承諾\n- 只是提醒\n\n## 調整步伐\n\n### 如果進度太慢\n\nKent Beck：**加大步伐**\n- 寫更大的測試\n- 用 Obvious Implementation\n- 跳過明顯的步驟\n\n### 如果感到不安\n\nKent Beck：**縮小步伐**\n- 寫更小的測試\n- 用 Fake It\n- 三角測量\n- 更頻繁測試\n\n## 範例反思記錄\n\n### 順利的情況\n\n```markdown\n### 第 3 輪完成 - 2025-10-15 22:00\n\n#### 💭 回顧與學習\n\n**這一輪做了什麼**\n測試了負數乘法，確認 Dollar(-5).times(2) 得到 -10。\n\n**學到了什麼**\n- 現有實作自動支援負數\n- 不需要特殊處理\n- 乘法的數學性質自然延伸\n\n**設計如何演進**\n沒有改變，驗證了設計的穩健性。\n\n**目前的進度感覺**\n很順利！基本的乘法功能已經穩定。\n\n#### 🎯 下一步計劃\n\n**下一個測試想法**\n測試加法：Dollar(5).plus(Dollar(3)) 應該等於 Dollar(8)\n\n**預期會發生什麼**\n需要新增 plus 方法，可能會很直接。\n\n執行 /kb-red\n```\n\n### 卡住的情況\n\n```markdown\n### 第 5 輪完成 - 2025-10-15 22:30\n\n#### 💭 回顧與學習\n\n**這一輪做了什麼**\n嘗試實作不同幣別的比較。\n\n**學到了什麼**\n- 設計變複雜了\n- 不確定該怎麼處理幣別\n- 可能需要重新思考\n\n**設計如何演進**\n引入了 Currency 概念，但感覺有點勉強。\n\n**目前的進度感覺**\n有點卡住。可能步伐太大了。\n\n#### ⏸️ 暫停點\n\n**目前狀態**\nDollar 和 Franc 可以獨立運作，但比較功能還不清楚。\n\n**下次回來要做什麼**\n考慮回退到更簡單的設計，或者寫更小的測試。\n\n**卡住的問題**\n- 幣別應該是字串還是物件？\n- 需要匯率轉換嗎？\n- 設計是否過度複雜？\n\n可能需要回到更小的步伐，寫一個更簡單的測試。\n```\n\n## 長期視角\n\n### Kent Beck 的\"完成\"定義\n\nTDD **沒有**真正的完成：\n- 軟體是演進的\n- 永遠可以加新測試\n- 永遠可以改善設計\n- 永遠可以學到新東西\n\n### 知道何時停止\n\n**可以暫時停止的信號**：\n- 目前的需求滿足了\n- 設計達到一個穩定點\n- 沒有明顯的下一步\n- 想要轉向其他功能\n\n**不是因為**：\n- \"測試寫夠了\"\n- \"覆蓋率達標了\"\n- \"文件說的都做完了\"\n\n## 節奏意識\n\nKent Beck 強調 TDD 的節奏：\n\n```\n🔴 Red      → 緊張（寫測試）\n🟢 Green    → 放鬆（通過了！）\n🔵 Refactor → 改善（重構）\n💭 Review   → 回顧（現在）\n```\n\n**好的節奏**：\n- 快速循環（幾分鐘）\n- 頻繁的綠燈\n- 定期的反思\n\n**不好的節奏**：\n- 卡在紅燈太久\n- 測試寫太大\n- 實作太複雜\n- 忘記重構\n- 沒有回顧\n\n## 下一步選擇\n\n### 繼續前進\n\n```bash\n/kb-red\n```\n\n### 查看旅程記錄\n\n```bash\ncat docs/tdd/{feature_name}/journey.md\n```\n\n### 執行所有測試\n\n```bash\nnpm test\n```\n\n## 記住 Kent Beck 的話\n\n> \"TDD 不是一個目的地，而是一個旅程。\"\n> \"每個測試都教會你一些東西。\"\n> \"下一步不是計劃出來的，而是從經驗中浮現的。\"\n> \"當你不知道下一步時，寫一個你知道答案的測試。\"\n> \"信任這個過程，設計會自然演進。\"\n\n---\n\n## 完整循環\n\n你已經完成一輪完整的 TDD 循環！\n\n```\n/kb-start    ← 從這裡開始\n    ↓\n/kb-red      ← 寫測試 (Red)\n    ↓\n/kb-green    ← 實作 (Green)\n    ↓\n/kb-refactor ← 重構 (Refactor)\n    ↓\n/kb-review   ← 回顧（你在這裡）\n    ↓\n循環回 /kb-red 或結束\n```\n\n準備好下一輪了嗎？ 🚀\n",
        "plugins/kent-beck-tdd/commands/kb-start.md": "---\ndescription: 啟動新的 TDD 會話。遵循 Kent Beck 的純粹 TDD 理念，從第一個測試開始。\n---\n\n# TDD Start - 啟動 TDD 會話\n\n開始一個新的 TDD 開發會話。遵循 Kent Beck 的理念：從測試開始，讓設計演進。\n\n**【功能想法】**：{{brief_idea}}\n\n## Kent Beck 的起點\n\n> \"開始時不要想太多，從最簡單的測試開始。\"\n\n**不要做：**\n- ❌ 寫完整的需求文件\n- ❌ 規劃所有測試案例\n- ❌ 事先設計類別結構\n- ❌ 想太多細節\n\n**要做：**\n- ✅ 想一個最簡單的情境\n- ✅ 寫出第一個測試\n- ✅ 讓測試驅動設計\n\n## 開始步驟\n\n### 1. 建立開發記錄\n\n在 `docs/tdd/{feature_name}/` 建立：\n```\njourney.md  - TDD 開發旅程記錄（不是計劃）\n```\n\n### 2. 想第一個測試\n\n問自己：\n- 什麼是最簡單的使用情境？\n- 什麼是最明顯的行為？\n- 從哪裡開始最容易？\n\n**範例思考過程：**\n```\n功能想法：「計算購物車總價」\n\n❌ 不要想：\n- 需要支援優惠券\n- 需要處理多幣別\n- 需要計算稅金\n- ...\n\n✅ 只想：\n「一個商品的購物車，總價應該等於商品價格」\n\n這就是第一個測試！\n```\n\n### 3. journey.md 初始格式\n\n```markdown\n# {feature_name} TDD Journey\n\n## 開始想法\n{簡單描述要做什麼，1-2 句話}\n\n## TDD 循環記錄\n\n### 第 1 輪 - {日期時間}\n\n#### 🤔 想法\n{為什麼要寫這個測試？}\n\n#### 📝 下一步\n執行 /kb-red 寫第一個測試\n```\n\n## 心態準備\n\nKent Beck 強調的 TDD 心態：\n\n**好奇心**\n- \"如果我這樣寫測試會怎樣？\"\n- 用測試來探索問題\n\n**勇氣**\n- 敢於寫會失敗的測試\n- 敢於用最簡單的方式實作\n\n**簡單**\n- 從最簡單的開始\n- 不要過度設計\n\n**反饋**\n- 頻繁執行測試\n- 快速得到反饋\n\n## 範例：開始一個 Money 類別\n\n```markdown\n# Money TDD Journey\n\n## 開始想法\n建立一個 Money 類別，可以處理金錢運算。\n\n## TDD 循環記錄\n\n### 第 1 輪 - 2025-10-15 21:30\n\n#### 🤔 想法\n最簡單的情境：5 元乘以 2 應該等於 10 元。\n\n#### 📝 下一步\n執行 /kb-red 寫第一個測試\n```\n\n## 下一步\n\n準備好了嗎？執行：\n```\n/kb-red\n```\n\n開始寫你的第一個測試！\n\n## 記住 Kent Beck 的話\n\n> \"TDD 的目的不是測試，而是思考。\"\n> \"從最簡單的測試開始，讓複雜度自然演進。\"\n> \"如果不知道該寫什麼測試，那就寫一個你知道答案的測試。\"\n",
        "plugins/test-first-tdd/.claude-plugin/plugin.json": "{\n  \"name\": \"test-first-tdd\",\n  \"description\": \"Structured Test-First TDD: Plan-driven approach with comprehensive documentation and verification\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"cash\"\n  }\n}\n",
        "plugins/test-first-tdd/README.md": "# Test-First TDD Plugin\n\n結構化的測試優先開發方法，強調完整的規劃、文檔和驗證流程。\n\n## 理念\n\n這個 plugin 實現了有計劃、有文檔的 TDD 方法：\n\n- **從需求開始**：先整理清楚的需求文件，明確功能目標\n- **完整規劃**：預先規劃所有測試案例，包含正常、異常和邊界情況\n- **詳細文檔**：每個階段都有完整的繁體中文註解和文檔記錄\n- **驗證完整性**：確保所有規劃的測試都已實作並通過\n- **可追溯性**：從需求到測試到實作，全程可追溯\n\n## 核心原則\n\n### 1. 計劃驅動\n先規劃後執行，確保開發的完整性和系統性。\n\n### 2. 文檔完整\n- **requirements.md**：詳細的需求規格\n- **testcases.md**：完整的測試案例清單\n- **memo.md**：開發過程記錄\n- **verification-report.md**：完整性驗證報告\n\n### 3. 繁體中文註解\n所有測試和實作程式碼都必須包含完整的繁體中文註解，提高可讀性和維護性。\n\n### 4. 品質保證\n通過完整性驗證確保：\n- 所有測試案例都已實作\n- 所有測試都通過\n- 所有需求都有對應的測試\n\n## 命令\n\n### `/tf-requirements` - 需求定義\n整理功能需求，建立結構化的需求文件。\n\n**輸出**：\n- `docs/tdd/{feature_name}/requirements.md`\n\n**內容**：\n- 功能概要和目標\n- 輸入輸出規格\n- 限制條件\n- 使用範例\n\n### `/tf-testcases` - 測試案例規劃\n根據需求規劃所有測試案例。\n\n**輸出**：\n- `docs/tdd/{feature_name}/testcases.md`\n\n**分類**：\n- 正常系統測試（基本功能）\n- 異常系統測試（錯誤處理）\n- 邊界值測試（極端情況）\n\n### `/tf-red` - 建立測試（Red）\n實作會失敗的測試，明確定義功能行為。\n\n**特點**：\n- Given-When-Then 結構\n- 完整的繁體中文註解\n- 更新 memo.md 記錄進度\n\n### `/tf-green` - 實作功能（Green）\n用最簡單的方式讓測試通過。\n\n**原則**：\n- 先求能動，再求完美\n- 可以使用硬編碼或假實作\n- 標註待改善項目\n\n### `/tf-refactor` - 重構（Refactor）\n在測試保護下改善程式碼品質。\n\n**重點**：\n- 消除重複（DRY 原則）\n- 提取魔術數字為常數\n- 改善命名和可讀性\n- 小步改善，頻繁測試\n\n### `/tf-verify` - 完整性驗證\n驗證所有測試案例都已實作並通過。\n\n**檢查**：\n- 測試執行結果\n- 測試案例實作率\n- 需求覆蓋率\n- 生成驗證報告\n\n## 工作流程\n\n```\n/tf-requirements   ← 定義需求\n    ↓\n/tf-testcases      ← 規劃測試案例\n    ↓\n/tf-red            ← 建立測試 (Red)\n    ↓\n/tf-green          ← 實作功能 (Green)\n    ↓\n/tf-refactor       ← 重構 (Refactor)\n    ↓\n/tf-verify         ← 驗證完整性\n    ↓\n完成或返回補充\n```\n\n## 適用場景\n\n### 適合使用 Test-First TDD 的情況\n\n✅ **團隊協作**\n- 需要清楚的文檔供團隊成員參考\n- 多人協作開發\n- 知識傳承\n\n✅ **需求明確**\n- 需求規格清楚\n- 可以預先規劃測試案例\n- 功能範圍明確\n\n✅ **品質要求高**\n- 需要完整的測試覆蓋\n- 需要可追溯性\n- 需要驗證完整性\n\n✅ **合規需求**\n- 需要文檔化開發過程\n- 需要證明測試覆蓋率\n- 需要稽核追蹤\n\n### 不太適合的情況\n\n❌ **探索性開發**：需求還不明確，需要通過開發來探索\n\n❌ **快速原型**：只是驗證想法，不需要完整文檔\n\n❌ **個人快速開發**：不需要正式文檔，Kent Beck TDD 可能更適合\n\n## 生成的文檔\n\n在 `docs/tdd/{feature_name}/` 目錄下：\n\n- **requirements.md**：功能需求規格\n- **testcases.md**：測試案例清單\n- **memo.md**：開發過程記錄\n  - Red 階段進度\n  - Green 階段實作\n  - Refactor 階段改善\n  - 完整性驗證結果\n- **verification-report.md**：完整性驗證報告\n\n## 註解規範\n\n### 測試程式碼\n```javascript\n// 【測試目的】：說明此測試要驗證什麼\n// 【測試內容】：具體測試的處理\n// 【預期行為】：正常情況下的結果\n\n// 【測試資料準備 Given】：準備測試所需的資料\nconst input = testData;\n\n// 【執行測試 When】：呼叫要測試的功能\nconst result = functionToTest(input);\n\n// 【驗證結果 Then】：確認結果符合預期\nexpect(result).toBe(expectedValue); // 【確認】：數值正確\n```\n\n### 實作程式碼\n```javascript\n/**\n * 【功能說明】：此函式的功能\n * 【實作方針】：為什麼這樣實作\n * 【對應測試】：為了通過哪個測試\n */\nfunction functionName(param) {\n  // 【輸入驗證】：檢查輸入是否有效\n  // 【主要處理】：核心功能實作\n  // 【回傳結果】：回傳處理結果\n}\n```\n\n## 哲學\n\nTest-First TDD 的核心是：\n\n> \"計劃周全，執行確實，驗證完整。\"\n\n這個方法強調：\n- 📋 詳細規劃，減少返工\n- 📝 完整文檔，便於維護\n- ✅ 驗證完整性，確保品質\n- 🔍 可追溯性，滿足合規\n- 👥 團隊協作，知識共享\n\n## 與 Kent Beck TDD 的比較\n\n| 特性 | Test-First TDD | Kent Beck TDD |\n|------|----------------|---------------|\n| 起點 | 需求文件 | 第一個測試 |\n| 規劃 | 預先規劃所有測試 | 逐步演進 |\n| 文檔 | 詳細完整 | 簡單記錄 |\n| 適合 | 團隊、明確需求 | 個人、探索開發 |\n| 驗證 | 完整性驗證 | 主觀判斷 |\n\n## 開始使用\n\n```bash\n/tf-requirements\n```\n\n輸入功能描述，開始結構化的 TDD 開發流程！\n\n## 實際專案範例\n\n想看看這個方法的實際應用嗎？\n\n### 🎾 Tennis Kata 範例\n**Repository**: [ai-tdd-test-first-tennis](https://github.com/cashwu/ai-tdd-test-first-tennis)\n\n這是一個使用 Test-First TDD 方法開發的完整 Tennis Kata 實作，展示：\n\n- ✅ **完整規劃**：詳細的 `requirements.md` 和 `testcases.md`\n- ✅ **測試分類**：正常系統、異常系統、邊界值測試的完整規劃\n- ✅ **中文註解**：所有測試和實作都有完整的繁體中文註解\n- ✅ **開發記錄**：`memo.md` 記錄每個階段的進度和改善項目\n- ✅ **完整性驗證**：包含驗證報告，確保所有功能都已實作\n\n**適合學習**：\n- 如何撰寫結構化的需求文件\n- 如何預先規劃完整的測試案例\n- 如何使用 Given-When-Then 結構\n- 如何撰寫清楚的中文註解\n- 如何驗證開發的完整性\n\n**文檔結構**：\n```\ndocs/tdd/tennis-scoring/\n├── requirements.md         # 完整的需求規格\n├── testcases.md           # 預先規劃的測試案例\n├── memo.md                # 開發過程記錄\n└── verification-report.md # 完整性驗證報告\n```\n\n這個專案是按照本 plugin 的方法論開發的實際範例，可以直接參考！\n\n## 參考資料\n\n- TDD 核心概念：Red-Green-Refactor 循環\n- 測試分類：正常、異常、邊界值\n- DRY 原則：Don't Repeat Yourself\n- Given-When-Then 測試結構\n\n## 致謝\n\n本 plugin 的開發方法和文檔結構參考並修改自 [classmethod/tsumiki](https://github.com/classmethod/tsumiki) 專案。\n\n特別感謝 classmethod 團隊提供的優秀 TDD 方法論和實踐經驗。\n\n## 授權\n\nMIT License - 詳見 [LICENSE](../../LICENSE) 文件\n\nCopyright (c) 2025 cash\n",
        "plugins/test-first-tdd/commands/tf-green.md": "---\ndescription: 執行TDD的Green階段。實作功能讓失敗的測試通過。\n---\n\n# TDD Green階段（實作功能）\n\n執行TDD的Green階段，實作最小功能讓測試通過。\n\n**【功能名】**：{{feature_name}}\n\n## 事前準備\n\n請確認：\n- Red 階段的測試已建立\n- 測試執行後會失敗\n- memo.md 已記錄 Red 階段進度\n\n## Green 階段目標\n\n**實作最小功能讓測試通過。**\n\n**重要原則：**\n- 只要能讓測試通過就好\n- 程式碼簡潔優先，不用考慮完美\n- 複雜的最佳化留到 Refactor 階段\n- 先求能動，再求完美\n\n## 實作原則\n\n### 1. 最小實作優先\n```javascript\n// ❌ 不要一開始就寫複雜的實作\nfunction calculate(a, b) {\n  // 複雜的驗證和錯誤處理\n  // 效能最佳化\n  // 各種邊界條件處理\n  ...\n}\n\n// ✅ 先寫最簡單能通過測試的程式碼\nfunction calculate(a, b) {\n  return a + b;\n}\n```\n\n### 2. 階段性實作\n- 先讓一個測試通過\n- 再讓下一個測試通過\n- 逐步增加功能\n\n### 3. 容許暫時的解決方案\n- 可以使用硬編碼\n- 可以先忽略邊界條件\n- 重構階段再改善\n\n## 實作程式碼註解要求\n\n### 函式層級註解\n```javascript\n/**\n * 【功能說明】：此函式的功能\n * 【實作方針】：為什麼這樣實作\n * 【對應測試】：為了通過哪個測試\n *\n * @param {type} paramName - 參數說明\n * @returns {type} - 回傳值說明\n */\nfunction functionName(paramName) {\n  // 實作內容\n}\n```\n\n### 處理區塊註解\n```javascript\nfunction processData(input) {\n  // 【輸入驗證】：檢查輸入是否有效\n  if (!input) {\n    throw new Error('輸入不可為空');\n  }\n\n  // 【主要處理】：核心功能實作\n  const result = doSomething(input);\n\n  // 【回傳結果】：回傳處理結果\n  return result;\n}\n```\n\n### 變數註解\n```javascript\n// 【初始化】：設定初始值\nconst initialValue = 0;\n\n// 【計數器】：追蹤處理數量\nlet count = 0;\n```\n\n## 實作步驟\n\n1. **執行測試確認失敗**：\n   ```bash\n   npm test\n   ```\n\n2. **實作最小功能**：\n   - 只實作讓測試通過所需的程式碼\n   - 加入繁體中文註解\n   - 保持程式碼簡單\n\n3. **再次執行測試**：\n   - 確認測試通過\n   - 如果失敗，修正後重試\n\n4. **更新 memo.md**：\n   - 記錄實作內容\n   - 標註下一步改善項目\n\n## memo.md 更新格式\n\n在 memo.md 中加入 Green 階段記錄：\n\n```markdown\n## Green 階段（實作功能）\n\n### 日期\n{當前日期時間}\n\n### 實作內容\n{簡述實作了什麼功能}\n\n### 實作檔案位置\n{實作檔案路徑}\n\n### 測試結果\n- ✅ 測試 1：通過\n- ✅ 測試 2：通過\n...\n\n### 待改善項目\n{列出應該在 Refactor 階段改善的地方}\n\n### 下一步\n進入 Refactor 階段，改善程式碼品質。\n```\n\n## 常見的最小實作策略\n\n### 策略 1：硬編碼\n```javascript\n// 先用固定值通過測試\nfunction getGreeting() {\n  return \"Hello, World!\";\n}\n```\n\n### 策略 2：假實作\n```javascript\n// 先回傳符合格式的假資料\nfunction fetchData() {\n  return { status: 'success', data: [] };\n}\n```\n\n### 策略 3：簡單邏輯\n```javascript\n// 用最簡單的邏輯實作\nfunction isEven(num) {\n  return num % 2 === 0;\n}\n```\n\n## 品質檢查\n\n完成後請確認：\n- ✅ 所有測試都通過\n- ✅ 實作程式碼有繁體中文註解\n- ✅ 程式碼簡單易懂\n- ✅ 已記錄到 memo.md\n- ✅ 已標註待改善項目\n\n## 下一步\n\nGreen 階段完成後，執行：\n```\n/tf-refactor\n```\n開始改善程式碼品質（Refactor 階段）。\n",
        "plugins/test-first-tdd/commands/tf-red.md": "---\ndescription: 執行TDD的Red階段。建立會失敗的測試，明確定義應實作的功能。\n---\n\n# TDD Red階段（建立失敗的測試）\n\n執行TDD的Red階段，建立會失敗的測試。\n\n**【功能名】**：{{feature_name}}\n\n## 事前準備\n\n請確認以下文件已存在：\n```\ndocs/tdd/{feature_name}/requirements.md\ndocs/tdd/{feature_name}/testcases.md\n```\n\n## Red 階段目標\n\n建立會失敗的測試，明確定義功能的行為。\n\n**重要原則：**\n- 測試必須是會失敗的（因為功能尚未實作）\n- 測試要清楚定義預期的行為\n- 測試要容易理解和維護\n\n## 測試程式碼要求\n\n### 1. 測試檔案結構\n\n```javascript\n// 測試檔案：__tests__/{feature_name}.test.js\n\ndescribe('{feature_name}', () => {\n  // 【測試群組說明】：此群組測試的功能範圍\n\n  test('測試案例名稱', () => {\n    // 【測試目的】：說明此測試要驗證什麼\n    // 【測試內容】：具體測試的處理\n    // 【預期行為】：正常情況下的結果\n\n    // Given - 準備測試資料\n    // 【測試資料準備】：說明為何準備這些資料\n    const input = testData;\n\n    // When - 執行測試\n    // 【執行功能】：呼叫要測試的功能\n    const result = functionToTest(input);\n\n    // Then - 驗證結果\n    // 【驗證結果】：確認符合預期\n    expect(result).toBe(expectedValue);\n  });\n});\n```\n\n### 2. 繁體中文註解規範\n\n每個測試必須包含：\n\n**測試開始的註解：**\n```javascript\n// 【測試目的】：此測試要確認什麼功能\n// 【測試內容】：具體要測試的處理\n// 【預期行為】：正常情況下應該得到的結果\n```\n\n**Given（準備）階段：**\n```javascript\n// 【測試資料準備】：說明準備這些資料的原因\n// 【初始條件】：測試執行前的狀態\n```\n\n**When（執行）階段：**\n```javascript\n// 【執行功能】：說明呼叫哪個功能\n// 【處理內容】：這個功能做什麼處理\n```\n\n**Then（驗證）階段：**\n```javascript\n// 【驗證結果】：要確認什麼結果\n// 【預期值】：為什麼這是正確的結果\n```\n\n**每個 expect 的註解：**\n```javascript\nexpect(result.value).toBe(10); // 【確認】：數值正確為 10\nexpect(result.status).toBe('success'); // 【確認】：狀態為成功\n```\n\n## 實作步驟\n\n1. **選擇測試案例**：\n   - 從 testcases.md 選擇要實作的測試\n   - 建議從最簡單的正常系統測試開始\n\n2. **建立測試檔案**：\n   - 在適當位置建立測試檔案\n   - 設定測試框架和相關 import\n\n3. **撰寫測試程式碼**：\n   - 按照 Given-When-Then 結構\n   - 加入完整的繁體中文註解\n   - 確保測試會失敗（功能尚未實作）\n\n4. **執行測試**：\n   - 確認測試會失敗\n   - 失敗訊息要清楚易懂\n\n5. **記錄到 memo**：\n   - 更新 docs/tdd/{feature_name}/memo.md\n   - 記錄 Red 階段的進度\n\n## memo.md 格式\n\n```markdown\n# {feature_name} TDD 開發記錄\n\n## Red 階段（建立失敗的測試）\n\n### 日期\n{當前日期時間}\n\n### 已建立的測試\n- 測試案例 1：{測試名稱}\n- 測試案例 2：{測試名稱}\n...\n\n### 測試檔案位置\n{測試檔案路徑}\n\n### 預期的失敗\n{說明為什麼這些測試會失敗}\n\n### 下一步\n進入 Green 階段，實作功能讓測試通過。\n```\n\n## 測試執行命令\n\n根據使用的測試框架：\n\n**Jest/Vitest：**\n```bash\nnpm test\n# 或\nnpm test -- {test_file_name}\n```\n\n**其他框架：**\n請根據專案設定執行測試命令。\n\n## 品質檢查\n\n完成後請確認：\n- ✅ 測試會失敗（因為功能未實作）\n- ✅ 失敗訊息清楚易懂\n- ✅ 測試有完整的繁體中文註解\n- ✅ 測試結構清晰（Given-When-Then）\n- ✅ 已記錄到 memo.md\n\n## 下一步\n\nRed 階段完成後，執行：\n```\n/tf-green\n```\n開始實作功能讓測試通過（Green 階段）。\n",
        "plugins/test-first-tdd/commands/tf-refactor.md": "---\ndescription: 執行TDD的Refactor階段。在測試通過後，改善程式碼品質。\n---\n\n# TDD Refactor階段（程式碼重構）\n\n執行TDD的Refactor階段，改善程式碼品質。\n\n**【功能名】**：{{feature_name}}\n\n## 事前準備\n\n請確認：\n- 所有測試都通過\n- Green 階段的實作已完成\n- memo.md 已記錄待改善項目\n\n## Refactor 階段目標\n\n**在保持測試通過的前提下，改善程式碼品質。**\n\n**重要原則：**\n- 測試必須持續通過\n- 不改變功能行為\n- 小步改善，頻繁測試\n- 改善後測試，測試失敗立即回復\n\n## 改善的重點\n\n### 1. 提高可讀性\n- 改善變數和函式命名\n- 增加或改善註解\n- 簡化複雜的邏輯\n\n### 2. 消除重複（DRY原則）\n```javascript\n// ❌ 重複的程式碼\nfunction processA(data) {\n  if (!data) throw new Error('無效資料');\n  return data.value * 2;\n}\n\nfunction processB(data) {\n  if (!data) throw new Error('無效資料');\n  return data.value * 3;\n}\n\n// ✅ 提取共通邏輯\nfunction validateData(data) {\n  if (!data) throw new Error('無效資料');\n}\n\nfunction processA(data) {\n  validateData(data);\n  return data.value * 2;\n}\n\nfunction processB(data) {\n  validateData(data);\n  return data.value * 3;\n}\n```\n\n### 3. 改善程式結構\n- 單一職責原則（每個函式只做一件事）\n- 提取魔術數字為常數\n- 簡化條件判斷\n\n### 4. 改善註解品質\n```javascript\n/**\n * 【功能說明】：計算折扣後的價格\n * 【改善說明】：提取折扣計算邏輯，提高可讀性\n * 【使用情境】：結帳時計算最終價格\n *\n * @param {number} price - 原始價格\n * @param {number} discount - 折扣百分比（0-100）\n * @returns {number} - 折扣後價格\n */\nfunction calculateDiscountedPrice(price, discount) {\n  // 【參數驗證】：確保價格和折扣都是有效數值\n  if (price < 0 || discount < 0 || discount > 100) {\n    throw new Error('無效的價格或折扣');\n  }\n\n  // 【折扣計算】：套用折扣百分比\n  const discountAmount = price * (discount / 100);\n\n  // 【最終價格】：原價減去折扣金額\n  return price - discountAmount;\n}\n```\n\n## 重構步驟\n\n### 步驟 1：執行測試確認全部通過\n```bash\nnpm test\n```\n\n### 步驟 2：識別改善點\n根據 memo.md 中記錄的待改善項目：\n- 重複的程式碼\n- 不清楚的命名\n- 複雜的邏輯\n- 缺少的註解\n\n### 步驟 3：小步改善\n每次只改善一個地方：\n1. 改善一個項目\n2. 執行測試\n3. 測試通過，繼續下一個\n4. 測試失敗，立即回復\n\n### 步驟 4：更新 memo.md\n記錄重構內容\n\n## 常見重構技巧\n\n### 技巧 1：提取函式\n```javascript\n// Before\nfunction processOrder(order) {\n  // 驗證訂單\n  if (!order.items || order.items.length === 0) {\n    throw new Error('訂單沒有商品');\n  }\n\n  // 計算總價\n  let total = 0;\n  for (const item of order.items) {\n    total += item.price * item.quantity;\n  }\n\n  return total;\n}\n\n// After\nfunction processOrder(order) {\n  validateOrder(order);\n  return calculateTotal(order.items);\n}\n\nfunction validateOrder(order) {\n  // 【訂單驗證】：確保訂單包含商品\n  if (!order.items || order.items.length === 0) {\n    throw new Error('訂單沒有商品');\n  }\n}\n\nfunction calculateTotal(items) {\n  // 【總價計算】：計算所有商品的總價\n  let total = 0;\n  for (const item of items) {\n    total += item.price * item.quantity;\n  }\n  return total;\n}\n```\n\n### 技巧 2：提取常數\n```javascript\n// Before\nfunction calculateShipping(weight) {\n  if (weight > 1000) {\n    return 100;\n  }\n  return 50;\n}\n\n// After\n// 【運費常數】：定義不同重量級別的運費\nconst SHIPPING_COST = {\n  STANDARD: 50,\n  HEAVY: 100,\n};\n\n// 【重量門檻】：超過此重量視為重貨\nconst HEAVY_WEIGHT_THRESHOLD = 1000;\n\nfunction calculateShipping(weight) {\n  // 【運費計算】：根據重量決定運費\n  if (weight > HEAVY_WEIGHT_THRESHOLD) {\n    return SHIPPING_COST.HEAVY;\n  }\n  return SHIPPING_COST.STANDARD;\n}\n```\n\n### 技巧 3：簡化條件\n```javascript\n// Before\nfunction canPurchase(user, product) {\n  if (user.age >= 18) {\n    if (user.balance >= product.price) {\n      if (product.stock > 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// After\nfunction canPurchase(user, product) {\n  // 【購買條件檢查】：驗證使用者和商品狀態\n  const isAdult = user.age >= 18;\n  const hasEnoughBalance = user.balance >= product.price;\n  const isInStock = product.stock > 0;\n\n  return isAdult && hasEnoughBalance && isInStock;\n}\n```\n\n## memo.md 更新格式\n\n在 memo.md 中加入 Refactor 階段記錄：\n\n```markdown\n## Refactor 階段（程式碼重構）\n\n### 日期\n{當前日期時間}\n\n### 改善內容\n1. {改善項目 1}\n   - 改善前：{描述}\n   - 改善後：{描述}\n   - 原因：{為什麼要這樣改善}\n\n2. {改善項目 2}\n   ...\n\n### 測試結果\n✅ 所有測試持續通過\n\n### 程式碼品質評估\n- 可讀性：{評估}\n- 維護性：{評估}\n- 效能：{評估}\n\n### 下一步\n進入完整性驗證階段。\n```\n\n## 品質檢查\n\n完成後請確認：\n- ✅ 所有測試都通過\n- ✅ 程式碼更容易理解\n- ✅ 減少了重複\n- ✅ 註解更完整清楚\n- ✅ 已記錄改善內容到 memo.md\n\n## 注意事項\n\n**禁止的行為：**\n- ❌ 改變功能行為\n- ❌ 新增功能\n- ❌ 一次改太多\n- ❌ 不執行測試就繼續改\n\n**允許的行為：**\n- ✅ 改善命名\n- ✅ 提取函式\n- ✅ 提取常數\n- ✅ 增加註解\n- ✅ 簡化邏輯\n\n## 下一步\n\nRefactor 階段完成後，執行：\n```\n/tf-verify\n```\n驗證開發完整性。\n",
        "plugins/test-first-tdd/commands/tf-requirements.md": "---\ndescription: 進行TDD開發的需求整理。明確化功能需求，為測試驅動開發做準備。\n---\n\n# TDD需求定義・功能規格的整理\n\n開始TDD開發。請針對以下功能整理需求：\n\n**【功能名】**：{{feature_name}}\n\n## 使用說明\n\n請提供功能描述，我會幫您整理成結構化的需求文件。\n\n**提供資訊範例：**\n- 功能的目的和解決的問題\n- 預期的輸入和輸出\n- 使用情境和範例\n- 需要注意的限制條件\n\n## TDD用需求整理格式\n\n### 1. 功能的概要\n\n- **功能描述**：簡潔說明這是什麼功能\n- **解決的問題**：這個功能解決什麼問題\n- **目標使用者**：誰會使用這個功能\n- **使用情境**：在什麼情況下會使用\n\n### 2. 輸入・輸出的規格\n\n- **輸入參數**：\n  - 參數名稱、型別、是否必填\n  - 有效範圍或限制\n  - 預設值（如果有）\n\n- **輸出值**：\n  - 回傳型別和格式\n  - 輸出範例\n  - 特殊情況的輸出\n\n- **資料處理流程**：\n  - 簡要說明資料如何處理\n\n### 3. 限制條件\n\n- **效能需求**：\n  - 回應時間、處理量等要求\n\n- **技術限制**：\n  - 使用的語言、框架\n  - 相容性要求\n\n- **資料限制**：\n  - 資料大小限制\n  - 格式要求\n\n### 4. 使用範例\n\n- **基本使用範例**：\n  - 典型的使用案例\n  - 預期的正常行為\n\n- **邊界案例**：\n  - 極端值的處理\n  - 空值或特殊輸入\n\n- **錯誤案例**：\n  - 不正確輸入的處理\n  - 預期的錯誤訊息\n\n## 輸出格式\n\n整理完成後，將需求文件儲存至：\n```\ndocs/tdd/{feature_name}/requirements.md\n```\n\n## 品質檢查\n\n整理完成後，請確認：\n- ✅ 需求描述清楚明確\n- ✅ 輸入輸出規格完整\n- ✅ 使用範例具體實用\n- ✅ 限制條件明確\n\n## 下一步\n\n需求整理完成後，請執行：\n```\n/tf-testcases\n```\n開始測試案例的規劃。\n",
        "plugins/test-first-tdd/commands/tf-testcases.md": "---\ndescription: 進行TDD開發的測試案例規劃。根據需求定義規劃完整的測試案例。\n---\n\n# TDD測試案例的規劃\n\n根據需求文件，規劃涵蓋完整的測試案例。\n\n**【功能名】**：{{feature_name}}\n\n## 事前準備\n\n請先確認需求文件已存在：\n```\ndocs/tdd/{feature_name}/requirements.md\n```\n\n## 測試案例分類\n\n### 1. 正常系統測試案例（基本功能）\n\n記載格式：\n- **測試名稱**：清楚描述測試目的\n- **測試內容**：要驗證什麼功能\n- **輸入值**：具體的測試資料\n- **預期結果**：應該得到什麼輸出\n- **測試目的**：為什麼需要這個測試\n\n### 2. 異常系統測試案例（錯誤處理）\n\n記載格式：\n- **測試名稱**：描述錯誤情境\n- **測試內容**：要驗證的錯誤處理\n- **輸入值**：不正確或異常的資料\n- **預期結果**：預期的錯誤訊息或例外\n- **測試目的**：確保適當的錯誤處理\n\n### 3. 邊界值測試案例（極端情況）\n\n記載格式：\n- **測試名稱**：描述邊界條件\n- **測試內容**：要驗證的邊界行為\n- **輸入值**：最小值、最大值、空值等\n- **預期結果**：邊界情況的正確處理\n- **測試目的**：確保極端情況的穩定性\n\n## 技術選擇\n\n請指定測試使用的技術：\n- **程式語言**：如 JavaScript、TypeScript、Python 等\n- **測試框架**：如 Jest、Vitest、pytest 等\n- **測試類型**：單元測試、整合測試等\n\n## 測試程式碼註解要求\n\n測試程式碼必須包含繁體中文註解：\n\n### 測試開始的註解\n```javascript\ndescribe('功能名稱', () => {\n  test('測試案例名稱', () => {\n    // 【測試目的】：說明此測試要驗證什麼\n    // 【測試內容】：具體測試的處理\n    // 【預期行為】：正常情況下的結果\n  });\n});\n```\n\n### Given-When-Then 註解\n```javascript\n// 【測試資料準備 Given】：準備測試所需的資料\nconst input = testData;\n\n// 【執行測試 When】：呼叫要測試的功能\nconst result = functionToTest(input);\n\n// 【驗證結果 Then】：確認結果符合預期\nexpect(result).toBe(expectedValue);\n```\n\n### 驗證點的註解\n```javascript\nexpect(result.value).toBe(10); // 【確認】：數值正確為 10\nexpect(result.status).toBe('success'); // 【確認】：狀態為成功\nexpect(result.errors).toHaveLength(0); // 【確認】：沒有錯誤\n```\n\n## 輸出格式\n\n規劃完成後，將測試案例清單儲存至：\n```\ndocs/tdd/{feature_name}/testcases.md\n```\n\n測試案例文件應包含：\n1. 測試案例總覽（數量統計）\n2. 正常系統測試案例清單\n3. 異常系統測試案例清單\n4. 邊界值測試案例清單\n5. 技術選擇說明\n\n## 品質檢查\n\n規劃完成後，請確認：\n- ✅ 涵蓋所有需求項目\n- ✅ 測試案例分類完整\n- ✅ 每個測試案例都有明確的預期結果\n- ✅ 技術選擇明確\n\n## 下一步\n\n測試案例規劃完成後，請執行：\n```\n/tf-red\n```\n開始建立失敗的測試（Red 階段）。\n",
        "plugins/test-first-tdd/commands/tf-verify.md": "---\ndescription: 驗證TDD開發的完整性。確認所有測試案例都已實作且通過。\n---\n\n# TDD 開發完整性驗證\n\n驗證TDD開發是否完整，確保所有規劃的測試案例都已實作並通過。\n\n**【功能名】**：{{feature_name}}\n\n## 驗證目的\n\n確認：\n1. 所有規劃的測試案例都已實作\n2. 所有測試都通過\n3. 功能開發完整\n\n## 驗證檔案\n\n需要檢查的文件：\n```\ndocs/tdd/{feature_name}/requirements.md\ndocs/tdd/{feature_name}/testcases.md\ndocs/tdd/{feature_name}/memo.md\n```\n\n需要檢查的程式碼：\n- 測試檔案（如 `__tests__/*.test.js`）\n- 實作檔案（如 `src/*.js`）\n\n## 驗證步驟\n\n### 1. 執行所有測試\n\n```bash\nnpm test\n```\n\n確認：\n- ✅ 所有測試都通過\n- ✅ 沒有被跳過的測試\n- ✅ 測試覆蓋率合理\n\n### 2. 比對測試案例清單\n\n從 `testcases.md` 讀取規劃的測試案例，檢查：\n- 規劃了幾個測試案例\n- 實際實作了幾個\n- 哪些測試案例尚未實作\n\n### 3. 檢查需求覆蓋\n\n從 `requirements.md` 檢查：\n- 所有輸入參數都有測試\n- 所有輸出格式都有驗證\n- 錯誤處理都有測試\n- 邊界條件都有涵蓋\n\n## 驗證報告格式\n\n```markdown\n# {feature_name} TDD 開發完整性驗證報告\n\n## 測試執行結果\n- 測試總數：{數量}\n- 通過：{數量}\n- 失敗：{數量}\n- 跳過：{數量}\n- 成功率：{百分比}%\n\n## 測試案例實作狀況\n\n### 規劃的測試案例\n- 正常系統：{數量} 個\n- 異常系統：{數量} 個\n- 邊界值：{數量} 個\n- 總計：{數量} 個\n\n### 已實作的測試案例\n- 正常系統：{數量} 個\n- 異常系統：{數量} 個\n- 邊界值：{數量} 個\n- 總計：{數量} 個\n\n### 實作率\n- 整體實作率：{百分比}%\n\n## 需求覆蓋狀況\n\n### 已覆蓋的需求\n- {需求項目 1}：✅ 已測試\n- {需求項目 2}：✅ 已測試\n...\n\n### 未覆蓋的需求\n- {需求項目 X}：❌ 尚未測試\n...\n\n## 完整性判定\n\n{✅ 完整 / ⚠️ 不完整}\n\n### 判定理由\n{說明為什麼判定為完整或不完整}\n\n## 建議\n\n{如果不完整，列出建議的改善項目}\n```\n\n## 更新 memo.md\n\n在 memo.md 中加入驗證結果：\n\n```markdown\n## 完整性驗證\n\n### 日期\n{當前日期時間}\n\n### 驗證結果\n{完整 / 不完整}\n\n### 測試統計\n- 測試總數：{數量}\n- 成功率：{百分比}%\n- 實作率：{百分比}%\n\n### 需求覆蓋\n- 已覆蓋：{數量} 項\n- 未覆蓋：{數量} 項\n\n### 結論\n{總結開發成果}\n\n### 後續建議\n{如有需要，列出後續改善項目}\n```\n\n## 判定基準\n\n### ✅ 完整（開發完成）\n\n滿足所有條件：\n- 所有測試都通過（100%）\n- 實作率達 100%（或合理說明未實作的原因）\n- 需求覆蓋率達 100%\n- 程式碼品質良好\n\n### ⚠️ 不完整（需要繼續開發）\n\n有以下任一情況：\n- 有測試失敗\n- 重要測試案例未實作\n- 重要需求未覆蓋\n- 程式碼品質有明顯問題\n\n## 驗證完成後的行動\n\n### 如果驗證通過（完整）\n\n1. 在 memo.md 中標記為完成\n2. 整理開發記錄\n3. 結束此功能的 TDD 開發\n\n### 如果驗證未通過（不完整）\n\n1. 在 memo.md 中記錄缺失項目\n2. 返回相應階段補充：\n   - 缺測試案例 → 返回 `/tf-red`\n   - 測試未通過 → 返回 `/tf-green`\n   - 程式碼品質 → 返回 `/tf-refactor`\n\n## 輸出範例\n\n### 完整的情況\n\n```\n✅ TDD 開發完整性驗證：通過\n\n📊 測試統計\n- 測試總數：15 個\n- 全部通過\n- 成功率：100%\n- 實作率：100%\n\n📋 需求覆蓋\n- 全部需求項目都已測試\n- 覆蓋率：100%\n\n🎉 功能開發完成！\n```\n\n### 不完整的情況\n\n```\n⚠️ TDD 開發完整性驗證：未通過\n\n📊 測試統計\n- 測試總數：12 個\n- 通過：10 個\n- 失敗：2 個\n- 成功率：83.3%\n- 實作率：80%\n\n❌ 未實作的測試案例\n1. 邊界值測試：空陣列的處理\n2. 錯誤測試：無效輸入的錯誤訊息\n3. 邊界值測試：最大值超過限制\n\n📝 建議\n請返回 Red 階段，補充缺失的測試案例。\n```\n\n## 下一步\n\n驗證完成後：\n- 如果完整：功能開發結束，可以開始下一個功能\n- 如果不完整：根據驗證報告返回相應階段繼續開發\n"
      },
      "plugins": [
        {
          "name": "kent-beck-tdd",
          "source": "./plugins/kent-beck-tdd",
          "description": "Kent Beck's organic TDD: Let design emerge naturally through small, iterative test cycles",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add cashwu/claude-code-tdd-marketplace",
            "/plugin install kent-beck-tdd@tdd-methodologies"
          ]
        },
        {
          "name": "test-first-tdd",
          "source": "./plugins/test-first-tdd",
          "description": "Structured Test-First TDD: Plan-driven approach with comprehensive documentation and verification",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add cashwu/claude-code-tdd-marketplace",
            "/plugin install test-first-tdd@tdd-methodologies"
          ]
        }
      ]
    }
  ]
}