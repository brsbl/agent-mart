{
  "author": {
    "id": "undoio",
    "display_name": "Undo",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/41469639?v=4",
    "url": "https://github.com/undoio",
    "bio": "Making software reliable",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 1,
      "total_stars": 1,
      "total_forks": 6
    }
  },
  "marketplaces": [
    {
      "name": "undo",
      "version": "1.0.0",
      "description": "Claude Code plugins for UDB and debugging workflows",
      "owner_info": {
        "name": "Undo",
        "email": "support@undo.io"
      },
      "keywords": [],
      "repo_full_name": "undoio/addons",
      "repo_url": "https://github.com/undoio/addons",
      "repo_description": "Addons for UDB.",
      "homepage": "https://undo.io/udb",
      "signals": {
        "stars": 1,
        "forks": 6,
        "pushed_at": "2026-01-21T11:55:27Z",
        "created_at": "2019-08-16T12:22:17Z",
        "license": "BSD-3-Clause"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 561
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 682
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2687
        },
        {
          "path": "automatic_symbol_loading",
          "type": "tree",
          "size": null
        },
        {
          "path": "automatic_symbol_loading/README.md",
          "type": "blob",
          "size": 1360
        },
        {
          "path": "backtrace_with_time",
          "type": "tree",
          "size": null
        },
        {
          "path": "backtrace_with_time/README.md",
          "type": "blob",
          "size": 136
        },
        {
          "path": "completion",
          "type": "tree",
          "size": null
        },
        {
          "path": "completion/README.md",
          "type": "blob",
          "size": 202
        },
        {
          "path": "count_calls",
          "type": "tree",
          "size": null
        },
        {
          "path": "count_calls/README.md",
          "type": "blob",
          "size": 138
        },
        {
          "path": "explain",
          "type": "tree",
          "size": null
        },
        {
          "path": "explain/README.md",
          "type": "blob",
          "size": 3256
        },
        {
          "path": "explain/claude_code_plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "explain/claude_code_plugin/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "explain/claude_code_plugin/commands/configure_undo_path.md",
          "type": "blob",
          "size": 752
        },
        {
          "path": "explain/claude_code_plugin/commands/debug.md",
          "type": "blob",
          "size": 1157
        },
        {
          "path": "explain/claude_code_plugin/commands/record.md",
          "type": "blob",
          "size": 979
        },
        {
          "path": "explain/claude_code_plugin/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "explain/claude_code_plugin/hooks/check_debugger_usage.sh",
          "type": "blob",
          "size": 1809
        },
        {
          "path": "follow_fork",
          "type": "tree",
          "size": null
        },
        {
          "path": "follow_fork/README.md",
          "type": "blob",
          "size": 794
        },
        {
          "path": "gtest_annotations",
          "type": "tree",
          "size": null
        },
        {
          "path": "gtest_annotations/README.md",
          "type": "blob",
          "size": 2116
        },
        {
          "path": "k8s_live_recorder",
          "type": "tree",
          "size": null
        },
        {
          "path": "k8s_live_recorder/README.md",
          "type": "blob",
          "size": 3540
        },
        {
          "path": "load_debug_symbols",
          "type": "tree",
          "size": null
        },
        {
          "path": "load_debug_symbols/README.md",
          "type": "blob",
          "size": 1174
        },
        {
          "path": "reconstruct_file",
          "type": "tree",
          "size": null
        },
        {
          "path": "reconstruct_file/README.md",
          "type": "blob",
          "size": 1590
        },
        {
          "path": "regs_every_bb",
          "type": "tree",
          "size": null
        },
        {
          "path": "regs_every_bb/README.md",
          "type": "blob",
          "size": 256
        },
        {
          "path": "relative_wallclock",
          "type": "tree",
          "size": null
        },
        {
          "path": "relative_wallclock/README.md",
          "type": "blob",
          "size": 194
        },
        {
          "path": "reverse_step_map",
          "type": "tree",
          "size": null
        },
        {
          "path": "reverse_step_map/README.md",
          "type": "blob",
          "size": 958
        },
        {
          "path": "sample_functions",
          "type": "tree",
          "size": null
        },
        {
          "path": "sample_functions/README.md",
          "type": "blob",
          "size": 2242
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/debugging-with-undo",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/debugging-with-undo/SKILL.md",
          "type": "blob",
          "size": 2062
        },
        {
          "path": "systemc_trace",
          "type": "tree",
          "size": null
        },
        {
          "path": "systemc_trace/README.md",
          "type": "blob",
          "size": 2327
        },
        {
          "path": "what_map",
          "type": "tree",
          "size": null
        },
        {
          "path": "what_map/README.md",
          "type": "blob",
          "size": 733
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"undo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude Code plugins for UDB and debugging workflows\",\n  \"owner\": {\n    \"name\": \"Undo\",\n    \"email\": \"support@undo.io\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"undo\",\n      \"description\": \"Debug and analyze Undo recordings using AI-powered queries\",\n      \"source\": \"./\",\n      \"category\": \"development\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Undo\",\n        \"email\": \"support@undo.io\"\n      }\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"undo\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Debug and analyze Undo recordings using AI-powered queries\",\n  \"author\": {\n    \"name\": \"Undo\",\n    \"email\": \"support@undo.io\"\n  },\n  \"homepage\": \"https://github.com/undoio/addons/tree/master/explain\",\n  \"mcpServers\": {\n    \"undo-debugger\": {\n      \"command\": \"${CLAUDE_PLUGIN_ROOT}/explain/claude_code_plugin/run.sh\",\n      \"args\": []\n    }\n  },\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/explain/claude_code_plugin/hooks/check_debugger_usage.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "README.md": "[![Build status](https://api.travis-ci.com/undoio/addons.svg?master)](https://travis-ci.com/undoio/addons)\n\nUDB Addons\n==========\n\nA collection of add-on scripts and configuration to enhance the functionality\nprovided by [UDB](http://undo.io/) (and, in some cases, also vanilla GDB).\n\n\nSummary\n-------\n\n[**Automatic symbol loading**](automatic_symbol_loading/README.md)\nLoads all debug files in the specified directory.\n\n[**Backtrace with time**](backtrace_with_time/README.md)\nAdds a ubt command which adds basic block counts to frames within a backtrace.\n\n[**Completion**](completion/README.md)\nAdds completion of udb command line parameters in bash.\n\n[**Count calls**](count_calls/README.md)\nCounts how many times each function was called in the specificed period of time.\n\n[**Follow fork**](follow_fork/README.md)\nAllows live-record to record both parent and child after `fork()` has been called.\n\n[**LiveRecorder in Kubernetes**](k8s_live_recorder/README.md)\nA demo of how to record an application in a Kubernetes pod using live-record.\n\n[**Load Debug Symbols**](load_debug_symbols/README.md)\nLoads debug symbols by parsing the relevant section addresses.\n\n[**Reconstruct file**](reconstruct_file/README.md)\nReconstructs the content of a file by analysing reads on the execution history\nof a debugged program or LiveRecorder recording.\n\n[**Regs every bb**](regs_every_bb/README.md)\nPrints the values of all the registers at every basic block within a range.\n\n[**Relative wallclock**](relative_wallclock/README.md)\nPrints an approximate wallclock time relative to the start of recording.\n\n[**Reverse step map**](reverse_step_map/README.md)\nExecutes a reverse-step-instruction, prints the instruction and, for each\nregister used in it, prints which map is involved.\n\n[**Sample functions**](sample_functions/README.md)\nSamples the number of times the program is in each function.\n\n[**What map**](what_map/README.md)\nLooks up a variable or address within the maps of the debuggee.\n\n[**Google Test annotations**](gtest_annotations/README.md)\nExample Google Test integration to annotate recordings with test status.\n\nDevelopment\n-----------\n\nFeel free to make a pull request against the project!\n\nThe [`master`](https://github.com/undoio/addons/tree/dev) branch supports the\nlatest release of UDB.\nThe [`dev`](https://github.com/undoio/addons/tree/dev) branch contains code\nmeant for the next future release of UDB.\n\n### Linting\n\nPython code is linted using [pre-commit](https://pre-commit.com/) with black, pylint, and mypy.\n\nSetup (one-time):\n```bash\npip install pre-commit\npre-commit install  # Optional: auto-run on git commit\n```\n\nRun linters:\n```bash\npre-commit run --all-files\n```\n",
        "automatic_symbol_loading/README.md": "# Load Debug Symbols\n\nA common practice amongst UDB users is to produce binaries compiled with debug symbols and\nthen use a tool such as `objcopy` to strip it of symbols, producing a `.debug` symbol file\nand a stripped binary. This stripped binary is then shipped as part of their product without\nthe .debug file being present.\n\nWhen we produce a recording of an application that has been generated on binaries stripped\nof symbols, the resulting recording file will also not contain debug symbols. In order to\nretrospectively add the debug symbols to the recording, the user is required to use a rather\ncomplex procedure to be able to load all symbols files.\nThis script automates the symbol loading completely.\n\nThe script will traverse the whole directory structure, the user is just asked for the base\ndirectory.\n\n## Usage\n```\nload-all-symbols PATHTOBASEDIR\n```\n\nBefore using the script it must be loaded in to the debugger:\n```\nsource PATHTOADDONS/automatic_symbol_loading/automatic_symbol_loading.py\n```\n\n## Examples\n\n`load-all-symbols /data/mci/` : for each library loaded in UDB looks for the symbol file\n(by taking into consideration all and only the files ending in `.debug`) and, if the Build-IDs\nmatch, it loads the symbol-file.\n\nNote that the argument to `load-debug-symbols` needs to be a valid directory. If not\nthe script will exit immediately.\n",
        "backtrace_with_time/README.md": "Backtrace with time\n===================\n\nAdds a ubt command which adds basic block counts to frames within a backtrace.\n\n    Usage: ubt\n",
        "completion/README.md": "Completion\n==========\n\nAdds completion of udb command line parameters in bash.  \nTo use, source _udb from your .bashrc.  \ni.e. Add this line to your .bashrc:  \nsource PATH_TO_UDB_ADDONS/completion/_udb\n",
        "count_calls/README.md": "Count calls\n===========\n\nCounts how many times a function was called in a recording.\n\n\tusage:\n\t./count_calls RECORDING_FILE FUNCTION_NAME\n",
        "explain/README.md": "Explain Extension\n=================\n\nThis directory contains an [extension](https://docs.undo.io/Addons.html) that integrates AI coding\nagent support into UDB, the time travel debugger of the [Undo Suite](http://undo.io/).\n\nFor the impatient: Add `explain` to your UDB session using the `extend explain` command, then get\nstarted asking questions using the `explain` command (or via the `uexperimental mcp serve` command\nif you don't have a supported CLI coding agent).\n\nIf you don't have an Undo license to test with you can download a [free\ntrial](https://undo.io/udb-free-trial/).\n\nWhat is it?\n-----------\n\nExplain extends a time travel debugger (a debugger that can capture and query the entire history of\na program at machine-instruction precision) with the ability to ask questions about the program's\ndynamic behaviour. These might be as simple as \"What has gone wrong in this program?\" to root cause\na crash, or more complex (and iterative) questioning to navigate the semantics of a program.\n\nFor example, you could **Debug a cache corruption** that lead to a program crash:\n\n[![Debug a cache corruption using\nAI](https://img.youtube.com/vi/p416JIurLiU/0.jpg)](https://www.youtube.com/watch?v=p416JIurLiU)\n\nOr you could **Ask questions about a game you recorded**, using AI to navigate the semantics of the\nprogram and its dynamic behaviour during the particular session you recorded:\n\n[![Ask questions about a game of\nDoom](https://img.youtube.com/vi/dmH7owoctC4/0.jpg)](https://www.youtube.com/watch?v=dmH7owoctC4)\n\nFor more details about `explain`, you can refer to [our\nblogpost](https://undo.io/resources/time-travel-ai-code-assistant/) about it.\n\nWhat can I ask it?\n------------------\n\nYou can ask it anything you want about the state of the recorded program. Good questions involve\nquestions about the current state of the recorded program or about its overall behaviour.\n\n> [!NOTE]\n> `explain` is primarily designed for *querying* program history and the tools that it exposes to\n> the AI coding agent are optimised for this. As a result it does not have access to all debugger\n> functionality - it isn't designed to replace your IDE interface or the debugger's own command\n> line, so requests like \"set a breakpoint\" are not supported.\n\nRequirements\n------------\n\nFor full integration into the UDB debugger you must install a supported, CLI-based coding\nagent. This must be one of:\n\n * [Claude Code](https://www.anthropic.com/claude-code)\n * [Amp](https://ampcode.com/)\n * [Codex CLI](https://developers.openai.com/codex/cli/)\n * [Copilot CLI](https://docs.github.com/en/copilot/concepts/agents/about-copilot-cli)\n\nIf the extension detects an installation of one of these it will attempt to use it to answer your\nquestions about the program's recorded history.\n\nTo use UDB from other coding agents, start the included MCP server and connect from your preferred\nagent. To start the MCP server, use the command `uexperimental mcp serve` and configure your coding\nagent to connect.\n\n> [!CAUTION]\n>\n> Use of the MCP server from the command line of Undo's [Time Travel Debug for C/C++\n> extension](https://marketplace.visualstudio.com/items?itemName=Undo.udb) for VS Code is currently\n> not supported, this will be improved in future release.\n",
        "explain/claude_code_plugin/commands/configure_undo_path.md": "# Configure Undo Path\n\nConfigure the path to the Undo Suite installation or UDB executable.\n\n## Arguments\n\nArguments provided: `$ARGUMENTS`\n\n## What to do\n\n1. **Extract the path** from the user's message or $ARGUMENTS\n   - If the user wants to clear the path, pass `None`\n   - If unclear, ask: \"What is the full path to your UDB executable or Undo installation directory?\"\n\n2. **Call the MCP tool**\n   - To set: `configure_undo_path(path=\"/path/to/undo\")`\n   - To clear: `configure_undo_path(path=None)`\n\nThe tool accepts:\n- Path to `udb` or `live-record` executable\n- Path to Undo Suite installation directory\n- `None` to clear the configuration\n\nAfter successful configuration, any previously failed operations due to missing Undo tools should work.\n",
        "explain/claude_code_plugin/commands/debug.md": "# Debug Undo Recording\n\nHelp the user debug a program using an Undo recording.\n\n## IMPORTANT: Do not open recordings directly\n\nUndo recordings are opaque binary files. You MUST NOT try to open, read, or parse recording files directly. If you see a `.undo` file, always use the MCP tools to investigate it.\n\n## Recording Path\n\nArguments provided: `$ARGUMENTS`\n\nIf the user mentioned a recording file (which will appear in $ARGUMENTS), use that path.\n\nIf no recording path was provided:\n- Search for .undo files in the current directory\n- Check previous messages in the conversation\n- Ask the user for the recording path\n\n## What to do\n\nUse the available MCP tools from the `undo-debugger` MCP server to investigate the recording.\n\nThe MCP server instructions provide comprehensive guidance on reverse debugging techniques.\nCommon starting points:\n- Use `backtrace` to understand the current program state\n- Use `last_value` to trace how variables were set\n- Use `ubookmark` to mark interesting points in time\n- Use time-travel debugging to work backwards from the failure\n\nTrust the tool docstrings and the MCP instructions to guide your debugging approach.\n",
        "explain/claude_code_plugin/commands/record.md": "# Record Program Execution\n\nCreate an Undo recording of a program execution using `live-record`.\n\n## Arguments\n\nArguments provided: `$ARGUMENTS`\n\n## What to do\n\n1. **Extract the command to record** from the user's message or $ARGUMENTS\n   - If unclear, ask: \"What is the full command you want to record (including any arguments)?\"\n\n2. **Determine the recording path**\n   - If the user specifies a path, use it\n   - Otherwise, suggest a sensible default based on the program name (e.g., `./my_program.undo`)\n\n3. **Call the MCP tool**\n   - `record(command=\"./program arg1 arg2\", recording=\"./program.undo\")`\n   - Or with a list: `record(command=[\"./program\", \"arg1\", \"arg2\"], recording=\"./program.undo\")`\n\n## Example\n\n**User:** \"Record ./my_app --verbose\"\n**You do:** Call `record(command=\"./my_app --verbose\", recording=\"./my_app.undo\")`\n\nThe tool will handle execution and provide guidance on next steps. After successful recording, the user can use `/undo:debug` to analyze it.\n",
        "explain/claude_code_plugin/hooks/check_debugger_usage.sh": "#!/bin/bash\n#\n# Block direct invocation of `udb`, `live-record`, `undo`, or opening `.undo` files.\n# These should only be used via the plugin's MCP tools.\n\nset -euo pipefail\n\n# Check if `jq` is available; if not, skip checks and allow the command.\nif ! command -v jq &> /dev/null; then\n    exit 0\nfi\n\n# Read JSON input from stdin.\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command // \"\"')\n\n# Block direct `udb` invocation.\nif echo \"$command\" | grep -qE '\\budb\\b'; then\n    echo '{\"hookSpecificOutput\":{\"hookEventName\":\"PreToolUse\",\"permissionDecision\":\"deny\",\"permissionDecisionReason\":\"Use the /debug command or MCP debugging tools instead of invoking udb directly.\"}}'\n    exit 0\nfi\n\n# Block direct `live-record` invocation (including architecture-specific variants like `live-record_x64`).\nif echo \"$command\" | grep -qE '\\blive-record(_[a-z0-9]+)?\\b'; then\n    echo '{\"hookSpecificOutput\":{\"hookEventName\":\"PreToolUse\",\"permissionDecision\":\"deny\",\"permissionDecisionReason\":\"Use the /record command or the record MCP tool instead of invoking live-record directly.\"}}'\n    exit 0\nfi\n\n# Block direct access to `.undo` recording files (check before `undo` to get the right message).\nif echo \"$command\" | grep -qE '\\.undo\\b'; then\n    echo '{\"hookSpecificOutput\":{\"hookEventName\":\"PreToolUse\",\"permissionDecision\":\"deny\",\"permissionDecisionReason\":\"Do not access Undo recordings directly. Use the /debug command or MCP debugging tools.\"}}'\n    exit 0\nfi\n\n# Block direct `undo` invocation.\nif echo \"$command\" | grep -qE '\\bundo\\b'; then\n    echo '{\"hookSpecificOutput\":{\"hookEventName\":\"PreToolUse\",\"permissionDecision\":\"deny\",\"permissionDecisionReason\":\"Use the plugin commands (/debug, /record) or MCP tools instead of invoking undo directly.\"}}'\n    exit 0\nfi\n\n# Allow other commands.\nexit 0\n",
        "follow_fork/README.md": "Follow `fork()`\n===============\n\nOften, when recording, engineers might want to record both the parent and the\nchildren generated during the run.\nThis pre-load library intercepts the calls to 'fork()' and calls the\n[LiveRecorder API](http://undo.io) to record the child.\n\nNote\n----\n\nYou will need to have the LiveRecorder library in order to be able to\nuse this utility.\n\nCompiling\n---------\n\nIn order to be able to use the library it needs to be compiled with\nthe following command:\n\n```\ngcc -I /<path>/<to>/<undodb-xxxx>/undolr -L /<path>/<to>/<undodb-xxxx>/undolr -shared -fPIC follow_fork.c -o libfollowfork.so -l:libundolr_pic_x64.a -std=c99 -ldl\n```\n\nIn order to use the library you'll need to do the following:\n\n```\nLD_PRELOAD=<path_to>/libfollowfork.so <app to record> <args....>\n```\n\n\n",
        "gtest_annotations/README.md": "# Google Test annotations\n\n## Overview\n\nThis provides a listener for [Google Test](https://github.com/google/googletest)\nto insert annotations in recordings made with LiveRecorder or UDB.\n\nIf your Google Test integration already has a `main` function, enabling this\nshould just require the following:\n- `#include <undo_gtest_annotation.h>` before `main`.\n- in main, call:\n  ```c++\n  testing::UnitTest::GetInstance()->listeners().Append(new undo_annotation::UndoAnnotationListener);\n  ```\n\nIf you don't already have a `main` function, you'll need to add one. The most\nbasic version is:\n```c++\nGTEST_API_ int\nmain(int argc, char **argv)\n{\n    testing::InitGoogleTest(&argc, argv);\n\n    testing::UnitTest::GetInstance()->listeners().Append(new undo_annotation::UndoAnnotationListener);\n    return RUN_ALL_TESTS();\n}\n```\n\nThe header file includes `undoex-test-annotations.h`, which is included in the\n`undoex` path of a UDB release. It also requires the library to be included in\nthe build - it is distributed for both static and dynamic linking.\n\n## Examples\n\nThe [example](examples/) is a very basic test of the listener, built using `cmake`.\nIf the `undoex` header and library files are not in system paths, you can specify\nthe path to them using `CMAKE_PREFIX_PATH`. Build the example using:\n```sh\nexport CMAKE_PREFIX_PATH=/path/to/undo/release/undoex\ncmake -S . -B build\ncmake --build build\n```\n\nThe resulting binary in `build/listener_test` runs three tests, two that should\npass and one that should fail. If a recording is made (using LiveRecorder or UDB)\nannotations will be inserted. These can be viewed using the `info annotations`\ncommand in UDB. You can also travel directly to the start or endof a test using\n`ugo annotation`, for example `ugo annotation Fails/run2 u-test-start` will go\nto the start of the failing test in this example.\n\n## Limitations\n\nNote that the annotations are inserted at the point in time in the plugin, so\nwhen going to the start of a test you will need to step forward to find the\nactual start of a test. Likewise, when going to the end of a test you will need\nto step backward.\n",
        "k8s_live_recorder/README.md": "# Undo LiveRecorder Kubernetes Sidecar Demo\n\nThis is a demo of Undo's [LiveRecorder](https://docs.undo.io/UsingTheLiveRecorderTool.html) recording an application in a Kubernetes pod.\nLiveRecorder is hosted in a sidecar container that runs alongside the main application container in the same pod.\nA wrapper application monitors for specific annotations, and starts the recording of the main application process when instructed. \nAs LiveRecorder is hosted in a sidecar container no changes are needed to be made to the existing main application container.\nWhen recording has stopped, the resultant *.undo file is then uploaded to an S3 bucket.\n\nMinikube is used for demonstration purposes.\n\n## Requirements\n\n- [Minikube](https://minikube.sigs.k8s.io/docs/)\n- AWS credentials for S3 upload\n- `live-record` binary and `undolr/` folder from an Undo release. Obtain a [free trail here](https://undo.io/udb-free-trial/).\n\n\n## Setup\n\n1. Copy `live-record` binary and `undolr/` folder to `sidecar/` dir.\n1. `minikube start`\n1. `alias kubectl=\"minikube kubectl --\"` (for convenience)\n1. Use minikube image registry `eval $(minikube docker-env)`\n1. `docker buildx build -t undo/broken-go-app:latest -f app/Dockerfile app --load`\n1. `docker buildx build -t undo/undo-lr-sidecar:latest -f sidecar/Dockerfile sidecar --load`\n1. Create the required secrets for AWS credentials:\n   ```\n   kubectl create secret generic s3 \\\n     --from-literal=AWS_ACCESS_KEY_ID=your-access-key \\\n     --from-literal=AWS_SECRET_ACCESS_KEY=your-secret-key \\\n     --from-literal=S3_BUCKET_NAME=your-bucket \\\n     --from-literal=S3_REGION=your-region\n   ```\n1. `kubectl apply -f k8s/recorder-role.yaml`\n1. `kubectl apply -f k8s/recorder-rolebinding.yaml`\n1. `kubectl apply -f k8s/deployment.yaml`\n1. `kubectl apply -f k8s/service.yaml`\n1. (To restart deployment and redeploy containers `kubectl rollout restart deployment/broken-go-app-deployment`)\n\n## Test Demo\n\nThis very simple demo will show you how to record an application that crashes, get the recording from S3 and then replay using Undo's extended version of [Delve](https://docs.undo.io/GoDelve.html).\n\n1. Check containers and programs are running:\n```\n  kubectl get pods -l app=broken-go-app -o wide\n  kubectl describe pod $(kubectl get pods --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')\n  kubectl logs $(kubectl get pods --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}') -c undo-lr-sidecar\n  kubectl logs $(kubectl get pods --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}') -c broken-go-app\n```\n1. Start recording `kubectl annotate pod $(kubectl get pods --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}') undo.io/live-record=start --overwrite || true`\n1. Get service url `minikube service broken-go-app-service --url` - NOTE: if using docker driver, you will need to perform the curl request in a new terminal while this command continues to run.\n1. Make the target application crash `curl -s \"<service-url>/crash\"`\n1. Stop recording `kubectl annotate pod $(kubectl get pods --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}') undo.io/live-record=stop --overwrite || true` - NOTE: recording will stop due to the crash\n\n1. List uploaded recordings `aws s3 ls s3://S3-BUCKET-NAME/recordings/`\n1. Copy recording to local machine `aws s3 cp s3://S3-BUCKET-NAME/recordings/RECORDING-FILE-NAME.undo .`\n1. Use Delve to replay recording `dlv replay RECORDING-FILE-NAME.undo`",
        "load_debug_symbols/README.md": "# Load Debug Symbols\n\nA common practice amongst customers is to produce binaries compiled with debug symbols and\nthen use a tool such as `objcopy` to strip it of symbols, producing a `.debug` symbol file\nand a stripped binary. This stripped binary is then shipped as part of their product without\nthe .debug file being present.\n\nWhen we produce a recording of an application that has been generated on binaries stripped\nof symbols, the resulting recording file will also not contain debug symbols. In order to\nretrospectively add the debug symbols to the recording, the user is required to use the\n`add-symbol-file` command in udb and pass in the `.debug` file and relevant addresses for the\n`.text`, `.data` and `.bss` sections. This script automates this process.\n\n## Usage\n```\nload-debug-symbols PATHTOFILE\n```\n\nBefore using the script it must be loaded in to the debugger:\n```\nsource PATHTOADDONS/load_debug_symbols/load_debug_symbols.py\n```\n\n## Examples\n\n`load-debug-symbols /foo/bar/baz.debug` : loads the debug symbols by parsing relevant sections.\n\nNote that the argument to `load-debug-symbols` needs to be a valid debug symbol file and\npresent in the file system.\n",
        "reconstruct_file/README.md": "# Reconstruct file\n\nReconstruct a file read by the target program by examining its execution\nhistory. Use the `-regex` or `-fd` options to select which file to reconstruct\nor, if omitted, the first file opened is reconstructed.\n\n## Usage\n\n```\nreconstruct-file [-regex PATH-REGEX | -fd FILE-DESCRIPTOR]\n                 [-from-start]\n                 [-output OUTPUT-PATH]\n```\n\nBefore using the script it must be loaded in to the debugger:\n```\nsource PATHTOADDONS/reconstruct_file/reconstruct_file.py\n```\n\n### Optional arguments\n\n- `-regex PATH-REGEX`:\n  A regular expression matching the path of the file to reconstruct. Only the\n  first file matching the regular expression is considered.\n- `-fd FILE-DESCRIPTOR`:\n  The file descriptor of the file to reconstruct.\n- `-from-start`:\n  By default, the file is reconstructed starting at the current time in\n  execution history. With this flag, the execution history is considered from\n  its beginning.\n- `-output OUTPUT-PATH`, `-o OUTPUT-PATH`:\n  Path to a file were to write the reconstructed file. If not specified, the\n  content is printed on standard output.\n\n## Limitations\n\n- Only 64-bit x86 is supported.\n- Only files which are read in their entirety can be fully reconstructed.\n- Seeks in files being read are ignored. If the target program uses `fseek` or\n  similar, then the file won't be reconstructed correctly.\n- Regular expressions matching the whole path (including directories) may\n  not match opened files correctly due to path manipulation in the target\n  program.\n- Signals may cause the command to fail in unexpected ways.\n",
        "regs_every_bb/README.md": "# Regs every bb\n\nPrints the values of all the registers at every basic block within a range\n\n## Usage\n```\nuregs <bbstart> <bbend>\n```\n\nBefore using the script it must be loaded in to the debugger:\n```\nsource PATHTOADDONS/regs_every_bb/regs_every_bb.py\n```\n",
        "relative_wallclock/README.md": "Relative wallclock\n==================\n\nAdds an info-wallclock-relative command which prints the approximate wallclock time relative to the\nstart of recording.\n\n    Usage: info-wallclock-relative",
        "reverse_step_map/README.md": "# Reverse step maps\n\nThis command helps with finding quickly which maps each instruction works on.\n\nCurrently this script works only on x86 assembly, not ARM.\n\nOther limitations include:\n\n- not able to calculate the right address with certain addressing modes, for example:\n  `(%rax, %rbx, 8)`\n- not able to parse `xmm*` registers: gdb.parse_and_eval() returns an error on such registers.\n\n## Requirements\n\nThis command requires another addons command to be present too: `whatmap`\n\n## Installation\n\nTo install this script you only need to source it in `udb`:\n\n```\nsource reverse_step_map/reverse_step_map.py\n```\n\n## Usage\n\nsimply type `rsm` and you should get output similar to:\n\n```\n99% 15,486,248> rsm\nInstruction: movq   $0x0,0x18dd32(%rip)        # 0x772dcc41ca58 <list_all_lock+8>\nrip + 18dd32 = 0x0000772dcc41ca4d (131038584097357)\nSearching maps for address 0x772dcc41ca4d:\n          0x772dcc41c000     0x772dcc41d000     0x1000        0x0  rw-p\n```\n\n",
        "sample_functions/README.md": "# Sample functions\n\nSampler which counts the number of times we find ourselves in a particular function.\nOutputs a list of functions with their counts.\n```\nUsage:\n  usample <start_bbcount> <end_bbcount> <bbcount_interval> [<filename>]\n  Parameters:\n    start_bbcount: Time, given as a basic block count to start sampling.\n    end_bbcount: Last time that may be sampled.\n    bbcount_interval: How often to take a sample, in basic block count.\n    filename: A file to output the sampled stacks to.\n\n  E.g. 1 1000 1\n  means sample every basic block count from 1 to 1000.\n```\n\nBefore using the script it must be loaded in to the debugger:\n```\nsource PATHTOADDONS/sample_functions/sample_functions.py\n```\n\n## Generating flame graphs\n\nThe output from this tool can be used directly to generate [flame graphs](https://www.brendangregg.com/flamegraphs.html).\nThese graphs provide a visual indication of the busiest areas of your program.\nGenerally, around 1,000 samples will produce a useful flame graph. You may\nwish to limit the sampling to a specific range, for example after start up has\ncompleted.\n\nTo generate a flame graph:\n - clone the [flame graph repository](https://github.com/brendangregg/FlameGraph)\n\n - run the `usample` script. In this case we first query the recorded time\n range within UDB:\n```\n> info time\nCurrent time is: 1 (in recorded range; [1 - 140,988,372])\n```\nTo get around 1,000 samples we wish to sample every 141,000 bbcounts, so we\nrun `usample` with:\n```\n> usample 1 140988372 141000 /tmp/stacks.data\n```\n\n - in the shell run `flamegraph.pl` on the generated call stack data:\n```\n$ flamegraph.pl /tmp/stacks.data > /tmp/stacks.svg\n```\n\nYou can then view the generated SVG file in your browser. Clicking on a block\nwill allow you to zoom in to see more detail. You can also search for function\nnames with regular expressions.\n\nRun `flamegraph.ph --help` to see more options for controlling the output.\n\nThese flame graphs show the proportion of basic blocks that run in a particular\ncall stack. This is related to execution time, but is *not* identical. Not all\nbasic blocks take the same amount of time to run. In addition, this doesn't\nshow time spent in different processes, in particular time spent in system\ncalls.\n",
        "skills/debugging-with-undo/SKILL.md": "---\nname: debugging-with-undo\ndescription: >\n  Debug programs using Undo time travel debugging. Record flaky tests, intermittent failures,\n  race conditions, or bugs that don't reproduce reliably. Analyze recordings by traveling\n  backwards through execution history. Use when the user mentions debugging, flaky tests,\n  intermittent bugs, race conditions, `.undo` files (Undo recordings), or asks why something\n  happened in an actual run. This can provide similar results as adding logging statements,\n  but without modifying the code or needing to re-run the program multiple times.\n---\n\n# Debugging with Undo time travel debugger\n\nUndo provides time travel debugging for Linux programs. This Skill guides you to:\n1. **Record** program execution to capture failures (especially intermittent ones)\n2. **Debug** recordings by traveling backwards through execution history\n\n## When to record (use `record` MCP tool)\n\nRecord program execution when the user:\n- Has a **flaky test** or **intermittent failure** that doesn't reproduce reliably\n- Mentions **race conditions**, **threading issues**, or **concurrency bugs**\n- Wants to **capture a failure** for later analysis\n- Needs **deterministic replay** of a bug\n\nUndo captures the exact execution including thread interleavings, making even race conditions\nreproducible.\n\n## When to debug (use debugging MCP tools)\n\nDebug a recording when the user:\n- Has a **`.undo` recording file** to investigate\n- Asks **\"why did this happen\"** or **\"how did this value get set\"**\n- Wants **root cause analysis** on a captured failure\n- Needs to understand execution **backwards** from a crash or assertion\n\n## Workflow\n\n1. **If no recording exists**: Use `record` MCP tool to capture the failure\n2. **If recording exists**: Use debugging MCP tools to analyze it\n3. **Work backwards**: Start at the end (where the bug manifested), trace backwards\n\n## Important\n\n- **Never access `.undo` files directly** - they are opaque binary recordings\n- **Never invoke `udb`, `live-record`, or `undo` via Bash** - use the Undo MCP tools\n",
        "systemc_trace/README.md": "# systemc_trace\n\nUDB commands for SystemC design introspection and tracing.\n\nAutomatically creates a trace of all signals and module member variables in design.\n\nBased on https://github.com/ripopov/gdb_systemc_trace\n\n\n### Limitations\nFixed-point datatypes are not supported yet\n\n\n## Installation\n\n### Prerequisites\n* Undo 8.2 or later, with LiveRecorder\n* SystemC 2.3.3 built as .so library with debuginfo (see below)\n\n### Running basic example\n1. Ensure that the Undo release directory is on $PATH\n2. Download SystemC 2.3.3 https://accellera.org/downloads/standards/systemc\n3. Build with debug info:\n    ```\n    $ tar xvf systemc-2.3.3.tar.gz \n    $ cd systemc-2.3.3/\n    $ mkdir build_debug\n    $ cd build_debug/\n    $ cmake ../ -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_STANDARD=14\n    $ make -j8\n    # build SystemC examples\n    $ make check -j8\n    ```\n4. Record the example:\n    ```\n    # it is important to cd into example directory, sometimes they read some files from workdir\n    $ (cd examples/sysc/risc_cpu && undo record -o risc_cpu.undo risc_cpu)\n    ```\n5. Create a vcd file from the recording:\n    ```\n    $ udb examples/sysc/risc_cpu/risc_cpu.undo\n    [...]\n    end 1,837,898> extend systemc-trace\n    Updating repo cache...\n    ...done.\n    Installing third-party Python packages...\n        pyvcd\n    ...done.\n    Installing 'systemc-trace'...\n    ...done.\n\n    Type \"show extend-license systemc-trace\" for license information.\n\n\n    WARNING: The 'systemc-trace' addon is experimental and may be withdrawn or\n            changed in incompatible ways at any time.\n\n    end 1,837,898> systemc run risc_cpu.vcd\n    # risc_cpu.vcd file will be created\n    ```\n6. Use GTKWave or other VCD viewer to view generated vcd:\n    ```\n     $ gtkwave risc_cpu.vcd \n    ```\n\n![risc_cpu](gtkwave.png)\n\nYou may want to use vcd_hierarchy_manipulator to create hierarchical VCDs: \nhttps://github.com/yTakatsukasa/vcd_hierarchy_manipulator\n\n## Tracing only required signals\n\n* `udb RECORDING`\n* `systemc list-signals`\n* List of all detected signals in design will be printed to console\n* Copy required signal names (full hierarchical names) into some file, say signals.txt\n* `set signals-file signals.txt`\n* `systemc run systemc_trace.vcd`\n* systemc_trace.vcd will be created\n\n## Print design tree\n\n* `udb RECORDING`\n* `systemc print`\n",
        "what_map/README.md": "# What map\n\nLooks up a variable or address within the maps of the debuggee.\n\n## Usage\n```\nwhatmap EXPRESSION\n```\n\nBefore using the script it must be loaded in to the debugger:\n```\nsource PATHTOADDONS/what_map/what_map.py\n```\n\n## Examples\n\n`whatmap my_variable` : looks up the map containing the named variable.\n\n`whatmap *0x1234` : looks up the map containing the address 0x1234.\n\nNote that the argument to `whatmap` needs to be addressable - in other words, you should use an\nargument that you would pass to `watch`.\n\nThis command works with vanilla GDB or within UDB. When run under UDB it will inspect the maps\nof the currently active child process - note that these don't exactly match the maps that were\npresent at record time.\n"
      },
      "plugins": [
        {
          "name": "undo",
          "description": "Debug and analyze Undo recordings using AI-powered queries",
          "source": "./",
          "category": "development",
          "version": "1.0.0",
          "author": {
            "name": "Undo",
            "email": "support@undo.io"
          },
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add undoio/addons",
            "/plugin install undo@undo"
          ]
        }
      ]
    }
  ]
}