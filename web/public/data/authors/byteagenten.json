{
  "author": {
    "id": "byteAgenten",
    "display_name": "byteAgenten",
    "avatar_url": "https://avatars.githubusercontent.com/u/20725018?v=4"
  },
  "marketplaces": [
    {
      "name": "byteagenten-marketplace",
      "version": null,
      "description": "byteAgenten Claude Code Plugin Marketplace",
      "repo_full_name": "byteAgenten/byteagenten-marketplace",
      "repo_url": "https://github.com/byteAgenten/byteagenten-marketplace",
      "repo_description": "byteAgenten Claude Code Plugin Marketplace",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-14T02:14:39Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"byteagenten-marketplace\",\n  \"owner\": {\n    \"name\": \"byteAgenten\",\n    \"email\": \"hans.pickelmann@byteagenten.de\"\n  },\n  \"metadata\": {\n    \"description\": \"byteAgenten Claude Code Plugin Marketplace\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"byt8\",\n      \"description\": \"Full-stack development toolkit for Angular 21 + Spring Boot 4 applications with 10-phase workflow\",\n      \"source\": \"./plugins/byt8\"\n    },\n    {\n      \"name\": \"bytA\",\n      \"description\": \"Agent-based workflow orchestration for Angular + Spring Boot (experimental)\",\n      \"source\": \"./plugins/bytA\"\n    },\n    {\n      \"name\": \"bytM\",\n      \"description\": \"Agent Team-based full-stack development with cross-validation (native Claude Code Agent Teams)\",\n      \"source\": \"./plugins/bytM\"\n    }\n  ]\n}\n",
        "README.md": "# byteAgenten Plugin Marketplace\n\nPrivate Claude Code Plugins for byteAgenten team members.\n\n## Available Plugins\n\n| Plugin | Description | Version |\n|--------|-------------|---------|\n| [byt8](./plugins/byt8) | Full-stack development toolkit for Angular 21 + Spring Boot 4 | 7.5.7 |\n| [bytA](./plugins/bytA) | Deterministic full-stack workflow (Boomerang + Ralph-Loop) | 3.9.2 |\n| [bytM](./plugins/bytM) | 4-Agent Team workflow with cross-validation (native Agent Teams) | 1.5.0 |\n\n## Prerequisites\n\n### 1. GitHub-Zugang zur byteAgenten Organisation\n\nDu brauchst Zugriff auf das private Repository `byteAgenten/byteagenten-marketplace`.\n\n### 2. GitHub Token konfigurieren\n\n**Option A: GitHub CLI (empfohlen)**\n\nDie [GitHub CLI](https://cli.github.com/) (`gh`) ist ein Kommandozeilen-Tool fÃ¼r GitHub.\n\n```bash\n# Installation (macOS)\nbrew install gh\n\n# Installation (Windows)\nwinget install GitHub.cli\n\n# Einmalig anmelden - Ã¶ffnet Browser zur Authentifizierung\ngh auth login\n```\n\n**Option B: Personal Access Token (PAT)**\n\n1. Gehe zu [GitHub Settings â†’ Developer Settings â†’ Personal Access Tokens](https://github.com/settings/tokens)\n2. Klicke \"Generate new token (classic)\"\n3. WÃ¤hle Scope: `repo` (Full control of private repositories)\n4. Token kopieren (beginnt mit `ghp_`)\n5. In Shell exportieren:\n\n```bash\n# In ~/.bashrc oder ~/.zshrc einfÃ¼gen:\nexport GITHUB_TOKEN=ghp_dein_token_hier\n```\n\n## Installation\n\n### Option 1: Via Claude Code (empfohlen)\n\nIn Claude Code eingeben:\n\n```bash\n# Marketplace registrieren\n/plugin marketplace add byteAgenten/byteagenten-marketplace\n\n# Plugin installieren\n/plugin install byt8@byteagenten-marketplace\n```\n\n**ErklÃ¤rung:**\n- `byteAgenten` = GitHub Organisation (Owner des Repositories)\n- `byteagenten-marketplace` = Name des Repositories auf GitHub\n- `byt8` = Name des Plugins\n- `@byteagenten-marketplace` = aus welchem Marketplace das Plugin kommt\n\n### Option 2: Manuelle Konfiguration\n\nFÃ¼ge in deinem Projekt `.claude/settings.json` hinzu:\n\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"byteagenten-marketplace\": {\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"byteAgenten/byteagenten-marketplace\"\n      }\n    }\n  },\n  \"enabledPlugins\": {\n    \"byt8@byteagenten-marketplace\": true\n  }\n}\n```\n\n### Option 3: Bestimmte Version pinnen\n\nFalls du eine feste Version verwenden mÃ¶chtest:\n\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"byteagenten-marketplace\": {\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"byteAgenten/byteagenten-marketplace\",\n        \"ref\": \"v1.0.0\"\n      }\n    }\n  },\n  \"enabledPlugins\": {\n    \"byt8@byteagenten-marketplace\": true\n  }\n}\n```\n\n## Available Commands\n\n| Command | Description |\n|---------|-------------|\n| `/byt8:full-stack-feature` | 10-phase workflow for full-stack feature development |\n| `/byt8:ui-theming` | One-time design system initialization (theme, tokens, typography) |\n| `/byt8:python-expert` | Python development support |\n| `/byt8:prd-generator` | Generate PRDs (user stories, requirements) and create GitHub Issues |\n| `/bytA:feature` | Deterministic 10-phase workflow (Boomerang + Ralph-Loop) |\n| `/bytA:prd-generator` | Generate PRDs (user stories, requirements) and create GitHub Issues |\n| `/bytM:feature` | 4-Agent Team workflow with cross-validation |\n| `/bytM:prd-generator` | Generate PRDs (user stories, requirements) and create GitHub Issues |\n\nâ†’ Details und Beispiele siehe [byt8 README](./plugins/byt8/README.md) / [bytA README](./plugins/bytA/README.md) / [bytM README](./plugins/bytM/README.md)\n\n## Plugin Architecture\n\nEach plugin is independently installable and versioned:\n\n```\nbyteagenten-marketplace/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ marketplace.json       # Plugin registry\nâ”œâ”€â”€ plugins/\nâ”‚   â””â”€â”€ byt8/                  # Full-stack development toolkit\nâ”‚       â”œâ”€â”€ .claude-plugin/\nâ”‚       â”‚   â””â”€â”€ plugin.json    # Plugin metadata & version\nâ”‚       â”œâ”€â”€ .mcp.json          # MCP server configuration\nâ”‚       â”œâ”€â”€ agents/            # 10 specialized agents\nâ”‚       â”œâ”€â”€ commands/          # 10 slash commands\nâ”‚       â”œâ”€â”€ hooks/             # Workflow hooks (hooks.json)\nâ”‚       â”œâ”€â”€ scripts/           # Hook scripts (bash)\nâ”‚       â”œâ”€â”€ skills/            # Workflow implementations (SKILL.md)\nâ”‚       â””â”€â”€ README.md\nâ”œâ”€â”€ CLAUDE.md                  # Project instructions for Claude Code\nâ””â”€â”€ README.md\n```\n\n## Adding New Plugins\n\n1. Create a new folder: `plugins/byt8-[name]/`\n2. Add `.claude-plugin/plugin.json` with unique name\n3. Add commands, agents, and skills\n4. Update `.claude-plugin/marketplace.json`\n5. Create PR for review\n\n## License\n\nProprietary - byteAgenten internal use only.\n",
        "plugins/byt8/README.md": "# byt8 Plugin\n\n**Version 7.5.7** | Full-Stack Development Toolkit fÃ¼r Angular 21 + Spring Boot 4 Anwendungen mit 10-Phasen Workflow, Approval Gates und **deterministischem Auto-Advance via Context-Injection**.\n\n## Philosophy\n\n> \"QualitÃ¤t durch Struktur: Jede Phase wird abgeschlossen, bevor die nÃ¤chste beginnt.\"\n\nDieses Plugin orchestriert spezialisierte Agents durch einen strukturierten Entwicklungs-Workflow mit Quality Gates und User Approvals.\n\n### Workflow-Steuerung\n\nDas Plugin nutzt eine **hybride Workflow-Kontrolle** aus Hooks und SKILL-Logik:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. User ruft /byt8:full-stack-feature auf                  â”‚\nâ”‚  2. SKILL fÃ¼hrt Phasen aus bis zum nÃ¤chsten Approval Gate   â”‚\nâ”‚  3. Stop-Hook validiert und gibt Anweisungen                â”‚\nâ”‚  4. User gibt Approval oder Feedback                        â”‚\nâ”‚  5. NÃ¤chster Aufruf â†’ weiter bis zum nÃ¤chsten Gate          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Kernprinzip:** Approval Gates (0, 1, 7, 8, 9) pausieren fÃ¼r User-Input. Auto-Advance Phasen (2-6) laufen ohne Stopp durch. Der Stop-Hook kontrolliert den Workflow, nicht Claude.\n\n---\n\n## Installation\n\n### Via Marketplace\n\n```bash\n# In Claude Code\n/plugins install byt8\n```\n\n### Via GitHub\n\nFÃ¼ge in deinem Projekt `.claude/settings.json` hinzu:\n\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"byteagenten-marketplace\": {\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"byteAgenten/byteagenten-marketplace\"\n      }\n    }\n  },\n  \"enabledPlugins\": {\n    \"byt8@byteagenten-marketplace\": true\n  }\n}\n```\n\n---\n\n## MCP Server\n\nDas Plugin installiert zwei MCP Server automatisch:\n\n| Server | Beschreibung |\n|--------|--------------|\n| `context7` | Aktuelle Dokumentation fÃ¼r Libraries (von [Upstash](https://github.com/upstash/context7)) |\n| `angular-cli` | Angular CLI Integration |\n\n**Wichtig:** Nach der Plugin-Installation muss Claude Code **neu gestartet** werden, damit die MCP Server geladen werden.\n\n### Context7 API-Key (optional, empfohlen)\n\nContext7 funktioniert ohne Anmeldung, aber mit eingeschrÃ¤nkten Rate Limits. FÃ¼r hÃ¤ufige Nutzung empfehlen wir einen kostenlosen API-Key:\n\n1. Registrieren auf [context7.com/dashboard](https://context7.com/dashboard)\n2. API-Key generieren (Format: `ctx7sk-...`)\n3. Als Umgebungsvariable setzen:\n\n```bash\n# In ~/.bashrc oder ~/.zshrc einfÃ¼gen:\nexport CONTEXT7_API_KEY=ctx7sk-dein-key-hier\n```\n\n---\n\n## Commands\n\n| Command | Beschreibung |\n|---------|--------------|\n| `/byt8:full-stack-feature` | 10-Phasen Feature Development Workflow |\n| `/byt8:ui-theming` | Einmalige Design System Initialisierung |\n| `/byt8:python-expert` | Python Development Support |\n| `/byt8:prd-generator` | PRD erstellen (User Stories + Requirements â†’ GitHub Issue) |\n\n### Beispiele\n\n```bash\n# Mit GitHub Issue\n/byt8:full-stack-feature #42                          # Fragt nach Branch\n/byt8:full-stack-feature #42 --from=develop           # Branch explizit\n\n# Mit direkter Featurebeschreibung (ohne GitHub)\n/byt8:full-stack-feature \"User kann sich ausloggen\"   # Fragt nach Branch\n/byt8:full-stack-feature \"Logout Button\" --from=main  # Branch explizit\n\n# Mit Datei (fÃ¼r lÃ¤ngere Specs)\n/byt8:full-stack-feature --file=feature.md            # Fragt nach Branch\n/byt8:full-stack-feature --file=feature.md --from=develop\n```\n\n**Hinweis:** Ohne `--from=` fragt der Workflow immer nach dem Quell-Branch.\n\n---\n\n## Der 10-Phasen Workflow\n\nDer `full-stack-feature` Command orchestriert diese Phasen:\n\n| Phase | Agent | Aufgabe |\n|-------|-------|---------|\n| 0 | architect-planner | Technical Specification erstellen |\n| 1 | ui-designer | Wireframes erstellen |\n| 2 | api-architect | API Design (OpenAPI 3.1) |\n| 3 | postgresql-architect | Database Migrations (Flyway) |\n| 4 | spring-boot-developer | Backend Implementation + Tests |\n| 5 | angular-frontend-developer | Frontend Implementation + Tests |\n| 6 | test-engineer | E2E Tests (Playwright) |\n| 7 | security-auditor | Security Audit |\n| 8 | code-reviewer | Code Review |\n| 9 | - (Orchestrator) | Push & PR erstellen |\n\n### Approval Gates\n\nDer Workflow pausiert an kritischen Punkten fÃ¼r User-Approval:\n- Nach Phase 0 (Technical Spec)\n- Nach Phase 1 (Wireframes)\n- Nach Phase 7 (Security Audit)\n- Nach Phase 8 (Code Review)\n- Nach Phase 9 (PR erstellt)\n\n---\n\n## Hook-basierte Automatisierung (v4.0+, Context-Injection v7.0)\n\nAb Version 7.0 nutzt byt8 **Context-Injection** fÃ¼r deterministische Workflow-Steuerung. Hooks kommunizieren mit Claude Ã¼ber dokumentierte KanÃ¤le statt unsichtbarem stdout.\n\n### Hook-Output-Sichtbarkeit (Claude Code Architektur)\n\n| Output-Kanal | Sieht Claude? | Sieht User? | Genutzt fÃ¼r |\n|---|---|---|---|\n| `Stop` Hook: JSON `decision:\"block\"` + `reason` | **Ja** (reason) | Ja | Auto-Advance, Retries |\n| `UserPromptSubmit` Hook: stdout | **Ja** (Context) | Verbose | Approval Gate Kontext |\n| `SessionStart` Hook: stdout | **Ja** (Context) | Verbose | Context Recovery |\n| `PreToolUse` Hook: exit 2 + stderr | **Ja** (stderr) | Ja | Push Guard, Code-Edit Block |\n| `Stop` Hook: stdout (exit 0, kein JSON) | **Nein** | Verbose | Nur Logging |\n\n### Workflow Hooks\n\nDas Plugin nutzt **zwei Ebenen** von Hooks:\n\n**Plugin-Level Hooks** (`hooks/hooks.json`) â€” gelten global:\n\n| Hook | Trigger | Script | Funktion | Claude sieht? |\n|------|---------|--------|----------|----------------|\n| `UserPromptSubmit` | User-Prompt | `wf_user_prompt.sh` | Context-Injection: Status + Rollback-Regeln | **Ja** (stdout â†’ Context) |\n| `PreToolUse` (Bash) | Vor Bash-Aufruf | `guard_git_push.sh` | Blockiert `git push` ohne `pushApproved` | **Ja** (exit 2 â†’ stderr) |\n| `SessionStart` | Session-Start/Resume | `session_recovery.sh` | Context Recovery nach Overflow | **Ja** (stdout â†’ Context) |\n| `Stop` | Haupt-Agent fertig | `wf_engine.sh` | Auto-Advance (decision:block), Phase Validation | **Ja** (JSON reason) |\n| `SubagentStart` | Subagent startet | `subagent_start.sh` | Logging, `currentAgent` setzen | Nein (Logging) |\n| `SubagentStop` | Subagent beendet | `subagent_done.sh` | WIP-Commits (Shell-Commands) | Nein (deterministisch) |\n\n**Skill-Level Hooks** (SKILL.md Frontmatter) â€” gelten nur im Workflow:\n\n| Hook | Trigger | Script | Funktion | Claude sieht? |\n|------|---------|--------|----------|----------------|\n| `PreToolUse` (Edit\\|Write) | Vor Edit/Write-Aufruf | `block_orchestrator_code_edit.sh` | Blockiert Code-Edits durch Orchestrator | **Ja** (exit 2 â†’ stderr) |\n| `PreToolUse` (Task) | Vor Task-Aufruf | `block_orchestrator_explore.sh` | Blockiert Explore/general-purpose Agents | **Ja** (exit 2 â†’ stderr) |\n\n### Setup\n\nHooks werden automatisch Ã¼ber die Plugin-Konfiguration geladen â€” **kein manuelles Setup nÃ¶tig**.\n\n### Startup-Flow\n\n```mermaid\nflowchart TD\n    subgraph TRIGGER[\"Workflow Start\"]\n        A[\"/byt8:full-stack-feature\"]\n    end\n\n    subgraph CLEANUP[\"Schritt 1: Cleanup\"]\n        A1[\"wf_cleanup.sh<br/>aufrufen\"]\n        A2{\"Exit Code?\"}\n        A3[\"AufgerÃ¤umt oder<br/>kein Workflow\"]\n        A4[\"BLOCKED!<br/>Aktiver Workflow\"]\n        A5[\"User entscheidet:<br/>resume oder abbrechen\"]\n    end\n\n    subgraph SESSION[\"SessionStart Hook\"]\n        B{\".workflow/<br/>state.json<br/>existiert?\"}\n        C[\"Context Recovery<br/>Zeige Recovery-Prompt\"]\n        D[\"Kein aktiver Workflow\"]\n    end\n\n    subgraph INIT[\"Workflow Initialisierung\"]\n        H{\"workflow-state.json<br/>Status?\"}\n        I[\"Resume bei<br/>currentPhase\"]\n        J[\"User informieren<br/>'/wf:resume' anbieten\"]\n        K[\"Neuen Workflow<br/>initialisieren\"]\n    end\n\n    subgraph NEW_WF[\"Neuer Workflow\"]\n        L[\"1. CLAUDE.md prÃ¼fen\"]\n        M[\"2. .workflow/ erstellen\"]\n        N[\"3. .gitignore ergÃ¤nzen\"]\n        O[\"4. Branch erstellen\"]\n        P[\"5. Test-Coverage fragen\"]\n        Q[\"6. workflow-state.json<br/>erstellen\"]\n    end\n\n    subgraph PHASE[\"Phase starten\"]\n        R[\"Agent fÃ¼r Phase N<br/>aufrufen\"]\n        S[\"Hook validiert<br/>Done-Kriterien\"]\n        T[\"WIP-Commit<br/>erstellen\"]\n        U[\"NÃ¤chste Phase<br/>oder Approval Gate\"]\n    end\n\n    A --> A1\n    A1 --> A2\n    A2 -->|\"0 (OK)\"| A3\n    A2 -->|\"1 (BLOCKED)\"| A4\n    A4 --> A5\n    A3 --> B\n    B -->|Ja, status: active/paused| C\n    B -->|Nein| D\n    C --> H\n    D --> H\n    H -->|\"active\"| I\n    H -->|\"paused\"| J\n    H -->|Nicht gefunden| K\n    I --> R\n    K --> L\n    L --> M --> N --> O --> P --> Q\n    Q --> R\n    R --> S\n    S -->|\"Done\"| T\n    T --> U\n    S -->|\"Fail\"| R\n\n    style TRIGGER fill:#1565c0,color:#fff\n    style CLEANUP fill:#7b1fa2,color:#fff\n    style SESSION fill:#e65100,color:#fff\n    style INIT fill:#2e7d32,color:#fff\n    style NEW_WF fill:#c62828,color:#fff\n    style PHASE fill:#00695c,color:#fff\n```\n\n### Was die Hooks tun\n\n**wf_engine.sh** (Stop) â€” Zentrale Workflow-Steuerung:\n- **Auto-Advance via `decision:block`:** Bei Phasen 2-6 gibt JSON `{\"decision\":\"block\",\"reason\":\"...\"}` zurÃ¼ck â†’ Claude KANN NICHT stoppen und sieht die Anweisung fÃ¼r die nÃ¤chste Phase\n- **Approval Gates:** Setzt `status = \"awaiting_approval\"`, kein JSON â†’ Claude stoppt normal\n- **Phase-Skip Guard:** Erkennt Ã¼bersprungene Phasen via `phases[].status` und `context.*` Keys (Defense-in-Depth), korrigiert State, blockiert mit Anweisung\n- **Phase Done Check:** PrÃ¼ft `phases[].status` (completed/skipped) vor Context-Keys â€” Ã¼bersprungene Phasen werden korrekt als \"done\" erkannt\n- **Completed-State Guard:** Loggt Workflow-Completion nur einmal (dedupliziert via `completedAt`-Check)\n- **Test-Retries:** Max 3 Versuche, dann Workflow pausieren\n- **Phase 8 Rollback:** Deterministisch â€” bestimmt Rollback-Ziel aus `reviewFeedback.fixes[].type`\n- **Loop-Prevention:** ZÃ¤hlt consecutive blocks (`stopHookBlockCount`), pausiert bei >15\n- **Sound Notifications (Cross-Platform):** Akustische Benachrichtigungen bei Workflow-Events:\n  - **Notification Sound** â€” Approval Gates, Workflow pausiert (User muss handeln)\n  - **Completion Sound** â€” Workflow erfolgreich abgeschlossen\n  - UnterstÃ¼tzt: macOS (afplay), Linux (paplay/aplay), Windows (PowerShell)\n  - Custom Sounds: Lege `notification.wav` und `completion.wav` in `assets/sounds/` ab\n\n**wf_user_prompt.sh** (UserPromptSubmit) â€” Context-Injection:\n- stdout wird in Claudes Kontext injiziert (UserPromptSubmit Spezial!)\n- **Approval Gates:** Injiziert phase-spezifische Anweisungen (Approval, Feedback, Rollback-Regeln)\n- **Phase 7:** VollstÃ¤ndige Rollback-Regeln (Security-Fixes + allgemeine Ã„nderungen + PFLICHT-Reihenfolge)\n- **Phase 8â†’9 Transition:** Setzt `status = \"awaiting_approval\"` bei Approval, damit Phase 9 korrekt als Approval Gate erkannt wird\n- **Loop-Prevention Reset:** Setzt `stopHookBlockCount` auf 0 bei jedem User-Prompt\n\n**guard_git_push.sh** (PreToolUse/Bash):\n- Blockiert `git push` und `gh pr create` via exit 2 + stderr â†’ Claude sieht die Fehlermeldung\n- Nur Phase 9 setzt `pushApproved = true` nach User-Zustimmung\n\n**block_orchestrator_code_edit.sh** (PreToolUse/Edit|Write, Skill-Level):\n- Blockiert Edit/Write auf Code-Dateien via exit 2 + stderr â†’ Claude sieht die Fehlermeldung\n- Erzwingt: Alle Code-Ã„nderungen laufen Ã¼ber spezialisierte Agents\n\n**block_orchestrator_explore.sh** (PreToolUse/Task, Skill-Level):\n- Blockiert Task(Explore) und Task(general-purpose) via exit 2 + stderr â†’ Claude sieht die Fehlermeldung\n- Erlaubt: Task(byt8:*) â€” spezialisierte Phase-Agents\n- Erzwingt: Orchestrator delegiert sofort statt selbst zu explorieren\n- Loggt jeden blockierten Versuch in `hooks.log`\n\n**session_recovery.sh** (SessionStart):\n- stdout wird in Claudes Kontext injiziert (SessionStart Spezial!)\n- Erkennt aktiven Workflow nach Context Overflow/Compaction\n- Gibt Recovery-Prompt mit Workflow-Status und nÃ¤chstem Schritt aus\n\n**subagent_start.sh** (SubagentStart):\n- **Safety Net Cleanup:** LÃ¶scht `.workflow/` wenn `status=completed` (Backup falls Skill-Startup Ã¼bersprungen wird)\n- PrimÃ¤rer Cleanup passiert explizit via `wf_cleanup.sh` am Skill-Startup\n- Speichert `currentAgent` in workflow-state.json (fÃ¼r WIP-Commit Safety Net)\n- Loggt welcher Agent gestartet wurde\n\n**subagent_done.sh** (SubagentStop):\n- Erstellt **WIP-Commits** deterministisch (Shell-Commands, kein LLM)\n- Commitbare Phasen: 1, 3, 4, 5, 6\n- **Safety Net:** Agent-basierte Erkennung fÃ¼r Hotfixes (`agent_produces_code()`)\n- stdout wird NICHT in Claudes Kontext injiziert (ist aber deterministisch und braucht kein LLM)\n\n### Workflow-State\n\nDer Zustand wird in `.workflow/` persistiert:\n\n```\n.workflow/\nâ”œâ”€â”€ workflow-state.json    # Hauptzustand (Phase, Status, Context)\nâ”œâ”€â”€ specs/                 # Spec-Dateien der Agents\nâ”‚   â”œâ”€â”€ issue-N-ph00-architect-planner.md\nâ”‚   â”œâ”€â”€ issue-N-ph02-api-architect.md\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ recovery/              # Retry-Tracking (nur bei Test-Retries)\nâ”‚   â””â”€â”€ retry-tracker.json\nâ””â”€â”€ logs/                  # Audit-Logs\n    â”œâ”€â”€ hooks.log\n    â””â”€â”€ transitions.jsonl\n```\n\n### Workflow-Commands\n\n| Command | Beschreibung |\n|---------|--------------|\n| `/byt8:wf-status` | Detaillierten Workflow-Status anzeigen |\n| `/byt8:wf-pause` | Workflow pausieren |\n| `/byt8:wf-resume` | Pausierten Workflow fortsetzen |\n| `/byt8:wf-retry-reset` | Retry-Counter zurÃ¼cksetzen |\n| `/byt8:wf-skip` | âš ï¸ Phase Ã¼berspringen (Notfall) |\n| `/byt8:wf-cleanup` | .workflow/ Folder lÃ¶schen (nach Workflow-Abschluss) |\n\n---\n\n## Context-Optimierung: File Reference Protocol (v6.8.0+)\n\nAb Version 6.8.0 Ã¼bergibt der Orchestrator **nur Dateipfade** an Agents â€” nicht den Inhalt der Spec-Dateien. Agents lesen die Specs **selbst** via Read-Tool in ihrem eigenen, isolierten Kontext.\n\n### Vorher (Spec Injection)\n\n```\nOrchestrator liest Spec â†’ injiziert Inhalt in Task()-Prompt â†’ ~60 KB pro Phase\nAuto-Advance (5 Phasen) â†’ ~300 KB Orchestrator-Kontext â†’ Context Compaction ğŸ’¥\n```\n\n### Jetzt (File Reference)\n\n```\nOrchestrator liest NUR workflow-state.json â†’ Ã¼bergibt Dateipfade â†’ ~3 KB pro Phase\nAuto-Advance (5 Phasen) â†’ ~15 KB Orchestrator-Kontext â†’ kein Compaction âœ…\n```\n\n### Drei Output-KanÃ¤le pro Agent\n\n| Kanal | Wo | Wer schreibt | Context-Kosten |\n|-------|----|-------------|----------------|\n| Spec-Datei | `.workflow/specs/` | Agent | 0 KB (nur auf Platte) |\n| Workflow-State | `context.*` Keys | Agent | 0 KB (nur auf Platte) |\n| Task()-Return | Orchestrator-Kontext | Agent (letzte Nachricht) | ~1 KB (max 10 Zeilen) |\n\n---\n\n## Agents\n\n| Agent | Spezialisierung |\n|-------|-----------------|\n| `architect-planner` | Technical Specifications, 5x Warum Analyse |\n| `api-architect` | OpenAPI 3.1, REST API Design |\n| `angular-frontend-developer` | Angular 21, Signals, TypeScript |\n| `spring-boot-developer` | Spring Boot 4, Java 21, JPA |\n| `postgresql-architect` | Schema Design, Flyway Migrations |\n| `test-engineer` | JUnit 5, Jasmine, Playwright |\n| `ui-designer` | Wireframes, Design Tokens |\n| `security-auditor` | OWASP Top 10, Security Best Practices |\n| `code-reviewer` | Code Quality, Architecture Review |\n| `architect-reviewer` | Architecture Decisions |\n\n---\n\n## Skills\n\n| Skill | Beschreibung |\n|-------|--------------|\n| `full-stack-feature` | 10-Phasen Workflow mit State Management |\n| `ui-theming` | Design System Initialisierung (inkl. 10 vordefinierte Themes) |\n| `python-expert` | Async, Typing, Testing Patterns |\n| `prd-generator` | Product Requirements Documents (Was/Warum, keine technischen Details) |\n\n---\n\n## Plugin-Struktur\n\n```\nbyt8/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json\nâ”œâ”€â”€ assets/                    # Plugin-Assets\nâ”‚   â””â”€â”€ sounds/                # Custom workflow sounds (optional)\nâ”‚       â”œâ”€â”€ notification.wav   # Approval Gates, Workflow paused\nâ”‚       â””â”€â”€ completion.wav     # Workflow completed\nâ”œâ”€â”€ agents/                    # 10 spezialisierte Agents\nâ”‚   â”œâ”€â”€ architect-planner.md\nâ”‚   â”œâ”€â”€ angular-frontend-developer.md\nâ”‚   â”œâ”€â”€ spring-boot-developer.md\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ commands/                  # Slash-Commands\nâ”‚   â”œâ”€â”€ full-stack-feature.md\nâ”‚   â”œâ”€â”€ ui-theming.md\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ hooks/                     # Hook-Konfiguration (v4.0+)\nâ”‚   â””â”€â”€ hooks.json\nâ”œâ”€â”€ scripts/                   # Workflow-Scripts (v7.0 Context-Injection)\nâ”‚   â”œâ”€â”€ wf_engine.sh           # Stop Hook: JSON decision:block fÃ¼r Auto-Advance\nâ”‚   â”œâ”€â”€ wf_user_prompt.sh      # UserPromptSubmit Hook: Context-Injection\nâ”‚   â”œâ”€â”€ subagent_done.sh       # SubagentStop Hook: WIP-Commits\nâ”‚   â”œâ”€â”€ subagent_start.sh      # SubagentStart Hook: Agent-Tracking\nâ”‚   â”œâ”€â”€ session_recovery.sh    # SessionStart Hook: Context Recovery\nâ”‚   â”œâ”€â”€ guard_git_push.sh      # PreToolUse Hook: Push Guard\nâ”‚   â”œâ”€â”€ block_orchestrator_code_edit.sh  # PreToolUse Hook: Code-Edit Block\nâ”‚   â””â”€â”€ block_orchestrator_explore.sh   # PreToolUse Hook: Explore-Block\nâ”œâ”€â”€ skills/                    # Workflow-Implementierungen\nâ”‚   â”œâ”€â”€ full-stack-feature/\nâ”‚   â”‚   â””â”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ ui-theming/\nâ”‚   â”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”‚   â””â”€â”€ themes/\nâ”‚   â”œâ”€â”€ prd-generator/\nâ”‚   â”‚   â””â”€â”€ SKILL.md\nâ”‚   â””â”€â”€ ...\nâ””â”€â”€ README.md\n```\n\n---\n\n## Technologie-Stack\n\n- **Backend:** Spring Boot 4.0+, Java 21+, PostgreSQL\n- **Frontend:** Angular 21+, TypeScript, SCSS\n- **Testing:** JUnit 5, Jasmine, Playwright\n- **API:** OpenAPI 3.1, REST\n- **Database:** PostgreSQL, Flyway Migrations\n\n---\n\n## License\n\nMIT\n",
        "plugins/bytA/README.md": "# bytA Plugin\n\n**Version 3.9.2** | Deterministic Orchestration: Boomerang + Ralph-Loop\n\nFull-Stack Development Toolkit fuer Angular 21 + Spring Boot 4 mit deterministischem 10-Phasen-Workflow.\n\n## Architektur\n\nDer Orchestrator ist ein **Bash-Script**, kein LLM. Claude dient nur als Transport-Layer fuer Agent-Aufrufe.\n\n| Prinzip | Bedeutung |\n|---------|-----------|\n| **Ralph-Loop** | `while !done; do spawn_agent; verify; done` â€” Externe Verifikation |\n| **Boomerang** | Vollstaendige Kontext-Isolation pro Agent â€” kein Context Rot |\n| **Deterministisch** | Shell-Scripts steuern, LLM fuehrt aus |\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                                                          â”‚\nâ”‚  Stop Hook (wf_orchestrator.sh)                          â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚\nâ”‚  â”‚  1. verify_done()      â”‚  â† Shell prueft Dateien/    â”‚\nâ”‚  â”‚     (wf_verify.sh)     â”‚    State (kein LLM!)        â”‚\nâ”‚  â”‚                        â”‚                              â”‚\nâ”‚  â”‚  2. done? â†’ advance    â”‚  â† AUTO: naechste Phase     â”‚\nâ”‚  â”‚           â†’ approval   â”‚  â† APPROVAL: User fragen    â”‚\nâ”‚  â”‚                        â”‚                              â”‚\nâ”‚  â”‚  3. !done? â†’ re-spawn  â”‚  â† Ralph-Loop retry         â”‚\nâ”‚  â”‚     (max 3 attempts)   â”‚    (frischer Agent-Context)  â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚\nâ”‚                                                          â”‚\nâ”‚  Agent-Dispatch via decision:block                       â”‚\nâ”‚  â†’ Claude MUSS Task(bytA:agent) ausfuehren              â”‚\nâ”‚  â†’ Agent laeuft isoliert (Boomerang)                     â”‚\nâ”‚  â†’ Orchestrator prueft extern (Ralph)                    â”‚\nâ”‚                                                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Commands\n\n| Command | Beschreibung |\n|---------|-------------|\n| `/bytA:feature` | Deterministischer 10-Phasen-Workflow fuer Full-Stack Features |\n| `/bytA:prd-generator` | PRD-Generator: Product Requirements Documents + GitHub Issues |\n\n## Workflow\n\n```\n/bytA:feature #391\n```\n\n### Phasen\n\n| Phase | Agent | Typ | Done-Kriterium |\n|-------|-------|-----|----------------|\n| 0 | architect-planner | APPROVAL | Spec-Datei existiert |\n| 1 | ui-designer | APPROVAL | Issue-prefixed Wireframe HTML existiert |\n| 2 | api-architect | AUTO | API-Spec existiert |\n| 3 | postgresql-architect | AUTO | Migration SQL existiert |\n| 4 | spring-boot-developer | AUTO | Backend-Report MD existiert |\n| 5 | angular-frontend-developer | AUTO | Frontend-Report MD existiert |\n| 6 | test-engineer | AUTO | allPassed == true + Report-Datei existiert |\n| 7 | security-auditor | APPROVAL | Audit-Datei existiert |\n| 8 | code-reviewer | APPROVAL | Review-Datei existiert |\n| 9 | Push & PR | APPROVAL | PR URL in State |\n\n**APPROVAL** = User muss approven (Workflow pausiert)\n**AUTO** = Externe Verifikation, dann naechste Phase automatisch\n\n### Ablauf-Diagramm\n\n```\nPhase 0 (Tech Spec) â”€â”€[User Approval]â”€â”€â†’ Phase 1 (Wireframes)\n                                              â”‚\n                                        [User Approval]\n                                              â”‚\n                                              â–¼\nPhase 2 (API) â†’ Phase 3 (DB) â†’ Phase 4 (Backend) â†’ Phase 5 (Frontend) â†’ Phase 6 (Tests)\n   AUTO           AUTO           AUTO                  AUTO                  AUTO\n                                              â”‚\n                                              â–¼\nPhase 7 (Security) â”€â”€[User Approval]â”€â”€â†’ Phase 8 (Review) â”€â”€[User Approval]â”€â”€â†’ Phase 9 (PR)\n```\n\n### Rollback (Option C: Heuristik + User-Wahl)\n\nBei Phase 7/8 kann der User aendern lassen:\n1. Shell-Script schlaegt Rollback-Ziel vor (basierend auf betroffenen Dateipfaden)\n2. User bestaetigt oder waehlt anderes Ziel\n3. State wird deterministisch bereinigt (alle downstream Phasen geloescht)\n4. Auto-Advance laeuft automatisch bis zum naechsten Approval Gate\n\n## Hook-Architektur\n\nAlle Hooks sind **Plugin-Level** (in `hooks.json`). Skill-Level Hooks in Plugins feuern nicht zuverlaessig (GitHub #17688).\n\n| Hook | Script | Funktion |\n|------|--------|----------|\n| **Stop** | `wf_orchestrator.sh` | Ralph-Loop: Verify â†’ Advance/Retry â†’ Agent-Dispatch |\n| **UserPromptSubmit** | `wf_user_prompt.sh` | Approval Gate Context + Rollback-Optionen |\n| **PreToolUse/Bash** | `guard_git_push.sh` | Blockiert Push ohne pushApproved |\n| **PreToolUse/Edit\\|Write** | `block_orchestrator_code_edit.sh` | Blockiert Code-Aenderungen im Orchestrator |\n| **PreToolUse/Read** | `block_orchestrator_code_read.sh` | Blockiert Code-Lesen im Orchestrator |\n| **PreToolUse/Task** | `block_orchestrator_explore.sh` | Blockiert Explore/general-purpose im Orchestrator |\n| **SubagentStart** | `subagent_start.sh` | Setzt `.subagent-active` Marker |\n| **SubagentStop** | `subagent_done.sh` | WIP-Commits + Compact-Report + Marker-Cleanup |\n| **SessionStart** | `session_recovery.sh` | Recovery nach Session-Start UND Compaction |\n\n### Orchestrator-Blocker (v3.9.0)\n\nDie PreToolUse-Blocker verhindern, dass der Orchestrator Code direkt liest/schreibt. Vier Schichten:\n\n1. **Ownership Guard** â€” Nur bei aktivem `bytA-feature` Workflow mit Status `active`/`paused`/`awaiting_approval`\n2. **Session Isolation (v3.9.2)** â€” `ownerSessionId` in `workflow-state.json` identifiziert die Workflow-Session. Andere Sessions (z.B. fuer Issue-Erstellung) werden NICHT blockiert. `session_id` ist ein Common Input Field in jedem Hook-Event.\n3. **Subagent-Active Marker** â€” `SubagentStart` setzt `.workflow/.subagent-active`, `SubagentStop` entfernt ihn. Blocker erlauben Tool-Aufrufe wenn der Marker existiert (Subagents DUERFEN Code bearbeiten)\n4. **JSON deny Pattern** â€” `permissionDecision: \"deny\"` statt `exit 2` (zuverlaessiger, siehe GitHub #13744)\n\nSession-Lifecycle:\n- **Workflow-Start**: Stop-Hook setzt `ownerSessionId` beim ersten Fire\n- **Resume**: SessionStart-Hook aktualisiert `ownerSessionId` (neue ID bei Resume, GitHub #8069)\n- **Compact**: Gleiche Session-ID, kein Update noetig\n\n### Compact Recovery (v3.9.0)\n\nNach Context-Compaction verliert Claude die SKILL.md-Instruktionen. Der `SessionStart` Hook erkennt `source=compact` und re-injiziert starke Transport-Layer-Instruktionen:\n\n- \"Du bist ein TRANSPORT-LAYER â€” sage nur Done.\"\n- \"Der Stop-Hook uebernimmt ALLES\"\n- PreToolUse-Blocker blockieren Code-Zugriff deterministisch\n- Kein `/bytA:feature` Aufruf noetig (wuerde von wf_cleanup.sh blockiert)\n\n## Agents\n\n| Agent | Phase | Aufgabe |\n|-------|-------|---------|\n| architect-planner | 0 | Technical Specification, 5x Warum, Architektur |\n| ui-designer | 1 | HTML Wireframes mit Angular Material + data-testid |\n| api-architect | 2 | REST API Design (Markdown-Sketch, kein YAML) |\n| postgresql-architect | 3 | Flyway SQL Migrations, Schema, Indexes |\n| spring-boot-developer | 4 | Spring Boot 4 Backend (Controller, Service, Tests) |\n| angular-frontend-developer | 5 | Angular 21 Frontend (Signals, Standalone Components) |\n| test-engineer | 6 | E2E + Integration Tests (Playwright, JUnit, Jasmine) |\n| security-auditor | 7 | OWASP Top 10 Security Audit |\n| code-reviewer | 8 | Code Quality Gate (SOLID, Coverage, Architecture) |\n| architect-reviewer | - | Eskalation bei Architektur-Concerns |\n\n## Externe Verifikation (kein LLM!)\n\nDone-Kriterien werden von `wf_verify.sh` extern geprueft:\n\n| Phase | Pruefung | Methode |\n|-------|----------|---------|\n| 0 | Spec-Datei | `ls .workflow/specs/*-ph00-*.md` |\n| 1 | Wireframe | `ls wireframes/issue-*.html` |\n| 2 | API-Spec | `ls .workflow/specs/*-ph02-*.md` |\n| 3 | Migration | `ls backend/.../V*.sql` |\n| 4 | Backend-Report | `ls .workflow/specs/*-ph04-*.md` |\n| 5 | Frontend-Report | `ls .workflow/specs/*-ph05-*.md` |\n| 6 | Tests bestanden | `jq .context.testResults.allPassed` + `ls .workflow/specs/*-ph06-*.md` |\n| 7 | Audit-Datei | `ls .workflow/specs/*-ph07-*.md` |\n| 8 | Review-Datei | `ls .workflow/specs/*-ph08-*.md` |\n| 9 | PR URL | `jq .phases[\"9\"].prUrl` |\n\n### Compound-Kriterien (v3.3.0)\n\nPhase 6 nutzt ein Compound-Kriterium (`+` Separator): STATE und GLOB muessen BEIDE bestanden werden.\n`wf_verify.sh` unterstuetzt beliebige Kombinationen: `STATE:...+GLOB:...+VERIFY:...`\n\n### Status-Bypass Guard (v3.3.0)\n\nDer Stop-Hook (`wf_orchestrator.sh`) prueft GLOB-Kriterien auch im `awaiting_approval` Status.\nVerhindert, dass ein LLM die externe Verifikation umgeht, indem es `status = \"awaiting_approval\"` setzt,\nbevor der Shell-Orchestrator verifizieren kann. Bei fehlgeschlagenem GLOB â†’ Reset auf `active` â†’ Ralph-Loop.\n\n### Hook CWD Fix (v3.5.0)\n\nAlle Hook-Scripts lesen `cwd` aus dem Hook-Input-JSON (stdin) und wechseln ins Projekt-Root\nbevor sie auf `.workflow/` zugreifen. Claude Code kann Hooks von einem beliebigen Working Directory\nstarten â€” ohne diesen Fix finden die Scripts die Workflow-Dateien nicht und beenden sich lautlos.\n\nDer Stop-Hook (`wf_orchestrator.sh`) loggt zusaetzlich nach `/tmp/bytA-orchestrator-debug.log`\nfuer Fehlerdiagnose (CWD vorher/nachher, Workflow-Datei-Existenz, ERR-Trap mit Zeilennummer).\n\n### Workflow Ownership Guard (v3.6.0)\n\nAlle 5 Plugin-Level-Hooks pruefen `workflow == \"bytA-feature\"` bevor sie aktiv werden.\nPlugin-Level Hooks feuern **global** fuer JEDES Event, unabhaengig davon welches Plugin/Skill\nden Workflow gestartet hat. Ohne diesen Guard koennen andere Plugins (z.B. byt8) denselben\n`workflow-state.json` lesen/schreiben und eine Race Condition + State-Corruption verursachen.\n\nBetroffene Scripts: `wf_orchestrator.sh`, `wf_user_prompt.sh`, `subagent_done.sh`,\n`session_recovery.sh`, `guard_git_push.sh`.\n\n### Deterministic Approval-Advance (v3.7.0)\n\nAlle Approval-Phasen (0, 1, 7, 8, 9) nutzen `wf_advance.sh` fuer deterministische State-Manipulation.\nClaude fuehrt nur noch **einen einzigen Bash-Befehl** aus statt 3-4 manuelle jq-Befehle:\n\n```bash\nwf_advance.sh approve              # User approved â†’ naechste Phase\nwf_advance.sh feedback 'MESSAGE'   # User will Aenderungen â†’ gleiche Phase nochmal\nwf_advance.sh rollback 4 'MESSAGE' # Rollback zu Phase 4 mit Feedback\nwf_advance.sh complete             # Workflow abschliessen (nach Push+PR)\n```\n\nDas Script uebernimmt: State-Update, Context-Cleanup, Spec-Cleanup, Prompt-Bau via `wf_prompt_builder.sh`,\nund gibt eine `EXECUTE: Task(bytA:agent, 'prompt')` Anweisung aus die Claude direkt ausfuehrt.\n\n### Phase Skipping (v3.3.0)\n\nPhase 0 (architect-planner) kann Phasen als `\"skipped\"` markieren, wenn sie nicht benoetigt werden\n(z.B. keine DB-Aenderungen â†’ Phase 3 skippen). Der Orchestrator (`wf_orchestrator.sh`) erkennt\npre-geskippte Phasen und ueberspringt sie automatisch â€” auch ueber APPROVAL-Gates hinweg.\n\nSkippbare Phasen: 1 (Wireframes), 2 (API), 3 (DB), 4 (Backend), 5 (Frontend).\nNicht skippbar: 0 (Spec), 6 (Tests), 7 (Security), 8 (Review), 9 (Push & PR).\n\n### Agent-Reports (MD-Dateien)\n\nJeder Agent schreibt eine MD-Datei in `.workflow/specs/` mit seinem vollstaendigen Report.\nDownstream-Agents lesen diese Dateien selbst via Read-Tool (Boomerang: isolierter Context).\nDer Orchestrator sieht nur den **Dateipfad** (wenige Bytes) â€” kein Context-Wachstum.\n\n```\n.workflow/specs/\nâ”œâ”€â”€ issue-42-ph00-architect-planner.md     â† Technical Spec\nâ”œâ”€â”€ issue-42-ph02-api-architect.md         â† API Design\nâ”œâ”€â”€ issue-42-ph03-postgresql-architect.md   â† Database Design\nâ”œâ”€â”€ issue-42-ph04-spring-boot-developer.md  â† Backend Report\nâ”œâ”€â”€ issue-42-ph05-angular-frontend-developer.md â† Frontend Report\nâ”œâ”€â”€ issue-42-ph06-test-engineer.md         â† Test Report\nâ”œâ”€â”€ issue-42-ph07-security-auditor.md      â† Security Audit\nâ””â”€â”€ issue-42-ph08-code-reviewer.md         â† Code Review\n```\n\n## Struktur\n\n```\nbytA/\nâ”œâ”€â”€ .claude-plugin/plugin.json\nâ”œâ”€â”€ .mcp.json                          # MCP Server (context7, angular-cli)\nâ”œâ”€â”€ agents/                            # 10 spezialisierte Agents\nâ”‚   â”œâ”€â”€ architect-planner.md\nâ”‚   â”œâ”€â”€ ui-designer.md\nâ”‚   â”œâ”€â”€ api-architect.md\nâ”‚   â”œâ”€â”€ postgresql-architect.md\nâ”‚   â”œâ”€â”€ spring-boot-developer.md\nâ”‚   â”œâ”€â”€ angular-frontend-developer.md\nâ”‚   â”œâ”€â”€ test-engineer.md\nâ”‚   â”œâ”€â”€ security-auditor.md\nâ”‚   â”œâ”€â”€ code-reviewer.md\nâ”‚   â””â”€â”€ architect-reviewer.md\nâ”œâ”€â”€ commands/\nâ”‚   â”œâ”€â”€ feature.md                     # /bytA:feature Entry Point\nâ”‚   â””â”€â”€ prd-generator.md               # /bytA:prd-generator Entry Point\nâ”œâ”€â”€ config/\nâ”‚   â””â”€â”€ phases.conf                    # Deklarative Phase-Definition\nâ”œâ”€â”€ docs/\nâ”‚   â””â”€â”€ REFACTORING-PROPOSAL-BOOMERANG-RALPH.md\nâ”œâ”€â”€ hooks/\nâ”‚   â””â”€â”€ hooks.json                     # 9 Plugin-Level Hooks\nâ”œâ”€â”€ scripts/\nâ”‚   â”œâ”€â”€ wf_orchestrator.sh             # Stop Hook: Ralph-Loop Orchestrator\nâ”‚   â”œâ”€â”€ wf_verify.sh                   # Externe Done-Verifikation\nâ”‚   â”œâ”€â”€ wf_advance.sh                  # Deterministic Approval-Advance (v3.7.0)\nâ”‚   â”œâ”€â”€ wf_prompt_builder.sh           # Deterministische Agent-Prompts\nâ”‚   â”œâ”€â”€ wf_user_prompt.sh              # UserPromptSubmit: Approval Gates\nâ”‚   â”œâ”€â”€ wf_cleanup.sh                  # Startup: Workflow aufraumen\nâ”‚   â”œâ”€â”€ guard_git_push.sh              # PreToolUse: Push Guard\nâ”‚   â”œâ”€â”€ block_orchestrator_code_edit.sh # PreToolUse: Code-Edit Blocker (v3.9.0)\nâ”‚   â”œâ”€â”€ block_orchestrator_code_read.sh # PreToolUse: Code-Read Blocker (v3.9.0)\nâ”‚   â”œâ”€â”€ block_orchestrator_explore.sh  # PreToolUse: Explore Blocker (v3.9.0)\nâ”‚   â”œâ”€â”€ session_recovery.sh           # SessionStart: Recovery + Compact (v3.9.0)\nâ”‚   â”œâ”€â”€ subagent_start.sh             # SubagentStart: Marker setzen (v3.9.0)\nâ”‚   â””â”€â”€ subagent_done.sh              # SubagentStop: WIP Commits + Marker Cleanup\nâ”œâ”€â”€ skills/\nâ”‚   â”œâ”€â”€ feature/\nâ”‚   â”‚   â””â”€â”€ SKILL.md                   # Radikal vereinfacht (~170 Zeilen)\nâ”‚   â””â”€â”€ prd-generator/\nâ”‚       â””â”€â”€ SKILL.md                   # PRD Generator\nâ””â”€â”€ README.md\n```\n\n## Unterschied zu byt8\n\n| Aspekt | byt8 | bytA |\n|--------|------|------|\n| Orchestrator | Claude (LLM) mit SKILL.md | Bash-Script (wf_orchestrator.sh) |\n| Done-Pruefung | LLM interpretiert Agent-Output | Shell prueft Dateien/Exit-Codes |\n| Context-Wachstum | Monoton steigend | Konstant (~2.5 KB) |\n| Retry-Logik | Stop Hook + Block Counter | Ralph-Loop (explicit retry) |\n| Rollback | LLM fuehrt jq-Befehle aus | wf_advance.sh (deterministisch) |\n| SKILL.md | ~270 Zeilen Orchestrator-Logik | ~170 Zeilen (Transport-Layer) |\n\n## Troubleshooting\n\n### Plugin pruefen\n\n```bash\n# 1. Cache leeren\nrm -rf ~/.claude/plugins/cache/byteagenten-marketplace/\n\n# 2. Claude starten, Hooks pruefen\nclaude\n/hooks   # bytA-Hooks muessen sichtbar sein!\n```\n\n### Workflow laeuft nicht (Claude ignoriert SKILL.md)\n\nMoegliche Ursachen:\n1. **Plugin nicht installiert** â†’ `/hooks` zeigt keine bytA-Hooks â†’ Plugin neu installieren\n2. **Plugin-Cache veraltet** â†’ Cache leeren (siehe oben)\n3. **Session nach Cache-Refresh nicht neu gestartet** â†’ Hooks zeigen auf alten Pfad â†’ Session komplett neu starten\n\n### Hooks pruefen\n\nAlle Hooks sind Plugin-Level (in `hooks.json`). Nach `/hooks` muessen diese sichtbar sein:\n- Stop: `wf_orchestrator.sh`\n- UserPromptSubmit: `wf_user_prompt.sh`\n- PreToolUse/Bash: `guard_git_push.sh`\n- PreToolUse/Edit|Write: `block_orchestrator_code_edit.sh`\n- PreToolUse/Read: `block_orchestrator_code_read.sh`\n- PreToolUse/Task: `block_orchestrator_explore.sh`\n- SubagentStart: `subagent_start.sh`\n- SubagentStop: `subagent_done.sh`\n- SessionStart: `session_recovery.sh`\n\nVerbose-Modus: `Ctrl+O` in Claude Code zeigt Hook-Ausgaben.\nDebug-Modus: `claude --debug` zeigt detaillierte Hook-Ausfuehrung.\n\n## Quellen\n\n- [Boomerang Tasks â€” Roo Code](https://docs.roocode.com/features/boomerang-tasks)\n- [Ralph Loop â€” Geoffrey Huntley](https://ghuntley.com/loop/)\n- [Claude Code Hooks](https://code.claude.com/docs/en/hooks)\n- [Claude Code Sub-Agents](https://code.claude.com/docs/en/sub-agents)\n",
        "plugins/bytM/README.md": "# bytM Plugin\n\n**Version 1.5.0** | TeamCreate + Hub-and-Spoke Planning mit Cross-Validation\n\nFull-Stack Development fuer Angular 21 + Spring Boot 4 mit TeamCreate, SendMessage-Kommunikation und runden-frischen Agents.\n\n## Architektur\n\nDer Orchestrator ist ein **LLM Team Lead**. Pro Runde werden frische Agents gespawnt, die innerhalb der Runde via `SendMessage` kommunizieren. Zwischen Runden fliessen Informationen ueber `.workflow/specs/` Dateien.\n\n| Prinzip | Bedeutung |\n|---------|-----------|\n| **TeamCreate + SendMessage** | Agents kommunizieren direkt miteinander innerhalb einer Runde |\n| **Runden-frische Agents** | Jede Runde spawnt frische Agents â€” kein Context-Overflow |\n| **Hub-and-Spoke Planning** | 4 Spezialisten planen â†’ Architect konsolidiert |\n| **Spezialisierte Verify-Agents** | Test Engineer, Security Auditor, Code Reviewer als separate Spezialisten |\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                                                              â”‚\nâ”‚  Team Lead (SKILL.md, Delegate Mode)                         â”‚\nâ”‚  TeamCreate â†’ spawnt frische Agents pro Runde                â”‚\nâ”‚                                                              â”‚\nâ”‚  ROUND 1 â€” PLAN (Hub-and-Spoke):                             â”‚\nâ”‚                                                              â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚\nâ”‚  â”‚ Backend  â”‚  â”‚ Frontend â”‚  â”‚UI-Design â”‚  â”‚ Quality  â”‚     â”‚\nâ”‚  â”‚ Dev      â”‚  â”‚ Dev      â”‚  â”‚(optional)â”‚  â”‚ Engineer â”‚     â”‚\nâ”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â”‚\nâ”‚       â”‚             â”‚             â”‚             â”‚             â”‚\nâ”‚       â””â”€â”€â”€â”€ SendMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚\nâ”‚                     â”‚                                        â”‚\nâ”‚                     â–¼                                        â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                 â”‚\nâ”‚              â”‚  Architect  â”‚                                 â”‚\nâ”‚              â”‚ Konsolidiertâ”‚                                 â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                 â”‚\nâ”‚                                                              â”‚\nâ”‚  ROUND 2 â€” IMPLEMENT:                                        â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â†SendMessageâ†’  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚\nâ”‚  â”‚ Backend   â”‚                 â”‚ Frontend  â”‚                â”‚\nâ”‚  â”‚ Developer â”‚                 â”‚ Developer â”‚                â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚\nâ”‚                                                              â”‚\nâ”‚  ROUND 3 â€” VERIFY:                                           â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚\nâ”‚  â”‚   Test     â”‚  â”‚ Security  â”‚  â”‚   Code    â”‚               â”‚\nâ”‚  â”‚ Engineer   â”‚  â”‚ Auditor   â”‚  â”‚ Reviewer  â”‚               â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚\nâ”‚                                                              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Quick Start\n\n```\n/bytM:feature #42\n```\n\n## Commands\n\n| Command | Beschreibung |\n|---------|-------------|\n| `/bytM:feature` | Full-Stack Feature Workflow mit Hub-and-Spoke Planning |\n| `/bytM:prd-generator` | PRD-Generator: Product Requirements Documents + GitHub Issues |\n\n## Workflow: 4 Runden\n\n```\n/bytM:feature #42\n\nRound 0:   STARTUP      --- Issue laden, Model-Tier, Branch, UI-Designer wÃ¤hlen, TeamCreate\nRound 1:   PLAN          --- 4-5 Agents: 3-4 Spezialisten â†’ Architect konsolidiert\nRound 1.5: USER APPROVAL --- Du genehmigst die konsolidierte Spec    <-- DEIN INPUT\nRound 2:   IMPLEMENT     --- 2 Agents (Backend + Frontend) implementieren\nRound 3:   VERIFY        --- 3 Spezialisten (Test + Security + Code Review)\nRound 3.5: USER APPROVAL --- Du genehmigst das Ergebnis              <-- DEIN INPUT\nRound 4:   SHIP          --- Push & PR\n```\n\n### Round 1: PLAN â€” Hub-and-Spoke (4-5 Agents)\n\n3-4 Spezialisten planen parallel, senden Zusammenfassungen an den Architect (UI-Designer ist optional):\n\n| Agent | Plant | SendMessage an Architect |\n|-------|-------|--------------------------|\n| Backend Dev | DB-Schema, Services, Endpoints | *\"2 Entities, 3 Endpoints, Flyway V15\"* |\n| Frontend Dev | Components, Routing, State | *\"ReportListComponent, Route /reports, ReportService\"* |\n| UI-Designer *(optional)* | Wireframe HTML mit data-testid | *\"Wireframe fertig, 14 data-testid, Material Table\"* |\n| Test Engineer | E2E-Szenarien, Coverage | *\"8 Szenarien, 80% Coverage-Ziel\"* |\n\nDer **Architect** empfaengt alle Summaries (3 oder 4), prueft Konsistenz:\n\n```\nBackend: \"POST /api/reports erwartet {title, configId}\"\nFrontend: \"ReportService.create() sendet {title, config}\"\n                                              ^^^^^^^^\nArchitect erkennt: \"config\" vs \"configId\" â†’ Konflikt!\nArchitect â†’ Frontend: \"Bitte Feld zu 'configId' (UUID) anpassen\"\nFrontend â†’ Architect: \"Angepasst\"\nArchitect: Konsolidierte Spec schreiben â†’ Konflikt geloest\n```\n\n**Output:** Konsolidierte Tech Spec (`plan-consolidated.md`) + Einzel-Plaene + Wireframe\n\n### Round 1.5: USER APPROVAL\n\nDu siehst die konsolidierte Spec und genehmigst, aenderst oder brichst ab.\n\n### Round 2: IMPLEMENT (Scope-basiert: 1-2 Agents)\n\nDer Architect bestimmt den **Implementation Scope** in der konsolidierten Spec:\n\n| Scope | Agents | Beispiel |\n|-------|--------|----------|\n| `full-stack` | Backend + Frontend (2) | Neues Feature mit UI + API |\n| `backend-only` | Backend (1) | PDF-Export, neue API ohne UI |\n| `frontend-only` | Frontend (1) | UI-Redesign ohne API-Aenderung |\n\n**Nur betroffene Agents werden gespawnt** â€” kein Frontend-Agent bei reinem Backend-Feature.\n\n| Agent | Implementiert | Kommunikation |\n|-------|--------------|---------------|\n| Backend Dev | Entities, Services, Controller, Migrations, Tests | Kann Frontend fragen |\n| Frontend Dev | Components, Services, Routing, Tests, data-testid | Kann Backend fragen |\n\nAgents lesen die **konsolidierte Spec** von Disk. Koennen sich bei Unklarheiten per `SendMessage` abstimmen.\n\n### Round 3: VERIFY (3 Spezialisten)\n\n| Agent | Aufgabe | Ergebnis |\n|-------|---------|----------|\n| Test Engineer | E2E-Tests schreiben + ausfuehren, Coverage messen | `verify-test-engineer.md` |\n| Security Auditor | OWASP-Audit aller Aenderungen | `verify-security-auditor.md` |\n| Code Reviewer | Code Review + Build Gate (mvn verify, npm test, npm build) | `verify-code-reviewer.md` |\n\n### Round 3.5: USER APPROVAL\n\nDu siehst alle 3 Verify-Reports und genehmigst oder forderst Aenderungen an.\n\n### Round 4: SHIP\n\nTeam Lead: Build Gate â†’ Push â†’ PR erstellen â†’ TeamDelete â†’ PR-URL anzeigen.\n\n## Agent-Kommunikation\n\n| Runde | Kommunikations-Modell | Ueber |\n|-------|-----------------------|-------|\n| Plan | Hub-and-Spoke (Spezialisten â†’ Architect) | SendMessage |\n| Implement | Peer-to-Peer (Backend â†” Frontend) | SendMessage |\n| Verify | Unabhaengig (jeder prueft separat) | Nur â†’ Team Lead |\n| Zwischen Runden | Disk-basiert (Specs) | `.workflow/specs/` |\n\n## Wo muss ich als User approven?\n\n| Runde | Musst du approven? | Deine Optionen |\n|-------|-------------------|----------------|\n| Round 0: Startup | **Ja** (Infos geben) | Issue-Nr, Branch, Coverage, Model-Tier, UI-Designer (ja/nein) |\n| Round 1: Plan | Nein (automatisch) | â€” |\n| **Round 1.5** | **JA** | Genehmigen / Aendern / Abbrechen |\n| Round 2: Implement | Nein (automatisch) | â€” |\n| Round 3: Verify | Nein (automatisch) | â€” |\n| **Round 3.5** | **JA** | Genehmigen / Aendern / Rollback |\n| **Round 4: Ship** | **JA** (PR-Confirmation) | Push / Aendern |\n\n## Das Team\n\nBeim Start waehlt der User den **Model-Tier**:\n\n| Tier | Model | Fuer |\n|------|-------|------|\n| **fast** (default) | Sonnet | Standard-Features, CRUD, einfache UI |\n| **quality** | Opus | Komplexe Business-Logik, verschachtelte State-Patterns |\n\n| Agent | Domain | Runden |\n|-------|--------|--------|\n| **Architect** | Konsolidierung, API-Design, Konflikt-Resolution | Plan |\n| **Backend Dev** | Spring Boot, DB, Migrations, Tests | Plan, Implement |\n| **Frontend Dev** | Angular, Routing, State, Tests | Plan, Implement |\n| **UI-Designer** *(optional)* | Wireframes (HTML), Material Design, data-testid | Plan |\n| **Test Engineer** | Test-Strategie, E2E-Tests, Coverage | Plan, Verify |\n| **Security Auditor** | OWASP-Audit | Verify |\n| **Code Reviewer** | Code Quality, Build Gate | Verify |\n\n**Total: 9-10 Agent-Spawns** ueber 3 Runden (4-5 + 1-2 + 3), jeder mit frischem Context.\n\n## Hook-Architektur\n\n| Hook | Script | Funktion |\n|------|--------|----------|\n| **PreToolUse/Bash** | `guard_git_push.sh` | Blockiert Push ohne pushApproved |\n| **TaskCompleted** | `verify_task.sh` | Prueft ob Output-Dateien existieren |\n| **TeammateIdle** | `wip_commit.sh` | WIP-Commits bei Agent-Idle |\n| **SessionStart** | `session_recovery.sh` | Compaction Recovery + Session-ID-Tracking |\n| **Notification/idle_prompt** | `play_notification.sh` | Sound wenn User-Input noetig |\n| **Stop** | `play_completion.sh` | Sound wenn Workflow abgeschlossen |\n\n## Spec-Dateien\n\n| Runde | Pattern | Beispiel |\n|-------|---------|---------|\n| Plan (Spezialisten) | `issue-{N}-plan-{role}.md` | `issue-42-plan-backend.md` |\n| Plan (UI) | `issue-{N}-plan-ui.md` | `issue-42-plan-ui.md` |\n| Plan (konsolidiert) | `issue-{N}-plan-consolidated.md` | `issue-42-plan-consolidated.md` |\n| Implement | `issue-{N}-impl-{role}.md` | `issue-42-impl-frontend.md` |\n| Verify | `issue-{N}-verify-{role}.md` | `issue-42-verify-security-auditor.md` |\n| Wireframes | `wireframes/issue-{N}-{slug}.html` | `wireframes/issue-42-reports.html` |\n\n## Koexistenz mit bytA\n\n- bytA: `workflow: \"bytA-feature\"` â€” `/bytA:feature`\n- bytM: `workflow: \"bytM-feature\"` â€” `/bytM:feature`\n- Alle Hooks pruefen das `workflow` Feld (Ownership Guard)\n- Kein Konflikt moeglich\n"
      },
      "plugins": [
        {
          "name": "byt8",
          "description": "Full-stack development toolkit for Angular 21 + Spring Boot 4 applications with 10-phase workflow",
          "source": "./plugins/byt8",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add byteAgenten/byteagenten-marketplace",
            "/plugin install byt8@byteagenten-marketplace"
          ]
        },
        {
          "name": "bytA",
          "description": "Agent-based workflow orchestration for Angular + Spring Boot (experimental)",
          "source": "./plugins/bytA",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add byteAgenten/byteagenten-marketplace",
            "/plugin install bytA@byteagenten-marketplace"
          ]
        },
        {
          "name": "bytM",
          "description": "Agent Team-based full-stack development with cross-validation (native Claude Code Agent Teams)",
          "source": "./plugins/bytM",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add byteAgenten/byteagenten-marketplace",
            "/plugin install bytM@byteagenten-marketplace"
          ]
        }
      ]
    }
  ]
}