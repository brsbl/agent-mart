{
  "author": {
    "id": "firstloophq",
    "display_name": "Firstloop",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/209379067?v=4",
    "url": "https://github.com/firstloophq",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 0,
      "total_skills": 4,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "firstloop-claude-code-plugins",
      "version": "1.0.1",
      "description": "Bundled plugins for Claude Code from Firstloop",
      "owner_info": {
        "name": "Firstloop",
        "email": "jake@firstloop.ai"
      },
      "keywords": [],
      "repo_full_name": "firstloophq/claude-code-plugins",
      "repo_url": "https://github.com/firstloophq/claude-code-plugins",
      "repo_description": "Claude Code plug-ins we use across projects at Firstloop",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-29T19:18:22Z",
        "created_at": "2026-01-16T17:08:16Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 692
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/core",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/core/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/core/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 204
        },
        {
          "path": "plugins/core/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/core/skills/manage-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/core/skills/manage-skills/SKILL.md",
          "type": "blob",
          "size": 8333
        },
        {
          "path": "plugins/core/skills/manage-skills/advanced-patterns.md",
          "type": "blob",
          "size": 2489
        },
        {
          "path": "plugins/core/skills/manage-skills/frontmatter-rules.md",
          "type": "blob",
          "size": 998
        },
        {
          "path": "plugins/core/skills/manage-skills/meta-skill-management.md",
          "type": "blob",
          "size": 4891
        },
        {
          "path": "plugins/core/skills/pm",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/core/skills/pm/SKILL.md",
          "type": "blob",
          "size": 3956
        },
        {
          "path": "plugins/monotemplate",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/monotemplate/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/monotemplate/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 209
        },
        {
          "path": "plugins/monotemplate/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/monotemplate/skills/crud",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/monotemplate/skills/crud/SKILL.md",
          "type": "blob",
          "size": 2472
        },
        {
          "path": "plugins/monotemplate/skills/crud/reference.md",
          "type": "blob",
          "size": 17222
        },
        {
          "path": "plugins/monotemplate/skills/docker-troubleshoot",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/monotemplate/skills/docker-troubleshoot/SKILL.md",
          "type": "blob",
          "size": 1725
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"firstloop-claude-code-plugins\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Bundled plugins for Claude Code from Firstloop\",\n  \"owner\": {\n    \"name\": \"Firstloop\",\n    \"email\": \"jake@firstloop.ai\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"core\",\n      \"description\": \"Core Claude Code plugins for Firstloop projects\",\n      \"source\": \"./plugins/core\",\n      \"category\": \"development\"\n    },\n    {\n      \"name\": \"monotemplate\",\n      \"description\": \"CRUD architecture management for monorepo templates with layered patterns\",\n      \"source\": \"./plugins/monotemplate\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "plugins/core/.claude-plugin/plugin.json": "{\n  \"name\": \"core\",\n  \"version\": \"0.2.0\",\n  \"description\": \"Claude Code Plugin for Firstloop monorepo template\",\n  \"repository\": \"https://github.com/firstloophq/claude-code-plugins\",\n  \"license\": \"MIT\"\n}\n",
        "plugins/core/skills/manage-skills/SKILL.md": "---\nname: manage-skills\ndescription: Create and improve Claude Skills with proper structure, frontmatter, and best practices. Use when creating new skills, improving existing skills, refactoring skill content, or scaffolding skill files.\n---\n\n# Managing Claude Skills\n\n## Before Creating a Skill\n\n### Where does this skill belong?\n\n**Firstloop shared skill** (default assumption):\n- Skills for `core` or `monotemplate` plugins\n- Improvements to existing shared skills\n- → Create a GitHub issue in `firstloophq/claude-code-plugins` (see [meta-skill-management.md](meta-skill-management.md))\n\n**Local project skill**:\n- Project-specific workflows\n- Custom skills for a single codebase\n- User explicitly requests a \"local skill\"\n- → Create directly in `.claude/skills/<skill-name>/SKILL.md`\n\n### Quick Reference\n\n| Scenario | Action |\n|----------|--------|\n| \"Create a skill for monotemplate\" | GitHub issue |\n| \"Improve the crud skill\" | GitHub issue |\n| \"Add a docker skill to the plugin\" | GitHub issue |\n| \"Create a local skill for this project\" | Create in `.claude/skills/` |\n| \"Add a skill just for this repo\" | Create in `.claude/skills/` |\n\n## Creating Skills\n\n### Quick Start\n\nCreate a skill by making a `SKILL.md` file in `.claude/skills/<skill-name>/`:\n\n```markdown\n---\nname: my-skill-name\ndescription: Brief description of what this skill does and when to use it.\n---\n\n# My Skill Name\n\n## Instructions\n[Your instructions here]\n```\n\n## Required Structure\n\nEvery skill needs:\n\n1. **SKILL.md file** with YAML frontmatter\n2. **name field**: lowercase letters, numbers, hyphens only (max 64 chars)\n3. **description field**: what the skill does AND when to use it (max 1024 chars)\n\n## Skill Directory Layout\n\n```\n.claude/skills/\n└── my-skill/\n    ├── SKILL.md          # Main instructions (required)\n    ├── reference.md      # Additional details (optional)\n    └── scripts/          # Utility scripts (optional)\n        └── helper.py\n```\n\n## Writing the Description\n\nThe description is critical for skill discovery. Include:\n- What the skill does\n- When Claude should use it\n- Key trigger words\n\n**Good example:**\n```yaml\ndescription: Generate git commit messages by analyzing staged changes. Use when committing code, writing commit messages, or reviewing diffs.\n```\n\n**Bad example:**\n```yaml\ndescription: Helps with git stuff\n```\n\n## Skill Templates\n\n### Template 1: Instructions-Only Skill\n\nFor guidance-based skills without code:\n\n```markdown\n---\nname: code-review\ndescription: Review code for bugs, style, and best practices. Use when reviewing pull requests, analyzing code quality, or checking for issues.\n---\n\n# Code Review\n\n## Process\n\n1. Read the code thoroughly\n2. Check for bugs and edge cases\n3. Verify style consistency\n4. Suggest improvements\n\n## Checklist\n\n- [ ] No obvious bugs\n- [ ] Error handling present\n- [ ] Consistent naming\n- [ ] No security issues\n```\n\n### Template 2: Skill with Scripts\n\nFor skills that include executable utilities:\n\n```markdown\n---\nname: data-validation\ndescription: Validate data files against schemas. Use when checking CSV, JSON, or config file formats.\n---\n\n# Data Validation\n\n## Usage\n\nRun validation:\n```bash\npython scripts/validate.py input.json schema.json\n```\n\n## Scripts\n\n- **validate.py**: Check data against schema\n- **format.py**: Auto-fix formatting issues\n\nSee [reference.md](reference.md) for schema format details.\n```\n\n### Template 3: Domain-Specific Skill\n\nFor skills with extensive reference material:\n\n```markdown\n---\nname: api-integration\ndescription: Integrate with the Acme API. Use when calling Acme endpoints, handling Acme webhooks, or processing Acme data.\n---\n\n# Acme API Integration\n\n## Quick Reference\n\nBase URL: `https://api.acme.com/v2`\nAuth: Bearer token in header\n\n## Common Operations\n\n**Get user**: `GET /users/{id}`\n**Create order**: `POST /orders`\n\nFor complete endpoint docs, see [endpoints.md](endpoints.md).\nFor authentication details, see [auth.md](auth.md).\n```\n\n## Best Practices\n\n### Be Concise\nClaude is smart. Only include information Claude doesn't already know.\n\n### Use Progressive Disclosure\n- Keep SKILL.md under 500 lines\n- Put detailed reference material in separate files\n- Link with relative paths: `[details](reference.md)`\n\n### Set Appropriate Freedom\n\n**High freedom** (guidelines):\n```markdown\nReview the code for potential issues and suggest improvements.\n```\n\n**Low freedom** (specific steps):\n```markdown\nRun exactly: `python scripts/migrate.py --verify --backup`\nDo not modify the command.\n```\n\n### Include Workflows for Complex Tasks\n\n```markdown\n## Deployment Workflow\n\n1. Run tests: `bun test`\n2. Build: `bun run build`\n3. If build fails, fix errors and repeat from step 1\n4. Deploy: `bun run deploy`\n```\n\n## Common Mistakes to Avoid\n\n- Using vague descriptions\n- Including time-sensitive information\n- Using Windows-style paths (use forward slashes)\n- Offering too many options without a default\n- Deeply nesting file references (keep one level deep)\n\n## File Naming\n\nUse descriptive, lowercase names with hyphens:\n- `api-reference.md` (good)\n- `APIREF.md` (bad)\n- `scripts/validate-schema.py` (good)\n- `scripts/vs.py` (bad)\n\n## Testing Your Skill\n\n1. Create the skill files\n2. Start a new conversation\n3. Make a request that should trigger the skill\n4. Verify Claude uses the skill correctly\n5. Iterate based on behavior\n\n---\n\n## Improving Existing Skills\n\n### When to Improve a Skill\n\n- Skill produces inconsistent results\n- Instructions are ambiguous or unclear\n- Missing edge cases or workflows\n- Description doesn't trigger skill when expected\n- Skill has grown too large and needs refactoring\n\n### Improvement Process\n\n1. **Read the existing skill** - Understand current structure and intent\n2. **Identify the problem** - What's not working or missing?\n3. **Make targeted changes** - Don't rewrite unless necessary\n4. **Test the changes** - Verify improvements in a new conversation\n\n### Common Improvements\n\n#### Sharpen the Description\n\nIf the skill isn't triggering when expected, improve the description:\n\n```yaml\n# Before - too vague\ndescription: Helps with database tasks\n\n# After - specific triggers\ndescription: Generate and run database migrations. Use when creating tables, modifying schemas, or updating database structure.\n```\n\n#### Add Missing Workflows\n\nIf Claude doesn't handle certain cases, add explicit workflows:\n\n```markdown\n## Edge Cases\n\n### Empty Input\nIf input is empty, prompt user for required data before proceeding.\n\n### Existing File Conflict\nIf file already exists, ask user whether to overwrite, merge, or abort.\n```\n\n#### Reduce Ambiguity\n\nReplace vague instructions with specific ones:\n\n```markdown\n# Before - ambiguous\nReview the code and suggest improvements.\n\n# After - specific\nReview the code for:\n1. Security vulnerabilities (injection, XSS, auth issues)\n2. Performance problems (N+1 queries, unnecessary loops)\n3. Error handling gaps\n\nFor each issue found, provide:\n- Location (file:line)\n- Problem description\n- Suggested fix\n```\n\n#### Split Large Skills\n\nIf a skill exceeds 500 lines, consider:\n\n1. Moving reference material to separate files\n2. Splitting into multiple focused skills\n3. Using a reference folder structure:\n\n```\nmy-skill/\n├── SKILL.md           # Core instructions only\n└── reference/\n    ├── api.md         # API details\n    ├── examples.md    # Extended examples\n    └── errors.md      # Error handling guide\n```\n\n#### Improve Examples\n\nAdd before/after examples to clarify expected behavior:\n\n```markdown\n## Examples\n\n**Input**: User asks \"format this JSON\"\n**Expected**: Format JSON with 2-space indentation, sorted keys\n\n**Input**: User provides malformed JSON\n**Expected**: Report specific syntax error location, suggest fix\n```\n\n### Refactoring Checklist\n\n- [ ] Description clearly states what and when\n- [ ] Instructions are unambiguous\n- [ ] Edge cases are documented\n- [ ] Examples demonstrate expected behavior\n- [ ] Reference material is in separate files\n- [ ] File is under 500 lines\n\n## Additional Resources\n\n- [Frontmatter Rules](frontmatter-rules.md) - Detailed YAML validation rules\n- [Advanced Patterns](advanced-patterns.md) - Feedback loops, workflows, scripts\n- [Meta Skill Management](meta-skill-management.md) - How to contribute improvements to shared skills\n\n",
        "plugins/core/skills/manage-skills/advanced-patterns.md": "# Advanced Skill Patterns\n\n## Feedback Loop Pattern\n\nFor tasks requiring validation:\n\n```markdown\n## Document Processing\n\n1. Process the document\n2. **Validate**: Run `python scripts/validate.py output/`\n3. If validation fails:\n   - Review error messages\n   - Fix issues\n   - Run validation again\n4. Only proceed when validation passes\n```\n\n## Conditional Workflow Pattern\n\nGuide through decision points:\n\n```markdown\n## Processing Workflow\n\nDetermine the task type:\n\n**New file?** → Follow \"Creation workflow\"\n**Existing file?** → Follow \"Editing workflow\"\n\n### Creation Workflow\n1. Use template from `templates/`\n2. Fill in required fields\n3. Validate output\n\n### Editing Workflow\n1. Read existing file\n2. Make targeted changes\n3. Validate changes\n```\n\n## Checklist Pattern\n\nFor multi-step tasks:\n\n```markdown\n## Release Checklist\n\nCopy and track progress:\n\n```\nRelease Progress:\n- [ ] Update version number\n- [ ] Run full test suite\n- [ ] Update changelog\n- [ ] Build artifacts\n- [ ] Tag release\n```\n```\n\n## Examples Pattern\n\nFor quality-sensitive output:\n\n```markdown\n## Commit Messages\n\nFollow these examples:\n\n**Input**: Added user auth\n**Output**:\n```\nfeat(auth): implement JWT authentication\n\nAdd login endpoint and token validation\n```\n\n**Input**: Fixed date bug\n**Output**:\n```\nfix(reports): correct timezone handling\n\nUse UTC timestamps consistently\n```\n```\n\n## Domain Organization\n\nFor skills with multiple domains:\n\n```\nmy-skill/\n├── SKILL.md\n└── reference/\n    ├── domain-a.md\n    ├── domain-b.md\n    └── domain-c.md\n```\n\nSKILL.md points to relevant domain file based on task.\n\n## Utility Scripts Best Practices\n\n### Error Handling\n\n```python\ndef process(path):\n    try:\n        with open(path) as f:\n            return f.read()\n    except FileNotFoundError:\n        print(f\"Creating {path} with defaults\")\n        with open(path, 'w') as f:\n            f.write('')\n        return ''\n```\n\n### Document Constants\n\n```python\n# Timeout for HTTP requests (30s accounts for slow connections)\nREQUEST_TIMEOUT = 30\n\n# Retries balance reliability vs speed\nMAX_RETRIES = 3\n```\n\n## Verifiable Intermediate Outputs\n\nFor complex operations, create plan files:\n\n```markdown\n## Batch Update Process\n\n1. Analyze files → generate `changes.json`\n2. **Validate plan**: `python scripts/validate_plan.py changes.json`\n3. If valid, execute: `python scripts/apply_changes.py changes.json`\n4. Verify results\n```\n\nThis catches errors before changes are applied.\n\n",
        "plugins/core/skills/manage-skills/frontmatter-rules.md": "# YAML Frontmatter Rules\n\n## name Field\n\n**Requirements:**\n- Maximum 64 characters\n- Lowercase letters, numbers, and hyphens only\n- No XML tags\n- No reserved words: \"anthropic\", \"claude\"\n\n**Valid:**\n- `pdf-processing`\n- `git-commit-helper`\n- `data-validation-v2`\n\n**Invalid:**\n- `PDF_Processing` (uppercase, underscore)\n- `claude-helper` (reserved word)\n- `my skill` (space)\n\n## description Field\n\n**Requirements:**\n- Maximum 1024 characters\n- Cannot be empty\n- No XML tags\n- Write in third person\n\n**Structure:**\n1. What the skill does\n2. When to use it\n3. Key trigger words\n\n**Good:**\n```yaml\ndescription: Extract text and tables from PDF files. Use when working with PDFs, forms, or document extraction.\n```\n\n**Bad:**\n```yaml\ndescription: I help you with PDFs\n```\n(Uses first person \"I\")\n\n## Complete Example\n\n```yaml\n---\nname: code-formatter\ndescription: Format code files according to project style guides. Use when formatting code, fixing style issues, or preparing code for review.\n---\n```\n\n",
        "plugins/core/skills/manage-skills/meta-skill-management.md": "# Meta Skill Management\n\nThis document describes how to contribute improvements to shared skills in the claude-code-plugins repository.\n\n## Repository\n\n**GitHub**: https://github.com/firstloophq/claude-code-plugins\n\nAll shared skills (core and monotemplate plugins) are managed in this repository.\n\n## Creating Issues for Skill Improvements\n\nWhen you identify a skill that needs improvement, create a GitHub issue to track the work.\n\n### When to Create an Issue\n\n- Skill behavior is inconsistent or incorrect\n- Missing functionality or workflows\n- Description needs improvement for better triggering\n- Documentation is unclear or outdated\n- New skill idea for the shared plugins\n\n### Issue Format\n\n```bash\ngh issue create --repo firstloophq/claude-code-plugins --title \"Brief description\" --body \"$(cat <<'EOF'\n## Skill\n[Plugin name]:[Skill name] (e.g., `core:manage-skills` or `monotemplate:crud`)\n\n## Problem\n[What's wrong or missing]\n\n## Proposed Solution\n[How to fix or improve it]\n\n## Examples\n[Optional: Before/after examples or specific use cases]\nEOF\n)\"\n```\n\n### Triggering Claude to Work on Issues\n\nTag `@claude` in your issue or comment to trigger a GitHub Action that runs Claude on the issue automatically.\n\n**In the issue body:**\n```markdown\n@claude Please update the pm skill to add a new workflow for sprint planning.\n```\n\n**In a comment on an existing issue:**\n```markdown\n@claude Can you improve the description for the crud skill so it triggers when users ask about \"adding a new model\"?\n```\n\nClaude will read the issue context and respond with analysis, proposed changes, or a PR.\n\n### Labels\n\nUse appropriate labels when creating issues:\n- `skill-improvement` - Improving an existing skill\n- `new-skill` - Proposing a new skill\n- `bug` - Skill is broken or behaving incorrectly\n- `documentation` - Docs-only changes\n\n## Quick Commands\n\n**List open skill issues:**\n```bash\ngh issue list --repo firstloophq/claude-code-plugins\n```\n\n**View a specific issue:**\n```bash\ngh issue view <issue-number> --repo firstloophq/claude-code-plugins\n```\n\n**Create a PR for skill changes:**\n```bash\ngh pr create --repo firstloophq/claude-code-plugins --title \"Improve [skill-name]\" --body \"Fixes #<issue-number>\"\n```\n\n## Plugin Structure\n\n```\nclaude-code-plugins/\n├── plugins/\n│   ├── core/                    # Core skills for all projects\n│   │   └── skills/\n│   │       ├── manage-skills/   # This skill\n│   │       └── pm/              # Product manager skill\n│   └── monotemplate/            # Skills for monorepo template\n│       └── skills/\n│           └── crud/            # CRUD architecture skill\n```\n\n## Contribution Workflow\n\n1. **Identify improvement** - Notice a skill issue while working\n2. **Create issue** - Document the problem in the repo\n3. **Branch and fix** - Create a branch, make changes\n4. **Version bump** - Bump the plugin version (see below)\n5. **Test locally** - Verify the skill works as expected\n6. **Create PR** - Submit for review\n7. **Merge** - Once approved, merge to main\n\n## Version Bumping\n\nWhen improving a skill, you **must** bump the version of the plugin that contains the skill.\n\n### Plugin Version Location\n\nEach plugin has a `plugin.json` file in its `.claude-plugin` directory:\n\n```\nplugins/\n├── core/.claude-plugin/plugin.json           # Core plugin version\n└── monotemplate/.claude-plugin/plugin.json   # Monotemplate plugin version\n```\n\n### Version Format\n\nPlugins use [semantic versioning](https://semver.org/) (major.minor.patch):\n\n- **Patch** (0.1.0 → 0.1.1): Bug fixes, typo corrections\n- **Minor** (0.1.0 → 0.2.0): New features, skill improvements, new skills\n- **Major** (0.1.0 → 1.0.0): Breaking changes\n\n### Default: Minor Version Bump\n\n**Always use a minor version bump** unless:\n- The change is a simple bug fix or typo → use patch\n- The user explicitly requests a different bump level\n- The change introduces breaking behavior → use major\n\n### How to Bump the Version\n\n1. Identify which plugin contains the skill you're modifying\n2. Open the plugin's `plugin.json` file\n3. Update the `version` field\n\n**Example - Minor bump for core plugin skill improvement:**\n\n```json\n// Before\n{\n  \"name\": \"core\",\n  \"version\": \"0.1.1\",\n  ...\n}\n\n// After\n{\n  \"name\": \"core\",\n  \"version\": \"0.2.0\",\n  ...\n}\n```\n\n### Quick Commands\n\n**View current version:**\n```bash\ncat plugins/core/.claude-plugin/plugin.json | grep version\n```\n\n**Update version (using jq):**\n```bash\n# Minor bump\njq '.version = \"0.2.0\"' plugins/core/.claude-plugin/plugin.json > tmp.json && mv tmp.json plugins/core/.claude-plugin/plugin.json\n```\n\n### Version Bump Checklist\n\n- [ ] Identified the correct plugin (`core` or `monotemplate`)\n- [ ] Chose appropriate bump level (default: minor)\n- [ ] Updated the `version` field in `plugin.json`\n- [ ] Included version change in the commit\n",
        "plugins/core/skills/pm/SKILL.md": "---\nname: pm\ndescription: Product Manager skill for planning, implementing, and documenting features. Use when creating GitHub issues from specs, implementing planned work, or maintaining project documentation.\n---\n\n# Product Manager\n\nThis skill supports three core workflows: defining work (research → GitHub issues), implementing work, and documenting work.\n\n## 1. Define (Research → GitHub Issue)\n\nUse this workflow when the user wants to plan a feature or task.\n\n### Process\n\n1. **Accept the prompt** - Understand what the user wants to build or change\n2. **Research** - Explore the codebase to understand:\n   - Existing patterns and architecture\n   - Files that would be affected\n   - Dependencies and constraints\n3. **Ask clarifying questions** - **IMPORTANT: Always use the `AskUserQuestion` tool** to iterate with the user on:\n   - Scope and requirements\n   - Edge cases\n   - Acceptance criteria\n\n   > The `AskUserQuestion` tool provides structured prompts that ensure clear, consistent user interaction. Never use prose-based questions in your response—always use the tool.\n4. **Draft the plan** - Present a summary for user approval\n5. **Create GitHub issue** - Once approved, create the issue using `gh`\n\n### GitHub Issue Format\n\n```bash\ngh issue create --title \"Brief descriptive title\" --body \"$(cat <<'EOF'\n## Summary\n[1-2 sentence overview]\n\n## Requirements\n- [ ] Requirement 1\n- [ ] Requirement 2\n\n## Technical Approach\n[Brief description of implementation approach]\n\n## Files Affected\n- `path/to/file1.ts`\n- `path/to/file2.ts`\n\n## Acceptance Criteria\n- [ ] Criteria 1\n- [ ] Criteria 2\n\n## Notes\n[Any additional context, constraints, or considerations]\nEOF\n)\"\n```\n\n### Key Principles\n\n- **Use the `AskUserQuestion` tool** for all clarifying questions—never ask questions in prose\n- Keep asking questions until requirements are clear\n- Research the codebase before proposing solutions\n- Get explicit user approval before creating the issue\n- Be specific about files and changes in the technical approach\n\n---\n\n## 2. Implement\n\nUse this workflow when implementing a planned task (often from a GitHub issue).\n\n### Process\n\n1. Read and understand the plan/issue\n2. Implement the changes following existing codebase patterns\n3. Test the implementation\n4. Update documentation if needed (see Documentation workflow)\n\n*Note: Implementation details depend on the specific task and codebase patterns.*\n\n---\n\n## 3. Document\n\nUse this workflow when creating or updating project documentation.\n\n### Documentation Structure\n\nAll documentation lives in `/docs` at the repository root:\n\n```\ndocs/\n├── index.md           # Required: Index of all documentation\n├── architecture.md    # Example: System architecture\n├── api/               # Example: API documentation folder\n│   ├── endpoints.md\n│   └── authentication.md\n└── guides/            # Example: User/dev guides folder\n    └── getting-started.md\n```\n\n### Index File (docs/index.md)\n\nAlways maintain an index that lists all documentation:\n\n```markdown\n# Documentation Index\n\n## Overview\n- [Architecture](architecture.md) - System architecture overview\n\n## API\n- [Endpoints](api/endpoints.md) - API endpoint reference\n- [Authentication](api/authentication.md) - Auth flows and tokens\n\n## Guides\n- [Getting Started](guides/getting-started.md) - Setup and first steps\n```\n\n### Documentation Process\n\n1. **Check if docs/ exists** - Create it if needed\n2. **Read docs/index.md** - Understand existing documentation\n3. **Create/update the relevant doc** - Use clear markdown formatting\n4. **Update docs/index.md** - Add entry for new docs, update descriptions for changed docs\n\n### Documentation Guidelines\n\n- Use clear, descriptive file names (e.g., `api-authentication.md` not `auth.md`)\n- Keep related docs in folders (e.g., `api/`, `guides/`)\n- Always update the index when adding or removing docs\n- Use relative links between documentation files\n",
        "plugins/monotemplate/.claude-plugin/plugin.json": "{\n  \"name\": \"monotemplate\",\n  \"version\": \"0.1.1\",\n  \"description\": \"Core Claude Code plugins for Firstloop projects\",\n  \"repository\": \"https://github.com/firstloophq/claude-code-plugins\",\n  \"license\": \"MIT\"\n}\n",
        "plugins/monotemplate/skills/crud/SKILL.md": "---\r\nname: crud\r\ndescription: Add or modify CRUD entities following the layered architecture pattern. Use when adding new database models, creating API endpoints, or implementing data access layers.\r\n---\r\n\r\n# CRUD Architecture\r\n\r\nThis skill guides implementing CRUD operations following the layered architecture pattern.\r\n\r\n## Architecture Overview\r\n\r\n```\r\n1. Prisma Schema     → apps/server/src/db/prisma/schema.prisma\r\n2. Zod Schemas       → packages/common/src/types/<entity>/  (shared types)\r\n3. Repository Layer  → apps/server/src/repositories/\r\n4. Controller Layer  → apps/server/src/controllers/\r\n5. tRPC Router       → apps/server/src/routers/\r\n6. DI Container      → apps/server/src/di/container.ts\r\n```\r\n\r\n## Checklist for Adding New CRUD Entity\r\n\r\n- [ ] Add Prisma model in `apps/server/src/db/prisma/schema.prisma`\r\n- [ ] Run migration: `cd apps/server && bun run db:migrate`\r\n- [ ] Regenerate client: `cd apps/server && bun run db:generate`\r\n- [ ] Create Zod schemas in `packages/common/src/types/<entity>/`\r\n- [ ] Export from `packages/common/src/index.ts`\r\n- [ ] Create Repository in `apps/server/src/repositories/`\r\n- [ ] Create Controller in `apps/server/src/controllers/`\r\n- [ ] Create tRPC Router in `apps/server/src/routers/`\r\n- [ ] Register router in `apps/server/src/routers/_app.ts`\r\n- [ ] Add to DI container in `apps/server/src/di/container.ts`\r\n- [ ] Run build to verify: `cd apps/server && bun run build`\r\n\r\n## Critical Gotchas\r\n\r\n### 1. Clerk Integration\r\n- **Organization IDs are NOT UUIDs** - Clerk uses `org_xxxxx` format. Use `z.string().min(1)` not `z.string().uuid()`\r\n- **Don't pass organizationId in inputs** - Get it from `ctx.auth.orgId` in routers\r\n- **Webhooks may not have synced** (optional consideration) - Use `getOrCreate` patterns for users/orgs when webhooks aren't guaranteed\r\n\r\n### 2. Foreign Key Constraints (optional)\r\n- If entity has FK to `users` (e.g., `created_by`), user must exist first\r\n- Use `ensureUser` and `ensureOrganization` utilities before creating records\r\n- See `apps/server/src/utils/ensure-user.ts` and `ensure-organization.ts`\r\n\r\n### 3. tRPC Procedures\r\n- Use `authenticatedProcedure` for routes requiring login\r\n- Use `organizationProcedure` for routes requiring org context (auto-checks `ctx.auth.orgId`)\r\n- Don't use `publicProcedure` with manual auth checks\r\n- Procedures defined in `apps/server/src/trpc.ts`\r\n\r\nFor detailed implementation patterns, see [reference.md](reference.md).\r\n",
        "plugins/monotemplate/skills/crud/reference.md": "# CRUD Architecture Reference\r\n\r\nDetailed implementation patterns for each layer.\r\n\r\n## 1. Prisma Schema\r\n\r\n**File**: `apps/server/src/db/prisma/schema.prisma`\r\n\r\n```prisma\r\nmodel projects {\r\n  id              String   @id @default(uuid())\r\n  organization_id String\r\n  name            String\r\n  created_at      DateTime @default(now()) @db.Timestamptz(6)\r\n  updated_at      DateTime @updatedAt @db.Timestamptz(6)\r\n\r\n  organization  organizations   @relation(fields: [organization_id], references: [id], onDelete: Cascade, onUpdate: Cascade)\r\n  content_items content_items[]\r\n\r\n  @@index([organization_id], map: \"idx_projects_organization_id\")\r\n  @@index([name], map: \"idx_projects_name\")\r\n}\r\n```\r\n\r\n**Key Points:**\r\n- Use snake_case for database fields\r\n- Include `created_at` and `updated_at` timestamps\r\n- Use `@updatedAt` for automatic update tracking\r\n- Add `deleted_at` for soft deletes when needed\r\n- Use cascading deletes/updates on foreign keys\r\n- Add indexes for commonly queried fields\r\n- **Organizations use Clerk IDs** - `@id` without `@default(uuid())` for org table\r\n\r\n**After editing schema:**\r\n```bash\r\ncd apps/server && bun run db:migrate\r\ncd apps/server && bun run db:generate\r\n```\r\n\r\n---\r\n\r\n## 2. Zod Schemas\r\n\r\n**Location**: `packages/common/src/types/<entity>/` (shared between frontend and backend)\r\n\r\nCreate three files per entity:\r\n\r\n### Main Entity Schema\r\n**File**: `apps/server/src/types/project/project.ts`\r\n```typescript\r\nimport { z } from \"zod\";\r\n\r\nexport const projectSchema = z.object({\r\n  id: z.string().uuid(),\r\n  organizationId: z.string().uuid(),\r\n  name: z.string().min(1),\r\n  createdAt: z.date(),\r\n  updatedAt: z.date(),\r\n});\r\n\r\nexport type Project = z.infer<typeof projectSchema>;\r\n```\r\n\r\n### Create Input Schema\r\n**File**: `apps/server/src/types/project/create-project-input.ts`\r\n```typescript\r\nimport { z } from \"zod\";\r\n\r\nexport const createProjectInputSchema = z.object({\r\n  organizationId: z.string().uuid(),\r\n  name: z.string().min(1),\r\n});\r\n\r\nexport type CreateProjectInput = z.infer<typeof createProjectInputSchema>;\r\n```\r\n\r\n### Update Input Schema\r\n**File**: `apps/server/src/types/project/update-project-input.ts`\r\n```typescript\r\nimport { z } from \"zod\";\r\n\r\nexport const updateProjectInputSchema = z.object({\r\n  name: z.string().min(1).optional(),\r\n});\r\n\r\nexport type UpdateProjectInput = z.infer<typeof updateProjectInputSchema>;\r\n```\r\n\r\n### Index Export\r\n**File**: `apps/server/src/types/project/index.ts`\r\n```typescript\r\nexport * from \"./project\";\r\nexport * from \"./create-project-input\";\r\nexport * from \"./update-project-input\";\r\n```\r\n\r\n**Key Points:**\r\n- Use camelCase for TypeScript types (maps from snake_case in Prisma)\r\n- Export both Zod schema and inferred TypeScript type\r\n- Create separate schemas for: entity, create input, update input\r\n- Update input fields should be optional\r\n\r\n---\r\n\r\n## 3. Repository Layer\r\n\r\n**File**: `apps/server/src/repositories/ProjectsRepository.ts`\r\n\r\n```typescript\r\nimport { PrismaClient } from \"@server/generated/prisma\";\r\nimport { Result, success, failure } from \"common\";\r\nimport { Project } from \"@server/types/project\";\r\nimport { CreateProjectInput } from \"@server/types/project/create-project-input\";\r\nimport { UpdateProjectInput } from \"@server/types/project/update-project-input\";\r\n\r\nexport class ProjectsRepository {\r\n  private prisma: PrismaClient;\r\n\r\n  constructor({ prisma }: { prisma: PrismaClient }) {\r\n    this.prisma = prisma;\r\n  }\r\n\r\n  async create({ data }: { data: CreateProjectInput }): Promise<Result<Project>> {\r\n    try {\r\n      const result = await this.prisma.projects.create({\r\n        data: {\r\n          organization_id: data.organizationId,\r\n          name: data.name,\r\n        },\r\n      });\r\n      return success(mapPrismaProjectToProject(result));\r\n    } catch (error) {\r\n      return failure(\"Failed to create project\", error);\r\n    }\r\n  }\r\n\r\n  async getById({ id }: { id: string }): Promise<Result<Project>> {\r\n    try {\r\n      const result = await this.prisma.projects.findUnique({\r\n        where: { id },\r\n      });\r\n      if (!result) {\r\n        return failure(\"Project not found\");\r\n      }\r\n      return success(mapPrismaProjectToProject(result));\r\n    } catch (error) {\r\n      return failure(\"Failed to get project\", error);\r\n    }\r\n  }\r\n\r\n  async update({ id, data }: { id: string; data: UpdateProjectInput }): Promise<Result<Project>> {\r\n    try {\r\n      const result = await this.prisma.projects.update({\r\n        where: { id },\r\n        data: {\r\n          ...(data.name !== undefined && { name: data.name }),\r\n        },\r\n      });\r\n      return success(mapPrismaProjectToProject(result));\r\n    } catch (error) {\r\n      return failure(\"Failed to update project\", error);\r\n    }\r\n  }\r\n\r\n  async delete({ id }: { id: string }): Promise<Result<Project>> {\r\n    try {\r\n      const result = await this.prisma.projects.delete({\r\n        where: { id },\r\n      });\r\n      return success(mapPrismaProjectToProject(result));\r\n    } catch (error) {\r\n      return failure(\"Failed to delete project\", error);\r\n    }\r\n  }\r\n\r\n  async listByOrganization({ organizationId }: { organizationId: string }): Promise<Result<Project[]>> {\r\n    try {\r\n      const results = await this.prisma.projects.findMany({\r\n        where: { organization_id: organizationId },\r\n        orderBy: { created_at: \"desc\" },\r\n      });\r\n      return success(results.map(mapPrismaProjectToProject));\r\n    } catch (error) {\r\n      return failure(\"Failed to list projects\", error);\r\n    }\r\n  }\r\n}\r\n\r\n// Mapping function: Prisma → Domain Type\r\nfunction mapPrismaProjectToProject(prisma: {\r\n  id: string;\r\n  organization_id: string;\r\n  name: string;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}): Project {\r\n  return {\r\n    id: prisma.id,\r\n    organizationId: prisma.organization_id,\r\n    name: prisma.name,\r\n    createdAt: prisma.created_at,\r\n    updatedAt: prisma.updated_at,\r\n  };\r\n}\r\n```\r\n\r\n**Key Points:**\r\n- **Always create a mapping function** (`mapPrisma[Entity]To[Entity]`)\r\n- All methods return `Result<T>` for consistent error handling\r\n- Use `success(data)` and `failure(message, error)` from `common` package\r\n- Constructor uses single parameter object: `{ prisma }`\r\n- All methods use single parameter objects: `{ id }`, `{ data }`, `{ id, data }`\r\n- Repository only handles data access - no business logic\r\n- For soft deletes, filter with `deleted_at: null` in queries\r\n\r\n---\r\n\r\n## 4. Controller Layer\r\n\r\n**File**: `apps/server/src/controllers/ProjectsController.ts`\r\n\r\n```typescript\r\nimport { Result, failure } from \"common\";\r\nimport { ProjectsRepository } from \"@server/repositories/ProjectsRepository\";\r\nimport { Project } from \"@server/types/project\";\r\nimport { CreateProjectInput } from \"@server/types/project/create-project-input\";\r\nimport { UpdateProjectInput } from \"@server/types/project/update-project-input\";\r\nimport { logger } from \"@server/common/utils/logger\";\r\n\r\nexport class ProjectsController {\r\n  private projectsRepository: ProjectsRepository;\r\n\r\n  constructor({ projectsRepository }: { projectsRepository: ProjectsRepository }) {\r\n    this.projectsRepository = projectsRepository;\r\n  }\r\n\r\n  async create({ data }: { data: CreateProjectInput }): Promise<Result<Project>> {\r\n    try {\r\n      logger.info(\"[ProjectsController] Creating project\", { name: data.name });\r\n      return await this.projectsRepository.create({ data });\r\n    } catch (error) {\r\n      logger.error(\"[ProjectsController] Error creating project\", { error });\r\n      return failure(\"Error creating project\", error);\r\n    }\r\n  }\r\n\r\n  async getById({ id }: { id: string }): Promise<Result<Project>> {\r\n    try {\r\n      return await this.projectsRepository.getById({ id });\r\n    } catch (error) {\r\n      logger.error(\"[ProjectsController] Error getting project\", { error });\r\n      return failure(\"Error getting project\", error);\r\n    }\r\n  }\r\n\r\n  async update({ id, data }: { id: string; data: UpdateProjectInput }): Promise<Result<Project>> {\r\n    try {\r\n      logger.info(\"[ProjectsController] Updating project\", { id });\r\n      // Business logic goes here (validation, authorization, etc.)\r\n      return await this.projectsRepository.update({ id, data });\r\n    } catch (error) {\r\n      logger.error(\"[ProjectsController] Error updating project\", { error });\r\n      return failure(\"Error updating project\", error);\r\n    }\r\n  }\r\n\r\n  async delete({ id }: { id: string }): Promise<Result<Project>> {\r\n    try {\r\n      logger.info(\"[ProjectsController] Deleting project\", { id });\r\n      return await this.projectsRepository.delete({ id });\r\n    } catch (error) {\r\n      logger.error(\"[ProjectsController] Error deleting project\", { error });\r\n      return failure(\"Error deleting project\", error);\r\n    }\r\n  }\r\n\r\n  async listByOrganization({ organizationId }: { organizationId: string }): Promise<Result<Project[]>> {\r\n    try {\r\n      return await this.projectsRepository.listByOrganization({ organizationId });\r\n    } catch (error) {\r\n      logger.error(\"[ProjectsController] Error listing projects\", { error });\r\n      return failure(\"Error listing projects\", error);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Key Points:**\r\n- Controllers contain business logic only\r\n- Inject dependencies via constructor using single parameter object\r\n- Return `Result<T>` for all operations\r\n- Add logging for debugging\r\n- Keep controllers thin - complex logic should be in services\r\n\r\n---\r\n\r\n## 5. tRPC Router\r\n\r\n**File**: `apps/server/src/routers/projects-router.ts`\r\n\r\n```typescript\r\nimport { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { publicProcedure, router } from \"@server/trpc\";\r\nimport { Container } from \"@server/di/container\";\r\nimport { projectSchema } from \"@server/types/project\";\r\nimport { createProjectInputSchema } from \"@server/types/project/create-project-input\";\r\nimport { updateProjectInputSchema } from \"@server/types/project/update-project-input\";\r\n\r\nexport function createProjectsRouter(container: Container) {\r\n  const { projectsController } = container;\r\n\r\n  return router({\r\n    create: publicProcedure\r\n      .input(createProjectInputSchema)\r\n      .output(z.object({ message: z.string(), data: projectSchema }))\r\n      .mutation(async ({ input, ctx }) => {\r\n        if (!ctx.auth.userId) {\r\n          throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"Authentication required\" });\r\n        }\r\n\r\n        const result = await projectsController.create({ data: input });\r\n\r\n        if (!result.success) {\r\n          throw new TRPCError({ code: \"INTERNAL_SERVER_ERROR\", message: result.message });\r\n        }\r\n\r\n        return { message: \"Project created\", data: result.data };\r\n      }),\r\n\r\n    getById: publicProcedure\r\n      .input(z.object({ id: z.string().uuid() }))\r\n      .output(z.object({ message: z.string(), data: projectSchema }))\r\n      .query(async ({ input, ctx }) => {\r\n        if (!ctx.auth.userId) {\r\n          throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"Authentication required\" });\r\n        }\r\n\r\n        const result = await projectsController.getById({ id: input.id });\r\n\r\n        if (!result.success) {\r\n          throw new TRPCError({ code: \"NOT_FOUND\", message: result.message });\r\n        }\r\n\r\n        return { message: \"Project retrieved\", data: result.data };\r\n      }),\r\n\r\n    update: publicProcedure\r\n      .input(z.object({ id: z.string().uuid(), data: updateProjectInputSchema }))\r\n      .output(z.object({ message: z.string(), data: projectSchema }))\r\n      .mutation(async ({ input, ctx }) => {\r\n        if (!ctx.auth.userId) {\r\n          throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"Authentication required\" });\r\n        }\r\n\r\n        const result = await projectsController.update({ id: input.id, data: input.data });\r\n\r\n        if (!result.success) {\r\n          throw new TRPCError({ code: \"NOT_FOUND\", message: result.message });\r\n        }\r\n\r\n        return { message: \"Project updated\", data: result.data };\r\n      }),\r\n\r\n    delete: publicProcedure\r\n      .input(z.object({ id: z.string().uuid() }))\r\n      .output(z.object({ message: z.string(), data: projectSchema }))\r\n      .mutation(async ({ input, ctx }) => {\r\n        if (!ctx.auth.userId) {\r\n          throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"Authentication required\" });\r\n        }\r\n\r\n        const result = await projectsController.delete({ id: input.id });\r\n\r\n        if (!result.success) {\r\n          throw new TRPCError({ code: \"NOT_FOUND\", message: result.message });\r\n        }\r\n\r\n        return { message: \"Project deleted\", data: result.data };\r\n      }),\r\n\r\n    listByOrganization: publicProcedure\r\n      .input(z.object({ organizationId: z.string().uuid() }))\r\n      .output(z.object({ message: z.string(), data: z.array(projectSchema) }))\r\n      .query(async ({ input, ctx }) => {\r\n        if (!ctx.auth.userId) {\r\n          throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"Authentication required\" });\r\n        }\r\n\r\n        const result = await projectsController.listByOrganization({ organizationId: input.organizationId });\r\n\r\n        if (!result.success) {\r\n          throw new TRPCError({ code: \"INTERNAL_SERVER_ERROR\", message: result.message });\r\n        }\r\n\r\n        return { message: \"Projects retrieved\", data: result.data };\r\n      }),\r\n  });\r\n}\r\n```\r\n\r\n**Key Points:**\r\n- Router is a factory function receiving the DI container\r\n- Use `.input()` and `.output()` with Zod schemas\r\n- Use `.query()` for GET operations, `.mutation()` for POST/PUT/DELETE\r\n- Check `ctx.auth.userId` for authorization\r\n- Check `result.success` and throw `TRPCError` on failure\r\n- Return consistent format: `{ message: string, data: T }`\r\n\r\n---\r\n\r\n## 6. Register in App Router\r\n\r\n**File**: `apps/server/src/routers/_app.ts`\r\n\r\n```typescript\r\nimport { router } from \"@server/trpc\";\r\nimport { Container } from \"@server/di/container\";\r\nimport { createUserRouter } from \"./user-router\";\r\nimport { createProjectsRouter } from \"./projects-router\";\r\n\r\nexport function createAppRouter(container: Container) {\r\n  return router({\r\n    user: createUserRouter(container),\r\n    projects: createProjectsRouter(container),  // Add new router\r\n  });\r\n}\r\n\r\nexport type AppRouter = ReturnType<typeof createAppRouter>;\r\n```\r\n\r\n---\r\n\r\n## 7. Update DI Container\r\n\r\n**File**: `apps/server/src/di/container.ts`\r\n\r\n```typescript\r\nimport { PrismaClient } from \"@server/generated/prisma\";\r\nimport { UsersRepository } from \"@server/repositories/UsersRepository\";\r\nimport { UsersController } from \"@server/controllers/UsersController\";\r\nimport { ProjectsRepository } from \"@server/repositories/ProjectsRepository\";\r\nimport { ProjectsController } from \"@server/controllers/ProjectsController\";\r\n\r\nexport const createContainer = () => {\r\n  const prisma = new PrismaClient();\r\n\r\n  // Users\r\n  const usersRepository = new UsersRepository({ prisma });\r\n  const usersController = new UsersController({ usersRepository });\r\n\r\n  // Projects\r\n  const projectsRepository = new ProjectsRepository({ prisma });\r\n  const projectsController = new ProjectsController({ projectsRepository });\r\n\r\n  return {\r\n    prisma,\r\n    usersRepository,\r\n    usersController,\r\n    projectsRepository,\r\n    projectsController,\r\n  };\r\n};\r\n\r\nexport type Container = ReturnType<typeof createContainer>;\r\n```\r\n\r\n**Dependency Graph:**\r\n1. Prisma client created first\r\n2. Repositories receive Prisma instance\r\n3. Controllers receive repositories\r\n4. Container exported with all dependencies\r\n\r\n---\r\n\r\n## Important Patterns\r\n\r\n### Single Parameter Pattern\r\n\r\nAll functions accept a single object parameter:\r\n\r\n```typescript\r\n// Good\r\nasync update({ id, data }: { id: string; data: UpdateProjectInput }) {}\r\n\r\n// Bad\r\nasync update(id: string, data: UpdateProjectInput) {}\r\n```\r\n\r\n### Result Type Pattern\r\n\r\nImport from `common` package:\r\n\r\n```typescript\r\nimport { Result, success, failure } from \"common\";\r\n\r\nasync getById({ id }: { id: string }): Promise<Result<Project>> {\r\n  try {\r\n    const data = await this.prisma.projects.findUnique({ where: { id } });\r\n    if (!data) return failure(\"Not found\");\r\n    return success(mapPrismaProjectToProject(data));\r\n  } catch (error) {\r\n    return failure(\"Database error\", error);\r\n  }\r\n}\r\n```\r\n\r\n### Mapping Function Pattern\r\n\r\nAlways create explicit mapping functions:\r\n\r\n```typescript\r\n// Good - explicit mapping function\r\nfunction mapPrismaProjectToProject(prisma: PrismaProject): Project {\r\n  return {\r\n    id: prisma.id,\r\n    organizationId: prisma.organization_id,\r\n    name: prisma.name,\r\n    createdAt: prisma.created_at,\r\n    updatedAt: prisma.updated_at,\r\n  };\r\n}\r\n\r\n// Bad - inline mapping repeated in every method\r\nreturn success({\r\n  id: result.id,\r\n  organizationId: result.organization_id,\r\n  // ...\r\n});\r\n```\r\n\r\n### Soft Delete Pattern\r\n\r\nFor entities with soft deletes:\r\n\r\n```typescript\r\n// Repository methods filter by deleted_at\r\nasync getById({ id }: { id: string }): Promise<Result<Project>> {\r\n  const result = await this.prisma.projects.findUnique({\r\n    where: { id, deleted_at: null },\r\n  });\r\n  // ...\r\n}\r\n\r\n// Soft delete sets deleted_at instead of deleting\r\nasync softDelete({ id }: { id: string }): Promise<Result<Project>> {\r\n  const result = await this.prisma.projects.update({\r\n    where: { id },\r\n    data: { deleted_at: new Date() },\r\n  });\r\n  // ...\r\n}\r\n```\r\n",
        "plugins/monotemplate/skills/docker-troubleshoot/SKILL.md": "---\nname: docker-troubleshoot\ndescription: Troubleshoot Docker Compose startup errors. Use when encountering network conflicts, container name collisions, orphaned containers, or other Docker setup issues.\n---\n\n# Docker Troubleshooting\n\n## Common Issues and Fixes\n\n### 1. Network Subnet Conflict\n\n**Error message:**\n```\nfailed to create network: Error response from daemon: invalid pool request: Pool overlaps with other one on this address space\n```\n\n**Cause:** The subnet defined in docker-compose conflicts with an existing Docker network.\n\n**Fix:**\n1. Open `docker-compose.dev.yml`\n2. Find the `networks` section at the bottom\n3. Change the subnet to an unused range (e.g., `172.28.0.0/16` instead of `172.20.0.0/16`)\n4. Update all `ipv4_address` values for each service to match the new subnet\n\n**Alternative:** Clean up unused networks with:\n```bash\ndocker network prune\n```\n\n### 2. Container Name Already in Use\n\n**Error message:**\n```\nError response from daemon: Conflict. The container name \"/container-name\" is already in use\n```\n\n**Cause:** Orphaned containers from a previous run weren't cleaned up properly.\n\n**Fix:** Remove the conflicting containers:\n```bash\ndocker rm -f postgres-dev migrate-dev server-dev web-dev nginx-dev\n```\n\nOr remove all stopped containers:\n```bash\ndocker container prune\n```\n\n### 3. Full Cleanup\n\nWhen Docker state is severely corrupted:\n\n```bash\ndocker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\ndocker network rm caliber-fleet-management_app_network\ndocker system prune -f\n```\n\n## Diagnostic Commands\n\n```bash\ndocker ps -a                    # List all containers\ndocker network ls               # List all networks\ndocker network inspect <name>   # Inspect network subnet\n```\n"
      },
      "plugins": [
        {
          "name": "core",
          "description": "Core Claude Code plugins for Firstloop projects",
          "source": "./plugins/core",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add firstloophq/claude-code-plugins",
            "/plugin install core@firstloop-claude-code-plugins"
          ]
        },
        {
          "name": "monotemplate",
          "description": "CRUD architecture management for monorepo templates with layered patterns",
          "source": "./plugins/monotemplate",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add firstloophq/claude-code-plugins",
            "/plugin install monotemplate@firstloop-claude-code-plugins"
          ]
        }
      ]
    }
  ]
}