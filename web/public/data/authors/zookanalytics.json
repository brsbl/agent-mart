{
  "author": {
    "id": "zookanalytics",
    "display_name": "zookanalytics",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/20464940?v=4",
    "url": "https://github.com/zookanalytics",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 6,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "claude-devcontainer",
      "version": null,
      "description": "Plugins from the claude-devcontainer project",
      "owner_info": {
        "name": "Zook Analytics",
        "url": "https://github.com/zookanalytics"
      },
      "keywords": [],
      "repo_full_name": "zookanalytics/claude-devcontainer",
      "repo_url": "https://github.com/zookanalytics/claude-devcontainer",
      "repo_description": "Secure, opinionated Claude Code-ready devcontainer base image with firewall domain allowlisting",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-29T06:20:01Z",
        "created_at": "2025-12-10T22:44:05Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 844
        },
        {
          "path": "packages",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/bmad-orchestrator",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/bmad-orchestrator/README.md",
          "type": "blob",
          "size": 5348
        },
        {
          "path": "packages/bmad-orchestrator/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/bmad-orchestrator/hooks/hooks.json",
          "type": "blob",
          "size": 248
        },
        {
          "path": "packages/bmad-orchestrator/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/bmad-orchestrator/hooks/scripts/bmad-phase-complete.sh",
          "type": "blob",
          "size": 1987
        },
        {
          "path": "packages/claude-instance",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/claude-instance/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/claude-instance/hooks/hooks.json",
          "type": "blob",
          "size": 259
        },
        {
          "path": "packages/claude-instance/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/claude-instance/hooks/scripts/session-focus-reminder.sh",
          "type": "blob",
          "size": 1322
        },
        {
          "path": "packages/git-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/git-workflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/git-workflow/commands/cleanup.md",
          "type": "blob",
          "size": 10693
        },
        {
          "path": "packages/git-workflow/commands/commit.md",
          "type": "blob",
          "size": 287
        },
        {
          "path": "packages/git-workflow/commands/create-pull-request.md",
          "type": "blob",
          "size": 6983
        },
        {
          "path": "packages/git-workflow/commands/merge-pull-request.md",
          "type": "blob",
          "size": 7434
        },
        {
          "path": "packages/git-workflow/commands/orchestrate.md",
          "type": "blob",
          "size": 16654
        },
        {
          "path": "packages/git-workflow/commands/receiving-code-review.md",
          "type": "blob",
          "size": 6959
        },
        {
          "path": "packages/git-workflow/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/git-workflow/hooks/hooks.json",
          "type": "blob",
          "size": 259
        },
        {
          "path": "packages/git-workflow/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/git-workflow/hooks/scripts/enforce-commit-skill.sh",
          "type": "blob",
          "size": 3070
        },
        {
          "path": "packages/git-workflow/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/git-workflow/skills/creating-commits",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/git-workflow/skills/creating-commits/SKILL.md",
          "type": "blob",
          "size": 3890
        },
        {
          "path": "packages/git-workflow/skills/pull-request-conventions",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/git-workflow/skills/pull-request-conventions/SKILL.md",
          "type": "blob",
          "size": 2887
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-devcontainer\",\n  \"metadata\": {\n    \"description\": \"Plugins from the claude-devcontainer project\"\n  },\n  \"owner\": {\n    \"name\": \"Zook Analytics\",\n    \"url\": \"https://github.com/zookanalytics\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"git-workflow\",\n      \"description\": \"Git workflow skills with enforcement hooks for commits, PRs, and code review\",\n      \"version\": \"0.1.0\",\n      \"source\": \"./packages/git-workflow\"\n    },\n    {\n      \"name\": \"bmad-orchestrator\",\n      \"description\": \"BMAD workflow orchestration for AI-driven development\",\n      \"version\": \"0.1.0\",\n      \"source\": \"./packages/bmad-orchestrator\"\n    },\n    {\n      \"name\": \"claude-instance\",\n      \"description\": \"Multi-instance management with session purpose tracking\",\n      \"version\": \"0.1.0\",\n      \"source\": \"./packages/claude-instance\"\n    }\n  ]\n}\n",
        "packages/bmad-orchestrator/README.md": "# BMAD Orchestrator\n\nA Claude Code plugin that automates BMAD (Breakthrough Method for Agile AI-Driven Development) workflow orchestration for AI-driven software development.\n\n## What It Does\n\n- **Phase Detection**: Automatically detects when Claude completes a workflow phase (story creation, development, code review)\n- **Story Progression**: Advances stories through the BMAD lifecycle (backlog → ready-for-dev → in-progress → review → done)\n- **Multi-Instance Coordination**: Dispatches work to devcontainer instances and tracks progress\n- **Status Dashboard**: Terminal-based view of sprint progress and next actions\n\n## Architecture\n\nbmad-cli has two operating modes with different installation requirements:\n\n| Commands | Runs Where | Purpose |\n|----------|------------|---------|\n| `next`, `restart`, `menu` (dispatch) | **Host only** | Orchestrate work across multiple containers |\n| `run-story`, `run-epic`, `menu` (execute) | **Container only** | Execute workflows inside devcontainer |\n| `status`, `audit` | Either | View status, check health |\n\nThe orchestrator commands require Docker access to discover and dispatch to containers. The executor commands require being inside a devcontainer with Claude Code installed.\n\n## Installation\n\n### Host Installation (for orchestration)\n\nInstall globally on your host machine to dispatch work to containers:\n\n```bash\nnpm install -g @zookanalytics/bmad-orchestrator\n```\n\nThis provides the `bmad-cli` command with orchestration capabilities:\n- `bmad-cli next` - Dispatch next story to an available container\n- `bmad-cli restart <id>` - Resume a stale dispatch\n- `bmad-cli menu` - Interactive orchestration menu\n\n### Container Installation (for execution)\n\nWhen using the `claude-devcontainer` Docker image, bmad-cli is pre-installed at `/usr/local/bin/bmad-cli`.\n\nTo enable the Stop hook for phase detection, add to your `.devcontainer/devcontainer.json`:\n\n```json\n{\n  \"image\": \"ghcr.io/zookanalytics/claude-devcontainer:latest\",\n  \"containerEnv\": {\n    \"ENABLE_BMAD_ORCHESTRATOR\": \"true\"\n  }\n}\n```\n\nThis enables:\n- `bmad-cli run-story <id>` - Run a story through all phases\n- `bmad-cli run-epic <id>` - Run all stories in an epic\n- Phase completion detection via Stop hook\n\n### As a Claude Code Plugin (alternative)\n\nIf not using the devcontainer image, add to your project's `.claude/settings.json`:\n\n```json\n{\n  \"enabledPlugins\": {\n    \"bmad-orchestrator@claude-devcontainer\": true\n  },\n  \"extraKnownMarketplaces\": {\n    \"claude-devcontainer\": {\n      \"source\": {\n        \"source\": \"directory\",\n        \"path\": \"/path/to/claude-devcontainer\"\n      }\n    }\n  }\n}\n```\n\n## Usage\n\n### Interactive Menu (Recommended)\n\n```bash\nbmad-cli              # Opens interactive menu with smart defaults\n```\n\nThe menu adapts based on environment:\n- **On host**: Shows orchestration options (dispatch, restart, audit)\n- **In container**: Shows execution options (run story, run epic)\n\n### Host Commands (Orchestration)\n\nRun these on your host machine to manage work across containers:\n\n```bash\nbmad-cli              # Interactive orchestration menu\nbmad-cli next         # Dispatch next story to an available container\nbmad-cli restart ID   # Resume a stale/dead dispatch\nbmad-cli audit        # Check for stale dispatches, optionally fix\nbmad-cli status       # Show sprint status and next action\n```\n\n### Container Commands (Execution)\n\nRun these inside a devcontainer to execute workflows:\n\n```bash\nbmad-cli              # Interactive execution menu\nbmad-cli run-story ID # Run a story through all phases to completion\nbmad-cli run-epic ID  # Run all stories in an epic sequentially\nbmad-cli status       # Show sprint status\n```\n\n## How It Works\n\n### Phase Completion Detection\n\n1. When a BMAD workflow runs, the orchestrator creates a lock file tracking the story and starting status\n2. A Stop hook fires when Claude stops responding\n3. The hook compares the starting status against current `sprint-status.yaml`\n4. If status changed, a signal file is written\n5. The executor detects the signal and terminates Claude gracefully to proceed to the next phase\n\n### Story Lifecycle\n\n```\nbacklog → ready-for-dev → in-progress → review → done\n```\n\nEach transition triggers the appropriate BMAD workflow:\n- `backlog → ready-for-dev`: create-story\n- `ready-for-dev → in-progress`: dev-story\n- `in-progress → review`: dev-story completion\n- `review → done`: code-review\n\n## Requirements\n\n- Python 3.10+\n- Claude Code CLI\n- BMAD Method installed in your project\n- `jq` for JSON parsing in hooks (fallback to grep if unavailable)\n\n## Project Structure\n\n```\nbmad-orchestrator/\n├── plugin.json           # Claude Code plugin metadata\n├── marketplace.json      # Plugin marketplace entry\n├── hooks/\n│   ├── hooks.json        # Hook definitions\n│   └── scripts/\n│       └── bmad-phase-complete.sh\n├── scripts/\n│   ├── bmad-cli          # CLI entry point\n│   └── bmad/\n│       ├── __init__.py\n│       ├── cli.py        # Command implementations\n│       ├── status.py     # Sprint status reader\n│       └── executor.py   # Workflow execution\n└── docs/\n    ├── research/         # Design research and proposals\n    └── implementation/   # Technical specifications\n```\n\n## License\n\nMIT\n",
        "packages/bmad-orchestrator/hooks/hooks.json": "{\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/bmad-phase-complete.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "packages/bmad-orchestrator/hooks/scripts/bmad-phase-complete.sh": "#!/usr/bin/env bash\n# bmad-phase-complete.sh - Stop hook for BMAD phase completion detection\n#\n# Fires when Claude stops responding. Checks if the story status changed\n# (indicating phase completion) and writes a signal file for the executor.\n\nset -e\n\nLOCK_DIR=\".claude/.bmad-running\"\nSIGNAL_FILE=\".claude/.bmad-phase-signal.json\"\nSTATUS_FILE=\"docs/delivery/sprint-status.yaml\"\n\n# Only run if we're in a BMAD workflow (lock file exists)\nshopt -s nullglob\nlocks=(\"$LOCK_DIR\"/*.json)\n[[ ${#locks[@]} -eq 0 ]] && exit 0\n\n# Get the lock file (first one if multiple)\nlock_file=\"${locks[0]}\"\n[[ ! -f \"$lock_file\" ]] && exit 0\n\n# Read lock data\nstory_id=$(jq -r '.story_id // empty' \"$lock_file\" 2>/dev/null)\nstarting_status=$(jq -r '.starting_status // empty' \"$lock_file\" 2>/dev/null)\n\n[[ -z \"$story_id\" ]] && exit 0\n\n# If no starting_status recorded, we can't compare (old lock format)\n[[ -z \"$starting_status\" ]] && exit 0\n\n# Read current status from sprint-status.yaml\nif [[ ! -f \"$STATUS_FILE\" ]]; then\n    exit 0\nfi\n\n# Extract current story status using yq or grep+sed fallback\nif command -v yq &>/dev/null; then\n    current_status=$(yq -r \".stories.\\\"$story_id\\\" // empty\" \"$STATUS_FILE\" 2>/dev/null)\nelse\n    # Fallback: grep for the story line\n    # Escape story_id for use in grep pattern (handle regex metacharacters)\n    escaped_id=$(printf '%s\\n' \"$story_id\" | sed 's/[.[\\*^$()+?{|]/\\\\&/g')\n    current_status=$(grep -E \"^\\s+\\\"?${escaped_id}\\\"?:\" \"$STATUS_FILE\" 2>/dev/null | head -1 | sed 's/.*:\\s*//' | tr -d '\"' | tr -d \"'\" | xargs)\nfi\n\n[[ -z \"$current_status\" ]] && exit 0\n\n# Check if status changed (phase made progress)\nif [[ \"$current_status\" != \"$starting_status\" ]]; then\n    # Phase complete - write signal file\n    cat > \"$SIGNAL_FILE\" << EOF\n{\n  \"story_id\": \"$story_id\",\n  \"from_status\": \"$starting_status\",\n  \"to_status\": \"$current_status\",\n  \"timestamp\": \"$(date -Iseconds)\"\n}\nEOF\n    echo \"BMAD: Phase complete ($starting_status -> $current_status)\" >&2\nfi\n\nexit 0\n",
        "packages/claude-instance/hooks/hooks.json": "{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/session-focus-reminder.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "packages/claude-instance/hooks/scripts/session-focus-reminder.sh": "#!/usr/bin/env bash\nset -euo pipefail\n\n# Validate required environment variable\nif [[ -z \"${CLAUDE_PROJECT_DIR:-}\" ]]; then\n    echo \"Error: CLAUDE_PROJECT_DIR environment variable not set\" >&2\n    exit 1\nfi\n\n# Remind Claude to maintain the purpose field in .claude-metadata.json\n#\n# This hook runs at SessionStart to provide context about the conversation purpose.\n# It does NOT tell Claude to act on the previous purpose - just to be aware and update if needed.\n\nMETADATA_FILE=\"$CLAUDE_PROJECT_DIR/.claude-metadata.json\"\n\n# Check that jq is installed\nif ! command -v jq >/dev/null 2>&1; then\n  echo \"Note: jq is not installed. Cannot display session purpose.\"\n  echo \"Install with: brew install jq (macOS) or apt-get install jq (Ubuntu/Debian)\"\n  exit 0\nfi\n\nif [ -f \"$METADATA_FILE\" ]; then\n  purpose=$(jq -r '.purpose // \"\"' \"$METADATA_FILE\" 2>/dev/null)\n  if [ -z \"$purpose\" ] || [ \"$purpose\" = \"null\" ]; then\n    echo \"Session purpose: not set. After the user provides direction, set the purpose field in .claude-metadata.json.\"\n  else\n    echo \"Previous session purpose was: $purpose\"\n    echo \"Do NOT assume this is current. Wait for user direction, then update the purpose if it has changed.\"\n  fi\nelse\n  echo \"No .claude-metadata.json found. After the user provides direction, create it with a purpose field.\"\nfi\n",
        "packages/git-workflow/commands/cleanup.md": "---\nallowed-tools: Bash(git status:--porcelain), Bash(git stash:list), Bash(git fetch:--all --prune), Bash(git branch:--show-current), Bash(git branch:-vv), Bash(git branch:--merged*), Bash(git branch:-d*), Bash(git branch:-D*), Bash(git merge-base:--is-ancestor*), Bash(git rev-list:*), Bash(gh pr list:*), Bash(gh pr view:*)\ndescription: 'Syncs local repository with remote, cleans up merged branches, and reports status'\n---\n\n# Claude Command: Git Cleanup\n\nPerforms comprehensive git repository synchronization and cleanup while preserving local work.\n\n## Usage\n\n```claude\n/git:cleanup\n```\n\n## Process\n\nThis command performs a safe sync and cleanup of your git repository by:\n\n1. **Pre-flight checks (parallel)** - Check uncommitted changes and stash simultaneously\n2. **Fetching and pruning** - Syncs with remote and removes stale references\n3. **Categorizing branches (parallel)** - Check each branch's merge status concurrently\n4. **Cleaning up merged branches** - Removes local branches that were merged/deleted remotely\n5. **Preserving new work** - Keeps branches with commits not yet pushed\n6. **Reporting status** - Provides clear summary of actions taken\n\n### Steps 1-2: Pre-flight Checks (PARALLEL)\n\n**Run these commands in parallel** (no dependencies between them):\n\n```bash\ngit status --porcelain    # Check for uncommitted changes\ngit stash list            # Check for stashed changes\n```\n\n**After both complete:**\n\n- If `git status --porcelain` shows changes: **STOP** and notify user concisely\n  - Report what files/directories have changes\n  - State that cleanup cannot proceed until changes are committed or stashed\n  - Do NOT provide options or suggestions - just state the facts\n- Count stash entries for final report (informational only)\n- User should be made aware of forgotten stashed work\n\n### Step 3: Fetch and Prune\n\nSync with remote and remove stale remote-tracking branches:\n\n```bash\ngit fetch --all --prune\n```\n\n**What this does:**\n\n- Downloads latest commits from all remotes\n- Removes remote-tracking branches that no longer exist on remote\n- Does not modify local branches or working tree\n\n### Step 4: Identify Stale Branches\n\nFind local branches whose remote counterparts are gone:\n\n```bash\ngit branch -vv\n```\n\n**Analysis:**\n\n- Parse output for branches marked `[origin/...: gone]`\n- These are candidates for deletion (likely merged PRs)\n- Extract branch names for review\n\n### Step 5: Categorize Branches (PARALLEL)\n\nFor each candidate branch with `[origin/...: gone]`, determine if it's safe to delete.\n\n**Understanding merged PRs:**\n\n- When a PR is merged via GitHub (squash or rebase merge), the remote branch is deleted\n- The local branch shows `[origin/branch-name: gone]`\n- Squash/rebase merges create new commits, so the branch won't appear in `git branch --merged`\n- Git ancestry checks (`git merge-base --is-ancestor`) don't work for squash merges\n- We must check if a PR associated with the branch was merged on GitHub\n\n**Parallel categorization strategy:**\n\n```bash\n# First, get shared context (run these in parallel):\ngit branch --show-current              # Current branch (protected)\ngit branch --merged origin/main        # All traditionally merged branches\n\n# Then, for ALL candidate branches simultaneously, check GitHub PR status:\n# Launch these in parallel - each is independent:\ngh pr list --state merged --head BRANCH_1 --json number,title\ngh pr list --state merged --head BRANCH_2 --json number,title\ngh pr list --state merged --head BRANCH_3 --json number,title\n# ... one call per candidate branch, ALL IN PARALLEL\n\n# For branches with no merged PR, check unique commits (can also be parallel):\ngit rev-list origin/main..BRANCH_NAME --count\n```\n\n**Why parallel:** Each `gh pr list` call takes 1-2 seconds.\nWith 5 branches:\n\n- Sequential: 5-10 seconds\n- Parallel: 1-2 seconds total\n\n**Categorization logic per branch:**\n\n1. Skip if it's the current branch or main (protected)\n2. Check if `gh pr list --state merged --head BRANCH` returns a PR → safe to delete\n3. Check if branch appears in `git branch --merged origin/main` → safe to delete\n4. Check `git rev-list origin/main..BRANCH --count`:\n   - 0 = no unique commits → safe to delete\n   - > 0 = has unpushed work → preserve\n\n**Categories:**\n\n- **Safe to delete**:\n  - Branch has a merged PR on GitHub (primary indicator), OR\n  - Branch appears in `git branch --merged origin/main` (traditional merge), OR\n  - Branch has no unique commits compared to origin/main (empty branch)\n- **Has new work**:\n  - No merged PR found AND\n  - Branch has commits not in origin/main AND\n  - Branch not in merged list\n- **Protected**:\n  - Current branch (never delete)\n  - Main branch (never delete)\n\n### Step 6: Clean Up Safe Branches\n\nDelete branches that are safe to remove:\n\n```bash\n# Use -d flag for safe deletion (will fail if truly unmerged)\ngit branch -d BRANCH_NAME\n\n# If -d fails but we verified it's merged via PR:\n# This WILL happen with squash/rebase merges\ngit branch -D BRANCH_NAME\n```\n\n**Deletion strategy:**\n\n1. If branch has merged PR on GitHub:\n   - Try `git branch -d` first (may succeed for traditional merges)\n   - If fails, use `git branch -D` (expected for squash/rebase merges)\n   - Safe because GitHub confirms the PR was merged\n2. If branch appears in `git branch --merged origin/main`:\n   - Use `git branch -d` (will succeed)\n3. If branch has zero unique commits:\n   - Use `git branch -d` (will succeed, branch is empty)\n4. Otherwise:\n   - Do NOT delete\n   - Report to user as preserved branch with unpushed work\n\n**Rules:**\n\n- Only delete if `[origin/...: gone]` AND one of:\n  - Has merged PR on GitHub (checked via `gh pr list`), OR\n  - Appears in `git branch --merged origin/main`, OR\n  - Has zero unique commits\n- Use `-D` only when PR is confirmed merged but `-d` fails (squash/rebase case)\n- Always protect current branch and main branch\n- Report any branches that couldn't be safely categorized\n\n### Step 7: Report Results\n\nProvide comprehensive status report:\n\n**If everything is clean:**\n\n```text\n✅ Repository is fully synced with remote\n\nSummary:\n- No uncommitted changes\n- No stashed changes\n- Deleted X merged branches: [list]\n- All local branches are up to date\n```\n\n**If local work exists:**\n\n```text\n⚠️  Repository synced with local work preserved\n\nSummary:\n- Uncommitted changes: [files list]\n  Action needed: Commit or stash these changes\n\n- Stashed changes: X entries found\n  Reminder: You have stashed work that may need attention\n  Run 'git stash list' to review\n\n- Deleted X merged branches: [list]\n\n- Branches with unpushed work: [list]\n  These branches were kept because they have commits not yet pushed to remote\n```\n\n## How Merged PR Detection Works\n\n**The Challenge:**\nWhen you merge a PR on GitHub using \"Squash and merge\" or \"Rebase and merge\", GitHub:\n\n1. Creates new commit(s) on main with different SHAs\n2. Deletes the remote branch\n3. Your local branch shows `[origin/branch-name: gone]`\n4. BUT `git branch --merged` won't show it as merged (different commit SHAs)\n5. AND `git merge-base --is-ancestor` returns false (branch not in main's history)\n\n**The Solution:**\nThis command uses a three-tiered approach to safely identify merged branches:\n\n1. **GitHub PR Check** (`gh pr list --state merged --head BRANCH`)\n   - **PRIMARY METHOD** - Checks if GitHub has a merged PR for this branch\n   - Works perfectly for squash/rebase merges (the standard workflow)\n   - Most reliable method because GitHub is the source of truth\n   - Handles all merge strategies (squash, rebase, traditional merge)\n\n2. **Traditional Merge Check** (`git branch --merged origin/main`)\n   - Standard git merge detection\n   - Works for traditional merge commits\n   - Backup method if no PR found (direct commits to main)\n\n3. **Unique Commit Count** (`git rev-list origin/main..BRANCH --count`)\n   - Counts commits in branch not in main\n   - If zero, branch adds nothing new (safe to delete)\n   - Catches empty branches or work already cherry-picked\n\n**Why git ancestry checks don't work:**\n\n- `git merge-base --is-ancestor` checks if commits are in the history tree\n- Squash merge creates a NEW commit, discarding the branch's commit history\n- The branch's commits are never added to main's history\n- Therefore ancestry check returns false even though changes were merged\n\n**Result:** Branches from merged PRs are safely deleted even with GitHub's squash/rebase merge strategies by checking GitHub's PR state directly.\n\n## Safety Features\n\n- **Smart merge detection**: Properly identifies merged PRs even with squash/rebase merges\n- **Ancestor verification**: Uses `git merge-base --is-ancestor` to confirm merges\n- **Pre-flight checks**: Validates working tree before making changes\n- **Conservative deletion**: Only removes branches confirmed safe through multiple checks\n- **Protected branches**: Never deletes current branch or main\n- **Clear reporting**: Always explains what was kept and why\n\n## Error Handling\n\n- **Dirty working tree**: Stop with concise message listing uncommitted changes only\n- **Failed deletions**: Report which branches couldn't be deleted and why\n- **Network issues**: Report fetch failures clearly\n- **Protected branches**: Never attempt to delete main or current branch\n\n## Output Style\n\n**Concise error reporting:**\n\n- State the blocker clearly and briefly\n- List affected files/directories\n- No suggestions, options, or explanations unless cleanup proceeds\n- Example: \"Cannot proceed - uncommitted changes detected: .claude/commands/git/\"\n\n## Example Output\n\n```text\nChecking for uncommitted changes...\n✓ Working tree is clean\n\nChecking stash...\n✓ Found 2 stashed entries\n\nFetching from remote and pruning stale references...\n✓ Synced with origin\n✓ Pruned 5 stale remote-tracking branches\n\nAnalyzing local branches...\nFound 4 branches with deleted remotes:\n- feat/user-auth [gone] - checking merge status...\n  ✓ Found merged PR #45 on GitHub (squash merged)\n- fix/login-bug [gone] - checking merge status...\n  ✓ Found in git merged branches (traditional merge)\n- docs/update-readme [gone] - checking merge status...\n  ✓ No unique commits (empty branch)\n- feat/new-feature [gone] - checking merge status...\n  ⚠️  No merged PR found, has 3 unique commits (preserving)\n\nCleaning up merged branches...\n✓ Deleted feat/user-auth (merged PR #45)\n✓ Deleted fix/login-bug (traditional merge)\n✓ Deleted docs/update-readme (no unique commits)\n\n✅ Repository cleanup complete\n\nSummary:\n- Deleted 3 merged branches\n- Kept 1 branch with unpushed work: feat/new-feature (3 unique commits)\n- Current branch 'main' is up to date with origin/main\n- Stashed changes: 2 entries (run 'git stash list' to review)\n```\n",
        "packages/git-workflow/commands/commit.md": "---\ndescription: Creates atomic commits following conventional commit specification\n---\n\n# Commit\n\nUse and follow the creating-commits skill exactly as written.\n\n**User-provided context:**\n$ARGUMENTS\n\nIncorporate user context into the commit message body when crafting the final commit.\n",
        "packages/git-workflow/commands/create-pull-request.md": "---\ndescription: Creates a branch (if needed), pushes changes, and opens a pull request with proper naming conventions\n---\n\n# Create Pull Request\n\n**User-provided context:**\n$ARGUMENTS\n\n## Arguments\n\n- `--ready` - Create PR as ready for review (not draft).\n  Triggers CI immediately.\n\nBy default, PRs are created as **drafts** to conserve GitHub Action minutes during iteration.\nUse `--ready` when confident the PR is ready for CI and review.\n\n## Pre-flight Check and Current State (PARALLEL)\n\n**Run these commands in parallel** (no dependencies between them):\n\n```bash\ngit status --porcelain      # Check for uncommitted changes\ngit branch --show-current   # Determine current branch\n```\n\n**After both complete:**\n\n- **If `git status --porcelain` shows changes: STOP.**\n  - Report: \"Cannot create PR - uncommitted or untracked changes detected\"\n  - List the files with changes\n  - Do not proceed until changes are committed\n- **If on main:** Proceed to branch creation.\n- **If on another branch:** Skip to push step.\n\n## Branch Creation (if on main)\n\n### Fetch Latest Remote State\n\nAlways fetch before checking for divergence:\n\n```bash\ngit fetch origin\n```\n\n### Check for Divergence (PARALLEL)\n\n**Run both merge-base commands in parallel:**\n\n```bash\ngit merge-base --is-ancestor origin/main HEAD && echo \"AHEAD_OR_EQUAL\"\ngit merge-base --is-ancestor HEAD origin/main && echo \"BEHIND_OR_EQUAL\"\n```\n\n**Interpretation:**\n\n| Result               | Meaning                         | Action                      |\n| -------------------- | ------------------------------- | --------------------------- |\n| Both succeed         | HEAD and origin/main are equal  | STOP - nothing to PR        |\n| First only (AHEAD)   | origin/main is ancestor of HEAD | Normal flow - create branch |\n| Second only (BEHIND) | HEAD is ancestor of origin/main | STOP - fast-forward first   |\n| Neither (DIVERGED)   | Branches have diverged          | Create branch, then rebase  |\n\n### Handle Diverged Main\n\n**If origin/main has commits not in local main:**\n\nThis happens when commits were merged to main remotely while you worked locally.\nLocal commits on main are always WIP intended for a PR, never direct pushes.\n\n**Resolution:**\n\n1. Create feature branch from current HEAD (preserving your work):\n\n   ```bash\n   git checkout -b <branch-name>\n   ```\n\n2. Rebase onto updated origin/main:\n\n   ```bash\n   git rebase origin/main\n   ```\n\n3. If rebase conflicts occur:\n   - Analyze both sides of each conflict\n   - Resolve automatically when intent is clear:\n     - Changes to different logical sections\n     - Additive changes that don't contradict\n     - One side is clearly the \"updated\" version\n   - After resolving, run `git add <file>` and `git rebase --continue`\n   - Only STOP for user resolution when:\n     - Both sides modify the same logic with different intent\n     - Semantic conflict where correct resolution is ambiguous\n     - Report what the conflict is and why it needs human judgment\n\n4. After successful rebase, continue with push step\n\n5. **If rebase fails completely** (too many conflicts, cannot resolve):\n   - Abort rebase: `git rebase --abort`\n   - Fall back to merge: `git merge origin/main`\n   - Resolve merge conflicts if any\n   - This preserves work but creates a merge commit\n   - Report to user that merge was used instead of rebase\n\n### Analyze Commits\n\nGet commits that will be included:\n\n```bash\ngit log origin/main..HEAD --oneline\n```\n\n**If no commits ahead of origin/main: STOP.**\n\n- Report: \"No commits to create PR from\"\n- Nothing to do\n\n### Determine Branch Name\n\nUse the `pull-request-conventions` skill for naming format.\n\nAnalyze the commits to determine:\n\n1. **Type** - What kind of change? (`feat`, `fix`, `docs`, `chore`, `refactor`, `test`, `build`, `ci`, `perf`, `style`)\n2. **Description** - Brief summary of the change (2-4 words, hyphenated)\n\n**Format:** `<type>/<description>`\n\n**Examples based on commits:**\n\n- \"Add user authentication\" → `feat/user-authentication`\n- \"Fix login validation bug\" → `fix/login-validation`\n- \"Update API documentation\" → `docs/api-updates`\n\n### Create and Switch to Branch\n\n```bash\ngit checkout -b <branch-name>\n```\n\n## Push to Remote\n\nCheck if branch is already pushed:\n\n```bash\ngit rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null\n```\n\n**If tracking branch exists:** Check if up to date.\n**If no tracking branch:** Push with upstream:\n\n```bash\ngit push -u origin <branch-name>\n```\n\n## Open GitHub Pull Request\n\n### Check for Existing PR\n\n```bash\ngh pr list --head <branch-name> --json number,url --jq '.[0]'\n```\n\n**If PR already exists:**\n\n- Report: \"PR already exists: `url`\"\n- Return the existing PR URL\n- Do not create a new one\n\n### Derive PR Title\n\nReference the `pull-request-conventions` skill for title format.\n\n**Derive from commits, not branch name.**\nThe branch name is a short handle that may have diverged from the actual changes.\nAnalyze the commits to determine the appropriate title.\n\n**Process:**\n\n1. Review commits: `git log origin/main..HEAD --oneline`\n2. Identify the primary type of change (`feat`, `fix`, `refactor`, etc.)\n3. Summarize what the changes accomplish\n4. Add scope if changes are clearly scoped to a specific area\n\n**Examples:**\n\n- Commits add authentication → `feat(auth): add user authentication`\n- Commits fix validation bug → `fix: resolve login validation error`\n- Commits update docs → `docs(api): update endpoint documentation`\n- Branch `feat/123-user-auth` with commits that add JWT → `feat(auth): add JWT-based authentication`\n\n### Generate PR Description\n\nAnalyze commits to create description:\n\n```bash\ngit log origin/main..HEAD --pretty=format:\"- %s\"\n```\n\n**Description format:**\n\n```markdown\n## Summary\n\n<1-3 bullet points summarizing the changes>\n\n## Test plan\n\n<How to verify - infer from changes or use \"Tested locally\">\n```\n\n### Create the PR\n\n**If `--ready` flag provided (create as ready for review):**\n\n```bash\ngh pr create --title \"<title>\" --body \"$(cat <<'EOF'\n## Summary\n<bullet points>\n\n## Test plan\n<verification steps>\nEOF\n)\"\n```\n\n**Otherwise (default - create as draft):**\n\n```bash\ngh pr create --draft --title \"<title>\" --body \"$(cat <<'EOF'\n## Summary\n<bullet points>\n\n## Test plan\n<verification steps>\nEOF\n)\"\n```\n\n## Output\n\nAfter successful creation, report:\n\n**For draft PRs:**\n\n```text\nCreated draft PR #<number>: <title>\n<url>\n\nCI is skipped for draft PRs. When ready for CI and review:\n- Run: /git:orchestrate --ready\n- Or manually: gh pr ready <number>\n```\n\n**For ready PRs:**\n\n```text\nCreated PR #<number>: <title>\n<url>\n```\n\n## Edge Cases\n\n### Branch Already Pushed, No PR\n\n- Create PR for existing branch\n- Use branch name for title derivation\n\n### PR Creation Fails\n\nCommon failures:\n\n1. **No commits** - \"Pull request has no commits\"\n   - Verify commits exist between branch and main\n2. **Auth issues** - Check `gh auth status`\n3. **Repository permissions** - User may not have push access\n\nReport the error clearly and stop.\n",
        "packages/git-workflow/commands/merge-pull-request.md": "---\ndescription: Merges pull requests using squash merge with proper validation and cleanup\n---\n\n# Merge Pull Request\n\n**User-provided context:**\n$ARGUMENTS\n\n## Determine PR Number\n\n**If user provided a PR number in arguments:** Use that PR number.\n\n**If no PR number provided:** Automatically determine from current branch:\n\n```bash\ngit branch --show-current\ngh pr list --head <branch-name> --json number --jq '.[0].number'\n```\n\n- If found: use that PR number\n- If not found: \"No PR found for branch `branch-name`\"\n- If multiple PRs: show list and ask user which one\n\n## Pre-Merge Validation\n\n**Use TodoWrite to create todos for EACH validation step.**\n\n### Step 1: Gather All Data (PARALLEL)\n\n**Run both queries in parallel** (no dependencies between them):\n\n```bash\n# Query 1: Get all PR data in one call (includes headRefName for branch)\ngh pr view <number> --json number,title,body,statusCheckRollup,mergeable,headRefName\n\n# Query 2: Get commit history for description verification\n# Use PR branch name (headRefName) to ensure correct history regardless of current branch\ngit log origin/main..origin/<headRefName> --oneline\n```\n\n### Step 2: Verify PR Title\n\nReference the `pull-request-conventions` skill for title format.\n\n**Check format:** `<type>[optional scope]: <description>`\n\nThe title becomes the squashed commit message on main.\n\n### Step 3: Verify PR Description\n\n**Foundational principle: Description must be 100% accurate.\nNo exceptions.**\n\nUse the body from Step 1 and commit history from Step 1.\n\n**If description mentions specific features, approaches, or code changes, verify with diff:**\n\n```bash\ngh pr diff <number>\n```\n\nReference the `pull-request-conventions` skill for description requirements.\n\n**Red flags that block merge:**\n\n- Removed features: Description mentions \"Added X\" but X was removed\n- Changed approaches: Description says \"Using Y\" but implementation uses Z\n- Removed safeguards: Description claims safeguard that was removed\n- Outdated code examples: Snippets don't match final implementation\n\n**If ANY red flags found - DO NOT MERGE:**\n\n1. Update description first:\n\n```bash\ngh pr edit <number> --body \"$(cat <<'EOF'\n## Summary\n<corrected description reflecting actual changes>\n\n## Test plan\n<verification steps>\nEOF\n)\"\n```\n\n2. Verify description is now accurate\n3. Only then proceed to merge\n\n### Step 4: Verify CI Checks\n\nUse `statusCheckRollup` from Step 1.\n\n**All checks must show one of:**\n\n- `\"conclusion\": \"SUCCESS\"` and `\"status\": \"COMPLETED\"` (passed)\n- `\"conclusion\": null` and `\"status\": \"SKIPPED\"` (legitimately skipped)\n\n**If any checks show SKIPPED:** Verify it's intentional (conditional workflows, platform-specific tests).\n\n**If any checks failed:**\n\n- Flaky test: Rerun the check\n- Real failure: **DO NOT MERGE**\n  - If fix needs code changes: STOP, inform user\n  - Never push unreviewed fixes to pass CI\n\n### Step 5: Verify Mergeable Status\n\n**CRITICAL:** GitHub computes mergeability asynchronously.\nAlways verify before merge.\n\nUse `mergeable` from Step 1.\n\n**Expected states:**\n\n- `\"mergeable\": \"MERGEABLE\"` - Ready to merge\n- `\"mergeable\": \"CONFLICTING\"` - Has conflicts, cannot merge\n- `\"mergeable\": \"UNKNOWN\"` - GitHub still computing, must wait\n\n**If status is UNKNOWN:**\n\nGitHub hasn't computed mergeability yet.\nThis commonly happens after:\n\n- Recent pushes to the PR branch\n- Recent changes to the base branch\n- PR just created or reopened\n\n**Wait and retry (up to 3 attempts, 5 seconds apart):**\n\n```bash\n# Check status\ngh pr view <number> --json mergeable --jq '.mergeable'\n\n# If UNKNOWN, wait 5 seconds and check again\nsleep 5\ngh pr view <number> --json mergeable --jq '.mergeable'\n```\n\n**If still UNKNOWN after 3 attempts:**\n\n- Inform user: \"GitHub hasn't computed merge status yet.\n  Try again in a moment.\"\n- DO NOT attempt merge with UNKNOWN status.\n  It will fail with misleading errors.\n\n**If CONFLICTING:**\n\n- Inform user: \"PR has merge conflicts - needs resolution\"\n- User decides approach (rebase, merge main, manual resolution)\n\n## Merge the PR\n\nAlways use squash merge:\n\n```bash\ngh pr merge <number> --squash\n```\n\n**Why squash merge:**\n\n- Clean, linear history - one commit per PR on main\n- PR title becomes commit message\n- Individual commits preserved in closed PR if needed\n\n## If Merge Fails\n\n```bash\ngh pr view <number> --json mergeable,mergeStateStatus\n```\n\n**Common failures:**\n\n1. **Merge conflicts** - `\"mergeable\": \"CONFLICTING\"`\n   - Inform user: \"PR has merge conflicts - needs resolution\"\n   - User decides approach (rebase, merge main, manual resolution)\n   - After resolved, return to Step 1\n\n2. **Branch protection violations**\n   - Check failed status checks, required reviews\n   - Re-verify Step 4\n\n3. **Insufficient permissions**\n   - Inform user of permission issue\n\n**DO NOT attempt to resolve merge failures without user input.**\n\n## Post-Merge Cleanup\n\n**After successful merge, IMMEDIATELY clean up:**\n\n```bash\n# 1. Verify merge succeeded\ngh pr view <number> --json state,mergedAt\n\n# 2. Switch to main and pull (sequential - must complete before cleanup)\ngit checkout main\ngit pull origin main\n\n# 3. Clean up local and remote refs (PARALLEL - run both simultaneously)\ngit branch -D <branch-name>    # Delete local branch (-D required for squash merges)\ngit fetch --prune               # Prune stale remote-tracking references\n\n# 4. Verify remote branch was deleted\ngit branch -r | grep <branch-name> || echo \"Remote branch deleted\"\n\n# 5. Update session purpose to indicate completion\n# First, read the current purpose\ncat .claude-metadata.json | jq -r '.purpose'\n# Then update with completion prefix\n./scripts/claude-instance purpose \"COMPLETED: <previous-purpose>\"\n```\n\n**Note:** Read the current purpose from `.claude-metadata.json` first, then replace\n`<previous-purpose>` in the command with the actual value.\nThis marks the session as having completed its primary objective.\n\n**If remote branch still exists after verified merge: STOP.**\n\n- This shouldn't happen (GitHub auto-deletes)\n- Inform user: \"Remote branch still exists - check GitHub PR page\"\n- May indicate repository settings issue\n\n**Why cleanup immediately:**\n\n- Prevents accidentally adding commits to merged branch\n- Keeps local git clean\n- \"I'll clean up later\" never happens\n\n## Process Violations (Never Do These)\n\n- Manually merge PR changes with `git merge` to main\n- Cherry-pick commits from PR branch directly\n- Copy code changes without closing the PR\n- Leave PRs open after manually incorporating changes\n- Merge with outdated description\n- Push code changes to fix CI without re-review\n- Skip branch cleanup after merge\n- Continue working on branch after it's been merged\n\n## Common Rationalizations (STOP)\n\nIf you think any of these, stop and follow the process:\n\n| Thought                            | Reality                                                 |\n| ---------------------------------- | ------------------------------------------------------- |\n| \"PR title is what matters\"         | Description is permanent record. Both must be accurate. |\n| \"Description can be updated later\" | Can't edit after merge. Do it now.                      |\n| \"Production urgency\"               | 5 min now saves hours debugging later.                  |\n| \"It's probably fine\"               | Run the commands. Takes 30 seconds.                     |\n| \"I'll clean up later\"              | You won't. Cleanup now.                                 |\n",
        "packages/git-workflow/commands/orchestrate.md": "---\ndescription: Orchestrates full PR workflow from local review through CI checks and external reviews to human sign-off readiness\n---\n\n# Orchestrate PR Workflow\n\n**User-provided context:**\n$ARGUMENTS\n\n## Arguments\n\n- `--ready` - Mark PR as ready for review and trigger CI.\n  Without this flag, PRs remain as drafts.\n\nBy default, PRs are created and kept as **drafts** to conserve GitHub Action minutes during iteration.\nUse `--ready` when confident the PR is ready for CI and review.\n\n## Overview\n\nThis command orchestrates the complete pull request workflow as an **idempotent state machine**.\nRun it multiple times - it detects current state and continues from where you left off.\n\n**Phases (without --ready):** Self-Review → Draft PR Creation → Report (CI skipped)\n\n**Phases (with --ready):** Self-Review → PR Creation → Mark Ready → CI + Copilot → External Feedback → Ready for Sign-off\n\n**Key loop:** After addressing feedback, return to Phase 3 (CI + Copilot) for re-validation.\n\n## State Detection\n\n**Use TodoWrite to create a checklist tracking workflow progress.**\n\nExample checklist items:\n\n- Uncommitted changes addressed\n- Commits ready\n- Self-review completed\n- PR opened\n- CI and Copilot checks passed\n- Feedback addressed\n- Ready for sign-off\n\n### Parallel State Detection\n\n**Run these commands in parallel** (no dependencies between them):\n\n```bash\n# Group 1: Independent queries (run all in parallel)\ngit status --porcelain                    # Uncommitted changes\ngit branch --show-current                 # Current branch\ngit fetch origin                          # Fetch latest remote state\n```\n\n**After fetch completes**, run these in parallel:\n\n```bash\n# Group 2: Depends on fetch (run all in parallel)\ngit log origin/main..HEAD --oneline       # Commits ahead of main\ngit merge-base --is-ancestor origin/main HEAD && echo \"AHEAD_OR_EQUAL\"\ngit merge-base --is-ancestor HEAD origin/main && echo \"BEHIND_OR_EQUAL\"\n# Interpretation: both succeed = EQUAL, first only = AHEAD, second only = BEHIND, neither = DIVERGED\n```\n\n**If on a feature branch**, also run:\n\n```bash\n# Group 3: PR status (run in parallel with Group 2 if branch known)\ngh pr list --head <branch-name> --json number,state,isDraft --jq '.[0]'\ngh pr view <number> --json statusCheckRollup,reviews,comments,isDraft  # If PR exists\n```\n\n**State determination:**\n\n| Condition                                       | State            | Action                                |\n| ----------------------------------------------- | ---------------- | ------------------------------------- |\n| Uncommitted changes exist                       | `uncommitted`    | Run /git:commit, then continue        |\n| No commits ahead of main                        | `nothing-to-do`  | STOP - nothing to review              |\n| On main with commits, branches have diverged    | `needs-branch`   | Start at Phase 1                      |\n| On feature branch, no PR exists                 | `needs-review`   | Start at Phase 1                      |\n| PR exists, is draft, no `--ready` flag          | `draft`          | Self-review only, report draft status |\n| PR exists, is draft, `--ready` flag provided    | `draft-ready`    | Mark ready, proceed to Phase 3        |\n| PR exists, not draft, CI/Copilot pending        | `checks-pending` | Wait for CI and Copilot               |\n| PR exists, not draft, CI failed                 | `ci-failed`      | Fix failures                          |\n| PR exists, checks passed, unresolved threads    | `merge-blocked`  | Address ALL threads                   |\n| PR exists, checks passed, no unresolved threads | `ready`          | Report completion                     |\n\n> **CRITICAL:** The `merge-blocked` state means **unresolved review threads block the merge**.\n> This is NOT about \"requiring approving review\" - it's about ALL review comments being resolved.\n> GitHub branch protection rules require all Copilot (and other reviewer) threads to be resolved before merge is allowed.\n\n### Validate Session Purpose\n\nAfter state detection, validate the session purpose matches the work being orchestrated.\n\n**Sources for purpose (in priority order):**\n\n1. PR title (if PR exists) - e.g., \"feat(app): add Automerge CRDT integration\" → \"Automerge CRDT Integration\"\n2. Branch name - e.g., `feat/automerge-crdt-integration` → \"Automerge CRDT Integration\"\n3. First commit message summary\n\n**Check and update:**\n\n```bash\n# Read current purpose\ncat .claude-metadata.json 2>/dev/null | jq -r '.purpose // empty'\n\n# If purpose is empty, stale, or doesn't match the work, update it\n./scripts/claude-instance purpose \"<derived-purpose>\"\n```\n\n**Keep purpose broad** - describes the overall goal, not specific steps.\nExamples:\n\n- ✅ \"Automerge CRDT Integration\"\n- ✅ \"JWT Authentication\"\n- ❌ \"Processing Copilot feedback\" (too specific)\n- ❌ \"Phase 3 CI checks\" (workflow step, not purpose)\n\n### Handling `uncommitted` State\n\nWhen uncommitted changes exist (staged or unstaged):\n\n1. Run `/git:commit` to commit the changes\n   - Follows the creating-commits skill workflow\n   - Runs `pnpm fix`, analyzes staging, creates atomic commit\n2. After successful commit, re-detect state and continue workflow\n3. If commit fails (lint errors, user intervention needed), report and STOP\n\nThis allows orchestrate to take over from any working state - user doesn't need to\nmanually commit before running orchestrate.\n\n### Handling `needs-branch` State\n\nWhen on main with local commits and origin/main has diverged:\n\n1. **Local commits on main are always WIP** - never intended to be pushed directly\n2. **Proceed to Phase 1** (Self-Review) - review changes before creating PR\n3. **Then Phase 2** (`/git:create-pull-request`) handles branch creation and rebase\n\nThe `needs-branch` state does NOT skip self-review.\nPhase 2 will:\n\n- Detect the divergence\n- Create an appropriately named feature branch\n- Rebase onto origin/main (or merge if rebase fails)\n- Push and create the PR\n\n### Handling `draft` State (no --ready flag)\n\nWhen PR is draft and `--ready` flag not provided:\n\n1. Run self-review (Phase 1 equivalent for existing PR)\n2. Skip Phases 3-5 (CI wait, feedback, sign-off)\n3. Report completion:\n\n```text\nSelf-review complete. PR remains in draft mode.\n\nPR: #<number> - <title>\nURL: <url>\n\nCI is skipped for draft PRs to conserve GitHub Action minutes.\nWhen ready for CI and review:\n- Run: /git:orchestrate --ready\n- Or manually: gh pr ready <number>\n```\n\n**Rationale:** Allows frequent self-review cycles without burning CI minutes.\n\n### Handling `draft-ready` State (--ready flag provided)\n\nWhen PR is draft and `--ready` flag provided:\n\n1. Run self-review (Phase 1 equivalent for existing PR)\n2. Mark PR as ready: `gh pr ready <number>`\n3. Proceed to Phase 3 (Wait for CI and Copilot)\n\n## Phase 1: Local Self-Review\n\n**Entry:** State is `needs-review` or `needs-branch` (committed but no PR yet)\n\n**Goal:** Catch issues before external reviewers see them.\n\n> **Use the slash command, not just a skill.**\n> The `/superpowers:review-branch` command executes the full review workflow.\n> **You MUST run the command.**\n\nRun `/superpowers:review-branch` which will:\n\n- Review all branch changes against main\n- Identify code quality issues, bugs, missing tests\n- Generate fixes for problems found\n\n**Exit criteria:**\n\n- All self-review issues addressed\n- Changes committed (if any fixes made)\n- Ready for PR creation\n\n**Transition:** → Phase 2\n\n## Phase 2: Create Pull Request\n\n**Entry:** Self-review complete, no PR exists\n\n**If `--ready` flag provided:**\n\nRun `/git:create-pull-request --ready` to:\n\n- Create feature branch if on main\n- Push to remote\n- Open PR as ready for review (not draft)\n\n**Otherwise (default - create as draft):**\n\nRun `/git:create-pull-request` to:\n\n- Create feature branch if on main\n- Push to remote\n- Open PR as draft (CI skipped)\n\n**Capture PR number and URL for tracking.**\n\n**Transition:**\n\n- If `--ready` flag: → Phase 3 (Wait for CI)\n- If no `--ready` flag: → Report draft status and STOP\n\n## Phase 3: Wait for CI and Copilot\n\n**Entry:** PR exists, awaiting CI completion and Copilot review\n\n### Detect Copilot Review Status\n\nUse the timeline and requested_reviewers APIs to accurately detect Copilot status:\n\n```bash\n# Get Copilot events from timeline (review_requested and reviewed)\ngh api repos/{owner}/{repo}/issues/{pr}/timeline --jq '\n  [.[] | select(\n    (.event == \"review_requested\" and .requested_reviewer.login == \"Copilot\") or\n    (.event == \"reviewed\" and .user.login == \"Copilot\")\n  )] | sort_by(if .event == \"reviewed\" then .submitted_at else .created_at end)'\n\n# Check if Copilot is in pending reviewers\ngh api repos/{owner}/{repo}/pulls/{pr}/requested_reviewers --jq '\n  .users[] | select(.login == \"Copilot\")'\n```\n\n**Copilot Status Determination:**\n\n| Condition                                       | Status        | Action              |\n| ----------------------------------------------- | ------------- | ------------------- |\n| Copilot in `requested_reviewers`                | In Progress   | Wait for completion |\n| `review_requested` after latest `reviewed`      | Re-reviewing  | Wait for completion |\n| `reviewed` exists, not in `requested_reviewers` | Complete      | Check for feedback  |\n| No `review_requested` for Copilot               | Not Triggered | Wait up to 5 min    |\n\n### Polling Strategy\n\nPoll CI and Copilot status every 30 seconds:\n\n1. **Get current PR state:**\n\n   ```bash\n   gh pr view <number> --json headRefOid,statusCheckRollup,reviews\n   ```\n\n2. **Check CI status:**\n   - All checks `SUCCESS` or `SKIPPED` → CI passed\n   - Any check `FAILURE` → CI failed\n   - Otherwise → CI pending\n\n3. **Check Copilot status** (using timeline + requested_reviewers as above)\n\n> **Note:** `statusCheckRollup` contains `CheckRun` (.conclusion) and `StatusContext` (.state) - use `.conclusion // .state` to handle both.\n\n**Timeouts:**\n\n- Copilot triggered: 10 minutes from `review_requested` (typical: 30s-5min)\n- Copilot not triggered: 5 minutes grace period to see if auto-triggered\n- CI: No timeout (wait indefinitely)\n\n**Decision Matrix:**\n\n| CI Status  | Copilot Status   | Timeout? | Action                         |\n| ---------- | ---------------- | -------- | ------------------------------ |\n| ✅ Passed  | ✅ Complete      | Any      | → Phase 4 (check feedback)     |\n| ✅ Passed  | ⏳ In Progress   | No       | Continue waiting               |\n| ✅ Passed  | ⏳ In Progress   | Yes      | → Phase 4 (proceed anyway)     |\n| ✅ Passed  | ❓ Not Triggered | < 5 min  | Wait for auto-trigger          |\n| ✅ Passed  | ❓ Not Triggered | ≥ 5 min  | → Phase 4 (no review expected) |\n| ⏳ Pending | Any              | Any      | Continue waiting for CI        |\n| ❌ Failed  | Any              | Any      | → Handle CI Failure            |\n\n**Exit:** CI passed AND (Copilot complete OR in-progress timeout OR not-triggered grace period)\n\n**If Copilot in-progress timeout reached:**\n\n- Report: \"CI passed but Copilot hasn't completed after 10 minutes (unusual)\"\n- Offer to wait longer or proceed without Copilot review\n\n**If Copilot never triggered:**\n\n- After 5 minute grace period with no `review_requested` event\n- Proceed to Phase 4 - no Copilot feedback expected\n- Note: Auto-review may be disabled or not configured for this repo\n\n### Handle CI Failure\n\n1. Fetch failure logs: `gh run view <run-id> --log-failed`\n2. Analyze root cause and fix the issue\n3. Commit fix: `/git:commit`\n4. Push: `git push`\n5. → Restart Phase 3 (wait for new CI run)\n\n**Retry limit:** 3 attempts per unique failure type.\nAfter limit: STOP and report to user.\n\n## Phase 4: Process External Feedback\n\n**Entry:** CI passed and Copilot reviewed (or timeout)\n\n### Check for Unresolved Threads\n\nQuery GitHub for unresolved review threads:\n\n```bash\ngh api graphql -f query='...' --jq '...' # See /git:receiving-code-review for full query\n```\n\n### If Unresolved Threads Exist\n\n> **CRITICAL:** Unresolved threads block PR merges.\n> You MUST resolve ALL threads before the PR can be merged.\n\nRun `/git:receiving-code-review <pr-number>` to:\n\n1. Fetch all unresolved review threads\n2. Evaluate each using parallel subagents\n3. Implement valid suggestions\n4. Reply to AND resolve each thread\n5. Generate summary report\n\nSee [/git:receiving-code-review](receiving-code-review.md) for complete workflow details.\n\n**After command completes:**\n\n1. Verify all threads resolved (command should do this, but double-check):\n\n   ```bash\n   gh api graphql ... | jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length'\n   ```\n\n2. If threads remain unresolved:\n   - Re-run `/git:receiving-code-review` OR\n   - Manually address remaining threads\n\n3. Commit any changes: `/git:commit`\n\n4. Push to update PR: `git push`\n\n5. → Return to Phase 3 (wait for CI and Copilot to re-review)\n\n**Common mistake:** Claiming work is \"done\" without verifying threads are resolved.\nCheck unresolved thread count FIRST before diagnosing merge blocks.\n\n### If No Unresolved Threads\n\nProceed to Phase 5 (Ready for Sign-off).\n\n## Phase 5: Ready for Sign-off\n\n**Entry:** CI passing, all feedback addressed (or none received)\n\n**Final verification:**\n\n```bash\ngh pr view <number> --json state,statusCheckRollup,reviews,mergeable\n```\n\n**Completion criteria:**\n\n| Check              | Required                 |\n| ------------------ | ------------------------ |\n| PR state           | `OPEN`                   |\n| All CI checks      | `SUCCESS` or `SKIPPED`   |\n| Mergeable          | `MERGEABLE`              |\n| Unresolved threads | 0 (or escalated to user) |\n\n**Final Report:**\n\n```markdown\n## PR Ready for Sign-off\n\n**PR:** #<number> - <title>\n**URL:** <url>\n**Branch:** <branch-name> → main\n\n### Verification Complete\n\n| Phase             | Status                      |\n| ----------------- | --------------------------- |\n| Self-Review       | ✓ Complete                  |\n| CI + Copilot      | ✓ All passing               |\n| External Feedback | ✓ Addressed / None received |\n\n### Changes Summary\n\n<1-3 sentence summary of what the PR accomplishes>\n\n### Commits\n\n<list of commits in PR>\n\n### Escalated Items\n\n<list any items that need human decision, or \"None\">\n\n### Next Steps\n\nHuman review and approval, then:\n\n- Merge: `/git:merge-pull-request`\n```\n\n## Iteration Limits\n\nPrevent infinite loops:\n\n| Limit           | Value              | On Exceed         |\n| --------------- | ------------------ | ----------------- |\n| CI fix attempts | 3 per failure type | Ask user          |\n| Feedback cycles | 5 round-trips      | Ask user          |\n| Copilot wait    | 10 minutes         | Proceed without   |\n| CI wait         | None               | Wait indefinitely |\n\n## Resume Capability\n\nThis command is **idempotent** - run it multiple times safely.\n\n**On re-run:**\n\n1. Detect current state (see State Detection)\n2. Skip completed phases\n3. Continue from current state\n4. Preserve all previous work\n\n**Example re-run scenarios:**\n\n- \"CI or Copilot pending\" → Continue waiting from Phase 3\n- \"New comments appeared\" → Process them in Phase 4\n- \"Everything green\" → Report ready state\n\n## Error Handling\n\n### Merge Blocked\n\nIf PR merge fails, diagnose in priority order:\n\n1. **Unresolved threads** (most common) → Return to Phase 4\n2. **CI failing/pending** → Return to Phase 3 or fix failures\n3. **Branch protection rules** → Check repository settings\n4. **Merge conflicts** → Resolve conflicts with main\n\n> **Common mistake:** Assuming \"requires approving review\" without checking unresolved threads first.\n> Copilot review comments are the most common merge blocker.\n\n### CI Repeatedly Fails\n\nAfter 3 fix attempts for same failure:\n\n```text\nCI continues to fail after 3 fix attempts.\n\nFailure: <check name>\nError: <error summary>\n\nOptions:\n1. Show full error log\n2. I'll investigate manually\n3. Skip this check (not recommended)\n```\n\n### Cannot Address Feedback\n\nIf feedback requires architectural decisions:\n\n- Escalate to user with context\n- Do NOT guess or make assumptions\n- Mark as \"Needs Discussion\" in report\n- Continue with other actionable items\n\n### API/Network Errors\n\n- Retry transient errors (3 attempts with backoff)\n- Report persistent failures clearly\n- Preserve local state (never lose work)\n\n## Key Principles\n\n- **Idempotent** - Safe to run multiple times\n- **State-aware** - Detects where you are, continues from there\n- **Transparent** - Reports what it's doing and why\n- **Escalates honestly** - Uncertain items need human judgment\n- **Never blocks indefinitely** - Timeouts and user prompts prevent hangs\n",
        "packages/git-workflow/commands/receiving-code-review.md": "---\ndescription: Process PR review comments using parallel subagents for evaluation and implementation\nallowed-tools: Bash(gh api:*), Bash(git branch:*), Glob, Grep, Read, Edit, Task\nargument-hint: [PR number]\n---\n\n# Receiving Code Review\n\n**User-provided context:** $ARGUMENTS\n\n## Overview\n\nProcess review comments on a GitHub PR using **parallel subagent orchestration**.\n\nUse Skill tool to load `superpowers:receiving-code-review` for evaluation criteria.\n\n## Get Context (PARALLEL)\n\n**If no PR number provided, run both queries in parallel:**\n\n```bash\n# Query 1: Get repository info\ngh repo view --json owner,name --jq '{owner: .owner.login, repo: .name}'\n\n# Query 2: Detect PR from current branch\ngh pr list --head \"$(git branch --show-current)\" --json number --jq '.[0].number'\n```\n\n**If PR number is provided:** Only run Query 1 (repo info).\n\nUse owner/repo values in all API calls below.\n\n## Fetch Unresolved Threads\n\n```bash\ngh api graphql -f query='\n  query($owner: String!, $repo: String!, $number: Int!) {\n    repository(owner: $owner, name: $repo) {\n      pullRequest(number: $number) {\n        reviewThreads(first: 50) {\n          nodes {\n            id\n            isResolved\n            comments(first: 10) {\n              nodes { id, author { login }, body, path, line }\n            }\n          }\n        }\n      }\n    }\n  }\n' -f owner=\"$OWNER\" -f repo=\"$REPO\" -F number=$PR_NUMBER\n```\n\nFilter to `isResolved: false` only.\n\n---\n\n## Parallel Processing Architecture\n\n### Phase 1: Parallel Evaluation\n\n**Dispatch one Task per thread** with `subagent_type: \"general-purpose\"`:\n\n```text\nEvaluate review thread. Context: repo={owner}/{repo}, PR={number}, thread_id={id}, file={path}, line={line}.\n\nComment: <body>\n\nEvaluation criteria (from receiving-code-review skill):\n1. Technically correct for THIS codebase?\n2. Breaks existing functionality?\n3. Reason for current implementation?\n4. Reviewer has full context?\n\nRead the file. Categorize: implement|decline|escalate.\n\nReturn JSON only:\n{\"thread_id\":\"<id>\",\"comment_id\":\"<comment_id>\",\"category\":\"implement|decline|escalate\",\"affected_files\":[\"<path>\"],\"response\":\"<explanation>\",\"fix\":\"<description or null>\"}\n```\n\n**Launch ALL evaluation subagents in a single message** (parallel Task invocations).\n\n### Phase 2: Group Results\n\n| Category    | Action                               |\n| ----------- | ------------------------------------ |\n| `implement` | Check file overlap → dispatch fixes  |\n| `decline`   | Reply + resolve (parallel API calls) |\n| `escalate`  | Reply only, report to user           |\n\n### Phase 3: Decline/Escalate (Parallel API Calls)\n\nNo subagents needed—just parallel `gh api` calls:\n\n```bash\n# Reply to comment thread\ngh api repos/<owner>/<repo>/pulls/<pr>/comments \\\n  -f body=\"<response>\" \\\n  -F in_reply_to=<comment_id>\n\n# Resolve thread (decline only)\ngh api graphql -f query='\n  mutation($threadId: ID!) {\n    resolveReviewThread(input: {threadId: $threadId}) {\n      thread { isResolved }\n    }\n  }\n' -f threadId=\"<thread_id>\"\n```\n\n### Phase 4: Smart Implementation\n\n**Group by file overlap:**\n\n- Non-overlapping → parallel Task dispatch\n- Overlapping → sequential within group\n\n**Implementation subagent prompt:**\n\n```text\nImplement fix. Context: repo={owner}/{repo}, PR={number}, thread_id={id}, file={path}.\n\nFeedback: <comment body>\nFix required: <description from evaluation>\n\nRead file. Make ONLY the required change. Return JSON:\n{\"thread_id\":\"<id>\",\"status\":\"fixed|failed\",\"changes\":\"<description>\",\"files\":[\"<path>\"]}\n```\n\n### Phase 5: Reply and Resolve Each Thread\n\nAfter implementations complete, **for EVERY thread**:\n\n1. **Reply directly to the thread** (not a standalone PR comment):\n\n   ```bash\n   gh api repos/<owner>/<repo>/pulls/<pr>/comments \\\n     -f body=\"<response>\" \\\n     -F in_reply_to=<comment_id>\n   ```\n\n2. **Resolve the thread** (mark it closed in GitHub):\n   ```bash\n   gh api graphql -f query='\n     mutation($threadId: ID!) {\n       resolveReviewThread(input: {threadId: $threadId}) {\n         thread { isResolved }\n       }\n     }\n   ' -f threadId=\"<thread_id>\"\n   ```\n\n**Response templates:**\n\n- Fixed: \"Fixed. {description of changes}\"\n- Declined: \"Declined. {reasoning why current approach is correct}\"\n- Escalated: \"Escalating. {why this needs human decision}\"\n\n### Phase 6: Verify All Threads Resolved\n\n> **BLOCKING: Do NOT report completion until this passes.**\n\n```bash\nUNRESOLVED=$(gh api graphql -f query='\n  query($owner: String!, $repo: String!, $pr: Int!) {\n    repository(owner: $owner, name: $repo) {\n      pullRequest(number: $pr) {\n        reviewThreads(first: 100) {\n          nodes { isResolved }\n        }\n      }\n    }\n  }\n' -f owner=\"<owner>\" -f repo=\"<repo>\" -F pr=<number> \\\n  --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length')\n\necho \"Unresolved threads: $UNRESOLVED\"\n```\n\n**If UNRESOLVED > 0:** Go back and resolve remaining threads before proceeding.\n\n---\n\n## Summary Report\n\n```markdown\n| #   | Comment | Response     | Status      |\n| --- | ------- | ------------ | ----------- |\n| 1   | desc    | what changed | ✓ Fixed     |\n| 2   | desc    | reasoning    | ✓ Declined  |\n| 3   | desc    | uncertainty  | Needs input |\n```\n\n---\n\n## Rationalization Counters\n\n**Do NOT skip parallelization because:**\n\n| Excuse                         | Reality                                              |\n| ------------------------------ | ---------------------------------------------------- |\n| \"Only 2 threads, not worth it\" | Parallel dispatch has no overhead. Use it.           |\n| \"I'll evaluate as I go\"        | Sequential = slower. Parallel evaluation first.      |\n| \"File overlap is complex\"      | Simple set intersection. Check `affected_files`.     |\n| \"Subagents add latency\"        | Parallel subagents are faster than sequential agent. |\n\n**Do NOT skip thread processing because:**\n\n| Excuse                             | Reality                                   |\n| ---------------------------------- | ----------------------------------------- |\n| \"This one seems minor\"             | Every comment deserves acknowledgment.    |\n| \"I'll batch similar ones\"          | Each thread gets its own reply. No batch. |\n| \"Already addressed by another fix\" | Still reply explaining this.              |\n\n---\n\n## Important Notes\n\n- **Never skip threads** — every comment deserves acknowledgment\n- **Reply directly to thread** — use `in_reply_to` parameter, not standalone comments\n- **Resolve every thread** — unresolved threads block PR merge\n- **Verify before claiming done** — run Phase 6 check, confirm 0 unresolved\n- **Escalate honestly** — if uncertain, say so (but still resolve the thread)\n- **Commit after implementing** — use `creating-commits` skill\n- **Maximize parallelism** — only serialize for file overlap\n\n> **Completion means UNRESOLVED = 0.**\n> If any threads remain open, you have NOT completed this command.\n",
        "packages/git-workflow/hooks/hooks.json": "{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/enforce-commit-skill.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "packages/git-workflow/hooks/scripts/enforce-commit-skill.sh": "#!/usr/bin/env bash\n#\n# enforce-commit-skill.sh\n#\n# PreToolUse hook for Bash commands that ensures the creating-commits skill\n# workflow is followed before any git commit.\n#\n# Exit codes:\n#   0 - Command is allowed\n#   2 - Command is blocked (provides feedback to Claude)\n\nset -euo pipefail\n\n# Validate required environment variable\nif [[ -z \"${CLAUDE_PROJECT_DIR:-}\" ]]; then\n    echo \"Error: CLAUDE_PROJECT_DIR environment variable not set\" >&2\n    exit 1\nfi\n\n# Read JSON input from stdin\ninput=$(cat)\n\n# Extract tool name and command from JSON\ntool_name=$(echo \"$input\" | jq -r '.tool_name // \"\"')\ncommand=$(echo \"$input\" | jq -r '.tool_input.command // \"\"')\n\n# Only process Bash commands\nif [[ \"$tool_name\" != \"Bash\" ]]; then\n    exit 0\nfi\n\n# Only process git commit commands (not git commit --amend which is handled separately)\nif ! echo \"$command\" | grep -qE '^\\s*git\\s+commit(\\s|$)'; then\n    exit 0\nfi\n\n# Allow git commit --amend (special case for pre-commit hook fixes)\nif echo \"$command\" | grep -qE '(\\s|^)--amend\\b'; then\n    exit 0\nfi\n\nSTATE_FILE=\"$CLAUDE_PROJECT_DIR/.claude/.commit-state.json\"\n\n# Check if state file exists\nif [[ ! -f \"$STATE_FILE\" ]]; then\n    cat >&2 <<EOF\n🚫 Commit blocked - creating-commits skill not followed\n\nYou MUST use the 'creating-commits' skill before committing.\n\nRequired workflow:\n1. Use Skill tool: Skill(creating-commits)\n2. Follow ALL checklist steps (use TodoWrite for tracking):\n   - Run 'pnpm fix' to auto-fix and validate\n   - Review changes with 'git diff'\n   - Stage files with 'git add <files>'\n   - Preview staged changes with 'git diff --staged'\n   - Prepare commit message following conventional commits\n   - Write commit state file (.claude/.commit-state.json)\n   - Create commit\n\nThis ensures commits:\n✓ Pass pre-commit hooks\n✓ Follow atomic commit principles\n✓ Use proper conventional commit format\n✓ Maintain clean git history\n\nNever skip this workflow - even for \"simple\" changes.\nSimple changes cause hook failures too.\nEOF\n    exit 2\nfi\n\n# Verify state file is recent (within last 5 minutes)\nif [[ \"$(uname)\" == \"Darwin\" ]]; then\n    file_age=$(($(date +%s) - $(stat -f %m \"$STATE_FILE\")))\nelse\n    file_age=$(($(date +%s) - $(stat -c %Y \"$STATE_FILE\")))\nfi\n\nif [[ $file_age -gt 300 ]]; then\n    cat >&2 <<EOF\n🚫 Commit blocked - stale commit state\n\nThe commit state file is older than 5 minutes.\n\nPlease re-run the 'creating-commits' skill to ensure fresh validation\nbefore committing. This prevents accidentally committing without running\nrecent quality checks.\n\nRun: Skill(creating-commits)\nEOF\n    rm -f \"$STATE_FILE\"\n    exit 2\nfi\n\n# Verify workflow was completed\nif ! jq -e '.workflow_completed == true' \"$STATE_FILE\" >/dev/null 2>&1; then\n    cat >&2 <<EOF\n🚫 Commit blocked - incomplete workflow\n\nThe commit state file exists but does not indicate workflow completion.\n\nPlease re-run the 'creating-commits' skill and complete all steps.\nEOF\n    rm -f \"$STATE_FILE\"\n    exit 2\nfi\n\n# Clean up state file on successful validation\nrm -f \"$STATE_FILE\"\n\n# Allow commit to proceed\nexit 0\n",
        "packages/git-workflow/skills/creating-commits/SKILL.md": "---\nname: creating-commits\ndescription: Use before EVERY git commit - no exceptions. Enforces pre-commit quality checks, atomic commits, and conventional commit format to prevent hook failures and maintain clean history\n---\n\n# Creating Commits\n\nUse before ANY commit - never skip for \"simple\" changes.\n\n## MANDATORY FIRST STEP\n\n**STOP: Create TodoWrite checklist BEFORE running any commands.**\n\n**Correct pattern:**\n\n1. Load this skill ✓\n2. TodoWrite with 6 checklist items (see below) → FIRST response\n3. Execute steps, updating todos (step 1 runs two operations in parallel)\n\n**Wrong pattern (will fail):**\n\n1. Load skill\n2. Run git commands without TodoWrite\n3. Forget a step\n4. Hook blocks commit ❌\n\n## Workflow Checklist\n\n**Create these TodoWrite items as your FIRST action, ALL steps are required:**\n\n1. ☐ Run `pnpm pre-commit` (if available) AND Read `docs/commit_specification.md` (PARALLEL)\n2. ☐ Run `git diff` and analyze staging (see below)\n3. ☐ `git add <files>` (stage atomic unit of related files)\n4. ☐ `git diff --staged` (preview commit)\n5. ☐ Write `.claude/.commit-state.json` (signals workflow completion)\n6. ☐ `git commit -m \"type(scope): description\"`\n\n**Parallel optimization:** Step 1 runs `pnpm pre-commit` (if the script exists) and reads `docs/commit_specification.md` simultaneously since they have no dependencies.\n\n### Steps 2-3: Staging Analysis\n\nBefore running `git add`, check current staging state:\n\n**Never stage files containing secrets** (`.env`, `credentials.json`, `*.pem`, `*_key`, etc.) - warn user if these appear in diff.\n\n**Some files already staged?** User pre-selected - verify staged files form atomic unit.\n\n**No files staged?** After reviewing `git diff`, evaluate what constitutes an atomic unit:\n\n- If all changes form one logical unit → stage all files and proceed\n- If multiple logical changes detected → use AskUserQuestion to ask which atomic unit to commit first, then suggest splitting rest into separate commits\n\n**Multiple logical changes?** See Atomic Commits section below for how to identify and split.\n\n### Step 5: Write Commit State File\n\nWrite this file after steps 1-4 and before step 6:\n\n```bash\ncat > .claude/.commit-state.json <<'EOF'\n{\n  \"workflow_completed\": true\n}\nEOF\n```\n\nThis signals the pre-commit hook that you followed the workflow.\nExpires in 5 minutes, auto-deletes after ANY `git commit` attempt (success or failure).\n\n**If commit fails/is blocked:** Rewrite this file before retrying.\n\n## Commit Message Format\n\n`type(scope): description` - see [docs/commit_specification.md](../../docs/commit_specification.md)\n\n**Focus on PURPOSE, not process:**\n\n- ✅ \"add creating-commits skill for git workflow\"\n- ❌ \"create skill and refactor for efficiency\"\n\nReview FULL diff - message describes collective change, not just latest conversation.\n\n## Atomic Commits\n\nOne logical change per commit.\nIf multiple concerns (mixed types, different scopes, unrelated files) → suggest splitting.\n\n## Breaking Changes\n\nIf breaking backward compatibility → use `feat(api)!: description` and include `BREAKING CHANGE:` footer.\n\n## Common Rationalizations (STOP)\n\n**If you think any of these, STOP and follow checklist:**\n\n- \"Just a comment, skip checks\" → Comments have syntax errors\n- \"User gave message, skip preview\" → Can't see what's staged\n- \"Too simple for `pnpm pre-commit`\" → Hooks fail on \"simple\" changes\n- \"One extra file won't hurt\" → Breaks atomic commits\n\n## When Checks Fail\n\n**`pnpm pre-commit` fails on your changes?** Fix before committing.\n\n**`pnpm pre-commit` fails on unrelated code?** Ask user:\n\n1. Fix unrelated error first\n2. Commit anyway (requires their decision)\n3. Investigate error\n\nNever assume \"error is unrelated, skip check\" - ask.\n\n## Never Use `--no-verify`\n\nNever use `git commit --no-verify` without **explicitly asking user permission first in bold text.**\n",
        "packages/git-workflow/skills/pull-request-conventions/SKILL.md": "---\nname: pull-request-conventions\ndescription: Use when creating or merging pull requests - provides branch naming, PR title format, and description requirements for consistent PR workflows\n---\n\n# Pull Request Conventions\n\n## Branch Naming Convention\n\n**Format:** `<type>/<issue-number>-<description>` or `<type>/<description>`\n\n**Types** (must match conventional commit types):\n\n- `feat` - New feature\n- `fix` - Bug fix\n- `docs` - Documentation only\n- `chore` - Maintenance tasks\n- `refactor` - Code restructuring\n- `test` - Adding or updating tests\n- `build` - Build system changes\n- `ci` - CI configuration\n- `perf` - Performance improvements\n- `style` - Code style changes (formatting, etc.)\n\n**Examples:**\n\n- `feat/123-user-auth`\n- `fix/login-error`\n- `docs/api-guide`\n- `refactor/simplify-validation`\n\n## PR Title Convention\n\nPR titles must follow Conventional Commits format.\n\n**Format:** `<type>[optional scope]: <description>`\n\n**Why:** PR title becomes the squash merge commit message on main.\n\n**Examples:**\n\n- `feat(auth): add JWT validation`\n- `fix: resolve login error`\n- `docs(api): update endpoint documentation`\n\n## Deriving PR Title\n\n**Primary source: commits.**\nThe PR title should reflect what the changes actually accomplish, not just the branch name.\n\n**Process:**\n\n1. Review commit history to understand the changes\n2. Identify the primary type (`feat`, `fix`, `refactor`, etc.)\n3. Summarize the changes concisely\n4. Add scope if clearly scoped to a specific area\n\n**Branch name as fallback:**\nIf starting from branch name (e.g., when branch already exists), use it as a hint:\n\n1. Extract type from prefix: `feat/...` → `feat`\n2. Remove issue number if present: `feat/123-user-auth` → `user auth`\n3. Convert hyphens to spaces\n\n**Scope is optional** - add when the change is clearly scoped to a specific area:\n\n- `feat/auth-jwt-validation` → `feat(auth): jwt validation`\n- `fix/login-error` → `fix: login error` (no obvious scope)\n\n**Important:** The branch name may diverge from actual changes during development.\nAlways verify the title accurately reflects what the PR contains.\n\n## PR Description Requirements\n\n**Foundational principle: Description must be 100% accurate.**\n\n### Required Sections\n\n```markdown\n## Summary\n\n<1-3 bullet points describing what changed and why>\n\n## Test plan\n\n<How to verify the changes work>\n```\n\n### Accuracy Rules\n\nThe description must reflect the **final state** of changes, not the journey:\n\n- If code was added then removed: don't mention it\n- If approach changed mid-development: describe final approach only\n- If features were split to other PRs: don't reference them\n\n### Common Red Flags\n\nWhen reviewing PR descriptions, watch for:\n\n- Mentions features that were removed\n- Describes approach that was changed\n- References safeguards that were removed\n- Contains code examples that don't match final implementation\n"
      },
      "plugins": [
        {
          "name": "git-workflow",
          "description": "Git workflow skills with enforcement hooks for commits, PRs, and code review",
          "version": "0.1.0",
          "source": "./packages/git-workflow",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add zookanalytics/claude-devcontainer",
            "/plugin install git-workflow@claude-devcontainer"
          ]
        },
        {
          "name": "bmad-orchestrator",
          "description": "BMAD workflow orchestration for AI-driven development",
          "version": "0.1.0",
          "source": "./packages/bmad-orchestrator",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add zookanalytics/claude-devcontainer",
            "/plugin install bmad-orchestrator@claude-devcontainer"
          ]
        },
        {
          "name": "claude-instance",
          "description": "Multi-instance management with session purpose tracking",
          "version": "0.1.0",
          "source": "./packages/claude-instance",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add zookanalytics/claude-devcontainer",
            "/plugin install claude-instance@claude-devcontainer"
          ]
        }
      ]
    }
  ]
}