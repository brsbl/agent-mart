{
  "author": {
    "id": "asermax",
    "display_name": "Agustín Carrasco",
    "avatar_url": "https://avatars.githubusercontent.com/u/1452164?v=4"
  },
  "marketplaces": [
    {
      "name": "asermax-plugins",
      "version": null,
      "description": "AUR package management commands for building and maintaining Arch User Repository packages",
      "repo_full_name": "asermax/claude-plugins",
      "repo_url": "https://github.com/asermax/claude-plugins",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-02-17T05:27:14Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"asermax-plugins\",\n  \"metadata\": {\n    \"version\": \"2.11.7\"\n  },\n  \"owner\": {\n    \"name\": \"Agustin Carrasco\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"aur\",\n      \"source\": \"./aur\",\n      \"description\": \"AUR package management commands for building and maintaining Arch User Repository packages\"\n    },\n    {\n      \"name\": \"superpowers\",\n      \"source\": \"./superpowers\",\n      \"description\": \"Development workflow skills for systematic debugging, code review, planning, and more\"\n    },\n    {\n      \"name\": \"quint\",\n      \"source\": \"./quint\",\n      \"description\": \"FPF reasoning methodology for structured decision-making with auditable hypothesis-evidence trails\"\n    },\n    {\n      \"name\": \"openspec\",\n      \"source\": \"./openspec\",\n      \"description\": \"Spec-driven development with Draft -> Review -> Implement -> Archive workflow for requirement alignment\"\n    },\n    {\n      \"name\": \"katachi\",\n      \"source\": \"./katachi\",\n      \"description\": \"Spec-driven development framework with iterative growth, progressive adoption, and retrofit support\"\n    },\n    {\n      \"name\": \"memu\",\n      \"source\": \"./memu\",\n      \"description\": \"Agentic memory framework for long-term memory, user preferences, and conversation history\"\n    }\n  ]\n}\n",
        "README.md": "# Claude Code Plugins\n\nPersonal collection of Claude Code plugins for development workflows.\n\n## Available Plugins\n\n### aur\n\nAUR package management commands for building and maintaining Arch User Repository packages.\n\n**Commands:**\n- `/aur:bump-version [version]` - Bump the AUR package version, update checksums, and commit\n- `/aur:create-aur-package <package-name> <source-type>` - Create a new AUR package\n\n[View Documentation](./aur/README.md)\n\n### superpowers\n\nDevelopment workflow skills for systematic debugging, code review, planning, and more.\n\n**Commands:**\n- `/update-superpowers-skills` - Sync skills from upstream repositories and intelligently merge updates\n\n**Skills:**\n- Core Development Workflow (brainstorming, executing-plans, receiving-code-review, requesting-code-review, writing-plans)\n- Debugging and Testing (root-cause-tracing, systematic-debugging, test-driven-development, testing-skills-activation, testing-skills-with-subagents)\n- Documentation and Research (self-maintaining-claude-md, skill-creator, using-live-documentation, writing-skills)\n- Project Management (using-beads)\n- Multi-Agent Collaboration (agent-communication)\n\n[View Documentation](./superpowers/README.md)\n\n## Installation\n\n### From Local Marketplace\n\n1. Add this directory as a local marketplace:\n   ```bash\n   /plugin marketplace add local ~/workspace/asermax/claude-plugins\n   ```\n\n2. Install a plugin:\n   ```bash\n   /plugin install <plugin-name>\n   ```\n\n### Direct Installation\n\n```bash\n/plugin install ~/workspace/asermax/claude-plugins/<plugin-name>\n```\n\n## Repository Structure\n\n```\n.\n├── .claude-plugin/\n│   └── marketplace.json      # Marketplace configuration\n├── aur/                       # AUR package management plugin\n│   ├── .claude-plugin/\n│   │   └── plugin.json\n│   ├── commands/\n│   └── README.md\n├── superpowers/               # Development workflow skills plugin\n│   ├── .claude-plugin/\n│   │   └── plugin.json\n│   ├── commands/\n│   ├── skills/\n│   ├── agents/\n│   ├── hooks/\n│   └── README.md\n├── CLAUDE.md                  # Repository documentation for Claude Code\n└── README.md\n```\n",
        "aur/README.md": "# aur\n\nAUR package management commands for building and maintaining Arch User Repository packages.\n\n## Description\n\nThis plugin provides commands for working with AUR (Arch User Repository) packages, including version bumping and package creation workflows.\n\n## Commands\n\n- `/bump-version` - Bump the AUR package version, update checksums, and commit\n- `/create-aur-package` - Create a new AUR package\n\n## Installation\n\n### From Local Marketplace\n\n1. Add this directory as a local marketplace:\n   ```bash\n   /plugin marketplace add local ~/workspace/asermax/claude-plugins\n   ```\n\n2. Install the plugin:\n   ```bash\n   /plugin install aur\n   ```\n\n### Direct Installation\n\n```bash\n/plugin install ~/workspace/asermax/claude-plugins/aur\n```\n\n## Version\n\n1.0.0\n",
        "superpowers/README.md": "# superpowers\n\nDevelopment workflow skills for systematic debugging, code review, planning, and more.\n\n## Description\n\nThis plugin provides a collection of Claude Code skills that establish proven workflows for common development tasks. These skills help ensure consistent, high-quality approaches to debugging, code review, planning, and implementation.\n\n## Skills\n\nThe plugin includes the following skills:\n\n### Core Development Workflow\n- **requesting-code-review**: Request code reviews before merging to verify work meets requirements\n- **using-code-directives**: Recognize and handle code directives (@implement, @docs, @refactor, @test, @todo) embedded in comments with context-dependent transformations\n\n### Debugging and Testing\n- **systematic-debugging**: Four-phase debugging framework ensuring understanding before solutions\n- **testing-skills-activation**: Systematically test and iterate on skill descriptions to ensure correct activation patterns\n\n### Documentation and Research\n- **self-maintaining-claude-md**: Keep CLAUDE.md instruction file current with high-level project state\n- **using-live-documentation**: Dispatch subagents to fetch library documentation with massive context savings (10,000-20,000 tokens per search)\n\n### Browser Automation\n- **agent-browser**: Browser automation CLI for web testing, form filling, screenshots, and data extraction\n\n### Multi-Agent Collaboration\n- **agent-communication**: Enable communication between multiple Claude Code instances across repositories\n\n### Other\n- **using-gemini**: Analyze images, videos, fetch web content, and search Google using Gemini CLI\n- **financial-summary**: Parse and analyze financial transaction CSV exports\n\n## Commands\n\n- `/superpowers:update-skills`: Pull latest changes from the upstream superpowers repository and show differences\n- `/superpowers:evolve-situation-state <input> [state-file]`: Maintain a living state document that evolves incrementally from transcripts, documents, and external sources\n- `/superpowers:evolve <problem>`: Evolve novel algorithms through LLM-driven mutation, crossover, and selection\n  - Uses 8 parallel mutation strategies: tweak, unroll, specialize, vectorize, memoize, restructure, hybrid, alien\n  - Dynamically scales from 10-32 agents based on problem complexity\n  - Supports configurable token budgets (e.g., `50k`, `20gen`, `unlimited`)\n  - Adaptive stopping when improvements plateau\n  - Resume capability via `--resume` flag\n  - Example: `/superpowers:evolve \"fibonacci sequence\"` or `/superpowers:evolve \"Optimize the string search in src/search.rs\" --budget 50k`\n- `/superpowers:process-directives <request>`: Scan and process code directives based on natural language request\n  - Example: `/superpowers:process-directives \"implement all @implement directives in src/\"`\n  - Example: `/superpowers:process-directives \"process @todo comments in auth module\"`\n  - Supports @implement, @docs, @refactor, @test, @todo directives\n  - Applies context-dependent transformations (remove vs. convert to docs)\n\n## Installation\n\n### From Local Marketplace\n\n1. Add this directory as a local marketplace:\n   ```bash\n   /plugin marketplace add local ~/workspace/asermax/claude-plugins\n   ```\n\n2. Install the plugin:\n   ```bash\n   /plugin install superpowers\n   ```\n\n### Direct Installation\n\n```bash\n/plugin install ~/workspace/asermax/claude-plugins/superpowers\n```\n\n## Updating Skills\n\nTo sync skills with the upstream repository:\n\n```bash\n/superpowers:update-skills\n```\n\nThis command will:\n1. Pull latest changes from `~/workspace/random/superpowers`\n2. Compare existing skills with updated versions\n3. Show differences for each skill\n4. Ask for confirmation before updating\n\n## Version\n\n1.0.0\n",
        "quint/README.md": "# Quint Plugin\n\nFPF (First Principles Framework) methodology for structured reasoning and decision-making.\n\n## Overview\n\nThis plugin integrates the quint-code framework for systematic hypothesis generation, verification, and validation. It implements a rigorous ADI (Abduction-Deduction-Induction) reasoning cycle to help make auditable architectural and implementation decisions.\n\n## Commands\n\n### Core Reasoning Cycle (Q0-Q5)\n\n| Command | Phase | Description |\n|---------|-------|-------------|\n| `/q0-init` | Setup | Initialize knowledge base and bounded context |\n| `/q1-hypothesize` | Abduction | Generate multiple competing L0 hypotheses |\n| `/q1-add` | Abduction | Manually add a custom hypothesis |\n| `/q2-verify` | Deduction | Verify logical consistency, promote L0→L1 |\n| `/q3-validate` | Induction | Gather empirical evidence, promote L1→L2 |\n| `/q4-audit` | Audit | Calculate trust scores and assurance levels |\n| `/q5-decide` | Decision | Select winning hypothesis, create Design Rationale Record |\n\n### Utility Commands\n\n| Command | Description |\n|---------|-------------|\n| `/q-status` | Display current reasoning cycle state |\n| `/q-query` | Search the knowledge base |\n| `/q-decay` | Report expired evidence (epistemic debt) |\n| `/q-actualize` | Reconcile knowledge base with code changes |\n| `/q-reset` | Discard current reasoning cycle |\n\n## Key Concepts\n\n### Knowledge Levels\n\n- **L0 (Observation)**: Raw hypotheses, unverified claims\n- **L1 (Reasoned)**: Logically verified, constraint-checked\n- **L2 (Verified)**: Empirically tested and validated\n- **Invalid**: Disproved claims (retained for learning)\n\n### Trust Calculation\n\n- **WLNK (Weakest Link)**: Assurance is capped by the weakest evidence, not averaged\n- **Congruence Level (CL0-CL3)**: How well external evidence matches your project context\n- **Evidence Decay**: Evidence expires over time, creating \"epistemic debt\"\n\n### Design Rationale Records (DRR)\n\nFinal decisions are documented with:\n- Selected hypothesis and supporting evidence\n- Alternatives considered and why they were rejected\n- Conditions under which the decision should be revisited\n- Audit trail of the reasoning process\n\n## MCP Server\n\nThe plugin uses the quint-code MCP server for state management:\n- **Binary**: Built from `~/workspace/random/quint-code/src/mcp`\n- **Installation**: Installed to `~/.local/bin/quint-code`\n- **Database**: SQLite database in `.quint/quint.db` (project-local)\n\n## Workflow Example\n\n1. **Initialize** (Q0): Set up knowledge base with bounded context\n   ```\n   /q0-init\n   ```\n\n2. **Generate Hypotheses** (Q1): Create multiple competing approaches\n   ```\n   /q1-hypothesize\n   ```\n\n3. **Verify Logic** (Q2): Check internal consistency\n   ```\n   /q2-verify\n   ```\n\n4. **Validate Empirically** (Q3): Gather evidence through tests/research\n   ```\n   /q3-validate\n   ```\n\n5. **Audit** (Q4): Calculate trust scores\n   ```\n   /q4-audit\n   ```\n\n6. **Decide** (Q5): Select winner and create DRR\n   ```\n   /q5-decide\n   ```\n\n## When to Use\n\n**Use quint for:**\n- Architectural decisions with long-term consequences\n- Multiple viable approaches requiring systematic evaluation\n- Decisions needing an auditable reasoning trail\n- Building organizational knowledge over time\n\n**Skip quint for:**\n- Quick fixes with obvious solutions\n- Easily reversible decisions\n- Time-critical situations where overhead isn't justified\n\n## Syncing from Upstream\n\nCommands are synced from the [quint-code](https://github.com/m0n0x41d/quint-code) repository:\n\n```bash\n/sync-upstream\n```\n\nThis will:\n1. Pull latest changes from `~/workspace/random/quint-code`\n2. Copy command files to the plugin\n3. Rebuild and install the MCP binary\n\n## References\n\n- **Upstream**: https://github.com/m0n0x41d/quint-code\n- **FPF Methodology**: Anatoly Levenchuk's First Principles Framework\n- **Local Clone**: `~/workspace/random/quint-code`\n",
        "katachi/README.md": "# katachi (形)\n\nA spec-driven development framework plugin for Claude Code.\n\n**katachi** means \"form\" or \"shape\" in Japanese - the structure you give to your projects.\n\n## Philosophy\n\n- **Spec-driven development** - Define what to build before coding\n- **Iterative growth** - Start with MVP, add features progressively\n- **Progressive adoption** - Use as much or as little as you need\n- **Retrofit support** - Document existing code, not just new projects\n\n## Quick Start\n\n```\n/katachi:init-framework    # Initialize framework in your project\n```\n\nThe framework will detect your project state and offer appropriate options:\n- **New project**: Quick-start (MVP) or full framework setup\n- **Existing project**: Retrofit options to document existing code\n- **Partial setup**: Complete missing pieces\n\n## Skills\n\nAll functionality is exposed as skills in the `skills/` directory. User-facing skills are invoked via `/katachi:<name>`, while supporting skills are loaded automatically by other skills.\n\n### Initialization\n- `/katachi:init-framework` - Initialize framework in a project\n- `/katachi:eject` - Eject plugin into self-contained project structure\n\n### Planning\n- `/katachi:vision` - Create/update project vision\n- `/katachi:deltas` - Extract deltas from vision\n- `/katachi:dependencies` - Build dependency matrix\n\n### Per-Delta Workflow\n- `/katachi:add-delta [description]` - Add new delta on-the-go\n- `/katachi:spec-delta <ID>` - Write delta specification\n- `/katachi:design-delta <ID>` - Write design rationale\n- `/katachi:plan-delta <ID>` - Create implementation plan\n- `/katachi:implement-delta <ID>` - Implement following plan\n- `/katachi:reconcile-delta <ID>` - Update feature documentation\n\n### Migration\n- `/katachi:migrate-to-deltas` - Migrate existing katachi project to delta-based workflow\n\n### Retrofit\n- `/katachi:retrofit-spec <path>` - Create spec from existing code\n- `/katachi:retrofit-design <ID>` - Create design from existing code\n- `/katachi:retrofit-decision <topic>` - Document existing decisions\n\n### Documentation & Analysis\n- `/katachi:decision` - Document architecture/design decision\n- `/katachi:analyze` - Gap analysis\n- `/katachi:analyze-impact [change]` - Analyze change impact\n- `/katachi:delta-summary [filter]` - View delta status summary\n- `/katachi:optimize-docs [scope]` - Optimize documentation\n- `/katachi:review-priorities` - Review and assign delta priorities\n\n### Development\n- `/katachi:review-code` - Review code with decision compliance\n- `/katachi:commit` - Create conventional commits\n\n### Supporting Skills (not user-invocable)\n- `katachi:framework-core` - Workflow principles and conventions\n- `katachi:working-on-delta` - Per-delta workflow orchestration\n- `katachi:iterative-development` - Progressive development support\n- `katachi:retrofit-existing` - Retrofit workflow patterns\n\n## Agents\n\nThe framework uses specialized agents for validation:\n\n| Agent | Purpose |\n|-------|---------|\n| `spec-reviewer` | Review specs for completeness and testability |\n| `design-reviewer` | Review designs for coherence and pattern alignment |\n| `plan-reviewer` | Review plans for step completeness |\n| `code-reviewer` | Review code against specs, designs, and decisions |\n| `impact-analyzer` | Analyze change impact on dependencies |\n| `codebase-analyzer` | Infer requirements/decisions from existing code |\n\n## Project Structure\n\nAfter initialization, your project will have:\n\n```\nyour-project/\n└── docs/\n    ├── planning/\n    │   ├── VISION.md        # Project vision and scope\n    │   ├── DELTAS.md        # Delta inventory (work items)\n    │   └── DEPENDENCIES.md  # Dependency matrix\n    ├── delta-specs/         # Working delta specifications\n    ├── delta-designs/       # Working delta designs\n    ├── delta-plans/         # Implementation plans\n    ├── feature-specs/       # Long-lived feature documentation\n    ├── feature-designs/     # Long-lived design documentation\n    ├── architecture/        # Architecture Decision Records (ADRs)\n    └── design/              # Design patterns (DES)\n```\n\n## Workflow\n\n### For New Projects\n\n1. `/katachi:init-framework` - Choose quick-start or full\n2. `/katachi:vision` - Define problem and scope\n3. `/katachi:deltas` - Extract deltas (work items)\n4. `/katachi:dependencies` - Build dependency matrix\n5. For each delta: spec → design → plan → implement → reconcile\n\n### For Existing Projects\n\n1. `/katachi:init-framework` - Choose retrofit\n2. `/katachi:retrofit-spec` - Document existing modules\n3. `/katachi:retrofit-decision` - Document existing choices\n4. Continue with normal workflow\n\n### Adding Deltas Mid-Project\n\n1. `/katachi:add-delta` - Describe the new work item\n2. Framework assigns ID, analyzes dependencies, integrates into matrix\n3. Continue with spec → design → plan → implement → reconcile\n\n## Ejecting the Plugin\n\nIf you want to make your project self-contained and independent of the katachi plugin:\n\n```\n/katachi:eject\n```\n\nThis will:\n- Copy all skills to `.claude/skills/`\n- Copy reviewer agents to `.claude/agents/`\n- Copy deltas.py script to `scripts/`\n- Generate framework documentation in `docs/`\n- Copy all templates to `docs/templates/`\n- Transform all plugin references to local paths\n\nAfter ejecting, you can uninstall the plugin and continue using all katachi skills locally.\n",
        "memu/README.md": "# memU Plugin for Claude Code\n\nAgentic memory framework integration that enables Claude to remember information across sessions.\n\n## Overview\n\nThe memU plugin provides persistent memory for Claude Code using memU's three-layer hierarchy:\n\n- **Resources**: Raw conversation data from sessions\n- **Items**: Extracted memory units (preferences, skills, opinions, habits)\n- **Categories**: Aggregated summaries with full traceability\n\n### How It Works\n\n1. **Auto-memorization**: When a Claude Code session ends, conversations are automatically memorized (via SessionEnd hook)\n2. **On-demand retrieval**: When you ask questions that could benefit from past context, Claude retrieves relevant memories (via recall-memory skill)\n\n## Prerequisites\n\n- Python 3.7+ (no external libraries required - uses only built-in modules)\n- memU API key from [memu.so](https://memu.so)\n\n## Installation\n\n### 1. Install the Plugin\n\n```bash\ncd /path/to/claude-code-session\n/plugin install ~/workspace/asermax/claude-plugins/memu\n```\n\nOr add to your project's Claude Code configuration.\n\n### 2. Set API Key\n\nGet your API key from [memu.so](https://memu.so) and set it as an environment variable:\n\n```bash\nexport MEMU_API_KEY=your_api_key_here\n```\n\nTo make this permanent, add to your shell profile (`~/.bashrc`, `~/.zshrc`, etc.):\n\n```bash\necho 'export MEMU_API_KEY=your_api_key_here' >> ~/.bashrc\nsource ~/.bashrc\n```\n\n### 3. Verify Installation\n\nStart a Claude Code session and ask:\n\n```\nWhat are my coding preferences?\n```\n\nIf no memories exist yet, Claude will indicate it doesn't have stored information. After a few sessions, memories will accumulate.\n\n## Features\n\n### Automatic Memorization\n\nEvery time you end a Claude Code session, the conversation is automatically sent to memU for processing. This happens in the background and doesn't block session exit.\n\n**What gets memorized**:\n- All conversations from the session\n- Preferences you express\n- Coding patterns and workflows\n- Decisions and opinions\n- Technical choices\n\n**Memory scope**: Memories are isolated per project (based on git remote URL or folder path).\n\n### Smart Retrieval\n\nThe `recall-memory` skill activates when you ask questions that could benefit from historical context:\n\n**Triggers on**:\n- \"What do I prefer?\"\n- \"How do I usually handle X?\"\n- \"What did we discuss about Y?\"\n- \"What's my approach to Z?\"\n\n**Doesn't trigger on**:\n- General knowledge questions (\"What is TypeScript?\")\n- Current session facts\n- File operations\n- Code generation tasks\n\n### Two Retrieval Methods\n\n**RAG (Recommended)**:\n- Fast vector-based retrieval (<2 seconds)\n- Good for specific factual queries\n- Default method\n\n**LLM**:\n- Deep semantic understanding (5-10 seconds)\n- Good for complex or ambiguous questions\n- Used automatically when needed\n\n## Usage Examples\n\n### Example 1: Learning Preferences\n\n**Session 1**:\n```\nYou: I prefer using TypeScript with strict mode enabled\n```\n\n(Session ends → auto-memorized)\n\n**Session 2**:\n```\nYou: What languages do I prefer?\nClaude: Based on our previous discussions, you prefer TypeScript with strict mode enabled.\n```\n\n### Example 2: Workflow Patterns\n\n**Session 1**:\n```\nYou: When I refactor code, I always write tests first, then make small incremental changes\n```\n\n(Session ends → auto-memorized)\n\n**Session 2**:\n```\nYou: How do I usually approach refactoring?\nClaude: You follow a test-first approach: write tests before refactoring, then make small incremental changes to minimize risk.\n```\n\n### Example 3: No Prior Knowledge\n\n```\nYou: What do you know about my deployment process?\nClaude: I don't have any stored information about your deployment process yet. We haven't discussed this in previous sessions.\n```\n\n## Troubleshooting\n\n### Error: MEMU_API_KEY not set\n\n**Problem**: The script can't find your API key.\n\n**Solution**:\n```bash\nexport MEMU_API_KEY=your_api_key_here\n```\n\nVerify it's set:\n```bash\necho $MEMU_API_KEY\n```\n\n### Error: API request failed\n\n**Problem**: Network issue or memU API is down.\n\n**Solutions**:\n1. Check internet connection\n2. Verify API key is valid at [memu.so](https://memu.so)\n3. Check memU service status\n4. Try again later\n\n### Skill not activating\n\n**Problem**: recall-memory skill doesn't trigger on your question.\n\n**Cause**: The question might be too general or not history-related.\n\n**Examples**:\n- ✅ \"What are my coding preferences?\" (triggers)\n- ❌ \"What is Python?\" (doesn't trigger - general knowledge)\n- ✅ \"How do I usually structure React components?\" (triggers)\n- ❌ \"Create a React component\" (doesn't trigger - generation task)\n\n### No memories found\n\n**Problem**: Claude says it doesn't have information.\n\n**Causes**:\n1. Topic hasn't been discussed yet\n2. Different project scope (memories are per-project)\n3. API key changed (different memU account)\n\n**Solution**: Have a conversation about the topic, end the session, then ask in a new session.\n\n## Privacy & Data\n\n- **Scope**: Memories are isolated per project using a hash of the git remote URL (or folder path)\n- **Storage**: Data is stored in memU's cloud service (memu.so)\n- **API Key**: Your API key controls access to your memories\n- **Deletion**: Manage data through memU's web interface at [memu.so](https://memu.so)\n\n## Technical Details\n\n### Project Identification\n\nThe plugin derives a unique project ID from:\n1. Git remote URL (if available) - hashed to 16 characters\n2. Current directory path (fallback) - hashed to 16 characters\n\nThis ensures memories stay isolated per project.\n\n### Hook Execution\n\nThe SessionEnd hook:\n1. Receives conversation transcript\n2. Forks background process\n3. Returns immediately (no blocking)\n4. Background process memorizes via memU API\n\n### Script Dependencies\n\nThe Python script uses only built-in Python libraries:\n- `urllib.request` and `urllib.error` for HTTP calls\n- `hashlib` for project ID hashing\n- `subprocess` for git commands\n- `json` for data handling\n- `argparse` for CLI argument parsing\n\nNo external dependencies required - works with standard Python installation.\n\n## License\n\nApache License 2.0\n\n## Support\n\nFor issues or questions:\n- memU service: [memu.so](https://memu.so)\n- Plugin issues: File an issue in the plugin repository\n"
      },
      "plugins": [
        {
          "name": "aur",
          "source": "./aur",
          "description": "AUR package management commands for building and maintaining Arch User Repository packages",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add asermax/claude-plugins",
            "/plugin install aur@asermax-plugins"
          ]
        },
        {
          "name": "superpowers",
          "source": "./superpowers",
          "description": "Development workflow skills for systematic debugging, code review, planning, and more",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add asermax/claude-plugins",
            "/plugin install superpowers@asermax-plugins"
          ]
        },
        {
          "name": "quint",
          "source": "./quint",
          "description": "FPF reasoning methodology for structured decision-making with auditable hypothesis-evidence trails",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add asermax/claude-plugins",
            "/plugin install quint@asermax-plugins"
          ]
        },
        {
          "name": "openspec",
          "source": "./openspec",
          "description": "Spec-driven development with Draft -> Review -> Implement -> Archive workflow for requirement alignment",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add asermax/claude-plugins",
            "/plugin install openspec@asermax-plugins"
          ]
        },
        {
          "name": "katachi",
          "source": "./katachi",
          "description": "Spec-driven development framework with iterative growth, progressive adoption, and retrofit support",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add asermax/claude-plugins",
            "/plugin install katachi@asermax-plugins"
          ]
        },
        {
          "name": "memu",
          "source": "./memu",
          "description": "Agentic memory framework for long-term memory, user preferences, and conversation history",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add asermax/claude-plugins",
            "/plugin install memu@asermax-plugins"
          ]
        }
      ]
    }
  ]
}