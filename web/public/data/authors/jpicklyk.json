{
  "author": {
    "id": "jpicklyk",
    "display_name": "Jeff Picklyk",
    "avatar_url": "https://avatars.githubusercontent.com/u/5747775?v=4"
  },
  "marketplaces": [
    {
      "name": "task-orchestrator-marketplace",
      "version": null,
      "description": "MCP Task Orchestrator - Hierarchical task management with AI workflows",
      "repo_full_name": "jpicklyk/task-orchestrator",
      "repo_url": "https://github.com/jpicklyk/task-orchestrator",
      "repo_description": "A light touch MCP task orchestration server for AI agents. Persistent project tracking and context storage across sessions. Defines planning floors through composable templates.   Coordinates multi-agent execution without prescribing how agents do their work.",
      "signals": {
        "stars": 158,
        "forks": 18,
        "pushed_at": "2026-02-20T00:01:05Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"task-orchestrator-marketplace\",\n  \"owner\": {\n    \"name\": \"Jeff Picklyk\"\n  },\n  \"metadata\": {\n    \"description\": \"MCP Task Orchestrator - Hierarchical task management with AI workflows\",\n    \"version\": \"2.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"task-orchestrator\",\n      \"version\": \"1.1.1\",\n      \"description\": \"Skills, hooks, and workflows for MCP Task Orchestrator (v3). Schema-aware context, note-driven workflow, and thin session hooks.\",\n      \"author\": {\n        \"name\": \"Jeff Picklyk\",\n        \"url\": \"https://github.com/jpicklyk\"\n      },\n      \"homepage\": \"https://github.com/jpicklyk/task-orchestrator\",\n      \"repository\": \"https://github.com/jpicklyk/task-orchestrator\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"task-management\", \"project-management\", \"workflow\", \"mcp\", \"ai-orchestration\"],\n      \"category\": \"productivity\",\n      \"tags\": [\"tasks\", \"features\", \"projects\", \"dependencies\", \"workflows\", \"v3\"],\n      \"source\": \"./claude-plugins/task-orchestrator\",\n      \"strict\": true\n    }\n  ]\n}\n",
        "README.md": "# MCP Task Orchestrator\n\n**Stop losing context. Start building faster.**\n\nAn orchestration framework for AI coding assistants that solves context pollution and token exhaustion — enabling your AI to work on complex projects without running out of memory.\n\n[![Version](https://img.shields.io/github/v/tag/jpicklyk/task-orchestrator?sort=semver)](https://github.com/jpicklyk/task-orchestrator/releases)\n[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)\n[![MCP Compatible](https://img.shields.io/badge/MCP-Compatible-purple)](https://modelcontextprotocol.io)\n\n---\n\n## Why This Exists\n\nAI agents [exhaust their effective context windows](https://www.anthropic.com/news/context-management) on long-running tasks — conversation history, tool outputs, and code examples accumulate until the model loses focus and fails. Task Orchestrator implements [industry-recommended patterns](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents) to prevent this: persistent external memory, summary-based phase handoffs, and sub-agent isolation with clean contexts. Work scales to 50+ tasks with up to 90% token reduction and zero time rebuilding context after session restarts.\n\n---\n\n## Key Features\n\n- ✅ **Persistent Memory** — AI remembers project state, completed work, and decisions across sessions\n- ✅ **Token Efficiency** — Up to 90% reduction via just-in-time context loading and note-based handoffs\n- ✅ **Hierarchical WorkItems** — Flexible depth hierarchy (up to 4 levels) with any nesting structure you need\n- ✅ **Note Schemas** — Per-item documentation requirements that gate phase transitions; enforced by the server\n- ✅ **Role-Based Workflow** — `queue → work → review → terminal` with named triggers and automatic dependency enforcement\n- ✅ **Dependency Graph** — Typed BLOCKS edges with pattern shortcuts (linear chains, fan-out, fan-in) and BFS traversal\n- ✅ **Sub-Agent Orchestration** — Delegated execution for complex work (Claude Code)\n- ✅ **Skills & Hooks** — Workflow coordination skills and event-driven automation (Claude Code plugin)\n- ✅ **MCP Protocol Support** — Core persistence and task management work with any MCP client\n\n---\n\n## Quick Start\n\n**Prerequisite**: [Docker](https://www.docker.com/products/docker-desktop/) must be installed and running.\n\n### Step 1: Pull the image\n\n```bash\ndocker pull ghcr.io/jpicklyk/task-orchestrator:latest\n```\n\nThis is a one-time step — Docker caches the image locally. Pulling first ensures your MCP client connects instantly rather than waiting silently on first launch.\n\n### Step 2: Register with your MCP client\n\nChoose the option that matches your setup:\n\n#### Option A: Claude Code (CLI — recommended)\n\nRegister the server once from your terminal:\n\n```bash\nclaude mcp add-json mcp-task-orchestrator '{\n  \"command\": \"docker\",\n  \"args\": [\n    \"run\", \"--rm\", \"-i\",\n    \"-v\", \"mcp-task-data:/app/data\",\n    \"ghcr.io/jpicklyk/task-orchestrator:latest\"\n  ]\n}'\n```\n\nRestart Claude Code, then run `/mcp` to confirm `mcp-task-orchestrator` is connected.\n\n#### Option B: Project `.mcp.json`\n\nAdd to `.mcp.json` in your project root (checked into source control so teammates get it automatically):\n\n```json\n{\n  \"mcpServers\": {\n    \"mcp-task-orchestrator\": {\n      \"command\": \"docker\",\n      \"args\": [\n        \"run\", \"--rm\", \"-i\",\n        \"-v\", \"mcp-task-data:/app/data\",\n        \"ghcr.io/jpicklyk/task-orchestrator:latest\"\n      ]\n    }\n  }\n}\n```\n\nThe `mcp-task-data` Docker volume persists the SQLite database across container restarts. The server auto-initializes its schema on first run — no additional setup required.\n\n#### Option C: Other MCP Clients\n\nConfigure your client with the same JSON as Option A above. STDIO transport works with any MCP-compatible client.\n\n### Advanced: Per-Project Note Schemas\n\nBy default the server runs in schema-free mode — all 13 tools work with no additional configuration. If you want to define custom note schemas that gate role transitions (e.g., require an acceptance-criteria note before a work item can advance), you can point the server at your project's `.taskorchestrator/config.yaml`.\n\nAdd the config mount to your **Option B** `.mcp.json` only (not the global Option A registration — a globally-registered server should not have its schema config vary per project):\n\n```json\n{\n  \"mcpServers\": {\n    \"mcp-task-orchestrator\": {\n      \"command\": \"docker\",\n      \"args\": [\n        \"run\", \"--rm\", \"-i\",\n        \"-v\", \"mcp-task-data:/app/data\",\n        \"-v\", \"${workspaceFolder}/.taskorchestrator:/project/.taskorchestrator:ro\",\n        \"-e\", \"AGENT_CONFIG_DIR=/project\",\n        \"ghcr.io/jpicklyk/task-orchestrator:latest\"\n      ]\n    }\n  }\n}\n```\n\n> **Security note:** Only the `.taskorchestrator/` folder is mounted — the server has no access to the rest of your project. The container's `/project` path contains nothing else.\n\nSee [Workflow Guide](current/docs/workflow-guide.md) for the `.taskorchestrator/config.yaml` schema format and examples.\n\n### Step 3: Claude Code Plugin (optional)\n\nThe plugin adds workflow skills, automation hooks, and an orchestrator output style to Claude Code. The MCP server (Step 2) must be connected first.\n\n**Install:**\n\n```\n/plugin marketplace add https://github.com/jpicklyk/task-orchestrator\n/plugin install task-orchestrator@task-orchestrator-marketplace\n```\n\nAfter installing, restart Claude Code and verify with `/plugin list` — you should see `task-orchestrator` enabled.\n\n**Skills** — invoke as slash commands in any Claude Code session:\n\n| Command | Description |\n|---------|-------------|\n| `/task-orchestrator:work-summary` | Insight-driven dashboard: active work, blockers, and next actions |\n| `/task-orchestrator:create-item` | Create a tracked work item from the current conversation context |\n| `/task-orchestrator:status-progression` | Navigate role transitions; shows gate status and the correct trigger |\n| `/task-orchestrator:schema-builder` | Interactively design a note schema for a new work item type |\n\n**Hooks** — automatic, no invocation needed:\n\n- **Session start** — loads current work context at the beginning of each Claude Code session\n- **Plan mode** — after plan approval, prompts Claude to create MCP items so persistent tracking stays in sync\n- **Subagent start** — injects task context into spawned subagents so they start with full awareness\n\n**Output style** — The plugin includes a **Workflow Analyst** output style that turns Claude Code into a project management orchestrator: it plans, delegates to subagents, and tracks progress without writing code directly. Select it from the output style menu (`/output-style`) or enable it in your Claude Code settings.\n\n> **Contributing?** See [Contributing Guidelines](CONTRIBUTING.md) for developer setup.\n\n---\n\n## How It Works\n\n### 1. Unified WorkItem Graph\n\nEverything is a **WorkItem** — there are no separate \"Project\", \"Feature\", or \"Task\" types. Items nest by `parentId` up to 4 levels deep. The hierarchy is whatever your workflow needs:\n\n```\nWorkItem (depth 0): \"E-Commerce Platform\"\n  └── WorkItem (depth 1): \"User Authentication\"\n      ├── WorkItem (depth 2): \"Database schema\" [terminal]\n      ├── WorkItem (depth 2): \"Login API\" [work]\n      └── WorkItem (depth 2): \"Integration tests\" [blocked by: Login API]\n```\n\nCreate an entire subtree atomically with `create_work_tree`:\n\n```\ncreate_work_tree(\n  root={ \"title\": \"User Authentication\", \"priority\": \"high\" },\n  children=[\n    { \"ref\": \"schema\", \"title\": \"Database schema\" },\n    { \"ref\": \"api\",    \"title\": \"Login API\" },\n    { \"ref\": \"tests\",  \"title\": \"Integration tests\" }\n  ],\n  deps=[\n    { \"from\": \"schema\", \"to\": \"api\" },\n    { \"from\": \"api\",    \"to\": \"tests\" }\n  ]\n)\n```\n\n### 2. Notes as Persistent Documentation\n\nNotes are keyed text documents attached to WorkItems. They serve as the persistent memory layer — capturing requirements, decisions, test results, and handoff context that survives session restarts.\n\nInstead of re-reading conversation history, each item carries structured phase-specific notes:\n\n```\nmanage_notes(operation=\"upsert\", notes=[{\n  \"itemId\": \"<uuid>\",\n  \"key\": \"done-criteria\",\n  \"role\": \"work\",\n  \"body\": \"All 42 tests passing. Schema migration verified on staging. No regressions.\"\n}])\n```\n\nReading a 200-token note instead of 5k+ tokens of conversation history implements Anthropic's \"compaction\" pattern — preserving critical information while discarding redundant details.\n\n### 3. Role-Based Workflow\n\nEvery WorkItem moves through lifecycle phases called **roles**:\n\n```\nqueue  →  work  →  review  →  terminal\n              ↘                    ↗\n               ← skip review if no review-phase notes defined ←\n\nAny non-terminal role can transition to:\n  blocked  (hold/block trigger)  →  resume  →  previous role\n```\n\nTransitions use named triggers — no raw status assignments:\n\n| Trigger   | Effect |\n|-----------|--------|\n| `start`   | queue→work, work→review (or terminal if no review notes), review→terminal |\n| `complete`| Force-close to terminal, bypassing phase gates |\n| `block`   | Pause to blocked, saving previous role for resume |\n| `resume`  | Restore blocked item to its previous role |\n| `cancel`  | Close to terminal with cancelled status label |\n\n**Dependency enforcement**: `advance_item(trigger=\"start\")` checks that all blocking items have reached their `unblockAt` threshold before allowing a transition. Blocked items appear in `get_blocked_items()` and `get_context()`.\n\n---\n\n## Note Schemas\n\nNote schemas are the key feature that makes phase transitions meaningful. When an item's `tags` match a configured schema, required notes must be filled before `advance_item` allows progression to the next phase.\n\nDefine schemas in `.taskorchestrator/config.yaml` in your project root:\n\n```yaml\nnote_schemas:\n  task-implementation:\n    - key: requirements\n      role: queue\n      required: true\n      description: \"Testable acceptance criteria before starting\"\n    - key: done-criteria\n      role: work\n      required: true\n      description: \"What does done look like? How was it verified?\"\n```\n\nItems tagged `task-implementation` are now gated:\n\n- `advance_item(trigger=\"start\")` from **queue** requires `requirements` to be filled\n- `advance_item(trigger=\"start\")` from **work** requires `done-criteria` to be filled\n\nUse `get_context(itemId=...)` to inspect gate status before attempting a transition — it returns `canAdvance`, `missing`, and `guidancePointer` for the first unfilled required note.\n\nAfter adding or editing `config.yaml`, reconnect the MCP server:\n\n```\n/mcp  (disconnect and reconnect mcp-task-orchestrator)\n```\n\n> **Full schema reference**: [Workflow Guide](current/docs/workflow-guide.md)\n\n---\n\n## MCP Tools\n\nv3 exposes **13 tools** organized around the WorkItem graph:\n\n### Hierarchy & CRUD\n\n| Tool | Description |\n|------|-------------|\n| `manage_items` | Create, update, or delete WorkItems (batch operations) |\n| `query_items` | Get by ID, search with filters and pagination, or hierarchical overview |\n| `create_work_tree` | Atomically create root + children + dependency edges + notes in one call |\n| `complete_tree` | Batch-complete all descendants in topological order with gate checking |\n\n### Notes\n\n| Tool | Description |\n|------|-------------|\n| `manage_notes` | Upsert or delete notes on WorkItems |\n| `query_notes` | Get a single note or list notes for an item; use `includeBody=false` for token-efficient metadata checks |\n\n### Dependencies\n\n| Tool | Description |\n|------|-------------|\n| `manage_dependencies` | Create or delete edges; supports `linear`, `fan-out`, `fan-in` pattern shortcuts |\n| `query_dependencies` | Query edges with direction filtering; `neighborsOnly=false` for full BFS graph traversal |\n\n### Workflow\n\n| Tool | Description |\n|------|-------------|\n| `advance_item` | Trigger-based role transitions with gate enforcement, dependency checking, and unblock reporting |\n| `get_next_status` | Read-only progression recommendation before transitioning |\n| `get_context` | Context snapshot: item gate check, session resume, or health check |\n| `get_next_item` | Priority-ranked recommendation of next actionable, unblocked item |\n| `get_blocked_items` | All items blocked by unsatisfied dependencies or explicit block trigger |\n\n> **Full reference**: [API Reference](current/docs/api-reference.md)\n\n### Token-Efficient Query Patterns\n\n`get_context(includeAncestors=true)` + `query_items(operation=\"overview\")` gives a complete work-summary dashboard in **2 calls** — active items with full ancestor chains, blocked items, and container-level counts. No sequential parent-walk needed.\n\n---\n\n## Documentation\n\n- **[Wiki](https://github.com/jpicklyk/task-orchestrator/wiki)** — Full documentation hub\n- **[Quick Start Guide](current/docs/quick-start.md)** — Setup walkthrough and first work item\n- **[API Reference](current/docs/api-reference.md)** — All 13 MCP tools, parameters, and response shapes\n- **[Workflow Guide](current/docs/workflow-guide.md)** — Note schemas, phase gates, dependency patterns, and lifecycle examples\n- **[Changelog](CHANGELOG.md)** — Release history\n- **[Contributing Guidelines](CONTRIBUTING.md)** — Development setup and contribution process\n\n---\n\n## Example: From Session Start to Feature Complete\n\n```\nYou: \"I want to build user authentication\"\nAI: → create_work_tree(\"User Auth\", children=[schema, login-api, tests], deps=[schema→api→tests])\n   → 3 WorkItems created with linear dependency chain\n   → Note schema gates applied to items tagged task-implementation\n\nYou: \"What's next?\"\nAI: → get_next_item() → \"Database schema\" [queue, no blockers, high priority]\n   → advance_item(trigger=\"start\") → schema moves to work\n   → [implements schema]\n   → manage_notes(key=\"done-criteria\"): \"Migration V5 applied. Users table with email index.\"\n   → advance_item(trigger=\"start\") → schema moves to terminal\n   → Response: unblockedItems = [\"Login API\"] ← dependency satisfied\n\nYou: \"What's next?\"\nAI: → get_next_item() → \"Login API\" [queue, schema is terminal]\n   → Reads 200-token done-criteria note (not 5k conversation history)\n   → Implements API, fills notes, advances to terminal\n\n[Next morning - new session]\nYou: \"What's next?\"\nAI: → get_context(includeAncestors=true) → sees active/blocked items with full context instantly\n   → \"Integration tests\" was blocked; Login API is now terminal → tests unblocked\n   → advance_item(trigger=\"start\") → tests move to work\n```\n\n**No context rebuilding.** Persistent WorkItem graph + notes = instant session resume with full state.\n\n---\n\n## Troubleshooting\n\n**Quick Fixes**:\n- **AI can't find tools**: Restart your AI client or run `/mcp reconnect mcp-task-orchestrator`\n- **Docker not running**: Start Docker Desktop, verify with `docker version`\n- **Server shows failed**: Enable `LOG_LEVEL=DEBUG` in your Docker config to inspect startup logs\n- **Note gates blocking unexpectedly**: Run `get_context(itemId=...)` to see exactly which notes are missing\n- **Skills not available**: Install via plugin marketplace (requires Claude Code)\n\n**Get Help**:\n- [Discussions](../../discussions) — Ask questions and share ideas\n- [Issues](../../issues) — Bug reports and feature requests\n\n---\n\n## Technical Stack\n\n- **Kotlin 2.2.0** with Coroutines for concurrent operations\n- **SQLite + Exposed ORM** for fast, zero-config database (persistent memory system)\n- **Flyway Migrations** for versioned schema management\n- **MCP SDK 0.8.4** for standards-compliant protocol (STDIO and HTTP transport)\n- **Docker** for one-command deployment\n\nClean Architecture (Domain → Application → Infrastructure → Interface) with 1,600+ tests.\n\n---\n\n## License\n\n[MIT License](LICENSE) — Free for personal and commercial use\n\n"
      },
      "plugins": [
        {
          "name": "task-orchestrator",
          "version": "1.1.1",
          "description": "Skills, hooks, and workflows for MCP Task Orchestrator (v3). Schema-aware context, note-driven workflow, and thin session hooks.",
          "author": {
            "name": "Jeff Picklyk",
            "url": "https://github.com/jpicklyk"
          },
          "homepage": "https://github.com/jpicklyk/task-orchestrator",
          "repository": "https://github.com/jpicklyk/task-orchestrator",
          "license": "MIT",
          "keywords": [
            "task-management",
            "project-management",
            "workflow",
            "mcp",
            "ai-orchestration"
          ],
          "category": "productivity",
          "tags": [
            "tasks",
            "features",
            "projects",
            "dependencies",
            "workflows",
            "v3"
          ],
          "source": "./claude-plugins/task-orchestrator",
          "strict": true,
          "categories": [
            "ai-orchestration",
            "dependencies",
            "features",
            "mcp",
            "productivity",
            "project-management",
            "projects",
            "task-management",
            "tasks",
            "v3",
            "workflow",
            "workflows"
          ],
          "install_commands": [
            "/plugin marketplace add jpicklyk/task-orchestrator",
            "/plugin install task-orchestrator@task-orchestrator-marketplace"
          ]
        }
      ]
    }
  ]
}