{
  "author": {
    "id": "Nothflare",
    "display_name": "Nothflare",
    "avatar_url": "https://avatars.githubusercontent.com/u/61462477?u=d035214972c87c612d9b2b46d299c6acea1299c5&v=4"
  },
  "marketplaces": [
    {
      "name": "feature-tree",
      "version": null,
      "description": "Feature Tree and companion plugins for Claude Code",
      "repo_full_name": "Nothflare/feature-tree",
      "repo_url": "https://github.com/Nothflare/feature-tree",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-09T15:20:42Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"feature-tree\",\n  \"description\": \"Feature Tree and companion plugins for Claude Code\",\n  \"owner\": {\n    \"name\": \"Feature Tree Contributors\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"feature-tree\",\n      \"description\": \"AI-driven feature management. Track features, link to code symbols and commits.\",\n      \"version\": \"3.1.0\",\n      \"source\": \"./feature-tree\",\n      \"author\": {\n        \"name\": \"Feature Tree Contributors\"\n      }\n    },\n    {\n      \"name\": \"ft-mem\",\n      \"description\": \"Session continuity. Handoff context between sessions, persist project knowledge.\",\n      \"version\": \"3.0.0\",\n      \"source\": \"./ft-mem\",\n      \"author\": {\n        \"name\": \"Feature Tree Contributors\"\n      }\n    }\n  ]\n}\n",
        "README.md": "# Feature Tree\n\nThe interface between human intent, AI agent, and code.\n\n## Philosophy\n\n### The Problem\n\nAI agents are high-variance systems. They can reason, explore, and make decisions. But without context, they:\n- Guess instead of knowing\n- Duplicate instead of reusing\n- Break things they didn't know existed\n- Lose everything when sessions restart\n- Degrade as context window fills up\n\nTraditional solutions try to control agents with rigid rules. This doesn't work — you can't control a complex system with a simple one.\n\n### The Solution\n\nFeature Tree is a **semantic layer** that grows with your project. Not rules that constrain, but context that enables.\n\n**Workflows** capture human intent — user journeys explained like you'd explain to a YC partner.\n\n**Features** capture code reality — atomic units with technical notes for implementation.\n\n**Semantic search** connects them — \"auth\" finds login, signin, credentials. Jump straight to context without guessing.\n\nThe agent starts at the right zoom level, with the right context in hand.\n\n## How It Works\n\n### Workflow-First Approach\n\n```\nTask arrives\n    ↓\nsearch_workflows(\"what user wants\")  ← Start here (broad context)\n    ↓\nget_workflow(id) → steps, dependencies, purpose\n    ↓\nget_feature(id) → files, symbols, technical notes (focused context)\n    ↓\nRead actual code (only when needed)\n```\n\nOne workflow often contains all context needed for a task. No need to grep the entire codebase.\n\n### Two Trees, Connected\n\n| Tree | What It Captures | Audience |\n|------|------------------|----------|\n| **Workflows** | User journeys, steps, why it exists | Human (YC partner level) |\n| **Features** | Atomic code units, how it works | Developer (implementation level) |\n\nThe link is the power:\n- `get_feature(\"AUTH.login\")` → shows which workflows use it\n- `get_workflow(\"USER.login_flow\")` → shows which features are done vs planned\n\n### Field Definitions\n\n**Workflows:**\n- `description` — Explain to a YC partner (what the journey IS)\n- `purpose` — Technical goal (why it exists in the system)\n- `steps` — Actual flow in plain language\n\n**Features:**\n- `description` — Explain to a YC partner (what it does, user-facing)\n- `technical_notes` — Explain to a developer (how it works, gotchas)\n\nBoth self-contained. Enough detail that Claude can understand without asking questions.\n\n### Semantic Search\n\nSearch finds related concepts, not just keywords.\n\n```\nsearch_features(\"auth\")     → finds: login, signin, credentials, session\nsearch_workflows(\"payment\") → finds: checkout, subscription, refund\n```\n\nJump straight to the right context. Prevents duplicates, prevents hallucination, prevents blind spots.\n\n## Installation\n\n```bash\n/plugin marketplace add github:Nothflare/feature-tree\n/plugin install feature-tree@feature-tree\n/plugin install ft-mem@feature-tree\n# Restart Claude Code\n```\n\n### Semantic Search Setup (Optional)\n\nWithout API key, falls back to keyword search. Still works, just less semantic.\n\n```json\n// ~/.claude/settings.json\n{\n  \"env\": {\n    \"FT_EMBEDDING_API_KEY\": \"sk-or-...\"\n  }\n}\n```\n\n| Env Variable | Default | Description |\n|--------------|---------|-------------|\n| `FT_EMBEDDING_API_KEY` | (none) | OpenRouter API key |\n| `FT_EMBEDDING_MODEL` | `openai/text-embedding-3-small` | Model |\n| `FT_EMBEDDING_ENDPOINT` | `https://openrouter.ai/api/v1/embeddings` | Endpoint |\n\n## MCP Tools\n\n### Search (use BEFORE implementing)\n\n| Tool | Purpose |\n|------|---------|\n| `search_features(query)` | Find existing features, prevent duplicates |\n| `search_workflows(query)` | Find user journeys, understand broad context |\n\n### Get (use AFTER search for full context)\n\n| Tool | Purpose |\n|------|---------|\n| `get_feature(id)` | Files, symbols, dependencies, what depends on this |\n| `get_workflow(id)` | Steps, purpose, which features are ready vs blocked |\n\n### Create/Update (use AFTER implementing)\n\n| Tool | Purpose |\n|------|---------|\n| `add_feature(...)` | Create new feature |\n| `update_feature(...)` | Update files, symbols, notes after implementing |\n| `add_workflow(...)` | Create new workflow |\n| `update_workflow(...)` | Update steps, dependencies |\n| `delete_feature(id)` | Archive (active) or delete (planned) |\n| `delete_workflow(id)` | Archive (active) or delete (planned) |\n\n**Note:** Updates OVERRIDE, not append. To add a file, get current list first, then update with full list.\n\n## Usage\n\n### Simple Rule\n\n- **Search BEFORE implementing** (always)\n- **Create/update AFTER implementing** (when you know actual files, symbols)\n\n### Status\n\nStatus tells you what you CAN DO with something:\n\n| Status | Meaning | Action |\n|--------|---------|--------|\n| `planned` | Designed, not in code | Don't depend on it yet |\n| `active` | Implemented, working | Safe to use |\n| `archived` | Deprecated/removed | Update things depending on it |\n\n### being_modified (for handoff only)\n\nOnly set when handing off mid-task:\n\n| Value | When |\n|-------|------|\n| `building` | First-time implementation, incomplete |\n| `refactoring` | Changing approach, incomplete |\n| `fixing` | Bug fix, incomplete |\n| `extending` | Adding features, incomplete |\n\n## Skills\n\n| Skill | Purpose |\n|-------|---------|\n| `/feature-tree:brainstorm` | Design through Discovery → Product → Design → Specification |\n| `/feature-tree:ralph-execute` | Autonomous overnight execution with subagents |\n| `/feature-tree:executing-plans` | Execute plans with commits between tasks |\n| `/feature-tree:commit` | Commit with feature tree update |\n| `/feature-tree:bootstrap` | Discover features from existing codebase |\n| `/ft-mem:handoff` | Save context before /clear |\n| `/ft-mem:brainstorm-sync` | Sync brainstorm discoveries to memory |\n\n## Autonomous Execution (Ralph)\n\nSleep while your app gets built.\n\n### The Architecture\n\nBased on the Viable System Model:\n\n```\nSystem 5 (Policy)       = Design files — what to build\nSystem 4 (Intelligence) = Human — strategic decisions\nSystem 3 (Management)   = Main agent — orchestrates everything\nSystem 1 (Operations)   = Subagents — fresh context workers\n```\n\n**Key insight:** Main agent stays alive, subagents get fresh context each time. No context degradation.\n\n### The Loop\n\n```\n/ralph-execute\n    ↓\nPre-flight check (verify ALL deps before human leaves)\n    ↓\nFor each planned feature:\n    Implementer (opus) → builds, writes test spec\n    Tester (sonnet) → runs REAL tests\n    Reviewer (opus) → quality/security/design gate\n    ↓\n    Pass → feature active, next\n    Fail → retry (max 3), then log blocker\n    ↓\nTest workflows end-to-end\n    ↓\nHuman wakes up to working app or clear blockers\n```\n\n### Subagents\n\n| Agent | Model | Purpose |\n|-------|-------|---------|\n| `implementer` | opus | Implement features, update Feature Tree, write test specs |\n| `tester` | sonnet | Run REAL tests, report pass/fail (cheaper) |\n| `reviewer` | opus | Quality, security, design review |\n\nFeature Tree is the shared memory between agents. No custom state management needed.\n\n## Storage\n\n```\n.feat-tree/\n├── features.db      # SQLite + FTS5\n├── chroma/          # Vector store (semantic search)\n├── FEATURES.md      # Auto-generated\n├── WORKFLOWS.md     # Auto-generated\n├── CONTEXT.md       # Product context\n├── memories/        # Cross-session context\n│   ├── handoff.md\n│   ├── user.md\n│   ├── scope.md\n│   └── decisions.md\n└── ralph/           # Autonomous execution artifacts\n    ├── handoff/     # Implementer → Implementer continuation\n    ├── test-spec/   # What to test\n    ├── test-results/# Raw test output\n    ├── review/      # Review findings\n    └── blockers/    # Stuck after retries\n```\n\n## Requirements\n\n- Python 3.11+\n- uv\n\n## License\n\nMIT\n",
        "ft-mem/README.md": "# ft-mem\n\nSession continuity for Claude Code. Companion plugin to feature-tree.\n\n## Why Use ft-mem?\n\n### The Problem\n\nWithout session memory:\n- Every `/clear` loses all context\n- Next Claude re-asks the same questions\n- Debugging progress lost\n- Design decisions forgotten\n\n### What ft-mem Gives You\n\n| Before | After |\n|--------|-------|\n| \"What were we working on?\" → no idea | Next session reads handoff.md automatically |\n| \"Why did we choose X?\" → lost forever | Decision recorded in memories/architecture.md |\n| \"What files are involved?\" → grep again | Handoff lists files, features, and state |\n\n## Installation\n\n```bash\n/plugin marketplace add github:Nothflare/feature-tree\n/plugin install ft-mem@feature-tree\n# Restart Claude Code\n```\n\nUsually installed alongside feature-tree.\n\n## Skills\n\n### /ft-mem:handoff\n\n**Use before `/clear`** to save session context.\n\n```\nHuman: /ft-mem:handoff\n\nClaude: [Creates handoff.md with current state]\n        - What we were working on\n        - Features created/modified\n        - Key decisions and why\n        - What to do next\n\n        Safe to /clear.\n```\n\nNext session automatically reads handoff.md and continues seamlessly.\n\n### /ft-mem:onboarding\n\n**First-time project setup.** Creates:\n- `.feat-tree/CONTEXT.md` - Product overview, constraints, assumptions\n- `.feat-tree/memories/` - Directory for persistent knowledge\n\n### /ft-mem:brainstorm-sync\n\n**After brainstorming sessions.** Syncs discoveries to project memory:\n- Updates CONTEXT.md with new insights\n- Creates relevant memory files\n\n## How It Works\n\n### Session Start\n\nHook reads and injects into context:\n1. `FT_SESSION=N` (session ID for multi-project safety)\n2. `.feat-tree/CONTEXT.md` (product context)\n3. `.feat-tree/memories/handoff.md` if exists\n\n### Before /clear\n\nRun `/ft-mem:handoff`. It:\n1. Records features you created/modified\n2. Captures current state (DONE, IN-PROGRESS, DEBUGGING, BLOCKED)\n3. Saves key decisions with rationale\n4. Lists files to read next session\n\n### Next Session\n\nClaude automatically:\n1. Reads handoff context\n2. Queries Feature Tree for mentioned features\n3. Continues where you left off\n\n## Handoff Templates\n\nThe handoff skill uses status-appropriate templates:\n\n| Status | Captured |\n|--------|----------|\n| **DONE** | What was completed, notes for future |\n| **IN-PROGRESS** | Current approach, progress, next steps |\n| **DEBUGGING** | Bug description, what was tried, hypotheses |\n| **BLOCKED** | Blocker, options, needs |\n\n## Storage\n\n```\n.feat-tree/\n├── CONTEXT.md              # Product context (injected at session start)\n└── memories/\n    ├── handoff.md          # Session handoff (auto-read on startup)\n    ├── codebase_structure.md\n    ├── code_style.md\n    ├── debugging_*.md\n    └── [anything].md       # You can create any memory files\n```\n\n## Memory Files\n\nCreate any `.md` file in `memories/` for persistent knowledge:\n\n| File | Purpose |\n|------|---------|\n| `code_style.md` | Project conventions |\n| `codebase_structure.md` | Key directories and patterns |\n| `api_patterns.md` | API conventions |\n| `debugging_auth.md` | Solved auth issues |\n\nThese survive `/clear` and provide context to future sessions.\n\n## Benefits\n\n1. **No re-explaining**: Context persists across sessions\n2. **No repeated mistakes**: Debugging notes prevent re-trying failed approaches\n3. **Seamless handoff**: Start where you left off\n4. **Team knowledge**: Memory files work for any Claude session on the project\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "feature-tree",
          "description": "AI-driven feature management. Track features, link to code symbols and commits.",
          "version": "3.1.0",
          "source": "./feature-tree",
          "author": {
            "name": "Feature Tree Contributors"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add Nothflare/feature-tree",
            "/plugin install feature-tree@feature-tree"
          ]
        },
        {
          "name": "ft-mem",
          "description": "Session continuity. Handoff context between sessions, persist project knowledge.",
          "version": "3.0.0",
          "source": "./ft-mem",
          "author": {
            "name": "Feature Tree Contributors"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add Nothflare/feature-tree",
            "/plugin install ft-mem@feature-tree"
          ]
        }
      ]
    }
  ]
}