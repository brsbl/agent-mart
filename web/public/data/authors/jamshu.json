{
  "author": {
    "id": "jamshu",
    "display_name": "Jamshid K",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/4831804?u=a0791f834437ef3799261358caa1a81558afa63d&v=4",
    "url": "https://github.com/jamshu",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 21,
      "total_skills": 9,
      "total_stars": 2,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "jamshi-marketplace",
      "version": null,
      "description": "Generate offline-first Progressive Web Apps with Odoo Studio backend integration. Supports SvelteKit, React, and Vue with smart caching, IndexedDB storage, and automatic sync",
      "owner_info": {
        "name": "Jamshid"
      },
      "keywords": [],
      "repo_full_name": "jamshu/jamshi-marketplace",
      "repo_url": "https://github.com/jamshu/jamshi-marketplace",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2025-11-02T14:27:44Z",
        "created_at": "2025-11-02T14:26:58Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 869
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 285
        },
        {
          "path": "plugins/odoo-dev/README.md",
          "type": "blob",
          "size": 11673
        },
        {
          "path": "plugins/odoo-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/agents/code-architect.md",
          "type": "blob",
          "size": 2264
        },
        {
          "path": "plugins/odoo-dev/agents/code-explorer.md",
          "type": "blob",
          "size": 2120
        },
        {
          "path": "plugins/odoo-dev/agents/code-reviewer.md",
          "type": "blob",
          "size": 2999
        },
        {
          "path": "plugins/odoo-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/commands/odoo-dev.md",
          "type": "blob",
          "size": 5406
        },
        {
          "path": "plugins/odoo-dev/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-code-reviewer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-code-reviewer/SKILL.md",
          "type": "blob",
          "size": 8968
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-code-reviewer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-code-reviewer/references/oca_guidelines.md",
          "type": "blob",
          "size": 25
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-code-reviewer/references/performance_patterns.md",
          "type": "blob",
          "size": 21
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-code-reviewer/references/security_checklist.md",
          "type": "blob",
          "size": 19
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator/SKILL.md",
          "type": "blob",
          "size": 40336
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator/references/api_integration.md",
          "type": "blob",
          "size": 15690
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator/references/architecture.md",
          "type": "blob",
          "size": 13811
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator/references/authentication.md",
          "type": "blob",
          "size": 13677
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator/references/patterns.md",
          "type": "blob",
          "size": 16027
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-connector-module-creator/references/troubleshooting.md",
          "type": "blob",
          "size": 15095
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-debugger",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-debugger/SKILL.md",
          "type": "blob",
          "size": 9276
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-debugger/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-debugger/references/common_issues.md",
          "type": "blob",
          "size": 31
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-debugger/references/debugging_queries.md",
          "type": "blob",
          "size": 40
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-feature-enhancer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-feature-enhancer/SKILL.md",
          "type": "blob",
          "size": 15051
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-feature-enhancer/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-feature-enhancer/references/api_reference.md",
          "type": "blob",
          "size": 972
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-feature-enhancer/references/field_types.md",
          "type": "blob",
          "size": 1679
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-feature-enhancer/references/implementation_patterns.md",
          "type": "blob",
          "size": 1559
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-feature-enhancer/references/xpath_patterns.md",
          "type": "blob",
          "size": 1298
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-migration-assistant",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-migration-assistant/SKILL.md",
          "type": "blob",
          "size": 8662
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-migration-assistant/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-migration-assistant/references/api_changes.md",
          "type": "blob",
          "size": 22
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-migration-assistant/references/odoo16_changes.md",
          "type": "blob",
          "size": 26
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-module-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-module-creator/SKILL.md",
          "type": "blob",
          "size": 17681
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-test-creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-test-creator/SKILL.md",
          "type": "blob",
          "size": 13315
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-test-creator/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-dev/skills/odoo-test-creator/references/test_patterns.md",
          "type": "blob",
          "size": 8953
        },
        {
          "path": "plugins/odoo-pwa-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-pwa-generator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-pwa-generator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 500
        },
        {
          "path": "plugins/odoo-pwa-generator/README.md",
          "type": "blob",
          "size": 6493
        },
        {
          "path": "plugins/odoo-pwa-generator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/add-deployment.md",
          "type": "blob",
          "size": 10413
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/add-model.md",
          "type": "blob",
          "size": 1847
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/api-reference.md",
          "type": "blob",
          "size": 13666
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/architecture.md",
          "type": "blob",
          "size": 15004
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/clear-cache.md",
          "type": "blob",
          "size": 12217
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/create-cache-store.md",
          "type": "blob",
          "size": 3097
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/deploy-github.md",
          "type": "blob",
          "size": 5244
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/deploy-vercel.md",
          "type": "blob",
          "size": 3921
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/examples.md",
          "type": "blob",
          "size": 10879
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/fix-sync.md",
          "type": "blob",
          "size": 12942
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/help.md",
          "type": "blob",
          "size": 8641
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/init-project.md",
          "type": "blob",
          "size": 5257
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/new-react-pwa.md",
          "type": "blob",
          "size": 1576
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/new-svelte-pwa.md",
          "type": "blob",
          "size": 1602
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/new-vue-pwa.md",
          "type": "blob",
          "size": 1568
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/optimize.md",
          "type": "blob",
          "size": 12446
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/setup-env.md",
          "type": "blob",
          "size": 2976
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/test-connection.md",
          "type": "blob",
          "size": 5767
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/troubleshoot.md",
          "type": "blob",
          "size": 14021
        },
        {
          "path": "plugins/odoo-pwa-generator/commands/update-deps.md",
          "type": "blob",
          "size": 8187
        },
        {
          "path": "plugins/odoo-pwa-generator/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-pwa-generator/skills/add-odoo-model",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-pwa-generator/skills/add-odoo-model/SKILL.md",
          "type": "blob",
          "size": 5268
        },
        {
          "path": "plugins/odoo-pwa-generator/skills/create-odoo-pwa",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/odoo-pwa-generator/skills/create-odoo-pwa/SKILL.md",
          "type": "blob",
          "size": 11874
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n\"name\": \"jamshi-marketplace\",\n\"owner\": {\n\"name\": \"Jamshid\"\n},\n\"plugins\": [\n{\n  \"name\": \"odoo-pwa-generator\",\n  \"source\": \"./plugins/odoo-pwa-generator\",\n  \"description\": \"Generate offline-first Progressive Web Apps with Odoo Studio backend integration. Supports SvelteKit, React, and Vue with smart caching, IndexedDB storage, and automatic sync\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Jamshid K\",\n    \"email\": \"jamshu.mkd@gmail.com\"\n},\n  \"category\": \"development\" \n},\n{\n      \"name\": \"odoo-dev\",\n      \"description\": \"Comprehensive feature development workflow with specialized agents for codebase exploration, architecture design, and quality review\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Jamshid K\",\n        \"email\": \"jamshu.mkd@gmail.com\"\n      },\n      \"source\": \"./plugins/odoo-dev\",\n      \"category\": \"development\"\n    }\n]\n}\n",
        "plugins/odoo-dev/.claude-plugin/plugin.json": "{\n  \"name\": \"odoo-dev\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Comprehensive feature Odoo development workflow with specialized agents for codebase exploration, architecture design, and quality review\",\n  \"author\": {\n    \"name\": \"Jamshid K\",\n    \"email\": \"jamshu.mkd@gmail.com\"\n  }\n}\n",
        "plugins/odoo-dev/README.md": "# Feature Development Plugin\n\nA comprehensive, structured workflow for feature development with specialized agents for codebase exploration, architecture design, and quality review.\n\n## Overview\n\nThe Feature Development Plugin provides a systematic 7-phase approach to building new features. Instead of jumping straight into code, it guides you through understanding the codebase, asking clarifying questions, designing architecture, and ensuring quality—resulting in better-designed features that integrate seamlessly with your existing code.\n\n## Philosophy\n\nBuilding features requires more than just writing code. You need to:\n- **Understand the codebase** before making changes\n- **Ask questions** to clarify ambiguous requirements\n- **Design thoughtfully** before implementing\n- **Review for quality** after building\n\nThis plugin embeds these practices into a structured workflow that runs automatically when you use the `/odoo-dev` command.\n\n## Command: `/odoo-dev`\n\nLaunches a guided feature development workflow with 7 distinct phases.\n\n**Usage:**\n```bash\n/odoo-dev Add user authentication with OAuth\n```\n\nOr simply:\n```bash\n/odoo-dev\n```\n\nThe command will guide you through the entire process interactively.\n\n## The 7-Phase Workflow\n\n### Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\n**What happens:**\n- Clarifies the feature request if it's unclear\n- Asks what problem you're solving\n- Identifies constraints and requirements\n- Summarizes understanding and confirms with you\n\n**Example:**\n```\nYou: /odoo-dev Add caching\nClaude: Let me understand what you need...\n        - What should be cached? (API responses, computed values, etc.)\n        - What are your performance requirements?\n        - Do you have a preferred caching solution?\n```\n\n### Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns\n\n**What happens:**\n- Launches 2-3 `code-explorer` agents in parallel\n- Each agent explores different aspects (similar features, architecture, UI patterns)\n- Agents return comprehensive analyses with key files to read\n- Claude reads all identified files to build deep understanding\n- Presents comprehensive summary of findings\n\n**Agents launched:**\n- \"Find features similar to [feature] and trace implementation\"\n- \"Map the architecture and abstractions for [area]\"\n- \"Analyze current implementation of [related feature]\"\n\n**Example output:**\n```\nFound similar features:\n- User authentication (src/auth/): Uses JWT tokens, middleware pattern\n- Session management (src/session/): Redis-backed, 24hr expiry\n- API security (src/api/middleware/): Rate limiting, CORS\n\nKey files to understand:\n- src/auth/AuthService.ts:45 - Core authentication logic\n- src/middleware/authMiddleware.ts:12 - Request authentication\n- src/config/security.ts:8 - Security configuration\n```\n\n### Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities\n\n**What happens:**\n- Reviews codebase findings and feature request\n- Identifies underspecified aspects:\n  - Edge cases\n  - Error handling\n  - Integration points\n  - Backward compatibility\n  - Performance needs\n- Presents all questions in an organized list\n- **Waits for your answers before proceeding**\n\n**Example:**\n```\nBefore designing the architecture, I need to clarify:\n\n1. OAuth provider: Which OAuth providers? (Google, GitHub, custom?)\n2. User data: Store OAuth tokens or just user profile?\n3. Existing auth: Replace current auth or add alongside?\n4. Sessions: Integrate with existing session management?\n5. Error handling: How to handle OAuth failures?\n```\n\n**Critical**: This phase ensures nothing is ambiguous before design begins.\n\n### Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches\n\n**What happens:**\n- Launches 2-3 `code-architect` agents with different focuses:\n  - **Minimal changes**: Smallest change, maximum reuse\n  - **Clean architecture**: Maintainability, elegant abstractions\n  - **Pragmatic balance**: Speed + quality\n- Reviews all approaches\n- Forms opinion on which fits best for this task\n- Presents comparison with trade-offs and recommendation\n- **Asks which approach you prefer**\n\n**Example output:**\n```\nI've designed 3 approaches:\n\nApproach 1: Minimal Changes\n- Extend existing AuthService with OAuth methods\n- Add new OAuth routes to existing auth router\n- Minimal refactoring required\nPros: Fast, low risk\nCons: Couples OAuth to existing auth, harder to test\n\nApproach 2: Clean Architecture\n- New OAuthService with dedicated interface\n- Separate OAuth router and middleware\n- Refactor AuthService to use common interface\nPros: Clean separation, testable, maintainable\nCons: More files, more refactoring\n\nApproach 3: Pragmatic Balance\n- New OAuthProvider abstraction\n- Integrate into existing AuthService\n- Minimal refactoring, good boundaries\nPros: Balanced complexity and cleanliness\nCons: Some coupling remains\n\nRecommendation: Approach 3 - gives you clean boundaries without\nexcessive refactoring, and fits your existing architecture well.\n\nWhich approach would you like to use?\n```\n\n### Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**What happens:**\n- **Waits for explicit approval** before starting\n- Reads all relevant files identified in previous phases\n- Implements following chosen architecture\n- Follows codebase conventions strictly\n- Writes clean, well-documented code\n- Updates todos as progress is made\n\n**Notes:**\n- Implementation only starts after you approve\n- Follows patterns discovered in Phase 2\n- Uses architecture designed in Phase 4\n- Continuously tracks progress\n\n### Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, and functionally correct\n\n**What happens:**\n- Launches 3 `code-reviewer` agents in parallel with different focuses:\n  - **Simplicity/DRY/Elegance**: Code quality and maintainability\n  - **Bugs/Correctness**: Functional correctness and logic errors\n  - **Conventions/Abstractions**: Project standards and patterns\n- Consolidates findings\n- Identifies highest severity issues\n- **Presents findings and asks what you want to do**:\n  - Fix now\n  - Fix later\n  - Proceed as-is\n- Addresses issues based on your decision\n\n**Example output:**\n```\nCode Review Results:\n\nHigh Priority Issues:\n1. Missing error handling in OAuth callback (src/auth/oauth.ts:67)\n2. Memory leak: OAuth state not cleaned up (src/auth/oauth.ts:89)\n\nMedium Priority:\n1. Could simplify token refresh logic (src/auth/oauth.ts:120)\n2. Consider extracting OAuth config validation\n\nAll tests pass. Code follows project conventions.\n\nWhat would you like to do?\n```\n\n### Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**What happens:**\n- Marks all todos complete\n- Summarizes:\n  - What was built\n  - Key decisions made\n  - Files modified\n  - Suggested next steps\n\n**Example:**\n```\nFeature Complete: OAuth Authentication\n\nWhat was built:\n- OAuth provider abstraction supporting Google and GitHub\n- OAuth routes and middleware integrated with existing auth\n- Token refresh and session integration\n- Error handling for all OAuth flows\n\nKey decisions:\n- Used pragmatic approach with OAuthProvider abstraction\n- Integrated with existing session management\n- Added OAuth state to prevent CSRF\n\nFiles modified:\n- src/auth/OAuthProvider.ts (new)\n- src/auth/AuthService.ts\n- src/routes/auth.ts\n- src/middleware/authMiddleware.ts\n\nSuggested next steps:\n- Add tests for OAuth flows\n- Add more OAuth providers (Microsoft, Apple)\n- Update documentation\n```\n\n## Agents\n\n### `code-explorer`\n\n**Purpose**: Deeply analyzes existing codebase features by tracing execution paths\n\n**Focus areas:**\n- Entry points and call chains\n- Data flow and transformations\n- Architecture layers and patterns\n- Dependencies and integrations\n- Implementation details\n\n**When triggered:**\n- Automatically in Phase 2\n- Can be invoked manually when exploring code\n\n**Output:**\n- Entry points with file:line references\n- Step-by-step execution flow\n- Key components and responsibilities\n- Architecture insights\n- List of essential files to read\n\n### `code-architect`\n\n**Purpose**: Designs feature architectures and implementation blueprints\n\n**Focus areas:**\n- Codebase pattern analysis\n- Architecture decisions\n- Component design\n- Implementation roadmap\n- Data flow and build sequence\n\n**When triggered:**\n- Automatically in Phase 4\n- Can be invoked manually for architecture design\n\n**Output:**\n- Patterns and conventions found\n- Architecture decision with rationale\n- Complete component design\n- Implementation map with specific files\n- Build sequence with phases\n\n### `code-reviewer`\n\n**Purpose**: Reviews code for bugs, quality issues, and project conventions\n\n**Focus areas:**\n- Project guideline compliance (CLAUDE.md)\n- Bug detection\n- Code quality issues\n- Confidence-based filtering (only reports high-confidence issues ≥80)\n\n**When triggered:**\n- Automatically in Phase 6\n- Can be invoked manually after writing code\n\n**Output:**\n- Critical issues (confidence 75-100)\n- Important issues (confidence 50-74)\n- Specific fixes with file:line references\n- Project guideline references\n\n## Usage Patterns\n\n### Full workflow (recommended for new features):\n```bash\n/feature-dev Add rate limiting to API endpoints\n```\n\nLet the workflow guide you through all 7 phases.\n\n### Manual agent invocation:\n\n**Explore a feature:**\n```\n\"Launch code-explorer to trace how authentication works\"\n```\n\n**Design architecture:**\n```\n\"Launch code-architect to design the caching layer\"\n```\n\n**Review code:**\n```\n\"Launch code-reviewer to check my recent changes\"\n```\n\n## Best Practices\n\n1. **Use the full workflow for complex features**: The 7 phases ensure thorough planning\n2. **Answer clarifying questions thoughtfully**: Phase 3 prevents future confusion\n3. **Choose architecture deliberately**: Phase 4 gives you options for a reason\n4. **Don't skip code review**: Phase 6 catches issues before they reach production\n5. **Read the suggested files**: Phase 2 identifies key files—read them to understand context\n\n## When to Use This Plugin\n\n**Use for:**\n- New features that touch multiple files\n- Features requiring architectural decisions\n- Complex integrations with existing code\n- Features where requirements are somewhat unclear\n\n**Don't use for:**\n- Single-line bug fixes\n- Trivial changes\n- Well-defined, simple tasks\n- Urgent hotfixes\n\n## Requirements\n\n- Claude Code installed\n- Git repository (for code review)\n- Project with existing codebase (workflow assumes existing code to learn from)\n\n## Troubleshooting\n\n### Agents take too long\n\n**Issue**: Code exploration or architecture agents are slow\n\n**Solution**:\n- This is normal for large codebases\n- Agents run in parallel when possible\n- The thoroughness pays off in better understanding\n\n### Too many clarifying questions\n\n**Issue**: Phase 3 asks too many questions\n\n**Solution**:\n- Be more specific in your initial feature request\n- Provide context about constraints upfront\n- Say \"whatever you think is best\" if truly no preference\n\n### Architecture options overwhelming\n\n**Issue**: Too many architecture options in Phase 4\n\n**Solution**:\n- Trust the recommendation—it's based on codebase analysis\n- If still unsure, ask for more explanation\n- Pick the pragmatic option when in doubt\n\n## Tips\n\n- **Be specific in your feature request**: More detail = fewer clarifying questions\n- **Trust the process**: Each phase builds on the previous one\n- **Review agent outputs**: Agents provide valuable insights about your codebase\n- **Don't skip phases**: Each phase serves a purpose\n- **Use for learning**: The exploration phase teaches you about your own codebase\n\n## Author\n\nJamahid K(jamshu.mkd@gmail.com)\n\n## Version\n\n1.0.0\n",
        "plugins/odoo-dev/agents/code-architect.md": "---\nname: code-architect\ndescription: Designs feature architectures by analyzing existing codebase patterns and conventions, then providing comprehensive implementation blueprints with specific files to create/modify, component designs, data flows, and build sequences\ntools: Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, KillShell, BashOutput\nmodel: sonnet\ncolor: green\n---\n\nYou are a senior Odoo software architect who delivers comprehensive, actionable architecture blueprints by deeply understanding codebases and making confident architectural decisions.\n\n## Core Process\n\n**1. Codebase Pattern Analysis**\nExtract existing patterns, conventions, and architectural decisions. Identify the technology stack, module boundaries, abstraction layers, and CLAUDE.md guidelines. Find similar features to understand established approaches.\n\n**2. Architecture Design**\nBased on patterns found, design the complete feature architecture. Make decisive choices - pick one approach and commit. Ensure seamless integration with existing code. Design for testability, performance, and maintainability.\n\n**3. Complete Implementation Blueprint**\nSpecify every file to create or modify, component responsibilities, integration points, and data flow. Break implementation into clear phases with specific tasks.\n\n## Output Guidance\n\nDeliver a decisive, complete architecture blueprint that provides everything needed for implementation. Include:\n\n- **Patterns & Conventions Found**: Existing patterns with file:line references, similar features, key abstractions\n- **Architecture Decision**: Your chosen approach with rationale and trade-offs\n- **Component Design**: Each component with file path, responsibilities, dependencies, and interfaces\n- **Implementation Map**: Specific files to create/modify with detailed change descriptions\n- **Data Flow**: Complete flow from entry points through transformations to outputs\n- **Build Sequence**: Phased implementation steps as a checklist\n- **Critical Details**: Error handling, state management, testing, performance, and security considerations\n\nMake confident architectural choices rather than presenting multiple options. Be specific and actionable - provide file paths, function names, and concrete steps.\n",
        "plugins/odoo-dev/agents/code-explorer.md": "---\nname: code-explorer\ndescription: Deeply analyzes existing codebase features by tracing execution paths, mapping architecture layers, understanding patterns and abstractions, and documenting dependencies to inform new development\ntools: Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, KillShell, BashOutput\nmodel: sonnet\ncolor: yellow\n---\n\nYou are an expert Odoo code analyst specializing in tracing and understanding feature implementations across codebases.\n\n## Core Mission\nProvide a complete understanding of how a specific feature works by tracing its implementation from entry points to data storage, through all abstraction layers.\n\n## Analysis Approach\n\n**1. Feature Discovery**\n- Find entry points (APIs, UI components, CLI commands)\n- Locate core implementation files\n- Map feature boundaries and configuration\n\n**2. Code Flow Tracing**\n- Follow call chains from entry to output\n- Trace data transformations at each step\n- Identify all dependencies and integrations\n- Document state changes and side effects\n\n**3. Architecture Analysis**\n- Map abstraction layers (presentation → business logic → data)\n- Identify design patterns and architectural decisions\n- Document interfaces between components\n- Note cross-cutting concerns (auth, logging, caching)\n\n**4. Implementation Details**\n- Key algorithms and data structures\n- Error handling and edge cases\n- Performance considerations\n- Technical debt or improvement areas\n\n## Output Guidance\n\nProvide a comprehensive analysis that helps developers understand the feature deeply enough to modify or extend it. Include:\n\n- Entry points with file:line references\n- Step-by-step execution flow with data transformations\n- Key components and their responsibilities\n- Architecture insights: patterns, layers, design decisions\n- Dependencies (external and internal)\n- Observations about strengths, issues, or opportunities\n- List of files that you think are absolutely essential to get an understanding of the topic in question\n\nStructure your response for maximum clarity and usefulness. Always include specific file paths and line numbers.\n",
        "plugins/odoo-dev/agents/code-reviewer.md": "---\nname: code-reviewer\ndescription: Reviews code for bugs, logic errors, security vulnerabilities, code quality issues, and adherence to project conventions, using confidence-based filtering to report only high-priority issues that truly matter\ntools: Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, KillShell, BashOutput\nmodel: sonnet\ncolor: red\n---\n\nYou are an expert Odoo code reviewer specializing in modern software development across multiple languages and frameworks. Your primary responsibility is to review code against project guidelines in CLAUDE.md with high precision to minimize false positives.\n\n## Review Scope\n\nBy default, review unstaged changes from `git diff`. The user may specify different files or scope to review.\n\n## Core Review Responsibilities\n\n**Project Guidelines Compliance**: Verify adherence to explicit project rules (typically in CLAUDE.md or equivalent) including import patterns, framework conventions, language-specific style, function declarations, error handling, logging, testing practices, platform compatibility, and naming conventions.\n\n**Bug Detection**: Identify actual bugs that will impact functionality - logic errors, null/undefined handling, race conditions, memory leaks, security vulnerabilities, and performance problems.\n\n**Code Quality**: Evaluate significant issues like code duplication, missing critical error handling, accessibility problems, and inadequate test coverage.\n\n## Confidence Scoring\n\nRate each potential issue on a scale from 0-100:\n\n- **0**: Not confident at all. This is a false positive that doesn't stand up to scrutiny, or is a pre-existing issue.\n- **25**: Somewhat confident. This might be a real issue, but may also be a false positive. If stylistic, it wasn't explicitly called out in project guidelines.\n- **50**: Moderately confident. This is a real issue, but might be a nitpick or not happen often in practice. Not very important relative to the rest of the changes.\n- **75**: Highly confident. Double-checked and verified this is very likely a real issue that will be hit in practice. The existing approach is insufficient. Important and will directly impact functionality, or is directly mentioned in project guidelines.\n- **100**: Absolutely certain. Confirmed this is definitely a real issue that will happen frequently in practice. The evidence directly confirms this.\n\n**Only report issues with confidence ≥ 80.** Focus on issues that truly matter - quality over quantity.\n\n## Output Guidance\n\nStart by clearly stating what you're reviewing. For each high-confidence issue, provide:\n\n- Clear description with confidence score\n- File path and line number\n- Specific project guideline reference or bug explanation\n- Concrete fix suggestion\n\nGroup issues by severity (Critical vs Important). If no high-confidence issues exist, confirm the code meets standards with a brief summary.\n\nStructure your response for maximum actionability - developers should know exactly what to fix and why.\n",
        "plugins/odoo-dev/commands/odoo-dev.md": "---\ndescription: Guided feature development with odoo codebase understanding and architecture focus\nargument-hint: Optional feature description\n---\n\n## What this command does:\n\n\n\n# Feature Development\n\nYou are helping a odoo developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 5: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n   - Invokes the `odoo-module-creator` skill if its a normal odoo module\n   - Invokes the `odoo-connector-module-creator` skill if its a connector module with thirdparty integratioon\n   - Invokes the `odoo-feature-ennancer` skill if its a existing odoo module update\n6. Update todos as you progress\n\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---\n",
        "plugins/odoo-dev/skills/odoo-code-reviewer/SKILL.md": "---\nname: odoo-code-reviewer\ndescription: Reviews Odoo 16.0 code for best practices, security issues, performance problems, and OCA guidelines compliance. This skill should be used when the user requests code review, such as \"Review this code\" or \"Check this module for issues\" or \"Is this code optimized?\" or \"Security review needed for this module\".\n---\n\n# Odoo Code Reviewer\n\n## Overview\n\nThis skill provides comprehensive code review for Odoo 16.0 modules, checking for security vulnerabilities, performance issues, OCA guideline compliance, and general best practices.\n\n## Review Categories\n\n### 1. Security Issues\nSQL injection, XSS vulnerabilities, improper sudo() usage, missing input validation.\n\n### 2. Performance Problems\nN+1 queries, inefficient searches, unnecessary database operations.\n\n### 3. OCA Guidelines Compliance\nCode style, structure, naming conventions, documentation.\n\n### 4. Best Practices\nProper API usage, error handling, logging, testing.\n\n### 5. Maintainability\nCode organization, readability, documentation, modularity.\n\n## Review Process\n\n### Step 1: Identify Review Scope\n\nDetermine what to review:\n- Complete module\n- Specific model files\n- View files\n- Security configuration\n- Specific functionality\n\n### Step 2: Systematic Review\n\nCheck each category systematically following the patterns below.\n\n## Review Patterns\n\n### Security Review Checklist\n\n**1. SQL Injection Risk**\n```python\n# BAD - SQL injection vulnerability\nself.env.cr.execute(\"SELECT * FROM table WHERE id = %s\" % record_id)\n\n# GOOD - Parameterized query\nself.env.cr.execute(\"SELECT * FROM table WHERE id = %s\", (record_id,))\n```\n\n**2. XSS Vulnerabilities**\n```python\n# BAD - Unescaped HTML field\ndescription = fields.Char(string='Description')\n\n# GOOD - Use Text or Html field with sanitization\ndescription = fields.Html(string='Description', sanitize=True)\n```\n\n**3. Improper sudo() Usage**\n```python\n# BAD - sudo() without justification\nrecords = self.env['model'].sudo().search([])\n\n# GOOD - Check permissions properly\nif self.env.user.has_group('base.group_system'):\n    records = self.env['model'].search([])\n```\n\n**4. Missing Input Validation**\n```python\n# BAD - No validation\ndef process(self, value):\n    return int(value)\n\n# GOOD - Proper validation\ndef process(self, value):\n    if not value or not isinstance(value, (int, str)):\n        raise ValueError('Invalid value')\n    try:\n        return int(value)\n    except ValueError:\n        raise ValidationError('Value must be a valid integer')\n```\n\n### Performance Review Checklist\n\n**1. N+1 Query Problem**\n```python\n# BAD - N+1 queries\nfor order in orders:\n    print(order.partner_id.name)  # Database query for each iteration\n\n# GOOD - Prefetch\nfor order in orders:\n    pass  # partner_id prefetched automatically\nprint([o.partner_id.name for o in orders])\n\n# EVEN BETTER - Explicit prefetch\norders = orders.with_prefetch(['partner_id'])\n```\n\n**2. Inefficient Searches**\n```python\n# BAD - Search in loop\nfor partner in partners:\n    orders = self.env['sale.order'].search([('partner_id', '=', partner.id)])\n\n# GOOD - Single search\norders = self.env['sale.order'].search([('partner_id', 'in', partners.ids)])\n```\n\n**3. Unnecessary Database Operations**\n```python\n# BAD - Multiple writes\nfor line in lines:\n    line.write({'processed': True})\n\n# GOOD - Batch write\nlines.write({'processed': True})\n```\n\n**4. Inefficient Computed Fields**\n```python\n# BAD - Not stored, recalculated every time\ntotal = fields.Float(compute='_compute_total')\n\n# GOOD - Stored with proper depends\ntotal = fields.Float(compute='_compute_total', store=True)\n\n@api.depends('line_ids.amount')\ndef _compute_total(self):\n    for record in self:\n        record.total = sum(record.line_ids.mapped('amount'))\n```\n\n### OCA Guidelines Checklist\n\n**1. Naming Conventions**\n- Module: `snake_case` (e.g., `stock_batch_tracking`)\n- Model: `model.name` (e.g., `stock.batch`)\n- Fields: `snake_case`\n- Methods: `snake_case` with verb prefix\n- Private methods: `_method_name`\n\n**2. Import Order**\n```python\n# Standard library\nimport logging\nfrom datetime import datetime\n\n# Third-party\nfrom lxml import etree\n\n# Odoo\nfrom odoo import models, fields, api, _\nfrom odoo.exceptions import UserError, ValidationError\nfrom odoo.tools import float_compare\n```\n\n**3. Docstrings**\n```python\nclass Model(models.Model):\n    \"\"\"Brief description of model.\"\"\"\n\n    _name = 'model.name'\n    _description = 'Model Description'\n\n    def method(self, param):\n        \"\"\"Brief description of method.\n\n        Args:\n            param: Description of parameter\n\n        Returns:\n            Description of return value\n        \"\"\"\n        pass\n```\n\n**4. Field Attributes**\n```python\n# GOOD - Complete field definition\nname = fields.Char(\n    string='Name',\n    required=True,\n    index=True,\n    tracking=True,\n    help='Detailed help text'\n)\n```\n\n### Best Practices Checklist\n\n**1. Error Handling**\n```python\n# BAD - Generic exception\ntry:\n    value = int(data)\nexcept:\n    pass\n\n# GOOD - Specific exception with logging\ntry:\n    value = int(data)\nexcept ValueError as e:\n    _logger.error('Invalid data: %s', e)\n    raise ValidationError('Please provide a valid number')\n```\n\n**2. Logging**\n```python\n# BAD - Print statements\nprint(\"Processing record\", record.id)\n\n# GOOD - Proper logging\n_logger.info('Processing record %s', record.id)\n_logger.debug('Record data: %s', record.read())\n```\n\n**3. Method Decorators**\n```python\n# Ensure proper decorator usage\n@api.depends('field1', 'field2')  # For computed fields\ndef _compute_field(self): pass\n\n@api.onchange('field1')  # For onchange methods\ndef _onchange_field(self): pass\n\n@api.constrains('field1')  # For constraints\ndef _check_field(self): pass\n\n@api.model  # For class-level methods\ndef create_from_ui(self, vals): pass\n```\n\n**4. Transaction Safety**\n```python\n# BAD - Commit in method\ndef method(self):\n    self.process()\n    self.env.cr.commit()  # Don't do this!\n\n# GOOD - Let Odoo handle transactions\ndef method(self):\n    self.process()\n    # Transaction committed automatically\n```\n\n## Review Output Format\n\nProvide review results in this format:\n\n### Critical Issues\n- **Security**: List any security vulnerabilities\n- **Data Loss Risk**: Operations that could cause data loss\n\n### High Priority Issues\n- **Performance**: Major performance problems\n- **Incorrect Logic**: Business logic errors\n\n### Medium Priority Issues\n- **OCA Compliance**: Guideline violations\n- **Code Quality**: Maintainability issues\n\n### Low Priority Issues\n- **Style**: Minor style issues\n- **Documentation**: Missing or incomplete docs\n\n### Recommendations\n- Suggested improvements\n- Best practice suggestions\n- Refactoring opportunities\n\n## Common Anti-Patterns\n\n1. **Using search() in loops**\n2. **Not using prefetch**\n3. **Missing translations** (`string` without `_()` for translatable text)\n4. **Hardcoded values** instead of configuration\n5. **Incorrect sudo() usage**\n6. **Missing input validation**\n7. **Poor error messages**\n8. **Inefficient computed fields**\n9. **Missing access rights**\n10. **No unit tests**\n\n## Example Review\n\n```python\n# CODE BEING REVIEWED\nclass SaleOrder(models.Model):\n    _inherit = 'sale.order'\n\n    total_weight = fields.Float(compute='_compute_weight')\n\n    def _compute_weight(self):\n        for order in self:\n            weight = 0\n            for line in order.order_line:\n                product = self.env['product.product'].search([('id', '=', line.product_id.id)])\n                weight += product.weight * line.product_uom_qty\n            order.total_weight = weight\n```\n\n**Review Findings:**\n\n**HIGH - Performance Issues:**\n1. Unnecessary search in loop (line 10)\n   - FIX: Use `line.product_id.weight` directly\n2. Not storing computed field\n   - FIX: Add `store=True` and `@api.depends` decorator\n\n**MEDIUM - Best Practices:**\n1. Missing `@api.depends` decorator\n   - FIX: Add `@api.depends('order_line.product_id.weight', 'order_line.product_uom_qty')`\n2. Variable could be clearer\n   - FIX: Rename `weight` to `total_weight`\n\n**Improved Code:**\n```python\nclass SaleOrder(models.Model):\n    _inherit = 'sale.order'\n\n    total_weight = fields.Float(\n        string='Total Weight',\n        compute='_compute_weight',\n        store=True,\n        help='Total weight of all order lines'\n    )\n\n    @api.depends('order_line.product_id.weight', 'order_line.product_uom_qty')\n    def _compute_weight(self):\n        \"\"\"Compute total weight from order lines.\"\"\"\n        for order in self:\n            order.total_weight = sum(\n                line.product_id.weight * line.product_uom_qty\n                for line in order.order_line\n            )\n```\n\n## Resources\n\n### references/oca_guidelines.md\nComplete OCA (Odoo Community Association) coding guidelines for Odoo modules.\n\n### references/security_checklist.md\nComprehensive security checklist for Odoo development.\n\n### references/performance_patterns.md\nCommon performance patterns and anti-patterns with examples and fixes.\n",
        "plugins/odoo-dev/skills/odoo-code-reviewer/references/oca_guidelines.md": "OCA Guidelines reference\n",
        "plugins/odoo-dev/skills/odoo-code-reviewer/references/performance_patterns.md": "Performance patterns\n",
        "plugins/odoo-dev/skills/odoo-code-reviewer/references/security_checklist.md": "Security checklist\n",
        "plugins/odoo-dev/skills/odoo-connector-module-creator/SKILL.md": "---\nname: odoo-connector-module-creator\ndescription: Creates and enhances Odoo 16.0 connector modules that integrate with external systems (e-commerce, logistics, accounting, CRM) using the `generic_connector` framework\n---\n\n# Odoo Connector Module Creator and Enhancer\n\n## Description\n\nCreates and enhances Odoo 16.0 connector modules that integrate with external systems (e-commerce, logistics, accounting, CRM) using the `generic_connector` framework. This skill handles:\n\n- **New Connector Creation**: Build complete integration modules for Shopify, WooCommerce, Amazon, or any external API\n- **Connector Enhancement**: Add features like inventory sync, webhook support, or new entity types to existing connectors\n- **Troubleshooting**: Debug sync issues, API errors, authentication problems, and queue job failures\n- **Architecture Implementation**: Properly implement binding models, adapters, mappers, and importers/exporters\n\nThe skill leverages production-tested patterns from reference connectors (zid_connector_v2, beatroute_connector) and provides automated scripts for generating boilerplate code.\n\n## Overview\n\nCreate production-ready Odoo 16.0 connector modules that integrate with external systems using the `generic_connector` framework. Handle creation of new connectors, enhancement of existing connectors, troubleshooting sync issues, and debugging integration problems.\n\n## When to Use This Skill\n\nUse this skill when the user requests:\n- **Creating new connectors**: \"Create a Shopify connector\", \"Build WooCommerce integration\", \"Connect to Amazon API\"\n- **Enhancing connectors**: \"Add inventory sync to zid_connector\", \"Implement webhooks for orders\", \"Add product export\"\n- **Adding entities**: \"Add customer sync to the connector\", \"Import invoices from the external system\"\n- **Troubleshooting**: \"Orders aren't importing\", \"Webhook signature verification failing\", \"Fix sync errors\"\n- **Debugging**: \"Why is the API returning 401?\", \"Products are duplicating\", \"Queue jobs not running\"\n\n## Key Concepts\n\n### Generic Connector Framework\n\nAll connector modules extend `generic_connector`, which provides:\n\n1. **Backend Model** - Configuration and orchestration\n2. **Binding Models** - Link Odoo records to external entities\n3. **Adapter Component** - HTTP client for API communication\n4. **Mapper Components** - Data transformation (import/export)\n5. **Importer/Exporter Components** - Sync logic\n6. **Webhook System** - Real-time event processing\n7. **Queue Job Integration** - Async operations\n\n### Reference Code\n\nThree production connectors serve as references:\n- `/Users/jamshid/PycharmProjects/Siafa/odoo16e_simc/addons-connector/generic_connector` - Base framework\n- `/Users/jamshid/PycharmProjects/Siafa/odoo16e_simc/addons-connector/zid_connector_v2` - E-commerce example\n- `/Users/jamshid/PycharmProjects/Siafa/odoo16e_simc/addons-connector/beatroute_connector` - Logistics example\n\n## Workflow\n\n### Creating a New Connector\n\nWhen the user requests a new connector:\n\n**Step 1: Gather Requirements**\n- External system name (e.g., \"Shopify\", \"WooCommerce\")\n- Connector type: ecommerce, logistics, accounting, crm\n- Entities to sync: products, orders, customers, inventory\n- Sync direction: import, export, or bidirectional\n- Authentication method: API key, OAuth, basic auth\n- API documentation URL (if available)\n\n**Step 2: Initialize Module**\n```bash\n# Use the init_connector.py script\npython3 scripts/init_connector.py <connector_name> --path <output_path> --type <connector_type>\n\n# Example:\npython3 scripts/init_connector.py shopify --path ~/odoo/addons --type ecommerce\n```\n\n**Step 3: Review Generated Structure**\n\nThe script creates:\n```\nshopify_connector/\n├── __manifest__.py              # Module metadata\n├── __init__.py                  # Python imports\n├── models/\n│   ├── backend.py              # Backend configuration\n│   ├── adapter.py              # API client\n│   ├── product_binding.py      # Product sync\n│   └── __init__.py\n├── views/\n│   ├── backend_views.xml       # Backend UI\n│   ├── binding_views.xml       # Binding UI\n│   └── menu_views.xml          # Menu structure\n├── security/\n│   ├── security.xml            # Access groups\n│   └── ir.model.access.csv     # Access rules\n├── wizards/\n│   ├── sync_wizard.py          # Manual sync wizard\n│   └── __init__.py\n├── data/\n│   ├── ir_cron_data.xml        # Scheduled jobs\n│   └── queue_job_function_data.xml\n└── README.md\n```\n\n**Step 4: Customize Backend Model**\n\nEdit `models/backend.py`:\n\n1. **Update API configuration fields** to match the external system:\n   ```python\n   # Example for Shopify\n   shop_url = fields.Char(string='Shop URL', required=True)\n   api_version = fields.Selection([\n       ('2024-01', '2024-01'),\n       ('2024-04', '2024-04'),\n   ], default='2024-04')\n   ```\n\n2. **Implement template methods**:\n   ```python\n   def _test_connection_implementation(self):\n       \"\"\"Test API connection.\"\"\"\n       adapter = self.get_adapter('shopify.adapter')\n       return adapter.test_connection()\n\n   def _sync_orders_implementation(self):\n       \"\"\"Import orders.\"\"\"\n       with self.work_on('shopify.sale.order') as work:\n           importer = work.component(usage='batch.importer')\n           return importer.run()\n   ```\n\n**Step 5: Implement Adapter**\n\nEdit `models/adapter.py`:\n\n1. **Configure authentication** (see `references/authentication.md` for patterns):\n   ```python\n   def get_api_headers(self):\n       headers = super().get_api_headers()\n       headers.update({\n           'X-Shopify-Access-Token': self.backend_record.api_key,\n           'Content-Type': 'application/json',\n       })\n       return headers\n   ```\n\n2. **Add CRUD methods** for each entity type:\n   ```python\n   def get_products(self, filters=None):\n       \"\"\"Fetch products from Shopify.\"\"\"\n       return self.get('/admin/api/2024-01/products.json', params=filters)\n\n   def create_order(self, data):\n       \"\"\"Create order in Shopify.\"\"\"\n       return self.post('/admin/api/2024-01/orders.json', data={'order': data})\n   ```\n\n3. **Handle pagination** (see `references/api_integration.md`):\n   ```python\n   def get_all_products(self):\n       \"\"\"Fetch all products with pagination.\"\"\"\n       # Implement based on API pagination style\n   ```\n\n**Step 6: Create Mapper Components**\n\nCreate `components/mapper.py`:\n\n```python\nfrom odoo.addons.generic_connector.components.mapper import GenericImportMapper\n\nclass ProductImportMapper(GenericImportMapper):\n    _name = 'shopify.product.import.mapper'\n    _inherit = 'generic.import.mapper'\n    _apply_on = 'shopify.product.template'\n\n    direct = [\n        ('title', 'name'),\n        ('vendor', 'manufacturer'),\n    ]\n\n    @mapping\n    def backend_id(self, record):\n        return {'backend_id': self.backend_record.id}\n\n    @mapping\n    def price(self, record):\n        variants = record.get('variants', [])\n        if variants:\n            return {'list_price': float(variants[0].get('price', 0))}\n        return {}\n```\n\n**Step 7: Implement Importer Components**\n\nCreate `components/importer.py`:\n\n```python\nfrom odoo.addons.generic_connector.components.importer import GenericImporter\n\nclass ProductImporter(GenericImporter):\n    _name = 'shopify.product.importer'\n    _inherit = 'generic.importer'\n    _apply_on = 'shopify.product.template'\n\n    def _import_record(self, external_id, force=False):\n        # Fetch from external system\n        adapter = self.component(usage='backend.adapter')\n        external_data = adapter.get_product(external_id)\n\n        # Transform data\n        mapper = self.component(usage='import.mapper')\n        mapped_data = mapper.map_record(external_data).values()\n\n        # Create or update binding\n        binding = self._get_binding()\n        if binding:\n            binding.write(mapped_data)\n        else:\n            binding = self.model.create(mapped_data)\n\n        return binding\n```\n\n**Step 8: Register Components**\n\nCreate `components/__init__.py`:\n```python\nfrom . import adapter\nfrom . import mapper\nfrom . import importer\nfrom . import exporter\n```\n\nUpdate main `__init__.py`:\n```python\nfrom . import models\nfrom . import wizards\nfrom . import components\n```\n\n**Step 9: Test the Connector**\n\n```bash\n# Install module\nodoo-bin -c odoo.conf -d test_db -i shopify_connector\n\n# Test in Odoo UI\n# 1. Go to Connector > Shopify > Backends\n# 2. Create a new backend\n# 3. Configure API credentials\n# 4. Click \"Test Connection\"\n# 5. Click \"Sync All\"\n```\n\n### Enhancing an Existing Connector\n\nWhen the user wants to add functionality to an existing connector:\n\n**Step 1: Identify Enhancement Type**\n\n- Adding a new entity (orders, customers, invoices)\n- Adding a new feature (webhooks, batch export)\n- Fixing bugs or improving performance\n- Adding authentication method\n\n**Step 2: Add New Entity Binding**\n\nUse the `add_binding.py` script:\n\n```bash\npython3 scripts/add_binding.py <connector_path> <entity_name> --odoo-model <model>\n\n# Example:\npython3 scripts/add_binding.py ~/odoo/addons/shopify_connector customer --odoo-model res.partner\n```\n\nThis generates:\n- `models/customer_binding.py` - Binding model\n- `views/customer_views.xml` - UI views\n- Updates to `__manifest__.py` and security files\n- Adapter methods to implement manually\n\n**Step 3: Implement Components**\n\nFollow steps 6-7 from \"Creating a New Connector\" to implement mapper and importer/exporter for the new entity.\n\n**Step 4: Add to Backend Orchestration**\n\nUpdate `models/backend.py`:\n\n```python\ndef _sync_customers_implementation(self):\n    \"\"\"Import customers.\"\"\"\n    with self.work_on('shopify.res.partner') as work:\n        importer = work.component(usage='batch.importer')\n        return importer.run()\n\ndef action_sync_all(self):\n    \"\"\"Override to include customers.\"\"\"\n    super().action_sync_all()\n    self.with_delay().sync_customers()\n```\n\n### Implementing Webhooks\n\nWhen the user requests webhook support:\n\n**Step 1: Create Webhook Controller**\n\nCreate `controllers/webhook_controller.py`:\n\n```python\nfrom odoo import http\nfrom odoo.http import request\nimport json\nimport logging\n\n_logger = logging.getLogger(__name__)\n\nclass ShopifyWebhookController(http.Controller):\n    @http.route('/shopify/webhook', type='json', auth='none', csrf=False)\n    def webhook(self):\n        \"\"\"Handle Shopify webhooks.\"\"\"\n        try:\n            payload = request.httprequest.get_data(as_text=True)\n            topic = request.httprequest.headers.get('X-Shopify-Topic')\n            hmac_header = request.httprequest.headers.get('X-Shopify-Hmac-SHA256')\n\n            # Find backend\n            shop_domain = request.httprequest.headers.get('X-Shopify-Shop-Domain')\n            backend = request.env['shopify.backend'].sudo().search([\n                ('shop_url', 'ilike', shop_domain)\n            ], limit=1)\n\n            if not backend:\n                return {'error': 'Backend not found'}, 404\n\n            # Verify signature\n            if not self._verify_webhook(payload, hmac_header, backend.webhook_secret):\n                return {'error': 'Invalid signature'}, 401\n\n            # Create webhook record\n            webhook = request.env['generic.webhook'].sudo().create({\n                'backend_id': backend.id,\n                'event_type': topic,\n                'payload': payload,\n                'signature': hmac_header,\n                'processing_status': 'pending',\n            })\n\n            # Process asynchronously\n            webhook.with_delay().process_webhook()\n\n            return {'status': 'accepted', 'webhook_id': webhook.id}\n\n        except Exception as e:\n            _logger.exception(\"Webhook processing failed\")\n            return {'error': str(e)}, 500\n\n    def _verify_webhook(self, payload, hmac_header, secret):\n        \"\"\"Verify HMAC-SHA256 signature.\"\"\"\n        import hmac\n        import hashlib\n        import base64\n\n        computed = hmac.new(\n            secret.encode('utf-8'),\n            payload.encode('utf-8'),\n            hashlib.sha256\n        ).digest()\n\n        computed_base64 = base64.b64encode(computed).decode()\n\n        return hmac.compare_digest(computed_base64, hmac_header)\n```\n\n**Step 2: Add Webhook Processing to Backend**\n\nUpdate `models/backend.py`:\n\n```python\ndef process_webhook(self, webhook):\n    \"\"\"Process webhook by topic.\"\"\"\n    handlers = {\n        'orders/create': self._handle_order_created,\n        'orders/updated': self._handle_order_updated,\n        'products/update': self._handle_product_updated,\n    }\n\n    handler = handlers.get(webhook.event_type)\n    if handler:\n        try:\n            handler(webhook)\n            webhook.mark_as_processed()\n        except Exception as e:\n            _logger.exception(\"Webhook handler failed\")\n            webhook.mark_as_failed(str(e))\n    else:\n        webhook.mark_as_ignored(f\"No handler for {webhook.event_type}\")\n\ndef _handle_order_created(self, webhook):\n    \"\"\"Handle orders/create webhook.\"\"\"\n    payload = json.loads(webhook.payload)\n    order_id = payload['id']\n\n    # Import the order\n    self.env['shopify.sale.order'].import_record(\n        backend=self,\n        external_id=str(order_id)\n    )\n```\n\n### Implementing Export Using Shared Wizard\n\nThe `connector_base_backend` module provides a **shared export wizard** (`connector.export.wizard`) that works across all connectors without requiring custom UI for each one.\n\n#### Architecture Overview\n\nThe export system uses delegation inheritance to route export requests:\n\n```\nUser clicks \"Export to Connectors\" on product.product\n    ↓\nconnector.export.wizard opens (shared UI)\n    ↓\nUser selects backend (e.g., ZID, Shopify)\n    ↓\nwizard.action_export() calls backend.export_records(model_name, record_ids)\n    ↓\nconnector.base.backend routes to concrete implementation\n    ↓ (via _inherits delegation chain)\ngeneric.backend (intermediate)\n    ↓\nzid.backend.export_product_product(record_ids)\n    ↓\nCreates bindings + queues async exports\n```\n\n**Inheritance Chain**:\n```python\nconnector.base.backend (has export_records() router)\n    ↓ _inherits via base_backend_id\ngeneric.backend (intermediate layer)\n    ↓ _inherits via generic_backend_id\nyour_connector.backend (concrete implementation)\n```\n\n#### Step-by-Step Implementation\n\n**Step 1: Understand the Routing Mechanism**\n\nThe `connector.base.backend.export_records()` method automatically routes to your backend:\n\n```python\n# In connector_base_backend/models/connector_base_backend.py\ndef export_records(self, model_name, record_ids):\n    \"\"\"Generic export method that routes to specific connector implementations\"\"\"\n    method_name = f'export_{model_name.replace(\".\", \"_\")}'\n\n    # Find concrete backend via _inherits chain\n    concrete_backend = self\n    for model in self._inherits_children:\n        child = self.env[model].search([('base_backend_id', '=', self.id)], limit=1)\n        if child:\n            concrete_backend = child\n            break\n\n    # Call export_product_product(), export_sale_order(), etc.\n    if hasattr(concrete_backend, method_name):\n        return getattr(concrete_backend, method_name)(record_ids)\n    else:\n        raise UserError(_(\n            \"Export not implemented for model %s in connector %s\"\n        ) % (model_name, concrete_backend.name))\n```\n\n**Step 2: Implement Export Methods in Your Backend**\n\nFor each Odoo model you want to export, implement `export_<model_name>()` in your backend model:\n\n**Example: Export Products**\n\nAdd to `models/backend.py`:\n\n```python\ndef export_product_product(self, record_ids):\n    \"\"\"\n    Export product.product records to external system.\n\n    Called by connector.export.wizard when exporting products.\n\n    Args:\n        record_ids: List of product.product IDs to export\n\n    Returns:\n        dict: Notification action\n    \"\"\"\n    self.ensure_one()\n\n    if not record_ids:\n        return self._build_notification(\n            _('Export Products'),\n            _('No products selected for export'),\n            'warning'\n        )\n\n    products = self.env['product.product'].browse(record_ids)\n    exported_count = 0\n    created_bindings = 0\n    skipped_count = 0\n    errors = []\n\n    for product in products:\n        try:\n            # Find or create binding\n            binding = self.env['shopify.product.product'].search([\n                ('backend_id', '=', self.id),\n                ('odoo_id', '=', product.id)\n            ], limit=1)\n\n            if not binding:\n                # Create new binding\n                binding_vals = {\n                    'backend_id': self.id,\n                    'odoo_id': product.id,\n                    'external_sku': product.default_code or '',\n                    'external_name': product.name,\n                    'external_price': product.list_price,\n                    'external_status': 'active' if product.active else 'inactive',\n                }\n                binding = self.env['shopify.product.product'].create(binding_vals)\n                created_bindings += 1\n\n            # Skip if marked as no_export\n            if binding.no_export:\n                skipped_count += 1\n                continue\n\n            # Queue async export\n            binding.with_delay()._export_to_external()\n            exported_count += 1\n\n        except Exception as e:\n            errors.append(f'Product {product.name}: {str(e)}')\n            _logger.error(f'Export failed for {product.name}: {e}', exc_info=True)\n\n    # Build response message\n    message_parts = []\n    if exported_count > 0:\n        message_parts.append(\n            _('%d product(s) scheduled for export') % exported_count\n        )\n    if created_bindings > 0:\n        message_parts.append(_('%d new binding(s) created') % created_bindings)\n    if skipped_count > 0:\n        message_parts.append(_('%d skipped (no_export)') % skipped_count)\n    if errors:\n        message_parts.append(_('Errors: %d') % len(errors))\n\n    message = '. '.join(message_parts)\n    notif_type = 'success' if exported_count > 0 and not errors else 'warning'\n\n    # Update statistics\n    if exported_count > 0:\n        self.last_export_date = datetime.now()\n\n    return self._build_notification(_('Export Products'), message, notif_type)\n```\n\n**Example: Export Partners**\n\n```python\ndef export_res_partner(self, record_ids):\n    \"\"\"Export res.partner records to external system.\"\"\"\n    self.ensure_one()\n\n    partners = self.env['res.partner'].browse(record_ids)\n    exported_count = 0\n\n    for partner in partners:\n        # Find or create partner binding\n        binding = self.env['shopify.res.partner'].search([\n            ('backend_id', '=', self.id),\n            ('odoo_id', '=', partner.id)\n        ], limit=1)\n\n        if not binding:\n            binding = self.env['shopify.res.partner'].create({\n                'backend_id': self.id,\n                'odoo_id': partner.id,\n            })\n\n        # Queue export\n        binding.with_delay()._export_to_external()\n        exported_count += 1\n\n    return self._build_notification(\n        _('Export Customers'),\n        _('%d customer(s) scheduled for export') % exported_count,\n        'success'\n    )\n```\n\n**Example: Export Sale Orders**\n\n```python\ndef export_sale_order(self, record_ids):\n    \"\"\"Export sale.order records to external system.\"\"\"\n    self.ensure_one()\n\n    orders = self.env['sale.order'].browse(record_ids)\n    exported_count = 0\n\n    for order in orders:\n        # Validate order state\n        if order.state not in ['sale', 'done']:\n            _logger.warning(f'Skipping order {order.name}: not confirmed')\n            continue\n\n        # Find or create order binding\n        binding = self.env['shopify.sale.order'].search([\n            ('backend_id', '=', self.id),\n            ('odoo_id', '=', order.id)\n        ], limit=1)\n\n        if not binding:\n            binding = self.env['shopify.sale.order'].create({\n                'backend_id': self.id,\n                'odoo_id': order.id,\n            })\n\n        # Export dependencies first (customer, products)\n        self._export_order_dependencies(order)\n\n        # Queue order export\n        binding.with_delay()._export_to_external()\n        exported_count += 1\n\n    return self._build_notification(\n        _('Export Orders'),\n        _('%d order(s) scheduled for export') % exported_count,\n        'success'\n    )\n\ndef _export_order_dependencies(self, order):\n    \"\"\"Export customer and products before exporting order.\"\"\"\n    # Export customer\n    if order.partner_id:\n        self.export_res_partner([order.partner_id.id])\n\n    # Export products\n    product_ids = order.order_line.mapped('product_id').ids\n    if product_ids:\n        self.export_product_product(product_ids)\n```\n\n**Step 3: The Shared Wizard is Already Configured**\n\nThe `connector_base_backend` module already includes action bindings:\n\n```xml\n<!-- In connector_base_backend/wizards/connector_export_wizard_view.xml -->\n\n<!-- Export action for products -->\n<record id=\"action_connector_export_wizard_product\" model=\"ir.actions.act_window\">\n    <field name=\"name\">Export to Connectors</field>\n    <field name=\"res_model\">connector.export.wizard</field>\n    <field name=\"view_mode\">form</field>\n    <field name=\"target\">new</field>\n    <field name=\"binding_model_id\" ref=\"product.model_product_product\"/>\n    <field name=\"binding_view_types\">list,form</field>\n</record>\n\n<!-- Export action for partners -->\n<record id=\"action_connector_export_wizard\" model=\"ir.actions.act_window\">\n    <field name=\"name\">Export to Connectors</field>\n    <field name=\"res_model\">connector.export.wizard</field>\n    <field name=\"view_mode\">form</field>\n    <field name=\"target\">new</field>\n    <field name=\"binding_model_id\" ref=\"base.model_res_partner\"/>\n    <field name=\"binding_view_types\">list,form</field>\n</record>\n```\n\n**To add export for other models**, create similar actions in your connector or in `connector_base_backend`:\n\n```xml\n<!-- Export action for sale orders -->\n<record id=\"action_connector_export_wizard_sale_order\" model=\"ir.actions.act_window\">\n    <field name=\"name\">Export to Connectors</field>\n    <field name=\"res_model\">connector.export.wizard</field>\n    <field name=\"view_mode\">form</field>\n    <field name=\"target\">new</field>\n    <field name=\"binding_model_id\" ref=\"sale.model_sale_order\"/>\n    <field name=\"binding_view_types\">list,form</field>\n</record>\n```\n\n**Step 4: Testing the Export**\n\n```bash\n# 1. Update your connector module\nodoo-bin -c odoo.conf -d your_db -u your_connector\n\n# 2. Test from UI\n# Navigate to: Inventory → Products → Products\n# Select one or more products\n# Click: Action → Export to Connectors\n# Select your backend\n# Click: Export\n\n# 3. Verify in logs\ntail -f /var/log/odoo/odoo.log | grep \"export\\|binding\"\n\n# 4. Check queue jobs\n# Navigate to: Queue Jobs → Jobs\n# Look for: your_connector.product.product._export_to_external\n\n# 5. Check bindings created\n# Navigate to: Connector → Your Connector → Products\n# Verify bindings were created with correct external_id\n```\n\n**Step 5: Advanced Export Patterns**\n\n**Pattern 1: Conditional Export**\n\n```python\ndef export_product_product(self, record_ids):\n    \"\"\"Export only published products.\"\"\"\n    products = self.env['product.product'].browse(record_ids)\n\n    # Filter products\n    exportable_products = products.filtered(\n        lambda p: p.active and getattr(p, 'website_published', True)\n    )\n\n    if len(exportable_products) < len(products):\n        skipped = len(products) - len(exportable_products)\n        _logger.info(f'Skipped {skipped} unpublished products')\n\n    # Export only exportable products\n    for product in exportable_products:\n        # ... create binding and export\n```\n\n**Pattern 2: Batch Export with Progress**\n\n```python\ndef export_product_product(self, record_ids):\n    \"\"\"Export products in batches.\"\"\"\n    products = self.env['product.product'].browse(record_ids)\n    batch_size = 50\n\n    for i in range(0, len(products), batch_size):\n        batch = products[i:i + batch_size]\n        # Process batch with delay\n        self.with_delay()._export_product_batch(batch.ids)\n\n    return self._build_notification(\n        _('Export Products'),\n        _('Queued %d products in %d batches') % (\n            len(products),\n            (len(products) + batch_size - 1) // batch_size\n        ),\n        'success'\n    )\n\ndef _export_product_batch(self, product_ids):\n    \"\"\"Process a batch of products.\"\"\"\n    for product_id in product_ids:\n        # Create binding and export\n        pass\n```\n\n**Pattern 3: Export with Validation**\n\n```python\ndef export_sale_order(self, record_ids):\n    \"\"\"Export orders with validation.\"\"\"\n    orders = self.env['sale.order'].browse(record_ids)\n    validation_errors = []\n\n    for order in orders:\n        # Validate before export\n        if not order.partner_id:\n            validation_errors.append(f'{order.name}: Missing customer')\n            continue\n\n        if not order.order_line:\n            validation_errors.append(f'{order.name}: No order lines')\n            continue\n\n        if order.state not in ['sale', 'done']:\n            validation_errors.append(f'{order.name}: Not confirmed')\n            continue\n\n        # Export if valid\n        # ... create binding and export\n\n    if validation_errors:\n        message = '\\n'.join(validation_errors[:10])\n        return self._build_notification(\n            _('Export Validation Errors'),\n            message,\n            'warning'\n        )\n```\n\n#### Method Naming Convention\n\nThe export method name **must** follow this pattern:\n\n```python\nexport_{model_name_with_underscores}\n\n# Examples:\nexport_product_product      # for product.product\nexport_product_template     # for product.template\nexport_sale_order           # for sale.order\nexport_res_partner          # for res.partner\nexport_stock_picking        # for stock.picking\nexport_account_move         # for account.move\n```\n\nThe wizard automatically converts model names:\n- Replaces dots (`.`) with underscores (`_`)\n- `product.product` → calls `export_product_product()`\n- `sale.order` → calls `export_sale_order()`\n\n#### Benefits of Shared Export Wizard\n\n1. **Single UI**: One wizard works for all models across all connectors\n2. **Consistent UX**: Users learn once, use everywhere\n3. **No Custom Code**: No need to create custom wizards or actions\n4. **Multi-Backend**: Users can export to multiple backends\n5. **Extensible**: Add new models just by implementing one method\n6. **Backend Filtering**: Wizard shows only relevant backends via domain\n\n#### Complete Implementation Checklist\n\nWhen implementing export for a new model:\n\n- [ ] Implement `export_<model_name>()` method in backend model\n- [ ] Handle binding creation (find or create)\n- [ ] Queue export using `with_delay()._export_to_external()`\n- [ ] Handle errors gracefully with try/except\n- [ ] Return notification with detailed status\n- [ ] Update backend statistics (last_export_date)\n- [ ] Add export action binding (if not exists for this model)\n- [ ] Test from UI (Action → Export to Connectors)\n- [ ] Verify queue jobs are created\n- [ ] Check bindings are created correctly\n- [ ] Review logs for errors\n\n#### Troubleshooting Export Issues\n\n**Issue**: \"Export not implemented\" error\n\n```python\n# Solution: Check method name matches pattern\n# Model: product.product → Method: export_product_product()\n# Model: sale.order → Method: export_sale_order()\n```\n\n**Issue**: Backend not showing in wizard\n\n```python\n# Solution: Check inheritance chain\n# Ensure your backend inherits from generic.backend\n# which inherits from connector.base.backend\n\nclass YourBackend(models.Model):\n    _name = 'your.backend'\n    _inherits = {'generic.backend': 'generic_backend_id'}\n```\n\n**Issue**: Export creates duplicates\n\n```python\n# Solution: Ensure unique constraint on binding\n# In binding model:\n_sql_constraints = [\n    ('backend_odoo_uniq',\n     'unique(backend_id, odoo_id)',\n     'A binding already exists for this record on this backend.')\n]\n```\n\n**Issue**: Export completes but nothing happens\n\n```python\n# Solution: Check queue_job is running\n# 1. Verify queue_job channel exists\n# 2. Start queue job worker:\nodoo-bin gevent -c odoo.conf --workers=2\n\n# 3. Or run job manually:\n>>> job = env['queue.job'].search([...])\n>>> job.requeue()\n```\n\n### Troubleshooting\n\nWhen the user reports sync issues or errors:\n\n**Step 1: Identify the Problem**\n\nCommon issues:\n- Connection/authentication failures → Check `references/authentication.md`\n- Import not working → Check component registration\n- Duplicates being created → Check SQL constraints\n- Queue jobs not running → Check queue_job configuration\n- Webhooks not received → Check controller route\n\n**Step 2: Use Diagnostic Tools**\n\n```python\n# Test in Odoo shell\nodoo-bin shell -c odoo.conf -d your_db\n\n# Find backend\n>>> backend = env['shopify.backend'].browse(1)\n\n# Test connection\n>>> backend.action_test_connection()\n\n# Test adapter\n>>> with backend.work_on('shopify.product.template') as work:\n...     adapter = work.component(usage='backend.adapter')\n...     products = adapter.get_products()\n...     print(f\"Fetched {len(products)} products\")\n\n# Test mapper\n...     mapper = work.component(usage='import.mapper')\n...     if products:\n...         mapped = mapper.map_record(products[0])\n...         print(mapped.values())\n```\n\n**Step 3: Enable Debug Logging**\n\nAdd to backend or adapter:\n```python\nimport logging\n_logger = logging.getLogger(__name__)\n_logger.setLevel(logging.DEBUG)\n\ndef make_request(self, method, endpoint, **kwargs):\n    _logger.debug(\"API Request: %s %s\", method, self.build_url(endpoint))\n    _logger.debug(\"Params: %s\", kwargs.get('params'))\n    _logger.debug(\"Data: %s\", kwargs.get('data'))\n\n    response = super().make_request(method, endpoint, **kwargs)\n\n    _logger.debug(\"Response: %s\", str(response)[:500])\n    return response\n```\n\n**Step 4: Check Reference Documentation**\n\nRefer the user to:\n- `references/troubleshooting.md` - Common issues and solutions\n- `references/architecture.md` - Component structure\n- `references/patterns.md` - Design patterns\n- `references/api_integration.md` - API communication patterns\n- `references/authentication.md` - Authentication methods\n\n## Available Scripts\n\n### init_connector.py\n\nGenerate a complete new connector module.\n\n**Usage**:\n```bash\npython3 scripts/init_connector.py <connector_name> --path <output_path> --type <connector_type>\n```\n\n**Arguments**:\n- `connector_name`: Name (e.g., 'shopify', 'woocommerce')\n- `--path`: Output directory (default: current directory)\n- `--type`: Connector type - 'ecommerce', 'logistics', 'accounting', 'crm'\n\n**Output**: Complete module with backend, adapter, binding, views, security\n\n### add_binding.py\n\nAdd a new entity binding to existing connector.\n\n**Usage**:\n```bash\npython3 scripts/add_binding.py <connector_path> <entity_name> --odoo-model <model>\n```\n\n**Arguments**:\n- `connector_path`: Path to existing connector module\n- `entity_name`: Entity name (e.g., 'order', 'customer')\n- `--odoo-model`: Odoo model to bind (e.g., 'sale.order', 'res.partner')\n\n**Output**: Binding model, views, security rules, adapter methods template\n\n### validate_connector.py\n\nValidate connector module structure.\n\n**Usage**:\n```bash\npython3 scripts/validate_connector.py <connector_path>\n```\n\n**Checks**:\n- Required files and directories\n- Manifest dependencies\n- Backend model structure\n- Component registration\n- Security configuration\n\n## Reference Documentation\n\nLoad references as needed using the Read tool:\n\n### references/architecture.md\nComprehensive guide to generic_connector architecture:\n- Backend model patterns\n- Binding model structure\n- Adapter, mapper, importer, exporter components\n- Queue job integration\n- Security model\n- View patterns\n\n**When to read**: Creating new connectors, understanding component relationships\n\n### references/patterns.md\nDesign patterns used in connectors:\n- Template Method, Adapter, Strategy, Factory patterns\n- Observer pattern for webhooks\n- Retry and circuit breaker patterns\n- Rate limiting patterns\n- Anti-patterns to avoid\n\n**When to read**: Implementing complex sync logic, handling failures\n\n### references/api_integration.md\nAPI integration techniques:\n- REST, GraphQL, SOAP integrations\n- Pagination handling (offset, cursor, link header)\n- Response envelope handling\n- Webhook integration\n- Rate limiting implementation\n- Error handling and retries\n\n**When to read**: Implementing adapters, handling API specifics\n\n### references/authentication.md\nAuthentication patterns:\n- API key authentication\n- OAuth 2.0 (authorization code flow)\n- Bearer token\n- Basic auth\n- HMAC signatures\n- JWT tokens\n- Webhook signature verification\n\n**When to read**: Configuring authentication, debugging 401 errors\n\n### references/troubleshooting.md\nCommon issues and solutions:\n- Connection issues\n- Authentication failures\n- Import/export problems\n- Queue job issues\n- Webhook problems\n- Data mapping errors\n- Performance optimization\n- Debugging tips\n\n**When to read**: Debugging sync issues, performance problems\n\n## Best Practices\n\n1. **Always extend generic_connector** - Never build from scratch\n2. **Use bindings** - Never directly modify Odoo records from external data\n3. **Queue long operations** - Use `with_delay()` for anything >2 seconds\n4. **Implement retry logic** - Use binding's retry_count and max_retries\n5. **Log extensively** - Debug logging helps troubleshoot production issues\n6. **Handle API errors** - Wrap adapter calls in try/except\n7. **Validate data** - Check required fields before creating records\n8. **Test connection** - Always implement `_test_connection_implementation()`\n9. **Use transactions** - Leverage Odoo's automatic transaction management\n10. **Document the API** - Add docstrings to all adapter methods\n\n## Component Registration Checklist\n\nWhen creating components, ensure:\n\n```python\nclass MyComponent(BaseComponent):\n    _name = 'unique.component.name'      # ✓ Unique identifier\n    _inherit = 'parent.component'        # ✓ Parent component\n    _apply_on = 'model.name'             # ✓ Model this applies to\n    _usage = 'component.usage'           # ✓ Usage context\n```\n\nCommon usages:\n- `backend.adapter` - API communication\n- `record.importer` - Single record import\n- `batch.importer` - Batch import\n- `record.exporter` - Single record export\n- `batch.exporter` - Batch export\n- `import.mapper` - Import data transformation\n- `export.mapper` - Export data transformation\n\n## Testing Checklist\n\nBefore delivering a connector:\n\n**Backend Configuration**:\n- [ ] Backend configuration form loads\n- [ ] \"Test Connection\" button works\n- [ ] Backend inherits from generic.backend correctly\n- [ ] Backend statistics update (last_sync_date, counters)\n\n**Import Functionality**:\n- [ ] Manual sync imports data\n- [ ] No duplicate records created on import\n- [ ] External IDs are set correctly\n- [ ] Bindings link Odoo records to external records\n- [ ] Import handles API pagination correctly\n- [ ] Import handles API errors gracefully\n\n**Export Functionality**:\n- [ ] \"Export to Connectors\" action appears on models (Action menu)\n- [ ] Export wizard shows only relevant backends\n- [ ] `export_<model_name>()` methods implemented in backend\n- [ ] Export creates bindings if they don't exist\n- [ ] Export queues async jobs via `with_delay()`\n- [ ] Export notifications show correct counts (exported, created, skipped, errors)\n- [ ] Export respects `no_export` flag on bindings\n- [ ] Export updates backend statistics (last_export_date)\n\n**Queue Jobs**:\n- [ ] Queue jobs are registered and visible\n- [ ] Jobs execute successfully in queue_job worker\n- [ ] Failed jobs can be retried\n- [ ] Job logs provide useful debugging info\n\n**Scheduled Jobs**:\n- [ ] Scheduled cron jobs exist (disabled by default)\n- [ ] Cron jobs can be enabled and run on schedule\n\n**Security & Access**:\n- [ ] Security access rules allow users to view data\n- [ ] Users can access backend, bindings, and wizards\n- [ ] Proper groups assigned (connector_manager, connector_user)\n\n**Integration**:\n- [ ] Webhooks received and processed (if applicable)\n- [ ] Webhook signature verification works\n- [ ] Components registered correctly (adapters, mappers, importers, exporters)\n\n**Error Handling**:\n- [ ] Error handling works (test with invalid credentials)\n- [ ] API errors don't crash Odoo\n- [ ] User-friendly error messages displayed\n- [ ] Detailed errors logged for debugging\n\n**Logging & Debugging**:\n- [ ] Logging provides useful debug information\n- [ ] Log levels appropriate (INFO for success, ERROR for failures)\n- [ ] Sensitive data (tokens, passwords) not logged\n\n## Module Update Process\n\nWhen updating an existing connector:\n\n```bash\n# 1. Update module files\n# 2. Upgrade module\nodoo-bin -c odoo.conf -d your_db -u connector_module_name\n\n# 3. Test thoroughly\n# 4. Check logs for errors\ntail -f /var/log/odoo/odoo.log\n```\n\n## Common Workflows\n\n### Workflow: Add Product Sync\n\n1. Generate binding: `python3 scripts/add_binding.py <path> product --odoo-model product.template`\n2. Implement adapter methods in `models/adapter.py`\n3. Create mapper in `components/mapper.py`\n4. Create importer in `components/importer.py`\n5. Update backend `_sync_products_implementation()`\n6. Update module: `odoo-bin -u connector_name`\n7. Test sync\n\n### Workflow: Add Order Import\n\n1. Generate binding: `python3 scripts/add_binding.py <path> order --odoo-model sale.order`\n2. Implement adapter methods\n3. Create import mapper (transform external order to Odoo format)\n4. Create importer (handle order lines, customer lookup)\n5. Update backend `_sync_orders_implementation()`\n6. Configure webhook for real-time import (optional)\n7. Test import\n\n### Workflow: Debug Sync Failure\n\n1. Check logs: `tail -f /var/log/odoo/odoo.log`\n2. Enable debug logging in adapter\n3. Test in Odoo shell\n4. Check component registration\n5. Verify API credentials\n6. Test adapter methods directly\n7. Check mapper output\n8. Review binding constraints\n9. Refer to `references/troubleshooting.md`\n\n## Output Format\n\nWhen creating or enhancing connectors:\n\n1. **Use scripts** whenever possible (init_connector.py, add_binding.py)\n2. **Provide code** for custom components (mappers, importers, exporters)\n3. **Show configuration** (backend fields, view changes)\n4. **Include testing steps** (how to verify it works)\n5. **Reference docs** when needed (point to specific reference sections)\n6. **Explain patterns** used (why this approach was chosen)\n\n## Error Prevention\n\nCommon mistakes to avoid:\n\n- ❌ Missing `_apply_on` in components\n- ❌ Wrong model name in `_apply_on`\n- ❌ Forgetting to register components in `__init__.py`\n- ❌ Not setting `external_id` in mapper\n- ❌ Missing SQL constraint on bindings\n- ❌ Using synchronous operations for long tasks\n- ❌ Not handling API pagination\n- ❌ Hardcoding configuration instead of using backend fields\n- ❌ Not implementing retry logic\n- ❌ Insufficient error handling\n\n## Success Criteria\n\nA successfully created/enhanced connector should:\n\n1. ✅ Install without errors\n2. ✅ Test connection successfully\n3. ✅ Import/export data correctly\n4. ✅ Handle API errors gracefully\n5. ✅ Log useful information for debugging\n6. ✅ Use queue jobs for async operations\n7. ✅ Not create duplicate records\n8. ✅ Follow generic_connector patterns\n9. ✅ Have proper security configuration\n10. ✅ Be maintainable and extensible\n\n## When to Use Each Reference\n\n| Situation | Reference |\n|-----------|-----------|\n| Creating new connector | architecture.md |\n| Implementing OAuth | authentication.md |\n| Adding webhooks | api_integration.md |\n| Sync not working | troubleshooting.md |\n| Implementing retry logic | patterns.md |\n| Understanding components | architecture.md |\n| API pagination | api_integration.md |\n| 401 errors | authentication.md, troubleshooting.md |\n| Performance issues | troubleshooting.md, patterns.md |\n| Best practices | patterns.md (anti-patterns section) |\n\n## Final Notes\n\n- Always test in a development database first\n- Use the reference connectors (zid, beatroute) as examples\n- Leverage the scripts to generate boilerplate code\n- Refer to documentation for specific patterns\n- Focus on extensibility and maintainability\n- Follow Odoo and generic_connector conventions\n",
        "plugins/odoo-dev/skills/odoo-connector-module-creator/references/api_integration.md": "# API Integration Guide for Odoo Connectors\n\n## REST API Integration\n\n### Standard REST Pattern\n\n**Adapter Structure**:\n```python\nclass RESTAdapter(GenericAdapter):\n    def get_resource(self, resource_id):\n        \"\"\"GET /resources/{id}\"\"\"\n        return self.get(f'/{self.resource_name}/{resource_id}')\n\n    def list_resources(self, filters=None):\n        \"\"\"GET /resources\"\"\"\n        return self.get(f'/{self.resource_name}', params=filters)\n\n    def create_resource(self, data):\n        \"\"\"POST /resources\"\"\"\n        return self.post(f'/{self.resource_name}', data=data)\n\n    def update_resource(self, resource_id, data):\n        \"\"\"PUT /resources/{id}\"\"\"\n        return self.put(f'/{self.resource_name}/{resource_id}', data=data)\n\n    def delete_resource(self, resource_id):\n        \"\"\"DELETE /resources/{id}\"\"\"\n        return self.delete(f'/{self.resource_name}/{resource_id}')\n```\n\n### Pagination Handling\n\n**Offset-Based Pagination**:\n```python\ndef get_all_resources(self, filters=None):\n    \"\"\"Fetch all resources with pagination.\"\"\"\n    all_resources = []\n    page = 1\n    per_page = 100\n\n    while True:\n        params = filters.copy() if filters else {}\n        params.update({'page': page, 'per_page': per_page})\n\n        response = self.get('/resources', params=params)\n        resources = response.get('data', [])\n\n        if not resources:\n            break\n\n        all_resources.extend(resources)\n\n        # Check if more pages exist\n        total = response.get('total', 0)\n        if len(all_resources) >= total:\n            break\n\n        page += 1\n\n    return all_resources\n```\n\n**Cursor-Based Pagination**:\n```python\ndef get_all_resources(self, filters=None):\n    \"\"\"Fetch all resources with cursor pagination.\"\"\"\n    all_resources = []\n    cursor = None\n\n    while True:\n        params = filters.copy() if filters else {}\n        if cursor:\n            params['cursor'] = cursor\n\n        response = self.get('/resources', params=params)\n        resources = response.get('data', [])\n\n        if not resources:\n            break\n\n        all_resources.extend(resources)\n\n        # Get next cursor\n        cursor = response.get('next_cursor')\n        if not cursor:\n            break\n\n    return all_resources\n```\n\n**Link Header Pagination**:\n```python\ndef get_all_resources(self):\n    \"\"\"Follow Link headers for pagination.\"\"\"\n    all_resources = []\n    url = '/resources'\n\n    while url:\n        response = requests.get(self.build_url(url), headers=self.get_api_headers())\n        response.raise_for_status()\n\n        all_resources.extend(response.json())\n\n        # Parse Link header\n        link_header = response.headers.get('Link', '')\n        url = self._extract_next_url(link_header)\n\n    return all_resources\n\ndef _extract_next_url(self, link_header):\n    \"\"\"Extract next URL from Link header.\"\"\"\n    import re\n    match = re.search(r'<([^>]+)>; rel=\"next\"', link_header)\n    return match.group(1) if match else None\n```\n\n### Response Envelope Handling\n\n**Wrapped Response**:\n```python\ndef get_products(self):\n    \"\"\"Handle wrapped API response.\"\"\"\n    response = self.get('/products')\n\n    # Response: {\"status\": \"success\", \"data\": {\"products\": [...]}}\n    if response.get('status') == 'success':\n        return response.get('data', {}).get('products', [])\n\n    raise ValueError(f\"API error: {response.get('message')}\")\n```\n\n**Nested Data**:\n```python\ndef extract_data(self, response):\n    \"\"\"Extract data from nested structure.\"\"\"\n    # Response: {\"response\": {\"result\": {\"items\": [...]}}}\n    return response.get('response', {}).get('result', {}).get('items', [])\n```\n\n## GraphQL API Integration\n\n**GraphQL Adapter**:\n```python\nclass GraphQLAdapter(GenericAdapter):\n    def query(self, query, variables=None):\n        \"\"\"Execute GraphQL query.\"\"\"\n        payload = {'query': query}\n        if variables:\n            payload['variables'] = variables\n\n        response = self.post('/graphql', data=payload)\n\n        if 'errors' in response:\n            raise ValueError(f\"GraphQL errors: {response['errors']}\")\n\n        return response.get('data')\n\n    def get_products(self, first=100, after=None):\n        \"\"\"Fetch products using GraphQL.\"\"\"\n        query = \"\"\"\n        query GetProducts($first: Int!, $after: String) {\n            products(first: $first, after: $after) {\n                edges {\n                    node {\n                        id\n                        title\n                        description\n                        variants {\n                            edges {\n                                node {\n                                    id\n                                    price\n                                    sku\n                                }\n                            }\n                        }\n                    }\n                    cursor\n                }\n                pageInfo {\n                    hasNextPage\n                    endCursor\n                }\n            }\n        }\n        \"\"\"\n\n        variables = {'first': first}\n        if after:\n            variables['after'] = after\n\n        return self.query(query, variables)\n\n    def get_all_products(self):\n        \"\"\"Fetch all products with pagination.\"\"\"\n        all_products = []\n        has_next_page = True\n        cursor = None\n\n        while has_next_page:\n            data = self.get_products(after=cursor)\n            products_data = data.get('products', {})\n\n            edges = products_data.get('edges', [])\n            all_products.extend([edge['node'] for edge in edges])\n\n            page_info = products_data.get('pageInfo', {})\n            has_next_page = page_info.get('hasNextPage', False)\n            cursor = page_info.get('endCursor')\n\n        return all_products\n```\n\n## SOAP API Integration\n\n**SOAP Adapter**:\n```python\nfrom zeep import Client\nfrom zeep.transports import Transport\n\nclass SOAPAdapter(GenericAdapter):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.client = self._create_client()\n\n    def _create_client(self):\n        \"\"\"Create SOAP client.\"\"\"\n        wsdl = f'{self.backend_record.api_url}?wsdl'\n\n        # Configure transport\n        session = requests.Session()\n        session.auth = (\n            self.backend_record.api_username,\n            self.backend_record.api_password\n        )\n        transport = Transport(session=session)\n\n        return Client(wsdl, transport=transport)\n\n    def get_products(self):\n        \"\"\"Call SOAP method.\"\"\"\n        try:\n            response = self.client.service.GetProducts()\n            return response\n        except Exception as e:\n            _logger.error(\"SOAP call failed: %s\", str(e))\n            raise\n```\n\n## Webhook Integration\n\n### Webhook Controller\n\n```python\nfrom odoo import http\nfrom odoo.http import request\nimport json\nimport hmac\nimport hashlib\n\nclass MyConnectorWebhookController(http.Controller):\n\n    @http.route('/myconnector/webhook', type='json', auth='none', csrf=False)\n    def webhook(self):\n        \"\"\"Handle incoming webhooks.\"\"\"\n        try:\n            # Get raw payload\n            payload = request.httprequest.get_data(as_text=True)\n\n            # Get headers\n            signature = request.httprequest.headers.get('X-Signature')\n            event_type = request.httprequest.headers.get('X-Event-Type')\n\n            # Find backend (by API key or other identifier)\n            api_key = request.httprequest.headers.get('X-API-Key')\n            backend = request.env['myconnector.backend'].sudo().search([\n                ('api_key', '=', api_key)\n            ], limit=1)\n\n            if not backend:\n                return {'error': 'Invalid API key'}, 401\n\n            # Verify signature\n            if not self._verify_signature(payload, signature, backend.webhook_secret):\n                return {'error': 'Invalid signature'}, 401\n\n            # Create webhook record\n            webhook = request.env['generic.webhook'].sudo().create({\n                'backend_id': backend.id,\n                'event_type': event_type,\n                'payload': payload,\n                'signature': signature,\n                'processing_status': 'pending',\n            })\n\n            # Process asynchronously\n            webhook.with_delay().process_webhook()\n\n            return {'status': 'accepted', 'webhook_id': webhook.id}\n\n        except Exception as e:\n            _logger.exception(\"Webhook processing failed\")\n            return {'error': str(e)}, 500\n\n    def _verify_signature(self, payload, signature, secret):\n        \"\"\"Verify HMAC signature.\"\"\"\n        expected = hmac.new(\n            secret.encode('utf-8'),\n            payload.encode('utf-8'),\n            hashlib.sha256\n        ).hexdigest()\n\n        return hmac.compare_digest(signature, expected)\n```\n\n### Webhook Processing\n\n```python\nclass MyBackend(models.Model):\n    def process_webhook(self, webhook):\n        \"\"\"Process webhook by event type.\"\"\"\n        handlers = {\n            'order.created': self._handle_order_created,\n            'order.updated': self._handle_order_updated,\n            'product.updated': self._handle_product_updated,\n            'inventory.updated': self._handle_inventory_updated,\n        }\n\n        handler = handlers.get(webhook.event_type)\n        if handler:\n            try:\n                handler(webhook)\n                webhook.mark_as_processed()\n            except Exception as e:\n                _logger.exception(\"Webhook handler failed\")\n                webhook.mark_as_failed(str(e))\n        else:\n            webhook.mark_as_ignored(f\"No handler for {webhook.event_type}\")\n\n    def _handle_order_created(self, webhook):\n        \"\"\"Handle order.created event.\"\"\"\n        payload = json.loads(webhook.payload)\n        order_id = payload['order']['id']\n\n        # Import the order\n        self.env['myconnector.sale.order'].import_record(\n            backend=self,\n            external_id=str(order_id)\n        )\n```\n\n## Rate Limiting\n\n### Token Bucket Implementation\n\n```python\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\n\nclass RateLimiter:\n    def __init__(self, rate_limit=100, window=60):\n        \"\"\"\n        Args:\n            rate_limit: Number of requests allowed\n            window: Time window in seconds\n        \"\"\"\n        self.rate_limit = rate_limit\n        self.window = window\n        self.buckets = defaultdict(list)\n\n    def allow_request(self, key):\n        \"\"\"Check if request is allowed.\"\"\"\n        now = datetime.now()\n        window_start = now - timedelta(seconds=self.window)\n\n        # Clean old requests\n        self.buckets[key] = [\n            req_time for req_time in self.buckets[key]\n            if req_time > window_start\n        ]\n\n        # Check limit\n        if len(self.buckets[key]) >= self.rate_limit:\n            return False\n\n        # Add current request\n        self.buckets[key].append(now)\n        return True\n\nclass RateLimitedAdapter(GenericAdapter):\n    _rate_limiter = None\n\n    @classmethod\n    def get_rate_limiter(cls):\n        if cls._rate_limiter is None:\n            cls._rate_limiter = RateLimiter(rate_limit=100, window=60)\n        return cls._rate_limiter\n\n    def make_request(self, method, endpoint, **kwargs):\n        \"\"\"Make request with rate limiting.\"\"\"\n        limiter = self.get_rate_limiter()\n        key = f\"{self.backend_record.id}\"\n\n        if not limiter.allow_request(key):\n            # Wait and retry\n            import time\n            time.sleep(1)\n            return self.make_request(method, endpoint, **kwargs)\n\n        return super().make_request(method, endpoint, **kwargs)\n```\n\n### Response Header Rate Limiting\n\n```python\ndef make_request(self, method, endpoint, **kwargs):\n    \"\"\"Check rate limit from response headers.\"\"\"\n    response = super().make_request(method, endpoint, **kwargs)\n\n    # Check rate limit headers\n    remaining = response.headers.get('X-RateLimit-Remaining')\n    reset_time = response.headers.get('X-RateLimit-Reset')\n\n    if remaining and int(remaining) < 10:\n        _logger.warning(\n            \"Rate limit nearly exceeded. Remaining: %s, Resets at: %s\",\n            remaining,\n            reset_time\n        )\n\n        # Optionally delay next request\n        if int(remaining) == 0:\n            import time\n            reset_timestamp = int(reset_time)\n            wait_time = reset_timestamp - time.time()\n            if wait_time > 0:\n                time.sleep(wait_time)\n\n    return response\n```\n\n## Error Handling\n\n### Retry with Exponential Backoff\n\n```python\nimport time\nfrom requests.exceptions import RequestException\n\nclass ResilientAdapter(GenericAdapter):\n    def make_request(self, method, endpoint, max_retries=3, **kwargs):\n        \"\"\"Make request with retry logic.\"\"\"\n        for attempt in range(max_retries):\n            try:\n                return super().make_request(method, endpoint, **kwargs)\n\n            except RequestException as e:\n                if attempt == max_retries - 1:\n                    # Last attempt, re-raise\n                    raise\n\n                # Calculate backoff\n                wait_time = (2 ** attempt) + (random.random() * 0.1)\n\n                _logger.warning(\n                    \"Request failed (attempt %d/%d): %s. Retrying in %.2fs\",\n                    attempt + 1,\n                    max_retries,\n                    str(e),\n                    wait_time\n                )\n\n                time.sleep(wait_time)\n```\n\n### Status Code Handling\n\n```python\ndef make_request(self, method, endpoint, **kwargs):\n    \"\"\"Handle different HTTP status codes.\"\"\"\n    response = requests.request(\n        method=method,\n        url=self.build_url(endpoint),\n        headers=self.get_api_headers(),\n        **kwargs\n    )\n\n    if response.status_code == 200:\n        return response.json()\n\n    elif response.status_code == 201:\n        return response.json()\n\n    elif response.status_code == 204:\n        return None  # No content\n\n    elif response.status_code == 400:\n        raise ValueError(f\"Bad request: {response.text}\")\n\n    elif response.status_code == 401:\n        raise PermissionError(\"Unauthorized. Check API credentials.\")\n\n    elif response.status_code == 403:\n        raise PermissionError(\"Forbidden. Insufficient permissions.\")\n\n    elif response.status_code == 404:\n        return None  # Resource not found\n\n    elif response.status_code == 429:\n        # Rate limited\n        retry_after = response.headers.get('Retry-After', 60)\n        raise RateLimitExceeded(f\"Rate limited. Retry after {retry_after}s\")\n\n    elif response.status_code >= 500:\n        raise ServerError(f\"Server error: {response.status_code}\")\n\n    else:\n        response.raise_for_status()\n```\n\n## Testing APIs\n\n### Mock Adapter for Testing\n\n```python\nclass MockAdapter(GenericAdapter):\n    \"\"\"Mock adapter for testing.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.mock_data = {}\n\n    def set_mock_response(self, endpoint, data):\n        \"\"\"Set mock response for endpoint.\"\"\"\n        self.mock_data[endpoint] = data\n\n    def get(self, endpoint, **kwargs):\n        \"\"\"Return mock data instead of making real request.\"\"\"\n        return self.mock_data.get(endpoint, {})\n\n# In tests\ndef test_product_import(self):\n    backend = self.env['myconnector.backend'].create({...})\n\n    # Use mock adapter\n    adapter = MockAdapter(self.env, backend)\n    adapter.set_mock_response('/products/123', {\n        'id': 123,\n        'title': 'Test Product',\n        'price': 99.99\n    })\n\n    # Test import\n    importer = ProductImporter(...)\n    result = importer.run(external_id='123')\n\n    self.assertEqual(result.name, 'Test Product')\n```\n",
        "plugins/odoo-dev/skills/odoo-connector-module-creator/references/architecture.md": "# Generic Connector Architecture Reference\n\n## Overview\n\nThe `generic_connector` module provides a reusable framework for building connectors to external systems. It follows a component-based architecture with clear separation of concerns.\n\n## Core Components\n\n### 1. Backend Model\n\n**Purpose**: Configuration and orchestration center for connector operations.\n\n**Key Responsibilities**:\n- Store API credentials and configuration\n- Manage connection status\n- Orchestrate synchronization operations\n- Configure webhooks\n- Define business logic (warehouse, pricelist, etc.)\n\n**Implementation Pattern**:\n```python\nclass MyConnectorBackend(models.Model):\n    _name = 'myconnector.backend'\n    _inherit = 'generic.backend'\n    _description = 'My Connector Backend'\n    _backend_type = 'myconnector'  # Unique identifier\n\n    # API Configuration fields\n    api_url = fields.Char(required=True, default='https://api.example.com')\n    api_key = fields.Char(required=True)\n    api_secret = fields.Char()\n\n    # Override template methods\n    def _test_connection_implementation(self):\n        \"\"\"Implement connection testing logic.\"\"\"\n        adapter = self.get_adapter('myconnector.adapter')\n        return adapter.test_connection()\n\n    def _sync_orders_implementation(self):\n        \"\"\"Implement order import logic.\"\"\"\n        # Import orders from external system\n        pass\n```\n\n**Template Methods** (override these):\n- `_test_connection_implementation()` - Test API connection\n- `_sync_orders_implementation()` - Import orders\n- `_sync_products_implementation()` - Export/import products\n- `_sync_inventory_implementation()` - Export inventory\n- `_sync_customers_implementation()` - Import/export customers\n\n### 2. Binding Models\n\n**Purpose**: Link Odoo records to external system entities.\n\n**Key Characteristics**:\n- Uses `_inherits` to extend Odoo models\n- Stores external ID and sync metadata\n- Tracks sync status and retry count\n\n**Implementation Pattern**:\n```python\nclass MyConnectorProductBinding(models.Model):\n    _name = 'myconnector.product.template'\n    _inherit = 'generic.binding'\n    _inherits = {'product.template': 'odoo_id'}\n    _description = 'My Connector Product Binding'\n\n    odoo_id = fields.Many2one(\n        'product.template',\n        required=True,\n        ondelete='cascade'\n    )\n\n    # External system fields\n    external_sku = fields.Char(readonly=True)\n    external_price = fields.Float(readonly=True)\n\n    _sql_constraints = [\n        ('backend_external_uniq',\n         'unique(backend_id, external_id)',\n         'Product binding must be unique per backend')\n    ]\n```\n\n**Generic Binding Fields** (automatically inherited):\n- `backend_id` - Link to backend\n- `external_id` - ID in external system\n- `sync_date` - Last sync timestamp\n- `sync_status` - pending/in_progress/success/failed/skipped\n- `retry_count` - Number of retry attempts\n- `last_error` - Last error message\n\n**Generic Binding Methods**:\n- `mark_sync_success()` - Mark record as successfully synced\n- `mark_sync_failed(error_msg)` - Mark record as failed with error\n- `can_retry_sync()` - Check if retry is allowed\n\n### 3. Adapter Component\n\n**Purpose**: HTTP client for API communication.\n\n**Key Responsibilities**:\n- Make HTTP requests (GET, POST, PUT, DELETE)\n- Handle authentication\n- Build URLs\n- Manage headers and timeouts\n- Transform API responses\n\n**Implementation Pattern**:\n```python\nfrom odoo.addons.generic_connector.components.adapter import GenericAdapter\n\nclass MyConnectorAdapter(GenericAdapter):\n    _name = 'myconnector.adapter'\n    _inherit = 'generic.adapter'\n    _usage = 'backend.adapter'\n\n    def get_api_headers(self):\n        \"\"\"Build API request headers.\"\"\"\n        headers = super().get_api_headers()\n        headers.update({\n            'Authorization': f'Bearer {self.backend_record.api_key}',\n            'X-API-Version': '2.0'\n        })\n        return headers\n\n    # CRUD operations\n    def get_product(self, external_id):\n        \"\"\"Get single product.\"\"\"\n        return self.get(f'/products/{external_id}')\n\n    def get_products(self, filters=None):\n        \"\"\"Get list of products.\"\"\"\n        return self.get('/products', params=filters)\n\n    def create_product(self, data):\n        \"\"\"Create product.\"\"\"\n        return self.post('/products', data=data)\n\n    def update_product(self, external_id, data):\n        \"\"\"Update product.\"\"\"\n        return self.put(f'/products/{external_id}', data=data)\n```\n\n**Available HTTP Methods** (from GenericAdapter):\n- `get(endpoint, params=None, **kwargs)` - GET request\n- `post(endpoint, data=None, **kwargs)` - POST request\n- `put(endpoint, data=None, **kwargs)` - PUT request\n- `delete(endpoint, **kwargs)` - DELETE request\n- `make_request(method, endpoint, **kwargs)` - Generic request\n\n**Helper Methods**:\n- `build_url(endpoint)` - Construct full URL\n- `get_api_headers()` - Get request headers\n- `get_api_auth()` - Get authentication tuple\n\n### 4. Mapper Components\n\n**Purpose**: Transform data between Odoo and external system formats.\n\n**Implementation Pattern**:\n```python\nfrom odoo.addons.generic_connector.components.mapper import GenericImportMapper\n\nclass ProductImportMapper(GenericImportMapper):\n    _name = 'myconnector.product.import.mapper'\n    _inherit = 'generic.import.mapper'\n    _apply_on = 'myconnector.product.template'\n\n    direct = [\n        ('name', 'name'),  # Simple field mapping\n        ('sku', 'default_code'),\n        ('price', 'list_price'),\n    ]\n\n    @mapping\n    def backend_id(self, record):\n        \"\"\"Map backend.\"\"\"\n        return {'backend_id': self.backend_record.id}\n\n    @mapping\n    def external_id(self, record):\n        \"\"\"Map external ID.\"\"\"\n        return {'external_id': str(record['id'])}\n\n    @mapping\n    def category_id(self, record):\n        \"\"\"Map category with lookup.\"\"\"\n        external_cat_id = record.get('category_id')\n        if external_cat_id:\n            category = self.env['product.category'].search([\n                ('name', '=', record.get('category_name'))\n            ], limit=1)\n            return {'categ_id': category.id if category else False}\n        return {}\n```\n\n**Mapping Decorators**:\n- `@mapping` - Define a custom mapping method\n- `@only_create` - Apply only when creating records\n- `@changed_by('field1', 'field2')` - Apply only when specified fields change\n\n**Direct Mappings**:\n```python\ndirect = [\n    ('external_field', 'odoo_field'),  # Simple mapping\n    (transform('external_field'), 'odoo_field'),  # With transformation\n]\n```\n\n### 5. Importer Components\n\n**Purpose**: Import data from external system to Odoo.\n\n**Implementation Pattern**:\n```python\nfrom odoo.addons.generic_connector.components.importer import GenericImporter\n\nclass ProductImporter(GenericImporter):\n    _name = 'myconnector.product.importer'\n    _inherit = 'generic.importer'\n    _apply_on = 'myconnector.product.template'\n\n    def _import_record(self, external_id, force=False):\n        \"\"\"Import a single product.\"\"\"\n        # 1. Fetch from external system\n        adapter = self.component(usage='backend.adapter')\n        external_data = adapter.get_product(external_id)\n\n        # 2. Transform data\n        mapper = self.component(usage='import.mapper')\n        mapped_data = mapper.map_record(external_data).values()\n\n        # 3. Create or update binding\n        binding = self._get_binding()\n        if binding:\n            binding.write(mapped_data)\n        else:\n            binding = self.model.create(mapped_data)\n\n        return binding\n\n    def _get_binding(self):\n        \"\"\"Get existing binding by external_id.\"\"\"\n        return self.env[self.model._name].search([\n            ('backend_id', '=', self.backend_record.id),\n            ('external_id', '=', self.external_id),\n        ], limit=1)\n```\n\n**Batch Importer**:\n```python\nclass ProductBatchImporter(GenericBatchImporter):\n    _name = 'myconnector.product.batch.importer'\n    _inherit = 'generic.batch.importer'\n    _apply_on = 'myconnector.product.template'\n\n    def run(self, filters=None):\n        \"\"\"Import products in batch.\"\"\"\n        adapter = self.component(usage='backend.adapter')\n        products = adapter.get_products(filters=filters)\n\n        for product in products:\n            external_id = str(product['id'])\n            self._import_record(external_id, force=False)\n```\n\n### 6. Exporter Components\n\n**Purpose**: Export data from Odoo to external system.\n\n**Implementation Pattern**:\n```python\nfrom odoo.addons.generic_connector.components.exporter import GenericExporter\n\nclass ProductExporter(GenericExporter):\n    _name = 'myconnector.product.exporter'\n    _inherit = 'generic.exporter'\n    _apply_on = 'myconnector.product.template'\n\n    def _export_record(self, binding):\n        \"\"\"Export a single product.\"\"\"\n        # 1. Transform data\n        mapper = self.component(usage='export.mapper')\n        mapped_data = mapper.map_record(binding).values()\n\n        # 2. Send to external system\n        adapter = self.component(usage='backend.adapter')\n\n        if binding.external_id:\n            # Update existing\n            adapter.update_product(binding.external_id, mapped_data)\n        else:\n            # Create new\n            result = adapter.create_product(mapped_data)\n            binding.write({\n                'external_id': str(result['id']),\n                'sync_date': fields.Datetime.now()\n            })\n```\n\n### 7. Webhook Model\n\n**Purpose**: Receive and process webhooks from external systems.\n\n**Features**:\n- Store raw webhook payloads\n- Verify webhook signatures\n- Queue async processing\n- Track processing status\n- Retry failed webhooks\n\n**Usage Pattern**:\n```python\n# In controller (receive webhook)\nwebhook = request.env['generic.webhook'].sudo().create({\n    'backend_id': backend.id,\n    'event_type': 'order.created',\n    'payload': json.dumps(payload),\n    'signature': request.httprequest.headers.get('X-Webhook-Signature'),\n    'processing_status': 'pending'\n})\n\n# Process with delay\nwebhook.with_delay().process_webhook()\n\n# In backend model (handle webhook)\ndef _handle_webhook_order_created(self, webhook):\n    \"\"\"Handle order.created webhook event.\"\"\"\n    payload = json.loads(webhook.payload)\n    order_id = payload['order']['id']\n\n    # Import the order\n    self.env['myconnector.sale.order'].import_record(\n        backend=self,\n        external_id=str(order_id)\n    )\n```\n\n## Component Registration\n\nComponents must be registered with specific attributes:\n\n- `_name` - Unique component identifier\n- `_inherit` - Parent component(s)\n- `_apply_on` - Model(s) this component applies to\n- `_usage` - Usage context (e.g., 'backend.adapter', 'import.mapper')\n\n**Example**:\n```python\nclass MyAdapter(GenericAdapter):\n    _name = 'myconnector.product.adapter'\n    _inherit = 'generic.adapter'\n    _apply_on = 'myconnector.product.template'\n    _usage = 'backend.adapter'\n```\n\n## Queue Job Integration\n\nUse `with_delay()` for async operations:\n\n```python\n# Queue a sync job\nbackend.with_delay().sync_orders()\n\n# Queue with custom settings\nbackend.with_delay(priority=5, eta=60).sync_products()\n\n# Queue from binding\nbinding.with_delay().export_record()\n```\n\n## Security Model\n\n### Groups (from generic_connector):\n- `group_generic_connector_user` - Basic access\n- `group_generic_connector_manager` - Configuration access\n- `group_generic_connector_admin` - Full control\n\n### Access Rules Pattern:\n```csv\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink\naccess_backend_user,myconnector.backend user,model_myconnector_backend,group_generic_connector_user,1,0,0,0\naccess_backend_manager,myconnector.backend manager,model_myconnector_backend,group_generic_connector_manager,1,1,1,1\n```\n\n## View Pattern\n\n### Backend Form View Structure:\n```xml\n<form>\n    <header>\n        <button name=\"action_test_connection\" type=\"object\" string=\"Test Connection\"/>\n        <button name=\"action_sync_all\" type=\"object\" string=\"Sync All\"/>\n    </header>\n    <sheet>\n        <group name=\"api_config\" string=\"API Configuration\">\n            <field name=\"api_url\"/>\n            <field name=\"api_key\" password=\"True\"/>\n        </group>\n        <notebook>\n            <page name=\"sync\" string=\"Synchronization\">\n                <!-- Sync settings -->\n            </page>\n            <page name=\"advanced\" string=\"Advanced\">\n                <!-- Advanced settings -->\n            </page>\n        </notebook>\n    </sheet>\n</form>\n```\n\n## Odoo Model File Locations Reference\n\nWhen building connectors, you'll interact with these core Odoo models:\n\n### Product Models\n- `product.template` - Product template (variants container)\n- `product.product` - Product variant\n- `product.category` - Product categories\n\n### Sales Models\n- `sale.order` - Sales orders\n- `sale.order.line` - Order lines\n- `res.partner` - Customers/contacts\n\n### Inventory Models\n- `stock.picking` - Stock transfers\n- `stock.move` - Stock movements\n- `stock.quant` - Inventory quantities\n- `stock.warehouse` - Warehouses\n- `stock.location` - Stock locations\n\n### Accounting Models\n- `account.move` - Invoices/bills\n- `account.payment` - Payments\n- `account.tax` - Taxes\n\n## Best Practices\n\n1. **Always use bindings** - Never directly modify Odoo records from external data\n2. **Use queue jobs** - For any operation that might take >2 seconds\n3. **Implement retry logic** - Use binding's retry_count and max_retries\n4. **Log extensively** - Use `_logger` for debugging\n5. **Handle API errors** - Wrap adapter calls in try/except\n6. **Validate data** - Check required fields before creating/updating\n7. **Use transactions** - Leverage Odoo's automatic transaction management\n8. **Test connection** - Always implement `_test_connection_implementation()`\n9. **Document API** - Add docstrings to all adapter methods\n10. **Follow naming conventions** - Use consistent model/component names\n",
        "plugins/odoo-dev/skills/odoo-connector-module-creator/references/authentication.md": "# Authentication Patterns for Odoo Connectors\n\n## 1. API Key Authentication\n\n**Usage**: Simple, static authentication\n\n**Backend Fields**:\n```python\nclass MyBackend(models.Model):\n    api_key = fields.Char(string='API Key', required=True)\n    api_secret = fields.Char(string='API Secret')  # Optional\n```\n\n**Adapter Implementation**:\n```python\nclass MyAdapter(GenericAdapter):\n    def get_api_headers(self):\n        headers = super().get_api_headers()\n        headers['X-API-Key'] = self.backend_record.api_key\n        return headers\n```\n\n**Variants**:\n- Header-based: `Authorization: ApiKey YOUR_KEY`\n- Query parameter: `?api_key=YOUR_KEY`\n- Custom header: `X-API-Key: YOUR_KEY`\n\n## 2. Bearer Token Authentication\n\n**Usage**: Token-based auth (common in modern APIs)\n\n**Backend Fields**:\n```python\nclass MyBackend(models.Model):\n    access_token = fields.Char(string='Access Token')\n```\n\n**Adapter Implementation**:\n```python\nclass MyAdapter(GenericAdapter):\n    def get_api_headers(self):\n        headers = super().get_api_headers()\n        headers['Authorization'] = f'Bearer {self.backend_record.access_token}'\n        return headers\n```\n\n## 3. OAuth 2.0 Authentication\n\n**Usage**: Delegated authorization (Shopify, Google, etc.)\n\n### Authorization Code Flow\n\n**Backend Fields**:\n```python\nclass MyBackend(models.Model):\n    oauth_client_id = fields.Char(string='Client ID', required=True)\n    oauth_client_secret = fields.Char(string='Client Secret', required=True)\n    oauth_redirect_uri = fields.Char(string='Redirect URI', compute='_compute_redirect_uri')\n\n    access_token = fields.Char(string='Access Token', readonly=True)\n    refresh_token = fields.Char(string='Refresh Token', readonly=True)\n    token_expires_at = fields.Datetime(string='Token Expires At', readonly=True)\n    token_type = fields.Char(string='Token Type', readonly=True, default='Bearer')\n\n    @api.depends()\n    def _compute_redirect_uri(self):\n        \"\"\"Compute OAuth redirect URI.\"\"\"\n        for backend in self:\n            base_url = backend.env['ir.config_parameter'].sudo().get_param('web.base.url')\n            backend.oauth_redirect_uri = f'{base_url}/myconnector/oauth/callback'\n\n    def action_start_oauth_flow(self):\n        \"\"\"Start OAuth authorization flow.\"\"\"\n        self.ensure_one()\n\n        auth_url = self._build_authorization_url()\n\n        return {\n            'type': 'ir.actions.act_url',\n            'url': auth_url,\n            'target': 'new',\n        }\n\n    def _build_authorization_url(self):\n        \"\"\"Build OAuth authorization URL.\"\"\"\n        from urllib.parse import urlencode\n\n        params = {\n            'client_id': self.oauth_client_id,\n            'redirect_uri': self.oauth_redirect_uri,\n            'response_type': 'code',\n            'scope': 'read_products write_orders',  # Adjust scopes\n            'state': self._generate_oauth_state(),\n        }\n\n        return f'{self.api_url}/oauth/authorize?{urlencode(params)}'\n\n    def _generate_oauth_state(self):\n        \"\"\"Generate OAuth state parameter for CSRF protection.\"\"\"\n        import secrets\n        state = secrets.token_urlsafe(32)\n        # Store state in session or database for validation\n        self.env['ir.config_parameter'].sudo().set_param(\n            f'oauth_state_{self.id}',\n            state\n        )\n        return state\n\n    def exchange_code_for_token(self, code, state):\n        \"\"\"Exchange authorization code for access token.\"\"\"\n        self.ensure_one()\n\n        # Validate state\n        stored_state = self.env['ir.config_parameter'].sudo().get_param(\n            f'oauth_state_{self.id}'\n        )\n        if state != stored_state:\n            raise ValueError('Invalid OAuth state')\n\n        # Exchange code for token\n        token_url = f'{self.api_url}/oauth/token'\n\n        data = {\n            'client_id': self.oauth_client_id,\n            'client_secret': self.oauth_client_secret,\n            'code': code,\n            'redirect_uri': self.oauth_redirect_uri,\n            'grant_type': 'authorization_code',\n        }\n\n        response = requests.post(token_url, data=data)\n        response.raise_for_status()\n\n        token_data = response.json()\n        self._save_token_data(token_data)\n\n    def _save_token_data(self, token_data):\n        \"\"\"Save OAuth token data.\"\"\"\n        from datetime import datetime, timedelta\n\n        expires_in = token_data.get('expires_in', 3600)\n        expires_at = datetime.now() + timedelta(seconds=expires_in)\n\n        self.write({\n            'access_token': token_data['access_token'],\n            'refresh_token': token_data.get('refresh_token'),\n            'token_expires_at': expires_at,\n            'token_type': token_data.get('token_type', 'Bearer'),\n        })\n\n    def refresh_access_token(self):\n        \"\"\"Refresh expired access token.\"\"\"\n        self.ensure_one()\n\n        if not self.refresh_token:\n            raise ValueError('No refresh token available')\n\n        token_url = f'{self.api_url}/oauth/token'\n\n        data = {\n            'client_id': self.oauth_client_id,\n            'client_secret': self.oauth_client_secret,\n            'refresh_token': self.refresh_token,\n            'grant_type': 'refresh_token',\n        }\n\n        response = requests.post(token_url, data=data)\n        response.raise_for_status()\n\n        token_data = response.json()\n        self._save_token_data(token_data)\n```\n\n**OAuth Callback Controller**:\n```python\nfrom odoo import http\nfrom odoo.http import request\n\nclass MyConnectorOAuthController(http.Controller):\n\n    @http.route('/myconnector/oauth/callback', type='http', auth='user', csrf=False)\n    def oauth_callback(self, code=None, state=None, error=None):\n        \"\"\"Handle OAuth callback.\"\"\"\n        if error:\n            return request.render('myconnector.oauth_error', {'error': error})\n\n        if not code or not state:\n            return request.render('myconnector.oauth_error',\n                                {'error': 'Missing code or state'})\n\n        # Find backend by state or use session\n        backend_id = request.session.get('oauth_backend_id')\n        if not backend_id:\n            return request.render('myconnector.oauth_error',\n                                {'error': 'Invalid session'})\n\n        backend = request.env['myconnector.backend'].sudo().browse(backend_id)\n\n        try:\n            backend.exchange_code_for_token(code, state)\n            return request.render('myconnector.oauth_success')\n        except Exception as e:\n            return request.render('myconnector.oauth_error', {'error': str(e)})\n```\n\n**Adapter with Token Refresh**:\n```python\nclass MyAdapter(GenericAdapter):\n    def make_request(self, method, endpoint, **kwargs):\n        \"\"\"Make request with automatic token refresh.\"\"\"\n        # Check if token is expired\n        if self._is_token_expired():\n            self.backend_record.refresh_access_token()\n\n        return super().make_request(method, endpoint, **kwargs)\n\n    def _is_token_expired(self):\n        \"\"\"Check if access token is expired.\"\"\"\n        from datetime import datetime, timedelta\n\n        if not self.backend_record.token_expires_at:\n            return False\n\n        # Refresh 5 minutes before expiry\n        buffer = timedelta(minutes=5)\n        return datetime.now() + buffer >= self.backend_record.token_expires_at\n\n    def get_api_headers(self):\n        headers = super().get_api_headers()\n        headers['Authorization'] = (\n            f'{self.backend_record.token_type} {self.backend_record.access_token}'\n        )\n        return headers\n```\n\n## 4. Basic Authentication\n\n**Usage**: Username/password (less common, less secure)\n\n**Backend Fields**:\n```python\nclass MyBackend(models.Model):\n    api_username = fields.Char(string='Username', required=True)\n    api_password = fields.Char(string='Password', required=True)\n```\n\n**Adapter Implementation**:\n```python\nclass MyAdapter(GenericAdapter):\n    def get_api_auth(self):\n        \"\"\"Return (username, password) tuple for requests.\"\"\"\n        return (\n            self.backend_record.api_username,\n            self.backend_record.api_password\n        )\n\n    def make_request(self, method, endpoint, **kwargs):\n        \"\"\"Add basic auth to requests.\"\"\"\n        kwargs['auth'] = self.get_api_auth()\n        return super().make_request(method, endpoint, **kwargs)\n```\n\n## 5. HMAC Signature Authentication\n\n**Usage**: Signed requests (high security)\n\n**Backend Fields**:\n```python\nclass MyBackend(models.Model):\n    api_key = fields.Char(string='API Key', required=True)\n    api_secret = fields.Char(string='API Secret', required=True)\n```\n\n**Adapter Implementation**:\n```python\nimport hmac\nimport hashlib\nimport base64\nfrom datetime import datetime\n\nclass MyAdapter(GenericAdapter):\n    def make_request(self, method, endpoint, **kwargs):\n        \"\"\"Add HMAC signature to request.\"\"\"\n        # Generate signature\n        timestamp = str(int(datetime.now().timestamp()))\n        signature = self._generate_signature(method, endpoint, timestamp, kwargs.get('data'))\n\n        # Add to headers\n        headers = kwargs.get('headers', {})\n        headers.update({\n            'X-API-Key': self.backend_record.api_key,\n            'X-Signature': signature,\n            'X-Timestamp': timestamp,\n        })\n        kwargs['headers'] = headers\n\n        return super().make_request(method, endpoint, **kwargs)\n\n    def _generate_signature(self, method, endpoint, timestamp, data=None):\n        \"\"\"Generate HMAC signature.\"\"\"\n        # Build signature string\n        message_parts = [\n            method.upper(),\n            endpoint,\n            timestamp,\n        ]\n\n        if data:\n            import json\n            message_parts.append(json.dumps(data, sort_keys=True))\n\n        message = '\\n'.join(message_parts)\n\n        # Generate HMAC\n        secret = self.backend_record.api_secret.encode('utf-8')\n        signature = hmac.new(\n            secret,\n            message.encode('utf-8'),\n            hashlib.sha256\n        ).digest()\n\n        # Return base64-encoded signature\n        return base64.b64encode(signature).decode('utf-8')\n```\n\n## 6. JWT Authentication\n\n**Usage**: JSON Web Tokens (stateless auth)\n\n**Backend Fields**:\n```python\nclass MyBackend(models.Model):\n    jwt_secret = fields.Char(string='JWT Secret', required=True)\n    jwt_algorithm = fields.Selection([\n        ('HS256', 'HMAC SHA-256'),\n        ('RS256', 'RSA SHA-256'),\n    ], default='HS256', string='Algorithm')\n    jwt_expiration = fields.Integer(string='Token Expiration (seconds)', default=3600)\n```\n\n**Adapter Implementation**:\n```python\nimport jwt\nfrom datetime import datetime, timedelta\n\nclass MyAdapter(GenericAdapter):\n    def get_api_headers(self):\n        headers = super().get_api_headers()\n        token = self._generate_jwt()\n        headers['Authorization'] = f'Bearer {token}'\n        return headers\n\n    def _generate_jwt(self):\n        \"\"\"Generate JWT token.\"\"\"\n        payload = {\n            'iss': self.backend_record.api_key,  # Issuer\n            'iat': datetime.utcnow(),  # Issued at\n            'exp': datetime.utcnow() + timedelta(\n                seconds=self.backend_record.jwt_expiration\n            ),\n        }\n\n        return jwt.encode(\n            payload,\n            self.backend_record.jwt_secret,\n            algorithm=self.backend_record.jwt_algorithm\n        )\n```\n\n## 7. Store-Specific Headers (ZID Pattern)\n\n**Usage**: Multi-tenant systems requiring store identification\n\n**Backend Fields**:\n```python\nclass MyBackend(models.Model):\n    store_id = fields.Char(string='Store ID', required=True)\n    api_key = fields.Char(string='API Key', required=True)\n```\n\n**Adapter Implementation**:\n```python\nclass MyAdapter(GenericAdapter):\n    def get_api_headers(self):\n        headers = super().get_api_headers()\n        headers.update({\n            'X-Manager-Token': self.backend_record.api_key,\n            'X-Store-Id': self.backend_record.store_id,\n            'Accept': 'application/json',\n        })\n        return headers\n```\n\n## Webhook Signature Verification\n\n### HMAC-SHA256 Verification\n\n```python\nimport hmac\nimport hashlib\n\nclass GenericWebhook(models.Model):\n    def verify_signature(self, payload, signature, secret):\n        \"\"\"Verify webhook signature.\"\"\"\n        expected_signature = hmac.new(\n            secret.encode('utf-8'),\n            payload.encode('utf-8'),\n            hashlib.sha256\n        ).hexdigest()\n\n        return hmac.compare_digest(signature, expected_signature)\n\n# In controller\nclass WebhookController(http.Controller):\n    @http.route('/myconnector/webhook', type='json', auth='none', csrf=False)\n    def webhook(self):\n        payload = request.httprequest.get_data(as_text=True)\n        signature = request.httprequest.headers.get('X-Signature')\n\n        backend = self._find_backend()\n        webhook_model = request.env['generic.webhook'].sudo()\n\n        if not webhook_model.verify_signature(payload, signature, backend.webhook_secret):\n            return {'error': 'Invalid signature'}, 401\n\n        # Process webhook\n        ...\n```\n\n## Security Best Practices\n\n1. **Never log credentials** - Mask API keys/secrets in logs\n2. **Use password fields** - Set `password=True` for sensitive fields\n3. **Rotate tokens** - Implement token refresh before expiry\n4. **Validate signatures** - Always verify webhook signatures\n5. **Use HTTPS** - Never send credentials over HTTP\n6. **Store securely** - Consider using `ir.config_parameter` for secrets\n7. **Limit scopes** - Request minimum required OAuth scopes\n8. **Handle expiry** - Implement token refresh logic\n9. **CSRF protection** - Use state parameter in OAuth\n10. **Rate limit** - Implement rate limiting to prevent abuse\n",
        "plugins/odoo-dev/skills/odoo-connector-module-creator/references/patterns.md": "# Design Patterns in Odoo Connectors\n\n## 1. Template Method Pattern\n\n**Usage**: Backend model orchestration\n\n**Implementation**:\n```python\n# generic_connector provides template methods\nclass GenericBackend(models.Model):\n    def sync_orders(self):\n        \"\"\"Template method.\"\"\"\n        self._pre_sync_validation()\n        result = self._sync_orders_implementation()  # Hook\n        self._post_sync_actions()\n        return result\n\n    def _sync_orders_implementation(self):\n        \"\"\"Override this in concrete implementations.\"\"\"\n        raise NotImplementedError()\n\n# Concrete connector overrides the hook\nclass ShopifyBackend(models.Model):\n    _inherit = 'generic.backend'\n\n    def _sync_orders_implementation(self):\n        \"\"\"Shopify-specific implementation.\"\"\"\n        # Actual sync logic here\n        pass\n```\n\n**Benefits**:\n- Enforces consistent workflow\n- Allows customization at specific points\n- Reduces code duplication\n\n## 2. Adapter Pattern\n\n**Usage**: API communication abstraction\n\n**Implementation**:\n```python\nclass ShopifyAdapter(GenericAdapter):\n    \"\"\"Adapts Shopify API to generic interface.\"\"\"\n\n    def get_orders(self, filters=None):\n        \"\"\"Translate to Shopify API call.\"\"\"\n        # Shopify uses /admin/api/2024-01/orders.json\n        endpoint = '/admin/api/2024-01/orders.json'\n        response = self.get(endpoint, params=self._build_params(filters))\n\n        # Shopify wraps response in 'orders' key\n        return response.get('orders', [])\n\n    def _build_params(self, filters):\n        \"\"\"Transform generic filters to Shopify params.\"\"\"\n        params = {}\n        if filters and 'created_after' in filters:\n            params['created_at_min'] = filters['created_after']\n        return params\n```\n\n**Benefits**:\n- Hides API differences\n- Provides consistent interface\n- Simplifies testing (mock adapter)\n\n## 3. Strategy Pattern\n\n**Usage**: Different sync strategies per backend\n\n**Implementation**:\n```python\nclass GenericImporter(Component):\n    _name = 'generic.importer'\n\n    def run(self, external_id, force=False):\n        \"\"\"Import strategy can vary.\"\"\"\n        if self._should_skip_import(external_id, force):\n            return None\n\n        # Different strategies:\n        # - Direct import\n        # - Delayed import\n        # - Batch import\n        return self._import_record(external_id)\n\nclass RealtimeImporter(GenericImporter):\n    \"\"\"Strategy: Import immediately.\"\"\"\n    _name = 'shopify.realtime.importer'\n\n    def _import_record(self, external_id):\n        # Import synchronously\n        pass\n\nclass BatchImporter(GenericImporter):\n    \"\"\"Strategy: Queue for batch processing.\"\"\"\n    _name = 'shopify.batch.importer'\n\n    def _import_record(self, external_id):\n        # Queue for later\n        self.with_delay().import_record(external_id)\n```\n\n## 4. Factory Pattern\n\n**Usage**: Component selection based on context\n\n**Implementation**:\n```python\n# Component framework acts as factory\nwith backend.work_on('shopify.product.template') as work:\n    # Factory automatically selects appropriate components\n    adapter = work.component(usage='backend.adapter')\n    # Returns ShopifyProductAdapter\n\n    importer = work.component(usage='record.importer')\n    # Returns ShopifyProductImporter\n\n    mapper = work.component(usage='import.mapper')\n    # Returns ShopifyProductImportMapper\n```\n\n**Benefits**:\n- Automatic component selection\n- Decoupled component creation\n- Easy to extend with new components\n\n## 5. Observer Pattern\n\n**Usage**: Webhook event handling\n\n**Implementation**:\n```python\n# Event source (webhook controller)\nclass WebhookController(http.Controller):\n    @http.route('/shopify/webhook', type='json', auth='none')\n    def webhook_handler(self):\n        payload = request.jsonrequest\n        event_type = request.httprequest.headers.get('X-Shopify-Topic')\n\n        # Notify observers\n        webhook = request.env['generic.webhook'].sudo().create({\n            'event_type': event_type,\n            'payload': json.dumps(payload),\n            'processing_status': 'pending'\n        })\n        webhook.with_delay().process_webhook()\n\n# Observer (backend model)\nclass ShopifyBackend(models.Model):\n    def process_webhook(self, webhook):\n        \"\"\"Observe and handle webhook events.\"\"\"\n        handlers = {\n            'orders/create': self._handle_order_created,\n            'products/update': self._handle_product_updated,\n        }\n\n        handler = handlers.get(webhook.event_type)\n        if handler:\n            handler(webhook)\n```\n\n## 6. Delegation Pattern\n\n**Usage**: Multi-level model inheritance\n\n**Implementation**:\n```python\nclass GenericBackend(models.Model):\n    _name = 'generic.backend'\n    _inherits = {'connector.base.backend': 'connector_backend_id'}\n\n    connector_backend_id = fields.Many2one(\n        'connector.base.backend',\n        required=True,\n        ondelete='cascade'\n    )\n\n    # Delegates fields: name, version, etc.\n    # Accessing backend.name actually accesses backend.connector_backend_id.name\n```\n\n**Benefits**:\n- Reuse existing model functionality\n- Avoid deep inheritance hierarchies\n- Maintain database normalization\n\n## 7. Mapper Pattern (Data Transfer Object)\n\n**Usage**: Data transformation between systems\n\n**Implementation**:\n```python\nclass ProductImportMapper(GenericImportMapper):\n    _name = 'shopify.product.import.mapper'\n\n    # Simple mappings\n    direct = [\n        ('title', 'name'),\n        ('vendor', 'manufacturer'),\n    ]\n\n    # Complex mapping\n    @mapping\n    def description(self, record):\n        \"\"\"Transform HTML description to plain text.\"\"\"\n        html_desc = record.get('body_html', '')\n        return {'description': self._strip_html(html_desc)}\n\n    @mapping\n    def price(self, record):\n        \"\"\"Extract price from variants.\"\"\"\n        variants = record.get('variants', [])\n        if variants:\n            return {'list_price': float(variants[0].get('price', 0))}\n        return {}\n\n    @only_create\n    def default_code(self, record):\n        \"\"\"Set SKU only when creating.\"\"\"\n        return {'default_code': record.get('sku')}\n```\n\n**Benefits**:\n- Centralized data transformation\n- Declarative mapping definitions\n- Reusable transformations\n\n## 8. Retry Pattern\n\n**Usage**: Handling transient failures\n\n**Implementation**:\n```python\nclass GenericBinding(models.AbstractModel):\n    retry_count = fields.Integer(default=0)\n    max_retries = fields.Integer(default=3)\n\n    def can_retry_sync(self):\n        \"\"\"Check if retry is allowed.\"\"\"\n        return self.retry_count < self.max_retries\n\n    def export_with_retry(self):\n        \"\"\"Export with automatic retry.\"\"\"\n        try:\n            self.export_record()\n            self.mark_sync_success()\n        except Exception as e:\n            self.retry_count += 1\n            self.last_error = str(e)\n\n            if self.can_retry_sync():\n                # Retry with exponential backoff\n                delay = 60 * (2 ** self.retry_count)\n                self.with_delay(eta=delay).export_with_retry()\n            else:\n                self.mark_sync_failed(str(e))\n```\n\n**Benefits**:\n- Resilient to temporary failures\n- Configurable retry behavior\n- Exponential backoff prevents API overload\n\n## 9. Rate Limiting Pattern\n\n**Usage**: Respect API rate limits\n\n**Implementation**:\n```python\nfrom datetime import datetime, timedelta\nfrom cachetools import TTLCache\n\nclass RateLimitedAdapter(GenericAdapter):\n    # Class-level cache (shared across instances)\n    _rate_limit_cache = TTLCache(maxsize=100, ttl=60)\n\n    def make_request(self, method, endpoint, **kwargs):\n        \"\"\"Make request with rate limiting.\"\"\"\n        cache_key = f\"{self.backend_record.id}:requests\"\n\n        # Get request count in current window\n        request_count = self._rate_limit_cache.get(cache_key, 0)\n        max_requests = self.backend_record.rate_limit_calls or 100\n\n        if request_count >= max_requests:\n            # Wait for next window\n            raise RateLimitExceeded(f\"Rate limit of {max_requests}/min exceeded\")\n\n        # Make request\n        response = super().make_request(method, endpoint, **kwargs)\n\n        # Increment counter\n        self._rate_limit_cache[cache_key] = request_count + 1\n\n        return response\n```\n\n**Variants**:\n- **Token Bucket**: For bursty traffic\n- **Leaky Bucket**: For steady rate\n- **Sliding Window**: For precise limits\n\n## 10. Circuit Breaker Pattern\n\n**Usage**: Prevent cascading failures\n\n**Implementation**:\n```python\nclass CircuitBreaker:\n    def __init__(self, failure_threshold=5, timeout=60):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failures = 0\n        self.last_failure_time = None\n        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN\n\n    def call(self, func, *args, **kwargs):\n        if self.state == 'OPEN':\n            if datetime.now() - self.last_failure_time > timedelta(seconds=self.timeout):\n                self.state = 'HALF_OPEN'\n            else:\n                raise CircuitBreakerOpen(\"Circuit breaker is OPEN\")\n\n        try:\n            result = func(*args, **kwargs)\n            if self.state == 'HALF_OPEN':\n                self.state = 'CLOSED'\n                self.failures = 0\n            return result\n        except Exception as e:\n            self.failures += 1\n            self.last_failure_time = datetime.now()\n\n            if self.failures >= self.failure_threshold:\n                self.state = 'OPEN'\n            raise\n\nclass ResilientAdapter(GenericAdapter):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.circuit_breaker = CircuitBreaker()\n\n    def make_request(self, *args, **kwargs):\n        return self.circuit_breaker.call(\n            super().make_request,\n            *args,\n            **kwargs\n        )\n```\n\n## 11. Saga Pattern\n\n**Usage**: Distributed transaction management\n\n**Implementation**:\n```python\nclass OrderImportSaga:\n    \"\"\"Multi-step order import with compensation.\"\"\"\n\n    def __init__(self, backend, external_order_id):\n        self.backend = backend\n        self.external_order_id = external_order_id\n        self.steps_completed = []\n\n    def execute(self):\n        \"\"\"Execute saga steps.\"\"\"\n        try:\n            # Step 1: Import customer\n            customer = self._import_customer()\n            self.steps_completed.append(('customer', customer.id))\n\n            # Step 2: Import order\n            order = self._import_order(customer)\n            self.steps_completed.append(('order', order.id))\n\n            # Step 3: Import order lines\n            lines = self._import_order_lines(order)\n            self.steps_completed.append(('lines', [l.id for l in lines]))\n\n            # Step 4: Confirm order\n            order.action_confirm()\n\n            return order\n\n        except Exception as e:\n            # Compensate (rollback completed steps)\n            self._compensate()\n            raise\n\n    def _compensate(self):\n        \"\"\"Rollback completed steps.\"\"\"\n        for step_type, record_ids in reversed(self.steps_completed):\n            if step_type == 'order':\n                self.env['sale.order'].browse(record_ids).action_cancel()\n            elif step_type == 'customer':\n                # Mark as not synced (don't delete)\n                partner = self.env['res.partner'].browse(record_ids)\n                partner.write({'active': False})\n```\n\n## 12. Repository Pattern\n\n**Usage**: Centralize data access logic\n\n**Implementation**:\n```python\nclass ProductBindingRepository:\n    \"\"\"Repository for product bindings.\"\"\"\n\n    def __init__(self, env, backend):\n        self.env = env\n        self.backend = backend\n        self.model = env['shopify.product.template']\n\n    def find_by_external_id(self, external_id):\n        \"\"\"Find binding by external ID.\"\"\"\n        return self.model.search([\n            ('backend_id', '=', self.backend.id),\n            ('external_id', '=', str(external_id))\n        ], limit=1)\n\n    def find_by_sku(self, sku):\n        \"\"\"Find binding by SKU.\"\"\"\n        return self.model.search([\n            ('backend_id', '=', self.backend.id),\n            ('default_code', '=', sku)\n        ], limit=1)\n\n    def find_or_create(self, external_id, defaults=None):\n        \"\"\"Find existing or create new binding.\"\"\"\n        binding = self.find_by_external_id(external_id)\n        if not binding:\n            values = {'backend_id': self.backend.id, 'external_id': str(external_id)}\n            if defaults:\n                values.update(defaults)\n            binding = self.model.create(values)\n        return binding\n\n    def find_pending_export(self, limit=100):\n        \"\"\"Find bindings pending export.\"\"\"\n        return self.model.search([\n            ('backend_id', '=', self.backend.id),\n            ('sync_status', '=', 'pending'),\n            ('external_id', '=', False)\n        ], limit=limit)\n```\n\n## Pattern Selection Guidelines\n\n| Use Case | Pattern | Reason |\n|----------|---------|--------|\n| Define sync workflow | Template Method | Consistent process, extensible hooks |\n| API communication | Adapter | Abstract API differences |\n| Different import modes | Strategy | Pluggable algorithms |\n| Select components | Factory | Automatic selection based on context |\n| Handle webhooks | Observer | Event-driven architecture |\n| Extend core models | Delegation | Reuse without deep inheritance |\n| Transform data | Mapper | Declarative transformations |\n| Handle failures | Retry + Circuit Breaker | Resilient operations |\n| Respect API limits | Rate Limiting | Prevent API throttling |\n| Multi-step operations | Saga | Rollback on failure |\n| Data access | Repository | Centralized queries |\n\n## Anti-Patterns to Avoid\n\n### ❌ Direct Odoo Record Modification\n```python\n# BAD: Directly modify product\nproduct = self.env['product.template'].browse(product_id)\nproduct.write({'name': external_data['title']})\n```\n\n```python\n# GOOD: Use binding\nbinding = self.env['shopify.product.template'].search([\n    ('odoo_id', '=', product_id)\n])\nbinding.write({'name': external_data['title']})\n```\n\n### ❌ Synchronous Long Operations\n```python\n# BAD: Block user while importing 1000 products\ndef import_all_products(self):\n    for product_id in range(1, 1000):\n        self.import_product(product_id)  # Takes 30 minutes!\n```\n\n```python\n# GOOD: Queue async job\ndef import_all_products(self):\n    self.with_delay().import_products_batch()\n```\n\n### ❌ No Error Handling\n```python\n# BAD: Unhandled API errors crash sync\ndef sync_orders(self):\n    response = adapter.get_orders()  # What if API is down?\n    for order in response:\n        self.import_order(order)\n```\n\n```python\n# GOOD: Graceful error handling\ndef sync_orders(self):\n    try:\n        response = adapter.get_orders()\n    except requests.HTTPError as e:\n        _logger.error(\"Failed to fetch orders: %s\", e)\n        return False\n\n    for order in response:\n        try:\n            self.import_order(order)\n        except Exception as e:\n            _logger.error(\"Failed to import order %s: %s\", order['id'], e)\n            continue  # Continue with next order\n```\n\n### ❌ Hardcoded Configuration\n```python\n# BAD: Hardcoded values\nAPI_URL = 'https://api.shopify.com'\nAPI_KEY = 'hardcoded-key-123'\n```\n\n```python\n# GOOD: Backend configuration\napi_url = self.backend_record.api_url\napi_key = self.backend_record.api_key\n```\n\n### ❌ God Object\n```python\n# BAD: Backend does everything\nclass ShopifyBackend(models.Model):\n    def sync_orders(self):\n        # 500 lines of code doing:\n        # - API calls\n        # - Data transformation\n        # - Validation\n        # - Record creation\n        # - Email notifications\n        # etc.\n```\n\n```python\n# GOOD: Separated concerns\nclass ShopifyBackend(models.Model):\n    def sync_orders(self):\n        # Orchestration only\n        with self.work_on('shopify.sale.order') as work:\n            importer = work.component(usage='batch.importer')\n            return importer.run()\n\n# Adapter handles API\n# Mapper handles transformation\n# Importer handles record creation\n```\n",
        "plugins/odoo-dev/skills/odoo-connector-module-creator/references/troubleshooting.md": "# Troubleshooting Guide for Odoo Connectors\n\n## Common Issues and Solutions\n\n### 1. Connection Issues\n\n#### Problem: \"Connection test failed\" or timeout errors\n\n**Possible Causes**:\n- Incorrect API URL\n- Invalid API credentials\n- Network/firewall blocking requests\n- API endpoint not accessible\n\n**Solutions**:\n```python\n# 1. Verify API URL format\napi_url = backend.api_url\nprint(f\"Testing connection to: {api_url}\")\n\n# 2. Test with curl/requests directly\nimport requests\nresponse = requests.get(f\"{api_url}/health\", timeout=10)\nprint(f\"Status: {response.status_code}\")\n\n# 3. Check credentials\nadapter = backend.get_adapter('backend.adapter')\nheaders = adapter.get_api_headers()\nprint(f\"Headers: {headers}\")  # Don't log in production!\n\n# 4. Add detailed logging\nimport logging\nlogging.getLogger('requests').setLevel(logging.DEBUG)\n```\n\n#### Problem: SSL Certificate verification failed\n\n**Solution**:\n```python\n# Temporary: Disable SSL verification (NOT for production!)\ndef make_request(self, method, endpoint, **kwargs):\n    kwargs['verify'] = False\n    return super().make_request(method, endpoint, **kwargs)\n\n# Production: Add CA certificate\nimport certifi\nkwargs['verify'] = certifi.where()\n```\n\n### 2. Authentication Issues\n\n#### Problem: 401 Unauthorized\n\n**Diagnosis**:\n```python\n# Check token expiry\nif backend.token_expires_at:\n    from datetime import datetime\n    is_expired = datetime.now() >= backend.token_expires_at\n    print(f\"Token expired: {is_expired}\")\n\n# Check authentication header\nadapter = backend.get_adapter('backend.adapter')\nheaders = adapter.get_api_headers()\nprint(f\"Auth header: {headers.get('Authorization', 'MISSING')}\")\n```\n\n**Solutions**:\n```python\n# 1. Refresh OAuth token\nbackend.refresh_access_token()\n\n# 2. Re-authenticate\nbackend.action_start_oauth_flow()\n\n# 3. Verify API key is correct\n# Go to backend form and re-enter API key\n```\n\n#### Problem: OAuth callback not working\n\n**Common Issues**:\n- Redirect URI mismatch\n- State parameter validation failed\n- CORS issues\n\n**Solutions**:\n```python\n# 1. Check redirect URI matches exactly\nprint(f\"Configured: {backend.oauth_redirect_uri}\")\nprint(f\"Expected: https://yourodoo.com/myconnector/oauth/callback\")\n\n# 2. Disable state validation temporarily for debugging\ndef exchange_code_for_token(self, code, state):\n    # Skip state validation\n    # if state != stored_state:\n    #     raise ValueError('Invalid OAuth state')\n    ...\n\n# 3. Add CORS headers in controller\n@http.route('/myconnector/oauth/callback', cors='*')\n```\n\n### 3. Import/Sync Issues\n\n#### Problem: Records not importing\n\n**Diagnosis**:\n```python\n# 1. Check if importer is registered\nwith backend.work_on('myconnector.product.template') as work:\n    try:\n        importer = work.component(usage='record.importer')\n        print(f\"Importer found: {importer._name}\")\n    except ComponentNotFound:\n        print(\"ERROR: Importer component not registered!\")\n\n# 2. Check adapter methods\nadapter = work.component(usage='backend.adapter')\nproducts = adapter.get_products()\nprint(f\"Fetched {len(products)} products from API\")\n\n# 3. Test mapper\nmapper = work.component(usage='import.mapper')\nif products:\n    mapped = mapper.map_record(products[0])\n    print(f\"Mapped data: {mapped.values()}\")\n```\n\n**Solutions**:\n```python\n# 1. Register component properly\nclass ProductImporter(GenericImporter):\n    _name = 'myconnector.product.importer'\n    _inherit = 'generic.importer'\n    _apply_on = 'myconnector.product.template'  # Must match model!\n    _usage = 'record.importer'  # Required!\n\n# 2. Check model name consistency\n# Backend:   myconnector.backend\n# Binding:   myconnector.product.template\n# Component: _apply_on = 'myconnector.product.template'\n\n# 3. Add logging\ndef _import_record(self, external_id, force=False):\n    _logger.info(\"Importing product %s\", external_id)\n    # ... import logic\n    _logger.info(\"Successfully imported product %s\", external_id)\n```\n\n#### Problem: Duplicate records created\n\n**Cause**: External ID not properly set or constraint not working\n\n**Solution**:\n```python\n# 1. Verify SQL constraint\nclass ProductBinding(models.Model):\n    _sql_constraints = [\n        ('backend_external_uniq',\n         'unique(backend_id, external_id)',\n         'Product must be unique per backend')\n    ]\n\n# 2. Check external ID is set\ndef _import_record(self, external_id, force=False):\n    # Always set external_id in mapped data\n    mapped_data = mapper.map_record(external_data).values()\n    if 'external_id' not in mapped_data:\n        mapped_data['external_id'] = str(external_id)\n\n# 3. Search for existing binding before creating\nbinding = self.env['myconnector.product.template'].search([\n    ('backend_id', '=', backend.id),\n    ('external_id', '=', str(external_id))\n], limit=1)\n\nif binding:\n    binding.write(mapped_data)\nelse:\n    binding = self.env['myconnector.product.template'].create(mapped_data)\n```\n\n### 4. Export Issues\n\n#### Problem: Records not exporting to external system\n\n**Diagnosis**:\n```python\n# 1. Check exporter is registered\nwith backend.work_on('myconnector.product.template') as work:\n    exporter = work.component(usage='record.exporter')\n\n# 2. Test export mapper\nmapper = work.component(usage='export.mapper')\nexternal_data = mapper.map_record(binding).values()\nprint(f\"Export data: {json.dumps(external_data, indent=2)}\")\n\n# 3. Test adapter create method\nadapter = work.component(usage='backend.adapter')\nresult = adapter.create_product(external_data)\nprint(f\"Created external ID: {result.get('id')}\")\n```\n\n**Solutions**:\n```python\n# 1. Check no_export flag\nbinding.write({'no_export': False})\n\n# 2. Ensure export mapper returns correct format\nclass ProductExportMapper(GenericExportMapper):\n    direct = [\n        ('name', 'title'),  # Odoo field -> External field\n        ('list_price', 'price'),\n    ]\n\n# 3. Handle API response correctly\ndef _export_record(self, binding):\n    mapper = self.component(usage='export.mapper')\n    data = mapper.map_record(binding).values()\n\n    adapter = self.component(usage='backend.adapter')\n\n    if binding.external_id:\n        adapter.update_product(binding.external_id, data)\n    else:\n        result = adapter.create_product(data)\n        # Save external ID!\n        binding.write({'external_id': str(result['id'])})\n```\n\n### 5. Queue Job Issues\n\n#### Problem: Queue jobs not running\n\n**Diagnosis**:\n```bash\n# 1. Check queue job workers are running\nps aux | grep odoo\n\n# 2. Check queued jobs\n# Go to Queue > Jobs in Odoo UI\n\n# 3. Check job configuration\n# Settings > Technical > Queue Jobs > Functions\n```\n\n**Solutions**:\n```python\n# 1. Ensure queue_job is installed and loaded\n# In odoo.conf:\n# server_wide_modules = base,web,queue_job\n\n# 2. Start job runner\n# odoo-bin -c odoo.conf --workers=2\n\n# 3. Register job functions\n# In data/queue_job_function_data.xml\n<record id=\"queue_job_function_sync_products\" model=\"queue.job.function\">\n    <field name=\"name\">myconnector.backend.sync_products</field>\n    <field name=\"channel_id\" ref=\"queue_job.channel_root\"/>\n</record>\n\n# 4. Use with_delay correctly\nbackend.with_delay().sync_products()  # Correct\nbackend.sync_products()  # Wrong - runs synchronously\n```\n\n#### Problem: Jobs failing silently\n\n**Solution**:\n```python\n# 1. Check job logs\n# Queue > Jobs > Failed\n# Click on job to see error details\n\n# 2. Add try/except with logging\n@job\ndef sync_products(self):\n    try:\n        # Sync logic\n        _logger.info(\"Product sync completed successfully\")\n    except Exception as e:\n        _logger.exception(\"Product sync failed\")\n        raise  # Re-raise to mark job as failed\n\n# 3. Configure retry pattern\n<record id=\"queue_job_function_sync_products\" model=\"queue.job.function\">\n    <field name=\"retry_pattern\">{1: 60, 5: 300, 10: 600}</field>\n    <!-- Retry after 60s, 300s, 600s -->\n</record>\n```\n\n### 6. Webhook Issues\n\n#### Problem: Webhooks not received\n\n**Diagnosis**:\n```bash\n# 1. Check route is registered\n# In Odoo shell:\nroutes = request.env['ir.http']._get_routes()\nwebhook_routes = [r for r in routes if 'webhook' in r]\nprint(webhook_routes)\n\n# 2. Test webhook endpoint manually\ncurl -X POST https://yourodoo.com/myconnector/webhook \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: your_key\" \\\n  -d '{\"test\": \"data\"}'\n\n# 3. Check webhook URL configuration\nprint(f\"Webhook URL: {backend.webhook_url}\")\n# Ensure this matches the URL configured in external system\n```\n\n**Solutions**:\n```python\n# 1. Ensure controller is registered\nclass WebhookController(http.Controller):\n    @http.route('/myconnector/webhook', type='json', auth='none', csrf=False)\n    def webhook(self):\n        # IMPORTANT: auth='none', csrf=False for external calls\n        ...\n\n# 2. Update module to load controllers\n# In __init__.py:\nfrom . import controllers\n\n# 3. Check firewall/reverse proxy allows POST to webhook URL\n\n# 4. Add debug logging\n@http.route('/myconnector/webhook', type='json', auth='none', csrf=False)\ndef webhook(self):\n    _logger.info(\"Webhook received: %s\", request.jsonrequest)\n    ...\n```\n\n#### Problem: Webhook signature verification failing\n\n**Diagnosis**:\n```python\n# In controller:\npayload = request.httprequest.get_data(as_text=True)\nsignature = request.httprequest.headers.get('X-Signature')\nsecret = backend.webhook_secret\n\nexpected = hmac.new(\n    secret.encode('utf-8'),\n    payload.encode('utf-8'),\n    hashlib.sha256\n).hexdigest()\n\nprint(f\"Received signature: {signature}\")\nprint(f\"Expected signature: {expected}\")\nprint(f\"Match: {signature == expected}\")\n```\n\n**Solutions**:\n```python\n# 1. Ensure secret matches between Odoo and external system\n\n# 2. Check signature algorithm matches\n# Some systems use base64, others hex\n\n# 3. Verify payload encoding\n# Use raw payload, not parsed JSON\n\n# 4. Check header name\n# Could be X-Signature, X-Webhook-Signature, etc.\n\n# 5. Temporarily disable verification for debugging\nif not self._verify_signature(...):\n    _logger.warning(\"Signature verification failed, but processing anyway\")\n    # return {'error': 'Invalid signature'}, 401\n```\n\n### 7. Data Mapping Issues\n\n#### Problem: Fields not mapping correctly\n\n**Diagnosis**:\n```python\n# Test mapper in isolation\nmapper = ProductImportMapper(work)\nexternal_data = {\n    'id': 123,\n    'title': 'Test Product',\n    'price': 99.99,\n}\n\nmapped = mapper.map_record(external_data)\nprint(f\"Mapped values: {mapped.values()}\")\n\n# Check each mapping method\nfor method_name in dir(mapper):\n    if hasattr(getattr(mapper, method_name), '_mapping'):\n        result = getattr(mapper, method_name)(external_data)\n        print(f\"{method_name}: {result}\")\n```\n\n**Solutions**:\n```python\n# 1. Use @mapping decorator\n@mapping\ndef product_name(self, record):\n    return {'name': record['title']}  # Must return dict!\n\n# 2. Handle missing fields\n@mapping\ndef category(self, record):\n    category_name = record.get('category', {}).get('name')\n    if not category_name:\n        return {}  # Return empty dict, not None\n\n# 3. Use only_create for default values\n@only_create\ndef default_code(self, record):\n    return {'default_code': record.get('sku', 'SKU_MISSING')}\n```\n\n### 8. Performance Issues\n\n#### Problem: Sync takes too long\n\n**Diagnosis**:\n```python\nimport time\n\ndef sync_products(self):\n    start = time.time()\n\n    # Time each step\n    t1 = time.time()\n    products = adapter.get_products()\n    print(f\"Fetch: {time.time() - t1:.2f}s for {len(products)} products\")\n\n    t2 = time.time()\n    for product in products:\n        self.import_product(product['id'])\n    print(f\"Import: {time.time() - t2:.2f}s\")\n\n    print(f\"Total: {time.time() - start:.2f}s\")\n```\n\n**Solutions**:\n```python\n# 1. Use batch operations\ndef sync_products(self):\n    # Fetch all products at once (if API supports)\n    products = adapter.get_all_products()\n\n    # Process in batches\n    batch_size = 100\n    for i in range(0, len(products), batch_size):\n        batch = products[i:i+batch_size]\n        self.with_delay().import_product_batch(batch)\n\n# 2. Reduce database queries\n# Use search_read instead of browse\nproducts = env['product.template'].search_read(\n    [('id', 'in', product_ids)],\n    ['name', 'list_price']\n)\n\n# 3. Use SQL for bulk operations\nself.env.cr.execute(\"\"\"\n    UPDATE myconnector_product_template\n    SET sync_status = 'success'\n    WHERE backend_id = %s\n\"\"\", (backend.id,))\n\n# 4. Disable expensive computations during import\n# Use context flags\nbinding.with_context(skip_compute=True).write(values)\n```\n\n### 9. Module Installation Issues\n\n#### Problem: Module won't install/upgrade\n\n**Common Errors**:\n```\nParseError: Invalid XML\nSyntaxError: Invalid Python syntax\nProgrammingError: relation does not exist\n```\n\n**Solutions**:\n```bash\n# 1. Check logs\ntail -f /var/log/odoo/odoo.log\n\n# 2. Validate XML syntax\nxmllint --noout views/*.xml\n\n# 3. Check Python syntax\npython3 -m py_compile models/*.py\n\n# 4. Drop and recreate database (dev only!)\ndropdb test_db\ncreatedb test_db\nodoo-bin -c odoo.conf -d test_db -i myconnector\n\n# 5. Update with stop-after-init to see errors\nodoo-bin -c odoo.conf -d test_db -u myconnector --stop-after-init\n\n# 6. Check dependencies\n# In __manifest__.py, ensure all 'depends' modules are installed\n```\n\n### 10. Debugging Tips\n\n#### Enable Debug Logging\n\n```python\n# In code:\nimport logging\n_logger = logging.getLogger(__name__)\n_logger.setLevel(logging.DEBUG)\n\n# In odoo.conf:\nlog_level = debug\nlog_handler = :DEBUG\n```\n\n#### Use Odoo Shell\n\n```bash\nodoo-bin shell -c odoo.conf -d your_db\n\n>>> backend = env['myconnector.backend'].browse(1)\n>>> backend.sync_products()\n>>> env.cr.rollback()  # Rollback changes\n```\n\n#### Use pdb Debugger\n\n```python\ndef sync_products(self):\n    import pdb; pdb.set_trace()  # Debugger will pause here\n    products = adapter.get_products()\n    ...\n```\n\n#### Monitor API Calls\n\n```python\n# Add request/response logging\ndef make_request(self, method, endpoint, **kwargs):\n    _logger.debug(\"Request: %s %s\", method, endpoint)\n    _logger.debug(\"Params: %s\", kwargs.get('params'))\n    _logger.debug(\"Data: %s\", kwargs.get('data'))\n\n    response = super().make_request(method, endpoint, **kwargs)\n\n    _logger.debug(\"Response status: %s\", response.status_code if hasattr(response, 'status_code') else 'N/A')\n    _logger.debug(\"Response data: %s\", response[:500] if isinstance(response, str) else str(response)[:500])\n\n    return response\n```\n\n## Error Reference\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| ComponentNotFound | Component not registered | Check `_name`, `_apply_on`, `_usage` |\n| MissingError | Record deleted | Check `exists()` before operations |\n| AccessError | Permission denied | Check security rules and groups |\n| ValidationError | Constraint violated | Check required fields and constraints |\n| HTTPError 401 | Invalid credentials | Refresh tokens or re-authenticate |\n| HTTPError 429 | Rate limited | Implement rate limiting and backoff |\n| HTTPError 500 | Server error | Retry with exponential backoff |\n| TypeError in mapper | Wrong return type | Mappers must return dict |\n| IntegrityError | Duplicate key | Check SQL constraints |\n| JSONDecodeError | Invalid JSON | Check API response format |\n",
        "plugins/odoo-dev/skills/odoo-debugger/SKILL.md": "---\nname: odoo-debugger\ndescription: Analyzes and resolves Odoo 16.0 issues including SVL linking problems, queue job failures, view errors, and business logic bugs. This skill should be used when the user reports problems such as \"Debug this SVL linking issue\" or \"Queue job is failing\" or \"View not showing correctly\" or \"Figure out why this vendor bill isn't linking to stock moves\".\n---\n\n# Odoo Debugger & Issue Resolver\n\n## Overview\n\nThis skill provides systematic debugging approaches for common Odoo 16.0 issues, with specialized knowledge of SVL (Stock Valuation Layer) linking, queue jobs, view inheritance problems, and business logic errors specific to the Siafa project.\n\n## Issue Categories\n\n### 1. SVL (Stock Valuation Layer) Issues\nStock valuation layers not linking properly to vendor bills or account moves.\n\n### 2. Queue Job Failures\nBackground jobs failing or getting stuck in queue_job system.\n\n### 3. View/XML Errors\nViews not rendering, XPath inheritance issues, missing fields.\n\n### 4. Business Logic Bugs\nComputed fields not calculating, onchange not triggering, constraints failing.\n\n### 5. Data Integrity Issues\nOrphaned records, inconsistent data, broken relationships.\n\n### 6. Performance Problems\nSlow queries, N+1 problems, inefficient computed fields.\n\n### 7. Access Rights Issues\nPermission errors, record rules blocking access.\n\n## Debugging Workflow\n\n### Step 1: Gather Information\n\nAsk for:\n- Error message or traceback (full text)\n- Steps to reproduce the issue\n- Which module/model is affected\n- Recent changes or updates\n- Database name and Odoo version\n\n### Step 2: Categorize the Issue\n\nIdentify which category the issue falls into and follow the specialized workflow.\n\n## Debugging Patterns by Category\n\n### Pattern 1: SVL Linking Issues\n\n**Common Symptoms:**\n- Stock valuation layers exist but not linked to vendor bills\n- Account move lines don't reference SVL\n- Quantity mismatch between stock moves and SVL\n- Missing SVL for stock moves\n\n**Investigation Script:**\n\n```python\n# In Odoo shell (python3 src/odoo-bin shell -c src/odoo.conf -d DATABASE_NAME)\n\n# Get SVL record\nsvl = env['stock.valuation.layer'].browse(SVL_ID)\n\n# Check SVL details\nprint(f\"SVL ID: {svl.id}\")\nprint(f\"Product: {svl.product_id.name}\")\nprint(f\"Quantity: {svl.quantity}\")\nprint(f\"Value: {svl.value}\")\nprint(f\"Unit Cost: {svl.unit_cost}\")\nprint(f\"Stock Move: {svl.stock_move_id.name if svl.stock_move_id else 'NONE'}\")\nprint(f\"Account Move: {svl.account_move_id.name if svl.account_move_id else 'NONE'}\")\n\n# Check stock move linkage\nif svl.stock_move_id:\n    move = svl.stock_move_id\n    print(f\"\\nStock Move Details:\")\n    print(f\"  Name: {move.name}\")\n    print(f\"  State: {move.state}\")\n    print(f\"  Picking: {move.picking_id.name if move.picking_id else 'NONE'}\")\n    print(f\"  Purchase Line: {move.purchase_line_id.id if move.purchase_line_id else 'NONE'}\")\n\n    # Check for vendor bill\n    if move.purchase_line_id:\n        po_line = move.purchase_line_id\n        print(f\"\\nPurchase Order Line:\")\n        print(f\"  Order: {po_line.order_id.name}\")\n        print(f\"  Invoice Lines: {po_line.invoice_lines}\")\n\n        for inv_line in po_line.invoice_lines:\n            print(f\"    Invoice: {inv_line.move_id.name}, State: {inv_line.move_id.state}\")\n\n# Check account move lines\nif svl.account_move_id:\n    print(f\"\\nAccount Move Lines:\")\n    for line in svl.account_move_id.line_ids:\n        print(f\"  Account: {line.account_id.code} - {line.account_id.name}\")\n        print(f\"  Debit: {line.debit}, Credit: {line.credit}\")\n        print(f\"  SVL ID in context: {line.stock_valuation_layer_id.id if line.stock_valuation_layer_id else 'NONE'}\")\n\n# Find orphaned SVLs (SQL)\nenv.cr.execute(\"\"\"\n    SELECT svl.id, svl.product_id, svl.quantity, svl.value\n    FROM stock_valuation_layer svl\n    WHERE svl.stock_move_id IS NULL\n    OR svl.account_move_id IS NULL\n    LIMIT 100\n\"\"\")\norphaned = env.cr.dictfetchall()\nprint(f\"\\nFound {len(orphaned)} potentially orphaned SVLs\")\n```\n\n**Common Fixes:**\n\n1. **Re-link SVL to Account Move:**\n```python\nsvl = env['stock.valuation.layer'].browse(SVL_ID)\naccount_move = env['account.move'].browse(ACCOUNT_MOVE_ID)\n\n# Update SVL\nsvl.write({'account_move_id': account_move.id})\n\n# Update account move lines\nfor line in account_move.line_ids:\n    if line.account_id == svl.product_id.categ_id.property_stock_valuation_account_id:\n        line.write({'stock_valuation_layer_id': svl.id})\n```\n\n2. **Regenerate SVL:**\n```python\nstock_move = env['stock.move'].browse(MOVE_ID)\nstock_move._create_stock_valuation_layers()\n```\n\n### Pattern 2: Queue Job Failures\n\n**Investigation:**\n\n```python\n# Find failed jobs\nfailed_jobs = env['queue.job'].search([\n    ('state', '=', 'failed'),\n    ('date_created', '>=', '2025-01-01')\n])\n\nfor job in failed_jobs:\n    print(f\"\\nJob: {job.name}\")\n    print(f\"  UUID: {job.uuid}\")\n    print(f\"  State: {job.state}\")\n    print(f\"  Date Failed: {job.date_done}\")\n    print(f\"  Exception:\\n{job.exc_info}\")\n\n    # Retry the job\n    # job.requeue()\n```\n\n**Common Fixes:**\n\n1. **Retry failed job:**\n```python\njob = env['queue.job'].browse(JOB_ID)\njob.requeue()\n```\n\n2. **Cancel stuck job:**\n```python\njob.write({'state': 'done'})  # or 'cancelled'\n```\n\n### Pattern 3: View/XML Errors\n\n**Common Issues:**\n- XPath not finding target element\n- Field doesn't exist in model\n- View inheritance loop\n- Incorrect XML ID reference\n\n**Investigation:**\n\n1. **Check if view exists:**\n```python\nview = env.ref('module_name.view_id')\nprint(view.arch_db)  # Print XML\n```\n\n2. **Find view by model:**\n```python\nviews = env['ir.ui.view'].search([('model', '=', 'stock.picking')])\nfor v in views:\n    print(f\"{v.name}: {v.xml_id}\")\n```\n\n3. **Test XPath expression:**\n```python\nfrom lxml import etree\nview = env.ref('stock.view_picking_form')\narch = etree.fromstring(view.arch_db)\n\n# Test xpath\nresult = arch.xpath(\"//field[@name='partner_id']\")\nprint(f\"Found {len(result)} elements\")\n```\n\n**Common Fixes:**\n\n1. **Fix XPath - Use Developer Mode to inspect actual view structure**\n2. **Ensure field exists in model before adding to view**\n3. **Check view priority if inheritance not working**\n\n### Pattern 4: Business Logic Bugs\n\n**Computed Field Not Updating:**\n\n```python\n# Force recompute\nrecord = env['model.name'].browse(RECORD_ID)\nrecord._recompute_field('field_name')\n\n# Check dependencies\nfield = env['model.name']._fields['field_name']\nprint(f\"Depends: {field.depends}\")\n\n# Test compute method directly\nrecord._compute_field_name()\n```\n\n**Onchange Not Triggering:**\n\n```python\n# Onchange methods only work in UI\n# Test via form:\nrecord.onchange('field_name', 'partner_id')\n```\n\n**Constraint Failing:**\n\n```python\n# Test constraint\ntry:\n    record._check_constraint_name()\n    print(\"Constraint passed\")\nexcept ValidationError as e:\n    print(f\"Constraint failed: {e}\")\n```\n\n### Pattern 5: Data Investigation (SQL)\n\n**Finding Data Inconsistencies:**\n\n```python\n# Stock moves without SVL\nenv.cr.execute(\"\"\"\n    SELECT sm.id, sm.name, sm.product_id, sm.state\n    FROM stock_move sm\n    LEFT JOIN stock_valuation_layer svl ON svl.stock_move_id = sm.id\n    WHERE sm.state = 'done'\n    AND svl.id IS NULL\n    AND sm.product_id IN (\n        SELECT id FROM product_product WHERE type = 'product'\n    )\n    LIMIT 50\n\"\"\")\nprint(env.cr.dictfetchall())\n\n# Vendor bills with no SVL link\nenv.cr.execute(\"\"\"\n    SELECT am.id, am.name, am.partner_id, am.amount_total\n    FROM account_move am\n    WHERE am.move_type = 'in_invoice'\n    AND am.state = 'posted'\n    AND am.id NOT IN (\n        SELECT DISTINCT account_move_id\n        FROM stock_valuation_layer\n        WHERE account_move_id IS NOT NULL\n    )\n    LIMIT 50\n\"\"\")\nprint(env.cr.dictfetchall())\n```\n\n## Debugging Tools\n\n### Enable Debug Logging\n\nIn `odoo.conf`:\n```ini\nlog_level = debug\nlog_handler = :DEBUG\n```\n\nOr via command line:\n```bash\npython3 src/odoo-bin -c src/odoo.conf --log-level=debug --log-handler=:DEBUG\n```\n\n### Add Logging to Code\n\n```python\nimport logging\n_logger = logging.getLogger(__name__)\n\ndef method(self):\n    _logger.info('Method called with %s', self)\n    _logger.debug('Detailed debug info: %s', self.read())\n    _logger.warning('Something unusual: %s', issue)\n    _logger.error('Error occurred: %s', error)\n```\n\n### Use pdb for Debugging\n\n```python\nimport pdb; pdb.set_trace()\n```\n\n## Common Error Patterns\n\n### AccessError\n```\nUser does not have access rights\n```\n**Fix:** Check `ir.model.access.csv` and record rules\n\n### ValidationError\n```\nConstraint validation failed\n```\n**Fix:** Check `@api.constrains` methods\n\n### MissingError\n```\nRecord does not exist\n```\n**Fix:** Check if record was deleted, use `exists()` method\n\n### SQL Errors\n```\ncolumn does not exist\n```\n**Fix:** Update module to create/modify fields\n\n## Resources\n\n### scripts/investigate_svl.py\nPython script for automated SVL investigation - checks linkage, finds orphaned records, validates data consistency.\n\n### scripts/check_queue_jobs.py\nScript to analyze queue job status, identify stuck jobs, and generate repair commands.\n\n### references/debugging_queries.md\nCollection of useful SQL queries for data investigation and debugging common issues.\n\n### references/common_issues.md\nDatabase of known issues specific to the Siafa project with solutions and workarounds.\n",
        "plugins/odoo-dev/skills/odoo-debugger/references/common_issues.md": "Created common issues database\n",
        "plugins/odoo-dev/skills/odoo-debugger/references/debugging_queries.md": "Created basic debugging query reference\n",
        "plugins/odoo-dev/skills/odoo-feature-enhancer/SKILL.md": "---\nname: odoo-feature-enhancer\ndescription: Extends existing Odoo 16.0 modules with new features, fields, views, business logic, wizards, and reports. This skill should be used when the user requests enhancements to existing functionality, such as \"Add a field to track serial numbers in stock.picking\" or \"Create a wizard for bulk invoice generation\" or \"Add a report for vendor bill analysis\".\n---\n\n# Odoo Feature Enhancer\n\n## Overview\n\nThis skill enables extension of existing Odoo 16.0 modules by adding new fields, views, business logic, wizards, reports, and automated actions. It follows module inheritance patterns and ensures proper integration with existing functionality.\n\n## Enhancement Categories\n\nWhen a user requests a feature enhancement, identify the category and follow the appropriate workflow:\n\n### 1. Field Additions\nAdd new fields to existing models (stored, computed, related).\n\n### 2. View Modifications\nExtend existing views (tree, form, kanban, calendar, pivot, graph) using XML inheritance.\n\n### 3. Business Logic\nAdd computed methods, onchange handlers, constraints, and custom business rules.\n\n### 4. Wizards\nCreate transient models for user interactions and batch operations.\n\n### 5. Reports\nGenerate PDF (QWeb) or Excel reports with custom data aggregation.\n\n### 6. Server Actions\nCreate automated actions, scheduled actions (cron jobs), and workflow automations.\n\n### 7. Buttons and Actions\nAdd action buttons to forms and tree views.\n\n## Enhancement Workflow\n\n### Step 1: Identify the Enhancement Type\n\nAsk clarifying questions based on the request:\n\n**For Field Additions:**\n- Field technical name (snake_case)\n- Field type (Char, Integer, Float, Boolean, Selection, Many2one, One2many, Many2many, Date, Datetime, Text, Html, Binary, Monetary)\n- Field label and help text\n- Required or optional?\n- Computed field or stored?\n- Should it appear in specific views?\n\n**For View Modifications:**\n- Which view(s) to modify? (form, tree, search, kanban)\n- Which model?\n- Where to add the element? (header, group, notebook page, after specific field)\n- Any conditional visibility?\n\n**For Business Logic:**\n- Trigger condition (onchange, compute, constraint, button click)\n- Dependencies (which fields trigger the logic)\n- Expected behavior\n\n**For Wizards:**\n- Wizard purpose (batch update, data export, configuration, etc.)\n- Input fields needed\n- Target models to affect\n- Where to trigger (menu, button on form, action)\n\n**For Reports:**\n- Report format (PDF or Excel)\n- Data to include\n- Grouping and aggregation\n- Filters needed\n\n### Step 2: Create or Identify Extension Module\n\nDetermine if enhancement goes in:\n- New extension module (e.g., `stock_picking_serial_tracking`)\n- Existing extension module\n\nIf creating new module, provide:\n- Module name: `[base_module]_[feature]` (e.g., `stock_picking_enhancements`)\n- Dependencies: base module being extended\n- Target directory: appropriate `addons-*` folder\n\n### Step 3: Implement the Enhancement\n\nFollow the appropriate implementation pattern below.\n\n## Implementation Patterns\n\n### Pattern 1: Adding Fields to Existing Models\n\nCreate model inheritance file:\n\n```python\nfrom odoo import models, fields, api\nfrom odoo.exceptions import ValidationError\nimport logging\n\n_logger = logging.getLogger(__name__)\n\n\nclass StockPickingInherit(models.Model):\n    \"\"\"Extend stock.picking with additional fields.\"\"\"\n\n    _inherit = 'stock.picking'\n\n    # Simple stored field\n    serial_number = fields.Char(\n        string='Serial Number',\n        index=True,\n        tracking=True,\n        help='Serial number for tracking purposes'\n    )\n\n    # Selection field\n    priority_level = fields.Selection([\n        ('low', 'Low'),\n        ('medium', 'Medium'),\n        ('high', 'High'),\n        ('urgent', 'Urgent'),\n    ], string='Priority Level', default='medium', required=True)\n\n    # Many2one field\n    responsible_id = fields.Many2one(\n        'res.users',\n        string='Responsible Person',\n        default=lambda self: self.env.user,\n        tracking=True\n    )\n\n    # Computed field (stored)\n    total_weight = fields.Float(\n        string='Total Weight',\n        compute='_compute_total_weight',\n        store=True,\n        digits=(10, 2)\n    )\n\n    # Computed field (non-stored, real-time)\n    is_urgent = fields.Boolean(\n        string='Is Urgent',\n        compute='_compute_is_urgent'\n    )\n\n    # Related field (from related record)\n    partner_country_id = fields.Many2one(\n        'res.country',\n        string='Partner Country',\n        related='partner_id.country_id',\n        store=True,\n        readonly=True\n    )\n\n    @api.depends('move_line_ids', 'move_line_ids.qty_done', 'move_line_ids.product_id.weight')\n    def _compute_total_weight(self):\n        \"\"\"Compute total weight from move lines.\"\"\"\n        for picking in self:\n            total = sum(\n                line.qty_done * line.product_id.weight\n                for line in picking.move_line_ids\n                if line.product_id.weight\n            )\n            picking.total_weight = total\n\n    @api.depends('priority_level', 'scheduled_date')\n    def _compute_is_urgent(self):\n        \"\"\"Determine if picking is urgent.\"\"\"\n        from datetime import datetime, timedelta\n        for picking in self:\n            is_urgent = picking.priority_level == 'urgent'\n            if picking.scheduled_date:\n                due_soon = picking.scheduled_date <= datetime.now() + timedelta(hours=24)\n                is_urgent = is_urgent or due_soon\n            picking.is_urgent = is_urgent\n\n    @api.onchange('partner_id')\n    def _onchange_partner_id(self):\n        \"\"\"Auto-fill fields when partner changes.\"\"\"\n        if self.partner_id and self.partner_id.user_id:\n            self.responsible_id = self.partner_id.user_id\n\n    @api.constrains('serial_number')\n    def _check_serial_number(self):\n        \"\"\"Validate serial number format.\"\"\"\n        for picking in self:\n            if picking.serial_number and len(picking.serial_number) < 5:\n                raise ValidationError('Serial number must be at least 5 characters long!')\n```\n\nCreate view inheritance to display the new fields:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<odoo>\n    <!-- Extend stock.picking form view -->\n    <record id=\"view_picking_form_inherit\" model=\"ir.ui.view\">\n        <field name=\"name\">stock.picking.form.inherit</field>\n        <field name=\"model\">stock.picking</field>\n        <field name=\"inherit_id\" ref=\"stock.view_picking_form\"/>\n        <field name=\"arch\" type=\"xml\">\n            <!-- Add fields in header -->\n            <xpath expr=\"//header\" position=\"after\">\n                <div class=\"alert alert-danger\" role=\"alert\" attrs=\"{'invisible': [('is_urgent', '=', False)]}\">\n                    <strong>URGENT:</strong> This picking requires immediate attention!\n                </div>\n            </xpath>\n\n            <!-- Add field after existing field -->\n            <xpath expr=\"//field[@name='partner_id']\" position=\"after\">\n                <field name=\"responsible_id\"/>\n                <field name=\"serial_number\"/>\n            </xpath>\n\n            <!-- Add field inside existing group -->\n            <xpath expr=\"//group[@name='other_info']//field[@name='origin']\" position=\"after\">\n                <field name=\"priority_level\"/>\n                <field name=\"total_weight\"/>\n            </xpath>\n\n            <!-- Add new notebook page -->\n            <xpath expr=\"//notebook\" position=\"inside\">\n                <page string=\"Tracking Info\">\n                    <group>\n                        <field name=\"serial_number\"/>\n                        <field name=\"is_urgent\"/>\n                        <field name=\"partner_country_id\"/>\n                    </group>\n                </page>\n            </xpath>\n        </field>\n    </record>\n\n    <!-- Extend tree view -->\n    <record id=\"view_picking_tree_inherit\" model=\"ir.ui.view\">\n        <field name=\"name\">stock.picking.tree.inherit</field>\n        <field name=\"model\">stock.picking</field>\n        <field name=\"inherit_id\" ref=\"stock.view_picking_internal_search\"/>\n        <field name=\"arch\" type=\"xml\">\n            <xpath expr=\"//tree\" position=\"attributes\">\n                <attribute name=\"decoration-danger\">is_urgent</attribute>\n            </xpath>\n            <xpath expr=\"//field[@name='name']\" position=\"after\">\n                <field name=\"serial_number\"/>\n                <field name=\"priority_level\"/>\n                <field name=\"is_urgent\" invisible=\"1\"/>\n            </xpath>\n        </field>\n    </record>\n\n    <!-- Extend search view with filters -->\n    <record id=\"view_picking_search_inherit\" model=\"ir.ui.view\">\n        <field name=\"name\">stock.picking.search.inherit</field>\n        <field name=\"model\">stock.picking</field>\n        <field name=\"inherit_id\" ref=\"stock.view_picking_internal_search\"/>\n        <field name=\"arch\" type=\"xml\">\n            <xpath expr=\"//search\" position=\"inside\">\n                <field name=\"serial_number\"/>\n                <filter string=\"Urgent\" name=\"urgent\" domain=\"[('is_urgent', '=', True)]\"/>\n                <filter string=\"High Priority\" name=\"high_priority\" domain=\"[('priority_level', '=', 'high')]\"/>\n                <group expand=\"0\" string=\"Group By\">\n                    <filter string=\"Priority Level\" name=\"priority\" context=\"{'group_by': 'priority_level'}\"/>\n                </group>\n            </xpath>\n        </field>\n    </record>\n</odoo>\n```\n\n### Pattern 2: Creating Wizards\n\nWizard model (transient):\n\n```python\nfrom odoo import models, fields, api\nfrom odoo.exceptions import UserError\n\n\nclass BulkInvoiceWizard(models.TransientModel):\n    \"\"\"Wizard for bulk invoice generation.\"\"\"\n\n    _name = 'bulk.invoice.wizard'\n    _description = 'Bulk Invoice Generation Wizard'\n\n    partner_id = fields.Many2one(\n        'res.partner',\n        string='Partner',\n        help='Leave empty to process all partners'\n    )\n    date_from = fields.Date(\n        string='Date From',\n        required=True\n    )\n    date_to = fields.Date(\n        string='Date To',\n        required=True\n    )\n    invoice_date = fields.Date(\n        string='Invoice Date',\n        required=True,\n        default=fields.Date.context_today\n    )\n    group_by_partner = fields.Boolean(\n        string='Group by Partner',\n        default=True,\n        help='Create one invoice per partner'\n    )\n\n    @api.constrains('date_from', 'date_to')\n    def _check_dates(self):\n        \"\"\"Validate date range.\"\"\"\n        if self.date_from > self.date_to:\n            raise UserError('Date From must be before Date To!')\n\n    def action_generate_invoices(self):\n        \"\"\"Generate invoices based on wizard parameters.\"\"\"\n        self.ensure_one()\n\n        # Get records to invoice\n        domain = [\n            ('date', '>=', self.date_from),\n            ('date', '<=', self.date_to),\n            ('invoice_status', '=', 'to invoice'),\n        ]\n        if self.partner_id:\n            domain.append(('partner_id', '=', self.partner_id.id))\n\n        orders = self.env['sale.order'].search(domain)\n        if not orders:\n            raise UserError('No orders found matching the criteria!')\n\n        # Group by partner if requested\n        if self.group_by_partner:\n            partners = orders.mapped('partner_id')\n            invoices = self.env['account.move']\n            for partner in partners:\n                partner_orders = orders.filtered(lambda o: o.partner_id == partner)\n                invoice = partner_orders._create_invoices()\n                invoices |= invoice\n        else:\n            invoices = orders._create_invoices()\n\n        # Update invoice dates\n        invoices.write({'invoice_date': self.invoice_date})\n\n        # Return action to view created invoices\n        return {\n            'name': 'Generated Invoices',\n            'type': 'ir.actions.act_window',\n            'res_model': 'account.move',\n            'view_mode': 'tree,form',\n            'domain': [('id', 'in', invoices.ids)],\n            'context': {'create': False},\n        }\n```\n\nWizard view:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<odoo>\n    <record id=\"view_bulk_invoice_wizard_form\" model=\"ir.ui.view\">\n        <field name=\"name\">bulk.invoice.wizard.form</field>\n        <field name=\"model\">bulk.invoice.wizard</field>\n        <field name=\"arch\" type=\"xml\">\n            <form string=\"Generate Bulk Invoices\">\n                <group>\n                    <group>\n                        <field name=\"partner_id\"/>\n                        <field name=\"group_by_partner\"/>\n                    </group>\n                    <group>\n                        <field name=\"date_from\"/>\n                        <field name=\"date_to\"/>\n                        <field name=\"invoice_date\"/>\n                    </group>\n                </group>\n                <footer>\n                    <button string=\"Generate Invoices\" name=\"action_generate_invoices\"\n                            type=\"object\" class=\"btn-primary\"/>\n                    <button string=\"Cancel\" class=\"btn-secondary\" special=\"cancel\"/>\n                </footer>\n            </form>\n        </field>\n    </record>\n\n    <!-- Action to open wizard -->\n    <record id=\"action_bulk_invoice_wizard\" model=\"ir.actions.act_window\">\n        <field name=\"name\">Generate Bulk Invoices</field>\n        <field name=\"res_model\">bulk.invoice.wizard</field>\n        <field name=\"view_mode\">form</field>\n        <field name=\"target\">new</field>\n    </record>\n\n    <!-- Menu item -->\n    <menuitem id=\"menu_bulk_invoice_wizard\"\n              name=\"Generate Bulk Invoices\"\n              parent=\"account.menu_finance\"\n              action=\"action_bulk_invoice_wizard\"\n              sequence=\"100\"/>\n</odoo>\n```\n\nFor more implementation patterns including action buttons, reports (PDF/Excel), and scheduled actions, reference the `references/implementation_patterns.md` file.\n\n## Update Instructions\n\nAfter implementing enhancements:\n\n1. **Update __manifest__.py** - Add new data files and dependencies\n2. **Update security** - Add access rights for new models\n3. **Update module** - Run with `-u module_name`\n4. **Test** - Verify all functionality works\n\n```bash\n# Update module\npython3 /Users/jamshid/PycharmProjects/Siafa/src/odoo-bin \\\n    -c /Users/jamshid/PycharmProjects/Siafa/src/odoo.conf \\\n    -d DATABASE_NAME \\\n    -u module_name\n\n# Run tests if available\npython3 /Users/jamshid/PycharmProjects/Siafa/src/odoo-bin \\\n    -c /Users/jamshid/PycharmProjects/Siafa/src/odoo.conf \\\n    -d DATABASE_NAME \\\n    --test-enable \\\n    --stop-after-init \\\n    -u module_name\n```\n\n## Resources\n\n### references/xpath_patterns.md\nComprehensive collection of XPath expressions for view inheritance - how to add fields before/after elements, replace content, add attributes, etc.\n\n### references/field_types.md\nComplete reference of Odoo field types with examples and common attributes for each type.\n\n### references/implementation_patterns.md\nAdditional implementation patterns for action buttons, PDF reports, Excel reports, and scheduled actions (cron jobs).\n",
        "plugins/odoo-dev/skills/odoo-feature-enhancer/references/api_reference.md": "# Reference Documentation for Odoo Feature Enhancer\n\nThis is a placeholder for detailed reference documentation.\nReplace with actual reference content or delete if not needed.\n\nExample real reference docs from other skills:\n- product-management/references/communication.md - Comprehensive guide for status updates\n- product-management/references/context_building.md - Deep-dive on gathering context\n- bigquery/references/ - API references and query examples\n\n## When Reference Docs Are Useful\n\nReference docs are ideal for:\n- Comprehensive API documentation\n- Detailed workflow guides\n- Complex multi-step processes\n- Information too lengthy for main SKILL.md\n- Content that's only needed for specific use cases\n\n## Structure Suggestions\n\n### API Reference Example\n- Overview\n- Authentication\n- Endpoints with examples\n- Error codes\n- Rate limits\n\n### Workflow Guide Example\n- Prerequisites\n- Step-by-step instructions\n- Common patterns\n- Troubleshooting\n- Best practices\n",
        "plugins/odoo-dev/skills/odoo-feature-enhancer/references/field_types.md": "# Odoo Field Types Reference\n\n## Basic Field Types\n\n### Char - String field\n```python\nname = fields.Char(string='Name', required=True, size=128, index=True)\n```\n\n### Text - Multi-line text\n```python\ndescription = fields.Text(string='Description')\n```\n\n### Integer\n```python\nquantity = fields.Integer(string='Quantity', default=1)\n```\n\n### Float\n```python\nprice = fields.Float(string='Price', digits=(10, 2))\n```\n\n### Boolean\n```python\nactive = fields.Boolean(string='Active', default=True)\n```\n\n### Selection\n```python\nstate = fields.Selection([\n    ('draft', 'Draft'),\n    ('done', 'Done'),\n], string='Status', default='draft')\n```\n\n### Date / Datetime\n```python\ndate = fields.Date(string='Date', default=fields.Date.context_today)\ndatetime = fields.Datetime(string='DateTime', default=fields.Datetime.now)\n```\n\n### Monetary\n```python\namount = fields.Monetary(string='Amount', currency_field='currency_id')\ncurrency_id = fields.Many2one('res.currency')\n```\n\n## Relational Fields\n\n### Many2one - Foreign key\n```python\npartner_id = fields.Many2one('res.partner', string='Partner', ondelete='cascade')\n```\n\n### One2many - Reverse relationship\n```python\nline_ids = fields.One2many('model.line', 'parent_id', string='Lines')\n```\n\n### Many2many\n```python\ntag_ids = fields.Many2many('model.tag', string='Tags')\n```\n\n### Related Field\n```python\npartner_email = fields.Char(related='partner_id.email', string='Email', store=True, readonly=True)\n```\n\n## Computed Fields\n\n```python\ntotal = fields.Float(compute='_compute_total', store=True)\n\n@api.depends('line_ids.amount')\ndef _compute_total(self):\n    for record in self:\n        record.total = sum(record.line_ids.mapped('amount'))\n```\n",
        "plugins/odoo-dev/skills/odoo-feature-enhancer/references/implementation_patterns.md": "# Additional Implementation Patterns\n\n## Action Buttons\n\n```python\ndef action_custom(self):\n    self.ensure_one()\n    # Logic here\n    return {\n        'type': 'ir.actions.client',\n        'tag': 'display_notification',\n        'params': {\n            'title': 'Success',\n            'message': 'Action completed',\n            'type': 'success',\n        }\n    }\n```\n\n## PDF Reports (QWeb)\n\n```python\nclass CustomReport(models.AbstractModel):\n    _name = 'report.module.report_name'\n    \n    @api.model\n    def _get_report_values(self, docids, data=None):\n        docs = self.env['model.name'].browse(docids)\n        return {\n            'doc_ids': docids,\n            'docs': docs,\n            'custom_data': self._prepare_data(docs),\n        }\n```\n\n## Excel Reports\n\n```python\nfrom odoo import models\n\nclass ExcelReport(models.AbstractModel):\n    _name = 'report.module.report_xlsx'\n    _inherit = 'report.report_xlsx.abstract'\n    \n    def generate_xlsx_report(self, workbook, data, objects):\n        sheet = workbook.add_worksheet('Report')\n        header_format = workbook.add_format({'bold': True})\n        \n        sheet.write(0, 0, 'Header 1', header_format)\n        # Add data rows\n```\n\n## Scheduled Actions (Cron)\n\n```xml\n<record id=\"ir_cron_task\" model=\"ir.cron\">\n    <field name=\"name\">Task Name</field>\n    <field name=\"model_id\" ref=\"model_model_name\"/>\n    <field name=\"state\">code</field>\n    <field name=\"code\">model._cron_method()</field>\n    <field name=\"interval_number\">1</field>\n    <field name=\"interval_type\">days</field>\n</record>\n```\n",
        "plugins/odoo-dev/skills/odoo-feature-enhancer/references/xpath_patterns.md": "# XPath Patterns for Odoo View Inheritance\n\n## Common XPath Positions\n\n- `before` - Insert before the target element\n- `after` - Insert after the target element\n- `inside` - Insert inside the target element (as last child)\n- `replace` - Replace the target element entirely\n- `attributes` - Add/modify attributes of the target element\n\n## Examples\n\n### Add Field After Another Field\n```xml\n<xpath expr=\"//field[@name='partner_id']\" position=\"after\">\n    <field name=\"new_field\"/>\n</xpath>\n```\n\n### Add Field Inside Group\n```xml\n<xpath expr=\"//group[@name='group_name']\" position=\"inside\">\n    <field name=\"new_field\"/>\n</xpath>\n```\n\n### Replace Field\n```xml\n<xpath expr=\"//field[@name='old_field']\" position=\"replace\">\n    <field name=\"new_field\"/>\n</xpath>\n```\n\n### Add Attributes\n```xml\n<xpath expr=\"//field[@name='field_name']\" position=\"attributes\">\n    <attribute name=\"readonly\">1</attribute>\n    <attribute name=\"required\">1</attribute>\n</xpath>\n```\n\n### Add to Header\n```xml\n<xpath expr=\"//header\" position=\"inside\">\n    <button name=\"action_custom\" string=\"Custom\" type=\"object\"/>\n</xpath>\n```\n\n### Add Notebook Page\n```xml\n<xpath expr=\"//notebook\" position=\"inside\">\n    <page string=\"New Page\">\n        <group>\n            <field name=\"field1\"/>\n        </group>\n    </page>\n</xpath>\n```\n",
        "plugins/odoo-dev/skills/odoo-migration-assistant/SKILL.md": "---\nname: odoo-migration-assistant\ndescription: Helps migrate Odoo modules and customizations between versions, specifically focusing on upgrades to/from Odoo 16.0. This skill should be used when the user requests migration help, such as \"Migrate this module to Odoo 16\" or \"Upgrade from version 15 to 16\" or \"What changed in Odoo 16 for stock valuation?\" or \"Migration guide for this module\".\n---\n\n# Odoo Migration Assistant\n\n## Overview\n\nThis skill provides guidance for migrating Odoo modules between versions, with specialized knowledge of Odoo 16.0 changes, API differences, and upgrade procedures.\n\n## Migration Scenarios\n\n### 1. Upgrade TO Odoo 16.0\nMigrating modules from older versions (14.0, 15.0) to 16.0.\n\n### 2. Upgrade FROM Odoo 16.0\nPreparing modules for future Odoo versions.\n\n### 3. Version Compatibility Check\nDetermining what changes are needed for version compatibility.\n\n## Migration Workflow\n\n### Step 1: Identify Source and Target Versions\n\nAsk for:\n- Current Odoo version\n- Target Odoo version\n- Module name and purpose\n- Dependencies\n\n### Step 2: Assess Changes Required\n\nReview:\n- API changes between versions\n- Deprecated features\n- New required fields or methods\n- View structure changes\n- Dependency updates\n\n### Step 3: Create Migration Plan\n\nProvide step-by-step migration guide.\n\n## Odoo 16.0 Specific Changes\n\n### Key Changes in Odoo 16.0\n\n**1. Python Version**\n- Minimum: Python 3.8\n- Recommended: Python 3.10+\n\n**2. Manifest Changes**\n```python\n# Odoo 15 and earlier\n{\n    'version': '15.0.1.0.0',\n    'depends': ['base', 'stock'],\n    'license': 'LGPL-3',\n}\n\n# Odoo 16.0\n{\n    'version': '16.0.1.0.0',  # Updated version\n    'depends': ['base', 'stock'],\n    'license': 'LGPL-3',\n    # New optional keys\n    'assets': {  # Replaces some XML asset declarations\n        'web.assets_backend': [\n            'module/static/src/**/*',\n        ],\n    },\n}\n```\n\n**3. Stock Valuation Changes**\n```python\n# Odoo 15\nclass StockMove(models.Model):\n    _inherit = 'stock.move'\n\n    def _create_account_move_line(self):\n        # Old method signature\n        pass\n\n# Odoo 16\nclass StockMove(models.Model):\n    _inherit = 'stock.move'\n\n    def _create_account_move_line(self, credit_account_id, debit_account_id, journal_id, qty, description, svl_id, cost):\n        # Updated method signature with more parameters\n        pass\n```\n\n**4. Widget Changes**\n```xml\n<!-- Odoo 15 -->\n<field name=\"amount\" widget=\"monetary\" options=\"{'currency_field': 'currency_id'}\"/>\n\n<!-- Odoo 16 - Same, but some widgets renamed or removed -->\n<field name=\"amount\" widget=\"monetary\" options=\"{'currency_field': 'currency_id'}\"/>\n```\n\n**5. Removed/Deprecated Methods**\n- `_update_average_price()` - Replaced with new accounting methods\n- Some portal methods reorganized\n\n## Migration Patterns\n\n### Pattern 1: Update Manifest\n\n```python\n# Step 1: Update version number\n'version': '16.0.1.0.0',\n\n# Step 2: Check dependencies\n# Ensure all depends modules are compatible with Odoo 16\n\n# Step 3: Update data files if needed\n'data': [\n    'security/ir.model.access.csv',\n    'views/views.xml',\n    # Remove any deprecated files\n],\n\n# Step 4: Move assets if needed\n'assets': {\n    'web.assets_backend': [\n        'module_name/static/src/js/*.js',\n    ],\n},\n```\n\n### Pattern 2: Update Model Fields\n\n```python\n# Check for removed fields in base models\n# Example: If inheriting stock.move, check release notes\n\nclass StockMove(models.Model):\n    _inherit = 'stock.move'\n\n    # Update field definitions if base definition changed\n    custom_field = fields.Char(...)\n\n    # Update method signatures to match new base methods\n    def _action_done(self, cancel_backorder=False):\n        # Match new signature\n        return super()._action_done(cancel_backorder=cancel_backorder)\n```\n\n### Pattern 3: Update Views\n\n```xml\n<!-- Check for removed/renamed view references -->\n<record id=\"view_form\" model=\"ir.ui.view\">\n    <field name=\"inherit_id\" ref=\"stock.view_move_form\"/>\n    <!-- Update XPath if base view structure changed -->\n    <field name=\"arch\" type=\"xml\">\n        <xpath expr=\"//field[@name='product_id']\" position=\"after\">\n            <field name=\"custom_field\"/>\n        </xpath>\n    </field>\n</record>\n```\n\n### Pattern 4: Create Migration Script\n\n```python\n# migrations/16.0.1.0.0/pre-migrate.py\n\ndef migrate(cr, version):\n    \"\"\"Pre-migration script for 16.0.1.0.0\"\"\"\n    # Update data before module upgrade\n    cr.execute(\"\"\"\n        UPDATE model_table\n        SET new_field = old_field\n        WHERE new_field IS NULL\n    \"\"\")\n\n# migrations/16.0.1.0.0/post-migrate.py\n\ndef migrate(cr, version):\n    \"\"\"Post-migration script for 16.0.1.0.0\"\"\"\n    from odoo import api, SUPERUSER_ID\n\n    env = api.Environment(cr, SUPERUSER_ID, {})\n\n    # Recompute fields\n    records = env['model.name'].search([])\n    records._compute_field_name()\n\n    # Clean up old data\n    old_records = env['old.model'].search([])\n    old_records.unlink()\n```\n\n### Pattern 5: Update Tests\n\n```python\n# Update test imports if needed\nfrom odoo.tests import TransactionCase  # Unchanged\n\nclass TestModule(TransactionCase):\n\n    def setUp(self):\n        super().setUp()\n        # Update test data for new field requirements\n\n    def test_feature(self):\n        # Update assertions for new behavior\n        record = self.env['model.name'].create({\n            'name': 'Test',\n            # Add new required fields for Odoo 16\n        })\n        self.assertTrue(record)\n```\n\n## Version-Specific Changes\n\n### Migrating FROM 15.0 TO 16.0\n\n**Major Changes:**\n1. Stock accounting methods updated\n2. Some JavaScript widgets updated\n3. Python 3.10 support added\n4. Minor ORM improvements\n\n**Steps:**\n1. Update `__manifest__.py` version to `16.0.x.x.x`\n2. Test on Odoo 16 test database\n3. Check deprecation warnings\n4. Update any changed method signatures\n5. Test all functionality\n6. Create migration scripts if data changes needed\n\n### Migrating FROM 14.0 TO 16.0\n\n**Major Changes:**\n- All changes from 14→15 plus 15→16\n- Significant OWL (JavaScript framework) changes\n- Python 2 completely removed\n- Many deprecated features removed\n\n**Steps:**\n1. Consider migrating 14→15→16 (two-step migration)\n2. Review all custom JavaScript (major changes)\n3. Update all deprecated API calls\n4. Extensive testing required\n\n## Migration Checklist\n\n- [ ] Update manifest version\n- [ ] Check all dependencies compatible with target version\n- [ ] Review Odoo release notes for target version\n- [ ] Update deprecated method calls\n- [ ] Test views render correctly\n- [ ] Update method signatures if base methods changed\n- [ ] Create migration scripts (pre/post)\n- [ ] Update tests\n- [ ] Test on copy of production database\n- [ ] Check for deprecation warnings in logs\n- [ ] Update documentation\n- [ ] Test all user workflows\n- [ ] Performance test (especially for large datasets)\n- [ ] Backup production before upgrade\n\n## Migration Commands\n\n```bash\n# Create migration script directory\nmkdir -p module_name/migrations/16.0.1.0.0\n\n# Test migration on copy of database\npg_dump production_db > backup.sql\ncreatedb test_migration_db\npsql test_migration_db < backup.sql\n\n# Run Odoo with migration\npython3 src/odoo-bin -c src/odoo.conf \\\n    -d test_migration_db \\\n    -u module_name \\\n    --stop-after-init\n\n# Check logs for errors\ntail -f /var/log/odoo/odoo.log | grep ERROR\n```\n\n## Common Migration Issues\n\n### Issue 1: Missing Field Error\n```\nError: Field 'xyz' does not exist\n```\n**Solution:** Add field to model or remove from views\n\n### Issue 2: Method Signature Changed\n```\nTypeError: method() takes X positional arguments but Y were given\n```\n**Solution:** Update method call to match new signature\n\n### Issue 3: View Inheritance Broken\n```\nError: View inheritance may not use attribute: ...\n```\n**Solution:** Update XPath or view structure\n\n### Issue 4: Dependencies Not Found\n```\nError: Module 'xyz' not found\n```\n**Solution:** Update dependency version or find replacement\n\n## Testing After Migration\n\n```python\n# Run all tests\npython3 src/odoo-bin -c src/odoo.conf \\\n    -d DATABASE_NAME \\\n    --test-enable \\\n    --stop-after-init \\\n    -u module_name\n\n# Check specific functionality\npython3 src/odoo-bin shell -c src/odoo.conf -d DATABASE_NAME\n\n>>> env['model.name'].search([]).read()\n>>> # Test key functionality manually\n```\n\n## Resources\n\n### references/odoo16_changes.md\nComprehensive list of changes introduced in Odoo 16.0 affecting common modules and customizations.\n\n### references/api_changes.md\nDetailed API changes by module (stock, account, sale, etc.) between Odoo versions.\n\n### scripts/migration_template.py\nTemplate for creating migration scripts with common patterns and examples.\n",
        "plugins/odoo-dev/skills/odoo-migration-assistant/references/api_changes.md": "API changes reference\n",
        "plugins/odoo-dev/skills/odoo-migration-assistant/references/odoo16_changes.md": "Odoo 16 changes reference\n",
        "plugins/odoo-dev/skills/odoo-module-creator/SKILL.md": "---\nname: odoo-module-creator\ndescription: Creates complete Odoo 16.0 modules with proper structure, manifests, models, views, and security. This skill should be used when the user requests creation of a new Odoo module, such as \"Create a new module for inventory tracking\" or \"I need a new POS customization module\" or \"Generate module structure for vendor management\".\n---\n\n# Odoo Module Creator\n\n## Overview\n\nThis skill enables creation of complete, production-ready Odoo 16.0 Enterprise modules with proper directory structure, manifest files, models, views, security configurations, and documentation. It follows OCA guidelines and Siafa project standards.\n\n## Module Creation Workflow\n\n### Step 1: Gather Module Requirements\n\nAsk clarifying questions to collect essential information:\n\n1. **Module technical name** (snake_case format, e.g., `stock_batch_tracking`, `pos_custom_receipt`)\n2. **Module display name** (human-readable, e.g., \"Stock Batch Tracking\", \"POS Custom Receipt\")\n3. **Module purpose** (1-2 sentence description of functionality)\n4. **Module category** (select from: Sales, Inventory, Accounting, Point of Sale, Human Resources, Manufacturing, Purchases, Warehouse, Website, etc.)\n5. **Dependencies** (base modules required, e.g., `stock`, `account`, `point_of_sale`)\n6. **Module type** (see Module Types section below)\n7. **Target addon directory** (e.g., `addons-stock`, `addons-pos`, `addons-account`)\n\n### Step 2: Determine Module Type\n\nIdentify which type of module to create based on the purpose:\n\n**A. Simple Model Module** - CRUD operations for a new business entity\n- Creates new models with fields and views\n- Example: Customer feedback tracking, equipment registry\n\n**B. Extension Module** - Extends existing Odoo models\n- Inherits and adds fields/methods to existing models\n- Example: Add serial number tracking to stock.picking\n\n**C. POS Customization** - Point of Sale enhancements\n- Extends POS models, screens, or receipts\n- Example: Custom receipt format, loyalty points integration\n\n**D. Stock/Inventory Enhancement** - Warehouse and inventory features\n- Stock valuation, warehouse operations, batch tracking\n- Example: Inter-warehouse transit, GRN-invoice linking\n\n**E. Accounting Customization** - Financial module extensions\n- Account moves, vendor bills, analytic accounting\n- Example: Multi-dimensional analytics, custom invoicing\n\n**F. Report Module** - Custom reports (PDF, Excel)\n- QWeb templates, data aggregation, export functionality\n- Example: Sales analysis, inventory valuation reports\n\n**G. Integration Module** - External API/service connectors\n- REST API clients, webhooks, data synchronization\n- Example: Beatroute connector, payment gateway integration\n\n**H. Widget/UI Customization** - Frontend enhancements\n- JavaScript widgets, custom views, web controllers\n- Example: Kanban view customizations, dashboard widgets\n\n### Step 3: Generate Module Structure\n\nCreate the complete directory structure with all required files:\n\n```\nmodule_name/\n├── __init__.py\n├── __manifest__.py\n├── models/\n│   ├── __init__.py\n│   └── [model_files].py\n├── views/\n│   ├── [model]_views.xml\n│   └── menu_views.xml\n├── security/\n│   ├── security_groups.xml (if needed)\n│   └── ir.model.access.csv\n├── data/ (optional)\n│   └── data.xml\n├── wizards/ (if needed)\n│   ├── __init__.py\n│   └── [wizard_name].py\n├── report/ (if reports needed)\n│   ├── __init__.py\n│   ├── [report_name].py\n│   └── templates/\n│       └── [report_template].xml\n├── static/\n│   ├── description/\n│   │   ├── icon.png\n│   │   └── index.html\n│   └── src/ (for JS/CSS if needed)\n│       ├── js/\n│       └── css/\n└── tests/ (recommended)\n    ├── __init__.py\n    └── test_[module].py\n```\n\n### Step 4: Generate __manifest__.py\n\nCreate manifest with standard metadata:\n\n```python\n{\n    'name': '[Module Display Name]',\n    'version': '16.0.1.0.0',\n    'category': '[Category]',\n    'summary': '[Brief one-line description]',\n    'description': \"\"\"\n[Detailed multi-line description of module functionality]\n\nKey Features:\n- Feature 1\n- Feature 2\n- Feature 3\n    \"\"\",\n    'author': 'Jamshid K',\n    'website': 'https://siafadates.com',\n    'license': 'LGPL-3',\n    'depends': [\n        'base',\n        # Additional dependencies\n    ],\n    'data': [\n        'security/security_groups.xml',  # Load first\n        'security/ir.model.access.csv',\n        'views/[model]_views.xml',\n        'views/menu_views.xml',\n        'data/data.xml',  # If needed\n        'report/templates/[report].xml',  # If needed\n    ],\n    'assets': {  # If JS/CSS needed\n        'web.assets_backend': [\n            'module_name/static/src/js/*.js',\n            'module_name/static/src/css/*.css',\n        ],\n    },\n    'demo': [],  # Demo data if applicable\n    'installable': True,\n    'auto_install': False,\n    'application': False,  # True for standalone apps\n}\n```\n\n### Step 5: Generate Model Files\n\nCreate model files following Odoo ORM best practices:\n\n```python\nfrom odoo import models, fields, api\nfrom odoo.exceptions import UserError, ValidationError\nimport logging\n\n_logger = logging.getLogger(__name__)\n\n\nclass ModelName(models.Model):\n    \"\"\"Description of the model.\"\"\"\n\n    _name = 'module.model'\n    _description = 'Model Description'\n    _inherit = ['mail.thread', 'mail.activity.mixin']  # If needed\n    _order = 'create_date desc'\n\n    # Fields\n    name = fields.Char(\n        string='Name',\n        required=True,\n        index=True,\n        tracking=True,\n        help='Primary identifier for this record'\n    )\n    active = fields.Boolean(\n        string='Active',\n        default=True,\n        help='If unchecked, this record will be hidden'\n    )\n    state = fields.Selection([\n        ('draft', 'Draft'),\n        ('confirmed', 'Confirmed'),\n        ('done', 'Done'),\n        ('cancel', 'Cancelled'),\n    ], string='Status', default='draft', required=True, tracking=True)\n\n    company_id = fields.Many2one(\n        'res.company',\n        string='Company',\n        required=True,\n        default=lambda self: self.env.company\n    )\n\n    # Relational fields\n    partner_id = fields.Many2one('res.partner', string='Partner')\n    line_ids = fields.One2many('module.model.line', 'parent_id', string='Lines')\n\n    # Computed fields\n    total_amount = fields.Float(\n        string='Total Amount',\n        compute='_compute_total_amount',\n        store=True\n    )\n\n    # Constraints\n    _sql_constraints = [\n        ('name_unique', 'UNIQUE(name, company_id)', 'Name must be unique per company!'),\n    ]\n\n    @api.depends('line_ids', 'line_ids.amount')\n    def _compute_total_amount(self):\n        \"\"\"Compute total amount from lines.\"\"\"\n        for record in self:\n            record.total_amount = sum(record.line_ids.mapped('amount'))\n\n    @api.onchange('partner_id')\n    def _onchange_partner_id(self):\n        \"\"\"Update fields when partner changes.\"\"\"\n        if self.partner_id:\n            # Logic here\n            pass\n\n    @api.constrains('total_amount')\n    def _check_total_amount(self):\n        \"\"\"Validate total amount is positive.\"\"\"\n        for record in self:\n            if record.total_amount < 0:\n                raise ValidationError('Total amount must be positive!')\n\n    def action_confirm(self):\n        \"\"\"Confirm the record.\"\"\"\n        self.ensure_one()\n        if self.state != 'draft':\n            raise UserError('Only draft records can be confirmed!')\n        self.write({'state': 'confirmed'})\n        _logger.info('Record %s confirmed by user %s', self.name, self.env.user.name)\n```\n\n### Step 6: Generate View Files\n\nCreate XML view definitions:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<odoo>\n    <!-- Tree View -->\n    <record id=\"view_model_tree\" model=\"ir.ui.view\">\n        <field name=\"name\">module.model.tree</field>\n        <field name=\"model\">module.model</field>\n        <field name=\"arch\" type=\"xml\">\n            <tree string=\"Model Name\">\n                <field name=\"name\"/>\n                <field name=\"partner_id\"/>\n                <field name=\"state\" decoration-info=\"state == 'draft'\"\n                       decoration-success=\"state == 'done'\"/>\n                <field name=\"total_amount\" sum=\"Total\"/>\n                <field name=\"company_id\" groups=\"base.group_multi_company\"/>\n            </tree>\n        </field>\n    </record>\n\n    <!-- Form View -->\n    <record id=\"view_model_form\" model=\"ir.ui.view\">\n        <field name=\"name\">module.model.form</field>\n        <field name=\"model\">module.model</field>\n        <field name=\"arch\" type=\"xml\">\n            <form string=\"Model Name\">\n                <header>\n                    <button name=\"action_confirm\" string=\"Confirm\" type=\"object\"\n                            class=\"oe_highlight\" states=\"draft\"/>\n                    <field name=\"state\" widget=\"statusbar\"\n                           statusbar_visible=\"draft,confirmed,done\"/>\n                </header>\n                <sheet>\n                    <div class=\"oe_title\">\n                        <h1>\n                            <field name=\"name\" placeholder=\"Name...\"/>\n                        </h1>\n                    </div>\n                    <group>\n                        <group>\n                            <field name=\"partner_id\"/>\n                            <field name=\"company_id\" groups=\"base.group_multi_company\"/>\n                        </group>\n                        <group>\n                            <field name=\"total_amount\"/>\n                            <field name=\"active\"/>\n                        </group>\n                    </group>\n                    <notebook>\n                        <page string=\"Lines\">\n                            <field name=\"line_ids\">\n                                <tree editable=\"bottom\">\n                                    <field name=\"name\"/>\n                                    <field name=\"amount\"/>\n                                </tree>\n                            </field>\n                        </page>\n                    </notebook>\n                </sheet>\n                <div class=\"oe_chatter\">\n                    <field name=\"message_follower_ids\"/>\n                    <field name=\"activity_ids\"/>\n                    <field name=\"message_ids\"/>\n                </div>\n            </form>\n        </field>\n    </record>\n\n    <!-- Search View -->\n    <record id=\"view_model_search\" model=\"ir.ui.view\">\n        <field name=\"name\">module.model.search</field>\n        <field name=\"model\">module.model</field>\n        <field name=\"arch\" type=\"xml\">\n            <search string=\"Search Model\">\n                <field name=\"name\"/>\n                <field name=\"partner_id\"/>\n                <filter string=\"Draft\" name=\"draft\" domain=\"[('state', '=', 'draft')]\"/>\n                <filter string=\"Done\" name=\"done\" domain=\"[('state', '=', 'done')]\"/>\n                <separator/>\n                <filter string=\"Archived\" name=\"inactive\" domain=\"[('active', '=', False)]\"/>\n                <group expand=\"0\" string=\"Group By\">\n                    <filter string=\"Partner\" name=\"partner\" context=\"{'group_by': 'partner_id'}\"/>\n                    <filter string=\"Status\" name=\"state\" context=\"{'group_by': 'state'}\"/>\n                </group>\n            </search>\n        </field>\n    </record>\n\n    <!-- Action -->\n    <record id=\"action_model\" model=\"ir.actions.act_window\">\n        <field name=\"name\">Model Name</field>\n        <field name=\"res_model\">module.model</field>\n        <field name=\"view_mode\">tree,form</field>\n        <field name=\"context\">{}</field>\n        <field name=\"help\" type=\"html\">\n            <p class=\"o_view_nocontent_smiling_face\">\n                Create your first record!\n            </p>\n            <p>\n                Click the create button to add a new record.\n            </p>\n        </field>\n    </record>\n</odoo>\n```\n\n### Step 7: Generate Security Files\n\nCreate security groups (if needed):\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<odoo>\n    <record id=\"module_category\" model=\"ir.module.category\">\n        <field name=\"name\">Module Category</field>\n        <field name=\"sequence\">100</field>\n    </record>\n\n    <record id=\"group_user\" model=\"res.groups\">\n        <field name=\"name\">User</field>\n        <field name=\"category_id\" ref=\"module_category\"/>\n        <field name=\"implied_ids\" eval=\"[(4, ref('base.group_user'))]\"/>\n    </record>\n\n    <record id=\"group_manager\" model=\"res.groups\">\n        <field name=\"name\">Manager</field>\n        <field name=\"category_id\" ref=\"module_category\"/>\n        <field name=\"implied_ids\" eval=\"[(4, ref('group_user'))]\"/>\n    </record>\n</odoo>\n```\n\nCreate access rights CSV:\n\n```csv\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink\naccess_model_user,module.model.user,model_module_model,group_user,1,1,1,0\naccess_model_manager,module.model.manager,model_module_model,group_manager,1,1,1,1\n```\n\n### Step 8: Generate Tests (Recommended)\n\n**Use the `odoo-test-creator` skill** to create comprehensive test suites for the module. The odoo-test-creator skill provides:\n- Test templates for different module types (basic models, constraints, inheritance)\n- Best practices specific to Siafa project standards\n- Solutions to common testing pitfalls (database constraints, HTML fields, permissions)\n- Proper import patterns and setUp methods\n\nTo create tests with the odoo-test-creator skill, simply invoke:\n\n```\nUse the odoo-test-creator skill to create tests for [module_name]\n```\n\nThe skill will:\n1. Analyze the module structure to determine what needs testing\n2. Select appropriate test templates based on module type\n3. Generate comprehensive test methods for CRUD operations, constraints, computed fields, and business logic\n4. Handle database constraints properly (using existing records vs. creating with .sudo())\n5. Apply Siafa-specific patterns and best practices\n\n**Quick Test Example** (if not using the skill):\n\n```python\nfrom odoo.tests.common import TransactionCase\nfrom odoo.exceptions import UserError\n\n\nclass TestModel(TransactionCase):\n    \"\"\"Test cases for module.model\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test data\"\"\"\n        super().setUp()\n\n        self.Model = self.env['module.model']\n\n        # Use existing records when possible\n        self.partner = self.env['res.partner'].search([], limit=1)\n        if not self.partner:\n            self.skipTest(\"No partner available for testing\")\n\n    def test_01_create_model(self):\n        \"\"\"Test creating a model record\"\"\"\n        record = self.Model.create({\n            'name': 'Test Record',\n            'partner_id': self.partner.id,\n        })\n        self.assertTrue(record)\n        self.assertEqual(record.state, 'draft')\n\n    def test_02_constraint_validation(self):\n        \"\"\"Test constraint validation\"\"\"\n        record = self.Model.create({\n            'name': 'Test Record',\n            'partner_id': self.partner.id,\n        })\n        with self.assertRaises(UserError) as context:\n            record.write({'invalid_field': 'invalid_value'})\n\n        self.assertIn('expected error', str(context.exception))\n```\n\n**Important:** For production modules, always use the `odoo-test-creator` skill to ensure comprehensive test coverage and proper handling of Siafa-specific constraints.\n\n\n\n## Code Standards and Best Practices\n\nFollow these standards when generating module code:\n\n1. **Naming Conventions**\n   - Module name: `snake_case` (e.g., `stock_batch_tracking`)\n   - Model name: `module.model` (e.g., `stock.batch.tracking`)\n   - Fields: `snake_case` (e.g., `batch_number`, `expiry_date`)\n   - Methods: `snake_case` with verb prefix (e.g., `action_confirm`, `_compute_total`)\n   - XML IDs: `view_model_type` (e.g., `view_batch_tracking_form`)\n\n2. **Import Order**\n   ```python\n   # Standard library\n   import logging\n   from datetime import datetime\n\n   # Odoo imports\n   from odoo import models, fields, api, _\n   from odoo.exceptions import UserError, ValidationError\n   from odoo.tools import float_compare, float_is_zero\n   ```\n\n3. **Field Attributes**\n   - Always provide `string` parameter\n   - Add `help` text for complex fields\n   - Use `tracking=True` for important fields\n   - Set `index=True` for searchable fields\n   - Include `company_id` for multi-company support\n\n4. **Method Decorators**\n   - Use `@api.depends()` for computed fields\n   - Use `@api.onchange()` for onchange methods\n   - Use `@api.constrains()` for validation\n   - Use `@api.model` for class-level methods\n\n5. **Error Handling**\n   - Use `UserError` for user-facing errors\n   - Use `ValidationError` for constraint violations\n   - Always log important actions with `_logger`\n\n6. **Security**\n   - Always create access rights CSV\n   - Use security groups for sensitive operations\n   - Add record rules if row-level security needed\n   - Test with different user permissions\n\n## Module Type Templates\n\nReference the `assets/templates/` directory for complete templates by module type:\n- `simple_model/` - Basic CRUD module\n- `extension/` - Inheriting existing models\n- `pos_custom/` - POS customizations\n- `stock_enhancement/` - Inventory features\n- `report_module/` - Custom reports\n\n## Resources\n\n### assets/templates/\nContains complete module templates for different module types. Use these as starting points and customize based on specific requirements.\n\n### assets/icon.png\nDefault module icon. Replace with custom icon if needed (PNG, 128x128px recommended).\n\n### assets/index.html\nModule description HTML template for the Apps menu.\n",
        "plugins/odoo-dev/skills/odoo-test-creator/SKILL.md": "---\nname: odoo-test-creator\ndescription: Creates comprehensive test suites for Odoo 16.0 modules following Siafa project standards. This skill should be used when creating tests for Odoo modules, such as \"Create tests for this module\" or \"Generate test cases for stock_location_usage_restriction\" or \"Add unit tests to validate this functionality\". The skill provides test templates, patterns, and best practices specific to Odoo 16.0 Enterprise with knowledge of database constraints and common pitfalls in the Siafa codebase.\n---\n\n# Odoo Test Creator\n\n## Overview\n\nCreate production-ready test suites for Odoo 16.0 Enterprise modules that follow Siafa project standards, handle database constraints properly, and provide comprehensive test coverage.\n\n## When to Use This Skill\n\nUse this skill when:\n- Creating tests for new Odoo modules\n- Adding test coverage to existing modules\n- Validating model logic, constraints, and workflows\n- Testing inherited/extended Odoo models\n- Ensuring compliance with Siafa testing standards\n\n## Test Creation Workflow\n\n### Step 1: Analyze Module Structure\n\nExamine the module to understand what needs testing:\n\n1. **Identify Components to Test:**\n   - Models (new models or inherited models)\n   - Computed fields and @api.depends\n   - Constraints (@api.constrains and _sql_constraints)\n   - Onchange methods (@api.onchange)\n   - Business logic methods\n   - State transitions and workflows\n   - Wizards and transient models\n   - Reports (if applicable)\n\n2. **Review Module Dependencies:**\n   - Check `__manifest__.py` for dependencies\n   - Identify which models from dependencies will be used\n   - Plan to use existing records when possible\n\n3. **Check for Special Requirements:**\n   - Database constraints (NOT NULL, UNIQUE)\n   - Multi-company considerations\n   - Access rights and permissions\n   - Integration points with other modules\n\n### Step 2: Set Up Test File Structure\n\nCreate the test file following Siafa standards:\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom odoo.tests.common import TransactionCase\nfrom odoo.exceptions import UserError, ValidationError\n\n\nclass TestModuleName(TransactionCase):\n    \"\"\"Test cases for module_name functionality.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        super().setUp()\n\n        # Initialize model references\n        self.Model = self.env['model.name']\n\n        # Set up test data (Step 3)\n```\n\n**Critical Import Pattern:**\n- ✅ Use `from odoo.tests.common import TransactionCase`\n- ❌ NOT `from odoo.tests import TransactionCase`\n\n### Step 3: Set Up Test Data\n\nUse the appropriate pattern based on database constraints:\n\n#### Pattern A: Use Existing Records (Preferred)\n\nAvoid database constraint issues by using existing records:\n\n```python\ndef setUp(self):\n    super().setUp()\n\n    self.Model = self.env['model.name']\n\n    # Use existing records from database\n    self.warehouse = self.env['stock.warehouse'].search([], limit=1)\n    if not self.warehouse:\n        self.skipTest(\"No warehouse available for testing\")\n\n    self.product = self.env['product.product'].search([('type', '=', 'product')], limit=1)\n    if not self.product:\n        self.skipTest(\"No storable product available for testing\")\n\n    self.partner = self.env['res.partner'].search([], limit=1)\n    if not self.partner:\n        self.skipTest(\"No partner available for testing\")\n```\n\n**When to use:** For models with complex database constraints (products, partners, companies).\n\n#### Pattern B: Create with .sudo() (When Necessary)\n\nCreate new records when specific test data is required:\n\n```python\ndef setUp(self):\n    super().setUp()\n\n    self.Model = self.env['model.name']\n\n    # Create test data with .sudo() to bypass permissions\n    self.vendor = self.env['res.partner'].sudo().create({\n        'name': 'Test Vendor',\n        'is_company': True,\n        'supplier_rank': 1,\n    })\n\n    self.product = self.env['product.product'].sudo().create({\n        'name': 'Test Product',\n        'type': 'product',\n        'purchase_method': 'receive',\n        'list_price': 100.0,\n        'standard_price': 80.0,\n    })\n```\n\n**When to use:** When specific field values are required for tests or existing records may not have the right attributes.\n\n#### Pattern C: Class-Level Setup (For Shared Data)\n\nUse `setUpClass` for data shared across all test methods:\n\n```python\n@classmethod\ndef setUpClass(cls):\n    \"\"\"Set up test data shared across all test methods.\"\"\"\n    super().setUpClass()\n\n    cls.vendor = cls.env['res.partner'].sudo().create({\n        'name': 'Test Vendor',\n        'is_company': True,\n    })\n```\n\n**When to use:** For immutable test data that doesn't change between tests (saves database operations).\n\n### Step 4: Write Test Methods\n\nCreate test methods following these guidelines:\n\n#### Test Naming Convention\n\n```python\ndef test_01_descriptive_name(self):\n    \"\"\"Test description in docstring.\"\"\"\n    pass\n\ndef test_02_another_scenario(self):\n    \"\"\"Test another scenario.\"\"\"\n    pass\n```\n\n**Numbering:** Use `01`, `02`, etc. to control execution order.\n\n#### Test Coverage Areas\n\nCreate tests for each component identified in Step 1:\n\n**A. CRUD Operations**\n\n```python\ndef test_01_create_record(self):\n    \"\"\"Test creating a new record with valid data.\"\"\"\n    record = self.Model.create({\n        'name': 'Test Record',\n        'partner_id': self.partner.id,\n    })\n\n    self.assertTrue(record)\n    self.assertEqual(record.name, 'Test Record')\n    self.assertEqual(record.state, 'draft')\n\ndef test_02_update_record(self):\n    \"\"\"Test updating an existing record.\"\"\"\n    record = self.Model.create({\n        'name': 'Test Record',\n        'partner_id': self.partner.id,\n    })\n\n    record.write({'name': 'Updated Record'})\n\n    self.assertEqual(record.name, 'Updated Record')\n```\n\n**B. Computed Fields**\n\n```python\ndef test_03_computed_field(self):\n    \"\"\"Test computed field calculation.\"\"\"\n    record = self.Model.create({\n        'name': 'Test Record',\n        'quantity': 10,\n        'unit_price': 5.0,\n    })\n\n    self.assertEqual(record.total_amount, 50.0)\n\n    # Test recomputation on dependency change\n    record.write({'quantity': 20})\n    self.assertEqual(record.total_amount, 100.0)\n```\n\n**C. Constraints**\n\n```python\ndef test_04_constraint_validation(self):\n    \"\"\"Test constraint prevents invalid data.\"\"\"\n    record = self.Model.create({\n        'name': 'Test Record',\n        'partner_id': self.partner.id,\n    })\n\n    with self.assertRaises(ValidationError) as context:\n        record.write({'amount': -10.0})\n\n    self.assertIn('must be positive', str(context.exception).lower())\n```\n\n**D. Onchange Methods**\n\n```python\ndef test_05_onchange_method(self):\n    \"\"\"Test onchange method updates dependent fields.\"\"\"\n    record = self.Model.new({\n        'name': 'Test Record',\n    })\n\n    record.partner_id = self.partner\n    record._onchange_partner_id()\n\n    # Verify onchange updated related fields\n    # self.assertEqual(record.expected_field, expected_value)\n```\n\n**E. State Transitions**\n\n```python\ndef test_06_state_transition(self):\n    \"\"\"Test state transition workflow.\"\"\"\n    record = self.Model.create({\n        'name': 'Test Record',\n        'partner_id': self.partner.id,\n    })\n\n    self.assertEqual(record.state, 'draft')\n\n    record.action_confirm()\n    self.assertEqual(record.state, 'confirmed')\n\n    # Test invalid transition\n    with self.assertRaises(UserError) as context:\n        record.action_confirm()  # Already confirmed\n\n    self.assertIn('Cannot confirm', str(context.exception))\n```\n\n**F. Inheritance/Extension Tests**\n\nFor modules that inherit existing models:\n\n```python\ndef test_07_inherited_method_override(self):\n    \"\"\"Test overridden method applies custom logic.\"\"\"\n    location = self.Location.create({\n        'name': 'Test Location',\n        'usage': 'internal',\n        'location_id': self.parent_location.id,\n    })\n\n    # Create stock move using this location\n    self.StockMove.create({\n        'name': 'Test Move',\n        'product_id': self.product.id,\n        'product_uom_qty': 10,\n        'product_uom': self.product.uom_id.id,\n        'location_id': location.id,\n        'location_dest_id': self.parent_location.id,\n    })\n\n    # Test that custom validation prevents usage change\n    with self.assertRaises(UserError) as context:\n        location.write({'usage': 'inventory'})\n\n    self.assertIn('Cannot change the usage type', str(context.exception))\n```\n\n### Step 5: Handle Common Pitfalls\n\nApply fixes for known issues in the Siafa codebase:\n\n#### Pitfall 1: Database Constraints\n\n**Problem:** Creating products fails with \"null value in column 'sale_line_warn' violates not-null constraint\"\n\n**Solution:** Use existing products:\n```python\nself.product = self.env['product.product'].search([('type', '=', 'product')], limit=1)\n```\n\n#### Pitfall 2: HTML Field Comparisons\n\n**Problem:** HTML fields return `Markup` objects: `Markup('<p>Text</p>') != 'Text'`\n\n**Solution:** Use non-HTML fields or convert to string:\n```python\n# Instead of comment field\nself.assertEqual(record.barcode, 'TEST001')\n\n# Or convert to string\nself.assertIn('expected text', str(record.html_field))\n```\n\n#### Pitfall 3: Permission Errors\n\n**Problem:** Tests fail with access rights errors.\n\n**Solution:** Use `.sudo()` when creating test data:\n```python\nself.partner = self.env['res.partner'].sudo().create({...})\n```\n\n#### Pitfall 4: Incorrect Super() Call\n\n**Problem:** Using old-style `super(ClassName, self).setUp()`\n\n**Solution:** Use modern syntax:\n```python\nsuper().setUp()  # ✅ Correct\n```\n\n### Step 6: Run and Validate Tests\n\nExecute tests and verify results:\n\n```bash\n# Run tests during module update\npython3 src/odoo-bin -c src/odoo.conf -d DATABASE_NAME \\\n    --test-enable --stop-after-init \\\n    -u MODULE_NAME\n\n# Run with verbose output\npython3 src/odoo-bin -c src/odoo.conf -d DATABASE_NAME \\\n    --test-enable --stop-after-init \\\n    --log-level=test \\\n    -u MODULE_NAME\n```\n\n**Expected Output:**\n```\nINFO MODULE_NAME: 0 failed, 0 error(s) of N tests when loading database 'DATABASE_NAME'\n```\n\n**If tests fail:**\n1. Read the full traceback carefully\n2. Check for database constraint violations\n3. Verify test data setup is correct\n4. Ensure imports are correct\n5. Review field types (especially HTML fields)\n\n### Step 7: Document Tests\n\nAdd comprehensive docstrings to each test method:\n\n```python\ndef test_prevent_usage_change_with_moves(self):\n    \"\"\"\n    Test that location usage cannot be changed when moves exist.\n\n    This test verifies that the module prevents changing a location's\n    usage type after it has been used in stock movements, protecting\n    data integrity.\n    \"\"\"\n    # Test implementation\n```\n\n## Resources\n\n### references/test_patterns.md\n\nComprehensive documentation of:\n- Test infrastructure patterns\n- Common setup patterns for different scenarios\n- Database constraint handling strategies\n- Test organization best practices\n- Assertion patterns\n- Complete list of common pitfalls and solutions\n- Running tests with various options\n\nLoad this reference when:\n- Creating complex test scenarios\n- Handling database constraints\n- Troubleshooting test failures\n- Learning Siafa-specific testing patterns\n\n### assets/test_model_basic.py\n\nTemplate for testing basic model operations:\n- CRUD operations (Create, Read, Update, Delete)\n- Computed field testing\n- Onchange method testing\n- Constraint validation\n- State transitions\n- Search operations\n\nUse as starting point for new model tests.\n\n### assets/test_model_constraints.py\n\nTemplate for testing constraints:\n- Python constraints (@api.constrains)\n- SQL constraints (_sql_constraints)\n- Required field validation\n- Domain constraints\n- Dependent field constraints\n- Conditional constraints\n- Cascading constraints\n\nUse when module has complex validation logic.\n\n### assets/test_model_inheritance.py\n\nTemplate for testing model inheritance and extensions:\n- New field validation\n- Overridden method testing\n- Super() call behavior\n- Added constraints\n- Computed field extensions\n- Onchange extensions\n- Backward compatibility\n\nUse when module extends existing Odoo models.\n\n## Best Practices\n\n1. **Always use existing records when possible** to avoid database constraints\n2. **Test both success and failure cases** for comprehensive coverage\n3. **Verify error messages** when testing exceptions\n4. **Use .sudo() for test data creation** to bypass permission issues\n5. **Add descriptive docstrings** to every test method\n6. **Number test methods** for predictable execution order\n7. **Keep tests isolated** - each test should work independently\n8. **Test edge cases** - empty data, maximum values, invalid combinations\n9. **Follow naming conventions** - clear, descriptive test names\n10. **Run tests frequently** during development to catch issues early\n\n## Example: Complete Test File\n\nFor reference, see `/Users/jamshid/PycharmProjects/Siafa/odoo16e_simc/addons-stock/stock_location_usage_restriction/tests/test_stock_location_usage_restriction.py`\n\nThis file demonstrates:\n- Proper imports (`from odoo.tests.common import TransactionCase`)\n- Using existing records (`self.product = self.Product.search(...)`)\n- Comprehensive test coverage (7 test methods)\n- Exception testing with message validation\n- Proper super() call (`super().setUp()`)\n- Avoiding HTML field comparison issues\n",
        "plugins/odoo-dev/skills/odoo-test-creator/references/test_patterns.md": "# Odoo 16.0 Test Patterns and Best Practices\n\nThis document provides comprehensive patterns and best practices for writing tests in Odoo 16.0 Enterprise modules, based on the Siafa project standards.\n\n## Table of Contents\n\n1. [Test Infrastructure](#test-infrastructure)\n2. [Common Setup Patterns](#common-setup-patterns)\n3. [Database Constraints](#database-constraints)\n4. [Test Organization](#test-organization)\n5. [Assertion Patterns](#assertion-patterns)\n6. [Common Pitfalls](#common-pitfalls)\n\n## Test Infrastructure\n\n### Import Statement\n\nAlways use the correct import for `TransactionCase`:\n\n```python\nfrom odoo.tests.common import TransactionCase\nfrom odoo.exceptions import UserError, ValidationError\n```\n\n**Note:** Use `from odoo.tests.common import TransactionCase`, NOT `from odoo.tests import TransactionCase`.\n\n### Base Test Class\n\n```python\nclass TestModuleName(TransactionCase):\n    \"\"\"Test cases for module functionality.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        super().setUp()  # Use super().setUp() not super(ClassName, self).setUp()\n\n        # Initialize models\n        self.Model = self.env['model.name']\n\n        # Set up test data\n        # ...\n```\n\n## Common Setup Patterns\n\n### Using Existing Records\n\n**Preferred Pattern:** Use existing database records when possible to avoid database constraint issues:\n\n```python\ndef setUp(self):\n    super().setUp()\n\n    # Use existing warehouse\n    self.warehouse = self.env['stock.warehouse'].search([], limit=1)\n    if not self.warehouse:\n        self.skipTest(\"No warehouse available for testing\")\n\n    # Use existing product\n    self.product = self.env['product.product'].search([('type', '=', 'product')], limit=1)\n    if not self.product:\n        self.skipTest(\"No storable product available for testing\")\n```\n\n### Creating New Records with .sudo()\n\nWhen creating new records is necessary, use `.sudo()` to bypass access rights and permission issues:\n\n```python\ndef setUp(self):\n    super().setUp()\n\n    # Create vendor\n    self.vendor = self.env['res.partner'].sudo().create({\n        'name': 'Test Vendor',\n        'is_company': True,\n        'supplier_rank': 1,\n    })\n\n    # Create product with minimal required fields\n    self.product = self.env['product.product'].sudo().create({\n        'name': 'Test Product',\n        'type': 'product',\n        'purchase_method': 'receive',\n        'list_price': 100.0,\n        'standard_price': 80.0,\n    })\n```\n\n### Class-Level Setup\n\nFor test data shared across all test methods, use `setUpClass`:\n\n```python\n@classmethod\ndef setUpClass(cls):\n    \"\"\"Set up test data shared across all test methods.\"\"\"\n    super().setUpClass()\n\n    # Create shared test data\n    cls.vendor = cls.env['res.partner'].sudo().create({\n        'name': 'Test Vendor',\n        'is_company': True,\n    })\n```\n\n## Database Constraints\n\n### Handling NOT NULL Constraints\n\nMany databases have custom NOT NULL constraints. Avoid creating records that trigger these constraints:\n\n**Problem:** Creating a product might fail due to missing `sale_line_warn` field:\n```python\n# ❌ May fail with \"null value in column 'sale_line_warn' violates not-null constraint\"\nself.product = self.env['product.product'].create({\n    'name': 'Test Product',\n    'type': 'product',\n})\n```\n\n**Solution 1:** Use existing records:\n```python\n# ✅ Use existing product from database\nself.product = self.env['product.product'].search([('type', '=', 'product')], limit=1)\n```\n\n**Solution 2:** Provide all required fields (if known):\n```python\n# ✅ Provide the required field\nself.product = self.env['product.product'].sudo().create({\n    'name': 'Test Product',\n    'type': 'product',\n    'sale_line_warn': 'no-message',  # Required in some databases\n})\n```\n\n### HTML/Markup Fields\n\nHTML fields return `Markup` objects, not plain strings:\n\n```python\n# ❌ Fails: Markup('<p>Text</p>') != 'Text'\nself.assertEqual(record.comment, 'Updated comment')\n\n# ✅ Use a different field for testing\nself.assertEqual(record.barcode, 'TEST002')\n\n# ✅ Or convert to string\nself.assertIn('Updated comment', str(record.comment))\n```\n\n## Test Organization\n\n### Test Method Naming\n\nUse descriptive names with numbering for execution order:\n\n```python\ndef test_01_create_record(self):\n    \"\"\"Test creating a new record.\"\"\"\n    pass\n\ndef test_02_update_record(self):\n    \"\"\"Test updating an existing record.\"\"\"\n    pass\n\ndef test_03_validation_error(self):\n    \"\"\"Test that validation error is raised for invalid data.\"\"\"\n    pass\n```\n\n### Test Coverage Areas\n\nComprehensive tests should cover:\n\n1. **CRUD Operations**\n   - Create records with valid data\n   - Update records\n   - Read/search records\n   - Delete records (if applicable)\n\n2. **Validation Logic**\n   - Test constraints\n   - Test computed fields\n   - Test onchange methods\n\n3. **Business Logic**\n   - Test state transitions\n   - Test workflow methods\n   - Test custom methods\n\n4. **Edge Cases**\n   - Test with empty data\n   - Test with maximum values\n   - Test with invalid combinations\n\n5. **Error Handling**\n   - Test that appropriate errors are raised\n   - Test error messages are clear\n\n## Assertion Patterns\n\n### Basic Assertions\n\n```python\n# Equality\nself.assertEqual(record.field, expected_value)\nself.assertNotEqual(record.field, unexpected_value)\n\n# Boolean\nself.assertTrue(record.active)\nself.assertFalse(record.archived)\n\n# Containment\nself.assertIn(item, collection)\nself.assertNotIn(item, collection)\n\n# String matching\nself.assertIn('substring', record.message)\n```\n\n### Exception Testing\n\n```python\n# Test that exception is raised\nwith self.assertRaises(UserError) as context:\n    record.forbidden_action()\n\n# Check exception message\nself.assertIn('Cannot perform action', str(context.exception))\n```\n\n### Recordset Assertions\n\n```python\n# Check recordset size\nself.assertEqual(len(records), 3)\n\n# Check recordset is empty\nself.assertFalse(records)\n\n# Check record exists\nself.assertTrue(record)\nself.assertTrue(record.exists())\n```\n\n### Computed Field Testing\n\n```python\n# Test computed field\nself.assertEqual(record.total_amount, 100.0)\n\n# Test compute dependency\nrecord.line_ids = [(5, 0, 0)]  # Clear lines\nself.assertEqual(record.total_amount, 0.0)\n```\n\n## Common Pitfalls\n\n### 1. Product Creation Failures\n\n**Issue:** Creating products fails due to database constraints.\n\n**Solution:** Use existing products or create with `.sudo()` and minimal fields:\n```python\nself.product = self.env['product.product'].search([('type', '=', 'product')], limit=1)\n```\n\n### 2. Incorrect Import Statement\n\n**Issue:** `from odoo.tests import TransactionCase` causes import errors.\n\n**Solution:** Use `from odoo.tests.common import TransactionCase`\n\n### 3. Super() Call Format\n\n**Issue:** Using old-style super() calls.\n\n**Solution:** Use `super().setUp()` instead of `super(ClassName, self).setUp()`\n\n### 4. Missing .sudo()\n\n**Issue:** Tests fail due to access rights.\n\n**Solution:** Use `.sudo()` when creating test data:\n```python\nself.partner = self.env['res.partner'].sudo().create({...})\n```\n\n### 5. HTML Field Comparisons\n\n**Issue:** Comparing HTML fields directly fails.\n\n**Solution:** Use non-HTML fields or convert to string:\n```python\n# Instead of comment field, use barcode or another text field\nself.assertEqual(record.barcode, 'TEST001')\n```\n\n### 6. Transaction Isolation\n\n**Issue:** Tests affect each other due to shared data.\n\n**Solution:** Each test method runs in its own transaction (automatic with `TransactionCase`)\n\n### 7. Insufficient Error Checking\n\n**Issue:** Not verifying error messages.\n\n**Solution:** Always check exception messages:\n```python\nwith self.assertRaises(UserError) as context:\n    record.action()\nself.assertIn('expected error message', str(context.exception))\n```\n\n### 8. Missing Test Documentation\n\n**Issue:** Tests without docstrings are hard to understand.\n\n**Solution:** Always add descriptive docstrings:\n```python\ndef test_prevent_usage_change_with_moves(self):\n    \"\"\"Test that usage cannot be changed when location has stock moves.\"\"\"\n    # ...\n```\n\n## Running Tests\n\n### Command Patterns\n\n```bash\n# Run tests during module installation\npython3 src/odoo-bin -c src/odoo.conf -d DATABASE_NAME \\\n    --test-enable --stop-after-init \\\n    -i MODULE_NAME\n\n# Run tests during module update\npython3 src/odoo-bin -c src/odoo.conf -d DATABASE_NAME \\\n    --test-enable --stop-after-init \\\n    -u MODULE_NAME\n\n# Run with verbose output\npython3 src/odoo-bin -c src/odoo.conf -d DATABASE_NAME \\\n    --test-enable --stop-after-init \\\n    --log-level=test \\\n    -u MODULE_NAME\n```\n\n### Test Tags\n\nTag tests for selective execution:\n\n```python\nfrom odoo.tests import TransactionCase, tagged\n\n@tagged('post_install', '-at_install', 'module_name')\nclass TestModuleName(TransactionCase):\n    \"\"\"Test cases with tags.\"\"\"\n    pass\n```\n\nRun tagged tests:\n```bash\npython3 src/odoo-bin -c src/odoo.conf -d DATABASE_NAME \\\n    --test-enable --stop-after-init \\\n    --test-tags module_name\n```\n",
        "plugins/odoo-pwa-generator/.claude-plugin/plugin.json": "{\n  \"name\": \"odoo-pwa-generator\",\n  \"description\": \"Generate offline-first Progressive Web Apps with Odoo Studio backend integration. Supports SvelteKit, React, and Vue with smart caching, IndexedDB storage, and automatic sync.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"Jamshid\",\n    \"url\": \"https://github.com/jamshu\"\n  },\n  \"keywords\": [\n    \"odoo\",\n    \"pwa\",\n    \"offline\",\n    \"sveltekit\",\n    \"react\",\n    \"vue\",\n    \"indexeddb\",\n    \"erp\",\n    \"odoo-studio\"\n  ],\n  \"license\": \"MIT\"\n}\n",
        "plugins/odoo-pwa-generator/README.md": "# Odoo PWA Generator\n\nA Claude Code plugin for generating offline-first Progressive Web Apps with Odoo Studio backend integration.\n\n## 🚀 Features\n\n- **Quick Project Generation**: Create complete PWA projects in minutes\n- **Offline-First Architecture**: Smart caching with localStorage and IndexedDB\n- **Auto-Sync**: Background synchronization with Odoo every 3 minutes\n- **Multi-Framework**: Support for SvelteKit, React, and Vue (SvelteKit primary)\n- **PWA-Ready**: Service workers, manifest, and installable apps\n- **Production-Ready**: Deployment configs for Vercel, GitHub Pages, Cloudflare\n\n## 📦 Installation\n\n### For Claude Code CLI\n\n```bash\n# Clone this repository\ngit clone https://github.com/jamshid/odoo-pwa-generator.git\n\n# Link as a local plugin (for development)\ncd odoo-pwa-generator\n\n# Or install from marketplace (when published)\nclaude plugin install odoo-pwa-generator\n```\n\n## 🎯 Skills Included\n\n### 1. **create-odoo-pwa**\nGenerate a complete Odoo-backed PWA project from scratch.\n\n**Usage**:\n```\n\"Create an offline-first PWA for inventory management with Odoo backend\"\n\"Generate a new Odoo PWA for expense tracking using SvelteKit\"\n```\n\n### 2. **add-odoo-model**\nAdd integration for additional Odoo models to existing projects.\n\n**Usage**:\n```\n\"Add a new model for tasks to my Odoo PWA\"\n\"Integrate product catalog model\"\n```\n\n### 3. **create-cache-store**\nGenerate cache stores for offline data management.\n\n**Usage**:\n```\n\"Create a cache store for categories\"\n```\n\n## 🛠️ Quick Start\n\n### Generate a New Project\n\nTalk to Claude naturally:\n\n```\n\"I want to create an offline PWA for tracking expenses with Odoo Studio backend.\nUse SvelteKit and deploy to Vercel.\"\n```\n\nClaude will invoke the `create-odoo-pwa` skill and ask for:\n- Project name (e.g., \"expense-tracker\")\n- Primary Odoo model name (e.g., \"expense\")\n- Model display name (e.g., \"Expense\")\n- Deployment target (e.g., \"vercel\")\n\n### Add a Model to Existing Project\n\n```\n\"Add a category model to track expense categories\"\n```\n\nClaude will invoke `add-odoo-model` and generate:\n- Cache store for categories\n- Form and list pages\n- API integration\n- Navigation updates\n\n## 📁 Generated Project Structure\n\n```\nmy-odoo-pwa/\n├── src/\n│   ├── lib/\n│   │   ├── odoo.js              # Odoo API client\n│   │   ├── db.js                # IndexedDB manager\n│   │   ├── utils.js             # Utilities\n│   │   └── stores/\n│   │       └── cache.js         # Smart cache store\n│   ├── routes/\n│   │   ├── +layout.svelte       # Root layout\n│   │   ├── +layout.js           # SSR/CSR config\n│   │   ├── +page.svelte         # Add form\n│   │   ├── list/+page.svelte    # List view\n│   │   └── api/odoo/+server.js  # Server proxy\n│   └── app.html                 # HTML template\n├── static/\n│   ├── manifest.json            # PWA manifest\n│   ├── icon-192.png             # App icon\n│   └── icon-512.png             # App icon\n├── .env.example                 # Environment template\n├── svelte.config.js             # SvelteKit config\n├── vite.config.js               # Vite + PWA config\n├── package.json                 # Dependencies\n├── README.md                    # User guide\n└── CLAUDE.md                    # Architecture docs\n```\n\n## 🏗️ Architecture\n\n### Three-Layer Data Flow\n\n```\nFrontend Component (Svelte/React/Vue)\n    ↓\nCache Store (Framework Store)\n    ↓\nAPI Client (Frontend)\n    ↓\nServer Route (/api/odoo)\n    ↓\nOdoo JSON-RPC Backend\n```\n\n### Key Patterns\n\n1. **Smart Caching**: Load from cache instantly, sync in background if stale\n2. **Incremental Sync**: Only fetch records with `id > lastRecordId`\n3. **Optimistic Updates**: Update UI immediately, sync to server in background\n4. **Offline Queue**: Save changes locally when offline, sync when online\n\n## 🔧 Odoo Setup Requirements\n\n### Create Odoo Studio Model\n\n1. Log into Odoo instance\n2. Navigate to Studio\n3. Create new model with `x_` prefix (e.g., `x_expense`)\n4. Add fields with `x_studio_` prefix\n\n### Get API Credentials\n\n1. Settings → Users & Companies → Users\n2. Select your user\n3. Generate API Key\n4. Use in `.env` file\n\n## 📝 Example Usage\n\n### Expense Tracking App\n\n```\nUser: \"Create a PWA for splitting expenses with roommates using Odoo\"\n\nClaude:\n1. Asks for:\n   - Project name: \"expense-split\"\n   - Model name: \"expense\"\n   - Display name: \"Expense\"\n   - Deployment: \"vercel\"\n\n2. Generates complete project with:\n   - Expense form with offline support\n   - List view with search/filter\n   - Smart caching for instant load\n   - PWA for mobile install\n   - Vercel deployment config\n```\n\n### Inventory Management\n\n```\nUser: \"Generate an inventory tracker with Odoo backend\"\n\nClaude: Creates \"inventory-tracker\" with:\n- Item management forms\n- Stock level tracking\n- Offline data entry\n- Auto-sync when online\n```\n\n## 🌐 Deployment\n\nGenerated projects include deployment configs for:\n\n- **Vercel**: `vercel.json` + auto-deploy\n- **GitHub Pages**: GitHub Actions workflow\n- **Cloudflare Pages**: `wrangler.toml`\n- **Netlify**: `netlify.toml`\n\nSet environment variables in your deployment platform:\n- `ODOO_URL`\n- `ODOO_DB`\n- `ODOO_USERNAME`\n- `ODOO_API_KEY`\n- `ODOO_PRIMARY_MODEL`\n\n## 📚 Documentation\n\nEach generated project includes:\n\n- **README.md**: Setup and deployment guide\n- **CLAUDE.md**: Architecture documentation for Claude Code\n- **Inline comments**: Detailed code documentation\n\n## 🤝 Contributing\n\nContributions welcome! This plugin is designed to be extended with:\n\n- More framework templates (React, Vue)\n- Additional deployment targets\n- UI component libraries\n- Advanced sync strategies\n\n## 📄 License\n\nMIT\n\n## 🔗 Links\n\n- [Odoo Documentation](https://www.odoo.com/documentation/)\n- [SvelteKit Documentation](https://kit.svelte.dev/)\n- [Claude Code Documentation](https://docs.claude.com/claude-code)\n\n## ⚡ Roadmap\n\n- [ ] React and Vue template support\n- [ ] Visual form builder\n- [ ] Advanced conflict resolution\n- [ ] Real-time sync with Odoo webhooks\n- [ ] Multi-language (i18n) support\n- [ ] Mobile app generation (React Native/Capacitor)\n- [ ] Batch operations\n- [ ] Data export/import utilities\n\n---\n\n**Built with ❤️ for the Odoo and PWA communities**\n\nGenerated projects follow the proven patterns from [expense-split-pwa](https://github.com/jamshid/expense-split-pwa)\n",
        "plugins/odoo-pwa-generator/commands/add-deployment.md": "Add a new deployment target to your existing Odoo PWA project.\n\n## What this command does:\n- Adds deployment configuration for new platforms\n- Creates necessary config files\n- Sets up CI/CD workflows\n- Provides deployment instructions\n- Configures environment variables\n\n## Supported Deployment Targets\n\n### Primary (Recommended)\n- ✅ **Vercel** - Best for full-stack PWAs (API routes work)\n- ✅ **Netlify** - Great for static + serverless functions\n- ✅ **Cloudflare Pages** - Fast global CDN, edge functions\n\n### Secondary (Static Only)\n- ⚠️ **GitHub Pages** - Free, but no server-side code\n- ⚠️ **Cloudflare Pages (Static)** - Without edge functions\n- ⚠️ **AWS S3 + CloudFront** - Static hosting only\n\n---\n\n## Prerequisites\n\nBefore adding deployment:\n\n```\n□ Project builds successfully (npm run build)\n□ Odoo connection tested and working\n□ Environment variables documented\n□ Git repository initialized\n□ Code committed to version control\n```\n\n---\n\n## Add Vercel Deployment 🔷\n\n### What You'll Get:\n- Automatic deployments from Git\n- Serverless API routes\n- Preview deployments for PRs\n- Environment variable management\n- Custom domains\n- Analytics and logs\n\n### Steps:\n\n#### 1. Install Vercel CLI (Optional)\n```bash\nnpm install -g vercel\n```\n\n#### 2. Create `vercel.json`\n```json\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"build\",\n  \"framework\": \"sveltekit\",\n  \"installCommand\": \"npm install\",\n  \"devCommand\": \"npm run dev\",\n  \"env\": {\n    \"VITE_ODOO_URL\": \"@vite_odoo_url\",\n    \"VITE_ODOO_DB\": \"@vite_odoo_db\",\n    \"VITE_MODEL_NAME\": \"@vite_model_name\",\n    \"VITE_MODEL_DISPLAY_NAME\": \"@vite_model_display_name\"\n  },\n  \"build\": {\n    \"env\": {\n      \"ODOO_API_KEY\": \"@odoo_api_key\",\n      \"ODOO_USERNAME\": \"@odoo_username\"\n    }\n  }\n}\n```\n\nFor React/Vue:\n```json\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"dist\",\n  \"framework\": \"vite\"\n}\n```\n\n#### 3. Create `.vercelignore`\n```\nnode_modules\n.env\n.env.local\n*.log\n.DS_Store\n```\n\n#### 4. Deployment Options\n\n**Option A: Vercel Dashboard (Recommended for first time)**\n1. Go to https://vercel.com/new\n2. Connect your Git repository\n3. Vercel auto-detects framework\n4. Add environment variables:\n   - `VITE_ODOO_URL`\n   - `VITE_ODOO_DB`\n   - `ODOO_API_KEY`\n   - `ODOO_USERNAME`\n   - `VITE_MODEL_NAME`\n   - `VITE_MODEL_DISPLAY_NAME`\n5. Click \"Deploy\"\n\n**Option B: Vercel CLI**\n```bash\nvercel login\nvercel\n\n# Follow prompts\n# Add environment variables when asked\n# Or add them later in dashboard\n```\n\n**Option C: Continuous Deployment**\n1. Connect repository to Vercel\n2. Every push to `main` auto-deploys\n3. PRs get preview deployments\n\n#### 5. Configure Environment Variables\nIn Vercel Dashboard:\n1. Go to Project Settings\n2. Environment Variables tab\n3. Add each variable:\n   - Production\n   - Preview (optional)\n   - Development (optional)\n\n#### 6. Test Deployment\n1. Wait for build to complete\n2. Visit deployed URL\n3. Test Odoo connection\n4. Verify all features work\n5. Check browser console for errors\n\n---\n\n## Add Netlify Deployment 🟢\n\n### What You'll Get:\n- Git-based deployments\n- Serverless functions\n- Form handling\n- Split testing\n- Deploy previews\n- Custom domains\n\n### Steps:\n\n#### 1. Create `netlify.toml`\n```toml\n[build]\n  command = \"npm run build\"\n  publish = \"build\"\n\n[build.environment]\n  NODE_VERSION = \"18\"\n\n[[redirects]]\n  from = \"/*\"\n  to = \"/index.html\"\n  status = 200\n\n[functions]\n  directory = \"netlify/functions\"\n```\n\nFor React/Vue:\n```toml\n[build]\n  command = \"npm run build\"\n  publish = \"dist\"\n```\n\n#### 2. Convert API Routes to Netlify Functions\n\nCreate `netlify/functions/odoo.js`:\n```javascript\n// Copy your API route logic here\n// Netlify functions use different format\n\nexports.handler = async (event, context) => {\n  // Parse request\n  const body = JSON.parse(event.body);\n\n  // Your Odoo logic here\n  // (copy from src/routes/api/odoo/+server.js)\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify(result)\n  };\n};\n```\n\n#### 3. Update Client to Use Netlify Function\n```javascript\n// Change API endpoint\nconst response = await fetch('/.netlify/functions/odoo', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(data)\n});\n```\n\n#### 4. Deploy\n\n**Option A: Netlify Dashboard**\n1. Go to https://app.netlify.com/start\n2. Connect repository\n3. Configure build settings\n4. Add environment variables\n5. Deploy\n\n**Option B: Netlify CLI**\n```bash\nnpm install -g netlify-cli\nnetlify login\nnetlify init\nnetlify deploy --prod\n```\n\n---\n\n## Add Cloudflare Pages Deployment 🟠\n\n### What You'll Get:\n- Global CDN\n- Unlimited bandwidth\n- Edge functions\n- Preview deployments\n- Web Analytics\n- Fast performance\n\n### Steps:\n\n#### 1. Create `wrangler.toml` (for edge functions)\n```toml\nname = \"odoo-pwa\"\ncompatibility_date = \"2025-01-01\"\n\n[build]\ncommand = \"npm run build\"\n\n[build.upload]\nformat = \"service-worker\"\n```\n\n#### 2. Convert API Routes to Workers\n\nCreate `functions/odoo.js`:\n```javascript\nexport async function onRequest(context) {\n  const { request, env } = context;\n\n  // Parse request\n  const body = await request.json();\n\n  // Odoo logic here\n  // Access env vars via env.ODOO_API_KEY\n\n  return new Response(JSON.stringify(result), {\n    headers: { 'Content-Type': 'application/json' }\n  });\n}\n```\n\n#### 3. Deploy\n\n**Option A: Cloudflare Dashboard**\n1. Go to Cloudflare Pages\n2. Connect Git repository\n3. Configure build:\n   - Build command: `npm run build`\n   - Output: `build` or `dist`\n4. Add environment variables\n5. Deploy\n\n**Option B: Wrangler CLI**\n```bash\nnpm install -g wrangler\nwrangler login\nwrangler pages project create odoo-pwa\nwrangler pages publish build\n```\n\n---\n\n## Add GitHub Pages Deployment 📘\n\n### ⚠️ Limitations:\n- Static hosting only\n- No server-side API routes\n- Must modify Odoo client for direct API calls\n- CORS issues possible\n\n### When to Use:\n- Demo projects\n- Public apps (no sensitive data)\n- Frontend-only versions\n\n### Steps:\n\n#### 1. Update Base Path\n\n**SvelteKit** (`svelte.config.js`):\n```javascript\nconst config = {\n  kit: {\n    adapter: adapter({\n      pages: 'build',\n      assets: 'build',\n      fallback: 'index.html'\n    }),\n    paths: {\n      base: process.env.NODE_ENV === 'production'\n        ? '/your-repo-name'\n        : ''\n    }\n  }\n};\n```\n\n**React/Vue** (`vite.config.js`):\n```javascript\nexport default {\n  base: '/your-repo-name/'\n};\n```\n\n#### 2. Create `.github/workflows/deploy.yml`\n```yaml\nname: Deploy to GitHub Pages\n\non:\n  push:\n    branches: [main]\n\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n      - run: npm install\n\n      - run: npm run build\n        env:\n          VITE_ODOO_URL: ${{ secrets.VITE_ODOO_URL }}\n          VITE_ODOO_DB: ${{ secrets.VITE_ODOO_DB }}\n          VITE_MODEL_NAME: ${{ secrets.VITE_MODEL_NAME }}\n\n      - uses: actions/upload-pages-artifact@v3\n        with:\n          path: build\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n\n    steps:\n      - uses: actions/deploy-pages@v4\n```\n\n#### 3. Configure Repository\n1. Go to Settings → Pages\n2. Source: GitHub Actions\n3. Save\n\n#### 4. Add Secrets\n1. Settings → Secrets and variables → Actions\n2. Add each environment variable\n\n#### 5. Push to Deploy\n```bash\ngit add .\ngit commit -m \"Add GitHub Pages deployment\"\ngit push origin main\n```\n\n---\n\n## Environment Variables Reference\n\n### Required for All Platforms:\n```bash\n# Public (VITE_ prefix for client access)\nVITE_ODOO_URL=https://yourcompany.odoo.com\nVITE_ODOO_DB=yourcompany-main\nVITE_MODEL_NAME=x_expense\nVITE_MODEL_DISPLAY_NAME=Expense\n\n# Private (server-side only)\nODOO_API_KEY=your_production_api_key\nODOO_USERNAME=your.email@company.com\n```\n\n### Platform-Specific:\n\n**Vercel:**\n- Add in Project Settings → Environment Variables\n- Separate for Production/Preview/Development\n\n**Netlify:**\n- Add in Site Settings → Environment Variables\n- Or in `netlify.toml`\n\n**Cloudflare:**\n- Add in Pages → Settings → Environment Variables\n- Or use Wrangler secrets\n\n**GitHub Pages:**\n- Add in Repository Settings → Secrets\n- Used in GitHub Actions workflow\n\n---\n\n## Post-Deployment Checklist ✅\n\nAfter deploying to new platform:\n\n```\n□ Build completed successfully\n□ Application loads at deployment URL\n□ Odoo connection works\n□ Data syncs correctly\n□ CRUD operations work\n□ Offline mode functions\n□ Service worker registered\n□ PWA installs correctly\n□ Environment variables set correctly\n□ No console errors\n□ Tested on mobile\n□ Custom domain configured (if needed)\n```\n\n---\n\n## Multi-Platform Deployment\n\n### Deploy to Multiple Platforms:\nYou can deploy the same app to multiple platforms for:\n- Redundancy\n- A/B testing\n- Different regions\n- Different audiences\n\n### Example Setup:\n```\nmain branch → Vercel (primary production)\nstaging branch → Netlify (staging)\nPRs → Vercel preview deployments\n```\n\n---\n\n## Troubleshooting Deployment\n\n### Build Fails\n- Check build logs\n- Test `npm run build` locally\n- Verify Node version matches\n- Check for missing env vars\n\n### App Loads but Doesn't Work\n- Check environment variables are set\n- Look at browser console errors\n- Verify API routes deployed correctly\n- Test Odoo connection\n\n### API Routes Not Working\n- Verify platform supports server-side code\n- Check function logs\n- Ensure correct paths used\n- Test API endpoint directly\n\n---\n\n## Example prompts to use this command:\n- `/add-deployment` - Add new deployment target\n- User: \"Deploy to Netlify\"\n- User: \"Add Cloudflare deployment\"\n- User: \"Set up continuous deployment\"\n\n## Related Commands:\n- `/deploy-vercel` - Deploy to Vercel\n- `/deploy-github` - Deploy to GitHub Pages\n- `/test-connection` - Test before deploying\n- `/optimize` - Optimize before production\n\n---\n\n## Best Practices\n\n1. **Use Git-Based Deployment**\n   - Automatic on push\n   - Preview deployments\n   - Easy rollbacks\n\n2. **Separate Environments**\n   - Development\n   - Staging\n   - Production\n\n3. **Secure Secrets**\n   - Never commit API keys\n   - Use platform secret management\n   - Rotate keys regularly\n\n4. **Monitor Deployments**\n   - Set up error tracking\n   - Monitor performance\n   - Watch build times\n\n5. **Test Before Merging**\n   - Use preview deployments\n   - Test all features\n   - Check on real devices\n",
        "plugins/odoo-pwa-generator/commands/add-model.md": "Add integration for a new Odoo Studio model to an existing PWA project.\n\n## What this command does:\n- Invokes the `add-odoo-model` skill\n- Creates cache store for the new model\n- Adds API methods to the Odoo client\n- Generates form and list pages (optional)\n- Updates navigation and routing\n- Maintains consistency with existing project structure\n\n## Required Information:\nBefore starting, gather:\n1. **Current working directory** - Must be inside an existing Odoo PWA project\n2. **Framework** - Detect from project files (SvelteKit/React/Vue)\n3. **New model name** (without `x_` prefix, e.g., \"task\", \"product\")\n4. **Model display name** (human-readable, e.g., \"Task\", \"Product\")\n5. **Generate UI?** - Whether to create form and list pages (yes/no)\n\n## Steps:\n1. Verify the current directory is an Odoo PWA project (check for odoo.js, cache stores)\n2. Detect the framework from project structure\n3. Ask the user for the new model details\n4. Create cache store for the model in `src/lib/stores/` or equivalent\n5. Update the Odoo API client with methods for the new model\n6. If requested, generate form and list pages/components\n7. Update navigation/routing if UI was generated\n8. Update documentation with the new model\n\n## Example prompts to use this command:\n- `/add-model` - Interactive mode, will ask for all parameters\n- User: \"Add a task model to my PWA\"\n- User: \"Integrate product catalog from Odoo\"\n\n## Validation:\nBefore proceeding, check:\n- Project has `src/lib/odoo.js` or equivalent\n- Project has existing cache stores\n- `.env` file exists with Odoo configuration\n- Framework can be detected\n\n## After adding model:\nRemind the user to:\n1. Update `.env` with any new model-specific configuration\n2. Test the new model's CRUD operations\n3. Verify sync functionality works correctly\n4. Update any necessary business logic or calculations\n",
        "plugins/odoo-pwa-generator/commands/api-reference.md": "Complete API reference for the Odoo client and cache stores in generated PWAs.\n\n## What this command does:\n- Provides comprehensive API documentation\n- Lists all available methods and functions\n- Shows parameter types and return values\n- Includes code examples for each method\n- Helps developers use the generated code effectively\n\n---\n\n## Odoo API Client Reference 🔌\n\nThe Odoo API client (`src/lib/odoo.js` or equivalent) provides methods for interacting with Odoo Studio models.\n\n### Configuration\n\n#### Environment Variables\n```bash\nVITE_ODOO_URL=https://yourcompany.odoo.com\nVITE_ODOO_DB=yourcompany-main\nODOO_API_KEY=your_api_key\nODOO_USERNAME=your.email@company.com\nVITE_MODEL_NAME=x_expense\n```\n\n---\n\n## CRUD Operations\n\n### createRecord()\nCreate a new record in Odoo.\n\n**Signature:**\n```javascript\nasync function createRecord(model, fields)\n```\n\n**Parameters:**\n- `model` (string) - Odoo model name (e.g., 'x_expense')\n- `fields` (object) - Field values to set\n\n**Returns:** Promise<number> - ID of created record\n\n**Example:**\n```javascript\nconst newId = await odoo.createRecord('x_expense', {\n  x_studio_description: 'Team lunch',\n  x_studio_amount: 45.50,\n  x_studio_date: '2025-01-15',\n  x_studio_category: 'meal',\n  x_studio_employee: odoo.formatMany2one(12)\n});\n\nconsole.log(`Created expense with ID: ${newId}`);\n```\n\n**Error Handling:**\n```javascript\ntry {\n  const id = await odoo.createRecord('x_expense', fields);\n} catch (error) {\n  console.error('Failed to create:', error.message);\n  // Handle error (show message to user, retry, etc.)\n}\n```\n\n---\n\n### searchRecords()\nSearch and read records from Odoo.\n\n**Signature:**\n```javascript\nasync function searchRecords(model, domain, fields, limit = null, offset = null)\n```\n\n**Parameters:**\n- `model` (string) - Odoo model name\n- `domain` (array) - Odoo domain filter (e.g., [['id', '>', 100]])\n- `fields` (array) - List of field names to fetch\n- `limit` (number, optional) - Maximum number of records\n- `offset` (number, optional) - Number of records to skip\n\n**Returns:** Promise<Array<Object>> - Array of record objects\n\n**Example:**\n```javascript\n// Get all expenses\nconst allExpenses = await odoo.searchRecords(\n  'x_expense',\n  [],\n  ['x_studio_description', 'x_studio_amount', 'x_studio_date']\n);\n\n// Get expenses > $100\nconst largeExpenses = await odoo.searchRecords(\n  'x_expense',\n  [['x_studio_amount', '>', 100]],\n  ['x_studio_description', 'x_studio_amount']\n);\n\n// Get recent 10 expenses\nconst recentExpenses = await odoo.searchRecords(\n  'x_expense',\n  [],\n  ['x_studio_description', 'x_studio_date'],\n  10  // limit\n);\n\n// Get expenses with pagination\nconst page2 = await odoo.searchRecords(\n  'x_expense',\n  [],\n  fields,\n  20,  // limit: 20 per page\n  20   // offset: skip first 20 (page 2)\n);\n```\n\n**Domain Syntax:**\n```javascript\n// Equals\n[['x_studio_status', '=', 'draft']]\n\n// Greater than\n[['x_studio_amount', '>', 100]]\n\n// In list\n[['x_studio_category', 'in', ['meal', 'travel']]]\n\n// Multiple conditions (AND)\n[\n  ['x_studio_amount', '>', 50],\n  ['x_studio_status', '=', 'draft']\n]\n\n// OR conditions\n['|',\n  ['x_studio_amount', '>', 100],\n  ['x_studio_category', '=', 'travel']\n]\n\n// Complex: (amount > 100 OR category = travel) AND status = draft\n['&',\n  '|',\n    ['x_studio_amount', '>', 100],\n    ['x_studio_category', '=', 'travel'],\n  ['x_studio_status', '=', 'draft']\n]\n```\n\n---\n\n### updateRecord()\nUpdate an existing record.\n\n**Signature:**\n```javascript\nasync function updateRecord(model, id, values)\n```\n\n**Parameters:**\n- `model` (string) - Odoo model name\n- `id` (number) - Record ID to update\n- `values` (object) - Fields to update\n\n**Returns:** Promise<boolean> - true if successful\n\n**Example:**\n```javascript\nawait odoo.updateRecord('x_expense', 123, {\n  x_studio_status: 'approved',\n  x_studio_amount: 55.00\n});\n\n// Update multiple fields\nawait odoo.updateRecord('x_expense', 123, {\n  x_studio_description: 'Updated description',\n  x_studio_date: '2025-01-20',\n  x_studio_notes: 'Added receipt'\n});\n```\n\n---\n\n### deleteRecord()\nDelete a record from Odoo.\n\n**Signature:**\n```javascript\nasync function deleteRecord(model, id)\n```\n\n**Parameters:**\n- `model` (string) - Odoo model name\n- `id` (number) - Record ID to delete\n\n**Returns:** Promise<boolean> - true if successful\n\n**Example:**\n```javascript\nawait odoo.deleteRecord('x_expense', 123);\n\n// With confirmation\nif (confirm('Are you sure you want to delete this expense?')) {\n  await odoo.deleteRecord('x_expense', expenseId);\n}\n```\n\n**Error Handling:**\n```javascript\ntry {\n  await odoo.deleteRecord('x_expense', id);\n  console.log('Deleted successfully');\n} catch (error) {\n  console.error('Failed to delete:', error.message);\n  alert('Could not delete: ' + error.message);\n}\n```\n\n---\n\n## Helper Methods\n\n### fetchPartners()\nFetch partner (res.partner) records.\n\n**Signature:**\n```javascript\nasync function fetchPartners(ids = null)\n```\n\n**Parameters:**\n- `ids` (array, optional) - Specific partner IDs to fetch. If null, fetches all.\n\n**Returns:** Promise<Array<Object>> - Array of partner objects\n\n**Example:**\n```javascript\n// Fetch all partners\nconst allPartners = await odoo.fetchPartners();\n\n// Fetch specific partners\nconst somePartners = await odoo.fetchPartners([1, 2, 3]);\n\n// Use in dropdown\nconst partners = await odoo.fetchPartners();\n// Display: partners.map(p => ({ value: p.id, label: p.name }))\n```\n\n---\n\n### formatMany2one()\nFormat a Many2one field value for Odoo.\n\n**Signature:**\n```javascript\nfunction formatMany2one(id)\n```\n\n**Parameters:**\n- `id` (number | null) - Partner/record ID\n\n**Returns:** Array<number, boolean> | false - Odoo-formatted value\n\n**Example:**\n```javascript\n// Set employee field\nconst fields = {\n  x_studio_employee: odoo.formatMany2one(12)\n  // Result: [12, false]\n};\n\n// Clear employee field\nconst fields = {\n  x_studio_employee: odoo.formatMany2one(null)\n  // Result: false\n};\n```\n\n---\n\n### formatMany2many()\nFormat a Many2many field value for Odoo.\n\n**Signature:**\n```javascript\nfunction formatMany2many(ids)\n```\n\n**Parameters:**\n- `ids` (array) - Array of record IDs\n\n**Returns:** Array - Odoo command format\n\n**Example:**\n```javascript\n// Set tags (replace all)\nconst fields = {\n  x_studio_tags: odoo.formatMany2many([1, 2, 3])\n  // Result: [[6, 0, [1, 2, 3]]]\n};\n\n// Clear tags\nconst fields = {\n  x_studio_tags: odoo.formatMany2many([])\n  // Result: [[6, 0, []]]\n};\n```\n\n**Odoo Many2many Commands:**\n```javascript\n// (6, 0, [ids]) - Replace all (what formatMany2many uses)\n// (4, id) - Add link to id\n// (3, id) - Remove link to id\n// (5, 0) - Remove all links\n```\n\n---\n\n## Cache Store API Reference 💾\n\nThe cache store provides reactive state management with offline-first capabilities.\n\n### Properties\n\n#### records\n**Type:** Reactive Array<Object>\n\nCurrent cached records.\n\n**Example:**\n```javascript\n// SvelteKit\n$: totalAmount = $expenseCache.reduce((sum, e) => sum + e.x_studio_amount, 0);\n\n// React\nconst totalAmount = useMemo(() =>\n  records.reduce((sum, e) => sum + e.x_studio_amount, 0),\n  [records]\n);\n\n// Vue\nconst totalAmount = computed(() =>\n  expenseStore.records.reduce((sum, e) => sum + e.x_studio_amount, 0)\n);\n```\n\n#### isLoading\n**Type:** Reactive Boolean\n\nLoading state indicator.\n\n**Example:**\n```javascript\n{#if $expenseCache.isLoading}\n  <LoadingSpinner />\n{:else}\n  <ExpenseList />\n{/if}\n```\n\n#### error\n**Type:** Reactive String | null\n\nCurrent error message, if any.\n\n**Example:**\n```javascript\n{#if $expenseCache.error}\n  <ErrorAlert message={$expenseCache.error} />\n{/if}\n```\n\n#### lastSync\n**Type:** Reactive Number (timestamp)\n\nTimestamp of last successful sync.\n\n**Example:**\n```javascript\nconst timeSinceSync = Date.now() - $expenseCache.lastSync;\nconst minutes = Math.floor(timeSinceSync / 60000);\n// Display: \"Last synced ${minutes} minutes ago\"\n```\n\n---\n\n### Methods\n\n### load()\nLoad records from cache and trigger background sync.\n\n**Signature:**\n```javascript\nasync function load()\n```\n\n**Returns:** Promise<void>\n\n**Behavior:**\n1. Loads from cache immediately (instant UI update)\n2. Checks if cache is stale (> 5 minutes)\n3. If stale, syncs in background\n4. Updates UI when new data arrives\n\n**Example:**\n```javascript\n// SvelteKit\n$effect(() => {\n  expenseCache.load();\n});\n\n// React\nuseEffect(() => {\n  expenseCache.load();\n}, []);\n\n// Vue\nonMounted(() => {\n  expenseStore.load();\n});\n```\n\n---\n\n### create()\nCreate a new record with optimistic update.\n\n**Signature:**\n```javascript\nasync function create(data)\n```\n\n**Parameters:**\n- `data` (object) - Field values for new record\n\n**Returns:** Promise<number> - ID of created record\n\n**Behavior:**\n1. Generates temporary ID\n2. Adds to cache immediately (optimistic)\n3. Creates in Odoo (background)\n4. Replaces temp ID with real ID\n5. Rolls back on error\n\n**Example:**\n```javascript\ntry {\n  const newId = await expenseCache.create({\n    x_studio_description: 'Lunch meeting',\n    x_studio_amount: 45.50,\n    x_studio_date: '2025-01-15',\n    x_studio_category: 'meal'\n  });\n\n  console.log('Created:', newId);\n  navigate(`/expenses/${newId}`);\n} catch (error) {\n  alert('Failed to create: ' + error.message);\n}\n```\n\n---\n\n### update()\nUpdate an existing record.\n\n**Signature:**\n```javascript\nasync function update(id, data)\n```\n\n**Parameters:**\n- `id` (number) - Record ID\n- `data` (object) - Fields to update\n\n**Returns:** Promise<boolean>\n\n**Behavior:**\n1. Updates cache immediately (optimistic)\n2. Updates in Odoo (background)\n3. Rolls back on error\n\n**Example:**\n```javascript\nawait expenseCache.update(123, {\n  x_studio_amount: 50.00,\n  x_studio_status: 'submitted'\n});\n```\n\n---\n\n### delete()\nDelete a record.\n\n**Signature:**\n```javascript\nasync function remove(id)\n```\n\n**Parameters:**\n- `id` (number) - Record ID to delete\n\n**Returns:** Promise<boolean>\n\n**Behavior:**\n1. Removes from cache immediately\n2. Deletes from Odoo (background)\n3. Restores on error\n\n**Example:**\n```javascript\nif (confirm('Delete this expense?')) {\n  try {\n    await expenseCache.remove(123);\n    navigate('/expenses');\n  } catch (error) {\n    alert('Failed to delete: ' + error.message);\n  }\n}\n```\n\n---\n\n### refresh()\nForce refresh from Odoo.\n\n**Signature:**\n```javascript\nasync function refresh()\n```\n\n**Returns:** Promise<void>\n\n**Behavior:**\n1. Fetches all records from Odoo\n2. Replaces cache\n3. Updates UI\n\n**Example:**\n```javascript\n// Manual refresh button\n<button onclick={() => expenseCache.refresh()}>\n  Refresh\n</button>\n```\n\n---\n\n### clearCache()\nClear all cached data.\n\n**Signature:**\n```javascript\nfunction clearCache()\n```\n\n**Returns:** void\n\n**Behavior:**\n1. Clears localStorage\n2. Clears IndexedDB\n3. Resets records to empty array\n\n**Example:**\n```javascript\n// Logout function\nasync function logout() {\n  expenseCache.clearCache();\n  // Clear other caches\n  navigate('/login');\n}\n```\n\n---\n\n## Advanced Patterns\n\n### Custom Filters\n```javascript\n// Derived store (SvelteKit)\nimport { derived } from 'svelte/store';\n\nexport const draftExpenses = derived(\n  expenseCache,\n  $cache => $cache.filter(e => e.x_studio_status === 'draft')\n);\n\n// Hook (React)\nfunction useDraftExpenses() {\n  const { records } = useExpense();\n  return useMemo(\n    () => records.filter(e => e.x_studio_status === 'draft'),\n    [records]\n  );\n}\n\n// Computed (Vue)\nconst draftExpenses = computed(() =>\n  expenseStore.records.filter(e => e.x_studio_status === 'draft')\n);\n```\n\n### Sorting\n```javascript\nexport const sortedExpenses = derived(\n  expenseCache,\n  $cache => [...$cache].sort((a, b) =>\n    b.x_studio_date.localeCompare(a.x_studio_date)\n  )\n);\n```\n\n### Search\n```javascript\nfunction searchExpenses(query) {\n  return records.filter(e =>\n    e.x_studio_description.toLowerCase().includes(query.toLowerCase())\n  );\n}\n```\n\n### Grouping\n```javascript\nfunction groupByCategory(records) {\n  return records.reduce((groups, record) => {\n    const category = record.x_studio_category;\n    if (!groups[category]) groups[category] = [];\n    groups[category].push(record);\n    return groups;\n  }, {});\n}\n```\n\n### Aggregation\n```javascript\nfunction getTotalByCategory(records) {\n  return records.reduce((totals, record) => {\n    const cat = record.x_studio_category;\n    totals[cat] = (totals[cat] || 0) + record.x_studio_amount;\n    return totals;\n  }, {});\n}\n```\n\n---\n\n## Server Route API Reference 🔐\n\nThe server route (`src/routes/api/odoo/+server.js`) handles Odoo communication.\n\n### Endpoint\n**URL:** `/api/odoo`\n**Method:** POST\n**Content-Type:** application/json\n\n### Request Format\n```json\n{\n  \"action\": \"create|search|update|delete\",\n  \"model\": \"x_expense\",\n  ...parameters\n}\n```\n\n### Actions\n\n#### create\n```json\n{\n  \"action\": \"create\",\n  \"model\": \"x_expense\",\n  \"fields\": {\n    \"x_studio_description\": \"Lunch\",\n    \"x_studio_amount\": 45.50\n  }\n}\n```\n\n**Response:** `{ \"id\": 123 }`\n\n#### search\n```json\n{\n  \"action\": \"search\",\n  \"model\": \"x_expense\",\n  \"domain\": [[\"id\", \">\", 100]],\n  \"fields\": [\"x_studio_description\", \"x_studio_amount\"]\n}\n```\n\n**Response:** `{ \"records\": [...] }`\n\n#### update\n```json\n{\n  \"action\": \"update\",\n  \"model\": \"x_expense\",\n  \"id\": 123,\n  \"values\": {\n    \"x_studio_amount\": 50.00\n  }\n}\n```\n\n**Response:** `{ \"success\": true }`\n\n#### delete\n```json\n{\n  \"action\": \"delete\",\n  \"model\": \"x_expense\",\n  \"id\": 123\n}\n```\n\n**Response:** `{ \"success\": true }`\n\n---\n\n## Example prompts to use this command:\n- `/api-reference` - Show complete API documentation\n- User: \"What methods are available in the Odoo client?\"\n- User: \"How do I use the cache store?\"\n- User: \"Show me API examples\"\n\n## Next Steps:\n- Try the methods in your project\n- Review `/examples` for practical use cases\n- See `/architecture` for design patterns\n- Check `/help` for more information\n",
        "plugins/odoo-pwa-generator/commands/architecture.md": "Detailed explanation of the Odoo PWA architecture, patterns, and design decisions.\n\n## What this command does:\n- Explains the architectural patterns used in generated PWAs\n- Details the data flow and state management\n- Describes the caching strategy\n- Explains offline-first design principles\n- Provides insights into technical decisions\n\n---\n\n## Architecture Overview 🏗️\n\nThe Odoo PWA Generator creates **offline-first Progressive Web Apps** with a **three-layer architecture** that ensures data availability, performance, and seamless Odoo integration.\n\n```\n┌─────────────────────────────────────────┐\n│         UI Layer (Components)           │\n│  - Forms, Lists, Navigation             │\n│  - Framework-specific (Svelte/React/Vue)│\n└──────────────┬──────────────────────────┘\n               │\n               ▼\n┌─────────────────────────────────────────┐\n│      State Layer (Cache Stores)         │\n│  - Smart Caching Logic                  │\n│  - Dual Storage (localStorage +  IndexedDB) │\n│  - Background Sync                      │\n│  - Optimistic Updates                   │\n└──────────────┬──────────────────────────┘\n               │\n               ▼\n┌─────────────────────────────────────────┐\n│       API Layer (Odoo Client)           │\n│  - JSON-RPC Communication               │\n│  - CRUD Operations                      │\n│  - Field Formatting                     │\n└──────────────┬──────────────────────────┘\n               │\n               ▼\n┌─────────────────────────────────────────┐\n│    Server Layer (API Routes)            │\n│  - Credential Management                │\n│  - UID Caching                          │\n│  - Error Handling                       │\n└──────────────┬──────────────────────────┘\n               │\n               ▼\n┌─────────────────────────────────────────┐\n│         Odoo Backend                    │\n│  - Studio Models                        │\n│  - Business Logic                       │\n│  - Data Persistence                     │\n└─────────────────────────────────────────┘\n```\n\n---\n\n## Layer 1: UI Components 🎨\n\n### Purpose:\nPresent data to users and capture user input.\n\n### Responsibilities:\n- Render data from cache stores\n- Handle user interactions\n- Validate form inputs\n- Display loading and error states\n- Provide responsive, mobile-friendly interface\n\n### Framework-Specific Implementation:\n\n#### SvelteKit\n```javascript\n<script>\n  import { expenseCache } from '$lib/stores/expenseCache';\n\n  // Reactive to cache updates\n  $effect(() => {\n    expenseCache.load();\n  });\n</script>\n\n{#each $expenseCache as expense}\n  <ExpenseCard {expense} />\n{/each}\n```\n\n#### React\n```javascript\nimport { useExpense } from './contexts/ExpenseContext';\n\nfunction ExpenseList() {\n  const { records, isLoading } = useExpense();\n\n  useEffect(() => {\n    // Load on mount\n  }, []);\n\n  return records.map(expense => (\n    <ExpenseCard key={expense.id} expense={expense} />\n  ));\n}\n```\n\n#### Vue\n```javascript\n<script setup>\nimport { useExpenseStore } from '@/stores/expenseStore';\n\nconst expenseStore = useExpenseStore();\nexpenseStore.load();\n</script>\n\n<template>\n  <ExpenseCard\n    v-for=\"expense in expenseStore.records\"\n    :key=\"expense.id\"\n    :expense=\"expense\"\n  />\n</template>\n```\n\n### Design Principles:\n- **Reactive by default** - UI updates automatically when data changes\n- **Loading states** - Show skeleton loaders while data fetches\n- **Error boundaries** - Graceful error handling\n- **Optimistic UI** - Show changes immediately, sync in background\n\n---\n\n## Layer 2: Cache Stores (State Management) 💾\n\n### Purpose:\nManage application state with offline-first caching.\n\n### The Smart Caching Pattern:\n\n```javascript\n// Two-phase load strategy\nexport async function load() {\n  // Phase 1: Load from cache (instant)\n  const cached = await loadFromCache();\n  records.set(cached); // UI shows data immediately\n\n  // Phase 2: Check if stale and sync\n  if (isCacheStale()) {\n    await syncInBackground(); // Update in background\n  }\n}\n```\n\n### Dual Storage Strategy:\n\n#### localStorage (Metadata)\nStores lightweight metadata:\n- `lastSyncTime` - When was last successful sync\n- `lastRecordId` - Highest ID fetched so far\n- `version` - Cache schema version\n\n```javascript\nlocalStorage.setItem('expenseCache', JSON.stringify({\n  lastSyncTime: Date.now(),\n  lastRecordId: 123,\n  version: 1\n}));\n```\n\n#### IndexedDB (Master Data)\nStores actual records:\n- All record data\n- Larger storage capacity\n- Async API\n- Structured data\n\n```javascript\nawait db.expenses.bulkPut(records);\n```\n\n### Stale Detection:\n\n```javascript\nfunction isCacheStale() {\n  const cacheData = JSON.parse(localStorage.getItem('expenseCache'));\n  const CACHE_VALIDITY = 5 * 60 * 1000; // 5 minutes\n\n  return !cacheData ||\n         (Date.now() - cacheData.lastSyncTime) > CACHE_VALIDITY;\n}\n```\n\n### Incremental Sync Pattern:\n\n```javascript\n// Only fetch new records, not everything\nasync function syncInBackground() {\n  const { lastRecordId } = getCacheMetadata();\n\n  // Fetch only records with id > lastRecordId\n  const newRecords = await odoo.searchRecords(\n    'x_expense',\n    [['id', '>', lastRecordId]],\n    fields\n  );\n\n  if (newRecords.length > 0) {\n    await appendToCache(newRecords);\n    updateLastRecordId(newRecords[newRecords.length - 1].id);\n  }\n}\n```\n\n### Optimistic Updates:\n\n```javascript\nexport async function create(data) {\n  // 1. Generate temporary ID\n  const tempId = `temp-${Date.now()}`;\n  const tempRecord = { id: tempId, ...data };\n\n  // 2. Update UI immediately\n  records.update(r => [...r, tempRecord]);\n\n  // 3. Create in Odoo (background)\n  try {\n    const realId = await odoo.createRecord('x_expense', data);\n\n    // 4. Replace temp ID with real ID\n    records.update(r =>\n      r.map(rec => rec.id === tempId ? { ...rec, id: realId } : rec)\n    );\n  } catch (error) {\n    // 5. Rollback on error\n    records.update(r => r.filter(rec => rec.id !== tempId));\n    throw error;\n  }\n}\n```\n\n### Background Sync Timer:\n\n```javascript\nlet syncInterval;\n\nexport function startAutoSync() {\n  syncInterval = setInterval(() => {\n    syncInBackground();\n  }, 3 * 60 * 1000); // Every 3 minutes\n}\n\nexport function stopAutoSync() {\n  clearInterval(syncInterval);\n}\n```\n\n### Partner Resolution Pattern:\n\n```javascript\n// Many2one fields return [id, name] or just id\n// Resolve partner names and cache them\n\nasync function resolvePartnerNames(records) {\n  const partnerIds = new Set();\n\n  // Collect all unique partner IDs\n  records.forEach(record => {\n    if (record.x_studio_employee) {\n      if (Array.isArray(record.x_studio_employee)) {\n        partnerIds.add(record.x_studio_employee[0]);\n      } else {\n        partnerIds.add(record.x_studio_employee);\n      }\n    }\n  });\n\n  // Fetch partner names in batch\n  const partners = await odoo.fetchPartners(Array.from(partnerIds));\n  const partnerMap = new Map(partners.map(p => [p.id, p.name]));\n\n  // Cache for future use\n  localStorage.setItem('partnerCache', JSON.stringify(\n    Array.from(partnerMap.entries())\n  ));\n\n  return partnerMap;\n}\n```\n\n---\n\n## Layer 3: API Client (Odoo Communication) 🔌\n\n### Purpose:\nAbstract Odoo API communication with clean, reusable methods.\n\n### JSON-RPC Communication:\n\n```javascript\nasync function jsonRpc(url, params) {\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      jsonrpc: '2.0',\n      method: 'call',\n      params: params,\n      id: Math.random()\n    })\n  });\n\n  const data = await response.json();\n\n  if (data.error) {\n    throw new Error(data.error.message);\n  }\n\n  return data.result;\n}\n```\n\n### CRUD Methods:\n\n#### Create\n```javascript\nexport async function createRecord(model, fields) {\n  return await fetch('/api/odoo', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'create',\n      model,\n      fields\n    })\n  });\n}\n```\n\n#### Read\n```javascript\nexport async function searchRecords(model, domain, fields) {\n  return await fetch('/api/odoo', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'search',\n      model,\n      domain,\n      fields\n    })\n  });\n}\n```\n\n#### Update\n```javascript\nexport async function updateRecord(model, id, values) {\n  return await fetch('/api/odoo', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'update',\n      model,\n      id,\n      values\n    })\n  });\n}\n```\n\n#### Delete\n```javascript\nexport async function deleteRecord(model, id) {\n  return await fetch('/api/odoo', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'delete',\n      model,\n      id\n    })\n  });\n}\n```\n\n### Field Formatting Helpers:\n\n```javascript\n// Many2one: Convert to Odoo format [id, false]\nexport function formatMany2one(id) {\n  return id ? [id, false] : false;\n}\n\n// Many2many: Convert to Odoo command [(6, 0, [ids])]\nexport function formatMany2many(ids) {\n  return ids && ids.length > 0 ? [[6, 0, ids]] : [[6, 0, []]];\n}\n```\n\n---\n\n## Layer 4: Server Routes (API Proxy) 🔐\n\n### Purpose:\nSecurely handle Odoo authentication and proxy requests.\n\n### Why Server-Side?\n1. **Security** - API keys never exposed to client\n2. **CORS** - Bypass cross-origin restrictions\n3. **Caching** - Cache UIDs to reduce auth calls\n4. **Error Handling** - Centralized error management\n\n### UID Caching Pattern:\n\n```javascript\nlet cachedUid = null;\n\nasync function authenticate() {\n  if (cachedUid) {\n    return cachedUid;\n  }\n\n  // Authenticate with Odoo\n  cachedUid = await odooClient.authenticate(\n    db, username, apiKey\n  );\n\n  return cachedUid;\n}\n```\n\n### Action Routing:\n\n```javascript\nexport async function POST({ request }) {\n  const { action, model, ...params } = await request.json();\n  const uid = await authenticate();\n\n  switch (action) {\n    case 'create':\n      return odooClient.create(model, params.fields);\n    case 'search':\n      return odooClient.searchRead(model, params.domain, params.fields);\n    case 'update':\n      return odooClient.write(model, params.id, params.values);\n    case 'delete':\n      return odooClient.unlink(model, params.id);\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n}\n```\n\n---\n\n## Data Flow Examples 🔄\n\n### Example 1: Loading Data on Page Load\n\n```\n1. User navigates to page\n   ↓\n2. Component calls expenseCache.load()\n   ↓\n3. Cache store loads from localStorage/IndexedDB\n   ↓\n4. UI updates with cached data (instant)\n   ↓\n5. Cache checks if data is stale (> 5 min)\n   ↓\n6. If stale, triggers background sync\n   ↓\n7. API client calls /api/odoo\n   ↓\n8. Server authenticates and calls Odoo\n   ↓\n9. New records returned\n   ↓\n10. Cache updated (localStorage + IndexedDB)\n    ↓\n11. UI reactively updates with new data\n```\n\n### Example 2: Creating a Record\n\n```\n1. User submits form\n   ↓\n2. Component calls expenseCache.create(data)\n   ↓\n3. Cache creates temp record with temp-ID\n   ↓\n4. UI updates immediately (optimistic)\n   ↓\n5. API client calls /api/odoo (background)\n   ↓\n6. Server creates record in Odoo\n   ↓\n7. Real ID returned\n   ↓\n8. Cache replaces temp-ID with real ID\n   ↓\n9. localStorage and IndexedDB updated\n   ↓\n10. UI shows success message\n```\n\n### Example 3: Offline Create → Online Sync\n\n```\n1. User creates record (offline)\n   ↓\n2. Record saved to cache with temp-ID\n   ↓\n3. API call fails (no network)\n   ↓\n4. Record marked as \"pending sync\"\n   ↓\n5. UI shows \"Will sync when online\"\n   ↓\n   [User goes online]\n   ↓\n6. Background sync detects pending records\n   ↓\n7. Retries API call\n   ↓\n8. Success! Real ID received\n   ↓\n9. Cache updated\n   ↓\n10. UI shows \"Synced\" status\n```\n\n---\n\n## Key Design Patterns 🎯\n\n### 1. Offline-First\n- Always load from cache first\n- Sync in background\n- Queue operations when offline\n- Retry on reconnection\n\n### 2. Optimistic UI\n- Update UI immediately\n- Sync with server in background\n- Rollback on error\n- Show pending states\n\n### 3. Incremental Sync\n- Don't re-fetch all data\n- Only fetch new records (id > lastRecordId)\n- Reduces bandwidth\n- Faster sync times\n\n### 4. Dual Storage\n- localStorage for metadata (fast)\n- IndexedDB for data (large)\n- Best of both worlds\n\n### 5. Partner Resolution\n- Batch fetch related records\n- Cache partner names\n- Avoid N+1 queries\n- Display human-readable names\n\n### 6. Reactive State\n- Framework-native reactivity\n- UI updates automatically\n- No manual DOM manipulation\n- Cleaner code\n\n---\n\n## Performance Considerations ⚡\n\n### Initial Load:\n- Cache-first: Instant data display\n- Background sync: Fetch updates without blocking\n- IndexedDB: Fast access to large datasets\n\n### Network Usage:\n- Incremental sync: Only new data\n- Batch operations: Combine requests\n- UID caching: Reduce auth calls\n\n### Memory Usage:\n- Store large data in IndexedDB, not memory\n- Clean up old data periodically\n- Lazy load related data\n\n### Bundle Size:\n- Framework-specific optimizations\n- Tree shaking\n- Code splitting\n- Lazy load routes\n\n---\n\n## Security Patterns 🔒\n\n### Credential Management:\n- API keys in environment variables\n- Server-side authentication\n- Never expose keys to client\n- Rotate keys periodically\n\n### Data Validation:\n- Validate on client (UX)\n- Validate on server (security)\n- Sanitize inputs\n- Check permissions\n\n### Error Handling:\n- Don't expose internal errors to user\n- Log errors securely\n- Graceful degradation\n- User-friendly messages\n\n---\n\n## Example prompts to use this command:\n- `/architecture` - Show architecture details\n- User: \"How does the caching work?\"\n- User: \"Explain the data flow\"\n- User: \"What design patterns are used?\"\n\n## Next Steps:\nAfter understanding the architecture:\n1. Review generated code in your project\n2. Read CLAUDE.md in your project for specific details\n3. Customize patterns for your use case\n4. Optimize for your specific needs\n\nFor more information, see `/help` or `/examples`!\n",
        "plugins/odoo-pwa-generator/commands/clear-cache.md": "Clear all cached data from your Odoo PWA application.\n\n## What this command does:\n- Clears localStorage cache\n- Clears IndexedDB data\n- Clears browser cache\n- Resets service worker cache\n- Forces fresh data fetch from Odoo\n- Provides selective clearing options\n\n## When to Use This Command\n\n### ✅ Good Reasons:\n- Data appears corrupted or inconsistent\n- Testing fresh installation\n- After Odoo schema changes\n- Debugging sync issues\n- After major updates\n- Stuck with old data\n\n### ⚠️ Caution:\n- Clears all offline data\n- May lose unsyncedchanges\n- Requires re-download of all data\n- User will need to be online\n\n---\n\n## Quick Clear Options\n\n### Option 1: Clear from Browser Console (Fastest)\n```javascript\n// Clear localStorage\nlocalStorage.clear();\n\n// Clear and refresh\nlocalStorage.clear();\nlocation.reload();\n```\n\n### Option 2: Clear from Cache Store\n```javascript\n// Using cache store method\nexpenseCache.clearCache();\nexpenseCache.refresh();\n```\n\n### Option 3: Clear from UI\nAdd a button to your app:\n```javascript\n<button onclick={() => {\n  if (confirm('Clear all cached data?')) {\n    expenseCache.clearCache();\n    expenseCache.refresh();\n  }\n}}>\n  Clear Cache\n</button>\n```\n\n---\n\n## Complete Clear Procedure\n\n### Step 1: Prepare\n```\n□ Save any unsaved work\n□ Ensure internet connection\n□ Note current state (for comparison)\n□ Close other tabs with same app\n```\n\n### Step 2: Clear localStorage\n```javascript\n// Clear all\nlocalStorage.clear();\n\n// Or clear specific keys\nlocalStorage.removeItem('expenseCache');\nlocalStorage.removeItem('taskCache');\nlocalStorage.removeItem('partnerCache');\n```\n\n### Step 3: Clear IndexedDB\n```javascript\n// Via DevTools:\n// 1. Open DevTools (F12)\n// 2. Go to Application tab\n// 3. Expand IndexedDB in left sidebar\n// 4. Right-click on database → Delete\n\n// Or programmatically:\nindexedDB.deleteDatabase('odoo-pwa-db');\n```\n\n### Step 4: Clear Service Worker Cache\n```javascript\n// Unregister service worker\nnavigator.serviceWorker.getRegistrations()\n  .then(registrations => {\n    registrations.forEach(reg => reg.unregister());\n  });\n\n// Clear all caches\ncaches.keys()\n  .then(keys => Promise.all(\n    keys.map(key => caches.delete(key))\n  ));\n```\n\n### Step 5: Clear Browser Cache\n```\nChrome/Edge: Ctrl+Shift+Delete → Select cache → Clear\nFirefox: Ctrl+Shift+Delete → Select cache → Clear now\nSafari: Cmd+Option+E\n```\n\n### Step 6: Hard Refresh\n```\nWindows/Linux: Ctrl+Shift+R or Ctrl+F5\nMac: Cmd+Shift+R\n```\n\n### Step 7: Verify\n```javascript\n// Check localStorage is empty\nconsole.log('localStorage size:', localStorage.length);\n\n// Check IndexedDB\n// DevTools → Application → IndexedDB\n// Should be empty or recreated\n\n// Check cache stores\nconsole.log('Records:', $expenseCache.length);\n// Should be 0 or freshly fetched\n```\n\n---\n\n## Selective Clearing\n\n### Clear Only Specific Model Cache\n```javascript\n// Clear just expense cache\nlocalStorage.removeItem('expenseCache');\n\n// Refresh that cache\nexpenseCache.refresh();\n```\n\n### Clear Only Metadata (Keep Records)\n```javascript\n// Get current cache data\nconst cacheData = JSON.parse(localStorage.getItem('expenseCache'));\n\n// Reset only metadata\ncacheData.lastSyncTime = 0;\ncacheData.lastRecordId = 0;\n\n// Save back\nlocalStorage.setItem('expenseCache', JSON.stringify(cacheData));\n\n// Force sync\nexpenseCache.refresh();\n```\n\n### Clear Only Old Records\n```javascript\n// Keep only recent records (last 30 days)\nconst thirtyDaysAgo = new Date();\nthirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\nexpenseCache.records.update(records =>\n  records.filter(r => new Date(r.x_studio_date) > thirtyDaysAgo)\n);\n```\n\n---\n\n## Framework-Specific Clearing\n\n### SvelteKit\n```javascript\n// Clear and reset store\nimport { expenseCache } from '$lib/stores/expenseCache';\n\nexpenseCache.clearCache();\nexpenseCache.load(); // Reload fresh data\n```\n\n### React\n```javascript\n// Using Context\nimport { useExpense } from './contexts/ExpenseContext';\n\nfunction ClearCacheButton() {\n  const { clearCache, refresh } = useExpense();\n\n  return (\n    <button onClick={() => {\n      clearCache();\n      refresh();\n    }}>\n      Clear Cache\n    </button>\n  );\n}\n```\n\n### Vue\n```javascript\n// Using Pinia store\nimport { useExpenseStore } from '@/stores/expenseStore';\n\nconst expenseStore = useExpenseStore();\n\nfunction clearAndRefresh() {\n  expenseStore.clearCache();\n  expenseStore.load();\n}\n```\n\n---\n\n## Advanced Cache Management\n\n### Schedule Automatic Cache Clear\n```javascript\n// Clear cache older than 7 days\nconst CACHE_MAX_AGE = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nfunction checkCacheAge() {\n  const cacheData = JSON.parse(localStorage.getItem('expenseCache'));\n\n  if (cacheData && cacheData.lastSyncTime) {\n    const age = Date.now() - cacheData.lastSyncTime;\n\n    if (age > CACHE_MAX_AGE) {\n      console.log('Cache too old, clearing...');\n      expenseCache.clearCache();\n      expenseCache.refresh();\n    }\n  }\n}\n\n// Check on app load\ncheckCacheAge();\n```\n\n### Clear on Version Change\n```javascript\n// In cache store\nconst CACHE_VERSION = 2; // Increment when schema changes\n\nfunction checkCacheVersion() {\n  const cacheData = JSON.parse(localStorage.getItem('expenseCache'));\n\n  if (!cacheData || cacheData.version !== CACHE_VERSION) {\n    console.log('Cache version mismatch, clearing...');\n    clearCache();\n\n    // Set new version\n    localStorage.setItem('expenseCache', JSON.stringify({\n      version: CACHE_VERSION,\n      lastSyncTime: 0,\n      lastRecordId: 0\n    }));\n  }\n}\n```\n\n### Clear Based on Storage Quota\n```javascript\n// Check storage usage\nif (navigator.storage && navigator.storage.estimate) {\n  navigator.storage.estimate().then(estimate => {\n    const percentUsed = (estimate.usage / estimate.quota) * 100;\n\n    console.log(`Storage: ${percentUsed.toFixed(2)}% used`);\n\n    if (percentUsed > 90) {\n      console.warn('Storage almost full, clearing old cache...');\n      clearOldestRecords();\n    }\n  });\n}\n\nfunction clearOldestRecords() {\n  // Keep only most recent 100 records\n  expenseCache.records.update(records =>\n    records\n      .sort((a, b) => b.id - a.id)\n      .slice(0, 100)\n  );\n}\n```\n\n---\n\n## Cache Verification\n\n### After Clearing, Verify:\n\n#### 1. Storage is Empty\n```javascript\nconsole.log('localStorage keys:', Object.keys(localStorage));\n// Should be [] or minimal\n\nconsole.log('localStorage size:', localStorage.length);\n// Should be 0 or very small\n```\n\n#### 2. IndexedDB is Clear\n```\nDevTools → Application → IndexedDB\n- Check if database exists\n- Check if tables are empty\n```\n\n#### 3. Fresh Data Loads\n```javascript\n// Refresh and watch console\nlocation.reload();\n\n// Should see:\n// \"Cache miss, fetching from Odoo...\"\n// \"Fetched X records\"\n```\n\n#### 4. Functionality Works\n```\n□ Data loads correctly\n□ CRUD operations work\n□ Sync happens\n□ Offline mode works after re-caching\n```\n\n---\n\n## Troubleshooting Clear Issues\n\n### Issue: Cache Won't Clear\n\n**Solution 1: Force with DevTools**\n```\n1. Open DevTools (F12)\n2. Application tab\n3. Clear storage section\n4. Check all boxes\n5. Click \"Clear site data\"\n```\n\n**Solution 2: Use Private/Incognito**\n```\nOpen app in private browsing mode\n- Fresh session, no cache\n- Test functionality\n```\n\n**Solution 3: Different Browser**\n```\nTest in different browser\n- Rules out browser-specific issues\n```\n\n### Issue: Data Reappears After Clear\n\n**Solution: Check Multiple Sources**\n```javascript\n// Clear all possible locations\nlocalStorage.clear();\nsessionStorage.clear();\nindexedDB.deleteDatabase('odoo-pwa-db');\n\n// Unregister service workers\nnavigator.serviceWorker.getRegistrations()\n  .then(regs => regs.forEach(reg => reg.unregister()));\n\n// Clear all caches\ncaches.keys()\n  .then(keys => Promise.all(keys.map(k => caches.delete(k))));\n```\n\n### Issue: App Breaks After Clear\n\n**Solution: Ensure Graceful Degradation**\n```javascript\n// In cache store, handle missing cache\nfunction loadFromCache() {\n  try {\n    const cached = localStorage.getItem('expenseCache');\n\n    if (!cached) {\n      console.log('No cache, will fetch from Odoo');\n      return { records: [], lastRecordId: 0, lastSyncTime: 0 };\n    }\n\n    return JSON.parse(cached);\n  } catch (error) {\n    console.error('Error loading cache:', error);\n    return { records: [], lastRecordId: 0, lastSyncTime: 0 };\n  }\n}\n```\n\n---\n\n## User-Facing Clear Options\n\n### Settings Page Example\n```javascript\n<script>\n  import { expenseCache, taskCache } from '$lib/stores';\n\n  async function clearAll() {\n    if (confirm('Clear all cached data? This cannot be undone.')) {\n      expenseCache.clearCache();\n      taskCache.clearCache();\n\n      alert('Cache cleared! Refreshing...');\n      location.reload();\n    }\n  }\n\n  async function clearExpenses() {\n    if (confirm('Clear expense cache?')) {\n      expenseCache.clearCache();\n      await expenseCache.refresh();\n      alert('Expense cache cleared!');\n    }\n  }\n\n  function getCacheInfo() {\n    const size = new Blob(Object.values(localStorage)).size;\n    const sizeKB = (size / 1024).toFixed(2);\n    return { count: localStorage.length, sizeKB };\n  }\n</script>\n\n<div class=\"settings\">\n  <h2>Cache Management</h2>\n\n  <div class=\"cache-info\">\n    <p>Items: {getCacheInfo().count}</p>\n    <p>Size: {getCacheInfo().sizeKB} KB</p>\n    <p>Last sync: {new Date($expenseCache.lastSync).toLocaleString()}</p>\n  </div>\n\n  <div class=\"actions\">\n    <button on:click={clearExpenses}>Clear Expense Cache</button>\n    <button on:click={clearAll} class=\"danger\">Clear All Cache</button>\n  </div>\n</div>\n\n<style>\n  .danger {\n    background: red;\n    color: white;\n  }\n</style>\n```\n\n---\n\n## Cache Clear Checklist ✅\n\nBefore clearing:\n```\n□ Save any unsaved work\n□ Note current state\n□ Ensure internet connection\n□ Close duplicate tabs\n```\n\nAfter clearing:\n```\n□ localStorage is empty\n□ IndexedDB is cleared\n□ Service worker cache cleared\n□ Fresh data loaded\n□ Functionality tested\n□ Sync works correctly\n□ Offline mode re-enabled (after cache rebuilt)\n```\n\n---\n\n## Best Practices\n\n### 1. Clear Strategically\n- Don't clear unnecessarily\n- Clear only what's needed\n- Keep user data when possible\n\n### 2. Warn Users\n```javascript\nfunction clearCache() {\n  const message = `\n    This will clear all cached data.\n    You'll need to re-download everything from Odoo.\n    Continue?\n  `;\n\n  if (confirm(message)) {\n    // Proceed\n  }\n}\n```\n\n### 3. Provide Progress\n```javascript\nasync function clearAndRefresh() {\n  alert('Clearing cache...');\n\n  localStorage.clear();\n\n  alert('Fetching fresh data...');\n\n  await expenseCache.refresh();\n\n  alert('Done! Cache rebuilt.');\n}\n```\n\n### 4. Log for Debugging\n```javascript\nfunction clearCache() {\n  console.log('Before clear:', {\n    localStorage: localStorage.length,\n    records: $expenseCache.length\n  });\n\n  localStorage.clear();\n  expenseCache.clearCache();\n\n  console.log('After clear:', {\n    localStorage: localStorage.length,\n    records: $expenseCache.length\n  });\n}\n```\n\n### 5. Test Regularly\n- Test cache clear functionality\n- Ensure app works after clear\n- Verify data re-downloads\n- Check offline mode recovers\n\n---\n\n## Example prompts to use this command:\n- `/clear-cache` - Clear all cached data\n- User: \"Clear my cache\"\n- User: \"Data looks wrong, clear everything\"\n- User: \"Reset the app\"\n\n## Related Commands:\n- `/fix-sync` - If sync issues persist\n- `/test-connection` - Test after clearing\n- `/troubleshoot` - For other issues\n- `/help` - Full documentation\n\n---\n\n## Quick Reference\n\n### Clear Everything (Nuclear Option)\n```javascript\n// Copy-paste into console\nlocalStorage.clear();\nsessionStorage.clear();\nindexedDB.databases().then(dbs =>\n  dbs.forEach(db => indexedDB.deleteDatabase(db.name))\n);\nnavigator.serviceWorker.getRegistrations().then(regs =>\n  regs.forEach(reg => reg.unregister())\n);\ncaches.keys().then(keys =>\n  keys.forEach(key => caches.delete(key))\n);\nlocation.reload(true);\n```\n\n### Clear Specific Model\n```javascript\nlocalStorage.removeItem('expenseCache');\nexpenseCache.refresh();\n```\n\n### Reset Metadata Only\n```javascript\nconst cache = JSON.parse(localStorage.getItem('expenseCache'));\ncache.lastSyncTime = 0;\ncache.lastRecordId = 0;\nlocalStorage.setItem('expenseCache', JSON.stringify(cache));\nexpenseCache.refresh();\n```\n",
        "plugins/odoo-pwa-generator/commands/create-cache-store.md": "Create a smart cache store for an Odoo model with offline-first capabilities.\n\n## What this command does:\n- Creates a framework-specific cache store (Svelte store, React Context, or Vue Pinia)\n- Implements dual storage (localStorage + IndexedDB)\n- Adds smart caching with stale detection (5-minute validity)\n- Implements background sync (3-minute intervals)\n- Includes incremental fetching (only new records)\n- Adds partner name resolution and caching\n- Implements optimistic updates\n\n## Required Information:\nBefore starting, gather:\n1. **Current working directory** - Must be inside an Odoo PWA project\n2. **Framework** - Detect from project files (SvelteKit/React/Vue)\n3. **Model name** (without `x_` prefix, e.g., \"expense\", \"task\")\n4. **Model display name** (human-readable, e.g., \"Expense\", \"Task\")\n5. **Fields to fetch** - Array of Odoo fields (e.g., [\"x_studio_name\", \"x_studio_amount\"])\n\n## Store Features:\nThe generated cache store will include:\n- `records` - Reactive array of cached records\n- `isLoading` - Loading state indicator\n- `error` - Error state\n- `lastSync` - Timestamp of last successful sync\n- `load()` - Load from cache and trigger background sync\n- `create(data)` - Create new record with optimistic update\n- `update(id, data)` - Update record with optimistic update\n- `delete(id)` - Delete record with optimistic update\n- `refresh()` - Force refresh from Odoo\n- `clearCache()` - Clear all cached data\n\n## Storage Strategy:\n1. **localStorage**: Stores metadata (lastSyncTime, lastRecordId, version)\n2. **IndexedDB**: Stores master data (all records)\n3. **Stale detection**: Cache considered stale after 5 minutes\n4. **Background sync**: Automatic sync every 3 minutes\n5. **Incremental fetch**: Only fetches records with `id > lastRecordId`\n\n## Steps:\n1. Verify the current directory is an Odoo PWA project\n2. Detect the framework from project structure\n3. Ask the user for model details and fields\n4. Create cache store file in appropriate location:\n   - SvelteKit: `src/lib/stores/{model}Cache.js`\n   - React: `src/contexts/{Model}Context.jsx`\n   - Vue: `src/stores/{model}Store.js`\n5. Import and register the store in the appropriate location\n6. Provide usage examples and documentation\n\n## Example prompts to use this command:\n- `/create-cache-store` - Interactive mode\n- User: \"Create a cache store for the task model\"\n- User: \"Add caching for product catalog\"\n\n## After creation:\nRemind the user to:\n1. Import the store in components that need it\n2. Call the `load()` method when the component mounts\n3. Use reactive data bindings to display records\n4. Test create, update, and delete operations\n5. Verify offline functionality works correctly\n\n## Usage Examples:\n\n### SvelteKit\n```javascript\nimport { taskCache } from '$lib/stores/taskCache';\n\n// In +page.svelte\n$effect(() => {\n  taskCache.load();\n});\n```\n\n### React\n```javascript\nimport { useTask } from './contexts/TaskContext';\n\nconst { records, create, update } = useTask();\n```\n\n### Vue\n```javascript\nimport { useTaskStore } from '@/stores/taskStore';\n\nconst taskStore = useTaskStore();\ntaskStore.load();\n```\n",
        "plugins/odoo-pwa-generator/commands/deploy-github.md": "Deploy your Odoo PWA to GitHub Pages with GitHub Actions for continuous deployment.\n\n## What this command does:\n- Sets up GitHub Actions workflow for automated deployment\n- Configures GitHub Pages in repository settings\n- Sets up repository secrets for environment variables\n- Deploys the application to GitHub Pages\n- Provides custom domain setup instructions\n\n## Prerequisites:\nBefore deploying, verify:\n1. ✅ Project builds successfully locally (`npm run build`)\n2. ✅ Git repository exists and is pushed to GitHub\n3. ✅ User has admin access to the repository\n4. ✅ GitHub Pages is enabled in repository settings\n5. ✅ Base URL configuration is correct for GitHub Pages\n\n## Important: GitHub Pages Limitations\n⚠️ Note: GitHub Pages is static hosting only. Server-side API routes won't work.\n\n**Recommendation**: For full Odoo PWA functionality with server-side API proxy:\n- Use Vercel, Cloudflare Pages, or Netlify instead\n- Or deploy API routes separately (e.g., Vercel Serverless Functions)\n\n## If Continuing with GitHub Pages:\nYou'll need to modify the Odoo client to use CORS-enabled direct Odoo API calls or deploy API routes separately.\n\n## Steps:\n\n### 1. Configure GitHub Repository\n```bash\n# Ensure you're on main branch\ngit checkout main\ngit pull origin main\n```\n\n### 2. Set Up GitHub Actions Workflow\nCheck if `.github/workflows/deploy.yml` exists:\n- If yes: Review and update if needed\n- If no: Create the workflow file\n\n### 3. Configure Repository Secrets\nGo to: Repository → Settings → Secrets and variables → Actions\n\nAdd these secrets:\n```\nODOO_API_KEY=your_production_api_key\nODOO_USERNAME=your.email@company.com\nVITE_ODOO_URL=https://yourcompany.odoo.com\nVITE_ODOO_DB=yourcompany-main\nVITE_MODEL_NAME=x_expense\nVITE_MODEL_DISPLAY_NAME=Expense\n```\n\n### 4. Enable GitHub Pages\nRepository → Settings → Pages:\n- Source: Deploy from a branch\n- Branch: `gh-pages` (will be created by Actions)\n- Folder: `/ (root)`\n\n### 5. Update Base Path\nFor framework-specific configuration:\n\n**SvelteKit** (`svelte.config.js`):\n```javascript\npaths: {\n  base: process.env.NODE_ENV === 'production' ? '/your-repo-name' : ''\n}\n```\n\n**React/Vue** (`vite.config.js`):\n```javascript\nbase: process.env.NODE_ENV === 'production' ? '/your-repo-name/' : '/'\n```\n\n### 6. Commit and Push\n```bash\ngit add .\ngit commit -m \"Configure GitHub Pages deployment\"\ngit push origin main\n```\n\n### 7. Monitor Deployment\n- Go to Actions tab in GitHub\n- Watch the deployment workflow\n- Check for any errors\n\n## GitHub Actions Workflow\nThe workflow should:\n1. Trigger on push to `main` branch\n2. Install dependencies\n3. Build the project with environment variables\n4. Deploy to `gh-pages` branch\n5. GitHub Pages automatically serves from `gh-pages`\n\n## Example Workflow (.github/workflows/deploy.yml):\n```yaml\nname: Deploy to GitHub Pages\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - run: npm install\n      - run: npm run build\n        env:\n          VITE_ODOO_URL: ${{ secrets.VITE_ODOO_URL }}\n          VITE_ODOO_DB: ${{ secrets.VITE_ODOO_DB }}\n          VITE_MODEL_NAME: ${{ secrets.VITE_MODEL_NAME }}\n          VITE_MODEL_DISPLAY_NAME: ${{ secrets.VITE_MODEL_DISPLAY_NAME }}\n      - uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./build\n```\n\n## Custom Domain Setup (Optional):\n1. Add `CNAME` file to `static` folder with your domain\n2. Configure DNS records:\n   - A record: Points to GitHub Pages IPs\n   - Or CNAME: Points to `username.github.io`\n3. Enable HTTPS in repository settings (automatic)\n\n## Post-Deployment Checks:\nAfter deployment, verify:\n1. ✅ Application loads at `https://username.github.io/repo-name`\n2. ✅ All assets load correctly (check browser console)\n3. ✅ Base path is correct for all routes\n4. ✅ Odoo connection works (may need CORS configuration)\n5. ✅ PWA installs correctly\n\n## Example prompts to use this command:\n- `/deploy-github` - Interactive GitHub Pages deployment\n- User: \"Deploy to GitHub Pages\"\n- User: \"Set up GitHub Actions for my PWA\"\n\n## Troubleshooting:\n\n### Build Fails in Actions\n- Check Actions logs for specific error\n- Verify all secrets are set correctly\n- Ensure Node version is compatible\n- Test build locally first\n\n### 404 on GitHub Pages\n- Verify `gh-pages` branch exists\n- Check GitHub Pages settings\n- Ensure base path is configured\n- Wait a few minutes for DNS propagation\n\n### Assets Not Loading\n- Check base path configuration\n- Verify all asset paths are relative\n- Look for CORS issues in console\n- Ensure service worker paths are correct\n\n### API Routes Don't Work\n- GitHub Pages doesn't support server-side code\n- Deploy API routes to Vercel/Netlify separately\n- Or modify Odoo client for direct API calls with CORS\n\n## After Deployment:\nProvide the user with:\n1. GitHub Pages URL\n2. Link to Actions tab for monitoring\n3. Instructions for custom domain setup\n4. Reminder about server-side limitations\n5. Alternative hosting recommendations if needed\n",
        "plugins/odoo-pwa-generator/commands/deploy-vercel.md": "Deploy your Odoo PWA to Vercel with proper environment variable configuration.\n\n## What this command does:\n- Prepares the project for Vercel deployment\n- Guides through Vercel CLI setup or web deployment\n- Configures environment variables securely\n- Sets up continuous deployment from Git\n- Provides post-deployment verification steps\n\n## Prerequisites:\nBefore deploying, verify:\n1. ✅ Project builds successfully locally (`npm run build`)\n2. ✅ All tests pass\n3. ✅ `.env` file is configured and working\n4. ✅ Git repository is initialized and pushed to GitHub/GitLab/Bitbucket\n5. ✅ Vercel account exists (or guide user to create one)\n\n## Deployment Options:\n\n### Option 1: Vercel CLI (Recommended for first deployment)\n```bash\nnpm install -g vercel\nvercel login\nvercel\n```\n\n### Option 2: Vercel Dashboard (Recommended for Git integration)\n1. Go to https://vercel.com/new\n2. Import your Git repository\n3. Configure project settings\n4. Add environment variables\n5. Deploy\n\n## Environment Variables to Set in Vercel:\nRequired for production:\n```\nVITE_ODOO_URL=https://yourcompany.odoo.com\nVITE_ODOO_DB=yourcompany-main\nODOO_API_KEY=your_production_api_key\nODOO_USERNAME=your.email@company.com\nVITE_MODEL_NAME=x_expense\nVITE_MODEL_DISPLAY_NAME=Expense\n```\n\n## Steps:\n1. Verify project builds successfully\n2. Check if Vercel is already configured (look for `vercel.json`)\n3. Ask user which deployment option they prefer\n4. Guide through the chosen deployment method\n5. Help set up environment variables in Vercel dashboard\n6. Initiate deployment\n7. Wait for build to complete\n8. Test the deployed application\n9. Set up custom domain (if requested)\n\n## Framework-Specific Configuration:\n\n### SvelteKit\nVerify `vercel.json` contains:\n```json\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"build\",\n  \"framework\": \"sveltekit\"\n}\n```\n\n### React\nVerify build settings:\n```json\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"dist\",\n  \"framework\": \"vite\"\n}\n```\n\n### Vue\nVerify build settings:\n```json\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"dist\",\n  \"framework\": \"vite\"\n}\n```\n\n## Post-Deployment Checks:\nAfter deployment, verify:\n1. ✅ Application loads correctly\n2. ✅ Odoo connection works (check browser console)\n3. ✅ Data syncs from Odoo\n4. ✅ CRUD operations work\n5. ✅ Offline functionality works\n6. ✅ PWA can be installed\n7. ✅ Service worker is active\n\n## Example prompts to use this command:\n- `/deploy-vercel` - Interactive deployment wizard\n- User: \"Deploy my PWA to Vercel\"\n- User: \"Help me set up Vercel deployment\"\n\n## Continuous Deployment:\nOnce Git integration is set up:\n- Every push to `main` branch triggers automatic deployment\n- Preview deployments for pull requests\n- Automatic rollback on build failures\n- Environment variables persist across deployments\n\n## Custom Domain Setup:\nIf user wants a custom domain:\n1. Go to Vercel Dashboard → Project → Settings → Domains\n2. Add custom domain\n3. Configure DNS records as shown\n4. Wait for SSL certificate provisioning (automatic)\n5. Test HTTPS access\n\n## Troubleshooting:\n\n### Build Fails\n- Check build logs in Vercel dashboard\n- Verify all dependencies are in package.json\n- Ensure Node version is compatible\n- Check for environment-specific code\n\n### Environment Variables Not Working\n- Verify variables are set in Vercel dashboard\n- Check variable names match exactly (case-sensitive)\n- Ensure variables starting with `VITE_` for client-side access\n- Redeploy after adding new variables\n\n### API Routes Not Working\n- Verify serverless functions are in correct directory\n- Check function size limits (< 50MB)\n- Review function logs in Vercel dashboard\n- Ensure API routes use correct paths\n\n## After Deployment:\nProvide the user with:\n1. Deployed URL\n2. Vercel dashboard link\n3. Instructions for adding custom domain\n4. Tips for monitoring performance\n5. Reminder to update API keys for production\n",
        "plugins/odoo-pwa-generator/commands/examples.md": "Real-world usage examples and scenarios for the Odoo PWA Generator plugin.\n\n## What this command does:\n- Provides practical, real-world examples of using the plugin\n- Shows complete workflows from start to finish\n- Demonstrates different use cases and scenarios\n- Includes code samples and best practices\n- Helps users understand the plugin's capabilities\n\n## Example 1: Expense Tracking App 💰\n\n### Business Need:\nCreate a mobile-friendly app for employees to track expenses on-the-go, even without internet connection. Sync with Odoo for approval and reimbursement.\n\n### Odoo Model Setup:\nIn Odoo Studio, create model `x_expense` with fields:\n- `x_studio_description` (Char) - Expense description\n- `x_studio_amount` (Float) - Amount spent\n- `x_studio_date` (Date) - When expense occurred\n- `x_studio_category` (Selection) - Meal, Travel, Hotel, Other\n- `x_studio_receipt` (Binary) - Photo of receipt\n- `x_studio_employee` (Many2one to res.partner) - Who spent it\n- `x_studio_status` (Selection) - Draft, Submitted, Approved, Paid\n\n### Implementation Steps:\n```\n1. /new-svelte-pwa\n   - Project name: expense-tracker\n   - Model: expense\n   - Display name: Expense\n   - Deployment: vercel\n\n2. cd expense-tracker\n\n3. /init-project\n   - Install dependencies\n   - Configure Odoo credentials\n   - Test connection\n\n4. Customize the UI:\n   - Add category filter\n   - Display total amount\n   - Add receipt upload\n   - Status badge colors\n\n5. /deploy-vercel\n   - Deploy to production\n   - Share with team\n```\n\n### Key Features:\n- ✅ Record expenses offline\n- ✅ Take photos of receipts\n- ✅ Categorize expenses\n- ✅ Auto-sync when online\n- ✅ View approval status\n- ✅ Calculate monthly totals\n\n### Code Customization:\n```javascript\n// Add total calculation to cache store\nexport const totalExpenses = derived(expenseCache, $cache => {\n  return $cache.reduce((sum, exp) => sum + exp.x_studio_amount, 0);\n});\n\n// Add category filter\nexport function filterByCategory(category) {\n  return $expenseCache.filter(e => e.x_studio_category === category);\n}\n```\n\n---\n\n## Example 2: Inventory Management System 📦\n\n### Business Need:\nWarehouse staff need to check stock levels, update quantities, and add new inventory items from mobile devices or tablets, even in areas with poor connectivity.\n\n### Odoo Model Setup:\nCreate model `x_inventory` with fields:\n- `x_studio_sku` (Char) - Product SKU\n- `x_studio_name` (Char) - Product name\n- `x_studio_quantity` (Integer) - Current stock\n- `x_studio_location` (Char) - Warehouse location\n- `x_studio_min_quantity` (Integer) - Reorder threshold\n- `x_studio_supplier` (Many2one to res.partner) - Supplier\n- `x_studio_last_restock` (Date) - Last restock date\n\n### Implementation Steps:\n```\n1. /new-react-pwa\n   - Project name: inventory-manager\n   - Model: inventory\n   - Display name: Inventory Item\n   - Deployment: vercel\n\n2. cd inventory-manager\n\n3. /init-project\n\n4. Add barcode scanning:\n   - npm install @zxing/library\n   - Add scanner component\n   - Look up items by SKU\n\n5. Add low stock alerts:\n   - Filter items where quantity < min_quantity\n   - Show notification badge\n   - Sort by urgency\n\n6. /deploy-vercel\n```\n\n### Key Features:\n- ✅ Scan barcodes to find items\n- ✅ Update quantities offline\n- ✅ Low stock alerts\n- ✅ Search by name or SKU\n- ✅ Filter by location\n- ✅ Auto-sync updates\n\n### Code Customization:\n```javascript\n// Add low stock filter\nconst lowStockItems = useMemo(() => {\n  return records.filter(item =>\n    item.x_studio_quantity < item.x_studio_min_quantity\n  );\n}, [records]);\n\n// Add barcode lookup\nasync function lookupBySKU(sku) {\n  return records.find(item => item.x_studio_sku === sku);\n}\n```\n\n---\n\n## Example 3: Field Service CRM 🔧\n\n### Business Need:\nField technicians need to view customer information, log service calls, and update job status while on-site, often without reliable internet.\n\n### Odoo Model Setup:\nCreate model `x_service_call` with fields:\n- `x_studio_customer` (Many2one to res.partner) - Customer\n- `x_studio_issue` (Text) - Problem description\n- `x_studio_status` (Selection) - Scheduled, In Progress, Completed\n- `x_studio_scheduled_date` (Datetime) - When to visit\n- `x_studio_technician` (Many2one to res.partner) - Assigned tech\n- `x_studio_notes` (Text) - Service notes\n- `x_studio_parts_used` (Char) - Parts replaced\n- `x_studio_duration` (Float) - Hours spent\n\n### Implementation Steps:\n```\n1. /new-vue-pwa\n   - Project name: field-service-crm\n   - Model: service_call\n   - Display name: Service Call\n   - Deployment: vercel\n\n2. /init-project\n\n3. Add customer details:\n   - Create customer cache store\n   - /add-model\n     - Model: customer (use res.partner)\n     - Generate UI: no (use existing)\n\n4. Add map integration:\n   - npm install @googlemaps/js-api-loader\n   - Show customer locations\n   - Route planning\n\n5. Add time tracking:\n   - Start/stop timer\n   - Calculate duration\n   - Generate timesheet\n\n6. /deploy-vercel\n```\n\n### Key Features:\n- ✅ View today's schedule\n- ✅ Customer contact info\n- ✅ Log service notes offline\n- ✅ Track time spent\n- ✅ Update job status\n- ✅ View service history\n\n---\n\n## Example 4: Sales Order Entry 🛒\n\n### Business Need:\nSales reps at trade shows need to take orders offline and sync them with Odoo when they get back online.\n\n### Odoo Model Setup:\nCreate model `x_sales_order` with fields:\n- `x_studio_customer` (Many2one to res.partner)\n- `x_studio_date` (Date)\n- `x_studio_items` (Text/JSON) - Line items\n- `x_studio_total` (Float) - Order total\n- `x_studio_status` (Selection) - Draft, Sent, Confirmed\n- `x_studio_notes` (Text) - Special instructions\n- `x_studio_salesperson` (Many2one to res.partner)\n\n### Implementation Steps:\n```\n1. /new-svelte-pwa\n   - Project name: sales-order-entry\n   - Model: sales_order\n   - Display name: Sales Order\n\n2. /add-model\n   - Model: customer (res.partner)\n   - Add product catalog model\n\n3. Build line item editor:\n   - Add/remove products\n   - Quantity and price\n   - Calculate totals\n\n4. Add customer search:\n   - Autocomplete\n   - Recently viewed\n   - New customer form\n\n5. /deploy-vercel\n```\n\n### Key Features:\n- ✅ Search products\n- ✅ Build order offline\n- ✅ Calculate totals\n- ✅ Customer lookup\n- ✅ Sync when online\n- ✅ Email confirmation\n\n---\n\n## Example 5: Multi-Model Project Management 📋\n\n### Business Need:\nManage projects with tasks, time entries, and documents, all syncing with Odoo.\n\n### Multiple Models:\n1. `x_project` - Projects\n2. `x_task` - Tasks\n3. `x_time_entry` - Time tracking\n4. `x_document` - File attachments\n\n### Implementation Steps:\n```\n1. /new-svelte-pwa\n   - Project name: project-manager\n   - Model: project\n   - Display name: Project\n\n2. /add-model\n   - Model: task\n   - Generate UI: yes\n\n3. /add-model\n   - Model: time_entry\n   - Generate UI: yes\n\n4. /add-model\n   - Model: document\n   - Generate UI: yes\n\n5. Add relationships:\n   - Tasks belong to projects\n   - Time entries belong to tasks\n   - Documents belong to projects\n\n6. Build dashboard:\n   - Project overview\n   - Task list by status\n   - Total hours tracked\n   - Recent documents\n\n7. /deploy-vercel\n```\n\n### Key Features:\n- ✅ Multiple model types\n- ✅ Relationships between models\n- ✅ Aggregate data (total hours)\n- ✅ Complex filtering\n- ✅ Dashboard views\n\n---\n\n## Example 6: Custom Cache Strategy 🎯\n\n### Scenario:\nNeed a custom caching strategy for frequently changing data.\n\n### Implementation:\n```\n1. Open existing project\n\n2. /create-cache-store\n   - Model: notification\n   - Shorter cache timeout (1 minute)\n   - More frequent sync (30 seconds)\n\n3. Customize the generated store:\n```\n\n```javascript\n// Shorten cache validity\nconst CACHE_VALIDITY = 60 * 1000; // 1 minute\n\n// More frequent sync\nconst SYNC_INTERVAL = 30 * 1000; // 30 seconds\n\n// Add real-time refresh\nexport function enableRealTimeSync() {\n  return setInterval(() => {\n    refresh();\n  }, SYNC_INTERVAL);\n}\n```\n\n---\n\n## Example 7: Migrating Existing App 🔄\n\n### Scenario:\nHave an existing web app, want to add Odoo integration and offline functionality.\n\n### Implementation Steps:\n```\n1. Generate reference implementation:\n   /new-svelte-pwa\n   - Project name: reference-app\n   - Model: your_model\n\n2. Study generated code:\n   - Review odoo.js client\n   - Study cache.js pattern\n   - Examine API routes\n\n3. Copy patterns to existing app:\n   - Copy src/lib/odoo.js\n   - Copy src/routes/api/odoo/+server.js\n   - Adapt cache store to your state management\n\n4. Test integration:\n   /test-connection\n\n5. Gradually add features:\n   - Start with read-only\n   - Add create functionality\n   - Add update/delete\n   - Add offline support\n\n6. /deploy-vercel\n```\n\n---\n\n## Common Customizations:\n\n### 1. Add Search Functionality\n```javascript\nexport function searchRecords(query) {\n  return $cache.filter(record =>\n    record.x_studio_name.toLowerCase().includes(query.toLowerCase())\n  );\n}\n```\n\n### 2. Add Sorting\n```javascript\nexport function sortBy(field, direction = 'asc') {\n  return $cache.sort((a, b) => {\n    const valA = a[field];\n    const valB = b[field];\n    return direction === 'asc' ? valA - valB : valB - valA;\n  });\n}\n```\n\n### 3. Add Pagination\n```javascript\nexport function paginate(page, pageSize) {\n  const start = (page - 1) * pageSize;\n  return $cache.slice(start, start + pageSize);\n}\n```\n\n### 4. Add Export to CSV\n```javascript\nexport function exportToCSV() {\n  const headers = ['ID', 'Name', 'Amount', 'Date'];\n  const rows = $cache.map(r => [\n    r.id,\n    r.x_studio_name,\n    r.x_studio_amount,\n    r.x_studio_date\n  ]);\n  // Convert to CSV and download\n}\n```\n\n### 5. Add Bulk Operations\n```javascript\nexport async function bulkUpdate(ids, fields) {\n  const promises = ids.map(id => update(id, fields));\n  return Promise.all(promises);\n}\n```\n\n---\n\n## Tips for Success:\n\n### Start Simple\n1. Generate basic PWA first\n2. Test with sample data\n3. Add features incrementally\n4. Deploy early and often\n\n### Plan Your Models\n1. Design Odoo model schema carefully\n2. Include all necessary fields\n3. Think about relationships\n4. Consider mobile UX\n\n### Test Thoroughly\n1. Test offline functionality\n2. Verify sync works correctly\n3. Check error handling\n4. Test on real devices\n\n### Optimize Performance\n1. Limit initial data load\n2. Use pagination for large datasets\n3. Lazy load images\n4. Minimize bundle size\n\n### Deploy Confidently\n1. Test build locally\n2. Use staging environment\n3. Monitor errors\n4. Have rollback plan\n\n---\n\n## Example prompts to use this command:\n- `/examples` - Show all examples\n- User: \"Show me real-world examples\"\n- User: \"How do I build an expense tracker?\"\n- User: \"Give me ideas for using this plugin\"\n\n## Next Steps:\nAfter reviewing these examples:\n1. Choose a use case similar to your needs\n2. Follow the implementation steps\n3. Customize to match your requirements\n4. Deploy and iterate\n\nNeed help? Run `/help` for more information!\n",
        "plugins/odoo-pwa-generator/commands/fix-sync.md": "Diagnose and fix synchronization issues between your PWA and Odoo.\n\n## What this command does:\n- Identifies sync problems\n- Tests each component of the sync system\n- Provides step-by-step fixes\n- Clears problematic cached data\n- Verifies sync works correctly\n\n---\n\n## Quick Diagnosis 🔍\n\nRun through these quick checks first:\n\n### 1. Visual Inspection\n```\n□ Check browser console for errors\n□ Look at \"Last synced\" timestamp\n□ Try manual refresh\n□ Check network tab for failed requests\n```\n\n### 2. Quick Tests\n```javascript\n// In browser console:\n\n// 1. Check if cache exists\nlocalStorage.getItem('expenseCache');\n\n// 2. Test API endpoint\nfetch('/api/odoo', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    action: 'search',\n    model: 'res.partner',\n    domain: [],\n    fields: ['name'],\n    limit: 1\n  })\n}).then(r => r.json()).then(console.log);\n\n// 3. Force refresh\nexpenseCache.refresh();\n```\n\n### 3. Automatic Diagnosis\n```bash\n/test-connection\n```\n\n---\n\n## Common Sync Issues\n\n### Issue 1: Initial Load Works, But No Updates 🔄\n\n**Symptoms:**\n- Data loads on first visit\n- But never updates with new Odoo data\n- \"Last synced\" timestamp is old\n- Background sync not happening\n\n**Diagnosis:**\n```javascript\n// Check if sync timer is running\n// In cache store, look for:\nsetInterval(() => syncInBackground(), 180000);\n\n// Check if stale detection works\nconst cacheData = JSON.parse(localStorage.getItem('expenseCache'));\nconsole.log('Last sync:', new Date(cacheData?.lastSyncTime));\nconsole.log('Is stale?', Date.now() - cacheData?.lastSyncTime > 5 * 60 * 1000);\n```\n\n**Solutions:**\n\n#### Solution A: Restart Background Sync\n```javascript\n// In browser console\nexpenseCache.stopAutoSync();\nexpenseCache.startAutoSync();\n```\n\n#### Solution B: Check Cache Validity\n```javascript\n// In cache store file (e.g., expenseCache.js)\nconst CACHE_VALIDITY = 5 * 60 * 1000; // 5 minutes\n\nfunction isCacheStale() {\n  const cacheData = JSON.parse(localStorage.getItem('expenseCache'));\n  if (!cacheData) return true;\n\n  const now = Date.now();\n  const age = now - cacheData.lastSyncTime;\n\n  console.log(`Cache age: ${Math.floor(age / 1000)}s`);\n\n  return age > CACHE_VALIDITY;\n}\n```\n\n#### Solution C: Force Manual Sync\n```javascript\n// Add a refresh button to your UI\n<button onclick={() => expenseCache.refresh()}>\n  Sync Now\n</button>\n```\n\n---\n\n### Issue 2: Incremental Sync Not Working 📈\n\n**Symptoms:**\n- Always fetches all records\n- Slow sync times\n- High bandwidth usage\n- `lastRecordId` not updating\n\n**Diagnosis:**\n```javascript\n// Check lastRecordId\nconst cacheData = JSON.parse(localStorage.getItem('expenseCache'));\nconsole.log('Last record ID:', cacheData?.lastRecordId);\n\n// Check if it's being updated after sync\n```\n\n**Solutions:**\n\n#### Solution A: Verify Domain Filter\n```javascript\n// In syncInBackground() function\nasync function syncInBackground() {\n  const { lastRecordId } = getCacheMetadata();\n\n  console.log('Fetching records with id >', lastRecordId);\n\n  const domain = lastRecordId > 0\n    ? [['id', '>', lastRecordId]]\n    : [];\n\n  const newRecords = await odoo.searchRecords(\n    MODEL_NAME,\n    domain,\n    fields\n  );\n\n  console.log('Fetched:', newRecords.length, 'new records');\n\n  if (newRecords.length > 0) {\n    // Update lastRecordId\n    const maxId = Math.max(...newRecords.map(r => r.id));\n    updateCacheMetadata({ lastRecordId: maxId });\n  }\n}\n```\n\n#### Solution B: Reset lastRecordId\n```javascript\n// If stuck, reset to fetch all\nconst cacheData = JSON.parse(localStorage.getItem('expenseCache'));\ncacheData.lastRecordId = 0;\nlocalStorage.setItem('expenseCache', JSON.stringify(cacheData));\n\n// Then refresh\nexpenseCache.refresh();\n```\n\n---\n\n### Issue 3: Optimistic Updates Not Syncing ⚡\n\n**Symptoms:**\n- Create/update works in UI\n- But changes don't save to Odoo\n- Records disappear on refresh\n- Temp IDs persist\n\n**Diagnosis:**\n```javascript\n// Check for temp IDs\nconsole.log($expenseCache.filter(e => e.id.toString().startsWith('temp-')));\n\n// Check browser console for API errors\n```\n\n**Solutions:**\n\n#### Solution A: Check API Route\n```javascript\n// Test create\nfetch('/api/odoo', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    action: 'create',\n    model: 'x_expense',\n    fields: {\n      x_studio_description: 'Test',\n      x_studio_amount: 10.00\n    }\n  })\n})\n.then(r => r.json())\n.then(console.log)\n.catch(console.error);\n```\n\n#### Solution B: Fix Error Handling\n```javascript\n// In cache store create() function\nexport async function create(data) {\n  const tempId = `temp-${Date.now()}`;\n  const tempRecord = { id: tempId, ...data };\n\n  // Add to cache\n  records.update(r => [...r, tempRecord]);\n\n  try {\n    // Create in Odoo\n    const realId = await odoo.createRecord(MODEL_NAME, data);\n\n    // Replace temp ID\n    records.update(r =>\n      r.map(rec => rec.id === tempId ? { ...rec, id: realId } : rec)\n    );\n\n    // Update cache metadata\n    await refresh(); // Sync to get the complete record\n\n    return realId;\n  } catch (error) {\n    console.error('Failed to create record:', error);\n\n    // Rollback\n    records.update(r => r.filter(rec => rec.id !== tempId));\n\n    // Re-throw\n    throw error;\n  }\n}\n```\n\n#### Solution C: Clean Up Temp Records\n```javascript\n// Remove stuck temp records\nexpenseCache.records.update(records =>\n  records.filter(r => !r.id.toString().startsWith('temp-'))\n);\n\n// Then refresh\nexpenseCache.refresh();\n```\n\n---\n\n### Issue 4: Partner Names Not Resolving 👥\n\n**Symptoms:**\n- Partner fields show IDs instead of names\n- Many2one fields display as arrays\n- \"undefined\" or \"[object Object]\" displayed\n\n**Diagnosis:**\n```javascript\n// Check partner field format\nconst record = $expenseCache[0];\nconsole.log('Employee field:', record.x_studio_employee);\n// Should be: [12, \"John Doe\"] or 12\n```\n\n**Solutions:**\n\n#### Solution A: Add Partner Resolution\n```javascript\n// In syncInBackground()\nasync function syncInBackground() {\n  // ... fetch records ...\n\n  // Resolve partner names\n  const partnerIds = new Set();\n\n  records.forEach(record => {\n    if (record.x_studio_employee) {\n      const id = Array.isArray(record.x_studio_employee)\n        ? record.x_studio_employee[0]\n        : record.x_studio_employee;\n      partnerIds.add(id);\n    }\n  });\n\n  if (partnerIds.size > 0) {\n    const partners = await odoo.fetchPartners(Array.from(partnerIds));\n    const partnerMap = new Map(partners.map(p => [p.id, p.name]));\n\n    // Cache partners\n    localStorage.setItem('partnerCache', JSON.stringify(\n      Array.from(partnerMap.entries())\n    ));\n\n    // Update records with names\n    records = records.map(record => {\n      if (record.x_studio_employee) {\n        const id = Array.isArray(record.x_studio_employee)\n          ? record.x_studio_employee[0]\n          : record.x_studio_employee;\n\n        return {\n          ...record,\n          x_studio_employee: [id, partnerMap.get(id) || 'Unknown']\n        };\n      }\n      return record;\n    });\n  }\n}\n```\n\n#### Solution B: Display Helper Function\n```javascript\n// Helper to display partner name\nfunction getPartnerName(field) {\n  if (!field) return 'None';\n  if (Array.isArray(field)) return field[1] || `ID: ${field[0]}`;\n  return `ID: ${field}`;\n}\n\n// In component\n{getPartnerName(expense.x_studio_employee)}\n```\n\n---\n\n### Issue 5: Duplicate Records 📋📋\n\n**Symptoms:**\n- Same record appears multiple times\n- ID conflicts\n- Sync creates duplicates\n\n**Diagnosis:**\n```javascript\n// Check for duplicates\nconst ids = $expenseCache.map(r => r.id);\nconst duplicates = ids.filter((id, index) => ids.indexOf(id) !== index);\nconsole.log('Duplicate IDs:', duplicates);\n```\n\n**Solutions:**\n\n#### Solution A: Deduplicate Cache\n```javascript\nfunction deduplicateCache() {\n  records.update(currentRecords => {\n    const seen = new Set();\n    return currentRecords.filter(record => {\n      if (seen.has(record.id)) {\n        return false;\n      }\n      seen.add(record.id);\n      return true;\n    });\n  });\n}\n\n// Run deduplication\ndeduplicateCache();\n```\n\n#### Solution B: Fix Sync Logic\n```javascript\n// When appending new records, check for duplicates\nasync function appendToCache(newRecords) {\n  records.update(currentRecords => {\n    const existingIds = new Set(currentRecords.map(r => r.id));\n\n    // Only add records that don't exist\n    const toAdd = newRecords.filter(r => !existingIds.has(r.id));\n\n    return [...currentRecords, ...toAdd];\n  });\n}\n```\n\n---\n\n### Issue 6: Offline Queue Not Syncing 📴\n\n**Symptoms:**\n- Changes made offline\n- Online now, but changes not syncing\n- Stuck in \"pending\" state\n\n**Solutions:**\n\n#### Solution A: Implement Offline Queue\n```javascript\n// Store failed operations\nconst offlineQueue = writable([]);\n\nasync function queueOperation(operation) {\n  offlineQueue.update(q => [...q, operation]);\n  saveOfflineQueue();\n}\n\nasync function processOfflineQueue() {\n  const queue = get(offlineQueue);\n\n  for (const operation of queue) {\n    try {\n      if (operation.type === 'create') {\n        await odoo.createRecord(operation.model, operation.data);\n      } else if (operation.type === 'update') {\n        await odoo.updateRecord(operation.model, operation.id, operation.data);\n      } else if (operation.type === 'delete') {\n        await odoo.deleteRecord(operation.model, operation.id);\n      }\n\n      // Remove from queue\n      offlineQueue.update(q => q.filter(op => op !== operation));\n    } catch (error) {\n      console.error('Failed to process queued operation:', error);\n      // Keep in queue, will retry\n    }\n  }\n\n  saveOfflineQueue();\n}\n\n// Listen for online event\nwindow.addEventListener('online', () => {\n  console.log('Back online, processing queue...');\n  processOfflineQueue();\n});\n```\n\n---\n\n## Step-by-Step Fix Procedure 🔧\n\n### Step 1: Clear Everything\n```javascript\n// Clear all caches\nlocalStorage.clear();\n\n// Clear IndexedDB\n// DevTools → Application → IndexedDB → Delete database\n```\n\n### Step 2: Test API\n```bash\n/test-connection\n```\n\n### Step 3: Fresh Sync\n```javascript\n// Refresh page\nlocation.reload();\n\n// Should fetch all data fresh\n```\n\n### Step 4: Monitor Sync\n```javascript\n// Watch console for sync messages\n// Should see:\n// \"Syncing x_expense...\"\n// \"Fetched X records\"\n// \"Cache updated\"\n```\n\n### Step 5: Test CRUD\n```javascript\n// Test create\nawait expenseCache.create({ /* data */ });\n\n// Test update\nawait expenseCache.update(id, { /* data */ });\n\n// Test delete\nawait expenseCache.remove(id);\n\n// Verify in Odoo\n```\n\n---\n\n## Sync Debugging Checklist ✅\n\n```\n□ Browser console shows no errors\n□ /api/odoo endpoint responds\n□ ODOO_API_KEY is valid\n□ lastSyncTime is updating\n□ lastRecordId is updating\n□ Background sync interval is running\n□ Stale detection works correctly\n□ Incremental fetch has correct domain\n□ Optimistic updates resolve temp IDs\n□ Partner names resolve correctly\n□ No duplicate records\n□ Offline queue processes when online\n□ IndexedDB is storing data\n□ localStorage has metadata\n```\n\n---\n\n## Advanced Debugging 🐛\n\n### Enable Verbose Logging\n```javascript\n// Add to cache store\nconst DEBUG = true;\n\nfunction log(...args) {\n  if (DEBUG) console.log('[ExpenseCache]', ...args);\n}\n\nasync function syncInBackground() {\n  log('Starting background sync...');\n  log('lastRecordId:', getLastRecordId());\n\n  const records = await fetch();\n  log('Fetched records:', records.length);\n\n  await saveToCache(records);\n  log('Cache updated');\n}\n```\n\n### Monitor Network\n```javascript\n// Log all API calls\nconst originalFetch = window.fetch;\nwindow.fetch = async (...args) => {\n  console.log('Fetch:', args[0]);\n  const response = await originalFetch(...args);\n  console.log('Response:', response.status);\n  return response;\n};\n```\n\n### Profile Performance\n```javascript\n// Measure sync time\nconsole.time('sync');\nawait expenseCache.refresh();\nconsole.timeEnd('sync');\n```\n\n---\n\n## Example prompts to use this command:\n- `/fix-sync` - Diagnose sync issues\n- User: \"Data is not syncing\"\n- User: \"My changes aren't saving\"\n- User: \"Sync is broken\"\n\n## Related Commands:\n- `/test-connection` - Test Odoo connectivity\n- `/clear-cache` - Clear all cached data\n- `/troubleshoot` - General troubleshooting\n- `/help` - Full documentation\n\n---\n\n## Prevention Tips 🛡️\n\n1. **Monitor sync health**\n   - Display \"Last synced\" timestamp in UI\n   - Show sync status indicator\n   - Alert on sync failures\n\n2. **Handle errors gracefully**\n   - Catch and log all errors\n   - Show user-friendly messages\n   - Provide retry mechanisms\n\n3. **Test offline scenarios**\n   - Test creating records offline\n   - Test going offline mid-sync\n   - Test coming back online\n\n4. **Keep sync simple**\n   - Stick to generated patterns\n   - Don't overcomplicate logic\n   - Follow proven examples\n\n5. **Regular maintenance**\n   - Clear old data periodically\n   - Update dependencies\n   - Monitor performance\n",
        "plugins/odoo-pwa-generator/commands/help.md": "Display comprehensive help and documentation for the Odoo PWA Generator plugin.\n\n## What this command does:\n- Provides overview of the plugin and its capabilities\n- Lists all available commands with descriptions\n- Explains the plugin's skills and when to use them\n- Shows common usage patterns and workflows\n- Links to detailed documentation\n\n## Plugin Overview:\nThe **odoo-pwa-generator** plugin helps you create offline-first Progressive Web Apps with Odoo Studio backend integration. It supports SvelteKit, React, and Vue frameworks.\n\n### Key Features:\n✨ **Quick Project Generation** - Create complete PWAs in minutes\n📱 **Offline-First** - Smart caching with background sync\n🔄 **Odoo Integration** - Seamless Odoo Studio connectivity\n🚀 **Production Ready** - Pre-configured deployment setups\n⚡ **Framework Support** - SvelteKit, React, and Vue\n\n### Core Capabilities:\n- Automatic CRUD operations for Odoo models\n- Smart caching with localStorage + IndexedDB\n- Incremental sync (only fetch new records)\n- Optimistic UI updates\n- Partner/relation resolution\n- PWA installability\n- Offline functionality\n\n## Available Commands:\n\n### 🎯 Skill Shortcuts (Project Generation)\nCreate new PWA projects:\n- `/new-svelte-pwa` - Generate SvelteKit PWA\n- `/new-react-pwa` - Generate React PWA\n- `/new-vue-pwa` - Generate Vue PWA\n- `/add-model` - Add Odoo model to existing PWA\n- `/create-cache-store` - Create cache store for a model\n\n### 🔧 Workflow Commands\nDevelopment and deployment:\n- `/init-project` - Initialize new PWA project\n- `/setup-env` - Configure environment variables\n- `/test-connection` - Test Odoo API connection\n- `/deploy-vercel` - Deploy to Vercel\n- `/deploy-github` - Deploy to GitHub Pages\n\n### 📚 Documentation Commands\nHelp and reference:\n- `/help` - This help document (you are here!)\n- `/examples` - Real-world usage examples\n- `/architecture` - Explain PWA architecture\n- `/api-reference` - Odoo API client documentation\n- `/troubleshoot` - Common issues and solutions\n\n### 🛠 Maintenance Commands\nProject management:\n- `/update-deps` - Update project dependencies\n- `/fix-sync` - Diagnose and fix sync issues\n- `/clear-cache` - Clear application caches\n- `/add-deployment` - Add new deployment target\n- `/optimize` - Run optimization checks\n\n## Common Workflows:\n\n### 1️⃣ Starting a New Project\n```\n1. /new-svelte-pwa (or /new-react-pwa or /new-vue-pwa)\n2. Provide project details (name, model, etc.)\n3. /init-project\n4. Start coding!\n```\n\n### 2️⃣ Setting Up Environment\n```\n1. /setup-env\n2. Provide Odoo credentials\n3. /test-connection\n4. Verify everything works\n```\n\n### 3️⃣ Adding More Models\n```\n1. /add-model\n2. Specify model name and details\n3. Test CRUD operations\n4. Customize UI as needed\n```\n\n### 4️⃣ Deploying to Production\n```\n1. /deploy-vercel (recommended)\n   OR /deploy-github\n2. Configure environment variables\n3. Test deployed application\n4. Set up custom domain (optional)\n```\n\n### 5️⃣ Troubleshooting Issues\n```\n1. /test-connection - Check Odoo connectivity\n2. /troubleshoot - Find specific solutions\n3. /fix-sync - Diagnose sync problems\n4. /clear-cache - Reset if needed\n```\n\n## Quick Start Guide:\n\n### Step 1: Generate a New PWA\nChoose your framework and run the appropriate command:\n```\n/new-svelte-pwa\n```\n\n### Step 2: Provide Project Details\nWhen prompted, provide:\n- **Project name**: e.g., \"expense-tracker\"\n- **Odoo model**: e.g., \"expense\" (without x_ prefix)\n- **Display name**: e.g., \"Expense\"\n- **Deployment target**: e.g., \"vercel\" (optional)\n\n### Step 3: Initialize the Project\n```\ncd your-project-name\n/init-project\n```\n\n### Step 4: Configure Odoo Connection\n```\n/setup-env\n```\nProvide your Odoo URL, database, API key, and username.\n\n### Step 5: Test Everything\n```\n/test-connection\n```\nVerify your Odoo connection works correctly.\n\n### Step 6: Start Developing\nThe dev server should be running. Open your browser and start customizing!\n\n### Step 7: Deploy (when ready)\n```\n/deploy-vercel\n```\nFollow the prompts to deploy to production.\n\n## Plugin Skills:\n\n### create-odoo-pwa\nGenerates a complete PWA project from scratch.\n\n**When to use**: Starting a new project\n\n**What it generates**:\n- Base configuration (package.json, vite.config, etc.)\n- Odoo API client\n- Cache stores with smart syncing\n- Server-side API proxy\n- UI components (forms, lists)\n- PWA manifest and service worker\n- Deployment configurations\n- Complete documentation\n\n### add-odoo-model\nAdds integration for additional Odoo models.\n\n**When to use**: Adding new data models to existing project\n\n**What it generates**:\n- Cache store for the new model\n- API methods in Odoo client\n- Form and list pages (optional)\n- Navigation updates\n\n### create-cache-store\nCreates a standalone cache store.\n\n**When to use**: Need custom caching logic\n\n**What it generates**:\n- Framework-specific cache store\n- Smart caching logic\n- Background sync\n- Optimistic updates\n\n## Best Practices:\n\n### Security\n- ✅ Keep API keys in `.env` file (never commit)\n- ✅ Use different credentials for dev and production\n- ✅ Set environment variables in hosting platform\n- ✅ Rotate API keys periodically\n\n### Development\n- ✅ Test Odoo connection before coding\n- ✅ Use version control (Git)\n- ✅ Test offline functionality regularly\n- ✅ Read generated CLAUDE.md for patterns\n\n### Deployment\n- ✅ Build and test locally first\n- ✅ Use Vercel/Netlify for full functionality\n- ✅ Set up continuous deployment from Git\n- ✅ Monitor performance and errors\n\n### Maintenance\n- ✅ Keep dependencies updated\n- ✅ Monitor Odoo API changes\n- ✅ Test after Odoo upgrades\n- ✅ Clear caches when schema changes\n\n## Getting More Help:\n\n### Example prompts to use this command:\n- `/help` - Show this help document\n- User: \"How do I use the Odoo PWA plugin?\"\n- User: \"What commands are available?\"\n\n### In Generated Projects:\n- `README.md` - Getting started guide\n- `CLAUDE.md` - Architecture patterns\n- `API.md` - API client reference\n\n### External Resources:\n- Odoo API Documentation: https://www.odoo.com/documentation/\n- SvelteKit: https://kit.svelte.dev/\n- React: https://react.dev/\n- Vue: https://vuejs.org/\n- PWA Guide: https://web.dev/progressive-web-apps/\n\n### Troubleshooting:\nIf you encounter issues:\n1. Run `/test-connection` to diagnose\n2. Check `/troubleshoot` for common solutions\n3. Review browser console for errors\n4. Verify Odoo configuration\n5. Check generated documentation\n\n### Support:\nFor bugs or feature requests:\n- Check existing issues\n- Review documentation thoroughly\n- Provide detailed error messages\n- Include environment details\n\n## Framework-Specific Notes:\n\n### SvelteKit (Recommended)\n- Uses Svelte 5 runes syntax\n- Server-side API routes work perfectly\n- Best offline functionality\n- Smallest bundle size\n- Easiest to deploy\n\n### React\n- Modern React 18+ hooks\n- Context API for state management\n- Wide ecosystem support\n- Popular and familiar\n\n### Vue\n- Vue 3 Composition API\n- Pinia for state management\n- Great developer experience\n- Progressive framework\n\n## Architecture Highlights:\n\n### Data Flow\n```\nComponent → Cache Store → API Client → Server Route → Odoo\n```\n\n### Caching Strategy\n1. **Load from cache** (instant, may be stale)\n2. **Check if stale** (> 5 minutes)\n3. **Background sync** (fetch new data)\n4. **Update cache** (localStorage + IndexedDB)\n5. **Reactive update** (UI updates automatically)\n\n### Sync Strategy\n1. **Incremental fetch** - Only `id > lastRecordId`\n2. **Partner resolution** - Batch fetch related records\n3. **Optimistic updates** - UI updates before server\n4. **Error recovery** - Graceful offline handling\n\n## Tips and Tricks:\n\n💡 **Use the right command for the job**\n- Quick start? `/new-svelte-pwa`\n- Need help? `/help` or `/troubleshoot`\n- Deploy ready? `/deploy-vercel`\n\n💡 **Test early and often**\n- Run `/test-connection` after setup\n- Test offline mode frequently\n- Verify sync works correctly\n\n💡 **Read the generated docs**\n- CLAUDE.md has architecture details\n- API.md has client method docs\n- README.md has setup instructions\n\n💡 **Customize to your needs**\n- Start with generated code\n- Modify UI components\n- Add business logic\n- Extend with new features\n\n💡 **Deploy with confidence**\n- Test build locally first\n- Use environment variables properly\n- Monitor after deployment\n- Set up error tracking\n\n## Summary:\nThe odoo-pwa-generator plugin makes it easy to create production-ready PWAs with Odoo integration. Use the commands above to generate, develop, deploy, and maintain your applications.\n\nFor more details on any command, just run that command and follow the prompts!\n\nHappy coding! 🚀\n",
        "plugins/odoo-pwa-generator/commands/init-project.md": "Initialize a newly generated Odoo PWA project with all necessary setup steps.\n\n## What this command does:\n- Runs `npm install` to install all dependencies\n- Creates `.env` file from `.env.example`\n- Guides through environment configuration\n- Tests the Odoo connection\n- Starts the development server\n- Opens the application in browser\n- Provides next steps and documentation\n\n## Prerequisites:\n- Newly generated Odoo PWA project\n- Node.js installed (v18 or higher)\n- npm or pnpm package manager\n- Internet connection for dependencies\n\n## Steps:\n\n### 1. Verify Project Structure\nCheck that required files exist:\n- ✅ `package.json`\n- ✅ `.env.example`\n- ✅ `README.md`\n- ✅ `src/lib/odoo.js` (or equivalent)\n- ✅ Framework config file (svelte.config.js / vite.config.js)\n\n### 2. Install Dependencies\n```bash\nnpm install\n```\n\nShow progress and estimated time.\n\n### 3. Environment Setup\nCopy `.env.example` to `.env`:\n```bash\ncp .env.example .env\n```\n\nAsk the user to provide:\n1. Odoo URL\n2. Database name\n3. API key\n4. Username\n5. Model configuration\n\nUpdate `.env` file with provided values.\n\n### 4. Verify Setup\nRead `.env` and verify all required variables are set.\n\n### 5. Test Odoo Connection\nRun a quick connection test:\n- Test authentication\n- Verify model access\n- Check permissions\n\nIf connection fails, offer to run full diagnostics (`/test-connection`).\n\n### 6. Initialize Git (if not already)\n```bash\ngit init\ngit add .\ngit commit -m \"Initial commit: Odoo PWA generated\"\n```\n\n### 7. Start Development Server\n```bash\nnpm run dev\n```\n\nFramework-specific commands:\n- **SvelteKit**: `npm run dev` (default port 5173)\n- **React**: `npm run dev` (default port 5173)\n- **Vue**: `npm run dev` (default port 5173)\n\n### 8. Open in Browser\nAutomatically open browser to `http://localhost:5173`\n\n## Example prompts to use this command:\n- `/init-project` - Complete initialization wizard\n- User: \"Set up my new Odoo PWA\"\n- User: \"Initialize the project\"\n- User: \"Get my PWA running\"\n\n## Post-Initialization Checklist:\nAfter successful initialization:\n\n✅ **Immediate Next Steps**:\n1. Test the application in the browser\n2. Verify data loads from Odoo\n3. Test creating a new record\n4. Test editing and deleting records\n5. Verify offline functionality (disable network)\n\n✅ **Configuration**:\n1. Review and customize PWA manifest (colors, icons, name)\n2. Update application metadata\n3. Configure deployment targets\n4. Set up version control (Git)\n\n✅ **Development**:\n1. Read the generated `CLAUDE.md` for architecture details\n2. Review `API.md` for Odoo client documentation\n3. Explore the codebase structure\n4. Customize UI components and styling\n\n✅ **Testing**:\n1. Test all CRUD operations\n2. Verify sync functionality\n3. Test offline mode\n4. Check PWA installability\n5. Test on mobile devices\n\n✅ **Deployment Preparation**:\n1. Review deployment documentation\n2. Set up hosting platform account (Vercel/Netlify/etc)\n3. Prepare production Odoo API keys\n4. Configure environment variables for production\n\n## Helpful Resources:\nProvide links to:\n- Project `README.md`\n- `CLAUDE.md` (architecture guide)\n- `API.md` (API documentation)\n- Odoo documentation\n- Framework documentation (SvelteKit/React/Vue)\n- PWA best practices\n\n## Development Commands:\nRemind the user of available commands:\n```bash\nnpm run dev          # Start development server\nnpm run build        # Build for production\nnpm run preview      # Preview production build\nnpm run lint         # Run linter\nnpm run format       # Format code\n```\n\n## Troubleshooting:\n\n### npm install fails\n- Check Node.js version (must be v18+)\n- Clear npm cache: `npm cache clean --force`\n- Delete `node_modules` and `package-lock.json`, try again\n- Check internet connection\n\n### .env configuration issues\n- Verify all variables are set (no empty values)\n- Check for typos in variable names\n- Ensure no spaces around `=` signs\n- Verify Odoo credentials are correct\n\n### Development server won't start\n- Check if port 5173 is already in use\n- Try different port: `npm run dev -- --port 3000`\n- Check for syntax errors in config files\n- Review console error messages\n\n### Odoo connection fails\n- Run `/test-connection` for full diagnostics\n- Verify `.env` file is loaded correctly\n- Check Odoo server is accessible\n- Verify API key is valid\n\n### Build fails\n- Check for TypeScript errors (if using TypeScript)\n- Verify all dependencies are installed\n- Check for missing environment variables\n- Review build logs for specific errors\n\n## After Initialization:\nDisplay summary:\n```\n🎉 Odoo PWA Initialized Successfully!\n\n📁 Project: [project-name]\n🚀 Framework: [SvelteKit/React/Vue]\n🔗 Dev Server: http://localhost:5173\n📝 Model: [model-name]\n\n✅ Next Steps:\n1. Open http://localhost:5173 in your browser\n2. Test data sync from Odoo\n3. Read CLAUDE.md for architecture details\n4. Customize the UI to match your needs\n5. Run /deploy-vercel when ready to deploy\n\n📚 Documentation:\n- README.md - Getting started guide\n- CLAUDE.md - Architecture and patterns\n- API.md - Odoo API client reference\n\n💡 Helpful Commands:\n- /test-connection - Verify Odoo integration\n- /add-model - Add more Odoo models\n- /deploy-vercel - Deploy to production\n- /odoo-help - Get plugin help\n\nHappy coding! 🚀\n```\n",
        "plugins/odoo-pwa-generator/commands/new-react-pwa.md": "Generate a new offline-first Progressive Web App using React framework with Odoo Studio backend integration.\n\n## What this command does:\n- Invokes the `create-odoo-pwa` skill with React as the framework\n- Generates a complete PWA project with smart caching, offline support, and Odoo integration\n- Creates all necessary configuration files, components, hooks, and deployment setups\n\n## Required Information:\nBefore starting, gather:\n1. **Project name** (kebab-case, e.g., \"expense-tracker\", \"inventory-manager\")\n2. **Odoo model name** (without `x_` prefix, e.g., \"expense\", \"inventory\")\n3. **Model display name** (human-readable, e.g., \"Expense\", \"Inventory Item\")\n4. **Deployment target** (optional: vercel, github, cloudflare, netlify)\n\n## Steps:\n1. Ask the user for the required information listed above\n2. Invoke the `create-odoo-pwa` skill with framework set to \"react\"\n3. Generate the complete React PWA project structure\n4. Create comprehensive documentation (README.md, CLAUDE.md, API.md)\n5. Provide next steps for setup and deployment\n\n## Example prompts to use this command:\n- `/new-react-pwa` - Interactive mode, will ask for all parameters\n- User: \"Create a React PWA for tracking expenses with Odoo\"\n- User: \"Generate an inventory management app using React and Odoo Studio\"\n\n## After generation:\nRemind the user to:\n1. Navigate to the project directory\n2. Copy `.env.example` to `.env` and configure Odoo credentials\n3. Run `npm install` to install dependencies\n4. Run `npm run dev` to start development server\n5. Test the Odoo connection and sync functionality\n",
        "plugins/odoo-pwa-generator/commands/new-svelte-pwa.md": "Generate a new offline-first Progressive Web App using SvelteKit framework with Odoo Studio backend integration.\n\n## What this command does:\n- Invokes the `create-odoo-pwa` skill with SvelteKit as the framework\n- Generates a complete PWA project with smart caching, offline support, and Odoo integration\n- Creates all necessary configuration files, routes, components, and deployment setups\n\n## Required Information:\nBefore starting, gather:\n1. **Project name** (kebab-case, e.g., \"expense-tracker\", \"inventory-manager\")\n2. **Odoo model name** (without `x_` prefix, e.g., \"expense\", \"inventory\")\n3. **Model display name** (human-readable, e.g., \"Expense\", \"Inventory Item\")\n4. **Deployment target** (optional: vercel, github, cloudflare, netlify)\n\n## Steps:\n1. Ask the user for the required information listed above\n2. Invoke the `create-odoo-pwa` skill with framework set to \"sveltekit\"\n3. Generate the complete SvelteKit PWA project structure\n4. Create comprehensive documentation (README.md, CLAUDE.md, API.md)\n5. Provide next steps for setup and deployment\n\n## Example prompts to use this command:\n- `/new-svelte-pwa` - Interactive mode, will ask for all parameters\n- User: \"Create a SvelteKit PWA for tracking expenses with Odoo\"\n- User: \"Generate an inventory management app using SvelteKit and Odoo Studio\"\n\n## After generation:\nRemind the user to:\n1. Navigate to the project directory\n2. Copy `.env.example` to `.env` and configure Odoo credentials\n3. Run `npm install` to install dependencies\n4. Run `npm run dev` to start development server\n5. Test the Odoo connection and sync functionality\n",
        "plugins/odoo-pwa-generator/commands/new-vue-pwa.md": "Generate a new offline-first Progressive Web App using Vue framework with Odoo Studio backend integration.\n\n## What this command does:\n- Invokes the `create-odoo-pwa` skill with Vue as the framework\n- Generates a complete PWA project with smart caching, offline support, and Odoo integration\n- Creates all necessary configuration files, components, composables, and deployment setups\n\n## Required Information:\nBefore starting, gather:\n1. **Project name** (kebab-case, e.g., \"expense-tracker\", \"inventory-manager\")\n2. **Odoo model name** (without `x_` prefix, e.g., \"expense\", \"inventory\")\n3. **Model display name** (human-readable, e.g., \"Expense\", \"Inventory Item\")\n4. **Deployment target** (optional: vercel, github, cloudflare, netlify)\n\n## Steps:\n1. Ask the user for the required information listed above\n2. Invoke the `create-odoo-pwa` skill with framework set to \"vue\"\n3. Generate the complete Vue PWA project structure\n4. Create comprehensive documentation (README.md, CLAUDE.md, API.md)\n5. Provide next steps for setup and deployment\n\n## Example prompts to use this command:\n- `/new-vue-pwa` - Interactive mode, will ask for all parameters\n- User: \"Create a Vue PWA for tracking expenses with Odoo\"\n- User: \"Generate an inventory management app using Vue and Odoo Studio\"\n\n## After generation:\nRemind the user to:\n1. Navigate to the project directory\n2. Copy `.env.example` to `.env` and configure Odoo credentials\n3. Run `npm install` to install dependencies\n4. Run `npm run dev` to start development server\n5. Test the Odoo connection and sync functionality\n",
        "plugins/odoo-pwa-generator/commands/optimize.md": "Analyze and optimize your Odoo PWA for performance, bundle size, and user experience.\n\n## What this command does:\n- Analyzes bundle size\n- Identifies performance bottlenecks\n- Suggests optimizations\n- Checks caching efficiency\n- Reviews PWA configuration\n- Provides actionable recommendations\n\n---\n\n## Quick Performance Check 🚀\n\n### Run These Commands:\n```bash\n# Build for production\nnpm run build\n\n# Analyze bundle size\nnpm run build -- --analyze\n\n# Preview production build\nnpm run preview\n\n# Run Lighthouse audit\n# (Chrome DevTools → Lighthouse tab)\n```\n\n---\n\n## Bundle Size Analysis 📦\n\n### Check Current Size\n```bash\n# Build and see output\nnpm run build\n\n# Typical output:\n# dist/index.html                   1.2 kB\n# dist/assets/index-abc123.js      45.3 kB\n# dist/assets/vendor-def456.js    120.5 kB\n```\n\n### Analyze Bundle Composition\n```bash\n# Install analyzer\nnpm install -D rollup-plugin-visualizer\n\n# Add to vite.config.js\nimport { visualizer } from 'rollup-plugin-visualizer';\n\nexport default {\n  plugins: [\n    // ...other plugins\n    visualizer({\n      open: true,\n      gzipSize: true,\n      brotliSize: true\n    })\n  ]\n};\n\n# Build and open report\nnpm run build\n# Opens stats.html in browser\n```\n\n### Target Bundle Sizes:\n- ✅ **Excellent**: < 200 KB (gzipped)\n- ⚠️ **Good**: 200-500 KB\n- ❌ **Needs Work**: > 500 KB\n\n---\n\n## Optimization Strategies\n\n### 1. Code Splitting 📂\n\n#### Lazy Load Routes\n**SvelteKit** (automatic):\n```javascript\n// Routes are auto-split\n// src/routes/+page.svelte → separate chunk\n```\n\n**React**:\n```javascript\nimport { lazy, Suspense } from 'react';\n\nconst ExpenseList = lazy(() => import('./ExpenseList'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <ExpenseList />\n    </Suspense>\n  );\n}\n```\n\n**Vue**:\n```javascript\nconst ExpenseList = () => import('./ExpenseList.vue');\n\nconst routes = [\n  {\n    path: '/expenses',\n    component: ExpenseList // Lazy loaded\n  }\n];\n```\n\n#### Manual Code Splitting\n```javascript\n// Split heavy utility into separate chunk\nconst heavyUtil = await import('./heavyUtility.js');\nheavyUtil.doSomething();\n```\n\n### 2. Tree Shaking 🌳\n\n#### Remove Unused Code\n```javascript\n// Bad: Imports everything\nimport * as utils from './utils';\n\n// Good: Import only what you need\nimport { formatDate, formatCurrency } from './utils';\n```\n\n#### Check for Unused Dependencies\n```bash\nnpm install -g depcheck\ndepcheck\n\n# Remove unused packages\nnpm uninstall <unused-package>\n```\n\n### 3. Optimize Dependencies 📚\n\n#### Use Lighter Alternatives\n```javascript\n// Instead of moment.js (heavy)\nimport moment from 'moment'; // 72 KB\n\n// Use date-fns (tree-shakeable)\nimport { format } from 'date-fns'; // ~2 KB\n\n// Or native Date\nnew Date().toLocaleDateString();\n```\n\n#### Common Heavy Packages & Alternatives:\n- ❌ **moment** (72 KB) → ✅ **date-fns** (tree-shakeable)\n- ❌ **lodash** (whole) → ✅ **lodash-es** (individual imports)\n- ❌ **axios** → ✅ **fetch** (built-in)\n- ❌ **uuid** → ✅ **crypto.randomUUID()** (built-in)\n\n### 4. Optimize Images 🖼️\n\n#### Compress Images\n```bash\n# Install image optimizer\nnpm install -D vite-plugin-imagemin\n\n# Add to vite.config.js\nimport viteImagemin from 'vite-plugin-imagemin';\n\nexport default {\n  plugins: [\n    viteImagemin({\n      gifsicle: { optimizationLevel: 7 },\n      optipng: { optimizationLevel: 7 },\n      mozjpeg: { quality: 80 },\n      svgo: { plugins: [{ removeViewBox: false }] }\n    })\n  ]\n};\n```\n\n#### Lazy Load Images\n```javascript\n// Native lazy loading\n<img src=\"large-image.jpg\" loading=\"lazy\" />\n\n// Or with IntersectionObserver\n```\n\n#### Use Appropriate Formats\n- **WebP** for photos (smaller than JPEG)\n- **SVG** for icons/logos\n- **PNG** only when transparency needed\n\n### 5. Minimize JavaScript ⚡\n\n#### Enable Minification (default in Vite)\n```javascript\n// vite.config.js\nexport default {\n  build: {\n    minify: 'terser', // or 'esbuild' (faster)\n    terserOptions: {\n      compress: {\n        drop_console: true, // Remove console.logs\n        drop_debugger: true\n      }\n    }\n  }\n};\n```\n\n#### Remove Development Code\n```javascript\n// Use environment variables\nif (import.meta.env.DEV) {\n  console.log('Debug info'); // Removed in production\n}\n```\n\n---\n\n## Caching Optimization 💾\n\n### 1. Optimize Cache Strategy\n\n#### Review Cache Settings\n```javascript\n// In cache store\nconst CACHE_VALIDITY = 5 * 60 * 1000; // 5 minutes\n\n// Consider your use case:\n// - Frequently changing data: 1-2 minutes\n// - Moderate updates: 5-10 minutes\n// - Rarely changes: 30-60 minutes\n```\n\n#### Limit Initial Load\n```javascript\n// Don't fetch everything at once\nconst records = await odoo.searchRecords(\n  model,\n  [],\n  fields,\n  100 // Limit to 100 records initially\n);\n\n// Load more on demand (pagination)\n```\n\n### 2. Optimize Sync Frequency\n```javascript\n// Adjust sync interval based on needs\nconst SYNC_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\n// Balance:\n// - More frequent: Better UX, more bandwidth\n// - Less frequent: Less bandwidth, slightly stale data\n```\n\n### 3. Selective Caching\n```javascript\n// Only cache fields you need\nconst fields = [\n  'x_studio_name',\n  'x_studio_amount',\n  'x_studio_date'\n  // Don't fetch unnecessary fields\n];\n```\n\n---\n\n## PWA Optimization 📱\n\n### 1. Service Worker Configuration\n\n#### Optimize Caching Strategy\n```javascript\n// In service worker or vite-plugin-pwa config\nVitePWA({\n  workbox: {\n    runtimeCaching: [\n      {\n        urlPattern: /^https:\\/\\/fonts\\.googleapis\\.com\\/.*/,\n        handler: 'CacheFirst',\n        options: {\n          cacheName: 'google-fonts',\n          expiration: {\n            maxEntries: 10,\n            maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year\n          }\n        }\n      },\n      {\n        urlPattern: /^https:\\/\\/.*\\.odoo\\.com\\/.*/,\n        handler: 'NetworkFirst',\n        options: {\n          cacheName: 'odoo-api',\n          networkTimeoutSeconds: 3\n        }\n      }\n    ]\n  }\n})\n```\n\n### 2. Optimize Manifest\n```json\n{\n  \"name\": \"Expense Tracker\",\n  \"short_name\": \"Expenses\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#0066cc\",\n  \"icons\": [\n    {\n      \"src\": \"/icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any maskable\"\n    },\n    {\n      \"src\": \"/icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n```\n\n### 3. Optimize Icons\n```bash\n# Use optimized PNG or WebP\n# Compress images\n# Provide multiple sizes\n```\n\n---\n\n## Network Optimization 🌐\n\n### 1. Reduce API Calls\n\n#### Batch Requests\n```javascript\n// Bad: Multiple calls\nconst expenses = await fetchExpenses();\nconst tasks = await fetchTasks();\nconst partners = await fetchPartners();\n\n// Good: Single call (if Odoo supports)\nconst data = await fetchAll(['expenses', 'tasks', 'partners']);\n```\n\n#### Cache Partner Names\n```javascript\n// Fetch once, reuse\nconst partners = await odoo.fetchPartners();\nlocalStorage.setItem('partnerCache', JSON.stringify(partners));\n\n// Later, use cached data\nconst cached = JSON.parse(localStorage.getItem('partnerCache'));\n```\n\n### 2. Incremental Loading\n```javascript\n// Load initial data\nconst initial = await fetchExpenses({ limit: 20 });\n\n// Load more on scroll\nfunction onScroll() {\n  if (nearBottom) {\n    loadMore();\n  }\n}\n```\n\n### 3. Optimize Requests\n```javascript\n// Only fetch fields you display\nconst fields = ['id', 'x_studio_name', 'x_studio_amount'];\n\n// Use appropriate domain filters\nconst domain = [\n  ['x_studio_date', '>=', lastMonth],\n  ['x_studio_status', '!=', 'deleted']\n];\n```\n\n---\n\n## UI Performance 🎨\n\n### 1. Virtual Scrolling\nFor long lists:\n```javascript\n// SvelteKit\nimport { VirtualList } from 'svelte-virtual-list';\n\n<VirtualList items={expenses} let:item>\n  <ExpenseCard expense={item} />\n</VirtualList>\n\n// React\nimport { FixedSizeList } from 'react-window';\n\n// Vue\nimport { RecycleScroller } from 'vue-virtual-scroller';\n```\n\n### 2. Debounce Search\n```javascript\nimport { debounce } from './utils';\n\nconst handleSearch = debounce((query) => {\n  searchExpenses(query);\n}, 300); // Wait 300ms after typing stops\n```\n\n### 3. Optimize Rendering\n```javascript\n// SvelteKit: Use keyed each blocks\n{#each expenses as expense (expense.id)}\n  <ExpenseCard {expense} />\n{/each}\n\n// React: Use keys and memo\nconst ExpenseCard = memo(({ expense }) => {\n  // ...\n});\n\nexpenses.map(expense => (\n  <ExpenseCard key={expense.id} expense={expense} />\n));\n\n// Vue: Use v-memo\n<ExpenseCard\n  v-for=\"expense in expenses\"\n  :key=\"expense.id\"\n  :expense=\"expense\"\n  v-memo=\"[expense.id]\"\n/>\n```\n\n---\n\n## Build Optimization 🔨\n\n### Vite Config Optimizations\n```javascript\n// vite.config.js\nexport default {\n  build: {\n    // Target modern browsers\n    target: 'es2020',\n\n    // Optimize chunks\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          vendor: ['svelte', '@sveltejs/kit'],\n          odoo: ['./src/lib/odoo.js', './src/lib/stores']\n        }\n      }\n    },\n\n    // Compression\n    minify: 'esbuild', // Faster than terser\n\n    // Source maps (only for debugging)\n    sourcemap: false\n  },\n\n  // Optimize dependencies\n  optimizeDeps: {\n    include: ['date-fns', 'lodash-es']\n  }\n};\n```\n\n---\n\n## Lighthouse Audit 💡\n\n### Run Lighthouse\n1. Open Chrome DevTools\n2. Go to Lighthouse tab\n3. Select categories:\n   - ✅ Performance\n   - ✅ Progressive Web App\n   - ✅ Best Practices\n   - ✅ Accessibility\n   - ✅ SEO\n4. Click \"Analyze page load\"\n\n### Target Scores:\n- **Performance**: > 90\n- **PWA**: 100\n- **Best Practices**: > 95\n- **Accessibility**: > 90\n- **SEO**: > 90\n\n### Common Issues & Fixes:\n\n#### Low Performance Score\n- Reduce bundle size\n- Optimize images\n- Enable caching\n- Lazy load resources\n\n#### PWA Issues\n- Fix manifest.json\n- Register service worker\n- Add offline support\n- Provide app icons\n\n#### Accessibility Issues\n- Add alt text to images\n- Use semantic HTML\n- Ensure color contrast\n- Add ARIA labels\n\n---\n\n## Performance Monitoring 📊\n\n### Add Performance Tracking\n```javascript\n// Measure initial load\nwindow.addEventListener('load', () => {\n  const perfData = performance.getEntriesByType('navigation')[0];\n\n  console.log('Load time:', perfData.loadEventEnd - perfData.fetchStart);\n  console.log('DOM ready:', perfData.domContentLoadedEventEnd - perfData.fetchStart);\n});\n\n// Measure sync time\nconsole.time('sync');\nawait expenseCache.refresh();\nconsole.timeEnd('sync');\n```\n\n### Use Web Vitals\n```bash\nnpm install web-vitals\n\n# In app\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\ngetCLS(console.log);\ngetFID(console.log);\ngetFCP(console.log);\ngetLCP(console.log);\ngetTTFB(console.log);\n```\n\n---\n\n## Optimization Checklist ✅\n\n### Bundle Size:\n```\n□ Analyzed bundle composition\n□ Removed unused dependencies\n□ Lazy loaded routes/components\n□ Optimized images\n□ Tree-shaking enabled\n□ Minification enabled\n□ Total size < 500 KB (gzipped)\n```\n\n### Caching:\n```\n□ Optimal cache validity period\n□ Incremental sync working\n□ Selective field fetching\n□ Partner name caching\n□ Appropriate sync frequency\n□ IndexedDB optimized\n```\n\n### PWA:\n```\n□ Service worker registered\n□ Offline mode works\n□ App installable\n□ Icons optimized\n□ Manifest configured\n□ Fast load time\n```\n\n### Performance:\n```\n□ Lighthouse score > 90\n□ Initial load < 3s\n□ Sync time < 2s\n□ No console errors\n□ Smooth scrolling\n□ Fast navigation\n```\n\n---\n\n## Example prompts to use this command:\n- `/optimize` - Run optimization checks\n- User: \"Make my app faster\"\n- User: \"Reduce bundle size\"\n- User: \"Optimize performance\"\n\n## Related Commands:\n- `/test-connection` - Test after optimization\n- `/update-deps` - Update to faster versions\n- `/troubleshoot` - Fix performance issues\n- `/help` - More information\n\n---\n\n## Quick Wins 🎯\n\n### Immediate Optimizations:\n1. **Enable compression** (already in Vite)\n2. **Remove console.logs** in production\n3. **Lazy load routes** (easy with frameworks)\n4. **Optimize images** (use WebP)\n5. **Limit initial data fetch** (pagination)\n\n### Medium Effort:\n1. **Analyze and split bundles**\n2. **Replace heavy dependencies**\n3. **Implement virtual scrolling**\n4. **Optimize service worker**\n5. **Add performance monitoring**\n\n### Long Term:\n1. **Regular Lighthouse audits**\n2. **Monitor real user metrics**\n3. **Continuous optimization**\n4. **Keep dependencies updated**\n5. **Review and refactor regularly**\n",
        "plugins/odoo-pwa-generator/commands/setup-env.md": "Interactive setup wizard for configuring Odoo PWA environment variables.\n\n## What this command does:\n- Guides the user through setting up their `.env` file\n- Validates Odoo connection credentials\n- Tests API connectivity\n- Configures model-specific settings\n- Provides troubleshooting help if connection fails\n\n## Required Information:\nGather from the user:\n1. **Odoo Instance URL** (e.g., \"https://yourcompany.odoo.com\")\n2. **Database Name** (e.g., \"yourcompany-main\")\n3. **API Key** (from Odoo user preferences)\n4. **Username/Email** (Odoo user email)\n5. **Primary Model Name** (e.g., \"x_expense\", \"x_inventory\")\n\n## Steps:\n1. Check if `.env.example` exists in the current directory\n2. If not, ask if this is an Odoo PWA project\n3. Ask the user for each environment variable interactively\n4. Validate URL format (must start with http:// or https://)\n5. Create or update `.env` file with the provided values\n6. Test the connection by making a simple API call to Odoo\n7. If connection fails, provide troubleshooting steps\n8. Display success message with next steps\n\n## Environment Variables to Set:\n```bash\n# Odoo Instance Configuration\nVITE_ODOO_URL=https://yourcompany.odoo.com\nVITE_ODOO_DB=yourcompany-main\n\n# Authentication (keep these secret!)\nODOO_API_KEY=your_api_key_here\nODOO_USERNAME=your.email@company.com\n\n# Model Configuration\nVITE_MODEL_NAME=x_expense\nVITE_MODEL_DISPLAY_NAME=Expense\n```\n\n## Validation Tests:\nAfter creating `.env`, run these checks:\n1. Test Odoo URL is reachable\n2. Verify API key is valid\n3. Check if the model exists in Odoo\n4. Test read permissions on the model\n5. Verify required fields are accessible\n\n## Example prompts to use this command:\n- `/setup-env` - Interactive setup wizard\n- User: \"Help me configure my Odoo credentials\"\n- User: \"Set up environment variables for Odoo PWA\"\n\n## Security Reminders:\nAfter setup, remind the user:\n1. ✅ `.env` should be in `.gitignore` (verify this)\n2. ✅ Never commit API keys to version control\n3. ✅ Use different credentials for development and production\n4. ✅ For deployment, set environment variables in the hosting platform\n5. ✅ Rotate API keys periodically\n\n## Troubleshooting Common Issues:\n\n### Connection Failed\n- Verify Odoo URL is correct and accessible\n- Check if API key is valid (generate new one in Odoo)\n- Ensure username matches the API key owner\n- Check firewall/network restrictions\n\n### Model Not Found\n- Verify the model exists in Odoo Studio\n- Check model name has `x_` prefix\n- Ensure user has access permissions to the model\n\n### Authentication Error\n- Regenerate API key in Odoo (Settings → Users → API Keys)\n- Verify database name is correct\n- Check if account is active and not locked\n\n## After Setup:\nRemind the user to:\n1. Restart the development server to load new environment variables\n2. Test the application and verify data loads correctly\n3. Keep the `.env.example` file updated for team members\n4. Document any custom configuration in project README\n",
        "plugins/odoo-pwa-generator/commands/test-connection.md": "Test Odoo API connection and sync functionality to diagnose issues.\n\n## What this command does:\n- Validates Odoo connection credentials\n- Tests API authentication\n- Verifies model access and permissions\n- Checks sync functionality\n- Runs diagnostic tests on cache stores\n- Provides detailed error reporting and solutions\n\n## Prerequisites:\nBefore testing, ensure:\n1. ✅ `.env` file exists and is configured\n2. ✅ Current directory is an Odoo PWA project\n3. ✅ Development server can be started\n4. ✅ Internet connection is available\n\n## Diagnostic Tests to Run:\n\n### 1. Environment Configuration Check\nVerify all required environment variables are set:\n- `VITE_ODOO_URL` - Odoo instance URL\n- `VITE_ODOO_DB` - Database name\n- `ODOO_API_KEY` - API authentication key\n- `ODOO_USERNAME` - User email/username\n- `VITE_MODEL_NAME` - Primary model name\n\n### 2. Network Connectivity Test\n```bash\n# Test if Odoo URL is reachable\ncurl -I [ODOO_URL]\n```\n\nExpected: HTTP 200 or 301/302 redirect\n\n### 3. API Authentication Test\nMake a test API call to verify credentials:\n```javascript\nPOST /api/odoo\n{\n  \"action\": \"search\",\n  \"model\": \"res.partner\",\n  \"domain\": [],\n  \"fields\": [\"id\", \"name\"],\n  \"limit\": 1\n}\n```\n\nExpected: Returns at least one partner record\n\n### 4. Model Access Test\nVerify the configured model exists and is accessible:\n```javascript\nPOST /api/odoo\n{\n  \"action\": \"search_model\",\n  \"model\": \"[VITE_MODEL_NAME]\",\n  \"domain\": [],\n  \"fields\": [\"id\"],\n  \"limit\": 1\n}\n```\n\nExpected: Returns records or empty array (not an error)\n\n### 5. CRUD Operations Test\nTest each operation:\n- **Create**: Create a test record\n- **Read**: Fetch the created record\n- **Update**: Modify the record\n- **Delete**: Remove the test record\n\n### 6. Cache Functionality Test\nVerify cache stores work correctly:\n- localStorage read/write\n- IndexedDB read/write\n- Cache expiration logic\n- Sync mechanism\n\n### 7. Sync Performance Test\nMeasure sync performance:\n- Initial load time\n- Incremental sync time\n- Number of records synced\n- Network request count\n\n## Steps:\n1. Read and validate `.env` file\n2. Parse environment variables\n3. Run each diagnostic test in sequence\n4. Log results with timestamps\n5. Identify failing tests\n6. Provide specific solutions for failures\n7. Generate diagnostic report\n\n## Output Format:\n```\n🧪 Odoo PWA Connection Diagnostics\n================================\n\n✅ Environment Configuration: PASSED\n   - ODOO_URL: https://yourcompany.odoo.com\n   - DATABASE: yourcompany-main\n   - MODEL: x_expense\n\n✅ Network Connectivity: PASSED\n   - Odoo server reachable\n   - Response time: 234ms\n\n✅ API Authentication: PASSED\n   - API key valid\n   - User authenticated: your.email@company.com\n\n✅ Model Access: PASSED\n   - Model exists: x_expense\n   - Read permission: Yes\n   - Write permission: Yes\n\n✅ CRUD Operations: PASSED\n   - Create: ✅ Record created (ID: 123)\n   - Read: ✅ Record fetched\n   - Update: ✅ Record updated\n   - Delete: ✅ Record deleted\n\n✅ Cache Functionality: PASSED\n   - localStorage: Working\n   - IndexedDB: Working\n   - Sync interval: 3 minutes\n\n✅ Sync Performance: PASSED\n   - Initial load: 1.2s (45 records)\n   - Incremental sync: 0.3s (2 new records)\n   - Network requests: 3\n\n================================\n🎉 All tests passed! Your Odoo PWA is working correctly.\n```\n\n## Example prompts to use this command:\n- `/test-connection` - Run full diagnostic suite\n- User: \"Test my Odoo connection\"\n- User: \"Why isn't data syncing from Odoo?\"\n- User: \"Diagnose Odoo API issues\"\n\n## Common Issues and Solutions:\n\n### ❌ Connection Failed\n**Error**: Cannot reach Odoo URL\n**Solutions**:\n- Verify URL is correct (include https://)\n- Check internet connection\n- Test URL in browser\n- Check firewall/VPN settings\n\n### ❌ Authentication Failed\n**Error**: Invalid API key or credentials\n**Solutions**:\n- Regenerate API key in Odoo (Settings → Users → API Keys)\n- Verify username matches API key owner\n- Check for typos in `.env` file\n- Ensure API key has not expired\n\n### ❌ Model Not Found\n**Error**: Model doesn't exist or no access\n**Solutions**:\n- Verify model exists in Odoo Studio\n- Check model name includes `x_` prefix\n- Verify user has read/write permissions\n- Check model is published (not in draft mode)\n\n### ❌ CORS Error\n**Error**: Blocked by CORS policy\n**Solutions**:\n- Use server-side API proxy (recommended)\n- Configure CORS in Odoo (not recommended)\n- Check API route is working correctly\n\n### ❌ Sync Not Working\n**Error**: Records not updating\n**Solutions**:\n- Check browser console for errors\n- Verify sync interval is running\n- Clear cache and try again\n- Check Odoo server is not down\n\n### ❌ Permission Denied\n**Error**: Cannot create/update records\n**Solutions**:\n- Verify user has write permission on model\n- Check required fields are included\n- Verify field types match expectations\n- Check for validation rules in Odoo\n\n## Development Tools:\nProvide user with helpful commands:\n```bash\n# Watch network requests\n# Open browser DevTools → Network tab\n\n# View cache contents\nlocalStorage.getItem('[model]Cache')\n\n# Force cache clear\nlocalStorage.clear()\n\n# Monitor sync in console\n# Look for \"Syncing...\" messages\n```\n\n## After Testing:\nIf all tests pass:\n- Confirm the application is working correctly\n- Suggest running tests periodically\n- Recommend monitoring in production\n\nIf tests fail:\n- Provide specific error messages\n- Offer step-by-step troubleshooting\n- Suggest checking Odoo server logs\n- Offer to help fix configuration\n\n## Advanced Diagnostics:\nFor complex issues:\n1. Export full diagnostic report\n2. Check Odoo server logs\n3. Review browser console errors\n4. Analyze network traffic\n5. Test with different API keys\n6. Try with different models\n7. Compare with working examples\n",
        "plugins/odoo-pwa-generator/commands/troubleshoot.md": "Common issues and solutions for Odoo PWA projects.\n\n## What this command does:\n- Lists common problems and their solutions\n- Provides step-by-step debugging guides\n- Offers troubleshooting workflows\n- Helps diagnose connection, sync, and build issues\n- Links to relevant documentation and tools\n\n---\n\n## Quick Diagnostic Checklist ✅\n\nBefore diving into specific issues, run through this checklist:\n\n```\n□ .env file exists and has all required variables\n□ Odoo URL is correct and reachable\n□ API key is valid and not expired\n□ Database name is correct\n□ Model name includes x_ prefix\n□ Development server is running\n□ No errors in browser console\n□ Internet connection is working\n□ Node.js version is 18 or higher\n```\n\n**Quick Test:** Run `/test-connection` to diagnose most issues automatically.\n\n---\n\n## Connection Issues 🔌\n\n### Problem: Cannot connect to Odoo\n**Symptoms:**\n- \"Connection refused\" error\n- \"Network error\" in console\n- Timeout errors\n- No data loading\n\n**Solutions:**\n\n#### 1. Verify Odoo URL\n```bash\n# Test if URL is reachable\ncurl -I https://yourcompany.odoo.com\n\n# Expected: HTTP 200 or 301/302\n```\n\n**Common mistakes:**\n- Missing `https://`\n- Extra trailing slash\n- Wrong subdomain\n- Typo in URL\n\n**Fix:**\n```bash\n# Wrong\nVITE_ODOO_URL=yourcompany.odoo.com\nVITE_ODOO_URL=https://yourcompany.odoo.com/\n\n# Right\nVITE_ODOO_URL=https://yourcompany.odoo.com\n```\n\n#### 2. Check firewall / VPN\n- Try accessing Odoo URL in browser\n- Disable VPN temporarily\n- Check corporate firewall rules\n- Try from different network\n\n#### 3. Verify environment variables loaded\n```javascript\n// Add to your code temporarily\nconsole.log('Odoo URL:', import.meta.env.VITE_ODOO_URL);\nconsole.log('Database:', import.meta.env.VITE_ODOO_DB);\n```\n\n**If undefined:**\n- Restart development server\n- Check variable names (case-sensitive)\n- Ensure variables start with `VITE_`\n\n---\n\n## Authentication Issues 🔐\n\n### Problem: Invalid API key / Authentication failed\n**Symptoms:**\n- \"Invalid credentials\" error\n- \"Access denied\" message\n- 401 Unauthorized errors\n- UID is null\n\n**Solutions:**\n\n#### 1. Regenerate API Key\n1. Log into Odoo\n2. Go to Settings → Users & Companies → Users\n3. Open your user record\n4. Go to \"API Keys\" tab\n5. Click \"New API Key\"\n6. Copy the key immediately (shown only once!)\n7. Update `.env` file:\n```bash\nODOO_API_KEY=your_new_api_key_here\n```\n8. Restart development server\n\n#### 2. Verify username matches\n```bash\n# Username must match the API key owner\nODOO_USERNAME=john.doe@company.com  # ✅ Correct\nODOO_USERNAME=John Doe              # ❌ Wrong\n```\n\n#### 3. Check user permissions\n- Ensure user has access to the model\n- Verify read/write permissions\n- Check if user account is active\n- Verify not locked out\n\n#### 4. Test authentication manually\n```javascript\n// In browser console\nfetch('/api/odoo', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    action: 'search',\n    model: 'res.partner',\n    domain: [],\n    fields: ['name'],\n    limit: 1\n  })\n})\n.then(r => r.json())\n.then(console.log);\n```\n\n---\n\n## Model Access Issues 📋\n\n### Problem: Model not found / No records returned\n**Symptoms:**\n- \"Model does not exist\" error\n- Empty array returned\n- \"Access rights\" error\n- Records don't appear\n\n**Solutions:**\n\n#### 1. Verify model name\n```bash\n# Check model name includes x_ prefix\nVITE_MODEL_NAME=x_expense  # ✅ Correct\nVITE_MODEL_NAME=expense    # ❌ Wrong\n```\n\n#### 2. Check model exists in Odoo\n1. Log into Odoo\n2. Go to Settings → Technical → Database Structure → Models\n3. Search for your model name\n4. Verify it exists and is active\n\n#### 3. Check field names\n```javascript\n// Fields must use full name with x_studio_ prefix\nconst fields = [\n  'x_studio_name',      // ✅ Correct\n  'x_studio_amount',    // ✅ Correct\n  'name',               // ❌ Wrong (unless it's a standard field)\n  'amount'              // ❌ Wrong\n];\n```\n\n#### 4. Verify permissions\n- User must have read access to model\n- Check access rights in Odoo Studio\n- Verify record rules don't filter all records\n- Test with admin user\n\n#### 5. Check if model is published\n- In Odoo Studio, verify model is not in draft mode\n- Ensure model is accessible via API\n- Check if model requires special access\n\n---\n\n## Sync Issues 🔄\n\n### Problem: Data not syncing\n**Symptoms:**\n- Old data displayed\n- Changes don't appear\n- \"Last synced\" time not updating\n- Background sync not working\n\n**Solutions:**\n\n#### 1. Check browser console\nLook for:\n- Network errors\n- JavaScript errors\n- CORS errors\n- Authentication errors\n\n#### 2. Verify sync mechanism\n```javascript\n// Check if sync is running\n// Look for these console logs:\n\"Syncing x_expense...\"\n\"Fetched X new records\"\n\"Cache updated\"\n```\n\n#### 3. Force refresh\n```javascript\n// In browser console\nexpenseCache.refresh();\n```\n\n#### 4. Clear cache and reload\n```javascript\n// In browser console\nlocalStorage.clear();\n// Then refresh page\n```\n\n#### 5. Check sync interval\n```javascript\n// Verify sync timer is running\n// Default: 3 minutes (180,000ms)\n// Look in cache store for:\nsetInterval(() => sync(), 180000);\n```\n\n#### 6. Test incremental sync\n```javascript\n// Check lastRecordId is updating\nconst cacheData = localStorage.getItem('expenseCache');\nconsole.log(JSON.parse(cacheData));\n// Should show: { lastRecordId: X, lastSyncTime: Y }\n```\n\n---\n\n## Offline Mode Issues 📵\n\n### Problem: Offline mode not working\n**Symptoms:**\n- App doesn't work without internet\n- \"No connection\" errors when offline\n- Service worker not registered\n- Data not available offline\n\n**Solutions:**\n\n#### 1. Verify service worker registered\n```javascript\n// In browser console\nnavigator.serviceWorker.getRegistration()\n  .then(reg => console.log('Service Worker:', reg));\n```\n\n#### 2. Check cache stores\n```javascript\n// Verify data is cached\nlocalStorage.getItem('expenseCache');\n// Should return JSON string\n\n// Check IndexedDB\n// Open DevTools → Application → IndexedDB\n// Look for your database and tables\n```\n\n#### 3. Test offline mode\n1. Load app while online\n2. Open DevTools → Network tab\n3. Enable \"Offline\" checkbox\n4. Refresh page\n5. App should still work\n\n#### 4. Build and test production\n```bash\n# Offline mode works better in production build\nnpm run build\nnpm run preview\n```\n\n#### 5. Check manifest.json\nVerify PWA manifest is correct:\n- Located in `/static/manifest.json`\n- Has correct `start_url`\n- Has valid icons\n\n---\n\n## Build / Deployment Issues 🚀\n\n### Problem: Build fails\n**Symptoms:**\n- `npm run build` returns errors\n- TypeScript errors\n- Module not found errors\n- Build process hangs\n\n**Solutions:**\n\n#### 1. Check Node version\n```bash\nnode --version\n# Must be v18 or higher\n\n# If too old:\nnvm install 18\nnvm use 18\n```\n\n#### 2. Clean install\n```bash\nrm -rf node_modules package-lock.json\nnpm install\n```\n\n#### 3. Check for errors\n```bash\n# Run build with verbose output\nnpm run build -- --verbose\n```\n\n#### 4. Verify environment variables\n```bash\n# For production build, set env vars:\nVITE_ODOO_URL=https://yourcompany.odoo.com \\\nVITE_ODOO_DB=yourcompany-main \\\nnpm run build\n```\n\n#### 5. Check imports\n- Verify all imports are correct\n- Check for circular dependencies\n- Ensure all files exist\n\n---\n\n### Problem: Deployment fails\n**Symptoms:**\n- Vercel/Netlify build fails\n- Environment variables not working\n- 404 errors in production\n- Blank page after deployment\n\n**Solutions:**\n\n#### 1. Set environment variables\nIn hosting dashboard:\n- Add all `VITE_*` variables\n- Add `ODOO_API_KEY`\n- Add `ODOO_USERNAME`\n- Redeploy after adding\n\n#### 2. Check build logs\n- Review deployment logs\n- Look for specific errors\n- Check Node version in platform\n\n#### 3. Test build locally\n```bash\nnpm run build\nnpm run preview\n# Test at http://localhost:4173\n```\n\n#### 4. Verify base path\n```javascript\n// For GitHub Pages or subpath deployment\n// vite.config.js\nexport default {\n  base: '/your-repo-name/'\n};\n```\n\n#### 5. Check API routes\n- Ensure serverless functions deploy correctly\n- Verify function size < 50MB\n- Check function logs in platform dashboard\n\n---\n\n## Performance Issues ⚡\n\n### Problem: App is slow\n**Symptoms:**\n- Slow initial load\n- Laggy UI\n- Long sync times\n- High memory usage\n\n**Solutions:**\n\n#### 1. Optimize initial load\n```javascript\n// Limit initial fetch\nconst records = await odoo.searchRecords(\n  model,\n  [],\n  fields,\n  100  // Only fetch first 100\n);\n```\n\n#### 2. Add pagination\n```javascript\n// Load more on scroll\nlet page = 1;\nconst pageSize = 20;\n\nasync function loadMore() {\n  const offset = (page - 1) * pageSize;\n  const more = await odoo.searchRecords(\n    model, [], fields, pageSize, offset\n  );\n  page++;\n  return more;\n}\n```\n\n#### 3. Optimize bundle size\n```bash\n# Analyze bundle\nnpm run build -- --analyze\n\n# Lazy load routes\n// SvelteKit (automatic)\n// React\nconst ExpenseList = lazy(() => import('./ExpenseList'));\n\n// Vue\nconst ExpenseList = () => import('./ExpenseList.vue');\n```\n\n#### 4. Reduce sync frequency\n```javascript\n// Increase sync interval\nconst SYNC_INTERVAL = 5 * 60 * 1000; // 5 minutes instead of 3\n```\n\n#### 5. Optimize images\n- Compress images before upload\n- Use appropriate image formats\n- Lazy load images\n\n---\n\n## Data Issues 📊\n\n### Problem: Wrong data displayed\n**Symptoms:**\n- Incorrect values shown\n- Missing fields\n- Corrupted data\n- Date format issues\n\n**Solutions:**\n\n#### 1. Clear cache\n```javascript\nexpenseCache.clearCache();\nexpenseCache.refresh();\n```\n\n#### 2. Verify field mapping\n```javascript\n// Check if fields are correctly named\nconsole.log(records[0]);\n// Should show x_studio_* fields\n```\n\n#### 3. Check data types\n```javascript\n// Ensure correct types\nconst expense = {\n  x_studio_amount: 45.50,        // number ✅\n  x_studio_date: '2025-01-15',   // string (ISO) ✅\n  x_studio_employee: [12, false] // Many2one ✅\n};\n```\n\n#### 4. Format dates correctly\n```javascript\n// Store as ISO string\nconst dateString = '2025-01-15';\n\n// Display formatted\nnew Date(dateString).toLocaleDateString();\n```\n\n#### 5. Handle Many2one fields\n```javascript\n// Many2one can be [id, name] or just id\nfunction getPartnerId(field) {\n  return Array.isArray(field) ? field[0] : field;\n}\n\nfunction getPartnerName(field) {\n  return Array.isArray(field) ? field[1] : null;\n}\n```\n\n---\n\n## CORS Issues 🚫\n\n### Problem: CORS error\n**Symptoms:**\n- \"Blocked by CORS policy\" in console\n- Requests fail in browser but work in Postman\n- Preflight errors (OPTIONS)\n\n**Solutions:**\n\n#### 1. Use server-side proxy (recommended)\nAll generated PWAs include server-side API routes. Ensure you're using them:\n```javascript\n// ✅ Good: Goes through server proxy\nfetch('/api/odoo', { ... });\n\n// ❌ Bad: Direct call to Odoo (CORS error)\nfetch('https://yourcompany.odoo.com/jsonrpc', { ... });\n```\n\n#### 2. Verify API route works\n```javascript\n// Test in browser console\nfetch('/api/odoo', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    action: 'search',\n    model: 'res.partner',\n    domain: [],\n    fields: ['name'],\n    limit: 1\n  })\n})\n.then(r => r.json())\n.then(console.log);\n```\n\n#### 3. Check if deployed correctly\n- Verify serverless functions deployed\n- Check function logs\n- Ensure environment variables set\n\n---\n\n## Browser-Specific Issues 🌐\n\n### Problem: Works in Chrome but not Safari/Firefox\n**Symptoms:**\n- Different behavior across browsers\n- Safari-specific errors\n- Mobile browser issues\n\n**Solutions:**\n\n#### 1. Check browser compatibility\n- Test in multiple browsers\n- Check for console errors in each\n- Verify IndexedDB support\n\n#### 2. Safari-specific\n- Safari has stricter storage limits\n- Check if localStorage/IndexedDB working\n- Test in private mode\n\n#### 3. Mobile browsers\n- Test on actual devices\n- Check responsive design\n- Verify touch interactions work\n\n---\n\n## Debugging Tools & Commands 🔧\n\n### Essential Commands\n```bash\n# Test connection\n/test-connection\n\n# View full help\n/help\n\n# See architecture details\n/architecture\n\n# Clear cache and start fresh\n/clear-cache\n\n# Fix sync issues\n/fix-sync\n```\n\n### Browser DevTools\n```javascript\n// Network tab\n// - See all API calls\n// - Check request/response\n// - View timing\n\n// Console tab\n// - See error messages\n// - Run test commands\n// - Inspect data\n\n// Application tab\n// - View localStorage\n// - Inspect IndexedDB\n// - Check Service Workers\n// - View Cache Storage\n\n// Performance tab\n// - Profile slow operations\n// - Find bottlenecks\n```\n\n### Useful Console Commands\n```javascript\n// View cache\nlocalStorage.getItem('expenseCache');\n\n// Clear cache\nlocalStorage.clear();\n\n// Force refresh\nexpenseCache.refresh();\n\n// View current records\nconsole.log($expenseCache); // SvelteKit\n\n// Test API\nfetch('/api/odoo', { /* ... */ })\n  .then(r => r.json())\n  .then(console.log);\n```\n\n---\n\n## Getting Help 💬\n\n### Before asking for help:\n1. Run `/test-connection`\n2. Check browser console for errors\n3. Review this troubleshooting guide\n4. Try solutions listed above\n5. Test with minimal example\n\n### When reporting issues:\nInclude:\n- Exact error message\n- Browser and version\n- Node.js version\n- Steps to reproduce\n- What you've already tried\n- Relevant code snippets\n\n### Helpful resources:\n- `/help` - Plugin documentation\n- `/examples` - Usage examples\n- `/architecture` - Design patterns\n- `/api-reference` - API documentation\n- Odoo docs: https://www.odoo.com/documentation/\n- Framework docs (SvelteKit/React/Vue)\n\n---\n\n## Example prompts to use this command:\n- `/troubleshoot` - Show troubleshooting guide\n- User: \"Why isn't my data syncing?\"\n- User: \"I'm getting a connection error\"\n- User: \"Help! Nothing works!\"\n\n## Still Stuck?\nIf these solutions don't help:\n1. Run `/test-connection` for detailed diagnostics\n2. Check generated project's CLAUDE.md\n3. Review Odoo server logs\n4. Test with different Odoo model\n5. Try generating fresh project to compare\n\nMost issues are related to configuration or permissions. Double-check your `.env` file and Odoo settings!\n",
        "plugins/odoo-pwa-generator/commands/update-deps.md": "Update dependencies in your Odoo PWA project to latest compatible versions.\n\n## What this command does:\n- Checks for outdated dependencies\n- Updates packages to latest versions\n- Tests the application after updates\n- Fixes breaking changes if needed\n- Updates lock files\n- Verifies everything still works\n\n## Prerequisites:\n- Current directory is an Odoo PWA project\n- Git repository (recommended for easy rollback)\n- Latest npm installed\n\n---\n\n## Update Strategy\n\n### Safe Update (Recommended)\nUpdates to latest compatible versions within semver ranges.\n\n```bash\nnpm update\n```\n\n### Major Update (Requires testing)\nUpdates to latest versions including major releases.\n\n```bash\nnpm outdated  # See what's outdated\nnpm update    # Update minor/patch\nnpx npm-check-updates -u  # Update majors\nnpm install\n```\n\n---\n\n## Steps:\n\n### 1. Check Current Status\n```bash\n# See current versions\nnpm list --depth=0\n\n# See outdated packages\nnpm outdated\n```\n\n### 2. Create Backup\n```bash\n# Commit current state\ngit add .\ngit commit -m \"Pre-dependency update checkpoint\"\n\n# Or backup package files\ncp package.json package.json.backup\ncp package-lock.json package-lock.json.backup\n```\n\n### 3. Update Dependencies\n\n#### Minor/Patch Updates (Safe)\n```bash\nnpm update\nnpm install\n```\n\n#### Major Updates (Test carefully)\n```bash\n# Install npm-check-updates if needed\nnpm install -g npm-check-updates\n\n# Preview updates\nncu\n\n# Update package.json\nncu -u\n\n# Install new versions\nnpm install\n```\n\n### 4. Framework-Specific Updates\n\n#### SvelteKit\n```bash\n# Update Svelte + SvelteKit\nnpm update @sveltejs/kit @sveltejs/adapter-static\nnpm update svelte\n\n# Check for breaking changes\n# https://github.com/sveltejs/kit/blob/master/CHANGELOG.md\n```\n\n#### React\n```bash\n# Update React\nnpm update react react-dom\n\n# Update related packages\nnpm update @types/react @types/react-dom\n```\n\n#### Vue\n```bash\n# Update Vue\nnpm update vue\n\n# Update related packages\nnpm update @vitejs/plugin-vue\n```\n\n### 5. Update Build Tools\n```bash\n# Update Vite\nnpm update vite\n\n# Update PWA plugin\nnpm update vite-plugin-pwa @vite-pwa/sveltekit\n```\n\n### 6. Test Everything\n\n#### Run Development Server\n```bash\nnpm run dev\n```\n\nCheck:\n- ✅ Server starts without errors\n- ✅ App loads correctly\n- ✅ No console errors\n- ✅ All routes work\n\n#### Test Core Functionality\n- ✅ Odoo connection works\n- ✅ Data loads from cache\n- ✅ Sync works\n- ✅ CRUD operations work\n- ✅ Offline mode works\n\n#### Build for Production\n```bash\nnpm run build\n```\n\nCheck:\n- ✅ Build completes without errors\n- ✅ No warnings about deprecations\n- ✅ Bundle size is reasonable\n\n#### Preview Production Build\n```bash\nnpm run preview\n```\n\nTest the same functionality in production mode.\n\n### 7. Run Connection Test\n```bash\n# If /test-connection command is available\n/test-connection\n```\n\n### 8. Commit Changes\n```bash\ngit add package.json package-lock.json\ngit commit -m \"Update dependencies to latest versions\"\n```\n\n---\n\n## Common Issues & Solutions\n\n### Issue: Build fails after update\n\n**Solution:**\n```bash\n# Revert updates\ngit checkout package.json package-lock.json\nnpm install\n\n# Try updating one package at a time\nnpm update vite\nnpm run build  # Test\n\nnpm update @sveltejs/kit\nnpm run build  # Test\n\n# Continue one by one\n```\n\n### Issue: TypeScript errors\n\n**Solution:**\n```bash\n# Update TypeScript\nnpm update typescript\n\n# Update type definitions\nnpm update @types/node\n\n# Regenerate tsconfig\nnpx tsc --init\n```\n\n### Issue: Import errors\n\n**Solution:**\n```javascript\n// Old import might be:\nimport { foo } from 'package';\n\n// New import might be:\nimport { foo } from 'package/foo';\n\n// Check package's CHANGELOG for migration guide\n```\n\n### Issue: Service Worker errors\n\n**Solution:**\n```bash\n# Update PWA plugin\nnpm update vite-plugin-pwa\n\n# Check configuration\n# vite.config.js\nVitePWA({\n  // Update config as needed\n})\n```\n\n### Issue: Peer dependency warnings\n\n**Solution:**\n```bash\n# Install peer dependencies\nnpm install <missing-peer-dep>\n\n# Or use --force (not recommended)\nnpm install --force\n```\n\n---\n\n## Breaking Changes to Watch For\n\n### Vite 5+\n- May require Node 18+\n- ESM-only packages\n- Updated config format\n\n### SvelteKit 2+\n- Svelte 5 syntax (runes)\n- Updated adapter config\n- New routing conventions\n\n### React 19+\n- New JSX transform\n- Updated hooks behavior\n- Server components\n\n### Vue 3.4+\n- New compiler optimizations\n- Updated Composition API\n- Better TypeScript support\n\n---\n\n## Update Checklist\n\nAfter updating, verify:\n\n```\n□ npm run dev works\n□ npm run build succeeds\n□ npm run preview works\n□ No console errors\n□ Odoo connection works\n□ Data syncs correctly\n□ CRUD operations work\n□ Offline mode works\n□ Service worker registered\n□ Tests pass (if any)\n□ No TypeScript errors\n□ No ESLint warnings\n□ Documentation updated\n```\n\n---\n\n## Selective Updates\n\n### Update Only Production Dependencies\n```bash\nnpm update --prod\n```\n\n### Update Specific Package\n```bash\nnpm update vite\nnpm update @sveltejs/kit\n```\n\n### Update to Specific Version\n```bash\nnpm install vite@5.0.0\nnpm install svelte@5.0.0\n```\n\n### Keep Package at Current Version\n```json\n// package.json\n{\n  \"dependencies\": {\n    \"some-package\": \"1.2.3\"  // No ^ or ~ = exact version\n  }\n}\n```\n\n---\n\n## Best Practices\n\n### 1. Update Regularly\n- Check weekly for security updates\n- Update monthly for feature updates\n- Test before deploying\n\n### 2. Read Changelogs\n- Check CHANGELOG.md for breaking changes\n- Review migration guides\n- Test thoroughly\n\n### 3. Update One Category at a Time\n```bash\n# 1. Framework\nnpm update svelte @sveltejs/kit\n\n# 2. Build tools\nnpm update vite\n\n# 3. Dependencies\nnpm update  # All others\n```\n\n### 4. Keep Lock Files\n- Commit `package-lock.json`\n- Ensure consistent installs\n- Track exact versions\n\n### 5. Test in Staging\n- Deploy to staging first\n- Test all functionality\n- Then deploy to production\n\n---\n\n## Security Updates\n\n### Check for Vulnerabilities\n```bash\nnpm audit\n```\n\n### Fix Automatically\n```bash\nnpm audit fix\n```\n\n### Fix with Breaking Changes\n```bash\nnpm audit fix --force\n```\n\n### Review Details\n```bash\nnpm audit --json\n```\n\n---\n\n## Automated Updates (Optional)\n\n### Using Dependabot (GitHub)\nCreate `.github/dependabot.yml`:\n```yaml\nversion: 2\nupdates:\n  - package-ecosystem: \"npm\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    open-pull-requests-limit: 10\n```\n\n### Using Renovate\nCreate `renovate.json`:\n```json\n{\n  \"extends\": [\"config:base\"],\n  \"schedule\": [\"before 10am on monday\"]\n}\n```\n\n---\n\n## Rollback Plan\n\n### If Something Breaks\n\n#### Quick Rollback\n```bash\ngit checkout package.json package-lock.json\nnpm install\n```\n\n#### Restore from Backup\n```bash\ncp package.json.backup package.json\ncp package-lock.json.backup package-lock.json\nnpm install\n```\n\n#### Git Reset\n```bash\ngit reset --hard HEAD~1\nnpm install\n```\n\n---\n\n## After Update\n\n### Update Documentation\n- Note any breaking changes\n- Update README if needed\n- Document new features used\n\n### Notify Team\n- Share what was updated\n- Note any changes in behavior\n- Update staging/production\n\n### Monitor Production\n- Watch error logs\n- Check performance metrics\n- Monitor user reports\n\n---\n\n## Example prompts to use this command:\n- `/update-deps` - Update all dependencies\n- User: \"Update my dependencies\"\n- User: \"Check for package updates\"\n- User: \"My packages are outdated\"\n\n## Related Commands:\n- `/fix-sync` - If sync breaks after update\n- `/test-connection` - Verify Odoo still works\n- `/troubleshoot` - Fix issues after update\n- `/optimize` - Check for optimizations after update\n\n---\n\n## Quick Update Script\n\nSave as `update.sh`:\n```bash\n#!/bin/bash\n\necho \"Backing up...\"\ncp package.json package.json.backup\ncp package-lock.json package-lock.json.backup\n\necho \"Checking for updates...\"\nnpm outdated\n\necho \"Updating...\"\nnpm update\n\necho \"Installing...\"\nnpm install\n\necho \"Testing...\"\nnpm run build\n\nif [ $? -eq 0 ]; then\n  echo \"✅ Build successful!\"\n  echo \"Run: npm run dev to test\"\nelse\n  echo \"❌ Build failed! Rolling back...\"\n  cp package.json.backup package.json\n  cp package-lock.json.backup package-lock.json\n  npm install\nfi\n```\n\nUsage:\n```bash\nchmod +x update.sh\n./update.sh\n```\n",
        "plugins/odoo-pwa-generator/skills/add-odoo-model/SKILL.md": "---\nname: add-odoo-model\ndescription: Add integration for an additional Odoo Studio model to an existing Odoo PWA project. Use when user wants to add support for another model, mentions \"add new model\", \"integrate another Odoo model\", or similar.\nallowed-tools: Read, Write, Edit, Glob\n---\n\n# Add Odoo Model Integration\n\nAdd a new Odoo model integration to an existing Odoo PWA project, creating cache stores, API methods, and UI components.\n\n## Prerequisites\n\n- Existing Odoo PWA project (generated with create-odoo-pwa skill)\n- New Odoo Studio model created with `x_` prefix\n- Model name and display name from user\n\n## Required User Input\n\nAsk the user for:\n\n1. **Model name** (required)\n   - Format: without `x_` prefix (e.g., \"inventory\", \"tasks\")\n   - Example: If Odoo model is `x_inventory`, user provides: `inventory`\n\n2. **Model display name** (required)\n   - Human-readable singular name (e.g., \"Inventory Item\", \"Task\")\n\n3. **Create UI pages** (optional)\n   - Ask if user wants to generate form and list pages\n   - Default: yes\n\n## Detection Steps\n\nBefore generating, detect the project structure:\n\n1. **Detect framework**:\n   - Check for `svelte.config.js` → SvelteKit\n   - Check for `vite.config.ts` with React → React\n   - Check for `nuxt.config.ts` → Vue/Nuxt\n\n2. **Find existing files**:\n   - Locate `src/lib/odoo.js` (or equivalent)\n   - Find existing cache stores in `src/lib/stores/`\n   - Check routes structure\n\n3. **Verify Odoo connection**:\n   - Check `.env` file has ODOO_URL and credentials\n\n## Generation Steps\n\n### Step 1: Create Cache Store\n\nGenerate `src/lib/stores/{{MODEL_NAME}}Cache.js`:\n\n- Based on existing cache store pattern\n- Replace model name throughout\n- Update fields array with model-specific fields\n- Include CRUD methods\n\n### Step 2: Update Odoo API Client\n\nAdd model-specific methods to `src/lib/odoo.js`:\n\n```javascript\n/**\n * Fetch {{MODEL_DISPLAY_NAME}} records\n */\nasync fetch{{MODEL_NAME|capitalize}}s(domain = [], fields = []) {\n  return await this.searchRecords('x_{{MODEL_NAME}}', domain, fields);\n}\n\n/**\n * Create {{MODEL_DISPLAY_NAME}}\n */\nasync create{{MODEL_NAME|capitalize}}(fields) {\n  return await this.createRecord('x_{{MODEL_NAME}}', fields);\n}\n\n/**\n * Update {{MODEL_DISPLAY_NAME}}\n */\nasync update{{MODEL_NAME|capitalize}}(id, values) {\n  return await this.updateRecord('x_{{MODEL_NAME}}', id, values);\n}\n\n/**\n * Delete {{MODEL_DISPLAY_NAME}}\n */\nasync delete{{MODEL_NAME|capitalize}}(id) {\n  return await this.deleteRecord('x_{{MODEL_NAME}}', id);\n}\n```\n\n### Step 3: Create UI Pages (if requested)\n\n#### Add Form Page: `src/routes/{{MODEL_NAME}}/+page.svelte`\n\nGenerate form component:\n- Import cache store\n- Form fields for model\n- Handle offline/online states\n- Submit handler with validation\n\n#### List Page: `src/routes/{{MODEL_NAME}}/list/+page.svelte`\n\nGenerate list component:\n- Display records in table/card format\n- Search/filter functionality\n- Delete actions\n- Sync status\n\n### Step 4: Update Navigation\n\nUpdate navigation in main layout or existing pages:\n\n```svelte\n<nav>\n  <!-- Existing links -->\n  <a href=\"/{{MODEL_NAME}}\">{{MODEL_DISPLAY_NAME}}s</a>\n</nav>\n```\n\n### Step 5: Update Environment Variables\n\nAdd to `.env.example` (if needed):\n```env\n# {{MODEL_DISPLAY_NAME}} Model\nODOO_{{MODEL_NAME|uppercase}}_MODEL=x_{{MODEL_NAME}}\n```\n\n## Post-Generation Instructions\n\nProvide user with:\n\n```\n✅ {{MODEL_DISPLAY_NAME}} integration added successfully!\n\n📋 Next Steps:\n\n1. Verify Odoo Model Setup:\n   - Model name: x_{{MODEL_NAME}}\n   - Add custom fields with x_studio_ prefix in Odoo Studio\n\n2. Update Cache Store:\n   - Edit src/lib/stores/{{MODEL_NAME}}Cache.js\n   - Add all model fields to the 'fields' array\n\n3. Customize UI:\n   - Edit src/routes/{{MODEL_NAME}}/+page.svelte for form\n   - Edit src/routes/{{MODEL_NAME}}/list/+page.svelte for list view\n   - Add model-specific fields and validation\n\n4. Test Integration:\n   npm run dev\n   - Navigate to /{{MODEL_NAME}}\n   - Test create, read, update, delete operations\n   - Verify offline functionality\n\n📚 Model-Specific Files Created:\n- src/lib/stores/{{MODEL_NAME}}Cache.js - Cache and sync logic\n- src/routes/{{MODEL_NAME}}/+page.svelte - Add form\n- src/routes/{{MODEL_NAME}}/list/+page.svelte - List view\n\n🔗 Access:\n- Add: http://localhost:5173/{{MODEL_NAME}}\n- List: http://localhost:5173/{{MODEL_NAME}}/list\n```\n\n## Framework-Specific Notes\n\n### SvelteKit\n- Use Svelte 5 syntax with `$state`, `$derived`, `$effect`\n- Cache stores use Svelte stores pattern\n- Routes in `src/routes/`\n\n### React\n- Use React hooks (useState, useEffect)\n- Context API for cache\n- Routes configuration depends on router (React Router, etc.)\n\n### Vue\n- Use Vue 3 Composition API\n- Composables for cache logic\n- Routes in `src/pages/` or as configured\n\n## Error Handling\n\nIf generation fails:\n- Verify project has Odoo PWA structure\n- Check for existing odoo.js file\n- Ensure proper permissions for file creation\n- Provide clear error messages\n\n## Examples\n\nUser: \"Add inventory model to track items\"\n- Model name: inventory\n- Display name: Inventory Item\n- Creates: inventoryCache.js, /inventory pages, API methods\n\nUser: \"Integrate task management\"\n- Model name: task\n- Display name: Task\n- Creates: taskCache.js, /task pages, API methods\n",
        "plugins/odoo-pwa-generator/skills/create-odoo-pwa/SKILL.md": "---\nname: create-odoo-pwa\ndescription: Generate an offline-first Progressive Web App with Odoo Studio backend integration. Use when user wants to create new Odoo-backed application, mentions \"PWA with Odoo\", \"offline Odoo app\", \"Odoo Studio PWA\", or similar terms. Supports SvelteKit, React, and Vue frameworks.\nallowed-tools: Read, Write, Glob, Bash\n---\n\n# Create Odoo PWA Application\n\nGenerate a production-ready Progressive Web App with Odoo Studio backend, featuring offline-first architecture, smart caching, and automatic synchronization.\n\n## Before You Start\n\nThis skill generates a complete PWA project following proven architectural patterns:\n- **Three-layer data flow**: Component → Cache Store → API Client → Server Route → Odoo\n- **Offline-first**: IndexedDB/localStorage with background sync\n- **Smart caching**: Incremental fetch, stale detection, optimistic updates\n- **PWA-ready**: Service workers, manifest, installable\n\n## Required User Input\n\nAsk the user for the following information before generating:\n\n1. **Project name** (required)\n   - Format: kebab-case (e.g., \"inventory-tracker\", \"expense-manager\")\n   - Used for directory name and package.json\n\n2. **Framework** (required)\n   - Options: `sveltekit` (recommended), `react`, `vue`\n   - Default: sveltekit if not specified\n\n3. **Primary Odoo model** (required)\n   - The main custom model name WITHOUT the `x_` prefix\n   - Example: If Odoo model is `x_inventory`, user provides: `inventory`\n   - Will automatically add `x_` prefix in code\n\n4. **Model display name** (required)\n   - Human-readable singular name (e.g., \"Inventory Item\", \"Expense\")\n\n5. **Deployment target** (optional)\n   - Options: `vercel`, `github-pages`, `cloudflare`, `netlify`\n   - Default: vercel if not specified\n\n## Generation Steps\n\n### Step 1: Project Initialization\n\nCreate the project directory and initialize the structure:\n\n```bash\nmkdir {{PROJECT_NAME}}\ncd {{PROJECT_NAME}}\n```\n\nGenerate the appropriate structure based on framework:\n- **SvelteKit**: Use SvelteKit 2.x structure with `src/` directory\n- **React**: Use Vite + React structure\n- **Vue**: Use Vite + Vue structure\n\n### Step 2: Base Configuration Files\n\nGenerate these files using templates from `skills/create-odoo-pwa/templates/{{FRAMEWORK}}/base/`:\n\n#### For SvelteKit:\n- `package.json` - Dependencies including @sveltejs/kit, @vite-pwa/sveltekit, @sveltejs/adapter-static\n- `svelte.config.js` - SvelteKit configuration with adapter-static\n- `vite.config.js` - Vite + PWA plugin configuration\n- `jsconfig.json` or `tsconfig.json` - Path aliases and compiler options\n\n#### For React:\n- `package.json` - Dependencies including React 18, Vite, vite-plugin-pwa\n- `vite.config.js` - React + PWA plugin configuration\n- `tsconfig.json` - TypeScript configuration\n\n#### For Vue:\n- `package.json` - Dependencies including Vue 3, Vite, vite-plugin-pwa\n- `vite.config.js` - Vue + PWA plugin configuration\n- `tsconfig.json` - TypeScript configuration\n\n### Step 3: Environment and Git Configuration\n\nCreate `.env.example`:\n```env\n# Odoo Instance Configuration\nODOO_URL=https://your-instance.odoo.com\nODOO_DB=your-database-name\nODOO_USERNAME=your-username\nODOO_API_KEY=your-api-key\n\n# Primary Model (use x_ prefix)\nODOO_PRIMARY_MODEL=x_{{MODEL_NAME}}\n\n# Optional: For static hosting (GitHub Pages, etc.)\nPUBLIC_API_URL=\n```\n\nCreate `.gitignore`:\n```\nnode_modules/\n.env\ndist/\nbuild/\n.svelte-kit/\n.vercel/\n.DS_Store\n*.log\n```\n\n### Step 4: Core Library Files\n\nGenerate these essential files from templates:\n\n#### A. Odoo API Client (`src/lib/odoo.js`)\nFeatures:\n- API URL configuration (supports PUBLIC_API_URL for static hosts)\n- `callApi(action, data)` - Core API communication\n- `createRecord(model, fields)` - Create records\n- `searchRecords(model, domain, fields)` - Search/read records\n- `updateRecord(model, id, values)` - Update records\n- `deleteRecord(model, id)` - Delete records\n- `formatMany2one(id)` - Format single relation fields\n- `formatMany2many(ids)` - Format multi-relation fields\n- Model-specific convenience methods\n\n#### B. IndexedDB Manager (`src/lib/db.js`)\nFeatures:\n- Database initialization with versioning\n- Store definitions for master data (partners, categories, config)\n- CRUD operations: `add()`, `get()`, `getAll()`, `update()`, `remove()`\n- Transaction helpers\n- Error handling\n\n#### C. Smart Cache Store (`src/lib/stores/{{MODEL_NAME}}Cache.js`)\nFeatures:\n- Framework-specific store pattern (Svelte store/React context/Vue composable)\n- Dual storage strategy (localStorage for metadata, IndexedDB for master data)\n- `initialize()` - Load cache and start background sync\n- `sync(forceFullRefresh)` - Incremental sync with Odoo\n- `forceRefresh()` - Clear cache and full sync\n- Partner name resolution with caching\n- Optimistic UI updates\n- Stale detection (5-minute cache validity)\n- Background sync (3-minute intervals)\n- Derived stores for UI states\n\n#### D. Utility Functions (`src/lib/{{MODEL_NAME}}Utils.js`)\nFeatures:\n- Business logic calculations\n- Data normalization helpers\n- Field formatters\n\n### Step 5: Server-Side API Proxy\n\n#### For SvelteKit: `src/routes/api/odoo/+server.js`\nFeatures:\n- JSON-RPC client for Odoo\n- UID caching to reduce auth calls\n- `execute(model, method, args, kwargs)` helper\n- POST request handler with actions:\n  - `create` - Create new record\n  - `search` - Search and read records\n  - `search_model` - Search any Odoo model\n  - `update` - Update existing record\n  - `delete` - Delete record\n- Error handling with descriptive messages\n- Environment variable access\n\n#### For React/Vue: `src/api/odoo.js` (server endpoint)\nSimilar functionality adapted to framework conventions\n\n### Step 6: UI Components and Routes\n\nGenerate starter components and pages:\n\n#### SvelteKit Routes:\n- `src/routes/+layout.svelte` - Root layout with navigation\n- `src/routes/+layout.js` - SSR/CSR configuration (ssr: false, csr: true)\n- `src/routes/+page.svelte` - Main form for creating records\n- `src/routes/list/+page.svelte` - List/table view with filtering\n- `src/app.html` - HTML template with PWA meta tags\n\n#### React/Vue Pages:\nEquivalent component structure adapted to framework conventions\n\n#### Shared Components:\n- `OfflineBanner` - Shows online/offline status\n- `SyncStatus` - Displays sync state and last sync time\n- `LoadingSpinner` - Loading indicator\n- Form components with offline support\n\n### Step 7: PWA Configuration\n\nGenerate PWA files:\n\n#### `static/manifest.json` (or `public/manifest.json`):\n```json\n{\n  \"name\": \"{{PROJECT_NAME}}\",\n  \"short_name\": \"{{PROJECT_NAME}}\",\n  \"description\": \"{{MODEL_DISPLAY_NAME}} management app\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#667eea\",\n  \"icons\": [\n    {\n      \"src\": \"/icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n```\n\nConfigure service worker in `vite.config.js`:\n- Auto-update strategy\n- Cache all static assets\n- Offline support\n\n### Step 8: Deployment Configuration\n\nGenerate deployment files based on target:\n\n#### Vercel (`vercel.json`):\n```json\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"build\",\n  \"framework\": \"sveltekit\",\n  \"regions\": [\"iad1\"]\n}\n```\n\n#### GitHub Pages (`.github/workflows/deploy.yml`):\n```yaml\nname: Deploy to GitHub Pages\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: npm ci\n      - run: npm run build\n      - uses: actions/upload-pages-artifact@v2\n        with:\n          path: build\n```\n\n#### Cloudflare/Netlify:\nGenerate appropriate configuration files\n\n### Step 9: Documentation\n\nGenerate comprehensive documentation:\n\n#### `README.md`:\n- Project overview\n- Prerequisites (Node.js, Odoo account)\n- Installation steps\n- Odoo Studio model setup instructions\n- Development commands\n- Deployment guide\n- Architecture overview\n\n#### `CLAUDE.md`:\nComplete architecture documentation following the expense-split-pwa pattern:\n- Project overview\n- Development commands\n- Environment setup\n- Architecture diagrams\n- Key architectural patterns\n- Odoo model structure\n- Important development notes\n- Common gotchas\n\n#### `API.md`:\n- Odoo integration patterns\n- Available API methods\n- Field formatting examples\n- Common operations\n\n### Step 10: Post-Generation Instructions\n\nAfter generating all files, provide the user with:\n\n```\n✅ Project '{{PROJECT_NAME}}' generated successfully!\n\n📋 Next Steps:\n\n1. Navigate to the project:\n   cd {{PROJECT_NAME}}\n\n2. Install dependencies:\n   npm install\n\n3. Configure Odoo credentials:\n   cp .env.example .env\n   # Edit .env with your Odoo instance details\n\n4. Create Odoo Studio Model:\n   - Log into your Odoo instance\n   - Go to Studio\n   - Create a new model named: x_{{MODEL_NAME}}\n   - Add custom fields with x_studio_ prefix\n   - Example fields:\n     * x_name (Char) - Required\n     * x_studio_description (Text)\n     * x_studio_value (Float)\n     * x_studio_date (Date)\n     * x_studio_category (Many2one → res.partner or custom)\n\n5. Start development server:\n   npm run dev\n\n6. Generate PWA icons:\n   - Create 192x192 and 512x512 PNG icons\n   - Place in static/ or public/ directory\n   - Name them icon-192.png and icon-512.png\n\n7. Deploy (optional):\n   - Vercel: vercel\n   - GitHub Pages: Push to main branch\n   - Cloudflare: wrangler deploy\n   - Netlify: netlify deploy\n\n📚 Documentation:\n- README.md - Getting started guide\n- CLAUDE.md - Architecture documentation\n- API.md - Odoo integration patterns\n\n🔗 Resources:\n- Odoo API Docs: https://www.odoo.com/documentation/\n- SvelteKit Docs: https://kit.svelte.dev/\n```\n\n## Template Variables\n\nWhen generating files, replace these placeholders:\n\n- `{{PROJECT_NAME}}` - User's project name (kebab-case)\n- `{{MODEL_NAME}}` - Odoo model name without x_ prefix\n- `{{MODEL_DISPLAY_NAME}}` - Human-readable model name\n- `{{FRAMEWORK}}` - sveltekit/react/vue\n- `{{DEPLOYMENT_TARGET}}` - vercel/github-pages/cloudflare/netlify\n- `{{AUTHOR_NAME}}` - User's name (if provided)\n\n## Common Patterns from expense-split-pwa\n\nThis skill implements proven patterns from the expense-split-pwa project:\n\n1. **Smart Caching**: Load from cache immediately, sync in background if stale\n2. **Incremental Fetch**: Only fetch records with `id > lastRecordId`\n3. **Partner Resolution**: Batch-fetch and cache partner names\n4. **Dual-Phase Calculation**: Process settled/unsettled records separately\n5. **Optimistic Updates**: Update UI immediately, sync to server in background\n6. **Error Recovery**: Graceful degradation when offline\n\n## Error Handling\n\nIf generation fails:\n- Verify all required input is provided\n- Check template files exist\n- Ensure proper permissions for file creation\n- Provide clear error messages to user\n\n## Framework-Specific Notes\n\n### SvelteKit\n- Use Svelte 5 runes syntax (`$state`, `$derived`, `$effect`)\n- Configure adapter-static for static deployment\n- Set `ssr: false` for client-side only apps\n- Use `$app/paths` for base path support\n\n### React\n- Use React 18+ with hooks\n- Context API for global state\n- React Query for server state (optional)\n- Vite for build tooling\n\n### Vue\n- Use Vue 3 Composition API\n- Pinia for state management\n- Composables for reusable logic\n- Vite for build tooling\n\n## Testing the Generated Project\n\nAfter generation, verify:\n1. `npm install` completes without errors\n2. `npm run dev` starts development server\n3. Form renders correctly\n4. Offline banner appears when disconnecting\n5. Data persists in localStorage/IndexedDB\n6. Sync works when back online\n\n## Support\n\nFor issues or questions:\n- Check CLAUDE.md for architecture details\n- Review generated code comments\n- Consult Odoo API documentation\n- Verify environment variables are set correctly\n"
      },
      "plugins": [
        {
          "name": "odoo-pwa-generator",
          "source": "./plugins/odoo-pwa-generator",
          "description": "Generate offline-first Progressive Web Apps with Odoo Studio backend integration. Supports SvelteKit, React, and Vue with smart caching, IndexedDB storage, and automatic sync",
          "version": "1.0.0",
          "author": {
            "name": "Jamshid K",
            "email": "jamshu.mkd@gmail.com"
          },
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add jamshu/jamshi-marketplace",
            "/plugin install odoo-pwa-generator@jamshi-marketplace"
          ]
        },
        {
          "name": "odoo-dev",
          "description": "Comprehensive feature development workflow with specialized agents for codebase exploration, architecture design, and quality review",
          "version": "1.0.0",
          "author": {
            "name": "Jamshid K",
            "email": "jamshu.mkd@gmail.com"
          },
          "source": "./plugins/odoo-dev",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add jamshu/jamshi-marketplace",
            "/plugin install odoo-dev@jamshi-marketplace"
          ]
        }
      ]
    }
  ]
}