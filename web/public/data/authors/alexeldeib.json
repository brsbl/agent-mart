{
  "author": {
    "id": "alexeldeib",
    "display_name": "Ace Eldeib",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/6800857?u=d719eb9116e36ff8462d1aca640d5b18a3040ffa&v=4",
    "url": "https://github.com/alexeldeib",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 4,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "clode",
      "version": null,
      "description": "Personal productivity plugin with task management, coding practices, and example scaffolds",
      "owner_info": {
        "name": "Alex Eldeib",
        "email": "alexeldeib@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "alexeldeib/clode",
      "repo_url": "https://github.com/alexeldeib/clode",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-11T19:21:25Z",
        "created_at": "2026-01-11T01:05:21Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 354
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 385
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1194
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/skill-creator.md",
          "type": "blob",
          "size": 3539
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/dots-plan.md",
          "type": "blob",
          "size": 11857
        },
        {
          "path": "commands/interview.md",
          "type": "blob",
          "size": 727
        },
        {
          "path": "commands/status.md",
          "type": "blob",
          "size": 1362
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 815
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-practices",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-practices/SKILL.md",
          "type": "blob",
          "size": 1530
        },
        {
          "path": "skills/dots",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dots/SKILL.md",
          "type": "blob",
          "size": 4565
        },
        {
          "path": "skills/git-spice",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/git-spice/SKILL.md",
          "type": "blob",
          "size": 7257
        },
        {
          "path": "skills/ripgrep",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/ripgrep/SKILL.md",
          "type": "blob",
          "size": 6400
        },
        {
          "path": "skills/ripgrep/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/ripgrep/references/advanced.md",
          "type": "blob",
          "size": 3455
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"clode\",\n  \"owner\": {\n    \"name\": \"Alex Eldeib\",\n    \"email\": \"alexeldeib@gmail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"clode\",\n      \"source\": \"./\",\n      \"description\": \"Personal productivity plugin with task management, coding practices, and example scaffolds\",\n      \"version\": \"0.1.0\",\n      \"category\": \"productivity\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"clode\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Personal productivity plugin with task management, coding practices, and example scaffolds\",\n  \"author\": {\n    \"name\": \"Alex Eldeib\",\n    \"url\": \"https://github.com/alexeldeib\"\n  },\n  \"repository\": \"https://github.com/alexeldeib/clode\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"productivity\", \"tasks\", \"personal\", \"scaffolds\"]\n}\n",
        "README.md": "# clode\n\nPersonal productivity plugin for Claude Code with task management, coding practices, and example scaffolds for building custom hooks, commands, and agents.\n\n## Features\n\n- **Skills**: Dots task management, coding practices guidance\n- **Commands**: `/clode:status` - show plugin/project status\n- **Agents**: skill-creator - explore projects and generate skills\n- **Hooks**: Example scaffolds for PreToolUse, PermissionRequest, Notification, Stop events\n\n## Installation\n\n```bash\n# Local development\nclaude --plugin-dir /path/to/clode\n\n# Or copy to your .claude-plugin directory\ncp -r clode ~/.claude-plugin/\n```\n\n## Components\n\n### Skills\n\n- **dots** - Task management using the dots CLI\n- **coding-practices** - Coding best practices (scaffold)\n\n### Commands\n\n- `/clode:status` - Display plugin and project status information\n\n### Agents\n\n- **skill-creator** - Explores current project, discovers CLIs/commands, creates skills\n\n### Hooks\n\nExample hook configurations for:\n- PreToolUse (with AskUserQuestion matcher)\n- PermissionRequest\n- Notification\n- Stop\n\n## Development\n\nThis plugin serves as both a productivity tool and a template for building your own plugins.\n\n## License\n\nMIT\n",
        "agents/skill-creator.md": "---\nname: skill-creator\ndescription: Use this agent to create a new skill based on exploring the current project directory. This agent discovers CLIs, commands, and patterns in a codebase, then generates a skill from what it finds. Examples:\n\n<example>\nContext: User has a project with a custom CLI tool\nuser: \"Create a skill for the CLI in this project\"\nassistant: \"I'll use the skill-creator agent to explore your project and generate a skill based on the CLI it discovers.\"\n<commentary>\nThe skill-creator agent should explore the project structure, find CLI entry points, understand the command structure, and generate a skill that documents how to use the CLI effectively.\n</commentary>\n</example>\n\n<example>\nContext: User wants to document a workflow they use repeatedly\nuser: \"Make a skill from the build scripts in this repo\"\nassistant: \"I'll launch the skill-creator agent to analyze your build scripts and create a skill documenting the build workflow.\"\n<commentary>\nThe agent should read build scripts, understand the steps, and create a skill that captures this workflow knowledge.\n</commentary>\n</example>\n\n<example>\nContext: User has a library or tool they want to make discoverable\nuser: \"Generate a skill for the authentication module\"\nassistant: \"I'll use skill-creator to explore the authentication module and create a skill documenting its usage patterns.\"\n<commentary>\nThe agent explores specific parts of the codebase and generates focused skills.\n</commentary>\n</example>\n\nmodel: inherit\ncolor: cyan\ntools: [\"Read\", \"Glob\", \"Grep\", \"Bash\", \"Write\"]\n---\n\nYou are a skill creation specialist that explores codebases and generates Claude Code skills.\n\n**Your Core Responsibilities:**\n1. Explore the current project to discover CLIs, commands, scripts, and patterns\n2. Understand how tools and workflows are used\n3. Generate well-structured skills following Claude Code conventions\n\n**Discovery Process:**\n\n1. **Identify target**\n   - Determine what the user wants a skill for (CLI, module, workflow)\n   - Ask clarifying questions if the target is unclear\n\n2. **Explore codebase**\n   - Find entry points (bin/, scripts/, CLI files, package.json scripts)\n   - Read key files to understand functionality\n   - Identify command structures and options\n   - Note common usage patterns\n\n3. **Extract knowledge**\n   - Document available commands and their purposes\n   - Capture configuration options\n   - Note dependencies and requirements\n   - Identify integration points\n\n4. **Generate skill**\n   - Create skill directory structure\n   - Write SKILL.md with:\n     - Third-person description with trigger phrases\n     - Command reference tables\n     - Usage examples\n     - Workflow patterns\n   - Add references/ for detailed documentation if needed\n\n**Skill Quality Standards:**\n- Description uses third person (\"This skill should be used when...\")\n- Include specific trigger phrases users would say\n- Body uses imperative form, not second person\n- Keep SKILL.md lean (1,500-2,000 words)\n- Include working examples\n\n**Output Format:**\n\nAfter exploration, create the skill files directly:\n1. `skills/<skill-name>/SKILL.md` - Main skill file\n2. `skills/<skill-name>/references/` - Detailed docs if needed\n3. `skills/<skill-name>/examples/` - Working examples\n\nReport what was created and suggest how to test the skill.\n\n**Edge Cases:**\n- If no CLI or clear tool found: Ask user what aspect to document\n- If project is too large: Focus on specific subsystem\n- If unclear target: List what could become skills and ask user to choose\n",
        "commands/dots-plan.md": "---\ndescription: Plan complex work with collaborative AI debate, create dot tasks with dependencies\nargument-hint: [optional focus area]\n---\n\n# Planning Dot Tasks\n\nReview the conversation history above to identify work that needs planning. Extract requirements, decisions, and context discussed—these inform the dot tasks you create. If the user provided additional instructions below, incorporate those as well.\n\nThis is a two-phase process: discovery first, then planning with collaborative debate.\n\n## Phase 1: Discovery\n\nGather context from the conversation history and find verification commands.\n\n### Step 1: Verification Commands\nRun a focused Explore query to find exact development commands:\n```\nFind the ACTUAL commands used in this project for verification. Search in order:\n1. mise.toml / .mise.toml (mise task runner - https://github.com/jdx/mise)\n2. package.json scripts / pyproject.toml / Makefile / Justfile\n3. .github/workflows (CI jobs are authoritative)\n4. docs/CONTRIBUTING.md or README.md\n\nFor each category, report the EXACT command string:\n- Linting/formatting (e.g., `mise run lint`, `go fmt ./...`)\n- Static analysis / type checking (e.g., `mise run check`, `staticcheck ./...`, `golangci-lint run`)\n- Unit tests (e.g., `mise run test`, `go test ./...`)\n- Scoped E2E tests - run specific tests (e.g., `mise run test:e2e -- -run TestAuth`, `go test ./e2e/... -run TestAuth`)\n- Full E2E tests - run entire suite (e.g., `mise run test:e2e`, `go test ./e2e/...`)\n\nOutput format: \"CATEGORY: [exact command]\"\nStop searching a category once you find an authoritative source.\n```\n\n### Step 2: Discovery Synthesis\nConsolidate findings from conversation history into planning input:\n- **Architecture overview**: Patterns, conventions, and constraints discussed\n- **Testing setup**: Where tests live, how to run them, what coverage exists\n- **Verification commands**: From Step 1\n- **Known risks**: Edge cases and caveats identified\n\nThis synthesis becomes the input for Phase 2.\n\n## Phase 2: Planning with Collaborative Debate\n\nUse multi-round refinement for thorough planning.\n\n### Guiding Principles: Speed-of-Light Implementation\n\n**Treat planning as a minimization problem.** The goal is not to design a comprehensive solution—it's to find the smallest, fastest path to the desired outcome.\n\n- **Minimize changes**: What is the absolute minimum number of lines, files, and touch points needed? Every additional change is a potential bug, a review burden, and merge conflict risk.\n- **Minimize complexity**: Prefer boring, obvious solutions over clever ones. If two approaches work, choose the one a junior developer could understand in 5 minutes.\n- **Minimize scope**: Ruthlessly cut anything that isn't strictly required. \"Nice to have\" belongs in a separate future task, not this plan.\n- **Minimize risk**: Favor incremental changes over big-bang rewrites. Ship something small that works over something ambitious that might not.\n\n**Ask at every decision point**: \"Is there a simpler way?\" If the answer is yes, take it.\n\n### Step 1: Initial Plan\nUse the Plan subagent with **model: \"opus\"** to design the minimum viable implementation based on discovery synthesis. The plan should answer: \"What is the smallest change that achieves the goal?\"\n\n### Step 2: Collaborative Debate (1-5 rounds, until feedback converges)\nClaude (Opus) and Codex (gpt-5.2-codex) debate back-and-forth to refine the plan. The number of rounds depends on complexity and whether feedback converges:\n\n- **Simple/straightforward plans**: 1 round may suffice if both models agree\n- **Moderate complexity**: 2-3 rounds typical\n- **Complex or contentious plans**: Up to 5 rounds if feedback doesn't converge\n\n**Round 1 - Dual Critique**:\n- **Claude (Opus)**: Review the plan through a minimization lens. For each concern: (1) Is this change actually necessary? (2) Is there a simpler alternative? (3) What can be cut or deferred? Also flag genuine gaps or risks.\n- **Codex**: Use `mcp__codex-cli__codex` with model \"gpt-5.2-codex\":\n  ```\n  prompt: \"Review this implementation plan with a minimization mindset: [plan]. The goal is the smallest, simplest path to the outcome. For each part of the plan: (1) Is this necessary or can it be cut? (2) Is there a simpler approach? (3) What's the minimum viable version? Also list any genuine gaps or risks, with concrete mitigations.\"\n  ```\n- Synthesize both critiques. Prioritize simplification opportunities alongside risk fixes.\n- **Exit condition**: If both models agree the plan is minimal and sound, proceed to task creation.\n\n**Round 2+ - Address & Counter** (repeat until convergence or Round 5):\n- **Claude (Opus)**: Propose revisions that make the plan simpler, not more complex. For each concern: accept and simplify, reject with rationale, or defer to a future task. Resist adding complexity to \"fix\" problems.\n- **Codex**: Use `mcp__codex-cli__codex` with model \"gpt-5.2-codex\":\n  ```\n  prompt: \"Claude proposes these revisions: [revisions]. Evaluate with a bias toward simplicity: (1) Does this revision add or remove complexity? (2) Is there an even simpler fix? (3) Should this concern be deferred rather than addressed now? Flag any revision that makes the plan bigger rather than smaller.\"\n  ```\n- Integrate valid counterpoints. If a fix adds more complexity than the problem warrants, defer it.\n- **Exit condition**: Feedback converges (plan is minimal, both models agree on approach).\n\n**Final Round - Consensus Check** (when exiting):\n- **Claude (Opus)**: Present the refined plan. Confirm it represents the minimum viable implementation. List what was intentionally deferred.\n- **Codex**: Use `mcp__codex-cli__codex` with model \"gpt-5.2-codex\":\n  ```\n  prompt: \"Final minimization check: [plan]. Verify: (1) Is this the smallest possible implementation? (2) Can anything else be cut or deferred? (3) Are there any 'nice to haves' hiding as requirements? (4) Is the testing strategy proportional (not over-tested)? Approve only if the plan is truly minimal.\"\n  ```\n- If consensus: Proceed to task creation.\n- If minor disagreement: Choose the simpler option, defer the rest.\n- If still unresolved after Round 5: Choose the approach with fewer moving parts. Document what was deferred and why.\n\n### Quality Gate\nBefore creating tasks, confirm:\n- [ ] All discovered edge cases addressed or explicitly deferred with rationale\n- [ ] Error paths defined (what happens when X fails?)\n- [ ] Testing strategy covers new code\n- [ ] Trade-offs documented with reasoning\n\n### Step 3: Create Tasks\n\nCreate dot tasks using the dots skill. Each task must:\n1. Have clear acceptance criteria (what success looks like)\n2. Be scoped to complete in one session\n3. End with verification notes using **discovered commands** (not generic phrases):\n   ```\n   ## Verification\n   - [ ] `[discovered lint command]` passes\n   - [ ] `[discovered static analysis command]` passes\n   - [ ] `[discovered test command]` passes\n   - [ ] `[discovered scoped e2e command]` passes (if applicable)\n   ```\n   Use exact commands from Phase 1 discovery. Omit categories if no command exists.\n4. Include note: \"If implementation reveals new issues, create separate dot tasks for investigation\"\n\nCreate tasks using:\n```bash\ndot add \"Task title\" -d \"Description with acceptance criteria and verification steps\"\n```\n\n### Step 4: Final Verification Task\n\nAfter creating all implementation tasks, create one final dot task to run the full test suite:\n\n1. **Create the task**:\n   ```bash\n   dot add \"Run full E2E/integration test suite\" -d \"Verify all changes work together by running the complete test suite. Include the discovered full E2E command. Acceptance criteria: All tests pass, no regressions introduced. If any tests fail, create new tasks for each failure before completing this task.\"\n   ```\n\n2. **Set up dependencies**:\n   Use `dot update <final-task-id> -a <implementation-task-id>` for EACH implementation task.\n   This ensures the final verification runs only after all implementation work is complete.\n\nExample:\n```bash\n# If implementation tasks are a1b2c3d, e4f5g6h, i7j8k9l and final is m0n1o2p:\ndot update m0n1o2p -a a1b2c3d\ndot update m0n1o2p -a e4f5g6h\ndot update m0n1o2p -a i7j8k9l\n```\n\n### Step 5: Create Parent Tasks (Epics)\n\n**IMPORTANT**: Every planned effort MUST have a parent task, even simple single-task work. Workflow automation depends on parent task completion tracking. A simple task = one parent with one child under it.\n\n**Goal**: Create the smallest shippable units of work. Prefer many small parent tasks over few large ones.\n\n#### The Smallest Shippable Unit Test\nA parent task is the right size when:\n- Removing any child would make it unshippable\n- Adding any child would make it do two things instead of one\n- You can describe what it ships in one sentence without \"and\"\n\n#### Decomposition Checklist\nBefore finalizing parent tasks, ask these questions:\n\n1. **File overlap test**: Do any two tasks modify the same files?\n   - If YES and they're in different parents → merge parents or resequence\n   - If YES and parent is large → they belong together, but look for other splits\n\n2. **Ship independently test**: Can this parent be merged to main without the others?\n   - If NO → it's not self-contained, find the true boundary\n\n3. **Value test**: Does this parent deliver user-visible value or enable future work?\n   - If NO → it might be too granular, consider merging with dependent parent\n\n4. **Parallel work test**: Could two developers work on different parents simultaneously without conflicts?\n   - If NO → file overlap exists, resequence or merge\n\n#### Split Signals (create separate parents when you see these)\n- Different subsystems (API vs UI vs database)\n- Different risk profiles (safe refactor vs risky behavior change)\n- Natural phases (setup/infrastructure → core feature → polish)\n- Optional enhancements vs core functionality\n\n#### Anti-patterns to Avoid\n- ❌ One mega-parent containing all work\n- ❌ Parents that \"prepare\" for other parents without delivering value\n- ❌ Splitting by arbitrary task count rather than logical boundaries\n- ❌ Parents where tasks have no dependency relationship\n\nFor each parent task:\n\n```bash\n# Create parent task with high priority\ndot add \"[Parent task name]\" -p 1 -d \"$(cat <<'EOF'\n# Overview\n[Brief description of this parent task's scope]\n\n# Why This Is One Unit\n[Explain the boundary: what makes this atomic and self-contained?\nWhy can't it be split further? Why doesn't it need other parents to ship?]\n\n# Implementation Tasks\n- [task-id]: [task title]\n- [task-id]: [task title]\n- [task-id]: Run verification for this parent\n\n# Files Modified\n[List primary files this parent touches—used for conflict detection]\n\n# Verification Commands\n- Lint: `[discovered lint command]`\n- Static analysis: `[discovered static analysis command]`\n- Tests: `[discovered test command]`\n- Scoped E2E: `[discovered scoped e2e command]`\n- Full E2E: `[discovered full e2e command]`\n\n# Success Criteria\n[What \"done\" looks like for this parent task]\nEOF\n)\"\n```\n\nLink child tasks to their parent:\n```bash\n# When creating child tasks, use -P to set parent\ndot add \"Child task title\" -P <parent-task-id> -d \"Description...\"\n\n# Or update existing tasks to add parent\ndot update <child-task-id> -P <parent-task-id>\n```\n\nCheck progress: `dot tree`\n\n## Handling Failures\n\nWhen discovery or planning reveals blocking issues:\n1. Create a P0 meta task titled: \"Create plan for [blocker-topic]\"\n   ```bash\n   dot add \"Create plan for [blocker-topic]\" -p 0 -d \"Description of what was blocking and why it matters. Instruction to use Explore subagent for discovery. Instruction to use Plan subagent to design fix. Instruction to create implementation dot tasks via dots skill.\"\n   ```\n2. Any implementation tasks spawned from meta tasks are also P0\n\n$ARGUMENTS\n",
        "commands/interview.md": "---\ndescription: Interview users in-depth about their plans using probing, non-obvious questions.\n---\n\n# Plan Interview\n\nFirst, review the entire conversation to understand what plan is being discussed.\n\nInterview me about this plan in detail using the AskUserQuestion tool. Ask about literally anything: technical implementation, UI & UX, concerns, tradeoffs, edge cases, assumptions, risks, dependencies, etc.\n\nMake sure the questions are not obvious - probe deeper into things I might not have considered. Challenge assumptions. Ask about the hard parts.\n\nBe very in-depth and continue interviewing me continually until the plan is fully fleshed out, then re-iterate the complete plan incorporating everything we discussed.\n",
        "commands/status.md": "---\nname: status\ndescription: Show plugin and project status information\nargument-hint: \"[--verbose]\"\nallowed-tools: [\"Read\", \"Bash\", \"Glob\"]\n---\n\n# Status Command\n\nDisplay status information about the clode plugin and current project.\n\n## Execution Steps\n\n1. **Check plugin installation**\n   - Verify plugin files exist at expected locations\n   - Report any missing components\n\n2. **List available components**\n   - Skills: List skills in `skills/` directory\n   - Commands: List commands in `commands/` directory\n   - Agents: List agents in `agents/` directory\n   - Hooks: Check if `hooks/hooks.json` exists and is valid\n\n3. **Project context** (if applicable)\n   - Current working directory\n   - Git status (if git repo)\n   - Any `.dots/` task tracking present\n\n4. **Display summary**\n   Format output as a clean status report:\n   ```\n   clode plugin status\n   ==================\n\n   Components:\n   - Skills: [count] loaded\n   - Commands: [count] available\n   - Agents: [count] configured\n   - Hooks: [status]\n\n   Project:\n   - Directory: [cwd]\n   - Git: [status]\n   - Tasks: [dots status if present]\n   ```\n\n## Arguments\n\n- `--verbose` or `-v`: Show detailed information about each component\n\n## Tips\n\n- Run this command to verify plugin installation\n- Use `--verbose` to debug component loading issues\n- Check hooks configuration if automation isn't working\n",
        "hooks/hooks.json": "{\n  \"description\": \"Scaffold hooks demonstrating various event types. All hooks are currently no-ops - customize as needed.\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"AskUserQuestion\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"echo '{}'\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"echo '{\\\"decision\\\": \\\"approve\\\"}'\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"Notification\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"echo '{}'\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "skills/coding-practices/SKILL.md": "---\nname: coding-practices\ndescription: This skill should be used when the user asks about \"coding best practices\", \"code conventions\", \"code style\", \"how to write good code\", \"clean code\", or asks for guidance on code quality and patterns. Scaffold skill - expand with your preferred practices.\nversion: 0.1.0\n---\n\n# Coding Practices\n\nScaffold skill for coding best practices and conventions. Expand this skill with your preferred patterns, style guides, and development workflows.\n\n## Structure\n\nTo build out this skill, add content covering:\n\n### Code Quality\n- Naming conventions\n- Function design\n- Error handling patterns\n- Testing approaches\n\n### Project Structure\n- Directory organization\n- Module patterns\n- Configuration management\n\n### Workflow\n- Git conventions\n- Code review guidelines\n- Documentation standards\n\n## References\n\nAdd detailed guides to `references/`:\n- `references/style-guide.md` - Language-specific style guides\n- `references/patterns.md` - Common design patterns\n- `references/testing.md` - Testing strategies\n\n## Examples\n\nAdd working examples to `examples/`:\n- `examples/good-function.py` - Well-structured function example\n- `examples/error-handling.js` - Error handling patterns\n\n## Customization\n\nReplace this scaffold content with your actual coding practices and preferences. Focus on patterns that:\n\n1. You use repeatedly\n2. Are non-obvious to a general LLM\n3. Are specific to your tech stack or organization\n\nKeep SKILL.md lean (1,500-2,000 words) and move detailed content to references/.\n",
        "skills/dots/SKILL.md": "---\nname: dots\ndescription: This skill should be used when the user mentions \"dots\", \"dot\", \"tasks\", \"task\", \"todo\", \"issue\", \"track\", \"plan\", \"breakdown\", or asks about task management. Provides guidance for using the dots CLI task tracker.\nversion: 0.1.0\n---\n\n# Dots Task Management\n\nManages tasks using dots - a fast, minimal CLI task tracker that stores tasks as plain markdown files with YAML frontmatter in `.dots/`. Zero dependencies, git-friendly, perfect for AI agent workflows.\n\n## Quick Reference\n\n### Essential Commands\n\n| Command | Purpose | Example |\n|---------|---------|---------|\n| `dot init` | Initialize `.dots/` directory | `dot init` |\n| `dot add \"title\"` | Create new task | `dot add \"Fix login bug\"` |\n| `dot ls` | List open/active tasks | `dot ls` |\n| `dot on <id>` | Mark task as active | `dot on a1b2c3d` |\n| `dot off <id>` | Complete and archive task | `dot off a1b2c3d` |\n| `dot ready` | Show unblocked tasks | `dot ready` |\n| `dot tree` | Show task hierarchy | `dot tree` |\n| `dot show <id>` | Display task details | `dot show a1b2c3d` |\n| `dot find \"query\"` | Search tasks | `dot find \"auth\"` |\n| `dot rm <id>` | Delete task permanently | `dot rm a1b2c3d` |\n\n### Task Creation Options\n\n```bash\n# Basic task\ndot add \"Fix the login bug\"\n\n# With priority (0=critical, 1=high, 2=normal, 3=low, 4=backlog)\ndot add \"Critical security fix\" -p 0\n\n# With description\ndot add \"Refactor auth\" -d \"Move JWT validation to middleware\"\n\n# As child of parent task\ndot add \"Write unit tests\" -P parent-task-id\n\n# Blocked by another task (dependency)\ndot add \"Deploy to prod\" -a blocking-task-id\n\n# Quick add (shorthand)\ndot \"Quick task title\"\n```\n\n### Task Status Flow\n\n```\nopen -> active -> done (archived)\n```\n\n- **open**: Created, not started\n- **active**: Currently being worked on\n- **done**: Completed, moved to `.dots/archive/`\n\n### ID Format\n\nIDs use format: `{prefix}-{slug}-{hex}` (e.g., `dots-fix-user-auth-a3f2b1c8`)\n\nCommands accept short prefixes:\n```bash\ndot on a3f2b1    # Matches dots-fix-user-auth-a3f2b1c8\ndot show a3f     # Error if ambiguous\n```\n\n## Workflow Patterns\n\n### Planning a Feature\n\n```bash\n# Create parent task\ndot add \"Implement user authentication\" -p 1\n# Output: dots-impl-user-auth-a1b2c3d4\n\n# Add subtasks\ndot add \"Design database schema\" -P a1b2c3d4\ndot add \"Create API endpoints\" -P a1b2c3d4 -a schema-task-id\ndot add \"Build login UI\" -P a1b2c3d4 -a api-task-id\ndot add \"Write integration tests\" -P a1b2c3d4 -a ui-task-id\n\n# View hierarchy\ndot tree\n```\n\n### Daily Workflow\n\n```bash\n# Start of day: see what's ready\ndot ready\n\n# Pick a task and start working\ndot on a1b2c3d\n\n# Check active tasks\ndot ls --status active\n\n# Complete task with reason\ndot off a1b2c3d -r \"Fixed in commit abc123\"\n```\n\n### Managing Dependencies\n\n```bash\n# Add dependency after creation\ndot update <task-id> -a <blocking-task-id>\n\n# View task to see what's blocking it\ndot show <task-id>\n```\n\n## Claude Code Integration\n\ndots has built-in hooks for seamless Claude Code integration.\n\n### Hook Configuration\n\nAdd to `~/.claude/settings.json`:\n\n```json\n{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"dot hook session\"}]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"TodoWrite\",\n        \"hooks\": [{\"type\": \"command\", \"command\": \"dot hook sync\"}]\n      }\n    ]\n  }\n}\n```\n\n### What Hooks Do\n\n- **SessionStart**: Shows active and ready tasks at conversation start\n- **PostToolUse (TodoWrite)**: Syncs Claude's TodoWrite items to dots\n  - Creates new dots for new todos\n  - Marks dots as done when todos complete\n  - Maintains mapping in `.dots/todo-mapping.json`\n\n## Storage Format\n\nTasks stored as markdown with YAML frontmatter:\n\n```\n.dots/\n  task-id.md              # Root task\n  parent-id/              # Parent with children\n    parent-id.md          # Parent task\n    child-id.md           # Child task\n  archive/                # Completed tasks\n  config                  # Project prefix\n  todo-mapping.json       # TodoWrite sync state\n```\n\n### File Format\n\n```markdown\n---\ntitle: Fix the bug\nstatus: open\npriority: 2\nissue-type: task\ncreated-at: 2024-12-24T10:30:00Z\nblocks:\n  - other-task-id\n---\n\nDescription as markdown body here.\n```\n\n## Tips\n\n- Use short ID prefixes for speed (first 7 chars usually unique)\n- Run `dot slugify` to add readable slugs to existing IDs\n- Archive keeps completed tasks accessible via `dot ls --status done`\n- Use `dot purge` to permanently delete all archived tasks\n- Tasks are git-friendly - commit `.dots/` to track project history\n",
        "skills/git-spice/SKILL.md": "---\nname: git-spice\ndescription: >-\n  This skill should be used when the user asks about \"stacked branches\",\n  \"git-spice\", \"gs command\", \"stacked PRs\", \"stacked pull requests\",\n  \"stacked merge requests\", \"branch stacks\", \"restack branches\",\n  \"submit stack\", \"gs branch\", \"gs stack\", \"gs upstack\", \"gs downstack\",\n  \"gs repo sync\", or needs help managing multiple dependent branches.\nversion: 0.1.0\n---\n\n# git-spice CLI\n\ngit-spice (`gs`) is a CLI tool for managing stacked Git branches.\nIt tracks relationships between branches, enables easy navigation,\nand creates stacked Pull Requests on GitHub or Merge Requests on GitLab.\n\n## Key Concepts\n\n- **Stack**: Collection of branches stacked on top of each other\n- **Trunk**: The default branch (main/master) with no base\n- **Upstack**: Branches above the current branch\n- **Downstack**: Branches below the current branch (not including trunk)\n- **Restacking**: Rebasing a branch onto its base to maintain linear history\n\n## Command Reference\n\n### Repository Commands (`gs repo` / `gs r`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs repo init` | `gs ri` | Initialize git-spice in a repository |\n| `gs repo sync` | `gs rs` | Pull latest changes, delete merged branches |\n| `gs repo restack` | `gs rr` | Restack all tracked branches |\n\n### Branch Commands (`gs branch` / `gs b`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs branch create <name>` | `gs bc` | Create and track a new stacked branch |\n| `gs branch track` | `gs bt` | Track an existing branch |\n| `gs branch untrack` | `gs but` | Stop tracking a branch (keep in Git) |\n| `gs branch checkout <name>` | `gs bco` | Check out a branch (interactive if no name) |\n| `gs branch delete <name>` | `gs bd` | Delete a tracked branch |\n| `gs branch rename <new>` | `gs brn` | Rename the current branch |\n| `gs branch submit` | `gs bs` | Submit current branch as a CR |\n| `gs branch restack` | `gs br` | Restack current branch onto its base |\n| `gs branch edit` | `gs be` | Interactive rebase of branch commits |\n| `gs branch squash` | `gs bsq` | Squash all commits in current branch |\n| `gs branch split` | `gs bsp` | Split branch into multiple branches |\n| `gs branch onto <base>` | `gs bo` | Move branch to a different base |\n| `gs branch fold` | `gs bf` | Fold branch into its base |\n\n### Stack Commands (`gs stack` / `gs s`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs stack submit` | `gs ss` | Submit all branches in the stack |\n| `gs stack restack` | `gs sr` | Restack all branches in the stack |\n| `gs stack edit` | `gs se` | Edit order of branches in the stack |\n| `gs stack delete` | `gs sd` | Delete all branches in the stack |\n\n### Upstack Commands (`gs upstack` / `gs us`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs upstack submit` | `gs uss` | Submit current branch and those above |\n| `gs upstack restack` | `gs usr` | Restack current branch and upstack |\n| `gs upstack onto <base>` | `gs uso` | Move branch and upstack to new base |\n| `gs upstack delete` | `gs usd` | Delete all branches above current |\n\n### Downstack Commands (`gs downstack` / `gs ds`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs downstack submit` | `gs dss` | Submit current branch and those below |\n| `gs downstack track` | `gs dst` | Track multiple branches at once |\n| `gs downstack edit` | `gs dse` | Edit order of downstack branches |\n\n### Commit Commands (`gs commit` / `gs c`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs commit create` | `gs cc` | Commit and restack upstack branches |\n| `gs commit amend` | `gs ca` | Amend last commit and restack |\n| `gs commit split` | `gs csp` | Split last commit into two |\n| `gs commit fixup` | `gs cf` | Create a fixup commit |\n| `gs commit pick` | `gs cp` | Cherry-pick commits into branch |\n\n### Navigation Commands\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs up` | `gs u` | Move up one branch in the stack |\n| `gs down` | `gs d` | Move down one branch in the stack |\n| `gs top` | `gs U` | Move to top of stack |\n| `gs bottom` | `gs D` | Move to bottom of stack |\n| `gs trunk` | - | Move to trunk branch |\n\n### Log Commands (`gs log` / `gs l`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs log short` | `gs ls` | Show branches as a tree |\n| `gs log long` | `gs ll` | Show branches with commits |\n\nAdd `--all` to show all stacks, not just the current one.\nAdd `--json` for machine-readable output.\n\n### Authentication (`gs auth`)\n\n| Command | Description |\n|---------|-------------|\n| `gs auth login` | Authenticate with GitHub/GitLab |\n| `gs auth logout` | Log out from the service |\n| `gs auth status` | Show authentication status |\n\n### Rebase Commands (`gs rebase` / `gs rb`)\n\n| Command | Shorthand | Description |\n|---------|-----------|-------------|\n| `gs rebase continue` | `gs rbc` | Continue interrupted rebase |\n| `gs rebase abort` | `gs rba` | Abort the current rebase |\n\n## Common Workflows\n\n### Create a New Stack\n\n```bash\n# Start from trunk\ngs trunk\n\n# Create first feature branch\ngit add file.txt\ngs branch create feat1\n\n# Stack another branch on top\ngit add another.txt\ngs branch create feat2\n```\n\n### Submit a Stack for Review\n\n```bash\n# Submit entire stack\ngs stack submit\n\n# Or submit with auto-filled PR info\ngs stack submit --fill\n```\n\n### Modify Mid-Stack and Update\n\n```bash\n# Navigate to the branch to modify\ngs down  # or: gs bco feat1\n\n# Make changes and commit\ngit add file.txt\ngs commit create -m \"fix typo\"\n\n# Submit updates to all CRs\ngs stack submit\n```\n\n### Sync After Merges\n\n```bash\n# Pull latest, delete merged branches, restack remaining\ngs repo sync\n```\n\n### Move a Branch to Different Base\n\n```bash\n# Move current branch and upstack to main\ngs upstack onto main\n\n# Move only current branch (leave upstack in place)\ngs branch onto main\n```\n\n### Split a Branch\n\n```bash\n# Interactively split current branch at commit boundaries\ngs branch split\n```\n\n## Common Flags\n\n- `--fill` / `-c`: Auto-fill CR info from commits\n- `--draft` / `--no-draft`: Set CR draft status\n- `--force`: Force push (override safety checks)\n- `--update-only`: Only update existing CRs, don't create new ones\n- `-n` / `--dry-run`: Show what would happen without doing it\n- `--no-prompt`: Disable interactive prompts\n\n## Configuration\n\nSet options with `git config`:\n\n```bash\n# Create branches without committing by default\ngit config spice.branchCreate.commit false\n\n# Add prefix to all created branches\ngit config spice.branchCreate.prefix \"user/\"\n\n# Create CRs as drafts by default\ngit config spice.submit.draft true\n\n# Open browser when CR is created\ngit config spice.submit.web created\n\n# Add default labels to all CRs\ngit config spice.submit.label \"needs-review\"\n\n# Add default reviewers\ngit config spice.submit.reviewers \"alice,myorg/team\"\n```\n\n## Tips\n\n- Use `--help` on any command to see its shorthand\n- Interactive prompts provide fuzzy search for branch selection\n- Navigation commands accept `-n` to print target without switching\n- Use `gs bco` without arguments for an interactive branch picker\n",
        "skills/ripgrep/SKILL.md": "---\nname: ripgrep\ndescription: This skill should be used when the user asks about \"ripgrep\", \"rg command\", \"fast grep\", \"search files\", \"code search\", \"regex search in files\", \"find in files\", \"search codebase\", \"grep replacement\", or needs guidance on file content searching, pattern matching, or recursive text search. Provides command reference, usage patterns, and best practices for ripgrep (rg).\n---\n\n# ripgrep (rg) CLI Reference\n\nripgrep is a line-oriented search tool that recursively searches directories for regex patterns. It respects `.gitignore` rules by default and automatically skips hidden files, directories, and binary files.\n\n## Basic Usage\n\n```bash\n# Search for pattern in current directory (recursive)\nrg 'pattern'\n\n# Search specific file\nrg 'pattern' file.txt\n\n# Search specific directory\nrg 'pattern' src/\n\n# Multiple paths\nrg 'pattern' src/ tests/ docs/\n```\n\n## Essential Flags\n\n| Flag | Short | Description |\n|------|-------|-------------|\n| `--ignore-case` | `-i` | Case-insensitive search |\n| `--smart-case` | `-S` | Case-insensitive unless pattern has uppercase |\n| `--word-regexp` | `-w` | Match whole words only |\n| `--fixed-strings` | `-F` | Treat pattern as literal string (no regex) |\n| `--count` | `-c` | Show count of matches per file |\n| `--files-with-matches` | `-l` | Show only filenames with matches |\n| `--files-without-match` | `-L` | Show only filenames without matches |\n| `--line-number` | `-n` | Show line numbers (default when output is terminal) |\n| `--no-line-number` | `-N` | Suppress line numbers |\n| `--only-matching` | `-o` | Print only the matched text |\n| `--invert-match` | `-v` | Show non-matching lines |\n| `--multiline` | `-U` | Enable multiline matching (`.` matches newlines) |\n\n## Context Lines\n\n```bash\n# Show 3 lines after each match\nrg -A 3 'pattern'\n\n# Show 3 lines before each match\nrg -B 3 'pattern'\n\n# Show 3 lines before and after (context)\nrg -C 3 'pattern'\n```\n\n## File Filtering\n\n### By File Type\n\n```bash\n# Search only in Rust files\nrg 'pattern' --type rust\nrg 'pattern' -trust\n\n# Exclude JavaScript files\nrg 'pattern' --type-not js\nrg 'pattern' -Tjs\n\n# List all available types\nrg --type-list\n\n# Define custom type\nrg --type-add 'web:*.{html,css,js}' -tweb 'pattern'\n```\n\nCommon built-in types: `py`, `js`, `ts`, `rust`, `go`, `java`, `c`, `cpp`, `html`, `css`, `json`, `yaml`, `md`, `sh`\n\n### By Glob Pattern\n\n```bash\n# Include only .toml files\nrg 'pattern' -g '*.toml'\n\n# Include files in specific directory\nrg 'pattern' -g 'src/**/*.rs'\n\n# Exclude files (prefix with !)\nrg 'pattern' -g '!*.min.js'\n\n# Multiple globs\nrg 'pattern' -g '*.rs' -g '*.toml'\n```\n\n## Automatic Filtering Control\n\nripgrep automatically ignores:\n1. Files matching `.gitignore`, `.ignore`, `.rgignore` patterns\n2. Hidden files and directories\n3. Binary files\n\n```bash\n# Disable .gitignore filtering\nrg --no-ignore 'pattern'\n\n# Search hidden files\nrg --hidden 'pattern'\nrg -. 'pattern'\n\n# Search binary files as text\nrg --text 'pattern'\nrg -a 'pattern'\n\n# Shorthand for disabling filters\nrg -u 'pattern'    # --no-ignore\nrg -uu 'pattern'   # --no-ignore --hidden\nrg -uuu 'pattern'  # --no-ignore --hidden --text\n```\n\n## Regex Patterns\n\nripgrep uses Rust regex syntax by default.\n\n```bash\n# Word characters followed by digits\nrg '\\w+\\d+'\n\n# Start/end of line anchors\nrg '^start'\nrg 'end$'\n\n# Character classes\nrg '[A-Z][a-z]+'\n\n# Alternation\nrg 'foo|bar'\n\n# Quantifiers\nrg 'colou?r'       # 0 or 1\nrg 'a+'            # 1 or more\nrg 'a*'            # 0 or more\nrg 'a{2,4}'        # 2 to 4 times\n\n# Non-greedy matching\nrg 'a+?'\n\n# Lookahead/lookbehind (requires PCRE2)\nrg -P '(?<=prefix)\\w+'    # Lookbehind\nrg -P '\\w+(?=suffix)'     # Lookahead\n```\n\n### PCRE2 Mode\n\nEnable PCRE2 for advanced regex features:\n\n```bash\n# Enable PCRE2\nrg -P 'pattern'\nrg --pcre2 'pattern'\n\n# Auto-detect when PCRE2 is needed\nrg --engine auto 'pattern'\n```\n\n## Multiline Search\n\n```bash\n# Basic multiline (dot matches newline)\nrg -U 'start.*end'\n\n# Match across lines with PCRE2\nrg -UP 'function\\s+\\w+\\s*\\([^)]*\\)\\s*\\{'\n```\n\n## Replacements (Output Only)\n\nripgrep never modifies files. The `--replace` flag transforms output only.\n\n```bash\n# Simple replacement\nrg 'old' -r 'new'\n\n# With capture groups\nrg '(\\w+)@(\\w+)' -r '$2:$1'\n\n# Named capture groups\nrg '(?P<user>\\w+)@(?P<domain>\\w+)' -r '$domain:$user'\n```\n\n## Output Formats\n\n```bash\n# JSON output (for parsing)\nrg --json 'pattern'\n\n# Null-separated filenames (for xargs -0)\nrg -l --null 'pattern'\n\n# Show only matching files\nrg -l 'pattern'\n\n# Show files that would be searched\nrg --files\n\n# Show files matching glob\nrg --files -g '*.rs'\n```\n\n## Performance Options\n\n```bash\n# Limit search depth\nrg --max-depth 3 'pattern'\n\n# Limit results\nrg --max-count 5 'pattern'    # Per file\nrg 'pattern' | head -n 100    # Total\n\n# Disable memory maps (for consistency)\nrg --no-mmap 'pattern'\n\n# Sort results by path\nrg --sort path 'pattern'\n```\n\n## Common Patterns\n\n### Find function definitions\n\n```bash\n# Rust\nrg '^(pub\\s+)?(async\\s+)?fn\\s+\\w+'\n\n# Python\nrg '^def \\w+|^class \\w+'\n\n# JavaScript/TypeScript\nrg '(function|const|let|var)\\s+\\w+\\s*='\n```\n\n### Find TODO/FIXME comments\n\n```bash\nrg 'TODO|FIXME|XXX|HACK' -g '!*.min.*'\n```\n\n### Find imports/requires\n\n```bash\n# Python\nrg '^(import|from)\\s+\\w+'\n\n# JavaScript\nrg \"^(import|require\\()\"\n\n# Go\nrg '^import\\s+'\n```\n\n### Search specific patterns\n\n```bash\n# IP addresses (approximate)\nrg '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'\n\n# Email addresses (simple)\nrg '\\w+@\\w+\\.\\w+'\n\n# URLs\nrg 'https?://[^\\s]+'\n```\n\n## Configuration File\n\nSet default options via `RIPGREP_CONFIG_PATH`:\n\n```bash\nexport RIPGREP_CONFIG_PATH=\"$HOME/.ripgreprc\"\n```\n\nExample `~/.ripgreprc`:\n\n```\n--smart-case\n--hidden\n--glob=!.git/*\n--max-columns=150\n--max-columns-preview\n```\n\n## Debugging\n\n```bash\n# Show what files would be searched and why others are ignored\nrg --debug 'pattern'\n\n# Disable config file\nrg --no-config 'pattern'\n```\n\n## Key Differences from grep\n\n| Feature | ripgrep | GNU grep |\n|---------|---------|----------|\n| Recursive by default | Yes | No (`-r` required) |\n| Respects .gitignore | Yes | No |\n| Skips binary files | Yes | No |\n| Unicode by default | Yes | Depends on locale |\n| Parallel search | Yes | No |\n| Memory-mapped files | Yes | No |\n\n## Reference\n\nFor advanced features, see:\n- [references/advanced.md](references/advanced.md) - Preprocessors, encoding, binary handling\n",
        "skills/ripgrep/references/advanced.md": "# Advanced ripgrep Features\n\n## Preprocessors\n\nTransform file contents before searching using `--pre`:\n\n```bash\n# Create a preprocessor script\ncat > ~/bin/pre-rg << 'EOF'\n#!/bin/sh\ncase \"$1\" in\n*.pdf)\n  if [ -s \"$1\" ]; then\n    exec pdftotext - -\n  else\n    exec cat\n  fi\n  ;;\n*)\n  exec cat\n  ;;\nesac\nEOF\nchmod +x ~/bin/pre-rg\n\n# Use the preprocessor\nrg --pre ~/bin/pre-rg 'pattern' document.pdf\n\n# Limit preprocessor to specific files (performance)\nrg --pre ~/bin/pre-rg --pre-glob '*.pdf' 'pattern'\n```\n\n## File Encoding\n\n```bash\n# Auto-detect encoding (default, handles UTF-16 BOM)\nrg -E auto 'pattern'\n\n# Specify encoding\nrg -E utf-16 'pattern'\nrg -E latin1 'pattern'\n\n# Disable encoding detection (raw bytes)\nrg -E none 'pattern'\n\n# Search raw UTF-16\nrg '(?-u)\\(\\x045\\x04@\\x04' -E none -a file\n```\n\nSupported encodings: UTF-8, UTF-16, latin1, GBK, EUC-JP, Shift_JIS, and more from the Encoding Standard.\n\n## Binary File Handling\n\nripgrep operates in three binary modes:\n\n### Default Mode\nStops searching when NUL byte found (for recursive directory traversal):\n```bash\nrg 'pattern'\n```\n\n### Binary Mode\nContinues searching but stops output on first match:\n```bash\nrg --binary 'pattern'\n```\n\n### Text Mode\nTreat all files as text:\n```bash\nrg -a 'pattern'\nrg --text 'pattern'\n```\n\n## Compressed Files\n\n```bash\n# Search compressed files\nrg -z 'pattern' archive.gz\nrg --search-zip 'pattern' *.tar.gz\n\n# Supported formats: gzip, bzip2, lzma, xz, lz4, brotli, zstd\n```\n\n## Symbolic Links\n\n```bash\n# Follow symlinks during directory traversal\nrg -L 'pattern'\nrg --follow 'pattern'\n```\n\n## Output Column Control\n\n```bash\n# Limit column width\nrg -M 150 'pattern'\nrg --max-columns 150 'pattern'\n\n# Show preview of truncated lines\nrg --max-columns 150 --max-columns-preview 'pattern'\n\n# Show column number of match\nrg --column 'pattern'\n```\n\n## Sorting and Ordering\n\n```bash\n# Sort by file path\nrg --sort path 'pattern'\n\n# Sort by modification time\nrg --sort modified 'pattern'\n\n# Reverse sort\nrg --sortr path 'pattern'\n```\n\nNote: Sorting disables parallelism.\n\n## Statistics\n\n```bash\n# Show search statistics\nrg --stats 'pattern'\n```\n\n## Passthrough Mode\n\nPrint all lines, highlighting matches:\n\n```bash\nrg --passthru 'pattern' file.txt\n```\n\n## Count Modes\n\n```bash\n# Count matching lines per file\nrg -c 'pattern'\n\n# Count all matches (not just lines)\nrg --count-matches 'pattern'\n```\n\n## Null Data Mode\n\nFor files with NUL-separated records instead of newlines:\n\n```bash\nrg --null-data 'pattern'\n```\n\n## Color Control\n\n```bash\n# Force colors (even when piping)\nrg --color always 'pattern' | less -R\n\n# Disable colors\nrg --color never 'pattern'\n\n# Customize colors\nrg --colors 'match:fg:red' --colors 'match:style:bold' 'pattern'\n```\n\nAvailable color specs: `path`, `line`, `column`, `match`\n\n## Hyperlinks\n\n```bash\n# Enable hyperlinks in terminal output (clickable paths)\nrg --hyperlink-format default 'pattern'\n```\n\n## Environment Variables\n\n| Variable | Description |\n|----------|-------------|\n| `RIPGREP_CONFIG_PATH` | Path to config file |\n| `NO_COLOR` | Disable color output |\n\n## Performance Tips\n\n1. Use `--pre-glob` with `--pre` to limit preprocessor invocations\n2. Use `--max-depth` to limit directory depth\n3. Use `-t type` instead of `-g '*.ext'` when possible (faster)\n4. Use `--no-mmap` for consistent behavior across platforms\n5. Specific paths are faster than recursive search\n6. `-F` (fixed strings) is faster than regex for literal patterns\n"
      },
      "plugins": [
        {
          "name": "clode",
          "source": "./",
          "description": "Personal productivity plugin with task management, coding practices, and example scaffolds",
          "version": "0.1.0",
          "category": "productivity",
          "categories": [
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add alexeldeib/clode",
            "/plugin install clode@clode"
          ]
        }
      ]
    }
  ]
}