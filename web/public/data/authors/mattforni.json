{
  "author": {
    "id": "mattforni",
    "display_name": "Matthew Fornaciari",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/13540?u=2e9fd1bce4f60a270a5d2180a6b5349325ef9b34&v=4",
    "url": "https://github.com/mattforni",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 1,
      "total_skills": 6,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "skillset",
      "version": null,
      "description": "A curated collection of Claude Code plugins for enhanced development workflows",
      "owner_info": {
        "name": "Matthew Fornaciari",
        "email": "matt@fornaciari.com",
        "url": "https://github.com/mattforni"
      },
      "keywords": [],
      "repo_full_name": "mattforni/skillset",
      "repo_url": "https://github.com/mattforni/skillset",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-29T16:42:42Z",
        "created_at": "2025-11-19T22:28:59Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1967
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/linear-lifecycle",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/linear-lifecycle/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/linear-lifecycle/commands/linear-setup.md",
          "type": "blob",
          "size": 378
        },
        {
          "path": "plugins/linear-lifecycle/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/linear-lifecycle/skills/linear-lifecycle",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/linear-lifecycle/skills/linear-lifecycle/SKILL.md",
          "type": "blob",
          "size": 6644
        },
        {
          "path": "plugins/sdlc",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sdlc/README.md",
          "type": "blob",
          "size": 904
        },
        {
          "path": "plugins/sdlc/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sdlc/skills/checkpoint",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sdlc/skills/checkpoint/SKILL.md",
          "type": "blob",
          "size": 1835
        },
        {
          "path": "plugins/sdlc/skills/complete",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sdlc/skills/complete/SKILL.md",
          "type": "blob",
          "size": 3211
        },
        {
          "path": "plugins/sdlc/skills/iterate",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sdlc/skills/iterate/SKILL.md",
          "type": "blob",
          "size": 2860
        },
        {
          "path": "plugins/sdlc/skills/plan",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sdlc/skills/plan/SKILL.md",
          "type": "blob",
          "size": 3118
        },
        {
          "path": "plugins/sdlc/skills/review",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sdlc/skills/review/SKILL.md",
          "type": "blob",
          "size": 3246
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"skillset\",\n  \"owner\": {\n    \"name\": \"Matthew Fornaciari\",\n    \"email\": \"matt@fornaciari.com\",\n    \"url\": \"https://github.com/mattforni\"\n  },\n  \"metadata\": {\n    \"version\": \"1.0.0\",\n    \"description\": \"A curated collection of Claude Code plugins for enhanced development workflows\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"linear-lifecycle\",\n      \"source\": \"./plugins/linear-lifecycle\",\n      \"version\": \"1.0.0\",\n      \"license\": \"MIT\",\n      \"description\": \"Manage Linear issues via Linearis CLI with zero-context overhead. Create, update, and track issues without loading large MCPs.\",\n      \"homepage\": \"https://github.com/mattforni/skillset\",\n      \"repository\": \"https://github.com/mattforni/skillset\",\n      \"author\": {\n        \"name\": \"Matthew Fornaciari\",\n        \"url\": \"https://github.com/mattforni\"\n      },\n      \"category\": \"development\",\n      \"keywords\": [\"linear\", \"issue-tracking\", \"cli\", \"workflow\", \"linearis\", \"project-management\"],\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/linear-lifecycle/SKILL.md\"\n      ],\n      \"commands\": [\n        \"./commands/linear-setup.md\"\n      ]\n    },\n    {\n      \"name\": \"sdlc\",\n      \"source\": \"./plugins/sdlc\",\n      \"version\": \"1.0.0\",\n      \"license\": \"MIT\",\n      \"description\": \"Software development lifecycle skills for planning, implementing, reviewing, and completing work.\",\n      \"homepage\": \"https://github.com/mattforni/skillset\",\n      \"repository\": \"https://github.com/mattforni/skillset\",\n      \"author\": {\n        \"name\": \"Matthew Fornaciari\",\n        \"url\": \"https://github.com/mattforni\"\n      },\n      \"category\": \"development\",\n      \"keywords\": [\"sdlc\", \"workflow\", \"git\", \"pr\", \"review\", \"development\", \"lifecycle\"],\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/plan/SKILL.md\",\n        \"./skills/checkpoint/SKILL.md\",\n        \"./skills/review/SKILL.md\",\n        \"./skills/iterate/SKILL.md\",\n        \"./skills/complete/SKILL.md\"\n      ]\n    }\n  ]\n}\n",
        "plugins/linear-lifecycle/commands/linear-setup.md": "---\nname: linear-setup\ndescription: Configure Linear API token and team key for the linear-lifecycle plugin\n---\n\nCopying setup command to clipboard...\n\n```bash\necho \"bash ~/.claude/plugins/marketplaces/skillset/plugins/linear-lifecycle/skills/linear-lifecycle/scripts/setup.sh\" | pbcopy && echo \"✓ Command copied to clipboard! Paste it in your terminal to run the setup.\"\n```\n",
        "plugins/linear-lifecycle/skills/linear-lifecycle/SKILL.md": "---\nname: linear-lifecycle\ndescription: Use when working with Linear issues across development workflow - uses Linearis CLI with JSON output for zero-context issue management. Get details, create issues, update status, and add comments without consuming tokens in main session.\n---\n\n# Linear Lifecycle Management with Linearis CLI\n\n## Overview\n\n**Core principle:** Use Linearis CLI for all Linear operations instead of loading 20k token Linear MCP. CLI returns structured JSON for parsing without context overhead.\n\n**Tool:** [Linearis](https://github.com/czottmann/linearis) - Linear CLI built for LLM agents with ~1000 token footprint vs 13k+ for MCP.\n\n**Context savings:** 100% - no MCP loaded, just bash commands with JSON output.\n\n## Setup\n\n**One-time dependencies install:**\n\nUse `/linear-setup` to install Linearis CLI (required for this skill to work).\n\n**Token configuration:**\n\nAutomatic! On first use, Claude will:\n\n1. Check if `~/.linear_api_token` exists\n2. If not, prompt you for your Linear API token\n3. Save it to `~/.linear_api_token` with secure permissions\n4. Verify the connection works\n\n**Get your token:** Linear Settings → Security & Access → Personal API keys\n\n## When to Use\n\n**Use this skill when:**\n\n- Starting work on a Linear issue (need issue details)\n- Creating new issues from bugs or features discovered\n- Updating issue status during development\n- Adding comments or progress updates\n- Searching for issues across teams/projects\n\n**Don't use when:**\n\n- Issue tracking not needed for current work\n- Working on non-Linear projects\n\n## Implementation\n\n**IMPORTANT: Always check for token on first Linear operation in a skill invocation:**\n\n```bash\n# Check if token exists\nif [ ! -f ~/.linear_api_token ]; then\n  echo \"⚠️  Linear API token not found.\"\n  echo \"\"\n  echo \"Get your token from: Linear Settings → Security & Access → Personal API keys\"\n  echo \"\"\n  # Use AskUserQuestion tool to prompt for token\n  # Save response to ~/.linear_api_token\n  # Set permissions: chmod 600 ~/.linear_api_token\n  # Verify it works with: linearis issues list -l 1\nfi\n```\n\nAfter token is confirmed, proceed with Linear operations. Linearis automatically reads from `~/.linear_api_token`.\n\n### Creating a New Issue\n\n**IMPORTANT: Keep it simple! Specify the team key directly. Never use --labels or --priority.**\n\n**User request:** \"Create a Linear issue for fixing the avatar crop bug\"\n\n**Command:**\n\n```bash\nlinearis issues create \"Fix avatar crop bug\" \\\n  --team BET \\\n  --description \"Avatar images are cropping incorrectly on mobile devices. Need to adjust aspect ratio handling.\"\n```\n\n**Key rules:**\n\n- ✅ Use `--team TEAM_KEY` (get from user's Linear workspace, e.g. BET, ENG, etc.)\n- ✅ Keep description clear and concise\n- ❌ NEVER use --labels (causes errors)\n- ❌ NEVER use --priority (unnecessary)\n\n**Parse response:**\n\n```bash\n# Returns JSON with: {identifier, title, url, ...}\n# Extract: issue ID (e.g., BET-145) and URL\n```\n\n**Response to user:**\n\n```markdown\n✓ Created issue BET-145: Fix avatar crop bug\nhttps://linear.app/your-workspace/issue/BET-145\n```\n\n### Starting Work on an Issue\n\n**User request:** \"Start working on bet-123\"\n\n**Command:**\n\n```bash\nlinearis issues read BET-123\n```\n\n**Parse JSON response for:**\n\n- title\n- description\n- state (current status)\n- priority\n- labels\n- branchName (suggested git branch)\n\n**Response to user:**\n\n```markdown\nIssue: BET-123 - [Title]\nStatus: [State]\nDescription: [Brief description]\nLabels: [labels]\nBranch: [branchName or generate from title]\n\nCreating branch [branch-name]...\n```\n\n**Then create branch and proceed with development.**\n\n### Updating Issue Status\n\n**User request:** \"Update bet-456 to in progress\"\n\n**Command:**\n\n```bash\nlinearis issues update BET-456 --state \"In Progress\"\n```\n\n**Response:**\n\n```markdown\n✓ Updated BET-456 to In Progress\n```\n\n### Adding Comments\n\n**User request:** \"Add comment to bet-789 about the refactor being done\"\n\n**Command:**\n\n```bash\nlinearis comments create BET-789 --body \"Completed auth refactor. Moved from Context API to Zustand for better performance. All tests passing.\"\n```\n\n**Response:**\n\n```markdown\n✓ Added comment to BET-789\n```\n\n### Searching for Issues\n\n**User request:** \"Find all open bugs with label 'authentication'\"\n\n**Command:**\n\n```bash\nlinearis issues search \"authentication\" --team \"$LINEAR_TEAM_KEY\" | jq '.[] | select(.labels[]? | contains(\"bug\")) | {id: .identifier, title: .title, state: .state.name}'\n```\n\n**Parse and format results as table.**\n\n### Completing Work\n\n**User request:** \"Close bet-789, PR merged\"\n\n**Commands:**\n\n```bash\n# 1. Add completion comment\nlinearis comments create BET-789 --body \"Feature complete. PR #456 merged to main.\"\n\n# 2. Update status to done\nlinearis issues update BET-789 --state \"Done\"\n```\n\n**Response:**\n\n```markdown\n✓ Marked BET-789 as Done\n✓ Added completion comment\n```\n\n## Quick Reference\n\n| Operation | Command Pattern |\n|-----------|----------------|\n| List recent issues | `linearis issues list -l 10` |\n| Get issue details | `linearis issues read ABC-123` |\n| Create issue | `linearis issues create \"Title\" --team TEAM_KEY --description \"Description\"` |\n| Update status | `linearis issues update ABC-123 --state \"In Progress\"` |\n| Add comment | `linearis comments create ABC-123 --body \"Comment text\"` |\n| Search issues | `linearis issues search \"query\"` |\n\n## Common Mistakes\n\n**Not parsing JSON output**\n\n- ❌ Don't show raw JSON to user\n- ✅ Parse and format relevant fields cleanly\n\n**Hardcoding team/project names**\n\n- ❌ Don't assume team structure\n- ✅ Let user specify or discover via linearis commands\n\n**Using issue IDs incorrectly**\n\n- ❌ Don't lowercase (bet-123) in commands\n- ✅ Use proper case (BET-123) - linearis handles both but be consistent\n\n## Real-World Impact\n\n**Before (Linear MCP):**\n\n- 20k tokens consumed at session start\n- All tools loaded in context\n- Context budget: 180k/200k remaining\n\n**After (Linearis CLI):**\n\n- 0 tokens in session (just bash commands)\n- JSON parsing lightweight\n- Context budget: 200k/200k remaining\n- **100% context savings**\n\n**Performance:**\n\n- Linearis usage docs: ~1000 tokens\n- MCP tool definitions: ~13000 tokens\n- **92% reduction even for reference material**\n\n## Advanced: Multi-Team Operations\n\n**List issues across teams:**\n\n```bash\nlinearis issues list --team Frontend -l 5\nlinearis issues list --team Backend -l 5\n```\n\n**Create issue in specific team:**\n\n```bash\nlinearis issues create \"Fix API timeout\" --team Backend\n```\n\n**No workspace switching needed** - all commands accept `--team` flag for cross-team operations within same Linear workspace.\n",
        "plugins/sdlc/README.md": "# SDLC Plugin\n\nSoftware development lifecycle skills for planning, implementing, reviewing, and completing work.\n\n## Quick Start\n\n```bash\nclaude plugin marketplace add mattforni/skillset\nclaude plugin install sdlc@mattforni/skillset\n```\n\n## Skills\n\n| Skill | Description |\n|-------|-------------|\n| `/sdlc:plan` | Start work on an issue with branch setup and plan mode |\n| `/sdlc:checkpoint` | Save work in progress (commit + push, no PR) |\n| `/sdlc:review` | Create PR and request code review |\n| `/sdlc:iterate` | Address PR feedback, request re-review |\n| `/sdlc:complete` | Reset environment for next task |\n\n## Workflow\n\n```text\n/sdlc:plan <issue-id> → [implement] → (/sdlc:checkpoint)* → /sdlc:review → (/sdlc:iterate)* → /sdlc:complete\n```\n\n## Full Documentation\n\nSee [docs/plugins/sdlc.md](../../docs/plugins/sdlc.md) for detailed usage, configuration options, and skill documentation.\n",
        "plugins/sdlc/skills/checkpoint/SKILL.md": "---\nname: sdlc:checkpoint\ndescription: Save work in progress with commit and push (no PR)\nargument-hint: [optional commit message]\nallowed-tools:\n  - Bash(git:*)\n  - Grep\n  - Read\n---\n\n# Checkpoint\n\nSave current work in progress to remote. This creates a commit and pushes but does NOT create a PR.\n\n## Workflow\n\n1. **Verify branch state** - Must be on a feature branch, not main\n2. **Analyze changes** - Review what will be committed\n3. **Stage all changes** - Add all modified and untracked files\n4. **Generate commit message** - Create informative message from changes\n5. **Commit and push** - Save to remote\n\n## Step 1: Verify Branch State\n\n```bash\nBASE_BRANCH=$(../../scripts/get-base-branch.sh)\nCURRENT_BRANCH=$(git branch --show-current)\n\nif [[ \"$CURRENT_BRANCH\" == \"$BASE_BRANCH\" ]]; then\n  echo \"ERROR: Cannot checkpoint on default branch ($BASE_BRANCH)\"\n  echo \"Create a feature branch first with: git checkout -b <branch-name>\"\n  exit 1\nfi\n```\n\n## Step 2: Check for Changes\n\n```bash\nif [ -z \"$(git status --porcelain)\" ]; then\n  echo \"No changes to checkpoint. Working directory is clean.\"\n  exit 0\nfi\n\ngit status\ngit diff --stat\n```\n\n## Step 3: Stage All Changes\n\n```bash\ngit add -A\n```\n\n## Step 4: Generate Commit Message\n\nIf the user provided a message via `$ARGUMENTS`, use it as the commit message prefix.\n\nOtherwise, analyze the staged changes to generate an appropriate message:\n\n- Look at modified files to understand the scope\n- Create a concise summary of changes\n- Follow conventional commit format when appropriate\n\n## Step 5: Commit and Push\n\n```bash\ngit commit -m \"$(cat <<'EOF'\n<commit message here>\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n)\"\n\ngit push -u origin HEAD\n```\n\n## Output\n\nConfirm the checkpoint was successful:\n\n```\nCheckpoint saved to <branch-name>\nCommit: <short-hash> <message>\n```\n",
        "plugins/sdlc/skills/complete/SKILL.md": "---\nname: sdlc:complete\ndescription: Finish work and reset local environment for next task\nallowed-tools:\n  - Bash(continue)\n  - Bash(do:*)\n  - Bash(done)\n  - Bash(gh:*)\n  - Bash(git:*)\n  - Bash(linearis:*)\n  - Bash(while:*)\n---\n\n# Complete Work\n\nFinish the current task and reset the local environment for the next piece of work.\n\n## Workflow\n\n1. **Verify PR is merged** - Confirm the work is complete\n2. **Update Linear issue** - Mark as Done (if applicable)\n3. **Checkout main** - Switch to main branch\n4. **Pull latest** - Get all merged changes\n5. **Cleanup branches** - Delete merged local branches\n6. **Confirm reset** - Show clean state\n\n## Step 1: Verify PR is Merged\n\nCheck if the current branch has a merged PR:\n\n```bash\nBASE_BRANCH=$(../../scripts/get-base-branch.sh)\nCURRENT_BRANCH=$(git branch --show-current)\n\n# Skip if already on default branch\nif [ \"$CURRENT_BRANCH\" = \"$BASE_BRANCH\" ]; then\n  echo \"Already on default branch ($BASE_BRANCH)\"\nelse\n  # Check PR status\n  PR_STATE=$(gh pr view --json state --jq '.state' 2>/dev/null || echo \"NONE\")\n\n  if [ \"$PR_STATE\" = \"OPEN\" ]; then\n    echo \"WARNING: PR for $CURRENT_BRANCH is still open\"\n    echo \"Are you sure you want to abandon this work?\"\n    # Continue anyway - user may want to discard\n  elif [ \"$PR_STATE\" = \"MERGED\" ]; then\n    echo \"PR merged successfully\"\n  elif [ \"$PR_STATE\" = \"NONE\" ]; then\n    echo \"No PR found for branch $CURRENT_BRANCH. Proceeding to clean up local branch.\"\n  fi\nfi\n```\n\n## Step 2: Update Linear Issue (Optional)\n\nIf the branch name looks like a Linear issue ID (e.g., `ATE-123`), update its status:\n\n```bash\n# Extract issue ID from branch name if it matches pattern\nISSUE_ID=$(echo \"$CURRENT_BRANCH\" | grep -oE '^[A-Z]+-[0-9]+')\n\nif [ -n \"$ISSUE_ID\" ] && command -v linearis &> /dev/null; then\n  echo \"Marking $ISSUE_ID as Done...\"\n  linearis issues update \"$ISSUE_ID\" --state \"Done\" 2>/dev/null || true\nfi\n```\n\n## Step 3: Checkout Default Branch\n\n```bash\n# BASE_BRANCH was determined in Step 1\ngit checkout \"$BASE_BRANCH\"\n```\n\n## Step 4: Pull Latest\n\n```bash\ngit pull origin \"$BASE_BRANCH\"\n```\n\n## Step 5: Cleanup Branches\n\nPrune remote tracking branches:\n\n```bash\ngit fetch --prune\n```\n\nList branches and identify those that can be deleted:\n\n```bash\ngit branch -vv\n```\n\nFor branches showing `[gone]` (remote was deleted after merge), delete them:\n\n```bash\n# Delete branches where remote is gone (uses conditional formatting for efficiency)\ngit for-each-ref --format='%(if:equals=gone)%(upstream:track,nobracket)%(then)%(refname:short)%(end)' refs/heads | while read -r branch; do\n  [ -z \"$branch\" ] && continue\n  echo \"Deleting merged branch: $branch\"\n  git branch -d \"$branch\"\ndone\n```\n\nAlso delete the branch we were just on if it's different from the default branch:\n\n```bash\nif [ \"$CURRENT_BRANCH\" != \"$BASE_BRANCH\" ]; then\n  git branch -d \"$CURRENT_BRANCH\" 2>/dev/null || true\nfi\n```\n\n## Step 6: Confirm Reset\n\nShow the clean state:\n\n```bash\necho \"\"\necho \"Environment reset complete\"\necho \"Branch: $(git branch --show-current)\"\necho \"Status:\"\ngit status --short\n```\n\n## Output\n\n```\nEnvironment reset complete\nBranch: main\nStatus: (clean)\n\nReady for next task. Use /sdlc:plan <issue-id> to start.\n```\n",
        "plugins/sdlc/skills/iterate/SKILL.md": "---\nname: sdlc:iterate\ndescription: Address PR review feedback and request re-review\nargument-hint: [PR number - auto-detected if on feature branch]\nallowed-tools:\n  - Bash(git:*)\n  - Bash(gh:*)\n  - Grep\n  - Read\n  - Edit\n---\n\n# Iterate on PR Feedback\n\nFetch review comments, address each issue, and request re-review.\n\n## Workflow\n\n1. **Identify PR** - Get PR number from branch or argument\n2. **Fetch review comments** - Get all unresolved feedback\n3. **Address each comment** - Fix issues, apply suggestions\n4. **Commit and push** - Save changes to PR branch\n5. **Request re-review** - Comment with configurable review command\n\n## Step 1: Identify PR\n\nIf `$ARGUMENTS` is provided, use it as the PR number. Otherwise, detect from current branch:\n\n```bash\nif [ -n \"$ARGUMENTS\" ]; then\n  PR_NUMBER=\"$ARGUMENTS\"\nelse\n  PR_NUMBER=$(gh pr view --json number --jq '.number' 2>/dev/null)\n  if [ -z \"$PR_NUMBER\" ]; then\n    echo \"ERROR: No PR found for current branch\"\n    echo \"Usage: /sdlc:iterate <PR_NUMBER>\"\n    exit 1\n  fi\nfi\n```\n\n## Step 2: Fetch Review Comments\n\nGet all review comments from the PR:\n\n```bash\ngh api repos/{owner}/{repo}/pulls/$PR_NUMBER/comments --jq '.[] | {path: .path, line: .line, body: .body, id: .id}'\n```\n\nAlso check for review summaries:\n\n```bash\ngh pr view $PR_NUMBER --json reviews --jq '.reviews[] | {author: .author.login, body: .body, state: .state}'\n```\n\nParse the comments to identify:\n\n- **High priority** issues (bugs, security, data loss)\n- **Medium priority** suggestions (improvements, best practices)\n- **Low priority** style/formatting comments\n\n## Step 3: Address Each Comment\n\nFor each review comment:\n\n1. Read the file and understand the context\n2. Apply the suggested fix or improvement\n3. If the suggestion is unclear, use best judgment\n4. Track which comments were addressed\n\n**Important:** If a comment requires clarification or you disagree with the suggestion, note it for the summary but still make a reasonable fix.\n\n## Step 4: Commit and Push\n\nStage all changes and create a commit:\n\n```bash\ngit add -A\ngit commit -m \"$(cat <<'EOF'\nAddress PR review feedback\n\n<list of addressed items>\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n)\"\n\ngit push\n```\n\n## Step 5: Request Re-Review\n\nGet the configured review command (same pattern as review skill) and comment on the PR:\n\n```bash\n# Get review command: git config > env var > default\nREVIEW_CMD=$(git config --get sdlc.review-command 2>/dev/null)\nif [[ -z \"$REVIEW_CMD\" ]]; then\n  REVIEW_CMD=${SDLC_REVIEW_COMMAND:-\"/gemini review\"}\nfi\n```\n\nSummarize what was addressed and request re-review:\n\n```bash\ngh pr comment $PR_NUMBER --body \"$(cat <<EOF\n## Feedback Addressed\n\n<bulleted list of changes made>\n\n$REVIEW_CMD\nEOF\n)\"\n```\n\n## Output\n\nReport completion:\n\n```\nPR #<number> updated\nAddressed <N> review comments\nRe-review requested via: <REVIEW_CMD>\n```\n",
        "plugins/sdlc/skills/plan/SKILL.md": "---\nname: sdlc:plan\ndescription: Start work on an issue with branch setup and automatic plan mode\nargument-hint: <issue-id>\nallowed-tools:\n  - Bash(git:*)\n  - Bash(linearis:*)\n  - TodoWrite\n  - ExitPlanMode\n  - AskUserQuestion\n---\n\n# Start Planning\n\nStarting work on issue $ARGUMENTS. Setting up git branch and fetching issue details.\n\n## Workflow\n\n1. **Fetch issue details** (if using Linear)\n2. **Set up git branch**\n3. **Enter plan mode for implementation design**\n\n## Step 1: Fetch Issue Details (Optional Linear Integration)\n\nIf the argument looks like a Linear issue ID (e.g., `ATE-123`) and Linearis CLI is available, fetch issue details:\n\n```bash\n# Check if linearis is available and argument looks like a Linear issue\nISSUE_ID=$(echo \"$ARGUMENTS\" | grep -oE '^[A-Z]+-[0-9]+')\nif [ -n \"$ISSUE_ID\" ] && command -v linearis &> /dev/null; then\n  # Try to fetch issue details\n  linearis issues read \"$ISSUE_ID\"\nfi\n```\n\nIf the fetch fails or Linearis is not installed, continue with just the issue ID as the branch name. The user can provide additional context manually.\n\n## Step 2: Set Up Git Branch\n\nFirst, check if there are uncommitted changes:\n\n```bash\nif [ -n \"$(git status --porcelain)\" ]; then\n  echo \"You have uncommitted changes or untracked files in your working directory.\"\nfi\n```\n\nIf uncommitted changes exist, use AskUserQuestion to prompt the user:\n\n- **Stash changes** - Save changes and continue\n- **Commit changes** - Create a quick commit first\n- **Abort** - Stop and let user handle manually\n\nAfter handling uncommitted changes, prepare the repository:\n\n```bash\nBASE_BRANCH=$(../../scripts/get-base-branch.sh)\ngit checkout \"$BASE_BRANCH\"\ngit pull origin \"$BASE_BRANCH\"\n\n# Sanitize arguments for valid branch name\nBRANCH_NAME=$(echo \"$ARGUMENTS\" | tr -s '[:space:]' '-' | tr -cd '[:alnum:]-./_')\nif [ -z \"$BRANCH_NAME\" ] || ! git check-ref-format --branch \"$BRANCH_NAME\" >/dev/null 2>&1; then\n  echo \"ERROR: Could not create a valid branch name from '$ARGUMENTS'. Please provide a valid name.\"\n  exit 1\nfi\ngit checkout -b \"$BRANCH_NAME\"\n```\n\n## Step 3: Fetch and Display Issue Details\n\nParse the issue response and display:\n\n- **Issue ID and Title**\n- **Description** (full text)\n- **Current Status**\n- **Labels** (if any)\n- **Suggested Branch Name** (from Linear)\n\n## Step 4: Create Implementation Plan\n\nYou are now in **plan mode**. Your task is to:\n\n1. **Understand the requirement** from the issue description\n2. **Explore the codebase** to understand relevant files and patterns\n3. **Design the implementation approach**\n4. **Create a detailed plan** using TodoWrite with specific tasks\n5. **Present the plan to the user** for approval\n\n**Do NOT start implementing until the user approves the plan.**\n\nWhen the plan is ready, use ExitPlanMode to request user approval.\n\nAfter user approves, if using Linear integration, update the issue status (reusing `ISSUE_ID` from Step 1):\n\n```bash\n# Reuse ISSUE_ID from Step 1 - only update if it was a valid Linear issue\nif [ -n \"$ISSUE_ID\" ] && command -v linearis &> /dev/null; then\n  linearis issues update \"$ISSUE_ID\" --state \"In Progress\"\nfi\n```\n",
        "plugins/sdlc/skills/review/SKILL.md": "---\nname: sdlc:review\ndescription: Create PR and request code review\nallowed-tools:\n  - Bash(git:*)\n  - Bash(gh:*)\n  - Grep\n  - Read\n  - Edit\n---\n\n# Submit for Review\n\nCreate a commit, push to remote, create a PR, and automatically request code review.\n\n## Workflow\n\n1. **Verify branch state** - Must be on feature branch with changes\n2. **Detect and remove dead code** - Clean up orphaned code\n3. **Stage and commit** - Create informative commit message\n4. **Push to remote** - Ensure upstream tracking\n5. **Create PR** - With comprehensive description\n6. **Request code review** - Auto-comment with configurable review command\n\n## Step 1: Verify Branch State\n\n```bash\nBASE=$(../../scripts/get-base-branch.sh)\nCURRENT_BRANCH=$(git branch --show-current)\n\nif [ \"$CURRENT_BRANCH\" = \"$BASE\" ]; then\n  echo \"ERROR: Cannot create PR from default branch ($BASE)\"\n  exit 1\nfi\n\n# Check for changes\nif [ -z \"$(git status --porcelain)\" ]; then\n  echo \"No changes to commit. Nothing to submit for review.\"\n  exit 0\nfi\n```\n\n## Step 2: Dead Code Detection\n\nAnalyze the git diff to identify removed references:\n\n1. Look for deleted imports, function calls, or type references\n2. Search the codebase for orphaned code (zero references)\n3. If found, delete the dead code files/functions\n4. Report what was cleaned up\n\n**Safe deletion rules:**\n\n- Only delete code with ZERO references\n- Preserve exported members that might be used externally\n- Check both implementation and test files\n\n## Step 3: Stage and Commit\n\n```bash\ngit add -A\n```\n\nAnalyze changes and generate a commit message:\n\n- Summarize the nature of changes (feature, fix, refactor, etc.)\n- Focus on the \"why\" rather than the \"what\"\n- Keep it concise (1-2 sentences)\n\n```bash\ngit commit -m \"$(cat <<'EOF'\n<commit message here>\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n)\"\n```\n\n## Step 4: Push to Remote\n\n```bash\ngit push -u origin HEAD\n```\n\n## Step 5: Create PR\n\nAnalyze all commits on the branch to create PR description:\n\n```bash\nCOMMIT_LOG=$(git log $BASE..HEAD --pretty=format:\"- %s%n%b\")\n```\n\nUse the commit log output to create an informative PR body. Summarize the commits into clear bullet points and generate an appropriate test plan based on what changed.\n\nCreate the PR and capture the URL:\n\n```bash\nPR_URL=$(gh pr create --base $BASE --title \"<PR title>\" --body \"$(cat <<'EOF'\n## Summary\n\n<bullet points derived from $COMMIT_LOG>\n\n## Test Plan\n\n<checklist based on changes made>\n\n---\nGenerated with [Claude Code](https://claude.ai/code)\nEOF\n)\")\n```\n\n## Step 6: Request Review (Configurable)\n\nRequest review using the PR URL from Step 5. The review command is configurable via git config or environment variable:\n\n```bash\n# Get review command: git config > env var > default\nREVIEW_CMD=$(git config --get sdlc.review-command 2>/dev/null)\nif [[ -z \"$REVIEW_CMD\" ]]; then\n  REVIEW_CMD=${SDLC_REVIEW_COMMAND:-\"/gemini review\"}\nfi\n\ngh pr comment \"$PR_URL\" --body \"$REVIEW_CMD\"\n```\n\n**Configuration options:**\n\n- Git config: `git config sdlc.review-command \"/gemini review\"`\n- Environment variable: `export SDLC_REVIEW_COMMAND=\"/gemini review\"`\n- Default: `/gemini review`\n\n## Output\n\nReport success with the PR URL:\n\n```\nPR created: <PR URL>\nReview requested via: <REVIEW_CMD>\n```\n"
      },
      "plugins": [
        {
          "name": "linear-lifecycle",
          "source": "./plugins/linear-lifecycle",
          "version": "1.0.0",
          "license": "MIT",
          "description": "Manage Linear issues via Linearis CLI with zero-context overhead. Create, update, and track issues without loading large MCPs.",
          "homepage": "https://github.com/mattforni/skillset",
          "repository": "https://github.com/mattforni/skillset",
          "author": {
            "name": "Matthew Fornaciari",
            "url": "https://github.com/mattforni"
          },
          "category": "development",
          "keywords": [
            "linear",
            "issue-tracking",
            "cli",
            "workflow",
            "linearis",
            "project-management"
          ],
          "strict": false,
          "skills": [
            "./skills/linear-lifecycle/SKILL.md"
          ],
          "commands": [
            "./commands/linear-setup.md"
          ],
          "categories": [
            "cli",
            "development",
            "issue-tracking",
            "linear",
            "linearis",
            "project-management",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add mattforni/skillset",
            "/plugin install linear-lifecycle@skillset"
          ]
        },
        {
          "name": "sdlc",
          "source": "./plugins/sdlc",
          "version": "1.0.0",
          "license": "MIT",
          "description": "Software development lifecycle skills for planning, implementing, reviewing, and completing work.",
          "homepage": "https://github.com/mattforni/skillset",
          "repository": "https://github.com/mattforni/skillset",
          "author": {
            "name": "Matthew Fornaciari",
            "url": "https://github.com/mattforni"
          },
          "category": "development",
          "keywords": [
            "sdlc",
            "workflow",
            "git",
            "pr",
            "review",
            "development",
            "lifecycle"
          ],
          "strict": false,
          "skills": [
            "./skills/plan/SKILL.md",
            "./skills/checkpoint/SKILL.md",
            "./skills/review/SKILL.md",
            "./skills/iterate/SKILL.md",
            "./skills/complete/SKILL.md"
          ],
          "categories": [
            "development",
            "git",
            "lifecycle",
            "pr",
            "review",
            "sdlc",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add mattforni/skillset",
            "/plugin install sdlc@skillset"
          ]
        }
      ]
    }
  ]
}