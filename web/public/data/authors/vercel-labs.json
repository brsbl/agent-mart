{
  "author": {
    "id": "vercel-labs",
    "display_name": "Vercel Labs",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/108547162?v=4",
    "url": "https://github.com/vercel-labs",
    "bio": "Develop. Preview. Ship. Creators of Next.js.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 11421,
      "total_forks": 629
    }
  },
  "marketplaces": [
    {
      "name": "agent-browser",
      "version": null,
      "description": "Headless browser automation for AI agents",
      "owner_info": {
        "name": "Vercel",
        "email": "support@vercel.com"
      },
      "keywords": [],
      "repo_full_name": "vercel-labs/agent-browser",
      "repo_url": "https://github.com/vercel-labs/agent-browser",
      "repo_description": "Browser automation CLI for AI agents",
      "homepage": "https://agent-browser.dev",
      "signals": {
        "stars": 11421,
        "forks": 629,
        "pushed_at": "2026-01-29T16:54:36Z",
        "created_at": "2026-01-11T05:38:15Z",
        "license": "Apache-2.0"
      },
      "file_tree": [
        {
          "path": ".changeset",
          "type": "tree",
          "size": null
        },
        {
          "path": ".changeset/README.md",
          "type": "blob",
          "size": 632
        },
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 543
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 23513
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/agent-browser",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/agent-browser/SKILL.md",
          "type": "blob",
          "size": 12895
        },
        {
          "path": "skills/agent-browser/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/agent-browser/references/authentication.md",
          "type": "blob",
          "size": 4443
        },
        {
          "path": "skills/agent-browser/references/proxy-support.md",
          "type": "blob",
          "size": 4265
        },
        {
          "path": "skills/agent-browser/references/session-management.md",
          "type": "blob",
          "size": 3894
        },
        {
          "path": "skills/agent-browser/references/snapshot-refs.md",
          "type": "blob",
          "size": 4108
        },
        {
          "path": "skills/agent-browser/references/video-recording.md",
          "type": "blob",
          "size": 3246
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"agent-browser\",\n  \"description\": \"Headless browser automation for AI agents\",\n  \"owner\": {\n    \"name\": \"Vercel\",\n    \"email\": \"support@vercel.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agent-browser\",\n      \"description\": \"Automates browser interactions for web testing, form filling, screenshots, and data extraction\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./skills/agent-browser\"],\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".changeset/README.md": "# Changesets\n\nThis project uses [Changesets](https://github.com/changesets/changesets) for versioning and changelog generation.\n\n## Adding a changeset\n\nWhen you make a change that should be released, run:\n\n```bash\npnpm changeset\n```\n\nThis will prompt you to:\n1. Select the type of change (patch, minor, major)\n2. Write a summary of your changes\n\nThe changeset file will be committed with your PR.\n\n## Release process\n\nWhen changesets are merged to `main`, the release workflow will:\n1. Create a \"Version Packages\" PR that updates version numbers and changelogs\n2. When that PR is merged, packages are automatically published to npm\n",
        "README.md": "# agent-browser\n\nHeadless browser automation CLI for AI agents. Fast Rust CLI with Node.js fallback.\n\n## Installation\n\n### npm (recommended)\n\n```bash\nnpm install -g agent-browser\nagent-browser install  # Download Chromium\n```\n\n### From Source\n\n```bash\ngit clone https://github.com/vercel-labs/agent-browser\ncd agent-browser\npnpm install\npnpm build\npnpm build:native   # Requires Rust (https://rustup.rs)\npnpm link --global  # Makes agent-browser available globally\nagent-browser install\n```\n\n### Linux Dependencies\n\nOn Linux, install system dependencies:\n\n```bash\nagent-browser install --with-deps\n# or manually: npx playwright install-deps chromium\n```\n\n## Quick Start\n\n```bash\nagent-browser open example.com\nagent-browser snapshot                    # Get accessibility tree with refs\nagent-browser click @e2                   # Click by ref from snapshot\nagent-browser fill @e3 \"test@example.com\" # Fill by ref\nagent-browser get text @e1                # Get text by ref\nagent-browser screenshot page.png\nagent-browser close\n```\n\n### Traditional Selectors (also supported)\n\n```bash\nagent-browser click \"#submit\"\nagent-browser fill \"#email\" \"test@example.com\"\nagent-browser find role button click --name \"Submit\"\n```\n\n## Commands\n\n### Core Commands\n\n```bash\nagent-browser open <url>              # Navigate to URL (aliases: goto, navigate)\nagent-browser click <sel>             # Click element\nagent-browser dblclick <sel>          # Double-click element\nagent-browser focus <sel>             # Focus element\nagent-browser type <sel> <text>       # Type into element\nagent-browser fill <sel> <text>       # Clear and fill\nagent-browser press <key>             # Press key (Enter, Tab, Control+a) (alias: key)\nagent-browser keydown <key>           # Hold key down\nagent-browser keyup <key>             # Release key\nagent-browser hover <sel>             # Hover element\nagent-browser select <sel> <val>      # Select dropdown option\nagent-browser check <sel>             # Check checkbox\nagent-browser uncheck <sel>           # Uncheck checkbox\nagent-browser scroll <dir> [px]       # Scroll (up/down/left/right)\nagent-browser scrollintoview <sel>    # Scroll element into view (alias: scrollinto)\nagent-browser drag <src> <tgt>        # Drag and drop\nagent-browser upload <sel> <files>    # Upload files\nagent-browser screenshot [path]       # Take screenshot (--full for full page, saves to a temporary directory if no path)\nagent-browser pdf <path>              # Save as PDF\nagent-browser snapshot                # Accessibility tree with refs (best for AI)\nagent-browser eval <js>               # Run JavaScript\nagent-browser connect <port>          # Connect to browser via CDP\nagent-browser close                   # Close browser (aliases: quit, exit)\n```\n\n### Get Info\n\n```bash\nagent-browser get text <sel>          # Get text content\nagent-browser get html <sel>          # Get innerHTML\nagent-browser get value <sel>         # Get input value\nagent-browser get attr <sel> <attr>   # Get attribute\nagent-browser get title               # Get page title\nagent-browser get url                 # Get current URL\nagent-browser get count <sel>         # Count matching elements\nagent-browser get box <sel>           # Get bounding box\n```\n\n### Check State\n\n```bash\nagent-browser is visible <sel>        # Check if visible\nagent-browser is enabled <sel>        # Check if enabled\nagent-browser is checked <sel>        # Check if checked\n```\n\n### Find Elements (Semantic Locators)\n\n```bash\nagent-browser find role <role> <action> [value]       # By ARIA role\nagent-browser find text <text> <action>               # By text content\nagent-browser find label <label> <action> [value]     # By label\nagent-browser find placeholder <ph> <action> [value]  # By placeholder\nagent-browser find alt <text> <action>                # By alt text\nagent-browser find title <text> <action>              # By title attr\nagent-browser find testid <id> <action> [value]       # By data-testid\nagent-browser find first <sel> <action> [value]       # First match\nagent-browser find last <sel> <action> [value]        # Last match\nagent-browser find nth <n> <sel> <action> [value]     # Nth match\n```\n\n**Actions:** `click`, `fill`, `check`, `hover`, `text`\n\n**Examples:**\n```bash\nagent-browser find role button click --name \"Submit\"\nagent-browser find text \"Sign In\" click\nagent-browser find label \"Email\" fill \"test@test.com\"\nagent-browser find first \".item\" click\nagent-browser find nth 2 \"a\" text\n```\n\n### Wait\n\n```bash\nagent-browser wait <selector>         # Wait for element to be visible\nagent-browser wait <ms>               # Wait for time (milliseconds)\nagent-browser wait --text \"Welcome\"   # Wait for text to appear\nagent-browser wait --url \"**/dash\"    # Wait for URL pattern\nagent-browser wait --load networkidle # Wait for load state\nagent-browser wait --fn \"window.ready === true\"  # Wait for JS condition\n```\n\n**Load states:** `load`, `domcontentloaded`, `networkidle`\n\n### Mouse Control\n\n```bash\nagent-browser mouse move <x> <y>      # Move mouse\nagent-browser mouse down [button]     # Press button (left/right/middle)\nagent-browser mouse up [button]       # Release button\nagent-browser mouse wheel <dy> [dx]   # Scroll wheel\n```\n\n### Browser Settings\n\n```bash\nagent-browser set viewport <w> <h>    # Set viewport size\nagent-browser set device <name>       # Emulate device (\"iPhone 14\")\nagent-browser set geo <lat> <lng>     # Set geolocation\nagent-browser set offline [on|off]    # Toggle offline mode\nagent-browser set headers <json>      # Extra HTTP headers\nagent-browser set credentials <u> <p> # HTTP basic auth\nagent-browser set media [dark|light]  # Emulate color scheme\n```\n\n### Cookies & Storage\n\n```bash\nagent-browser cookies                 # Get all cookies\nagent-browser cookies set <name> <val> # Set cookie\nagent-browser cookies clear           # Clear cookies\n\nagent-browser storage local           # Get all localStorage\nagent-browser storage local <key>     # Get specific key\nagent-browser storage local set <k> <v>  # Set value\nagent-browser storage local clear     # Clear all\n\nagent-browser storage session         # Same for sessionStorage\n```\n\n### Network\n\n```bash\nagent-browser network route <url>              # Intercept requests\nagent-browser network route <url> --abort      # Block requests\nagent-browser network route <url> --body <json>  # Mock response\nagent-browser network unroute [url]            # Remove routes\nagent-browser network requests                 # View tracked requests\nagent-browser network requests --filter api    # Filter requests\n```\n\n### Tabs & Windows\n\n```bash\nagent-browser tab                     # List tabs\nagent-browser tab new [url]           # New tab (optionally with URL)\nagent-browser tab <n>                 # Switch to tab n\nagent-browser tab close [n]           # Close tab\nagent-browser window new              # New window\n```\n\n### Frames\n\n```bash\nagent-browser frame <sel>             # Switch to iframe\nagent-browser frame main              # Back to main frame\n```\n\n### Dialogs\n\n```bash\nagent-browser dialog accept [text]    # Accept (with optional prompt text)\nagent-browser dialog dismiss          # Dismiss\n```\n\n### Debug\n\n```bash\nagent-browser trace start [path]      # Start recording trace\nagent-browser trace stop [path]       # Stop and save trace\nagent-browser console                 # View console messages (log, error, warn, info)\nagent-browser console --clear         # Clear console\nagent-browser errors                  # View page errors (uncaught JavaScript exceptions)\nagent-browser errors --clear          # Clear errors\nagent-browser highlight <sel>         # Highlight element\nagent-browser state save <path>       # Save auth state\nagent-browser state load <path>       # Load auth state\n```\n\n### Navigation\n\n```bash\nagent-browser back                    # Go back\nagent-browser forward                 # Go forward\nagent-browser reload                  # Reload page\n```\n\n### Setup\n\n```bash\nagent-browser install                 # Download Chromium browser\nagent-browser install --with-deps     # Also install system deps (Linux)\n```\n\n## Sessions\n\nRun multiple isolated browser instances:\n\n```bash\n# Different sessions\nagent-browser --session agent1 open site-a.com\nagent-browser --session agent2 open site-b.com\n\n# Or via environment variable\nAGENT_BROWSER_SESSION=agent1 agent-browser click \"#btn\"\n\n# List active sessions\nagent-browser session list\n# Output:\n# Active sessions:\n# -> default\n#    agent1\n\n# Show current session\nagent-browser session\n```\n\nEach session has its own:\n- Browser instance\n- Cookies and storage\n- Navigation history\n- Authentication state\n\n## Persistent Profiles\n\nBy default, browser state (cookies, localStorage, login sessions) is ephemeral and lost when the browser closes. Use `--profile` to persist state across browser restarts:\n\n```bash\n# Use a persistent profile directory\nagent-browser --profile ~/.myapp-profile open myapp.com\n\n# Login once, then reuse the authenticated session\nagent-browser --profile ~/.myapp-profile open myapp.com/dashboard\n\n# Or via environment variable\nAGENT_BROWSER_PROFILE=~/.myapp-profile agent-browser open myapp.com\n```\n\nThe profile directory stores:\n- Cookies and localStorage\n- IndexedDB data\n- Service workers\n- Browser cache\n- Login sessions\n\n**Tip**: Use different profile paths for different projects to keep their browser state isolated.\n\n## Snapshot Options\n\nThe `snapshot` command supports filtering to reduce output size:\n\n```bash\nagent-browser snapshot                    # Full accessibility tree\nagent-browser snapshot -i                 # Interactive elements only (buttons, inputs, links)\nagent-browser snapshot -c                 # Compact (remove empty structural elements)\nagent-browser snapshot -d 3               # Limit depth to 3 levels\nagent-browser snapshot -s \"#main\"         # Scope to CSS selector\nagent-browser snapshot -i -c -d 5         # Combine options\n```\n\n| Option | Description |\n|--------|-------------|\n| `-i, --interactive` | Only show interactive elements (buttons, links, inputs) |\n| `-c, --compact` | Remove empty structural elements |\n| `-d, --depth <n>` | Limit tree depth |\n| `-s, --selector <sel>` | Scope to CSS selector |\n\n## Options\n\n| Option | Description |\n|--------|-------------|\n| `--session <name>` | Use isolated session (or `AGENT_BROWSER_SESSION` env) |\n| `--profile <path>` | Persistent browser profile directory (or `AGENT_BROWSER_PROFILE` env) |\n| `--headers <json>` | Set HTTP headers scoped to the URL's origin |\n| `--executable-path <path>` | Custom browser executable (or `AGENT_BROWSER_EXECUTABLE_PATH` env) |\n| `--args <args>` | Browser launch args, comma or newline separated (or `AGENT_BROWSER_ARGS` env) |\n| `--user-agent <ua>` | Custom User-Agent string (or `AGENT_BROWSER_USER_AGENT` env) |\n| `--proxy <url>` | Proxy server URL with optional auth (or `AGENT_BROWSER_PROXY` env) |\n| `--proxy-bypass <hosts>` | Hosts to bypass proxy (or `AGENT_BROWSER_PROXY_BYPASS` env) |\n| `-p, --provider <name>` | Cloud browser provider (or `AGENT_BROWSER_PROVIDER` env) |\n| `--json` | JSON output (for agents) |\n| `--full, -f` | Full page screenshot |\n| `--name, -n` | Locator name filter |\n| `--exact` | Exact text match |\n| `--headed` | Show browser window (not headless) |\n| `--cdp <port>` | Connect via Chrome DevTools Protocol |\n| `--ignore-https-errors` | Ignore HTTPS certificate errors (useful for self-signed certs) |\n| `--debug` | Debug output |\n\n## Selectors\n\n### Refs (Recommended for AI)\n\nRefs provide deterministic element selection from snapshots:\n\n```bash\n# 1. Get snapshot with refs\nagent-browser snapshot\n# Output:\n# - heading \"Example Domain\" [ref=e1] [level=1]\n# - button \"Submit\" [ref=e2]\n# - textbox \"Email\" [ref=e3]\n# - link \"Learn more\" [ref=e4]\n\n# 2. Use refs to interact\nagent-browser click @e2                   # Click the button\nagent-browser fill @e3 \"test@example.com\" # Fill the textbox\nagent-browser get text @e1                # Get heading text\nagent-browser hover @e4                   # Hover the link\n```\n\n**Why use refs?**\n- **Deterministic**: Ref points to exact element from snapshot\n- **Fast**: No DOM re-query needed\n- **AI-friendly**: Snapshot + ref workflow is optimal for LLMs\n\n### CSS Selectors\n\n```bash\nagent-browser click \"#id\"\nagent-browser click \".class\"\nagent-browser click \"div > button\"\n```\n\n### Text & XPath\n\n```bash\nagent-browser click \"text=Submit\"\nagent-browser click \"xpath=//button\"\n```\n\n### Semantic Locators\n\n```bash\nagent-browser find role button click --name \"Submit\"\nagent-browser find label \"Email\" fill \"test@test.com\"\n```\n\n## Agent Mode\n\nUse `--json` for machine-readable output:\n\n```bash\nagent-browser snapshot --json\n# Returns: {\"success\":true,\"data\":{\"snapshot\":\"...\",\"refs\":{\"e1\":{\"role\":\"heading\",\"name\":\"Title\"},...}}}\n\nagent-browser get text @e1 --json\nagent-browser is visible @e2 --json\n```\n\n### Optimal AI Workflow\n\n```bash\n# 1. Navigate and get snapshot\nagent-browser open example.com\nagent-browser snapshot -i --json   # AI parses tree and refs\n\n# 2. AI identifies target refs from snapshot\n# 3. Execute actions using refs\nagent-browser click @e2\nagent-browser fill @e3 \"input text\"\n\n# 4. Get new snapshot if page changed\nagent-browser snapshot -i --json\n```\n\n## Headed Mode\n\nShow the browser window for debugging:\n\n```bash\nagent-browser open example.com --headed\n```\n\nThis opens a visible browser window instead of running headless.\n\n## Authenticated Sessions\n\nUse `--headers` to set HTTP headers for a specific origin, enabling authentication without login flows:\n\n```bash\n# Headers are scoped to api.example.com only\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer <token>\"}'\n\n# Requests to api.example.com include the auth header\nagent-browser snapshot -i --json\nagent-browser click @e2\n\n# Navigate to another domain - headers are NOT sent (safe!)\nagent-browser open other-site.com\n```\n\nThis is useful for:\n- **Skipping login flows** - Authenticate via headers instead of UI\n- **Switching users** - Start new sessions with different auth tokens\n- **API testing** - Access protected endpoints directly\n- **Security** - Headers are scoped to the origin, not leaked to other domains\n\nTo set headers for multiple origins, use `--headers` with each `open` command:\n\n```bash\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer token1\"}'\nagent-browser open api.acme.com --headers '{\"Authorization\": \"Bearer token2\"}'\n```\n\nFor global headers (all domains), use `set headers`:\n\n```bash\nagent-browser set headers '{\"X-Custom-Header\": \"value\"}'\n```\n\n## Custom Browser Executable\n\nUse a custom browser executable instead of the bundled Chromium. This is useful for:\n- **Serverless deployment**: Use lightweight Chromium builds like `@sparticuz/chromium` (~50MB vs ~684MB)\n- **System browsers**: Use an existing Chrome/Chromium installation\n- **Custom builds**: Use modified browser builds\n\n### CLI Usage\n\n```bash\n# Via flag\nagent-browser --executable-path /path/to/chromium open example.com\n\n# Via environment variable\nAGENT_BROWSER_EXECUTABLE_PATH=/path/to/chromium agent-browser open example.com\n```\n\n### Serverless Example (Vercel/AWS Lambda)\n\n```typescript\nimport chromium from '@sparticuz/chromium';\nimport { BrowserManager } from 'agent-browser';\n\nexport async function handler() {\n  const browser = new BrowserManager();\n  await browser.launch({\n    executablePath: await chromium.executablePath(),\n    headless: true,\n  });\n  // ... use browser\n}\n```\n\n## CDP Mode\n\nConnect to an existing browser via Chrome DevTools Protocol:\n\n```bash\n# Start Chrome with: google-chrome --remote-debugging-port=9222\n\n# Connect once, then run commands without --cdp\nagent-browser connect 9222\nagent-browser snapshot\nagent-browser tab\nagent-browser close\n\n# Or pass --cdp on each command\nagent-browser --cdp 9222 snapshot\n\n# Connect to remote browser via WebSocket URL\nagent-browser --cdp \"wss://your-browser-service.com/cdp?token=...\" snapshot\n```\n\nThe `--cdp` flag accepts either:\n- A port number (e.g., `9222`) for local connections via `http://localhost:{port}`\n- A full WebSocket URL (e.g., `wss://...` or `ws://...`) for remote browser services\n\nThis enables control of:\n- Electron apps\n- Chrome/Chromium instances with remote debugging\n- WebView2 applications\n- Any browser exposing a CDP endpoint\n\n## Streaming (Browser Preview)\n\nStream the browser viewport via WebSocket for live preview or \"pair browsing\" where a human can watch and interact alongside an AI agent.\n\n### Enable Streaming\n\nSet the `AGENT_BROWSER_STREAM_PORT` environment variable:\n\n```bash\nAGENT_BROWSER_STREAM_PORT=9223 agent-browser open example.com\n```\n\nThis starts a WebSocket server on the specified port that streams the browser viewport and accepts input events.\n\n### WebSocket Protocol\n\nConnect to `ws://localhost:9223` to receive frames and send input:\n\n**Receive frames:**\n```json\n{\n  \"type\": \"frame\",\n  \"data\": \"<base64-encoded-jpeg>\",\n  \"metadata\": {\n    \"deviceWidth\": 1280,\n    \"deviceHeight\": 720,\n    \"pageScaleFactor\": 1,\n    \"offsetTop\": 0,\n    \"scrollOffsetX\": 0,\n    \"scrollOffsetY\": 0\n  }\n}\n```\n\n**Send mouse events:**\n```json\n{\n  \"type\": \"input_mouse\",\n  \"eventType\": \"mousePressed\",\n  \"x\": 100,\n  \"y\": 200,\n  \"button\": \"left\",\n  \"clickCount\": 1\n}\n```\n\n**Send keyboard events:**\n```json\n{\n  \"type\": \"input_keyboard\",\n  \"eventType\": \"keyDown\",\n  \"key\": \"Enter\",\n  \"code\": \"Enter\"\n}\n```\n\n**Send touch events:**\n```json\n{\n  \"type\": \"input_touch\",\n  \"eventType\": \"touchStart\",\n  \"touchPoints\": [{ \"x\": 100, \"y\": 200 }]\n}\n```\n\n### Programmatic API\n\nFor advanced use, control streaming directly via the protocol:\n\n```typescript\nimport { BrowserManager } from 'agent-browser';\n\nconst browser = new BrowserManager();\nawait browser.launch({ headless: true });\nawait browser.navigate('https://example.com');\n\n// Start screencast\nawait browser.startScreencast((frame) => {\n  // frame.data is base64-encoded image\n  // frame.metadata contains viewport info\n  console.log('Frame received:', frame.metadata.deviceWidth, 'x', frame.metadata.deviceHeight);\n}, {\n  format: 'jpeg',\n  quality: 80,\n  maxWidth: 1280,\n  maxHeight: 720,\n});\n\n// Inject mouse events\nawait browser.injectMouseEvent({\n  type: 'mousePressed',\n  x: 100,\n  y: 200,\n  button: 'left',\n});\n\n// Inject keyboard events\nawait browser.injectKeyboardEvent({\n  type: 'keyDown',\n  key: 'Enter',\n  code: 'Enter',\n});\n\n// Stop when done\nawait browser.stopScreencast();\n```\n\n## Architecture\n\nagent-browser uses a client-daemon architecture:\n\n1. **Rust CLI** (fast native binary) - Parses commands, communicates with daemon\n2. **Node.js Daemon** - Manages Playwright browser instance\n3. **Fallback** - If native binary unavailable, uses Node.js directly\n\nThe daemon starts automatically on first command and persists between commands for fast subsequent operations.\n\n**Browser Engine:** Uses Chromium by default. The daemon also supports Firefox and WebKit via the Playwright protocol.\n\n## Platforms\n\n| Platform | Binary | Fallback |\n|----------|--------|----------|\n| macOS ARM64 | Native Rust | Node.js |\n| macOS x64 | Native Rust | Node.js |\n| Linux ARM64 | Native Rust | Node.js |\n| Linux x64 | Native Rust | Node.js |\n| Windows x64 | Native Rust | Node.js |\n\n## Usage with AI Agents\n\n### Just ask the agent\n\nThe simplest approach - just tell your agent to use it:\n\n```\nUse agent-browser to test the login flow. Run agent-browser --help to see available commands.\n```\n\nThe `--help` output is comprehensive and most agents can figure it out from there.\n\n### AI Coding Assistants\n\nAdd the skill to your AI coding assistant for richer context:\n\n```bash\nnpx skills add vercel-labs/agent-browser\n```\n\nThis works with Claude Code, Codex, Cursor, Gemini CLI, GitHub Copilot, Goose, OpenCode, and Windsurf.\n\n### AGENTS.md / CLAUDE.md\n\nFor more consistent results, add to your project or global instructions file:\n\n```markdown\n## Browser Automation\n\nUse `agent-browser` for web automation. Run `agent-browser --help` for all commands.\n\nCore workflow:\n1. `agent-browser open <url>` - Navigate to page\n2. `agent-browser snapshot -i` - Get interactive elements with refs (@e1, @e2)\n3. `agent-browser click @e1` / `fill @e2 \"text\"` - Interact using refs\n4. Re-snapshot after page changes\n```\n\n## Integrations\n\n### Browserbase\n\n[Browserbase](https://browserbase.com) provides remote browser infrastructure to make deployment of agentic browsing agents easy. Use it when running the agent-browser CLI in an environment where a local browser isn't feasible.\n\nTo enable Browserbase, use the `-p` flag:\n\n```bash\nexport BROWSERBASE_API_KEY=\"your-api-key\"\nexport BROWSERBASE_PROJECT_ID=\"your-project-id\"\nagent-browser -p browserbase open https://example.com\n```\n\nOr use environment variables for CI/scripts:\n\n```bash\nexport AGENT_BROWSER_PROVIDER=browserbase\nexport BROWSERBASE_API_KEY=\"your-api-key\"\nexport BROWSERBASE_PROJECT_ID=\"your-project-id\"\nagent-browser open https://example.com\n```\n\nWhen enabled, agent-browser connects to a Browserbase session instead of launching a local browser. All commands work identically.\n\nGet your API key and project ID from the [Browserbase Dashboard](https://browserbase.com/overview).\n\n### Browser Use\n\n[Browser Use](https://browser-use.com) provides cloud browser infrastructure for AI agents. Use it when running agent-browser in environments where a local browser isn't available (serverless, CI/CD, etc.).\n\nTo enable Browser Use, use the `-p` flag:\n\n```bash\nexport BROWSER_USE_API_KEY=\"your-api-key\"\nagent-browser -p browseruse open https://example.com\n```\n\nOr use environment variables for CI/scripts:\n\n```bash\nexport AGENT_BROWSER_PROVIDER=browseruse\nexport BROWSER_USE_API_KEY=\"your-api-key\"\nagent-browser open https://example.com\n```\n\nWhen enabled, agent-browser connects to a Browser Use cloud session instead of launching a local browser. All commands work identically.\n\nGet your API key from the [Browser Use Cloud Dashboard](https://cloud.browser-use.com/settings?tab=api-keys). Free credits are available to get started, with pay-as-you-go pricing after.\n\n### Kernel\n\n[Kernel](https://www.kernel.sh) provides cloud browser infrastructure for AI agents with features like stealth mode and persistent profiles.\n\nTo enable Kernel, use the `-p` flag:\n\n```bash\nexport KERNEL_API_KEY=\"your-api-key\"\nagent-browser -p kernel open https://example.com\n```\n\nOr use environment variables for CI/scripts:\n\n```bash\nexport AGENT_BROWSER_PROVIDER=kernel\nexport KERNEL_API_KEY=\"your-api-key\"\nagent-browser open https://example.com\n```\n\nOptional configuration via environment variables:\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `KERNEL_HEADLESS` | Run browser in headless mode (`true`/`false`) | `false` |\n| `KERNEL_STEALTH` | Enable stealth mode to avoid bot detection (`true`/`false`) | `true` |\n| `KERNEL_TIMEOUT_SECONDS` | Session timeout in seconds | `300` |\n| `KERNEL_PROFILE_NAME` | Browser profile name for persistent cookies/logins (created if it doesn't exist) | (none) |\n\nWhen enabled, agent-browser connects to a Kernel cloud session instead of launching a local browser. All commands work identically.\n\n**Profile Persistence:** When `KERNEL_PROFILE_NAME` is set, the profile will be created if it doesn't already exist. Cookies, logins, and session data are automatically saved back to the profile when the browser session ends, making them available for future sessions.\n\nGet your API key from the [Kernel Dashboard](https://dashboard.onkernel.com).\n\n## License\n\nApache-2.0\n",
        "skills/agent-browser/SKILL.md": "---\nname: agent-browser\ndescription: Automates browser interactions for web testing, form filling, screenshots, and data extraction. Use when the user needs to navigate websites, interact with web pages, fill forms, take screenshots, test web applications, or extract information from web pages.\nallowed-tools: Bash(agent-browser:*)\n---\n\n# Browser Automation with agent-browser\n\n## Quick start\n\n```bash\nagent-browser open <url>        # Navigate to page\nagent-browser snapshot -i       # Get interactive elements with refs\nagent-browser click @e1         # Click element by ref\nagent-browser fill @e2 \"text\"   # Fill input by ref\nagent-browser close             # Close browser\n```\n\n## Core workflow\n\n1. Navigate: `agent-browser open <url>`\n2. Snapshot: `agent-browser snapshot -i` (returns elements with refs like `@e1`, `@e2`)\n3. Interact using refs from the snapshot\n4. Re-snapshot after navigation or significant DOM changes\n\n## Commands\n\n### Navigation\n\n```bash\nagent-browser open <url>      # Navigate to URL (aliases: goto, navigate)\n                              # Supports: https://, http://, file://, about:, data://\n                              # Auto-prepends https:// if no protocol given\nagent-browser back            # Go back\nagent-browser forward         # Go forward\nagent-browser reload          # Reload page\nagent-browser close           # Close browser (aliases: quit, exit)\nagent-browser connect 9222    # Connect to browser via CDP port\n```\n\n### Snapshot (page analysis)\n\n```bash\nagent-browser snapshot            # Full accessibility tree\nagent-browser snapshot -i         # Interactive elements only (recommended)\nagent-browser snapshot -c         # Compact output\nagent-browser snapshot -d 3       # Limit depth to 3\nagent-browser snapshot -s \"#main\" # Scope to CSS selector\n```\n\n### Interactions (use @refs from snapshot)\n\n```bash\nagent-browser click @e1           # Click\nagent-browser dblclick @e1        # Double-click\nagent-browser focus @e1           # Focus element\nagent-browser fill @e2 \"text\"     # Clear and type\nagent-browser type @e2 \"text\"     # Type without clearing\nagent-browser press Enter         # Press key (alias: key)\nagent-browser press Control+a     # Key combination\nagent-browser keydown Shift       # Hold key down\nagent-browser keyup Shift         # Release key\nagent-browser hover @e1           # Hover\nagent-browser check @e1           # Check checkbox\nagent-browser uncheck @e1         # Uncheck checkbox\nagent-browser select @e1 \"value\"  # Select dropdown option\nagent-browser select @e1 \"a\" \"b\"  # Select multiple options\nagent-browser scroll down 500     # Scroll page (default: down 300px)\nagent-browser scrollintoview @e1  # Scroll element into view (alias: scrollinto)\nagent-browser drag @e1 @e2        # Drag and drop\nagent-browser upload @e1 file.pdf # Upload files\n```\n\n### Get information\n\n```bash\nagent-browser get text @e1        # Get element text\nagent-browser get html @e1        # Get innerHTML\nagent-browser get value @e1       # Get input value\nagent-browser get attr @e1 href   # Get attribute\nagent-browser get title           # Get page title\nagent-browser get url             # Get current URL\nagent-browser get count \".item\"   # Count matching elements\nagent-browser get box @e1         # Get bounding box\nagent-browser get styles @e1      # Get computed styles (font, color, bg, etc.)\n```\n\n### Check state\n\n```bash\nagent-browser is visible @e1      # Check if visible\nagent-browser is enabled @e1      # Check if enabled\nagent-browser is checked @e1      # Check if checked\n```\n\n### Screenshots & PDF\n\n```bash\nagent-browser screenshot          # Save to a temporary directory\nagent-browser screenshot path.png # Save to a specific path\nagent-browser screenshot --full   # Full page\nagent-browser pdf output.pdf      # Save as PDF\n```\n\n### Video recording\n\n```bash\nagent-browser record start ./demo.webm    # Start recording (uses current URL + state)\nagent-browser click @e1                   # Perform actions\nagent-browser record stop                 # Stop and save video\nagent-browser record restart ./take2.webm # Stop current + start new recording\n```\n\nRecording creates a fresh context but preserves cookies/storage from your session. If no URL is provided, it\nautomatically returns to your current page. For smooth demos, explore first, then start recording.\n\n### Wait\n\n```bash\nagent-browser wait @e1                     # Wait for element\nagent-browser wait 2000                    # Wait milliseconds\nagent-browser wait --text \"Success\"        # Wait for text (or -t)\nagent-browser wait --url \"**/dashboard\"    # Wait for URL pattern (or -u)\nagent-browser wait --load networkidle      # Wait for network idle (or -l)\nagent-browser wait --fn \"window.ready\"     # Wait for JS condition (or -f)\n```\n\n### Mouse control\n\n```bash\nagent-browser mouse move 100 200      # Move mouse\nagent-browser mouse down left         # Press button\nagent-browser mouse up left           # Release button\nagent-browser mouse wheel 100         # Scroll wheel\n```\n\n### Semantic locators (alternative to refs)\n\n```bash\nagent-browser find role button click --name \"Submit\"\nagent-browser find text \"Sign In\" click\nagent-browser find text \"Sign In\" click --exact      # Exact match only\nagent-browser find label \"Email\" fill \"user@test.com\"\nagent-browser find placeholder \"Search\" type \"query\"\nagent-browser find alt \"Logo\" click\nagent-browser find title \"Close\" click\nagent-browser find testid \"submit-btn\" click\nagent-browser find first \".item\" click\nagent-browser find last \".item\" click\nagent-browser find nth 2 \"a\" hover\n```\n\n### Browser settings\n\n```bash\nagent-browser set viewport 1920 1080          # Set viewport size\nagent-browser set device \"iPhone 14\"          # Emulate device\nagent-browser set geo 37.7749 -122.4194       # Set geolocation (alias: geolocation)\nagent-browser set offline on                  # Toggle offline mode\nagent-browser set headers '{\"X-Key\":\"v\"}'     # Extra HTTP headers\nagent-browser set credentials user pass       # HTTP basic auth (alias: auth)\nagent-browser set media dark                  # Emulate color scheme\nagent-browser set media light reduced-motion  # Light mode + reduced motion\n```\n\n### Cookies & Storage\n\n```bash\nagent-browser cookies                     # Get all cookies\nagent-browser cookies set name value      # Set cookie\nagent-browser cookies clear               # Clear cookies\nagent-browser storage local               # Get all localStorage\nagent-browser storage local key           # Get specific key\nagent-browser storage local set k v       # Set value\nagent-browser storage local clear         # Clear all\n```\n\n### Network\n\n```bash\nagent-browser network route <url>              # Intercept requests\nagent-browser network route <url> --abort      # Block requests\nagent-browser network route <url> --body '{}'  # Mock response\nagent-browser network unroute [url]            # Remove routes\nagent-browser network requests                 # View tracked requests\nagent-browser network requests --filter api    # Filter requests\n```\n\n### Tabs & Windows\n\n```bash\nagent-browser tab                 # List tabs\nagent-browser tab new [url]       # New tab\nagent-browser tab 2               # Switch to tab by index\nagent-browser tab close           # Close current tab\nagent-browser tab close 2         # Close tab by index\nagent-browser window new          # New window\n```\n\n### Frames\n\n```bash\nagent-browser frame \"#iframe\"     # Switch to iframe\nagent-browser frame main          # Back to main frame\n```\n\n### Dialogs\n\n```bash\nagent-browser dialog accept [text]  # Accept dialog\nagent-browser dialog dismiss        # Dismiss dialog\n```\n\n### JavaScript\n\n```bash\nagent-browser eval \"document.title\"   # Run JavaScript\n```\n\n## Global options\n\n```bash\nagent-browser --session <name> ...    # Isolated browser session\nagent-browser --json ...              # JSON output for parsing\nagent-browser --headed ...            # Show browser window (not headless)\nagent-browser --full ...              # Full page screenshot (-f)\nagent-browser --cdp <port> ...        # Connect via Chrome DevTools Protocol\nagent-browser -p <provider> ...       # Cloud browser provider (--provider)\nagent-browser --proxy <url> ...       # Use proxy server\nagent-browser --headers <json> ...    # HTTP headers scoped to URL's origin\nagent-browser --executable-path <p>   # Custom browser executable\nagent-browser --extension <path> ...  # Load browser extension (repeatable)\nagent-browser --help                  # Show help (-h)\nagent-browser --version               # Show version (-V)\nagent-browser <command> --help        # Show detailed help for a command\n```\n\n### Proxy support\n\n```bash\nagent-browser --proxy http://proxy.com:8080 open example.com\nagent-browser --proxy http://user:pass@proxy.com:8080 open example.com\nagent-browser --proxy socks5://proxy.com:1080 open example.com\n```\n\n## Environment variables\n\n```bash\nAGENT_BROWSER_SESSION=\"mysession\"            # Default session name\nAGENT_BROWSER_EXECUTABLE_PATH=\"/path/chrome\" # Custom browser path\nAGENT_BROWSER_EXTENSIONS=\"/ext1,/ext2\"       # Comma-separated extension paths\nAGENT_BROWSER_PROVIDER=\"your-cloud-browser-provider\"  # Cloud browser provider (select browseruse or browserbase)\nAGENT_BROWSER_STREAM_PORT=\"9223\"             # WebSocket streaming port\nAGENT_BROWSER_HOME=\"/path/to/agent-browser\"  # Custom install location (for daemon.js)\n```\n\n## Example: Form submission\n\n```bash\nagent-browser open https://example.com/form\nagent-browser snapshot -i\n# Output shows: textbox \"Email\" [ref=e1], textbox \"Password\" [ref=e2], button \"Submit\" [ref=e3]\n\nagent-browser fill @e1 \"user@example.com\"\nagent-browser fill @e2 \"password123\"\nagent-browser click @e3\nagent-browser wait --load networkidle\nagent-browser snapshot -i  # Check result\n```\n\n## Example: Authentication with saved state\n\n```bash\n# Login once\nagent-browser open https://app.example.com/login\nagent-browser snapshot -i\nagent-browser fill @e1 \"username\"\nagent-browser fill @e2 \"password\"\nagent-browser click @e3\nagent-browser wait --url \"**/dashboard\"\nagent-browser state save auth.json\n\n# Later sessions: load saved state\nagent-browser state load auth.json\nagent-browser open https://app.example.com/dashboard\n```\n\n## Sessions (parallel browsers)\n\n```bash\nagent-browser --session test1 open site-a.com\nagent-browser --session test2 open site-b.com\nagent-browser session list\n```\n\n## JSON output (for parsing)\n\nAdd `--json` for machine-readable output:\n\n```bash\nagent-browser snapshot -i --json\nagent-browser get text @e1 --json\n```\n\n## Debugging\n\n```bash\nagent-browser --headed open example.com   # Show browser window\nagent-browser --cdp 9222 snapshot         # Connect via CDP port\nagent-browser connect 9222                # Alternative: connect command\nagent-browser console                     # View console messages\nagent-browser console --clear             # Clear console\nagent-browser errors                      # View page errors\nagent-browser errors --clear              # Clear errors\nagent-browser highlight @e1               # Highlight element\nagent-browser trace start                 # Start recording trace\nagent-browser trace stop trace.zip        # Stop and save trace\nagent-browser record start ./debug.webm   # Record video from current page\nagent-browser record stop                 # Save recording\n```\n\n## Deep-dive documentation\n\nFor detailed patterns and best practices, see:\n\n| Reference | Description |\n|-----------|-------------|\n| [references/snapshot-refs.md](references/snapshot-refs.md) | Ref lifecycle, invalidation rules, troubleshooting |\n| [references/session-management.md](references/session-management.md) | Parallel sessions, state persistence, concurrent scraping |\n| [references/authentication.md](references/authentication.md) | Login flows, OAuth, 2FA handling, state reuse |\n| [references/video-recording.md](references/video-recording.md) | Recording workflows for debugging and documentation |\n| [references/proxy-support.md](references/proxy-support.md) | Proxy configuration, geo-testing, rotating proxies |\n\n## Ready-to-use templates\n\nExecutable workflow scripts for common patterns:\n\n| Template | Description |\n|----------|-------------|\n| [templates/form-automation.sh](templates/form-automation.sh) | Form filling with validation |\n| [templates/authenticated-session.sh](templates/authenticated-session.sh) | Login once, reuse state |\n| [templates/capture-workflow.sh](templates/capture-workflow.sh) | Content extraction with screenshots |\n\nUsage:\n```bash\n./templates/form-automation.sh https://example.com/form\n./templates/authenticated-session.sh https://app.example.com/login\n./templates/capture-workflow.sh https://example.com ./output\n```\n\n## HTTPS Certificate Errors\n\nFor sites with self-signed or invalid certificates:\n```bash\nagent-browser open https://localhost:8443 --ignore-https-errors\n```\n",
        "skills/agent-browser/references/authentication.md": "# Authentication Patterns\n\nPatterns for handling login flows, session persistence, and authenticated browsing.\n\n## Basic Login Flow\n\n```bash\n# Navigate to login page\nagent-browser open https://app.example.com/login\nagent-browser wait --load networkidle\n\n# Get form elements\nagent-browser snapshot -i\n# Output: @e1 [input type=\"email\"], @e2 [input type=\"password\"], @e3 [button] \"Sign In\"\n\n# Fill credentials\nagent-browser fill @e1 \"user@example.com\"\nagent-browser fill @e2 \"password123\"\n\n# Submit\nagent-browser click @e3\nagent-browser wait --load networkidle\n\n# Verify login succeeded\nagent-browser get url  # Should be dashboard, not login\n```\n\n## Saving Authentication State\n\nAfter logging in, save state for reuse:\n\n```bash\n# Login first (see above)\nagent-browser open https://app.example.com/login\nagent-browser snapshot -i\nagent-browser fill @e1 \"user@example.com\"\nagent-browser fill @e2 \"password123\"\nagent-browser click @e3\nagent-browser wait --url \"**/dashboard\"\n\n# Save authenticated state\nagent-browser state save ./auth-state.json\n```\n\n## Restoring Authentication\n\nSkip login by loading saved state:\n\n```bash\n# Load saved auth state\nagent-browser state load ./auth-state.json\n\n# Navigate directly to protected page\nagent-browser open https://app.example.com/dashboard\n\n# Verify authenticated\nagent-browser snapshot -i\n```\n\n## OAuth / SSO Flows\n\nFor OAuth redirects:\n\n```bash\n# Start OAuth flow\nagent-browser open https://app.example.com/auth/google\n\n# Handle redirects automatically\nagent-browser wait --url \"**/accounts.google.com**\"\nagent-browser snapshot -i\n\n# Fill Google credentials\nagent-browser fill @e1 \"user@gmail.com\"\nagent-browser click @e2  # Next button\nagent-browser wait 2000\nagent-browser snapshot -i\nagent-browser fill @e3 \"password\"\nagent-browser click @e4  # Sign in\n\n# Wait for redirect back\nagent-browser wait --url \"**/app.example.com**\"\nagent-browser state save ./oauth-state.json\n```\n\n## Two-Factor Authentication\n\nHandle 2FA with manual intervention:\n\n```bash\n# Login with credentials\nagent-browser open https://app.example.com/login --headed  # Show browser\nagent-browser snapshot -i\nagent-browser fill @e1 \"user@example.com\"\nagent-browser fill @e2 \"password123\"\nagent-browser click @e3\n\n# Wait for user to complete 2FA manually\necho \"Complete 2FA in the browser window...\"\nagent-browser wait --url \"**/dashboard\" --timeout 120000\n\n# Save state after 2FA\nagent-browser state save ./2fa-state.json\n```\n\n## HTTP Basic Auth\n\nFor sites using HTTP Basic Authentication:\n\n```bash\n# Set credentials before navigation\nagent-browser set credentials username password\n\n# Navigate to protected resource\nagent-browser open https://protected.example.com/api\n```\n\n## Cookie-Based Auth\n\nManually set authentication cookies:\n\n```bash\n# Set auth cookie\nagent-browser cookies set session_token \"abc123xyz\"\n\n# Navigate to protected page\nagent-browser open https://app.example.com/dashboard\n```\n\n## Token Refresh Handling\n\nFor sessions with expiring tokens:\n\n```bash\n#!/bin/bash\n# Wrapper that handles token refresh\n\nSTATE_FILE=\"./auth-state.json\"\n\n# Try loading existing state\nif [[ -f \"$STATE_FILE\" ]]; then\n    agent-browser state load \"$STATE_FILE\"\n    agent-browser open https://app.example.com/dashboard\n\n    # Check if session is still valid\n    URL=$(agent-browser get url)\n    if [[ \"$URL\" == *\"/login\"* ]]; then\n        echo \"Session expired, re-authenticating...\"\n        # Perform fresh login\n        agent-browser snapshot -i\n        agent-browser fill @e1 \"$USERNAME\"\n        agent-browser fill @e2 \"$PASSWORD\"\n        agent-browser click @e3\n        agent-browser wait --url \"**/dashboard\"\n        agent-browser state save \"$STATE_FILE\"\n    fi\nelse\n    # First-time login\n    agent-browser open https://app.example.com/login\n    # ... login flow ...\nfi\n```\n\n## Security Best Practices\n\n1. **Never commit state files** - They contain session tokens\n   ```bash\n   echo \"*.auth-state.json\" >> .gitignore\n   ```\n\n2. **Use environment variables for credentials**\n   ```bash\n   agent-browser fill @e1 \"$APP_USERNAME\"\n   agent-browser fill @e2 \"$APP_PASSWORD\"\n   ```\n\n3. **Clean up after automation**\n   ```bash\n   agent-browser cookies clear\n   rm -f ./auth-state.json\n   ```\n\n4. **Use short-lived sessions for CI/CD**\n   ```bash\n   # Don't persist state in CI\n   agent-browser open https://app.example.com/login\n   # ... login and perform actions ...\n   agent-browser close  # Session ends, nothing persisted\n   ```\n",
        "skills/agent-browser/references/proxy-support.md": "# Proxy Support\n\nConfigure proxy servers for browser automation, useful for geo-testing, rate limiting avoidance, and corporate environments.\n\n## Basic Proxy Configuration\n\nSet proxy via environment variable before starting:\n\n```bash\n# HTTP proxy\nexport HTTP_PROXY=\"http://proxy.example.com:8080\"\nagent-browser open https://example.com\n\n# HTTPS proxy\nexport HTTPS_PROXY=\"https://proxy.example.com:8080\"\nagent-browser open https://example.com\n\n# Both\nexport HTTP_PROXY=\"http://proxy.example.com:8080\"\nexport HTTPS_PROXY=\"http://proxy.example.com:8080\"\nagent-browser open https://example.com\n```\n\n## Authenticated Proxy\n\nFor proxies requiring authentication:\n\n```bash\n# Include credentials in URL\nexport HTTP_PROXY=\"http://username:password@proxy.example.com:8080\"\nagent-browser open https://example.com\n```\n\n## SOCKS Proxy\n\n```bash\n# SOCKS5 proxy\nexport ALL_PROXY=\"socks5://proxy.example.com:1080\"\nagent-browser open https://example.com\n\n# SOCKS5 with auth\nexport ALL_PROXY=\"socks5://user:pass@proxy.example.com:1080\"\nagent-browser open https://example.com\n```\n\n## Proxy Bypass\n\nSkip proxy for specific domains:\n\n```bash\n# Bypass proxy for local addresses\nexport NO_PROXY=\"localhost,127.0.0.1,.internal.company.com\"\nagent-browser open https://internal.company.com  # Direct connection\nagent-browser open https://external.com          # Via proxy\n```\n\n## Common Use Cases\n\n### Geo-Location Testing\n\n```bash\n#!/bin/bash\n# Test site from different regions using geo-located proxies\n\nPROXIES=(\n    \"http://us-proxy.example.com:8080\"\n    \"http://eu-proxy.example.com:8080\"\n    \"http://asia-proxy.example.com:8080\"\n)\n\nfor proxy in \"${PROXIES[@]}\"; do\n    export HTTP_PROXY=\"$proxy\"\n    export HTTPS_PROXY=\"$proxy\"\n\n    region=$(echo \"$proxy\" | grep -oP '^\\w+-\\w+')\n    echo \"Testing from: $region\"\n\n    agent-browser --session \"$region\" open https://example.com\n    agent-browser --session \"$region\" screenshot \"./screenshots/$region.png\"\n    agent-browser --session \"$region\" close\ndone\n```\n\n### Rotating Proxies for Scraping\n\n```bash\n#!/bin/bash\n# Rotate through proxy list to avoid rate limiting\n\nPROXY_LIST=(\n    \"http://proxy1.example.com:8080\"\n    \"http://proxy2.example.com:8080\"\n    \"http://proxy3.example.com:8080\"\n)\n\nURLS=(\n    \"https://site.com/page1\"\n    \"https://site.com/page2\"\n    \"https://site.com/page3\"\n)\n\nfor i in \"${!URLS[@]}\"; do\n    proxy_index=$((i % ${#PROXY_LIST[@]}))\n    export HTTP_PROXY=\"${PROXY_LIST[$proxy_index]}\"\n    export HTTPS_PROXY=\"${PROXY_LIST[$proxy_index]}\"\n\n    agent-browser open \"${URLS[$i]}\"\n    agent-browser get text body > \"output-$i.txt\"\n    agent-browser close\n\n    sleep 1  # Polite delay\ndone\n```\n\n### Corporate Network Access\n\n```bash\n#!/bin/bash\n# Access internal sites via corporate proxy\n\nexport HTTP_PROXY=\"http://corpproxy.company.com:8080\"\nexport HTTPS_PROXY=\"http://corpproxy.company.com:8080\"\nexport NO_PROXY=\"localhost,127.0.0.1,.company.com\"\n\n# External sites go through proxy\nagent-browser open https://external-vendor.com\n\n# Internal sites bypass proxy\nagent-browser open https://intranet.company.com\n```\n\n## Verifying Proxy Connection\n\n```bash\n# Check your apparent IP\nagent-browser open https://httpbin.org/ip\nagent-browser get text body\n# Should show proxy's IP, not your real IP\n```\n\n## Troubleshooting\n\n### Proxy Connection Failed\n\n```bash\n# Test proxy connectivity first\ncurl -x http://proxy.example.com:8080 https://httpbin.org/ip\n\n# Check if proxy requires auth\nexport HTTP_PROXY=\"http://user:pass@proxy.example.com:8080\"\n```\n\n### SSL/TLS Errors Through Proxy\n\nSome proxies perform SSL inspection. If you encounter certificate errors:\n\n```bash\n# For testing only - not recommended for production\nagent-browser open https://example.com --ignore-https-errors\n```\n\n### Slow Performance\n\n```bash\n# Use proxy only when necessary\nexport NO_PROXY=\"*.cdn.com,*.static.com\"  # Direct CDN access\n```\n\n## Best Practices\n\n1. **Use environment variables** - Don't hardcode proxy credentials\n2. **Set NO_PROXY appropriately** - Avoid routing local traffic through proxy\n3. **Test proxy before automation** - Verify connectivity with simple requests\n4. **Handle proxy failures gracefully** - Implement retry logic for unstable proxies\n5. **Rotate proxies for large scraping jobs** - Distribute load and avoid bans\n",
        "skills/agent-browser/references/session-management.md": "# Session Management\n\nRun multiple isolated browser sessions concurrently with state persistence.\n\n## Named Sessions\n\nUse `--session` flag to isolate browser contexts:\n\n```bash\n# Session 1: Authentication flow\nagent-browser --session auth open https://app.example.com/login\n\n# Session 2: Public browsing (separate cookies, storage)\nagent-browser --session public open https://example.com\n\n# Commands are isolated by session\nagent-browser --session auth fill @e1 \"user@example.com\"\nagent-browser --session public get text body\n```\n\n## Session Isolation Properties\n\nEach session has independent:\n- Cookies\n- LocalStorage / SessionStorage\n- IndexedDB\n- Cache\n- Browsing history\n- Open tabs\n\n## Session State Persistence\n\n### Save Session State\n\n```bash\n# Save cookies, storage, and auth state\nagent-browser state save /path/to/auth-state.json\n```\n\n### Load Session State\n\n```bash\n# Restore saved state\nagent-browser state load /path/to/auth-state.json\n\n# Continue with authenticated session\nagent-browser open https://app.example.com/dashboard\n```\n\n### State File Contents\n\n```json\n{\n  \"cookies\": [...],\n  \"localStorage\": {...},\n  \"sessionStorage\": {...},\n  \"origins\": [...]\n}\n```\n\n## Common Patterns\n\n### Authenticated Session Reuse\n\n```bash\n#!/bin/bash\n# Save login state once, reuse many times\n\nSTATE_FILE=\"/tmp/auth-state.json\"\n\n# Check if we have saved state\nif [[ -f \"$STATE_FILE\" ]]; then\n    agent-browser state load \"$STATE_FILE\"\n    agent-browser open https://app.example.com/dashboard\nelse\n    # Perform login\n    agent-browser open https://app.example.com/login\n    agent-browser snapshot -i\n    agent-browser fill @e1 \"$USERNAME\"\n    agent-browser fill @e2 \"$PASSWORD\"\n    agent-browser click @e3\n    agent-browser wait --load networkidle\n\n    # Save for future use\n    agent-browser state save \"$STATE_FILE\"\nfi\n```\n\n### Concurrent Scraping\n\n```bash\n#!/bin/bash\n# Scrape multiple sites concurrently\n\n# Start all sessions\nagent-browser --session site1 open https://site1.com &\nagent-browser --session site2 open https://site2.com &\nagent-browser --session site3 open https://site3.com &\nwait\n\n# Extract from each\nagent-browser --session site1 get text body > site1.txt\nagent-browser --session site2 get text body > site2.txt\nagent-browser --session site3 get text body > site3.txt\n\n# Cleanup\nagent-browser --session site1 close\nagent-browser --session site2 close\nagent-browser --session site3 close\n```\n\n### A/B Testing Sessions\n\n```bash\n# Test different user experiences\nagent-browser --session variant-a open \"https://app.com?variant=a\"\nagent-browser --session variant-b open \"https://app.com?variant=b\"\n\n# Compare\nagent-browser --session variant-a screenshot /tmp/variant-a.png\nagent-browser --session variant-b screenshot /tmp/variant-b.png\n```\n\n## Default Session\n\nWhen `--session` is omitted, commands use the default session:\n\n```bash\n# These use the same default session\nagent-browser open https://example.com\nagent-browser snapshot -i\nagent-browser close  # Closes default session\n```\n\n## Session Cleanup\n\n```bash\n# Close specific session\nagent-browser --session auth close\n\n# List active sessions\nagent-browser session list\n```\n\n## Best Practices\n\n### 1. Name Sessions Semantically\n\n```bash\n# GOOD: Clear purpose\nagent-browser --session github-auth open https://github.com\nagent-browser --session docs-scrape open https://docs.example.com\n\n# AVOID: Generic names\nagent-browser --session s1 open https://github.com\n```\n\n### 2. Always Clean Up\n\n```bash\n# Close sessions when done\nagent-browser --session auth close\nagent-browser --session scrape close\n```\n\n### 3. Handle State Files Securely\n\n```bash\n# Don't commit state files (contain auth tokens!)\necho \"*.auth-state.json\" >> .gitignore\n\n# Delete after use\nrm /tmp/auth-state.json\n```\n\n### 4. Timeout Long Sessions\n\n```bash\n# Set timeout for automated scripts\ntimeout 60 agent-browser --session long-task get text body\n```\n",
        "skills/agent-browser/references/snapshot-refs.md": "# Snapshot + Refs Workflow\n\nThe core innovation of agent-browser: compact element references that reduce context usage dramatically for AI agents.\n\n## How It Works\n\n### The Problem\nTraditional browser automation sends full DOM to AI agents:\n```\nFull DOM/HTML sent  AI parses  Generates CSS selector  Executes action\n~3000-5000 tokens per interaction\n```\n\n### The Solution\nagent-browser uses compact snapshots with refs:\n```\nCompact snapshot  @refs assigned  Direct ref interaction\n~200-400 tokens per interaction\n```\n\n## The Snapshot Command\n\n```bash\n# Basic snapshot (shows page structure)\nagent-browser snapshot\n\n# Interactive snapshot (-i flag) - RECOMMENDED\nagent-browser snapshot -i\n```\n\n### Snapshot Output Format\n\n```\nPage: Example Site - Home\nURL: https://example.com\n\n@e1 [header]\n  @e2 [nav]\n    @e3 [a] \"Home\"\n    @e4 [a] \"Products\"\n    @e5 [a] \"About\"\n  @e6 [button] \"Sign In\"\n\n@e7 [main]\n  @e8 [h1] \"Welcome\"\n  @e9 [form]\n    @e10 [input type=\"email\"] placeholder=\"Email\"\n    @e11 [input type=\"password\"] placeholder=\"Password\"\n    @e12 [button type=\"submit\"] \"Log In\"\n\n@e13 [footer]\n  @e14 [a] \"Privacy Policy\"\n```\n\n## Using Refs\n\nOnce you have refs, interact directly:\n\n```bash\n# Click the \"Sign In\" button\nagent-browser click @e6\n\n# Fill email input\nagent-browser fill @e10 \"user@example.com\"\n\n# Fill password\nagent-browser fill @e11 \"password123\"\n\n# Submit the form\nagent-browser click @e12\n```\n\n## Ref Lifecycle\n\n**IMPORTANT**: Refs are invalidated when the page changes!\n\n```bash\n# Get initial snapshot\nagent-browser snapshot -i\n# @e1 [button] \"Next\"\n\n# Click triggers page change\nagent-browser click @e1\n\n# MUST re-snapshot to get new refs!\nagent-browser snapshot -i\n# @e1 [h1] \"Page 2\"   Different element now!\n```\n\n## Best Practices\n\n### 1. Always Snapshot Before Interacting\n\n```bash\n# CORRECT\nagent-browser open https://example.com\nagent-browser snapshot -i          # Get refs first\nagent-browser click @e1            # Use ref\n\n# WRONG\nagent-browser open https://example.com\nagent-browser click @e1            # Ref doesn't exist yet!\n```\n\n### 2. Re-Snapshot After Navigation\n\n```bash\nagent-browser click @e5            # Navigates to new page\nagent-browser snapshot -i          # Get new refs\nagent-browser click @e1            # Use new refs\n```\n\n### 3. Re-Snapshot After Dynamic Changes\n\n```bash\nagent-browser click @e1            # Opens dropdown\nagent-browser snapshot -i          # See dropdown items\nagent-browser click @e7            # Select item\n```\n\n### 4. Snapshot Specific Regions\n\nFor complex pages, snapshot specific areas:\n\n```bash\n# Snapshot just the form\nagent-browser snapshot @e9\n```\n\n## Ref Notation Details\n\n```\n@e1 [tag type=\"value\"] \"text content\" placeholder=\"hint\"\n                                   \n                                    Additional attributes\n                     Visible text\n        Key attributes shown\n     HTML tag name\n Unique ref ID\n```\n\n### Common Patterns\n\n```\n@e1 [button] \"Submit\"                    # Button with text\n@e2 [input type=\"email\"]                 # Email input\n@e3 [input type=\"password\"]              # Password input\n@e4 [a href=\"/page\"] \"Link Text\"         # Anchor link\n@e5 [select]                             # Dropdown\n@e6 [textarea] placeholder=\"Message\"     # Text area\n@e7 [div class=\"modal\"]                  # Container (when relevant)\n@e8 [img alt=\"Logo\"]                     # Image\n@e9 [checkbox] checked                   # Checked checkbox\n@e10 [radio] selected                    # Selected radio\n```\n\n## Troubleshooting\n\n### \"Ref not found\" Error\n\n```bash\n# Ref may have changed - re-snapshot\nagent-browser snapshot -i\n```\n\n### Element Not Visible in Snapshot\n\n```bash\n# Scroll to reveal element\nagent-browser scroll --bottom\nagent-browser snapshot -i\n\n# Or wait for dynamic content\nagent-browser wait 1000\nagent-browser snapshot -i\n```\n\n### Too Many Elements\n\n```bash\n# Snapshot specific container\nagent-browser snapshot @e5\n\n# Or use get text for content-only extraction\nagent-browser get text @e5\n```\n",
        "skills/agent-browser/references/video-recording.md": "# Video Recording\n\nCapture browser automation sessions as video for debugging, documentation, or verification.\n\n## Basic Recording\n\n```bash\n# Start recording\nagent-browser record start ./demo.webm\n\n# Perform actions\nagent-browser open https://example.com\nagent-browser snapshot -i\nagent-browser click @e1\nagent-browser fill @e2 \"test input\"\n\n# Stop and save\nagent-browser record stop\n```\n\n## Recording Commands\n\n```bash\n# Start recording to file\nagent-browser record start ./output.webm\n\n# Stop current recording\nagent-browser record stop\n\n# Restart with new file (stops current + starts new)\nagent-browser record restart ./take2.webm\n```\n\n## Use Cases\n\n### Debugging Failed Automation\n\n```bash\n#!/bin/bash\n# Record automation for debugging\n\nagent-browser record start ./debug-$(date +%Y%m%d-%H%M%S).webm\n\n# Run your automation\nagent-browser open https://app.example.com\nagent-browser snapshot -i\nagent-browser click @e1 || {\n    echo \"Click failed - check recording\"\n    agent-browser record stop\n    exit 1\n}\n\nagent-browser record stop\n```\n\n### Documentation Generation\n\n```bash\n#!/bin/bash\n# Record workflow for documentation\n\nagent-browser record start ./docs/how-to-login.webm\n\nagent-browser open https://app.example.com/login\nagent-browser wait 1000  # Pause for visibility\n\nagent-browser snapshot -i\nagent-browser fill @e1 \"demo@example.com\"\nagent-browser wait 500\n\nagent-browser fill @e2 \"password\"\nagent-browser wait 500\n\nagent-browser click @e3\nagent-browser wait --load networkidle\nagent-browser wait 1000  # Show result\n\nagent-browser record stop\n```\n\n### CI/CD Test Evidence\n\n```bash\n#!/bin/bash\n# Record E2E test runs for CI artifacts\n\nTEST_NAME=\"${1:-e2e-test}\"\nRECORDING_DIR=\"./test-recordings\"\nmkdir -p \"$RECORDING_DIR\"\n\nagent-browser record start \"$RECORDING_DIR/$TEST_NAME-$(date +%s).webm\"\n\n# Run test\nif run_e2e_test; then\n    echo \"Test passed\"\nelse\n    echo \"Test failed - recording saved\"\nfi\n\nagent-browser record stop\n```\n\n## Best Practices\n\n### 1. Add Pauses for Clarity\n\n```bash\n# Slow down for human viewing\nagent-browser click @e1\nagent-browser wait 500  # Let viewer see result\n```\n\n### 2. Use Descriptive Filenames\n\n```bash\n# Include context in filename\nagent-browser record start ./recordings/login-flow-2024-01-15.webm\nagent-browser record start ./recordings/checkout-test-run-42.webm\n```\n\n### 3. Handle Recording in Error Cases\n\n```bash\n#!/bin/bash\nset -e\n\ncleanup() {\n    agent-browser record stop 2>/dev/null || true\n    agent-browser close 2>/dev/null || true\n}\ntrap cleanup EXIT\n\nagent-browser record start ./automation.webm\n# ... automation steps ...\n```\n\n### 4. Combine with Screenshots\n\n```bash\n# Record video AND capture key frames\nagent-browser record start ./flow.webm\n\nagent-browser open https://example.com\nagent-browser screenshot ./screenshots/step1-homepage.png\n\nagent-browser click @e1\nagent-browser screenshot ./screenshots/step2-after-click.png\n\nagent-browser record stop\n```\n\n## Output Format\n\n- Default format: WebM (VP8/VP9 codec)\n- Compatible with all modern browsers and video players\n- Compressed but high quality\n\n## Limitations\n\n- Recording adds slight overhead to automation\n- Large recordings can consume significant disk space\n- Some headless environments may have codec limitations\n"
      },
      "plugins": [
        {
          "name": "agent-browser",
          "description": "Automates browser interactions for web testing, form filling, screenshots, and data extraction",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/agent-browser"
          ],
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add vercel-labs/agent-browser",
            "/plugin install agent-browser@agent-browser"
          ]
        }
      ]
    }
  ]
}