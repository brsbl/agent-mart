{
  "author": {
    "id": "vercel-labs",
    "display_name": "Vercel Labs",
    "avatar_url": "https://avatars.githubusercontent.com/u/108547162?v=4"
  },
  "marketplaces": [
    {
      "name": "agent-browser",
      "version": null,
      "description": "Headless browser automation for AI agents",
      "repo_full_name": "vercel-labs/agent-browser",
      "repo_url": "https://github.com/vercel-labs/agent-browser",
      "repo_description": "Browser automation CLI for AI agents",
      "signals": {
        "stars": 14568,
        "forks": 858,
        "pushed_at": "2026-02-19T04:43:42Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"agent-browser\",\n  \"description\": \"Headless browser automation for AI agents\",\n  \"owner\": {\n    \"name\": \"Vercel\",\n    \"email\": \"support@vercel.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agent-browser\",\n      \"description\": \"Automates browser interactions for web testing, form filling, screenshots, and data extraction\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\"./skills/agent-browser\"],\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        "README.md": "# agent-browser\n\nHeadless browser automation CLI for AI agents. Fast Rust CLI with Node.js fallback.\n\n## Installation\n\n### Global Installation (recommended)\n\nInstalls the native Rust binary for maximum performance:\n\n```bash\nnpm install -g agent-browser\nagent-browser install  # Download Chromium\n```\n\nThis is the fastest option -- commands run through the native Rust CLI directly with sub-millisecond parsing overhead.\n\n### Quick Start (no install)\n\nRun directly with `npx` if you want to try it without installing globally:\n\n```bash\nnpx agent-browser install   # Download Chromium (first time only)\nnpx agent-browser open example.com\n```\n\n> **Note:** `npx` routes through Node.js before reaching the Rust CLI, so it is noticeably slower than a global install. For regular use, install globally.\n\n### Project Installation (local dependency)\n\nFor projects that want to pin the version in `package.json`:\n\n```bash\nnpm install agent-browser\nnpx agent-browser install\n```\n\nThen use via `npx` or `package.json` scripts:\n\n```bash\nnpx agent-browser open example.com\n```\n\n### Homebrew (macOS)\n\n```bash\nbrew install agent-browser\nagent-browser install  # Download Chromium\n```\n\n### From Source\n\n```bash\ngit clone https://github.com/vercel-labs/agent-browser\ncd agent-browser\npnpm install\npnpm build\npnpm build:native   # Requires Rust (https://rustup.rs)\npnpm link --global  # Makes agent-browser available globally\nagent-browser install\n```\n\n### Linux Dependencies\n\nOn Linux, install system dependencies:\n\n```bash\nagent-browser install --with-deps\n# or manually: npx playwright install-deps chromium\n```\n\n## Quick Start\n\n```bash\nagent-browser open example.com\nagent-browser snapshot                    # Get accessibility tree with refs\nagent-browser click @e2                   # Click by ref from snapshot\nagent-browser fill @e3 \"test@example.com\" # Fill by ref\nagent-browser get text @e1                # Get text by ref\nagent-browser screenshot page.png\nagent-browser close\n```\n\n### Traditional Selectors (also supported)\n\n```bash\nagent-browser click \"#submit\"\nagent-browser fill \"#email\" \"test@example.com\"\nagent-browser find role button click --name \"Submit\"\n```\n\n## Commands\n\n### Core Commands\n\n```bash\nagent-browser open <url>              # Navigate to URL (aliases: goto, navigate)\nagent-browser click <sel>             # Click element (--new-tab to open in new tab)\nagent-browser dblclick <sel>          # Double-click element\nagent-browser focus <sel>             # Focus element\nagent-browser type <sel> <text>       # Type into element\nagent-browser fill <sel> <text>       # Clear and fill\nagent-browser press <key>             # Press key (Enter, Tab, Control+a) (alias: key)\nagent-browser keydown <key>           # Hold key down\nagent-browser keyup <key>             # Release key\nagent-browser hover <sel>             # Hover element\nagent-browser select <sel> <val>      # Select dropdown option\nagent-browser check <sel>             # Check checkbox\nagent-browser uncheck <sel>           # Uncheck checkbox\nagent-browser scroll <dir> [px]       # Scroll (up/down/left/right)\nagent-browser scrollintoview <sel>    # Scroll element into view (alias: scrollinto)\nagent-browser drag <src> <tgt>        # Drag and drop\nagent-browser upload <sel> <files>    # Upload files\nagent-browser screenshot [path]       # Take screenshot (--full for full page, saves to a temporary directory if no path)\nagent-browser screenshot --annotate   # Annotated screenshot with numbered element labels\nagent-browser pdf <path>              # Save as PDF\nagent-browser snapshot                # Accessibility tree with refs (best for AI)\nagent-browser eval <js>               # Run JavaScript (-b for base64, --stdin for piped input)\nagent-browser connect <port>          # Connect to browser via CDP\nagent-browser close                   # Close browser (aliases: quit, exit)\n```\n\n### Get Info\n\n```bash\nagent-browser get text <sel>          # Get text content\nagent-browser get html <sel>          # Get innerHTML\nagent-browser get value <sel>         # Get input value\nagent-browser get attr <sel> <attr>   # Get attribute\nagent-browser get title               # Get page title\nagent-browser get url                 # Get current URL\nagent-browser get count <sel>         # Count matching elements\nagent-browser get box <sel>           # Get bounding box\nagent-browser get styles <sel>        # Get computed styles\n```\n\n### Check State\n\n```bash\nagent-browser is visible <sel>        # Check if visible\nagent-browser is enabled <sel>        # Check if enabled\nagent-browser is checked <sel>        # Check if checked\n```\n\n### Find Elements (Semantic Locators)\n\n```bash\nagent-browser find role <role> <action> [value]       # By ARIA role\nagent-browser find text <text> <action>               # By text content\nagent-browser find label <label> <action> [value]     # By label\nagent-browser find placeholder <ph> <action> [value]  # By placeholder\nagent-browser find alt <text> <action>                # By alt text\nagent-browser find title <text> <action>              # By title attr\nagent-browser find testid <id> <action> [value]       # By data-testid\nagent-browser find first <sel> <action> [value]       # First match\nagent-browser find last <sel> <action> [value]        # Last match\nagent-browser find nth <n> <sel> <action> [value]     # Nth match\n```\n\n**Actions:** `click`, `fill`, `type`, `hover`, `focus`, `check`, `uncheck`, `text`\n\n**Options:** `--name <name>` (filter role by accessible name), `--exact` (require exact text match)\n\n**Examples:**\n```bash\nagent-browser find role button click --name \"Submit\"\nagent-browser find text \"Sign In\" click\nagent-browser find label \"Email\" fill \"test@test.com\"\nagent-browser find first \".item\" click\nagent-browser find nth 2 \"a\" text\n```\n\n### Wait\n\n```bash\nagent-browser wait <selector>         # Wait for element to be visible\nagent-browser wait <ms>               # Wait for time (milliseconds)\nagent-browser wait --text \"Welcome\"   # Wait for text to appear\nagent-browser wait --url \"**/dash\"    # Wait for URL pattern\nagent-browser wait --load networkidle # Wait for load state\nagent-browser wait --fn \"window.ready === true\"  # Wait for JS condition\n```\n\n**Load states:** `load`, `domcontentloaded`, `networkidle`\n\n### Mouse Control\n\n```bash\nagent-browser mouse move <x> <y>      # Move mouse\nagent-browser mouse down [button]     # Press button (left/right/middle)\nagent-browser mouse up [button]       # Release button\nagent-browser mouse wheel <dy> [dx]   # Scroll wheel\n```\n\n### Browser Settings\n\n```bash\nagent-browser set viewport <w> <h>    # Set viewport size\nagent-browser set device <name>       # Emulate device (\"iPhone 14\")\nagent-browser set geo <lat> <lng>     # Set geolocation\nagent-browser set offline [on|off]    # Toggle offline mode\nagent-browser set headers <json>      # Extra HTTP headers\nagent-browser set credentials <u> <p> # HTTP basic auth\nagent-browser set media [dark|light]  # Emulate color scheme\n```\n\n### Cookies & Storage\n\n```bash\nagent-browser cookies                 # Get all cookies\nagent-browser cookies set <name> <val> # Set cookie\nagent-browser cookies clear           # Clear cookies\n\nagent-browser storage local           # Get all localStorage\nagent-browser storage local <key>     # Get specific key\nagent-browser storage local set <k> <v>  # Set value\nagent-browser storage local clear     # Clear all\n\nagent-browser storage session         # Same for sessionStorage\n```\n\n### Network\n\n```bash\nagent-browser network route <url>              # Intercept requests\nagent-browser network route <url> --abort      # Block requests\nagent-browser network route <url> --body <json>  # Mock response\nagent-browser network unroute [url]            # Remove routes\nagent-browser network requests                 # View tracked requests\nagent-browser network requests --filter api    # Filter requests\n```\n\n### Tabs & Windows\n\n```bash\nagent-browser tab                     # List tabs\nagent-browser tab new [url]           # New tab (optionally with URL)\nagent-browser tab <n>                 # Switch to tab n\nagent-browser tab close [n]           # Close tab\nagent-browser window new              # New window\n```\n\n### Frames\n\n```bash\nagent-browser frame <sel>             # Switch to iframe\nagent-browser frame main              # Back to main frame\n```\n\n### Dialogs\n\n```bash\nagent-browser dialog accept [text]    # Accept (with optional prompt text)\nagent-browser dialog dismiss          # Dismiss\n```\n\n### Debug\n\n```bash\nagent-browser trace start [path]      # Start recording trace\nagent-browser trace stop [path]       # Stop and save trace\nagent-browser profiler start          # Start Chrome DevTools profiling\nagent-browser profiler stop [path]    # Stop and save profile (.json)\nagent-browser console                 # View console messages (log, error, warn, info)\nagent-browser console --clear         # Clear console\nagent-browser errors                  # View page errors (uncaught JavaScript exceptions)\nagent-browser errors --clear          # Clear errors\nagent-browser highlight <sel>         # Highlight element\nagent-browser state save <path>       # Save auth state\nagent-browser state load <path>       # Load auth state\nagent-browser state list              # List saved state files\nagent-browser state show <file>       # Show state summary\nagent-browser state rename <old> <new> # Rename state file\nagent-browser state clear [name]      # Clear states for session\nagent-browser state clear --all       # Clear all saved states\nagent-browser state clean --older-than <days>  # Delete old states\n```\n\n### Navigation\n\n```bash\nagent-browser back                    # Go back\nagent-browser forward                 # Go forward\nagent-browser reload                  # Reload page\n```\n\n### Setup\n\n```bash\nagent-browser install                 # Download Chromium browser\nagent-browser install --with-deps     # Also install system deps (Linux)\n```\n\n## Sessions\n\nRun multiple isolated browser instances:\n\n```bash\n# Different sessions\nagent-browser --session agent1 open site-a.com\nagent-browser --session agent2 open site-b.com\n\n# Or via environment variable\nAGENT_BROWSER_SESSION=agent1 agent-browser click \"#btn\"\n\n# List active sessions\nagent-browser session list\n# Output:\n# Active sessions:\n# -> default\n#    agent1\n\n# Show current session\nagent-browser session\n```\n\nEach session has its own:\n- Browser instance\n- Cookies and storage\n- Navigation history\n- Authentication state\n\n## Persistent Profiles\n\nBy default, browser state (cookies, localStorage, login sessions) is ephemeral and lost when the browser closes. Use `--profile` to persist state across browser restarts:\n\n```bash\n# Use a persistent profile directory\nagent-browser --profile ~/.myapp-profile open myapp.com\n\n# Login once, then reuse the authenticated session\nagent-browser --profile ~/.myapp-profile open myapp.com/dashboard\n\n# Or via environment variable\nAGENT_BROWSER_PROFILE=~/.myapp-profile agent-browser open myapp.com\n```\n\nThe profile directory stores:\n- Cookies and localStorage\n- IndexedDB data\n- Service workers\n- Browser cache\n- Login sessions\n\n**Tip**: Use different profile paths for different projects to keep their browser state isolated.\n\n## Session Persistence\n\nAlternatively, use `--session-name` to automatically save and restore cookies and localStorage across browser restarts:\n\n```bash\n# Auto-save/load state for \"twitter\" session\nagent-browser --session-name twitter open twitter.com\n\n# Login once, then state persists automatically\n# State files stored in ~/.agent-browser/sessions/\n\n# Or via environment variable\nexport AGENT_BROWSER_SESSION_NAME=twitter\nagent-browser open twitter.com\n```\n\n### State Encryption\n\nEncrypt saved session data at rest with AES-256-GCM:\n\n```bash\n# Generate key: openssl rand -hex 32\nexport AGENT_BROWSER_ENCRYPTION_KEY=<64-char-hex-key>\n\n# State files are now encrypted automatically\nagent-browser --session-name secure open example.com\n```\n\n| Variable | Description |\n|----------|-------------|\n| `AGENT_BROWSER_SESSION_NAME` | Auto-save/load state persistence name |\n| `AGENT_BROWSER_ENCRYPTION_KEY` | 64-char hex key for AES-256-GCM encryption |\n| `AGENT_BROWSER_STATE_EXPIRE_DAYS` | Auto-delete states older than N days (default: 30) |\n\n## Snapshot Options\n\nThe `snapshot` command supports filtering to reduce output size:\n\n```bash\nagent-browser snapshot                    # Full accessibility tree\nagent-browser snapshot -i                 # Interactive elements only (buttons, inputs, links)\nagent-browser snapshot -i -C              # Include cursor-interactive elements (divs with onclick, etc.)\nagent-browser snapshot -c                 # Compact (remove empty structural elements)\nagent-browser snapshot -d 3               # Limit depth to 3 levels\nagent-browser snapshot -s \"#main\"         # Scope to CSS selector\nagent-browser snapshot -i -c -d 5         # Combine options\n```\n\n| Option | Description |\n|--------|-------------|\n| `-i, --interactive` | Only show interactive elements (buttons, links, inputs) |\n| `-C, --cursor` | Include cursor-interactive elements (cursor:pointer, onclick, tabindex) |\n| `-c, --compact` | Remove empty structural elements |\n| `-d, --depth <n>` | Limit tree depth |\n| `-s, --selector <sel>` | Scope to CSS selector |\n\nThe `-C` flag is useful for modern web apps that use custom clickable elements (divs, spans) instead of standard buttons/links.\n\n## Annotated Screenshots\n\nThe `--annotate` flag overlays numbered labels on interactive elements in the screenshot. Each label `[N]` corresponds to ref `@eN`, so the same refs work for both visual and text-based workflows.\n\n```bash\nagent-browser screenshot --annotate\n# -> Screenshot saved to /tmp/screenshot-2026-02-17T12-00-00-abc123.png\n#    [1] @e1 button \"Submit\"\n#    [2] @e2 link \"Home\"\n#    [3] @e3 textbox \"Email\"\n```\n\nAfter an annotated screenshot, refs are cached so you can immediately interact with elements:\n\n```bash\nagent-browser screenshot --annotate ./page.png\nagent-browser click @e2     # Click the \"Home\" link labeled [2]\n```\n\nThis is useful for multimodal AI models that can reason about visual layout, unlabeled icon buttons, canvas elements, or visual state that the text accessibility tree cannot capture.\n\n## Options\n\n| Option | Description |\n|--------|-------------|\n| `--session <name>` | Use isolated session (or `AGENT_BROWSER_SESSION` env) |\n| `--session-name <name>` | Auto-save/restore session state (or `AGENT_BROWSER_SESSION_NAME` env) |\n| `--profile <path>` | Persistent browser profile directory (or `AGENT_BROWSER_PROFILE` env) |\n| `--state <path>` | Load storage state from JSON file (or `AGENT_BROWSER_STATE` env) |\n| `--headers <json>` | Set HTTP headers scoped to the URL's origin |\n| `--executable-path <path>` | Custom browser executable (or `AGENT_BROWSER_EXECUTABLE_PATH` env) |\n| `--extension <path>` | Load browser extension (repeatable; or `AGENT_BROWSER_EXTENSIONS` env) |\n| `--args <args>` | Browser launch args, comma or newline separated (or `AGENT_BROWSER_ARGS` env) |\n| `--user-agent <ua>` | Custom User-Agent string (or `AGENT_BROWSER_USER_AGENT` env) |\n| `--proxy <url>` | Proxy server URL with optional auth (or `AGENT_BROWSER_PROXY` env) |\n| `--proxy-bypass <hosts>` | Hosts to bypass proxy (or `AGENT_BROWSER_PROXY_BYPASS` env) |\n| `--ignore-https-errors` | Ignore HTTPS certificate errors (useful for self-signed certs) |\n| `--allow-file-access` | Allow file:// URLs to access local files (Chromium only) |\n| `-p, --provider <name>` | Cloud browser provider (or `AGENT_BROWSER_PROVIDER` env) |\n| `--device <name>` | iOS device name, e.g. \"iPhone 15 Pro\" (or `AGENT_BROWSER_IOS_DEVICE` env) |\n| `--json` | JSON output (for agents) |\n| `--full, -f` | Full page screenshot |\n| `--annotate` | Annotated screenshot with numbered element labels (or `AGENT_BROWSER_ANNOTATE` env) |\n| `--headed` | Show browser window (not headless) |\n| `--cdp <port\\|url>` | Connect via Chrome DevTools Protocol (port or WebSocket URL) |\n| `--auto-connect` | Auto-discover and connect to running Chrome (or `AGENT_BROWSER_AUTO_CONNECT` env) |\n| `--config <path>` | Use a custom config file (or `AGENT_BROWSER_CONFIG` env) |\n| `--debug` | Debug output |\n\n## Configuration\n\nCreate an `agent-browser.json` file to set persistent defaults instead of repeating flags on every command.\n\n**Locations (lowest to highest priority):**\n\n1. `~/.agent-browser/config.json` -- user-level defaults\n2. `./agent-browser.json` -- project-level overrides (in working directory)\n3. `AGENT_BROWSER_*` environment variables override config file values\n4. CLI flags override everything\n\n**Example `agent-browser.json`:**\n\n```json\n{\n  \"headed\": true,\n  \"proxy\": \"http://localhost:8080\",\n  \"profile\": \"./browser-data\",\n  \"userAgent\": \"my-agent/1.0\",\n  \"ignoreHttpsErrors\": true\n}\n```\n\nUse `--config <path>` or `AGENT_BROWSER_CONFIG` to load a specific config file instead of the defaults:\n\n```bash\nagent-browser --config ./ci-config.json open example.com\nAGENT_BROWSER_CONFIG=./ci-config.json agent-browser open example.com\n```\n\nAll options from the table above can be set in the config file using camelCase keys (e.g., `--executable-path` becomes `\"executablePath\"`, `--proxy-bypass` becomes `\"proxyBypass\"`). Unknown keys are ignored for forward compatibility.\n\nBoolean flags accept an optional `true`/`false` value to override config settings. For example, `--headed false` disables `\"headed\": true` from config. A bare `--headed` is equivalent to `--headed true`.\n\nAuto-discovered config files that are missing are silently ignored. If `--config <path>` points to a missing or invalid file, agent-browser exits with an error. Extensions from user and project configs are merged (concatenated), not replaced.\n\n> **Tip:** If your project-level `agent-browser.json` contains environment-specific values (paths, proxies), consider adding it to `.gitignore`.\n\n## Selectors\n\n### Refs (Recommended for AI)\n\nRefs provide deterministic element selection from snapshots:\n\n```bash\n# 1. Get snapshot with refs\nagent-browser snapshot\n# Output:\n# - heading \"Example Domain\" [ref=e1] [level=1]\n# - button \"Submit\" [ref=e2]\n# - textbox \"Email\" [ref=e3]\n# - link \"Learn more\" [ref=e4]\n\n# 2. Use refs to interact\nagent-browser click @e2                   # Click the button\nagent-browser fill @e3 \"test@example.com\" # Fill the textbox\nagent-browser get text @e1                # Get heading text\nagent-browser hover @e4                   # Hover the link\n```\n\n**Why use refs?**\n- **Deterministic**: Ref points to exact element from snapshot\n- **Fast**: No DOM re-query needed\n- **AI-friendly**: Snapshot + ref workflow is optimal for LLMs\n\n### CSS Selectors\n\n```bash\nagent-browser click \"#id\"\nagent-browser click \".class\"\nagent-browser click \"div > button\"\n```\n\n### Text & XPath\n\n```bash\nagent-browser click \"text=Submit\"\nagent-browser click \"xpath=//button\"\n```\n\n### Semantic Locators\n\n```bash\nagent-browser find role button click --name \"Submit\"\nagent-browser find label \"Email\" fill \"test@test.com\"\n```\n\n## Agent Mode\n\nUse `--json` for machine-readable output:\n\n```bash\nagent-browser snapshot --json\n# Returns: {\"success\":true,\"data\":{\"snapshot\":\"...\",\"refs\":{\"e1\":{\"role\":\"heading\",\"name\":\"Title\"},...}}}\n\nagent-browser get text @e1 --json\nagent-browser is visible @e2 --json\n```\n\n### Optimal AI Workflow\n\n```bash\n# 1. Navigate and get snapshot\nagent-browser open example.com\nagent-browser snapshot -i --json   # AI parses tree and refs\n\n# 2. AI identifies target refs from snapshot\n# 3. Execute actions using refs\nagent-browser click @e2\nagent-browser fill @e3 \"input text\"\n\n# 4. Get new snapshot if page changed\nagent-browser snapshot -i --json\n```\n\n### Command Chaining\n\nCommands can be chained with `&&` in a single shell invocation. The browser persists via a background daemon, so chaining is safe and more efficient:\n\n```bash\n# Open, wait for load, and snapshot in one call\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser snapshot -i\n\n# Chain multiple interactions\nagent-browser fill @e1 \"user@example.com\" && agent-browser fill @e2 \"pass\" && agent-browser click @e3\n\n# Navigate and screenshot\nagent-browser open example.com && agent-browser wait --load networkidle && agent-browser screenshot page.png\n```\n\nUse `&&` when you don't need intermediate output. Run commands separately when you need to parse output first (e.g., snapshot to discover refs before interacting).\n\n## Headed Mode\n\nShow the browser window for debugging:\n\n```bash\nagent-browser open example.com --headed\n```\n\nThis opens a visible browser window instead of running headless.\n\n## Authenticated Sessions\n\nUse `--headers` to set HTTP headers for a specific origin, enabling authentication without login flows:\n\n```bash\n# Headers are scoped to api.example.com only\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer <token>\"}'\n\n# Requests to api.example.com include the auth header\nagent-browser snapshot -i --json\nagent-browser click @e2\n\n# Navigate to another domain - headers are NOT sent (safe!)\nagent-browser open other-site.com\n```\n\nThis is useful for:\n- **Skipping login flows** - Authenticate via headers instead of UI\n- **Switching users** - Start new sessions with different auth tokens\n- **API testing** - Access protected endpoints directly\n- **Security** - Headers are scoped to the origin, not leaked to other domains\n\nTo set headers for multiple origins, use `--headers` with each `open` command:\n\n```bash\nagent-browser open api.example.com --headers '{\"Authorization\": \"Bearer token1\"}'\nagent-browser open api.acme.com --headers '{\"Authorization\": \"Bearer token2\"}'\n```\n\nFor global headers (all domains), use `set headers`:\n\n```bash\nagent-browser set headers '{\"X-Custom-Header\": \"value\"}'\n```\n\n## Custom Browser Executable\n\nUse a custom browser executable instead of the bundled Chromium. This is useful for:\n- **Serverless deployment**: Use lightweight Chromium builds like `@sparticuz/chromium` (~50MB vs ~684MB)\n- **System browsers**: Use an existing Chrome/Chromium installation\n- **Custom builds**: Use modified browser builds\n\n### CLI Usage\n\n```bash\n# Via flag\nagent-browser --executable-path /path/to/chromium open example.com\n\n# Via environment variable\nAGENT_BROWSER_EXECUTABLE_PATH=/path/to/chromium agent-browser open example.com\n```\n\n### Serverless Example (Vercel/AWS Lambda)\n\n```typescript\nimport chromium from '@sparticuz/chromium';\nimport { BrowserManager } from 'agent-browser';\n\nexport async function handler() {\n  const browser = new BrowserManager();\n  await browser.launch({\n    executablePath: await chromium.executablePath(),\n    headless: true,\n  });\n  // ... use browser\n}\n```\n\n## Local Files\n\nOpen and interact with local files (PDFs, HTML, etc.) using `file://` URLs:\n\n```bash\n# Enable file access (required for JavaScript to access local files)\nagent-browser --allow-file-access open file:///path/to/document.pdf\nagent-browser --allow-file-access open file:///path/to/page.html\n\n# Take screenshot of a local PDF\nagent-browser --allow-file-access open file:///Users/me/report.pdf\nagent-browser screenshot report.png\n```\n\nThe `--allow-file-access` flag adds Chromium flags (`--allow-file-access-from-files`, `--allow-file-access`) that allow `file://` URLs to:\n- Load and render local files\n- Access other local files via JavaScript (XHR, fetch)\n- Load local resources (images, scripts, stylesheets)\n\n**Note:** This flag only works with Chromium. For security, it's disabled by default.\n\n## CDP Mode\n\nConnect to an existing browser via Chrome DevTools Protocol:\n\n```bash\n# Start Chrome with: google-chrome --remote-debugging-port=9222\n\n# Connect once, then run commands without --cdp\nagent-browser connect 9222\nagent-browser snapshot\nagent-browser tab\nagent-browser close\n\n# Or pass --cdp on each command\nagent-browser --cdp 9222 snapshot\n\n# Connect to remote browser via WebSocket URL\nagent-browser --cdp \"wss://your-browser-service.com/cdp?token=...\" snapshot\n```\n\nThe `--cdp` flag accepts either:\n- A port number (e.g., `9222`) for local connections via `http://localhost:{port}`\n- A full WebSocket URL (e.g., `wss://...` or `ws://...`) for remote browser services\n\nThis enables control of:\n- Electron apps\n- Chrome/Chromium instances with remote debugging\n- WebView2 applications\n- Any browser exposing a CDP endpoint\n\n### Auto-Connect\n\nUse `--auto-connect` to automatically discover and connect to a running Chrome instance without specifying a port:\n\n```bash\n# Auto-discover running Chrome with remote debugging\nagent-browser --auto-connect open example.com\nagent-browser --auto-connect snapshot\n\n# Or via environment variable\nAGENT_BROWSER_AUTO_CONNECT=1 agent-browser snapshot\n```\n\nAuto-connect discovers Chrome by:\n1. Reading Chrome's `DevToolsActivePort` file from the default user data directory\n2. Falling back to probing common debugging ports (9222, 9229)\n\nThis is useful when:\n- Chrome 144+ has remote debugging enabled via `chrome://inspect/#remote-debugging` (which uses a dynamic port)\n- You want a zero-configuration connection to your existing browser\n- You don't want to track which port Chrome is using\n\n## Streaming (Browser Preview)\n\nStream the browser viewport via WebSocket for live preview or \"pair browsing\" where a human can watch and interact alongside an AI agent.\n\n### Enable Streaming\n\nSet the `AGENT_BROWSER_STREAM_PORT` environment variable:\n\n```bash\nAGENT_BROWSER_STREAM_PORT=9223 agent-browser open example.com\n```\n\nThis starts a WebSocket server on the specified port that streams the browser viewport and accepts input events.\n\n### WebSocket Protocol\n\nConnect to `ws://localhost:9223` to receive frames and send input:\n\n**Receive frames:**\n```json\n{\n  \"type\": \"frame\",\n  \"data\": \"<base64-encoded-jpeg>\",\n  \"metadata\": {\n    \"deviceWidth\": 1280,\n    \"deviceHeight\": 720,\n    \"pageScaleFactor\": 1,\n    \"offsetTop\": 0,\n    \"scrollOffsetX\": 0,\n    \"scrollOffsetY\": 0\n  }\n}\n```\n\n**Send mouse events:**\n```json\n{\n  \"type\": \"input_mouse\",\n  \"eventType\": \"mousePressed\",\n  \"x\": 100,\n  \"y\": 200,\n  \"button\": \"left\",\n  \"clickCount\": 1\n}\n```\n\n**Send keyboard events:**\n```json\n{\n  \"type\": \"input_keyboard\",\n  \"eventType\": \"keyDown\",\n  \"key\": \"Enter\",\n  \"code\": \"Enter\"\n}\n```\n\n**Send touch events:**\n```json\n{\n  \"type\": \"input_touch\",\n  \"eventType\": \"touchStart\",\n  \"touchPoints\": [{ \"x\": 100, \"y\": 200 }]\n}\n```\n\n### Programmatic API\n\nFor advanced use, control streaming directly via the protocol:\n\n```typescript\nimport { BrowserManager } from 'agent-browser';\n\nconst browser = new BrowserManager();\nawait browser.launch({ headless: true });\nawait browser.navigate('https://example.com');\n\n// Start screencast\nawait browser.startScreencast((frame) => {\n  // frame.data is base64-encoded image\n  // frame.metadata contains viewport info\n  console.log('Frame received:', frame.metadata.deviceWidth, 'x', frame.metadata.deviceHeight);\n}, {\n  format: 'jpeg',\n  quality: 80,\n  maxWidth: 1280,\n  maxHeight: 720,\n});\n\n// Inject mouse events\nawait browser.injectMouseEvent({\n  type: 'mousePressed',\n  x: 100,\n  y: 200,\n  button: 'left',\n});\n\n// Inject keyboard events\nawait browser.injectKeyboardEvent({\n  type: 'keyDown',\n  key: 'Enter',\n  code: 'Enter',\n});\n\n// Stop when done\nawait browser.stopScreencast();\n```\n\n## Architecture\n\nagent-browser uses a client-daemon architecture:\n\n1. **Rust CLI** (fast native binary) - Parses commands, communicates with daemon\n2. **Node.js Daemon** - Manages Playwright browser instance\n3. **Fallback** - If native binary unavailable, uses Node.js directly\n\nThe daemon starts automatically on first command and persists between commands for fast subsequent operations.\n\n**Browser Engine:** Uses Chromium by default. The daemon also supports Firefox and WebKit via the Playwright protocol.\n\n## Platforms\n\n| Platform | Binary | Fallback |\n|----------|--------|----------|\n| macOS ARM64 | Native Rust | Node.js |\n| macOS x64 | Native Rust | Node.js |\n| Linux ARM64 | Native Rust | Node.js |\n| Linux x64 | Native Rust | Node.js |\n| Windows x64 | Native Rust | Node.js |\n\n## Usage with AI Agents\n\n### Just ask the agent\n\nThe simplest approach -- just tell your agent to use it:\n\n```\nUse agent-browser to test the login flow. Run agent-browser --help to see available commands.\n```\n\nThe `--help` output is comprehensive and most agents can figure it out from there.\n\n### AI Coding Assistants (recommended)\n\nAdd the skill to your AI coding assistant for richer context:\n\n```bash\nnpx skills add vercel-labs/agent-browser\n```\n\nThis works with Claude Code, Codex, Cursor, Gemini CLI, GitHub Copilot, Goose, OpenCode, and Windsurf. The skill is fetched from the repository, so it stays up to date automatically -- do not copy `SKILL.md` from `node_modules` as it will become stale.\n\n### Claude Code\n\nInstall as a Claude Code skill:\n\n```bash\nnpx skills add vercel-labs/agent-browser\n```\n\nThis adds the skill to `.claude/skills/agent-browser/SKILL.md` in your project. The skill teaches Claude Code the full agent-browser workflow, including the snapshot-ref interaction pattern, session management, and timeout handling.\n\n### AGENTS.md / CLAUDE.md\n\nFor more consistent results, add to your project or global instructions file:\n\n```markdown\n## Browser Automation\n\nUse `agent-browser` for web automation. Run `agent-browser --help` for all commands.\n\nCore workflow:\n1. `agent-browser open <url>` - Navigate to page\n2. `agent-browser snapshot -i` - Get interactive elements with refs (@e1, @e2)\n3. `agent-browser click @e1` / `fill @e2 \"text\"` - Interact using refs\n4. Re-snapshot after page changes\n```\n\n## Integrations\n\n### iOS Simulator\n\nControl real Mobile Safari in the iOS Simulator for authentic mobile web testing. Requires macOS with Xcode.\n\n**Setup:**\n\n```bash\n# Install Appium and XCUITest driver\nnpm install -g appium\nappium driver install xcuitest\n```\n\n**Usage:**\n\n```bash\n# List available iOS simulators\nagent-browser device list\n\n# Launch Safari on a specific device\nagent-browser -p ios --device \"iPhone 16 Pro\" open https://example.com\n\n# Same commands as desktop\nagent-browser -p ios snapshot -i\nagent-browser -p ios tap @e1\nagent-browser -p ios fill @e2 \"text\"\nagent-browser -p ios screenshot mobile.png\n\n# Mobile-specific commands\nagent-browser -p ios swipe up\nagent-browser -p ios swipe down 500\n\n# Close session\nagent-browser -p ios close\n```\n\nOr use environment variables:\n\n```bash\nexport AGENT_BROWSER_PROVIDER=ios\nexport AGENT_BROWSER_IOS_DEVICE=\"iPhone 16 Pro\"\nagent-browser open https://example.com\n```\n\n| Variable | Description |\n|----------|-------------|\n| `AGENT_BROWSER_PROVIDER` | Set to `ios` to enable iOS mode |\n| `AGENT_BROWSER_IOS_DEVICE` | Device name (e.g., \"iPhone 16 Pro\", \"iPad Pro\") |\n| `AGENT_BROWSER_IOS_UDID` | Device UDID (alternative to device name) |\n\n**Supported devices:** All iOS Simulators available in Xcode (iPhones, iPads), plus real iOS devices.\n\n**Note:** The iOS provider boots the simulator, starts Appium, and controls Safari. First launch takes ~30-60 seconds; subsequent commands are fast.\n\n#### Real Device Support\n\nAppium also supports real iOS devices connected via USB. This requires additional one-time setup:\n\n**1. Get your device UDID:**\n```bash\nxcrun xctrace list devices\n# or\nsystem_profiler SPUSBDataType | grep -A 5 \"iPhone\\|iPad\"\n```\n\n**2. Sign WebDriverAgent (one-time):**\n```bash\n# Open the WebDriverAgent Xcode project\ncd ~/.appium/node_modules/appium-xcuitest-driver/node_modules/appium-webdriveragent\nopen WebDriverAgent.xcodeproj\n```\n\nIn Xcode:\n- Select the `WebDriverAgentRunner` target\n- Go to Signing & Capabilities\n- Select your Team (requires Apple Developer account, free tier works)\n- Let Xcode manage signing automatically\n\n**3. Use with agent-browser:**\n```bash\n# Connect device via USB, then:\nagent-browser -p ios --device \"<DEVICE_UDID>\" open https://example.com\n\n# Or use the device name if unique\nagent-browser -p ios --device \"John's iPhone\" open https://example.com\n```\n\n**Real device notes:**\n- First run installs WebDriverAgent to the device (may require Trust prompt)\n- Device must be unlocked and connected via USB\n- Slightly slower initial connection than simulator\n- Tests against real Safari performance and behavior\n\n### Browserbase\n\n[Browserbase](https://browserbase.com) provides remote browser infrastructure to make deployment of agentic browsing agents easy. Use it when running the agent-browser CLI in an environment where a local browser isn't feasible.\n\nTo enable Browserbase, use the `-p` flag:\n\n```bash\nexport BROWSERBASE_API_KEY=\"your-api-key\"\nexport BROWSERBASE_PROJECT_ID=\"your-project-id\"\nagent-browser -p browserbase open https://example.com\n```\n\nOr use environment variables for CI/scripts:\n\n```bash\nexport AGENT_BROWSER_PROVIDER=browserbase\nexport BROWSERBASE_API_KEY=\"your-api-key\"\nexport BROWSERBASE_PROJECT_ID=\"your-project-id\"\nagent-browser open https://example.com\n```\n\nWhen enabled, agent-browser connects to a Browserbase session instead of launching a local browser. All commands work identically.\n\nGet your API key and project ID from the [Browserbase Dashboard](https://browserbase.com/overview).\n\n### Browser Use\n\n[Browser Use](https://browser-use.com) provides cloud browser infrastructure for AI agents. Use it when running agent-browser in environments where a local browser isn't available (serverless, CI/CD, etc.).\n\nTo enable Browser Use, use the `-p` flag:\n\n```bash\nexport BROWSER_USE_API_KEY=\"your-api-key\"\nagent-browser -p browseruse open https://example.com\n```\n\nOr use environment variables for CI/scripts:\n\n```bash\nexport AGENT_BROWSER_PROVIDER=browseruse\nexport BROWSER_USE_API_KEY=\"your-api-key\"\nagent-browser open https://example.com\n```\n\nWhen enabled, agent-browser connects to a Browser Use cloud session instead of launching a local browser. All commands work identically.\n\nGet your API key from the [Browser Use Cloud Dashboard](https://cloud.browser-use.com/settings?tab=api-keys). Free credits are available to get started, with pay-as-you-go pricing after.\n\n### Kernel\n\n[Kernel](https://www.kernel.sh) provides cloud browser infrastructure for AI agents with features like stealth mode and persistent profiles.\n\nTo enable Kernel, use the `-p` flag:\n\n```bash\nexport KERNEL_API_KEY=\"your-api-key\"\nagent-browser -p kernel open https://example.com\n```\n\nOr use environment variables for CI/scripts:\n\n```bash\nexport AGENT_BROWSER_PROVIDER=kernel\nexport KERNEL_API_KEY=\"your-api-key\"\nagent-browser open https://example.com\n```\n\nOptional configuration via environment variables:\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `KERNEL_HEADLESS` | Run browser in headless mode (`true`/`false`) | `false` |\n| `KERNEL_STEALTH` | Enable stealth mode to avoid bot detection (`true`/`false`) | `true` |\n| `KERNEL_TIMEOUT_SECONDS` | Session timeout in seconds | `300` |\n| `KERNEL_PROFILE_NAME` | Browser profile name for persistent cookies/logins (created if it doesn't exist) | (none) |\n\nWhen enabled, agent-browser connects to a Kernel cloud session instead of launching a local browser. All commands work identically.\n\n**Profile Persistence:** When `KERNEL_PROFILE_NAME` is set, the profile will be created if it doesn't already exist. Cookies, logins, and session data are automatically saved back to the profile when the browser session ends, making them available for future sessions.\n\nGet your API key from the [Kernel Dashboard](https://dashboard.onkernel.com).\n\n## License\n\nApache-2.0\n"
      },
      "plugins": [
        {
          "name": "agent-browser",
          "description": "Automates browser interactions for web testing, form filling, screenshots, and data extraction",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/agent-browser"
          ],
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add vercel-labs/agent-browser",
            "/plugin install agent-browser@agent-browser"
          ]
        }
      ]
    },
    {
      "name": "nextjs-docs-rag-marketplace",
      "version": null,
      "description": "Next.js documentation RAG plugin for Claude Code",
      "repo_full_name": "vercel-labs/next-docs-agentic-rag",
      "repo_url": "https://github.com/vercel-labs/next-docs-agentic-rag",
      "repo_description": null,
      "signals": {
        "stars": 2,
        "forks": 0,
        "pushed_at": "2026-02-09T23:17:26Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"nextjs-docs-rag-marketplace\",\n  \"owner\": {\n    \"name\": \"Jude Gao\"\n  },\n  \"metadata\": {\n    \"description\": \"Next.js documentation RAG plugin for Claude Code\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"nextjs-docs-rag\",\n      \"source\": \"./\",\n      \"description\": \"Injects relevant Next.js documentation into every prompt via RAG\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\"nextjs\", \"rag\", \"docs\", \"context\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"nextjs-docs-rag\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Injects relevant Next.js documentation into every prompt via RAG, so the coding agent always has accurate, up-to-date framework context.\",\n  \"author\": {\n    \"name\": \"Jude Gao\"\n  },\n  \"repository\": \"https://github.com/judegao/agentic-rag\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"nextjs\", \"rag\", \"docs\", \"context\"]\n}\n",
        "README.md": "This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).\n\n## Getting Started\n\nFirst, run the development server:\n\n```bash\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n# or\nbun dev\n```\n\nOpen [http://localhost:3000](http://localhost:3000) with your browser to see the result.\n\nYou can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.\n\nThis project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.\n\n## Learn More\n\nTo learn more about Next.js, take a look at the following resources:\n\n- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.\n- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.\n\nYou can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!\n\n## Deploy on Vercel\n\nThe easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.\n\nCheck out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.\n"
      },
      "plugins": [
        {
          "name": "nextjs-docs-rag",
          "source": "./",
          "description": "Injects relevant Next.js documentation into every prompt via RAG",
          "version": "0.1.0",
          "keywords": [
            "nextjs",
            "rag",
            "docs",
            "context"
          ],
          "categories": [
            "context",
            "docs",
            "nextjs",
            "rag"
          ],
          "install_commands": [
            "/plugin marketplace add vercel-labs/next-docs-agentic-rag",
            "/plugin install nextjs-docs-rag@nextjs-docs-rag-marketplace"
          ]
        }
      ]
    }
  ]
}