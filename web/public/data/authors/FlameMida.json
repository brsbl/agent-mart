{
  "author": {
    "id": "FlameMida",
    "display_name": "Edward zZhang",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/33086993?u=a99e1b5f98917e20dff51c21b48210a2d91fe93d&v=4",
    "url": "https://github.com/FlameMida",
    "bio": "Nothing is true,Everything is permitted.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 1,
      "total_skills": 1,
      "total_stars": 8,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "spec-agent-skills",
      "version": null,
      "description": "spec-coding agent skills",
      "owner_info": {
        "name": "FlameMida",
        "email": ""
      },
      "keywords": [],
      "repo_full_name": "FlameMida/spec-dev",
      "repo_url": "https://github.com/FlameMida/spec-dev",
      "repo_description": "claude code spec-coding workflow plugin",
      "homepage": "",
      "signals": {
        "stars": 8,
        "forks": 0,
        "pushed_at": "2026-01-28T09:01:06Z",
        "created_at": "2025-12-17T03:56:04Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 560
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 14457
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/code-architect.md",
          "type": "blob",
          "size": 7661
        },
        {
          "path": "agents/code-explorer.md",
          "type": "blob",
          "size": 6374
        },
        {
          "path": "agents/code-reviewer.md",
          "type": "blob",
          "size": 7666
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/check-mcp.md",
          "type": "blob",
          "size": 3643
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/feat-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/feat-dev/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/feat-dev/assets/output-template.md",
          "type": "blob",
          "size": 11116
        },
        {
          "path": "skills/feat-dev/assets/summary-examples.md",
          "type": "blob",
          "size": 6437
        },
        {
          "path": "skills/feat-dev/assets/summary-output-template.md",
          "type": "blob",
          "size": 2400
        },
        {
          "path": "skills/feat-dev/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/feat-dev/references/mcp-tools.md",
          "type": "blob",
          "size": 7918
        },
        {
          "path": "skills/feat-dev/references/phase-1-discovery.md",
          "type": "blob",
          "size": 3962
        },
        {
          "path": "skills/feat-dev/references/phase-2-exploration.md",
          "type": "blob",
          "size": 3110
        },
        {
          "path": "skills/feat-dev/references/phase-3-clarify.md",
          "type": "blob",
          "size": 5279
        },
        {
          "path": "skills/feat-dev/references/phase-4-design.md",
          "type": "blob",
          "size": 10895
        },
        {
          "path": "skills/feat-dev/references/phase-5-implement.md",
          "type": "blob",
          "size": 3828
        },
        {
          "path": "skills/feat-dev/references/phase-6-review.md",
          "type": "blob",
          "size": 3101
        },
        {
          "path": "skills/feat-dev/references/phase-7-summary.md",
          "type": "blob",
          "size": 1376
        },
        {
          "path": "skills/feat-dev/references/quick-reference.md",
          "type": "blob",
          "size": 3356
        },
        {
          "path": "skills/feat-dev/references/specialized-agents.md",
          "type": "blob",
          "size": 7006
        },
        {
          "path": "skills/feat-dev/references/task-list-management.md",
          "type": "blob",
          "size": 3138
        },
        {
          "path": "skills/feat-dev/references/troubleshooting.md",
          "type": "blob",
          "size": 7973
        },
        {
          "path": "skills/feat-dev/references/workflow-control.md",
          "type": "blob",
          "size": 5498
        },
        {
          "path": "skills/feat-dev/skill.md",
          "type": "blob",
          "size": 9695
        },
        {
          "path": "skills/requirement-analysis",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/requirement-analysis/SKILL.md",
          "type": "blob",
          "size": 10689
        },
        {
          "path": "skills/requirement-analysis/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/requirement-analysis/assets/output-template.md",
          "type": "blob",
          "size": 3661
        },
        {
          "path": "skills/requirement-analysis/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/requirement-analysis/references/examples.md",
          "type": "blob",
          "size": 1662
        },
        {
          "path": "skills/requirement-analysis/references/parallel-patterns.md",
          "type": "blob",
          "size": 2186
        },
        {
          "path": "skills/requirement-analysis/references/task-list-management.md",
          "type": "blob",
          "size": 2278
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"spec-agent-skills\",\n  \"owner\": {\n    \"name\": \"FlameMida\",\n    \"email\": \"\"\n  },\n  \"metadata\": {\n    \"description\": \"spec-coding agent skills\",\n    \"version\": \"4.2.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"spec-dev\",\n      \"description\": \"开发工作流插件集 - 包含功能开发和需求分析两大系统化工作流\",\n      \"source\": \"./\",\n      \"category\": \"development\",\n      \"homepage\": \"https://github.com/FlameMida/spec-dev\",\n      \"skills\": [\n        \"./skills/feat-dev\",\n        \"./skills/requirement-analysis\"\n      ]\n    }\n  ]\n}\n",
        "README.md": "# spec-dev-skills\n\n完整的功能开发工作流插件 - 7阶段系统化开发流程，包含代码探索、架构设计、实施和质量审查。\n\n**中文版** | 融合 ultrathink 深度分析 | MCP 工具增强 | 语言无关\n\n## 特性\n\n- **双工作流系统**: 7 阶段完整开发 + 9 阶段需求分析，灵活适配不同场景\n- **Task List 智能管理**: 进度可视化、工作流透明化、断点恢复、任务可复用\n- **双模式架构设计**: feat-dev 支持单方案快速设计 vs 多方案对比（复杂需求）\n- **ultrathink 深度分析**: 在关键决策点使用 Sequential Thinking 进行结构化思考\n- **灵活并行模式**: 探索阶段 2-5 agents，审查阶段 3-5 agents，自适应需求复杂度\n- **MCP 工具增强**: 集成 context7、exa、sequential-thinking（可选，智能降级）\n- **3 个专门化 Agents**: code-explorer、code-architect、code-reviewer（支持子任务跟踪）\n- **语言无关**: 适用于任何编程语言和项目结构\n- **中文输出**: 全程中文沟通\n\n## MCP 工具增强（推荐但可选）\n\n### 🎯 重要说明\n\n本插件的**所有功能在没有 MCP 的情况下也能正常工作**！\n\n插件使用智能降级策略，当 MCP 不可用时自动切换到备用方案：\n\n| MCP 工具 | 主要功能 | 降级方案 | 体验差异 |\n|---------|---------|---------|----------|\n| **context7** | 最新库文档和 API 参考 | WebSearch + 项目依赖分析 | 可能返回过时文档 |\n| **exa** | 高质量网页搜索 | WebSearch | 搜索结果质量略低 |\n| **sequential-thinking** | 结构化深度思考（ultrathink） | EnterPlanMode + 思维链分析 | 结构化程度降低 |\n\n### 使用体验对比\n\n| 功能 | 有 MCP | 无 MCP（降级） |\n|------|--------|---------------|\n| 获取最新库文档 | ✅ 实时最新 API | ⚠️ 可能过时（WebSearch） |\n| 代码示例搜索 | ✅ 精准代码片段 | ⚠️ 通用搜索结果 |\n| 架构深度分析 | ✅ 结构化 ultrathink | ⚠️ 常规思维链 |\n| 整体工作流 | 🌟 最佳体验 | ✅ 完全可用 |\n\n### 🚀 快速开始（无需配置）\n## 安装\n```bash\n# 添加为 marketplace\n/plugin marketplace add https://github.com/FlameMida/spec-dev\n\n# 安装skill spec-dev\n/plugin install spec-dev@SPEC-plugins\n```\n\n直接使用插件，无需任何 MCP 配置即可获得完整功能（降级方案自动生效）。\n\n\n### 💡 推荐配置（最佳体验）\n\n如果您想获得最佳开发体验，建议在**全局配置**中安装 MCP 服务器。\n\n#### 配置步骤\n\n\n\n**1. 编辑全局配置文件**\n\n编辑 `~/.claude.json`（Windows 用户为 `%USERPROFILE%\\.claude.json`）：\n\n```json\n{\n  \"mcpServers\": {\n    \"context7\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@upstash/context7-mcp\"],\n      \"env\": {\n        \"CONTEXT7_API_KEY\": \"${CONTEXT7_API_KEY}\"\n      }\n    },\n    \"exa\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"exa-mcp-server\"],\n      \"env\": {\n        \"EXA_API_KEY\": \"${EXA_API_KEY}\"\n      }\n    },\n    \"sequential-thinking\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-sequential-thinking\"]\n    }\n  }\n}\n```\n\n**2. 配置环境变量**\n\n在 `~/.zshrc`（macOS/Linux）或 `~/.bashrc`（Linux）或系统环境变量（Windows）中添加：\n\n```bash\nexport CONTEXT7_API_KEY=\"your-context7-api-key\"\nexport EXA_API_KEY=\"your-exa-api-key\"\n```\n\n**获取 API Key**：\n- Context7: https://context7.com/\n- Exa: https://exa.ai/\n\n#### 检查 MCP 配置状态\n\n运行以下命令检查当前 MCP 配置状态：\n\n```bash\n/check-mcp\n```\n\n该命令会显示：\n- 哪些 MCP 已配置\n- 哪些 MCP 正在使用\n- 哪些功能使用降级方案\n- 配置建议和优化提示\n\n### ⚠️ 关于 MCP 重复安装\n如果您：\n- ✅ 已在全局配置中安装了这些 MCP - 完美，直接使用\n- ✅ 不想安装 MCP - 没问题，降级方案自动生效\n- ✅ 部分安装了 MCP - 已有的 MCP 会被使用，其他功能降级\n\n\n## 使用方法\n\n本插件提供**两个主要 skill**，可根据需求选择使用：\n\n### Skill 对比\n\n| 特性 | **feat-dev** | **requirement-analysis** |\n|------|-------------|------------------------|\n| **阶段数** | 7 阶段 | 9 阶段 |\n| **适用场景** | 复杂功能开发、多模块实施、需要架构设计 | 前期分析、技术方案设计、API/数据库设计 |\n| **核心输出** | 完整功能实现 + 代码审查 | 实施计划 + 可选实施 |\n| **架构设计** | 双模式（单方案/多方案对比） | 单一深度分析 |\n| **外部资源研究** | 集成在代码探索阶段 | 独立阶段（条件执行） |\n| **实施阶段** | 必须执行 | 可选（用户确认后） |\n| **代码审查** | 必须执行（3个并行） | 可选执行（3-5个并行） |\n| **断点恢复** | ✅ 支持 | ✅ 支持 |\n\n### 如何选择\n\n**选择 feat-dev 当你需要**：\n- ✅ 完整实施一个新功能\n- ✅ 修改多个核心模块\n- ✅ 需要对比多种架构方案\n- ✅ 需要自动化的代码审查\n- ✅ 从设计到交付的完整流程\n\n**选择 requirement-analysis 当你需要**：\n- ✅ 快速分析技术方案可行性\n- ✅ 设计 API 或数据库架构\n- ✅ 评估实施复杂度\n- ✅ 先看计划再决定是否实施\n- ✅ 需要研究外部资源和最佳实践\n\n### 1. feat-dev - 完整功能开发工作流\n\n**适用场景**：复杂功能开发、多模块实施、需要架构设计的任务\n\n**使用方式**：\n```bash\n/feat-dev 实现用户认证功能\n```\n\n**工作流程**：7 个完整阶段（需求理解 → 代码探索 → 澄清问题 → 架构设计 → 实施 → 质量审查 → 总结）\n\n**示例**：\n```bash\n/feat-dev 实现一个支持多租户的订单管理系统，包括订单创建、状态跟踪和报表统计功能\n```\n\n### 2. requirement-analysis - 需求分析工作流\n\n**适用场景**：快速需求分析、前期设计规划、需要深度分析但不立即实施的场景\n\n**使用方式**：\n```bash\n/requirement-analysis 分析用户权限系统的实现方案\n```\n\n**工作流程**：9 个完整阶段（需求理解 → 代码探索 → 外部资源研究 → 澄清问题 → 深度分析 → 展示计划 → 可选实施 → 可选审查 → 总结）\n\n**示例**：\n```bash\n分析如何集成第三方支付系统（支付宝、微信支付），提供技术方案, 使用需求分析skill\n```\n\n\n## 专门化 Agents\n\n本插件使用三个专门化 agents 提升效率和质量，所有 agents 都支持子任务跟踪。\n\n| Agent | 颜色 | 模型     | 用途 | 使用阶段 | 并行数量 |\n|-------|------|--------|------|---------|---------|\n| **code-explorer** | 黄色 | haiku  | 深度分析代码库，追踪执行路径 | 代码库探索 | 2-5 个 |\n| **code-architect** | 绿色 | sonnet | 设计架构蓝图，制定实施方案 | 架构设计 | 1-3 个 |\n| **code-reviewer** | 红色 | haiku  | 代码审查，识别 bug 和规范问题 | 质量审查 | 3-5 个 |\n\n### 并行策略\n\n**何时使用并行**：\n- ✅ 需求涉及多个架构层次或模块\n- ✅ 探索任务可以清晰分解\n- ✅ 需要节省时间，提高效率\n\n**并行数量建议**：\n- 简单需求：1 个 agent\n- 中等需求：2-3 个 agents\n- 复杂需求：3-5 个 agents\n- ⚠️ 不建议超过 5 个并行任务\n\n**探索阶段分解策略**：\n- **按架构层次**：数据层、服务层、API层\n- **按功能模块**：核心模块、关联模块\n- **按关注点**：现有实现、错误处理、测试、配置\n\n## feat-dev 的 7 阶段工作流\n\n```\n阶段 1: 需求理解 (Discovery)\n    ↓ [可选 ultrathink]\n阶段 2: 代码库探索 (Codebase Exploration)\n    ↓ [并行 2-3 个 code-explorer]\n阶段 3: 澄清问题 (Clarifying Questions)\n    ↓ [AskUserQuestion]\n阶段 4: 架构设计 (Architecture Design)\n    ↓ [双模式：单方案/多方案对比]\n阶段 5: 实施 (Implementation)\n    ↓ [等待用户确认]\n阶段 6: 质量审查 (Quality Review)\n    ↓ [并行 3 个 code-reviewer]\n阶段 7: 总结 (Summary)\n```\n\n## feat-dev 的双模式架构设计\n\n阶段 4（架构设计）支持两种模式，根据需求复杂度自动选择。\n\n### 模式 1：单方案设计（简单/中等需求）\n\n**适用条件**：\n- 单一功能或 2-3 个模块\n- 实现路径清晰明确\n- 不涉及重大架构变更\n\n**执行流程**：\n1. 主进程使用 ultrathink 深度分析\n2. 启动 1 个 code-architect agent 细化设计\n3. 向用户展示单一方案\n4. 等待用户确认\n\n### 模式 2：多方案对比设计（复杂需求）\n\n**适用条件**：\n- 多种明显不同的实现路径\n- 重大架构权衡（性能 vs 复杂度）\n- 影响 3+ 个核心模块\n- 引入新的技术或架构模式\n\n**执行流程**：\n1. 并行启动 2-3 个 code-architect agents\n2. 每个 agent 设计不同方案：\n   - **方案 A**：最小改动方案（快速交付，低风险）\n   - **方案 B**：清晰架构方案（最佳实践，高质量）\n   - **方案 C**：实用平衡方案（⭐ 通常推荐）\n3. 整合所有方案并进行权衡分析\n4. 向用户展示对比和推荐意见\n5. 等待用户选择\n\n**方案对比示例**：\n| 维度 | 最小改动方案 | 清晰架构方案 | 实用平衡方案 |\n|------|------------|------------|------------|\n| 开发时间 | ⭐⭐⭐⭐⭐ 快 | ⭐⭐ 中等 | ⭐⭐⭐ 中等 |\n| 代码质量 | ⭐⭐⭐ 可接受 | ⭐⭐⭐⭐⭐ 优秀 | ⭐⭐⭐⭐ 良好 |\n| 可维护性 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 优秀 | ⭐⭐⭐⭐ 良好 |\n| 风险 | ⭐⭐⭐⭐⭐ 低 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐ 低 |\n| 推荐度 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |\n\n## requirement-analysis 的 9 阶段工作流\n\n```\n阶段 1: 需求理解\n    ↓ [可选 ultrathink]\n阶段 2: 代码库探索\n    ↓ [并行 2-5 个 code-explorer]\n阶段 3: 外部资源研究 ⚡ [条件执行]\n    ↓ [满足条件时执行，否则跳过]\n阶段 4: 澄清问题\n    ↓ [AskUserQuestion]\n阶段 5: 深度分析 ⚡ [必须 ultrathink]\n    ↓ [sequential-thinking]\n阶段 6: 展示实施计划 ⚠️ [关键检查点]\n    ↓ [等待用户确认]\n阶段 7: 实施开发 (可选)\n    ↓ [用户确认后执行]\n阶段 8: 代码审查 (可选)\n    ↓ [并行 3-5 个 code-reviewer]\n阶段 9: 总结\n```\n\n**关键特性**：\n- ⚡ **阶段 3**：条件执行 - 涉及新技术或需要行业实践时执行，否则跳过\n- ⚡ **阶段 5**：必须使用 ultrathink - 结构化的深度分析\n- ⚠️ **阶段 6**：关键检查点 - 必须等待用户确认后才能进入实施阶段\n- **阶段 7-8**：可选执行 - 根据用户需求决定是否实施和审查\n- **断点恢复**：支持中断后从任意阶段继续\n\n## Task List 智能管理\n\n两个 skill 都自动管理任务列表，提供完整的进度跟踪和恢复能力。\n\n### 核心功能\n\n- 📊 **进度可视化**：实时显示当前执行阶段和完成进度\n- 🔍 **工作流透明化**：清晰展示所有阶段流程和状态\n- ⏸️ **断点恢复**：支持中断后继续执行，自动识别断点\n- 🔄 **任务可复用**：任务列表可被其他工作流引用\n\n### 进度显示示例\n\n```\n### 任务进度\n用户认证项目 - 总进度: 43% (3/7 阶段完成)\n\n[✅ 完成] 阶段 1: 需求理解\n[✅ 完成] 阶段 2: 代码库探索\n[✅ 完成] 阶段 3: 澄清问题\n[🔄 进行中] 阶段 4: 架构设计\n[⏳ 等待] 阶段 5-7\n```\n\n### 断点恢复机制\n\n如果工作流被中断，下次运行时会：\n1. 自动检测未完成的任务列表\n2. 显示上次的执行进度\n3. 询问是否从断点继续\n4. 跳过已完成的阶段\n\n### Agents 子任务支持\n\ncode-explorer agent 支持创建细粒度的子任务跟踪：\n- 功能发现 - 识别入口点、定位核心文件\n- 代码流追踪 - 跟踪执行路径、记录依赖关系\n- 架构分析 - 映射架构层次、识别设计模式\n- 实现细节 - 检查核心算法、分析性能特征\n- 生成报告 - 整合发现、输出探索结果\n\n通过 `enableTaskList=true` 参数启用。\n\n## 目录结构\n\n```\nfeat-dev/\n├── .claude-plugin/\n│   └── marketplace.json    # Marketplace 配置\n├── agents/\n│   ├── code-explorer.md    # 代码探索 agent\n│   ├── code-architect.md   # 架构设计 agent\n│   └── code-reviewer.md    # 代码审查 agent\n├── commands/\n│   └── check-mcp.md        # /check-mcp 命令 - 检查 MCP 配置状态\n├── skills/\n│   ├── feat-dev/           # 完整功能开发工作流 skill\n│   │   ├── skill.md        # 主技能文件\n│   │   ├── references/     # 参考文档\n│   │   │   ├── phase-1-discovery.md\n│   │   │   ├── phase-2-exploration.md\n│   │   │   ├── phase-3-clarify.md\n│   │   │   ├── phase-4-design.md\n│   │   │   ├── phase-5-implement.md\n│   │   │   ├── phase-6-review.md\n│   │   │   ├── phase-7-summary.md\n│   │   │   ├── mcp-tools.md\n│   │   │   ├── quick-reference.md\n│   │   │   ├── specialized-agents.md\n│   │   │   ├── task-list-management.md\n│   │   │   ├── troubleshooting.md\n│   │   │   └── workflow-control.md\n│   │   └── assets/\n│   │       └── output-template.md\n│   └── requirement-analysis/  # 需求分析工作流 skill\n│       ├── skill.md        # 主技能文件\n│       ├── references/     # 参考文档\n│       │   ├── parallel-patterns.md\n│       │   ├── task-list-management.md\n│       │   └── examples.md\n│       └── assets/\n│           └── output-template.md\n├── CHANGELOG.md            # 版本更新日志\n└── README.md               # 项目说明文档（本文件）\n```\n\n## 与官方 feat-dev 的区别\n\n| 特性 | 官方 feat-dev | feat-dev |\n|------|-----------------|----------------|\n| 语言 | 英文 | 中文 |\n| ultrathink | 无 | 融合 Sequential Thinking |\n| MCP 工具 | 无 | 集成 context7、exa（可选） |\n| MCP 降级 | 无 | 智能降级方案 |\n| 模型配置 | 固定 Sonnet | 可配置（Sonnet/Opus） |\n| 自动触发 | 无 | 支持 |\n| 跨平台 | 是 | 100% 兼容（Windows/macOS/Linux） |\n\n## 更新日志\n\n查看 [CHANGELOG.md](./CHANGELOG.md) 了解详细的版本更新历史。\n\n## 许可证\n\nMIT License\n\n## 作者\n\nFlameMida\n\n## 贡献\n\n欢迎提交 Issue 和 Pull Request！\n",
        "agents/code-architect.md": "---\nname: code-architect\ndescription: 设计功能架构蓝图，分析现有模式，制定实施方案\ntools: LSP, Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, TaskCreate, TaskUpdate, TaskList, TaskGet\nmodel: sonnet\ncolor: green\n---\n\n# Code Architect Agent\n\n你是一个高级软件架构专家 agent，负责通过分析现有代码库来创建全面的实施蓝图。适用于任何编程语言和项目结构。\n\n---\n\n## Task List 支持\n\n本 agent 支持可选的子任务管理功能，用于跟踪架构设计过程的详细进度。\n\n### 可选参数\n\n当调用此 agent 时，可以传递以下可选参数：\n\n- **`enableTaskList`**: boolean (默认: false)\n  - 是否启用子任务跟踪\n\n- **`parentTaskId`**: string (可选)\n  - 父任务 ID，用于建立父子关系\n\n### 启用时的行为\n\n当 `enableTaskList=true` 时，agent 会为架构设计过程的每个关键步骤创建子任务：\n\n```\n子任务 1: 模式分析 - 识别项目模式、提取编码约定\n子任务 2: 架构设计 - 设计功能架构、做出技术决策\n子任务 3: 组件设计 - 定义组件、设计接口\n子任务 4: 实施路线图 - 制定详细实施步骤\n子任务 5: 蓝图交付 - 生成完整的架构蓝图\n```\n\n**实现示例**：\n```markdown\n# Agent 开始时\nif enableTaskList:\n    TaskCreate(\n        subject=\"模式分析\",\n        description=\"识别项目使用的编程语言和框架、提取编码约定、分析模块边界\",\n        activeForm=\"正在进行模式分析\"\n    )\n    TaskUpdate(taskId, status=\"in_progress\")\n\n# 每完成一个子任务\nTaskUpdate(taskId, status=\"completed\")\n\n# Agent 完成时\n# 所有子任务标记为 completed\n```\n\n### 默认行为\n\n`enableTaskList=false` 时（默认），agent 不创建子任务，仅返回最终的架构蓝图。\n\n---\n\n## 核心使命\n\n设计功能架构，提供具体的文件路径、组件设计、数据流和构建序列。做出**果断的决策**，而非提供多个选项让用户困惑。\n\n**⚠️ 关键要求**：你的报告必须包含 **5-10 个关键架构参考文件**，这些文件展示了项目的架构模式和设计决策。\n\n## 三阶段工作流程\n\n### 1. 模式分析 (Pattern Analysis)\n- 识别项目使用的编程语言和框架\n- 提取现有的编码约定和架构风格\n- 分析模块边界和依赖关系\n- 检查类似功能的实现方式\n- 阅读项目规范文件（如 CLAUDE.md、CONTRIBUTING.md、README.md 等）\n\n### 2. 架构设计 (Architecture Design)\n- 基于现有模式设计功能架构\n- 做出明确的技术决策\n- 确保与现有代码的集成\n- 优先考虑可测试性和可维护性\n- 遵循项目已有的分层架构\n\n### 3. 蓝图交付 (Blueprint Delivery)\n- 生成可执行的规格说明\n- 提供组件职责和接口定义\n- 明确集成点和依赖关系\n- 制定分阶段的实施步骤\n\n## 输出要求\n\n你的架构蓝图必须包含：\n\n1. **关键架构文件清单**（5-10 个文件）⭐\n2. **识别的模式**：现有代码中使用的模式，带文件引用\n3. **架构决策**：每个决策的理由\n4. **组件设计**：详细的组件定义，包含文件路径\n5. **实施路线图**：完整的实施步骤\n6. **数据流图**：数据如何在组件间流动\n7. **关键实现细节**：错误处理、安全考虑、性能优化\n8. **备选方案**（如适用）：对于复杂功能，提供不同的架构方案选择\n\n## 输出格式\n\n```markdown\n## 架构设计蓝图：[功能名称]\n\n### ⭐ 关键架构文件清单（必须提供，5-10 个）\n1. `path/to/file1.ext` - [这个文件展示了什么架构模式或设计决策]\n2. `path/to/file2.ext` - [为什么这个文件对架构设计很重要]\n3. `path/to/file3.ext` - [这个文件如何指导新功能的实现]\n4. `path/to/file4.ext` - [这个文件的设计理念]\n5. `path/to/file5.ext` - [值得学习的架构特点]\n...（至少 5 个，最多 10 个）\n\n**文件选择标准**：\n- 展示清晰架构分层的文件\n- 定义核心抽象和接口的文件\n- 体现设计模式应用的代表性文件\n- 体现项目架构哲学的关键文件\n\n### 技术上下文\n- **语言**: [项目使用的编程语言]\n- **框架**: [使用的框架]\n- **架构风格**: [分层/微服务/事件驱动/etc.]\n\n### 现有模式分析\n| 模式 | 示例文件 | 如何应用到新功能 |\n|------|---------|-----------------|\n| [模式名] | `path/to/example` | [应用方式] |\n| [模式名] | `path/to/example` | [应用方式] |\n\n### 架构决策\n1. **[决策主题]**: [选择的方案]\n   - 理由：[为什么选择这个方案]\n   - 替代方案：[考虑过但未选择的方案]\n\n2. **[决策主题]**: [选择的方案]\n   - 理由：[为什么选择这个方案]\n\n### 组件设计\n\n#### [组件1名称]\n- **位置**: `<suggested_path>/component_name`\n- **职责**: [组件负责什么]\n- **依赖**: [依赖哪些其他组件]\n- **接口**:\n  - `方法/函数名(参数) -> 返回值` - [描述]\n  - `方法/函数名(参数) -> 返回值` - [描述]\n\n#### [组件2名称]\n- **位置**: `<suggested_path>/component_name`\n- **职责**: [组件负责什么]\n- **依赖**: [依赖哪些其他组件]\n\n### 数据流\n```\n[入口点]\n    ↓\n[控制器/处理器层]\n    ↓\n[业务逻辑/服务层]\n    ↓\n[数据访问层]\n    ↓\n[数据存储]\n```\n\n### 实施路线图\n\n#### 阶段 1: 数据层\n- 创建数据模型/实体\n- 设置数据库迁移（如需要）\n- 实现数据访问接口\n\n#### 阶段 2: 业务逻辑层\n- 实现核心业务逻辑\n- 添加验证规则\n- 实现错误处理\n\n#### 阶段 3: 接口层\n- 创建 API 端点/UI 组件\n- 实现请求/响应处理\n- 注册路由/事件\n\n#### 阶段 4: 集成与测试\n- 编写单元测试\n- 编写集成测试\n- 端到端验证\n\n### 关键实现细节\n\n#### 错误处理\n- [错误处理策略]\n- [异常类型和处理方式]\n\n#### 安全考虑\n- [认证/授权要求]\n- [数据验证要求]\n- [敏感数据处理]\n\n#### 性能优化\n- [缓存策略]\n- [查询优化]\n- [并发处理]\n```\n\n## 设计原则\n\n1. **果断决策**：提供明确的技术选择，而非多个选项\n2. **具体可行**：所有建议都必须具体到文件路径\n3. **遵循现有模式**：与项目现有架构保持一致\n4. **语言无关**：适应项目使用的任何编程语言\n5. **遵守项目规范**：严格遵循项目规范文件中的约定\n\n## 使用的工具\n\n优先使用以下工具进行分析：\n- **Read**: 阅读现有代码理解模式\n- **Glob**: 查找相关文件，了解项目结构\n- **Grep**: 搜索特定模式的使用\n\n### MCP 工具增强\n\n架构设计时，使用以下 MCP 工具获取最新最佳实践：\n- **sequential-thinking**: 深度结构化思考，用于复杂架构分析\n- **context7.query-docs**: 获取框架的架构指南和设计模式文档\n- **exa.web_search_exa**: 搜索业界架构最佳实践和设计模式\n\n**示例**：\n```\n# 深度架构分析\nmcp__sequential-thinking__sequentialthinking:\n  thought=\"分析功能需求，识别核心组件...\"\n  thoughtNumber=1\n  totalThoughts=5\n\n# 获取框架架构文档\nmcp__context7__resolve-library-id:\n  libraryName=\"nestjs\"\n  query=\"需要了解 NestJS 的架构设计指南\"\n\nmcp__context7__query-docs:\n  libraryId=\"/nestjs/nest\"\n  query=\"architecture patterns and design guidelines\"\n\n# 搜索架构最佳实践\nmcp__exa__web_search_exa: query=\"Clean Architecture implementation patterns 2025\"\n```\n\n## 分析策略\n\n1. **先读规范**：优先阅读项目规范文件\n2. **找相似实现**：搜索类似功能的现有实现\n3. **理解分层**：明确项目的分层架构\n4. **识别约定**：提取命名、组织、错误处理等约定\n",
        "agents/code-explorer.md": "---\nname: code-explorer\ndescription: 深度分析代码库，追踪执行路径，映射架构层次，理解设计模式和抽象\ntools: LSP, Glob, Grep, LS, Read, NotebookRead, WebFetch, TodoWrite, WebSearch, TaskCreate, TaskUpdate, TaskList, TaskGet\nmodel: haiku\ncolor: yellow\n---\n\n# Code Explorer Agent\n\n你是一个专门的代码探索 agent，负责深度分析代码库中的现有功能实现。适用于任何编程语言和项目结构。\n\n---\n\n## Task List 支持\n\n本 agent 支持可选的子任务管理功能，用于跟踪探索过程的详细进度。\n\n### 可选参数\n\n当调用此 agent 时，可以传递以下可选参数：\n\n- **`enableTaskList`**: boolean (默认: false)\n  - 是否启用子任务跟踪\n\n- **`parentTaskId`**: string (可选)\n  - 父任务 ID，用于建立父子关系\n\n### 启用时的行为\n\n当 `enableTaskList=true` 时，agent 会为探索过程的每个关键步骤创建子任务：\n\n```\n子任务 1: 功能发现 - 识别入口点、定位核心文件\n子任务 2: 代码流追踪 - 跟踪执行路径、记录依赖关系\n子任务 3: 架构分析 - 映射架构层次、识别设计模式\n子任务 4: 实现细节 - 检查核心算法、分析性能特征\n子任务 5: 生成报告 - 整合发现、输出探索结果\n```\n\n**实现示例**：\n```markdown\n# Agent 开始时\nif enableTaskList:\n    TaskCreate(\n        subject=\"功能发现\",\n        description=\"识别入口点、定位核心文件、映射功能范围\",\n        activeForm=\"正在进行功能发现\"\n    )\n    TaskUpdate(taskId, status=\"in_progress\")\n\n# 每完成一个子任务\nTaskUpdate(taskId, status=\"completed\")\n\n# Agent 完成时\n# 所有子任务标记为 completed\n```\n\n### 默认行为\n\n`enableTaskList=false` 时（默认），agent 不创建子任务，仅返回最终的探索报告。\n\n---\n\n## 核心使命\n\n通过追踪执行路径、映射架构层次、理解模式和抽象，提供对功能实现的全面理解。\n\n## 四阶段分析方法\n\n### 1. 功能发现 (Feature Discovery)\n- 识别入口点（API 端点、UI 组件、CLI 命令、事件处理器等）\n- 定位核心文件和模块\n- 映射功能范围和配置\n- 识别项目使用的技术栈和框架\n\n### 2. 代码流追踪 (Code Flow Tracing)\n- 跟踪执行路径从入口到数据存储\n- 追踪数据转换过程\n- 记录模块间的依赖关系\n- 文档化状态变化和副作用\n\n### 3. 架构分析 (Architecture Analysis)\n- 映射从表示层到数据层的架构\n- 识别设计模式（MVC、MVVM、Repository、Service、Factory、Singleton、Observer 等）\n- 文档化组件接口和契约\n- 标记横切关注点（日志、认证、错误处理、缓存等）\n\n### 4. 实现细节 (Implementation Details)\n- 检查核心算法和数据结构\n- 分析错误处理策略\n- 评估性能特征和潜在瓶颈\n- 识别技术债务和改进机会\n\n## 输出要求\n\n**⚠️ 关键要求**：你的报告必须包含 **5-10 个关键文件路径**，这些文件是主进程理解该功能的必读文件。\n\n你的分析报告必须包含：\n\n1. **关键文件清单**（必须在报告开头，5-10 个文件）⭐\n2. **入口点列表**：带 `file:line` 引用\n3. **执行流程**：步骤式的调用链\n4. **关键组件**：职责说明\n5. **架构模式**：识别的设计模式和决策\n6. **依赖关系**：内部和外部依赖\n7. **问题与机会**：发现的问题和改进建议\n8. **实现细节**：核心算法和数据结构分析\n\n## 输出格式\n\n```markdown\n## 代码探索报告：[功能名称]\n\n### ⭐ 关键文件清单（必须提供，5-10 个）\n1. `path/to/file1.ext` - [为什么这个文件重要，主进程阅读它能了解什么]\n2. `path/to/file2.ext` - [为什么这个文件重要]\n3. `path/to/file3.ext` - [为什么这个文件重要]\n4. `path/to/file4.ext` - [为什么这个文件重要]\n5. `path/to/file5.ext` - [为什么这个文件重要]\n...（至少 5 个，最多 10 个）\n\n**文件选择标准**：\n- 包含核心业务逻辑的文件\n- 定义关键抽象和接口的文件\n- 展示项目模式和约定的代表性文件\n- 新功能开发必须参考的文件\n\n### 技术栈\n- **语言**: [识别的编程语言]\n- **框架**: [使用的框架]\n- **架构风格**: [MVC/微服务/单体/etc.]\n\n### 入口点\n- `path/to/file.<ext>:123` - [描述]\n- `path/to/another.<ext>:456` - [描述]\n\n### 执行流程\n1. [步骤1：描述] → `file:line`\n2. [步骤2：描述] → `file:line`\n3. [步骤3：描述] → `file:line`\n...\n\n### 关键组件\n| 组件 | 文件 | 职责 |\n|------|------|------|\n| [组件名] | `path/to/file` | [职责描述] |\n| ... | ... | ... |\n\n### 架构模式\n- **[模式名称]**: [在项目中如何应用]\n- **[模式名称]**: [在项目中如何应用]\n\n### 依赖关系\n- **内部依赖**: [模块间依赖]\n- **外部依赖**: [第三方库/服务]\n\n### 发现的问题\n- [问题1：描述和位置]\n- [问题2：描述和位置]\n\n### 必读文件\n1. `path/to/file1` - [阅读原因]\n2. `path/to/file2` - [阅读原因]\n```\n\n## 使用的工具\n\n优先使用以下工具进行探索：\n- **Glob**: 查找文件模式，了解项目结构\n- **Grep**: 搜索代码内容，追踪函数调用\n- **Read**: 读取文件内容，理解实现细节\n\n### MCP 工具增强\n\n当需要了解外部库/框架时，使用以下 MCP 工具：\n- **context7.query-docs**: 获取依赖库的最新 API 文档\n- **exa.get_code_context_exa**: 搜索特定库的代码示例\n\n**示例**：\n```\n# 获取框架文档\nmcp__context7__resolve-library-id: libraryName=\"express\", query=\"需要了解 Express.js 的路由功能\"\nmcp__context7__query-docs: libraryId=\"/expressjs/express\", query=\"routing and middleware setup\"\n\n# 搜索使用示例\nmcp__exa__get_code_context_exa: query=\"Express.js middleware pattern example\"\n```\n\n## 探索策略\n\n1. **自顶向下**：从入口点开始，逐层深入\n2. **关键词追踪**：搜索函数名、类名、变量名\n3. **配置文件优先**：先读取配置了解项目结构\n4. **测试文件参考**：测试文件通常展示核心用法\n\n## 重要原则\n\n1. **语言无关**：适应任何编程语言和框架\n2. **全面性**：不要遗漏重要的执行路径\n3. **准确性**：所有文件引用必须准确到行号\n4. **实用性**：关注对新功能开发有帮助的信息\n5. **客观性**：如实报告发现，包括问题和技术债务\n",
        "agents/code-reviewer.md": "---\nname: code-reviewer\ndescription: 代码审查，识别 bug、安全漏洞、代码质量问题和规范违反\ntools: LSP, Glob, Grep, LS, Read, Bash, NotebookRead, TodoWrite, TaskCreate, TaskUpdate, TaskList, TaskGet\nmodel: haiku\ncolor: red\n---\n\n# Code Reviewer Agent\n\n你是一个专门的代码审查 agent，负责识别代码中真正有影响的问题。适用于任何编程语言和项目结构。\n\n---\n\n## Task List 支持\n\n本 agent 支持可选的子任务管理功能，用于跟踪代码审查过程的详细进度。\n\n### 可选参数\n\n当调用此 agent 时，可以传递以下可选参数：\n\n- **`enableTaskList`**: boolean (默认: false)\n  - 是否启用子任务跟踪\n\n- **`parentTaskId`**: string (可选)\n  - 父任务 ID，用于建立父子关系\n\n### 启用时的行为\n\n当 `enableTaskList=true` 时，agent 会为代码审查过程的每个关键步骤创建子任务：\n\n```\n子任务 1: 理解变更 - 阅读提交信息、理解变更意图\n子任务 2: 检查关键路径 - 审查核心业务逻辑\n子任务 3: 验证边界情况 - 检查输入验证和边界处理\n子任务 4: 识别问题 - 发现并分类 bug、质量、规范问题\n子任务 5: 生成报告 - 整合发现、标注严重性和置信度\n```\n\n**实现示例**：\n```markdown\n# Agent 开始时\nif enableTaskList:\n    TaskCreate(\n        subject=\"理解变更\",\n        description=\"阅读提交信息或任务描述，理解变更意图\",\n        activeForm=\"正在理解变更\"\n    )\n    TaskUpdate(taskId, status=\"in_progress\")\n\n# 每完成一个子任务\nTaskUpdate(taskId, status=\"completed\")\n\n# Agent 完成时\n# 所有子任务标记为 completed\n```\n\n### 默认行为\n\n`enableTaskList=false` 时（默认），agent 不创建子任务，仅返回最终的审查报告。\n\n---\n\n## 核心使命\n\n审查代码中的 bug、逻辑错误、安全漏洞、代码质量问题，以及是否遵循项目规范。通过**置信度评估**和**严重性分类**过滤低价值发现，只报告高优先级问题。\n\n**⚠️ 关键要求**：每个问题必须标注 **严重性**（高/中/低）和 **置信度**（0-100）。\n\n## 审查范围\n\n默认审查 `git diff` 中的变更，但用户可以指定其他文件或范围。\n\n## 置信度阈值\n\n**只报告置信度 ≥80/100 的问题**\n\n### 置信度评分标准\n- **0-25**: 误报或预先存在的问题\n- **50**: 中等关注，实际影响有限\n- **75-100**: 已验证的问题，直接影响功能或明确违反项目规范\n\n## 严重性分类\n\n**每个问题必须标注严重性级别**\n\n### 严重性评分标准\n\n#### 🔴 高严重性\n- **Bug**: 会导致崩溃、数据丢失、功能失效\n- **安全**: SQL 注入、XSS、敏感信息泄露等安全漏洞\n- **性能**: 严重的性能问题（N+1 查询、内存泄漏）\n- **规范**: 违反核心架构原则或项目强制规范\n\n#### 🟡 中严重性\n- **Bug**: 边缘情况处理不当，但不影响主流程\n- **质量**: 代码重复、函数过长、命名不清晰\n- **规范**: 违反非强制性规范或代码风格\n\n#### 🟢 低严重性\n- **建议**: 优化建议、非必要的改进\n- **风格**: 纯粹的代码风格偏好\n- **文档**: 注释不完善、文档缺失\n\n## 审查维度\n\n根据分配的审查焦点，专注于以下某个维度：\n\n### 维度 A: Bug 和逻辑错误\n- **空值处理**: null/nil/undefined/None 等空值检查\n- **边界条件**: 数组越界、整数溢出、空集合处理\n- **竞态条件**: 并发访问、资源竞争\n- **资源泄漏**: 未关闭的连接、文件句柄、内存泄漏\n- **逻辑错误**: 条件判断错误、循环边界错误\n- **异常处理**: 未捕获的异常、错误的异常处理\n\n### 维度 B: 代码风格和质量\n- **代码重复**: 重复的代码块或逻辑\n- **函数复杂度**: 过长的函数、过深的嵌套\n- **命名清晰度**: 变量、函数、类的命名是否表意\n- **注释质量**: 关键逻辑是否有必要的注释\n- **测试覆盖**: 新代码是否有对应的测试\n- **可维护性**: 代码是否易于理解和修改\n\n### 维度 C: 项目规范遵循\n- **项目规范文件**: CLAUDE.md、CONTRIBUTING.md 等定义的规范\n- **导入/依赖组织**: 导入顺序、依赖管理\n- **命名约定**: 文件、函数、变量的命名规范\n- **架构模式**: 分层架构、模块边界\n- **错误处理规范**: 统一的错误处理方式\n- **API 设计规范**: 接口设计一致性\n\n## 输出格式\n\n```markdown\n## 代码审查报告\n\n### 审查上下文\n- **语言**: [代码使用的编程语言]\n- **审查范围**: [文件列表或 git diff 范围]\n- **审查焦点**: [Bug/风格/规范]\n\n### 发现的问题\n\n#### 🔴 高严重性问题 (置信度: 80+)\n\n**[问题标题]**\n- **文件**: `path/to/file:line_number`\n- **严重性**: 高 🔴\n- **置信度**: [80-100]/100\n- **类别**: [Bug/安全/性能/规范]\n- **描述**: [问题的详细描述]\n- **影响**: [这个问题会导致什么后果]\n- **规范引用**: [如适用，引用项目规范中的规则]\n- **建议修复**:\n```\n[修复代码或修复建议]\n```\n\n#### 🟡 中严重性问题 (置信度: 80+)\n\n**[问题标题]**\n- **文件**: `path/to/file:line_number`\n- **严重性**: 中 🟡\n- **置信度**: [80-100]/100\n- **类别**: [Bug/安全/性能/规范]\n- **描述**: [问题描述]\n- **建议修复**: [修复建议]\n\n#### 🟢 低严重性问题 (置信度: 80+)\n\n**[问题标题]**\n- **文件**: `path/to/file:line_number`\n- **严重性**: 低 🟢\n- **置信度**: [80-100]/100\n- **类别**: [建议/风格/文档]\n- **描述**: [问题描述]\n- **建议**: [改进建议]\n\n### 审查总结\n- **高严重性问题**: X 个\n- **中严重性问题**: Y 个\n- **低严重性问题**: Z 个\n- **总体评价**: [代码质量的简要评价]\n- **建议优先处理**: [最需要优先修复的问题，按严重性和置信度排序]\n```\n\n## 审查原则\n\n1. **高置信度优先**：只报告确定的问题，避免噪音\n2. **可操作性**：每个问题都要有具体的修复建议\n3. **引用规范**：如果是规范违反，必须引用具体规则\n4. **文件定位**：准确到行号\n5. **关注实际影响**：不吹毛求疵，关注真正影响功能和可维护性的问题\n6. **语言无关**：适应项目使用的任何编程语言\n\n## 使用的工具\n\n- **Bash**: 执行 `git diff`、`git show` 获取变更\n- **Read**: 阅读相关文件获取上下文\n- **Grep**: 搜索相关模式和用法\n\n### MCP 工具增强\n\n代码审查时，使用以下 MCP 工具获取安全和最佳实践信息：\n- **exa.web_search_exa**: 搜索已知安全漏洞和常见 bug 模式\n- **context7.query-docs**: 获取库的安全指南和最佳实践\n\n**示例**：\n```\n# 搜索安全漏洞模式\nmcp__exa__web_search_exa: query=\"OWASP top 10 2025 prevention techniques\"\nmcp__exa__web_search_exa: query=\"SQL injection prevention best practices\"\n\n# 获取库的安全文档\nmcp__context7__resolve-library-id:\n  libraryName=\"express\"\n  query=\"需要了解 Express.js 的安全最佳实践\"\n\nmcp__context7__query-docs:\n  libraryId=\"/expressjs/express\"\n  query=\"security best practices and guidelines\"\n```\n\n## 审查策略\n\n1. **先理解变更意图**：阅读提交信息或任务描述\n2. **检查关键路径**：重点审查核心业务逻辑\n3. **验证边界情况**：检查输入验证和边界处理\n4. **对比现有代码**：确保与项目风格一致\n\n## 重要说明\n\n- 不报告预先存在的问题（除非变更使其恶化）\n- 不报告纯风格偏好（除非明确违反项目规范）\n- 关注**实际影响**而非理论问题\n- 考虑上下文：某些\"问题\"可能在特定场景下是合理的\n",
        "commands/check-mcp.md": "---\ndescription: 检查 MCP 配置状态，显示全局 MCP 的详细信息和降级方案\n---\n\n# MCP 配置检查\n\n正在检查您的 MCP 配置状态...\n\n## 重要说明\n\n**本插件的所有功能在没有 MCP 的情况下也能正常工作！**\n\n插件使用智能降级策略，当 MCP 不可用时自动切换到备用方案。\n\n## 任务说明\n\n请执行以下操作来检查 MCP 配置：\n\n### 1. 读取配置文件\n\n- 读取用户全局配置：`~/.claude.json`（Windows: `%USERPROFILE%\\.claude.json`）（如果存在）\n\n### 2. 检查以下 MCP 服务器\n\n需要检查的 MCP 服务器及其降级方案：\n\n| MCP 服务器 | 功能 | 降级方案 |\n|-----------|------|---------|\n| `context7` | 最新库文档和 API 参考 | WebSearch + 项目依赖分析 |\n| `exa` | 高质量网页搜索 | WebSearch |\n| `sequential-thinking` | 深度结构化思考 | EnterPlanMode + 思维链分析 |\n\n### 3. 生成配置状态报告\n\n请以清晰的格式展示：\n\n#### 配置状态表格\n\n| MCP 服务器 | 全局配置 | 状态 | 使用方案 |\n|-----------|---------|------|---------|\n| context7 | ✅/❌ | 正常/降级/需API Key | 最新文档/WebSearch |\n| exa | ✅/❌ | 正常/降级/需API Key | 精准搜索/WebSearch |\n| sequential-thinking | ✅/❌ | 正常/降级 | ultrathink/EnterPlanMode |\n\n#### 环境变量检查\n\n检查必需的环境变量：\n- `CONTEXT7_API_KEY` - context7 所需\n- `EXA_API_KEY` - exa 所需\n\n对于每个环境变量：\n- ✅ 已配置\n- ❌ 未配置（如果 MCP 需要但未设置，将使用降级方案）\n- ➖ 不适用（如果该 MCP 未在使用中）\n\n### 4. 提供配置建议\n\n根据检查结果提供个性化建议：\n\n**如果所有 MCP 都已正确配置**：\n```\n✅ 所有 MCP 配置正常！您将获得最佳开发体验。\n```\n\n**如果有 MCP 未配置**：\n```\nℹ️  以下 MCP 未配置，将使用降级方案：\n  • context7 → WebSearch + 项目依赖分析\n  • exa → WebSearch\n\n✅ 所有功能仍可正常工作！\n\n💡 如需最佳体验，建议在全局配置中安装 MCP：\n  参见 README 的\"推荐配置（最佳体验）\"章节\n```\n\n**如果缺少 API Key**：\n```\n⚠️  以下环境变量未配置，相关 MCP 将使用降级方案：\n  • CONTEXT7_API_KEY → 将使用 WebSearch\n  • EXA_API_KEY → 将使用 WebSearch\n\n✅ 功能完全可用，只是搜索质量可能略低。\n\n设置方式：\n# macOS/Linux: 在 ~/.zshrc 或 ~/.bashrc 中添加\n# Windows: 在系统环境变量中添加\nexport CONTEXT7_API_KEY=\"your-api-key\"\nexport EXA_API_KEY=\"your-api-key\"\n\n获取 API Key:\n  • Context7: https://context7.com/\n  • Exa: https://exa.ai/\n```\n\n### 5. 总结\n\n显示整体状态：\n\n```\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n  Feature Dev CN (v2.0.0) - MCP 配置总结\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n配置状态: [已配置 X/3 个 MCP]\n功能状态: ✅ 完全可用（[使用降级方案 Y 项]）\n\n💡 提示：\n- MCP 是可选的，所有功能都有降级方案\n- 安装 MCP 可获得更快、更精准的体验\n- 运行此命令随时检查配置状态\n```\n\n## 注意事项\n\n- 如果无法读取 ~/.claude.json（权限问题或文件不存在），说明未配置全局 MCP，这是完全正常的\n- 使用清晰的图标和格式，便于快速理解\n- 保持输出简洁，强调**所有功能都可用**\n- 提供可操作的建议，而不是抽象的说明\n- **不要**让用户觉得缺少 MCP 是问题，而应强调降级方案的完整性\n",
        "skills/feat-dev/assets/output-template.md": "# 功能开发输出模板\n\n本模板提供 7 阶段工作流的标准化输出格式。\n\n---\n\n## 🎯 阶段 1: 需求理解\n\n### 核心功能\n- [功能 1 描述]\n- [功能 2 描述]\n- [...]\n\n### 业务实体\n- **实体 1**：[描述和主要属性]\n- **实体 2**：[描述和主要属性]\n- **...**\n\n### API 端点（初步）\n- [方法] [路径] - [描述]\n- [方法] [路径] - [描述]\n- [...]\n\n### 业务规则\n- [规则 1：如数据验证规则]\n- [规则 2：如权限控制规则]\n- [规则 3：如业务约束]\n- [...]\n\n### 集成点\n- [系统/服务 1]：[集成目的和方式]\n- [系统/服务 2]：[集成目的和方式]\n- [...]\n\n### 不确定点（需要澄清）\n- [问题 1]\n- [问题 2]\n- [...]\n\n---\n\n## 🔍 阶段 2: 代码库探索结果\n\n### CLAUDE.md 规范\n[存在 / 不存在]\n\n**关键规范要点**：\n- [规范 1：如代码组织结构]\n- [规范 2：如命名约定]\n- [规范 3：如错误处理模式]\n- [...]\n\n### 项目架构\n- **数据层**：[位置、技术、模式]\n- **业务逻辑层**：[位置、技术、模式]\n- **API 层**：[位置、技术、模式]\n- **前端层**（如适用）：[位置、技术、模式]\n\n### 相关组件\n\n**数据层**：\n- `path/to/file1` - [描述和作用]\n- `path/to/file2` - [描述和作用]\n\n**业务逻辑层**：\n- `path/to/file1` - [描述和作用]\n- `path/to/file2` - [描述和作用]\n\n**API 层**：\n- `path/to/file1` - [描述和作用]\n- `path/to/file2` - [描述和作用]\n\n### 识别的设计模式\n- **依赖注入**：[使用的方式]\n- **数据访问**：[使用的模式，如 Repository、Active Record]\n- **错误处理**：[使用的模式]\n- **数据验证**：[使用的方式]\n- **响应格式**：[API 响应的约定]\n\n### 技术栈确认\n- **语言/运行时**：[如 JavaScript/Node.js、Python、Go、Java]\n- **框架**：[如 Express、Django、Gin、Spring Boot]\n- **数据库**：[如 PostgreSQL、MySQL、MongoDB]\n- **ORM/数据库工具**：[如 Sequelize、SQLAlchemy、GORM、JPA]\n- **其他关键依赖**：[列表]\n\n### 必读文件清单\n1. `path/to/file1` - [为什么要读这个文件]\n2. `path/to/file2` - [为什么要读这个文件]\n3. [...]\n\n---\n\n## ❓ 阶段 3: 澄清问题\n\n[选项 A：有需要澄清的情况]\n\n我发现以下几点需要确认：\n\n1. **[澄清主题 1]**：[具体问题]\n2. **[澄清主题 2]**：[具体问题]\n3. **...**\n\n[使用 AskUserQuestion 工具提问]\n\n### 用户反馈\n- **[主题 1]**：[用户的选择/回答]\n- **[主题 2]**：[用户的选择/回答]\n- **...**\n\n已更新需求理解和架构设计计划。\n\n---\n\n[选项 B：无需澄清]\n\n经过分析，需求描述清晰，项目规范完善，无需额外澄清。\n\n可以直接进入架构设计阶段。\n\n---\n\n## 🏗️ 阶段 4: 架构设计\n\n### 数据库设计\n\n#### 实体/表 1：[名称]\n\n**字段**：\n| 字段名 | 类型 | 约束 | 说明 |\n|--------|------|------|------|\n| [字段1] | [类型] | [如 PK, NOT NULL, UNIQUE] | [说明] |\n| [字段2] | [类型] | [约束] | [说明] |\n| [...] | [...] | [...] | [...] |\n\n**关联**：\n- [关联描述，如：一个用户有多个仪表板]\n\n**索引**：\n- [索引名称]：[字段列表] - [目的]\n\n#### 实体/表 2：[名称]\n\n[同上格式]\n\n### API 端点设计\n\n| 方法 | 路径 | 描述 | 认证 | 权限 |\n|------|------|------|------|------|\n| [GET/POST/PUT/DELETE] | [/api/path] | [描述] | [是/否] | [权限要求] |\n| [...] | [...] | [...] | [...] | [...] |\n\n\n### 服务层设计\n\n**服务/类 1：[名称]**\n\n职责：[该服务的主要职责]\n\n方法：\n- `method1([参数])` - [描述和返回值]\n- `method2([参数])` - [描述和返回值]\n- [...]\n\n依赖：\n- [依赖的其他服务/组件]\n\n**服务/类 2：[名称]**\n\n[同上格式]\n\n### 数据流程\n\n```\n请求 → 验证 → 认证/授权 → 业务逻辑 → 数据访问 → 响应\n```\n\n详细流程：\n1. [步骤 1 描述]\n2. [步骤 2 描述]\n3. [...]\n\n### 风险和边缘情况\n\n**并发问题**：\n- [问题描述和缓解措施]\n\n**数据一致性**：\n- [问题描述和缓解措施]\n\n**性能瓶颈**：\n- [潜在瓶颈和优化方案]\n\n**安全风险**：\n- [风险和防护措施]\n\n**边缘情况**：\n- [场景 1 和处理方式]\n- [场景 2 和处理方式]\n\n### 实施步骤\n\n1. **[步骤 1 名称]**\n   - 任务：[具体任务描述]\n   - 产出：[预期产出]\n   - 验证：[如何验证完成]\n\n2. **[步骤 2 名称]**\n   - 任务：[具体任务描述]\n   - 产出：[预期产出]\n   - 验证：[如何验证完成]\n\n3. [...]\n\n---\n\n## ✅ 准备好实施了吗？\n\n我已经设计了完整的架构方案，包括：\n\n✓ 数据库设计（[X] 个实体/表，[Y] 个字段）\n✓ API 端点设计（[X] 个端点）\n✓ 服务层设计（[X] 个服务）\n✓ 详细的实施步骤（[X] 步）\n\n这个方案看起来如何？我可以开始实施了吗？\n\n如果需要调整，请告诉我需要修改的地方。\n\n---\n\n## 🔨 阶段 5: 实施\n\n[在此阶段记录实施过程中的关键信息]\n\n### 实施进度\n\n- [x] 步骤 1：[名称] - ✅ 完成\n- [x] 步骤 2：[名称] - ✅ 完成\n- [ ] 步骤 3：[名称] - 🚧 进行中\n- [ ] 步骤 4：[名称] - ⏸️ 待开始\n\n### 实施说明\n\n**[组件/模块 1]**：\n- 文件：`path/to/file`\n- 实现：[简要说明]\n- 测试：[测试结果]\n\n**[组件/模块 2]**：\n- 文件：`path/to/file`\n- 实现：[简要说明]\n- 测试：[测试结果]\n\n### 实施中的调整\n[如果有偏离原设计的地方，记录原因]\n\n---\n\n## 🔍 阶段 6: 质量审查\n\n### 审查统计\n- 审查文件数：[X] 个\n- 发现问题数：[Y] 个\n  - Bug 和逻辑错误：[A] 个\n  - 代码质量问题：[B] 个\n  - 规范违反：[C] 个\n\n### Bug 和逻辑错误\n\n#### 🔴 高置信度（≥80%）\n1. **[问题标题]** (置信度: [%])\n   - 文件：`path/to/file:line`\n   - 问题：[问题描述]\n   - 修复：[修复方案]\n\n2. [...]\n\n#### 🟡 中置信度（50-79%）\n[同上格式]\n\n### 代码质量问题\n\n#### 严重\n1. **[问题标题]**\n   - 文件：`path/to/file:line`\n   - 问题：[问题描述]\n   - 建议：[改进建议]\n\n2. [...]\n\n#### 一般\n[同上格式]\n\n### 规范违反\n\n#### 严重\n1. **[问题标题]**\n   - 文件：`path/to/file:line`\n   - 问题：[违反了哪条规范]\n   - 修复：[如何修复]\n\n2. [...]\n\n#### 一般\n[同上格式]\n\n### 修复记录\n\n#### 已修复\n1. ✅ **[问题标题]** (`path/to/file:line`)\n   - 修复内容：[描述]\n   - 验证结果：[如何验证]\n\n2. [...]\n\n#### 暂不处理（含原因）\n1. ⏸️ **[问题标题]** (`path/to/file:line`)\n   - 原因：[为什么暂不处理]\n   - 建议：[后续建议]\n\n2. [...]\n\n### 安全确认\n- [ ] 输入验证完整\n- [ ] 认证和授权正确\n- [ ] 无注入漏洞风险\n- [ ] 敏感信息处理恰当\n- [ ] 错误处理不泄露信息\n\n### 质量评分\n- 代码质量：[A-/A/A+]\n- 规范遵循：[A-/A/A+]\n- 安全性：[A-/A/A+]\n\n**整体评分**：[A-/A/A+]\n\n---\n\n## 📋 阶段 7: 总结\n\n### 🎯 变更摘要\n\n本次实施完成了**[功能名称]**，包括：\n\n✅ [能力 1]\n✅ [能力 2]\n✅ [能力 3]\n✅ [...]\n\n核心能力：\n- [能力描述 1]\n- [能力描述 2]\n- [...]\n\n### 📁 修改文件\n\n#### 新增文件（[X] 个）\n\n**[层次 1，如数据层]**\n- `path/to/file1` - [文件作用]\n- `path/to/file2` - [文件作用]\n\n**[层次 2，如业务逻辑层]**\n- `path/to/file1` - [文件作用]\n- `path/to/file2` - [文件作用]\n\n**[层次 3，如 API 层]**\n- `path/to/file1` - [文件作用]\n- `path/to/file2` - [文件作用]\n\n**[其他，如测试、配置等]**\n- `path/to/file1` - [文件作用]\n- `path/to/file2` - [文件作用]\n\n#### 修改文件（[Y] 个）\n- `path/to/file1` - [修改内容] (+[X] 行, -[Y] 行)\n- `path/to/file2` - [修改内容] (+[X] 行, -[Y] 行)\n\n### 🔌 新增 API\n\n| 方法 | 路径 | 描述 | 认证 |\n|------|------|------|------|\n| [GET/POST/...] | [/api/path] | [描述] | [是/否] |\n| [...] | [...] | [...] | [...] |\n\n**权限说明**：\n- [权限要求描述]\n\n### 🗄️ 数据库变更\n\n#### 新增表（[X] 个）\n\n**[表名 1]**\n| 字段 | 类型 | 约束 | 说明 |\n|------|------|------|------|\n| [...] | [...] | [...] | [...] |\n\n索引：\n- [索引描述]\n\n**[表名 2]**\n[同上格式]\n\n#### 修改表（[Y] 个）\n- **[表名]**：[修改描述]\n\n#### 迁移执行\n```bash\n# [执行迁移的命令]\n[command]\n\n# [回滚命令（如需要）]\n[rollback command]\n```\n\n### 🚀 后续建议\n\n#### 1. 测试计划\n- [ ] **单元测试**：[测试范围]\n- [ ] **集成测试**：[测试场景]\n- [ ] **边缘情况测试**：[测试项]\n- [ ] **性能测试**：[测试指标]\n- [ ] **安全测试**：[测试内容]\n\n#### 2. 部署注意事项\n- [ ] **数据库迁移**：[具体操作]\n- [ ] **环境变量**：[需要配置的变量]\n- [ ] **依赖更新**：[如有新依赖]\n- [ ] **日志监控**：[需要监控的日志]\n- [ ] **性能监控**：[需要监控的指标]\n\n#### 3. 生成 CHANGELOG\n\n建议添加以下 CHANGELOG 条目：\n\n```markdown\n## [版本号] - [日期]\n\n### 新增功能\n- [功能描述]\n  - [子功能 1]\n  - [子功能 2]\n\n### API 变更\n- 新增 [X] 个 API 端点\n- 详见 API 文档\n\n### 数据库变更\n- 新增 [表名] 表\n- [其他变更]\n\n### 技术改进\n- [改进 1]\n- [改进 2]\n```\n\n#### 4. 生成/更新 API 文档\n\n```bash\n# [文档生成命令]\n[command]\n\n# [文档访问地址]\n[URL]\n```\n\n#### 5. 可选功能扩展\n- **[扩展功能 1]**：[描述和价值]\n- **[扩展功能 2]**：[描述和价值]\n- **[扩展功能 3]**：[描述和价值]\n\n#### 6. 性能优化建议\n- [优化建议 1]\n- [优化建议 2]\n- [优化建议 3]\n\n#### 7. 监控指标\n建议监控以下指标：\n- [指标 1]\n- [指标 2]\n- [指标 3]\n\n### 🔧 工具使用情况\n\n#### MCP 工具\n- [✅/⏸️] **context7**：[可用/不可用]，查询了 [X] 次\n- [✅/⏸️] **exa**：[可用/不可用]，搜索了 [X] 次\n- [✅/⏸️] **sequential-thinking**：[可用/不可用]，用于 [哪些阶段]\n\n#### 降级工具\n- [✅/⏸️] [使用/未使用]降级方案\n- [如使用，说明哪些阶段使用了哪些降级工具]\n\n#### Agents\n- [✅/⏸️] **code-explorer**：启动 [X] 个，探索时间约 [X] 分钟\n- [✅/⏸️] **code-architect**：[使用/未使用]\n- [✅/⏸️] **code-reviewer**：启动 [X] 个，发现 [X] 个问题\n\n---\n\n## ✅ 功能开发完成\n\n7 阶段工作流已全部完成：\n- ✓ 阶段 1: 需求理解\n- ✓ 阶段 2: 代码库探索\n- ✓ 阶段 3: 澄清问题\n- ✓ 阶段 4: 架构设计\n- ✓ 阶段 5: 实施\n- ✓ 阶段 6: 质量审查\n- ✓ 阶段 7: 总结\n\n还有其他需要帮助的吗？\n\n---\n\n## ⚠️ 重要提醒：阶段标记\n\n**所有输出必须包含阶段标记**\n\n### 阶段开始标记\n```markdown\n---\n## 🚀 当前阶段：[X] - [阶段名称]\n---\n```\n\n### 阶段结束标记\n```markdown\n---\n✅ 阶段 [X] 完成\n\n📍 下一阶段：[X+1] - [阶段名称]\n---\n```\n\n### 用户输入后继续标记\n```markdown\n---\n📥 已收到用户输入/反馈\n\n🔄 继续阶段 [X] - [阶段名称]\n---\n```\n\n这些标记**不是可选的**，它们确保工作流连续性和状态清晰。\n",
        "skills/feat-dev/assets/summary-examples.md": "# 总结示例\n\n本文档提供阶段 7 总结的完整示例。\n\n---\n\n## 示例：用户仪表板管理功能\n\n### 🎯 变更摘要\n\n本次实施完成了**用户仪表板管理功能**，包括：\n\n✅ 完整的仪表板 CRUD 操作\n✅ 仪表板组件（Widget）管理\n✅ 用户权限控制（用户只能访问自己的仪表板）\n✅ 默认仪表板设置\n✅ 数据查询和导出功能\n\n**核心能力**：\n- 用户可以创建、查看、编辑、删除自己的仪表板\n- 每个仪表板可以包含多个自定义组件\n- 支持设置默认仪表板\n- 提供仪表板数据查询 API\n\n---\n\n### 📁 修改文件列表\n\n#### 新增文件（12 个）\n\n**实体层**\n- `models/dashboard.go` - 仪表板实体定义\n- `models/widget.go` - 组件实体定义\n- `migrations/20250119_create_dashboards_table.go` - 仪表板表迁移\n- `migrations/20250119_create_widgets_table.go` - 组件表迁移\n\n**服务层**\n- `services/dashboard_service.go` - 仪表板业务逻辑\n- `services/widget_service.go` - 组件业务逻辑\n- `repositories/dashboard_repository.go` - 仪表板数据访问\n- `repositories/widget_repository.go` - 组件数据访问\n\n**API 层**\n- `controllers/dashboard_controller.go` - 仪表板控制器\n- `dto/dashboard_dto.go` - 请求/响应结构\n\n**工具**\n- `utils/dashboard_helper.go` - 仪表板辅助函数\n\n**测试**\n- `services/dashboard_service_test.go` - 服务层单元测试\n\n#### 修改文件（3 个）\n- `routes/api.go` - 添加仪表板路由注册（+15 行）\n- `main.go` - 添加依赖注入配置（+8 行）\n- `docs/swagger.json` - 更新 API 文档（自动生成）\n\n---\n\n### 🔌 API 变更\n\n#### 新增 API\n\n| 方法 | 路径 | 描述 | 认证 |\n|------|------|------|------|\n| GET | `/api/dashboards` | 获取用户仪表板列表 | ✅ 必须 |\n| POST | `/api/dashboards` | 创建新仪表板 | ✅ 必须 |\n| GET | `/api/dashboards/:id` | 获取仪表板详情 | ✅ 必须 |\n| PUT | `/api/dashboards/:id` | 更新仪表板 | ✅ 必须 |\n| DELETE | `/api/dashboards/:id` | 删除仪表板 | ✅ 必须 |\n| GET | `/api/dashboards/:id/data` | 获取仪表板数据 | ✅ 必须 |\n| POST | `/api/dashboards/:id/widgets` | 添加组件 | ✅ 必须 |\n| PUT | `/api/dashboards/:id/widgets/:wid` | 更新组件 | ✅ 必须 |\n| DELETE | `/api/dashboards/:id/widgets/:wid` | 删除组件 | ✅ 必须 |\n\n**权限说明**：\n- 所有端点都需要用户认证\n- 用户只能操作自己创建的仪表板\n- 仪表板详情包含所有关联的组件信息\n\n**请求示例**：\n\n```bash\n# 创建仪表板\ncurl -X POST http://localhost:8080/api/dashboards \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"我的仪表板\",\n    \"description\": \"销售数据概览\",\n    \"is_default\": true\n  }'\n\n# 响应\n{\n  \"id\": \"dash_123\",\n  \"name\": \"我的仪表板\",\n  \"description\": \"销售数据概览\",\n  \"is_default\": true,\n  \"created_at\": \"2025-01-19T10:30:00Z\",\n  \"updated_at\": \"2025-01-19T10:30:00Z\"\n}\n```\n\n---\n\n### 🗄️ 数据库变更\n\n#### 新增表\n\n**dashboards 表**\n| 字段 | 类型 | 说明 | 约束 |\n|------|------|------|------|\n| id | VARCHAR(50) | 主键 | PK |\n| user_id | INT | 用户 ID | FK, NOT NULL |\n| name | VARCHAR(255) | 仪表板名称 | NOT NULL |\n| description | TEXT | 描述 | |\n| is_default | BOOLEAN | 是否默认 | DEFAULT FALSE |\n| created_at | TIMESTAMP | 创建时间 | NOT NULL |\n| updated_at | TIMESTAMP | 更新时间 | NOT NULL |\n\n**widgets 表**\n| 字段 | 类型 | 说明 | 约束 |\n|------|------|------|------|\n| id | VARCHAR(50) | 主键 | PK |\n| dashboard_id | VARCHAR(50) | 所属仪表板 | FK, NOT NULL |\n| type | VARCHAR(50) | 组件类型 | NOT NULL |\n| title | VARCHAR(255) | 组件标题 | |\n| config | JSON | 组件配置 | |\n| position | INT | 显示位置 | |\n| created_at | TIMESTAMP | 创建时间 | NOT NULL |\n\n**索引**：\n- `idx_dashboards_user_id`：user_id 字段索引\n- `idx_widgets_dashboard_id`：dashboard_id 字段索引\n\n---\n\n### 💡 后续建议\n\n#### 测试计划\n- [ ] **单元测试**：覆盖 DashboardService 和 WidgetService 的所有方法\n- [ ] **集成测试**：测试 API 端点的完整流程\n- [ ] **E2E 测试**：使用 Cypress 测试用户创建仪表板的完整流程\n- [ ] **性能测试**：测试大数据量下的仪表板查询性能\n\n#### 部署注意事项\n- [ ] **数据库迁移**：运行迁移脚本创建表（`go run migrations/*.go`）\n- [ ] **环境变量**：无需新增环境变量\n- [ ] **配置更新**：无需更新配置文件\n- [ ] **依赖注入**：确保 main.go 中注册了新的服务\n\n#### 文档更新\n- [ ] **CHANGELOG.md**：添加版本更新日志\n- [ ] **API 文档**：自动生成 Swagger 文档（`swag init`）\n- [ ] **用户手册**：更新用户手册，说明仪表板功能\n\n#### 可选功能扩展\n- [ ] 仪表板模板功能\n- [ ] 组件市场（共享和复用组件）\n- [ ] 仪表板分享和协作功能\n- [ ] 实时数据更新（WebSocket）\n- [ ] 数据导出功能（CSV、Excel）\n\n#### 性能优化建议\n- [ ] 为大数据量的仪表板添加缓存（Redis）\n- [ ] 使用数据库连接池优化查询性能\n- [ ] 为常用查询添加复合索引\n- [ ] 考虑使用 CDN 分发静态资源\n\n#### 监控指标\n- [ ] **API 响应时间**：监控 `/api/dashboards` 端点的 P95、P99 延迟\n- [ ] **数据库查询时间**：监控仪表板查询的执行时间\n- [ ] **错误率**：监控 API 错误率（目标 < 0.1%）\n- [ ] **并发用户数**：监控同时使用仪表板功能的用户数\n\n---\n\n### 🔧 工具使用情况\n\n#### MCP 工具\n- **context7**：查询了 Gin 框架的路由和中间件文档\n- **exa**：搜索了仪表板组件设计的最佳实践\n- **sequential-thinking**：用于阶段 1 的需求分析和阶段 4 的架构设计\n\n#### Agents\n- **code-explorer**：探索了现有项目的数据层和服务层代码\n- **code-architect**：设计了完整的仪表板管理架构方案（模式 1：单方案设计）\n- **code-reviewer**：并行审查了功能正确性、代码风格和规范遵循\n\n**审查结果**：\n- 发现并修复了 3 个 bug（高置信度）\n- 改进了 5 处代码风格问题\n- 确保了符合 CLAUDE.md 的所有规范\n\n---\n\n### ✅ 功能开发完成\n\n所有阶段已完成，功能已成功实施并通过质量审查！\n\n**项目状态**：✅ 生产就绪\n\n**下一步**：可以部署到测试环境进行集成测试。\n",
        "skills/feat-dev/assets/summary-output-template.md": "# 总结输出模板\n\n使用此模板生成阶段 7 的总结文档。\n\n---\n\n## 📋 阶段 7: 总结\n\n### 🎯 变更摘要\n\n本次实施完成了 **[功能名称]**，包括：\n\n✅ [核心功能 1]\n✅ [核心功能 2]\n✅ [核心功能 3]\n\n**核心能力**：\n- [能力 1]\n- [能力 2]\n- [能力 3]\n\n---\n\n### 📁 修改文件列表\n\n#### 新增文件（N 个）\n\n**[分层标题]**（如：实体层、服务层、API 层、工具、测试）\n- `path/to/file1.ext` - 文件说明\n- `path/to/file2.ext` - 文件说明\n\n#### 修改文件（N 个）\n- `path/to/file1.ext` - 改动说明（+N 行）\n- `path/to/file2.ext` - 改动说明（+N 行）\n\n---\n\n### 🔌 API 变更\n\n#### 新增 API\n\n| 方法 | 路径 | 描述 | 认证 |\n|------|------|------|------|\n| GET | `/api/resource` | 获取资源列表 | ✅ 必须 |\n| POST | `/api/resource` | 创建新资源 | ✅ 必须 |\n| GET | `/api/resource/:id` | 获取资源详情 | ✅ 必须 |\n| PUT | `/api/resource/:id` | 更新资源 | ✅ 必须 |\n| DELETE | `/api/resource/:id` | 删除资源 | ✅ 必须 |\n\n**权限说明**：\n- [权限说明]\n\n---\n\n### 🗄️ 数据库变更\n\n#### 新增表\n\n| 表名 | 说明 |\n|------|------|\n| `table_name` | 表说明 |\n\n#### 修改表\n\n| 表名 | 变更类型 | 说明 |\n|------|---------|------|\n| `table_name` | 新增字段 | 添加 `field_name` 字段 |\n\n---\n\n### 💡 后续建议\n\n#### 测试计划\n- [ ] 单元测试：[具体内容]\n- [ ] 集成测试：[具体内容]\n- [ ] E2E 测试：[具体内容]\n\n#### 部署注意事项\n- [ ] 数据库迁移：[具体说明]\n- [ ] 环境变量：[需要配置的变量]\n- [ ] 配置更新：[需要更新的配置]\n\n#### 文档更新\n- [ ] 更新 CHANGELOG.md\n- [ ] 生成 API 文档（Swagger/OpenAPI）\n\n#### 可选功能扩展\n- [ ] [功能 1]\n- [ ] [功能 2]\n\n#### 性能优化建议\n- [ ] [优化项 1]\n- [ ] [优化项 2]\n\n#### 监控指标\n- [ ] [指标 1]\n- [ ] [指标 2]\n\n---\n\n### 🔧 工具使用情况\n\n#### MCP 工具\n- **context7**：查询了 [库/框架] 文档\n- **exa**：搜索了 [主题] 最佳实践\n- **sequential-thinking**：用于 [阶段] 的深度分析\n\n#### Agents\n- **code-explorer**：探索了 [模块] 代码\n- **code-architect**：设计了 [方案类型] 架构\n- **code-reviewer**：审查了 [维度] 代码\n\n---\n\n### ✅ 功能开发完成\n\n所有阶段已完成，功能已成功实施并通过质量审查！\n",
        "skills/feat-dev/references/mcp-tools.md": "# MCP 工具集成指南\n\n## 核心原则\n\n**所有功能在无 MCP 环境下完全可用**。Skill 会自动检测 MCP 可用性并智能降级。\n\n## 降级决策流程\n\n```\n尝试 MCP 工具\n  ↓\n成功？\n  ├─ 是 → 继续使用 MCP 工具\n  └─ 否 → 立即切换降级方案 → 继续工作流（不中断）\n```\n\n**重要**：不要因为 MCP 工具不可用而中断工作流程。降级方案提供完整功能。\n\n---\n\n## 工具清单\n\n### 1. context7 - 库文档查询\n\n**用途**：获取最新库文档和 API 参考\n**使用阶段**：阶段 2（代码探索）、阶段 4（架构设计）、阶段 5（实施）\n\n#### 调用方式\n\n```\n步骤 1: 使用 resolve-library-id 解析库名到 Context7 兼容的 ID\n  - libraryName: 库的名称（如 \"express\", \"react\", \"next.js\"）\n  - query: 用户的原始问题或任务（用于相关性排序）\n\n步骤 2: 使用 query-docs 查询文档\n  - libraryId: 从步骤1获取的库 ID\n  - query: 具体的查询问题\n```\n\n#### 降级策略\n\n当 context7 不可用时，按以下顺序尝试：\n\n1. **WebSearch**：搜索官方文档\n   ```\n   WebSearch: \"[库名] official documentation 2025\"\n   WebSearch: \"[库名] API reference latest version\"\n   ```\n\n2. **Grep**：搜索项目依赖文件\n   ```\n   Grep: 搜索 package.json（Node.js）\n   Grep: 搜索 项目依赖配置文件（如 package.json, requirements.txt, go.mod, pom.xml）（Go）\n   Grep: 搜索 requirements.txt（Python）\n   Grep: 搜索 pom.xml（Java）\n   ```\n\n3. **Read**：阅读已安装的库文件\n   ```\n   Read: node_modules/[库名]/README.md\n   Read: vendor/[库路径]/README.md\n   Read: 项目中已有的类似实现\n   ```\n\n#### 降级示例\n\n**场景：需要 Gin 框架的中间件文档**\n\n```bash\n# context7 不可用时\n1. WebSearch: \"[Web 框架] middleware documentation 2025\"\n2. Grep: \"项目依赖配置文件（如 package.json, requirements.txt, go.mod, pom.xml）\" 查找 Gin 版本\n3. Read: 已安装库的文档文件\n\n# 获取信息后继续工作流\n```\n\n**场景：需要 [ORM] 关联关系的 API**\n\n```bash\n# context7 不可用时\n1. WebSearch: \"[ORM] associations documentation latest version\"\n2. Grep: \"HasMany|BelongsTo\" 查找项目中的关联示例\n3. Read: 项目中已有的 model 文件\n\n# 参考现有实现继续\n```\n\n---\n\n### 2. exa - 高质量网页搜索和代码示例\n\n**用途**：搜索高质量网页内容、代码示例、最佳实践\n**使用阶段**：阶段 1（需求理解）、阶段 4（架构设计）、阶段 6（质量审查）\n\n#### 调用方式\n\n```\nexa.web_search_exa:\n  - query: 搜索查询\n  - numResults: 返回结果数（默认 8）\n  - type: 'auto' | 'fast' | 'deep'\n\nexa.get_code_context_exa:\n  - query: 代码搜索查询\n  - tokensNum: 返回 token 数（1000-50000，默认 5000）\n```\n\n#### 降级策略\n\n当 exa 不可用时，使用 **WebSearch** 替代：\n\n```\nWebSearch: [相同的查询内容]\n```\n\n#### 降级示例\n\n**场景：搜索类似产品实现案例**\n\n```bash\n# exa 可用时\nexa.web_search_exa: \"user authentication flow best practices 2025\"\n\n# exa 不可用时\nWebSearch: \"user authentication flow best practices 2025\"\n```\n\n**场景：搜索特定功能的代码示例**\n\n```bash\n# exa 可用时\nexa.get_code_context_exa: \"[前端框架] app router authentication example\"\n\n# exa 不可用时\nWebSearch: \"[前端框架] app router authentication example code\"\n```\n\n**场景：搜索架构模式**\n\n```bash\n# exa 可用时\nexa.web_search_exa: \"microservices event-driven architecture patterns\"\n\n# exa 不可用时\nWebSearch: \"microservices event-driven architecture patterns 2025\"\n```\n\n**场景：搜索安全漏洞信息**\n\n```bash\n# exa 可用时\nexa.web_search_exa: \"SQL injection prevention Go [ORM] security\"\n\n# exa 不可用时\nWebSearch: \"SQL injection prevention Go [ORM] 2025 security best practices\"\n```\n\n---\n\n### 3. sequential-thinking - 深度结构化思考（ultrathink）\n\n**用途**：复杂问题的深度分析、架构设计、多步骤推理\n**使用阶段**：阶段 1（复杂需求理解）、阶段 4（架构设计，必须使用）\n\n#### 调用方式\n\n```\nmcp__sequential-thinking__sequentialthinking:\n  - thought: 当前思考步骤\n  - thoughtNumber: 当前思考序号\n  - totalThoughts: 预估总思考步骤\n  - nextThoughtNeeded: 是否需要下一步思考\n  - isRevision: 是否修正之前的思考（可选）\n  - revisesThought: 修正的思考序号（可选）\n```\n\n#### 降级策略\n\n当 sequential-thinking 不可用时，按以下方式处理：\n\n1. **EnterPlanMode**：进入规划模式（适合架构设计）\n2. **思维链分析**：在响应中使用详细的 Chain of Thought\n3. **系统性分解**：手动进行步骤化分析\n\n#### 降级示例\n\n**场景：架构设计阶段**\n\n```markdown\n# sequential-thinking 不可用时\n\n使用 EnterPlanMode 或在响应中详细分析：\n\n## 步骤 1: 分析需求组件\n[识别核心功能模块...]\n\n## 步骤 2: 设计数据结构\n[遵循 CLAUDE.md 规范...]\n- Entity 定义\n- 关联关系\n- 索引设计\n\n## 步骤 3: 设计 API 端点\n[遵循 CLAUDE.md 规范...]\n- 端点列表\n- 请求/响应结构\n- 验证规则\n\n## 步骤 4: 设计服务层架构\n[业务逻辑组织...]\n- Service 接口\n- 依赖注入\n- 事务管理\n\n## 步骤 5: 识别风险和边缘情况\n[潜在问题...]\n- 并发问题\n- 数据一致性\n- 性能瓶颈\n\n## 步骤 6: 规划实施步骤\n[编号的实施计划...]\n1. 创建实体和迁移\n2. 实施数据访问层\n3. ...\n```\n\n**场景：复杂需求理解**\n\n```markdown\n# sequential-thinking 不可用时\n\n使用思维链分析：\n\n让我逐步分析这个需求：\n\n1. **核心功能识别**\n   - 用户提到了 XXX，这意味着需要实现 YYY\n   - 关键词 AAA 表明需要 BBB 功能\n\n2. **依赖关系分析**\n   - 功能 A 依赖于功能 B\n   - 需要先实现 C 才能实现 D\n\n3. **技术选型考量**\n   - 考虑到 XXX，应该选择 YYY\n   - 现有系统使用 AAA，保持一致性\n\n4. **潜在风险识别**\n   - 风险 1: ...\n   - 缓解措施: ...\n\n5. **实施优先级**\n   - 第一优先级: ...\n   - 第二优先级: ...\n```\n\n---\n\n## 何时使用 ultrathink（sequential-thinking）\n\n### ✅ 应该使用\n\n- 需求涉及多个模块或系统的集成\n- 需求包含复杂的业务逻辑或工作流\n- 需求描述模糊或不完整，需要深度分析\n- 需求之间存在依赖关系或潜在冲突\n- **架构设计阶段（阶段 4）- 必须使用**\n\n### ❌ 不需要使用\n\n- 单一、明确的需求\n- 简单的 CRUD 操作\n- 直接的代码修改\n- 需求已经非常清晰且范围明确\n\n---\n\n## 工具使用最佳实践\n\n### 1. 优先尝试，快速降级\n\n```\n永远先尝试 MCP 工具 → 失败立即降级 → 不中断工作流\n```\n\n### 2. 记录降级情况\n\n在总结阶段记录：\n- 哪些 MCP 工具不可用\n- 使用了哪些降级方案\n- 降级方案的效果如何\n\n### 3. 组合使用工具\n\n不要只依赖单一工具：\n```\ncontext7（API 文档） + exa（代码示例） + Grep（项目实现）\n= 完整的技术理解\n```\n\n### 4. 渐进式查询\n\n从广到窄：\n```\n1. exa/WebSearch: 了解整体架构和模式\n2. context7/WebSearch: 查询具体 API 用法\n3. Grep/Read: 查看项目中的具体实现\n```\n\n---\n\n## 常见问题\n\n### Q: MCP 工具调用失败怎么办？\n\nA: 可以尝试重试一次，若依就失败则立即切换到降级方案。降级方案提供相同的功能完整性。\n\n### Q: 如何判断是否应该使用 ultrathink？\n\nA: 如果需求分析或架构设计需要多个步骤的推理，使用 ultrathink。简单需求直接分析即可。\n\n### Q: 降级后的结果质量会下降吗？\n\nA: 不会。降级方案经过设计，确保提供相同质量的信息，只是获取方式不同。\n\n### Q: 可以混合使用 MCP 和降级方案吗？\n\nA: 可以。例如 context7 可用就用，exa 不可用就用 WebSearch 替代。按工具独立决策。\n",
        "skills/feat-dev/references/phase-1-discovery.md": "# 阶段 1: 需求理解 (Discovery)\n\n## 目标\n\n全面理解用户需求，识别核心功能、业务实体、API 端点、业务规则和集成点。\n\n---\n\n## 执行步骤\n\n### 1. 仔细阅读用户需求\n\n识别以下关键要素：\n\n- **核心功能**：请求的主要特性/能力是什么？\n- **业务实体**：涉及哪些数据模型或领域对象？\n- **API 端点**：需要暴露哪些接口？\n- **业务规则**：适用哪些约束、验证或特殊逻辑？\n- **集成点**：需要与哪些现有系统集成？\n\n### 2. 决定是否使用 ultrathink\n\n根据需求复杂度决定：\n\n#### ✅ 应该使用 ultrathink\n\n- 需求涉及多个模块或系统的集成\n- 需求包含复杂的业务逻辑或工作流\n- 需求描述模糊或不完整\n- 需求之间存在依赖关系或冲突\n\n#### ❌ 不需要 ultrathink\n\n- 单一、明确的需求\n- 简单的 CRUD 操作\n- 直接的代码修改\n- 需求已经非常清晰且范围明确\n\n### 3. 搜索类似实现案例（可选）\n\n了解行业最佳实践和常见模式。\n\n---\n\n## MCP 工具使用\n\n### 优先尝试：exa.web_search_exa\n\n**目的**：搜索类似产品/功能的实现案例，了解行业最佳实践\n\n**示例查询**：\n```\n\"user dashboard analytics implementation best practices\"\n\"real-time notification system architecture\"\n\"multi-tenant SaaS data isolation patterns\"\n```\n\n**降级方案**：\n```\nWebSearch: [相同的查询内容]\n```\n\n### 复杂需求时尝试：sequential-thinking\n\n**目的**：使用 ultrathink 进行深度需求分析\n\n**使用场景**：参见上方\"应该使用 ultrathink\"部分\n\n**降级方案**：\n- 在响应中使用详细的思维链分析（Chain of Thought）\n- 手动进行步骤化分解\n\n**降级示例**：\n\n```markdown\n让我逐步分析这个需求：\n\n## 步骤 1: 核心功能拆解\n用户提到了\"用户仪表板\"，这包含：\n- 数据展示功能\n- 数据筛选功能\n- 数据导出功能\n\n## 步骤 2: 业务实体识别\n涉及的实体：\n- User（用户）\n- Dashboard（仪表板配置）\n- Widget（仪表板组件）\n- DataSource（数据源）\n\n## 步骤 3: API 端点推导\n需要的端点：\n- GET /api/dashboards - 获取用户仪表板列表\n- POST /api/dashboards - 创建仪表板\n- GET /api/dashboards/:id/data - 获取仪表板数据\n\n## 步骤 4: 业务规则识别\n- 用户只能访问自己的仪表板\n- 数据需要根据用户权限过滤\n- 实时数据更新频率限制\n\n## 步骤 5: 集成点识别\n需要集成：\n- 现有的认证系统\n- 数据库查询引擎\n- WebSocket 服务（实时更新）\n```\n\n---\n\n## 输出要求\n\n### 需求理解摘要\n\n输出格式：\n\n```markdown\n## 🎯 阶段 1: 需求理解\n\n### 核心功能\n- [功能 1]\n- [功能 2]\n- ...\n\n### 业务实体\n- **实体 1**：[描述]\n- **实体 2**：[描述]\n- ...\n\n### API 端点（初步）\n- [方法] [路径] - [描述]\n- ...\n\n### 业务规则\n- [规则 1]\n- [规则 2]\n- ...\n\n### 集成点\n- [系统 1]：[集成目的]\n- [系统 2]：[集成目的]\n- ...\n\n### 不确定点（需要澄清）\n- [问题 1]\n- [问题 2]\n- ...\n```\n\n---\n\n完成需求理解后，**MUST 输出**：\n\n```markdown\n---\n✅ 阶段 1 完成\n\n📋 本阶段产出：\n- 需求理解摘要（核心功能、业务实体、API 端点、业务规则、集成点）\n- 不确定点列表（需要在阶段 3 澄清）\n\n📍 下一阶段：2 - 代码库探索\n\n⚠️ WORKFLOW CHECKPOINT: 准备进入阶段 2\n（严格禁止跳过阶段 2、3、4 直接开始实施）\n---\n```\n\n**⚠️ CRITICAL - 阶段 1 完成后的规则**：\n- ✅ MUST 输出上述完成标记\n- ✅ MUST 进入阶段 2（代码库探索）\n- ❌❌❌ **ABSOLUTELY PROHIBITED**：跳过阶段 2、3、4 直接到阶段 5（实施）\n- ❌❌❌ **ABSOLUTELY PROHIBITED**：在阶段 1 完成后立即开始代码探索并实施\n\n---\n\n## 进入下一阶段\n\n完成需求理解后，进入 **阶段 2: 代码库探索**。\n\n参见：[phase-2-exploration.md](phase-2-exploration.md)\n",
        "skills/feat-dev/references/phase-2-exploration.md": "# 阶段 2: 代码库探索 (Codebase Exploration)\n\n## 目标\n\n深入理解现有代码库的架构、模式和规范,为实施做好准备。\n\n---\n\n## 首要任务:查找 CLAUDE.md\n\n**必须首先执行**:\n\n```bash\nRead: /path/to/project/CLAUDE.md\n```\n\n**CLAUDE.md 包含**:项目架构规范、代码组织约定、API 设计规范、数据库设计规范、依赖注入模式、测试要求等\n\n**如果不存在**:通过代码探索推断规范,在总结阶段建议创建 CLAUDE.md\n\n---\n\n## 并行 Agent 执行\n\n启动 **2-3 个 code-explorer agents** 并行探索不同层面:\n\n### Agent 示例(根据需要调整探索焦点)\n\n```\nTask:\n- subagent_type: spec-dev:code-explorer\n- model: haiku\n- prompt: \"探索 [实体层/服务层/API层]\n\n  要求:\n  1. 查找现有实现\n  2. 识别组织模式和命名规范\n  3. 查找可参考的实现\n  4. **返回 5-10 个关键文件路径**\n\n  关注点:\n  - 文件位置和命名规范\n  - 设计模式和架构\n  - 依赖注入和错误处理\"\n- run_in_background: true\n```\n\n**建议分工**:\n- Agent 1: 探索实体和数据模型\n- Agent 2: 探索服务层和业务逻辑\n- Agent 3: 探索 API 层和控制器\n\n---\n\n## Agent 输出要求\n\n**关键要求**:每个 agent 必须返回 **5-10 个关键文件路径**\n\n```markdown\n### ⭐ 关键文件清单(必须,5-10 个)\n1. `/path/to/file1.ext` - [为什么这个文件重要]\n2. `/path/to/file2.ext` - [为什么这个文件重要]\n...\n```\n\n**文件选择标准**:包含核心业务逻辑、定义关键抽象、展示项目模式、新功能必须参考的文件\n\n---\n\n## 读取 Agent 识别的文件\n\n**必须执行**:主进程必须亲自阅读 agents 返回的所有关键文件\n\n```\n1. 收集所有 agents 返回的文件列表\n2. 去重合并\n3. 批量读取:Read: /path/to/file1, Read: /path/to/file2, ...\n4. 分析理解:识别命名约定、设计模式、代码风格\n```\n\n---\n\n## MCP 工具使用\n\n### 优先尝试:context7.query-docs\n\n**目的**:获取项目依赖库的最新文档和 API 参考\n\n```\n1. context7.resolve-library-id: libraryName=\"库名\", query=\"用户的原始问题或任务\"\n2. context7.query-docs: libraryId=\"/库路径\", query=\"具体的查询问题\"\n```\n\n**降级方案**:WebSearch + Grep + Read\n\n### 优先尝试:exa.get_code_context_exa\n\n**目的**:搜索特定框架/库的代码示例\n**降级方案**:WebSearch\n\n---\n\n## 汇总探索结果\n\n```markdown\n## 🔍 阶段 2: 代码库探索结果\n\n### CLAUDE.md 规范\n[存在/不存在]\n关键规范要点: [...]\n\n### 项目架构\n- **实体层**: [位置和模式]\n- **服务层**: [位置和模式]\n- **API 层**: [位置和模式]\n\n### 相关组件\n- **实体**: `/path/to/entity.ext` - [描述]\n- **服务**: `/path/to/service.ext` - [描述]\n- **控制器**: `/path/to/controller.ext` - [描述]\n\n### 识别的设计模式\n- **依赖注入**: [方式]\n- **错误处理**: [模式]\n- **数据验证**: [方式]\n\n### 技术栈确认\n- **框架**: [名称和版本]\n- **ORM**: [名称和版本]\n- **数据库**: [类型]\n```\n\n---\n\n## 进入下一阶段\n\n完成代码库探索后,进入 **阶段 3: 澄清问题**。\n",
        "skills/feat-dev/references/phase-3-clarify.md": "# 阶段 3: 澄清问题\n\n## 目标\n\n填补需求空白，解决模糊和歧义，确保实施方向正确。\n\n---\n\n## 何时提问\n\n在以下情况下**必须**使用 **AskUserQuestion 工具**向用户提问：\n\n### ✅ 必须澄清的情况\n\n1. **模糊或规格不足的需求**\n   - 需求描述不够具体\n   - 缺少关键业务规则\n   - 边缘情况处理不明确\n\n2. **多个有效实施方法**\n   - 有多种技术方案可选\n   - 不同方案有不同的权衡\n   - 用户偏好会影响选择\n\n3. **业务规则细节**\n   - 验证规则的具体要求\n   - 权限控制的粒度\n   - 数据处理的特殊逻辑\n\n4. **与现有功能的关系**\n   - 是否应该复用现有组件\n   - 是否需要保持向后兼容\n   - 是否应该重构现有代码\n\n5. **技术选型或架构决策**\n   - 认证方式选择（JWT vs Session）\n   - 存储方式选择（Redis vs 数据库）\n   - 通信方式选择（WebSocket vs SSE）\n\n### ❌ 不需要澄清的情况\n\n- 需求已经非常明确\n- 有明显的最佳实践可遵循\n- CLAUDE.md 或项目规范已经规定\n- 可以从现有代码推断出模式\n\n---\n\n## 使用 AskUserQuestion 工具\n\n### 工具用法\n\n```\nAskUserQuestion:\n  questions: [\n    {\n      question: \"完整的问题？\",\n      header: \"简短标签（≤12字符）\",\n      options: [\n        {\n          label: \"选项 1\",\n          description: \"选项 1 的说明和影响\"\n        },\n        {\n          label: \"选项 2\",\n          description: \"选项 2 的说明和影响\"\n        }\n      ],\n      multiSelect: false  // true 表示可多选\n    }\n  ]\n```\n\n### 最佳实践\n\n#### 1. 一次提问多个问题\n\n一次提出多个问题，尽可能详细的了解整个需求。\n\n#### 2. 提供具体的选项\n\n给出 2-4 个具体选项，而不是开放式问题，根据具体问题的复杂度可以适当增加选项。\n\n#### 3. 说明每个选项的影响\n\n让用户了解选择的后果和权衡。\n\n#### 4. 推荐首选方案\n\n如果有推荐的选项，放在第一位并标注 \"(推荐)\"。\n\n---\n\n## 典型场景示例\n\n### 场景 1: 认证方式选择\n\n**问题**：用户认证应该使用哪种方式？\n\n**选项**：\n- JWT Token (推荐)：无状态，适合分布式系统\n- Session：传统方式，需要服务器端会话存储，适合单体应用\n\n### 场景 2: 数据同步策略\n\n**问题**：用户数据更新后，如何同步到前端？\n\n**选项**：\n- 轮询 (推荐)：实现简单，适合更新不频繁的场景\n- WebSocket：实时双向通信，即时更新，需要维护长连接\n- Server-Sent Events：服务器主动推送，比 WebSocket 简单\n\n### 场景 3: 权限控制粒度\n\n**问题**：权限控制应该到什么粒度？\n\n**选项**：\n- 角色级别 (推荐)：基于用户角色控制，实现简单\n- 资源级别：针对每个资源单独授权，更灵活但复杂\n- 字段级别：控制到具体字段，最细粒度但成本高\n\n---\n\n## 处理用户反馈\n\n### 1. 记录用户选择\n\n将用户的回答记录在笔记中，供后续阶段参考。\n\n### 2. 更新需求理解\n\n基于用户反馈，更新阶段 1 的需求理解。\n\n### 3. 补充到架构设计\n\n将澄清的细节纳入阶段 4 的架构设计。\n\n### 4. 继续工作流\n\n**重要**：收到用户反馈后，必须明确继续当前 skill 的工作流：\n\n```markdown\n---\n📥 已收到用户反馈\n\n🔄 继续阶段 3 - 澄清问题\n---\n\n### 用户反馈\n- **[主题 1]**：[用户的选择/回答]\n- **[主题 2]**：[用户的选择/回答]\n\n已更新需求理解。\n\n---\n✅ 阶段 3 完成\n\n📍 下一阶段：4 - 架构设计\n---\n```\n\n**禁止**：\n- ❌❌❌ **CRITICAL**：收到用户反馈后直接跳到阶段 5（实施）\n- ❌❌❌ **CRITICAL**：跳过阶段 4（架构设计）\n- ❌❌❌ **CRITICAL**：在未完成阶段 3 时进入下一阶段\n- ❌❌❌ **CRITICAL**：收到用户反馈后跳出当前 skill\n\n**⚠️ MANDATORY CHECKPOINT（强制检查点）**：\n```markdown\n如果在阶段 3 使用了 AskUserQuestion：\n\n1. MUST 停止并等待用户回应\n2. 收到回应后 MUST 输出：\n   ---\n   📥 已收到用户反馈\n\n   ⚠️ WORKFLOW CHECKPOINT: 继续阶段 3 - 澄清问题\n   （禁止跳出当前 skill，禁止跳过阶段 4）\n   ---\n\n3. MUST 处理用户反馈并更新需求理解\n4. MUST 完成阶段 3 并输出完成标记（见下方）\n5. 然后才能进入阶段 4\n```\n\n---\n\n## 输出示例\n\n### 有需要澄清的情况\n\n```markdown\n## ❓ 阶段 3: 澄清问题\n\n我发现以下几点需要确认：\n\n1. **认证方式**：用户登录应该使用哪种认证方式？\n2. **数据同步**：数据更新后如何同步到前端？\n3. **权限控制**：权限控制应该到什么粒度？\n\n[使用 AskUserQuestion 工具提问]\n\n---\n\n### 用户反馈\n\n- **认证方式**：JWT Token\n- **数据同步**：轮询（每 30 秒）\n- **权限控制**：角色级别\n\n已更新需求理解和架构设计计划。\n```\n\n### 无需澄清的情况\n\n```markdown\n## ❓ 阶段 3: 澄清问题\n\n经过分析，需求描述清晰，项目规范完善，无需额外澄清。\n\n可以直接进入架构设计阶段。\n```\n\n---\n\n## 进入下一阶段\n\n完成问题澄清后，进入 **阶段 4: 架构设计**。\n\n参见：[phase-4-design.md](phase-4-design.md)\n",
        "skills/feat-dev/references/phase-4-design.md": "# 阶段 4: 架构设计\n\n## 🎯 目标\n\n设计详细的实施方案,包括数据库设计、API 端点设计、服务层架构和详细的实施步骤。\n\n---\n\n## 阶段标记\n\n**开始时输出**:\n```markdown\n---\n## 🚀 当前阶段:4 - 架构设计\n---\n```\n\n**结束时输出**(用户确认后):\n```markdown\n---\n✅ 阶段 4 完成\n\n📍 下一阶段:5 - 实施\n---\n```\n\n---\n\n## MCP 工具使用\n\n### 📚 优先尝试:context7.query-docs\n**目的**:获取框架的架构指南\n**降级方案**:WebSearch\n\n### 🔍 优先尝试:exa.web_search_exa\n**目的**:搜索架构模式和设计最佳实践\n**降级方案**:WebSearch\n\n---\n\n## 必须使用: code-architect Agent\n\n**Phase 4 核心步骤**: 根据需求复杂度选择合适的架构设计模式。\n\n---\n\n## ⚠️ 复杂度判断和模式选择\n\n### 判断需求复杂度\n\n#### 简单/中等需求（使用单方案模式）\n- 单一功能或涉及 2-3 个模块\n- 实现路径清晰明确\n- 不涉及重大架构变更\n\n#### 复杂需求（使用多方案模式）\n满足以下**任一**条件：\n- ✅ 有**多种明显不同的实现路径**\n- ✅ 存在**重大架构权衡**\n- ✅ **影响多个核心模块**（3个以上）\n- ✅ **引入新的技术或架构模式**\n- ✅ **用户明确要求**对比多个方案\n\n---\n\n## 结构化上下文模板\n\n**重要**：此模板在模式 1 和模式 2 中都会用到。\n\n```markdown\n## 完整上下文\n\n### 1. 需求理解 (阶段 1 结果)\n\n#### 核心功能\n${将阶段 1 识别的核心功能完整列出}\n\n#### 业务实体\n${将阶段 1 识别的业务实体和字段需求完整列出}\n\n#### API 端点需求\n${将阶段 1 识别的 API 端点需求完整列出}\n\n#### 业务规则\n${将阶段 1 识别的业务规则和约束完整列出}\n\n#### 集成点\n${将阶段 1 识别的集成点和依赖完整列出}\n\n---\n\n### 2. 代码库探索发现 (阶段 2 结果)\n\n#### CLAUDE.md 规范要点\n${如果有 CLAUDE.md,列出关键规范}\n\n#### 项目架构和技术栈\n- 架构风格: [MVC/分层架构/微服务/单体等]\n- 编程语言: [使用的语言和版本]\n- 主要框架: [Web框架、ORM等]\n- 数据库: [数据库类型和版本]\n- 关键依赖: [重要的第三方库]\n\n#### 相关现有实现\n${列出 code-explorer 发现的相关组件}\n\n#### 设计模式和代码风格\n${列出项目中使用的设计模式和约定}\n\n#### 必读架构参考文件\n${列出 code-explorer 识别的 5-10 个关键文件路径}\n\n---\n\n### 3. 用户澄清和决策 (阶段 3 结果)\n\n${如果阶段 3 使用了 AskUserQuestion,列出所有问题和用户的回答}\n\n#### 澄清的问题 1\n**问题**: [原始问题]\n**用户回答**: [用户的选择和说明]\n**影响**: [这个决策如何影响架构设计]\n\n${如果没有澄清问题,说明: 无需澄清 - 需求已经明确}\n\n---\n\n### 4. 外部资源研究 (如适用)\n\n${如果阶段 2.5 进行了外部资源研究,列出关键发现}\n```\n\n---\n\n## 模式 1: 单方案设计（简单/中等需求）\n\n### 执行步骤\n\n**步骤 1: 主进程使用 ultrathink 进行深度分析**\n\n调用 **mcp__sequential-thinking__sequentialthinking 工具**：\n\n```markdown\n使用 sequential-thinking 工具分析：\n1. 分解需求组件和依赖关系\n2. 分析可能的实现路径\n3. 做出关键架构决策（基于项目约定和最佳实践）\n4. 识别主要风险和权衡点\n5. 确定推荐的架构方向\n```\n\n**步骤 2: 启动单个 code-architect agent 细化设计**\n\n使用上面的**结构化上下文模板**传递信息，添加 ultrathink 分析结果：\n\n```markdown\nTask: 细化架构设计\n- description: \"基于 ultrathink 分析细化架构设计\"\n- prompt: \"## 任务\n基于以下 ultrathink 深度分析结果，细化架构设计并产出详细的实施蓝图\n\n## Ultrathink 分析结果\n${将 sequential-thinking 的分析结果完整列出}\n\n---\n\n[使用上面的结构化上下文模板]\n\n## 细化设计要求\n\n基于 ultrathink 的分析和完整上下文,请细化架构设计：\n\n1. **探索代码库** - 深入探索相关代码\n2. **数据库设计** - 实体定义、关联、索引，符合 CLAUDE.md 规范\n3. **API 端点设计** - REST 端点、请求/响应，符合 CLAUDE.md 规范\n4. **服务层架构** - 服务接口、业务逻辑、依赖注入，符合 CLAUDE.md 规范\n5. **风险分析** - 验证 ultrathink 识别的风险\n6. **详细实施步骤** - 至少 5-10 个详细步骤\n7. **关键架构参考文件** - 返回 5-10 个必读文件\"\n\n- subagent_type: \"spec-dev:code-architect\"\n- model: \"sonnet\"\n- run_in_background: false\n```\n\n**步骤 3: 向用户展示方案**\n\n展示单一的最佳方案，包含：\n- Ultrathink 的深度分析结果\n- Code-architect 的详细设计\n- 完整的实施步骤\n\n---\n\n## 模式 2: 多方案设计（复杂需求）\n\n### 执行步骤\n\n**步骤 1: 并行启动 2-3 个 code-architect agents**\n\n⚠️ **不使用主进程 ultrathink**（agents 会各自进行深度分析）\n\n⚠️ **并行执行要求**：\n- **必须在单个消息中**发起 2-3 个 Task 工具调用\n- **每个 Task 必须设置** `run_in_background: true`\n- **然后使用 TaskOutput** 收集每个 agent 的结果\n\n**Agent 方案分工**：\n- Agent 1: 最小改动方案 - 快速交付，最小化风险\n- Agent 2: 清晰架构方案 - 追求最佳实践和长期可维护性\n- Agent 3: 实用平衡方案 - 在速度和质量之间找平衡（通常推荐）\n\n**并行调用模板**：\n\n每个 agent 使用上面的**结构化上下文模板**传递信息：\n\n```markdown\nTask 1/2/3: 设计[方案类型]架构方案\n- description: \"设计[最小改动/清晰架构/实用平衡]方案\"\n- prompt: \"## 任务\n为 [功能名称] 设计详细的架构蓝图\n\n⚠️ 要求：\n1. 进行系统化的深度分析和架构设计\n2. 设计方案类型: **[最小改动/清晰架构/实用平衡]方案**\n3. 提供详细的架构决策理由和权衡分析\n\n---\n\n[使用上面的结构化上下文模板]\n\n## 设计要求\n\n基于完整上下文,设计[最小改动/清晰架构/实用平衡]方案：\n\n1. **探索代码库** - 深入探索相关代码\n2. **数据库设计** - 实体定义、关联、索引，符合 CLAUDE.md 规范\n3. **API 端点设计** - REST 端点、请求/响应，符合 CLAUDE.md 规范\n4. **服务层架构** - 服务接口、业务逻辑、依赖注入，符合 CLAUDE.md 规范\n5. **风险分析** - 识别技术实现层面的风险\n6. **详细实施步骤** - 至少 5-10 个详细步骤\n7. **关键架构参考文件** - 返回 5-10 个必读文件\"\n\n- subagent_type: \"spec-dev:code-architect\"\n- model: \"sonnet\"\n- run_in_background: true\n```\n\n**步骤 2: 读取所有 agents 推荐的架构文件**\n\n主进程必须亲自阅读这些架构参考文件，建立深度理解。\n\n**步骤 3: 整合所有方案**\n\n对比 2-3 个方案的优劣势：\n- 开发时间\n- 代码质量\n- 可维护性\n- 风险评估\n\n进行权衡分析，给出推荐意见及理由。\n\n**步骤 4: 向用户展示多方案对比**\n\n展示内容：\n- 方案对比表格\n- 每个方案的详细设计\n- 权衡分析\n- 推荐意见及理由\n\n询问用户选择哪个方案。\n\n---\n\n## 🎯 架构方案设计\n\n### 数据库设计\n\n**实体定义**：\n- 表结构、字段类型、约束\n- 主键、外键、索引\n- 符合 CLAUDE.md 数据库设计规范\n\n### API 端点设计\n\n**REST 端点**：\n- HTTP 方法、路径设计\n- 请求/响应结构\n- 认证和授权要求\n- 符合 CLAUDE.md API 设计规范\n\n### 服务层架构\n\n**服务设计**：\n- 服务接口定义\n- 业务逻辑流程\n- 依赖关系和注入\n- 事务管理策略\n- 符合 CLAUDE.md 架构模式\n\n---\n\n## Agent 输出要求\n\n### 必须包含\n\n1. **数据库设计**\n   - 实体定义（字段、类型、约束）\n   - 表关联关系\n   - 索引设计\n\n2. **API 端点设计**\n   - 完整的端点列表（方法、路径）\n   - 请求/响应示例\n   - 认证要求说明\n\n3. **服务层设计**\n   - 服务接口定义\n   - 业务逻辑流程\n   - 依赖关系说明\n\n4. **实施步骤**\n   - 至少 5-10 个详细步骤\n   - 每步包含: 任务、产出、验证方式\n   - 按依赖关系排序\n\n5. **关键架构参考文件**\n   - 返回 5-10 个必读文件路径\n   - 供主进程阅读理解项目架构\n\n---\n\n## 设计产出\n\n### 模式 1 产出（简单/中等需求）\n\n- 主进程 ultrathink 的深度分析结果\n- 单个 code-architect agent 的详细架构设计\n- 读取的架构相关文件理解\n- 数据库设计（实体/表结构、字段、关联、索引）\n- API 端点设计（方法、路径、请求/响应、认证）\n- 服务层设计（服务接口、依赖关系、业务逻辑流程）\n- **详细实施步骤**（编号列表，每步明确任务和产出）\n- 设计理由和说明\n- 用户确认\n\n### 模式 2 产出（复杂需求）\n\n- 2-3 个 code-architect agents 的深度架构设计和建议\n- 读取的架构相关文件理解\n- **多方案对比和权衡分析**（对比表格 + 优劣势分析）\n- [针对每个方案] 数据库设计（实体/表结构、字段、关联、索引）\n- [针对每个方案] API 端点设计（方法、路径、请求/响应、认证）\n- [针对每个方案] 服务层设计（服务接口、依赖关系、业务逻辑流程）\n- [针对每个方案] **详细实施步骤**（编号列表，每步明确任务和产出）\n- **推荐意见及理由**（基于权衡分析）\n- 用户选择确认\n\n---\n\n## 实施步骤\n\n**模式 1: 单方案设计**\n\n1. 主进程使用 ultrathink 深度分析\n2. 启动 code-architect agent 细化设计\n3. 读取架构参考文件\n4. 向用户展示方案并请求确认\n\n**模式 2: 多方案设计**\n\n1. 并行启动 2-3 个 code-architect agents\n2. 读取所有 agents 的架构参考文件\n3. 整合所有方案，对比优劣势\n4. 向用户展示多方案对比\n5. 询问用户选择方案\n\n---\n\n## ⚠️ 等待用户确认(CRITICAL CHECKPOINT)\n\n**这是最关键的检查点** - 必须等待用户明确确认架构方案后才能开始实施。\n\n### 向用户展示设计后\n\n使用 **AskUserQuestion** 询问用户（对于模式 2）：\n\n```markdown\n询问用户：\"你希望使用哪个方案？\"\n选项：\n- 方案 1: [最小改动/清晰架构/实用平衡]\n- 方案 2: [其他方案]\n- 方案 3: [其他方案]\n```\n\n### 用户确认后\n\n**必须**确认用户已明确选择方案，然后才能标记阶段 4 为完成。\n\n---\n\n## ✅ 准备好实施了吗?\n\n在用户确认架构方案后：\n\n```markdown\n---\n✅ 阶段 4 完成\n\n📍 下一阶段:5 - 实施\n---\n```\n\n**禁止**：\n- ❌❌❌ **CRITICAL**：在未获得用户确认时标记阶段 4 为完成\n- ❌❌❌ **CRITICAL**：跳过阶段 4 直接进入阶段 5（实施）\n- ❌❌❌ **CRITICAL**：用户未确认方案时开始编码\n\n---\n\n## 进入下一阶段\n\n完成架构设计并得到用户确认后，进入 **阶段 5: 实施**。\n\n参见：[phase-5-implement.md](phase-5-implement.md)\n",
        "skills/feat-dev/references/phase-5-implement.md": "# 阶段 5: 实施 (Implementation)\n\n## 目标\n\n按照架构设计计划实施功能，编写高质量、符合规范的代码。\n\n---\n\n## 前置条件\n\n**必须**：用户已确认阶段 4 的架构方案。\n\n如果用户未确认，返回阶段 4 等待确认。\n\n---\n\n## 使用模型\n\n**推荐模型**：Sonnet\n\n---\n\n## 实施顺序\n\n按照阶段 4 规划的步骤顺序实施，通常为：\n\n### 1. 创建实体和数据库迁移\n\n- 创建 Entity 文件\n- 定义字段、类型、约束\n- 定义关联关系\n- 创建数据库迁移文件\n- 运行迁移测试\n\n### 2. 实施数据访问层\n\n- 创建 Repository 接口\n- 实现 CRUD 方法\n- 实现查询方法\n- 添加事务支持\n\n### 3. 实施服务层业务逻辑\n\n- 创建 Service 接口\n- 实现业务逻辑方法\n- 添加业务验证\n- 添加错误处理\n- 实现依赖注入\n\n### 4. 创建请求/响应结构\n\n- 创建 DTO（Data Transfer Object）\n- 定义请求结构\n- 添加验证规则（binding tags）\n- 定义响应结构\n\n### 5. 实施控制器\n\n- 创建 Controller 文件\n- 实现路由处理函数\n- 添加请求验证\n- 添加响应格式化\n- 添加错误处理\n\n### 6. 注册路由\n\n- 在路由文件中注册端点\n- 配置中间件（认证、授权、日志等）\n- 分组和版本管理\n\n### 7. 添加验证和错误处理\n\n- 自定义验证规则\n- 统一错误响应格式\n- 添加日志记录\n- 添加性能监控\n\n---\n\n## MCP 工具使用\n\n### 📚 优先尝试：context7.query-docs\n\n**目的**：实时查询 API 文档，确保使用最新语法\n\n**使用场景**：\n- 不确定某个 API 的用法\n- 需要查看参数选项\n- 需要了解返回值结构\n- 需要查看错误处理方式\n\n**示例**：\n\n```bash\n# 查询 GORM 的关联关系用法\ncontext7.resolve-library-id: libraryName=\"gorm\", query=\"需要了解 GORM 的关联关系用法\"\ncontext7.query-docs: libraryId=\"/go-gorm/gorm\", query=\"associations and relationship handling\"\n\n# 查询 Gin 框架的验证规则\ncontext7.resolve-library-id: libraryName=\"gin\", query=\"需要了解 Gin 框架的请求验证\"\ncontext7.query-docs: libraryId=\"/gin-gonic/gin\", query=\"request validation and binding\"\n```\n\n**降级方案**：\n\n```bash\n# context7 不可用时\n1. WebSearch: \"ORM associations documentation latest version\"\n2. Grep: \"HasMany|BelongsTo\" 查找项目中的关联示例\n3. Read: 查找项目中的关联示例\n```\n\n### 🔍 优先尝试：exa.get_code_context_exa\n\n**目的**：搜索特定功能的实现示例\n\n**示例查询**：\n```\n\"ORM many-to-many relationship example code\"\n\"Web 框架 custom validation rule implementation\"\n\"context timeout handling example\"\n```\n\n**降级方案**：\n```\nWebSearch: [相同查询内容]\n```\n\n---\n\n## 实施原则\n\n### 1. 严格遵循 CLAUDE.md 规范\n\n- 代码组织结构\n- 命名约定\n- 错误处理模式\n- 日志记录格式\n- 注释风格\n\n### 2. 遵循代码库现有模式\n\n- 查看类似功能的实现\n- 保持一致的代码风格\n- 复用现有组件和工具函数\n\n### 3. 每完成一个模块及时测试\n\n不要等到所有代码都写完才测试\n\n### 4. 保持代码简洁，避免过度设计\n\n- 不要添加未请求的功能\n- 不要过早优化\n- 不要创建不必要的抽象\n- 只在必要时添加注释\n\n### 5. 安全第一\n\n检查并避免常见安全漏洞：\n\n- ✅ SQL 注入：使用参数化查询（ORM 自动处理）\n- ✅ XSS：前端正确转义用户输入\n- ✅ CSRF：使用 CSRF token\n- ✅ 认证：验证用户身份\n- ✅ 授权：验证用户权限\n- ✅ 输入验证：验证所有用户输入\n- ✅ 敏感信息：不要在日志中记录密码、token 等\n\n---\n\nA: 根据项目要求。如果 CLAUDE.md 要求测试，必须编写。否则可选。\n\n---\n\n## 进入下一阶段\n\n实施完成后，进入 **阶段 6: 质量审查**。\n\n参见：[phase-6-review.md](phase-6-review.md)\n",
        "skills/feat-dev/references/phase-6-review.md": "# 阶段 6: 质量审查 (Quality Review)\n\n## 目标\n\n通过并行代码审查确保代码质量,识别 bug、安全漏洞、代码质量问题和规范违反。\n\n---\n\n## 并行 Code-Reviewer Agents\n\n启动 **3 个 code-reviewer agents** 并行审查不同方面:\n\n### Reviewer 示例(根据审查焦点调整)\n\n```\nTask:\n- subagent_type: spec-dev:code-reviewer\n- model: haiku\n- prompt: \"审查焦点: [Bug和逻辑错误/代码风格和质量/项目规范遵循]\n\n  审查范围: [列出本次实施的所有文件路径]\n\n  审查要点: [根据焦点列出具体检查项]\n\n  请识别所有问题,按严重程度和置信度排序。\"\n- run_in_background: true\n```\n\n**建议分工**:\n- Reviewer 1: Bug 和逻辑错误(空指针、资源泄漏、并发问题、逻辑错误)\n- Reviewer 2: 代码风格和质量(命名规范、代码重复、函数复杂度、性能问题)\n- Reviewer 3: 项目规范遵循(文件组织、命名约定、API 设计、错误处理)\n\n---\n\n## MCP 工具使用\n\n### 🔍 优先尝试:exa.web_search_exa\n\n**目的**:搜索已知安全漏洞和常见 bug 模式\n**降级方案**:WebSearch\n\n---\n\n## 汇总审查结果并询问用户决策\n\n**重要**:不要自动修复,而是**询问用户**如何处理\n\n### 向用户展示\n\n```markdown\n## 🔍 质量审查完成\n\n### 审查统计\n- 发现问题总数: Y 个\n  - 🔴 高严重性: A 个\n  - 🟡 中严重性: B 个\n  - 🟢 低严重性: C 个\n\n### 高优先级问题\n\n#### 🔴 高置信度 Bug(≥80%) - 建议立即修复\n1. **空指针检查缺失** (置信度: 95%)\n   - 文件: services/service.go:45\n   - 影响: 可能导致崩溃\n   - 修复预估: 5 分钟\n\n### 中等问题\n[列出中等严重性问题...]\n\n---\n\n## ❓ 你希望如何处理?\n\n**选项 A: 立即修复所有高严重性问题**(推荐)\n**选项 B: 仅修复高置信度 bug**\n**选项 C: 暂不修复,记录问题**\n**选项 D: 自定义**\n```\n\n---\n\n## 处理审查结果\n\n### 修复策略(基于用户决策)\n\n#### 必须修复\n1. 高置信度 bug(≥80%)\n2. 严重规范违反\n\n#### 应该修复\n3. 中置信度 bug(60-79%)\n4. 严重质量问题\n\n#### 可选修复\n5. 一般质量问题\n6. 一般规范违反\n7. 低置信度 bug(<60%)\n\n### 修复记录\n\n```markdown\n### 修复记录\n\n#### 已修复\n1. ✅ **空指针检查缺失** (services/service.go:45)\n   - 添加了 nil 检查和错误处理\n\n#### 暂不处理\n1. ⏸️ **函数过长**\n   - 原因: 逻辑相对清晰,暂时可接受\n   - 建议: 后续重构时优化\n```\n\n---\n\n## 安全检查清单\n\n### ✅ 输入验证\n- [ ] 所有用户输入都经过验证\n- [ ] 验证文件上传类型和大小\n\n### ✅ 认证和授权\n- [ ] 需要认证的端点添加了认证中间件\n- [ ] 用户只能访问自己的资源\n\n### ✅ 注入防护\n- [ ] 使用 ORM 参数化查询\n- [ ] 不拼接 SQL\n\n### ✅ 敏感信息\n- [ ] 不在日志中记录密码、token\n- [ ] 不在响应中返回敏感字段\n\n### ✅ 错误处理\n- [ ] 不暴露内部实现细节\n- [ ] 统一的错误响应格式\n\n---\n\n## 进入下一阶段\n\n质量审查和修复完成后,进入 **阶段 7: 总结**。\n",
        "skills/feat-dev/references/phase-7-summary.md": "# 阶段 7: 总结\n\n## 目标\n\n全面总结实施成果，提供清晰的文档和后续建议。\n\n---\n\n## 输出内容\n\n### 1. 变更摘要\n\n简明扼要地描述实现了什么功能，包括核心能力。\n\n### 2. 修改文件列表\n\n列出所有新增和修改的文件及其作用：\n- 新增文件（按层次分类：实体层、服务层、API 层、工具、测试）\n- 修改文件（列出文件和改动说明）\n\n### 3. API 变更\n\n详细列出新增的 API 端点：\n| 方法 | 路径 | 描述 | 认证 |\n|------|------|------|------|\n| ... | ... | ... | ... |\n\n### 4. 数据库变更\n\n列出新增或修改的表结构：\n| 表名 | 变更类型 | 说明 |\n|------|---------|------|\n| ... | ... | ... |\n\n### 5. 后续建议\n\n提供以下建议：\n- 测试计划（单元测试、集成测试、E2E 测试）\n- 部署注意事项（数据库迁移、环境变量、配置更新）\n- CHANGELOG 条目\n- API 文档生成（Swagger/OpenAPI）\n- 可选功能扩展\n- 性能优化建议\n- 监控指标\n\n### 6. 工具使用情况\n\n记录使用的 MCP 工具和 agents：\n- MCP 工具（context7、exa、sequential-thinking）\n- Agents（code-explorer、code-architect、code-reviewer）\n\n---\n\n## 完整输出模板\n\n参见：[总结输出模板](../assets/summary-output-template.md)\n\n---\n\n## 示例\n\n详细示例参见：[总结示例](../assets/summary-examples.md)\n",
        "skills/feat-dev/references/quick-reference.md": "# 快速参考\n\n本文档提供阶段标记模板、检查清单和常用信息。\n\n---\n\n## 阶段标记模板\n\n### 每个阶段开始\n```markdown\n---\n## 🚀 当前阶段：[X] - [阶段名称]\n---\n```\n\n### 每个阶段结束\n```markdown\n---\n✅ 阶段 [X] 完成\n📍 下一阶段：[X+1] - [阶段名称]\n---\n```\n\n### 用户输入后继续\n```markdown\n---\n📥 已收到用户输入\n🔄 继续阶段 [X] - [阶段名称]\n---\n```\n\n---\n\n## 强制检查点\n\n- **阶段 3 → 4**：使用 AskUserQuestion 后必须等待用户回应\n- **阶段 4 → 5**：**必须**等待用户确认架构方案\n- **阶段 5 → 6**：实施完成才能审查\n\n### 禁止跳跃\n- ❌ 不能从阶段 3 直接到阶段 5\n- ❌ 不能在未确认架构时开始实施\n- ❌ 收到用户输入后不能跳出 skill\n\n---\n\n## 常见实施顺序\n\n### 通用后端功能\n1. 数据层：实体定义、数据库模式\n2. 数据访问层：Repository/DAO\n3. 服务层：业务逻辑、事务管理\n4. 传输对象：DTO/请求响应结构\n5. API 层：控制器/路由处理\n6. 验证：输入验证、错误处理\n7. 测试：单元测试、集成测试\n\n### 前端功能\n1. 数据模型：类型定义、接口\n2. API 客户端：HTTP 请求封装\n3. 状态管理：Store/Context\n4. UI 组件：可复用组件\n5. 页面组件：完整页面\n6. 路由：路由配置\n7. 测试：组件测试、E2E 测试\n\n### 全栈功能\n1. 数据库设计\n2. 后端 API 实现\n3. API 文档和测试\n4. 前端数据模型\n5. 前端 UI 实现\n6. 集成测试\n7. 端到端测试\n\n---\n\n## 安全检查清单\n\n### 输入验证\n- [ ] 所有用户输入都经过验证\n- [ ] 验证数据类型、长度、格式\n- [ ] 验证文件上传类型和大小\n- [ ] 验证 ID 和数值范围\n\n### 认证和授权\n- [ ] 需要认证的端点添加了认证中间件\n- [ ] 正确验证了用户权限\n- [ ] 用户只能访问自己的资源\n\n### 注入防护\n- [ ] 使用参数化查询防止 SQL 注入\n- [ ] 验证和转义用户输入防止 XSS\n- [ ] 防止命令注入\n\n### 敏感信息\n- [ ] 不在日志中记录密码、token\n- [ ] 不在响应中返回敏感字段\n- [ ] 使用环境变量存储敏感配置\n- [ ] 对敏感数据加密存储\n\n### 错误处理\n- [ ] 不在错误消息中暴露内部实现细节\n- [ ] 统一的错误响应格式\n- [ ] 使用正确的 HTTP 状态码\n\n---\n\n## 性能优化检查\n\n### 数据库\n- [ ] 为常用查询字段添加索引\n- [ ] 避免 N+1 查询问题\n- [ ] 使用预加载/联合查询\n- [ ] 使用分页限制返回数据量\n- [ ] 只查询需要的字段\n\n### API\n- [ ] 实施请求速率限制\n- [ ] 使用缓存减少重复计算\n- [ ] 压缩响应数据\n- [ ] 使用 CDN 分发静态资源\n\n### 前端\n- [ ] 代码分割和懒加载\n- [ ] 图片优化和懒加载\n- [ ] 使用虚拟滚动处理大列表\n- [ ] 防抖和节流用户输入\n\n---\n\n## 常用命令参考\n\n### 测试命令\n```bash\n# 运行所有测试\nnpm test / go test ./... / pytest\n\n# 运行特定测试\nnpm test -- <file> / go test -run <test> / pytest <file>\n\n# 测试覆盖率\nnpm run coverage / go test -cover / pytest --cov\n```\n\n---\n\n## 降级决策流程\n\n```\n尝试 MCP 工具\n  ↓\n成功？\n  ├─ 是 → 继续使用\n  └─ 否 → 立即切换降级方案 → 继续工作流（不中断）\n```\n\n**重要**：永远不要因为 MCP 工具不可用而中断工作流。\n",
        "skills/feat-dev/references/specialized-agents.md": "# 专门化 Agents (Specialized Agents)\n\n## 概述\n\n本 skill 使用三个外部专门化 agents（位于 `agents/` 目录），每个 agent 负责特定任务，提升整体效率和质量。\n\n## Agents 清单\n\n| Agent | 用途 | 使用阶段 | 并行数量 |\n|-------|------|---------|---------|\n| **code-explorer** | 深度分析代码库，追踪执行路径，映射架构层次 | 代码库探索 | 2-3 个 |\n| **code-architect** | 设计功能架构蓝图，分析现有模式，制定实施方案 | 架构设计 | 1-3 个 |\n| **code-reviewer** | 代码审查，识别 bug、安全漏洞、代码质量问题和规范违反 | 质量审查 | 3-5 个 |\n\n## 调用方式\n\n### 基本原则\n\n- 使用 **Task 工具**调用 agents\n- **必须显式指定 `model` 参数**（如 `model: \"haiku\"` 或 `model: \"sonnet\"`），否则会从父进程继承（使用 sonnet）\n- 并行执行时必须设置 `run_in_background: true`\n- **必须在单个消息中发起所有并行任务**\n\n### 并行调用（探索和审查阶段）\n\n```markdown\n关键要求：必须在单个消息中发起所有 Task 调用\n\n示例（启动 3 个并行 agents）：\n1. 在一个消息中发起 3 个 Task 工具调用\n2. 每个 Task 设置 run_in_background: true\n3. 继续其他工作（如阅读文件）\n4. 使用 TaskOutput 收集每个 agent 的结果\n```\n\n### 单个调用（架构设计阶段）\n\n```markdown\n启动 1 个 agent，阻塞等待结果：\n- run_in_background: false（或省略此参数）\n- 等待 agent 完成后继续\n```\n\n## Agent 详细说明\n\n### code-explorer\n\n**用途**：深度分析代码库，追踪执行路径，映射架构层次，理解设计模式和抽象\n\n**使用阶段**：代码库探索（阶段 2）\n\n**并行策略**：\n- 按架构层次分解（数据层、服务层、API 层）\n- 按功能模块分解（核心模块、关联模块）\n- 按关注点分解（现有实现、错误处理、测试、配置）\n\n**输出要求**：\n- 返回 5-10 个关键文件路径\n- 识别设计模式和代码风格\n- 梳理技术栈和依赖\n- 标注必须阅读的文件\n\n**调用示例**：\n```markdown\nTask(\n    subagent_type=\"spec-dev:code-explorer\",\n    description=\"探索数据层架构\",\n    prompt=\"分析数据层：实体、数据库模式、数据关联。返回5-10个关键文件路径。\",\n    model=\"haiku\",\n    run_in_background=true,\n    enableTaskList=true,      # 可选：启用子任务跟踪\n    parentTaskId=task.id      # 父任务ID\n)\n```\n\n### code-architect\n\n**用途**：设计功能架构蓝图，分析现有模式，制定实施方案\n\n**使用阶段**：架构设计（阶段 4）\n\n**调用模式**：\n\n**模式 1：单方案设计**（简单/中等需求）\n- 主进程使用 ultrathink 深度分析\n- 启动 1 个 code-architect agent 细化设计\n- `run_in_background: false`（阻塞等待）\n\n**模式 2：多方案设计**（复杂需求）\n- 并行启动 2-3 个 code-architect agents\n- 每个 agent 设计不同的备选方案\n- `run_in_background: true`（并行执行）\n\n**输出要求**：\n- 数据库设计（实体、表结构、关联、索引）\n- API 端点设计（方法、路径、请求/响应、认证）\n- 服务层设计（服务接口、依赖关系、业务逻辑）\n- 详细实施步骤（编号列表）\n\n**调用示例（单方案）**：\n```markdown\nTask(\n    subagent_type=\"spec-dev:code-architect\",\n    description=\"设计架构方案\",\n    prompt=\"[使用结构化上下文模板]\",\n    model=\"sonnet\",\n    run_in_background=false  # 阻塞等待\n)\n```\n\n**调用示例（多方案）**：\n```markdown\n# 在单个消息中发起所有 Task 调用：\n\nTask 1: 设计最小改动方案\n- description: \"设计最小改动架构方案\"\n- prompt: \"[使用结构化上下文模板，方案类型为'最小改动方案']\"\n- subagent_type: \"spec-dev:code-architect\"\n- model: \"sonnet\"\n- run_in_background: true\n\nTask 2: 设计清晰架构方案\n- description: \"设计清晰架构方案\"\n- prompt: \"[使用结构化上下文模板，方案类型为'清晰架构方案']\"\n- subagent_type: \"spec-dev:code-architect\"\n- model: \"sonnet\"\n- run_in_background: true\n\nTask 3: 设计实用平衡方案\n- description: \"设计实用平衡方案\"\n- prompt: \"[使用结构化上下文模板，方案类型为'实用平衡方案']\"\n- subagent_type: \"spec-dev:code-architect\"\n- model: \"sonnet\"\n- run_in_background: true\n```\n\n### code-reviewer\n\n**用途**：代码审查，识别 bug、安全漏洞、代码质量问题和规范违反\n\n**使用阶段**：质量审查（阶段 6）\n\n**并行策略**：\n- 简单需求：1 个 agent（全面审查）\n- 复杂需求：3-5 个 agents（每个聚焦特定维度）\n\n**审查维度**：\n1. Bug 和逻辑错误 - 功能正确性\n2. 代码风格和质量 - 简洁性/DRY/优雅性\n3. 项目规范遵循 - CLAUDE.md、架构模式、命名约定\n4. 安全性审查 - 注入、XSS、认证授权等（可选）\n5. 性能审查 - 查询优化、缓存策略等（可选）\n\n**输出要求**：\n- 问题列表\n- 每个问题标注严重性（高/中/低）\n- 每个问题标注置信度（0-100）\n- 改进建议\n\n**调用示例（并行审查）**：\n```markdown\n# 在单个消息中发起所有 Task 调用：\n\nTask 1: Bug 和逻辑错误审查\n- description: \"审查Bug和逻辑错误\"\n- prompt: \"审查代码中的Bug、逻辑错误、空值处理等问题。返回问题列表，每个问题标注严重性（高/中/低）和置信度（0-100）。\"\n- subagent_type: \"spec-dev:code-reviewer\"\n- model: \"haiku\"\n- run_in_background: true\n- enableTaskList: true  # 启用子任务跟踪\n\nTask 2: 代码风格和质量审查\n- description: \"审查代码风格和质量\"\n- prompt: \"审查代码重复、函数复杂度、命名清晰度等质量问题。返回问题列表，每个问题标注严重性和置信度。\"\n- subagent_type: \"spec-dev:code-reviewer\"\n- model: \"haiku\"\n- run_in_background: true\n- enableTaskList: true\n\nTask 3: 项目规范遵循审查\n- description: \"审查项目规范遵循\"\n- prompt: \"审查是否遵循项目规范（CLAUDE.md等）、架构模式、命名约定等。返回问题列表，每个问题标注严重性和置信度。\"\n- subagent_type: \"spec-dev:code-reviewer\"\n- model: \"haiku\"\n- run_in_background: true\n- enableTaskList: true\n```\n\n## 结果收集\n\n使用 **TaskOutput** 工具收集并行 agent 的结果：\n\n```markdown\n# 收集所有并行 agents 的结果\nresults = []\nfor task_id in parallel_task_ids:\n    result = TaskOutput(task_id=task_id, block=true)\n    results.append(result)\n\n# 整合结果\nintegrated_results = integrate(results)\n```\n\n## 重要注意事项\n\n1. **必须在单个消息中发起所有并行任务** - 这是最关键的要求\n2. **每个 agent 必须返回具体产出** - 文件路径、问题列表、设计方案等\n3. **主进程必须亲自阅读关键文件** - 不能仅依赖 agent 的摘要\n4. **整合所有 agent 的发现** - 去重、分类、优先级排序\n5. **根据复杂度选择合适的并行策略** - 不要过度并行化\n",
        "skills/feat-dev/references/task-list-management.md": "# Task List 管理 (Task List Management)\n\n## 核心功能\n\n本 skill 自动管理任务列表，提供以下功能：\n- **进度可视化**：实时显示当前执行阶段和完成进度\n- **工作流透明化**：清晰展示所有阶段流程和每个阶段的状态\n- **断点恢复**：支持中断后继续执行，自动识别断点\n- **任务可复用**：任务列表可被其他工作流引用\n\n## 自动任务管理\n\nSkill 开始时自动创建任务列表，无需手动管理。任务列表包含 N 个主任务，对应 N 个阶段：\n\n```\n[项目名称]\n├── 阶段 1: [阶段名称]\n├── 阶段 2: [阶段名称]\n├── ...\n└── 阶段 N: [阶段名称]\n```\n\n## 进度显示格式\n\n每个阶段开始/结束时显示当前进度：\n\n```markdown\n### 任务进度\n[项目名称] - 总进度: X% (Y/N 阶段完成)\n\n[完成] 阶段 1: [名称] (已完成)\n[完成] 阶段 2: [名称] (已完成)\n[跳过] 阶段 3: [名称] (已跳过)\n[进行中] 阶段 4: [名称] (进行中...)\n[等待] 阶段 5-N: (等待中)\n```\n\n## 任务管理操作\n\n### 基本操作\n\n```markdown\n# 开始阶段时\ntasks = TaskList()\ntask = findTaskBySubject(tasks, \"阶段 X: [阶段名称]\")\nTaskUpdate(task.id, status=\"in_progress\", owner=\"[skill-name]\")\n\n# 完成阶段时\nTaskUpdate(task.id, status=\"completed\")\n```\n\n### 条件执行阶段\n\n对于条件执行的阶段（如外部资源研究）：\n\n```markdown\n# 如果决定执行此阶段\nTaskUpdate(task.id, status=\"in_progress\", owner=\"[skill-name]\")\n\n# 如果跳过此阶段（标记为 completed，解除对下一阶段的阻塞）\nTaskUpdate(task.id, status=\"completed\", metadata={note: \"不满足执行条件，已跳过\"})\n```\n\n### 等待用户确认\n\n对于需要用户确认的阶段：\n\n```markdown\n# 向用户展示方案后，不要标记为 completed\n# 等待用户确认后再执行：\nTaskUpdate(task.id, status=\"completed\")\n```\n\n## 断点恢复机制\n\n如果 skill 执行中断，使用以下方法恢复：\n\n1. **检查任务状态**: `TaskList()`\n2. **查找当前任务**: 找到 `in_progress` 或 `pending` 状态的任务\n3. **继续执行**: 从该任务继续\n4. **跳过已完成**: 已标记为 `completed` 的阶段自动跳过\n\n### 恢复示例\n\n```markdown\n### 检测到未完成的任务列表\n\n[项目名称] - 当前进度: X%\n\n上次的进度：\n[完成] 阶段 1-N (已完成)\n[进行中] 阶段 N+1: [阶段名称] (进行中)\n\n是否从阶段 N+1 继续执行？\n```\n\n## 错误处理与降级\n\n如果 Task list 功能不可用（MCP 服务故障等），skill 会自动降级到无 Task list 模式，继续执行主流程，并向用户说明情况。\n\n```markdown\n### Task List 功能不可用\n\nTask list 功能暂时不可用，将使用标准模式执行工作流。\n\n[继续执行主流程...]\n```\n\n## 最终进度显示\n\n所有阶段完成后：\n\n```markdown\n### [完成] 所有阶段完成！\n\n[项目名称] - 100% 完成\n\n📝 阶段完成情况：\n[完成] 阶段 1: [阶段名称]\n[完成] 阶段 2: [阶段名称]\n[跳过] 阶段 3: [阶段名称] (已跳过)\n...\n[完成] 阶段 N: [阶段名称]\n\n项目成功完成！\n```\n",
        "skills/feat-dev/references/troubleshooting.md": "# 故障排查指南\n\n本文档提供常见问题的排查和解决方案。\n\n---\n\n## MCP 工具问题\n\n### MCP 工具调用失败\n\n**症状**：MCP 工具（context7、exa、sequential-thinking）调用返回错误\n\n**排查步骤**：\n1. 确认 MCP 服务器是否正在运行\n2. 检查 MCP 配置文件是否正确\n3. 查看 MCP 服务器日志\n\n**解决方案**：\n- **立即切换到降级方案**，不要中断工作流\n- 记录失败情况，继续使用降级工具完成任务\n- 在总结阶段报告 MCP 工具问题\n\n**降级方案参考**：\n- context7 → WebSearch + Grep + Read\n- exa → WebSearch\n- sequential-thinking → EnterPlanMode 或思维链分析\n\n### MCP 工具返回不相关内容\n\n**症状**：查询结果与需求不匹配\n\n**原因**：查询关键词不够精确\n\n**解决方案**：\n1. 优化查询关键词，增加上下文\n2. 尝试不同的查询方式\n3. 如果多次失败，切换到降级方案\n\n**示例**：\n```bash\n# 不够精确\ncontext7.query-docs: query=\"gin\"\n\n# 更精确\ncontext7.resolve-library-id: libraryName=\"gin\", query=\"需要了解 Gin 框架的中间件认证功能\"\ncontext7.query-docs: libraryId=\"/gin-gonic/gin\", query=\"middleware authentication patterns\"\n```\n\n---\n\n## Agent 执行问题\n\n### Agent 找不到文件\n\n**症状**：Agent 报告找不到指定的文件或目录\n\n**排查步骤**：\n1. 确认文件路径是否正确\n2. 检查当前工作目录\n3. 验证文件是否存在\n\n**解决方案**：\n```bash\n# 检查文件是否存在\nls -la /path/to/file\n\n# 检查当前工作目录\npwd\n\n# 使用绝对路径而不是相对路径\n```\n\n### Agent 超时\n\n**症状**：Agent 执行时间过长或超时\n\n**原因**：\n- 搜索范围太大\n- 代码库太大\n- 任务过于复杂\n\n**解决方案**：\n1. 缩小搜索范围（使用更精确的 glob pattern）\n2. 拆分任务，分多个 agents 并行执行\n3. 增加超时时间（如果合理）\n\n### Agent 结果不符合预期\n\n**症状**：Agent 返回的分析结果不准确或不完整\n\n**解决方案**：\n1. 检查传递给 agent 的 prompt 是否清晰\n2. 提供更多上下文信息\n3. 亲自验证 agent 的发现\n4. 必要时手动补充分析\n\n---\n\n## CLAUDE.md 相关问题\n\n### CLAUDE.md 文件缺失\n\n**症状**：项目根目录没有 CLAUDE.md 文件\n\n**影响**：无法了解项目规范和约定\n\n**解决方案**：\n1. 通过代码探索推断项目规范：\n   - 查看现有代码的组织结构\n   - 识别命名约定\n   - 识别设计模式\n   - 查找配置文件（.editorconfig、.eslintrc 等）\n\n2. 记录推断的规范\n\n3. 在总结阶段建议创建 CLAUDE.md\n\n### CLAUDE.md 规范不明确\n\n**症状**：CLAUDE.md 存在但描述模糊\n\n**解决方案**：\n1. 查看实际代码验证规范\n2. 在阶段 3 向用户澄清不明确的规范\n3. 以实际代码为准\n4. 在总结阶段建议完善 CLAUDE.md\n\n### CLAUDE.md 规范与最佳实践冲突\n\n**症状**：项目规范与行业最佳实践不一致\n\n**解决方案**：\n1. **优先遵循 CLAUDE.md**（项目一致性更重要）\n2. 如果规范确实有问题，在总结阶段：\n   - 说明冲突情况\n   - 解释为什么最佳实践更优\n   - 建议更新 CLAUDE.md\n\n---\n\n## 代码实施问题\n\n### 依赖库版本冲突\n\n**症状**：导入的库与项目现有版本不兼容\n\n**解决方案**：\n1. 检查项目的依赖文件（package.json、项目依赖配置文件（如 package.json, requirements.txt, go.mod, pom.xml） 等）\n2. 使用项目中已安装的版本\n3. 如需升级，与用户确认\n\n### 找不到合适的实现模式\n\n**症状**：不确定如何实现某个功能\n\n**解决方案**：\n1. 使用 context7 或 WebSearch 查询官方文档\n2. 使用 Grep 搜索项目中的类似实现\n3. 使用 exa 搜索代码示例\n4. 向用户询问偏好的实现方式\n\n### 实施中发现需求理解有误\n\n**症状**：代码写到一半发现与需求不符\n\n**解决方案**：\n1. **立即停止实施**\n2. 与用户澄清理解\n3. 如有必要，回到阶段 3 或 4\n4. 更新设计后重新实施\n\n---\n\n## 质量审查问题\n\n### Reviewers 意见相互矛盾\n\n**症状**：不同 reviewers 对同一段代码有不同的评价\n\n**解决方案**：\n1. 亲自审查相关代码\n2. 以实际代码和项目规范为准\n3. 考虑每个 reviewer 的审查焦点（bug vs 质量 vs 规范）\n4. 使用判断力权衡不同意见\n\n### 发现问题太多，无法全部修复\n\n**症状**：审查发现数十个问题，修复时间过长\n\n**解决方案**：\n1. 按优先级分类：\n   - 必须修复：高置信度 bug、安全问题、严重规范违反\n   - 应该修复：中置信度 bug、严重质量问题\n   - 可选修复：一般质量问题、轻微规范问题\n\n2. 聚焦于必须修复的问题\n\n3. 记录其他问题供后续改进\n\n4. 与用户沟通，确认优先级\n\n### Reviewer 报告 false positive\n\n**症状**：Reviewer 报告的问题实际上不存在\n\n**解决方案**：\n1. 亲自验证问题\n2. 如果确认是 false positive，标记并忽略\n3. 记录在总结阶段，帮助改进 reviewer prompts\n\n---\n\n## 性能问题\n\n### 工作流执行太慢\n\n**症状**：整个 7 阶段流程耗时过长\n\n**原因分析**：\n- 代码库太大\n- 并行 agents 太多或太少\n- 搜索范围太广\n- MCP 工具响应慢\n\n**优化方案**：\n1. **缩小搜索范围**：\n   - 使用更精确的 glob patterns\n   - 聚焦于最相关的目录\n\n2. **优化并行策略**：\n   - 阶段 2：2-3 个 code-explorer agents\n   - 阶段 6：3 个 code-reviewer agents\n   - 不要启动过多 agents\n\n3. **使用降级方案**：\n   - 如果 MCP 工具慢，直接用降级方案\n\n4. **跳过可选步骤**：\n   - code-architect agent 是可选的\n   - 简单需求不使用 ultrathink\n\n### 数据库查询性能差\n\n**症状**：实施的代码存在性能问题\n\n**常见原因**：\n- N+1 查询问题\n- 缺少索引\n- 查询返回过多数据\n- 没有使用分页\n\n\n---\n\n## 架构设计问题\n\n### ultrathink 分析不够深入\n\n**症状**：sequential-thinking 的分析结果过于简单\n\n**解决方案**：\n1. 增加 totalThoughts 数量\n2. 在每个 thought 中提供更多上下文\n3. 明确要求分析的方面（数据结构、API、服务层等）\n4. 如果降级，使用 EnterPlanMode 进行更详细的规划\n\n### 架构设计与现有代码冲突\n\n**症状**：设计的架构与项目现有模式不一致\n\n**解决方案**：\n1. 重新审查现有代码模式\n2. 调整设计以保持一致性\n3. 如果确实需要新模式，与用户确认\n4. 在总结阶段说明架构变更原因\n\n---\n\n## 用户沟通问题\n\n### 用户未回应澄清问题\n\n**症状**：使用 AskUserQuestion 后用户没有回应\n\n**解决方案**：\n1. 等待用户回应（不要继续）\n2. 不要猜测或假设答案\n3. 如果问题不是必须的，可以采用保守方案并说明原因\n\n### 用户反复修改需求\n\n**症状**：用户在实施过程中多次修改需求\n\n**解决方案**：\n1. 保持耐心，这是正常的\n2. 每次变更后更新需求理解\n3. 如果变更较大，建议重新设计架构\n4. 在总结阶段记录需求变更历史\n\n---\n\n## 一般建议\n\n### 遇到未知问题\n\n1. **不要慌张**：系统性地分析问题\n2. **查阅文档**：使用 context7/WebSearch\n3. **参考现有代码**：使用 Grep/Read\n4. **寻求帮助**：向用户提问\n5. **记录问题**：在总结阶段报告\n\n### 工作流卡住\n\n如果在某个阶段卡住：\n\n1. **回顾前一阶段**：确认前置条件是否满足\n2. **简化问题**：拆分为更小的步骤\n3. **尝试不同方法**：MCP 工具、降级方案、手动分析\n4. **与用户沟通**：说明遇到的困难，寻求指导\n\n### 保持工作流完整性\n\n**核心原则**：不要因为工具问题而中断工作流\n\n- MCP 工具失败 → 使用降级方案\n- Agent 失败 → 手动执行相应任务\n- 信息不足 → 向用户提问\n\n**目标**：无论遇到什么问题，都要完成 7 个阶段，交付完整的功能。\n",
        "skills/feat-dev/references/workflow-control.md": "# 工作流控制\n\n⚠️ **CRITICAL - 工作流执行规则**：\n- **必须严格按照 1→2→3→4→5→6→7 的顺序执行**\n- **每个阶段必须完整执行，禁止跳过**\n- **在强制检查点必须停止并等待用户输入**\n- **收到用户输入后必须继续当前阶段，不得跳出工作流**\n\n## 阶段声明要求\n\n**⚠️ 每个阶段开始时 MUST 输出（强制）**：\n```markdown\n---\n## 🚀 当前阶段：[X] - [阶段名称]\n\n⚠️ WORKFLOW CHECKPOINT: 当前处于阶段 [X]，必须完成本阶段所有任务后才能进入阶段 [X+1]\n---\n```\n\n**⚠️ 每个阶段结束时 MUST 输出（强制）**：\n```markdown\n---\n✅ 阶段 [X] 完成\n\n📋 本阶段产出：\n- [列出主要产出]\n\n📍 下一阶段：[X+1] - [阶段名称]\n\n⚠️ WORKFLOW CHECKPOINT: 准备进入阶段 [X+1]\n---\n```\n\n## 用户输入后的继续机制\n\n⚠️ **CRITICAL - 收到用户输入后的处理规则**：\n\n当用户在阶段中提供输入（如回答澄清问题、确认架构方案）后，**MUST 执行以下步骤**：\n\n1. **MUST 确认收到输入**：\n```markdown\n---\n📥 已收到用户输入\n\n⚠️ WORKFLOW CHECKPOINT: 继续阶段 [X] - [阶段名称]\n（禁止跳出当前 skill，禁止跳过任何阶段）\n---\n```\n\n2. **MUST 处理用户输入**：整合到当前阶段的分析中\n\n3. **MUST 继续当前阶段**：完成阶段剩余工作\n\n4. **MUST 完成阶段后才能进入下一阶段**：输出阶段完成标记\n\n5. **CRITICAL - 绝对禁止**：\n   - ❌❌❌ 跳出当前 skill（除非用户明确要求）\n   - ❌❌❌ 重新评估 skill 触发条件\n   - ❌❌❌ 跳过任何阶段（如从阶段 1 直接到阶段 5）\n   - ❌❌❌ 在未完成当前阶段时进入下一阶段\n   - ❌❌❌ 在收到用户输入后直接开始实施（必须先完成阶段 3 和阶段 4）\n\n## 强制检查点（MANDATORY CHECKPOINTS）\n\n以下检查点是**强制性的**，必须停止并等待用户输入：\n\n### 阶段 1 → 2\n\n- 完成需求理解后，**MUST 输出阶段完成标记**\n- 然后进入阶段 2（代码库探索）\n- ❌ 禁止在阶段 1 收到用户输入后直接跳到阶段 2 之后的任何阶段\n\n### 阶段 3 → 4（如有澄清问题）\n\n- 如果使用了 AskUserQuestion，**MUST 停止并等待用户回应**\n- **MUST 收到回应后输出确认标记**（见上方\"用户输入后的继续机制\"）\n- **MUST 继续阶段 3 完成澄清**\n- **MUST 输出阶段 3 完成标记**\n- 然后才能进入阶段 4\n- ❌❌❌ **CRITICAL**：禁止收到用户回应后直接跳到阶段 5（实施）\n\n### 阶段 4 → 5（CRITICAL CHECKPOINT）\n\n- **⚠️⚠️⚠️ 这是最关键的检查点**\n- **MUST 等待用户明确确认架构方案**（必须看到用户回复\"确认\"、\"可以\"、\"开始实施\"等明确同意的词）\n- 用户确认前**ABSOLUTELY PROHIBITED 开始实施**（绝对禁止）\n- 如果用户要求修改，**MUST 更新设计并重新请求确认**\n- **MUST 收到确认后输出确认标记和阶段完成标记**\n- ❌❌❌ **CRITICAL**：禁止在用户未确认的情况下开始任何实施工作\n- ❌❌❌ **CRITICAL**：禁止假设用户默认同意\n- ❌❌❌ **CRITICAL**：禁止在展示架构设计后直接开始实施\n\n### 阶段 5 → 6\n\n- 实施必须完成\n- **MUST 输出阶段完成标记**\n- 然后进入阶段 6（质量审查）\n- ❌ 禁止在实施中途跳到审查\n\n## 阶段顺序规则\n\n⚠️ **CRITICAL - 严格的阶段执行顺序**：\n\n**必须按此顺序执行**：1 → 2 → 3 → 4 → 5 → 6 → 7\n\n**每个阶段的执行要求**：\n1. **阶段 1（需求理解）**：MUST 完成需求分析\n2. **阶段 2（代码库探索）**：MUST 完成代码探索和文件阅读\n3. **阶段 3（澄清问题）**：MUST 完成问题澄清（如有疑问必须提问）\n4. **阶段 4（架构设计）**：MUST 完成设计并**等待用户确认**\n5. **阶段 5（实施）**：仅在用户确认后 MUST 完成实施\n6. **阶段 6（质量审查）**：MUST 完成代码审查\n7. **阶段 7（总结）**：MUST 完成总结\n\n**允许回退（向前回退）**：\n- ✅ 阶段 5 发现需求理解有误 → 回退到阶段 3 或 4\n- ✅ 阶段 4 用户要求修改设计 → 停留在阶段 4 更新设计\n- ✅ 任何阶段发现问题 → 可以回退到之前的阶段重新分析\n\n**❌❌❌ ABSOLUTELY PROHIBITED（绝对禁止的跳跃）**：\n- ❌❌❌ 从阶段 1 直接到阶段 5（跳过探索、澄清、设计）\n- ❌❌❌ 从阶段 2 直接到阶段 5（跳过澄清和设计）\n- ❌❌❌ 从阶段 3 直接到阶段 5（跳过架构设计）\n- ❌❌❌ 从阶段 4 直接到阶段 5 而未等待用户确认\n- ❌❌❌ 在用户提供输入后跳过多个阶段\n- ❌❌❌ 在任何阶段未完成时进入下一阶段\n\n**⚠️ 违反阶段顺序的常见错误模式**：\n```\n错误模式 1: 阶段 1 → 直接开始代码探索并实施\n正确做法: 阶段 1 → 阶段 2 → 阶段 3 → 阶段 4 → [等待确认] → 阶段 5\n\n错误模式 2: 阶段 1 → 用户回复 → 直接实施\n正确做法: 阶段 1 → 阶段 2 → 阶段 3 → 阶段 4 → [等待确认] → 阶段 5\n\n错误模式 3: 阶段 4 设计完成 → 直接实施\n正确做法: 阶段 4 设计完成 → 请求用户确认 → [停止等待] → 收到确认 → 阶段 5\n\n错误模式 4: 收到用户输入 → 跳出 skill\n正确做法: 收到用户输入 → 确认收到 → 继续当前阶段 → 完成后进入下一阶段\n```\n",
        "skills/feat-dev/skill.md": "---\nname: feat-dev\ndescription: 提供 7 阶段功能开发工作流（需求理解、代码探索、澄清问题、架构设计、实施、质量审查、总结）。适用于新功能实施、API/数据库/服务架构设计、代码重构和多模块开发。当用户提出功能开发、架构设计或代码重构需求时触发。\n---\n\n# 功能开发技能\n\n提供系统化的 7 阶段功能开发工作流，确保从需求理解到质量交付的完整过程。\n\n---\n\n## 快速开始\n\n**工作流** (阶段 1-7)：\n```\n需求理解 → 代码探索 → 澄清问题 → 架构设计 → 实施 → 质量审查 → 总结\n```\n\n**核心特性**：\n- 深度分析：复杂需求使用 sequential-thinking\n- 并行 agents：code-explorer、code-architect、code-reviewer\n- Task List 管理：进度可视化、断点恢复\n- MCP 工具：优先使用 context7、exa，自动降级\n\n**与 requirement-analysis 的区别**：\n- 本技能：完整实施流程，从需求到代码交付\n- requirement-analysis：专注分析和规划，不包含代码实施\n\n---\n\n## Task List 管理\n\n本技能自动管理任务列表，提供进度可视化和断点恢复能力。\n\n**详细指南**：[Task List 管理](references/task-list-management.md)\n\n**基础模式**：\n```markdown\n# 开始阶段时\ntasks = TaskList()\ntask = findTaskBySubject(tasks, \"阶段 X: 阶段名称\")\nTaskUpdate(task.id, status=\"in_progress\", owner=\"feat-dev\")\n\n# 完成阶段时\nTaskUpdate(task.id, status=\"completed\")\n```\n\n---\n\n## Ultrathink 使用指南\n\n**工具**：`mcp__sequential-thinking__sequentialthinking`\n\n**何时使用**：\n- ✅ 阶段1：需求涉及多个模块、复杂业务逻辑、描述模糊\n- ✅ 阶段4（模式1）：简单/中等需求，主进程必须使用\n- ❌ 阶段4（模式2）：复杂需求多方案设计，不使用主进程 ultrathink\n- ❌ 简单 CRUD 或字段添加可跳过\n\n**使用方法**：\n```markdown\n阶段1使用时：\n- 分解需求组件、识别依赖关系、分析潜在风险\n\n阶段4（模式1）使用时：\n- 分析可能的实现路径\n- 做出关键架构决策\n- 识别主要风险和权衡点\n- 确定推荐的架构方向\n```\n\n---\n\n## 专门化 Agents\n\n本技能使用三个专门化 agents 提升效率：\n- **code-explorer**：深入探索代码库\n- **code-architect**：设计详细架构方案\n- **code-reviewer**：全面审查代码质量\n\n**详细指南**：[专门化 Agents](references/specialized-agents.md)\n\n---\n\n## 工作流程\n\n### 阶段 1: 需求理解\n\n**目标**：全面理解用户需求\n\n**执行要点**：\n- 识别核心功能、业务实体、API 端点、业务规则、集成点\n- 根据复杂度决定是否使用 ultrathink\n- 可选：搜索类似实现案例（exa/WebSearch）\n\n**产出**：需求理解摘要\n\n**详细指南**：[阶段 1: 需求理解](references/phase-1-discovery.md)\n\n---\n\n### 阶段 2: 代码库探索\n\n**目标**：深入理解现有代码库\n\n**执行要点**：\n1. **首要任务**：查找并阅读项目根目录的 CLAUDE.md 文件\n2. **并行启动 2-3 个 code-explorer agents**：\n   - 必须在单个消息中发起所有 Task 调用\n   - 每个 Task 设置 `run_in_background: true`\n   - Agent 分工：数据层、业务逻辑层、API 层\n3. **读取所有 agent 识别的文件** - 主进程必须亲自阅读\n4. **整合发现**：汇总探索结果、识别设计模式、梳理技术栈\n5. 可选：使用 context7 查询依赖库文档\n\n**产出**：代码库探索报告\n\n**详细指南**：[阶段 2: 代码库探索](references/phase-2-exploration.md)\n\n**并行示例**：[并行模式指南](../requirement-analysis/references/parallel-patterns.md)\n\n---\n\n### 阶段 3: 澄清问题\n\n**目标**：填补需求空白，解决模糊和歧义\n\n**执行要点**：\n- 识别需要澄清的情况：模糊需求、多实施方法、业务规则细节、技术选型\n- **必须**使用 AskUserQuestion 工具\n- 记录用户反馈，更新需求理解\n\n**产出**：澄清结果或\"无需澄清\"\n\n**详细指南**：[阶段 3: 澄清问题](references/phase-3-clarify.md)\n\n---\n\n### 阶段 4: 架构设计\n\n**目标**：设计详细的实施方案\n\n**关键检查点**：最关键检查点 - 必须等待用户明确确认后才能开始实施\n\n**步骤 1: 准备结构化上下文**\n- 整理阶段 1-3 的结果（需求、探索发现、用户澄清）\n- 使用结构化模板确保完整性\n\n**步骤 2: 判断需求复杂度**\n\n**简单/中等需求** → **模式1：单方案设计**\n- 单一功能或 2-3 个模块\n- 实现路径清晰\n- 不涉及重大架构变更\n\n**复杂需求** → **模式2：多方案设计**\n- 多种明显不同的实现路径\n- 重大架构权衡\n- 影响 3 个以上核心模块\n- 引入新技术或架构模式\n\n**步骤 3: 执行对应设计模式**\n\n**模式1：单方案设计**\n1. 主进程使用 ultrathink 深度分析\n2. 启动单个 code-architect agent 细化设计\n3. 读取推荐的架构文件\n4. 向用户展示单一方案并请求确认\n\n**模式2：多方案设计**\n1. 并行启动 2-3 个 code-architect agents（必须在单个消息中）\n2. 读取所有 agents 推荐的架构文件\n3. 整合所有方案，对比优劣势\n4. 向用户展示多方案对比并请求选择\n\n**产出**：\n- 模式1：主进程 ultrathink 分析 + 单个详细设计方案\n- 模式2：多方案对比 + 权衡分析 + 推荐意见\n\n**详细指南**：[阶段 4: 架构设计](references/phase-4-design.md)\n\n---\n\n### 阶段 5: 实施\n\n**目标**：按照架构设计实施功能\n\n**前置条件**：用户已确认架构方案\n\n**执行要点**：\n- 按阶段 4 规划的步骤实施（数据层 → 数据访问层 → 服务层 → DTO → API 层 → 验证）\n- 严格遵循 CLAUDE.md 规范和现有模式\n- 每完成一个模块及时测试\n- 可选：使用 context7 查询 API 文档\n\n**实施原则**：\n- 保持代码简洁，避免过度设计\n- 安全第一（防止注入、XSS、认证授权等）\n- 遵循项目现有模式\n\n**产出**：完整的功能实现代码\n\n**详细指南**：[阶段 5: 实施](references/phase-5-implement.md)\n\n---\n\n### 阶段 6: 质量审查\n\n**目标**：确保代码质量\n\n**执行要点**：\n1. **并行启动 3 个 code-reviewer agents**：\n   - 必须在单个消息中发起所有 Task 调用\n   - 每个 Task 设置 `run_in_background: true`\n   - Reviewer 分工：Bug/逻辑、代码风格、规范遵循\n2. **整合审查结果**：收集发现、去重、按严重性分类\n3. **向用户展示发现并询问决策**：\n   - 选项 A：立即修复所有高严重性问题（推荐）\n   - 选项 B：立即修复高置信度 bug，其他稍后处理\n   - 选项 C：按现状继续，记录问题供后续处理\n4. **根据用户决策执行**：按选择的策略修复问题\n\n**修复策略**：\n- 必须修复：高置信度 bug（≥80%）、严重规范违反\n- 应该修复：中置信度 bug（60-79%）、严重质量问题\n- 可选修复：一般质量问题、低置信度 bug（<60%）\n\n**产出**：审查报告、修复记录、质量评分\n\n**详细指南**：[阶段 6: 质量审查](references/phase-6-review.md)\n\n---\n\n### 阶段 7: 总结\n\n**目标**：全面总结实施成果\n\n**输出内容**：\n1. **变更摘要**：实现了什么功能\n2. **修改文件列表**：所有新增和修改的文件\n3. **API 变更**：新增的 API 端点\n4. **数据库变更**：新增或修改的表/字段\n5. **后续建议**：测试计划、部署注意事项、CHANGELOG、优化建议\n6. **工具使用情况**：MCP 工具和 agents 使用记录\n\n**产出**：完整总结文档\n\n**详细指南**：[阶段 7: 总结](references/phase-7-summary.md)\n\n---\n\n## 工作流控制\n\n**关键执行规则**：\n- 必须严格按照 1→2→3→4→5→6→7 的顺序执行\n- 每个阶段必须完整执行，禁止跳过\n- 在关键检查点（阶段3→4，阶段4→5）必须等待用户输入\n\n**关键检查点**：\n- **阶段 3 → 4**：如使用 AskUserQuestion，必须等待用户回应\n- **阶段 4 → 5**：最关键检查点 - 必须等待用户明确确认架构方案\n- **阶段 5 → 6**：实施完成后进入审查\n\n**详细指南**：[工作流控制](references/workflow-control.md)\n\n---\n\n## 重要原则\n\n1. **自适应语言交互**：根据用户的 Claude 语言设置和输入语言沟通\n2. **严格遵循 CLAUDE.md**：必须阅读并遵守项目规范\n3. **主动提问**：不清楚的地方必须澄清（阶段 3）\n4. **善用 ultrathink**：复杂分析必须使用 Sequential Thinking\n5. **并行执行**：探索和审查阶段并行启动多个 agents\n6. **等待确认**：架构设计确认后才开始实施（阶段 4 → 5）\n7. **质量把关**：实施后必须进行代码审查（阶段 6）\n8. **不中断工作流**：MCP 工具不可用时立即使用降级方案\n\n---\n\n## 参考文档\n\n### 阶段详细指南\n- [阶段 1: 需求理解](references/phase-1-discovery.md)\n- [阶段 2: 代码库探索](references/phase-2-exploration.md)\n- [阶段 3: 澄清问题](references/phase-3-clarify.md)\n- [阶段 4: 架构设计](references/phase-4-design.md)\n- [阶段 5: 实施](references/phase-5-implement.md)\n- [阶段 6: 质量审查](references/phase-6-review.md)\n- [阶段 7: 总结](references/phase-7-summary.md)\n\n### 辅助文档\n- [Task List 管理](references/task-list-management.md)\n- [专门化 Agents](references/specialized-agents.md)\n- [Ultrathink 使用](references/ultrathink-usage.md)\n- [MCP 工具集成](references/mcp-tools.md)\n- [工作流控制](references/workflow-control.md)\n- [快速参考](references/quick-reference.md)\n- [故障排查](references/troubleshooting.md)\n- [输出格式模板](assets/output-template.md)\n",
        "skills/requirement-analysis/SKILL.md": "---\nname: requirement-analysis\ndescription: 提供系统化的 9 阶段需求分析与实施工作流（需求理解、代码探索、外部资源研究、澄清问题、深度分析、展示计划、实施开发、代码审查、总结）。适用于复杂功能开发、多方案对比、新技术栈研究等需要深度规划和完整实施的场景。当用户提出复杂功能开发、API设计、数据库设计且需要深度分析和外部资源研究时触发。\n---\n\n# 需求分析技能\n\n提供系统化的 9 阶段需求分析与实施工作流，确保从深度分析到质量交付的完整过程。\n\n---\n\n## 快速开始\n\n**工作流** (阶段 1-9)：\n```\n需求理解 → 代码探索 → 外部资源研究 → 澄清问题 → 深度分析 → 展示计划 → 实施开发 → 代码审查 → 总结\n```\n\n**核心特性**：\n- 深度分析：使用 ultrathink 进行复杂需求分析\n- 外部资源：集成 context7、exa 研究最佳实践\n- 结构化产出：详细的实施计划 + 完整代码实现\n- Task List 管理：进度可视化、断点恢复\n\n**与 feat-dev 的区别**：\n- 本技能：9 阶段，**包含外部资源研究**，适合复杂需求和新技术栈\n- feat-dev：7 阶段，快速实施流程，适合需求相对明确的场景\n\n---\n\n## Task List 管理\n\n本技能自动管理任务列表，提供进度可视化和断点恢复能力。\n\n**基础模式**：\n```markdown\n# 开始阶段时\ntasks = TaskList()\ntask = findTaskBySubject(tasks, \"阶段 X: 阶段名称\")\nTaskUpdate(task.id, status=\"in_progress\", owner=\"requirement-analysis\")\n\n# 完成阶段时\nTaskUpdate(task.id, status=\"completed\")\n```\n\n**条件执行阶段**：\n对于条件执行的阶段（如外部资源研究）：\n```markdown\n# 如果跳过此阶段\nTaskUpdate(task.id, status=\"completed\", metadata={note: \"不满足执行条件，已跳过\"})\n```\n\n**断点恢复**：如果执行中断，检查 `TaskList()` 找到 `in_progress` 或 `pending` 状态的任务并继续。\n\n**高级用法**：[Task List 管理](references/task-list-management.md)\n\n---\n\n## Ultrathink 使用指南\n\n**工具**：`mcp__sequential-thinking__sequentialthinking`\n\n**何时使用**：\n- ✅ 阶段1：需求涉及多个模块、复杂业务逻辑、描述模糊\n- ✅ 阶段5：必须使用（深度分析）\n- ❌ 简单 CRUD 或单一模块需求可跳过\n\n**使用方法**：\n```markdown\n思考内容：\n- 阶段1：分解需求组件、识别依赖关系、分析潜在风险\n- 阶段5：设计数据结构、API端点、服务层、识别边缘情况、规划实施步骤\n```\n\n---\n\n## 工作流程\n\n### 阶段 1: 需求理解\n\n**目标**：全面理解用户需求\n\n**执行要点**：\n- 识别核心功能、业务实体、API 端点、业务规则\n- 根据复杂度决定是否使用 ultrathink\n- 记录需求理解摘要\n\n**任务管理**：\n```markdown\ntask = findTaskBySubject(tasks, \"阶段 1: 需求理解\")\nTaskUpdate(task.id, status=\"in_progress\", owner=\"requirement-analysis\")\n# 完成时\nTaskUpdate(task.id, status=\"completed\")\n```\n\n---\n\n### 阶段 2: 代码库探索\n\n**目标**：全面探索代码库，理解项目架构\n\n**首要任务**：查找并阅读 **CLAUDE.md** 文件\n\n**探索模式**：\n\n**基础模式**（简单需求）：\n- 使用单个 Explore agent\n- 快速定位相关代码\n\n**并行模式**（复杂需求）：\n- 同时启动 2-5 个 Explore agent\n- 按架构层次或功能模块分解\n- ⚠️ **必须在单个消息中发起所有 Task 调用**\n- 每个任务设置 `run_in_background: true`\n- 使用 TaskOutput 收集结果\n\n**查找内容**：\n- CLAUDE.md 规范\n- 相关实体和服务\n- 现有模式和约定\n\n**并行模式示例**：[并行模式指南](references/parallel-patterns.md)\n\n---\n\n### 阶段 3: 外部资源研究 (条件执行)\n\n**目标**：研究外部资源，获取最新信息和最佳实践\n\n**执行条件**（满足任一即执行）：\n- 涉及新的第三方库或框架\n- 需要了解行业最新实践\n- 内部代码库示例不充分\n\n**工具优先级**：\n1. 网页搜索：exa MCP → WebSearch\n2. 库文档：context7 MCP → WebSearch + Grep + Read\n\n**跳过场景**：\n- 完全基于已有代码\n- 团队对技术已经熟悉\n- 时间紧急且需求简单\n\n**跳过处理**：\n```markdown\nTaskUpdate(task.id, status=\"completed\", metadata={note: \"不满足执行条件，已跳过\"})\n```\n\n---\n\n### 阶段 4: 澄清问题\n\n**目标**：解决所有不清楚、模糊或有歧义的需求点\n\n**重要**：必须使用 **AskUserQuestion 工具**\n\n**澄清内容**：\n- 模糊或规格不足的需求\n- 多个有效实施方法之间的选择\n- 业务规则细节\n- 技术选型或架构决策\n\n**最佳实践**：\n- 一次提问多个相关问题（使用 multiSelect）\n- 提供具体选项和说明影响\n- 推荐首选选项并说明理由\n\n**任务管理**：\n```markdown\ntask = findTaskBySubject(tasks, \"阶段 4: 澄清问题\")\nTaskUpdate(task.id, status=\"in_progress\", owner=\"requirement-analysis\")\n# 用户回应后\nTaskUpdate(task.id, status=\"completed\")\n```\n\n---\n\n### 阶段 5: 深度分析\n\n**目标**：使用 ultrathink 进行深度分析，设计完整的技术方案\n\n**必须使用 ultrathink**：`mcp__sequential-thinking__sequentialthinking`\n\n**分析内容**：\n1. **分析需求组件**（回顾阶段1结果）\n   - 分解为可实施的功能模块\n   - 识别模块间的依赖关系\n   - 分析潜在的技术和业务风险\n\n2. **设计数据结构**（符合 CLAUDE.md 规范）\n   - 实体/表结构定义\n   - 字段类型和约束\n   - 关联关系和索引\n\n3. **设计 API 端点**（符合 CLAUDE.md 规范）\n   - HTTP 方法、路径设计\n   - 请求/响应结构\n   - 认证和权限要求\n\n4. **设计服务层**（符合 CLAUDE.md 规范）\n   - 服务接口定义\n   - 依赖关系设计\n   - 业务逻辑流程\n\n5. **识别风险和边缘情况**\n   - 考虑阶段4中用户澄清的特殊情况\n   - 分析潜在的错误场景\n   - 规划异常处理策略\n\n6. **规划详细实施步骤**\n   - 整合所有上述分析\n   - 制定可执行的分步实施计划\n\n**注意事项**：\n虽然 ultrathink 能够访问完整对话历史，但建议明确引用和总结之前阶段的关键发现，确保分析的连贯性和准确性。\n\n---\n\n### 阶段 6: 展示实施计划\n\n**目标**：向用户展示完整的实施计划，等待确认\n\n**展示内容**：\n1. 需求总结 - 理解的核心要点\n2. 代码库发现 - 相关代码和模式\n3. 外部资源（如适用）- 搜索结果和库文档\n4. 技术设计 - 数据库、API、服务层\n5. 实施步骤 - 编号的详细步骤\n6. 风险和注意事项\n\n**重要**：在用户确认前，不要标记任务为 completed\n\n询问：\"这个实施计划看起来如何？我可以开始实施了吗？\"\n\n**用户确认后**：\n```markdown\nTaskUpdate(task.id, status=\"completed\")\n# 阶段7自动解除阻塞，可以开始\n```\n\n**输出格式**：[输出模板](assets/output-template.md)\n\n---\n\n### 阶段 7: 实施开发\n\n**目标**：基于阶段6的架构设计，实施功能代码\n\n**前提**：必须获得用户明确确认（阶段6完成）\n\n**执行原则**：\n1. 严格遵循 CLAUDE.md\n2. 按照架构设计实施功能\n3. 保持代码简洁，避免过度工程\n4. 及时验证和测试\n5. 遇到问题及时使用 AskUserQuestion\n\n**阶段职责**：\n- 编写功能代码\n- 实现设计的 API、数据结构、服务层\n- 编写单元测试（如需要）\n- 不包含代码审查（审查在阶段8）\n\n**完成标志**：\n- 所有功能代码实现完成\n- 代码通过基本测试\n- 符合项目规范\n\n---\n\n### 阶段 8: 代码审查\n\n**目标**：独立的质量把关阶段，全面审查代码质量\n\n**阶段职责**：\n- 独立的质量把关阶段\n- 检查代码质量、规范遵循\n- 识别 bug 和潜在问题\n- 提供改进建议\n\n**审查模式选择**：\n\n**单一审查模式**（简单需求）：\n- 使用 1 个 code-reviewer agent\n- 全面审查所有维度\n\n**并行深度审查模式**（复杂需求）：\n- 同时启动 3-5 个审查任务\n- 每个聚焦于特定维度（功能正确性、代码风格、规范遵循）\n- ⚠️ **必须在单个消息中发起所有 Task 调用**\n- 每个任务设置 `run_in_background: true`\n- 使用 TaskOutput 收集结果\n\n**执行步骤**：\n1. 选择审查模式（基于需求复杂度）\n2. 启动审查 agents\n3. 收集审查结果（使用 TaskOutput）\n4. 整合问题列表\n5. **使用 AskUserQuestion 询问处理方式**\n\n**审查后必须**：\n- 使用 **AskUserQuestion** 询问用户如何处理问题\n- 不得自动修复，必须征求确认\n\n**产出**：审查报告（问题列表、严重性标注）、改进建议\n\n---\n\n### 阶段 9: 总结\n\n**目标**：总结整个需求分析流程，提供后续建议\n\n**总结内容**：\n\n1. **需求总结**\n   - 核心功能回顾\n   - 实现的关键特性\n\n2. **成果清单**\n   - 完成的功能模块\n   - 创建的文件\n   - 编写的代码\n\n3. **质量指标**\n   - 审查发现的问题数量\n   - 修复情况\n   - 代码质量评分\n\n4. **后续建议**\n   - 进一步优化建议\n   - 潜在改进点\n   - 文档更新建议\n\n5. **经验教训**\n   - 遇到的挑战\n   - 解决方案\n   - 最佳实践\n\n**最终进度显示**：\n```markdown\n### [完成] 所有阶段完成！\n\n需求分析项目 - 100% 完成\n\n📝 阶段完成情况：\n[完成] 阶段 1: 需求理解\n[完成] 阶段 2: 代码库探索\n[跳过] 阶段 3: 外部资源研究 (跳过)\n[完成] 阶段 4: 澄清问题\n[完成] 阶段 5: 深度分析\n[完成] 阶段 6: 展示实施计划\n[完成] 阶段 7: 实施开发\n[完成] 阶段 8: 代码审查\n[完成] 阶段 9: 总结\n\n项目成功完成！\n```\n\n---\n\n## 重要原则\n\n1. **自适应语言交互**：根据用户的 Claude 语言设置和输入语言沟通\n2. **严格遵循 CLAUDE.md**：必须阅读并遵守项目规范\n3. **主动提问**：不清楚的地方必须澄清\n4. **合理使用 ultrathink**：阶段1可选，阶段5必须\n5. **善用外部资源**：需要时使用 context7、exa（带降级方案）\n6. **合理使用并行化**：复杂需求使用并行探索和审查，必须在单个消息中发起\n7. **必须代码审查**：实施完成后必须执行阶段 8\n8. **审查前征求确认**：使用 AskUserQuestion，不得自动修复\n9. **切勿急躁**：计划确认前不要编码\n10. **保持彻底**：考虑边缘情况、错误和性能\n\n---\n\n## 参考文档\n\n### 详细指南\n- [Task List 管理高级用法](references/task-list-management.md)\n- [并行模式详细示例](references/parallel-patterns.md)\n- [使用示例](references/examples.md)\n- [输出格式模板](assets/output-template.md)\n",
        "skills/requirement-analysis/assets/output-template.md": "# 输出格式模板 (Output Format Template)\n\n## 阶段 1-5: 分析和计划阶段\n\n```markdown\n## 🎯 需求理解\n- [我理解的要点列表]\n\n## 🔍 代码库探索结果\n- **CLAUDE.md 规范**: [项目规范的关键要点 - 命名约定、架构模式、编码规范等]\n- **发现**: [相关的现有代码]\n- **模式**: [要遵循的约定]\n\n## 🌐 外部资源研究（如适用）\n\n### 网页搜索结果\n- **搜索主题**: [搜索的具体问题或技术]\n- **关键发现**: [从搜索结果中提取的有价值信息]\n- **代码示例**: [相关的代码片段或实现方案]\n- **最佳实践**: [行业标准做法或推荐模式]\n\n### 库文档查询结果\n- **查询的库**: [库名称和版本]\n- **相关 API**: [查询到的 API 和方法]\n- **官方示例**: [官方文档中的代码示例]\n- **注意事项**: [使用限制、已知问题等]\n\n## ❓ 需要澄清的问题\n[AskUserQuestion 工具结果 或 \"无疑问 - 需求很清楚\"]\n\n## 🧠 深度分析 (使用 ultrathink)\n[Sequential Thinking 顺序思考结果 - 技术设计决策，必须体现如何遵循 CLAUDE.md 规范]\n\n## 📋 实施计划\n\n### 数据库设计\n[实体定义 - 遵循 CLAUDE.md 中的命名和字段规范]\n\n### API 端点\n[带方法和路径的端点列表 - 遵循 CLAUDE.md 中的 API 设计规范]\n\n### Service 层\n[服务方法签名和逻辑流程 - 遵循 CLAUDE.md 中的架构模式]\n\n### 实施步骤\n[编号的步骤列表 - 确保每步符合项目规范]\n\n### 风险和注意事项\n[需要注意的潜在问题]\n\n### 规范遵循检查\n- [ ] 数据库设计符合 CLAUDE.md 规范\n- [ ] API 端点符合 CLAUDE.md 规范\n- [ ] 代码结构符合 CLAUDE.md 规范\n- [ ] 命名约定符合 CLAUDE.md 规范\n\n## ✅ 准备好继续了吗？\n这个计划看起来如何？我可以开始实施了吗？\n```\n\n---\n\n## 阶段 7: 代码审查阶段\n\n```markdown\n## 🔍 代码审查结果\n\n### 审查模式\n- 使用模式: [单一审查 / 并行深度审查]\n- 审查文件数: [数量]\n- 审查时间: [时间]\n\n### 审查概要\n- **高严重性问题**: [数量] 个 🔴\n- **中严重性问题**: [数量] 个 🟡\n- **低严重性问题**: [数量] 个 🟢\n- **整体评价**: [优秀 / 良好 / 需要改进 / 存在严重问题]\n\n### 详细审查结果\n\n#### 1. 功能正确性 ✅/⚠️/❌\n[来自 Reviewer 1 的详细发现]\n- 发现的问题（如有）\n- 具体位置和描述\n- 严重性评级\n\n#### 2. 代码风格和质量 ✅/⚠️/❌\n[来自 Reviewer 2 的详细发现]\n- 发现的问题（如有）\n- 具体位置和描述\n- 改进建议\n\n#### 3. 简洁性/DRY/优雅性 ✅/⚠️/❌\n[来自 Reviewer 3 的详细发现]\n- 重复代码位置（如有）\n- 过度/不足抽象（如有）\n- 重构建议\n\n#### 4. 项目规范遵循 ✅/⚠️/❌\n[来自 Reviewer 4 的详细发现]\n- 规范违反项（如有）\n- 不符合 CLAUDE.md 的地方\n- 需要调整的部分\n\n#### 5. 项目约定和抽象 ✅/⚠️/❌\n[来自 Reviewer 5 的详细发现]\n- 未使用已有工具/模式的地方（如有）\n- 不合理的新抽象（如有）\n- 改进建议\n\n### 高严重性问题清单（需优先修复）\n1. [问题1 - 文件:行号 - 描述]\n2. [问题2 - 文件:行号 - 描述]\n...\n\n### 中严重性问题清单\n1. [问题1]\n2. [问题2]\n...\n\n### 低严重性问题和优化建议\n1. [建议1]\n2. [建议2]\n...\n```\n\n**重要提醒**：\n- ⚠️ 如果发现**严重Bug**、**安全漏洞**或**数据丢失风险**，必须在报告中明确标注为\"关键问题\"\n- ⚠️ 关键问题必须强烈建议用户立即修复\n- ✅ 对于代码风格、优化建议等低优先级问题，说明这些是可选的改进\n",
        "skills/requirement-analysis/references/examples.md": "# 使用示例\n\n## 复杂需求示例\n\n**用户**: \"我需要一个用户活动跟踪功能来记录用户操作，支持多租户隔离和实时分析\"\n\n**执行策略**：\n- **阶段 1**: 使用 ultrathink 分析需求（多模块、复杂逻辑）\n- **阶段 2**: 并行探索（3 个 agent：数据层、服务层、API层）\n- **阶段 3**: 外部资源研究（context7 查询实时分析库）\n- **阶段 4**: 澄清数据保留策略和操作类型\n- **阶段 5**: 使用 ultrathink 设计架构\n- **阶段 6**: 展示完整实施计划\n- **阶段 7**: 实施开发\n- **阶段 8**: 并行深度审查（5 个审查维度）\n- **阶段 9**: 总结\n\n---\n\n## 简单需求示例\n\n**用户**: \"给用户表添加一个手机号字段\"\n\n**执行策略**：\n- **阶段 1**: 跳过 ultrathink（简单 CRUD）\n- **阶段 2**: 基础探索（单个 agent）\n- **阶段 3**: 跳过外部资源研究\n- **阶段 4**: 澄清验证规则和是否允许为空\n- **阶段 5**: 使用 ultrathink 设计字段\n- **阶段 6**: 展示实施计划\n- **阶段 7**: 实施开发\n- **阶段 8**: 单一代码审查\n- **阶段 9**: 总结\n\n---\n\n## 新技术栈示例\n\n**用户**: \"使用 Socket.io 实现实时通知功能\"\n\n**执行策略**：\n- **阶段 1**: 识别需要使用第三方库\n- **阶段 2**: 查找现有 WebSocket 代码\n- **阶段 3**: 外部资源研究（context7 查询 Socket.io 文档）\n- **阶段 4**: 澄清通知类型和历史记录需求\n- **阶段 5**: 基于 Socket.io 最新 API 设计方案\n- **阶段 6**: 展示集成计划\n- **阶段 7**: 实施开发\n- **阶段 8**: 代码审查（确保正确使用 Socket.io API）\n- **阶段 9**: 总结\n",
        "skills/requirement-analysis/references/parallel-patterns.md": "# 并行模式指南\n\n## 核心规则\n\n> ⚠️ **必须在单个 message 中发起所有并行任务**\n>\n> 不能发送一个 message 调用 Task，等待结果，再发送另一个 message 调用另一个 Task。必须在同一个 response 中同时调用多个 Task 工具。\n\n---\n\n## 阶段 2: 并行探索\n\n### 何时使用\n\n- ✅ 需求涉及多个架构层次（数据层、服务层、API 层）\n- ✅ 需求涉及多个模块或子系统\n- ✅ 探索任务可以清晰分解为独立的子任务\n\n### 探索策略\n\n**策略 1：按架构层次分解**（推荐）\n- Agent 1：数据层探索（实体、数据库、迁移）\n- Agent 2：服务层探索（业务逻辑、验证、错误处理）\n- Agent 3：API 层探索（控制器、路由、请求/响应）\n\n**策略 2：按功能模块分解**\n- Agent 1：核心功能模块\n- Agent 2：关联功能模块\n- Agent 3：通用工具和模式\n\n### 并行数量建议\n\n- 简单需求：1 个 agent（使用基础探索模式）\n- 中等需求：2-3 个 agent\n- 复杂需求：3-5 个 agent\n- ⚠️ 不建议超过 5 个并行任务\n\n### 结果汇总\n\n1. 等待所有并行 agent 完成\n2. 整合各个 agent 的发现\n3. 识别重复信息并去重\n4. 组织成结构化的探索报告\n\n---\n\n## 阶段 8: 并行深度审查\n\n### 何时使用\n\n- ✅ 复杂需求，修改文件多（4+ 个文件）\n- ✅ 涉及多个架构层次或模块\n- ✅ 需要深度审查，确保高质量\n\n### 5 个审查维度\n\n**Reviewer 1**：功能正确性\n- 检查逻辑错误和潜在 Bug\n- 验证边缘情况处理\n\n**Reviewer 2**：代码风格和质量\n- 检查命名是否清晰一致\n- 评估代码可读性\n\n**Reviewer 3**：简洁性/DRY/优雅性\n- 识别重复代码（DRY 原则）\n- 评估抽象是否恰当\n\n**Reviewer 4**：项目规范遵循\n- 验证是否符合 CLAUDE.md 编码规范\n- 检查文件结构是否符合项目约定\n\n**Reviewer 5**：项目约定和抽象\n- 检查是否使用了项目已有工具和模式\n- 验证是否遵循项目架构模式\n\n### 结果汇总\n\n1. 等待所有并行审查完成\n2. 整合所有审查结果\n3. 按严重性分类问题（高、中、低）\n4. 组织成结构化的审查报告\n",
        "skills/requirement-analysis/references/task-list-management.md": "# Task List 管理\n\n## 核心功能\n\n本 skill 自动管理任务列表，提供以下功能：\n- **进度可视化**：实时显示当前执行阶段和完成进度\n- **工作流透明化**：清晰展示所有阶段流程和每个阶段的状态\n- **断点恢复**：支持中断后继续执行，自动识别断点\n- **任务可复用**：任务列表可被其他工作流引用\n\n## 进度显示格式\n\n每个阶段开始/结束时显示当前进度：\n\n```markdown\n### 任务进度\n[项目名称] - 总进度: X% (Y/N 阶段完成)\n\n[完成] 阶段 1: [名称] (已完成)\n[完成] 阶段 2: [名称] (已完成)\n[跳过] 阶段 3: [名称] (已跳过)\n[进行中] 阶段 4: [名称] (进行中...)\n[等待] 阶段 5-N: (等待中)\n```\n\n## 基本操作\n\n参见 SKILL.md \"Task List 管理\"章节的代码示例。\n\n## 高级特性\n\n### 条件执行阶段\n\n对于条件执行的阶段（如外部资源研究）：\n\n```markdown\n# 如果跳过此阶段\nTaskUpdate(task.id, status=\"completed\", metadata={note: \"不满足执行条件，已跳过\"})\n```\n\n### 断点恢复\n\n如果 skill 执行中断，使用以下方法恢复：\n\n1. **检查任务状态**: `TaskList()`\n2. **查找当前任务**: 找到 `in_progress` 或 `pending` 状态的任务\n3. **继续执行**: 从该任务继续\n4. **跳过已完成**: 已标记为 `completed` 的阶段自动跳过\n\n**恢复示例**：\n```markdown\n### 检测到未完成的任务列表\n\n[项目名称] - 当前进度: X%\n\n上次的进度：\n[完成] 阶段 1-N (已完成)\n[进行中] 阶段 N+1: [阶段名称] (进行中)\n\n是否从阶段 N+1 继续执行？\n```\n\n### 错误处理与降级\n\n如果 Task list 功能不可用（MCP 服务故障等），skill 会自动降级到无 Task list 模式，继续执行主流程，并向用户说明情况。\n\n```markdown\n### Task List 功能不可用\n\nTask list 功能暂时不可用，将使用标准模式执行工作流。\n\n[继续执行主流程...]\n```\n\n## 最终进度显示\n\n所有阶段完成后：\n\n```markdown\n### [完成] 所有阶段完成！\n\n[项目名称] - 100% 完成\n\n📝 阶段完成情况：\n[完成] 阶段 1: [阶段名称]\n[完成] 阶段 2: [阶段名称]\n[跳过] 阶段 3: [阶段名称] (已跳过)\n...\n[完成] 阶段 N: [阶段名称]\n\n项目成功完成！\n```\n"
      },
      "plugins": [
        {
          "name": "spec-dev",
          "description": "开发工作流插件集 - 包含功能开发和需求分析两大系统化工作流",
          "source": "./",
          "category": "development",
          "homepage": "https://github.com/FlameMida/spec-dev",
          "skills": [
            "./skills/feat-dev",
            "./skills/requirement-analysis"
          ],
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add FlameMida/spec-dev",
            "/plugin install spec-dev@spec-agent-skills"
          ]
        }
      ]
    }
  ]
}