{
  "author": {
    "id": "th3w1zard1",
    "display_name": "Boden",
    "avatar_url": "https://avatars.githubusercontent.com/u/2219836?u=fe68a9270a752e9b0043d5ab7e6f7cd4805d941b&v=4"
  },
  "marketplaces": [
    {
      "name": "reva",
      "version": null,
      "description": "ReVa - AI-assisted binary analysis and reverse engineering with Ghidra integration",
      "repo_full_name": "th3w1zard1/reverse-engineering-assistant",
      "repo_url": "https://github.com/th3w1zard1/reverse-engineering-assistant",
      "repo_description": "MCP server for reverse engineering tasks in Ghidra ðŸ‘©â€ðŸ’»",
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-21T05:47:22Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"reva\",\n  \"description\": \"ReVa - AI-assisted binary analysis and reverse engineering with Ghidra integration\",\n  \"owner\": {\n    \"name\": \"CyberKaida\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"ReVa\",\n      \"source\": \"./ReVa\",\n      \"description\": \"AI-assisted binary analysis and reverse engineering with Ghidra integration\"\n    }\n  ]\n}\n",
        "README.md": "# ReVa - Ghidra MCP Server for AI-Powered Reverse Engineering\n\n> A Ghidra extension that provides a [Model Context Protocol (MCP)](https://modelcontextprotocol.io/faqs) server for AI-assisted reverse engineering\n\nReVa (Reverse Engineering Assistant) is a **Ghidra MCP server** that enables AI language models to interact with Ghidra's powerful reverse engineering capabilities. ReVa uses\nstate of the art techniques to limit [context rot](https://github.com/chroma-core/context-rot) and enable\nlong form reverse engineering tasks.\n\nReVa is different from other efforts at building AI assistants for RE tasks because it uses a _tool driven approach_ with a focus\non designing tools for effective LLM use.\nReVa aims to provide a variety of small tools to the LLM, just as your RE environment provides a set of small tools\nto you.\n\nEach of the tools given to the LLM are constructed to be easy for the LLM to use and to tolerate a variety of inputs\nand to reduce hallucination by the LLM. We do this by providing the LLM with a schema but tolerating other input,\nincluding descriptions that guide the LLM,and redirecting correctable mistakes back to the LLM, and including extra\noutput to guide the next decision by the LLM.\n\nReVa's tools differ to other solutions, they provide smaller,\ncritical fragments with reinforcement and links to other\nrelevant information to reduce context usage and hallucination.\nThis greatly improves performance, especially on long form\nreverse engineering tasks. This allows ReVa to handle large\nbinaries and even entire firmware images.\n\nTo encourage exploration as a human would, we report additional context like the namespace and cross references along with the decompilation, this\nis a small nudge to make the LLM explore the binary in the same way a human would.\n\nUsing this technique you can ask general questions and get relevant answers. The model prioritises\ninformation from the tools, but when there is no information it can still respond to generic\nquestions from its training.\n\nAs an MCP server, ReVa can be used alongside other MCP servers to enrich its analysis.\nFor example you can use the [GitHub MCP Server](https://github.com/github/github-mcp-server)\nto allow ReVa access to source code on GitHub, or the\n[Kagi MCP Server](https://github.com/kagisearch/kagimcp) to allow ReVa to search the web.\n\nYou can ask questions like:\n\n- Examine the programs in this project and explain the relationship between the main binary and the shared libraries.\n- What are the interesting strings in this program?\n- Does this program use encryption? Write a markdown report on the encryption and where it is used.\n- Draw a class diagram using plantuml syntax.\n- Start from main, examine the program in detail. Rename variables as you go and provide a summary of the program.\n- Explain the purpose of the `__mod_init` segment.\n- What does `mmap` return?\n- What does the function at address 0x80000 do?\n- This is a CTF problem. Write a pwntools script to get the flag.\n\n## Table of Contents\n\n- [Installation](#installation)\n- [Usage](#usage)\n- [Configuration](#configuration)\n  - [Environment Variables](#environment-variables)\n- [Assistant Mode](#assistant-mode)\n  - [Claude Code (Assistant)](#claude-code-assistant)\n  - [VSCode (Assistant)](#vscode-assistant)\n- [Headless Mode](#headless-mode)\n  - [Claude Code (Headless)](#claude-code-headless)\n  - [PyGhidra Integration](#pyghidra-integration)\n- [Claude Code Marketplace](#claude-code-marketplace)\n- [Support](#support)\n\n## Installation\n\n> NOTE: ReVa only supports Ghidra 12.0 and above!\n\nReVa is a Ghidra extension. To install it, you can download the release for your\nversion of Ghidra from the releases page and install it using the Ghidra extension manager.\n\nAlternatively, you can build it from source. To do this, clone the repository and run the following command:\n\n```bash\nexport GHIDRA_INSTALL_DIR=/path/to/ghidra\ngradle install\n```\n\nAfter installing the extension you need to activate it in two places:\n\n1. In the Project view, open the File menu and select \"Configure\". Click the \"Configure all plugins\" button on the top right of the menu (it looks like a plug). Check the \"ReVa Application Plugin\"\n2. In the Code Browser tool (Click the Dragon icon or open a File), open the File menu and select \"Configure\". Click the \"Configure all plugins\" button on the top right of the menu (it looks like a plug). Check the \"ReVa Plugin\". Then Press File and select \"Save Tool\". This will enable ReVa by default.\n\n## Configuration\n\n### Environment Variables\n\nReVa supports configuring default parameter values via environment variables. This allows you to set global defaults for tool parameters without specifying them in every tool call.\n\nEnvironment variables follow the pattern: `REVA_<PARAMETER_NAME>` where `PARAMETER_NAME` is the parameter name in `UPPER_SNAKE_CASE`.\n\n**Examples:**\n\n```bash\n# Enable auto-suggestions by default (default: true)\nexport REVA_AUTO_SUGGEST=true\n\n# Set default max results for searches (default: varies by tool)\nexport REVA_MAX_RESULTS=500\n\n# Set default analyze after import (default: true)\nexport REVA_ANALYZE_AFTER_IMPORT=true\n\n# Set default recursive import (default: true)\nexport REVA_RECURSIVE=true\n```\n\n**Common Parameters:**\n\n- `REVA_ANALYZE_AFTER_IMPORT` - Run auto-analysis after importing files (default: `true`)\n- `REVA_RECURSIVE` - Recursively import from containers/archives (default: `true`)\n- `REVA_MAX_DEPTH` - Maximum depth for recursive imports (default: `10`)\n- `REVA_ENABLE_VERSION_CONTROL` - Add imported files to version control (default: `true`)\n- `REVA_MAX_RESULTS` - Maximum number of results to return (default: varies by tool)\n- `REVA_FILTER_DEFAULT_NAMES` - Filter out default Ghidra-generated names (default: `true`)\n- `REVA_AUTO_BOOKMARK_PERCENTILE` - Percentile threshold for automatic bookmarking (default: `97.0` = top 3%, range: 95.0-99.0)\n\n**Note:** Environment variables only affect default values when parameters are not explicitly provided in tool calls. Explicit parameters always take precedence.\n\n### Intelligent Features\n\nReVa includes several intelligent features that work automatically:\n\n- **Auto-Bookmarking**: Top 2-5% of addresses by reference count are automatically bookmarked with appropriate types\n- **Auto-Tagging**: Function tags are automatically applied based on API calls, libraries, and string patterns\n- **Auto-Labeling**: Function and variable names are automatically assigned based on context, strings, and API usage\n- **Auto-Commenting**: Comment types and text are automatically set based on address context\n\nThese features are enabled by default and controlled exclusively via environment variables (no tool parameters needed).\n\n## Usage\n\nThere are two ways to use ReVa, with the Ghidra UI in assistant mode or in headless mode. Headless mode is ideal for automation and CI/CD pipelines, while the assistant mode is great for interactive analysis.\n\nIn assistant mode, ReVa connects to your running Ghidra and can work with you on your project. It can work in real time on the same file or on other files in your project. This is useful for deep analysis, ReVa can help identify algorithms, rename variables, fix datatypes, and many other parts of analysis.\n\nIn headless mode, ReVa runs without the Ghidra UI. This is useful for automation, CI/CD pipelines, or when you want to run ReVa in a pipeline. ReVa manages starting Ghidra\nand projects for you. Projects in headless mode are ephemeral (session-scoped) and automatically cleaned up. This is useful when you do not need the Ghidra UI and want ReVa\nto work on its own.\n\nYou select which mode with the MCP configuration in your MCP client.\n\n## Assistant Mode\n\nIn assistant mode, you run Ghidra with ReVa installed and connect your MCP client to the ReVa MCP server running in Ghidra. You must first start Ghidra and open a project.\n\nReVa uses the [streamable MCP transport](https://modelcontextprotocol.io/docs/concepts/transports#streamable-http)\nand will listen on port `8080` by default, you can change this in the Ghidra settings from the project view. This allows many clients to connect to the same UI for interactive use.\n\n### Claude Code (Assistant)\n\nClaude Code is the recommended client for ReVa, performance is excellent and Claude Code\nhandles large binaries and projects well.\n\n```sh\nclaude mcp add --scope user --transport http ReVa -- http://localhost:8080/mcp/message\n```\n\nWhen you use the `claude` command with Ghidra open it will connect to the ReVa MCP server.\nYou can check with `/mcp` in the Claude Code chat to see if it is connected.\n\nTo enable all ReVa commands by default, and avoid prompts for tool use, you can use\nthe `/permissions` command in Claude Code and add a rule for `mcp__ReVa`. This will\nallow ReVa to use all of its tools without prompting you for permission.\n\n### VSCode (Assistant)\n\nVSCode has a built in MCP client, instructions to configure it can be found\nin the [GitHub Copilot documentation](https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_add-an-mcp-server-to-your-user-settings).\n\n```json\n{\n  \"mcp\": {\n    \"servers\": {\n      \"ReVa Assistant\": {\n        \"type\": \"http\",\n        \"url\": \"http://localhost:8080/mcp/message\"\n      }\n    }\n  }\n}\n```\n\n## Headless Mode\n\nReVa can run in headless Ghidra mode without the GUI, making it ideal for:\n\n- **Automation** - CI/CD pipelines and automated analysis\n- **Docker** - Containerized reverse engineering workflows\n- **PyGhidra** - Python-based automation\n\n### Claude Code (Headless)\n\n```bash\n# Set Ghidra installation directory, this must always be in your environment\nexport GHIDRA_INSTALL_DIR=/path/to/ghidra\nuv tool install reverse-engineering-assistant\nclaude mcp add --scope user ReVa -- mcp-reva\n\nclaude -p \"Import /bin/ls with ReVa and tell me how it works\"\n```\n\nA project will be created in the current working directory in `.reva/projects/`.\nIf you run claude from the same directory, you can import many files into the same project. Just ask ReVa to work on the new file.\n\n### PyGhidra Integration\n\nYou can also use ReVa directly from PyGhidra scripts:\n\n```python\nimport pyghidra\npyghidra.start()\n\nfrom reva.headless import RevaHeadlessLauncher\n\n# Start server\nlauncher = RevaHeadlessLauncher()\nlauncher.start()\n\nif launcher.waitForServer(30000):\n    print(f\"Server ready on port {launcher.getPort()}\")\n    # ... your analysis code with your agent ...\n\nlauncher.stop()\n```\n\n## Claude Code Marketplace\n\nThe ReVa repo includes a [Claude Code marketplace and plugins](https://claude.com/blog/claude-code-plugins)\nto make using ReVa easier. These include skills and scripts to help ReVa work better with Claude Code.\n\nYou can install with:\n\n```bash\nclaude plugin marketplace add th3w1zard1/reverse-engineering-assistant\n```\n\nThis will add the [ReVa skills](/ReVa/skills/) to your Claude Code installation.\n\n- Binary Triage\n- Deep Analysis\n- Cryptography Analysis\n- CTF guides\n\nI will be adding more skills over time to help with reverse engineering tasks.\n\n## Support\n\nDo you like my work? Want to support this project and others? Support me here: <https://github.com/sponsors/bolabaden> !\n"
      },
      "plugins": [
        {
          "name": "ReVa",
          "source": "./ReVa",
          "description": "AI-assisted binary analysis and reverse engineering with Ghidra integration",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add th3w1zard1/reverse-engineering-assistant",
            "/plugin install ReVa@reva"
          ]
        }
      ]
    }
  ]
}